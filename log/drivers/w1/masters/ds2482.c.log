commit b886d83c5b621abc84ff9616f14c529be3f6b147
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:55 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 441
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2 of the license
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 315 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190115.503150771@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/masters/ds2482.c b/drivers/w1/masters/ds2482.c
index 8f2b25f1614c..b471779c3e2c 100644
--- a/drivers/w1/masters/ds2482.c
+++ b/drivers/w1/masters/ds2482.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /**
  * ds2482.c - provides i2c to w1-master bridge(s)
  * Copyright (C) 2005  Ben Gardner <bgardner@wabtec.com>
@@ -7,10 +8,6 @@
  * There are two variations: -100 and -800, which have 1 or 8 1-wire ports.
  * The complete datasheet can be obtained from MAXIM's website at:
  *   http://www.maxim-ic.com/quick_view2.cfm/qv_pk/4382
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
  */
 
 #include <linux/module.h>

commit 5cb27d30fc3a281e830a2099d520b469e2b82008
Author: Mariusz Bialonczyk <manio@skyboo.net>
Date:   Mon Mar 4 12:23:36 2019 +0100

    w1: ds2482: cosmetic fixes after 54865314f5a1
    
    We have a helper function ds2482_calculate_config() which is calculating
    the config value, so just use it instead of passing the same variable
    in all calls to this function.
    
    Also fixes the placement of module parameters to match with:
    50fa2951bd74 (w1: Organize driver source to natural/common order)
    by Andrew F. Davis
    
    Signed-off-by: Mariusz Bialonczyk <manio@skyboo.net>
    Cc: Andrew Worsley <amworsley@gmail.com>
    Cc: Andrew F. Davis <afd@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/masters/ds2482.c b/drivers/w1/masters/ds2482.c
index 8b5e598ffdb3..8f2b25f1614c 100644
--- a/drivers/w1/masters/ds2482.c
+++ b/drivers/w1/masters/ds2482.c
@@ -37,6 +37,11 @@ module_param_named(active_pullup, ds2482_active_pullup, int, 0644);
 MODULE_PARM_DESC(active_pullup, "Active pullup (apply to all buses): " \
 				"0-disable, 1-enable (default)");
 
+/* extra configurations - e.g. 1WS */
+static int extra_config;
+module_param(extra_config, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(extra_config, "Extra Configuration settings 1=APU,2=PPM,3=SPU,8=1WS");
+
 /**
  * The DS2482 registers - there are 3 registers that are addressed by a read
  * pointer. The read pointer is set by the last command executed.
@@ -70,8 +75,6 @@ MODULE_PARM_DESC(active_pullup, "Active pullup (apply to all buses): " \
 #define DS2482_REG_CFG_PPM		0x02	/* presence pulse masking */
 #define DS2482_REG_CFG_APU		0x01	/* active pull-up */
 
-/* extra configurations - e.g. 1WS */
-static int extra_config;
 
 /**
  * Write and verify codes for the CHANNEL_SELECT command (DS2482-800 only).
@@ -130,6 +133,8 @@ struct ds2482_data {
  */
 static inline u8 ds2482_calculate_config(u8 conf)
 {
+	conf |= extra_config;
+
 	if (ds2482_active_pullup)
 		conf |= DS2482_REG_CFG_APU;
 
@@ -405,7 +410,7 @@ static u8 ds2482_w1_reset_bus(void *data)
 		/* If the chip did reset since detect, re-config it */
 		if (err & DS2482_REG_STS_RST)
 			ds2482_send_cmd_data(pdev, DS2482_CMD_WRITE_CONFIG,
-					ds2482_calculate_config(extra_config));
+					     ds2482_calculate_config(0x00));
 	}
 
 	mutex_unlock(&pdev->access_lock);
@@ -431,7 +436,8 @@ static u8 ds2482_w1_set_pullup(void *data, int delay)
 		ds2482_wait_1wire_idle(pdev);
 		/* note: it seems like both SPU and APU have to be set! */
 		retval = ds2482_send_cmd_data(pdev, DS2482_CMD_WRITE_CONFIG,
-			ds2482_calculate_config(extra_config|DS2482_REG_CFG_SPU|DS2482_REG_CFG_APU));
+			ds2482_calculate_config(DS2482_REG_CFG_SPU |
+						DS2482_REG_CFG_APU));
 		ds2482_wait_1wire_idle(pdev);
 	}
 
@@ -484,7 +490,7 @@ static int ds2482_probe(struct i2c_client *client,
 
 	/* Set all config items to 0 (off) */
 	ds2482_send_cmd_data(data, DS2482_CMD_WRITE_CONFIG,
-		ds2482_calculate_config(extra_config));
+		ds2482_calculate_config(0x00));
 
 	mutex_init(&data->access_lock);
 
@@ -559,7 +565,5 @@ module_i2c_driver(ds2482_driver);
 
 MODULE_AUTHOR("Ben Gardner <bgardner@wabtec.com>");
 MODULE_DESCRIPTION("DS2482 driver");
-module_param(extra_config, int, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(extra_config, "Extra Configuration settings 1=APU,2=PPM,3=SPU,8=1WS");
 
 MODULE_LICENSE("GPL");

commit c6446c210f2b658ce5a7abc5b9763447910d751d
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Jun 21 18:08:06 2018 +0100

    w1: ds2482: make module parameter extra_config static
    
    The variable extra_config is local to the source and does not
    need to be in global scope, so make it static.
    
    Cleans up sparse warning:
    warning: symbol 'extra_config' was not declared. Should it be static?
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/masters/ds2482.c b/drivers/w1/masters/ds2482.c
index 5b3e017d9276..8b5e598ffdb3 100644
--- a/drivers/w1/masters/ds2482.c
+++ b/drivers/w1/masters/ds2482.c
@@ -71,7 +71,7 @@ MODULE_PARM_DESC(active_pullup, "Active pullup (apply to all buses): " \
 #define DS2482_REG_CFG_APU		0x01	/* active pull-up */
 
 /* extra configurations - e.g. 1WS */
-int extra_config;
+static int extra_config;
 
 /**
  * Write and verify codes for the CHANNEL_SELECT command (DS2482-800 only).

commit 54865314f5a1bfade1555ca6b26653729a0f3e23
Author: Andrew Worsley <amworsley@gmail.com>
Date:   Sun Aug 27 21:34:22 2017 +1000

    drivers: w1: Extend 1W master driver DS2482 with module option to support PPM/SPU/1WS features
    
    Extend the one wire DS2482 master driver with a module option that allows support
    for PPM/SPU/1WS interface modes to be requested. This allows support of chips
    that require one or more of these features such as the DS28E05.
    
    Signed-off-by: Andrew Worsley <amworsley@gmail.com>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/masters/ds2482.c b/drivers/w1/masters/ds2482.c
index d49681cd29af..5b3e017d9276 100644
--- a/drivers/w1/masters/ds2482.c
+++ b/drivers/w1/masters/ds2482.c
@@ -70,6 +70,8 @@ MODULE_PARM_DESC(active_pullup, "Active pullup (apply to all buses): " \
 #define DS2482_REG_CFG_PPM		0x02	/* presence pulse masking */
 #define DS2482_REG_CFG_APU		0x01	/* active pull-up */
 
+/* extra configurations - e.g. 1WS */
+int extra_config;
 
 /**
  * Write and verify codes for the CHANNEL_SELECT command (DS2482-800 only).
@@ -403,7 +405,7 @@ static u8 ds2482_w1_reset_bus(void *data)
 		/* If the chip did reset since detect, re-config it */
 		if (err & DS2482_REG_STS_RST)
 			ds2482_send_cmd_data(pdev, DS2482_CMD_WRITE_CONFIG,
-					     ds2482_calculate_config(0x00));
+					ds2482_calculate_config(extra_config));
 	}
 
 	mutex_unlock(&pdev->access_lock);
@@ -429,8 +431,7 @@ static u8 ds2482_w1_set_pullup(void *data, int delay)
 		ds2482_wait_1wire_idle(pdev);
 		/* note: it seems like both SPU and APU have to be set! */
 		retval = ds2482_send_cmd_data(pdev, DS2482_CMD_WRITE_CONFIG,
-			ds2482_calculate_config(DS2482_REG_CFG_SPU |
-						DS2482_REG_CFG_APU));
+			ds2482_calculate_config(extra_config|DS2482_REG_CFG_SPU|DS2482_REG_CFG_APU));
 		ds2482_wait_1wire_idle(pdev);
 	}
 
@@ -483,7 +484,7 @@ static int ds2482_probe(struct i2c_client *client,
 
 	/* Set all config items to 0 (off) */
 	ds2482_send_cmd_data(data, DS2482_CMD_WRITE_CONFIG,
-		ds2482_calculate_config(0x00));
+		ds2482_calculate_config(extra_config));
 
 	mutex_init(&data->access_lock);
 
@@ -558,4 +559,7 @@ module_i2c_driver(ds2482_driver);
 
 MODULE_AUTHOR("Ben Gardner <bgardner@wabtec.com>");
 MODULE_DESCRIPTION("DS2482 driver");
+module_param(extra_config, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(extra_config, "Extra Configuration settings 1=APU,2=PPM,3=SPU,8=1WS");
+
 MODULE_LICENSE("GPL");

commit de0d6dbdbdb23ddb85f10d54a516e794f9a873e0
Author: Andrew F. Davis <afd@ti.com>
Date:   Mon Jun 5 08:52:08 2017 -0500

    w1: Add subsystem kernel public interface
    
    Like other subsystems we should be able to define slave devices outside
    of the w1 directory. To do this we move public facing interface
    definitions to include/linux/w1.h and rename the internal definition
    file to w1_internal.h.
    
    As w1_family.h and w1_int.h contained almost entirely public
    driver interface definitions we simply removed these files and
    moved the remaining definitions into w1_internal.h.
    
    With this we can now start to move slave devices out of w1/slaves and
    into the subsystem based on the function they implement, again like
    other drivers.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>
    Reviewed-by: Sebastian Reichel <sre@kernel.org>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/masters/ds2482.c b/drivers/w1/masters/ds2482.c
index e8730ea3e3aa..d49681cd29af 100644
--- a/drivers/w1/masters/ds2482.c
+++ b/drivers/w1/masters/ds2482.c
@@ -20,8 +20,7 @@
 #include <linux/delay.h>
 #include <asm/delay.h>
 
-#include "../w1.h"
-#include "../w1_int.h"
+#include <linux/w1.h>
 
 /**
  * Allow the active pullup to be disabled, default is enabled.

commit 50fa2951bd744d2a82aa33074001efac12d4e1cf
Author: Andrew F. Davis <afd@ti.com>
Date:   Tue May 16 15:02:12 2017 -0500

    w1: Organize driver source to natural/common order
    
    Structures and functions should be ordered such that forward declaration
    use is minimized.
    
    MODULE_* macros should immediately follow the structures and functions
    upon which they act.
    
    Remaining MODULE_* macros should be at the end of the file in
    alphabetical order.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/masters/ds2482.c b/drivers/w1/masters/ds2482.c
index 2e30db1b1a43..e8730ea3e3aa 100644
--- a/drivers/w1/masters/ds2482.c
+++ b/drivers/w1/masters/ds2482.c
@@ -35,6 +35,8 @@
  */
 static int ds2482_active_pullup = 1;
 module_param_named(active_pullup, ds2482_active_pullup, int, 0644);
+MODULE_PARM_DESC(active_pullup, "Active pullup (apply to all buses): " \
+				"0-disable, 1-enable (default)");
 
 /**
  * The DS2482 registers - there are 3 registers that are addressed by a read
@@ -93,30 +95,6 @@ static const u8 ds2482_chan_rd[8] =
 #define DS2482_REG_STS_PPD		0x02
 #define DS2482_REG_STS_1WB		0x01
 
-
-static int ds2482_probe(struct i2c_client *client,
-			const struct i2c_device_id *id);
-static int ds2482_remove(struct i2c_client *client);
-
-
-/**
- * Driver data (common to all clients)
- */
-static const struct i2c_device_id ds2482_id[] = {
-	{ "ds2482", 0 },
-	{ }
-};
-MODULE_DEVICE_TABLE(i2c, ds2482_id);
-
-static struct i2c_driver ds2482_driver = {
-	.driver = {
-		.name	= "ds2482",
-	},
-	.probe		= ds2482_probe,
-	.remove		= ds2482_remove,
-	.id_table	= ds2482_id,
-};
-
 /*
  * Client data (each client gets its own)
  */
@@ -560,10 +538,25 @@ static int ds2482_remove(struct i2c_client *client)
 	return 0;
 }
 
+/**
+ * Driver data (common to all clients)
+ */
+static const struct i2c_device_id ds2482_id[] = {
+	{ "ds2482", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ds2482_id);
+
+static struct i2c_driver ds2482_driver = {
+	.driver = {
+		.name	= "ds2482",
+	},
+	.probe		= ds2482_probe,
+	.remove		= ds2482_remove,
+	.id_table	= ds2482_id,
+};
 module_i2c_driver(ds2482_driver);
 
-MODULE_PARM_DESC(active_pullup, "Active pullup (apply to all buses): " \
-				"0-disable, 1-enable (default)");
 MODULE_AUTHOR("Ben Gardner <bgardner@wabtec.com>");
 MODULE_DESCRIPTION("DS2482 driver");
 MODULE_LICENSE("GPL");

commit f704938c0ef1e3224e66b16d5b358f02cd351240
Author: Mariusz Bialonczyk <manio@skyboo.net>
Date:   Tue Mar 29 18:41:38 2016 +0200

    w1: enable active pullup for DS2482 by default
    
    This commit enables the active pullup (APU bit) by default for
    the DS2482 1-Wire master.
    
    >From the DS2482 datasheet:
    "The APU bit controls whether an active pullup (controlled slew-rate
    transistor) or a passive pullup (Rwpu resistor) will be used to drive
    a 1-Wire line from low to high. When APU = 0, active pullup is disabled
    (resistor mode). Active Pullup should always be selected unless there is
    only a single slave on the 1-Wire line."
    
    According to the module author, Ben Gardner:
    "It doesn't look like active pullup would cause any hurt if there
    is only a single slave."
    And my tests with multiple and single slaves on 1-Wire bus
    confirms that.
    
    This active pullup can be manually disabled using the introduced
    module parameter:
      active_pullup = 0
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/masters/ds2482.c b/drivers/w1/masters/ds2482.c
index b05e8fefbabd..2e30db1b1a43 100644
--- a/drivers/w1/masters/ds2482.c
+++ b/drivers/w1/masters/ds2482.c
@@ -23,6 +23,19 @@
 #include "../w1.h"
 #include "../w1_int.h"
 
+/**
+ * Allow the active pullup to be disabled, default is enabled.
+ *
+ * Note from the DS2482 datasheet:
+ * The APU bit controls whether an active pullup (controlled slew-rate
+ * transistor) or a passive pullup (Rwpu resistor) will be used to drive
+ * a 1-Wire line from low to high. When APU = 0, active pullup is disabled
+ * (resistor mode). Active Pullup should always be selected unless there is
+ * only a single slave on the 1-Wire line.
+ */
+static int ds2482_active_pullup = 1;
+module_param_named(active_pullup, ds2482_active_pullup, int, 0644);
+
 /**
  * The DS2482 registers - there are 3 registers that are addressed by a read
  * pointer. The read pointer is set by the last command executed.
@@ -138,6 +151,9 @@ struct ds2482_data {
  */
 static inline u8 ds2482_calculate_config(u8 conf)
 {
+	if (ds2482_active_pullup)
+		conf |= DS2482_REG_CFG_APU;
+
 	return conf | ((~conf & 0x0f) << 4);
 }
 
@@ -546,6 +562,8 @@ static int ds2482_remove(struct i2c_client *client)
 
 module_i2c_driver(ds2482_driver);
 
+MODULE_PARM_DESC(active_pullup, "Active pullup (apply to all buses): " \
+				"0-disable, 1-enable (default)");
 MODULE_AUTHOR("Ben Gardner <bgardner@wabtec.com>");
 MODULE_DESCRIPTION("DS2482 driver");
 MODULE_LICENSE("GPL");

commit 01c48a59bae36f08ba27ed6bfe789aa0d14ee2a1
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Fri Jul 10 15:38:10 2015 +0900

    w1: Drop owner assignment from i2c_driver
    
    i2c_driver does not need to set an owner because i2c_register_driver()
    will set it.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/masters/ds2482.c b/drivers/w1/masters/ds2482.c
index a674409edfb3..b05e8fefbabd 100644
--- a/drivers/w1/masters/ds2482.c
+++ b/drivers/w1/masters/ds2482.c
@@ -97,7 +97,6 @@ MODULE_DEVICE_TABLE(i2c, ds2482_id);
 
 static struct i2c_driver ds2482_driver = {
 	.driver = {
-		.owner	= THIS_MODULE,
 		.name	= "ds2482",
 	},
 	.probe		= ds2482_probe,

commit 0dcacd768ea6fc5bdd7302d43d430b92e047c134
Author: Ludek Hlavacek <ludek_h@seznam.cz>
Date:   Wed May 27 00:37:59 2015 +0200

    w1: ds2482: Add i2c module alias name
    
    Add i2c alias to enable autoloading of the module for device specified
    in device-tree.
    
    Signed-off-by: Ludek Hlavacek <ludek_h@seznam.cz>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/masters/ds2482.c b/drivers/w1/masters/ds2482.c
index e76a9b39abb2..a674409edfb3 100644
--- a/drivers/w1/masters/ds2482.c
+++ b/drivers/w1/masters/ds2482.c
@@ -93,6 +93,7 @@ static const struct i2c_device_id ds2482_id[] = {
 	{ "ds2482", 0 },
 	{ }
 };
+MODULE_DEVICE_TABLE(i2c, ds2482_id);
 
 static struct i2c_driver ds2482_driver = {
 	.driver = {

commit 1fda5690906b20ce823964eaac32baa8d3a03f61
Author: Fjodor Schelichow <fjodor.schelichow@hotmail.com>
Date:   Thu Jun 19 02:52:01 2014 +0200

    w1/masters: use pr_* instead of printk
    
    This patch replaces all calls to the "printk" function within the "masters"
    subdirectory by calls to the appropriate "pr_*" function thus addressing
    the following warning generated by the checkpatch script:
    
    WARNING: Prefer [subsystem eg: netdev]_err([subsystem]dev, ...
            then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
    
    Signed-off-by: Fjodor Schelichow <fjodor.schelichow@hotmail.com>
    Signed-off-by: Roman Sommer <romsom2@yahoo.de>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/masters/ds2482.c b/drivers/w1/masters/ds2482.c
index e033491fe308..e76a9b39abb2 100644
--- a/drivers/w1/masters/ds2482.c
+++ b/drivers/w1/masters/ds2482.c
@@ -226,7 +226,7 @@ static int ds2482_wait_1wire_idle(struct ds2482_data *pdev)
 	}
 
 	if (retries >= DS2482_WAIT_IDLE_TIMEOUT)
-		printk(KERN_ERR "%s: timeout on channel %d\n",
+		pr_err("%s: timeout on channel %d\n",
 		       __func__, pdev->channel);
 
 	return temp;

commit 9c95bb6f25ff802081125f24bf0c756252fa27b2
Author: Michael Arndt <michael@scriptkiller.de>
Date:   Sun Feb 17 20:31:27 2013 +0100

    w1: ds2482: Added 1-Wire pull-up support to the driver
    
    Signed-off-by: Michael Arndt <michael@scriptkiller.de>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/masters/ds2482.c b/drivers/w1/masters/ds2482.c
index 6429b9e9fb82..e033491fe308 100644
--- a/drivers/w1/masters/ds2482.c
+++ b/drivers/w1/masters/ds2482.c
@@ -51,10 +51,10 @@
  * The top 4 bits always read 0.
  * To write, the top nibble must be the 1's compl. of the low nibble.
  */
-#define DS2482_REG_CFG_1WS		0x08
-#define DS2482_REG_CFG_SPU		0x04
-#define DS2482_REG_CFG_PPM		0x02
-#define DS2482_REG_CFG_APU		0x01
+#define DS2482_REG_CFG_1WS		0x08	/* 1-wire speed */
+#define DS2482_REG_CFG_SPU		0x04	/* strong pull-up */
+#define DS2482_REG_CFG_PPM		0x02	/* presence pulse masking */
+#define DS2482_REG_CFG_APU		0x01	/* active pull-up */
 
 
 /**
@@ -131,6 +131,17 @@ struct ds2482_data {
 };
 
 
+/**
+ * Helper to calculate values for configuration register
+ * @param conf the raw config value
+ * @return the value w/ complements that can be written to register
+ */
+static inline u8 ds2482_calculate_config(u8 conf)
+{
+	return conf | ((~conf & 0x0f) << 4);
+}
+
+
 /**
  * Sets the read pointer.
  * @param pdev		The ds2482 client pointer
@@ -399,7 +410,7 @@ static u8 ds2482_w1_reset_bus(void *data)
 		/* If the chip did reset since detect, re-config it */
 		if (err & DS2482_REG_STS_RST)
 			ds2482_send_cmd_data(pdev, DS2482_CMD_WRITE_CONFIG,
-					     0xF0);
+					     ds2482_calculate_config(0x00));
 	}
 
 	mutex_unlock(&pdev->access_lock);
@@ -407,6 +418,32 @@ static u8 ds2482_w1_reset_bus(void *data)
 	return retval;
 }
 
+static u8 ds2482_w1_set_pullup(void *data, int delay)
+{
+	struct ds2482_w1_chan *pchan = data;
+	struct ds2482_data    *pdev = pchan->pdev;
+	u8 retval = 1;
+
+	/* if delay is non-zero activate the pullup,
+	 * the strong pullup will be automatically deactivated
+	 * by the master, so do not explicitly deactive it
+	 */
+	if (delay) {
+		/* both waits are crucial, otherwise devices might not be
+		 * powered long enough, causing e.g. a w1_therm sensor to
+		 * provide wrong conversion results
+		 */
+		ds2482_wait_1wire_idle(pdev);
+		/* note: it seems like both SPU and APU have to be set! */
+		retval = ds2482_send_cmd_data(pdev, DS2482_CMD_WRITE_CONFIG,
+			ds2482_calculate_config(DS2482_REG_CFG_SPU |
+						DS2482_REG_CFG_APU));
+		ds2482_wait_1wire_idle(pdev);
+	}
+
+	return retval;
+}
+
 
 static int ds2482_probe(struct i2c_client *client,
 			const struct i2c_device_id *id)
@@ -452,7 +489,8 @@ static int ds2482_probe(struct i2c_client *client,
 		data->w1_count = 8;
 
 	/* Set all config items to 0 (off) */
-	ds2482_send_cmd_data(data, DS2482_CMD_WRITE_CONFIG, 0xF0);
+	ds2482_send_cmd_data(data, DS2482_CMD_WRITE_CONFIG,
+		ds2482_calculate_config(0x00));
 
 	mutex_init(&data->access_lock);
 
@@ -468,6 +506,7 @@ static int ds2482_probe(struct i2c_client *client,
 		data->w1_ch[idx].w1_bm.touch_bit  = ds2482_w1_touch_bit;
 		data->w1_ch[idx].w1_bm.triplet    = ds2482_w1_triplet;
 		data->w1_ch[idx].w1_bm.reset_bus  = ds2482_w1_reset_bus;
+		data->w1_ch[idx].w1_bm.set_pullup = ds2482_w1_set_pullup;
 
 		err = w1_add_master_device(&data->w1_ch[idx].w1_bm);
 		if (err) {

commit dbfd5ccc057fbefb7247614741efbf96be0258c5
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Mon Oct 8 22:06:07 2012 +0800

    w1/ds2482: use module_i2c_driver to simplify the code
    
    Use the module_i2c_driver() macro to make the code smaller
    and a bit simpler.
    
    dpatch engine is used to auto generate this patch.
    (https://github.com/weiyj/dpatch)
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/masters/ds2482.c b/drivers/w1/masters/ds2482.c
index e5f74416d4b7..6429b9e9fb82 100644
--- a/drivers/w1/masters/ds2482.c
+++ b/drivers/w1/masters/ds2482.c
@@ -505,19 +505,8 @@ static int ds2482_remove(struct i2c_client *client)
 	return 0;
 }
 
-static int __init sensors_ds2482_init(void)
-{
-	return i2c_add_driver(&ds2482_driver);
-}
-
-static void __exit sensors_ds2482_exit(void)
-{
-	i2c_del_driver(&ds2482_driver);
-}
+module_i2c_driver(ds2482_driver);
 
 MODULE_AUTHOR("Ben Gardner <bgardner@wabtec.com>");
 MODULE_DESCRIPTION("DS2482 driver");
 MODULE_LICENSE("GPL");
-
-module_init(sensors_ds2482_init);
-module_exit(sensors_ds2482_exit);

commit 6786073927c3ff3eb7fc3d2192e761e86fa0d352
Author: Roel Kluin <roel.kluin@gmail.com>
Date:   Wed Mar 10 15:23:49 2010 -0800

    w1: fix test in ds2482_wait_1wire_idle()
    
    With `while (++retries < DS2482_WAIT_IDLE_TIMEOUT)' retries reaches
    DS2482_WAIT_IDLE_TIMEOUT after the loop
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Cc: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/w1/masters/ds2482.c b/drivers/w1/masters/ds2482.c
index 406caa6a71cb..e5f74416d4b7 100644
--- a/drivers/w1/masters/ds2482.c
+++ b/drivers/w1/masters/ds2482.c
@@ -214,7 +214,7 @@ static int ds2482_wait_1wire_idle(struct ds2482_data *pdev)
 			 (++retries < DS2482_WAIT_IDLE_TIMEOUT));
 	}
 
-	if (retries > DS2482_WAIT_IDLE_TIMEOUT)
+	if (retries >= DS2482_WAIT_IDLE_TIMEOUT)
 		printk(KERN_ERR "%s: timeout on channel %d\n",
 		       __func__, pdev->channel);
 

commit 0314b020c49c1d6cd182d2b89775bfa6686660db
Author: Jean Delvare <khali@linux-fr.org>
Date:   Sun Oct 4 22:53:41 2009 +0200

    ds2482: Discard obsolete detect method
    
    There is no point in implementing a detect callback for the DS2482, as
    this device can't be detected. It was there solely to handle "force"
    module parameters to instantiate devices, but now we have a better sysfs
    interface that can do the same.
    
    So we can get rid of the ugly module parameters and the detect callback.
    This shrinks the binary module size by 21%.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Acked-by: Ben Gardner <gardner.ben@gmail.com>

diff --git a/drivers/w1/masters/ds2482.c b/drivers/w1/masters/ds2482.c
index df52cb355f7d..406caa6a71cb 100644
--- a/drivers/w1/masters/ds2482.c
+++ b/drivers/w1/masters/ds2482.c
@@ -23,19 +23,6 @@
 #include "../w1.h"
 #include "../w1_int.h"
 
-/**
- * Address is selected using 2 pins, resulting in 4 possible addresses.
- *  0x18, 0x19, 0x1a, 0x1b
- * However, the chip cannot be detected without doing an i2c write,
- * so use the force module parameter.
- */
-static const unsigned short normal_i2c[] = { I2C_CLIENT_END };
-
-/**
- * Insmod parameters
- */
-I2C_CLIENT_INSMOD_1(ds2482);
-
 /**
  * The DS2482 registers - there are 3 registers that are addressed by a read
  * pointer. The read pointer is set by the last command executed.
@@ -96,8 +83,6 @@ static const u8 ds2482_chan_rd[8] =
 
 static int ds2482_probe(struct i2c_client *client,
 			const struct i2c_device_id *id);
-static int ds2482_detect(struct i2c_client *client, int kind,
-			 struct i2c_board_info *info);
 static int ds2482_remove(struct i2c_client *client);
 
 
@@ -117,8 +102,6 @@ static struct i2c_driver ds2482_driver = {
 	.probe		= ds2482_probe,
 	.remove		= ds2482_remove,
 	.id_table	= ds2482_id,
-	.detect		= ds2482_detect,
-	.address_data	= &addr_data,
 };
 
 /*
@@ -425,19 +408,6 @@ static u8 ds2482_w1_reset_bus(void *data)
 }
 
 
-static int ds2482_detect(struct i2c_client *client, int kind,
-			 struct i2c_board_info *info)
-{
-	if (!i2c_check_functionality(client->adapter,
-				     I2C_FUNC_SMBUS_WRITE_BYTE_DATA |
-				     I2C_FUNC_SMBUS_BYTE))
-		return -ENODEV;
-
-	strlcpy(info->type, "ds2482", I2C_NAME_SIZE);
-
-	return 0;
-}
-
 static int ds2482_probe(struct i2c_client *client,
 			const struct i2c_device_id *id)
 {
@@ -446,6 +416,11 @@ static int ds2482_probe(struct i2c_client *client,
 	int temp1;
 	int idx;
 
+	if (!i2c_check_functionality(client->adapter,
+				     I2C_FUNC_SMBUS_WRITE_BYTE_DATA |
+				     I2C_FUNC_SMBUS_BYTE))
+		return -ENODEV;
+
 	if (!(data = kzalloc(sizeof(struct ds2482_data), GFP_KERNEL))) {
 		err = -ENOMEM;
 		goto exit;

commit 61c91f7ded640bb2b340cc89d9ca3a3ca0229c74
Author: Jean Delvare <khali@linux-fr.org>
Date:   Wed Jul 16 19:30:07 2008 +0200

    w1/ds2482: Convert to a new-style driver
    
    The new-style ds2482 driver implements the optional detect() callback
    to cover the use cases of the legacy driver. I'm curious if anyone
    really needs this though, so it might be removed in the feature.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>

diff --git a/drivers/w1/masters/ds2482.c b/drivers/w1/masters/ds2482.c
index 0fd5820d5c61..df52cb355f7d 100644
--- a/drivers/w1/masters/ds2482.c
+++ b/drivers/w1/masters/ds2482.c
@@ -94,21 +94,31 @@ static const u8 ds2482_chan_rd[8] =
 #define DS2482_REG_STS_1WB		0x01
 
 
-static int ds2482_attach_adapter(struct i2c_adapter *adapter);
-static int ds2482_detect(struct i2c_adapter *adapter, int address, int kind);
-static int ds2482_detach_client(struct i2c_client *client);
+static int ds2482_probe(struct i2c_client *client,
+			const struct i2c_device_id *id);
+static int ds2482_detect(struct i2c_client *client, int kind,
+			 struct i2c_board_info *info);
+static int ds2482_remove(struct i2c_client *client);
 
 
 /**
  * Driver data (common to all clients)
  */
+static const struct i2c_device_id ds2482_id[] = {
+	{ "ds2482", 0 },
+	{ }
+};
+
 static struct i2c_driver ds2482_driver = {
 	.driver = {
 		.owner	= THIS_MODULE,
 		.name	= "ds2482",
 	},
-	.attach_adapter	= ds2482_attach_adapter,
-	.detach_client	= ds2482_detach_client,
+	.probe		= ds2482_probe,
+	.remove		= ds2482_remove,
+	.id_table	= ds2482_id,
+	.detect		= ds2482_detect,
+	.address_data	= &addr_data,
 };
 
 /*
@@ -124,7 +134,7 @@ struct ds2482_w1_chan {
 };
 
 struct ds2482_data {
-	struct i2c_client	client;
+	struct i2c_client	*client;
 	struct mutex		access_lock;
 
 	/* 1-wire interface(s) */
@@ -147,7 +157,7 @@ struct ds2482_data {
 static inline int ds2482_select_register(struct ds2482_data *pdev, u8 read_ptr)
 {
 	if (pdev->read_prt != read_ptr) {
-		if (i2c_smbus_write_byte_data(&pdev->client,
+		if (i2c_smbus_write_byte_data(pdev->client,
 					      DS2482_CMD_SET_READ_PTR,
 					      read_ptr) < 0)
 			return -1;
@@ -167,7 +177,7 @@ static inline int ds2482_select_register(struct ds2482_data *pdev, u8 read_ptr)
  */
 static inline int ds2482_send_cmd(struct ds2482_data *pdev, u8 cmd)
 {
-	if (i2c_smbus_write_byte(&pdev->client, cmd) < 0)
+	if (i2c_smbus_write_byte(pdev->client, cmd) < 0)
 		return -1;
 
 	pdev->read_prt = DS2482_PTR_CODE_STATUS;
@@ -187,7 +197,7 @@ static inline int ds2482_send_cmd(struct ds2482_data *pdev, u8 cmd)
 static inline int ds2482_send_cmd_data(struct ds2482_data *pdev,
 				       u8 cmd, u8 byte)
 {
-	if (i2c_smbus_write_byte_data(&pdev->client, cmd, byte) < 0)
+	if (i2c_smbus_write_byte_data(pdev->client, cmd, byte) < 0)
 		return -1;
 
 	/* all cmds leave in STATUS, except CONFIG */
@@ -216,7 +226,7 @@ static int ds2482_wait_1wire_idle(struct ds2482_data *pdev)
 
 	if (!ds2482_select_register(pdev, DS2482_PTR_CODE_STATUS)) {
 		do {
-			temp = i2c_smbus_read_byte(&pdev->client);
+			temp = i2c_smbus_read_byte(pdev->client);
 		} while ((temp >= 0) && (temp & DS2482_REG_STS_1WB) &&
 			 (++retries < DS2482_WAIT_IDLE_TIMEOUT));
 	}
@@ -238,13 +248,13 @@ static int ds2482_wait_1wire_idle(struct ds2482_data *pdev)
  */
 static int ds2482_set_channel(struct ds2482_data *pdev, u8 channel)
 {
-	if (i2c_smbus_write_byte_data(&pdev->client, DS2482_CMD_CHANNEL_SELECT,
+	if (i2c_smbus_write_byte_data(pdev->client, DS2482_CMD_CHANNEL_SELECT,
 				      ds2482_chan_wr[channel]) < 0)
 		return -1;
 
 	pdev->read_prt = DS2482_PTR_CODE_CHANNEL;
 	pdev->channel = -1;
-	if (i2c_smbus_read_byte(&pdev->client) == ds2482_chan_rd[channel]) {
+	if (i2c_smbus_read_byte(pdev->client) == ds2482_chan_rd[channel]) {
 		pdev->channel = channel;
 		return 0;
 	}
@@ -368,7 +378,7 @@ static u8 ds2482_w1_read_byte(void *data)
 	ds2482_select_register(pdev, DS2482_PTR_CODE_DATA);
 
 	/* Read the data byte */
-	result = i2c_smbus_read_byte(&pdev->client);
+	result = i2c_smbus_read_byte(pdev->client);
 
 	mutex_unlock(&pdev->access_lock);
 
@@ -415,47 +425,38 @@ static u8 ds2482_w1_reset_bus(void *data)
 }
 
 
-/**
- * Called to see if the device exists on an i2c bus.
- */
-static int ds2482_attach_adapter(struct i2c_adapter *adapter)
+static int ds2482_detect(struct i2c_client *client, int kind,
+			 struct i2c_board_info *info)
 {
-	return i2c_probe(adapter, &addr_data, ds2482_detect);
-}
+	if (!i2c_check_functionality(client->adapter,
+				     I2C_FUNC_SMBUS_WRITE_BYTE_DATA |
+				     I2C_FUNC_SMBUS_BYTE))
+		return -ENODEV;
 
+	strlcpy(info->type, "ds2482", I2C_NAME_SIZE);
 
-/*
- * The following function does more than just detection. If detection
- * succeeds, it also registers the new chip.
- */
-static int ds2482_detect(struct i2c_adapter *adapter, int address, int kind)
+	return 0;
+}
+
+static int ds2482_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
 {
 	struct ds2482_data *data;
-	struct i2c_client  *new_client;
-	int err = 0;
+	int err = -ENODEV;
 	int temp1;
 	int idx;
 
-	if (!i2c_check_functionality(adapter,
-				     I2C_FUNC_SMBUS_WRITE_BYTE_DATA |
-				     I2C_FUNC_SMBUS_BYTE))
-		goto exit;
-
 	if (!(data = kzalloc(sizeof(struct ds2482_data), GFP_KERNEL))) {
 		err = -ENOMEM;
 		goto exit;
 	}
 
-	new_client = &data->client;
-	i2c_set_clientdata(new_client, data);
-	new_client->addr = address;
-	new_client->driver = &ds2482_driver;
-	new_client->adapter = adapter;
+	data->client = client;
+	i2c_set_clientdata(client, data);
 
 	/* Reset the device (sets the read_ptr to status) */
 	if (ds2482_send_cmd(data, DS2482_CMD_RESET) < 0) {
-		dev_dbg(&adapter->dev, "DS2482 reset failed at 0x%02x.\n",
-			address);
+		dev_warn(&client->dev, "DS2482 reset failed.\n");
 		goto exit_free;
 	}
 
@@ -463,10 +464,10 @@ static int ds2482_detect(struct i2c_adapter *adapter, int address, int kind)
 	ndelay(525);
 
 	/* Read the status byte - only reset bit and line should be set */
-	temp1 = i2c_smbus_read_byte(new_client);
+	temp1 = i2c_smbus_read_byte(client);
 	if (temp1 != (DS2482_REG_STS_LL | DS2482_REG_STS_RST)) {
-		dev_dbg(&adapter->dev, "DS2482 (0x%02x) reset status "
-			"0x%02X - not a DS2482\n", address, temp1);
+		dev_warn(&client->dev, "DS2482 reset status "
+			 "0x%02X - not a DS2482\n", temp1);
 		goto exit_free;
 	}
 
@@ -478,16 +479,8 @@ static int ds2482_detect(struct i2c_adapter *adapter, int address, int kind)
 	/* Set all config items to 0 (off) */
 	ds2482_send_cmd_data(data, DS2482_CMD_WRITE_CONFIG, 0xF0);
 
-	/* We can fill in the remaining client fields */
-	snprintf(new_client->name, sizeof(new_client->name), "ds2482-%d00",
-		 data->w1_count);
-
 	mutex_init(&data->access_lock);
 
-	/* Tell the I2C layer a new client has arrived */
-	if ((err = i2c_attach_client(new_client)))
-		goto exit_free;
-
 	/* Register 1-wire interface(s) */
 	for (idx = 0; idx < data->w1_count; idx++) {
 		data->w1_ch[idx].pdev = data;
@@ -511,8 +504,6 @@ static int ds2482_detect(struct i2c_adapter *adapter, int address, int kind)
 	return 0;
 
 exit_w1_remove:
-	i2c_detach_client(new_client);
-
 	for (idx = 0; idx < data->w1_count; idx++) {
 		if (data->w1_ch[idx].pdev != NULL)
 			w1_remove_master_device(&data->w1_ch[idx].w1_bm);
@@ -523,10 +514,10 @@ static int ds2482_detect(struct i2c_adapter *adapter, int address, int kind)
 	return err;
 }
 
-static int ds2482_detach_client(struct i2c_client *client)
+static int ds2482_remove(struct i2c_client *client)
 {
 	struct ds2482_data   *data = i2c_get_clientdata(client);
-	int err, idx;
+	int idx;
 
 	/* Unregister the 1-wire bridge(s) */
 	for (idx = 0; idx < data->w1_count; idx++) {
@@ -534,13 +525,6 @@ static int ds2482_detach_client(struct i2c_client *client)
 			w1_remove_master_device(&data->w1_ch[idx].w1_bm);
 	}
 
-	/* Detach the i2c device */
-	if ((err = i2c_detach_client(client))) {
-		dev_err(&client->dev,
-			"Deregistration failed, client not detached.\n");
-		return err;
-	}
-
 	/* Free the memory */
 	kfree(data);
 	return 0;

commit 2cdddeb8d7dd42dc1847b110228a626d25a1e468
Author: Jean Delvare <khali@linux-fr.org>
Date:   Sun Jan 27 18:14:47 2008 +0100

    i2c: normal_i2c can be made const (remaining drivers)
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>

diff --git a/drivers/w1/masters/ds2482.c b/drivers/w1/masters/ds2482.c
index d93eb626b2f0..0fd5820d5c61 100644
--- a/drivers/w1/masters/ds2482.c
+++ b/drivers/w1/masters/ds2482.c
@@ -29,7 +29,7 @@
  * However, the chip cannot be detected without doing an i2c write,
  * so use the force module parameter.
  */
-static unsigned short normal_i2c[] = {I2C_CLIENT_END};
+static const unsigned short normal_i2c[] = { I2C_CLIENT_END };
 
 /**
  * Insmod parameters

commit b4786f1893305312d0a3e602de9080b1b932a681
Author: Ben Gardner <gardner.ben@gmail.com>
Date:   Thu Jun 29 22:33:22 2006 +0400

    [PATCH] w1: fix idle check loop in ds2482
    
    The idle check loop has a greater-than where it should have a less-than.
    This causes the ds2482 driver to check for the idle condition exactly
    once, which causes it to fail on faster machines.
    
    Signed-off-by: Ben Gardner <gardner.ben@gmail.com>
    Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/w1/masters/ds2482.c b/drivers/w1/masters/ds2482.c
index af492cc48db2..d93eb626b2f0 100644
--- a/drivers/w1/masters/ds2482.c
+++ b/drivers/w1/masters/ds2482.c
@@ -218,7 +218,7 @@ static int ds2482_wait_1wire_idle(struct ds2482_data *pdev)
 		do {
 			temp = i2c_smbus_read_byte(&pdev->client);
 		} while ((temp >= 0) && (temp & DS2482_REG_STS_1WB) &&
-			 (++retries > DS2482_WAIT_IDLE_TIMEOUT));
+			 (++retries < DS2482_WAIT_IDLE_TIMEOUT));
 	}
 
 	if (retries > DS2482_WAIT_IDLE_TIMEOUT)

commit abd52a13206e02537ca1dc08fc5438c7d27bdbf1
Author: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
Date:   Mon Apr 3 12:04:27 2006 +0400

    [PATCH] w1: Use mutexes instead of semaphores.
    
    Use mutexes instead of semaphores.
    Patch tested on x86_64 and i386 with test bus master driver.
    
    Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/w1/masters/ds2482.c b/drivers/w1/masters/ds2482.c
index d1cacd23576b..af492cc48db2 100644
--- a/drivers/w1/masters/ds2482.c
+++ b/drivers/w1/masters/ds2482.c
@@ -125,7 +125,7 @@ struct ds2482_w1_chan {
 
 struct ds2482_data {
 	struct i2c_client	client;
-	struct semaphore	access_lock;
+	struct mutex		access_lock;
 
 	/* 1-wire interface(s) */
 	int			w1_count;	/* 1 or 8 */
@@ -265,7 +265,7 @@ static u8 ds2482_w1_touch_bit(void *data, u8 bit)
 	struct ds2482_data    *pdev = pchan->pdev;
 	int status = -1;
 
-	down(&pdev->access_lock);
+	mutex_lock(&pdev->access_lock);
 
 	/* Select the channel */
 	ds2482_wait_1wire_idle(pdev);
@@ -277,7 +277,7 @@ static u8 ds2482_w1_touch_bit(void *data, u8 bit)
 				  bit ? 0xFF : 0))
 		status = ds2482_wait_1wire_idle(pdev);
 
-	up(&pdev->access_lock);
+	mutex_unlock(&pdev->access_lock);
 
 	return (status & DS2482_REG_STS_SBR) ? 1 : 0;
 }
@@ -297,7 +297,7 @@ static u8 ds2482_w1_triplet(void *data, u8 dbit)
 	struct ds2482_data    *pdev = pchan->pdev;
 	int status = (3 << 5);
 
-	down(&pdev->access_lock);
+	mutex_lock(&pdev->access_lock);
 
 	/* Select the channel */
 	ds2482_wait_1wire_idle(pdev);
@@ -309,7 +309,7 @@ static u8 ds2482_w1_triplet(void *data, u8 dbit)
 				  dbit ? 0xFF : 0))
 		status = ds2482_wait_1wire_idle(pdev);
 
-	up(&pdev->access_lock);
+	mutex_unlock(&pdev->access_lock);
 
 	/* Decode the status */
 	return (status >> 5);
@@ -326,7 +326,7 @@ static void ds2482_w1_write_byte(void *data, u8 byte)
 	struct ds2482_w1_chan *pchan = data;
 	struct ds2482_data    *pdev = pchan->pdev;
 
-	down(&pdev->access_lock);
+	mutex_lock(&pdev->access_lock);
 
 	/* Select the channel */
 	ds2482_wait_1wire_idle(pdev);
@@ -336,7 +336,7 @@ static void ds2482_w1_write_byte(void *data, u8 byte)
 	/* Send the write byte command */
 	ds2482_send_cmd_data(pdev, DS2482_CMD_1WIRE_WRITE_BYTE, byte);
 
-	up(&pdev->access_lock);
+	mutex_unlock(&pdev->access_lock);
 }
 
 /**
@@ -351,7 +351,7 @@ static u8 ds2482_w1_read_byte(void *data)
 	struct ds2482_data    *pdev = pchan->pdev;
 	int result;
 
-	down(&pdev->access_lock);
+	mutex_lock(&pdev->access_lock);
 
 	/* Select the channel */
 	ds2482_wait_1wire_idle(pdev);
@@ -370,7 +370,7 @@ static u8 ds2482_w1_read_byte(void *data)
 	/* Read the data byte */
 	result = i2c_smbus_read_byte(&pdev->client);
 
-	up(&pdev->access_lock);
+	mutex_unlock(&pdev->access_lock);
 
 	return result;
 }
@@ -389,7 +389,7 @@ static u8 ds2482_w1_reset_bus(void *data)
 	int err;
 	u8 retval = 1;
 
-	down(&pdev->access_lock);
+	mutex_lock(&pdev->access_lock);
 
 	/* Select the channel */
 	ds2482_wait_1wire_idle(pdev);
@@ -409,7 +409,7 @@ static u8 ds2482_w1_reset_bus(void *data)
 					     0xF0);
 	}
 
-	up(&pdev->access_lock);
+	mutex_unlock(&pdev->access_lock);
 
 	return retval;
 }
@@ -482,7 +482,7 @@ static int ds2482_detect(struct i2c_adapter *adapter, int address, int kind)
 	snprintf(new_client->name, sizeof(new_client->name), "ds2482-%d00",
 		 data->w1_count);
 
-	init_MUTEX(&data->access_lock);
+	mutex_init(&data->access_lock);
 
 	/* Tell the I2C layer a new client has arrived */
 	if ((err = i2c_attach_client(new_client)))

commit baf12ae29ab4cc6381e21b2e1a3af75a6a8f7566
Author: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
Date:   Tue Dec 6 13:38:28 2005 +0300

    [PATCH] W1: Add the DS2482 I2C-to-w1 bridge driver.
    
    Signed-off-by: Ben Gardner <bgardner@wabtec.com>
    Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/w1/masters/ds2482.c b/drivers/w1/masters/ds2482.c
new file mode 100644
index 000000000000..d1cacd23576b
--- /dev/null
+++ b/drivers/w1/masters/ds2482.c
@@ -0,0 +1,564 @@
+/**
+ * ds2482.c - provides i2c to w1-master bridge(s)
+ * Copyright (C) 2005  Ben Gardner <bgardner@wabtec.com>
+ *
+ * The DS2482 is a sensor chip made by Dallas Semiconductor (Maxim).
+ * It is a I2C to 1-wire bridge.
+ * There are two variations: -100 and -800, which have 1 or 8 1-wire ports.
+ * The complete datasheet can be obtained from MAXIM's website at:
+ *   http://www.maxim-ic.com/quick_view2.cfm/qv_pk/4382
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <asm/delay.h>
+
+#include "../w1.h"
+#include "../w1_int.h"
+
+/**
+ * Address is selected using 2 pins, resulting in 4 possible addresses.
+ *  0x18, 0x19, 0x1a, 0x1b
+ * However, the chip cannot be detected without doing an i2c write,
+ * so use the force module parameter.
+ */
+static unsigned short normal_i2c[] = {I2C_CLIENT_END};
+
+/**
+ * Insmod parameters
+ */
+I2C_CLIENT_INSMOD_1(ds2482);
+
+/**
+ * The DS2482 registers - there are 3 registers that are addressed by a read
+ * pointer. The read pointer is set by the last command executed.
+ *
+ * To read the data, issue a register read for any address
+ */
+#define DS2482_CMD_RESET		0xF0	/* No param */
+#define DS2482_CMD_SET_READ_PTR		0xE1	/* Param: DS2482_PTR_CODE_xxx */
+#define DS2482_CMD_CHANNEL_SELECT	0xC3	/* Param: Channel byte - DS2482-800 only */
+#define DS2482_CMD_WRITE_CONFIG		0xD2	/* Param: Config byte */
+#define DS2482_CMD_1WIRE_RESET		0xB4	/* Param: None */
+#define DS2482_CMD_1WIRE_SINGLE_BIT	0x87	/* Param: Bit byte (bit7) */
+#define DS2482_CMD_1WIRE_WRITE_BYTE	0xA5	/* Param: Data byte */
+#define DS2482_CMD_1WIRE_READ_BYTE	0x96	/* Param: None */
+/* Note to read the byte, Set the ReadPtr to Data then read (any addr) */
+#define DS2482_CMD_1WIRE_TRIPLET	0x78	/* Param: Dir byte (bit7) */
+
+/* Values for DS2482_CMD_SET_READ_PTR */
+#define DS2482_PTR_CODE_STATUS		0xF0
+#define DS2482_PTR_CODE_DATA		0xE1
+#define DS2482_PTR_CODE_CHANNEL		0xD2	/* DS2482-800 only */
+#define DS2482_PTR_CODE_CONFIG		0xC3
+
+/**
+ * Configure Register bit definitions
+ * The top 4 bits always read 0.
+ * To write, the top nibble must be the 1's compl. of the low nibble.
+ */
+#define DS2482_REG_CFG_1WS		0x08
+#define DS2482_REG_CFG_SPU		0x04
+#define DS2482_REG_CFG_PPM		0x02
+#define DS2482_REG_CFG_APU		0x01
+
+
+/**
+ * Write and verify codes for the CHANNEL_SELECT command (DS2482-800 only).
+ * To set the channel, write the value at the index of the channel.
+ * Read and compare against the corresponding value to verify the change.
+ */
+static const u8 ds2482_chan_wr[8] =
+	{ 0xF0, 0xE1, 0xD2, 0xC3, 0xB4, 0xA5, 0x96, 0x87 };
+static const u8 ds2482_chan_rd[8] =
+	{ 0xB8, 0xB1, 0xAA, 0xA3, 0x9C, 0x95, 0x8E, 0x87 };
+
+
+/**
+ * Status Register bit definitions (read only)
+ */
+#define DS2482_REG_STS_DIR		0x80
+#define DS2482_REG_STS_TSB		0x40
+#define DS2482_REG_STS_SBR		0x20
+#define DS2482_REG_STS_RST		0x10
+#define DS2482_REG_STS_LL		0x08
+#define DS2482_REG_STS_SD		0x04
+#define DS2482_REG_STS_PPD		0x02
+#define DS2482_REG_STS_1WB		0x01
+
+
+static int ds2482_attach_adapter(struct i2c_adapter *adapter);
+static int ds2482_detect(struct i2c_adapter *adapter, int address, int kind);
+static int ds2482_detach_client(struct i2c_client *client);
+
+
+/**
+ * Driver data (common to all clients)
+ */
+static struct i2c_driver ds2482_driver = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= "ds2482",
+	},
+	.attach_adapter	= ds2482_attach_adapter,
+	.detach_client	= ds2482_detach_client,
+};
+
+/*
+ * Client data (each client gets its own)
+ */
+
+struct ds2482_data;
+
+struct ds2482_w1_chan {
+	struct ds2482_data	*pdev;
+	u8			channel;
+	struct w1_bus_master	w1_bm;
+};
+
+struct ds2482_data {
+	struct i2c_client	client;
+	struct semaphore	access_lock;
+
+	/* 1-wire interface(s) */
+	int			w1_count;	/* 1 or 8 */
+	struct ds2482_w1_chan	w1_ch[8];
+
+	/* per-device values */
+	u8			channel;
+	u8			read_prt;	/* see DS2482_PTR_CODE_xxx */
+	u8			reg_config;
+};
+
+
+/**
+ * Sets the read pointer.
+ * @param pdev		The ds2482 client pointer
+ * @param read_ptr	see DS2482_PTR_CODE_xxx above
+ * @return -1 on failure, 0 on success
+ */
+static inline int ds2482_select_register(struct ds2482_data *pdev, u8 read_ptr)
+{
+	if (pdev->read_prt != read_ptr) {
+		if (i2c_smbus_write_byte_data(&pdev->client,
+					      DS2482_CMD_SET_READ_PTR,
+					      read_ptr) < 0)
+			return -1;
+
+		pdev->read_prt = read_ptr;
+	}
+	return 0;
+}
+
+/**
+ * Sends a command without a parameter
+ * @param pdev	The ds2482 client pointer
+ * @param cmd	DS2482_CMD_RESET,
+ *		DS2482_CMD_1WIRE_RESET,
+ *		DS2482_CMD_1WIRE_READ_BYTE
+ * @return -1 on failure, 0 on success
+ */
+static inline int ds2482_send_cmd(struct ds2482_data *pdev, u8 cmd)
+{
+	if (i2c_smbus_write_byte(&pdev->client, cmd) < 0)
+		return -1;
+
+	pdev->read_prt = DS2482_PTR_CODE_STATUS;
+	return 0;
+}
+
+/**
+ * Sends a command with a parameter
+ * @param pdev	The ds2482 client pointer
+ * @param cmd	DS2482_CMD_WRITE_CONFIG,
+ *		DS2482_CMD_1WIRE_SINGLE_BIT,
+ *		DS2482_CMD_1WIRE_WRITE_BYTE,
+ *		DS2482_CMD_1WIRE_TRIPLET
+ * @param byte	The data to send
+ * @return -1 on failure, 0 on success
+ */
+static inline int ds2482_send_cmd_data(struct ds2482_data *pdev,
+				       u8 cmd, u8 byte)
+{
+	if (i2c_smbus_write_byte_data(&pdev->client, cmd, byte) < 0)
+		return -1;
+
+	/* all cmds leave in STATUS, except CONFIG */
+	pdev->read_prt = (cmd != DS2482_CMD_WRITE_CONFIG) ?
+			 DS2482_PTR_CODE_STATUS : DS2482_PTR_CODE_CONFIG;
+	return 0;
+}
+
+
+/*
+ * 1-Wire interface code
+ */
+
+#define DS2482_WAIT_IDLE_TIMEOUT	100
+
+/**
+ * Waits until the 1-wire interface is idle (not busy)
+ *
+ * @param pdev Pointer to the device structure
+ * @return the last value read from status or -1 (failure)
+ */
+static int ds2482_wait_1wire_idle(struct ds2482_data *pdev)
+{
+	int temp = -1;
+	int retries = 0;
+
+	if (!ds2482_select_register(pdev, DS2482_PTR_CODE_STATUS)) {
+		do {
+			temp = i2c_smbus_read_byte(&pdev->client);
+		} while ((temp >= 0) && (temp & DS2482_REG_STS_1WB) &&
+			 (++retries > DS2482_WAIT_IDLE_TIMEOUT));
+	}
+
+	if (retries > DS2482_WAIT_IDLE_TIMEOUT)
+		printk(KERN_ERR "%s: timeout on channel %d\n",
+		       __func__, pdev->channel);
+
+	return temp;
+}
+
+/**
+ * Selects a w1 channel.
+ * The 1-wire interface must be idle before calling this function.
+ *
+ * @param pdev		The ds2482 client pointer
+ * @param channel	0-7
+ * @return		-1 (failure) or 0 (success)
+ */
+static int ds2482_set_channel(struct ds2482_data *pdev, u8 channel)
+{
+	if (i2c_smbus_write_byte_data(&pdev->client, DS2482_CMD_CHANNEL_SELECT,
+				      ds2482_chan_wr[channel]) < 0)
+		return -1;
+
+	pdev->read_prt = DS2482_PTR_CODE_CHANNEL;
+	pdev->channel = -1;
+	if (i2c_smbus_read_byte(&pdev->client) == ds2482_chan_rd[channel]) {
+		pdev->channel = channel;
+		return 0;
+	}
+	return -1;
+}
+
+
+/**
+ * Performs the touch-bit function, which writes a 0 or 1 and reads the level.
+ *
+ * @param data	The ds2482 channel pointer
+ * @param bit	The level to write: 0 or non-zero
+ * @return	The level read: 0 or 1
+ */
+static u8 ds2482_w1_touch_bit(void *data, u8 bit)
+{
+	struct ds2482_w1_chan *pchan = data;
+	struct ds2482_data    *pdev = pchan->pdev;
+	int status = -1;
+
+	down(&pdev->access_lock);
+
+	/* Select the channel */
+	ds2482_wait_1wire_idle(pdev);
+	if (pdev->w1_count > 1)
+		ds2482_set_channel(pdev, pchan->channel);
+
+	/* Send the touch command, wait until 1WB == 0, return the status */
+	if (!ds2482_send_cmd_data(pdev, DS2482_CMD_1WIRE_SINGLE_BIT,
+				  bit ? 0xFF : 0))
+		status = ds2482_wait_1wire_idle(pdev);
+
+	up(&pdev->access_lock);
+
+	return (status & DS2482_REG_STS_SBR) ? 1 : 0;
+}
+
+/**
+ * Performs the triplet function, which reads two bits and writes a bit.
+ * The bit written is determined by the two reads:
+ *   00 => dbit, 01 => 0, 10 => 1
+ *
+ * @param data	The ds2482 channel pointer
+ * @param dbit	The direction to choose if both branches are valid
+ * @return	b0=read1 b1=read2 b3=bit written
+ */
+static u8 ds2482_w1_triplet(void *data, u8 dbit)
+{
+	struct ds2482_w1_chan *pchan = data;
+	struct ds2482_data    *pdev = pchan->pdev;
+	int status = (3 << 5);
+
+	down(&pdev->access_lock);
+
+	/* Select the channel */
+	ds2482_wait_1wire_idle(pdev);
+	if (pdev->w1_count > 1)
+		ds2482_set_channel(pdev, pchan->channel);
+
+	/* Send the triplet command, wait until 1WB == 0, return the status */
+	if (!ds2482_send_cmd_data(pdev, DS2482_CMD_1WIRE_TRIPLET,
+				  dbit ? 0xFF : 0))
+		status = ds2482_wait_1wire_idle(pdev);
+
+	up(&pdev->access_lock);
+
+	/* Decode the status */
+	return (status >> 5);
+}
+
+/**
+ * Performs the write byte function.
+ *
+ * @param data	The ds2482 channel pointer
+ * @param byte	The value to write
+ */
+static void ds2482_w1_write_byte(void *data, u8 byte)
+{
+	struct ds2482_w1_chan *pchan = data;
+	struct ds2482_data    *pdev = pchan->pdev;
+
+	down(&pdev->access_lock);
+
+	/* Select the channel */
+	ds2482_wait_1wire_idle(pdev);
+	if (pdev->w1_count > 1)
+		ds2482_set_channel(pdev, pchan->channel);
+
+	/* Send the write byte command */
+	ds2482_send_cmd_data(pdev, DS2482_CMD_1WIRE_WRITE_BYTE, byte);
+
+	up(&pdev->access_lock);
+}
+
+/**
+ * Performs the read byte function.
+ *
+ * @param data	The ds2482 channel pointer
+ * @return	The value read
+ */
+static u8 ds2482_w1_read_byte(void *data)
+{
+	struct ds2482_w1_chan *pchan = data;
+	struct ds2482_data    *pdev = pchan->pdev;
+	int result;
+
+	down(&pdev->access_lock);
+
+	/* Select the channel */
+	ds2482_wait_1wire_idle(pdev);
+	if (pdev->w1_count > 1)
+		ds2482_set_channel(pdev, pchan->channel);
+
+	/* Send the read byte command */
+	ds2482_send_cmd(pdev, DS2482_CMD_1WIRE_READ_BYTE);
+
+	/* Wait until 1WB == 0 */
+	ds2482_wait_1wire_idle(pdev);
+
+	/* Select the data register */
+	ds2482_select_register(pdev, DS2482_PTR_CODE_DATA);
+
+	/* Read the data byte */
+	result = i2c_smbus_read_byte(&pdev->client);
+
+	up(&pdev->access_lock);
+
+	return result;
+}
+
+
+/**
+ * Sends a reset on the 1-wire interface
+ *
+ * @param data	The ds2482 channel pointer
+ * @return	0=Device present, 1=No device present or error
+ */
+static u8 ds2482_w1_reset_bus(void *data)
+{
+	struct ds2482_w1_chan *pchan = data;
+	struct ds2482_data    *pdev = pchan->pdev;
+	int err;
+	u8 retval = 1;
+
+	down(&pdev->access_lock);
+
+	/* Select the channel */
+	ds2482_wait_1wire_idle(pdev);
+	if (pdev->w1_count > 1)
+		ds2482_set_channel(pdev, pchan->channel);
+
+	/* Send the reset command */
+	err = ds2482_send_cmd(pdev, DS2482_CMD_1WIRE_RESET);
+	if (err >= 0) {
+		/* Wait until the reset is complete */
+		err = ds2482_wait_1wire_idle(pdev);
+		retval = !(err & DS2482_REG_STS_PPD);
+
+		/* If the chip did reset since detect, re-config it */
+		if (err & DS2482_REG_STS_RST)
+			ds2482_send_cmd_data(pdev, DS2482_CMD_WRITE_CONFIG,
+					     0xF0);
+	}
+
+	up(&pdev->access_lock);
+
+	return retval;
+}
+
+
+/**
+ * Called to see if the device exists on an i2c bus.
+ */
+static int ds2482_attach_adapter(struct i2c_adapter *adapter)
+{
+	return i2c_probe(adapter, &addr_data, ds2482_detect);
+}
+
+
+/*
+ * The following function does more than just detection. If detection
+ * succeeds, it also registers the new chip.
+ */
+static int ds2482_detect(struct i2c_adapter *adapter, int address, int kind)
+{
+	struct ds2482_data *data;
+	struct i2c_client  *new_client;
+	int err = 0;
+	int temp1;
+	int idx;
+
+	if (!i2c_check_functionality(adapter,
+				     I2C_FUNC_SMBUS_WRITE_BYTE_DATA |
+				     I2C_FUNC_SMBUS_BYTE))
+		goto exit;
+
+	if (!(data = kzalloc(sizeof(struct ds2482_data), GFP_KERNEL))) {
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	new_client = &data->client;
+	i2c_set_clientdata(new_client, data);
+	new_client->addr = address;
+	new_client->driver = &ds2482_driver;
+	new_client->adapter = adapter;
+
+	/* Reset the device (sets the read_ptr to status) */
+	if (ds2482_send_cmd(data, DS2482_CMD_RESET) < 0) {
+		dev_dbg(&adapter->dev, "DS2482 reset failed at 0x%02x.\n",
+			address);
+		goto exit_free;
+	}
+
+	/* Sleep at least 525ns to allow the reset to complete */
+	ndelay(525);
+
+	/* Read the status byte - only reset bit and line should be set */
+	temp1 = i2c_smbus_read_byte(new_client);
+	if (temp1 != (DS2482_REG_STS_LL | DS2482_REG_STS_RST)) {
+		dev_dbg(&adapter->dev, "DS2482 (0x%02x) reset status "
+			"0x%02X - not a DS2482\n", address, temp1);
+		goto exit_free;
+	}
+
+	/* Detect the 8-port version */
+	data->w1_count = 1;
+	if (ds2482_set_channel(data, 7) == 0)
+		data->w1_count = 8;
+
+	/* Set all config items to 0 (off) */
+	ds2482_send_cmd_data(data, DS2482_CMD_WRITE_CONFIG, 0xF0);
+
+	/* We can fill in the remaining client fields */
+	snprintf(new_client->name, sizeof(new_client->name), "ds2482-%d00",
+		 data->w1_count);
+
+	init_MUTEX(&data->access_lock);
+
+	/* Tell the I2C layer a new client has arrived */
+	if ((err = i2c_attach_client(new_client)))
+		goto exit_free;
+
+	/* Register 1-wire interface(s) */
+	for (idx = 0; idx < data->w1_count; idx++) {
+		data->w1_ch[idx].pdev = data;
+		data->w1_ch[idx].channel = idx;
+
+		/* Populate all the w1 bus master stuff */
+		data->w1_ch[idx].w1_bm.data       = &data->w1_ch[idx];
+		data->w1_ch[idx].w1_bm.read_byte  = ds2482_w1_read_byte;
+		data->w1_ch[idx].w1_bm.write_byte = ds2482_w1_write_byte;
+		data->w1_ch[idx].w1_bm.touch_bit  = ds2482_w1_touch_bit;
+		data->w1_ch[idx].w1_bm.triplet    = ds2482_w1_triplet;
+		data->w1_ch[idx].w1_bm.reset_bus  = ds2482_w1_reset_bus;
+
+		err = w1_add_master_device(&data->w1_ch[idx].w1_bm);
+		if (err) {
+			data->w1_ch[idx].pdev = NULL;
+			goto exit_w1_remove;
+		}
+	}
+
+	return 0;
+
+exit_w1_remove:
+	i2c_detach_client(new_client);
+
+	for (idx = 0; idx < data->w1_count; idx++) {
+		if (data->w1_ch[idx].pdev != NULL)
+			w1_remove_master_device(&data->w1_ch[idx].w1_bm);
+	}
+exit_free:
+	kfree(data);
+exit:
+	return err;
+}
+
+static int ds2482_detach_client(struct i2c_client *client)
+{
+	struct ds2482_data   *data = i2c_get_clientdata(client);
+	int err, idx;
+
+	/* Unregister the 1-wire bridge(s) */
+	for (idx = 0; idx < data->w1_count; idx++) {
+		if (data->w1_ch[idx].pdev != NULL)
+			w1_remove_master_device(&data->w1_ch[idx].w1_bm);
+	}
+
+	/* Detach the i2c device */
+	if ((err = i2c_detach_client(client))) {
+		dev_err(&client->dev,
+			"Deregistration failed, client not detached.\n");
+		return err;
+	}
+
+	/* Free the memory */
+	kfree(data);
+	return 0;
+}
+
+static int __init sensors_ds2482_init(void)
+{
+	return i2c_add_driver(&ds2482_driver);
+}
+
+static void __exit sensors_ds2482_exit(void)
+{
+	i2c_del_driver(&ds2482_driver);
+}
+
+MODULE_AUTHOR("Ben Gardner <bgardner@wabtec.com>");
+MODULE_DESCRIPTION("DS2482 driver");
+MODULE_LICENSE("GPL");
+
+module_init(sensors_ds2482_init);
+module_exit(sensors_ds2482_exit);
