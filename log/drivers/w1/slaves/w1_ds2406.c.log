commit 40b0b3f8fb2d8f55d13ceed41593d46689a6b496
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jun 3 07:44:46 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 230
    
    Based on 2 normalized pattern(s):
    
      this source code is licensed under the gnu general public license
      version 2 see the file copying for more details
    
      this source code is licensed under general public license version 2
      see
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 52 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190602204653.449021192@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/slaves/w1_ds2406.c b/drivers/w1/slaves/w1_ds2406.c
index fac266366ca3..762e5e4e2b48 100644
--- a/drivers/w1/slaves/w1_ds2406.c
+++ b/drivers/w1/slaves/w1_ds2406.c
@@ -1,11 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * w1_ds2406.c - w1 family 12 (DS2406) driver
  * based on w1_ds2413.c by Mariusz Bialonczyk <manio@skyboo.net>
  *
  * Copyright (c) 2014 Scott Alfter <scott@alfter.us>
- *
- * This source code is licensed under the GNU General Public License,
- * Version 2. See the file COPYING for more details.
  */
 
 #include <linux/kernel.h>

commit de0d6dbdbdb23ddb85f10d54a516e794f9a873e0
Author: Andrew F. Davis <afd@ti.com>
Date:   Mon Jun 5 08:52:08 2017 -0500

    w1: Add subsystem kernel public interface
    
    Like other subsystems we should be able to define slave devices outside
    of the w1 directory. To do this we move public facing interface
    definitions to include/linux/w1.h and rename the internal definition
    file to w1_internal.h.
    
    As w1_family.h and w1_int.h contained almost entirely public
    driver interface definitions we simply removed these files and
    moved the remaining definitions into w1_internal.h.
    
    With this we can now start to move slave devices out of w1/slaves and
    into the subsystem based on the function they implement, again like
    other drivers.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>
    Reviewed-by: Sebastian Reichel <sre@kernel.org>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/slaves/w1_ds2406.c b/drivers/w1/slaves/w1_ds2406.c
index 709bd5e02eed..fac266366ca3 100644
--- a/drivers/w1/slaves/w1_ds2406.c
+++ b/drivers/w1/slaves/w1_ds2406.c
@@ -17,9 +17,9 @@
 #include <linux/slab.h>
 #include <linux/crc16.h>
 
-#include "../w1.h"
-#include "../w1_int.h"
-#include "../w1_family.h"
+#include <linux/w1.h>
+
+#define W1_FAMILY_DS2406	0x12
 
 #define W1_F12_FUNC_READ_STATUS		   0xAA
 #define W1_F12_FUNC_WRITE_STATUS	   0x55

commit 50fa2951bd744d2a82aa33074001efac12d4e1cf
Author: Andrew F. Davis <afd@ti.com>
Date:   Tue May 16 15:02:12 2017 -0500

    w1: Organize driver source to natural/common order
    
    Structures and functions should be ordered such that forward declaration
    use is minimized.
    
    MODULE_* macros should immediately follow the structures and functions
    upon which they act.
    
    Remaining MODULE_* macros should be at the end of the file in
    alphabetical order.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/slaves/w1_ds2406.c b/drivers/w1/slaves/w1_ds2406.c
index 51f2f66d6555..709bd5e02eed 100644
--- a/drivers/w1/slaves/w1_ds2406.c
+++ b/drivers/w1/slaves/w1_ds2406.c
@@ -21,10 +21,6 @@
 #include "../w1_int.h"
 #include "../w1_family.h"
 
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Scott Alfter <scott@alfter.us>");
-MODULE_DESCRIPTION("w1 family 12 driver for DS2406 2 Pin IO");
-
 #define W1_F12_FUNC_READ_STATUS		   0xAA
 #define W1_F12_FUNC_WRITE_STATUS	   0x55
 
@@ -154,3 +150,7 @@ static struct w1_family w1_family_12 = {
 	.fops = &w1_f12_fops,
 };
 module_w1_family(w1_family_12);
+
+MODULE_AUTHOR("Scott Alfter <scott@alfter.us>");
+MODULE_DESCRIPTION("w1 family 12 driver for DS2406 2 Pin IO");
+MODULE_LICENSE("GPL");

commit 939fc832290d548a02b6a309992b3c1ff7de1ff9
Author: Andrew F. Davis <afd@ti.com>
Date:   Tue Aug 2 14:07:09 2016 -0700

    w1: add helper macro module_w1_family
    
    The helper macro module_w1_family can be used in module drivers that
    only register a w1 driver in their module init functions.  Add this
    macro and use it in all applicable drivers.
    
    Link: http://lkml.kernel.org/r/20160531204313.20979-2-afd@ti.com
    Signed-off-by: Andrew F. Davis <afd@ti.com>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/w1/slaves/w1_ds2406.c b/drivers/w1/slaves/w1_ds2406.c
index d488961a8c90..51f2f66d6555 100644
--- a/drivers/w1/slaves/w1_ds2406.c
+++ b/drivers/w1/slaves/w1_ds2406.c
@@ -153,16 +153,4 @@ static struct w1_family w1_family_12 = {
 	.fid = W1_FAMILY_DS2406,
 	.fops = &w1_f12_fops,
 };
-
-static int __init w1_f12_init(void)
-{
-	return w1_register_family(&w1_family_12);
-}
-
-static void __exit w1_f12_exit(void)
-{
-	w1_unregister_family(&w1_family_12);
-}
-
-module_init(w1_f12_init);
-module_exit(w1_f12_exit);
+module_w1_family(w1_family_12);

commit 94859308a21b2bbf3d7c48789513c0c4a9ea7de1
Author: Scott Alfter <scott@alfter.us>
Date:   Tue Jun 17 20:42:05 2014 +0000

    w1: new w1_ds2406 driver
    
    Some preliminary work at making use of this driver led me to implement
    CRC-16 checks on read and write to deal with the occasional glitchiness of
    the 1-Wire bus.  The revised driver (attached) returns an I/O error if the
    CRC check fails.  When reading the chip's state, either you get a valid
    indication or you get an I/O error.  When changing its state, either the
    change is successful or an I/O error is returned.
    
    Signed-off-by: Scott Alfter <scott@alfter.us>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/slaves/w1_ds2406.c b/drivers/w1/slaves/w1_ds2406.c
new file mode 100644
index 000000000000..d488961a8c90
--- /dev/null
+++ b/drivers/w1/slaves/w1_ds2406.c
@@ -0,0 +1,168 @@
+/*
+ * w1_ds2406.c - w1 family 12 (DS2406) driver
+ * based on w1_ds2413.c by Mariusz Bialonczyk <manio@skyboo.net>
+ *
+ * Copyright (c) 2014 Scott Alfter <scott@alfter.us>
+ *
+ * This source code is licensed under the GNU General Public License,
+ * Version 2. See the file COPYING for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/crc16.h>
+
+#include "../w1.h"
+#include "../w1_int.h"
+#include "../w1_family.h"
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Scott Alfter <scott@alfter.us>");
+MODULE_DESCRIPTION("w1 family 12 driver for DS2406 2 Pin IO");
+
+#define W1_F12_FUNC_READ_STATUS		   0xAA
+#define W1_F12_FUNC_WRITE_STATUS	   0x55
+
+static ssize_t w1_f12_read_state(
+	struct file *filp, struct kobject *kobj,
+	struct bin_attribute *bin_attr,
+	char *buf, loff_t off, size_t count)
+{
+	u8 w1_buf[6]={W1_F12_FUNC_READ_STATUS, 7, 0, 0, 0, 0};
+	struct w1_slave *sl = kobj_to_w1_slave(kobj);
+	u16 crc=0;
+	int i;
+	ssize_t rtnval=1;
+
+	if (off != 0)
+		return 0;
+	if (!buf)
+		return -EINVAL;
+
+	mutex_lock(&sl->master->bus_mutex);
+
+	if (w1_reset_select_slave(sl)) {
+		mutex_unlock(&sl->master->bus_mutex);
+		return -EIO;
+	}
+
+	w1_write_block(sl->master, w1_buf, 3);
+	w1_read_block(sl->master, w1_buf+3, 3);
+	for (i=0; i<6; i++)
+		crc=crc16_byte(crc, w1_buf[i]);
+	if (crc==0xb001) /* good read? */
+		*buf=((w1_buf[3]>>5)&3)|0x30;
+	else
+		rtnval=-EIO;
+
+	mutex_unlock(&sl->master->bus_mutex);
+
+	return rtnval;
+}
+
+static ssize_t w1_f12_write_output(
+	struct file *filp, struct kobject *kobj,
+	struct bin_attribute *bin_attr,
+	char *buf, loff_t off, size_t count)
+{
+	struct w1_slave *sl = kobj_to_w1_slave(kobj);
+	u8 w1_buf[6]={W1_F12_FUNC_WRITE_STATUS, 7, 0, 0, 0, 0};
+	u16 crc=0;
+	int i;
+	ssize_t rtnval=1;
+
+	if (count != 1 || off != 0)
+		return -EFAULT;
+
+	mutex_lock(&sl->master->bus_mutex);
+
+	if (w1_reset_select_slave(sl)) {
+		mutex_unlock(&sl->master->bus_mutex);
+		return -EIO;
+	}
+
+	w1_buf[3] = (((*buf)&3)<<5)|0x1F;
+	w1_write_block(sl->master, w1_buf, 4);
+	w1_read_block(sl->master, w1_buf+4, 2);
+	for (i=0; i<6; i++)
+		crc=crc16_byte(crc, w1_buf[i]);
+	if (crc==0xb001) /* good read? */
+		w1_write_8(sl->master, 0xFF);
+	else
+		rtnval=-EIO;
+
+	mutex_unlock(&sl->master->bus_mutex);
+	return rtnval;
+}
+
+#define NB_SYSFS_BIN_FILES 2
+static struct bin_attribute w1_f12_sysfs_bin_files[NB_SYSFS_BIN_FILES] = {
+	{
+		.attr = {
+			.name = "state",
+			.mode = S_IRUGO,
+		},
+		.size = 1,
+		.read = w1_f12_read_state,
+	},
+	{
+		.attr = {
+			.name = "output",
+			.mode = S_IRUGO | S_IWUSR | S_IWGRP,
+		},
+		.size = 1,
+		.write = w1_f12_write_output,
+	}
+};
+
+static int w1_f12_add_slave(struct w1_slave *sl)
+{
+	int err = 0;
+	int i;
+
+	for (i = 0; i < NB_SYSFS_BIN_FILES && !err; ++i)
+		err = sysfs_create_bin_file(
+			&sl->dev.kobj,
+			&(w1_f12_sysfs_bin_files[i]));
+	if (err)
+		while (--i >= 0)
+			sysfs_remove_bin_file(&sl->dev.kobj,
+				&(w1_f12_sysfs_bin_files[i]));
+	return err;
+}
+
+static void w1_f12_remove_slave(struct w1_slave *sl)
+{
+	int i;
+	for (i = NB_SYSFS_BIN_FILES - 1; i >= 0; --i)
+		sysfs_remove_bin_file(&sl->dev.kobj,
+			&(w1_f12_sysfs_bin_files[i]));
+}
+
+static struct w1_family_ops w1_f12_fops = {
+	.add_slave      = w1_f12_add_slave,
+	.remove_slave   = w1_f12_remove_slave,
+};
+
+static struct w1_family w1_family_12 = {
+	.fid = W1_FAMILY_DS2406,
+	.fops = &w1_f12_fops,
+};
+
+static int __init w1_f12_init(void)
+{
+	return w1_register_family(&w1_family_12);
+}
+
+static void __exit w1_f12_exit(void)
+{
+	w1_unregister_family(&w1_family_12);
+}
+
+module_init(w1_f12_init);
+module_exit(w1_f12_exit);
