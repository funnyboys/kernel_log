commit 53c8ab3584148acb61426cd5af0450045855c35b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 24 12:04:07 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 147
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the [therms] of the gnu general public license as published
      by the free software foundation either version 2 of the license or
      at your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 2 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190524100844.941364072@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/slaves/w1_ds2423.c b/drivers/w1/slaves/w1_ds2423.c
index 050407c53b16..f4367282dcc1 100644
--- a/drivers/w1/slaves/w1_ds2423.c
+++ b/drivers/w1/slaves/w1_ds2423.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *	w1_ds2423.c
  *
@@ -6,20 +7,6 @@
  * This driver will read and write the value of 4 counters to w1_slave file in
  * sys filesystem.
  * Inspired by the w1_therm and w1_ds2431 drivers.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the therms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
 
 #include <linux/kernel.h>

commit de0d6dbdbdb23ddb85f10d54a516e794f9a873e0
Author: Andrew F. Davis <afd@ti.com>
Date:   Mon Jun 5 08:52:08 2017 -0500

    w1: Add subsystem kernel public interface
    
    Like other subsystems we should be able to define slave devices outside
    of the w1 directory. To do this we move public facing interface
    definitions to include/linux/w1.h and rename the internal definition
    file to w1_internal.h.
    
    As w1_family.h and w1_int.h contained almost entirely public
    driver interface definitions we simply removed these files and
    moved the remaining definitions into w1_internal.h.
    
    With this we can now start to move slave devices out of w1/slaves and
    into the subsystem based on the function they implement, again like
    other drivers.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>
    Reviewed-by: Sebastian Reichel <sre@kernel.org>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/slaves/w1_ds2423.c b/drivers/w1/slaves/w1_ds2423.c
index 306240fe496c..050407c53b16 100644
--- a/drivers/w1/slaves/w1_ds2423.c
+++ b/drivers/w1/slaves/w1_ds2423.c
@@ -30,9 +30,9 @@
 #include <linux/delay.h>
 #include <linux/crc16.h>
 
-#include "../w1.h"
-#include "../w1_int.h"
-#include "../w1_family.h"
+#include <linux/w1.h>
+
+#define W1_COUNTER_DS2423	0x1D
 
 #define CRC16_VALID	0xb001
 #define CRC16_INIT	0

commit 50fa2951bd744d2a82aa33074001efac12d4e1cf
Author: Andrew F. Davis <afd@ti.com>
Date:   Tue May 16 15:02:12 2017 -0500

    w1: Organize driver source to natural/common order
    
    Structures and functions should be ordered such that forward declaration
    use is minimized.
    
    MODULE_* macros should immediately follow the structures and functions
    upon which they act.
    
    Remaining MODULE_* macros should be at the end of the file in
    alphabetical order.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/slaves/w1_ds2423.c b/drivers/w1/slaves/w1_ds2423.c
index 4ab54fd9dde2..306240fe496c 100644
--- a/drivers/w1/slaves/w1_ds2423.c
+++ b/drivers/w1/slaves/w1_ds2423.c
@@ -140,7 +140,7 @@ static struct w1_family w1_family_1d = {
 };
 module_w1_family(w1_family_1d);
 
-MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Mika Laitio <lamikr@pilppa.org>");
 MODULE_DESCRIPTION("w1 family 1d driver for DS2423, 4 counters and 4kb ram");
+MODULE_LICENSE("GPL");
 MODULE_ALIAS("w1-family-" __stringify(W1_COUNTER_DS2423));

commit 939fc832290d548a02b6a309992b3c1ff7de1ff9
Author: Andrew F. Davis <afd@ti.com>
Date:   Tue Aug 2 14:07:09 2016 -0700

    w1: add helper macro module_w1_family
    
    The helper macro module_w1_family can be used in module drivers that
    only register a w1 driver in their module init functions.  Add this
    macro and use it in all applicable drivers.
    
    Link: http://lkml.kernel.org/r/20160531204313.20979-2-afd@ti.com
    Signed-off-by: Andrew F. Davis <afd@ti.com>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/w1/slaves/w1_ds2423.c b/drivers/w1/slaves/w1_ds2423.c
index 7e41b7d91fb5..4ab54fd9dde2 100644
--- a/drivers/w1/slaves/w1_ds2423.c
+++ b/drivers/w1/slaves/w1_ds2423.c
@@ -138,19 +138,7 @@ static struct w1_family w1_family_1d = {
 	.fid = W1_COUNTER_DS2423,
 	.fops = &w1_f1d_fops,
 };
-
-static int __init w1_f1d_init(void)
-{
-	return w1_register_family(&w1_family_1d);
-}
-
-static void __exit w1_f1d_exit(void)
-{
-	w1_unregister_family(&w1_family_1d);
-}
-
-module_init(w1_f1d_init);
-module_exit(w1_f1d_exit);
+module_w1_family(w1_family_1d);
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Mika Laitio <lamikr@pilppa.org>");

commit 94c9e6d665011a9926c5f6fd349a6c665093e721
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Aug 21 15:44:59 2013 -0700

    w1: slaves: w1_ds2423: convert to use w1_family_ops.groups
    
    This moves the sysfs file creation/removal to the w1 core by using the
    .groups field, saving code in the slave driver.
    
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Cc: Alexander Stein <alexander.stein@informatik.tu-chemnitz.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/slaves/w1_ds2423.c b/drivers/w1/slaves/w1_ds2423.c
index 7f86aec74088..7e41b7d91fb5 100644
--- a/drivers/w1/slaves/w1_ds2423.c
+++ b/drivers/w1/slaves/w1_ds2423.c
@@ -40,14 +40,8 @@
 #define COUNTER_COUNT 4
 #define READ_BYTE_COUNT 42
 
-static ssize_t w1_counter_read(struct device *device,
-	struct device_attribute *attr, char *buf);
-
-static struct device_attribute w1_counter_attr =
-	__ATTR(w1_slave, S_IRUGO, w1_counter_read, NULL);
-
-static ssize_t w1_counter_read(struct device *device,
-	struct device_attribute *attr, char *out_buf)
+static ssize_t w1_slave_show(struct device *device,
+			     struct device_attribute *attr, char *out_buf)
 {
 	struct w1_slave *sl = dev_to_w1_slave(device);
 	struct w1_master *dev = sl->master;
@@ -128,19 +122,16 @@ static ssize_t w1_counter_read(struct device *device,
 	return PAGE_SIZE - c;
 }
 
-static int w1_f1d_add_slave(struct w1_slave *sl)
-{
-	return device_create_file(&sl->dev, &w1_counter_attr);
-}
+static DEVICE_ATTR_RO(w1_slave);
 
-static void w1_f1d_remove_slave(struct w1_slave *sl)
-{
-	device_remove_file(&sl->dev, &w1_counter_attr);
-}
+static struct attribute *w1_f1d_attrs[] = {
+	&dev_attr_w1_slave.attr,
+	NULL,
+};
+ATTRIBUTE_GROUPS(w1_f1d);
 
 static struct w1_family_ops w1_f1d_fops = {
-	.add_slave      = w1_f1d_add_slave,
-	.remove_slave   = w1_f1d_remove_slave,
+	.groups		= w1_f1d_groups,
 };
 
 static struct w1_family w1_family_1d = {

commit 8d7bda51888d14c07cbebacc5a10be776477bb63
Author: Alexander Stein <alexander.stein@informatik.tu-chemnitz.de>
Date:   Sun May 26 20:06:50 2013 +0200

    w1: add family based automatic module loading
    
    This patch allows the 1-wire bus to autoload the corresponding module
    for each slave being attached.
    This works similar to bluetooth protocols.
    
    Signed-off-by: Alexander Stein <alexander.stein@informatik.tu-chemnitz.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/slaves/w1_ds2423.c b/drivers/w1/slaves/w1_ds2423.c
index 40a10b5ed120..7f86aec74088 100644
--- a/drivers/w1/slaves/w1_ds2423.c
+++ b/drivers/w1/slaves/w1_ds2423.c
@@ -164,3 +164,4 @@ module_exit(w1_f1d_exit);
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Mika Laitio <lamikr@pilppa.org>");
 MODULE_DESCRIPTION("w1 family 1d driver for DS2423, 4 counters and 4kb ram");
+MODULE_ALIAS("w1-family-" __stringify(W1_COUNTER_DS2423));

commit b02f8bede217a4b145ecc16d3940c78d83941147
Author: NeilBrown <neilb@suse.de>
Date:   Fri May 18 15:59:52 2012 +1000

    W1: split master mutex to avoid deadlocks.
    
    The 'mutex' in struct w1_master is use for two very different
    purposes.
    
    Firstly it protects various data structures such as the list of all
    slaves.
    
    Secondly it protects the w1 buss against concurrent accesses.
    
    This can lead to deadlocks when the ->probe code called while adding a
    slave needs to talk on the bus, as is the case for power_supply
    devices.
    ds2780 and ds2781 drivers contain a work around to track which
    process hold the lock simply to avoid this deadlock.  bq27000 doesn't
    have that work around and so deadlocks.
    
    There are other possible deadlocks involving sysfs.
    When removing a device the sysfs s_active lock is held, so the lock
    that protects the slave list must take precedence over s_active.
    However when access power_supply attributes via sysfs, the s_active
    lock must take precedence over the lock that protects accesses to
    the bus.
    
    So to avoid deadlocks between w1 slaves and sysfs, these must be
    two separate locks.  Making them separate means that the work around
    in ds2780 and ds2781 can be removed.
    
    So this patch:
     - adds a new mutex: "bus_mutex" which serialises access to the bus.
     - takes in mutex in w1_search and ds1wm_search while they access
       the bus for searching.  The mutex is dropped before calling the
       callback which adds the slave.
     - changes all slaves to use bus_mutex instead of mutex to
       protect access to the bus
     - removes w1_ds2790_io_nolock and w1_ds2781_io_nolock, and the
       related code from drivers/power/ds278[01]_battery.c which
       calls them.
    
    Signed-off-by: NeilBrown <neilb@suse.de>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/slaves/w1_ds2423.c b/drivers/w1/slaves/w1_ds2423.c
index 7a7dbe5026f1..40a10b5ed120 100644
--- a/drivers/w1/slaves/w1_ds2423.c
+++ b/drivers/w1/slaves/w1_ds2423.c
@@ -66,7 +66,7 @@ static ssize_t w1_counter_read(struct device *device,
 	wrbuf[0]	= 0xA5;
 	wrbuf[1]	= rom_addr & 0xFF;
 	wrbuf[2]	= rom_addr >> 8;
-	mutex_lock(&dev->mutex);
+	mutex_lock(&dev->bus_mutex);
 	if (!w1_reset_select_slave(sl)) {
 		w1_write_block(dev, wrbuf, 3);
 		read_byte_count = 0;
@@ -124,7 +124,7 @@ static ssize_t w1_counter_read(struct device *device,
 	} else {
 		c -= snprintf(out_buf + PAGE_SIZE - c, c, "Connection error");
 	}
-	mutex_unlock(&dev->mutex);
+	mutex_unlock(&dev->bus_mutex);
 	return PAGE_SIZE - c;
 }
 

commit 17fecb5582962c2ca5627a51ec9ab0979fb673ef
Author: Mika Laitio <lamikr@pilppa.org>
Date:   Wed Jan 12 17:01:06 2011 -0800

    w1: DS2423 counter driver and documentation
    
    This is a 1-wire/w1 DS2423 slave driver for reading the values from all 4
    counters available DS2423 devices by using standard w1_slave file.  In
    ds2423 the counters are tied to ram pages 12-15 in and each of those
    ram-pages.  Each of these counter values (and asoociated ram page values)
    are represented as a own line in w1_slave file.  Driver has been tested on
    mips and x86.
    
    usage example:
    cat /sys/bus/w1/devices/1d-00000009b964/w1_slave
    
    00 02 00 00 00 00 00 00 00 6d 38 00 ff ff 00 00 fe ff 00 00 ff ff 00 00 ff
    ff 00 00 ff ff 00 00 ff ff 00 00 ff ff 00 00 ff ff crc=YES c=2
    00 02 00 00 00 00 00 00 00 e0 1f 00 ff ff 00 00 ff ff 00 00 ff ff 00 00 ff
    ff 00 00 ff ff 00 00 ff ff 00 00 ff ff 00 00 ff ff crc=YES c=2
    00 5a 0e 5f 18 00 00 00 00 0b 28 00 ff ff 00 00 ff ff 00 00 ff ff 00 00 ff
    ff 00 00 ff ff 00 00 ff ff 00 00 ff ff 00 00 ff ff crc=YES c=408882778
    00 05 00 00 00 00 00 00 00 8d 39 ff ff ff ff ff ff ff ff ff ff ff ff ff ff
    ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff crc=YES c=5
    
    Patch includes also the documentation.
    
    [randy.dunlap@oracle.com: fix ds2423 build, needs to select CRC16]
    Signed-off-by: Mika Laitio <lamikr@pilppa.org>
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/w1/slaves/w1_ds2423.c b/drivers/w1/slaves/w1_ds2423.c
new file mode 100644
index 000000000000..7a7dbe5026f1
--- /dev/null
+++ b/drivers/w1/slaves/w1_ds2423.c
@@ -0,0 +1,166 @@
+/*
+ *	w1_ds2423.c
+ *
+ * Copyright (c) 2010 Mika Laitio <lamikr@pilppa.org>
+ *
+ * This driver will read and write the value of 4 counters to w1_slave file in
+ * sys filesystem.
+ * Inspired by the w1_therm and w1_ds2431 drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the therms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/crc16.h>
+
+#include "../w1.h"
+#include "../w1_int.h"
+#include "../w1_family.h"
+
+#define CRC16_VALID	0xb001
+#define CRC16_INIT	0
+
+#define COUNTER_COUNT 4
+#define READ_BYTE_COUNT 42
+
+static ssize_t w1_counter_read(struct device *device,
+	struct device_attribute *attr, char *buf);
+
+static struct device_attribute w1_counter_attr =
+	__ATTR(w1_slave, S_IRUGO, w1_counter_read, NULL);
+
+static ssize_t w1_counter_read(struct device *device,
+	struct device_attribute *attr, char *out_buf)
+{
+	struct w1_slave *sl = dev_to_w1_slave(device);
+	struct w1_master *dev = sl->master;
+	u8 rbuf[COUNTER_COUNT * READ_BYTE_COUNT];
+	u8 wrbuf[3];
+	int rom_addr;
+	int read_byte_count;
+	int result;
+	ssize_t c;
+	int ii;
+	int p;
+	int crc;
+
+	c		= PAGE_SIZE;
+	rom_addr	= (12 << 5) + 31;
+	wrbuf[0]	= 0xA5;
+	wrbuf[1]	= rom_addr & 0xFF;
+	wrbuf[2]	= rom_addr >> 8;
+	mutex_lock(&dev->mutex);
+	if (!w1_reset_select_slave(sl)) {
+		w1_write_block(dev, wrbuf, 3);
+		read_byte_count = 0;
+		for (p = 0; p < 4; p++) {
+			/*
+			 * 1 byte for first bytes in ram page read
+			 * 4 bytes for counter
+			 * 4 bytes for zero bits
+			 * 2 bytes for crc
+			 * 31 remaining bytes from the ram page
+			 */
+			read_byte_count += w1_read_block(dev,
+				rbuf + (p * READ_BYTE_COUNT), READ_BYTE_COUNT);
+			for (ii = 0; ii < READ_BYTE_COUNT; ++ii)
+				c -= snprintf(out_buf + PAGE_SIZE - c,
+					c, "%02x ",
+					rbuf[(p * READ_BYTE_COUNT) + ii]);
+			if (read_byte_count != (p + 1) * READ_BYTE_COUNT) {
+				dev_warn(device,
+					"w1_counter_read() returned %u bytes "
+					"instead of %d bytes wanted.\n",
+					read_byte_count,
+					READ_BYTE_COUNT);
+				c -= snprintf(out_buf + PAGE_SIZE - c,
+					c, "crc=NO\n");
+			} else {
+				if (p == 0) {
+					crc = crc16(CRC16_INIT, wrbuf, 3);
+					crc = crc16(crc, rbuf, 11);
+				} else {
+					/*
+					 * DS2423 calculates crc from all bytes
+					 * read after the previous crc bytes.
+					 */
+					crc = crc16(CRC16_INIT,
+						(rbuf + 11) +
+						((p - 1) * READ_BYTE_COUNT),
+						READ_BYTE_COUNT);
+				}
+				if (crc == CRC16_VALID) {
+					result = 0;
+					for (ii = 4; ii > 0; ii--) {
+						result <<= 8;
+						result |= rbuf[(p *
+							READ_BYTE_COUNT) + ii];
+					}
+					c -= snprintf(out_buf + PAGE_SIZE - c,
+						c, "crc=YES c=%d\n", result);
+				} else {
+					c -= snprintf(out_buf + PAGE_SIZE - c,
+						c, "crc=NO\n");
+				}
+			}
+		}
+	} else {
+		c -= snprintf(out_buf + PAGE_SIZE - c, c, "Connection error");
+	}
+	mutex_unlock(&dev->mutex);
+	return PAGE_SIZE - c;
+}
+
+static int w1_f1d_add_slave(struct w1_slave *sl)
+{
+	return device_create_file(&sl->dev, &w1_counter_attr);
+}
+
+static void w1_f1d_remove_slave(struct w1_slave *sl)
+{
+	device_remove_file(&sl->dev, &w1_counter_attr);
+}
+
+static struct w1_family_ops w1_f1d_fops = {
+	.add_slave      = w1_f1d_add_slave,
+	.remove_slave   = w1_f1d_remove_slave,
+};
+
+static struct w1_family w1_family_1d = {
+	.fid = W1_COUNTER_DS2423,
+	.fops = &w1_f1d_fops,
+};
+
+static int __init w1_f1d_init(void)
+{
+	return w1_register_family(&w1_family_1d);
+}
+
+static void __exit w1_f1d_exit(void)
+{
+	w1_unregister_family(&w1_family_1d);
+}
+
+module_init(w1_f1d_init);
+module_exit(w1_f1d_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Mika Laitio <lamikr@pilppa.org>");
+MODULE_DESCRIPTION("w1 family 1d driver for DS2423, 4 counters and 4kb ram");
