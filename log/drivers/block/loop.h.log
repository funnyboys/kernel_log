commit 310ca162d779efee8a2dc3731439680f3e9c1e86
Author: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Date:   Thu Nov 8 14:01:02 2018 +0100

    block/loop: Use global lock for ioctl() operation.
    
    syzbot is reporting NULL pointer dereference [1] which is caused by
    race condition between ioctl(loop_fd, LOOP_CLR_FD, 0) versus
    ioctl(other_loop_fd, LOOP_SET_FD, loop_fd) due to traversing other
    loop devices at loop_validate_file() without holding corresponding
    lo->lo_ctl_mutex locks.
    
    Since ioctl() request on loop devices is not frequent operation, we don't
    need fine grained locking. Let's use global lock in order to allow safe
    traversal at loop_validate_file().
    
    Note that syzbot is also reporting circular locking dependency between
    bdev->bd_mutex and lo->lo_ctl_mutex [2] which is caused by calling
    blkdev_reread_part() with lock held. This patch does not address it.
    
    [1] https://syzkaller.appspot.com/bug?id=f3cfe26e785d85f9ee259f385515291d21bd80a3
    [2] https://syzkaller.appspot.com/bug?id=bf154052f0eea4bc7712499e4569505907d15889
    
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Reported-by: syzbot <syzbot+bf89c128e05dd6c62523@syzkaller.appspotmail.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/block/loop.h b/drivers/block/loop.h
index 4d42c7af7de7..af75a5ee4094 100644
--- a/drivers/block/loop.h
+++ b/drivers/block/loop.h
@@ -54,7 +54,6 @@ struct loop_device {
 
 	spinlock_t		lo_lock;
 	int			lo_state;
-	struct mutex		lo_ctl_mutex;
 	struct kthread_worker	worker;
 	struct task_struct	*worker_task;
 	bool			use_dio;

commit d3349b6b3c373ac1fbfb040b810fcee5e2adc7e0
Author: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Date:   Fri May 4 10:58:09 2018 -0600

    loop: remember whether sysfs_create_group() was done
    
    syzbot is hitting WARN() triggered by memory allocation fault
    injection [1] because loop module is calling sysfs_remove_group()
    when sysfs_create_group() failed.
    Fix this by remembering whether sysfs_create_group() succeeded.
    
    [1] https://syzkaller.appspot.com/bug?id=3f86c0edf75c86d2633aeb9dd69eccc70bc7e90b
    
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Reported-by: syzbot <syzbot+9f03168400f56df89dbc6f1751f4458fe739ff29@syzkaller.appspotmail.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    
    Renamed sysfs_ready -> sysfs_inited.
    
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/block/loop.h b/drivers/block/loop.h
index b78de9879f4f..4d42c7af7de7 100644
--- a/drivers/block/loop.h
+++ b/drivers/block/loop.h
@@ -58,6 +58,7 @@ struct loop_device {
 	struct kthread_worker	worker;
 	struct task_struct	*worker_task;
 	bool			use_dio;
+	bool			sysfs_inited;
 
 	struct request_queue	*lo_queue;
 	struct blk_mq_tag_set	tag_set;

commit 1894e916546df0efec9890a5c9954f4ad281494c
Author: Jens Axboe <axboe@kernel.dk>
Date:   Fri Apr 13 16:24:29 2018 -0600

    loop: remove cmd->rq member
    
    We can always get at the request from the payload, no need to store
    a pointer to it.
    
    Reviewed-by: Ming Lei <ming.lei@redhat.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/block/loop.h b/drivers/block/loop.h
index 0f45416e4fcf..b78de9879f4f 100644
--- a/drivers/block/loop.h
+++ b/drivers/block/loop.h
@@ -66,7 +66,6 @@ struct loop_device {
 
 struct loop_cmd {
 	struct kthread_work work;
-	struct request *rq;
 	bool use_aio; /* use AIO interface to handle I/O */
 	atomic_t ref; /* only for aio */
 	long ret;

commit d4478e92d6186ce37947a36994de407c27446266
Author: Shaohua Li <shli@fb.com>
Date:   Mon Sep 25 13:07:22 2017 -0600

    block/loop: make loop cgroup aware
    
    loop block device handles IO in a separate thread. The actual IO
    dispatched isn't cloned from the IO loop device received, so the
    dispatched IO loses the cgroup context.
    
    I'm ignoring buffer IO case now, which is quite complicated.  Making the
    loop thread aware cgroup context doesn't really help. The loop device
    only writes to a single file. In current writeback cgroup
    implementation, the file can only belong to one cgroup.
    
    For direct IO case, we could workaround the issue in theory. For
    example, say we assign cgroup1 5M/s BW for loop device and cgroup2
    10M/s. We can create a special cgroup for loop thread and assign at
    least 15M/s for the underlayer disk. In this way, we correctly throttle
    the two cgroups. But this is tricky to setup.
    
    This patch tries to address the issue. We record bio's css in loop
    command. When loop thread is handling the command, we then use the API
    provided in patch 1 to set the css for current task. The bio layer will
    use the css for new IO (from patch 3).
    
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Shaohua Li <shli@fb.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/block/loop.h b/drivers/block/loop.h
index 1f3956702993..0f45416e4fcf 100644
--- a/drivers/block/loop.h
+++ b/drivers/block/loop.h
@@ -72,6 +72,7 @@ struct loop_cmd {
 	long ret;
 	struct kiocb iocb;
 	struct bio_vec *bvec;
+	struct cgroup_subsys_state *css;
 };
 
 /* Support for loadable transfer modules */

commit e5313c141b49c1b1af43d1ca81398185d66ad1a6
Author: Omar Sandoval <osandov@fb.com>
Date:   Wed Sep 20 14:24:34 2017 -0700

    loop: remove union of use_aio and ref in struct loop_cmd
    
    When the request is completed, lo_complete_rq() checks cmd->use_aio.
    However, if this is in fact an aio request, cmd->use_aio will have
    already been reused as cmd->ref by lo_rw_aio*. Fix it by not using a
    union. On x86_64, there's a hole after the union anyways, so this
    doesn't make struct loop_cmd any bigger.
    
    Fixes: 92d773324b7e ("block/loop: fix use after free")
    Signed-off-by: Omar Sandoval <osandov@fb.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/block/loop.h b/drivers/block/loop.h
index f68c1d50802f..1f3956702993 100644
--- a/drivers/block/loop.h
+++ b/drivers/block/loop.h
@@ -67,10 +67,8 @@ struct loop_device {
 struct loop_cmd {
 	struct kthread_work work;
 	struct request *rq;
-	union {
-		bool use_aio; /* use AIO interface to handle I/O */
-		atomic_t ref; /* only for aio */
-	};
+	bool use_aio; /* use AIO interface to handle I/O */
+	atomic_t ref; /* only for aio */
 	long ret;
 	struct kiocb iocb;
 	struct bio_vec *bvec;

commit bc75705d00637c5f7b0346bf63094a9899c3d516
Author: Shaohua Li <shli@fb.com>
Date:   Fri Sep 1 11:15:18 2017 -0700

    block/loop: remove unused field
    
    nobody uses the list.
    
    Signed-off-by: Shaohua Li <shli@fb.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/block/loop.h b/drivers/block/loop.h
index b0ba4a5951c4..f68c1d50802f 100644
--- a/drivers/block/loop.h
+++ b/drivers/block/loop.h
@@ -67,7 +67,6 @@ struct loop_device {
 struct loop_cmd {
 	struct kthread_work work;
 	struct request *rq;
-	struct list_head list;
 	union {
 		bool use_aio; /* use AIO interface to handle I/O */
 		atomic_t ref; /* only for aio */

commit 92d773324b7edbd36bf0c28c1e0157763aeccc92
Author: Shaohua Li <shli@fb.com>
Date:   Fri Sep 1 11:15:17 2017 -0700

    block/loop: fix use after free
    
    lo_rw_aio->call_read_iter->
    1       aops->direct_IO
    2       iov_iter_revert
    lo_rw_aio_complete could happen between 1 and 2, the bio and bvec could
    be freed before 2, which accesses bvec.
    
    Signed-off-by: Shaohua Li <shli@fb.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/block/loop.h b/drivers/block/loop.h
index 43d20d37b79a..b0ba4a5951c4 100644
--- a/drivers/block/loop.h
+++ b/drivers/block/loop.h
@@ -68,7 +68,10 @@ struct loop_cmd {
 	struct kthread_work work;
 	struct request *rq;
 	struct list_head list;
-	bool use_aio;           /* use AIO interface to handle I/O */
+	union {
+		bool use_aio; /* use AIO interface to handle I/O */
+		atomic_t ref; /* only for aio */
+	};
 	long ret;
 	struct kiocb iocb;
 	struct bio_vec *bvec;

commit 40326d8a33d5b70039849d233975b63c733d94a2
Author: Shaohua Li <shli@fb.com>
Date:   Thu Aug 31 22:09:46 2017 -0700

    block/loop: allow request merge for directio mode
    
    Currently loop disables merge. While it makes sense for buffer IO mode,
    directio mode can benefit from request merge. Without merge, loop could
    send small size IO to underlayer disk and harm performance.
    
    Reviewed-by: Omar Sandoval <osandov@fb.com>
    Signed-off-by: Shaohua Li <shli@fb.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/block/loop.h b/drivers/block/loop.h
index efe57189d01e..43d20d37b79a 100644
--- a/drivers/block/loop.h
+++ b/drivers/block/loop.h
@@ -71,6 +71,7 @@ struct loop_cmd {
 	bool use_aio;           /* use AIO interface to handle I/O */
 	long ret;
 	struct kiocb iocb;
+	struct bio_vec *bvec;
 };
 
 /* Support for loadable transfer modules */

commit 8a0740c4109d646d8697d359962edea47301c652
Author: Omar Sandoval <osandov@fb.com>
Date:   Thu Aug 24 00:03:41 2017 -0700

    loop: get rid of lo_blocksize
    
    This is only used for setting the soft block size on the struct
    block_device once and then never used again.
    
    Reviewed-by: Ming Lei <ming.lei@redhat.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Omar Sandoval <osandov@fb.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/block/loop.h b/drivers/block/loop.h
index fecd3f97ef8c..efe57189d01e 100644
--- a/drivers/block/loop.h
+++ b/drivers/block/loop.h
@@ -48,7 +48,6 @@ struct loop_device {
 
 	struct file *	lo_backing_file;
 	struct block_device *lo_device;
-	unsigned	lo_blocksize;
 	void		*key_data; 
 
 	gfp_t		old_gfp_mask;

commit 1e6ec9ea89d30739b9447c1860fcb07fc29f3aef
Author: Omar Sandoval <osandov@fb.com>
Date:   Wed Aug 23 14:54:59 2017 -0700

    Revert "loop: support 4k physical blocksize"
    
    There's some stuff still up in the air, let's not get stuck with a
    subpar ABI. I'll follow up with something better for 4.14.
    
    Signed-off-by: Omar Sandoval <osandov@fb.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/block/loop.h b/drivers/block/loop.h
index 2c096b9a17b8..fecd3f97ef8c 100644
--- a/drivers/block/loop.h
+++ b/drivers/block/loop.h
@@ -49,7 +49,6 @@ struct loop_device {
 	struct file *	lo_backing_file;
 	struct block_device *lo_device;
 	unsigned	lo_blocksize;
-	unsigned	lo_logical_blocksize;
 	void		*key_data; 
 
 	gfp_t		old_gfp_mask;

commit f2c6df7dbf9a60e1cd9941f9fb376d4d9ad1e8dd
Author: Hannes Reinecke <hare@suse.de>
Date:   Thu Jun 8 13:46:45 2017 +0200

    loop: support 4k physical blocksize
    
    When generating bootable VM images certain systems (most notably
    s390x) require devices with 4k blocksize. This patch implements
    a new flag 'LO_FLAGS_BLOCKSIZE' which will set the physical
    blocksize to that of the underlying device, and allow to change
    the logical blocksize for up to the physical blocksize.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/block/loop.h b/drivers/block/loop.h
index fecd3f97ef8c..2c096b9a17b8 100644
--- a/drivers/block/loop.h
+++ b/drivers/block/loop.h
@@ -49,6 +49,7 @@ struct loop_device {
 	struct file *	lo_backing_file;
 	struct block_device *lo_device;
 	unsigned	lo_blocksize;
+	unsigned	lo_logical_blocksize;
 	void		*key_data; 
 
 	gfp_t		old_gfp_mask;

commit fe2cb2905c3dc872158e7ce30df05d72c3989645
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Apr 20 16:03:02 2017 +0200

    loop: zero-fill bio on the submitting cpu
    
    In thruth I've just audited which blk-mq drivers don't currently have a
    complete callback, but I think this change is at least borderline useful.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Ming Lei <ming.lei@redhat.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/block/loop.h b/drivers/block/loop.h
index fb2237c73e61..fecd3f97ef8c 100644
--- a/drivers/block/loop.h
+++ b/drivers/block/loop.h
@@ -70,6 +70,7 @@ struct loop_cmd {
 	struct request *rq;
 	struct list_head list;
 	bool use_aio;           /* use AIO interface to handle I/O */
+	long ret;
 	struct kiocb iocb;
 };
 

commit bc07c10a3603a5ab3ef01ba42b3d41f9ac63d1b6
Author: Ming Lei <ming.lei@canonical.com>
Date:   Mon Aug 17 10:31:51 2015 +0800

    block: loop: support DIO & AIO
    
    There are at least 3 advantages to use direct I/O and AIO on
    read/write loop's backing file:
    
    1) double cache can be avoided, then memory usage gets
    decreased a lot
    
    2) not like user space direct I/O, there isn't cost of
    pinning pages
    
    3) avoid context switch for obtaining good throughput
    - in buffered file read, random I/O top throughput is often obtained
    only if they are submitted concurrently from lots of tasks; but for
    sequential I/O, most of times they can be hit from page cache, so
    concurrent submissions often introduce unnecessary context switch
    and can't improve throughput much. There was such discussion[1]
    to use non-blocking I/O to improve the problem for application.
    - with direct I/O and AIO, concurrent submissions can be
    avoided and random read throughput can't be affected meantime
    
    xfstests(-g auto, ext4) is basically passed when running with
    direct I/O(aio), one exception is generic/232, but it failed in
    loop buffered I/O(4.2-rc6-next-20150814) too.
    
    Follows the fio test result for performance purpose:
            4 jobs fio test inside ext4 file system over loop block
    
    1) How to run
            - KVM: 4 VCPUs, 2G RAM
            - linux kernel: 4.2-rc6-next-20150814(base) with the patchset
            - the loop block is over one image on SSD.
            - linux psync, 4 jobs, size 1500M, ext4 over loop block
            - test result: IOPS from fio output
    
    2) Throughput(IOPS) becomes a bit better with direct I/O(aio)
            -------------------------------------------------------------
            test cases          |randread   |read   |randwrite  |write  |
            -------------------------------------------------------------
            base                |8015       |113811 |67442      |106978
            -------------------------------------------------------------
            base+loop aio       |8136       |125040 |67811      |111376
            -------------------------------------------------------------
    
    - somehow, it should be caused by more page cache avaiable for
    application or one extra page copy is avoided in case of direct I/O
    
    3) context switch
            - context switch decreased by ~50% with loop direct I/O(aio)
            compared with loop buffered I/O(4.2-rc6-next-20150814)
    
    4) memory usage from /proc/meminfo
            -------------------------------------------------------------
                                       | Buffers       | Cached
            -------------------------------------------------------------
            base                       | > 760MB       | ~950MB
            -------------------------------------------------------------
            base+loop direct I/O(aio)  | < 5MB         | ~1.6GB
            -------------------------------------------------------------
    
    - so there are much more page caches available for application with
    direct I/O
    
    [1] https://lwn.net/Articles/612483/
    
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/block/loop.h b/drivers/block/loop.h
index d1de2217c09a..fb2237c73e61 100644
--- a/drivers/block/loop.h
+++ b/drivers/block/loop.h
@@ -69,6 +69,8 @@ struct loop_cmd {
 	struct kthread_work work;
 	struct request *rq;
 	struct list_head list;
+	bool use_aio;           /* use AIO interface to handle I/O */
+	struct kiocb iocb;
 };
 
 /* Support for loadable transfer modules */

commit 2e5ab5f379f96a6207c45be40c357ebb1beb8ef3
Author: Ming Lei <ming.lei@canonical.com>
Date:   Mon Aug 17 10:31:49 2015 +0800

    block: loop: prepare for supporing direct IO
    
    This patches provides one interface for enabling direct IO
    from user space:
    
            - userspace(such as losetup) can pass 'file' which is
            opened/fcntl as O_DIRECT
    
    Also __loop_update_dio() is introduced to check if direct I/O
    can be used on current loop setting.
    
    The last big change is to introduce LO_FLAGS_DIRECT_IO flag
    for userspace to know if direct IO is used to access backing
    file.
    
    Cc: linux-api@vger.kernel.org
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/block/loop.h b/drivers/block/loop.h
index b6c7d21a453a..d1de2217c09a 100644
--- a/drivers/block/loop.h
+++ b/drivers/block/loop.h
@@ -58,6 +58,7 @@ struct loop_device {
 	struct mutex		lo_ctl_mutex;
 	struct kthread_worker	worker;
 	struct task_struct	*worker_task;
+	bool			use_dio;
 
 	struct request_queue	*lo_queue;
 	struct blk_mq_tag_set	tag_set;

commit e03a3d7a94e2485b6e2fa3fb630b9b3a30b65718
Author: Ming Lei <ming.lei@canonical.com>
Date:   Mon Aug 17 10:31:48 2015 +0800

    block: loop: use kthread_work
    
    The following patch will use dio/aio to submit IO to backing file,
    then it needn't to schedule IO concurrently from work, so
    use kthread_work for decreasing context switch cost a lot.
    
    For non-AIO case, single thread has been used for long long time,
    and it was just converted to work in v4.0, which has caused performance
    regression for fedora live booting already. In discussion[1], even
    though submitting I/O via work concurrently can improve random read IO
    throughput, meantime it might hurt sequential read IO performance, so
    better to restore to single thread behaviour.
    
    For the following AIO support, it is better to use multi hw-queue
    with per-hwq kthread than current work approach suppose there is so
    high performance requirement for loop.
    
    [1] http://marc.info/?t=143082678400002&r=1&w=2
    
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/block/loop.h b/drivers/block/loop.h
index 25e8997ed246..b6c7d21a453a 100644
--- a/drivers/block/loop.h
+++ b/drivers/block/loop.h
@@ -14,7 +14,7 @@
 #include <linux/blk-mq.h>
 #include <linux/spinlock.h>
 #include <linux/mutex.h>
-#include <linux/workqueue.h>
+#include <linux/kthread.h>
 #include <uapi/linux/loop.h>
 
 /* Possible states of device */
@@ -54,12 +54,10 @@ struct loop_device {
 	gfp_t		old_gfp_mask;
 
 	spinlock_t		lo_lock;
-	struct workqueue_struct *wq;
-	struct list_head	write_cmd_head;
-	struct work_struct	write_work;
-	bool			write_started;
 	int			lo_state;
 	struct mutex		lo_ctl_mutex;
+	struct kthread_worker	worker;
+	struct task_struct	*worker_task;
 
 	struct request_queue	*lo_queue;
 	struct blk_mq_tag_set	tag_set;
@@ -67,7 +65,7 @@ struct loop_device {
 };
 
 struct loop_cmd {
-	struct work_struct read_work;
+	struct kthread_work work;
 	struct request *rq;
 	struct list_head list;
 };

commit f8933667953e8e61bb6104f5ca88e32e85656a93
Author: Ming Lei <ming.lei@canonical.com>
Date:   Wed May 6 12:26:23 2015 +0800

    block: loop: don't hold lo_ctl_mutex in lo_open
    
    The lo_ctl_mutex is held for running all ioctl handlers, and
    in some ioctl handlers, ioctl_by_bdev(BLKRRPART) is called for
    rereading partitions, which requires bd_mutex.
    
    So it is easy to cause failure because trylock(bd_mutex) may
    fail inside blkdev_reread_part(), and follows the lock context:
    
    blkid or other application:
            ->open()
                    ->mutex_lock(bd_mutex)
                    ->lo_open()
                            ->mutex_lock(lo_ctl_mutex)
    
    losetup(set fd ioctl):
            ->mutex_lock(lo_ctl_mutex)
            ->ioctl_by_bdev(BLKRRPART)
                    ->trylock(bd_mutex)
    
    This patch trys to eliminate the ABBA lock dependency by removing
    lo_ctl_mutext in lo_open() with the following approach:
    
    1) make lo_refcnt as atomic_t and avoid acquiring lo_ctl_mutex in lo_open():
            - for open vs. add/del loop, no any problem because of loop_index_mutex
            - freeze request queue during clr_fd, so I/O can't come until
              clearing fd is completed, like the effect of holding lo_ctl_mutex
              in lo_open
            - both open() and release() have been serialized by bd_mutex already
    
    2) don't hold lo_ctl_mutex for decreasing/checking lo_refcnt in
    lo_release(), then lo_ctl_mutex is only required for the last release.
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Jarod Wilson <jarod@redhat.com>
    Acked-by: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/block/loop.h b/drivers/block/loop.h
index 49564edf5581..25e8997ed246 100644
--- a/drivers/block/loop.h
+++ b/drivers/block/loop.h
@@ -28,7 +28,7 @@ struct loop_func_table;
 
 struct loop_device {
 	int		lo_number;
-	int		lo_refcnt;
+	atomic_t	lo_refcnt;
 	loff_t		lo_offset;
 	loff_t		lo_sizelimit;
 	int		lo_flags;

commit f4aa4c7bbac6c4afdd4adccf90898c1a3685396d
Author: Ming Lei <ming.lei@canonical.com>
Date:   Tue May 5 19:49:54 2015 +0800

    block: loop: convert to per-device workqueue
    
    Documentation/workqueue.txt:
            If there is dependency among multiple work items used
            during memory reclaim, they should be queued to separate
            wq each with WQ_MEM_RECLAIM.
    
    Loop devices can be stacked, so we have to convert to per-device
    workqueue. One example is Fedora live CD.
    
    Fixes: b5dd2f6047ca108001328aac0e8588edd15f1778
    Cc: stable@vger.kernel.org (v4.0)
    Cc: Justin M. Forbes <jforbes@fedoraproject.org>
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/block/loop.h b/drivers/block/loop.h
index 301c27f8323f..49564edf5581 100644
--- a/drivers/block/loop.h
+++ b/drivers/block/loop.h
@@ -54,6 +54,7 @@ struct loop_device {
 	gfp_t		old_gfp_mask;
 
 	spinlock_t		lo_lock;
+	struct workqueue_struct *wq;
 	struct list_head	write_cmd_head;
 	struct work_struct	write_work;
 	bool			write_started;

commit 78e367a3601f35ea811e7f5660b7362afa2401fa
Author: Jens Axboe <axboe@fb.com>
Date:   Fri Jan 2 15:20:25 2015 -0700

    loop: add blk-mq.h include
    
    Looks like we pull it in through other ways on x86, but we fail
    on sparc:
    
    In file included from drivers/block/cryptoloop.c:30:0:
    drivers/block/loop.h:63:24: error: field 'tag_set' has incomplete type
    struct blk_mq_tag_set tag_set;
    
    Add the include to loop.h, kill it from loop.c.
    
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/block/loop.h b/drivers/block/loop.h
index e20cdbbff7d5..301c27f8323f 100644
--- a/drivers/block/loop.h
+++ b/drivers/block/loop.h
@@ -11,6 +11,7 @@
 
 #include <linux/bio.h>
 #include <linux/blkdev.h>
+#include <linux/blk-mq.h>
 #include <linux/spinlock.h>
 #include <linux/mutex.h>
 #include <linux/workqueue.h>

commit b5dd2f6047ca108001328aac0e8588edd15f1778
Author: Ming Lei <ming.lei@canonical.com>
Date:   Wed Dec 31 13:22:57 2014 +0000

    block: loop: improve performance via blk-mq
    
    The conversion is a bit straightforward, and use work queue to
    dispatch requests of loop block, and one big change is that requests
    is submitted to backend file/device concurrently with work queue,
    so throughput may get improved much. Given write requests over same
    file are often run exclusively, so don't handle them concurrently for
    avoiding extra context switch cost, possible lock contention and work
    schedule cost. Also with blk-mq, there is opportunity to get loop I/O
    merged before submitting to backend file/device.
    
    In the following test:
            - base: v3.19-rc2-2041231
            - loop over file in ext4 file system on SSD disk
            - bs: 4k, libaio, io depth: 64, O_DIRECT, num of jobs: 1
            - throughput: IOPS
    
            ------------------------------------------------------
            |            | base      | base with loop-mq | delta |
            ------------------------------------------------------
            | randread   | 1740      | 25318             | +1355%|
            ------------------------------------------------------
            | read       | 42196     | 51771             | +22.6%|
            -----------------------------------------------------
            | randwrite  | 35709     | 34624             | -3%   |
            -----------------------------------------------------
            | write      | 39137     | 40326             | +3%   |
            -----------------------------------------------------
    
    So loop-mq can improve throughput for both read and randread, meantime,
    performance of write and randwrite isn't hurted basically.
    
    Another benefit is that loop driver code gets simplified
    much after blk-mq conversion, and the patch can be thought as
    cleanup too.
    
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/block/loop.h b/drivers/block/loop.h
index 90df5d6485b6..e20cdbbff7d5 100644
--- a/drivers/block/loop.h
+++ b/drivers/block/loop.h
@@ -13,6 +13,7 @@
 #include <linux/blkdev.h>
 #include <linux/spinlock.h>
 #include <linux/mutex.h>
+#include <linux/workqueue.h>
 #include <uapi/linux/loop.h>
 
 /* Possible states of device */
@@ -52,19 +53,23 @@ struct loop_device {
 	gfp_t		old_gfp_mask;
 
 	spinlock_t		lo_lock;
-	struct bio_list		lo_bio_list;
-	unsigned int		lo_bio_count;
+	struct list_head	write_cmd_head;
+	struct work_struct	write_work;
+	bool			write_started;
 	int			lo_state;
 	struct mutex		lo_ctl_mutex;
-	struct task_struct	*lo_thread;
-	wait_queue_head_t	lo_event;
-	/* wait queue for incoming requests */
-	wait_queue_head_t	lo_req_wait;
 
 	struct request_queue	*lo_queue;
+	struct blk_mq_tag_set	tag_set;
 	struct gendisk		*lo_disk;
 };
 
+struct loop_cmd {
+	struct work_struct read_work;
+	struct request *rq;
+	struct list_head list;
+};
+
 /* Support for loadable transfer modules */
 struct loop_func_table {
 	int number;	/* filter type */ 

commit 83a8761142cb38536e9e88dfc2432d331ea4e257
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun May 12 10:14:07 2013 -0400

    move linux/loop.h to drivers/block
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/block/loop.h b/drivers/block/loop.h
new file mode 100644
index 000000000000..90df5d6485b6
--- /dev/null
+++ b/drivers/block/loop.h
@@ -0,0 +1,85 @@
+/*
+ * loop.h
+ *
+ * Written by Theodore Ts'o, 3/29/93.
+ *
+ * Copyright 1993 by Theodore Ts'o.  Redistribution of this file is
+ * permitted under the GNU General Public License.
+ */
+#ifndef _LINUX_LOOP_H
+#define _LINUX_LOOP_H
+
+#include <linux/bio.h>
+#include <linux/blkdev.h>
+#include <linux/spinlock.h>
+#include <linux/mutex.h>
+#include <uapi/linux/loop.h>
+
+/* Possible states of device */
+enum {
+	Lo_unbound,
+	Lo_bound,
+	Lo_rundown,
+};
+
+struct loop_func_table;
+
+struct loop_device {
+	int		lo_number;
+	int		lo_refcnt;
+	loff_t		lo_offset;
+	loff_t		lo_sizelimit;
+	int		lo_flags;
+	int		(*transfer)(struct loop_device *, int cmd,
+				    struct page *raw_page, unsigned raw_off,
+				    struct page *loop_page, unsigned loop_off,
+				    int size, sector_t real_block);
+	char		lo_file_name[LO_NAME_SIZE];
+	char		lo_crypt_name[LO_NAME_SIZE];
+	char		lo_encrypt_key[LO_KEY_SIZE];
+	int		lo_encrypt_key_size;
+	struct loop_func_table *lo_encryption;
+	__u32           lo_init[2];
+	kuid_t		lo_key_owner;	/* Who set the key */
+	int		(*ioctl)(struct loop_device *, int cmd, 
+				 unsigned long arg); 
+
+	struct file *	lo_backing_file;
+	struct block_device *lo_device;
+	unsigned	lo_blocksize;
+	void		*key_data; 
+
+	gfp_t		old_gfp_mask;
+
+	spinlock_t		lo_lock;
+	struct bio_list		lo_bio_list;
+	unsigned int		lo_bio_count;
+	int			lo_state;
+	struct mutex		lo_ctl_mutex;
+	struct task_struct	*lo_thread;
+	wait_queue_head_t	lo_event;
+	/* wait queue for incoming requests */
+	wait_queue_head_t	lo_req_wait;
+
+	struct request_queue	*lo_queue;
+	struct gendisk		*lo_disk;
+};
+
+/* Support for loadable transfer modules */
+struct loop_func_table {
+	int number;	/* filter type */ 
+	int (*transfer)(struct loop_device *lo, int cmd,
+			struct page *raw_page, unsigned raw_off,
+			struct page *loop_page, unsigned loop_off,
+			int size, sector_t real_block);
+	int (*init)(struct loop_device *, const struct loop_info64 *); 
+	/* release is called from loop_unregister_transfer or clr_fd */
+	int (*release)(struct loop_device *); 
+	int (*ioctl)(struct loop_device *, int cmd, unsigned long arg);
+	struct module *owner;
+}; 
+
+int loop_register_transfer(struct loop_func_table *funcs);
+int loop_unregister_transfer(int number); 
+
+#endif
