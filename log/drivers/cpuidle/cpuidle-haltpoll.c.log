commit 4902f7fcb3bcb4ce088db97bfd194401a784cc60
Author: Yihao Wu <wuyihao@linux.alibaba.com>
Date:   Wed Apr 8 18:11:36 2020 +0800

    cpuidle-haltpoll: Fix small typo
    
    Fix a spelling typo in cpuidle-haltpoll.c.
    
    Signed-off-by: Yihao Wu <wuyihao@linux.alibaba.com>
    [ rjw: Subject & changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpuidle/cpuidle-haltpoll.c b/drivers/cpuidle/cpuidle-haltpoll.c
index db124bc1ca2c..fcc53215bac8 100644
--- a/drivers/cpuidle/cpuidle-haltpoll.c
+++ b/drivers/cpuidle/cpuidle-haltpoll.c
@@ -94,7 +94,7 @@ static void haltpoll_uninit(void)
 	haltpoll_cpuidle_devices = NULL;
 }
 
-static bool haltpool_want(void)
+static bool haltpoll_want(void)
 {
 	return kvm_para_has_hint(KVM_HINTS_REALTIME) || force;
 }
@@ -110,7 +110,7 @@ static int __init haltpoll_init(void)
 
 	cpuidle_poll_state_init(drv);
 
-	if (!kvm_para_available() || !haltpool_want())
+	if (!kvm_para_available() || !haltpoll_want())
 		return -ENODEV;
 
 	ret = cpuidle_register_driver(drv);

commit dd52551fb786aa7371bf9fe922573deafc26287e
Author: Maciej S. Szmigiero <maciej.szmigiero@oracle.com>
Date:   Wed Mar 4 12:32:48 2020 +0100

    cpuidle: haltpoll: allow force loading on hosts without the REALTIME hint
    
    Before commit 1328edca4a14 ("cpuidle-haltpoll: Enable kvm guest polling
    when dedicated physical CPUs are available") the cpuidle-haltpoll driver
    could also be used in scenarios when the host does not advertise the
    KVM_HINTS_REALTIME hint.
    
    While the behavior introduced by the aforementioned commit makes sense as
    the default there are cases where the old behavior is desired, for example,
    when other kernel changes triggered by presence by this hint are unwanted,
    for some workloads where the latency benefit from polling overweights the
    loss from idle CPU capacity that otherwise would be available, or just when
    running under older Qemu versions that lack this hint.
    
    Let's provide a typical "force" module parameter that allows restoring the
    old behavior.
    
    Signed-off-by: Maciej S. Szmigiero <maciej.szmigiero@oracle.com>
    Reviewed-by: Marcelo Tosatti <mtosatti@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpuidle/cpuidle-haltpoll.c b/drivers/cpuidle/cpuidle-haltpoll.c
index b0ce9bc78113..db124bc1ca2c 100644
--- a/drivers/cpuidle/cpuidle-haltpoll.c
+++ b/drivers/cpuidle/cpuidle-haltpoll.c
@@ -18,6 +18,10 @@
 #include <linux/kvm_para.h>
 #include <linux/cpuidle_haltpoll.h>
 
+static bool force __read_mostly;
+module_param(force, bool, 0444);
+MODULE_PARM_DESC(force, "Load unconditionally");
+
 static struct cpuidle_device __percpu *haltpoll_cpuidle_devices;
 static enum cpuhp_state haltpoll_hp_state;
 
@@ -90,6 +94,11 @@ static void haltpoll_uninit(void)
 	haltpoll_cpuidle_devices = NULL;
 }
 
+static bool haltpool_want(void)
+{
+	return kvm_para_has_hint(KVM_HINTS_REALTIME) || force;
+}
+
 static int __init haltpoll_init(void)
 {
 	int ret;
@@ -101,8 +110,7 @@ static int __init haltpoll_init(void)
 
 	cpuidle_poll_state_init(drv);
 
-	if (!kvm_para_available() ||
-		!kvm_para_has_hint(KVM_HINTS_REALTIME))
+	if (!kvm_para_available() || !haltpool_want())
 		return -ENODEV;
 
 	ret = cpuidle_register_driver(drv);

commit 31d851407f90076c58291fb5eadc82c1dd613cee
Author: Zhenzhong Duan <zhenzhong.duan@oracle.com>
Date:   Fri Oct 18 08:49:29 2019 +0800

    cpuidle: haltpoll: Take 'idle=' override into account
    
    Currenly haltpoll isn't aware of the 'idle=' override, the priority is
    'idle=poll' > haltpoll > 'idle=halt'. When 'idle=poll' is used, cpuidle
    driver is bypassed but current_driver in sys still shows 'haltpoll'.
    
    When 'idle=halt' is used, haltpoll takes precedence and makes
    'idle=halt' have no effect.
    
    Add a check to prevent the haltpoll driver from loading if 'idle=' is
    present.
    
    Signed-off-by: Zhenzhong Duan <zhenzhong.duan@oracle.com>
    Co-developed-by: Joao Martins <joao.m.martins@oracle.com>
    [ rjw: Subject ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpuidle/cpuidle-haltpoll.c b/drivers/cpuidle/cpuidle-haltpoll.c
index 932390b028f1..b0ce9bc78113 100644
--- a/drivers/cpuidle/cpuidle-haltpoll.c
+++ b/drivers/cpuidle/cpuidle-haltpoll.c
@@ -95,6 +95,10 @@ static int __init haltpoll_init(void)
 	int ret;
 	struct cpuidle_driver *drv = &haltpoll_driver;
 
+	/* Do not load haltpoll if idle= is passed */
+	if (boot_option_idle_override != IDLE_NO_OVERRIDE)
+		return -ENODEV;
+
 	cpuidle_poll_state_init(drv);
 
 	if (!kvm_para_available() ||

commit 1328edca4a142ee3c7442d1eece2c3ca383eff35
Author: Wanpeng Li <wanpengli@tencent.com>
Date:   Thu Aug 29 16:49:57 2019 +0800

    cpuidle-haltpoll: Enable kvm guest polling when dedicated physical CPUs are available
    
    The downside of guest side polling is that polling is performed even
    with other runnable tasks in the host. However, even if poll in kvm
    can aware whether or not other runnable tasks in the same pCPU, it
    can still incur extra overhead in over-subscribe scenario. Now we can
    just enable guest polling when dedicated pCPUs are available.
    
    Acked-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Wanpeng Li <wanpengli@tencent.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpuidle/cpuidle-haltpoll.c b/drivers/cpuidle/cpuidle-haltpoll.c
index 49a65c6fe91e..932390b028f1 100644
--- a/drivers/cpuidle/cpuidle-haltpoll.c
+++ b/drivers/cpuidle/cpuidle-haltpoll.c
@@ -97,7 +97,8 @@ static int __init haltpoll_init(void)
 
 	cpuidle_poll_state_init(drv);
 
-	if (!kvm_para_available())
+	if (!kvm_para_available() ||
+		!kvm_para_has_hint(KVM_HINTS_REALTIME))
 		return -ENODEV;
 
 	ret = cpuidle_register_driver(drv);

commit 472f263660832b90e53bede2020f68cd14f8b76c
Author: Joao Martins <joao.m.martins@oracle.com>
Date:   Sun Sep 8 00:45:24 2019 +0100

    cpuidle-haltpoll: do not set an owner to allow modunload
    
    cpuidle-haltpoll can be built as a module to allow optional late load.
    Given we are setting @owner to THIS_MODULE, cpuidle will attempt to grab a
    module reference every time a cpuidle_device is registered -- so
    essentially all online cpus get a reference.
    
    This prevents for the module to be unloaded later, which makes the
    module_exit callback entirely unused. Thus remove the @owner and allow
    module to be unloaded.
    
    Fixes: fa86ee90eb11 ("add cpuidle-haltpoll driver")
    Signed-off-by: Joao Martins <joao.m.martins@oracle.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpuidle/cpuidle-haltpoll.c b/drivers/cpuidle/cpuidle-haltpoll.c
index 7a0239ef717e..49a65c6fe91e 100644
--- a/drivers/cpuidle/cpuidle-haltpoll.c
+++ b/drivers/cpuidle/cpuidle-haltpoll.c
@@ -35,7 +35,6 @@ static int default_enter_idle(struct cpuidle_device *dev,
 static struct cpuidle_driver haltpoll_driver = {
 	.name = "haltpoll",
 	.governor = "haltpoll",
-	.owner = THIS_MODULE,
 	.states = {
 		{ /* entry 0 is for polling */ },
 		{

commit 5cc59f597c0666c6a7e1c67aac9063895949fd56
Author: Joao Martins <joao.m.martins@oracle.com>
Date:   Sun Sep 8 00:45:23 2019 +0100

    cpuidle-haltpoll: return -ENODEV on modinit failure
    
    When a user loads cpuidle-haltpoll on a non KVM guest the module will
    successfully load, even though idle driver registration didn't take
    place.
    
    We should instead return -ENODEV signaling the user that the driver can't
    be loaded, like other error paths in haltpoll_init().  An example of such
    error paths is when we return -EBUSY when attempting to register an idle
    driver when it had one already (e.g. intel_idle loads at boot and then we
    attempt to insert module cpuidle-haltpoll).
    
    Fixes: fa86ee90eb11 ("add cpuidle-haltpoll driver")
    Signed-off-by: Joao Martins <joao.m.martins@oracle.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpuidle/cpuidle-haltpoll.c b/drivers/cpuidle/cpuidle-haltpoll.c
index 519e90d125cf..7a0239ef717e 100644
--- a/drivers/cpuidle/cpuidle-haltpoll.c
+++ b/drivers/cpuidle/cpuidle-haltpoll.c
@@ -99,7 +99,7 @@ static int __init haltpoll_init(void)
 	cpuidle_poll_state_init(drv);
 
 	if (!kvm_para_available())
-		return 0;
+		return -ENODEV;
 
 	ret = cpuidle_register_driver(drv);
 	if (ret < 0)

commit 7321440829a27d58c88b7fcfcbbc37487b5e39a5
Author: Joao Martins <joao.m.martins@oracle.com>
Date:   Sun Sep 8 00:45:22 2019 +0100

    cpuidle-haltpoll: set haltpoll as preferred governor
    
    Right now, guest current governors have the following ratings:
    
     * ladder            -> 10
     * teo               -> 19
     * menu              -> 20
     * haltpoll          -> 21
     * ladder + nohz=off -> 25
    
    haltpoll governor got introduced and it is now the default governor given
    its highest rating -- with ladder+nohz being the exception -- regardless of
    idle driver in the guest. An example of an undesirable case is x86 KVM
    guests with MWAIT which have intel_idle registered first, and consequently
    will have haltpoll be used as governor which would get limited to a poll
    state and state 1 and the other states wouldn't get used.
    
    To keep the previous defaults we decrease rating of governor to 9 (below
    current lowest rating) and thus rely on @governor switch on
    cpuidle_register_driver() to tie in haltpoll idle driver and governor
    together.
    
    Signed-off-by: Joao Martins <joao.m.martins@oracle.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpuidle/cpuidle-haltpoll.c b/drivers/cpuidle/cpuidle-haltpoll.c
index 56d8ab814466..519e90d125cf 100644
--- a/drivers/cpuidle/cpuidle-haltpoll.c
+++ b/drivers/cpuidle/cpuidle-haltpoll.c
@@ -34,6 +34,7 @@ static int default_enter_idle(struct cpuidle_device *dev,
 
 static struct cpuidle_driver haltpoll_driver = {
 	.name = "haltpoll",
+	.governor = "haltpoll",
 	.owner = THIS_MODULE,
 	.states = {
 		{ /* entry 0 is for polling */ },

commit 97d3eb9da84cae0548359b0aecb8619faad003b7
Author: Joao Martins <joao.m.martins@oracle.com>
Date:   Mon Sep 2 11:40:31 2019 +0100

    cpuidle-haltpoll: vcpu hotplug support
    
    When cpus != maxcpus cpuidle-haltpoll will fail to register all vcpus
    past the online ones and thus fail to register the idle driver.
    This is because cpuidle_add_sysfs() will return with -ENODEV as a
    consequence from get_cpu_device() return no device for a non-existing
    CPU.
    
    Instead switch to cpuidle_register_driver() and manually register each
    of the present cpus through cpuhp_setup_state() callbacks and future
    ones that get onlined or offlined. This mimmics similar logic that
    intel_idle does.
    
    Fixes: fa86ee90eb11 ("add cpuidle-haltpoll driver")
    Signed-off-by: Joao Martins <joao.m.martins@oracle.com>
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Reviewed-by: Marcelo Tosatti <mtosatti@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpuidle/cpuidle-haltpoll.c b/drivers/cpuidle/cpuidle-haltpoll.c
index 9ac093dcbb01..56d8ab814466 100644
--- a/drivers/cpuidle/cpuidle-haltpoll.c
+++ b/drivers/cpuidle/cpuidle-haltpoll.c
@@ -11,12 +11,16 @@
  */
 
 #include <linux/init.h>
+#include <linux/cpu.h>
 #include <linux/cpuidle.h>
 #include <linux/module.h>
 #include <linux/sched/idle.h>
 #include <linux/kvm_para.h>
 #include <linux/cpuidle_haltpoll.h>
 
+static struct cpuidle_device __percpu *haltpoll_cpuidle_devices;
+static enum cpuhp_state haltpoll_hp_state;
+
 static int default_enter_idle(struct cpuidle_device *dev,
 			      struct cpuidle_driver *drv, int index)
 {
@@ -46,6 +50,46 @@ static struct cpuidle_driver haltpoll_driver = {
 	.state_count = 2,
 };
 
+static int haltpoll_cpu_online(unsigned int cpu)
+{
+	struct cpuidle_device *dev;
+
+	dev = per_cpu_ptr(haltpoll_cpuidle_devices, cpu);
+	if (!dev->registered) {
+		dev->cpu = cpu;
+		if (cpuidle_register_device(dev)) {
+			pr_notice("cpuidle_register_device %d failed!\n", cpu);
+			return -EIO;
+		}
+		arch_haltpoll_enable(cpu);
+	}
+
+	return 0;
+}
+
+static int haltpoll_cpu_offline(unsigned int cpu)
+{
+	struct cpuidle_device *dev;
+
+	dev = per_cpu_ptr(haltpoll_cpuidle_devices, cpu);
+	if (dev->registered) {
+		arch_haltpoll_disable(cpu);
+		cpuidle_unregister_device(dev);
+	}
+
+	return 0;
+}
+
+static void haltpoll_uninit(void)
+{
+	if (haltpoll_hp_state)
+		cpuhp_remove_state(haltpoll_hp_state);
+	cpuidle_unregister_driver(&haltpoll_driver);
+
+	free_percpu(haltpoll_cpuidle_devices);
+	haltpoll_cpuidle_devices = NULL;
+}
+
 static int __init haltpoll_init(void)
 {
 	int ret;
@@ -56,17 +100,31 @@ static int __init haltpoll_init(void)
 	if (!kvm_para_available())
 		return 0;
 
-	ret = cpuidle_register(&haltpoll_driver, NULL);
-	if (ret == 0)
-		arch_haltpoll_enable();
+	ret = cpuidle_register_driver(drv);
+	if (ret < 0)
+		return ret;
+
+	haltpoll_cpuidle_devices = alloc_percpu(struct cpuidle_device);
+	if (haltpoll_cpuidle_devices == NULL) {
+		cpuidle_unregister_driver(drv);
+		return -ENOMEM;
+	}
+
+	ret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, "cpuidle/haltpoll:online",
+				haltpoll_cpu_online, haltpoll_cpu_offline);
+	if (ret < 0) {
+		haltpoll_uninit();
+	} else {
+		haltpoll_hp_state = ret;
+		ret = 0;
+	}
 
 	return ret;
 }
 
 static void __exit haltpoll_exit(void)
 {
-	arch_haltpoll_disable();
-	cpuidle_unregister(&haltpoll_driver);
+	haltpoll_uninit();
 }
 
 module_init(haltpoll_init);

commit a1c4423b02b2121108e3ea9580741e0f26309a48
Author: Marcelo Tosatti <mtosatti@redhat.com>
Date:   Wed Jul 3 20:51:29 2019 -0300

    cpuidle-haltpoll: disable host side polling when kvm virtualized
    
    When performing guest side polling, it is not necessary to
    also perform host side polling.
    
    So disable host side polling, via the new MSR interface,
    when loading cpuidle-haltpoll driver.
    
    Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpuidle/cpuidle-haltpoll.c b/drivers/cpuidle/cpuidle-haltpoll.c
index 35cfb53e9287..9ac093dcbb01 100644
--- a/drivers/cpuidle/cpuidle-haltpoll.c
+++ b/drivers/cpuidle/cpuidle-haltpoll.c
@@ -15,6 +15,7 @@
 #include <linux/module.h>
 #include <linux/sched/idle.h>
 #include <linux/kvm_para.h>
+#include <linux/cpuidle_haltpoll.h>
 
 static int default_enter_idle(struct cpuidle_device *dev,
 			      struct cpuidle_driver *drv, int index)
@@ -47,6 +48,7 @@ static struct cpuidle_driver haltpoll_driver = {
 
 static int __init haltpoll_init(void)
 {
+	int ret;
 	struct cpuidle_driver *drv = &haltpoll_driver;
 
 	cpuidle_poll_state_init(drv);
@@ -54,11 +56,16 @@ static int __init haltpoll_init(void)
 	if (!kvm_para_available())
 		return 0;
 
-	return cpuidle_register(&haltpoll_driver, NULL);
+	ret = cpuidle_register(&haltpoll_driver, NULL);
+	if (ret == 0)
+		arch_haltpoll_enable();
+
+	return ret;
 }
 
 static void __exit haltpoll_exit(void)
 {
+	arch_haltpoll_disable();
 	cpuidle_unregister(&haltpoll_driver);
 }
 

commit fa86ee90eb1111267de67cb4272b5ce711f18cbb
Author: Marcelo Tosatti <mtosatti@redhat.com>
Date:   Wed Jul 3 20:51:25 2019 -0300

    add cpuidle-haltpoll driver
    
    Add a cpuidle driver that calls the architecture default_idle routine.
    
    To be used in conjunction with the haltpoll governor.
    
    Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpuidle/cpuidle-haltpoll.c b/drivers/cpuidle/cpuidle-haltpoll.c
new file mode 100644
index 000000000000..35cfb53e9287
--- /dev/null
+++ b/drivers/cpuidle/cpuidle-haltpoll.c
@@ -0,0 +1,68 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * cpuidle driver for haltpoll governor.
+ *
+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2.  See
+ * the COPYING file in the top-level directory.
+ *
+ * Authors: Marcelo Tosatti <mtosatti@redhat.com>
+ */
+
+#include <linux/init.h>
+#include <linux/cpuidle.h>
+#include <linux/module.h>
+#include <linux/sched/idle.h>
+#include <linux/kvm_para.h>
+
+static int default_enter_idle(struct cpuidle_device *dev,
+			      struct cpuidle_driver *drv, int index)
+{
+	if (current_clr_polling_and_test()) {
+		local_irq_enable();
+		return index;
+	}
+	default_idle();
+	return index;
+}
+
+static struct cpuidle_driver haltpoll_driver = {
+	.name = "haltpoll",
+	.owner = THIS_MODULE,
+	.states = {
+		{ /* entry 0 is for polling */ },
+		{
+			.enter			= default_enter_idle,
+			.exit_latency		= 1,
+			.target_residency	= 1,
+			.power_usage		= -1,
+			.name			= "haltpoll idle",
+			.desc			= "default architecture idle",
+		},
+	},
+	.safe_state_index = 0,
+	.state_count = 2,
+};
+
+static int __init haltpoll_init(void)
+{
+	struct cpuidle_driver *drv = &haltpoll_driver;
+
+	cpuidle_poll_state_init(drv);
+
+	if (!kvm_para_available())
+		return 0;
+
+	return cpuidle_register(&haltpoll_driver, NULL);
+}
+
+static void __exit haltpoll_exit(void)
+{
+	cpuidle_unregister(&haltpoll_driver);
+}
+
+module_init(haltpoll_init);
+module_exit(haltpoll_exit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Marcelo Tosatti <mtosatti@redhat.com>");
