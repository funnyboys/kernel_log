commit df2fbf5bfa0e7fff8b4784507e4d68f200454318
Merge: 44ebe016df3a 8d485da0ddee
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 12 14:10:21 2020 -0700

    Merge tag 'thermal-v5.8-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/thermal/linux
    
    Pull thermal updates from Daniel Lezcano:
    
     - Add the hwmon support on the i.MX SC (Anson Huang)
    
     - Thermal framework cleanups (self-encapsulation, pointless stubs,
       private structures) (Daniel Lezcano)
    
     - Use the PM QoS frequency changes for the devfreq cooling device
       (Matthias Kaehlcke)
    
     - Remove duplicate error messages from platform_get_irq() error
       handling (Markus Elfring)
    
     - Add support for the bandgap sensors (Keerthy)
    
     - Statically initialize .get_mode/.set_mode ops (Andrzej Pietrasiewicz)
    
     - Add Renesas R-Car maintainer entry (Niklas Söderlund)
    
     - Fix error checking after calling ti_bandgap_get_sensor_data() for the
       TI SoC thermal (Sudip Mukherjee)
    
     - Add latency constraint for the idle injection, the DT binding and the
       change the registering function (Daniel Lezcano)
    
     - Convert the thermal framework binding to the Yaml schema (Amit
       Kucheria)
    
     - Replace zero-length array with flexible-array on i.MX 8MM (Gustavo A.
       R. Silva)
    
     - Thermal framework cleanups (alphabetic order for heads, replace
       module.h by export.h, make file naming consistent) (Amit Kucheria)
    
     - Merge tsens-common into the tsens driver (Amit Kucheria)
    
     - Fix platform dependency for the Qoriq driver (Geert Uytterhoeven)
    
     - Clean up the rcar_thermal_update_temp() function in the rcar thermal
       driver (Niklas Söderlund)
    
     - Fix the TMSAR register for the TMUv2 on the Qoriq platform (Yuantian
       Tang)
    
     - Export GDDV, OEM vendor variables, and don't require IDSP for the
       int340x thermal driver - trivial conflicts fixed (Matthew Garrett)
    
    * tag 'thermal-v5.8-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/thermal/linux: (48 commits)
      thermal/int340x_thermal: Don't require IDSP to exist
      thermal/int340x_thermal: Export OEM vendor variables
      thermal/int340x_thermal: Export GDDV
      thermal: qoriq: Update the settings for TMUv2
      thermal: rcar_thermal: Clean up rcar_thermal_update_temp()
      thermal: qoriq: Add platform dependencies
      drivers: thermal: tsens: Merge tsens-common.c into tsens.c
      thermal/of: Rename of-thermal.c
      thermal/governors: Prefix all source files with gov_
      thermal/drivers/user_space: Sort headers alphabetically
      thermal/drivers/of-thermal: Sort headers alphabetically
      thermal/drivers/cpufreq_cooling: Replace module.h with export.h
      thermal/drivers/cpufreq_cooling: Sort headers alphabetically
      thermal/drivers/clock_cooling: Include export.h
      thermal/drivers/clock_cooling: Sort headers alphabetically
      thermal/drivers/thermal_hwmon: Include export.h
      thermal/drivers/thermal_hwmon: Sort headers alphabetically
      thermal/drivers/thermal_helpers: Include export.h
      thermal/drivers/thermal_helpers: Sort headers alphabetically
      thermal/core: Replace module.h with export.h
      ...

commit fc7a3d9e9cd01e2679076c655f2bc4b04efbfa01
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Wed Apr 29 12:36:42 2020 +0200

    thermal: cpuidle: Register cpuidle cooling device
    
    The cpuidle driver can be used as a cooling device by injecting idle
    cycles.
    
    When the property is set, register the cpuidle driver with the idle
    state node pointer as a cooling device. The thermal framework will do
    the association automatically with the thermal zone via the
    cooling-device defined in the device tree cooling-maps section.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reviewed-by: Lukasz Luba <lukasz.luba@arm.com>
    Reviewed-by: Amit Kucheria <amit.kucheria@linaro.org>
    Acked-by: Sudeep Holla <sudeep.holla@arm.com>
    Link: https://lore.kernel.org/r/20200429103644.5492-4-daniel.lezcano@linaro.org

diff --git a/drivers/cpuidle/cpuidle-psci.c b/drivers/cpuidle/cpuidle-psci.c
index bae9140a65a5..1f38e0dfc9b2 100644
--- a/drivers/cpuidle/cpuidle-psci.c
+++ b/drivers/cpuidle/cpuidle-psci.c
@@ -9,6 +9,7 @@
 #define pr_fmt(fmt) "CPUidle PSCI: " fmt
 
 #include <linux/cpuhotplug.h>
+#include <linux/cpu_cooling.h>
 #include <linux/cpuidle.h>
 #include <linux/cpumask.h>
 #include <linux/cpu_pm.h>
@@ -313,6 +314,8 @@ static int __init psci_idle_init_cpu(int cpu)
 	if (ret)
 		goto out_kfree_drv;
 
+	cpuidle_cooling_register(drv);
+
 	return 0;
 
 out_kfree_drv:

commit 8b7ce5e49049ca78c238f03d70569a73da049f32
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon May 11 15:33:46 2020 +0200

    cpuidle: psci: Fixup execution order when entering a domain idle state
    
    Moving forward, platforms are going to need to execute specific "last-man"
    operations before a domain idle state can be entered. In one way or the
    other, these operations needs to be triggered while walking the
    hierarchical topology via runtime PM and genpd, as it's at that point the
    last-man becomes known.
    
    Moreover, executing last-man operations needs to be done after the CPU PM
    notifications are sent through cpu_pm_enter(), as otherwise it's likely
    that some notifications would fail. Therefore, let's re-order the sequence
    in psci_enter_domain_idle_state(), so cpu_pm_enter() gets called prior
    pm_runtime_put_sync().
    
    Fixes: ce85aef570df ("cpuidle: psci: Manage runtime PM in the idle path")
    Reported-by: Lina Iyer <ilina@codeaurora.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpuidle/cpuidle-psci.c b/drivers/cpuidle/cpuidle-psci.c
index bae9140a65a5..d0fb585073c6 100644
--- a/drivers/cpuidle/cpuidle-psci.c
+++ b/drivers/cpuidle/cpuidle-psci.c
@@ -58,6 +58,10 @@ static int psci_enter_domain_idle_state(struct cpuidle_device *dev,
 	u32 state;
 	int ret;
 
+	ret = cpu_pm_enter();
+	if (ret)
+		return -1;
+
 	/* Do runtime PM to manage a hierarchical CPU toplogy. */
 	pm_runtime_put_sync_suspend(pd_dev);
 
@@ -65,10 +69,12 @@ static int psci_enter_domain_idle_state(struct cpuidle_device *dev,
 	if (!state)
 		state = states[idx];
 
-	ret = psci_enter_state(idx, state);
+	ret = psci_cpu_suspend_enter(state) ? -1 : idx;
 
 	pm_runtime_get_sync(pd_dev);
 
+	cpu_pm_exit();
+
 	/* Clear the domain state to start fresh when back from idle. */
 	psci_set_domain_state(0);
 	return ret;

commit 7fbee48ea0fb00976ea15db3a2103ef20005a54a
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Mar 10 11:40:39 2020 +0100

    cpuidle: psci: Split psci_dt_cpu_init_idle()
    
    To make the code a bit more readable, let's move the OSI specific
    initialization out of the psci_dt_cpu_init_idle() and into a separate
    function.
    
    Reviewed-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpuidle/cpuidle-psci.c b/drivers/cpuidle/cpuidle-psci.c
index edd7a54ef0d3..bae9140a65a5 100644
--- a/drivers/cpuidle/cpuidle-psci.c
+++ b/drivers/cpuidle/cpuidle-psci.c
@@ -160,6 +160,29 @@ int __init psci_dt_parse_state_node(struct device_node *np, u32 *state)
 	return 0;
 }
 
+static int __init psci_dt_cpu_init_topology(struct cpuidle_driver *drv,
+					    struct psci_cpuidle_data *data,
+					    unsigned int state_count, int cpu)
+{
+	/* Currently limit the hierarchical topology to be used in OSI mode. */
+	if (!psci_has_osi_support())
+		return 0;
+
+	data->dev = psci_dt_attach_cpu(cpu);
+	if (IS_ERR_OR_NULL(data->dev))
+		return PTR_ERR_OR_ZERO(data->dev);
+
+	/*
+	 * Using the deepest state for the CPU to trigger a potential selection
+	 * of a shared state for the domain, assumes the domain states are all
+	 * deeper states.
+	 */
+	drv->states[state_count - 1].enter = psci_enter_domain_idle_state;
+	psci_cpuidle_use_cpuhp = true;
+
+	return 0;
+}
+
 static int __init psci_dt_cpu_init_idle(struct cpuidle_driver *drv,
 					struct device_node *cpu_node,
 					unsigned int state_count, int cpu)
@@ -193,25 +216,10 @@ static int __init psci_dt_cpu_init_idle(struct cpuidle_driver *drv,
 		goto free_mem;
 	}
 
-	/* Currently limit the hierarchical topology to be used in OSI mode. */
-	if (psci_has_osi_support()) {
-		data->dev = psci_dt_attach_cpu(cpu);
-		if (IS_ERR(data->dev)) {
-			ret = PTR_ERR(data->dev);
-			goto free_mem;
-		}
-
-		/*
-		 * Using the deepest state for the CPU to trigger a potential
-		 * selection of a shared state for the domain, assumes the
-		 * domain states are all deeper states.
-		 */
-		if (data->dev) {
-			drv->states[state_count - 1].enter =
-				psci_enter_domain_idle_state;
-			psci_cpuidle_use_cpuhp = true;
-		}
-	}
+	/* Initialize optional data, used for the hierarchical topology. */
+	ret = psci_dt_cpu_init_topology(drv, data, state_count, cpu);
+	if (ret < 0)
+		goto free_mem;
 
 	/* Idle states parsed correctly, store them in the per-cpu struct. */
 	data->psci_states = psci_states;

commit a65a397f245137f6ffcd5e6490cd2504c30f8e73
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Oct 10 12:01:48 2019 +0200

    cpuidle: psci: Add support for PM domains by using genpd
    
    When the hierarchical CPU topology layout is used in DT and the PSCI OSI
    mode is supported by the PSCI FW, let's initialize a corresponding PM
    domain topology by using genpd. This enables a CPU and a group of CPUs,
    when attached to the topology, to be power-managed accordingly.
    
    To trigger the attempt to initialize the genpd data structures let's use a
    subsys_initcall, which should be early enough to allow CPUs, but also other
    devices to be attached.
    
    The initialization consists of parsing the PSCI OF node for the topology
    and the "domain idle states" DT bindings. In case the idle states are
    compatible with "domain-idle-state", the initialized genpd becomes
    responsible of selecting an idle state for the PM domain, via assigning it
    a genpd governor.
    
    Note that, a successful initialization of the genpd data structures, is
    followed by a call to psci_set_osi_mode(), as to try to enable the OSI mode
    in the PSCI FW. In case this fails, we fall back into a degraded mode
    rather than bailing out and returning error codes.
    
    Co-developed-by: Lina Iyer <lina.iyer@linaro.org>
    Signed-off-by: Lina Iyer <lina.iyer@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Sudeep Holla <sudeep.holla@arm.com>
    Acked-by: Rafael J. Wysocki <rafael@kernel.org>

diff --git a/drivers/cpuidle/cpuidle-psci.c b/drivers/cpuidle/cpuidle-psci.c
index 9d779be27071..edd7a54ef0d3 100644
--- a/drivers/cpuidle/cpuidle-psci.c
+++ b/drivers/cpuidle/cpuidle-psci.c
@@ -34,7 +34,7 @@ static DEFINE_PER_CPU_READ_MOSTLY(struct psci_cpuidle_data, psci_cpuidle_data);
 static DEFINE_PER_CPU(u32, domain_state);
 static bool psci_cpuidle_use_cpuhp __initdata;
 
-static inline void psci_set_domain_state(u32 state)
+void psci_set_domain_state(u32 state)
 {
 	__this_cpu_write(domain_state, state);
 }
@@ -143,7 +143,7 @@ static const struct of_device_id psci_idle_state_match[] __initconst = {
 	{ },
 };
 
-static int __init psci_dt_parse_state_node(struct device_node *np, u32 *state)
+int __init psci_dt_parse_state_node(struct device_node *np, u32 *state)
 {
 	int err = of_property_read_u32(np, "arm,psci-suspend-param", state);
 

commit 9c6ceecb6541954dfc410aa8883f872469326c73
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Oct 10 12:01:48 2019 +0200

    cpuidle: psci: Support CPU hotplug for the hierarchical model
    
    When the hierarchical CPU topology is used and when a CPU is put offline,
    that CPU prevents its PM domain from being powered off, which is because
    genpd observes the corresponding attached device as being active from a
    runtime PM point of view. Furthermore, any potential master PM domains are
    also prevented from being powered off.
    
    To address this limitation, let's add add a new CPU hotplug state
    (CPUHP_AP_CPU_PM_STARTING) and register up/down callbacks for it, which
    allows us to deal with runtime PM accordingly.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Sudeep Holla <sudeep.holla@arm.com>
    Acked-by: Rafael J. Wysocki <rafael@kernel.org>

diff --git a/drivers/cpuidle/cpuidle-psci.c b/drivers/cpuidle/cpuidle-psci.c
index 6e7804e697ed..9d779be27071 100644
--- a/drivers/cpuidle/cpuidle-psci.c
+++ b/drivers/cpuidle/cpuidle-psci.c
@@ -8,6 +8,7 @@
 
 #define pr_fmt(fmt) "CPUidle PSCI: " fmt
 
+#include <linux/cpuhotplug.h>
 #include <linux/cpuidle.h>
 #include <linux/cpumask.h>
 #include <linux/cpu_pm.h>
@@ -31,6 +32,7 @@ struct psci_cpuidle_data {
 
 static DEFINE_PER_CPU_READ_MOSTLY(struct psci_cpuidle_data, psci_cpuidle_data);
 static DEFINE_PER_CPU(u32, domain_state);
+static bool psci_cpuidle_use_cpuhp __initdata;
 
 static inline void psci_set_domain_state(u32 state)
 {
@@ -72,6 +74,44 @@ static int psci_enter_domain_idle_state(struct cpuidle_device *dev,
 	return ret;
 }
 
+static int psci_idle_cpuhp_up(unsigned int cpu)
+{
+	struct device *pd_dev = __this_cpu_read(psci_cpuidle_data.dev);
+
+	if (pd_dev)
+		pm_runtime_get_sync(pd_dev);
+
+	return 0;
+}
+
+static int psci_idle_cpuhp_down(unsigned int cpu)
+{
+	struct device *pd_dev = __this_cpu_read(psci_cpuidle_data.dev);
+
+	if (pd_dev) {
+		pm_runtime_put_sync(pd_dev);
+		/* Clear domain state to start fresh at next online. */
+		psci_set_domain_state(0);
+	}
+
+	return 0;
+}
+
+static void __init psci_idle_init_cpuhp(void)
+{
+	int err;
+
+	if (!psci_cpuidle_use_cpuhp)
+		return;
+
+	err = cpuhp_setup_state_nocalls(CPUHP_AP_CPU_PM_STARTING,
+					"cpuidle/psci:online",
+					psci_idle_cpuhp_up,
+					psci_idle_cpuhp_down);
+	if (err)
+		pr_warn("Failed %d while setup cpuhp state\n", err);
+}
+
 static int psci_enter_idle_state(struct cpuidle_device *dev,
 				struct cpuidle_driver *drv, int idx)
 {
@@ -166,9 +206,11 @@ static int __init psci_dt_cpu_init_idle(struct cpuidle_driver *drv,
 		 * selection of a shared state for the domain, assumes the
 		 * domain states are all deeper states.
 		 */
-		if (data->dev)
+		if (data->dev) {
 			drv->states[state_count - 1].enter =
 				psci_enter_domain_idle_state;
+			psci_cpuidle_use_cpuhp = true;
+		}
 	}
 
 	/* Idle states parsed correctly, store them in the per-cpu struct. */
@@ -289,6 +331,7 @@ static int __init psci_idle_init(void)
 			goto out_fail;
 	}
 
+	psci_idle_init_cpuhp();
 	return 0;
 
 out_fail:

commit ce85aef570df406fc8cb360e7351024570ef7d4f
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Oct 10 12:01:48 2019 +0200

    cpuidle: psci: Manage runtime PM in the idle path
    
    In case we have succeeded to attach a CPU to its PM domain, let's deploy
    runtime PM support for the corresponding attached device, to allow the CPU
    to be powered-managed accordingly.
    
    The triggering point for when runtime PM reference counting should be done,
    has been selected to the deepest idle state for the CPU. However, from the
    hierarchical point view, there may be good reasons to do runtime PM
    reference counting even on shallower idle states, but at this point this
    isn't supported, mainly due to limitations set by the generic PM domain.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Sudeep Holla <sudeep.holla@arm.com>
    Acked-by: Rafael J. Wysocki <rafael@kernel.org>

diff --git a/drivers/cpuidle/cpuidle-psci.c b/drivers/cpuidle/cpuidle-psci.c
index 9600fe674a89..6e7804e697ed 100644
--- a/drivers/cpuidle/cpuidle-psci.c
+++ b/drivers/cpuidle/cpuidle-psci.c
@@ -16,6 +16,7 @@
 #include <linux/of.h>
 #include <linux/of_device.h>
 #include <linux/psci.h>
+#include <linux/pm_runtime.h>
 #include <linux/slab.h>
 
 #include <asm/cpuidle.h>
@@ -51,14 +52,21 @@ static int psci_enter_domain_idle_state(struct cpuidle_device *dev,
 {
 	struct psci_cpuidle_data *data = this_cpu_ptr(&psci_cpuidle_data);
 	u32 *states = data->psci_states;
-	u32 state = psci_get_domain_state();
+	struct device *pd_dev = data->dev;
+	u32 state;
 	int ret;
 
+	/* Do runtime PM to manage a hierarchical CPU toplogy. */
+	pm_runtime_put_sync_suspend(pd_dev);
+
+	state = psci_get_domain_state();
 	if (!state)
 		state = states[idx];
 
 	ret = psci_enter_state(idx, state);
 
+	pm_runtime_get_sync(pd_dev);
+
 	/* Clear the domain state to start fresh when back from idle. */
 	psci_set_domain_state(0);
 	return ret;

commit a0cf319460745a6102555ecf99994374704dcb4c
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Oct 10 12:01:48 2019 +0200

    cpuidle: psci: Prepare to use OS initiated suspend mode via PM domains
    
    The per CPU variable psci_power_state, contains an array of fixed values,
    which reflects the corresponding arm,psci-suspend-param parsed from DT, for
    each of the available CPU idle states.
    
    This isn't sufficient when using the hierarchical CPU topology in DT, in
    combination with having PSCI OS initiated (OSI) mode enabled. More
    precisely, in OSI mode, Linux is responsible of telling the PSCI FW what
    idle state the cluster (a group of CPUs) should enter, while in PSCI
    Platform Coordinated (PC) mode, each CPU independently votes for an idle
    state of the cluster.
    
    For this reason, introduce a per CPU variable called domain_state and
    implement two helper functions to read/write its value. Then let the
    domain_state take precedence over the regular selected state, when entering
    and idle state.
    
    To avoid executing the above OSI specific code in the ->enter() callback,
    while operating in the default PSCI Platform Coordinated mode, let's also
    add a new enter-function and use it for OSI.
    
    Co-developed-by: Lina Iyer <lina.iyer@linaro.org>
    Signed-off-by: Lina Iyer <lina.iyer@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Sudeep Holla <sudeep.holla@arm.com>
    Acked-by: Rafael J. Wysocki <rafael@kernel.org>

diff --git a/drivers/cpuidle/cpuidle-psci.c b/drivers/cpuidle/cpuidle-psci.c
index 6a87848be3c3..9600fe674a89 100644
--- a/drivers/cpuidle/cpuidle-psci.c
+++ b/drivers/cpuidle/cpuidle-psci.c
@@ -29,14 +29,47 @@ struct psci_cpuidle_data {
 };
 
 static DEFINE_PER_CPU_READ_MOSTLY(struct psci_cpuidle_data, psci_cpuidle_data);
+static DEFINE_PER_CPU(u32, domain_state);
+
+static inline void psci_set_domain_state(u32 state)
+{
+	__this_cpu_write(domain_state, state);
+}
+
+static inline u32 psci_get_domain_state(void)
+{
+	return __this_cpu_read(domain_state);
+}
+
+static inline int psci_enter_state(int idx, u32 state)
+{
+	return CPU_PM_CPU_IDLE_ENTER_PARAM(psci_cpu_suspend_enter, idx, state);
+}
+
+static int psci_enter_domain_idle_state(struct cpuidle_device *dev,
+					struct cpuidle_driver *drv, int idx)
+{
+	struct psci_cpuidle_data *data = this_cpu_ptr(&psci_cpuidle_data);
+	u32 *states = data->psci_states;
+	u32 state = psci_get_domain_state();
+	int ret;
+
+	if (!state)
+		state = states[idx];
+
+	ret = psci_enter_state(idx, state);
+
+	/* Clear the domain state to start fresh when back from idle. */
+	psci_set_domain_state(0);
+	return ret;
+}
 
 static int psci_enter_idle_state(struct cpuidle_device *dev,
 				struct cpuidle_driver *drv, int idx)
 {
 	u32 *state = __this_cpu_read(psci_cpuidle_data.psci_states);
 
-	return CPU_PM_CPU_IDLE_ENTER_PARAM(psci_cpu_suspend_enter,
-					   idx, state[idx]);
+	return psci_enter_state(idx, state[idx]);
 }
 
 static struct cpuidle_driver psci_idle_driver __initdata = {
@@ -79,7 +112,8 @@ static int __init psci_dt_parse_state_node(struct device_node *np, u32 *state)
 	return 0;
 }
 
-static int __init psci_dt_cpu_init_idle(struct device_node *cpu_node,
+static int __init psci_dt_cpu_init_idle(struct cpuidle_driver *drv,
+					struct device_node *cpu_node,
 					unsigned int state_count, int cpu)
 {
 	int i, ret = 0;
@@ -118,6 +152,15 @@ static int __init psci_dt_cpu_init_idle(struct device_node *cpu_node,
 			ret = PTR_ERR(data->dev);
 			goto free_mem;
 		}
+
+		/*
+		 * Using the deepest state for the CPU to trigger a potential
+		 * selection of a shared state for the domain, assumes the
+		 * domain states are all deeper states.
+		 */
+		if (data->dev)
+			drv->states[state_count - 1].enter =
+				psci_enter_domain_idle_state;
 	}
 
 	/* Idle states parsed correctly, store them in the per-cpu struct. */
@@ -129,7 +172,8 @@ static int __init psci_dt_cpu_init_idle(struct device_node *cpu_node,
 	return ret;
 }
 
-static __init int psci_cpu_init_idle(unsigned int cpu, unsigned int state_count)
+static __init int psci_cpu_init_idle(struct cpuidle_driver *drv,
+				     unsigned int cpu, unsigned int state_count)
 {
 	struct device_node *cpu_node;
 	int ret;
@@ -145,7 +189,7 @@ static __init int psci_cpu_init_idle(unsigned int cpu, unsigned int state_count)
 	if (!cpu_node)
 		return -ENODEV;
 
-	ret = psci_dt_cpu_init_idle(cpu_node, state_count, cpu);
+	ret = psci_dt_cpu_init_idle(drv, cpu_node, state_count, cpu);
 
 	of_node_put(cpu_node);
 
@@ -201,7 +245,7 @@ static int __init psci_idle_init_cpu(int cpu)
 	/*
 	 * Initialize PSCI idle states.
 	 */
-	ret = psci_cpu_init_idle(cpu, ret);
+	ret = psci_cpu_init_idle(drv, cpu, ret);
 	if (ret) {
 		pr_err("CPU %d failed to PSCI idle\n", cpu);
 		goto out_kfree_drv;

commit 8554951a4dd3d3a1a0efeba8eb5543eee7533be4
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Oct 10 12:01:48 2019 +0200

    cpuidle: psci: Attach CPU devices to their PM domains
    
    In order to enable a CPU to be power managed through its PM domain, let's
    try to attach it by calling psci_dt_attach_cpu() during the cpuidle
    initialization.
    
    psci_dt_attach_cpu() returns a pointer to the attached struct device, which
    later should be used for runtime PM, hence we need to store it somewhere.
    Rather than adding yet another per CPU variable, let's create a per CPU
    struct to collect the relevant per CPU variables.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Sudeep Holla <sudeep.holla@arm.com>
    Acked-by: Rafael J. Wysocki <rafael@kernel.org>

diff --git a/drivers/cpuidle/cpuidle-psci.c b/drivers/cpuidle/cpuidle-psci.c
index 830995b8a56f..6a87848be3c3 100644
--- a/drivers/cpuidle/cpuidle-psci.c
+++ b/drivers/cpuidle/cpuidle-psci.c
@@ -20,14 +20,20 @@
 
 #include <asm/cpuidle.h>
 
+#include "cpuidle-psci.h"
 #include "dt_idle_states.h"
 
-static DEFINE_PER_CPU_READ_MOSTLY(u32 *, psci_power_state);
+struct psci_cpuidle_data {
+	u32 *psci_states;
+	struct device *dev;
+};
+
+static DEFINE_PER_CPU_READ_MOSTLY(struct psci_cpuidle_data, psci_cpuidle_data);
 
 static int psci_enter_idle_state(struct cpuidle_device *dev,
 				struct cpuidle_driver *drv, int idx)
 {
-	u32 *state = __this_cpu_read(psci_power_state);
+	u32 *state = __this_cpu_read(psci_cpuidle_data.psci_states);
 
 	return CPU_PM_CPU_IDLE_ENTER_PARAM(psci_cpu_suspend_enter,
 					   idx, state[idx]);
@@ -79,6 +85,7 @@ static int __init psci_dt_cpu_init_idle(struct device_node *cpu_node,
 	int i, ret = 0;
 	u32 *psci_states;
 	struct device_node *state_node;
+	struct psci_cpuidle_data *data = per_cpu_ptr(&psci_cpuidle_data, cpu);
 
 	state_count++; /* Add WFI state too */
 	psci_states = kcalloc(state_count, sizeof(*psci_states), GFP_KERNEL);
@@ -104,8 +111,17 @@ static int __init psci_dt_cpu_init_idle(struct device_node *cpu_node,
 		goto free_mem;
 	}
 
-	/* Idle states parsed correctly, initialize per-cpu pointer */
-	per_cpu(psci_power_state, cpu) = psci_states;
+	/* Currently limit the hierarchical topology to be used in OSI mode. */
+	if (psci_has_osi_support()) {
+		data->dev = psci_dt_attach_cpu(cpu);
+		if (IS_ERR(data->dev)) {
+			ret = PTR_ERR(data->dev);
+			goto free_mem;
+		}
+	}
+
+	/* Idle states parsed correctly, store them in the per-cpu struct. */
+	data->psci_states = psci_states;
 	return 0;
 
 free_mem:

commit f08cfbfa4fb1b5cf15d9f3d3f8ef2280236f4a12
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Oct 10 12:01:48 2019 +0200

    cpuidle: psci: Support hierarchical CPU idle states
    
    Currently CPU's idle states are represented using the flattened model.
    Let's add support for the hierarchical layout, via converting to use
    of_get_cpu_state_node().
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Sudeep Holla <sudeep.holla@arm.com>
    Acked-by: Rafael J. Wysocki <rafael@kernel.org>

diff --git a/drivers/cpuidle/cpuidle-psci.c b/drivers/cpuidle/cpuidle-psci.c
index 761359be50f2..830995b8a56f 100644
--- a/drivers/cpuidle/cpuidle-psci.c
+++ b/drivers/cpuidle/cpuidle-psci.c
@@ -86,8 +86,7 @@ static int __init psci_dt_cpu_init_idle(struct device_node *cpu_node,
 		return -ENOMEM;
 
 	for (i = 1; i < state_count; i++) {
-		state_node = of_parse_phandle(cpu_node, "cpu-idle-states",
-					      i - 1);
+		state_node = of_get_cpu_state_node(cpu_node, i - 1);
 		if (!state_node)
 			break;
 

commit 1595e4b09b2e7f7fc83369ecc3066505b6c7359b
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Oct 10 12:01:48 2019 +0200

    cpuidle: psci: Simplify OF parsing of CPU idle state nodes
    
    Iterating through the idle state nodes in DT, to find out the number of
    states that needs to be allocated is unnecessary, as it has already been
    done from dt_init_idle_driver(). Therefore, drop the iteration and use the
    number we already have at hand.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Sudeep Holla <sudeep.holla@arm.com>
    Acked-by: Rafael J. Wysocki <rafael@kernel.org>

diff --git a/drivers/cpuidle/cpuidle-psci.c b/drivers/cpuidle/cpuidle-psci.c
index 361985f52ddd..761359be50f2 100644
--- a/drivers/cpuidle/cpuidle-psci.c
+++ b/drivers/cpuidle/cpuidle-psci.c
@@ -73,30 +73,24 @@ static int __init psci_dt_parse_state_node(struct device_node *np, u32 *state)
 	return 0;
 }
 
-static int __init psci_dt_cpu_init_idle(struct device_node *cpu_node, int cpu)
+static int __init psci_dt_cpu_init_idle(struct device_node *cpu_node,
+					unsigned int state_count, int cpu)
 {
-	int i, ret = 0, count = 0;
+	int i, ret = 0;
 	u32 *psci_states;
 	struct device_node *state_node;
 
-	/* Count idle states */
-	while ((state_node = of_parse_phandle(cpu_node, "cpu-idle-states",
-					      count))) {
-		count++;
-		of_node_put(state_node);
-	}
-
-	if (!count)
-		return -ENODEV;
-
-	count++; /* Add WFI state too */
-	psci_states = kcalloc(count, sizeof(*psci_states), GFP_KERNEL);
+	state_count++; /* Add WFI state too */
+	psci_states = kcalloc(state_count, sizeof(*psci_states), GFP_KERNEL);
 	if (!psci_states)
 		return -ENOMEM;
 
-	for (i = 1; i < count; i++) {
+	for (i = 1; i < state_count; i++) {
 		state_node = of_parse_phandle(cpu_node, "cpu-idle-states",
 					      i - 1);
+		if (!state_node)
+			break;
+
 		ret = psci_dt_parse_state_node(state_node, &psci_states[i]);
 		of_node_put(state_node);
 
@@ -106,6 +100,11 @@ static int __init psci_dt_cpu_init_idle(struct device_node *cpu_node, int cpu)
 		pr_debug("psci-power-state %#x index %d\n", psci_states[i], i);
 	}
 
+	if (i != state_count) {
+		ret = -ENODEV;
+		goto free_mem;
+	}
+
 	/* Idle states parsed correctly, initialize per-cpu pointer */
 	per_cpu(psci_power_state, cpu) = psci_states;
 	return 0;
@@ -115,7 +114,7 @@ static int __init psci_dt_cpu_init_idle(struct device_node *cpu_node, int cpu)
 	return ret;
 }
 
-static __init int psci_cpu_init_idle(unsigned int cpu)
+static __init int psci_cpu_init_idle(unsigned int cpu, unsigned int state_count)
 {
 	struct device_node *cpu_node;
 	int ret;
@@ -131,7 +130,7 @@ static __init int psci_cpu_init_idle(unsigned int cpu)
 	if (!cpu_node)
 		return -ENODEV;
 
-	ret = psci_dt_cpu_init_idle(cpu_node, cpu);
+	ret = psci_dt_cpu_init_idle(cpu_node, state_count, cpu);
 
 	of_node_put(cpu_node);
 
@@ -187,7 +186,7 @@ static int __init psci_idle_init_cpu(int cpu)
 	/*
 	 * Initialize PSCI idle states.
 	 */
-	ret = psci_cpu_init_idle(cpu);
+	ret = psci_cpu_init_idle(cpu, ret);
 	if (ret) {
 		pr_err("CPU %d failed to PSCI idle\n", cpu);
 		goto out_kfree_drv;

commit 4386aa866d99e31243a53a75041dba7901b9ec61
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Thu Oct 24 16:18:34 2019 +0100

    cpuidle: psci: Align psci_power_state count with idle state count
    
    Instead of allocating 'n-1' states in psci_power_state to manage 'n'
    idle states which include "ARM WFI" state, it would be simpler to have
    1:1 mapping between psci_power_state and cpuidle driver states.
    
    ARM WFI state(i.e. idx == 0) is handled specially in the generic macro
    CPU_PM_CPU_IDLE_ENTER_PARAM and hence state[-1] is not possible. However
    for sake of code readability, it is better to have 1:1 mapping and not
    use [idx - 1] to access psci_power_state corresponding to driver cpuidle
    state for idx.
    
    psci_power_state[0] is default initialised to 0 and is never accessed
    while entering WFI state.
    
    Reported-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Rafael J. Wysocki <rafael@kernel.org>

diff --git a/drivers/cpuidle/cpuidle-psci.c b/drivers/cpuidle/cpuidle-psci.c
index f3c1a2396f98..361985f52ddd 100644
--- a/drivers/cpuidle/cpuidle-psci.c
+++ b/drivers/cpuidle/cpuidle-psci.c
@@ -30,7 +30,7 @@ static int psci_enter_idle_state(struct cpuidle_device *dev,
 	u32 *state = __this_cpu_read(psci_power_state);
 
 	return CPU_PM_CPU_IDLE_ENTER_PARAM(psci_cpu_suspend_enter,
-					   idx, state[idx - 1]);
+					   idx, state[idx]);
 }
 
 static struct cpuidle_driver psci_idle_driver __initdata = {
@@ -89,12 +89,14 @@ static int __init psci_dt_cpu_init_idle(struct device_node *cpu_node, int cpu)
 	if (!count)
 		return -ENODEV;
 
+	count++; /* Add WFI state too */
 	psci_states = kcalloc(count, sizeof(*psci_states), GFP_KERNEL);
 	if (!psci_states)
 		return -ENOMEM;
 
-	for (i = 0; i < count; i++) {
-		state_node = of_parse_phandle(cpu_node, "cpu-idle-states", i);
+	for (i = 1; i < count; i++) {
+		state_node = of_parse_phandle(cpu_node, "cpu-idle-states",
+					      i - 1);
 		ret = psci_dt_parse_state_node(state_node, &psci_states[i]);
 		of_node_put(state_node);
 

commit 9ffeb6d08c3a4bbd7b1e33711b241f511e2ded79
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Fri Aug 9 12:03:12 2019 +0100

    PSCI: cpuidle: Refactor CPU suspend power_state parameter handling
    
    Current PSCI code handles idle state entry through the
    psci_cpu_suspend_enter() API, that takes an idle state index as a
    parameter and convert the index into a previously initialized
    power_state parameter before calling the PSCI.CPU_SUSPEND() with it.
    
    This is unwieldly, since it forces the PSCI firmware layer to keep track
    of power_state parameter for every idle state so that the
    index->power_state conversion can be made in the PSCI firmware layer
    instead of the CPUidle driver implementations.
    
    Move the power_state handling out of drivers/firmware/psci
    into the respective ACPI/DT PSCI CPUidle backends and convert
    the psci_cpu_suspend_enter() API to get the power_state
    parameter as input, which makes it closer to its firmware
    interface PSCI.CPU_SUSPEND() API.
    
    A notable side effect is that the PSCI ACPI/DT CPUidle backends
    now can directly handle (and if needed update) power_state
    parameters before handing them over to the PSCI firmware
    interface to trigger PSCI.CPU_SUSPEND() calls.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/drivers/cpuidle/cpuidle-psci.c b/drivers/cpuidle/cpuidle-psci.c
index ab1dea918ea3..f3c1a2396f98 100644
--- a/drivers/cpuidle/cpuidle-psci.c
+++ b/drivers/cpuidle/cpuidle-psci.c
@@ -22,10 +22,15 @@
 
 #include "dt_idle_states.h"
 
+static DEFINE_PER_CPU_READ_MOSTLY(u32 *, psci_power_state);
+
 static int psci_enter_idle_state(struct cpuidle_device *dev,
 				struct cpuidle_driver *drv, int idx)
 {
-	return CPU_PM_CPU_IDLE_ENTER(psci_cpu_suspend_enter, idx);
+	u32 *state = __this_cpu_read(psci_power_state);
+
+	return CPU_PM_CPU_IDLE_ENTER_PARAM(psci_cpu_suspend_enter,
+					   idx, state[idx - 1]);
 }
 
 static struct cpuidle_driver psci_idle_driver __initdata = {
@@ -51,6 +56,86 @@ static const struct of_device_id psci_idle_state_match[] __initconst = {
 	{ },
 };
 
+static int __init psci_dt_parse_state_node(struct device_node *np, u32 *state)
+{
+	int err = of_property_read_u32(np, "arm,psci-suspend-param", state);
+
+	if (err) {
+		pr_warn("%pOF missing arm,psci-suspend-param property\n", np);
+		return err;
+	}
+
+	if (!psci_power_state_is_valid(*state)) {
+		pr_warn("Invalid PSCI power state %#x\n", *state);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int __init psci_dt_cpu_init_idle(struct device_node *cpu_node, int cpu)
+{
+	int i, ret = 0, count = 0;
+	u32 *psci_states;
+	struct device_node *state_node;
+
+	/* Count idle states */
+	while ((state_node = of_parse_phandle(cpu_node, "cpu-idle-states",
+					      count))) {
+		count++;
+		of_node_put(state_node);
+	}
+
+	if (!count)
+		return -ENODEV;
+
+	psci_states = kcalloc(count, sizeof(*psci_states), GFP_KERNEL);
+	if (!psci_states)
+		return -ENOMEM;
+
+	for (i = 0; i < count; i++) {
+		state_node = of_parse_phandle(cpu_node, "cpu-idle-states", i);
+		ret = psci_dt_parse_state_node(state_node, &psci_states[i]);
+		of_node_put(state_node);
+
+		if (ret)
+			goto free_mem;
+
+		pr_debug("psci-power-state %#x index %d\n", psci_states[i], i);
+	}
+
+	/* Idle states parsed correctly, initialize per-cpu pointer */
+	per_cpu(psci_power_state, cpu) = psci_states;
+	return 0;
+
+free_mem:
+	kfree(psci_states);
+	return ret;
+}
+
+static __init int psci_cpu_init_idle(unsigned int cpu)
+{
+	struct device_node *cpu_node;
+	int ret;
+
+	/*
+	 * If the PSCI cpu_suspend function hook has not been initialized
+	 * idle states must not be enabled, so bail out
+	 */
+	if (!psci_ops.cpu_suspend)
+		return -EOPNOTSUPP;
+
+	cpu_node = of_cpu_device_node_get(cpu);
+	if (!cpu_node)
+		return -ENODEV;
+
+	ret = psci_dt_cpu_init_idle(cpu_node, cpu);
+
+	of_node_put(cpu_node);
+
+	return ret;
+}
+
 static int __init psci_idle_init_cpu(int cpu)
 {
 	struct cpuidle_driver *drv;

commit 81d549e0c810773bf003a25f59fa5509857bf9b2
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Fri Aug 9 12:03:10 2019 +0100

    ARM: psci: cpuidle: Introduce PSCI CPUidle driver
    
    PSCI firmware is the standard power management control for
    all ARM64 based platforms and it is also deployed on some
    ARM 32 bit platforms to date.
    
    Idle state entry in PSCI is currently achieved by calling
    arm_cpuidle_init() and arm_cpuidle_suspend() in a generic
    idle driver, which in turn relies on ARM/ARM64 CPUidle back-end
    to relay the call into PSCI firmware if PSCI is the boot method.
    
    Given that PSCI is the standard idle entry method on ARM64 systems
    (which means that no other CPUidle driver are expected on ARM64
    platforms - so PSCI is already a generic idle driver), in order to
    simplify idle entry and code maintenance, it makes sense to have a PSCI
    specific idle driver so that idle code that it is currently living in
    drivers/firmware directory can be hoisted out of it and moved
    where it belongs, into a full-fledged PSCI driver, leaving PSCI code
    in drivers/firmware as a pure firmware interface, as it should be.
    
    Implement a PSCI CPUidle driver. By default it is a silent Kconfig entry
    which is left unselected, since it selection would clash with the
    generic ARM CPUidle driver that provides a PSCI based idle driver
    through the arm/arm64 arches back-ends CPU operations.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/drivers/cpuidle/cpuidle-psci.c b/drivers/cpuidle/cpuidle-psci.c
new file mode 100644
index 000000000000..ab1dea918ea3
--- /dev/null
+++ b/drivers/cpuidle/cpuidle-psci.c
@@ -0,0 +1,151 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * PSCI CPU idle driver.
+ *
+ * Copyright (C) 2019 ARM Ltd.
+ * Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
+ */
+
+#define pr_fmt(fmt) "CPUidle PSCI: " fmt
+
+#include <linux/cpuidle.h>
+#include <linux/cpumask.h>
+#include <linux/cpu_pm.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/psci.h>
+#include <linux/slab.h>
+
+#include <asm/cpuidle.h>
+
+#include "dt_idle_states.h"
+
+static int psci_enter_idle_state(struct cpuidle_device *dev,
+				struct cpuidle_driver *drv, int idx)
+{
+	return CPU_PM_CPU_IDLE_ENTER(psci_cpu_suspend_enter, idx);
+}
+
+static struct cpuidle_driver psci_idle_driver __initdata = {
+	.name = "psci_idle",
+	.owner = THIS_MODULE,
+	/*
+	 * PSCI idle states relies on architectural WFI to
+	 * be represented as state index 0.
+	 */
+	.states[0] = {
+		.enter                  = psci_enter_idle_state,
+		.exit_latency           = 1,
+		.target_residency       = 1,
+		.power_usage		= UINT_MAX,
+		.name                   = "WFI",
+		.desc                   = "ARM WFI",
+	}
+};
+
+static const struct of_device_id psci_idle_state_match[] __initconst = {
+	{ .compatible = "arm,idle-state",
+	  .data = psci_enter_idle_state },
+	{ },
+};
+
+static int __init psci_idle_init_cpu(int cpu)
+{
+	struct cpuidle_driver *drv;
+	struct device_node *cpu_node;
+	const char *enable_method;
+	int ret = 0;
+
+	cpu_node = of_cpu_device_node_get(cpu);
+	if (!cpu_node)
+		return -ENODEV;
+
+	/*
+	 * Check whether the enable-method for the cpu is PSCI, fail
+	 * if it is not.
+	 */
+	enable_method = of_get_property(cpu_node, "enable-method", NULL);
+	if (!enable_method || (strcmp(enable_method, "psci")))
+		ret = -ENODEV;
+
+	of_node_put(cpu_node);
+	if (ret)
+		return ret;
+
+	drv = kmemdup(&psci_idle_driver, sizeof(*drv), GFP_KERNEL);
+	if (!drv)
+		return -ENOMEM;
+
+	drv->cpumask = (struct cpumask *)cpumask_of(cpu);
+
+	/*
+	 * Initialize idle states data, starting at index 1, since
+	 * by default idle state 0 is the quiescent state reached
+	 * by the cpu by executing the wfi instruction.
+	 *
+	 * If no DT idle states are detected (ret == 0) let the driver
+	 * initialization fail accordingly since there is no reason to
+	 * initialize the idle driver if only wfi is supported, the
+	 * default archictectural back-end already executes wfi
+	 * on idle entry.
+	 */
+	ret = dt_init_idle_driver(drv, psci_idle_state_match, 1);
+	if (ret <= 0) {
+		ret = ret ? : -ENODEV;
+		goto out_kfree_drv;
+	}
+
+	/*
+	 * Initialize PSCI idle states.
+	 */
+	ret = psci_cpu_init_idle(cpu);
+	if (ret) {
+		pr_err("CPU %d failed to PSCI idle\n", cpu);
+		goto out_kfree_drv;
+	}
+
+	ret = cpuidle_register(drv, NULL);
+	if (ret)
+		goto out_kfree_drv;
+
+	return 0;
+
+out_kfree_drv:
+	kfree(drv);
+	return ret;
+}
+
+/*
+ * psci_idle_init - Initializes PSCI cpuidle driver
+ *
+ * Initializes PSCI cpuidle driver for all CPUs, if any CPU fails
+ * to register cpuidle driver then rollback to cancel all CPUs
+ * registration.
+ */
+static int __init psci_idle_init(void)
+{
+	int cpu, ret;
+	struct cpuidle_driver *drv;
+	struct cpuidle_device *dev;
+
+	for_each_possible_cpu(cpu) {
+		ret = psci_idle_init_cpu(cpu);
+		if (ret)
+			goto out_fail;
+	}
+
+	return 0;
+
+out_fail:
+	while (--cpu >= 0) {
+		dev = per_cpu(cpuidle_devices, cpu);
+		drv = cpuidle_get_cpu_driver(dev);
+		cpuidle_unregister(drv);
+		kfree(drv);
+	}
+
+	return ret;
+}
+device_initcall(psci_idle_init);
