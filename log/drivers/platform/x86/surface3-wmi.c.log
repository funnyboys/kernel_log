commit b886d83c5b621abc84ff9616f14c529be3f6b147
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:55 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 441
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2 of the license
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 315 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190115.503150771@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/platform/x86/surface3-wmi.c b/drivers/platform/x86/surface3-wmi.c
index 25b176996cb7..130b6f52a600 100644
--- a/drivers/platform/x86/surface3-wmi.c
+++ b/drivers/platform/x86/surface3-wmi.c
@@ -1,14 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  Driver for the LID cover switch of the Surface 3
  *
  *  Copyright (c) 2016 Red Hat Inc.
  */
 
-/*
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; version 2 of the License.
- */
 
 #include <linux/kernel.h>
 #include <linux/module.h>

commit e95ac4574b23a5fd8f5c5f2c19ef69ac15b7252c
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Wed Jan 18 09:13:46 2017 +0100

    platform/x86: surface3-wmi: fix uninitialized symbol
    
    The patch 3dda3b3798f9: "platform/x86: Add custom surface3 platform
    device for controlling LID" from Nov 25, 2016, leads to the following
    static checker warning:
    
            drivers/platform/x86/surface3-wmi.c:168 s3_wmi_check_platform_device()
            error: uninitialized symbol 'ts_adev'.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/surface3-wmi.c b/drivers/platform/x86/surface3-wmi.c
index 6ac1d1349d7e..25b176996cb7 100644
--- a/drivers/platform/x86/surface3-wmi.c
+++ b/drivers/platform/x86/surface3-wmi.c
@@ -139,7 +139,7 @@ static acpi_status s3_wmi_attach_spi_device(acpi_handle handle,
 
 static int s3_wmi_check_platform_device(struct device *dev, void *data)
 {
-	struct acpi_device *adev, *ts_adev;
+	struct acpi_device *adev, *ts_adev = NULL;
 	acpi_handle handle;
 	acpi_status status;
 

commit 44e6861646748a21b55725adc0780342f4440066
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Jan 10 16:28:47 2017 +0100

    platform/x86: surface3-wmi: Shut up unused-function warning
    
    The newly added driver guards its "resume" callback with an
    warning in some configurations:
    
    drivers/platform/x86/surface3-wmi.c:248:12: error: 's3_wmi_resume' defined but not used [-Werror=unused-function]
    
    Using a __maybe_unused annotation without an #ifdef avoids the mistake more
    reliably.
    
    Fixes: 3dda3b3798f9 ("platform/x86: Add custom surface3 platform device for controlling LID")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/surface3-wmi.c b/drivers/platform/x86/surface3-wmi.c
index cbf4d83a7271..6ac1d1349d7e 100644
--- a/drivers/platform/x86/surface3-wmi.c
+++ b/drivers/platform/x86/surface3-wmi.c
@@ -244,13 +244,11 @@ static int s3_wmi_remove(struct platform_device *device)
 	return 0;
 }
 
-#ifdef CONFIG_PM
-static int s3_wmi_resume(struct device *dev)
+static int __maybe_unused s3_wmi_resume(struct device *dev)
 {
 	s3_wmi_send_lid_state();
 	return 0;
 }
-#endif
 static SIMPLE_DEV_PM_OPS(s3_wmi_pm, NULL, s3_wmi_resume);
 
 static struct platform_driver s3_wmi_driver = {

commit 83da6b59919a71a1a97ce9863aa0267eaf6d496c
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu Dec 15 03:10:02 2016 +0200

    platform/x86: surface3-wmi: Balance locking on error path
    
    There is a possibility that lock will be left acquired.
    Consolidate error path under out_free_unlock label.
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/surface3-wmi.c b/drivers/platform/x86/surface3-wmi.c
index 5553b2b85e0a..cbf4d83a7271 100644
--- a/drivers/platform/x86/surface3-wmi.c
+++ b/drivers/platform/x86/surface3-wmi.c
@@ -60,10 +60,10 @@ static DEFINE_MUTEX(s3_wmi_lock);
 
 static int s3_wmi_query_block(const char *guid, int instance, int *ret)
 {
+	struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
 	acpi_status status;
 	union acpi_object *obj;
-
-	struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
+	int error = 0;
 
 	mutex_lock(&s3_wmi_lock);
 	status = wmi_query_block(guid, instance, &output);
@@ -77,13 +77,14 @@ static int s3_wmi_query_block(const char *guid, int instance, int *ret)
 			       obj->type == ACPI_TYPE_BUFFER ?
 						obj->buffer.length : 0);
 		}
-		kfree(obj);
-		return -EINVAL;
+		error = -EINVAL;
+		goto out_free_unlock;
 	}
 	*ret = obj->integer.value;
+ out_free_unlock:
 	kfree(obj);
 	mutex_unlock(&s3_wmi_lock);
-	return 0;
+	return error;
 }
 
 static inline int s3_wmi_query_lid(int *ret)

commit 3dda3b3798f96d2974b5f60811142d3e25547807
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Fri Nov 25 17:11:41 2016 +0100

    platform/x86: Add custom surface3 platform device for controlling LID
    
    The LID state provided by ACPI on the Surface 3 is not accurate.
    The ACPI node doesn't get notified on LID open, which means the
    LID input switch stays close most of the time.
    
    Fortunatelly, there is a WMI method which directly queries the
    GPIO underneath the LID state, so it's far more reliable than ACPI.
    To get the notifications that the LID was opened/closed, we can
    rely on the ACPI notification of the touchscreen: the DSDT shows
    that the touchscreen will get notified on close/open as it also
    controls its _STA method.
    
    Note that we need to set the tag "power-switch" to the LID
    input node through a udev rule for logind to accept it:
    
    SUBSYSTEM=="input", KERNEL=="event*", KERNELS=="surface3-wmi", \
            TAG+="power-switch"
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/surface3-wmi.c b/drivers/platform/x86/surface3-wmi.c
new file mode 100644
index 000000000000..5553b2b85e0a
--- /dev/null
+++ b/drivers/platform/x86/surface3-wmi.c
@@ -0,0 +1,296 @@
+/*
+ *  Driver for the LID cover switch of the Surface 3
+ *
+ *  Copyright (c) 2016 Red Hat Inc.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; version 2 of the License.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+
+#include <linux/acpi.h>
+#include <linux/dmi.h>
+#include <linux/input.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+
+MODULE_AUTHOR("Benjamin Tissoires <benjamin.tissoires@redhat.com>");
+MODULE_DESCRIPTION("Surface 3 platform driver");
+MODULE_LICENSE("GPL");
+
+#define ACPI_BUTTON_HID_LID		"PNP0C0D"
+#define SPI_CTL_OBJ_NAME		"SPI"
+#define SPI_TS_OBJ_NAME			"NTRG"
+
+#define SURFACE3_LID_GUID "F7CC25EC-D20B-404C-8903-0ED4359C18AE"
+
+MODULE_ALIAS("wmi:" SURFACE3_LID_GUID);
+
+static const struct dmi_system_id surface3_dmi_table[] = {
+#if defined(CONFIG_X86)
+	{
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Surface 3"),
+		},
+	},
+#endif
+	{ }
+};
+
+struct surface3_wmi {
+	struct acpi_device *touchscreen_adev;
+	struct acpi_device *pnp0c0d_adev;
+	struct acpi_hotplug_context hp;
+	struct input_dev *input;
+};
+
+static struct platform_device *s3_wmi_pdev;
+
+static struct surface3_wmi s3_wmi;
+
+static DEFINE_MUTEX(s3_wmi_lock);
+
+static int s3_wmi_query_block(const char *guid, int instance, int *ret)
+{
+	acpi_status status;
+	union acpi_object *obj;
+
+	struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
+
+	mutex_lock(&s3_wmi_lock);
+	status = wmi_query_block(guid, instance, &output);
+
+	obj = output.pointer;
+
+	if (!obj || obj->type != ACPI_TYPE_INTEGER) {
+		if (obj) {
+			pr_err("query block returned object type: %d - buffer length:%d\n",
+			       obj->type,
+			       obj->type == ACPI_TYPE_BUFFER ?
+						obj->buffer.length : 0);
+		}
+		kfree(obj);
+		return -EINVAL;
+	}
+	*ret = obj->integer.value;
+	kfree(obj);
+	mutex_unlock(&s3_wmi_lock);
+	return 0;
+}
+
+static inline int s3_wmi_query_lid(int *ret)
+{
+	return s3_wmi_query_block(SURFACE3_LID_GUID, 0, ret);
+}
+
+static int s3_wmi_send_lid_state(void)
+{
+	int ret, lid_sw;
+
+	ret = s3_wmi_query_lid(&lid_sw);
+	if (ret)
+		return ret;
+
+	input_report_switch(s3_wmi.input, SW_LID, lid_sw);
+	input_sync(s3_wmi.input);
+
+	return 0;
+}
+
+static int s3_wmi_hp_notify(struct acpi_device *adev, u32 value)
+{
+	return s3_wmi_send_lid_state();
+}
+
+static acpi_status s3_wmi_attach_spi_device(acpi_handle handle,
+					    u32 level,
+					    void *data,
+					    void **return_value)
+{
+	struct acpi_device *adev, **ts_adev;
+
+	if (acpi_bus_get_device(handle, &adev))
+		return AE_OK;
+
+	ts_adev = data;
+
+	if (strncmp(acpi_device_bid(adev), SPI_TS_OBJ_NAME,
+	    strlen(SPI_TS_OBJ_NAME)))
+		return AE_OK;
+
+	if (*ts_adev) {
+		pr_err("duplicate entry %s\n", SPI_TS_OBJ_NAME);
+		return AE_OK;
+	}
+
+	*ts_adev = adev;
+
+	return AE_OK;
+}
+
+static int s3_wmi_check_platform_device(struct device *dev, void *data)
+{
+	struct acpi_device *adev, *ts_adev;
+	acpi_handle handle;
+	acpi_status status;
+
+	/* ignore non ACPI devices */
+	handle = ACPI_HANDLE(dev);
+	if (!handle || acpi_bus_get_device(handle, &adev))
+		return 0;
+
+	/* check for LID ACPI switch */
+	if (!strcmp(ACPI_BUTTON_HID_LID, acpi_device_hid(adev))) {
+		s3_wmi.pnp0c0d_adev = adev;
+		return 0;
+	}
+
+	/* ignore non SPI controllers */
+	if (strncmp(acpi_device_bid(adev), SPI_CTL_OBJ_NAME,
+	    strlen(SPI_CTL_OBJ_NAME)))
+		return 0;
+
+	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, handle, 1,
+				     s3_wmi_attach_spi_device, NULL,
+				     &ts_adev, NULL);
+	if (ACPI_FAILURE(status))
+		dev_warn(dev, "failed to enumerate SPI slaves\n");
+
+	if (!ts_adev)
+		return 0;
+
+	s3_wmi.touchscreen_adev = ts_adev;
+
+	return 0;
+}
+
+static int s3_wmi_create_and_register_input(struct platform_device *pdev)
+{
+	struct input_dev *input;
+	int error;
+
+	input = devm_input_allocate_device(&pdev->dev);
+	if (!input)
+		return -ENOMEM;
+
+	input->name = "Lid Switch";
+	input->phys = "button/input0";
+	input->id.bustype = BUS_HOST;
+	input->id.product = 0x0005;
+
+	input_set_capability(input, EV_SW, SW_LID);
+
+	error = input_register_device(input);
+	if (error)
+		goto out_err;
+
+	s3_wmi.input = input;
+
+	return 0;
+ out_err:
+	input_free_device(s3_wmi.input);
+	return error;
+}
+
+static int __init s3_wmi_probe(struct platform_device *pdev)
+{
+	int error;
+
+	if (!dmi_check_system(surface3_dmi_table))
+		return -ENODEV;
+
+	memset(&s3_wmi, 0, sizeof(s3_wmi));
+
+	bus_for_each_dev(&platform_bus_type, NULL, NULL,
+			 s3_wmi_check_platform_device);
+
+	if (!s3_wmi.touchscreen_adev)
+		return -ENODEV;
+
+	acpi_bus_trim(s3_wmi.pnp0c0d_adev);
+
+	error = s3_wmi_create_and_register_input(pdev);
+	if (error)
+		goto restore_acpi_lid;
+
+	acpi_initialize_hp_context(s3_wmi.touchscreen_adev, &s3_wmi.hp,
+				   s3_wmi_hp_notify, NULL);
+
+	s3_wmi_send_lid_state();
+
+	return 0;
+
+ restore_acpi_lid:
+	acpi_bus_scan(s3_wmi.pnp0c0d_adev->handle);
+	return error;
+}
+
+static int s3_wmi_remove(struct platform_device *device)
+{
+	/* remove the hotplug context from the acpi device */
+	s3_wmi.touchscreen_adev->hp = NULL;
+
+	/* reinstall the actual PNPC0C0D LID default handle */
+	acpi_bus_scan(s3_wmi.pnp0c0d_adev->handle);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int s3_wmi_resume(struct device *dev)
+{
+	s3_wmi_send_lid_state();
+	return 0;
+}
+#endif
+static SIMPLE_DEV_PM_OPS(s3_wmi_pm, NULL, s3_wmi_resume);
+
+static struct platform_driver s3_wmi_driver = {
+	.driver = {
+		.name = "surface3-wmi",
+		.pm = &s3_wmi_pm,
+	},
+	.remove = s3_wmi_remove,
+};
+
+static int __init s3_wmi_init(void)
+{
+	int error;
+
+	s3_wmi_pdev = platform_device_alloc("surface3-wmi", -1);
+	if (!s3_wmi_pdev)
+		return -ENOMEM;
+
+	error = platform_device_add(s3_wmi_pdev);
+	if (error)
+		goto err_device_put;
+
+	error = platform_driver_probe(&s3_wmi_driver, s3_wmi_probe);
+	if (error)
+		goto err_device_del;
+
+	pr_info("Surface 3 WMI Extras loaded\n");
+	return 0;
+
+ err_device_del:
+	platform_device_del(s3_wmi_pdev);
+ err_device_put:
+	platform_device_put(s3_wmi_pdev);
+	return error;
+}
+
+static void __exit s3_wmi_exit(void)
+{
+	platform_device_unregister(s3_wmi_pdev);
+	platform_driver_unregister(&s3_wmi_driver);
+}
+
+module_init(s3_wmi_init);
+module_exit(s3_wmi_exit);
