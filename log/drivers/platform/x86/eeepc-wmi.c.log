commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 17b365f26f9d..ce86d84ee796 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Eee PC WMI hotkey driver
  *
@@ -8,20 +9,6 @@
  * Copyright (C) 2005 Miloslav Trmac <mitr@volny.cz>
  * Copyright (C) 2005 Bernhard Rosenkraenzer <bero@arklinux.org>
  * Copyright (C) 2005 Dmitry Torokhov <dtor@mail.ru>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt

commit 9f9de69d754cc9f8f2d8c21bb92275d95ddb3c77
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Mar 24 13:15:20 2016 +0100

    eeepc-wmi: Use acpi_dev_found()
    
    Use shiny new acpi_dev_found() and remove all the boilerplate
    to search for a particular ACPI device. No functional change.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Acked-by: Darren Hart <dvhart@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 14fd2ecb06a1..17b365f26f9d 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -204,30 +204,10 @@ static void eeepc_wmi_key_filter(struct asus_wmi_driver *asus_wmi, int *code,
 	}
 }
 
-static acpi_status eeepc_wmi_parse_device(acpi_handle handle, u32 level,
-						 void *context, void **retval)
-{
-	pr_warn("Found legacy ATKD device (%s)\n", EEEPC_ACPI_HID);
-	*(bool *)context = true;
-	return AE_CTRL_TERMINATE;
-}
-
-static int eeepc_wmi_check_atkd(void)
-{
-	acpi_status status;
-	bool found = false;
-
-	status = acpi_get_devices(EEEPC_ACPI_HID, eeepc_wmi_parse_device,
-				  &found, NULL);
-
-	if (ACPI_FAILURE(status) || !found)
-		return 0;
-	return -1;
-}
-
 static int eeepc_wmi_probe(struct platform_device *pdev)
 {
-	if (eeepc_wmi_check_atkd()) {
+	if (acpi_dev_found(EEEPC_ACPI_HID)) {
+		pr_warn("Found legacy ATKD device (%s)\n", EEEPC_ACPI_HID);
 		pr_warn("WMI device present, but legacy ATKD device is also "
 			"present and enabled\n");
 		pr_warn("You probably booted with acpi_osi=\"Linux\" or "

commit 7e6c227cebeee59ffe37bccde698ad45f6210ef0
Author: Mathias Krause <minipli@googlemail.com>
Date:   Wed Jul 16 19:43:10 2014 +0200

    eeepc-wmi: Constify asus_quirks[] DMI table
    
    Constify the asus_quirks[] DMI table. There's no need to have it
    writeable during runtime.
    
    Signed-off-by: Mathias Krause <minipli@googlemail.com>
    Cc: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 6112933f6278..14fd2ecb06a1 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -145,7 +145,7 @@ static int dmi_matched(const struct dmi_system_id *dmi)
 	return 1;
 }
 
-static struct dmi_system_id asus_quirks[] = {
+static const struct dmi_system_id asus_quirks[] = {
 	{
 		.callback = dmi_matched,
 		.ident = "ASUSTeK Computer INC. 1000H",

commit 8b48463f89429af408ff695244dc627e1acff4f7
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Dec 3 08:49:16 2013 +0800

    ACPI: Clean up inclusions of ACPI header files
    
    Replace direct inclusions of <acpi/acpi.h>, <acpi/acpi_bus.h> and
    <acpi/acpi_drivers.h>, which are incorrect, with <linux/acpi.h>
    inclusions and remove some inclusions of those files that aren't
    necessary.
    
    First of all, <acpi/acpi.h>, <acpi/acpi_bus.h> and <acpi/acpi_drivers.h>
    should not be included directly from any files that are built for
    CONFIG_ACPI unset, because that generally leads to build warnings about
    undefined symbols in !CONFIG_ACPI builds.  For CONFIG_ACPI set,
    <linux/acpi.h> includes those files and for CONFIG_ACPI unset it
    provides stub ACPI symbols to be used in that case.
    
    Second, there are ordering dependencies between those files that always
    have to be met.  Namely, it is required that <acpi/acpi_bus.h> be included
    prior to <acpi/acpi_drivers.h> so that the acpi_pci_root declarations the
    latter depends on are always there.  And <acpi/acpi.h> which provides
    basic ACPICA type declarations should always be included prior to any other
    ACPI headers in CONFIG_ACPI builds.  That also is taken care of including
    <linux/acpi.h> as appropriate.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> (drivers/pci stuff)
    Acked-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com> (Xen stuff)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index af67e6e56ebb..6112933f6278 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -33,7 +33,7 @@
 #include <linux/input/sparse-keymap.h>
 #include <linux/dmi.h>
 #include <linux/fb.h>
-#include <acpi/acpi_bus.h>
+#include <linux/acpi.h>
 
 #include "asus-wmi.h"
 

commit 3ba0302bdd57d225b52c4b4b36975196c1572b3f
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Thu Nov 29 09:12:38 2012 +0100

    asus-wmi: always report brightness key events
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 60cb76a5b513..af67e6e56ebb 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -63,6 +63,8 @@ MODULE_PARM_DESC(hotplug_wireless,
 #define HOME_RELEASE	0xe5
 
 static const struct key_entry eeepc_wmi_keymap[] = {
+	{ KE_KEY, ASUS_WMI_BRN_DOWN, { KEY_BRIGHTNESSDOWN } },
+	{ KE_KEY, ASUS_WMI_BRN_UP, { KEY_BRIGHTNESSUP } },
 	/* Sleep already handled via generic ACPI code */
 	{ KE_KEY, 0x30, { KEY_VOLUMEUP } },
 	{ KE_KEY, 0x31, { KEY_VOLUMEDOWN } },

commit 5909c654a6f20dd61cc5ac952f8eaa3a29e59078
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Mon Dec 17 16:00:05 2012 -0800

    Corentin has moved
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 5838332ea5bd..60cb76a5b513 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -39,7 +39,7 @@
 
 #define	EEEPC_WMI_FILE	"eeepc-wmi"
 
-MODULE_AUTHOR("Corentin Chary <corentincj@iksaif.net>");
+MODULE_AUTHOR("Corentin Chary <corentin.chary@gmail.com>");
 MODULE_DESCRIPTION("Eee PC WMI Hotkey Driver");
 MODULE_LICENSE("GPL");
 

commit 272c77d55672ef92eda9d5e24a5a7ac62df9c431
Author: AceLan Kao <acelan.kao@canonical.com>
Date:   Wed Jun 13 09:32:06 2012 +0200

    asus-wmi: control backlight power through WMI, not ACPI
    
    BugLink: https://bugs.launchpad.net/bugs/1000146
    
    Some h/w that can adjust screen brightness through ACPI functions, but
    can't turn on/off the backlight power correctly. So, we list those h/w in
    quirks and try to turn on/off the backlight power through WMI.
    Signed-off-by: AceLan Kao <acelan.kao@canonical.com>
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 656761380342..5838332ea5bd 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -79,7 +79,7 @@ static const struct key_entry eeepc_wmi_keymap[] = {
 	{ KE_KEY, 0xe1, { KEY_F14 } }, /* Change Resolution */
 	{ KE_KEY, HOME_PRESS, { KEY_CONFIG } }, /* Home/Express gate key */
 	{ KE_KEY, 0xe8, { KEY_SCREENLOCK } },
-	{ KE_KEY, 0xe9, { KEY_BRIGHTNESS_ZERO } },
+	{ KE_KEY, 0xe9, { KEY_DISPLAYTOGGLE } },
 	{ KE_KEY, 0xeb, { KEY_CAMERA_ZOOMOUT } },
 	{ KE_KEY, 0xec, { KEY_CAMERA_UP } },
 	{ KE_KEY, 0xed, { KEY_CAMERA_DOWN } },
@@ -107,6 +107,11 @@ static struct quirk_entry quirk_asus_et2012_type3 = {
 	.store_backlight_power = true,
 };
 
+static struct quirk_entry quirk_asus_x101ch = {
+	/* We need this when ACPI function doesn't do this well */
+	.wmi_backlight_power = true,
+};
+
 static struct quirk_entry *quirks;
 
 static void et2012_quirks(void)
@@ -157,6 +162,24 @@ static struct dmi_system_id asus_quirks[] = {
 		},
 		.driver_data = &quirk_asus_unknown,
 	},
+	{
+		.callback = dmi_matched,
+		.ident = "ASUSTeK Computer INC. X101CH",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "X101CH"),
+		},
+		.driver_data = &quirk_asus_x101ch,
+	},
+	{
+		.callback = dmi_matched,
+		.ident = "ASUSTeK Computer INC. 1015CX",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "1015CX"),
+		},
+		.driver_data = &quirk_asus_x101ch,
+	},
 	{},
 };
 

commit 7a61d0207465e41b7dbe3a25f628ddef24572c6f
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Tue Mar 20 09:53:13 2012 +0100

    eeepc-wmi: split et2012 specific hacks
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 0bb0aaf43aba..656761380342 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -109,26 +109,32 @@ static struct quirk_entry quirk_asus_et2012_type3 = {
 
 static struct quirk_entry *quirks;
 
+static void et2012_quirks(void)
+{
+	const struct dmi_device *dev = NULL;
+	char oemstring[30];
+
+	while ((dev = dmi_find_device(DMI_DEV_TYPE_OEM_STRING, NULL, dev))) {
+		if (sscanf(dev->name, "AEMS%24c", oemstring) == 1) {
+			if (oemstring[18] == '1')
+				quirks = &quirk_asus_et2012_type1;
+			else if (oemstring[18] == '3')
+				quirks = &quirk_asus_et2012_type3;
+			break;
+		}
+	}
+}
+
 static int dmi_matched(const struct dmi_system_id *dmi)
 {
 	char *model;
+
 	quirks = dmi->driver_data;
 
 	model = (char *)dmi->matches[1].substr;
-	if (unlikely(strncmp(model, "ET2012", 6) == 0)) {
-		const struct dmi_device *dev = NULL;
-		char oemstring[30];
-		while ((dev = dmi_find_device(DMI_DEV_TYPE_OEM_STRING,
-					      NULL, dev))) {
-			if (sscanf(dev->name, "AEMS%24c", oemstring) == 1) {
-				if (oemstring[18] == '1')
-					quirks = &quirk_asus_et2012_type1;
-				else if (oemstring[18] == '3')
-					quirks = &quirk_asus_et2012_type3;
-				break;
-			}
-		}
-	}
+	if (unlikely(strncmp(model, "ET2012", 6) == 0))
+		et2012_quirks();
+
 	return 1;
 }
 

commit c55d995dd3cebffdeb2b7eff8acc813c56d62c97
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Tue Mar 20 09:53:12 2012 +0100

    eeepc-wmi: refine quirks handling
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 389ff888cb6c..0bb0aaf43aba 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -49,7 +49,6 @@ MODULE_LICENSE("GPL");
 
 MODULE_ALIAS("wmi:"EEEPC_WMI_EVENT_GUID);
 
-static struct quirk_entry *quirks;
 static bool hotplug_wireless;
 
 module_param(hotplug_wireless, bool, 0444);
@@ -108,6 +107,8 @@ static struct quirk_entry quirk_asus_et2012_type3 = {
 	.store_backlight_power = true,
 };
 
+static struct quirk_entry *quirks;
+
 static int dmi_matched(const struct dmi_system_id *dmi)
 {
 	char *model;
@@ -209,12 +210,14 @@ static int eeepc_wmi_probe(struct platform_device *pdev)
 
 static void eeepc_wmi_quirks(struct asus_wmi_driver *driver)
 {
-	driver->panel_power = FB_BLANK_UNBLANK;
-	driver->quirks = &quirk_asus_unknown;
-	driver->quirks->hotplug_wireless = hotplug_wireless;
-	driver->quirks->wapf = -1;
+	quirks = &quirk_asus_unknown;
+	quirks->hotplug_wireless = hotplug_wireless;
+
 	dmi_check_system(asus_quirks);
+
 	driver->quirks = quirks;
+	driver->quirks->wapf = -1;
+	driver->panel_power = FB_BLANK_UNBLANK;
 }
 
 static struct asus_wmi_driver asus_wmi_driver = {

commit 6a2bcccdb3206950d28e343476d9050e23e79b7e
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Tue Mar 20 09:53:10 2012 +0100

    asus-wmi: move WAPF variable into quirks_entry
    
    Some models work better with different values of wapf, so move the
    variable into quriks_entry to make it more easy to give a specific
    value to different models.
    
    Based on original patch from AceLan Kao <acelan.kao@canonical.com>
    
    Cc: AceLan Kao <acelan.kao@canonical.com>
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 9f8ccf9f590d..389ff888cb6c 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -209,10 +209,10 @@ static int eeepc_wmi_probe(struct platform_device *pdev)
 
 static void eeepc_wmi_quirks(struct asus_wmi_driver *driver)
 {
-	driver->wapf = -1;
 	driver->panel_power = FB_BLANK_UNBLANK;
 	driver->quirks = &quirk_asus_unknown;
 	driver->quirks->hotplug_wireless = hotplug_wireless;
+	driver->quirks->wapf = -1;
 	dmi_check_system(asus_quirks);
 	driver->quirks = quirks;
 }

commit 6e0044bedc1fc94a61cc32fa25dcab9a4e4a9218
Author: AceLan Kao <acelan.kao@canonical.com>
Date:   Tue Mar 20 09:53:09 2012 +0100

    asus-wmi: store backlight power status for AIO machine
    
    Due to some implementation reasons, ASUS ET2012 All-in-One machines
    can't report the correct backlight power status, it will always return
    1. To track the backlight power status correctly, we have to store the
    status by ourselves.
    
    BTW, by the BIOS design, the backlight power will be turn on/off
    sequently, no matter what the value of the parameter will be.
    More over, the brightness adjustment command will turn on the backlight
    power. Those behaviors will make us fail to track the backlight power
    status.
    For example, While we are trying to turn on the backlight power,
    we will send out the brightness adjustment command and then trying to
    figure out if we have to turn on the backlight power, then send out
    the command. But, the real case is that, the backlight power turns on
    while sending the brightness adjustment command, and then we send out
    the command to turn on the backlight power, it actually will turn off
    the backlight power and the backlight power status we recorded becomes
    wrong. So, we have to seperate these two commands by a if statement.
    
    Signed-off-by: AceLan Kao <acelan.kao@canonical.com>
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 67186e6ca28d..9f8ccf9f590d 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -32,6 +32,7 @@
 #include <linux/input.h>
 #include <linux/input/sparse-keymap.h>
 #include <linux/dmi.h>
+#include <linux/fb.h>
 #include <acpi/acpi_bus.h>
 
 #include "asus-wmi.h"
@@ -98,8 +99,13 @@ static struct quirk_entry quirk_asus_1000h = {
 	.hotplug_wireless = true,
 };
 
+static struct quirk_entry quirk_asus_et2012_type1 = {
+	.store_backlight_power = true,
+};
+
 static struct quirk_entry quirk_asus_et2012_type3 = {
 	.scalar_panel_brightness = true,
+	.store_backlight_power = true,
 };
 
 static int dmi_matched(const struct dmi_system_id *dmi)
@@ -111,10 +117,12 @@ static int dmi_matched(const struct dmi_system_id *dmi)
 	if (unlikely(strncmp(model, "ET2012", 6) == 0)) {
 		const struct dmi_device *dev = NULL;
 		char oemstring[30];
-		while ((dev = dmi_find_device(DMI_DEV_TYPE_OEM_STRING, NULL,
-					      dev))) {
+		while ((dev = dmi_find_device(DMI_DEV_TYPE_OEM_STRING,
+					      NULL, dev))) {
 			if (sscanf(dev->name, "AEMS%24c", oemstring) == 1) {
-				if (oemstring[18] == '3')
+				if (oemstring[18] == '1')
+					quirks = &quirk_asus_et2012_type1;
+				else if (oemstring[18] == '3')
 					quirks = &quirk_asus_et2012_type3;
 				break;
 			}
@@ -202,6 +210,7 @@ static int eeepc_wmi_probe(struct platform_device *pdev)
 static void eeepc_wmi_quirks(struct asus_wmi_driver *driver)
 {
 	driver->wapf = -1;
+	driver->panel_power = FB_BLANK_UNBLANK;
 	driver->quirks = &quirk_asus_unknown;
 	driver->quirks->hotplug_wireless = hotplug_wireless;
 	dmi_check_system(asus_quirks);

commit c87992d1fa51a6a3d8f0e980ca4d2bdec7e78a17
Author: AceLan Kao <acelan.kao@canonical.com>
Date:   Tue Mar 20 09:53:08 2012 +0100

    asus-wmi: add scalar board brightness adj. support
    
    Some ASUS ET2012E/I All-in-One machines that use a scalar board
    to control the brightness, and they only accept brightness up and down
    command. So, I introduced a get_scalar_command() function to pass the
    command to the scalar board through WMI.
    
    Besides, we have to store the brightness value locally, for we need the
    old value to know the brightness value is increasing or decreasing.
    
    BTW, since there is no way to retrieve the actual brightness(it would be
    a fixed value), and the max brightness value would be fixed to 1, so we
    have to keep passing the brightness up/down command when we reached the
    max brightness value or 0.
    
    Signed-off-by: AceLan Kao <acelan.kao@canonical.com>
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 1d91eb2ace0a..67186e6ca28d 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -48,6 +48,7 @@ MODULE_LICENSE("GPL");
 
 MODULE_ALIAS("wmi:"EEEPC_WMI_EVENT_GUID);
 
+static struct quirk_entry *quirks;
 static bool hotplug_wireless;
 
 module_param(hotplug_wireless, bool, 0444);
@@ -90,6 +91,60 @@ static const struct key_entry eeepc_wmi_keymap[] = {
 	{ KE_END, 0},
 };
 
+static struct quirk_entry quirk_asus_unknown = {
+};
+
+static struct quirk_entry quirk_asus_1000h = {
+	.hotplug_wireless = true,
+};
+
+static struct quirk_entry quirk_asus_et2012_type3 = {
+	.scalar_panel_brightness = true,
+};
+
+static int dmi_matched(const struct dmi_system_id *dmi)
+{
+	char *model;
+	quirks = dmi->driver_data;
+
+	model = (char *)dmi->matches[1].substr;
+	if (unlikely(strncmp(model, "ET2012", 6) == 0)) {
+		const struct dmi_device *dev = NULL;
+		char oemstring[30];
+		while ((dev = dmi_find_device(DMI_DEV_TYPE_OEM_STRING, NULL,
+					      dev))) {
+			if (sscanf(dev->name, "AEMS%24c", oemstring) == 1) {
+				if (oemstring[18] == '3')
+					quirks = &quirk_asus_et2012_type3;
+				break;
+			}
+		}
+	}
+	return 1;
+}
+
+static struct dmi_system_id asus_quirks[] = {
+	{
+		.callback = dmi_matched,
+		.ident = "ASUSTeK Computer INC. 1000H",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK Computer INC."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "1000H"),
+		},
+		.driver_data = &quirk_asus_1000h,
+	},
+	{
+		.callback = dmi_matched,
+		.ident = "ASUSTeK Computer INC. ET2012E/I",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK Computer INC."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "ET2012"),
+		},
+		.driver_data = &quirk_asus_unknown,
+	},
+	{},
+};
+
 static void eeepc_wmi_key_filter(struct asus_wmi_driver *asus_wmi, int *code,
 				 unsigned int *value, bool *autorelease)
 {
@@ -144,33 +199,13 @@ static int eeepc_wmi_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static void eeepc_dmi_check(struct asus_wmi_driver *driver)
-{
-	const char *model;
-
-	model = dmi_get_system_info(DMI_PRODUCT_NAME);
-	if (!model)
-		return;
-
-	/*
-	 * Whitelist for wlan hotplug
-	 *
-	 * Asus 1000H needs the current hotplug code to handle
-	 * Fn+F2 correctly. We may add other Asus here later, but
-	 * it seems that most of the laptops supported by asus-wmi
-	 * don't need to be on this list
-	 */
-	if (strcmp(model, "1000H") == 0) {
-		driver->hotplug_wireless = true;
-		pr_info("wlan hotplug enabled\n");
-	}
-}
-
 static void eeepc_wmi_quirks(struct asus_wmi_driver *driver)
 {
-	driver->hotplug_wireless = hotplug_wireless;
 	driver->wapf = -1;
-	eeepc_dmi_check(driver);
+	driver->quirks = &quirk_asus_unknown;
+	driver->quirks->hotplug_wireless = hotplug_wireless;
+	dmi_check_system(asus_quirks);
+	driver->quirks = quirks;
 }
 
 static struct asus_wmi_driver asus_wmi_driver = {
@@ -182,7 +217,7 @@ static struct asus_wmi_driver asus_wmi_driver = {
 	.input_phys = EEEPC_WMI_FILE "/input0",
 	.key_filter = eeepc_wmi_key_filter,
 	.probe = eeepc_wmi_probe,
-	.quirks = eeepc_wmi_quirks,
+	.detect_quirks = eeepc_wmi_quirks,
 };
 
 

commit eb649a818abab4b0a8bb8b00d174ad9acf0a8a5a
Author: Chih-Wei Huang <cwhuang@linux.org.tw>
Date:   Tue Mar 20 09:53:03 2012 +0100

    eeepc-wmi: add extra keymaps for EP121
    
    Signed-off-by: Chih-Wei Huang <cwhuang@linux.org.tw>
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 9f6e64302b45..1d91eb2ace0a 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -84,6 +84,9 @@ static const struct key_entry eeepc_wmi_keymap[] = {
 	{ KE_KEY, 0xed, { KEY_CAMERA_DOWN } },
 	{ KE_KEY, 0xee, { KEY_CAMERA_LEFT } },
 	{ KE_KEY, 0xef, { KEY_CAMERA_RIGHT } },
+	{ KE_KEY, 0xf3, { KEY_MENU } },
+	{ KE_KEY, 0xf5, { KEY_HOMEPAGE } },
+	{ KE_KEY, 0xf6, { KEY_ESC } },
 	{ KE_END, 0},
 };
 

commit fddbfed595b307f9dddc7a86ddfbcbcb80141e28
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Fri Jul 1 11:34:39 2011 +0200

    asus-wmi: add CWAP support and clarify the meaning of WAPF bits
    
    ref: http://dev.iksaif.net/projects/3/wiki/Asus-laptop_WAPF
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index f41a977efa94..9f6e64302b45 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -166,6 +166,7 @@ static void eeepc_dmi_check(struct asus_wmi_driver *driver)
 static void eeepc_wmi_quirks(struct asus_wmi_driver *driver)
 {
 	driver->hotplug_wireless = hotplug_wireless;
+	driver->wapf = -1;
 	eeepc_dmi_check(driver);
 }
 

commit 6ae8b807371ba8d5b42648721c528582295136f7
Author: Seth Forshee <seth.forshee@canonical.com>
Date:   Fri Jul 1 11:34:28 2011 +0200

    eeepc-wmi: Add support for T101MT Home/Express Gate key
    
    This key is different than other hotkeys, having seperate scan
    codes for press, release, and hold, so it requires some special
    filtering. Press and release events are passed on, and hold events
    are ignored since sparse-keymap does not support hardware
    autorepeat.
    
    Note that "Home" in the context of this button doesn't mean the
    same thing as the usual Home key, and it really isn't clear at
    all what is meant by "Home". The manufacurer's description of the
    button indicates that it should launch some sort of touch screen
    settings interface on short press and apply a desktop rotation on
    long press.
    
    Signed-off-by: Seth Forshee <seth.forshee@canonical.com>
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 4aa867a9b88b..f41a977efa94 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -56,6 +56,11 @@ MODULE_PARM_DESC(hotplug_wireless,
 		 "If your laptop needs that, please report to "
 		 "acpi4asus-user@lists.sourceforge.net.");
 
+/* Values for T101MT "Home" key */
+#define HOME_PRESS	0xe4
+#define HOME_HOLD	0xea
+#define HOME_RELEASE	0xe5
+
 static const struct key_entry eeepc_wmi_keymap[] = {
 	/* Sleep already handled via generic ACPI code */
 	{ KE_KEY, 0x30, { KEY_VOLUMEUP } },
@@ -71,6 +76,7 @@ static const struct key_entry eeepc_wmi_keymap[] = {
 	{ KE_KEY, 0xcc, { KEY_SWITCHVIDEOMODE } },
 	{ KE_KEY, 0xe0, { KEY_PROG1 } }, /* Task Manager */
 	{ KE_KEY, 0xe1, { KEY_F14 } }, /* Change Resolution */
+	{ KE_KEY, HOME_PRESS, { KEY_CONFIG } }, /* Home/Express gate key */
 	{ KE_KEY, 0xe8, { KEY_SCREENLOCK } },
 	{ KE_KEY, 0xe9, { KEY_BRIGHTNESS_ZERO } },
 	{ KE_KEY, 0xeb, { KEY_CAMERA_ZOOMOUT } },
@@ -81,6 +87,25 @@ static const struct key_entry eeepc_wmi_keymap[] = {
 	{ KE_END, 0},
 };
 
+static void eeepc_wmi_key_filter(struct asus_wmi_driver *asus_wmi, int *code,
+				 unsigned int *value, bool *autorelease)
+{
+	switch (*code) {
+	case HOME_PRESS:
+		*value = 1;
+		*autorelease = 0;
+		break;
+	case HOME_HOLD:
+		*code = ASUS_WMI_KEY_IGNORE;
+		break;
+	case HOME_RELEASE:
+		*code = HOME_PRESS;
+		*value = 0;
+		*autorelease = 0;
+		break;
+	}
+}
+
 static acpi_status eeepc_wmi_parse_device(acpi_handle handle, u32 level,
 						 void *context, void **retval)
 {
@@ -151,6 +176,7 @@ static struct asus_wmi_driver asus_wmi_driver = {
 	.keymap = eeepc_wmi_keymap,
 	.input_name = "Eee PC WMI hotkeys",
 	.input_phys = EEEPC_WMI_FILE "/input0",
+	.key_filter = eeepc_wmi_key_filter,
 	.probe = eeepc_wmi_probe,
 	.quirks = eeepc_wmi_quirks,
 };

commit 22441ffeed17b94b28bd7c609f2cdb24d11e81f3
Author: Joe Perches <joe@perches.com>
Date:   Tue Mar 29 15:21:38 2011 -0700

    eeepc: Use pr_warn
    
    Just a trivial pr_warning to pr_warn conversion
    while adding a few missing newlines.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 649dcadd8ea3..4aa867a9b88b 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -84,7 +84,7 @@ static const struct key_entry eeepc_wmi_keymap[] = {
 static acpi_status eeepc_wmi_parse_device(acpi_handle handle, u32 level,
 						 void *context, void **retval)
 {
-	pr_warning("Found legacy ATKD device (%s)", EEEPC_ACPI_HID);
+	pr_warn("Found legacy ATKD device (%s)\n", EEEPC_ACPI_HID);
 	*(bool *)context = true;
 	return AE_CTRL_TERMINATE;
 }
@@ -105,12 +105,12 @@ static int eeepc_wmi_check_atkd(void)
 static int eeepc_wmi_probe(struct platform_device *pdev)
 {
 	if (eeepc_wmi_check_atkd()) {
-		pr_warning("WMI device present, but legacy ATKD device is also "
-			   "present and enabled.");
-		pr_warning("You probably booted with acpi_osi=\"Linux\" or "
-			   "acpi_osi=\"!Windows 2009\"");
-		pr_warning("Can't load eeepc-wmi, use default acpi_osi "
-			   "(preferred) or eeepc-laptop");
+		pr_warn("WMI device present, but legacy ATKD device is also "
+			"present and enabled\n");
+		pr_warn("You probably booted with acpi_osi=\"Linux\" or "
+			"acpi_osi=\"!Windows 2009\"\n");
+		pr_warn("Can't load eeepc-wmi, use default acpi_osi "
+			"(preferred) or eeepc-laptop\n");
 		return -EBUSY;
 	}
 	return 0;

commit 9481472559b3ecd366390786628c2fb211d1477b
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Wed Mar 30 16:32:33 2011 +0200

    eeepc-wmi: add keys found on EeePC 1215T
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 0ddc434fb93b..649dcadd8ea3 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -67,9 +67,11 @@ static const struct key_entry eeepc_wmi_keymap[] = {
 	{ KE_KEY, 0x82, { KEY_CAMERA } },
 	{ KE_KEY, 0x83, { KEY_CAMERA_ZOOMIN } },
 	{ KE_KEY, 0x88, { KEY_WLAN } },
+	{ KE_KEY, 0xbd, { KEY_CAMERA } },
 	{ KE_KEY, 0xcc, { KEY_SWITCHVIDEOMODE } },
 	{ KE_KEY, 0xe0, { KEY_PROG1 } }, /* Task Manager */
 	{ KE_KEY, 0xe1, { KEY_F14 } }, /* Change Resolution */
+	{ KE_KEY, 0xe8, { KEY_SCREENLOCK } },
 	{ KE_KEY, 0xe9, { KEY_BRIGHTNESS_ZERO } },
 	{ KE_KEY, 0xeb, { KEY_CAMERA_ZOOMOUT } },
 	{ KE_KEY, 0xec, { KEY_CAMERA_UP } },

commit 3b3e73f7d879f914f25605f74a71c2dad34bc329
Author: Keng-Yu Lin <keng-yu.lin@canonical.com>
Date:   Tue Mar 1 12:56:13 2011 +0800

    eeepc-wmi: set the touchpad toggle key code to KEY_TOUCHPAD_TOGGLE
    
    Signed-off-by: Keng-Yu Lin <keng-yu.lin@canonical.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 64e36de2285c..0ddc434fb93b 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -63,7 +63,7 @@ static const struct key_entry eeepc_wmi_keymap[] = {
 	{ KE_KEY, 0x32, { KEY_MUTE } },
 	{ KE_KEY, 0x5c, { KEY_F15 } }, /* Power Gear key */
 	{ KE_KEY, 0x5d, { KEY_WLAN } },
-	{ KE_KEY, 0x6b, { KEY_F13 } }, /* Disable Touchpad */
+	{ KE_KEY, 0x6b, { KEY_TOUCHPAD_TOGGLE } }, /* Toggle Touchpad */
 	{ KE_KEY, 0x82, { KEY_CAMERA } },
 	{ KE_KEY, 0x83, { KEY_CAMERA_ZOOMIN } },
 	{ KE_KEY, 0x88, { KEY_WLAN } },

commit 5f8540094d23b8886d671ff1faf875b698e2f299
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sat Feb 26 10:20:43 2011 +0100

    eeepc-wmi: restore KEY_CAMERA_* keys lost in 190ca27
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index e69701fc422b..64e36de2285c 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -65,11 +65,17 @@ static const struct key_entry eeepc_wmi_keymap[] = {
 	{ KE_KEY, 0x5d, { KEY_WLAN } },
 	{ KE_KEY, 0x6b, { KEY_F13 } }, /* Disable Touchpad */
 	{ KE_KEY, 0x82, { KEY_CAMERA } },
+	{ KE_KEY, 0x83, { KEY_CAMERA_ZOOMIN } },
 	{ KE_KEY, 0x88, { KEY_WLAN } },
 	{ KE_KEY, 0xcc, { KEY_SWITCHVIDEOMODE } },
 	{ KE_KEY, 0xe0, { KEY_PROG1 } }, /* Task Manager */
 	{ KE_KEY, 0xe1, { KEY_F14 } }, /* Change Resolution */
 	{ KE_KEY, 0xe9, { KEY_BRIGHTNESS_ZERO } },
+	{ KE_KEY, 0xeb, { KEY_CAMERA_ZOOMOUT } },
+	{ KE_KEY, 0xec, { KEY_CAMERA_UP } },
+	{ KE_KEY, 0xed, { KEY_CAMERA_DOWN } },
+	{ KE_KEY, 0xee, { KEY_CAMERA_LEFT } },
+	{ KE_KEY, 0xef, { KEY_CAMERA_RIGHT } },
 	{ KE_END, 0},
 };
 

commit 57ab7dae27fae6a492ec968dc543106685adcad5
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sat Feb 26 10:20:32 2011 +0100

    asus-wmi: minor cleanups
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 3a060aefc5f3..e69701fc422b 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -2,7 +2,7 @@
  * Eee PC WMI hotkey driver
  *
  * Copyright(C) 2010 Intel Corporation.
- * Copyright(C) 2010 Corentin Chary <corentin.chary@gmail.com>
+ * Copyright(C) 2010-2011 Corentin Chary <corentin.chary@gmail.com>
  *
  * Portions based on wistron_btns.c:
  * Copyright (C) 2005 Miloslav Trmac <mitr@volny.cz>

commit e12e6d94db24e9050821965aa75c95e8d2c65f10
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sat Feb 26 10:20:31 2011 +0100

    eeepc-wmi: asus generic asus-wmi.ko module
    
    New Asus notebooks are using a WMI device similar to
    the one used in Eee PCs. Since we don't want to load
    eeepc-wmi module on Asus notebooks, and we want to
    keep the eeepc-wmi module for backward compatibility,
    this patch introduce a new module, named asus-wmi, that
    will be used by eeepc-wmi and the new Asus Notebook WMI
    Driver.
    
    eeepc-wmi's input device strings (device name and phys)
    are kept, but rfkill and led names are changed (s/eeepc/asus/).
    This should not break anything since rfkill are used by type or
    index, not by name, and the eeepc::touchpad led wasn't working
    correctly before 2.6.39 anyway.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
new file mode 100644
index 000000000000..3a060aefc5f3
--- /dev/null
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -0,0 +1,162 @@
+/*
+ * Eee PC WMI hotkey driver
+ *
+ * Copyright(C) 2010 Intel Corporation.
+ * Copyright(C) 2010 Corentin Chary <corentin.chary@gmail.com>
+ *
+ * Portions based on wistron_btns.c:
+ * Copyright (C) 2005 Miloslav Trmac <mitr@volny.cz>
+ * Copyright (C) 2005 Bernhard Rosenkraenzer <bero@arklinux.org>
+ * Copyright (C) 2005 Dmitry Torokhov <dtor@mail.ru>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/input/sparse-keymap.h>
+#include <linux/dmi.h>
+#include <acpi/acpi_bus.h>
+
+#include "asus-wmi.h"
+
+#define	EEEPC_WMI_FILE	"eeepc-wmi"
+
+MODULE_AUTHOR("Corentin Chary <corentincj@iksaif.net>");
+MODULE_DESCRIPTION("Eee PC WMI Hotkey Driver");
+MODULE_LICENSE("GPL");
+
+#define EEEPC_ACPI_HID		"ASUS010" /* old _HID used in eeepc-laptop */
+
+#define EEEPC_WMI_EVENT_GUID	"ABBC0F72-8EA1-11D1-00A0-C90629100000"
+
+MODULE_ALIAS("wmi:"EEEPC_WMI_EVENT_GUID);
+
+static bool hotplug_wireless;
+
+module_param(hotplug_wireless, bool, 0444);
+MODULE_PARM_DESC(hotplug_wireless,
+		 "Enable hotplug for wireless device. "
+		 "If your laptop needs that, please report to "
+		 "acpi4asus-user@lists.sourceforge.net.");
+
+static const struct key_entry eeepc_wmi_keymap[] = {
+	/* Sleep already handled via generic ACPI code */
+	{ KE_KEY, 0x30, { KEY_VOLUMEUP } },
+	{ KE_KEY, 0x31, { KEY_VOLUMEDOWN } },
+	{ KE_KEY, 0x32, { KEY_MUTE } },
+	{ KE_KEY, 0x5c, { KEY_F15 } }, /* Power Gear key */
+	{ KE_KEY, 0x5d, { KEY_WLAN } },
+	{ KE_KEY, 0x6b, { KEY_F13 } }, /* Disable Touchpad */
+	{ KE_KEY, 0x82, { KEY_CAMERA } },
+	{ KE_KEY, 0x88, { KEY_WLAN } },
+	{ KE_KEY, 0xcc, { KEY_SWITCHVIDEOMODE } },
+	{ KE_KEY, 0xe0, { KEY_PROG1 } }, /* Task Manager */
+	{ KE_KEY, 0xe1, { KEY_F14 } }, /* Change Resolution */
+	{ KE_KEY, 0xe9, { KEY_BRIGHTNESS_ZERO } },
+	{ KE_END, 0},
+};
+
+static acpi_status eeepc_wmi_parse_device(acpi_handle handle, u32 level,
+						 void *context, void **retval)
+{
+	pr_warning("Found legacy ATKD device (%s)", EEEPC_ACPI_HID);
+	*(bool *)context = true;
+	return AE_CTRL_TERMINATE;
+}
+
+static int eeepc_wmi_check_atkd(void)
+{
+	acpi_status status;
+	bool found = false;
+
+	status = acpi_get_devices(EEEPC_ACPI_HID, eeepc_wmi_parse_device,
+				  &found, NULL);
+
+	if (ACPI_FAILURE(status) || !found)
+		return 0;
+	return -1;
+}
+
+static int eeepc_wmi_probe(struct platform_device *pdev)
+{
+	if (eeepc_wmi_check_atkd()) {
+		pr_warning("WMI device present, but legacy ATKD device is also "
+			   "present and enabled.");
+		pr_warning("You probably booted with acpi_osi=\"Linux\" or "
+			   "acpi_osi=\"!Windows 2009\"");
+		pr_warning("Can't load eeepc-wmi, use default acpi_osi "
+			   "(preferred) or eeepc-laptop");
+		return -EBUSY;
+	}
+	return 0;
+}
+
+static void eeepc_dmi_check(struct asus_wmi_driver *driver)
+{
+	const char *model;
+
+	model = dmi_get_system_info(DMI_PRODUCT_NAME);
+	if (!model)
+		return;
+
+	/*
+	 * Whitelist for wlan hotplug
+	 *
+	 * Asus 1000H needs the current hotplug code to handle
+	 * Fn+F2 correctly. We may add other Asus here later, but
+	 * it seems that most of the laptops supported by asus-wmi
+	 * don't need to be on this list
+	 */
+	if (strcmp(model, "1000H") == 0) {
+		driver->hotplug_wireless = true;
+		pr_info("wlan hotplug enabled\n");
+	}
+}
+
+static void eeepc_wmi_quirks(struct asus_wmi_driver *driver)
+{
+	driver->hotplug_wireless = hotplug_wireless;
+	eeepc_dmi_check(driver);
+}
+
+static struct asus_wmi_driver asus_wmi_driver = {
+	.name = EEEPC_WMI_FILE,
+	.owner = THIS_MODULE,
+	.event_guid = EEEPC_WMI_EVENT_GUID,
+	.keymap = eeepc_wmi_keymap,
+	.input_name = "Eee PC WMI hotkeys",
+	.input_phys = EEEPC_WMI_FILE "/input0",
+	.probe = eeepc_wmi_probe,
+	.quirks = eeepc_wmi_quirks,
+};
+
+
+static int __init eeepc_wmi_init(void)
+{
+	return asus_wmi_register_driver(&asus_wmi_driver);
+}
+
+static void __exit eeepc_wmi_exit(void)
+{
+	asus_wmi_unregister_driver(&asus_wmi_driver);
+}
+
+module_init(eeepc_wmi_init);
+module_exit(eeepc_wmi_exit);

commit 5b799d4fb787bb94f1068352220ab033ac7969f8
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sat Feb 26 10:20:30 2011 +0100

    asus-wmi: move generic code to asus-wmi
    
    New Asus notebooks are using a WMI device similar to
    the one used in Eee PCs. Since we don't want to load
    a module named eeepc-laptop on Asus Notebooks, start by
    copying all the code to asus-wmi.c.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
deleted file mode 100644
index d3997757e790..000000000000
--- a/drivers/platform/x86/eeepc-wmi.c
+++ /dev/null
@@ -1,1454 +0,0 @@
-/*
- * Eee PC WMI hotkey driver
- *
- * Copyright(C) 2010 Intel Corporation.
- * Copyright(C) 2010 Corentin Chary <corentin.chary@gmail.com>
- *
- * Portions based on wistron_btns.c:
- * Copyright (C) 2005 Miloslav Trmac <mitr@volny.cz>
- * Copyright (C) 2005 Bernhard Rosenkraenzer <bero@arklinux.org>
- * Copyright (C) 2005 Dmitry Torokhov <dtor@mail.ru>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/slab.h>
-#include <linux/input.h>
-#include <linux/input/sparse-keymap.h>
-#include <linux/fb.h>
-#include <linux/backlight.h>
-#include <linux/leds.h>
-#include <linux/rfkill.h>
-#include <linux/pci.h>
-#include <linux/pci_hotplug.h>
-#include <linux/debugfs.h>
-#include <linux/seq_file.h>
-#include <linux/platform_device.h>
-#include <linux/dmi.h>
-#include <acpi/acpi_bus.h>
-#include <acpi/acpi_drivers.h>
-
-#define	EEEPC_WMI_FILE	"eeepc-wmi"
-
-MODULE_AUTHOR("Yong Wang <yong.y.wang@intel.com>");
-MODULE_DESCRIPTION("Eee PC WMI Hotkey Driver");
-MODULE_LICENSE("GPL");
-
-#define EEEPC_ACPI_HID		"ASUS010" /* old _HID used in eeepc-laptop */
-
-#define EEEPC_WMI_EVENT_GUID	"ABBC0F72-8EA1-11D1-00A0-C90629100000"
-#define EEEPC_WMI_MGMT_GUID	"97845ED0-4E6D-11DE-8A39-0800200C9A66"
-
-MODULE_ALIAS("wmi:"EEEPC_WMI_EVENT_GUID);
-MODULE_ALIAS("wmi:"EEEPC_WMI_MGMT_GUID);
-
-#define NOTIFY_BRNUP_MIN		0x11
-#define NOTIFY_BRNUP_MAX		0x1f
-#define NOTIFY_BRNDOWN_MIN		0x20
-#define NOTIFY_BRNDOWN_MAX		0x2e
-
-/* WMI Methods */
-#define EEEPC_WMI_METHODID_DSTS		0x53544344
-#define EEEPC_WMI_METHODID_DEVS		0x53564544
-#define EEEPC_WMI_METHODID_CFVS		0x53564643
-
-/* Wireless */
-#define EEEPC_WMI_DEVID_WLAN		0x00010011
-#define EEEPC_WMI_DEVID_BLUETOOTH	0x00010013
-#define EEEPC_WMI_DEVID_WIMAX		0x00010017
-#define EEEPC_WMI_DEVID_WWAN3G		0x00010019
-
-/* Backlight and Brightness */
-#define EEEPC_WMI_DEVID_BACKLIGHT	0x00050011
-#define EEEPC_WMI_DEVID_BRIGHTNESS	0x00050012
-
-/* Misc */
-#define EEEPC_WMI_DEVID_CAMERA		0x00060013
-
-/* Storage */
-#define EEEPC_WMI_DEVID_CARDREADER	0x00080013
-
-/* Input */
-#define EEEPC_WMI_DEVID_TOUCHPAD	0x00100011
-#define EEEPC_WMI_DEVID_TOUCHPAD_LED	0x00100012
-
-/* DSTS masks */
-#define EEEPC_WMI_DSTS_STATUS_BIT	0x00000001
-#define EEEPC_WMI_DSTS_PRESENCE_BIT	0x00010000
-#define EEEPC_WMI_DSTS_BRIGHTNESS_MASK	0x000000FF
-#define EEEPC_WMI_DSTS_MAX_BRIGTH_MASK	0x0000FF00
-
-static bool hotplug_wireless;
-
-module_param(hotplug_wireless, bool, 0444);
-MODULE_PARM_DESC(hotplug_wireless,
-		 "Enable hotplug for wireless device. "
-		 "If your laptop needs that, please report to "
-		 "acpi4asus-user@lists.sourceforge.net.");
-
-static const struct key_entry eeepc_wmi_keymap[] = {
-	/* Sleep already handled via generic ACPI code */
-	{ KE_IGNORE, NOTIFY_BRNDOWN_MIN, { KEY_BRIGHTNESSDOWN } },
-	{ KE_IGNORE, NOTIFY_BRNUP_MIN, { KEY_BRIGHTNESSUP } },
-	{ KE_KEY, 0x30, { KEY_VOLUMEUP } },
-	{ KE_KEY, 0x31, { KEY_VOLUMEDOWN } },
-	{ KE_KEY, 0x32, { KEY_MUTE } },
-	{ KE_KEY, 0x5c, { KEY_F15 } }, /* Power Gear key */
-	{ KE_KEY, 0x5d, { KEY_WLAN } },
-	{ KE_KEY, 0x6b, { KEY_F13 } }, /* Disable Touchpad */
-	{ KE_KEY, 0x82, { KEY_CAMERA } },
-	{ KE_KEY, 0x83, { KEY_CAMERA_ZOOMIN } },
-	{ KE_KEY, 0x88, { KEY_WLAN } },
-	{ KE_KEY, 0xcc, { KEY_SWITCHVIDEOMODE } },
-	{ KE_KEY, 0xe0, { KEY_PROG1 } }, /* Task Manager */
-	{ KE_KEY, 0xe1, { KEY_F14 } }, /* Change Resolution */
-	{ KE_KEY, 0xe9, { KEY_BRIGHTNESS_ZERO } },
-	{ KE_KEY, 0xeb, { KEY_CAMERA_ZOOMOUT } },
-	{ KE_KEY, 0xec, { KEY_CAMERA_UP } },
-	{ KE_KEY, 0xed, { KEY_CAMERA_DOWN } },
-	{ KE_KEY, 0xee, { KEY_CAMERA_LEFT } },
-	{ KE_KEY, 0xef, { KEY_CAMERA_RIGHT } },
-	{ KE_END, 0},
-};
-
-struct bios_args {
-	u32	dev_id;
-	u32	ctrl_param;
-};
-
-/*
- * eeepc-wmi/    - debugfs root directory
- *   dev_id      - current dev_id
- *   ctrl_param  - current ctrl_param
- *   devs        - call DEVS(dev_id, ctrl_param) and print result
- *   dsts        - call DSTS(dev_id)  and print result
- */
-struct eeepc_wmi_debug {
-	struct dentry *root;
-	u32 dev_id;
-	u32 ctrl_param;
-};
-
-struct eeepc_wmi {
-	bool hotplug_wireless;
-
-	struct input_dev *inputdev;
-	struct backlight_device *backlight_device;
-	struct platform_device *platform_device;
-
-	struct led_classdev tpd_led;
-	int tpd_led_wk;
-	struct workqueue_struct *led_workqueue;
-	struct work_struct tpd_led_work;
-
-	struct rfkill *wlan_rfkill;
-	struct rfkill *bluetooth_rfkill;
-	struct rfkill *wimax_rfkill;
-	struct rfkill *wwan3g_rfkill;
-
-	struct hotplug_slot *hotplug_slot;
-	struct mutex hotplug_lock;
-	struct mutex wmi_lock;
-	struct workqueue_struct *hotplug_workqueue;
-	struct work_struct hotplug_work;
-
-	struct eeepc_wmi_debug debug;
-};
-
-static int eeepc_wmi_input_init(struct eeepc_wmi *eeepc)
-{
-	int err;
-
-	eeepc->inputdev = input_allocate_device();
-	if (!eeepc->inputdev)
-		return -ENOMEM;
-
-	eeepc->inputdev->name = "Eee PC WMI hotkeys";
-	eeepc->inputdev->phys = EEEPC_WMI_FILE "/input0";
-	eeepc->inputdev->id.bustype = BUS_HOST;
-	eeepc->inputdev->dev.parent = &eeepc->platform_device->dev;
-
-	err = sparse_keymap_setup(eeepc->inputdev, eeepc_wmi_keymap, NULL);
-	if (err)
-		goto err_free_dev;
-
-	err = input_register_device(eeepc->inputdev);
-	if (err)
-		goto err_free_keymap;
-
-	return 0;
-
-err_free_keymap:
-	sparse_keymap_free(eeepc->inputdev);
-err_free_dev:
-	input_free_device(eeepc->inputdev);
-	return err;
-}
-
-static void eeepc_wmi_input_exit(struct eeepc_wmi *eeepc)
-{
-	if (eeepc->inputdev) {
-		sparse_keymap_free(eeepc->inputdev);
-		input_unregister_device(eeepc->inputdev);
-	}
-
-	eeepc->inputdev = NULL;
-}
-
-static acpi_status eeepc_wmi_get_devstate(u32 dev_id, u32 *retval)
-{
-	struct acpi_buffer input = { (acpi_size)sizeof(u32), &dev_id };
-	struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
-	union acpi_object *obj;
-	acpi_status status;
-	u32 tmp;
-
-	status = wmi_evaluate_method(EEEPC_WMI_MGMT_GUID,
-				     1, EEEPC_WMI_METHODID_DSTS,
-				     &input, &output);
-
-	if (ACPI_FAILURE(status))
-		return status;
-
-	obj = (union acpi_object *)output.pointer;
-	if (obj && obj->type == ACPI_TYPE_INTEGER)
-		tmp = (u32)obj->integer.value;
-	else
-		tmp = 0;
-
-	if (retval)
-		*retval = tmp;
-
-	kfree(obj);
-
-	return status;
-
-}
-
-static acpi_status eeepc_wmi_set_devstate(u32 dev_id, u32 ctrl_param,
-					  u32 *retval)
-{
-	struct bios_args args = {
-		.dev_id = dev_id,
-		.ctrl_param = ctrl_param,
-	};
-	struct acpi_buffer input = { (acpi_size)sizeof(args), &args };
-	acpi_status status;
-
-	if (!retval) {
-		status = wmi_evaluate_method(EEEPC_WMI_MGMT_GUID, 1,
-					     EEEPC_WMI_METHODID_DEVS,
-					     &input, NULL);
-	} else {
-		struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
-		union acpi_object *obj;
-		u32 tmp;
-
-		status = wmi_evaluate_method(EEEPC_WMI_MGMT_GUID, 1,
-					     EEEPC_WMI_METHODID_DEVS,
-					     &input, &output);
-
-		if (ACPI_FAILURE(status))
-			return status;
-
-		obj = (union acpi_object *)output.pointer;
-		if (obj && obj->type == ACPI_TYPE_INTEGER)
-			tmp = (u32)obj->integer.value;
-		else
-			tmp = 0;
-
-		*retval = tmp;
-
-		kfree(obj);
-	}
-
-	return status;
-}
-
-/* Helper for special devices with magic return codes */
-static int eeepc_wmi_get_devstate_bits(u32 dev_id, u32 mask)
-{
-	u32 retval = 0;
-	acpi_status status;
-
-	status = eeepc_wmi_get_devstate(dev_id, &retval);
-
-	if (ACPI_FAILURE(status))
-		return -EINVAL;
-
-	if (!(retval & EEEPC_WMI_DSTS_PRESENCE_BIT))
-		return -ENODEV;
-
-	return retval & mask;
-}
-
-static int eeepc_wmi_get_devstate_simple(u32 dev_id)
-{
-	return eeepc_wmi_get_devstate_bits(dev_id, EEEPC_WMI_DSTS_STATUS_BIT);
-}
-
-/*
- * LEDs
- */
-/*
- * These functions actually update the LED's, and are called from a
- * workqueue. By doing this as separate work rather than when the LED
- * subsystem asks, we avoid messing with the Eeepc ACPI stuff during a
- * potentially bad time, such as a timer interrupt.
- */
-static void tpd_led_update(struct work_struct *work)
-{
-	int ctrl_param;
-	struct eeepc_wmi *eeepc;
-
-	eeepc = container_of(work, struct eeepc_wmi, tpd_led_work);
-
-	ctrl_param = eeepc->tpd_led_wk;
-	eeepc_wmi_set_devstate(EEEPC_WMI_DEVID_TOUCHPAD_LED, ctrl_param, NULL);
-}
-
-static void tpd_led_set(struct led_classdev *led_cdev,
-			enum led_brightness value)
-{
-	struct eeepc_wmi *eeepc;
-
-	eeepc = container_of(led_cdev, struct eeepc_wmi, tpd_led);
-
-	eeepc->tpd_led_wk = !!value;
-	queue_work(eeepc->led_workqueue, &eeepc->tpd_led_work);
-}
-
-static int read_tpd_led_state(struct eeepc_wmi *eeepc)
-{
-	return eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_TOUCHPAD_LED);
-}
-
-static enum led_brightness tpd_led_get(struct led_classdev *led_cdev)
-{
-	struct eeepc_wmi *eeepc;
-
-	eeepc = container_of(led_cdev, struct eeepc_wmi, tpd_led);
-
-	return read_tpd_led_state(eeepc);
-}
-
-static int eeepc_wmi_led_init(struct eeepc_wmi *eeepc)
-{
-	int rv;
-
-	if (read_tpd_led_state(eeepc) < 0)
-		return 0;
-
-	eeepc->led_workqueue = create_singlethread_workqueue("led_workqueue");
-	if (!eeepc->led_workqueue)
-		return -ENOMEM;
-	INIT_WORK(&eeepc->tpd_led_work, tpd_led_update);
-
-	eeepc->tpd_led.name = "eeepc::touchpad";
-	eeepc->tpd_led.brightness_set = tpd_led_set;
-	eeepc->tpd_led.brightness_get = tpd_led_get;
-	eeepc->tpd_led.max_brightness = 1;
-
-	rv = led_classdev_register(&eeepc->platform_device->dev,
-				   &eeepc->tpd_led);
-	if (rv) {
-		destroy_workqueue(eeepc->led_workqueue);
-		return rv;
-	}
-
-	return 0;
-}
-
-static void eeepc_wmi_led_exit(struct eeepc_wmi *eeepc)
-{
-	if (eeepc->tpd_led.dev)
-		led_classdev_unregister(&eeepc->tpd_led);
-	if (eeepc->led_workqueue)
-		destroy_workqueue(eeepc->led_workqueue);
-}
-
-/*
- * PCI hotplug (for wlan rfkill)
- */
-static bool eeepc_wlan_rfkill_blocked(struct eeepc_wmi *eeepc)
-{
-	int result = eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_WLAN);
-
-	if (result < 0)
-		return false;
-	return !result;
-}
-
-static void eeepc_rfkill_hotplug(struct eeepc_wmi *eeepc)
-{
-	struct pci_dev *dev;
-	struct pci_bus *bus;
-	bool blocked;
-	bool absent;
-	u32 l;
-
-	mutex_lock(&eeepc->wmi_lock);
-	blocked = eeepc_wlan_rfkill_blocked(eeepc);
-	mutex_unlock(&eeepc->wmi_lock);
-
-	mutex_lock(&eeepc->hotplug_lock);
-
-	if (eeepc->wlan_rfkill)
-		rfkill_set_sw_state(eeepc->wlan_rfkill, blocked);
-
-	if (eeepc->hotplug_slot) {
-		bus = pci_find_bus(0, 1);
-		if (!bus) {
-			pr_warning("Unable to find PCI bus 1?\n");
-			goto out_unlock;
-		}
-
-		if (pci_bus_read_config_dword(bus, 0, PCI_VENDOR_ID, &l)) {
-			pr_err("Unable to read PCI config space?\n");
-			goto out_unlock;
-		}
-		absent = (l == 0xffffffff);
-
-		if (blocked != absent) {
-			pr_warning("BIOS says wireless lan is %s, "
-					"but the pci device is %s\n",
-				blocked ? "blocked" : "unblocked",
-				absent ? "absent" : "present");
-			pr_warning("skipped wireless hotplug as probably "
-					"inappropriate for this model\n");
-			goto out_unlock;
-		}
-
-		if (!blocked) {
-			dev = pci_get_slot(bus, 0);
-			if (dev) {
-				/* Device already present */
-				pci_dev_put(dev);
-				goto out_unlock;
-			}
-			dev = pci_scan_single_device(bus, 0);
-			if (dev) {
-				pci_bus_assign_resources(bus);
-				if (pci_bus_add_device(dev))
-					pr_err("Unable to hotplug wifi\n");
-			}
-		} else {
-			dev = pci_get_slot(bus, 0);
-			if (dev) {
-				pci_remove_bus_device(dev);
-				pci_dev_put(dev);
-			}
-		}
-	}
-
-out_unlock:
-	mutex_unlock(&eeepc->hotplug_lock);
-}
-
-static void eeepc_rfkill_notify(acpi_handle handle, u32 event, void *data)
-{
-	struct eeepc_wmi *eeepc = data;
-
-	if (event != ACPI_NOTIFY_BUS_CHECK)
-		return;
-
-	/*
-	 * We can't call directly eeepc_rfkill_hotplug because most
-	 * of the time WMBC is still being executed and not reetrant.
-	 * There is currently no way to tell ACPICA that  we want this
-	 * method to be serialized, we schedule a eeepc_rfkill_hotplug
-	 * call later, in a safer context.
-	 */
-	queue_work(eeepc->hotplug_workqueue, &eeepc->hotplug_work);
-}
-
-static int eeepc_register_rfkill_notifier(struct eeepc_wmi *eeepc,
-					  char *node)
-{
-	acpi_status status;
-	acpi_handle handle;
-
-	status = acpi_get_handle(NULL, node, &handle);
-
-	if (ACPI_SUCCESS(status)) {
-		status = acpi_install_notify_handler(handle,
-						     ACPI_SYSTEM_NOTIFY,
-						     eeepc_rfkill_notify,
-						     eeepc);
-		if (ACPI_FAILURE(status))
-			pr_warning("Failed to register notify on %s\n", node);
-	} else
-		return -ENODEV;
-
-	return 0;
-}
-
-static void eeepc_unregister_rfkill_notifier(struct eeepc_wmi *eeepc,
-					     char *node)
-{
-	acpi_status status = AE_OK;
-	acpi_handle handle;
-
-	status = acpi_get_handle(NULL, node, &handle);
-
-	if (ACPI_SUCCESS(status)) {
-		status = acpi_remove_notify_handler(handle,
-						     ACPI_SYSTEM_NOTIFY,
-						     eeepc_rfkill_notify);
-		if (ACPI_FAILURE(status))
-			pr_err("Error removing rfkill notify handler %s\n",
-				node);
-	}
-}
-
-static int eeepc_get_adapter_status(struct hotplug_slot *hotplug_slot,
-				    u8 *value)
-{
-	int result = eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_WLAN);
-
-	if (result < 0)
-		return result;
-
-	*value = !!result;
-	return 0;
-}
-
-static void eeepc_cleanup_pci_hotplug(struct hotplug_slot *hotplug_slot)
-{
-	kfree(hotplug_slot->info);
-	kfree(hotplug_slot);
-}
-
-static struct hotplug_slot_ops eeepc_hotplug_slot_ops = {
-	.owner = THIS_MODULE,
-	.get_adapter_status = eeepc_get_adapter_status,
-	.get_power_status = eeepc_get_adapter_status,
-};
-
-static void eeepc_hotplug_work(struct work_struct *work)
-{
-	struct eeepc_wmi *eeepc;
-
-	eeepc = container_of(work, struct eeepc_wmi, hotplug_work);
-	eeepc_rfkill_hotplug(eeepc);
-}
-
-static int eeepc_setup_pci_hotplug(struct eeepc_wmi *eeepc)
-{
-	int ret = -ENOMEM;
-	struct pci_bus *bus = pci_find_bus(0, 1);
-
-	if (!bus) {
-		pr_err("Unable to find wifi PCI bus\n");
-		return -ENODEV;
-	}
-
-	eeepc->hotplug_workqueue =
-		create_singlethread_workqueue("hotplug_workqueue");
-	if (!eeepc->hotplug_workqueue)
-		goto error_workqueue;
-
-	INIT_WORK(&eeepc->hotplug_work, eeepc_hotplug_work);
-
-	eeepc->hotplug_slot = kzalloc(sizeof(struct hotplug_slot), GFP_KERNEL);
-	if (!eeepc->hotplug_slot)
-		goto error_slot;
-
-	eeepc->hotplug_slot->info = kzalloc(sizeof(struct hotplug_slot_info),
-					    GFP_KERNEL);
-	if (!eeepc->hotplug_slot->info)
-		goto error_info;
-
-	eeepc->hotplug_slot->private = eeepc;
-	eeepc->hotplug_slot->release = &eeepc_cleanup_pci_hotplug;
-	eeepc->hotplug_slot->ops = &eeepc_hotplug_slot_ops;
-	eeepc_get_adapter_status(eeepc->hotplug_slot,
-				 &eeepc->hotplug_slot->info->adapter_status);
-
-	ret = pci_hp_register(eeepc->hotplug_slot, bus, 0, "eeepc-wifi");
-	if (ret) {
-		pr_err("Unable to register hotplug slot - %d\n", ret);
-		goto error_register;
-	}
-
-	return 0;
-
-error_register:
-	kfree(eeepc->hotplug_slot->info);
-error_info:
-	kfree(eeepc->hotplug_slot);
-	eeepc->hotplug_slot = NULL;
-error_slot:
-	destroy_workqueue(eeepc->hotplug_workqueue);
-error_workqueue:
-	return ret;
-}
-
-/*
- * Rfkill devices
- */
-static int eeepc_rfkill_set(void *data, bool blocked)
-{
-	int dev_id = (unsigned long)data;
-	u32 ctrl_param = !blocked;
-	acpi_status status;
-
-	status = eeepc_wmi_set_devstate(dev_id, ctrl_param, NULL);
-
-	if (ACPI_FAILURE(status))
-		return -EIO;
-
-	return 0;
-}
-
-static void eeepc_rfkill_query(struct rfkill *rfkill, void *data)
-{
-	int dev_id = (unsigned long)data;
-	int result;
-
-	result = eeepc_wmi_get_devstate_simple(dev_id);
-
-	if (result < 0)
-		return ;
-
-	rfkill_set_sw_state(rfkill, !result);
-}
-
-static int eeepc_rfkill_wlan_set(void *data, bool blocked)
-{
-	struct eeepc_wmi *eeepc = data;
-	int ret;
-
-	/*
-	 * This handler is enabled only if hotplug is enabled.
-	 * In this case, the eeepc_wmi_set_devstate() will
-	 * trigger a wmi notification and we need to wait
-	 * this call to finish before being able to call
-	 * any wmi method
-	 */
-	mutex_lock(&eeepc->wmi_lock);
-	ret = eeepc_rfkill_set((void *)(long)EEEPC_WMI_DEVID_WLAN, blocked);
-	mutex_unlock(&eeepc->wmi_lock);
-	return ret;
-}
-
-static void eeepc_rfkill_wlan_query(struct rfkill *rfkill, void *data)
-{
-	eeepc_rfkill_query(rfkill, (void *)(long)EEEPC_WMI_DEVID_WLAN);
-}
-
-static const struct rfkill_ops eeepc_rfkill_wlan_ops = {
-	.set_block = eeepc_rfkill_wlan_set,
-	.query = eeepc_rfkill_wlan_query,
-};
-
-static const struct rfkill_ops eeepc_rfkill_ops = {
-	.set_block = eeepc_rfkill_set,
-	.query = eeepc_rfkill_query,
-};
-
-static int eeepc_new_rfkill(struct eeepc_wmi *eeepc,
-			    struct rfkill **rfkill,
-			    const char *name,
-			    enum rfkill_type type, int dev_id)
-{
-	int result = eeepc_wmi_get_devstate_simple(dev_id);
-
-	if (result < 0)
-		return result;
-
-	if (dev_id == EEEPC_WMI_DEVID_WLAN && eeepc->hotplug_wireless)
-		*rfkill = rfkill_alloc(name, &eeepc->platform_device->dev, type,
-				       &eeepc_rfkill_wlan_ops, eeepc);
-	else
-		*rfkill = rfkill_alloc(name, &eeepc->platform_device->dev, type,
-				       &eeepc_rfkill_ops, (void *)(long)dev_id);
-
-	if (!*rfkill)
-		return -EINVAL;
-
-	rfkill_init_sw_state(*rfkill, !result);
-	result = rfkill_register(*rfkill);
-	if (result) {
-		rfkill_destroy(*rfkill);
-		*rfkill = NULL;
-		return result;
-	}
-	return 0;
-}
-
-static void eeepc_wmi_rfkill_exit(struct eeepc_wmi *eeepc)
-{
-	eeepc_unregister_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P5");
-	eeepc_unregister_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P6");
-	eeepc_unregister_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P7");
-	if (eeepc->wlan_rfkill) {
-		rfkill_unregister(eeepc->wlan_rfkill);
-		rfkill_destroy(eeepc->wlan_rfkill);
-		eeepc->wlan_rfkill = NULL;
-	}
-	/*
-	 * Refresh pci hotplug in case the rfkill state was changed after
-	 * eeepc_unregister_rfkill_notifier()
-	 */
-	eeepc_rfkill_hotplug(eeepc);
-	if (eeepc->hotplug_slot)
-		pci_hp_deregister(eeepc->hotplug_slot);
-	if (eeepc->hotplug_workqueue)
-		destroy_workqueue(eeepc->hotplug_workqueue);
-
-	if (eeepc->bluetooth_rfkill) {
-		rfkill_unregister(eeepc->bluetooth_rfkill);
-		rfkill_destroy(eeepc->bluetooth_rfkill);
-		eeepc->bluetooth_rfkill = NULL;
-	}
-	if (eeepc->wimax_rfkill) {
-		rfkill_unregister(eeepc->wimax_rfkill);
-		rfkill_destroy(eeepc->wimax_rfkill);
-		eeepc->wimax_rfkill = NULL;
-	}
-	if (eeepc->wwan3g_rfkill) {
-		rfkill_unregister(eeepc->wwan3g_rfkill);
-		rfkill_destroy(eeepc->wwan3g_rfkill);
-		eeepc->wwan3g_rfkill = NULL;
-	}
-}
-
-static int eeepc_wmi_rfkill_init(struct eeepc_wmi *eeepc)
-{
-	int result = 0;
-
-	mutex_init(&eeepc->hotplug_lock);
-	mutex_init(&eeepc->wmi_lock);
-
-	result = eeepc_new_rfkill(eeepc, &eeepc->wlan_rfkill,
-				  "eeepc-wlan", RFKILL_TYPE_WLAN,
-				  EEEPC_WMI_DEVID_WLAN);
-
-	if (result && result != -ENODEV)
-		goto exit;
-
-	result = eeepc_new_rfkill(eeepc, &eeepc->bluetooth_rfkill,
-				  "eeepc-bluetooth", RFKILL_TYPE_BLUETOOTH,
-				  EEEPC_WMI_DEVID_BLUETOOTH);
-
-	if (result && result != -ENODEV)
-		goto exit;
-
-	result = eeepc_new_rfkill(eeepc, &eeepc->wimax_rfkill,
-				  "eeepc-wimax", RFKILL_TYPE_WIMAX,
-				  EEEPC_WMI_DEVID_WIMAX);
-
-	if (result && result != -ENODEV)
-		goto exit;
-
-	result = eeepc_new_rfkill(eeepc, &eeepc->wwan3g_rfkill,
-				  "eeepc-wwan3g", RFKILL_TYPE_WWAN,
-				  EEEPC_WMI_DEVID_WWAN3G);
-
-	if (result && result != -ENODEV)
-		goto exit;
-
-	if (!eeepc->hotplug_wireless)
-		goto exit;
-
-	result = eeepc_setup_pci_hotplug(eeepc);
-	/*
-	 * If we get -EBUSY then something else is handling the PCI hotplug -
-	 * don't fail in this case
-	 */
-	if (result == -EBUSY)
-		result = 0;
-
-	eeepc_register_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P5");
-	eeepc_register_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P6");
-	eeepc_register_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P7");
-	/*
-	 * Refresh pci hotplug in case the rfkill state was changed during
-	 * setup.
-	 */
-	eeepc_rfkill_hotplug(eeepc);
-
-exit:
-	if (result && result != -ENODEV)
-		eeepc_wmi_rfkill_exit(eeepc);
-
-	if (result == -ENODEV)
-		result = 0;
-
-	return result;
-}
-
-/*
- * Backlight
- */
-static int read_backlight_power(void)
-{
-	int ret = eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_BACKLIGHT);
-
-	if (ret < 0)
-		return ret;
-
-	return ret ? FB_BLANK_UNBLANK : FB_BLANK_POWERDOWN;
-}
-
-static int read_brightness(struct backlight_device *bd)
-{
-	u32 retval;
-	acpi_status status;
-
-	status = eeepc_wmi_get_devstate(EEEPC_WMI_DEVID_BRIGHTNESS, &retval);
-
-	if (ACPI_FAILURE(status))
-		return -EIO;
-	else
-		return retval & EEEPC_WMI_DSTS_BRIGHTNESS_MASK;
-}
-
-static int update_bl_status(struct backlight_device *bd)
-{
-	u32 ctrl_param;
-	acpi_status status;
-	int power;
-
-	ctrl_param = bd->props.brightness;
-
-	status = eeepc_wmi_set_devstate(EEEPC_WMI_DEVID_BRIGHTNESS,
-					ctrl_param, NULL);
-
-	if (ACPI_FAILURE(status))
-		return -EIO;
-
-	power = read_backlight_power();
-	if (power != -ENODEV && bd->props.power != power) {
-		ctrl_param = !!(bd->props.power == FB_BLANK_UNBLANK);
-		status = eeepc_wmi_set_devstate(EEEPC_WMI_DEVID_BACKLIGHT,
-						ctrl_param, NULL);
-
-		if (ACPI_FAILURE(status))
-			return -EIO;
-	}
-	return 0;
-}
-
-static const struct backlight_ops eeepc_wmi_bl_ops = {
-	.get_brightness = read_brightness,
-	.update_status = update_bl_status,
-};
-
-static int eeepc_wmi_backlight_notify(struct eeepc_wmi *eeepc, int code)
-{
-	struct backlight_device *bd = eeepc->backlight_device;
-	int old = bd->props.brightness;
-	int new = old;
-
-	if (code >= NOTIFY_BRNUP_MIN && code <= NOTIFY_BRNUP_MAX)
-		new = code - NOTIFY_BRNUP_MIN + 1;
-	else if (code >= NOTIFY_BRNDOWN_MIN && code <= NOTIFY_BRNDOWN_MAX)
-		new = code - NOTIFY_BRNDOWN_MIN;
-
-	bd->props.brightness = new;
-	backlight_update_status(bd);
-	backlight_force_update(bd, BACKLIGHT_UPDATE_HOTKEY);
-
-	return old;
-}
-
-static int eeepc_wmi_backlight_init(struct eeepc_wmi *eeepc)
-{
-	struct backlight_device *bd;
-	struct backlight_properties props;
-	int max;
-	int power;
-
-	max = eeepc_wmi_get_devstate_bits(EEEPC_WMI_DEVID_BRIGHTNESS,
-					  EEEPC_WMI_DSTS_MAX_BRIGTH_MASK);
-	power = read_backlight_power();
-
-	if (max < 0 && power < 0) {
-		/* Try to keep the original error */
-		if (max == -ENODEV && power == -ENODEV)
-			return -ENODEV;
-		if (max != -ENODEV)
-			return max;
-		else
-			return power;
-	}
-	if (max == -ENODEV)
-		max = 0;
-	if (power == -ENODEV)
-		power = FB_BLANK_UNBLANK;
-
-	memset(&props, 0, sizeof(struct backlight_properties));
-	props.max_brightness = max;
-	bd = backlight_device_register(EEEPC_WMI_FILE,
-				       &eeepc->platform_device->dev, eeepc,
-				       &eeepc_wmi_bl_ops, &props);
-	if (IS_ERR(bd)) {
-		pr_err("Could not register backlight device\n");
-		return PTR_ERR(bd);
-	}
-
-	eeepc->backlight_device = bd;
-
-	bd->props.brightness = read_brightness(bd);
-	bd->props.power = power;
-	backlight_update_status(bd);
-
-	return 0;
-}
-
-static void eeepc_wmi_backlight_exit(struct eeepc_wmi *eeepc)
-{
-	if (eeepc->backlight_device)
-		backlight_device_unregister(eeepc->backlight_device);
-
-	eeepc->backlight_device = NULL;
-}
-
-static void eeepc_wmi_notify(u32 value, void *context)
-{
-	struct eeepc_wmi *eeepc = context;
-	struct acpi_buffer response = { ACPI_ALLOCATE_BUFFER, NULL };
-	union acpi_object *obj;
-	acpi_status status;
-	int code;
-	int orig_code;
-
-	status = wmi_get_event_data(value, &response);
-	if (status != AE_OK) {
-		pr_err("bad event status 0x%x\n", status);
-		return;
-	}
-
-	obj = (union acpi_object *)response.pointer;
-
-	if (obj && obj->type == ACPI_TYPE_INTEGER) {
-		code = obj->integer.value;
-		orig_code = code;
-
-		if (code >= NOTIFY_BRNUP_MIN && code <= NOTIFY_BRNUP_MAX)
-			code = NOTIFY_BRNUP_MIN;
-		else if (code >= NOTIFY_BRNDOWN_MIN &&
-			 code <= NOTIFY_BRNDOWN_MAX)
-			code = NOTIFY_BRNDOWN_MIN;
-
-		if (code == NOTIFY_BRNUP_MIN || code == NOTIFY_BRNDOWN_MIN) {
-			if (!acpi_video_backlight_support())
-				eeepc_wmi_backlight_notify(eeepc, orig_code);
-		}
-
-		if (!sparse_keymap_report_event(eeepc->inputdev,
-						code, 1, true))
-			pr_info("Unknown key %x pressed\n", code);
-	}
-
-	kfree(obj);
-}
-
-/*
- * Sys helpers
- */
-static int parse_arg(const char *buf, unsigned long count, int *val)
-{
-	if (!count)
-		return 0;
-	if (sscanf(buf, "%i", val) != 1)
-		return -EINVAL;
-	return count;
-}
-
-static ssize_t store_sys_wmi(int devid, const char *buf, size_t count)
-{
-	acpi_status status;
-	u32 retval;
-	int rv, value;
-
-	value = eeepc_wmi_get_devstate_simple(devid);
-	if (value == -ENODEV) /* Check device presence */
-		return value;
-
-	rv = parse_arg(buf, count, &value);
-	status = eeepc_wmi_set_devstate(devid, value, &retval);
-
-	if (ACPI_FAILURE(status))
-		return -EIO;
-	return rv;
-}
-
-static ssize_t show_sys_wmi(int devid, char *buf)
-{
-	int value = eeepc_wmi_get_devstate_simple(devid);
-
-	if (value < 0)
-		return value;
-
-	return sprintf(buf, "%d\n", value);
-}
-
-#define EEEPC_WMI_CREATE_DEVICE_ATTR(_name, _mode, _cm)			\
-	static ssize_t show_##_name(struct device *dev,			\
-				    struct device_attribute *attr,	\
-				    char *buf)				\
-	{								\
-		return show_sys_wmi(_cm, buf);				\
-	}								\
-	static ssize_t store_##_name(struct device *dev,		\
-				     struct device_attribute *attr,	\
-				     const char *buf, size_t count)	\
-	{								\
-		return store_sys_wmi(_cm, buf, count);			\
-	}								\
-	static struct device_attribute dev_attr_##_name = {		\
-		.attr = {						\
-			.name = __stringify(_name),			\
-			.mode = _mode },				\
-		.show   = show_##_name,					\
-		.store  = store_##_name,				\
-	}
-
-EEEPC_WMI_CREATE_DEVICE_ATTR(touchpad, 0644, EEEPC_WMI_DEVID_TOUCHPAD);
-EEEPC_WMI_CREATE_DEVICE_ATTR(camera, 0644, EEEPC_WMI_DEVID_CAMERA);
-EEEPC_WMI_CREATE_DEVICE_ATTR(cardr, 0644, EEEPC_WMI_DEVID_CARDREADER);
-
-static ssize_t store_cpufv(struct device *dev, struct device_attribute *attr,
-			   const char *buf, size_t count)
-{
-	int value;
-	struct acpi_buffer input = { (acpi_size)sizeof(value), &value };
-	acpi_status status;
-
-	if (!count || sscanf(buf, "%i", &value) != 1)
-		return -EINVAL;
-	if (value < 0 || value > 2)
-		return -EINVAL;
-
-	status = wmi_evaluate_method(EEEPC_WMI_MGMT_GUID,
-				     1, EEEPC_WMI_METHODID_CFVS, &input, NULL);
-
-	if (ACPI_FAILURE(status))
-		return -EIO;
-	else
-		return count;
-}
-
-static DEVICE_ATTR(cpufv, S_IRUGO | S_IWUSR, NULL, store_cpufv);
-
-static struct attribute *platform_attributes[] = {
-	&dev_attr_cpufv.attr,
-	&dev_attr_camera.attr,
-	&dev_attr_cardr.attr,
-	&dev_attr_touchpad.attr,
-	NULL
-};
-
-static mode_t eeepc_sysfs_is_visible(struct kobject *kobj,
-				     struct attribute *attr,
-				     int idx)
-{
-	bool supported = true;
-	int devid = -1;
-
-	if (attr == &dev_attr_camera.attr)
-		devid = EEEPC_WMI_DEVID_CAMERA;
-	else if (attr == &dev_attr_cardr.attr)
-		devid = EEEPC_WMI_DEVID_CARDREADER;
-	else if (attr == &dev_attr_touchpad.attr)
-		devid = EEEPC_WMI_DEVID_TOUCHPAD;
-
-	if (devid != -1)
-		supported = eeepc_wmi_get_devstate_simple(devid) != -ENODEV;
-
-	return supported ? attr->mode : 0;
-}
-
-static struct attribute_group platform_attribute_group = {
-	.is_visible	= eeepc_sysfs_is_visible,
-	.attrs		= platform_attributes
-};
-
-static void eeepc_wmi_sysfs_exit(struct platform_device *device)
-{
-	sysfs_remove_group(&device->dev.kobj, &platform_attribute_group);
-}
-
-static int eeepc_wmi_sysfs_init(struct platform_device *device)
-{
-	return sysfs_create_group(&device->dev.kobj, &platform_attribute_group);
-}
-
-/*
- * Platform device
- */
-static int __init eeepc_wmi_platform_init(struct eeepc_wmi *eeepc)
-{
-	return eeepc_wmi_sysfs_init(eeepc->platform_device);
-}
-
-static void eeepc_wmi_platform_exit(struct eeepc_wmi *eeepc)
-{
-	eeepc_wmi_sysfs_exit(eeepc->platform_device);
-}
-
-/*
- * debugfs
- */
-struct eeepc_wmi_debugfs_node {
-	struct eeepc_wmi *eeepc;
-	char *name;
-	int (*show)(struct seq_file *m, void *data);
-};
-
-static int show_dsts(struct seq_file *m, void *data)
-{
-	struct eeepc_wmi *eeepc = m->private;
-	acpi_status status;
-	u32 retval = -1;
-
-	status = eeepc_wmi_get_devstate(eeepc->debug.dev_id, &retval);
-
-	if (ACPI_FAILURE(status))
-		return -EIO;
-
-	seq_printf(m, "DSTS(%x) = %x\n", eeepc->debug.dev_id, retval);
-
-	return 0;
-}
-
-static int show_devs(struct seq_file *m, void *data)
-{
-	struct eeepc_wmi *eeepc = m->private;
-	acpi_status status;
-	u32 retval = -1;
-
-	status = eeepc_wmi_set_devstate(eeepc->debug.dev_id,
-					eeepc->debug.ctrl_param, &retval);
-	if (ACPI_FAILURE(status))
-		return -EIO;
-
-	seq_printf(m, "DEVS(%x, %x) = %x\n", eeepc->debug.dev_id,
-		   eeepc->debug.ctrl_param, retval);
-
-	return 0;
-}
-
-static struct eeepc_wmi_debugfs_node eeepc_wmi_debug_files[] = {
-	{ NULL, "devs", show_devs },
-	{ NULL, "dsts", show_dsts },
-};
-
-static int eeepc_wmi_debugfs_open(struct inode *inode, struct file *file)
-{
-	struct eeepc_wmi_debugfs_node *node = inode->i_private;
-
-	return single_open(file, node->show, node->eeepc);
-}
-
-static const struct file_operations eeepc_wmi_debugfs_io_ops = {
-	.owner = THIS_MODULE,
-	.open  = eeepc_wmi_debugfs_open,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static void eeepc_wmi_debugfs_exit(struct eeepc_wmi *eeepc)
-{
-	debugfs_remove_recursive(eeepc->debug.root);
-}
-
-static int eeepc_wmi_debugfs_init(struct eeepc_wmi *eeepc)
-{
-	struct dentry *dent;
-	int i;
-
-	eeepc->debug.root = debugfs_create_dir(EEEPC_WMI_FILE, NULL);
-	if (!eeepc->debug.root) {
-		pr_err("failed to create debugfs directory");
-		goto error_debugfs;
-	}
-
-	dent = debugfs_create_x32("dev_id", S_IRUGO|S_IWUSR,
-				  eeepc->debug.root, &eeepc->debug.dev_id);
-	if (!dent)
-		goto error_debugfs;
-
-	dent = debugfs_create_x32("ctrl_param", S_IRUGO|S_IWUSR,
-				  eeepc->debug.root, &eeepc->debug.ctrl_param);
-	if (!dent)
-		goto error_debugfs;
-
-	for (i = 0; i < ARRAY_SIZE(eeepc_wmi_debug_files); i++) {
-		struct eeepc_wmi_debugfs_node *node = &eeepc_wmi_debug_files[i];
-
-		node->eeepc = eeepc;
-		dent = debugfs_create_file(node->name, S_IFREG | S_IRUGO,
-					   eeepc->debug.root, node,
-					   &eeepc_wmi_debugfs_io_ops);
-		if (!dent) {
-			pr_err("failed to create debug file: %s\n", node->name);
-			goto error_debugfs;
-		}
-	}
-
-	return 0;
-
-error_debugfs:
-	eeepc_wmi_debugfs_exit(eeepc);
-	return -ENOMEM;
-}
-
-/*
- * WMI Driver
- */
-static void eeepc_dmi_check(struct eeepc_wmi *eeepc)
-{
-	const char *model;
-
-	model = dmi_get_system_info(DMI_PRODUCT_NAME);
-	if (!model)
-		return;
-
-	/*
-	 * Whitelist for wlan hotplug
-	 *
-	 * Eeepc 1000H needs the current hotplug code to handle
-	 * Fn+F2 correctly. We may add other Eeepc here later, but
-	 * it seems that most of the laptops supported by eeepc-wmi
-	 * don't need to be on this list
-	 */
-	if (strcmp(model, "1000H") == 0) {
-		eeepc->hotplug_wireless = true;
-		pr_info("wlan hotplug enabled\n");
-	}
-}
-
-static int __init eeepc_wmi_add(struct platform_device *pdev)
-{
-	struct eeepc_wmi *eeepc;
-	acpi_status status;
-	int err;
-
-	eeepc = kzalloc(sizeof(struct eeepc_wmi), GFP_KERNEL);
-	if (!eeepc)
-		return -ENOMEM;
-
-	eeepc->platform_device = pdev;
-	platform_set_drvdata(eeepc->platform_device, eeepc);
-
-	eeepc->hotplug_wireless = hotplug_wireless;
-	eeepc_dmi_check(eeepc);
-
-	err = eeepc_wmi_platform_init(eeepc);
-	if (err)
-		goto fail_platform;
-
-	err = eeepc_wmi_input_init(eeepc);
-	if (err)
-		goto fail_input;
-
-	err = eeepc_wmi_led_init(eeepc);
-	if (err)
-		goto fail_leds;
-
-	err = eeepc_wmi_rfkill_init(eeepc);
-	if (err)
-		goto fail_rfkill;
-
-	if (!acpi_video_backlight_support()) {
-		err = eeepc_wmi_backlight_init(eeepc);
-		if (err && err != -ENODEV)
-			goto fail_backlight;
-	} else
-		pr_info("Backlight controlled by ACPI video driver\n");
-
-	status = wmi_install_notify_handler(EEEPC_WMI_EVENT_GUID,
-					    eeepc_wmi_notify, eeepc);
-	if (ACPI_FAILURE(status)) {
-		pr_err("Unable to register notify handler - %d\n",
-			status);
-		err = -ENODEV;
-		goto fail_wmi_handler;
-	}
-
-	err = eeepc_wmi_debugfs_init(eeepc);
-	if (err)
-		goto fail_debugfs;
-
-	return 0;
-
-fail_debugfs:
-	wmi_remove_notify_handler(EEEPC_WMI_EVENT_GUID);
-fail_wmi_handler:
-	eeepc_wmi_backlight_exit(eeepc);
-fail_backlight:
-	eeepc_wmi_rfkill_exit(eeepc);
-fail_rfkill:
-	eeepc_wmi_led_exit(eeepc);
-fail_leds:
-	eeepc_wmi_input_exit(eeepc);
-fail_input:
-	eeepc_wmi_platform_exit(eeepc);
-fail_platform:
-	kfree(eeepc);
-	return err;
-}
-
-static int __exit eeepc_wmi_remove(struct platform_device *device)
-{
-	struct eeepc_wmi *eeepc;
-
-	eeepc = platform_get_drvdata(device);
-	wmi_remove_notify_handler(EEEPC_WMI_EVENT_GUID);
-	eeepc_wmi_backlight_exit(eeepc);
-	eeepc_wmi_input_exit(eeepc);
-	eeepc_wmi_led_exit(eeepc);
-	eeepc_wmi_rfkill_exit(eeepc);
-	eeepc_wmi_debugfs_exit(eeepc);
-	eeepc_wmi_platform_exit(eeepc);
-
-	kfree(eeepc);
-	return 0;
-}
-
-/*
- * Platform driver - hibernate/resume callbacks
- */
-static int eeepc_hotk_thaw(struct device *device)
-{
-	struct eeepc_wmi *eeepc = dev_get_drvdata(device);
-
-	if (eeepc->wlan_rfkill) {
-		bool wlan;
-
-		/*
-		 * Work around bios bug - acpi _PTS turns off the wireless led
-		 * during suspend.  Normally it restores it on resume, but
-		 * we should kick it ourselves in case hibernation is aborted.
-		 */
-		wlan = eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_WLAN);
-		eeepc_wmi_set_devstate(EEEPC_WMI_DEVID_WLAN, wlan, NULL);
-	}
-
-	return 0;
-}
-
-static int eeepc_hotk_restore(struct device *device)
-{
-	struct eeepc_wmi *eeepc = dev_get_drvdata(device);
-	int bl;
-
-	/* Refresh both wlan rfkill state and pci hotplug */
-	if (eeepc->wlan_rfkill)
-		eeepc_rfkill_hotplug(eeepc);
-
-	if (eeepc->bluetooth_rfkill) {
-		bl = !eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_BLUETOOTH);
-		rfkill_set_sw_state(eeepc->bluetooth_rfkill, bl);
-	}
-	if (eeepc->wimax_rfkill) {
-		bl = !eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_WIMAX);
-		rfkill_set_sw_state(eeepc->wimax_rfkill, bl);
-	}
-	if (eeepc->wwan3g_rfkill) {
-		bl = !eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_WWAN3G);
-		rfkill_set_sw_state(eeepc->wwan3g_rfkill, bl);
-	}
-
-	return 0;
-}
-
-static const struct dev_pm_ops eeepc_pm_ops = {
-	.thaw = eeepc_hotk_thaw,
-	.restore = eeepc_hotk_restore,
-};
-
-static struct platform_driver platform_driver = {
-	.remove = __exit_p(eeepc_wmi_remove),
-	.driver = {
-		.name = EEEPC_WMI_FILE,
-		.owner = THIS_MODULE,
-		.pm = &eeepc_pm_ops,
-	},
-};
-
-static acpi_status __init eeepc_wmi_parse_device(acpi_handle handle, u32 level,
-						 void *context, void **retval)
-{
-	pr_warning("Found legacy ATKD device (%s)", EEEPC_ACPI_HID);
-	*(bool *)context = true;
-	return AE_CTRL_TERMINATE;
-}
-
-static int __init eeepc_wmi_check_atkd(void)
-{
-	acpi_status status;
-	bool found = false;
-
-	status = acpi_get_devices(EEEPC_ACPI_HID, eeepc_wmi_parse_device,
-				  &found, NULL);
-
-	if (ACPI_FAILURE(status) || !found)
-		return 0;
-	return -1;
-}
-
-static int __init eeepc_wmi_probe(struct platform_device *pdev)
-{
-	if (!wmi_has_guid(EEEPC_WMI_EVENT_GUID) ||
-	    !wmi_has_guid(EEEPC_WMI_MGMT_GUID)) {
-		pr_warning("No known WMI GUID found\n");
-		return -ENODEV;
-	}
-
-	if (eeepc_wmi_check_atkd()) {
-		pr_warning("WMI device present, but legacy ATKD device is also "
-			   "present and enabled.");
-		pr_warning("You probably booted with acpi_osi=\"Linux\" or "
-			   "acpi_osi=\"!Windows 2009\"");
-		pr_warning("Can't load eeepc-wmi, use default acpi_osi "
-			   "(preferred) or eeepc-laptop");
-		return -ENODEV;
-	}
-
-	return eeepc_wmi_add(pdev);
-}
-
-static struct platform_device *platform_device;
-
-static int __init eeepc_wmi_init(void)
-{
-	platform_device = platform_create_bundle(&platform_driver,
-						 eeepc_wmi_probe,
-						 NULL, 0, NULL, 0);
-	if (IS_ERR(platform_device))
-		return PTR_ERR(platform_device);
-	return 0;
-}
-
-static void __exit eeepc_wmi_exit(void)
-{
-	platform_device_unregister(platform_device);
-	platform_driver_unregister(&platform_driver);
-}
-
-module_init(eeepc_wmi_init);
-module_exit(eeepc_wmi_exit);

commit e2d3d44b9a6efe4f3968252d4b680397a9640268
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sun Feb 6 13:30:47 2011 +0100

    eeepc-wmi: add camera keys
    
    These keys are supposed to be handled by any software
    using the camera (like webKam or cheese...). They can
    also be used to actually move the camera when possible.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index eea8c942653b..d3997757e790 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -114,11 +114,18 @@ static const struct key_entry eeepc_wmi_keymap[] = {
 	{ KE_KEY, 0x5c, { KEY_F15 } }, /* Power Gear key */
 	{ KE_KEY, 0x5d, { KEY_WLAN } },
 	{ KE_KEY, 0x6b, { KEY_F13 } }, /* Disable Touchpad */
+	{ KE_KEY, 0x82, { KEY_CAMERA } },
+	{ KE_KEY, 0x83, { KEY_CAMERA_ZOOMIN } },
 	{ KE_KEY, 0x88, { KEY_WLAN } },
 	{ KE_KEY, 0xcc, { KEY_SWITCHVIDEOMODE } },
 	{ KE_KEY, 0xe0, { KEY_PROG1 } }, /* Task Manager */
 	{ KE_KEY, 0xe1, { KEY_F14 } }, /* Change Resolution */
 	{ KE_KEY, 0xe9, { KEY_BRIGHTNESS_ZERO } },
+	{ KE_KEY, 0xeb, { KEY_CAMERA_ZOOMOUT } },
+	{ KE_KEY, 0xec, { KEY_CAMERA_UP } },
+	{ KE_KEY, 0xed, { KEY_CAMERA_DOWN } },
+	{ KE_KEY, 0xee, { KEY_CAMERA_LEFT } },
+	{ KE_KEY, 0xef, { KEY_CAMERA_RIGHT } },
 	{ KE_END, 0},
 };
 

commit 43815941efb1374c2f71eb1fb0a2814b049030eb
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sun Feb 6 13:28:43 2011 +0100

    eeepc-wmi: reorder device ids
    
    Each device seems to be in a "group" (devid >> 16 & 0xFF).
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 16c7f2d62515..eea8c942653b 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -65,21 +65,32 @@ MODULE_ALIAS("wmi:"EEEPC_WMI_MGMT_GUID);
 #define NOTIFY_BRNDOWN_MIN		0x20
 #define NOTIFY_BRNDOWN_MAX		0x2e
 
+/* WMI Methods */
 #define EEEPC_WMI_METHODID_DSTS		0x53544344
 #define EEEPC_WMI_METHODID_DEVS		0x53564544
 #define EEEPC_WMI_METHODID_CFVS		0x53564643
 
+/* Wireless */
 #define EEEPC_WMI_DEVID_WLAN		0x00010011
 #define EEEPC_WMI_DEVID_BLUETOOTH	0x00010013
 #define EEEPC_WMI_DEVID_WIMAX		0x00010017
 #define EEEPC_WMI_DEVID_WWAN3G		0x00010019
+
+/* Backlight and Brightness */
 #define EEEPC_WMI_DEVID_BACKLIGHT	0x00050011
 #define EEEPC_WMI_DEVID_BRIGHTNESS	0x00050012
+
+/* Misc */
 #define EEEPC_WMI_DEVID_CAMERA		0x00060013
+
+/* Storage */
 #define EEEPC_WMI_DEVID_CARDREADER	0x00080013
+
+/* Input */
 #define EEEPC_WMI_DEVID_TOUCHPAD	0x00100011
 #define EEEPC_WMI_DEVID_TOUCHPAD_LED	0x00100012
 
+/* DSTS masks */
 #define EEEPC_WMI_DSTS_STATUS_BIT	0x00000001
 #define EEEPC_WMI_DSTS_PRESENCE_BIT	0x00010000
 #define EEEPC_WMI_DSTS_BRIGHTNESS_MASK	0x000000FF

commit 4615bb661352acb7032796185c8c5573e47dfa1d
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sun Feb 6 13:28:42 2011 +0100

    eeepc-wmi: add touchpad sysfs file
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index a78a90d886da..16c7f2d62515 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -77,6 +77,7 @@ MODULE_ALIAS("wmi:"EEEPC_WMI_MGMT_GUID);
 #define EEEPC_WMI_DEVID_BRIGHTNESS	0x00050012
 #define EEEPC_WMI_DEVID_CAMERA		0x00060013
 #define EEEPC_WMI_DEVID_CARDREADER	0x00080013
+#define EEEPC_WMI_DEVID_TOUCHPAD	0x00100011
 #define EEEPC_WMI_DEVID_TOUCHPAD_LED	0x00100012
 
 #define EEEPC_WMI_DSTS_STATUS_BIT	0x00000001
@@ -1006,6 +1007,7 @@ static ssize_t show_sys_wmi(int devid, char *buf)
 		.store  = store_##_name,				\
 	}
 
+EEEPC_WMI_CREATE_DEVICE_ATTR(touchpad, 0644, EEEPC_WMI_DEVID_TOUCHPAD);
 EEEPC_WMI_CREATE_DEVICE_ATTR(camera, 0644, EEEPC_WMI_DEVID_CAMERA);
 EEEPC_WMI_CREATE_DEVICE_ATTR(cardr, 0644, EEEPC_WMI_DEVID_CARDREADER);
 
@@ -1036,6 +1038,7 @@ static struct attribute *platform_attributes[] = {
 	&dev_attr_cpufv.attr,
 	&dev_attr_camera.attr,
 	&dev_attr_cardr.attr,
+	&dev_attr_touchpad.attr,
 	NULL
 };
 
@@ -1050,6 +1053,8 @@ static mode_t eeepc_sysfs_is_visible(struct kobject *kobj,
 		devid = EEEPC_WMI_DEVID_CAMERA;
 	else if (attr == &dev_attr_cardr.attr)
 		devid = EEEPC_WMI_DEVID_CARDREADER;
+	else if (attr == &dev_attr_touchpad.attr)
+		devid = EEEPC_WMI_DEVID_TOUCHPAD;
 
 	if (devid != -1)
 		supported = eeepc_wmi_get_devstate_simple(devid) != -ENODEV;

commit 77ca5b0197138db1260bbbb95ce3fd015dd10437
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sun Feb 6 13:30:48 2011 +0100

    eeepc-wmi: comments keymap to clarify the meaning of some keys
    
    Found while checking PDF manuals...
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 898476716246..a78a90d886da 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -99,13 +99,13 @@ static const struct key_entry eeepc_wmi_keymap[] = {
 	{ KE_KEY, 0x30, { KEY_VOLUMEUP } },
 	{ KE_KEY, 0x31, { KEY_VOLUMEDOWN } },
 	{ KE_KEY, 0x32, { KEY_MUTE } },
-	{ KE_KEY, 0x5c, { KEY_F15 } },
+	{ KE_KEY, 0x5c, { KEY_F15 } }, /* Power Gear key */
 	{ KE_KEY, 0x5d, { KEY_WLAN } },
 	{ KE_KEY, 0x6b, { KEY_F13 } }, /* Disable Touchpad */
 	{ KE_KEY, 0x88, { KEY_WLAN } },
 	{ KE_KEY, 0xcc, { KEY_SWITCHVIDEOMODE } },
-	{ KE_KEY, 0xe0, { KEY_PROG1 } },
-	{ KE_KEY, 0xe1, { KEY_F14 } },
+	{ KE_KEY, 0xe0, { KEY_PROG1 } }, /* Task Manager */
+	{ KE_KEY, 0xe1, { KEY_F14 } }, /* Change Resolution */
 	{ KE_KEY, 0xe9, { KEY_BRIGHTNESS_ZERO } },
 	{ KE_END, 0},
 };

commit 8571d75d614702e3e0278c92892012dbf7c2e65b
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sun Feb 6 13:28:41 2011 +0100

    eeepc-wmi: real touchpad led device id is 0x001000012
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index bc7133345674..898476716246 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -77,7 +77,7 @@ MODULE_ALIAS("wmi:"EEEPC_WMI_MGMT_GUID);
 #define EEEPC_WMI_DEVID_BRIGHTNESS	0x00050012
 #define EEEPC_WMI_DEVID_CAMERA		0x00060013
 #define EEEPC_WMI_DEVID_CARDREADER	0x00080013
-#define EEEPC_WMI_DEVID_TPDLED		0x00100011
+#define EEEPC_WMI_DEVID_TOUCHPAD_LED	0x00100012
 
 #define EEEPC_WMI_DSTS_STATUS_BIT	0x00000001
 #define EEEPC_WMI_DSTS_PRESENCE_BIT	0x00010000
@@ -303,7 +303,7 @@ static void tpd_led_update(struct work_struct *work)
 	eeepc = container_of(work, struct eeepc_wmi, tpd_led_work);
 
 	ctrl_param = eeepc->tpd_led_wk;
-	eeepc_wmi_set_devstate(EEEPC_WMI_DEVID_TPDLED, ctrl_param, NULL);
+	eeepc_wmi_set_devstate(EEEPC_WMI_DEVID_TOUCHPAD_LED, ctrl_param, NULL);
 }
 
 static void tpd_led_set(struct led_classdev *led_cdev,
@@ -317,9 +317,9 @@ static void tpd_led_set(struct led_classdev *led_cdev,
 	queue_work(eeepc->led_workqueue, &eeepc->tpd_led_work);
 }
 
-static int read_tpd_state(struct eeepc_wmi *eeepc)
+static int read_tpd_led_state(struct eeepc_wmi *eeepc)
 {
-	return eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_TPDLED);
+	return eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_TOUCHPAD_LED);
 }
 
 static enum led_brightness tpd_led_get(struct led_classdev *led_cdev)
@@ -328,14 +328,14 @@ static enum led_brightness tpd_led_get(struct led_classdev *led_cdev)
 
 	eeepc = container_of(led_cdev, struct eeepc_wmi, tpd_led);
 
-	return read_tpd_state(eeepc);
+	return read_tpd_led_state(eeepc);
 }
 
 static int eeepc_wmi_led_init(struct eeepc_wmi *eeepc)
 {
 	int rv;
 
-	if (read_tpd_state(eeepc) < 0)
+	if (read_tpd_led_state(eeepc) < 0)
 		return 0;
 
 	eeepc->led_workqueue = create_singlethread_workqueue("led_workqueue");

commit c14d4b8ea799515cd44134b8eddd8f789f0b6286
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sun Feb 6 13:28:40 2011 +0100

    eeepc-wmi: respect wireless_hotplug setting
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 910eb00fb13e..bc7133345674 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -748,6 +748,9 @@ static int eeepc_wmi_rfkill_init(struct eeepc_wmi *eeepc)
 	if (result && result != -ENODEV)
 		goto exit;
 
+	if (!eeepc->hotplug_wireless)
+		goto exit;
+
 	result = eeepc_setup_pci_hotplug(eeepc);
 	/*
 	 * If we get -EBUSY then something else is handling the PCI hotplug -

commit b71872650fe967eb0a38aa0d7dcbe9c60d160032
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sun Feb 6 13:28:39 2011 +0100

    eeepc-wmi: support backlight power (bl_power) attribute
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 75dd692d31ee..910eb00fb13e 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -73,13 +73,16 @@ MODULE_ALIAS("wmi:"EEEPC_WMI_MGMT_GUID);
 #define EEEPC_WMI_DEVID_BLUETOOTH	0x00010013
 #define EEEPC_WMI_DEVID_WIMAX		0x00010017
 #define EEEPC_WMI_DEVID_WWAN3G		0x00010019
-#define EEEPC_WMI_DEVID_BACKLIGHT	0x00050012
+#define EEEPC_WMI_DEVID_BACKLIGHT	0x00050011
+#define EEEPC_WMI_DEVID_BRIGHTNESS	0x00050012
 #define EEEPC_WMI_DEVID_CAMERA		0x00060013
 #define EEEPC_WMI_DEVID_CARDREADER	0x00080013
 #define EEEPC_WMI_DEVID_TPDLED		0x00100011
 
 #define EEEPC_WMI_DSTS_STATUS_BIT	0x00000001
 #define EEEPC_WMI_DSTS_PRESENCE_BIT	0x00010000
+#define EEEPC_WMI_DSTS_BRIGHTNESS_MASK	0x000000FF
+#define EEEPC_WMI_DSTS_MAX_BRIGTH_MASK	0x0000FF00
 
 static bool hotplug_wireless;
 
@@ -262,7 +265,7 @@ static acpi_status eeepc_wmi_set_devstate(u32 dev_id, u32 ctrl_param,
 }
 
 /* Helper for special devices with magic return codes */
-static int eeepc_wmi_get_devstate_simple(u32 dev_id)
+static int eeepc_wmi_get_devstate_bits(u32 dev_id, u32 mask)
 {
 	u32 retval = 0;
 	acpi_status status;
@@ -275,7 +278,12 @@ static int eeepc_wmi_get_devstate_simple(u32 dev_id)
 	if (!(retval & EEEPC_WMI_DSTS_PRESENCE_BIT))
 		return -ENODEV;
 
-	return retval & EEEPC_WMI_DSTS_STATUS_BIT;
+	return retval & mask;
+}
+
+static int eeepc_wmi_get_devstate_simple(u32 dev_id)
+{
+	return eeepc_wmi_get_devstate_bits(dev_id, EEEPC_WMI_DSTS_STATUS_BIT);
 }
 
 /*
@@ -770,34 +778,53 @@ static int eeepc_wmi_rfkill_init(struct eeepc_wmi *eeepc)
 /*
  * Backlight
  */
+static int read_backlight_power(void)
+{
+	int ret = eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_BACKLIGHT);
+
+	if (ret < 0)
+		return ret;
+
+	return ret ? FB_BLANK_UNBLANK : FB_BLANK_POWERDOWN;
+}
+
 static int read_brightness(struct backlight_device *bd)
 {
 	u32 retval;
 	acpi_status status;
 
-	status = eeepc_wmi_get_devstate(EEEPC_WMI_DEVID_BACKLIGHT, &retval);
+	status = eeepc_wmi_get_devstate(EEEPC_WMI_DEVID_BRIGHTNESS, &retval);
 
 	if (ACPI_FAILURE(status))
-		return -1;
+		return -EIO;
 	else
-		return retval & 0xFF;
+		return retval & EEEPC_WMI_DSTS_BRIGHTNESS_MASK;
 }
 
 static int update_bl_status(struct backlight_device *bd)
 {
-
 	u32 ctrl_param;
 	acpi_status status;
+	int power;
 
 	ctrl_param = bd->props.brightness;
 
-	status = eeepc_wmi_set_devstate(EEEPC_WMI_DEVID_BACKLIGHT,
+	status = eeepc_wmi_set_devstate(EEEPC_WMI_DEVID_BRIGHTNESS,
 					ctrl_param, NULL);
 
 	if (ACPI_FAILURE(status))
-		return -1;
-	else
-		return 0;
+		return -EIO;
+
+	power = read_backlight_power();
+	if (power != -ENODEV && bd->props.power != power) {
+		ctrl_param = !!(bd->props.power == FB_BLANK_UNBLANK);
+		status = eeepc_wmi_set_devstate(EEEPC_WMI_DEVID_BACKLIGHT,
+						ctrl_param, NULL);
+
+		if (ACPI_FAILURE(status))
+			return -EIO;
+	}
+	return 0;
 }
 
 static const struct backlight_ops eeepc_wmi_bl_ops = {
@@ -827,9 +854,29 @@ static int eeepc_wmi_backlight_init(struct eeepc_wmi *eeepc)
 {
 	struct backlight_device *bd;
 	struct backlight_properties props;
+	int max;
+	int power;
+
+	max = eeepc_wmi_get_devstate_bits(EEEPC_WMI_DEVID_BRIGHTNESS,
+					  EEEPC_WMI_DSTS_MAX_BRIGTH_MASK);
+	power = read_backlight_power();
+
+	if (max < 0 && power < 0) {
+		/* Try to keep the original error */
+		if (max == -ENODEV && power == -ENODEV)
+			return -ENODEV;
+		if (max != -ENODEV)
+			return max;
+		else
+			return power;
+	}
+	if (max == -ENODEV)
+		max = 0;
+	if (power == -ENODEV)
+		power = FB_BLANK_UNBLANK;
 
 	memset(&props, 0, sizeof(struct backlight_properties));
-	props.max_brightness = 15;
+	props.max_brightness = max;
 	bd = backlight_device_register(EEEPC_WMI_FILE,
 				       &eeepc->platform_device->dev, eeepc,
 				       &eeepc_wmi_bl_ops, &props);
@@ -841,7 +888,7 @@ static int eeepc_wmi_backlight_init(struct eeepc_wmi *eeepc)
 	eeepc->backlight_device = bd;
 
 	bd->props.brightness = read_brightness(bd);
-	bd->props.power = FB_BLANK_UNBLANK;
+	bd->props.power = power;
 	backlight_update_status(bd);
 
 	return 0;
@@ -1202,7 +1249,7 @@ static int __init eeepc_wmi_add(struct platform_device *pdev)
 
 	if (!acpi_video_backlight_support()) {
 		err = eeepc_wmi_backlight_init(eeepc);
-		if (err)
+		if (err && err != -ENODEV)
 			goto fail_backlight;
 	} else
 		pr_info("Backlight controlled by ACPI video driver\n");

commit 54c799a50f58285f5f6a93d87470cba1847943a3
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sun Feb 6 13:28:38 2011 +0100

    eeepc-wmi: set the right key code for 0xe9
    
    This key should power off the backlight, not the display,
    it is also used in acpi/video.c to do the same thing.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 0db700939433..75dd692d31ee 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -103,7 +103,7 @@ static const struct key_entry eeepc_wmi_keymap[] = {
 	{ KE_KEY, 0xcc, { KEY_SWITCHVIDEOMODE } },
 	{ KE_KEY, 0xe0, { KEY_PROG1 } },
 	{ KE_KEY, 0xe1, { KEY_F14 } },
-	{ KE_KEY, 0xe9, { KEY_DISPLAY_OFF } },
+	{ KE_KEY, 0xe9, { KEY_BRIGHTNESS_ZERO } },
 	{ KE_END, 0},
 };
 

commit 2e9e159d8e18c37d60a7d5040314f579a40f4c63
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sun Feb 6 13:28:37 2011 +0100

    eeepc-wmi: add wimax support
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 83415dd42d0d..0db700939433 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -71,6 +71,7 @@ MODULE_ALIAS("wmi:"EEEPC_WMI_MGMT_GUID);
 
 #define EEEPC_WMI_DEVID_WLAN		0x00010011
 #define EEEPC_WMI_DEVID_BLUETOOTH	0x00010013
+#define EEEPC_WMI_DEVID_WIMAX		0x00010017
 #define EEEPC_WMI_DEVID_WWAN3G		0x00010019
 #define EEEPC_WMI_DEVID_BACKLIGHT	0x00050012
 #define EEEPC_WMI_DEVID_CAMERA		0x00060013
@@ -138,6 +139,7 @@ struct eeepc_wmi {
 
 	struct rfkill *wlan_rfkill;
 	struct rfkill *bluetooth_rfkill;
+	struct rfkill *wimax_rfkill;
 	struct rfkill *wwan3g_rfkill;
 
 	struct hotplug_slot *hotplug_slot;
@@ -691,6 +693,11 @@ static void eeepc_wmi_rfkill_exit(struct eeepc_wmi *eeepc)
 		rfkill_destroy(eeepc->bluetooth_rfkill);
 		eeepc->bluetooth_rfkill = NULL;
 	}
+	if (eeepc->wimax_rfkill) {
+		rfkill_unregister(eeepc->wimax_rfkill);
+		rfkill_destroy(eeepc->wimax_rfkill);
+		eeepc->wimax_rfkill = NULL;
+	}
 	if (eeepc->wwan3g_rfkill) {
 		rfkill_unregister(eeepc->wwan3g_rfkill);
 		rfkill_destroy(eeepc->wwan3g_rfkill);
@@ -719,6 +726,13 @@ static int eeepc_wmi_rfkill_init(struct eeepc_wmi *eeepc)
 	if (result && result != -ENODEV)
 		goto exit;
 
+	result = eeepc_new_rfkill(eeepc, &eeepc->wimax_rfkill,
+				  "eeepc-wimax", RFKILL_TYPE_WIMAX,
+				  EEEPC_WMI_DEVID_WIMAX);
+
+	if (result && result != -ENODEV)
+		goto exit;
+
 	result = eeepc_new_rfkill(eeepc, &eeepc->wwan3g_rfkill,
 				  "eeepc-wwan3g", RFKILL_TYPE_WWAN,
 				  EEEPC_WMI_DEVID_WWAN3G);
@@ -1276,7 +1290,11 @@ static int eeepc_hotk_restore(struct device *device)
 	if (eeepc->bluetooth_rfkill) {
 		bl = !eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_BLUETOOTH);
 		rfkill_set_sw_state(eeepc->bluetooth_rfkill, bl);
-}
+	}
+	if (eeepc->wimax_rfkill) {
+		bl = !eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_WIMAX);
+		rfkill_set_sw_state(eeepc->wimax_rfkill, bl);
+	}
 	if (eeepc->wwan3g_rfkill) {
 		bl = !eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_WWAN3G);
 		rfkill_set_sw_state(eeepc->wwan3g_rfkill, bl);

commit 9e1565bc390123d3c74b940ba3466faf196970ec
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sun Feb 6 13:28:36 2011 +0100

    eeepc-wmi: add camera and card reader support
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 391c32bd703e..83415dd42d0d 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -73,6 +73,8 @@ MODULE_ALIAS("wmi:"EEEPC_WMI_MGMT_GUID);
 #define EEEPC_WMI_DEVID_BLUETOOTH	0x00010013
 #define EEEPC_WMI_DEVID_WWAN3G		0x00010019
 #define EEEPC_WMI_DEVID_BACKLIGHT	0x00050012
+#define EEEPC_WMI_DEVID_CAMERA		0x00060013
+#define EEEPC_WMI_DEVID_CARDREADER	0x00080013
 #define EEEPC_WMI_DEVID_TPDLED		0x00100011
 
 #define EEEPC_WMI_DSTS_STATUS_BIT	0x00000001
@@ -879,6 +881,70 @@ static void eeepc_wmi_notify(u32 value, void *context)
 	kfree(obj);
 }
 
+/*
+ * Sys helpers
+ */
+static int parse_arg(const char *buf, unsigned long count, int *val)
+{
+	if (!count)
+		return 0;
+	if (sscanf(buf, "%i", val) != 1)
+		return -EINVAL;
+	return count;
+}
+
+static ssize_t store_sys_wmi(int devid, const char *buf, size_t count)
+{
+	acpi_status status;
+	u32 retval;
+	int rv, value;
+
+	value = eeepc_wmi_get_devstate_simple(devid);
+	if (value == -ENODEV) /* Check device presence */
+		return value;
+
+	rv = parse_arg(buf, count, &value);
+	status = eeepc_wmi_set_devstate(devid, value, &retval);
+
+	if (ACPI_FAILURE(status))
+		return -EIO;
+	return rv;
+}
+
+static ssize_t show_sys_wmi(int devid, char *buf)
+{
+	int value = eeepc_wmi_get_devstate_simple(devid);
+
+	if (value < 0)
+		return value;
+
+	return sprintf(buf, "%d\n", value);
+}
+
+#define EEEPC_WMI_CREATE_DEVICE_ATTR(_name, _mode, _cm)			\
+	static ssize_t show_##_name(struct device *dev,			\
+				    struct device_attribute *attr,	\
+				    char *buf)				\
+	{								\
+		return show_sys_wmi(_cm, buf);				\
+	}								\
+	static ssize_t store_##_name(struct device *dev,		\
+				     struct device_attribute *attr,	\
+				     const char *buf, size_t count)	\
+	{								\
+		return store_sys_wmi(_cm, buf, count);			\
+	}								\
+	static struct device_attribute dev_attr_##_name = {		\
+		.attr = {						\
+			.name = __stringify(_name),			\
+			.mode = _mode },				\
+		.show   = show_##_name,					\
+		.store  = store_##_name,				\
+	}
+
+EEEPC_WMI_CREATE_DEVICE_ATTR(camera, 0644, EEEPC_WMI_DEVID_CAMERA);
+EEEPC_WMI_CREATE_DEVICE_ATTR(cardr, 0644, EEEPC_WMI_DEVID_CARDREADER);
+
 static ssize_t store_cpufv(struct device *dev, struct device_attribute *attr,
 			   const char *buf, size_t count)
 {
@@ -904,11 +970,32 @@ static DEVICE_ATTR(cpufv, S_IRUGO | S_IWUSR, NULL, store_cpufv);
 
 static struct attribute *platform_attributes[] = {
 	&dev_attr_cpufv.attr,
+	&dev_attr_camera.attr,
+	&dev_attr_cardr.attr,
 	NULL
 };
 
+static mode_t eeepc_sysfs_is_visible(struct kobject *kobj,
+				     struct attribute *attr,
+				     int idx)
+{
+	bool supported = true;
+	int devid = -1;
+
+	if (attr == &dev_attr_camera.attr)
+		devid = EEEPC_WMI_DEVID_CAMERA;
+	else if (attr == &dev_attr_cardr.attr)
+		devid = EEEPC_WMI_DEVID_CARDREADER;
+
+	if (devid != -1)
+		supported = eeepc_wmi_get_devstate_simple(devid) != -ENODEV;
+
+	return supported ? attr->mode : 0;
+}
+
 static struct attribute_group platform_attribute_group = {
-	.attrs = platform_attributes
+	.is_visible	= eeepc_sysfs_is_visible,
+	.attrs		= platform_attributes
 };
 
 static void eeepc_wmi_sysfs_exit(struct platform_device *device)

commit aafa719dcd0cb0c05bb0690c816b13263c8b36e6
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sun Feb 6 13:28:35 2011 +0100

    eeepc-wmi: use the presence bit correctly
    
    I checked some more DSDT, and it seems that I wasn't
    totally right about the meaning of DSTS return value.
    Bit 0 is clearly the status of the device, and I discovered
    that bit 16 is set when the device is present.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index aa9e1d1719da..391c32bd703e 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -75,6 +75,9 @@ MODULE_ALIAS("wmi:"EEEPC_WMI_MGMT_GUID);
 #define EEEPC_WMI_DEVID_BACKLIGHT	0x00050012
 #define EEEPC_WMI_DEVID_TPDLED		0x00100011
 
+#define EEEPC_WMI_DSTS_STATUS_BIT	0x00000001
+#define EEEPC_WMI_DSTS_PRESENCE_BIT	0x00010000
+
 static bool hotplug_wireless;
 
 module_param(hotplug_wireless, bool, 0444);
@@ -265,16 +268,10 @@ static int eeepc_wmi_get_devstate_simple(u32 dev_id)
 	if (ACPI_FAILURE(status))
 		return -EINVAL;
 
-	/* If the device is present, DSTS will always set some bits
-	 * 0x00070000 - 1110000000000000000 - device supported
-	 * 0x00060000 - 1100000000000000000 - not supported
-	 * 0x00020000 - 0100000000000000000 - device supported
-	 * 0x00010000 - 0010000000000000000 - not supported / special mode ?
-	 */
-	if (!retval || retval == 0x00060000)
+	if (!(retval & EEEPC_WMI_DSTS_PRESENCE_BIT))
 		return -ENODEV;
 
-	return retval & 0x1;
+	return retval & EEEPC_WMI_DSTS_STATUS_BIT;
 }
 
 /*

commit 33e0e6fed04dc6067562c65e3e6d551dc0eb11fc
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sun Feb 6 13:28:34 2011 +0100

    eeepc-wmi: reorder defines
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 1fc191bc0a3f..aa9e1d1719da 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -60,20 +60,20 @@ MODULE_LICENSE("GPL");
 MODULE_ALIAS("wmi:"EEEPC_WMI_EVENT_GUID);
 MODULE_ALIAS("wmi:"EEEPC_WMI_MGMT_GUID);
 
-#define NOTIFY_BRNUP_MIN	0x11
-#define NOTIFY_BRNUP_MAX	0x1f
-#define NOTIFY_BRNDOWN_MIN	0x20
-#define NOTIFY_BRNDOWN_MAX	0x2e
+#define NOTIFY_BRNUP_MIN		0x11
+#define NOTIFY_BRNUP_MAX		0x1f
+#define NOTIFY_BRNDOWN_MIN		0x20
+#define NOTIFY_BRNDOWN_MAX		0x2e
 
-#define EEEPC_WMI_METHODID_DEVS	0x53564544
-#define EEEPC_WMI_METHODID_DSTS	0x53544344
-#define EEEPC_WMI_METHODID_CFVS	0x53564643
+#define EEEPC_WMI_METHODID_DSTS		0x53544344
+#define EEEPC_WMI_METHODID_DEVS		0x53564544
+#define EEEPC_WMI_METHODID_CFVS		0x53564643
 
-#define EEEPC_WMI_DEVID_BACKLIGHT	0x00050012
-#define EEEPC_WMI_DEVID_TPDLED		0x00100011
 #define EEEPC_WMI_DEVID_WLAN		0x00010011
 #define EEEPC_WMI_DEVID_BLUETOOTH	0x00010013
 #define EEEPC_WMI_DEVID_WWAN3G		0x00010019
+#define EEEPC_WMI_DEVID_BACKLIGHT	0x00050012
+#define EEEPC_WMI_DEVID_TPDLED		0x00100011
 
 static bool hotplug_wireless;
 

commit a04ce290bffe6b39edf18bac0fdb302503a53a4e
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sun Feb 6 13:28:33 2011 +0100

    eeepc-wmi: switch to platform_create_bundle()
    
    This allow to remove ~30 lines of code.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 583ba78a7f7d..1fc191bc0a3f 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -144,9 +144,6 @@ struct eeepc_wmi {
 	struct eeepc_wmi_debug debug;
 };
 
-/* Only used in eeepc_wmi_init() and eeepc_wmi_exit() */
-static struct platform_device *platform_device;
-
 static int eeepc_wmi_input_init(struct eeepc_wmi *eeepc)
 {
 	int err;
@@ -932,33 +929,12 @@ static int eeepc_wmi_sysfs_init(struct platform_device *device)
  */
 static int __init eeepc_wmi_platform_init(struct eeepc_wmi *eeepc)
 {
-	int err;
-
-	eeepc->platform_device = platform_device_alloc(EEEPC_WMI_FILE, -1);
-	if (!eeepc->platform_device)
-		return -ENOMEM;
-	platform_set_drvdata(eeepc->platform_device, eeepc);
-
-	err = platform_device_add(eeepc->platform_device);
-	if (err)
-		goto fail_platform_device;
-
-	err = eeepc_wmi_sysfs_init(eeepc->platform_device);
-	if (err)
-		goto fail_sysfs;
-	return 0;
-
-fail_sysfs:
-	platform_device_del(eeepc->platform_device);
-fail_platform_device:
-	platform_device_put(eeepc->platform_device);
-	return err;
+	return eeepc_wmi_sysfs_init(eeepc->platform_device);
 }
 
 static void eeepc_wmi_platform_exit(struct eeepc_wmi *eeepc)
 {
 	eeepc_wmi_sysfs_exit(eeepc->platform_device);
-	platform_device_unregister(eeepc->platform_device);
 }
 
 /*
@@ -1094,7 +1070,7 @@ static void eeepc_dmi_check(struct eeepc_wmi *eeepc)
 	}
 }
 
-static struct platform_device * __init eeepc_wmi_add(void)
+static int __init eeepc_wmi_add(struct platform_device *pdev)
 {
 	struct eeepc_wmi *eeepc;
 	acpi_status status;
@@ -1102,15 +1078,14 @@ static struct platform_device * __init eeepc_wmi_add(void)
 
 	eeepc = kzalloc(sizeof(struct eeepc_wmi), GFP_KERNEL);
 	if (!eeepc)
-		return ERR_PTR(-ENOMEM);
+		return -ENOMEM;
+
+	eeepc->platform_device = pdev;
+	platform_set_drvdata(eeepc->platform_device, eeepc);
 
 	eeepc->hotplug_wireless = hotplug_wireless;
 	eeepc_dmi_check(eeepc);
 
-	/*
-	 * Register the platform device first.  It is used as a parent for the
-	 * sub-devices below.
-	 */
 	err = eeepc_wmi_platform_init(eeepc);
 	if (err)
 		goto fail_platform;
@@ -1147,7 +1122,7 @@ static struct platform_device * __init eeepc_wmi_add(void)
 	if (err)
 		goto fail_debugfs;
 
-	return eeepc->platform_device;
+	return 0;
 
 fail_debugfs:
 	wmi_remove_notify_handler(EEEPC_WMI_EVENT_GUID);
@@ -1163,10 +1138,10 @@ static struct platform_device * __init eeepc_wmi_add(void)
 	eeepc_wmi_platform_exit(eeepc);
 fail_platform:
 	kfree(eeepc);
-	return ERR_PTR(err);
+	return err;
 }
 
-static int eeepc_wmi_remove(struct platform_device *device)
+static int __exit eeepc_wmi_remove(struct platform_device *device)
 {
 	struct eeepc_wmi *eeepc;
 
@@ -1232,6 +1207,7 @@ static const struct dev_pm_ops eeepc_pm_ops = {
 };
 
 static struct platform_driver platform_driver = {
+	.remove = __exit_p(eeepc_wmi_remove),
 	.driver = {
 		.name = EEEPC_WMI_FILE,
 		.owner = THIS_MODULE,
@@ -1260,10 +1236,8 @@ static int __init eeepc_wmi_check_atkd(void)
 	return -1;
 }
 
-static int __init eeepc_wmi_init(void)
+static int __init eeepc_wmi_probe(struct platform_device *pdev)
 {
-	int err;
-
 	if (!wmi_has_guid(EEEPC_WMI_EVENT_GUID) ||
 	    !wmi_has_guid(EEEPC_WMI_MGMT_GUID)) {
 		pr_warning("No known WMI GUID found\n");
@@ -1280,29 +1254,24 @@ static int __init eeepc_wmi_init(void)
 		return -ENODEV;
 	}
 
-	platform_device = eeepc_wmi_add();
-	if (IS_ERR(platform_device)) {
-		err = PTR_ERR(platform_device);
-		goto fail_eeepc_wmi;
-	}
+	return eeepc_wmi_add(pdev);
+}
 
-	err = platform_driver_register(&platform_driver);
-	if (err) {
-		pr_warning("Unable to register platform driver\n");
-		goto fail_platform_driver;
-	}
+static struct platform_device *platform_device;
 
+static int __init eeepc_wmi_init(void)
+{
+	platform_device = platform_create_bundle(&platform_driver,
+						 eeepc_wmi_probe,
+						 NULL, 0, NULL, 0);
+	if (IS_ERR(platform_device))
+		return PTR_ERR(platform_device);
 	return 0;
-
-fail_platform_driver:
-	eeepc_wmi_remove(platform_device);
-fail_eeepc_wmi:
-	return err;
 }
 
 static void __exit eeepc_wmi_exit(void)
 {
-	eeepc_wmi_remove(platform_device);
+	platform_device_unregister(platform_device);
 	platform_driver_unregister(&platform_driver);
 }
 

commit 0773d7f9f1c0ad5fb86d23ad7e4ef5bfd2f48b5e
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sun Feb 6 13:28:32 2011 +0100

    eeepc-wmi: add hibernate/resume callbacks
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index de501fb3d1bb..583ba78a7f7d 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -1183,10 +1183,59 @@ static int eeepc_wmi_remove(struct platform_device *device)
 	return 0;
 }
 
+/*
+ * Platform driver - hibernate/resume callbacks
+ */
+static int eeepc_hotk_thaw(struct device *device)
+{
+	struct eeepc_wmi *eeepc = dev_get_drvdata(device);
+
+	if (eeepc->wlan_rfkill) {
+		bool wlan;
+
+		/*
+		 * Work around bios bug - acpi _PTS turns off the wireless led
+		 * during suspend.  Normally it restores it on resume, but
+		 * we should kick it ourselves in case hibernation is aborted.
+		 */
+		wlan = eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_WLAN);
+		eeepc_wmi_set_devstate(EEEPC_WMI_DEVID_WLAN, wlan, NULL);
+	}
+
+	return 0;
+}
+
+static int eeepc_hotk_restore(struct device *device)
+{
+	struct eeepc_wmi *eeepc = dev_get_drvdata(device);
+	int bl;
+
+	/* Refresh both wlan rfkill state and pci hotplug */
+	if (eeepc->wlan_rfkill)
+		eeepc_rfkill_hotplug(eeepc);
+
+	if (eeepc->bluetooth_rfkill) {
+		bl = !eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_BLUETOOTH);
+		rfkill_set_sw_state(eeepc->bluetooth_rfkill, bl);
+}
+	if (eeepc->wwan3g_rfkill) {
+		bl = !eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_WWAN3G);
+		rfkill_set_sw_state(eeepc->wwan3g_rfkill, bl);
+	}
+
+	return 0;
+}
+
+static const struct dev_pm_ops eeepc_pm_ops = {
+	.thaw = eeepc_hotk_thaw,
+	.restore = eeepc_hotk_restore,
+};
+
 static struct platform_driver platform_driver = {
 	.driver = {
 		.name = EEEPC_WMI_FILE,
 		.owner = THIS_MODULE,
+		.pm = &eeepc_pm_ops,
 	},
 };
 

commit 5c95638d115f9c6661fff254b3beb14b19f88e41
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sun Feb 6 13:28:31 2011 +0100

    eeepc-wmi: add an helper using simple return codes
    
    eeepc_wmi_get_devstate returns an acpi_status, so each
    call need extra logic to handle the return code. This
    patch add a simple getter, returning a boolean (or a
    negative error code).
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index d8234582b541..de501fb3d1bb 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -257,6 +257,29 @@ static acpi_status eeepc_wmi_set_devstate(u32 dev_id, u32 ctrl_param,
 	return status;
 }
 
+/* Helper for special devices with magic return codes */
+static int eeepc_wmi_get_devstate_simple(u32 dev_id)
+{
+	u32 retval = 0;
+	acpi_status status;
+
+	status = eeepc_wmi_get_devstate(dev_id, &retval);
+
+	if (ACPI_FAILURE(status))
+		return -EINVAL;
+
+	/* If the device is present, DSTS will always set some bits
+	 * 0x00070000 - 1110000000000000000 - device supported
+	 * 0x00060000 - 1100000000000000000 - not supported
+	 * 0x00020000 - 0100000000000000000 - device supported
+	 * 0x00010000 - 0010000000000000000 - not supported / special mode ?
+	 */
+	if (!retval || retval == 0x00060000)
+		return -ENODEV;
+
+	return retval & 0x1;
+}
+
 /*
  * LEDs
  */
@@ -290,23 +313,7 @@ static void tpd_led_set(struct led_classdev *led_cdev,
 
 static int read_tpd_state(struct eeepc_wmi *eeepc)
 {
-	u32 retval;
-	acpi_status status;
-
-	status = eeepc_wmi_get_devstate(EEEPC_WMI_DEVID_TPDLED, &retval);
-
-	if (ACPI_FAILURE(status))
-		return -1;
-	else if (!retval || retval == 0x00060000)
-		/*
-		 * if touchpad led is present, DSTS will set some bits,
-		 * usually 0x00020000.
-		 * 0x00060000 means that the device is not supported
-		 */
-		return -ENODEV;
-	else
-		/* Status is stored in the first bit */
-		return retval & 0x1;
+	return eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_TPDLED);
 }
 
 static enum led_brightness tpd_led_get(struct led_classdev *led_cdev)
@@ -358,15 +365,11 @@ static void eeepc_wmi_led_exit(struct eeepc_wmi *eeepc)
  */
 static bool eeepc_wlan_rfkill_blocked(struct eeepc_wmi *eeepc)
 {
-	u32 retval;
-	acpi_status status;
-
-	status = eeepc_wmi_get_devstate(EEEPC_WMI_DEVID_WLAN, &retval);
+	int result = eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_WLAN);
 
-	if (ACPI_FAILURE(status))
+	if (result < 0)
 		return false;
-
-	return !(retval & 0x1);
+	return !result;
 }
 
 static void eeepc_rfkill_hotplug(struct eeepc_wmi *eeepc)
@@ -494,19 +497,12 @@ static void eeepc_unregister_rfkill_notifier(struct eeepc_wmi *eeepc,
 static int eeepc_get_adapter_status(struct hotplug_slot *hotplug_slot,
 				    u8 *value)
 {
-	u32 retval;
-	acpi_status status;
-
-	status = eeepc_wmi_get_devstate(EEEPC_WMI_DEVID_WLAN, &retval);
-
-	if (ACPI_FAILURE(status))
-		return -EIO;
+	int result = eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_WLAN);
 
-	if (!retval || retval == 0x00060000)
-		return -ENODEV;
-	else
-		*value = (retval & 0x1);
+	if (result < 0)
+		return result;
 
+	*value = !!result;
 	return 0;
 }
 
@@ -601,15 +597,14 @@ static int eeepc_rfkill_set(void *data, bool blocked)
 static void eeepc_rfkill_query(struct rfkill *rfkill, void *data)
 {
 	int dev_id = (unsigned long)data;
-	u32 retval;
-	acpi_status status;
+	int result;
 
-	status = eeepc_wmi_get_devstate(dev_id, &retval);
+	result = eeepc_wmi_get_devstate_simple(dev_id);
 
-	if (ACPI_FAILURE(status))
+	if (result < 0)
 		return ;
 
-	rfkill_set_sw_state(rfkill, !(retval & 0x1));
+	rfkill_set_sw_state(rfkill, !result);
 }
 
 static int eeepc_rfkill_wlan_set(void *data, bool blocked)
@@ -650,23 +645,10 @@ static int eeepc_new_rfkill(struct eeepc_wmi *eeepc,
 			    const char *name,
 			    enum rfkill_type type, int dev_id)
 {
-	int result;
-	u32 retval;
-	acpi_status status;
-
-	status = eeepc_wmi_get_devstate(dev_id, &retval);
+	int result = eeepc_wmi_get_devstate_simple(dev_id);
 
-	if (ACPI_FAILURE(status))
-		return -1;
-
-	/* If the device is present, DSTS will always set some bits
-	 * 0x00070000 - 1110000000000000000 - device supported
-	 * 0x00060000 - 1100000000000000000 - not supported
-	 * 0x00020000 - 0100000000000000000 - device supported
-	 * 0x00010000 - 0010000000000000000 - not supported / special mode ?
-	 */
-	if (!retval || retval == 0x00060000)
-		return -ENODEV;
+	if (result < 0)
+		return result;
 
 	if (dev_id == EEEPC_WMI_DEVID_WLAN && eeepc->hotplug_wireless)
 		*rfkill = rfkill_alloc(name, &eeepc->platform_device->dev, type,
@@ -678,7 +660,7 @@ static int eeepc_new_rfkill(struct eeepc_wmi *eeepc,
 	if (!*rfkill)
 		return -EINVAL;
 
-	rfkill_init_sw_state(*rfkill, !(retval & 0x1));
+	rfkill_init_sw_state(*rfkill, !result);
 	result = rfkill_register(*rfkill);
 	if (result) {
 		rfkill_destroy(*rfkill);

commit 7898cf1a3665d22c4d16308f73e981c6464be81b
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sun Feb 6 13:28:30 2011 +0100

    eeepc-wmi: return proper error code in eeepc_rfkill_set()
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index eb4c0ce88ac1..d8234582b541 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -588,8 +588,14 @@ static int eeepc_rfkill_set(void *data, bool blocked)
 {
 	int dev_id = (unsigned long)data;
 	u32 ctrl_param = !blocked;
+	acpi_status status;
+
+	status = eeepc_wmi_set_devstate(dev_id, ctrl_param, NULL);
+
+	if (ACPI_FAILURE(status))
+		return -EIO;
 
-	return eeepc_wmi_set_devstate(dev_id, ctrl_param, NULL);
+	return 0;
 }
 
 static void eeepc_rfkill_query(struct rfkill *rfkill, void *data)

commit 279f8f95493c9aaa0a85520c863ccba87c4bf930
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sun Feb 6 13:28:29 2011 +0100

    eeepc-wmi: serialize access to wmi method
    
    \AMW0.WMBC, which is the main method that we use,
    is not reentrant. When wireless hotpluging is enabled,
    toggling the status of the wireless device using WMBC will
    trigger a notification and the notification handler need to
    call WMBC again to get the new status of the device, this
    will trigger the following error:
    
    ACPI Error (dswload-0802): [_T_0] Namespace lookup failure, AE_ALREADY_EXISTS
    ACPI Exception: AE_ALREADY_EXISTS, During name lookup/catalog (20100428/psloop-231)
    ACPI Error (psparse-0537): Method parse/execution failed [\AMW0.WMBC] (Node f7023b88), AE_ALREADY_EXISTS
    ACPI: Marking method WMBC as Serialized because of AE_ALREADY_EXISTS error
    
    Since there is currently no way to tell the acpi subsystem to mark
    a method as serialized, we do it in eeepc-wmi.
    
    Of course, we could let the first call fail, and then it would work,
    but it doesn't seems really clean, and it will make the first
    WMBC call return a random value.
    
    This patch was tested on EeePc 1000H with a RaLink RT2860
    wireless card using the rt2800pci driver. rt2860sta driver
    seems to deadlock when we remove the pci device...
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 01bc2b3da98a..eb4c0ce88ac1 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -137,6 +137,9 @@ struct eeepc_wmi {
 
 	struct hotplug_slot *hotplug_slot;
 	struct mutex hotplug_lock;
+	struct mutex wmi_lock;
+	struct workqueue_struct *hotplug_workqueue;
+	struct work_struct hotplug_work;
 
 	struct eeepc_wmi_debug debug;
 };
@@ -370,15 +373,19 @@ static void eeepc_rfkill_hotplug(struct eeepc_wmi *eeepc)
 {
 	struct pci_dev *dev;
 	struct pci_bus *bus;
-	bool blocked = eeepc_wlan_rfkill_blocked(eeepc);
+	bool blocked;
 	bool absent;
 	u32 l;
 
-	if (eeepc->wlan_rfkill)
-		rfkill_set_sw_state(eeepc->wlan_rfkill, blocked);
+	mutex_lock(&eeepc->wmi_lock);
+	blocked = eeepc_wlan_rfkill_blocked(eeepc);
+	mutex_unlock(&eeepc->wmi_lock);
 
 	mutex_lock(&eeepc->hotplug_lock);
 
+	if (eeepc->wlan_rfkill)
+		rfkill_set_sw_state(eeepc->wlan_rfkill, blocked);
+
 	if (eeepc->hotplug_slot) {
 		bus = pci_find_bus(0, 1);
 		if (!bus) {
@@ -435,7 +442,14 @@ static void eeepc_rfkill_notify(acpi_handle handle, u32 event, void *data)
 	if (event != ACPI_NOTIFY_BUS_CHECK)
 		return;
 
-	eeepc_rfkill_hotplug(eeepc);
+	/*
+	 * We can't call directly eeepc_rfkill_hotplug because most
+	 * of the time WMBC is still being executed and not reetrant.
+	 * There is currently no way to tell ACPICA that  we want this
+	 * method to be serialized, we schedule a eeepc_rfkill_hotplug
+	 * call later, in a safer context.
+	 */
+	queue_work(eeepc->hotplug_workqueue, &eeepc->hotplug_work);
 }
 
 static int eeepc_register_rfkill_notifier(struct eeepc_wmi *eeepc,
@@ -508,6 +522,14 @@ static struct hotplug_slot_ops eeepc_hotplug_slot_ops = {
 	.get_power_status = eeepc_get_adapter_status,
 };
 
+static void eeepc_hotplug_work(struct work_struct *work)
+{
+	struct eeepc_wmi *eeepc;
+
+	eeepc = container_of(work, struct eeepc_wmi, hotplug_work);
+	eeepc_rfkill_hotplug(eeepc);
+}
+
 static int eeepc_setup_pci_hotplug(struct eeepc_wmi *eeepc)
 {
 	int ret = -ENOMEM;
@@ -518,6 +540,13 @@ static int eeepc_setup_pci_hotplug(struct eeepc_wmi *eeepc)
 		return -ENODEV;
 	}
 
+	eeepc->hotplug_workqueue =
+		create_singlethread_workqueue("hotplug_workqueue");
+	if (!eeepc->hotplug_workqueue)
+		goto error_workqueue;
+
+	INIT_WORK(&eeepc->hotplug_work, eeepc_hotplug_work);
+
 	eeepc->hotplug_slot = kzalloc(sizeof(struct hotplug_slot), GFP_KERNEL);
 	if (!eeepc->hotplug_slot)
 		goto error_slot;
@@ -547,6 +576,8 @@ static int eeepc_setup_pci_hotplug(struct eeepc_wmi *eeepc)
 	kfree(eeepc->hotplug_slot);
 	eeepc->hotplug_slot = NULL;
 error_slot:
+	destroy_workqueue(eeepc->hotplug_workqueue);
+error_workqueue:
 	return ret;
 }
 
@@ -575,6 +606,34 @@ static void eeepc_rfkill_query(struct rfkill *rfkill, void *data)
 	rfkill_set_sw_state(rfkill, !(retval & 0x1));
 }
 
+static int eeepc_rfkill_wlan_set(void *data, bool blocked)
+{
+	struct eeepc_wmi *eeepc = data;
+	int ret;
+
+	/*
+	 * This handler is enabled only if hotplug is enabled.
+	 * In this case, the eeepc_wmi_set_devstate() will
+	 * trigger a wmi notification and we need to wait
+	 * this call to finish before being able to call
+	 * any wmi method
+	 */
+	mutex_lock(&eeepc->wmi_lock);
+	ret = eeepc_rfkill_set((void *)(long)EEEPC_WMI_DEVID_WLAN, blocked);
+	mutex_unlock(&eeepc->wmi_lock);
+	return ret;
+}
+
+static void eeepc_rfkill_wlan_query(struct rfkill *rfkill, void *data)
+{
+	eeepc_rfkill_query(rfkill, (void *)(long)EEEPC_WMI_DEVID_WLAN);
+}
+
+static const struct rfkill_ops eeepc_rfkill_wlan_ops = {
+	.set_block = eeepc_rfkill_wlan_set,
+	.query = eeepc_rfkill_wlan_query,
+};
+
 static const struct rfkill_ops eeepc_rfkill_ops = {
 	.set_block = eeepc_rfkill_set,
 	.query = eeepc_rfkill_query,
@@ -603,8 +662,12 @@ static int eeepc_new_rfkill(struct eeepc_wmi *eeepc,
 	if (!retval || retval == 0x00060000)
 		return -ENODEV;
 
-	*rfkill = rfkill_alloc(name, &eeepc->platform_device->dev, type,
-			       &eeepc_rfkill_ops, (void *)(long)dev_id);
+	if (dev_id == EEEPC_WMI_DEVID_WLAN && eeepc->hotplug_wireless)
+		*rfkill = rfkill_alloc(name, &eeepc->platform_device->dev, type,
+				       &eeepc_rfkill_wlan_ops, eeepc);
+	else
+		*rfkill = rfkill_alloc(name, &eeepc->platform_device->dev, type,
+				       &eeepc_rfkill_ops, (void *)(long)dev_id);
 
 	if (!*rfkill)
 		return -EINVAL;
@@ -636,6 +699,8 @@ static void eeepc_wmi_rfkill_exit(struct eeepc_wmi *eeepc)
 	eeepc_rfkill_hotplug(eeepc);
 	if (eeepc->hotplug_slot)
 		pci_hp_deregister(eeepc->hotplug_slot);
+	if (eeepc->hotplug_workqueue)
+		destroy_workqueue(eeepc->hotplug_workqueue);
 
 	if (eeepc->bluetooth_rfkill) {
 		rfkill_unregister(eeepc->bluetooth_rfkill);
@@ -654,6 +719,7 @@ static int eeepc_wmi_rfkill_init(struct eeepc_wmi *eeepc)
 	int result = 0;
 
 	mutex_init(&eeepc->hotplug_lock);
+	mutex_init(&eeepc->wmi_lock);
 
 	result = eeepc_new_rfkill(eeepc, &eeepc->wlan_rfkill,
 				  "eeepc-wlan", RFKILL_TYPE_WLAN,

commit afa7c886578ce264d9b66d4bcb1fea51fac47925
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sun Feb 6 13:28:28 2011 +0100

    eeepc-wmi: add hotplug code for Eeepc 1000H
    
    Implement wireless like hotplug handling (code stolen from eeepc-laptop).
    
    Reminder: on some models rfkill is implemented by logically unplugging the
    wireless card from the PCI bus. Despite sending ACPI notifications, this does
    not appear to be implemented using standard ACPI hotplug - nor does the
    firmware provide the _OSC method required to support native PCIe hotplug.
    The only sensible choice appears to be to handle the hotplugging directly in
    the platform driver.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 0d8217d14780..01bc2b3da98a 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -37,9 +37,12 @@
 #include <linux/backlight.h>
 #include <linux/leds.h>
 #include <linux/rfkill.h>
+#include <linux/pci.h>
+#include <linux/pci_hotplug.h>
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
 #include <linux/platform_device.h>
+#include <linux/dmi.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
@@ -72,6 +75,14 @@ MODULE_ALIAS("wmi:"EEEPC_WMI_MGMT_GUID);
 #define EEEPC_WMI_DEVID_BLUETOOTH	0x00010013
 #define EEEPC_WMI_DEVID_WWAN3G		0x00010019
 
+static bool hotplug_wireless;
+
+module_param(hotplug_wireless, bool, 0444);
+MODULE_PARM_DESC(hotplug_wireless,
+		 "Enable hotplug for wireless device. "
+		 "If your laptop needs that, please report to "
+		 "acpi4asus-user@lists.sourceforge.net.");
+
 static const struct key_entry eeepc_wmi_keymap[] = {
 	/* Sleep already handled via generic ACPI code */
 	{ KE_IGNORE, NOTIFY_BRNDOWN_MIN, { KEY_BRIGHTNESSDOWN } },
@@ -109,6 +120,8 @@ struct eeepc_wmi_debug {
 };
 
 struct eeepc_wmi {
+	bool hotplug_wireless;
+
 	struct input_dev *inputdev;
 	struct backlight_device *backlight_device;
 	struct platform_device *platform_device;
@@ -122,6 +135,9 @@ struct eeepc_wmi {
 	struct rfkill *bluetooth_rfkill;
 	struct rfkill *wwan3g_rfkill;
 
+	struct hotplug_slot *hotplug_slot;
+	struct mutex hotplug_lock;
+
 	struct eeepc_wmi_debug debug;
 };
 
@@ -177,7 +193,8 @@ static acpi_status eeepc_wmi_get_devstate(u32 dev_id, u32 *retval)
 	u32 tmp;
 
 	status = wmi_evaluate_method(EEEPC_WMI_MGMT_GUID,
-			1, EEEPC_WMI_METHODID_DSTS, &input, &output);
+				     1, EEEPC_WMI_METHODID_DSTS,
+				     &input, &output);
 
 	if (ACPI_FAILURE(status))
 		return status;
@@ -333,6 +350,206 @@ static void eeepc_wmi_led_exit(struct eeepc_wmi *eeepc)
 		destroy_workqueue(eeepc->led_workqueue);
 }
 
+/*
+ * PCI hotplug (for wlan rfkill)
+ */
+static bool eeepc_wlan_rfkill_blocked(struct eeepc_wmi *eeepc)
+{
+	u32 retval;
+	acpi_status status;
+
+	status = eeepc_wmi_get_devstate(EEEPC_WMI_DEVID_WLAN, &retval);
+
+	if (ACPI_FAILURE(status))
+		return false;
+
+	return !(retval & 0x1);
+}
+
+static void eeepc_rfkill_hotplug(struct eeepc_wmi *eeepc)
+{
+	struct pci_dev *dev;
+	struct pci_bus *bus;
+	bool blocked = eeepc_wlan_rfkill_blocked(eeepc);
+	bool absent;
+	u32 l;
+
+	if (eeepc->wlan_rfkill)
+		rfkill_set_sw_state(eeepc->wlan_rfkill, blocked);
+
+	mutex_lock(&eeepc->hotplug_lock);
+
+	if (eeepc->hotplug_slot) {
+		bus = pci_find_bus(0, 1);
+		if (!bus) {
+			pr_warning("Unable to find PCI bus 1?\n");
+			goto out_unlock;
+		}
+
+		if (pci_bus_read_config_dword(bus, 0, PCI_VENDOR_ID, &l)) {
+			pr_err("Unable to read PCI config space?\n");
+			goto out_unlock;
+		}
+		absent = (l == 0xffffffff);
+
+		if (blocked != absent) {
+			pr_warning("BIOS says wireless lan is %s, "
+					"but the pci device is %s\n",
+				blocked ? "blocked" : "unblocked",
+				absent ? "absent" : "present");
+			pr_warning("skipped wireless hotplug as probably "
+					"inappropriate for this model\n");
+			goto out_unlock;
+		}
+
+		if (!blocked) {
+			dev = pci_get_slot(bus, 0);
+			if (dev) {
+				/* Device already present */
+				pci_dev_put(dev);
+				goto out_unlock;
+			}
+			dev = pci_scan_single_device(bus, 0);
+			if (dev) {
+				pci_bus_assign_resources(bus);
+				if (pci_bus_add_device(dev))
+					pr_err("Unable to hotplug wifi\n");
+			}
+		} else {
+			dev = pci_get_slot(bus, 0);
+			if (dev) {
+				pci_remove_bus_device(dev);
+				pci_dev_put(dev);
+			}
+		}
+	}
+
+out_unlock:
+	mutex_unlock(&eeepc->hotplug_lock);
+}
+
+static void eeepc_rfkill_notify(acpi_handle handle, u32 event, void *data)
+{
+	struct eeepc_wmi *eeepc = data;
+
+	if (event != ACPI_NOTIFY_BUS_CHECK)
+		return;
+
+	eeepc_rfkill_hotplug(eeepc);
+}
+
+static int eeepc_register_rfkill_notifier(struct eeepc_wmi *eeepc,
+					  char *node)
+{
+	acpi_status status;
+	acpi_handle handle;
+
+	status = acpi_get_handle(NULL, node, &handle);
+
+	if (ACPI_SUCCESS(status)) {
+		status = acpi_install_notify_handler(handle,
+						     ACPI_SYSTEM_NOTIFY,
+						     eeepc_rfkill_notify,
+						     eeepc);
+		if (ACPI_FAILURE(status))
+			pr_warning("Failed to register notify on %s\n", node);
+	} else
+		return -ENODEV;
+
+	return 0;
+}
+
+static void eeepc_unregister_rfkill_notifier(struct eeepc_wmi *eeepc,
+					     char *node)
+{
+	acpi_status status = AE_OK;
+	acpi_handle handle;
+
+	status = acpi_get_handle(NULL, node, &handle);
+
+	if (ACPI_SUCCESS(status)) {
+		status = acpi_remove_notify_handler(handle,
+						     ACPI_SYSTEM_NOTIFY,
+						     eeepc_rfkill_notify);
+		if (ACPI_FAILURE(status))
+			pr_err("Error removing rfkill notify handler %s\n",
+				node);
+	}
+}
+
+static int eeepc_get_adapter_status(struct hotplug_slot *hotplug_slot,
+				    u8 *value)
+{
+	u32 retval;
+	acpi_status status;
+
+	status = eeepc_wmi_get_devstate(EEEPC_WMI_DEVID_WLAN, &retval);
+
+	if (ACPI_FAILURE(status))
+		return -EIO;
+
+	if (!retval || retval == 0x00060000)
+		return -ENODEV;
+	else
+		*value = (retval & 0x1);
+
+	return 0;
+}
+
+static void eeepc_cleanup_pci_hotplug(struct hotplug_slot *hotplug_slot)
+{
+	kfree(hotplug_slot->info);
+	kfree(hotplug_slot);
+}
+
+static struct hotplug_slot_ops eeepc_hotplug_slot_ops = {
+	.owner = THIS_MODULE,
+	.get_adapter_status = eeepc_get_adapter_status,
+	.get_power_status = eeepc_get_adapter_status,
+};
+
+static int eeepc_setup_pci_hotplug(struct eeepc_wmi *eeepc)
+{
+	int ret = -ENOMEM;
+	struct pci_bus *bus = pci_find_bus(0, 1);
+
+	if (!bus) {
+		pr_err("Unable to find wifi PCI bus\n");
+		return -ENODEV;
+	}
+
+	eeepc->hotplug_slot = kzalloc(sizeof(struct hotplug_slot), GFP_KERNEL);
+	if (!eeepc->hotplug_slot)
+		goto error_slot;
+
+	eeepc->hotplug_slot->info = kzalloc(sizeof(struct hotplug_slot_info),
+					    GFP_KERNEL);
+	if (!eeepc->hotplug_slot->info)
+		goto error_info;
+
+	eeepc->hotplug_slot->private = eeepc;
+	eeepc->hotplug_slot->release = &eeepc_cleanup_pci_hotplug;
+	eeepc->hotplug_slot->ops = &eeepc_hotplug_slot_ops;
+	eeepc_get_adapter_status(eeepc->hotplug_slot,
+				 &eeepc->hotplug_slot->info->adapter_status);
+
+	ret = pci_hp_register(eeepc->hotplug_slot, bus, 0, "eeepc-wifi");
+	if (ret) {
+		pr_err("Unable to register hotplug slot - %d\n", ret);
+		goto error_register;
+	}
+
+	return 0;
+
+error_register:
+	kfree(eeepc->hotplug_slot->info);
+error_info:
+	kfree(eeepc->hotplug_slot);
+	eeepc->hotplug_slot = NULL;
+error_slot:
+	return ret;
+}
+
 /*
  * Rfkill devices
  */
@@ -404,11 +621,22 @@ static int eeepc_new_rfkill(struct eeepc_wmi *eeepc,
 
 static void eeepc_wmi_rfkill_exit(struct eeepc_wmi *eeepc)
 {
+	eeepc_unregister_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P5");
+	eeepc_unregister_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P6");
+	eeepc_unregister_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P7");
 	if (eeepc->wlan_rfkill) {
 		rfkill_unregister(eeepc->wlan_rfkill);
 		rfkill_destroy(eeepc->wlan_rfkill);
 		eeepc->wlan_rfkill = NULL;
 	}
+	/*
+	 * Refresh pci hotplug in case the rfkill state was changed after
+	 * eeepc_unregister_rfkill_notifier()
+	 */
+	eeepc_rfkill_hotplug(eeepc);
+	if (eeepc->hotplug_slot)
+		pci_hp_deregister(eeepc->hotplug_slot);
+
 	if (eeepc->bluetooth_rfkill) {
 		rfkill_unregister(eeepc->bluetooth_rfkill);
 		rfkill_destroy(eeepc->bluetooth_rfkill);
@@ -425,6 +653,8 @@ static int eeepc_wmi_rfkill_init(struct eeepc_wmi *eeepc)
 {
 	int result = 0;
 
+	mutex_init(&eeepc->hotplug_lock);
+
 	result = eeepc_new_rfkill(eeepc, &eeepc->wlan_rfkill,
 				  "eeepc-wlan", RFKILL_TYPE_WLAN,
 				  EEEPC_WMI_DEVID_WLAN);
@@ -446,6 +676,23 @@ static int eeepc_wmi_rfkill_init(struct eeepc_wmi *eeepc)
 	if (result && result != -ENODEV)
 		goto exit;
 
+	result = eeepc_setup_pci_hotplug(eeepc);
+	/*
+	 * If we get -EBUSY then something else is handling the PCI hotplug -
+	 * don't fail in this case
+	 */
+	if (result == -EBUSY)
+		result = 0;
+
+	eeepc_register_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P5");
+	eeepc_register_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P6");
+	eeepc_register_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P7");
+	/*
+	 * Refresh pci hotplug in case the rfkill state was changed during
+	 * setup.
+	 */
+	eeepc_rfkill_hotplug(eeepc);
+
 exit:
 	if (result && result != -ENODEV)
 		eeepc_wmi_rfkill_exit(eeepc);
@@ -771,6 +1018,28 @@ static int eeepc_wmi_debugfs_init(struct eeepc_wmi *eeepc)
 /*
  * WMI Driver
  */
+static void eeepc_dmi_check(struct eeepc_wmi *eeepc)
+{
+	const char *model;
+
+	model = dmi_get_system_info(DMI_PRODUCT_NAME);
+	if (!model)
+		return;
+
+	/*
+	 * Whitelist for wlan hotplug
+	 *
+	 * Eeepc 1000H needs the current hotplug code to handle
+	 * Fn+F2 correctly. We may add other Eeepc here later, but
+	 * it seems that most of the laptops supported by eeepc-wmi
+	 * don't need to be on this list
+	 */
+	if (strcmp(model, "1000H") == 0) {
+		eeepc->hotplug_wireless = true;
+		pr_info("wlan hotplug enabled\n");
+	}
+}
+
 static struct platform_device * __init eeepc_wmi_add(void)
 {
 	struct eeepc_wmi *eeepc;
@@ -781,6 +1050,9 @@ static struct platform_device * __init eeepc_wmi_add(void)
 	if (!eeepc)
 		return ERR_PTR(-ENOMEM);
 
+	eeepc->hotplug_wireless = hotplug_wireless;
+	eeepc_dmi_check(eeepc);
+
 	/*
 	 * Register the platform device first.  It is used as a parent for the
 	 * sub-devices below.

commit bc40cce201b69ab25178565e298d9482a5876306
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sun Feb 6 13:28:27 2011 +0100

    eeepc-wmi: add wlan key found on 1015P
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 350b7bcfc326..0d8217d14780 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -82,6 +82,7 @@ static const struct key_entry eeepc_wmi_keymap[] = {
 	{ KE_KEY, 0x5c, { KEY_F15 } },
 	{ KE_KEY, 0x5d, { KEY_WLAN } },
 	{ KE_KEY, 0x6b, { KEY_F13 } }, /* Disable Touchpad */
+	{ KE_KEY, 0x88, { KEY_WLAN } },
 	{ KE_KEY, 0xcc, { KEY_SWITCHVIDEOMODE } },
 	{ KE_KEY, 0xe0, { KEY_PROG1 } },
 	{ KE_KEY, 0xe1, { KEY_F14 } },

commit 5628e5aa12d6147f4174ed7c42da146ef57fd125
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sun Feb 6 13:28:26 2011 +0100

    eeepc-wmi: reorder keymap
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 4d38f98aa976..350b7bcfc326 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -74,18 +74,18 @@ MODULE_ALIAS("wmi:"EEEPC_WMI_MGMT_GUID);
 
 static const struct key_entry eeepc_wmi_keymap[] = {
 	/* Sleep already handled via generic ACPI code */
-	{ KE_KEY, 0x5d, { KEY_WLAN } },
-	{ KE_KEY, 0x32, { KEY_MUTE } },
-	{ KE_KEY, 0x31, { KEY_VOLUMEDOWN } },
-	{ KE_KEY, 0x30, { KEY_VOLUMEUP } },
 	{ KE_IGNORE, NOTIFY_BRNDOWN_MIN, { KEY_BRIGHTNESSDOWN } },
 	{ KE_IGNORE, NOTIFY_BRNUP_MIN, { KEY_BRIGHTNESSUP } },
-	{ KE_KEY, 0xcc, { KEY_SWITCHVIDEOMODE } },
+	{ KE_KEY, 0x30, { KEY_VOLUMEUP } },
+	{ KE_KEY, 0x31, { KEY_VOLUMEDOWN } },
+	{ KE_KEY, 0x32, { KEY_MUTE } },
+	{ KE_KEY, 0x5c, { KEY_F15 } },
+	{ KE_KEY, 0x5d, { KEY_WLAN } },
 	{ KE_KEY, 0x6b, { KEY_F13 } }, /* Disable Touchpad */
+	{ KE_KEY, 0xcc, { KEY_SWITCHVIDEOMODE } },
+	{ KE_KEY, 0xe0, { KEY_PROG1 } },
 	{ KE_KEY, 0xe1, { KEY_F14 } },
 	{ KE_KEY, 0xe9, { KEY_DISPLAY_OFF } },
-	{ KE_KEY, 0xe0, { KEY_PROG1 } },
-	{ KE_KEY, 0x5c, { KEY_F15 } },
 	{ KE_END, 0},
 };
 

commit d358cb55a4cc83c37fbaebc0e4401a573777c6ac
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Mon Nov 29 08:14:14 2010 +0100

    eeepc-wmi: never load if legacy device is enabled
    
    If legacy device (SB.ATKD - ASUS010) used by eeepc-laptop
    is enabled, don't allow eeepc-wmi to load because:
    - eeepc-laptop may be loaded, and can conflict with
      eeepc-wmi (they both try to register eeepc::touchpad
      led for example).
    - the WMI interface is inteded to be used when the OS is
      not detected as Win 7. And when this is the case, the
      ASUS010 device is disabled.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 52274e21ee89..4d38f98aa976 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -49,6 +49,8 @@ MODULE_AUTHOR("Yong Wang <yong.y.wang@intel.com>");
 MODULE_DESCRIPTION("Eee PC WMI Hotkey Driver");
 MODULE_LICENSE("GPL");
 
+#define EEEPC_ACPI_HID		"ASUS010" /* old _HID used in eeepc-laptop */
+
 #define EEEPC_WMI_EVENT_GUID	"ABBC0F72-8EA1-11D1-00A0-C90629100000"
 #define EEEPC_WMI_MGMT_GUID	"97845ED0-4E6D-11DE-8A39-0800200C9A66"
 
@@ -861,6 +863,27 @@ static struct platform_driver platform_driver = {
 	},
 };
 
+static acpi_status __init eeepc_wmi_parse_device(acpi_handle handle, u32 level,
+						 void *context, void **retval)
+{
+	pr_warning("Found legacy ATKD device (%s)", EEEPC_ACPI_HID);
+	*(bool *)context = true;
+	return AE_CTRL_TERMINATE;
+}
+
+static int __init eeepc_wmi_check_atkd(void)
+{
+	acpi_status status;
+	bool found = false;
+
+	status = acpi_get_devices(EEEPC_ACPI_HID, eeepc_wmi_parse_device,
+				  &found, NULL);
+
+	if (ACPI_FAILURE(status) || !found)
+		return 0;
+	return -1;
+}
+
 static int __init eeepc_wmi_init(void)
 {
 	int err;
@@ -871,6 +894,16 @@ static int __init eeepc_wmi_init(void)
 		return -ENODEV;
 	}
 
+	if (eeepc_wmi_check_atkd()) {
+		pr_warning("WMI device present, but legacy ATKD device is also "
+			   "present and enabled.");
+		pr_warning("You probably booted with acpi_osi=\"Linux\" or "
+			   "acpi_osi=\"!Windows 2009\"");
+		pr_warning("Can't load eeepc-wmi, use default acpi_osi "
+			   "(preferred) or eeepc-laptop");
+		return -ENODEV;
+	}
+
 	platform_device = eeepc_wmi_add();
 	if (IS_ERR(platform_device)) {
 		err = PTR_ERR(platform_device);

commit dfed65d56f9a94466bb4afd44ec8e900a6709cda
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Mon Nov 29 08:14:12 2010 +0100

    eeepc-wmi: remove unneeded static
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 5f3f42c8a989..52274e21ee89 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -267,7 +267,7 @@ static void tpd_led_set(struct led_classdev *led_cdev,
 
 static int read_tpd_state(struct eeepc_wmi *eeepc)
 {
-	static u32 retval;
+	u32 retval;
 	acpi_status status;
 
 	status = eeepc_wmi_get_devstate(EEEPC_WMI_DEVID_TPDLED, &retval);
@@ -458,7 +458,7 @@ static int eeepc_wmi_rfkill_init(struct eeepc_wmi *eeepc)
  */
 static int read_brightness(struct backlight_device *bd)
 {
-	static u32 retval;
+	u32 retval;
 	acpi_status status;
 
 	status = eeepc_wmi_get_devstate(EEEPC_WMI_DEVID_BACKLIGHT, &retval);
@@ -472,7 +472,7 @@ static int read_brightness(struct backlight_device *bd)
 static int update_bl_status(struct backlight_device *bd)
 {
 
-	static u32 ctrl_param;
+	u32 ctrl_param;
 	acpi_status status;
 
 	ctrl_param = bd->props.brightness;

commit 4c4edfa3d375109c1360ce786b9df984ca65d727
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Mon Nov 29 08:14:11 2010 +0100

    eeepc-wmi: claim eeepc-wmi maintainership
    
    Since eeepc-wmi has currently no official maintainer, I claim
    maintainership of this driver, and add it to the acpi4asus project.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 78306bea01f7..5f3f42c8a989 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -2,6 +2,7 @@
  * Eee PC WMI hotkey driver
  *
  * Copyright(C) 2010 Intel Corporation.
+ * Copyright(C) 2010 Corentin Chary <corentin.chary@gmail.com>
  *
  * Portions based on wistron_btns.c:
  * Copyright (C) 2005 Miloslav Trmac <mitr@volny.cz>

commit 2a3f0064f2a06d5a31cddb0e452681d9f884bd8c
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Mon Nov 29 08:14:10 2010 +0100

    eeepc-wmi: fix confusion between ctrl_param and retval
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 253070ab963c..78306bea01f7 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -164,7 +164,7 @@ static void eeepc_wmi_input_exit(struct eeepc_wmi *eeepc)
 	eeepc->inputdev = NULL;
 }
 
-static acpi_status eeepc_wmi_get_devstate(u32 dev_id, u32 *ctrl_param)
+static acpi_status eeepc_wmi_get_devstate(u32 dev_id, u32 *retval)
 {
 	struct acpi_buffer input = { (acpi_size)sizeof(u32), &dev_id };
 	struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
@@ -184,8 +184,8 @@ static acpi_status eeepc_wmi_get_devstate(u32 dev_id, u32 *ctrl_param)
 	else
 		tmp = 0;
 
-	if (ctrl_param)
-		*ctrl_param = tmp;
+	if (retval)
+		*retval = tmp;
 
 	kfree(obj);
 
@@ -266,14 +266,14 @@ static void tpd_led_set(struct led_classdev *led_cdev,
 
 static int read_tpd_state(struct eeepc_wmi *eeepc)
 {
-	static u32 ctrl_param;
+	static u32 retval;
 	acpi_status status;
 
-	status = eeepc_wmi_get_devstate(EEEPC_WMI_DEVID_TPDLED, &ctrl_param);
+	status = eeepc_wmi_get_devstate(EEEPC_WMI_DEVID_TPDLED, &retval);
 
 	if (ACPI_FAILURE(status))
 		return -1;
-	else if (!ctrl_param || ctrl_param == 0x00060000)
+	else if (!retval || retval == 0x00060000)
 		/*
 		 * if touchpad led is present, DSTS will set some bits,
 		 * usually 0x00020000.
@@ -282,7 +282,7 @@ static int read_tpd_state(struct eeepc_wmi *eeepc)
 		return -ENODEV;
 	else
 		/* Status is stored in the first bit */
-		return ctrl_param & 0x1;
+		return retval & 0x1;
 }
 
 static enum led_brightness tpd_led_get(struct led_classdev *led_cdev)
@@ -343,15 +343,15 @@ static int eeepc_rfkill_set(void *data, bool blocked)
 static void eeepc_rfkill_query(struct rfkill *rfkill, void *data)
 {
 	int dev_id = (unsigned long)data;
-	u32 ctrl_param;
+	u32 retval;
 	acpi_status status;
 
-	status = eeepc_wmi_get_devstate(dev_id, &ctrl_param);
+	status = eeepc_wmi_get_devstate(dev_id, &retval);
 
 	if (ACPI_FAILURE(status))
 		return ;
 
-	rfkill_set_sw_state(rfkill, !(ctrl_param & 0x1));
+	rfkill_set_sw_state(rfkill, !(retval & 0x1));
 }
 
 static const struct rfkill_ops eeepc_rfkill_ops = {
@@ -365,10 +365,10 @@ static int eeepc_new_rfkill(struct eeepc_wmi *eeepc,
 			    enum rfkill_type type, int dev_id)
 {
 	int result;
-	u32 ctrl_param;
+	u32 retval;
 	acpi_status status;
 
-	status = eeepc_wmi_get_devstate(dev_id, &ctrl_param);
+	status = eeepc_wmi_get_devstate(dev_id, &retval);
 
 	if (ACPI_FAILURE(status))
 		return -1;
@@ -379,7 +379,7 @@ static int eeepc_new_rfkill(struct eeepc_wmi *eeepc,
 	 * 0x00020000 - 0100000000000000000 - device supported
 	 * 0x00010000 - 0010000000000000000 - not supported / special mode ?
 	 */
-	if (!ctrl_param || ctrl_param == 0x00060000)
+	if (!retval || retval == 0x00060000)
 		return -ENODEV;
 
 	*rfkill = rfkill_alloc(name, &eeepc->platform_device->dev, type,
@@ -388,7 +388,7 @@ static int eeepc_new_rfkill(struct eeepc_wmi *eeepc,
 	if (!*rfkill)
 		return -EINVAL;
 
-	rfkill_init_sw_state(*rfkill, !(ctrl_param & 0x1));
+	rfkill_init_sw_state(*rfkill, !(retval & 0x1));
 	result = rfkill_register(*rfkill);
 	if (result) {
 		rfkill_destroy(*rfkill);
@@ -457,15 +457,15 @@ static int eeepc_wmi_rfkill_init(struct eeepc_wmi *eeepc)
  */
 static int read_brightness(struct backlight_device *bd)
 {
-	static u32 ctrl_param;
+	static u32 retval;
 	acpi_status status;
 
-	status = eeepc_wmi_get_devstate(EEEPC_WMI_DEVID_BACKLIGHT, &ctrl_param);
+	status = eeepc_wmi_get_devstate(EEEPC_WMI_DEVID_BACKLIGHT, &retval);
 
 	if (ACPI_FAILURE(status))
 		return -1;
 	else
-		return ctrl_param & 0xFF;
+		return retval & 0xFF;
 }
 
 static int update_bl_status(struct backlight_device *bd)

commit 8c1b2d83e82e11b9447d7fb3715d6c9764f6f28d
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Mon Nov 29 08:14:09 2010 +0100

    eeepc-wmi: add debugfs entries
    
    eeepc-wmi/    - debugfs root directory
      dev_id      - current dev_id
      ctrl_param  - current ctrl_param
      devs        - call DEVS(dev_id, ctrl_param) and print result
      dsts        - call DSTS(dev_id)  and print result
    
    DEVS and DSTS are the main functions used in eeepc-wmi, this
    will allow to test new features without patching the drivers.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index a70d76a463a6..253070ab963c 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -36,6 +36,8 @@
 #include <linux/backlight.h>
 #include <linux/leds.h>
 #include <linux/rfkill.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
 #include <linux/platform_device.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
@@ -89,6 +91,19 @@ struct bios_args {
 	u32	ctrl_param;
 };
 
+/*
+ * eeepc-wmi/    - debugfs root directory
+ *   dev_id      - current dev_id
+ *   ctrl_param  - current ctrl_param
+ *   devs        - call DEVS(dev_id, ctrl_param) and print result
+ *   dsts        - call DSTS(dev_id)  and print result
+ */
+struct eeepc_wmi_debug {
+	struct dentry *root;
+	u32 dev_id;
+	u32 ctrl_param;
+};
+
 struct eeepc_wmi {
 	struct input_dev *inputdev;
 	struct backlight_device *backlight_device;
@@ -102,6 +117,8 @@ struct eeepc_wmi {
 	struct rfkill *wlan_rfkill;
 	struct rfkill *bluetooth_rfkill;
 	struct rfkill *wwan3g_rfkill;
+
+	struct eeepc_wmi_debug debug;
 };
 
 /* Only used in eeepc_wmi_init() and eeepc_wmi_exit() */
@@ -176,7 +193,8 @@ static acpi_status eeepc_wmi_get_devstate(u32 dev_id, u32 *ctrl_param)
 
 }
 
-static acpi_status eeepc_wmi_set_devstate(u32 dev_id, u32 ctrl_param)
+static acpi_status eeepc_wmi_set_devstate(u32 dev_id, u32 ctrl_param,
+					  u32 *retval)
 {
 	struct bios_args args = {
 		.dev_id = dev_id,
@@ -185,8 +203,32 @@ static acpi_status eeepc_wmi_set_devstate(u32 dev_id, u32 ctrl_param)
 	struct acpi_buffer input = { (acpi_size)sizeof(args), &args };
 	acpi_status status;
 
-	status = wmi_evaluate_method(EEEPC_WMI_MGMT_GUID,
-			1, EEEPC_WMI_METHODID_DEVS, &input, NULL);
+	if (!retval) {
+		status = wmi_evaluate_method(EEEPC_WMI_MGMT_GUID, 1,
+					     EEEPC_WMI_METHODID_DEVS,
+					     &input, NULL);
+	} else {
+		struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
+		union acpi_object *obj;
+		u32 tmp;
+
+		status = wmi_evaluate_method(EEEPC_WMI_MGMT_GUID, 1,
+					     EEEPC_WMI_METHODID_DEVS,
+					     &input, &output);
+
+		if (ACPI_FAILURE(status))
+			return status;
+
+		obj = (union acpi_object *)output.pointer;
+		if (obj && obj->type == ACPI_TYPE_INTEGER)
+			tmp = (u32)obj->integer.value;
+		else
+			tmp = 0;
+
+		*retval = tmp;
+
+		kfree(obj);
+	}
 
 	return status;
 }
@@ -208,7 +250,7 @@ static void tpd_led_update(struct work_struct *work)
 	eeepc = container_of(work, struct eeepc_wmi, tpd_led_work);
 
 	ctrl_param = eeepc->tpd_led_wk;
-	eeepc_wmi_set_devstate(EEEPC_WMI_DEVID_TPDLED, ctrl_param);
+	eeepc_wmi_set_devstate(EEEPC_WMI_DEVID_TPDLED, ctrl_param, NULL);
 }
 
 static void tpd_led_set(struct led_classdev *led_cdev,
@@ -295,7 +337,7 @@ static int eeepc_rfkill_set(void *data, bool blocked)
 	int dev_id = (unsigned long)data;
 	u32 ctrl_param = !blocked;
 
-	return eeepc_wmi_set_devstate(dev_id, ctrl_param);
+	return eeepc_wmi_set_devstate(dev_id, ctrl_param, NULL);
 }
 
 static void eeepc_rfkill_query(struct rfkill *rfkill, void *data)
@@ -434,7 +476,8 @@ static int update_bl_status(struct backlight_device *bd)
 
 	ctrl_param = bd->props.brightness;
 
-	status = eeepc_wmi_set_devstate(EEEPC_WMI_DEVID_BACKLIGHT, ctrl_param);
+	status = eeepc_wmi_set_devstate(EEEPC_WMI_DEVID_BACKLIGHT,
+					ctrl_param, NULL);
 
 	if (ACPI_FAILURE(status))
 		return -1;
@@ -613,6 +656,114 @@ static void eeepc_wmi_platform_exit(struct eeepc_wmi *eeepc)
 	platform_device_unregister(eeepc->platform_device);
 }
 
+/*
+ * debugfs
+ */
+struct eeepc_wmi_debugfs_node {
+	struct eeepc_wmi *eeepc;
+	char *name;
+	int (*show)(struct seq_file *m, void *data);
+};
+
+static int show_dsts(struct seq_file *m, void *data)
+{
+	struct eeepc_wmi *eeepc = m->private;
+	acpi_status status;
+	u32 retval = -1;
+
+	status = eeepc_wmi_get_devstate(eeepc->debug.dev_id, &retval);
+
+	if (ACPI_FAILURE(status))
+		return -EIO;
+
+	seq_printf(m, "DSTS(%x) = %x\n", eeepc->debug.dev_id, retval);
+
+	return 0;
+}
+
+static int show_devs(struct seq_file *m, void *data)
+{
+	struct eeepc_wmi *eeepc = m->private;
+	acpi_status status;
+	u32 retval = -1;
+
+	status = eeepc_wmi_set_devstate(eeepc->debug.dev_id,
+					eeepc->debug.ctrl_param, &retval);
+	if (ACPI_FAILURE(status))
+		return -EIO;
+
+	seq_printf(m, "DEVS(%x, %x) = %x\n", eeepc->debug.dev_id,
+		   eeepc->debug.ctrl_param, retval);
+
+	return 0;
+}
+
+static struct eeepc_wmi_debugfs_node eeepc_wmi_debug_files[] = {
+	{ NULL, "devs", show_devs },
+	{ NULL, "dsts", show_dsts },
+};
+
+static int eeepc_wmi_debugfs_open(struct inode *inode, struct file *file)
+{
+	struct eeepc_wmi_debugfs_node *node = inode->i_private;
+
+	return single_open(file, node->show, node->eeepc);
+}
+
+static const struct file_operations eeepc_wmi_debugfs_io_ops = {
+	.owner = THIS_MODULE,
+	.open  = eeepc_wmi_debugfs_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+static void eeepc_wmi_debugfs_exit(struct eeepc_wmi *eeepc)
+{
+	debugfs_remove_recursive(eeepc->debug.root);
+}
+
+static int eeepc_wmi_debugfs_init(struct eeepc_wmi *eeepc)
+{
+	struct dentry *dent;
+	int i;
+
+	eeepc->debug.root = debugfs_create_dir(EEEPC_WMI_FILE, NULL);
+	if (!eeepc->debug.root) {
+		pr_err("failed to create debugfs directory");
+		goto error_debugfs;
+	}
+
+	dent = debugfs_create_x32("dev_id", S_IRUGO|S_IWUSR,
+				  eeepc->debug.root, &eeepc->debug.dev_id);
+	if (!dent)
+		goto error_debugfs;
+
+	dent = debugfs_create_x32("ctrl_param", S_IRUGO|S_IWUSR,
+				  eeepc->debug.root, &eeepc->debug.ctrl_param);
+	if (!dent)
+		goto error_debugfs;
+
+	for (i = 0; i < ARRAY_SIZE(eeepc_wmi_debug_files); i++) {
+		struct eeepc_wmi_debugfs_node *node = &eeepc_wmi_debug_files[i];
+
+		node->eeepc = eeepc;
+		dent = debugfs_create_file(node->name, S_IFREG | S_IRUGO,
+					   eeepc->debug.root, node,
+					   &eeepc_wmi_debugfs_io_ops);
+		if (!dent) {
+			pr_err("failed to create debug file: %s\n", node->name);
+			goto error_debugfs;
+		}
+	}
+
+	return 0;
+
+error_debugfs:
+	eeepc_wmi_debugfs_exit(eeepc);
+	return -ENOMEM;
+}
+
 /*
  * WMI Driver
  */
@@ -662,8 +813,14 @@ static struct platform_device * __init eeepc_wmi_add(void)
 		goto fail_wmi_handler;
 	}
 
+	err = eeepc_wmi_debugfs_init(eeepc);
+	if (err)
+		goto fail_debugfs;
+
 	return eeepc->platform_device;
 
+fail_debugfs:
+	wmi_remove_notify_handler(EEEPC_WMI_EVENT_GUID);
 fail_wmi_handler:
 	eeepc_wmi_backlight_exit(eeepc);
 fail_backlight:
@@ -689,6 +846,7 @@ static int eeepc_wmi_remove(struct platform_device *device)
 	eeepc_wmi_input_exit(eeepc);
 	eeepc_wmi_led_exit(eeepc);
 	eeepc_wmi_rfkill_exit(eeepc);
+	eeepc_wmi_debugfs_exit(eeepc);
 	eeepc_wmi_platform_exit(eeepc);
 
 	kfree(eeepc);

commit 4e37b42d5ac0d3f505bcdc09028f3fde82031593
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Mon Nov 29 08:14:08 2010 +0100

    eeepc-wmi: use attribute group to manage attributes
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index fb548f4b03e0..a70d76a463a6 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -560,24 +560,23 @@ static ssize_t store_cpufv(struct device *dev, struct device_attribute *attr,
 
 static DEVICE_ATTR(cpufv, S_IRUGO | S_IWUSR, NULL, store_cpufv);
 
+static struct attribute *platform_attributes[] = {
+	&dev_attr_cpufv.attr,
+	NULL
+};
+
+static struct attribute_group platform_attribute_group = {
+	.attrs = platform_attributes
+};
+
 static void eeepc_wmi_sysfs_exit(struct platform_device *device)
 {
-	device_remove_file(&device->dev, &dev_attr_cpufv);
+	sysfs_remove_group(&device->dev.kobj, &platform_attribute_group);
 }
 
 static int eeepc_wmi_sysfs_init(struct platform_device *device)
 {
-	int retval = -ENOMEM;
-
-	retval = device_create_file(&device->dev, &dev_attr_cpufv);
-	if (retval)
-		goto error_sysfs;
-
-	return 0;
-
-error_sysfs:
-	eeepc_wmi_sysfs_exit(device);
-	return retval;
+	return sysfs_create_group(&device->dev.kobj, &platform_attribute_group);
 }
 
 /*

commit ba48fdb969d0404d54f6fa0266373afecbbd19d7
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Mon Nov 29 08:14:07 2010 +0100

    eeepc-wmi: add rfkill support for wlan, bluetooth and 3g
    
    wimax support is missing because I don't have any DSDT
    with WMI and wimax support.
    
    Most of the code comes from eeepc-laptop.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index f12a25da4055..fb548f4b03e0 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -35,6 +35,7 @@
 #include <linux/fb.h>
 #include <linux/backlight.h>
 #include <linux/leds.h>
+#include <linux/rfkill.h>
 #include <linux/platform_device.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
@@ -62,6 +63,9 @@ MODULE_ALIAS("wmi:"EEEPC_WMI_MGMT_GUID);
 
 #define EEEPC_WMI_DEVID_BACKLIGHT	0x00050012
 #define EEEPC_WMI_DEVID_TPDLED		0x00100011
+#define EEEPC_WMI_DEVID_WLAN		0x00010011
+#define EEEPC_WMI_DEVID_BLUETOOTH	0x00010013
+#define EEEPC_WMI_DEVID_WWAN3G		0x00010019
 
 static const struct key_entry eeepc_wmi_keymap[] = {
 	/* Sleep already handled via generic ACPI code */
@@ -94,6 +98,10 @@ struct eeepc_wmi {
 	int tpd_led_wk;
 	struct workqueue_struct *led_workqueue;
 	struct work_struct tpd_led_work;
+
+	struct rfkill *wlan_rfkill;
+	struct rfkill *bluetooth_rfkill;
+	struct rfkill *wwan3g_rfkill;
 };
 
 /* Only used in eeepc_wmi_init() and eeepc_wmi_exit() */
@@ -279,6 +287,129 @@ static void eeepc_wmi_led_exit(struct eeepc_wmi *eeepc)
 		destroy_workqueue(eeepc->led_workqueue);
 }
 
+/*
+ * Rfkill devices
+ */
+static int eeepc_rfkill_set(void *data, bool blocked)
+{
+	int dev_id = (unsigned long)data;
+	u32 ctrl_param = !blocked;
+
+	return eeepc_wmi_set_devstate(dev_id, ctrl_param);
+}
+
+static void eeepc_rfkill_query(struct rfkill *rfkill, void *data)
+{
+	int dev_id = (unsigned long)data;
+	u32 ctrl_param;
+	acpi_status status;
+
+	status = eeepc_wmi_get_devstate(dev_id, &ctrl_param);
+
+	if (ACPI_FAILURE(status))
+		return ;
+
+	rfkill_set_sw_state(rfkill, !(ctrl_param & 0x1));
+}
+
+static const struct rfkill_ops eeepc_rfkill_ops = {
+	.set_block = eeepc_rfkill_set,
+	.query = eeepc_rfkill_query,
+};
+
+static int eeepc_new_rfkill(struct eeepc_wmi *eeepc,
+			    struct rfkill **rfkill,
+			    const char *name,
+			    enum rfkill_type type, int dev_id)
+{
+	int result;
+	u32 ctrl_param;
+	acpi_status status;
+
+	status = eeepc_wmi_get_devstate(dev_id, &ctrl_param);
+
+	if (ACPI_FAILURE(status))
+		return -1;
+
+	/* If the device is present, DSTS will always set some bits
+	 * 0x00070000 - 1110000000000000000 - device supported
+	 * 0x00060000 - 1100000000000000000 - not supported
+	 * 0x00020000 - 0100000000000000000 - device supported
+	 * 0x00010000 - 0010000000000000000 - not supported / special mode ?
+	 */
+	if (!ctrl_param || ctrl_param == 0x00060000)
+		return -ENODEV;
+
+	*rfkill = rfkill_alloc(name, &eeepc->platform_device->dev, type,
+			       &eeepc_rfkill_ops, (void *)(long)dev_id);
+
+	if (!*rfkill)
+		return -EINVAL;
+
+	rfkill_init_sw_state(*rfkill, !(ctrl_param & 0x1));
+	result = rfkill_register(*rfkill);
+	if (result) {
+		rfkill_destroy(*rfkill);
+		*rfkill = NULL;
+		return result;
+	}
+	return 0;
+}
+
+static void eeepc_wmi_rfkill_exit(struct eeepc_wmi *eeepc)
+{
+	if (eeepc->wlan_rfkill) {
+		rfkill_unregister(eeepc->wlan_rfkill);
+		rfkill_destroy(eeepc->wlan_rfkill);
+		eeepc->wlan_rfkill = NULL;
+	}
+	if (eeepc->bluetooth_rfkill) {
+		rfkill_unregister(eeepc->bluetooth_rfkill);
+		rfkill_destroy(eeepc->bluetooth_rfkill);
+		eeepc->bluetooth_rfkill = NULL;
+	}
+	if (eeepc->wwan3g_rfkill) {
+		rfkill_unregister(eeepc->wwan3g_rfkill);
+		rfkill_destroy(eeepc->wwan3g_rfkill);
+		eeepc->wwan3g_rfkill = NULL;
+	}
+}
+
+static int eeepc_wmi_rfkill_init(struct eeepc_wmi *eeepc)
+{
+	int result = 0;
+
+	result = eeepc_new_rfkill(eeepc, &eeepc->wlan_rfkill,
+				  "eeepc-wlan", RFKILL_TYPE_WLAN,
+				  EEEPC_WMI_DEVID_WLAN);
+
+	if (result && result != -ENODEV)
+		goto exit;
+
+	result = eeepc_new_rfkill(eeepc, &eeepc->bluetooth_rfkill,
+				  "eeepc-bluetooth", RFKILL_TYPE_BLUETOOTH,
+				  EEEPC_WMI_DEVID_BLUETOOTH);
+
+	if (result && result != -ENODEV)
+		goto exit;
+
+	result = eeepc_new_rfkill(eeepc, &eeepc->wwan3g_rfkill,
+				  "eeepc-wwan3g", RFKILL_TYPE_WWAN,
+				  EEEPC_WMI_DEVID_WWAN3G);
+
+	if (result && result != -ENODEV)
+		goto exit;
+
+exit:
+	if (result && result != -ENODEV)
+		eeepc_wmi_rfkill_exit(eeepc);
+
+	if (result == -ENODEV)
+		result = 0;
+
+	return result;
+}
+
 /*
  * Backlight
  */
@@ -512,6 +643,10 @@ static struct platform_device * __init eeepc_wmi_add(void)
 	if (err)
 		goto fail_leds;
 
+	err = eeepc_wmi_rfkill_init(eeepc);
+	if (err)
+		goto fail_rfkill;
+
 	if (!acpi_video_backlight_support()) {
 		err = eeepc_wmi_backlight_init(eeepc);
 		if (err)
@@ -533,6 +668,8 @@ static struct platform_device * __init eeepc_wmi_add(void)
 fail_wmi_handler:
 	eeepc_wmi_backlight_exit(eeepc);
 fail_backlight:
+	eeepc_wmi_rfkill_exit(eeepc);
+fail_rfkill:
 	eeepc_wmi_led_exit(eeepc);
 fail_leds:
 	eeepc_wmi_input_exit(eeepc);
@@ -552,6 +689,7 @@ static int eeepc_wmi_remove(struct platform_device *device)
 	eeepc_wmi_backlight_exit(eeepc);
 	eeepc_wmi_input_exit(eeepc);
 	eeepc_wmi_led_exit(eeepc);
+	eeepc_wmi_rfkill_exit(eeepc);
 	eeepc_wmi_platform_exit(eeepc);
 
 	kfree(eeepc);

commit 084fca63128849c0961b3cfdb0cd0345e8f51ad8
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Mon Nov 29 08:14:06 2010 +0100

    eeepc-wmi: add touchpad led support
    
    Most of the code comes from eeepc-laptop.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index dfbb295326be..f12a25da4055 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -34,6 +34,7 @@
 #include <linux/input/sparse-keymap.h>
 #include <linux/fb.h>
 #include <linux/backlight.h>
+#include <linux/leds.h>
 #include <linux/platform_device.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
@@ -60,6 +61,7 @@ MODULE_ALIAS("wmi:"EEEPC_WMI_MGMT_GUID);
 #define EEEPC_WMI_METHODID_CFVS	0x53564643
 
 #define EEEPC_WMI_DEVID_BACKLIGHT	0x00050012
+#define EEEPC_WMI_DEVID_TPDLED		0x00100011
 
 static const struct key_entry eeepc_wmi_keymap[] = {
 	/* Sleep already handled via generic ACPI code */
@@ -87,6 +89,11 @@ struct eeepc_wmi {
 	struct input_dev *inputdev;
 	struct backlight_device *backlight_device;
 	struct platform_device *platform_device;
+
+	struct led_classdev tpd_led;
+	int tpd_led_wk;
+	struct workqueue_struct *led_workqueue;
+	struct work_struct tpd_led_work;
 };
 
 /* Only used in eeepc_wmi_init() and eeepc_wmi_exit() */
@@ -176,6 +183,105 @@ static acpi_status eeepc_wmi_set_devstate(u32 dev_id, u32 ctrl_param)
 	return status;
 }
 
+/*
+ * LEDs
+ */
+/*
+ * These functions actually update the LED's, and are called from a
+ * workqueue. By doing this as separate work rather than when the LED
+ * subsystem asks, we avoid messing with the Eeepc ACPI stuff during a
+ * potentially bad time, such as a timer interrupt.
+ */
+static void tpd_led_update(struct work_struct *work)
+{
+	int ctrl_param;
+	struct eeepc_wmi *eeepc;
+
+	eeepc = container_of(work, struct eeepc_wmi, tpd_led_work);
+
+	ctrl_param = eeepc->tpd_led_wk;
+	eeepc_wmi_set_devstate(EEEPC_WMI_DEVID_TPDLED, ctrl_param);
+}
+
+static void tpd_led_set(struct led_classdev *led_cdev,
+			enum led_brightness value)
+{
+	struct eeepc_wmi *eeepc;
+
+	eeepc = container_of(led_cdev, struct eeepc_wmi, tpd_led);
+
+	eeepc->tpd_led_wk = !!value;
+	queue_work(eeepc->led_workqueue, &eeepc->tpd_led_work);
+}
+
+static int read_tpd_state(struct eeepc_wmi *eeepc)
+{
+	static u32 ctrl_param;
+	acpi_status status;
+
+	status = eeepc_wmi_get_devstate(EEEPC_WMI_DEVID_TPDLED, &ctrl_param);
+
+	if (ACPI_FAILURE(status))
+		return -1;
+	else if (!ctrl_param || ctrl_param == 0x00060000)
+		/*
+		 * if touchpad led is present, DSTS will set some bits,
+		 * usually 0x00020000.
+		 * 0x00060000 means that the device is not supported
+		 */
+		return -ENODEV;
+	else
+		/* Status is stored in the first bit */
+		return ctrl_param & 0x1;
+}
+
+static enum led_brightness tpd_led_get(struct led_classdev *led_cdev)
+{
+	struct eeepc_wmi *eeepc;
+
+	eeepc = container_of(led_cdev, struct eeepc_wmi, tpd_led);
+
+	return read_tpd_state(eeepc);
+}
+
+static int eeepc_wmi_led_init(struct eeepc_wmi *eeepc)
+{
+	int rv;
+
+	if (read_tpd_state(eeepc) < 0)
+		return 0;
+
+	eeepc->led_workqueue = create_singlethread_workqueue("led_workqueue");
+	if (!eeepc->led_workqueue)
+		return -ENOMEM;
+	INIT_WORK(&eeepc->tpd_led_work, tpd_led_update);
+
+	eeepc->tpd_led.name = "eeepc::touchpad";
+	eeepc->tpd_led.brightness_set = tpd_led_set;
+	eeepc->tpd_led.brightness_get = tpd_led_get;
+	eeepc->tpd_led.max_brightness = 1;
+
+	rv = led_classdev_register(&eeepc->platform_device->dev,
+				   &eeepc->tpd_led);
+	if (rv) {
+		destroy_workqueue(eeepc->led_workqueue);
+		return rv;
+	}
+
+	return 0;
+}
+
+static void eeepc_wmi_led_exit(struct eeepc_wmi *eeepc)
+{
+	if (eeepc->tpd_led.dev)
+		led_classdev_unregister(&eeepc->tpd_led);
+	if (eeepc->led_workqueue)
+		destroy_workqueue(eeepc->led_workqueue);
+}
+
+/*
+ * Backlight
+ */
 static int read_brightness(struct backlight_device *bd)
 {
 	static u32 ctrl_param;
@@ -402,6 +508,10 @@ static struct platform_device * __init eeepc_wmi_add(void)
 	if (err)
 		goto fail_input;
 
+	err = eeepc_wmi_led_init(eeepc);
+	if (err)
+		goto fail_leds;
+
 	if (!acpi_video_backlight_support()) {
 		err = eeepc_wmi_backlight_init(eeepc);
 		if (err)
@@ -423,6 +533,8 @@ static struct platform_device * __init eeepc_wmi_add(void)
 fail_wmi_handler:
 	eeepc_wmi_backlight_exit(eeepc);
 fail_backlight:
+	eeepc_wmi_led_exit(eeepc);
+fail_leds:
 	eeepc_wmi_input_exit(eeepc);
 fail_input:
 	eeepc_wmi_platform_exit(eeepc);
@@ -439,6 +551,7 @@ static int eeepc_wmi_remove(struct platform_device *device)
 	wmi_remove_notify_handler(EEEPC_WMI_EVENT_GUID);
 	eeepc_wmi_backlight_exit(eeepc);
 	eeepc_wmi_input_exit(eeepc);
+	eeepc_wmi_led_exit(eeepc);
 	eeepc_wmi_platform_exit(eeepc);
 
 	kfree(eeepc);

commit 27c136c8738f6bec10c26aaf0a486f19edef7bf7
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Mon Nov 29 08:14:05 2010 +0100

    eeepc-wmi: rework eeepc_wmi_init and eeepc_wmi_exit
    
    The old code was using platform_driver.probe to initialize
    eeepc_wmi context. That's a mistake because if probe fail,
    eeepc_platform_register() won't tell anyone, and chaos will happen.
    
    Wrap add and remove code inside eeepc_wmi_add() / eeepc_wmi_remove(),
    and try to use the static platform_device only in eeepc_wmi_init()
    and eeepc_wmi_exit()
    
    The code is now very similar to eeepc-laptop, except eeepc_laptop_add
    and eeepc_laptop_remove are called from acpi_driver, not module
    init/exit functions, but WMI doesn't provide such functionalities (yet ?).
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 0d50fbbe2478..dfbb295326be 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -86,8 +86,10 @@ struct bios_args {
 struct eeepc_wmi {
 	struct input_dev *inputdev;
 	struct backlight_device *backlight_device;
+	struct platform_device *platform_device;
 };
 
+/* Only used in eeepc_wmi_init() and eeepc_wmi_exit() */
 static struct platform_device *platform_device;
 
 static int eeepc_wmi_input_init(struct eeepc_wmi *eeepc)
@@ -101,7 +103,7 @@ static int eeepc_wmi_input_init(struct eeepc_wmi *eeepc)
 	eeepc->inputdev->name = "Eee PC WMI hotkeys";
 	eeepc->inputdev->phys = EEEPC_WMI_FILE "/input0";
 	eeepc->inputdev->id.bustype = BUS_HOST;
-	eeepc->inputdev->dev.parent = &platform_device->dev;
+	eeepc->inputdev->dev.parent = &eeepc->platform_device->dev;
 
 	err = sparse_keymap_setup(eeepc->inputdev, eeepc_wmi_keymap, NULL);
 	if (err)
@@ -234,7 +236,7 @@ static int eeepc_wmi_backlight_init(struct eeepc_wmi *eeepc)
 	memset(&props, 0, sizeof(struct backlight_properties));
 	props.max_brightness = 15;
 	bd = backlight_device_register(EEEPC_WMI_FILE,
-				       &platform_device->dev, eeepc,
+				       &eeepc->platform_device->dev, eeepc,
 				       &eeepc_wmi_bl_ops, &props);
 	if (IS_ERR(bd)) {
 		pr_err("Could not register backlight device\n");
@@ -337,49 +339,99 @@ static int eeepc_wmi_sysfs_init(struct platform_device *device)
 	return 0;
 
 error_sysfs:
-	eeepc_wmi_sysfs_exit(platform_device);
+	eeepc_wmi_sysfs_exit(device);
 	return retval;
 }
 
-static int __devinit eeepc_wmi_platform_probe(struct platform_device *device)
+/*
+ * Platform device
+ */
+static int __init eeepc_wmi_platform_init(struct eeepc_wmi *eeepc)
 {
-	struct eeepc_wmi *eeepc;
 	int err;
+
+	eeepc->platform_device = platform_device_alloc(EEEPC_WMI_FILE, -1);
+	if (!eeepc->platform_device)
+		return -ENOMEM;
+	platform_set_drvdata(eeepc->platform_device, eeepc);
+
+	err = platform_device_add(eeepc->platform_device);
+	if (err)
+		goto fail_platform_device;
+
+	err = eeepc_wmi_sysfs_init(eeepc->platform_device);
+	if (err)
+		goto fail_sysfs;
+	return 0;
+
+fail_sysfs:
+	platform_device_del(eeepc->platform_device);
+fail_platform_device:
+	platform_device_put(eeepc->platform_device);
+	return err;
+}
+
+static void eeepc_wmi_platform_exit(struct eeepc_wmi *eeepc)
+{
+	eeepc_wmi_sysfs_exit(eeepc->platform_device);
+	platform_device_unregister(eeepc->platform_device);
+}
+
+/*
+ * WMI Driver
+ */
+static struct platform_device * __init eeepc_wmi_add(void)
+{
+	struct eeepc_wmi *eeepc;
 	acpi_status status;
+	int err;
 
-	eeepc = platform_get_drvdata(device);
+	eeepc = kzalloc(sizeof(struct eeepc_wmi), GFP_KERNEL);
+	if (!eeepc)
+		return ERR_PTR(-ENOMEM);
+
+	/*
+	 * Register the platform device first.  It is used as a parent for the
+	 * sub-devices below.
+	 */
+	err = eeepc_wmi_platform_init(eeepc);
+	if (err)
+		goto fail_platform;
 
 	err = eeepc_wmi_input_init(eeepc);
 	if (err)
-		goto error_input;
+		goto fail_input;
 
 	if (!acpi_video_backlight_support()) {
 		err = eeepc_wmi_backlight_init(eeepc);
 		if (err)
-			goto error_backlight;
+			goto fail_backlight;
 	} else
 		pr_info("Backlight controlled by ACPI video driver\n");
 
 	status = wmi_install_notify_handler(EEEPC_WMI_EVENT_GUID,
-					eeepc_wmi_notify, eeepc);
+					    eeepc_wmi_notify, eeepc);
 	if (ACPI_FAILURE(status)) {
 		pr_err("Unable to register notify handler - %d\n",
 			status);
 		err = -ENODEV;
-		goto error_wmi;
+		goto fail_wmi_handler;
 	}
 
-	return 0;
+	return eeepc->platform_device;
 
-error_wmi:
+fail_wmi_handler:
 	eeepc_wmi_backlight_exit(eeepc);
-error_backlight:
+fail_backlight:
 	eeepc_wmi_input_exit(eeepc);
-error_input:
-	return err;
+fail_input:
+	eeepc_wmi_platform_exit(eeepc);
+fail_platform:
+	kfree(eeepc);
+	return ERR_PTR(err);
 }
 
-static int __devexit eeepc_wmi_platform_remove(struct platform_device *device)
+static int eeepc_wmi_remove(struct platform_device *device)
 {
 	struct eeepc_wmi *eeepc;
 
@@ -387,7 +439,9 @@ static int __devexit eeepc_wmi_platform_remove(struct platform_device *device)
 	wmi_remove_notify_handler(EEEPC_WMI_EVENT_GUID);
 	eeepc_wmi_backlight_exit(eeepc);
 	eeepc_wmi_input_exit(eeepc);
+	eeepc_wmi_platform_exit(eeepc);
 
+	kfree(eeepc);
 	return 0;
 }
 
@@ -396,13 +450,10 @@ static struct platform_driver platform_driver = {
 		.name = EEEPC_WMI_FILE,
 		.owner = THIS_MODULE,
 	},
-	.probe = eeepc_wmi_platform_probe,
-	.remove = __devexit_p(eeepc_wmi_platform_remove),
 };
 
 static int __init eeepc_wmi_init(void)
 {
-	struct eeepc_wmi *eeepc;
 	int err;
 
 	if (!wmi_has_guid(EEEPC_WMI_EVENT_GUID) ||
@@ -411,58 +462,30 @@ static int __init eeepc_wmi_init(void)
 		return -ENODEV;
 	}
 
-	eeepc = kzalloc(sizeof(struct eeepc_wmi), GFP_KERNEL);
-	if (!eeepc)
-		return -ENOMEM;
-
-	platform_device = platform_device_alloc(EEEPC_WMI_FILE, -1);
-	if (!platform_device) {
-		pr_warning("Unable to allocate platform device\n");
-		err = -ENOMEM;
-		goto fail_platform;
+	platform_device = eeepc_wmi_add();
+	if (IS_ERR(platform_device)) {
+		err = PTR_ERR(platform_device);
+		goto fail_eeepc_wmi;
 	}
 
-	err = platform_device_add(platform_device);
-	if (err) {
-		pr_warning("Unable to add platform device\n");
-		goto put_dev;
-	}
-
-	platform_set_drvdata(platform_device, eeepc);
-
 	err = platform_driver_register(&platform_driver);
 	if (err) {
 		pr_warning("Unable to register platform driver\n");
-		goto del_dev;
+		goto fail_platform_driver;
 	}
 
-	err = eeepc_wmi_sysfs_init(platform_device);
-	if (err)
-		goto del_sysfs;
-
 	return 0;
 
-del_sysfs:
-	eeepc_wmi_sysfs_exit(platform_device);
-del_dev:
-	platform_device_del(platform_device);
-put_dev:
-	platform_device_put(platform_device);
-fail_platform:
-	kfree(eeepc);
-
+fail_platform_driver:
+	eeepc_wmi_remove(platform_device);
+fail_eeepc_wmi:
 	return err;
 }
 
 static void __exit eeepc_wmi_exit(void)
 {
-	struct eeepc_wmi *eeepc;
-
-	eeepc_wmi_sysfs_exit(platform_device);
-	eeepc = platform_get_drvdata(platform_device);
+	eeepc_wmi_remove(platform_device);
 	platform_driver_unregister(&platform_driver);
-	platform_device_unregister(platform_device);
-	kfree(eeepc);
 }
 
 module_init(eeepc_wmi_init);

commit 67fa38ec097a3e270ab175636338185017b49fa7
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Wed Nov 3 11:14:01 2010 -0700

    eeepc-wmi: fix compiler warning
    
    This fixes the following:
    
      CC [M]  drivers/platform/x86/eeepc-wmi.o
    drivers/platform/x86/eeepc-wmi.c:322: warning: initialization from incompatible pointer type
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 462ceab93f87..0d50fbbe2478 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -298,8 +298,8 @@ static void eeepc_wmi_notify(u32 value, void *context)
 	kfree(obj);
 }
 
-static int store_cpufv(struct device *dev, struct device_attribute *attr,
-		       const char *buf, size_t count)
+static ssize_t store_cpufv(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
 {
 	int value;
 	struct acpi_buffer input = { (acpi_size)sizeof(value), &value };

commit 7f80d734b3b5d23b9851cc03cc20733bca2c724e
Author: Chris Bagwell <chris@cnpbagwell.com>
Date:   Mon Oct 11 18:47:18 2010 -0500

    eeepc-wmi: Add cpufv sysfs interface
    
    eeepc-laptop provides a sysfs interface to read and control what it
    calls cpufv.  When WMI is enabled, the ACPI interface changes slightly
    and becames a write-only control with 3 valid values.
    
    Expose cpufv again to allow for user space utils that can extended battery
    life noticably and come a little closer to parity with eeepc-laptop.
    
    Write-only is OK for most user space apps because read status was
    mostly used to prevent unneeded mode changes.  Since this same check
    to ignore changes to same mode also exists in the DSDT then it was
    wasted ACPI call.
    
    acpi_osi="!Windows 2009" can be used for get back eeepc-laptop's
    read support of cpufv for debugging things such as behaviour
    during resume.
    
    This patch was tested with EEE PC 1005PE by monitoring powertop output while
    writing values of "0", "1", and "2" and by reviewing the decompiled DSDT of
    an 1201NL and comparing it to 1005PE's DSDT.
    
    Signed-off-by: Chris Bagwell <chris@cnpbagwell.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 21df266c27ac..462ceab93f87 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -57,6 +57,7 @@ MODULE_ALIAS("wmi:"EEEPC_WMI_MGMT_GUID);
 
 #define EEEPC_WMI_METHODID_DEVS	0x53564544
 #define EEEPC_WMI_METHODID_DSTS	0x53544344
+#define EEEPC_WMI_METHODID_CFVS	0x53564643
 
 #define EEEPC_WMI_DEVID_BACKLIGHT	0x00050012
 
@@ -297,6 +298,49 @@ static void eeepc_wmi_notify(u32 value, void *context)
 	kfree(obj);
 }
 
+static int store_cpufv(struct device *dev, struct device_attribute *attr,
+		       const char *buf, size_t count)
+{
+	int value;
+	struct acpi_buffer input = { (acpi_size)sizeof(value), &value };
+	acpi_status status;
+
+	if (!count || sscanf(buf, "%i", &value) != 1)
+		return -EINVAL;
+	if (value < 0 || value > 2)
+		return -EINVAL;
+
+	status = wmi_evaluate_method(EEEPC_WMI_MGMT_GUID,
+				     1, EEEPC_WMI_METHODID_CFVS, &input, NULL);
+
+	if (ACPI_FAILURE(status))
+		return -EIO;
+	else
+		return count;
+}
+
+static DEVICE_ATTR(cpufv, S_IRUGO | S_IWUSR, NULL, store_cpufv);
+
+static void eeepc_wmi_sysfs_exit(struct platform_device *device)
+{
+	device_remove_file(&device->dev, &dev_attr_cpufv);
+}
+
+static int eeepc_wmi_sysfs_init(struct platform_device *device)
+{
+	int retval = -ENOMEM;
+
+	retval = device_create_file(&device->dev, &dev_attr_cpufv);
+	if (retval)
+		goto error_sysfs;
+
+	return 0;
+
+error_sysfs:
+	eeepc_wmi_sysfs_exit(platform_device);
+	return retval;
+}
+
 static int __devinit eeepc_wmi_platform_probe(struct platform_device *device)
 {
 	struct eeepc_wmi *eeepc;
@@ -392,8 +436,14 @@ static int __init eeepc_wmi_init(void)
 		goto del_dev;
 	}
 
+	err = eeepc_wmi_sysfs_init(platform_device);
+	if (err)
+		goto del_sysfs;
+
 	return 0;
 
+del_sysfs:
+	eeepc_wmi_sysfs_exit(platform_device);
 del_dev:
 	platform_device_del(platform_device);
 put_dev:
@@ -408,6 +458,7 @@ static void __exit eeepc_wmi_exit(void)
 {
 	struct eeepc_wmi *eeepc;
 
+	eeepc_wmi_sysfs_exit(platform_device);
 	eeepc = platform_get_drvdata(platform_device);
 	platform_driver_unregister(&platform_driver);
 	platform_device_unregister(platform_device);

commit eda1748418beb1b9a75d0cea3304edf922c66134
Author: Chris Bagwell <chris@cnpbagwell.com>
Date:   Mon Oct 11 18:47:17 2010 -0500

    eeepc-wmi: add additional hotkeys
    
    Added 4 hotkeys using same keymap values as eeepc-latop.
    These are mousepad toggle, resolution change, screen off,
    and task manager.  These were tested on 1005PE and are the
    Fn-F3, F4, F7, and F9, respectively.
    
    Also, added a new hot key for power toggles (Fn-Space on 1005PE)
    and is meant to drive cpufv interface from userspace.
    
    Signed-off-by: Chris Bagwell <chris@cnpbagwell.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 9dc50fbf3d0b..21df266c27ac 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -69,6 +69,11 @@ static const struct key_entry eeepc_wmi_keymap[] = {
 	{ KE_IGNORE, NOTIFY_BRNDOWN_MIN, { KEY_BRIGHTNESSDOWN } },
 	{ KE_IGNORE, NOTIFY_BRNUP_MIN, { KEY_BRIGHTNESSUP } },
 	{ KE_KEY, 0xcc, { KEY_SWITCHVIDEOMODE } },
+	{ KE_KEY, 0x6b, { KEY_F13 } }, /* Disable Touchpad */
+	{ KE_KEY, 0xe1, { KEY_F14 } },
+	{ KE_KEY, 0xe9, { KEY_DISPLAY_OFF } },
+	{ KE_KEY, 0xe0, { KEY_PROG1 } },
+	{ KE_KEY, 0x5c, { KEY_F15 } },
 	{ KE_END, 0},
 };
 

commit b7670ed6509f322713bbd96eed0301c322f2ae02
Author: Daniel Mack <daniel@caiaq.de>
Date:   Wed May 19 12:37:01 2010 +0200

    drivers/platform/x86/eeepc-wmi.c: fix build warning
    
    drivers/platform/x86/eeepc-wmi.c: In function eeepc_wmi_notify:
    drivers/platform/x86/eeepc-wmi.c:209: warning: new may be used uninitialized in this function
    drivers/platform/x86/eeepc-wmi.c:209: note: new was declared here
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Cc: Matthew Garrett <mjg@redhat.com>
    Cc: Yong Wang <yong.y.wang@intel.com>
    Cc: Corentin Chary <corentincj@iksaif.net>
    Cc: Dmitry Torokhov <dtor@mail.ru>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: platform-driver-x86@vger.kernel.org
    Acked-By: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index b227eb469f49..9dc50fbf3d0b 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -206,7 +206,7 @@ static int eeepc_wmi_backlight_notify(struct eeepc_wmi *eeepc, int code)
 {
 	struct backlight_device *bd = eeepc->backlight_device;
 	int old = bd->props.brightness;
-	int new;
+	int new = old;
 
 	if (code >= NOTIFY_BRNUP_MIN && code <= NOTIFY_BRNUP_MAX)
 		new = code - NOTIFY_BRNUP_MIN + 1;

commit 3d7b165539d4174b0b8396bd52ee37ba21bd0dfb
Author: Yong Wang <yong.y.wang@linux.intel.com>
Date:   Sun Apr 11 09:27:54 2010 +0800

    eeepc-wmi: add backlight support
    
    Add backlight support for WMI based Eee PC laptops.
    
    Signed-off-by: Yong Wang <yong.y.wang@intel.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Reviewed-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 0c9596c97a0f..b227eb469f49 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -32,6 +32,8 @@
 #include <linux/slab.h>
 #include <linux/input.h>
 #include <linux/input/sparse-keymap.h>
+#include <linux/fb.h>
+#include <linux/backlight.h>
 #include <linux/platform_device.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
@@ -43,14 +45,21 @@ MODULE_DESCRIPTION("Eee PC WMI Hotkey Driver");
 MODULE_LICENSE("GPL");
 
 #define EEEPC_WMI_EVENT_GUID	"ABBC0F72-8EA1-11D1-00A0-C90629100000"
+#define EEEPC_WMI_MGMT_GUID	"97845ED0-4E6D-11DE-8A39-0800200C9A66"
 
 MODULE_ALIAS("wmi:"EEEPC_WMI_EVENT_GUID);
+MODULE_ALIAS("wmi:"EEEPC_WMI_MGMT_GUID);
 
 #define NOTIFY_BRNUP_MIN	0x11
 #define NOTIFY_BRNUP_MAX	0x1f
 #define NOTIFY_BRNDOWN_MIN	0x20
 #define NOTIFY_BRNDOWN_MAX	0x2e
 
+#define EEEPC_WMI_METHODID_DEVS	0x53564544
+#define EEEPC_WMI_METHODID_DSTS	0x53544344
+
+#define EEEPC_WMI_DEVID_BACKLIGHT	0x00050012
+
 static const struct key_entry eeepc_wmi_keymap[] = {
 	/* Sleep already handled via generic ACPI code */
 	{ KE_KEY, 0x5d, { KEY_WLAN } },
@@ -63,44 +72,18 @@ static const struct key_entry eeepc_wmi_keymap[] = {
 	{ KE_END, 0},
 };
 
+struct bios_args {
+	u32	dev_id;
+	u32	ctrl_param;
+};
+
 struct eeepc_wmi {
 	struct input_dev *inputdev;
+	struct backlight_device *backlight_device;
 };
 
 static struct platform_device *platform_device;
 
-static void eeepc_wmi_notify(u32 value, void *context)
-{
-	struct eeepc_wmi *eeepc = context;
-	struct acpi_buffer response = { ACPI_ALLOCATE_BUFFER, NULL };
-	union acpi_object *obj;
-	acpi_status status;
-	int code;
-
-	status = wmi_get_event_data(value, &response);
-	if (status != AE_OK) {
-		pr_err("bad event status 0x%x\n", status);
-		return;
-	}
-
-	obj = (union acpi_object *)response.pointer;
-
-	if (obj && obj->type == ACPI_TYPE_INTEGER) {
-		code = obj->integer.value;
-
-		if (code >= NOTIFY_BRNUP_MIN && code <= NOTIFY_BRNUP_MAX)
-			code = NOTIFY_BRNUP_MIN;
-		else if (code >= NOTIFY_BRNDOWN_MIN && code <= NOTIFY_BRNDOWN_MAX)
-			code = NOTIFY_BRNDOWN_MIN;
-
-		if (!sparse_keymap_report_event(eeepc->inputdev,
-						code, 1, true))
-			pr_info("Unknown key %x pressed\n", code);
-	}
-
-	kfree(obj);
-}
-
 static int eeepc_wmi_input_init(struct eeepc_wmi *eeepc)
 {
 	int err;
@@ -141,6 +124,174 @@ static void eeepc_wmi_input_exit(struct eeepc_wmi *eeepc)
 	eeepc->inputdev = NULL;
 }
 
+static acpi_status eeepc_wmi_get_devstate(u32 dev_id, u32 *ctrl_param)
+{
+	struct acpi_buffer input = { (acpi_size)sizeof(u32), &dev_id };
+	struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *obj;
+	acpi_status status;
+	u32 tmp;
+
+	status = wmi_evaluate_method(EEEPC_WMI_MGMT_GUID,
+			1, EEEPC_WMI_METHODID_DSTS, &input, &output);
+
+	if (ACPI_FAILURE(status))
+		return status;
+
+	obj = (union acpi_object *)output.pointer;
+	if (obj && obj->type == ACPI_TYPE_INTEGER)
+		tmp = (u32)obj->integer.value;
+	else
+		tmp = 0;
+
+	if (ctrl_param)
+		*ctrl_param = tmp;
+
+	kfree(obj);
+
+	return status;
+
+}
+
+static acpi_status eeepc_wmi_set_devstate(u32 dev_id, u32 ctrl_param)
+{
+	struct bios_args args = {
+		.dev_id = dev_id,
+		.ctrl_param = ctrl_param,
+	};
+	struct acpi_buffer input = { (acpi_size)sizeof(args), &args };
+	acpi_status status;
+
+	status = wmi_evaluate_method(EEEPC_WMI_MGMT_GUID,
+			1, EEEPC_WMI_METHODID_DEVS, &input, NULL);
+
+	return status;
+}
+
+static int read_brightness(struct backlight_device *bd)
+{
+	static u32 ctrl_param;
+	acpi_status status;
+
+	status = eeepc_wmi_get_devstate(EEEPC_WMI_DEVID_BACKLIGHT, &ctrl_param);
+
+	if (ACPI_FAILURE(status))
+		return -1;
+	else
+		return ctrl_param & 0xFF;
+}
+
+static int update_bl_status(struct backlight_device *bd)
+{
+
+	static u32 ctrl_param;
+	acpi_status status;
+
+	ctrl_param = bd->props.brightness;
+
+	status = eeepc_wmi_set_devstate(EEEPC_WMI_DEVID_BACKLIGHT, ctrl_param);
+
+	if (ACPI_FAILURE(status))
+		return -1;
+	else
+		return 0;
+}
+
+static const struct backlight_ops eeepc_wmi_bl_ops = {
+	.get_brightness = read_brightness,
+	.update_status = update_bl_status,
+};
+
+static int eeepc_wmi_backlight_notify(struct eeepc_wmi *eeepc, int code)
+{
+	struct backlight_device *bd = eeepc->backlight_device;
+	int old = bd->props.brightness;
+	int new;
+
+	if (code >= NOTIFY_BRNUP_MIN && code <= NOTIFY_BRNUP_MAX)
+		new = code - NOTIFY_BRNUP_MIN + 1;
+	else if (code >= NOTIFY_BRNDOWN_MIN && code <= NOTIFY_BRNDOWN_MAX)
+		new = code - NOTIFY_BRNDOWN_MIN;
+
+	bd->props.brightness = new;
+	backlight_update_status(bd);
+	backlight_force_update(bd, BACKLIGHT_UPDATE_HOTKEY);
+
+	return old;
+}
+
+static int eeepc_wmi_backlight_init(struct eeepc_wmi *eeepc)
+{
+	struct backlight_device *bd;
+	struct backlight_properties props;
+
+	memset(&props, 0, sizeof(struct backlight_properties));
+	props.max_brightness = 15;
+	bd = backlight_device_register(EEEPC_WMI_FILE,
+				       &platform_device->dev, eeepc,
+				       &eeepc_wmi_bl_ops, &props);
+	if (IS_ERR(bd)) {
+		pr_err("Could not register backlight device\n");
+		return PTR_ERR(bd);
+	}
+
+	eeepc->backlight_device = bd;
+
+	bd->props.brightness = read_brightness(bd);
+	bd->props.power = FB_BLANK_UNBLANK;
+	backlight_update_status(bd);
+
+	return 0;
+}
+
+static void eeepc_wmi_backlight_exit(struct eeepc_wmi *eeepc)
+{
+	if (eeepc->backlight_device)
+		backlight_device_unregister(eeepc->backlight_device);
+
+	eeepc->backlight_device = NULL;
+}
+
+static void eeepc_wmi_notify(u32 value, void *context)
+{
+	struct eeepc_wmi *eeepc = context;
+	struct acpi_buffer response = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *obj;
+	acpi_status status;
+	int code;
+	int orig_code;
+
+	status = wmi_get_event_data(value, &response);
+	if (status != AE_OK) {
+		pr_err("bad event status 0x%x\n", status);
+		return;
+	}
+
+	obj = (union acpi_object *)response.pointer;
+
+	if (obj && obj->type == ACPI_TYPE_INTEGER) {
+		code = obj->integer.value;
+		orig_code = code;
+
+		if (code >= NOTIFY_BRNUP_MIN && code <= NOTIFY_BRNUP_MAX)
+			code = NOTIFY_BRNUP_MIN;
+		else if (code >= NOTIFY_BRNDOWN_MIN &&
+			 code <= NOTIFY_BRNDOWN_MAX)
+			code = NOTIFY_BRNDOWN_MIN;
+
+		if (code == NOTIFY_BRNUP_MIN || code == NOTIFY_BRNDOWN_MIN) {
+			if (!acpi_video_backlight_support())
+				eeepc_wmi_backlight_notify(eeepc, orig_code);
+		}
+
+		if (!sparse_keymap_report_event(eeepc->inputdev,
+						code, 1, true))
+			pr_info("Unknown key %x pressed\n", code);
+	}
+
+	kfree(obj);
+}
+
 static int __devinit eeepc_wmi_platform_probe(struct platform_device *device)
 {
 	struct eeepc_wmi *eeepc;
@@ -151,7 +302,14 @@ static int __devinit eeepc_wmi_platform_probe(struct platform_device *device)
 
 	err = eeepc_wmi_input_init(eeepc);
 	if (err)
-		return err;
+		goto error_input;
+
+	if (!acpi_video_backlight_support()) {
+		err = eeepc_wmi_backlight_init(eeepc);
+		if (err)
+			goto error_backlight;
+	} else
+		pr_info("Backlight controlled by ACPI video driver\n");
 
 	status = wmi_install_notify_handler(EEEPC_WMI_EVENT_GUID,
 					eeepc_wmi_notify, eeepc);
@@ -165,8 +323,10 @@ static int __devinit eeepc_wmi_platform_probe(struct platform_device *device)
 	return 0;
 
 error_wmi:
+	eeepc_wmi_backlight_exit(eeepc);
+error_backlight:
 	eeepc_wmi_input_exit(eeepc);
-
+error_input:
 	return err;
 }
 
@@ -176,6 +336,7 @@ static int __devexit eeepc_wmi_platform_remove(struct platform_device *device)
 
 	eeepc = platform_get_drvdata(device);
 	wmi_remove_notify_handler(EEEPC_WMI_EVENT_GUID);
+	eeepc_wmi_backlight_exit(eeepc);
 	eeepc_wmi_input_exit(eeepc);
 
 	return 0;
@@ -195,7 +356,8 @@ static int __init eeepc_wmi_init(void)
 	struct eeepc_wmi *eeepc;
 	int err;
 
-	if (!wmi_has_guid(EEEPC_WMI_EVENT_GUID)) {
+	if (!wmi_has_guid(EEEPC_WMI_EVENT_GUID) ||
+	    !wmi_has_guid(EEEPC_WMI_MGMT_GUID)) {
 		pr_warning("No known WMI GUID found\n");
 		return -ENODEV;
 	}

commit 45f2c6937ed6066c9a177c4d37f6bd76daa607c0
Author: Yong Wang <yong.y.wang@linux.intel.com>
Date:   Sun Apr 11 09:27:19 2010 +0800

    eeepc-wmi: use a platform device as parent device of all sub-devices
    
    Add a platform device and use it as the parent device of all sub-devices.
    
    Signed-off-by: Yong Wang <yong.y.wang@intel.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Reviewed-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index daed4a476b39..0c9596c97a0f 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -32,9 +32,12 @@
 #include <linux/slab.h>
 #include <linux/input.h>
 #include <linux/input/sparse-keymap.h>
+#include <linux/platform_device.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
+#define	EEEPC_WMI_FILE	"eeepc-wmi"
+
 MODULE_AUTHOR("Yong Wang <yong.y.wang@intel.com>");
 MODULE_DESCRIPTION("Eee PC WMI Hotkey Driver");
 MODULE_LICENSE("GPL");
@@ -64,7 +67,7 @@ struct eeepc_wmi {
 	struct input_dev *inputdev;
 };
 
-static struct eeepc_wmi *eeepc;
+static struct platform_device *platform_device;
 
 static void eeepc_wmi_notify(u32 value, void *context)
 {
@@ -107,8 +110,9 @@ static int eeepc_wmi_input_init(struct eeepc_wmi *eeepc)
 		return -ENOMEM;
 
 	eeepc->inputdev->name = "Eee PC WMI hotkeys";
-	eeepc->inputdev->phys = "wmi/input0";
+	eeepc->inputdev->phys = EEEPC_WMI_FILE "/input0";
 	eeepc->inputdev->id.bustype = BUS_HOST;
+	eeepc->inputdev->dev.parent = &platform_device->dev;
 
 	err = sparse_keymap_setup(eeepc->inputdev, eeepc_wmi_keymap, NULL);
 	if (err)
@@ -137,11 +141,60 @@ static void eeepc_wmi_input_exit(struct eeepc_wmi *eeepc)
 	eeepc->inputdev = NULL;
 }
 
-static int __init eeepc_wmi_init(void)
+static int __devinit eeepc_wmi_platform_probe(struct platform_device *device)
 {
+	struct eeepc_wmi *eeepc;
 	int err;
 	acpi_status status;
 
+	eeepc = platform_get_drvdata(device);
+
+	err = eeepc_wmi_input_init(eeepc);
+	if (err)
+		return err;
+
+	status = wmi_install_notify_handler(EEEPC_WMI_EVENT_GUID,
+					eeepc_wmi_notify, eeepc);
+	if (ACPI_FAILURE(status)) {
+		pr_err("Unable to register notify handler - %d\n",
+			status);
+		err = -ENODEV;
+		goto error_wmi;
+	}
+
+	return 0;
+
+error_wmi:
+	eeepc_wmi_input_exit(eeepc);
+
+	return err;
+}
+
+static int __devexit eeepc_wmi_platform_remove(struct platform_device *device)
+{
+	struct eeepc_wmi *eeepc;
+
+	eeepc = platform_get_drvdata(device);
+	wmi_remove_notify_handler(EEEPC_WMI_EVENT_GUID);
+	eeepc_wmi_input_exit(eeepc);
+
+	return 0;
+}
+
+static struct platform_driver platform_driver = {
+	.driver = {
+		.name = EEEPC_WMI_FILE,
+		.owner = THIS_MODULE,
+	},
+	.probe = eeepc_wmi_platform_probe,
+	.remove = __devexit_p(eeepc_wmi_platform_remove),
+};
+
+static int __init eeepc_wmi_init(void)
+{
+	struct eeepc_wmi *eeepc;
+	int err;
+
 	if (!wmi_has_guid(EEEPC_WMI_EVENT_GUID)) {
 		pr_warning("No known WMI GUID found\n");
 		return -ENODEV;
@@ -151,29 +204,46 @@ static int __init eeepc_wmi_init(void)
 	if (!eeepc)
 		return -ENOMEM;
 
-	err = eeepc_wmi_input_init(eeepc);
+	platform_device = platform_device_alloc(EEEPC_WMI_FILE, -1);
+	if (!platform_device) {
+		pr_warning("Unable to allocate platform device\n");
+		err = -ENOMEM;
+		goto fail_platform;
+	}
+
+	err = platform_device_add(platform_device);
 	if (err) {
-		kfree(eeepc);
-		return err;
+		pr_warning("Unable to add platform device\n");
+		goto put_dev;
 	}
 
-	status = wmi_install_notify_handler(EEEPC_WMI_EVENT_GUID,
-					eeepc_wmi_notify, eeepc);
-	if (ACPI_FAILURE(status)) {
-		pr_err("Unable to register notify handler - %d\n",
-			status);
-		eeepc_wmi_input_exit(eeepc);
-		kfree(eeepc);
-		return -ENODEV;
+	platform_set_drvdata(platform_device, eeepc);
+
+	err = platform_driver_register(&platform_driver);
+	if (err) {
+		pr_warning("Unable to register platform driver\n");
+		goto del_dev;
 	}
 
 	return 0;
+
+del_dev:
+	platform_device_del(platform_device);
+put_dev:
+	platform_device_put(platform_device);
+fail_platform:
+	kfree(eeepc);
+
+	return err;
 }
 
 static void __exit eeepc_wmi_exit(void)
 {
-	wmi_remove_notify_handler(EEEPC_WMI_EVENT_GUID);
-	eeepc_wmi_input_exit(eeepc);
+	struct eeepc_wmi *eeepc;
+
+	eeepc = platform_get_drvdata(platform_device);
+	platform_driver_unregister(&platform_driver);
+	platform_device_unregister(platform_device);
 	kfree(eeepc);
 }
 

commit 8124888940be5d9d73a6e04970d73eaec7c582b7
Author: Yong Wang <yong.y.wang@linux.intel.com>
Date:   Sun Apr 11 09:26:33 2010 +0800

    eeepc-wmi: add an eeepc_wmi context structure
    
    Add an eeepc_wmi context structure to manage all the sub-devices
    that will be implemented later on. Put input device into it first.
    
    Signed-off-by: Yong Wang <yong.y.wang@intel.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Reviewed-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 9f8822658fd7..daed4a476b39 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -23,6 +23,8 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -58,10 +60,15 @@ static const struct key_entry eeepc_wmi_keymap[] = {
 	{ KE_END, 0},
 };
 
-static struct input_dev *eeepc_wmi_input_dev;
+struct eeepc_wmi {
+	struct input_dev *inputdev;
+};
+
+static struct eeepc_wmi *eeepc;
 
 static void eeepc_wmi_notify(u32 value, void *context)
 {
+	struct eeepc_wmi *eeepc = context;
 	struct acpi_buffer response = { ACPI_ALLOCATE_BUFFER, NULL };
 	union acpi_object *obj;
 	acpi_status status;
@@ -69,7 +76,7 @@ static void eeepc_wmi_notify(u32 value, void *context)
 
 	status = wmi_get_event_data(value, &response);
 	if (status != AE_OK) {
-		pr_err("EEEPC WMI: bad event status 0x%x\n", status);
+		pr_err("bad event status 0x%x\n", status);
 		return;
 	}
 
@@ -83,64 +90,80 @@ static void eeepc_wmi_notify(u32 value, void *context)
 		else if (code >= NOTIFY_BRNDOWN_MIN && code <= NOTIFY_BRNDOWN_MAX)
 			code = NOTIFY_BRNDOWN_MIN;
 
-		if (!sparse_keymap_report_event(eeepc_wmi_input_dev,
+		if (!sparse_keymap_report_event(eeepc->inputdev,
 						code, 1, true))
-			pr_info("EEEPC WMI: Unknown key %x pressed\n", code);
+			pr_info("Unknown key %x pressed\n", code);
 	}
 
 	kfree(obj);
 }
 
-static int eeepc_wmi_input_setup(void)
+static int eeepc_wmi_input_init(struct eeepc_wmi *eeepc)
 {
 	int err;
 
-	eeepc_wmi_input_dev = input_allocate_device();
-	if (!eeepc_wmi_input_dev)
+	eeepc->inputdev = input_allocate_device();
+	if (!eeepc->inputdev)
 		return -ENOMEM;
 
-	eeepc_wmi_input_dev->name = "Eee PC WMI hotkeys";
-	eeepc_wmi_input_dev->phys = "wmi/input0";
-	eeepc_wmi_input_dev->id.bustype = BUS_HOST;
+	eeepc->inputdev->name = "Eee PC WMI hotkeys";
+	eeepc->inputdev->phys = "wmi/input0";
+	eeepc->inputdev->id.bustype = BUS_HOST;
 
-	err = sparse_keymap_setup(eeepc_wmi_input_dev, eeepc_wmi_keymap, NULL);
+	err = sparse_keymap_setup(eeepc->inputdev, eeepc_wmi_keymap, NULL);
 	if (err)
 		goto err_free_dev;
 
-	err = input_register_device(eeepc_wmi_input_dev);
+	err = input_register_device(eeepc->inputdev);
 	if (err)
 		goto err_free_keymap;
 
 	return 0;
 
 err_free_keymap:
-	sparse_keymap_free(eeepc_wmi_input_dev);
+	sparse_keymap_free(eeepc->inputdev);
 err_free_dev:
-	input_free_device(eeepc_wmi_input_dev);
+	input_free_device(eeepc->inputdev);
 	return err;
 }
 
+static void eeepc_wmi_input_exit(struct eeepc_wmi *eeepc)
+{
+	if (eeepc->inputdev) {
+		sparse_keymap_free(eeepc->inputdev);
+		input_unregister_device(eeepc->inputdev);
+	}
+
+	eeepc->inputdev = NULL;
+}
+
 static int __init eeepc_wmi_init(void)
 {
 	int err;
 	acpi_status status;
 
 	if (!wmi_has_guid(EEEPC_WMI_EVENT_GUID)) {
-		pr_warning("EEEPC WMI: No known WMI GUID found\n");
+		pr_warning("No known WMI GUID found\n");
 		return -ENODEV;
 	}
 
-	err = eeepc_wmi_input_setup();
-	if (err)
+	eeepc = kzalloc(sizeof(struct eeepc_wmi), GFP_KERNEL);
+	if (!eeepc)
+		return -ENOMEM;
+
+	err = eeepc_wmi_input_init(eeepc);
+	if (err) {
+		kfree(eeepc);
 		return err;
+	}
 
 	status = wmi_install_notify_handler(EEEPC_WMI_EVENT_GUID,
-					eeepc_wmi_notify, NULL);
+					eeepc_wmi_notify, eeepc);
 	if (ACPI_FAILURE(status)) {
-		sparse_keymap_free(eeepc_wmi_input_dev);
-		input_unregister_device(eeepc_wmi_input_dev);
-		pr_err("EEEPC WMI: Unable to register notify handler - %d\n",
+		pr_err("Unable to register notify handler - %d\n",
 			status);
+		eeepc_wmi_input_exit(eeepc);
+		kfree(eeepc);
 		return -ENODEV;
 	}
 
@@ -150,8 +173,8 @@ static int __init eeepc_wmi_init(void)
 static void __exit eeepc_wmi_exit(void)
 {
 	wmi_remove_notify_handler(EEEPC_WMI_EVENT_GUID);
-	sparse_keymap_free(eeepc_wmi_input_dev);
-	input_unregister_device(eeepc_wmi_input_dev);
+	eeepc_wmi_input_exit(eeepc);
+	kfree(eeepc);
 }
 
 module_init(eeepc_wmi_init);

commit a32f3926632e71c8aa23ce32fe2625f8d5f792c2
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Apr 5 11:37:59 2010 +0900

    eeepc-wmi: include slab.h
    
    eeepc-wmi uses kfree() but doesn't include slab.h.  Include it.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Yong Wang <yong.y.wang@intel.com>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
index 2466b7b7fb0e..9f8822658fd7 100644
--- a/drivers/platform/x86/eeepc-wmi.c
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -27,6 +27,7 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/types.h>
+#include <linux/slab.h>
 #include <linux/input.h>
 #include <linux/input/sparse-keymap.h>
 #include <acpi/acpi_bus.h>

commit ee027e4aed3077c4bb3b585c67528eec0e7222df
Author: Yong Wang <yong.y.wang@linux.intel.com>
Date:   Sun Mar 21 10:26:34 2010 +0800

    eeepc-wmi: new driver for WMI based hotkeys on Eee PC laptops
    
    Add a WMI driver for Eee PC laptops. Currently it only supports hotkeys.
    
    Signed-off-by: Yong Wang <yong.y.wang@intel.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Acked-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/platform/x86/eeepc-wmi.c b/drivers/platform/x86/eeepc-wmi.c
new file mode 100644
index 000000000000..2466b7b7fb0e
--- /dev/null
+++ b/drivers/platform/x86/eeepc-wmi.c
@@ -0,0 +1,157 @@
+/*
+ * Eee PC WMI hotkey driver
+ *
+ * Copyright(C) 2010 Intel Corporation.
+ *
+ * Portions based on wistron_btns.c:
+ * Copyright (C) 2005 Miloslav Trmac <mitr@volny.cz>
+ * Copyright (C) 2005 Bernhard Rosenkraenzer <bero@arklinux.org>
+ * Copyright (C) 2005 Dmitry Torokhov <dtor@mail.ru>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/input/sparse-keymap.h>
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+
+MODULE_AUTHOR("Yong Wang <yong.y.wang@intel.com>");
+MODULE_DESCRIPTION("Eee PC WMI Hotkey Driver");
+MODULE_LICENSE("GPL");
+
+#define EEEPC_WMI_EVENT_GUID	"ABBC0F72-8EA1-11D1-00A0-C90629100000"
+
+MODULE_ALIAS("wmi:"EEEPC_WMI_EVENT_GUID);
+
+#define NOTIFY_BRNUP_MIN	0x11
+#define NOTIFY_BRNUP_MAX	0x1f
+#define NOTIFY_BRNDOWN_MIN	0x20
+#define NOTIFY_BRNDOWN_MAX	0x2e
+
+static const struct key_entry eeepc_wmi_keymap[] = {
+	/* Sleep already handled via generic ACPI code */
+	{ KE_KEY, 0x5d, { KEY_WLAN } },
+	{ KE_KEY, 0x32, { KEY_MUTE } },
+	{ KE_KEY, 0x31, { KEY_VOLUMEDOWN } },
+	{ KE_KEY, 0x30, { KEY_VOLUMEUP } },
+	{ KE_IGNORE, NOTIFY_BRNDOWN_MIN, { KEY_BRIGHTNESSDOWN } },
+	{ KE_IGNORE, NOTIFY_BRNUP_MIN, { KEY_BRIGHTNESSUP } },
+	{ KE_KEY, 0xcc, { KEY_SWITCHVIDEOMODE } },
+	{ KE_END, 0},
+};
+
+static struct input_dev *eeepc_wmi_input_dev;
+
+static void eeepc_wmi_notify(u32 value, void *context)
+{
+	struct acpi_buffer response = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *obj;
+	acpi_status status;
+	int code;
+
+	status = wmi_get_event_data(value, &response);
+	if (status != AE_OK) {
+		pr_err("EEEPC WMI: bad event status 0x%x\n", status);
+		return;
+	}
+
+	obj = (union acpi_object *)response.pointer;
+
+	if (obj && obj->type == ACPI_TYPE_INTEGER) {
+		code = obj->integer.value;
+
+		if (code >= NOTIFY_BRNUP_MIN && code <= NOTIFY_BRNUP_MAX)
+			code = NOTIFY_BRNUP_MIN;
+		else if (code >= NOTIFY_BRNDOWN_MIN && code <= NOTIFY_BRNDOWN_MAX)
+			code = NOTIFY_BRNDOWN_MIN;
+
+		if (!sparse_keymap_report_event(eeepc_wmi_input_dev,
+						code, 1, true))
+			pr_info("EEEPC WMI: Unknown key %x pressed\n", code);
+	}
+
+	kfree(obj);
+}
+
+static int eeepc_wmi_input_setup(void)
+{
+	int err;
+
+	eeepc_wmi_input_dev = input_allocate_device();
+	if (!eeepc_wmi_input_dev)
+		return -ENOMEM;
+
+	eeepc_wmi_input_dev->name = "Eee PC WMI hotkeys";
+	eeepc_wmi_input_dev->phys = "wmi/input0";
+	eeepc_wmi_input_dev->id.bustype = BUS_HOST;
+
+	err = sparse_keymap_setup(eeepc_wmi_input_dev, eeepc_wmi_keymap, NULL);
+	if (err)
+		goto err_free_dev;
+
+	err = input_register_device(eeepc_wmi_input_dev);
+	if (err)
+		goto err_free_keymap;
+
+	return 0;
+
+err_free_keymap:
+	sparse_keymap_free(eeepc_wmi_input_dev);
+err_free_dev:
+	input_free_device(eeepc_wmi_input_dev);
+	return err;
+}
+
+static int __init eeepc_wmi_init(void)
+{
+	int err;
+	acpi_status status;
+
+	if (!wmi_has_guid(EEEPC_WMI_EVENT_GUID)) {
+		pr_warning("EEEPC WMI: No known WMI GUID found\n");
+		return -ENODEV;
+	}
+
+	err = eeepc_wmi_input_setup();
+	if (err)
+		return err;
+
+	status = wmi_install_notify_handler(EEEPC_WMI_EVENT_GUID,
+					eeepc_wmi_notify, NULL);
+	if (ACPI_FAILURE(status)) {
+		sparse_keymap_free(eeepc_wmi_input_dev);
+		input_unregister_device(eeepc_wmi_input_dev);
+		pr_err("EEEPC WMI: Unable to register notify handler - %d\n",
+			status);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static void __exit eeepc_wmi_exit(void)
+{
+	wmi_remove_notify_handler(EEEPC_WMI_EVENT_GUID);
+	sparse_keymap_free(eeepc_wmi_input_dev);
+	input_unregister_device(eeepc_wmi_input_dev);
+}
+
+module_init(eeepc_wmi_init);
+module_exit(eeepc_wmi_exit);
