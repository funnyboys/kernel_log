commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/platform/x86/asus-wireless.c b/drivers/platform/x86/asus-wireless.c
index 7458f7602d5e..d3e7171928e5 100644
--- a/drivers/platform/x86/asus-wireless.c
+++ b/drivers/platform/x86/asus-wireless.c
@@ -1,11 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Asus Wireless Radio Control Driver
  *
  * Copyright (C) 2015-2016 Endless Mobile, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/kernel.h>

commit eca4c4e47eb0658ad251f0bff465e23c055377da
Author: João Paulo Rechi Vita <jprvita@gmail.com>
Date:   Fri Jun 29 15:12:46 2018 -0700

    platform/x86: asus-wireless: Fix uninitialized symbol usage
    
    'ret' will not be initialized if acpi_evaluate_integer() returns through
    an error path, so it should not be used in this case. This fixes the
    following Smatch static analyser error:
    
     drivers/platform/x86/asus-wireless.c:76 asus_wireless_method() error:
                                                         uninitialized symbol 'ret'.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: João Paulo Rechi Vita <jprvita@endlessm.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wireless.c b/drivers/platform/x86/asus-wireless.c
index 0e9f5ec13474..7458f7602d5e 100644
--- a/drivers/platform/x86/asus-wireless.c
+++ b/drivers/platform/x86/asus-wireless.c
@@ -52,13 +52,12 @@ static const struct acpi_device_id device_ids[] = {
 };
 MODULE_DEVICE_TABLE(acpi, device_ids);
 
-static u64 asus_wireless_method(acpi_handle handle, const char *method,
-				int param)
+static acpi_status asus_wireless_method(acpi_handle handle, const char *method,
+					int param, u64 *ret)
 {
 	struct acpi_object_list p;
 	union acpi_object obj;
 	acpi_status s;
-	u64 ret;
 
 	acpi_handle_debug(handle, "Evaluating method %s, parameter %#x\n",
 			  method, param);
@@ -67,24 +66,27 @@ static u64 asus_wireless_method(acpi_handle handle, const char *method,
 	p.count = 1;
 	p.pointer = &obj;
 
-	s = acpi_evaluate_integer(handle, (acpi_string) method, &p, &ret);
+	s = acpi_evaluate_integer(handle, (acpi_string) method, &p, ret);
 	if (ACPI_FAILURE(s))
 		acpi_handle_err(handle,
 				"Failed to eval method %s, param %#x (%d)\n",
 				method, param, s);
-	acpi_handle_debug(handle, "%s returned %#llx\n", method, ret);
-	return ret;
+	else
+		acpi_handle_debug(handle, "%s returned %#llx\n", method, *ret);
+
+	return s;
 }
 
 static enum led_brightness led_state_get(struct led_classdev *led)
 {
 	struct asus_wireless_data *data;
-	int s;
+	acpi_status s;
+	u64 ret;
 
 	data = container_of(led, struct asus_wireless_data, led);
 	s = asus_wireless_method(acpi_device_handle(data->adev), "HSWC",
-				 data->hswc_params->status);
-	if (s == data->hswc_params->on)
+				 data->hswc_params->status, &ret);
+	if (ACPI_SUCCESS(s) && ret == data->hswc_params->on)
 		return LED_FULL;
 	return LED_OFF;
 }
@@ -92,10 +94,11 @@ static enum led_brightness led_state_get(struct led_classdev *led)
 static void led_state_update(struct work_struct *work)
 {
 	struct asus_wireless_data *data;
+	u64 ret;
 
 	data = container_of(work, struct asus_wireless_data, led_work);
 	asus_wireless_method(acpi_device_handle(data->adev), "HSWC",
-			     data->led_state);
+			     data->led_state, &ret);
 }
 
 static void led_state_set(struct led_classdev *led, enum led_brightness value)

commit 6bb6ec285df9a20128f8b0ed7cdaad7152208eb8
Author: João Paulo Rechi Vita <jprvita@gmail.com>
Date:   Fri Jun 29 17:11:38 2018 -0700

    platform/x86: asus-wireless: Toggle airplane mode LED
    
    This commit makes use of a newly implemented RFKill LED trigger to
    trigger the LED when all radios are blocked.
    
    Signed-off-by: João Paulo Rechi Vita <jprvita@endlessm.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wireless.c b/drivers/platform/x86/asus-wireless.c
index 6afd011de9e5..0e9f5ec13474 100644
--- a/drivers/platform/x86/asus-wireless.c
+++ b/drivers/platform/x86/asus-wireless.c
@@ -167,6 +167,7 @@ static int asus_wireless_add(struct acpi_device *adev)
 	data->led.brightness_get = led_state_get;
 	data->led.flags = LED_CORE_SUSPENDRESUME;
 	data->led.max_brightness = 1;
+	data->led.default_trigger = "rfkill-none";
 	err = devm_led_classdev_register(&adev->dev, &data->led);
 	if (err)
 		destroy_workqueue(data->wq);

commit cc5cceff288f8d8b45c7790e38190d3ca4d3dec0
Author: João Paulo Rechi Vita <jprvita@gmail.com>
Date:   Tue May 22 14:29:56 2018 -0700

    platform/x86: asus-wireless: Fix format specifier
    
    u64 should be printed with %llx instead of %x and cast to uint.
    
    Signed-off-by: João Paulo Rechi Vita <jprvita@gmail.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wireless.c b/drivers/platform/x86/asus-wireless.c
index f086469ea740..6afd011de9e5 100644
--- a/drivers/platform/x86/asus-wireless.c
+++ b/drivers/platform/x86/asus-wireless.c
@@ -72,7 +72,7 @@ static u64 asus_wireless_method(acpi_handle handle, const char *method,
 		acpi_handle_err(handle,
 				"Failed to eval method %s, param %#x (%d)\n",
 				method, param, s);
-	acpi_handle_debug(handle, "%s returned %#x\n", method, (uint) ret);
+	acpi_handle_debug(handle, "%s returned %#llx\n", method, ret);
 	return ret;
 }
 

commit 06b8b00b33a145ef5d708ff971cfdb83c8e480c0
Author: João Paulo Rechi Vita <jprvita@gmail.com>
Date:   Thu Apr 19 07:04:34 2018 -0700

    platform/x86: asus-wireless: Fix NULL pointer dereference
    
    When the module is removed the led workqueue is destroyed in the remove
    callback, before the led device is unregistered from the led subsystem.
    
    This leads to a NULL pointer derefence when the led device is
    unregistered automatically later as part of the module removal cleanup.
    Bellow is the backtrace showing the problem.
    
      BUG: unable to handle kernel NULL pointer dereference at           (null)
      IP: __queue_work+0x8c/0x410
      PGD 0 P4D 0
      Oops: 0000 [#1] SMP NOPTI
      Modules linked in: ccm edac_mce_amd kvm_amd kvm irqbypass crct10dif_pclmul crc32_pclmul ghash_clmulni_intel pcbc aesni_intel aes_x86_64 joydev crypto_simd asus_nb_wmi glue_helper uvcvideo snd_hda_codec_conexant snd_hda_codec_generic snd_hda_codec_hdmi snd_hda_intel asus_wmi snd_hda_codec cryptd snd_hda_core sparse_keymap videobuf2_vmalloc arc4 videobuf2_memops snd_hwdep input_leds videobuf2_v4l2 ath9k psmouse videobuf2_core videodev ath9k_common snd_pcm ath9k_hw media fam15h_power ath k10temp snd_timer mac80211 i2c_piix4 r8169 mii mac_hid cfg80211 asus_wireless(-) snd soundcore wmi shpchp 8250_dw ip_tables x_tables amdkfd amd_iommu_v2 amdgpu radeon chash i2c_algo_bit drm_kms_helper syscopyarea serio_raw sysfillrect sysimgblt fb_sys_fops ahci ttm libahci drm video
      CPU: 3 PID: 2177 Comm: rmmod Not tainted 4.15.0-5-generic #6+dev94.b4287e5bem1-Endless
      Hardware name: ASUSTeK COMPUTER INC. X555DG/X555DG, BIOS 5.011 05/05/2015
      RIP: 0010:__queue_work+0x8c/0x410
      RSP: 0018:ffffbe8cc249fcd8 EFLAGS: 00010086
      RAX: ffff992ac6810800 RBX: 0000000000000000 RCX: 0000000000000008
      RDX: 0000000000000000 RSI: 0000000000000008 RDI: ffff992ac6400e18
      RBP: ffffbe8cc249fd18 R08: ffff992ac6400db0 R09: 0000000000000000
      R10: 0000000000000040 R11: ffff992ac6400dd8 R12: 0000000000002000
      R13: ffff992abd762e00 R14: ffff992abd763e38 R15: 000000000001ebe0
      FS:  00007f318203e700(0000) GS:ffff992aced80000(0000) knlGS:0000000000000000
      CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
      CR2: 0000000000000000 CR3: 00000001c720e000 CR4: 00000000001406e0
      Call Trace:
       queue_work_on+0x38/0x40
       led_state_set+0x2c/0x40 [asus_wireless]
       led_set_brightness_nopm+0x14/0x40
       led_set_brightness+0x37/0x60
       led_trigger_set+0xfc/0x1d0
       led_classdev_unregister+0x32/0xd0
       devm_led_classdev_release+0x11/0x20
       release_nodes+0x109/0x1f0
       devres_release_all+0x3c/0x50
       device_release_driver_internal+0x16d/0x220
       driver_detach+0x3f/0x80
       bus_remove_driver+0x55/0xd0
       driver_unregister+0x2c/0x40
       acpi_bus_unregister_driver+0x15/0x20
       asus_wireless_driver_exit+0x10/0xb7c [asus_wireless]
       SyS_delete_module+0x1da/0x2b0
       entry_SYSCALL_64_fastpath+0x24/0x87
      RIP: 0033:0x7f3181b65fd7
      RSP: 002b:00007ffe74bcbe18 EFLAGS: 00000206 ORIG_RAX: 00000000000000b0
      RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f3181b65fd7
      RDX: 000000000000000a RSI: 0000000000000800 RDI: 0000555ea2559258
      RBP: 0000555ea25591f0 R08: 00007ffe74bcad91 R09: 000000000000000a
      R10: 0000000000000000 R11: 0000000000000206 R12: 0000000000000003
      R13: 00007ffe74bcae00 R14: 0000000000000000 R15: 0000555ea25591f0
      Code: 01 00 00 02 0f 85 7d 01 00 00 48 63 45 d4 48 c7 c6 00 f4 fa 87 49 8b 9d 08 01 00 00 48 03 1c c6 4c 89 f7 e8 87 fb ff ff 48 85 c0 <48> 8b 3b 0f 84 c5 01 00 00 48 39 f8 0f 84 bc 01 00 00 48 89 c7
      RIP: __queue_work+0x8c/0x410 RSP: ffffbe8cc249fcd8
      CR2: 0000000000000000
      ---[ end trace 7aa4f4a232e9c39c ]---
    
    Unregistering the led device on the remove callback before destroying the
    workqueue avoids this problem.
    
    https://bugzilla.kernel.org/show_bug.cgi?id=196097
    
    Reported-by: Dun Hum <bitter.taste@gmx.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: João Paulo Rechi Vita <jprvita@endlessm.com>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/asus-wireless.c b/drivers/platform/x86/asus-wireless.c
index d4aeac3477f5..f086469ea740 100644
--- a/drivers/platform/x86/asus-wireless.c
+++ b/drivers/platform/x86/asus-wireless.c
@@ -178,8 +178,10 @@ static int asus_wireless_remove(struct acpi_device *adev)
 {
 	struct asus_wireless_data *data = acpi_driver_data(adev);
 
-	if (data->wq)
+	if (data->wq) {
+		devm_led_classdev_unregister(&adev->dev, &data->led);
 		destroy_workqueue(data->wq);
+	}
 	return 0;
 }
 

commit bff5bf9db1c9453ffd0a78abed3e2d040c092fd9
Author: Peter Hutterer <peter.hutterer@who-t.net>
Date:   Mon Dec 4 10:26:17 2017 +1000

    platform/x86: asus-wireless: send an EV_SYN/SYN_REPORT between state changes
    
    Sending the switch state change twice within the same frame is invalid
    evdev protocol and only works if the client handles keys immediately as
    well. Processing events immediately is incorrect, it forces a fake
    order of events that does not exist on the device.
    
    Recent versions of libinput changed to only process the device state and
    SYN_REPORT time, so now the key event is lost.
    
    https://bugs.freedesktop.org/show_bug.cgi?id=104041
    
    Signed-off-by: Peter Hutterer <peter.hutterer@who-t.net>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/asus-wireless.c b/drivers/platform/x86/asus-wireless.c
index f3796164329e..d4aeac3477f5 100644
--- a/drivers/platform/x86/asus-wireless.c
+++ b/drivers/platform/x86/asus-wireless.c
@@ -118,6 +118,7 @@ static void asus_wireless_notify(struct acpi_device *adev, u32 event)
 		return;
 	}
 	input_report_key(data->idev, KEY_RFKILL, 1);
+	input_sync(data->idev);
 	input_report_key(data->idev, KEY_RFKILL, 0);
 	input_sync(data->idev);
 }

commit 4ac20e62efc6b8a63a1a534ddf236af7fe8849b5
Author: João Paulo Rechi Vita <jprvita@gmail.com>
Date:   Mon Feb 6 10:20:21 2017 -0500

    platform/x86: asus-wireless: Fix indentation
    
    Fix indentation problem introduced when this driver was first merged into
    the kernel.
    
    Signed-off-by: João Paulo Rechi Vita <jprvita@endlessm.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wireless.c b/drivers/platform/x86/asus-wireless.c
index 9fd43b75339d..f3796164329e 100644
--- a/drivers/platform/x86/asus-wireless.c
+++ b/drivers/platform/x86/asus-wireless.c
@@ -98,8 +98,7 @@ static void led_state_update(struct work_struct *work)
 			     data->led_state);
 }
 
-static void led_state_set(struct led_classdev *led,
-				  enum led_brightness value)
+static void led_state_set(struct led_classdev *led, enum led_brightness value)
 {
 	struct asus_wireless_data *data;
 

commit 4b7fb9fcf917f7eda8da8f2bf335539067772c4d
Author: João Paulo Rechi Vita <jprvita@gmail.com>
Date:   Tue Feb 7 16:45:10 2017 -0500

    platform/x86: asus-wireless: Use per-HID HSWC parameters
    
    Some Asus machines use 0x4/0x5 as their LED on/off values, while others
    use 0x0/0x1, as shown in the DSDT excerpts below. Luckily it seems this
    behavior is tied to different HIDs, after looking at 44 DSDTs from
    different Asus models.
    
    Another small difference is that a few of them call GWBL instead of
    OWGS, and SWBL instead of OWGD. That does not seem to make a difference
    for asus-wireless, and is additional reasoning to not try to call these
    methods directly.
    
    Device (ASHS)                       | Device (ASHS)
    {                                   | {
        Name (_HID, "ATK4002")          |     Name (_HID, "ATK4001")
        Method (HSWC, 1, Serialized)    |     Method (HSWC, 1, Serialized)
        {                               |     {
            If ((Arg0 < 0x02))          |         If ((Arg0 < 0x02))
            {                           |         {
                OWGD (Arg0)             |             OWGD (Arg0)
                Return (One)            |             Return (One)
            }                           |         }
            If ((Arg0 == 0x02))         |
            {                           |         If ((Arg0 == 0x02))
                Local0 = OWGS ()        |         {
                If (Local0)             |             Return (OWGS ())
                {                       |         }
                        Return (0x05)   |
                }                       |         If ((Arg0 == 0x03))
                Else                    |         {
                {                       |             Return (0xFF)
                        Return (0x04)   |         }
                }                       |
            }                           |         If ((Arg0 == 0x80))
            If ((Arg0 == 0x03))         |         {
            {                           |            Return (One)
                Return (0xFF)           |         }
            }                           |     }
            If ((Arg0 == 0x04))         |     Method (_STA, 0, NotSerialized)
            {                           |     {
                OWGD (Zero)             |         If ((MSOS () >= OSW8))
                Return (One)            |         {
            }                           |             Return (0x0F)
            If ((Arg0 == 0x05))         |         }
            {                           |         Else
                OWGD (One)              |         {
                Return (One)            |             Return (Zero)
            }                           |         }
            If ((Arg0 == 0x80))         |     }
            {                           | }
                Return (One)            |
            }                           |
        }                               |
        Method (_STA, 0, NotSerialized) |
        {                               |
            If ((MSOS () >= OSW8))      |
            {                           |
                Return (0x0F)           |
            }                           |
            Else                        |
            {                           |
                Return (Zero)           |
            }                           |
        }                               |
    }                                   |
    
    Signed-off-by: João Paulo Rechi Vita <jprvita@endlessm.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wireless.c b/drivers/platform/x86/asus-wireless.c
index 9f31bc1a47d0..9fd43b75339d 100644
--- a/drivers/platform/x86/asus-wireless.c
+++ b/drivers/platform/x86/asus-wireless.c
@@ -17,19 +17,41 @@
 #include <linux/pci_ids.h>
 #include <linux/leds.h>
 
-#define ASUS_WIRELESS_LED_STATUS 0x2
-#define ASUS_WIRELESS_LED_OFF 0x4
-#define ASUS_WIRELESS_LED_ON 0x5
+struct hswc_params {
+	u8 on;
+	u8 off;
+	u8 status;
+};
 
 struct asus_wireless_data {
 	struct input_dev *idev;
 	struct acpi_device *adev;
+	const struct hswc_params *hswc_params;
 	struct workqueue_struct *wq;
 	struct work_struct led_work;
 	struct led_classdev led;
 	int led_state;
 };
 
+static const struct hswc_params atk4001_id_params = {
+	.on = 0x0,
+	.off = 0x1,
+	.status = 0x2,
+};
+
+static const struct hswc_params atk4002_id_params = {
+	.on = 0x5,
+	.off = 0x4,
+	.status = 0x2,
+};
+
+static const struct acpi_device_id device_ids[] = {
+	{"ATK4001", (kernel_ulong_t)&atk4001_id_params},
+	{"ATK4002", (kernel_ulong_t)&atk4002_id_params},
+	{"", 0},
+};
+MODULE_DEVICE_TABLE(acpi, device_ids);
+
 static u64 asus_wireless_method(acpi_handle handle, const char *method,
 				int param)
 {
@@ -61,8 +83,8 @@ static enum led_brightness led_state_get(struct led_classdev *led)
 
 	data = container_of(led, struct asus_wireless_data, led);
 	s = asus_wireless_method(acpi_device_handle(data->adev), "HSWC",
-				 ASUS_WIRELESS_LED_STATUS);
-	if (s == ASUS_WIRELESS_LED_ON)
+				 data->hswc_params->status);
+	if (s == data->hswc_params->on)
 		return LED_FULL;
 	return LED_OFF;
 }
@@ -82,8 +104,8 @@ static void led_state_set(struct led_classdev *led,
 	struct asus_wireless_data *data;
 
 	data = container_of(led, struct asus_wireless_data, led);
-	data->led_state = value == LED_OFF ? ASUS_WIRELESS_LED_OFF :
-					     ASUS_WIRELESS_LED_ON;
+	data->led_state = value == LED_OFF ? data->hswc_params->off :
+					     data->hswc_params->on;
 	queue_work(data->wq, &data->led_work);
 }
 
@@ -104,12 +126,14 @@ static void asus_wireless_notify(struct acpi_device *adev, u32 event)
 static int asus_wireless_add(struct acpi_device *adev)
 {
 	struct asus_wireless_data *data;
+	const struct acpi_device_id *id;
 	int err;
 
 	data = devm_kzalloc(&adev->dev, sizeof(*data), GFP_KERNEL);
 	if (!data)
 		return -ENOMEM;
 	adev->driver_data = data;
+	data->adev = adev;
 
 	data->idev = devm_input_allocate_device(&adev->dev);
 	if (!data->idev)
@@ -124,7 +148,16 @@ static int asus_wireless_add(struct acpi_device *adev)
 	if (err)
 		return err;
 
-	data->adev = adev;
+	for (id = device_ids; id->id[0]; id++) {
+		if (!strcmp((char *) id->id, acpi_device_hid(adev))) {
+			data->hswc_params =
+				(const struct hswc_params *)id->driver_data;
+			break;
+		}
+	}
+	if (!data->hswc_params)
+		return 0;
+
 	data->wq = create_singlethread_workqueue("asus_wireless_workqueue");
 	if (!data->wq)
 		return -ENOMEM;
@@ -137,6 +170,7 @@ static int asus_wireless_add(struct acpi_device *adev)
 	err = devm_led_classdev_register(&adev->dev, &data->led);
 	if (err)
 		destroy_workqueue(data->wq);
+
 	return err;
 }
 
@@ -149,13 +183,6 @@ static int asus_wireless_remove(struct acpi_device *adev)
 	return 0;
 }
 
-static const struct acpi_device_id device_ids[] = {
-	{"ATK4001", 0},
-	{"ATK4002", 0},
-	{"", 0},
-};
-MODULE_DEVICE_TABLE(acpi, device_ids);
-
 static struct acpi_driver asus_wireless_driver = {
 	.name = "Asus Wireless Radio Control Driver",
 	.class = "hotkey",

commit 2c1a49c961237ed8758af3188673b0e9a8826ac6
Author: João Paulo Rechi Vita <jprvita@gmail.com>
Date:   Mon Jun 13 16:57:30 2016 -0400

    asus-wireless: Toggle airplane mode LED
    
    In the ASHS device we have the HSWC method, which calls either OWGD or
    OWGS, depending on its parameter:
    
            Device (ASHS)
            {
                    Name (_HID, "ATK4002")  // _HID: Hardware ID
                    Method (HSWC, 1, Serialized)
                    {
                            If ((Arg0 < 0x02))
                            {
                                    OWGD (Arg0)
                                    Return (One)
                            }
                            If ((Arg0 == 0x02))
                            {
                                    Local0 = OWGS ()
                                    If (Local0)
                                    {
                                            Return (0x05)
                                    }
                                    Else
                                    {
                                            Return (0x04)
                                    }
                            }
                            If ((Arg0 == 0x03))
                            {
                                    Return (0xFF)
                            }
                            If ((Arg0 == 0x04))
                            {
                                    OWGD (Zero)
                                    Return (One)
                            }
                            If ((Arg0 == 0x05))
                            {
                                    OWGD (One)
                                    Return (One)
                            }
                            If ((Arg0 == 0x80))
                            {
                                    Return (One)
                            }
                    }
                    Method (_STA, 0, NotSerialized)  // _STA: Status
                    {
                            If ((MSOS () >= OSW8))
                            {
                                    Return (0x0F)
                            }
                            Else
                            {
                                    Return (Zero)
                            }
                    }
            }
    
    On the Asus laptops that do not have an airplane mode LED, OWGD has an
    empty implementation and OWGS simply returns 0. On the ones that have an
    airplane mode LED these methods have the following implementation:
    
            Method (OWGD, 1, Serialized)
            {
                    SGPL (0x0203000F, Arg0)
                    SGPL (0x0203000F, Arg0)
            }
    
            Method (OWGS, 0, Serialized)
            {
                    Store (RGPL (0x0203000F), Local0)
                    Return (Local0)
            }
    
    Where OWGD(1) sets the airplane mode LED ON, OWGD(0) set it off, and
    OWGS() returns its state.
    
    This commit exposes the airplane mode indicator LED to userspace under
    the name asus-wireless::airplane, so it can be driven according to
    userspace's policy.
    
    Signed-off-by: João Paulo Rechi Vita <jprvita@endlessm.com>
    Reviewed-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wireless.c b/drivers/platform/x86/asus-wireless.c
index 9ec721e26532..9f31bc1a47d0 100644
--- a/drivers/platform/x86/asus-wireless.c
+++ b/drivers/platform/x86/asus-wireless.c
@@ -15,11 +15,78 @@
 #include <linux/acpi.h>
 #include <linux/input.h>
 #include <linux/pci_ids.h>
+#include <linux/leds.h>
+
+#define ASUS_WIRELESS_LED_STATUS 0x2
+#define ASUS_WIRELESS_LED_OFF 0x4
+#define ASUS_WIRELESS_LED_ON 0x5
 
 struct asus_wireless_data {
 	struct input_dev *idev;
+	struct acpi_device *adev;
+	struct workqueue_struct *wq;
+	struct work_struct led_work;
+	struct led_classdev led;
+	int led_state;
 };
 
+static u64 asus_wireless_method(acpi_handle handle, const char *method,
+				int param)
+{
+	struct acpi_object_list p;
+	union acpi_object obj;
+	acpi_status s;
+	u64 ret;
+
+	acpi_handle_debug(handle, "Evaluating method %s, parameter %#x\n",
+			  method, param);
+	obj.type = ACPI_TYPE_INTEGER;
+	obj.integer.value = param;
+	p.count = 1;
+	p.pointer = &obj;
+
+	s = acpi_evaluate_integer(handle, (acpi_string) method, &p, &ret);
+	if (ACPI_FAILURE(s))
+		acpi_handle_err(handle,
+				"Failed to eval method %s, param %#x (%d)\n",
+				method, param, s);
+	acpi_handle_debug(handle, "%s returned %#x\n", method, (uint) ret);
+	return ret;
+}
+
+static enum led_brightness led_state_get(struct led_classdev *led)
+{
+	struct asus_wireless_data *data;
+	int s;
+
+	data = container_of(led, struct asus_wireless_data, led);
+	s = asus_wireless_method(acpi_device_handle(data->adev), "HSWC",
+				 ASUS_WIRELESS_LED_STATUS);
+	if (s == ASUS_WIRELESS_LED_ON)
+		return LED_FULL;
+	return LED_OFF;
+}
+
+static void led_state_update(struct work_struct *work)
+{
+	struct asus_wireless_data *data;
+
+	data = container_of(work, struct asus_wireless_data, led_work);
+	asus_wireless_method(acpi_device_handle(data->adev), "HSWC",
+			     data->led_state);
+}
+
+static void led_state_set(struct led_classdev *led,
+				  enum led_brightness value)
+{
+	struct asus_wireless_data *data;
+
+	data = container_of(led, struct asus_wireless_data, led);
+	data->led_state = value == LED_OFF ? ASUS_WIRELESS_LED_OFF :
+					     ASUS_WIRELESS_LED_ON;
+	queue_work(data->wq, &data->led_work);
+}
+
 static void asus_wireless_notify(struct acpi_device *adev, u32 event)
 {
 	struct asus_wireless_data *data = acpi_driver_data(adev);
@@ -37,6 +104,7 @@ static void asus_wireless_notify(struct acpi_device *adev, u32 event)
 static int asus_wireless_add(struct acpi_device *adev)
 {
 	struct asus_wireless_data *data;
+	int err;
 
 	data = devm_kzalloc(&adev->dev, sizeof(*data), GFP_KERNEL);
 	if (!data)
@@ -52,11 +120,32 @@ static int asus_wireless_add(struct acpi_device *adev)
 	data->idev->id.vendor = PCI_VENDOR_ID_ASUSTEK;
 	set_bit(EV_KEY, data->idev->evbit);
 	set_bit(KEY_RFKILL, data->idev->keybit);
-	return input_register_device(data->idev);
+	err = input_register_device(data->idev);
+	if (err)
+		return err;
+
+	data->adev = adev;
+	data->wq = create_singlethread_workqueue("asus_wireless_workqueue");
+	if (!data->wq)
+		return -ENOMEM;
+	INIT_WORK(&data->led_work, led_state_update);
+	data->led.name = "asus-wireless::airplane";
+	data->led.brightness_set = led_state_set;
+	data->led.brightness_get = led_state_get;
+	data->led.flags = LED_CORE_SUSPENDRESUME;
+	data->led.max_brightness = 1;
+	err = devm_led_classdev_register(&adev->dev, &data->led);
+	if (err)
+		destroy_workqueue(data->wq);
+	return err;
 }
 
 static int asus_wireless_remove(struct acpi_device *adev)
 {
+	struct asus_wireless_data *data = acpi_driver_data(adev);
+
+	if (data->wq)
+		destroy_workqueue(data->wq);
 	return 0;
 }
 

commit b0a095fc193a5f257c3609b09298c0705fc32c0b
Author: João Paulo Rechi Vita <jprvita@gmail.com>
Date:   Tue Jan 5 08:26:01 2016 -0500

    asus-wireless: Add ACPI HID ATK4001
    
    As reported in https://bugzilla.kernel.org/show_bug.cgi?id=98931#c22 in
    the Asus UX31A the Asus Wireless Radio Control device (ASHS) uses the
    HID "ATK4001".
    
    Signed-off-by: João Paulo Rechi Vita <jprvita@endlessm.com>
    Reported-by: Tasev Nikola <tasev.stefanoska@skynet.be>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wireless.c b/drivers/platform/x86/asus-wireless.c
index 5058d48f2909..9ec721e26532 100644
--- a/drivers/platform/x86/asus-wireless.c
+++ b/drivers/platform/x86/asus-wireless.c
@@ -61,6 +61,7 @@ static int asus_wireless_remove(struct acpi_device *adev)
 }
 
 static const struct acpi_device_id device_ids[] = {
+	{"ATK4001", 0},
 	{"ATK4002", 0},
 	{"", 0},
 };

commit f6a6bbae0471fdfb824a86d1808eae33e8819254
Author: João Paulo Rechi Vita <jprvita@gmail.com>
Date:   Tue Jan 5 11:16:53 2016 -0500

    platform/x86: Add Asus Wireless Radio Control driver
    
    Some Asus notebooks like the Asus E202SA and the Asus X555UB have a
    separate ACPI device for notifications from the airplane mode hotkey.
    This device is called "Wireless Radio Control" in Asus websites and ASHS
    in the DSDT, and its ACPI _HID is ATK4002 in the two models mentioned
    above.
    
    For these models, when the airplane mode hotkey (Fn+F2) is pressed, a
    query 0x0B is started in the Embedded Controller, and all this query does
    is a notify ASHS with the value 0x88 (for acpi_osi >= "Windows 2012"):
    
            Scope (_SB.PCI0.SBRG.EC0)
            {
                    (...)
                    Method (_Q0B, 0, NotSerialized)  // _Qxx: EC Query
                    {
                            If ((MSOS () >= OSW8))
                            {
                                    Notify (ASHS, 0x88) // Device-Specific
                            }
                            Else
                            {
                                    (...)
                            }
                    }
            }
    
    Signed-off-by: João Paulo Rechi Vita <jprvita@endlessm.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wireless.c b/drivers/platform/x86/asus-wireless.c
new file mode 100644
index 000000000000..5058d48f2909
--- /dev/null
+++ b/drivers/platform/x86/asus-wireless.c
@@ -0,0 +1,83 @@
+/*
+ * Asus Wireless Radio Control Driver
+ *
+ * Copyright (C) 2015-2016 Endless Mobile, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/acpi.h>
+#include <linux/input.h>
+#include <linux/pci_ids.h>
+
+struct asus_wireless_data {
+	struct input_dev *idev;
+};
+
+static void asus_wireless_notify(struct acpi_device *adev, u32 event)
+{
+	struct asus_wireless_data *data = acpi_driver_data(adev);
+
+	dev_dbg(&adev->dev, "event=%#x\n", event);
+	if (event != 0x88) {
+		dev_notice(&adev->dev, "Unknown ASHS event: %#x\n", event);
+		return;
+	}
+	input_report_key(data->idev, KEY_RFKILL, 1);
+	input_report_key(data->idev, KEY_RFKILL, 0);
+	input_sync(data->idev);
+}
+
+static int asus_wireless_add(struct acpi_device *adev)
+{
+	struct asus_wireless_data *data;
+
+	data = devm_kzalloc(&adev->dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+	adev->driver_data = data;
+
+	data->idev = devm_input_allocate_device(&adev->dev);
+	if (!data->idev)
+		return -ENOMEM;
+	data->idev->name = "Asus Wireless Radio Control";
+	data->idev->phys = "asus-wireless/input0";
+	data->idev->id.bustype = BUS_HOST;
+	data->idev->id.vendor = PCI_VENDOR_ID_ASUSTEK;
+	set_bit(EV_KEY, data->idev->evbit);
+	set_bit(KEY_RFKILL, data->idev->keybit);
+	return input_register_device(data->idev);
+}
+
+static int asus_wireless_remove(struct acpi_device *adev)
+{
+	return 0;
+}
+
+static const struct acpi_device_id device_ids[] = {
+	{"ATK4002", 0},
+	{"", 0},
+};
+MODULE_DEVICE_TABLE(acpi, device_ids);
+
+static struct acpi_driver asus_wireless_driver = {
+	.name = "Asus Wireless Radio Control Driver",
+	.class = "hotkey",
+	.ids = device_ids,
+	.ops = {
+		.add = asus_wireless_add,
+		.remove = asus_wireless_remove,
+		.notify = asus_wireless_notify,
+	},
+};
+module_acpi_driver(asus_wireless_driver);
+
+MODULE_DESCRIPTION("Asus Wireless Radio Control Driver");
+MODULE_AUTHOR("João Paulo Rechi Vita <jprvita@gmail.com>");
+MODULE_LICENSE("GPL");
