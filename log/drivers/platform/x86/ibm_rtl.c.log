commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/platform/x86/ibm_rtl.c b/drivers/platform/x86/ibm_rtl.c
index 18d55cee5bcd..5fc665f7d9b3 100644
--- a/drivers/platform/x86/ibm_rtl.c
+++ b/drivers/platform/x86/ibm_rtl.c
@@ -1,25 +1,11 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * IBM Real-Time Linux driver
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
  * Copyright (C) IBM Corporation, 2010
  *
  * Author: Keith Mannthey <kmannth@us.ibm.com>
  *         Vernon Mauery <vernux@us.ibm.com>
- *
  */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt

commit 6faadbbb7f9da70ce484f98f72223c20125a1009
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Sep 14 11:59:30 2017 +0200

    dmi: Mark all struct dmi_system_id instances const
    
    ... and __initconst if applicable.
    
    Based on similar work for an older kernel in the Grsecurity patch.
    
    [JD: fix toshiba-wmi build]
    [JD: add htcpen]
    [JD: move __initconst where checkscript wants it]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jean Delvare <jdelvare@suse.de>

diff --git a/drivers/platform/x86/ibm_rtl.c b/drivers/platform/x86/ibm_rtl.c
index 610ac8391caa..18d55cee5bcd 100644
--- a/drivers/platform/x86/ibm_rtl.c
+++ b/drivers/platform/x86/ibm_rtl.c
@@ -227,7 +227,7 @@ static void rtl_teardown_sysfs(void) {
 }
 
 
-static struct dmi_system_id __initdata ibm_rtl_dmi_table[] = {
+static const struct dmi_system_id ibm_rtl_dmi_table[] __initconst = {
 	{                                                  \
 		.matches = {                               \
 			DMI_MATCH(DMI_SYS_VENDOR, "IBM"),  \

commit cd0223c64c604b2aff2aa7b7576ef7693b0b10ae
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Tue Jul 18 17:01:45 2017 -0500

    platform/x86: ibm_rtl: remove unnecessary static in ibm_rtl_write()
    
    Remove unnecessary static on local variable cmd_port_val. Such variable
    is initialized before being used, on every execution path throughout
    the function. The static has no benefit and, removing it reduces the
    object file size.
    
    This issue was detected using Coccinelle and the following semantic patch:
    https://github.com/GustavoARSilva/coccinelle/blob/master/static/static_unused.cocci
    
    In the following log you can see a difference in the object file size.
    This log is the output of the size command, before and after the code
    change:
    
    before:
       text    data     bss     dec     hex filename
       3932    3440     512    7884    1ecc drivers/platform/x86/ibm_rtl.o
    
    after:
       text    data     bss     dec     hex filename
       3887    3384     448    7719    1e27 drivers/platform/x86/ibm_rtl.o
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/ibm_rtl.c b/drivers/platform/x86/ibm_rtl.c
index c62e5e11ca4b..610ac8391caa 100644
--- a/drivers/platform/x86/ibm_rtl.c
+++ b/drivers/platform/x86/ibm_rtl.c
@@ -103,7 +103,7 @@ static void rtl_port_unmap(void __iomem *addr)
 static int ibm_rtl_write(u8 value)
 {
 	int ret = 0, count = 0;
-	static u32 cmd_port_val;
+	u32 cmd_port_val;
 
 	RTL_DEBUG("%s(%d)\n", __func__, value);
 

commit 2f8e2c877784a0b23f02b41550170a24e14f5c95
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Aug 28 09:27:14 2015 +0200

    move io-64-nonatomic*.h out of asm-generic
    
    These are not implementations of default architecture code but helpers
    for drivers. Move them to the place they belong to.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Darren Hart <dvhart@linux.intel.com>
    Acked-by: Hitoshi Mitake <mitake.hitoshi@lab.ntt.co.jp>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/platform/x86/ibm_rtl.c b/drivers/platform/x86/ibm_rtl.c
index 97c2be195efc..c62e5e11ca4b 100644
--- a/drivers/platform/x86/ibm_rtl.c
+++ b/drivers/platform/x86/ibm_rtl.c
@@ -33,7 +33,7 @@
 #include <linux/mutex.h>
 #include <asm/bios_ebda.h>
 
-#include <asm-generic/io-64-nonatomic-lo-hi.h>
+#include <linux/io-64-nonatomic-lo-hi.h>
 
 static bool force;
 module_param(force, bool, 0);

commit 83e68189745ad931c2afd45d8ee3303929233e7f
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Wed Nov 14 09:42:35 2012 +0000

    efi: Make 'efi_enabled' a function to query EFI facilities
    
    Originally 'efi_enabled' indicated whether a kernel was booted from
    EFI firmware. Over time its semantics have changed, and it now
    indicates whether or not we are booted on an EFI machine with
    bit-native firmware, e.g. 64-bit kernel with 64-bit firmware.
    
    The immediate motivation for this patch is the bug report at,
    
        https://bugs.launchpad.net/ubuntu-cdimage/+bug/1040557
    
    which details how running a platform driver on an EFI machine that is
    designed to run under BIOS can cause the machine to become
    bricked. Also, the following report,
    
        https://bugzilla.kernel.org/show_bug.cgi?id=47121
    
    details how running said driver can also cause Machine Check
    Exceptions. Drivers need a new means of detecting whether they're
    running on an EFI machine, as sadly the expression,
    
        if (!efi_enabled)
    
    hasn't been a sufficient condition for quite some time.
    
    Users actually want to query 'efi_enabled' for different reasons -
    what they really want access to is the list of available EFI
    facilities.
    
    For instance, the x86 reboot code needs to know whether it can invoke
    the ResetSystem() function provided by the EFI runtime services, while
    the ACPI OSL code wants to know whether the EFI config tables were
    mapped successfully. There are also checks in some of the platform
    driver code to simply see if they're running on an EFI machine (which
    would make it a bad idea to do BIOS-y things).
    
    This patch is a prereq for the samsung-laptop fix patch.
    
    Cc: David Airlie <airlied@linux.ie>
    Cc: Corentin Chary <corentincj@iksaif.net>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Dave Jiang <dave.jiang@intel.com>
    Cc: Olof Johansson <olof@lixom.net>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Colin Ian King <colin.king@canonical.com>
    Cc: Steve Langasek <steve.langasek@canonical.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad@kernel.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/drivers/platform/x86/ibm_rtl.c b/drivers/platform/x86/ibm_rtl.c
index 7481146a5b47..97c2be195efc 100644
--- a/drivers/platform/x86/ibm_rtl.c
+++ b/drivers/platform/x86/ibm_rtl.c
@@ -244,7 +244,7 @@ static int __init ibm_rtl_init(void) {
 	if (force)
 		pr_warn("module loaded by force\n");
 	/* first ensure that we are running on IBM HW */
-	else if (efi_enabled || !dmi_check_system(ibm_rtl_dmi_table))
+	else if (efi_enabled(EFI_BOOT) || !dmi_check_system(ibm_rtl_dmi_table))
 		return -ENODEV;
 
 	/* Get the address for the Extended BIOS Data Area */

commit 797a796a13df6b84a4791e57306737059b5b2384
Author: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
Date:   Tue Feb 7 11:45:33 2012 +0900

    asm-generic: architecture independent readq/writeq for 32bit environment
    
    This provides unified readq()/writeq() helper functions for 32-bit
    drivers.
    
    For some cases, readq/writeq without atomicity is harmful, and order of
    io access has to be specified explicitly.  So in this patch, new two
    header files which contain non-atomic readq/writeq are added.
    
     - <asm-generic/io-64-nonatomic-lo-hi.h> provides non-atomic readq/
       writeq with the order of lower address -> higher address
    
     - <asm-generic/io-64-nonatomic-hi-lo.h> provides non-atomic readq/
       writeq with reversed order
    
    This allows us to remove some readq()s that were added drivers when the
    default non-atomic ones were removed in commit dbee8a0affd5 ("x86:
    remove 32-bit versions of readq()/writeq()")
    
    The drivers which need readq/writeq but can do with the non-atomic ones
    must add the line:
    
      #include <asm-generic/io-64-nonatomic-lo-hi.h> /* or hi-lo.h */
    
    But this will be nop in 64-bit environments, and no other #ifdefs are
    required.  So I believe that this patch can solve the problem of
     1. driver-specific readq/writeq
     2. atomicity and order of io access
    
    This patch is tested with building allyesconfig and allmodconfig as
    ARCH=x86 and ARCH=i386 on top of tip/master.
    
    Cc: Kashyap Desai <Kashyap.Desai@lsi.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Ravi Anand <ravi.anand@qlogic.com>
    Cc: Vikas Chaudhary <vikas.chaudhary@qlogic.com>
    Cc: Matthew Garrett <mjg@redhat.com>
    Cc: Jason Uhlenkott <juhlenko@akamai.com>
    Cc: James Bottomley <James.Bottomley@parallels.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Roland Dreier <roland@purestorage.com>
    Cc: James Bottomley <jbottomley@parallels.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Matthew Wilcox <matthew.r.wilcox@intel.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Hitoshi Mitake <h.mitake@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/platform/x86/ibm_rtl.c b/drivers/platform/x86/ibm_rtl.c
index 42a7d603c870..7481146a5b47 100644
--- a/drivers/platform/x86/ibm_rtl.c
+++ b/drivers/platform/x86/ibm_rtl.c
@@ -33,6 +33,8 @@
 #include <linux/mutex.h>
 #include <asm/bios_ebda.h>
 
+#include <asm-generic/io-64-nonatomic-lo-hi.h>
+
 static bool force;
 module_param(force, bool, 0);
 MODULE_PARM_DESC(force, "Force driver load, ignore DMI data");
@@ -83,19 +85,6 @@ static void __iomem *rtl_cmd_addr;
 static u8 rtl_cmd_type;
 static u8 rtl_cmd_width;
 
-#ifndef readq
-static inline __u64 readq(const volatile void __iomem *addr)
-{
-	const volatile u32 __iomem *p = addr;
-	u32 low, high;
-
-	low = readl(p);
-	high = readl(p + 1);
-
-	return low + ((u64)high << 32);
-}
-#endif
-
 static void __iomem *rtl_port_map(phys_addr_t addr, unsigned long len)
 {
 	if (rtl_cmd_type == RTL_ADDR_TYPE_MMIO)

commit 15916a123e59b84d2fdfcccac84c99d1777f2a45
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Wed Dec 14 15:26:15 2011 -0800

    ibm_rtl: convert sysdev_class to a regular subsystem
    
    After all sysdev classes are ported to regular driver core entities, the
    sysdev implementation will be entirely removed from the kernel.
    
    Cc: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/platform/x86/ibm_rtl.c b/drivers/platform/x86/ibm_rtl.c
index 811d436cd677..42a7d603c870 100644
--- a/drivers/platform/x86/ibm_rtl.c
+++ b/drivers/platform/x86/ibm_rtl.c
@@ -28,7 +28,6 @@
 #include <linux/delay.h>
 #include <linux/module.h>
 #include <linux/io.h>
-#include <linux/sysdev.h>
 #include <linux/dmi.h>
 #include <linux/efi.h>
 #include <linux/mutex.h>
@@ -165,22 +164,22 @@ static int ibm_rtl_write(u8 value)
 	return ret;
 }
 
-static ssize_t rtl_show_version(struct sysdev_class * dev,
-                                struct sysdev_class_attribute *attr,
+static ssize_t rtl_show_version(struct device *dev,
+                                struct device_attribute *attr,
                                 char *buf)
 {
 	return sprintf(buf, "%d\n", (int)ioread8(&rtl_table->version));
 }
 
-static ssize_t rtl_show_state(struct sysdev_class *dev,
-                              struct sysdev_class_attribute *attr,
+static ssize_t rtl_show_state(struct device *dev,
+                              struct device_attribute *attr,
                               char *buf)
 {
 	return sprintf(buf, "%d\n", ioread8(&rtl_table->rt_status));
 }
 
-static ssize_t rtl_set_state(struct sysdev_class *dev,
-                             struct sysdev_class_attribute *attr,
+static ssize_t rtl_set_state(struct device *dev,
+                             struct device_attribute *attr,
                              const char *buf,
                              size_t count)
 {
@@ -205,27 +204,28 @@ static ssize_t rtl_set_state(struct sysdev_class *dev,
 	return ret;
 }
 
-static struct sysdev_class class_rtl = {
+static struct bus_type rtl_subsys = {
 	.name = "ibm_rtl",
+	.dev_name = "ibm_rtl",
 };
 
-static SYSDEV_CLASS_ATTR(version, S_IRUGO, rtl_show_version, NULL);
-static SYSDEV_CLASS_ATTR(state, 0600, rtl_show_state, rtl_set_state);
+static DEVICE_ATTR(version, S_IRUGO, rtl_show_version, NULL);
+static DEVICE_ATTR(state, 0600, rtl_show_state, rtl_set_state);
 
-static struct sysdev_class_attribute *rtl_attributes[] = {
-	&attr_version,
-	&attr_state,
+static struct device_attribute *rtl_attributes[] = {
+	&dev_attr_version,
+	&dev_attr_state,
 	NULL
 };
 
 
 static int rtl_setup_sysfs(void) {
 	int ret, i;
-	ret = sysdev_class_register(&class_rtl);
 
+	ret = subsys_system_register(&rtl_subsys, NULL);
 	if (!ret) {
 		for (i = 0; rtl_attributes[i]; i ++)
-			sysdev_class_create_file(&class_rtl, rtl_attributes[i]);
+			device_create_file(rtl_subsys.dev_root, rtl_attributes[i]);
 	}
 	return ret;
 }
@@ -233,8 +233,8 @@ static int rtl_setup_sysfs(void) {
 static void rtl_teardown_sysfs(void) {
 	int i;
 	for (i = 0; rtl_attributes[i]; i ++)
-		sysdev_class_remove_file(&class_rtl, rtl_attributes[i]);
-	sysdev_class_unregister(&class_rtl);
+		device_remove_file(rtl_subsys.dev_root, rtl_attributes[i]);
+	bus_unregister(&rtl_subsys);
 }
 
 

commit 323623a717c7feec3f36099f4caa18b3319c5cca
Author: Joe Perches <joe@perches.com>
Date:   Tue Mar 29 15:21:42 2011 -0700

    ibm_rtl: Use pr_fmt and pr_<level>
    
    Remove hard coded prefixes from logging messages.
    Neaten RTL_DEBUG macro and uses.
    Convert __FUNCTION__ to __func__.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/ibm_rtl.c b/drivers/platform/x86/ibm_rtl.c
index 10563458408c..811d436cd677 100644
--- a/drivers/platform/x86/ibm_rtl.c
+++ b/drivers/platform/x86/ibm_rtl.c
@@ -22,6 +22,8 @@
  *
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/kernel.h>
 #include <linux/delay.h>
 #include <linux/module.h>
@@ -69,9 +71,10 @@ struct ibm_rtl_table {
 #define RTL_SIGNATURE 0x0000005f4c54525fULL
 #define RTL_MASK      0x000000ffffffffffULL
 
-#define RTL_DEBUG(A, ...) do { \
-	if (debug) \
-		pr_info("ibm-rtl: " A, ##__VA_ARGS__ ); \
+#define RTL_DEBUG(fmt, ...)				\
+do {							\
+	if (debug)					\
+		pr_info(fmt, ##__VA_ARGS__);		\
 } while (0)
 
 static DEFINE_MUTEX(rtl_lock);
@@ -114,7 +117,7 @@ static int ibm_rtl_write(u8 value)
 	int ret = 0, count = 0;
 	static u32 cmd_port_val;
 
-	RTL_DEBUG("%s(%d)\n", __FUNCTION__, value);
+	RTL_DEBUG("%s(%d)\n", __func__, value);
 
 	value = value == 1 ? RTL_CMD_ENTER_PRTM : RTL_CMD_EXIT_PRTM;
 
@@ -144,8 +147,8 @@ static int ibm_rtl_write(u8 value)
 		while (ioread8(&rtl_table->command)) {
 			msleep(10);
 			if (count++ > 500) {
-				pr_err("ibm-rtl: Hardware not responding to "
-					"mode switch request\n");
+				pr_err("Hardware not responding to "
+				       "mode switch request\n");
 				ret = -EIO;
 				break;
 			}
@@ -250,7 +253,7 @@ static int __init ibm_rtl_init(void) {
 	int ret = -ENODEV, i;
 
 	if (force)
-		pr_warning("ibm-rtl: module loaded by force\n");
+		pr_warn("module loaded by force\n");
 	/* first ensure that we are running on IBM HW */
 	else if (efi_enabled || !dmi_check_system(ibm_rtl_dmi_table))
 		return -ENODEV;
@@ -295,7 +298,7 @@ static int __init ibm_rtl_init(void) {
 			rtl_cmd_width = ioread8(&rtl_table->cmd_granularity);
 			rtl_cmd_type = ioread8(&rtl_table->cmd_address_type);
 			RTL_DEBUG("rtl_cmd_width = %u, rtl_cmd_type = %u\n",
-			      rtl_cmd_width, rtl_cmd_type);
+				  rtl_cmd_width, rtl_cmd_type);
 			addr = ioread32(&rtl_table->cmd_port_address);
 			RTL_DEBUG("addr = %#llx\n", (unsigned long long)addr);
 			plen = rtl_cmd_width/sizeof(char);

commit 3a35125f97be0658305c9509c51077959c19b244
Author: Joe Perches <joe@perches.com>
Date:   Tue Mar 29 15:21:33 2011 -0700

    ibm_rtl: Remove warnings from casts of pointer to int
    
    Just print them as %p.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/ibm_rtl.c b/drivers/platform/x86/ibm_rtl.c
index b1396e5b2953..10563458408c 100644
--- a/drivers/platform/x86/ibm_rtl.c
+++ b/drivers/platform/x86/ibm_rtl.c
@@ -288,7 +288,7 @@ static int __init ibm_rtl_init(void) {
 		if ((readq(&tmp->signature) & RTL_MASK) == RTL_SIGNATURE) {
 			phys_addr_t addr;
 			unsigned int plen;
-			RTL_DEBUG("found RTL_SIGNATURE at %#llx\n", (u64)tmp);
+			RTL_DEBUG("found RTL_SIGNATURE at %p\n", tmp);
 			rtl_table = tmp;
 			/* The address, value, width and offset are platform
 			 * dependent and found in the ibm_rtl_table */
@@ -300,7 +300,7 @@ static int __init ibm_rtl_init(void) {
 			RTL_DEBUG("addr = %#llx\n", (unsigned long long)addr);
 			plen = rtl_cmd_width/sizeof(char);
 			rtl_cmd_addr = rtl_port_map(addr, plen);
-			RTL_DEBUG("rtl_cmd_addr = %#llx\n", (u64)rtl_cmd_addr);
+			RTL_DEBUG("rtl_cmd_addr = %p\n", rtl_cmd_addr);
 			if (!rtl_cmd_addr) {
 				ret = -ENOMEM;
 				break;

commit dbee8a0affd5e6eaa5d7c816c4bc233f6f110f50
Author: Roland Dreier <roland@purestorage.com>
Date:   Tue May 24 17:13:09 2011 -0700

    x86: remove 32-bit versions of readq()/writeq()
    
    The presense of a writeq() implementation on 32-bit x86 that splits the
    64-bit write into two 32-bit writes turns out to break the mpt2sas driver
    (and in general is risky for drivers as was discussed in
    <http://lkml.kernel.org/r/adaab6c1h7c.fsf@cisco.com>).  To fix this,
    revert 2c5643b1c5c7 ("x86: provide readq()/writeq() on 32-bit too") and
    follow-on cleanups.
    
    This unfortunately leads to pushing non-atomic definitions of readq() and
    write() to various x86-only drivers that in the meantime started using the
    definitions in the x86 version of <asm/io.h>.  However as discussed
    exhaustively, this is actually the right thing to do, because the right
    way to split a 64-bit transaction is hardware dependent and therefore
    belongs in the hardware driver (eg mpt2sas needs a spinlock to make sure
    no other accesses occur in between the two halves of the access).
    
    Build tested on 32- and 64-bit x86 allmodconfig.
    
    Link: http://lkml.kernel.org/r/x86-32-writeq-is-broken@mdm.bga.com
    Acked-by: Hitoshi Mitake <h.mitake@gmail.com>
    Cc: Kashyap Desai <Kashyap.Desai@lsi.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Ravi Anand <ravi.anand@qlogic.com>
    Cc: Vikas Chaudhary <vikas.chaudhary@qlogic.com>
    Cc: Matthew Garrett <mjg@redhat.com>
    Cc: Jason Uhlenkott <juhlenko@akamai.com>
    Acked-by: James Bottomley <James.Bottomley@parallels.com>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Signed-off-by: Roland Dreier <roland@purestorage.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/platform/x86/ibm_rtl.c b/drivers/platform/x86/ibm_rtl.c
index 94a114aa8e28..b1396e5b2953 100644
--- a/drivers/platform/x86/ibm_rtl.c
+++ b/drivers/platform/x86/ibm_rtl.c
@@ -81,6 +81,19 @@ static void __iomem *rtl_cmd_addr;
 static u8 rtl_cmd_type;
 static u8 rtl_cmd_width;
 
+#ifndef readq
+static inline __u64 readq(const volatile void __iomem *addr)
+{
+	const volatile u32 __iomem *p = addr;
+	u32 low, high;
+
+	low = readl(p);
+	high = readl(p + 1);
+
+	return low + ((u64)high << 32);
+}
+#endif
+
 static void __iomem *rtl_port_map(phys_addr_t addr, unsigned long len)
 {
 	if (rtl_cmd_type == RTL_ADDR_TYPE_MMIO)

commit 1d37db77c1aa199ae9a4114af7c0412c8417e949
Author: Vernon Mauery <vernux@us.ibm.com>
Date:   Tue Nov 2 13:08:11 2010 -0700

    ibm_rtl: _RTL_ is not available in UEFI mode
    
    Some of the IBM servers that are supported by ibm_rtl
    can run in both Legacy mode (BIOS) and in UEFI mode.
    When running in UEFI mode, it is possible that the
    EBDA table exists but cannot be mapped and reports
    errors.  We need to make sure that by default we don't
    try to probe the machines if they are running in UEFI
    mode.
    
    Signed-off-by: Vernon Mauery <vernux@us.ibm.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/ibm_rtl.c b/drivers/platform/x86/ibm_rtl.c
index 5c975edb3c81..94a114aa8e28 100644
--- a/drivers/platform/x86/ibm_rtl.c
+++ b/drivers/platform/x86/ibm_rtl.c
@@ -28,6 +28,7 @@
 #include <linux/io.h>
 #include <linux/sysdev.h>
 #include <linux/dmi.h>
+#include <linux/efi.h>
 #include <linux/mutex.h>
 #include <asm/bios_ebda.h>
 
@@ -238,7 +239,7 @@ static int __init ibm_rtl_init(void) {
 	if (force)
 		pr_warning("ibm-rtl: module loaded by force\n");
 	/* first ensure that we are running on IBM HW */
-	else if (!dmi_check_system(ibm_rtl_dmi_table))
+	else if (efi_enabled || !dmi_check_system(ibm_rtl_dmi_table))
 		return -ENODEV;
 
 	/* Get the address for the Extended BIOS Data Area */

commit a2262260f9eaee4acd56b5624b5d2bf4be9bb38a
Author: Vernon Mauery <vernux@us.ibm.com>
Date:   Tue Nov 2 13:08:10 2010 -0700

    ibm_rtl: Loosen the DMI criteria to all IBM machines
    
    Allow all IBM machines to pass the DMI check so that we
    don't have to add them one by one to the driver.  Any IBM
    machine that has the _RTL_ table in the EBDA will work.
    
    Signed-off-by: Vernon Mauery <vernux@us.ibm.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/ibm_rtl.c b/drivers/platform/x86/ibm_rtl.c
index a884f5498846..5c975edb3c81 100644
--- a/drivers/platform/x86/ibm_rtl.c
+++ b/drivers/platform/x86/ibm_rtl.c
@@ -220,32 +220,13 @@ static void rtl_teardown_sysfs(void) {
 	sysdev_class_unregister(&class_rtl);
 }
 
-static int dmi_check_cb(const struct dmi_system_id *id)
-{
-	RTL_DEBUG("found IBM server '%s'\n", id->ident);
-	return 0;
-}
-
-#define ibm_dmi_entry(NAME, TYPE)                  \
-{                                                  \
-	.ident = NAME,                             \
-	.matches = {                               \
-		DMI_MATCH(DMI_SYS_VENDOR, "IBM"),  \
-		DMI_MATCH(DMI_PRODUCT_NAME, TYPE), \
-	},                                         \
-	.callback = dmi_check_cb                   \
-}
 
 static struct dmi_system_id __initdata ibm_rtl_dmi_table[] = {
-	ibm_dmi_entry("BladeCenter LS21", "7971"),
-	ibm_dmi_entry("BladeCenter LS22", "7901"),
-	ibm_dmi_entry("BladeCenter HS21 XM", "7995"),
-	ibm_dmi_entry("BladeCenter HS22", "7870"),
-	ibm_dmi_entry("BladeCenter HS22V", "7871"),
-	ibm_dmi_entry("System x3550 M2", "7946"),
-	ibm_dmi_entry("System x3650 M2", "7947"),
-	ibm_dmi_entry("System x3550 M3", "7944"),
-	ibm_dmi_entry("System x3650 M3", "7945"),
+	{                                                  \
+		.matches = {                               \
+			DMI_MATCH(DMI_SYS_VENDOR, "IBM"),  \
+		},                                         \
+	},
 	{ }
 };
 

commit c72b844ed2f55c442b464e382a2eb2ecab5292a8
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Fri Oct 22 16:18:47 2010 -0700

    ibm_rtl: fix printk format warning
    
    Fix printk format warning:
    
    drivers/platform/x86/ibm_rtl.c:305:warning: format '%#llx' expects type 'long long unsigned int', but argument 2 has type 'phys_addr_t'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Keith Mannthey <kmannth@us.ibm.com>
    Cc: Vernon Mauery <vernux@us.ibm.com>
    Cc: platform-driver-x86@vger.kernel.org
    Cc: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/ibm_rtl.c b/drivers/platform/x86/ibm_rtl.c
index 3c2c6b91ecb3..a884f5498846 100644
--- a/drivers/platform/x86/ibm_rtl.c
+++ b/drivers/platform/x86/ibm_rtl.c
@@ -302,7 +302,7 @@ static int __init ibm_rtl_init(void) {
 			RTL_DEBUG("rtl_cmd_width = %u, rtl_cmd_type = %u\n",
 			      rtl_cmd_width, rtl_cmd_type);
 			addr = ioread32(&rtl_table->cmd_port_address);
-			RTL_DEBUG("addr = %#llx\n", addr);
+			RTL_DEBUG("addr = %#llx\n", (unsigned long long)addr);
 			plen = rtl_cmd_width/sizeof(char);
 			rtl_cmd_addr = rtl_port_map(addr, plen);
 			RTL_DEBUG("rtl_cmd_addr = %#llx\n", (u64)rtl_cmd_addr);

commit 35f0ce032b0f2d6974da516b5a113f49b7b70b09
Author: Vernon Mauery <vernux@us.ibm.com>
Date:   Tue Oct 5 15:47:18 2010 -0700

    IBM Real-Time "SMI Free" mode driver -v7
    
    After a period of RFC for this driver, I think it is ready
    for inclusion in the platform-driver-x86 tree, hopefully to
    be staged in the next merge window into Linus's tree.
    
    --Vernon
    
    ------------------------------------------------------------
    
    IBM Real-Time "SMI Free" mode driver
    
    This driver supports the Real-Time Linux (RTL) BIOS feature.
    The RTL feature allows non-fatal System Management Interrupts
    (SMIs) to be disabled on supported IBM platforms and is
    intended to be coupled with a user-space daemon to monitor
    the hardware in a way that can be prioritized and scheduled
    to better suit the requirements for the system.
    
    The Device is presented as a special "_RTL_" table to the OS
    in the Extended BIOS Data Area.  There is a simple protocol
    for entering and exiting the mode at runtime.  This driver
    creates a simple sysfs interface to allow a simple entry and
    exit from RTL mode in the UFI/BIOS.
    
    Since the driver is specific to IBM SystemX hardware (x86-
    based servers) it only builds on x86 builds.  To reduce the
    risk of loading on the wrong hardware, the module uses DMI
    information and checks a list of servers that are known to
    work.
    
    Signed-off-by: Vernon Mauery <vernux@us.ibm.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/ibm_rtl.c b/drivers/platform/x86/ibm_rtl.c
new file mode 100644
index 000000000000..3c2c6b91ecb3
--- /dev/null
+++ b/drivers/platform/x86/ibm_rtl.c
@@ -0,0 +1,341 @@
+/*
+ * IBM Real-Time Linux driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (C) IBM Corporation, 2010
+ *
+ * Author: Keith Mannthey <kmannth@us.ibm.com>
+ *         Vernon Mauery <vernux@us.ibm.com>
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/sysdev.h>
+#include <linux/dmi.h>
+#include <linux/mutex.h>
+#include <asm/bios_ebda.h>
+
+static bool force;
+module_param(force, bool, 0);
+MODULE_PARM_DESC(force, "Force driver load, ignore DMI data");
+
+static bool debug;
+module_param(debug, bool, 0644);
+MODULE_PARM_DESC(debug, "Show debug output");
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Keith Mannthey <kmmanth@us.ibm.com>");
+MODULE_AUTHOR("Vernon Mauery <vernux@us.ibm.com>");
+
+#define RTL_ADDR_TYPE_IO    1
+#define RTL_ADDR_TYPE_MMIO  2
+
+#define RTL_CMD_ENTER_PRTM  1
+#define RTL_CMD_EXIT_PRTM   2
+
+/* The RTL table as presented by the EBDA: */
+struct ibm_rtl_table {
+	char signature[5]; /* signature should be "_RTL_" */
+	u8 version;
+	u8 rt_status;
+	u8 command;
+	u8 command_status;
+	u8 cmd_address_type;
+	u8 cmd_granularity;
+	u8 cmd_offset;
+	u16 reserve1;
+	u32 cmd_port_address; /* platform dependent address */
+	u32 cmd_port_value;   /* platform dependent value */
+} __attribute__((packed));
+
+/* to locate "_RTL_" signature do a masked 5-byte integer compare */
+#define RTL_SIGNATURE 0x0000005f4c54525fULL
+#define RTL_MASK      0x000000ffffffffffULL
+
+#define RTL_DEBUG(A, ...) do { \
+	if (debug) \
+		pr_info("ibm-rtl: " A, ##__VA_ARGS__ ); \
+} while (0)
+
+static DEFINE_MUTEX(rtl_lock);
+static struct ibm_rtl_table __iomem *rtl_table;
+static void __iomem *ebda_map;
+static void __iomem *rtl_cmd_addr;
+static u8 rtl_cmd_type;
+static u8 rtl_cmd_width;
+
+static void __iomem *rtl_port_map(phys_addr_t addr, unsigned long len)
+{
+	if (rtl_cmd_type == RTL_ADDR_TYPE_MMIO)
+		return ioremap(addr, len);
+	return ioport_map(addr, len);
+}
+
+static void rtl_port_unmap(void __iomem *addr)
+{
+	if (addr && rtl_cmd_type == RTL_ADDR_TYPE_MMIO)
+		iounmap(addr);
+	else
+		ioport_unmap(addr);
+}
+
+static int ibm_rtl_write(u8 value)
+{
+	int ret = 0, count = 0;
+	static u32 cmd_port_val;
+
+	RTL_DEBUG("%s(%d)\n", __FUNCTION__, value);
+
+	value = value == 1 ? RTL_CMD_ENTER_PRTM : RTL_CMD_EXIT_PRTM;
+
+	mutex_lock(&rtl_lock);
+
+	if (ioread8(&rtl_table->rt_status) != value) {
+		iowrite8(value, &rtl_table->command);
+
+		switch (rtl_cmd_width) {
+		case 8:
+			cmd_port_val = ioread8(&rtl_table->cmd_port_value);
+			RTL_DEBUG("cmd_port_val = %u\n", cmd_port_val);
+			iowrite8((u8)cmd_port_val, rtl_cmd_addr);
+			break;
+		case 16:
+			cmd_port_val = ioread16(&rtl_table->cmd_port_value);
+			RTL_DEBUG("cmd_port_val = %u\n", cmd_port_val);
+			iowrite16((u16)cmd_port_val, rtl_cmd_addr);
+			break;
+		case 32:
+			cmd_port_val = ioread32(&rtl_table->cmd_port_value);
+			RTL_DEBUG("cmd_port_val = %u\n", cmd_port_val);
+			iowrite32(cmd_port_val, rtl_cmd_addr);
+			break;
+		}
+
+		while (ioread8(&rtl_table->command)) {
+			msleep(10);
+			if (count++ > 500) {
+				pr_err("ibm-rtl: Hardware not responding to "
+					"mode switch request\n");
+				ret = -EIO;
+				break;
+			}
+
+		}
+
+		if (ioread8(&rtl_table->command_status)) {
+			RTL_DEBUG("command_status reports failed command\n");
+			ret = -EIO;
+		}
+	}
+
+	mutex_unlock(&rtl_lock);
+	return ret;
+}
+
+static ssize_t rtl_show_version(struct sysdev_class * dev,
+                                struct sysdev_class_attribute *attr,
+                                char *buf)
+{
+	return sprintf(buf, "%d\n", (int)ioread8(&rtl_table->version));
+}
+
+static ssize_t rtl_show_state(struct sysdev_class *dev,
+                              struct sysdev_class_attribute *attr,
+                              char *buf)
+{
+	return sprintf(buf, "%d\n", ioread8(&rtl_table->rt_status));
+}
+
+static ssize_t rtl_set_state(struct sysdev_class *dev,
+                             struct sysdev_class_attribute *attr,
+                             const char *buf,
+                             size_t count)
+{
+	ssize_t ret;
+
+	if (count < 1 || count > 2)
+		return -EINVAL;
+
+	switch (buf[0]) {
+	case '0':
+		ret = ibm_rtl_write(0);
+		break;
+	case '1':
+		ret = ibm_rtl_write(1);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	if (ret >= 0)
+		ret = count;
+
+	return ret;
+}
+
+static struct sysdev_class class_rtl = {
+	.name = "ibm_rtl",
+};
+
+static SYSDEV_CLASS_ATTR(version, S_IRUGO, rtl_show_version, NULL);
+static SYSDEV_CLASS_ATTR(state, 0600, rtl_show_state, rtl_set_state);
+
+static struct sysdev_class_attribute *rtl_attributes[] = {
+	&attr_version,
+	&attr_state,
+	NULL
+};
+
+
+static int rtl_setup_sysfs(void) {
+	int ret, i;
+	ret = sysdev_class_register(&class_rtl);
+
+	if (!ret) {
+		for (i = 0; rtl_attributes[i]; i ++)
+			sysdev_class_create_file(&class_rtl, rtl_attributes[i]);
+	}
+	return ret;
+}
+
+static void rtl_teardown_sysfs(void) {
+	int i;
+	for (i = 0; rtl_attributes[i]; i ++)
+		sysdev_class_remove_file(&class_rtl, rtl_attributes[i]);
+	sysdev_class_unregister(&class_rtl);
+}
+
+static int dmi_check_cb(const struct dmi_system_id *id)
+{
+	RTL_DEBUG("found IBM server '%s'\n", id->ident);
+	return 0;
+}
+
+#define ibm_dmi_entry(NAME, TYPE)                  \
+{                                                  \
+	.ident = NAME,                             \
+	.matches = {                               \
+		DMI_MATCH(DMI_SYS_VENDOR, "IBM"),  \
+		DMI_MATCH(DMI_PRODUCT_NAME, TYPE), \
+	},                                         \
+	.callback = dmi_check_cb                   \
+}
+
+static struct dmi_system_id __initdata ibm_rtl_dmi_table[] = {
+	ibm_dmi_entry("BladeCenter LS21", "7971"),
+	ibm_dmi_entry("BladeCenter LS22", "7901"),
+	ibm_dmi_entry("BladeCenter HS21 XM", "7995"),
+	ibm_dmi_entry("BladeCenter HS22", "7870"),
+	ibm_dmi_entry("BladeCenter HS22V", "7871"),
+	ibm_dmi_entry("System x3550 M2", "7946"),
+	ibm_dmi_entry("System x3650 M2", "7947"),
+	ibm_dmi_entry("System x3550 M3", "7944"),
+	ibm_dmi_entry("System x3650 M3", "7945"),
+	{ }
+};
+
+static int __init ibm_rtl_init(void) {
+	unsigned long ebda_addr, ebda_size;
+	unsigned int ebda_kb;
+	int ret = -ENODEV, i;
+
+	if (force)
+		pr_warning("ibm-rtl: module loaded by force\n");
+	/* first ensure that we are running on IBM HW */
+	else if (!dmi_check_system(ibm_rtl_dmi_table))
+		return -ENODEV;
+
+	/* Get the address for the Extended BIOS Data Area */
+	ebda_addr = get_bios_ebda();
+	if (!ebda_addr) {
+		RTL_DEBUG("no BIOS EBDA found\n");
+		return -ENODEV;
+	}
+
+	ebda_map = ioremap(ebda_addr, 4);
+	if (!ebda_map)
+		return -ENOMEM;
+
+	/* First word in the EDBA is the Size in KB */
+	ebda_kb = ioread16(ebda_map);
+	RTL_DEBUG("EBDA is %d kB\n", ebda_kb);
+
+	if (ebda_kb == 0)
+		goto out;
+
+	iounmap(ebda_map);
+	ebda_size = ebda_kb*1024;
+
+	/* Remap the whole table */
+	ebda_map = ioremap(ebda_addr, ebda_size);
+	if (!ebda_map)
+		return -ENOMEM;
+
+	/* search for the _RTL_ signature at the start of the table */
+	for (i = 0 ; i < ebda_size/sizeof(unsigned int); i++) {
+		struct ibm_rtl_table __iomem * tmp;
+		tmp = (struct ibm_rtl_table __iomem *) (ebda_map+i);
+		if ((readq(&tmp->signature) & RTL_MASK) == RTL_SIGNATURE) {
+			phys_addr_t addr;
+			unsigned int plen;
+			RTL_DEBUG("found RTL_SIGNATURE at %#llx\n", (u64)tmp);
+			rtl_table = tmp;
+			/* The address, value, width and offset are platform
+			 * dependent and found in the ibm_rtl_table */
+			rtl_cmd_width = ioread8(&rtl_table->cmd_granularity);
+			rtl_cmd_type = ioread8(&rtl_table->cmd_address_type);
+			RTL_DEBUG("rtl_cmd_width = %u, rtl_cmd_type = %u\n",
+			      rtl_cmd_width, rtl_cmd_type);
+			addr = ioread32(&rtl_table->cmd_port_address);
+			RTL_DEBUG("addr = %#llx\n", addr);
+			plen = rtl_cmd_width/sizeof(char);
+			rtl_cmd_addr = rtl_port_map(addr, plen);
+			RTL_DEBUG("rtl_cmd_addr = %#llx\n", (u64)rtl_cmd_addr);
+			if (!rtl_cmd_addr) {
+				ret = -ENOMEM;
+				break;
+			}
+			ret = rtl_setup_sysfs();
+			break;
+		}
+	}
+
+out:
+	if (ret) {
+		iounmap(ebda_map);
+		rtl_port_unmap(rtl_cmd_addr);
+	}
+
+	return ret;
+}
+
+static void __exit ibm_rtl_exit(void)
+{
+	if (rtl_table) {
+		RTL_DEBUG("cleaning up");
+		/* do not leave the machine in SMI-free mode */
+		ibm_rtl_write(0);
+		/* unmap, unlink and remove all traces */
+		rtl_teardown_sysfs();
+		iounmap(ebda_map);
+		rtl_port_unmap(rtl_cmd_addr);
+	}
+}
+
+module_init(ibm_rtl_init);
+module_exit(ibm_rtl_exit);
