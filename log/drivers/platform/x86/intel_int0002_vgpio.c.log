commit ef05db16bbd81c0afc4e97806ab338665863bd3b
Merge: f183d269cc6c 54032b863b56
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 6 10:14:39 2020 -0700

    Merge tag 'pm-5.7-rc1-2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull more power management updates from Rafael Wysocki:
     "Additional power management updates.
    
      These fix a corner-case suspend-to-idle wakeup issue on systems where
      the ACPI SCI is shared with another wakeup source, add a kernel
      command line option to set pm_debug_messages via the kernel command
      line, add a document desctibing system-wide suspend and resume code
      flows, modify cpufreq Kconfig to choose schedutil as the preferred
      governor by default in a couple of cases and do some assorted
      cleanups.
    
      Specifics:
    
       - Fix corner-case suspend-to-idle wakeup issue on systems where the
         ACPI SCI is shared with another wakeup source (Hans de Goede).
    
       - Add document describing system-wide suspend and resume code flows
         to the admin guide (Rafael Wysocki).
    
       - Add kernel command line option to set pm_debug_messages (Chen Yu).
    
       - Choose schedutil as the preferred scaling governor by default on
         ARM big.LITTLE systems and on x86 systems using the intel_pstate
         driver in the passive mode (Linus Walleij, Rafael Wysocki).
    
       - Drop racy and redundant checks from the PM core's device_prepare()
         routine (Rafael Wysocki).
    
       - Make resume from hibernation take the hibernation_restore() return
         value into account (Dexuan Cui)"
    
    * tag 'pm-5.7-rc1-2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      platform/x86: intel_int0002_vgpio: Use acpi_register_wakeup_handler()
      ACPI: PM: Add acpi_[un]register_wakeup_handler()
      Documentation: PM: sleep: Document system-wide suspend code flows
      cpufreq: Select schedutil when using big.LITTLE
      PM: sleep: Add pm_debug_messages kernel command line option
      PM: sleep: core: Drop racy and redundant checks from device_prepare()
      PM: hibernate: Propagate the return value of hibernation_restore()
      cpufreq: intel_pstate: Select schedutil as the default governor

commit 767191db8220db29f78c031f4d27375173c336d5
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Apr 3 17:48:34 2020 +0200

    platform/x86: intel_int0002_vgpio: Use acpi_register_wakeup_handler()
    
    The Power Management Events (PMEs) the INT0002 driver listens for get
    signalled by the Power Management Controller (PMC) using the same IRQ
    as used for the ACPI SCI.
    
    Since commit fdde0ff8590b ("ACPI: PM: s2idle: Prevent spurious SCIs from
    waking up the system") the SCI triggering, without there being a wakeup
    cause recognized by the ACPI sleep code, will no longer wakeup the system.
    
    This breaks PMEs / wakeups signalled to the INT0002 driver, the system
    never leaves the s2idle_loop() now.
    
    Use acpi_register_wakeup_handler() to register a function which checks
    the GPE0a_STS register for a PME and trigger a wakeup when a PME has
    been signalled.
    
    Fixes: fdde0ff8590b ("ACPI: PM: s2idle: Prevent spurious SCIs from waking up the system")
    Cc: 5.4+ <stable@vger.kernel.org> # 5.4+
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/platform/x86/intel_int0002_vgpio.c b/drivers/platform/x86/intel_int0002_vgpio.c
index f14e2c5f9da5..55f088f535e2 100644
--- a/drivers/platform/x86/intel_int0002_vgpio.c
+++ b/drivers/platform/x86/intel_int0002_vgpio.c
@@ -127,6 +127,14 @@ static irqreturn_t int0002_irq(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
+static bool int0002_check_wake(void *data)
+{
+	u32 gpe_sts_reg;
+
+	gpe_sts_reg = inl(GPE0A_STS_PORT);
+	return (gpe_sts_reg & GPE0A_PME_B0_STS_BIT);
+}
+
 static struct irq_chip int0002_byt_irqchip = {
 	.name			= DRV_NAME,
 	.irq_ack		= int0002_irq_ack,
@@ -220,6 +228,7 @@ static int int0002_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	acpi_register_wakeup_handler(irq, int0002_check_wake, NULL);
 	device_init_wakeup(dev, true);
 	return 0;
 }
@@ -227,6 +236,7 @@ static int int0002_probe(struct platform_device *pdev)
 static int int0002_remove(struct platform_device *pdev)
 {
 	device_init_wakeup(&pdev->dev, false);
+	acpi_unregister_wakeup_handler(int0002_check_wake, NULL);
 	return 0;
 }
 

commit a69b3b1d4cf061d9197d835dcf539d2dd7b9e46f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 20 14:13:56 2020 +0100

    platform/x86: Convert to new CPU match macros
    
    The new macro set has a consistent namespace and uses C99 initializers
    instead of the grufty C89 ones.
    
    Get rid the of the local macro wrappers for consistency.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Link: https://lkml.kernel.org/r/20200320131509.766573641@linutronix.de

diff --git a/drivers/platform/x86/intel_int0002_vgpio.c b/drivers/platform/x86/intel_int0002_vgpio.c
index f14e2c5f9da5..7b23efc46a43 100644
--- a/drivers/platform/x86/intel_int0002_vgpio.c
+++ b/drivers/platform/x86/intel_int0002_vgpio.c
@@ -148,8 +148,8 @@ static struct irq_chip int0002_cht_irqchip = {
 };
 
 static const struct x86_cpu_id int0002_cpu_ids[] = {
-	INTEL_CPU_FAM6(ATOM_SILVERMONT, int0002_byt_irqchip),	/* Valleyview, Bay Trail  */
-	INTEL_CPU_FAM6(ATOM_AIRMONT, int0002_cht_irqchip),	/* Braswell, Cherry Trail */
+	X86_MATCH_INTEL_FAM6_MODEL(ATOM_SILVERMONT,	&int0002_byt_irqchip),
+	X86_MATCH_INTEL_FAM6_MODEL(ATOM_AIRMONT,	&int0002_cht_irqchip),
 	{}
 };
 

commit 4a8d82cdec16fac619f1bc9a664be5d78c514316
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Oct 22 23:01:28 2019 +0200

    platform/x86: intel_int0002_vgpio: Pass irqchip when adding gpiochip
    
    We need to convert all old gpio irqchips to pass the irqchip
    setup along when adding the gpio_chip. For more info see
    drivers/gpio/TODO.
    
    For chained irqchips this is a pretty straight-forward
    conversion. This driver requests the IRQ directly in the driver
    so it needs to pass a NULL parent handler. We may revisit this
    code later and pull reqular shared IRQ handler into
    gpiolib, so leave a FIXME.
    
    Cc: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_int0002_vgpio.c b/drivers/platform/x86/intel_int0002_vgpio.c
index af233b7b77f2..f14e2c5f9da5 100644
--- a/drivers/platform/x86/intel_int0002_vgpio.c
+++ b/drivers/platform/x86/intel_int0002_vgpio.c
@@ -164,8 +164,8 @@ static int int0002_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	const struct x86_cpu_id *cpu_id;
-	struct irq_chip *irq_chip;
 	struct gpio_chip *chip;
+	struct gpio_irq_chip *girq;
 	int irq, ret;
 
 	/* Menlow has a different INT0002 device? <sigh> */
@@ -192,15 +192,11 @@ static int int0002_probe(struct platform_device *pdev)
 	chip->ngpio = GPE0A_PME_B0_VIRT_GPIO_PIN + 1;
 	chip->irq.init_valid_mask = int0002_init_irq_valid_mask;
 
-	ret = devm_gpiochip_add_data(&pdev->dev, chip, NULL);
-	if (ret) {
-		dev_err(dev, "Error adding gpio chip: %d\n", ret);
-		return ret;
-	}
-
 	/*
-	 * We manually request the irq here instead of passing a flow-handler
+	 * We directly request the irq here instead of passing a flow-handler
 	 * to gpiochip_set_chained_irqchip, because the irq is shared.
+	 * FIXME: augment this if we managed to pull handling of shared
+	 * IRQs into gpiolib.
 	 */
 	ret = devm_request_irq(dev, irq, int0002_irq,
 			       IRQF_SHARED, "INT0002", chip);
@@ -209,17 +205,21 @@ static int int0002_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	irq_chip = (struct irq_chip *)cpu_id->driver_data;
+	girq = &chip->irq;
+	girq->chip = (struct irq_chip *)cpu_id->driver_data;
+	/* This let us handle the parent IRQ in the driver */
+	girq->parent_handler = NULL;
+	girq->num_parents = 0;
+	girq->parents = NULL;
+	girq->default_type = IRQ_TYPE_NONE;
+	girq->handler = handle_edge_irq;
 
-	ret = gpiochip_irqchip_add(chip, irq_chip, 0, handle_edge_irq,
-				   IRQ_TYPE_NONE);
+	ret = devm_gpiochip_add_data(dev, chip, NULL);
 	if (ret) {
-		dev_err(dev, "Error adding irqchip: %d\n", ret);
+		dev_err(dev, "Error adding gpio chip: %d\n", ret);
 		return ret;
 	}
 
-	gpiochip_set_chained_irqchip(chip, irq_chip, irq, NULL);
-
 	device_init_wakeup(dev, true);
 	return 0;
 }

commit ad062195731bea1624ce7160e79e0fcdaa25c1b5
Merge: 7ac63f6ba5db f690790c9da3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Sep 16 19:59:10 2019 -0700

    Merge tag 'platform-drivers-x86-v5.4-1' of git://git.infradead.org/linux-platform-drivers-x86
    
    Pull x86 platform-drivers updates from Andy Shevchenko:
    
     - ASUS WMI driver got a couple of updates, i.e. support of FAN is fixed
       for recent products and the charge threshold support has been added
    
     - Two uknown key events for Dell laptops are being ignored now to avoid
       spamming users with harmless messages
    
     - HP ZBook 17 G5 and ASUS Zenbook UX430UNR got accelerometer support.
    
     - Intel CherryTrail platforms had a regression with wake up. Now it's
       fixed
    
     - Intel PMC driver got fixed in order to work nicely in Xen
       environment
    
     - Intel Speed Select driver provides bucket vs core count relationship.
       Besides that the tools has been updated for better output
    
     - The PrivacyGuard is enabled on Lenovo ThinkPad laptops
    
     - Three tablets - Trekstor Primebook C11B 2-in-1, Irbis TW90 and Chuwi
       Surbook Mini - got touchscreen support
    
    * tag 'platform-drivers-x86-v5.4-1' of git://git.infradead.org/linux-platform-drivers-x86: (53 commits)
      MAINTAINERS: Switch PDx86 subsystem status to Odd Fixes
      platform/x86: asus-wmi: Refactor charge threshold to use the battery hooking API
      platform/x86: asus-wmi: Rename CHARGE_THRESHOLD to RSOC
      platform/x86: asus-wmi: Reorder ASUS_WMI_CHARGE_THRESHOLD
      tools/power/x86/intel-speed-select: Display core count for bucket
      platform/x86: ISST: Allow additional TRL MSRs
      tools/power/x86/intel-speed-select: Fix memory leak
      tools/power/x86/intel-speed-select: Output success/failed for command output
      tools/power/x86/intel-speed-select: Output human readable CPU list
      tools/power/x86/intel-speed-select: Change turbo ratio output to maximum turbo frequency
      tools/power/x86/intel-speed-select: Switch output to MHz
      tools/power/x86/intel-speed-select: Simplify output for turbo-freq and base-freq
      tools/power/x86/intel-speed-select: Fix cpu-count output
      tools/power/x86/intel-speed-select: Fix help option typo
      tools/power/x86/intel-speed-select: Fix package typo
      tools/power/x86/intel-speed-select: Fix a read overflow in isst_set_tdp_level_msr()
      platform/x86: intel_int0002_vgpio: Use device_init_wakeup
      platform/x86: intel_int0002_vgpio: Fix wakeups not working on Cherry Trail
      platform/x86: compal-laptop: Initialize "value" in ec_read_u8()
      platform/x86: touchscreen_dmi: Add info for the Trekstor Primebook C11B 2-in-1
      ...

commit 5fbe5b5883f847363ff1b7280e8b1d2980526b8e
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Sep 4 16:01:04 2019 +0200

    gpio: Initialize the irqchip valid_mask with a callback
    
    After changing the valid_mask for the struct gpio_chip
    to detect the need and presence of a valid mask with the
    presence of a .init_valid_mask() callback to fill it in,
    we augment the gpio_irq_chip to use the same logic.
    
    Switch all driver using the gpio_irq_chio valid_mask
    over to this new method.
    
    This makes sure the valid_mask for the gpio_irq_chip gets
    filled in when we add the gpio_chip, which makes it a
    little easier to switch over drivers using the old
    way of setting up gpio_irq_chip over to the new method
    of passing the gpio_irq_chip along with the gpio_chip.
    (See drivers/gpio/TODO for details.)
    
    Cc: Joel Stanley <joel@jms.id.au>
    Cc: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Tested-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andrew Jeffery <andrew@aj.id.au>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Patrice Chotard <patrice.chotard@st.com>
    Link: https://lore.kernel.org/r/20190904140104.32426-1-linus.walleij@linaro.org

diff --git a/drivers/platform/x86/intel_int0002_vgpio.c b/drivers/platform/x86/intel_int0002_vgpio.c
index d9542c661ddc..f57bbbeb2495 100644
--- a/drivers/platform/x86/intel_int0002_vgpio.c
+++ b/drivers/platform/x86/intel_int0002_vgpio.c
@@ -152,6 +152,13 @@ static const struct x86_cpu_id int0002_cpu_ids[] = {
 	{}
 };
 
+static void int0002_init_irq_valid_mask(struct gpio_chip *chip,
+					unsigned long *valid_mask,
+					unsigned int ngpios)
+{
+	bitmap_clear(valid_mask, 0, GPE0A_PME_B0_VIRT_GPIO_PIN);
+}
+
 static int int0002_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -184,7 +191,7 @@ static int int0002_probe(struct platform_device *pdev)
 	chip->direction_output = int0002_gpio_direction_output;
 	chip->base = -1;
 	chip->ngpio = GPE0A_PME_B0_VIRT_GPIO_PIN + 1;
-	chip->irq.need_valid_mask = true;
+	chip->irq.init_valid_mask = int0002_init_irq_valid_mask;
 
 	ret = devm_gpiochip_add_data(&pdev->dev, chip, NULL);
 	if (ret) {
@@ -192,8 +199,6 @@ static int int0002_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	bitmap_clear(chip->irq.valid_mask, 0, GPE0A_PME_B0_VIRT_GPIO_PIN);
-
 	/*
 	 * We manually request the irq here instead of passing a flow-handler
 	 * to gpiochip_set_chained_irqchip, because the irq is shared.

commit 0ecee9e3d42231e5641671c5b6b1127d3efff1d4
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Aug 23 19:48:15 2019 +0200

    platform/x86: intel_int0002_vgpio: Use device_init_wakeup
    
    Use device_init_wakeup and pm_wakeup_hard_event instead of directly
    calling pm_system_wakeup(). This is the preferred way to do this and
    this will allow the user to disable wakeup through INT0002 events
    through sysfs.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_int0002_vgpio.c b/drivers/platform/x86/intel_int0002_vgpio.c
index 4df10d5b9db9..d291bb482786 100644
--- a/drivers/platform/x86/intel_int0002_vgpio.c
+++ b/drivers/platform/x86/intel_int0002_vgpio.c
@@ -122,7 +122,7 @@ static irqreturn_t int0002_irq(int irq, void *data)
 	generic_handle_irq(irq_find_mapping(chip->irq.domain,
 					    GPE0A_PME_B0_VIRT_GPIO_PIN));
 
-	pm_system_wakeup();
+	pm_wakeup_hard_event(chip->parent);
 
 	return IRQ_HANDLED;
 }
@@ -215,6 +215,13 @@ static int int0002_probe(struct platform_device *pdev)
 
 	gpiochip_set_chained_irqchip(chip, irq_chip, irq, NULL);
 
+	device_init_wakeup(dev, true);
+	return 0;
+}
+
+static int int0002_remove(struct platform_device *pdev)
+{
+	device_init_wakeup(&pdev->dev, false);
 	return 0;
 }
 
@@ -230,6 +237,7 @@ static struct platform_driver int0002_driver = {
 		.acpi_match_table	= int0002_acpi_ids,
 	},
 	.probe	= int0002_probe,
+	.remove	= int0002_remove,
 };
 
 module_platform_driver(int0002_driver);

commit 1bd43d0077b9a32a8b8059036471f3fc82dae342
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Aug 23 19:48:14 2019 +0200

    platform/x86: intel_int0002_vgpio: Fix wakeups not working on Cherry Trail
    
    Commit 871f1f2bcb01 ("platform/x86: intel_int0002_vgpio: Only implement
    irq_set_wake on Bay Trail") removed the irq_set_wake method from the
    struct irq_chip used on Cherry Trail, but it did not set
    IRQCHIP_SKIP_SET_WAKE causing  kernel/irq/manage.c: set_irq_wake_real()
    to return -ENXIO.
    
    This causes the kernel to no longer see PME events reported through the
    INT0002 device as wakeup events. Which e.g. breaks wakeup by the (USB)
    keyboard on many Cherry Trail 2-in-1 devices.
    
    Cc: stable@vger.kernel.org
    Fixes: 871f1f2bcb01 ("platform/x86: intel_int0002_vgpio: Only implement irq_set_wake on Bay Trail")
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_int0002_vgpio.c b/drivers/platform/x86/intel_int0002_vgpio.c
index 4f3f30152a27..4df10d5b9db9 100644
--- a/drivers/platform/x86/intel_int0002_vgpio.c
+++ b/drivers/platform/x86/intel_int0002_vgpio.c
@@ -144,6 +144,7 @@ static struct irq_chip int0002_cht_irqchip = {
 	 * No set_wake, on CHT the IRQ is typically shared with the ACPI SCI
 	 * and we don't want to mess with the ACPI SCI irq settings.
 	 */
+	.flags			= IRQCHIP_SKIP_SET_WAKE,
 };
 
 static const struct x86_cpu_id int0002_cpu_ids[] = {

commit f839b4b549a65e1c611f911654012ac65e6d1610
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Tue Jul 30 11:15:55 2019 -0700

    platform/x86: intel_int0002_vgpio: Remove dev_err() usage after platform_get_irq()
    
    We don't need dev_err() messages when platform_get_irq() fails now that
    platform_get_irq() prints an error message itself when something goes
    wrong. Let's remove these prints with a simple semantic patch.
    
    // <smpl>
    @@
    expression ret;
    struct platform_device *E;
    @@
    
    ret =
    (
    platform_get_irq(E, ...)
    |
    platform_get_irq_byname(E, ...)
    );
    
    if ( \( ret < 0 \| ret <= 0 \) )
    {
    (
    -if (ret != -EPROBE_DEFER)
    -{ ...
    -dev_err(...);
    -... }
    |
    ...
    -dev_err(...);
    )
    ...
    }
    // </smpl>
    
    While we're here, remove braces on if statements that only have one
    statement (manually).
    
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Cc: Hans de Goede <hdegoede@redhat.com>
    Cc: "Darren Hart (VMware)" <dvhart@infradead.org>
    Cc: Roman Kiryanov <rkir@google.com>
    Cc: Vadim Pasternak <vadimp@mellanox.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_int0002_vgpio.c b/drivers/platform/x86/intel_int0002_vgpio.c
index d9542c661ddc..4f3f30152a27 100644
--- a/drivers/platform/x86/intel_int0002_vgpio.c
+++ b/drivers/platform/x86/intel_int0002_vgpio.c
@@ -166,10 +166,8 @@ static int int0002_probe(struct platform_device *pdev)
 		return -ENODEV;
 
 	irq = platform_get_irq(pdev, 0);
-	if (irq < 0) {
-		dev_err(dev, "Error getting IRQ: %d\n", irq);
+	if (irq < 0)
 		return irq;
-	}
 
 	chip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);
 	if (!chip)

commit 568aeeeb69e6af7784418e294b0c37723d03936d
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Jun 19 17:50:50 2019 +0300

    platform/x86: intel_int0002_vgpio: Get rid of custom ICPU() macro
    
    Replace custom grown macro with generic INTEL_CPU_FAM6() one.
    
    No functional change intended.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>

diff --git a/drivers/platform/x86/intel_int0002_vgpio.c b/drivers/platform/x86/intel_int0002_vgpio.c
index 1694a9aec77c..d9542c661ddc 100644
--- a/drivers/platform/x86/intel_int0002_vgpio.c
+++ b/drivers/platform/x86/intel_int0002_vgpio.c
@@ -51,17 +51,6 @@
 #define GPE0A_STS_PORT			0x420
 #define GPE0A_EN_PORT			0x428
 
-#define BAYTRAIL			0x01
-#define CHERRYTRAIL			0x02
-
-#define ICPU(model, data) { X86_VENDOR_INTEL, 6, model, X86_FEATURE_ANY, data }
-
-static const struct x86_cpu_id int0002_cpu_ids[] = {
-	ICPU(INTEL_FAM6_ATOM_SILVERMONT, BAYTRAIL), /* Valleyview, Bay Trail  */
-	ICPU(INTEL_FAM6_ATOM_AIRMONT, CHERRYTRAIL), /* Braswell, Cherry Trail */
-	{}
-};
-
 /*
  * As this is not a real GPIO at all, but just a hack to model an event in
  * ACPI the get / set functions are dummy functions.
@@ -157,6 +146,12 @@ static struct irq_chip int0002_cht_irqchip = {
 	 */
 };
 
+static const struct x86_cpu_id int0002_cpu_ids[] = {
+	INTEL_CPU_FAM6(ATOM_SILVERMONT, int0002_byt_irqchip),	/* Valleyview, Bay Trail  */
+	INTEL_CPU_FAM6(ATOM_AIRMONT, int0002_cht_irqchip),	/* Braswell, Cherry Trail */
+	{}
+};
+
 static int int0002_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -210,10 +205,7 @@ static int int0002_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	if (cpu_id->driver_data == BAYTRAIL)
-		irq_chip = &int0002_byt_irqchip;
-	else
-		irq_chip = &int0002_cht_irqchip;
+	irq_chip = (struct irq_chip *)cpu_id->driver_data;
 
 	ret = gpiochip_irqchip_add(chip, irq_chip, 0, handle_edge_irq,
 				   IRQ_TYPE_NONE);

commit 871f1f2bcb01d205472ddac70d38e8b08e902f15
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun Feb 3 10:42:33 2019 +0100

    platform/x86: intel_int0002_vgpio: Only implement irq_set_wake on Bay Trail
    
    Commit c3b8e884defa ("platform/x86: intel_int0002_vgpio: Implement irq_set_wake"),
    was written to fix some wakeup issues on Bay Trail (BYT) devices.
    
    We've received a bug report that this causes a suspend regression on some
    Cherry Trail (CHT) based devices.
    
    To fix the issues this causes on CHT devices, this commit modifies the
    irq_set_wake support so that we only implement irq_set_wake on BYT devices,
    
    Fixes: c3b8e884defa ("platform/x86: intel_int0002_vgpio: ... irq_set_wake")
    Reported-and-tested-by: Maxim Mikityanskiy <maxtram95@gmail.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_int0002_vgpio.c b/drivers/platform/x86/intel_int0002_vgpio.c
index 4b8f7305fc8a..1694a9aec77c 100644
--- a/drivers/platform/x86/intel_int0002_vgpio.c
+++ b/drivers/platform/x86/intel_int0002_vgpio.c
@@ -51,11 +51,14 @@
 #define GPE0A_STS_PORT			0x420
 #define GPE0A_EN_PORT			0x428
 
-#define ICPU(model)	{ X86_VENDOR_INTEL, 6, model, X86_FEATURE_ANY, }
+#define BAYTRAIL			0x01
+#define CHERRYTRAIL			0x02
+
+#define ICPU(model, data) { X86_VENDOR_INTEL, 6, model, X86_FEATURE_ANY, data }
 
 static const struct x86_cpu_id int0002_cpu_ids[] = {
-	ICPU(INTEL_FAM6_ATOM_SILVERMONT),	/* Valleyview, Bay Trail  */
-	ICPU(INTEL_FAM6_ATOM_AIRMONT),		/* Braswell, Cherry Trail */
+	ICPU(INTEL_FAM6_ATOM_SILVERMONT, BAYTRAIL), /* Valleyview, Bay Trail  */
+	ICPU(INTEL_FAM6_ATOM_AIRMONT, CHERRYTRAIL), /* Braswell, Cherry Trail */
 	{}
 };
 
@@ -135,7 +138,7 @@ static irqreturn_t int0002_irq(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
-static struct irq_chip int0002_irqchip = {
+static struct irq_chip int0002_byt_irqchip = {
 	.name			= DRV_NAME,
 	.irq_ack		= int0002_irq_ack,
 	.irq_mask		= int0002_irq_mask,
@@ -143,10 +146,22 @@ static struct irq_chip int0002_irqchip = {
 	.irq_set_wake		= int0002_irq_set_wake,
 };
 
+static struct irq_chip int0002_cht_irqchip = {
+	.name			= DRV_NAME,
+	.irq_ack		= int0002_irq_ack,
+	.irq_mask		= int0002_irq_mask,
+	.irq_unmask		= int0002_irq_unmask,
+	/*
+	 * No set_wake, on CHT the IRQ is typically shared with the ACPI SCI
+	 * and we don't want to mess with the ACPI SCI irq settings.
+	 */
+};
+
 static int int0002_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	const struct x86_cpu_id *cpu_id;
+	struct irq_chip *irq_chip;
 	struct gpio_chip *chip;
 	int irq, ret;
 
@@ -195,14 +210,19 @@ static int int0002_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	ret = gpiochip_irqchip_add(chip, &int0002_irqchip, 0, handle_edge_irq,
+	if (cpu_id->driver_data == BAYTRAIL)
+		irq_chip = &int0002_byt_irqchip;
+	else
+		irq_chip = &int0002_cht_irqchip;
+
+	ret = gpiochip_irqchip_add(chip, irq_chip, 0, handle_edge_irq,
 				   IRQ_TYPE_NONE);
 	if (ret) {
 		dev_err(dev, "Error adding irqchip: %d\n", ret);
 		return ret;
 	}
 
-	gpiochip_set_chained_irqchip(chip, &int0002_irqchip, irq, NULL);
+	gpiochip_set_chained_irqchip(chip, irq_chip, irq, NULL);
 
 	return 0;
 }

commit eb7046e9bf466cebfcfbcdf640e41d9e3a80086c
Merge: 5b7449810ae6 3b692c55e58d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Nov 1 08:42:21 2018 -0700

    Merge tag 'platform-drivers-x86-v4.20-1' of git://git.infradead.org/linux-platform-drivers-x86
    
    Pull x86 platform driver updates from Darren Hart:
    
     - Move the Dell dcdbas and dell_rbu drivers into platform/drivers/x86
       as they are closely coupled with other drivers in this location.
    
     - Improve _init* usage for acerhdf and fix some usage issues with
       messages and module parameters.
    
     - Simplify asus-wmi by calling ACPI/WMI methods directly, eliminating
       workqueue overhead, eliminate double reporting of keyboard backlight.
    
     - Fix wake from USB failure on Bay Trail devices (intel_int0002_vgpio).
    
     - Notify intel_telemetry users when IPC1 device is not enabled.
    
     - Update various drivers with new laptop model IDs.
    
     - Update several intel drivers to use SPDX identifers and order headers
       alphabetically.
    
    * tag 'platform-drivers-x86-v4.20-1' of git://git.infradead.org/linux-platform-drivers-x86: (64 commits)
      HID: asus: only support backlight when it's not driven by WMI
      platform/x86: asus-wmi: export function for evaluating WMI methods
      platform/x86: asus-wmi: Only notify kbd LED hw_change by fn-key pressed
      platform/x86: wmi: declare device_type structure as constant
      platform/x86: ideapad: Add Y530-15ICH to no_hw_rfkill
      platform/x86: Add Intel AtomISP2 dummy / power-management driver
      platform/x86: touchscreen_dmi: Add min-x and min-y settings for various models
      platform/x86: touchscreen_dmi: Add info for the Onda V80 Plus v3 tablet
      platform/x86: touchscreen_dmi: Add info for the Trekstor Primetab T13B tablet
      platform/x86: intel_telemetry: Get rid of custom macro
      platform/x86: intel_telemetry: report debugfs failure
      MAINTAINERS: intel_telemetry: Update maintainers info
      platform/x86: Add LG Gram laptop special features driver
      platform/x86: asus-wmi: Simplify the keyboard brightness updating process
      platform/x86: touchscreen_dmi: Add info for the Trekstor Primebook C11 convertible
      platform/x86: mlx-platform: Properly use mlxplat_mlxcpld_msn201x_items
      MAINTAINERS: intel_pmc_core: Update MAINTAINERS
      firmware: dcdbas: include linux/io.h
      platform/x86: intel-wmi-thunderbolt: Add dynamic debugging
      platform/x86: intel-wmi-thunderbolt: Convert to use SPDX identifier
      ...

commit f2c4db1bd80720cd8cb2a5aa220d9bc9f374f04e
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Tue Aug 7 10:17:27 2018 -0700

    x86/cpu: Sanitize FAM6_ATOM naming
    
    Going primarily by:
    
      https://en.wikipedia.org/wiki/List_of_Intel_Atom_microprocessors
    
    with additional information gleaned from other related pages; notably:
    
     - Bonnell shrink was called Saltwell
     - Moorefield is the Merriefield refresh which makes it Airmont
    
    The general naming scheme is: FAM6_ATOM_UARCH_SOCTYPE
    
      for i in `git grep -l FAM6_ATOM` ; do
            sed -i  -e 's/ATOM_PINEVIEW/ATOM_BONNELL/g'             \
                    -e 's/ATOM_LINCROFT/ATOM_BONNELL_MID/'          \
                    -e 's/ATOM_PENWELL/ATOM_SALTWELL_MID/g'         \
                    -e 's/ATOM_CLOVERVIEW/ATOM_SALTWELL_TABLET/g'   \
                    -e 's/ATOM_CEDARVIEW/ATOM_SALTWELL/g'           \
                    -e 's/ATOM_SILVERMONT1/ATOM_SILVERMONT/g'       \
                    -e 's/ATOM_SILVERMONT2/ATOM_SILVERMONT_X/g'     \
                    -e 's/ATOM_MERRIFIELD/ATOM_SILVERMONT_MID/g'    \
                    -e 's/ATOM_MOOREFIELD/ATOM_AIRMONT_MID/g'       \
                    -e 's/ATOM_DENVERTON/ATOM_GOLDMONT_X/g'         \
                    -e 's/ATOM_GEMINI_LAKE/ATOM_GOLDMONT_PLUS/g' ${i}
      done
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Vince Weaver <vincent.weaver@maine.edu>
    Cc: dave.hansen@linux.intel.com
    Cc: len.brown@intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/platform/x86/intel_int0002_vgpio.c b/drivers/platform/x86/intel_int0002_vgpio.c
index a473dc51b18d..e89ad4964dc1 100644
--- a/drivers/platform/x86/intel_int0002_vgpio.c
+++ b/drivers/platform/x86/intel_int0002_vgpio.c
@@ -60,7 +60,7 @@ static const struct x86_cpu_id int0002_cpu_ids[] = {
 /*
  * Limit ourselves to Cherry Trail for now, until testing shows we
  * need to handle the INT0002 device on Baytrail too.
- *	ICPU(INTEL_FAM6_ATOM_SILVERMONT1),	 * Valleyview, Bay Trail *
+ *	ICPU(INTEL_FAM6_ATOM_SILVERMONT),	 * Valleyview, Bay Trail *
  */
 	ICPU(INTEL_FAM6_ATOM_AIRMONT),		/* Braswell, Cherry Trail */
 	{}

commit 79c24dbdcbcb23e722e5c2680dba642fcc74a357
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Sep 26 18:27:40 2018 +0300

    platform/x86: intel_int0002_vgpio: Convert to use SPDX identifier
    
    Reduce size of duplicated comments by switching to use SPDX identifier.
    
    No functional change.
    
    While here, correct MODULE_LICENSE() string to be aligned with license text.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_int0002_vgpio.c b/drivers/platform/x86/intel_int0002_vgpio.c
index 33c3489f5bc1..c958a628c375 100644
--- a/drivers/platform/x86/intel_int0002_vgpio.c
+++ b/drivers/platform/x86/intel_int0002_vgpio.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Intel INT0002 "Virtual GPIO" driver
  *
@@ -9,10 +10,6 @@
  *
  * Author: Dyut Kumar Sil <dyut.k.sil@intel.com>
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  * Some peripherals on Bay Trail and Cherry Trail platforms signal a Power
  * Management Event (PME) to the Power Management Controller (PMC) to wakeup
  * the system. When this happens software needs to clear the PME bus 0 status
@@ -228,4 +225,4 @@ module_platform_driver(int0002_driver);
 
 MODULE_AUTHOR("Hans de Goede <hdegoede@redhat.com>");
 MODULE_DESCRIPTION("Intel INT0002 Virtual GPIO driver");
-MODULE_LICENSE("GPL");
+MODULE_LICENSE("GPL v2");

commit c3b8e884defae3ad50956ee77bdba3638fe4852f
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Mon Sep 24 16:37:19 2018 +0200

    platform/x86: intel_int0002_vgpio: Implement irq_set_wake
    
    We were relying on the interrupt being shared with the ACPI SCI and the
    ACPI core calling irq_set_wake. But that does not always happen on
    Bay Trail devices, so we should do it ourselves.
    
    This fixes wake from USB not working on various Bay Trail devices.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_int0002_vgpio.c b/drivers/platform/x86/intel_int0002_vgpio.c
index 987a3b03f225..33c3489f5bc1 100644
--- a/drivers/platform/x86/intel_int0002_vgpio.c
+++ b/drivers/platform/x86/intel_int0002_vgpio.c
@@ -106,6 +106,21 @@ static void int0002_irq_mask(struct irq_data *data)
 	outl(gpe_en_reg, GPE0A_EN_PORT);
 }
 
+static int int0002_irq_set_wake(struct irq_data *data, unsigned int on)
+{
+	struct gpio_chip *chip = irq_data_get_irq_chip_data(data);
+	struct platform_device *pdev = to_platform_device(chip->parent);
+	int irq = platform_get_irq(pdev, 0);
+
+	/* Propagate to parent irq */
+	if (on)
+		enable_irq_wake(irq);
+	else
+		disable_irq_wake(irq);
+
+	return 0;
+}
+
 static irqreturn_t int0002_irq(int irq, void *data)
 {
 	struct gpio_chip *chip = data;
@@ -128,6 +143,7 @@ static struct irq_chip int0002_irqchip = {
 	.irq_ack		= int0002_irq_ack,
 	.irq_mask		= int0002_irq_mask,
 	.irq_unmask		= int0002_irq_unmask,
+	.irq_set_wake		= int0002_irq_set_wake,
 };
 
 static int int0002_probe(struct platform_device *pdev)

commit 96402de65afcd9d7f12e04bf8a14d5a321aca4af
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Sep 19 20:14:51 2018 +0200

    platform/x86: intel_int0002_vgpio: Enable the driver on Bay Trail platforms
    
    The intel_int0002_vgpio driver was added to avoid an IRQ 9 storm on Cherry
    Trail platforms.
    
    When originally merged the CPU ID for Bay Trail SoCs was commented out
    of the list of valid CPU IDs because we did not have any reports of the
    IRQ storm on Bay Trail platforms.
    
    We now have a report of the IRQ 9 storm on the Bay Trail based Thinkpad
    Tablet 10 which is fixed by enabling this driver, so lets enable it on
    Bay Trail too.
    
    I've tested various other Bay Trail device with this driver enabled
    without adverse side-effects.
    
    BugLink: https://www.dpin.de/nf/finally-s0i3-is-there-thinkpad-tablet-10-sleeps-deeply-with-linux-kernel-4-15rc/#comments
    Reported-and-tested-by: Nicole Faerber <nicole@id3p.de>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_int0002_vgpio.c b/drivers/platform/x86/intel_int0002_vgpio.c
index a473dc51b18d..987a3b03f225 100644
--- a/drivers/platform/x86/intel_int0002_vgpio.c
+++ b/drivers/platform/x86/intel_int0002_vgpio.c
@@ -57,11 +57,7 @@
 #define ICPU(model)	{ X86_VENDOR_INTEL, 6, model, X86_FEATURE_ANY, }
 
 static const struct x86_cpu_id int0002_cpu_ids[] = {
-/*
- * Limit ourselves to Cherry Trail for now, until testing shows we
- * need to handle the INT0002 device on Baytrail too.
- *	ICPU(INTEL_FAM6_ATOM_SILVERMONT1),	 * Valleyview, Bay Trail *
- */
+	ICPU(INTEL_FAM6_ATOM_SILVERMONT1),	/* Valleyview, Bay Trail  */
 	ICPU(INTEL_FAM6_ATOM_AIRMONT),		/* Braswell, Cherry Trail */
 	{}
 };

commit 2448f44f31625610ddeafc9c7642da8a78d93c7b
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Nov 22 16:50:33 2017 +0100

    platform/x86: intel_int0002_vgpio: Remove IRQF_NO_THREAD irq flag
    
    Remove the IRQF_NO_THREAD irq flag, there is no need for it and it breaks
    irq-sharing with the "acpi" irq when passing "threadirqs" on the kernel
    cmdline, as the acpi/osl.c code does not pass IRQF_NO_THREAD.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reported-by: Oleksandr Natalenko <oleksandr@natalenko.name>
    Tested-by: Oleksandr Natalenko <oleksandr@natalenko.name>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_int0002_vgpio.c b/drivers/platform/x86/intel_int0002_vgpio.c
index f7b67e898abc..a473dc51b18d 100644
--- a/drivers/platform/x86/intel_int0002_vgpio.c
+++ b/drivers/platform/x86/intel_int0002_vgpio.c
@@ -180,7 +180,7 @@ static int int0002_probe(struct platform_device *pdev)
 	 * to gpiochip_set_chained_irqchip, because the irq is shared.
 	 */
 	ret = devm_request_irq(dev, irq, int0002_irq,
-			       IRQF_SHARED | IRQF_NO_THREAD, "INT0002", chip);
+			       IRQF_SHARED, "INT0002", chip);
 	if (ret) {
 		dev_err(dev, "Error requesting IRQ %d: %d\n", irq, ret);
 		return ret;

commit dc7b0387ee894c115ef5ddcaaf794125d6d9058c
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Nov 7 19:15:52 2017 +0100

    gpio: Move irq_valid_mask into struct gpio_irq_chip
    
    In order to consolidate the multiple ways to associate an IRQ chip with
    a GPIO chip, move more fields into the new struct gpio_irq_chip.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/platform/x86/intel_int0002_vgpio.c b/drivers/platform/x86/intel_int0002_vgpio.c
index f6b3af73dea5..f7b67e898abc 100644
--- a/drivers/platform/x86/intel_int0002_vgpio.c
+++ b/drivers/platform/x86/intel_int0002_vgpio.c
@@ -165,7 +165,7 @@ static int int0002_probe(struct platform_device *pdev)
 	chip->direction_output = int0002_gpio_direction_output;
 	chip->base = -1;
 	chip->ngpio = GPE0A_PME_B0_VIRT_GPIO_PIN + 1;
-	chip->irq_need_valid_mask = true;
+	chip->irq.need_valid_mask = true;
 
 	ret = devm_gpiochip_add_data(&pdev->dev, chip, NULL);
 	if (ret) {
@@ -173,7 +173,7 @@ static int int0002_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	bitmap_clear(chip->irq_valid_mask, 0, GPE0A_PME_B0_VIRT_GPIO_PIN);
+	bitmap_clear(chip->irq.valid_mask, 0, GPE0A_PME_B0_VIRT_GPIO_PIN);
 
 	/*
 	 * We manually request the irq here instead of passing a flow-handler

commit f0fbe7bce733561b76a5b55c5f4625888acd3792
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Nov 7 19:15:47 2017 +0100

    gpio: Move irqdomain into struct gpio_irq_chip
    
    In order to consolidate the multiple ways to associate an IRQ chip with
    a GPIO chip, move more fields into the new struct gpio_irq_chip.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/platform/x86/intel_int0002_vgpio.c b/drivers/platform/x86/intel_int0002_vgpio.c
index 92dc230ef5b2..f6b3af73dea5 100644
--- a/drivers/platform/x86/intel_int0002_vgpio.c
+++ b/drivers/platform/x86/intel_int0002_vgpio.c
@@ -119,7 +119,7 @@ static irqreturn_t int0002_irq(int irq, void *data)
 	if (!(gpe_sts_reg & GPE0A_PME_B0_STS_BIT))
 		return IRQ_NONE;
 
-	generic_handle_irq(irq_find_mapping(chip->irqdomain,
+	generic_handle_irq(irq_find_mapping(chip->irq.domain,
 					    GPE0A_PME_B0_VIRT_GPIO_PIN));
 
 	pm_system_wakeup();

commit 63dada87f7ef7d4a536765c816fbbe7c4b9f3c85
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Mon Jun 12 22:55:46 2017 +0200

    platform/x86: Add driver for ACPI INT0002 Virtual GPIO device
    
    Some peripherals on Bay Trail and Cherry Trail platforms signal a
    Power Management Event (PME) to the Power Management Controller (PMC)
    to wakeup the system. When this happens software needs to explicitly
    clear the PME bus 0 status bit in the GPE0a_STS register to avoid an
    IRQ storm on IRQ 9.
    
    This is modelled in ACPI through the INT0002 ACPI device, which is
    called a "Virtual GPIO controller" in ACPI because it defines the
    event handler to call when the PME triggers through _AEI and _L02
    methods as would be done for a real GPIO interrupt in ACPI.
    
    This commit adds a driver which registers the Virtual GPIOs expected
    by the DSDT on these devices, letting gpiolib-acpi claim the
    virtual GPIO and install a GPIO-interrupt handler which call the _L02
    handler as it would for a real GPIO controller.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/platform/x86/intel_int0002_vgpio.c b/drivers/platform/x86/intel_int0002_vgpio.c
new file mode 100644
index 000000000000..92dc230ef5b2
--- /dev/null
+++ b/drivers/platform/x86/intel_int0002_vgpio.c
@@ -0,0 +1,219 @@
+/*
+ * Intel INT0002 "Virtual GPIO" driver
+ *
+ * Copyright (C) 2017 Hans de Goede <hdegoede@redhat.com>
+ *
+ * Loosely based on android x86 kernel code which is:
+ *
+ * Copyright (c) 2014, Intel Corporation.
+ *
+ * Author: Dyut Kumar Sil <dyut.k.sil@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Some peripherals on Bay Trail and Cherry Trail platforms signal a Power
+ * Management Event (PME) to the Power Management Controller (PMC) to wakeup
+ * the system. When this happens software needs to clear the PME bus 0 status
+ * bit in the GPE0a_STS register to avoid an IRQ storm on IRQ 9.
+ *
+ * This is modelled in ACPI through the INT0002 ACPI device, which is
+ * called a "Virtual GPIO controller" in ACPI because it defines the event
+ * handler to call when the PME triggers through _AEI and _L02 / _E02
+ * methods as would be done for a real GPIO interrupt in ACPI. Note this
+ * is a hack to define an AML event handler for the PME while using existing
+ * ACPI mechanisms, this is not a real GPIO at all.
+ *
+ * This driver will bind to the INT0002 device, and register as a GPIO
+ * controller, letting gpiolib-acpi.c call the _L02 handler as it would
+ * for a real GPIO controller.
+ */
+
+#include <linux/acpi.h>
+#include <linux/bitmap.h>
+#include <linux/gpio/driver.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/suspend.h>
+
+#include <asm/cpu_device_id.h>
+#include <asm/intel-family.h>
+
+#define DRV_NAME			"INT0002 Virtual GPIO"
+
+/* For some reason the virtual GPIO pin tied to the GPE is numbered pin 2 */
+#define GPE0A_PME_B0_VIRT_GPIO_PIN	2
+
+#define GPE0A_PME_B0_STS_BIT		BIT(13)
+#define GPE0A_PME_B0_EN_BIT		BIT(13)
+#define GPE0A_STS_PORT			0x420
+#define GPE0A_EN_PORT			0x428
+
+#define ICPU(model)	{ X86_VENDOR_INTEL, 6, model, X86_FEATURE_ANY, }
+
+static const struct x86_cpu_id int0002_cpu_ids[] = {
+/*
+ * Limit ourselves to Cherry Trail for now, until testing shows we
+ * need to handle the INT0002 device on Baytrail too.
+ *	ICPU(INTEL_FAM6_ATOM_SILVERMONT1),	 * Valleyview, Bay Trail *
+ */
+	ICPU(INTEL_FAM6_ATOM_AIRMONT),		/* Braswell, Cherry Trail */
+	{}
+};
+
+/*
+ * As this is not a real GPIO at all, but just a hack to model an event in
+ * ACPI the get / set functions are dummy functions.
+ */
+
+static int int0002_gpio_get(struct gpio_chip *chip, unsigned int offset)
+{
+	return 0;
+}
+
+static void int0002_gpio_set(struct gpio_chip *chip, unsigned int offset,
+			     int value)
+{
+}
+
+static int int0002_gpio_direction_output(struct gpio_chip *chip,
+					 unsigned int offset, int value)
+{
+	return 0;
+}
+
+static void int0002_irq_ack(struct irq_data *data)
+{
+	outl(GPE0A_PME_B0_STS_BIT, GPE0A_STS_PORT);
+}
+
+static void int0002_irq_unmask(struct irq_data *data)
+{
+	u32 gpe_en_reg;
+
+	gpe_en_reg = inl(GPE0A_EN_PORT);
+	gpe_en_reg |= GPE0A_PME_B0_EN_BIT;
+	outl(gpe_en_reg, GPE0A_EN_PORT);
+}
+
+static void int0002_irq_mask(struct irq_data *data)
+{
+	u32 gpe_en_reg;
+
+	gpe_en_reg = inl(GPE0A_EN_PORT);
+	gpe_en_reg &= ~GPE0A_PME_B0_EN_BIT;
+	outl(gpe_en_reg, GPE0A_EN_PORT);
+}
+
+static irqreturn_t int0002_irq(int irq, void *data)
+{
+	struct gpio_chip *chip = data;
+	u32 gpe_sts_reg;
+
+	gpe_sts_reg = inl(GPE0A_STS_PORT);
+	if (!(gpe_sts_reg & GPE0A_PME_B0_STS_BIT))
+		return IRQ_NONE;
+
+	generic_handle_irq(irq_find_mapping(chip->irqdomain,
+					    GPE0A_PME_B0_VIRT_GPIO_PIN));
+
+	pm_system_wakeup();
+
+	return IRQ_HANDLED;
+}
+
+static struct irq_chip int0002_irqchip = {
+	.name			= DRV_NAME,
+	.irq_ack		= int0002_irq_ack,
+	.irq_mask		= int0002_irq_mask,
+	.irq_unmask		= int0002_irq_unmask,
+};
+
+static int int0002_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	const struct x86_cpu_id *cpu_id;
+	struct gpio_chip *chip;
+	int irq, ret;
+
+	/* Menlow has a different INT0002 device? <sigh> */
+	cpu_id = x86_match_cpu(int0002_cpu_ids);
+	if (!cpu_id)
+		return -ENODEV;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(dev, "Error getting IRQ: %d\n", irq);
+		return irq;
+	}
+
+	chip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+
+	chip->label = DRV_NAME;
+	chip->parent = dev;
+	chip->owner = THIS_MODULE;
+	chip->get = int0002_gpio_get;
+	chip->set = int0002_gpio_set;
+	chip->direction_input = int0002_gpio_get;
+	chip->direction_output = int0002_gpio_direction_output;
+	chip->base = -1;
+	chip->ngpio = GPE0A_PME_B0_VIRT_GPIO_PIN + 1;
+	chip->irq_need_valid_mask = true;
+
+	ret = devm_gpiochip_add_data(&pdev->dev, chip, NULL);
+	if (ret) {
+		dev_err(dev, "Error adding gpio chip: %d\n", ret);
+		return ret;
+	}
+
+	bitmap_clear(chip->irq_valid_mask, 0, GPE0A_PME_B0_VIRT_GPIO_PIN);
+
+	/*
+	 * We manually request the irq here instead of passing a flow-handler
+	 * to gpiochip_set_chained_irqchip, because the irq is shared.
+	 */
+	ret = devm_request_irq(dev, irq, int0002_irq,
+			       IRQF_SHARED | IRQF_NO_THREAD, "INT0002", chip);
+	if (ret) {
+		dev_err(dev, "Error requesting IRQ %d: %d\n", irq, ret);
+		return ret;
+	}
+
+	ret = gpiochip_irqchip_add(chip, &int0002_irqchip, 0, handle_edge_irq,
+				   IRQ_TYPE_NONE);
+	if (ret) {
+		dev_err(dev, "Error adding irqchip: %d\n", ret);
+		return ret;
+	}
+
+	gpiochip_set_chained_irqchip(chip, &int0002_irqchip, irq, NULL);
+
+	return 0;
+}
+
+static const struct acpi_device_id int0002_acpi_ids[] = {
+	{ "INT0002", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(acpi, int0002_acpi_ids);
+
+static struct platform_driver int0002_driver = {
+	.driver = {
+		.name			= DRV_NAME,
+		.acpi_match_table	= int0002_acpi_ids,
+	},
+	.probe	= int0002_probe,
+};
+
+module_platform_driver(int0002_driver);
+
+MODULE_AUTHOR("Hans de Goede <hdegoede@redhat.com>");
+MODULE_DESCRIPTION("Intel INT0002 Virtual GPIO driver");
+MODULE_LICENSE("GPL");
