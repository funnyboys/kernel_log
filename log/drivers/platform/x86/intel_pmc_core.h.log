commit 01f259f3720c3965443109d82a0f12611ea8bb58
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Apr 28 23:36:38 2020 +0200

    platform/x86: intel_pmc_core: avoid unused-function warnings
    
    When both CONFIG_DEBUG_FS and CONFIG_PM_SLEEP are disabled, the
    functions that got moved out of the #ifdef section now cause
    a warning:
    
    drivers/platform/x86/intel_pmc_core.c:654:13: error: 'pmc_core_lpm_display' defined but not used [-Werror=unused-function]
      654 | static void pmc_core_lpm_display(struct pmc_dev *pmcdev, struct device *dev,
          |             ^~~~~~~~~~~~~~~~~~~~
    drivers/platform/x86/intel_pmc_core.c:617:13: error: 'pmc_core_slps0_display' defined but not used [-Werror=unused-function]
      617 | static void pmc_core_slps0_display(struct pmc_dev *pmcdev, struct device *dev,
          |             ^~~~~~~~~~~~~~~~~~~~~~
    
    Rather than add even more #ifdefs here, remove them entirely and
    let the compiler work it out, it can actually get rid of all the
    debugfs calls without problems as long as the struct member is
    there.
    
    The two PM functions just need a __maybe_unused annotations to avoid
    another warning instead of the #ifdef.
    
    Fixes: aae43c2bcdc1 ("platform/x86: intel_pmc_core: Relocate pmc_core_*_display() to outside of CONFIG_DEBUG_FS")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index 0d50b2402abe..5eae55d80226 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -282,9 +282,7 @@ struct pmc_dev {
 	u32 base_addr;
 	void __iomem *regbase;
 	const struct pmc_reg_map *map;
-#if IS_ENABLED(CONFIG_DEBUG_FS)
 	struct dentry *dbgfs_dir;
-#endif /* CONFIG_DEBUG_FS */
 	int pmc_xram_read_bit;
 	struct mutex lock; /* generic mutex lock for PMC Core */
 

commit c61b693c9a032991f34cc4034b466d7807fd61ab
Author: Gayatri Kammela <gayatri.kammela@intel.com>
Date:   Sun Mar 1 12:44:25 2020 -0800

    platform/x86: intel_pmc_core: Make pmc_core_substate_res_show() generic
    
    Currently pmc_core_substate_res_show() uses array of char pointers
    i.e., lpm_modes for Tiger Lake directly to iterate through and to get
    the number of low power modes which is hardcoded and cannot be re-used
    for future platforms that support sub-states. To maintain readability,
    make pmc_core_substate_res_show() generic, so that it can re-used for
    future platforms.
    
    Cc: Chen Zhou <chenzhou10@huawei.com>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: David E. Box <david.e.box@intel.com>
    Signed-off-by: Gayatri Kammela <gayatri.kammela@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index 1bbdffe80bde..0d50b2402abe 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -198,7 +198,7 @@ enum ppfear_regs {
 #define TGL_LPM_STATUS_OFFSET			0x1C3C
 #define TGL_LPM_LIVE_STATUS_OFFSET		0x1C5C
 
-const char *lpm_modes[] = {
+const char *tgl_lpm_modes[] = {
 	"S0i2.0",
 	"S0i2.1",
 	"S0i2.2",
@@ -255,6 +255,7 @@ struct pmc_reg_map {
 	const u32 ltr_ignore_max;
 	const u32 pm_vric1_offset;
 	/* Low Power Mode registers */
+	const char **lpm_modes;
 	const u32 lpm_en_offset;
 	const u32 lpm_residency_offset;
 	const u32 lpm_status_offset;

commit 7adb1e8aeeb5d4d88012568b2049599c1a247cf2
Author: Gayatri Kammela <gayatri.kammela@intel.com>
Date:   Tue Feb 4 15:02:00 2020 -0800

    platform/x86: intel_pmc_core: Add debugfs support to access live status registers
    
    Just like status registers, Tiger Lake has another set of 6 registers
    that help with status of the low power mode requirements. They are
    latched on every PC10 entry/exit and S0ix.y entry/exit as well.
    
    Though status and live status registers show the status of same list
    of requirements, live status registers show the status of the low power
    mode requirements at the time of reading.
    
    Cc: Srinivas Pandruvada <srinivas.pandruvada@intel.com>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: David E. Box <david.e.box@intel.com>
    Signed-off-by: Gayatri Kammela <gayatri.kammela@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index 3fdf4735c56f..1bbdffe80bde 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -196,6 +196,7 @@ enum ppfear_regs {
 
 /* Tigerlake Low Power Mode debug registers */
 #define TGL_LPM_STATUS_OFFSET			0x1C3C
+#define TGL_LPM_LIVE_STATUS_OFFSET		0x1C5C
 
 const char *lpm_modes[] = {
 	"S0i2.0",
@@ -257,6 +258,7 @@ struct pmc_reg_map {
 	const u32 lpm_en_offset;
 	const u32 lpm_residency_offset;
 	const u32 lpm_status_offset;
+	const u32 lpm_live_status_offset;
 };
 
 /**

commit f632817d5ef369a6f433449a1b8fa26627fc40e0
Author: Gayatri Kammela <gayatri.kammela@intel.com>
Date:   Tue Feb 4 15:01:55 2020 -0800

    platform/x86: intel_pmc_core: Add debugfs entry for low power mode status registers
    
    Tiger Lake has 6 status registers that are memory mapped. These
    registers show the status of the low power mode requirements. The
    registers are latched on every C10 entry or exit and on every s0ix.y
    entry/exit. Accessing these registers is useful for debugging any low
    power related activities.
    
    Thus, add debugfs entry to access low power mode status registers.
    
    Cc: Srinivas Pandruvada <srinivas.pandruvada@intel.com>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: David Box <david.e.box@intel.com>
    Signed-off-by: David Box <david.e.box@intel.com>
    Signed-off-by: Gayatri Kammela <gayatri.kammela@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index ff1b2645d9b4..3fdf4735c56f 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -194,6 +194,9 @@ enum ppfear_regs {
 #define TGL_LPM_EN_OFFSET			0x1C78
 #define TGL_LPM_RESIDENCY_OFFSET		0x1C80
 
+/* Tigerlake Low Power Mode debug registers */
+#define TGL_LPM_STATUS_OFFSET			0x1C3C
+
 const char *lpm_modes[] = {
 	"S0i2.0",
 	"S0i2.1",
@@ -239,6 +242,7 @@ struct pmc_reg_map {
 	const struct pmc_bit_map **slps0_dbg_maps;
 	const struct pmc_bit_map *ltr_show_sts;
 	const struct pmc_bit_map *msr_sts;
+	const struct pmc_bit_map **lpm_sts;
 	const u32 slp_s0_offset;
 	const u32 ltr_ignore_offset;
 	const int regmap_length;
@@ -252,6 +256,7 @@ struct pmc_reg_map {
 	/* Low Power Mode registers */
 	const u32 lpm_en_offset;
 	const u32 lpm_residency_offset;
+	const u32 lpm_status_offset;
 };
 
 /**

commit a45096ac70e59498ef3d1fe67ab6a10dbccf59ef
Author: Gayatri Kammela <gayatri.kammela@intel.com>
Date:   Tue Feb 4 15:01:54 2020 -0800

    platform/x86: intel_pmc_core: Add debugfs entry to access sub-state residencies
    
    Prior to Tiger Lake, the platforms that support pmc_core have no
    sub-states of S0ix. Tiger Lake has 8 sub-states/low power modes of S0ix
    ranging from S0i2.0-S0i2.2 and S0i3.0-S0i3.4, simply represented as
    S0ix.y.
    
    Create a debugfs entry to access residency of each sub-state.
    
    Cc: Srinivas Pandruvada <srinivas.pandruvada@intel.com>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: David Box <david.e.box@intel.com>
    Signed-off-by: David Box <david.e.box@intel.com>
    Signed-off-by: Gayatri Kammela <gayatri.kammela@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index f1a0792b3f91..ff1b2645d9b4 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -188,6 +188,24 @@ enum ppfear_regs {
 
 #define TGL_NUM_IP_IGN_ALLOWED			22
 
+/*
+ * Tigerlake Power Management Controller register offsets
+ */
+#define TGL_LPM_EN_OFFSET			0x1C78
+#define TGL_LPM_RESIDENCY_OFFSET		0x1C80
+
+const char *lpm_modes[] = {
+	"S0i2.0",
+	"S0i2.1",
+	"S0i2.2",
+	"S0i3.0",
+	"S0i3.1",
+	"S0i3.2",
+	"S0i3.3",
+	"S0i3.4",
+	NULL
+};
+
 struct pmc_bit_map {
 	const char *name;
 	u32 bit_mask;
@@ -231,6 +249,9 @@ struct pmc_reg_map {
 	const u32 slps0_dbg_offset;
 	const u32 ltr_ignore_max;
 	const u32 pm_vric1_offset;
+	/* Low Power Mode registers */
+	const u32 lpm_en_offset;
+	const u32 lpm_residency_offset;
 };
 
 /**

commit 84abc5a1c924548099a2d9cd0e8b8c1928ef5b55
Author: Nishad Kamdar <nishadkamdar@gmail.com>
Date:   Thu Dec 19 20:00:01 2019 +0530

    platform/x86: intel-ips: Use the correct style for SPDX License Identifier
    
    This patch corrects the SPDX License Identifier style in
    header files related to x86 Platform Specific Drivers.
    For C header files Documentation/process/license-rules.rst
    mandates C-like comments (opposed to C source files where
    C++ style should be used).
    
    Changes made by using a script provided by Joe Perches here:
    https://lkml.org/lkml/2019/2/7/46.
    
    Suggested-by: Joe Perches <joe@perches.com>
    Signed-off-by: Nishad Kamdar <nishadkamdar@gmail.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index 99acdc051342..f1a0792b3f91 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Intel Core SoC Power Management Controller Header File
  *

commit 49a437941c3f9e12254c0f4e97201900cb756b3a
Author: Gayatri Kammela <gayatri.kammela@intel.com>
Date:   Thu Dec 12 10:38:46 2019 -0800

    platform/x86: intel_pmc_core: Add Intel Tiger Lake support
    
    Add Intel Tiger Lake to the list of the platforms that driver supports
    for the PMC device.
    
    Just like Ice Lake, Tiger Lake can also reuse all the Cannon Lake PCH
    IPs. Since Tiger Lake has almost the same number of PCH IPs as Ice Lake,
    reuse Ice Lake's PPFEAR_NUM_ENTRIES instead of defining a new macro.
    
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Srinivas Pandruvada <srinivas.pandruvada@intel.com>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Kan Liang <kan.liang@intel.com>
    Cc: David E. Box <david.e.box@intel.com>
    Cc: Rajneesh Bhardwaj <irenic.rajneesh@gmail.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Reviewed-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Gayatri Kammela <gayatri.kammela@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index 4b9f9ad6b692..99acdc051342 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -186,6 +186,8 @@ enum ppfear_regs {
 #define ICL_NUM_IP_IGN_ALLOWED			20
 #define ICL_PMC_LTR_WIGIG			0x1BFC
 
+#define TGL_NUM_IP_IGN_ALLOWED			22
+
 struct pmc_bit_map {
 	const char *name;
 	u32 bit_mask;

commit e3985478183019bf41b40c44049333bf74b26fc3
Author: Gayatri Kammela <gayatri.kammela@intel.com>
Date:   Thu Dec 12 10:38:44 2019 -0800

    platform/x86: intel_pmc_core: Create platform dependent bitmap structs
    
    The current implementation of intel_pmc_core driver allows to reuse, but does
    not reflect the exact number and names of IPs for a newer platform which
    does not necessarily support all the IPs in the entries. The names and
    number of these IPs might differ from its previous platforms. The number
    of PCH IPs per platform is calculated based on PPFEAR_NUM_ENTRIES
    defined, where each entry represents a bucket (8 bits). The platform can
    support 'n' entries, but not necessarily all 'n * 8' IPs.
    
    Create platform dependent bitmap structures to specify the exact number,
    names of IPs while reusing the existing IPs.
    
    The changes in this patch are preparatory to accommodate future SoCs
    that might reuse the CNL/ICL PCH IPs, and to reflect the exact number of
    IPs with its names.
    
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Srinivas Pandruvada <srinivas.pandruvada@intel.com>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Kan Liang <kan.liang@intel.com>
    Cc: David E. Box <david.e.box@intel.com>
    Cc: Rajneesh Bhardwaj <irenic.rajneesh@gmail.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Reviewed-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Gayatri Kammela <gayatri.kammela@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index fdee5772e532..4b9f9ad6b692 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -213,7 +213,7 @@ struct pmc_bit_map {
  * captures them to have a common implementation.
  */
 struct pmc_reg_map {
-	const struct pmc_bit_map *pfear_sts;
+	const struct pmc_bit_map **pfear_sts;
 	const struct pmc_bit_map *mphy_sts;
 	const struct pmc_bit_map *pll_sts;
 	const struct pmc_bit_map **slps0_dbg_maps;

commit 2ac8d46dce1b62d19be6a4fa37334c185b1c75fa
Author: Rajat Jain <rajatja@google.com>
Date:   Wed Apr 17 16:01:54 2019 -0700

    platform/x86: intel_pmc_core: Allow to dump debug registers on S0ix failure
    
    Add a module parameter which when enabled, will check on resume, if the
    last S0ix attempt was successful. If not, the driver would warn and provide
    helpful debug information (which gets latched during the failed suspend
    attempt) to debug the S0ix failure.
    
    This information is very useful to debug S0ix failures. Specially since
    the latched debug information will be lost (over-written) if the system
    attempts to go into runtime (or imminent) S0ix again after that failed
    suspend attempt.
    
    Signed-off-by: Rajat Jain <rajatja@google.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index 88d9c0653a5f..fdee5772e532 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -241,6 +241,9 @@ struct pmc_reg_map {
  * @pmc_xram_read_bit:	flag to indicate whether PMC XRAM shadow registers
  *			used to read MPHY PG and PLL status are available
  * @mutex_lock:		mutex to complete one transcation
+ * @check_counters:	On resume, check if counters are getting incremented
+ * @pc10_counter:	PC10 residency counter
+ * @s0ix_counter:	S0ix residency (step adjusted)
  *
  * pmc_dev contains info about power management controller device.
  */
@@ -253,6 +256,10 @@ struct pmc_dev {
 #endif /* CONFIG_DEBUG_FS */
 	int pmc_xram_read_bit;
 	struct mutex lock; /* generic mutex lock for PMC Core */
+
+	bool check_counters; /* Check for counter increments on resume */
+	u64 pc10_counter;
+	u64 s0ix_counter;
 };
 
 #endif /* PMC_CORE_H */

commit 238f9c11351f8af8534ae0318b4d9acc77b09ee8
Author: Rajneesh Bhardwaj <rajneesh.bhardwaj@linux.intel.com>
Date:   Thu Feb 14 17:27:12 2019 +0530

    platform/x86: intel_pmc_core: Quirk to ignore XTAL shutdown
    
    On some platforms such as HP Elite-x2-1013-g3, the platform BIOS
    enforces XTAL to remain off before S0ix state can be achieved. This may
    not be optimum when we want to enable use cases like Low Power Audio,
    Wake on Voice etc which always need 24mhz clock.
    
    This introduces a new quirk to allow S0ix entry when all other
    conditions except for XTAL clock are good on a given platform. The extra
    power consumed by XTAL clock is about 2mw but it saves much more
    platform power compared to the system that remains in just PC10.
    
    Link: https://bit.ly/2UmnrFf
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=201579
    Tested-by: "David E. Box" <david.e.box@linux.intel.com>
    Reported-and-tested-by: russianneuromancer <russianneuromancer@ya.ru>
    Signed-off-by: Rajneesh Bhardwaj <rajneesh.bhardwaj@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index 6f1b64808075..88d9c0653a5f 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -25,6 +25,7 @@
 #define SPT_PMC_MTPMC_OFFSET			0x20
 #define SPT_PMC_MFPMC_OFFSET			0x38
 #define SPT_PMC_LTR_IGNORE_OFFSET		0x30C
+#define SPT_PMC_VRIC1_OFFSET			0x31c
 #define SPT_PMC_MPHY_CORE_STS_0			0x1143
 #define SPT_PMC_MPHY_CORE_STS_1			0x1142
 #define SPT_PMC_MPHY_COM_STS_0			0x1155
@@ -136,6 +137,9 @@ enum ppfear_regs {
 #define SPT_PMC_BIT_MPHY_CMN_LANE2		BIT(2)
 #define SPT_PMC_BIT_MPHY_CMN_LANE3		BIT(3)
 
+#define SPT_PMC_VRIC1_SLPS0LVEN			BIT(13)
+#define SPT_PMC_VRIC1_XTALSDQDIS		BIT(22)
+
 /* Cannonlake Power Management Controller register offsets */
 #define CNP_PMC_SLPS0_DBG_OFFSET		0x10B4
 #define CNP_PMC_PM_CFG_OFFSET			0x1818
@@ -224,6 +228,7 @@ struct pmc_reg_map {
 	const int pm_read_disable_bit;
 	const u32 slps0_dbg_offset;
 	const u32 ltr_ignore_max;
+	const u32 pm_vric1_offset;
 };
 
 /**

commit 8aba056a4ea6da18186025a335a96b2f071e69d3
Author: Rajneesh Bhardwaj <rajneesh.bhardwaj@linux.intel.com>
Date:   Thu Feb 14 17:27:11 2019 +0530

    platform/x86: intel_pmc_core: Add Package cstates residency info
    
    This patch introduces a new debugfs entry to read current Package
    cstate residency counters. A similar variant of this patch was discussed
    earlier "https://patchwork.kernel.org/patch/9908563/" but didn't make it
    into mainline for various reasons. Current version only adds debugfs
    entry which is quite useful for S0ix debug but excludes the exported API
    that was there in initial version. Though there are tools like turbostat
    and socwatch which can also show this info but sometimes its more
    practical to have it here as it's hard to switch between various tools for
    S0ix debug when pmc_core driver is the primary debug tool. Internal and
    external customers have requested for this patch to be included in the
    PMC driver on many occasions and Google Chrome OS team has already included
    it in their builds. This becomes handy when requesting logs from external
    customers who may not always have above mentioned tools in their integrated
    kernel builds.
    
    Package cstate residency MSRs provide useful debug information about
    system idle states. In idle states system must enter deeper Package
    cstates. Package cstates depend not only on Core cstates but also on
    various IP block's power gating status and LTR values.
    
    For Intel Core SoCs Package C10 entry is a must for deeper sleep states
    such as S0ix. "Suspend-to-idle"  should ideally take this path:
    PC0 -> PC10 -> S0ix. For S0ix debug, its logical to check for
    Package C10 residency first if for some reason system fails to enter S0ix.
    
    Please refer to this link for MSR details:
    https://software.intel.com/sites/default/files/managed/22/0d/335592-sdm-vol-4.pdf
    
    Usage:
    cat /sys/kernel/debug/pmc_core/package_cstate_show
    Package C2       : 0xec2e21735f
    Package C3       : 0xc30113ba4
    Package C6       : 0x9ef4be15c5
    Package C7       : 0x1e011904
    Package C8       : 0x3c5653cfe5a
    Package C9       : 0x0
    Package C10      : 0x16fff4289
    
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: "David E. Box" <david.e.box@intel.com>
    Cc: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Cc: Anshuman Gupta <anshuman.gupta@intel.com>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-and-tested-by: Anshuman Gupta <anshuman.gupta@intel.com>
    Signed-off-by: Rajneesh Bhardwaj <rajneesh.bhardwaj@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index 78dd4229489d..6f1b64808075 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -214,6 +214,7 @@ struct pmc_reg_map {
 	const struct pmc_bit_map *pll_sts;
 	const struct pmc_bit_map **slps0_dbg_maps;
 	const struct pmc_bit_map *ltr_show_sts;
+	const struct pmc_bit_map *msr_sts;
 	const u32 slp_s0_offset;
 	const u32 ltr_ignore_offset;
 	const int regmap_length;

commit 6769fdbe27d782dfee5e459e25b44baacc7c8459
Author: Rajneesh Bhardwaj <rajneesh.bhardwaj@linux.intel.com>
Date:   Thu Feb 14 17:27:10 2019 +0530

    platform/x86: intel_pmc_core: Add ICL platform support
    
    Icelake can resue most of the CNL PCH IPs as they are mostly similar.
    This patch enables the PMC Core driver for ICL family.
    
    It also addresses few other minor issues like upper case conversions and
    some tab alignments.
    
    Cc: "David E. Box" <david.e.box@intel.com>
    Cc: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Acked-and-tested-by: Anshuman Gupta <anshuman.gupta@intel.com>
    Signed-off-by: Rajneesh Bhardwaj <rajneesh.bhardwaj@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index 0680ca397b57..78dd4229489d 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -178,6 +178,10 @@ enum ppfear_regs {
 #define LTR_REQ_SNOOP				BIT(15)
 #define LTR_REQ_NONSNOOP			BIT(31)
 
+#define ICL_PPFEAR_NUM_ENTRIES			9
+#define ICL_NUM_IP_IGN_ALLOWED			20
+#define ICL_PMC_LTR_WIGIG			0x1BFC
+
 struct pmc_bit_map {
 	const char *name;
 	u32 bit_mask;

commit 2a13096ac7da07a1bfc9d91fc4a982020e7ded2b
Author: Rajneesh Bhardwaj <rajneesh.bhardwaj@linux.intel.com>
Date:   Fri Feb 1 13:02:29 2019 +0530

    platform/x86: intel_pmc_core: Include Reserved IP for LTR
    
    Recently introduced commit "platform/x86: intel_pmc_core: Show Latency
    Tolerance info <51337cd94d18184601ac0fb4cf1a02b8bbabc3d7> skipped the
    LTR from a reserved IP. Though this doesn't cause any functional issue
    but it is needed for the consumers of "ltr_ignore" as the index printing
    for "ltr_show" is missing. For example, w/o this change, a user that wants
    to ignore LTR from ME would do something like
    
    echo 5 > ltr_ignore
    
    but the index for ME is 6. Printing a reserved IP helps to properly
    calculate LTR ignore offsets.
    
    Cc: "David E. Box" <david.e.box@intel.com>
    Cc: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Rajneesh Bhardwaj <rajneesh.bhardwaj@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index 1a0104d2cbf0..0680ca397b57 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -46,6 +46,7 @@
 #define SPT_PMC_LTR_SATA			0x368
 #define SPT_PMC_LTR_GBE				0x36C
 #define SPT_PMC_LTR_XHCI			0x370
+#define SPT_PMC_LTR_RESERVED			0x374
 #define SPT_PMC_LTR_ME				0x378
 #define SPT_PMC_LTR_EVA				0x37C
 #define SPT_PMC_LTR_SPC				0x380
@@ -156,6 +157,7 @@ enum ppfear_regs {
 #define CNP_PMC_LTR_SATA			0x1B68
 #define CNP_PMC_LTR_GBE				0x1B6C
 #define CNP_PMC_LTR_XHCI			0x1B70
+#define CNP_PMC_LTR_RESERVED			0x1B74
 #define CNP_PMC_LTR_ME				0x1B78
 #define CNP_PMC_LTR_EVA				0x1B7C
 #define CNP_PMC_LTR_SPC				0x1B80

commit 0e68eeea9894feeba2edf7ec63e4551b87f39621
Author: Rajneesh Bhardwaj <rajneesh.bhardwaj@linux.intel.com>
Date:   Fri Feb 1 13:02:26 2019 +0530

    platform/x86: intel_pmc_core: Fix PCH IP sts reading
    
    A previous commit "platform/x86: intel_pmc_core: Make the driver PCH
    family agnostic <c977b98bbef5898ed3d30b08ea67622e9e82082a>" provided
    better abstraction to this driver but has some fundamental issues.
    
    e.g. the following condition
    
    for (index = 0; index < pmcdev->map->ppfear_buckets &&
            index < PPFEAR_MAX_NUM_ENTRIES; index++, iter++)
    
    is wrong because for CNL, PPFEAR_MAX_NUM_ENTRIES is hardcoded as 5 which
    is _wrong_ and even though ppfear_buckets is 8, the loop fails to read
    all eight registers needed for CNL PCH i.e. PPFEAR0 and PPFEAR1. This
    patch refactors the pfear show logic to correctly read PCH IP power
    gating status for Cannonlake and beyond.
    
    Cc: "David E. Box" <david.e.box@intel.com>
    Cc: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Fixes: c977b98bbef5 ("platform/x86: intel_pmc_core: Make the driver PCH family agnostic")
    Signed-off-by: Rajneesh Bhardwaj <rajneesh.bhardwaj@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index 89554cba5758..1a0104d2cbf0 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -32,7 +32,7 @@
 #define SPT_PMC_SLP_S0_RES_COUNTER_STEP		0x64
 #define PMC_BASE_ADDR_MASK			~(SPT_PMC_MMIO_REG_LEN - 1)
 #define MTPMC_MASK				0xffff0000
-#define PPFEAR_MAX_NUM_ENTRIES			5
+#define PPFEAR_MAX_NUM_ENTRIES			12
 #define SPT_PPFEAR_NUM_ENTRIES			5
 #define SPT_PMC_READ_DISABLE_BIT		0x16
 #define SPT_PMC_MSG_FULL_STS_BIT		0x18

commit 8122e7cd806df4c696eed0c9a6ad1e69dfe783fc
Author: Rajneesh Bhardwaj <rajneesh.bhardwaj@linux.intel.com>
Date:   Fri Nov 9 00:32:44 2018 +0530

    platform/x86: intel_pmc_core: Decode Snoop / Non Snoop LTR
    
    The LTR values follow PCIE LTR encoding format and can be decoded as per
    https://pcisig.com/sites/default/files/specification_documents/ECN_LatencyTolnReporting_14Aug08.pdf
    
    This adds support to translate the raw LTR values as read from the PMC
    to meaningful values in nanosecond units of time.
    
    Signed-off-by: Rajneesh Bhardwaj <rajneesh.bhardwaj@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index e57b26cdb442..89554cba5758 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -12,6 +12,8 @@
 #ifndef PMC_CORE_H
 #define PMC_CORE_H
 
+#include <linux/bits.h>
+
 #define PMC_BASE_ADDR_DEFAULT			0xFE000000
 
 /* Sunrise Point Power Management Controller PCI Device ID */
@@ -169,6 +171,11 @@ enum ppfear_regs {
 #define CNP_PMC_LTR_EMMC			0x1BF4
 #define CNP_PMC_LTR_UFSX2			0x1BF8
 
+#define LTR_DECODED_VAL				GENMASK(9, 0)
+#define LTR_DECODED_SCALE			GENMASK(12, 10)
+#define LTR_REQ_SNOOP				BIT(15)
+#define LTR_REQ_NONSNOOP			BIT(31)
+
 struct pmc_bit_map {
 	const char *name;
 	u32 bit_mask;

commit 2d649d972bae50199a498f46b945ef8fd78cad5a
Author: Rajneesh Bhardwaj <rajneesh.bhardwaj@linux.intel.com>
Date:   Fri Nov 9 00:32:43 2018 +0530

    platform/x86: intel_pmc_core: Fix LTR IGNORE Max offset
    
    Cannonlake PCH allows us to ignore LTR from more IPs than Sunrisepoint
    PCH so make the LTR ignore platform specific.
    
    Signed-off-by: Rajneesh Bhardwaj <rajneesh.bhardwaj@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index fcb13ca1f2bd..e57b26cdb442 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -35,7 +35,7 @@
 #define SPT_PMC_READ_DISABLE_BIT		0x16
 #define SPT_PMC_MSG_FULL_STS_BIT		0x18
 #define NUM_RETRIES				100
-#define NUM_IP_IGN_ALLOWED			17
+#define SPT_NUM_IP_IGN_ALLOWED			17
 
 #define SPT_PMC_LTR_CUR_PLT			0x350
 #define SPT_PMC_LTR_CUR_ASLT			0x354
@@ -146,6 +146,7 @@ enum ppfear_regs {
 #define CNP_PMC_MMIO_REG_LEN			0x2000
 #define CNP_PPFEAR_NUM_ENTRIES			8
 #define CNP_PMC_READ_DISABLE_BIT		22
+#define CNP_NUM_IP_IGN_ALLOWED			19
 #define CNP_PMC_LTR_CUR_PLT			0x1B50
 #define CNP_PMC_LTR_CUR_ASLT			0x1B54
 #define CNP_PMC_LTR_SPA				0x1B60
@@ -208,6 +209,7 @@ struct pmc_reg_map {
 	const u32 pm_cfg_offset;
 	const int pm_read_disable_bit;
 	const u32 slps0_dbg_offset;
+	const u32 ltr_ignore_max;
 };
 
 /**

commit 2eb150558bb79ee01c39b64c2868216c0be2904f
Author: Rajneesh Bhardwaj <rajneesh.bhardwaj@linux.intel.com>
Date:   Fri Nov 9 00:32:42 2018 +0530

    platform/x86: intel_pmc_core: Show Latency Tolerance info
    
    This adds support to show the Latency Tolerance Reporting for the IPs on
    the PCH as reported by the PMC. The format shown here is raw LTR data
    payload that can further be decoded as per the PCI specification.
    
    This also fixes some minor alignment issues in the header file by
    removing spaces and converting to tabs at some places.
    
    Signed-off-by: Rajneesh Bhardwaj <rajneesh.bhardwaj@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index be045348ad86..fcb13ca1f2bd 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -37,6 +37,25 @@
 #define NUM_RETRIES				100
 #define NUM_IP_IGN_ALLOWED			17
 
+#define SPT_PMC_LTR_CUR_PLT			0x350
+#define SPT_PMC_LTR_CUR_ASLT			0x354
+#define SPT_PMC_LTR_SPA				0x360
+#define SPT_PMC_LTR_SPB				0x364
+#define SPT_PMC_LTR_SATA			0x368
+#define SPT_PMC_LTR_GBE				0x36C
+#define SPT_PMC_LTR_XHCI			0x370
+#define SPT_PMC_LTR_ME				0x378
+#define SPT_PMC_LTR_EVA				0x37C
+#define SPT_PMC_LTR_SPC				0x380
+#define SPT_PMC_LTR_AZ				0x384
+#define SPT_PMC_LTR_LPSS			0x38C
+#define SPT_PMC_LTR_CAM				0x390
+#define SPT_PMC_LTR_SPD				0x394
+#define SPT_PMC_LTR_SPE				0x398
+#define SPT_PMC_LTR_ESPI			0x39C
+#define SPT_PMC_LTR_SCC				0x3A0
+#define SPT_PMC_LTR_ISH				0x3A4
+
 /* Sunrise Point: PGD PFET Enable Ack Status Registers */
 enum ppfear_regs {
 	SPT_PMC_XRAM_PPFEAR0A = 0x590,
@@ -115,18 +134,40 @@ enum ppfear_regs {
 #define SPT_PMC_BIT_MPHY_CMN_LANE3		BIT(3)
 
 /* Cannonlake Power Management Controller register offsets */
-#define CNP_PMC_SLP_S0_RES_COUNTER_OFFSET      0x193C
-#define CNP_PMC_LTR_IGNORE_OFFSET              0x1B0C
-#define CNP_PMC_PM_CFG_OFFSET                  0x1818
 #define CNP_PMC_SLPS0_DBG_OFFSET		0x10B4
+#define CNP_PMC_PM_CFG_OFFSET			0x1818
+#define CNP_PMC_SLP_S0_RES_COUNTER_OFFSET	0x193C
+#define CNP_PMC_LTR_IGNORE_OFFSET		0x1B0C
 /* Cannonlake: PGD PFET Enable Ack Status Register(s) start */
-#define CNP_PMC_HOST_PPFEAR0A                  0x1D90
+#define CNP_PMC_HOST_PPFEAR0A			0x1D90
 
-#define CNP_PMC_MMIO_REG_LEN                   0x2000
-#define CNP_PPFEAR_NUM_ENTRIES                 8
-#define CNP_PMC_READ_DISABLE_BIT               22
 #define CNP_PMC_LATCH_SLPS0_EVENTS		BIT(31)
 
+#define CNP_PMC_MMIO_REG_LEN			0x2000
+#define CNP_PPFEAR_NUM_ENTRIES			8
+#define CNP_PMC_READ_DISABLE_BIT		22
+#define CNP_PMC_LTR_CUR_PLT			0x1B50
+#define CNP_PMC_LTR_CUR_ASLT			0x1B54
+#define CNP_PMC_LTR_SPA				0x1B60
+#define CNP_PMC_LTR_SPB				0x1B64
+#define CNP_PMC_LTR_SATA			0x1B68
+#define CNP_PMC_LTR_GBE				0x1B6C
+#define CNP_PMC_LTR_XHCI			0x1B70
+#define CNP_PMC_LTR_ME				0x1B78
+#define CNP_PMC_LTR_EVA				0x1B7C
+#define CNP_PMC_LTR_SPC				0x1B80
+#define CNP_PMC_LTR_AZ				0x1B84
+#define CNP_PMC_LTR_LPSS			0x1B8C
+#define CNP_PMC_LTR_CAM				0x1B90
+#define CNP_PMC_LTR_SPD				0x1B94
+#define CNP_PMC_LTR_SPE				0x1B98
+#define CNP_PMC_LTR_ESPI			0x1B9C
+#define CNP_PMC_LTR_SCC				0x1BA0
+#define CNP_PMC_LTR_ISH				0x1BA4
+#define CNP_PMC_LTR_CNV				0x1BF0
+#define CNP_PMC_LTR_EMMC			0x1BF4
+#define CNP_PMC_LTR_UFSX2			0x1BF8
+
 struct pmc_bit_map {
 	const char *name;
 	u32 bit_mask;
@@ -139,6 +180,7 @@ struct pmc_bit_map {
  * @mphy_sts:		Maps name of MPHY lane to MPHY status lane status bit
  * @pll_sts:		Maps name of PLL to corresponding bit status
  * @slps0_dbg_maps:	Array of SLP_S0_DBG* registers containing debug info
+ * @ltr_show_sts:	Maps PCH IP Names to their MMIO register offsets
  * @slp_s0_offset:	PWRMBASE offset to read SLP_S0 residency
  * @ltr_ignore_offset:	PWRMBASE offset to read/write LTR ignore bit
  * @regmap_length:	Length of memory to map from PWRMBASE address to access
@@ -157,6 +199,7 @@ struct pmc_reg_map {
 	const struct pmc_bit_map *mphy_sts;
 	const struct pmc_bit_map *pll_sts;
 	const struct pmc_bit_map **slps0_dbg_maps;
+	const struct pmc_bit_map *ltr_show_sts;
 	const u32 slp_s0_offset;
 	const u32 ltr_ignore_offset;
 	const int regmap_length;

commit ad51f287ff593efb559f23e655312f3b6694fd90
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Sep 26 18:27:40 2018 +0300

    platform/x86: intel_pmc: Convert to use SPDX identifier
    
    Reduce size of duplicated comments by switching to use SPDX identifier.
    
    No functional change.
    
    While here, correct MODULE_LICENSE() string to be aligned with license text.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index 93a7e99e1f8b..be045348ad86 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Intel Core SoC Power Management Controller Header File
  *
@@ -6,16 +7,6 @@
  *
  * Authors: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
  *          Vishwanath Somayaji <vishwanath.somayaji@intel.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
  */
 
 #ifndef PMC_CORE_H

commit 4cf2afd6ef0d5e43e92d46401e7c1d3a9fac915b
Author: Box, David E <david.e.box@intel.com>
Date:   Fri Jun 8 17:02:37 2018 -0700

    platform/x86: intel_pmc_core: Add CNP SLPS0 debug registers
    
    Adds debugfs access to registers in the Cannon Point PCH PMC that are
    useful for debugging #SLP_S0 signal assertion and other low power relate
    activities. Device pm states are latched in these registers whenever the
    package enters C10 and can be read from slp_s0_debug_status. The pm
    states may also be latched by writing 1 to slp_s0_dbg_latch which will
    immediately capture the current state on the next read of
    slp_s0_debug_status.
    
    Signed-off-by: Box, David E <david.e.box@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index 5fa5f97870aa..93a7e99e1f8b 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -127,12 +127,14 @@ enum ppfear_regs {
 #define CNP_PMC_SLP_S0_RES_COUNTER_OFFSET      0x193C
 #define CNP_PMC_LTR_IGNORE_OFFSET              0x1B0C
 #define CNP_PMC_PM_CFG_OFFSET                  0x1818
+#define CNP_PMC_SLPS0_DBG_OFFSET		0x10B4
 /* Cannonlake: PGD PFET Enable Ack Status Register(s) start */
 #define CNP_PMC_HOST_PPFEAR0A                  0x1D90
 
 #define CNP_PMC_MMIO_REG_LEN                   0x2000
 #define CNP_PPFEAR_NUM_ENTRIES                 8
 #define CNP_PMC_READ_DISABLE_BIT               22
+#define CNP_PMC_LATCH_SLPS0_EVENTS		BIT(31)
 
 struct pmc_bit_map {
 	const char *name;
@@ -145,6 +147,7 @@ struct pmc_bit_map {
  * @pfear_sts:		Maps name of IP block to PPFEAR* bit
  * @mphy_sts:		Maps name of MPHY lane to MPHY status lane status bit
  * @pll_sts:		Maps name of PLL to corresponding bit status
+ * @slps0_dbg_maps:	Array of SLP_S0_DBG* registers containing debug info
  * @slp_s0_offset:	PWRMBASE offset to read SLP_S0 residency
  * @ltr_ignore_offset:	PWRMBASE offset to read/write LTR ignore bit
  * @regmap_length:	Length of memory to map from PWRMBASE address to access
@@ -153,6 +156,7 @@ struct pmc_bit_map {
  *			PPFEAR
  * @pm_cfg_offset:	PWRMBASE offset to PM_CFG register
  * @pm_read_disable_bit: Bit index to read PMC_READ_DISABLE
+ * @slps0_dbg_offset:	PWRMBASE offset to SLP_S0_DEBUG_REG*
  *
  * Each PCH has unique set of register offsets and bit indexes. This structure
  * captures them to have a common implementation.
@@ -161,6 +165,7 @@ struct pmc_reg_map {
 	const struct pmc_bit_map *pfear_sts;
 	const struct pmc_bit_map *mphy_sts;
 	const struct pmc_bit_map *pll_sts;
+	const struct pmc_bit_map **slps0_dbg_maps;
 	const u32 slp_s0_offset;
 	const u32 ltr_ignore_offset;
 	const int regmap_length;
@@ -168,6 +173,7 @@ struct pmc_reg_map {
 	const int ppfear_buckets;
 	const u32 pm_cfg_offset;
 	const int pm_read_disable_bit;
+	const u32 slps0_dbg_offset;
 };
 
 /**

commit 661405bd817b209ac9bd4812c63d90873a7f2993
Author: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
Date:   Fri Feb 2 19:13:37 2018 +0530

    platform/x86: intel_pmc_core: Special case for Coffeelake
    
    Intel CoffeeLake SoC uses CPU ID of KabyLake but has Cannonlake PCH, so in
    this case PMC register details from Cannonlake PCH must be used.
    
    In order to identify whether the given platform is Coffeelake, scan for the
    Sunrisepoint PMC PCI Id.
    
             KBL CPUID      SPT PCIID
    ------------------------------------
    KBL     |       Y       |       Y   |
    ------------------------------------
    CFL     |       Y       |       N   |
    ------------------------------------
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index 8b7731e6dea2..5fa5f97870aa 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -23,6 +23,8 @@
 
 #define PMC_BASE_ADDR_DEFAULT			0xFE000000
 
+/* Sunrise Point Power Management Controller PCI Device ID */
+#define SPT_PMC_PCI_DEVICE_ID			0x9d21
 #define SPT_PMC_BASE_ADDR_OFFSET		0x48
 #define SPT_PMC_SLP_S0_RES_COUNTER_OFFSET	0x13c
 #define SPT_PMC_PM_CFG_OFFSET			0x18

commit 291101f6a73566f5d1ab597784288c5bc85906fd
Author: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
Date:   Fri Feb 2 19:13:36 2018 +0530

    platform/x86: intel_pmc_core: Add CannonLake PCH support
    
    This adds support for Cannonlake PCH which is used by Cannonlake and
    Coffeelake SoCs.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index 9df4a60a179f..8b7731e6dea2 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -121,6 +121,17 @@ enum ppfear_regs {
 #define SPT_PMC_BIT_MPHY_CMN_LANE2		BIT(2)
 #define SPT_PMC_BIT_MPHY_CMN_LANE3		BIT(3)
 
+/* Cannonlake Power Management Controller register offsets */
+#define CNP_PMC_SLP_S0_RES_COUNTER_OFFSET      0x193C
+#define CNP_PMC_LTR_IGNORE_OFFSET              0x1B0C
+#define CNP_PMC_PM_CFG_OFFSET                  0x1818
+/* Cannonlake: PGD PFET Enable Ack Status Register(s) start */
+#define CNP_PMC_HOST_PPFEAR0A                  0x1D90
+
+#define CNP_PMC_MMIO_REG_LEN                   0x2000
+#define CNP_PPFEAR_NUM_ENTRIES                 8
+#define CNP_PMC_READ_DISABLE_BIT               22
+
 struct pmc_bit_map {
 	const char *name;
 	u32 bit_mask;

commit 21ae43570940f8393a80369f62a3880bd64daad8
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Fri Jan 19 14:28:21 2018 +0530

    platform/x86: intel_pmc_core: Substitute PCI with CPUID enumeration
    
    The Only use of PCI device enumeration here is to get the PMC base address
    which is a fixed value i.e. 0xFE000000. On some platforms this can be read
    through a non standard PCI BAR. But after Kabylake, PMC is not exposed as a
    PCI device anymore. There are other non standard methods like ACPI LPIT
    which can also be used for obtaining this value.
    
    For simplicity, this value can be hardcoded as it won't change.
    
    Since we don't have a PMC PCI device on any platform after Kabylake, this
    creates a foundation for future SoC support.
    
    Signed-off-by: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index e3be1d2b08cd..9df4a60a179f 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -21,8 +21,7 @@
 #ifndef PMC_CORE_H
 #define PMC_CORE_H
 
-/* Sunrise Point Power Management Controller PCI Device ID */
-#define SPT_PMC_PCI_DEVICE_ID			0x9d21
+#define PMC_BASE_ADDR_DEFAULT			0xFE000000
 
 #define SPT_PMC_BASE_ADDR_OFFSET		0x48
 #define SPT_PMC_SLP_S0_RES_COUNTER_OFFSET	0x13c

commit 7fc658923a599f3ad68dbccec59b6631c6352455
Author: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
Date:   Thu Jan 11 16:40:33 2018 +0530

    platform/x86: intel_pmc_core: Fix kernel doc for pmc_dev
    
    Fix invalid field information and add missing fields in kernel doc comments.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index c6169fe0edf2..e3be1d2b08cd 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -160,12 +160,14 @@ struct pmc_reg_map {
 
 /**
  * struct pmc_dev - pmc device structure
- * @base_addr:		comtains pmc base address
+ * @base_addr:		contains pmc base address
  * @regbase:		pointer to io-remapped memory location
- * @dbgfs_dir:		path to debug fs interface
- * @feature_available:	flag to indicate whether
- *			the feature is available
- *			on a particular platform or not.
+ * @map:		pointer to pmc_reg_map struct that contains platform
+ *			specific attributes
+ * @dbgfs_dir:		path to debugfs interface
+ * @pmc_xram_read_bit:	flag to indicate whether PMC XRAM shadow registers
+ *			used to read MPHY PG and PLL status are available
+ * @mutex_lock:		mutex to complete one transcation
  *
  * pmc_dev contains info about power management controller device.
  */

commit 8c9180dd2c2a5f1356121cd87b373d9881b41c65
Author: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
Date:   Thu Jan 11 16:40:32 2018 +0530

    platform/x86: intel_pmc_core: Remove unused variable
    
    base_address field is redundant and unused in the driver so get rid of it.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index ecff50356c71..c6169fe0edf2 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -135,7 +135,6 @@ struct pmc_bit_map {
  * @pll_sts:		Maps name of PLL to corresponding bit status
  * @slp_s0_offset:	PWRMBASE offset to read SLP_S0 residency
  * @ltr_ignore_offset:	PWRMBASE offset to read/write LTR ignore bit
- * @base_address:	Base address of PWRMBASE defined in BIOS writer guide
  * @regmap_length:	Length of memory to map from PWRMBASE address to access
  * @ppfear0_offset:	PWRMBASE offset to to read PPFEAR*
  * @ppfear_buckets:	Number of 8 bits blocks to read all IP blocks from
@@ -152,7 +151,6 @@ struct pmc_reg_map {
 	const struct pmc_bit_map *pll_sts;
 	const u32 slp_s0_offset;
 	const u32 ltr_ignore_offset;
-	const u32 base_address;
 	const int regmap_length;
 	const u32 ppfear0_offset;
 	const int ppfear_buckets;

commit 12d614a0dcaee9668c641fcaa9f524da861a765e
Author: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
Date:   Thu Jan 11 16:40:31 2018 +0530

    platform/x86: intel_pmc_core: Remove unused EXPORTED API
    
    Though ChromeOs uses the exported API as part of their S0ix failsafe
    mechanism, there is no active consumer of this API in upstream kernel.
    
    We can revisit this when ChromeOs kernel team is able to get their S0ix
    failsafe framework in mainline.
    
    Cc: Derek Basehore <dbasehore@chromium.org>
    Cc: Rajat Jain <rajatja@google.com>
    Link: https://patchwork.kernel.org/patch/9831229/
    
    Suggested-by: Andriy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index 3d225a9cc09f..ecff50356c71 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -178,7 +178,6 @@ struct pmc_dev {
 #if IS_ENABLED(CONFIG_DEBUG_FS)
 	struct dentry *dbgfs_dir;
 #endif /* CONFIG_DEBUG_FS */
-	bool has_slp_s0_res;
 	int pmc_xram_read_bit;
 	struct mutex lock; /* generic mutex lock for PMC Core */
 };

commit c977b98bbef5898ed3d30b08ea67622e9e82082a
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Sat Aug 12 09:50:09 2017 -0700

    platform/x86: intel_pmc_core: Make the driver PCH family agnostic
    
    Although this driver did pretty good job in abstracting PCH specific
    interfaces, but still there are some loose ends. For example
    SLP_S0 counter (for reading SLP_S0 residency), PM config offset (for
    checking permissions to read XRAM) and PPFEAR offset (for reading IP
    status) is still hardcoded for a specific family of PCH.
    
    This change extended the struct pmc_reg_map to allow per family
    configuration of offsets and bits.
    
    No functional change is expected with this change. This change allows
    seamless additions to new PCH and create a baseline for other platform
    specific extensions.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index 5a48e7728479..3d225a9cc09f 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -38,7 +38,8 @@
 #define SPT_PMC_SLP_S0_RES_COUNTER_STEP		0x64
 #define PMC_BASE_ADDR_MASK			~(SPT_PMC_MMIO_REG_LEN - 1)
 #define MTPMC_MASK				0xffff0000
-#define NUM_ENTRIES				5
+#define PPFEAR_MAX_NUM_ENTRIES			5
+#define SPT_PPFEAR_NUM_ENTRIES			5
 #define SPT_PMC_READ_DISABLE_BIT		0x16
 #define SPT_PMC_MSG_FULL_STS_BIT		0x18
 #define NUM_RETRIES				100
@@ -126,10 +127,37 @@ struct pmc_bit_map {
 	u32 bit_mask;
 };
 
+/**
+ * struct pmc_reg_map - Structure used to define parameter unique to a
+			PCH family
+ * @pfear_sts:		Maps name of IP block to PPFEAR* bit
+ * @mphy_sts:		Maps name of MPHY lane to MPHY status lane status bit
+ * @pll_sts:		Maps name of PLL to corresponding bit status
+ * @slp_s0_offset:	PWRMBASE offset to read SLP_S0 residency
+ * @ltr_ignore_offset:	PWRMBASE offset to read/write LTR ignore bit
+ * @base_address:	Base address of PWRMBASE defined in BIOS writer guide
+ * @regmap_length:	Length of memory to map from PWRMBASE address to access
+ * @ppfear0_offset:	PWRMBASE offset to to read PPFEAR*
+ * @ppfear_buckets:	Number of 8 bits blocks to read all IP blocks from
+ *			PPFEAR
+ * @pm_cfg_offset:	PWRMBASE offset to PM_CFG register
+ * @pm_read_disable_bit: Bit index to read PMC_READ_DISABLE
+ *
+ * Each PCH has unique set of register offsets and bit indexes. This structure
+ * captures them to have a common implementation.
+ */
 struct pmc_reg_map {
 	const struct pmc_bit_map *pfear_sts;
 	const struct pmc_bit_map *mphy_sts;
 	const struct pmc_bit_map *pll_sts;
+	const u32 slp_s0_offset;
+	const u32 ltr_ignore_offset;
+	const u32 base_address;
+	const int regmap_length;
+	const u32 ppfear0_offset;
+	const int ppfear_buckets;
+	const u32 pm_cfg_offset;
+	const int pm_read_disable_bit;
 };
 
 /**

commit 9c2ee19987ef02fe3dbe507d81ff5c7dd5bb4f21
Author: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
Date:   Fri Oct 7 16:01:16 2016 +0530

    platform/x86: intel_pmc_core: Add LTR IGNORE debug feature
    
    SPT LTR_IGN register provides a means to make the PMC ignore the LTR values
    reported by the individual PCH devices.
    
    echo <IP Offset> > /sys/kernel/debug/pmc_core/ltr_ignore.
    
    When a particular IP Offset bit is set the PMC will ignore the LTR value
    reported by the corresponding IP when the PMC performs the latency
    coalescing.
    
    IP Offset       IP Name
    0               SPA
    1               SPB
    2               SATA
    3               GBE
    4               XHCI
    5               RSVD
    6               ME
    7               EVA
    8               SPC
    9               Azalia/ADSP
    10              RSVD
    11              LPSS
    12              SPD
    13              SPE
    14              Camera
    15              ESPI
    16              SCC
    17              ISH
    
    Signed-off-by: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
    [dvhart: pmc_core_ltr_ignore_write local declaration order cleanup]
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index 07161fb33bb6..5a48e7728479 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -30,6 +30,7 @@
 #define SPT_PMC_PM_STS_OFFSET			0x1c
 #define SPT_PMC_MTPMC_OFFSET			0x20
 #define SPT_PMC_MFPMC_OFFSET			0x38
+#define SPT_PMC_LTR_IGNORE_OFFSET		0x30C
 #define SPT_PMC_MPHY_CORE_STS_0			0x1143
 #define SPT_PMC_MPHY_CORE_STS_1			0x1142
 #define SPT_PMC_MPHY_COM_STS_0			0x1155
@@ -41,6 +42,7 @@
 #define SPT_PMC_READ_DISABLE_BIT		0x16
 #define SPT_PMC_MSG_FULL_STS_BIT		0x18
 #define NUM_RETRIES				100
+#define NUM_IP_IGN_ALLOWED			17
 
 /* Sunrise Point: PGD PFET Enable Ack Status Registers */
 enum ppfear_regs {

commit fe748227570107abaa4767c39be3eff934bdaf5c
Author: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
Date:   Fri Oct 7 16:01:15 2016 +0530

    platform/x86: intel_pmc_core: Add MPHY PLL clock gating status
    
    ModPhy Common lanes can provide the clock gating status for the important
    system PLLs such as Gen2 USB3PCIE2 PLL, DMIPCIE3 PLL, SATA PLL and MIPI
    PLL.
    
    On SPT, in addition to the crystal oscillator clock, the 100Mhz Gen2
    USB3PCI2 PLL clock is used as the PLL reference clock and Gen2 PLL idling
    is a necessary condition for the platform to go into low power states like
    PC10 and S0ix.
    
    Signed-off-by: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index 62fe5d15a9b2..07161fb33bb6 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -32,6 +32,7 @@
 #define SPT_PMC_MFPMC_OFFSET			0x38
 #define SPT_PMC_MPHY_CORE_STS_0			0x1143
 #define SPT_PMC_MPHY_CORE_STS_1			0x1142
+#define SPT_PMC_MPHY_COM_STS_0			0x1155
 #define SPT_PMC_MMIO_REG_LEN			0x1000
 #define SPT_PMC_SLP_S0_RES_COUNTER_STEP		0x64
 #define PMC_BASE_ADDR_MASK			~(SPT_PMC_MMIO_REG_LEN - 1)
@@ -113,6 +114,11 @@ enum ppfear_regs {
 #define SPT_PMC_BIT_MPHY_LANE14			BIT(6)
 #define SPT_PMC_BIT_MPHY_LANE15			BIT(7)
 
+#define SPT_PMC_BIT_MPHY_CMN_LANE0		BIT(0)
+#define SPT_PMC_BIT_MPHY_CMN_LANE1		BIT(1)
+#define SPT_PMC_BIT_MPHY_CMN_LANE2		BIT(2)
+#define SPT_PMC_BIT_MPHY_CMN_LANE3		BIT(3)
+
 struct pmc_bit_map {
 	const char *name;
 	u32 bit_mask;
@@ -121,6 +127,7 @@ struct pmc_bit_map {
 struct pmc_reg_map {
 	const struct pmc_bit_map *pfear_sts;
 	const struct pmc_bit_map *mphy_sts;
+	const struct pmc_bit_map *pll_sts;
 };
 
 /**

commit 173943b3dae570d705e3f5237110a64a28c0bf74
Author: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
Date:   Fri Oct 7 16:01:14 2016 +0530

    platform/x86: intel_pmc_core: ModPhy core lanes pg status
    
    The PCH implements a number of High Speed I/O (HSIO) lanes that are split
    between PCIe*, USB 3.0, SATA, GbE, USB OTG and SSIC. This patch shows the
    current power gating status of the available ModPhy Core lanes. This is
    done by sending a message to the PMC (MTPMC) that contains the XRAM
    register offset for the MPHY_CORE_STS_0 and MPHY_CORE_STS_1 and then by
    reading the response sent by the PMC (MFPMC).
    
    While enabling low power modes we often encounter situations when the
    ModPhy lanes are not power gated and it becomes hard to debug which lane is
    active and which is not in the absence of an external hardware debugger
    (JTAG/ITP). This patch eliminates the dependency on an external hardware
    debugger for reading the ModPhy Lanes power gating status.
    
    This patch requires PMC_READ_DISABLE setting to be disabled in the platform
    bios.
    
    cat /sys/kernel/debug/pmc_core/mphy_lanes_power_gating_status
    
    Signed-off-by: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index d034cd309172..62fe5d15a9b2 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -26,10 +26,20 @@
 
 #define SPT_PMC_BASE_ADDR_OFFSET		0x48
 #define SPT_PMC_SLP_S0_RES_COUNTER_OFFSET	0x13c
+#define SPT_PMC_PM_CFG_OFFSET			0x18
+#define SPT_PMC_PM_STS_OFFSET			0x1c
+#define SPT_PMC_MTPMC_OFFSET			0x20
+#define SPT_PMC_MFPMC_OFFSET			0x38
+#define SPT_PMC_MPHY_CORE_STS_0			0x1143
+#define SPT_PMC_MPHY_CORE_STS_1			0x1142
 #define SPT_PMC_MMIO_REG_LEN			0x1000
 #define SPT_PMC_SLP_S0_RES_COUNTER_STEP		0x64
 #define PMC_BASE_ADDR_MASK			~(SPT_PMC_MMIO_REG_LEN - 1)
+#define MTPMC_MASK				0xffff0000
 #define NUM_ENTRIES				5
+#define SPT_PMC_READ_DISABLE_BIT		0x16
+#define SPT_PMC_MSG_FULL_STS_BIT		0x18
+#define NUM_RETRIES				100
 
 /* Sunrise Point: PGD PFET Enable Ack Status Registers */
 enum ppfear_regs {
@@ -85,6 +95,24 @@ enum ppfear_regs {
 #define SPT_PMC_BIT_CSME_RTC			BIT(6)
 #define SPT_PMC_BIT_CSME_PSF			BIT(7)
 
+#define SPT_PMC_BIT_MPHY_LANE0			BIT(0)
+#define SPT_PMC_BIT_MPHY_LANE1			BIT(1)
+#define SPT_PMC_BIT_MPHY_LANE2			BIT(2)
+#define SPT_PMC_BIT_MPHY_LANE3			BIT(3)
+#define SPT_PMC_BIT_MPHY_LANE4			BIT(4)
+#define SPT_PMC_BIT_MPHY_LANE5			BIT(5)
+#define SPT_PMC_BIT_MPHY_LANE6			BIT(6)
+#define SPT_PMC_BIT_MPHY_LANE7			BIT(7)
+
+#define SPT_PMC_BIT_MPHY_LANE8			BIT(0)
+#define SPT_PMC_BIT_MPHY_LANE9			BIT(1)
+#define SPT_PMC_BIT_MPHY_LANE10			BIT(2)
+#define SPT_PMC_BIT_MPHY_LANE11			BIT(3)
+#define SPT_PMC_BIT_MPHY_LANE12			BIT(4)
+#define SPT_PMC_BIT_MPHY_LANE13			BIT(5)
+#define SPT_PMC_BIT_MPHY_LANE14			BIT(6)
+#define SPT_PMC_BIT_MPHY_LANE15			BIT(7)
+
 struct pmc_bit_map {
 	const char *name;
 	u32 bit_mask;
@@ -92,6 +120,7 @@ struct pmc_bit_map {
 
 struct pmc_reg_map {
 	const struct pmc_bit_map *pfear_sts;
+	const struct pmc_bit_map *mphy_sts;
 };
 
 /**
@@ -113,6 +142,8 @@ struct pmc_dev {
 	struct dentry *dbgfs_dir;
 #endif /* CONFIG_DEBUG_FS */
 	bool has_slp_s0_res;
+	int pmc_xram_read_bit;
+	struct mutex lock; /* generic mutex lock for PMC Core */
 };
 
 #endif /* PMC_CORE_H */

commit 0bdfaf429d1da662742708153bf8cc945bf4904b
Author: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
Date:   Fri Oct 7 16:01:13 2016 +0530

    platform/x86: intel_pmc_core: Add PCH IP Power Gating Status
    
    This patch adds the support for reading the power gating status of various
    devices present on Sunrise Point PCH. This is intended to be used for
    debugging purpose while tuning the platform for power optimizations and
    also to understand which devices (on PCH) are blocking the system to enter
    a low power state.
    
    Power Management Controller on Sunrise Point PCH provides access to "PGD
    PFET Enable Ack Status Registers (ppfear)". This patch reads and decodes
    this register and dumps the output in formatted manner showing various
    devices present on the PCH and their "Power Gating" status.
    
    Further documentation can be found in Intel 7th Gen Core family mobile u/y
    processor io datasheet volume 2.
    
    Sample output (stripped and not in order):
    
    cat /sys/kernel/debug/pmc_core/pch_ip_power_gating_status
    PMC                             State: Not Power gated
    OPI-DMI                         State: Not Power gated
    XHCI                            State: Power gated
    LPSS                            State: Power gated
    CSME_PSF                        State: Not power gated
    
    Signed-off-by: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index cde31ec02266..d034cd309172 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -29,6 +29,70 @@
 #define SPT_PMC_MMIO_REG_LEN			0x1000
 #define SPT_PMC_SLP_S0_RES_COUNTER_STEP		0x64
 #define PMC_BASE_ADDR_MASK			~(SPT_PMC_MMIO_REG_LEN - 1)
+#define NUM_ENTRIES				5
+
+/* Sunrise Point: PGD PFET Enable Ack Status Registers */
+enum ppfear_regs {
+	SPT_PMC_XRAM_PPFEAR0A = 0x590,
+	SPT_PMC_XRAM_PPFEAR0B,
+	SPT_PMC_XRAM_PPFEAR0C,
+	SPT_PMC_XRAM_PPFEAR0D,
+	SPT_PMC_XRAM_PPFEAR1A,
+};
+
+#define SPT_PMC_BIT_PMC				BIT(0)
+#define SPT_PMC_BIT_OPI				BIT(1)
+#define SPT_PMC_BIT_SPI				BIT(2)
+#define SPT_PMC_BIT_XHCI			BIT(3)
+#define SPT_PMC_BIT_SPA				BIT(4)
+#define SPT_PMC_BIT_SPB				BIT(5)
+#define SPT_PMC_BIT_SPC				BIT(6)
+#define SPT_PMC_BIT_GBE				BIT(7)
+
+#define SPT_PMC_BIT_SATA			BIT(0)
+#define SPT_PMC_BIT_HDA_PGD0			BIT(1)
+#define SPT_PMC_BIT_HDA_PGD1			BIT(2)
+#define SPT_PMC_BIT_HDA_PGD2			BIT(3)
+#define SPT_PMC_BIT_HDA_PGD3			BIT(4)
+#define SPT_PMC_BIT_RSVD_0B			BIT(5)
+#define SPT_PMC_BIT_LPSS			BIT(6)
+#define SPT_PMC_BIT_LPC				BIT(7)
+
+#define SPT_PMC_BIT_SMB				BIT(0)
+#define SPT_PMC_BIT_ISH				BIT(1)
+#define SPT_PMC_BIT_P2SB			BIT(2)
+#define SPT_PMC_BIT_DFX				BIT(3)
+#define SPT_PMC_BIT_SCC				BIT(4)
+#define SPT_PMC_BIT_RSVD_0C			BIT(5)
+#define SPT_PMC_BIT_FUSE			BIT(6)
+#define SPT_PMC_BIT_CAMREA			BIT(7)
+
+#define SPT_PMC_BIT_RSVD_0D			BIT(0)
+#define SPT_PMC_BIT_USB3_OTG			BIT(1)
+#define SPT_PMC_BIT_EXI				BIT(2)
+#define SPT_PMC_BIT_CSE				BIT(3)
+#define SPT_PMC_BIT_CSME_KVM			BIT(4)
+#define SPT_PMC_BIT_CSME_PMT			BIT(5)
+#define SPT_PMC_BIT_CSME_CLINK			BIT(6)
+#define SPT_PMC_BIT_CSME_PTIO			BIT(7)
+
+#define SPT_PMC_BIT_CSME_USBR			BIT(0)
+#define SPT_PMC_BIT_CSME_SUSRAM			BIT(1)
+#define SPT_PMC_BIT_CSME_SMT			BIT(2)
+#define SPT_PMC_BIT_RSVD_1A			BIT(3)
+#define SPT_PMC_BIT_CSME_SMS2			BIT(4)
+#define SPT_PMC_BIT_CSME_SMS1			BIT(5)
+#define SPT_PMC_BIT_CSME_RTC			BIT(6)
+#define SPT_PMC_BIT_CSME_PSF			BIT(7)
+
+struct pmc_bit_map {
+	const char *name;
+	u32 bit_mask;
+};
+
+struct pmc_reg_map {
+	const struct pmc_bit_map *pfear_sts;
+};
 
 /**
  * struct pmc_dev - pmc device structure
@@ -44,7 +108,10 @@
 struct pmc_dev {
 	u32 base_addr;
 	void __iomem *regbase;
+	const struct pmc_reg_map *map;
+#if IS_ENABLED(CONFIG_DEBUG_FS)
 	struct dentry *dbgfs_dir;
+#endif /* CONFIG_DEBUG_FS */
 	bool has_slp_s0_res;
 };
 

commit 8434709ba71473f75572245c247d3c1e92509cf3
Author: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
Date:   Fri Oct 7 16:01:12 2016 +0530

    platform/x86: intel_pmc_core: Fix PWRMBASE mask and mmio reg len
    
    On Sunrise Point PCH, the Power Management Controller provides 4K bytes of
    memory space for various power management and debug registers. This fix is
    needed to access power management & debug registers that are mapped at a
    higher offset.
    
    Also, this provides a fix for correctly masking the PWRMBASE as the initial
    bits (0-11) are reserved.
    
    Signed-off-by: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index e3f671f4d122..cde31ec02266 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -26,8 +26,9 @@
 
 #define SPT_PMC_BASE_ADDR_OFFSET		0x48
 #define SPT_PMC_SLP_S0_RES_COUNTER_OFFSET	0x13c
-#define SPT_PMC_MMIO_REG_LEN			0x100
+#define SPT_PMC_MMIO_REG_LEN			0x1000
 #define SPT_PMC_SLP_S0_RES_COUNTER_STEP		0x64
+#define PMC_BASE_ADDR_MASK			~(SPT_PMC_MMIO_REG_LEN - 1)
 
 /**
  * struct pmc_dev - pmc device structure

commit df2294fb64285d2d793cf50c682ac4bfddf56c4c
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Jul 4 15:39:48 2016 +0300

    intel_pmc_core: Convert to DEFINE_DEBUGFS_ATTRIBUTE
    
    Refactor the code to use the recently introduced
    DEFINE_DEBUGFS_ATTRIBUTE() macro to eliminate boilerplate code.
    Make the absence of DEBUG_FS a non-fatal error.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-and-tested-by: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
index a9dadaf787c1..e3f671f4d122 100644
--- a/drivers/platform/x86/intel_pmc_core.h
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -23,6 +23,7 @@
 
 /* Sunrise Point Power Management Controller PCI Device ID */
 #define SPT_PMC_PCI_DEVICE_ID			0x9d21
+
 #define SPT_PMC_BASE_ADDR_OFFSET		0x48
 #define SPT_PMC_SLP_S0_RES_COUNTER_OFFSET	0x13c
 #define SPT_PMC_MMIO_REG_LEN			0x100
@@ -42,9 +43,7 @@
 struct pmc_dev {
 	u32 base_addr;
 	void __iomem *regbase;
-#if IS_ENABLED(CONFIG_DEBUG_FS)
 	struct dentry *dbgfs_dir;
-#endif /* CONFIG_DEBUG_FS */
 	bool has_slp_s0_res;
 };
 

commit b740d2e9233cb33626d3b62210bcfc6a34baa839
Author: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
Date:   Thu May 26 14:41:19 2016 +0530

    platform/x86: Add PMC Driver for Intel Core SoC
    
    This patch adds the Power Management Controller driver as a PCI driver
    for Intel Core SoC architecture.
    
    This driver can utilize debugging capabilities and supported features
    as exposed by the Power Management Controller.
    
    Please refer to the below specification for more details on PMC features.
    http://www.intel.in/content/www/in/en/chipsets/100-series-chipset-datasheet-vol-2.html
    
    The current version of this driver exposes SLP_S0_RESIDENCY counter.
    This counter can be used for detecting fragile SLP_S0 signal related
    failures and take corrective actions when PCH SLP_S0 signal is not
    asserted after kernel freeze as part of suspend to idle flow
    (echo freeze > /sys/power/state).
    
    Intel Platform Controller Hub (PCH) asserts SLP_S0 signal when it
    detects favorable conditions to enter its low power mode. As a
    pre-requisite the SoC should be in deepest possible Package C-State
    and devices should be in low power mode. For example, on Skylake SoC
    the deepest Package C-State is Package C10 or PC10. Suspend to idle
    flow generally leads to PC10 state but PC10 state may not be sufficient
    for realizing the platform wide power potential which SLP_S0 signal
    assertion can provide.
    
    SLP_S0 signal is often connected to the Embedded Controller (EC) and the
    Power Management IC (PMIC) for other platform power management related
    optimizations.
    
    In general, SLP_S0 assertion == PC10 + PCH low power mode + ModPhy Lanes
    power gated + PLL Idle.
    
    As part of this driver, a mechanism to read the SLP_S0_RESIDENCY is exposed
    as an API and also debugfs features are added to indicate SLP_S0 signal
    assertion residency in microseconds.
    
    echo freeze > /sys/power/state
    wake the system
    cat /sys/kernel/debug/pmc_core/slp_s0_residency_usec
    
    Signed-off-by: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
    Signed-off-by: Vishwanath Somayaji <vishwanath.somayaji@intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/intel_pmc_core.h b/drivers/platform/x86/intel_pmc_core.h
new file mode 100644
index 000000000000..a9dadaf787c1
--- /dev/null
+++ b/drivers/platform/x86/intel_pmc_core.h
@@ -0,0 +1,51 @@
+/*
+ * Intel Core SoC Power Management Controller Header File
+ *
+ * Copyright (c) 2016, Intel Corporation.
+ * All Rights Reserved.
+ *
+ * Authors: Rajneesh Bhardwaj <rajneesh.bhardwaj@intel.com>
+ *          Vishwanath Somayaji <vishwanath.somayaji@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef PMC_CORE_H
+#define PMC_CORE_H
+
+/* Sunrise Point Power Management Controller PCI Device ID */
+#define SPT_PMC_PCI_DEVICE_ID			0x9d21
+#define SPT_PMC_BASE_ADDR_OFFSET		0x48
+#define SPT_PMC_SLP_S0_RES_COUNTER_OFFSET	0x13c
+#define SPT_PMC_MMIO_REG_LEN			0x100
+#define SPT_PMC_SLP_S0_RES_COUNTER_STEP		0x64
+
+/**
+ * struct pmc_dev - pmc device structure
+ * @base_addr:		comtains pmc base address
+ * @regbase:		pointer to io-remapped memory location
+ * @dbgfs_dir:		path to debug fs interface
+ * @feature_available:	flag to indicate whether
+ *			the feature is available
+ *			on a particular platform or not.
+ *
+ * pmc_dev contains info about power management controller device.
+ */
+struct pmc_dev {
+	u32 base_addr;
+	void __iomem *regbase;
+#if IS_ENABLED(CONFIG_DEBUG_FS)
+	struct dentry *dbgfs_dir;
+#endif /* CONFIG_DEBUG_FS */
+	bool has_slp_s0_res;
+};
+
+#endif /* PMC_CORE_H */
