commit 9a33e375d98ece5ea40c576eabd3257acb90c509
Author: Vasiliy Kupriakov <rublag-ns@yandex.ru>
Date:   Tue Jun 30 20:56:01 2020 +0300

    platform/x86: asus-wmi: allow BAT1 battery name
    
    The battery on my laptop ASUS TUF Gaming FX706II is named BAT1.
    This patch allows battery extension to load.
    
    Signed-off-by: Vasiliy Kupriakov <rublag-ns@yandex.ru>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 877aade19497..8f4acdc06b13 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -441,6 +441,7 @@ static int asus_wmi_battery_add(struct power_supply *battery)
 	 * battery is named BATT.
 	 */
 	if (strcmp(battery->desc->name, "BAT0") != 0 &&
+	    strcmp(battery->desc->name, "BAT1") != 0 &&
 	    strcmp(battery->desc->name, "BATT") != 0)
 		return -ENODEV;
 

commit 7b91f1565fbfbe5a162d91f8a1f6c5580c2fc1d0
Author: Chris Chiu <chiu@endlessm.com>
Date:   Fri May 22 15:44:24 2020 +0800

    platform/x86: asus_wmi: Reserve more space for struct bias_args
    
    On the ASUS laptop UX325JA/UX425JA, most of the media keys are not
    working due to the ASUS WMI driver fails to be loaded. The ACPI error
    as follows leads to the failure of asus_wmi_evaluate_method.
      ACPI BIOS Error (bug): AE_AML_BUFFER_LIMIT, Field [IIA3] at bit offset/length 96/32 exceeds size of target Buffer (96 bits) (20200326/dsopcode-203)
      No Local Variables are initialized for Method [WMNB]
      ACPI Error: Aborting method \_SB.ATKD.WMNB due to previous error (AE_AML_BUFFER_LIMIT) (20200326/psparse-531)
    
    The DSDT for the WMNB part shows that 5 DWORD required for local
    variables and the 3rd variable IIA3 hit the buffer limit.
    
    Method (WMNB, 3, Serialized)
    { ..
        CreateDWordField (Arg2, Zero, IIA0)
        CreateDWordField (Arg2, 0x04, IIA1)
        CreateDWordField (Arg2, 0x08, IIA2)
        CreateDWordField (Arg2, 0x0C, IIA3)
        CreateDWordField (Arg2, 0x10, IIA4)
        Local0 = (Arg1 & 0xFFFFFFFF)
        If ((Local0 == 0x54494E49))
      ..
    }
    
    The limitation is determined by the input acpi_buffer size passed
    to the wmi_evaluate_method. Since the struct bios_args is the data
    structure used as input buffer by default for all ASUS WMI calls,
    the size needs to be expanded to fix the problem.
    
    Signed-off-by: Chris Chiu <chiu@endlessm.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index a97aba2ba467..877aade19497 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -117,6 +117,8 @@ struct bios_args {
 	u32 arg0;
 	u32 arg1;
 	u32 arg2; /* At least TUF Gaming series uses 3 dword input buffer. */
+	u32 arg4;
+	u32 arg5;
 } __packed;
 
 /*

commit b0dbd97de1f1fd6b3c9a7bb8f7c795bba7e169d8
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun May 10 14:24:31 2020 +0200

    platform/x86: asus-wmi: Add support for SW_TABLET_MODE
    
    On Asus 2-in-1s with a detachable keyboard the Asus WMI interface
    reports if the tablet is attached to the keyboard or not.
    
    Report if the 2-in-1 is in tablet or clamshell mode to userspace
    by reporting SW_TABLET_MODE events to userspace.
    
    This has been tested on a T100TA, T100CHI, T100HA and T200TA.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 91d0c8be63a5..a97aba2ba467 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -57,6 +57,7 @@ MODULE_LICENSE("GPL");
 #define NOTIFY_BRNDOWN_MIN		0x20
 #define NOTIFY_BRNDOWN_MAX		0x2e
 #define NOTIFY_FNLOCK_TOGGLE		0x4e
+#define NOTIFY_KBD_DOCK_CHANGE		0x75
 #define NOTIFY_KBD_BRTUP		0xc4
 #define NOTIFY_KBD_BRTDWN		0xc5
 #define NOTIFY_KBD_BRTTOGGLE		0xc7
@@ -346,7 +347,7 @@ static bool asus_wmi_dev_is_present(struct asus_wmi *asus, u32 dev_id)
 
 static int asus_wmi_input_init(struct asus_wmi *asus)
 {
-	int err;
+	int err, result;
 
 	asus->inputdev = input_allocate_device();
 	if (!asus->inputdev)
@@ -362,6 +363,14 @@ static int asus_wmi_input_init(struct asus_wmi *asus)
 	if (err)
 		goto err_free_dev;
 
+	result = asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_KBD_DOCK);
+	if (result >= 0) {
+		input_set_capability(asus->inputdev, EV_SW, SW_TABLET_MODE);
+		input_report_switch(asus->inputdev, SW_TABLET_MODE, !result);
+	} else if (result != -ENODEV) {
+		pr_err("Error checking for keyboard-dock: %d\n", result);
+	}
+
 	err = input_register_device(asus->inputdev);
 	if (err)
 		goto err_free_dev;
@@ -2055,9 +2064,9 @@ static int asus_wmi_get_event_code(u32 value)
 
 static void asus_wmi_handle_event_code(int code, struct asus_wmi *asus)
 {
-	int orig_code;
 	unsigned int key_value = 1;
 	bool autorelease = 1;
+	int result, orig_code;
 
 	orig_code = code;
 
@@ -2102,6 +2111,17 @@ static void asus_wmi_handle_event_code(int code, struct asus_wmi *asus)
 		return;
 	}
 
+	if (code == NOTIFY_KBD_DOCK_CHANGE) {
+		result = asus_wmi_get_devstate_simple(asus,
+						      ASUS_WMI_DEVID_KBD_DOCK);
+		if (result >= 0) {
+			input_report_switch(asus->inputdev, SW_TABLET_MODE,
+					    !result);
+			input_sync(asus->inputdev);
+		}
+		return;
+	}
+
 	if (asus->fan_boost_mode_available && code == NOTIFY_KBD_FBM) {
 		fan_boost_mode_switch_next(asus);
 		return;

commit fed5003d805c5ea06e146ed8df2b319496765454
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun May 10 14:24:30 2020 +0200

    platform/x86: asus-wmi: Move asus_wmi_input_init and _exit lower in the file
    
    Move the asus_wmi_input_init() and asus_wmi_input_exit() functions to
    below the WMI helpers, so that further patches in this patch-set can use
    the WMI helpers inside asus_wmi_input_init() without needing a forward
    declaration.
    
    Note this commit makes no functional changes, the moved block of code
    is completely unchanged.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 7adb3da44a6a..91d0c8be63a5 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -222,45 +222,6 @@ struct asus_wmi {
 	struct asus_wmi_driver *driver;
 };
 
-/* Input **********************************************************************/
-
-static int asus_wmi_input_init(struct asus_wmi *asus)
-{
-	int err;
-
-	asus->inputdev = input_allocate_device();
-	if (!asus->inputdev)
-		return -ENOMEM;
-
-	asus->inputdev->name = asus->driver->input_name;
-	asus->inputdev->phys = asus->driver->input_phys;
-	asus->inputdev->id.bustype = BUS_HOST;
-	asus->inputdev->dev.parent = &asus->platform_device->dev;
-	set_bit(EV_REP, asus->inputdev->evbit);
-
-	err = sparse_keymap_setup(asus->inputdev, asus->driver->keymap, NULL);
-	if (err)
-		goto err_free_dev;
-
-	err = input_register_device(asus->inputdev);
-	if (err)
-		goto err_free_dev;
-
-	return 0;
-
-err_free_dev:
-	input_free_device(asus->inputdev);
-	return err;
-}
-
-static void asus_wmi_input_exit(struct asus_wmi *asus)
-{
-	if (asus->inputdev)
-		input_unregister_device(asus->inputdev);
-
-	asus->inputdev = NULL;
-}
-
 /* WMI ************************************************************************/
 
 static int asus_wmi_evaluate_method3(u32 method_id,
@@ -381,6 +342,45 @@ static bool asus_wmi_dev_is_present(struct asus_wmi *asus, u32 dev_id)
 	return status == 0 && (retval & ASUS_WMI_DSTS_PRESENCE_BIT);
 }
 
+/* Input **********************************************************************/
+
+static int asus_wmi_input_init(struct asus_wmi *asus)
+{
+	int err;
+
+	asus->inputdev = input_allocate_device();
+	if (!asus->inputdev)
+		return -ENOMEM;
+
+	asus->inputdev->name = asus->driver->input_name;
+	asus->inputdev->phys = asus->driver->input_phys;
+	asus->inputdev->id.bustype = BUS_HOST;
+	asus->inputdev->dev.parent = &asus->platform_device->dev;
+	set_bit(EV_REP, asus->inputdev->evbit);
+
+	err = sparse_keymap_setup(asus->inputdev, asus->driver->keymap, NULL);
+	if (err)
+		goto err_free_dev;
+
+	err = input_register_device(asus->inputdev);
+	if (err)
+		goto err_free_dev;
+
+	return 0;
+
+err_free_dev:
+	input_free_device(asus->inputdev);
+	return err;
+}
+
+static void asus_wmi_input_exit(struct asus_wmi *asus)
+{
+	if (asus->inputdev)
+		input_unregister_device(asus->inputdev);
+
+	asus->inputdev = NULL;
+}
+
 /* Battery ********************************************************************/
 
 /* The battery maximum charging percentage */

commit 6568d0c07efcc2e786d59c9258ec61f36f4ac483
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu May 7 23:04:55 2020 +0100

    platform/x86: asus_wmi: remove redundant initialization of variable status
    
    The variable status is being initialized with a value that is never read
    and it is being updated later with a new value. The initialization is
    redundant and can be removed.
    
    Addresses-Coverity: ("Unused value")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index e705ae66c083..7adb3da44a6a 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -309,7 +309,7 @@ static int asus_wmi_evaluate_method_agfn(const struct acpi_buffer args)
 	struct acpi_buffer input;
 	u64 phys_addr;
 	u32 retval;
-	u32 status = -1;
+	u32 status;
 
 	/*
 	 * Copy to dma capable address otherwise memory corruption occurs as

commit 2225dba20529fb71f0a7716b47b6123d521f103b
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu May 7 19:37:23 2020 +0300

    platform/x86: asus-wmi: Drop duplicate check for led_classdev_unregister()
    
    led_classdev_unregister() already has the very same check, so,
    drop a duplicate in the driver.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index bb7c529d7d16..e705ae66c083 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -675,14 +675,11 @@ static enum led_brightness lightbar_led_get(struct led_classdev *led_cdev)
 
 static void asus_wmi_led_exit(struct asus_wmi *asus)
 {
-	if (!IS_ERR_OR_NULL(asus->kbd_led.dev))
-		led_classdev_unregister(&asus->kbd_led);
-	if (!IS_ERR_OR_NULL(asus->tpd_led.dev))
-		led_classdev_unregister(&asus->tpd_led);
-	if (!IS_ERR_OR_NULL(asus->wlan_led.dev))
-		led_classdev_unregister(&asus->wlan_led);
-	if (!IS_ERR_OR_NULL(asus->lightbar_led.dev))
-		led_classdev_unregister(&asus->lightbar_led);
+	led_classdev_unregister(&asus->kbd_led);
+	led_classdev_unregister(&asus->tpd_led);
+	led_classdev_unregister(&asus->wlan_led);
+	led_classdev_unregister(&asus->lightbar_led);
+
 	if (asus->led_workqueue)
 		destroy_workqueue(asus->led_workqueue);
 }

commit edeee341fd6c1099de357c517af215bee2c6f766
Author: Leonid Maksymchuk <leonmaxx@gmail.com>
Date:   Wed Mar 4 13:38:11 2020 +0200

    platform/x86: asus_wmi: Fix return value of fan_boost_mode_store
    
    Function fan_boost_mode_store returns 0 if store is successful,
    this leads to infinite loop after any write to it's sysfs entry:
    
    # echo 0 >/sys/devices/platform/asus-nb-wmi/fan_boost_mode
    
    This command never ends, one CPU core is at 100% utilization.
    This patch fixes this by returning size of written data.
    
    Fixes: b096f626a682 ("platform/x86: asus-wmi: Switch fan boost mode")
    Signed-off-by: Leonid Maksymchuk <leonmaxx@gmail.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 01becbe2a9a8..bb7c529d7d16 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1722,7 +1722,7 @@ static ssize_t fan_boost_mode_store(struct device *dev,
 	asus->fan_boost_mode = new_mode;
 	fan_boost_mode_write(asus);
 
-	return result;
+	return count;
 }
 
 // Fan boost mode: 0 - normal, 1 - overboost, 2 - silent

commit 6b3586d45bba14f6912f37488090c37a3710e7b4
Author: Kristian Klausen <kristian@klausen.dk>
Date:   Tue Mar 3 19:02:15 2020 +0100

    platform/x86: asus-wmi: Support laptops where the first battery is named BATT
    
    The WMI method to set the charge threshold does not provide a
    way to specific a battery, so we assume it is the first/primary
    battery (by checking if the name is BAT0).
    On some newer ASUS laptops (Zenbook UM431DA) though, the
    primary/first battery isn't named BAT0 but BATT, so we need
    to support that case.
    
    Fixes: 7973353e92ee ("platform/x86: asus-wmi: Refactor charge threshold to use the battery hooking API")
    Cc: stable@vger.kernel.org
    Signed-off-by: Kristian Klausen <kristian@klausen.dk>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 612ef5526226..01becbe2a9a8 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -426,8 +426,11 @@ static int asus_wmi_battery_add(struct power_supply *battery)
 {
 	/* The WMI method does not provide a way to specific a battery, so we
 	 * just assume it is the first battery.
+	 * Note: On some newer ASUS laptops (Zenbook UM431DA), the primary/first
+	 * battery is named BATT.
 	 */
-	if (strcmp(battery->desc->name, "BAT0") != 0)
+	if (strcmp(battery->desc->name, "BAT0") != 0 &&
+	    strcmp(battery->desc->name, "BATT") != 0)
 		return -ENODEV;
 
 	if (device_create_file(&battery->dev,

commit f07b9fdf000e7fee2d8fa7143fd0b736a674cb5d
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Thu Jan 30 22:15:37 2020 -0800

    platform/x86: asus-wmi: switch to use <linux/units.h> helpers
    
    The asus-wmi driver doesn't implement the thermal device functionality
    directly, so including <linux/thermal.h> just for
    DECI_KELVIN_TO_CELSIUS() is a bit odd.
    
    This switches the asus-wmi driver to use deci_kelvin_to_millicelsius()
    in <linux/units.h>.
    
    The format string is changed from %d to %ld due to function returned
    type.
    
    Link: http://lkml.kernel.org/r/1576386975-7941-4-git-send-email-akinobu.mita@gmail.com
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Acked-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Cc: Sujith Thomas <sujith.thomas@intel.com>
    Cc: Darren Hart <dvhart@infradead.org>
    Cc: Andy Shevchenko <andy@infradead.org>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Amit Kucheria <amit.kucheria@verdurent.com>
    Cc: Jean Delvare <jdelvare@suse.com>
    Cc: Guenter Roeck <linux@roeck-us.net>
    Cc: Keith Busch <kbusch@kernel.org>
    Cc: Jens Axboe <axboe@fb.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Sagi Grimberg <sagi@grimberg.me>
    Cc: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
    Cc: Hartmut Knaack <knaack.h@gmx.de>
    Cc: Johannes Berg <johannes.berg@intel.com>
    Cc: Jonathan Cameron <jic23@kernel.org>
    Cc: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Cc: Kalle Valo <kvalo@codeaurora.org>
    Cc: Lars-Peter Clausen <lars@metafoo.de>
    Cc: Luca Coelho <luciano.coelho@intel.com>
    Cc: Peter Meerwald-Stadler <pmeerw@pmeerw.net>
    Cc: Stanislaw Gruszka <sgruszka@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 43bb15e05529..612ef5526226 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -33,9 +33,9 @@
 #include <linux/seq_file.h>
 #include <linux/platform_data/x86/asus-wmi.h>
 #include <linux/platform_device.h>
-#include <linux/thermal.h>
 #include <linux/acpi.h>
 #include <linux/dmi.h>
+#include <linux/units.h>
 
 #include <acpi/battery.h>
 #include <acpi/video.h>
@@ -1514,9 +1514,8 @@ static ssize_t asus_hwmon_temp1(struct device *dev,
 	if (err < 0)
 		return err;
 
-	value = DECI_KELVIN_TO_CELSIUS((value & 0xFFFF)) * 1000;
-
-	return sprintf(buf, "%d\n", value);
+	return sprintf(buf, "%ld\n",
+		       deci_kelvin_to_millicelsius(value & 0xFFFF));
 }
 
 /* Fan1 */

commit 26e66a0cf258d413bd64095b0fea6e34f9e46587
Author: Jian-Hong Pan <jian-hong@endlessm.com>
Date:   Mon Dec 30 16:30:45 2019 +0800

    platform/x86: asus-wmi: Fix keyboard brightness cannot be set to 0
    
    Some of ASUS laptops like UX431FL keyboard backlight cannot be set to
    brightness 0. According to ASUS' information, the brightness should be
    0x80 ~ 0x83. This patch fixes it by following the logic.
    
    Fixes: e9809c0b9670 ("asus-wmi: add keyboard backlight support")
    Signed-off-by: Jian-Hong Pan <jian-hong@endlessm.com>
    Reviewed-by: Daniel Drake <drake@endlessm.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 469f1a852719..43bb15e05529 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -520,13 +520,7 @@ static void kbd_led_update(struct asus_wmi *asus)
 {
 	int ctrl_param = 0;
 
-	/*
-	 * bits 0-2: level
-	 * bit 7: light on/off
-	 */
-	if (asus->kbd_led_wk > 0)
-		ctrl_param = 0x80 | (asus->kbd_led_wk & 0x7F);
-
+	ctrl_param = 0x80 | (asus->kbd_led_wk & 0x7F);
 	asus_wmi_set_devstate(ASUS_WMI_DEVID_KBD_BACKLIGHT, ctrl_param, NULL);
 }
 

commit a28215844d8db87aadb9bcce040e7897691ff6ba
Author: Leonid Maksymchuk <leonmaxx@gmail.com>
Date:   Sun Dec 15 16:27:24 2019 +0200

    platform/x86: asus_wmi: Set throttle thermal policy to default
    
    ASUS TUF FX705DY/FX505DY starts in silent mode and under heavy
    CPU load it overheats and drops CPU frequency to 399MHz and stays
    at it until reboot [1]. Set throttle thermal policy to default
    to avoid overheating and throttlig.
    
    [1] Link: https://bugzilla.kernel.org/show_bug.cgi?id=203733
    
    Signed-off-by: Leonid Maksymchuk <leonmaxx@gmail.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index f10ec9d745e5..469f1a852719 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1780,6 +1780,15 @@ static int throttle_thermal_policy_write(struct asus_wmi *asus)
 	return 0;
 }
 
+static int throttle_thermal_policy_set_default(struct asus_wmi *asus)
+{
+	if (!asus->throttle_thermal_policy_available)
+		return 0;
+
+	asus->throttle_thermal_policy_mode = ASUS_THROTTLE_THERMAL_POLICY_DEFAULT;
+	return throttle_thermal_policy_write(asus);
+}
+
 static int throttle_thermal_policy_switch_next(struct asus_wmi *asus)
 {
 	u8 new_mode = asus->throttle_thermal_policy_mode + 1;
@@ -2548,6 +2557,8 @@ static int asus_wmi_add(struct platform_device *pdev)
 	err = throttle_thermal_policy_check_present(asus);
 	if (err)
 		goto fail_throttle_thermal_policy;
+	else
+		throttle_thermal_policy_set_default(asus);
 
 	err = asus_wmi_sysfs_init(asus->platform_device);
 	if (err)

commit 2daa86e78c494d06d0aac231e4533f3dc50fa432
Author: Leonid Maksymchuk <leonmaxx@gmail.com>
Date:   Sun Dec 15 16:26:34 2019 +0200

    platform/x86: asus_wmi: Support throttle thermal policy
    
    Throttle thermal policy ACPI device is used to control CPU cooling and
    throttling. This patch adds sysfs entry for setting current mode and
    Fn+F5 hotkey that switches to next.
    
    Policy modes:
    * 0x00 - default
    * 0x01 - overboost
    * 0x02 - silent
    
    Signed-off-by: Leonid Maksymchuk <leonmaxx@gmail.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 821b08e01635..f10ec9d745e5 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -61,6 +61,7 @@ MODULE_LICENSE("GPL");
 #define NOTIFY_KBD_BRTDWN		0xc5
 #define NOTIFY_KBD_BRTTOGGLE		0xc7
 #define NOTIFY_KBD_FBM			0x99
+#define NOTIFY_KBD_TTP			0xae
 
 #define ASUS_WMI_FNLOCK_BIOS_DISABLED	BIT(0)
 
@@ -81,6 +82,10 @@ MODULE_LICENSE("GPL");
 #define ASUS_FAN_BOOST_MODE_SILENT_MASK		0x02
 #define ASUS_FAN_BOOST_MODES_MASK		0x03
 
+#define ASUS_THROTTLE_THERMAL_POLICY_DEFAULT	0
+#define ASUS_THROTTLE_THERMAL_POLICY_OVERBOOST	1
+#define ASUS_THROTTLE_THERMAL_POLICY_SILENT	2
+
 #define USB_INTEL_XUSB2PR		0xD0
 #define PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI	0x9c31
 
@@ -198,6 +203,9 @@ struct asus_wmi {
 	u8 fan_boost_mode_mask;
 	u8 fan_boost_mode;
 
+	bool throttle_thermal_policy_available;
+	u8 throttle_thermal_policy_mode;
+
 	// The RSOC controls the maximum charging percentage.
 	bool battery_rsoc_available;
 
@@ -1724,6 +1732,98 @@ static ssize_t fan_boost_mode_store(struct device *dev,
 // Fan boost mode: 0 - normal, 1 - overboost, 2 - silent
 static DEVICE_ATTR_RW(fan_boost_mode);
 
+/* Throttle thermal policy ****************************************************/
+
+static int throttle_thermal_policy_check_present(struct asus_wmi *asus)
+{
+	u32 result;
+	int err;
+
+	asus->throttle_thermal_policy_available = false;
+
+	err = asus_wmi_get_devstate(asus,
+				    ASUS_WMI_DEVID_THROTTLE_THERMAL_POLICY,
+				    &result);
+	if (err) {
+		if (err == -ENODEV)
+			return 0;
+		return err;
+	}
+
+	if (result & ASUS_WMI_DSTS_PRESENCE_BIT)
+		asus->throttle_thermal_policy_available = true;
+
+	return 0;
+}
+
+static int throttle_thermal_policy_write(struct asus_wmi *asus)
+{
+	int err;
+	u8 value;
+	u32 retval;
+
+	value = asus->throttle_thermal_policy_mode;
+
+	err = asus_wmi_set_devstate(ASUS_WMI_DEVID_THROTTLE_THERMAL_POLICY,
+				    value, &retval);
+	if (err) {
+		pr_warn("Failed to set throttle thermal policy: %d\n", err);
+		return err;
+	}
+
+	if (retval != 1) {
+		pr_warn("Failed to set throttle thermal policy (retval): 0x%x\n",
+			retval);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int throttle_thermal_policy_switch_next(struct asus_wmi *asus)
+{
+	u8 new_mode = asus->throttle_thermal_policy_mode + 1;
+
+	if (new_mode > ASUS_THROTTLE_THERMAL_POLICY_SILENT)
+		new_mode = ASUS_THROTTLE_THERMAL_POLICY_DEFAULT;
+
+	asus->throttle_thermal_policy_mode = new_mode;
+	return throttle_thermal_policy_write(asus);
+}
+
+static ssize_t throttle_thermal_policy_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct asus_wmi *asus = dev_get_drvdata(dev);
+	u8 mode = asus->throttle_thermal_policy_mode;
+
+	return scnprintf(buf, PAGE_SIZE, "%d\n", mode);
+}
+
+static ssize_t throttle_thermal_policy_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	int result;
+	u8 new_mode;
+	struct asus_wmi *asus = dev_get_drvdata(dev);
+
+	result = kstrtou8(buf, 10, &new_mode);
+	if (result < 0)
+		return result;
+
+	if (new_mode > ASUS_THROTTLE_THERMAL_POLICY_SILENT)
+		return -EINVAL;
+
+	asus->throttle_thermal_policy_mode = new_mode;
+	throttle_thermal_policy_write(asus);
+
+	return count;
+}
+
+// Throttle thermal policy: 0 - default, 1 - overboost, 2 - silent
+static DEVICE_ATTR_RW(throttle_thermal_policy);
+
 /* Backlight ******************************************************************/
 
 static int read_backlight_power(struct asus_wmi *asus)
@@ -2005,6 +2105,11 @@ static void asus_wmi_handle_event_code(int code, struct asus_wmi *asus)
 		return;
 	}
 
+	if (asus->throttle_thermal_policy_available && code == NOTIFY_KBD_TTP) {
+		throttle_thermal_policy_switch_next(asus);
+		return;
+	}
+
 	if (is_display_toggle(code) && asus->driver->quirks->no_display_toggle)
 		return;
 
@@ -2155,6 +2260,7 @@ static struct attribute *platform_attributes[] = {
 	&dev_attr_lid_resume.attr,
 	&dev_attr_als_enable.attr,
 	&dev_attr_fan_boost_mode.attr,
+	&dev_attr_throttle_thermal_policy.attr,
 	NULL
 };
 
@@ -2178,6 +2284,8 @@ static umode_t asus_sysfs_is_visible(struct kobject *kobj,
 		devid = ASUS_WMI_DEVID_ALS_ENABLE;
 	else if (attr == &dev_attr_fan_boost_mode.attr)
 		ok = asus->fan_boost_mode_available;
+	else if (attr == &dev_attr_throttle_thermal_policy.attr)
+		ok = asus->throttle_thermal_policy_available;
 
 	if (devid != -1)
 		ok = !(asus_wmi_get_devstate_simple(asus, devid) < 0);
@@ -2437,6 +2545,10 @@ static int asus_wmi_add(struct platform_device *pdev)
 	if (err)
 		goto fail_fan_boost_mode;
 
+	err = throttle_thermal_policy_check_present(asus);
+	if (err)
+		goto fail_throttle_thermal_policy;
+
 	err = asus_wmi_sysfs_init(asus->platform_device);
 	if (err)
 		goto fail_sysfs;
@@ -2521,6 +2633,7 @@ static int asus_wmi_add(struct platform_device *pdev)
 fail_input:
 	asus_wmi_sysfs_exit(asus->platform_device);
 fail_sysfs:
+fail_throttle_thermal_policy:
 fail_fan_boost_mode:
 fail_platform:
 	kfree(asus);

commit 7973353e92ee1e7ca3b2eb361a4b7cb66c92abee
Author: Kristian Klausen <kristian@klausen.dk>
Date:   Mon Sep 9 19:31:28 2019 +0200

    platform/x86: asus-wmi: Refactor charge threshold to use the battery hooking API
    
    At the same time use the official naming for the knobs.
    
    Tested on a Zenbook UX430UNR.
    
    Signed-off-by: Kristian Klausen <kristian@klausen.dk>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 92c149dc2e6e..821b08e01635 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -26,6 +26,7 @@
 #include <linux/rfkill.h>
 #include <linux/pci.h>
 #include <linux/pci_hotplug.h>
+#include <linux/power_supply.h>
 #include <linux/hwmon.h>
 #include <linux/hwmon-sysfs.h>
 #include <linux/debugfs.h>
@@ -35,6 +36,8 @@
 #include <linux/thermal.h>
 #include <linux/acpi.h>
 #include <linux/dmi.h>
+
+#include <acpi/battery.h>
 #include <acpi/video.h>
 
 #include "asus-wmi.h"
@@ -195,7 +198,8 @@ struct asus_wmi {
 	u8 fan_boost_mode_mask;
 	u8 fan_boost_mode;
 
-	int charge_threshold;
+	// The RSOC controls the maximum charging percentage.
+	bool battery_rsoc_available;
 
 	struct hotplug_slot hotplug_slot;
 	struct mutex hotplug_lock;
@@ -369,6 +373,97 @@ static bool asus_wmi_dev_is_present(struct asus_wmi *asus, u32 dev_id)
 	return status == 0 && (retval & ASUS_WMI_DSTS_PRESENCE_BIT);
 }
 
+/* Battery ********************************************************************/
+
+/* The battery maximum charging percentage */
+static int charge_end_threshold;
+
+static ssize_t charge_control_end_threshold_store(struct device *dev,
+						  struct device_attribute *attr,
+						  const char *buf, size_t count)
+{
+	int value, ret, rv;
+
+	ret = kstrtouint(buf, 10, &value);
+	if (ret)
+		return ret;
+
+	if (value < 0 || value > 100)
+		return -EINVAL;
+
+	ret = asus_wmi_set_devstate(ASUS_WMI_DEVID_RSOC, value, &rv);
+	if (ret)
+		return ret;
+
+	if (rv != 1)
+		return -EIO;
+
+	/* There isn't any method in the DSDT to read the threshold, so we
+	 * save the threshold.
+	 */
+	charge_end_threshold = value;
+	return count;
+}
+
+static ssize_t charge_control_end_threshold_show(struct device *device,
+						 struct device_attribute *attr,
+						 char *buf)
+{
+	return sprintf(buf, "%d\n", charge_end_threshold);
+}
+
+static DEVICE_ATTR_RW(charge_control_end_threshold);
+
+static int asus_wmi_battery_add(struct power_supply *battery)
+{
+	/* The WMI method does not provide a way to specific a battery, so we
+	 * just assume it is the first battery.
+	 */
+	if (strcmp(battery->desc->name, "BAT0") != 0)
+		return -ENODEV;
+
+	if (device_create_file(&battery->dev,
+	    &dev_attr_charge_control_end_threshold))
+		return -ENODEV;
+
+	/* The charge threshold is only reset when the system is power cycled,
+	 * and we can't get the current threshold so let set it to 100% when
+	 * a battery is added.
+	 */
+	asus_wmi_set_devstate(ASUS_WMI_DEVID_RSOC, 100, NULL);
+	charge_end_threshold = 100;
+
+	return 0;
+}
+
+static int asus_wmi_battery_remove(struct power_supply *battery)
+{
+	device_remove_file(&battery->dev,
+			   &dev_attr_charge_control_end_threshold);
+	return 0;
+}
+
+static struct acpi_battery_hook battery_hook = {
+	.add_battery = asus_wmi_battery_add,
+	.remove_battery = asus_wmi_battery_remove,
+	.name = "ASUS Battery Extension",
+};
+
+static void asus_wmi_battery_init(struct asus_wmi *asus)
+{
+	asus->battery_rsoc_available = false;
+	if (asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_RSOC)) {
+		asus->battery_rsoc_available = true;
+		battery_hook_register(&battery_hook);
+	}
+}
+
+static void asus_wmi_battery_exit(struct asus_wmi *asus)
+{
+	if (asus->battery_rsoc_available)
+		battery_hook_unregister(&battery_hook);
+}
+
 /* LEDs ***********************************************************************/
 
 /*
@@ -2052,45 +2147,6 @@ static ssize_t cpufv_store(struct device *dev, struct device_attribute *attr,
 
 static DEVICE_ATTR_WO(cpufv);
 
-
-static ssize_t charge_threshold_store(struct device *dev,
-				      struct device_attribute *attr,
-				      const char *buf, size_t count)
-{
-	struct asus_wmi *asus = dev_get_drvdata(dev);
-	int value, ret, rv;
-
-	ret = kstrtouint(buf, 10, &value);
-	if (ret)
-		return ret;
-
-	if (value < 0 || value > 100)
-		return -EINVAL;
-
-	ret = asus_wmi_set_devstate(ASUS_WMI_DEVID_RSOC, value, &rv);
-	if (ret)
-		return ret;
-
-	if (rv != 1)
-		return -EIO;
-
-	/* There isn't any method in the DSDT to read the threshold, so we
-	 * save the threshold.
-	 */
-	asus->charge_threshold = value;
-	return count;
-}
-
-static ssize_t charge_threshold_show(struct device *dev,
-				     struct device_attribute *attr, char *buf)
-{
-	struct asus_wmi *asus = dev_get_drvdata(dev);
-
-	return sprintf(buf, "%d\n", asus->charge_threshold);
-}
-
-static DEVICE_ATTR_RW(charge_threshold);
-
 static struct attribute *platform_attributes[] = {
 	&dev_attr_cpufv.attr,
 	&dev_attr_camera.attr,
@@ -2099,7 +2155,6 @@ static struct attribute *platform_attributes[] = {
 	&dev_attr_lid_resume.attr,
 	&dev_attr_als_enable.attr,
 	&dev_attr_fan_boost_mode.attr,
-	&dev_attr_charge_threshold.attr,
 	NULL
 };
 
@@ -2123,8 +2178,6 @@ static umode_t asus_sysfs_is_visible(struct kobject *kobj,
 		devid = ASUS_WMI_DEVID_ALS_ENABLE;
 	else if (attr == &dev_attr_fan_boost_mode.attr)
 		ok = asus->fan_boost_mode_available;
-	else if (attr == &dev_attr_charge_threshold.attr)
-		devid = ASUS_WMI_DEVID_RSOC;
 
 	if (devid != -1)
 		ok = !(asus_wmi_get_devstate_simple(asus, devid) < 0);
@@ -2450,13 +2503,9 @@ static int asus_wmi_add(struct platform_device *pdev)
 		goto fail_wmi_handler;
 	}
 
+	asus_wmi_battery_init(asus);
+
 	asus_wmi_debugfs_init(asus);
-	/* The charge threshold is only reset when the system is power cycled,
-	 * and we can't get the current threshold so let set it to 100% on
-	 * module load.
-	 */
-	asus_wmi_set_devstate(ASUS_WMI_DEVID_RSOC, 100, NULL);
-	asus->charge_threshold = 100;
 
 	return 0;
 
@@ -2491,6 +2540,7 @@ static int asus_wmi_remove(struct platform_device *device)
 	asus_wmi_debugfs_exit(asus);
 	asus_wmi_sysfs_exit(asus->platform_device);
 	asus_fan_set_auto(asus);
+	asus_wmi_battery_exit(asus);
 
 	kfree(asus);
 	return 0;

commit 0c37f44845557b5e5b91ab320f256a4fd5059648
Author: Kristian Klausen <kristian@klausen.dk>
Date:   Mon Sep 9 19:31:27 2019 +0200

    platform/x86: asus-wmi: Rename CHARGE_THRESHOLD to RSOC
    
    The device is officially called "Relative state of charge" (RSOC).
    At the same time add the missing DEVID from the name.
    
    Signed-off-by: Kristian Klausen <kristian@klausen.dk>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 848b23764fc3..92c149dc2e6e 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -2067,7 +2067,7 @@ static ssize_t charge_threshold_store(struct device *dev,
 	if (value < 0 || value > 100)
 		return -EINVAL;
 
-	ret = asus_wmi_set_devstate(ASUS_WMI_CHARGE_THRESHOLD, value, &rv);
+	ret = asus_wmi_set_devstate(ASUS_WMI_DEVID_RSOC, value, &rv);
 	if (ret)
 		return ret;
 
@@ -2124,7 +2124,7 @@ static umode_t asus_sysfs_is_visible(struct kobject *kobj,
 	else if (attr == &dev_attr_fan_boost_mode.attr)
 		ok = asus->fan_boost_mode_available;
 	else if (attr == &dev_attr_charge_threshold.attr)
-		devid = ASUS_WMI_CHARGE_THRESHOLD;
+		devid = ASUS_WMI_DEVID_RSOC;
 
 	if (devid != -1)
 		ok = !(asus_wmi_get_devstate_simple(asus, devid) < 0);
@@ -2455,7 +2455,7 @@ static int asus_wmi_add(struct platform_device *pdev)
 	 * and we can't get the current threshold so let set it to 100% on
 	 * module load.
 	 */
-	asus_wmi_set_devstate(ASUS_WMI_CHARGE_THRESHOLD, 100, NULL);
+	asus_wmi_set_devstate(ASUS_WMI_DEVID_RSOC, 100, NULL);
 	asus->charge_threshold = 100;
 
 	return 0;

commit 07779c33a7282366f979e384de263e42aa422ada
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Mon Sep 2 17:38:50 2019 +0300

    platform/x86: asus-wmi: Fix condition in charge_threshold_store()
    
    This error handling is reversed so we return early.
    
    Fixes: 84d8e80b0a36 ("platform/x86: asus-wmi: Refactor charge_threshold_store()")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 14467748b343..848b23764fc3 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -2068,7 +2068,7 @@ static ssize_t charge_threshold_store(struct device *dev,
 		return -EINVAL;
 
 	ret = asus_wmi_set_devstate(ASUS_WMI_CHARGE_THRESHOLD, value, &rv);
-	if (!ret)
+	if (ret)
 		return ret;
 
 	if (rv != 1)

commit 109e8adfbc665a3e463043cefd5d17e552dc020c
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Aug 16 14:17:34 2019 +0300

    platform/x86: asus-wmi: Remove unnecessary blank lines
    
    Remove blank lines where they are not needed.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index d538b8ce1a3a..14467748b343 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -341,7 +341,6 @@ static int asus_wmi_get_devstate_bits(struct asus_wmi *asus,
 	int err;
 
 	err = asus_wmi_get_devstate(asus, dev_id, &retval);
-
 	if (err < 0)
 		return err;
 
@@ -493,7 +492,6 @@ static enum led_brightness kbd_led_get(struct led_classdev *led_cdev)
 	asus = container_of(led_cdev, struct asus_wmi, kbd_led);
 
 	retval = kbd_led_read(asus, &value, NULL);
-
 	if (retval < 0)
 		return retval;
 
@@ -1277,7 +1275,6 @@ static ssize_t pwm1_store(struct device *dev,
 	int ret;
 
 	ret = kstrtouint(buf, 10, &value);
-
 	if (ret)
 		return ret;
 
@@ -1359,7 +1356,6 @@ static ssize_t pwm1_enable_store(struct device *dev,
 	u32 retval;
 
 	ret = kstrtouint(buf, 10, &state);
-
 	if (ret)
 		return ret;
 
@@ -1418,7 +1414,6 @@ static ssize_t asus_hwmon_temp1(struct device *dev,
 	int err;
 
 	err = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_THERMAL_CTRL, &value);
-
 	if (err < 0)
 		return err;
 
@@ -1557,7 +1552,6 @@ static int fan_boost_mode_write(struct asus_wmi *asus)
 	pr_info("Set fan boost mode: %u\n", value);
 	err = asus_wmi_set_devstate(ASUS_WMI_DEVID_FAN_BOOST_MODE, value,
 				    &retval);
-
 	if (err) {
 		pr_warn("Failed to set fan boost mode: %d\n", err);
 		return err;
@@ -1640,6 +1634,7 @@ static DEVICE_ATTR_RW(fan_boost_mode);
 static int read_backlight_power(struct asus_wmi *asus)
 {
 	int ret;
+
 	if (asus->driver->quirks->store_backlight_power)
 		ret = !asus->driver->panel_power;
 	else
@@ -1658,7 +1653,6 @@ static int read_brightness_max(struct asus_wmi *asus)
 	int err;
 
 	err = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_BRIGHTNESS, &retval);
-
 	if (err < 0)
 		return err;
 
@@ -1678,7 +1672,6 @@ static int read_brightness(struct backlight_device *bd)
 	int err;
 
 	err = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_BRIGHTNESS, &retval);
-
 	if (err < 0)
 		return err;
 
@@ -1768,7 +1761,6 @@ static int asus_wmi_backlight_init(struct asus_wmi *asus)
 		return max;
 
 	power = read_backlight_power(asus);
-
 	if (power == -ENODEV)
 		power = FB_BLANK_UNBLANK;
 	else if (power < 0)
@@ -1934,7 +1926,6 @@ static void asus_wmi_notify(u32 value, void *context)
 
 	for (i = 0; i < WMI_EVENT_QUEUE_SIZE + 1; i++) {
 		code = asus_wmi_get_event_code(value);
-
 		if (code < 0) {
 			pr_warn("Failed to get notify code: %d\n", code);
 			return;
@@ -1963,7 +1954,6 @@ static int asus_wmi_notify_queue_flush(struct asus_wmi *asus)
 
 	for (i = 0; i < WMI_EVENT_QUEUE_SIZE + 1; i++) {
 		code = asus_wmi_get_event_code(WMI_EVENT_VALUE_ATK);
-
 		if (code < 0) {
 			pr_warn("Failed to get event during flush: %d\n", code);
 			return code;
@@ -2252,7 +2242,6 @@ static int show_dsts(struct seq_file *m, void *data)
 	u32 retval = -1;
 
 	err = asus_wmi_get_devstate(asus, asus->debug.dev_id, &retval);
-
 	if (err < 0)
 		return err;
 
@@ -2269,7 +2258,6 @@ static int show_devs(struct seq_file *m, void *data)
 
 	err = asus_wmi_set_devstate(asus->debug.dev_id, asus->debug.ctrl_param,
 				    &retval);
-
 	if (err < 0)
 		return err;
 

commit 127e1dfc66cd0ea9ebd0fbf95c817b1b8d1d408b
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Aug 16 14:07:17 2019 +0300

    platform/x86: asus-wmi: Drop indentation level by inverting conditionals
    
    We have extra indentation level where it can be avoided by changing conditional
    to the inverted one.
    
    Do it here for three such locations in the driver.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 42dc2db775d1..d538b8ce1a3a 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -445,15 +445,14 @@ static int kbd_led_read(struct asus_wmi *asus, int *level, int *env)
 	if (retval == 0x8000)
 		retval = 0;
 
-	if (retval >= 0) {
-		if (level)
-			*level = retval & 0x7F;
-		if (env)
-			*env = (retval >> 8) & 0x7F;
-		retval = 0;
-	}
+	if (retval < 0)
+		return retval;
 
-	return retval;
+	if (level)
+		*level = retval & 0x7F;
+	if (env)
+		*env = (retval >> 8) & 0x7F;
+	return 0;
 }
 
 static void do_kbd_led_set(struct led_classdev *led_cdev, int value)
@@ -767,16 +766,14 @@ static int asus_register_rfkill_notifier(struct asus_wmi *asus, char *node)
 	acpi_handle handle;
 
 	status = acpi_get_handle(NULL, node, &handle);
-
-	if (ACPI_SUCCESS(status)) {
-		status = acpi_install_notify_handler(handle,
-						     ACPI_SYSTEM_NOTIFY,
-						     asus_rfkill_notify, asus);
-		if (ACPI_FAILURE(status))
-			pr_warn("Failed to register notify on %s\n", node);
-	} else
+	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
+	status = acpi_install_notify_handler(handle, ACPI_SYSTEM_NOTIFY,
+					     asus_rfkill_notify, asus);
+	if (ACPI_FAILURE(status))
+		pr_warn("Failed to register notify on %s\n", node);
+
 	return 0;
 }
 
@@ -786,15 +783,13 @@ static void asus_unregister_rfkill_notifier(struct asus_wmi *asus, char *node)
 	acpi_handle handle;
 
 	status = acpi_get_handle(NULL, node, &handle);
+	if (ACPI_FAILURE(status))
+		return;
 
-	if (ACPI_SUCCESS(status)) {
-		status = acpi_remove_notify_handler(handle,
-						    ACPI_SYSTEM_NOTIFY,
-						    asus_rfkill_notify);
-		if (ACPI_FAILURE(status))
-			pr_err("Error removing rfkill notify handler %s\n",
-			       node);
-	}
+	status = acpi_remove_notify_handler(handle, ACPI_SYSTEM_NOTIFY,
+					    asus_rfkill_notify);
+	if (ACPI_FAILURE(status))
+		pr_err("Error removing rfkill notify handler %s\n", node);
 }
 
 static int asus_get_adapter_status(struct hotplug_slot *hotplug_slot,

commit 2275752004ab216c667cfdba378c5199f9068e96
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Aug 16 14:10:03 2019 +0300

    platform/x86: asus-wmi: Use clamp_val() instead of open coded variant
    
    There is no need to open code clamp_val() macro implementation.
    Replace the corresponding lines with direct call to clamp_val().
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 6b1f661a6ce6..42dc2db775d1 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -464,12 +464,7 @@ static void do_kbd_led_set(struct led_classdev *led_cdev, int value)
 	asus = container_of(led_cdev, struct asus_wmi, kbd_led);
 	max_level = asus->kbd_led.max_brightness;
 
-	if (value > max_level)
-		value = max_level;
-	else if (value < 0)
-		value = 0;
-
-	asus->kbd_led_wk = value;
+	asus->kbd_led_wk = clamp_val(value, 0, max_level);
 	kbd_led_update(asus);
 }
 

commit a5556fa1107d5b9cda75632c6ece1b4612dd1607
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Aug 16 14:15:55 2019 +0300

    platform/x86: asus-wmi: Replace sscanf() with kstrtoint()
    
    The use of sscanf() is an overkill here. Moreover, there is no need to check
    for count to be 0, since it's guaranteed by sysfs not to be.
    
    Taking above into account, replace sscanf() with kstrtoint() calls.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 1a76d878852f..6b1f661a6ce6 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1989,32 +1989,25 @@ static int asus_wmi_notify_queue_flush(struct asus_wmi *asus)
 
 /* Sysfs **********************************************************************/
 
-static int parse_arg(const char *buf, unsigned long count, int *val)
-{
-	if (!count)
-		return 0;
-	if (sscanf(buf, "%i", val) != 1)
-		return -EINVAL;
-	return count;
-}
-
 static ssize_t store_sys_wmi(struct asus_wmi *asus, int devid,
 			     const char *buf, size_t count)
 {
 	u32 retval;
-	int rv, err, value;
+	int err, value;
 
 	value = asus_wmi_get_devstate_simple(asus, devid);
 	if (value < 0)
 		return value;
 
-	rv = parse_arg(buf, count, &value);
-	err = asus_wmi_set_devstate(devid, value, &retval);
+	err = kstrtoint(buf, 0, &value);
+	if (err)
+		return err;
 
+	err = asus_wmi_set_devstate(devid, value, &retval);
 	if (err < 0)
 		return err;
 
-	return rv;
+	return count;
 }
 
 static ssize_t show_sys_wmi(struct asus_wmi *asus, int devid, char *buf)
@@ -2063,8 +2056,10 @@ static ssize_t cpufv_store(struct device *dev, struct device_attribute *attr,
 {
 	int value, rv;
 
-	if (!count || sscanf(buf, "%i", &value) != 1)
-		return -EINVAL;
+	rv = kstrtoint(buf, 0, &value);
+	if (rv)
+		return rv;
+
 	if (value < 0 || value > 2)
 		return -EINVAL;
 

commit 84d8e80b0a3612aad746837e95d8efe324fdc5c6
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Aug 16 12:46:25 2019 +0300

    platform/x86: asus-wmi: Refactor charge_threshold_store()
    
    There are few issues with the current code:
     - the error code from kstrtouint() is shadowed
     - the error code from asus_wmi_set_devstate() is ignored
     - the extra check against 0 for count (this is guaranteed by sysfs)
    
    Fix these issues by doing a slight refactoring of charge_threshold_store().
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 22ae350e0a96..1a76d878852f 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -2086,13 +2086,15 @@ static ssize_t charge_threshold_store(struct device *dev,
 	int value, ret, rv;
 
 	ret = kstrtouint(buf, 10, &value);
+	if (ret)
+		return ret;
 
-	if (!count || ret != 0)
-		return -EINVAL;
 	if (value < 0 || value > 100)
 		return -EINVAL;
 
-	asus_wmi_set_devstate(ASUS_WMI_CHARGE_THRESHOLD, value, &rv);
+	ret = asus_wmi_set_devstate(ASUS_WMI_CHARGE_THRESHOLD, value, &rv);
+	if (!ret)
+		return ret;
 
 	if (rv != 1)
 		return -EIO;

commit d507a54f5865d8dcbdd16c66a1a2da15640878ca
Author: Kristian Klausen <kristian@klausen.dk>
Date:   Mon Aug 5 21:23:05 2019 +0200

    platform/x86: asus-wmi: Add support for charge threshold
    
    Most newer ASUS laptops supports limiting the battery charge level, which
    help prolonging the battery life.
    
    Tested on a Zenbook UX430UNR.
    
    Signed-off-by: Kristian Klausen <kristian@klausen.dk>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 34dfbed65332..22ae350e0a96 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -195,6 +195,8 @@ struct asus_wmi {
 	u8 fan_boost_mode_mask;
 	u8 fan_boost_mode;
 
+	int charge_threshold;
+
 	struct hotplug_slot hotplug_slot;
 	struct mutex hotplug_lock;
 	struct mutex wmi_lock;
@@ -2075,6 +2077,43 @@ static ssize_t cpufv_store(struct device *dev, struct device_attribute *attr,
 
 static DEVICE_ATTR_WO(cpufv);
 
+
+static ssize_t charge_threshold_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct asus_wmi *asus = dev_get_drvdata(dev);
+	int value, ret, rv;
+
+	ret = kstrtouint(buf, 10, &value);
+
+	if (!count || ret != 0)
+		return -EINVAL;
+	if (value < 0 || value > 100)
+		return -EINVAL;
+
+	asus_wmi_set_devstate(ASUS_WMI_CHARGE_THRESHOLD, value, &rv);
+
+	if (rv != 1)
+		return -EIO;
+
+	/* There isn't any method in the DSDT to read the threshold, so we
+	 * save the threshold.
+	 */
+	asus->charge_threshold = value;
+	return count;
+}
+
+static ssize_t charge_threshold_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct asus_wmi *asus = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", asus->charge_threshold);
+}
+
+static DEVICE_ATTR_RW(charge_threshold);
+
 static struct attribute *platform_attributes[] = {
 	&dev_attr_cpufv.attr,
 	&dev_attr_camera.attr,
@@ -2083,6 +2122,7 @@ static struct attribute *platform_attributes[] = {
 	&dev_attr_lid_resume.attr,
 	&dev_attr_als_enable.attr,
 	&dev_attr_fan_boost_mode.attr,
+	&dev_attr_charge_threshold.attr,
 	NULL
 };
 
@@ -2106,6 +2146,8 @@ static umode_t asus_sysfs_is_visible(struct kobject *kobj,
 		devid = ASUS_WMI_DEVID_ALS_ENABLE;
 	else if (attr == &dev_attr_fan_boost_mode.attr)
 		ok = asus->fan_boost_mode_available;
+	else if (attr == &dev_attr_charge_threshold.attr)
+		devid = ASUS_WMI_CHARGE_THRESHOLD;
 
 	if (devid != -1)
 		ok = !(asus_wmi_get_devstate_simple(asus, devid) < 0);
@@ -2434,6 +2476,12 @@ static int asus_wmi_add(struct platform_device *pdev)
 	}
 
 	asus_wmi_debugfs_init(asus);
+	/* The charge threshold is only reset when the system is power cycled,
+	 * and we can't get the current threshold so let set it to 100% on
+	 * module load.
+	 */
+	asus_wmi_set_devstate(ASUS_WMI_CHARGE_THRESHOLD, 100, NULL);
+	asus->charge_threshold = 100;
 
 	return 0;
 

commit e3168b874321d04c160c9eb937919eb926ae232f
Author: Daniel Drake <drake@endlessm.com>
Date:   Mon Jul 29 16:27:39 2019 +0800

    platform/x86: asus-wmi: fix CPU fan control on recent products
    
    Previously, asus-wmi was using the AGFN interface and FAN_CTRL device
    for CPU fan control. However, this code has been found to be not fully
    working on some recent products, and having checked the spec, these
    interfaces are marked as being removed from future products currently
    in development.
    
    The replacement appears to be the CPU_FAN device, added in spec version
    8.3 (March 2014) and present on many modern Asus laptops.
    
    Add support for this device, and use it whenever it is detected.
    The older approach based on AGFN and FAN_CTRL is used as a fallback
    on products that do not have such device.
    
    Other than switching between automatic and full speed, there is
    no fan speed control through this new interface.
    
    Signed-off-by: Daniel Drake <drake@endlessm.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 25f1e256c442..34dfbed65332 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -67,6 +67,7 @@ MODULE_LICENSE("GPL");
 #define ASUS_FAN_SFUN_WRITE		0x07
 
 /* Based on standard hwmon pwmX_enable values */
+#define ASUS_FAN_CTRL_FULLSPEED		0
 #define ASUS_FAN_CTRL_MANUAL		1
 #define ASUS_FAN_CTRL_AUTO		2
 
@@ -153,6 +154,7 @@ struct asus_rfkill {
 enum fan_type {
 	FAN_TYPE_NONE = 0,
 	FAN_TYPE_AGFN,		/* deprecated on newer platforms */
+	FAN_TYPE_SPEC83,	/* starting in Spec 8.3, use CPU_FAN_CTRL */
 };
 
 struct asus_wmi {
@@ -1211,10 +1213,29 @@ static bool asus_wmi_has_agfn_fan(struct asus_wmi *asus)
 static int asus_fan_set_auto(struct asus_wmi *asus)
 {
 	int status;
+	u32 retval;
 
-	status = asus_agfn_fan_speed_write(asus, 0, NULL);
-	if (status)
+	switch (asus->fan_type) {
+	case FAN_TYPE_SPEC83:
+		status = asus_wmi_set_devstate(ASUS_WMI_DEVID_CPU_FAN_CTRL,
+					       0, &retval);
+		if (status)
+			return status;
+
+		if (retval != 1)
+			return -EIO;
+		break;
+
+	case FAN_TYPE_AGFN:
+		status = asus_agfn_fan_speed_write(asus, 0, NULL);
+		if (status)
+			return -ENXIO;
+		break;
+
+	default:
 		return -ENXIO;
+	}
+
 
 	return 0;
 }
@@ -1287,13 +1308,29 @@ static ssize_t fan1_input_show(struct device *dev,
 	int value;
 	int ret;
 
-	/* no speed readable on manual mode */
-	if (asus->fan_pwm_mode == ASUS_FAN_CTRL_MANUAL)
-		return -ENXIO;
+	switch (asus->fan_type) {
+	case FAN_TYPE_SPEC83:
+		ret = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_CPU_FAN_CTRL,
+					    &value);
+		if (ret < 0)
+			return ret;
 
-	ret = asus_agfn_fan_speed_read(asus, 1, &value);
-	if (ret) {
-		pr_warn("reading fan speed failed: %d\n", ret);
+		value &= 0xffff;
+		break;
+
+	case FAN_TYPE_AGFN:
+		/* no speed readable on manual mode */
+		if (asus->fan_pwm_mode == ASUS_FAN_CTRL_MANUAL)
+			return -ENXIO;
+
+		ret = asus_agfn_fan_speed_read(asus, 1, &value);
+		if (ret) {
+			pr_warn("reading fan speed failed: %d\n", ret);
+			return -ENXIO;
+		}
+		break;
+
+	default:
 		return -ENXIO;
 	}
 
@@ -1306,6 +1343,15 @@ static ssize_t pwm1_enable_show(struct device *dev,
 {
 	struct asus_wmi *asus = dev_get_drvdata(dev);
 
+	/*
+	 * Just read back the cached pwm mode.
+	 *
+	 * For the CPU_FAN device, the spec indicates that we should be
+	 * able to read the device status and consult bit 19 to see if we
+	 * are in Full On or Automatic mode. However, this does not work
+	 * in practice on X532FL at least (the bit is always 0) and there's
+	 * also nothing in the DSDT to indicate that this behaviour exists.
+	 */
 	return sprintf(buf, "%d\n", asus->fan_pwm_mode);
 }
 
@@ -1316,25 +1362,48 @@ static ssize_t pwm1_enable_store(struct device *dev,
 	struct asus_wmi *asus = dev_get_drvdata(dev);
 	int status = 0;
 	int state;
+	int value;
 	int ret;
+	u32 retval;
 
 	ret = kstrtouint(buf, 10, &state);
 
 	if (ret)
 		return ret;
 
-	switch (state) {
-	case ASUS_FAN_CTRL_MANUAL:
-		break;
+	if (asus->fan_type == FAN_TYPE_SPEC83) {
+		switch (state) { /* standard documented hwmon values */
+		case ASUS_FAN_CTRL_FULLSPEED:
+			value = 1;
+			break;
+		case ASUS_FAN_CTRL_AUTO:
+			value = 0;
+			break;
+		default:
+			return -EINVAL;
+		}
 
-	case ASUS_FAN_CTRL_AUTO:
-		status = asus_fan_set_auto(asus);
-		if (status)
-			return status;
-		break;
+		ret = asus_wmi_set_devstate(ASUS_WMI_DEVID_CPU_FAN_CTRL,
+					    value, &retval);
+		if (ret)
+			return ret;
 
-	default:
-		return -EINVAL;
+		if (retval != 1)
+			return -EIO;
+	} else if (asus->fan_type == FAN_TYPE_AGFN) {
+		switch (state) {
+		case ASUS_FAN_CTRL_MANUAL:
+			break;
+
+		case ASUS_FAN_CTRL_AUTO:
+			status = asus_fan_set_auto(asus);
+			if (status)
+				return status;
+			break;
+
+		default:
+			return -EINVAL;
+		}
 	}
 
 	asus->fan_pwm_mode = state;
@@ -1392,9 +1461,11 @@ static umode_t asus_hwmon_sysfs_is_visible(struct kobject *kobj,
 	struct asus_wmi *asus = dev_get_drvdata(dev->parent);
 	u32 value = ASUS_WMI_UNSUPPORTED_METHOD;
 
-	if (attr == &dev_attr_fan1_input.attr
+	if (attr == &dev_attr_pwm1.attr) {
+		if (asus->fan_type != FAN_TYPE_AGFN)
+			return 0;
+	} else if (attr == &dev_attr_fan1_input.attr
 	    || attr == &dev_attr_fan1_label.attr
-	    || attr == &dev_attr_pwm1.attr
 	    || attr == &dev_attr_pwm1_enable.attr) {
 		if (asus->fan_type == FAN_TYPE_NONE)
 			return 0;
@@ -1443,13 +1514,17 @@ static int asus_wmi_fan_init(struct asus_wmi *asus)
 	asus->fan_type = FAN_TYPE_NONE;
 	asus->agfn_pwm = -1;
 
-	if (asus_wmi_has_agfn_fan(asus)) {
+	if (asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_CPU_FAN_CTRL))
+		asus->fan_type = FAN_TYPE_SPEC83;
+	else if (asus_wmi_has_agfn_fan(asus))
 		asus->fan_type = FAN_TYPE_AGFN;
-		asus_fan_set_auto(asus);
-		asus->fan_pwm_mode = ASUS_FAN_CTRL_AUTO;
-	}
 
-	return asus->fan_type != FAN_TYPE_NONE;
+	if (asus->fan_type == FAN_TYPE_NONE)
+		return -ENODEV;
+
+	asus_fan_set_auto(asus);
+	asus->fan_pwm_mode = ASUS_FAN_CTRL_AUTO;
+	return 0;
 }
 
 /* Fan mode *******************************************************************/

commit f1fc032192d2872caef69fb899e939bf7cc24fc7
Author: Daniel Drake <drake@endlessm.com>
Date:   Mon Jul 29 16:27:38 2019 +0800

    platform/x86: asus-wmi: add a helper for device presence
    
    Factor out the WLAN LED and lightbar LED presence checks into a
    helper function, which will also be used by the upcoming CPU fan device
    support.
    
    Signed-off-by: Daniel Drake <drake@endlessm.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index fc2939ac1cfe..25f1e256c442 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -358,6 +358,14 @@ static int asus_wmi_get_devstate_simple(struct asus_wmi *asus, u32 dev_id)
 					  ASUS_WMI_DSTS_STATUS_BIT);
 }
 
+static bool asus_wmi_dev_is_present(struct asus_wmi *asus, u32 dev_id)
+{
+	u32 retval;
+	int status = asus_wmi_get_devstate(asus, dev_id, &retval);
+
+	return status == 0 && (retval & ASUS_WMI_DSTS_PRESENCE_BIT);
+}
+
 /* LEDs ***********************************************************************/
 
 /*
@@ -503,15 +511,6 @@ static int wlan_led_unknown_state(struct asus_wmi *asus)
 	return result & ASUS_WMI_DSTS_UNKNOWN_BIT;
 }
 
-static int wlan_led_presence(struct asus_wmi *asus)
-{
-	u32 result;
-
-	asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_WIRELESS_LED, &result);
-
-	return result & ASUS_WMI_DSTS_PRESENCE_BIT;
-}
-
 static void wlan_led_update(struct work_struct *work)
 {
 	int ctrl_param;
@@ -578,15 +577,6 @@ static enum led_brightness lightbar_led_get(struct led_classdev *led_cdev)
 	return result & ASUS_WMI_DSTS_LIGHTBAR_MASK;
 }
 
-static int lightbar_led_presence(struct asus_wmi *asus)
-{
-	u32 result;
-
-	asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_LIGHTBAR, &result);
-
-	return result & ASUS_WMI_DSTS_PRESENCE_BIT;
-}
-
 static void asus_wmi_led_exit(struct asus_wmi *asus)
 {
 	if (!IS_ERR_OR_NULL(asus->kbd_led.dev))
@@ -637,7 +627,8 @@ static int asus_wmi_led_init(struct asus_wmi *asus)
 			goto error;
 	}
 
-	if (wlan_led_presence(asus) && (asus->driver->quirks->wapf > 0)) {
+	if (asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_WIRELESS_LED)
+			&& (asus->driver->quirks->wapf > 0)) {
 		INIT_WORK(&asus->wlan_led_work, wlan_led_update);
 
 		asus->wlan_led.name = "asus::wlan";
@@ -654,7 +645,7 @@ static int asus_wmi_led_init(struct asus_wmi *asus)
 			goto error;
 	}
 
-	if (lightbar_led_presence(asus)) {
+	if (asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_LIGHTBAR)) {
 		INIT_WORK(&asus->lightbar_led_work, lightbar_led_update);
 
 		asus->lightbar_led.name = "asus::lightbar";

commit 2889ffcfc2522d6d25e5bda704275064062bbb21
Author: Daniel Drake <drake@endlessm.com>
Date:   Mon Jul 29 16:27:37 2019 +0800

    platform/x86: asus-wmi: cleanup AGFN fan handling
    
    The asus-wmi driver currently uses the "AGFN" interface and
    the FAN_CTRL device for fan control. According to the spec, this
    interface is very dated and marked as pending removal from products
    currently in development.
    
    Clean up the way that the AGFN fan is detected and handled, also
    preparing the driver for the introduction of an alternate fan
    control method needed to support recent Asus products.
    
    Not anticipating further development of this interface, simplify
    the code by dropping any notion of being able to control multiple
    AGFN fans (this was already limited to just a single fan through only
    exposing a single fan in sysfs).
    
    Check for the presence of AGFN fans at probe time, simplifying the code
    flow in asus_hwmon_sysfs_is_visible().
    
    Signed-off-by: Daniel Drake <drake@endlessm.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 0c6a810fcb72..fc2939ac1cfe 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -65,6 +65,8 @@ MODULE_LICENSE("GPL");
 #define ASUS_FAN_MFUN			0x13
 #define ASUS_FAN_SFUN_READ		0x06
 #define ASUS_FAN_SFUN_WRITE		0x07
+
+/* Based on standard hwmon pwmX_enable values */
 #define ASUS_FAN_CTRL_MANUAL		1
 #define ASUS_FAN_CTRL_AUTO		2
 
@@ -120,7 +122,7 @@ struct agfn_args {
 } __packed;
 
 /* struct used for calling fan read and write methods */
-struct fan_args {
+struct agfn_fan_args {
 	struct agfn_args agfn;	/* common fields */
 	u8 fan;			/* fan number: 0: set auto mode 1: 1st fan */
 	u32 speed;		/* read: RPM/100 - write: 0-255 */
@@ -148,6 +150,11 @@ struct asus_rfkill {
 	u32 dev_id;
 };
 
+enum fan_type {
+	FAN_TYPE_NONE = 0,
+	FAN_TYPE_AGFN,		/* deprecated on newer platforms */
+};
+
 struct asus_wmi {
 	int dsts_id;
 	int spec;
@@ -178,9 +185,9 @@ struct asus_wmi {
 	struct asus_rfkill gps;
 	struct asus_rfkill uwb;
 
-	bool asus_hwmon_fan_manual_mode;
-	int asus_hwmon_num_fans;
-	int asus_hwmon_pwm;
+	enum fan_type fan_type;
+	int fan_pwm_mode;
+	int agfn_pwm;
 
 	bool fan_boost_mode_available;
 	u8 fan_boost_mode_mask;
@@ -1125,10 +1132,10 @@ static void asus_wmi_set_als(void)
 
 /* Hwmon device ***************************************************************/
 
-static int asus_hwmon_agfn_fan_speed_read(struct asus_wmi *asus, int fan,
+static int asus_agfn_fan_speed_read(struct asus_wmi *asus, int fan,
 					  int *speed)
 {
-	struct fan_args args = {
+	struct agfn_fan_args args = {
 		.agfn.len = sizeof(args),
 		.agfn.mfun = ASUS_FAN_MFUN,
 		.agfn.sfun = ASUS_FAN_SFUN_READ,
@@ -1152,10 +1159,10 @@ static int asus_hwmon_agfn_fan_speed_read(struct asus_wmi *asus, int fan,
 	return 0;
 }
 
-static int asus_hwmon_agfn_fan_speed_write(struct asus_wmi *asus, int fan,
+static int asus_agfn_fan_speed_write(struct asus_wmi *asus, int fan,
 				     int *speed)
 {
-	struct fan_args args = {
+	struct agfn_fan_args args = {
 		.agfn.len = sizeof(args),
 		.agfn.mfun = ASUS_FAN_MFUN,
 		.agfn.sfun = ASUS_FAN_SFUN_WRITE,
@@ -1175,7 +1182,7 @@ static int asus_hwmon_agfn_fan_speed_write(struct asus_wmi *asus, int fan,
 		return -ENXIO;
 
 	if (speed && fan == 1)
-		asus->asus_hwmon_pwm = *speed;
+		asus->agfn_pwm = *speed;
 
 	return 0;
 }
@@ -1184,87 +1191,75 @@ static int asus_hwmon_agfn_fan_speed_write(struct asus_wmi *asus, int fan,
  * Check if we can read the speed of one fan. If true we assume we can also
  * control it.
  */
-static int asus_hwmon_get_fan_number(struct asus_wmi *asus, int *num_fans)
+static bool asus_wmi_has_agfn_fan(struct asus_wmi *asus)
 {
 	int status;
-	int speed = 0;
+	int speed;
+	u32 value;
 
-	*num_fans = 0;
+	status = asus_agfn_fan_speed_read(asus, 1, &speed);
+	if (status != 0)
+		return false;
 
-	status = asus_hwmon_agfn_fan_speed_read(asus, 1, &speed);
-	if (!status)
-		*num_fans = 1;
+	status = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_FAN_CTRL, &value);
+	if (status != 0)
+		return false;
 
-	return 0;
+	/*
+	 * We need to find a better way, probably using sfun,
+	 * bits or spec ...
+	 * Currently we disable it if:
+	 * - ASUS_WMI_UNSUPPORTED_METHOD is returned
+	 * - reverved bits are non-zero
+	 * - sfun and presence bit are not set
+	 */
+	return !(value == ASUS_WMI_UNSUPPORTED_METHOD || value & 0xFFF80000
+		 || (!asus->sfun && !(value & ASUS_WMI_DSTS_PRESENCE_BIT)));
 }
 
-static int asus_hwmon_fan_set_auto(struct asus_wmi *asus)
+static int asus_fan_set_auto(struct asus_wmi *asus)
 {
 	int status;
 
-	status = asus_hwmon_agfn_fan_speed_write(asus, 0, NULL);
+	status = asus_agfn_fan_speed_write(asus, 0, NULL);
 	if (status)
 		return -ENXIO;
 
-	asus->asus_hwmon_fan_manual_mode = false;
-
 	return 0;
 }
 
-static int asus_hwmon_fan_rpm_show(struct device *dev, int fan)
+static ssize_t pwm1_show(struct device *dev,
+			       struct device_attribute *attr,
+			       char *buf)
 {
 	struct asus_wmi *asus = dev_get_drvdata(dev);
-	int value;
-	int ret;
-
-	/* no speed readable on manual mode */
-	if (asus->asus_hwmon_fan_manual_mode)
-		return -ENXIO;
-
-	ret = asus_hwmon_agfn_fan_speed_read(asus, fan+1, &value);
-	if (ret) {
-		pr_warn("reading fan speed failed: %d\n", ret);
-		return -ENXIO;
-	}
-
-	return value;
-}
-
-static void asus_hwmon_pwm_show(struct asus_wmi *asus, int fan, int *value)
-{
 	int err;
+	int value;
 
-	if (asus->asus_hwmon_pwm >= 0) {
-		*value = asus->asus_hwmon_pwm;
-		return;
-	}
+	/* If we already set a value then just return it */
+	if (asus->agfn_pwm >= 0)
+		return sprintf(buf, "%d\n", asus->agfn_pwm);
 
-	err = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_FAN_CTRL, value);
+	/*
+	 * If we haven't set already set a value through the AGFN interface,
+	 * we read a current value through the (now-deprecated) FAN_CTRL device.
+	 */
+	err = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_FAN_CTRL, &value);
 	if (err < 0)
-		return;
+		return err;
 
-	*value &= 0xFF;
-
-	if (*value == 1) /* Low Speed */
-		*value = 85;
-	else if (*value == 2)
-		*value = 170;
-	else if (*value == 3)
-		*value = 255;
-	else if (*value) {
-		pr_err("Unknown fan speed %#x\n", *value);
-		*value = -1;
+	value &= 0xFF;
+
+	if (value == 1) /* Low Speed */
+		value = 85;
+	else if (value == 2)
+		value = 170;
+	else if (value == 3)
+		value = 255;
+	else if (value) {
+		pr_err("Unknown fan speed %#x\n", value);
+		value = -1;
 	}
-}
-
-static ssize_t pwm1_show(struct device *dev,
-			       struct device_attribute *attr,
-			       char *buf)
-{
-	struct asus_wmi *asus = dev_get_drvdata(dev);
-	int value;
-
-	asus_hwmon_pwm_show(asus, 0, &value);
 
 	return sprintf(buf, "%d\n", value);
 }
@@ -1284,11 +1279,11 @@ static ssize_t pwm1_store(struct device *dev,
 
 	value = clamp(value, 0, 255);
 
-	state = asus_hwmon_agfn_fan_speed_write(asus, 1, &value);
+	state = asus_agfn_fan_speed_write(asus, 1, &value);
 	if (state)
 		pr_warn("Setting fan speed failed: %d\n", state);
 	else
-		asus->asus_hwmon_fan_manual_mode = true;
+		asus->fan_pwm_mode = ASUS_FAN_CTRL_MANUAL;
 
 	return count;
 }
@@ -1297,10 +1292,21 @@ static ssize_t fan1_input_show(struct device *dev,
 					struct device_attribute *attr,
 					char *buf)
 {
-	int value = asus_hwmon_fan_rpm_show(dev, 0);
+	struct asus_wmi *asus = dev_get_drvdata(dev);
+	int value;
+	int ret;
 
-	return sprintf(buf, "%d\n", value < 0 ? -1 : value*100);
+	/* no speed readable on manual mode */
+	if (asus->fan_pwm_mode == ASUS_FAN_CTRL_MANUAL)
+		return -ENXIO;
+
+	ret = asus_agfn_fan_speed_read(asus, 1, &value);
+	if (ret) {
+		pr_warn("reading fan speed failed: %d\n", ret);
+		return -ENXIO;
+	}
 
+	return sprintf(buf, "%d\n", value < 0 ? -1 : value*100);
 }
 
 static ssize_t pwm1_enable_show(struct device *dev,
@@ -1309,10 +1315,7 @@ static ssize_t pwm1_enable_show(struct device *dev,
 {
 	struct asus_wmi *asus = dev_get_drvdata(dev);
 
-	if (asus->asus_hwmon_fan_manual_mode)
-		return sprintf(buf, "%d\n", ASUS_FAN_CTRL_MANUAL);
-
-	return sprintf(buf, "%d\n", ASUS_FAN_CTRL_AUTO);
+	return sprintf(buf, "%d\n", asus->fan_pwm_mode);
 }
 
 static ssize_t pwm1_enable_store(struct device *dev,
@@ -1329,14 +1332,21 @@ static ssize_t pwm1_enable_store(struct device *dev,
 	if (ret)
 		return ret;
 
-	if (state == ASUS_FAN_CTRL_MANUAL)
-		asus->asus_hwmon_fan_manual_mode = true;
-	else
-		status = asus_hwmon_fan_set_auto(asus);
+	switch (state) {
+	case ASUS_FAN_CTRL_MANUAL:
+		break;
 
-	if (status)
-		return status;
+	case ASUS_FAN_CTRL_AUTO:
+		status = asus_fan_set_auto(asus);
+		if (status)
+			return status;
+		break;
 
+	default:
+		return -EINVAL;
+	}
+
+	asus->fan_pwm_mode = state;
 	return count;
 }
 
@@ -1389,59 +1399,31 @@ static umode_t asus_hwmon_sysfs_is_visible(struct kobject *kobj,
 {
 	struct device *dev = container_of(kobj, struct device, kobj);
 	struct asus_wmi *asus = dev_get_drvdata(dev->parent);
-	int dev_id = -1;
-	int fan_attr = -1;
 	u32 value = ASUS_WMI_UNSUPPORTED_METHOD;
-	bool ok = true;
-
-	if (attr == &dev_attr_pwm1.attr)
-		dev_id = ASUS_WMI_DEVID_FAN_CTRL;
-	else if (attr == &dev_attr_temp1_input.attr)
-		dev_id = ASUS_WMI_DEVID_THERMAL_CTRL;
-
 
 	if (attr == &dev_attr_fan1_input.attr
 	    || attr == &dev_attr_fan1_label.attr
 	    || attr == &dev_attr_pwm1.attr
 	    || attr == &dev_attr_pwm1_enable.attr) {
-		fan_attr = 1;
-	}
-
-	if (dev_id != -1) {
-		int err = asus_wmi_get_devstate(asus, dev_id, &value);
+		if (asus->fan_type == FAN_TYPE_NONE)
+			return 0;
+	} else if (attr == &dev_attr_temp1_input.attr) {
+		int err = asus_wmi_get_devstate(asus,
+						ASUS_WMI_DEVID_THERMAL_CTRL,
+						&value);
 
-		if (err < 0 && fan_attr == -1)
+		if (err < 0)
 			return 0; /* can't return negative here */
-	}
 
-	if (dev_id == ASUS_WMI_DEVID_FAN_CTRL) {
-		/*
-		 * We need to find a better way, probably using sfun,
-		 * bits or spec ...
-		 * Currently we disable it if:
-		 * - ASUS_WMI_UNSUPPORTED_METHOD is returned
-		 * - reverved bits are non-zero
-		 * - sfun and presence bit are not set
-		 */
-		if (value == ASUS_WMI_UNSUPPORTED_METHOD || value & 0xFFF80000
-		    || (!asus->sfun && !(value & ASUS_WMI_DSTS_PRESENCE_BIT)))
-			ok = false;
-		else
-			ok = fan_attr <= asus->asus_hwmon_num_fans;
-	} else if (dev_id == ASUS_WMI_DEVID_THERMAL_CTRL) {
 		/*
 		 * If the temperature value in deci-Kelvin is near the absolute
 		 * zero temperature, something is clearly wrong
 		 */
 		if (value == 0 || value == 1)
-			ok = false;
-	} else if (fan_attr <= asus->asus_hwmon_num_fans && fan_attr != -1) {
-		ok = true;
-	} else {
-		ok = false;
+			return 0;
 	}
 
-	return ok ? attr->mode : 0;
+	return attr->mode;
 }
 
 static const struct attribute_group hwmon_attribute_group = {
@@ -1467,21 +1449,16 @@ static int asus_wmi_hwmon_init(struct asus_wmi *asus)
 
 static int asus_wmi_fan_init(struct asus_wmi *asus)
 {
-	int status;
-
-	asus->asus_hwmon_pwm = -1;
-	asus->asus_hwmon_num_fans = -1;
-	asus->asus_hwmon_fan_manual_mode = false;
+	asus->fan_type = FAN_TYPE_NONE;
+	asus->agfn_pwm = -1;
 
-	status = asus_hwmon_get_fan_number(asus, &asus->asus_hwmon_num_fans);
-	if (status) {
-		asus->asus_hwmon_num_fans = 0;
-		pr_warn("Could not determine number of fans: %d\n", status);
-		return -ENXIO;
+	if (asus_wmi_has_agfn_fan(asus)) {
+		asus->fan_type = FAN_TYPE_AGFN;
+		asus_fan_set_auto(asus);
+		asus->fan_pwm_mode = ASUS_FAN_CTRL_AUTO;
 	}
 
-	pr_info("Number of fans: %d\n", asus->asus_hwmon_num_fans);
-	return 0;
+	return asus->fan_type != FAN_TYPE_NONE;
 }
 
 /* Fan mode *******************************************************************/
@@ -2333,7 +2310,6 @@ static int asus_wmi_add(struct platform_device *pdev)
 		goto fail_input;
 
 	err = asus_wmi_fan_init(asus); /* probably no problems on error */
-	asus_hwmon_fan_set_auto(asus);
 
 	err = asus_wmi_hwmon_init(asus);
 	if (err)
@@ -2425,7 +2401,7 @@ static int asus_wmi_remove(struct platform_device *device)
 	asus_wmi_rfkill_exit(asus);
 	asus_wmi_debugfs_exit(asus);
 	asus_wmi_sysfs_exit(asus->platform_device);
-	asus_hwmon_fan_set_auto(asus);
+	asus_fan_set_auto(asus);
 
 	kfree(asus);
 	return 0;

commit 340f25ff1d4fd3bfe0d3e0769261fec8fb32ae9f
Author: Fuqian Huang <huangfq.daxian@gmail.com>
Date:   Thu Jul 4 00:29:51 2019 +0800

    platform/x86: asus-wmi: Use kmemdup rather than duplicating its implementation
    
    kmemdup is introduced to duplicate a region of memory in a neat way.
    Rather than kmalloc/kzalloc + memcpy, which the programmer needs to
    write the size twice (sometimes lead to mistakes), kmemdup improves
    readability, leads to smaller code and also reduce the chances of mistakes.
    Suggestion to use kmemdup rather than using kmalloc/kzalloc + memcpy.
    
    Signed-off-by: Fuqian Huang <huangfq.daxian@gmail.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index ca28d27dae63..0c6a810fcb72 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -292,12 +292,11 @@ static int asus_wmi_evaluate_method_agfn(const struct acpi_buffer args)
 	 * Copy to dma capable address otherwise memory corruption occurs as
 	 * bios has to be able to access it.
 	 */
-	input.pointer = kzalloc(args.length, GFP_DMA | GFP_KERNEL);
+	input.pointer = kmemdup(args.pointer, args.length, GFP_DMA | GFP_KERNEL);
 	input.length = args.length;
 	if (!input.pointer)
 		return -ENOMEM;
 	phys_addr = virt_to_phys(input.pointer);
-	memcpy(input.pointer, args.pointer, args.length);
 
 	status = asus_wmi_evaluate_method(ASUS_WMI_METHODID_AGFN,
 					phys_addr, 0, &retval);

commit 9af93db9e140a4e6e79cdb098919bc928a72cd59
Author: Daniel Drake <drake@endlessm.com>
Date:   Wed Jul 17 13:10:58 2019 +0800

    platform/x86: asus: Rename "fan mode" to "fan boost mode"
    
    The Asus WMI spec indicates that the function being controlled here
    is called "Fan Boost Mode". The user-facing documentation also calls it
    this.
    
    The spec uses the term "fan mode" is used to refer to other things,
    including functionality expected to appear on future products.
    We missed this before as we are not dealing with the most readable of
    specs, and didn't forsee any confusion around shortening the name.
    
    Rename "fan mode" to "fan boost mode" to improve consistency with the
    spec and to avoid a future naming conflict.
    
    There is no interface breakage here since this has yet to be included
    in an official kernel release. I also updated the kernel version listed
    under ABI accordingly.
    
    Signed-off-by: Daniel Drake <drake@endlessm.com>
    Acked-by: Yurii Pavlovskyi <yurii.pavlovskyi@gmail.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 18f3a8bad52f..ca28d27dae63 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -68,12 +68,12 @@ MODULE_LICENSE("GPL");
 #define ASUS_FAN_CTRL_MANUAL		1
 #define ASUS_FAN_CTRL_AUTO		2
 
-#define ASUS_FAN_MODE_NORMAL		0
-#define ASUS_FAN_MODE_OVERBOOST		1
-#define ASUS_FAN_MODE_OVERBOOST_MASK	0x01
-#define ASUS_FAN_MODE_SILENT		2
-#define ASUS_FAN_MODE_SILENT_MASK	0x02
-#define ASUS_FAN_MODES_MASK		0x03
+#define ASUS_FAN_BOOST_MODE_NORMAL		0
+#define ASUS_FAN_BOOST_MODE_OVERBOOST		1
+#define ASUS_FAN_BOOST_MODE_OVERBOOST_MASK	0x01
+#define ASUS_FAN_BOOST_MODE_SILENT		2
+#define ASUS_FAN_BOOST_MODE_SILENT_MASK		0x02
+#define ASUS_FAN_BOOST_MODES_MASK		0x03
 
 #define USB_INTEL_XUSB2PR		0xD0
 #define PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI	0x9c31
@@ -182,9 +182,9 @@ struct asus_wmi {
 	int asus_hwmon_num_fans;
 	int asus_hwmon_pwm;
 
-	bool fan_mode_available;
-	u8 fan_mode_mask;
-	u8 fan_mode;
+	bool fan_boost_mode_available;
+	u8 fan_boost_mode_mask;
+	u8 fan_boost_mode;
 
 	struct hotplug_slot hotplug_slot;
 	struct mutex hotplug_lock;
@@ -1487,14 +1487,15 @@ static int asus_wmi_fan_init(struct asus_wmi *asus)
 
 /* Fan mode *******************************************************************/
 
-static int fan_mode_check_present(struct asus_wmi *asus)
+static int fan_boost_mode_check_present(struct asus_wmi *asus)
 {
 	u32 result;
 	int err;
 
-	asus->fan_mode_available = false;
+	asus->fan_boost_mode_available = false;
 
-	err = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_FAN_MODE, &result);
+	err = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_FAN_BOOST_MODE,
+				    &result);
 	if (err) {
 		if (err == -ENODEV)
 			return 0;
@@ -1503,72 +1504,77 @@ static int fan_mode_check_present(struct asus_wmi *asus)
 	}
 
 	if ((result & ASUS_WMI_DSTS_PRESENCE_BIT) &&
-			(result & ASUS_FAN_MODES_MASK)) {
-		asus->fan_mode_available = true;
-		asus->fan_mode_mask = result & ASUS_FAN_MODES_MASK;
+			(result & ASUS_FAN_BOOST_MODES_MASK)) {
+		asus->fan_boost_mode_available = true;
+		asus->fan_boost_mode_mask = result & ASUS_FAN_BOOST_MODES_MASK;
 	}
 
 	return 0;
 }
 
-static int fan_mode_write(struct asus_wmi *asus)
+static int fan_boost_mode_write(struct asus_wmi *asus)
 {
 	int err;
 	u8 value;
 	u32 retval;
 
-	value = asus->fan_mode;
+	value = asus->fan_boost_mode;
 
-	pr_info("Set fan mode: %u\n", value);
-	err = asus_wmi_set_devstate(ASUS_WMI_DEVID_FAN_MODE, value, &retval);
+	pr_info("Set fan boost mode: %u\n", value);
+	err = asus_wmi_set_devstate(ASUS_WMI_DEVID_FAN_BOOST_MODE, value,
+				    &retval);
 
 	if (err) {
-		pr_warn("Failed to set fan mode: %d\n", err);
+		pr_warn("Failed to set fan boost mode: %d\n", err);
 		return err;
 	}
 
 	if (retval != 1) {
-		pr_warn("Failed to set fan mode (retval): 0x%x\n", retval);
+		pr_warn("Failed to set fan boost mode (retval): 0x%x\n",
+			retval);
 		return -EIO;
 	}
 
 	return 0;
 }
 
-static int fan_mode_switch_next(struct asus_wmi *asus)
+static int fan_boost_mode_switch_next(struct asus_wmi *asus)
 {
-	if (asus->fan_mode == ASUS_FAN_MODE_NORMAL) {
-		if (asus->fan_mode_mask & ASUS_FAN_MODE_OVERBOOST_MASK)
-			asus->fan_mode = ASUS_FAN_MODE_OVERBOOST;
-		else if (asus->fan_mode_mask & ASUS_FAN_MODE_SILENT_MASK)
-			asus->fan_mode = ASUS_FAN_MODE_SILENT;
-	} else if (asus->fan_mode == ASUS_FAN_MODE_OVERBOOST) {
-		if (asus->fan_mode_mask & ASUS_FAN_MODE_SILENT_MASK)
-			asus->fan_mode = ASUS_FAN_MODE_SILENT;
+	u8 mask = asus->fan_boost_mode_mask;
+
+	if (asus->fan_boost_mode == ASUS_FAN_BOOST_MODE_NORMAL) {
+		if (mask & ASUS_FAN_BOOST_MODE_OVERBOOST_MASK)
+			asus->fan_boost_mode = ASUS_FAN_BOOST_MODE_OVERBOOST;
+		else if (mask & ASUS_FAN_BOOST_MODE_SILENT_MASK)
+			asus->fan_boost_mode = ASUS_FAN_BOOST_MODE_SILENT;
+	} else if (asus->fan_boost_mode == ASUS_FAN_BOOST_MODE_OVERBOOST) {
+		if (mask & ASUS_FAN_BOOST_MODE_SILENT_MASK)
+			asus->fan_boost_mode = ASUS_FAN_BOOST_MODE_SILENT;
 		else
-			asus->fan_mode = ASUS_FAN_MODE_NORMAL;
+			asus->fan_boost_mode = ASUS_FAN_BOOST_MODE_NORMAL;
 	} else {
-		asus->fan_mode = ASUS_FAN_MODE_NORMAL;
+		asus->fan_boost_mode = ASUS_FAN_BOOST_MODE_NORMAL;
 	}
 
-	return fan_mode_write(asus);
+	return fan_boost_mode_write(asus);
 }
 
-static ssize_t fan_mode_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
+static ssize_t fan_boost_mode_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
 {
 	struct asus_wmi *asus = dev_get_drvdata(dev);
 
-	return scnprintf(buf, PAGE_SIZE, "%d\n", asus->fan_mode);
+	return scnprintf(buf, PAGE_SIZE, "%d\n", asus->fan_boost_mode);
 }
 
-static ssize_t fan_mode_store(struct device *dev, struct device_attribute *attr,
-		const char *buf, size_t count)
+static ssize_t fan_boost_mode_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
 {
 	int result;
 	u8 new_mode;
-
 	struct asus_wmi *asus = dev_get_drvdata(dev);
+	u8 mask = asus->fan_boost_mode_mask;
 
 	result = kstrtou8(buf, 10, &new_mode);
 	if (result < 0) {
@@ -1576,24 +1582,24 @@ static ssize_t fan_mode_store(struct device *dev, struct device_attribute *attr,
 		return result;
 	}
 
-	if (new_mode == ASUS_FAN_MODE_OVERBOOST) {
-		if (!(asus->fan_mode_mask & ASUS_FAN_MODE_OVERBOOST_MASK))
+	if (new_mode == ASUS_FAN_BOOST_MODE_OVERBOOST) {
+		if (!(mask & ASUS_FAN_BOOST_MODE_OVERBOOST_MASK))
 			return -EINVAL;
-	} else if (new_mode == ASUS_FAN_MODE_SILENT) {
-		if (!(asus->fan_mode_mask & ASUS_FAN_MODE_SILENT_MASK))
+	} else if (new_mode == ASUS_FAN_BOOST_MODE_SILENT) {
+		if (!(mask & ASUS_FAN_BOOST_MODE_SILENT_MASK))
 			return -EINVAL;
-	} else if (new_mode != ASUS_FAN_MODE_NORMAL) {
+	} else if (new_mode != ASUS_FAN_BOOST_MODE_NORMAL) {
 		return -EINVAL;
 	}
 
-	asus->fan_mode = new_mode;
-	fan_mode_write(asus);
+	asus->fan_boost_mode = new_mode;
+	fan_boost_mode_write(asus);
 
 	return result;
 }
 
-// Fan mode: 0 - normal, 1 - overboost, 2 - silent
-static DEVICE_ATTR_RW(fan_mode);
+// Fan boost mode: 0 - normal, 1 - overboost, 2 - silent
+static DEVICE_ATTR_RW(fan_boost_mode);
 
 /* Backlight ******************************************************************/
 
@@ -1873,8 +1879,8 @@ static void asus_wmi_handle_event_code(int code, struct asus_wmi *asus)
 		return;
 	}
 
-	if (asus->fan_mode_available && code == NOTIFY_KBD_FBM) {
-		fan_mode_switch_next(asus);
+	if (asus->fan_boost_mode_available && code == NOTIFY_KBD_FBM) {
+		fan_boost_mode_switch_next(asus);
 		return;
 	}
 
@@ -2034,7 +2040,7 @@ static struct attribute *platform_attributes[] = {
 	&dev_attr_touchpad.attr,
 	&dev_attr_lid_resume.attr,
 	&dev_attr_als_enable.attr,
-	&dev_attr_fan_mode.attr,
+	&dev_attr_fan_boost_mode.attr,
 	NULL
 };
 
@@ -2056,8 +2062,8 @@ static umode_t asus_sysfs_is_visible(struct kobject *kobj,
 		devid = ASUS_WMI_DEVID_LID_RESUME;
 	else if (attr == &dev_attr_als_enable.attr)
 		devid = ASUS_WMI_DEVID_ALS_ENABLE;
-	else if (attr == &dev_attr_fan_mode.attr)
-		ok = asus->fan_mode_available;
+	else if (attr == &dev_attr_fan_boost_mode.attr)
+		ok = asus->fan_boost_mode_available;
 
 	if (devid != -1)
 		ok = !(asus_wmi_get_devstate_simple(asus, devid) < 0);
@@ -2315,9 +2321,9 @@ static int asus_wmi_add(struct platform_device *pdev)
 	if (err)
 		goto fail_platform;
 
-	err = fan_mode_check_present(asus);
+	err = fan_boost_mode_check_present(asus);
 	if (err)
-		goto fail_fan_mode;
+		goto fail_fan_boost_mode;
 
 	err = asus_wmi_sysfs_init(asus->platform_device);
 	if (err)
@@ -2402,7 +2408,7 @@ static int asus_wmi_add(struct platform_device *pdev)
 fail_input:
 	asus_wmi_sysfs_exit(asus->platform_device);
 fail_sysfs:
-fail_fan_mode:
+fail_fan_boost_mode:
 fail_platform:
 	kfree(asus);
 	return err;

commit 55167453111d3a1e600e29ba6c8e63906bb4821b
Merge: fde7dc63b1ca 7d67c8ac25fb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jul 14 16:51:47 2019 -0700

    Merge tag 'platform-drivers-x86-v5.3-1' of git://git.infradead.org/linux-platform-drivers-x86
    
    Pull x86 platform driver updates from Andy Shevchenko:
     "Gathered a bunch of x86 platform driver changes. It's rather big,
      since includes two big refactors and completely new driver:
    
       - ASUS WMI driver got a big refactoring in order to support the TUF
         Gaming laptops. Besides that, the regression with backlight being
         permanently off on various EeePC laptops has been fixed.
    
       - Accelerometer on HP ProBook 450 G0 shows wrong measurements due to
         X axis being inverted. This has been fixed.
    
       - Intel PMC core driver has been extended to be ACPI enumerated if
         the DSDT provides device with _HID "INT33A1". This allows to
         convert the driver to be pure platform and support new hardware
         purely based on ACPI DSDT.
    
       - From now on the Intel Speed Select Technology is supported thru a
         corresponding driver. This driver provides an access to the
         features of the ISST, such as Performance Profile, Core Power, Base
         frequency and Turbo Frequency.
    
       - Mellanox platform drivers has been refactored and now extended to
         support more systems, including new coming ones.
    
       - The OLPC XO-1.75 platform is now supported.
    
       - CB4063 Beckhoff Automation board is using PMC clocks, provided via
         pmc_atom driver, for ethernet controllers in a way that they can't
         be managed by the clock driver. The quirk has been extended to
         cover this case.
    
       - Touchscreen on Chuwi Hi10 Plus tablet has been enabled. Meanwhile
         the information of Chuwi Hi10 Air has been fixed to cover more
         models based on the same platform.
    
       - Xiaomi notebooks have WMI interface enabled. Thus, the driver to
         support it has been provided. It required some extension of the
         generic WMI library, which allows to propagate opaque context to
         the ->probe() of the individual drivers.
    
      This release includes debugfs clean up from Greg KH for several
      drivers that drop return code check and make debugfs absence or
      failure non-fatal.
    
      Also miscellaneous fixes here and there, mostly for Acer WMI and
      various Intel drivers"
    
    * tag 'platform-drivers-x86-v5.3-1' of git://git.infradead.org/linux-platform-drivers-x86: (74 commits)
      platform/x86: Fix PCENGINES_APU2 Kconfig warning
      tools/power/x86/intel-speed-select: Add .gitignore file
      platform/x86: mlx-platform: Fix error handling in mlxplat_init()
      platform/x86: intel_pmc_core: Attach using APCI HID "INT33A1"
      platform/x86: intel_pmc_core: transform Pkg C-state residency from TSC ticks into microseconds
      platform/x86: asus-wmi: Use dev_get_drvdata()
      Documentation/ABI: Add new attribute for mlxreg-io sysfs interfaces
      platform/x86: mlx-platform: Add more reset cause attributes
      platform/x86: mlx-platform: Modify DMI matching order
      platform/x86: mlx-platform: Add regmap structure for the next generation systems
      platform/x86: mlx-platform: Change API for i2c-mlxcpld driver activation
      platform/x86: mlx-platform: Move regmap initialization before all drivers activation
      MAINTAINERS: Update for Intel Speed Select Technology
      tools/power/x86: A tool to validate Intel Speed Select commands
      platform/x86: ISST: Restore state on resume
      platform/x86: ISST: Add Intel Speed Select PUNIT MSR interface
      platform/x86: ISST: Add Intel Speed Select mailbox interface via MSRs
      platform/x86: ISST: Add Intel Speed Select mailbox interface via PCI
      platform/x86: ISST: Add Intel Speed Select mmio interface
      platform/x86: ISST: Add IOCTL to Translate Linux logical CPU to PUNIT CPU number
      ...

commit 8e8fe446a91caf4537f512572e4bf52f8f2154a9
Author: Fuqian Huang <huangfq.daxian@gmail.com>
Date:   Mon Jul 1 11:24:26 2019 +0800

    platform/x86: asus-wmi: Use dev_get_drvdata()
    
    Using dev_get_drvdata directly.
    
    Signed-off-by: Fuqian Huang <huangfq.daxian@gmail.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 508e6ad47793..269ed7e94013 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1402,8 +1402,7 @@ static umode_t asus_hwmon_sysfs_is_visible(struct kobject *kobj,
 					  struct attribute *attr, int idx)
 {
 	struct device *dev = container_of(kobj, struct device, kobj);
-	struct platform_device *pdev = to_platform_device(dev->parent);
-	struct asus_wmi *asus = platform_get_drvdata(pdev);
+	struct asus_wmi *asus = dev_get_drvdata(dev->parent);
 	int dev_id = -1;
 	int fan_attr = -1;
 	u32 value = ASUS_WMI_UNSUPPORTED_METHOD;

commit 3e58167ac3703c9b15a8600ab559d239f3d4dd97
Author: Yurii Pavlovskyi <yurii.pavlovskyi@gmail.com>
Date:   Tue May 14 21:07:46 2019 +0200

    platform/x86: asus-wmi: Do not disable keyboard backlight on unloading
    
    The keyboard backlight is automatically disabled when the module is
    unloaded as it is exposed as a ledclass device. Change this behavior to
    ignore setting brightness when the device is in unloading state.
    
    Signed-off-by: Yurii Pavlovskyi <yurii.pavlovskyi@gmail.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 5712bc56fa10..508e6ad47793 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -471,6 +471,10 @@ static void do_kbd_led_set(struct led_classdev *led_cdev, int value)
 static void kbd_led_set(struct led_classdev *led_cdev,
 			enum led_brightness value)
 {
+	/* Prevent disabling keyboard backlight on module unregister */
+	if (led_cdev->flags & LED_UNREGISTERING)
+		return;
+
 	do_kbd_led_set(led_cdev, value);
 }
 

commit b096f626a6827ad2ced5ebdbdc04e62422d463f6
Author: Yurii Pavlovskyi <yurii.pavlovskyi@gmail.com>
Date:   Tue May 14 21:07:05 2019 +0200

    platform/x86: asus-wmi: Switch fan boost mode
    
    The WMI exposes a write-only device ID where up to three fan modes can be
    switched on some laptops (TUF Gaming FX505GM). There is a hotkey
    combination Fn-F5 that does have a fan icon, which is designed to toggle
    between fan modes. The DSTS of the device ID returns information about the
    presence of this capability and the presence of each of the two additional
    fan modes as a bitmask (0x01 - overboost present, 0x02 - silent present)
    [1].
    
    Add a SysFS entry that reads the last written value and updates value in
    WMI on write and a hotkey handler that toggles the modes taking into
    account their availability according to DSTS.
    
    Modes:
    * 0x00 - normal or balanced,
    * 0x01 - overboost, increased fan RPM,
    * 0x02 - silent, decreased fan RPM
    
    [1] Link: https://lkml.org/lkml/2019/4/12/110
    
    Signed-off-by: Yurii Pavlovskyi <yurii.pavlovskyi@gmail.com>
    Suggested-by: Daniel Drake <drake@endlessm.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index a1d85667383c..5712bc56fa10 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -70,6 +70,7 @@ MODULE_LICENSE("GPL");
 #define NOTIFY_KBD_BRTUP		0xc4
 #define NOTIFY_KBD_BRTDWN		0xc5
 #define NOTIFY_KBD_BRTTOGGLE		0xc7
+#define NOTIFY_KBD_FBM			0x99
 
 #define ASUS_WMI_FNLOCK_BIOS_DISABLED	BIT(0)
 
@@ -80,6 +81,13 @@ MODULE_LICENSE("GPL");
 #define ASUS_FAN_CTRL_MANUAL		1
 #define ASUS_FAN_CTRL_AUTO		2
 
+#define ASUS_FAN_MODE_NORMAL		0
+#define ASUS_FAN_MODE_OVERBOOST		1
+#define ASUS_FAN_MODE_OVERBOOST_MASK	0x01
+#define ASUS_FAN_MODE_SILENT		2
+#define ASUS_FAN_MODE_SILENT_MASK	0x02
+#define ASUS_FAN_MODES_MASK		0x03
+
 #define USB_INTEL_XUSB2PR		0xD0
 #define PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI	0x9c31
 
@@ -187,6 +195,10 @@ struct asus_wmi {
 	int asus_hwmon_num_fans;
 	int asus_hwmon_pwm;
 
+	bool fan_mode_available;
+	u8 fan_mode_mask;
+	u8 fan_mode;
+
 	struct hotplug_slot hotplug_slot;
 	struct mutex hotplug_lock;
 	struct mutex wmi_lock;
@@ -1483,6 +1495,116 @@ static int asus_wmi_fan_init(struct asus_wmi *asus)
 	return 0;
 }
 
+/* Fan mode *******************************************************************/
+
+static int fan_mode_check_present(struct asus_wmi *asus)
+{
+	u32 result;
+	int err;
+
+	asus->fan_mode_available = false;
+
+	err = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_FAN_MODE, &result);
+	if (err) {
+		if (err == -ENODEV)
+			return 0;
+		else
+			return err;
+	}
+
+	if ((result & ASUS_WMI_DSTS_PRESENCE_BIT) &&
+			(result & ASUS_FAN_MODES_MASK)) {
+		asus->fan_mode_available = true;
+		asus->fan_mode_mask = result & ASUS_FAN_MODES_MASK;
+	}
+
+	return 0;
+}
+
+static int fan_mode_write(struct asus_wmi *asus)
+{
+	int err;
+	u8 value;
+	u32 retval;
+
+	value = asus->fan_mode;
+
+	pr_info("Set fan mode: %u\n", value);
+	err = asus_wmi_set_devstate(ASUS_WMI_DEVID_FAN_MODE, value, &retval);
+
+	if (err) {
+		pr_warn("Failed to set fan mode: %d\n", err);
+		return err;
+	}
+
+	if (retval != 1) {
+		pr_warn("Failed to set fan mode (retval): 0x%x\n", retval);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int fan_mode_switch_next(struct asus_wmi *asus)
+{
+	if (asus->fan_mode == ASUS_FAN_MODE_NORMAL) {
+		if (asus->fan_mode_mask & ASUS_FAN_MODE_OVERBOOST_MASK)
+			asus->fan_mode = ASUS_FAN_MODE_OVERBOOST;
+		else if (asus->fan_mode_mask & ASUS_FAN_MODE_SILENT_MASK)
+			asus->fan_mode = ASUS_FAN_MODE_SILENT;
+	} else if (asus->fan_mode == ASUS_FAN_MODE_OVERBOOST) {
+		if (asus->fan_mode_mask & ASUS_FAN_MODE_SILENT_MASK)
+			asus->fan_mode = ASUS_FAN_MODE_SILENT;
+		else
+			asus->fan_mode = ASUS_FAN_MODE_NORMAL;
+	} else {
+		asus->fan_mode = ASUS_FAN_MODE_NORMAL;
+	}
+
+	return fan_mode_write(asus);
+}
+
+static ssize_t fan_mode_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct asus_wmi *asus = dev_get_drvdata(dev);
+
+	return scnprintf(buf, PAGE_SIZE, "%d\n", asus->fan_mode);
+}
+
+static ssize_t fan_mode_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	int result;
+	u8 new_mode;
+
+	struct asus_wmi *asus = dev_get_drvdata(dev);
+
+	result = kstrtou8(buf, 10, &new_mode);
+	if (result < 0) {
+		pr_warn("Trying to store invalid value\n");
+		return result;
+	}
+
+	if (new_mode == ASUS_FAN_MODE_OVERBOOST) {
+		if (!(asus->fan_mode_mask & ASUS_FAN_MODE_OVERBOOST_MASK))
+			return -EINVAL;
+	} else if (new_mode == ASUS_FAN_MODE_SILENT) {
+		if (!(asus->fan_mode_mask & ASUS_FAN_MODE_SILENT_MASK))
+			return -EINVAL;
+	} else if (new_mode != ASUS_FAN_MODE_NORMAL) {
+		return -EINVAL;
+	}
+
+	asus->fan_mode = new_mode;
+	fan_mode_write(asus);
+
+	return result;
+}
+
+// Fan mode: 0 - normal, 1 - overboost, 2 - silent
+static DEVICE_ATTR_RW(fan_mode);
+
 /* Backlight ******************************************************************/
 
 static int read_backlight_power(struct asus_wmi *asus)
@@ -1761,6 +1883,11 @@ static void asus_wmi_handle_event_code(int code, struct asus_wmi *asus)
 		return;
 	}
 
+	if (asus->fan_mode_available && code == NOTIFY_KBD_FBM) {
+		fan_mode_switch_next(asus);
+		return;
+	}
+
 	if (is_display_toggle(code) && asus->driver->quirks->no_display_toggle)
 		return;
 
@@ -1917,6 +2044,7 @@ static struct attribute *platform_attributes[] = {
 	&dev_attr_touchpad.attr,
 	&dev_attr_lid_resume.attr,
 	&dev_attr_als_enable.attr,
+	&dev_attr_fan_mode.attr,
 	NULL
 };
 
@@ -1938,6 +2066,8 @@ static umode_t asus_sysfs_is_visible(struct kobject *kobj,
 		devid = ASUS_WMI_DEVID_LID_RESUME;
 	else if (attr == &dev_attr_als_enable.attr)
 		devid = ASUS_WMI_DEVID_ALS_ENABLE;
+	else if (attr == &dev_attr_fan_mode.attr)
+		ok = asus->fan_mode_available;
 
 	if (devid != -1)
 		ok = !(asus_wmi_get_devstate_simple(asus, devid) < 0);
@@ -2037,12 +2167,7 @@ static int asus_wmi_platform_init(struct asus_wmi *asus)
 		asus_wmi_set_devstate(ASUS_WMI_DEVID_CWAP,
 				      asus->driver->quirks->wapf, NULL);
 
-	return asus_wmi_sysfs_init(asus->platform_device);
-}
-
-static void asus_wmi_platform_exit(struct asus_wmi *asus)
-{
-	asus_wmi_sysfs_exit(asus->platform_device);
+	return 0;
 }
 
 /* debugfs ********************************************************************/
@@ -2200,6 +2325,14 @@ static int asus_wmi_add(struct platform_device *pdev)
 	if (err)
 		goto fail_platform;
 
+	err = fan_mode_check_present(asus);
+	if (err)
+		goto fail_fan_mode;
+
+	err = asus_wmi_sysfs_init(asus->platform_device);
+	if (err)
+		goto fail_sysfs;
+
 	err = asus_wmi_input_init(asus);
 	if (err)
 		goto fail_input;
@@ -2277,7 +2410,9 @@ static int asus_wmi_add(struct platform_device *pdev)
 fail_hwmon:
 	asus_wmi_input_exit(asus);
 fail_input:
-	asus_wmi_platform_exit(asus);
+	asus_wmi_sysfs_exit(asus->platform_device);
+fail_sysfs:
+fail_fan_mode:
 fail_platform:
 	kfree(asus);
 	return err;
@@ -2294,7 +2429,7 @@ static int asus_wmi_remove(struct platform_device *device)
 	asus_wmi_led_exit(asus);
 	asus_wmi_rfkill_exit(asus);
 	asus_wmi_debugfs_exit(asus);
-	asus_wmi_platform_exit(asus);
+	asus_wmi_sysfs_exit(asus->platform_device);
 	asus_hwmon_fan_set_auto(asus);
 
 	kfree(asus);

commit 4fd1982545398bf801fe13455e02bc01b6402de6
Author: Yurii Pavlovskyi <yurii.pavlovskyi@gmail.com>
Date:   Tue May 14 21:05:46 2019 +0200

    platform/x86: asus-wmi: Enhance detection of thermal data
    
    The obviously wrong value 1 for temperature device ID in this driver is
    returned by at least some devices, including TUF Gaming series laptops,
    instead of 0 as expected previously. Observable effect is that a
    temp1_input in hwmon reads temperature near absolute zero.
    
    Consider 0.1 K an erroneous value in addition to 0 K.
    
    Signed-off-by: Yurii Pavlovskyi <yurii.pavlovskyi@gmail.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 3a4e61cfa15d..a1d85667383c 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1428,8 +1428,11 @@ static umode_t asus_hwmon_sysfs_is_visible(struct kobject *kobj,
 		else
 			ok = fan_attr <= asus->asus_hwmon_num_fans;
 	} else if (dev_id == ASUS_WMI_DEVID_THERMAL_CTRL) {
-		/* If value is zero, something is clearly wrong */
-		if (!value)
+		/*
+		 * If the temperature value in deci-Kelvin is near the absolute
+		 * zero temperature, something is clearly wrong
+		 */
+		if (value == 0 || value == 1)
 			ok = false;
 	} else if (fan_attr <= asus->asus_hwmon_num_fans && fan_attr != -1) {
 		ok = true;

commit 54a3121f00dad3227735085fd568cdee5a733696
Author: Yurii Pavlovskyi <yurii.pavlovskyi@gmail.com>
Date:   Tue May 14 21:04:48 2019 +0200

    platform/x86: asus-wmi: Organize code into sections
    
    The driver has grown pretty big and will grow more, which makes it hard to
    navigate and understand. Add uniform comments to the code and ensure that
    it is sorted into logical sections.
    
    Signed-off-by: Yurii Pavlovskyi <yurii.pavlovskyi@gmail.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 5cbd7fc365b3..3a4e61cfa15d 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -200,6 +200,8 @@ struct asus_wmi {
 	struct asus_wmi_driver *driver;
 };
 
+/* Input **********************************************************************/
+
 static int asus_wmi_input_init(struct asus_wmi *asus)
 {
 	int err;
@@ -237,6 +239,8 @@ static void asus_wmi_input_exit(struct asus_wmi *asus)
 	asus->inputdev = NULL;
 }
 
+/* WMI ************************************************************************/
+
 static int asus_wmi_evaluate_method3(u32 method_id,
 		u32 arg0, u32 arg1, u32 arg2, u32 *retval)
 {
@@ -349,9 +353,8 @@ static int asus_wmi_get_devstate_simple(struct asus_wmi *asus, u32 dev_id)
 					  ASUS_WMI_DSTS_STATUS_BIT);
 }
 
-/*
- * LEDs
- */
+/* LEDs ***********************************************************************/
+
 /*
  * These functions actually update the LED's, and are called from a
  * workqueue. By doing this as separate work rather than when the LED
@@ -661,6 +664,7 @@ static int asus_wmi_led_init(struct asus_wmi *asus)
 	return rv;
 }
 
+/* RF *************************************************************************/
 
 /*
  * PCI hotplug (for wlan rfkill)
@@ -1083,6 +1087,8 @@ static int asus_wmi_rfkill_init(struct asus_wmi *asus)
 	return result;
 }
 
+/* Quirks *********************************************************************/
+
 static void asus_wmi_set_xusb2pr(struct asus_wmi *asus)
 {
 	struct pci_dev *xhci_pdev;
@@ -1115,9 +1121,8 @@ static void asus_wmi_set_als(void)
 	asus_wmi_set_devstate(ASUS_WMI_DEVID_ALS_ENABLE, 1, NULL);
 }
 
-/*
- * Hwmon device
- */
+/* Hwmon device ***************************************************************/
+
 static int asus_hwmon_agfn_fan_speed_read(struct asus_wmi *asus, int fan,
 					  int *speed)
 {
@@ -1456,9 +1461,27 @@ static int asus_wmi_hwmon_init(struct asus_wmi *asus)
 	return 0;
 }
 
-/*
- * Backlight
- */
+static int asus_wmi_fan_init(struct asus_wmi *asus)
+{
+	int status;
+
+	asus->asus_hwmon_pwm = -1;
+	asus->asus_hwmon_num_fans = -1;
+	asus->asus_hwmon_fan_manual_mode = false;
+
+	status = asus_hwmon_get_fan_number(asus, &asus->asus_hwmon_num_fans);
+	if (status) {
+		asus->asus_hwmon_num_fans = 0;
+		pr_warn("Could not determine number of fans: %d\n", status);
+		return -ENXIO;
+	}
+
+	pr_info("Number of fans: %d\n", asus->asus_hwmon_num_fans);
+	return 0;
+}
+
+/* Backlight ******************************************************************/
+
 static int read_backlight_power(struct asus_wmi *asus)
 {
 	int ret;
@@ -1640,6 +1663,8 @@ static int is_display_toggle(int code)
 	return 0;
 }
 
+/* Fn-lock ********************************************************************/
+
 static bool asus_wmi_has_fnlock_key(struct asus_wmi *asus)
 {
 	u32 result;
@@ -1657,6 +1682,8 @@ static void asus_wmi_fnlock_update(struct asus_wmi *asus)
 	asus_wmi_set_devstate(ASUS_WMI_DEVID_FNLOCK, mode, NULL);
 }
 
+/* WMI events *****************************************************************/
+
 static int asus_wmi_get_event_code(u32 value)
 {
 	struct acpi_buffer response = { ACPI_ALLOCATE_BUFFER, NULL };
@@ -1790,9 +1817,8 @@ static int asus_wmi_notify_queue_flush(struct asus_wmi *asus)
 	return -EIO;
 }
 
-/*
- * Sys helpers
- */
+/* Sysfs **********************************************************************/
+
 static int parse_arg(const char *buf, unsigned long count, int *val)
 {
 	if (!count)
@@ -1931,9 +1957,8 @@ static int asus_wmi_sysfs_init(struct platform_device *device)
 	return sysfs_create_group(&device->dev.kobj, &platform_attribute_group);
 }
 
-/*
- * Platform device
- */
+/* Platform device ************************************************************/
+
 static int asus_wmi_platform_init(struct asus_wmi *asus)
 {
 	struct device *dev = &asus->platform_device->dev;
@@ -2017,9 +2042,8 @@ static void asus_wmi_platform_exit(struct asus_wmi *asus)
 	asus_wmi_sysfs_exit(asus->platform_device);
 }
 
-/*
- * debugfs
- */
+/* debugfs ********************************************************************/
+
 struct asus_wmi_debugfs_node {
 	struct asus_wmi *asus;
 	char *name;
@@ -2145,28 +2169,8 @@ static void asus_wmi_debugfs_init(struct asus_wmi *asus)
 	}
 }
 
-static int asus_wmi_fan_init(struct asus_wmi *asus)
-{
-	int status;
-
-	asus->asus_hwmon_pwm = -1;
-	asus->asus_hwmon_num_fans = -1;
-	asus->asus_hwmon_fan_manual_mode = false;
+/* Init / exit ****************************************************************/
 
-	status = asus_hwmon_get_fan_number(asus, &asus->asus_hwmon_num_fans);
-	if (status) {
-		asus->asus_hwmon_num_fans = 0;
-		pr_warn("Could not determine number of fans: %d\n", status);
-		return -ENXIO;
-	}
-
-	pr_info("Number of fans: %d\n", asus->asus_hwmon_num_fans);
-	return 0;
-}
-
-/*
- * WMI Driver
- */
 static int asus_wmi_add(struct platform_device *pdev)
 {
 	struct platform_driver *pdrv = to_platform_driver(pdev->dev.driver);
@@ -2294,9 +2298,8 @@ static int asus_wmi_remove(struct platform_device *device)
 	return 0;
 }
 
-/*
- * Platform driver - hibernate/resume callbacks
- */
+/* Platform driver - hibernate/resume callbacks *******************************/
+
 static int asus_hotk_thaw(struct device *device)
 {
 	struct asus_wmi *asus = dev_get_drvdata(device);
@@ -2372,6 +2375,8 @@ static const struct dev_pm_ops asus_pm_ops = {
 	.resume = asus_hotk_resume,
 };
 
+/* Registration ***************************************************************/
+
 static int asus_wmi_probe(struct platform_device *pdev)
 {
 	struct platform_driver *pdrv = to_platform_driver(pdev->dev.driver);

commit 1827f3f06aafe67c1d273025a26390d9d2bdd3f7
Author: Yurii Pavlovskyi <yurii.pavlovskyi@gmail.com>
Date:   Tue May 14 21:03:50 2019 +0200

    platform/x86: asus-wmi: Refactor error handling
    
    Remove exit label as it is only used once from the point in code where no
    cleanup is required and return can be called immediately.
    
    Signed-off-by: Yurii Pavlovskyi <yurii.pavlovskyi@gmail.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 83bf145e9ca5..5cbd7fc365b3 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -255,7 +255,7 @@ static int asus_wmi_evaluate_method3(u32 method_id,
 				     &input, &output);
 
 	if (ACPI_FAILURE(status))
-		goto exit;
+		return -EIO;
 
 	obj = (union acpi_object *)output.pointer;
 	if (obj && obj->type == ACPI_TYPE_INTEGER)
@@ -266,10 +266,6 @@ static int asus_wmi_evaluate_method3(u32 method_id,
 
 	kfree(obj);
 
-exit:
-	if (ACPI_FAILURE(status))
-		return -EIO;
-
 	if (tmp == ASUS_WMI_UNSUPPORTED_METHOD)
 		return -ENODEV;
 

commit 1a373d15e283937b51eaf5debf4fc31474c31436
Author: Yurii Pavlovskyi <yurii.pavlovskyi@gmail.com>
Date:   Tue May 14 21:02:09 2019 +0200

    platform/x86: asus-wmi: Support WMI event queue
    
    Event codes are expected to be retrieved from a queue on at least some
    models. Specifically, very likely the ACPI WMI devices with _UID ATK are
    queued whereas those with ASUSWMI are not [1].
    
    The WMI event codes are pushed into a circular buffer queue. After the INIT
    method is called, ACPI code is allowed to push events into this buffer.
    The INIT method cannot be reverted. If the module is unloaded and an event
    (such as hotkey press) gets emitted before inserting it back the events get
    processed delayed by one or if the queue overflows, additionally delayed by
    about 3 seconds.
    
    It might be considered a minor issue and no normal user would likely
    observe this (there is little reason unloading the driver), but it does
    significantly frustrate a developer who is unlucky enough to encounter
    this. Therefore, the fallback to unqueued behavior occurs whenever
    something unexpected happens.
    
    The fix flushes the old key codes out of the queue on load. After receiving
    event the queue is read until either ..FFFF or 1 is encountered. Also as
    noted in [1] it is checked whether notify code is equal to 0xFF before
    enabling queue processing in WMI notify handler.
    
    DSDT examples:
    
    FX505GM
    Device (ATKD)
    { ..
        Name (ATKQ, Package (0x10)
        {
            0xFFFFFFFF, ..
        }
    
        Method (IANQ, 1, Serialized)
        {
            If ((AQNO >= 0x10))
            {
                Local0 = 0x64
                While ((Local0 && (AQNO >= 0x10)))
                {
                    Local0--
                    Sleep (0x0A)
                }
                ...
            ..
            AQTI++
            AQTI &= 0x0F
            ATKQ [AQTI] = Arg0
            ...
        }
    
        Method (GANQ, 0, Serialized)
        {
            ..
            If (AQNO)
            {
                ...
                Local0 = DerefOf (ATKQ [AQHI])
                AQHI++
                AQHI &= 0x0F
                Return (Local0)
            }
    
            Return (One)
        }
    
    This code is almost identical to K54C, which does return Ones on empty
    queue.
    
    K54C:
    Method (GANQ, 0, Serialized)
    {
        If (AQNO)
        {
            ...
            Return (Local0)
        }
    
        Return (Ones)
    }
    
    [1] Link: https://lkml.org/lkml/2019/4/12/104
    
    Signed-off-by: Yurii Pavlovskyi <yurii.pavlovskyi@gmail.com>
    Suggested-by: Daniel Drake <drake@endlessm.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index fc4ccdedb626..83bf145e9ca5 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -84,6 +84,13 @@ MODULE_LICENSE("GPL");
 #define PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI	0x9c31
 
 #define ASUS_ACPI_UID_ASUSWMI		"ASUSWMI"
+#define ASUS_ACPI_UID_ATK		"ATK"
+
+#define WMI_EVENT_QUEUE_SIZE		0x10
+#define WMI_EVENT_QUEUE_END		0x1
+#define WMI_EVENT_MASK			0xFFFF
+/* The WMI hotkey event value is always the same. */
+#define WMI_EVENT_VALUE_ATK		0xFF
 
 #define WMI_EVENT_MASK			0xFFFF
 
@@ -150,6 +157,7 @@ struct asus_wmi {
 	int dsts_id;
 	int spec;
 	int sfun;
+	bool wmi_event_queue;
 
 	struct input_dev *inputdev;
 	struct backlight_device *backlight_device;
@@ -1738,14 +1746,52 @@ static void asus_wmi_handle_event_code(int code, struct asus_wmi *asus)
 static void asus_wmi_notify(u32 value, void *context)
 {
 	struct asus_wmi *asus = context;
-	int code = asus_wmi_get_event_code(value);
+	int code;
+	int i;
 
-	if (code < 0) {
-		pr_warn("Failed to get notify code: %d\n", code);
-		return;
+	for (i = 0; i < WMI_EVENT_QUEUE_SIZE + 1; i++) {
+		code = asus_wmi_get_event_code(value);
+
+		if (code < 0) {
+			pr_warn("Failed to get notify code: %d\n", code);
+			return;
+		}
+
+		if (code == WMI_EVENT_QUEUE_END || code == WMI_EVENT_MASK)
+			return;
+
+		asus_wmi_handle_event_code(code, asus);
+
+		/*
+		 * Double check that queue is present:
+		 * ATK (with queue) uses 0xff, ASUSWMI (without) 0xd2.
+		 */
+		if (!asus->wmi_event_queue || value != WMI_EVENT_VALUE_ATK)
+			return;
 	}
 
-	asus_wmi_handle_event_code(code, asus);
+	pr_warn("Failed to process event queue, last code: 0x%x\n", code);
+}
+
+static int asus_wmi_notify_queue_flush(struct asus_wmi *asus)
+{
+	int code;
+	int i;
+
+	for (i = 0; i < WMI_EVENT_QUEUE_SIZE + 1; i++) {
+		code = asus_wmi_get_event_code(WMI_EVENT_VALUE_ATK);
+
+		if (code < 0) {
+			pr_warn("Failed to get event during flush: %d\n", code);
+			return code;
+		}
+
+		if (code == WMI_EVENT_QUEUE_END || code == WMI_EVENT_MASK)
+			return 0;
+	}
+
+	pr_warn("Failed to flush event queue\n");
+	return -EIO;
 }
 
 /*
@@ -1944,6 +1990,23 @@ static int asus_wmi_platform_init(struct asus_wmi *asus)
 		asus->dsts_id = ASUS_WMI_METHODID_DSTS;
 	}
 
+	/*
+	 * Some devices can have multiple event codes stored in a queue before
+	 * the module load if it was unloaded intermittently after calling
+	 * the INIT method (enables event handling). The WMI notify handler is
+	 * expected to retrieve all event codes until a retrieved code equals
+	 * queue end marker (One or Ones). Old codes are flushed from the queue
+	 * upon module load. Not enabling this when it should be has minimal
+	 * visible impact so fall back if anything goes wrong.
+	 */
+	wmi_uid = wmi_get_acpi_device_uid(asus->driver->event_guid);
+	if (wmi_uid && !strcmp(wmi_uid, ASUS_ACPI_UID_ATK)) {
+		dev_info(dev, "Detected ATK, enable event queue\n");
+
+		if (!asus_wmi_notify_queue_flush(asus))
+			asus->wmi_event_queue = true;
+	}
+
 	/* CWAP allow to define the behavior of the Fn+F2 key,
 	 * this method doesn't seems to be present on Eee PCs */
 	if (asus->driver->quirks->wapf >= 0)

commit 8abd752bd4733ed2e812fc37413ef80e13946c34
Author: Yurii Pavlovskyi <yurii.pavlovskyi@gmail.com>
Date:   Tue May 14 21:01:24 2019 +0200

    platform/x86: asus-wmi: Refactor WMI event handling
    
    Refactor WMI event handling into separate functions for getting the event
    code and handling the retrieved event code as a preparation for
    introduction of WMI event queue support.
    
    Signed-off-by: Yurii Pavlovskyi <yurii.pavlovskyi@gmail.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index ef526dcfeac5..fc4ccdedb626 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -85,6 +85,8 @@ MODULE_LICENSE("GPL");
 
 #define ASUS_ACPI_UID_ASUSWMI		"ASUSWMI"
 
+#define WMI_EVENT_MASK			0xFFFF
+
 static const char * const ashs_ids[] = { "ATK4001", "ATK4002", NULL };
 
 static bool ashs_present(void)
@@ -1651,83 +1653,99 @@ static void asus_wmi_fnlock_update(struct asus_wmi *asus)
 	asus_wmi_set_devstate(ASUS_WMI_DEVID_FNLOCK, mode, NULL);
 }
 
-static void asus_wmi_notify(u32 value, void *context)
+static int asus_wmi_get_event_code(u32 value)
 {
-	struct asus_wmi *asus = context;
 	struct acpi_buffer response = { ACPI_ALLOCATE_BUFFER, NULL };
 	union acpi_object *obj;
 	acpi_status status;
 	int code;
-	int orig_code;
-	unsigned int key_value = 1;
-	bool autorelease = 1;
 
 	status = wmi_get_event_data(value, &response);
-	if (status != AE_OK) {
-		pr_err("bad event status 0x%x\n", status);
-		return;
+	if (ACPI_FAILURE(status)) {
+		pr_warn("Failed to get WMI notify code: %s\n",
+				acpi_format_exception(status));
+		return -EIO;
 	}
 
 	obj = (union acpi_object *)response.pointer;
 
-	if (!obj || obj->type != ACPI_TYPE_INTEGER)
-		goto exit;
+	if (obj && obj->type == ACPI_TYPE_INTEGER)
+		code = (int)(obj->integer.value & WMI_EVENT_MASK);
+	else
+		code = -EIO;
+
+	kfree(obj);
+	return code;
+}
+
+static void asus_wmi_handle_event_code(int code, struct asus_wmi *asus)
+{
+	int orig_code;
+	unsigned int key_value = 1;
+	bool autorelease = 1;
 
-	code = obj->integer.value;
 	orig_code = code;
 
 	if (asus->driver->key_filter) {
 		asus->driver->key_filter(asus->driver, &code, &key_value,
 					 &autorelease);
 		if (code == ASUS_WMI_KEY_IGNORE)
-			goto exit;
+			return;
 	}
 
 	if (code >= NOTIFY_BRNUP_MIN && code <= NOTIFY_BRNUP_MAX)
 		code = ASUS_WMI_BRN_UP;
-	else if (code >= NOTIFY_BRNDOWN_MIN &&
-		 code <= NOTIFY_BRNDOWN_MAX)
+	else if (code >= NOTIFY_BRNDOWN_MIN && code <= NOTIFY_BRNDOWN_MAX)
 		code = ASUS_WMI_BRN_DOWN;
 
 	if (code == ASUS_WMI_BRN_DOWN || code == ASUS_WMI_BRN_UP) {
 		if (acpi_video_get_backlight_type() == acpi_backlight_vendor) {
 			asus_wmi_backlight_notify(asus, orig_code);
-			goto exit;
+			return;
 		}
 	}
 
 	if (code == NOTIFY_KBD_BRTUP) {
 		kbd_led_set_by_kbd(asus, asus->kbd_led_wk + 1);
-		goto exit;
+		return;
 	}
 	if (code == NOTIFY_KBD_BRTDWN) {
 		kbd_led_set_by_kbd(asus, asus->kbd_led_wk - 1);
-		goto exit;
+		return;
 	}
 	if (code == NOTIFY_KBD_BRTTOGGLE) {
 		if (asus->kbd_led_wk == asus->kbd_led.max_brightness)
 			kbd_led_set_by_kbd(asus, 0);
 		else
 			kbd_led_set_by_kbd(asus, asus->kbd_led_wk + 1);
-		goto exit;
+		return;
 	}
 
 	if (code == NOTIFY_FNLOCK_TOGGLE) {
 		asus->fnlock_locked = !asus->fnlock_locked;
 		asus_wmi_fnlock_update(asus);
-		goto exit;
+		return;
 	}
 
-	if (is_display_toggle(code) &&
-	    asus->driver->quirks->no_display_toggle)
-		goto exit;
+	if (is_display_toggle(code) && asus->driver->quirks->no_display_toggle)
+		return;
 
 	if (!sparse_keymap_report_event(asus->inputdev, code,
 					key_value, autorelease))
 		pr_info("Unknown key %x pressed\n", code);
+}
 
-exit:
-	kfree(obj);
+static void asus_wmi_notify(u32 value, void *context)
+{
+	struct asus_wmi *asus = context;
+	int code = asus_wmi_get_event_code(value);
+
+	if (code < 0) {
+		pr_warn("Failed to get notify code: %d\n", code);
+		return;
+	}
+
+	asus_wmi_handle_event_code(code, asus);
 }
 
 /*

commit e0668f28888184f6c633110a37386f2d4a6fa00e
Author: Yurii Pavlovskyi <yurii.pavlovskyi@gmail.com>
Date:   Tue May 14 21:00:31 2019 +0200

    platform/x86: asus-wmi: Improve DSTS WMI method ID detection
    
    The DSTS method detection mistakenly selects DCTS instead of DSTS if
    nothing is returned when the method ID is not defined in WMNB. As a result,
    the control of keyboard backlight is not functional for TUF Gaming series
    laptops. Implement detection based on _UID of the WMI device instead.
    
    There is evidence that DCTS is handled by ACPI WMI devices that have _UID
    ASUSWMI, whereas none of the devices without ASUSWMI respond to DCTS and
    DSTS is used instead [1].
    
    DSDT examples:
    
    FX505GM (_UID ATK):
    Method (WMNB, 3, Serialized)
    { ...
        If ((Local0 == 0x53545344))
        {
            ...
            Return (Zero)
        }
        ...
        // No return
    }
    
    K54C (_UID ATK):
    Method (WMNB, 3, Serialized)
    { ...
        If ((Local0 == 0x53545344))
        {
            ...
            Return (0x02)
        }
        ...
        Return (0xFFFFFFFE)
    }
    
    [1] Link: https://lkml.org/lkml/2019/4/11/322
    
    Signed-off-by: Yurii Pavlovskyi <yurii.pavlovskyi@gmail.com>
    Suggested-by: Daniel Drake <drake@endlessm.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index c67f11e0d6e7..ef526dcfeac5 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -83,6 +83,8 @@ MODULE_LICENSE("GPL");
 #define USB_INTEL_XUSB2PR		0xD0
 #define PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI	0x9c31
 
+#define ASUS_ACPI_UID_ASUSWMI		"ASUSWMI"
+
 static const char * const ashs_ids[] = { "ATK4001", "ATK4002", NULL };
 
 static bool ashs_present(void)
@@ -1874,6 +1876,8 @@ static int asus_wmi_sysfs_init(struct platform_device *device)
  */
 static int asus_wmi_platform_init(struct asus_wmi *asus)
 {
+	struct device *dev = &asus->platform_device->dev;
+	char *wmi_uid;
 	int rv;
 
 	/* INIT enable hotkeys on some models */
@@ -1903,11 +1907,24 @@ static int asus_wmi_platform_init(struct asus_wmi *asus)
 	 * Note, on most Eeepc, there is no way to check if a method exist
 	 * or note, while on notebooks, they returns 0xFFFFFFFE on failure,
 	 * but once again, SPEC may probably be used for that kind of things.
+	 *
+	 * Additionally at least TUF Gaming series laptops return nothing for
+	 * unknown methods, so the detection in this way is not possible.
+	 *
+	 * There is strong indication that only ACPI WMI devices that have _UID
+	 * equal to "ASUSWMI" use DCTS whereas those with "ATK" use DSTS.
 	 */
-	if (!asus_wmi_evaluate_method(ASUS_WMI_METHODID_DSTS, 0, 0, NULL))
+	wmi_uid = wmi_get_acpi_device_uid(ASUS_WMI_MGMT_GUID);
+	if (!wmi_uid)
+		return -ENODEV;
+
+	if (!strcmp(wmi_uid, ASUS_ACPI_UID_ASUSWMI)) {
+		dev_info(dev, "Detected ASUSWMI, use DCTS\n");
+		asus->dsts_id = ASUS_WMI_METHODID_DCTS;
+	} else {
+		dev_info(dev, "Detected %s, not ASUSWMI, use DSTS\n", wmi_uid);
 		asus->dsts_id = ASUS_WMI_METHODID_DSTS;
-	else
-		asus->dsts_id = ASUS_WMI_METHODID_DSTS2;
+	}
 
 	/* CWAP allow to define the behavior of the Fn+F2 key,
 	 * this method doesn't seems to be present on Eee PCs */

commit 98e865a522983f2afde075648ec9d15ea4bb9194
Author: Yurii Pavlovskyi <yurii.pavlovskyi@gmail.com>
Date:   Tue May 14 20:54:50 2019 +0200

    platform/x86: asus-wmi: Increase input buffer size of WMI methods
    
    The asus-nb-wmi driver is matched by WMI alias but fails to load on TUF
    Gaming series laptops producing multiple ACPI errors in the kernel log.
    
    The input buffer for WMI method invocation size is 2 dwords, whereas
    3 are expected by this model.
    
    FX505GM:
    ..
    Method (WMNB, 3, Serialized)
    {
        P8XH (Zero, 0x11)
        CreateDWordField (Arg2, Zero, IIA0)
        CreateDWordField (Arg2, 0x04, IIA1)
        CreateDWordField (Arg2, 0x08, IIA2)
        Local0 = (Arg1 & 0xFFFFFFFF)
        ...
    
    Compare with older K54C:
    ...
    Method (WMNB, 3, NotSerialized)
    {
        CreateDWordField (Arg2, 0x00, IIA0)
        CreateDWordField (Arg2, 0x04, IIA1)
        Local0 = (Arg1 & 0xFFFFFFFF)
        ...
    
    Increase buffer size to 3 dwords. No negative consequences of this change
    are expected, as the input buffer size is not verified. The original
    function is replaced by a wrapper for a new method passing value 0 for the
    last parameter. The new function will be used to control RGB keyboard
    backlight.
    
    Signed-off-by: Yurii Pavlovskyi <yurii.pavlovskyi@gmail.com>
    Reviewed-by: Daniel Drake <drake@endlessm.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index b536e757df17..c67f11e0d6e7 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -98,6 +98,7 @@ static bool ashs_present(void)
 struct bios_args {
 	u32 arg0;
 	u32 arg1;
+	u32 arg2; /* At least TUF Gaming series uses 3 dword input buffer. */
 } __packed;
 
 /*
@@ -224,11 +225,13 @@ static void asus_wmi_input_exit(struct asus_wmi *asus)
 	asus->inputdev = NULL;
 }
 
-int asus_wmi_evaluate_method(u32 method_id, u32 arg0, u32 arg1, u32 *retval)
+static int asus_wmi_evaluate_method3(u32 method_id,
+		u32 arg0, u32 arg1, u32 arg2, u32 *retval)
 {
 	struct bios_args args = {
 		.arg0 = arg0,
 		.arg1 = arg1,
+		.arg2 = arg2,
 	};
 	struct acpi_buffer input = { (acpi_size) sizeof(args), &args };
 	struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
@@ -260,6 +263,11 @@ int asus_wmi_evaluate_method(u32 method_id, u32 arg0, u32 arg1, u32 *retval)
 
 	return 0;
 }
+
+int asus_wmi_evaluate_method(u32 method_id, u32 arg0, u32 arg1, u32 *retval)
+{
+	return asus_wmi_evaluate_method3(method_id, arg0, arg1, 0, retval);
+}
 EXPORT_SYMBOL_GPL(asus_wmi_evaluate_method);
 
 static int asus_wmi_evaluate_method_agfn(const struct acpi_buffer args)

commit 8853a2f6498b244d0cfff5c11158e2f76e323975
Author: Yurii Pavlovskyi <yurii.pavlovskyi@gmail.com>
Date:   Tue May 14 20:51:25 2019 +0200

    platform/x86: asus-wmi: Fix preserving keyboard backlight intensity on load
    
    The error code and return value are mixed up. The intensity is always set
    to 0 on load as kbd_led_read returns either 0 or negative value. To
    reproduce set backlight to maximum, reload driver and try to increase it
    using keyboard hotkey, the intensity will drop as a result. Correct the
    implementation.
    
    Signed-off-by: Yurii Pavlovskyi <yurii.pavlovskyi@gmail.com>
    Reviewed-by: Daniel Drake <drake@endlessm.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 6a590ec4c4ef..b536e757df17 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -595,8 +595,7 @@ static int asus_wmi_led_init(struct asus_wmi *asus)
 			goto error;
 	}
 
-	led_val = kbd_led_read(asus, NULL, NULL);
-	if (led_val >= 0) {
+	if (!kbd_led_read(asus, &led_val, NULL)) {
 		asus->kbd_led_wk = led_val;
 		asus->kbd_led.name = "asus::kbd_backlight";
 		asus->kbd_led.flags = LED_BRIGHT_HW_CHANGED;

commit cd10ee006ab504b2b9c5ed992cc06d3e110c6311
Author: Yurii Pavlovskyi <yurii.pavlovskyi@gmail.com>
Date:   Tue May 14 20:50:30 2019 +0200

    platform/x86: asus-wmi: Fix hwmon device cleanup
    
    The driver does not clean up the hwmon device on exit or error. To
    reproduce the bug, repeat rmmod, insmod to verify that device number
    /sys/devices/platform/asus-nb-wmi/hwmon/hwmon?? grows every time. Replace
    call for registering device with devm_* version that unregisters it
    automatically.
    
    Signed-off-by: Yurii Pavlovskyi <yurii.pavlovskyi@gmail.com>
    Reviewed-by: Daniel Drake <drake@endlessm.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 7e946ce7f66f..6a590ec4c4ef 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1428,11 +1428,12 @@ __ATTRIBUTE_GROUPS(hwmon_attribute);
 
 static int asus_wmi_hwmon_init(struct asus_wmi *asus)
 {
+	struct device *dev = &asus->platform_device->dev;
 	struct device *hwmon;
 
-	hwmon = hwmon_device_register_with_groups(&asus->platform_device->dev,
-						  "asus", asus,
-						  hwmon_attribute_groups);
+	hwmon = devm_hwmon_device_register_with_groups(dev, "asus", asus,
+			hwmon_attribute_groups);
+
 	if (IS_ERR(hwmon)) {
 		pr_err("Could not register asus hwmon device\n");
 		return PTR_ERR(hwmon);

commit d2785d37ed6fdceb2d8d17058f09577dadf3e592
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jun 12 14:12:52 2019 +0200

    platform/x86: asus-wmi: no need to check return value of debugfs_create functions
    
    When calling debugfs functions, there is no need to ever check the
    return value.  The function can work or not, but the code logic should
    never do something different based on this.
    
    Cc: Corentin Chary <corentin.chary@gmail.com>
    Cc: Darren Hart <dvhart@infradead.org>
    Cc: Andy Shevchenko <andy@infradead.org>
    Cc: acpi4asus-user@lists.sourceforge.net
    Cc: platform-driver-x86@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 12462726312c..7e946ce7f66f 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -2018,50 +2018,29 @@ static void asus_wmi_debugfs_exit(struct asus_wmi *asus)
 	debugfs_remove_recursive(asus->debug.root);
 }
 
-static int asus_wmi_debugfs_init(struct asus_wmi *asus)
+static void asus_wmi_debugfs_init(struct asus_wmi *asus)
 {
-	struct dentry *dent;
 	int i;
 
 	asus->debug.root = debugfs_create_dir(asus->driver->name, NULL);
-	if (!asus->debug.root) {
-		pr_err("failed to create debugfs directory\n");
-		goto error_debugfs;
-	}
 
-	dent = debugfs_create_x32("method_id", S_IRUGO | S_IWUSR,
-				  asus->debug.root, &asus->debug.method_id);
-	if (!dent)
-		goto error_debugfs;
+	debugfs_create_x32("method_id", S_IRUGO | S_IWUSR, asus->debug.root,
+			   &asus->debug.method_id);
 
-	dent = debugfs_create_x32("dev_id", S_IRUGO | S_IWUSR,
-				  asus->debug.root, &asus->debug.dev_id);
-	if (!dent)
-		goto error_debugfs;
+	debugfs_create_x32("dev_id", S_IRUGO | S_IWUSR, asus->debug.root,
+			   &asus->debug.dev_id);
 
-	dent = debugfs_create_x32("ctrl_param", S_IRUGO | S_IWUSR,
-				  asus->debug.root, &asus->debug.ctrl_param);
-	if (!dent)
-		goto error_debugfs;
+	debugfs_create_x32("ctrl_param", S_IRUGO | S_IWUSR, asus->debug.root,
+			   &asus->debug.ctrl_param);
 
 	for (i = 0; i < ARRAY_SIZE(asus_wmi_debug_files); i++) {
 		struct asus_wmi_debugfs_node *node = &asus_wmi_debug_files[i];
 
 		node->asus = asus;
-		dent = debugfs_create_file(node->name, S_IFREG | S_IRUGO,
-					   asus->debug.root, node,
-					   &asus_wmi_debugfs_io_ops);
-		if (!dent) {
-			pr_err("failed to create debug file: %s\n", node->name);
-			goto error_debugfs;
-		}
+		debugfs_create_file(node->name, S_IFREG | S_IRUGO,
+				    asus->debug.root, node,
+				    &asus_wmi_debugfs_io_ops);
 	}
-
-	return 0;
-
-error_debugfs:
-	asus_wmi_debugfs_exit(asus);
-	return -ENOMEM;
 }
 
 static int asus_wmi_fan_init(struct asus_wmi *asus)
@@ -2175,14 +2154,10 @@ static int asus_wmi_add(struct platform_device *pdev)
 		goto fail_wmi_handler;
 	}
 
-	err = asus_wmi_debugfs_init(asus);
-	if (err)
-		goto fail_debugfs;
+	asus_wmi_debugfs_init(asus);
 
 	return 0;
 
-fail_debugfs:
-	wmi_remove_notify_handler(asus->driver->event_guid);
 fail_wmi_handler:
 	asus_wmi_backlight_exit(asus);
 fail_backlight:

commit 1dd93f873d8ed8e5b228d1ae324b1f3c1e94bfa8
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Jun 12 09:02:02 2019 +0200

    platform/x86: asus-wmi: Only Tell EC the OS will handle display hotkeys from asus_nb_wmi
    
    Commit 78f3ac76d9e5 ("platform/x86: asus-wmi: Tell the EC the OS will
    handle the display off hotkey") causes the backlight to be permanently off
    on various EeePC laptop models using the eeepc-wmi driver (Asus EeePC
    1015BX, Asus EeePC 1025C).
    
    The asus_wmi_set_devstate(ASUS_WMI_DEVID_BACKLIGHT, 2, NULL) call added
    by that commit is made conditional in this commit and only enabled in
    the quirk_entry structs in the asus-nb-wmi driver fixing the broken
    display / backlight on various EeePC laptop models.
    
    Cc: Joo Paulo Rechi Vita <jprvita@endlessm.com>
    Fixes: 78f3ac76d9e5 ("platform/x86: asus-wmi: Tell the EC the OS will handle the display off hotkey")
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index f94691615881..12462726312c 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -2159,7 +2159,7 @@ static int asus_wmi_add(struct platform_device *pdev)
 		err = asus_wmi_backlight_init(asus);
 		if (err && err != -ENODEV)
 			goto fail_backlight;
-	} else
+	} else if (asus->driver->quirks->wmi_backlight_set_devstate)
 		err = asus_wmi_set_devstate(ASUS_WMI_DEVID_BACKLIGHT, 2, NULL);
 
 	if (asus_wmi_has_fnlock_key(asus)) {

commit 401fee8195d401b2b94dee57383f627050724d5b
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Jun 12 09:02:02 2019 +0200

    platform/x86: asus-wmi: Only Tell EC the OS will handle display hotkeys from asus_nb_wmi
    
    Commit 78f3ac76d9e5 ("platform/x86: asus-wmi: Tell the EC the OS will
    handle the display off hotkey") causes the backlight to be permanently off
    on various EeePC laptop models using the eeepc-wmi driver (Asus EeePC
    1015BX, Asus EeePC 1025C).
    
    The asus_wmi_set_devstate(ASUS_WMI_DEVID_BACKLIGHT, 2, NULL) call added
    by that commit is made conditional in this commit and only enabled in
    the quirk_entry structs in the asus-nb-wmi driver fixing the broken
    display / backlight on various EeePC laptop models.
    
    Cc: Joo Paulo Rechi Vita <jprvita@endlessm.com>
    Fixes: 78f3ac76d9e5 ("platform/x86: asus-wmi: Tell the EC the OS will handle the display off hotkey")
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 3e4336025e8f..9b18a184e0aa 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -2146,7 +2146,7 @@ static int asus_wmi_add(struct platform_device *pdev)
 		err = asus_wmi_backlight_init(asus);
 		if (err && err != -ENODEV)
 			goto fail_backlight;
-	} else
+	} else if (asus->driver->quirks->wmi_backlight_set_devstate)
 		err = asus_wmi_set_devstate(ASUS_WMI_DEVID_BACKLIGHT, 2, NULL);
 
 	if (asus_wmi_has_fnlock_key(asus)) {

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index f94691615881..3e4336025e8f 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Asus PC WMI hotkey driver
  *
@@ -8,20 +9,6 @@
  * Copyright (C) 2005 Miloslav Trmac <mitr@volny.cz>
  * Copyright (C) 2005 Bernhard Rosenkraenzer <bero@arklinux.org>
  * Copyright (C) 2005 Dmitry Torokhov <dtor@mail.ru>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt

commit 487579bab867e739be3d2c0064ad3af1221482c8
Author: Chris Chiu <chiu@endlessm.com>
Date:   Thu Apr 18 14:46:48 2019 +0800

    platform/x86: asus-wmi: Add fn-lock mode switch support
    
    Some of latest ASUS laptops support new fn-lock mode switching.
    This commit detect whether if the fn-lock option is enabled in
    BIOS setting, and toggle the fn-lock mode via a new WMI DEVID
    0x00100023 when the corresponding notify code captured.
    
    The ASUS fn-lock mode switch is activated by pressing Fn+Esc.
    When on, keys F1 to F12 behave as applicable, with meanings
    defined by the application being used at the time. When off,
    F1 to F12 directly triggers hardware features, well known audio
    volume up/down, brightness up/down...etc, which were triggered
    by holding down Fn key and F-keys.
    
    Because there's no way to retrieve the fn-lock mode via existing
    WMI methods per ASUS spec, driver need to initialize and keep the
    fn-lock mode by itself.
    
    Signed-off-by: Chris Chiu <chiu@endlessm.com>
    Reviewed-by: Daniel Drake <drake@endlessm.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index ee1fa93708ec..f94691615881 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -66,10 +66,13 @@ MODULE_LICENSE("GPL");
 #define NOTIFY_BRNUP_MAX		0x1f
 #define NOTIFY_BRNDOWN_MIN		0x20
 #define NOTIFY_BRNDOWN_MAX		0x2e
+#define NOTIFY_FNLOCK_TOGGLE		0x4e
 #define NOTIFY_KBD_BRTUP		0xc4
 #define NOTIFY_KBD_BRTDWN		0xc5
 #define NOTIFY_KBD_BRTTOGGLE		0xc7
 
+#define ASUS_WMI_FNLOCK_BIOS_DISABLED	BIT(0)
+
 #define ASUS_FAN_DESC			"cpu_fan"
 #define ASUS_FAN_MFUN			0x13
 #define ASUS_FAN_SFUN_READ		0x06
@@ -177,6 +180,8 @@ struct asus_wmi {
 	struct workqueue_struct *hotplug_workqueue;
 	struct work_struct hotplug_work;
 
+	bool fnlock_locked;
+
 	struct asus_wmi_debug debug;
 
 	struct asus_wmi_driver *driver;
@@ -1619,6 +1624,23 @@ static int is_display_toggle(int code)
 	return 0;
 }
 
+static bool asus_wmi_has_fnlock_key(struct asus_wmi *asus)
+{
+	u32 result;
+
+	asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_FNLOCK, &result);
+
+	return (result & ASUS_WMI_DSTS_PRESENCE_BIT) &&
+		!(result & ASUS_WMI_FNLOCK_BIOS_DISABLED);
+}
+
+static void asus_wmi_fnlock_update(struct asus_wmi *asus)
+{
+	int mode = asus->fnlock_locked;
+
+	asus_wmi_set_devstate(ASUS_WMI_DEVID_FNLOCK, mode, NULL);
+}
+
 static void asus_wmi_notify(u32 value, void *context)
 {
 	struct asus_wmi *asus = context;
@@ -1680,6 +1702,12 @@ static void asus_wmi_notify(u32 value, void *context)
 		goto exit;
 	}
 
+	if (code == NOTIFY_FNLOCK_TOGGLE) {
+		asus->fnlock_locked = !asus->fnlock_locked;
+		asus_wmi_fnlock_update(asus);
+		goto exit;
+	}
+
 	if (is_display_toggle(code) &&
 	    asus->driver->quirks->no_display_toggle)
 		goto exit;
@@ -2134,6 +2162,11 @@ static int asus_wmi_add(struct platform_device *pdev)
 	} else
 		err = asus_wmi_set_devstate(ASUS_WMI_DEVID_BACKLIGHT, 2, NULL);
 
+	if (asus_wmi_has_fnlock_key(asus)) {
+		asus->fnlock_locked = true;
+		asus_wmi_fnlock_update(asus);
+	}
+
 	status = wmi_install_notify_handler(asus->driver->event_guid,
 					    asus_wmi_notify, asus);
 	if (ACPI_FAILURE(status)) {
@@ -2213,6 +2246,8 @@ static int asus_hotk_resume(struct device *device)
 	if (!IS_ERR_OR_NULL(asus->kbd_led.dev))
 		kbd_led_update(asus);
 
+	if (asus_wmi_has_fnlock_key(asus))
+		asus_wmi_fnlock_update(asus);
 	return 0;
 }
 
@@ -2249,6 +2284,8 @@ static int asus_hotk_restore(struct device *device)
 	if (!IS_ERR_OR_NULL(asus->kbd_led.dev))
 		kbd_led_update(asus);
 
+	if (asus_wmi_has_fnlock_key(asus))
+		asus_wmi_fnlock_update(asus);
 	return 0;
 }
 

commit c994611aca361fa1ac39e6b2b36837c07610e467
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Mon Jan 21 14:24:36 2019 +0100

    platform/x86: asus-wmi: Allow loading on systems without the Asus Management GUID
    
    hid-asus depends on asus-wmi through the asus_wmi_evaluate_method. Before
    this commit asus-wmi, and thus hid-asus, could not be loaded on non-Asus
    systems. This breaks using Asus bluetooth keyboards such as the Asus
    T100CHI keyboard with non Asus systems.
    
    This commit fixes this by allowing asus-wmi to load on systems without the
    Asus Management GUID.
    
    This is safe to do since all asus-wmi sub drivers use
    asus_wmi_register_driver which also checks for the GUID.
    
    This commit also improves the error messages in asus_wmi_register_driver
    to include "ASUS" in their description to make them more clear. This is
    important since we now rely on those errors when loaded on systems without
    the Asus Management GUID.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 37b5de541270..ee1fa93708ec 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -2265,12 +2265,12 @@ static int asus_wmi_probe(struct platform_device *pdev)
 	int ret;
 
 	if (!wmi_has_guid(ASUS_WMI_MGMT_GUID)) {
-		pr_warn("Management GUID not found\n");
+		pr_warn("ASUS Management GUID not found\n");
 		return -ENODEV;
 	}
 
 	if (wdrv->event_guid && !wmi_has_guid(wdrv->event_guid)) {
-		pr_warn("Event GUID not found\n");
+		pr_warn("ASUS Event GUID not found\n");
 		return -ENODEV;
 	}
 
@@ -2320,11 +2320,6 @@ EXPORT_SYMBOL_GPL(asus_wmi_unregister_driver);
 
 static int __init asus_wmi_init(void)
 {
-	if (!wmi_has_guid(ASUS_WMI_MGMT_GUID)) {
-		pr_info("Asus Management GUID not found\n");
-		return -ENODEV;
-	}
-
 	pr_info("ASUS WMI generic driver loaded\n");
 	return 0;
 }

commit 78f3ac76d9e5219589718b9e4733bee21627b3f5
Author: Joo Paulo Rechi Vita <jprvita@gmail.com>
Date:   Wed Oct 31 17:21:26 2018 -0700

    platform/x86: asus-wmi: Tell the EC the OS will handle the display off hotkey
    
    In the past, Asus firmwares would change the panel backlight directly
    through the EC when the display off hotkey (Fn+F7) was pressed, and
    only notify the OS of such change, with 0x33 when the LCD was ON and
    0x34 when the LCD was OFF. These are currently mapped to
    KEY_DISPLAYTOGGLE and KEY_DISPLAY_OFF, respectively.
    
    Most recently the EC on Asus most machines lost ability to toggle the
    LCD backlight directly, but unless the OS informs the firmware it is
    going to handle the display toggle hotkey events, the firmware still
    tries change the brightness through the EC, to no effect. The end result
    is a long list (at Endless we counted 11) of Asus laptop models where
    the display toggle hotkey does not perform any action. Our firmware
    engineers contacts at Asus were surprised that there were still machines
    out there with the old behavior.
    
    Calling WMNB(ASUS_WMI_DEVID_BACKLIGHT==0x00050011, 2) on the _WDG device
    tells the firmware that it should let the OS handle the display toggle
    event, in which case it will simply notify the OS of a key press with
    0x35, as shown by the DSDT excerpts bellow.
    
     Scope (_SB)
     {
         (...)
    
         Device (ATKD)
         {
             (...)
    
             Name (_WDG, Buffer (0x28)
             {
                 /* 0000 */  0xD0, 0x5E, 0x84, 0x97, 0x6D, 0x4E, 0xDE, 0x11,
                 /* 0008 */  0x8A, 0x39, 0x08, 0x00, 0x20, 0x0C, 0x9A, 0x66,
                 /* 0010 */  0x4E, 0x42, 0x01, 0x02, 0x35, 0xBB, 0x3C, 0x0B,
                 /* 0018 */  0xC2, 0xE3, 0xED, 0x45, 0x91, 0xC2, 0x4C, 0x5A,
                 /* 0020 */  0x6D, 0x19, 0x5D, 0x1C, 0xFF, 0x00, 0x01, 0x08
             })
             Method (WMNB, 3, Serialized)
             {
                 CreateDWordField (Arg2, Zero, IIA0)
                 CreateDWordField (Arg2, 0x04, IIA1)
                 Local0 = (Arg1 & 0xFFFFFFFF)
    
                 (...)
    
                 If ((Local0 == 0x53564544))
                 {
                     (...)
    
                     If ((IIA0 == 0x00050011))
                     {
                         If ((IIA1 == 0x02))
                         {
                             ^^PCI0.SBRG.EC0.SPIN (0x72, One)
                             ^^PCI0.SBRG.EC0.BLCT = One
                         }
    
                         Return (One)
                     }
                 }
                 (...)
             }
             (...)
         }
         (...)
     }
     (...)
    
     Scope (_SB.PCI0.SBRG.EC0)
     {
         (...)
    
         Name (BLCT, Zero)
    
         (...)
    
         Method (_Q10, 0, NotSerialized)  // _Qxx: EC Query
         {
             If ((BLCT == Zero))
             {
                 Local0 = One
                 Local0 = RPIN (0x72)
                 Local0 ^= One
                 SPIN (0x72, Local0)
                 If (ATKP)
                 {
                     Local0 = (0x34 - Local0)
                     ^^^^ATKD.IANE (Local0)
                 }
             }
             ElseIf ((BLCT == One))
             {
                 If (ATKP)
                 {
                     ^^^^ATKD.IANE (0x35)
                 }
             }
         }
         (...)
     }
    
    Signed-off-by: Joo Paulo Rechi Vita <jprvita@endlessm.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index c285a16675ee..37b5de541270 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -2131,7 +2131,8 @@ static int asus_wmi_add(struct platform_device *pdev)
 		err = asus_wmi_backlight_init(asus);
 		if (err && err != -ENODEV)
 			goto fail_backlight;
-	}
+	} else
+		err = asus_wmi_set_devstate(ASUS_WMI_DEVID_BACKLIGHT, 2, NULL);
 
 	status = wmi_install_notify_handler(asus->driver->event_guid,
 					    asus_wmi_notify, asus);

commit eb7046e9bf466cebfcfbcdf640e41d9e3a80086c
Merge: 5b7449810ae6 3b692c55e58d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Nov 1 08:42:21 2018 -0700

    Merge tag 'platform-drivers-x86-v4.20-1' of git://git.infradead.org/linux-platform-drivers-x86
    
    Pull x86 platform driver updates from Darren Hart:
    
     - Move the Dell dcdbas and dell_rbu drivers into platform/drivers/x86
       as they are closely coupled with other drivers in this location.
    
     - Improve _init* usage for acerhdf and fix some usage issues with
       messages and module parameters.
    
     - Simplify asus-wmi by calling ACPI/WMI methods directly, eliminating
       workqueue overhead, eliminate double reporting of keyboard backlight.
    
     - Fix wake from USB failure on Bay Trail devices (intel_int0002_vgpio).
    
     - Notify intel_telemetry users when IPC1 device is not enabled.
    
     - Update various drivers with new laptop model IDs.
    
     - Update several intel drivers to use SPDX identifers and order headers
       alphabetically.
    
    * tag 'platform-drivers-x86-v4.20-1' of git://git.infradead.org/linux-platform-drivers-x86: (64 commits)
      HID: asus: only support backlight when it's not driven by WMI
      platform/x86: asus-wmi: export function for evaluating WMI methods
      platform/x86: asus-wmi: Only notify kbd LED hw_change by fn-key pressed
      platform/x86: wmi: declare device_type structure as constant
      platform/x86: ideapad: Add Y530-15ICH to no_hw_rfkill
      platform/x86: Add Intel AtomISP2 dummy / power-management driver
      platform/x86: touchscreen_dmi: Add min-x and min-y settings for various models
      platform/x86: touchscreen_dmi: Add info for the Onda V80 Plus v3 tablet
      platform/x86: touchscreen_dmi: Add info for the Trekstor Primetab T13B tablet
      platform/x86: intel_telemetry: Get rid of custom macro
      platform/x86: intel_telemetry: report debugfs failure
      MAINTAINERS: intel_telemetry: Update maintainers info
      platform/x86: Add LG Gram laptop special features driver
      platform/x86: asus-wmi: Simplify the keyboard brightness updating process
      platform/x86: touchscreen_dmi: Add info for the Trekstor Primebook C11 convertible
      platform/x86: mlx-platform: Properly use mlxplat_mlxcpld_msn201x_items
      MAINTAINERS: intel_pmc_core: Update MAINTAINERS
      firmware: dcdbas: include linux/io.h
      platform/x86: intel-wmi-thunderbolt: Add dynamic debugging
      platform/x86: intel-wmi-thunderbolt: Convert to use SPDX identifier
      ...

commit ffb6ce7086ee2d68d8d6d987882f1c5e923fee7e
Author: Daniel Drake <drake@endlessm.com>
Date:   Tue Oct 9 14:40:55 2018 +0800

    platform/x86: asus-wmi: export function for evaluating WMI methods
    
    Export asus_wmi_evaluate_method() and related headers for use by other
    drivers.
    
    hid-asus is going to use this to avoid advertising that it has a keyboard
    backlight when the keyboard backlight is controlled via WMI.
    
    Signed-off-by: Daniel Drake <drake@endlessm.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index a805227b31e1..b52b192a4f16 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -43,6 +43,7 @@
 #include <linux/hwmon-sysfs.h>
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
+#include <linux/platform_data/x86/asus-wmi.h>
 #include <linux/platform_device.h>
 #include <linux/thermal.h>
 #include <linux/acpi.h>
@@ -69,89 +70,6 @@ MODULE_LICENSE("GPL");
 #define NOTIFY_KBD_BRTDWN		0xc5
 #define NOTIFY_KBD_BRTTOGGLE		0xc7
 
-/* WMI Methods */
-#define ASUS_WMI_METHODID_SPEC	        0x43455053 /* BIOS SPECification */
-#define ASUS_WMI_METHODID_SFBD		0x44424653 /* Set First Boot Device */
-#define ASUS_WMI_METHODID_GLCD		0x44434C47 /* Get LCD status */
-#define ASUS_WMI_METHODID_GPID		0x44495047 /* Get Panel ID?? (Resol) */
-#define ASUS_WMI_METHODID_QMOD		0x444F4D51 /* Quiet MODe */
-#define ASUS_WMI_METHODID_SPLV		0x4C425053 /* Set Panel Light Value */
-#define ASUS_WMI_METHODID_AGFN		0x4E464741 /* FaN? */
-#define ASUS_WMI_METHODID_SFUN		0x4E554653 /* FUNCtionalities */
-#define ASUS_WMI_METHODID_SDSP		0x50534453 /* Set DiSPlay output */
-#define ASUS_WMI_METHODID_GDSP		0x50534447 /* Get DiSPlay output */
-#define ASUS_WMI_METHODID_DEVP		0x50564544 /* DEVice Policy */
-#define ASUS_WMI_METHODID_OSVR		0x5256534F /* OS VeRsion */
-#define ASUS_WMI_METHODID_DSTS		0x53544344 /* Device STatuS */
-#define ASUS_WMI_METHODID_DSTS2		0x53545344 /* Device STatuS #2*/
-#define ASUS_WMI_METHODID_BSTS		0x53545342 /* Bios STatuS ? */
-#define ASUS_WMI_METHODID_DEVS		0x53564544 /* DEVice Set */
-#define ASUS_WMI_METHODID_CFVS		0x53564643 /* CPU Frequency Volt Set */
-#define ASUS_WMI_METHODID_KBFT		0x5446424B /* KeyBoard FilTer */
-#define ASUS_WMI_METHODID_INIT		0x54494E49 /* INITialize */
-#define ASUS_WMI_METHODID_HKEY		0x59454B48 /* Hot KEY ?? */
-
-#define ASUS_WMI_UNSUPPORTED_METHOD	0xFFFFFFFE
-
-/* Wireless */
-#define ASUS_WMI_DEVID_HW_SWITCH	0x00010001
-#define ASUS_WMI_DEVID_WIRELESS_LED	0x00010002
-#define ASUS_WMI_DEVID_CWAP		0x00010003
-#define ASUS_WMI_DEVID_WLAN		0x00010011
-#define ASUS_WMI_DEVID_WLAN_LED		0x00010012
-#define ASUS_WMI_DEVID_BLUETOOTH	0x00010013
-#define ASUS_WMI_DEVID_GPS		0x00010015
-#define ASUS_WMI_DEVID_WIMAX		0x00010017
-#define ASUS_WMI_DEVID_WWAN3G		0x00010019
-#define ASUS_WMI_DEVID_UWB		0x00010021
-
-/* Leds */
-/* 0x000200XX and 0x000400XX */
-#define ASUS_WMI_DEVID_LED1		0x00020011
-#define ASUS_WMI_DEVID_LED2		0x00020012
-#define ASUS_WMI_DEVID_LED3		0x00020013
-#define ASUS_WMI_DEVID_LED4		0x00020014
-#define ASUS_WMI_DEVID_LED5		0x00020015
-#define ASUS_WMI_DEVID_LED6		0x00020016
-
-/* Backlight and Brightness */
-#define ASUS_WMI_DEVID_ALS_ENABLE	0x00050001 /* Ambient Light Sensor */
-#define ASUS_WMI_DEVID_BACKLIGHT	0x00050011
-#define ASUS_WMI_DEVID_BRIGHTNESS	0x00050012
-#define ASUS_WMI_DEVID_KBD_BACKLIGHT	0x00050021
-#define ASUS_WMI_DEVID_LIGHT_SENSOR	0x00050022 /* ?? */
-#define ASUS_WMI_DEVID_LIGHTBAR		0x00050025
-
-/* Misc */
-#define ASUS_WMI_DEVID_CAMERA		0x00060013
-
-/* Storage */
-#define ASUS_WMI_DEVID_CARDREADER	0x00080013
-
-/* Input */
-#define ASUS_WMI_DEVID_TOUCHPAD		0x00100011
-#define ASUS_WMI_DEVID_TOUCHPAD_LED	0x00100012
-
-/* Fan, Thermal */
-#define ASUS_WMI_DEVID_THERMAL_CTRL	0x00110011
-#define ASUS_WMI_DEVID_FAN_CTRL		0x00110012
-
-/* Power */
-#define ASUS_WMI_DEVID_PROCESSOR_STATE	0x00120012
-
-/* Deep S3 / Resume on LID open */
-#define ASUS_WMI_DEVID_LID_RESUME	0x00120031
-
-/* DSTS masks */
-#define ASUS_WMI_DSTS_STATUS_BIT	0x00000001
-#define ASUS_WMI_DSTS_UNKNOWN_BIT	0x00000002
-#define ASUS_WMI_DSTS_PRESENCE_BIT	0x00010000
-#define ASUS_WMI_DSTS_USER_BIT		0x00020000
-#define ASUS_WMI_DSTS_BIOS_BIT		0x00040000
-#define ASUS_WMI_DSTS_BRIGHTNESS_MASK	0x000000FF
-#define ASUS_WMI_DSTS_MAX_BRIGTH_MASK	0x0000FF00
-#define ASUS_WMI_DSTS_LIGHTBAR_MASK	0x0000000F
-
 #define ASUS_FAN_DESC			"cpu_fan"
 #define ASUS_FAN_MFUN			0x13
 #define ASUS_FAN_SFUN_READ		0x06
@@ -301,8 +219,7 @@ static void asus_wmi_input_exit(struct asus_wmi *asus)
 	asus->inputdev = NULL;
 }
 
-static int asus_wmi_evaluate_method(u32 method_id, u32 arg0, u32 arg1,
-				    u32 *retval)
+int asus_wmi_evaluate_method(u32 method_id, u32 arg0, u32 arg1, u32 *retval)
 {
 	struct bios_args args = {
 		.arg0 = arg0,
@@ -338,6 +255,7 @@ static int asus_wmi_evaluate_method(u32 method_id, u32 arg0, u32 arg1,
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(asus_wmi_evaluate_method);
 
 static int asus_wmi_evaluate_method_agfn(const struct acpi_buffer args)
 {

commit 29f6eb533c3be9b9c74cdeacc7bf14d927a8adb4
Author: Jian-Hong Pan <jian-hong@endlessm.com>
Date:   Mon Oct 22 18:00:04 2018 +0800

    platform/x86: asus-wmi: Only notify kbd LED hw_change by fn-key pressed
    
    Since commit dbb3d78f61ba ("platform/x86: asus-wmi: Call led hw_changed
    API on kbd brightness change"), asus-wmi directly changes the keyboard
    LED brightness when the keyboard brightness keys are pressed,
    raising the appropriate notification.
    
    However, this notification was unintentionally also being raised during
    boot and resume from suspend. This was resulting in userspace showing
    the keyboard LED OSD on resume for no good reason.
    
    Move the keyboard LED brightness changed notification
    from kbd_led_update to the new kbd_led_set_by_kbd function which is only
    called from the keyboard brightness function keys codepath.
    
    Signed-off-by: Jian-Hong Pan <jian-hong@endlessm.com>
    Signed-off-by: Daniel Drake <drake@endlessm.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 9441cce636e6..a805227b31e1 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -467,7 +467,6 @@ static void kbd_led_update(struct asus_wmi *asus)
 		ctrl_param = 0x80 | (asus->kbd_led_wk & 0x7F);
 
 	asus_wmi_set_devstate(ASUS_WMI_DEVID_KBD_BACKLIGHT, ctrl_param, NULL);
-	led_classdev_notify_brightness_hw_changed(&asus->kbd_led, asus->kbd_led_wk);
 }
 
 static int kbd_led_read(struct asus_wmi *asus, int *level, int *env)
@@ -521,6 +520,14 @@ static void kbd_led_set(struct led_classdev *led_cdev,
 	do_kbd_led_set(led_cdev, value);
 }
 
+static void kbd_led_set_by_kbd(struct asus_wmi *asus, enum led_brightness value)
+{
+	struct led_classdev *led_cdev = &asus->kbd_led;
+
+	do_kbd_led_set(led_cdev, value);
+	led_classdev_notify_brightness_hw_changed(led_cdev, asus->kbd_led_wk);
+}
+
 static enum led_brightness kbd_led_get(struct led_classdev *led_cdev)
 {
 	struct asus_wmi *asus;
@@ -1759,18 +1766,18 @@ static void asus_wmi_notify(u32 value, void *context)
 	}
 
 	if (code == NOTIFY_KBD_BRTUP) {
-		do_kbd_led_set(&asus->kbd_led, asus->kbd_led_wk + 1);
+		kbd_led_set_by_kbd(asus, asus->kbd_led_wk + 1);
 		goto exit;
 	}
 	if (code == NOTIFY_KBD_BRTDWN) {
-		do_kbd_led_set(&asus->kbd_led, asus->kbd_led_wk - 1);
+		kbd_led_set_by_kbd(asus, asus->kbd_led_wk - 1);
 		goto exit;
 	}
 	if (code == NOTIFY_KBD_BRTTOGGLE) {
 		if (asus->kbd_led_wk == asus->kbd_led.max_brightness)
-			do_kbd_led_set(&asus->kbd_led, 0);
+			kbd_led_set_by_kbd(asus, 0);
 		else
-			do_kbd_led_set(&asus->kbd_led, asus->kbd_led_wk + 1);
+			kbd_led_set_by_kbd(asus, asus->kbd_led_wk + 1);
 		goto exit;
 	}
 

commit 9fe44fc98ce45fe42004be9fd282775030c6b147
Author: Jian-Hong Pan <jian-hong@endlessm.com>
Date:   Thu Sep 27 16:50:09 2018 +0800

    platform/x86: asus-wmi: Simplify the keyboard brightness updating process
    
    The original asus-wmi queues a work which calls the ACPI/WMI methods to
    update the keyboard LED brightness.  Similar drivers - acer-wmi,
    dell-wmi-led just call the ACPI/WMI methods directly without workqueues.
    
    This patch simplifies the keyboard brightness updating process which
    calls the kbd_led_update function directly without workqueue in
    asus-wmi.
    
    Signed-off-by: Jian-Hong Pan <jian-hong@endlessm.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 2d6e272315a8..9441cce636e6 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -239,7 +239,6 @@ struct asus_wmi {
 	int lightbar_led_wk;
 	struct workqueue_struct *led_workqueue;
 	struct work_struct tpd_led_work;
-	struct work_struct kbd_led_work;
 	struct work_struct wlan_led_work;
 	struct work_struct lightbar_led_work;
 
@@ -456,12 +455,9 @@ static enum led_brightness tpd_led_get(struct led_classdev *led_cdev)
 	return read_tpd_led_state(asus);
 }
 
-static void kbd_led_update(struct work_struct *work)
+static void kbd_led_update(struct asus_wmi *asus)
 {
 	int ctrl_param = 0;
-	struct asus_wmi *asus;
-
-	asus = container_of(work, struct asus_wmi, kbd_led_work);
 
 	/*
 	 * bits 0-2: level
@@ -516,7 +512,7 @@ static void do_kbd_led_set(struct led_classdev *led_cdev, int value)
 		value = 0;
 
 	asus->kbd_led_wk = value;
-	queue_work(asus->led_workqueue, &asus->kbd_led_work);
+	kbd_led_update(asus);
 }
 
 static void kbd_led_set(struct led_classdev *led_cdev,
@@ -671,8 +667,6 @@ static int asus_wmi_led_init(struct asus_wmi *asus)
 
 	led_val = kbd_led_read(asus, NULL, NULL);
 	if (led_val >= 0) {
-		INIT_WORK(&asus->kbd_led_work, kbd_led_update);
-
 		asus->kbd_led_wk = led_val;
 		asus->kbd_led.name = "asus::kbd_backlight";
 		asus->kbd_led.flags = LED_BRIGHT_HW_CHANGED;
@@ -2310,7 +2304,7 @@ static int asus_hotk_resume(struct device *device)
 	struct asus_wmi *asus = dev_get_drvdata(device);
 
 	if (!IS_ERR_OR_NULL(asus->kbd_led.dev))
-		queue_work(asus->led_workqueue, &asus->kbd_led_work);
+		kbd_led_update(asus);
 
 	return 0;
 }
@@ -2346,7 +2340,7 @@ static int asus_hotk_restore(struct device *device)
 		rfkill_set_sw_state(asus->uwb.rfkill, bl);
 	}
 	if (!IS_ERR_OR_NULL(asus->kbd_led.dev))
-		queue_work(asus->led_workqueue, &asus->kbd_led_work);
+		kbd_led_update(asus);
 
 	return 0;
 }

commit 125450f814418b9f889c9885831467d1b2e25a7d
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sat Sep 8 09:59:01 2018 +0200

    PCI: hotplug: Embed hotplug_slot
    
    When the PCI hotplug core and its first user, cpqphp, were introduced in
    February 2002 with historic commit a8a2069f432c, cpqphp allocated a slot
    struct for its internal use plus a hotplug_slot struct to be registered
    with the hotplug core and linked the two with pointers:
    https://git.kernel.org/tglx/history/c/a8a2069f432c
    
    Nowadays, the predominant pattern in the tree is to embed ("subclass")
    such structures in one another and cast to the containing struct with
    container_of().  But it wasn't until July 2002 that container_of() was
    introduced with historic commit ec4f214232cf:
    https://git.kernel.org/tglx/history/c/ec4f214232cf
    
    pnv_php, introduced in 2016, did the right thing and embedded struct
    hotplug_slot in its internal struct pnv_php_slot, but all other drivers
    cargo-culted cpqphp's design and linked separate structs with pointers.
    
    Embedding structs is preferrable to linking them with pointers because
    it requires fewer allocations, thereby reducing overhead and simplifying
    error paths.  Casting an embedded struct to the containing struct
    becomes a cheap subtraction rather than a dereference.  And having fewer
    pointers reduces the risk of them pointing nowhere either accidentally
    or due to an attack.
    
    Convert all drivers to embed struct hotplug_slot in their internal slot
    struct.  The "private" pointer in struct hotplug_slot thereby becomes
    unused, so drop it.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>  # drivers/pci/hotplug/rpa*
    Acked-by: Sebastian Ott <sebott@linux.ibm.com>        # drivers/pci/hotplug/s390*
    Acked-by: Andy Shevchenko <andy.shevchenko@gmail.com> # drivers/platform/x86
    Cc: Len Brown <lenb@kernel.org>
    Cc: Scott Murray <scott@spiteful.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Oliver OHalloran <oliveroh@au1.ibm.com>
    Cc: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Cc: Gerald Schaefer <gerald.schaefer@de.ibm.com>
    Cc: Corentin Chary <corentin.chary@gmail.com>
    Cc: Darren Hart <dvhart@infradead.org>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 019b037319e3..93ee2d5466f8 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -254,7 +254,7 @@ struct asus_wmi {
 	int asus_hwmon_num_fans;
 	int asus_hwmon_pwm;
 
-	struct hotplug_slot *hotplug_slot;
+	struct hotplug_slot hotplug_slot;
 	struct mutex hotplug_lock;
 	struct mutex wmi_lock;
 	struct workqueue_struct *hotplug_workqueue;
@@ -753,7 +753,7 @@ static void asus_rfkill_hotplug(struct asus_wmi *asus)
 	if (asus->wlan.rfkill)
 		rfkill_set_sw_state(asus->wlan.rfkill, blocked);
 
-	if (asus->hotplug_slot) {
+	if (asus->hotplug_slot.ops) {
 		bus = pci_find_bus(0, 1);
 		if (!bus) {
 			pr_warn("Unable to find PCI bus 1?\n");
@@ -858,7 +858,8 @@ static void asus_unregister_rfkill_notifier(struct asus_wmi *asus, char *node)
 static int asus_get_adapter_status(struct hotplug_slot *hotplug_slot,
 				   u8 *value)
 {
-	struct asus_wmi *asus = hotplug_slot->private;
+	struct asus_wmi *asus = container_of(hotplug_slot,
+					     struct asus_wmi, hotplug_slot);
 	int result = asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_WLAN);
 
 	if (result < 0)
@@ -898,14 +899,9 @@ static int asus_setup_pci_hotplug(struct asus_wmi *asus)
 
 	INIT_WORK(&asus->hotplug_work, asus_hotplug_work);
 
-	asus->hotplug_slot = kzalloc(sizeof(struct hotplug_slot), GFP_KERNEL);
-	if (!asus->hotplug_slot)
-		goto error_slot;
+	asus->hotplug_slot.ops = &asus_hotplug_slot_ops;
 
-	asus->hotplug_slot->private = asus;
-	asus->hotplug_slot->ops = &asus_hotplug_slot_ops;
-
-	ret = pci_hp_register(asus->hotplug_slot, bus, 0, "asus-wifi");
+	ret = pci_hp_register(&asus->hotplug_slot, bus, 0, "asus-wifi");
 	if (ret) {
 		pr_err("Unable to register hotplug slot - %d\n", ret);
 		goto error_register;
@@ -914,9 +910,7 @@ static int asus_setup_pci_hotplug(struct asus_wmi *asus)
 	return 0;
 
 error_register:
-	kfree(asus->hotplug_slot);
-	asus->hotplug_slot = NULL;
-error_slot:
+	asus->hotplug_slot.ops = NULL;
 	destroy_workqueue(asus->hotplug_workqueue);
 error_workqueue:
 	return ret;
@@ -1044,10 +1038,8 @@ static void asus_wmi_rfkill_exit(struct asus_wmi *asus)
 	 * asus_unregister_rfkill_notifier()
 	 */
 	asus_rfkill_hotplug(asus);
-	if (asus->hotplug_slot) {
-		pci_hp_deregister(asus->hotplug_slot);
-		kfree(asus->hotplug_slot);
-	}
+	if (asus->hotplug_slot.ops)
+		pci_hp_deregister(&asus->hotplug_slot);
 	if (asus->hotplug_workqueue)
 		destroy_workqueue(asus->hotplug_workqueue);
 

commit a7da21613c4efcd4cc0235e6a30bec96ae47c619
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sat Sep 8 09:59:01 2018 +0200

    PCI: hotplug: Drop hotplug_slot_info
    
    Ever since the PCI hotplug core was introduced in 2002, drivers had to
    allocate and register a struct hotplug_slot_info for every slot:
    https://git.kernel.org/tglx/history/c/a8a2069f432c
    
    Apparently the idea was that drivers furnish the hotplug core with an
    up-to-date card presence status, power status, latch status and
    attention indicator status as well as notify the hotplug core of changes
    thereof.  However only 4 out of 12 hotplug drivers bother to notify the
    hotplug core with pci_hp_change_slot_info() and the hotplug core never
    made any use of the information:  There is just a single macro in
    pci_hotplug_core.c, GET_STATUS(), which uses the hotplug_slot_info if
    the driver lacks the corresponding callback in hotplug_slot_ops.  The
    macro is called when the user reads the attribute via sysfs.
    
    Now, if the callback isn't defined, the attribute isn't exposed in sysfs
    in the first place (see e.g. has_power_file()).  There are only two
    situations when the hotplug_slot_info would actually be accessed:
    
    * If the driver defines ->enable_slot or ->disable_slot but not
      ->get_power_status.
    
    * If the driver defines ->set_attention_status but not
      ->get_attention_status.
    
    There is no driver doing the former and just a single driver doing the
    latter, namely pnv_php.c.  Amend it with a ->get_attention_status
    callback.  With that, the hotplug_slot_info becomes completely unused by
    the PCI hotplug core.  But a few drivers use it internally as a cache:
    
    cpcihp uses it to cache the latch_status and adapter_status.
    cpqhp uses it to cache the adapter_status.
    pnv_php and rpaphp use it to cache the attention_status.
    shpchp uses it to cache all four values.
    
    Amend these drivers to cache the information in their private slot
    struct.  shpchp's slot struct already contains members to cache the
    power_status and adapter_status, so additional members are only needed
    for the other two values.  In the case of cpqphp, the cached value is
    only accessed in a single place, so instead of caching it, read the
    current value from the hardware.
    
    Caution:  acpiphp, cpci, cpqhp, shpchp, asus-wmi and eeepc-laptop
    populate the hotplug_slot_info with initial values on probe.  That code
    is herewith removed.  There is a theoretical chance that the code has
    side effects without which the driver fails to function, e.g. if the
    ACPI method to read the adapter status needs to be executed at least
    once on probe.  That seems unlikely to me, still maintainers should
    review the changes carefully for this possibility.
    
    Rafael adds: "I'm not aware of any case in which it will break anything,
    [...] but if that happens, it may be necessary to add the execution of
    the control methods in question directly to the initialization part."
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>  # drivers/pci/hotplug/rpa*
    Acked-by: Sebastian Ott <sebott@linux.ibm.com>        # drivers/pci/hotplug/s390*
    Acked-by: Andy Shevchenko <andy.shevchenko@gmail.com> # drivers/platform/x86
    Cc: Len Brown <lenb@kernel.org>
    Cc: Scott Murray <scott@spiteful.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Oliver OHalloran <oliveroh@au1.ibm.com>
    Cc: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Cc: Gerald Schaefer <gerald.schaefer@de.ibm.com>
    Cc: Corentin Chary <corentin.chary@gmail.com>
    Cc: Darren Hart <dvhart@infradead.org>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index a8aa2eadfd82..019b037319e3 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -902,15 +902,8 @@ static int asus_setup_pci_hotplug(struct asus_wmi *asus)
 	if (!asus->hotplug_slot)
 		goto error_slot;
 
-	asus->hotplug_slot->info = kzalloc(sizeof(struct hotplug_slot_info),
-					   GFP_KERNEL);
-	if (!asus->hotplug_slot->info)
-		goto error_info;
-
 	asus->hotplug_slot->private = asus;
 	asus->hotplug_slot->ops = &asus_hotplug_slot_ops;
-	asus_get_adapter_status(asus->hotplug_slot,
-				&asus->hotplug_slot->info->adapter_status);
 
 	ret = pci_hp_register(asus->hotplug_slot, bus, 0, "asus-wifi");
 	if (ret) {
@@ -921,8 +914,6 @@ static int asus_setup_pci_hotplug(struct asus_wmi *asus)
 	return 0;
 
 error_register:
-	kfree(asus->hotplug_slot->info);
-error_info:
 	kfree(asus->hotplug_slot);
 	asus->hotplug_slot = NULL;
 error_slot:
@@ -1055,7 +1046,6 @@ static void asus_wmi_rfkill_exit(struct asus_wmi *asus)
 	asus_rfkill_hotplug(asus);
 	if (asus->hotplug_slot) {
 		pci_hp_deregister(asus->hotplug_slot);
-		kfree(asus->hotplug_slot->info);
 		kfree(asus->hotplug_slot);
 	}
 	if (asus->hotplug_workqueue)

commit 81c4b5bf30de01a0f6b43ccaa1d220f4a0a5d99c
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sat Sep 8 09:59:01 2018 +0200

    PCI: hotplug: Constify hotplug_slot_ops
    
    Hotplug drivers cannot declare their hotplug_slot_ops const, making them
    attractive targets for attackers, because upon registration of a hotplug
    slot, __pci_hp_initialize() writes to the "owner" and "mod_name" members
    in that struct.
    
    Fix by moving these members to struct hotplug_slot and constify every
    driver's hotplug_slot_ops except for pciehp.
    
    pciehp constructs its hotplug_slot_ops at runtime based on the PCIe
    port's capabilities, hence cannot declare them const.  It can be
    converted to __write_rarely once that's mainlined:
    http://www.openwall.com/lists/kernel-hardening/2016/11/16/3
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>  # drivers/pci/hotplug/rpa*
    Acked-by: Andy Shevchenko <andy.shevchenko@gmail.com> # drivers/platform/x86
    Cc: Len Brown <lenb@kernel.org>
    Cc: Scott Murray <scott@spiteful.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Oliver OHalloran <oliveroh@au1.ibm.com>
    Cc: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Cc: Sebastian Ott <sebott@linux.vnet.ibm.com>
    Cc: Gerald Schaefer <gerald.schaefer@de.ibm.com>
    Cc: Corentin Chary <corentin.chary@gmail.com>
    Cc: Darren Hart <dvhart@infradead.org>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 2d6e272315a8..a8aa2eadfd82 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -868,8 +868,7 @@ static int asus_get_adapter_status(struct hotplug_slot *hotplug_slot,
 	return 0;
 }
 
-static struct hotplug_slot_ops asus_hotplug_slot_ops = {
-	.owner = THIS_MODULE,
+static const struct hotplug_slot_ops asus_hotplug_slot_ops = {
 	.get_adapter_status = asus_get_adapter_status,
 	.get_power_status = asus_get_adapter_status,
 };

commit 899fbc33fd775b9dfa363db28f322272920a2196
Merge: 2edd73a42e0e 9bd5196e5cf7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 22 14:14:15 2018 -0700

    Merge tag 'platform-drivers-x86-v4.19-1' of git://git.infradead.org/linux-platform-drivers-x86
    
    Pull x86 platform driver updates from Andy Shevchenko:
    
     - The driver for Silead touchscreen configurations has been renamed
       from silead_dmi to touchscreen_dmi since it starts supporting other
       touchscreens which require some DMI quirks
    
       It also gets expanded to cover cases for Chuwi Vi10, ONDA V891W,
       Connect Tablet 9, Onda V820w, and Cube KNote i1101 tablets.
    
     - Another bunch of changes is related to Mellanox platform code to
       allow user space to communicate with Mellanox for system control and
       monitoring purposes. The driver notifies user on hotplug device
       signal receiving.
    
     - ASUS WMI drivers recognize lid flip action on UX360, and correctly
       toggles airplane mode LED. In addition the keyboard backlight toggle
       gets support.
    
     - ThinkPad ACPI driver enables support for calculator key (on at least
       P52). It also has been fixed to support three characters model
       designators, which are used for modern laptops. Earlier the battery,
       marked as BAT1, on ThinkPad laptops has not been configured properly,
       which is fixed. On the opposite the multi-battery configurations now
       probed correctly.
    
     - Dell SMBIOS driver starts working on some Dell servers which do not
       support token interface. The regression with backlight detection has
       also been fixed. In order to support dock mode on some laptops, Intel
       virtual button driver has been fixed. The last but not least is the
       fix to Intel HID driver due to changes in Dell systems that prevented
       to use power button.
    
    * tag 'platform-drivers-x86-v4.19-1' of git://git.infradead.org/linux-platform-drivers-x86: (47 commits)
      platform/x86: acer-wmi: Silence "unsupported" message a bit
      platform/x86: intel_punit_ipc: fix build errors
      platform/x86: ideapad: Add Y520-15IKBM and Y720-15IKBM to no_hw_rfkill
      platform/x86: asus-nb-wmi: Add keymap entry for lid flip action on UX360
      platform/x86: acer-wmi: refactor function has_cap
      platform/x86: thinkpad_acpi: Fix multi-battery bug
      platform/x86: thinkpad_acpi: extend battery quirk coverage
      platform/x86: touchscreen_dmi: Add info for the Cube KNote i1101 tablet
      platform/x86: mlx-platform: Fix copy-paste error in mlxplat_init()
      platform/x86: mlx-platform: Remove unused define
      platform/x86: mlx-platform: Change mlxreg-io configuration for MSN274x systems
      Documentation/ABI: Add new attribute for mlxreg-io sysfs interfaces
      platform/x86: mlx-platform: Allow mlxreg-io driver activation for more systems
      platform/x86: mlx-platform: Add ASIC hotplug device configuration
      platform/mellanox: mlxreg-hotplug: Add hotplug hwmon uevent notification
      platform/mellanox: mlxreg-hotplug: Improve mechanism of ASIC health discovery
      platform/x86: mlx-platform: Add mlxreg-fan platform driver activation
      platform/x86: dell-laptop: Fix backlight detection
      platform/x86: toshiba_acpi: Fix defined but not used build warnings
      platform/x86: thinkpad_acpi: Support battery quirk
      ...

commit 51bbf9bee34ff5d4006d266f24a54dc9c1669eb5
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Jul 19 17:27:43 2018 -0500

    PCI: hotplug: Demidlayer registration with the core
    
    When a hotplug driver calls pci_hp_register(), all steps necessary for
    registration are carried out in one go, including creation of a kobject
    and addition to sysfs.  That's a problem for pciehp once it's converted
    to enable/disable the slot exclusively from the IRQ thread:  The thread
    needs to be spawned after creation of the kobject (because it uses the
    kobject's name), but before addition to sysfs (because it will handle
    enable/disable requests submitted via sysfs).
    
    pci_hp_deregister() does offer a ->release callback that's invoked
    after deletion from sysfs and before destruction of the kobject.  But
    because pci_hp_register() doesn't offer a counterpart, hotplug drivers'
    ->probe and ->remove code becomes asymmetric, which is error prone
    as recently discovered use-after-free bugs in pciehp's ->remove hook
    have shown.
    
    In a sense, this appears to be a case of the midlayer antipattern:
    
       "The core thesis of the "midlayer mistake" is that midlayers are
        bad and should not exist.  That common functionality which it is
        so tempting to put in a midlayer should instead be provided as
        library routines which can [be] used, augmented, or ignored by
        each bottom level driver independently.  Thus every subsystem
        that supports multiple implementations (or drivers) should
        provide a very thin top layer which calls directly into the
        bottom layer drivers, and a rich library of support code that
        eases the implementation of those drivers.  This library is
        available to, but not forced upon, those drivers."
            --  Neil Brown (2009), https://lwn.net/Articles/336262/
    
    The presence of midlayer traits in the PCI hotplug core might be ascribed
    to its age:  When it was introduced in February 2002, the blessings of a
    library approach might not have been well known:
    https://git.kernel.org/tglx/history/c/a8a2069f432c
    
    For comparison, the driver core does offer split functions for creating
    a kobject (device_initialize()) and addition to sysfs (device_add()) as
    an alternative to carrying out everything at once (device_register()).
    This was introduced in October 2002:
    https://git.kernel.org/tglx/history/c/8b290eb19962
    
    The odd ->release callback in the PCI hotplug core was added in 2003:
    https://git.kernel.org/tglx/history/c/69f8d663b595
    
    Clearly, a library approach would not force every hotplug driver to
    implement a ->release callback, but rather allow the driver to remove
    the sysfs files, release its data structures and finally destroy the
    kobject.  Alternatively, a driver may choose to remove everything with
    pci_hp_deregister(), then release its data structures.
    
    To this end, offer drivers pci_hp_initialize() and pci_hp_add() as a
    split-up version of pci_hp_register().  Likewise, offer pci_hp_del()
    and pci_hp_destroy() as a split-up version of pci_hp_deregister().
    
    Eliminate the ->release callback and move its code into each driver's
    teardown routine.
    
    Declare pci_hp_deregister() void, in keeping with the usual kernel
    pattern that enablement can fail, but disablement cannot.  It only
    returned an error if the caller passed in a NULL pointer or a slot which
    has never or is no longer registered or is sharing its name with another
    slot.  Those would be bugs, so WARN about them.  Few hotplug drivers
    actually checked the return value and those that did only printed a
    useless error message to dmesg.  Remove that.
    
    For most drivers the conversion was straightforward since it doesn't
    matter whether the code in the ->release callback is executed before or
    after destruction of the kobject.  But in the case of ibmphp, it was
    unclear to me whether setting slot_cur->ctrl and slot_cur->bus_on to
    NULL needs to happen before the kobject is destroyed, so I erred on
    the side of caution and ensured that the order stays the same.  Another
    nontrivial case is pnv_php, I've found the list and kref logic difficult
    to understand, however my impression was that it is safe to delete the
    list element and drop the references until after the kobject is
    destroyed.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Andy Shevchenko <andy.shevchenko@gmail.com>  # drivers/platform/x86
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Scott Murray <scott@spiteful.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Cc: Sebastian Ott <sebott@linux.vnet.ibm.com>
    Cc: Gerald Schaefer <gerald.schaefer@de.ibm.com>
    Cc: Corentin Chary <corentin.chary@gmail.com>
    Cc: Darren Hart <dvhart@infradead.org>
    Cc: Andy Shevchenko <andy@infradead.org>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 3d523ca64694..d67f32a29bb4 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -858,12 +858,6 @@ static int asus_get_adapter_status(struct hotplug_slot *hotplug_slot,
 	return 0;
 }
 
-static void asus_cleanup_pci_hotplug(struct hotplug_slot *hotplug_slot)
-{
-	kfree(hotplug_slot->info);
-	kfree(hotplug_slot);
-}
-
 static struct hotplug_slot_ops asus_hotplug_slot_ops = {
 	.owner = THIS_MODULE,
 	.get_adapter_status = asus_get_adapter_status,
@@ -905,7 +899,6 @@ static int asus_setup_pci_hotplug(struct asus_wmi *asus)
 		goto error_info;
 
 	asus->hotplug_slot->private = asus;
-	asus->hotplug_slot->release = &asus_cleanup_pci_hotplug;
 	asus->hotplug_slot->ops = &asus_hotplug_slot_ops;
 	asus_get_adapter_status(asus->hotplug_slot,
 				&asus->hotplug_slot->info->adapter_status);
@@ -1051,8 +1044,11 @@ static void asus_wmi_rfkill_exit(struct asus_wmi *asus)
 	 * asus_unregister_rfkill_notifier()
 	 */
 	asus_rfkill_hotplug(asus);
-	if (asus->hotplug_slot)
+	if (asus->hotplug_slot) {
 		pci_hp_deregister(asus->hotplug_slot);
+		kfree(asus->hotplug_slot->info);
+		kfree(asus->hotplug_slot);
+	}
 	if (asus->hotplug_workqueue)
 		destroy_workqueue(asus->hotplug_workqueue);
 

commit ed99d29b2b1562e5173953a5ea8b7861a4f29e2c
Author: Chris Chiu <chiu@endlessm.com>
Date:   Wed Jun 20 22:46:45 2018 +0800

    platform/x86: asus-wmi: Add keyboard backlight toggle support
    
    Some ASUS laptops like UX550GE has hotkey (Fn+F7) for keyboard
    backlight toggle which would emit the scan code 0xc7 each keypress.
    On the UX550GE, the max keyboard brightness level is 3 so the
    toggle would not be simply on/off the led but need to be cyclic.
    Per ASUS spec, it should increment the brightness for each keypress,
    then toggle(off) the LED when it already reached the max level.
    
    Signed-off-by: Chris Chiu <chiu@endlessm.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 3944e065ab77..34dcc1aac4ea 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -67,6 +67,7 @@ MODULE_LICENSE("GPL");
 #define NOTIFY_BRNDOWN_MAX		0x2e
 #define NOTIFY_KBD_BRTUP		0xc4
 #define NOTIFY_KBD_BRTDWN		0xc5
+#define NOTIFY_KBD_BRTTOGGLE		0xc7
 
 /* WMI Methods */
 #define ASUS_WMI_METHODID_SPEC	        0x43455053 /* BIOS SPECification */
@@ -1775,6 +1776,13 @@ static void asus_wmi_notify(u32 value, void *context)
 		do_kbd_led_set(&asus->kbd_led, asus->kbd_led_wk - 1);
 		goto exit;
 	}
+	if (code == NOTIFY_KBD_BRTTOGGLE) {
+		if (asus->kbd_led_wk == asus->kbd_led.max_brightness)
+			do_kbd_led_set(&asus->kbd_led, 0);
+		else
+			do_kbd_led_set(&asus->kbd_led, asus->kbd_led_wk + 1);
+		goto exit;
+	}
 
 	if (is_display_toggle(code) &&
 	    asus->driver->quirks->no_display_toggle)

commit dbb3d78f61badeadc7448f9d88a070a76612860f
Author: Chris Chiu <chiu@endlessm.com>
Date:   Wed Jun 20 22:46:44 2018 +0800

    platform/x86: asus-wmi: Call led hw_changed API on kbd brightness change
    
    Make asus-wmi notify on hotkey kbd brightness changes, listen for
    brightness events and update the brightness directly in the driver.
    Create new do_kbd_led_set function for in-driver update, and leave
    kbd_led_set for original led_classdev call path.
    
    Update the brightness by led_classdev_notify_brightness_hw_changed.
    This will allow userspace to monitor (poll) for brightness changes
    on the LED without reporting via input keymapping.
    
    Signed-off-by: Chris Chiu <chiu@endlessm.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 3d523ca64694..3944e065ab77 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -470,6 +470,7 @@ static void kbd_led_update(struct work_struct *work)
 		ctrl_param = 0x80 | (asus->kbd_led_wk & 0x7F);
 
 	asus_wmi_set_devstate(ASUS_WMI_DEVID_KBD_BACKLIGHT, ctrl_param, NULL);
+	led_classdev_notify_brightness_hw_changed(&asus->kbd_led, asus->kbd_led_wk);
 }
 
 static int kbd_led_read(struct asus_wmi *asus, int *level, int *env)
@@ -500,15 +501,16 @@ static int kbd_led_read(struct asus_wmi *asus, int *level, int *env)
 	return retval;
 }
 
-static void kbd_led_set(struct led_classdev *led_cdev,
-			enum led_brightness value)
+static void do_kbd_led_set(struct led_classdev *led_cdev, int value)
 {
 	struct asus_wmi *asus;
+	int max_level;
 
 	asus = container_of(led_cdev, struct asus_wmi, kbd_led);
+	max_level = asus->kbd_led.max_brightness;
 
-	if (value > asus->kbd_led.max_brightness)
-		value = asus->kbd_led.max_brightness;
+	if (value > max_level)
+		value = max_level;
 	else if (value < 0)
 		value = 0;
 
@@ -516,6 +518,12 @@ static void kbd_led_set(struct led_classdev *led_cdev,
 	queue_work(asus->led_workqueue, &asus->kbd_led_work);
 }
 
+static void kbd_led_set(struct led_classdev *led_cdev,
+			enum led_brightness value)
+{
+	do_kbd_led_set(led_cdev, value);
+}
+
 static enum led_brightness kbd_led_get(struct led_classdev *led_cdev)
 {
 	struct asus_wmi *asus;
@@ -666,6 +674,7 @@ static int asus_wmi_led_init(struct asus_wmi *asus)
 
 		asus->kbd_led_wk = led_val;
 		asus->kbd_led.name = "asus::kbd_backlight";
+		asus->kbd_led.flags = LED_BRIGHT_HW_CHANGED;
 		asus->kbd_led.brightness_set = kbd_led_set;
 		asus->kbd_led.brightness_get = kbd_led_get;
 		asus->kbd_led.max_brightness = 3;
@@ -1758,6 +1767,15 @@ static void asus_wmi_notify(u32 value, void *context)
 		}
 	}
 
+	if (code == NOTIFY_KBD_BRTUP) {
+		do_kbd_led_set(&asus->kbd_led, asus->kbd_led_wk + 1);
+		goto exit;
+	}
+	if (code == NOTIFY_KBD_BRTDWN) {
+		do_kbd_led_set(&asus->kbd_led, asus->kbd_led_wk - 1);
+		goto exit;
+	}
+
 	if (is_display_toggle(code) &&
 	    asus->driver->quirks->no_display_toggle)
 		goto exit;

commit cf48bf9eee42061c0dbe06ba3e26244dd933cab1
Author: Joo Paulo Rechi Vita <jprvita@gmail.com>
Date:   Tue May 22 14:30:15 2018 -0700

    platform/x86: asus-wmi: Fix NULL pointer dereference
    
    Do not perform the rfkill cleanup routine when
    (asus->driver->wlan_ctrl_by_user && ashs_present()) is true, since
    nothing is registered with the rfkill subsystem in that case. Doing so
    leads to the following kernel NULL pointer dereference:
    
      BUG: unable to handle kernel NULL pointer dereference at           (null)
      IP: [<ffffffff816c7348>] __mutex_lock_slowpath+0x98/0x120
      PGD 1a3aa8067
      PUD 1a3b3d067
      PMD 0
    
      Oops: 0002 [#1] PREEMPT SMP
      Modules linked in: bnep ccm binfmt_misc uvcvideo videobuf2_vmalloc videobuf2_memops videobuf2_v4l2 videobuf2_core hid_a4tech videodev x86_pkg_temp_thermal intel_powerclamp coretemp ath3k btusb btrtl btintel bluetooth kvm_intel snd_hda_codec_hdmi kvm snd_hda_codec_realtek snd_hda_codec_generic irqbypass crc32c_intel arc4 i915 snd_hda_intel snd_hda_codec ath9k ath9k_common ath9k_hw ath i2c_algo_bit snd_hwdep mac80211 ghash_clmulni_intel snd_hda_core snd_pcm snd_timer cfg80211 ehci_pci xhci_pci drm_kms_helper syscopyarea sysfillrect sysimgblt fb_sys_fops drm xhci_hcd ehci_hcd asus_nb_wmi(-) asus_wmi sparse_keymap r8169 rfkill mxm_wmi serio_raw snd mii mei_me lpc_ich i2c_i801 video soundcore mei i2c_smbus wmi i2c_core mfd_core
      CPU: 3 PID: 3275 Comm: modprobe Not tainted 4.9.34-gentoo #34
      Hardware name: ASUSTeK COMPUTER INC. K56CM/K56CM, BIOS K56CM.206 08/21/2012
      task: ffff8801a639ba00 task.stack: ffffc900014cc000
      RIP: 0010:[<ffffffff816c7348>]  [<ffffffff816c7348>] __mutex_lock_slowpath+0x98/0x120
      RSP: 0018:ffffc900014cfce0  EFLAGS: 00010282
      RAX: 0000000000000000 RBX: ffff8801a54315b0 RCX: 00000000c0000100
      RDX: 0000000000000001 RSI: 0000000000000000 RDI: ffff8801a54315b4
      RBP: ffffc900014cfd30 R08: 0000000000000000 R09: 0000000000000002
      R10: 0000000000000000 R11: 0000000000000000 R12: ffff8801a54315b4
      R13: ffff8801a639ba00 R14: 00000000ffffffff R15: ffff8801a54315b8
      FS:  00007faa254fb700(0000) GS:ffff8801aef80000(0000) knlGS:0000000000000000
      CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
      CR2: 0000000000000000 CR3: 00000001a3b1b000 CR4: 00000000001406e0
      Stack:
       ffff8801a54315b8 0000000000000000 ffffffff814733ae ffffc900014cfd28
       ffffffff8146a28c ffff8801a54315b0 0000000000000000 ffff8801a54315b0
       ffff8801a66f3820 0000000000000000 ffffc900014cfd48 ffffffff816c73e7
      Call Trace:
       [<ffffffff814733ae>] ? acpi_ut_release_mutex+0x5d/0x61
       [<ffffffff8146a28c>] ? acpi_ns_get_node+0x49/0x52
       [<ffffffff816c73e7>] mutex_lock+0x17/0x30
       [<ffffffffa00a3bb4>] asus_rfkill_hotplug+0x24/0x1a0 [asus_wmi]
       [<ffffffffa00a4421>] asus_wmi_rfkill_exit+0x61/0x150 [asus_wmi]
       [<ffffffffa00a49f1>] asus_wmi_remove+0x61/0xb0 [asus_wmi]
       [<ffffffff814a5128>] platform_drv_remove+0x28/0x40
       [<ffffffff814a2901>] __device_release_driver+0xa1/0x160
       [<ffffffff814a29e3>] device_release_driver+0x23/0x30
       [<ffffffff814a1ffd>] bus_remove_device+0xfd/0x170
       [<ffffffff8149e5a9>] device_del+0x139/0x270
       [<ffffffff814a5028>] platform_device_del+0x28/0x90
       [<ffffffff814a50a2>] platform_device_unregister+0x12/0x30
       [<ffffffffa00a4209>] asus_wmi_unregister_driver+0x19/0x30 [asus_wmi]
       [<ffffffffa00da0ea>] asus_nb_wmi_exit+0x10/0xf26 [asus_nb_wmi]
       [<ffffffff8110c692>] SyS_delete_module+0x192/0x270
       [<ffffffff810022b2>] ? exit_to_usermode_loop+0x92/0xa0
       [<ffffffff816ca560>] entry_SYSCALL_64_fastpath+0x13/0x94
      Code: e8 5e 30 00 00 8b 03 83 f8 01 0f 84 93 00 00 00 48 8b 43 10 4c 8d 7b 08 48 89 63 10 41 be ff ff ff ff 4c 89 3c 24 48 89 44 24 08 <48> 89 20 4c 89 6c 24 10 eb 1d 4c 89 e7 49 c7 45 08 02 00 00 00
      RIP  [<ffffffff816c7348>] __mutex_lock_slowpath+0x98/0x120
       RSP <ffffc900014cfce0>
      CR2: 0000000000000000
      ---[ end trace 8d484233fa7cb512 ]---
      note: modprobe[3275] exited with preempt_count 2
    
    https://bugzilla.kernel.org/show_bug.cgi?id=196467
    
    Reported-by: red.f0xyz@gmail.com
    Signed-off-by: Joo Paulo Rechi Vita <jprvita@endlessm.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index ef87e78ca772..3d523ca64694 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -163,6 +163,16 @@ MODULE_LICENSE("GPL");
 
 static const char * const ashs_ids[] = { "ATK4001", "ATK4002", NULL };
 
+static bool ashs_present(void)
+{
+	int i = 0;
+	while (ashs_ids[i]) {
+		if (acpi_dev_found(ashs_ids[i++]))
+			return true;
+	}
+	return false;
+}
+
 struct bios_args {
 	u32 arg0;
 	u32 arg1;
@@ -1025,6 +1035,9 @@ static int asus_new_rfkill(struct asus_wmi *asus,
 
 static void asus_wmi_rfkill_exit(struct asus_wmi *asus)
 {
+	if (asus->driver->wlan_ctrl_by_user && ashs_present())
+		return;
+
 	asus_unregister_rfkill_notifier(asus, "\\_SB.PCI0.P0P5");
 	asus_unregister_rfkill_notifier(asus, "\\_SB.PCI0.P0P6");
 	asus_unregister_rfkill_notifier(asus, "\\_SB.PCI0.P0P7");
@@ -2120,16 +2133,6 @@ static int asus_wmi_fan_init(struct asus_wmi *asus)
 	return 0;
 }
 
-static bool ashs_present(void)
-{
-	int i = 0;
-	while (ashs_ids[i]) {
-		if (acpi_dev_found(ashs_ids[i++]))
-			return true;
-	}
-	return false;
-}
-
 /*
  * WMI Driver
  */

commit d605ca29c35d9ebc0c32c386d95336d5339f61f7
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Thu Apr 19 16:06:10 2018 +0200

    platform/x86: Simplify getting .drvdata
    
    We should get drvdata from struct device directly. Going via
    platform_device is an unneeded step back and forth.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index a32c5c00e0e7..ef87e78ca772 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1862,8 +1862,7 @@ static umode_t asus_sysfs_is_visible(struct kobject *kobj,
 				    struct attribute *attr, int idx)
 {
 	struct device *dev = container_of(kobj, struct device, kobj);
-	struct platform_device *pdev = to_platform_device(dev);
-	struct asus_wmi *asus = platform_get_drvdata(pdev);
+	struct asus_wmi *asus = dev_get_drvdata(dev);
 	bool ok = true;
 	int devid = -1;
 

commit 4c05984459ec55056857bee32ecb01653c6b8f84
Author: Maxime Belleng <maxime.bellenge@gmail.com>
Date:   Sat Sep 23 18:23:37 2017 +0200

    platform/x86: asus-wmi: Add lightbar led support
    
    Some Asus laptops (ROG series for example) are provided with a lightbar
    behind the monitor. This patch make possible to switch it on and off.
    This lightbar works exactly like any other led.
    
    Signed-off-by: Maxime Belleng <maxime.bellenge@gmail.com>
    [dvhart: fix commit message format and variable declaration order]
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 48e1541dc8d4..a32c5c00e0e7 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -119,6 +119,7 @@ MODULE_LICENSE("GPL");
 #define ASUS_WMI_DEVID_BRIGHTNESS	0x00050012
 #define ASUS_WMI_DEVID_KBD_BACKLIGHT	0x00050021
 #define ASUS_WMI_DEVID_LIGHT_SENSOR	0x00050022 /* ?? */
+#define ASUS_WMI_DEVID_LIGHTBAR		0x00050025
 
 /* Misc */
 #define ASUS_WMI_DEVID_CAMERA		0x00060013
@@ -148,6 +149,7 @@ MODULE_LICENSE("GPL");
 #define ASUS_WMI_DSTS_BIOS_BIT		0x00040000
 #define ASUS_WMI_DSTS_BRIGHTNESS_MASK	0x000000FF
 #define ASUS_WMI_DSTS_MAX_BRIGTH_MASK	0x0000FF00
+#define ASUS_WMI_DSTS_LIGHTBAR_MASK	0x0000000F
 
 #define ASUS_FAN_DESC			"cpu_fan"
 #define ASUS_FAN_MFUN			0x13
@@ -222,10 +224,13 @@ struct asus_wmi {
 	int tpd_led_wk;
 	struct led_classdev kbd_led;
 	int kbd_led_wk;
+	struct led_classdev lightbar_led;
+	int lightbar_led_wk;
 	struct workqueue_struct *led_workqueue;
 	struct work_struct tpd_led_work;
 	struct work_struct kbd_led_work;
 	struct work_struct wlan_led_work;
+	struct work_struct lightbar_led_work;
 
 	struct asus_rfkill wlan;
 	struct asus_rfkill bluetooth;
@@ -567,6 +572,48 @@ static enum led_brightness wlan_led_get(struct led_classdev *led_cdev)
 	return result & ASUS_WMI_DSTS_BRIGHTNESS_MASK;
 }
 
+static void lightbar_led_update(struct work_struct *work)
+{
+	struct asus_wmi *asus;
+	int ctrl_param;
+
+	asus = container_of(work, struct asus_wmi, lightbar_led_work);
+
+	ctrl_param = asus->lightbar_led_wk;
+	asus_wmi_set_devstate(ASUS_WMI_DEVID_LIGHTBAR, ctrl_param, NULL);
+}
+
+static void lightbar_led_set(struct led_classdev *led_cdev,
+			     enum led_brightness value)
+{
+	struct asus_wmi *asus;
+
+	asus = container_of(led_cdev, struct asus_wmi, lightbar_led);
+
+	asus->lightbar_led_wk = !!value;
+	queue_work(asus->led_workqueue, &asus->lightbar_led_work);
+}
+
+static enum led_brightness lightbar_led_get(struct led_classdev *led_cdev)
+{
+	struct asus_wmi *asus;
+	u32 result;
+
+	asus = container_of(led_cdev, struct asus_wmi, lightbar_led);
+	asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_LIGHTBAR, &result);
+
+	return result & ASUS_WMI_DSTS_LIGHTBAR_MASK;
+}
+
+static int lightbar_led_presence(struct asus_wmi *asus)
+{
+	u32 result;
+
+	asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_LIGHTBAR, &result);
+
+	return result & ASUS_WMI_DSTS_PRESENCE_BIT;
+}
+
 static void asus_wmi_led_exit(struct asus_wmi *asus)
 {
 	if (!IS_ERR_OR_NULL(asus->kbd_led.dev))
@@ -575,6 +622,8 @@ static void asus_wmi_led_exit(struct asus_wmi *asus)
 		led_classdev_unregister(&asus->tpd_led);
 	if (!IS_ERR_OR_NULL(asus->wlan_led.dev))
 		led_classdev_unregister(&asus->wlan_led);
+	if (!IS_ERR_OR_NULL(asus->lightbar_led.dev))
+		led_classdev_unregister(&asus->lightbar_led);
 	if (asus->led_workqueue)
 		destroy_workqueue(asus->led_workqueue);
 }
@@ -630,6 +679,20 @@ static int asus_wmi_led_init(struct asus_wmi *asus)
 
 		rv = led_classdev_register(&asus->platform_device->dev,
 					   &asus->wlan_led);
+		if (rv)
+			goto error;
+	}
+
+	if (lightbar_led_presence(asus)) {
+		INIT_WORK(&asus->lightbar_led_work, lightbar_led_update);
+
+		asus->lightbar_led.name = "asus::lightbar";
+		asus->lightbar_led.brightness_set = lightbar_led_set;
+		asus->lightbar_led.brightness_get = lightbar_led_get;
+		asus->lightbar_led.max_brightness = 1;
+
+		rv = led_classdev_register(&asus->platform_device->dev,
+					   &asus->lightbar_led);
 	}
 
 error:

commit 0fe57261214bcc866ef0233444a395b5fdfb5ac3
Author: Pali Rohr <pali.rohar@gmail.com>
Date:   Sat Aug 12 09:44:16 2017 +0200

    platform/x86: asus-wmi: Evaluate wmi method with instance number 0x0
    
    According to available DSDT dump from Asus machine, there is the only one
    instance of the WMI GUID 97845ED0-4E6D-11DE-8A39-0800200C9A66 and so it is
    0x0. Moreover corresponding method WMBC does not check Arg0 (instance
    number) at all.
    
    DSDT dump is available at:
    https://lwn.net/Articles/391249/
    
    _WDG dump:
    0xD0, 0x5E, 0x84, 0x97, 0x6D, 0x4E, 0xDE, 0x11, 0x8A, 0x39, 0x08,
    0x00, 0x20, 0x0C, 0x9A, 0x66,
    0x42, 0x43,    // Object ID "BC" = method "WMBC"
    0x01,          // Instance count
    0x02,          // Flags
    
    Signed-off-by: Pali Rohr <pali.rohar@gmail.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 709e3a67391a..48e1541dc8d4 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -299,7 +299,7 @@ static int asus_wmi_evaluate_method(u32 method_id, u32 arg0, u32 arg1,
 	union acpi_object *obj;
 	u32 tmp = 0;
 
-	status = wmi_evaluate_method(ASUS_WMI_MGMT_GUID, 1, method_id,
+	status = wmi_evaluate_method(ASUS_WMI_MGMT_GUID, 0, method_id,
 				     &input, &output);
 
 	if (ACPI_FAILURE(status))
@@ -1946,7 +1946,7 @@ static int show_call(struct seq_file *m, void *data)
 	acpi_status status;
 
 	status = wmi_evaluate_method(ASUS_WMI_MGMT_GUID,
-				     1, asus->debug.method_id,
+				     0, asus->debug.method_id,
 				     &input, &output);
 
 	if (ACPI_FAILURE(status))

commit e90d9ba837b3b779644613a3b9e4845a0cd302f2
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Tue Jul 11 16:18:19 2017 +0530

    platform/x86: asus-wmi: constify attribute_group structures.
    
    attribute_groups are not supposed to change at runtime. All functions
    working with attribute_groups provided by <linux/sysfs.h> work
    with const attribute_group. So mark the non-const structs as const.
    
    File size before:
       text    data     bss     dec     hex filename
      13140     840       1   13981    369d drivers/platform/x86/asus-wmi.o
    
    File size After adding 'const':
       text    data     bss     dec     hex filename
      13268     712       1   13981    368d drivers/platform/x86/asus-wmi.o
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 6c7d86074b38..709e3a67391a 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1433,7 +1433,7 @@ static umode_t asus_hwmon_sysfs_is_visible(struct kobject *kobj,
 	return ok ? attr->mode : 0;
 }
 
-static struct attribute_group hwmon_attribute_group = {
+static const struct attribute_group hwmon_attribute_group = {
 	.is_visible = asus_hwmon_sysfs_is_visible,
 	.attrs = hwmon_attributes
 };
@@ -1821,7 +1821,7 @@ static umode_t asus_sysfs_is_visible(struct kobject *kobj,
 	return ok ? attr->mode : 0;
 }
 
-static struct attribute_group platform_attribute_group = {
+static const struct attribute_group platform_attribute_group = {
 	.is_visible = asus_sysfs_is_visible,
 	.attrs = platform_attributes
 };

commit e9b615186805e2c18a0ac76aca62c1543ecfdbb8
Author: Oleksij Rempel <linux@rempel-privat.de>
Date:   Fri Apr 28 16:19:49 2017 +0200

    platform/x86: asus-wmi: try to set als by default
    
    some laptops, for example ASUS UX330UAK, have brocken als_get function
    but working als_set funktion. In this case, ALS will stay turned off.
    
                 Method (WMNB, 3, Serialized)
                {
                ...
                   If (Local0 == 0x53545344)
                    {
                    ...
                        If (IIA0 == 0x00050001)
                        {
                            If (!ALSP)
                            {
                                Return (0x02)
                            }
    
                            Local0 = (GALS & 0x10)    <<<---- bug,
                                                        should be: (GALS () & 0x10)
                            If (Local0)
                            {
                                Return (0x00050001)
                            }
                            Else
                            {
                                Return (0x00050000)
                            }
                        }
    
                 .....
                    If (Local0 == 0x53564544)
                    {
                    ...
                        If (IIA0 == 0x00050001)
                        {
                            Return (ALSC (IIA1))
                        }
    
                      ......
                        Method (GALS, 0, NotSerialized)
                        {
                            Local0 = Zero
                            Local0 |= 0x20
                            If (ALAE)
                            {
                                Local0 |= 0x10
                            }
    
                            Local1 = 0x0A
                            Local1 <<= 0x08
                            Local0 |= Local1
                            Return (Local0)
                        }
    
    Since it works without problems on Windows I assume ASUS WMI driver for Win
    never trying to get ALS state, and instead it is setting it by default to ON.
    
    This patch will do the same. Turn ALS on by default.
    
    Signed-off-by: Oleksij Rempel <linux@rempel-privat.de>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index a92255400d5c..6c7d86074b38 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1104,6 +1104,15 @@ static void asus_wmi_set_xusb2pr(struct asus_wmi *asus)
 			orig_ports_available, ports_available);
 }
 
+/*
+ * Some devices dont support or have borcken get_als method
+ * but still support set method.
+ */
+static void asus_wmi_set_als(void)
+{
+	asus_wmi_set_devstate(ASUS_WMI_DEVID_ALS_ENABLE, 1, NULL);
+}
+
 /*
  * Hwmon device
  */
@@ -2113,6 +2122,9 @@ static int asus_wmi_add(struct platform_device *pdev)
 			goto fail_rfkill;
 	}
 
+	if (asus->driver->quirks->wmi_force_als_set)
+		asus_wmi_set_als();
+
 	/* Some Asus desktop boards export an acpi-video backlight interface,
 	   stop this from showing up */
 	chassis_type = dmi_get_system_info(DMI_CHASSIS_TYPE);

commit a8fe342856e5bce71a43201eb2870bd059483d2f
Author: Jrmy Lefaure <jeremy.lefaure@lse.epita.fr>
Date:   Fri Apr 21 22:19:45 2017 -0400

    platform/x86: asus-wmi: fix cpufv sysfs file permission
    
    The cpufv sysfs file is defined as readable by anyone even if the
    attribute does not have a show function. The result of every read is an
    IO error. This file should be write only.
    
    Signed-off-by: Jrmy Lefaure <jeremy.lefaure@lse.epita.fr>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index d817e6327fec..a92255400d5c 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1757,7 +1757,7 @@ ASUS_WMI_CREATE_DEVICE_ATTR(cardr, 0644, ASUS_WMI_DEVID_CARDREADER);
 ASUS_WMI_CREATE_DEVICE_ATTR(lid_resume, 0644, ASUS_WMI_DEVID_LID_RESUME);
 ASUS_WMI_CREATE_DEVICE_ATTR(als_enable, 0644, ASUS_WMI_DEVID_ALS_ENABLE);
 
-static ssize_t store_cpufv(struct device *dev, struct device_attribute *attr,
+static ssize_t cpufv_store(struct device *dev, struct device_attribute *attr,
 			   const char *buf, size_t count)
 {
 	int value, rv;
@@ -1774,7 +1774,7 @@ static ssize_t store_cpufv(struct device *dev, struct device_attribute *attr,
 	return count;
 }
 
-static DEVICE_ATTR(cpufv, S_IRUGO | S_IWUSR, NULL, store_cpufv);
+static DEVICE_ATTR_WO(cpufv);
 
 static struct attribute *platform_attributes[] = {
 	&dev_attr_cpufv.attr,

commit c2ef3a1c97adbe26d1a10d878e353436a3978409
Author: Micha Kpie <kernel@kempniu.pl>
Date:   Thu Mar 9 13:11:39 2017 +0100

    platform/x86: asus-wmi: remove sparse_keymap_free() calls
    
    As sparse_keymap_setup() now uses a managed memory allocation for the
    keymap copy it creates, the latter is freed automatically.  Remove all
    calls to sparse_keymap_free().
    
    Signed-off-by: Micha Kpie <kernel@kempniu.pl>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 8fe5890bf539..d817e6327fec 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -269,12 +269,10 @@ static int asus_wmi_input_init(struct asus_wmi *asus)
 
 	err = input_register_device(asus->inputdev);
 	if (err)
-		goto err_free_keymap;
+		goto err_free_dev;
 
 	return 0;
 
-err_free_keymap:
-	sparse_keymap_free(asus->inputdev);
 err_free_dev:
 	input_free_device(asus->inputdev);
 	return err;
@@ -282,10 +280,8 @@ static int asus_wmi_input_init(struct asus_wmi *asus)
 
 static void asus_wmi_input_exit(struct asus_wmi *asus)
 {
-	if (asus->inputdev) {
-		sparse_keymap_free(asus->inputdev);
+	if (asus->inputdev)
 		input_unregister_device(asus->inputdev);
-	}
 
 	asus->inputdev = NULL;
 }

commit d1c4e9bf73e739b937ddd9dc4cf0f6de2e6117da
Author: Joo Paulo Rechi Vita <jprvita@gmail.com>
Date:   Mon Feb 20 14:50:23 2017 -0500

    platform/x86: asus-wmi: Remove quirk_no_rfkill
    
    With the detection introduced in the previous patches, we don't need
    these static DMI-based quirks anymore.
    
    This reverts the following commits:
    56a37a72002b "asus-wmi: Add quirk_no_rfkill_wapf4 for the Asus X456UA"
    a961a285b479 "asus-wmi: Add quirk_no_rfkill_wapf4 for the Asus X456UF"
    6b7ff2af5286 "asus-wmi: Add quirk_no_rfkill for the Asus Z550MA"
    02db9ff7af18 "asus-wmi: Add quirk_no_rfkill for the Asus U303LB"
    2d735244b798 "asus-wmi: Add quirk_no_rfkill for the Asus N552VW"
    a977e59c0c67 "asus-wmi: Create quirk for airplane_mode LED"
    
    Signed-off-by: Joo Paulo Rechi Vita <jprvita@endlessm.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    [dvhart: minor commit message corrections]
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 8499d3ae4257..8fe5890bf539 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -2111,10 +2111,7 @@ static int asus_wmi_add(struct platform_device *pdev)
 	if (result & (ASUS_WMI_DSTS_PRESENCE_BIT | ASUS_WMI_DSTS_USER_BIT))
 		asus->driver->wlan_ctrl_by_user = 1;
 
-	if (asus->driver->wlan_ctrl_by_user && ashs_present())
-		asus->driver->quirks->no_rfkill = 1;
-
-	if (!asus->driver->quirks->no_rfkill) {
+	if (!(asus->driver->wlan_ctrl_by_user && ashs_present())) {
 		err = asus_wmi_rfkill_init(asus);
 		if (err)
 			goto fail_rfkill;

commit 71050ae7bf83e4d71a859257d11adc5de517073e
Author: Joo Paulo Rechi Vita <jprvita@gmail.com>
Date:   Mon Feb 20 14:50:22 2017 -0500

    platform/x86: asus-wmi: Detect quirk_no_rfkill from the DSDT
    
    Some Asus laptops that have an airplane-mode indicator LED, also have
    the WMI WLAN user bit set, and the following bits in their DSDT:
    
        Scope (_SB)
        {
          (...)
          Device (ATKD)
          {
            (...)
            Method (WMNB, 3, Serialized)
            {
              (...)
              If (LEqual (IIA0, 0x00010002))
              {
                OWGD (IIA1)
                Return (One)
              }
            }
          }
        }
    
    So when asus-wmi uses ASUS_WMI_DEVID_WLAN_LED (0x00010002) to store the
    wlan state, it drives the airplane-mode indicator LED (through the call
    to OWGD) in an inverted fashion: the LED is ON when airplane mode is OFF
    (since wlan is ON), and vice-versa.
    
    This commit skips registering RFKill switches at all for these laptops,
    to allow the asus-wireless driver to drive the airplane mode LED
    correctly through the ASHS ACPI device. Relying on the presence of ASHS
    and ASUS_WMI_DSTS_USER_BIT avoids adding DMI-based quirks for at least
    21 different laptops.
    
    Signed-off-by: Joo Paulo Rechi Vita <jprvita@endlessm.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 43cb680adbb4..8499d3ae4257 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -159,6 +159,8 @@ MODULE_LICENSE("GPL");
 #define USB_INTEL_XUSB2PR		0xD0
 #define PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI	0x9c31
 
+static const char * const ashs_ids[] = { "ATK4001", "ATK4002", NULL };
+
 struct bios_args {
 	u32 arg0;
 	u32 arg1;
@@ -2051,6 +2053,16 @@ static int asus_wmi_fan_init(struct asus_wmi *asus)
 	return 0;
 }
 
+static bool ashs_present(void)
+{
+	int i = 0;
+	while (ashs_ids[i]) {
+		if (acpi_dev_found(ashs_ids[i++]))
+			return true;
+	}
+	return false;
+}
+
 /*
  * WMI Driver
  */
@@ -2095,6 +2107,13 @@ static int asus_wmi_add(struct platform_device *pdev)
 	if (err)
 		goto fail_leds;
 
+	asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_WLAN, &result);
+	if (result & (ASUS_WMI_DSTS_PRESENCE_BIT | ASUS_WMI_DSTS_USER_BIT))
+		asus->driver->wlan_ctrl_by_user = 1;
+
+	if (asus->driver->wlan_ctrl_by_user && ashs_present())
+		asus->driver->quirks->no_rfkill = 1;
+
 	if (!asus->driver->quirks->no_rfkill) {
 		err = asus_wmi_rfkill_init(asus);
 		if (err)
@@ -2134,10 +2153,6 @@ static int asus_wmi_add(struct platform_device *pdev)
 	if (err)
 		goto fail_debugfs;
 
-	asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_WLAN, &result);
-	if (result & (ASUS_WMI_DSTS_PRESENCE_BIT | ASUS_WMI_DSTS_USER_BIT))
-		asus->driver->wlan_ctrl_by_user = 1;
-
 	return 0;
 
 fail_debugfs:

commit 8023eff10e7b0327898f17f0b553d2e45c71cef3
Author: Kai-Chuan Hsieh <kai.chiuan@gmail.com>
Date:   Thu Sep 1 23:55:55 2016 +0800

    platform/x86: asus-wmi: Set specified XUSB2PR value for X550LB
    
    The bluetooth adapter Atheros AR3012 can't be enumerated
    and make the bluetooth function broken.
    
    T:  Bus=02 Lev=01 Prnt=01 Port=05 Cnt=02 Dev#=  5 Spd=12  MxCh= 0
    D:  Ver= 1.10 Cls=e0(wlcon) Sub=01 Prot=01 MxPS=64 #Cfgs=  1
    P:  Vendor=13d3 ProdID=3362 Rev=00.02
    S:  Manufacturer=Atheros Communications
    S:  Product=Bluetooth USB Host Controller
    S:  SerialNumber=Alaska Day 2006
    C:  #Ifs= 2 Cfg#= 1 Atr=e0 MxPwr=100mA
    I:  If#= 0 Alt= 0 #EPs= 3 Cls=e0(wlcon) Sub=01 Prot=01 Driver=btusb
    I:  If#= 1 Alt= 0 #EPs= 2 Cls=e0(wlcon) Sub=01 Prot=01 Driver=btusb
    
    The error is:
    
     usb 2-6: device not accepting address 7, error -62
     usb usb2-port6: unable to enumerate USB device
    
    It is caused by adapter's connected port is mapped to xHC
    controller, but the xHCI is not supported by the usb device.
    
    The output of 'sudo lspci -nnxxx -s 00:14.0':
    
     00:14.0 USB controller [0c03]: Intel Corporation 8 Series USB xHCI HC [8086:9c31] (rev 04)
     00: 86 80 31 9c 06 04 90 02 04 30 03 0c 00 00 00 00
     10: 04 00 a0 f7 00 00 00 00 00 00 00 00 00 00 00 00
     20: 00 00 00 00 00 00 00 00 00 00 00 00 43 10 1f 20
     30: 00 00 00 00 70 00 00 00 00 00 00 00 0b 01 00 00
     40: fd 01 36 80 89 c6 0f 80 00 00 00 00 00 00 00 00
     50: 5f 2e ce 0f 00 00 00 00 00 00 00 00 00 00 00 00
     60: 30 20 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     70: 01 80 c2 c1 08 00 00 00 00 00 00 00 00 00 00 00
     80: 05 00 87 00 0c a0 e0 fe 00 00 00 00 a1 41 00 00
     90: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     a0: 00 01 04 00 00 00 00 00 00 00 00 00 00 00 00 00
     b0: 0f 00 03 00 00 00 00 00 00 00 00 00 00 00 00 00
     c0: 03 c0 30 00 00 00 00 00 03 0c 00 00 00 00 00 00
     d0: f9 01 00 00 f9 01 00 00 0f 00 00 00 0f 00 00 00
     e0: 00 08 00 00 00 00 00 00 00 00 00 00 d8 d8 00 00
     f0: 00 00 00 00 00 00 00 00 b1 0f 04 08 00 00 00 00
    
    By referencing Intel Platform Controller Hub(PCH) datasheet,
    the xHC USB 2.0 Port Routing(XUSB2PR) at offset 0xD0-0xD3h
    decides the setting of mapping the port to EHCI controller or
    xHC controller. And the port mapped to xHC will enable xHCI
    during bus resume.
    
    The setting of disabling bluetooth adapter's connected port is
    0x000001D9. The value can be obtained by few times 1 bit flip
    operation. The suited configuration should have the 'lsusb -t'
    result with bluetooth using ehci:
    
    /:  Bus 03.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/4p, 5000M
    /:  Bus 02.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/9p, 480M
        |__ Port 5: Dev 2, If 0, Class=Video, Driver=uvcvideo, 480M
        |__ Port 5: Dev 2, If 1, Class=Video, Driver=uvcvideo, 480M
    /:  Bus 01.Port 1: Dev 1, Class=root_hub, Driver=ehci-pci/2p, 480M
        |__ Port 1: Dev 2, If 0, Class=Hub, Driver=hub/8p, 480M
            |__ Port 6: Dev 3, If 0, Class=Wireless, Driver=btusb, 12M
            |__ Port 6: Dev 3, If 1, Class=Wireless, Driver=btusb, 12M
    
    Signed-off-by: Kai-Chuan Hsieh <kai.chiuan@gmail.com>
    Acked-by: Corentin Chary <corentin.chary@gmail.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    [andy: resolve merge conflict in asus-wmi.h]
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index ce6ca31a2d09..43cb680adbb4 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -156,6 +156,9 @@ MODULE_LICENSE("GPL");
 #define ASUS_FAN_CTRL_MANUAL		1
 #define ASUS_FAN_CTRL_AUTO		2
 
+#define USB_INTEL_XUSB2PR		0xD0
+#define PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI	0x9c31
+
 struct bios_args {
 	u32 arg0;
 	u32 arg1;
@@ -1080,6 +1083,29 @@ static int asus_wmi_rfkill_init(struct asus_wmi *asus)
 	return result;
 }
 
+static void asus_wmi_set_xusb2pr(struct asus_wmi *asus)
+{
+	struct pci_dev *xhci_pdev;
+	u32 orig_ports_available;
+	u32 ports_available = asus->driver->quirks->xusb2pr;
+
+	xhci_pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
+			PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI,
+			NULL);
+
+	if (!xhci_pdev)
+		return;
+
+	pci_read_config_dword(xhci_pdev, USB_INTEL_XUSB2PR,
+				&orig_ports_available);
+
+	pci_write_config_dword(xhci_pdev, USB_INTEL_XUSB2PR,
+				cpu_to_le32(ports_available));
+
+	pr_info("set USB_INTEL_XUSB2PR old: 0x%04x, new: 0x%04x\n",
+			orig_ports_available, ports_available);
+}
+
 /*
  * Hwmon device
  */
@@ -2087,6 +2113,9 @@ static int asus_wmi_add(struct platform_device *pdev)
 	if (asus->driver->quirks->wmi_backlight_native)
 		acpi_video_set_dmi_backlight_type(acpi_backlight_native);
 
+	if (asus->driver->quirks->xusb2pr)
+		asus_wmi_set_xusb2pr(asus);
+
 	if (acpi_video_get_backlight_type() == acpi_backlight_vendor) {
 		err = asus_wmi_backlight_init(asus);
 		if (err && err != -ENODEV)

commit 999d4376c62828b260fbb59d5ab6bc28918ca448
Author: zino lin <linzino7@gmail.com>
Date:   Sun Aug 28 16:12:06 2016 +0800

    platform/x86: asus-wmi: fix asus ux303ub brightness issue
    
    acpi_video0 doesn't work, asus-wmi brightness interface doesn't work, too.
    So, we use native brightness interface to handle the brightness adjustion,
    and add quirk_asus_ux303ub.
    
    Signed-off-by: zino lin <linzino7@gmail.com>
    Acked-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 7c093a0b78bb..ce6ca31a2d09 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -2084,6 +2084,9 @@ static int asus_wmi_add(struct platform_device *pdev)
 	if (asus->driver->quirks->wmi_backlight_power)
 		acpi_video_set_dmi_backlight_type(acpi_backlight_vendor);
 
+	if (asus->driver->quirks->wmi_backlight_native)
+		acpi_video_set_dmi_backlight_type(acpi_backlight_native);
+
 	if (acpi_video_get_backlight_type() == acpi_backlight_vendor) {
 		err = asus_wmi_backlight_init(asus);
 		if (err && err != -ENODEV)

commit a977e59c0c67c9d492bb16677ce66d67cae0ebd8
Author: Joo Paulo Rechi Vita <jprvita@gmail.com>
Date:   Mon Jun 13 16:57:31 2016 -0400

    asus-wmi: Create quirk for airplane_mode LED
    
    Some Asus laptops that have an airplane-mode indicator LED, also have
    the WMI WLAN user bit set, and the following bits in their DSDT:
    
    Scope (_SB)
    {
      (...)
      Device (ATKD)
      {
        (...)
        Method (WMNB, 3, Serialized)
        {
          (...)
          If (LEqual (IIA0, 0x00010002))
          {
            OWGD (IIA1)
            Return (One)
          }
        }
      }
    }
    
    So when asus-wmi uses ASUS_WMI_DEVID_WLAN_LED (0x00010002) to store the
    wlan state, it drives the airplane-mode indicator LED (through the call
    to OWGD) in an inverted fashion: the LED is ON when airplane mode is OFF
    (since wlan is ON), and vice-versa.
    
    This commit creates a quirk to not register a RFKill switch at all for
    these laptops, to allow the asus-wireless driver to drive the airplane
    mode LED correctly through the ASHS ACPI device. It also adds a match to
    that quirk for the Asus X555UB, which is affected by this problem.
    
    Signed-off-by: Joo Paulo Rechi Vita <jprvita@endlessm.com>
    Reviewed-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index a26dca3640ea..7c093a0b78bb 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -2069,9 +2069,11 @@ static int asus_wmi_add(struct platform_device *pdev)
 	if (err)
 		goto fail_leds;
 
-	err = asus_wmi_rfkill_init(asus);
-	if (err)
-		goto fail_rfkill;
+	if (!asus->driver->quirks->no_rfkill) {
+		err = asus_wmi_rfkill_init(asus);
+		if (err)
+			goto fail_rfkill;
+	}
 
 	/* Some Asus desktop boards export an acpi-video backlight interface,
 	   stop this from showing up */

commit aca234f6378864d85514be558746c0ea6eabfa8e
Author: Oleksij Rempel <linux@rempel-privat.de>
Date:   Fri Apr 1 13:35:21 2016 +0200

    asus-wmi: provide access to ALS control
    
    Asus Zenbook ux31a is providing ACPI0008 interface for ALS
    (Ambient Light Sensor), which is accessible for OS => Win 7.
    This sensor can be used with iio/acpi-als driver.
    Since it is disabled by default, we should use asus-wmi
    interface to enable it.
    
    Signed-off-by: Oleksij Rempel <linux@rempel-privat.de>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index a96630d52346..a26dca3640ea 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -114,6 +114,7 @@ MODULE_LICENSE("GPL");
 #define ASUS_WMI_DEVID_LED6		0x00020016
 
 /* Backlight and Brightness */
+#define ASUS_WMI_DEVID_ALS_ENABLE	0x00050001 /* Ambient Light Sensor */
 #define ASUS_WMI_DEVID_BACKLIGHT	0x00050011
 #define ASUS_WMI_DEVID_BRIGHTNESS	0x00050012
 #define ASUS_WMI_DEVID_KBD_BACKLIGHT	0x00050021
@@ -1730,6 +1731,7 @@ ASUS_WMI_CREATE_DEVICE_ATTR(touchpad, 0644, ASUS_WMI_DEVID_TOUCHPAD);
 ASUS_WMI_CREATE_DEVICE_ATTR(camera, 0644, ASUS_WMI_DEVID_CAMERA);
 ASUS_WMI_CREATE_DEVICE_ATTR(cardr, 0644, ASUS_WMI_DEVID_CARDREADER);
 ASUS_WMI_CREATE_DEVICE_ATTR(lid_resume, 0644, ASUS_WMI_DEVID_LID_RESUME);
+ASUS_WMI_CREATE_DEVICE_ATTR(als_enable, 0644, ASUS_WMI_DEVID_ALS_ENABLE);
 
 static ssize_t store_cpufv(struct device *dev, struct device_attribute *attr,
 			   const char *buf, size_t count)
@@ -1756,6 +1758,7 @@ static struct attribute *platform_attributes[] = {
 	&dev_attr_cardr.attr,
 	&dev_attr_touchpad.attr,
 	&dev_attr_lid_resume.attr,
+	&dev_attr_als_enable.attr,
 	NULL
 };
 
@@ -1776,6 +1779,8 @@ static umode_t asus_sysfs_is_visible(struct kobject *kobj,
 		devid = ASUS_WMI_DEVID_TOUCHPAD;
 	else if (attr == &dev_attr_lid_resume.attr)
 		devid = ASUS_WMI_DEVID_LID_RESUME;
+	else if (attr == &dev_attr_als_enable.attr)
+		devid = ASUS_WMI_DEVID_ALS_ENABLE;
 
 	if (devid != -1)
 		ok = !(asus_wmi_get_devstate_simple(asus, devid) < 0);

commit f5b3f66548b72f8ab77fea5867bd45ad91ed2143
Author: Geliang Tang <geliangtang@163.com>
Date:   Tue Dec 22 22:16:13 2015 +0800

    asus-wmi: drop to_platform_driver macro
    
    to_platform_driver has been defined in platform_device.h, so drop
    this repetitive macro in asus-wmi.c.
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index f96f7b865267..a96630d52346 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -56,9 +56,6 @@ MODULE_AUTHOR("Corentin Chary <corentin.chary@gmail.com>, "
 MODULE_DESCRIPTION("Asus Generic WMI Driver");
 MODULE_LICENSE("GPL");
 
-#define to_platform_driver(drv)					\
-	(container_of((drv), struct platform_driver, driver))
-
 #define to_asus_wmi_driver(pdrv)					\
 	(container_of((pdrv), struct asus_wmi_driver, platform_driver))
 

commit 4bfc89d26a0d177a79574fc1b54fc728e3bb8b4e
Merge: a30b7ca28949 b82983401684
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 13 21:47:06 2015 -0800

    Merge tag 'platform-drivers-x86-v4.4-2' of git://git.infradead.org/users/dvhart/linux-platform-drivers-x86
    
    Pull another x86 platform driver update from Darren Hart:
     "Support for the unfortunately rather unique ESC key on the Ideapad
      Yoga 3 and two DMI matches for rfkill support.  Solitary fix for
      potential missed errors for asus-wmi.  Downgrade a thinkpad_acpi
      message to info.
    
      asus-wmi:
       - fix error handling in store_sys_wmi()
    
      ideapad-laptop:
       - Add Lenovo Yoga 900 to no_hw_rfkill dmi list
       - include Yoga 3 1170 in add rfkill whitelist
       - add support for Yoga 3 ESC key
    
      thinkpad_acpi:
       - Don't yell on unsupported brightness interfaces"
    
    * tag 'platform-drivers-x86-v4.4-2' of git://git.infradead.org/users/dvhart/linux-platform-drivers-x86:
      asus-wmi: fix error handling in store_sys_wmi()
      ideapad-laptop: Add Lenovo Yoga 900 to no_hw_rfkill dmi list
      ideapad-laptop: include Yoga 3 1170 in add rfkill whitelist
      ideapad-laptop: add support for Yoga 3 ESC key
      thinkpad_acpi: Don't yell on unsupported brightness interfaces

commit baf51c43926ec9aa42ef9d33ca6ee9e3e043aebe
Merge: c5a37883f42b 7c5b2759bf8c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 11 09:03:01 2015 -0800

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/rzhang/linux
    
    Pull thermal updates from Zhang Rui:
    
     - Implement generic devfreq cooling mechanism through frequency
       reduction for devices using devfreq.  From rjan Eide and Javi
       Merino.
    
     - Introduce OMAP3 support on TI SoC thermal driver.  From Pavel Mack
       and Eduardo Valentin.
    
     - A bounch of small fixes on devfreq_cooling, Exynos, IMX, Armada, and
       Rockchip thermal drivers.
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/rzhang/linux: (24 commits)
      thermal: exynos: Directly return 0 instead of using local ret variable
      thermal: exynos: Remove unneeded semicolon
      thermal: exynos: Use IS_ERR() because regulator cannot be NULL
      thermal: exynos: Fix first temperature read after registering sensor
      thermal: exynos: Fix unbalanced regulator disable on probe failure
      devfreq_cooling: return on allocation failure
      thermal: rockchip: support the sleep pinctrl state to avoid glitches in s2r
      dt-bindings: rockchip-thermal: Add the pinctrl states in this document
      thermal: devfreq_cooling: Make power a u64
      thermal: devfreq_cooling: use a thermal_cooling_device for register and unregister
      thermal: underflow bug in imx_set_trip_temp()
      thermal: armada: Fix possible overflow in the Armada 380 thermal sensor formula
      thermal: imx: register irq handler later in probe
      thermal: rockhip: fix setting thermal shutdown polarity
      thermal: rockchip: fix handling of invalid readings
      devfreq_cooling: add trace information
      thermal: Add devfreq cooling
      PM / OPP: get the voltage for all OPPs
      tools/thermal: tmon: use pkg-config also for CFLAGS
      linux/thermal.h: rename KELVIN_TO_CELSIUS to DECI_KELVIN_TO_CELSIUS
      ...

commit b82983401684ba06fcf3fbafa63edf371c0d4775
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Nov 11 01:18:16 2015 +0300

    asus-wmi: fix error handling in store_sys_wmi()
    
    The asus_wmi_get_devstate_simple() returns 0-1 on success.  In theory
    according to static checkers, it can return either -EIO or -ENODEV on
    failure.  Currently the error handling code only handles -ENODEV and
    -EIO is treated as success.  Let's make it handle the -EIO error as
    well.
    
    It's possible that it can't actually return -EIO and this patch is not
    needed but in that case this patch is harmless and silences a static
    checker warning so it's still worth it.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 1f7d80ff8cb4..179eeee227b4 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1682,7 +1682,7 @@ static ssize_t store_sys_wmi(struct asus_wmi *asus, int devid,
 	int rv, err, value;
 
 	value = asus_wmi_get_devstate_simple(asus, devid);
-	if (value == -ENODEV)	/* Check device presence */
+	if (value < 0)
 		return value;
 
 	rv = parse_arg(buf, count, &value);

commit e866a2e3950fe2f708d5cc67d641b1725ef7a708
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Thu Oct 1 23:45:31 2015 +0200

    linux/thermal.h: rename KELVIN_TO_CELSIUS to DECI_KELVIN_TO_CELSIUS
    
    The macros KELVIN_TO_CELSIUS and CELSIUS_TO_KELVIN actually convert
    between deciKelvins and Celsius, so rename them to reflect that. While
    at it, use a statement expression in DECI_KELVIN_TO_CELSIUS to prevent
    expanding the argument multiple times and get rid of a few casts.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Acked-by: Darren Hart <dvhart@linux.intel.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index efbc3f0c592b..bb80f7a29496 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1318,7 +1318,7 @@ static ssize_t asus_hwmon_temp1(struct device *dev,
 	if (err < 0)
 		return err;
 
-	value = KELVIN_TO_CELSIUS((value & 0xFFFF)) * 1000;
+	value = DECI_KELVIN_TO_CELSIUS((value & 0xFFFF)) * 1000;
 
 	return sprintf(buf, "%d\n", value);
 }

commit 307340493f3d62935db0bd48a9909bb746ffef1e
Author: Oleksij Rempel <linux@rempel-privat.de>
Date:   Mon Sep 14 11:16:30 2015 +0200

    asus-wmi: restore kbd led level after resume
    
    Afters suspend/resume cycle with closed lid the kbd backlight level
    is lost. This patch will will restore this value to last known level.
    
    Signed-off-by: Oleksij Rempel <linux@rempel-privat.de>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index efbc3f0c592b..1f7d80ff8cb4 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -582,7 +582,7 @@ static void asus_wmi_led_exit(struct asus_wmi *asus)
 
 static int asus_wmi_led_init(struct asus_wmi *asus)
 {
-	int rv = 0;
+	int rv = 0, led_val;
 
 	asus->led_workqueue = create_singlethread_workqueue("led_workqueue");
 	if (!asus->led_workqueue)
@@ -602,9 +602,11 @@ static int asus_wmi_led_init(struct asus_wmi *asus)
 			goto error;
 	}
 
-	if (kbd_led_read(asus, NULL, NULL) >= 0) {
+	led_val = kbd_led_read(asus, NULL, NULL);
+	if (led_val >= 0) {
 		INIT_WORK(&asus->kbd_led_work, kbd_led_update);
 
+		asus->kbd_led_wk = led_val;
 		asus->kbd_led.name = "asus::kbd_backlight";
 		asus->kbd_led.brightness_set = kbd_led_set;
 		asus->kbd_led.brightness_get = kbd_led_get;
@@ -2160,6 +2162,16 @@ static int asus_hotk_thaw(struct device *device)
 	return 0;
 }
 
+static int asus_hotk_resume(struct device *device)
+{
+	struct asus_wmi *asus = dev_get_drvdata(device);
+
+	if (!IS_ERR_OR_NULL(asus->kbd_led.dev))
+		queue_work(asus->led_workqueue, &asus->kbd_led_work);
+
+	return 0;
+}
+
 static int asus_hotk_restore(struct device *device)
 {
 	struct asus_wmi *asus = dev_get_drvdata(device);
@@ -2190,6 +2202,8 @@ static int asus_hotk_restore(struct device *device)
 		bl = !asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_UWB);
 		rfkill_set_sw_state(asus->uwb.rfkill, bl);
 	}
+	if (!IS_ERR_OR_NULL(asus->kbd_led.dev))
+		queue_work(asus->led_workqueue, &asus->kbd_led_work);
 
 	return 0;
 }
@@ -2197,6 +2211,7 @@ static int asus_hotk_restore(struct device *device)
 static const struct dev_pm_ops asus_pm_ops = {
 	.thaw = asus_hotk_thaw,
 	.restore = asus_hotk_restore,
+	.resume = asus_hotk_resume,
 };
 
 static int asus_wmi_probe(struct platform_device *pdev)

commit 05fde26a943a9c55d8b498d97bb49d3d207e5069
Merge: 2d01eedf1d14 5ee7041e5bc0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 1 18:55:34 2015 -0700

    Merge tag 'platform-drivers-x86-v4.2-1' of git://git.infradead.org/users/dvhart/linux-platform-drivers-x86
    
    Pull x86 platform driver updates from Darren Hart:
     "Fairly routine update for platform-drivers-x86.
    
      Mostly fixes and cleanups, with a significant refactoring of toshiba*
      drivers.  Includes the addition of the dell-rbtn driver.
    
      Details:
    
      asus-wmi:
       - fan control
    
      dell*:
       - add Dell airplane mode switch driver
    
      ideapad-laptop:
       - platform rfkill fixes, and regression fix
    
      pvpanic:
       - handle missing _STA correctly
    
      toshiba*:
       - rafactor bluetooth support
       - haps documentation
       - driver cleanup
    
      other:
       - Use acpi_video_unregister_backlight instead of
         acpi_video_unregister in serveral drivers.
       - Orphan msi-wmi.
    
    * tag 'platform-drivers-x86-v4.2-1' of git://git.infradead.org/users/dvhart/linux-platform-drivers-x86: (24 commits)
      MAINTAINERS: Orphan x86 driver msi-wmi
      ideapad: fix software rfkill setting
      dell-laptop: Use dell-rbtn instead i8042 filter when possible
      dell-rbtn: Export notifier for other kernel modules
      dell-rbtn: Dell Airplane Mode Switch driver
      samsung-laptop: Use acpi_video_unregister_backlight instead of acpi_video_unregister
      asus-wmi: Use acpi_video_unregister_backlight instead of acpi_video_unregister
      apple_gmux: Use acpi_video_unregister_backlight instead of acpi_video_unregister
      pvpanic: handle missing _STA correctly
      ideapad_laptop: Lenovo G50-30 fix rfkill reports wireless blocked
      asus-wmi: add fan control
      Documentation/ABI: Add file describing the sysfs entries for toshiba_haps
      toshiba_haps: Make use of DEVICE_ATTR_{RW, WO} macros
      toshiba_haps: Replace sscanf with kstrtoint
      toshiba_acpi: Bump driver version to 0.22
      toshiba_acpi: Remove TOS_FAILURE check from some functions
      toshiba_acpi: Comments cleanup
      toshiba_acpi: Rename hci_{read, write}1 functions
      toshiba_acpi: Remove no longer needed hci_{read, write}2 functions
      toshiba_bluetooth: Change BT status message to debug
      ...

commit 62c4aa1a8d9ec3e7e9391ca46f8abf040499544e
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Jun 16 16:27:58 2015 +0200

    asus-wmi: Port to new backlight interface selection API
    
    Port the backlight selection logic to the new backlight interface
    selection API.
    
    This commit also removes various obsolete pr_xxx messages related to
    backlight interface selection. These are obsolete because they assume
    there is only a vendor or acpi backlight driver and no other choice.
    Also they are not necessary, if the user wants to know which backlight
    interfaces are registered a simple "ls /sys/class/backlight" suffices.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Darren Hart <dvhart@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 945145df67b8..6f8558f744a4 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1364,7 +1364,7 @@ static void asus_wmi_notify(u32 value, void *context)
 		code = ASUS_WMI_BRN_DOWN;
 
 	if (code == ASUS_WMI_BRN_DOWN || code == ASUS_WMI_BRN_UP) {
-		if (!acpi_video_backlight_support()) {
+		if (acpi_video_get_backlight_type() == acpi_backlight_vendor) {
 			asus_wmi_backlight_notify(asus, orig_code);
 			goto exit;
 		}
@@ -1772,17 +1772,16 @@ static int asus_wmi_add(struct platform_device *pdev)
 	   stop this from showing up */
 	chassis_type = dmi_get_system_info(DMI_CHASSIS_TYPE);
 	if (chassis_type && !strcmp(chassis_type, "3"))
-		acpi_video_dmi_promote_vendor();
+		acpi_video_set_dmi_backlight_type(acpi_backlight_vendor);
+
 	if (asus->driver->quirks->wmi_backlight_power)
-		acpi_video_dmi_promote_vendor();
-	if (!acpi_video_backlight_support()) {
-		pr_info("Disabling ACPI video driver\n");
-		acpi_video_unregister_backlight();
+		acpi_video_set_dmi_backlight_type(acpi_backlight_vendor);
+
+	if (acpi_video_get_backlight_type() == acpi_backlight_vendor) {
 		err = asus_wmi_backlight_init(asus);
 		if (err && err != -ENODEV)
 			goto fail_backlight;
-	} else
-		pr_info("Backlight controlled by ACPI video driver\n");
+	}
 
 	status = wmi_install_notify_handler(asus->driver->event_guid,
 					    asus_wmi_notify, asus);

commit 4c27febf8e51857e8981be060a31e1c5c0f9a2e7
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Jun 16 16:27:40 2015 +0200

    asus-wmi: Use acpi_video_unregister_backlight instead of acpi_video_unregister
    
    acpi_video_unregister() not only unregisters the acpi-video backlight
    interface but also unregisters the acpi video bus event listener, causing
    e.g. brightness hotkey presses to no longer generate keypress events.
    
    The unregistering of the acpi video bus event listener usually is
    undesirable, which by itself is a good reason to switch to
    acpi_video_unregister_backlight().
    
    Another problem with using acpi_video_unregister() rather then using
    acpi_video_unregister_backlight() is that on systems with an intel video
    opregion (most systems) and a wmi_backlight_power quirk, whether or not
    the acpi video bus event listener actually gets unregistered depends on
    module load ordering:
    
    Scenario a:
    1) acpi/video.ko gets loaded (*), does not do acpi_video_register as there
       is an intel opregion.
    2) intel.ko gets loaded, calls acpi_video_register() which registers both
       the listener and the acpi backlight interface
    3) asus-wmi.ko gets loaded, calls acpi_video_unregister() causing both
       the listener and the acpi backlight interface to unregister
    
    Scenario b:
    1) acpi/video.ko gets loaded (*), does not do acpi_video_register as there
       is an intel opregion.
    2) asus-wmi.ko gets loaded, calls acpi_video_dmi_promote_vendor(),
       calls acpi_video_unregister(), which is a nop since acpi_video_register
       has not yet been called
    2) intel.ko gets loaded, calls acpi_video_register() which registers
       the listener, but does not register the acpi backlight interface due to
       the call to the preciding call to acpi_video_dmi_promote_vendor()
    
    *) acpi/video.ko always loads first as both other modules depend on it.
    
    So we end up with or without an acpi video bus event listener depending
    on module load ordering, not good.
    
    Switching to using acpi_video_unregister_backlight() means that independ
    of ordering we will always have an acpi video bus event listener fixing
    this.
    
    Note that this commit means that systems without an intel video opregion,
    and systems which were hitting scenario a wrt module load ordering, are
    now getting an acpi video bus event listener while before they were not!
    
    On some systems this may cause the brightness hotkeys to start generating
    keypresses while before they were not (good), while on other systems this
    may cause the brightness hotkeys to generate multiple keypress events for
    a single press (not so good). Since on most systems the acpi video bus is
    the canonical source for brightness events I believe that the latter case
    will needs to be handled on a case by case basis by filtering out the
    duplicate keypresses at the other source for them.
    
    Cc: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Darren Hart <dvhart@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 7543a56e0f45..945145df67b8 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1777,7 +1777,7 @@ static int asus_wmi_add(struct platform_device *pdev)
 		acpi_video_dmi_promote_vendor();
 	if (!acpi_video_backlight_support()) {
 		pr_info("Disabling ACPI video driver\n");
-		acpi_video_unregister();
+		acpi_video_unregister_backlight();
 		err = asus_wmi_backlight_init(asus);
 		if (err && err != -ENODEV)
 			goto fail_backlight;

commit 5f770658747ee1f5730c9cb853e8957d7ba22e1b
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Mon Jun 1 11:25:07 2015 +0200

    asus-wmi: Use acpi_video_unregister_backlight instead of acpi_video_unregister
    
    acpi_video_unregister() not only unregisters the acpi-video backlight
    interface but also unregisters the acpi video bus event listener, causing
    e.g. brightness hotkey presses to no longer generate keypress events.
    
    The unregistering of the acpi video bus event listener usually is
    undesirable, which by itself is a good reason to switch to
    acpi_video_unregister_backlight().
    
    Another problem with using acpi_video_unregister() rather then using
    acpi_video_unregister_backlight() is that on systems with an intel video
    opregion (most systems) and a wmi_backlight_power quirk, whether or not
    the acpi video bus event listener actually gets unregistered depends on
    module load ordering:
    
    Scenario a:
    1) acpi/video.ko gets loaded (*), does not do acpi_video_register as there
       is an intel opregion.
    2) intel.ko gets loaded, calls acpi_video_register() which registers both
       the listener and the acpi backlight interface
    3) asus-wmi.ko gets loaded, calls acpi_video_unregister() causing both
       the listener and the acpi backlight interface to unregister
    
    Scenario b:
    1) acpi/video.ko gets loaded (*), does not do acpi_video_register as there
       is an intel opregion.
    2) asus-wmi.ko gets loaded, calls acpi_video_dmi_promote_vendor(),
       calls acpi_video_unregister(), which is a nop since acpi_video_register
       has not yet been called
    2) intel.ko gets loaded, calls acpi_video_register() which registers
       the listener, but does not register the acpi backlight interface due to
       the call to the preciding call to acpi_video_dmi_promote_vendor()
    
    *) acpi/video.ko always loads first as both other modules depend on it.
    
    So we end up with or without an acpi video bus event listener depending
    on module load ordering, not good.
    
    Switching to using acpi_video_unregister_backlight() means that independ
    of ordering we will always have an acpi video bus event listener fixing
    this.
    
    Note that this commit means that systems without an intel video opregion,
    and systems which were hitting scenario a wrt module load ordering, are
    now getting an acpi video bus event listener while before they were not!
    
    On some systems this may cause the brightness hotkeys to start generating
    keypresses while before they were not (good), while on other systems this
    may cause the brightness hotkeys to generate multiple keypress events for
    a single press (not so good). Since on most systems the acpi video bus is
    the canonical source for brightness events I believe that the latter case
    will needs to be handled on a case by case basis by filtering out the
    duplicate keypresses at the other source for them.
    
    Cc: acpi4asus-user@lists.sourceforge.net
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Corentin Chary <corentin.chary@gmail.com)
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 9b82364e0f3c..75de0feca13b 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -2078,7 +2078,7 @@ static int asus_wmi_add(struct platform_device *pdev)
 		acpi_video_dmi_promote_vendor();
 	if (!acpi_video_backlight_support()) {
 		pr_info("Disabling ACPI video driver\n");
-		acpi_video_unregister();
+		acpi_video_unregister_backlight();
 		err = asus_wmi_backlight_init(asus);
 		if (err && err != -ENODEV)
 			goto fail_backlight;

commit 53e755c21afc230dd93fddda5a2db9609e6f07d0
Author: Kast Bernd <kastbernd@gmx.de>
Date:   Wed May 13 16:24:16 2015 +0200

    asus-wmi: add fan control
    
    This patch is partially based on Felipe Contrera's earlier patch, that
    was discussed here: https://lkml.org/lkml/2013/10/8/800
    Some problems of that patch are solved, now:
    
    1) The main obstacle for the earlier patch seemed to be the use of
    virt_to_phys, which is accepted, now
    
    2) random memory corruption occurred on my notebook, thus DMA-able memory
    is allocated now, which solves this problem
    
    3) hwmon interface is used instead of the thermal interface, as a
    hwmon device is already set up by this driver and seemed more
    appropriate than the thermal interface
    
    4) Calling the ACPI-functions was modularized thus it's possible to call
    some multifunctions easily, now (by using
    asus_wmi_evaluate_method_agfn).
    
    Unfortunately the WMI doesn't support controlling both fans on
    a dual-fan notebook because of an restriction in the acpi-method
    "SFNS", that is callable through the wmi. If "SFNV" would be called
    directly even dual fan configurations could be controlled, but not by using
    wmi.
    
    Speed readings only work on auto-mode, thus "-1" will be reported in
    manual mode.
    Additionally the speed readings are reported as hundreds of RPM thus
    they are not too precise.
    
    This patch is tested only on one notebook (N551JK) but a similar module,
    that contained some code to try to control the second fan also, was
    reported to work on an UX32VD, at least for the first fan.
    
    As Felipe already mentioned the low-level functions are described here:
    http://forum.notebookreview.com/threads/fan-control-on-asus-prime-ux31-ux31a-ux32a-ux32vd.705656/
    
    Signed-off-by: Kast Bernd <kastbernd@gmx.de>
    Acked-by: Corentin Chary <corentin.chary@gmail.com>
    Cc: Corentin Chary <corentin.chary@gmail.com>
    Cc: Darren Hart <dvhart@infradead.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 7543a56e0f45..9b82364e0f3c 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -78,6 +78,7 @@ MODULE_LICENSE("GPL");
 #define ASUS_WMI_METHODID_GPID		0x44495047 /* Get Panel ID?? (Resol) */
 #define ASUS_WMI_METHODID_QMOD		0x444F4D51 /* Quiet MODe */
 #define ASUS_WMI_METHODID_SPLV		0x4C425053 /* Set Panel Light Value */
+#define ASUS_WMI_METHODID_AGFN		0x4E464741 /* FaN? */
 #define ASUS_WMI_METHODID_SFUN		0x4E554653 /* FUNCtionalities */
 #define ASUS_WMI_METHODID_SDSP		0x50534453 /* Set DiSPlay output */
 #define ASUS_WMI_METHODID_GDSP		0x50534447 /* Get DiSPlay output */
@@ -150,11 +151,37 @@ MODULE_LICENSE("GPL");
 #define ASUS_WMI_DSTS_BRIGHTNESS_MASK	0x000000FF
 #define ASUS_WMI_DSTS_MAX_BRIGTH_MASK	0x0000FF00
 
+#define ASUS_FAN_DESC			"cpu_fan"
+#define ASUS_FAN_MFUN			0x13
+#define ASUS_FAN_SFUN_READ		0x06
+#define ASUS_FAN_SFUN_WRITE		0x07
+#define ASUS_FAN_CTRL_MANUAL		1
+#define ASUS_FAN_CTRL_AUTO		2
+
 struct bios_args {
 	u32 arg0;
 	u32 arg1;
 } __packed;
 
+/*
+ * Struct that's used for all methods called via AGFN. Naming is
+ * identically to the AML code.
+ */
+struct agfn_args {
+	u16 mfun; /* probably "Multi-function" to be called */
+	u16 sfun; /* probably "Sub-function" to be called */
+	u16 len;  /* size of the hole struct, including subfunction fields */
+	u8 stas;  /* not used by now */
+	u8 err;   /* zero on success */
+} __packed;
+
+/* struct used for calling fan read and write methods */
+struct fan_args {
+	struct agfn_args agfn;	/* common fields */
+	u8 fan;			/* fan number: 0: set auto mode 1: 1st fan */
+	u32 speed;		/* read: RPM/100 - write: 0-255 */
+} __packed;
+
 /*
  * <platform>/    - debugfs root directory
  *   dev_id      - current dev_id
@@ -204,6 +231,10 @@ struct asus_wmi {
 	struct asus_rfkill gps;
 	struct asus_rfkill uwb;
 
+	bool asus_hwmon_fan_manual_mode;
+	int asus_hwmon_num_fans;
+	int asus_hwmon_pwm;
+
 	struct hotplug_slot *hotplug_slot;
 	struct mutex hotplug_lock;
 	struct mutex wmi_lock;
@@ -294,6 +325,36 @@ static int asus_wmi_evaluate_method(u32 method_id, u32 arg0, u32 arg1,
 	return 0;
 }
 
+static int asus_wmi_evaluate_method_agfn(const struct acpi_buffer args)
+{
+	struct acpi_buffer input;
+	u64 phys_addr;
+	u32 retval;
+	u32 status = -1;
+
+	/*
+	 * Copy to dma capable address otherwise memory corruption occurs as
+	 * bios has to be able to access it.
+	 */
+	input.pointer = kzalloc(args.length, GFP_DMA | GFP_KERNEL);
+	input.length = args.length;
+	if (!input.pointer)
+		return -ENOMEM;
+	phys_addr = virt_to_phys(input.pointer);
+	memcpy(input.pointer, args.pointer, args.length);
+
+	status = asus_wmi_evaluate_method(ASUS_WMI_METHODID_AGFN,
+					phys_addr, 0, &retval);
+	if (!status)
+		memcpy(args.pointer, input.pointer, args.length);
+
+	kfree(input.pointer);
+	if (status)
+		return -ENXIO;
+
+	return retval;
+}
+
 static int asus_wmi_get_devstate(struct asus_wmi *asus, u32 dev_id, u32 *retval)
 {
 	return asus_wmi_evaluate_method(asus->dsts_id, dev_id, 0, retval);
@@ -1022,35 +1083,228 @@ static int asus_wmi_rfkill_init(struct asus_wmi *asus)
 /*
  * Hwmon device
  */
-static ssize_t asus_hwmon_pwm1(struct device *dev,
-			       struct device_attribute *attr,
-			       char *buf)
+static int asus_hwmon_agfn_fan_speed_read(struct asus_wmi *asus, int fan,
+					  int *speed)
+{
+	struct fan_args args = {
+		.agfn.len = sizeof(args),
+		.agfn.mfun = ASUS_FAN_MFUN,
+		.agfn.sfun = ASUS_FAN_SFUN_READ,
+		.fan = fan,
+		.speed = 0,
+	};
+	struct acpi_buffer input = { (acpi_size) sizeof(args), &args };
+	int status;
+
+	if (fan != 1)
+		return -EINVAL;
+
+	status = asus_wmi_evaluate_method_agfn(input);
+
+	if (status || args.agfn.err)
+		return -ENXIO;
+
+	if (speed)
+		*speed = args.speed;
+
+	return 0;
+}
+
+static int asus_hwmon_agfn_fan_speed_write(struct asus_wmi *asus, int fan,
+				     int *speed)
+{
+	struct fan_args args = {
+		.agfn.len = sizeof(args),
+		.agfn.mfun = ASUS_FAN_MFUN,
+		.agfn.sfun = ASUS_FAN_SFUN_WRITE,
+		.fan = fan,
+		.speed = speed ?  *speed : 0,
+	};
+	struct acpi_buffer input = { (acpi_size) sizeof(args), &args };
+	int status;
+
+	/* 1: for setting 1st fan's speed 0: setting auto mode */
+	if (fan != 1 && fan != 0)
+		return -EINVAL;
+
+	status = asus_wmi_evaluate_method_agfn(input);
+
+	if (status || args.agfn.err)
+		return -ENXIO;
+
+	if (speed && fan == 1)
+		asus->asus_hwmon_pwm = *speed;
+
+	return 0;
+}
+
+/*
+ * Check if we can read the speed of one fan. If true we assume we can also
+ * control it.
+ */
+static int asus_hwmon_get_fan_number(struct asus_wmi *asus, int *num_fans)
+{
+	int status;
+	int speed = 0;
+
+	*num_fans = 0;
+
+	status = asus_hwmon_agfn_fan_speed_read(asus, 1, &speed);
+	if (!status)
+		*num_fans = 1;
+
+	return 0;
+}
+
+static int asus_hwmon_fan_set_auto(struct asus_wmi *asus)
+{
+	int status;
+
+	status = asus_hwmon_agfn_fan_speed_write(asus, 0, NULL);
+	if (status)
+		return -ENXIO;
+
+	asus->asus_hwmon_fan_manual_mode = false;
+
+	return 0;
+}
+
+static int asus_hwmon_fan_rpm_show(struct device *dev, int fan)
 {
 	struct asus_wmi *asus = dev_get_drvdata(dev);
-	u32 value;
+	int value;
+	int ret;
+
+	/* no speed readable on manual mode */
+	if (asus->asus_hwmon_fan_manual_mode)
+		return -ENXIO;
+
+	ret = asus_hwmon_agfn_fan_speed_read(asus, fan+1, &value);
+	if (ret) {
+		pr_warn("reading fan speed failed: %d\n", ret);
+		return -ENXIO;
+	}
+
+	return value;
+}
+
+static void asus_hwmon_pwm_show(struct asus_wmi *asus, int fan, int *value)
+{
 	int err;
 
-	err = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_FAN_CTRL, &value);
+	if (asus->asus_hwmon_pwm >= 0) {
+		*value = asus->asus_hwmon_pwm;
+		return;
+	}
 
+	err = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_FAN_CTRL, value);
 	if (err < 0)
-		return err;
+		return;
 
-	value &= 0xFF;
-
-	if (value == 1) /* Low Speed */
-		value = 85;
-	else if (value == 2)
-		value = 170;
-	else if (value == 3)
-		value = 255;
-	else if (value != 0) {
-		pr_err("Unknown fan speed %#x\n", value);
-		value = -1;
+	*value &= 0xFF;
+
+	if (*value == 1) /* Low Speed */
+		*value = 85;
+	else if (*value == 2)
+		*value = 170;
+	else if (*value == 3)
+		*value = 255;
+	else if (*value) {
+		pr_err("Unknown fan speed %#x\n", *value);
+		*value = -1;
 	}
+}
+
+static ssize_t pwm1_show(struct device *dev,
+			       struct device_attribute *attr,
+			       char *buf)
+{
+	struct asus_wmi *asus = dev_get_drvdata(dev);
+	int value;
+
+	asus_hwmon_pwm_show(asus, 0, &value);
 
 	return sprintf(buf, "%d\n", value);
 }
 
+static ssize_t pwm1_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count) {
+	struct asus_wmi *asus = dev_get_drvdata(dev);
+	int value;
+	int state;
+	int ret;
+
+	ret = kstrtouint(buf, 10, &value);
+
+	if (ret)
+		return ret;
+
+	value = clamp(value, 0, 255);
+
+	state = asus_hwmon_agfn_fan_speed_write(asus, 1, &value);
+	if (state)
+		pr_warn("Setting fan speed failed: %d\n", state);
+	else
+		asus->asus_hwmon_fan_manual_mode = true;
+
+	return count;
+}
+
+static ssize_t fan1_input_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	int value = asus_hwmon_fan_rpm_show(dev, 0);
+
+	return sprintf(buf, "%d\n", value < 0 ? -1 : value*100);
+
+}
+
+static ssize_t pwm1_enable_show(struct device *dev,
+						 struct device_attribute *attr,
+						 char *buf)
+{
+	struct asus_wmi *asus = dev_get_drvdata(dev);
+
+	if (asus->asus_hwmon_fan_manual_mode)
+		return sprintf(buf, "%d\n", ASUS_FAN_CTRL_MANUAL);
+
+	return sprintf(buf, "%d\n", ASUS_FAN_CTRL_AUTO);
+}
+
+static ssize_t pwm1_enable_store(struct device *dev,
+						  struct device_attribute *attr,
+						  const char *buf, size_t count)
+{
+	struct asus_wmi *asus = dev_get_drvdata(dev);
+	int status = 0;
+	int state;
+	int ret;
+
+	ret = kstrtouint(buf, 10, &state);
+
+	if (ret)
+		return ret;
+
+	if (state == ASUS_FAN_CTRL_MANUAL)
+		asus->asus_hwmon_fan_manual_mode = true;
+	else
+		status = asus_hwmon_fan_set_auto(asus);
+
+	if (status)
+		return status;
+
+	return count;
+}
+
+static ssize_t fan1_label_show(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	return sprintf(buf, "%s\n", ASUS_FAN_DESC);
+}
+
 static ssize_t asus_hwmon_temp1(struct device *dev,
 				struct device_attribute *attr,
 				char *buf)
@@ -1069,11 +1323,21 @@ static ssize_t asus_hwmon_temp1(struct device *dev,
 	return sprintf(buf, "%d\n", value);
 }
 
-static DEVICE_ATTR(pwm1, S_IRUGO, asus_hwmon_pwm1, NULL);
+/* Fan1 */
+static DEVICE_ATTR_RW(pwm1);
+static DEVICE_ATTR_RW(pwm1_enable);
+static DEVICE_ATTR_RO(fan1_input);
+static DEVICE_ATTR_RO(fan1_label);
+
+/* Temperature */
 static DEVICE_ATTR(temp1_input, S_IRUGO, asus_hwmon_temp1, NULL);
 
 static struct attribute *hwmon_attributes[] = {
 	&dev_attr_pwm1.attr,
+	&dev_attr_pwm1_enable.attr,
+	&dev_attr_fan1_input.attr,
+	&dev_attr_fan1_label.attr,
+
 	&dev_attr_temp1_input.attr,
 	NULL
 };
@@ -1084,19 +1348,28 @@ static umode_t asus_hwmon_sysfs_is_visible(struct kobject *kobj,
 	struct device *dev = container_of(kobj, struct device, kobj);
 	struct platform_device *pdev = to_platform_device(dev->parent);
 	struct asus_wmi *asus = platform_get_drvdata(pdev);
-	bool ok = true;
 	int dev_id = -1;
+	int fan_attr = -1;
 	u32 value = ASUS_WMI_UNSUPPORTED_METHOD;
+	bool ok = true;
 
 	if (attr == &dev_attr_pwm1.attr)
 		dev_id = ASUS_WMI_DEVID_FAN_CTRL;
 	else if (attr == &dev_attr_temp1_input.attr)
 		dev_id = ASUS_WMI_DEVID_THERMAL_CTRL;
 
+
+	if (attr == &dev_attr_fan1_input.attr
+	    || attr == &dev_attr_fan1_label.attr
+	    || attr == &dev_attr_pwm1.attr
+	    || attr == &dev_attr_pwm1_enable.attr) {
+		fan_attr = 1;
+	}
+
 	if (dev_id != -1) {
 		int err = asus_wmi_get_devstate(asus, dev_id, &value);
 
-		if (err < 0)
+		if (err < 0 && fan_attr == -1)
 			return 0; /* can't return negative here */
 	}
 
@@ -1112,10 +1385,16 @@ static umode_t asus_hwmon_sysfs_is_visible(struct kobject *kobj,
 		if (value == ASUS_WMI_UNSUPPORTED_METHOD || value & 0xFFF80000
 		    || (!asus->sfun && !(value & ASUS_WMI_DSTS_PRESENCE_BIT)))
 			ok = false;
+		else
+			ok = fan_attr <= asus->asus_hwmon_num_fans;
 	} else if (dev_id == ASUS_WMI_DEVID_THERMAL_CTRL) {
 		/* If value is zero, something is clearly wrong */
-		if (value == 0)
+		if (!value)
 			ok = false;
+	} else if (fan_attr <= asus->asus_hwmon_num_fans && fan_attr != -1) {
+		ok = true;
+	} else {
+		ok = false;
 	}
 
 	return ok ? attr->mode : 0;
@@ -1723,6 +2002,25 @@ static int asus_wmi_debugfs_init(struct asus_wmi *asus)
 	return -ENOMEM;
 }
 
+static int asus_wmi_fan_init(struct asus_wmi *asus)
+{
+	int status;
+
+	asus->asus_hwmon_pwm = -1;
+	asus->asus_hwmon_num_fans = -1;
+	asus->asus_hwmon_fan_manual_mode = false;
+
+	status = asus_hwmon_get_fan_number(asus, &asus->asus_hwmon_num_fans);
+	if (status) {
+		asus->asus_hwmon_num_fans = 0;
+		pr_warn("Could not determine number of fans: %d\n", status);
+		return -ENXIO;
+	}
+
+	pr_info("Number of fans: %d\n", asus->asus_hwmon_num_fans);
+	return 0;
+}
+
 /*
  * WMI Driver
  */
@@ -1756,6 +2054,9 @@ static int asus_wmi_add(struct platform_device *pdev)
 	if (err)
 		goto fail_input;
 
+	err = asus_wmi_fan_init(asus); /* probably no problems on error */
+	asus_hwmon_fan_set_auto(asus);
+
 	err = asus_wmi_hwmon_init(asus);
 	if (err)
 		goto fail_hwmon;
@@ -1832,6 +2133,7 @@ static int asus_wmi_remove(struct platform_device *device)
 	asus_wmi_rfkill_exit(asus);
 	asus_wmi_debugfs_exit(asus);
 	asus_wmi_platform_exit(asus);
+	asus_hwmon_fan_set_auto(asus);
 
 	kfree(asus);
 	return 0;

commit 0098181016dd45c1c417656ba36b87d9101cbb83
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Mon Nov 24 20:30:29 2014 +0100

    platform: x86: Deletion of checks before backlight_device_unregister()
    
    The backlight_device_unregister() function tests whether its argument is NULL
    and then returns immediately. Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    For msi-wmi.c:
    Acked-by: Anisse Astier <anisse@astier.eu>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 21fc932da3a1..7543a56e0f45 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1308,8 +1308,7 @@ static int asus_wmi_backlight_init(struct asus_wmi *asus)
 
 static void asus_wmi_backlight_exit(struct asus_wmi *asus)
 {
-	if (asus->backlight_device)
-		backlight_device_unregister(asus->backlight_device);
+	backlight_device_unregister(asus->backlight_device);
 
 	asus->backlight_device = NULL;
 }

commit f515623cac706e616c48778e5e611020dff44e19
Author: AceLan Kao <acelan.kao@canonical.com>
Date:   Wed Jul 9 16:18:18 2014 +0800

    asus-wmi: control wlan-led if wapf > 0
    
    Wifi will be controlled by asus-wmi driver when wapf > 0
    So, controls the wifi-led when wapf > 0
    
    Signed-off-by: AceLan Kao <acelan.kao@canonical.com>
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 8a8841668992..21fc932da3a1 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -555,7 +555,7 @@ static int asus_wmi_led_init(struct asus_wmi *asus)
 			goto error;
 	}
 
-	if (wlan_led_presence(asus) && (asus->driver->quirks->wapf == 4)) {
+	if (wlan_led_presence(asus) && (asus->driver->quirks->wapf > 0)) {
 		INIT_WORK(&asus->wlan_led_work, wlan_led_update);
 
 		asus->wlan_led.name = "asus::wlan";
@@ -885,7 +885,7 @@ static int asus_new_rfkill(struct asus_wmi *asus,
 		return -EINVAL;
 
 	if ((dev_id == ASUS_WMI_DEVID_WLAN) &&
-			(asus->driver->quirks->wapf == 4))
+			(asus->driver->quirks->wapf > 0))
 		rfkill_set_led_trigger_name(*rfkill, "asus-wlan");
 
 	rfkill_init_sw_state(*rfkill, !result);

commit 86ac2735ae09ab012da358d4dff73f3bcad50583
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Jul 8 10:47:22 2014 +0200

    asus-wmi: backlight_init: Stop treating -ENODEV as if its not an error
    
    When bl_power support got added to asus-wmi, the error handling for it was
    written to ignore -ENODEV, to avoid not registering a backlight interface for
    models which have no bl_power control, but do have brightness control.
    
    At the same time the error handling for brightness_max was modified to do the
    same, this is wrong, when there is no brightness_max asus-wmi should not
    register a backlight interface.
    
    Note the caller of asus_wmi_backlight_init already special cases -ENODEV,
    and will not cause the wmi driver regristration to fail because of a
    -ENODEV return from asus_wmi_backlight_init.
    
    https://bugzilla.redhat.com/show_bug.cgi?id=1097436
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 70aec19f50f3..8a8841668992 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1271,10 +1271,7 @@ static int asus_wmi_backlight_init(struct asus_wmi *asus)
 	int power;
 
 	max = read_brightness_max(asus);
-
-	if (max == -ENODEV)
-		max = 0;
-	else if (max < 0)
+	if (max < 0)
 		return max;
 
 	power = read_backlight_power(asus);

commit d8c66f62992dac3a92cbc5f16791557100c7a068
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Jul 8 10:47:21 2014 +0200

    asus-wmi: Disable acpi-video backlight on desktop machines
    
    Some Asus motherboards for desktop PC-s export an acpi-video interface
    advertising backlight support. Test the dmi chassis-type and tell acpi-video
    to not register a backlight interface on desktops.
    
    https://bugzilla.redhat.com/show_bug.cgi?id=1097436
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 3c6ccedc82b6..70aec19f50f3 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -46,6 +46,7 @@
 #include <linux/platform_device.h>
 #include <linux/thermal.h>
 #include <linux/acpi.h>
+#include <linux/dmi.h>
 #include <acpi/video.h>
 
 #include "asus-wmi.h"
@@ -1734,6 +1735,7 @@ static int asus_wmi_add(struct platform_device *pdev)
 	struct platform_driver *pdrv = to_platform_driver(pdev->dev.driver);
 	struct asus_wmi_driver *wdrv = to_asus_wmi_driver(pdrv);
 	struct asus_wmi *asus;
+	const char *chassis_type;
 	acpi_status status;
 	int err;
 	u32 result;
@@ -1770,6 +1772,11 @@ static int asus_wmi_add(struct platform_device *pdev)
 	if (err)
 		goto fail_rfkill;
 
+	/* Some Asus desktop boards export an acpi-video backlight interface,
+	   stop this from showing up */
+	chassis_type = dmi_get_system_info(DMI_CHASSIS_TYPE);
+	if (chassis_type && !strcmp(chassis_type, "3"))
+		acpi_video_dmi_promote_vendor();
 	if (asus->driver->quirks->wmi_backlight_power)
 		acpi_video_dmi_promote_vendor();
 	if (!acpi_video_backlight_support()) {

commit 8ad3be1eacbe252b93f5a0478413774308f3dbfb
Author: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
Date:   Sun Jun 1 14:58:52 2014 +0200

    platform: x86: asus-wmi.c: Cleaning up uninitialized variables
    
    There is a risk that the variable will be used without being initialized.
    
    This was largely found by using a static code analysis program called cppcheck.
    
    Signed-off-by: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 91ef69a52263..3c6ccedc82b6 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -266,7 +266,7 @@ static int asus_wmi_evaluate_method(u32 method_id, u32 arg0, u32 arg1,
 	struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
 	acpi_status status;
 	union acpi_object *obj;
-	u32 tmp;
+	u32 tmp = 0;
 
 	status = wmi_evaluate_method(ASUS_WMI_MGMT_GUID, 1, method_id,
 				     &input, &output);
@@ -277,8 +277,6 @@ static int asus_wmi_evaluate_method(u32 method_id, u32 arg0, u32 arg1,
 	obj = (union acpi_object *)output.pointer;
 	if (obj && obj->type == ACPI_TYPE_INTEGER)
 		tmp = (u32) obj->integer.value;
-	else
-		tmp = 0;
 
 	if (retval)
 		*retval = tmp;

commit c893d133eaccdda2516a3e71cd05a7dac2e14b00
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Fri May 30 11:01:03 2014 +0800

    PCI: Make pci_bus_add_device() void
    
    pci_bus_add_device() always returns 0, so there's no point in returning
    anything at all.  Make it a void function and remove the tests of the
    return value from the callers.
    
    [bhelgaas: changelog, remove unused "err" from i82875p_setup_overfl_dev()]
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index c5e082fb82fa..91ef69a52263 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -642,8 +642,7 @@ static void asus_rfkill_hotplug(struct asus_wmi *asus)
 			dev = pci_scan_single_device(bus, 0);
 			if (dev) {
 				pci_bus_assign_resources(bus);
-				if (pci_bus_add_device(dev))
-					pr_err("Unable to hotplug wifi\n");
+				pci_bus_add_device(dev);
 			}
 		} else {
 			dev = pci_get_slot(bus, 0);

commit b7a8399edfd7ad3da36d51513ea30a4708b02b52
Merge: 30c867eebfbd b4b0b4a9e039
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 29 18:54:05 2014 -0800

    Merge branch 'for_linus' of git://cavan.codon.org.uk/platform-drivers-x86
    
    Pull x86 platform drivers update from Matthew Garrett:
     "Nothing amazingly special here.  Some cleanups, a new driver to
      support a single button on some new HPs, a tiny amount of hardware
      enablement"
    
    * 'for_linus' of git://cavan.codon.org.uk/platform-drivers-x86:
      ipc: add intel-mid's pci id macros
      hp-wireless: new driver for hp wireless button for Windows 8
      toshiba_acpi: Support RFKILL hotkey scancode
      hp_accel: Add a new PnP ID HPQ6007 for new HP laptops
      sony-laptop: remove unnecessary assigment of len
      fujitsu-laptop: fix error return code
      dell-laptop: Only install the i8042 filter when rfkill is active
      X86 platform: New BayTrail IOSF-SB MBI driver
      drivers: platform: Include appropriate header file in mxm-wmi.c
      drivers: platform: Mark functions as static in hp_accel.c
      dell-laptop: rkill whitelist Precision models
      ipc: simplify platform data approach
      asus-wmi: Convert to use devm_hwmon_device_register_with_groups
      compal-laptop: Use devm_hwmon_device_register_with_groups
      compal-laptop: Replace SENSOR_DEVICE_ATTR with DEVICE_ATTR
      eeepc-laptop: Convert to use devm_hwmon_device_register_with_groups
      compal-laptop: Use devm_kzalloc to allocate local data structure
      dell-laptop: fix to return error code in dell_send_intensity()

commit 09da8dfa98682d871987145ed11e3232accac860
Merge: 3aacd625f201 7744064731a9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 24 15:51:02 2014 -0800

    Merge tag 'pm+acpi-3.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI and power management updates from Rafael Wysocki:
     "As far as the number of commits goes, the top spot belongs to ACPI
      this time with cpufreq in the second position and a handful of PM
      core, PNP and cpuidle updates.  They are fixes and cleanups mostly, as
      usual, with a couple of new features in the mix.
    
      The most visible change is probably that we will create struct
      acpi_device objects (visible in sysfs) for all devices represented in
      the ACPI tables regardless of their status and there will be a new
      sysfs attribute under those objects allowing user space to check that
      status via _STA.
    
      Consequently, ACPI device eject or generally hot-removal will not
      delete those objects, unless the table containing the corresponding
      namespace nodes is unloaded, which is extremely rare.  Also ACPI
      container hotplug will be handled quite a bit differently and cpufreq
      will support CPU boost ("turbo") generically and not only in the
      acpi-cpufreq driver.
    
      Specifics:
    
       - ACPI core changes to make it create a struct acpi_device object for
         every device represented in the ACPI tables during all namespace
         scans regardless of the current status of that device.  In
         accordance with this, ACPI hotplug operations will not delete those
         objects, unless the underlying ACPI tables go away.
    
       - On top of the above, new sysfs attribute for ACPI device objects
         allowing user space to check device status by triggering the
         execution of _STA for its ACPI object.  From Srinivas Pandruvada.
    
       - ACPI core hotplug changes reducing code duplication, integrating
         the PCI root hotplug with the core and reworking container hotplug.
    
       - ACPI core simplifications making it use ACPI_COMPANION() in the
         code "glueing" ACPI device objects to "physical" devices.
    
       - ACPICA update to upstream version 20131218.  This adds support for
         the DBG2 and PCCT tables to ACPICA, fixes some bugs and improves
         debug facilities.  From Bob Moore, Lv Zheng and Betty Dall.
    
       - Init code change to carry out the early ACPI initialization
         earlier.  That should allow us to use ACPI during the timekeeping
         initialization and possibly to simplify the EFI initialization too.
         From Chun-Yi Lee.
    
       - Clenups of the inclusions of ACPI headers in many places all over
         from Lv Zheng and Rashika Kheria (work in progress).
    
       - New helper for ACPI _DSM execution and rework of the code in
         drivers that uses _DSM to execute it via the new helper.  From
         Jiang Liu.
    
       - New Win8 OSI blacklist entries from Takashi Iwai.
    
       - Assorted ACPI fixes and cleanups from Al Stone, Emil Goode, Hanjun
         Guo, Lan Tianyu, Masanari Iida, Oliver Neukum, Prarit Bhargava,
         Rashika Kheria, Tang Chen, Zhang Rui.
    
       - intel_pstate driver updates, including proper Baytrail support,
         from Dirk Brandewie and intel_pstate documentation from Ramkumar
         Ramachandra.
    
       - Generic CPU boost ("turbo") support for cpufreq from Lukasz
         Majewski.
    
       - powernow-k6 cpufreq driver fixes from Mikulas Patocka.
    
       - cpufreq core fixes and cleanups from Viresh Kumar, Jane Li, Mark
         Brown.
    
       - Assorted cpufreq drivers fixes and cleanups from Anson Huang, John
         Tobias, Paul Bolle, Paul Walmsley, Sachin Kamat, Shawn Guo, Viresh
         Kumar.
    
       - cpuidle cleanups from Bartlomiej Zolnierkiewicz.
    
       - Support for hibernation APM events from Bin Shi.
    
       - Hibernation fix to avoid bringing up nonboot CPUs with ACPI EC
         disabled during thaw transitions from Bjrn Mork.
    
       - PM core fixes and cleanups from Ben Dooks, Leonardo Potenza, Ulf
         Hansson.
    
       - PNP subsystem fixes and cleanups from Dmitry Torokhov, Levente
         Kurusa, Rashika Kheria.
    
       - New tool for profiling system suspend from Todd E Brandt and a
         cpupower tool cleanup from One Thousand Gnomes"
    
    * tag 'pm+acpi-3.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (153 commits)
      thermal: exynos: boost: Automatic enable/disable of BOOST feature (at Exynos4412)
      cpufreq: exynos4x12: Change L0 driver data to CPUFREQ_BOOST_FREQ
      Documentation: cpufreq / boost: Update BOOST documentation
      cpufreq: exynos: Extend Exynos cpufreq driver to support boost
      cpufreq / boost: Kconfig: Support for software-managed BOOST
      acpi-cpufreq: Adjust the code to use the common boost attribute
      cpufreq: Add boost frequency support in core
      intel_pstate: Add trace point to report internal state.
      cpufreq: introduce cpufreq_generic_get() routine
      ARM: SA1100: Create dummy clk_get_rate() to avoid build failures
      cpufreq: stats: create sysfs entries when cpufreq_stats is a module
      cpufreq: stats: free table and remove sysfs entry in a single routine
      cpufreq: stats: remove hotplug notifiers
      cpufreq: stats: handle cpufreq_unregister_driver() and suspend/resume properly
      cpufreq: speedstep: remove unused speedstep_get_state
      platform: introduce OF style 'modalias' support for platform bus
      PM / tools: new tool for suspend/resume performance optimization
      ACPI: fix module autoloading for ACPI enumerated devices
      ACPI: add module autoloading support for ACPI enumerated devices
      ACPI: fix create_modalias() return value handling
      ...

commit 50a639fb158c6aafe86ba7d6104de69518a9d09a
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Sat Nov 23 11:03:17 2013 -0800

    asus-wmi: Convert to use devm_hwmon_device_register_with_groups
    
    Simplify the code and avoid race conditions due to late sysfs attribute
    registration. Also replace SENSOR_DEVICE_ATTR with DEVICE_ATTR;
    the additional parameter is not used and thus unnecessary.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 19c313b056c3..e9e22a51e703 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -184,7 +184,6 @@ struct asus_wmi {
 
 	struct input_dev *inputdev;
 	struct backlight_device *backlight_device;
-	struct device *hwmon_device;
 	struct platform_device *platform_device;
 
 	struct led_classdev wlan_led;
@@ -1071,20 +1070,12 @@ static ssize_t asus_hwmon_temp1(struct device *dev,
 	return sprintf(buf, "%d\n", value);
 }
 
-static SENSOR_DEVICE_ATTR(pwm1, S_IRUGO, asus_hwmon_pwm1, NULL, 0);
-static SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, asus_hwmon_temp1, NULL, 0);
-
-static ssize_t
-show_name(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	return sprintf(buf, "asus\n");
-}
-static SENSOR_DEVICE_ATTR(name, S_IRUGO, show_name, NULL, 0);
+static DEVICE_ATTR(pwm1, S_IRUGO, asus_hwmon_pwm1, NULL);
+static DEVICE_ATTR(temp1_input, S_IRUGO, asus_hwmon_temp1, NULL);
 
 static struct attribute *hwmon_attributes[] = {
-	&sensor_dev_attr_pwm1.dev_attr.attr,
-	&sensor_dev_attr_temp1_input.dev_attr.attr,
-	&sensor_dev_attr_name.dev_attr.attr,
+	&dev_attr_pwm1.attr,
+	&dev_attr_temp1_input.attr,
 	NULL
 };
 
@@ -1098,9 +1089,9 @@ static umode_t asus_hwmon_sysfs_is_visible(struct kobject *kobj,
 	int dev_id = -1;
 	u32 value = ASUS_WMI_UNSUPPORTED_METHOD;
 
-	if (attr == &sensor_dev_attr_pwm1.dev_attr.attr)
+	if (attr == &dev_attr_pwm1.attr)
 		dev_id = ASUS_WMI_DEVID_FAN_CTRL;
-	else if (attr == &sensor_dev_attr_temp1_input.dev_attr.attr)
+	else if (attr == &dev_attr_temp1_input.attr)
 		dev_id = ASUS_WMI_DEVID_THERMAL_CTRL;
 
 	if (dev_id != -1) {
@@ -1135,35 +1126,20 @@ static struct attribute_group hwmon_attribute_group = {
 	.is_visible = asus_hwmon_sysfs_is_visible,
 	.attrs = hwmon_attributes
 };
-
-static void asus_wmi_hwmon_exit(struct asus_wmi *asus)
-{
-	struct device *hwmon;
-
-	hwmon = asus->hwmon_device;
-	if (!hwmon)
-		return;
-	sysfs_remove_group(&hwmon->kobj, &hwmon_attribute_group);
-	hwmon_device_unregister(hwmon);
-	asus->hwmon_device = NULL;
-}
+__ATTRIBUTE_GROUPS(hwmon_attribute);
 
 static int asus_wmi_hwmon_init(struct asus_wmi *asus)
 {
 	struct device *hwmon;
-	int result;
 
-	hwmon = hwmon_device_register(&asus->platform_device->dev);
+	hwmon = hwmon_device_register_with_groups(&asus->platform_device->dev,
+						  "asus", asus,
+						  hwmon_attribute_groups);
 	if (IS_ERR(hwmon)) {
 		pr_err("Could not register asus hwmon device\n");
 		return PTR_ERR(hwmon);
 	}
-	dev_set_drvdata(hwmon, asus);
-	asus->hwmon_device = hwmon;
-	result = sysfs_create_group(&hwmon->kobj, &hwmon_attribute_group);
-	if (result)
-		asus_wmi_hwmon_exit(asus);
-	return result;
+	return 0;
 }
 
 /*
@@ -1834,7 +1810,6 @@ static int asus_wmi_add(struct platform_device *pdev)
 fail_rfkill:
 	asus_wmi_led_exit(asus);
 fail_leds:
-	asus_wmi_hwmon_exit(asus);
 fail_hwmon:
 	asus_wmi_input_exit(asus);
 fail_input:
@@ -1852,7 +1827,6 @@ static int asus_wmi_remove(struct platform_device *device)
 	wmi_remove_notify_handler(asus->driver->event_guid);
 	asus_wmi_backlight_exit(asus);
 	asus_wmi_input_exit(asus);
-	asus_wmi_hwmon_exit(asus);
 	asus_wmi_led_exit(asus);
 	asus_wmi_rfkill_exit(asus);
 	asus_wmi_debugfs_exit(asus);

commit 8b9ec1da6a310b438516468c669a7e1be046b18c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jan 10 15:27:08 2014 +0100

    platform / x86: Use global PCI rescan-remove locking
    
    Multiple race conditions are possible between the rfkill hotplug in the
    asus-wmi and eeepc-laptop drivers and the generic PCI bus rescan and device
    removal that can be triggered via sysfs.
    
    To avoid those race conditions make asus-wmi and eeepc-laptop use global
    PCI rescan-remove locking around the rfkill hotplug.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 19c313b056c3..6fe268f6af91 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -606,6 +606,7 @@ static void asus_rfkill_hotplug(struct asus_wmi *asus)
 	mutex_unlock(&asus->wmi_lock);
 
 	mutex_lock(&asus->hotplug_lock);
+	pci_lock_rescan_remove();
 
 	if (asus->wlan.rfkill)
 		rfkill_set_sw_state(asus->wlan.rfkill, blocked);
@@ -656,6 +657,7 @@ static void asus_rfkill_hotplug(struct asus_wmi *asus)
 	}
 
 out_unlock:
+	pci_unlock_rescan_remove();
 	mutex_unlock(&asus->hotplug_lock);
 }
 

commit 8b48463f89429af408ff695244dc627e1acff4f7
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Dec 3 08:49:16 2013 +0800

    ACPI: Clean up inclusions of ACPI header files
    
    Replace direct inclusions of <acpi/acpi.h>, <acpi/acpi_bus.h> and
    <acpi/acpi_drivers.h>, which are incorrect, with <linux/acpi.h>
    inclusions and remove some inclusions of those files that aren't
    necessary.
    
    First of all, <acpi/acpi.h>, <acpi/acpi_bus.h> and <acpi/acpi_drivers.h>
    should not be included directly from any files that are built for
    CONFIG_ACPI unset, because that generally leads to build warnings about
    undefined symbols in !CONFIG_ACPI builds.  For CONFIG_ACPI set,
    <linux/acpi.h> includes those files and for CONFIG_ACPI unset it
    provides stub ACPI symbols to be used in that case.
    
    Second, there are ordering dependencies between those files that always
    have to be met.  Namely, it is required that <acpi/acpi_bus.h> be included
    prior to <acpi/acpi_drivers.h> so that the acpi_pci_root declarations the
    latter depends on are always there.  And <acpi/acpi.h> which provides
    basic ACPICA type declarations should always be included prior to any other
    ACPI headers in CONFIG_ACPI builds.  That also is taken care of including
    <linux/acpi.h> as appropriate.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> (drivers/pci stuff)
    Acked-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com> (Xen stuff)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 19c313b056c3..df7ecb9ecd9d 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -45,8 +45,7 @@
 #include <linux/seq_file.h>
 #include <linux/platform_device.h>
 #include <linux/thermal.h>
-#include <acpi/acpi_bus.h>
-#include <acpi/acpi_drivers.h>
+#include <linux/acpi.h>
 #include <acpi/video.h>
 
 #include "asus-wmi.h"

commit e8f56c80aedacfb1552509c0e4ed265266328bc4
Author: AceLan Kao <acelan.kao@canonical.com>
Date:   Thu May 30 10:31:50 2013 +0800

    asus-wmi: control wlan-led only if wapf == 4
    
    Controlling the wlan led seems to have some side effects to the machines
    with wapf value is not equal to 4. It will make the keyboard backlight
    out of order.
    So, the patch will enable the wlan led function only if the wapf == 4.
    
    Bug: https://bugzilla.kernel.org/show_bug.cgi?id=46791
    
    Reported-by: Mirto Silvio Busico <m.busico@ieee.org>
    Tested-by: Karol Herbst <karolherbst@me.com>
    Tested-by: drunkenbatman <drunkenbatman@gmail.com>
    Signed-off-by: AceLan Kao <acelan.kao@canonical.com>
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 0e58d748d7f6..19c313b056c3 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -558,7 +558,7 @@ static int asus_wmi_led_init(struct asus_wmi *asus)
 			goto error;
 	}
 
-	if (wlan_led_presence(asus)) {
+	if (wlan_led_presence(asus) && (asus->driver->quirks->wapf == 4)) {
 		INIT_WORK(&asus->wlan_led_work, wlan_led_update);
 
 		asus->wlan_led.name = "asus::wlan";
@@ -886,7 +886,8 @@ static int asus_new_rfkill(struct asus_wmi *asus,
 	if (!*rfkill)
 		return -EINVAL;
 
-	if (dev_id == ASUS_WMI_DEVID_WLAN)
+	if ((dev_id == ASUS_WMI_DEVID_WLAN) &&
+			(asus->driver->quirks->wapf == 4))
 		rfkill_set_led_trigger_name(*rfkill, "asus-wlan");
 
 	rfkill_init_sw_state(*rfkill, !result);

commit 0ed60654a24c730dcb555da8439e5639253b6eca
Author: vic <victorenator@gmail.com>
Date:   Wed May 22 21:32:10 2013 +0300

    asus-wmi: append newline to messages
    
    Append newline to messages.
    
    Signed-off-by: Viktar Vauchkevich <victorenator@gmail.com>
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index c11b2426dac1..0e58d748d7f6 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1045,7 +1045,7 @@ static ssize_t asus_hwmon_pwm1(struct device *dev,
 	else if (value == 3)
 		value = 255;
 	else if (value != 0) {
-		pr_err("Unknown fan speed %#x", value);
+		pr_err("Unknown fan speed %#x\n", value);
 		value = -1;
 	}
 
@@ -1557,11 +1557,11 @@ static int asus_wmi_platform_init(struct asus_wmi *asus)
 
 	/* INIT enable hotkeys on some models */
 	if (!asus_wmi_evaluate_method(ASUS_WMI_METHODID_INIT, 0, 0, &rv))
-		pr_info("Initialization: %#x", rv);
+		pr_info("Initialization: %#x\n", rv);
 
 	/* We don't know yet what to do with this version... */
 	if (!asus_wmi_evaluate_method(ASUS_WMI_METHODID_SPEC, 0, 0x9, &rv)) {
-		pr_info("BIOS WMI version: %d.%d", rv >> 16, rv & 0xFF);
+		pr_info("BIOS WMI version: %d.%d\n", rv >> 16, rv & 0xFF);
 		asus->spec = rv;
 	}
 
@@ -1572,7 +1572,7 @@ static int asus_wmi_platform_init(struct asus_wmi *asus)
 	 * The significance of others is yet to be found.
 	 */
 	if (!asus_wmi_evaluate_method(ASUS_WMI_METHODID_SFUN, 0, 0, &rv)) {
-		pr_info("SFUN value: %#x", rv);
+		pr_info("SFUN value: %#x\n", rv);
 		asus->sfun = rv;
 	}
 
@@ -1712,7 +1712,7 @@ static int asus_wmi_debugfs_init(struct asus_wmi *asus)
 
 	asus->debug.root = debugfs_create_dir(asus->driver->name, NULL);
 	if (!asus->debug.root) {
-		pr_err("failed to create debugfs directory");
+		pr_err("failed to create debugfs directory\n");
 		goto error_debugfs;
 	}
 
@@ -1985,17 +1985,17 @@ EXPORT_SYMBOL_GPL(asus_wmi_unregister_driver);
 static int __init asus_wmi_init(void)
 {
 	if (!wmi_has_guid(ASUS_WMI_MGMT_GUID)) {
-		pr_info("Asus Management GUID not found");
+		pr_info("Asus Management GUID not found\n");
 		return -ENODEV;
 	}
 
-	pr_info("ASUS WMI generic driver loaded");
+	pr_info("ASUS WMI generic driver loaded\n");
 	return 0;
 }
 
 static void __exit asus_wmi_exit(void)
 {
-	pr_info("ASUS WMI generic driver unloaded");
+	pr_info("ASUS WMI generic driver unloaded\n");
 }
 
 module_init(asus_wmi_init);

commit 2adb95d83f6e915a7d3793a8f6aa8e6e9463357c
Author: Shuah Khan <shuah.khan@hp.com>
Date:   Mon Jan 14 15:50:40 2013 -0700

    asus-wmi: Fix unused function build warning
    
    Fix the following build warning
    
    CC [M]  drivers/platform/x86/asus-wmi.o
    drivers/platform/x86/asus-wmi.c:1356:13: warning: do_nothing defined but not used [-Wunused-function]
    
    Signed-off-by: Shuah Khan <shuah.khan@hp.com>
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index e41eae315852..c11b2426dac1 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1353,11 +1353,6 @@ static int is_display_toggle(int code)
 	return 0;
 }
 
-static void do_nothing(void)
-{
-	return;
-}
-
 static void asus_wmi_notify(u32 value, void *context)
 {
 	struct asus_wmi *asus = context;

commit 3ba0302bdd57d225b52c4b4b36975196c1572b3f
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Thu Nov 29 09:12:38 2012 +0100

    asus-wmi: always report brightness key events
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 208e71c61847..e41eae315852 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1391,16 +1391,16 @@ static void asus_wmi_notify(u32 value, void *context)
 	}
 
 	if (code >= NOTIFY_BRNUP_MIN && code <= NOTIFY_BRNUP_MAX)
-		code = NOTIFY_BRNUP_MIN;
+		code = ASUS_WMI_BRN_UP;
 	else if (code >= NOTIFY_BRNDOWN_MIN &&
 		 code <= NOTIFY_BRNDOWN_MAX)
-		code = NOTIFY_BRNDOWN_MIN;
+		code = ASUS_WMI_BRN_DOWN;
 
-	if (code == NOTIFY_BRNUP_MIN || code == NOTIFY_BRNDOWN_MIN) {
+	if (code == ASUS_WMI_BRN_DOWN || code == ASUS_WMI_BRN_UP) {
 		if (!acpi_video_backlight_support()) {
 			asus_wmi_backlight_notify(asus, orig_code);
+			goto exit;
 		}
-		goto exit;
 	}
 
 	if (is_display_toggle(code) &&

commit a2a96f0c7221806c8a8072b662e6deaa119833da
Author: AceLan Kao <acelan.kao@canonical.com>
Date:   Wed Oct 3 11:26:31 2012 +0200

    asus-wmi: add display toggle quirk
    
    For machines with AMD graphic chips, it will send out WMI event and ACPI
    interrupt at the same time while hitting the hotkey. BIOS will notify the
    system the next display output mode throught WMI event code, so that
    windows' application can show an OSD to tell the user which mode will be
    taken effect. User can hit the display toggle key many times within 2
    seconds to choose the mode they want. After 2 seconds, WMI dirver should
    send a WMIMethod(SDSP) command to tell the BIOS which mode the user chose.
    And then BIOS will raise another ACPI interrupt to tell the system to
    really switch the display mode.
    
    In Linux desktop, we don't have this kind of OSD to let users to choose
    the mode they want, so we don't need to call WMIMethod(SDSP) to have
    another ACPI interrupt. To simplify the problem, we just have to ignore
    the WMI event, and let the first ACPI interrupt to send out the key event.
    
    For the need, here comes another quirk to add machines with this kind of
    behavior. When the WMI driver receives the display toggle WMI event, and
    found the machin is in the list, it will do nothing and let ACPI video
    driver to report the key event.
    
    Signed-off-by: AceLan Kao <acelan.kao@canonical.com>
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 912ec7de71f4..208e71c61847 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1341,6 +1341,23 @@ static void asus_wmi_backlight_exit(struct asus_wmi *asus)
 	asus->backlight_device = NULL;
 }
 
+static int is_display_toggle(int code)
+{
+	/* display toggle keys */
+	if ((code >= 0x61 && code <= 0x67) ||
+	    (code >= 0x8c && code <= 0x93) ||
+	    (code >= 0xa0 && code <= 0xa7) ||
+	    (code >= 0xd0 && code <= 0xd5))
+		return 1;
+
+	return 0;
+}
+
+static void do_nothing(void)
+{
+	return;
+}
+
 static void asus_wmi_notify(u32 value, void *context)
 {
 	struct asus_wmi *asus = context;
@@ -1380,10 +1397,18 @@ static void asus_wmi_notify(u32 value, void *context)
 		code = NOTIFY_BRNDOWN_MIN;
 
 	if (code == NOTIFY_BRNUP_MIN || code == NOTIFY_BRNDOWN_MIN) {
-		if (!acpi_video_backlight_support())
+		if (!acpi_video_backlight_support()) {
 			asus_wmi_backlight_notify(asus, orig_code);
-	} else if (!sparse_keymap_report_event(asus->inputdev, code,
-					       key_value, autorelease))
+		}
+		goto exit;
+	}
+
+	if (is_display_toggle(code) &&
+	    asus->driver->quirks->no_display_toggle)
+		goto exit;
+
+	if (!sparse_keymap_report_event(asus->inputdev, code,
+					key_value, autorelease))
 		pr_info("Unknown key %x pressed\n", code);
 
 exit:

commit 6cae06e603339f99334bc6b276e2ac619cf0d476
Author: AceLan Kao <acelan.kao@canonical.com>
Date:   Fri Jul 27 16:51:59 2012 +0800

    asus-wmi: update wlan LED through rfkill led trigger
    
    For those machines with wapf=4, BIOS won't update the wireless LED,
    since wapf=4 means user application will take in chage of the wifi and bt.
    So, we have to update wlan LED status explicitly.
    
    But I found there is another wireless LED bug in launchpad and which is
    not in the wapf=4 quirk.
    So, it might be better to set wireless LED status explicitly for all
    machines.
    
    BugLink: https://launchpad.net/bugs/901105
    
    Signed-off-by: AceLan Kao <acelan.kao@canonical.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index f80ae4d10f68..912ec7de71f4 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -187,6 +187,8 @@ struct asus_wmi {
 	struct device *hwmon_device;
 	struct platform_device *platform_device;
 
+	struct led_classdev wlan_led;
+	int wlan_led_wk;
 	struct led_classdev tpd_led;
 	int tpd_led_wk;
 	struct led_classdev kbd_led;
@@ -194,6 +196,7 @@ struct asus_wmi {
 	struct workqueue_struct *led_workqueue;
 	struct work_struct tpd_led_work;
 	struct work_struct kbd_led_work;
+	struct work_struct wlan_led_work;
 
 	struct asus_rfkill wlan;
 	struct asus_rfkill bluetooth;
@@ -456,12 +459,65 @@ static enum led_brightness kbd_led_get(struct led_classdev *led_cdev)
 	return value;
 }
 
+static int wlan_led_unknown_state(struct asus_wmi *asus)
+{
+	u32 result;
+
+	asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_WIRELESS_LED, &result);
+
+	return result & ASUS_WMI_DSTS_UNKNOWN_BIT;
+}
+
+static int wlan_led_presence(struct asus_wmi *asus)
+{
+	u32 result;
+
+	asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_WIRELESS_LED, &result);
+
+	return result & ASUS_WMI_DSTS_PRESENCE_BIT;
+}
+
+static void wlan_led_update(struct work_struct *work)
+{
+	int ctrl_param;
+	struct asus_wmi *asus;
+
+	asus = container_of(work, struct asus_wmi, wlan_led_work);
+
+	ctrl_param = asus->wlan_led_wk;
+	asus_wmi_set_devstate(ASUS_WMI_DEVID_WIRELESS_LED, ctrl_param, NULL);
+}
+
+static void wlan_led_set(struct led_classdev *led_cdev,
+			 enum led_brightness value)
+{
+	struct asus_wmi *asus;
+
+	asus = container_of(led_cdev, struct asus_wmi, wlan_led);
+
+	asus->wlan_led_wk = !!value;
+	queue_work(asus->led_workqueue, &asus->wlan_led_work);
+}
+
+static enum led_brightness wlan_led_get(struct led_classdev *led_cdev)
+{
+	struct asus_wmi *asus;
+	u32 result;
+
+	asus = container_of(led_cdev, struct asus_wmi, wlan_led);
+	asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_WIRELESS_LED, &result);
+
+	return result & ASUS_WMI_DSTS_BRIGHTNESS_MASK;
+}
+
 static void asus_wmi_led_exit(struct asus_wmi *asus)
 {
 	if (!IS_ERR_OR_NULL(asus->kbd_led.dev))
 		led_classdev_unregister(&asus->kbd_led);
 	if (!IS_ERR_OR_NULL(asus->tpd_led.dev))
 		led_classdev_unregister(&asus->tpd_led);
+	if (!IS_ERR_OR_NULL(asus->wlan_led.dev))
+		led_classdev_unregister(&asus->wlan_led);
 	if (asus->led_workqueue)
 		destroy_workqueue(asus->led_workqueue);
 }
@@ -498,6 +554,23 @@ static int asus_wmi_led_init(struct asus_wmi *asus)
 
 		rv = led_classdev_register(&asus->platform_device->dev,
 					   &asus->kbd_led);
+		if (rv)
+			goto error;
+	}
+
+	if (wlan_led_presence(asus)) {
+		INIT_WORK(&asus->wlan_led_work, wlan_led_update);
+
+		asus->wlan_led.name = "asus::wlan";
+		asus->wlan_led.brightness_set = wlan_led_set;
+		if (!wlan_led_unknown_state(asus))
+			asus->wlan_led.brightness_get = wlan_led_get;
+		asus->wlan_led.flags = LED_CORE_SUSPENDRESUME;
+		asus->wlan_led.max_brightness = 1;
+		asus->wlan_led.default_trigger = "asus-wlan";
+
+		rv = led_classdev_register(&asus->platform_device->dev,
+					   &asus->wlan_led);
 	}
 
 error:
@@ -813,6 +886,9 @@ static int asus_new_rfkill(struct asus_wmi *asus,
 	if (!*rfkill)
 		return -EINVAL;
 
+	if (dev_id == ASUS_WMI_DEVID_WLAN)
+		rfkill_set_led_trigger_name(*rfkill, "asus-wlan");
+
 	rfkill_init_sw_state(*rfkill, !result);
 	result = rfkill_register(*rfkill);
 	if (result) {

commit 5909c654a6f20dd61cc5ac952f8eaa3a29e59078
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Mon Dec 17 16:00:05 2012 -0800

    Corentin has moved
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index c0e9ff489b24..f80ae4d10f68 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -51,7 +51,7 @@
 
 #include "asus-wmi.h"
 
-MODULE_AUTHOR("Corentin Chary <corentincj@iksaif.net>, "
+MODULE_AUTHOR("Corentin Chary <corentin.chary@gmail.com>, "
 	      "Yong Wang <yong.y.wang@intel.com>");
 MODULE_DESCRIPTION("Asus Generic WMI Driver");
 MODULE_LICENSE("GPL");

commit 689db7843d503fae0eb46cb849e4caab35588170
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Mon Aug 20 23:01:50 2012 +0200

    drivers-platform-x86: remove useless #ifdef CONFIG_ACPI_VIDEO
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 2eb9fe8e8efd..c0e9ff489b24 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -47,9 +47,7 @@
 #include <linux/thermal.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
-#ifdef CONFIG_ACPI_VIDEO
 #include <acpi/video.h>
-#endif
 
 #include "asus-wmi.h"
 
@@ -1704,10 +1702,8 @@ static int asus_wmi_add(struct platform_device *pdev)
 	if (asus->driver->quirks->wmi_backlight_power)
 		acpi_video_dmi_promote_vendor();
 	if (!acpi_video_backlight_support()) {
-#ifdef CONFIG_ACPI_VIDEO
 		pr_info("Disabling ACPI video driver\n");
 		acpi_video_unregister();
-#endif
 		err = asus_wmi_backlight_init(asus);
 		if (err && err != -ENODEV)
 			goto fail_backlight;

commit a50bd128f28cf81c1250874fc53728e113f12957
Author: AceLan Kao <acelan.kao@canonical.com>
Date:   Thu Jul 26 17:13:31 2012 +0800

    asus-wmi: record wlan status while controlled by userapp
    
    If the user bit is set, that mean BIOS can't set and record the wlan
    status, it will report the value read from id ASUS_WMI_DEVID_WLAN_LED
    (0x00010012) while we query the wlan status by id ASUS_WMI_DEVID_WLAN
    (0x00010011) through WMI.
    So, we have to record wlan status in id ASUS_WMI_DEVID_WLAN_LED
    (0x00010012) while setting the wlan status through WMI.
    This is also the behavior that windows app will do.
    
    Quote from ASUS application engineer
    ===
    When you call WMIMethod(DSTS, 0x00010011) to get WLAN status, it may return
    
    (1) 0x00050001 (On)
    (2) 0x00050000 (Off)
    (3) 0x00030001 (On)
    (4) 0x00030000 (Off)
    (5) 0x00000002 (Unknown)
    
    (1), (2) means that the model has hardware GPIO for WLAN, you can call
    WMIMethod(DEVS, 0x00010011, 1 or 0) to turn WLAN on/off.
    (3), (4) means that the model doesnt have hardware GPIO, you need to use
    API or driver library to turn WLAN on/off, and call
    WMIMethod(DEVS, 0x00010012, 1 or 0) to set WLAN LED status.
    After you set WLAN LED status, you can see the WLAN status is changed with
    WMIMethod(DSTS, 0x00010011). Because the status is recorded lastly
    (ex: Windows), you can use it for synchronization.
    (5) means that the model doesnt have WLAN device.
    
    WLAN is the ONLY special case with upper rule.
    
    For other device, like Bluetooth, you just need use
    WMIMethod(DSTS, 0x00010013) to get, and WMIMethod(DEVS, 0x00010013, 1 or 0)
    to set.
    ===
    
    Signed-off-by: AceLan Kao <acelan.kao@canonical.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index c7a36f6b0580..2eb9fe8e8efd 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -101,6 +101,7 @@ MODULE_LICENSE("GPL");
 #define ASUS_WMI_DEVID_WIRELESS_LED	0x00010002
 #define ASUS_WMI_DEVID_CWAP		0x00010003
 #define ASUS_WMI_DEVID_WLAN		0x00010011
+#define ASUS_WMI_DEVID_WLAN_LED		0x00010012
 #define ASUS_WMI_DEVID_BLUETOOTH	0x00010013
 #define ASUS_WMI_DEVID_GPS		0x00010015
 #define ASUS_WMI_DEVID_WIMAX		0x00010017
@@ -731,8 +732,21 @@ static int asus_rfkill_set(void *data, bool blocked)
 {
 	struct asus_rfkill *priv = data;
 	u32 ctrl_param = !blocked;
+	u32 dev_id = priv->dev_id;
 
-	return asus_wmi_set_devstate(priv->dev_id, ctrl_param, NULL);
+	/*
+	 * If the user bit is set, BIOS can't set and record the wlan status,
+	 * it will report the value read from id ASUS_WMI_DEVID_WLAN_LED
+	 * while we query the wlan status through WMI(ASUS_WMI_DEVID_WLAN).
+	 * So, we have to record wlan status in id ASUS_WMI_DEVID_WLAN_LED
+	 * while setting the wlan status through WMI.
+	 * This is also the behavior that windows app will do.
+	 */
+	if ((dev_id == ASUS_WMI_DEVID_WLAN) &&
+	     priv->asus->driver->wlan_ctrl_by_user)
+		dev_id = ASUS_WMI_DEVID_WLAN_LED;
+
+	return asus_wmi_set_devstate(dev_id, ctrl_param, NULL);
 }
 
 static void asus_rfkill_query(struct rfkill *rfkill, void *data)
@@ -1653,6 +1667,7 @@ static int asus_wmi_add(struct platform_device *pdev)
 	struct asus_wmi *asus;
 	acpi_status status;
 	int err;
+	u32 result;
 
 	asus = kzalloc(sizeof(struct asus_wmi), GFP_KERNEL);
 	if (!asus)
@@ -1711,6 +1726,10 @@ static int asus_wmi_add(struct platform_device *pdev)
 	if (err)
 		goto fail_debugfs;
 
+	asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_WLAN, &result);
+	if (result & (ASUS_WMI_DSTS_PRESENCE_BIT | ASUS_WMI_DSTS_USER_BIT))
+		asus->driver->wlan_ctrl_by_user = 1;
+
 	return 0;
 
 fail_debugfs:

commit c0b91b6d5226247fa4fe894eb592bcc56bc7e9fd
Author: AceLan Kao <acelan.kao@canonical.com>
Date:   Wed Jun 13 09:32:07 2012 +0200

    asus-wmi: enable resume on lid open
    
    According to the ASUS WMI spec., to enable resume on lid open should
    use the device ID(0x00120032), but it doesn't work indeed.
    
    After discussing with ASUS' BIOS engineer, they say wake on lid open
    doesn't have a uniq device ID(0x00120032) in the BIOS. It shares the same
    device ID with deep S3(0x00120031), and the deep S3(resume on lid open)
    is disable by default.
    
    Adding this option in asus wmi sysfs
       /sys/devices/platform/<platform>/lid_resume
    so that userspace apps can enable/disable this feature by themselves.
    
    Signed-off-by: AceLan Kao <acelan.kao@canonical.com>
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 486f836b79df..c7a36f6b0580 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -139,6 +139,9 @@ MODULE_LICENSE("GPL");
 /* Power */
 #define ASUS_WMI_DEVID_PROCESSOR_STATE	0x00120012
 
+/* Deep S3 / Resume on LID open */
+#define ASUS_WMI_DEVID_LID_RESUME	0x00120031
+
 /* DSTS masks */
 #define ASUS_WMI_DSTS_STATUS_BIT	0x00000001
 #define ASUS_WMI_DSTS_UNKNOWN_BIT	0x00000002
@@ -1368,6 +1371,7 @@ static ssize_t show_sys_wmi(struct asus_wmi *asus, int devid, char *buf)
 ASUS_WMI_CREATE_DEVICE_ATTR(touchpad, 0644, ASUS_WMI_DEVID_TOUCHPAD);
 ASUS_WMI_CREATE_DEVICE_ATTR(camera, 0644, ASUS_WMI_DEVID_CAMERA);
 ASUS_WMI_CREATE_DEVICE_ATTR(cardr, 0644, ASUS_WMI_DEVID_CARDREADER);
+ASUS_WMI_CREATE_DEVICE_ATTR(lid_resume, 0644, ASUS_WMI_DEVID_LID_RESUME);
 
 static ssize_t store_cpufv(struct device *dev, struct device_attribute *attr,
 			   const char *buf, size_t count)
@@ -1393,6 +1397,7 @@ static struct attribute *platform_attributes[] = {
 	&dev_attr_camera.attr,
 	&dev_attr_cardr.attr,
 	&dev_attr_touchpad.attr,
+	&dev_attr_lid_resume.attr,
 	NULL
 };
 
@@ -1411,6 +1416,8 @@ static umode_t asus_sysfs_is_visible(struct kobject *kobj,
 		devid = ASUS_WMI_DEVID_CARDREADER;
 	else if (attr == &dev_attr_touchpad.attr)
 		devid = ASUS_WMI_DEVID_TOUCHPAD;
+	else if (attr == &dev_attr_lid_resume.attr)
+		devid = ASUS_WMI_DEVID_LID_RESUME;
 
 	if (devid != -1)
 		ok = !(asus_wmi_get_devstate_simple(asus, devid) < 0);

commit 272c77d55672ef92eda9d5e24a5a7ac62df9c431
Author: AceLan Kao <acelan.kao@canonical.com>
Date:   Wed Jun 13 09:32:06 2012 +0200

    asus-wmi: control backlight power through WMI, not ACPI
    
    BugLink: https://bugs.launchpad.net/bugs/1000146
    
    Some h/w that can adjust screen brightness through ACPI functions, but
    can't turn on/off the backlight power correctly. So, we list those h/w in
    quirks and try to turn on/off the backlight power through WMI.
    Signed-off-by: AceLan Kao <acelan.kao@canonical.com>
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 556cbb455ed2..486f836b79df 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -47,6 +47,9 @@
 #include <linux/thermal.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
+#ifdef CONFIG_ACPI_VIDEO
+#include <acpi/video.h>
+#endif
 
 #include "asus-wmi.h"
 
@@ -1676,7 +1679,13 @@ static int asus_wmi_add(struct platform_device *pdev)
 	if (err)
 		goto fail_rfkill;
 
+	if (asus->driver->quirks->wmi_backlight_power)
+		acpi_video_dmi_promote_vendor();
 	if (!acpi_video_backlight_support()) {
+#ifdef CONFIG_ACPI_VIDEO
+		pr_info("Disabling ACPI video driver\n");
+		acpi_video_unregister();
+#endif
 		err = asus_wmi_backlight_init(asus);
 		if (err && err != -ENODEV)
 			goto fail_backlight;

commit 63a78bb1051b240417daad3a3fa9c1bb10646dca
Author: Alex Hung <alex.hung@canonical.com>
Date:   Wed Jun 20 11:47:35 2012 +0800

    asus-wmi: use ASUS_WMI_METHODID_DSTS2 as default DSTS ID.
    
    According to responses from the BIOS team, ASUS_WMI_METHODID_DSTS2
    (0x53545344) will be used as future DSTS ID. In addition, calling
    asus_wmi_evaluate_method(ASUS_WMI_METHODID_DSTS2, 0, 0, NULL) returns
    ASUS_WMI_UNSUPPORTED_METHOD in new ASUS laptop PCs. This patch fixes
    no DSTS ID will be assigned in this case.
    
    Signed-off-by: Alex Hung <alex.hung@canonical.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Cc: stable@kernel.org

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 77aadde5281c..556cbb455ed2 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1467,14 +1467,9 @@ static int asus_wmi_platform_init(struct asus_wmi *asus)
 	 */
 	if (!asus_wmi_evaluate_method(ASUS_WMI_METHODID_DSTS, 0, 0, NULL))
 		asus->dsts_id = ASUS_WMI_METHODID_DSTS;
-	else if (!asus_wmi_evaluate_method(ASUS_WMI_METHODID_DSTS2, 0, 0, NULL))
+	else
 		asus->dsts_id = ASUS_WMI_METHODID_DSTS2;
 
-	if (!asus->dsts_id) {
-		pr_err("Can't find DSTS");
-		return -ENODEV;
-	}
-
 	/* CWAP allow to define the behavior of the Fn+F2 key,
 	 * this method doesn't seems to be present on Eee PCs */
 	if (asus->driver->quirks->wapf >= 0)

commit 61e5191c9d96268746bd57ed55d035678a1a2cf9
Merge: d2a2fc18d98d 86924de2a612
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 28 14:20:23 2012 -0700

    Merge branch 'for_linus' of git://cavan.codon.org.uk/platform-drivers-x86
    
    Pull x86 platform driver updates from Matthew Garrett:
     "Some significant updates to samsung-laptop, additional hardware
      support for Toshibas, misc updates to various hardware and a new
      backlight driver for some Apple machines."
    
    Fix up trivial conflicts: geode Geos update happening next to net5501
    support, and MSIC thermal platform support added twice.
    
    * 'for_linus' of git://cavan.codon.org.uk/platform-drivers-x86: (77 commits)
      acer-wmi: add quirk table for video backlight vendor mode
      drivers/platform/x86/amilo-rfkill.c::amilo_rfkill_probe() avoid NULL deref
      samsung-laptop: unregister ACPI video module for some well known laptops
      acer-wmi: No wifi rfkill on Sony machines
      thinkpad-acpi: recognize Lenovo as version string in newer V-series BIOS
      asus-wmi: don't update power and brightness when using scalar
      eeepc-wmi: split et2012 specific hacks
      eeepc-wmi: refine quirks handling
      asus-nb-wmi: set panel_power correctly
      asus-wmi: move WAPF variable into quirks_entry
      asus-wmi: store backlight power status for AIO machine
      asus-wmi: add scalar board brightness adj. support
      samsung-laptop: cleanup return type: mode_t vs umode_t
      drivers, samsung-laptop: fix usage of isalnum
      drivers, samsung-laptop: fix initialization of sabi_data in sabi_set_commandb
      asus-wmi: on/off bit is not set when reading the value
      eeepc-wmi: add extra keymaps for EP121
      asus-nb-wmi: ignore useless keys
      acer-wmi: support Lenovo ideapad S205 Brazos wifi switch
      acer-wmi: fix out of input parameter size when set
      ...

commit ade28abdcb474531bb7045c032a286812c7f6d2a
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Tue Mar 20 09:53:14 2012 +0100

    asus-wmi: don't update power and brightness when using scalar
    
    But we can still do it on other boards, as this might happen
    if the backlight driver change when update_bl is called.
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index ff9cfd83b09f..7d1684bdbf63 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1152,15 +1152,21 @@ static int update_bl_status(struct backlight_device *bd)
 					    ctrl_param, NULL);
 		if (asus->driver->quirks->store_backlight_power)
 			asus->driver->panel_power = bd->props.power;
-	} else {
-		if (asus->driver->quirks->scalar_panel_brightness)
-			ctrl_param = get_scalar_command(bd);
-		else
-			ctrl_param = bd->props.brightness;
 
-		err = asus_wmi_set_devstate(ASUS_WMI_DEVID_BRIGHTNESS,
-					    ctrl_param, NULL);
+		/* When using scalar brightness, updating the brightness
+		 * will mess with the backlight power */
+		if (asus->driver->quirks->scalar_panel_brightness)
+			return err;
 	}
+
+	if (asus->driver->quirks->scalar_panel_brightness)
+		ctrl_param = get_scalar_command(bd);
+	else
+		ctrl_param = bd->props.brightness;
+
+	err = asus_wmi_set_devstate(ASUS_WMI_DEVID_BRIGHTNESS,
+				    ctrl_param, NULL);
+
 	return err;
 }
 

commit 6a2bcccdb3206950d28e343476d9050e23e79b7e
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Tue Mar 20 09:53:10 2012 +0100

    asus-wmi: move WAPF variable into quirks_entry
    
    Some models work better with different values of wapf, so move the
    variable into quriks_entry to make it more easy to give a specific
    value to different models.
    
    Based on original patch from AceLan Kao <acelan.kao@canonical.com>
    
    Cc: AceLan Kao <acelan.kao@canonical.com>
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index c4ad76ee7b5f..ff9cfd83b09f 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1471,9 +1471,9 @@ static int asus_wmi_platform_init(struct asus_wmi *asus)
 
 	/* CWAP allow to define the behavior of the Fn+F2 key,
 	 * this method doesn't seems to be present on Eee PCs */
-	if (asus->driver->wapf >= 0)
+	if (asus->driver->quirks->wapf >= 0)
 		asus_wmi_set_devstate(ASUS_WMI_DEVID_CWAP,
-				      asus->driver->wapf, NULL);
+				      asus->driver->quirks->wapf, NULL);
 
 	return asus_wmi_sysfs_init(asus->platform_device);
 }

commit 6e0044bedc1fc94a61cc32fa25dcab9a4e4a9218
Author: AceLan Kao <acelan.kao@canonical.com>
Date:   Tue Mar 20 09:53:09 2012 +0100

    asus-wmi: store backlight power status for AIO machine
    
    Due to some implementation reasons, ASUS ET2012 All-in-One machines
    can't report the correct backlight power status, it will always return
    1. To track the backlight power status correctly, we have to store the
    status by ourselves.
    
    BTW, by the BIOS design, the backlight power will be turn on/off
    sequently, no matter what the value of the parameter will be.
    More over, the brightness adjustment command will turn on the backlight
    power. Those behaviors will make us fail to track the backlight power
    status.
    For example, While we are trying to turn on the backlight power,
    we will send out the brightness adjustment command and then trying to
    figure out if we have to turn on the backlight power, then send out
    the command. But, the real case is that, the backlight power turns on
    while sending the brightness adjustment command, and then we send out
    the command to turn on the backlight power, it actually will turn off
    the backlight power and the backlight power status we recorded becomes
    wrong. So, we have to seperate these two commands by a if statement.
    
    Signed-off-by: AceLan Kao <acelan.kao@canonical.com>
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index eb114f8d39e7..c4ad76ee7b5f 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1076,7 +1076,12 @@ static int asus_wmi_hwmon_init(struct asus_wmi *asus)
  */
 static int read_backlight_power(struct asus_wmi *asus)
 {
-	int ret = asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_BACKLIGHT);
+	int ret;
+	if (asus->driver->quirks->store_backlight_power)
+		ret = !asus->driver->panel_power;
+	else
+		ret = asus_wmi_get_devstate_simple(asus,
+						   ASUS_WMI_DEVID_BACKLIGHT);
 
 	if (ret < 0)
 		return ret;
@@ -1138,24 +1143,23 @@ static int update_bl_status(struct backlight_device *bd)
 {
 	struct asus_wmi *asus = bl_get_data(bd);
 	u32 ctrl_param;
-	int power, err;
-
-	if (asus->driver->quirks->scalar_panel_brightness)
-		ctrl_param = get_scalar_command(bd);
-	else
-		ctrl_param = bd->props.brightness;
-
-	err = asus_wmi_set_devstate(ASUS_WMI_DEVID_BRIGHTNESS,
-				    ctrl_param, NULL);
-
-	if (err < 0)
-		return err;
+	int power, err = 0;
 
 	power = read_backlight_power(asus);
 	if (power != -ENODEV && bd->props.power != power) {
 		ctrl_param = !!(bd->props.power == FB_BLANK_UNBLANK);
 		err = asus_wmi_set_devstate(ASUS_WMI_DEVID_BACKLIGHT,
 					    ctrl_param, NULL);
+		if (asus->driver->quirks->store_backlight_power)
+			asus->driver->panel_power = bd->props.power;
+	} else {
+		if (asus->driver->quirks->scalar_panel_brightness)
+			ctrl_param = get_scalar_command(bd);
+		else
+			ctrl_param = bd->props.brightness;
+
+		err = asus_wmi_set_devstate(ASUS_WMI_DEVID_BRIGHTNESS,
+					    ctrl_param, NULL);
 	}
 	return err;
 }
@@ -1217,6 +1221,9 @@ static int asus_wmi_backlight_init(struct asus_wmi *asus)
 
 	asus->backlight_device = bd;
 
+	if (asus->driver->quirks->store_backlight_power)
+		asus->driver->panel_power = power;
+
 	bd->props.brightness = read_brightness(bd);
 	bd->props.power = power;
 	backlight_update_status(bd);

commit c87992d1fa51a6a3d8f0e980ca4d2bdec7e78a17
Author: AceLan Kao <acelan.kao@canonical.com>
Date:   Tue Mar 20 09:53:08 2012 +0100

    asus-wmi: add scalar board brightness adj. support
    
    Some ASUS ET2012E/I All-in-One machines that use a scalar board
    to control the brightness, and they only accept brightness up and down
    command. So, I introduced a get_scalar_command() function to pass the
    command to the scalar board through WMI.
    
    Besides, we have to store the brightness value locally, for we need the
    old value to know the brightness value is increasing or decreasing.
    
    BTW, since there is no way to retrieve the actual brightness(it would be
    a fixed value), and the max brightness value would be fixed to 1, so we
    have to keep passing the brightness up/down command when we reached the
    max brightness value or 0.
    
    Signed-off-by: AceLan Kao <acelan.kao@canonical.com>
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 2b883470a9d0..eb114f8d39e7 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -784,7 +784,8 @@ static int asus_new_rfkill(struct asus_wmi *asus,
 	arfkill->dev_id = dev_id;
 	arfkill->asus = asus;
 
-	if (dev_id == ASUS_WMI_DEVID_WLAN && asus->driver->hotplug_wireless)
+	if (dev_id == ASUS_WMI_DEVID_WLAN &&
+	    asus->driver->quirks->hotplug_wireless)
 		*rfkill = rfkill_alloc(name, &asus->platform_device->dev, type,
 				       &asus_rfkill_wlan_ops, arfkill);
 	else
@@ -895,7 +896,7 @@ static int asus_wmi_rfkill_init(struct asus_wmi *asus)
 	if (result && result != -ENODEV)
 		goto exit;
 
-	if (!asus->driver->hotplug_wireless)
+	if (!asus->driver->quirks->hotplug_wireless)
 		goto exit;
 
 	result = asus_setup_pci_hotplug(asus);
@@ -1116,13 +1117,33 @@ static int read_brightness(struct backlight_device *bd)
 	return retval & ASUS_WMI_DSTS_BRIGHTNESS_MASK;
 }
 
+static u32 get_scalar_command(struct backlight_device *bd)
+{
+	struct asus_wmi *asus = bl_get_data(bd);
+	u32 ctrl_param = 0;
+
+	if ((asus->driver->brightness < bd->props.brightness) ||
+	    bd->props.brightness == bd->props.max_brightness)
+		ctrl_param = 0x00008001;
+	else if ((asus->driver->brightness > bd->props.brightness) ||
+		 bd->props.brightness == 0)
+		ctrl_param = 0x00008000;
+
+	asus->driver->brightness = bd->props.brightness;
+
+	return ctrl_param;
+}
+
 static int update_bl_status(struct backlight_device *bd)
 {
 	struct asus_wmi *asus = bl_get_data(bd);
 	u32 ctrl_param;
 	int power, err;
 
-	ctrl_param = bd->props.brightness;
+	if (asus->driver->quirks->scalar_panel_brightness)
+		ctrl_param = get_scalar_command(bd);
+	else
+		ctrl_param = bd->props.brightness;
 
 	err = asus_wmi_set_devstate(ASUS_WMI_DEVID_BRIGHTNESS,
 				    ctrl_param, NULL);
@@ -1200,6 +1221,8 @@ static int asus_wmi_backlight_init(struct asus_wmi *asus)
 	bd->props.power = power;
 	backlight_update_status(bd);
 
+	asus->driver->brightness = bd->props.brightness;
+
 	return 0;
 }
 
@@ -1622,8 +1645,8 @@ static int asus_wmi_add(struct platform_device *pdev)
 	wdrv->platform_device = pdev;
 	platform_set_drvdata(asus->platform_device, asus);
 
-	if (wdrv->quirks)
-		wdrv->quirks(asus->driver);
+	if (wdrv->detect_quirks)
+		wdrv->detect_quirks(asus->driver);
 
 	err = asus_wmi_platform_init(asus);
 	if (err)

commit c09b2237da24e9136fc8053e11244f52903e73e0
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Tue Mar 20 09:53:04 2012 +0100

    asus-wmi: on/off bit is not set when reading the value
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 72d731c21d45..2b883470a9d0 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -411,7 +411,7 @@ static int kbd_led_read(struct asus_wmi *asus, int *level, int *env)
 
 	if (retval >= 0) {
 		if (level)
-			*level = retval & 0x80 ? retval & 0x7F : 0;
+			*level = retval & 0x7F;
 		if (env)
 			*env = (retval >> 8) & 0x7F;
 		retval = 0;

commit 210647af897af8ef2d00828aa2a6b1b42206aae6
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Feb 25 13:54:20 2012 -0800

    PCI: Rename pci_remove_bus_device to pci_stop_and_remove_bus_device
    
    The old pci_remove_bus_device actually did stop and remove.
    
    Make the name reflect that to reduce confusion.
    
    This patch is done by sed scripts and changes back some incorrect
    __pci_remove_bus_device changes.
    
    Suggested-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 72d731c21d45..9929246895de 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -571,7 +571,7 @@ static void asus_rfkill_hotplug(struct asus_wmi *asus)
 		} else {
 			dev = pci_get_slot(bus, 0);
 			if (dev) {
-				pci_remove_bus_device(dev);
+				pci_stop_and_remove_bus_device(dev);
 				pci_dev_put(dev);
 			}
 		}

commit 587a1f1659e8b330b8738ef4901832a2b63f0bed
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jul 23 23:11:19 2011 -0400

    switch ->is_visible() to returning umode_t
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index d1049ee3c9e8..72d731c21d45 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -992,7 +992,7 @@ static struct attribute *hwmon_attributes[] = {
 	NULL
 };
 
-static mode_t asus_hwmon_sysfs_is_visible(struct kobject *kobj,
+static umode_t asus_hwmon_sysfs_is_visible(struct kobject *kobj,
 					  struct attribute *attr, int idx)
 {
 	struct device *dev = container_of(kobj, struct device, kobj);
@@ -1357,7 +1357,7 @@ static struct attribute *platform_attributes[] = {
 	NULL
 };
 
-static mode_t asus_sysfs_is_visible(struct kobject *kobj,
+static umode_t asus_sysfs_is_visible(struct kobject *kobj,
 				    struct attribute *attr, int idx)
 {
 	struct device *dev = container_of(kobj, struct device, kobj);

commit e9298028ee69bda44607156e7348cd32f7ab9360
Author: Axel Lin <axel.lin@gmail.com>
Date:   Mon Aug 8 17:16:01 2011 +0800

    platform-drivers-x86: asus-wmi: fix resource leak in asus_wmi_led_exit
    
    This patch fixes wrong test for successful registered led_classdev,
    and also fixes a leak due to missing led_classdev_unregister call
    for asus->kbd_led in asus_wmi_led_exit.
    
    device_create returns &struct device pointer on success, or ERR_PTR() on error.
    Thus if led_classdev_register fails, led_cdev->dev is always not NULL.
    
    Thus to unregister a successful registered led_classdev, we should check
    (!IS_ERR_OR_NULL(asus->tpd_led.dev)) instead of (asus->tpd_led.dev).
    
    we use IS_ERR_OR_NULL instead of IS_ERR because if we havn't call
    led_classdev_register, the led_cdev->dev is NULL.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Acked-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 95cba9ebf6c0..d1049ee3c9e8 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -453,7 +453,9 @@ static enum led_brightness kbd_led_get(struct led_classdev *led_cdev)
 
 static void asus_wmi_led_exit(struct asus_wmi *asus)
 {
-	if (asus->tpd_led.dev)
+	if (!IS_ERR_OR_NULL(asus->kbd_led.dev))
+		led_classdev_unregister(&asus->kbd_led);
+	if (!IS_ERR_OR_NULL(asus->tpd_led.dev))
 		led_classdev_unregister(&asus->tpd_led);
 	if (asus->led_workqueue)
 		destroy_workqueue(asus->led_workqueue);

commit a912d329102aa13c572989c6adc103685c9d24ae
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Fri Jul 1 11:34:41 2011 +0200

    asus-wmi: add uwb rfkill support
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 57514deb8e2b..95cba9ebf6c0 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -195,6 +195,7 @@ struct asus_wmi {
 	struct asus_rfkill wimax;
 	struct asus_rfkill wwan3g;
 	struct asus_rfkill gps;
+	struct asus_rfkill uwb;
 
 	struct hotplug_slot *hotplug_slot;
 	struct mutex hotplug_lock;
@@ -841,6 +842,11 @@ static void asus_wmi_rfkill_exit(struct asus_wmi *asus)
 		rfkill_destroy(asus->gps.rfkill);
 		asus->gps.rfkill = NULL;
 	}
+	if (asus->uwb.rfkill) {
+		rfkill_unregister(asus->uwb.rfkill);
+		rfkill_destroy(asus->uwb.rfkill);
+		asus->uwb.rfkill = NULL;
+	}
 }
 
 static int asus_wmi_rfkill_init(struct asus_wmi *asus)
@@ -881,6 +887,12 @@ static int asus_wmi_rfkill_init(struct asus_wmi *asus)
 	if (result && result != -ENODEV)
 		goto exit;
 
+	result = asus_new_rfkill(asus, &asus->uwb, "asus-uwb",
+				 RFKILL_TYPE_UWB, ASUS_WMI_DEVID_UWB);
+
+	if (result && result != -ENODEV)
+		goto exit;
+
 	if (!asus->driver->hotplug_wireless)
 		goto exit;
 
@@ -1737,6 +1749,10 @@ static int asus_hotk_restore(struct device *device)
 		bl = !asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_GPS);
 		rfkill_set_sw_state(asus->gps.rfkill, bl);
 	}
+	if (asus->uwb.rfkill) {
+		bl = !asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_UWB);
+		rfkill_set_sw_state(asus->uwb.rfkill, bl);
+	}
 
 	return 0;
 }

commit 43be8bde1fdfbe3f4dedfd04ca4f9d6dd1e04b46
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Fri Jul 1 11:34:40 2011 +0200

    asus-wmi: add gps rfkill support
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 8787dfacf11d..57514deb8e2b 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -194,6 +194,7 @@ struct asus_wmi {
 	struct asus_rfkill bluetooth;
 	struct asus_rfkill wimax;
 	struct asus_rfkill wwan3g;
+	struct asus_rfkill gps;
 
 	struct hotplug_slot *hotplug_slot;
 	struct mutex hotplug_lock;
@@ -835,6 +836,11 @@ static void asus_wmi_rfkill_exit(struct asus_wmi *asus)
 		rfkill_destroy(asus->wwan3g.rfkill);
 		asus->wwan3g.rfkill = NULL;
 	}
+	if (asus->gps.rfkill) {
+		rfkill_unregister(asus->gps.rfkill);
+		rfkill_destroy(asus->gps.rfkill);
+		asus->gps.rfkill = NULL;
+	}
 }
 
 static int asus_wmi_rfkill_init(struct asus_wmi *asus)
@@ -869,6 +875,12 @@ static int asus_wmi_rfkill_init(struct asus_wmi *asus)
 	if (result && result != -ENODEV)
 		goto exit;
 
+	result = asus_new_rfkill(asus, &asus->gps, "asus-gps",
+				 RFKILL_TYPE_GPS, ASUS_WMI_DEVID_GPS);
+
+	if (result && result != -ENODEV)
+		goto exit;
+
 	if (!asus->driver->hotplug_wireless)
 		goto exit;
 
@@ -1721,6 +1733,10 @@ static int asus_hotk_restore(struct device *device)
 		bl = !asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_WWAN3G);
 		rfkill_set_sw_state(asus->wwan3g.rfkill, bl);
 	}
+	if (asus->gps.rfkill) {
+		bl = !asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_GPS);
+		rfkill_set_sw_state(asus->gps.rfkill, bl);
+	}
 
 	return 0;
 }

commit fddbfed595b307f9dddc7a86ddfbcbcb80141e28
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Fri Jul 1 11:34:39 2011 +0200

    asus-wmi: add CWAP support and clarify the meaning of WAPF bits
    
    ref: http://dev.iksaif.net/projects/3/wiki/Asus-laptop_WAPF
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 3b9fb91e25ff..8787dfacf11d 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1413,6 +1413,12 @@ static int asus_wmi_platform_init(struct asus_wmi *asus)
 		return -ENODEV;
 	}
 
+	/* CWAP allow to define the behavior of the Fn+F2 key,
+	 * this method doesn't seems to be present on Eee PCs */
+	if (asus->driver->wapf >= 0)
+		asus_wmi_set_devstate(ASUS_WMI_DEVID_CWAP,
+				      asus->driver->wapf, NULL);
+
 	return asus_wmi_sysfs_init(asus->platform_device);
 }
 

commit 3df5fdadf6400373a696bb14e27d4771e5f6afb3
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Fri Jul 1 11:34:38 2011 +0200

    asus-wmi: return proper value in store_cpufv()
    
    Cc: stable@kernel.org
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index e50872632c5a..3b9fb91e25ff 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1307,14 +1307,18 @@ ASUS_WMI_CREATE_DEVICE_ATTR(cardr, 0644, ASUS_WMI_DEVID_CARDREADER);
 static ssize_t store_cpufv(struct device *dev, struct device_attribute *attr,
 			   const char *buf, size_t count)
 {
-	int value;
+	int value, rv;
 
 	if (!count || sscanf(buf, "%i", &value) != 1)
 		return -EINVAL;
 	if (value < 0 || value > 2)
 		return -EINVAL;
 
-	return asus_wmi_evaluate_method(ASUS_WMI_METHODID_CFVS, value, 0, NULL);
+	rv = asus_wmi_evaluate_method(ASUS_WMI_METHODID_CFVS, value, 0, NULL);
+	if (rv < 0)
+		return rv;
+
+	return count;
 }
 
 static DEVICE_ATTR(cpufv, S_IRUGO | S_IWUSR, NULL, store_cpufv);

commit e02431d6f5e8f1023ce0cfbaf70ddf4afae924d8
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Fri Jul 1 11:34:37 2011 +0200

    asus-wmi: check for temp1 presence
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index d01f767c7b69..e50872632c5a 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -967,7 +967,7 @@ static struct attribute *hwmon_attributes[] = {
 };
 
 static mode_t asus_hwmon_sysfs_is_visible(struct kobject *kobj,
-				    struct attribute *attr, int idx)
+					  struct attribute *attr, int idx)
 {
 	struct device *dev = container_of(kobj, struct device, kobj);
 	struct platform_device *pdev = to_platform_device(dev->parent);
@@ -978,6 +978,8 @@ static mode_t asus_hwmon_sysfs_is_visible(struct kobject *kobj,
 
 	if (attr == &sensor_dev_attr_pwm1.dev_attr.attr)
 		dev_id = ASUS_WMI_DEVID_FAN_CTRL;
+	else if (attr == &sensor_dev_attr_temp1_input.dev_attr.attr)
+		dev_id = ASUS_WMI_DEVID_THERMAL_CTRL;
 
 	if (dev_id != -1) {
 		int err = asus_wmi_get_devstate(asus, dev_id, &value);
@@ -998,6 +1000,10 @@ static mode_t asus_hwmon_sysfs_is_visible(struct kobject *kobj,
 		if (value == ASUS_WMI_UNSUPPORTED_METHOD || value & 0xFFF80000
 		    || (!asus->sfun && !(value & ASUS_WMI_DSTS_PRESENCE_BIT)))
 			ok = false;
+	} else if (dev_id == ASUS_WMI_DEVID_THERMAL_CTRL) {
+		/* If value is zero, something is clearly wrong */
+		if (value == 0)
+			ok = false;
 	}
 
 	return ok ? attr->mode : 0;

commit 6118b8adb50c23714d5be089965082bbbb48d831
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Fri Jul 1 11:34:36 2011 +0200

    asus-wmi: add thermal sensor
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index e60385df4af2..d01f767c7b69 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -44,6 +44,7 @@
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
 #include <linux/platform_device.h>
+#include <linux/thermal.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
@@ -930,7 +931,26 @@ static ssize_t asus_hwmon_pwm1(struct device *dev,
 	return sprintf(buf, "%d\n", value);
 }
 
+static ssize_t asus_hwmon_temp1(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	struct asus_wmi *asus = dev_get_drvdata(dev);
+	u32 value;
+	int err;
+
+	err = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_THERMAL_CTRL, &value);
+
+	if (err < 0)
+		return err;
+
+	value = KELVIN_TO_CELSIUS((value & 0xFFFF)) * 1000;
+
+	return sprintf(buf, "%d\n", value);
+}
+
 static SENSOR_DEVICE_ATTR(pwm1, S_IRUGO, asus_hwmon_pwm1, NULL, 0);
+static SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, asus_hwmon_temp1, NULL, 0);
 
 static ssize_t
 show_name(struct device *dev, struct device_attribute *attr, char *buf)
@@ -941,6 +961,7 @@ static SENSOR_DEVICE_ATTR(name, S_IRUGO, show_name, NULL, 0);
 
 static struct attribute *hwmon_attributes[] = {
 	&sensor_dev_attr_pwm1.dev_attr.attr,
+	&sensor_dev_attr_temp1_input.dev_attr.attr,
 	&sensor_dev_attr_name.dev_attr.attr,
 	NULL
 };

commit 79ec1172c29ed521f1652b0b44dceb84ba115541
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Fri Jul 1 11:34:35 2011 +0200

    asus-wmi: add some device ids
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 4b0384e140f8..e60385df4af2 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -95,6 +95,7 @@ MODULE_LICENSE("GPL");
 /* Wireless */
 #define ASUS_WMI_DEVID_HW_SWITCH	0x00010001
 #define ASUS_WMI_DEVID_WIRELESS_LED	0x00010002
+#define ASUS_WMI_DEVID_CWAP		0x00010003
 #define ASUS_WMI_DEVID_WLAN		0x00010011
 #define ASUS_WMI_DEVID_BLUETOOTH	0x00010013
 #define ASUS_WMI_DEVID_GPS		0x00010015
@@ -104,6 +105,12 @@ MODULE_LICENSE("GPL");
 
 /* Leds */
 /* 0x000200XX and 0x000400XX */
+#define ASUS_WMI_DEVID_LED1		0x00020011
+#define ASUS_WMI_DEVID_LED2		0x00020012
+#define ASUS_WMI_DEVID_LED3		0x00020013
+#define ASUS_WMI_DEVID_LED4		0x00020014
+#define ASUS_WMI_DEVID_LED5		0x00020015
+#define ASUS_WMI_DEVID_LED6		0x00020016
 
 /* Backlight and Brightness */
 #define ASUS_WMI_DEVID_BACKLIGHT	0x00050011

commit af965e973276b015d1b7d9ee78ed8d8df9d6bc98
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Fri Jul 1 11:34:34 2011 +0200

    asus-wmi: fix keyboard backlight detection
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 41a96f2b136e..4b0384e140f8 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -395,8 +395,9 @@ static int kbd_led_read(struct asus_wmi *asus, int *level, int *env)
 	retval = asus_wmi_get_devstate_bits(asus, ASUS_WMI_DEVID_KBD_BACKLIGHT,
 					    0xFFFF);
 
+	/* Unknown status is considered as off */
 	if (retval == 0x8000)
-		retval = -ENODEV;
+		retval = 0;
 
 	if (retval >= 0) {
 		if (level)

commit 8fe8c25ef92ffc773a49c4b0dab2938a6fd64489
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Fri Jul 1 11:34:32 2011 +0200

    asus-wmi: fix section mismatch
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 83a7a8101fd6..41a96f2b136e 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1712,7 +1712,7 @@ static int asus_wmi_probe(struct platform_device *pdev)
 
 static bool used;
 
-int asus_wmi_register_driver(struct asus_wmi_driver *driver)
+int __init_or_module asus_wmi_register_driver(struct asus_wmi_driver *driver)
 {
 	struct platform_driver *platform_driver;
 	struct platform_device *platform_device;

commit e9809c0b9670656855655d8ed6dc33718ec12ba2
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Fri Jul 1 11:34:31 2011 +0200

    asus-wmi: add keyboard backlight support
    
    Based on a patch from Nate Weibley. <nweibley@gmail.com>.
    
    Cc: Nate Weibley <nweibley@gmail.com>
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index fa2b395145a6..83a7a8101fd6 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -66,6 +66,8 @@ MODULE_LICENSE("GPL");
 #define NOTIFY_BRNUP_MAX		0x1f
 #define NOTIFY_BRNDOWN_MIN		0x20
 #define NOTIFY_BRNDOWN_MAX		0x2e
+#define NOTIFY_KBD_BRTUP		0xc4
+#define NOTIFY_KBD_BRTDWN		0xc5
 
 /* WMI Methods */
 #define ASUS_WMI_METHODID_SPEC	        0x43455053 /* BIOS SPECification */
@@ -174,8 +176,11 @@ struct asus_wmi {
 
 	struct led_classdev tpd_led;
 	int tpd_led_wk;
+	struct led_classdev kbd_led;
+	int kbd_led_wk;
 	struct workqueue_struct *led_workqueue;
 	struct work_struct tpd_led_work;
+	struct work_struct kbd_led_work;
 
 	struct asus_rfkill wlan;
 	struct asus_rfkill bluetooth;
@@ -360,30 +365,79 @@ static enum led_brightness tpd_led_get(struct led_classdev *led_cdev)
 	return read_tpd_led_state(asus);
 }
 
-static int asus_wmi_led_init(struct asus_wmi *asus)
+static void kbd_led_update(struct work_struct *work)
 {
-	int rv;
+	int ctrl_param = 0;
+	struct asus_wmi *asus;
 
-	if (read_tpd_led_state(asus) < 0)
-		return 0;
+	asus = container_of(work, struct asus_wmi, kbd_led_work);
 
-	asus->led_workqueue = create_singlethread_workqueue("led_workqueue");
-	if (!asus->led_workqueue)
-		return -ENOMEM;
-	INIT_WORK(&asus->tpd_led_work, tpd_led_update);
+	/*
+	 * bits 0-2: level
+	 * bit 7: light on/off
+	 */
+	if (asus->kbd_led_wk > 0)
+		ctrl_param = 0x80 | (asus->kbd_led_wk & 0x7F);
 
-	asus->tpd_led.name = "asus::touchpad";
-	asus->tpd_led.brightness_set = tpd_led_set;
-	asus->tpd_led.brightness_get = tpd_led_get;
-	asus->tpd_led.max_brightness = 1;
+	asus_wmi_set_devstate(ASUS_WMI_DEVID_KBD_BACKLIGHT, ctrl_param, NULL);
+}
 
-	rv = led_classdev_register(&asus->platform_device->dev, &asus->tpd_led);
-	if (rv) {
-		destroy_workqueue(asus->led_workqueue);
-		return rv;
+static int kbd_led_read(struct asus_wmi *asus, int *level, int *env)
+{
+	int retval;
+
+	/*
+	 * bits 0-2: level
+	 * bit 7: light on/off
+	 * bit 8-10: environment (0: dark, 1: normal, 2: light)
+	 * bit 17: status unknown
+	 */
+	retval = asus_wmi_get_devstate_bits(asus, ASUS_WMI_DEVID_KBD_BACKLIGHT,
+					    0xFFFF);
+
+	if (retval == 0x8000)
+		retval = -ENODEV;
+
+	if (retval >= 0) {
+		if (level)
+			*level = retval & 0x80 ? retval & 0x7F : 0;
+		if (env)
+			*env = (retval >> 8) & 0x7F;
+		retval = 0;
 	}
 
-	return 0;
+	return retval;
+}
+
+static void kbd_led_set(struct led_classdev *led_cdev,
+			enum led_brightness value)
+{
+	struct asus_wmi *asus;
+
+	asus = container_of(led_cdev, struct asus_wmi, kbd_led);
+
+	if (value > asus->kbd_led.max_brightness)
+		value = asus->kbd_led.max_brightness;
+	else if (value < 0)
+		value = 0;
+
+	asus->kbd_led_wk = value;
+	queue_work(asus->led_workqueue, &asus->kbd_led_work);
+}
+
+static enum led_brightness kbd_led_get(struct led_classdev *led_cdev)
+{
+	struct asus_wmi *asus;
+	int retval, value;
+
+	asus = container_of(led_cdev, struct asus_wmi, kbd_led);
+
+	retval = kbd_led_read(asus, &value, NULL);
+
+	if (retval < 0)
+		return retval;
+
+	return value;
 }
 
 static void asus_wmi_led_exit(struct asus_wmi *asus)
@@ -394,6 +448,48 @@ static void asus_wmi_led_exit(struct asus_wmi *asus)
 		destroy_workqueue(asus->led_workqueue);
 }
 
+static int asus_wmi_led_init(struct asus_wmi *asus)
+{
+	int rv = 0;
+
+	asus->led_workqueue = create_singlethread_workqueue("led_workqueue");
+	if (!asus->led_workqueue)
+		return -ENOMEM;
+
+	if (read_tpd_led_state(asus) >= 0) {
+		INIT_WORK(&asus->tpd_led_work, tpd_led_update);
+
+		asus->tpd_led.name = "asus::touchpad";
+		asus->tpd_led.brightness_set = tpd_led_set;
+		asus->tpd_led.brightness_get = tpd_led_get;
+		asus->tpd_led.max_brightness = 1;
+
+		rv = led_classdev_register(&asus->platform_device->dev,
+					   &asus->tpd_led);
+		if (rv)
+			goto error;
+	}
+
+	if (kbd_led_read(asus, NULL, NULL) >= 0) {
+		INIT_WORK(&asus->kbd_led_work, kbd_led_update);
+
+		asus->kbd_led.name = "asus::kbd_backlight";
+		asus->kbd_led.brightness_set = kbd_led_set;
+		asus->kbd_led.brightness_get = kbd_led_get;
+		asus->kbd_led.max_brightness = 3;
+
+		rv = led_classdev_register(&asus->platform_device->dev,
+					   &asus->kbd_led);
+	}
+
+error:
+	if (rv)
+		asus_wmi_led_exit(asus);
+
+	return rv;
+}
+
+
 /*
  * PCI hotplug (for wlan rfkill)
  */

commit 57d5c8e742dbb8cdc794d9e0fee769c9533072af
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Fri Jul 1 11:34:30 2011 +0200

    asus-wmi: second part of the version starts at 16 not 8
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 0fce7de77b1c..fa2b395145a6 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1246,7 +1246,7 @@ static int asus_wmi_platform_init(struct asus_wmi *asus)
 
 	/* We don't know yet what to do with this version... */
 	if (!asus_wmi_evaluate_method(ASUS_WMI_METHODID_SPEC, 0, 0x9, &rv)) {
-		pr_info("BIOS WMI version: %d.%d", rv >> 8, rv & 0xFF);
+		pr_info("BIOS WMI version: %d.%d", rv >> 16, rv & 0xFF);
 		asus->spec = rv;
 	}
 

commit 39bbde059973d3337ae5f2fae5097d52599415e4
Author: Seth Forshee <seth.forshee@canonical.com>
Date:   Mon Jul 4 09:49:20 2011 +0200

    asus-wmi: Enable autorepeat for hotkey input device
    
    The T101MT Home/Express Gate key autorepeats in hardware, but
    sparse-keymap does not support hardware autorepeat. Enable the
    input core's software autorepeat to emulate the hardware behavior.
    Normal hotkeys are autoreleased, so the behavior of these keys
    will not be affected.
    
    Signed-off-by: Seth Forshee <seth.forshee@canonical.com>
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index cea9fdcad64c..0fce7de77b1c 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -205,6 +205,7 @@ static int asus_wmi_input_init(struct asus_wmi *asus)
 	asus->inputdev->phys = asus->driver->input_phys;
 	asus->inputdev->id.bustype = BUS_HOST;
 	asus->inputdev->dev.parent = &asus->platform_device->dev;
+	set_bit(EV_REP, asus->inputdev->evbit);
 
 	err = sparse_keymap_setup(asus->inputdev, asus->driver->keymap, NULL);
 	if (err)

commit c4453f6a7ceff330ff37a9712ee8305fc3f8e9b6
Author: Seth Forshee <seth.forshee@canonical.com>
Date:   Fri Jul 1 11:34:27 2011 +0200

    asus-wmi: Add callback for hotkey filtering
    
    This is required for the T101MT home key, which behaves differently
    than other hotkeys.
    
    Signed-off-by: Seth Forshee <seth.forshee@canonical.com>
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index bcb9fb41ddc4..cea9fdcad64c 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1061,6 +1061,8 @@ static void asus_wmi_notify(u32 value, void *context)
 	acpi_status status;
 	int code;
 	int orig_code;
+	unsigned int key_value = 1;
+	bool autorelease = 1;
 
 	status = wmi_get_event_data(value, &response);
 	if (status != AE_OK) {
@@ -1076,6 +1078,13 @@ static void asus_wmi_notify(u32 value, void *context)
 	code = obj->integer.value;
 	orig_code = code;
 
+	if (asus->driver->key_filter) {
+		asus->driver->key_filter(asus->driver, &code, &key_value,
+					 &autorelease);
+		if (code == ASUS_WMI_KEY_IGNORE)
+			goto exit;
+	}
+
 	if (code >= NOTIFY_BRNUP_MIN && code <= NOTIFY_BRNUP_MAX)
 		code = NOTIFY_BRNUP_MIN;
 	else if (code >= NOTIFY_BRNDOWN_MIN &&
@@ -1085,7 +1094,8 @@ static void asus_wmi_notify(u32 value, void *context)
 	if (code == NOTIFY_BRNUP_MIN || code == NOTIFY_BRNDOWN_MIN) {
 		if (!acpi_video_backlight_support())
 			asus_wmi_backlight_notify(asus, orig_code);
-	} else if (!sparse_keymap_report_event(asus->inputdev, code, 1, true))
+	} else if (!sparse_keymap_report_event(asus->inputdev, code,
+					       key_value, autorelease))
 		pr_info("Unknown key %x pressed\n", code);
 
 exit:

commit 49979d091d1847823c064301da1ec173619ddd92
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Fri Jul 1 11:34:26 2011 +0200

    asus-wmi: fix hwmon/pwm1
    
    The code was completly broken, and should never had been sent
    to the kernel. That's what happens when you write code without
    hardware to test it.
    
    Cc: stable@kernel.org
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 65b66aa44c78..bcb9fb41ddc4 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -797,8 +797,8 @@ static int asus_wmi_rfkill_init(struct asus_wmi *asus)
  * Hwmon device
  */
 static ssize_t asus_hwmon_pwm1(struct device *dev,
-			    struct device_attribute *attr,
-			    char *buf)
+			       struct device_attribute *attr,
+			       char *buf)
 {
 	struct asus_wmi *asus = dev_get_drvdata(dev);
 	u32 value;
@@ -809,7 +809,7 @@ static ssize_t asus_hwmon_pwm1(struct device *dev,
 	if (err < 0)
 		return err;
 
-	value |= 0xFF;
+	value &= 0xFF;
 
 	if (value == 1) /* Low Speed */
 		value = 85;
@@ -869,7 +869,7 @@ static mode_t asus_hwmon_sysfs_is_visible(struct kobject *kobj,
 		 * - reverved bits are non-zero
 		 * - sfun and presence bit are not set
 		 */
-		if (value != ASUS_WMI_UNSUPPORTED_METHOD || value & 0xFFF80000
+		if (value == ASUS_WMI_UNSUPPORTED_METHOD || value & 0xFFF80000
 		    || (!asus->sfun && !(value & ASUS_WMI_DSTS_PRESENCE_BIT)))
 			ok = false;
 	}
@@ -904,6 +904,7 @@ static int asus_wmi_hwmon_init(struct asus_wmi *asus)
 		pr_err("Could not register asus hwmon device\n");
 		return PTR_ERR(hwmon);
 	}
+	dev_set_drvdata(hwmon, asus);
 	asus->hwmon_device = hwmon;
 	result = sysfs_create_group(&hwmon->kobj, &hwmon_attribute_group);
 	if (result)

commit e772aed369779c98f44e83ccd7fb1b713953cd09
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jul 23 20:59:40 2011 -0400

    asus-wmi: ->is_visible() can't return negative
    
    It's mode_t; return 0 (no access) on error.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 3c7857c71a23..65b66aa44c78 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -857,7 +857,7 @@ static mode_t asus_hwmon_sysfs_is_visible(struct kobject *kobj,
 		int err = asus_wmi_get_devstate(asus, dev_id, &value);
 
 		if (err < 0)
-			return err;
+			return 0; /* can't return negative here */
 	}
 
 	if (dev_id == ASUS_WMI_DEVID_FAN_CTRL) {

commit 60cfa098dc60a9988e18d0bbab735e10c744e6fe
Author: Axel Lin <axel.lin@gmail.com>
Date:   Wed Jun 29 11:43:30 2011 +0800

    platform-drivers-x86: set backlight type to BACKLIGHT_PLATFORM
    
    Some newly added drivers do not set backlight type, as a result
    /sys/class/backlight/<backlight>/type shows incorrect backlight type.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Cc: Corentin Chary <corentin.chary@gmail.com>
    Cc: Yin Kangkai <kangkai.yin@intel.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 00460cb9587b..3c7857c71a23 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1025,6 +1025,7 @@ static int asus_wmi_backlight_init(struct asus_wmi *asus)
 		return power;
 
 	memset(&props, 0, sizeof(struct backlight_properties));
+	props.type = BACKLIGHT_PLATFORM;
 	props.max_brightness = max;
 	bd = backlight_device_register(asus->driver->name,
 				       &asus->platform_device->dev, asus,

commit 5ad77dcfb49a85715bcb9174a133cba140eda1bc
Author: Joe Perches <joe@perches.com>
Date:   Tue Mar 29 15:21:35 2011 -0700

    asus: Add pr_fmt and convert printks to pr_<level>
    
    Add pr_fmt, prefixes each log message.
    Convert printks to pr_<level>.
    Convert pr_warning to pr_warn.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index c8c9842753dc..00460cb9587b 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -425,7 +425,7 @@ static void asus_rfkill_hotplug(struct asus_wmi *asus)
 	if (asus->hotplug_slot) {
 		bus = pci_find_bus(0, 1);
 		if (!bus) {
-			pr_warning("Unable to find PCI bus 1?\n");
+			pr_warn("Unable to find PCI bus 1?\n");
 			goto out_unlock;
 		}
 
@@ -436,12 +436,12 @@ static void asus_rfkill_hotplug(struct asus_wmi *asus)
 		absent = (l == 0xffffffff);
 
 		if (blocked != absent) {
-			pr_warning("BIOS says wireless lan is %s, "
-				   "but the pci device is %s\n",
-				   blocked ? "blocked" : "unblocked",
-				   absent ? "absent" : "present");
-			pr_warning("skipped wireless hotplug as probably "
-				   "inappropriate for this model\n");
+			pr_warn("BIOS says wireless lan is %s, "
+				"but the pci device is %s\n",
+				blocked ? "blocked" : "unblocked",
+				absent ? "absent" : "present");
+			pr_warn("skipped wireless hotplug as probably "
+				"inappropriate for this model\n");
 			goto out_unlock;
 		}
 
@@ -500,7 +500,7 @@ static int asus_register_rfkill_notifier(struct asus_wmi *asus, char *node)
 						     ACPI_SYSTEM_NOTIFY,
 						     asus_rfkill_notify, asus);
 		if (ACPI_FAILURE(status))
-			pr_warning("Failed to register notify on %s\n", node);
+			pr_warn("Failed to register notify on %s\n", node);
 	} else
 		return -ENODEV;
 
@@ -1583,12 +1583,12 @@ static int asus_wmi_probe(struct platform_device *pdev)
 	int ret;
 
 	if (!wmi_has_guid(ASUS_WMI_MGMT_GUID)) {
-		pr_warning("Management GUID not found\n");
+		pr_warn("Management GUID not found\n");
 		return -ENODEV;
 	}
 
 	if (wdrv->event_guid && !wmi_has_guid(wdrv->event_guid)) {
-		pr_warning("Event GUID not found\n");
+		pr_warn("Event GUID not found\n");
 		return -ENODEV;
 	}
 

commit 39ddf3bf6463bc86041e806b43e014d50a144aa4
Author: Joe Perches <joe@perches.com>
Date:   Tue Mar 29 15:21:32 2011 -0700

    asus-wmi: Remove __init from asus_wmi_platform_init
    
    It's used by a non-init function.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 832a3fd7c1c8..c8c9842753dc 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1223,7 +1223,7 @@ static int asus_wmi_sysfs_init(struct platform_device *device)
 /*
  * Platform device
  */
-static int __init asus_wmi_platform_init(struct asus_wmi *asus)
+static int asus_wmi_platform_init(struct asus_wmi *asus)
 {
 	int rv;
 

commit 58a9f397ac9288403d600b22b8472c0d164ee8cb
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Wed Mar 30 16:32:32 2011 +0200

    asus-wmi: swap input name and phys
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index efc776cb0c66..832a3fd7c1c8 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -201,8 +201,8 @@ static int asus_wmi_input_init(struct asus_wmi *asus)
 	if (!asus->inputdev)
 		return -ENOMEM;
 
-	asus->inputdev->name = asus->driver->input_phys;
-	asus->inputdev->phys = asus->driver->input_name;
+	asus->inputdev->name = asus->driver->input_name;
+	asus->inputdev->phys = asus->driver->input_phys;
 	asus->inputdev->id.bustype = BUS_HOST;
 	asus->inputdev->dev.parent = &asus->platform_device->dev;
 

commit a1d6086739c5b8f23a48e02e62b0e495321a2122
Author: Dan Carpenter <error27@gmail.com>
Date:   Tue Mar 15 10:07:37 2011 +0300

    asus-wmi: potential NULL dereference in show_call()
    
    In the earlier check we assumed that "obj" could be NULL.  I looked at
    some of the other places that call evaluate_object() and they check
    for NULL as well.
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index a038595200ee..efc776cb0c66 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1343,7 +1343,7 @@ static int show_call(struct seq_file *m, void *data)
 	else
 		seq_printf(m, "%#x(%#x, %#x) = t:%d\n", asus->debug.method_id,
 			   asus->debug.dev_id, asus->debug.ctrl_param,
-			   obj->type);
+			   obj ? obj->type : -1);
 
 	kfree(obj);
 

commit 0986f25fbba8827762b35222bb45d2fbb2d72fa4
Author: Dan Carpenter <error27@gmail.com>
Date:   Tue Mar 15 10:06:23 2011 +0300

    asus-wmi: signedness bug in read_brightness()
    
    "err" needs to be signed for the error handling to work.
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 5b779a9443d6..a038595200ee 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -946,7 +946,8 @@ static int read_brightness_max(struct asus_wmi *asus)
 static int read_brightness(struct backlight_device *bd)
 {
 	struct asus_wmi *asus = bl_get_data(bd);
-	u32 retval, err;
+	u32 retval;
+	int err;
 
 	err = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_BRIGHTNESS, &retval);
 

commit e07babde13460d7b03842a6de8f22fbef93709e1
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sat Feb 26 10:20:42 2011 +0100

    asus-wmi: add hwmon interface and pwm1
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 05db6b2067b5..5b779a9443d6 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -39,6 +39,8 @@
 #include <linux/rfkill.h>
 #include <linux/pci.h>
 #include <linux/pci_hotplug.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
 #include <linux/platform_device.h>
@@ -167,6 +169,7 @@ struct asus_wmi {
 
 	struct input_dev *inputdev;
 	struct backlight_device *backlight_device;
+	struct device *hwmon_device;
 	struct platform_device *platform_device;
 
 	struct led_classdev tpd_led;
@@ -790,6 +793,124 @@ static int asus_wmi_rfkill_init(struct asus_wmi *asus)
 	return result;
 }
 
+/*
+ * Hwmon device
+ */
+static ssize_t asus_hwmon_pwm1(struct device *dev,
+			    struct device_attribute *attr,
+			    char *buf)
+{
+	struct asus_wmi *asus = dev_get_drvdata(dev);
+	u32 value;
+	int err;
+
+	err = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_FAN_CTRL, &value);
+
+	if (err < 0)
+		return err;
+
+	value |= 0xFF;
+
+	if (value == 1) /* Low Speed */
+		value = 85;
+	else if (value == 2)
+		value = 170;
+	else if (value == 3)
+		value = 255;
+	else if (value != 0) {
+		pr_err("Unknown fan speed %#x", value);
+		value = -1;
+	}
+
+	return sprintf(buf, "%d\n", value);
+}
+
+static SENSOR_DEVICE_ATTR(pwm1, S_IRUGO, asus_hwmon_pwm1, NULL, 0);
+
+static ssize_t
+show_name(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "asus\n");
+}
+static SENSOR_DEVICE_ATTR(name, S_IRUGO, show_name, NULL, 0);
+
+static struct attribute *hwmon_attributes[] = {
+	&sensor_dev_attr_pwm1.dev_attr.attr,
+	&sensor_dev_attr_name.dev_attr.attr,
+	NULL
+};
+
+static mode_t asus_hwmon_sysfs_is_visible(struct kobject *kobj,
+				    struct attribute *attr, int idx)
+{
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct platform_device *pdev = to_platform_device(dev->parent);
+	struct asus_wmi *asus = platform_get_drvdata(pdev);
+	bool ok = true;
+	int dev_id = -1;
+	u32 value = ASUS_WMI_UNSUPPORTED_METHOD;
+
+	if (attr == &sensor_dev_attr_pwm1.dev_attr.attr)
+		dev_id = ASUS_WMI_DEVID_FAN_CTRL;
+
+	if (dev_id != -1) {
+		int err = asus_wmi_get_devstate(asus, dev_id, &value);
+
+		if (err < 0)
+			return err;
+	}
+
+	if (dev_id == ASUS_WMI_DEVID_FAN_CTRL) {
+		/*
+		 * We need to find a better way, probably using sfun,
+		 * bits or spec ...
+		 * Currently we disable it if:
+		 * - ASUS_WMI_UNSUPPORTED_METHOD is returned
+		 * - reverved bits are non-zero
+		 * - sfun and presence bit are not set
+		 */
+		if (value != ASUS_WMI_UNSUPPORTED_METHOD || value & 0xFFF80000
+		    || (!asus->sfun && !(value & ASUS_WMI_DSTS_PRESENCE_BIT)))
+			ok = false;
+	}
+
+	return ok ? attr->mode : 0;
+}
+
+static struct attribute_group hwmon_attribute_group = {
+	.is_visible = asus_hwmon_sysfs_is_visible,
+	.attrs = hwmon_attributes
+};
+
+static void asus_wmi_hwmon_exit(struct asus_wmi *asus)
+{
+	struct device *hwmon;
+
+	hwmon = asus->hwmon_device;
+	if (!hwmon)
+		return;
+	sysfs_remove_group(&hwmon->kobj, &hwmon_attribute_group);
+	hwmon_device_unregister(hwmon);
+	asus->hwmon_device = NULL;
+}
+
+static int asus_wmi_hwmon_init(struct asus_wmi *asus)
+{
+	struct device *hwmon;
+	int result;
+
+	hwmon = hwmon_device_register(&asus->platform_device->dev);
+	if (IS_ERR(hwmon)) {
+		pr_err("Could not register asus hwmon device\n");
+		return PTR_ERR(hwmon);
+	}
+	asus->hwmon_device = hwmon;
+	result = sysfs_create_group(&hwmon->kobj, &hwmon_attribute_group);
+	if (result)
+		asus_wmi_hwmon_exit(asus);
+	return result;
+}
+
 /*
  * Backlight
  */
@@ -1331,6 +1452,10 @@ static int asus_wmi_add(struct platform_device *pdev)
 	if (err)
 		goto fail_input;
 
+	err = asus_wmi_hwmon_init(asus);
+	if (err)
+		goto fail_hwmon;
+
 	err = asus_wmi_led_init(asus);
 	if (err)
 		goto fail_leds;
@@ -1369,6 +1494,8 @@ static int asus_wmi_add(struct platform_device *pdev)
 fail_rfkill:
 	asus_wmi_led_exit(asus);
 fail_leds:
+	asus_wmi_hwmon_exit(asus);
+fail_hwmon:
 	asus_wmi_input_exit(asus);
 fail_input:
 	asus_wmi_platform_exit(asus);
@@ -1385,6 +1512,7 @@ static int asus_wmi_remove(struct platform_device *device)
 	wmi_remove_notify_handler(asus->driver->event_guid);
 	asus_wmi_backlight_exit(asus);
 	asus_wmi_input_exit(asus);
+	asus_wmi_hwmon_exit(asus);
 	asus_wmi_led_exit(asus);
 	asus_wmi_rfkill_exit(asus);
 	asus_wmi_debugfs_exit(asus);

commit 2f686b54fbfcd82ebfb650a5c628c1b9ba8b9863
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sat Feb 26 10:20:41 2011 +0100

    asus-wmi: add some common device ids and method ids
    
    I also found some leds ids (0x00020011-0x00020016 and 0x00040015),
    but since they are not really present on the notebook,
    I can't guess their name .
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 9095c28340cd..05db6b2067b5 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -66,25 +66,46 @@ MODULE_LICENSE("GPL");
 #define NOTIFY_BRNDOWN_MAX		0x2e
 
 /* WMI Methods */
-#define ASUS_WMI_METHODID_SPEC	        0x43455053
-#define ASUS_WMI_METHODID_SFUN		0x4E554653
-#define ASUS_WMI_METHODID_DSTS		0x53544344
-#define ASUS_WMI_METHODID_DSTS2		0x53545344
-#define ASUS_WMI_METHODID_DEVS		0x53564544
-#define ASUS_WMI_METHODID_CFVS		0x53564643
-#define ASUS_WMI_METHODID_INIT		0x54494E49
+#define ASUS_WMI_METHODID_SPEC	        0x43455053 /* BIOS SPECification */
+#define ASUS_WMI_METHODID_SFBD		0x44424653 /* Set First Boot Device */
+#define ASUS_WMI_METHODID_GLCD		0x44434C47 /* Get LCD status */
+#define ASUS_WMI_METHODID_GPID		0x44495047 /* Get Panel ID?? (Resol) */
+#define ASUS_WMI_METHODID_QMOD		0x444F4D51 /* Quiet MODe */
+#define ASUS_WMI_METHODID_SPLV		0x4C425053 /* Set Panel Light Value */
+#define ASUS_WMI_METHODID_SFUN		0x4E554653 /* FUNCtionalities */
+#define ASUS_WMI_METHODID_SDSP		0x50534453 /* Set DiSPlay output */
+#define ASUS_WMI_METHODID_GDSP		0x50534447 /* Get DiSPlay output */
+#define ASUS_WMI_METHODID_DEVP		0x50564544 /* DEVice Policy */
+#define ASUS_WMI_METHODID_OSVR		0x5256534F /* OS VeRsion */
+#define ASUS_WMI_METHODID_DSTS		0x53544344 /* Device STatuS */
+#define ASUS_WMI_METHODID_DSTS2		0x53545344 /* Device STatuS #2*/
+#define ASUS_WMI_METHODID_BSTS		0x53545342 /* Bios STatuS ? */
+#define ASUS_WMI_METHODID_DEVS		0x53564544 /* DEVice Set */
+#define ASUS_WMI_METHODID_CFVS		0x53564643 /* CPU Frequency Volt Set */
+#define ASUS_WMI_METHODID_KBFT		0x5446424B /* KeyBoard FilTer */
+#define ASUS_WMI_METHODID_INIT		0x54494E49 /* INITialize */
+#define ASUS_WMI_METHODID_HKEY		0x59454B48 /* Hot KEY ?? */
 
 #define ASUS_WMI_UNSUPPORTED_METHOD	0xFFFFFFFE
 
 /* Wireless */
+#define ASUS_WMI_DEVID_HW_SWITCH	0x00010001
+#define ASUS_WMI_DEVID_WIRELESS_LED	0x00010002
 #define ASUS_WMI_DEVID_WLAN		0x00010011
 #define ASUS_WMI_DEVID_BLUETOOTH	0x00010013
+#define ASUS_WMI_DEVID_GPS		0x00010015
 #define ASUS_WMI_DEVID_WIMAX		0x00010017
 #define ASUS_WMI_DEVID_WWAN3G		0x00010019
+#define ASUS_WMI_DEVID_UWB		0x00010021
+
+/* Leds */
+/* 0x000200XX and 0x000400XX */
 
 /* Backlight and Brightness */
 #define ASUS_WMI_DEVID_BACKLIGHT	0x00050011
 #define ASUS_WMI_DEVID_BRIGHTNESS	0x00050012
+#define ASUS_WMI_DEVID_KBD_BACKLIGHT	0x00050021
+#define ASUS_WMI_DEVID_LIGHT_SENSOR	0x00050022 /* ?? */
 
 /* Misc */
 #define ASUS_WMI_DEVID_CAMERA		0x00060013
@@ -96,10 +117,19 @@ MODULE_LICENSE("GPL");
 #define ASUS_WMI_DEVID_TOUCHPAD		0x00100011
 #define ASUS_WMI_DEVID_TOUCHPAD_LED	0x00100012
 
+/* Fan, Thermal */
+#define ASUS_WMI_DEVID_THERMAL_CTRL	0x00110011
+#define ASUS_WMI_DEVID_FAN_CTRL		0x00110012
+
+/* Power */
+#define ASUS_WMI_DEVID_PROCESSOR_STATE	0x00120012
+
 /* DSTS masks */
 #define ASUS_WMI_DSTS_STATUS_BIT	0x00000001
 #define ASUS_WMI_DSTS_UNKNOWN_BIT	0x00000002
 #define ASUS_WMI_DSTS_PRESENCE_BIT	0x00010000
+#define ASUS_WMI_DSTS_USER_BIT		0x00020000
+#define ASUS_WMI_DSTS_BIOS_BIT		0x00040000
 #define ASUS_WMI_DSTS_BRIGHTNESS_MASK	0x000000FF
 #define ASUS_WMI_DSTS_MAX_BRIGTH_MASK	0x0000FF00
 

commit ef343491db1770a3af5010ba007167c348cdbe1a
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sat Feb 26 10:20:39 2011 +0100

    asus-wmi: allow debugfs interface to call arbitrary method
    
    Also add some # format flags to debugfs output.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 88596ea0f74e..9095c28340cd 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -112,11 +112,14 @@ struct bios_args {
  * <platform>/    - debugfs root directory
  *   dev_id      - current dev_id
  *   ctrl_param  - current ctrl_param
+ *   method_id   - current method_id
  *   devs        - call DEVS(dev_id, ctrl_param) and print result
  *   dsts        - call DSTS(dev_id)  and print result
+ *   call        - call method_id(dev_id, ctrl_param) and print result
  */
 struct asus_wmi_debug {
 	struct dentry *root;
+	u32 method_id;
 	u32 dev_id;
 	u32 ctrl_param;
 };
@@ -1138,7 +1141,7 @@ static int show_dsts(struct seq_file *m, void *data)
 	if (err < 0)
 		return err;
 
-	seq_printf(m, "DSTS(%x) = %x\n", asus->debug.dev_id, retval);
+	seq_printf(m, "DSTS(%#x) = %#x\n", asus->debug.dev_id, retval);
 
 	return 0;
 }
@@ -1155,15 +1158,50 @@ static int show_devs(struct seq_file *m, void *data)
 	if (err < 0)
 		return err;
 
-	seq_printf(m, "DEVS(%x, %x) = %x\n", asus->debug.dev_id,
+	seq_printf(m, "DEVS(%#x, %#x) = %#x\n", asus->debug.dev_id,
 		   asus->debug.ctrl_param, retval);
 
 	return 0;
 }
 
+static int show_call(struct seq_file *m, void *data)
+{
+	struct asus_wmi *asus = m->private;
+	struct bios_args args = {
+		.arg0 = asus->debug.dev_id,
+		.arg1 = asus->debug.ctrl_param,
+	};
+	struct acpi_buffer input = { (acpi_size) sizeof(args), &args };
+	struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *obj;
+	acpi_status status;
+
+	status = wmi_evaluate_method(ASUS_WMI_MGMT_GUID,
+				     1, asus->debug.method_id,
+				     &input, &output);
+
+	if (ACPI_FAILURE(status))
+		return -EIO;
+
+	obj = (union acpi_object *)output.pointer;
+	if (obj && obj->type == ACPI_TYPE_INTEGER)
+		seq_printf(m, "%#x(%#x, %#x) = %#x\n", asus->debug.method_id,
+			   asus->debug.dev_id, asus->debug.ctrl_param,
+			   (u32) obj->integer.value);
+	else
+		seq_printf(m, "%#x(%#x, %#x) = t:%d\n", asus->debug.method_id,
+			   asus->debug.dev_id, asus->debug.ctrl_param,
+			   obj->type);
+
+	kfree(obj);
+
+	return 0;
+}
+
 static struct asus_wmi_debugfs_node asus_wmi_debug_files[] = {
 	{NULL, "devs", show_devs},
 	{NULL, "dsts", show_dsts},
+	{NULL, "call", show_call},
 };
 
 static int asus_wmi_debugfs_open(struct inode *inode, struct file *file)
@@ -1197,6 +1235,11 @@ static int asus_wmi_debugfs_init(struct asus_wmi *asus)
 		goto error_debugfs;
 	}
 
+	dent = debugfs_create_x32("method_id", S_IRUGO | S_IWUSR,
+				  asus->debug.root, &asus->debug.method_id);
+	if (!dent)
+		goto error_debugfs;
+
 	dent = debugfs_create_x32("dev_id", S_IRUGO | S_IWUSR,
 				  asus->debug.root, &asus->debug.dev_id);
 	if (!dent)

commit 46dbca871df753ce92c321a41a8a38eba7487680
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sat Feb 26 10:20:38 2011 +0100

    asus-wmi: add calls to INIT, SPEC and SFUN on init
    
    INIT() call is needed to enable hotkeys on G73
    SPEC() and SFUN() allow us to know more about
    available features.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index adf7b05c9aef..88596ea0f74e 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -66,10 +66,13 @@ MODULE_LICENSE("GPL");
 #define NOTIFY_BRNDOWN_MAX		0x2e
 
 /* WMI Methods */
+#define ASUS_WMI_METHODID_SPEC	        0x43455053
+#define ASUS_WMI_METHODID_SFUN		0x4E554653
 #define ASUS_WMI_METHODID_DSTS		0x53544344
 #define ASUS_WMI_METHODID_DSTS2		0x53545344
 #define ASUS_WMI_METHODID_DEVS		0x53564544
 #define ASUS_WMI_METHODID_CFVS		0x53564643
+#define ASUS_WMI_METHODID_INIT		0x54494E49
 
 #define ASUS_WMI_UNSUPPORTED_METHOD	0xFFFFFFFE
 
@@ -126,6 +129,8 @@ struct asus_rfkill {
 
 struct asus_wmi {
 	int dsts_id;
+	int spec;
+	int sfun;
 
 	struct input_dev *inputdev;
 	struct backlight_device *backlight_device;
@@ -1065,6 +1070,29 @@ static int asus_wmi_sysfs_init(struct platform_device *device)
  */
 static int __init asus_wmi_platform_init(struct asus_wmi *asus)
 {
+	int rv;
+
+	/* INIT enable hotkeys on some models */
+	if (!asus_wmi_evaluate_method(ASUS_WMI_METHODID_INIT, 0, 0, &rv))
+		pr_info("Initialization: %#x", rv);
+
+	/* We don't know yet what to do with this version... */
+	if (!asus_wmi_evaluate_method(ASUS_WMI_METHODID_SPEC, 0, 0x9, &rv)) {
+		pr_info("BIOS WMI version: %d.%d", rv >> 8, rv & 0xFF);
+		asus->spec = rv;
+	}
+
+	/*
+	 * The SFUN method probably allows the original driver to get the list
+	 * of features supported by a given model. For now, 0x0100 or 0x0800
+	 * bit signifies that the laptop is equipped with a Wi-Fi MiniPCI card.
+	 * The significance of others is yet to be found.
+	 */
+	if (!asus_wmi_evaluate_method(ASUS_WMI_METHODID_SFUN, 0, 0, &rv)) {
+		pr_info("SFUN value: %#x", rv);
+		asus->sfun = rv;
+	}
+
 	/*
 	 * Eee PC and Notebooks seems to have different method_id for DSTS,
 	 * but it may also be related to the BIOS's SPEC.

commit 8fbea019a1a70e0fb01e0f98c963e6042fbe94ab
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sat Feb 26 10:20:37 2011 +0100

    asus-wmi: fix and clean backlight code
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index fd5b08eecf1e..adf7b05c9aef 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -765,14 +765,32 @@ static int read_backlight_power(struct asus_wmi *asus)
 	return ret ? FB_BLANK_UNBLANK : FB_BLANK_POWERDOWN;
 }
 
-static int read_brightness(struct backlight_device *bd)
+static int read_brightness_max(struct asus_wmi *asus)
 {
-	struct asus_wmi *asus = bl_get_data(bd);
 	u32 retval;
 	int err;
 
 	err = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_BRIGHTNESS, &retval);
 
+	if (err < 0)
+		return err;
+
+	retval = retval & ASUS_WMI_DSTS_MAX_BRIGTH_MASK;
+	retval >>= 8;
+
+	if (!retval)
+		return -ENODEV;
+
+	return retval;
+}
+
+static int read_brightness(struct backlight_device *bd)
+{
+	struct asus_wmi *asus = bl_get_data(bd);
+	u32 retval, err;
+
+	err = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_BRIGHTNESS, &retval);
+
 	if (err < 0)
 		return err;
 
@@ -799,7 +817,7 @@ static int update_bl_status(struct backlight_device *bd)
 		err = asus_wmi_set_devstate(ASUS_WMI_DEVID_BACKLIGHT,
 					    ctrl_param, NULL);
 	}
-	return 0;
+	return err;
 }
 
 static const struct backlight_ops asus_wmi_bl_ops = {
@@ -832,23 +850,19 @@ static int asus_wmi_backlight_init(struct asus_wmi *asus)
 	int max;
 	int power;
 
-	max = asus_wmi_get_devstate_bits(asus, ASUS_WMI_DEVID_BRIGHTNESS,
-					 ASUS_WMI_DSTS_MAX_BRIGTH_MASK);
-	power = read_backlight_power(asus);
+	max = read_brightness_max(asus);
 
-	if (max < 0 && power < 0) {
-		/* Try to keep the original error */
-		if (max == -ENODEV && power == -ENODEV)
-			return -ENODEV;
-		if (max != -ENODEV)
-			return max;
-		else
-			return power;
-	}
 	if (max == -ENODEV)
 		max = 0;
+	else if (max < 0)
+		return max;
+
+	power = read_backlight_power(asus);
+
 	if (power == -ENODEV)
 		power = FB_BLANK_UNBLANK;
+	else if (power < 0)
+		return power;
 
 	memset(&props, 0, sizeof(struct backlight_properties));
 	props.max_brightness = max;

commit 1d070f89a723bd296865dd7eb61c8050763e6e3b
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sat Feb 26 10:20:36 2011 +0100

    asus-wmi: try to guess the right DSTS methods
    
    This is tricky, new WMI aware notebooks seems to use
    0x53545344 while Eee PCs are using 0x53544344. But there
    is no way to know if there is an Eee PC in that wild that is
    using 0x53545344 or a notebook using 0x53544344. So the
    driver try to guess the available DSTS method ... But most Eee PCs
    never return 0xFFFFFFFE when a method is not available, they return
    0 instead (and that's useless).
    
    So, first, try 0x53544344 then 0x53545344. We will find
    a better way when we got more data.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 34e6b4d83a93..fd5b08eecf1e 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -67,6 +67,7 @@ MODULE_LICENSE("GPL");
 
 /* WMI Methods */
 #define ASUS_WMI_METHODID_DSTS		0x53544344
+#define ASUS_WMI_METHODID_DSTS2		0x53545344
 #define ASUS_WMI_METHODID_DEVS		0x53564544
 #define ASUS_WMI_METHODID_CFVS		0x53564643
 
@@ -124,6 +125,8 @@ struct asus_rfkill {
 };
 
 struct asus_wmi {
+	int dsts_id;
+
 	struct input_dev *inputdev;
 	struct backlight_device *backlight_device;
 	struct platform_device *platform_device;
@@ -229,26 +232,26 @@ static int asus_wmi_evaluate_method(u32 method_id, u32 arg0, u32 arg1,
 	return 0;
 }
 
-static int asus_wmi_get_devstate(u32 dev_id, u32 *retval)
+static int asus_wmi_get_devstate(struct asus_wmi *asus, u32 dev_id, u32 *retval)
 {
-	return asus_wmi_evaluate_method(ASUS_WMI_METHODID_DSTS, dev_id,
-					0, retval);
+	return asus_wmi_evaluate_method(asus->dsts_id, dev_id, 0, retval);
 }
 
 static int asus_wmi_set_devstate(u32 dev_id, u32 ctrl_param,
-					 u32 *retval)
+				 u32 *retval)
 {
 	return asus_wmi_evaluate_method(ASUS_WMI_METHODID_DEVS, dev_id,
 					ctrl_param, retval);
 }
 
 /* Helper for special devices with magic return codes */
-static int asus_wmi_get_devstate_bits(u32 dev_id, u32 mask)
+static int asus_wmi_get_devstate_bits(struct asus_wmi *asus,
+				      u32 dev_id, u32 mask)
 {
 	u32 retval = 0;
 	int err;
 
-	err = asus_wmi_get_devstate(dev_id, &retval);
+	err = asus_wmi_get_devstate(asus, dev_id, &retval);
 
 	if (err < 0)
 		return err;
@@ -264,9 +267,10 @@ static int asus_wmi_get_devstate_bits(u32 dev_id, u32 mask)
 	return retval & mask;
 }
 
-static int asus_wmi_get_devstate_simple(u32 dev_id)
+static int asus_wmi_get_devstate_simple(struct asus_wmi *asus, u32 dev_id)
 {
-	return asus_wmi_get_devstate_bits(dev_id, ASUS_WMI_DSTS_STATUS_BIT);
+	return asus_wmi_get_devstate_bits(asus, dev_id,
+					  ASUS_WMI_DSTS_STATUS_BIT);
 }
 
 /*
@@ -302,7 +306,7 @@ static void tpd_led_set(struct led_classdev *led_cdev,
 
 static int read_tpd_led_state(struct asus_wmi *asus)
 {
-	return asus_wmi_get_devstate_simple(ASUS_WMI_DEVID_TOUCHPAD_LED);
+	return asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_TOUCHPAD_LED);
 }
 
 static enum led_brightness tpd_led_get(struct led_classdev *led_cdev)
@@ -353,7 +357,7 @@ static void asus_wmi_led_exit(struct asus_wmi *asus)
  */
 static bool asus_wlan_rfkill_blocked(struct asus_wmi *asus)
 {
-	int result = asus_wmi_get_devstate_simple(ASUS_WMI_DEVID_WLAN);
+	int result = asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_WLAN);
 
 	if (result < 0)
 		return false;
@@ -482,7 +486,8 @@ static void asus_unregister_rfkill_notifier(struct asus_wmi *asus, char *node)
 static int asus_get_adapter_status(struct hotplug_slot *hotplug_slot,
 				   u8 *value)
 {
-	int result = asus_wmi_get_devstate_simple(ASUS_WMI_DEVID_WLAN);
+	struct asus_wmi *asus = hotplug_slot->private;
+	int result = asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_WLAN);
 
 	if (result < 0)
 		return result;
@@ -578,7 +583,7 @@ static void asus_rfkill_query(struct rfkill *rfkill, void *data)
 	struct asus_rfkill *priv = data;
 	int result;
 
-	result = asus_wmi_get_devstate_simple(priv->dev_id);
+	result = asus_wmi_get_devstate_simple(priv->asus, priv->dev_id);
 
 	if (result < 0)
 		return;
@@ -619,7 +624,7 @@ static int asus_new_rfkill(struct asus_wmi *asus,
 			   struct asus_rfkill *arfkill,
 			   const char *name, enum rfkill_type type, int dev_id)
 {
-	int result = asus_wmi_get_devstate_simple(dev_id);
+	int result = asus_wmi_get_devstate_simple(asus, dev_id);
 	struct rfkill **rfkill = &arfkill->rfkill;
 
 	if (result < 0)
@@ -750,9 +755,9 @@ static int asus_wmi_rfkill_init(struct asus_wmi *asus)
 /*
  * Backlight
  */
-static int read_backlight_power(void)
+static int read_backlight_power(struct asus_wmi *asus)
 {
-	int ret = asus_wmi_get_devstate_simple(ASUS_WMI_DEVID_BACKLIGHT);
+	int ret = asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_BACKLIGHT);
 
 	if (ret < 0)
 		return ret;
@@ -762,10 +767,11 @@ static int read_backlight_power(void)
 
 static int read_brightness(struct backlight_device *bd)
 {
+	struct asus_wmi *asus = bl_get_data(bd);
 	u32 retval;
 	int err;
 
-	err = asus_wmi_get_devstate(ASUS_WMI_DEVID_BRIGHTNESS, &retval);
+	err = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_BRIGHTNESS, &retval);
 
 	if (err < 0)
 		return err;
@@ -775,6 +781,7 @@ static int read_brightness(struct backlight_device *bd)
 
 static int update_bl_status(struct backlight_device *bd)
 {
+	struct asus_wmi *asus = bl_get_data(bd);
 	u32 ctrl_param;
 	int power, err;
 
@@ -786,7 +793,7 @@ static int update_bl_status(struct backlight_device *bd)
 	if (err < 0)
 		return err;
 
-	power = read_backlight_power();
+	power = read_backlight_power(asus);
 	if (power != -ENODEV && bd->props.power != power) {
 		ctrl_param = !!(bd->props.power == FB_BLANK_UNBLANK);
 		err = asus_wmi_set_devstate(ASUS_WMI_DEVID_BACKLIGHT,
@@ -825,9 +832,9 @@ static int asus_wmi_backlight_init(struct asus_wmi *asus)
 	int max;
 	int power;
 
-	max = asus_wmi_get_devstate_bits(ASUS_WMI_DEVID_BRIGHTNESS,
+	max = asus_wmi_get_devstate_bits(asus, ASUS_WMI_DEVID_BRIGHTNESS,
 					 ASUS_WMI_DSTS_MAX_BRIGTH_MASK);
-	power = read_backlight_power();
+	power = read_backlight_power(asus);
 
 	if (max < 0 && power < 0) {
 		/* Try to keep the original error */
@@ -921,12 +928,13 @@ static int parse_arg(const char *buf, unsigned long count, int *val)
 	return count;
 }
 
-static ssize_t store_sys_wmi(int devid, const char *buf, size_t count)
+static ssize_t store_sys_wmi(struct asus_wmi *asus, int devid,
+			     const char *buf, size_t count)
 {
 	u32 retval;
 	int rv, err, value;
 
-	value = asus_wmi_get_devstate_simple(devid);
+	value = asus_wmi_get_devstate_simple(asus, devid);
 	if (value == -ENODEV)	/* Check device presence */
 		return value;
 
@@ -939,9 +947,9 @@ static ssize_t store_sys_wmi(int devid, const char *buf, size_t count)
 	return rv;
 }
 
-static ssize_t show_sys_wmi(int devid, char *buf)
+static ssize_t show_sys_wmi(struct asus_wmi *asus, int devid, char *buf)
 {
-	int value = asus_wmi_get_devstate_simple(devid);
+	int value = asus_wmi_get_devstate_simple(asus, devid);
 
 	if (value < 0)
 		return value;
@@ -954,13 +962,17 @@ static ssize_t show_sys_wmi(int devid, char *buf)
 				    struct device_attribute *attr,	\
 				    char *buf)				\
 	{								\
-		return show_sys_wmi(_cm, buf);				\
+		struct asus_wmi *asus = dev_get_drvdata(dev);		\
+									\
+		return show_sys_wmi(asus, _cm, buf);			\
 	}								\
 	static ssize_t store_##_name(struct device *dev,		\
 				     struct device_attribute *attr,	\
 				     const char *buf, size_t count)	\
 	{								\
-		return store_sys_wmi(_cm, buf, count);			\
+		struct asus_wmi *asus = dev_get_drvdata(dev);		\
+									\
+		return store_sys_wmi(asus, _cm, buf, count);		\
 	}								\
 	static struct device_attribute dev_attr_##_name = {		\
 		.attr = {						\
@@ -1000,7 +1012,10 @@ static struct attribute *platform_attributes[] = {
 static mode_t asus_sysfs_is_visible(struct kobject *kobj,
 				    struct attribute *attr, int idx)
 {
-	bool supported = true;
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct platform_device *pdev = to_platform_device(dev);
+	struct asus_wmi *asus = platform_get_drvdata(pdev);
+	bool ok = true;
 	int devid = -1;
 
 	if (attr == &dev_attr_camera.attr)
@@ -1011,9 +1026,9 @@ static mode_t asus_sysfs_is_visible(struct kobject *kobj,
 		devid = ASUS_WMI_DEVID_TOUCHPAD;
 
 	if (devid != -1)
-		supported = asus_wmi_get_devstate_simple(devid) != -ENODEV;
+		ok = !(asus_wmi_get_devstate_simple(asus, devid) < 0);
 
-	return supported ? attr->mode : 0;
+	return ok ? attr->mode : 0;
 }
 
 static struct attribute_group platform_attribute_group = {
@@ -1036,6 +1051,23 @@ static int asus_wmi_sysfs_init(struct platform_device *device)
  */
 static int __init asus_wmi_platform_init(struct asus_wmi *asus)
 {
+	/*
+	 * Eee PC and Notebooks seems to have different method_id for DSTS,
+	 * but it may also be related to the BIOS's SPEC.
+	 * Note, on most Eeepc, there is no way to check if a method exist
+	 * or note, while on notebooks, they returns 0xFFFFFFFE on failure,
+	 * but once again, SPEC may probably be used for that kind of things.
+	 */
+	if (!asus_wmi_evaluate_method(ASUS_WMI_METHODID_DSTS, 0, 0, NULL))
+		asus->dsts_id = ASUS_WMI_METHODID_DSTS;
+	else if (!asus_wmi_evaluate_method(ASUS_WMI_METHODID_DSTS2, 0, 0, NULL))
+		asus->dsts_id = ASUS_WMI_METHODID_DSTS2;
+
+	if (!asus->dsts_id) {
+		pr_err("Can't find DSTS");
+		return -ENODEV;
+	}
+
 	return asus_wmi_sysfs_init(asus->platform_device);
 }
 
@@ -1059,7 +1091,7 @@ static int show_dsts(struct seq_file *m, void *data)
 	int err;
 	u32 retval = -1;
 
-	err = asus_wmi_get_devstate(asus->debug.dev_id, &retval);
+	err = asus_wmi_get_devstate(asus, asus->debug.dev_id, &retval);
 
 	if (err < 0)
 		return err;
@@ -1262,7 +1294,7 @@ static int asus_hotk_thaw(struct device *device)
 		 * during suspend.  Normally it restores it on resume, but
 		 * we should kick it ourselves in case hibernation is aborted.
 		 */
-		wlan = asus_wmi_get_devstate_simple(ASUS_WMI_DEVID_WLAN);
+		wlan = asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_WLAN);
 		asus_wmi_set_devstate(ASUS_WMI_DEVID_WLAN, wlan, NULL);
 	}
 
@@ -1279,15 +1311,16 @@ static int asus_hotk_restore(struct device *device)
 		asus_rfkill_hotplug(asus);
 
 	if (asus->bluetooth.rfkill) {
-		bl = !asus_wmi_get_devstate_simple(ASUS_WMI_DEVID_BLUETOOTH);
+		bl = !asus_wmi_get_devstate_simple(asus,
+						   ASUS_WMI_DEVID_BLUETOOTH);
 		rfkill_set_sw_state(asus->bluetooth.rfkill, bl);
 	}
 	if (asus->wimax.rfkill) {
-		bl = !asus_wmi_get_devstate_simple(ASUS_WMI_DEVID_WIMAX);
+		bl = !asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_WIMAX);
 		rfkill_set_sw_state(asus->wimax.rfkill, bl);
 	}
 	if (asus->wwan3g.rfkill) {
-		bl = !asus_wmi_get_devstate_simple(ASUS_WMI_DEVID_WWAN3G);
+		bl = !asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_WWAN3G);
 		rfkill_set_sw_state(asus->wwan3g.rfkill, bl);
 	}
 

commit d33da3b6866975b17fbec67540f6153f5dcdcec7
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sat Feb 26 10:20:35 2011 +0100

    asus-wmi: factorise wmi_evaluate_method call
    
    This patch create a single function to call the
    WMI methods. This function handle inexistent methods (when
    implemented by the WMI devices, and this is not the case on
    Eee PCs), ACPI errors, etc..
    
    Also pack struct bios_arg, and make sure that we always send
    a 64bit buffer when calling a WMI method, because this is
    needed on Asus notebooks.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 39ce3c1a7712..34e6b4d83a93 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -70,6 +70,8 @@ MODULE_LICENSE("GPL");
 #define ASUS_WMI_METHODID_DEVS		0x53564544
 #define ASUS_WMI_METHODID_CFVS		0x53564643
 
+#define ASUS_WMI_UNSUPPORTED_METHOD	0xFFFFFFFE
+
 /* Wireless */
 #define ASUS_WMI_DEVID_WLAN		0x00010011
 #define ASUS_WMI_DEVID_BLUETOOTH	0x00010013
@@ -98,9 +100,9 @@ MODULE_LICENSE("GPL");
 #define ASUS_WMI_DSTS_MAX_BRIGTH_MASK	0x0000FF00
 
 struct bios_args {
-	u32 dev_id;
-	u32 ctrl_param;
-};
+	u32 arg0;
+	u32 arg1;
+} __packed;
 
 /*
  * <platform>/    - debugfs root directory
@@ -187,20 +189,24 @@ static void asus_wmi_input_exit(struct asus_wmi *asus)
 	asus->inputdev = NULL;
 }
 
-static acpi_status asus_wmi_get_devstate(u32 dev_id, u32 *retval)
+static int asus_wmi_evaluate_method(u32 method_id, u32 arg0, u32 arg1,
+				    u32 *retval)
 {
-	struct acpi_buffer input = { (acpi_size) sizeof(u32), &dev_id };
+	struct bios_args args = {
+		.arg0 = arg0,
+		.arg1 = arg1,
+	};
+	struct acpi_buffer input = { (acpi_size) sizeof(args), &args };
 	struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
-	union acpi_object *obj;
 	acpi_status status;
+	union acpi_object *obj;
 	u32 tmp;
 
-	status = wmi_evaluate_method(ASUS_WMI_MGMT_GUID,
-				     1, ASUS_WMI_METHODID_DSTS,
+	status = wmi_evaluate_method(ASUS_WMI_MGMT_GUID, 1, method_id,
 				     &input, &output);
 
 	if (ACPI_FAILURE(status))
-		return status;
+		goto exit;
 
 	obj = (union acpi_object *)output.pointer;
 	if (obj && obj->type == ACPI_TYPE_INTEGER)
@@ -213,60 +219,39 @@ static acpi_status asus_wmi_get_devstate(u32 dev_id, u32 *retval)
 
 	kfree(obj);
 
-	return status;
+exit:
+	if (ACPI_FAILURE(status))
+		return -EIO;
+
+	if (tmp == ASUS_WMI_UNSUPPORTED_METHOD)
+		return -ENODEV;
 
+	return 0;
 }
 
-static acpi_status asus_wmi_set_devstate(u32 dev_id, u32 ctrl_param,
-					 u32 *retval)
+static int asus_wmi_get_devstate(u32 dev_id, u32 *retval)
 {
-	struct bios_args args = {
-		.dev_id = dev_id,
-		.ctrl_param = ctrl_param,
-	};
-	struct acpi_buffer input = { (acpi_size) sizeof(args), &args };
-	acpi_status status;
-
-	if (!retval) {
-		status = wmi_evaluate_method(ASUS_WMI_MGMT_GUID, 1,
-					     ASUS_WMI_METHODID_DEVS,
-					     &input, NULL);
-	} else {
-		struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
-		union acpi_object *obj;
-		u32 tmp;
-
-		status = wmi_evaluate_method(ASUS_WMI_MGMT_GUID, 1,
-					     ASUS_WMI_METHODID_DEVS,
-					     &input, &output);
-
-		if (ACPI_FAILURE(status))
-			return status;
-
-		obj = (union acpi_object *)output.pointer;
-		if (obj && obj->type == ACPI_TYPE_INTEGER)
-			tmp = (u32) obj->integer.value;
-		else
-			tmp = 0;
-
-		*retval = tmp;
-
-		kfree(obj);
-	}
+	return asus_wmi_evaluate_method(ASUS_WMI_METHODID_DSTS, dev_id,
+					0, retval);
+}
 
-	return status;
+static int asus_wmi_set_devstate(u32 dev_id, u32 ctrl_param,
+					 u32 *retval)
+{
+	return asus_wmi_evaluate_method(ASUS_WMI_METHODID_DEVS, dev_id,
+					ctrl_param, retval);
 }
 
 /* Helper for special devices with magic return codes */
 static int asus_wmi_get_devstate_bits(u32 dev_id, u32 mask)
 {
 	u32 retval = 0;
-	acpi_status status;
+	int err;
 
-	status = asus_wmi_get_devstate(dev_id, &retval);
+	err = asus_wmi_get_devstate(dev_id, &retval);
 
-	if (ACPI_FAILURE(status))
-		return -EINVAL;
+	if (err < 0)
+		return err;
 
 	if (!(retval & ASUS_WMI_DSTS_PRESENCE_BIT))
 		return -ENODEV;
@@ -584,14 +569,8 @@ static int asus_rfkill_set(void *data, bool blocked)
 {
 	struct asus_rfkill *priv = data;
 	u32 ctrl_param = !blocked;
-	acpi_status status;
-
-	status = asus_wmi_set_devstate(priv->dev_id, ctrl_param, NULL);
-
-	if (ACPI_FAILURE(status))
-		return -EIO;
 
-	return 0;
+	return asus_wmi_set_devstate(priv->dev_id, ctrl_param, NULL);
 }
 
 static void asus_rfkill_query(struct rfkill *rfkill, void *data)
@@ -784,38 +763,34 @@ static int read_backlight_power(void)
 static int read_brightness(struct backlight_device *bd)
 {
 	u32 retval;
-	acpi_status status;
+	int err;
 
-	status = asus_wmi_get_devstate(ASUS_WMI_DEVID_BRIGHTNESS, &retval);
+	err = asus_wmi_get_devstate(ASUS_WMI_DEVID_BRIGHTNESS, &retval);
 
-	if (ACPI_FAILURE(status))
-		return -EIO;
-	else
-		return retval & ASUS_WMI_DSTS_BRIGHTNESS_MASK;
+	if (err < 0)
+		return err;
+
+	return retval & ASUS_WMI_DSTS_BRIGHTNESS_MASK;
 }
 
 static int update_bl_status(struct backlight_device *bd)
 {
 	u32 ctrl_param;
-	acpi_status status;
-	int power;
+	int power, err;
 
 	ctrl_param = bd->props.brightness;
 
-	status = asus_wmi_set_devstate(ASUS_WMI_DEVID_BRIGHTNESS,
-				       ctrl_param, NULL);
+	err = asus_wmi_set_devstate(ASUS_WMI_DEVID_BRIGHTNESS,
+				    ctrl_param, NULL);
 
-	if (ACPI_FAILURE(status))
-		return -EIO;
+	if (err < 0)
+		return err;
 
 	power = read_backlight_power();
 	if (power != -ENODEV && bd->props.power != power) {
 		ctrl_param = !!(bd->props.power == FB_BLANK_UNBLANK);
-		status = asus_wmi_set_devstate(ASUS_WMI_DEVID_BACKLIGHT,
-					       ctrl_param, NULL);
-
-		if (ACPI_FAILURE(status))
-			return -EIO;
+		err = asus_wmi_set_devstate(ASUS_WMI_DEVID_BACKLIGHT,
+					    ctrl_param, NULL);
 	}
 	return 0;
 }
@@ -948,19 +923,19 @@ static int parse_arg(const char *buf, unsigned long count, int *val)
 
 static ssize_t store_sys_wmi(int devid, const char *buf, size_t count)
 {
-	acpi_status status;
 	u32 retval;
-	int rv, value;
+	int rv, err, value;
 
 	value = asus_wmi_get_devstate_simple(devid);
 	if (value == -ENODEV)	/* Check device presence */
 		return value;
 
 	rv = parse_arg(buf, count, &value);
-	status = asus_wmi_set_devstate(devid, value, &retval);
+	err = asus_wmi_set_devstate(devid, value, &retval);
+
+	if (err < 0)
+		return err;
 
-	if (ACPI_FAILURE(status))
-		return -EIO;
 	return rv;
 }
 
@@ -1003,21 +978,13 @@ static ssize_t store_cpufv(struct device *dev, struct device_attribute *attr,
 			   const char *buf, size_t count)
 {
 	int value;
-	struct acpi_buffer input = { (acpi_size) sizeof(value), &value };
-	acpi_status status;
 
 	if (!count || sscanf(buf, "%i", &value) != 1)
 		return -EINVAL;
 	if (value < 0 || value > 2)
 		return -EINVAL;
 
-	status = wmi_evaluate_method(ASUS_WMI_MGMT_GUID,
-				     1, ASUS_WMI_METHODID_CFVS, &input, NULL);
-
-	if (ACPI_FAILURE(status))
-		return -EIO;
-	else
-		return count;
+	return asus_wmi_evaluate_method(ASUS_WMI_METHODID_CFVS, value, 0, NULL);
 }
 
 static DEVICE_ATTR(cpufv, S_IRUGO | S_IWUSR, NULL, store_cpufv);
@@ -1089,13 +1056,13 @@ struct asus_wmi_debugfs_node {
 static int show_dsts(struct seq_file *m, void *data)
 {
 	struct asus_wmi *asus = m->private;
-	acpi_status status;
+	int err;
 	u32 retval = -1;
 
-	status = asus_wmi_get_devstate(asus->debug.dev_id, &retval);
+	err = asus_wmi_get_devstate(asus->debug.dev_id, &retval);
 
-	if (ACPI_FAILURE(status))
-		return -EIO;
+	if (err < 0)
+		return err;
 
 	seq_printf(m, "DSTS(%x) = %x\n", asus->debug.dev_id, retval);
 
@@ -1105,13 +1072,14 @@ static int show_dsts(struct seq_file *m, void *data)
 static int show_devs(struct seq_file *m, void *data)
 {
 	struct asus_wmi *asus = m->private;
-	acpi_status status;
+	int err;
 	u32 retval = -1;
 
-	status = asus_wmi_set_devstate(asus->debug.dev_id,
-				       asus->debug.ctrl_param, &retval);
-	if (ACPI_FAILURE(status))
-		return -EIO;
+	err = asus_wmi_set_devstate(asus->debug.dev_id, asus->debug.ctrl_param,
+				    &retval);
+
+	if (err < 0)
+		return err;
 
 	seq_printf(m, "DEVS(%x, %x) = %x\n", asus->debug.dev_id,
 		   asus->debug.ctrl_param, retval);

commit a75fe0d78ec00d3d5b2c42b1ee76b22e99f213d1
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sat Feb 26 10:20:34 2011 +0100

    asus-wmi: handle "unknown status" bit
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index d0f0931ea5eb..39ce3c1a7712 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -92,6 +92,7 @@ MODULE_LICENSE("GPL");
 
 /* DSTS masks */
 #define ASUS_WMI_DSTS_STATUS_BIT	0x00000001
+#define ASUS_WMI_DSTS_UNKNOWN_BIT	0x00000002
 #define ASUS_WMI_DSTS_PRESENCE_BIT	0x00010000
 #define ASUS_WMI_DSTS_BRIGHTNESS_MASK	0x000000FF
 #define ASUS_WMI_DSTS_MAX_BRIGTH_MASK	0x0000FF00
@@ -270,6 +271,11 @@ static int asus_wmi_get_devstate_bits(u32 dev_id, u32 mask)
 	if (!(retval & ASUS_WMI_DSTS_PRESENCE_BIT))
 		return -ENODEV;
 
+	if (mask == ASUS_WMI_DSTS_STATUS_BIT) {
+		if (retval & ASUS_WMI_DSTS_UNKNOWN_BIT)
+			return -ENODEV;
+	}
+
 	return retval & mask;
 }
 

commit a7ce3f041e640daf96e227d8f7ffa6b988f33025
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sat Feb 26 10:20:33 2011 +0100

    asus-wmi: introduce struct asus_rfkill
    
    First, this allow use to remove the custom asusrfkill_wlan_query,
    but this will also allow us to give struct asus_wmi * to
    get_devstate/set_devstate later.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 4c3f68a495d7..d0f0931ea5eb 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -114,6 +114,12 @@ struct asus_wmi_debug {
 	u32 ctrl_param;
 };
 
+struct asus_rfkill {
+	struct asus_wmi *asus;
+	struct rfkill *rfkill;
+	u32 dev_id;
+};
+
 struct asus_wmi {
 	struct input_dev *inputdev;
 	struct backlight_device *backlight_device;
@@ -124,10 +130,10 @@ struct asus_wmi {
 	struct workqueue_struct *led_workqueue;
 	struct work_struct tpd_led_work;
 
-	struct rfkill *wlan_rfkill;
-	struct rfkill *bluetooth_rfkill;
-	struct rfkill *wimax_rfkill;
-	struct rfkill *wwan3g_rfkill;
+	struct asus_rfkill wlan;
+	struct asus_rfkill bluetooth;
+	struct asus_rfkill wimax;
+	struct asus_rfkill wwan3g;
 
 	struct hotplug_slot *hotplug_slot;
 	struct mutex hotplug_lock;
@@ -377,8 +383,8 @@ static void asus_rfkill_hotplug(struct asus_wmi *asus)
 
 	mutex_lock(&asus->hotplug_lock);
 
-	if (asus->wlan_rfkill)
-		rfkill_set_sw_state(asus->wlan_rfkill, blocked);
+	if (asus->wlan.rfkill)
+		rfkill_set_sw_state(asus->wlan.rfkill, blocked);
 
 	if (asus->hotplug_slot) {
 		bus = pci_find_bus(0, 1);
@@ -570,11 +576,11 @@ static int asus_setup_pci_hotplug(struct asus_wmi *asus)
  */
 static int asus_rfkill_set(void *data, bool blocked)
 {
-	int dev_id = (unsigned long)data;
+	struct asus_rfkill *priv = data;
 	u32 ctrl_param = !blocked;
 	acpi_status status;
 
-	status = asus_wmi_set_devstate(dev_id, ctrl_param, NULL);
+	status = asus_wmi_set_devstate(priv->dev_id, ctrl_param, NULL);
 
 	if (ACPI_FAILURE(status))
 		return -EIO;
@@ -584,20 +590,21 @@ static int asus_rfkill_set(void *data, bool blocked)
 
 static void asus_rfkill_query(struct rfkill *rfkill, void *data)
 {
-	int dev_id = (unsigned long)data;
+	struct asus_rfkill *priv = data;
 	int result;
 
-	result = asus_wmi_get_devstate_simple(dev_id);
+	result = asus_wmi_get_devstate_simple(priv->dev_id);
 
 	if (result < 0)
 		return;
 
-	rfkill_set_sw_state(rfkill, !result);
+	rfkill_set_sw_state(priv->rfkill, !result);
 }
 
 static int asus_rfkill_wlan_set(void *data, bool blocked)
 {
-	struct asus_wmi *asus = data;
+	struct asus_rfkill *priv = data;
+	struct asus_wmi *asus = priv->asus;
 	int ret;
 
 	/*
@@ -608,19 +615,14 @@ static int asus_rfkill_wlan_set(void *data, bool blocked)
 	 * any wmi method
 	 */
 	mutex_lock(&asus->wmi_lock);
-	ret = asus_rfkill_set((void *)(long)ASUS_WMI_DEVID_WLAN, blocked);
+	ret = asus_rfkill_set(data, blocked);
 	mutex_unlock(&asus->wmi_lock);
 	return ret;
 }
 
-static void asus_rfkill_wlan_query(struct rfkill *rfkill, void *data)
-{
-	asus_rfkill_query(rfkill, (void *)(long)ASUS_WMI_DEVID_WLAN);
-}
-
 static const struct rfkill_ops asus_rfkill_wlan_ops = {
 	.set_block = asus_rfkill_wlan_set,
-	.query = asus_rfkill_wlan_query,
+	.query = asus_rfkill_query,
 };
 
 static const struct rfkill_ops asus_rfkill_ops = {
@@ -629,20 +631,24 @@ static const struct rfkill_ops asus_rfkill_ops = {
 };
 
 static int asus_new_rfkill(struct asus_wmi *asus,
-			   struct rfkill **rfkill,
+			   struct asus_rfkill *arfkill,
 			   const char *name, enum rfkill_type type, int dev_id)
 {
 	int result = asus_wmi_get_devstate_simple(dev_id);
+	struct rfkill **rfkill = &arfkill->rfkill;
 
 	if (result < 0)
 		return result;
 
+	arfkill->dev_id = dev_id;
+	arfkill->asus = asus;
+
 	if (dev_id == ASUS_WMI_DEVID_WLAN && asus->driver->hotplug_wireless)
 		*rfkill = rfkill_alloc(name, &asus->platform_device->dev, type,
-				       &asus_rfkill_wlan_ops, asus);
+				       &asus_rfkill_wlan_ops, arfkill);
 	else
 		*rfkill = rfkill_alloc(name, &asus->platform_device->dev, type,
-				       &asus_rfkill_ops, (void *)(long)dev_id);
+				       &asus_rfkill_ops, arfkill);
 
 	if (!*rfkill)
 		return -EINVAL;
@@ -662,10 +668,10 @@ static void asus_wmi_rfkill_exit(struct asus_wmi *asus)
 	asus_unregister_rfkill_notifier(asus, "\\_SB.PCI0.P0P5");
 	asus_unregister_rfkill_notifier(asus, "\\_SB.PCI0.P0P6");
 	asus_unregister_rfkill_notifier(asus, "\\_SB.PCI0.P0P7");
-	if (asus->wlan_rfkill) {
-		rfkill_unregister(asus->wlan_rfkill);
-		rfkill_destroy(asus->wlan_rfkill);
-		asus->wlan_rfkill = NULL;
+	if (asus->wlan.rfkill) {
+		rfkill_unregister(asus->wlan.rfkill);
+		rfkill_destroy(asus->wlan.rfkill);
+		asus->wlan.rfkill = NULL;
 	}
 	/*
 	 * Refresh pci hotplug in case the rfkill state was changed after
@@ -677,20 +683,20 @@ static void asus_wmi_rfkill_exit(struct asus_wmi *asus)
 	if (asus->hotplug_workqueue)
 		destroy_workqueue(asus->hotplug_workqueue);
 
-	if (asus->bluetooth_rfkill) {
-		rfkill_unregister(asus->bluetooth_rfkill);
-		rfkill_destroy(asus->bluetooth_rfkill);
-		asus->bluetooth_rfkill = NULL;
+	if (asus->bluetooth.rfkill) {
+		rfkill_unregister(asus->bluetooth.rfkill);
+		rfkill_destroy(asus->bluetooth.rfkill);
+		asus->bluetooth.rfkill = NULL;
 	}
-	if (asus->wimax_rfkill) {
-		rfkill_unregister(asus->wimax_rfkill);
-		rfkill_destroy(asus->wimax_rfkill);
-		asus->wimax_rfkill = NULL;
+	if (asus->wimax.rfkill) {
+		rfkill_unregister(asus->wimax.rfkill);
+		rfkill_destroy(asus->wimax.rfkill);
+		asus->wimax.rfkill = NULL;
 	}
-	if (asus->wwan3g_rfkill) {
-		rfkill_unregister(asus->wwan3g_rfkill);
-		rfkill_destroy(asus->wwan3g_rfkill);
-		asus->wwan3g_rfkill = NULL;
+	if (asus->wwan3g.rfkill) {
+		rfkill_unregister(asus->wwan3g.rfkill);
+		rfkill_destroy(asus->wwan3g.rfkill);
+		asus->wwan3g.rfkill = NULL;
 	}
 }
 
@@ -701,30 +707,27 @@ static int asus_wmi_rfkill_init(struct asus_wmi *asus)
 	mutex_init(&asus->hotplug_lock);
 	mutex_init(&asus->wmi_lock);
 
-	result = asus_new_rfkill(asus, &asus->wlan_rfkill,
-				 "asus-wlan", RFKILL_TYPE_WLAN,
-				 ASUS_WMI_DEVID_WLAN);
+	result = asus_new_rfkill(asus, &asus->wlan, "asus-wlan",
+				 RFKILL_TYPE_WLAN, ASUS_WMI_DEVID_WLAN);
 
 	if (result && result != -ENODEV)
 		goto exit;
 
-	result = asus_new_rfkill(asus, &asus->bluetooth_rfkill,
+	result = asus_new_rfkill(asus, &asus->bluetooth,
 				 "asus-bluetooth", RFKILL_TYPE_BLUETOOTH,
 				 ASUS_WMI_DEVID_BLUETOOTH);
 
 	if (result && result != -ENODEV)
 		goto exit;
 
-	result = asus_new_rfkill(asus, &asus->wimax_rfkill,
-				 "asus-wimax", RFKILL_TYPE_WIMAX,
-				 ASUS_WMI_DEVID_WIMAX);
+	result = asus_new_rfkill(asus, &asus->wimax, "asus-wimax",
+				 RFKILL_TYPE_WIMAX, ASUS_WMI_DEVID_WIMAX);
 
 	if (result && result != -ENODEV)
 		goto exit;
 
-	result = asus_new_rfkill(asus, &asus->wwan3g_rfkill,
-				 "asus-wwan3g", RFKILL_TYPE_WWAN,
-				 ASUS_WMI_DEVID_WWAN3G);
+	result = asus_new_rfkill(asus, &asus->wwan3g, "asus-wwan3g",
+				 RFKILL_TYPE_WWAN, ASUS_WMI_DEVID_WWAN3G);
 
 	if (result && result != -ENODEV)
 		goto exit;
@@ -1277,7 +1280,7 @@ static int asus_hotk_thaw(struct device *device)
 {
 	struct asus_wmi *asus = dev_get_drvdata(device);
 
-	if (asus->wlan_rfkill) {
+	if (asus->wlan.rfkill) {
 		bool wlan;
 
 		/*
@@ -1298,20 +1301,20 @@ static int asus_hotk_restore(struct device *device)
 	int bl;
 
 	/* Refresh both wlan rfkill state and pci hotplug */
-	if (asus->wlan_rfkill)
+	if (asus->wlan.rfkill)
 		asus_rfkill_hotplug(asus);
 
-	if (asus->bluetooth_rfkill) {
+	if (asus->bluetooth.rfkill) {
 		bl = !asus_wmi_get_devstate_simple(ASUS_WMI_DEVID_BLUETOOTH);
-		rfkill_set_sw_state(asus->bluetooth_rfkill, bl);
+		rfkill_set_sw_state(asus->bluetooth.rfkill, bl);
 	}
-	if (asus->wimax_rfkill) {
+	if (asus->wimax.rfkill) {
 		bl = !asus_wmi_get_devstate_simple(ASUS_WMI_DEVID_WIMAX);
-		rfkill_set_sw_state(asus->wimax_rfkill, bl);
+		rfkill_set_sw_state(asus->wimax.rfkill, bl);
 	}
-	if (asus->wwan3g_rfkill) {
+	if (asus->wwan3g.rfkill) {
 		bl = !asus_wmi_get_devstate_simple(ASUS_WMI_DEVID_WWAN3G);
-		rfkill_set_sw_state(asus->wwan3g_rfkill, bl);
+		rfkill_set_sw_state(asus->wwan3g.rfkill, bl);
 	}
 
 	return 0;

commit 57ab7dae27fae6a492ec968dc543106685adcad5
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sat Feb 26 10:20:32 2011 +0100

    asus-wmi: minor cleanups
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 35e6bb6c266d..4c3f68a495d7 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -2,7 +2,7 @@
  * Asus PC WMI hotkey driver
  *
  * Copyright(C) 2010 Intel Corporation.
- * Copyright(C) 2010 Corentin Chary <corentin.chary@gmail.com>
+ * Copyright(C) 2010-2011 Corentin Chary <corentin.chary@gmail.com>
  *
  * Portions based on wistron_btns.c:
  * Copyright (C) 2005 Miloslav Trmac <mitr@volny.cz>
@@ -87,7 +87,7 @@ MODULE_LICENSE("GPL");
 #define ASUS_WMI_DEVID_CARDREADER	0x00080013
 
 /* Input */
-#define ASUS_WMI_DEVID_TOUCHPAD	0x00100011
+#define ASUS_WMI_DEVID_TOUCHPAD		0x00100011
 #define ASUS_WMI_DEVID_TOUCHPAD_LED	0x00100012
 
 /* DSTS masks */
@@ -903,25 +903,25 @@ static void asus_wmi_notify(u32 value, void *context)
 
 	obj = (union acpi_object *)response.pointer;
 
-	if (obj && obj->type == ACPI_TYPE_INTEGER) {
-		code = obj->integer.value;
-		orig_code = code;
+	if (!obj || obj->type != ACPI_TYPE_INTEGER)
+		goto exit;
 
-		if (code >= NOTIFY_BRNUP_MIN && code <= NOTIFY_BRNUP_MAX)
-			code = NOTIFY_BRNUP_MIN;
-		else if (code >= NOTIFY_BRNDOWN_MIN &&
-			 code <= NOTIFY_BRNDOWN_MAX)
-			code = NOTIFY_BRNDOWN_MIN;
+	code = obj->integer.value;
+	orig_code = code;
 
-		if (code == NOTIFY_BRNUP_MIN || code == NOTIFY_BRNDOWN_MIN) {
-			if (!acpi_video_backlight_support())
-				asus_wmi_backlight_notify(asus, orig_code);
-		}
+	if (code >= NOTIFY_BRNUP_MIN && code <= NOTIFY_BRNUP_MAX)
+		code = NOTIFY_BRNUP_MIN;
+	else if (code >= NOTIFY_BRNDOWN_MIN &&
+		 code <= NOTIFY_BRNDOWN_MAX)
+		code = NOTIFY_BRNDOWN_MIN;
 
-		if (!sparse_keymap_report_event(asus->inputdev, code, 1, true))
-			pr_info("Unknown key %x pressed\n", code);
-	}
+	if (code == NOTIFY_BRNUP_MIN || code == NOTIFY_BRNDOWN_MIN) {
+		if (!acpi_video_backlight_support())
+			asus_wmi_backlight_notify(asus, orig_code);
+	} else if (!sparse_keymap_report_event(asus->inputdev, code, 1, true))
+		pr_info("Unknown key %x pressed\n", code);
 
+exit:
 	kfree(obj);
 }
 

commit e12e6d94db24e9050821965aa75c95e8d2c65f10
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sat Feb 26 10:20:31 2011 +0100

    eeepc-wmi: asus generic asus-wmi.ko module
    
    New Asus notebooks are using a WMI device similar to
    the one used in Eee PCs. Since we don't want to load
    eeepc-wmi module on Asus notebooks, and we want to
    keep the eeepc-wmi module for backward compatibility,
    this patch introduce a new module, named asus-wmi, that
    will be used by eeepc-wmi and the new Asus Notebook WMI
    Driver.
    
    eeepc-wmi's input device strings (device name and phys)
    are kept, but rfkill and led names are changed (s/eeepc/asus/).
    This should not break anything since rfkill are used by type or
    index, not by name, and the eeepc::touchpad led wasn't working
    correctly before 2.6.39 anyway.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index d3997757e790..35e6bb6c266d 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1,5 +1,5 @@
 /*
- * Eee PC WMI hotkey driver
+ * Asus PC WMI hotkey driver
  *
  * Copyright(C) 2010 Intel Corporation.
  * Copyright(C) 2010 Corentin Chary <corentin.chary@gmail.com>
@@ -42,23 +42,23 @@
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
 #include <linux/platform_device.h>
-#include <linux/dmi.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
-#define	EEEPC_WMI_FILE	"eeepc-wmi"
+#include "asus-wmi.h"
 
-MODULE_AUTHOR("Yong Wang <yong.y.wang@intel.com>");
-MODULE_DESCRIPTION("Eee PC WMI Hotkey Driver");
+MODULE_AUTHOR("Corentin Chary <corentincj@iksaif.net>, "
+	      "Yong Wang <yong.y.wang@intel.com>");
+MODULE_DESCRIPTION("Asus Generic WMI Driver");
 MODULE_LICENSE("GPL");
 
-#define EEEPC_ACPI_HID		"ASUS010" /* old _HID used in eeepc-laptop */
+#define to_platform_driver(drv)					\
+	(container_of((drv), struct platform_driver, driver))
 
-#define EEEPC_WMI_EVENT_GUID	"ABBC0F72-8EA1-11D1-00A0-C90629100000"
-#define EEEPC_WMI_MGMT_GUID	"97845ED0-4E6D-11DE-8A39-0800200C9A66"
+#define to_asus_wmi_driver(pdrv)					\
+	(container_of((pdrv), struct asus_wmi_driver, platform_driver))
 
-MODULE_ALIAS("wmi:"EEEPC_WMI_EVENT_GUID);
-MODULE_ALIAS("wmi:"EEEPC_WMI_MGMT_GUID);
+#define ASUS_WMI_MGMT_GUID	"97845ED0-4E6D-11DE-8A39-0800200C9A66"
 
 #define NOTIFY_BRNUP_MIN		0x11
 #define NOTIFY_BRNUP_MAX		0x1f
@@ -66,90 +66,55 @@ MODULE_ALIAS("wmi:"EEEPC_WMI_MGMT_GUID);
 #define NOTIFY_BRNDOWN_MAX		0x2e
 
 /* WMI Methods */
-#define EEEPC_WMI_METHODID_DSTS		0x53544344
-#define EEEPC_WMI_METHODID_DEVS		0x53564544
-#define EEEPC_WMI_METHODID_CFVS		0x53564643
+#define ASUS_WMI_METHODID_DSTS		0x53544344
+#define ASUS_WMI_METHODID_DEVS		0x53564544
+#define ASUS_WMI_METHODID_CFVS		0x53564643
 
 /* Wireless */
-#define EEEPC_WMI_DEVID_WLAN		0x00010011
-#define EEEPC_WMI_DEVID_BLUETOOTH	0x00010013
-#define EEEPC_WMI_DEVID_WIMAX		0x00010017
-#define EEEPC_WMI_DEVID_WWAN3G		0x00010019
+#define ASUS_WMI_DEVID_WLAN		0x00010011
+#define ASUS_WMI_DEVID_BLUETOOTH	0x00010013
+#define ASUS_WMI_DEVID_WIMAX		0x00010017
+#define ASUS_WMI_DEVID_WWAN3G		0x00010019
 
 /* Backlight and Brightness */
-#define EEEPC_WMI_DEVID_BACKLIGHT	0x00050011
-#define EEEPC_WMI_DEVID_BRIGHTNESS	0x00050012
+#define ASUS_WMI_DEVID_BACKLIGHT	0x00050011
+#define ASUS_WMI_DEVID_BRIGHTNESS	0x00050012
 
 /* Misc */
-#define EEEPC_WMI_DEVID_CAMERA		0x00060013
+#define ASUS_WMI_DEVID_CAMERA		0x00060013
 
 /* Storage */
-#define EEEPC_WMI_DEVID_CARDREADER	0x00080013
+#define ASUS_WMI_DEVID_CARDREADER	0x00080013
 
 /* Input */
-#define EEEPC_WMI_DEVID_TOUCHPAD	0x00100011
-#define EEEPC_WMI_DEVID_TOUCHPAD_LED	0x00100012
+#define ASUS_WMI_DEVID_TOUCHPAD	0x00100011
+#define ASUS_WMI_DEVID_TOUCHPAD_LED	0x00100012
 
 /* DSTS masks */
-#define EEEPC_WMI_DSTS_STATUS_BIT	0x00000001
-#define EEEPC_WMI_DSTS_PRESENCE_BIT	0x00010000
-#define EEEPC_WMI_DSTS_BRIGHTNESS_MASK	0x000000FF
-#define EEEPC_WMI_DSTS_MAX_BRIGTH_MASK	0x0000FF00
-
-static bool hotplug_wireless;
-
-module_param(hotplug_wireless, bool, 0444);
-MODULE_PARM_DESC(hotplug_wireless,
-		 "Enable hotplug for wireless device. "
-		 "If your laptop needs that, please report to "
-		 "acpi4asus-user@lists.sourceforge.net.");
-
-static const struct key_entry eeepc_wmi_keymap[] = {
-	/* Sleep already handled via generic ACPI code */
-	{ KE_IGNORE, NOTIFY_BRNDOWN_MIN, { KEY_BRIGHTNESSDOWN } },
-	{ KE_IGNORE, NOTIFY_BRNUP_MIN, { KEY_BRIGHTNESSUP } },
-	{ KE_KEY, 0x30, { KEY_VOLUMEUP } },
-	{ KE_KEY, 0x31, { KEY_VOLUMEDOWN } },
-	{ KE_KEY, 0x32, { KEY_MUTE } },
-	{ KE_KEY, 0x5c, { KEY_F15 } }, /* Power Gear key */
-	{ KE_KEY, 0x5d, { KEY_WLAN } },
-	{ KE_KEY, 0x6b, { KEY_F13 } }, /* Disable Touchpad */
-	{ KE_KEY, 0x82, { KEY_CAMERA } },
-	{ KE_KEY, 0x83, { KEY_CAMERA_ZOOMIN } },
-	{ KE_KEY, 0x88, { KEY_WLAN } },
-	{ KE_KEY, 0xcc, { KEY_SWITCHVIDEOMODE } },
-	{ KE_KEY, 0xe0, { KEY_PROG1 } }, /* Task Manager */
-	{ KE_KEY, 0xe1, { KEY_F14 } }, /* Change Resolution */
-	{ KE_KEY, 0xe9, { KEY_BRIGHTNESS_ZERO } },
-	{ KE_KEY, 0xeb, { KEY_CAMERA_ZOOMOUT } },
-	{ KE_KEY, 0xec, { KEY_CAMERA_UP } },
-	{ KE_KEY, 0xed, { KEY_CAMERA_DOWN } },
-	{ KE_KEY, 0xee, { KEY_CAMERA_LEFT } },
-	{ KE_KEY, 0xef, { KEY_CAMERA_RIGHT } },
-	{ KE_END, 0},
-};
+#define ASUS_WMI_DSTS_STATUS_BIT	0x00000001
+#define ASUS_WMI_DSTS_PRESENCE_BIT	0x00010000
+#define ASUS_WMI_DSTS_BRIGHTNESS_MASK	0x000000FF
+#define ASUS_WMI_DSTS_MAX_BRIGTH_MASK	0x0000FF00
 
 struct bios_args {
-	u32	dev_id;
-	u32	ctrl_param;
+	u32 dev_id;
+	u32 ctrl_param;
 };
 
 /*
- * eeepc-wmi/    - debugfs root directory
+ * <platform>/    - debugfs root directory
  *   dev_id      - current dev_id
  *   ctrl_param  - current ctrl_param
  *   devs        - call DEVS(dev_id, ctrl_param) and print result
  *   dsts        - call DSTS(dev_id)  and print result
  */
-struct eeepc_wmi_debug {
+struct asus_wmi_debug {
 	struct dentry *root;
 	u32 dev_id;
 	u32 ctrl_param;
 };
 
-struct eeepc_wmi {
-	bool hotplug_wireless;
-
+struct asus_wmi {
 	struct input_dev *inputdev;
 	struct backlight_device *backlight_device;
 	struct platform_device *platform_device;
@@ -170,59 +135,61 @@ struct eeepc_wmi {
 	struct workqueue_struct *hotplug_workqueue;
 	struct work_struct hotplug_work;
 
-	struct eeepc_wmi_debug debug;
+	struct asus_wmi_debug debug;
+
+	struct asus_wmi_driver *driver;
 };
 
-static int eeepc_wmi_input_init(struct eeepc_wmi *eeepc)
+static int asus_wmi_input_init(struct asus_wmi *asus)
 {
 	int err;
 
-	eeepc->inputdev = input_allocate_device();
-	if (!eeepc->inputdev)
+	asus->inputdev = input_allocate_device();
+	if (!asus->inputdev)
 		return -ENOMEM;
 
-	eeepc->inputdev->name = "Eee PC WMI hotkeys";
-	eeepc->inputdev->phys = EEEPC_WMI_FILE "/input0";
-	eeepc->inputdev->id.bustype = BUS_HOST;
-	eeepc->inputdev->dev.parent = &eeepc->platform_device->dev;
+	asus->inputdev->name = asus->driver->input_phys;
+	asus->inputdev->phys = asus->driver->input_name;
+	asus->inputdev->id.bustype = BUS_HOST;
+	asus->inputdev->dev.parent = &asus->platform_device->dev;
 
-	err = sparse_keymap_setup(eeepc->inputdev, eeepc_wmi_keymap, NULL);
+	err = sparse_keymap_setup(asus->inputdev, asus->driver->keymap, NULL);
 	if (err)
 		goto err_free_dev;
 
-	err = input_register_device(eeepc->inputdev);
+	err = input_register_device(asus->inputdev);
 	if (err)
 		goto err_free_keymap;
 
 	return 0;
 
 err_free_keymap:
-	sparse_keymap_free(eeepc->inputdev);
+	sparse_keymap_free(asus->inputdev);
 err_free_dev:
-	input_free_device(eeepc->inputdev);
+	input_free_device(asus->inputdev);
 	return err;
 }
 
-static void eeepc_wmi_input_exit(struct eeepc_wmi *eeepc)
+static void asus_wmi_input_exit(struct asus_wmi *asus)
 {
-	if (eeepc->inputdev) {
-		sparse_keymap_free(eeepc->inputdev);
-		input_unregister_device(eeepc->inputdev);
+	if (asus->inputdev) {
+		sparse_keymap_free(asus->inputdev);
+		input_unregister_device(asus->inputdev);
 	}
 
-	eeepc->inputdev = NULL;
+	asus->inputdev = NULL;
 }
 
-static acpi_status eeepc_wmi_get_devstate(u32 dev_id, u32 *retval)
+static acpi_status asus_wmi_get_devstate(u32 dev_id, u32 *retval)
 {
-	struct acpi_buffer input = { (acpi_size)sizeof(u32), &dev_id };
+	struct acpi_buffer input = { (acpi_size) sizeof(u32), &dev_id };
 	struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
 	union acpi_object *obj;
 	acpi_status status;
 	u32 tmp;
 
-	status = wmi_evaluate_method(EEEPC_WMI_MGMT_GUID,
-				     1, EEEPC_WMI_METHODID_DSTS,
+	status = wmi_evaluate_method(ASUS_WMI_MGMT_GUID,
+				     1, ASUS_WMI_METHODID_DSTS,
 				     &input, &output);
 
 	if (ACPI_FAILURE(status))
@@ -230,7 +197,7 @@ static acpi_status eeepc_wmi_get_devstate(u32 dev_id, u32 *retval)
 
 	obj = (union acpi_object *)output.pointer;
 	if (obj && obj->type == ACPI_TYPE_INTEGER)
-		tmp = (u32)obj->integer.value;
+		tmp = (u32) obj->integer.value;
 	else
 		tmp = 0;
 
@@ -243,27 +210,27 @@ static acpi_status eeepc_wmi_get_devstate(u32 dev_id, u32 *retval)
 
 }
 
-static acpi_status eeepc_wmi_set_devstate(u32 dev_id, u32 ctrl_param,
-					  u32 *retval)
+static acpi_status asus_wmi_set_devstate(u32 dev_id, u32 ctrl_param,
+					 u32 *retval)
 {
 	struct bios_args args = {
 		.dev_id = dev_id,
 		.ctrl_param = ctrl_param,
 	};
-	struct acpi_buffer input = { (acpi_size)sizeof(args), &args };
+	struct acpi_buffer input = { (acpi_size) sizeof(args), &args };
 	acpi_status status;
 
 	if (!retval) {
-		status = wmi_evaluate_method(EEEPC_WMI_MGMT_GUID, 1,
-					     EEEPC_WMI_METHODID_DEVS,
+		status = wmi_evaluate_method(ASUS_WMI_MGMT_GUID, 1,
+					     ASUS_WMI_METHODID_DEVS,
 					     &input, NULL);
 	} else {
 		struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
 		union acpi_object *obj;
 		u32 tmp;
 
-		status = wmi_evaluate_method(EEEPC_WMI_MGMT_GUID, 1,
-					     EEEPC_WMI_METHODID_DEVS,
+		status = wmi_evaluate_method(ASUS_WMI_MGMT_GUID, 1,
+					     ASUS_WMI_METHODID_DEVS,
 					     &input, &output);
 
 		if (ACPI_FAILURE(status))
@@ -271,7 +238,7 @@ static acpi_status eeepc_wmi_set_devstate(u32 dev_id, u32 ctrl_param,
 
 		obj = (union acpi_object *)output.pointer;
 		if (obj && obj->type == ACPI_TYPE_INTEGER)
-			tmp = (u32)obj->integer.value;
+			tmp = (u32) obj->integer.value;
 		else
 			tmp = 0;
 
@@ -284,25 +251,25 @@ static acpi_status eeepc_wmi_set_devstate(u32 dev_id, u32 ctrl_param,
 }
 
 /* Helper for special devices with magic return codes */
-static int eeepc_wmi_get_devstate_bits(u32 dev_id, u32 mask)
+static int asus_wmi_get_devstate_bits(u32 dev_id, u32 mask)
 {
 	u32 retval = 0;
 	acpi_status status;
 
-	status = eeepc_wmi_get_devstate(dev_id, &retval);
+	status = asus_wmi_get_devstate(dev_id, &retval);
 
 	if (ACPI_FAILURE(status))
 		return -EINVAL;
 
-	if (!(retval & EEEPC_WMI_DSTS_PRESENCE_BIT))
+	if (!(retval & ASUS_WMI_DSTS_PRESENCE_BIT))
 		return -ENODEV;
 
 	return retval & mask;
 }
 
-static int eeepc_wmi_get_devstate_simple(u32 dev_id)
+static int asus_wmi_get_devstate_simple(u32 dev_id)
 {
-	return eeepc_wmi_get_devstate_bits(dev_id, EEEPC_WMI_DSTS_STATUS_BIT);
+	return asus_wmi_get_devstate_bits(dev_id, ASUS_WMI_DSTS_STATUS_BIT);
 }
 
 /*
@@ -311,93 +278,92 @@ static int eeepc_wmi_get_devstate_simple(u32 dev_id)
 /*
  * These functions actually update the LED's, and are called from a
  * workqueue. By doing this as separate work rather than when the LED
- * subsystem asks, we avoid messing with the Eeepc ACPI stuff during a
+ * subsystem asks, we avoid messing with the Asus ACPI stuff during a
  * potentially bad time, such as a timer interrupt.
  */
 static void tpd_led_update(struct work_struct *work)
 {
 	int ctrl_param;
-	struct eeepc_wmi *eeepc;
+	struct asus_wmi *asus;
 
-	eeepc = container_of(work, struct eeepc_wmi, tpd_led_work);
+	asus = container_of(work, struct asus_wmi, tpd_led_work);
 
-	ctrl_param = eeepc->tpd_led_wk;
-	eeepc_wmi_set_devstate(EEEPC_WMI_DEVID_TOUCHPAD_LED, ctrl_param, NULL);
+	ctrl_param = asus->tpd_led_wk;
+	asus_wmi_set_devstate(ASUS_WMI_DEVID_TOUCHPAD_LED, ctrl_param, NULL);
 }
 
 static void tpd_led_set(struct led_classdev *led_cdev,
 			enum led_brightness value)
 {
-	struct eeepc_wmi *eeepc;
+	struct asus_wmi *asus;
 
-	eeepc = container_of(led_cdev, struct eeepc_wmi, tpd_led);
+	asus = container_of(led_cdev, struct asus_wmi, tpd_led);
 
-	eeepc->tpd_led_wk = !!value;
-	queue_work(eeepc->led_workqueue, &eeepc->tpd_led_work);
+	asus->tpd_led_wk = !!value;
+	queue_work(asus->led_workqueue, &asus->tpd_led_work);
 }
 
-static int read_tpd_led_state(struct eeepc_wmi *eeepc)
+static int read_tpd_led_state(struct asus_wmi *asus)
 {
-	return eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_TOUCHPAD_LED);
+	return asus_wmi_get_devstate_simple(ASUS_WMI_DEVID_TOUCHPAD_LED);
 }
 
 static enum led_brightness tpd_led_get(struct led_classdev *led_cdev)
 {
-	struct eeepc_wmi *eeepc;
+	struct asus_wmi *asus;
 
-	eeepc = container_of(led_cdev, struct eeepc_wmi, tpd_led);
+	asus = container_of(led_cdev, struct asus_wmi, tpd_led);
 
-	return read_tpd_led_state(eeepc);
+	return read_tpd_led_state(asus);
 }
 
-static int eeepc_wmi_led_init(struct eeepc_wmi *eeepc)
+static int asus_wmi_led_init(struct asus_wmi *asus)
 {
 	int rv;
 
-	if (read_tpd_led_state(eeepc) < 0)
+	if (read_tpd_led_state(asus) < 0)
 		return 0;
 
-	eeepc->led_workqueue = create_singlethread_workqueue("led_workqueue");
-	if (!eeepc->led_workqueue)
+	asus->led_workqueue = create_singlethread_workqueue("led_workqueue");
+	if (!asus->led_workqueue)
 		return -ENOMEM;
-	INIT_WORK(&eeepc->tpd_led_work, tpd_led_update);
+	INIT_WORK(&asus->tpd_led_work, tpd_led_update);
 
-	eeepc->tpd_led.name = "eeepc::touchpad";
-	eeepc->tpd_led.brightness_set = tpd_led_set;
-	eeepc->tpd_led.brightness_get = tpd_led_get;
-	eeepc->tpd_led.max_brightness = 1;
+	asus->tpd_led.name = "asus::touchpad";
+	asus->tpd_led.brightness_set = tpd_led_set;
+	asus->tpd_led.brightness_get = tpd_led_get;
+	asus->tpd_led.max_brightness = 1;
 
-	rv = led_classdev_register(&eeepc->platform_device->dev,
-				   &eeepc->tpd_led);
+	rv = led_classdev_register(&asus->platform_device->dev, &asus->tpd_led);
 	if (rv) {
-		destroy_workqueue(eeepc->led_workqueue);
+		destroy_workqueue(asus->led_workqueue);
 		return rv;
 	}
 
 	return 0;
 }
 
-static void eeepc_wmi_led_exit(struct eeepc_wmi *eeepc)
+static void asus_wmi_led_exit(struct asus_wmi *asus)
 {
-	if (eeepc->tpd_led.dev)
-		led_classdev_unregister(&eeepc->tpd_led);
-	if (eeepc->led_workqueue)
-		destroy_workqueue(eeepc->led_workqueue);
+	if (asus->tpd_led.dev)
+		led_classdev_unregister(&asus->tpd_led);
+	if (asus->led_workqueue)
+		destroy_workqueue(asus->led_workqueue);
 }
 
 /*
  * PCI hotplug (for wlan rfkill)
  */
-static bool eeepc_wlan_rfkill_blocked(struct eeepc_wmi *eeepc)
+static bool asus_wlan_rfkill_blocked(struct asus_wmi *asus)
 {
-	int result = eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_WLAN);
+	int result = asus_wmi_get_devstate_simple(ASUS_WMI_DEVID_WLAN);
 
 	if (result < 0)
 		return false;
 	return !result;
 }
 
-static void eeepc_rfkill_hotplug(struct eeepc_wmi *eeepc)
+static void asus_rfkill_hotplug(struct asus_wmi *asus)
 {
 	struct pci_dev *dev;
 	struct pci_bus *bus;
@@ -405,16 +371,16 @@ static void eeepc_rfkill_hotplug(struct eeepc_wmi *eeepc)
 	bool absent;
 	u32 l;
 
-	mutex_lock(&eeepc->wmi_lock);
-	blocked = eeepc_wlan_rfkill_blocked(eeepc);
-	mutex_unlock(&eeepc->wmi_lock);
+	mutex_lock(&asus->wmi_lock);
+	blocked = asus_wlan_rfkill_blocked(asus);
+	mutex_unlock(&asus->wmi_lock);
 
-	mutex_lock(&eeepc->hotplug_lock);
+	mutex_lock(&asus->hotplug_lock);
 
-	if (eeepc->wlan_rfkill)
-		rfkill_set_sw_state(eeepc->wlan_rfkill, blocked);
+	if (asus->wlan_rfkill)
+		rfkill_set_sw_state(asus->wlan_rfkill, blocked);
 
-	if (eeepc->hotplug_slot) {
+	if (asus->hotplug_slot) {
 		bus = pci_find_bus(0, 1);
 		if (!bus) {
 			pr_warning("Unable to find PCI bus 1?\n");
@@ -429,11 +395,11 @@ static void eeepc_rfkill_hotplug(struct eeepc_wmi *eeepc)
 
 		if (blocked != absent) {
 			pr_warning("BIOS says wireless lan is %s, "
-					"but the pci device is %s\n",
-				blocked ? "blocked" : "unblocked",
-				absent ? "absent" : "present");
+				   "but the pci device is %s\n",
+				   blocked ? "blocked" : "unblocked",
+				   absent ? "absent" : "present");
 			pr_warning("skipped wireless hotplug as probably "
-					"inappropriate for this model\n");
+				   "inappropriate for this model\n");
 			goto out_unlock;
 		}
 
@@ -460,28 +426,27 @@ static void eeepc_rfkill_hotplug(struct eeepc_wmi *eeepc)
 	}
 
 out_unlock:
-	mutex_unlock(&eeepc->hotplug_lock);
+	mutex_unlock(&asus->hotplug_lock);
 }
 
-static void eeepc_rfkill_notify(acpi_handle handle, u32 event, void *data)
+static void asus_rfkill_notify(acpi_handle handle, u32 event, void *data)
 {
-	struct eeepc_wmi *eeepc = data;
+	struct asus_wmi *asus = data;
 
 	if (event != ACPI_NOTIFY_BUS_CHECK)
 		return;
 
 	/*
-	 * We can't call directly eeepc_rfkill_hotplug because most
+	 * We can't call directly asus_rfkill_hotplug because most
 	 * of the time WMBC is still being executed and not reetrant.
 	 * There is currently no way to tell ACPICA that  we want this
-	 * method to be serialized, we schedule a eeepc_rfkill_hotplug
+	 * method to be serialized, we schedule a asus_rfkill_hotplug
 	 * call later, in a safer context.
 	 */
-	queue_work(eeepc->hotplug_workqueue, &eeepc->hotplug_work);
+	queue_work(asus->hotplug_workqueue, &asus->hotplug_work);
 }
 
-static int eeepc_register_rfkill_notifier(struct eeepc_wmi *eeepc,
-					  char *node)
+static int asus_register_rfkill_notifier(struct asus_wmi *asus, char *node)
 {
 	acpi_status status;
 	acpi_handle handle;
@@ -491,8 +456,7 @@ static int eeepc_register_rfkill_notifier(struct eeepc_wmi *eeepc,
 	if (ACPI_SUCCESS(status)) {
 		status = acpi_install_notify_handler(handle,
 						     ACPI_SYSTEM_NOTIFY,
-						     eeepc_rfkill_notify,
-						     eeepc);
+						     asus_rfkill_notify, asus);
 		if (ACPI_FAILURE(status))
 			pr_warning("Failed to register notify on %s\n", node);
 	} else
@@ -501,8 +465,7 @@ static int eeepc_register_rfkill_notifier(struct eeepc_wmi *eeepc,
 	return 0;
 }
 
-static void eeepc_unregister_rfkill_notifier(struct eeepc_wmi *eeepc,
-					     char *node)
+static void asus_unregister_rfkill_notifier(struct asus_wmi *asus, char *node)
 {
 	acpi_status status = AE_OK;
 	acpi_handle handle;
@@ -511,18 +474,18 @@ static void eeepc_unregister_rfkill_notifier(struct eeepc_wmi *eeepc,
 
 	if (ACPI_SUCCESS(status)) {
 		status = acpi_remove_notify_handler(handle,
-						     ACPI_SYSTEM_NOTIFY,
-						     eeepc_rfkill_notify);
+						    ACPI_SYSTEM_NOTIFY,
+						    asus_rfkill_notify);
 		if (ACPI_FAILURE(status))
 			pr_err("Error removing rfkill notify handler %s\n",
-				node);
+			       node);
 	}
 }
 
-static int eeepc_get_adapter_status(struct hotplug_slot *hotplug_slot,
-				    u8 *value)
+static int asus_get_adapter_status(struct hotplug_slot *hotplug_slot,
+				   u8 *value)
 {
-	int result = eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_WLAN);
+	int result = asus_wmi_get_devstate_simple(ASUS_WMI_DEVID_WLAN);
 
 	if (result < 0)
 		return result;
@@ -531,27 +494,27 @@ static int eeepc_get_adapter_status(struct hotplug_slot *hotplug_slot,
 	return 0;
 }
 
-static void eeepc_cleanup_pci_hotplug(struct hotplug_slot *hotplug_slot)
+static void asus_cleanup_pci_hotplug(struct hotplug_slot *hotplug_slot)
 {
 	kfree(hotplug_slot->info);
 	kfree(hotplug_slot);
 }
 
-static struct hotplug_slot_ops eeepc_hotplug_slot_ops = {
+static struct hotplug_slot_ops asus_hotplug_slot_ops = {
 	.owner = THIS_MODULE,
-	.get_adapter_status = eeepc_get_adapter_status,
-	.get_power_status = eeepc_get_adapter_status,
+	.get_adapter_status = asus_get_adapter_status,
+	.get_power_status = asus_get_adapter_status,
 };
 
-static void eeepc_hotplug_work(struct work_struct *work)
+static void asus_hotplug_work(struct work_struct *work)
 {
-	struct eeepc_wmi *eeepc;
+	struct asus_wmi *asus;
 
-	eeepc = container_of(work, struct eeepc_wmi, hotplug_work);
-	eeepc_rfkill_hotplug(eeepc);
+	asus = container_of(work, struct asus_wmi, hotplug_work);
+	asus_rfkill_hotplug(asus);
 }
 
-static int eeepc_setup_pci_hotplug(struct eeepc_wmi *eeepc)
+static int asus_setup_pci_hotplug(struct asus_wmi *asus)
 {
 	int ret = -ENOMEM;
 	struct pci_bus *bus = pci_find_bus(0, 1);
@@ -561,29 +524,29 @@ static int eeepc_setup_pci_hotplug(struct eeepc_wmi *eeepc)
 		return -ENODEV;
 	}
 
-	eeepc->hotplug_workqueue =
-		create_singlethread_workqueue("hotplug_workqueue");
-	if (!eeepc->hotplug_workqueue)
+	asus->hotplug_workqueue =
+	    create_singlethread_workqueue("hotplug_workqueue");
+	if (!asus->hotplug_workqueue)
 		goto error_workqueue;
 
-	INIT_WORK(&eeepc->hotplug_work, eeepc_hotplug_work);
+	INIT_WORK(&asus->hotplug_work, asus_hotplug_work);
 
-	eeepc->hotplug_slot = kzalloc(sizeof(struct hotplug_slot), GFP_KERNEL);
-	if (!eeepc->hotplug_slot)
+	asus->hotplug_slot = kzalloc(sizeof(struct hotplug_slot), GFP_KERNEL);
+	if (!asus->hotplug_slot)
 		goto error_slot;
 
-	eeepc->hotplug_slot->info = kzalloc(sizeof(struct hotplug_slot_info),
-					    GFP_KERNEL);
-	if (!eeepc->hotplug_slot->info)
+	asus->hotplug_slot->info = kzalloc(sizeof(struct hotplug_slot_info),
+					   GFP_KERNEL);
+	if (!asus->hotplug_slot->info)
 		goto error_info;
 
-	eeepc->hotplug_slot->private = eeepc;
-	eeepc->hotplug_slot->release = &eeepc_cleanup_pci_hotplug;
-	eeepc->hotplug_slot->ops = &eeepc_hotplug_slot_ops;
-	eeepc_get_adapter_status(eeepc->hotplug_slot,
-				 &eeepc->hotplug_slot->info->adapter_status);
+	asus->hotplug_slot->private = asus;
+	asus->hotplug_slot->release = &asus_cleanup_pci_hotplug;
+	asus->hotplug_slot->ops = &asus_hotplug_slot_ops;
+	asus_get_adapter_status(asus->hotplug_slot,
+				&asus->hotplug_slot->info->adapter_status);
 
-	ret = pci_hp_register(eeepc->hotplug_slot, bus, 0, "eeepc-wifi");
+	ret = pci_hp_register(asus->hotplug_slot, bus, 0, "asus-wifi");
 	if (ret) {
 		pr_err("Unable to register hotplug slot - %d\n", ret);
 		goto error_register;
@@ -592,12 +555,12 @@ static int eeepc_setup_pci_hotplug(struct eeepc_wmi *eeepc)
 	return 0;
 
 error_register:
-	kfree(eeepc->hotplug_slot->info);
+	kfree(asus->hotplug_slot->info);
 error_info:
-	kfree(eeepc->hotplug_slot);
-	eeepc->hotplug_slot = NULL;
+	kfree(asus->hotplug_slot);
+	asus->hotplug_slot = NULL;
 error_slot:
-	destroy_workqueue(eeepc->hotplug_workqueue);
+	destroy_workqueue(asus->hotplug_workqueue);
 error_workqueue:
 	return ret;
 }
@@ -605,13 +568,13 @@ static int eeepc_setup_pci_hotplug(struct eeepc_wmi *eeepc)
 /*
  * Rfkill devices
  */
-static int eeepc_rfkill_set(void *data, bool blocked)
+static int asus_rfkill_set(void *data, bool blocked)
 {
 	int dev_id = (unsigned long)data;
 	u32 ctrl_param = !blocked;
 	acpi_status status;
 
-	status = eeepc_wmi_set_devstate(dev_id, ctrl_param, NULL);
+	status = asus_wmi_set_devstate(dev_id, ctrl_param, NULL);
 
 	if (ACPI_FAILURE(status))
 		return -EIO;
@@ -619,68 +582,67 @@ static int eeepc_rfkill_set(void *data, bool blocked)
 	return 0;
 }
 
-static void eeepc_rfkill_query(struct rfkill *rfkill, void *data)
+static void asus_rfkill_query(struct rfkill *rfkill, void *data)
 {
 	int dev_id = (unsigned long)data;
 	int result;
 
-	result = eeepc_wmi_get_devstate_simple(dev_id);
+	result = asus_wmi_get_devstate_simple(dev_id);
 
 	if (result < 0)
-		return ;
+		return;
 
 	rfkill_set_sw_state(rfkill, !result);
 }
 
-static int eeepc_rfkill_wlan_set(void *data, bool blocked)
+static int asus_rfkill_wlan_set(void *data, bool blocked)
 {
-	struct eeepc_wmi *eeepc = data;
+	struct asus_wmi *asus = data;
 	int ret;
 
 	/*
 	 * This handler is enabled only if hotplug is enabled.
-	 * In this case, the eeepc_wmi_set_devstate() will
+	 * In this case, the asus_wmi_set_devstate() will
 	 * trigger a wmi notification and we need to wait
 	 * this call to finish before being able to call
 	 * any wmi method
 	 */
-	mutex_lock(&eeepc->wmi_lock);
-	ret = eeepc_rfkill_set((void *)(long)EEEPC_WMI_DEVID_WLAN, blocked);
-	mutex_unlock(&eeepc->wmi_lock);
+	mutex_lock(&asus->wmi_lock);
+	ret = asus_rfkill_set((void *)(long)ASUS_WMI_DEVID_WLAN, blocked);
+	mutex_unlock(&asus->wmi_lock);
 	return ret;
 }
 
-static void eeepc_rfkill_wlan_query(struct rfkill *rfkill, void *data)
+static void asus_rfkill_wlan_query(struct rfkill *rfkill, void *data)
 {
-	eeepc_rfkill_query(rfkill, (void *)(long)EEEPC_WMI_DEVID_WLAN);
+	asus_rfkill_query(rfkill, (void *)(long)ASUS_WMI_DEVID_WLAN);
 }
 
-static const struct rfkill_ops eeepc_rfkill_wlan_ops = {
-	.set_block = eeepc_rfkill_wlan_set,
-	.query = eeepc_rfkill_wlan_query,
+static const struct rfkill_ops asus_rfkill_wlan_ops = {
+	.set_block = asus_rfkill_wlan_set,
+	.query = asus_rfkill_wlan_query,
 };
 
-static const struct rfkill_ops eeepc_rfkill_ops = {
-	.set_block = eeepc_rfkill_set,
-	.query = eeepc_rfkill_query,
+static const struct rfkill_ops asus_rfkill_ops = {
+	.set_block = asus_rfkill_set,
+	.query = asus_rfkill_query,
 };
 
-static int eeepc_new_rfkill(struct eeepc_wmi *eeepc,
-			    struct rfkill **rfkill,
-			    const char *name,
-			    enum rfkill_type type, int dev_id)
+static int asus_new_rfkill(struct asus_wmi *asus,
+			   struct rfkill **rfkill,
+			   const char *name, enum rfkill_type type, int dev_id)
 {
-	int result = eeepc_wmi_get_devstate_simple(dev_id);
+	int result = asus_wmi_get_devstate_simple(dev_id);
 
 	if (result < 0)
 		return result;
 
-	if (dev_id == EEEPC_WMI_DEVID_WLAN && eeepc->hotplug_wireless)
-		*rfkill = rfkill_alloc(name, &eeepc->platform_device->dev, type,
-				       &eeepc_rfkill_wlan_ops, eeepc);
+	if (dev_id == ASUS_WMI_DEVID_WLAN && asus->driver->hotplug_wireless)
+		*rfkill = rfkill_alloc(name, &asus->platform_device->dev, type,
+				       &asus_rfkill_wlan_ops, asus);
 	else
-		*rfkill = rfkill_alloc(name, &eeepc->platform_device->dev, type,
-				       &eeepc_rfkill_ops, (void *)(long)dev_id);
+		*rfkill = rfkill_alloc(name, &asus->platform_device->dev, type,
+				       &asus_rfkill_ops, (void *)(long)dev_id);
 
 	if (!*rfkill)
 		return -EINVAL;
@@ -695,82 +657,82 @@ static int eeepc_new_rfkill(struct eeepc_wmi *eeepc,
 	return 0;
 }
 
-static void eeepc_wmi_rfkill_exit(struct eeepc_wmi *eeepc)
+static void asus_wmi_rfkill_exit(struct asus_wmi *asus)
 {
-	eeepc_unregister_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P5");
-	eeepc_unregister_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P6");
-	eeepc_unregister_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P7");
-	if (eeepc->wlan_rfkill) {
-		rfkill_unregister(eeepc->wlan_rfkill);
-		rfkill_destroy(eeepc->wlan_rfkill);
-		eeepc->wlan_rfkill = NULL;
+	asus_unregister_rfkill_notifier(asus, "\\_SB.PCI0.P0P5");
+	asus_unregister_rfkill_notifier(asus, "\\_SB.PCI0.P0P6");
+	asus_unregister_rfkill_notifier(asus, "\\_SB.PCI0.P0P7");
+	if (asus->wlan_rfkill) {
+		rfkill_unregister(asus->wlan_rfkill);
+		rfkill_destroy(asus->wlan_rfkill);
+		asus->wlan_rfkill = NULL;
 	}
 	/*
 	 * Refresh pci hotplug in case the rfkill state was changed after
-	 * eeepc_unregister_rfkill_notifier()
+	 * asus_unregister_rfkill_notifier()
 	 */
-	eeepc_rfkill_hotplug(eeepc);
-	if (eeepc->hotplug_slot)
-		pci_hp_deregister(eeepc->hotplug_slot);
-	if (eeepc->hotplug_workqueue)
-		destroy_workqueue(eeepc->hotplug_workqueue);
-
-	if (eeepc->bluetooth_rfkill) {
-		rfkill_unregister(eeepc->bluetooth_rfkill);
-		rfkill_destroy(eeepc->bluetooth_rfkill);
-		eeepc->bluetooth_rfkill = NULL;
+	asus_rfkill_hotplug(asus);
+	if (asus->hotplug_slot)
+		pci_hp_deregister(asus->hotplug_slot);
+	if (asus->hotplug_workqueue)
+		destroy_workqueue(asus->hotplug_workqueue);
+
+	if (asus->bluetooth_rfkill) {
+		rfkill_unregister(asus->bluetooth_rfkill);
+		rfkill_destroy(asus->bluetooth_rfkill);
+		asus->bluetooth_rfkill = NULL;
 	}
-	if (eeepc->wimax_rfkill) {
-		rfkill_unregister(eeepc->wimax_rfkill);
-		rfkill_destroy(eeepc->wimax_rfkill);
-		eeepc->wimax_rfkill = NULL;
+	if (asus->wimax_rfkill) {
+		rfkill_unregister(asus->wimax_rfkill);
+		rfkill_destroy(asus->wimax_rfkill);
+		asus->wimax_rfkill = NULL;
 	}
-	if (eeepc->wwan3g_rfkill) {
-		rfkill_unregister(eeepc->wwan3g_rfkill);
-		rfkill_destroy(eeepc->wwan3g_rfkill);
-		eeepc->wwan3g_rfkill = NULL;
+	if (asus->wwan3g_rfkill) {
+		rfkill_unregister(asus->wwan3g_rfkill);
+		rfkill_destroy(asus->wwan3g_rfkill);
+		asus->wwan3g_rfkill = NULL;
 	}
 }
 
-static int eeepc_wmi_rfkill_init(struct eeepc_wmi *eeepc)
+static int asus_wmi_rfkill_init(struct asus_wmi *asus)
 {
 	int result = 0;
 
-	mutex_init(&eeepc->hotplug_lock);
-	mutex_init(&eeepc->wmi_lock);
+	mutex_init(&asus->hotplug_lock);
+	mutex_init(&asus->wmi_lock);
 
-	result = eeepc_new_rfkill(eeepc, &eeepc->wlan_rfkill,
-				  "eeepc-wlan", RFKILL_TYPE_WLAN,
-				  EEEPC_WMI_DEVID_WLAN);
+	result = asus_new_rfkill(asus, &asus->wlan_rfkill,
+				 "asus-wlan", RFKILL_TYPE_WLAN,
+				 ASUS_WMI_DEVID_WLAN);
 
 	if (result && result != -ENODEV)
 		goto exit;
 
-	result = eeepc_new_rfkill(eeepc, &eeepc->bluetooth_rfkill,
-				  "eeepc-bluetooth", RFKILL_TYPE_BLUETOOTH,
-				  EEEPC_WMI_DEVID_BLUETOOTH);
+	result = asus_new_rfkill(asus, &asus->bluetooth_rfkill,
+				 "asus-bluetooth", RFKILL_TYPE_BLUETOOTH,
+				 ASUS_WMI_DEVID_BLUETOOTH);
 
 	if (result && result != -ENODEV)
 		goto exit;
 
-	result = eeepc_new_rfkill(eeepc, &eeepc->wimax_rfkill,
-				  "eeepc-wimax", RFKILL_TYPE_WIMAX,
-				  EEEPC_WMI_DEVID_WIMAX);
+	result = asus_new_rfkill(asus, &asus->wimax_rfkill,
+				 "asus-wimax", RFKILL_TYPE_WIMAX,
+				 ASUS_WMI_DEVID_WIMAX);
 
 	if (result && result != -ENODEV)
 		goto exit;
 
-	result = eeepc_new_rfkill(eeepc, &eeepc->wwan3g_rfkill,
-				  "eeepc-wwan3g", RFKILL_TYPE_WWAN,
-				  EEEPC_WMI_DEVID_WWAN3G);
+	result = asus_new_rfkill(asus, &asus->wwan3g_rfkill,
+				 "asus-wwan3g", RFKILL_TYPE_WWAN,
+				 ASUS_WMI_DEVID_WWAN3G);
 
 	if (result && result != -ENODEV)
 		goto exit;
 
-	if (!eeepc->hotplug_wireless)
+	if (!asus->driver->hotplug_wireless)
 		goto exit;
 
-	result = eeepc_setup_pci_hotplug(eeepc);
+	result = asus_setup_pci_hotplug(asus);
 	/*
 	 * If we get -EBUSY then something else is handling the PCI hotplug -
 	 * don't fail in this case
@@ -778,18 +740,18 @@ static int eeepc_wmi_rfkill_init(struct eeepc_wmi *eeepc)
 	if (result == -EBUSY)
 		result = 0;
 
-	eeepc_register_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P5");
-	eeepc_register_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P6");
-	eeepc_register_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P7");
+	asus_register_rfkill_notifier(asus, "\\_SB.PCI0.P0P5");
+	asus_register_rfkill_notifier(asus, "\\_SB.PCI0.P0P6");
+	asus_register_rfkill_notifier(asus, "\\_SB.PCI0.P0P7");
 	/*
 	 * Refresh pci hotplug in case the rfkill state was changed during
 	 * setup.
 	 */
-	eeepc_rfkill_hotplug(eeepc);
+	asus_rfkill_hotplug(asus);
 
 exit:
 	if (result && result != -ENODEV)
-		eeepc_wmi_rfkill_exit(eeepc);
+		asus_wmi_rfkill_exit(asus);
 
 	if (result == -ENODEV)
 		result = 0;
@@ -802,7 +764,7 @@ static int eeepc_wmi_rfkill_init(struct eeepc_wmi *eeepc)
  */
 static int read_backlight_power(void)
 {
-	int ret = eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_BACKLIGHT);
+	int ret = asus_wmi_get_devstate_simple(ASUS_WMI_DEVID_BACKLIGHT);
 
 	if (ret < 0)
 		return ret;
@@ -815,12 +777,12 @@ static int read_brightness(struct backlight_device *bd)
 	u32 retval;
 	acpi_status status;
 
-	status = eeepc_wmi_get_devstate(EEEPC_WMI_DEVID_BRIGHTNESS, &retval);
+	status = asus_wmi_get_devstate(ASUS_WMI_DEVID_BRIGHTNESS, &retval);
 
 	if (ACPI_FAILURE(status))
 		return -EIO;
 	else
-		return retval & EEEPC_WMI_DSTS_BRIGHTNESS_MASK;
+		return retval & ASUS_WMI_DSTS_BRIGHTNESS_MASK;
 }
 
 static int update_bl_status(struct backlight_device *bd)
@@ -831,8 +793,8 @@ static int update_bl_status(struct backlight_device *bd)
 
 	ctrl_param = bd->props.brightness;
 
-	status = eeepc_wmi_set_devstate(EEEPC_WMI_DEVID_BRIGHTNESS,
-					ctrl_param, NULL);
+	status = asus_wmi_set_devstate(ASUS_WMI_DEVID_BRIGHTNESS,
+				       ctrl_param, NULL);
 
 	if (ACPI_FAILURE(status))
 		return -EIO;
@@ -840,8 +802,8 @@ static int update_bl_status(struct backlight_device *bd)
 	power = read_backlight_power();
 	if (power != -ENODEV && bd->props.power != power) {
 		ctrl_param = !!(bd->props.power == FB_BLANK_UNBLANK);
-		status = eeepc_wmi_set_devstate(EEEPC_WMI_DEVID_BACKLIGHT,
-						ctrl_param, NULL);
+		status = asus_wmi_set_devstate(ASUS_WMI_DEVID_BACKLIGHT,
+					       ctrl_param, NULL);
 
 		if (ACPI_FAILURE(status))
 			return -EIO;
@@ -849,14 +811,14 @@ static int update_bl_status(struct backlight_device *bd)
 	return 0;
 }
 
-static const struct backlight_ops eeepc_wmi_bl_ops = {
+static const struct backlight_ops asus_wmi_bl_ops = {
 	.get_brightness = read_brightness,
 	.update_status = update_bl_status,
 };
 
-static int eeepc_wmi_backlight_notify(struct eeepc_wmi *eeepc, int code)
+static int asus_wmi_backlight_notify(struct asus_wmi *asus, int code)
 {
-	struct backlight_device *bd = eeepc->backlight_device;
+	struct backlight_device *bd = asus->backlight_device;
 	int old = bd->props.brightness;
 	int new = old;
 
@@ -872,15 +834,15 @@ static int eeepc_wmi_backlight_notify(struct eeepc_wmi *eeepc, int code)
 	return old;
 }
 
-static int eeepc_wmi_backlight_init(struct eeepc_wmi *eeepc)
+static int asus_wmi_backlight_init(struct asus_wmi *asus)
 {
 	struct backlight_device *bd;
 	struct backlight_properties props;
 	int max;
 	int power;
 
-	max = eeepc_wmi_get_devstate_bits(EEEPC_WMI_DEVID_BRIGHTNESS,
-					  EEEPC_WMI_DSTS_MAX_BRIGTH_MASK);
+	max = asus_wmi_get_devstate_bits(ASUS_WMI_DEVID_BRIGHTNESS,
+					 ASUS_WMI_DSTS_MAX_BRIGTH_MASK);
 	power = read_backlight_power();
 
 	if (max < 0 && power < 0) {
@@ -899,15 +861,15 @@ static int eeepc_wmi_backlight_init(struct eeepc_wmi *eeepc)
 
 	memset(&props, 0, sizeof(struct backlight_properties));
 	props.max_brightness = max;
-	bd = backlight_device_register(EEEPC_WMI_FILE,
-				       &eeepc->platform_device->dev, eeepc,
-				       &eeepc_wmi_bl_ops, &props);
+	bd = backlight_device_register(asus->driver->name,
+				       &asus->platform_device->dev, asus,
+				       &asus_wmi_bl_ops, &props);
 	if (IS_ERR(bd)) {
 		pr_err("Could not register backlight device\n");
 		return PTR_ERR(bd);
 	}
 
-	eeepc->backlight_device = bd;
+	asus->backlight_device = bd;
 
 	bd->props.brightness = read_brightness(bd);
 	bd->props.power = power;
@@ -916,17 +878,17 @@ static int eeepc_wmi_backlight_init(struct eeepc_wmi *eeepc)
 	return 0;
 }
 
-static void eeepc_wmi_backlight_exit(struct eeepc_wmi *eeepc)
+static void asus_wmi_backlight_exit(struct asus_wmi *asus)
 {
-	if (eeepc->backlight_device)
-		backlight_device_unregister(eeepc->backlight_device);
+	if (asus->backlight_device)
+		backlight_device_unregister(asus->backlight_device);
 
-	eeepc->backlight_device = NULL;
+	asus->backlight_device = NULL;
 }
 
-static void eeepc_wmi_notify(u32 value, void *context)
+static void asus_wmi_notify(u32 value, void *context)
 {
-	struct eeepc_wmi *eeepc = context;
+	struct asus_wmi *asus = context;
 	struct acpi_buffer response = { ACPI_ALLOCATE_BUFFER, NULL };
 	union acpi_object *obj;
 	acpi_status status;
@@ -953,11 +915,10 @@ static void eeepc_wmi_notify(u32 value, void *context)
 
 		if (code == NOTIFY_BRNUP_MIN || code == NOTIFY_BRNDOWN_MIN) {
 			if (!acpi_video_backlight_support())
-				eeepc_wmi_backlight_notify(eeepc, orig_code);
+				asus_wmi_backlight_notify(asus, orig_code);
 		}
 
-		if (!sparse_keymap_report_event(eeepc->inputdev,
-						code, 1, true))
+		if (!sparse_keymap_report_event(asus->inputdev, code, 1, true))
 			pr_info("Unknown key %x pressed\n", code);
 	}
 
@@ -982,12 +943,12 @@ static ssize_t store_sys_wmi(int devid, const char *buf, size_t count)
 	u32 retval;
 	int rv, value;
 
-	value = eeepc_wmi_get_devstate_simple(devid);
-	if (value == -ENODEV) /* Check device presence */
+	value = asus_wmi_get_devstate_simple(devid);
+	if (value == -ENODEV)	/* Check device presence */
 		return value;
 
 	rv = parse_arg(buf, count, &value);
-	status = eeepc_wmi_set_devstate(devid, value, &retval);
+	status = asus_wmi_set_devstate(devid, value, &retval);
 
 	if (ACPI_FAILURE(status))
 		return -EIO;
@@ -996,7 +957,7 @@ static ssize_t store_sys_wmi(int devid, const char *buf, size_t count)
 
 static ssize_t show_sys_wmi(int devid, char *buf)
 {
-	int value = eeepc_wmi_get_devstate_simple(devid);
+	int value = asus_wmi_get_devstate_simple(devid);
 
 	if (value < 0)
 		return value;
@@ -1004,7 +965,7 @@ static ssize_t show_sys_wmi(int devid, char *buf)
 	return sprintf(buf, "%d\n", value);
 }
 
-#define EEEPC_WMI_CREATE_DEVICE_ATTR(_name, _mode, _cm)			\
+#define ASUS_WMI_CREATE_DEVICE_ATTR(_name, _mode, _cm)			\
 	static ssize_t show_##_name(struct device *dev,			\
 				    struct device_attribute *attr,	\
 				    char *buf)				\
@@ -1025,15 +986,15 @@ static ssize_t show_sys_wmi(int devid, char *buf)
 		.store  = store_##_name,				\
 	}
 
-EEEPC_WMI_CREATE_DEVICE_ATTR(touchpad, 0644, EEEPC_WMI_DEVID_TOUCHPAD);
-EEEPC_WMI_CREATE_DEVICE_ATTR(camera, 0644, EEEPC_WMI_DEVID_CAMERA);
-EEEPC_WMI_CREATE_DEVICE_ATTR(cardr, 0644, EEEPC_WMI_DEVID_CARDREADER);
+ASUS_WMI_CREATE_DEVICE_ATTR(touchpad, 0644, ASUS_WMI_DEVID_TOUCHPAD);
+ASUS_WMI_CREATE_DEVICE_ATTR(camera, 0644, ASUS_WMI_DEVID_CAMERA);
+ASUS_WMI_CREATE_DEVICE_ATTR(cardr, 0644, ASUS_WMI_DEVID_CARDREADER);
 
 static ssize_t store_cpufv(struct device *dev, struct device_attribute *attr,
 			   const char *buf, size_t count)
 {
 	int value;
-	struct acpi_buffer input = { (acpi_size)sizeof(value), &value };
+	struct acpi_buffer input = { (acpi_size) sizeof(value), &value };
 	acpi_status status;
 
 	if (!count || sscanf(buf, "%i", &value) != 1)
@@ -1041,8 +1002,8 @@ static ssize_t store_cpufv(struct device *dev, struct device_attribute *attr,
 	if (value < 0 || value > 2)
 		return -EINVAL;
 
-	status = wmi_evaluate_method(EEEPC_WMI_MGMT_GUID,
-				     1, EEEPC_WMI_METHODID_CFVS, &input, NULL);
+	status = wmi_evaluate_method(ASUS_WMI_MGMT_GUID,
+				     1, ASUS_WMI_METHODID_CFVS, &input, NULL);
 
 	if (ACPI_FAILURE(status))
 		return -EIO;
@@ -1060,37 +1021,36 @@ static struct attribute *platform_attributes[] = {
 	NULL
 };
 
-static mode_t eeepc_sysfs_is_visible(struct kobject *kobj,
-				     struct attribute *attr,
-				     int idx)
+static mode_t asus_sysfs_is_visible(struct kobject *kobj,
+				    struct attribute *attr, int idx)
 {
 	bool supported = true;
 	int devid = -1;
 
 	if (attr == &dev_attr_camera.attr)
-		devid = EEEPC_WMI_DEVID_CAMERA;
+		devid = ASUS_WMI_DEVID_CAMERA;
 	else if (attr == &dev_attr_cardr.attr)
-		devid = EEEPC_WMI_DEVID_CARDREADER;
+		devid = ASUS_WMI_DEVID_CARDREADER;
 	else if (attr == &dev_attr_touchpad.attr)
-		devid = EEEPC_WMI_DEVID_TOUCHPAD;
+		devid = ASUS_WMI_DEVID_TOUCHPAD;
 
 	if (devid != -1)
-		supported = eeepc_wmi_get_devstate_simple(devid) != -ENODEV;
+		supported = asus_wmi_get_devstate_simple(devid) != -ENODEV;
 
 	return supported ? attr->mode : 0;
 }
 
 static struct attribute_group platform_attribute_group = {
-	.is_visible	= eeepc_sysfs_is_visible,
-	.attrs		= platform_attributes
+	.is_visible = asus_sysfs_is_visible,
+	.attrs = platform_attributes
 };
 
-static void eeepc_wmi_sysfs_exit(struct platform_device *device)
+static void asus_wmi_sysfs_exit(struct platform_device *device)
 {
 	sysfs_remove_group(&device->dev.kobj, &platform_attribute_group);
 }
 
-static int eeepc_wmi_sysfs_init(struct platform_device *device)
+static int asus_wmi_sysfs_init(struct platform_device *device)
 {
 	return sysfs_create_group(&device->dev.kobj, &platform_attribute_group);
 }
@@ -1098,111 +1058,111 @@ static int eeepc_wmi_sysfs_init(struct platform_device *device)
 /*
  * Platform device
  */
-static int __init eeepc_wmi_platform_init(struct eeepc_wmi *eeepc)
+static int __init asus_wmi_platform_init(struct asus_wmi *asus)
 {
-	return eeepc_wmi_sysfs_init(eeepc->platform_device);
+	return asus_wmi_sysfs_init(asus->platform_device);
 }
 
-static void eeepc_wmi_platform_exit(struct eeepc_wmi *eeepc)
+static void asus_wmi_platform_exit(struct asus_wmi *asus)
 {
-	eeepc_wmi_sysfs_exit(eeepc->platform_device);
+	asus_wmi_sysfs_exit(asus->platform_device);
 }
 
 /*
  * debugfs
  */
-struct eeepc_wmi_debugfs_node {
-	struct eeepc_wmi *eeepc;
+struct asus_wmi_debugfs_node {
+	struct asus_wmi *asus;
 	char *name;
-	int (*show)(struct seq_file *m, void *data);
+	int (*show) (struct seq_file *m, void *data);
 };
 
 static int show_dsts(struct seq_file *m, void *data)
 {
-	struct eeepc_wmi *eeepc = m->private;
+	struct asus_wmi *asus = m->private;
 	acpi_status status;
 	u32 retval = -1;
 
-	status = eeepc_wmi_get_devstate(eeepc->debug.dev_id, &retval);
+	status = asus_wmi_get_devstate(asus->debug.dev_id, &retval);
 
 	if (ACPI_FAILURE(status))
 		return -EIO;
 
-	seq_printf(m, "DSTS(%x) = %x\n", eeepc->debug.dev_id, retval);
+	seq_printf(m, "DSTS(%x) = %x\n", asus->debug.dev_id, retval);
 
 	return 0;
 }
 
 static int show_devs(struct seq_file *m, void *data)
 {
-	struct eeepc_wmi *eeepc = m->private;
+	struct asus_wmi *asus = m->private;
 	acpi_status status;
 	u32 retval = -1;
 
-	status = eeepc_wmi_set_devstate(eeepc->debug.dev_id,
-					eeepc->debug.ctrl_param, &retval);
+	status = asus_wmi_set_devstate(asus->debug.dev_id,
+				       asus->debug.ctrl_param, &retval);
 	if (ACPI_FAILURE(status))
 		return -EIO;
 
-	seq_printf(m, "DEVS(%x, %x) = %x\n", eeepc->debug.dev_id,
-		   eeepc->debug.ctrl_param, retval);
+	seq_printf(m, "DEVS(%x, %x) = %x\n", asus->debug.dev_id,
+		   asus->debug.ctrl_param, retval);
 
 	return 0;
 }
 
-static struct eeepc_wmi_debugfs_node eeepc_wmi_debug_files[] = {
-	{ NULL, "devs", show_devs },
-	{ NULL, "dsts", show_dsts },
+static struct asus_wmi_debugfs_node asus_wmi_debug_files[] = {
+	{NULL, "devs", show_devs},
+	{NULL, "dsts", show_dsts},
 };
 
-static int eeepc_wmi_debugfs_open(struct inode *inode, struct file *file)
+static int asus_wmi_debugfs_open(struct inode *inode, struct file *file)
 {
-	struct eeepc_wmi_debugfs_node *node = inode->i_private;
+	struct asus_wmi_debugfs_node *node = inode->i_private;
 
-	return single_open(file, node->show, node->eeepc);
+	return single_open(file, node->show, node->asus);
 }
 
-static const struct file_operations eeepc_wmi_debugfs_io_ops = {
+static const struct file_operations asus_wmi_debugfs_io_ops = {
 	.owner = THIS_MODULE,
-	.open  = eeepc_wmi_debugfs_open,
+	.open = asus_wmi_debugfs_open,
 	.read = seq_read,
 	.llseek = seq_lseek,
 	.release = single_release,
 };
 
-static void eeepc_wmi_debugfs_exit(struct eeepc_wmi *eeepc)
+static void asus_wmi_debugfs_exit(struct asus_wmi *asus)
 {
-	debugfs_remove_recursive(eeepc->debug.root);
+	debugfs_remove_recursive(asus->debug.root);
 }
 
-static int eeepc_wmi_debugfs_init(struct eeepc_wmi *eeepc)
+static int asus_wmi_debugfs_init(struct asus_wmi *asus)
 {
 	struct dentry *dent;
 	int i;
 
-	eeepc->debug.root = debugfs_create_dir(EEEPC_WMI_FILE, NULL);
-	if (!eeepc->debug.root) {
+	asus->debug.root = debugfs_create_dir(asus->driver->name, NULL);
+	if (!asus->debug.root) {
 		pr_err("failed to create debugfs directory");
 		goto error_debugfs;
 	}
 
-	dent = debugfs_create_x32("dev_id", S_IRUGO|S_IWUSR,
-				  eeepc->debug.root, &eeepc->debug.dev_id);
+	dent = debugfs_create_x32("dev_id", S_IRUGO | S_IWUSR,
+				  asus->debug.root, &asus->debug.dev_id);
 	if (!dent)
 		goto error_debugfs;
 
-	dent = debugfs_create_x32("ctrl_param", S_IRUGO|S_IWUSR,
-				  eeepc->debug.root, &eeepc->debug.ctrl_param);
+	dent = debugfs_create_x32("ctrl_param", S_IRUGO | S_IWUSR,
+				  asus->debug.root, &asus->debug.ctrl_param);
 	if (!dent)
 		goto error_debugfs;
 
-	for (i = 0; i < ARRAY_SIZE(eeepc_wmi_debug_files); i++) {
-		struct eeepc_wmi_debugfs_node *node = &eeepc_wmi_debug_files[i];
+	for (i = 0; i < ARRAY_SIZE(asus_wmi_debug_files); i++) {
+		struct asus_wmi_debugfs_node *node = &asus_wmi_debug_files[i];
 
-		node->eeepc = eeepc;
+		node->asus = asus;
 		dent = debugfs_create_file(node->name, S_IFREG | S_IRUGO,
-					   eeepc->debug.root, node,
-					   &eeepc_wmi_debugfs_io_ops);
+					   asus->debug.root, node,
+					   &asus_wmi_debugfs_io_ops);
 		if (!dent) {
 			pr_err("failed to create debug file: %s\n", node->name);
 			goto error_debugfs;
@@ -1212,131 +1172,112 @@ static int eeepc_wmi_debugfs_init(struct eeepc_wmi *eeepc)
 	return 0;
 
 error_debugfs:
-	eeepc_wmi_debugfs_exit(eeepc);
+	asus_wmi_debugfs_exit(asus);
 	return -ENOMEM;
 }
 
 /*
  * WMI Driver
  */
-static void eeepc_dmi_check(struct eeepc_wmi *eeepc)
+static int asus_wmi_add(struct platform_device *pdev)
 {
-	const char *model;
-
-	model = dmi_get_system_info(DMI_PRODUCT_NAME);
-	if (!model)
-		return;
-
-	/*
-	 * Whitelist for wlan hotplug
-	 *
-	 * Eeepc 1000H needs the current hotplug code to handle
-	 * Fn+F2 correctly. We may add other Eeepc here later, but
-	 * it seems that most of the laptops supported by eeepc-wmi
-	 * don't need to be on this list
-	 */
-	if (strcmp(model, "1000H") == 0) {
-		eeepc->hotplug_wireless = true;
-		pr_info("wlan hotplug enabled\n");
-	}
-}
-
-static int __init eeepc_wmi_add(struct platform_device *pdev)
-{
-	struct eeepc_wmi *eeepc;
+	struct platform_driver *pdrv = to_platform_driver(pdev->dev.driver);
+	struct asus_wmi_driver *wdrv = to_asus_wmi_driver(pdrv);
+	struct asus_wmi *asus;
 	acpi_status status;
 	int err;
 
-	eeepc = kzalloc(sizeof(struct eeepc_wmi), GFP_KERNEL);
-	if (!eeepc)
+	asus = kzalloc(sizeof(struct asus_wmi), GFP_KERNEL);
+	if (!asus)
 		return -ENOMEM;
 
-	eeepc->platform_device = pdev;
-	platform_set_drvdata(eeepc->platform_device, eeepc);
+	asus->driver = wdrv;
+	asus->platform_device = pdev;
+	wdrv->platform_device = pdev;
+	platform_set_drvdata(asus->platform_device, asus);
 
-	eeepc->hotplug_wireless = hotplug_wireless;
-	eeepc_dmi_check(eeepc);
+	if (wdrv->quirks)
+		wdrv->quirks(asus->driver);
 
-	err = eeepc_wmi_platform_init(eeepc);
+	err = asus_wmi_platform_init(asus);
 	if (err)
 		goto fail_platform;
 
-	err = eeepc_wmi_input_init(eeepc);
+	err = asus_wmi_input_init(asus);
 	if (err)
 		goto fail_input;
 
-	err = eeepc_wmi_led_init(eeepc);
+	err = asus_wmi_led_init(asus);
 	if (err)
 		goto fail_leds;
 
-	err = eeepc_wmi_rfkill_init(eeepc);
+	err = asus_wmi_rfkill_init(asus);
 	if (err)
 		goto fail_rfkill;
 
 	if (!acpi_video_backlight_support()) {
-		err = eeepc_wmi_backlight_init(eeepc);
+		err = asus_wmi_backlight_init(asus);
 		if (err && err != -ENODEV)
 			goto fail_backlight;
 	} else
 		pr_info("Backlight controlled by ACPI video driver\n");
 
-	status = wmi_install_notify_handler(EEEPC_WMI_EVENT_GUID,
-					    eeepc_wmi_notify, eeepc);
+	status = wmi_install_notify_handler(asus->driver->event_guid,
+					    asus_wmi_notify, asus);
 	if (ACPI_FAILURE(status)) {
-		pr_err("Unable to register notify handler - %d\n",
-			status);
+		pr_err("Unable to register notify handler - %d\n", status);
 		err = -ENODEV;
 		goto fail_wmi_handler;
 	}
 
-	err = eeepc_wmi_debugfs_init(eeepc);
+	err = asus_wmi_debugfs_init(asus);
 	if (err)
 		goto fail_debugfs;
 
 	return 0;
 
 fail_debugfs:
-	wmi_remove_notify_handler(EEEPC_WMI_EVENT_GUID);
+	wmi_remove_notify_handler(asus->driver->event_guid);
 fail_wmi_handler:
-	eeepc_wmi_backlight_exit(eeepc);
+	asus_wmi_backlight_exit(asus);
 fail_backlight:
-	eeepc_wmi_rfkill_exit(eeepc);
+	asus_wmi_rfkill_exit(asus);
 fail_rfkill:
-	eeepc_wmi_led_exit(eeepc);
+	asus_wmi_led_exit(asus);
 fail_leds:
-	eeepc_wmi_input_exit(eeepc);
+	asus_wmi_input_exit(asus);
 fail_input:
-	eeepc_wmi_platform_exit(eeepc);
+	asus_wmi_platform_exit(asus);
 fail_platform:
-	kfree(eeepc);
+	kfree(asus);
 	return err;
 }
 
-static int __exit eeepc_wmi_remove(struct platform_device *device)
+static int asus_wmi_remove(struct platform_device *device)
 {
-	struct eeepc_wmi *eeepc;
-
-	eeepc = platform_get_drvdata(device);
-	wmi_remove_notify_handler(EEEPC_WMI_EVENT_GUID);
-	eeepc_wmi_backlight_exit(eeepc);
-	eeepc_wmi_input_exit(eeepc);
-	eeepc_wmi_led_exit(eeepc);
-	eeepc_wmi_rfkill_exit(eeepc);
-	eeepc_wmi_debugfs_exit(eeepc);
-	eeepc_wmi_platform_exit(eeepc);
-
-	kfree(eeepc);
+	struct asus_wmi *asus;
+
+	asus = platform_get_drvdata(device);
+	wmi_remove_notify_handler(asus->driver->event_guid);
+	asus_wmi_backlight_exit(asus);
+	asus_wmi_input_exit(asus);
+	asus_wmi_led_exit(asus);
+	asus_wmi_rfkill_exit(asus);
+	asus_wmi_debugfs_exit(asus);
+	asus_wmi_platform_exit(asus);
+
+	kfree(asus);
 	return 0;
 }
 
 /*
  * Platform driver - hibernate/resume callbacks
  */
-static int eeepc_hotk_thaw(struct device *device)
+static int asus_hotk_thaw(struct device *device)
 {
-	struct eeepc_wmi *eeepc = dev_get_drvdata(device);
+	struct asus_wmi *asus = dev_get_drvdata(device);
 
-	if (eeepc->wlan_rfkill) {
+	if (asus->wlan_rfkill) {
 		bool wlan;
 
 		/*
@@ -1344,111 +1285,118 @@ static int eeepc_hotk_thaw(struct device *device)
 		 * during suspend.  Normally it restores it on resume, but
 		 * we should kick it ourselves in case hibernation is aborted.
 		 */
-		wlan = eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_WLAN);
-		eeepc_wmi_set_devstate(EEEPC_WMI_DEVID_WLAN, wlan, NULL);
+		wlan = asus_wmi_get_devstate_simple(ASUS_WMI_DEVID_WLAN);
+		asus_wmi_set_devstate(ASUS_WMI_DEVID_WLAN, wlan, NULL);
 	}
 
 	return 0;
 }
 
-static int eeepc_hotk_restore(struct device *device)
+static int asus_hotk_restore(struct device *device)
 {
-	struct eeepc_wmi *eeepc = dev_get_drvdata(device);
+	struct asus_wmi *asus = dev_get_drvdata(device);
 	int bl;
 
 	/* Refresh both wlan rfkill state and pci hotplug */
-	if (eeepc->wlan_rfkill)
-		eeepc_rfkill_hotplug(eeepc);
+	if (asus->wlan_rfkill)
+		asus_rfkill_hotplug(asus);
 
-	if (eeepc->bluetooth_rfkill) {
-		bl = !eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_BLUETOOTH);
-		rfkill_set_sw_state(eeepc->bluetooth_rfkill, bl);
+	if (asus->bluetooth_rfkill) {
+		bl = !asus_wmi_get_devstate_simple(ASUS_WMI_DEVID_BLUETOOTH);
+		rfkill_set_sw_state(asus->bluetooth_rfkill, bl);
 	}
-	if (eeepc->wimax_rfkill) {
-		bl = !eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_WIMAX);
-		rfkill_set_sw_state(eeepc->wimax_rfkill, bl);
+	if (asus->wimax_rfkill) {
+		bl = !asus_wmi_get_devstate_simple(ASUS_WMI_DEVID_WIMAX);
+		rfkill_set_sw_state(asus->wimax_rfkill, bl);
 	}
-	if (eeepc->wwan3g_rfkill) {
-		bl = !eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_WWAN3G);
-		rfkill_set_sw_state(eeepc->wwan3g_rfkill, bl);
+	if (asus->wwan3g_rfkill) {
+		bl = !asus_wmi_get_devstate_simple(ASUS_WMI_DEVID_WWAN3G);
+		rfkill_set_sw_state(asus->wwan3g_rfkill, bl);
 	}
 
 	return 0;
 }
 
-static const struct dev_pm_ops eeepc_pm_ops = {
-	.thaw = eeepc_hotk_thaw,
-	.restore = eeepc_hotk_restore,
-};
-
-static struct platform_driver platform_driver = {
-	.remove = __exit_p(eeepc_wmi_remove),
-	.driver = {
-		.name = EEEPC_WMI_FILE,
-		.owner = THIS_MODULE,
-		.pm = &eeepc_pm_ops,
-	},
+static const struct dev_pm_ops asus_pm_ops = {
+	.thaw = asus_hotk_thaw,
+	.restore = asus_hotk_restore,
 };
 
-static acpi_status __init eeepc_wmi_parse_device(acpi_handle handle, u32 level,
-						 void *context, void **retval)
+static int asus_wmi_probe(struct platform_device *pdev)
 {
-	pr_warning("Found legacy ATKD device (%s)", EEEPC_ACPI_HID);
-	*(bool *)context = true;
-	return AE_CTRL_TERMINATE;
-}
-
-static int __init eeepc_wmi_check_atkd(void)
-{
-	acpi_status status;
-	bool found = false;
-
-	status = acpi_get_devices(EEEPC_ACPI_HID, eeepc_wmi_parse_device,
-				  &found, NULL);
-
-	if (ACPI_FAILURE(status) || !found)
-		return 0;
-	return -1;
-}
+	struct platform_driver *pdrv = to_platform_driver(pdev->dev.driver);
+	struct asus_wmi_driver *wdrv = to_asus_wmi_driver(pdrv);
+	int ret;
 
-static int __init eeepc_wmi_probe(struct platform_device *pdev)
-{
-	if (!wmi_has_guid(EEEPC_WMI_EVENT_GUID) ||
-	    !wmi_has_guid(EEEPC_WMI_MGMT_GUID)) {
-		pr_warning("No known WMI GUID found\n");
+	if (!wmi_has_guid(ASUS_WMI_MGMT_GUID)) {
+		pr_warning("Management GUID not found\n");
 		return -ENODEV;
 	}
 
-	if (eeepc_wmi_check_atkd()) {
-		pr_warning("WMI device present, but legacy ATKD device is also "
-			   "present and enabled.");
-		pr_warning("You probably booted with acpi_osi=\"Linux\" or "
-			   "acpi_osi=\"!Windows 2009\"");
-		pr_warning("Can't load eeepc-wmi, use default acpi_osi "
-			   "(preferred) or eeepc-laptop");
+	if (wdrv->event_guid && !wmi_has_guid(wdrv->event_guid)) {
+		pr_warning("Event GUID not found\n");
 		return -ENODEV;
 	}
 
-	return eeepc_wmi_add(pdev);
+	if (wdrv->probe) {
+		ret = wdrv->probe(pdev);
+		if (ret)
+			return ret;
+	}
+
+	return asus_wmi_add(pdev);
 }
 
-static struct platform_device *platform_device;
+static bool used;
 
-static int __init eeepc_wmi_init(void)
+int asus_wmi_register_driver(struct asus_wmi_driver *driver)
 {
-	platform_device = platform_create_bundle(&platform_driver,
-						 eeepc_wmi_probe,
+	struct platform_driver *platform_driver;
+	struct platform_device *platform_device;
+
+	if (used)
+		return -EBUSY;
+
+	platform_driver = &driver->platform_driver;
+	platform_driver->remove = asus_wmi_remove;
+	platform_driver->driver.owner = driver->owner;
+	platform_driver->driver.name = driver->name;
+	platform_driver->driver.pm = &asus_pm_ops;
+
+	platform_device = platform_create_bundle(platform_driver,
+						 asus_wmi_probe,
 						 NULL, 0, NULL, 0);
 	if (IS_ERR(platform_device))
 		return PTR_ERR(platform_device);
+
+	used = true;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(asus_wmi_register_driver);
+
+void asus_wmi_unregister_driver(struct asus_wmi_driver *driver)
+{
+	platform_device_unregister(driver->platform_device);
+	platform_driver_unregister(&driver->platform_driver);
+	used = false;
+}
+EXPORT_SYMBOL_GPL(asus_wmi_unregister_driver);
+
+static int __init asus_wmi_init(void)
+{
+	if (!wmi_has_guid(ASUS_WMI_MGMT_GUID)) {
+		pr_info("Asus Management GUID not found");
+		return -ENODEV;
+	}
+
+	pr_info("ASUS WMI generic driver loaded");
 	return 0;
 }
 
-static void __exit eeepc_wmi_exit(void)
+static void __exit asus_wmi_exit(void)
 {
-	platform_device_unregister(platform_device);
-	platform_driver_unregister(&platform_driver);
+	pr_info("ASUS WMI generic driver unloaded");
 }
 
-module_init(eeepc_wmi_init);
-module_exit(eeepc_wmi_exit);
+module_init(asus_wmi_init);
+module_exit(asus_wmi_exit);

commit 5b799d4fb787bb94f1068352220ab033ac7969f8
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sat Feb 26 10:20:30 2011 +0100

    asus-wmi: move generic code to asus-wmi
    
    New Asus notebooks are using a WMI device similar to
    the one used in Eee PCs. Since we don't want to load
    a module named eeepc-laptop on Asus Notebooks, start by
    copying all the code to asus-wmi.c.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
new file mode 100644
index 000000000000..d3997757e790
--- /dev/null
+++ b/drivers/platform/x86/asus-wmi.c
@@ -0,0 +1,1454 @@
+/*
+ * Eee PC WMI hotkey driver
+ *
+ * Copyright(C) 2010 Intel Corporation.
+ * Copyright(C) 2010 Corentin Chary <corentin.chary@gmail.com>
+ *
+ * Portions based on wistron_btns.c:
+ * Copyright (C) 2005 Miloslav Trmac <mitr@volny.cz>
+ * Copyright (C) 2005 Bernhard Rosenkraenzer <bero@arklinux.org>
+ * Copyright (C) 2005 Dmitry Torokhov <dtor@mail.ru>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/input/sparse-keymap.h>
+#include <linux/fb.h>
+#include <linux/backlight.h>
+#include <linux/leds.h>
+#include <linux/rfkill.h>
+#include <linux/pci.h>
+#include <linux/pci_hotplug.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/platform_device.h>
+#include <linux/dmi.h>
+#include <acpi/acpi_bus.h>
+#include <acpi/acpi_drivers.h>
+
+#define	EEEPC_WMI_FILE	"eeepc-wmi"
+
+MODULE_AUTHOR("Yong Wang <yong.y.wang@intel.com>");
+MODULE_DESCRIPTION("Eee PC WMI Hotkey Driver");
+MODULE_LICENSE("GPL");
+
+#define EEEPC_ACPI_HID		"ASUS010" /* old _HID used in eeepc-laptop */
+
+#define EEEPC_WMI_EVENT_GUID	"ABBC0F72-8EA1-11D1-00A0-C90629100000"
+#define EEEPC_WMI_MGMT_GUID	"97845ED0-4E6D-11DE-8A39-0800200C9A66"
+
+MODULE_ALIAS("wmi:"EEEPC_WMI_EVENT_GUID);
+MODULE_ALIAS("wmi:"EEEPC_WMI_MGMT_GUID);
+
+#define NOTIFY_BRNUP_MIN		0x11
+#define NOTIFY_BRNUP_MAX		0x1f
+#define NOTIFY_BRNDOWN_MIN		0x20
+#define NOTIFY_BRNDOWN_MAX		0x2e
+
+/* WMI Methods */
+#define EEEPC_WMI_METHODID_DSTS		0x53544344
+#define EEEPC_WMI_METHODID_DEVS		0x53564544
+#define EEEPC_WMI_METHODID_CFVS		0x53564643
+
+/* Wireless */
+#define EEEPC_WMI_DEVID_WLAN		0x00010011
+#define EEEPC_WMI_DEVID_BLUETOOTH	0x00010013
+#define EEEPC_WMI_DEVID_WIMAX		0x00010017
+#define EEEPC_WMI_DEVID_WWAN3G		0x00010019
+
+/* Backlight and Brightness */
+#define EEEPC_WMI_DEVID_BACKLIGHT	0x00050011
+#define EEEPC_WMI_DEVID_BRIGHTNESS	0x00050012
+
+/* Misc */
+#define EEEPC_WMI_DEVID_CAMERA		0x00060013
+
+/* Storage */
+#define EEEPC_WMI_DEVID_CARDREADER	0x00080013
+
+/* Input */
+#define EEEPC_WMI_DEVID_TOUCHPAD	0x00100011
+#define EEEPC_WMI_DEVID_TOUCHPAD_LED	0x00100012
+
+/* DSTS masks */
+#define EEEPC_WMI_DSTS_STATUS_BIT	0x00000001
+#define EEEPC_WMI_DSTS_PRESENCE_BIT	0x00010000
+#define EEEPC_WMI_DSTS_BRIGHTNESS_MASK	0x000000FF
+#define EEEPC_WMI_DSTS_MAX_BRIGTH_MASK	0x0000FF00
+
+static bool hotplug_wireless;
+
+module_param(hotplug_wireless, bool, 0444);
+MODULE_PARM_DESC(hotplug_wireless,
+		 "Enable hotplug for wireless device. "
+		 "If your laptop needs that, please report to "
+		 "acpi4asus-user@lists.sourceforge.net.");
+
+static const struct key_entry eeepc_wmi_keymap[] = {
+	/* Sleep already handled via generic ACPI code */
+	{ KE_IGNORE, NOTIFY_BRNDOWN_MIN, { KEY_BRIGHTNESSDOWN } },
+	{ KE_IGNORE, NOTIFY_BRNUP_MIN, { KEY_BRIGHTNESSUP } },
+	{ KE_KEY, 0x30, { KEY_VOLUMEUP } },
+	{ KE_KEY, 0x31, { KEY_VOLUMEDOWN } },
+	{ KE_KEY, 0x32, { KEY_MUTE } },
+	{ KE_KEY, 0x5c, { KEY_F15 } }, /* Power Gear key */
+	{ KE_KEY, 0x5d, { KEY_WLAN } },
+	{ KE_KEY, 0x6b, { KEY_F13 } }, /* Disable Touchpad */
+	{ KE_KEY, 0x82, { KEY_CAMERA } },
+	{ KE_KEY, 0x83, { KEY_CAMERA_ZOOMIN } },
+	{ KE_KEY, 0x88, { KEY_WLAN } },
+	{ KE_KEY, 0xcc, { KEY_SWITCHVIDEOMODE } },
+	{ KE_KEY, 0xe0, { KEY_PROG1 } }, /* Task Manager */
+	{ KE_KEY, 0xe1, { KEY_F14 } }, /* Change Resolution */
+	{ KE_KEY, 0xe9, { KEY_BRIGHTNESS_ZERO } },
+	{ KE_KEY, 0xeb, { KEY_CAMERA_ZOOMOUT } },
+	{ KE_KEY, 0xec, { KEY_CAMERA_UP } },
+	{ KE_KEY, 0xed, { KEY_CAMERA_DOWN } },
+	{ KE_KEY, 0xee, { KEY_CAMERA_LEFT } },
+	{ KE_KEY, 0xef, { KEY_CAMERA_RIGHT } },
+	{ KE_END, 0},
+};
+
+struct bios_args {
+	u32	dev_id;
+	u32	ctrl_param;
+};
+
+/*
+ * eeepc-wmi/    - debugfs root directory
+ *   dev_id      - current dev_id
+ *   ctrl_param  - current ctrl_param
+ *   devs        - call DEVS(dev_id, ctrl_param) and print result
+ *   dsts        - call DSTS(dev_id)  and print result
+ */
+struct eeepc_wmi_debug {
+	struct dentry *root;
+	u32 dev_id;
+	u32 ctrl_param;
+};
+
+struct eeepc_wmi {
+	bool hotplug_wireless;
+
+	struct input_dev *inputdev;
+	struct backlight_device *backlight_device;
+	struct platform_device *platform_device;
+
+	struct led_classdev tpd_led;
+	int tpd_led_wk;
+	struct workqueue_struct *led_workqueue;
+	struct work_struct tpd_led_work;
+
+	struct rfkill *wlan_rfkill;
+	struct rfkill *bluetooth_rfkill;
+	struct rfkill *wimax_rfkill;
+	struct rfkill *wwan3g_rfkill;
+
+	struct hotplug_slot *hotplug_slot;
+	struct mutex hotplug_lock;
+	struct mutex wmi_lock;
+	struct workqueue_struct *hotplug_workqueue;
+	struct work_struct hotplug_work;
+
+	struct eeepc_wmi_debug debug;
+};
+
+static int eeepc_wmi_input_init(struct eeepc_wmi *eeepc)
+{
+	int err;
+
+	eeepc->inputdev = input_allocate_device();
+	if (!eeepc->inputdev)
+		return -ENOMEM;
+
+	eeepc->inputdev->name = "Eee PC WMI hotkeys";
+	eeepc->inputdev->phys = EEEPC_WMI_FILE "/input0";
+	eeepc->inputdev->id.bustype = BUS_HOST;
+	eeepc->inputdev->dev.parent = &eeepc->platform_device->dev;
+
+	err = sparse_keymap_setup(eeepc->inputdev, eeepc_wmi_keymap, NULL);
+	if (err)
+		goto err_free_dev;
+
+	err = input_register_device(eeepc->inputdev);
+	if (err)
+		goto err_free_keymap;
+
+	return 0;
+
+err_free_keymap:
+	sparse_keymap_free(eeepc->inputdev);
+err_free_dev:
+	input_free_device(eeepc->inputdev);
+	return err;
+}
+
+static void eeepc_wmi_input_exit(struct eeepc_wmi *eeepc)
+{
+	if (eeepc->inputdev) {
+		sparse_keymap_free(eeepc->inputdev);
+		input_unregister_device(eeepc->inputdev);
+	}
+
+	eeepc->inputdev = NULL;
+}
+
+static acpi_status eeepc_wmi_get_devstate(u32 dev_id, u32 *retval)
+{
+	struct acpi_buffer input = { (acpi_size)sizeof(u32), &dev_id };
+	struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *obj;
+	acpi_status status;
+	u32 tmp;
+
+	status = wmi_evaluate_method(EEEPC_WMI_MGMT_GUID,
+				     1, EEEPC_WMI_METHODID_DSTS,
+				     &input, &output);
+
+	if (ACPI_FAILURE(status))
+		return status;
+
+	obj = (union acpi_object *)output.pointer;
+	if (obj && obj->type == ACPI_TYPE_INTEGER)
+		tmp = (u32)obj->integer.value;
+	else
+		tmp = 0;
+
+	if (retval)
+		*retval = tmp;
+
+	kfree(obj);
+
+	return status;
+
+}
+
+static acpi_status eeepc_wmi_set_devstate(u32 dev_id, u32 ctrl_param,
+					  u32 *retval)
+{
+	struct bios_args args = {
+		.dev_id = dev_id,
+		.ctrl_param = ctrl_param,
+	};
+	struct acpi_buffer input = { (acpi_size)sizeof(args), &args };
+	acpi_status status;
+
+	if (!retval) {
+		status = wmi_evaluate_method(EEEPC_WMI_MGMT_GUID, 1,
+					     EEEPC_WMI_METHODID_DEVS,
+					     &input, NULL);
+	} else {
+		struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
+		union acpi_object *obj;
+		u32 tmp;
+
+		status = wmi_evaluate_method(EEEPC_WMI_MGMT_GUID, 1,
+					     EEEPC_WMI_METHODID_DEVS,
+					     &input, &output);
+
+		if (ACPI_FAILURE(status))
+			return status;
+
+		obj = (union acpi_object *)output.pointer;
+		if (obj && obj->type == ACPI_TYPE_INTEGER)
+			tmp = (u32)obj->integer.value;
+		else
+			tmp = 0;
+
+		*retval = tmp;
+
+		kfree(obj);
+	}
+
+	return status;
+}
+
+/* Helper for special devices with magic return codes */
+static int eeepc_wmi_get_devstate_bits(u32 dev_id, u32 mask)
+{
+	u32 retval = 0;
+	acpi_status status;
+
+	status = eeepc_wmi_get_devstate(dev_id, &retval);
+
+	if (ACPI_FAILURE(status))
+		return -EINVAL;
+
+	if (!(retval & EEEPC_WMI_DSTS_PRESENCE_BIT))
+		return -ENODEV;
+
+	return retval & mask;
+}
+
+static int eeepc_wmi_get_devstate_simple(u32 dev_id)
+{
+	return eeepc_wmi_get_devstate_bits(dev_id, EEEPC_WMI_DSTS_STATUS_BIT);
+}
+
+/*
+ * LEDs
+ */
+/*
+ * These functions actually update the LED's, and are called from a
+ * workqueue. By doing this as separate work rather than when the LED
+ * subsystem asks, we avoid messing with the Eeepc ACPI stuff during a
+ * potentially bad time, such as a timer interrupt.
+ */
+static void tpd_led_update(struct work_struct *work)
+{
+	int ctrl_param;
+	struct eeepc_wmi *eeepc;
+
+	eeepc = container_of(work, struct eeepc_wmi, tpd_led_work);
+
+	ctrl_param = eeepc->tpd_led_wk;
+	eeepc_wmi_set_devstate(EEEPC_WMI_DEVID_TOUCHPAD_LED, ctrl_param, NULL);
+}
+
+static void tpd_led_set(struct led_classdev *led_cdev,
+			enum led_brightness value)
+{
+	struct eeepc_wmi *eeepc;
+
+	eeepc = container_of(led_cdev, struct eeepc_wmi, tpd_led);
+
+	eeepc->tpd_led_wk = !!value;
+	queue_work(eeepc->led_workqueue, &eeepc->tpd_led_work);
+}
+
+static int read_tpd_led_state(struct eeepc_wmi *eeepc)
+{
+	return eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_TOUCHPAD_LED);
+}
+
+static enum led_brightness tpd_led_get(struct led_classdev *led_cdev)
+{
+	struct eeepc_wmi *eeepc;
+
+	eeepc = container_of(led_cdev, struct eeepc_wmi, tpd_led);
+
+	return read_tpd_led_state(eeepc);
+}
+
+static int eeepc_wmi_led_init(struct eeepc_wmi *eeepc)
+{
+	int rv;
+
+	if (read_tpd_led_state(eeepc) < 0)
+		return 0;
+
+	eeepc->led_workqueue = create_singlethread_workqueue("led_workqueue");
+	if (!eeepc->led_workqueue)
+		return -ENOMEM;
+	INIT_WORK(&eeepc->tpd_led_work, tpd_led_update);
+
+	eeepc->tpd_led.name = "eeepc::touchpad";
+	eeepc->tpd_led.brightness_set = tpd_led_set;
+	eeepc->tpd_led.brightness_get = tpd_led_get;
+	eeepc->tpd_led.max_brightness = 1;
+
+	rv = led_classdev_register(&eeepc->platform_device->dev,
+				   &eeepc->tpd_led);
+	if (rv) {
+		destroy_workqueue(eeepc->led_workqueue);
+		return rv;
+	}
+
+	return 0;
+}
+
+static void eeepc_wmi_led_exit(struct eeepc_wmi *eeepc)
+{
+	if (eeepc->tpd_led.dev)
+		led_classdev_unregister(&eeepc->tpd_led);
+	if (eeepc->led_workqueue)
+		destroy_workqueue(eeepc->led_workqueue);
+}
+
+/*
+ * PCI hotplug (for wlan rfkill)
+ */
+static bool eeepc_wlan_rfkill_blocked(struct eeepc_wmi *eeepc)
+{
+	int result = eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_WLAN);
+
+	if (result < 0)
+		return false;
+	return !result;
+}
+
+static void eeepc_rfkill_hotplug(struct eeepc_wmi *eeepc)
+{
+	struct pci_dev *dev;
+	struct pci_bus *bus;
+	bool blocked;
+	bool absent;
+	u32 l;
+
+	mutex_lock(&eeepc->wmi_lock);
+	blocked = eeepc_wlan_rfkill_blocked(eeepc);
+	mutex_unlock(&eeepc->wmi_lock);
+
+	mutex_lock(&eeepc->hotplug_lock);
+
+	if (eeepc->wlan_rfkill)
+		rfkill_set_sw_state(eeepc->wlan_rfkill, blocked);
+
+	if (eeepc->hotplug_slot) {
+		bus = pci_find_bus(0, 1);
+		if (!bus) {
+			pr_warning("Unable to find PCI bus 1?\n");
+			goto out_unlock;
+		}
+
+		if (pci_bus_read_config_dword(bus, 0, PCI_VENDOR_ID, &l)) {
+			pr_err("Unable to read PCI config space?\n");
+			goto out_unlock;
+		}
+		absent = (l == 0xffffffff);
+
+		if (blocked != absent) {
+			pr_warning("BIOS says wireless lan is %s, "
+					"but the pci device is %s\n",
+				blocked ? "blocked" : "unblocked",
+				absent ? "absent" : "present");
+			pr_warning("skipped wireless hotplug as probably "
+					"inappropriate for this model\n");
+			goto out_unlock;
+		}
+
+		if (!blocked) {
+			dev = pci_get_slot(bus, 0);
+			if (dev) {
+				/* Device already present */
+				pci_dev_put(dev);
+				goto out_unlock;
+			}
+			dev = pci_scan_single_device(bus, 0);
+			if (dev) {
+				pci_bus_assign_resources(bus);
+				if (pci_bus_add_device(dev))
+					pr_err("Unable to hotplug wifi\n");
+			}
+		} else {
+			dev = pci_get_slot(bus, 0);
+			if (dev) {
+				pci_remove_bus_device(dev);
+				pci_dev_put(dev);
+			}
+		}
+	}
+
+out_unlock:
+	mutex_unlock(&eeepc->hotplug_lock);
+}
+
+static void eeepc_rfkill_notify(acpi_handle handle, u32 event, void *data)
+{
+	struct eeepc_wmi *eeepc = data;
+
+	if (event != ACPI_NOTIFY_BUS_CHECK)
+		return;
+
+	/*
+	 * We can't call directly eeepc_rfkill_hotplug because most
+	 * of the time WMBC is still being executed and not reetrant.
+	 * There is currently no way to tell ACPICA that  we want this
+	 * method to be serialized, we schedule a eeepc_rfkill_hotplug
+	 * call later, in a safer context.
+	 */
+	queue_work(eeepc->hotplug_workqueue, &eeepc->hotplug_work);
+}
+
+static int eeepc_register_rfkill_notifier(struct eeepc_wmi *eeepc,
+					  char *node)
+{
+	acpi_status status;
+	acpi_handle handle;
+
+	status = acpi_get_handle(NULL, node, &handle);
+
+	if (ACPI_SUCCESS(status)) {
+		status = acpi_install_notify_handler(handle,
+						     ACPI_SYSTEM_NOTIFY,
+						     eeepc_rfkill_notify,
+						     eeepc);
+		if (ACPI_FAILURE(status))
+			pr_warning("Failed to register notify on %s\n", node);
+	} else
+		return -ENODEV;
+
+	return 0;
+}
+
+static void eeepc_unregister_rfkill_notifier(struct eeepc_wmi *eeepc,
+					     char *node)
+{
+	acpi_status status = AE_OK;
+	acpi_handle handle;
+
+	status = acpi_get_handle(NULL, node, &handle);
+
+	if (ACPI_SUCCESS(status)) {
+		status = acpi_remove_notify_handler(handle,
+						     ACPI_SYSTEM_NOTIFY,
+						     eeepc_rfkill_notify);
+		if (ACPI_FAILURE(status))
+			pr_err("Error removing rfkill notify handler %s\n",
+				node);
+	}
+}
+
+static int eeepc_get_adapter_status(struct hotplug_slot *hotplug_slot,
+				    u8 *value)
+{
+	int result = eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_WLAN);
+
+	if (result < 0)
+		return result;
+
+	*value = !!result;
+	return 0;
+}
+
+static void eeepc_cleanup_pci_hotplug(struct hotplug_slot *hotplug_slot)
+{
+	kfree(hotplug_slot->info);
+	kfree(hotplug_slot);
+}
+
+static struct hotplug_slot_ops eeepc_hotplug_slot_ops = {
+	.owner = THIS_MODULE,
+	.get_adapter_status = eeepc_get_adapter_status,
+	.get_power_status = eeepc_get_adapter_status,
+};
+
+static void eeepc_hotplug_work(struct work_struct *work)
+{
+	struct eeepc_wmi *eeepc;
+
+	eeepc = container_of(work, struct eeepc_wmi, hotplug_work);
+	eeepc_rfkill_hotplug(eeepc);
+}
+
+static int eeepc_setup_pci_hotplug(struct eeepc_wmi *eeepc)
+{
+	int ret = -ENOMEM;
+	struct pci_bus *bus = pci_find_bus(0, 1);
+
+	if (!bus) {
+		pr_err("Unable to find wifi PCI bus\n");
+		return -ENODEV;
+	}
+
+	eeepc->hotplug_workqueue =
+		create_singlethread_workqueue("hotplug_workqueue");
+	if (!eeepc->hotplug_workqueue)
+		goto error_workqueue;
+
+	INIT_WORK(&eeepc->hotplug_work, eeepc_hotplug_work);
+
+	eeepc->hotplug_slot = kzalloc(sizeof(struct hotplug_slot), GFP_KERNEL);
+	if (!eeepc->hotplug_slot)
+		goto error_slot;
+
+	eeepc->hotplug_slot->info = kzalloc(sizeof(struct hotplug_slot_info),
+					    GFP_KERNEL);
+	if (!eeepc->hotplug_slot->info)
+		goto error_info;
+
+	eeepc->hotplug_slot->private = eeepc;
+	eeepc->hotplug_slot->release = &eeepc_cleanup_pci_hotplug;
+	eeepc->hotplug_slot->ops = &eeepc_hotplug_slot_ops;
+	eeepc_get_adapter_status(eeepc->hotplug_slot,
+				 &eeepc->hotplug_slot->info->adapter_status);
+
+	ret = pci_hp_register(eeepc->hotplug_slot, bus, 0, "eeepc-wifi");
+	if (ret) {
+		pr_err("Unable to register hotplug slot - %d\n", ret);
+		goto error_register;
+	}
+
+	return 0;
+
+error_register:
+	kfree(eeepc->hotplug_slot->info);
+error_info:
+	kfree(eeepc->hotplug_slot);
+	eeepc->hotplug_slot = NULL;
+error_slot:
+	destroy_workqueue(eeepc->hotplug_workqueue);
+error_workqueue:
+	return ret;
+}
+
+/*
+ * Rfkill devices
+ */
+static int eeepc_rfkill_set(void *data, bool blocked)
+{
+	int dev_id = (unsigned long)data;
+	u32 ctrl_param = !blocked;
+	acpi_status status;
+
+	status = eeepc_wmi_set_devstate(dev_id, ctrl_param, NULL);
+
+	if (ACPI_FAILURE(status))
+		return -EIO;
+
+	return 0;
+}
+
+static void eeepc_rfkill_query(struct rfkill *rfkill, void *data)
+{
+	int dev_id = (unsigned long)data;
+	int result;
+
+	result = eeepc_wmi_get_devstate_simple(dev_id);
+
+	if (result < 0)
+		return ;
+
+	rfkill_set_sw_state(rfkill, !result);
+}
+
+static int eeepc_rfkill_wlan_set(void *data, bool blocked)
+{
+	struct eeepc_wmi *eeepc = data;
+	int ret;
+
+	/*
+	 * This handler is enabled only if hotplug is enabled.
+	 * In this case, the eeepc_wmi_set_devstate() will
+	 * trigger a wmi notification and we need to wait
+	 * this call to finish before being able to call
+	 * any wmi method
+	 */
+	mutex_lock(&eeepc->wmi_lock);
+	ret = eeepc_rfkill_set((void *)(long)EEEPC_WMI_DEVID_WLAN, blocked);
+	mutex_unlock(&eeepc->wmi_lock);
+	return ret;
+}
+
+static void eeepc_rfkill_wlan_query(struct rfkill *rfkill, void *data)
+{
+	eeepc_rfkill_query(rfkill, (void *)(long)EEEPC_WMI_DEVID_WLAN);
+}
+
+static const struct rfkill_ops eeepc_rfkill_wlan_ops = {
+	.set_block = eeepc_rfkill_wlan_set,
+	.query = eeepc_rfkill_wlan_query,
+};
+
+static const struct rfkill_ops eeepc_rfkill_ops = {
+	.set_block = eeepc_rfkill_set,
+	.query = eeepc_rfkill_query,
+};
+
+static int eeepc_new_rfkill(struct eeepc_wmi *eeepc,
+			    struct rfkill **rfkill,
+			    const char *name,
+			    enum rfkill_type type, int dev_id)
+{
+	int result = eeepc_wmi_get_devstate_simple(dev_id);
+
+	if (result < 0)
+		return result;
+
+	if (dev_id == EEEPC_WMI_DEVID_WLAN && eeepc->hotplug_wireless)
+		*rfkill = rfkill_alloc(name, &eeepc->platform_device->dev, type,
+				       &eeepc_rfkill_wlan_ops, eeepc);
+	else
+		*rfkill = rfkill_alloc(name, &eeepc->platform_device->dev, type,
+				       &eeepc_rfkill_ops, (void *)(long)dev_id);
+
+	if (!*rfkill)
+		return -EINVAL;
+
+	rfkill_init_sw_state(*rfkill, !result);
+	result = rfkill_register(*rfkill);
+	if (result) {
+		rfkill_destroy(*rfkill);
+		*rfkill = NULL;
+		return result;
+	}
+	return 0;
+}
+
+static void eeepc_wmi_rfkill_exit(struct eeepc_wmi *eeepc)
+{
+	eeepc_unregister_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P5");
+	eeepc_unregister_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P6");
+	eeepc_unregister_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P7");
+	if (eeepc->wlan_rfkill) {
+		rfkill_unregister(eeepc->wlan_rfkill);
+		rfkill_destroy(eeepc->wlan_rfkill);
+		eeepc->wlan_rfkill = NULL;
+	}
+	/*
+	 * Refresh pci hotplug in case the rfkill state was changed after
+	 * eeepc_unregister_rfkill_notifier()
+	 */
+	eeepc_rfkill_hotplug(eeepc);
+	if (eeepc->hotplug_slot)
+		pci_hp_deregister(eeepc->hotplug_slot);
+	if (eeepc->hotplug_workqueue)
+		destroy_workqueue(eeepc->hotplug_workqueue);
+
+	if (eeepc->bluetooth_rfkill) {
+		rfkill_unregister(eeepc->bluetooth_rfkill);
+		rfkill_destroy(eeepc->bluetooth_rfkill);
+		eeepc->bluetooth_rfkill = NULL;
+	}
+	if (eeepc->wimax_rfkill) {
+		rfkill_unregister(eeepc->wimax_rfkill);
+		rfkill_destroy(eeepc->wimax_rfkill);
+		eeepc->wimax_rfkill = NULL;
+	}
+	if (eeepc->wwan3g_rfkill) {
+		rfkill_unregister(eeepc->wwan3g_rfkill);
+		rfkill_destroy(eeepc->wwan3g_rfkill);
+		eeepc->wwan3g_rfkill = NULL;
+	}
+}
+
+static int eeepc_wmi_rfkill_init(struct eeepc_wmi *eeepc)
+{
+	int result = 0;
+
+	mutex_init(&eeepc->hotplug_lock);
+	mutex_init(&eeepc->wmi_lock);
+
+	result = eeepc_new_rfkill(eeepc, &eeepc->wlan_rfkill,
+				  "eeepc-wlan", RFKILL_TYPE_WLAN,
+				  EEEPC_WMI_DEVID_WLAN);
+
+	if (result && result != -ENODEV)
+		goto exit;
+
+	result = eeepc_new_rfkill(eeepc, &eeepc->bluetooth_rfkill,
+				  "eeepc-bluetooth", RFKILL_TYPE_BLUETOOTH,
+				  EEEPC_WMI_DEVID_BLUETOOTH);
+
+	if (result && result != -ENODEV)
+		goto exit;
+
+	result = eeepc_new_rfkill(eeepc, &eeepc->wimax_rfkill,
+				  "eeepc-wimax", RFKILL_TYPE_WIMAX,
+				  EEEPC_WMI_DEVID_WIMAX);
+
+	if (result && result != -ENODEV)
+		goto exit;
+
+	result = eeepc_new_rfkill(eeepc, &eeepc->wwan3g_rfkill,
+				  "eeepc-wwan3g", RFKILL_TYPE_WWAN,
+				  EEEPC_WMI_DEVID_WWAN3G);
+
+	if (result && result != -ENODEV)
+		goto exit;
+
+	if (!eeepc->hotplug_wireless)
+		goto exit;
+
+	result = eeepc_setup_pci_hotplug(eeepc);
+	/*
+	 * If we get -EBUSY then something else is handling the PCI hotplug -
+	 * don't fail in this case
+	 */
+	if (result == -EBUSY)
+		result = 0;
+
+	eeepc_register_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P5");
+	eeepc_register_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P6");
+	eeepc_register_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P7");
+	/*
+	 * Refresh pci hotplug in case the rfkill state was changed during
+	 * setup.
+	 */
+	eeepc_rfkill_hotplug(eeepc);
+
+exit:
+	if (result && result != -ENODEV)
+		eeepc_wmi_rfkill_exit(eeepc);
+
+	if (result == -ENODEV)
+		result = 0;
+
+	return result;
+}
+
+/*
+ * Backlight
+ */
+static int read_backlight_power(void)
+{
+	int ret = eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_BACKLIGHT);
+
+	if (ret < 0)
+		return ret;
+
+	return ret ? FB_BLANK_UNBLANK : FB_BLANK_POWERDOWN;
+}
+
+static int read_brightness(struct backlight_device *bd)
+{
+	u32 retval;
+	acpi_status status;
+
+	status = eeepc_wmi_get_devstate(EEEPC_WMI_DEVID_BRIGHTNESS, &retval);
+
+	if (ACPI_FAILURE(status))
+		return -EIO;
+	else
+		return retval & EEEPC_WMI_DSTS_BRIGHTNESS_MASK;
+}
+
+static int update_bl_status(struct backlight_device *bd)
+{
+	u32 ctrl_param;
+	acpi_status status;
+	int power;
+
+	ctrl_param = bd->props.brightness;
+
+	status = eeepc_wmi_set_devstate(EEEPC_WMI_DEVID_BRIGHTNESS,
+					ctrl_param, NULL);
+
+	if (ACPI_FAILURE(status))
+		return -EIO;
+
+	power = read_backlight_power();
+	if (power != -ENODEV && bd->props.power != power) {
+		ctrl_param = !!(bd->props.power == FB_BLANK_UNBLANK);
+		status = eeepc_wmi_set_devstate(EEEPC_WMI_DEVID_BACKLIGHT,
+						ctrl_param, NULL);
+
+		if (ACPI_FAILURE(status))
+			return -EIO;
+	}
+	return 0;
+}
+
+static const struct backlight_ops eeepc_wmi_bl_ops = {
+	.get_brightness = read_brightness,
+	.update_status = update_bl_status,
+};
+
+static int eeepc_wmi_backlight_notify(struct eeepc_wmi *eeepc, int code)
+{
+	struct backlight_device *bd = eeepc->backlight_device;
+	int old = bd->props.brightness;
+	int new = old;
+
+	if (code >= NOTIFY_BRNUP_MIN && code <= NOTIFY_BRNUP_MAX)
+		new = code - NOTIFY_BRNUP_MIN + 1;
+	else if (code >= NOTIFY_BRNDOWN_MIN && code <= NOTIFY_BRNDOWN_MAX)
+		new = code - NOTIFY_BRNDOWN_MIN;
+
+	bd->props.brightness = new;
+	backlight_update_status(bd);
+	backlight_force_update(bd, BACKLIGHT_UPDATE_HOTKEY);
+
+	return old;
+}
+
+static int eeepc_wmi_backlight_init(struct eeepc_wmi *eeepc)
+{
+	struct backlight_device *bd;
+	struct backlight_properties props;
+	int max;
+	int power;
+
+	max = eeepc_wmi_get_devstate_bits(EEEPC_WMI_DEVID_BRIGHTNESS,
+					  EEEPC_WMI_DSTS_MAX_BRIGTH_MASK);
+	power = read_backlight_power();
+
+	if (max < 0 && power < 0) {
+		/* Try to keep the original error */
+		if (max == -ENODEV && power == -ENODEV)
+			return -ENODEV;
+		if (max != -ENODEV)
+			return max;
+		else
+			return power;
+	}
+	if (max == -ENODEV)
+		max = 0;
+	if (power == -ENODEV)
+		power = FB_BLANK_UNBLANK;
+
+	memset(&props, 0, sizeof(struct backlight_properties));
+	props.max_brightness = max;
+	bd = backlight_device_register(EEEPC_WMI_FILE,
+				       &eeepc->platform_device->dev, eeepc,
+				       &eeepc_wmi_bl_ops, &props);
+	if (IS_ERR(bd)) {
+		pr_err("Could not register backlight device\n");
+		return PTR_ERR(bd);
+	}
+
+	eeepc->backlight_device = bd;
+
+	bd->props.brightness = read_brightness(bd);
+	bd->props.power = power;
+	backlight_update_status(bd);
+
+	return 0;
+}
+
+static void eeepc_wmi_backlight_exit(struct eeepc_wmi *eeepc)
+{
+	if (eeepc->backlight_device)
+		backlight_device_unregister(eeepc->backlight_device);
+
+	eeepc->backlight_device = NULL;
+}
+
+static void eeepc_wmi_notify(u32 value, void *context)
+{
+	struct eeepc_wmi *eeepc = context;
+	struct acpi_buffer response = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *obj;
+	acpi_status status;
+	int code;
+	int orig_code;
+
+	status = wmi_get_event_data(value, &response);
+	if (status != AE_OK) {
+		pr_err("bad event status 0x%x\n", status);
+		return;
+	}
+
+	obj = (union acpi_object *)response.pointer;
+
+	if (obj && obj->type == ACPI_TYPE_INTEGER) {
+		code = obj->integer.value;
+		orig_code = code;
+
+		if (code >= NOTIFY_BRNUP_MIN && code <= NOTIFY_BRNUP_MAX)
+			code = NOTIFY_BRNUP_MIN;
+		else if (code >= NOTIFY_BRNDOWN_MIN &&
+			 code <= NOTIFY_BRNDOWN_MAX)
+			code = NOTIFY_BRNDOWN_MIN;
+
+		if (code == NOTIFY_BRNUP_MIN || code == NOTIFY_BRNDOWN_MIN) {
+			if (!acpi_video_backlight_support())
+				eeepc_wmi_backlight_notify(eeepc, orig_code);
+		}
+
+		if (!sparse_keymap_report_event(eeepc->inputdev,
+						code, 1, true))
+			pr_info("Unknown key %x pressed\n", code);
+	}
+
+	kfree(obj);
+}
+
+/*
+ * Sys helpers
+ */
+static int parse_arg(const char *buf, unsigned long count, int *val)
+{
+	if (!count)
+		return 0;
+	if (sscanf(buf, "%i", val) != 1)
+		return -EINVAL;
+	return count;
+}
+
+static ssize_t store_sys_wmi(int devid, const char *buf, size_t count)
+{
+	acpi_status status;
+	u32 retval;
+	int rv, value;
+
+	value = eeepc_wmi_get_devstate_simple(devid);
+	if (value == -ENODEV) /* Check device presence */
+		return value;
+
+	rv = parse_arg(buf, count, &value);
+	status = eeepc_wmi_set_devstate(devid, value, &retval);
+
+	if (ACPI_FAILURE(status))
+		return -EIO;
+	return rv;
+}
+
+static ssize_t show_sys_wmi(int devid, char *buf)
+{
+	int value = eeepc_wmi_get_devstate_simple(devid);
+
+	if (value < 0)
+		return value;
+
+	return sprintf(buf, "%d\n", value);
+}
+
+#define EEEPC_WMI_CREATE_DEVICE_ATTR(_name, _mode, _cm)			\
+	static ssize_t show_##_name(struct device *dev,			\
+				    struct device_attribute *attr,	\
+				    char *buf)				\
+	{								\
+		return show_sys_wmi(_cm, buf);				\
+	}								\
+	static ssize_t store_##_name(struct device *dev,		\
+				     struct device_attribute *attr,	\
+				     const char *buf, size_t count)	\
+	{								\
+		return store_sys_wmi(_cm, buf, count);			\
+	}								\
+	static struct device_attribute dev_attr_##_name = {		\
+		.attr = {						\
+			.name = __stringify(_name),			\
+			.mode = _mode },				\
+		.show   = show_##_name,					\
+		.store  = store_##_name,				\
+	}
+
+EEEPC_WMI_CREATE_DEVICE_ATTR(touchpad, 0644, EEEPC_WMI_DEVID_TOUCHPAD);
+EEEPC_WMI_CREATE_DEVICE_ATTR(camera, 0644, EEEPC_WMI_DEVID_CAMERA);
+EEEPC_WMI_CREATE_DEVICE_ATTR(cardr, 0644, EEEPC_WMI_DEVID_CARDREADER);
+
+static ssize_t store_cpufv(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	int value;
+	struct acpi_buffer input = { (acpi_size)sizeof(value), &value };
+	acpi_status status;
+
+	if (!count || sscanf(buf, "%i", &value) != 1)
+		return -EINVAL;
+	if (value < 0 || value > 2)
+		return -EINVAL;
+
+	status = wmi_evaluate_method(EEEPC_WMI_MGMT_GUID,
+				     1, EEEPC_WMI_METHODID_CFVS, &input, NULL);
+
+	if (ACPI_FAILURE(status))
+		return -EIO;
+	else
+		return count;
+}
+
+static DEVICE_ATTR(cpufv, S_IRUGO | S_IWUSR, NULL, store_cpufv);
+
+static struct attribute *platform_attributes[] = {
+	&dev_attr_cpufv.attr,
+	&dev_attr_camera.attr,
+	&dev_attr_cardr.attr,
+	&dev_attr_touchpad.attr,
+	NULL
+};
+
+static mode_t eeepc_sysfs_is_visible(struct kobject *kobj,
+				     struct attribute *attr,
+				     int idx)
+{
+	bool supported = true;
+	int devid = -1;
+
+	if (attr == &dev_attr_camera.attr)
+		devid = EEEPC_WMI_DEVID_CAMERA;
+	else if (attr == &dev_attr_cardr.attr)
+		devid = EEEPC_WMI_DEVID_CARDREADER;
+	else if (attr == &dev_attr_touchpad.attr)
+		devid = EEEPC_WMI_DEVID_TOUCHPAD;
+
+	if (devid != -1)
+		supported = eeepc_wmi_get_devstate_simple(devid) != -ENODEV;
+
+	return supported ? attr->mode : 0;
+}
+
+static struct attribute_group platform_attribute_group = {
+	.is_visible	= eeepc_sysfs_is_visible,
+	.attrs		= platform_attributes
+};
+
+static void eeepc_wmi_sysfs_exit(struct platform_device *device)
+{
+	sysfs_remove_group(&device->dev.kobj, &platform_attribute_group);
+}
+
+static int eeepc_wmi_sysfs_init(struct platform_device *device)
+{
+	return sysfs_create_group(&device->dev.kobj, &platform_attribute_group);
+}
+
+/*
+ * Platform device
+ */
+static int __init eeepc_wmi_platform_init(struct eeepc_wmi *eeepc)
+{
+	return eeepc_wmi_sysfs_init(eeepc->platform_device);
+}
+
+static void eeepc_wmi_platform_exit(struct eeepc_wmi *eeepc)
+{
+	eeepc_wmi_sysfs_exit(eeepc->platform_device);
+}
+
+/*
+ * debugfs
+ */
+struct eeepc_wmi_debugfs_node {
+	struct eeepc_wmi *eeepc;
+	char *name;
+	int (*show)(struct seq_file *m, void *data);
+};
+
+static int show_dsts(struct seq_file *m, void *data)
+{
+	struct eeepc_wmi *eeepc = m->private;
+	acpi_status status;
+	u32 retval = -1;
+
+	status = eeepc_wmi_get_devstate(eeepc->debug.dev_id, &retval);
+
+	if (ACPI_FAILURE(status))
+		return -EIO;
+
+	seq_printf(m, "DSTS(%x) = %x\n", eeepc->debug.dev_id, retval);
+
+	return 0;
+}
+
+static int show_devs(struct seq_file *m, void *data)
+{
+	struct eeepc_wmi *eeepc = m->private;
+	acpi_status status;
+	u32 retval = -1;
+
+	status = eeepc_wmi_set_devstate(eeepc->debug.dev_id,
+					eeepc->debug.ctrl_param, &retval);
+	if (ACPI_FAILURE(status))
+		return -EIO;
+
+	seq_printf(m, "DEVS(%x, %x) = %x\n", eeepc->debug.dev_id,
+		   eeepc->debug.ctrl_param, retval);
+
+	return 0;
+}
+
+static struct eeepc_wmi_debugfs_node eeepc_wmi_debug_files[] = {
+	{ NULL, "devs", show_devs },
+	{ NULL, "dsts", show_dsts },
+};
+
+static int eeepc_wmi_debugfs_open(struct inode *inode, struct file *file)
+{
+	struct eeepc_wmi_debugfs_node *node = inode->i_private;
+
+	return single_open(file, node->show, node->eeepc);
+}
+
+static const struct file_operations eeepc_wmi_debugfs_io_ops = {
+	.owner = THIS_MODULE,
+	.open  = eeepc_wmi_debugfs_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+static void eeepc_wmi_debugfs_exit(struct eeepc_wmi *eeepc)
+{
+	debugfs_remove_recursive(eeepc->debug.root);
+}
+
+static int eeepc_wmi_debugfs_init(struct eeepc_wmi *eeepc)
+{
+	struct dentry *dent;
+	int i;
+
+	eeepc->debug.root = debugfs_create_dir(EEEPC_WMI_FILE, NULL);
+	if (!eeepc->debug.root) {
+		pr_err("failed to create debugfs directory");
+		goto error_debugfs;
+	}
+
+	dent = debugfs_create_x32("dev_id", S_IRUGO|S_IWUSR,
+				  eeepc->debug.root, &eeepc->debug.dev_id);
+	if (!dent)
+		goto error_debugfs;
+
+	dent = debugfs_create_x32("ctrl_param", S_IRUGO|S_IWUSR,
+				  eeepc->debug.root, &eeepc->debug.ctrl_param);
+	if (!dent)
+		goto error_debugfs;
+
+	for (i = 0; i < ARRAY_SIZE(eeepc_wmi_debug_files); i++) {
+		struct eeepc_wmi_debugfs_node *node = &eeepc_wmi_debug_files[i];
+
+		node->eeepc = eeepc;
+		dent = debugfs_create_file(node->name, S_IFREG | S_IRUGO,
+					   eeepc->debug.root, node,
+					   &eeepc_wmi_debugfs_io_ops);
+		if (!dent) {
+			pr_err("failed to create debug file: %s\n", node->name);
+			goto error_debugfs;
+		}
+	}
+
+	return 0;
+
+error_debugfs:
+	eeepc_wmi_debugfs_exit(eeepc);
+	return -ENOMEM;
+}
+
+/*
+ * WMI Driver
+ */
+static void eeepc_dmi_check(struct eeepc_wmi *eeepc)
+{
+	const char *model;
+
+	model = dmi_get_system_info(DMI_PRODUCT_NAME);
+	if (!model)
+		return;
+
+	/*
+	 * Whitelist for wlan hotplug
+	 *
+	 * Eeepc 1000H needs the current hotplug code to handle
+	 * Fn+F2 correctly. We may add other Eeepc here later, but
+	 * it seems that most of the laptops supported by eeepc-wmi
+	 * don't need to be on this list
+	 */
+	if (strcmp(model, "1000H") == 0) {
+		eeepc->hotplug_wireless = true;
+		pr_info("wlan hotplug enabled\n");
+	}
+}
+
+static int __init eeepc_wmi_add(struct platform_device *pdev)
+{
+	struct eeepc_wmi *eeepc;
+	acpi_status status;
+	int err;
+
+	eeepc = kzalloc(sizeof(struct eeepc_wmi), GFP_KERNEL);
+	if (!eeepc)
+		return -ENOMEM;
+
+	eeepc->platform_device = pdev;
+	platform_set_drvdata(eeepc->platform_device, eeepc);
+
+	eeepc->hotplug_wireless = hotplug_wireless;
+	eeepc_dmi_check(eeepc);
+
+	err = eeepc_wmi_platform_init(eeepc);
+	if (err)
+		goto fail_platform;
+
+	err = eeepc_wmi_input_init(eeepc);
+	if (err)
+		goto fail_input;
+
+	err = eeepc_wmi_led_init(eeepc);
+	if (err)
+		goto fail_leds;
+
+	err = eeepc_wmi_rfkill_init(eeepc);
+	if (err)
+		goto fail_rfkill;
+
+	if (!acpi_video_backlight_support()) {
+		err = eeepc_wmi_backlight_init(eeepc);
+		if (err && err != -ENODEV)
+			goto fail_backlight;
+	} else
+		pr_info("Backlight controlled by ACPI video driver\n");
+
+	status = wmi_install_notify_handler(EEEPC_WMI_EVENT_GUID,
+					    eeepc_wmi_notify, eeepc);
+	if (ACPI_FAILURE(status)) {
+		pr_err("Unable to register notify handler - %d\n",
+			status);
+		err = -ENODEV;
+		goto fail_wmi_handler;
+	}
+
+	err = eeepc_wmi_debugfs_init(eeepc);
+	if (err)
+		goto fail_debugfs;
+
+	return 0;
+
+fail_debugfs:
+	wmi_remove_notify_handler(EEEPC_WMI_EVENT_GUID);
+fail_wmi_handler:
+	eeepc_wmi_backlight_exit(eeepc);
+fail_backlight:
+	eeepc_wmi_rfkill_exit(eeepc);
+fail_rfkill:
+	eeepc_wmi_led_exit(eeepc);
+fail_leds:
+	eeepc_wmi_input_exit(eeepc);
+fail_input:
+	eeepc_wmi_platform_exit(eeepc);
+fail_platform:
+	kfree(eeepc);
+	return err;
+}
+
+static int __exit eeepc_wmi_remove(struct platform_device *device)
+{
+	struct eeepc_wmi *eeepc;
+
+	eeepc = platform_get_drvdata(device);
+	wmi_remove_notify_handler(EEEPC_WMI_EVENT_GUID);
+	eeepc_wmi_backlight_exit(eeepc);
+	eeepc_wmi_input_exit(eeepc);
+	eeepc_wmi_led_exit(eeepc);
+	eeepc_wmi_rfkill_exit(eeepc);
+	eeepc_wmi_debugfs_exit(eeepc);
+	eeepc_wmi_platform_exit(eeepc);
+
+	kfree(eeepc);
+	return 0;
+}
+
+/*
+ * Platform driver - hibernate/resume callbacks
+ */
+static int eeepc_hotk_thaw(struct device *device)
+{
+	struct eeepc_wmi *eeepc = dev_get_drvdata(device);
+
+	if (eeepc->wlan_rfkill) {
+		bool wlan;
+
+		/*
+		 * Work around bios bug - acpi _PTS turns off the wireless led
+		 * during suspend.  Normally it restores it on resume, but
+		 * we should kick it ourselves in case hibernation is aborted.
+		 */
+		wlan = eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_WLAN);
+		eeepc_wmi_set_devstate(EEEPC_WMI_DEVID_WLAN, wlan, NULL);
+	}
+
+	return 0;
+}
+
+static int eeepc_hotk_restore(struct device *device)
+{
+	struct eeepc_wmi *eeepc = dev_get_drvdata(device);
+	int bl;
+
+	/* Refresh both wlan rfkill state and pci hotplug */
+	if (eeepc->wlan_rfkill)
+		eeepc_rfkill_hotplug(eeepc);
+
+	if (eeepc->bluetooth_rfkill) {
+		bl = !eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_BLUETOOTH);
+		rfkill_set_sw_state(eeepc->bluetooth_rfkill, bl);
+	}
+	if (eeepc->wimax_rfkill) {
+		bl = !eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_WIMAX);
+		rfkill_set_sw_state(eeepc->wimax_rfkill, bl);
+	}
+	if (eeepc->wwan3g_rfkill) {
+		bl = !eeepc_wmi_get_devstate_simple(EEEPC_WMI_DEVID_WWAN3G);
+		rfkill_set_sw_state(eeepc->wwan3g_rfkill, bl);
+	}
+
+	return 0;
+}
+
+static const struct dev_pm_ops eeepc_pm_ops = {
+	.thaw = eeepc_hotk_thaw,
+	.restore = eeepc_hotk_restore,
+};
+
+static struct platform_driver platform_driver = {
+	.remove = __exit_p(eeepc_wmi_remove),
+	.driver = {
+		.name = EEEPC_WMI_FILE,
+		.owner = THIS_MODULE,
+		.pm = &eeepc_pm_ops,
+	},
+};
+
+static acpi_status __init eeepc_wmi_parse_device(acpi_handle handle, u32 level,
+						 void *context, void **retval)
+{
+	pr_warning("Found legacy ATKD device (%s)", EEEPC_ACPI_HID);
+	*(bool *)context = true;
+	return AE_CTRL_TERMINATE;
+}
+
+static int __init eeepc_wmi_check_atkd(void)
+{
+	acpi_status status;
+	bool found = false;
+
+	status = acpi_get_devices(EEEPC_ACPI_HID, eeepc_wmi_parse_device,
+				  &found, NULL);
+
+	if (ACPI_FAILURE(status) || !found)
+		return 0;
+	return -1;
+}
+
+static int __init eeepc_wmi_probe(struct platform_device *pdev)
+{
+	if (!wmi_has_guid(EEEPC_WMI_EVENT_GUID) ||
+	    !wmi_has_guid(EEEPC_WMI_MGMT_GUID)) {
+		pr_warning("No known WMI GUID found\n");
+		return -ENODEV;
+	}
+
+	if (eeepc_wmi_check_atkd()) {
+		pr_warning("WMI device present, but legacy ATKD device is also "
+			   "present and enabled.");
+		pr_warning("You probably booted with acpi_osi=\"Linux\" or "
+			   "acpi_osi=\"!Windows 2009\"");
+		pr_warning("Can't load eeepc-wmi, use default acpi_osi "
+			   "(preferred) or eeepc-laptop");
+		return -ENODEV;
+	}
+
+	return eeepc_wmi_add(pdev);
+}
+
+static struct platform_device *platform_device;
+
+static int __init eeepc_wmi_init(void)
+{
+	platform_device = platform_create_bundle(&platform_driver,
+						 eeepc_wmi_probe,
+						 NULL, 0, NULL, 0);
+	if (IS_ERR(platform_device))
+		return PTR_ERR(platform_device);
+	return 0;
+}
+
+static void __exit eeepc_wmi_exit(void)
+{
+	platform_device_unregister(platform_device);
+	platform_driver_unregister(&platform_driver);
+}
+
+module_init(eeepc_wmi_init);
+module_exit(eeepc_wmi_exit);
