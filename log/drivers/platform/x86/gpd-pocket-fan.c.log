commit 1d6f8c5bac93cceb2d4ac8e6331050652004d802
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Mar 6 10:17:24 2020 +0100

    platform/x86: GPD pocket fan: Fix error message when temp-limits are out of range
    
    Commit 1f27dbd8265d ("platform/x86: GPD pocket fan: Allow somewhat
    lower/higher temperature limits") changed the module-param sanity check
    to accept temperature limits between 20 and 90 degrees celcius.
    
    But the error message printed when the module params are outside this
    range was not updated. This commit updates the error message to match
    the new min and max value for the temp-limits.
    
    Reported-by: Pavel Machek <pavel@denx.de>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Pavel Machek <pavel@denx.de>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/gpd-pocket-fan.c b/drivers/platform/x86/gpd-pocket-fan.c
index b471b86c28fe..5b516e4c2bfb 100644
--- a/drivers/platform/x86/gpd-pocket-fan.c
+++ b/drivers/platform/x86/gpd-pocket-fan.c
@@ -128,7 +128,7 @@ static int gpd_pocket_fan_probe(struct platform_device *pdev)
 
 	for (i = 0; i < ARRAY_SIZE(temp_limits); i++) {
 		if (temp_limits[i] < 20000 || temp_limits[i] > 90000) {
-			dev_err(&pdev->dev, "Invalid temp-limit %d (must be between 40000 and 70000)\n",
+			dev_err(&pdev->dev, "Invalid temp-limit %d (must be between 20000 and 90000)\n",
 				temp_limits[i]);
 			temp_limits[0] = TEMP_LIMIT0_DEFAULT;
 			temp_limits[1] = TEMP_LIMIT1_DEFAULT;

commit 1f27dbd8265dbb379926c8f6a4453fe7fe26d7a3
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Mon Jan 6 15:42:19 2020 +0100

    platform/x86: GPD pocket fan: Allow somewhat lower/higher temperature limits
    
    Allow the user to configure the fan to turn on / speed-up at lower
    thresholds then before (20 degrees Celcius as minimum instead of 40) and
    likewise also allow the user to delay the fan speeding-up till the
    temperature hits 90 degrees Celcius (was 70).
    
    Cc: Jason Anderson <jasona.594@gmail.com>
    Reported-by: Jason Anderson <jasona.594@gmail.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/gpd-pocket-fan.c b/drivers/platform/x86/gpd-pocket-fan.c
index 73eb1572b966..b471b86c28fe 100644
--- a/drivers/platform/x86/gpd-pocket-fan.c
+++ b/drivers/platform/x86/gpd-pocket-fan.c
@@ -127,7 +127,7 @@ static int gpd_pocket_fan_probe(struct platform_device *pdev)
 	int i;
 
 	for (i = 0; i < ARRAY_SIZE(temp_limits); i++) {
-		if (temp_limits[i] < 40000 || temp_limits[i] > 70000) {
+		if (temp_limits[i] < 20000 || temp_limits[i] > 90000) {
 			dev_err(&pdev->dev, "Invalid temp-limit %d (must be between 40000 and 70000)\n",
 				temp_limits[i]);
 			temp_limits[0] = TEMP_LIMIT0_DEFAULT;

commit 6ae01050e49f0080ae30575d9b45a6d4a3d7ee23
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Mon Jan 6 15:42:18 2020 +0100

    platform/x86: GPD pocket fan: Use default values when wrong modparams are given
    
    Use our default values when wrong module-parameters are given, instead of
    refusing to load. Refusing to load leaves the fan at the BIOS default
    setting, which is "Off". The CPU's thermal throttling should protect the
    system from damage, but not-loading is really not the best fallback in this
    case.
    
    This commit fixes this by re-setting module-parameter values to their
    defaults if they are out of range, instead of failing the probe with
    -EINVAL.
    
    Cc: stable@vger.kernel.org
    Cc: Jason Anderson <jasona.594@gmail.com>
    Reported-by: Jason Anderson <jasona.594@gmail.com>
    Fixes: 594ce6db326e ("platform/x86: GPD pocket fan: Use a min-speed of 2 while charging")
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/gpd-pocket-fan.c b/drivers/platform/x86/gpd-pocket-fan.c
index be85ed966bf3..73eb1572b966 100644
--- a/drivers/platform/x86/gpd-pocket-fan.c
+++ b/drivers/platform/x86/gpd-pocket-fan.c
@@ -16,17 +16,27 @@
 
 #define MAX_SPEED 3
 
-static int temp_limits[3] = { 55000, 60000, 65000 };
+#define TEMP_LIMIT0_DEFAULT	55000
+#define TEMP_LIMIT1_DEFAULT	60000
+#define TEMP_LIMIT2_DEFAULT	65000
+
+#define HYSTERESIS_DEFAULT	3000
+
+#define SPEED_ON_AC_DEFAULT	2
+
+static int temp_limits[3] = {
+	TEMP_LIMIT0_DEFAULT, TEMP_LIMIT1_DEFAULT, TEMP_LIMIT2_DEFAULT,
+};
 module_param_array(temp_limits, int, NULL, 0444);
 MODULE_PARM_DESC(temp_limits,
 		 "Millicelsius values above which the fan speed increases");
 
-static int hysteresis = 3000;
+static int hysteresis = HYSTERESIS_DEFAULT;
 module_param(hysteresis, int, 0444);
 MODULE_PARM_DESC(hysteresis,
 		 "Hysteresis in millicelsius before lowering the fan speed");
 
-static int speed_on_ac = 2;
+static int speed_on_ac = SPEED_ON_AC_DEFAULT;
 module_param(speed_on_ac, int, 0444);
 MODULE_PARM_DESC(speed_on_ac,
 		 "minimum fan speed to allow when system is powered by AC");
@@ -120,18 +130,21 @@ static int gpd_pocket_fan_probe(struct platform_device *pdev)
 		if (temp_limits[i] < 40000 || temp_limits[i] > 70000) {
 			dev_err(&pdev->dev, "Invalid temp-limit %d (must be between 40000 and 70000)\n",
 				temp_limits[i]);
-			return -EINVAL;
+			temp_limits[0] = TEMP_LIMIT0_DEFAULT;
+			temp_limits[1] = TEMP_LIMIT1_DEFAULT;
+			temp_limits[2] = TEMP_LIMIT2_DEFAULT;
+			break;
 		}
 	}
 	if (hysteresis < 1000 || hysteresis > 10000) {
 		dev_err(&pdev->dev, "Invalid hysteresis %d (must be between 1000 and 10000)\n",
 			hysteresis);
-		return -EINVAL;
+		hysteresis = HYSTERESIS_DEFAULT;
 	}
 	if (speed_on_ac < 0 || speed_on_ac > MAX_SPEED) {
 		dev_err(&pdev->dev, "Invalid speed_on_ac %d (must be between 0 and 3)\n",
 			speed_on_ac);
-		return -EINVAL;
+		speed_on_ac = SPEED_ON_AC_DEFAULT;
 	}
 
 	fan = devm_kzalloc(&pdev->dev, sizeof(*fan), GFP_KERNEL);

commit b1ca80e4a23b91fc90545919dda90a32ec558663
Author: Colin Ian King <colin.king@canonical.com>
Date:   Fri Feb 9 11:53:40 2018 +0000

    platform/x86: GPD pocket fan: fix spelling mistake: "Mill-celcius" -> "millicelsius"
    
    Trivial fix to spelling mistake in MODULE_PARM_DESC text and remove
    unnecessary hyphen.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/gpd-pocket-fan.c b/drivers/platform/x86/gpd-pocket-fan.c
index 2d645c505f81..be85ed966bf3 100644
--- a/drivers/platform/x86/gpd-pocket-fan.c
+++ b/drivers/platform/x86/gpd-pocket-fan.c
@@ -19,12 +19,12 @@
 static int temp_limits[3] = { 55000, 60000, 65000 };
 module_param_array(temp_limits, int, NULL, 0444);
 MODULE_PARM_DESC(temp_limits,
-		 "Milli-celcius values above which the fan speed increases");
+		 "Millicelsius values above which the fan speed increases");
 
 static int hysteresis = 3000;
 module_param(hysteresis, int, 0444);
 MODULE_PARM_DESC(hysteresis,
-		 "Hysteresis in milli-celcius before lowering the fan speed");
+		 "Hysteresis in millicelsius before lowering the fan speed");
 
 static int speed_on_ac = 2;
 module_param(speed_on_ac, int, 0444);

commit e5778689a9653c0f364efbbd6b9bdd0527e7d8cb
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Jan 19 21:47:09 2018 +0100

    platform/x86: GPD pocket fan: Stop work on suspend
    
    Stop the work on suspend, otherwise it may run between our suspend method
    running and the system suspending, possibly restarting the fan which
    we've just stopped.
    
    Note we already requeue the work on resume, so that we get a fresh speed
    at resume.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/gpd-pocket-fan.c b/drivers/platform/x86/gpd-pocket-fan.c
index 2652eb40e5bc..2d645c505f81 100644
--- a/drivers/platform/x86/gpd-pocket-fan.c
+++ b/drivers/platform/x86/gpd-pocket-fan.c
@@ -177,6 +177,7 @@ static int gpd_pocket_fan_suspend(struct device *dev)
 {
 	struct gpd_pocket_fan_data *fan = dev_get_drvdata(dev);
 
+	cancel_delayed_work_sync(&fan->work);
 	gpd_pocket_fan_set_speed(fan, gpd_pocket_fan_min_speed());
 	return 0;
 }

commit 594ce6db326e3a2bff9a8e04cc333dea5467b020
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Jan 19 21:47:08 2018 +0100

    platform/x86: GPD pocket fan: Use a min-speed of 2 while charging
    
    Newer versions of the GPD pocket BIOS set the fan-speed to 2 when a
    charger gets plugged in while the device is off. Mirror this in our
    fan driver and use a minimum speed of 2 while charging,
    
    Cc: James <kernel@madingley.org>
    Suggested-by: James <kernel@madingley.org>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/gpd-pocket-fan.c b/drivers/platform/x86/gpd-pocket-fan.c
index 1fdf2205730d..2652eb40e5bc 100644
--- a/drivers/platform/x86/gpd-pocket-fan.c
+++ b/drivers/platform/x86/gpd-pocket-fan.c
@@ -10,6 +10,7 @@
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/platform_device.h>
+#include <linux/power_supply.h>
 #include <linux/thermal.h>
 #include <linux/workqueue.h>
 
@@ -25,6 +26,11 @@ module_param(hysteresis, int, 0444);
 MODULE_PARM_DESC(hysteresis,
 		 "Hysteresis in milli-celcius before lowering the fan speed");
 
+static int speed_on_ac = 2;
+module_param(speed_on_ac, int, 0444);
+MODULE_PARM_DESC(speed_on_ac,
+		 "minimum fan speed to allow when system is powered by AC");
+
 struct gpd_pocket_fan_data {
 	struct device *dev;
 	struct thermal_zone_device *dts0;
@@ -46,11 +52,19 @@ static void gpd_pocket_fan_set_speed(struct gpd_pocket_fan_data *fan, int speed)
 	fan->last_speed = speed;
 }
 
+static int gpd_pocket_fan_min_speed(void)
+{
+	if (power_supply_is_system_supplied())
+		return speed_on_ac;
+	else
+		return 0;
+}
+
 static void gpd_pocket_fan_worker(struct work_struct *work)
 {
 	struct gpd_pocket_fan_data *fan =
 		container_of(work, struct gpd_pocket_fan_data, work.work);
-	int t0, t1, temp, speed, i;
+	int t0, t1, temp, speed, min_speed, i;
 
 	if (thermal_zone_get_temp(fan->dts0, &t0) ||
 	    thermal_zone_get_temp(fan->dts1, &t1)) {
@@ -62,9 +76,10 @@ static void gpd_pocket_fan_worker(struct work_struct *work)
 	temp = max(t0, t1);
 
 	speed = fan->last_speed;
+	min_speed = gpd_pocket_fan_min_speed();
 
 	/* Determine minimum speed */
-	for (i = 0; i < ARRAY_SIZE(temp_limits); i++) {
+	for (i = min_speed; i < ARRAY_SIZE(temp_limits); i++) {
 		if (temp < temp_limits[i])
 			break;
 	}
@@ -72,7 +87,7 @@ static void gpd_pocket_fan_worker(struct work_struct *work)
 		speed = i;
 
 	/* Use hysteresis before lowering speed again */
-	for (i = 0; i < ARRAY_SIZE(temp_limits); i++) {
+	for (i = min_speed; i < ARRAY_SIZE(temp_limits); i++) {
 		if (temp <= (temp_limits[i] - hysteresis))
 			break;
 	}
@@ -113,6 +128,11 @@ static int gpd_pocket_fan_probe(struct platform_device *pdev)
 			hysteresis);
 		return -EINVAL;
 	}
+	if (speed_on_ac < 0 || speed_on_ac > MAX_SPEED) {
+		dev_err(&pdev->dev, "Invalid speed_on_ac %d (must be between 0 and 3)\n",
+			speed_on_ac);
+		return -EINVAL;
+	}
 
 	fan = devm_kzalloc(&pdev->dev, sizeof(*fan), GFP_KERNEL);
 	if (!fan)
@@ -157,7 +177,7 @@ static int gpd_pocket_fan_suspend(struct device *dev)
 {
 	struct gpd_pocket_fan_data *fan = dev_get_drvdata(dev);
 
-	gpd_pocket_fan_set_speed(fan, 0);
+	gpd_pocket_fan_set_speed(fan, gpd_pocket_fan_min_speed());
 	return 0;
 }
 

commit d890acf728aefc47fd90733d5fef1dff89857748
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Jan 19 21:47:07 2018 +0100

    platform/x86: GPD pocket fan: Set speed to max on get_temp failure
    
    When we fail to get the temperature, assume the worst and set the speed
    to max.
    
    While at it introduce a define for MAX_SPEED.
    
    Cc: James <kernel@madingley.org>
    Suggested-by: James <kernel@madingley.org>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/gpd-pocket-fan.c b/drivers/platform/x86/gpd-pocket-fan.c
index c6f4d89b1437..1fdf2205730d 100644
--- a/drivers/platform/x86/gpd-pocket-fan.c
+++ b/drivers/platform/x86/gpd-pocket-fan.c
@@ -13,6 +13,8 @@
 #include <linux/thermal.h>
 #include <linux/workqueue.h>
 
+#define MAX_SPEED 3
+
 static int temp_limits[3] = { 55000, 60000, 65000 };
 module_param_array(temp_limits, int, NULL, 0444);
 MODULE_PARM_DESC(temp_limits,
@@ -53,9 +55,8 @@ static void gpd_pocket_fan_worker(struct work_struct *work)
 	if (thermal_zone_get_temp(fan->dts0, &t0) ||
 	    thermal_zone_get_temp(fan->dts1, &t1)) {
 		dev_warn(fan->dev, "Error getting temperature\n");
-		queue_delayed_work(system_wq, &fan->work,
-				   msecs_to_jiffies(1000));
-		return;
+		speed = MAX_SPEED;
+		goto set_speed;
 	}
 
 	temp = max(t0, t1);
@@ -79,8 +80,9 @@ static void gpd_pocket_fan_worker(struct work_struct *work)
 		speed = i;
 
 	if (fan->last_speed <= 0 && speed)
-		speed = 3; /* kick start motor */
+		speed = MAX_SPEED; /* kick start motor */
 
+set_speed:
 	gpd_pocket_fan_set_speed(fan, speed);
 
 	/* When mostly idle (low temp/speed), slow down the poll interval. */

commit 1b46f17d687a431c423f970a5d292c6fcd478afb
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Dec 12 17:40:54 2017 +0100

    platform/x86: Add driver for GPD pocket custom fan controller
    
    Add a driver for the GPD pocket device's custom fan controller, which
    gets controlled through 2 GPIOs listed in a FAN02501 ACPI device.
    
    Cc: James <kernel@madingley.org>
    Suggested-by: James <kernel@madingley.org>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/gpd-pocket-fan.c b/drivers/platform/x86/gpd-pocket-fan.c
new file mode 100644
index 000000000000..c6f4d89b1437
--- /dev/null
+++ b/drivers/platform/x86/gpd-pocket-fan.c
@@ -0,0 +1,193 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * GPD Pocket fan controller driver
+ *
+ * Copyright (C) 2017 Hans de Goede <hdegoede@redhat.com>
+ */
+
+#include <linux/acpi.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/thermal.h>
+#include <linux/workqueue.h>
+
+static int temp_limits[3] = { 55000, 60000, 65000 };
+module_param_array(temp_limits, int, NULL, 0444);
+MODULE_PARM_DESC(temp_limits,
+		 "Milli-celcius values above which the fan speed increases");
+
+static int hysteresis = 3000;
+module_param(hysteresis, int, 0444);
+MODULE_PARM_DESC(hysteresis,
+		 "Hysteresis in milli-celcius before lowering the fan speed");
+
+struct gpd_pocket_fan_data {
+	struct device *dev;
+	struct thermal_zone_device *dts0;
+	struct thermal_zone_device *dts1;
+	struct gpio_desc *gpio0;
+	struct gpio_desc *gpio1;
+	struct delayed_work work;
+	int last_speed;
+};
+
+static void gpd_pocket_fan_set_speed(struct gpd_pocket_fan_data *fan, int speed)
+{
+	if (speed == fan->last_speed)
+		return;
+
+	gpiod_direction_output(fan->gpio0, !!(speed & 1));
+	gpiod_direction_output(fan->gpio1, !!(speed & 2));
+
+	fan->last_speed = speed;
+}
+
+static void gpd_pocket_fan_worker(struct work_struct *work)
+{
+	struct gpd_pocket_fan_data *fan =
+		container_of(work, struct gpd_pocket_fan_data, work.work);
+	int t0, t1, temp, speed, i;
+
+	if (thermal_zone_get_temp(fan->dts0, &t0) ||
+	    thermal_zone_get_temp(fan->dts1, &t1)) {
+		dev_warn(fan->dev, "Error getting temperature\n");
+		queue_delayed_work(system_wq, &fan->work,
+				   msecs_to_jiffies(1000));
+		return;
+	}
+
+	temp = max(t0, t1);
+
+	speed = fan->last_speed;
+
+	/* Determine minimum speed */
+	for (i = 0; i < ARRAY_SIZE(temp_limits); i++) {
+		if (temp < temp_limits[i])
+			break;
+	}
+	if (speed < i)
+		speed = i;
+
+	/* Use hysteresis before lowering speed again */
+	for (i = 0; i < ARRAY_SIZE(temp_limits); i++) {
+		if (temp <= (temp_limits[i] - hysteresis))
+			break;
+	}
+	if (speed > i)
+		speed = i;
+
+	if (fan->last_speed <= 0 && speed)
+		speed = 3; /* kick start motor */
+
+	gpd_pocket_fan_set_speed(fan, speed);
+
+	/* When mostly idle (low temp/speed), slow down the poll interval. */
+	queue_delayed_work(system_wq, &fan->work,
+			   msecs_to_jiffies(4000 / (speed + 1)));
+}
+
+static void gpd_pocket_fan_force_update(struct gpd_pocket_fan_data *fan)
+{
+	fan->last_speed = -1;
+	mod_delayed_work(system_wq, &fan->work, 0);
+}
+
+static int gpd_pocket_fan_probe(struct platform_device *pdev)
+{
+	struct gpd_pocket_fan_data *fan;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(temp_limits); i++) {
+		if (temp_limits[i] < 40000 || temp_limits[i] > 70000) {
+			dev_err(&pdev->dev, "Invalid temp-limit %d (must be between 40000 and 70000)\n",
+				temp_limits[i]);
+			return -EINVAL;
+		}
+	}
+	if (hysteresis < 1000 || hysteresis > 10000) {
+		dev_err(&pdev->dev, "Invalid hysteresis %d (must be between 1000 and 10000)\n",
+			hysteresis);
+		return -EINVAL;
+	}
+
+	fan = devm_kzalloc(&pdev->dev, sizeof(*fan), GFP_KERNEL);
+	if (!fan)
+		return -ENOMEM;
+
+	fan->dev = &pdev->dev;
+	INIT_DELAYED_WORK(&fan->work, gpd_pocket_fan_worker);
+
+	/* Note this returns a "weak" reference which we don't need to free */
+	fan->dts0 = thermal_zone_get_zone_by_name("soc_dts0");
+	if (IS_ERR(fan->dts0))
+		return -EPROBE_DEFER;
+
+	fan->dts1 = thermal_zone_get_zone_by_name("soc_dts1");
+	if (IS_ERR(fan->dts1))
+		return -EPROBE_DEFER;
+
+	fan->gpio0 = devm_gpiod_get_index(fan->dev, NULL, 0, GPIOD_ASIS);
+	if (IS_ERR(fan->gpio0))
+		return PTR_ERR(fan->gpio0);
+
+	fan->gpio1 = devm_gpiod_get_index(fan->dev, NULL, 1, GPIOD_ASIS);
+	if (IS_ERR(fan->gpio1))
+		return PTR_ERR(fan->gpio1);
+
+	gpd_pocket_fan_force_update(fan);
+
+	platform_set_drvdata(pdev, fan);
+	return 0;
+}
+
+static int gpd_pocket_fan_remove(struct platform_device *pdev)
+{
+	struct gpd_pocket_fan_data *fan = platform_get_drvdata(pdev);
+
+	cancel_delayed_work_sync(&fan->work);
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int gpd_pocket_fan_suspend(struct device *dev)
+{
+	struct gpd_pocket_fan_data *fan = dev_get_drvdata(dev);
+
+	gpd_pocket_fan_set_speed(fan, 0);
+	return 0;
+}
+
+static int gpd_pocket_fan_resume(struct device *dev)
+{
+	struct gpd_pocket_fan_data *fan = dev_get_drvdata(dev);
+
+	gpd_pocket_fan_force_update(fan);
+	return 0;
+}
+#endif
+static SIMPLE_DEV_PM_OPS(gpd_pocket_fan_pm_ops,
+			 gpd_pocket_fan_suspend,
+			 gpd_pocket_fan_resume);
+
+static struct acpi_device_id gpd_pocket_fan_acpi_match[] = {
+	{ "FAN02501" },
+	{},
+};
+MODULE_DEVICE_TABLE(acpi, gpd_pocket_fan_acpi_match);
+
+static struct platform_driver gpd_pocket_fan_driver = {
+	.probe	= gpd_pocket_fan_probe,
+	.remove	= gpd_pocket_fan_remove,
+	.driver	= {
+		.name			= "gpd_pocket_fan",
+		.acpi_match_table	= gpd_pocket_fan_acpi_match,
+		.pm			= &gpd_pocket_fan_pm_ops,
+	 },
+};
+
+module_platform_driver(gpd_pocket_fan_driver);
+MODULE_AUTHOR("Hans de Goede <hdegoede@redhat.com");
+MODULE_DESCRIPTION("GPD pocket fan driver");
+MODULE_LICENSE("GPL");
