commit e1eea3f839f41368d7cb4eb2d872d5b288677e94
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Wed Jun 24 10:51:38 2020 -0700

    platform/x86: ISST: Add new PCI device ids
    
    Added new PCI device ids for supporting mailbox and MMIO interface for
    Sapphire Rapids.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_speed_select_if/isst_if_mmio.c b/drivers/platform/x86/intel_speed_select_if/isst_if_mmio.c
index 3584859fcc42..aa17fd7817f8 100644
--- a/drivers/platform/x86/intel_speed_select_if/isst_if_mmio.c
+++ b/drivers/platform/x86/intel_speed_select_if/isst_if_mmio.c
@@ -72,6 +72,7 @@ static long isst_if_mmio_rd_wr(u8 *cmd_ptr, int *write_only, int resume)
 
 static const struct pci_device_id isst_if_ids[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, INTEL_RAPL_PRIO_DEVID_0)},
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, INTEL_RAPL_PRIO_DEVID_1)},
 	{ 0 },
 };
 MODULE_DEVICE_TABLE(pci, isst_if_ids);

commit 6cc8f6598978b8f30e70bc12f28fbbc9e26227cc
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Tue Mar 3 14:53:54 2020 -0800

    platform/x86: ISST: Fix wrong unregister type
    
    The MMIO driver is not unregistering with the correct type with the ISST
    common core during module removal. This should be unregistered with
    ISST_IF_DEV_MMIO instead of ISST_IF_DEV_MBOX.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_speed_select_if/isst_if_mmio.c b/drivers/platform/x86/intel_speed_select_if/isst_if_mmio.c
index ad8c7c0df4d9..3584859fcc42 100644
--- a/drivers/platform/x86/intel_speed_select_if/isst_if_mmio.c
+++ b/drivers/platform/x86/intel_speed_select_if/isst_if_mmio.c
@@ -126,7 +126,7 @@ static void isst_if_remove(struct pci_dev *pdev)
 	struct isst_if_device *punit_dev;
 
 	punit_dev = pci_get_drvdata(pdev);
-	isst_if_cdev_unregister(ISST_IF_DEV_MBOX);
+	isst_if_cdev_unregister(ISST_IF_DEV_MMIO);
 	mutex_destroy(&punit_dev->mutex);
 }
 

commit 5599e98fe06a88db55133ae8ac53f69216b82c6a
Author: Chuhong Yuan <hslester96@gmail.com>
Date:   Wed Jul 24 20:23:20 2019 +0800

    platform/x86: ISST: Use dev_get_drvdata
    
    Instead of using to_pci_dev + pci_get_drvdata,
    use dev_get_drvdata to make code simpler.
    
    Signed-off-by: Chuhong Yuan <hslester96@gmail.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_speed_select_if/isst_if_mmio.c b/drivers/platform/x86/intel_speed_select_if/isst_if_mmio.c
index f7266a115a08..ad8c7c0df4d9 100644
--- a/drivers/platform/x86/intel_speed_select_if/isst_if_mmio.c
+++ b/drivers/platform/x86/intel_speed_select_if/isst_if_mmio.c
@@ -132,11 +132,9 @@ static void isst_if_remove(struct pci_dev *pdev)
 
 static int __maybe_unused isst_if_suspend(struct device *device)
 {
-	struct pci_dev *pdev = to_pci_dev(device);
-	struct isst_if_device *punit_dev;
+	struct isst_if_device *punit_dev = dev_get_drvdata(device);
 	int i;
 
-	punit_dev = pci_get_drvdata(pdev);
 	for (i = 0; i < ARRAY_SIZE(punit_dev->range_0); ++i)
 		punit_dev->range_0[i] = readl(punit_dev->punit_mmio +
 						mmio_range[0].beg + 4 * i);
@@ -149,11 +147,9 @@ static int __maybe_unused isst_if_suspend(struct device *device)
 
 static int __maybe_unused isst_if_resume(struct device *device)
 {
-	struct pci_dev *pdev = to_pci_dev(device);
-	struct isst_if_device *punit_dev;
+	struct isst_if_device *punit_dev = dev_get_drvdata(device);
 	int i;
 
-	punit_dev = pci_get_drvdata(pdev);
 	for (i = 0; i < ARRAY_SIZE(punit_dev->range_0); ++i)
 		writel(punit_dev->range_0[i], punit_dev->punit_mmio +
 						mmio_range[0].beg + 4 * i);

commit f607874f35cbd276a837d7147d4e1ec752dfef44
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Wed Jun 26 15:38:50 2019 -0700

    platform/x86: ISST: Restore state on resume
    
    Commands which causes PUNIT writes, store them and restore them on system
    resume. The driver stores all such requests in a hash table and stores the
    the latest mailbox request parameters. On resume these commands mail box
    commands are executed again. There are only 5 such mail box commands which
    will trigger such processing so a very low overhead in store and execute
    on resume. Also there is no order requirement for mail box commands for
    these write/set commands. There is one MSR request for changing turbo
    ratio limits, this also stored and get restored on resume and cpu online.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_speed_select_if/isst_if_mmio.c b/drivers/platform/x86/intel_speed_select_if/isst_if_mmio.c
index 1c25a1235b9e..f7266a115a08 100644
--- a/drivers/platform/x86/intel_speed_select_if/isst_if_mmio.c
+++ b/drivers/platform/x86/intel_speed_select_if/isst_if_mmio.c
@@ -15,8 +15,20 @@
 
 #include "isst_if_common.h"
 
+struct isst_mmio_range {
+	int beg;
+	int end;
+};
+
+struct isst_mmio_range mmio_range[] = {
+	{0x04, 0x14},
+	{0x20, 0xD0},
+};
+
 struct isst_if_device {
 	void __iomem *punit_mmio;
+	u32 range_0[5];
+	u32 range_1[45];
 	struct mutex mutex;
 };
 
@@ -118,11 +130,48 @@ static void isst_if_remove(struct pci_dev *pdev)
 	mutex_destroy(&punit_dev->mutex);
 }
 
+static int __maybe_unused isst_if_suspend(struct device *device)
+{
+	struct pci_dev *pdev = to_pci_dev(device);
+	struct isst_if_device *punit_dev;
+	int i;
+
+	punit_dev = pci_get_drvdata(pdev);
+	for (i = 0; i < ARRAY_SIZE(punit_dev->range_0); ++i)
+		punit_dev->range_0[i] = readl(punit_dev->punit_mmio +
+						mmio_range[0].beg + 4 * i);
+	for (i = 0; i < ARRAY_SIZE(punit_dev->range_1); ++i)
+		punit_dev->range_1[i] = readl(punit_dev->punit_mmio +
+						mmio_range[1].beg + 4 * i);
+
+	return 0;
+}
+
+static int __maybe_unused isst_if_resume(struct device *device)
+{
+	struct pci_dev *pdev = to_pci_dev(device);
+	struct isst_if_device *punit_dev;
+	int i;
+
+	punit_dev = pci_get_drvdata(pdev);
+	for (i = 0; i < ARRAY_SIZE(punit_dev->range_0); ++i)
+		writel(punit_dev->range_0[i], punit_dev->punit_mmio +
+						mmio_range[0].beg + 4 * i);
+	for (i = 0; i < ARRAY_SIZE(punit_dev->range_1); ++i)
+		writel(punit_dev->range_1[i], punit_dev->punit_mmio +
+						mmio_range[1].beg + 4 * i);
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(isst_if_pm_ops, isst_if_suspend, isst_if_resume);
+
 static struct pci_driver isst_if_pci_driver = {
 	.name			= "isst_if_pci",
 	.id_table		= isst_if_ids,
 	.probe			= isst_if_probe,
 	.remove			= isst_if_remove,
+	.driver.pm		= &isst_if_pm_ops,
 };
 
 module_pci_driver(isst_if_pci_driver);

commit d3a23584294c1f379239a3b52bac13e03fecd147
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Wed Jun 26 15:38:46 2019 -0700

    platform/x86: ISST: Add Intel Speed Select mmio interface
    
    Added MMIO interface to read/write specific offsets in PUNIT PCI device
    which export core priortization. This MMIO interface can be used using
    ioctl interface on /dev/isst_interface using IOCTL ISST_IF_IO_CMD.
    
    This MMIO interface is used by the intel-speed-select tool under
    tools/x86/power to enumerate and set core priority. The MMIO offsets and
    semantics of the message can be checked from the source code of the tool.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_speed_select_if/isst_if_mmio.c b/drivers/platform/x86/intel_speed_select_if/isst_if_mmio.c
new file mode 100644
index 000000000000..1c25a1235b9e
--- /dev/null
+++ b/drivers/platform/x86/intel_speed_select_if/isst_if_mmio.c
@@ -0,0 +1,131 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Intel Speed Select Interface: MMIO Interface
+ * Copyright (c) 2019, Intel Corporation.
+ * All rights reserved.
+ *
+ * Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+ */
+
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/sched/signal.h>
+#include <linux/uaccess.h>
+#include <uapi/linux/isst_if.h>
+
+#include "isst_if_common.h"
+
+struct isst_if_device {
+	void __iomem *punit_mmio;
+	struct mutex mutex;
+};
+
+static long isst_if_mmio_rd_wr(u8 *cmd_ptr, int *write_only, int resume)
+{
+	struct isst_if_device *punit_dev;
+	struct isst_if_io_reg *io_reg;
+	struct pci_dev *pdev;
+
+	io_reg = (struct isst_if_io_reg *)cmd_ptr;
+	if (io_reg->reg < 0x04 || io_reg->reg > 0xD0)
+		return -EINVAL;
+
+	if (io_reg->read_write && !capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	pdev = isst_if_get_pci_dev(io_reg->logical_cpu, 0, 0, 1);
+	if (!pdev)
+		return -EINVAL;
+
+	punit_dev = pci_get_drvdata(pdev);
+	if (!punit_dev)
+		return -EINVAL;
+
+	/*
+	 * Ensure that operation is complete on a PCI device to avoid read
+	 * write race by using per PCI device mutex.
+	 */
+	mutex_lock(&punit_dev->mutex);
+	if (io_reg->read_write) {
+		writel(io_reg->value, punit_dev->punit_mmio+io_reg->reg);
+		*write_only = 1;
+	} else {
+		io_reg->value = readl(punit_dev->punit_mmio+io_reg->reg);
+		*write_only = 0;
+	}
+	mutex_unlock(&punit_dev->mutex);
+
+	return 0;
+}
+
+static const struct pci_device_id isst_if_ids[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, INTEL_RAPL_PRIO_DEVID_0)},
+	{ 0 },
+};
+MODULE_DEVICE_TABLE(pci, isst_if_ids);
+
+static int isst_if_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	struct isst_if_device *punit_dev;
+	struct isst_if_cmd_cb cb;
+	u32 mmio_base, pcu_base;
+	u64 base_addr;
+	int ret;
+
+	punit_dev = devm_kzalloc(&pdev->dev, sizeof(*punit_dev), GFP_KERNEL);
+	if (!punit_dev)
+		return -ENOMEM;
+
+	ret = pcim_enable_device(pdev);
+	if (ret)
+		return ret;
+
+	ret = pci_read_config_dword(pdev, 0xD0, &mmio_base);
+	if (ret)
+		return ret;
+
+	ret = pci_read_config_dword(pdev, 0xFC, &pcu_base);
+	if (ret)
+		return ret;
+
+	pcu_base &= GENMASK(10, 0);
+	base_addr = (u64)mmio_base << 23 | (u64) pcu_base << 12;
+	punit_dev->punit_mmio = devm_ioremap(&pdev->dev, base_addr, 256);
+	if (!punit_dev->punit_mmio)
+		return -ENOMEM;
+
+	mutex_init(&punit_dev->mutex);
+	pci_set_drvdata(pdev, punit_dev);
+
+	memset(&cb, 0, sizeof(cb));
+	cb.cmd_size = sizeof(struct isst_if_io_reg);
+	cb.offset = offsetof(struct isst_if_io_regs, io_reg);
+	cb.cmd_callback = isst_if_mmio_rd_wr;
+	cb.owner = THIS_MODULE;
+	ret = isst_if_cdev_register(ISST_IF_DEV_MMIO, &cb);
+	if (ret)
+		mutex_destroy(&punit_dev->mutex);
+
+	return ret;
+}
+
+static void isst_if_remove(struct pci_dev *pdev)
+{
+	struct isst_if_device *punit_dev;
+
+	punit_dev = pci_get_drvdata(pdev);
+	isst_if_cdev_unregister(ISST_IF_DEV_MBOX);
+	mutex_destroy(&punit_dev->mutex);
+}
+
+static struct pci_driver isst_if_pci_driver = {
+	.name			= "isst_if_pci",
+	.id_table		= isst_if_ids,
+	.probe			= isst_if_probe,
+	.remove			= isst_if_remove,
+};
+
+module_pci_driver(isst_if_pci_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Intel speed select interface mmio driver");
