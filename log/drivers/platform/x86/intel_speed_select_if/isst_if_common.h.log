commit e1eea3f839f41368d7cb4eb2d872d5b288677e94
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Wed Jun 24 10:51:38 2020 -0700

    platform/x86: ISST: Add new PCI device ids
    
    Added new PCI device ids for supporting mailbox and MMIO interface for
    Sapphire Rapids.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_speed_select_if/isst_if_common.h b/drivers/platform/x86/intel_speed_select_if/isst_if_common.h
index 1409a5bb5582..4f6f7f0761fc 100644
--- a/drivers/platform/x86/intel_speed_select_if/isst_if_common.h
+++ b/drivers/platform/x86/intel_speed_select_if/isst_if_common.h
@@ -13,6 +13,9 @@
 #define INTEL_RAPL_PRIO_DEVID_0	0x3451
 #define INTEL_CFG_MBOX_DEVID_0	0x3459
 
+#define INTEL_RAPL_PRIO_DEVID_1 0x3251
+#define INTEL_CFG_MBOX_DEVID_1  0x3259
+
 /*
  * Validate maximum commands in a single request.
  * This is enough to handle command to every core in one ioctl, or all

commit f607874f35cbd276a837d7147d4e1ec752dfef44
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Wed Jun 26 15:38:50 2019 -0700

    platform/x86: ISST: Restore state on resume
    
    Commands which causes PUNIT writes, store them and restore them on system
    resume. The driver stores all such requests in a hash table and stores the
    the latest mailbox request parameters. On resume these commands mail box
    commands are executed again. There are only 5 such mail box commands which
    will trigger such processing so a very low overhead in store and execute
    on resume. Also there is no order requirement for mail box commands for
    these write/set commands. There is one MSR request for changing turbo
    ratio limits, this also stored and get restored on resume and cpu online.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_speed_select_if/isst_if_common.h b/drivers/platform/x86/intel_speed_select_if/isst_if_common.h
index 7c0f71221da7..1409a5bb5582 100644
--- a/drivers/platform/x86/intel_speed_select_if/isst_if_common.h
+++ b/drivers/platform/x86/intel_speed_select_if/isst_if_common.h
@@ -63,4 +63,7 @@ void isst_if_cdev_unregister(int type);
 struct pci_dev *isst_if_get_pci_dev(int cpu, int bus, int dev, int fn);
 bool isst_if_mbox_cmd_set_req(struct isst_if_mbox_cmd *mbox_cmd);
 bool isst_if_mbox_cmd_invalid(struct isst_if_mbox_cmd *cmd);
+int isst_store_cmd(int cmd, int sub_command, u32 cpu, int mbox_cmd,
+		   u32 param, u64 data);
+void isst_resume_common(void);
 #endif

commit 31a166fe9c269af17977e650846ee4ea50361c07
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Wed Jun 26 15:38:47 2019 -0700

    platform/x86: ISST: Add Intel Speed Select mailbox interface via PCI
    
    Add an IOCTL to send mailbox commands to PUNIT using PUNIT PCI device.
    A limited set of mailbox commands can be sent to PUNIT.
    
    This MMIO interface is used by the intel-speed-select tool under
    tools/x86/power to enumerate and control Intel Speed Select features.
    The MBOX commands ids and semantics of the message can be checked from
    the source code of the tool.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_speed_select_if/isst_if_common.h b/drivers/platform/x86/intel_speed_select_if/isst_if_common.h
index cdc7d019748a..7c0f71221da7 100644
--- a/drivers/platform/x86/intel_speed_select_if/isst_if_common.h
+++ b/drivers/platform/x86/intel_speed_select_if/isst_if_common.h
@@ -11,6 +11,7 @@
 #define __ISST_IF_COMMON_H
 
 #define INTEL_RAPL_PRIO_DEVID_0	0x3451
+#define INTEL_CFG_MBOX_DEVID_0	0x3459
 
 /*
  * Validate maximum commands in a single request.
@@ -60,4 +61,6 @@ struct isst_if_cmd_cb {
 int isst_if_cdev_register(int type, struct isst_if_cmd_cb *cb);
 void isst_if_cdev_unregister(int type);
 struct pci_dev *isst_if_get_pci_dev(int cpu, int bus, int dev, int fn);
+bool isst_if_mbox_cmd_set_req(struct isst_if_mbox_cmd *mbox_cmd);
+bool isst_if_mbox_cmd_invalid(struct isst_if_mbox_cmd *cmd);
 #endif

commit d3a23584294c1f379239a3b52bac13e03fecd147
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Wed Jun 26 15:38:46 2019 -0700

    platform/x86: ISST: Add Intel Speed Select mmio interface
    
    Added MMIO interface to read/write specific offsets in PUNIT PCI device
    which export core priortization. This MMIO interface can be used using
    ioctl interface on /dev/isst_interface using IOCTL ISST_IF_IO_CMD.
    
    This MMIO interface is used by the intel-speed-select tool under
    tools/x86/power to enumerate and set core priority. The MMIO offsets and
    semantics of the message can be checked from the source code of the tool.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_speed_select_if/isst_if_common.h b/drivers/platform/x86/intel_speed_select_if/isst_if_common.h
index dade77c58b22..cdc7d019748a 100644
--- a/drivers/platform/x86/intel_speed_select_if/isst_if_common.h
+++ b/drivers/platform/x86/intel_speed_select_if/isst_if_common.h
@@ -10,6 +10,8 @@
 #ifndef __ISST_IF_COMMON_H
 #define __ISST_IF_COMMON_H
 
+#define INTEL_RAPL_PRIO_DEVID_0	0x3451
+
 /*
  * Validate maximum commands in a single request.
  * This is enough to handle command to every core in one ioctl, or all

commit 8fbfb6fc67819c1274584ff902f7d03aafe38dab
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Wed Jun 26 15:38:44 2019 -0700

    platform/x86: ISST: Store per CPU information
    
    There are two per CPU data needs to be stored and cached to avoid repeated
    MSR readings for accessing them later:
    
    - Physical to logical CPU conversion
    The PUNIT uses a different CPU numbering scheme which is not APIC id based.
    So we need to establish relationship between PUNIT CPU number and Linux
    logical CPU numbering which is based on APIC id. There is an MSR 0x53
    (MSR_THREAD_ID), which gets physical CPU number for the local CPU where it
    is read. Also the CPU mask in some messages will inform which CPUs needs
    to be online/offline for a TDP level. During TDP switch if user offlined
    some CPUs, then the physical CPU mask can't be converted as we can't
    read MSR on an offlined CPU to go to a lower TDP level by onlining more
    CPUs. So the mapping needs to be established at the boot up time.
    
    - Bus number corresponding to a CPU
    A group of CPUs are in a control of a PUNIT. The PUNIT device is exported
    as PCI device. To do operation on a PUNIT for a CPU, we need to find out
    to which PCI device it is related to. This is done by reading MSR 0x128
    (MSR_CPU_BUS_NUMBER).
    
    So during CPU online stages the above MSRs are read and stored. Later
    this stored information is used to process IOCTLs request from the user
    space.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_speed_select_if/isst_if_common.h b/drivers/platform/x86/intel_speed_select_if/isst_if_common.h
index 11f339226fb4..dade77c58b22 100644
--- a/drivers/platform/x86/intel_speed_select_if/isst_if_common.h
+++ b/drivers/platform/x86/intel_speed_select_if/isst_if_common.h
@@ -57,4 +57,5 @@ struct isst_if_cmd_cb {
 /* Internal interface functions */
 int isst_if_cdev_register(int type, struct isst_if_cmd_cb *cb);
 void isst_if_cdev_unregister(int type);
+struct pci_dev *isst_if_get_pci_dev(int cpu, int bus, int dev, int fn);
 #endif

commit 35f2c14d2a076b063a76c5bf275c46c0743ba3a0
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Wed Jun 26 15:38:43 2019 -0700

    platform/x86: ISST: Add common API to register and handle ioctls
    
    Encapsulate common functions which all Intel Speed Select Technology
    interface drivers can use. This creates API to register misc device for
    user kernel communication and handle all common IOCTLs. As part of the
    registry it allows a callback which is to handle domain specific ioctl
    processing.
    
    There can be multiple drivers register for services, which can be built
    as modules. So this driver handle contention during registry and as well
    as during removal. Once user space opened the misc device, the registered
    driver will be prevented from removal. Also once misc device is opened by
    the user space new client driver can't register, till the misc device is
    closed.
    
    There are two types of client drivers, one to handle mail box interface
    and the other is to allow direct read/write to some specific MMIO space.
    
    This common driver implements IOCTL ISST_IF_GET_PLATFORM_INFO.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel_speed_select_if/isst_if_common.h b/drivers/platform/x86/intel_speed_select_if/isst_if_common.h
new file mode 100644
index 000000000000..11f339226fb4
--- /dev/null
+++ b/drivers/platform/x86/intel_speed_select_if/isst_if_common.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Intel Speed Select Interface: Drivers Internal defines
+ * Copyright (c) 2019, Intel Corporation.
+ * All rights reserved.
+ *
+ * Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+ */
+
+#ifndef __ISST_IF_COMMON_H
+#define __ISST_IF_COMMON_H
+
+/*
+ * Validate maximum commands in a single request.
+ * This is enough to handle command to every core in one ioctl, or all
+ * possible message id to one CPU. Limit is also helpful for resonse time
+ * per IOCTL request, as PUNIT may take different times to process each
+ * request and may hold for long for too many commands.
+ */
+#define ISST_IF_CMD_LIMIT	64
+
+#define ISST_IF_API_VERSION	0x01
+#define ISST_IF_DRIVER_VERSION	0x01
+
+#define ISST_IF_DEV_MBOX	0
+#define ISST_IF_DEV_MMIO	1
+#define ISST_IF_DEV_MAX		2
+
+/**
+ * struct isst_if_cmd_cb - Used to register a IOCTL handler
+ * @registered:	Used by the common code to store registry. Caller don't
+ *		to touch this field
+ * @cmd_size:	The command size of the individual command in IOCTL
+ * @offset:	Offset to the first valid member in command structure.
+ *		This will be the offset of the start of the command
+ *		after command count field
+ * @cmd_callback: Callback function to handle IOCTL. The callback has the
+ *		command pointer with data for command. There is a pointer
+ *		called write_only, which when set, will not copy the
+ *		response to user ioctl buffer. The "resume" argument
+ *		can be used to avoid storing the command for replay
+ *		during system resume
+ *
+ * This structure is used to register an handler for IOCTL. To avoid
+ * code duplication common code handles all the IOCTL command read/write
+ * including handling multiple command in single IOCTL. The caller just
+ * need to execute a command via the registered callback.
+ */
+struct isst_if_cmd_cb {
+	int registered;
+	int cmd_size;
+	int offset;
+	struct module *owner;
+	long (*cmd_callback)(u8 *ptr, int *write_only, int resume);
+};
+
+/* Internal interface functions */
+int isst_if_cdev_register(int type, struct isst_if_cmd_cb *cb);
+void isst_if_cdev_unregister(int type);
+#endif
