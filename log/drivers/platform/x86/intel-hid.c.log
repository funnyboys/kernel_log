commit 8fe63eb757ac6e661a384cc760792080bdc738dc
Author: Nickolai Kozachenko <daemongloom@gmail.com>
Date:   Sat May 30 22:07:20 2020 +0500

    platform/x86: intel-hid: Add a quirk to support HP Spectre X2 (2015)
    
    HEBC method reports capabilities of 5 button array but HP Spectre X2 (2015)
    does not have this control method (the same was for Wacom MobileStudio Pro).
    Expand previous DMI quirk by Alex Hung to also enable 5 button array
    for this system.
    
    Signed-off-by: Nickolai Kozachenko <daemongloom@gmail.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index cc7dd4d87cce..9ee79b74311c 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -79,6 +79,13 @@ static const struct dmi_system_id button_array_table[] = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "Wacom MobileStudio Pro 16"),
 		},
 	},
+	{
+		.ident = "HP Spectre x2 (2015)",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "HP"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "HP Spectre x2 Detachable"),
+		},
+	},
 	{ }
 };
 

commit 7e63420847ae5f1036e4f7c42f0b3282e73efbc2
Merge: ef05db16bbd8 33ae7f715e30
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 6 10:35:06 2020 -0700

    Merge tag 'acpi-5.7-rc1-2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull more ACPI updates from Rafael Wysocki:
     "Additional ACPI updates.
    
      These update the ACPICA code in the kernel to the 20200326 upstream
      revision, fix an ACPI-related CPU hotplug deadlock on x86, update
      Intel Tiger Lake device IDs in some places, add a new ACPI backlight
      blacklist entry, update the "acpi_backlight" kernel command line
      switch documentation and clean up a CPPC library routine.
    
      Specifics:
    
       - Update the ACPICA code in the kernel to upstream revision 20200326
         including:
          * Fix for a typo in a comment field (Bob Moore)
          * acpiExec namespace init file fixes (Bob Moore)
          * Addition of NHLT to the known tables list (Cezary Rojewski)
          * Conversion of PlatformCommChannel ASL keyword to PCC (Erik
            Kaneda)
          * acpiexec cleanup (Erik Kaneda)
          * WSMT-related typo fix (Erik Kaneda)
          * sprintf() utility function fix (John Levon)
          * IVRS IVHD type 11h parsing implementation (Michał Żygowski)
          * IVRS IVHD type 10h reserved field name fix (Michał Żygowski)
    
       - Fix ACPI-related CPU hotplug deadlock on x86 (Qian Cai)
    
       - Fix Intel Tiger Lake ACPI device IDs in several places (Gayatri
         Kammela)
    
       - Add ACPI backlight blacklist entry for Acer Aspire 5783z (Hans de
         Goede)
    
       - Fix documentation of the "acpi_backlight" kernel command line
         switch (Randy Dunlap)
    
       - Clean up the acpi_get_psd_map() CPPC library routine (Liguang
         Zhang)"
    
    * tag 'acpi-5.7-rc1-2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      x86: ACPI: fix CPU hotplug deadlock
      thermal: int340x_thermal: fix: Update Tiger Lake ACPI device IDs
      platform/x86: intel-hid: fix: Update Tiger Lake ACPI device ID
      ACPI: Update Tiger Lake ACPI device IDs
      ACPI: video: Use native backlight on Acer Aspire 5783z
      ACPI: video: Docs update for "acpi_backlight" kernel parameter options
      ACPICA: Update version 20200326
      ACPICA: Fixes for acpiExec namespace init file
      ACPICA: Add NHLT table signature
      ACPICA: WSMT: Fix typo, no functional change
      ACPICA: utilities: fix sprintf()
      ACPICA: acpiexec: remove redeclaration of acpi_gbl_db_opt_no_region_support
      ACPICA: Change PlatformCommChannel ASL keyword to PCC
      ACPICA: Fix IVRS IVHD type 10h reserved field name
      ACPICA: Implement IVRS IVHD type 11h parsing
      ACPICA: Fix a typo in a comment field
      ACPI: CPPC: clean up acpi_get_psd_map()

commit d5764dc597467664a1a70ab66a2314a011aeccd4
Author: Gayatri Kammela <gayatri.kammela@intel.com>
Date:   Fri Mar 27 14:28:20 2020 -0700

    platform/x86: intel-hid: fix: Update Tiger Lake ACPI device ID
    
    Tiger Lake's new unique ACPI device IDs for intel-hid driver is not
    valid because of missing 'C' in the ID. Fix the ID by updating it.
    
    After the update, the new ID should now look like
    INT1051 --> INTC1051
    
    Fixes: bdd11b654035 ("platform/x86: intel-hid: Add Tiger Lake ACPI device ID")
    Suggested-by: Srinivas Pandruvada <srinivas.pandruvada@intel.com>
    Signed-off-by: Gayatri Kammela <gayatri.kammela@intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index 43d590250228..9c0e6e0fabdf 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -19,8 +19,8 @@ MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Alex Hung");
 
 static const struct acpi_device_id intel_hid_ids[] = {
-	{"INT1051", 0},
 	{"INT33D5", 0},
+	{"INTC1051", 0},
 	{"", 0},
 };
 

commit 57ba2633a1b618816fdee85d5baa52f1874ee07f
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Jan 28 12:26:21 2020 +0200

    platform/x86: intel-hid: Move MODULE_DEVICE_TABLE() closer to the table
    
    Move MODULE_DEVICE_TABLE() closer to the table for better maintenance.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index 43d590250228..5f4f5716c893 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -23,6 +23,7 @@ static const struct acpi_device_id intel_hid_ids[] = {
 	{"INT33D5", 0},
 	{"", 0},
 };
+MODULE_DEVICE_TABLE(acpi, intel_hid_ids);
 
 /* In theory, these are HID usages. */
 static const struct key_entry intel_hid_keymap[] = {
@@ -541,7 +542,6 @@ static struct platform_driver intel_hid_pl_driver = {
 	.probe = intel_hid_probe,
 	.remove = intel_hid_remove,
 };
-MODULE_DEVICE_TABLE(acpi, intel_hid_ids);
 
 /*
  * Unfortunately, some laptops provide a _HID="INT33D5" device with

commit bdd11b6540358f25c1eb1e21c1b92bd6276f5e53
Author: Gayatri Kammela <gayatri.kammela@intel.com>
Date:   Mon Dec 16 10:31:51 2019 -0800

    platform/x86: intel-hid: Add Tiger Lake ACPI device ID
    
    Tiger Lake has a new unique ACPI device ID for the Intel HID event
    filter device that needs to be added to the intel-hid driver to
    support it.
    
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Gayatri Kammela <gayatri.kammela@intel.com>
    [ rjw: Subject and changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index ef6d4bd77b1a..43d590250228 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -19,6 +19,7 @@ MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Alex Hung");
 
 static const struct acpi_device_id intel_hid_ids[] = {
+	{"INT1051", 0},
 	{"INT33D5", 0},
 	{"", 0},
 };

commit b90ff3554aa3e123bb7e6d08789f6fd92d86ddde
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Aug 21 11:40:19 2019 +0200

    ACPI: PM: s2idle: Always set up EC GPE for system wakeup
    
    Commit 10a08fd65ec1 ("ACPI: PM: Set up EC GPE for system wakeup from
    drivers that need it") assumed that the EC GPE would only need to be
    set up for system wakeup if either the intel-hid or the intel-vbtn
    driver was in use, but that turns out to be incorrect.  In particular,
    on ASUS Zenbook UX430UNR/i7-8550U, if the EC GPE is not enabled while
    suspended, the system cannot be woken up by opening the lid or
    pressing a key, and that machine doesn't use any of the drivers
    mentioned above.
    
    For this reason, always set up the EC GPE for system wakeup from
    suspend-to-idle by setting and clearing its wake mask in the ACPI
    suspend-to-idle callbacks.
    
    Fixes: 10a08fd65ec1 ("ACPI: PM: Set up EC GPE for system wakeup from drivers that need it")
    Reported-by: Kristian Klausen <kristian@klausen.dk>
    Tested-by: Kristian Klausen <kristian@klausen.dk>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index 18ac237114ff..ef6d4bd77b1a 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -257,7 +257,6 @@ static int intel_hid_pm_prepare(struct device *device)
 		struct intel_hid_priv *priv = dev_get_drvdata(device);
 
 		priv->wakeup_mode = true;
-		acpi_ec_set_gpe_wake_mask(ACPI_GPE_ENABLE);
 	}
 	return 0;
 }
@@ -266,10 +265,7 @@ static void intel_hid_pm_complete(struct device *device)
 {
 	struct intel_hid_priv *priv = dev_get_drvdata(device);
 
-	if (priv->wakeup_mode) {
-		acpi_ec_set_gpe_wake_mask(ACPI_GPE_DISABLE);
-		priv->wakeup_mode = false;
-	}
+	priv->wakeup_mode = false;
 }
 
 static int intel_hid_pl_suspend_handler(struct device *device)

commit d19bdb876bece27187d4ffbc272672e1239cd313
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Aug 8 11:39:23 2019 +0200

    intel-hid: Disable button array during suspend-to-idle
    
    Notice that intel_button_array_enable() never disables the power
    button which is the only one needed to wake up the system from
    suspend-to-idle, so it can be safely called during suspend-to-idle
    as well as during "regular" system suspend, and rearrange the
    code in the driver's "suspend" and "resume" callbacks accordingly.
    
    While at it, use pm_suspend_no_platform() to check if the current
    suspend-resume cycle is suspend-to-idle, as that is the only
    case when the device should be enabled while suspended.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index 6feda887df9d..18ac237114ff 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -274,10 +274,11 @@ static void intel_hid_pm_complete(struct device *device)
 
 static int intel_hid_pl_suspend_handler(struct device *device)
 {
-	if (pm_suspend_via_firmware()) {
+	intel_button_array_enable(device, false);
+
+	if (!pm_suspend_no_platform())
 		intel_hid_set_enable(device, false);
-		intel_button_array_enable(device, false);
-	}
+
 	return 0;
 }
 
@@ -285,10 +286,10 @@ static int intel_hid_pl_resume_handler(struct device *device)
 {
 	intel_hid_pm_complete(device);
 
-	if (pm_resume_via_firmware()) {
+	if (!pm_suspend_no_platform())
 		intel_hid_set_enable(device, true);
-		intel_button_array_enable(device, true);
-	}
+
+	intel_button_array_enable(device, true);
 	return 0;
 }
 

commit 31eb845718398f9bc9f6fbe1aca675f4e6284392
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Aug 8 11:39:17 2019 +0200

    intel-hid: intel-vbtn: Avoid leaking wakeup_mode set
    
    Both intel-hid and intel-vbtn set a wakeup_mode flag causing them
    to behave in a special way during system suspend and while suspended
    in their "prepare" PM callbacks and clear it in their "resume" PM
    callbacks.  That may cause the wakeup_mode flag to remain set after
    a system suspend failure (if some other driver's "suspend" callback
    returns an error before the "suspend" callback of either intel-hid
    or intel-vbtn is invoked).
    
    After commit 10a08fd65ec1 ("ACPI: PM: Set up EC GPE for system wakeup
    from drivers that need it") that also affects the "wakeup mask" bit
    of the EC GPE, which may not be cleared after a failing system
    suspend.
    
    Fix this issue by adding "complete" PM callbacks to intel-hid and
    intel-vbtn to clear the wakeup_mode flag and the "wakeup mask" bit
    of the EC GPE if they have not been cleared earlier.
    
    Fixes: 10a08fd65ec1 ("ACPI: PM: Set up EC GPE for system wakeup from drivers that need it")
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index e51c72b92cbd..6feda887df9d 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -262,6 +262,16 @@ static int intel_hid_pm_prepare(struct device *device)
 	return 0;
 }
 
+static void intel_hid_pm_complete(struct device *device)
+{
+	struct intel_hid_priv *priv = dev_get_drvdata(device);
+
+	if (priv->wakeup_mode) {
+		acpi_ec_set_gpe_wake_mask(ACPI_GPE_DISABLE);
+		priv->wakeup_mode = false;
+	}
+}
+
 static int intel_hid_pl_suspend_handler(struct device *device)
 {
 	if (pm_suspend_via_firmware()) {
@@ -273,12 +283,8 @@ static int intel_hid_pl_suspend_handler(struct device *device)
 
 static int intel_hid_pl_resume_handler(struct device *device)
 {
-	if (device_may_wakeup(device)) {
-		struct intel_hid_priv *priv = dev_get_drvdata(device);
+	intel_hid_pm_complete(device);
 
-		acpi_ec_set_gpe_wake_mask(ACPI_GPE_DISABLE);
-		priv->wakeup_mode = false;
-	}
 	if (pm_resume_via_firmware()) {
 		intel_hid_set_enable(device, true);
 		intel_button_array_enable(device, true);
@@ -288,6 +294,7 @@ static int intel_hid_pl_resume_handler(struct device *device)
 
 static const struct dev_pm_ops intel_hid_pl_pm_ops = {
 	.prepare = intel_hid_pm_prepare,
+	.complete = intel_hid_pm_complete,
 	.freeze  = intel_hid_pl_suspend_handler,
 	.thaw  = intel_hid_pl_resume_handler,
 	.restore  = intel_hid_pl_resume_handler,

commit 10a08fd65ec1a68ccd86b19ec822ed5f2e50113f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jul 30 11:55:59 2019 +0200

    ACPI: PM: Set up EC GPE for system wakeup from drivers that need it
    
    The EC GPE needs to be set up for system wakeup only if there is a
    driver depending on it, either intel-hid or intel-vbtn, bound to a
    button device that is expected to wake up the system from sleep (such
    as the power button on some Dell systems, like the XPS13 9360).  It
    doesn't need to be set up for waking up the system from sleep in any
    other cases and whether or not it is expected to wake up the system
    from sleep doesn't depend on whether or not the LPS0 device is
    present in the ACPI namespace.
    
    For this reason, rearrange the ACPI suspend-to-idle code to make the
    drivers depending on the EC GPE wakeup take care of setting it up and
    decouple that from the LPS0 device handling.
    
    While at it, make intel-hid and intel-vbtn prepare for system wakeup
    only if they are allowed to wake up the system from sleep by user
    space (via sysfs).
    
    [Note that acpi_ec_mark_gpe_for_wake() and acpi_ec_set_gpe_wake_mask()
     are there to prevent the EC GPE from being disabled by the
     acpi_enable_all_wakeup_gpes() call in acpi_s2idle_prepare(), so on
     systems with either intel-hid or intel-vbtn this change doesn't
     affect any interactions with the hardware or platform firmware.]
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index bc0d55a59015..e51c72b92cbd 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -253,9 +253,12 @@ static void intel_button_array_enable(struct device *device, bool enable)
 
 static int intel_hid_pm_prepare(struct device *device)
 {
-	struct intel_hid_priv *priv = dev_get_drvdata(device);
+	if (device_may_wakeup(device)) {
+		struct intel_hid_priv *priv = dev_get_drvdata(device);
 
-	priv->wakeup_mode = true;
+		priv->wakeup_mode = true;
+		acpi_ec_set_gpe_wake_mask(ACPI_GPE_ENABLE);
+	}
 	return 0;
 }
 
@@ -270,9 +273,12 @@ static int intel_hid_pl_suspend_handler(struct device *device)
 
 static int intel_hid_pl_resume_handler(struct device *device)
 {
-	struct intel_hid_priv *priv = dev_get_drvdata(device);
+	if (device_may_wakeup(device)) {
+		struct intel_hid_priv *priv = dev_get_drvdata(device);
 
-	priv->wakeup_mode = false;
+		acpi_ec_set_gpe_wake_mask(ACPI_GPE_DISABLE);
+		priv->wakeup_mode = false;
+	}
 	if (pm_resume_via_firmware()) {
 		intel_hid_set_enable(device, true);
 		intel_button_array_enable(device, true);
@@ -491,6 +497,12 @@ static int intel_hid_probe(struct platform_device *device)
 	}
 
 	device_init_wakeup(&device->dev, true);
+	/*
+	 * In order for system wakeup to work, the EC GPE has to be marked as
+	 * a wakeup one, so do that here (this setting will persist, but it has
+	 * no effect until the wakeup mask is set for the EC GPE).
+	 */
+	acpi_ec_mark_gpe_for_wake();
 	return 0;
 
 err_remove_notify:

commit e97a34563d18606ee5db93e495382a967f999cd4
Author: Jérôme de Bretagne <jerome.debretagne@gmail.com>
Date:   Sun Jan 6 18:56:44 2019 +0100

    platform/x86: intel-hid: Missing power button release on some Dell models
    
    Power button suspend for some Dell models was added in:
    
    commit 821b85366284 ("platform/x86: intel-hid: Power button suspend on Dell Latitude 7275")
    
    by checking against the power button press notification (0xCE) to report
    the power button press event. The corresponding power button release
    notification (0xCF) was caught and ignored to stop it from being reported
    as an "unknown event" in the logs.
    
    The missing button release event is creating issues on Android-x86, as
    reported on the project mailing list for a Dell Latitude 5175 model, since
    the events are expected in down/up pairs.
    
    Report the power button release event to fix this issue.
    
    Link: https://groups.google.com/forum/#!topic/android-x86/aSwZK9Nf9Ro
    Tested-by: Tristian Celestin <tristian.celestin@outlook.com>
    Tested-by: Jérôme de Bretagne <jerome.debretagne@gmail.com>
    Signed-off-by: Jérôme de Bretagne <jerome.debretagne@gmail.com>
    Reviewed-by: Mario Limonciello <mario.limonciello@dell.com>
    [dvhart: corrected commit reference format per checkpatch]
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index e28bcf61b126..bc0d55a59015 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -363,7 +363,7 @@ static void notify_handler(acpi_handle handle, u32 event, void *context)
 	 * the 5-button array, but still send notifies with power button
 	 * event code to this device object on power button actions.
 	 *
-	 * Report the power button press; catch and ignore the button release.
+	 * Report the power button press and release.
 	 */
 	if (!priv->array) {
 		if (event == 0xce) {
@@ -372,8 +372,11 @@ static void notify_handler(acpi_handle handle, u32 event, void *context)
 			return;
 		}
 
-		if (event == 0xcf)
+		if (event == 0xcf) {
+			input_report_key(priv->input_dev, KEY_POWER, 0);
+			input_sync(priv->input_dev);
 			return;
+		}
 	}
 
 	/* 0xC0 is for HID events, other values are for 5 button array */

commit 31daa5dd32fc77d3114ad0f6e1a2f1aedfe43616
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Sep 26 18:27:40 2018 +0300

    platform/x86: intel-hid: Convert to use SPDX identifier
    
    Reduce size of duplicated comments by switching to use SPDX identifier.
    
    No functional change.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index 6cf9b7fa5bf0..e28bcf61b126 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -1,19 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  *  Intel HID event & 5 button array driver
  *
  *  Copyright (C) 2015 Alex Hung <alex.hung@canonical.com>
  *  Copyright (C) 2015 Andrew Lutomirski <luto@kernel.org>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
  */
 
 #include <linux/acpi.h>

commit 5bf24e20d18f8335420149894988b2501d70319f
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Jun 28 11:19:06 2018 -0700

    platform/x86: intel-hid: Add support for Device Specific Methods
    
    In some of the recent platforms, it is possible that stand alone methods
    for HEBC() or other methods used in this driver may not exist. In this
    case intel-hid driver will fail to load and power button will not be
    functional.
    
    It is also possible that some quirks in this driver added for some
    platforms may have same issue in loading intel-hid driver.
    
    There is an update to the ACPI details for the HID event filter driver.
    In the updated specification a _DSM is added, which has separate function
    indexes for each of the previous stand alone methods.
    
    This change brings in support for the _DSM and allows usage of function
    index for corresponding stand alone methods.
    
    Details of Device Specific Method:
    
    Intel HID Event Filter Driver _DSM UUID:
    eeec56b3-4442-408f-a792-4edd4d758054
    
    • Function index 0: Returns a buffer with a bit-field representing the
    supported function IDs.
    
    Function Index  ASL Object
    --------------------------------
    1               BTNL
    2               HDMM
    3               HDSM
    4               HDEM
    5               BTNS
    6               BTNE
    7               HEBC
    8               VGBS
    9               HEBC
    
    One significant change is to query the supported methods implemented on
    the platform. So the previous HEBC() has two variants. HEBC v1 and
    HEBC v2. The v2 version allowed further define which of the 5-button
    are actually defined by the platform. HEBC v2 support is only available
    via new DSM.
    
    v1 Button details:
    Bits [0] - Rotation Lock, Num Lock, Home, End, Page Up,
    Page Down
    Bits [1] - Wireless Radio Control
    Bits [2] - System Power Down
    Bits [3] - System Hibernate
    Bits [4] - System Sleep/ System Wake
    Bits [5] - Scan Next Track
    Bits [6] - Scan Previous Track
    Bits [7] - Stop
    Bits [8] - Play/Pause
    Bits [9] - Mute
    Bits [10] - Volume Increment
    Bits [11] - Volume Decrement
    Bits [12] - Display Brightness Increment
    Bits [13] - Display Brightness Decrement
    Bits [14] - Lock Tablet
    Bits [15] - Release Tablet
    Bits [16] - Toggle Bezel
    Bits [17] - 5 button array
    Bits [18-31] - reserved
    
    v2 Buttom details:
    Bits [0-16] - Same as v1 version
    Bits [17] - 5 button array
    Bits [18] – Power Button
    Bits [19] - W Home Button
    Bits [20] - Volume Up Button
    Bits [21] - Volume Down Button
    Bits [22] – Rotation Lock Button
    Bits [23-31] – reserved
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Tested-by: Mario Limonciello <mario.limonciello@dell.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index b5adba227783..6cf9b7fa5bf0 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -96,13 +96,140 @@ struct intel_hid_priv {
 	bool wakeup_mode;
 };
 
-static int intel_hid_set_enable(struct device *device, bool enable)
+#define HID_EVENT_FILTER_UUID	"eeec56b3-4442-408f-a792-4edd4d758054"
+
+enum intel_hid_dsm_fn_codes {
+	INTEL_HID_DSM_FN_INVALID,
+	INTEL_HID_DSM_BTNL_FN,
+	INTEL_HID_DSM_HDMM_FN,
+	INTEL_HID_DSM_HDSM_FN,
+	INTEL_HID_DSM_HDEM_FN,
+	INTEL_HID_DSM_BTNS_FN,
+	INTEL_HID_DSM_BTNE_FN,
+	INTEL_HID_DSM_HEBC_V1_FN,
+	INTEL_HID_DSM_VGBS_FN,
+	INTEL_HID_DSM_HEBC_V2_FN,
+	INTEL_HID_DSM_FN_MAX
+};
+
+static const char *intel_hid_dsm_fn_to_method[INTEL_HID_DSM_FN_MAX] = {
+	NULL,
+	"BTNL",
+	"HDMM",
+	"HDSM",
+	"HDEM",
+	"BTNS",
+	"BTNE",
+	"HEBC",
+	"VGBS",
+	"HEBC"
+};
+
+static unsigned long long intel_hid_dsm_fn_mask;
+static guid_t intel_dsm_guid;
+
+static bool intel_hid_execute_method(acpi_handle handle,
+				     enum intel_hid_dsm_fn_codes fn_index,
+				     unsigned long long arg)
 {
+	union acpi_object *obj, argv4, req;
 	acpi_status status;
+	char *method_name;
 
-	status = acpi_execute_simple_method(ACPI_HANDLE(device), "HDSM",
-					    enable);
-	if (ACPI_FAILURE(status)) {
+	if (fn_index <= INTEL_HID_DSM_FN_INVALID ||
+	    fn_index >= INTEL_HID_DSM_FN_MAX)
+		return false;
+
+	method_name = (char *)intel_hid_dsm_fn_to_method[fn_index];
+
+	if (!(intel_hid_dsm_fn_mask & fn_index))
+		goto skip_dsm_exec;
+
+	/* All methods expects a package with one integer element */
+	req.type = ACPI_TYPE_INTEGER;
+	req.integer.value = arg;
+
+	argv4.type = ACPI_TYPE_PACKAGE;
+	argv4.package.count = 1;
+	argv4.package.elements = &req;
+
+	obj = acpi_evaluate_dsm(handle, &intel_dsm_guid, 1, fn_index, &argv4);
+	if (obj) {
+		acpi_handle_debug(handle, "Exec DSM Fn code: %d[%s] success\n",
+				  fn_index, method_name);
+		ACPI_FREE(obj);
+		return true;
+	}
+
+skip_dsm_exec:
+	status = acpi_execute_simple_method(handle, method_name, arg);
+	if (ACPI_SUCCESS(status))
+		return true;
+
+	return false;
+}
+
+static bool intel_hid_evaluate_method(acpi_handle handle,
+				      enum intel_hid_dsm_fn_codes fn_index,
+				      unsigned long long *result)
+{
+	union acpi_object *obj;
+	acpi_status status;
+	char *method_name;
+
+	if (fn_index <= INTEL_HID_DSM_FN_INVALID ||
+	    fn_index >= INTEL_HID_DSM_FN_MAX)
+		return false;
+
+	method_name = (char *)intel_hid_dsm_fn_to_method[fn_index];
+
+	if (!(intel_hid_dsm_fn_mask & fn_index))
+		goto skip_dsm_eval;
+
+	obj = acpi_evaluate_dsm_typed(handle, &intel_dsm_guid,
+				      1, fn_index,
+				      NULL,  ACPI_TYPE_INTEGER);
+	if (obj) {
+		*result = obj->integer.value;
+		acpi_handle_debug(handle,
+				  "Eval DSM Fn code: %d[%s] results: 0x%llx\n",
+				  fn_index, method_name, *result);
+		ACPI_FREE(obj);
+		return true;
+	}
+
+skip_dsm_eval:
+	status = acpi_evaluate_integer(handle, method_name, NULL, result);
+	if (ACPI_SUCCESS(status))
+		return true;
+
+	return false;
+}
+
+static void intel_hid_init_dsm(acpi_handle handle)
+{
+	union acpi_object *obj;
+
+	guid_parse(HID_EVENT_FILTER_UUID, &intel_dsm_guid);
+
+	obj = acpi_evaluate_dsm_typed(handle, &intel_dsm_guid, 1, 0, NULL,
+				      ACPI_TYPE_BUFFER);
+	if (obj) {
+		intel_hid_dsm_fn_mask = *obj->buffer.pointer;
+		ACPI_FREE(obj);
+	}
+
+	acpi_handle_debug(handle, "intel_hid_dsm_fn_mask = %llx\n",
+			  intel_hid_dsm_fn_mask);
+}
+
+static int intel_hid_set_enable(struct device *device, bool enable)
+{
+	acpi_handle handle = ACPI_HANDLE(device);
+
+	/* Enable|disable features - power button is always enabled */
+	if (!intel_hid_execute_method(handle, INTEL_HID_DSM_HDSM_FN,
+				      enable)) {
 		dev_warn(device, "failed to %sable hotkeys\n",
 			 enable ? "en" : "dis");
 		return -EIO;
@@ -129,9 +256,8 @@ static void intel_button_array_enable(struct device *device, bool enable)
 	}
 
 	/* Enable|disable features - power button is always enabled */
-	status = acpi_execute_simple_method(handle, "BTNE",
-					    enable ? button_cap : 1);
-	if (ACPI_FAILURE(status))
+	if (!intel_hid_execute_method(handle, INTEL_HID_DSM_BTNE_FN,
+				      enable ? button_cap : 1))
 		dev_warn(device, "failed to set button capability\n");
 }
 
@@ -217,7 +343,6 @@ static void notify_handler(acpi_handle handle, u32 event, void *context)
 	struct platform_device *device = context;
 	struct intel_hid_priv *priv = dev_get_drvdata(&device->dev);
 	unsigned long long ev_index;
-	acpi_status status;
 
 	if (priv->wakeup_mode) {
 		/*
@@ -269,8 +394,8 @@ static void notify_handler(acpi_handle handle, u32 event, void *context)
 		return;
 	}
 
-	status = acpi_evaluate_integer(handle, "HDEM", NULL, &ev_index);
-	if (ACPI_FAILURE(status)) {
+	if (!intel_hid_evaluate_method(handle, INTEL_HID_DSM_HDEM_FN,
+				       &ev_index)) {
 		dev_warn(&device->dev, "failed to get event index\n");
 		return;
 	}
@@ -284,17 +409,24 @@ static bool button_array_present(struct platform_device *device)
 {
 	acpi_handle handle = ACPI_HANDLE(&device->dev);
 	unsigned long long event_cap;
-	acpi_status status;
-	bool supported = false;
 
-	status = acpi_evaluate_integer(handle, "HEBC", NULL, &event_cap);
-	if (ACPI_SUCCESS(status) && (event_cap & 0x20000))
-		supported = true;
+	if (intel_hid_evaluate_method(handle, INTEL_HID_DSM_HEBC_V2_FN,
+				      &event_cap)) {
+		/* Check presence of 5 button array or v2 power button */
+		if (event_cap & 0x60000)
+			return true;
+	}
+
+	if (intel_hid_evaluate_method(handle, INTEL_HID_DSM_HEBC_V1_FN,
+				      &event_cap)) {
+		if (event_cap & 0x20000)
+			return true;
+	}
 
 	if (dmi_check_system(button_array_table))
-		supported = true;
+		return true;
 
-	return supported;
+	return false;
 }
 
 static int intel_hid_probe(struct platform_device *device)
@@ -305,8 +437,9 @@ static int intel_hid_probe(struct platform_device *device)
 	acpi_status status;
 	int err;
 
-	status = acpi_evaluate_integer(handle, "HDMM", NULL, &mode);
-	if (ACPI_FAILURE(status)) {
+	intel_hid_init_dsm(handle);
+
+	if (!intel_hid_evaluate_method(handle, INTEL_HID_DSM_HDMM_FN, &mode)) {
 		dev_warn(&device->dev, "failed to read mode\n");
 		return -ENODEV;
 	}
@@ -352,13 +485,16 @@ static int intel_hid_probe(struct platform_device *device)
 		goto err_remove_notify;
 
 	if (priv->array) {
+		unsigned long long dummy;
+
 		intel_button_array_enable(&device->dev, true);
 
 		/* Call button load method to enable HID power button */
-		status = acpi_evaluate_object(handle, "BTNL", NULL, NULL);
-		if (ACPI_FAILURE(status))
+		if (!intel_hid_evaluate_method(handle, INTEL_HID_DSM_BTNL_FN,
+					       &dummy)) {
 			dev_warn(&device->dev,
 				 "failed to enable HID power button\n");
+		}
 	}
 
 	device_init_wakeup(&device->dev, true);

commit 2b5de0cc1fe0e2308dc1d2494de7917c707bd8ca
Author: Alex Hung <alex.hung@canonical.com>
Date:   Fri Mar 30 16:54:54 2018 -0700

    intel-hid: support KEY_ROTATE_LOCK_TOGGLE
    
    KEY_ROTATE_LOCK_TOGGLE is introduced in 4.16 rc1 and this key event is
    emitted on Wacom MobileStudio Pro 13.
    
    Signed-off-by: Alex Hung <alex.hung@canonical.com>
    Co-developed-by: Jason Gerecke <jason.gerecke@wacom.com>
    Signed-off-by: Jason Gerecke <jason.gerecke@wacom.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index 6b89ec7bc732..b5adba227783 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -65,8 +65,8 @@ static const struct key_entry intel_array_keymap[] = {
 	{ KE_IGNORE, 0xC5, { KEY_VOLUMEUP } },                /* Release */
 	{ KE_KEY,    0xC6, { KEY_VOLUMEDOWN } },              /* Press */
 	{ KE_IGNORE, 0xC7, { KEY_VOLUMEDOWN } },              /* Release */
-	{ KE_SW,     0xC8, { .sw = { SW_ROTATE_LOCK, 1 } } }, /* Press */
-	{ KE_SW,     0xC9, { .sw = { SW_ROTATE_LOCK, 0 } } }, /* Release */
+	{ KE_KEY,    0xC8, { KEY_ROTATE_LOCK_TOGGLE } },      /* Press */
+	{ KE_IGNORE, 0xC9, { KEY_ROTATE_LOCK_TOGGLE } },      /* Release */
 	{ KE_KEY,    0xCE, { KEY_POWER } },                   /* Press */
 	{ KE_IGNORE, 0xCF, { KEY_POWER } },                   /* Release */
 	{ KE_END },

commit 28e8ed2a01bba317aab9bca1c5609924cbbf6cdc
Author: Alex Hung <alex.hung@canonical.com>
Date:   Thu Mar 15 16:22:51 2018 -0700

    intel-hid: clean up and sort header files
    
    Removed unused header files and sorted them alphabetically. No
    functional changes are made.
    
    Signed-off-by: Alex Hung <alex.hung@canonical.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index 5e3df194723e..6b89ec7bc732 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -16,16 +16,14 @@
  *
  */
 
+#include <linux/acpi.h>
+#include <linux/dmi.h>
+#include <linux/input.h>
+#include <linux/input/sparse-keymap.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/init.h>
-#include <linux/input.h>
 #include <linux/platform_device.h>
-#include <linux/input/sparse-keymap.h>
-#include <linux/acpi.h>
 #include <linux/suspend.h>
-#include <acpi/acpi_bus.h>
-#include <linux/dmi.h>
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Alex Hung");

commit 356b57752c91cffb35356abe6647065bf0edcad1
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Feb 28 12:10:59 2018 +0100

    platform/x86: intel-hid: Reset wakeup capable flag on removal
    
    The intel-hid device will not be able to wake up the system any more
    after removing the notify handler provided by its driver, so make
    its sysfs attributes reflect that.
    
    Fixes: ef884112e55c (platform: x86: intel-hid: Wake up the system from suspend-to-idle)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index d1a01311c1a2..5e3df194723e 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -376,6 +376,7 @@ static int intel_hid_remove(struct platform_device *device)
 {
 	acpi_handle handle = ACPI_HANDLE(&device->dev);
 
+	device_init_wakeup(&device->dev, false);
 	acpi_remove_notify_handler(handle, ACPI_DEVICE_NOTIFY, notify_handler);
 	intel_hid_set_enable(&device->dev, false);
 	intel_button_array_enable(&device->dev, false);

commit c454a99d4ce1cebb5b4dc742309187c05b4b17ee
Author: Alex Hung <alex.hung@canonical.com>
Date:   Thu Dec 7 11:40:23 2017 +0800

    intel-hid: add a DMI quirk to support Wacom MobileStudio Pro
    
    HEBC method reports capabilities of 5 button array but Wacom
    MobileStudio Pro does not have this control method. A DMI quirk
    was created to enable 5 button array for this system.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=197991
    
    Reported-by: Jason Gerecke <jason.gerecke@wacom.com>
    Signed-off-by: Alex Hung <alex.hung@canonical.com>
    Tested-by: Jason Gerecke <jason.gerecke@wacom.com>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index f470279c4c10..d1a01311c1a2 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -25,6 +25,7 @@
 #include <linux/acpi.h>
 #include <linux/suspend.h>
 #include <acpi/acpi_bus.h>
+#include <linux/dmi.h>
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Alex Hung");
@@ -73,6 +74,24 @@ static const struct key_entry intel_array_keymap[] = {
 	{ KE_END },
 };
 
+static const struct dmi_system_id button_array_table[] = {
+	{
+		.ident = "Wacom MobileStudio Pro 13",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Wacom Co.,Ltd"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Wacom MobileStudio Pro 13"),
+		},
+	},
+	{
+		.ident = "Wacom MobileStudio Pro 16",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Wacom Co.,Ltd"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Wacom MobileStudio Pro 16"),
+		},
+	},
+	{ }
+};
+
 struct intel_hid_priv {
 	struct input_dev *input_dev;
 	struct input_dev *array;
@@ -263,10 +282,27 @@ static void notify_handler(acpi_handle handle, u32 event, void *context)
 			 ev_index);
 }
 
+static bool button_array_present(struct platform_device *device)
+{
+	acpi_handle handle = ACPI_HANDLE(&device->dev);
+	unsigned long long event_cap;
+	acpi_status status;
+	bool supported = false;
+
+	status = acpi_evaluate_integer(handle, "HEBC", NULL, &event_cap);
+	if (ACPI_SUCCESS(status) && (event_cap & 0x20000))
+		supported = true;
+
+	if (dmi_check_system(button_array_table))
+		supported = true;
+
+	return supported;
+}
+
 static int intel_hid_probe(struct platform_device *device)
 {
 	acpi_handle handle = ACPI_HANDLE(&device->dev);
-	unsigned long long event_cap, mode;
+	unsigned long long mode;
 	struct intel_hid_priv *priv;
 	acpi_status status;
 	int err;
@@ -299,8 +335,7 @@ static int intel_hid_probe(struct platform_device *device)
 	}
 
 	/* Setup 5 button array */
-	status = acpi_evaluate_integer(handle, "HEBC", NULL, &event_cap);
-	if (ACPI_SUCCESS(status) && (event_cap & 0x20000)) {
+	if (button_array_present(device)) {
 		dev_info(&device->dev, "platform supports 5 button array\n");
 		err = intel_button_array_input_setup(device);
 		if (err)

commit 821b85366284542e00dd834062144c637e818ee0
Author: Jérôme de Bretagne <jerome.debretagne@gmail.com>
Date:   Mon Sep 18 00:57:12 2017 +0200

    platform/x86: intel-hid: Power button suspend on Dell Latitude 7275
    
    On Dell Latitude 7275 the 5-button array is not exposed in the ACPI
    tables, but notififies are still sent to the Intel HID device object
    (device ID INT33D5) in response to power button actions.  They were
    ignored as the intel-hid driver was not prepared to take care of them
    until recently.
    
    Power button wakeup from suspend-to-idle was added in:
    
    commit 635173a17b03 ("intel-hid: Wake up Dell Latitude 7275 from suspend-to-idle")
    
    However power button suspend doesn't work yet on this platform so it
    would be good to add it also.
    
    On the affected platform (for which priv->array is NULL), add a new
    upfront check against the power button press notification (0xCE) to
    notify_handler(), outside the wakeup mode this time, which allows
    reporting the power button press event and triggers the suspend. Also
    catch and ignore the corresponding power button release notification
    (0xCF) to stop it from being reported as an "unknown event" in the logs.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=196115
    Tested-by: Jérôme de Bretagne <jerome.debretagne@gmail.com>
    Signed-off-by: Jérôme de Bretagne <jerome.debretagne@gmail.com>
    Acked-By: Mario Limonciello <mario.limonciello@dell.com>
    [dvhart: minor coding style and commit message format fix]
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>
    
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index e34fd70b67af..f470279c4c10 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -226,6 +226,24 @@ static void notify_handler(acpi_handle handle, u32 event, void *context)
 		return;
 	}
 
+	/*
+	 * Needed for suspend to work on some platforms that don't expose
+	 * the 5-button array, but still send notifies with power button
+	 * event code to this device object on power button actions.
+	 *
+	 * Report the power button press; catch and ignore the button release.
+	 */
+	if (!priv->array) {
+		if (event == 0xce) {
+			input_report_key(priv->input_dev, KEY_POWER, 1);
+			input_sync(priv->input_dev);
+			return;
+		}
+
+		if (event == 0xcf)
+			return;
+	}
+
 	/* 0xC0 is for HID events, other values are for 5 button array */
 	if (event != 0xc0) {
 		if (!priv->array ||

commit 0e271fd59fe9e6d8c932309e7a42a4519c5aac6f
Merge: ee89252b9edf 00ebbeb39b70
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 8 16:04:50 2017 -0700

    Merge tag 'platform-drivers-x86-v4.14-1' of git://git.infradead.org/linux-platform-drivers-x86
    
    Pull x86 platform driver updates from Darren Hart:
     "Several fixes from static analysis and message noise reduction.
      Correct WMI core and related drivers to evaluate instance number 0x0
      in accordance with the documentation. Add intel-telemetry support for
      Gemini Lake. Various individual driver fixes noted below.
    
      dell-wmi:
       - Update dell_wmi_check_descriptor_buffer() to new model
    
      intel-vbtn:
       - reduce unnecessary messages for normal users
       - match power button on press rather than release
    
      intel-hid:
       - reduce unnecessary messages for normal users
    
      thinkpad_acpi:
       - Fix warning about deprecated hwmon_device_register
    
      wmi:
       - Fix check for method instance number
    
      ideapad-laptop:
       - Expose conservation mode switch
    
      intel_pmc_core:
       - Make the driver PCH family agnostic
    
      peaq-wmi:
       - Evaluate wmi method with instance number 0x0
       - silence a static checker warning
    
      mxm-wmi:
       - Evaluate wmi method with instance number 0x0
    
      asus-wmi:
       - Evaluate wmi method with instance number 0x0
    
      intel_scu_ipc:
       - make intel_scu_ipc_pdata_t const
    
      intel_mid_powerbtn:
       - make mid_pb_ddata const
       - fix error return code in mid_pb_probe()
    
      hp-wmi:
       - Remove unused macro helper
       - Correctly determine method id in WMI calls
    
      dell-wmi:
       - Fix driver interface version query
    
      intel_telemetry:
       - remove redundant macro definition
       - Add GLK PSS Event Table
    
      alienware-wmi:
       - fix format string overflow warning
    
      ibm_rtl:
       - remove unnecessary static in ibm_rtl_write()
    
      msi-wmi:
       - remove unnecessary static in msi_wmi_notify()"
    
    * tag 'platform-drivers-x86-v4.14-1' of git://git.infradead.org/linux-platform-drivers-x86: (23 commits)
      platform/x86: dell-wmi: Update dell_wmi_check_descriptor_buffer() to new model
      platform/x86: intel-vbtn: reduce unnecessary messages for normal users
      platform/x86: intel-hid: reduce unnecessary messages for normal users
      platform/x86: thinkpad_acpi: Fix warning about deprecated hwmon_device_register
      platform/x86: wmi: Fix check for method instance number
      platform/x86: ideapad-laptop: Expose conservation mode switch
      platform/x86: intel_pmc_core: Make the driver PCH family agnostic
      platform/x86: peaq-wmi: Evaluate wmi method with instance number 0x0
      platform/x86: mxm-wmi: Evaluate wmi method with instance number 0x0
      platform/x86: asus-wmi: Evaluate wmi method with instance number 0x0
      platform/x86: intel_scu_ipc: make intel_scu_ipc_pdata_t const
      platform/x86: intel_mid_powerbtn: make mid_pb_ddata const
      platform/x86: intel_mid_powerbtn: fix error return code in mid_pb_probe()
      platform/x86: hp-wmi: Remove unused macro helper
      platform/x86: hp-wmi: Correctly determine method id in WMI calls
      platform/x86: intel-vbtn: match power button on press rather than release
      platform/x86: dell-wmi: Fix driver interface version query
      platform/x86: intel_telemetry: remove redundant macro definition
      platform/x86: intel_telemetry: Add GLK PSS Event Table
      platform/x86: alienware-wmi: fix format string overflow warning
      ...

commit d496c8750f6f1ac61c7ecca8cb442ea40e67077e
Author: Alex Hung <alex.hung@canonical.com>
Date:   Thu Jul 20 20:58:08 2017 -0700

    platform/x86: intel-hid: reduce unnecessary messages for normal users
    
    Unsupported events is only useful for developers and does not meaningful
    for users. Using dev_dbg makes more sense and reduces noise in kernel
    messages.
    
    Signed-off-by: Alex Hung <alex.hung@canonical.com>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index 8519e0f97bdd..4f70b8219850 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -219,7 +219,7 @@ static void notify_handler(acpi_handle handle, u32 event, void *context)
 	if (event != 0xc0) {
 		if (!priv->array ||
 		    !sparse_keymap_report_event(priv->array, event, 1, true))
-			dev_info(&device->dev, "unknown event 0x%x\n", event);
+			dev_dbg(&device->dev, "unknown event 0x%x\n", event);
 		return;
 	}
 
@@ -230,7 +230,7 @@ static void notify_handler(acpi_handle handle, u32 event, void *context)
 	}
 
 	if (!sparse_keymap_report_event(priv->input_dev, ev_index, 1, true))
-		dev_info(&device->dev, "unknown event index 0x%llx\n",
+		dev_dbg(&device->dev, "unknown event index 0x%llx\n",
 			 ev_index);
 }
 

commit 635173a17b0323c28a39fb06fa36d876035cd2b9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jul 28 02:06:36 2017 +0200

    platform/x86: intel-hid: Wake up Dell Latitude 7275 from suspend-to-idle
    
    On Dell Latitude 7275 the 5-button array is not exposed in the
    ACPI tables, but still notifies are sent to the Intel HID device
    object (device ID INT33D5) in response to power button actions while
    suspended to idle.  However, they are currently ignored as the
    intel-hid driver is not prepared to take care of them.
    
    As a result, power button wakeup from suspend-to-idle doesn't work
    on this platform, but suspend-to-idle is the only reliable suspend
    variant on it (the S3 implementation in the platform firmware turns
    out to be broken), so it would be good to handle it properly.
    
    For this reason, add an upfront check against the power button press
    event (0xCE) to notify_handler() in the wakeup mode which allows it
    to catch the power button wakeup notification on the affected
    platform (even though priv->array is NULL on it) and should not
    change the behavior on platforms with priv->array present (because
    priv->array contains the event in question in those cases).
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=196115
    Tested-by: Jérôme de Bretagne <jerome.debretagne@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Acked-By: Mario Limonciello <mario.limonciello@dell.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index 8519e0f97bdd..a782c78e7c63 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -203,15 +203,26 @@ static void notify_handler(acpi_handle handle, u32 event, void *context)
 	acpi_status status;
 
 	if (priv->wakeup_mode) {
+		/*
+		 * Needed for wakeup from suspend-to-idle to work on some
+		 * platforms that don't expose the 5-button array, but still
+		 * send notifies with the power button event code to this
+		 * device object on power button actions while suspended.
+		 */
+		if (event == 0xce)
+			goto wakeup;
+
 		/* Wake up on 5-button array events only. */
 		if (event == 0xc0 || !priv->array)
 			return;
 
-		if (sparse_keymap_entry_from_scancode(priv->array, event))
-			pm_wakeup_hard_event(&device->dev);
-		else
+		if (!sparse_keymap_entry_from_scancode(priv->array, event)) {
 			dev_info(&device->dev, "unknown event 0x%x\n", event);
+			return;
+		}
 
+wakeup:
+		pm_wakeup_hard_event(&device->dev);
 		return;
 	}
 

commit ef884112e55c60d9e208b6524ae1841ae7e2fb2c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jun 8 02:16:13 2017 +0200

    platform: x86: intel-hid: Wake up the system from suspend-to-idle
    
    Allow the intel-hid driver to wake up the system from suspend-to-idle
    by configuring its platform device as a wakeup one by default and
    switching it over to a system wakeup events triggering mode during
    system suspend transitions.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index 63ba2cbd04c2..8519e0f97bdd 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -23,6 +23,7 @@
 #include <linux/platform_device.h>
 #include <linux/input/sparse-keymap.h>
 #include <linux/acpi.h>
+#include <linux/suspend.h>
 #include <acpi/acpi_bus.h>
 
 MODULE_LICENSE("GPL");
@@ -75,6 +76,7 @@ static const struct key_entry intel_array_keymap[] = {
 struct intel_hid_priv {
 	struct input_dev *input_dev;
 	struct input_dev *array;
+	bool wakeup_mode;
 };
 
 static int intel_hid_set_enable(struct device *device, bool enable)
@@ -116,23 +118,37 @@ static void intel_button_array_enable(struct device *device, bool enable)
 		dev_warn(device, "failed to set button capability\n");
 }
 
-static int intel_hid_pl_suspend_handler(struct device *device)
+static int intel_hid_pm_prepare(struct device *device)
 {
-	intel_hid_set_enable(device, false);
-	intel_button_array_enable(device, false);
+	struct intel_hid_priv *priv = dev_get_drvdata(device);
+
+	priv->wakeup_mode = true;
+	return 0;
+}
 
+static int intel_hid_pl_suspend_handler(struct device *device)
+{
+	if (pm_suspend_via_firmware()) {
+		intel_hid_set_enable(device, false);
+		intel_button_array_enable(device, false);
+	}
 	return 0;
 }
 
 static int intel_hid_pl_resume_handler(struct device *device)
 {
-	intel_hid_set_enable(device, true);
-	intel_button_array_enable(device, true);
+	struct intel_hid_priv *priv = dev_get_drvdata(device);
 
+	priv->wakeup_mode = false;
+	if (pm_resume_via_firmware()) {
+		intel_hid_set_enable(device, true);
+		intel_button_array_enable(device, true);
+	}
 	return 0;
 }
 
 static const struct dev_pm_ops intel_hid_pl_pm_ops = {
+	.prepare = intel_hid_pm_prepare,
 	.freeze  = intel_hid_pl_suspend_handler,
 	.thaw  = intel_hid_pl_resume_handler,
 	.restore  = intel_hid_pl_resume_handler,
@@ -186,6 +202,19 @@ static void notify_handler(acpi_handle handle, u32 event, void *context)
 	unsigned long long ev_index;
 	acpi_status status;
 
+	if (priv->wakeup_mode) {
+		/* Wake up on 5-button array events only. */
+		if (event == 0xc0 || !priv->array)
+			return;
+
+		if (sparse_keymap_entry_from_scancode(priv->array, event))
+			pm_wakeup_hard_event(&device->dev);
+		else
+			dev_info(&device->dev, "unknown event 0x%x\n", event);
+
+		return;
+	}
+
 	/* 0xC0 is for HID events, other values are for 5 button array */
 	if (event != 0xc0) {
 		if (!priv->array ||
@@ -270,6 +299,7 @@ static int intel_hid_probe(struct platform_device *device)
 				 "failed to enable HID power button\n");
 	}
 
+	device_init_wakeup(&device->dev, true);
 	return 0;
 
 err_remove_notify:

commit b899830506740faf509f3bb51d3d1e50102aed40
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Apr 18 15:49:06 2017 +0200

    platform/x86: intel-hid: Add missing ->thaw callback
    
    The intel-hid driver is missing a PM ->thaw callback allowing the
    device to go back to the operational state after creating a
    hibernation image or when there is an image restoration error during
    resume.
    
    The lack of the ->thaw callback basically means that all events
    signaled by the device are discarded after a hibernation image has
    been created which may be problematic, for example, if the image
    cannot be saved (eg. due to an I/O issue with storage).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index b40059aba856..63ba2cbd04c2 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -134,6 +134,7 @@ static int intel_hid_pl_resume_handler(struct device *device)
 
 static const struct dev_pm_ops intel_hid_pl_pm_ops = {
 	.freeze  = intel_hid_pl_suspend_handler,
+	.thaw  = intel_hid_pl_resume_handler,
 	.restore  = intel_hid_pl_resume_handler,
 	.suspend  = intel_hid_pl_suspend_handler,
 	.resume  = intel_hid_pl_resume_handler,

commit 1fe55309462cc9b2dcefe6eb91e7adeba5e59e89
Author: Michał Kępień <kernel@kempniu.pl>
Date:   Thu Mar 9 10:36:51 2017 +0100

    platform/x86: intel-hid: do not set parents of input devices explicitly
    
    devm_input_allocate_device() already causes the supplied struct device
    to be set as the parent of the input device, so doing it again is
    redundant.
    
    Signed-off-by: Michał Kępień <kernel@kempniu.pl>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-and-tested-by: Alex Hung <alex.hung@canonical.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index 5eab31659cba..b40059aba856 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -152,7 +152,6 @@ static int intel_hid_input_setup(struct platform_device *device)
 	if (ret)
 		return ret;
 
-	priv->input_dev->dev.parent = &device->dev;
 	priv->input_dev->name = "Intel HID events";
 	priv->input_dev->id.bustype = BUS_HOST;
 
@@ -173,7 +172,6 @@ static int intel_button_array_input_setup(struct platform_device *device)
 	if (ret)
 		return ret;
 
-	priv->array->dev.parent = &device->dev;
 	priv->array->name = "Intel HID 5 button array";
 	priv->array->id.bustype = BUS_HOST;
 

commit faf667efdbe5f6c8d6962aab8680680838678097
Author: Michał Kępień <kernel@kempniu.pl>
Date:   Fri Feb 24 11:33:09 2017 +0100

    platform/x86: intel-hid: remove redundant set_bit() call
    
    Remove redundant set_bit() call for KEY_RFKILL as it is already made by
    sparse_keymap_setup() due to KEY_RFKILL being assigned to event code 8
    in intel_hid_keymap.
    
    Signed-off-by: Michał Kępień <kernel@kempniu.pl>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-and-tested-by: Alex Hung <alex.hung@canonical.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index b17f33b832c2..5eab31659cba 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -155,7 +155,6 @@ static int intel_hid_input_setup(struct platform_device *device)
 	priv->input_dev->dev.parent = &device->dev;
 	priv->input_dev->name = "Intel HID events";
 	priv->input_dev->id.bustype = BUS_HOST;
-	set_bit(KEY_RFKILL, priv->input_dev->keybit);
 
 	return input_register_device(priv->input_dev);
 }

commit 175cc9b72fb5ca65dfb79e7c2500304476486717
Author: Michał Kępień <kernel@kempniu.pl>
Date:   Fri Feb 24 11:33:08 2017 +0100

    platform/x86: intel-hid: use devm_input_allocate_device() for HID events input device
    
    intel_hid_input_setup() is only called from the platform driver's .probe
    callback.  Use the devm variant of input_allocate_device() for
    allocating memory for the HID events input device in order to simplify
    two error paths and get rid of intel_hid_input_destroy().
    
    Signed-off-by: Michał Kępień <kernel@kempniu.pl>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-and-tested-by: Alex Hung <alex.hung@canonical.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index 89d1d98e3214..b17f33b832c2 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -144,28 +144,20 @@ static int intel_hid_input_setup(struct platform_device *device)
 	struct intel_hid_priv *priv = dev_get_drvdata(&device->dev);
 	int ret;
 
-	priv->input_dev = input_allocate_device();
+	priv->input_dev = devm_input_allocate_device(&device->dev);
 	if (!priv->input_dev)
 		return -ENOMEM;
 
 	ret = sparse_keymap_setup(priv->input_dev, intel_hid_keymap, NULL);
 	if (ret)
-		goto err_free_device;
+		return ret;
 
 	priv->input_dev->dev.parent = &device->dev;
 	priv->input_dev->name = "Intel HID events";
 	priv->input_dev->id.bustype = BUS_HOST;
 	set_bit(KEY_RFKILL, priv->input_dev->keybit);
 
-	ret = input_register_device(priv->input_dev);
-	if (ret)
-		goto err_free_device;
-
-	return 0;
-
-err_free_device:
-	input_free_device(priv->input_dev);
-	return ret;
+	return input_register_device(priv->input_dev);
 }
 
 static int intel_button_array_input_setup(struct platform_device *device)
@@ -189,13 +181,6 @@ static int intel_button_array_input_setup(struct platform_device *device)
 	return input_register_device(priv->array);
 }
 
-static void intel_hid_input_destroy(struct platform_device *device)
-{
-	struct intel_hid_priv *priv = dev_get_drvdata(&device->dev);
-
-	input_unregister_device(priv->input_dev);
-}
-
 static void notify_handler(acpi_handle handle, u32 event, void *context)
 {
 	struct platform_device *device = context;
@@ -270,10 +255,8 @@ static int intel_hid_probe(struct platform_device *device)
 					     ACPI_DEVICE_NOTIFY,
 					     notify_handler,
 					     device);
-	if (ACPI_FAILURE(status)) {
-		err = -EBUSY;
-		goto err_remove_input;
-	}
+	if (ACPI_FAILURE(status))
+		return -EBUSY;
 
 	err = intel_hid_set_enable(&device->dev, true);
 	if (err)
@@ -294,9 +277,6 @@ static int intel_hid_probe(struct platform_device *device)
 err_remove_notify:
 	acpi_remove_notify_handler(handle, ACPI_DEVICE_NOTIFY, notify_handler);
 
-err_remove_input:
-	intel_hid_input_destroy(device);
-
 	return err;
 }
 
@@ -305,7 +285,6 @@ static int intel_hid_remove(struct platform_device *device)
 	acpi_handle handle = ACPI_HANDLE(&device->dev);
 
 	acpi_remove_notify_handler(handle, ACPI_DEVICE_NOTIFY, notify_handler);
-	intel_hid_input_destroy(device);
 	intel_hid_set_enable(&device->dev, false);
 	intel_button_array_enable(&device->dev, false);
 

commit 99a75e7b05c764b82a1ba4b632c66d1b58b8fff7
Author: Michał Kępień <kernel@kempniu.pl>
Date:   Fri Feb 24 11:33:07 2017 +0100

    platform/x86: intel-hid: make intel_hid_set_enable() take a boolean argument
    
    As the integer value passed to intel_hid_set_enable() is always
    explicitly passed and is used solely as a boolean value, make it a bool.
    
    Signed-off-by: Michał Kępień <kernel@kempniu.pl>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-and-tested-by: Alex Hung <alex.hung@canonical.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index 4d1c5eb3a96d..89d1d98e3214 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -77,7 +77,7 @@ struct intel_hid_priv {
 	struct input_dev *array;
 };
 
-static int intel_hid_set_enable(struct device *device, int enable)
+static int intel_hid_set_enable(struct device *device, bool enable)
 {
 	acpi_status status;
 
@@ -118,7 +118,7 @@ static void intel_button_array_enable(struct device *device, bool enable)
 
 static int intel_hid_pl_suspend_handler(struct device *device)
 {
-	intel_hid_set_enable(device, 0);
+	intel_hid_set_enable(device, false);
 	intel_button_array_enable(device, false);
 
 	return 0;
@@ -126,7 +126,7 @@ static int intel_hid_pl_suspend_handler(struct device *device)
 
 static int intel_hid_pl_resume_handler(struct device *device)
 {
-	intel_hid_set_enable(device, 1);
+	intel_hid_set_enable(device, true);
 	intel_button_array_enable(device, true);
 
 	return 0;
@@ -275,7 +275,7 @@ static int intel_hid_probe(struct platform_device *device)
 		goto err_remove_input;
 	}
 
-	err = intel_hid_set_enable(&device->dev, 1);
+	err = intel_hid_set_enable(&device->dev, true);
 	if (err)
 		goto err_remove_notify;
 
@@ -306,7 +306,7 @@ static int intel_hid_remove(struct platform_device *device)
 
 	acpi_remove_notify_handler(handle, ACPI_DEVICE_NOTIFY, notify_handler);
 	intel_hid_input_destroy(device);
-	intel_hid_set_enable(&device->dev, 0);
+	intel_hid_set_enable(&device->dev, false);
 	intel_button_array_enable(&device->dev, false);
 
 	/*

commit 93ed249075599497fa0667d1b9873d66831fd0e0
Author: Michał Kępień <kernel@kempniu.pl>
Date:   Fri Feb 24 11:33:06 2017 +0100

    platform/x86: intel-hid: simplify enabling/disabling HID events
    
    ACPI method HDSM takes a single integer argument.  Use
    acpi_execute_simple_method() instead of acpi_evaluate_object() for
    calling that ACPI method to simplify code and reduce the number of local
    variables inside intel_hid_set_enable().
    
    Signed-off-by: Michał Kępień <kernel@kempniu.pl>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-and-tested-by: Alex Hung <alex.hung@canonical.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index bcf438f38781..4d1c5eb3a96d 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -79,12 +79,10 @@ struct intel_hid_priv {
 
 static int intel_hid_set_enable(struct device *device, int enable)
 {
-	union acpi_object arg0 = { ACPI_TYPE_INTEGER };
-	struct acpi_object_list args = { 1, &arg0 };
 	acpi_status status;
 
-	arg0.integer.value = enable;
-	status = acpi_evaluate_object(ACPI_HANDLE(device), "HDSM", &args, NULL);
+	status = acpi_execute_simple_method(ACPI_HANDLE(device), "HDSM",
+					    enable);
 	if (ACPI_FAILURE(status)) {
 		dev_warn(device, "failed to %sable hotkeys\n",
 			 enable ? "en" : "dis");

commit bd5762a0c1c9ae66bd0ece6959bbc5013ab95dcd
Author: Alex Hung <alex.hung@canonical.com>
Date:   Tue Feb 14 15:20:34 2017 +0800

    platform/x86: intel-hid: Support 5 button array
    
    New firmwares include a feature called 5 button array that supports
    super key, volume up/down, rotation lock and power button. Support
    for this feature is required to fix power button on some recent
    systems.
    
    This patch was tested on a Dell Latitude 7480.
    
    Signed-off-by: Alex Hung <alex.hung@canonical.com>
    Reviewed-by: Michał Kępień <kernel@kempniu.pl>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index cb3ab2b212b1..bcf438f38781 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -1,5 +1,5 @@
 /*
- *  Intel HID event driver for Windows 8
+ *  Intel HID event & 5 button array driver
  *
  *  Copyright (C) 2015 Alex Hung <alex.hung@canonical.com>
  *  Copyright (C) 2015 Andrew Lutomirski <luto@kernel.org>
@@ -57,8 +57,24 @@ static const struct key_entry intel_hid_keymap[] = {
 	{ KE_END },
 };
 
+/* 5 button array notification value. */
+static const struct key_entry intel_array_keymap[] = {
+	{ KE_KEY,    0xC2, { KEY_LEFTMETA } },                /* Press */
+	{ KE_IGNORE, 0xC3, { KEY_LEFTMETA } },                /* Release */
+	{ KE_KEY,    0xC4, { KEY_VOLUMEUP } },                /* Press */
+	{ KE_IGNORE, 0xC5, { KEY_VOLUMEUP } },                /* Release */
+	{ KE_KEY,    0xC6, { KEY_VOLUMEDOWN } },              /* Press */
+	{ KE_IGNORE, 0xC7, { KEY_VOLUMEDOWN } },              /* Release */
+	{ KE_SW,     0xC8, { .sw = { SW_ROTATE_LOCK, 1 } } }, /* Press */
+	{ KE_SW,     0xC9, { .sw = { SW_ROTATE_LOCK, 0 } } }, /* Release */
+	{ KE_KEY,    0xCE, { KEY_POWER } },                   /* Press */
+	{ KE_IGNORE, 0xCF, { KEY_POWER } },                   /* Release */
+	{ KE_END },
+};
+
 struct intel_hid_priv {
 	struct input_dev *input_dev;
+	struct input_dev *array;
 };
 
 static int intel_hid_set_enable(struct device *device, int enable)
@@ -78,15 +94,43 @@ static int intel_hid_set_enable(struct device *device, int enable)
 	return 0;
 }
 
+static void intel_button_array_enable(struct device *device, bool enable)
+{
+	struct intel_hid_priv *priv = dev_get_drvdata(device);
+	acpi_handle handle = ACPI_HANDLE(device);
+	unsigned long long button_cap;
+	acpi_status status;
+
+	if (!priv->array)
+		return;
+
+	/* Query supported platform features */
+	status = acpi_evaluate_integer(handle, "BTNC", NULL, &button_cap);
+	if (ACPI_FAILURE(status)) {
+		dev_warn(device, "failed to get button capability\n");
+		return;
+	}
+
+	/* Enable|disable features - power button is always enabled */
+	status = acpi_execute_simple_method(handle, "BTNE",
+					    enable ? button_cap : 1);
+	if (ACPI_FAILURE(status))
+		dev_warn(device, "failed to set button capability\n");
+}
+
 static int intel_hid_pl_suspend_handler(struct device *device)
 {
 	intel_hid_set_enable(device, 0);
+	intel_button_array_enable(device, false);
+
 	return 0;
 }
 
 static int intel_hid_pl_resume_handler(struct device *device)
 {
 	intel_hid_set_enable(device, 1);
+	intel_button_array_enable(device, true);
+
 	return 0;
 }
 
@@ -126,6 +170,27 @@ static int intel_hid_input_setup(struct platform_device *device)
 	return ret;
 }
 
+static int intel_button_array_input_setup(struct platform_device *device)
+{
+	struct intel_hid_priv *priv = dev_get_drvdata(&device->dev);
+	int ret;
+
+	/* Setup input device for 5 button array */
+	priv->array = devm_input_allocate_device(&device->dev);
+	if (!priv->array)
+		return -ENOMEM;
+
+	ret = sparse_keymap_setup(priv->array, intel_array_keymap, NULL);
+	if (ret)
+		return ret;
+
+	priv->array->dev.parent = &device->dev;
+	priv->array->name = "Intel HID 5 button array";
+	priv->array->id.bustype = BUS_HOST;
+
+	return input_register_device(priv->array);
+}
+
 static void intel_hid_input_destroy(struct platform_device *device)
 {
 	struct intel_hid_priv *priv = dev_get_drvdata(&device->dev);
@@ -140,10 +205,11 @@ static void notify_handler(acpi_handle handle, u32 event, void *context)
 	unsigned long long ev_index;
 	acpi_status status;
 
-	/* The platform spec only defines one event code: 0xC0. */
+	/* 0xC0 is for HID events, other values are for 5 button array */
 	if (event != 0xc0) {
-		dev_warn(&device->dev, "received unknown event (0x%x)\n",
-			 event);
+		if (!priv->array ||
+		    !sparse_keymap_report_event(priv->array, event, 1, true))
+			dev_info(&device->dev, "unknown event 0x%x\n", event);
 		return;
 	}
 
@@ -161,8 +227,8 @@ static void notify_handler(acpi_handle handle, u32 event, void *context)
 static int intel_hid_probe(struct platform_device *device)
 {
 	acpi_handle handle = ACPI_HANDLE(&device->dev);
+	unsigned long long event_cap, mode;
 	struct intel_hid_priv *priv;
-	unsigned long long mode;
 	acpi_status status;
 	int err;
 
@@ -193,6 +259,15 @@ static int intel_hid_probe(struct platform_device *device)
 		return err;
 	}
 
+	/* Setup 5 button array */
+	status = acpi_evaluate_integer(handle, "HEBC", NULL, &event_cap);
+	if (ACPI_SUCCESS(status) && (event_cap & 0x20000)) {
+		dev_info(&device->dev, "platform supports 5 button array\n");
+		err = intel_button_array_input_setup(device);
+		if (err)
+			pr_err("Failed to setup Intel 5 button array hotkeys\n");
+	}
+
 	status = acpi_install_notify_handler(handle,
 					     ACPI_DEVICE_NOTIFY,
 					     notify_handler,
@@ -206,6 +281,16 @@ static int intel_hid_probe(struct platform_device *device)
 	if (err)
 		goto err_remove_notify;
 
+	if (priv->array) {
+		intel_button_array_enable(&device->dev, true);
+
+		/* Call button load method to enable HID power button */
+		status = acpi_evaluate_object(handle, "BTNL", NULL, NULL);
+		if (ACPI_FAILURE(status))
+			dev_warn(&device->dev,
+				 "failed to enable HID power button\n");
+	}
+
 	return 0;
 
 err_remove_notify:
@@ -224,6 +309,7 @@ static int intel_hid_remove(struct platform_device *device)
 	acpi_remove_notify_handler(handle, ACPI_DEVICE_NOTIFY, notify_handler);
 	intel_hid_input_destroy(device);
 	intel_hid_set_enable(&device->dev, 0);
+	intel_button_array_enable(&device->dev, false);
 
 	/*
 	 * Even if we failed to shut off the event stream, we can still

commit e18bf801f1501e15830db5fa927a6e2832d49d7b
Merge: 8600b697cd47 cb2bf25145e0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 15 13:31:25 2016 -0800

    Merge tag 'platform-drivers-x86-v4.10-1' of git://git.infradead.org/users/dvhart/linux-platform-drivers-x86
    
    Pull x86 platform driver updates from Darrent Hart:
     "Introduce one new driver for Mellanox platforms. Add support for
      various new models to existing drivers via quirks, hotkeys, etc.
      Significant updates to intel_pmc_core in support of Kabylake and
      Sunrise Point PCH power management debug. Some cleanup and refactoring
      across various drivers.
    
      Detailed summary:
    
      dell-laptop:
       - Use brightness_set_blocking for kbd_led_level_set
    
      thinkpad_acpi:
       - Initialize local in_tablet_mode and type
       - Fix old style declaration GCC warning
       - Adding new hotkey ID for Lenovo thinkpad
       - Add support for X1 Yoga (2016) Tablet Mode
       - Move tablet detection into separate function
    
      asus-nb-wmi:
       - Add X45U quirk
       - Make use of dmi->ident
    
      asus-wmi:
       - Set specified XUSB2PR value for X550LB
    
      intel_mid_thermal:
       - Fix suspend handlers unused warning
    
      intel-vbtn:
       - Switch to use devm_input_allocate_device
    
      dell-wmi:
       - Add events created by Dell Rugged 2-in-1s
       - Adjust wifi catcher to emit KEY_WLAN
    
      intel_pmc_core:
       - Add KBL CPUID support
       - Add LTR IGNORE debug feature
       - Add MPHY PLL clock gating status
       - ModPhy core lanes pg status
       - Add PCH IP Power Gating Status
       - Fix PWRMBASE mask and mmio reg len
    
      acer-wmi:
       - Only supports AMW0_GUID1 on acer family
    
      mlx-platform:
       - Introduce support for Mellanox hotplug driver
    
      platform/x86:
       - Use ACPI_FAILURE at appropriate places"
    
    * tag 'platform-drivers-x86-v4.10-1' of git://git.infradead.org/users/dvhart/linux-platform-drivers-x86: (22 commits)
      platform/x86: thinkpad_acpi: Initialize local in_tablet_mode and type
      platform/x86: dell-laptop: Use brightness_set_blocking for kbd_led_level_set
      platform/x86: thinkpad_acpi: Fix old style declaration GCC warning
      platform/x86: thinkpad_acpi: Adding new hotkey ID for Lenovo thinkpad
      platform/x86: thinkpad_acpi: Add support for X1 Yoga (2016) Tablet Mode
      platform/x86: thinkpad_acpi: Move tablet detection into separate function
      platform/x86: asus-nb-wmi.c: Add X45U quirk
      platform/x86: asus-nb-wmi: Make use of dmi->ident
      platform/x86: asus-wmi: Set specified XUSB2PR value for X550LB
      platform/x86: intel_mid_thermal: Fix suspend handlers unused warning
      platform/x86: intel-vbtn: Switch to use devm_input_allocate_device
      platform/x86: Use ACPI_FAILURE at appropriate places
      platform/x86: dell-wmi: Add events created by Dell Rugged 2-in-1s
      platform/x86: dell-wmi: Adjust wifi catcher to emit KEY_WLAN
      platform/x86: intel_pmc_core: Add KBL CPUID support
      platform/x86: intel_pmc_core: Add LTR IGNORE debug feature
      platform/x86: intel_pmc_core: Add MPHY PLL clock gating status
      platform/x86: intel_pmc_core: ModPhy core lanes pg status
      platform/x86: intel_pmc_core: Add PCH IP Power Gating Status
      platform/x86: intel_pmc_core: Fix PWRMBASE mask and mmio reg len
      ...

commit 3526ecadc86cc1d485153255498cde7d0275dd37
Author: Axel Lin <axel.lin@ingics.com>
Date:   Mon Sep 19 09:33:51 2016 +0800

    platform/x86: Use ACPI_FAILURE at appropriate places
    
    Use ACPI_FAILURE() to replace !ACPI_SUCCESS(), this avoid !! operations.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Acked-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index ed5874217ee7..00cbeca2108d 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -69,7 +69,7 @@ static int intel_hid_set_enable(struct device *device, int enable)
 
 	arg0.integer.value = enable;
 	status = acpi_evaluate_object(ACPI_HANDLE(device), "HDSM", &args, NULL);
-	if (!ACPI_SUCCESS(status)) {
+	if (ACPI_FAILURE(status)) {
 		dev_warn(device, "failed to %sable hotkeys\n",
 			 enable ? "en" : "dis");
 		return -EIO;
@@ -148,7 +148,7 @@ static void notify_handler(acpi_handle handle, u32 event, void *context)
 	}
 
 	status = acpi_evaluate_integer(handle, "HDEM", NULL, &ev_index);
-	if (!ACPI_SUCCESS(status)) {
+	if (ACPI_FAILURE(status)) {
 		dev_warn(&device->dev, "failed to get event index\n");
 		return;
 	}
@@ -167,7 +167,7 @@ static int intel_hid_probe(struct platform_device *device)
 	int err;
 
 	status = acpi_evaluate_integer(handle, "HDMM", NULL, &mode);
-	if (!ACPI_SUCCESS(status)) {
+	if (ACPI_FAILURE(status)) {
 		dev_warn(&device->dev, "failed to read mode\n");
 		return -ENODEV;
 	}

commit 1571875beecd5de9657f73931449bda1b1329b6f
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Thu Nov 3 16:21:26 2016 +0200

    ACPI / platform: Add support for build-in properties
    
    We have a couple of drivers, acpi_apd.c and acpi_lpss.c,
    that need to pass extra build-in properties to the devices
    they create. Previously the drivers added those properties
    to the struct device which is member of the struct
    acpi_device, but that does not work. Those properties need
    to be assigned to the struct device of the platform device
    instead in order for them to become available to the
    drivers.
    
    To fix this, this patch changes acpi_create_platform_device
    function to take struct property_entry pointer as parameter.
    
    Fixes: 20a875e2e86e (serial: 8250_dw: Add quirk for APM X-Gene SoC)
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Tested-by: Yazen Ghannam <yazen.ghannam@amd.com>
    Tested-by: Jérôme de Bretagne <jerome.debretagne@gmail.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index ed5874217ee7..12dbb5063376 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -264,7 +264,7 @@ check_acpi_dev(acpi_handle handle, u32 lvl, void *context, void **rv)
 		return AE_OK;
 
 	if (acpi_match_device_ids(dev, ids) == 0)
-		if (acpi_create_platform_device(dev))
+		if (acpi_create_platform_device(dev, NULL))
 			dev_info(&dev->dev,
 				 "intel-hid: created platform device\n");
 

commit 1d6de071cb0c321279373634d81eb8e176d887c4
Author: Alex Hung <alex.hung@canonical.com>
Date:   Wed Jun 29 11:41:15 2016 +0800

    intel-hid: Remove duplicated acpi_remove_notify_handler
    
    The second call to acpi_remove_notify_handler does not result in panic
    or generate error messages, but it is unnecessary and the function
    returns with an error. Remove the duplicate call. Correct two improperly
    indented lines.
    
    Signed-off-by: Alex Hung <alex.hung@canonical.com>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index a818db6aa08f..ed5874217ee7 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -122,8 +122,8 @@ static int intel_hid_input_setup(struct platform_device *device)
 	return 0;
 
 err_free_device:
-		input_free_device(priv->input_dev);
-		return ret;
+	input_free_device(priv->input_dev);
+	return ret;
 }
 
 static void intel_hid_input_destroy(struct platform_device *device)
@@ -224,7 +224,6 @@ static int intel_hid_remove(struct platform_device *device)
 	acpi_remove_notify_handler(handle, ACPI_DEVICE_NOTIFY, notify_handler);
 	intel_hid_input_destroy(device);
 	intel_hid_set_enable(&device->dev, 0);
-	acpi_remove_notify_handler(handle, ACPI_DEVICE_NOTIFY, notify_handler);
 
 	/*
 	 * Even if we failed to shut off the event stream, we can still

commit 45aa56cd0ffc2ebc2274f1bacc985b6f032c0120
Author: Alex Hung <alex.hung@canonical.com>
Date:   Mon Mar 21 16:08:42 2016 +0800

    intel-hid: add a workaround to ignore an event after waking up from S4.
    
    This is the same as the original workaround from S3 but for S4.  Without
    this workaround, a rfkill event will be received and it will toggle
    wireless devices when radio hotkey is not pressed.
    
    Signed-off-by: Alex Hung <alex.hung@canonical.com>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index f93abc8c1424..a818db6aa08f 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -91,6 +91,8 @@ static int intel_hid_pl_resume_handler(struct device *device)
 }
 
 static const struct dev_pm_ops intel_hid_pl_pm_ops = {
+	.freeze  = intel_hid_pl_suspend_handler,
+	.restore  = intel_hid_pl_resume_handler,
 	.suspend  = intel_hid_pl_suspend_handler,
 	.resume  = intel_hid_pl_resume_handler,
 };

commit 5a010c73cdb760c9bdf37b28824b6566789cc005
Merge: b615d3d406ea fffcad87d4e7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 23 17:20:59 2016 -0700

    Merge tag 'platform-drivers-x86-v4.6-1' of git://git.infradead.org/users/dvhart/linux-platform-drivers-x86
    
    Pull x86 platform driver updates from Darren Hart:
     "Significant refactoring of Dell laptop drivers, modularizing the
      smbios code.  Multiple new platforms added for ideapad, asus, dell,
      and alienware using existing quirks.  A few fixes and cleanups.
    
      hp-wmi:
       - Remove GPS rfkill support via pre-2009 interface
       - fix unregister order in hp_wmi_rfkill_setup() once again
    
      ideapad-laptop:
       - Add ideapad Y700 (15) to the no_hw_rfkill DMI list
    
      fujitsu-laptop:
       - Support radio toggle button
    
      intel-hid:
       - allocate correct amount of memory for private struct
    
      platform/x86:
       - Make intel_scu_ipc explicitly non-modular
    
      intel_pmc_ipc:
       - Avoid pending IPC1 command during legacy suspend
       - Fix GCR register base address and length
    
      asus-nb-wmi:
       - add wapf=4 quirk for ASUS X75VD
    
      intel_telemetry_pltdrv:
       - Change verbosity control bits
    
      dell-rbtn:
       - Add a comment about the XPS 13 9350
    
      dell-wmi, dell-laptop:
       - depends DMI
    
      dell-wmi:
       - support Dell Inspiron M5110
       - properly process Dell Instant Launch hotkey
       - enable receiving WMI events on Dell Vostro V131
       - Support new hotkeys on the XPS 13 9350 (Skylake)
       - Clean up hotkey table size check
       - Stop storing pointers to DMI tables
    
      dell-laptop:
       - move dell_smi_error() to dell-smbios
       - use dell_smbios_find_token() instead of find_token_location()
       - use dell_smbios_find_token() instead of find_token_id()
       - extract SMBIOS-related code to a separate module
    
      dell-smbios:
       - rename dell_smi_error() to dell_smbios_error()
       - make da_tokens static
       - remove find_token_{id,location}()
       - implement new function for finding DMI table 0xDA tokens
       - make the SMBIOS buffer static
       - return the SMBIOS buffer from dell_smbios_get_buffer()
       - don't return an SMBIOS buffer from dell_smbios_send_request()
       - don't pass an SMBIOS buffer to dell_smbios_send_request()
       - rename dell_send_request() to dell_smbios_send_request()
       - rename release_buffer() to dell_smbios_release_buffer()
       - rename clear_buffer() to dell_smbios_clear_buffer()
       - rename get_buffer() to dell_smbios_get_buffer()
    
      dell-led:
       - use dell_smbios_send_request() for performing SMBIOS calls
       - use dell_smbios_find_token() for finding mic DMI tokens
    
      toshiba_acpi:
       - Add a module parameter to disable hotkeys registration
       - Add sysfs entries for the Cooling Method feature
       - Add support for cooling method feature
    
      Documentation/ABI:
       - Update sysfs-driver-toshiba_acpi file
    
      thinkpad_acpi:
       - Remove ambiguous logging for "Unsupported brightness interface"
    
      alienware-wmi:
       - whitespace improvements
       - Add support for two new systems: ASM200 and ASM201.
       - Add support for deep sleep control.
       - Add initial support for alienware graphics amplifier.
       - Add support for new platform: X51-R3
       - Clean up whitespace for ASM100 platform"
    
    * tag 'platform-drivers-x86-v4.6-1' of git://git.infradead.org/users/dvhart/linux-platform-drivers-x86: (47 commits)
      hp-wmi: Remove GPS rfkill support via pre-2009 interface
      hp-wmi: fix unregister order in hp_wmi_rfkill_setup() once again
      dell-wmi: support Dell Inspiron M5110
      dell-wmi: properly process Dell Instant Launch hotkey
      dell-wmi: enable receiving WMI events on Dell Vostro V131
      dell-smbios: rename dell_smi_error() to dell_smbios_error()
      dell-laptop: move dell_smi_error() to dell-smbios
      ideapad-laptop: Add ideapad Y700 (15) to the no_hw_rfkill DMI list
      fujitsu-laptop: Support radio toggle button
      intel-hid: allocate correct amount of memory for private struct
      platform/x86: Make intel_scu_ipc explicitly non-modular
      intel_pmc_ipc: Avoid pending IPC1 command during legacy suspend
      intel_pmc_ipc: Fix GCR register base address and length
      asus-nb-wmi: add wapf=4 quirk for ASUS X75VD
      intel_telemetry_pltdrv: Change verbosity control bits
      dell-rbtn: Add a comment about the XPS 13 9350
      dell-wmi: Support new hotkeys on the XPS 13 9350 (Skylake)
      dell-wmi: Clean up hotkey table size check
      dell-wmi, dell-laptop: depends DMI
      dell-wmi: Stop storing pointers to DMI tables
      ...

commit e8b69a51b4e72a168e8b3bc5fcac39a7de339864
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Sun Feb 21 15:22:27 2016 +0100

    intel-hid: allocate correct amount of memory for private struct
    
    We want the size of the struct, not of a pointer to it. To be future
    proof, just dereference the pointer to get the desired type.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index 20f0ad9bb9f3..9d15afe70b4f 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -181,8 +181,7 @@ static int intel_hid_probe(struct platform_device *device)
 		return -ENODEV;
 	}
 
-	priv = devm_kzalloc(&device->dev,
-			    sizeof(struct intel_hid_priv *), GFP_KERNEL);
+	priv = devm_kzalloc(&device->dev, sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
 	dev_set_drvdata(&device->dev, priv);

commit 1c319e781e0ecc48228081558f38044a11c7a76e
Author: Alex Hung <alex.hung@canonical.com>
Date:   Wed Jan 27 21:35:00 2016 +0800

    intel-hid: fix incorrect entries in intel_hid_keymap
    
    intel_hid_keymap contains a duplicate entry for KEY_HOME and an
    incorrect HID index for KEY_PAGEDOWN
    
    Reported-by: Pavel Bludov <pbludov@gmail.com>
    Signed-off-by: Alex Hung <alex.hung@canonical.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
index 20f0ad9bb9f3..e20f23e04c24 100644
--- a/drivers/platform/x86/intel-hid.c
+++ b/drivers/platform/x86/intel-hid.c
@@ -41,8 +41,7 @@ static const struct key_entry intel_hid_keymap[] = {
 	{ KE_KEY, 4, { KEY_HOME } },
 	{ KE_KEY, 5, { KEY_END } },
 	{ KE_KEY, 6, { KEY_PAGEUP } },
-	{ KE_KEY, 4, { KEY_PAGEDOWN } },
-	{ KE_KEY, 4, { KEY_HOME } },
+	{ KE_KEY, 7, { KEY_PAGEDOWN } },
 	{ KE_KEY, 8, { KEY_RFKILL } },
 	{ KE_KEY, 9, { KEY_POWER } },
 	{ KE_KEY, 11, { KEY_SLEEP } },

commit ecc83e52b28c707da3e7fb8aa471417d9c0d1ec7
Author: Alex Hung <alex.hung@canonical.com>
Date:   Fri Dec 18 23:31:10 2015 +0800

    intel-hid: new hid event driver for hotkeys
    
    This driver supports various HID events including hotkeys.
    Dell XPS 13 9350 requires it for the wireless hotkey.
    
    Signed-off-by: Alex Hung <alex.hung@canonical.com>
    Reviewed-and-tested-by: Andy Lutomirski <luto@kernel.org>
    
    [dvhart: Kconfig help typo fix and INPUT_SPARSEKMAP fix from Sedat Dilek]
    
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/intel-hid.c b/drivers/platform/x86/intel-hid.c
new file mode 100644
index 000000000000..20f0ad9bb9f3
--- /dev/null
+++ b/drivers/platform/x86/intel-hid.c
@@ -0,0 +1,289 @@
+/*
+ *  Intel HID event driver for Windows 8
+ *
+ *  Copyright (C) 2015 Alex Hung <alex.hung@canonical.com>
+ *  Copyright (C) 2015 Andrew Lutomirski <luto@kernel.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+#include <linux/input/sparse-keymap.h>
+#include <linux/acpi.h>
+#include <acpi/acpi_bus.h>
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Alex Hung");
+
+static const struct acpi_device_id intel_hid_ids[] = {
+	{"INT33D5", 0},
+	{"", 0},
+};
+
+/* In theory, these are HID usages. */
+static const struct key_entry intel_hid_keymap[] = {
+	/* 1: LSuper (Page 0x07, usage 0xE3) -- unclear what to do */
+	/* 2: Toggle SW_ROTATE_LOCK -- easy to implement if seen in wild */
+	{ KE_KEY, 3, { KEY_NUMLOCK } },
+	{ KE_KEY, 4, { KEY_HOME } },
+	{ KE_KEY, 5, { KEY_END } },
+	{ KE_KEY, 6, { KEY_PAGEUP } },
+	{ KE_KEY, 4, { KEY_PAGEDOWN } },
+	{ KE_KEY, 4, { KEY_HOME } },
+	{ KE_KEY, 8, { KEY_RFKILL } },
+	{ KE_KEY, 9, { KEY_POWER } },
+	{ KE_KEY, 11, { KEY_SLEEP } },
+	/* 13 has two different meanings in the spec -- ignore it. */
+	{ KE_KEY, 14, { KEY_STOPCD } },
+	{ KE_KEY, 15, { KEY_PLAYPAUSE } },
+	{ KE_KEY, 16, { KEY_MUTE } },
+	{ KE_KEY, 17, { KEY_VOLUMEUP } },
+	{ KE_KEY, 18, { KEY_VOLUMEDOWN } },
+	{ KE_KEY, 19, { KEY_BRIGHTNESSUP } },
+	{ KE_KEY, 20, { KEY_BRIGHTNESSDOWN } },
+	/* 27: wake -- needs special handling */
+	{ KE_END },
+};
+
+struct intel_hid_priv {
+	struct input_dev *input_dev;
+};
+
+static int intel_hid_set_enable(struct device *device, int enable)
+{
+	union acpi_object arg0 = { ACPI_TYPE_INTEGER };
+	struct acpi_object_list args = { 1, &arg0 };
+	acpi_status status;
+
+	arg0.integer.value = enable;
+	status = acpi_evaluate_object(ACPI_HANDLE(device), "HDSM", &args, NULL);
+	if (!ACPI_SUCCESS(status)) {
+		dev_warn(device, "failed to %sable hotkeys\n",
+			 enable ? "en" : "dis");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int intel_hid_pl_suspend_handler(struct device *device)
+{
+	intel_hid_set_enable(device, 0);
+	return 0;
+}
+
+static int intel_hid_pl_resume_handler(struct device *device)
+{
+	intel_hid_set_enable(device, 1);
+	return 0;
+}
+
+static const struct dev_pm_ops intel_hid_pl_pm_ops = {
+	.suspend  = intel_hid_pl_suspend_handler,
+	.resume  = intel_hid_pl_resume_handler,
+};
+
+static int intel_hid_input_setup(struct platform_device *device)
+{
+	struct intel_hid_priv *priv = dev_get_drvdata(&device->dev);
+	int ret;
+
+	priv->input_dev = input_allocate_device();
+	if (!priv->input_dev)
+		return -ENOMEM;
+
+	ret = sparse_keymap_setup(priv->input_dev, intel_hid_keymap, NULL);
+	if (ret)
+		goto err_free_device;
+
+	priv->input_dev->dev.parent = &device->dev;
+	priv->input_dev->name = "Intel HID events";
+	priv->input_dev->id.bustype = BUS_HOST;
+	set_bit(KEY_RFKILL, priv->input_dev->keybit);
+
+	ret = input_register_device(priv->input_dev);
+	if (ret)
+		goto err_free_device;
+
+	return 0;
+
+err_free_device:
+		input_free_device(priv->input_dev);
+		return ret;
+}
+
+static void intel_hid_input_destroy(struct platform_device *device)
+{
+	struct intel_hid_priv *priv = dev_get_drvdata(&device->dev);
+
+	input_unregister_device(priv->input_dev);
+}
+
+static void notify_handler(acpi_handle handle, u32 event, void *context)
+{
+	struct platform_device *device = context;
+	struct intel_hid_priv *priv = dev_get_drvdata(&device->dev);
+	unsigned long long ev_index;
+	acpi_status status;
+
+	/* The platform spec only defines one event code: 0xC0. */
+	if (event != 0xc0) {
+		dev_warn(&device->dev, "received unknown event (0x%x)\n",
+			 event);
+		return;
+	}
+
+	status = acpi_evaluate_integer(handle, "HDEM", NULL, &ev_index);
+	if (!ACPI_SUCCESS(status)) {
+		dev_warn(&device->dev, "failed to get event index\n");
+		return;
+	}
+
+	if (!sparse_keymap_report_event(priv->input_dev, ev_index, 1, true))
+		dev_info(&device->dev, "unknown event index 0x%llx\n",
+			 ev_index);
+}
+
+static int intel_hid_probe(struct platform_device *device)
+{
+	acpi_handle handle = ACPI_HANDLE(&device->dev);
+	struct intel_hid_priv *priv;
+	unsigned long long mode;
+	acpi_status status;
+	int err;
+
+	status = acpi_evaluate_integer(handle, "HDMM", NULL, &mode);
+	if (!ACPI_SUCCESS(status)) {
+		dev_warn(&device->dev, "failed to read mode\n");
+		return -ENODEV;
+	}
+
+	if (mode != 0) {
+		/*
+		 * This driver only implements "simple" mode.  There appear
+		 * to be no other modes, but we should be paranoid and check
+		 * for compatibility.
+		 */
+		dev_info(&device->dev, "platform is not in simple mode\n");
+		return -ENODEV;
+	}
+
+	priv = devm_kzalloc(&device->dev,
+			    sizeof(struct intel_hid_priv *), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+	dev_set_drvdata(&device->dev, priv);
+
+	err = intel_hid_input_setup(device);
+	if (err) {
+		pr_err("Failed to setup Intel HID hotkeys\n");
+		return err;
+	}
+
+	status = acpi_install_notify_handler(handle,
+					     ACPI_DEVICE_NOTIFY,
+					     notify_handler,
+					     device);
+	if (ACPI_FAILURE(status)) {
+		err = -EBUSY;
+		goto err_remove_input;
+	}
+
+	err = intel_hid_set_enable(&device->dev, 1);
+	if (err)
+		goto err_remove_notify;
+
+	return 0;
+
+err_remove_notify:
+	acpi_remove_notify_handler(handle, ACPI_DEVICE_NOTIFY, notify_handler);
+
+err_remove_input:
+	intel_hid_input_destroy(device);
+
+	return err;
+}
+
+static int intel_hid_remove(struct platform_device *device)
+{
+	acpi_handle handle = ACPI_HANDLE(&device->dev);
+
+	acpi_remove_notify_handler(handle, ACPI_DEVICE_NOTIFY, notify_handler);
+	intel_hid_input_destroy(device);
+	intel_hid_set_enable(&device->dev, 0);
+	acpi_remove_notify_handler(handle, ACPI_DEVICE_NOTIFY, notify_handler);
+
+	/*
+	 * Even if we failed to shut off the event stream, we can still
+	 * safely detach from the device.
+	 */
+	return 0;
+}
+
+static struct platform_driver intel_hid_pl_driver = {
+	.driver = {
+		.name = "intel-hid",
+		.acpi_match_table = intel_hid_ids,
+		.pm = &intel_hid_pl_pm_ops,
+	},
+	.probe = intel_hid_probe,
+	.remove = intel_hid_remove,
+};
+MODULE_DEVICE_TABLE(acpi, intel_hid_ids);
+
+/*
+ * Unfortunately, some laptops provide a _HID="INT33D5" device with
+ * _CID="PNP0C02".  This causes the pnpacpi scan driver to claim the
+ * ACPI node, so no platform device will be created.  The pnpacpi
+ * driver rejects this device in subsequent processing, so no physical
+ * node is created at all.
+ *
+ * As a workaround until the ACPI core figures out how to handle
+ * this corner case, manually ask the ACPI platform device code to
+ * claim the ACPI node.
+ */
+static acpi_status __init
+check_acpi_dev(acpi_handle handle, u32 lvl, void *context, void **rv)
+{
+	const struct acpi_device_id *ids = context;
+	struct acpi_device *dev;
+
+	if (acpi_bus_get_device(handle, &dev) != 0)
+		return AE_OK;
+
+	if (acpi_match_device_ids(dev, ids) == 0)
+		if (acpi_create_platform_device(dev))
+			dev_info(&dev->dev,
+				 "intel-hid: created platform device\n");
+
+	return AE_OK;
+}
+
+static int __init intel_hid_init(void)
+{
+	acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
+			    ACPI_UINT32_MAX, check_acpi_dev, NULL,
+			    (void *)intel_hid_ids, NULL);
+
+	return platform_driver_register(&intel_hid_pl_driver);
+}
+module_init(intel_hid_init);
+
+static void __exit intel_hid_exit(void)
+{
+	platform_driver_unregister(&intel_hid_pl_driver);
+}
+module_exit(intel_hid_exit);
