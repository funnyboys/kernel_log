commit 55167453111d3a1e600e29ba6c8e63906bb4821b
Merge: fde7dc63b1ca 7d67c8ac25fb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jul 14 16:51:47 2019 -0700

    Merge tag 'platform-drivers-x86-v5.3-1' of git://git.infradead.org/linux-platform-drivers-x86
    
    Pull x86 platform driver updates from Andy Shevchenko:
     "Gathered a bunch of x86 platform driver changes. It's rather big,
      since includes two big refactors and completely new driver:
    
       - ASUS WMI driver got a big refactoring in order to support the TUF
         Gaming laptops. Besides that, the regression with backlight being
         permanently off on various EeePC laptops has been fixed.
    
       - Accelerometer on HP ProBook 450 G0 shows wrong measurements due to
         X axis being inverted. This has been fixed.
    
       - Intel PMC core driver has been extended to be ACPI enumerated if
         the DSDT provides device with _HID "INT33A1". This allows to
         convert the driver to be pure platform and support new hardware
         purely based on ACPI DSDT.
    
       - From now on the Intel Speed Select Technology is supported thru a
         corresponding driver. This driver provides an access to the
         features of the ISST, such as Performance Profile, Core Power, Base
         frequency and Turbo Frequency.
    
       - Mellanox platform drivers has been refactored and now extended to
         support more systems, including new coming ones.
    
       - The OLPC XO-1.75 platform is now supported.
    
       - CB4063 Beckhoff Automation board is using PMC clocks, provided via
         pmc_atom driver, for ethernet controllers in a way that they can't
         be managed by the clock driver. The quirk has been extended to
         cover this case.
    
       - Touchscreen on Chuwi Hi10 Plus tablet has been enabled. Meanwhile
         the information of Chuwi Hi10 Air has been fixed to cover more
         models based on the same platform.
    
       - Xiaomi notebooks have WMI interface enabled. Thus, the driver to
         support it has been provided. It required some extension of the
         generic WMI library, which allows to propagate opaque context to
         the ->probe() of the individual drivers.
    
      This release includes debugfs clean up from Greg KH for several
      drivers that drop return code check and make debugfs absence or
      failure non-fatal.
    
      Also miscellaneous fixes here and there, mostly for Acer WMI and
      various Intel drivers"
    
    * tag 'platform-drivers-x86-v5.3-1' of git://git.infradead.org/linux-platform-drivers-x86: (74 commits)
      platform/x86: Fix PCENGINES_APU2 Kconfig warning
      tools/power/x86/intel-speed-select: Add .gitignore file
      platform/x86: mlx-platform: Fix error handling in mlxplat_init()
      platform/x86: intel_pmc_core: Attach using APCI HID "INT33A1"
      platform/x86: intel_pmc_core: transform Pkg C-state residency from TSC ticks into microseconds
      platform/x86: asus-wmi: Use dev_get_drvdata()
      Documentation/ABI: Add new attribute for mlxreg-io sysfs interfaces
      platform/x86: mlx-platform: Add more reset cause attributes
      platform/x86: mlx-platform: Modify DMI matching order
      platform/x86: mlx-platform: Add regmap structure for the next generation systems
      platform/x86: mlx-platform: Change API for i2c-mlxcpld driver activation
      platform/x86: mlx-platform: Move regmap initialization before all drivers activation
      MAINTAINERS: Update for Intel Speed Select Technology
      tools/power/x86: A tool to validate Intel Speed Select commands
      platform/x86: ISST: Restore state on resume
      platform/x86: ISST: Add Intel Speed Select PUNIT MSR interface
      platform/x86: ISST: Add Intel Speed Select mailbox interface via MSRs
      platform/x86: ISST: Add Intel Speed Select mailbox interface via PCI
      platform/x86: ISST: Add Intel Speed Select mmio interface
      platform/x86: ISST: Add IOCTL to Translate Linux logical CPU to PUNIT CPU number
      ...

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/platform/x86/dell-smbios-wmi.c b/drivers/platform/x86/dell-smbios-wmi.c
index c3ed3c8c17b9..942b5b77883a 100644
--- a/drivers/platform/x86/dell-smbios-wmi.c
+++ b/drivers/platform/x86/dell-smbios-wmi.c
@@ -1,11 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  WMI methods for use with dell-smbios
  *
  *  Copyright (c) 2017 Dell Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
  */
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 

commit 440c4983de262f78033ec58f6abcd199a664327d
Author: Mattias Jacobsson <2pi@mok.nu>
Date:   Mon May 27 18:21:30 2019 +0200

    platform/x86: wmi: add context argument to the probe function
    
    The struct wmi_device_id has a context pointer field, forward this
    pointer as an argument to the probe function in struct wmi_driver.
    
    Update existing users of the same probe function to accept this new
    context argument.
    
    Signed-off-by: Mattias Jacobsson <2pi@mok.nu>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/dell-smbios-wmi.c b/drivers/platform/x86/dell-smbios-wmi.c
index c3ed3c8c17b9..add2687079f7 100644
--- a/drivers/platform/x86/dell-smbios-wmi.c
+++ b/drivers/platform/x86/dell-smbios-wmi.c
@@ -146,7 +146,7 @@ static long dell_smbios_wmi_filter(struct wmi_device *wdev, unsigned int cmd,
 	return ret;
 }
 
-static int dell_smbios_wmi_probe(struct wmi_device *wdev)
+static int dell_smbios_wmi_probe(struct wmi_device *wdev, const void *context)
 {
 	struct wmi_driver *wdriver =
 		container_of(wdev->dev.driver, struct wmi_driver, driver);

commit 449ffaba357202e639c79a79ad8a898e77c5ae91
Author: Mattias Jacobsson <2pi@mok.nu>
Date:   Tue Feb 19 20:59:51 2019 +0100

    platform/x86: dell-smbios-wmi: use MODULE_DEVICE_TABLE() instead of MODULE_ALIAS()
    
    WMI drivers can if they have specified an array of struct wmi_device_id
    use the MODULE_DEVICE_TABLE() macro to automatically generate the
    appropriate MODULE_ALIAS() output. Thus avoiding to keep both the array
    of struct wmi_device_id and the MODULE_ALIAS() declaration(s) in sync.
    
    Change driver to use MODULE_DEVICE_TABLE() instead of MODULE_ALIAS().
    
    Signed-off-by: Mattias Jacobsson <2pi@mok.nu>
    Reviewed-by: Mario Limonciello <mario.limonciello@dell.com>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/dell-smbios-wmi.c b/drivers/platform/x86/dell-smbios-wmi.c
index cf2229ece9ff..c3ed3c8c17b9 100644
--- a/drivers/platform/x86/dell-smbios-wmi.c
+++ b/drivers/platform/x86/dell-smbios-wmi.c
@@ -277,4 +277,4 @@ void exit_dell_smbios_wmi(void)
 	wmi_driver_unregister(&dell_smbios_wmi_driver);
 }
 
-MODULE_ALIAS("wmi:" DELL_WMI_SMBIOS_GUID);
+MODULE_DEVICE_TABLE(wmi, dell_smbios_wmi_id_table);

commit affab51082174f60ef71ced8ab5fbe71f00e9ae3
Author: Mario Limonciello <mario.limonciello@dell.com>
Date:   Mon Sep 10 13:01:52 2018 -0500

    platform/x86: dell-smbios-wmi: Correct a memory leak
    
    ACPI buffers were being allocated but never freed.
    
    Reported-by: Pinzhen Xu <pinzhen.xu@intel.com>
    Signed-off-by: Mario Limonciello <mario.limonciello@dell.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/dell-smbios-wmi.c b/drivers/platform/x86/dell-smbios-wmi.c
index 88afe5651d24..cf2229ece9ff 100644
--- a/drivers/platform/x86/dell-smbios-wmi.c
+++ b/drivers/platform/x86/dell-smbios-wmi.c
@@ -78,6 +78,7 @@ static int run_smbios_call(struct wmi_device *wdev)
 	dev_dbg(&wdev->dev, "result: [%08x,%08x,%08x,%08x]\n",
 		priv->buf->std.output[0], priv->buf->std.output[1],
 		priv->buf->std.output[2], priv->buf->std.output[3]);
+	kfree(output.pointer);
 
 	return 0;
 }

commit 10a2032d7a6ac1d9e435ecb355fcc297e550d148
Author: Colin Ian King <colin.king@canonical.com>
Date:   Sat Jun 30 13:10:24 2018 +0100

    platform/x86: dell-smbios-wmi: make function dell_smbios_wmi_call static
    
    The function dell_smbios_wmi_call is local to the source and does not
    need to be in global scope, so make it static.
    
    Cleans up sparse warning:
    symbol 'dell_smbios_wmi_call' was not declared. Should it be static?
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Acked-by: Mario Limonciello <mario.limonciello@dell.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/dell-smbios-wmi.c b/drivers/platform/x86/dell-smbios-wmi.c
index fbefedb1c172..88afe5651d24 100644
--- a/drivers/platform/x86/dell-smbios-wmi.c
+++ b/drivers/platform/x86/dell-smbios-wmi.c
@@ -82,7 +82,7 @@ static int run_smbios_call(struct wmi_device *wdev)
 	return 0;
 }
 
-int dell_smbios_wmi_call(struct calling_interface_buffer *buffer)
+static int dell_smbios_wmi_call(struct calling_interface_buffer *buffer)
 {
 	struct wmi_smbios_priv *priv;
 	size_t difference;

commit 25d47027e1003546bfd8964b4423cb39bc2d53e9
Author: Mario Limonciello <mario.limonciello@dell.com>
Date:   Tue Feb 27 12:23:04 2018 -0600

    platform/x86: dell-smbios: Link all dell-smbios-* modules together
    
    Some race conditions were raised due to dell-smbios and its backends
    not being ready by the time that a consumer would call one of the
    exported methods.
    
    To avoid this problem, guarantee that all initialization has been
    done by linking them all together and running init for them all.
    
    As part of this change the Kconfig needs to be adjusted so that
    CONFIG_DELL_SMBIOS_SMM and CONFIG_DELL_SMBIOS_WMI are boolean
    rather than modules.
    
    CONFIG_DELL_SMBIOS is a visually selectable option again and both
    CONFIG_DELL_SMBIOS_WMI and CONFIG_DELL_SMBIOS_SMM are optional.
    
    Signed-off-by: Mario Limonciello <mario.limonciello@dell.com>
    [dvhart: Update prompt and help text for DELL_SMBIOS_* backends]
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/dell-smbios-wmi.c b/drivers/platform/x86/dell-smbios-wmi.c
index 609557aa5868..fbefedb1c172 100644
--- a/drivers/platform/x86/dell-smbios-wmi.c
+++ b/drivers/platform/x86/dell-smbios-wmi.c
@@ -228,7 +228,7 @@ static const struct wmi_device_id dell_smbios_wmi_id_table[] = {
 	{ },
 };
 
-static void __init parse_b1_table(const struct dmi_header *dm)
+static void parse_b1_table(const struct dmi_header *dm)
 {
 	struct misc_bios_flags_structure *flags =
 	container_of(dm, struct misc_bios_flags_structure, header);
@@ -242,7 +242,7 @@ static void __init parse_b1_table(const struct dmi_header *dm)
 		wmi_supported = 1;
 }
 
-static void __init find_b1(const struct dmi_header *dm, void *dummy)
+static void find_b1(const struct dmi_header *dm, void *dummy)
 {
 	switch (dm->type) {
 	case 0xb1: /* misc bios flags */
@@ -261,7 +261,7 @@ static struct wmi_driver dell_smbios_wmi_driver = {
 	.filter_callback = dell_smbios_wmi_filter,
 };
 
-static int __init init_dell_smbios_wmi(void)
+int init_dell_smbios_wmi(void)
 {
 	dmi_walk(find_b1, NULL);
 
@@ -271,15 +271,9 @@ static int __init init_dell_smbios_wmi(void)
 	return wmi_driver_register(&dell_smbios_wmi_driver);
 }
 
-static void __exit exit_dell_smbios_wmi(void)
+void exit_dell_smbios_wmi(void)
 {
 	wmi_driver_unregister(&dell_smbios_wmi_driver);
 }
 
-module_init(init_dell_smbios_wmi);
-module_exit(exit_dell_smbios_wmi);
-
 MODULE_ALIAS("wmi:" DELL_WMI_SMBIOS_GUID);
-MODULE_AUTHOR("Mario Limonciello <mario.limonciello@dell.com>");
-MODULE_DESCRIPTION("Dell SMBIOS communications over WMI");
-MODULE_LICENSE("GPL");

commit 4255c30fe88ee3cc99bbeac7974db27e4217a497
Author: Mario Limonciello <mario.limonciello@dell.com>
Date:   Thu Nov 16 22:13:12 2017 -0600

    platform/x86: dell-smbios-wmi: Disable userspace interface if missing hotfix
    
    The Dell SMBIOS WMI interface will fail for some more complex calls unless
    a WMI hotfix has been included.  Most platforms have this fix available in
    a maintenance BIOS release.  In the case the driver is loaded on a
    platform without this fix, disable the userspace interface.
    
    A hotfix indicator is present in the dell-wmi-descriptor that represents
    whether or not more complex calls will work properly.
    
    "Simple" calls such as those used by dell-laptop and dell-wmi will continue
    to work properly so dell-smbios-wmi should not be blocked from binding and
    being used as the dell-smbios dispatcher.
    
    Suggested-by: Girish Prakash <girish.prakash@dell.com>
    Signed-off-by: Mario Limonciello <mario.limonciello@dell.com>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/dell-smbios-wmi.c b/drivers/platform/x86/dell-smbios-wmi.c
index 0cab1f9c35af..609557aa5868 100644
--- a/drivers/platform/x86/dell-smbios-wmi.c
+++ b/drivers/platform/x86/dell-smbios-wmi.c
@@ -147,7 +147,10 @@ static long dell_smbios_wmi_filter(struct wmi_device *wdev, unsigned int cmd,
 
 static int dell_smbios_wmi_probe(struct wmi_device *wdev)
 {
+	struct wmi_driver *wdriver =
+		container_of(wdev->dev.driver, struct wmi_driver, driver);
 	struct wmi_smbios_priv *priv;
+	u32 hotfix;
 	int count;
 	int ret;
 
@@ -164,6 +167,16 @@ static int dell_smbios_wmi_probe(struct wmi_device *wdev)
 	if (!dell_wmi_get_size(&priv->req_buf_size))
 		return -EPROBE_DEFER;
 
+	/* some SMBIOS calls fail unless BIOS contains hotfix */
+	if (!dell_wmi_get_hotfix(&hotfix))
+		return -EPROBE_DEFER;
+	if (!hotfix) {
+		dev_warn(&wdev->dev,
+			"WMI SMBIOS userspace interface not supported(%u), try upgrading to a newer BIOS\n",
+			hotfix);
+		wdriver->filter_callback = NULL;
+	}
+
 	/* add in the length object we will use internally with ioctl */
 	priv->req_buf_size += sizeof(u64);
 	ret = set_required_buffer_size(wdev, priv->req_buf_size);

commit 868b8d33f91e431b1961a35baa6b5022639067f3
Author: Mario Limonciello <mario.limonciello@dell.com>
Date:   Thu Nov 9 11:49:10 2017 -0600

    platform/x86: dell-*wmi*: Relay failed initial probe to dependent drivers
    
    dell-wmi and dell-smbios-wmi are dependent upon dell-wmi-descriptor
    finishing probe successfully to probe themselves.
    
    Currently if dell-wmi-descriptor fails probing in a non-recoverable way
    (such as invalid header) dell-wmi and dell-smbios-wmi will continue to
    try to redo probing due to deferred probing.
    
    To solve this have the dependent drivers query the dell-wmi-descriptor
    driver whether the descriptor has been determined valid. The possible
    results are:
    -ENODEV: Descriptor GUID missing from WMI bus
    -EPROBE_DEFER: Descriptor not yet probed, dependent driver should wait
     and use deferred probing
    < 0: Descriptor probed, invalid.  Dependent driver should return an
     error.
    0: Successful descriptor probe, dependent driver can continue
    
    Successful descriptor probe still doesn't mean that the descriptor driver
    is necessarily bound at the time of initialization of dependent driver.
    Userspace can unbind the driver, so all methods used from driver
    should still be verified to return success values otherwise deferred
    probing be used.
    
    Signed-off-by: Mario Limonciello <mario.limonciello@dell.com>
    Reviewed-by: Pali Roh√°r <pali.rohar@gmail.com>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/dell-smbios-wmi.c b/drivers/platform/x86/dell-smbios-wmi.c
index 5cf9b13ce6e6..0cab1f9c35af 100644
--- a/drivers/platform/x86/dell-smbios-wmi.c
+++ b/drivers/platform/x86/dell-smbios-wmi.c
@@ -151,8 +151,9 @@ static int dell_smbios_wmi_probe(struct wmi_device *wdev)
 	int count;
 	int ret;
 
-	if (!wmi_has_guid(DELL_WMI_DESCRIPTOR_GUID))
-		return -ENODEV;
+	ret = dell_wmi_get_descriptor_valid();
+	if (ret)
+		return ret;
 
 	priv = devm_kzalloc(&wdev->dev, sizeof(struct wmi_smbios_priv),
 			    GFP_KERNEL);

commit 307ab2a99d190d3a7949258b8551b66887ce8cf4
Author: Mario Limonciello <mario.limonciello@dell.com>
Date:   Sun Nov 5 21:34:34 2017 -0600

    platform/x86: dell-smbios-wmi: release mutex lock on WMI call failure
    
    Unbound devices may race with calling this function causing the mutex
    to stay locked.  This failure mode should have released the mutex too.
    
    Signed-off-by: Mario Limonciello <mario.limonciello@dell.com>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/dell-smbios-wmi.c b/drivers/platform/x86/dell-smbios-wmi.c
index 35c13815b24c..5cf9b13ce6e6 100644
--- a/drivers/platform/x86/dell-smbios-wmi.c
+++ b/drivers/platform/x86/dell-smbios-wmi.c
@@ -91,8 +91,10 @@ int dell_smbios_wmi_call(struct calling_interface_buffer *buffer)
 
 	mutex_lock(&call_mutex);
 	priv = get_first_smbios_priv();
-	if (!priv)
-		return -ENODEV;
+	if (!priv) {
+		ret = -ENODEV;
+		goto out_wmi_call;
+	}
 
 	size = sizeof(struct calling_interface_buffer);
 	difference = priv->req_buf_size - sizeof(u64) - size;
@@ -101,6 +103,7 @@ int dell_smbios_wmi_call(struct calling_interface_buffer *buffer)
 	memcpy(&priv->buf->std, buffer, size);
 	ret = run_smbios_call(priv->wdev);
 	memcpy(buffer, &priv->buf->std, size);
+out_wmi_call:
 	mutex_unlock(&call_mutex);
 
 	return ret;

commit f2645fa317b8905b8934f06a0601d5b7fa66aba0
Author: Mario Limonciello <mario.limonciello@dell.com>
Date:   Wed Nov 1 14:25:36 2017 -0500

    platform/x86: dell-smbios-wmi: introduce userspace interface
    
    It's important for the driver to provide a R/W ioctl to ensure that
    two competing userspace processes don't race to provide or read each
    others data.
    
    This userspace character device will be used to perform SMBIOS calls
    from any applications.
    
    It provides an ioctl that will allow passing the WMI calling
    interface buffer between userspace and kernel space.
    
    This character device is intended to deprecate the dcdbas kernel module
    and the interface that it provides to userspace.
    
    To perform an SMBIOS IOCTL call using the character device userspace will
    perform a read() on the the character device.  The WMI bus will provide
    a u64 variable containing the necessary size of the IOCTL buffer.
    
    The API for interacting with this interface is defined in documentation
    as well as the WMI uapi header provides the format of the structures.
    
    Not all userspace requests will be accepted.  The dell-smbios filtering
    functionality will be used to prevent access to certain tokens and calls.
    
    All whitelisted commands and tokens are now shared out to userspace so
    applications don't need to define them in their own headers.
    
    Signed-off-by: Mario Limonciello <mario.limonciello@dell.com>
    Reviewed-by: Edward O'Callaghan <quasisec@google.com>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/dell-smbios-wmi.c b/drivers/platform/x86/dell-smbios-wmi.c
index b31f457e58c3..35c13815b24c 100644
--- a/drivers/platform/x86/dell-smbios-wmi.c
+++ b/drivers/platform/x86/dell-smbios-wmi.c
@@ -30,17 +30,6 @@ struct misc_bios_flags_structure {
 
 #define DELL_WMI_SMBIOS_GUID "A80593CE-A997-11DA-B012-B622A1EF5492"
 
-struct dell_wmi_extensions {
-	__u32 argattrib;
-	__u32 blength;
-	__u8 data[];
-} __packed;
-
-struct dell_wmi_smbios_buffer {
-	struct calling_interface_buffer std;
-	struct dell_wmi_extensions ext;
-} __packed;
-
 struct wmi_smbios_priv {
 	struct dell_wmi_smbios_buffer *buf;
 	struct list_head list;
@@ -117,6 +106,42 @@ int dell_smbios_wmi_call(struct calling_interface_buffer *buffer)
 	return ret;
 }
 
+static long dell_smbios_wmi_filter(struct wmi_device *wdev, unsigned int cmd,
+				   struct wmi_ioctl_buffer *arg)
+{
+	struct wmi_smbios_priv *priv;
+	int ret = 0;
+
+	switch (cmd) {
+	case DELL_WMI_SMBIOS_CMD:
+		mutex_lock(&call_mutex);
+		priv = dev_get_drvdata(&wdev->dev);
+		if (!priv) {
+			ret = -ENODEV;
+			goto fail_smbios_cmd;
+		}
+		memcpy(priv->buf, arg, priv->req_buf_size);
+		if (dell_smbios_call_filter(&wdev->dev, &priv->buf->std)) {
+			dev_err(&wdev->dev, "Invalid call %d/%d:%8x\n",
+				priv->buf->std.cmd_class,
+				priv->buf->std.cmd_select,
+				priv->buf->std.input[0]);
+			ret = -EFAULT;
+			goto fail_smbios_cmd;
+		}
+		ret = run_smbios_call(priv->wdev);
+		if (ret)
+			goto fail_smbios_cmd;
+		memcpy(arg, priv->buf, priv->req_buf_size);
+fail_smbios_cmd:
+		mutex_unlock(&call_mutex);
+		break;
+	default:
+		ret = -ENOIOCTLCMD;
+	}
+	return ret;
+}
+
 static int dell_smbios_wmi_probe(struct wmi_device *wdev)
 {
 	struct wmi_smbios_priv *priv;
@@ -135,6 +160,12 @@ static int dell_smbios_wmi_probe(struct wmi_device *wdev)
 	if (!dell_wmi_get_size(&priv->req_buf_size))
 		return -EPROBE_DEFER;
 
+	/* add in the length object we will use internally with ioctl */
+	priv->req_buf_size += sizeof(u64);
+	ret = set_required_buffer_size(wdev, priv->req_buf_size);
+	if (ret)
+		return ret;
+
 	count = get_order(priv->req_buf_size);
 	priv->buf = (void *)__get_free_pages(GFP_KERNEL, count);
 	if (!priv->buf)
@@ -210,6 +241,7 @@ static struct wmi_driver dell_smbios_wmi_driver = {
 	.probe = dell_smbios_wmi_probe,
 	.remove = dell_smbios_wmi_remove,
 	.id_table = dell_smbios_wmi_id_table,
+	.filter_callback = dell_smbios_wmi_filter,
 };
 
 static int __init init_dell_smbios_wmi(void)

commit 1a258e670434f404a4500b65ba1afea2c2b29bba
Author: Mario Limonciello <mario.limonciello@dell.com>
Date:   Wed Nov 1 14:25:32 2017 -0500

    platform/x86: dell-smbios-wmi: Add new WMI dispatcher driver
    
    The dell-smbios stack only currently uses an SMI interface which grants
    direct access to physical memory to the firmware SMM methods via a pointer.
    
    This dispatcher driver adds a WMI-ACPI interface that is detected by WMI
    probe and preferred over the SMI interface in dell-smbios.
    
    Changing this to operate over WMI-ACPI will use an ACPI OperationRegion
    for a buffer of data storage when SMM calls are performed.
    
    This is a safer approach to use in kernel drivers as the SMM will
    only have access to that OperationRegion.
    
    Signed-off-by: Mario Limonciello <mario.limonciello@dell.com>
    Reviewed-by: Edward O'Callaghan <quasisec@google.com>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/dell-smbios-wmi.c b/drivers/platform/x86/dell-smbios-wmi.c
new file mode 100644
index 000000000000..b31f457e58c3
--- /dev/null
+++ b/drivers/platform/x86/dell-smbios-wmi.c
@@ -0,0 +1,236 @@
+/*
+ *  WMI methods for use with dell-smbios
+ *
+ *  Copyright (c) 2017 Dell Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/dmi.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/uaccess.h>
+#include <linux/wmi.h>
+#include "dell-smbios.h"
+#include "dell-wmi-descriptor.h"
+
+static DEFINE_MUTEX(call_mutex);
+static DEFINE_MUTEX(list_mutex);
+static int wmi_supported;
+
+struct misc_bios_flags_structure {
+	struct dmi_header header;
+	u16 flags0;
+} __packed;
+#define FLAG_HAS_ACPI_WMI 0x02
+
+#define DELL_WMI_SMBIOS_GUID "A80593CE-A997-11DA-B012-B622A1EF5492"
+
+struct dell_wmi_extensions {
+	__u32 argattrib;
+	__u32 blength;
+	__u8 data[];
+} __packed;
+
+struct dell_wmi_smbios_buffer {
+	struct calling_interface_buffer std;
+	struct dell_wmi_extensions ext;
+} __packed;
+
+struct wmi_smbios_priv {
+	struct dell_wmi_smbios_buffer *buf;
+	struct list_head list;
+	struct wmi_device *wdev;
+	struct device *child;
+	u32 req_buf_size;
+};
+static LIST_HEAD(wmi_list);
+
+static inline struct wmi_smbios_priv *get_first_smbios_priv(void)
+{
+	return list_first_entry_or_null(&wmi_list,
+					struct wmi_smbios_priv,
+					list);
+}
+
+static int run_smbios_call(struct wmi_device *wdev)
+{
+	struct acpi_buffer output = {ACPI_ALLOCATE_BUFFER, NULL};
+	struct wmi_smbios_priv *priv;
+	struct acpi_buffer input;
+	union acpi_object *obj;
+	acpi_status status;
+
+	priv = dev_get_drvdata(&wdev->dev);
+	input.length = priv->req_buf_size - sizeof(u64);
+	input.pointer = &priv->buf->std;
+
+	dev_dbg(&wdev->dev, "evaluating: %u/%u [%x,%x,%x,%x]\n",
+		priv->buf->std.cmd_class, priv->buf->std.cmd_select,
+		priv->buf->std.input[0], priv->buf->std.input[1],
+		priv->buf->std.input[2], priv->buf->std.input[3]);
+
+	status = wmidev_evaluate_method(wdev, 0, 1, &input, &output);
+	if (ACPI_FAILURE(status))
+		return -EIO;
+	obj = (union acpi_object *)output.pointer;
+	if (obj->type != ACPI_TYPE_BUFFER) {
+		dev_dbg(&wdev->dev, "received type: %d\n", obj->type);
+		if (obj->type == ACPI_TYPE_INTEGER)
+			dev_dbg(&wdev->dev, "SMBIOS call failed: %llu\n",
+				obj->integer.value);
+		return -EIO;
+	}
+	memcpy(&priv->buf->std, obj->buffer.pointer, obj->buffer.length);
+	dev_dbg(&wdev->dev, "result: [%08x,%08x,%08x,%08x]\n",
+		priv->buf->std.output[0], priv->buf->std.output[1],
+		priv->buf->std.output[2], priv->buf->std.output[3]);
+
+	return 0;
+}
+
+int dell_smbios_wmi_call(struct calling_interface_buffer *buffer)
+{
+	struct wmi_smbios_priv *priv;
+	size_t difference;
+	size_t size;
+	int ret;
+
+	mutex_lock(&call_mutex);
+	priv = get_first_smbios_priv();
+	if (!priv)
+		return -ENODEV;
+
+	size = sizeof(struct calling_interface_buffer);
+	difference = priv->req_buf_size - sizeof(u64) - size;
+
+	memset(&priv->buf->ext, 0, difference);
+	memcpy(&priv->buf->std, buffer, size);
+	ret = run_smbios_call(priv->wdev);
+	memcpy(buffer, &priv->buf->std, size);
+	mutex_unlock(&call_mutex);
+
+	return ret;
+}
+
+static int dell_smbios_wmi_probe(struct wmi_device *wdev)
+{
+	struct wmi_smbios_priv *priv;
+	int count;
+	int ret;
+
+	if (!wmi_has_guid(DELL_WMI_DESCRIPTOR_GUID))
+		return -ENODEV;
+
+	priv = devm_kzalloc(&wdev->dev, sizeof(struct wmi_smbios_priv),
+			    GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	/* WMI buffer size will be either 4k or 32k depending on machine */
+	if (!dell_wmi_get_size(&priv->req_buf_size))
+		return -EPROBE_DEFER;
+
+	count = get_order(priv->req_buf_size);
+	priv->buf = (void *)__get_free_pages(GFP_KERNEL, count);
+	if (!priv->buf)
+		return -ENOMEM;
+
+	/* ID is used by dell-smbios to set priority of drivers */
+	wdev->dev.id = 1;
+	ret = dell_smbios_register_device(&wdev->dev, &dell_smbios_wmi_call);
+	if (ret)
+		goto fail_register;
+
+	priv->wdev = wdev;
+	dev_set_drvdata(&wdev->dev, priv);
+	mutex_lock(&list_mutex);
+	list_add_tail(&priv->list, &wmi_list);
+	mutex_unlock(&list_mutex);
+
+	return 0;
+
+fail_register:
+	free_pages((unsigned long)priv->buf, count);
+	return ret;
+}
+
+static int dell_smbios_wmi_remove(struct wmi_device *wdev)
+{
+	struct wmi_smbios_priv *priv = dev_get_drvdata(&wdev->dev);
+	int count;
+
+	mutex_lock(&call_mutex);
+	mutex_lock(&list_mutex);
+	list_del(&priv->list);
+	mutex_unlock(&list_mutex);
+	dell_smbios_unregister_device(&wdev->dev);
+	count = get_order(priv->req_buf_size);
+	free_pages((unsigned long)priv->buf, count);
+	mutex_unlock(&call_mutex);
+	return 0;
+}
+
+static const struct wmi_device_id dell_smbios_wmi_id_table[] = {
+	{ .guid_string = DELL_WMI_SMBIOS_GUID },
+	{ },
+};
+
+static void __init parse_b1_table(const struct dmi_header *dm)
+{
+	struct misc_bios_flags_structure *flags =
+	container_of(dm, struct misc_bios_flags_structure, header);
+
+	/* 4 bytes header, 8 bytes flags */
+	if (dm->length < 12)
+		return;
+	if (dm->handle != 0xb100)
+		return;
+	if ((flags->flags0 & FLAG_HAS_ACPI_WMI))
+		wmi_supported = 1;
+}
+
+static void __init find_b1(const struct dmi_header *dm, void *dummy)
+{
+	switch (dm->type) {
+	case 0xb1: /* misc bios flags */
+		parse_b1_table(dm);
+		break;
+	}
+}
+
+static struct wmi_driver dell_smbios_wmi_driver = {
+	.driver = {
+		.name = "dell-smbios",
+	},
+	.probe = dell_smbios_wmi_probe,
+	.remove = dell_smbios_wmi_remove,
+	.id_table = dell_smbios_wmi_id_table,
+};
+
+static int __init init_dell_smbios_wmi(void)
+{
+	dmi_walk(find_b1, NULL);
+
+	if (!wmi_supported)
+		return -ENODEV;
+
+	return wmi_driver_register(&dell_smbios_wmi_driver);
+}
+
+static void __exit exit_dell_smbios_wmi(void)
+{
+	wmi_driver_unregister(&dell_smbios_wmi_driver);
+}
+
+module_init(init_dell_smbios_wmi);
+module_exit(exit_dell_smbios_wmi);
+
+MODULE_ALIAS("wmi:" DELL_WMI_SMBIOS_GUID);
+MODULE_AUTHOR("Mario Limonciello <mario.limonciello@dell.com>");
+MODULE_DESCRIPTION("Dell SMBIOS communications over WMI");
+MODULE_LICENSE("GPL");
