commit cfae58ed681c5fe0185db843013ecc71cd265ebf
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri May 15 20:39:16 2020 +0200

    platform/x86: intel-vbtn: Only blacklist SW_TABLET_MODE on the 9 / "Laptop" chasis-type
    
    The HP Stream x360 11-p000nd no longer report SW_TABLET_MODE state / events
    with recent kernels. This model reports a chassis-type of 10 / "Notebook"
    which is not on the recently introduced chassis-type whitelist
    
    Commit de9647efeaa9 ("platform/x86: intel-vbtn: Only activate tablet mode
    switch on 2-in-1's") added a chassis-type whitelist and only listed 31 /
    "Convertible" as being capable of generating valid SW_TABLET_MOD events.
    
    Commit 1fac39fd0316 ("platform/x86: intel-vbtn: Also handle tablet-mode
    switch on "Detachable" and "Portable" chassis-types") extended the
    whitelist with chassis-types 8 / "Portable" and 32 / "Detachable".
    
    And now we need to exten the whitelist again with 10 / "Notebook"...
    
    The issue original fixed by the whitelist is really a ACPI DSDT bug on
    the Dell XPS 9360 where it has a VGBS which reports it is in tablet mode
    even though it is not a 2-in-1 at all, but a regular laptop.
    
    So since this is a workaround for a DSDT issue on that specific model,
    instead of extending the whitelist over and over again, lets switch to
    a blacklist and only blacklist the chassis-type of the model for which
    the chassis-type check was added.
    
    Note this also fixes the current version of the code no longer checking
    if dmi_get_system_info(DMI_CHASSIS_TYPE) returns NULL.
    
    Fixes: 1fac39fd0316 ("platform/x86: intel-vbtn: Also handle tablet-mode switch on "Detachable" and "Portable" chassis-types")
    Cc: Mario Limonciello <mario.limonciello@dell.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Mario Limonciello <Mario.limonciello@dell.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index ef92c1c3adbd..0487b606a274 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -170,21 +170,18 @@ static bool intel_vbtn_has_buttons(acpi_handle handle)
 static bool intel_vbtn_has_switches(acpi_handle handle)
 {
 	const char *chassis_type = dmi_get_system_info(DMI_CHASSIS_TYPE);
-	unsigned long chassis_type_int;
 	unsigned long long vgbs;
 	acpi_status status;
 
-	if (kstrtoul(chassis_type, 10, &chassis_type_int))
-		return false;
-
-	switch (chassis_type_int) {
-	case  8: /* Portable */
-	case 31: /* Convertible */
-	case 32: /* Detachable */
-		break;
-	default:
+	/*
+	 * Some normal laptops have a VGBS method despite being non-convertible
+	 * and their VGBS method always returns 0, causing detect_tablet_mode()
+	 * to report SW_TABLET_MODE=1 to userspace, which causes issues.
+	 * These laptops have a DMI chassis_type of 9 ("Laptop"), do not report
+	 * switches on any devices with a DMI chassis_type of 9.
+	 */
+	if (chassis_type && strcmp(chassis_type, "9") == 0)
 		return false;
-	}
 
 	status = acpi_evaluate_integer(handle, "VGBS", NULL, &vgbs);
 	return ACPI_SUCCESS(status);

commit dd950f16b10df55c16c98106726978b236c8be54
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun May 10 14:20:47 2020 +0200

    platform/x86: intel-vbtn: Detect switch position before registering the input-device
    
    Setting the initial state of input-device switches must be done before
    registering the input-device.
    
    Otherwise the initial state will get send out as an event as soon
    as input_sync() gets called.
    
    E.g. when undocking a tablet using intel-vbtn to report SW_TABLET_MODE
    and SW_DOCK before this commit we would get (evemu-record output):
    
    E: 0.000001 0005 0005 0001      # EV_SW / SW_DOCK              1
    E: 0.000001 0000 0000 0000      # ------------ SYN_REPORT (0) ---------- +0ms
    E: 0.000109 0005 0005 0000      # EV_SW / SW_DOCK              0
    E: 0.000109 0000 0000 0000      # ------------ SYN_REPORT (0) ---------- +0ms
    E: 0.000133 0005 0001 0001      # EV_SW / SW_TABLET_MODE       1
    E: 0.000133 0000 0000 0000      # ------------ SYN_REPORT (0) ---------- +0ms
    
    The first SW_DOCK=1 report is spurious, setting the initial switch
    state before registering the input-device fixes this.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index 29984154f8e4..ef92c1c3adbd 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -111,6 +111,9 @@ static int intel_vbtn_input_setup(struct platform_device *device)
 	priv->input_dev->name = "Intel Virtual Button driver";
 	priv->input_dev->id.bustype = BUS_HOST;
 
+	if (priv->has_switches)
+		detect_tablet_mode(device);
+
 	return input_register_device(priv->input_dev);
 }
 
@@ -217,9 +220,6 @@ static int intel_vbtn_probe(struct platform_device *device)
 		return err;
 	}
 
-	if (priv->has_switches)
-		detect_tablet_mode(device);
-
 	status = acpi_install_notify_handler(handle,
 					     ACPI_DEVICE_NOTIFY,
 					     notify_handler,

commit f913c3086c5078f67c1a6833f6fd1593d8a174fe
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun May 10 14:20:46 2020 +0200

    platform/x86: intel-vbtn: Move detect_tablet_mode() to higher in the file
    
    This is a preparation patch for calling detect_tablet_mode() from
    intel_vbtn_input_setup() without needing a forward declaration.
    
    Note this commit makes no functional changes, the moved block of code
    is completely unchanged.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index 4efc70b693a7..29984154f8e4 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -60,6 +60,24 @@ struct intel_vbtn_priv {
 	bool wakeup_mode;
 };
 
+static void detect_tablet_mode(struct platform_device *device)
+{
+	struct intel_vbtn_priv *priv = dev_get_drvdata(&device->dev);
+	acpi_handle handle = ACPI_HANDLE(&device->dev);
+	unsigned long long vgbs;
+	acpi_status status;
+	int m;
+
+	status = acpi_evaluate_integer(handle, "VGBS", NULL, &vgbs);
+	if (ACPI_FAILURE(status))
+		return;
+
+	m = !(vgbs & TABLET_MODE_FLAG);
+	input_report_switch(priv->input_dev, SW_TABLET_MODE, m);
+	m = (vgbs & DOCK_MODE_FLAG) ? 1 : 0;
+	input_report_switch(priv->input_dev, SW_DOCK, m);
+}
+
 static int intel_vbtn_input_setup(struct platform_device *device)
 {
 	struct intel_vbtn_priv *priv = dev_get_drvdata(&device->dev);
@@ -138,24 +156,6 @@ static void notify_handler(acpi_handle handle, u32 event, void *context)
 	dev_dbg(&device->dev, "unknown event index 0x%x\n", event);
 }
 
-static void detect_tablet_mode(struct platform_device *device)
-{
-	struct intel_vbtn_priv *priv = dev_get_drvdata(&device->dev);
-	acpi_handle handle = ACPI_HANDLE(&device->dev);
-	unsigned long long vgbs;
-	acpi_status status;
-	int m;
-
-	status = acpi_evaluate_integer(handle, "VGBS", NULL, &vgbs);
-	if (ACPI_FAILURE(status))
-		return;
-
-	m = !(vgbs & TABLET_MODE_FLAG);
-	input_report_switch(priv->input_dev, SW_TABLET_MODE, m);
-	m = (vgbs & DOCK_MODE_FLAG) ? 1 : 0;
-	input_report_switch(priv->input_dev, SW_DOCK, m);
-}
-
 static bool intel_vbtn_has_buttons(acpi_handle handle)
 {
 	acpi_status status;

commit d307f17293226a5bf22cbe67d8b949efe143950e
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat May 2 20:29:51 2020 +0200

    platform/x86: intel-vbtn: Fix probe failure on devices with only switches
    
    On some devices the INT33D6 vbtn device is only used to report
    tablet-mode / docked status (switches) and there are no vbtn managed
    buttons.
    
    On these devices there is no VBDL object.
    
    Move the VBDL check to a intel_vbtn_has_buttons() helper and only exit
    from intel_vbtn_probe() with -ENODEV when there are both no buttons and
    no switches. Also only report the buttons being present to userspace if
    the has_buttons check has succeeded.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index 4921fc15dc6c..4efc70b693a7 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -55,6 +55,7 @@ static const struct key_entry intel_vbtn_switchmap[] = {
 struct intel_vbtn_priv {
 	struct key_entry keymap[KEYMAP_LEN];
 	struct input_dev *input_dev;
+	bool has_buttons;
 	bool has_switches;
 	bool wakeup_mode;
 };
@@ -64,7 +65,7 @@ static int intel_vbtn_input_setup(struct platform_device *device)
 	struct intel_vbtn_priv *priv = dev_get_drvdata(&device->dev);
 	int ret, keymap_len = 0;
 
-	if (true) {
+	if (priv->has_buttons) {
 		memcpy(&priv->keymap[keymap_len], intel_vbtn_keymap,
 		       ARRAY_SIZE(intel_vbtn_keymap) *
 		       sizeof(struct key_entry));
@@ -155,6 +156,14 @@ static void detect_tablet_mode(struct platform_device *device)
 	input_report_switch(priv->input_dev, SW_DOCK, m);
 }
 
+static bool intel_vbtn_has_buttons(acpi_handle handle)
+{
+	acpi_status status;
+
+	status = acpi_evaluate_object(handle, "VBDL", NULL, NULL);
+	return ACPI_SUCCESS(status);
+}
+
 static bool intel_vbtn_has_switches(acpi_handle handle)
 {
 	const char *chassis_type = dmi_get_system_info(DMI_CHASSIS_TYPE);
@@ -181,12 +190,15 @@ static bool intel_vbtn_has_switches(acpi_handle handle)
 static int intel_vbtn_probe(struct platform_device *device)
 {
 	acpi_handle handle = ACPI_HANDLE(&device->dev);
+	bool has_buttons, has_switches;
 	struct intel_vbtn_priv *priv;
 	acpi_status status;
 	int err;
 
-	status = acpi_evaluate_object(handle, "VBDL", NULL, NULL);
-	if (ACPI_FAILURE(status)) {
+	has_buttons = intel_vbtn_has_buttons(handle);
+	has_switches = intel_vbtn_has_switches(handle);
+
+	if (!has_buttons && !has_switches) {
 		dev_warn(&device->dev, "failed to read Intel Virtual Button driver\n");
 		return -ENODEV;
 	}
@@ -196,7 +208,8 @@ static int intel_vbtn_probe(struct platform_device *device)
 		return -ENOMEM;
 	dev_set_drvdata(&device->dev, priv);
 
-	priv->has_switches = intel_vbtn_has_switches(handle);
+	priv->has_buttons = has_buttons;
+	priv->has_switches = has_switches;
 
 	err = intel_vbtn_input_setup(device);
 	if (err) {

commit 1fac39fd0316b19c3e57a182524332332d1643ce
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat May 2 20:29:50 2020 +0200

    platform/x86: intel-vbtn: Also handle tablet-mode switch on "Detachable" and "Portable" chassis-types
    
    Commit de9647efeaa9 ("platform/x86: intel-vbtn: Only activate tablet mode
    switch on 2-in-1's") added a DMI chassis-type check to avoid accidentally
    reporting SW_TABLET_MODE = 1 to userspace on laptops.
    
    Some devices with a detachable keyboard and using the intel-vbnt (INT33D6)
    interface to report if they are in tablet mode (keyboard detached) or not,
    report 32 / "Detachable" as chassis-type, e.g. the HP Pavilion X2 series.
    
    Other devices with a detachable keyboard and using the intel-vbnt (INT33D6)
    interface to report SW_TABLET_MODE, report 8 / "Portable" as chassis-type.
    The Dell Venue 11 Pro 7130 is an example of this.
    
    Extend the DMI chassis-type check to also accept Portables and Detachables
    so that the intel-vbtn driver will report SW_TABLET_MODE on these devices.
    
    Note the chassis-type check was originally added to avoid a false-positive
    tablet-mode report on the Dell XPS 9360 laptop. To the best of my knowledge
    that laptop is using a chassis-type of 9 / "Laptop", so after this commit
    we still ignore the tablet-switch for that chassis-type.
    
    Fixes: de9647efeaa9 ("platform/x86: intel-vbtn: Only activate tablet mode switch on 2-in-1's")
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Mario Limonciello <Mario.limonciello@dell.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index 500fae82e12c..4921fc15dc6c 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -158,12 +158,22 @@ static void detect_tablet_mode(struct platform_device *device)
 static bool intel_vbtn_has_switches(acpi_handle handle)
 {
 	const char *chassis_type = dmi_get_system_info(DMI_CHASSIS_TYPE);
+	unsigned long chassis_type_int;
 	unsigned long long vgbs;
 	acpi_status status;
 
-	if (!(chassis_type && strcmp(chassis_type, "31") == 0))
+	if (kstrtoul(chassis_type, 10, &chassis_type_int))
 		return false;
 
+	switch (chassis_type_int) {
+	case  8: /* Portable */
+	case 31: /* Convertible */
+	case 32: /* Detachable */
+		break;
+	default:
+		return false;
+	}
+
 	status = acpi_evaluate_integer(handle, "VGBS", NULL, &vgbs);
 	return ACPI_SUCCESS(status);
 }

commit 990fbb48067bf8cfa34b7d1e6e1674eaaef2f450
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat May 2 20:29:49 2020 +0200

    platform/x86: intel-vbtn: Do not advertise switches to userspace if they are not there
    
    Commit de9647efeaa9 ("platform/x86: intel-vbtn: Only activate tablet mode
    switch on 2-in-1's") added a DMI chassis-type check to avoid accidentally
    reporting SW_TABLET_MODE = 1 to userspace on laptops (specifically on the
    Dell XPS 9360), to avoid e.g. userspace ignoring touchpad events because
    userspace thought the device was in tablet-mode.
    
    But if we are not getting the initial status of the switch because the
    device does not have a tablet mode, then we really should not advertise
    the presence of a tablet-mode switch to userspace at all, as userspace may
    use the mere presence of this switch for certain heuristics.
    
    Fixes: de9647efeaa9 ("platform/x86: intel-vbtn: Only activate tablet mode switch on 2-in-1's")
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index 634096cef21a..500fae82e12c 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -55,6 +55,7 @@ static const struct key_entry intel_vbtn_switchmap[] = {
 struct intel_vbtn_priv {
 	struct key_entry keymap[KEYMAP_LEN];
 	struct input_dev *input_dev;
+	bool has_switches;
 	bool wakeup_mode;
 };
 
@@ -70,7 +71,7 @@ static int intel_vbtn_input_setup(struct platform_device *device)
 		keymap_len += ARRAY_SIZE(intel_vbtn_keymap);
 	}
 
-	if (true) {
+	if (priv->has_switches) {
 		memcpy(&priv->keymap[keymap_len], intel_vbtn_switchmap,
 		       ARRAY_SIZE(intel_vbtn_switchmap) *
 		       sizeof(struct key_entry));
@@ -138,16 +139,12 @@ static void notify_handler(acpi_handle handle, u32 event, void *context)
 
 static void detect_tablet_mode(struct platform_device *device)
 {
-	const char *chassis_type = dmi_get_system_info(DMI_CHASSIS_TYPE);
 	struct intel_vbtn_priv *priv = dev_get_drvdata(&device->dev);
 	acpi_handle handle = ACPI_HANDLE(&device->dev);
 	unsigned long long vgbs;
 	acpi_status status;
 	int m;
 
-	if (!(chassis_type && strcmp(chassis_type, "31") == 0))
-		return;
-
 	status = acpi_evaluate_integer(handle, "VGBS", NULL, &vgbs);
 	if (ACPI_FAILURE(status))
 		return;
@@ -158,6 +155,19 @@ static void detect_tablet_mode(struct platform_device *device)
 	input_report_switch(priv->input_dev, SW_DOCK, m);
 }
 
+static bool intel_vbtn_has_switches(acpi_handle handle)
+{
+	const char *chassis_type = dmi_get_system_info(DMI_CHASSIS_TYPE);
+	unsigned long long vgbs;
+	acpi_status status;
+
+	if (!(chassis_type && strcmp(chassis_type, "31") == 0))
+		return false;
+
+	status = acpi_evaluate_integer(handle, "VGBS", NULL, &vgbs);
+	return ACPI_SUCCESS(status);
+}
+
 static int intel_vbtn_probe(struct platform_device *device)
 {
 	acpi_handle handle = ACPI_HANDLE(&device->dev);
@@ -176,13 +186,16 @@ static int intel_vbtn_probe(struct platform_device *device)
 		return -ENOMEM;
 	dev_set_drvdata(&device->dev, priv);
 
+	priv->has_switches = intel_vbtn_has_switches(handle);
+
 	err = intel_vbtn_input_setup(device);
 	if (err) {
 		pr_err("Failed to setup Intel Virtual Button\n");
 		return err;
 	}
 
-	detect_tablet_mode(device);
+	if (priv->has_switches)
+		detect_tablet_mode(device);
 
 	status = acpi_install_notify_handler(handle,
 					     ACPI_DEVICE_NOTIFY,

commit f6ba524970c4b73b234bf41ecd6628f5803b1559
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat May 2 20:29:48 2020 +0200

    platform/x86: intel-vbtn: Split keymap into buttons and switches parts
    
    Split the sparse keymap into 2 separate keymaps, a buttons and a switches
    keymap and combine the 2 to a single map again in intel_vbtn_input_setup().
    
    This is a preparation patch for not telling userspace that we have switches
    when we do not have them (and for doing the same for the buttons).
    
    Fixes: de9647efeaa9 ("platform/x86: intel-vbtn: Only activate tablet mode switch on 2-in-1's")
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index 191894d648bb..634096cef21a 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -40,14 +40,20 @@ static const struct key_entry intel_vbtn_keymap[] = {
 	{ KE_IGNORE, 0xC7, { KEY_VOLUMEDOWN } },	/* volume-down key release */
 	{ KE_KEY,    0xC8, { KEY_ROTATE_LOCK_TOGGLE } },	/* rotate-lock key press */
 	{ KE_KEY,    0xC9, { KEY_ROTATE_LOCK_TOGGLE } },	/* rotate-lock key release */
+};
+
+static const struct key_entry intel_vbtn_switchmap[] = {
 	{ KE_SW,     0xCA, { .sw = { SW_DOCK, 1 } } },		/* Docked */
 	{ KE_SW,     0xCB, { .sw = { SW_DOCK, 0 } } },		/* Undocked */
 	{ KE_SW,     0xCC, { .sw = { SW_TABLET_MODE, 1 } } },	/* Tablet */
 	{ KE_SW,     0xCD, { .sw = { SW_TABLET_MODE, 0 } } },	/* Laptop */
-	{ KE_END },
 };
 
+#define KEYMAP_LEN \
+	(ARRAY_SIZE(intel_vbtn_keymap) + ARRAY_SIZE(intel_vbtn_switchmap) + 1)
+
 struct intel_vbtn_priv {
+	struct key_entry keymap[KEYMAP_LEN];
 	struct input_dev *input_dev;
 	bool wakeup_mode;
 };
@@ -55,13 +61,29 @@ struct intel_vbtn_priv {
 static int intel_vbtn_input_setup(struct platform_device *device)
 {
 	struct intel_vbtn_priv *priv = dev_get_drvdata(&device->dev);
-	int ret;
+	int ret, keymap_len = 0;
+
+	if (true) {
+		memcpy(&priv->keymap[keymap_len], intel_vbtn_keymap,
+		       ARRAY_SIZE(intel_vbtn_keymap) *
+		       sizeof(struct key_entry));
+		keymap_len += ARRAY_SIZE(intel_vbtn_keymap);
+	}
+
+	if (true) {
+		memcpy(&priv->keymap[keymap_len], intel_vbtn_switchmap,
+		       ARRAY_SIZE(intel_vbtn_switchmap) *
+		       sizeof(struct key_entry));
+		keymap_len += ARRAY_SIZE(intel_vbtn_switchmap);
+	}
+
+	priv->keymap[keymap_len].type = KE_END;
 
 	priv->input_dev = devm_input_allocate_device(&device->dev);
 	if (!priv->input_dev)
 		return -ENOMEM;
 
-	ret = sparse_keymap_setup(priv->input_dev, intel_vbtn_keymap, NULL);
+	ret = sparse_keymap_setup(priv->input_dev, priv->keymap, NULL);
 	if (ret)
 		return ret;
 

commit 18937875a231d831c309716d6d8fc358f8381881
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat May 2 20:29:47 2020 +0200

    platform/x86: intel-vbtn: Use acpi_evaluate_integer()
    
    Use acpi_evaluate_integer() instead of open-coding it.
    
    This is a preparation patch for adding a intel_vbtn_has_switches()
    helper function.
    
    Fixes: de9647efeaa9 ("platform/x86: intel-vbtn: Only activate tablet mode switch on 2-in-1's")
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index b5880936d785..191894d648bb 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -119,28 +119,21 @@ static void detect_tablet_mode(struct platform_device *device)
 	const char *chassis_type = dmi_get_system_info(DMI_CHASSIS_TYPE);
 	struct intel_vbtn_priv *priv = dev_get_drvdata(&device->dev);
 	acpi_handle handle = ACPI_HANDLE(&device->dev);
-	struct acpi_buffer vgbs_output = { ACPI_ALLOCATE_BUFFER, NULL };
-	union acpi_object *obj;
+	unsigned long long vgbs;
 	acpi_status status;
 	int m;
 
 	if (!(chassis_type && strcmp(chassis_type, "31") == 0))
-		goto out;
+		return;
 
-	status = acpi_evaluate_object(handle, "VGBS", NULL, &vgbs_output);
+	status = acpi_evaluate_integer(handle, "VGBS", NULL, &vgbs);
 	if (ACPI_FAILURE(status))
-		goto out;
-
-	obj = vgbs_output.pointer;
-	if (!(obj && obj->type == ACPI_TYPE_INTEGER))
-		goto out;
+		return;
 
-	m = !(obj->integer.value & TABLET_MODE_FLAG);
+	m = !(vgbs & TABLET_MODE_FLAG);
 	input_report_switch(priv->input_dev, SW_TABLET_MODE, m);
-	m = (obj->integer.value & DOCK_MODE_FLAG) ? 1 : 0;
+	m = (vgbs & DOCK_MODE_FLAG) ? 1 : 0;
 	input_report_switch(priv->input_dev, SW_DOCK, m);
-out:
-	kfree(vgbs_output.pointer);
 }
 
 static int intel_vbtn_probe(struct platform_device *device)

commit 807e92d1bdd0e49771390e546a52dfe05855c13e
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Jan 28 12:26:21 2020 +0200

    platform/x86: intel-vbtn: Move MODULE_DEVICE_TABLE() closer to the table
    
    Move MODULE_DEVICE_TABLE() closer to the table for better maintenance.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index b74932307d69..b5880936d785 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -26,6 +26,7 @@ static const struct acpi_device_id intel_vbtn_ids[] = {
 	{"INT33D6", 0},
 	{"", 0},
 };
+MODULE_DEVICE_TABLE(acpi, intel_vbtn_ids);
 
 /* In theory, these are HID usages. */
 static const struct key_entry intel_vbtn_keymap[] = {
@@ -239,7 +240,6 @@ static struct platform_driver intel_vbtn_pl_driver = {
 	.probe = intel_vbtn_probe,
 	.remove = intel_vbtn_remove,
 };
-MODULE_DEVICE_TABLE(acpi, intel_vbtn_ids);
 
 static acpi_status __init
 check_acpi_dev(acpi_handle handle, u32 lvl, void *context, void **rv)

commit b90ff3554aa3e123bb7e6d08789f6fd92d86ddde
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Aug 21 11:40:19 2019 +0200

    ACPI: PM: s2idle: Always set up EC GPE for system wakeup
    
    Commit 10a08fd65ec1 ("ACPI: PM: Set up EC GPE for system wakeup from
    drivers that need it") assumed that the EC GPE would only need to be
    set up for system wakeup if either the intel-hid or the intel-vbtn
    driver was in use, but that turns out to be incorrect.  In particular,
    on ASUS Zenbook UX430UNR/i7-8550U, if the EC GPE is not enabled while
    suspended, the system cannot be woken up by opening the lid or
    pressing a key, and that machine doesn't use any of the drivers
    mentioned above.
    
    For this reason, always set up the EC GPE for system wakeup from
    suspend-to-idle by setting and clearing its wake mask in the ACPI
    suspend-to-idle callbacks.
    
    Fixes: 10a08fd65ec1 ("ACPI: PM: Set up EC GPE for system wakeup from drivers that need it")
    Reported-by: Kristian Klausen <kristian@klausen.dk>
    Tested-by: Kristian Klausen <kristian@klausen.dk>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index b28e5519337e..b74932307d69 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -205,7 +205,6 @@ static int intel_vbtn_pm_prepare(struct device *dev)
 		struct intel_vbtn_priv *priv = dev_get_drvdata(dev);
 
 		priv->wakeup_mode = true;
-		acpi_ec_set_gpe_wake_mask(ACPI_GPE_ENABLE);
 	}
 	return 0;
 }
@@ -214,10 +213,7 @@ static void intel_vbtn_pm_complete(struct device *dev)
 {
 	struct intel_vbtn_priv *priv = dev_get_drvdata(dev);
 
-	if (priv->wakeup_mode) {
-		acpi_ec_set_gpe_wake_mask(ACPI_GPE_DISABLE);
-		priv->wakeup_mode = false;
-	}
+	priv->wakeup_mode = false;
 }
 
 static int intel_vbtn_pm_resume(struct device *dev)

commit 31eb845718398f9bc9f6fbe1aca675f4e6284392
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Aug 8 11:39:17 2019 +0200

    intel-hid: intel-vbtn: Avoid leaking wakeup_mode set
    
    Both intel-hid and intel-vbtn set a wakeup_mode flag causing them
    to behave in a special way during system suspend and while suspended
    in their "prepare" PM callbacks and clear it in their "resume" PM
    callbacks.  That may cause the wakeup_mode flag to remain set after
    a system suspend failure (if some other driver's "suspend" callback
    returns an error before the "suspend" callback of either intel-hid
    or intel-vbtn is invoked).
    
    After commit 10a08fd65ec1 ("ACPI: PM: Set up EC GPE for system wakeup
    from drivers that need it") that also affects the "wakeup mask" bit
    of the EC GPE, which may not be cleared after a failing system
    suspend.
    
    Fix this issue by adding "complete" PM callbacks to intel-hid and
    intel-vbtn to clear the wakeup_mode flag and the "wakeup mask" bit
    of the EC GPE if they have not been cleared earlier.
    
    Fixes: 10a08fd65ec1 ("ACPI: PM: Set up EC GPE for system wakeup from drivers that need it")
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index ab84e1bbdedd..b28e5519337e 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -210,19 +210,25 @@ static int intel_vbtn_pm_prepare(struct device *dev)
 	return 0;
 }
 
-static int intel_vbtn_pm_resume(struct device *dev)
+static void intel_vbtn_pm_complete(struct device *dev)
 {
-	if (device_may_wakeup(dev)) {
-		struct intel_vbtn_priv *priv = dev_get_drvdata(dev);
+	struct intel_vbtn_priv *priv = dev_get_drvdata(dev);
 
+	if (priv->wakeup_mode) {
 		acpi_ec_set_gpe_wake_mask(ACPI_GPE_DISABLE);
 		priv->wakeup_mode = false;
 	}
+}
+
+static int intel_vbtn_pm_resume(struct device *dev)
+{
+	intel_vbtn_pm_complete(dev);
 	return 0;
 }
 
 static const struct dev_pm_ops intel_vbtn_pm_ops = {
 	.prepare = intel_vbtn_pm_prepare,
+	.complete = intel_vbtn_pm_complete,
 	.resume = intel_vbtn_pm_resume,
 	.restore = intel_vbtn_pm_resume,
 	.thaw = intel_vbtn_pm_resume,

commit 10a08fd65ec1a68ccd86b19ec822ed5f2e50113f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jul 30 11:55:59 2019 +0200

    ACPI: PM: Set up EC GPE for system wakeup from drivers that need it
    
    The EC GPE needs to be set up for system wakeup only if there is a
    driver depending on it, either intel-hid or intel-vbtn, bound to a
    button device that is expected to wake up the system from sleep (such
    as the power button on some Dell systems, like the XPS13 9360).  It
    doesn't need to be set up for waking up the system from sleep in any
    other cases and whether or not it is expected to wake up the system
    from sleep doesn't depend on whether or not the LPS0 device is
    present in the ACPI namespace.
    
    For this reason, rearrange the ACPI suspend-to-idle code to make the
    drivers depending on the EC GPE wakeup take care of setting it up and
    decouple that from the LPS0 device handling.
    
    While at it, make intel-hid and intel-vbtn prepare for system wakeup
    only if they are allowed to wake up the system from sleep by user
    space (via sysfs).
    
    [Note that acpi_ec_mark_gpe_for_wake() and acpi_ec_set_gpe_wake_mask()
     are there to prevent the EC GPE from being disabled by the
     acpi_enable_all_wakeup_gpes() call in acpi_s2idle_prepare(), so on
     systems with either intel-hid or intel-vbtn this change doesn't
     affect any interactions with the hardware or platform firmware.]
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index a0d0cecff55f..ab84e1bbdedd 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -176,6 +176,12 @@ static int intel_vbtn_probe(struct platform_device *device)
 		return -EBUSY;
 
 	device_init_wakeup(&device->dev, true);
+	/*
+	 * In order for system wakeup to work, the EC GPE has to be marked as
+	 * a wakeup one, so do that here (this setting will persist, but it has
+	 * no effect until the wakeup mask is set for the EC GPE).
+	 */
+	acpi_ec_mark_gpe_for_wake();
 	return 0;
 }
 
@@ -195,17 +201,23 @@ static int intel_vbtn_remove(struct platform_device *device)
 
 static int intel_vbtn_pm_prepare(struct device *dev)
 {
-	struct intel_vbtn_priv *priv = dev_get_drvdata(dev);
+	if (device_may_wakeup(dev)) {
+		struct intel_vbtn_priv *priv = dev_get_drvdata(dev);
 
-	priv->wakeup_mode = true;
+		priv->wakeup_mode = true;
+		acpi_ec_set_gpe_wake_mask(ACPI_GPE_ENABLE);
+	}
 	return 0;
 }
 
 static int intel_vbtn_pm_resume(struct device *dev)
 {
-	struct intel_vbtn_priv *priv = dev_get_drvdata(dev);
+	if (device_may_wakeup(dev)) {
+		struct intel_vbtn_priv *priv = dev_get_drvdata(dev);
 
-	priv->wakeup_mode = false;
+		acpi_ec_set_gpe_wake_mask(ACPI_GPE_DISABLE);
+		priv->wakeup_mode = false;
+	}
 	return 0;
 }
 

commit cb1921b17adbe6509538098ac431033378cd7165
Author: Mathew King <mathewk@chromium.org>
Date:   Mon May 20 16:41:24 2019 -0600

    platform/x86: intel-vbtn: Report switch events when event wakes device
    
    When a switch event, such as tablet mode/laptop mode or docked/undocked,
    wakes a device make sure that the value of the swich is reported.
    Without when a device is put in tablet mode from laptop mode when it is
    suspended or vice versa the device will wake up but mode will be
    incorrect.
    
    Tested by suspending a device in laptop mode and putting it in tablet
    mode, the device resumes and is in tablet mode. When suspending the
    device in tablet mode and putting it in laptop mode the device resumes
    and is in laptop mode.
    
    Signed-off-by: Mathew King <mathewk@chromium.org>
    Reviewed-by: Jett Rink <jettrink@chromium.org>
    Reviewed-by: Mario Limonciello <mario.limonciello@dell.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index 06cd7e818ed5..a0d0cecff55f 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -76,12 +76,24 @@ static void notify_handler(acpi_handle handle, u32 event, void *context)
 	struct platform_device *device = context;
 	struct intel_vbtn_priv *priv = dev_get_drvdata(&device->dev);
 	unsigned int val = !(event & 1); /* Even=press, Odd=release */
-	const struct key_entry *ke_rel;
+	const struct key_entry *ke, *ke_rel;
 	bool autorelease;
 
 	if (priv->wakeup_mode) {
-		if (sparse_keymap_entry_from_scancode(priv->input_dev, event)) {
+		ke = sparse_keymap_entry_from_scancode(priv->input_dev, event);
+		if (ke) {
 			pm_wakeup_hard_event(&device->dev);
+
+			/*
+			 * Switch events like tablet mode will wake the device
+			 * and report the new switch position to the input
+			 * subsystem.
+			 */
+			if (ke->type == KE_SW)
+				sparse_keymap_report_event(priv->input_dev,
+							   event,
+							   val,
+							   0);
 			return;
 		}
 		goto out_unknown;

commit 4f5e81a7a68afa7c0a943ab42c61b00a21913db2
Author: Matt Delco <delco@chromium.org>
Date:   Sun Jun 24 17:29:40 2018 -0700

    platform/x86: intel-vbtn: Add support for dock mode detection
    
    The Dell laptop I have has an ACPI that sends 0xCB and 0xCC on entering
    tablet mode.  On exiting tablet mode it sends 0xCA and 0xCD. Based on:
    
    http://www.traby.de/medion/DSDT/dsdt.dsl
    https://gist.github.com/jprvita/5737de3cbb670e80973b7d4e51c38ab6
    https://osdn.net/projects/android-x86/scm/git/kernel/commits/
    7cbe5a330687b851f32dd9f1048a6ce182d0ff44
    
    It appears that 0xCA and 0xCB are about dock mode, which for my
    convertible laptop seems questionably tied to whether I've put
    the laptop in tablet or laptop mode.  I previously proposed no-oping
    0xCA and 0xCB but this revised change attempts to add support for
    detecting dock mode--this detection will essentially be broken for
    my laptop (the main workaround would be for 0xCA and 0xCB to be used
    to provoke a query of the VGBS method that reports the current dock &
    tablet mode [which is accurately reported on my laptop but based on
    the prior workarounds in the driver it apparently can't be trusted
    for all systems]).
    
    Signed-off-by: Matt Delco <delco@chromium.org>
    Cc: Darren Hart <dvhart@infradead.org>
    Cc: Andy Shevchenko <andy@infradead.org>
    Cc: platform-driver-x86@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Reviewed-by: AceLan Kao <acelan.kao@canonical.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index c13780b8dabb..06cd7e818ed5 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -17,6 +17,7 @@
 
 /* When NOT in tablet mode, VGBS returns with the flag 0x40 */
 #define TABLET_MODE_FLAG 0x40
+#define DOCK_MODE_FLAG   0x80
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("AceLan Kao");
@@ -38,6 +39,8 @@ static const struct key_entry intel_vbtn_keymap[] = {
 	{ KE_IGNORE, 0xC7, { KEY_VOLUMEDOWN } },	/* volume-down key release */
 	{ KE_KEY,    0xC8, { KEY_ROTATE_LOCK_TOGGLE } },	/* rotate-lock key press */
 	{ KE_KEY,    0xC9, { KEY_ROTATE_LOCK_TOGGLE } },	/* rotate-lock key release */
+	{ KE_SW,     0xCA, { .sw = { SW_DOCK, 1 } } },		/* Docked */
+	{ KE_SW,     0xCB, { .sw = { SW_DOCK, 0 } } },		/* Undocked */
 	{ KE_SW,     0xCC, { .sw = { SW_TABLET_MODE, 1 } } },	/* Tablet */
 	{ KE_SW,     0xCD, { .sw = { SW_TABLET_MODE, 0 } } },	/* Laptop */
 	{ KE_END },
@@ -121,6 +124,8 @@ static void detect_tablet_mode(struct platform_device *device)
 
 	m = !(obj->integer.value & TABLET_MODE_FLAG);
 	input_report_switch(priv->input_dev, SW_TABLET_MODE, m);
+	m = (obj->integer.value & DOCK_MODE_FLAG) ? 1 : 0;
+	input_report_switch(priv->input_dev, SW_DOCK, m);
 out:
 	kfree(vgbs_output.pointer);
 }

commit b758dbd57650b4157da98b2c734974b409849625
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Feb 28 12:09:56 2018 +0100

    platform/x86: intel-vbtn: Reset wakeup capable flag on removal
    
    The intel-vbtn device will not be able to wake up the system any more
    after removing the notify handler provided by its driver, so make
    its sysfs attributes reflect that.
    
    Fixes: 91f9e850d465 (platform: x86: intel-vbtn: Wake up the system from suspend-to-idle)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index 8173307d6bb1..c13780b8dabb 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -166,6 +166,7 @@ static int intel_vbtn_remove(struct platform_device *device)
 {
 	acpi_handle handle = ACPI_HANDLE(&device->dev);
 
+	device_init_wakeup(&device->dev, false);
 	acpi_remove_notify_handler(handle, ACPI_DEVICE_NOTIFY, notify_handler);
 
 	/*

commit de9647efeaa9f4e8b08c002e09757fd9c55ff901
Author: Mario Limonciello <mario.limonciello@dell.com>
Date:   Thu Feb 22 13:58:42 2018 -0600

    platform/x86: intel-vbtn: Only activate tablet mode switch on 2-in-1's
    
    Some laptops such as the XPS 9360 support the intel-vbtn INT33D6
    interface but don't initialize the bit that intel-vbtn uses to
    represent switching tablet mode.
    
    By running this only on real 2-in-1's it shouldn't cause false
    positives.
    
    Fixes: 30323fb6d5 ("Support tablet mode switch")
    Reported-by: Jeremy Cline <jeremy@jcline.org>
    Signed-off-by: Mario Limonciello <mario.limonciello@dell.com>
    Tested-by: Jeremy Cline <jeremy@jcline.org>
    Tested-by: Darren Hart (VMware) <dvhart@infradead.org>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index b703d6f5b099..8173307d6bb1 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -7,6 +7,7 @@
  */
 
 #include <linux/acpi.h>
+#include <linux/dmi.h>
 #include <linux/input.h>
 #include <linux/input/sparse-keymap.h>
 #include <linux/kernel.h>
@@ -97,9 +98,35 @@ static void notify_handler(acpi_handle handle, u32 event, void *context)
 	dev_dbg(&device->dev, "unknown event index 0x%x\n", event);
 }
 
-static int intel_vbtn_probe(struct platform_device *device)
+static void detect_tablet_mode(struct platform_device *device)
 {
+	const char *chassis_type = dmi_get_system_info(DMI_CHASSIS_TYPE);
+	struct intel_vbtn_priv *priv = dev_get_drvdata(&device->dev);
+	acpi_handle handle = ACPI_HANDLE(&device->dev);
 	struct acpi_buffer vgbs_output = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *obj;
+	acpi_status status;
+	int m;
+
+	if (!(chassis_type && strcmp(chassis_type, "31") == 0))
+		goto out;
+
+	status = acpi_evaluate_object(handle, "VGBS", NULL, &vgbs_output);
+	if (ACPI_FAILURE(status))
+		goto out;
+
+	obj = vgbs_output.pointer;
+	if (!(obj && obj->type == ACPI_TYPE_INTEGER))
+		goto out;
+
+	m = !(obj->integer.value & TABLET_MODE_FLAG);
+	input_report_switch(priv->input_dev, SW_TABLET_MODE, m);
+out:
+	kfree(vgbs_output.pointer);
+}
+
+static int intel_vbtn_probe(struct platform_device *device)
+{
 	acpi_handle handle = ACPI_HANDLE(&device->dev);
 	struct intel_vbtn_priv *priv;
 	acpi_status status;
@@ -122,22 +149,7 @@ static int intel_vbtn_probe(struct platform_device *device)
 		return err;
 	}
 
-	/*
-	 * VGBS being present and returning something means we have
-	 * a tablet mode switch.
-	 */
-	status = acpi_evaluate_object(handle, "VGBS", NULL, &vgbs_output);
-	if (ACPI_SUCCESS(status)) {
-		union acpi_object *obj = vgbs_output.pointer;
-
-		if (obj && obj->type == ACPI_TYPE_INTEGER) {
-			int m = !(obj->integer.value & TABLET_MODE_FLAG);
-
-			input_report_switch(priv->input_dev, SW_TABLET_MODE, m);
-		}
-	}
-
-	kfree(vgbs_output.pointer);
+	detect_tablet_mode(device);
 
 	status = acpi_install_notify_handler(handle,
 					     ACPI_DEVICE_NOTIFY,

commit 00f49ee79777876c37f50aa137e96c52aee24205
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Jan 31 19:54:07 2018 +0200

    platform/x86: intel-vbtn: Replace License by SDPX identifier
    
    Replace License short header by SPDX identifier.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Darren Hart (VMware) <dvhart@infradead.org>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index 69bc39f8d61d..b703d6f5b099 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -1,19 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  *  Intel Virtual Button driver for Windows 8.1+
  *
  *  Copyright (C) 2016 AceLan Kao <acelan.kao@canonical.com>
  *  Copyright (C) 2016 Alex Hung <alex.hung@canonical.com>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
  */
 
 #include <linux/acpi.h>

commit bd1b27e2c8ade686b0e9f6295b5cbe7c27ca01a4
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Jan 31 19:54:06 2018 +0200

    platform/x86: intel-vbtn: Remove redundant inclusions
    
    Some headers are not needed since the driver can be built as module.
    Remove them.
    
    While here, sort headers alphabetically.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Darren Hart (VMware) <dvhart@infradead.org>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index 101c100a3929..69bc39f8d61d 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -16,15 +16,13 @@
  *
  */
 
+#include <linux/acpi.h>
+#include <linux/input.h>
+#include <linux/input/sparse-keymap.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/init.h>
-#include <linux/input.h>
 #include <linux/platform_device.h>
-#include <linux/input/sparse-keymap.h>
-#include <linux/acpi.h>
 #include <linux/suspend.h>
-#include <acpi/acpi_bus.h>
 
 /* When NOT in tablet mode, VGBS returns with the flag 0x40 */
 #define TABLET_MODE_FLAG 0x40

commit 30323fb6d552c41997baca5292bf7001366cab57
Author: Marco Martin <notmart@gmail.com>
Date:   Mon Jan 29 21:27:43 2018 +0100

    platform/x86: intel-vbtn: Support tablet mode switch
    
    On some laptop like the Dell Inspiron 7000 series tablet mode switch
    implemented in Intel ACPI, the events to enter and exit the tablet mode
    are 0xCC and 0xCD
    
    This initializes the tablet/laptop mode at the correct value
    if the system booted in tablet mode (or the intel-vbtn module
    loaded with the device in tablet mode)
    
    Cc: platform-driver-x86@vger.kernel.org
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: "Pali Rohár" <pali.rohar@gmail.com>
    Cc: Darren Hart <dvhart@infradead.org>
    Cc: Mario Limonciello <mario_limonciello@dell.com>
    Cc: Andy Shevchenko <andy@infradead.org>
    Cc: Stefan Brüns<stefan.bruens@rwth-aachen.de>
    Signed-off-by: Marco Martin <notmart@gmail.com>
    Reviewed-by: Mario Limonciello <mario.limonciello@dell.com>
    Acked-by: Pali Rohár <pali.rohar@gmail.com>
    [andy: fixed style of comments, indentation, and massaged commit message]
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index 5fc4315f7382..101c100a3929 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -26,6 +26,9 @@
 #include <linux/suspend.h>
 #include <acpi/acpi_bus.h>
 
+/* When NOT in tablet mode, VGBS returns with the flag 0x40 */
+#define TABLET_MODE_FLAG 0x40
+
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("AceLan Kao");
 
@@ -108,6 +111,7 @@ static void notify_handler(acpi_handle handle, u32 event, void *context)
 
 static int intel_vbtn_probe(struct platform_device *device)
 {
+	struct acpi_buffer vgbs_output = { ACPI_ALLOCATE_BUFFER, NULL };
 	acpi_handle handle = ACPI_HANDLE(&device->dev);
 	struct intel_vbtn_priv *priv;
 	acpi_status status;
@@ -130,6 +134,23 @@ static int intel_vbtn_probe(struct platform_device *device)
 		return err;
 	}
 
+	/*
+	 * VGBS being present and returning something means we have
+	 * a tablet mode switch.
+	 */
+	status = acpi_evaluate_object(handle, "VGBS", NULL, &vgbs_output);
+	if (ACPI_SUCCESS(status)) {
+		union acpi_object *obj = vgbs_output.pointer;
+
+		if (obj && obj->type == ACPI_TYPE_INTEGER) {
+			int m = !(obj->integer.value & TABLET_MODE_FLAG);
+
+			input_report_switch(priv->input_dev, SW_TABLET_MODE, m);
+		}
+	}
+
+	kfree(vgbs_output.pointer);
+
 	status = acpi_install_notify_handler(handle,
 					     ACPI_DEVICE_NOTIFY,
 					     notify_handler,

commit 1c3fdf125ef416227e43fdedf6b5097c41e8c467
Author: Darren Hart (VMware) <dvhart@infradead.org>
Date:   Fri Dec 8 14:57:54 2017 -0800

    platform/x86: intel-vbtn: Simplify autorelease logic
    
    The new notify_handler logic determining if autorelease should be used or
    not is a bit awkward, and can result in more than one call to
    sparse_keymap_report_event for the same event (scancode). The nesting
    and long lines also made it difficult to read.
    
    Simplify the logic by eliminating a level of nesting with a goto and
    always calculate autorelease and val so we can make a single call to
    sparse_keymap_report_event.
    
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>
    Reviewed-by: Stefan Brüns <stefan.bruens@rwth-aachen.de>
    Tested-by: Stefan Brüns <stefan.bruens@rwth-aachen.de>
    Cc: AceLan Kao <acelan.kao@canonical.com>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index 0861efe490d0..5fc4315f7382 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -80,6 +80,7 @@ static void notify_handler(acpi_handle handle, u32 event, void *context)
 {
 	struct platform_device *device = context;
 	struct intel_vbtn_priv *priv = dev_get_drvdata(&device->dev);
+	unsigned int val = !(event & 1); /* Even=press, Odd=release */
 	const struct key_entry *ke_rel;
 	bool autorelease;
 
@@ -88,20 +89,20 @@ static void notify_handler(acpi_handle handle, u32 event, void *context)
 			pm_wakeup_hard_event(&device->dev);
 			return;
 		}
-	} else {
-		/* Use the fact press/release come in even/odd pairs */
-		if ((event & 1) && sparse_keymap_report_event(priv->input_dev,
-							      event, 0, false))
-			return;
+		goto out_unknown;
+	}
 
-		ke_rel = sparse_keymap_entry_from_scancode(priv->input_dev,
-							   event | 1);
-		autorelease = !ke_rel || ke_rel->type == KE_IGNORE;
+	/*
+	 * Even press events are autorelease if there is no corresponding odd
+	 * release event, or if the odd event is KE_IGNORE.
+	 */
+	ke_rel = sparse_keymap_entry_from_scancode(priv->input_dev, event | 1);
+	autorelease = val && (!ke_rel || ke_rel->type == KE_IGNORE);
 
-		if (sparse_keymap_report_event(priv->input_dev, event, 1,
-					       autorelease))
-			return;
-	}
+	if (sparse_keymap_report_event(priv->input_dev, event, val, autorelease))
+		return;
+
+out_unknown:
 	dev_dbg(&device->dev, "unknown event index 0x%x\n", event);
 }
 

commit 9678d0ef77d71a25e2194606238d9cb5b544c0f3
Author: Stefan Brüns <stefan.bruens@rwth-aachen.de>
Date:   Thu Nov 9 23:44:36 2017 +0100

    platform/x86: intel-vbtn: support panel front button
    
    The Lenovo Helix 2 and Dell XPS 12 (9Q33) have an extra button on the
    front showing a 'Windows' logo, both reporting event codes 0xC2/0xC3
    on press/release. On the Dell, both press/release are distinct events
    while on the Helix 2 both events are generated on release.
    
    Tested on XPS 12, for info on the Helix 2 see:
    https://www.spinics.net/lists/ibm-acpi-devel/msg03982.html
    
    Signed-off-by: Stefan Brüns <stefan.bruens@rwth-aachen.de>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index a484bcc6393b..0861efe490d0 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -38,6 +38,8 @@ static const struct acpi_device_id intel_vbtn_ids[] = {
 static const struct key_entry intel_vbtn_keymap[] = {
 	{ KE_KEY, 0xC0, { KEY_POWER } },	/* power key press */
 	{ KE_IGNORE, 0xC1, { KEY_POWER } },	/* power key release */
+	{ KE_KEY, 0xC2, { KEY_LEFTMETA } },		/* 'Windows' key press */
+	{ KE_KEY, 0xC3, { KEY_LEFTMETA } },		/* 'Windows' key release */
 	{ KE_KEY, 0xC4, { KEY_VOLUMEUP } },		/* volume-up key press */
 	{ KE_IGNORE, 0xC5, { KEY_VOLUMEUP } },		/* volume-up key release */
 	{ KE_KEY, 0xC6, { KEY_VOLUMEDOWN } },		/* volume-down key press */

commit 3d5d95d316b6fb3863a633293beb4e1e69dc7693
Author: Stefan Brüns <stefan.bruens@rwth-aachen.de>
Date:   Thu Nov 9 23:44:35 2017 +0100

    platform/x86: intel-vbtn: support KEY_ROTATE_LOCK_TOGGLE
    
    The Rotate Lock button event is emitted on the XPS 12 (BIOS A8, but not
    on BIOS A2).
    
    Signed-off-by: Stefan Brüns <stefan.bruens@rwth-aachen.de>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index e3f6375af85c..a484bcc6393b 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -42,6 +42,8 @@ static const struct key_entry intel_vbtn_keymap[] = {
 	{ KE_IGNORE, 0xC5, { KEY_VOLUMEUP } },		/* volume-up key release */
 	{ KE_KEY, 0xC6, { KEY_VOLUMEDOWN } },		/* volume-down key press */
 	{ KE_IGNORE, 0xC7, { KEY_VOLUMEDOWN } },	/* volume-down key release */
+	{ KE_KEY,    0xC8, { KEY_ROTATE_LOCK_TOGGLE } },	/* rotate-lock key press */
+	{ KE_KEY,    0xC9, { KEY_ROTATE_LOCK_TOGGLE } },	/* rotate-lock key release */
 	{ KE_SW,     0xCC, { .sw = { SW_TABLET_MODE, 1 } } },	/* Tablet */
 	{ KE_SW,     0xCD, { .sw = { SW_TABLET_MODE, 0 } } },	/* Laptop */
 	{ KE_END },

commit 95f38fd46cc5e45a0d5224f486e805d17ea3d93f
Author: Stefan Brüns <stefan.bruens@rwth-aachen.de>
Date:   Thu Nov 9 23:44:33 2017 +0100

    platform/x86: intel-vbtn: Support separate press/release events
    
    Currently all key events use autorelease, but this forbids use as a
    modifier key.
    
    As all event codes come in even/odd pairs, we can lookup the key type
    (KE_KEY/KE_IGNORE) for the key up event corresponding to the currently
    handled key down event. If the key up is ignored, we keep setting the
    autorelease flag for the key down.
    
    Signed-off-by: Stefan Brüns <stefan.bruens@rwth-aachen.de>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index ae55be91a64b..e3f6375af85c 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -76,14 +76,27 @@ static void notify_handler(acpi_handle handle, u32 event, void *context)
 {
 	struct platform_device *device = context;
 	struct intel_vbtn_priv *priv = dev_get_drvdata(&device->dev);
+	const struct key_entry *ke_rel;
+	bool autorelease;
 
 	if (priv->wakeup_mode) {
 		if (sparse_keymap_entry_from_scancode(priv->input_dev, event)) {
 			pm_wakeup_hard_event(&device->dev);
 			return;
 		}
-	} else if (sparse_keymap_report_event(priv->input_dev, event, 1, true)) {
-		return;
+	} else {
+		/* Use the fact press/release come in even/odd pairs */
+		if ((event & 1) && sparse_keymap_report_event(priv->input_dev,
+							      event, 0, false))
+			return;
+
+		ke_rel = sparse_keymap_entry_from_scancode(priv->input_dev,
+							   event | 1);
+		autorelease = !ke_rel || ke_rel->type == KE_IGNORE;
+
+		if (sparse_keymap_report_event(priv->input_dev, event, 1,
+					       autorelease))
+			return;
 	}
 	dev_dbg(&device->dev, "unknown event index 0x%x\n", event);
 }

commit 1c828496228deb7a080362bbdf8e70c50bc924b4
Author: Stefan Brüns <stefan.bruens@rwth-aachen.de>
Date:   Thu Nov 9 23:44:32 2017 +0100

    platform/x86: intel-vbtn: support SW_TABLET_MODE
    
    Event code 0xcc is emitted by several convertibles (Dell XPS 12 9Q33 BIOS
    A8, Dell XPS 13 2in1 9365, HP Spectre x360, Lenovo Thinkpad Helix) when
    entering tablet mode, and 0xcd on return to laptop mode.
    
    Signed-off-by: Stefan Brüns <stefan.bruens@rwth-aachen.de>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index 58c5ff36523a..ae55be91a64b 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -42,6 +42,8 @@ static const struct key_entry intel_vbtn_keymap[] = {
 	{ KE_IGNORE, 0xC5, { KEY_VOLUMEUP } },		/* volume-up key release */
 	{ KE_KEY, 0xC6, { KEY_VOLUMEDOWN } },		/* volume-down key press */
 	{ KE_IGNORE, 0xC7, { KEY_VOLUMEDOWN } },	/* volume-down key release */
+	{ KE_SW,     0xCC, { .sw = { SW_TABLET_MODE, 1 } } },	/* Tablet */
+	{ KE_SW,     0xCD, { .sw = { SW_TABLET_MODE, 0 } } },	/* Laptop */
 	{ KE_END },
 };
 

commit a9c37b74fd0242f3c8ce4221bb7a61cb14ccd59b
Author: Alex Hung <alex.hung@canonical.com>
Date:   Thu Jul 20 20:56:48 2017 -0700

    platform/x86: intel-vbtn: reduce unnecessary messages for normal users
    
    Unsupported events is only useful for developers and does not meaningful
    for users. Using dev_dbg makes more sense and reduces noise in kernel
    messages.
    
    Signed-off-by: Alex Hung <alex.hung@canonical.com>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index 480926786cb8..58c5ff36523a 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -83,7 +83,7 @@ static void notify_handler(acpi_handle handle, u32 event, void *context)
 	} else if (sparse_keymap_report_event(priv->input_dev, event, 1, true)) {
 		return;
 	}
-	dev_info(&device->dev, "unknown event index 0x%x\n", event);
+	dev_dbg(&device->dev, "unknown event index 0x%x\n", event);
 }
 
 static int intel_vbtn_probe(struct platform_device *device)

commit c801603e6d0c1bf87930402462d2e4185b1e9264
Author: Mario Limonciello <mario.limonciello@dell.com>
Date:   Fri Aug 4 12:00:06 2017 -0500

    platform/x86: intel-vbtn: match power button on press rather than release
    
    This fixes a problem where the system gets stuck in a loop
    unable to wakeup via power button in s2idle.
    
    The problem happens because:
     - press power button:
       - system emits 0xc0 (power press), event ignored
       - system emits 0xc1 (power release), event processed,
         emited as KEY_POWER
       - set wakeup_mode to true
       - system goes to s2idle
     - press power button
       - system emits 0xc0 (power press), wakeup_mode is true,
         system wakes
       - system emits 0xc1 (power release), event processed,
         emited as KEY_POWER
       - system goes to s2idle again
    
    To avoid this situation, process the presses (which matches what
    intel-hid does too).
    
    Verified on an Dell XPS 9365
    
    Signed-off-by: Mario Limonciello <mario.limonciello@dell.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index 61f106377661..480926786cb8 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -36,8 +36,8 @@ static const struct acpi_device_id intel_vbtn_ids[] = {
 
 /* In theory, these are HID usages. */
 static const struct key_entry intel_vbtn_keymap[] = {
-	{ KE_IGNORE, 0xC0, { KEY_POWER } },	/* power key press */
-	{ KE_KEY, 0xC1, { KEY_POWER } },	/* power key release */
+	{ KE_KEY, 0xC0, { KEY_POWER } },	/* power key press */
+	{ KE_IGNORE, 0xC1, { KEY_POWER } },	/* power key release */
 	{ KE_KEY, 0xC4, { KEY_VOLUMEUP } },		/* volume-up key press */
 	{ KE_IGNORE, 0xC5, { KEY_VOLUMEUP } },		/* volume-up key release */
 	{ KE_KEY, 0xC6, { KEY_VOLUMEDOWN } },		/* volume-down key press */

commit 91f9e850d465147197280cbeaf51d3fb51f61ca0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jun 8 02:15:52 2017 +0200

    platform: x86: intel-vbtn: Wake up the system from suspend-to-idle
    
    Allow the intel-vbtn driver to wake up the system from suspend-to-idle
    by configuring its platform device as a wakeup one by default and
    switching it over to a system wakeup events triggering mode during
    system suspend transitions.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index c2035e121ac2..61f106377661 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -23,6 +23,7 @@
 #include <linux/platform_device.h>
 #include <linux/input/sparse-keymap.h>
 #include <linux/acpi.h>
+#include <linux/suspend.h>
 #include <acpi/acpi_bus.h>
 
 MODULE_LICENSE("GPL");
@@ -46,6 +47,7 @@ static const struct key_entry intel_vbtn_keymap[] = {
 
 struct intel_vbtn_priv {
 	struct input_dev *input_dev;
+	bool wakeup_mode;
 };
 
 static int intel_vbtn_input_setup(struct platform_device *device)
@@ -73,9 +75,15 @@ static void notify_handler(acpi_handle handle, u32 event, void *context)
 	struct platform_device *device = context;
 	struct intel_vbtn_priv *priv = dev_get_drvdata(&device->dev);
 
-	if (!sparse_keymap_report_event(priv->input_dev, event, 1, true))
-		dev_info(&device->dev, "unknown event index 0x%x\n",
-			 event);
+	if (priv->wakeup_mode) {
+		if (sparse_keymap_entry_from_scancode(priv->input_dev, event)) {
+			pm_wakeup_hard_event(&device->dev);
+			return;
+		}
+	} else if (sparse_keymap_report_event(priv->input_dev, event, 1, true)) {
+		return;
+	}
+	dev_info(&device->dev, "unknown event index 0x%x\n", event);
 }
 
 static int intel_vbtn_probe(struct platform_device *device)
@@ -109,6 +117,7 @@ static int intel_vbtn_probe(struct platform_device *device)
 	if (ACPI_FAILURE(status))
 		return -EBUSY;
 
+	device_init_wakeup(&device->dev, true);
 	return 0;
 }
 
@@ -125,10 +134,34 @@ static int intel_vbtn_remove(struct platform_device *device)
 	return 0;
 }
 
+static int intel_vbtn_pm_prepare(struct device *dev)
+{
+	struct intel_vbtn_priv *priv = dev_get_drvdata(dev);
+
+	priv->wakeup_mode = true;
+	return 0;
+}
+
+static int intel_vbtn_pm_resume(struct device *dev)
+{
+	struct intel_vbtn_priv *priv = dev_get_drvdata(dev);
+
+	priv->wakeup_mode = false;
+	return 0;
+}
+
+static const struct dev_pm_ops intel_vbtn_pm_ops = {
+	.prepare = intel_vbtn_pm_prepare,
+	.resume = intel_vbtn_pm_resume,
+	.restore = intel_vbtn_pm_resume,
+	.thaw = intel_vbtn_pm_resume,
+};
+
 static struct platform_driver intel_vbtn_pl_driver = {
 	.driver = {
 		.name = "intel-vbtn",
 		.acpi_match_table = intel_vbtn_ids,
+		.pm = &intel_vbtn_pm_ops,
 	},
 	.probe = intel_vbtn_probe,
 	.remove = intel_vbtn_remove,

commit 8d9e29972836b75eb74f533594999500a4c7cc19
Author: Maarten Maathuis <madman2003@gmail.com>
Date:   Mon Apr 24 23:35:21 2017 +0200

    platform/x86: intel-vbtn: add volume up and down
    
    Tested on HP Elite X2 1012 G1.
    Matches event report of Lenovo Helix 2
    (https://www.spinics.net/lists/ibm-acpi-devel/msg03982.html).
    
    Signed-off-by: Maarten Maathuis <madman2003@shikahr.net>
    [andy: fixed indentation of comments and massaged title of the change]
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index 554e82ebe83c..c2035e121ac2 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -37,6 +37,10 @@ static const struct acpi_device_id intel_vbtn_ids[] = {
 static const struct key_entry intel_vbtn_keymap[] = {
 	{ KE_IGNORE, 0xC0, { KEY_POWER } },	/* power key press */
 	{ KE_KEY, 0xC1, { KEY_POWER } },	/* power key release */
+	{ KE_KEY, 0xC4, { KEY_VOLUMEUP } },		/* volume-up key press */
+	{ KE_IGNORE, 0xC5, { KEY_VOLUMEUP } },		/* volume-up key release */
+	{ KE_KEY, 0xC6, { KEY_VOLUMEDOWN } },		/* volume-down key press */
+	{ KE_IGNORE, 0xC7, { KEY_VOLUMEDOWN } },	/* volume-down key release */
 	{ KE_END },
 };
 

commit e18bf801f1501e15830db5fa927a6e2832d49d7b
Merge: 8600b697cd47 cb2bf25145e0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 15 13:31:25 2016 -0800

    Merge tag 'platform-drivers-x86-v4.10-1' of git://git.infradead.org/users/dvhart/linux-platform-drivers-x86
    
    Pull x86 platform driver updates from Darrent Hart:
     "Introduce one new driver for Mellanox platforms. Add support for
      various new models to existing drivers via quirks, hotkeys, etc.
      Significant updates to intel_pmc_core in support of Kabylake and
      Sunrise Point PCH power management debug. Some cleanup and refactoring
      across various drivers.
    
      Detailed summary:
    
      dell-laptop:
       - Use brightness_set_blocking for kbd_led_level_set
    
      thinkpad_acpi:
       - Initialize local in_tablet_mode and type
       - Fix old style declaration GCC warning
       - Adding new hotkey ID for Lenovo thinkpad
       - Add support for X1 Yoga (2016) Tablet Mode
       - Move tablet detection into separate function
    
      asus-nb-wmi:
       - Add X45U quirk
       - Make use of dmi->ident
    
      asus-wmi:
       - Set specified XUSB2PR value for X550LB
    
      intel_mid_thermal:
       - Fix suspend handlers unused warning
    
      intel-vbtn:
       - Switch to use devm_input_allocate_device
    
      dell-wmi:
       - Add events created by Dell Rugged 2-in-1s
       - Adjust wifi catcher to emit KEY_WLAN
    
      intel_pmc_core:
       - Add KBL CPUID support
       - Add LTR IGNORE debug feature
       - Add MPHY PLL clock gating status
       - ModPhy core lanes pg status
       - Add PCH IP Power Gating Status
       - Fix PWRMBASE mask and mmio reg len
    
      acer-wmi:
       - Only supports AMW0_GUID1 on acer family
    
      mlx-platform:
       - Introduce support for Mellanox hotplug driver
    
      platform/x86:
       - Use ACPI_FAILURE at appropriate places"
    
    * tag 'platform-drivers-x86-v4.10-1' of git://git.infradead.org/users/dvhart/linux-platform-drivers-x86: (22 commits)
      platform/x86: thinkpad_acpi: Initialize local in_tablet_mode and type
      platform/x86: dell-laptop: Use brightness_set_blocking for kbd_led_level_set
      platform/x86: thinkpad_acpi: Fix old style declaration GCC warning
      platform/x86: thinkpad_acpi: Adding new hotkey ID for Lenovo thinkpad
      platform/x86: thinkpad_acpi: Add support for X1 Yoga (2016) Tablet Mode
      platform/x86: thinkpad_acpi: Move tablet detection into separate function
      platform/x86: asus-nb-wmi.c: Add X45U quirk
      platform/x86: asus-nb-wmi: Make use of dmi->ident
      platform/x86: asus-wmi: Set specified XUSB2PR value for X550LB
      platform/x86: intel_mid_thermal: Fix suspend handlers unused warning
      platform/x86: intel-vbtn: Switch to use devm_input_allocate_device
      platform/x86: Use ACPI_FAILURE at appropriate places
      platform/x86: dell-wmi: Add events created by Dell Rugged 2-in-1s
      platform/x86: dell-wmi: Adjust wifi catcher to emit KEY_WLAN
      platform/x86: intel_pmc_core: Add KBL CPUID support
      platform/x86: intel_pmc_core: Add LTR IGNORE debug feature
      platform/x86: intel_pmc_core: Add MPHY PLL clock gating status
      platform/x86: intel_pmc_core: ModPhy core lanes pg status
      platform/x86: intel_pmc_core: Add PCH IP Power Gating Status
      platform/x86: intel_pmc_core: Fix PWRMBASE mask and mmio reg len
      ...

commit bb9ad484845d7cc48f0c8db199a91c3a669d908f
Author: Axel Lin <axel.lin@ingics.com>
Date:   Tue Sep 20 17:01:24 2016 +0800

    platform/x86: intel-vbtn: Switch to use devm_input_allocate_device
    
    Use devm_input_allocate_device to simplify the error handling code.
    This conversion also makes input_register_device() to be called after
    acpi_remove_notify_handler. This avoid a small window that it's possible
    to call notify_handler after unregister input device.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index f04a394d52d6..bd7230a89f15 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -49,34 +49,19 @@ static int intel_vbtn_input_setup(struct platform_device *device)
 	struct intel_vbtn_priv *priv = dev_get_drvdata(&device->dev);
 	int ret;
 
-	priv->input_dev = input_allocate_device();
+	priv->input_dev = devm_input_allocate_device(&device->dev);
 	if (!priv->input_dev)
 		return -ENOMEM;
 
 	ret = sparse_keymap_setup(priv->input_dev, intel_vbtn_keymap, NULL);
 	if (ret)
-		goto err_free_device;
+		return ret;
 
 	priv->input_dev->dev.parent = &device->dev;
 	priv->input_dev->name = "Intel Virtual Button driver";
 	priv->input_dev->id.bustype = BUS_HOST;
 
-	ret = input_register_device(priv->input_dev);
-	if (ret)
-		goto err_free_device;
-
-	return 0;
-
-err_free_device:
-	input_free_device(priv->input_dev);
-	return ret;
-}
-
-static void intel_vbtn_input_destroy(struct platform_device *device)
-{
-	struct intel_vbtn_priv *priv = dev_get_drvdata(&device->dev);
-
-	input_unregister_device(priv->input_dev);
+	return input_register_device(priv->input_dev);
 }
 
 static void notify_handler(acpi_handle handle, u32 event, void *context)
@@ -117,24 +102,16 @@ static int intel_vbtn_probe(struct platform_device *device)
 					     ACPI_DEVICE_NOTIFY,
 					     notify_handler,
 					     device);
-	if (ACPI_FAILURE(status)) {
-		err = -EBUSY;
-		goto err_remove_input;
-	}
+	if (ACPI_FAILURE(status))
+		return -EBUSY;
 
 	return 0;
-
-err_remove_input:
-	intel_vbtn_input_destroy(device);
-
-	return err;
 }
 
 static int intel_vbtn_remove(struct platform_device *device)
 {
 	acpi_handle handle = ACPI_HANDLE(&device->dev);
 
-	intel_vbtn_input_destroy(device);
 	acpi_remove_notify_handler(handle, ACPI_DEVICE_NOTIFY, notify_handler);
 
 	/*

commit 3526ecadc86cc1d485153255498cde7d0275dd37
Author: Axel Lin <axel.lin@ingics.com>
Date:   Mon Sep 19 09:33:51 2016 +0800

    platform/x86: Use ACPI_FAILURE at appropriate places
    
    Use ACPI_FAILURE() to replace !ACPI_SUCCESS(), this avoid !! operations.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Acked-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index 146d02f8c9bc..f04a394d52d6 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -97,7 +97,7 @@ static int intel_vbtn_probe(struct platform_device *device)
 	int err;
 
 	status = acpi_evaluate_object(handle, "VBDL", NULL, NULL);
-	if (!ACPI_SUCCESS(status)) {
+	if (ACPI_FAILURE(status)) {
 		dev_warn(&device->dev, "failed to read Intel Virtual Button driver\n");
 		return -ENODEV;
 	}

commit 1571875beecd5de9657f73931449bda1b1329b6f
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Thu Nov 3 16:21:26 2016 +0200

    ACPI / platform: Add support for build-in properties
    
    We have a couple of drivers, acpi_apd.c and acpi_lpss.c,
    that need to pass extra build-in properties to the devices
    they create. Previously the drivers added those properties
    to the struct device which is member of the struct
    acpi_device, but that does not work. Those properties need
    to be assigned to the struct device of the platform device
    instead in order for them to become available to the
    drivers.
    
    To fix this, this patch changes acpi_create_platform_device
    function to take struct property_entry pointer as parameter.
    
    Fixes: 20a875e2e86e (serial: 8250_dw: Add quirk for APM X-Gene SoC)
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Tested-by: Yazen Ghannam <yazen.ghannam@amd.com>
    Tested-by: Jérôme de Bretagne <jerome.debretagne@gmail.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
index 146d02f8c9bc..78080763df51 100644
--- a/drivers/platform/x86/intel-vbtn.c
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -164,7 +164,7 @@ check_acpi_dev(acpi_handle handle, u32 lvl, void *context, void **rv)
 		return AE_OK;
 
 	if (acpi_match_device_ids(dev, ids) == 0)
-		if (acpi_create_platform_device(dev))
+		if (acpi_create_platform_device(dev, NULL))
 			dev_info(&dev->dev,
 				 "intel-vbtn: created platform device\n");
 

commit 332e081225fc2a657aa587c42943d5f5a7dae88b
Author: AceLan Kao <acelan.kao@canonical.com>
Date:   Fri Jul 1 09:51:49 2016 +0800

    intel-vbtn: new driver for Intel Virtual Button
    
    This driver supports power button event in Intel Virtual Button currently.
    New Dell XPS 13 requires this driver for the power button.
    
    This driver is copied/modified from intel-hid.c
    Most credit goes to the author of intel-hid.c,
    Alex Hung <alex.hung@canonical.com>
    
    Signed-off-by: AceLan Kao <acelan.kao@canonical.com>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/intel-vbtn.c b/drivers/platform/x86/intel-vbtn.c
new file mode 100644
index 000000000000..146d02f8c9bc
--- /dev/null
+++ b/drivers/platform/x86/intel-vbtn.c
@@ -0,0 +1,188 @@
+/*
+ *  Intel Virtual Button driver for Windows 8.1+
+ *
+ *  Copyright (C) 2016 AceLan Kao <acelan.kao@canonical.com>
+ *  Copyright (C) 2016 Alex Hung <alex.hung@canonical.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+#include <linux/input/sparse-keymap.h>
+#include <linux/acpi.h>
+#include <acpi/acpi_bus.h>
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("AceLan Kao");
+
+static const struct acpi_device_id intel_vbtn_ids[] = {
+	{"INT33D6", 0},
+	{"", 0},
+};
+
+/* In theory, these are HID usages. */
+static const struct key_entry intel_vbtn_keymap[] = {
+	{ KE_IGNORE, 0xC0, { KEY_POWER } },	/* power key press */
+	{ KE_KEY, 0xC1, { KEY_POWER } },	/* power key release */
+	{ KE_END },
+};
+
+struct intel_vbtn_priv {
+	struct input_dev *input_dev;
+};
+
+static int intel_vbtn_input_setup(struct platform_device *device)
+{
+	struct intel_vbtn_priv *priv = dev_get_drvdata(&device->dev);
+	int ret;
+
+	priv->input_dev = input_allocate_device();
+	if (!priv->input_dev)
+		return -ENOMEM;
+
+	ret = sparse_keymap_setup(priv->input_dev, intel_vbtn_keymap, NULL);
+	if (ret)
+		goto err_free_device;
+
+	priv->input_dev->dev.parent = &device->dev;
+	priv->input_dev->name = "Intel Virtual Button driver";
+	priv->input_dev->id.bustype = BUS_HOST;
+
+	ret = input_register_device(priv->input_dev);
+	if (ret)
+		goto err_free_device;
+
+	return 0;
+
+err_free_device:
+	input_free_device(priv->input_dev);
+	return ret;
+}
+
+static void intel_vbtn_input_destroy(struct platform_device *device)
+{
+	struct intel_vbtn_priv *priv = dev_get_drvdata(&device->dev);
+
+	input_unregister_device(priv->input_dev);
+}
+
+static void notify_handler(acpi_handle handle, u32 event, void *context)
+{
+	struct platform_device *device = context;
+	struct intel_vbtn_priv *priv = dev_get_drvdata(&device->dev);
+
+	if (!sparse_keymap_report_event(priv->input_dev, event, 1, true))
+		dev_info(&device->dev, "unknown event index 0x%x\n",
+			 event);
+}
+
+static int intel_vbtn_probe(struct platform_device *device)
+{
+	acpi_handle handle = ACPI_HANDLE(&device->dev);
+	struct intel_vbtn_priv *priv;
+	acpi_status status;
+	int err;
+
+	status = acpi_evaluate_object(handle, "VBDL", NULL, NULL);
+	if (!ACPI_SUCCESS(status)) {
+		dev_warn(&device->dev, "failed to read Intel Virtual Button driver\n");
+		return -ENODEV;
+	}
+
+	priv = devm_kzalloc(&device->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+	dev_set_drvdata(&device->dev, priv);
+
+	err = intel_vbtn_input_setup(device);
+	if (err) {
+		pr_err("Failed to setup Intel Virtual Button\n");
+		return err;
+	}
+
+	status = acpi_install_notify_handler(handle,
+					     ACPI_DEVICE_NOTIFY,
+					     notify_handler,
+					     device);
+	if (ACPI_FAILURE(status)) {
+		err = -EBUSY;
+		goto err_remove_input;
+	}
+
+	return 0;
+
+err_remove_input:
+	intel_vbtn_input_destroy(device);
+
+	return err;
+}
+
+static int intel_vbtn_remove(struct platform_device *device)
+{
+	acpi_handle handle = ACPI_HANDLE(&device->dev);
+
+	intel_vbtn_input_destroy(device);
+	acpi_remove_notify_handler(handle, ACPI_DEVICE_NOTIFY, notify_handler);
+
+	/*
+	 * Even if we failed to shut off the event stream, we can still
+	 * safely detach from the device.
+	 */
+	return 0;
+}
+
+static struct platform_driver intel_vbtn_pl_driver = {
+	.driver = {
+		.name = "intel-vbtn",
+		.acpi_match_table = intel_vbtn_ids,
+	},
+	.probe = intel_vbtn_probe,
+	.remove = intel_vbtn_remove,
+};
+MODULE_DEVICE_TABLE(acpi, intel_vbtn_ids);
+
+static acpi_status __init
+check_acpi_dev(acpi_handle handle, u32 lvl, void *context, void **rv)
+{
+	const struct acpi_device_id *ids = context;
+	struct acpi_device *dev;
+
+	if (acpi_bus_get_device(handle, &dev) != 0)
+		return AE_OK;
+
+	if (acpi_match_device_ids(dev, ids) == 0)
+		if (acpi_create_platform_device(dev))
+			dev_info(&dev->dev,
+				 "intel-vbtn: created platform device\n");
+
+	return AE_OK;
+}
+
+static int __init intel_vbtn_init(void)
+{
+	acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
+			    ACPI_UINT32_MAX, check_acpi_dev, NULL,
+			    (void *)intel_vbtn_ids, NULL);
+
+	return platform_driver_register(&intel_vbtn_pl_driver);
+}
+module_init(intel_vbtn_init);
+
+static void __exit intel_vbtn_exit(void)
+{
+	platform_driver_unregister(&intel_vbtn_pl_driver);
+}
+module_exit(intel_vbtn_exit);
