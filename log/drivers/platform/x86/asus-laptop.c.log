commit 55523abaa85f61ba1414278c81aa9c8674a03e6d
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu May 7 19:37:23 2020 +0300

    platform/x86: asus-laptop: Drop duplicate check for led_classdev_unregister()
    
    led_classdev_unregister() already has the very same check, so,
    drop a duplicate in the driver.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index a666fbc2e73b..0edafe687fa9 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -640,22 +640,15 @@ static enum led_brightness asus_kled_cdev_get(struct led_classdev *led_cdev)
 
 static void asus_led_exit(struct asus_laptop *asus)
 {
-	if (!IS_ERR_OR_NULL(asus->wled.led.dev))
-		led_classdev_unregister(&asus->wled.led);
-	if (!IS_ERR_OR_NULL(asus->bled.led.dev))
-		led_classdev_unregister(&asus->bled.led);
-	if (!IS_ERR_OR_NULL(asus->mled.led.dev))
-		led_classdev_unregister(&asus->mled.led);
-	if (!IS_ERR_OR_NULL(asus->tled.led.dev))
-		led_classdev_unregister(&asus->tled.led);
-	if (!IS_ERR_OR_NULL(asus->pled.led.dev))
-		led_classdev_unregister(&asus->pled.led);
-	if (!IS_ERR_OR_NULL(asus->rled.led.dev))
-		led_classdev_unregister(&asus->rled.led);
-	if (!IS_ERR_OR_NULL(asus->gled.led.dev))
-		led_classdev_unregister(&asus->gled.led);
-	if (!IS_ERR_OR_NULL(asus->kled.led.dev))
-		led_classdev_unregister(&asus->kled.led);
+	led_classdev_unregister(&asus->wled.led);
+	led_classdev_unregister(&asus->bled.led);
+	led_classdev_unregister(&asus->mled.led);
+	led_classdev_unregister(&asus->tled.led);
+	led_classdev_unregister(&asus->pled.led);
+	led_classdev_unregister(&asus->rled.led);
+	led_classdev_unregister(&asus->gled.led);
+	led_classdev_unregister(&asus->kled.led);
+
 	if (asus->led_workqueue) {
 		destroy_workqueue(asus->led_workqueue);
 		asus->led_workqueue = NULL;

commit 67b8ed29e0d472bda2f3afe48d6ff99e127eff0c
Merge: d004701d1cc5 f3e4f3fc8ee9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 1 18:24:25 2019 -0800

    Merge tag 'platform-drivers-x86-v5.5-1' of git://git.infradead.org/linux-platform-drivers-x86
    
    Pull x86 platform driver updates from Andy Shevchenko:
    
     - New bootctl driver for Mellanox BlueField SoC.
    
     - New driver to support System76 laptops.
    
     - Temperature monitoring and fan control on Acer Aspire 7551 is now
       supported.
    
     - Previously the Huawei driver handled only hotkeys. After the
       conversion to WMI it has been expanded to support newer laptop
       models.
    
     - Big refactoring of intel-speed-select tools allows to use it on Intel
       CascadeLake-N systems.
    
     - Touchscreen support for ezpad 6 m4 and Schneider SCT101CTM tablets
    
     - Miscellaneous clean ups and fixes here and there.
    
    * tag 'platform-drivers-x86-v5.5-1' of git://git.infradead.org/linux-platform-drivers-x86: (59 commits)
      platform/x86: hp-wmi: Fix ACPI errors caused by passing 0 as input size
      platform/x86: hp-wmi: Fix ACPI errors caused by too small buffer
      platform/x86: intel_pmc_core: Add Comet Lake (CML) platform support to intel_pmc_core driver
      platform/x86: intel_pmc_core: Fix the SoC naming inconsistency
      platform/mellanox: Fix Kconfig indentation
      tools/power/x86/intel-speed-select: Display TRL buckets for just base config level
      tools/power/x86/intel-speed-select: Ignore missing config level
      platform/x86: touchscreen_dmi: Add info for the ezpad 6 m4 tablet
      tools/power/x86/intel-speed-select: Increment version
      tools/power/x86/intel-speed-select: Use core count for base-freq mask
      tools/power/x86/intel-speed-select: Support platform with limited Intel(R) Speed Select
      tools/power/x86/intel-speed-select: Use Frequency weight for CLOS
      tools/power/x86/intel-speed-select: Make CLOS frequency in MHz
      tools/power/x86/intel-speed-select: Use mailbox for CLOS_PM_QOS_CONFIG
      tools/power/x86/intel-speed-select: Auto mode for CLX
      tools/power/x86/intel-speed-select: Correct CLX-N frequency units
      tools/power/x86/intel-speed-select: Change display of "avx" to "avx2"
      tools/power/x86/intel-speed-select: Extend command set for perf-profile
      Add touchscreen platform data for the Schneider SCT101CTM tablet
      platform/x86: intel_int0002_vgpio: Pass irqchip when adding gpiochip
      ...

commit ab5561095c8f5f28b91629ab2c30839208afa612
Author: Kefeng Wang <wangkefeng.wang@huawei.com>
Date:   Fri Oct 18 11:18:36 2019 +0800

    platform/x86: asus-laptop: Use pr_warn instead of pr_warning
    
    As said in commit f2c2cbcc35d4 ("powerpc: Use pr_warn instead of
    pr_warning"), removing pr_warning so all logging messages use a
    consistent <prefix>_warn style. Let's do it.
    
    Link: http://lkml.kernel.org/r/20191018031850.48498-19-wangkefeng.wang@huawei.com
    To: linux-kernel@vger.kernel.org
    Cc: Corentin Chary <corentin.chary@gmail.com>
    Cc: Darren Hart <dvhart@infradead.org>
    Cc: Andy Shevchenko <andy@infradead.org>
    Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Acked-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 472af7edf0af..ca65e1039f92 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -1148,7 +1148,7 @@ static void asus_als_switch(struct asus_laptop *asus, int value)
 		ret = write_acpi_int(asus->handle, METHOD_ALS_CONTROL, value);
 	}
 	if (ret)
-		pr_warning("Error setting light sensor switch\n");
+		pr_warn("Error setting light sensor switch\n");
 
 	asus->light_switch = value;
 }

commit 2011176d8adbe21320158322df4a4c957474030d
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Oct 1 11:57:00 2019 -0700

    platform/x86: asus-laptop: switch to using polled mode of input devices
    
    We have added polled mode to the normal input devices with the intent of
    retiring input_polled_dev. This converts Asus laptop driver to use the
    polling mode of standard input devices and removes dependency on
    INPUT_POLLDEV.
    
    Also removed no longed needed set_bit(EV_ABS, ...) as
    input_set_abs_oarams() does it for us.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 472af7edf0af..fc6446209854 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -34,7 +34,6 @@
 #include <linux/uaccess.h>
 #include <linux/input.h>
 #include <linux/input/sparse-keymap.h>
-#include <linux/input-polldev.h>
 #include <linux/rfkill.h>
 #include <linux/slab.h>
 #include <linux/dmi.h>
@@ -244,7 +243,7 @@ struct asus_laptop {
 
 	struct input_dev *inputdev;
 	struct key_entry *keymap;
-	struct input_polled_dev *pega_accel_poll;
+	struct input_dev *pega_accel_poll;
 
 	struct asus_led wled;
 	struct asus_led bled;
@@ -446,9 +445,9 @@ static int pega_acc_axis(struct asus_laptop *asus, int curr, char *method)
 	return clamp_val((short)val, -PEGA_ACC_CLAMP, PEGA_ACC_CLAMP);
 }
 
-static void pega_accel_poll(struct input_polled_dev *ipd)
+static void pega_accel_poll(struct input_dev *input)
 {
-	struct device *parent = ipd->input->dev.parent;
+	struct device *parent = input->dev.parent;
 	struct asus_laptop *asus = dev_get_drvdata(parent);
 
 	/* In some cases, the very first call to poll causes a
@@ -457,10 +456,10 @@ static void pega_accel_poll(struct input_polled_dev *ipd)
 	 * device, and perhaps a firmware bug. Fake the first report. */
 	if (!asus->pega_acc_live) {
 		asus->pega_acc_live = true;
-		input_report_abs(ipd->input, ABS_X, 0);
-		input_report_abs(ipd->input, ABS_Y, 0);
-		input_report_abs(ipd->input, ABS_Z, 0);
-		input_sync(ipd->input);
+		input_report_abs(input, ABS_X, 0);
+		input_report_abs(input, ABS_Y, 0);
+		input_report_abs(input, ABS_Z, 0);
+		input_sync(input);
 		return;
 	}
 
@@ -471,25 +470,24 @@ static void pega_accel_poll(struct input_polled_dev *ipd)
 	/* Note transform, convert to "right/up/out" in the native
 	 * landscape orientation (i.e. the vector is the direction of
 	 * "real up" in the device's cartiesian coordinates). */
-	input_report_abs(ipd->input, ABS_X, -asus->pega_acc_x);
-	input_report_abs(ipd->input, ABS_Y, -asus->pega_acc_y);
-	input_report_abs(ipd->input, ABS_Z,  asus->pega_acc_z);
-	input_sync(ipd->input);
+	input_report_abs(input, ABS_X, -asus->pega_acc_x);
+	input_report_abs(input, ABS_Y, -asus->pega_acc_y);
+	input_report_abs(input, ABS_Z,  asus->pega_acc_z);
+	input_sync(input);
 }
 
 static void pega_accel_exit(struct asus_laptop *asus)
 {
 	if (asus->pega_accel_poll) {
-		input_unregister_polled_device(asus->pega_accel_poll);
-		input_free_polled_device(asus->pega_accel_poll);
+		input_unregister_device(asus->pega_accel_poll);
+		asus->pega_accel_poll = NULL;
 	}
-	asus->pega_accel_poll = NULL;
 }
 
 static int pega_accel_init(struct asus_laptop *asus)
 {
 	int err;
-	struct input_polled_dev *ipd;
+	struct input_dev *input;
 
 	if (!asus->is_pega_lucid)
 		return -ENODEV;
@@ -499,37 +497,39 @@ static int pega_accel_init(struct asus_laptop *asus)
 	    acpi_check_handle(asus->handle, METHOD_XLRZ, NULL))
 		return -ENODEV;
 
-	ipd = input_allocate_polled_device();
-	if (!ipd)
+	input = input_allocate_device();
+	if (!input)
 		return -ENOMEM;
 
-	ipd->poll = pega_accel_poll;
-	ipd->poll_interval = 125;
-	ipd->poll_interval_min = 50;
-	ipd->poll_interval_max = 2000;
-
-	ipd->input->name = PEGA_ACCEL_DESC;
-	ipd->input->phys = PEGA_ACCEL_NAME "/input0";
-	ipd->input->dev.parent = &asus->platform_device->dev;
-	ipd->input->id.bustype = BUS_HOST;
+	input->name = PEGA_ACCEL_DESC;
+	input->phys = PEGA_ACCEL_NAME "/input0";
+	input->dev.parent = &asus->platform_device->dev;
+	input->id.bustype = BUS_HOST;
 
-	set_bit(EV_ABS, ipd->input->evbit);
-	input_set_abs_params(ipd->input, ABS_X,
+	input_set_abs_params(input, ABS_X,
 			     -PEGA_ACC_CLAMP, PEGA_ACC_CLAMP, 0, 0);
-	input_set_abs_params(ipd->input, ABS_Y,
+	input_set_abs_params(input, ABS_Y,
 			     -PEGA_ACC_CLAMP, PEGA_ACC_CLAMP, 0, 0);
-	input_set_abs_params(ipd->input, ABS_Z,
+	input_set_abs_params(input, ABS_Z,
 			     -PEGA_ACC_CLAMP, PEGA_ACC_CLAMP, 0, 0);
 
-	err = input_register_polled_device(ipd);
+	err = input_setup_polling(input, pega_accel_poll);
 	if (err)
 		goto exit;
 
-	asus->pega_accel_poll = ipd;
+	input_set_poll_interval(input, 125);
+	input_set_min_poll_interval(input, 50);
+	input_set_max_poll_interval(input, 2000);
+
+	err = input_register_device(input);
+	if (err)
+		goto exit;
+
+	asus->pega_accel_poll = input;
 	return 0;
 
 exit:
-	input_free_polled_device(ipd);
+	input_free_device(input);
 	return err;
 }
 
@@ -1550,8 +1550,7 @@ static void asus_acpi_notify(struct acpi_device *device, u32 event)
 
 	/* Accelerometer "coarse orientation change" event */
 	if (asus->pega_accel_poll && event == 0xEA) {
-		kobject_uevent(&asus->pega_accel_poll->input->dev.kobj,
-			       KOBJ_CHANGE);
+		kobject_uevent(&asus->pega_accel_poll->dev.kobj, KOBJ_CHANGE);
 		return ;
 	}
 

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 700c48ddfa7c..472af7edf0af 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -1,26 +1,11 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  asus-laptop.c - Asus Laptop Support
  *
- *
  *  Copyright (C) 2002-2005 Julien Lerouge, 2003-2006 Karol Kozimor
  *  Copyright (C) 2006-2007 Corentin Chary
  *  Copyright (C) 2011 Wind River Systems
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- *
  *  The development page for this driver is located at
  *  http://sourceforge.net/projects/acpi4asus/
  *

commit d605ca29c35d9ebc0c32c386d95336d5339f61f7
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Thu Apr 19 16:06:10 2018 +0200

    platform/x86: Simplify getting .drvdata
    
    We should get drvdata from struct device directly. Going via
    platform_device is an unneeded step back and forth.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index c4768be24ba9..700c48ddfa7c 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -1593,8 +1593,7 @@ static umode_t asus_sysfs_is_visible(struct kobject *kobj,
 				    int idx)
 {
 	struct device *dev = container_of(kobj, struct device, kobj);
-	struct platform_device *pdev = to_platform_device(dev);
-	struct asus_laptop *asus = platform_get_drvdata(pdev);
+	struct asus_laptop *asus = dev_get_drvdata(dev);
 	acpi_handle handle = asus->handle;
 	bool supported;
 

commit f118b312bdd729b33165c6614e2370f019baad6e
Author: Michał Kępień <kernel@kempniu.pl>
Date:   Thu Mar 9 13:11:38 2017 +0100

    platform/x86: asus-laptop: remove sparse_keymap_free() calls
    
    As sparse_keymap_setup() now uses a managed memory allocation for the
    keymap copy it creates, the latter is freed automatically.  Remove all
    calls to sparse_keymap_free().
    
    Signed-off-by: Michał Kępień <kernel@kempniu.pl>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 28551f5a2e07..c4768be24ba9 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -1516,14 +1516,12 @@ static int asus_input_init(struct asus_laptop *asus)
 	error = input_register_device(input);
 	if (error) {
 		pr_warn("Unable to register input device\n");
-		goto err_free_keymap;
+		goto err_free_dev;
 	}
 
 	asus->inputdev = input;
 	return 0;
 
-err_free_keymap:
-	sparse_keymap_free(input);
 err_free_dev:
 	input_free_device(input);
 	return error;
@@ -1531,10 +1529,8 @@ static int asus_input_init(struct asus_laptop *asus)
 
 static void asus_input_exit(struct asus_laptop *asus)
 {
-	if (asus->inputdev) {
-		sparse_keymap_free(asus->inputdev);
+	if (asus->inputdev)
 		input_unregister_device(asus->inputdev);
-	}
 	asus->inputdev = NULL;
 }
 

commit 6f7e357bf181b5a9da9daffcd40a64ee516a29e4
Author: Giedrius Statkevičius <giedrius.statkevicius@gmail.com>
Date:   Fri Aug 5 23:57:10 2016 +0300

    platform/x86: asus-laptop: get rid of parse_arg()
    
    parse_arg() duplicates the funcionality of kstrtoint() so use the latter
    function instead. There is no funcionality change except that in the
    case of input being too big -ERANGE will be returned instead of -EINVAL
    which is not bad because -ERANGE makes more sense here. The check for
    !count is already done by the sysfs core so no need to duplicate it
    again. Also, add some minor corrections to error handling to accommodate
    the change in return values (parse_arg returned count if everything
    succeeded whereas kstrtoint returns 0 in the same situation)
    
    As a result of this patch asus-laptop.ko size is reduced by almost 1%:
    add/remove: 0/1 grow/shrink: 1/6 up/down: 1/-149 (-148)
    function                                     old     new   delta
    __UNIQUE_ID_vermagic0                         69      70      +1
    ls_switch_store                              133     117     -16
    ledd_store                                   175     159     -16
    display_store                                157     141     -16
    ls_level_store                               193     176     -17
    gps_store                                    200     178     -22
    sysfs_acpi_set.isra                          148     125     -23
    parse_arg.part                                39       -     -39
    Total: Before=19160, After=19012, chg -0.77%
    
    Signed-off-by: Giedrius Statkevičius <giedrius.statkevicius@gmail.com>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 15f131146501..28551f5a2e07 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -932,30 +932,19 @@ static ssize_t infos_show(struct device *dev, struct device_attribute *attr,
 }
 static DEVICE_ATTR_RO(infos);
 
-static int parse_arg(const char *buf, unsigned long count, int *val)
-{
-	if (!count)
-		return 0;
-	if (count > 31)
-		return -EINVAL;
-	if (sscanf(buf, "%i", val) != 1)
-		return -EINVAL;
-	return count;
-}
-
 static ssize_t sysfs_acpi_set(struct asus_laptop *asus,
 			      const char *buf, size_t count,
 			      const char *method)
 {
 	int rv, value;
 
-	rv = parse_arg(buf, count, &value);
-	if (rv <= 0)
+	rv = kstrtoint(buf, 0, &value);
+	if (rv < 0)
 		return rv;
 
 	if (write_acpi_int(asus->handle, method, value))
 		return -ENODEV;
-	return rv;
+	return count;
 }
 
 /*
@@ -975,15 +964,17 @@ static ssize_t ledd_store(struct device *dev, struct device_attribute *attr,
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 	int rv, value;
 
-	rv = parse_arg(buf, count, &value);
-	if (rv > 0) {
-		if (write_acpi_int(asus->handle, METHOD_LEDD, value)) {
-			pr_warn("LED display write failed\n");
-			return -ENODEV;
-		}
-		asus->ledd_status = (u32) value;
+	rv = kstrtoint(buf, 0, &value);
+	if (rv < 0)
+		return rv;
+
+	if (write_acpi_int(asus->handle, METHOD_LEDD, value)) {
+		pr_warn("LED display write failed\n");
+		return -ENODEV;
 	}
-	return rv;
+
+	asus->ledd_status = (u32) value;
+	return count;
 }
 static DEVICE_ATTR_RW(ledd);
 
@@ -1148,10 +1139,12 @@ static ssize_t display_store(struct device *dev, struct device_attribute *attr,
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 	int rv, value;
 
-	rv = parse_arg(buf, count, &value);
-	if (rv > 0)
-		asus_set_display(asus, value);
-	return rv;
+	rv = kstrtoint(buf, 0, &value);
+	if (rv < 0)
+		return rv;
+
+	asus_set_display(asus, value);
+	return count;
 }
 static DEVICE_ATTR_WO(display);
 
@@ -1190,11 +1183,12 @@ static ssize_t ls_switch_store(struct device *dev,
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 	int rv, value;
 
-	rv = parse_arg(buf, count, &value);
-	if (rv > 0)
-		asus_als_switch(asus, value ? 1 : 0);
+	rv = kstrtoint(buf, 0, &value);
+	if (rv < 0)
+		return rv;
 
-	return rv;
+	asus_als_switch(asus, value ? 1 : 0);
+	return count;
 }
 static DEVICE_ATTR_RW(ls_switch);
 
@@ -1219,14 +1213,15 @@ static ssize_t ls_level_store(struct device *dev, struct device_attribute *attr,
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 	int rv, value;
 
-	rv = parse_arg(buf, count, &value);
-	if (rv > 0) {
-		value = (0 < value) ? ((15 < value) ? 15 : value) : 0;
-		/* 0 <= value <= 15 */
-		asus_als_level(asus, value);
-	}
+	rv = kstrtoint(buf, 0, &value);
+	if (rv < 0)
+		return rv;
+
+	value = (0 < value) ? ((15 < value) ? 15 : value) : 0;
+	/* 0 <= value <= 15 */
+	asus_als_level(asus, value);
 
-	return rv;
+	return count;
 }
 static DEVICE_ATTR_RW(ls_level);
 
@@ -1301,14 +1296,14 @@ static ssize_t gps_store(struct device *dev, struct device_attribute *attr,
 	int rv, value;
 	int ret;
 
-	rv = parse_arg(buf, count, &value);
-	if (rv <= 0)
-		return -EINVAL;
+	rv = kstrtoint(buf, 0, &value);
+	if (rv < 0)
+		return rv;
 	ret = asus_gps_switch(asus, !!value);
 	if (ret)
 		return ret;
 	rfkill_set_sw_state(asus->gps.rfkill, !value);
-	return rv;
+	return count;
 }
 static DEVICE_ATTR_RW(gps);
 

commit 19d46ee1aec06de3dc1137c76c29e07bfd96d99d
Author: Giedrius Statkevičius <giedrius.statkevicius@gmail.com>
Date:   Sat Apr 16 03:01:57 2016 +0300

    asus-laptop: correct error handling in sysfs_acpi_set
    
    Properly return rv back to the caller in the case of an error in
    parse_arg. In the process remove a unused variable 'out'.
    
    Signed-off-by: Giedrius Statkevičius <giedrius.statkevicius@gmail.com>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 223090c9d433..15f131146501 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -948,11 +948,10 @@ static ssize_t sysfs_acpi_set(struct asus_laptop *asus,
 			      const char *method)
 {
 	int rv, value;
-	int out = 0;
 
 	rv = parse_arg(buf, count, &value);
-	if (rv > 0)
-		out = value ? 1 : 0;
+	if (rv <= 0)
+		return rv;
 
 	if (write_acpi_int(asus->handle, method, value))
 		return -ENODEV;

commit 2ce6d9932db55cfc09dd6362d6d0d47a361f5f02
Author: Giedrius Statkevičius <giedrius.statkevicius@gmail.com>
Date:   Sat Apr 16 03:01:56 2016 +0300

    asus-laptop: remove redundant initializers
    
    Initializing rv to AE_OK is pointless because later function results are
    assigned to them and only then the variable is used
    
    Signed-off-by: Giedrius Statkevičius <giedrius.statkevicius@gmail.com>
    Acked-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index a4cd78691ac9..223090c9d433 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -771,7 +771,7 @@ static int asus_read_brightness(struct backlight_device *bd)
 {
 	struct asus_laptop *asus = bl_get_data(bd);
 	unsigned long long value;
-	acpi_status rv = AE_OK;
+	acpi_status rv;
 
 	rv = acpi_evaluate_integer(asus->handle, METHOD_BRIGHTNESS_GET,
 				   NULL, &value);
@@ -867,7 +867,7 @@ static ssize_t infos_show(struct device *dev, struct device_attribute *attr,
 	int len = 0;
 	unsigned long long temp;
 	char buf[16];		/* enough for all info */
-	acpi_status rv = AE_OK;
+	acpi_status rv;
 
 	/*
 	 * We use the easy way, we don't care of off and count,
@@ -1267,7 +1267,7 @@ static DEVICE_ATTR_RO(ls_value);
 static int asus_gps_status(struct asus_laptop *asus)
 {
 	unsigned long long status;
-	acpi_status rv = AE_OK;
+	acpi_status rv;
 
 	rv = acpi_evaluate_integer(asus->handle, METHOD_GPS_STATUS,
 				   NULL, &status);

commit 198b618ab118c7d856278a985de1ed0eff77c02f
Author: Giedrius Statkevičius <giedrius.statkevicius@gmail.com>
Date:   Sat Apr 16 03:27:12 2016 +0300

    asus-laptop: correct error handling in asus_read_brightness()
    
    It is possible that acpi_evaluate_integer might fail and value would not be
    set to any value so correct this defect by returning 0 in case of an
    error. This is also the correct thing to return because the backlight
    subsystem will print the old value of brightness in this case.
    
    Signed-off-by: Giedrius Statkevičius <giedrius.statkevicius@gmail.com>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index f2b5d0a8adf0..a4cd78691ac9 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -775,8 +775,10 @@ static int asus_read_brightness(struct backlight_device *bd)
 
 	rv = acpi_evaluate_integer(asus->handle, METHOD_BRIGHTNESS_GET,
 				   NULL, &value);
-	if (ACPI_FAILURE(rv))
+	if (ACPI_FAILURE(rv)) {
 		pr_warn("Error reading brightness\n");
+		return 0;
+	}
 
 	return value;
 }

commit 97ade7697bb104523417d0f9b5e38a8bf55ed7f1
Author: Łukasz Stelmach <stlman@poczta.fm>
Date:   Wed Jul 29 21:31:23 2015 +0200

    asus-laptop: Add key found on Asus F3M
    
    Asus F3M has two keys labeled with an icon of a touchpad. The first,
    reported as 0x6B is next to the power key and the second, reported as
    0x6A, is F9 combined with Fn button. When I was pressing the latter, I was
    getting "Unknown key 6a pressed" message before applying this patch.
    
    Asus F3M does not support WMI so the commit does not update key mappings
    in the asus-nb-wmi.c file.
    
    I have not tested this mapping on any other Asus laptop.
    
    Signed-off-by: Łukasz Stelmach <stlman@poczta.fm>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 58d29c4f2840..f2b5d0a8adf0 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -332,6 +332,7 @@ static const struct key_entry asus_keymap[] = {
 	{KE_KEY, 0x65, { KEY_SWITCHVIDEOMODE } }, /* SDSP LCD + TV */
 	{KE_KEY, 0x66, { KEY_SWITCHVIDEOMODE } }, /* SDSP CRT + TV */
 	{KE_KEY, 0x67, { KEY_SWITCHVIDEOMODE } }, /* SDSP LCD + CRT + TV */
+	{KE_KEY, 0x6A, { KEY_TOUCHPAD_TOGGLE } }, /* Lock Touchpad Fn + F9 */
 	{KE_KEY, 0x6B, { KEY_TOUCHPAD_TOGGLE } }, /* Lock Touchpad */
 	{KE_KEY, 0x6C, { KEY_SLEEP } }, /* Suspend */
 	{KE_KEY, 0x6D, { KEY_SLEEP } }, /* Hibernate */

commit 8b9e6b70a14aa52f9de95e8e0fac543a8ae1a1c3
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Jun 16 16:27:57 2015 +0200

    asus-laptop: Port to new backlight interface selection API
    
    Port the backlight selection logic to the new backlight interface
    selection API.
    
    This commit also removes various obsolete pr_xxx messages related to
    backlight interface selection. These are obsolete because they assume
    there is only a vendor or acpi backlight driver and no other choice.
    Also they are not necessary, if the user wants to know which backlight
    interfaces are registered a simple "ls /sys/class/backlight" suffices.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Darren Hart <dvhart@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 46b274693872..58d29c4f2840 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -54,6 +54,7 @@
 #include <linux/slab.h>
 #include <linux/dmi.h>
 #include <linux/acpi.h>
+#include <acpi/video.h>
 
 #define ASUS_LAPTOP_VERSION	"0.42"
 
@@ -1884,12 +1885,11 @@ static int asus_acpi_add(struct acpi_device *device)
 	if (result)
 		goto fail_platform;
 
-	if (!acpi_video_backlight_support()) {
+	if (acpi_video_get_backlight_type() == acpi_backlight_vendor) {
 		result = asus_backlight_init(asus);
 		if (result)
 			goto fail_backlight;
-	} else
-		pr_info("Backlight controlled by ACPI video driver\n");
+	}
 
 	result = asus_input_init(asus);
 	if (result)

commit ed52ccbce7ffdde51f116e2cc9de00251f1ff7c5
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Jan 23 09:01:10 2015 -0500

    asus-laptop: use DEVICE_ATTR_xx macros
    
    Use DEVICE_ATTR_{RO,WO,RW} macros to simplify sysfs attributes
    declaration.
    
    To declare a "foo" attribute, DEVICE_ATTR_RW() requires foo_show() and
    foo_store(), so rename a few functions to satisfy this requirement.
    
    Also put the macro below each related show/store functions for clarity.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 00f5e8217472..46b274693872 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -856,8 +856,8 @@ static void asus_backlight_exit(struct asus_laptop *asus)
  * than count bytes. We set eof to 1 if we handle those 2 values. We return the
  * number of bytes written in page
  */
-static ssize_t show_infos(struct device *dev,
-			  struct device_attribute *attr, char *page)
+static ssize_t infos_show(struct device *dev, struct device_attribute *attr,
+			  char *page)
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 	int len = 0;
@@ -926,6 +926,7 @@ static ssize_t show_infos(struct device *dev,
 
 	return len;
 }
+static DEVICE_ATTR_RO(infos);
 
 static int parse_arg(const char *buf, unsigned long count, int *val)
 {
@@ -957,15 +958,15 @@ static ssize_t sysfs_acpi_set(struct asus_laptop *asus,
 /*
  * LEDD display
  */
-static ssize_t show_ledd(struct device *dev,
-			 struct device_attribute *attr, char *buf)
+static ssize_t ledd_show(struct device *dev, struct device_attribute *attr,
+			 char *buf)
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 
 	return sprintf(buf, "0x%08x\n", asus->ledd_status);
 }
 
-static ssize_t store_ledd(struct device *dev, struct device_attribute *attr,
+static ssize_t ledd_store(struct device *dev, struct device_attribute *attr,
 			  const char *buf, size_t count)
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
@@ -981,6 +982,7 @@ static ssize_t store_ledd(struct device *dev, struct device_attribute *attr,
 	}
 	return rv;
 }
+static DEVICE_ATTR_RW(ledd);
 
 /*
  * Wireless
@@ -1014,21 +1016,22 @@ static int asus_wlan_set(struct asus_laptop *asus, int status)
 	return 0;
 }
 
-static ssize_t show_wlan(struct device *dev,
-			 struct device_attribute *attr, char *buf)
+static ssize_t wlan_show(struct device *dev, struct device_attribute *attr,
+			 char *buf)
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 
 	return sprintf(buf, "%d\n", asus_wireless_status(asus, WL_RSTS));
 }
 
-static ssize_t store_wlan(struct device *dev, struct device_attribute *attr,
+static ssize_t wlan_store(struct device *dev, struct device_attribute *attr,
 			  const char *buf, size_t count)
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 
 	return sysfs_acpi_set(asus, buf, count, METHOD_WLAN);
 }
+static DEVICE_ATTR_RW(wlan);
 
 /*e
  * Bluetooth
@@ -1042,15 +1045,15 @@ static int asus_bluetooth_set(struct asus_laptop *asus, int status)
 	return 0;
 }
 
-static ssize_t show_bluetooth(struct device *dev,
-			      struct device_attribute *attr, char *buf)
+static ssize_t bluetooth_show(struct device *dev, struct device_attribute *attr,
+			      char *buf)
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 
 	return sprintf(buf, "%d\n", asus_wireless_status(asus, BT_RSTS));
 }
 
-static ssize_t store_bluetooth(struct device *dev,
+static ssize_t bluetooth_store(struct device *dev,
 			       struct device_attribute *attr, const char *buf,
 			       size_t count)
 {
@@ -1058,6 +1061,7 @@ static ssize_t store_bluetooth(struct device *dev,
 
 	return sysfs_acpi_set(asus, buf, count, METHOD_BLUETOOTH);
 }
+static DEVICE_ATTR_RW(bluetooth);
 
 /*
  * Wimax
@@ -1071,22 +1075,22 @@ static int asus_wimax_set(struct asus_laptop *asus, int status)
 	return 0;
 }
 
-static ssize_t show_wimax(struct device *dev,
-			      struct device_attribute *attr, char *buf)
+static ssize_t wimax_show(struct device *dev, struct device_attribute *attr,
+			  char *buf)
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 
 	return sprintf(buf, "%d\n", asus_wireless_status(asus, WM_RSTS));
 }
 
-static ssize_t store_wimax(struct device *dev,
-			       struct device_attribute *attr, const char *buf,
-			       size_t count)
+static ssize_t wimax_store(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 
 	return sysfs_acpi_set(asus, buf, count, METHOD_WIMAX);
 }
+static DEVICE_ATTR_RW(wimax);
 
 /*
  * Wwan
@@ -1100,22 +1104,22 @@ static int asus_wwan_set(struct asus_laptop *asus, int status)
 	return 0;
 }
 
-static ssize_t show_wwan(struct device *dev,
-			      struct device_attribute *attr, char *buf)
+static ssize_t wwan_show(struct device *dev, struct device_attribute *attr,
+			 char *buf)
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 
 	return sprintf(buf, "%d\n", asus_wireless_status(asus, WW_RSTS));
 }
 
-static ssize_t store_wwan(struct device *dev,
-			       struct device_attribute *attr, const char *buf,
-			       size_t count)
+static ssize_t wwan_store(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 
 	return sysfs_acpi_set(asus, buf, count, METHOD_WWAN);
 }
+static DEVICE_ATTR_RW(wwan);
 
 /*
  * Display
@@ -1135,8 +1139,8 @@ static void asus_set_display(struct asus_laptop *asus, int value)
  * displays hooked up simultaneously, so be warned. See the acpi4asus README
  * for more info.
  */
-static ssize_t store_disp(struct device *dev, struct device_attribute *attr,
-			  const char *buf, size_t count)
+static ssize_t display_store(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t count)
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 	int rv, value;
@@ -1146,6 +1150,7 @@ static ssize_t store_disp(struct device *dev, struct device_attribute *attr,
 		asus_set_display(asus, value);
 	return rv;
 }
+static DEVICE_ATTR_WO(display);
 
 /*
  * Light Sens
@@ -1167,16 +1172,17 @@ static void asus_als_switch(struct asus_laptop *asus, int value)
 	asus->light_switch = value;
 }
 
-static ssize_t show_lssw(struct device *dev,
-			 struct device_attribute *attr, char *buf)
+static ssize_t ls_switch_show(struct device *dev, struct device_attribute *attr,
+			      char *buf)
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 
 	return sprintf(buf, "%d\n", asus->light_switch);
 }
 
-static ssize_t store_lssw(struct device *dev, struct device_attribute *attr,
-			  const char *buf, size_t count)
+static ssize_t ls_switch_store(struct device *dev,
+			       struct device_attribute *attr, const char *buf,
+			       size_t count)
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 	int rv, value;
@@ -1187,6 +1193,7 @@ static ssize_t store_lssw(struct device *dev, struct device_attribute *attr,
 
 	return rv;
 }
+static DEVICE_ATTR_RW(ls_switch);
 
 static void asus_als_level(struct asus_laptop *asus, int value)
 {
@@ -1195,16 +1202,16 @@ static void asus_als_level(struct asus_laptop *asus, int value)
 	asus->light_level = value;
 }
 
-static ssize_t show_lslvl(struct device *dev,
-			  struct device_attribute *attr, char *buf)
+static ssize_t ls_level_show(struct device *dev, struct device_attribute *attr,
+			     char *buf)
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 
 	return sprintf(buf, "%d\n", asus->light_level);
 }
 
-static ssize_t store_lslvl(struct device *dev, struct device_attribute *attr,
-			   const char *buf, size_t count)
+static ssize_t ls_level_store(struct device *dev, struct device_attribute *attr,
+			      const char *buf, size_t count)
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 	int rv, value;
@@ -1218,6 +1225,7 @@ static ssize_t store_lslvl(struct device *dev, struct device_attribute *attr,
 
 	return rv;
 }
+static DEVICE_ATTR_RW(ls_level);
 
 static int pega_int_read(struct asus_laptop *asus, int arg, int *result)
 {
@@ -1234,8 +1242,8 @@ static int pega_int_read(struct asus_laptop *asus, int arg, int *result)
 	return err;
 }
 
-static ssize_t show_lsvalue(struct device *dev,
-			    struct device_attribute *attr, char *buf)
+static ssize_t ls_value_show(struct device *dev, struct device_attribute *attr,
+			     char *buf)
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 	int err, hi, lo;
@@ -1247,6 +1255,7 @@ static ssize_t show_lsvalue(struct device *dev,
 		return sprintf(buf, "%d\n", 10 * hi + lo);
 	return err;
 }
+static DEVICE_ATTR_RO(ls_value);
 
 /*
  * GPS
@@ -1274,15 +1283,15 @@ static int asus_gps_switch(struct asus_laptop *asus, int status)
 	return 0;
 }
 
-static ssize_t show_gps(struct device *dev,
-			struct device_attribute *attr, char *buf)
+static ssize_t gps_show(struct device *dev, struct device_attribute *attr,
+			char *buf)
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 
 	return sprintf(buf, "%d\n", asus_gps_status(asus));
 }
 
-static ssize_t store_gps(struct device *dev, struct device_attribute *attr,
+static ssize_t gps_store(struct device *dev, struct device_attribute *attr,
 			 const char *buf, size_t count)
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
@@ -1298,6 +1307,7 @@ static ssize_t store_gps(struct device *dev, struct device_attribute *attr,
 	rfkill_set_sw_state(asus->gps.rfkill, !value);
 	return rv;
 }
+static DEVICE_ATTR_RW(gps);
 
 /*
  * rfkill
@@ -1569,19 +1579,6 @@ static void asus_acpi_notify(struct acpi_device *device, u32 event)
 	asus_input_notify(asus, event);
 }
 
-static DEVICE_ATTR(infos, S_IRUGO, show_infos, NULL);
-static DEVICE_ATTR(wlan, S_IRUGO | S_IWUSR, show_wlan, store_wlan);
-static DEVICE_ATTR(bluetooth, S_IRUGO | S_IWUSR,
-		   show_bluetooth, store_bluetooth);
-static DEVICE_ATTR(wimax, S_IRUGO | S_IWUSR, show_wimax, store_wimax);
-static DEVICE_ATTR(wwan, S_IRUGO | S_IWUSR, show_wwan, store_wwan);
-static DEVICE_ATTR(display, S_IWUSR, NULL, store_disp);
-static DEVICE_ATTR(ledd, S_IRUGO | S_IWUSR, show_ledd, store_ledd);
-static DEVICE_ATTR(ls_value, S_IRUGO, show_lsvalue, NULL);
-static DEVICE_ATTR(ls_level, S_IRUGO | S_IWUSR, show_lslvl, store_lslvl);
-static DEVICE_ATTR(ls_switch, S_IRUGO | S_IWUSR, show_lssw, store_lssw);
-static DEVICE_ATTR(gps, S_IRUGO | S_IWUSR, show_gps, store_gps);
-
 static struct attribute *asus_attributes[] = {
 	&dev_attr_infos.attr,
 	&dev_attr_wlan.attr,

commit 03070e7c9d2dde754e49b189a195a7f5cc1ac7a1
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Sun Jan 18 18:25:24 2015 -0500

    asus-laptop: Fix is_visible return value
    
    With a Lucid platform, asus_sysfs_is_visible() returned a boolean for
    ls_switch and ls_level attributes.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index f71700e0d132..00f5e8217472 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -1616,7 +1616,7 @@ static umode_t asus_sysfs_is_visible(struct kobject *kobj,
 		else
 			goto normal;
 
-		return supported;
+		return supported ? attr->mode : 0;
 	}
 
 normal:

commit 385336e321c41b5174055c0194b60c19a27cc5c5
Merge: ebcffcda311c 200db647112d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 18 20:24:55 2014 -0800

    Merge tag 'platform-drivers-x86-v3.19-1' of git://git.infradead.org/users/dvhart/linux-platform-drivers-x86
    
    Pull x86 platform driver update from Darren Hart:
     - thinkpad-acpi: Switch to software mute, cleanups
     - acerhdf: Bang-bang thermal governor, new models, cleanups
     - dell-laptop: New keyboard backlight support and documentation
     - toshiba_acpi: Keyboard backlight updates, hotkey handling
     - dell-wmi: Keypress filtering, WMI event processing
     - eeepc-laptop: Multiple cleanups, improved error handling, documentation
     - hp_wireless: Inform the user if hp_wireless_input_setup()/add() fails
     - misc: Code cleanups, quirks, various new IDs
    
    * tag 'platform-drivers-x86-v3.19-1' of git://git.infradead.org/users/dvhart/linux-platform-drivers-x86: (33 commits)
      platform/x86/acerhdf: Still depends on THERMAL
      Documentation: Add entry for dell-laptop sysfs interface
      acpi: Remove _OSI(Linux) for ThinkPads
      thinkpad-acpi: Try to use full software mute control
      acerhdf: minor clean up
      acerhdf: added critical trip point
      acerhdf: Use bang-bang thermal governor
      acerhdf: Adding support for new models
      acerhdf: Adding support for "manual mode"
      dell-smo8800: Add more ACPI ids and change description of driver
      platform: x86: dell-laptop: Add support for keyboard backlight
      toshiba_acpi: Add keyboard backlight mode change event
      toshiba_acpi: Change notify funtion to handle more events
      toshiba_acpi: Move hotkey enabling code to its own function
      dell-wmi: Don't report keypresses on keybord illumination change
      dell-wmi: Don't report keypresses for radio state changes
      hp_wireless: Inform the user if hp_wireless_input_setup()/add() fails
      toshiba-acpi: Add missing ID (TOS6207)
      Sony-laptop: Deletion of an unnecessary check before the function call "pci_dev_put"
      platform: x86: Deletion of checks before backlight_device_unregister()
      ...

commit 0098181016dd45c1c417656ba36b87d9101cbb83
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Mon Nov 24 20:30:29 2014 +0100

    platform: x86: Deletion of checks before backlight_device_unregister()
    
    The backlight_device_unregister() function tests whether its argument is NULL
    and then returns immediately. Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    For msi-wmi.c:
    Acked-by: Anisse Astier <anisse@astier.eu>
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 7f4dc6f51f8a..11fac1a3977a 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -843,8 +843,7 @@ static int asus_backlight_init(struct asus_laptop *asus)
 
 static void asus_backlight_exit(struct asus_laptop *asus)
 {
-	if (asus->backlight_device)
-		backlight_device_unregister(asus->backlight_device);
+	backlight_device_unregister(asus->backlight_device);
 	asus->backlight_device = NULL;
 }
 

commit 3493f4144bfd2f11923670b45a8290c8c6499c92
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:27 2014 +0200

    platform: x86: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 7f4dc6f51f8a..05647f1a427e 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -1699,7 +1699,6 @@ static void asus_platform_exit(struct asus_laptop *asus)
 static struct platform_driver platform_driver = {
 	.driver = {
 		.name = ASUS_LAPTOP_FILE,
-		.owner = THIS_MODULE,
 	},
 };
 

commit 98feb7cc61c50fe0fa36eeb994d5db527ca9e103
Merge: 7e22e91102c6 f8a571b2a128
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jan 12 23:44:09 2014 +0100

    Merge branch 'acpi-cleanup'
    
    * acpi-cleanup: (22 commits)
      ACPI / tables: Return proper error codes from acpi_table_parse() and fix comment.
      ACPI / tables: Check if id is NULL in acpi_table_parse()
      ACPI / proc: Include appropriate header file in proc.c
      ACPI / EC: Remove unused functions and add prototype declaration in internal.h
      ACPI / dock: Include appropriate header file in dock.c
      ACPI / PCI: Include appropriate header file in pci_link.c
      ACPI / PCI: Include appropriate header file in pci_slot.c
      ACPI / EC: Mark the function acpi_ec_add_debugfs() as static in ec_sys.c
      ACPI / NVS: Include appropriate header file in nvs.c
      ACPI / OSL: Mark the function acpi_table_checksum() as static
      ACPI / processor: initialize a variable to silence compiler warning
      ACPI / processor: use ACPI_COMPANION() to get ACPI device
      ACPI: correct minor typos
      ACPI / sleep: Drop redundant acpi_disabled check
      ACPI / dock: Drop redundant acpi_disabled check
      ACPI / table: Replace '1' with specific error return values
      ACPI: remove trailing whitespace
      ACPI / IBFT: Fix incorrect <acpi/acpi.h> inclusion in iSCSI boot firmware module
      ACPI / i915: Fix incorrect <acpi/acpi.h> inclusions via <linux/acpi_io.h>
      SFI / ACPI: Fix warnings reported during builds with W=1
      ...
    
    Conflicts:
            drivers/acpi/nvs.c
            drivers/hwmon/asus_atk0110.c

commit 8b48463f89429af408ff695244dc627e1acff4f7
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Dec 3 08:49:16 2013 +0800

    ACPI: Clean up inclusions of ACPI header files
    
    Replace direct inclusions of <acpi/acpi.h>, <acpi/acpi_bus.h> and
    <acpi/acpi_drivers.h>, which are incorrect, with <linux/acpi.h>
    inclusions and remove some inclusions of those files that aren't
    necessary.
    
    First of all, <acpi/acpi.h>, <acpi/acpi_bus.h> and <acpi/acpi_drivers.h>
    should not be included directly from any files that are built for
    CONFIG_ACPI unset, because that generally leads to build warnings about
    undefined symbols in !CONFIG_ACPI builds.  For CONFIG_ACPI set,
    <linux/acpi.h> includes those files and for CONFIG_ACPI unset it
    provides stub ACPI symbols to be used in that case.
    
    Second, there are ordering dependencies between those files that always
    have to be met.  Namely, it is required that <acpi/acpi_bus.h> be included
    prior to <acpi/acpi_drivers.h> so that the acpi_pci_root declarations the
    latter depends on are always there.  And <acpi/acpi.h> which provides
    basic ACPICA type declarations should always be included prior to any other
    ACPI headers in CONFIG_ACPI builds.  That also is taken care of including
    <linux/acpi.h> as appropriate.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> (drivers/pci stuff)
    Acked-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com> (Xen stuff)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 0e9c169b42f8..430b5c3c46b4 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -53,8 +53,7 @@
 #include <linux/rfkill.h>
 #include <linux/slab.h>
 #include <linux/dmi.h>
-#include <acpi/acpi_drivers.h>
-#include <acpi/acpi_bus.h>
+#include <linux/acpi.h>
 
 #define ASUS_LAPTOP_VERSION	"0.42"
 

commit b222cca6002c9396c0ac03b68756f8c565d73561
Author: Joe Perches <joe@perches.com>
Date:   Wed Oct 23 12:14:52 2013 -0700

    platform:x86: Remove OOM message after input_allocate_device
    
    Emitting an OOM message isn't necessary after input_allocate_device
    as there's a generic OOM and a dump_stack already done.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 0e9c169b42f8..594323a926cf 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -1494,10 +1494,9 @@ static int asus_input_init(struct asus_laptop *asus)
 	int error;
 
 	input = input_allocate_device();
-	if (!input) {
-		pr_warn("Unable to allocate input device\n");
+	if (!input)
 		return -ENOMEM;
-	}
+
 	input->name = "Asus Laptop extra buttons";
 	input->phys = ASUS_LAPTOP_FILE "/input0";
 	input->id.bustype = BUS_HOST;

commit 1696d9dc57e062ce5200f6a42a6aaada15b434bb
Author: Thomas Renninger <trenn@suse.de>
Date:   Mon Jul 15 10:15:09 2013 +0200

    ACPI: Remove the old /proc/acpi/event interface
    
    It is quite some time that this one has been deprecated.
    Get rid of it.
    
    Should some really important user be overseen, it may be reverted and
    the userspace program worked on first, but it is time to do something
    to get rid of this old stuff...
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Acked-by: Matthew Garrett <matthew.garrett@nebula.com>
    Acked-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 8e268da6fdbd..0e9c169b42f8 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -1543,7 +1543,6 @@ static void asus_acpi_notify(struct acpi_device *device, u32 event)
 
 	/* TODO Find a better way to handle events count. */
 	count = asus->event_count[event % 128]++;
-	acpi_bus_generate_proc_event(asus->device, event, count);
 	acpi_bus_generate_netlink_event(asus->device->pnp.device_class,
 					dev_name(&asus->device->dev), event,
 					count);

commit 38bdd729ca39e1924a31970e41b13b6ce6ec1755
Author: Libo Chen <clbchenlibo.chen@huawei.com>
Date:   Mon May 20 10:30:24 2013 +0800

    x86: asus-laptop: fix invalid point access
    
    asus->name is null or point to const string,so it is not suitable to kfree it.
    
    Signed-off-by: Libo Chen <libo.chen@huawei.com>
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 0eea09c1c134..8e268da6fdbd 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -1935,7 +1935,6 @@ static int asus_acpi_add(struct acpi_device *device)
 fail_backlight:
 	asus_platform_exit(asus);
 fail_platform:
-	kfree(asus->name);
 	kfree(asus);
 
 	return result;

commit 2740e1bd528771dea9003a1c85f7f8d051c2808d
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Thu Nov 29 09:12:39 2012 +0100

    asus-laptop: always report brightness key events
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index a8792e81d1bc..0eea09c1c134 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -128,10 +128,12 @@ MODULE_PARM_DESC(als_status, "Set the ALS status on boot "
 /*
  * Some events we use, same for all Asus
  */
-#define ATKD_BR_UP	0x10	/* (event & ~ATKD_BR_UP) = brightness level */
-#define ATKD_BR_DOWN	0x20	/* (event & ~ATKD_BR_DOWN) = britghness level */
-#define ATKD_BR_MIN	ATKD_BR_UP
-#define ATKD_BR_MAX	(ATKD_BR_DOWN | 0xF)	/* 0x2f */
+#define ATKD_BRNUP_MIN		0x10
+#define ATKD_BRNUP_MAX		0x1f
+#define ATKD_BRNDOWN_MIN	0x20
+#define ATKD_BRNDOWN_MAX	0x2f
+#define ATKD_BRNDOWN		0x20
+#define ATKD_BRNUP		0x2f
 #define ATKD_LCD_ON	0x33
 #define ATKD_LCD_OFF	0x34
 
@@ -301,6 +303,8 @@ static const struct key_entry asus_keymap[] = {
 	{KE_KEY, 0x17, { KEY_ZOOM } },
 	{KE_KEY, 0x1f, { KEY_BATTERY } },
 	/* End of Lenovo SL Specific keycodes */
+	{KE_KEY, ATKD_BRNDOWN, { KEY_BRIGHTNESSDOWN } },
+	{KE_KEY, ATKD_BRNUP, { KEY_BRIGHTNESSUP } },
 	{KE_KEY, 0x30, { KEY_VOLUMEUP } },
 	{KE_KEY, 0x31, { KEY_VOLUMEDOWN } },
 	{KE_KEY, 0x32, { KEY_MUTE } },
@@ -1544,15 +1548,19 @@ static void asus_acpi_notify(struct acpi_device *device, u32 event)
 					dev_name(&asus->device->dev), event,
 					count);
 
-	/* Brightness events are special */
-	if (event >= ATKD_BR_MIN && event <= ATKD_BR_MAX) {
+	if (event >= ATKD_BRNUP_MIN && event <= ATKD_BRNUP_MAX)
+		event = ATKD_BRNUP;
+	else if (event >= ATKD_BRNDOWN_MIN &&
+		 event <= ATKD_BRNDOWN_MAX)
+		event = ATKD_BRNDOWN;
 
-		/* Ignore them completely if the acpi video driver is used */
+	/* Brightness events are special */
+	if (event == ATKD_BRNDOWN || event == ATKD_BRNUP) {
 		if (asus->backlight_device != NULL) {
 			/* Update the backlight device. */
 			asus_backlight_notify(asus);
+			return ;
 		}
-		return ;
 	}
 
 	/* Accelerometer "coarse orientation change" event */

commit 3da4cd2015630f50d8d80c6ff5089d3daa2306c6
Author: AceLan Kao <acelan.kao@canonical.com>
Date:   Wed Oct 3 11:26:28 2012 +0200

    asus-laptop: add all video switch keys
    
    Fill up all the video switch keys in the map.
    
    Signed-off-by: AceLan Kao <acelan.kao@canonical.com>
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 23c60558bfd3..a8792e81d1bc 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -321,9 +321,13 @@ static const struct key_entry asus_keymap[] = {
 	{KE_KEY, 0x5E, { KEY_WLAN } }, /* WLAN Enable */
 	{KE_KEY, 0x5F, { KEY_WLAN } }, /* WLAN Disable */
 	{KE_KEY, 0x60, { KEY_TOUCHPAD_ON } },
-	{KE_KEY, 0x61, { KEY_SWITCHVIDEOMODE } }, /* LCD Only */
-	{KE_KEY, 0x62, { KEY_SWITCHVIDEOMODE } }, /* CRT Only */
-	{KE_KEY, 0x63, { KEY_SWITCHVIDEOMODE } }, /* LCD + CRT */
+	{KE_KEY, 0x61, { KEY_SWITCHVIDEOMODE } }, /* SDSP LCD only */
+	{KE_KEY, 0x62, { KEY_SWITCHVIDEOMODE } }, /* SDSP CRT only */
+	{KE_KEY, 0x63, { KEY_SWITCHVIDEOMODE } }, /* SDSP LCD + CRT */
+	{KE_KEY, 0x64, { KEY_SWITCHVIDEOMODE } }, /* SDSP TV */
+	{KE_KEY, 0x65, { KEY_SWITCHVIDEOMODE } }, /* SDSP LCD + TV */
+	{KE_KEY, 0x66, { KEY_SWITCHVIDEOMODE } }, /* SDSP CRT + TV */
+	{KE_KEY, 0x67, { KEY_SWITCHVIDEOMODE } }, /* SDSP LCD + CRT + TV */
 	{KE_KEY, 0x6B, { KEY_TOUCHPAD_TOGGLE } }, /* Lock Touchpad */
 	{KE_KEY, 0x6C, { KEY_SLEEP } }, /* Suspend */
 	{KE_KEY, 0x6D, { KEY_SLEEP } }, /* Hibernate */
@@ -333,8 +337,24 @@ static const struct key_entry asus_keymap[] = {
 	{KE_KEY, 0x82, { KEY_CAMERA } },
 	{KE_KEY, 0x88, { KEY_RFKILL  } }, /* Radio Toggle Key */
 	{KE_KEY, 0x8A, { KEY_PROG1 } }, /* Color enhancement mode */
+	{KE_KEY, 0x8C, { KEY_SWITCHVIDEOMODE } }, /* SDSP DVI only */
+	{KE_KEY, 0x8D, { KEY_SWITCHVIDEOMODE } }, /* SDSP LCD + DVI */
+	{KE_KEY, 0x8E, { KEY_SWITCHVIDEOMODE } }, /* SDSP CRT + DVI */
+	{KE_KEY, 0x8F, { KEY_SWITCHVIDEOMODE } }, /* SDSP TV + DVI */
+	{KE_KEY, 0x90, { KEY_SWITCHVIDEOMODE } }, /* SDSP LCD + CRT + DVI */
+	{KE_KEY, 0x91, { KEY_SWITCHVIDEOMODE } }, /* SDSP LCD + TV + DVI */
+	{KE_KEY, 0x92, { KEY_SWITCHVIDEOMODE } }, /* SDSP CRT + TV + DVI */
+	{KE_KEY, 0x93, { KEY_SWITCHVIDEOMODE } }, /* SDSP LCD + CRT + TV + DVI */
 	{KE_KEY, 0x95, { KEY_MEDIA } },
 	{KE_KEY, 0x99, { KEY_PHONE } },
+	{KE_KEY, 0xA0, { KEY_SWITCHVIDEOMODE } }, /* SDSP HDMI only */
+	{KE_KEY, 0xA1, { KEY_SWITCHVIDEOMODE } }, /* SDSP LCD + HDMI */
+	{KE_KEY, 0xA2, { KEY_SWITCHVIDEOMODE } }, /* SDSP CRT + HDMI */
+	{KE_KEY, 0xA3, { KEY_SWITCHVIDEOMODE } }, /* SDSP TV + HDMI */
+	{KE_KEY, 0xA4, { KEY_SWITCHVIDEOMODE } }, /* SDSP LCD + CRT + HDMI */
+	{KE_KEY, 0xA5, { KEY_SWITCHVIDEOMODE } }, /* SDSP LCD + TV + HDMI */
+	{KE_KEY, 0xA6, { KEY_SWITCHVIDEOMODE } }, /* SDSP CRT + TV + HDMI */
+	{KE_KEY, 0xA7, { KEY_SWITCHVIDEOMODE } }, /* SDSP LCD + CRT + TV + HDMI */
 	{KE_KEY, 0xB5, { KEY_CALC } },
 	{KE_KEY, 0xC4, { KEY_KBDILLUMUP } },
 	{KE_KEY, 0xC5, { KEY_KBDILLUMDOWN } },

commit 19d3ab12e84f110009fd94f0c7b7d3008fb3494c
Author: AceLan Kao <acelan.kao@canonical.com>
Date:   Wed Oct 3 11:26:27 2012 +0200

    asus-laptop: correct a touchpad hotkey mapping
    
    0x60 is touchpad enable key, but is misdefined in the keymap.
    
    Signed-off-by: AceLan Kao <acelan.kao@canonical.com>
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 7ed1e9983d3e..23c60558bfd3 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -320,7 +320,7 @@ static const struct key_entry asus_keymap[] = {
 	{KE_KEY, 0x5D, { KEY_WLAN } }, /* WLAN Toggle */
 	{KE_KEY, 0x5E, { KEY_WLAN } }, /* WLAN Enable */
 	{KE_KEY, 0x5F, { KEY_WLAN } }, /* WLAN Disable */
-	{KE_KEY, 0x60, { KEY_SWITCHVIDEOMODE } },
+	{KE_KEY, 0x60, { KEY_TOUCHPAD_ON } },
 	{KE_KEY, 0x61, { KEY_SWITCHVIDEOMODE } }, /* LCD Only */
 	{KE_KEY, 0x62, { KEY_SWITCHVIDEOMODE } }, /* CRT Only */
 	{KE_KEY, 0x63, { KEY_SWITCHVIDEOMODE } }, /* LCD + CRT */

commit a935eaecef2b209ad661dadabb4e32b7c9a9b924
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Wed Oct 3 11:26:26 2012 +0200

    asus-{nb-wmi|laptop}.c: sync keymaps
    
    Maybe this should be shared in another module...
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 062ddd7791cc..7ed1e9983d3e 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -304,40 +304,40 @@ static const struct key_entry asus_keymap[] = {
 	{KE_KEY, 0x30, { KEY_VOLUMEUP } },
 	{KE_KEY, 0x31, { KEY_VOLUMEDOWN } },
 	{KE_KEY, 0x32, { KEY_MUTE } },
-	{KE_KEY, 0x33, { KEY_SWITCHVIDEOMODE } },
-	{KE_KEY, 0x34, { KEY_SWITCHVIDEOMODE } },
+	{KE_KEY, 0x33, { KEY_DISPLAYTOGGLE } }, /* LCD on */
+	{KE_KEY, 0x34, { KEY_DISPLAY_OFF } }, /* LCD off */
 	{KE_KEY, 0x40, { KEY_PREVIOUSSONG } },
 	{KE_KEY, 0x41, { KEY_NEXTSONG } },
-	{KE_KEY, 0x43, { KEY_STOPCD } },
+	{KE_KEY, 0x43, { KEY_STOPCD } }, /* Stop/Eject */
 	{KE_KEY, 0x45, { KEY_PLAYPAUSE } },
-	{KE_KEY, 0x4c, { KEY_MEDIA } },
+	{KE_KEY, 0x4c, { KEY_MEDIA } }, /* WMP Key */
 	{KE_KEY, 0x50, { KEY_EMAIL } },
 	{KE_KEY, 0x51, { KEY_WWW } },
 	{KE_KEY, 0x55, { KEY_CALC } },
 	{KE_IGNORE, 0x57, },  /* Battery mode */
 	{KE_IGNORE, 0x58, },  /* AC mode */
 	{KE_KEY, 0x5C, { KEY_SCREENLOCK } },  /* Screenlock */
-	{KE_KEY, 0x5D, { KEY_WLAN } },
-	{KE_KEY, 0x5E, { KEY_WLAN } },
-	{KE_KEY, 0x5F, { KEY_WLAN } },
+	{KE_KEY, 0x5D, { KEY_WLAN } }, /* WLAN Toggle */
+	{KE_KEY, 0x5E, { KEY_WLAN } }, /* WLAN Enable */
+	{KE_KEY, 0x5F, { KEY_WLAN } }, /* WLAN Disable */
 	{KE_KEY, 0x60, { KEY_SWITCHVIDEOMODE } },
-	{KE_KEY, 0x61, { KEY_SWITCHVIDEOMODE } },
-	{KE_KEY, 0x62, { KEY_SWITCHVIDEOMODE } },
-	{KE_KEY, 0x63, { KEY_SWITCHVIDEOMODE } },
-	{KE_KEY, 0x6B, { KEY_F13 } }, /* Lock Touchpad */
+	{KE_KEY, 0x61, { KEY_SWITCHVIDEOMODE } }, /* LCD Only */
+	{KE_KEY, 0x62, { KEY_SWITCHVIDEOMODE } }, /* CRT Only */
+	{KE_KEY, 0x63, { KEY_SWITCHVIDEOMODE } }, /* LCD + CRT */
+	{KE_KEY, 0x6B, { KEY_TOUCHPAD_TOGGLE } }, /* Lock Touchpad */
 	{KE_KEY, 0x6C, { KEY_SLEEP } }, /* Suspend */
 	{KE_KEY, 0x6D, { KEY_SLEEP } }, /* Hibernate */
 	{KE_IGNORE, 0x6E, },  /* Low Battery notification */
-	{KE_KEY, 0x7E, { KEY_BLUETOOTH } },
-	{KE_KEY, 0x7D, { KEY_BLUETOOTH } },
+	{KE_KEY, 0x7D, { KEY_BLUETOOTH } }, /* Bluetooth Enable */
+	{KE_KEY, 0x7E, { KEY_BLUETOOTH } }, /* Bluetooth Disable */
 	{KE_KEY, 0x82, { KEY_CAMERA } },
-	{KE_KEY, 0x88, { KEY_WLAN  } },
-	{KE_KEY, 0x8A, { KEY_PROG1 } },
+	{KE_KEY, 0x88, { KEY_RFKILL  } }, /* Radio Toggle Key */
+	{KE_KEY, 0x8A, { KEY_PROG1 } }, /* Color enhancement mode */
 	{KE_KEY, 0x95, { KEY_MEDIA } },
 	{KE_KEY, 0x99, { KEY_PHONE } },
-	{KE_KEY, 0xc4, { KEY_KBDILLUMUP } },
-	{KE_KEY, 0xc5, { KEY_KBDILLUMDOWN } },
-	{KE_KEY, 0xb5, { KEY_CALC } },
+	{KE_KEY, 0xB5, { KEY_CALC } },
+	{KE_KEY, 0xC4, { KEY_KBDILLUMUP } },
+	{KE_KEY, 0xC5, { KEY_KBDILLUMDOWN } },
 	{KE_END, 0},
 };
 

commit 982d385ad1e8a485cfd54b30469b3710935990ba
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Wed Oct 3 11:26:25 2012 +0200

    asus-laptop: map some new keys
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index d9f9a0dbc6f3..062ddd7791cc 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -314,6 +314,8 @@ static const struct key_entry asus_keymap[] = {
 	{KE_KEY, 0x50, { KEY_EMAIL } },
 	{KE_KEY, 0x51, { KEY_WWW } },
 	{KE_KEY, 0x55, { KEY_CALC } },
+	{KE_IGNORE, 0x57, },  /* Battery mode */
+	{KE_IGNORE, 0x58, },  /* AC mode */
 	{KE_KEY, 0x5C, { KEY_SCREENLOCK } },  /* Screenlock */
 	{KE_KEY, 0x5D, { KEY_WLAN } },
 	{KE_KEY, 0x5E, { KEY_WLAN } },
@@ -325,6 +327,7 @@ static const struct key_entry asus_keymap[] = {
 	{KE_KEY, 0x6B, { KEY_F13 } }, /* Lock Touchpad */
 	{KE_KEY, 0x6C, { KEY_SLEEP } }, /* Suspend */
 	{KE_KEY, 0x6D, { KEY_SLEEP } }, /* Hibernate */
+	{KE_IGNORE, 0x6E, },  /* Low Battery notification */
 	{KE_KEY, 0x7E, { KEY_BLUETOOTH } },
 	{KE_KEY, 0x7D, { KEY_BLUETOOTH } },
 	{KE_KEY, 0x82, { KEY_CAMERA } },

commit 51fac8388a0325a43f0ae67453ece2c373e2ec28
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 24 00:24:48 2013 +0100

    ACPI: Remove useless type argument of driver .remove() operation
    
    The second argument of ACPI driver .remove() operation is only used
    by the ACPI processor driver and the value passed to that driver
    through it is always available from the given struct acpi_device
    object's removal_type field.  For this reason, the second ACPI driver
    .remove() argument is in fact useless, so drop it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Jiang Liu <jiang.liu@huawei.com>
    Acked-by: Toshi Kani <toshi.kani@hp.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index fcde4e528819..d9f9a0dbc6f3 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -1910,7 +1910,7 @@ static int asus_acpi_add(struct acpi_device *device)
 	return result;
 }
 
-static int asus_acpi_remove(struct acpi_device *device, int type)
+static int asus_acpi_remove(struct acpi_device *device)
 {
 	struct asus_laptop *asus = acpi_driver_data(device);
 

commit 9f89748463f13c9657496b12820f09a988ce77ff
Author: Matthew Garrett <matthew.garrett@nebula.com>
Date:   Fri Dec 28 10:54:42 2012 -0500

    asus-laptop: Fix potential invalid pointer dereference
    
    The 0-day build testing backend noticed that a string could be dereferenced
    without validation. Fix that.
    
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index d0c519762dcf..fcde4e528819 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -1743,7 +1743,7 @@ static int asus_laptop_get_info(struct asus_laptop *asus)
 		return -ENOMEM;
 	}
 
-	if (*string)
+	if (string)
 		pr_notice("  %s model detected\n", string);
 
 	if (!acpi_check_handle(asus->handle, METHOD_WL_STATUS, NULL))

commit cb7da022450cdaaebd33078b6b32fb7dd2aaf6db
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Thu Nov 29 09:12:37 2012 +0100

    asus-laptop: Do not call HWRS on init
    
    Since commit 8871e99f89b7 ('asus-laptop: HRWS/HWRS typo'), module
    initialisation is very slow on the Asus UL30A.  The HWRS method takes
    about 12 seconds to run, and subsequent initialisation also seems to
    be delayed.  Since we don't really need the result, don't bother
    calling it on init.  Those who are curious can still get the result
    through the 'infos' device attribute.
    
    Update the comment about HWRS in show_infos().
    
    Reported-by: ryan <draziw+deb@gmail.com>
    References: http://bugs.debian.org/692436
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index ec1d3bc2dbe2..d0c519762dcf 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -860,8 +860,10 @@ static ssize_t show_infos(struct device *dev,
 	/*
 	 * The HWRS method return informations about the hardware.
 	 * 0x80 bit is for WLAN, 0x100 for Bluetooth.
+	 * 0x40 for WWAN, 0x10 for WIMAX.
 	 * The significance of others is yet to be found.
-	 * If we don't find the method, we assume the device are present.
+	 * We don't currently use this for device detection, and it
+	 * takes several seconds to run on some systems.
 	 */
 	rv = acpi_evaluate_integer(asus->handle, "HWRS", NULL, &temp);
 	if (!ACPI_FAILURE(rv))
@@ -1682,7 +1684,7 @@ static int asus_laptop_get_info(struct asus_laptop *asus)
 {
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 	union acpi_object *model = NULL;
-	unsigned long long bsts_result, hwrs_result;
+	unsigned long long bsts_result;
 	char *string = NULL;
 	acpi_status status;
 
@@ -1744,17 +1746,6 @@ static int asus_laptop_get_info(struct asus_laptop *asus)
 	if (*string)
 		pr_notice("  %s model detected\n", string);
 
-	/*
-	 * The HWRS method return informations about the hardware.
-	 * 0x80 bit is for WLAN, 0x100 for Bluetooth,
-	 * 0x40 for WWAN, 0x10 for WIMAX.
-	 * The significance of others is yet to be found.
-	 */
-	status =
-	    acpi_evaluate_integer(asus->handle, "HWRS", NULL, &hwrs_result);
-	if (!ACPI_FAILURE(status))
-		pr_notice("  HWRS returned %x", (int)hwrs_result);
-
 	if (!acpi_check_handle(asus->handle, METHOD_WL_STATUS, NULL))
 		asus->have_rsts = true;
 

commit b859f15921321b7bf4cb4cf188e31a6a25d2dff3
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:18:33 2012 -0800

    Drivers: platform: x86: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Joey Lee <jlee@novell.com>
    Cc: Matthew Garrett <mjg@redhat.com>
    Cc: Peter Feuerer <peter@piie.net>
    Cc: Corentin Chary <corentin.chary@gmail.com>
    Cc: Cezary Jackiewicz <cezary.jackiewicz@gmail.com>
    Cc: Robert Gerlach <khnz@gmx.de>
    Cc: Ike Panhc <ike.pan@canonical.com>
    Cc: Henrique de Moraes Holschuh <ibm-acpi@hmh.eng.br>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 4b568df56643..ec1d3bc2dbe2 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -1763,7 +1763,7 @@ static int asus_laptop_get_info(struct asus_laptop *asus)
 	return AE_OK;
 }
 
-static int __devinit asus_acpi_init(struct asus_laptop *asus)
+static int asus_acpi_init(struct asus_laptop *asus)
 {
 	int result = 0;
 
@@ -1823,7 +1823,7 @@ static int __devinit asus_acpi_init(struct asus_laptop *asus)
 	return result;
 }
 
-static void __devinit asus_dmi_check(void)
+static void asus_dmi_check(void)
 {
 	const char *model;
 
@@ -1839,7 +1839,7 @@ static void __devinit asus_dmi_check(void)
 
 static bool asus_device_present;
 
-static int __devinit asus_acpi_add(struct acpi_device *device)
+static int asus_acpi_add(struct acpi_device *device)
 {
 	struct asus_laptop *asus;
 	int result;

commit 3f5449bf39896587ca9f87b76832c5aa30f0f5c7
Author: Maxim Nikulin <m.a.nikulin@gmail.com>
Date:   Mon Aug 20 23:01:52 2012 +0200

    platform/x86: fix asus_laptop.wled_type description
    
    MODULE_PARM_DESC for wlan_status is further in the same file
    
    Signed-off-by: Maxim A. Nikulin <M.A.Nikulin@gmail.com>
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 110c7778cbf9..4b568df56643 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -85,7 +85,7 @@ static char *wled_type = "unknown";
 static char *bled_type = "unknown";
 
 module_param(wled_type, charp, 0444);
-MODULE_PARM_DESC(wlan_status, "Set the wled type on boot "
+MODULE_PARM_DESC(wled_type, "Set the wled type on boot "
 		 "(unknown, led or rfkill). "
 		 "default is unknown");
 

commit 8871e99f89b7d7b1ea99de550eea2a56273f42ab
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Mon Aug 20 23:01:51 2012 +0200

    asus-laptop: HRWS/HWRS typo
    
    Resolves-bug: https://bugzilla.kernel.org/show_bug.cgi?id=24222
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index e38f91be0b10..110c7778cbf9 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -863,9 +863,9 @@ static ssize_t show_infos(struct device *dev,
 	 * The significance of others is yet to be found.
 	 * If we don't find the method, we assume the device are present.
 	 */
-	rv = acpi_evaluate_integer(asus->handle, "HRWS", NULL, &temp);
+	rv = acpi_evaluate_integer(asus->handle, "HWRS", NULL, &temp);
 	if (!ACPI_FAILURE(rv))
-		len += sprintf(page + len, "HRWS value         : %#x\n",
+		len += sprintf(page + len, "HWRS value         : %#x\n",
 			       (uint) temp);
 	/*
 	 * Another value for userspace: the ASYM method returns 0x02 for
@@ -1751,9 +1751,9 @@ static int asus_laptop_get_info(struct asus_laptop *asus)
 	 * The significance of others is yet to be found.
 	 */
 	status =
-	    acpi_evaluate_integer(asus->handle, "HRWS", NULL, &hwrs_result);
+	    acpi_evaluate_integer(asus->handle, "HWRS", NULL, &hwrs_result);
 	if (!ACPI_FAILURE(status))
-		pr_notice("  HRWS returned %x", (int)hwrs_result);
+		pr_notice("  HWRS returned %x", (int)hwrs_result);
 
 	if (!acpi_check_handle(asus->handle, METHOD_WL_STATUS, NULL))
 		asus->have_rsts = true;

commit a2d5dd24af1308d35329d78e74a1a3a94a1c1344
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Thu Dec 15 08:27:38 2011 +0100

    asus-laptop: add some keys found on Lenovo SL500
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index c1125b36d177..e38f91be0b10 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -297,6 +297,7 @@ static const struct key_entry asus_keymap[] = {
 	{KE_KEY, 0x02, { KEY_SCREENLOCK } },
 	{KE_KEY, 0x05, { KEY_WLAN } },
 	{KE_KEY, 0x08, { KEY_F13 } },
+	{KE_KEY, 0x09, { KEY_PROG2 } }, /* Dock */
 	{KE_KEY, 0x17, { KEY_ZOOM } },
 	{KE_KEY, 0x1f, { KEY_BATTERY } },
 	/* End of Lenovo SL Specific keycodes */
@@ -322,6 +323,8 @@ static const struct key_entry asus_keymap[] = {
 	{KE_KEY, 0x62, { KEY_SWITCHVIDEOMODE } },
 	{KE_KEY, 0x63, { KEY_SWITCHVIDEOMODE } },
 	{KE_KEY, 0x6B, { KEY_F13 } }, /* Lock Touchpad */
+	{KE_KEY, 0x6C, { KEY_SLEEP } }, /* Suspend */
+	{KE_KEY, 0x6D, { KEY_SLEEP } }, /* Hibernate */
 	{KE_KEY, 0x7E, { KEY_BLUETOOTH } },
 	{KE_KEY, 0x7D, { KEY_BLUETOOTH } },
 	{KE_KEY, 0x82, { KEY_CAMERA } },

commit 26594dd47669ec213297b25fae20cdbb21f877b8
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Thu Dec 15 08:27:36 2011 +0100

    asus-laptop: check WLED and BLED presence before adding rfkill
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 547b9eba03ae..c1125b36d177 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -1361,14 +1361,16 @@ static int asus_rfkill_init(struct asus_laptop *asus)
 		goto exit;
 
 
-	if (asus->wled_type == TYPE_RFKILL)
+	if (!acpi_check_handle(asus->handle, METHOD_WLAN, NULL) &&
+	    asus->wled_type == TYPE_RFKILL)
 		result = asus_rfkill_setup(asus, &asus->wlan, "asus-wlan",
 					   WL_RSTS, RFKILL_TYPE_WLAN,
 					   &asus_rfkill_ops);
 	if (result)
 		goto exit;
 
-	if (asus->bled_type == TYPE_RFKILL)
+	if (!acpi_check_handle(asus->handle, METHOD_BLUETOOTH, NULL) &&
+	    asus->bled_type == TYPE_RFKILL)
 		result = asus_rfkill_setup(asus, &asus->bluetooth,
 					   "asus-bluetooth", BT_RSTS,
 					   RFKILL_TYPE_BLUETOOTH,

commit 3c8671ffd334cfb692089ec00141b56d5a796ae7
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Thu Dec 15 08:27:35 2011 +0100

    asus-laptop: add rfkill interfaces for wlan and wwan
    
    But don't try to do than on pegatron tablets to avoid any
    conflict.
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index e416867c0725..547b9eba03ae 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -282,6 +282,7 @@ struct asus_laptop {
 	struct asus_rfkill wlan;
 	struct asus_rfkill bluetooth;
 	struct asus_rfkill wwan;
+	struct asus_rfkill wimax;
 	struct asus_rfkill gps;
 
 	acpi_handle handle;	/* the handle of the hotk device */
@@ -1291,6 +1292,10 @@ static int asus_rfkill_set(void *data, bool blocked)
 		return asus_wlan_set(asus, !blocked);
 	else if (rfk->control_id == BT_RSTS)
 		return asus_bluetooth_set(asus, !blocked);
+	else if (rfk->control_id == WM_RSTS)
+		return asus_wimax_set(asus, !blocked);
+	else if (rfk->control_id == WW_RSTS)
+		return asus_wwan_set(asus, !blocked);
 
 	return -EINVAL;
 }
@@ -1343,6 +1348,9 @@ static int asus_rfkill_init(struct asus_laptop *asus)
 {
 	int result = 0;
 
+	if (asus->is_pega_lucid)
+		return -ENODEV;
+
 	if (!acpi_check_handle(asus->handle, METHOD_GPS_ON, NULL) &&
 	    !acpi_check_handle(asus->handle, METHOD_GPS_OFF, NULL) &&
 	    !acpi_check_handle(asus->handle, METHOD_GPS_STATUS, NULL))
@@ -1368,6 +1376,20 @@ static int asus_rfkill_init(struct asus_laptop *asus)
 	if (result)
 		goto exit;
 
+	if (!acpi_check_handle(asus->handle, METHOD_WWAN, NULL))
+		result = asus_rfkill_setup(asus, &asus->wwan, "asus-wwan",
+					   WW_RSTS, RFKILL_TYPE_WWAN,
+					   &asus_rfkill_ops);
+	if (result)
+		goto exit;
+
+	if (!acpi_check_handle(asus->handle, METHOD_WIMAX, NULL))
+		result = asus_rfkill_setup(asus, &asus->wimax, "asus-wimax",
+					   WM_RSTS, RFKILL_TYPE_WIMAX,
+					   &asus_rfkill_ops);
+	if (result)
+		goto exit;
+
 exit:
 	if (result)
 		asus_rfkill_exit(asus);
@@ -1859,7 +1881,7 @@ static int __devinit asus_acpi_add(struct acpi_device *device)
 		goto fail_led;
 
 	result = asus_rfkill_init(asus);
-	if (result)
+	if (result && result != -ENODEV)
 		goto fail_rfkill;
 
 	result = pega_accel_init(asus);

commit 774b06780be20d07c5459becd6495c04523a93a2
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Thu Dec 15 08:27:34 2011 +0100

    asus-laptop: control how BLED and WLED should be exposed
    
    Let the user tells if BLED and WLED should be exposed as led or
    rfkill (the old sysfs are still here, but this adds a standard
    interface to control the device).
    
    For example on my A6JC, with WAPF=1, I would do:
    
    $ modprobe asus-laptop wled_type=led bluetooth_type=rfkill
    
    There is still no known way to automatically guess what BLED
    and WLED methods will control, it's why user information is needed.
    
    A userspace database could do that automatically, and maybe some DMI
    matching in the driver.
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index db32d0337a7c..e416867c0725 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -81,6 +81,19 @@ static uint wapf = 1;
 module_param(wapf, uint, 0444);
 MODULE_PARM_DESC(wapf, "WAPF value");
 
+static char *wled_type = "unknown";
+static char *bled_type = "unknown";
+
+module_param(wled_type, charp, 0444);
+MODULE_PARM_DESC(wlan_status, "Set the wled type on boot "
+		 "(unknown, led or rfkill). "
+		 "default is unknown");
+
+module_param(bled_type, charp, 0444);
+MODULE_PARM_DESC(bled_type, "Set the bled type on boot "
+		 "(unknown, led or rfkill). "
+		 "default is unknown");
+
 static int wlan_status = 1;
 static int bluetooth_status = 1;
 static int wimax_status = -1;
@@ -137,6 +150,11 @@ MODULE_PARM_DESC(als_status, "Set the ALS status on boot "
 #define WM_RSTS		0x08    /* internal wimax */
 #define WW_RSTS		0x20    /* internal wwan */
 
+/* WLED and BLED type */
+#define TYPE_UNKNOWN	0
+#define TYPE_LED	1
+#define TYPE_RFKILL	2
+
 /* LED */
 #define METHOD_MLED		"MLED"
 #define METHOD_TLED		"TLED"
@@ -219,7 +237,8 @@ struct asus_led {
  * Same thing for rfkill
  */
 struct asus_rfkill {
-	int control_id;		/* type of control. Maps to PEGA_* values */
+	/* type of control. Maps to PEGA_* values or *_RSTS  */
+	int control_id;
 	struct rfkill *rfkill;
 	struct asus_laptop *asus;
 };
@@ -240,6 +259,8 @@ struct asus_laptop {
 	struct key_entry *keymap;
 	struct input_polled_dev *pega_accel_poll;
 
+	struct asus_led wled;
+	struct asus_led bled;
 	struct asus_led mled;
 	struct asus_led tled;
 	struct asus_led rled;
@@ -248,6 +269,8 @@ struct asus_laptop {
 	struct asus_led kled;
 	struct workqueue_struct *led_workqueue;
 
+	int wled_type;
+	int bled_type;
 	int wireless_status;
 	bool have_rsts;
 	bool is_pega_lucid;
@@ -600,6 +623,10 @@ static enum led_brightness asus_kled_cdev_get(struct led_classdev *led_cdev)
 
 static void asus_led_exit(struct asus_laptop *asus)
 {
+	if (!IS_ERR_OR_NULL(asus->wled.led.dev))
+		led_classdev_unregister(&asus->wled.led);
+	if (!IS_ERR_OR_NULL(asus->bled.led.dev))
+		led_classdev_unregister(&asus->bled.led);
 	if (!IS_ERR_OR_NULL(asus->mled.led.dev))
 		led_classdev_unregister(&asus->mled.led);
 	if (!IS_ERR_OR_NULL(asus->tled.led.dev))
@@ -641,7 +668,7 @@ static int asus_led_register(struct asus_laptop *asus,
 
 static int asus_led_init(struct asus_laptop *asus)
 {
-	int r;
+	int r = 0;
 
 	/*
 	 * The Pegatron Lucid has no physical leds, but all methods are
@@ -660,6 +687,16 @@ static int asus_led_init(struct asus_laptop *asus)
 	if (!asus->led_workqueue)
 		return -ENOMEM;
 
+	if (asus->wled_type == TYPE_LED)
+		r = asus_led_register(asus, &asus->wled, "asus::wlan",
+				      METHOD_WLAN);
+	if (r)
+		goto error;
+	if (asus->bled_type == TYPE_LED)
+		r = asus_led_register(asus, &asus->bled, "asus::bluetooth",
+				      METHOD_BLUETOOTH);
+	if (r)
+		goto error;
 	r = asus_led_register(asus, &asus->mled, "asus::mail", METHOD_MLED);
 	if (r)
 		goto error;
@@ -962,7 +999,7 @@ static ssize_t store_wlan(struct device *dev, struct device_attribute *attr,
 	return sysfs_acpi_set(asus, buf, count, METHOD_WLAN);
 }
 
-/*
+/*e
  * Bluetooth
  */
 static int asus_bluetooth_set(struct asus_laptop *asus, int status)
@@ -1245,6 +1282,23 @@ static const struct rfkill_ops asus_gps_rfkill_ops = {
 	.set_block = asus_gps_rfkill_set,
 };
 
+static int asus_rfkill_set(void *data, bool blocked)
+{
+	struct asus_rfkill *rfk = data;
+	struct asus_laptop *asus = rfk->asus;
+
+	if (rfk->control_id == WL_RSTS)
+		return asus_wlan_set(asus, !blocked);
+	else if (rfk->control_id == BT_RSTS)
+		return asus_bluetooth_set(asus, !blocked);
+
+	return -EINVAL;
+}
+
+static const struct rfkill_ops asus_rfkill_ops = {
+	.set_block = asus_rfkill_set,
+};
+
 static void asus_rfkill_terminate(struct asus_rfkill *rfk)
 {
 	if (!rfk->rfkill)
@@ -1263,30 +1317,64 @@ static void asus_rfkill_exit(struct asus_laptop *asus)
 	asus_rfkill_terminate(&asus->gps);
 }
 
-static int asus_rfkill_init(struct asus_laptop *asus)
+static int asus_rfkill_setup(struct asus_laptop *asus, struct asus_rfkill *rfk,
+			     const char *name, int control_id, int type,
+			     const struct rfkill_ops *ops)
 {
 	int result;
 
-	if (acpi_check_handle(asus->handle, METHOD_GPS_ON, NULL) ||
-	    acpi_check_handle(asus->handle, METHOD_GPS_OFF, NULL) ||
-	    acpi_check_handle(asus->handle, METHOD_GPS_STATUS, NULL))
-		return 0;
-
-	asus->gps.rfkill = rfkill_alloc("asus-gps", &asus->platform_device->dev,
-					RFKILL_TYPE_GPS,
-					&asus_gps_rfkill_ops, asus);
-	if (!asus->gps.rfkill)
+	rfk->control_id = control_id;
+	rfk->asus = asus;
+	rfk->rfkill = rfkill_alloc(name, &asus->platform_device->dev,
+				   type, ops, rfk);
+	if (!rfk->rfkill)
 		return -EINVAL;
 
-	result = rfkill_register(asus->gps.rfkill);
+	result = rfkill_register(rfk->rfkill);
 	if (result) {
-		rfkill_destroy(asus->gps.rfkill);
-		asus->gps.rfkill = NULL;
+		rfkill_destroy(rfk->rfkill);
+		rfk->rfkill = NULL;
 	}
 
 	return result;
 }
 
+static int asus_rfkill_init(struct asus_laptop *asus)
+{
+	int result = 0;
+
+	if (!acpi_check_handle(asus->handle, METHOD_GPS_ON, NULL) &&
+	    !acpi_check_handle(asus->handle, METHOD_GPS_OFF, NULL) &&
+	    !acpi_check_handle(asus->handle, METHOD_GPS_STATUS, NULL))
+		result = asus_rfkill_setup(asus, &asus->gps, "asus-gps",
+					   -1, RFKILL_TYPE_GPS,
+					   &asus_gps_rfkill_ops);
+	if (result)
+		goto exit;
+
+
+	if (asus->wled_type == TYPE_RFKILL)
+		result = asus_rfkill_setup(asus, &asus->wlan, "asus-wlan",
+					   WL_RSTS, RFKILL_TYPE_WLAN,
+					   &asus_rfkill_ops);
+	if (result)
+		goto exit;
+
+	if (asus->bled_type == TYPE_RFKILL)
+		result = asus_rfkill_setup(asus, &asus->bluetooth,
+					   "asus-bluetooth", BT_RSTS,
+					   RFKILL_TYPE_BLUETOOTH,
+					   &asus_rfkill_ops);
+	if (result)
+		goto exit;
+
+exit:
+	if (result)
+		asus_rfkill_exit(asus);
+
+	return result;
+}
+
 static int pega_rfkill_set(void *data, bool blocked)
 {
 	struct asus_rfkill *rfk = data;
@@ -1302,22 +1390,8 @@ static const struct rfkill_ops pega_rfkill_ops = {
 static int pega_rfkill_setup(struct asus_laptop *asus, struct asus_rfkill *rfk,
 			     const char *name, int controlid, int rfkill_type)
 {
-	int result;
-
-	rfk->control_id = controlid;
-	rfk->asus = asus;
-	rfk->rfkill = rfkill_alloc(name, &asus->platform_device->dev,
-				   rfkill_type, &pega_rfkill_ops, rfk);
-	if (!rfk->rfkill)
-		return -EINVAL;
-
-	result = rfkill_register(rfk->rfkill);
-	if (result) {
-		rfkill_destroy(rfk->rfkill);
-		rfk->rfkill = NULL;
-	}
-
-	return result;
+	return asus_rfkill_setup(asus, rfk, name, controlid, rfkill_type,
+				 &pega_rfkill_ops);
 }
 
 static int pega_rfkill_init(struct asus_laptop *asus)
@@ -1678,7 +1752,16 @@ static int __devinit asus_acpi_init(struct asus_laptop *asus)
 	if (result)
 		return result;
 
-	/* WLED and BLED are on by default */
+	if (!strcmp(bled_type, "led"))
+		asus->bled_type = TYPE_LED;
+	else if (!strcmp(bled_type, "rfkill"))
+		asus->bled_type = TYPE_RFKILL;
+
+	if (!strcmp(wled_type, "led"))
+		asus->wled_type = TYPE_LED;
+	else if (!strcmp(wled_type, "rfkill"))
+		asus->wled_type = TYPE_RFKILL;
+
 	if (bluetooth_status >= 0)
 		asus_bluetooth_set(asus, !!bluetooth_status);
 

commit 40969c7dd6298718820e0818b5b5acef7b24923d
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Thu Dec 15 08:27:33 2011 +0100

    asus-laptop: cleanup rfkill code
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 3976cfac5ffe..db32d0337a7c 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -218,7 +218,7 @@ struct asus_led {
 /*
  * Same thing for rfkill
  */
-struct asus_pega_rfkill {
+struct asus_rfkill {
 	int control_id;		/* type of control. Maps to PEGA_* values */
 	struct rfkill *rfkill;
 	struct asus_laptop *asus;
@@ -256,11 +256,10 @@ struct asus_laptop {
 	int pega_acc_y;
 	int pega_acc_z;
 
-	struct rfkill *gps_rfkill;
-
-	struct asus_pega_rfkill wlanrfk;
-	struct asus_pega_rfkill btrfk;
-	struct asus_pega_rfkill wwanrfk;
+	struct asus_rfkill wlan;
+	struct asus_rfkill bluetooth;
+	struct asus_rfkill wwan;
+	struct asus_rfkill gps;
 
 	acpi_handle handle;	/* the handle of the hotk device */
 	u32 ledd_status;	/* status of the LED display */
@@ -1228,7 +1227,7 @@ static ssize_t store_gps(struct device *dev, struct device_attribute *attr,
 	ret = asus_gps_switch(asus, !!value);
 	if (ret)
 		return ret;
-	rfkill_set_sw_state(asus->gps_rfkill, !value);
+	rfkill_set_sw_state(asus->gps.rfkill, !value);
 	return rv;
 }
 
@@ -1246,13 +1245,22 @@ static const struct rfkill_ops asus_gps_rfkill_ops = {
 	.set_block = asus_gps_rfkill_set,
 };
 
+static void asus_rfkill_terminate(struct asus_rfkill *rfk)
+{
+	if (!rfk->rfkill)
+		return ;
+
+	rfkill_unregister(rfk->rfkill);
+	rfkill_destroy(rfk->rfkill);
+	rfk->rfkill = NULL;
+}
+
 static void asus_rfkill_exit(struct asus_laptop *asus)
 {
-	if (asus->gps_rfkill) {
-		rfkill_unregister(asus->gps_rfkill);
-		rfkill_destroy(asus->gps_rfkill);
-		asus->gps_rfkill = NULL;
-	}
+	asus_rfkill_terminate(&asus->wwan);
+	asus_rfkill_terminate(&asus->bluetooth);
+	asus_rfkill_terminate(&asus->wlan);
+	asus_rfkill_terminate(&asus->gps);
 }
 
 static int asus_rfkill_init(struct asus_laptop *asus)
@@ -1264,16 +1272,16 @@ static int asus_rfkill_init(struct asus_laptop *asus)
 	    acpi_check_handle(asus->handle, METHOD_GPS_STATUS, NULL))
 		return 0;
 
-	asus->gps_rfkill = rfkill_alloc("asus-gps", &asus->platform_device->dev,
+	asus->gps.rfkill = rfkill_alloc("asus-gps", &asus->platform_device->dev,
 					RFKILL_TYPE_GPS,
 					&asus_gps_rfkill_ops, asus);
-	if (!asus->gps_rfkill)
+	if (!asus->gps.rfkill)
 		return -EINVAL;
 
-	result = rfkill_register(asus->gps_rfkill);
+	result = rfkill_register(asus->gps.rfkill);
 	if (result) {
-		rfkill_destroy(asus->gps_rfkill);
-		asus->gps_rfkill = NULL;
+		rfkill_destroy(asus->gps.rfkill);
+		asus->gps.rfkill = NULL;
 	}
 
 	return result;
@@ -1281,11 +1289,9 @@ static int asus_rfkill_init(struct asus_laptop *asus)
 
 static int pega_rfkill_set(void *data, bool blocked)
 {
-	struct asus_pega_rfkill *pega_rfk = data;
-
-	int ret = asus_pega_lucid_set(pega_rfk->asus, pega_rfk->control_id, !blocked);
-	pr_warn("Setting rfkill %d, to %d; returned %d\n", pega_rfk->control_id, !blocked, ret);
+	struct asus_rfkill *rfk = data;
 
+	int ret = asus_pega_lucid_set(rfk->asus, rfk->control_id, !blocked);
 	return ret;
 }
 
@@ -1293,40 +1299,22 @@ static const struct rfkill_ops pega_rfkill_ops = {
 	.set_block = pega_rfkill_set,
 };
 
-static void pega_rfkill_terminate(struct asus_pega_rfkill *pega_rfk)
-{
-	pr_warn("Terminating %d\n", pega_rfk->control_id);
-	if (pega_rfk->rfkill) {
-		rfkill_unregister(pega_rfk->rfkill);
-		rfkill_destroy(pega_rfk->rfkill);
-		pega_rfk->rfkill = NULL;
-	}
-}
-
-static void pega_rfkill_exit(struct asus_laptop *asus)
-{
-	pega_rfkill_terminate(&asus->wwanrfk);
-	pega_rfkill_terminate(&asus->btrfk);
-	pega_rfkill_terminate(&asus->wlanrfk);
-}
-
-static int pega_rfkill_setup(struct asus_laptop *asus, struct asus_pega_rfkill *pega_rfk,
-		const char *name, int controlid, int rfkill_type)
+static int pega_rfkill_setup(struct asus_laptop *asus, struct asus_rfkill *rfk,
+			     const char *name, int controlid, int rfkill_type)
 {
 	int result;
 
-	pr_warn("Setting up rfk %s, control %d, type %d\n", name, controlid, rfkill_type);
-	pega_rfk->control_id = controlid;
-	pega_rfk->asus = asus;
-	pega_rfk->rfkill = rfkill_alloc(name, &asus->platform_device->dev,
-					rfkill_type, &pega_rfkill_ops, pega_rfk);
-	if (!pega_rfk->rfkill)
+	rfk->control_id = controlid;
+	rfk->asus = asus;
+	rfk->rfkill = rfkill_alloc(name, &asus->platform_device->dev,
+				   rfkill_type, &pega_rfkill_ops, rfk);
+	if (!rfk->rfkill)
 		return -EINVAL;
 
-	result = rfkill_register(pega_rfk->rfkill);
+	result = rfkill_register(rfk->rfkill);
 	if (result) {
-		rfkill_destroy(pega_rfk->rfkill);
-		pega_rfk->rfkill = NULL;
+		rfkill_destroy(rfk->rfkill);
+		rfk->rfkill = NULL;
 	}
 
 	return result;
@@ -1339,22 +1327,22 @@ static int pega_rfkill_init(struct asus_laptop *asus)
 	if(!asus->is_pega_lucid)
 		return -ENODEV;
 
-	ret = pega_rfkill_setup(asus, &asus->wlanrfk, "pega-wlan", PEGA_WLAN, RFKILL_TYPE_WLAN);
+	ret = pega_rfkill_setup(asus, &asus->wlan, "pega-wlan",
+				PEGA_WLAN, RFKILL_TYPE_WLAN);
 	if(ret)
-		return ret;
-	ret = pega_rfkill_setup(asus, &asus->btrfk, "pega-bt", PEGA_BLUETOOTH, RFKILL_TYPE_BLUETOOTH);
-	if(ret)
-		goto err_btrfk;
-	ret = pega_rfkill_setup(asus, &asus->wwanrfk, "pega-wwan", PEGA_WWAN, RFKILL_TYPE_WWAN);
+		goto exit;
+
+	ret = pega_rfkill_setup(asus, &asus->bluetooth, "pega-bt",
+				PEGA_BLUETOOTH, RFKILL_TYPE_BLUETOOTH);
 	if(ret)
-		goto err_wwanrfk;
+		goto exit;
 
-	pr_warn("Pega rfkill init succeeded\n");
-	return 0;
-err_wwanrfk:
-	pega_rfkill_terminate(&asus->btrfk);
-err_btrfk:
-	pega_rfkill_terminate(&asus->wlanrfk);
+	ret = pega_rfkill_setup(asus, &asus->wwan, "pega-wwan",
+				PEGA_WWAN, RFKILL_TYPE_WWAN);
+
+exit:
+	if (ret)
+		asus_rfkill_exit(asus);
 
 	return ret;
 }
@@ -1377,7 +1365,7 @@ static int asus_input_init(struct asus_laptop *asus)
 
 	input = input_allocate_device();
 	if (!input) {
-		pr_info("Unable to allocate input device\n");
+		pr_warn("Unable to allocate input device\n");
 		return -ENOMEM;
 	}
 	input->name = "Asus Laptop extra buttons";
@@ -1392,7 +1380,7 @@ static int asus_input_init(struct asus_laptop *asus)
 	}
 	error = input_register_device(input);
 	if (error) {
-		pr_info("Unable to register input device\n");
+		pr_warn("Unable to register input device\n");
 		goto err_free_keymap;
 	}
 
@@ -1830,7 +1818,6 @@ static int asus_acpi_remove(struct acpi_device *device, int type)
 	asus_led_exit(asus);
 	asus_input_exit(asus);
 	pega_accel_exit(asus);
-	pega_rfkill_exit(asus);
 	asus_platform_exit(asus);
 
 	kfree(asus->name);

commit e0ac913374247f000aa97fdd732dcaf0070dd466
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Thu Dec 15 08:27:31 2011 +0100

    asus-laptop: log unknown keys
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index b7944f903886..3976cfac5ffe 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -1364,8 +1364,10 @@ static int pega_rfkill_init(struct asus_laptop *asus)
  */
 static void asus_input_notify(struct asus_laptop *asus, int event)
 {
-	if (asus->inputdev)
-		sparse_keymap_report_event(asus->inputdev, event, 1, true);
+	if (!asus->inputdev)
+		return ;
+	if (!sparse_keymap_report_event(asus->inputdev, event, 1, true))
+		pr_info("Unknown key %x pressed\n", event);
 }
 
 static int asus_input_init(struct asus_laptop *asus)

commit 587a1f1659e8b330b8738ef4901832a2b63f0bed
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jul 23 23:11:19 2011 -0400

    switch ->is_visible() to returning umode_t
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index edaccad9b5bf..b7944f903886 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -1477,7 +1477,7 @@ static struct attribute *asus_attributes[] = {
 	NULL
 };
 
-static mode_t asus_sysfs_is_visible(struct kobject *kobj,
+static umode_t asus_sysfs_is_visible(struct kobject *kobj,
 				    struct attribute *attr,
 				    int idx)
 {

commit 149083996e52c640fdfd73ad92550be4b803f349
Author: Anisse Astier <anisse@astier.eu>
Date:   Fri Oct 14 11:13:42 2011 +0200

    asus-laptop: Add rfkill support for Pegatron Lucid tablet
    
    Add three new rfkill switches in this driver that are specific to
    Pegatron Lucid tablet.
    Please note that you might not need all three switches. For example if
    you don't have a 3G module inside your tablet.
    
    Also, on my device, the gpio for the wifi/bt module is connected to the
    bluetooth line. Therefore to activate your wireless lan interface, you
    need to use the "pega-bt" rfkill switch.
    
    Finally, the rfkill switch only works before the wireless module is
    loaded the first time. Unloading ath9k doesn't help, a reboot is
    necessary.
    
    Signed-off-by: Anisse Astier <anisse@astier.eu>
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 05c0e594c036..edaccad9b5bf 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -186,6 +186,9 @@ MODULE_PARM_DESC(als_status, "Set the ALS status on boot "
 
 #define METHOD_PEGA_ENABLE	"ENPR"
 #define METHOD_PEGA_DISABLE	"DAPR"
+#define PEGA_WLAN	0x00
+#define PEGA_BLUETOOTH	0x01
+#define PEGA_WWAN	0x02
 #define PEGA_ALS	0x04
 #define PEGA_ALS_POWER	0x05
 
@@ -212,6 +215,15 @@ struct asus_led {
 	const char *method;
 };
 
+/*
+ * Same thing for rfkill
+ */
+struct asus_pega_rfkill {
+	int control_id;		/* type of control. Maps to PEGA_* values */
+	struct rfkill *rfkill;
+	struct asus_laptop *asus;
+};
+
 /*
  * This is the main structure, we can use it to store anything interesting
  * about the hotk device
@@ -246,6 +258,10 @@ struct asus_laptop {
 
 	struct rfkill *gps_rfkill;
 
+	struct asus_pega_rfkill wlanrfk;
+	struct asus_pega_rfkill btrfk;
+	struct asus_pega_rfkill wwanrfk;
+
 	acpi_handle handle;	/* the handle of the hotk device */
 	u32 ledd_status;	/* status of the LED display */
 	u8 light_level;		/* light sensor level */
@@ -1263,6 +1279,86 @@ static int asus_rfkill_init(struct asus_laptop *asus)
 	return result;
 }
 
+static int pega_rfkill_set(void *data, bool blocked)
+{
+	struct asus_pega_rfkill *pega_rfk = data;
+
+	int ret = asus_pega_lucid_set(pega_rfk->asus, pega_rfk->control_id, !blocked);
+	pr_warn("Setting rfkill %d, to %d; returned %d\n", pega_rfk->control_id, !blocked, ret);
+
+	return ret;
+}
+
+static const struct rfkill_ops pega_rfkill_ops = {
+	.set_block = pega_rfkill_set,
+};
+
+static void pega_rfkill_terminate(struct asus_pega_rfkill *pega_rfk)
+{
+	pr_warn("Terminating %d\n", pega_rfk->control_id);
+	if (pega_rfk->rfkill) {
+		rfkill_unregister(pega_rfk->rfkill);
+		rfkill_destroy(pega_rfk->rfkill);
+		pega_rfk->rfkill = NULL;
+	}
+}
+
+static void pega_rfkill_exit(struct asus_laptop *asus)
+{
+	pega_rfkill_terminate(&asus->wwanrfk);
+	pega_rfkill_terminate(&asus->btrfk);
+	pega_rfkill_terminate(&asus->wlanrfk);
+}
+
+static int pega_rfkill_setup(struct asus_laptop *asus, struct asus_pega_rfkill *pega_rfk,
+		const char *name, int controlid, int rfkill_type)
+{
+	int result;
+
+	pr_warn("Setting up rfk %s, control %d, type %d\n", name, controlid, rfkill_type);
+	pega_rfk->control_id = controlid;
+	pega_rfk->asus = asus;
+	pega_rfk->rfkill = rfkill_alloc(name, &asus->platform_device->dev,
+					rfkill_type, &pega_rfkill_ops, pega_rfk);
+	if (!pega_rfk->rfkill)
+		return -EINVAL;
+
+	result = rfkill_register(pega_rfk->rfkill);
+	if (result) {
+		rfkill_destroy(pega_rfk->rfkill);
+		pega_rfk->rfkill = NULL;
+	}
+
+	return result;
+}
+
+static int pega_rfkill_init(struct asus_laptop *asus)
+{
+	int ret = 0;
+
+	if(!asus->is_pega_lucid)
+		return -ENODEV;
+
+	ret = pega_rfkill_setup(asus, &asus->wlanrfk, "pega-wlan", PEGA_WLAN, RFKILL_TYPE_WLAN);
+	if(ret)
+		return ret;
+	ret = pega_rfkill_setup(asus, &asus->btrfk, "pega-bt", PEGA_BLUETOOTH, RFKILL_TYPE_BLUETOOTH);
+	if(ret)
+		goto err_btrfk;
+	ret = pega_rfkill_setup(asus, &asus->wwanrfk, "pega-wwan", PEGA_WWAN, RFKILL_TYPE_WWAN);
+	if(ret)
+		goto err_wwanrfk;
+
+	pr_warn("Pega rfkill init succeeded\n");
+	return 0;
+err_wwanrfk:
+	pega_rfkill_terminate(&asus->btrfk);
+err_btrfk:
+	pega_rfkill_terminate(&asus->wlanrfk);
+
+	return ret;
+}
+
 /*
  * Input device (i.e. hotkeys)
  */
@@ -1697,9 +1793,15 @@ static int __devinit asus_acpi_add(struct acpi_device *device)
 	if (result && result != -ENODEV)
 		goto fail_pega_accel;
 
+	result = pega_rfkill_init(asus);
+	if (result && result != -ENODEV)
+		goto fail_pega_rfkill;
+
 	asus_device_present = true;
 	return 0;
 
+fail_pega_rfkill:
+	pega_accel_exit(asus);
 fail_pega_accel:
 	asus_rfkill_exit(asus);
 fail_rfkill:
@@ -1726,6 +1828,7 @@ static int asus_acpi_remove(struct acpi_device *device, int type)
 	asus_led_exit(asus);
 	asus_input_exit(asus);
 	pega_accel_exit(asus);
+	pega_rfkill_exit(asus);
 	asus_platform_exit(asus);
 
 	kfree(asus->name);

commit b93f82816c9ee4868c5aa1c8e06259233916d988
Author: Anisse Astier <anisse@astier.eu>
Date:   Fri Oct 14 11:13:41 2011 +0200

    asus-laptop: pega_accel - Report accelerometer orientation change through udev
    
    Signed-off-by: Anisse Astier <anisse@astier.eu>
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 012c44d38d48..05c0e594c036 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -1342,6 +1342,14 @@ static void asus_acpi_notify(struct acpi_device *device, u32 event)
 		}
 		return ;
 	}
+
+	/* Accelerometer "coarse orientation change" event */
+	if (asus->pega_accel_poll && event == 0xEA) {
+		kobject_uevent(&asus->pega_accel_poll->input->dev.kobj,
+			       KOBJ_CHANGE);
+		return ;
+	}
+
 	asus_input_notify(asus, event);
 }
 

commit 16cbf93369a8d148316a75c333bb81bbb64a46c4
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Fri Oct 14 11:13:40 2011 +0200

    asus-laptop: fix module description
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 1fb8e699baf4..012c44d38d48 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -90,22 +90,22 @@ static int als_status;
 module_param(wlan_status, int, 0444);
 MODULE_PARM_DESC(wlan_status, "Set the wireless status on boot "
 		 "(0 = disabled, 1 = enabled, -1 = don't do anything). "
-		 "default is 1");
+		 "default is -1");
 
 module_param(bluetooth_status, int, 0444);
 MODULE_PARM_DESC(bluetooth_status, "Set the wireless status on boot "
 		 "(0 = disabled, 1 = enabled, -1 = don't do anything). "
-		 "default is 1");
+		 "default is -1");
 
 module_param(wimax_status, int, 0444);
 MODULE_PARM_DESC(wimax_status, "Set the wireless status on boot "
 		 "(0 = disabled, 1 = enabled, -1 = don't do anything). "
-		 "default is 1");
+		 "default is -1");
 
 module_param(wwan_status, int, 0444);
 MODULE_PARM_DESC(wwan_status, "Set the wireless status on boot "
 		 "(0 = disabled, 1 = enabled, -1 = don't do anything). "
-		 "default is 1");
+		 "default is -1");
 
 module_param(als_status, int, 0444);
 MODULE_PARM_DESC(als_status, "Set the ALS status on boot "

commit 8d38e42c61c53ab63abbb15380b39df4eae8d44e
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Fri Oct 14 11:13:39 2011 +0200

    asus-laptop: hide leds on Pegatron Lucid
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 613762d825f9..1fb8e699baf4 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -628,6 +628,13 @@ static int asus_led_init(struct asus_laptop *asus)
 {
 	int r;
 
+	/*
+	 * The Pegatron Lucid has no physical leds, but all methods are
+	 * available in the DSDT...
+	 */
+	if (asus->is_pega_lucid)
+		return 0;
+
 	/*
 	 * Functions that actually update the LED's are called from a
 	 * workqueue. By doing this as separate work rather than when the LED

commit b23910c2194e0e0ee43e585788085f8e6dd4877e
Author: Andy Ross <andy.ross@windriver.com>
Date:   Fri Oct 14 11:13:38 2011 +0200

    asus-laptop: Pegatron Lucid accelerometer
    
    Support the built-in accelerometer on the Lucid tablets as a standard
    3-axis input device.
    
    Signed-off-by: Andy Ross <andy.ross@windriver.com>
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 8327d06b6e8a..613762d825f9 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -193,6 +193,14 @@ MODULE_PARM_DESC(als_status, "Set the ALS status on boot "
 #define PEGA_READ_ALS_H	0x02
 #define PEGA_READ_ALS_L	0x03
 
+#define PEGA_ACCEL_NAME "pega_accel"
+#define PEGA_ACCEL_DESC "Pegatron Lucid Tablet Accelerometer"
+#define METHOD_XLRX "XLRX"
+#define METHOD_XLRY "XLRY"
+#define METHOD_XLRZ "XLRZ"
+#define PEGA_ACC_CLAMP 512 /* 1G accel is reported as ~256, so clamp to 2G */
+#define PEGA_ACC_RETRIES 3
+
 /*
  * Define a specific led structure to keep the main structure clean
  */
@@ -218,6 +226,7 @@ struct asus_laptop {
 
 	struct input_dev *inputdev;
 	struct key_entry *keymap;
+	struct input_polled_dev *pega_accel_poll;
 
 	struct asus_led mled;
 	struct asus_led tled;
@@ -230,6 +239,10 @@ struct asus_laptop {
 	int wireless_status;
 	bool have_rsts;
 	bool is_pega_lucid;
+	bool pega_acc_live;
+	int pega_acc_x;
+	int pega_acc_y;
+	int pega_acc_z;
 
 	struct rfkill *gps_rfkill;
 
@@ -358,6 +371,113 @@ static int asus_pega_lucid_set(struct asus_laptop *asus, int unit, bool enable)
 	return write_acpi_int(asus->handle, method, unit);
 }
 
+static int pega_acc_axis(struct asus_laptop *asus, int curr, char *method)
+{
+	int i, delta;
+	unsigned long long val;
+	for (i = 0; i < PEGA_ACC_RETRIES; i++) {
+		acpi_evaluate_integer(asus->handle, method, NULL, &val);
+
+		/* The output is noisy.  From reading the ASL
+		 * dissassembly, timeout errors are returned with 1's
+		 * in the high word, and the lack of locking around
+		 * thei hi/lo byte reads means that a transition
+		 * between (for example) -1 and 0 could be read as
+		 * 0xff00 or 0x00ff. */
+		delta = abs(curr - (short)val);
+		if (delta < 128 && !(val & ~0xffff))
+			break;
+	}
+	return clamp_val((short)val, -PEGA_ACC_CLAMP, PEGA_ACC_CLAMP);
+}
+
+static void pega_accel_poll(struct input_polled_dev *ipd)
+{
+	struct device *parent = ipd->input->dev.parent;
+	struct asus_laptop *asus = dev_get_drvdata(parent);
+
+	/* In some cases, the very first call to poll causes a
+	 * recursive fault under the polldev worker.  This is
+	 * apparently related to very early userspace access to the
+	 * device, and perhaps a firmware bug. Fake the first report. */
+	if (!asus->pega_acc_live) {
+		asus->pega_acc_live = true;
+		input_report_abs(ipd->input, ABS_X, 0);
+		input_report_abs(ipd->input, ABS_Y, 0);
+		input_report_abs(ipd->input, ABS_Z, 0);
+		input_sync(ipd->input);
+		return;
+	}
+
+	asus->pega_acc_x = pega_acc_axis(asus, asus->pega_acc_x, METHOD_XLRX);
+	asus->pega_acc_y = pega_acc_axis(asus, asus->pega_acc_y, METHOD_XLRY);
+	asus->pega_acc_z = pega_acc_axis(asus, asus->pega_acc_z, METHOD_XLRZ);
+
+	/* Note transform, convert to "right/up/out" in the native
+	 * landscape orientation (i.e. the vector is the direction of
+	 * "real up" in the device's cartiesian coordinates). */
+	input_report_abs(ipd->input, ABS_X, -asus->pega_acc_x);
+	input_report_abs(ipd->input, ABS_Y, -asus->pega_acc_y);
+	input_report_abs(ipd->input, ABS_Z,  asus->pega_acc_z);
+	input_sync(ipd->input);
+}
+
+static void pega_accel_exit(struct asus_laptop *asus)
+{
+	if (asus->pega_accel_poll) {
+		input_unregister_polled_device(asus->pega_accel_poll);
+		input_free_polled_device(asus->pega_accel_poll);
+	}
+	asus->pega_accel_poll = NULL;
+}
+
+static int pega_accel_init(struct asus_laptop *asus)
+{
+	int err;
+	struct input_polled_dev *ipd;
+
+	if (!asus->is_pega_lucid)
+		return -ENODEV;
+
+	if (acpi_check_handle(asus->handle, METHOD_XLRX, NULL) ||
+	    acpi_check_handle(asus->handle, METHOD_XLRY, NULL) ||
+	    acpi_check_handle(asus->handle, METHOD_XLRZ, NULL))
+		return -ENODEV;
+
+	ipd = input_allocate_polled_device();
+	if (!ipd)
+		return -ENOMEM;
+
+	ipd->poll = pega_accel_poll;
+	ipd->poll_interval = 125;
+	ipd->poll_interval_min = 50;
+	ipd->poll_interval_max = 2000;
+
+	ipd->input->name = PEGA_ACCEL_DESC;
+	ipd->input->phys = PEGA_ACCEL_NAME "/input0";
+	ipd->input->dev.parent = &asus->platform_device->dev;
+	ipd->input->id.bustype = BUS_HOST;
+
+	set_bit(EV_ABS, ipd->input->evbit);
+	input_set_abs_params(ipd->input, ABS_X,
+			     -PEGA_ACC_CLAMP, PEGA_ACC_CLAMP, 0, 0);
+	input_set_abs_params(ipd->input, ABS_Y,
+			     -PEGA_ACC_CLAMP, PEGA_ACC_CLAMP, 0, 0);
+	input_set_abs_params(ipd->input, ABS_Z,
+			     -PEGA_ACC_CLAMP, PEGA_ACC_CLAMP, 0, 0);
+
+	err = input_register_polled_device(ipd);
+	if (err)
+		goto exit;
+
+	asus->pega_accel_poll = ipd;
+	return 0;
+
+exit:
+	input_free_polled_device(ipd);
+	return err;
+}
+
 /* Generic LED function */
 static int asus_led_set(struct asus_laptop *asus, const char *method,
 			 int value)
@@ -1348,7 +1468,7 @@ static struct platform_driver platform_driver = {
 	.driver = {
 		.name = ASUS_LAPTOP_FILE,
 		.owner = THIS_MODULE,
-	}
+	},
 };
 
 /*
@@ -1558,9 +1678,15 @@ static int __devinit asus_acpi_add(struct acpi_device *device)
 	if (result)
 		goto fail_rfkill;
 
+	result = pega_accel_init(asus);
+	if (result && result != -ENODEV)
+		goto fail_pega_accel;
+
 	asus_device_present = true;
 	return 0;
 
+fail_pega_accel:
+	asus_rfkill_exit(asus);
 fail_rfkill:
 	asus_led_exit(asus);
 fail_led:
@@ -1584,6 +1710,7 @@ static int asus_acpi_remove(struct acpi_device *device, int type)
 	asus_rfkill_exit(asus);
 	asus_led_exit(asus);
 	asus_input_exit(asus);
+	pega_accel_exit(asus);
 	asus_platform_exit(asus);
 
 	kfree(asus->name);

commit abec04dbc3dbe7577ccd9d5d6e188aa153d464eb
Author: Andy Ross <andy.ross@windriver.com>
Date:   Fri Oct 14 11:13:37 2011 +0200

    asus-laptop: allow boot time control of Pegatron ALS sensor
    
    Signed-off-by: Andy Ross <andy.ross@windriver.com>
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 10b0a8663bb7..8327d06b6e8a 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -85,6 +85,7 @@ static int wlan_status = 1;
 static int bluetooth_status = 1;
 static int wimax_status = -1;
 static int wwan_status = -1;
+static int als_status;
 
 module_param(wlan_status, int, 0444);
 MODULE_PARM_DESC(wlan_status, "Set the wireless status on boot "
@@ -106,6 +107,11 @@ MODULE_PARM_DESC(wwan_status, "Set the wireless status on boot "
 		 "(0 = disabled, 1 = enabled, -1 = don't do anything). "
 		 "default is 1");
 
+module_param(als_status, int, 0444);
+MODULE_PARM_DESC(als_status, "Set the ALS status on boot "
+		 "(0 = disabled, 1 = enabled). "
+		 "default is 0");
+
 /*
  * Some events we use, same for all Asus
  */
@@ -1472,7 +1478,7 @@ static int __devinit asus_acpi_init(struct asus_laptop *asus)
 	asus->ledd_status = 0xFFF;
 
 	/* Set initial values of light sensor and level */
-	asus->light_switch = 0;	/* Default to light sensor disabled */
+	asus->light_switch = !!als_status;
 	asus->light_level = 5;	/* level 5 for sensor sensitivity */
 
 	if (asus->is_pega_lucid) {

commit 8fcf71aa0032acbd30b3222f9cb238919ab3b984
Author: Axel Lin <axel.lin@gmail.com>
Date:   Mon Aug 8 17:17:18 2011 +0800

    platform-drivers-x86: asus-laptop: fix wrong test for successful registered led_classdev
    
    device_create returns &struct device pointer on success, or ERR_PTR() on error.
    Thus if led_classdev_register fails, led_cdev->dev is always not NULL.
    
    Thus to unregister a successful registered led_classdev, we should check
    IS_ERR_OR_NULL macro for led_cdev->dev instead of checking if led_cdev->dev
    is NULL or not.
    
    we use IS_ERR_OR_NULL instead of IS_ERR because if we havn't call
    led_classdev_register, the led_cdev->dev is NULL.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Acked-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index afed9ff33b86..10b0a8663bb7 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -459,17 +459,17 @@ static enum led_brightness asus_kled_cdev_get(struct led_classdev *led_cdev)
 
 static void asus_led_exit(struct asus_laptop *asus)
 {
-	if (asus->mled.led.dev)
+	if (!IS_ERR_OR_NULL(asus->mled.led.dev))
 		led_classdev_unregister(&asus->mled.led);
-	if (asus->tled.led.dev)
+	if (!IS_ERR_OR_NULL(asus->tled.led.dev))
 		led_classdev_unregister(&asus->tled.led);
-	if (asus->pled.led.dev)
+	if (!IS_ERR_OR_NULL(asus->pled.led.dev))
 		led_classdev_unregister(&asus->pled.led);
-	if (asus->rled.led.dev)
+	if (!IS_ERR_OR_NULL(asus->rled.led.dev))
 		led_classdev_unregister(&asus->rled.led);
-	if (asus->gled.led.dev)
+	if (!IS_ERR_OR_NULL(asus->gled.led.dev))
 		led_classdev_unregister(&asus->gled.led);
-	if (asus->kled.led.dev)
+	if (!IS_ERR_OR_NULL(asus->kled.led.dev))
 		led_classdev_unregister(&asus->kled.led);
 	if (asus->led_workqueue) {
 		destroy_workqueue(asus->led_workqueue);

commit 33989ba6f7feb3d03916e42d7775d802d2fdea1e
Author: Andy Ross <andy.ross@windriver.com>
Date:   Fri Oct 14 11:13:36 2011 +0200

    asus-laptop: Pegatron Lucid ALS sensor
    
    Ambient light sensor for Pegatron Lucid.  Supports pre-existing
    ls_switch sysfs interface to en/disable automatic control, and exports
    the brightness from the device as "ls_value".
    
    Signed-off-by: Andy Ross <andy.ross@windriver.com>
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index c08f4c26b988..afed9ff33b86 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -177,9 +177,15 @@ MODULE_PARM_DESC(wwan_status, "Set the wireless status on boot "
 
 /* For Pegatron Lucid tablet */
 #define DEVICE_NAME_PEGA	"Lucid"
+
 #define METHOD_PEGA_ENABLE	"ENPR"
 #define METHOD_PEGA_DISABLE	"DAPR"
+#define PEGA_ALS	0x04
+#define PEGA_ALS_POWER	0x05
+
 #define METHOD_PEGA_READ	"RDLN"
+#define PEGA_READ_ALS_H	0x02
+#define PEGA_READ_ALS_L	0x03
 
 /*
  * Define a specific led structure to keep the main structure clean
@@ -340,6 +346,12 @@ static bool asus_check_pega_lucid(struct asus_laptop *asus)
 	   !acpi_check_handle(asus->handle, METHOD_PEGA_READ, NULL);
 }
 
+static int asus_pega_lucid_set(struct asus_laptop *asus, int unit, bool enable)
+{
+	char *method = enable ? METHOD_PEGA_ENABLE : METHOD_PEGA_DISABLE;
+	return write_acpi_int(asus->handle, method, unit);
+}
+
 /* Generic LED function */
 static int asus_led_set(struct asus_laptop *asus, const char *method,
 			 int value)
@@ -924,8 +936,18 @@ static ssize_t store_disp(struct device *dev, struct device_attribute *attr,
  */
 static void asus_als_switch(struct asus_laptop *asus, int value)
 {
-	if (write_acpi_int(asus->handle, METHOD_ALS_CONTROL, value))
-		pr_warn("Error setting light sensor switch\n");
+	int ret;
+
+	if (asus->is_pega_lucid) {
+		ret = asus_pega_lucid_set(asus, PEGA_ALS, value);
+		if (!ret)
+			ret = asus_pega_lucid_set(asus, PEGA_ALS_POWER, value);
+	} else {
+		ret = write_acpi_int(asus->handle, METHOD_ALS_CONTROL, value);
+	}
+	if (ret)
+		pr_warning("Error setting light sensor switch\n");
+
 	asus->light_switch = value;
 }
 
@@ -981,6 +1003,35 @@ static ssize_t store_lslvl(struct device *dev, struct device_attribute *attr,
 	return rv;
 }
 
+static int pega_int_read(struct asus_laptop *asus, int arg, int *result)
+{
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	int err = write_acpi_int_ret(asus->handle, METHOD_PEGA_READ, arg,
+				     &buffer);
+	if (!err) {
+		union acpi_object *obj = buffer.pointer;
+		if (obj && obj->type == ACPI_TYPE_INTEGER)
+			*result = obj->integer.value;
+		else
+			err = -EIO;
+	}
+	return err;
+}
+
+static ssize_t show_lsvalue(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	struct asus_laptop *asus = dev_get_drvdata(dev);
+	int err, hi, lo;
+
+	err = pega_int_read(asus, PEGA_READ_ALS_H, &hi);
+	if (!err)
+		err = pega_int_read(asus, PEGA_READ_ALS_L, &lo);
+	if (!err)
+		return sprintf(buf, "%d\n", 10 * hi + lo);
+	return err;
+}
+
 /*
  * GPS
  */
@@ -1169,6 +1220,7 @@ static DEVICE_ATTR(wimax, S_IRUGO | S_IWUSR, show_wimax, store_wimax);
 static DEVICE_ATTR(wwan, S_IRUGO | S_IWUSR, show_wwan, store_wwan);
 static DEVICE_ATTR(display, S_IWUSR, NULL, store_disp);
 static DEVICE_ATTR(ledd, S_IRUGO | S_IWUSR, show_ledd, store_ledd);
+static DEVICE_ATTR(ls_value, S_IRUGO, show_lsvalue, NULL);
 static DEVICE_ATTR(ls_level, S_IRUGO | S_IWUSR, show_lslvl, store_lslvl);
 static DEVICE_ATTR(ls_switch, S_IRUGO | S_IWUSR, show_lssw, store_lssw);
 static DEVICE_ATTR(gps, S_IRUGO | S_IWUSR, show_gps, store_gps);
@@ -1181,6 +1233,7 @@ static struct attribute *asus_attributes[] = {
 	&dev_attr_wwan.attr,
 	&dev_attr_display.attr,
 	&dev_attr_ledd.attr,
+	&dev_attr_ls_value.attr,
 	&dev_attr_ls_level.attr,
 	&dev_attr_ls_switch.attr,
 	&dev_attr_gps.attr,
@@ -1197,6 +1250,19 @@ static mode_t asus_sysfs_is_visible(struct kobject *kobj,
 	acpi_handle handle = asus->handle;
 	bool supported;
 
+	if (asus->is_pega_lucid) {
+		/* no ls_level interface on the Lucid */
+		if (attr == &dev_attr_ls_switch.attr)
+			supported = true;
+		else if (attr == &dev_attr_ls_level.attr)
+			supported = false;
+		else
+			goto normal;
+
+		return supported;
+	}
+
+normal:
 	if (attr == &dev_attr_wlan.attr) {
 		supported = !acpi_check_handle(handle, METHOD_WLAN, NULL);
 
@@ -1219,7 +1285,9 @@ static mode_t asus_sysfs_is_visible(struct kobject *kobj,
 	} else if (attr == &dev_attr_ls_switch.attr ||
 		   attr == &dev_attr_ls_level.attr) {
 		supported = !acpi_check_handle(handle, METHOD_ALS_CONTROL, NULL) &&
-			    !acpi_check_handle(handle, METHOD_ALS_LEVEL, NULL);
+			!acpi_check_handle(handle, METHOD_ALS_LEVEL, NULL);
+	} else if (attr == &dev_attr_ls_value.attr) {
+		supported = asus->is_pega_lucid;
 	} else if (attr == &dev_attr_gps.attr) {
 		supported = !acpi_check_handle(handle, METHOD_GPS_ON, NULL) &&
 			    !acpi_check_handle(handle, METHOD_GPS_OFF, NULL) &&
@@ -1407,8 +1475,10 @@ static int __devinit asus_acpi_init(struct asus_laptop *asus)
 	asus->light_switch = 0;	/* Default to light sensor disabled */
 	asus->light_level = 5;	/* level 5 for sensor sensitivity */
 
-	if (!acpi_check_handle(asus->handle, METHOD_ALS_CONTROL, NULL) &&
-	    !acpi_check_handle(asus->handle, METHOD_ALS_LEVEL, NULL)) {
+	if (asus->is_pega_lucid) {
+		asus_als_switch(asus, asus->light_switch);
+	} else if (!acpi_check_handle(asus->handle, METHOD_ALS_CONTROL, NULL) &&
+		   !acpi_check_handle(asus->handle, METHOD_ALS_LEVEL, NULL)) {
 		asus_als_switch(asus, asus->light_switch);
 		asus_als_level(asus, asus->light_level);
 	}

commit 8819de7f988289111cf4c44946f0d8c008b2d9a7
Author: Andy Ross <andy.ross@windriver.com>
Date:   Fri Oct 14 11:13:35 2011 +0200

    asus-laptop: Platform detection for Pegatron Lucid
    
    Recognize the Pegatron Lucid tablets by their method signatures.
    
    Signed-off-by: Andy Ross <andy.ross@windriver.com>
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index fa6d7ec68b26..c08f4c26b988 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -4,6 +4,7 @@
  *
  *  Copyright (C) 2002-2005 Julien Lerouge, 2003-2006 Karol Kozimor
  *  Copyright (C) 2006-2007 Corentin Chary
+ *  Copyright (C) 2011 Wind River Systems
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -48,6 +49,7 @@
 #include <linux/uaccess.h>
 #include <linux/input.h>
 #include <linux/input/sparse-keymap.h>
+#include <linux/input-polldev.h>
 #include <linux/rfkill.h>
 #include <linux/slab.h>
 #include <linux/dmi.h>
@@ -173,6 +175,12 @@ MODULE_PARM_DESC(wwan_status, "Set the wireless status on boot "
 #define METHOD_KBD_LIGHT_SET	"SLKB"
 #define METHOD_KBD_LIGHT_GET	"GLKB"
 
+/* For Pegatron Lucid tablet */
+#define DEVICE_NAME_PEGA	"Lucid"
+#define METHOD_PEGA_ENABLE	"ENPR"
+#define METHOD_PEGA_DISABLE	"DAPR"
+#define METHOD_PEGA_READ	"RDLN"
+
 /*
  * Define a specific led structure to keep the main structure clean
  */
@@ -209,6 +217,7 @@ struct asus_laptop {
 
 	int wireless_status;
 	bool have_rsts;
+	bool is_pega_lucid;
 
 	struct rfkill *gps_rfkill;
 
@@ -323,6 +332,14 @@ static int acpi_check_handle(acpi_handle handle, const char *method,
 	return 0;
 }
 
+static bool asus_check_pega_lucid(struct asus_laptop *asus)
+{
+	return !strcmp(asus->name, DEVICE_NAME_PEGA) &&
+	   !acpi_check_handle(asus->handle, METHOD_PEGA_ENABLE, NULL) &&
+	   !acpi_check_handle(asus->handle, METHOD_PEGA_DISABLE, NULL) &&
+	   !acpi_check_handle(asus->handle, METHOD_PEGA_READ, NULL);
+}
+
 /* Generic LED function */
 static int asus_led_set(struct asus_laptop *asus, const char *method,
 			 int value)
@@ -1203,7 +1220,6 @@ static mode_t asus_sysfs_is_visible(struct kobject *kobj,
 		   attr == &dev_attr_ls_level.attr) {
 		supported = !acpi_check_handle(handle, METHOD_ALS_CONTROL, NULL) &&
 			    !acpi_check_handle(handle, METHOD_ALS_LEVEL, NULL);
-
 	} else if (attr == &dev_attr_gps.attr) {
 		supported = !acpi_check_handle(handle, METHOD_GPS_ON, NULL) &&
 			    !acpi_check_handle(handle, METHOD_GPS_OFF, NULL) &&
@@ -1439,9 +1455,10 @@ static int __devinit asus_acpi_add(struct acpi_device *device)
 		goto fail_platform;
 
 	/*
-	 * Register the platform device first.  It is used as a parent for the
-	 * sub-devices below.
+	 * Need platform type detection first, then the platform
+	 * device.  It is used as a parent for the sub-devices below.
 	 */
+	asus->is_pega_lucid = asus_check_pega_lucid(asus);
 	result = asus_platform_init(asus);
 	if (result)
 		goto fail_platform;

commit fddbfed595b307f9dddc7a86ddfbcbcb80141e28
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Fri Jul 1 11:34:39 2011 +0200

    asus-wmi: add CWAP support and clarify the meaning of WAPF bits
    
    ref: http://dev.iksaif.net/projects/3/wiki/Asus-laptop_WAPF
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index d65df92e2acc..fa6d7ec68b26 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -70,11 +70,10 @@ MODULE_LICENSE("GPL");
  * WAPF defines the behavior of the Fn+Fx wlan key
  * The significance of values is yet to be found, but
  * most of the time:
- * 0x0 will do nothing
- * 0x1 will allow to control the device with Fn+Fx key.
- * 0x4 will send an ACPI event (0x88) while pressing the Fn+Fx key
- * 0x5 like 0x1 or 0x4
- * So, if something doesn't work as you want, just try other values =)
+ * Bit | Bluetooth | WLAN
+ *  0  | Hardware  | Hardware
+ *  1  | Hardware  | Software
+ *  4  | Software  | Software
  */
 static uint wapf = 1;
 module_param(wapf, uint, 0444);

commit 5ad77dcfb49a85715bcb9174a133cba140eda1bc
Author: Joe Perches <joe@perches.com>
Date:   Tue Mar 29 15:21:35 2011 -0700

    asus: Add pr_fmt and convert printks to pr_<level>
    
    Add pr_fmt, prefixes each log message.
    Convert printks to pr_<level>.
    Convert pr_warning to pr_warn.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index c53b3ff7978a..d65df92e2acc 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -318,7 +318,7 @@ static int acpi_check_handle(acpi_handle handle, const char *method,
 
 	if (status != AE_OK) {
 		if (ret)
-			pr_warning("Error finding %s\n", method);
+			pr_warn("Error finding %s\n", method);
 		return -ENODEV;
 	}
 	return 0;
@@ -383,7 +383,7 @@ static int asus_kled_lvl(struct asus_laptop *asus)
 	rv = acpi_evaluate_integer(asus->handle, METHOD_KBD_LIGHT_GET,
 				   &params, &kblv);
 	if (ACPI_FAILURE(rv)) {
-		pr_warning("Error reading kled level\n");
+		pr_warn("Error reading kled level\n");
 		return -ENODEV;
 	}
 	return kblv;
@@ -397,7 +397,7 @@ static int asus_kled_set(struct asus_laptop *asus, int kblv)
 		kblv = 0;
 
 	if (write_acpi_int(asus->handle, METHOD_KBD_LIGHT_SET, kblv)) {
-		pr_warning("Keyboard LED display write failed\n");
+		pr_warn("Keyboard LED display write failed\n");
 		return -EINVAL;
 	}
 	return 0;
@@ -531,7 +531,7 @@ static int asus_read_brightness(struct backlight_device *bd)
 	rv = acpi_evaluate_integer(asus->handle, METHOD_BRIGHTNESS_GET,
 				   NULL, &value);
 	if (ACPI_FAILURE(rv))
-		pr_warning("Error reading brightness\n");
+		pr_warn("Error reading brightness\n");
 
 	return value;
 }
@@ -541,7 +541,7 @@ static int asus_set_brightness(struct backlight_device *bd, int value)
 	struct asus_laptop *asus = bl_get_data(bd);
 
 	if (write_acpi_int(asus->handle, METHOD_BRIGHTNESS_SET, value)) {
-		pr_warning("Error changing brightness\n");
+		pr_warn("Error changing brightness\n");
 		return -EIO;
 	}
 	return 0;
@@ -730,7 +730,7 @@ static ssize_t store_ledd(struct device *dev, struct device_attribute *attr,
 	rv = parse_arg(buf, count, &value);
 	if (rv > 0) {
 		if (write_acpi_int(asus->handle, METHOD_LEDD, value)) {
-			pr_warning("LED display write failed\n");
+			pr_warn("LED display write failed\n");
 			return -ENODEV;
 		}
 		asus->ledd_status = (u32) value;
@@ -752,7 +752,7 @@ static int asus_wireless_status(struct asus_laptop *asus, int mask)
 	rv = acpi_evaluate_integer(asus->handle, METHOD_WL_STATUS,
 				   NULL, &status);
 	if (ACPI_FAILURE(rv)) {
-		pr_warning("Error reading Wireless status\n");
+		pr_warn("Error reading Wireless status\n");
 		return -EINVAL;
 	}
 	return !!(status & mask);
@@ -764,7 +764,7 @@ static int asus_wireless_status(struct asus_laptop *asus, int mask)
 static int asus_wlan_set(struct asus_laptop *asus, int status)
 {
 	if (write_acpi_int(asus->handle, METHOD_WLAN, !!status)) {
-		pr_warning("Error setting wlan status to %d", status);
+		pr_warn("Error setting wlan status to %d\n", status);
 		return -EIO;
 	}
 	return 0;
@@ -792,7 +792,7 @@ static ssize_t store_wlan(struct device *dev, struct device_attribute *attr,
 static int asus_bluetooth_set(struct asus_laptop *asus, int status)
 {
 	if (write_acpi_int(asus->handle, METHOD_BLUETOOTH, !!status)) {
-		pr_warning("Error setting bluetooth status to %d", status);
+		pr_warn("Error setting bluetooth status to %d\n", status);
 		return -EIO;
 	}
 	return 0;
@@ -821,7 +821,7 @@ static ssize_t store_bluetooth(struct device *dev,
 static int asus_wimax_set(struct asus_laptop *asus, int status)
 {
 	if (write_acpi_int(asus->handle, METHOD_WIMAX, !!status)) {
-		pr_warning("Error setting wimax status to %d", status);
+		pr_warn("Error setting wimax status to %d\n", status);
 		return -EIO;
 	}
 	return 0;
@@ -850,7 +850,7 @@ static ssize_t store_wimax(struct device *dev,
 static int asus_wwan_set(struct asus_laptop *asus, int status)
 {
 	if (write_acpi_int(asus->handle, METHOD_WWAN, !!status)) {
-		pr_warning("Error setting wwan status to %d", status);
+		pr_warn("Error setting wwan status to %d\n", status);
 		return -EIO;
 	}
 	return 0;
@@ -880,7 +880,7 @@ static void asus_set_display(struct asus_laptop *asus, int value)
 {
 	/* no sanity check needed for now */
 	if (write_acpi_int(asus->handle, METHOD_SWITCH_DISPLAY, value))
-		pr_warning("Error setting display\n");
+		pr_warn("Error setting display\n");
 	return;
 }
 
@@ -909,7 +909,7 @@ static ssize_t store_disp(struct device *dev, struct device_attribute *attr,
 static void asus_als_switch(struct asus_laptop *asus, int value)
 {
 	if (write_acpi_int(asus->handle, METHOD_ALS_CONTROL, value))
-		pr_warning("Error setting light sensor switch\n");
+		pr_warn("Error setting light sensor switch\n");
 	asus->light_switch = value;
 }
 
@@ -937,7 +937,7 @@ static ssize_t store_lssw(struct device *dev, struct device_attribute *attr,
 static void asus_als_level(struct asus_laptop *asus, int value)
 {
 	if (write_acpi_int(asus->handle, METHOD_ALS_LEVEL, value))
-		pr_warning("Error setting light sensor level\n");
+		pr_warn("Error setting light sensor level\n");
 	asus->light_level = value;
 }
 
@@ -976,7 +976,7 @@ static int asus_gps_status(struct asus_laptop *asus)
 	rv = acpi_evaluate_integer(asus->handle, METHOD_GPS_STATUS,
 				   NULL, &status);
 	if (ACPI_FAILURE(rv)) {
-		pr_warning("Error reading GPS status\n");
+		pr_warn("Error reading GPS status\n");
 		return -ENODEV;
 	}
 	return !!status;
@@ -1284,7 +1284,7 @@ static int asus_laptop_get_info(struct asus_laptop *asus)
 	 */
 	status = acpi_get_table(ACPI_SIG_DSDT, 1, &asus->dsdt_info);
 	if (ACPI_FAILURE(status))
-		pr_warning("Couldn't get the DSDT table header\n");
+		pr_warn("Couldn't get the DSDT table header\n");
 
 	/* We have to write 0 on init this far for all ASUS models */
 	if (write_acpi_int_ret(asus->handle, "INIT", 0, &buffer)) {
@@ -1296,7 +1296,7 @@ static int asus_laptop_get_info(struct asus_laptop *asus)
 	status =
 	    acpi_evaluate_integer(asus->handle, "BSTS", NULL, &bsts_result);
 	if (ACPI_FAILURE(status))
-		pr_warning("Error calling BSTS\n");
+		pr_warn("Error calling BSTS\n");
 	else if (bsts_result)
 		pr_notice("BSTS called, 0x%02x returned\n",
 		       (uint) bsts_result);

commit c8440336fe376036e473554c30f7266987961734
Author: Lucas De Marchi <lucas.de.marchi@gmail.com>
Date:   Thu Mar 17 17:18:22 2011 -0300

    platform-drivers: x86: fix common misspellings
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 62ef43ef06d2..c53b3ff7978a 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -29,7 +29,7 @@
  *  John Belmonte  - ACPI code for Toshiba laptop was a good starting point.
  *  Eric Burghard  - LED display support for W1N
  *  Josh Green     - Light Sens support
- *  Thomas Tuttle  - His first patch for led support was very helpfull
+ *  Thomas Tuttle  - His first patch for led support was very helpful
  *  Sam Lin        - GPS support
  */
 

commit 3b81cf9d558c57406b4ed9b0d2639113d1d428b6
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Sun Feb 6 13:27:31 2011 +0100

    asus-laptop: remove deprecated interfaces (lcd_switch and display_get)
    
    I should have done that one year ago, so it's more than
    time to do it.
    
    These two features use non-standard interfaces. There are the
    only features that really need multiple path to guess what's
    the right method name on a specific laptop.
    
    Removing them allow to remove a lot of code an significantly
    clean the driver.
    
    This will affect the backlight code which won't be able to know
    if the backlight is on or off.
    
    The platform display file will also be write only (like the one
    in eeepc-laptop).
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 2b9d7b8636e3..62ef43ef06d2 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -158,46 +158,9 @@ MODULE_PARM_DESC(wwan_status, "Set the wireless status on boot "
 #define METHOD_BRIGHTNESS_SET	"SPLV"
 #define METHOD_BRIGHTNESS_GET	"GPLV"
 
-/* Backlight */
-static acpi_handle lcd_switch_handle;
-static char *lcd_switch_paths[] = {
-  "\\_SB.PCI0.SBRG.EC0._Q10",	/* All new models */
-  "\\_SB.PCI0.ISA.EC0._Q10",	/* A1x */
-  "\\_SB.PCI0.PX40.ECD0._Q10",	/* L3C */
-  "\\_SB.PCI0.PX40.EC0.Q10",	/* M1A */
-  "\\_SB.PCI0.LPCB.EC0._Q10",	/* P30 */
-  "\\_SB.PCI0.LPCB.EC0._Q0E", /* P30/P35 */
-  "\\_SB.PCI0.PX40.Q10",	/* S1x */
-  "\\Q10"};		/* A2x, L2D, L3D, M2E */
-
 /* Display */
 #define METHOD_SWITCH_DISPLAY	"SDSP"
 
-static acpi_handle display_get_handle;
-static char *display_get_paths[] = {
-  /* A6B, A6K A6R A7D F3JM L4R M6R A3G M6A M6V VX-1 V6J V6V W3Z */
-  "\\_SB.PCI0.P0P1.VGA.GETD",
-  /* A3E A4K, A4D A4L A6J A7J A8J Z71V M9V S5A M5A z33A W1Jc W2V G1 */
-  "\\_SB.PCI0.P0P2.VGA.GETD",
-  /* A6V A6Q */
-  "\\_SB.PCI0.P0P3.VGA.GETD",
-  /* A6T, A6M */
-  "\\_SB.PCI0.P0PA.VGA.GETD",
-  /* L3C */
-  "\\_SB.PCI0.PCI1.VGAC.NMAP",
-  /* Z96F */
-  "\\_SB.PCI0.VGA.GETD",
-  /* A2D */
-  "\\ACTD",
-  /* A4G Z71A W1N W5A W5F M2N M3N M5N M6N S1N S5N */
-  "\\ADVG",
-  /* P30 */
-  "\\DNXT",
-  /* A2H D1 L2D L3D L3H L2E L5D L5C M1A M2E L4L W3V */
-  "\\INFB",
-  /* A3F A6F A3N A3L M6N W3N W6A */
-  "\\SSTE"};
-
 #define METHOD_ALS_CONTROL	"ALSC" /* Z71A Z71V */
 #define METHOD_ALS_LEVEL	"ALSL" /* Z71A Z71V */
 
@@ -247,7 +210,6 @@ struct asus_laptop {
 
 	int wireless_status;
 	bool have_rsts;
-	int lcd_state;
 
 	struct rfkill *gps_rfkill;
 
@@ -560,48 +522,6 @@ static int asus_led_init(struct asus_laptop *asus)
 /*
  * Backlight device
  */
-static int asus_lcd_status(struct asus_laptop *asus)
-{
-	return asus->lcd_state;
-}
-
-static int asus_lcd_set(struct asus_laptop *asus, int value)
-{
-	int lcd = 0;
-	acpi_status status = 0;
-
-	lcd = !!value;
-
-	if (lcd == asus_lcd_status(asus))
-		return 0;
-
-	if (!lcd_switch_handle)
-		return -ENODEV;
-
-	status = acpi_evaluate_object(lcd_switch_handle,
-				      NULL, NULL, NULL);
-
-	if (ACPI_FAILURE(status)) {
-		pr_warning("Error switching LCD\n");
-		return -ENODEV;
-	}
-
-	asus->lcd_state = lcd;
-	return 0;
-}
-
-static void lcd_blank(struct asus_laptop *asus, int blank)
-{
-	struct backlight_device *bd = asus->backlight_device;
-
-	asus->lcd_state = (blank == FB_BLANK_UNBLANK);
-
-	if (bd) {
-		bd->props.power = blank;
-		backlight_update_status(bd);
-	}
-}
-
 static int asus_read_brightness(struct backlight_device *bd)
 {
 	struct asus_laptop *asus = bl_get_data(bd);
@@ -629,16 +549,9 @@ static int asus_set_brightness(struct backlight_device *bd, int value)
 
 static int update_bl_status(struct backlight_device *bd)
 {
-	struct asus_laptop *asus = bl_get_data(bd);
-	int rv;
 	int value = bd->props.brightness;
 
-	rv = asus_set_brightness(bd, value);
-	if (rv)
-		return rv;
-
-	value = (bd->props.power == FB_BLANK_UNBLANK) ? 1 : 0;
-	return asus_lcd_set(asus, value);
+	return asus_set_brightness(bd, value);
 }
 
 static const struct backlight_ops asusbl_ops = {
@@ -662,8 +575,7 @@ static int asus_backlight_init(struct asus_laptop *asus)
 	struct backlight_properties props;
 
 	if (acpi_check_handle(asus->handle, METHOD_BRIGHTNESS_GET, NULL) ||
-	    acpi_check_handle(asus->handle, METHOD_BRIGHTNESS_SET, NULL) ||
-	    !lcd_switch_handle)
+	    acpi_check_handle(asus->handle, METHOD_BRIGHTNESS_SET, NULL))
 		return 0;
 
 	memset(&props, 0, sizeof(struct backlight_properties));
@@ -972,41 +884,6 @@ static void asus_set_display(struct asus_laptop *asus, int value)
 	return;
 }
 
-static int read_display(struct asus_laptop *asus)
-{
-	unsigned long long value = 0;
-	acpi_status rv = AE_OK;
-
-	/*
-	 * In most of the case, we know how to set the display, but sometime
-	 * we can't read it
-	 */
-	if (display_get_handle) {
-		rv = acpi_evaluate_integer(display_get_handle, NULL,
-					   NULL, &value);
-		if (ACPI_FAILURE(rv))
-			pr_warning("Error reading display status\n");
-	}
-
-	value &= 0x0F; /* needed for some models, shouldn't hurt others */
-
-	return value;
-}
-
-/*
- * Now, *this* one could be more user-friendly, but so far, no-one has
- * complained. The significance of bits is the same as in store_disp()
- */
-static ssize_t show_disp(struct device *dev,
-			 struct device_attribute *attr, char *buf)
-{
-	struct asus_laptop *asus = dev_get_drvdata(dev);
-
-	if (!display_get_handle)
-		return -ENODEV;
-	return sprintf(buf, "%d\n", read_display(asus));
-}
-
 /*
  * Experimental support for display switching. As of now: 1 should activate
  * the LCD output, 2 should do for CRT, 4 for TV-Out and 8 for DVI.
@@ -1248,15 +1125,6 @@ static void asus_acpi_notify(struct acpi_device *device, u32 event)
 	struct asus_laptop *asus = acpi_driver_data(device);
 	u16 count;
 
-	/*
-	 * We need to tell the backlight device when the backlight power is
-	 * switched
-	 */
-	if (event == ATKD_LCD_ON)
-		lcd_blank(asus, FB_BLANK_UNBLANK);
-	else if (event == ATKD_LCD_OFF)
-		lcd_blank(asus, FB_BLANK_POWERDOWN);
-
 	/* TODO Find a better way to handle events count. */
 	count = asus->event_count[event % 128]++;
 	acpi_bus_generate_proc_event(asus->device, event, count);
@@ -1283,7 +1151,7 @@ static DEVICE_ATTR(bluetooth, S_IRUGO | S_IWUSR,
 		   show_bluetooth, store_bluetooth);
 static DEVICE_ATTR(wimax, S_IRUGO | S_IWUSR, show_wimax, store_wimax);
 static DEVICE_ATTR(wwan, S_IRUGO | S_IWUSR, show_wwan, store_wwan);
-static DEVICE_ATTR(display, S_IRUGO | S_IWUSR, show_disp, store_disp);
+static DEVICE_ATTR(display, S_IWUSR, NULL, store_disp);
 static DEVICE_ATTR(ledd, S_IRUGO | S_IWUSR, show_ledd, store_ledd);
 static DEVICE_ATTR(ls_level, S_IRUGO | S_IWUSR, show_lslvl, store_lslvl);
 static DEVICE_ATTR(ls_switch, S_IRUGO | S_IWUSR, show_lssw, store_lssw);
@@ -1394,26 +1262,6 @@ static struct platform_driver platform_driver = {
 	}
 };
 
-static int asus_handle_init(char *name, acpi_handle * handle,
-			    char **paths, int num_paths)
-{
-	int i;
-	acpi_status status;
-
-	for (i = 0; i < num_paths; i++) {
-		status = acpi_get_handle(NULL, paths[i], handle);
-		if (ACPI_SUCCESS(status))
-			return 0;
-	}
-
-	*handle = NULL;
-	return -ENODEV;
-}
-
-#define ASUS_HANDLE_INIT(object)					\
-	asus_handle_init(#object, &object##_handle, object##_paths,	\
-			 ARRAY_SIZE(object##_paths))
-
 /*
  * This function is used to initialize the context with right values. In this
  * method, we can make all the detection we want, and modify the asus_laptop
@@ -1499,10 +1347,6 @@ static int asus_laptop_get_info(struct asus_laptop *asus)
 	if (!acpi_check_handle(asus->handle, METHOD_WL_STATUS, NULL))
 		asus->have_rsts = true;
 
-	/* Scheduled for removal */
-	ASUS_HANDLE_INIT(lcd_switch);
-	ASUS_HANDLE_INIT(display_get);
-
 	kfree(model);
 
 	return AE_OK;
@@ -1554,7 +1398,6 @@ static int __devinit asus_acpi_init(struct asus_laptop *asus)
 		asus_als_level(asus, asus->light_level);
 	}
 
-	asus->lcd_state = 1; /* LCD should be on when the module load */
 	return result;
 }
 

commit af96f87703f33a4dba4b51c7b3f0d6f874aa4853
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Sun Feb 6 13:27:30 2011 +0100

    asus-laptop: let WLED alone on L1400B
    
    Asus took the DSDT from another model (L84F), made some change
    to make it work, but forgot to remove WLED method (the laptop
    doesn't have a wireless card). They even didn't change the model
    name.
    
    ref: https://bugzilla.kernel.org/show_bug.cgi?id=25712
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 5a6f7d7575d6..2b9d7b8636e3 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -50,6 +50,7 @@
 #include <linux/input/sparse-keymap.h>
 #include <linux/rfkill.h>
 #include <linux/slab.h>
+#include <linux/dmi.h>
 #include <acpi/acpi_drivers.h>
 #include <acpi/acpi_bus.h>
 
@@ -1557,6 +1558,20 @@ static int __devinit asus_acpi_init(struct asus_laptop *asus)
 	return result;
 }
 
+static void __devinit asus_dmi_check(void)
+{
+	const char *model;
+
+	model = dmi_get_system_info(DMI_PRODUCT_NAME);
+	if (!model)
+		return;
+
+	/* On L1400B WLED control the sound card, don't mess with it ... */
+	if (strncmp(model, "L1400B", 6) == 0) {
+		wlan_status = -1;
+	}
+}
+
 static bool asus_device_present;
 
 static int __devinit asus_acpi_add(struct acpi_device *device)
@@ -1575,6 +1590,8 @@ static int __devinit asus_acpi_add(struct acpi_device *device)
 	device->driver_data = asus;
 	asus->device = device;
 
+	asus_dmi_check();
+
 	result = asus_acpi_init(asus);
 	if (result)
 		goto fail_platform;

commit bb7ca747f8d6243b3943c5b133048652020f4a50
Author: Matthew Garrett <mjg@redhat.com>
Date:   Tue Mar 22 16:30:21 2011 -0700

    backlight: add backlight type
    
    There may be multiple ways of controlling the backlight on a given
    machine.  Allow drivers to expose the type of interface they are
    providing, making it possible for userspace to make appropriate policy
    decisions.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Alex Deucher <alexdeucher@gmail.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index f3aa6a7fdab6..5a6f7d7575d6 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -667,6 +667,7 @@ static int asus_backlight_init(struct asus_laptop *asus)
 
 	memset(&props, 0, sizeof(struct backlight_properties));
 	props.max_brightness = 15;
+	props.type = BACKLIGHT_PLATFORM;
 
 	bd = backlight_device_register(ASUS_LAPTOP_FILE,
 				       &asus->platform_device->dev, asus,

commit 4b7bd364700d9ac8372eff48832062b936d0793b
Merge: c0d8768af260 90a8a73c06cc
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Wed Dec 22 18:57:02 2010 +0100

    Merge branch 'master' into for-next
    
    Conflicts:
            MAINTAINERS
            arch/arm/mach-omap2/pm24xx.c
            drivers/scsi/bfa/bfa_fcpim.c
    
    Needed to update to apply fixes for which the old branch was too
    outdated.

commit ba1ff5be52163a97ac4ce8bc51beae2c96861a43
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sun Nov 14 17:40:12 2010 +0100

    asus-laptop: add wimax and wwan support
    
    Asus UL30A has a 3G chip, but the radio is disabled by default.
    The DSDT also reference a WIMAX device, which is not present on this model.
    
    This patch adds two new files: wwan and wimax to control WWAN and
    WIMAX devices. It does not use rfkill, because like WLED and BLED,
    we don't know yet that the two ACPI functions will always control the
    radio, they may control only the leds on some hardware.
    
    We may add rfkill switchs later.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 60a5a5c6b50a..d235f44fd7a3 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -81,6 +81,8 @@ MODULE_PARM_DESC(wapf, "WAPF value");
 
 static int wlan_status = 1;
 static int bluetooth_status = 1;
+static int wimax_status = -1;
+static int wwan_status = -1;
 
 module_param(wlan_status, int, 0444);
 MODULE_PARM_DESC(wlan_status, "Set the wireless status on boot "
@@ -92,6 +94,16 @@ MODULE_PARM_DESC(bluetooth_status, "Set the wireless status on boot "
 		 "(0 = disabled, 1 = enabled, -1 = don't do anything). "
 		 "default is 1");
 
+module_param(wimax_status, int, 0444);
+MODULE_PARM_DESC(wimax_status, "Set the wireless status on boot "
+		 "(0 = disabled, 1 = enabled, -1 = don't do anything). "
+		 "default is 1");
+
+module_param(wwan_status, int, 0444);
+MODULE_PARM_DESC(wwan_status, "Set the wireless status on boot "
+		 "(0 = disabled, 1 = enabled, -1 = don't do anything). "
+		 "default is 1");
+
 /*
  * Some events we use, same for all Asus
  */
@@ -114,6 +126,8 @@ MODULE_PARM_DESC(bluetooth_status, "Set the wireless status on boot "
  */
 #define WL_RSTS		0x01	/* internal Wifi */
 #define BT_RSTS		0x02	/* internal Bluetooth */
+#define WM_RSTS		0x08    /* internal wimax */
+#define WW_RSTS		0x20    /* internal wwan */
 
 /* LED */
 #define METHOD_MLED		"MLED"
@@ -132,6 +146,11 @@ MODULE_PARM_DESC(bluetooth_status, "Set the wireless status on boot "
  */
 #define METHOD_WLAN		"WLED"
 #define METHOD_BLUETOOTH	"BLED"
+
+/* WWAN and WIMAX */
+#define METHOD_WWAN		"GSMC"
+#define METHOD_WIMAX		"WMXC"
+
 #define METHOD_WL_STATUS	"RSTS"
 
 /* Brightness */
@@ -882,6 +901,64 @@ static ssize_t store_bluetooth(struct device *dev,
 	return sysfs_acpi_set(asus, buf, count, METHOD_BLUETOOTH);
 }
 
+/*
+ * Wimax
+ */
+static int asus_wimax_set(struct asus_laptop *asus, int status)
+{
+	if (write_acpi_int(asus->handle, METHOD_WIMAX, !!status)) {
+		pr_warning("Error setting wimax status to %d", status);
+		return -EIO;
+	}
+	return 0;
+}
+
+static ssize_t show_wimax(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	struct asus_laptop *asus = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", asus_wireless_status(asus, WM_RSTS));
+}
+
+static ssize_t store_wimax(struct device *dev,
+			       struct device_attribute *attr, const char *buf,
+			       size_t count)
+{
+	struct asus_laptop *asus = dev_get_drvdata(dev);
+
+	return sysfs_acpi_set(asus, buf, count, METHOD_WIMAX);
+}
+
+/*
+ * Wwan
+ */
+static int asus_wwan_set(struct asus_laptop *asus, int status)
+{
+	if (write_acpi_int(asus->handle, METHOD_WWAN, !!status)) {
+		pr_warning("Error setting wwan status to %d", status);
+		return -EIO;
+	}
+	return 0;
+}
+
+static ssize_t show_wwan(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	struct asus_laptop *asus = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", asus_wireless_status(asus, WW_RSTS));
+}
+
+static ssize_t store_wwan(struct device *dev,
+			       struct device_attribute *attr, const char *buf,
+			       size_t count)
+{
+	struct asus_laptop *asus = dev_get_drvdata(dev);
+
+	return sysfs_acpi_set(asus, buf, count, METHOD_WWAN);
+}
+
 /*
  * Display
  */
@@ -1202,6 +1279,8 @@ static DEVICE_ATTR(infos, S_IRUGO, show_infos, NULL);
 static DEVICE_ATTR(wlan, S_IRUGO | S_IWUSR, show_wlan, store_wlan);
 static DEVICE_ATTR(bluetooth, S_IRUGO | S_IWUSR,
 		   show_bluetooth, store_bluetooth);
+static DEVICE_ATTR(wimax, S_IRUGO | S_IWUSR, show_wimax, store_wimax);
+static DEVICE_ATTR(wwan, S_IRUGO | S_IWUSR, show_wwan, store_wwan);
 static DEVICE_ATTR(display, S_IRUGO | S_IWUSR, show_disp, store_disp);
 static DEVICE_ATTR(ledd, S_IRUGO | S_IWUSR, show_ledd, store_ledd);
 static DEVICE_ATTR(ls_level, S_IRUGO | S_IWUSR, show_lslvl, store_lslvl);
@@ -1212,6 +1291,8 @@ static struct attribute *asus_attributes[] = {
 	&dev_attr_infos.attr,
 	&dev_attr_wlan.attr,
 	&dev_attr_bluetooth.attr,
+	&dev_attr_wimax.attr,
+	&dev_attr_wwan.attr,
 	&dev_attr_display.attr,
 	&dev_attr_ledd.attr,
 	&dev_attr_ls_level.attr,
@@ -1239,6 +1320,13 @@ static mode_t asus_sysfs_is_visible(struct kobject *kobj,
 	} else if (attr == &dev_attr_display.attr) {
 		supported = !acpi_check_handle(handle, METHOD_SWITCH_DISPLAY, NULL);
 
+	} else if (attr == &dev_attr_wimax.attr) {
+		supported =
+			!acpi_check_handle(asus->handle, METHOD_WIMAX, NULL);
+
+	} else if (attr == &dev_attr_wwan.attr) {
+		supported = !acpi_check_handle(asus->handle, METHOD_WWAN, NULL);
+
 	} else if (attr == &dev_attr_ledd.attr) {
 		supported = !acpi_check_handle(handle, METHOD_LEDD, NULL);
 
@@ -1397,7 +1485,8 @@ static int asus_laptop_get_info(struct asus_laptop *asus)
 
 	/*
 	 * The HWRS method return informations about the hardware.
-	 * 0x80 bit is for WLAN, 0x100 for Bluetooth.
+	 * 0x80 bit is for WLAN, 0x100 for Bluetooth,
+	 * 0x40 for WWAN, 0x10 for WIMAX.
 	 * The significance of others is yet to be found.
 	 */
 	status =
@@ -1440,6 +1529,12 @@ static int __devinit asus_acpi_init(struct asus_laptop *asus)
 	if (wlan_status >= 0)
 		asus_wlan_set(asus, !!wlan_status);
 
+	if (wimax_status >= 0)
+		asus_wimax_set(asus, !!wimax_status);
+
+	if (wwan_status >= 0)
+		asus_wwan_set(asus, !!wwan_status);
+
 	/* Keyboard Backlight is on by default */
 	if (!acpi_check_handle(asus->handle, METHOD_KBD_LIGHT_SET, NULL))
 		asus_kled_set(asus, 1);

commit acc2472ed33fc5e72482cc3b3b846077d97c2f8b
Author: Lionel Debroux <lionel_debroux@yahoo.fr>
Date:   Tue Nov 16 14:14:02 2010 +0100

    backlight: constify backlight_ops
    
    backlight_device_register has been expecting a const "ops" argument, and using
    it as such, since 9905a43b2d563e6f89e4c63c4278ada03f2ebb14. Let's make the
    remaining backlight_ops instances const.
    
    Inspired by hunks of the grsecurity patch, updated for newer kernels.
    
    Signed-off-by: Lionel Debroux <lionel_debroux@yahoo.fr>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 60a5a5c6b50a..3640599446fc 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -621,7 +621,7 @@ static int update_bl_status(struct backlight_device *bd)
 	return asus_lcd_set(asus, value);
 }
 
-static struct backlight_ops asusbl_ops = {
+static const struct backlight_ops asusbl_ops = {
 	.get_brightness = asus_read_brightness,
 	.update_status = update_bl_status,
 };

commit ac9b1e5b63d5d9829ecf2294f0486ccd270c5db4
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Thu Aug 26 00:12:19 2010 -0700

    asus-laptop: use attribute group to manage attributes
    
    Instead of registering (and removing) every attribute individually
    switch to using sysfs attribute group. This makes sure that we
    properly unwind and do not try to remove non-existent attributes which
    may not be safe to do in the future.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index e3b5e0604edd..60a5a5c6b50a 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -1200,82 +1200,70 @@ static void asus_acpi_notify(struct acpi_device *device, u32 event)
 
 static DEVICE_ATTR(infos, S_IRUGO, show_infos, NULL);
 static DEVICE_ATTR(wlan, S_IRUGO | S_IWUSR, show_wlan, store_wlan);
-static DEVICE_ATTR(bluetooth, S_IRUGO | S_IWUSR, show_bluetooth,
-		   store_bluetooth);
+static DEVICE_ATTR(bluetooth, S_IRUGO | S_IWUSR,
+		   show_bluetooth, store_bluetooth);
 static DEVICE_ATTR(display, S_IRUGO | S_IWUSR, show_disp, store_disp);
 static DEVICE_ATTR(ledd, S_IRUGO | S_IWUSR, show_ledd, store_ledd);
 static DEVICE_ATTR(ls_level, S_IRUGO | S_IWUSR, show_lslvl, store_lslvl);
 static DEVICE_ATTR(ls_switch, S_IRUGO | S_IWUSR, show_lssw, store_lssw);
 static DEVICE_ATTR(gps, S_IRUGO | S_IWUSR, show_gps, store_gps);
 
-static void asus_sysfs_exit(struct asus_laptop *asus)
-{
-	struct platform_device *device = asus->platform_device;
-
-	device_remove_file(&device->dev, &dev_attr_infos);
-	device_remove_file(&device->dev, &dev_attr_wlan);
-	device_remove_file(&device->dev, &dev_attr_bluetooth);
-	device_remove_file(&device->dev, &dev_attr_display);
-	device_remove_file(&device->dev, &dev_attr_ledd);
-	device_remove_file(&device->dev, &dev_attr_ls_switch);
-	device_remove_file(&device->dev, &dev_attr_ls_level);
-	device_remove_file(&device->dev, &dev_attr_gps);
-}
+static struct attribute *asus_attributes[] = {
+	&dev_attr_infos.attr,
+	&dev_attr_wlan.attr,
+	&dev_attr_bluetooth.attr,
+	&dev_attr_display.attr,
+	&dev_attr_ledd.attr,
+	&dev_attr_ls_level.attr,
+	&dev_attr_ls_switch.attr,
+	&dev_attr_gps.attr,
+	NULL
+};
 
-static int asus_sysfs_init(struct asus_laptop *asus)
+static mode_t asus_sysfs_is_visible(struct kobject *kobj,
+				    struct attribute *attr,
+				    int idx)
 {
-	struct platform_device *device = asus->platform_device;
-	int err;
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct platform_device *pdev = to_platform_device(dev);
+	struct asus_laptop *asus = platform_get_drvdata(pdev);
+	acpi_handle handle = asus->handle;
+	bool supported;
 
-	err = device_create_file(&device->dev, &dev_attr_infos);
-	if (err)
-		return err;
+	if (attr == &dev_attr_wlan.attr) {
+		supported = !acpi_check_handle(handle, METHOD_WLAN, NULL);
 
-	if (!acpi_check_handle(asus->handle, METHOD_WLAN, NULL)) {
-		err = device_create_file(&device->dev, &dev_attr_wlan);
-		if (err)
-			return err;
-	}
-
-	if (!acpi_check_handle(asus->handle, METHOD_BLUETOOTH, NULL)) {
-		err = device_create_file(&device->dev, &dev_attr_bluetooth);
-		if (err)
-			return err;
-	}
+	} else if (attr == &dev_attr_bluetooth.attr) {
+		supported = !acpi_check_handle(handle, METHOD_BLUETOOTH, NULL);
 
-	if (!acpi_check_handle(asus->handle, METHOD_SWITCH_DISPLAY, NULL)) {
-		err = device_create_file(&device->dev, &dev_attr_display);
-		if (err)
-			return err;
-	}
+	} else if (attr == &dev_attr_display.attr) {
+		supported = !acpi_check_handle(handle, METHOD_SWITCH_DISPLAY, NULL);
 
-	if (!acpi_check_handle(asus->handle, METHOD_LEDD, NULL)) {
-		err = device_create_file(&device->dev, &dev_attr_ledd);
-		if (err)
-			return err;
-	}
+	} else if (attr == &dev_attr_ledd.attr) {
+		supported = !acpi_check_handle(handle, METHOD_LEDD, NULL);
 
-	if (!acpi_check_handle(asus->handle, METHOD_ALS_CONTROL, NULL) &&
-	    !acpi_check_handle(asus->handle, METHOD_ALS_LEVEL, NULL)) {
-		err = device_create_file(&device->dev, &dev_attr_ls_switch);
-		if (err)
-			return err;
-		err = device_create_file(&device->dev, &dev_attr_ls_level);
-		if (err)
-			return err;
-	}
+	} else if (attr == &dev_attr_ls_switch.attr ||
+		   attr == &dev_attr_ls_level.attr) {
+		supported = !acpi_check_handle(handle, METHOD_ALS_CONTROL, NULL) &&
+			    !acpi_check_handle(handle, METHOD_ALS_LEVEL, NULL);
 
-	if (!acpi_check_handle(asus->handle, METHOD_GPS_ON, NULL) &&
-	    !acpi_check_handle(asus->handle, METHOD_GPS_OFF, NULL) &&
-	    !acpi_check_handle(asus->handle, METHOD_GPS_STATUS, NULL)) {
-		err = device_create_file(&device->dev, &dev_attr_gps);
-		if (err)
-			return err;
+	} else if (attr == &dev_attr_gps.attr) {
+		supported = !acpi_check_handle(handle, METHOD_GPS_ON, NULL) &&
+			    !acpi_check_handle(handle, METHOD_GPS_OFF, NULL) &&
+			    !acpi_check_handle(handle, METHOD_GPS_STATUS, NULL);
+	} else {
+		supported = true;
 	}
 
-	return err;
+	return supported ? attr->mode : 0;
 }
 
+
+static const struct attribute_group asus_attr_group = {
+	.is_visible	= asus_sysfs_is_visible,
+	.attrs		= asus_attributes,
+};
+
 static int asus_platform_init(struct asus_laptop *asus)
 {
 	int result;
@@ -1289,13 +1277,14 @@ static int asus_platform_init(struct asus_laptop *asus)
 	if (result)
 		goto fail_platform_device;
 
-	result = asus_sysfs_init(asus);
+	result = sysfs_create_group(&asus->platform_device->dev.kobj,
+				    &asus_attr_group);
 	if (result)
 		goto fail_sysfs;
+
 	return 0;
 
 fail_sysfs:
-	asus_sysfs_exit(asus);
 	platform_device_del(asus->platform_device);
 fail_platform_device:
 	platform_device_put(asus->platform_device);
@@ -1304,7 +1293,7 @@ static int asus_platform_init(struct asus_laptop *asus)
 
 static void asus_platform_exit(struct asus_laptop *asus)
 {
-	asus_sysfs_exit(asus);
+	sysfs_remove_group(&asus->platform_device->dev.kobj, &asus_attr_group);
 	platform_device_unregister(asus->platform_device);
 }
 

commit b404ecbf91a5c19c0f448b513aa26696eee09392
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Wed Aug 25 07:45:45 2010 -0700

    asus-laptop: remove no longer used keycode_map field
    
    The driver uses sparse keymap library and does not use this field
    anymore.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 67d922887616..e3b5e0604edd 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -236,7 +236,6 @@ struct asus_laptop {
 	u8 light_level;		/* light sensor level */
 	u8 light_switch;	/* light sensor switch value */
 	u16 event_count[128];	/* count for each event TODO make this better */
-	u16 *keycode_map;
 };
 
 static const struct key_entry asus_keymap[] = {

commit 23f45c3a76e715217f40ac397c15815c774cad7f
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Tue Aug 24 09:30:46 2010 +0200

    asus-laptop: fix gps rfkill
    
    The GPS rfkill crappy code. The ops_data argument wasn't
    set, and was totally misused. The fix have been tested
    on an Asus R2H.
    
    Cc: stable@kernel.org
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 27298a49c6d3..67d922887616 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -1066,9 +1066,9 @@ static ssize_t store_gps(struct device *dev, struct device_attribute *attr,
  */
 static int asus_gps_rfkill_set(void *data, bool blocked)
 {
-	acpi_handle handle = data;
+	struct asus_laptop *asus = data;
 
-	return asus_gps_switch(handle, !blocked);
+	return asus_gps_switch(asus, !blocked);
 }
 
 static const struct rfkill_ops asus_gps_rfkill_ops = {
@@ -1095,7 +1095,7 @@ static int asus_rfkill_init(struct asus_laptop *asus)
 
 	asus->gps_rfkill = rfkill_alloc("asus-gps", &asus->platform_device->dev,
 					RFKILL_TYPE_GPS,
-					&asus_gps_rfkill_ops, NULL);
+					&asus_gps_rfkill_ops, asus);
 	if (!asus->gps_rfkill)
 		return -EINVAL;
 

commit b58baecddee634903f339b7f7e9db7fc2a1449f1
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Tue Aug 24 09:30:45 2010 +0200

    asus-laptop: Add key found on Asus N61JQ
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index ffab9b45f0c8..27298a49c6d3 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -278,6 +278,7 @@ static const struct key_entry asus_keymap[] = {
 	{KE_KEY, 0x99, { KEY_PHONE } },
 	{KE_KEY, 0xc4, { KEY_KBDILLUMUP } },
 	{KE_KEY, 0xc5, { KEY_KBDILLUMDOWN } },
+	{KE_KEY, 0xb5, { KEY_CALC } },
 	{KE_END, 0},
 };
 

commit 71e687dc499819caa0d6ee0f80dcda1d5c24b5b2
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Tue Aug 24 09:30:44 2010 +0200

    platform-x86: sync eeepc-laptop and asus-laptop
    
    Makes asus-laptop and eeepc-laptop _init/_exit functions
    looks exactly the same as they do the same thing.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index b756e07d41b4..ffab9b45f0c8 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -639,29 +639,29 @@ static int asus_backlight_notify(struct asus_laptop *asus)
 static int asus_backlight_init(struct asus_laptop *asus)
 {
 	struct backlight_device *bd;
-	struct device *dev = &asus->platform_device->dev;
 	struct backlight_properties props;
 
-	if (!acpi_check_handle(asus->handle, METHOD_BRIGHTNESS_GET, NULL) &&
-	    !acpi_check_handle(asus->handle, METHOD_BRIGHTNESS_SET, NULL) &&
-	    lcd_switch_handle) {
-		memset(&props, 0, sizeof(struct backlight_properties));
-		props.max_brightness = 15;
-
-		bd = backlight_device_register(ASUS_LAPTOP_FILE, dev,
-					       asus, &asusbl_ops, &props);
-		if (IS_ERR(bd)) {
-			pr_err("Could not register asus backlight device\n");
-			asus->backlight_device = NULL;
-			return PTR_ERR(bd);
-		}
+	if (acpi_check_handle(asus->handle, METHOD_BRIGHTNESS_GET, NULL) ||
+	    acpi_check_handle(asus->handle, METHOD_BRIGHTNESS_SET, NULL) ||
+	    !lcd_switch_handle)
+		return 0;
 
-		asus->backlight_device = bd;
+	memset(&props, 0, sizeof(struct backlight_properties));
+	props.max_brightness = 15;
 
-		bd->props.power = FB_BLANK_UNBLANK;
-		bd->props.brightness = asus_read_brightness(bd);
-		backlight_update_status(bd);
+	bd = backlight_device_register(ASUS_LAPTOP_FILE,
+				       &asus->platform_device->dev, asus,
+				       &asusbl_ops, &props);
+	if (IS_ERR(bd)) {
+		pr_err("Could not register asus backlight device\n");
+		asus->backlight_device = NULL;
+		return PTR_ERR(bd);
 	}
+
+	asus->backlight_device = bd;
+	bd->props.brightness = asus_read_brightness(bd);
+	bd->props.power = FB_BLANK_UNBLANK;
+	backlight_update_status(bd);
 	return 0;
 }
 
@@ -1130,7 +1130,6 @@ static int asus_input_init(struct asus_laptop *asus)
 	input->phys = ASUS_LAPTOP_FILE "/input0";
 	input->id.bustype = BUS_HOST;
 	input->dev.parent = &asus->platform_device->dev;
-	input_set_drvdata(input, asus);
 
 	error = sparse_keymap_setup(input, asus_keymap, NULL);
 	if (error) {
@@ -1159,6 +1158,7 @@ static void asus_input_exit(struct asus_laptop *asus)
 		sparse_keymap_free(asus->inputdev);
 		input_unregister_device(asus->inputdev);
 	}
+	asus->inputdev = NULL;
 }
 
 /*
@@ -1278,19 +1278,19 @@ static int asus_sysfs_init(struct asus_laptop *asus)
 
 static int asus_platform_init(struct asus_laptop *asus)
 {
-	int err;
+	int result;
 
 	asus->platform_device = platform_device_alloc(ASUS_LAPTOP_FILE, -1);
 	if (!asus->platform_device)
 		return -ENOMEM;
 	platform_set_drvdata(asus->platform_device, asus);
 
-	err = platform_device_add(asus->platform_device);
-	if (err)
+	result = platform_device_add(asus->platform_device);
+	if (result)
 		goto fail_platform_device;
 
-	err = asus_sysfs_init(asus);
-	if (err)
+	result = asus_sysfs_init(asus);
+	if (result)
 		goto fail_sysfs;
 	return 0;
 
@@ -1299,7 +1299,7 @@ static int asus_platform_init(struct asus_laptop *asus)
 	platform_device_del(asus->platform_device);
 fail_platform_device:
 	platform_device_put(asus->platform_device);
-	return err;
+	return result;
 }
 
 static void asus_platform_exit(struct asus_laptop *asus)
@@ -1428,8 +1428,6 @@ static int asus_laptop_get_info(struct asus_laptop *asus)
 	return AE_OK;
 }
 
-static bool asus_device_present;
-
 static int __devinit asus_acpi_init(struct asus_laptop *asus)
 {
 	int result = 0;
@@ -1474,6 +1472,8 @@ static int __devinit asus_acpi_init(struct asus_laptop *asus)
 	return result;
 }
 
+static bool asus_device_present;
+
 static int __devinit asus_acpi_add(struct acpi_device *device)
 {
 	struct asus_laptop *asus;

commit 45036ae14a0161e9a0f542b6cb7ed55790f73f5b
Author: Axel Lin <axel.lin@gmail.com>
Date:   Mon Jul 5 15:29:00 2010 +0800

    asus-laptop: fix asus_input_init error path
    
    This patch includes below fixes:
    1. return -ENOMEM instead of 0 if input_allocate_device fail.
    2. fix wrong goto if sparse_keymap_setup fail.
    3. fix wrong goto if input_register_device fail.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 6aba24618416..b756e07d41b4 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -1124,7 +1124,7 @@ static int asus_input_init(struct asus_laptop *asus)
 	input = input_allocate_device();
 	if (!input) {
 		pr_info("Unable to allocate input device\n");
-		return 0;
+		return -ENOMEM;
 	}
 	input->name = "Asus Laptop extra buttons";
 	input->phys = ASUS_LAPTOP_FILE "/input0";
@@ -1135,20 +1135,20 @@ static int asus_input_init(struct asus_laptop *asus)
 	error = sparse_keymap_setup(input, asus_keymap, NULL);
 	if (error) {
 		pr_err("Unable to setup input device keymap\n");
-		goto err_keymap;
+		goto err_free_dev;
 	}
 	error = input_register_device(input);
 	if (error) {
 		pr_info("Unable to register input device\n");
-		goto err_device;
+		goto err_free_keymap;
 	}
 
 	asus->inputdev = input;
 	return 0;
 
-err_keymap:
+err_free_keymap:
 	sparse_keymap_free(input);
-err_device:
+err_free_dev:
 	input_free_device(input);
 	return error;
 }

commit c26d85cb90e178d1e3df6a78d064f8731f154a5e
Author: Axel Lin <axel.lin@gmail.com>
Date:   Tue Jul 20 15:19:55 2010 -0700

    asus-laptop: fix wapf, wlan_status and bluetooth_status module_param permissions
    
    The wapf module parameters defines the behavior of the Fn+Fx wlan key.
    The wlan_status and bluetooth_status module parameters are for setting the
    wlan/bluetooth status on boot.
    
    All above module parameters are determinated only at the module load time.
     Change the value after the module is loaded does not make sense and has
    no effect at all, thus set the permissions to 0444 instead of 0644.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Cc: Corentin Chary <corentincj@iksaif.net>
    Cc: Matthew Garrett <mjg@redhat.com>
    Cc: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 40897bab2ebe..6aba24618416 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -76,18 +76,18 @@ MODULE_LICENSE("GPL");
  * So, if something doesn't work as you want, just try other values =)
  */
 static uint wapf = 1;
-module_param(wapf, uint, 0644);
+module_param(wapf, uint, 0444);
 MODULE_PARM_DESC(wapf, "WAPF value");
 
 static int wlan_status = 1;
 static int bluetooth_status = 1;
 
-module_param(wlan_status, int, 0644);
+module_param(wlan_status, int, 0444);
 MODULE_PARM_DESC(wlan_status, "Set the wireless status on boot "
 		 "(0 = disabled, 1 = enabled, -1 = don't do anything). "
 		 "default is 1");
 
-module_param(bluetooth_status, int, 0644);
+module_param(bluetooth_status, int, 0444);
 MODULE_PARM_DESC(bluetooth_status, "Set the wireless status on boot "
 		 "(0 = disabled, 1 = enabled, -1 = don't do anything). "
 		 "default is 1");

commit 6a984a06487129f013ee2df6ce98b6cfada1e7b1
Author: Axel Lin <axel.lin@gmail.com>
Date:   Tue Jul 20 15:19:48 2010 -0700

    asus-laptop: return proper error for store_ledd if write_acpi_int fail
    
    In current implementation, store_ledd() does not return error if
    write_acpi_int fail.  This patch fixes it by return -ENODEV if
    write_acpi_int fail.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Cc: Matthew Garrett <mjg@redhat.com>
    Cc: Corentin Chary <corentincj@iksaif.net>
    Cc: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 19445eaff6ff..40897bab2ebe 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -796,10 +796,11 @@ static ssize_t store_ledd(struct device *dev, struct device_attribute *attr,
 
 	rv = parse_arg(buf, count, &value);
 	if (rv > 0) {
-		if (write_acpi_int(asus->handle, METHOD_LEDD, value))
+		if (write_acpi_int(asus->handle, METHOD_LEDD, value)) {
 			pr_warning("LED display write failed\n");
-		else
-			asus->ledd_status = (u32) value;
+			return -ENODEV;
+		}
+		asus->ledd_status = (u32) value;
 	}
 	return rv;
 }

commit 9fb866f317def195bb794120e13d1d73c2a94bb2
Author: Axel Lin <axel.lin@gmail.com>
Date:   Tue Jul 20 15:19:47 2010 -0700

    asus-laptop: fix incorrect return value for write_acpi_int_ret if handle is NULL
    
    According to the comments of write_acpi_int_ret(), write_acpi_int_ret()
    should return 0 if write is successful, -1 else.  Thus if handle is NULL,
    the write does not happen, it should return -1.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Cc: Matthew Garrett <mjg@redhat.com>
    Cc: Corentin Chary <corentincj@iksaif.net>
    Cc: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 4af5709f8317..19445eaff6ff 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -297,7 +297,7 @@ static int write_acpi_int_ret(acpi_handle handle, const char *method, int val,
 	acpi_status status;
 
 	if (!handle)
-		return 0;
+		return -1;
 
 	params.count = 1;
 	params.pointer = &in_obj;

commit d8eca1105fe2039e102c6a8a915d0af937b1b593
Author: Axel Lin <axel.lin@gmail.com>
Date:   Tue Jun 29 11:09:47 2010 +0800

    asus-laptop: fix a memory leak in asus_laptop_get_info error path
    
    The callers of write_acpi_int_ret() pass ACPI_ALLOCATE_BUFFER,
    the caller must kfree the returned buffer if AE_OK is returned.
    
    This patch adds a missing kfree(buffer.pointer) before return -ENOMEM
    if kstrdup fail.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Acked-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index efe8f6388906..4af5709f8317 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -1397,8 +1397,10 @@ static int asus_laptop_get_info(struct asus_laptop *asus)
 		}
 	}
 	asus->name = kstrdup(string, GFP_KERNEL);
-	if (!asus->name)
+	if (!asus->name) {
+		kfree(buffer.pointer);
 		return -ENOMEM;
+	}
 
 	if (*string)
 		pr_notice("  %s model detected\n", string);

commit 668f4a03211ace7aa57dece90bd835b4f9b9dd30
Author: Dan Carpenter <error27@gmail.com>
Date:   Tue Apr 6 13:44:29 2010 +0300

    asus: don't modify bluetooth/wlan on boot
    
    We were storing -1 as an unsigned int and as a result the effect of
    passing -1 was the same as using 1.
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Acked-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 52262b012abb..efe8f6388906 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -79,15 +79,15 @@ static uint wapf = 1;
 module_param(wapf, uint, 0644);
 MODULE_PARM_DESC(wapf, "WAPF value");
 
-static uint wlan_status = 1;
-static uint bluetooth_status = 1;
+static int wlan_status = 1;
+static int bluetooth_status = 1;
 
-module_param(wlan_status, uint, 0644);
+module_param(wlan_status, int, 0644);
 MODULE_PARM_DESC(wlan_status, "Set the wireless status on boot "
 		 "(0 = disabled, 1 = enabled, -1 = don't do anything). "
 		 "default is 1");
 
-module_param(bluetooth_status, uint, 0644);
+module_param(bluetooth_status, int, 0644);
 MODULE_PARM_DESC(bluetooth_status, "Set the wireless status on boot "
 		 "(0 = disabled, 1 = enabled, -1 = don't do anything). "
 		 "default is 1");

commit 336f5899d287f06d8329e208fc14ce50f7ec9698
Merge: a4ab2773205e db217dece300
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Apr 5 11:37:28 2010 +0900

    Merge branch 'master' into export-slabh

commit 167215118a88dd56a1ab8c8d33e279d6d40f57b6
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Tue Mar 2 22:24:12 2010 +0100

    asus-laptop: fix warning in asus_handle_init
    
    In function 'asus_laptop_get_info':
    warning: passing argument 3 of 'asus_handle_init' from incompatible pointer type
    note: expected 'char **' but argument is of type 'const char **'
    
    Introduced by commit c21085108a02e1b838c34f3650c8cc9fbd178615
    ("asus-laptop: fix style problems reported by checkpath.pl").
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index db5f7db2ba33..475ab50732ab 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -139,7 +139,7 @@ MODULE_PARM_DESC(bluetooth_status, "Set the wireless status on boot "
 
 /* Backlight */
 static acpi_handle lcd_switch_handle;
-static const char *lcd_switch_paths[] = {
+static char *lcd_switch_paths[] = {
   "\\_SB.PCI0.SBRG.EC0._Q10",	/* All new models */
   "\\_SB.PCI0.ISA.EC0._Q10",	/* A1x */
   "\\_SB.PCI0.PX40.ECD0._Q10",	/* L3C */
@@ -153,7 +153,7 @@ static const char *lcd_switch_paths[] = {
 #define METHOD_SWITCH_DISPLAY	"SDSP"
 
 static acpi_handle display_get_handle;
-static const char *display_get_paths[] = {
+static char *display_get_paths[] = {
   /* A6B, A6K A6R A7D F3JM L4R M6R A3G M6A M6V VX-1 V6J V6V W3Z */
   "\\_SB.PCI0.P0P1.VGA.GETD",
   /* A3E A4K, A4D A4L A6J A7J A8J Z71V M9V S5A M5A z33A W1Jc W2V G1 */

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index db5f7db2ba33..c2d4569aef3a 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -49,6 +49,7 @@
 #include <linux/input.h>
 #include <linux/input/sparse-keymap.h>
 #include <linux/rfkill.h>
+#include <linux/slab.h>
 #include <acpi/acpi_drivers.h>
 #include <acpi/acpi_bus.h>
 

commit a19a6ee6cad2b20292a774c2f56ba8039b0fac9c
Author: Matthew Garrett <mjg@redhat.com>
Date:   Wed Feb 17 16:39:44 2010 -0500

    backlight: Allow properties to be passed at registration
    
    Values such as max_brightness should be set before backlights are
    registered, but the current API doesn't allow that. Add a parameter to
    backlight_device_register and update drivers to ensure that they
    set this correctly.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Richard Purdie <rpurdie@linux.intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 791fcf321506..db5f7db2ba33 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -639,12 +639,16 @@ static int asus_backlight_init(struct asus_laptop *asus)
 {
 	struct backlight_device *bd;
 	struct device *dev = &asus->platform_device->dev;
+	struct backlight_properties props;
 
 	if (!acpi_check_handle(asus->handle, METHOD_BRIGHTNESS_GET, NULL) &&
 	    !acpi_check_handle(asus->handle, METHOD_BRIGHTNESS_SET, NULL) &&
 	    lcd_switch_handle) {
+		memset(&props, 0, sizeof(struct backlight_properties));
+		props.max_brightness = 15;
+
 		bd = backlight_device_register(ASUS_LAPTOP_FILE, dev,
-					       asus, &asusbl_ops);
+					       asus, &asusbl_ops, &props);
 		if (IS_ERR(bd)) {
 			pr_err("Could not register asus backlight device\n");
 			asus->backlight_device = NULL;
@@ -653,7 +657,6 @@ static int asus_backlight_init(struct asus_laptop *asus)
 
 		asus->backlight_device = bd;
 
-		bd->props.max_brightness = 15;
 		bd->props.power = FB_BLANK_UNBLANK;
 		bd->props.brightness = asus_read_brightness(bd);
 		backlight_update_status(bd);

commit 060cbce6c4431465e83907102e1903ecea366db5
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Thu Jan 28 10:52:40 2010 +0100

    asus-laptop: fix style problems reported by checkpath.pl
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index d0d117b0cf79..791fcf321506 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -45,12 +45,12 @@
 #include <linux/fb.h>
 #include <linux/leds.h>
 #include <linux/platform_device.h>
-#include <acpi/acpi_drivers.h>
-#include <acpi/acpi_bus.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <linux/input.h>
 #include <linux/input/sparse-keymap.h>
 #include <linux/rfkill.h>
+#include <acpi/acpi_drivers.h>
+#include <acpi/acpi_bus.h>
 
 #define ASUS_LAPTOP_VERSION	"0.42"
 
@@ -94,10 +94,10 @@ MODULE_PARM_DESC(bluetooth_status, "Set the wireless status on boot "
 /*
  * Some events we use, same for all Asus
  */
-#define ATKD_BR_UP	0x10	// (event & ~ATKD_BR_UP) = brightness level
-#define ATKD_BR_DOWN	0x20	// (event & ~ATKD_BR_DOWN) = britghness level
+#define ATKD_BR_UP	0x10	/* (event & ~ATKD_BR_UP) = brightness level */
+#define ATKD_BR_DOWN	0x20	/* (event & ~ATKD_BR_DOWN) = britghness level */
 #define ATKD_BR_MIN	ATKD_BR_UP
-#define ATKD_BR_MAX	(ATKD_BR_DOWN | 0xF)	// 0x2f
+#define ATKD_BR_MAX	(ATKD_BR_DOWN | 0xF)	/* 0x2f */
 #define ATKD_LCD_ON	0x33
 #define ATKD_LCD_OFF	0x34
 
@@ -114,10 +114,6 @@ MODULE_PARM_DESC(bluetooth_status, "Set the wireless status on boot "
 #define WL_RSTS		0x01	/* internal Wifi */
 #define BT_RSTS		0x02	/* internal Bluetooth */
 
-#define ASUS_HANDLE(object, paths...)					\
-	static acpi_handle  object##_handle = NULL;			\
-	static char *object##_paths[] = { paths }
-
 /* LED */
 #define METHOD_MLED		"MLED"
 #define METHOD_TLED		"TLED"
@@ -142,40 +138,44 @@ MODULE_PARM_DESC(bluetooth_status, "Set the wireless status on boot "
 #define METHOD_BRIGHTNESS_GET	"GPLV"
 
 /* Backlight */
-ASUS_HANDLE(lcd_switch, "\\_SB.PCI0.SBRG.EC0._Q10",	/* All new models */
-	    "\\_SB.PCI0.ISA.EC0._Q10",	/* A1x */
-	    "\\_SB.PCI0.PX40.ECD0._Q10",	/* L3C */
-	    "\\_SB.PCI0.PX40.EC0.Q10",	/* M1A */
-	    "\\_SB.PCI0.LPCB.EC0._Q10",	/* P30 */
-	    "\\_SB.PCI0.LPCB.EC0._Q0E", /* P30/P35 */
-	    "\\_SB.PCI0.PX40.Q10",	/* S1x */
-	    "\\Q10");		/* A2x, L2D, L3D, M2E */
+static acpi_handle lcd_switch_handle;
+static const char *lcd_switch_paths[] = {
+  "\\_SB.PCI0.SBRG.EC0._Q10",	/* All new models */
+  "\\_SB.PCI0.ISA.EC0._Q10",	/* A1x */
+  "\\_SB.PCI0.PX40.ECD0._Q10",	/* L3C */
+  "\\_SB.PCI0.PX40.EC0.Q10",	/* M1A */
+  "\\_SB.PCI0.LPCB.EC0._Q10",	/* P30 */
+  "\\_SB.PCI0.LPCB.EC0._Q0E", /* P30/P35 */
+  "\\_SB.PCI0.PX40.Q10",	/* S1x */
+  "\\Q10"};		/* A2x, L2D, L3D, M2E */
 
 /* Display */
 #define METHOD_SWITCH_DISPLAY	"SDSP"
-ASUS_HANDLE(display_get,
-	    /* A6B, A6K A6R A7D F3JM L4R M6R A3G M6A M6V VX-1 V6J V6V W3Z */
-	    "\\_SB.PCI0.P0P1.VGA.GETD",
-	    /* A3E A4K, A4D A4L A6J A7J A8J Z71V M9V S5A M5A z33A W1Jc W2V G1 */
-	    "\\_SB.PCI0.P0P2.VGA.GETD",
-	    /* A6V A6Q */
-	    "\\_SB.PCI0.P0P3.VGA.GETD",
-	    /* A6T, A6M */
-	    "\\_SB.PCI0.P0PA.VGA.GETD",
-	    /* L3C */
-	    "\\_SB.PCI0.PCI1.VGAC.NMAP",
-	    /* Z96F */
-	    "\\_SB.PCI0.VGA.GETD",
-	    /* A2D */
-	    "\\ACTD",
-	    /* A4G Z71A W1N W5A W5F M2N M3N M5N M6N S1N S5N */
-	    "\\ADVG",
-	    /* P30 */
-	    "\\DNXT",
-	    /* A2H D1 L2D L3D L3H L2E L5D L5C M1A M2E L4L W3V */
-	    "\\INFB",
-	    /* A3F A6F A3N A3L M6N W3N W6A */
-	    "\\SSTE");
+
+static acpi_handle display_get_handle;
+static const char *display_get_paths[] = {
+  /* A6B, A6K A6R A7D F3JM L4R M6R A3G M6A M6V VX-1 V6J V6V W3Z */
+  "\\_SB.PCI0.P0P1.VGA.GETD",
+  /* A3E A4K, A4D A4L A6J A7J A8J Z71V M9V S5A M5A z33A W1Jc W2V G1 */
+  "\\_SB.PCI0.P0P2.VGA.GETD",
+  /* A6V A6Q */
+  "\\_SB.PCI0.P0P3.VGA.GETD",
+  /* A6T, A6M */
+  "\\_SB.PCI0.P0PA.VGA.GETD",
+  /* L3C */
+  "\\_SB.PCI0.PCI1.VGAC.NMAP",
+  /* Z96F */
+  "\\_SB.PCI0.VGA.GETD",
+  /* A2D */
+  "\\ACTD",
+  /* A4G Z71A W1N W5A W5F M2N M3N M5N M6N S1N S5N */
+  "\\ADVG",
+  /* P30 */
+  "\\DNXT",
+  /* A2H D1 L2D L3D L3H L2E L5D L5C M1A M2E L4L W3V */
+  "\\INFB",
+  /* A3F A6F A3N A3L M6N W3N W6A */
+  "\\SSTE"};
 
 #define METHOD_ALS_CONTROL	"ALSC" /* Z71A Z71V */
 #define METHOD_ALS_LEVEL	"ALSL" /* Z71A Z71V */
@@ -426,7 +426,7 @@ static void asus_kled_cdev_set(struct led_classdev *led_cdev,
 	struct asus_led *led = container_of(led_cdev, struct asus_led, led);
 	struct asus_laptop *asus = led->asus;
 
-        led->wk = value;
+	led->wk = value;
 	queue_work(asus->led_workqueue, &led->work);
 }
 
@@ -474,7 +474,7 @@ static int asus_led_register(struct asus_laptop *asus,
 	struct led_classdev *led_cdev = &led->led;
 
 	if (!method || acpi_check_handle(asus->handle, method, NULL))
-	    return 0; /* Led not present */
+		return 0; /* Led not present */
 
 	led->asus = asus;
 	led->method = method;
@@ -687,8 +687,8 @@ static ssize_t show_infos(struct device *dev,
 	acpi_status rv = AE_OK;
 
 	/*
-	 * We use the easy way, we don't care of off and count, so we don't set eof
-	 * to 1
+	 * We use the easy way, we don't care of off and count,
+	 * so we don't set eof to 1
 	 */
 
 	len += sprintf(page, ASUS_LAPTOP_NAME " " ASUS_LAPTOP_VERSION "\n");
@@ -904,7 +904,7 @@ static int read_display(struct asus_laptop *asus)
 			pr_warning("Error reading display status\n");
 	}
 
-	value &= 0x0F;		/* needed for some models, shouldn't hurt others */
+	value &= 0x0F; /* needed for some models, shouldn't hurt others */
 
 	return value;
 }
@@ -1041,7 +1041,7 @@ static ssize_t show_gps(struct device *dev,
 static ssize_t store_gps(struct device *dev, struct device_attribute *attr,
 			 const char *buf, size_t count)
 {
- 	struct asus_laptop *asus = dev_get_drvdata(dev);
+	struct asus_laptop *asus = dev_get_drvdata(dev);
 	int rv, value;
 	int ret;
 

commit 2a1fd64cb70a42563d2313eb70c6495d2c88b36d
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Tue Jan 26 21:02:23 2010 +0100

    asus-laptop: use device_create_file() instead of platform_group
    
    There is two reason to do that:
    - we don't want a "gps" file if the model doesn't have a gps
    - we don't want to use global variables anymore
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index ae5302646c4e..d0d117b0cf79 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -918,6 +918,8 @@ static ssize_t show_disp(struct device *dev,
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 
+	if (!display_get_handle)
+		return -ENODEV;
 	return sprintf(buf, "%d\n", read_display(asus));
 }
 
@@ -1191,77 +1193,113 @@ static void asus_acpi_notify(struct acpi_device *device, u32 event)
 	asus_input_notify(asus, event);
 }
 
-#define ASUS_CREATE_DEVICE_ATTR(_name)					\
-	struct device_attribute dev_attr_##_name = {			\
-		.attr = {						\
-			.name = __stringify(_name),			\
-			.mode = 0 },					\
-		.show   = NULL,						\
-		.store  = NULL,						\
+static DEVICE_ATTR(infos, S_IRUGO, show_infos, NULL);
+static DEVICE_ATTR(wlan, S_IRUGO | S_IWUSR, show_wlan, store_wlan);
+static DEVICE_ATTR(bluetooth, S_IRUGO | S_IWUSR, show_bluetooth,
+		   store_bluetooth);
+static DEVICE_ATTR(display, S_IRUGO | S_IWUSR, show_disp, store_disp);
+static DEVICE_ATTR(ledd, S_IRUGO | S_IWUSR, show_ledd, store_ledd);
+static DEVICE_ATTR(ls_level, S_IRUGO | S_IWUSR, show_lslvl, store_lslvl);
+static DEVICE_ATTR(ls_switch, S_IRUGO | S_IWUSR, show_lssw, store_lssw);
+static DEVICE_ATTR(gps, S_IRUGO | S_IWUSR, show_gps, store_gps);
+
+static void asus_sysfs_exit(struct asus_laptop *asus)
+{
+	struct platform_device *device = asus->platform_device;
+
+	device_remove_file(&device->dev, &dev_attr_infos);
+	device_remove_file(&device->dev, &dev_attr_wlan);
+	device_remove_file(&device->dev, &dev_attr_bluetooth);
+	device_remove_file(&device->dev, &dev_attr_display);
+	device_remove_file(&device->dev, &dev_attr_ledd);
+	device_remove_file(&device->dev, &dev_attr_ls_switch);
+	device_remove_file(&device->dev, &dev_attr_ls_level);
+	device_remove_file(&device->dev, &dev_attr_gps);
+}
+
+static int asus_sysfs_init(struct asus_laptop *asus)
+{
+	struct platform_device *device = asus->platform_device;
+	int err;
+
+	err = device_create_file(&device->dev, &dev_attr_infos);
+	if (err)
+		return err;
+
+	if (!acpi_check_handle(asus->handle, METHOD_WLAN, NULL)) {
+		err = device_create_file(&device->dev, &dev_attr_wlan);
+		if (err)
+			return err;
 	}
 
-#define ASUS_SET_DEVICE_ATTR(_name, _mode, _show, _store)		\
-	do {								\
-		dev_attr_##_name.attr.mode = _mode;			\
-		dev_attr_##_name.show = _show;				\
-		dev_attr_##_name.store = _store;			\
-	} while(0)
-
-static ASUS_CREATE_DEVICE_ATTR(infos);
-static ASUS_CREATE_DEVICE_ATTR(wlan);
-static ASUS_CREATE_DEVICE_ATTR(bluetooth);
-static ASUS_CREATE_DEVICE_ATTR(display);
-static ASUS_CREATE_DEVICE_ATTR(ledd);
-static ASUS_CREATE_DEVICE_ATTR(ls_switch);
-static ASUS_CREATE_DEVICE_ATTR(ls_level);
-static ASUS_CREATE_DEVICE_ATTR(gps);
-
-static struct attribute *asuspf_attributes[] = {
-	&dev_attr_infos.attr,
-	&dev_attr_wlan.attr,
-	&dev_attr_bluetooth.attr,
-	&dev_attr_display.attr,
-	&dev_attr_ledd.attr,
-	&dev_attr_ls_switch.attr,
-	&dev_attr_ls_level.attr,
-	&dev_attr_gps.attr,
-	NULL
-};
+	if (!acpi_check_handle(asus->handle, METHOD_BLUETOOTH, NULL)) {
+		err = device_create_file(&device->dev, &dev_attr_bluetooth);
+		if (err)
+			return err;
+	}
 
-static struct attribute_group platform_attribute_group = {
-	.attrs = asuspf_attributes
-};
+	if (!acpi_check_handle(asus->handle, METHOD_SWITCH_DISPLAY, NULL)) {
+		err = device_create_file(&device->dev, &dev_attr_display);
+		if (err)
+			return err;
+	}
+
+	if (!acpi_check_handle(asus->handle, METHOD_LEDD, NULL)) {
+		err = device_create_file(&device->dev, &dev_attr_ledd);
+		if (err)
+			return err;
+	}
+
+	if (!acpi_check_handle(asus->handle, METHOD_ALS_CONTROL, NULL) &&
+	    !acpi_check_handle(asus->handle, METHOD_ALS_LEVEL, NULL)) {
+		err = device_create_file(&device->dev, &dev_attr_ls_switch);
+		if (err)
+			return err;
+		err = device_create_file(&device->dev, &dev_attr_ls_level);
+		if (err)
+			return err;
+	}
+
+	if (!acpi_check_handle(asus->handle, METHOD_GPS_ON, NULL) &&
+	    !acpi_check_handle(asus->handle, METHOD_GPS_OFF, NULL) &&
+	    !acpi_check_handle(asus->handle, METHOD_GPS_STATUS, NULL)) {
+		err = device_create_file(&device->dev, &dev_attr_gps);
+		if (err)
+			return err;
+	}
+
+	return err;
+}
 
 static int asus_platform_init(struct asus_laptop *asus)
 {
-	int result;
+	int err;
 
 	asus->platform_device = platform_device_alloc(ASUS_LAPTOP_FILE, -1);
 	if (!asus->platform_device)
 		return -ENOMEM;
 	platform_set_drvdata(asus->platform_device, asus);
 
-	result = platform_device_add(asus->platform_device);
-	if (result)
+	err = platform_device_add(asus->platform_device);
+	if (err)
 		goto fail_platform_device;
 
-	result = sysfs_create_group(&asus->platform_device->dev.kobj,
-				    &platform_attribute_group);
-	if (result)
+	err = asus_sysfs_init(asus);
+	if (err)
 		goto fail_sysfs;
 	return 0;
 
 fail_sysfs:
+	asus_sysfs_exit(asus);
 	platform_device_del(asus->platform_device);
 fail_platform_device:
 	platform_device_put(asus->platform_device);
-	return result;
+	return err;
 }
 
 static void asus_platform_exit(struct asus_laptop *asus)
 {
-	sysfs_remove_group(&asus->platform_device->dev.kobj,
-			   &platform_attribute_group);
+	asus_sysfs_exit(asus);
 	platform_device_unregister(asus->platform_device);
 }
 
@@ -1272,40 +1310,6 @@ static struct platform_driver platform_driver = {
 	}
 };
 
-static void asus_laptop_add_fs(struct asus_laptop *asus)
-{
-	ASUS_SET_DEVICE_ATTR(infos, 0444, show_infos, NULL);
-
-	if (!acpi_check_handle(asus->handle, METHOD_WLAN, NULL))
-		ASUS_SET_DEVICE_ATTR(wlan, 0644, show_wlan, store_wlan);
-
-	if (!acpi_check_handle(asus->handle, METHOD_BLUETOOTH, NULL))
-		ASUS_SET_DEVICE_ATTR(bluetooth, 0644,
-				     show_bluetooth, store_bluetooth);
-
-	if (!acpi_check_handle(asus->handle, METHOD_SWITCH_DISPLAY, NULL)) {
-		if (display_get_handle)
-			ASUS_SET_DEVICE_ATTR(display, 0644, show_disp,
-					     store_disp);
-		else
-			ASUS_SET_DEVICE_ATTR(display, 0200, NULL, store_disp);
-	}
-
-	if (!acpi_check_handle(asus->handle, METHOD_LEDD, NULL))
-		ASUS_SET_DEVICE_ATTR(ledd, 0644, show_ledd, store_ledd);
-
-	if (!acpi_check_handle(asus->handle, METHOD_ALS_CONTROL, NULL) &&
-	    !acpi_check_handle(asus->handle, METHOD_ALS_LEVEL, NULL)) {
-		ASUS_SET_DEVICE_ATTR(ls_level, 0644, show_lslvl, store_lslvl);
-		ASUS_SET_DEVICE_ATTR(ls_switch, 0644, show_lssw, store_lssw);
-	}
-
-	if (!acpi_check_handle(asus->handle, METHOD_GPS_ON, NULL) &&
-	    !acpi_check_handle(asus->handle, METHOD_GPS_OFF, NULL) &&
-	    !acpi_check_handle(asus->handle, METHOD_GPS_STATUS, NULL))
-		ASUS_SET_DEVICE_ATTR(gps, 0644, show_gps, store_gps);
-}
-
 static int asus_handle_init(char *name, acpi_handle * handle,
 			    char **paths, int num_paths)
 {
@@ -1435,8 +1439,6 @@ static int __devinit asus_acpi_init(struct asus_laptop *asus)
 	if (result)
 		return result;
 
-	asus_laptop_add_fs(asus);
-
 	/* WLED and BLED are on by default */
 	if (bluetooth_status >= 0)
 		asus_bluetooth_set(asus, !!bluetooth_status);

commit aee0afb8cb52178164accfec9cfc58bc27b597b3
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Tue Jan 26 21:01:34 2010 +0100

    asus-laptop: clean led code
    
    Remove all "templates" and add a generic struct asus_led instead.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index e1df92a22de9..ae5302646c4e 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -193,29 +193,12 @@ ASUS_HANDLE(display_get,
 /*
  * Define a specific led structure to keep the main structure clean
  */
-#define ASUS_DEFINE_LED(object)					\
-	int object##_wk;					\
-	struct work_struct object##_work;			\
-	struct led_classdev object;
-
-
-#define led_to_asus(led_cdev, led)					\
-	container_of(container_of(led_cdev, struct asus_laptop_leds,	\
-				  led),					\
-		     struct asus_laptop, leds)
-#define work_to_asus(work, led)						\
-	container_of(container_of(work, struct asus_laptop_leds,	\
-				  led##_work),				\
-		     struct asus_laptop, leds)
-
-struct asus_laptop_leds {
-	ASUS_DEFINE_LED(mled)
-	ASUS_DEFINE_LED(tled)
-	ASUS_DEFINE_LED(rled)
-	ASUS_DEFINE_LED(pled)
-	ASUS_DEFINE_LED(gled)
-	ASUS_DEFINE_LED(kled)
-	struct workqueue_struct *workqueue;
+struct asus_led {
+	int wk;
+	struct work_struct work;
+	struct led_classdev led;
+	struct asus_laptop *asus;
+	const char *method;
 };
 
 /*
@@ -233,7 +216,13 @@ struct asus_laptop {
 	struct input_dev *inputdev;
 	struct key_entry *keymap;
 
-	struct asus_laptop_leds leds;
+	struct asus_led mled;
+	struct asus_led tled;
+	struct asus_led rled;
+	struct asus_led pled;
+	struct asus_led gled;
+	struct asus_led kled;
+	struct workqueue_struct *led_workqueue;
 
 	int wireless_status;
 	bool have_rsts;
@@ -353,7 +342,7 @@ static int acpi_check_handle(acpi_handle handle, const char *method,
 }
 
 /* Generic LED function */
-static int asus_led_set(struct asus_laptop *asus, char *method,
+static int asus_led_set(struct asus_laptop *asus, const char *method,
 			 int value)
 {
 	if (!strcmp(method, METHOD_MLED))
@@ -369,50 +358,29 @@ static int asus_led_set(struct asus_laptop *asus, char *method,
 /*
  * LEDs
  */
-#define ASUS_LED(object, ledname, max)					\
-	static void object##_led_set(struct led_classdev *led_cdev,	\
-				     enum led_brightness value);	\
-	static enum led_brightness object##_led_get(			\
-		struct led_classdev *led_cdev);				\
-	static void object##_led_update(struct work_struct *ignored);
-
-ASUS_LED(mled, "mail", 1);
-ASUS_LED(tled, "touchpad", 1);
-ASUS_LED(rled, "record", 1);
-ASUS_LED(pled, "phone", 1);
-ASUS_LED(gled, "gaming", 1);
-ASUS_LED(kled, "kbd_backlight", 3);
-
 /* /sys/class/led handlers */
-#define ASUS_LED_HANDLER(object, method)				\
-	static void object##_led_set(struct led_classdev *led_cdev,	\
-				     enum led_brightness value)		\
-	{								\
-		struct asus_laptop *asus =				\
-			led_to_asus(led_cdev, object);			\
-									\
-		asus->leds.object##_wk = (value > 0) ? 1 : 0;		\
-		queue_work(asus->leds.workqueue,			\
-			   &asus->leds.object##_work);			\
-	}								\
-	static void object##_led_update(struct work_struct *work)	\
-	{								\
-		struct asus_laptop *asus = work_to_asus(work, object);	\
-									\
-		int value = asus->leds.object##_wk;			\
-		asus_led_set(asus, method, value);			\
-	}								\
-	static enum led_brightness object##_led_get(			\
-		struct led_classdev *led_cdev)				\
-	{								\
-		return led_cdev->brightness;				\
-	}
+static void asus_led_cdev_set(struct led_classdev *led_cdev,
+			 enum led_brightness value)
+{
+	struct asus_led *led = container_of(led_cdev, struct asus_led, led);
+	struct asus_laptop *asus = led->asus;
+
+	led->wk = !!value;
+	queue_work(asus->led_workqueue, &led->work);
+}
+
+static void asus_led_cdev_update(struct work_struct *work)
+{
+	struct asus_led *led = container_of(work, struct asus_led, work);
+	struct asus_laptop *asus = led->asus;
 
-ASUS_LED_HANDLER(mled, METHOD_MLED);
-ASUS_LED_HANDLER(pled, METHOD_PLED);
-ASUS_LED_HANDLER(rled, METHOD_RLED);
-ASUS_LED_HANDLER(tled, METHOD_TLED);
-ASUS_LED_HANDLER(gled, METHOD_GLED);
+	asus_led_set(asus, led->method, led->wk);
+}
+
+static enum led_brightness asus_led_cdev_get(struct led_classdev *led_cdev)
+{
+	return led_cdev->brightness;
+}
 
 /*
  * Keyboard backlight (also a LED)
@@ -452,70 +420,76 @@ static int asus_kled_set(struct asus_laptop *asus, int kblv)
 	return 0;
 }
 
-static void kled_led_set(struct led_classdev *led_cdev,
-			 enum led_brightness value)
+static void asus_kled_cdev_set(struct led_classdev *led_cdev,
+			      enum led_brightness value)
 {
-	struct asus_laptop *asus = led_to_asus(led_cdev, kled);
+	struct asus_led *led = container_of(led_cdev, struct asus_led, led);
+	struct asus_laptop *asus = led->asus;
 
-	asus->leds.kled_wk = value;
-	queue_work(asus->leds.workqueue, &asus->leds.kled_work);
+        led->wk = value;
+	queue_work(asus->led_workqueue, &led->work);
 }
 
-static void kled_led_update(struct work_struct *work)
+static void asus_kled_cdev_update(struct work_struct *work)
 {
-	struct asus_laptop *asus = work_to_asus(work, kled);
+	struct asus_led *led = container_of(work, struct asus_led, work);
+	struct asus_laptop *asus = led->asus;
 
-	asus_kled_set(asus, asus->leds.kled_wk);
+	asus_kled_set(asus, led->wk);
 }
 
-static enum led_brightness kled_led_get(struct led_classdev *led_cdev)
+static enum led_brightness asus_kled_cdev_get(struct led_classdev *led_cdev)
 {
-	struct asus_laptop *asus = led_to_asus(led_cdev, kled);
+	struct asus_led *led = container_of(led_cdev, struct asus_led, led);
+	struct asus_laptop *asus = led->asus;
 
 	return asus_kled_lvl(asus);
 }
 
 static void asus_led_exit(struct asus_laptop *asus)
 {
-	if (asus->leds.mled.dev)
-		led_classdev_unregister(&asus->leds.mled);
-	if (asus->leds.tled.dev)
-		led_classdev_unregister(&asus->leds.tled);
-	if (asus->leds.pled.dev)
-		led_classdev_unregister(&asus->leds.pled);
-	if (asus->leds.rled.dev)
-		led_classdev_unregister(&asus->leds.rled);
-	if (asus->leds.gled.dev)
-		led_classdev_unregister(&asus->leds.gled);
-	if (asus->leds.kled.dev)
-		led_classdev_unregister(&asus->leds.kled);
-	if (asus->leds.workqueue) {
-		destroy_workqueue(asus->leds.workqueue);
-		asus->leds.workqueue = NULL;
+	if (asus->mled.led.dev)
+		led_classdev_unregister(&asus->mled.led);
+	if (asus->tled.led.dev)
+		led_classdev_unregister(&asus->tled.led);
+	if (asus->pled.led.dev)
+		led_classdev_unregister(&asus->pled.led);
+	if (asus->rled.led.dev)
+		led_classdev_unregister(&asus->rled.led);
+	if (asus->gled.led.dev)
+		led_classdev_unregister(&asus->gled.led);
+	if (asus->kled.led.dev)
+		led_classdev_unregister(&asus->kled.led);
+	if (asus->led_workqueue) {
+		destroy_workqueue(asus->led_workqueue);
+		asus->led_workqueue = NULL;
 	}
 }
 
 /*  Ugly macro, need to fix that later */
-#define ASUS_LED_REGISTER(asus, object, _name, max, method)		\
-	do {								\
-		struct led_classdev *ldev = &asus->leds.object;		\
-									\
-		if (method && acpi_check_handle(asus->handle, method, NULL)) \
-			break ;						\
-									\
-		INIT_WORK(&asus->leds.object##_work, object##_led_update); \
-		ldev->name = "asus::" _name;				\
-		ldev->brightness_set = object##_led_set;		\
-		ldev->brightness_get = object##_led_get;		\
-		ldev->max_brightness = max;				\
-		rv = led_classdev_register(&asus->platform_device->dev, ldev); \
-		if (rv)							\
-			goto error;					\
-	} while (0)
+static int asus_led_register(struct asus_laptop *asus,
+			     struct asus_led *led,
+			     const char *name, const char *method)
+{
+	struct led_classdev *led_cdev = &led->led;
+
+	if (!method || acpi_check_handle(asus->handle, method, NULL))
+	    return 0; /* Led not present */
+
+	led->asus = asus;
+	led->method = method;
+
+	INIT_WORK(&led->work, asus_led_cdev_update);
+	led_cdev->name = name;
+	led_cdev->brightness_set = asus_led_cdev_set;
+	led_cdev->brightness_get = asus_led_cdev_get;
+	led_cdev->max_brightness = 1;
+	return led_classdev_register(&asus->platform_device->dev, led_cdev);
+}
 
 static int asus_led_init(struct asus_laptop *asus)
 {
-	int rv;
+	int r;
 
 	/*
 	 * Functions that actually update the LED's are called from a
@@ -523,22 +497,43 @@ static int asus_led_init(struct asus_laptop *asus)
 	 * subsystem asks, we avoid messing with the Asus ACPI stuff during a
 	 * potentially bad time, such as a timer interrupt.
 	 */
-	asus->leds.workqueue = create_singlethread_workqueue("led_workqueue");
-	if (!asus->leds.workqueue)
+	asus->led_workqueue = create_singlethread_workqueue("led_workqueue");
+	if (!asus->led_workqueue)
 		return -ENOMEM;
 
-	ASUS_LED_REGISTER(asus, mled, "mail", 1, METHOD_MLED);
-	ASUS_LED_REGISTER(asus, tled, "touchpad", 1, METHOD_TLED);
-	ASUS_LED_REGISTER(asus, rled, "record", 1, METHOD_RLED);
-	ASUS_LED_REGISTER(asus, pled, "phone", 1, METHOD_PLED);
-	ASUS_LED_REGISTER(asus, gled, "gaming", 1, METHOD_GLED);
+	r = asus_led_register(asus, &asus->mled, "asus::mail", METHOD_MLED);
+	if (r)
+		goto error;
+	r = asus_led_register(asus, &asus->tled, "asus::touchpad", METHOD_TLED);
+	if (r)
+		goto error;
+	r = asus_led_register(asus, &asus->rled, "asus::record", METHOD_RLED);
+	if (r)
+		goto error;
+	r = asus_led_register(asus, &asus->pled, "asus::phone", METHOD_PLED);
+	if (r)
+		goto error;
+	r = asus_led_register(asus, &asus->gled, "asus::gaming", METHOD_GLED);
+	if (r)
+		goto error;
 	if (!acpi_check_handle(asus->handle, METHOD_KBD_LIGHT_SET, NULL) &&
-	    !acpi_check_handle(asus->handle, METHOD_KBD_LIGHT_GET, NULL))
-		ASUS_LED_REGISTER(asus, kled, "kbd_backlight", 3, NULL);
+	    !acpi_check_handle(asus->handle, METHOD_KBD_LIGHT_GET, NULL)) {
+		struct asus_led *led = &asus->kled;
+		struct led_classdev *cdev = &led->led;
+
+		led->asus = asus;
+
+		INIT_WORK(&led->work, asus_kled_cdev_update);
+		cdev->name = "asus::kbd_backlight";
+		cdev->brightness_set = asus_kled_cdev_set;
+		cdev->brightness_get = asus_kled_cdev_get;
+		cdev->max_brightness = 3;
+		r = led_classdev_register(&asus->platform_device->dev, cdev);
+	}
 error:
-	if (rv)
+	if (r)
 		asus_led_exit(asus);
-	return rv;
+	return r;
 }
 
 /*

commit 18e1311ee71a67497a33521be61ddf6562fa22c0
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Mon Jan 25 23:29:24 2010 +0100

    asus-laptop: add gps rfkill
    
    The rfkill subsystem will enable gps by default.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 1d61094d3b5f..e1df92a22de9 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -50,6 +50,7 @@
 #include <asm/uaccess.h>
 #include <linux/input.h>
 #include <linux/input/sparse-keymap.h>
+#include <linux/rfkill.h>
 
 #define ASUS_LAPTOP_VERSION	"0.42"
 
@@ -238,6 +239,8 @@ struct asus_laptop {
 	bool have_rsts;
 	int lcd_state;
 
+	struct rfkill *gps_rfkill;
+
 	acpi_handle handle;	/* the handle of the hotk device */
 	u32 ledd_status;	/* status of the LED display */
 	u8 light_level;		/* light sensor level */
@@ -1006,7 +1009,6 @@ static ssize_t store_lslvl(struct device *dev, struct device_attribute *attr,
 
 /*
  * GPS
- * TODO: use rfkill
  */
 static int asus_gps_status(struct asus_laptop *asus)
 {
@@ -1052,9 +1054,57 @@ static ssize_t store_gps(struct device *dev, struct device_attribute *attr,
 	ret = asus_gps_switch(asus, !!value);
 	if (ret)
 		return ret;
+	rfkill_set_sw_state(asus->gps_rfkill, !value);
 	return rv;
 }
 
+/*
+ * rfkill
+ */
+static int asus_gps_rfkill_set(void *data, bool blocked)
+{
+	acpi_handle handle = data;
+
+	return asus_gps_switch(handle, !blocked);
+}
+
+static const struct rfkill_ops asus_gps_rfkill_ops = {
+	.set_block = asus_gps_rfkill_set,
+};
+
+static void asus_rfkill_exit(struct asus_laptop *asus)
+{
+	if (asus->gps_rfkill) {
+		rfkill_unregister(asus->gps_rfkill);
+		rfkill_destroy(asus->gps_rfkill);
+		asus->gps_rfkill = NULL;
+	}
+}
+
+static int asus_rfkill_init(struct asus_laptop *asus)
+{
+	int result;
+
+	if (acpi_check_handle(asus->handle, METHOD_GPS_ON, NULL) ||
+	    acpi_check_handle(asus->handle, METHOD_GPS_OFF, NULL) ||
+	    acpi_check_handle(asus->handle, METHOD_GPS_STATUS, NULL))
+		return 0;
+
+	asus->gps_rfkill = rfkill_alloc("asus-gps", &asus->platform_device->dev,
+					RFKILL_TYPE_GPS,
+					&asus_gps_rfkill_ops, NULL);
+	if (!asus->gps_rfkill)
+		return -EINVAL;
+
+	result = rfkill_register(asus->gps_rfkill);
+	if (result) {
+		rfkill_destroy(asus->gps_rfkill);
+		asus->gps_rfkill = NULL;
+	}
+
+	return result;
+}
+
 /*
  * Input device (i.e. hotkeys)
  */
@@ -1416,12 +1466,6 @@ static int __devinit asus_acpi_init(struct asus_laptop *asus)
 		asus_als_level(asus, asus->light_level);
 	}
 
-	/* GPS is on by default */
-	if (!acpi_check_handle(asus->handle, METHOD_GPS_ON, NULL) &&
-	    !acpi_check_handle(asus->handle, METHOD_GPS_OFF, NULL) &&
-	    !acpi_check_handle(asus->handle, METHOD_GPS_STATUS, NULL))
-		asus_gps_switch(asus, 1);
-
 	asus->lcd_state = 1; /* LCD should be on when the module load */
 	return result;
 }
@@ -1469,9 +1513,15 @@ static int __devinit asus_acpi_add(struct acpi_device *device)
 	if (result)
 		goto fail_led;
 
+	result = asus_rfkill_init(asus);
+	if (result)
+		goto fail_rfkill;
+
 	asus_device_present = true;
 	return 0;
 
+fail_rfkill:
+	asus_led_exit(asus);
 fail_led:
 	asus_input_exit(asus);
 fail_input:
@@ -1490,6 +1540,7 @@ static int asus_acpi_remove(struct acpi_device *device, int type)
 	struct asus_laptop *asus = acpi_driver_data(device);
 
 	asus_backlight_exit(asus);
+	asus_rfkill_exit(asus);
 	asus_led_exit(asus);
 	asus_input_exit(asus);
 	asus_platform_exit(asus);

commit 47ee0e99524a7ee0185e3c38423cc17cc1318ddc
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Sun Jan 24 11:17:15 2010 +0100

    asus-laptop: set initial lcd state
    
    There is no way to find the initial lcd state. A quick workaround
    is to set it "on" by default. Anyway this feature is scheduled for removal.
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index ca144d251b00..1d61094d3b5f 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -1421,6 +1421,8 @@ static int __devinit asus_acpi_init(struct asus_laptop *asus)
 	    !acpi_check_handle(asus->handle, METHOD_GPS_OFF, NULL) &&
 	    !acpi_check_handle(asus->handle, METHOD_GPS_STATUS, NULL))
 		asus_gps_switch(asus, 1);
+
+	asus->lcd_state = 1; /* LCD should be on when the module load */
 	return result;
 }
 

commit 75747129a994463e36c2516e8071771427d8494b
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Sun Jan 24 11:15:42 2010 +0100

    asus-laptop: leds, remove dead code and fix asus_led_exit()/asus_led_init()
    
    These bug where introduced in "asus-laptop: code movement".
    
    Signed-off-by: Corentin Chary <corentin.chary@gmail.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 516add3c340e..ca144d251b00 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -371,13 +371,7 @@ static int asus_led_set(struct asus_laptop *asus, char *method,
 				     enum led_brightness value);	\
 	static enum led_brightness object##_led_get(			\
 		struct led_classdev *led_cdev);				\
-	static void object##_led_update(struct work_struct *ignored);	\
-	static struct led_classdev object##_led = {			\
-		.name           = "asus::" ledname,			\
-		.brightness_set = object##_led_set,			\
-		.brightness_get = object##_led_get,			\
-		.max_brightness = max					\
-	}
+	static void object##_led_update(struct work_struct *ignored);
 
 ASUS_LED(mled, "mail", 1);
 ASUS_LED(tled, "touchpad", 1);
@@ -478,18 +472,20 @@ static enum led_brightness kled_led_get(struct led_classdev *led_cdev)
 	return asus_kled_lvl(asus);
 }
 
-#define ASUS_LED_UNREGISTER(object)				\
-	if (object##_led.dev)					\
-		led_classdev_unregister(&object##_led)
-
 static void asus_led_exit(struct asus_laptop *asus)
 {
-	ASUS_LED_UNREGISTER(mled);
-	ASUS_LED_UNREGISTER(tled);
-	ASUS_LED_UNREGISTER(pled);
-	ASUS_LED_UNREGISTER(rled);
-	ASUS_LED_UNREGISTER(gled);
-	ASUS_LED_UNREGISTER(kled);
+	if (asus->leds.mled.dev)
+		led_classdev_unregister(&asus->leds.mled);
+	if (asus->leds.tled.dev)
+		led_classdev_unregister(&asus->leds.tled);
+	if (asus->leds.pled.dev)
+		led_classdev_unregister(&asus->leds.pled);
+	if (asus->leds.rled.dev)
+		led_classdev_unregister(&asus->leds.rled);
+	if (asus->leds.gled.dev)
+		led_classdev_unregister(&asus->leds.gled);
+	if (asus->leds.kled.dev)
+		led_classdev_unregister(&asus->leds.kled);
 	if (asus->leds.workqueue) {
 		destroy_workqueue(asus->leds.workqueue);
 		asus->leds.workqueue = NULL;
@@ -507,6 +503,7 @@ static void asus_led_exit(struct asus_laptop *asus)
 		INIT_WORK(&asus->leds.object##_work, object##_led_update); \
 		ldev->name = "asus::" _name;				\
 		ldev->brightness_set = object##_led_set;		\
+		ldev->brightness_get = object##_led_get;		\
 		ldev->max_brightness = max;				\
 		rv = led_classdev_register(&asus->platform_device->dev, ldev); \
 		if (rv)							\

commit a539df5e1548751e352990c518e88af50e6111b8
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Mon Jan 25 22:53:21 2010 +0100

    asus-laptop: add backlight changes notifications
    
    We don't want to send KEY_BRIGHTNESSDOWN or KEY_BRIGHTNESSUP
    because it would be a lie to tell userspace that we want
    to change the brightness while it's actually done by the
    firmware.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 4f3c4674498b..516add3c340e 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -93,8 +93,10 @@ MODULE_PARM_DESC(bluetooth_status, "Set the wireless status on boot "
 /*
  * Some events we use, same for all Asus
  */
-#define ATKD_BR_UP	0x10
-#define ATKD_BR_DOWN	0x20
+#define ATKD_BR_UP	0x10	// (event & ~ATKD_BR_UP) = brightness level
+#define ATKD_BR_DOWN	0x20	// (event & ~ATKD_BR_DOWN) = britghness level
+#define ATKD_BR_MIN	ATKD_BR_UP
+#define ATKD_BR_MAX	(ATKD_BR_DOWN | 0xF)	// 0x2f
 #define ATKD_LCD_ON	0x33
 #define ATKD_LCD_OFF	0x34
 
@@ -245,11 +247,13 @@ struct asus_laptop {
 };
 
 static const struct key_entry asus_keymap[] = {
+	/* Lenovo SL Specific keycodes */
 	{KE_KEY, 0x02, { KEY_SCREENLOCK } },
 	{KE_KEY, 0x05, { KEY_WLAN } },
 	{KE_KEY, 0x08, { KEY_F13 } },
 	{KE_KEY, 0x17, { KEY_ZOOM } },
 	{KE_KEY, 0x1f, { KEY_BATTERY } },
+	/* End of Lenovo SL Specific keycodes */
 	{KE_KEY, 0x30, { KEY_VOLUMEUP } },
 	{KE_KEY, 0x31, { KEY_VOLUMEDOWN } },
 	{KE_KEY, 0x32, { KEY_MUTE } },
@@ -626,6 +630,16 @@ static struct backlight_ops asusbl_ops = {
 	.update_status = update_bl_status,
 };
 
+static int asus_backlight_notify(struct asus_laptop *asus)
+{
+	struct backlight_device *bd = asus->backlight_device;
+	int old = bd->props.brightness;
+
+	backlight_force_update(bd, BACKLIGHT_UPDATE_HOTKEY);
+
+	return old;
+}
+
 static int asus_backlight_init(struct asus_laptop *asus)
 {
 	struct backlight_device *bd;
@@ -656,6 +670,7 @@ static void asus_backlight_exit(struct asus_laptop *asus)
 {
 	if (asus->backlight_device)
 		backlight_device_unregister(asus->backlight_device);
+	asus->backlight_device = NULL;
 }
 
 /*
@@ -1121,6 +1136,16 @@ static void asus_acpi_notify(struct acpi_device *device, u32 event)
 					dev_name(&asus->device->dev), event,
 					count);
 
+	/* Brightness events are special */
+	if (event >= ATKD_BR_MIN && event <= ATKD_BR_MAX) {
+
+		/* Ignore them completely if the acpi video driver is used */
+		if (asus->backlight_device != NULL) {
+			/* Update the backlight device. */
+			asus_backlight_notify(asus);
+		}
+		return ;
+	}
 	asus_input_notify(asus, event);
 }
 

commit 7f607d71065b6b089f59b78b54144c3fb93ad629
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sun Jan 17 17:37:19 2010 +0100

    asus-laptop: add bluetooth keys found on M9V
    
    Reported by Andrey F. Ilchuk
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 8042568528e5..4f3c4674498b 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -272,6 +272,8 @@ static const struct key_entry asus_keymap[] = {
 	{KE_KEY, 0x62, { KEY_SWITCHVIDEOMODE } },
 	{KE_KEY, 0x63, { KEY_SWITCHVIDEOMODE } },
 	{KE_KEY, 0x6B, { KEY_F13 } }, /* Lock Touchpad */
+	{KE_KEY, 0x7E, { KEY_BLUETOOTH } },
+	{KE_KEY, 0x7D, { KEY_BLUETOOTH } },
 	{KE_KEY, 0x82, { KEY_CAMERA } },
 	{KE_KEY, 0x88, { KEY_WLAN  } },
 	{KE_KEY, 0x8A, { KEY_PROG1 } },

commit 66a71dd1f7c4eee636867d381995b7e6ae489dc3
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Mon Jan 25 22:50:11 2010 +0100

    asus-laptop: switch to sparse keymap library
    
    This patch is based on Dmitry Torokhov's patch with
    some modifications and cleanups.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index bb8fb45c45e9..8042568528e5 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -49,6 +49,7 @@
 #include <acpi/acpi_bus.h>
 #include <asm/uaccess.h>
 #include <linux/input.h>
+#include <linux/input/sparse-keymap.h>
 
 #define ASUS_LAPTOP_VERSION	"0.42"
 
@@ -243,52 +244,45 @@ struct asus_laptop {
 	u16 *keycode_map;
 };
 
-struct key_entry {
-	char type;
-	u8 code;
-	u16 keycode;
-};
-
-enum { KE_KEY, KE_END };
-
 static const struct key_entry asus_keymap[] = {
-	{KE_KEY, 0x02, KEY_SCREENLOCK},
-	{KE_KEY, 0x05, KEY_WLAN},
-	{KE_KEY, 0x08, KEY_F13},
-	{KE_KEY, 0x17, KEY_ZOOM},
-	{KE_KEY, 0x1f, KEY_BATTERY},
-	{KE_KEY, 0x30, KEY_VOLUMEUP},
-	{KE_KEY, 0x31, KEY_VOLUMEDOWN},
-	{KE_KEY, 0x32, KEY_MUTE},
-	{KE_KEY, 0x33, KEY_SWITCHVIDEOMODE},
-	{KE_KEY, 0x34, KEY_SWITCHVIDEOMODE},
-	{KE_KEY, 0x40, KEY_PREVIOUSSONG},
-	{KE_KEY, 0x41, KEY_NEXTSONG},
-	{KE_KEY, 0x43, KEY_STOPCD},
-	{KE_KEY, 0x45, KEY_PLAYPAUSE},
-	{KE_KEY, 0x4c, KEY_MEDIA},
-	{KE_KEY, 0x50, KEY_EMAIL},
-	{KE_KEY, 0x51, KEY_WWW},
-	{KE_KEY, 0x55, KEY_CALC},
-	{KE_KEY, 0x5C, KEY_SCREENLOCK},  /* Screenlock */
-	{KE_KEY, 0x5D, KEY_WLAN},
-	{KE_KEY, 0x5E, KEY_WLAN},
-	{KE_KEY, 0x5F, KEY_WLAN},
-	{KE_KEY, 0x60, KEY_SWITCHVIDEOMODE},
-	{KE_KEY, 0x61, KEY_SWITCHVIDEOMODE},
-	{KE_KEY, 0x62, KEY_SWITCHVIDEOMODE},
-	{KE_KEY, 0x63, KEY_SWITCHVIDEOMODE},
-	{KE_KEY, 0x6B, KEY_F13}, /* Lock Touchpad */
-	{KE_KEY, 0x82, KEY_CAMERA},
-	{KE_KEY, 0x88, KEY_WLAN },
-	{KE_KEY, 0x8A, KEY_PROG1},
-	{KE_KEY, 0x95, KEY_MEDIA},
-	{KE_KEY, 0x99, KEY_PHONE},
-	{KE_KEY, 0xc4, KEY_KBDILLUMUP},
-	{KE_KEY, 0xc5, KEY_KBDILLUMDOWN},
+	{KE_KEY, 0x02, { KEY_SCREENLOCK } },
+	{KE_KEY, 0x05, { KEY_WLAN } },
+	{KE_KEY, 0x08, { KEY_F13 } },
+	{KE_KEY, 0x17, { KEY_ZOOM } },
+	{KE_KEY, 0x1f, { KEY_BATTERY } },
+	{KE_KEY, 0x30, { KEY_VOLUMEUP } },
+	{KE_KEY, 0x31, { KEY_VOLUMEDOWN } },
+	{KE_KEY, 0x32, { KEY_MUTE } },
+	{KE_KEY, 0x33, { KEY_SWITCHVIDEOMODE } },
+	{KE_KEY, 0x34, { KEY_SWITCHVIDEOMODE } },
+	{KE_KEY, 0x40, { KEY_PREVIOUSSONG } },
+	{KE_KEY, 0x41, { KEY_NEXTSONG } },
+	{KE_KEY, 0x43, { KEY_STOPCD } },
+	{KE_KEY, 0x45, { KEY_PLAYPAUSE } },
+	{KE_KEY, 0x4c, { KEY_MEDIA } },
+	{KE_KEY, 0x50, { KEY_EMAIL } },
+	{KE_KEY, 0x51, { KEY_WWW } },
+	{KE_KEY, 0x55, { KEY_CALC } },
+	{KE_KEY, 0x5C, { KEY_SCREENLOCK } },  /* Screenlock */
+	{KE_KEY, 0x5D, { KEY_WLAN } },
+	{KE_KEY, 0x5E, { KEY_WLAN } },
+	{KE_KEY, 0x5F, { KEY_WLAN } },
+	{KE_KEY, 0x60, { KEY_SWITCHVIDEOMODE } },
+	{KE_KEY, 0x61, { KEY_SWITCHVIDEOMODE } },
+	{KE_KEY, 0x62, { KEY_SWITCHVIDEOMODE } },
+	{KE_KEY, 0x63, { KEY_SWITCHVIDEOMODE } },
+	{KE_KEY, 0x6B, { KEY_F13 } }, /* Lock Touchpad */
+	{KE_KEY, 0x82, { KEY_CAMERA } },
+	{KE_KEY, 0x88, { KEY_WLAN  } },
+	{KE_KEY, 0x8A, { KEY_PROG1 } },
+	{KE_KEY, 0x95, { KEY_MEDIA } },
+	{KE_KEY, 0x99, { KEY_PHONE } },
+	{KE_KEY, 0xc4, { KEY_KBDILLUMUP } },
+	{KE_KEY, 0xc5, { KEY_KBDILLUMDOWN } },
 	{KE_END, 0},
 };
 
+
 /*
  * This function evaluates an ACPI method, given an int as parameter, the
  * method is searched within the scope of the handle, can be NULL. The output
@@ -1050,123 +1044,55 @@ static ssize_t store_gps(struct device *dev, struct device_attribute *attr,
 /*
  * Input device (i.e. hotkeys)
  */
-static struct key_entry *asus_get_entry_by_scancode(struct asus_laptop *asus,
-						    int code)
-{
-	struct key_entry *key;
-
-	for (key = asus->keymap; key->type != KE_END; key++)
-		if (code == key->code)
-			return key;
-
-	return NULL;
-}
-
-static struct key_entry *asus_get_entry_by_keycode(struct asus_laptop *asus,
-						   int code)
-{
-	struct key_entry *key;
-
-	for (key = asus->keymap; key->type != KE_END; key++)
-		if (code == key->keycode && key->type == KE_KEY)
-			return key;
-
-	return NULL;
-}
-
-static int asus_getkeycode(struct input_dev *dev, int scancode, int *keycode)
-{
-	struct asus_laptop *asus = input_get_drvdata(dev);
-	struct key_entry *key = asus_get_entry_by_scancode(asus, scancode);
-
-	if (key && key->type == KE_KEY) {
-		*keycode = key->keycode;
-		return 0;
-	}
-
-	return -EINVAL;
-}
-
-static int asus_setkeycode(struct input_dev *dev, int scancode, int keycode)
-{
-	struct asus_laptop *asus = input_get_drvdata(dev);
-	struct key_entry *key;
-	int old_keycode;
-
-	if (keycode < 0 || keycode > KEY_MAX)
-		return -EINVAL;
-
-	key = asus_get_entry_by_scancode(asus, scancode);
-	if (key && key->type == KE_KEY) {
-		old_keycode = key->keycode;
-		key->keycode = keycode;
-		set_bit(keycode, dev->keybit);
-		if (!asus_get_entry_by_keycode(asus, old_keycode))
-			clear_bit(old_keycode, dev->keybit);
-		return 0;
-	}
-
-	return -EINVAL;
-}
-
 static void asus_input_notify(struct asus_laptop *asus, int event)
 {
-	struct key_entry *key;
-
-	key = asus_get_entry_by_scancode(asus, event);
-	if (!key)
-		return ;
-
-	switch (key->type) {
-	case KE_KEY:
-		input_report_key(asus->inputdev, key->keycode, 1);
-		input_sync(asus->inputdev);
-		input_report_key(asus->inputdev, key->keycode, 0);
-		input_sync(asus->inputdev);
-		break;
-	}
+	if (asus->inputdev)
+		sparse_keymap_report_event(asus->inputdev, event, 1, true);
 }
 
 static int asus_input_init(struct asus_laptop *asus)
 {
-	const struct key_entry *key;
-	int result;
+	struct input_dev *input;
+	int error;
 
-	asus->inputdev = input_allocate_device();
-	if (!asus->inputdev) {
+	input = input_allocate_device();
+	if (!input) {
 		pr_info("Unable to allocate input device\n");
 		return 0;
 	}
-	asus->inputdev->name = "Asus Laptop extra buttons";
-	asus->inputdev->dev.parent = &asus->platform_device->dev;
-	asus->inputdev->phys = ASUS_LAPTOP_FILE "/input0";
-	asus->inputdev->id.bustype = BUS_HOST;
-	asus->inputdev->getkeycode = asus_getkeycode;
-	asus->inputdev->setkeycode = asus_setkeycode;
-	input_set_drvdata(asus->inputdev, asus);
-
-	asus->keymap = kmemdup(asus_keymap, sizeof(asus_keymap),
-				GFP_KERNEL);
-	for (key = asus->keymap; key->type != KE_END; key++) {
-		switch (key->type) {
-		case KE_KEY:
-			set_bit(EV_KEY, asus->inputdev->evbit);
-			set_bit(key->keycode, asus->inputdev->keybit);
-			break;
-		}
+	input->name = "Asus Laptop extra buttons";
+	input->phys = ASUS_LAPTOP_FILE "/input0";
+	input->id.bustype = BUS_HOST;
+	input->dev.parent = &asus->platform_device->dev;
+	input_set_drvdata(input, asus);
+
+	error = sparse_keymap_setup(input, asus_keymap, NULL);
+	if (error) {
+		pr_err("Unable to setup input device keymap\n");
+		goto err_keymap;
 	}
-	result = input_register_device(asus->inputdev);
-	if (result) {
+	error = input_register_device(input);
+	if (error) {
 		pr_info("Unable to register input device\n");
-		input_free_device(asus->inputdev);
+		goto err_device;
 	}
-	return result;
+
+	asus->inputdev = input;
+	return 0;
+
+err_keymap:
+	sparse_keymap_free(input);
+err_device:
+	input_free_device(input);
+	return error;
 }
 
 static void asus_input_exit(struct asus_laptop *asus)
 {
-	if (asus->inputdev)
+	if (asus->inputdev) {
+		sparse_keymap_free(asus->inputdev);
 		input_unregister_device(asus->inputdev);
+	}
 }
 
 /*

commit d0930a2d42c5a28039d8cc2376a7dff4e59c5f7a
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sun Jan 17 17:21:13 2010 +0100

    asus-laptop: rename wireless_status to wlan_status to avoid confusion
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index aad6b9300f5d..bb8fb45c45e9 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -76,11 +76,11 @@ static uint wapf = 1;
 module_param(wapf, uint, 0644);
 MODULE_PARM_DESC(wapf, "WAPF value");
 
-static uint wireless_status = 1;
+static uint wlan_status = 1;
 static uint bluetooth_status = 1;
 
-module_param(wireless_status, uint, 0644);
-MODULE_PARM_DESC(wireless_status, "Set the wireless status on boot "
+module_param(wlan_status, uint, 0644);
+MODULE_PARM_DESC(wlan_status, "Set the wireless status on boot "
 		 "(0 = disabled, 1 = enabled, -1 = don't do anything). "
 		 "default is 1");
 
@@ -1446,8 +1446,8 @@ static int __devinit asus_acpi_init(struct asus_laptop *asus)
 	if (bluetooth_status >= 0)
 		asus_bluetooth_set(asus, !!bluetooth_status);
 
-	if (wireless_status >= 0)
-		asus_wlan_set(asus, !!wireless_status);
+	if (wlan_status >= 0)
+		asus_wlan_set(asus, !!wlan_status);
 
 	/* Keyboard Backlight is on by default */
 	if (!acpi_check_handle(asus->handle, METHOD_KBD_LIGHT_SET, NULL))

commit e5593bf18be79b4897c7ec8b392dc7f07cbc1b11
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sun Jan 17 17:20:11 2010 +0100

    asus-laptop: add error check for write_acpi_int calls
    
    Also add to helpers for bluetooth and wlan.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 671fad96c275..aad6b9300f5d 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -350,7 +350,7 @@ static int acpi_check_handle(acpi_handle handle, const char *method,
 }
 
 /* Generic LED function */
-static void asus_led_set(struct asus_laptop *asus, char *method,
+static int asus_led_set(struct asus_laptop *asus, char *method,
 			 int value)
 {
 	if (!strcmp(method, METHOD_MLED))
@@ -360,7 +360,7 @@ static void asus_led_set(struct asus_laptop *asus, char *method,
 	else
 		value = !!value;
 
-	write_acpi_int(asus->handle, method, value);
+	return write_acpi_int(asus->handle, method, value);
 }
 
 /*
@@ -817,6 +817,15 @@ static int asus_wireless_status(struct asus_laptop *asus, int mask)
 /*
  * WLAN
  */
+static int asus_wlan_set(struct asus_laptop *asus, int status)
+{
+	if (write_acpi_int(asus->handle, METHOD_WLAN, !!status)) {
+		pr_warning("Error setting wlan status to %d", status);
+		return -EIO;
+	}
+	return 0;
+}
+
 static ssize_t show_wlan(struct device *dev,
 			 struct device_attribute *attr, char *buf)
 {
@@ -836,6 +845,15 @@ static ssize_t store_wlan(struct device *dev, struct device_attribute *attr,
 /*
  * Bluetooth
  */
+static int asus_bluetooth_set(struct asus_laptop *asus, int status)
+{
+	if (write_acpi_int(asus->handle, METHOD_BLUETOOTH, !!status)) {
+		pr_warning("Error setting bluetooth status to %d", status);
+		return -EIO;
+	}
+	return 0;
+}
+
 static ssize_t show_bluetooth(struct device *dev,
 			      struct device_attribute *attr, char *buf)
 {
@@ -1353,8 +1371,8 @@ static int asus_laptop_get_info(struct asus_laptop *asus)
 		       (uint) bsts_result);
 
 	/* This too ... */
-	write_acpi_int(asus->handle, "CWAP", wapf);
-
+	if (write_acpi_int(asus->handle, "CWAP", wapf))
+		pr_err("Error calling CWAP(%d)\n", wapf);
 	/*
 	 * Try to match the object returned by INIT to the specific model.
 	 * Handle every possible object (or the lack of thereof) the DSDT
@@ -1426,11 +1444,10 @@ static int __devinit asus_acpi_init(struct asus_laptop *asus)
 
 	/* WLED and BLED are on by default */
 	if (bluetooth_status >= 0)
-		write_acpi_int(asus->handle, METHOD_BLUETOOTH,
-			       !!bluetooth_status);
+		asus_bluetooth_set(asus, !!bluetooth_status);
+
 	if (wireless_status >= 0)
-		write_acpi_int(asus->handle, METHOD_WLAN,
-			       !!wireless_status);
+		asus_wlan_set(asus, !!wireless_status);
 
 	/* Keyboard Backlight is on by default */
 	if (!acpi_check_handle(asus->handle, METHOD_KBD_LIGHT_SET, NULL))

commit d99b577c729c4a29679fb1f605f9ccace154e0e5
Author: Corentin Chary <corentin.chary@gmail.com>
Date:   Fri Jan 22 21:20:57 2010 +0100

    asus-laptop: stop using ASUS_HANDLE and use relative methods instead
    
    Stop using ASUS_HANDLE because most of the time it is not needed.
    This macro was introduced to display_get and lcd_switch which are not
    part of the interface provided by Asus, and are scheduled for removal.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index ae4f80886577..671fad96c275 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -115,27 +115,27 @@ MODULE_PARM_DESC(bluetooth_status, "Set the wireless status on boot "
 	static char *object##_paths[] = { paths }
 
 /* LED */
-ASUS_HANDLE(mled_set, ASUS_LAPTOP_PREFIX "MLED");
-ASUS_HANDLE(tled_set, ASUS_LAPTOP_PREFIX "TLED");
-ASUS_HANDLE(rled_set, ASUS_LAPTOP_PREFIX "RLED");	/* W1JC */
-ASUS_HANDLE(pled_set, ASUS_LAPTOP_PREFIX "PLED");	/* A7J */
-ASUS_HANDLE(gled_set, ASUS_LAPTOP_PREFIX "GLED");	/* G1, G2 (probably) */
+#define METHOD_MLED		"MLED"
+#define METHOD_TLED		"TLED"
+#define METHOD_RLED		"RLED"	/* W1JC */
+#define METHOD_PLED		"PLED"	/* A7J */
+#define METHOD_GLED		"GLED"	/* G1, G2 (probably) */
 
 /* LEDD */
-ASUS_HANDLE(ledd_set, ASUS_LAPTOP_PREFIX "SLCM");
+#define METHOD_LEDD		"SLCM"
 
 /*
  * Bluetooth and WLAN
  * WLED and BLED are not handled like other XLED, because in some dsdt
  * they also control the WLAN/Bluetooth device.
  */
-ASUS_HANDLE(wl_switch, ASUS_LAPTOP_PREFIX "WLED");
-ASUS_HANDLE(bt_switch, ASUS_LAPTOP_PREFIX "BLED");
-ASUS_HANDLE(wireless_status, ASUS_LAPTOP_PREFIX "RSTS");	/* All new models */
+#define METHOD_WLAN		"WLED"
+#define METHOD_BLUETOOTH	"BLED"
+#define METHOD_WL_STATUS	"RSTS"
 
 /* Brightness */
-ASUS_HANDLE(brightness_set, ASUS_LAPTOP_PREFIX "SPLV");
-ASUS_HANDLE(brightness_get, ASUS_LAPTOP_PREFIX "GPLV");
+#define METHOD_BRIGHTNESS_SET	"SPLV"
+#define METHOD_BRIGHTNESS_GET	"GPLV"
 
 /* Backlight */
 ASUS_HANDLE(lcd_switch, "\\_SB.PCI0.SBRG.EC0._Q10",	/* All new models */
@@ -148,7 +148,7 @@ ASUS_HANDLE(lcd_switch, "\\_SB.PCI0.SBRG.EC0._Q10",	/* All new models */
 	    "\\Q10");		/* A2x, L2D, L3D, M2E */
 
 /* Display */
-ASUS_HANDLE(display_set, ASUS_LAPTOP_PREFIX "SDSP");
+#define METHOD_SWITCH_DISPLAY	"SDSP"
 ASUS_HANDLE(display_get,
 	    /* A6B, A6K A6R A7D F3JM L4R M6R A3G M6A M6V VX-1 V6J V6V W3Z */
 	    "\\_SB.PCI0.P0P1.VGA.GETD",
@@ -173,18 +173,18 @@ ASUS_HANDLE(display_get,
 	    /* A3F A6F A3N A3L M6N W3N W6A */
 	    "\\SSTE");
 
-ASUS_HANDLE(ls_switch, ASUS_LAPTOP_PREFIX "ALSC"); /* Z71A Z71V */
-ASUS_HANDLE(ls_level, ASUS_LAPTOP_PREFIX "ALSL");	 /* Z71A Z71V */
+#define METHOD_ALS_CONTROL	"ALSC" /* Z71A Z71V */
+#define METHOD_ALS_LEVEL	"ALSL" /* Z71A Z71V */
 
 /* GPS */
 /* R2H use different handle for GPS on/off */
-ASUS_HANDLE(gps_on, ASUS_LAPTOP_PREFIX "SDON");	/* R2H */
-ASUS_HANDLE(gps_off, ASUS_LAPTOP_PREFIX "SDOF");	/* R2H */
-ASUS_HANDLE(gps_status, ASUS_LAPTOP_PREFIX "GPST");
+#define METHOD_GPS_ON		"SDON"
+#define METHOD_GPS_OFF		"SDOF"
+#define METHOD_GPS_STATUS	"GPST"
 
 /* Keyboard light */
-ASUS_HANDLE(kled_set, ASUS_LAPTOP_PREFIX "SLKB");
-ASUS_HANDLE(kled_get, ASUS_LAPTOP_PREFIX "GLKB");
+#define METHOD_KBD_LIGHT_SET	"SLKB"
+#define METHOD_KBD_LIGHT_GET	"GLKB"
 
 /*
  * Define a specific led structure to keep the main structure clean
@@ -323,18 +323,44 @@ static int write_acpi_int(acpi_handle handle, const char *method, int val)
 	return write_acpi_int_ret(handle, method, val, NULL);
 }
 
+static int acpi_check_handle(acpi_handle handle, const char *method,
+			     acpi_handle *ret)
+{
+	acpi_status status;
+
+	if (method == NULL)
+		return -ENODEV;
+
+	if (ret)
+		status = acpi_get_handle(handle, (char *)method,
+					 ret);
+	else {
+		acpi_handle dummy;
+
+		status = acpi_get_handle(handle, (char *)method,
+					 &dummy);
+	}
+
+	if (status != AE_OK) {
+		if (ret)
+			pr_warning("Error finding %s\n", method);
+		return -ENODEV;
+	}
+	return 0;
+}
+
 /* Generic LED function */
-static void asus_led_set(struct asus_laptop *asus, acpi_handle handle,
+static void asus_led_set(struct asus_laptop *asus, char *method,
 			 int value)
 {
-	if (handle == mled_set_handle)
+	if (!strcmp(method, METHOD_MLED))
 		value = !value;
-	else if (handle == gled_set_handle)
+	else if (!strcmp(method, METHOD_GLED))
 		value = !value + 1;
 	else
 		value = !!value;
 
-	write_acpi_int(handle, NULL, value);
+	write_acpi_int(asus->handle, method, value);
 }
 
 /*
@@ -361,7 +387,7 @@ ASUS_LED(gled, "gaming", 1);
 ASUS_LED(kled, "kbd_backlight", 3);
 
 /* /sys/class/led handlers */
-#define ASUS_LED_HANDLER(object, mask)					\
+#define ASUS_LED_HANDLER(object, method)				\
 	static void object##_led_set(struct led_classdev *led_cdev,	\
 				     enum led_brightness value)		\
 	{								\
@@ -377,7 +403,7 @@ ASUS_LED(kled, "kbd_backlight", 3);
 		struct asus_laptop *asus = work_to_asus(work, object);	\
 									\
 		int value = asus->leds.object##_wk;			\
-		asus_led_set(asus, object##_set_handle, value);		\
+		asus_led_set(asus, method, value);			\
 	}								\
 	static enum led_brightness object##_led_get(			\
 		struct led_classdev *led_cdev)				\
@@ -385,16 +411,16 @@ ASUS_LED(kled, "kbd_backlight", 3);
 		return led_cdev->brightness;				\
 	}
 
-ASUS_LED_HANDLER(mled, MLED_ON);
-ASUS_LED_HANDLER(pled, PLED_ON);
-ASUS_LED_HANDLER(rled, RLED_ON);
-ASUS_LED_HANDLER(tled, TLED_ON);
-ASUS_LED_HANDLER(gled, GLED_ON);
+ASUS_LED_HANDLER(mled, METHOD_MLED);
+ASUS_LED_HANDLER(pled, METHOD_PLED);
+ASUS_LED_HANDLER(rled, METHOD_RLED);
+ASUS_LED_HANDLER(tled, METHOD_TLED);
+ASUS_LED_HANDLER(gled, METHOD_GLED);
 
 /*
  * Keyboard backlight (also a LED)
  */
-static int asus_kled_lvl(void)
+static int asus_kled_lvl(struct asus_laptop *asus)
 {
 	unsigned long long kblv;
 	struct acpi_object_list params;
@@ -406,7 +432,8 @@ static int asus_kled_lvl(void)
 	in_obj.type = ACPI_TYPE_INTEGER;
 	in_obj.integer.value = 2;
 
-	rv = acpi_evaluate_integer(kled_get_handle, NULL, &params, &kblv);
+	rv = acpi_evaluate_integer(asus->handle, METHOD_KBD_LIGHT_GET,
+				   &params, &kblv);
 	if (ACPI_FAILURE(rv)) {
 		pr_warning("Error reading kled level\n");
 		return -ENODEV;
@@ -421,7 +448,7 @@ static int asus_kled_set(struct asus_laptop *asus, int kblv)
 	else
 		kblv = 0;
 
-	if (write_acpi_int(kled_set_handle, NULL, kblv)) {
+	if (write_acpi_int(asus->handle, METHOD_KBD_LIGHT_SET, kblv)) {
 		pr_warning("Keyboard LED display write failed\n");
 		return -EINVAL;
 	}
@@ -446,7 +473,9 @@ static void kled_led_update(struct work_struct *work)
 
 static enum led_brightness kled_led_get(struct led_classdev *led_cdev)
 {
-	return asus_kled_lvl();
+	struct asus_laptop *asus = led_to_asus(led_cdev, kled);
+
+	return asus_kled_lvl(asus);
 }
 
 #define ASUS_LED_UNREGISTER(object)				\
@@ -468,10 +497,11 @@ static void asus_led_exit(struct asus_laptop *asus)
 }
 
 /*  Ugly macro, need to fix that later */
-#define ASUS_LED_REGISTER(asus, object, _name, max)			\
+#define ASUS_LED_REGISTER(asus, object, _name, max, method)		\
 	do {								\
 		struct led_classdev *ldev = &asus->leds.object;		\
-		if (!object##_set_handle)				\
+									\
+		if (method && acpi_check_handle(asus->handle, method, NULL)) \
 			break ;						\
 									\
 		INIT_WORK(&asus->leds.object##_work, object##_led_update); \
@@ -497,13 +527,14 @@ static int asus_led_init(struct asus_laptop *asus)
 	if (!asus->leds.workqueue)
 		return -ENOMEM;
 
-	ASUS_LED_REGISTER(asus, mled, "mail", 1);
-	ASUS_LED_REGISTER(asus, tled, "touchpad", 1);
-	ASUS_LED_REGISTER(asus, rled, "record", 1);
-	ASUS_LED_REGISTER(asus, pled, "phone", 1);
-	ASUS_LED_REGISTER(asus, gled, "gaming", 1);
-	if (kled_set_handle && kled_get_handle)
-		ASUS_LED_REGISTER(asus, kled, "kbd_backlight", 3);
+	ASUS_LED_REGISTER(asus, mled, "mail", 1, METHOD_MLED);
+	ASUS_LED_REGISTER(asus, tled, "touchpad", 1, METHOD_TLED);
+	ASUS_LED_REGISTER(asus, rled, "record", 1, METHOD_RLED);
+	ASUS_LED_REGISTER(asus, pled, "phone", 1, METHOD_PLED);
+	ASUS_LED_REGISTER(asus, gled, "gaming", 1, METHOD_GLED);
+	if (!acpi_check_handle(asus->handle, METHOD_KBD_LIGHT_SET, NULL) &&
+	    !acpi_check_handle(asus->handle, METHOD_KBD_LIGHT_GET, NULL))
+		ASUS_LED_REGISTER(asus, kled, "kbd_backlight", 3, NULL);
 error:
 	if (rv)
 		asus_led_exit(asus);
@@ -557,10 +588,12 @@ static void lcd_blank(struct asus_laptop *asus, int blank)
 
 static int asus_read_brightness(struct backlight_device *bd)
 {
+	struct asus_laptop *asus = bl_get_data(bd);
 	unsigned long long value;
 	acpi_status rv = AE_OK;
 
-	rv = acpi_evaluate_integer(brightness_get_handle, NULL, NULL, &value);
+	rv = acpi_evaluate_integer(asus->handle, METHOD_BRIGHTNESS_GET,
+				   NULL, &value);
 	if (ACPI_FAILURE(rv))
 		pr_warning("Error reading brightness\n");
 
@@ -569,7 +602,9 @@ static int asus_read_brightness(struct backlight_device *bd)
 
 static int asus_set_brightness(struct backlight_device *bd, int value)
 {
-	if (write_acpi_int(brightness_set_handle, NULL, value)) {
+	struct asus_laptop *asus = bl_get_data(bd);
+
+	if (write_acpi_int(asus->handle, METHOD_BRIGHTNESS_SET, value)) {
 		pr_warning("Error changing brightness\n");
 		return -EIO;
 	}
@@ -600,7 +635,9 @@ static int asus_backlight_init(struct asus_laptop *asus)
 	struct backlight_device *bd;
 	struct device *dev = &asus->platform_device->dev;
 
-	if (brightness_set_handle && lcd_switch_handle) {
+	if (!acpi_check_handle(asus->handle, METHOD_BRIGHTNESS_GET, NULL) &&
+	    !acpi_check_handle(asus->handle, METHOD_BRIGHTNESS_SET, NULL) &&
+	    lcd_switch_handle) {
 		bd = backlight_device_register(ASUS_LAPTOP_FILE, dev,
 					       asus, &asusbl_ops);
 		if (IS_ERR(bd)) {
@@ -612,8 +649,8 @@ static int asus_backlight_init(struct asus_laptop *asus)
 		asus->backlight_device = bd;
 
 		bd->props.max_brightness = 15;
-		bd->props.brightness = asus_read_brightness(NULL);
 		bd->props.power = FB_BLANK_UNBLANK;
+		bd->props.brightness = asus_read_brightness(bd);
 		backlight_update_status(bd);
 	}
 	return 0;
@@ -716,7 +753,7 @@ static int parse_arg(const char *buf, unsigned long count, int *val)
 
 static ssize_t sysfs_acpi_set(struct asus_laptop *asus,
 			      const char *buf, size_t count,
-			      acpi_handle handle)
+			      const char *method)
 {
 	int rv, value;
 	int out = 0;
@@ -725,7 +762,7 @@ static ssize_t sysfs_acpi_set(struct asus_laptop *asus,
 	if (rv > 0)
 		out = value ? 1 : 0;
 
-	if (write_acpi_int(handle, NULL, value))
+	if (write_acpi_int(asus->handle, method, value))
 		return -ENODEV;
 	return rv;
 }
@@ -749,7 +786,7 @@ static ssize_t store_ledd(struct device *dev, struct device_attribute *attr,
 
 	rv = parse_arg(buf, count, &value);
 	if (rv > 0) {
-		if (write_acpi_int(ledd_set_handle, NULL, value))
+		if (write_acpi_int(asus->handle, METHOD_LEDD, value))
 			pr_warning("LED display write failed\n");
 		else
 			asus->ledd_status = (u32) value;
@@ -768,7 +805,8 @@ static int asus_wireless_status(struct asus_laptop *asus, int mask)
 	if (!asus->have_rsts)
 		return (asus->wireless_status & mask) ? 1 : 0;
 
-	rv = acpi_evaluate_integer(wireless_status_handle, NULL, NULL, &status);
+	rv = acpi_evaluate_integer(asus->handle, METHOD_WL_STATUS,
+				   NULL, &status);
 	if (ACPI_FAILURE(rv)) {
 		pr_warning("Error reading Wireless status\n");
 		return -EINVAL;
@@ -792,7 +830,7 @@ static ssize_t store_wlan(struct device *dev, struct device_attribute *attr,
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 
-	return sysfs_acpi_set(asus, buf, count, wl_switch_handle);
+	return sysfs_acpi_set(asus, buf, count, METHOD_WLAN);
 }
 
 /*
@@ -812,7 +850,7 @@ static ssize_t store_bluetooth(struct device *dev,
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 
-	return sysfs_acpi_set(asus, buf, count, bt_switch_handle);
+	return sysfs_acpi_set(asus, buf, count, METHOD_BLUETOOTH);
 }
 
 /*
@@ -821,7 +859,7 @@ static ssize_t store_bluetooth(struct device *dev,
 static void asus_set_display(struct asus_laptop *asus, int value)
 {
 	/* no sanity check needed for now */
-	if (write_acpi_int(display_set_handle, NULL, value))
+	if (write_acpi_int(asus->handle, METHOD_SWITCH_DISPLAY, value))
 		pr_warning("Error setting display\n");
 	return;
 }
@@ -883,7 +921,7 @@ static ssize_t store_disp(struct device *dev, struct device_attribute *attr,
  */
 static void asus_als_switch(struct asus_laptop *asus, int value)
 {
-	if (write_acpi_int(ls_switch_handle, NULL, value))
+	if (write_acpi_int(asus->handle, METHOD_ALS_CONTROL, value))
 		pr_warning("Error setting light sensor switch\n");
 	asus->light_switch = value;
 }
@@ -911,7 +949,7 @@ static ssize_t store_lssw(struct device *dev, struct device_attribute *attr,
 
 static void asus_als_level(struct asus_laptop *asus, int value)
 {
-	if (write_acpi_int(ls_level_handle, NULL, value))
+	if (write_acpi_int(asus->handle, METHOD_ALS_LEVEL, value))
 		pr_warning("Error setting light sensor level\n");
 	asus->light_level = value;
 }
@@ -949,7 +987,8 @@ static int asus_gps_status(struct asus_laptop *asus)
 	unsigned long long status;
 	acpi_status rv = AE_OK;
 
-	rv = acpi_evaluate_integer(gps_status_handle, NULL, NULL, &status);
+	rv = acpi_evaluate_integer(asus->handle, METHOD_GPS_STATUS,
+				   NULL, &status);
 	if (ACPI_FAILURE(rv)) {
 		pr_warning("Error reading GPS status\n");
 		return -ENODEV;
@@ -959,9 +998,9 @@ static int asus_gps_status(struct asus_laptop *asus)
 
 static int asus_gps_switch(struct asus_laptop *asus, int status)
 {
-	acpi_handle handle = status ? gps_on_handle : gps_off_handle;
+	const char *meth = status ? METHOD_GPS_ON : METHOD_GPS_OFF;
 
-	if (write_acpi_int(handle, NULL, 0x02))
+	if (write_acpi_int(asus->handle, meth, 0x02))
 		return -ENODEV;
 	return 0;
 }
@@ -1224,27 +1263,33 @@ static void asus_laptop_add_fs(struct asus_laptop *asus)
 {
 	ASUS_SET_DEVICE_ATTR(infos, 0444, show_infos, NULL);
 
-	if (wl_switch_handle)
+	if (!acpi_check_handle(asus->handle, METHOD_WLAN, NULL))
 		ASUS_SET_DEVICE_ATTR(wlan, 0644, show_wlan, store_wlan);
 
-	if (bt_switch_handle)
+	if (!acpi_check_handle(asus->handle, METHOD_BLUETOOTH, NULL))
 		ASUS_SET_DEVICE_ATTR(bluetooth, 0644,
 				     show_bluetooth, store_bluetooth);
 
-	if (display_set_handle && display_get_handle)
-		ASUS_SET_DEVICE_ATTR(display, 0644, show_disp, store_disp);
-	else if (display_set_handle)
-		ASUS_SET_DEVICE_ATTR(display, 0200, NULL, store_disp);
+	if (!acpi_check_handle(asus->handle, METHOD_SWITCH_DISPLAY, NULL)) {
+		if (display_get_handle)
+			ASUS_SET_DEVICE_ATTR(display, 0644, show_disp,
+					     store_disp);
+		else
+			ASUS_SET_DEVICE_ATTR(display, 0200, NULL, store_disp);
+	}
 
-	if (ledd_set_handle)
+	if (!acpi_check_handle(asus->handle, METHOD_LEDD, NULL))
 		ASUS_SET_DEVICE_ATTR(ledd, 0644, show_ledd, store_ledd);
 
-	if (ls_switch_handle && ls_level_handle) {
+	if (!acpi_check_handle(asus->handle, METHOD_ALS_CONTROL, NULL) &&
+	    !acpi_check_handle(asus->handle, METHOD_ALS_LEVEL, NULL)) {
 		ASUS_SET_DEVICE_ATTR(ls_level, 0644, show_lslvl, store_lslvl);
 		ASUS_SET_DEVICE_ATTR(ls_switch, 0644, show_lssw, store_lssw);
 	}
 
-	if (gps_status_handle && gps_on_handle && gps_off_handle)
+	if (!acpi_check_handle(asus->handle, METHOD_GPS_ON, NULL) &&
+	    !acpi_check_handle(asus->handle, METHOD_GPS_OFF, NULL) &&
+	    !acpi_check_handle(asus->handle, METHOD_GPS_STATUS, NULL))
 		ASUS_SET_DEVICE_ATTR(gps, 0644, show_gps, store_gps);
 }
 
@@ -1337,55 +1382,23 @@ static int asus_laptop_get_info(struct asus_laptop *asus)
 	if (*string)
 		pr_notice("  %s model detected\n", string);
 
-	ASUS_HANDLE_INIT(mled_set);
-	ASUS_HANDLE_INIT(tled_set);
-	ASUS_HANDLE_INIT(rled_set);
-	ASUS_HANDLE_INIT(pled_set);
-	ASUS_HANDLE_INIT(gled_set);
-
-	ASUS_HANDLE_INIT(ledd_set);
-
-	ASUS_HANDLE_INIT(kled_set);
-	ASUS_HANDLE_INIT(kled_get);
-
 	/*
 	 * The HWRS method return informations about the hardware.
 	 * 0x80 bit is for WLAN, 0x100 for Bluetooth.
 	 * The significance of others is yet to be found.
-	 * If we don't find the method, we assume the device are present.
 	 */
 	status =
 	    acpi_evaluate_integer(asus->handle, "HRWS", NULL, &hwrs_result);
-	if (ACPI_FAILURE(status))
-		hwrs_result = WL_HWRS | BT_HWRS;
+	if (!ACPI_FAILURE(status))
+		pr_notice("  HRWS returned %x", (int)hwrs_result);
 
-	if (hwrs_result & WL_HWRS)
-		ASUS_HANDLE_INIT(wl_switch);
-	if (hwrs_result & BT_HWRS)
-		ASUS_HANDLE_INIT(bt_switch);
-
-	if (!ASUS_HANDLE_INIT(wireless_status))
+	if (!acpi_check_handle(asus->handle, METHOD_WL_STATUS, NULL))
 		asus->have_rsts = true;
 
-	ASUS_HANDLE_INIT(brightness_set);
-	ASUS_HANDLE_INIT(brightness_get);
-
+	/* Scheduled for removal */
 	ASUS_HANDLE_INIT(lcd_switch);
-
-	ASUS_HANDLE_INIT(display_set);
 	ASUS_HANDLE_INIT(display_get);
 
-	/*
-	 * There is a lot of models with "ALSL", but a few get
-	 * a real light sens, so we need to check it.
-	 */
-	if (!ASUS_HANDLE_INIT(ls_switch))
-		ASUS_HANDLE_INIT(ls_level);
-
-	ASUS_HANDLE_INIT(gps_on);
-	ASUS_HANDLE_INIT(gps_off);
-	ASUS_HANDLE_INIT(gps_status);
-
 	kfree(model);
 
 	return AE_OK;
@@ -1413,12 +1426,14 @@ static int __devinit asus_acpi_init(struct asus_laptop *asus)
 
 	/* WLED and BLED are on by default */
 	if (bluetooth_status >= 0)
-		write_acpi_int(bt_switch_handle, NULL, !!bluetooth_status);
+		write_acpi_int(asus->handle, METHOD_BLUETOOTH,
+			       !!bluetooth_status);
 	if (wireless_status >= 0)
-		write_acpi_int(wl_switch_handle, NULL, !!wireless_status);
+		write_acpi_int(asus->handle, METHOD_WLAN,
+			       !!wireless_status);
 
 	/* Keyboard Backlight is on by default */
-	if (kled_set_handle)
+	if (!acpi_check_handle(asus->handle, METHOD_KBD_LIGHT_SET, NULL))
 		asus_kled_set(asus, 1);
 
 	/* LED display is off by default */
@@ -1428,14 +1443,17 @@ static int __devinit asus_acpi_init(struct asus_laptop *asus)
 	asus->light_switch = 0;	/* Default to light sensor disabled */
 	asus->light_level = 5;	/* level 5 for sensor sensitivity */
 
-	if (ls_switch_handle)
+	if (!acpi_check_handle(asus->handle, METHOD_ALS_CONTROL, NULL) &&
+	    !acpi_check_handle(asus->handle, METHOD_ALS_LEVEL, NULL)) {
 		asus_als_switch(asus, asus->light_switch);
-
-	if (ls_level_handle)
 		asus_als_level(asus, asus->light_level);
+	}
 
 	/* GPS is on by default */
-	asus_gps_switch(asus, 1);
+	if (!acpi_check_handle(asus->handle, METHOD_GPS_ON, NULL) &&
+	    !acpi_check_handle(asus->handle, METHOD_GPS_OFF, NULL) &&
+	    !acpi_check_handle(asus->handle, METHOD_GPS_STATUS, NULL))
+		asus_gps_switch(asus, 1);
 	return result;
 }
 

commit 4d4415138060870670a18d0768fe1d597f505f98
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Wed Jan 13 22:26:24 2010 +0100

    asus-laptop: rename function talking directly to acpi with asus_xxx scheme
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 2349e88bbc75..ae4f80886577 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -394,7 +394,7 @@ ASUS_LED_HANDLER(gled, GLED_ON);
 /*
  * Keyboard backlight (also a LED)
  */
-static int get_kled_lvl(void)
+static int asus_kled_lvl(void)
 {
 	unsigned long long kblv;
 	struct acpi_object_list params;
@@ -409,12 +409,12 @@ static int get_kled_lvl(void)
 	rv = acpi_evaluate_integer(kled_get_handle, NULL, &params, &kblv);
 	if (ACPI_FAILURE(rv)) {
 		pr_warning("Error reading kled level\n");
-		return 0;
+		return -ENODEV;
 	}
 	return kblv;
 }
 
-static int set_kled_lvl(struct asus_laptop *asus, int kblv)
+static int asus_kled_set(struct asus_laptop *asus, int kblv)
 {
 	if (kblv > 0)
 		kblv = (1 << 7) | (kblv & 0x7F);
@@ -441,12 +441,12 @@ static void kled_led_update(struct work_struct *work)
 {
 	struct asus_laptop *asus = work_to_asus(work, kled);
 
-	set_kled_lvl(asus, asus->leds.kled_wk);
+	asus_kled_set(asus, asus->leds.kled_wk);
 }
 
 static enum led_brightness kled_led_get(struct led_classdev *led_cdev)
 {
-	return get_kled_lvl();
+	return asus_kled_lvl();
 }
 
 #define ASUS_LED_UNREGISTER(object)				\
@@ -555,7 +555,7 @@ static void lcd_blank(struct asus_laptop *asus, int blank)
 	}
 }
 
-static int read_brightness(struct backlight_device *bd)
+static int asus_read_brightness(struct backlight_device *bd)
 {
 	unsigned long long value;
 	acpi_status rv = AE_OK;
@@ -567,7 +567,7 @@ static int read_brightness(struct backlight_device *bd)
 	return value;
 }
 
-static int set_brightness(struct backlight_device *bd, int value)
+static int asus_set_brightness(struct backlight_device *bd, int value)
 {
 	if (write_acpi_int(brightness_set_handle, NULL, value)) {
 		pr_warning("Error changing brightness\n");
@@ -582,7 +582,7 @@ static int update_bl_status(struct backlight_device *bd)
 	int rv;
 	int value = bd->props.brightness;
 
-	rv = set_brightness(bd, value);
+	rv = asus_set_brightness(bd, value);
 	if (rv)
 		return rv;
 
@@ -591,7 +591,7 @@ static int update_bl_status(struct backlight_device *bd)
 }
 
 static struct backlight_ops asusbl_ops = {
-	.get_brightness = read_brightness,
+	.get_brightness = asus_read_brightness,
 	.update_status = update_bl_status,
 };
 
@@ -612,7 +612,7 @@ static int asus_backlight_init(struct asus_laptop *asus)
 		asus->backlight_device = bd;
 
 		bd->props.max_brightness = 15;
-		bd->props.brightness = read_brightness(NULL);
+		bd->props.brightness = asus_read_brightness(NULL);
 		bd->props.power = FB_BLANK_UNBLANK;
 		backlight_update_status(bd);
 	}
@@ -818,7 +818,7 @@ static ssize_t store_bluetooth(struct device *dev,
 /*
  * Display
  */
-static void set_display(struct asus_laptop *asus, int value)
+static void asus_set_display(struct asus_laptop *asus, int value)
 {
 	/* no sanity check needed for now */
 	if (write_acpi_int(display_set_handle, NULL, value))
@@ -874,14 +874,14 @@ static ssize_t store_disp(struct device *dev, struct device_attribute *attr,
 
 	rv = parse_arg(buf, count, &value);
 	if (rv > 0)
-		set_display(asus, value);
+		asus_set_display(asus, value);
 	return rv;
 }
 
 /*
  * Light Sens
  */
-static void set_light_sens_switch(struct asus_laptop *asus, int value)
+static void asus_als_switch(struct asus_laptop *asus, int value)
 {
 	if (write_acpi_int(ls_switch_handle, NULL, value))
 		pr_warning("Error setting light sensor switch\n");
@@ -904,12 +904,12 @@ static ssize_t store_lssw(struct device *dev, struct device_attribute *attr,
 
 	rv = parse_arg(buf, count, &value);
 	if (rv > 0)
-		set_light_sens_switch(asus, value ? 1 : 0);
+		asus_als_switch(asus, value ? 1 : 0);
 
 	return rv;
 }
 
-static void set_light_sens_level(struct asus_laptop *asus, int value)
+static void asus_als_level(struct asus_laptop *asus, int value)
 {
 	if (write_acpi_int(ls_level_handle, NULL, value))
 		pr_warning("Error setting light sensor level\n");
@@ -934,7 +934,7 @@ static ssize_t store_lslvl(struct device *dev, struct device_attribute *attr,
 	if (rv > 0) {
 		value = (0 < value) ? ((15 < value) ? 15 : value) : 0;
 		/* 0 <= value <= 15 */
-		set_light_sens_level(asus, value);
+		asus_als_level(asus, value);
 	}
 
 	return rv;
@@ -1419,7 +1419,7 @@ static int __devinit asus_acpi_init(struct asus_laptop *asus)
 
 	/* Keyboard Backlight is on by default */
 	if (kled_set_handle)
-		set_kled_lvl(asus, 1);
+		asus_kled_set(asus, 1);
 
 	/* LED display is off by default */
 	asus->ledd_status = 0xFFF;
@@ -1429,10 +1429,10 @@ static int __devinit asus_acpi_init(struct asus_laptop *asus)
 	asus->light_level = 5;	/* level 5 for sensor sensitivity */
 
 	if (ls_switch_handle)
-		set_light_sens_switch(asus, asus->light_switch);
+		asus_als_switch(asus, asus->light_switch);
 
 	if (ls_level_handle)
-		set_light_sens_level(asus, asus->light_level);
+		asus_als_level(asus, asus->light_level);
 
 	/* GPS is on by default */
 	asus_gps_switch(asus, 1);

commit 17e78f6260fbc8f55c279cca081c26c88d96ec00
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Wed Jan 13 22:21:33 2010 +0100

    asus-laptop: removing read_status/store_status/write_status and asus->status
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index d726db380e47..2349e88bbc75 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -107,16 +107,8 @@ MODULE_PARM_DESC(bluetooth_status, "Set the wireless status on boot "
  * Flags for hotk status
  * WL_ON and BT_ON are also used for wireless_status()
  */
-#define WL_ON		0x01	/* internal Wifi */
-#define BT_ON		0x02	/* internal Bluetooth */
-#define MLED_ON		0x04	/* mail LED */
-#define TLED_ON		0x08	/* touchpad LED */
-#define RLED_ON		0x10	/* Record LED */
-#define PLED_ON		0x20	/* Phone LED */
-#define GLED_ON		0x40	/* Gaming LED */
-#define LCD_ON		0x80	/* LCD backlight */
-#define GPS_ON		0x100	/* GPS */
-#define KEY_ON		0x200	/* Keyboard backlight */
+#define WL_RSTS		0x01	/* internal Wifi */
+#define BT_RSTS		0x02	/* internal Bluetooth */
 
 #define ASUS_HANDLE(object, paths...)					\
 	static acpi_handle  object##_handle = NULL;			\
@@ -244,7 +236,6 @@ struct asus_laptop {
 	int lcd_state;
 
 	acpi_handle handle;	/* the handle of the hotk device */
-	char status;		/* status of the hotk, for LEDs, ... */
 	u32 ledd_status;	/* status of the LED display */
 	u8 light_level;		/* light sensor level */
 	u8 light_switch;	/* light sensor switch value */
@@ -332,35 +323,18 @@ static int write_acpi_int(acpi_handle handle, const char *method, int val)
 	return write_acpi_int_ret(handle, method, val, NULL);
 }
 
-/* Generic LED functions */
-static int read_status(struct asus_laptop *asus, int mask)
+/* Generic LED function */
+static void asus_led_set(struct asus_laptop *asus, acpi_handle handle,
+			 int value)
 {
-	return (asus->status & mask) ? 1 : 0;
-}
-
-static void write_status(struct asus_laptop *asus, acpi_handle handle,
-			 int out, int mask)
-{
-	asus->status = (out) ? (asus->status | mask) : (asus->status & ~mask);
-
-	switch (mask) {
-	case MLED_ON:
-		out = !(out & 0x1);
-		break;
-	case GLED_ON:
-		out = (out & 0x1) + 1;
-		break;
-	case GPS_ON:
-		handle = (out) ? gps_on_handle : gps_off_handle;
-		out = 0x02;
-		break;
-	default:
-		out &= 0x1;
-		break;
-	}
+	if (handle == mled_set_handle)
+		value = !value;
+	else if (handle == gled_set_handle)
+		value = !value + 1;
+	else
+		value = !!value;
 
-	if (write_acpi_int(handle, NULL, out))
-		pr_warning(" write failed %x\n", mask);
+	write_acpi_int(handle, NULL, value);
 }
 
 /*
@@ -403,7 +377,7 @@ ASUS_LED(kled, "kbd_backlight", 3);
 		struct asus_laptop *asus = work_to_asus(work, object);	\
 									\
 		int value = asus->leds.object##_wk;			\
-		write_status(asus, object##_set_handle, value, (mask));	\
+		asus_led_set(asus, object##_set_handle, value);		\
 	}								\
 	static enum led_brightness object##_led_get(			\
 		struct led_classdev *led_cdev)				\
@@ -740,9 +714,9 @@ static int parse_arg(const char *buf, unsigned long count, int *val)
 	return count;
 }
 
-static ssize_t store_status(struct asus_laptop *asus,
-			    const char *buf, size_t count,
-			    acpi_handle handle, int mask)
+static ssize_t sysfs_acpi_set(struct asus_laptop *asus,
+			      const char *buf, size_t count,
+			      acpi_handle handle)
 {
 	int rv, value;
 	int out = 0;
@@ -751,8 +725,8 @@ static ssize_t store_status(struct asus_laptop *asus,
 	if (rv > 0)
 		out = value ? 1 : 0;
 
-	write_status(asus, handle, out, mask);
-
+	if (write_acpi_int(handle, NULL, value))
+		return -ENODEV;
 	return rv;
 }
 
@@ -810,7 +784,7 @@ static ssize_t show_wlan(struct device *dev,
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 
-	return sprintf(buf, "%d\n", asus_wireless_status(asus, WL_ON));
+	return sprintf(buf, "%d\n", asus_wireless_status(asus, WL_RSTS));
 }
 
 static ssize_t store_wlan(struct device *dev, struct device_attribute *attr,
@@ -818,7 +792,7 @@ static ssize_t store_wlan(struct device *dev, struct device_attribute *attr,
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 
-	return store_status(asus, buf, count, wl_switch_handle, WL_ON);
+	return sysfs_acpi_set(asus, buf, count, wl_switch_handle);
 }
 
 /*
@@ -829,7 +803,7 @@ static ssize_t show_bluetooth(struct device *dev,
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 
-	return sprintf(buf, "%d\n", asus_wireless_status(asus, BT_ON));
+	return sprintf(buf, "%d\n", asus_wireless_status(asus, BT_RSTS));
 }
 
 static ssize_t store_bluetooth(struct device *dev,
@@ -838,7 +812,7 @@ static ssize_t store_bluetooth(struct device *dev,
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 
-	return store_status(asus, buf, count, bt_switch_handle, BT_ON);
+	return sysfs_acpi_set(asus, buf, count, bt_switch_handle);
 }
 
 /*
@@ -1439,16 +1413,9 @@ static int __devinit asus_acpi_init(struct asus_laptop *asus)
 
 	/* WLED and BLED are on by default */
 	if (bluetooth_status >= 0)
-		write_status(asus, bt_switch_handle, !!bluetooth_status, BT_ON);
+		write_acpi_int(bt_switch_handle, NULL, !!bluetooth_status);
 	if (wireless_status >= 0)
-		write_status(asus, wl_switch_handle, !!wireless_status, WL_ON);
-
-	/* If the h/w switch is off, we need to check the real status */
-	write_status(asus, NULL, asus_wireless_status(asus, BT_ON), BT_ON);
-	write_status(asus, NULL, asus_wireless_status(asus, WL_ON), WL_ON);
-
-	/* LCD Backlight is on by default */
-	write_status(asus, NULL, 1, LCD_ON);
+		write_acpi_int(wl_switch_handle, NULL, !!wireless_status);
 
 	/* Keyboard Backlight is on by default */
 	if (kled_set_handle)

commit 3e68ae7c2a9076a694e46f49ec26323a7757eaad
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Wed Jan 13 22:10:39 2010 +0100

    asus-laptop: stop using read_status for lcd
    
    (anyway lcd code is scheduled for removal)
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index ea51d7e4df21..d726db380e47 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -241,6 +241,7 @@ struct asus_laptop {
 
 	int wireless_status;
 	bool have_rsts;
+	int lcd_state;
 
 	acpi_handle handle;	/* the handle of the hotk device */
 	char status;		/* status of the hotk, for LEDs, ... */
@@ -538,30 +539,33 @@ static int asus_led_init(struct asus_laptop *asus)
 /*
  * Backlight device
  */
-static int get_lcd_state(struct asus_laptop *asus)
+static int asus_lcd_status(struct asus_laptop *asus)
 {
-	return read_status(asus, LCD_ON);
+	return asus->lcd_state;
 }
 
-static int set_lcd_state(struct asus_laptop *asus, int value)
+static int asus_lcd_set(struct asus_laptop *asus, int value)
 {
 	int lcd = 0;
 	acpi_status status = 0;
 
-	lcd = value ? 1 : 0;
+	lcd = !!value;
 
-	if (lcd == get_lcd_state(asus))
+	if (lcd == asus_lcd_status(asus))
 		return 0;
 
-	if (lcd_switch_handle) {
-		status = acpi_evaluate_object(lcd_switch_handle,
-					      NULL, NULL, NULL);
+	if (!lcd_switch_handle)
+		return -ENODEV;
+
+	status = acpi_evaluate_object(lcd_switch_handle,
+				      NULL, NULL, NULL);
 
-		if (ACPI_FAILURE(status))
-			pr_warning("Error switching LCD\n");
+	if (ACPI_FAILURE(status)) {
+		pr_warning("Error switching LCD\n");
+		return -ENODEV;
 	}
 
-	write_status(asus, NULL, lcd, LCD_ON);
+	asus->lcd_state = lcd;
 	return 0;
 }
 
@@ -569,6 +573,8 @@ static void lcd_blank(struct asus_laptop *asus, int blank)
 {
 	struct backlight_device *bd = asus->backlight_device;
 
+	asus->lcd_state = (blank == FB_BLANK_UNBLANK);
+
 	if (bd) {
 		bd->props.power = blank;
 		backlight_update_status(bd);
@@ -607,7 +613,7 @@ static int update_bl_status(struct backlight_device *bd)
 		return rv;
 
 	value = (bd->props.power == FB_BLANK_UNBLANK) ? 1 : 0;
-	return set_lcd_state(asus, value);
+	return asus_lcd_set(asus, value);
 }
 
 static struct backlight_ops asusbl_ops = {
@@ -1144,13 +1150,10 @@ static void asus_acpi_notify(struct acpi_device *device, u32 event)
 	 * We need to tell the backlight device when the backlight power is
 	 * switched
 	 */
-	if (event == ATKD_LCD_ON) {
-		write_status(asus, NULL, 1, LCD_ON);
+	if (event == ATKD_LCD_ON)
 		lcd_blank(asus, FB_BLANK_UNBLANK);
-	} else if (event == ATKD_LCD_OFF) {
-		write_status(asus, NULL, 0, LCD_ON);
+	else if (event == ATKD_LCD_OFF)
 		lcd_blank(asus, FB_BLANK_POWERDOWN);
-	}
 
 	/* TODO Find a better way to handle events count. */
 	count = asus->event_count[event % 128]++;

commit 6358bf2c4c309efc7c3cbc36466c32108c12c456
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Wed Jan 13 21:55:44 2010 +0100

    asus-laptop: stop using read_status and store_status for GPS
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index cee751e301a6..ea51d7e4df21 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -331,26 +331,9 @@ static int write_acpi_int(acpi_handle handle, const char *method, int val)
 	return write_acpi_int_ret(handle, method, val, NULL);
 }
 
-static int read_gps_status(struct asus_laptop *asus)
-{
-	unsigned long long status;
-	acpi_status rv = AE_OK;
-
-	rv = acpi_evaluate_integer(gps_status_handle, NULL, NULL, &status);
-	if (ACPI_FAILURE(rv))
-		pr_warning("Error reading GPS status\n");
-	else
-		return status ? 1 : 0;
-
-	return (asus->status & GPS_ON) ? 1 : 0;
-}
-
 /* Generic LED functions */
 static int read_status(struct asus_laptop *asus, int mask)
 {
-	if (mask == GPS_ON)
-		return read_gps_status(asus);
-
 	return (asus->status & mask) ? 1 : 0;
 }
 
@@ -979,21 +962,52 @@ static ssize_t store_lslvl(struct device *dev, struct device_attribute *attr,
 
 /*
  * GPS
+ * TODO: use rfkill
  */
+static int asus_gps_status(struct asus_laptop *asus)
+{
+	unsigned long long status;
+	acpi_status rv = AE_OK;
+
+	rv = acpi_evaluate_integer(gps_status_handle, NULL, NULL, &status);
+	if (ACPI_FAILURE(rv)) {
+		pr_warning("Error reading GPS status\n");
+		return -ENODEV;
+	}
+	return !!status;
+}
+
+static int asus_gps_switch(struct asus_laptop *asus, int status)
+{
+	acpi_handle handle = status ? gps_on_handle : gps_off_handle;
+
+	if (write_acpi_int(handle, NULL, 0x02))
+		return -ENODEV;
+	return 0;
+}
+
 static ssize_t show_gps(struct device *dev,
 			struct device_attribute *attr, char *buf)
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 
-	return sprintf(buf, "%d\n", read_status(asus, GPS_ON));
+	return sprintf(buf, "%d\n", asus_gps_status(asus));
 }
 
 static ssize_t store_gps(struct device *dev, struct device_attribute *attr,
 			 const char *buf, size_t count)
 {
-	struct asus_laptop *asus = dev_get_drvdata(dev);
+ 	struct asus_laptop *asus = dev_get_drvdata(dev);
+	int rv, value;
+	int ret;
 
-	return store_status(asus, buf, count, NULL, GPS_ON);
+	rv = parse_arg(buf, count, &value);
+	if (rv <= 0)
+		return -EINVAL;
+	ret = asus_gps_switch(asus, !!value);
+	if (ret)
+		return ret;
+	return rv;
 }
 
 /*
@@ -1451,7 +1465,7 @@ static int __devinit asus_acpi_init(struct asus_laptop *asus)
 		set_light_sens_level(asus, asus->light_level);
 
 	/* GPS is on by default */
-	write_status(asus, NULL, 1, GPS_ON);
+	asus_gps_switch(asus, 1);
 	return result;
 }
 

commit aa9df930d6eabbd8f2439eca6b2f77f81ce425f2
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Wed Jan 13 21:49:10 2010 +0100

    asus-laptop: stop using read_status for bluetooth and wlan
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 940ce3d63229..cee751e301a6 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -239,6 +239,9 @@ struct asus_laptop {
 
 	struct asus_laptop_leds leds;
 
+	int wireless_status;
+	bool have_rsts;
+
 	acpi_handle handle;	/* the handle of the hotk device */
 	char status;		/* status of the hotk, for LEDs, ... */
 	u32 ledd_status;	/* status of the LED display */
@@ -328,23 +331,6 @@ static int write_acpi_int(acpi_handle handle, const char *method, int val)
 	return write_acpi_int_ret(handle, method, val, NULL);
 }
 
-static int read_wireless_status(struct asus_laptop *asus, int mask)
-{
-	unsigned long long status;
-	acpi_status rv = AE_OK;
-
-	if (!wireless_status_handle)
-		return (asus->status & mask) ? 1 : 0;
-
-	rv = acpi_evaluate_integer(wireless_status_handle, NULL, NULL, &status);
-	if (ACPI_FAILURE(rv))
-		pr_warning("Error reading Wireless status\n");
-	else
-		return (status & mask) ? 1 : 0;
-
-	return (asus->status & mask) ? 1 : 0;
-}
-
 static int read_gps_status(struct asus_laptop *asus)
 {
 	unsigned long long status;
@@ -362,10 +348,7 @@ static int read_gps_status(struct asus_laptop *asus)
 /* Generic LED functions */
 static int read_status(struct asus_laptop *asus, int mask)
 {
-	/* There is a special method for both wireless devices */
-	if (mask == BT_ON || mask == WL_ON)
-		return read_wireless_status(asus, mask);
-	else if (mask == GPS_ON)
+	if (mask == GPS_ON)
 		return read_gps_status(asus);
 
 	return (asus->status & mask) ? 1 : 0;
@@ -811,6 +794,25 @@ static ssize_t store_ledd(struct device *dev, struct device_attribute *attr,
 	return rv;
 }
 
+/*
+ * Wireless
+ */
+static int asus_wireless_status(struct asus_laptop *asus, int mask)
+{
+	unsigned long long status;
+	acpi_status rv = AE_OK;
+
+	if (!asus->have_rsts)
+		return (asus->wireless_status & mask) ? 1 : 0;
+
+	rv = acpi_evaluate_integer(wireless_status_handle, NULL, NULL, &status);
+	if (ACPI_FAILURE(rv)) {
+		pr_warning("Error reading Wireless status\n");
+		return -EINVAL;
+	}
+	return !!(status & mask);
+}
+
 /*
  * WLAN
  */
@@ -819,7 +821,7 @@ static ssize_t show_wlan(struct device *dev,
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 
-	return sprintf(buf, "%d\n", read_status(asus, WL_ON));
+	return sprintf(buf, "%d\n", asus_wireless_status(asus, WL_ON));
 }
 
 static ssize_t store_wlan(struct device *dev, struct device_attribute *attr,
@@ -838,7 +840,7 @@ static ssize_t show_bluetooth(struct device *dev,
 {
 	struct asus_laptop *asus = dev_get_drvdata(dev);
 
-	return sprintf(buf, "%d\n", read_status(asus, BT_ON));
+	return sprintf(buf, "%d\n", asus_wireless_status(asus, BT_ON));
 }
 
 static ssize_t store_bluetooth(struct device *dev,
@@ -1371,7 +1373,8 @@ static int asus_laptop_get_info(struct asus_laptop *asus)
 	if (hwrs_result & BT_HWRS)
 		ASUS_HANDLE_INIT(bt_switch);
 
-	ASUS_HANDLE_INIT(wireless_status);
+	if (!ASUS_HANDLE_INIT(wireless_status))
+		asus->have_rsts = true;
 
 	ASUS_HANDLE_INIT(brightness_set);
 	ASUS_HANDLE_INIT(brightness_get);
@@ -1424,8 +1427,8 @@ static int __devinit asus_acpi_init(struct asus_laptop *asus)
 		write_status(asus, wl_switch_handle, !!wireless_status, WL_ON);
 
 	/* If the h/w switch is off, we need to check the real status */
-	write_status(asus, NULL, read_status(asus, BT_ON), BT_ON);
-	write_status(asus, NULL, read_status(asus, WL_ON), WL_ON);
+	write_status(asus, NULL, asus_wireless_status(asus, BT_ON), BT_ON);
+	write_status(asus, NULL, asus_wireless_status(asus, WL_ON), WL_ON);
 
 	/* LCD Backlight is on by default */
 	write_status(asus, NULL, 1, LCD_ON);

commit be4ee82d3e44c5940a7f77cae5ed3e942e80a723
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sun Dec 6 16:27:09 2009 +0100

    asus-laptop: code movement
    
    The asus-laptop driver implements a number of interfaces like the
    backlight class driver.  This change makes it easier to examine the
    implementation of one interface at at a time, without having to search
    through the file to find init() and exit() functions etc.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 58a4864096d9..940ce3d63229 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -58,36 +58,6 @@
 #define ASUS_LAPTOP_FILE	KBUILD_MODNAME
 #define ASUS_LAPTOP_PREFIX	"\\_SB.ATKD."
 
-
-/*
- * Some events we use, same for all Asus
- */
-#define ATKD_BR_UP	0x10
-#define ATKD_BR_DOWN	0x20
-#define ATKD_LCD_ON	0x33
-#define ATKD_LCD_OFF	0x34
-
-/*
- * Known bits returned by \_SB.ATKD.HWRS
- */
-#define WL_HWRS		0x80
-#define BT_HWRS		0x100
-
-/*
- * Flags for hotk status
- * WL_ON and BT_ON are also used for wireless_status()
- */
-#define WL_ON		0x01	/* internal Wifi */
-#define BT_ON		0x02	/* internal Bluetooth */
-#define MLED_ON		0x04	/* mail LED */
-#define TLED_ON		0x08	/* touchpad LED */
-#define RLED_ON		0x10	/* Record LED */
-#define PLED_ON		0x20	/* Phone LED */
-#define GLED_ON		0x40	/* Gaming LED */
-#define LCD_ON		0x80	/* LCD backlight */
-#define GPS_ON		0x100	/* GPS */
-#define KEY_ON		0x200	/* Keyboard backlight */
-
 MODULE_AUTHOR("Julien Lerouge, Karol Kozimor, Corentin Chary");
 MODULE_DESCRIPTION(ASUS_LAPTOP_NAME);
 MODULE_LICENSE("GPL");
@@ -119,6 +89,35 @@ MODULE_PARM_DESC(bluetooth_status, "Set the wireless status on boot "
 		 "(0 = disabled, 1 = enabled, -1 = don't do anything). "
 		 "default is 1");
 
+/*
+ * Some events we use, same for all Asus
+ */
+#define ATKD_BR_UP	0x10
+#define ATKD_BR_DOWN	0x20
+#define ATKD_LCD_ON	0x33
+#define ATKD_LCD_OFF	0x34
+
+/*
+ * Known bits returned by \_SB.ATKD.HWRS
+ */
+#define WL_HWRS		0x80
+#define BT_HWRS		0x100
+
+/*
+ * Flags for hotk status
+ * WL_ON and BT_ON are also used for wireless_status()
+ */
+#define WL_ON		0x01	/* internal Wifi */
+#define BT_ON		0x02	/* internal Bluetooth */
+#define MLED_ON		0x04	/* mail LED */
+#define TLED_ON		0x08	/* touchpad LED */
+#define RLED_ON		0x10	/* Record LED */
+#define PLED_ON		0x20	/* Phone LED */
+#define GLED_ON		0x40	/* Gaming LED */
+#define LCD_ON		0x80	/* LCD backlight */
+#define GPS_ON		0x100	/* GPS */
+#define KEY_ON		0x200	/* Keyboard backlight */
+
 #define ASUS_HANDLE(object, paths...)					\
 	static acpi_handle  object##_handle = NULL;			\
 	static char *object##_paths[] = { paths }
@@ -249,36 +248,6 @@ struct asus_laptop {
 	u16 *keycode_map;
 };
 
-/*
- * The backlight class declaration
- */
-static int read_brightness(struct backlight_device *bd);
-static int update_bl_status(struct backlight_device *bd);
-static struct backlight_ops asusbl_ops = {
-	.get_brightness = read_brightness,
-	.update_status = update_bl_status,
-};
-
-#define ASUS_LED(object, ledname, max)					\
-	static void object##_led_set(struct led_classdev *led_cdev,	\
-				     enum led_brightness value);	\
-	static enum led_brightness object##_led_get(			\
-		struct led_classdev *led_cdev);				\
-	static void object##_led_update(struct work_struct *ignored);	\
-	static struct led_classdev object##_led = {			\
-		.name           = "asus::" ledname,			\
-		.brightness_set = object##_led_set,			\
-		.brightness_get = object##_led_get,			\
-		.max_brightness = max					\
-	}
-
-ASUS_LED(mled, "mail", 1);
-ASUS_LED(tled, "touchpad", 1);
-ASUS_LED(rled, "record", 1);
-ASUS_LED(pled, "phone", 1);
-ASUS_LED(gled, "gaming", 1);
-ASUS_LED(kled, "kbd_backlight", 3);
-
 struct key_entry {
 	char type;
 	u8 code;
@@ -427,6 +396,29 @@ static void write_status(struct asus_laptop *asus, acpi_handle handle,
 		pr_warning(" write failed %x\n", mask);
 }
 
+/*
+ * LEDs
+ */
+#define ASUS_LED(object, ledname, max)					\
+	static void object##_led_set(struct led_classdev *led_cdev,	\
+				     enum led_brightness value);	\
+	static enum led_brightness object##_led_get(			\
+		struct led_classdev *led_cdev);				\
+	static void object##_led_update(struct work_struct *ignored);	\
+	static struct led_classdev object##_led = {			\
+		.name           = "asus::" ledname,			\
+		.brightness_set = object##_led_set,			\
+		.brightness_get = object##_led_get,			\
+		.max_brightness = max					\
+	}
+
+ASUS_LED(mled, "mail", 1);
+ASUS_LED(tled, "touchpad", 1);
+ASUS_LED(rled, "record", 1);
+ASUS_LED(pled, "phone", 1);
+ASUS_LED(gled, "gaming", 1);
+ASUS_LED(kled, "kbd_backlight", 3);
+
 /* /sys/class/led handlers */
 #define ASUS_LED_HANDLER(object, mask)					\
 	static void object##_led_set(struct led_classdev *led_cdev,	\
@@ -459,7 +451,7 @@ ASUS_LED_HANDLER(tled, TLED_ON);
 ASUS_LED_HANDLER(gled, GLED_ON);
 
 /*
- * Keyboard backlight
+ * Keyboard backlight (also a LED)
  */
 static int get_kled_lvl(void)
 {
@@ -516,6 +508,70 @@ static enum led_brightness kled_led_get(struct led_classdev *led_cdev)
 	return get_kled_lvl();
 }
 
+#define ASUS_LED_UNREGISTER(object)				\
+	if (object##_led.dev)					\
+		led_classdev_unregister(&object##_led)
+
+static void asus_led_exit(struct asus_laptop *asus)
+{
+	ASUS_LED_UNREGISTER(mled);
+	ASUS_LED_UNREGISTER(tled);
+	ASUS_LED_UNREGISTER(pled);
+	ASUS_LED_UNREGISTER(rled);
+	ASUS_LED_UNREGISTER(gled);
+	ASUS_LED_UNREGISTER(kled);
+	if (asus->leds.workqueue) {
+		destroy_workqueue(asus->leds.workqueue);
+		asus->leds.workqueue = NULL;
+	}
+}
+
+/*  Ugly macro, need to fix that later */
+#define ASUS_LED_REGISTER(asus, object, _name, max)			\
+	do {								\
+		struct led_classdev *ldev = &asus->leds.object;		\
+		if (!object##_set_handle)				\
+			break ;						\
+									\
+		INIT_WORK(&asus->leds.object##_work, object##_led_update); \
+		ldev->name = "asus::" _name;				\
+		ldev->brightness_set = object##_led_set;		\
+		ldev->max_brightness = max;				\
+		rv = led_classdev_register(&asus->platform_device->dev, ldev); \
+		if (rv)							\
+			goto error;					\
+	} while (0)
+
+static int asus_led_init(struct asus_laptop *asus)
+{
+	int rv;
+
+	/*
+	 * Functions that actually update the LED's are called from a
+	 * workqueue. By doing this as separate work rather than when the LED
+	 * subsystem asks, we avoid messing with the Asus ACPI stuff during a
+	 * potentially bad time, such as a timer interrupt.
+	 */
+	asus->leds.workqueue = create_singlethread_workqueue("led_workqueue");
+	if (!asus->leds.workqueue)
+		return -ENOMEM;
+
+	ASUS_LED_REGISTER(asus, mled, "mail", 1);
+	ASUS_LED_REGISTER(asus, tled, "touchpad", 1);
+	ASUS_LED_REGISTER(asus, rled, "record", 1);
+	ASUS_LED_REGISTER(asus, pled, "phone", 1);
+	ASUS_LED_REGISTER(asus, gled, "gaming", 1);
+	if (kled_set_handle && kled_get_handle)
+		ASUS_LED_REGISTER(asus, kled, "kbd_backlight", 3);
+error:
+	if (rv)
+		asus_led_exit(asus);
+	return rv;
+}
+
+/*
+ * Backlight device
+ */
 static int get_lcd_state(struct asus_laptop *asus)
 {
 	return read_status(asus, LCD_ON);
@@ -588,6 +644,41 @@ static int update_bl_status(struct backlight_device *bd)
 	return set_lcd_state(asus, value);
 }
 
+static struct backlight_ops asusbl_ops = {
+	.get_brightness = read_brightness,
+	.update_status = update_bl_status,
+};
+
+static int asus_backlight_init(struct asus_laptop *asus)
+{
+	struct backlight_device *bd;
+	struct device *dev = &asus->platform_device->dev;
+
+	if (brightness_set_handle && lcd_switch_handle) {
+		bd = backlight_device_register(ASUS_LAPTOP_FILE, dev,
+					       asus, &asusbl_ops);
+		if (IS_ERR(bd)) {
+			pr_err("Could not register asus backlight device\n");
+			asus->backlight_device = NULL;
+			return PTR_ERR(bd);
+		}
+
+		asus->backlight_device = bd;
+
+		bd->props.max_brightness = 15;
+		bd->props.brightness = read_brightness(NULL);
+		bd->props.power = FB_BLANK_UNBLANK;
+		backlight_update_status(bd);
+	}
+	return 0;
+}
+
+static void asus_backlight_exit(struct asus_laptop *asus)
+{
+	if (asus->backlight_device)
+		backlight_device_unregister(asus->backlight_device);
+}
+
 /*
  * Platform device handlers
  */
@@ -904,7 +995,7 @@ static ssize_t store_gps(struct device *dev, struct device_attribute *attr,
 }
 
 /*
- * Hotkey functions
+ * Input device (i.e. hotkeys)
  */
 static struct key_entry *asus_get_entry_by_scancode(struct asus_laptop *asus,
 						    int code)
@@ -965,10 +1056,72 @@ static int asus_setkeycode(struct input_dev *dev, int scancode, int keycode)
 	return -EINVAL;
 }
 
+static void asus_input_notify(struct asus_laptop *asus, int event)
+{
+	struct key_entry *key;
+
+	key = asus_get_entry_by_scancode(asus, event);
+	if (!key)
+		return ;
+
+	switch (key->type) {
+	case KE_KEY:
+		input_report_key(asus->inputdev, key->keycode, 1);
+		input_sync(asus->inputdev);
+		input_report_key(asus->inputdev, key->keycode, 0);
+		input_sync(asus->inputdev);
+		break;
+	}
+}
+
+static int asus_input_init(struct asus_laptop *asus)
+{
+	const struct key_entry *key;
+	int result;
+
+	asus->inputdev = input_allocate_device();
+	if (!asus->inputdev) {
+		pr_info("Unable to allocate input device\n");
+		return 0;
+	}
+	asus->inputdev->name = "Asus Laptop extra buttons";
+	asus->inputdev->dev.parent = &asus->platform_device->dev;
+	asus->inputdev->phys = ASUS_LAPTOP_FILE "/input0";
+	asus->inputdev->id.bustype = BUS_HOST;
+	asus->inputdev->getkeycode = asus_getkeycode;
+	asus->inputdev->setkeycode = asus_setkeycode;
+	input_set_drvdata(asus->inputdev, asus);
+
+	asus->keymap = kmemdup(asus_keymap, sizeof(asus_keymap),
+				GFP_KERNEL);
+	for (key = asus->keymap; key->type != KE_END; key++) {
+		switch (key->type) {
+		case KE_KEY:
+			set_bit(EV_KEY, asus->inputdev->evbit);
+			set_bit(key->keycode, asus->inputdev->keybit);
+			break;
+		}
+	}
+	result = input_register_device(asus->inputdev);
+	if (result) {
+		pr_info("Unable to register input device\n");
+		input_free_device(asus->inputdev);
+	}
+	return result;
+}
+
+static void asus_input_exit(struct asus_laptop *asus)
+{
+	if (asus->inputdev)
+		input_unregister_device(asus->inputdev);
+}
+
+/*
+ * ACPI driver
+ */
 static void asus_acpi_notify(struct acpi_device *device, u32 event)
 {
 	struct asus_laptop *asus = acpi_driver_data(device);
-	static struct key_entry *key;
 	u16 count;
 
 	/*
@@ -990,20 +1143,7 @@ static void asus_acpi_notify(struct acpi_device *device, u32 event)
 					dev_name(&asus->device->dev), event,
 					count);
 
-	if (asus->inputdev) {
-		key = asus_get_entry_by_scancode(asus, event);
-		if (!key)
-			return ;
-
-		switch (key->type) {
-		case KE_KEY:
-			input_report_key(asus->inputdev, key->keycode, 1);
-			input_sync(asus->inputdev);
-			input_report_key(asus->inputdev, key->keycode, 0);
-			input_sync(asus->inputdev);
-			break;
-		}
-	}
+	asus_input_notify(asus, event);
 }
 
 #define ASUS_CREATE_DEVICE_ATTR(_name)					\
@@ -1257,142 +1397,6 @@ static int asus_laptop_get_info(struct asus_laptop *asus)
 	return AE_OK;
 }
 
-static int asus_input_init(struct asus_laptop *asus)
-{
-	const struct key_entry *key;
-	int result;
-
-	asus->inputdev = input_allocate_device();
-	if (!asus->inputdev) {
-		pr_info("Unable to allocate input device\n");
-		return 0;
-	}
-	asus->inputdev->name = "Asus Laptop extra buttons";
-	asus->inputdev->dev.parent = &asus->platform_device->dev;
-	asus->inputdev->phys = ASUS_LAPTOP_FILE "/input0";
-	asus->inputdev->id.bustype = BUS_HOST;
-	asus->inputdev->getkeycode = asus_getkeycode;
-	asus->inputdev->setkeycode = asus_setkeycode;
-	input_set_drvdata(asus->inputdev, asus);
-
-	asus->keymap = kmemdup(asus_keymap, sizeof(asus_keymap),
-				GFP_KERNEL);
-	for (key = asus->keymap; key->type != KE_END; key++) {
-		switch (key->type) {
-		case KE_KEY:
-			set_bit(EV_KEY, asus->inputdev->evbit);
-			set_bit(key->keycode, asus->inputdev->keybit);
-			break;
-		}
-	}
-	result = input_register_device(asus->inputdev);
-	if (result) {
-		pr_info("Unable to register input device\n");
-		input_free_device(asus->inputdev);
-	}
-	return result;
-}
-
-static void asus_backlight_exit(struct asus_laptop *asus)
-{
-	if (asus->backlight_device)
-		backlight_device_unregister(asus->backlight_device);
-}
-
-#define ASUS_LED_UNREGISTER(object)				\
-	if (object##_led.dev)					\
-		led_classdev_unregister(&object##_led)
-
-static void asus_led_exit(struct asus_laptop *asus)
-{
-	ASUS_LED_UNREGISTER(mled);
-	ASUS_LED_UNREGISTER(tled);
-	ASUS_LED_UNREGISTER(pled);
-	ASUS_LED_UNREGISTER(rled);
-	ASUS_LED_UNREGISTER(gled);
-	ASUS_LED_UNREGISTER(kled);
-	if (asus->leds.workqueue) {
-		destroy_workqueue(asus->leds.workqueue);
-		asus->leds.workqueue = NULL;
-	}
-}
-
-static void asus_input_exit(struct asus_laptop *asus)
-{
-	if (asus->inputdev)
-		input_unregister_device(asus->inputdev);
-}
-
-static int asus_backlight_init(struct asus_laptop *asus)
-{
-	struct backlight_device *bd;
-	struct device *dev = &asus->platform_device->dev;
-
-	if (brightness_set_handle && lcd_switch_handle) {
-		bd = backlight_device_register(ASUS_LAPTOP_FILE, dev,
-					       asus, &asusbl_ops);
-		if (IS_ERR(bd)) {
-			pr_err("Could not register asus backlight device\n");
-			asus->backlight_device = NULL;
-			return PTR_ERR(bd);
-		}
-
-		asus->backlight_device = bd;
-
-		bd->props.max_brightness = 15;
-		bd->props.brightness = read_brightness(NULL);
-		bd->props.power = FB_BLANK_UNBLANK;
-		backlight_update_status(bd);
-	}
-	return 0;
-}
-
-/*
- * Ugly macro, need to fix that later
- */
-#define ASUS_LED_REGISTER(asus, object, _name, max)			\
-	do {								\
-		struct led_classdev *ldev = &asus->leds.object;		\
-		if (!object##_set_handle)				\
-			break ;						\
-									\
-		INIT_WORK(&asus->leds.object##_work, object##_led_update); \
-		ldev->name = "asus::" _name;				\
-		ldev->brightness_set = object##_led_set;		\
-		ldev->max_brightness = max;				\
-		rv = led_classdev_register(&asus->platform_device->dev, ldev); \
-		if (rv)							\
-			goto error;					\
-	} while (0)
-
-static int asus_led_init(struct asus_laptop *asus)
-{
-	int rv;
-
-	/*
-	 * Functions that actually update the LED's are called from a
-	 * workqueue. By doing this as separate work rather than when the LED
-	 * subsystem asks, we avoid messing with the Asus ACPI stuff during a
-	 * potentially bad time, such as a timer interrupt.
-	 */
-	asus->leds.workqueue = create_singlethread_workqueue("led_workqueue");
-	if (!asus->leds.workqueue)
-		return -ENOMEM;
-
-	ASUS_LED_REGISTER(asus, mled, "mail", 1);
-	ASUS_LED_REGISTER(asus, tled, "touchpad", 1);
-	ASUS_LED_REGISTER(asus, rled, "record", 1);
-	ASUS_LED_REGISTER(asus, pled, "phone", 1);
-	ASUS_LED_REGISTER(asus, gled, "gaming", 1);
-	if (kled_set_handle && kled_get_handle)
-		ASUS_LED_REGISTER(asus, kled, "kbd_backlight", 3);
-error:
-	if (rv)
-		asus_led_exit(asus);
-	return rv;
-}
-
-
 static bool asus_device_present;
 
 static int __devinit asus_acpi_init(struct asus_laptop *asus)
@@ -1414,8 +1418,10 @@ static int __devinit asus_acpi_init(struct asus_laptop *asus)
 	asus_laptop_add_fs(asus);
 
 	/* WLED and BLED are on by default */
-	write_status(asus, bt_switch_handle, 1, BT_ON);
-	write_status(asus, wl_switch_handle, 1, WL_ON);
+	if (bluetooth_status >= 0)
+		write_status(asus, bt_switch_handle, !!bluetooth_status, BT_ON);
+	if (wireless_status >= 0)
+		write_status(asus, wl_switch_handle, !!wireless_status, WL_ON);
 
 	/* If the h/w switch is off, we need to check the real status */
 	write_status(asus, NULL, read_status(asus, BT_ON), BT_ON);
@@ -1432,8 +1438,8 @@ static int __devinit asus_acpi_init(struct asus_laptop *asus)
 	asus->ledd_status = 0xFFF;
 
 	/* Set initial values of light sensor and level */
-	hotk->light_switch = 0;	/* Default to light sensor disabled */
-	hotk->light_level = 5;	/* level 5 for sensor sensitivity */
+	asus->light_switch = 0;	/* Default to light sensor disabled */
+	asus->light_level = 5;	/* level 5 for sensor sensitivity */
 
 	if (ls_switch_handle)
 		set_light_sens_switch(asus, asus->light_switch);

commit 9129d14d297e78bc21caffa44d55a5920a74862c
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Tue Dec 1 22:39:41 2009 +0100

    asus-laptop: callbacks should use "driver data" parameter or field
    
    (Changelog stolen from Alan's patch for eeepc-laptop, but this patch
    does the same thing for asus-laptop)
    
    Callback methods should not refer to a variable like "asus" (formally
    "hotk").  Instead, they should extract the data they need either from
    a "driver data" parameter, or the "driver data" field of the object
    which they operate on.  The "asus" variable can then be removed.
    
    In practice, drivers under "drivers/platform" can get away without using
    driver data, because it doesn't make sense to have more than one
    instance of them.  However this makes it harder to review them for
    correctness.  This is especially true for core ACPI developers who have
    not previously been exposed to this anti-pattern :-).
    
    This will serve as an example of best practice for new driver writers
    (whether they find it themselves, or have it pointed out during review
    :-).
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 4ff30ca4df12..58a4864096d9 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -195,6 +195,34 @@ ASUS_HANDLE(gps_status, ASUS_LAPTOP_PREFIX "GPST");
 ASUS_HANDLE(kled_set, ASUS_LAPTOP_PREFIX "SLKB");
 ASUS_HANDLE(kled_get, ASUS_LAPTOP_PREFIX "GLKB");
 
+/*
+ * Define a specific led structure to keep the main structure clean
+ */
+#define ASUS_DEFINE_LED(object)					\
+	int object##_wk;					\
+	struct work_struct object##_work;			\
+	struct led_classdev object;
+
+
+#define led_to_asus(led_cdev, led)					\
+	container_of(container_of(led_cdev, struct asus_laptop_leds,	\
+				  led),					\
+		     struct asus_laptop, leds)
+#define work_to_asus(work, led)						\
+	container_of(container_of(work, struct asus_laptop_leds,	\
+				  led##_work),				\
+		     struct asus_laptop, leds)
+
+struct asus_laptop_leds {
+	ASUS_DEFINE_LED(mled)
+	ASUS_DEFINE_LED(tled)
+	ASUS_DEFINE_LED(rled)
+	ASUS_DEFINE_LED(pled)
+	ASUS_DEFINE_LED(gled)
+	ASUS_DEFINE_LED(kled)
+	struct workqueue_struct *workqueue;
+};
+
 /*
  * This is the main structure, we can use it to store anything interesting
  * about the hotk device
@@ -206,7 +234,11 @@ struct asus_laptop {
 	struct platform_device *platform_device;
 	struct acpi_device *device;		/* the device we are in */
 	struct backlight_device *backlight_device;
+
 	struct input_dev *inputdev;
+	struct key_entry *keymap;
+
+	struct asus_laptop_leds leds;
 
 	acpi_handle handle;	/* the handle of the hotk device */
 	char status;		/* status of the hotk, for LEDs, ... */
@@ -217,10 +249,6 @@ struct asus_laptop {
 	u16 *keycode_map;
 };
 
-static struct asus_laptop *asus;
-
-static struct workqueue_struct *led_workqueue;
-
 /*
  * The backlight class declaration
  */
@@ -237,8 +265,6 @@ static struct backlight_ops asusbl_ops = {
 	static enum led_brightness object##_led_get(			\
 		struct led_classdev *led_cdev);				\
 	static void object##_led_update(struct work_struct *ignored);	\
-	static int object##_led_wk;					\
-	static DECLARE_WORK(object##_led_work, object##_led_update);	\
 	static struct led_classdev object##_led = {			\
 		.name           = "asus::" ledname,			\
 		.brightness_set = object##_led_set,			\
@@ -261,7 +287,7 @@ struct key_entry {
 
 enum { KE_KEY, KE_END };
 
-static struct key_entry asus_keymap[] = {
+static const struct key_entry asus_keymap[] = {
 	{KE_KEY, 0x02, KEY_SCREENLOCK},
 	{KE_KEY, 0x05, KEY_WLAN},
 	{KE_KEY, 0x08, KEY_F13},
@@ -333,7 +359,7 @@ static int write_acpi_int(acpi_handle handle, const char *method, int val)
 	return write_acpi_int_ret(handle, method, val, NULL);
 }
 
-static int read_wireless_status(int mask)
+static int read_wireless_status(struct asus_laptop *asus, int mask)
 {
 	unsigned long long status;
 	acpi_status rv = AE_OK;
@@ -350,7 +376,7 @@ static int read_wireless_status(int mask)
 	return (asus->status & mask) ? 1 : 0;
 }
 
-static int read_gps_status(void)
+static int read_gps_status(struct asus_laptop *asus)
 {
 	unsigned long long status;
 	acpi_status rv = AE_OK;
@@ -365,18 +391,19 @@ static int read_gps_status(void)
 }
 
 /* Generic LED functions */
-static int read_status(int mask)
+static int read_status(struct asus_laptop *asus, int mask)
 {
 	/* There is a special method for both wireless devices */
 	if (mask == BT_ON || mask == WL_ON)
-		return read_wireless_status(mask);
+		return read_wireless_status(asus, mask);
 	else if (mask == GPS_ON)
-		return read_gps_status();
+		return read_gps_status(asus);
 
 	return (asus->status & mask) ? 1 : 0;
 }
 
-static void write_status(acpi_handle handle, int out, int mask)
+static void write_status(struct asus_laptop *asus, acpi_handle handle,
+			 int out, int mask)
 {
 	asus->status = (out) ? (asus->status | mask) : (asus->status & ~mask);
 
@@ -405,13 +432,19 @@ static void write_status(acpi_handle handle, int out, int mask)
 	static void object##_led_set(struct led_classdev *led_cdev,	\
 				     enum led_brightness value)		\
 	{								\
-		object##_led_wk = (value > 0) ? 1 : 0;			\
-		queue_work(led_workqueue, &object##_led_work);		\
+		struct asus_laptop *asus =				\
+			led_to_asus(led_cdev, object);			\
+									\
+		asus->leds.object##_wk = (value > 0) ? 1 : 0;		\
+		queue_work(asus->leds.workqueue,			\
+			   &asus->leds.object##_work);			\
 	}								\
-	static void object##_led_update(struct work_struct *ignored)	\
+	static void object##_led_update(struct work_struct *work)	\
 	{								\
-		int value = object##_led_wk;				\
-		write_status(object##_set_handle, value, (mask));	\
+		struct asus_laptop *asus = work_to_asus(work, object);	\
+									\
+		int value = asus->leds.object##_wk;			\
+		write_status(asus, object##_set_handle, value, (mask));	\
 	}								\
 	static enum led_brightness object##_led_get(			\
 		struct led_classdev *led_cdev)				\
@@ -448,7 +481,7 @@ static int get_kled_lvl(void)
 	return kblv;
 }
 
-static int set_kled_lvl(int kblv)
+static int set_kled_lvl(struct asus_laptop *asus, int kblv)
 {
 	if (kblv > 0)
 		kblv = (1 << 7) | (kblv & 0x7F);
@@ -465,13 +498,17 @@ static int set_kled_lvl(int kblv)
 static void kled_led_set(struct led_classdev *led_cdev,
 			 enum led_brightness value)
 {
-	kled_led_wk = value;
-	queue_work(led_workqueue, &kled_led_work);
+	struct asus_laptop *asus = led_to_asus(led_cdev, kled);
+
+	asus->leds.kled_wk = value;
+	queue_work(asus->leds.workqueue, &asus->leds.kled_work);
 }
 
-static void kled_led_update(struct work_struct *ignored)
+static void kled_led_update(struct work_struct *work)
 {
-	set_kled_lvl(kled_led_wk);
+	struct asus_laptop *asus = work_to_asus(work, kled);
+
+	set_kled_lvl(asus, asus->leds.kled_wk);
 }
 
 static enum led_brightness kled_led_get(struct led_classdev *led_cdev)
@@ -479,19 +516,19 @@ static enum led_brightness kled_led_get(struct led_classdev *led_cdev)
 	return get_kled_lvl();
 }
 
-static int get_lcd_state(void)
+static int get_lcd_state(struct asus_laptop *asus)
 {
-	return read_status(LCD_ON);
+	return read_status(asus, LCD_ON);
 }
 
-static int set_lcd_state(int value)
+static int set_lcd_state(struct asus_laptop *asus, int value)
 {
 	int lcd = 0;
 	acpi_status status = 0;
 
 	lcd = value ? 1 : 0;
 
-	if (lcd == get_lcd_state())
+	if (lcd == get_lcd_state(asus))
 		return 0;
 
 	if (lcd_switch_handle) {
@@ -502,11 +539,11 @@ static int set_lcd_state(int value)
 			pr_warning("Error switching LCD\n");
 	}
 
-	write_status(NULL, lcd, LCD_ON);
+	write_status(asus, NULL, lcd, LCD_ON);
 	return 0;
 }
 
-static void lcd_blank(int blank)
+static void lcd_blank(struct asus_laptop *asus, int blank)
 {
 	struct backlight_device *bd = asus->backlight_device;
 
@@ -539,6 +576,7 @@ static int set_brightness(struct backlight_device *bd, int value)
 
 static int update_bl_status(struct backlight_device *bd)
 {
+	struct asus_laptop *asus = bl_get_data(bd);
 	int rv;
 	int value = bd->props.brightness;
 
@@ -547,7 +585,7 @@ static int update_bl_status(struct backlight_device *bd)
 		return rv;
 
 	value = (bd->props.power == FB_BLANK_UNBLANK) ? 1 : 0;
-	return set_lcd_state(value);
+	return set_lcd_state(asus, value);
 }
 
 /*
@@ -562,6 +600,7 @@ static int update_bl_status(struct backlight_device *bd)
 static ssize_t show_infos(struct device *dev,
 			  struct device_attribute *attr, char *page)
 {
+	struct asus_laptop *asus = dev_get_drvdata(dev);
 	int len = 0;
 	unsigned long long temp;
 	char buf[16];		/* enough for all info */
@@ -638,7 +677,8 @@ static int parse_arg(const char *buf, unsigned long count, int *val)
 	return count;
 }
 
-static ssize_t store_status(const char *buf, size_t count,
+static ssize_t store_status(struct asus_laptop *asus,
+			    const char *buf, size_t count,
 			    acpi_handle handle, int mask)
 {
 	int rv, value;
@@ -648,7 +688,7 @@ static ssize_t store_status(const char *buf, size_t count,
 	if (rv > 0)
 		out = value ? 1 : 0;
 
-	write_status(handle, out, mask);
+	write_status(asus, handle, out, mask);
 
 	return rv;
 }
@@ -659,12 +699,15 @@ static ssize_t store_status(const char *buf, size_t count,
 static ssize_t show_ledd(struct device *dev,
 			 struct device_attribute *attr, char *buf)
 {
+	struct asus_laptop *asus = dev_get_drvdata(dev);
+
 	return sprintf(buf, "0x%08x\n", asus->ledd_status);
 }
 
 static ssize_t store_ledd(struct device *dev, struct device_attribute *attr,
 			  const char *buf, size_t count)
 {
+	struct asus_laptop *asus = dev_get_drvdata(dev);
 	int rv, value;
 
 	rv = parse_arg(buf, count, &value);
@@ -683,13 +726,17 @@ static ssize_t store_ledd(struct device *dev, struct device_attribute *attr,
 static ssize_t show_wlan(struct device *dev,
 			 struct device_attribute *attr, char *buf)
 {
-	return sprintf(buf, "%d\n", read_status(WL_ON));
+	struct asus_laptop *asus = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", read_status(asus, WL_ON));
 }
 
 static ssize_t store_wlan(struct device *dev, struct device_attribute *attr,
 			  const char *buf, size_t count)
 {
-	return store_status(buf, count, wl_switch_handle, WL_ON);
+	struct asus_laptop *asus = dev_get_drvdata(dev);
+
+	return store_status(asus, buf, count, wl_switch_handle, WL_ON);
 }
 
 /*
@@ -698,20 +745,24 @@ static ssize_t store_wlan(struct device *dev, struct device_attribute *attr,
 static ssize_t show_bluetooth(struct device *dev,
 			      struct device_attribute *attr, char *buf)
 {
-	return sprintf(buf, "%d\n", read_status(BT_ON));
+	struct asus_laptop *asus = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", read_status(asus, BT_ON));
 }
 
 static ssize_t store_bluetooth(struct device *dev,
 			       struct device_attribute *attr, const char *buf,
 			       size_t count)
 {
-	return store_status(buf, count, bt_switch_handle, BT_ON);
+	struct asus_laptop *asus = dev_get_drvdata(dev);
+
+	return store_status(asus, buf, count, bt_switch_handle, BT_ON);
 }
 
 /*
  * Display
  */
-static void set_display(int value)
+static void set_display(struct asus_laptop *asus, int value)
 {
 	/* no sanity check needed for now */
 	if (write_acpi_int(display_set_handle, NULL, value))
@@ -719,7 +770,7 @@ static void set_display(int value)
 	return;
 }
 
-static int read_display(void)
+static int read_display(struct asus_laptop *asus)
 {
 	unsigned long long value = 0;
 	acpi_status rv = AE_OK;
@@ -747,7 +798,9 @@ static int read_display(void)
 static ssize_t show_disp(struct device *dev,
 			 struct device_attribute *attr, char *buf)
 {
-	return sprintf(buf, "%d\n", read_display());
+	struct asus_laptop *asus = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", read_display(asus));
 }
 
 /*
@@ -760,18 +813,19 @@ static ssize_t show_disp(struct device *dev,
 static ssize_t store_disp(struct device *dev, struct device_attribute *attr,
 			  const char *buf, size_t count)
 {
+	struct asus_laptop *asus = dev_get_drvdata(dev);
 	int rv, value;
 
 	rv = parse_arg(buf, count, &value);
 	if (rv > 0)
-		set_display(value);
+		set_display(asus, value);
 	return rv;
 }
 
 /*
  * Light Sens
  */
-static void set_light_sens_switch(int value)
+static void set_light_sens_switch(struct asus_laptop *asus, int value)
 {
 	if (write_acpi_int(ls_switch_handle, NULL, value))
 		pr_warning("Error setting light sensor switch\n");
@@ -781,22 +835,25 @@ static void set_light_sens_switch(int value)
 static ssize_t show_lssw(struct device *dev,
 			 struct device_attribute *attr, char *buf)
 {
+	struct asus_laptop *asus = dev_get_drvdata(dev);
+
 	return sprintf(buf, "%d\n", asus->light_switch);
 }
 
 static ssize_t store_lssw(struct device *dev, struct device_attribute *attr,
 			  const char *buf, size_t count)
 {
+	struct asus_laptop *asus = dev_get_drvdata(dev);
 	int rv, value;
 
 	rv = parse_arg(buf, count, &value);
 	if (rv > 0)
-		set_light_sens_switch(value ? 1 : 0);
+		set_light_sens_switch(asus, value ? 1 : 0);
 
 	return rv;
 }
 
-static void set_light_sens_level(int value)
+static void set_light_sens_level(struct asus_laptop *asus, int value)
 {
 	if (write_acpi_int(ls_level_handle, NULL, value))
 		pr_warning("Error setting light sensor level\n");
@@ -806,19 +863,22 @@ static void set_light_sens_level(int value)
 static ssize_t show_lslvl(struct device *dev,
 			  struct device_attribute *attr, char *buf)
 {
+	struct asus_laptop *asus = dev_get_drvdata(dev);
+
 	return sprintf(buf, "%d\n", asus->light_level);
 }
 
 static ssize_t store_lslvl(struct device *dev, struct device_attribute *attr,
 			   const char *buf, size_t count)
 {
+	struct asus_laptop *asus = dev_get_drvdata(dev);
 	int rv, value;
 
 	rv = parse_arg(buf, count, &value);
 	if (rv > 0) {
 		value = (0 < value) ? ((15 < value) ? 15 : value) : 0;
 		/* 0 <= value <= 15 */
-		set_light_sens_level(value);
+		set_light_sens_level(asus, value);
 	}
 
 	return rv;
@@ -830,34 +890,40 @@ static ssize_t store_lslvl(struct device *dev, struct device_attribute *attr,
 static ssize_t show_gps(struct device *dev,
 			struct device_attribute *attr, char *buf)
 {
-	return sprintf(buf, "%d\n", read_status(GPS_ON));
+	struct asus_laptop *asus = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", read_status(asus, GPS_ON));
 }
 
 static ssize_t store_gps(struct device *dev, struct device_attribute *attr,
 			 const char *buf, size_t count)
 {
-	return store_status(buf, count, NULL, GPS_ON);
+	struct asus_laptop *asus = dev_get_drvdata(dev);
+
+	return store_status(asus, buf, count, NULL, GPS_ON);
 }
 
 /*
  * Hotkey functions
  */
-static struct key_entry *asus_get_entry_by_scancode(int code)
+static struct key_entry *asus_get_entry_by_scancode(struct asus_laptop *asus,
+						    int code)
 {
 	struct key_entry *key;
 
-	for (key = asus_keymap; key->type != KE_END; key++)
+	for (key = asus->keymap; key->type != KE_END; key++)
 		if (code == key->code)
 			return key;
 
 	return NULL;
 }
 
-static struct key_entry *asus_get_entry_by_keycode(int code)
+static struct key_entry *asus_get_entry_by_keycode(struct asus_laptop *asus,
+						   int code)
 {
 	struct key_entry *key;
 
-	for (key = asus_keymap; key->type != KE_END; key++)
+	for (key = asus->keymap; key->type != KE_END; key++)
 		if (code == key->keycode && key->type == KE_KEY)
 			return key;
 
@@ -866,7 +932,8 @@ static struct key_entry *asus_get_entry_by_keycode(int code)
 
 static int asus_getkeycode(struct input_dev *dev, int scancode, int *keycode)
 {
-	struct key_entry *key = asus_get_entry_by_scancode(scancode);
+	struct asus_laptop *asus = input_get_drvdata(dev);
+	struct key_entry *key = asus_get_entry_by_scancode(asus, scancode);
 
 	if (key && key->type == KE_KEY) {
 		*keycode = key->keycode;
@@ -878,18 +945,19 @@ static int asus_getkeycode(struct input_dev *dev, int scancode, int *keycode)
 
 static int asus_setkeycode(struct input_dev *dev, int scancode, int keycode)
 {
+	struct asus_laptop *asus = input_get_drvdata(dev);
 	struct key_entry *key;
 	int old_keycode;
 
 	if (keycode < 0 || keycode > KEY_MAX)
 		return -EINVAL;
 
-	key = asus_get_entry_by_scancode(scancode);
+	key = asus_get_entry_by_scancode(asus, scancode);
 	if (key && key->type == KE_KEY) {
 		old_keycode = key->keycode;
 		key->keycode = keycode;
 		set_bit(keycode, dev->keybit);
-		if (!asus_get_entry_by_keycode(old_keycode))
+		if (!asus_get_entry_by_keycode(asus, old_keycode))
 			clear_bit(old_keycode, dev->keybit);
 		return 0;
 	}
@@ -899,6 +967,7 @@ static int asus_setkeycode(struct input_dev *dev, int scancode, int keycode)
 
 static void asus_acpi_notify(struct acpi_device *device, u32 event)
 {
+	struct asus_laptop *asus = acpi_driver_data(device);
 	static struct key_entry *key;
 	u16 count;
 
@@ -907,11 +976,11 @@ static void asus_acpi_notify(struct acpi_device *device, u32 event)
 	 * switched
 	 */
 	if (event == ATKD_LCD_ON) {
-		write_status(NULL, 1, LCD_ON);
-		lcd_blank(FB_BLANK_UNBLANK);
+		write_status(asus, NULL, 1, LCD_ON);
+		lcd_blank(asus, FB_BLANK_UNBLANK);
 	} else if (event == ATKD_LCD_OFF) {
-		write_status(NULL, 0, LCD_ON);
-		lcd_blank(FB_BLANK_POWERDOWN);
+		write_status(asus, NULL, 0, LCD_ON);
+		lcd_blank(asus, FB_BLANK_POWERDOWN);
 	}
 
 	/* TODO Find a better way to handle events count. */
@@ -922,7 +991,7 @@ static void asus_acpi_notify(struct acpi_device *device, u32 event)
 					count);
 
 	if (asus->inputdev) {
-		key = asus_get_entry_by_scancode(event);
+		key = asus_get_entry_by_scancode(asus, event);
 		if (!key)
 			return ;
 
@@ -978,13 +1047,14 @@ static struct attribute_group platform_attribute_group = {
 	.attrs = asuspf_attributes
 };
 
-static int asus_platform_init(void)
+static int asus_platform_init(struct asus_laptop *asus)
 {
 	int result;
 
 	asus->platform_device = platform_device_alloc(ASUS_LAPTOP_FILE, -1);
 	if (!asus->platform_device)
 		return -ENOMEM;
+	platform_set_drvdata(asus->platform_device, asus);
 
 	result = platform_device_add(asus->platform_device);
 	if (result)
@@ -1003,7 +1073,7 @@ static int asus_platform_init(void)
 	return result;
 }
 
-static void asus_platform_exit(void)
+static void asus_platform_exit(struct asus_laptop *asus)
 {
 	sysfs_remove_group(&asus->platform_device->dev.kobj,
 			   &platform_attribute_group);
@@ -1012,12 +1082,12 @@ static void asus_platform_exit(void)
 
 static struct platform_driver platform_driver = {
 	.driver = {
-		   .name = ASUS_LAPTOP_FILE,
-		   .owner = THIS_MODULE,
-		   }
+		.name = ASUS_LAPTOP_FILE,
+		.owner = THIS_MODULE,
+	}
 };
 
-static void asus_laptop_add_fs(void)
+static void asus_laptop_add_fs(struct asus_laptop *asus)
 {
 	ASUS_SET_DEVICE_ATTR(infos, 0444, show_infos, NULL);
 
@@ -1187,7 +1257,7 @@ static int asus_laptop_get_info(struct asus_laptop *asus)
 	return AE_OK;
 }
 
-static int asus_input_init(struct device *dev)
+static int asus_input_init(struct asus_laptop *asus)
 {
 	const struct key_entry *key;
 	int result;
@@ -1198,13 +1268,16 @@ static int asus_input_init(struct device *dev)
 		return 0;
 	}
 	asus->inputdev->name = "Asus Laptop extra buttons";
-	asus->inputdev->dev.parent = dev;
+	asus->inputdev->dev.parent = &asus->platform_device->dev;
 	asus->inputdev->phys = ASUS_LAPTOP_FILE "/input0";
 	asus->inputdev->id.bustype = BUS_HOST;
 	asus->inputdev->getkeycode = asus_getkeycode;
 	asus->inputdev->setkeycode = asus_setkeycode;
+	input_set_drvdata(asus->inputdev, asus);
 
-	for (key = asus_keymap; key->type != KE_END; key++) {
+	asus->keymap = kmemdup(asus_keymap, sizeof(asus_keymap),
+				GFP_KERNEL);
+	for (key = asus->keymap; key->type != KE_END; key++) {
 		switch (key->type) {
 		case KE_KEY:
 			set_bit(EV_KEY, asus->inputdev->evbit);
@@ -1220,40 +1293,44 @@ static int asus_input_init(struct device *dev)
 	return result;
 }
 
-static void asus_backlight_exit(void)
+static void asus_backlight_exit(struct asus_laptop *asus)
 {
 	if (asus->backlight_device)
 		backlight_device_unregister(asus->backlight_device);
 }
 
-#define  ASUS_LED_UNREGISTER(object)				\
+#define ASUS_LED_UNREGISTER(object)				\
 	if (object##_led.dev)					\
 		led_classdev_unregister(&object##_led)
 
-static void asus_led_exit(void)
+static void asus_led_exit(struct asus_laptop *asus)
 {
-	destroy_workqueue(led_workqueue);
 	ASUS_LED_UNREGISTER(mled);
 	ASUS_LED_UNREGISTER(tled);
 	ASUS_LED_UNREGISTER(pled);
 	ASUS_LED_UNREGISTER(rled);
 	ASUS_LED_UNREGISTER(gled);
 	ASUS_LED_UNREGISTER(kled);
+	if (asus->leds.workqueue) {
+		destroy_workqueue(asus->leds.workqueue);
+		asus->leds.workqueue = NULL;
+	}
 }
 
-static void asus_input_exit(void)
+static void asus_input_exit(struct asus_laptop *asus)
 {
 	if (asus->inputdev)
 		input_unregister_device(asus->inputdev);
 }
 
-static int asus_backlight_init(struct device *dev)
+static int asus_backlight_init(struct asus_laptop *asus)
 {
 	struct backlight_device *bd;
+	struct device *dev = &asus->platform_device->dev;
 
 	if (brightness_set_handle && lcd_switch_handle) {
 		bd = backlight_device_register(ASUS_LAPTOP_FILE, dev,
-					       NULL, &asusbl_ops);
+					       asus, &asusbl_ops);
 		if (IS_ERR(bd)) {
 			pr_err("Could not register asus backlight device\n");
 			asus->backlight_device = NULL;
@@ -1270,79 +1347,55 @@ static int asus_backlight_init(struct device *dev)
 	return 0;
 }
 
-static int asus_led_register(acpi_handle handle,
-			     struct led_classdev *ldev, struct device *dev)
-{
-	if (!handle)
-		return 0;
-
-	return led_classdev_register(dev, ldev);
-}
-
-#define ASUS_LED_REGISTER(object, device)				\
-	asus_led_register(object##_set_handle, &object##_led, device)
-
-static int asus_led_init(struct device *dev)
+/*
+ * Ugly macro, need to fix that later
+ */
+#define ASUS_LED_REGISTER(asus, object, _name, max)			\
+	do {								\
+		struct led_classdev *ldev = &asus->leds.object;		\
+		if (!object##_set_handle)				\
+			break ;						\
+									\
+		INIT_WORK(&asus->leds.object##_work, object##_led_update); \
+		ldev->name = "asus::" _name;				\
+		ldev->brightness_set = object##_led_set;		\
+		ldev->max_brightness = max;				\
+		rv = led_classdev_register(&asus->platform_device->dev, ldev); \
+		if (rv)							\
+			goto error;					\
+	} while (0)
+
+static int asus_led_init(struct asus_laptop *asus)
 {
 	int rv;
 
-	rv = ASUS_LED_REGISTER(mled, dev);
-	if (rv)
-		goto out;
-
-	rv = ASUS_LED_REGISTER(tled, dev);
-	if (rv)
-		goto out1;
-
-	rv = ASUS_LED_REGISTER(rled, dev);
-	if (rv)
-		goto out2;
-
-	rv = ASUS_LED_REGISTER(pled, dev);
-	if (rv)
-		goto out3;
-
-	rv = ASUS_LED_REGISTER(gled, dev);
-	if (rv)
-		goto out4;
-
-	if (kled_set_handle && kled_get_handle)
-		rv = ASUS_LED_REGISTER(kled, dev);
-	if (rv)
-		goto out5;
-
 	/*
 	 * Functions that actually update the LED's are called from a
 	 * workqueue. By doing this as separate work rather than when the LED
 	 * subsystem asks, we avoid messing with the Asus ACPI stuff during a
 	 * potentially bad time, such as a timer interrupt.
 	 */
-	led_workqueue = create_singlethread_workqueue("led_workqueue");
-	if (!led_workqueue)
-		goto out6;
+	asus->leds.workqueue = create_singlethread_workqueue("led_workqueue");
+	if (!asus->leds.workqueue)
+		return -ENOMEM;
 
-	return 0;
-out6:
-	rv = -ENOMEM;
-	ASUS_LED_UNREGISTER(kled);
-out5:
-	ASUS_LED_UNREGISTER(gled);
-out4:
-	ASUS_LED_UNREGISTER(pled);
-out3:
-	ASUS_LED_UNREGISTER(rled);
-out2:
-	ASUS_LED_UNREGISTER(tled);
-out1:
-	ASUS_LED_UNREGISTER(mled);
-out:
+	ASUS_LED_REGISTER(asus, mled, "mail", 1);
+	ASUS_LED_REGISTER(asus, tled, "touchpad", 1);
+	ASUS_LED_REGISTER(asus, rled, "record", 1);
+	ASUS_LED_REGISTER(asus, pled, "phone", 1);
+	ASUS_LED_REGISTER(asus, gled, "gaming", 1);
+	if (kled_set_handle && kled_get_handle)
+		ASUS_LED_REGISTER(asus, kled, "kbd_backlight", 3);
+error:
+	if (rv)
+		asus_led_exit(asus);
 	return rv;
 }
 
 
 static bool asus_device_present;
 
-static int __devinit asus_acpi_init(struct acpi_device *device)
+static int __devinit asus_acpi_init(struct asus_laptop *asus)
 {
 	int result = 0;
 
@@ -1358,22 +1411,22 @@ static int __devinit asus_acpi_init(struct acpi_device *device)
 	if (result)
 		return result;
 
-	asus_laptop_add_fs();
+	asus_laptop_add_fs(asus);
 
 	/* WLED and BLED are on by default */
-	write_status(bt_switch_handle, 1, BT_ON);
-	write_status(wl_switch_handle, 1, WL_ON);
+	write_status(asus, bt_switch_handle, 1, BT_ON);
+	write_status(asus, wl_switch_handle, 1, WL_ON);
 
 	/* If the h/w switch is off, we need to check the real status */
-	write_status(NULL, read_status(BT_ON), BT_ON);
-	write_status(NULL, read_status(WL_ON), WL_ON);
+	write_status(asus, NULL, read_status(asus, BT_ON), BT_ON);
+	write_status(asus, NULL, read_status(asus, WL_ON), WL_ON);
 
 	/* LCD Backlight is on by default */
-	write_status(NULL, 1, LCD_ON);
+	write_status(asus, NULL, 1, LCD_ON);
 
 	/* Keyboard Backlight is on by default */
 	if (kled_set_handle)
-		set_kled_lvl(1);
+		set_kled_lvl(asus, 1);
 
 	/* LED display is off by default */
 	asus->ledd_status = 0xFFF;
@@ -1383,18 +1436,19 @@ static int __devinit asus_acpi_init(struct acpi_device *device)
 	hotk->light_level = 5;	/* level 5 for sensor sensitivity */
 
 	if (ls_switch_handle)
-		set_light_sens_switch(asus->light_switch);
+		set_light_sens_switch(asus, asus->light_switch);
 
 	if (ls_level_handle)
-		set_light_sens_level(asus->light_level);
+		set_light_sens_level(asus, asus->light_level);
 
 	/* GPS is on by default */
-	write_status(NULL, 1, GPS_ON);
+	write_status(asus, NULL, 1, GPS_ON);
 	return result;
 }
 
 static int __devinit asus_acpi_add(struct acpi_device *device)
 {
+	struct asus_laptop *asus;
 	int result;
 
 	pr_notice("Asus Laptop Support version %s\n",
@@ -1408,7 +1462,7 @@ static int __devinit asus_acpi_add(struct acpi_device *device)
 	device->driver_data = asus;
 	asus->device = device;
 
-	result = asus_acpi_init(device);
+	result = asus_acpi_init(asus);
 	if (result)
 		goto fail_platform;
 
@@ -1416,22 +1470,22 @@ static int __devinit asus_acpi_add(struct acpi_device *device)
 	 * Register the platform device first.  It is used as a parent for the
 	 * sub-devices below.
 	 */
-	result = asus_platform_init();
+	result = asus_platform_init(asus);
 	if (result)
 		goto fail_platform;
 
 	if (!acpi_video_backlight_support()) {
-		result = asus_backlight_init(&asus->platform_device->dev);
+		result = asus_backlight_init(asus);
 		if (result)
 			goto fail_backlight;
 	} else
 		pr_info("Backlight controlled by ACPI video driver\n");
 
-	result = asus_input_init(&asus->platform_device->dev);
+	result = asus_input_init(asus);
 	if (result)
 		goto fail_input;
 
-	result = asus_led_init(&asus->platform_device->dev);
+	result = asus_led_init(asus);
 	if (result)
 		goto fail_led;
 
@@ -1439,11 +1493,11 @@ static int __devinit asus_acpi_add(struct acpi_device *device)
 	return 0;
 
 fail_led:
-	asus_input_exit();
+	asus_input_exit(asus);
 fail_input:
-	asus_backlight_exit();
+	asus_backlight_exit(asus);
 fail_backlight:
-	asus_platform_exit();
+	asus_platform_exit(asus);
 fail_platform:
 	kfree(asus->name);
 	kfree(asus);
@@ -1453,10 +1507,12 @@ static int __devinit asus_acpi_add(struct acpi_device *device)
 
 static int asus_acpi_remove(struct acpi_device *device, int type)
 {
-	asus_backlight_exit();
-	asus_led_exit();
-	asus_input_exit();
-	asus_platform_exit();
+	struct asus_laptop *asus = acpi_driver_data(device);
+
+	asus_backlight_exit(asus);
+	asus_led_exit(asus);
+	asus_input_exit(asus);
+	asus_platform_exit(asus);
 
 	kfree(asus->name);
 	kfree(asus);

commit 7c247645f305da2bb309fa439fd6cc0aa26f8722
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Mon Nov 30 22:13:54 2009 +0100

    asus-laptop: move backlight and dsdt info inside asus_laptop struct
    
    Prepare the use of "driver data" for callbacks.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 2505f15cbe6b..4ff30ca4df12 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -202,30 +202,24 @@ ASUS_HANDLE(kled_get, ASUS_LAPTOP_PREFIX "GLKB");
 struct asus_laptop {
 	char *name;		/* laptop name */
 
+	struct acpi_table_header *dsdt_info;
 	struct platform_device *platform_device;
-	struct acpi_device *device;	/* the device we are in */
+	struct acpi_device *device;		/* the device we are in */
+	struct backlight_device *backlight_device;
+	struct input_dev *inputdev;
+
 	acpi_handle handle;	/* the handle of the hotk device */
 	char status;		/* status of the hotk, for LEDs, ... */
 	u32 ledd_status;	/* status of the LED display */
 	u8 light_level;		/* light sensor level */
 	u8 light_switch;	/* light sensor switch value */
 	u16 event_count[128];	/* count for each event TODO make this better */
-	struct input_dev *inputdev;
 	u16 *keycode_map;
 };
 
-/*
- * This header is made available to allow proper configuration given model,
- * revision number , ... this info cannot go in struct asus_laptop because it is
- * available before the hotk
- */
-static struct acpi_table_header *asus_info;
-
-/* The actual device the driver binds to */
 static struct asus_laptop *asus;
 
-/* The backlight device /sys/class/backlight */
-static struct backlight_device *asus_backlight_device;
+static struct workqueue_struct *led_workqueue;
 
 /*
  * The backlight class declaration
@@ -237,14 +231,6 @@ static struct backlight_ops asusbl_ops = {
 	.update_status = update_bl_status,
 };
 
-/*
- * These functions actually update the LED's, and are called from a
- * workqueue. By doing this as separate work rather than when the LED
- * subsystem asks, we avoid messing with the Asus ACPI stuff during a
- * potentially bad time, such as a timer interrupt.
- */
-static struct workqueue_struct *led_workqueue;
-
 #define ASUS_LED(object, ledname, max)					\
 	static void object##_led_set(struct led_classdev *led_cdev,	\
 				     enum led_brightness value);	\
@@ -522,7 +508,7 @@ static int set_lcd_state(int value)
 
 static void lcd_blank(int blank)
 {
-	struct backlight_device *bd = asus_backlight_device;
+	struct backlight_device *bd = asus->backlight_device;
 
 	if (bd) {
 		bd->props.power = blank;
@@ -619,22 +605,22 @@ static ssize_t show_infos(struct device *dev,
 	if (!ACPI_FAILURE(rv))
 		len += sprintf(page + len, "ASYM value         : %#x\n",
 			       (uint) temp);
-	if (asus_info) {
-		snprintf(buf, 16, "%d", asus_info->length);
+	if (asus->dsdt_info) {
+		snprintf(buf, 16, "%d", asus->dsdt_info->length);
 		len += sprintf(page + len, "DSDT length        : %s\n", buf);
-		snprintf(buf, 16, "%d", asus_info->checksum);
+		snprintf(buf, 16, "%d", asus->dsdt_info->checksum);
 		len += sprintf(page + len, "DSDT checksum      : %s\n", buf);
-		snprintf(buf, 16, "%d", asus_info->revision);
+		snprintf(buf, 16, "%d", asus->dsdt_info->revision);
 		len += sprintf(page + len, "DSDT revision      : %s\n", buf);
-		snprintf(buf, 7, "%s", asus_info->oem_id);
+		snprintf(buf, 7, "%s", asus->dsdt_info->oem_id);
 		len += sprintf(page + len, "OEM id             : %s\n", buf);
-		snprintf(buf, 9, "%s", asus_info->oem_table_id);
+		snprintf(buf, 9, "%s", asus->dsdt_info->oem_table_id);
 		len += sprintf(page + len, "OEM table id       : %s\n", buf);
-		snprintf(buf, 16, "%x", asus_info->oem_revision);
+		snprintf(buf, 16, "%x", asus->dsdt_info->oem_revision);
 		len += sprintf(page + len, "OEM revision       : 0x%s\n", buf);
-		snprintf(buf, 5, "%s", asus_info->asl_compiler_id);
+		snprintf(buf, 5, "%s", asus->dsdt_info->asl_compiler_id);
 		len += sprintf(page + len, "ASL comp vendor id : %s\n", buf);
-		snprintf(buf, 16, "%x", asus_info->asl_compiler_revision);
+		snprintf(buf, 16, "%x", asus->dsdt_info->asl_compiler_revision);
 		len += sprintf(page + len, "ASL comp revision  : 0x%s\n", buf);
 	}
 
@@ -1084,7 +1070,7 @@ static int asus_handle_init(char *name, acpi_handle * handle,
  * method, we can make all the detection we want, and modify the asus_laptop
  * struct
  */
-static int asus_laptop_get_info(void)
+static int asus_laptop_get_info(struct asus_laptop *asus)
 {
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 	union acpi_object *model = NULL;
@@ -1097,10 +1083,9 @@ static int asus_laptop_get_info(void)
 	 * models, but late enough to allow acpi_bus_register_driver() to fail
 	 * before doing anything ACPI-specific. Should we encounter a machine,
 	 * which needs special handling (i.e. its hotkey device has a different
-	 * HID), this bit will be moved. A global variable asus_info contains
-	 * the DSDT header.
+	 * HID), this bit will be moved.
 	 */
-	status = acpi_get_table(ACPI_SIG_DSDT, 1, &asus_info);
+	status = acpi_get_table(ACPI_SIG_DSDT, 1, &asus->dsdt_info);
 	if (ACPI_FAILURE(status))
 		pr_warning("Couldn't get the DSDT table header\n");
 
@@ -1237,8 +1222,8 @@ static int asus_input_init(struct device *dev)
 
 static void asus_backlight_exit(void)
 {
-	if (asus_backlight_device)
-		backlight_device_unregister(asus_backlight_device);
+	if (asus->backlight_device)
+		backlight_device_unregister(asus->backlight_device);
 }
 
 #define  ASUS_LED_UNREGISTER(object)				\
@@ -1271,11 +1256,11 @@ static int asus_backlight_init(struct device *dev)
 					       NULL, &asusbl_ops);
 		if (IS_ERR(bd)) {
 			pr_err("Could not register asus backlight device\n");
-			asus_backlight_device = NULL;
+			asus->backlight_device = NULL;
 			return PTR_ERR(bd);
 		}
 
-		asus_backlight_device = bd;
+		asus->backlight_device = bd;
 
 		bd->props.max_brightness = 15;
 		bd->props.brightness = read_brightness(NULL);
@@ -1326,6 +1311,12 @@ static int asus_led_init(struct device *dev)
 	if (rv)
 		goto out5;
 
+	/*
+	 * Functions that actually update the LED's are called from a
+	 * workqueue. By doing this as separate work rather than when the LED
+	 * subsystem asks, we avoid messing with the Asus ACPI stuff during a
+	 * potentially bad time, such as a timer interrupt.
+	 */
 	led_workqueue = create_singlethread_workqueue("led_workqueue");
 	if (!led_workqueue)
 		goto out6;
@@ -1363,7 +1354,7 @@ static int __devinit asus_acpi_init(struct acpi_device *device)
 		return -ENODEV;
 	}
 
-	result = asus_laptop_get_info();
+	result = asus_laptop_get_info(asus);
 	if (result)
 		return result;
 

commit 50a90c4d953fe4bb5a87ee5207c4243d25278189
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Mon Nov 30 21:55:12 2009 +0100

    asus-laptop: revise names
    
    asus-laptop now does a lot more than just hotkeys.  Replace the "hotk"
    names used throughout the driver with some slightly more appropriate
    names.  The actual strings used in kernel messages and sysfs are left
    unchanged.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 8834405be1fd..2505f15cbe6b 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -52,11 +52,11 @@
 
 #define ASUS_LAPTOP_VERSION	"0.42"
 
-#define ASUS_HOTK_NAME		"Asus Laptop Support"
-#define ASUS_HOTK_CLASS		"hotkey"
-#define ASUS_HOTK_DEVICE_NAME	"Hotkey"
-#define ASUS_HOTK_FILE		KBUILD_MODNAME
-#define ASUS_HOTK_PREFIX	"\\_SB.ATKD."
+#define ASUS_LAPTOP_NAME	"Asus Laptop Support"
+#define ASUS_LAPTOP_CLASS	"hotkey"
+#define ASUS_LAPTOP_DEVICE_NAME	"Hotkey"
+#define ASUS_LAPTOP_FILE	KBUILD_MODNAME
+#define ASUS_LAPTOP_PREFIX	"\\_SB.ATKD."
 
 
 /*
@@ -89,7 +89,7 @@
 #define KEY_ON		0x200	/* Keyboard backlight */
 
 MODULE_AUTHOR("Julien Lerouge, Karol Kozimor, Corentin Chary");
-MODULE_DESCRIPTION(ASUS_HOTK_NAME);
+MODULE_DESCRIPTION(ASUS_LAPTOP_NAME);
 MODULE_LICENSE("GPL");
 
 /*
@@ -124,27 +124,27 @@ MODULE_PARM_DESC(bluetooth_status, "Set the wireless status on boot "
 	static char *object##_paths[] = { paths }
 
 /* LED */
-ASUS_HANDLE(mled_set, ASUS_HOTK_PREFIX "MLED");
-ASUS_HANDLE(tled_set, ASUS_HOTK_PREFIX "TLED");
-ASUS_HANDLE(rled_set, ASUS_HOTK_PREFIX "RLED");	/* W1JC */
-ASUS_HANDLE(pled_set, ASUS_HOTK_PREFIX "PLED");	/* A7J */
-ASUS_HANDLE(gled_set, ASUS_HOTK_PREFIX "GLED");	/* G1, G2 (probably) */
+ASUS_HANDLE(mled_set, ASUS_LAPTOP_PREFIX "MLED");
+ASUS_HANDLE(tled_set, ASUS_LAPTOP_PREFIX "TLED");
+ASUS_HANDLE(rled_set, ASUS_LAPTOP_PREFIX "RLED");	/* W1JC */
+ASUS_HANDLE(pled_set, ASUS_LAPTOP_PREFIX "PLED");	/* A7J */
+ASUS_HANDLE(gled_set, ASUS_LAPTOP_PREFIX "GLED");	/* G1, G2 (probably) */
 
 /* LEDD */
-ASUS_HANDLE(ledd_set, ASUS_HOTK_PREFIX "SLCM");
+ASUS_HANDLE(ledd_set, ASUS_LAPTOP_PREFIX "SLCM");
 
 /*
  * Bluetooth and WLAN
  * WLED and BLED are not handled like other XLED, because in some dsdt
  * they also control the WLAN/Bluetooth device.
  */
-ASUS_HANDLE(wl_switch, ASUS_HOTK_PREFIX "WLED");
-ASUS_HANDLE(bt_switch, ASUS_HOTK_PREFIX "BLED");
-ASUS_HANDLE(wireless_status, ASUS_HOTK_PREFIX "RSTS");	/* All new models */
+ASUS_HANDLE(wl_switch, ASUS_LAPTOP_PREFIX "WLED");
+ASUS_HANDLE(bt_switch, ASUS_LAPTOP_PREFIX "BLED");
+ASUS_HANDLE(wireless_status, ASUS_LAPTOP_PREFIX "RSTS");	/* All new models */
 
 /* Brightness */
-ASUS_HANDLE(brightness_set, ASUS_HOTK_PREFIX "SPLV");
-ASUS_HANDLE(brightness_get, ASUS_HOTK_PREFIX "GPLV");
+ASUS_HANDLE(brightness_set, ASUS_LAPTOP_PREFIX "SPLV");
+ASUS_HANDLE(brightness_get, ASUS_LAPTOP_PREFIX "GPLV");
 
 /* Backlight */
 ASUS_HANDLE(lcd_switch, "\\_SB.PCI0.SBRG.EC0._Q10",	/* All new models */
@@ -157,7 +157,7 @@ ASUS_HANDLE(lcd_switch, "\\_SB.PCI0.SBRG.EC0._Q10",	/* All new models */
 	    "\\Q10");		/* A2x, L2D, L3D, M2E */
 
 /* Display */
-ASUS_HANDLE(display_set, ASUS_HOTK_PREFIX "SDSP");
+ASUS_HANDLE(display_set, ASUS_LAPTOP_PREFIX "SDSP");
 ASUS_HANDLE(display_get,
 	    /* A6B, A6K A6R A7D F3JM L4R M6R A3G M6A M6V VX-1 V6J V6V W3Z */
 	    "\\_SB.PCI0.P0P1.VGA.GETD",
@@ -182,24 +182,24 @@ ASUS_HANDLE(display_get,
 	    /* A3F A6F A3N A3L M6N W3N W6A */
 	    "\\SSTE");
 
-ASUS_HANDLE(ls_switch, ASUS_HOTK_PREFIX "ALSC"); /* Z71A Z71V */
-ASUS_HANDLE(ls_level, ASUS_HOTK_PREFIX "ALSL");	 /* Z71A Z71V */
+ASUS_HANDLE(ls_switch, ASUS_LAPTOP_PREFIX "ALSC"); /* Z71A Z71V */
+ASUS_HANDLE(ls_level, ASUS_LAPTOP_PREFIX "ALSL");	 /* Z71A Z71V */
 
 /* GPS */
 /* R2H use different handle for GPS on/off */
-ASUS_HANDLE(gps_on, ASUS_HOTK_PREFIX "SDON");	/* R2H */
-ASUS_HANDLE(gps_off, ASUS_HOTK_PREFIX "SDOF");	/* R2H */
-ASUS_HANDLE(gps_status, ASUS_HOTK_PREFIX "GPST");
+ASUS_HANDLE(gps_on, ASUS_LAPTOP_PREFIX "SDON");	/* R2H */
+ASUS_HANDLE(gps_off, ASUS_LAPTOP_PREFIX "SDOF");	/* R2H */
+ASUS_HANDLE(gps_status, ASUS_LAPTOP_PREFIX "GPST");
 
 /* Keyboard light */
-ASUS_HANDLE(kled_set, ASUS_HOTK_PREFIX "SLKB");
-ASUS_HANDLE(kled_get, ASUS_HOTK_PREFIX "GLKB");
+ASUS_HANDLE(kled_set, ASUS_LAPTOP_PREFIX "SLKB");
+ASUS_HANDLE(kled_get, ASUS_LAPTOP_PREFIX "GLKB");
 
 /*
  * This is the main structure, we can use it to store anything interesting
  * about the hotk device
  */
-struct asus_hotk {
+struct asus_laptop {
 	char *name;		/* laptop name */
 
 	struct platform_device *platform_device;
@@ -216,13 +216,13 @@ struct asus_hotk {
 
 /*
  * This header is made available to allow proper configuration given model,
- * revision number , ... this info cannot go in struct asus_hotk because it is
+ * revision number , ... this info cannot go in struct asus_laptop because it is
  * available before the hotk
  */
 static struct acpi_table_header *asus_info;
 
 /* The actual device the driver binds to */
-static struct asus_hotk *hotk;
+static struct asus_laptop *asus;
 
 /* The backlight device /sys/class/backlight */
 static struct backlight_device *asus_backlight_device;
@@ -353,7 +353,7 @@ static int read_wireless_status(int mask)
 	acpi_status rv = AE_OK;
 
 	if (!wireless_status_handle)
-		return (hotk->status & mask) ? 1 : 0;
+		return (asus->status & mask) ? 1 : 0;
 
 	rv = acpi_evaluate_integer(wireless_status_handle, NULL, NULL, &status);
 	if (ACPI_FAILURE(rv))
@@ -361,7 +361,7 @@ static int read_wireless_status(int mask)
 	else
 		return (status & mask) ? 1 : 0;
 
-	return (hotk->status & mask) ? 1 : 0;
+	return (asus->status & mask) ? 1 : 0;
 }
 
 static int read_gps_status(void)
@@ -375,7 +375,7 @@ static int read_gps_status(void)
 	else
 		return status ? 1 : 0;
 
-	return (hotk->status & GPS_ON) ? 1 : 0;
+	return (asus->status & GPS_ON) ? 1 : 0;
 }
 
 /* Generic LED functions */
@@ -387,12 +387,12 @@ static int read_status(int mask)
 	else if (mask == GPS_ON)
 		return read_gps_status();
 
-	return (hotk->status & mask) ? 1 : 0;
+	return (asus->status & mask) ? 1 : 0;
 }
 
 static void write_status(acpi_handle handle, int out, int mask)
 {
-	hotk->status = (out) ? (hotk->status | mask) : (hotk->status & ~mask);
+	asus->status = (out) ? (asus->status | mask) : (asus->status & ~mask);
 
 	switch (mask) {
 	case MLED_ON:
@@ -586,15 +586,15 @@ static ssize_t show_infos(struct device *dev,
 	 * to 1
 	 */
 
-	len += sprintf(page, ASUS_HOTK_NAME " " ASUS_LAPTOP_VERSION "\n");
-	len += sprintf(page + len, "Model reference    : %s\n", hotk->name);
+	len += sprintf(page, ASUS_LAPTOP_NAME " " ASUS_LAPTOP_VERSION "\n");
+	len += sprintf(page + len, "Model reference    : %s\n", asus->name);
 	/*
 	 * The SFUN method probably allows the original driver to get the list
 	 * of features supported by a given model. For now, 0x0100 or 0x0800
 	 * bit signifies that the laptop is equipped with a Wi-Fi MiniPCI card.
 	 * The significance of others is yet to be found.
 	 */
-	rv = acpi_evaluate_integer(hotk->handle, "SFUN", NULL, &temp);
+	rv = acpi_evaluate_integer(asus->handle, "SFUN", NULL, &temp);
 	if (!ACPI_FAILURE(rv))
 		len += sprintf(page + len, "SFUN value         : %#x\n",
 			       (uint) temp);
@@ -604,7 +604,7 @@ static ssize_t show_infos(struct device *dev,
 	 * The significance of others is yet to be found.
 	 * If we don't find the method, we assume the device are present.
 	 */
-	rv = acpi_evaluate_integer(hotk->handle, "HRWS", NULL, &temp);
+	rv = acpi_evaluate_integer(asus->handle, "HRWS", NULL, &temp);
 	if (!ACPI_FAILURE(rv))
 		len += sprintf(page + len, "HRWS value         : %#x\n",
 			       (uint) temp);
@@ -615,7 +615,7 @@ static ssize_t show_infos(struct device *dev,
 	 * Note: since not all the laptops provide this method, errors are
 	 * silently ignored.
 	 */
-	rv = acpi_evaluate_integer(hotk->handle, "ASYM", NULL, &temp);
+	rv = acpi_evaluate_integer(asus->handle, "ASYM", NULL, &temp);
 	if (!ACPI_FAILURE(rv))
 		len += sprintf(page + len, "ASYM value         : %#x\n",
 			       (uint) temp);
@@ -673,7 +673,7 @@ static ssize_t store_status(const char *buf, size_t count,
 static ssize_t show_ledd(struct device *dev,
 			 struct device_attribute *attr, char *buf)
 {
-	return sprintf(buf, "0x%08x\n", hotk->ledd_status);
+	return sprintf(buf, "0x%08x\n", asus->ledd_status);
 }
 
 static ssize_t store_ledd(struct device *dev, struct device_attribute *attr,
@@ -686,7 +686,7 @@ static ssize_t store_ledd(struct device *dev, struct device_attribute *attr,
 		if (write_acpi_int(ledd_set_handle, NULL, value))
 			pr_warning("LED display write failed\n");
 		else
-			hotk->ledd_status = (u32) value;
+			asus->ledd_status = (u32) value;
 	}
 	return rv;
 }
@@ -789,13 +789,13 @@ static void set_light_sens_switch(int value)
 {
 	if (write_acpi_int(ls_switch_handle, NULL, value))
 		pr_warning("Error setting light sensor switch\n");
-	hotk->light_switch = value;
+	asus->light_switch = value;
 }
 
 static ssize_t show_lssw(struct device *dev,
 			 struct device_attribute *attr, char *buf)
 {
-	return sprintf(buf, "%d\n", hotk->light_switch);
+	return sprintf(buf, "%d\n", asus->light_switch);
 }
 
 static ssize_t store_lssw(struct device *dev, struct device_attribute *attr,
@@ -814,13 +814,13 @@ static void set_light_sens_level(int value)
 {
 	if (write_acpi_int(ls_level_handle, NULL, value))
 		pr_warning("Error setting light sensor level\n");
-	hotk->light_level = value;
+	asus->light_level = value;
 }
 
 static ssize_t show_lslvl(struct device *dev,
 			  struct device_attribute *attr, char *buf)
 {
-	return sprintf(buf, "%d\n", hotk->light_level);
+	return sprintf(buf, "%d\n", asus->light_level);
 }
 
 static ssize_t store_lslvl(struct device *dev, struct device_attribute *attr,
@@ -929,23 +929,23 @@ static void asus_acpi_notify(struct acpi_device *device, u32 event)
 	}
 
 	/* TODO Find a better way to handle events count. */
-	count = hotk->event_count[event % 128]++;
-	acpi_bus_generate_proc_event(hotk->device, event, count);
-	acpi_bus_generate_netlink_event(hotk->device->pnp.device_class,
-					dev_name(&hotk->device->dev), event,
+	count = asus->event_count[event % 128]++;
+	acpi_bus_generate_proc_event(asus->device, event, count);
+	acpi_bus_generate_netlink_event(asus->device->pnp.device_class,
+					dev_name(&asus->device->dev), event,
 					count);
 
-	if (hotk->inputdev) {
+	if (asus->inputdev) {
 		key = asus_get_entry_by_scancode(event);
 		if (!key)
 			return ;
 
 		switch (key->type) {
 		case KE_KEY:
-			input_report_key(hotk->inputdev, key->keycode, 1);
-			input_sync(hotk->inputdev);
-			input_report_key(hotk->inputdev, key->keycode, 0);
-			input_sync(hotk->inputdev);
+			input_report_key(asus->inputdev, key->keycode, 1);
+			input_sync(asus->inputdev);
+			input_report_key(asus->inputdev, key->keycode, 0);
+			input_sync(asus->inputdev);
 			break;
 		}
 	}
@@ -996,42 +996,42 @@ static int asus_platform_init(void)
 {
 	int result;
 
-	hotk->platform_device = platform_device_alloc(ASUS_HOTK_FILE, -1);
-	if (!hotk->platform_device)
+	asus->platform_device = platform_device_alloc(ASUS_LAPTOP_FILE, -1);
+	if (!asus->platform_device)
 		return -ENOMEM;
 
-	result = platform_device_add(hotk->platform_device);
+	result = platform_device_add(asus->platform_device);
 	if (result)
 		goto fail_platform_device;
 
-	result = sysfs_create_group(&hotk->platform_device->dev.kobj,
+	result = sysfs_create_group(&asus->platform_device->dev.kobj,
 				    &platform_attribute_group);
 	if (result)
 		goto fail_sysfs;
 	return 0;
 
 fail_sysfs:
-	platform_device_del(hotk->platform_device);
+	platform_device_del(asus->platform_device);
 fail_platform_device:
-	platform_device_put(hotk->platform_device);
+	platform_device_put(asus->platform_device);
 	return result;
 }
 
 static void asus_platform_exit(void)
 {
-	sysfs_remove_group(&hotk->platform_device->dev.kobj,
+	sysfs_remove_group(&asus->platform_device->dev.kobj,
 			   &platform_attribute_group);
-	platform_device_unregister(hotk->platform_device);
+	platform_device_unregister(asus->platform_device);
 }
 
 static struct platform_driver platform_driver = {
 	.driver = {
-		   .name = ASUS_HOTK_FILE,
+		   .name = ASUS_LAPTOP_FILE,
 		   .owner = THIS_MODULE,
 		   }
 };
 
-static void asus_hotk_add_fs(void)
+static void asus_laptop_add_fs(void)
 {
 	ASUS_SET_DEVICE_ATTR(infos, 0444, show_infos, NULL);
 
@@ -1080,10 +1080,11 @@ static int asus_handle_init(char *name, acpi_handle * handle,
 			 ARRAY_SIZE(object##_paths))
 
 /*
- * This function is used to initialize the hotk with right values. In this
- * method, we can make all the detection we want, and modify the hotk struct
+ * This function is used to initialize the context with right values. In this
+ * method, we can make all the detection we want, and modify the asus_laptop
+ * struct
  */
-static int asus_hotk_get_info(void)
+static int asus_laptop_get_info(void)
 {
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 	union acpi_object *model = NULL;
@@ -1104,14 +1105,14 @@ static int asus_hotk_get_info(void)
 		pr_warning("Couldn't get the DSDT table header\n");
 
 	/* We have to write 0 on init this far for all ASUS models */
-	if (write_acpi_int_ret(hotk->handle, "INIT", 0, &buffer)) {
+	if (write_acpi_int_ret(asus->handle, "INIT", 0, &buffer)) {
 		pr_err("Hotkey initialization failed\n");
 		return -ENODEV;
 	}
 
 	/* This needs to be called for some laptops to init properly */
 	status =
-	    acpi_evaluate_integer(hotk->handle, "BSTS", NULL, &bsts_result);
+	    acpi_evaluate_integer(asus->handle, "BSTS", NULL, &bsts_result);
 	if (ACPI_FAILURE(status))
 		pr_warning("Error calling BSTS\n");
 	else if (bsts_result)
@@ -1119,7 +1120,7 @@ static int asus_hotk_get_info(void)
 		       (uint) bsts_result);
 
 	/* This too ... */
-	write_acpi_int(hotk->handle, "CWAP", wapf);
+	write_acpi_int(asus->handle, "CWAP", wapf);
 
 	/*
 	 * Try to match the object returned by INIT to the specific model.
@@ -1141,8 +1142,8 @@ static int asus_hotk_get_info(void)
 			break;
 		}
 	}
-	hotk->name = kstrdup(string, GFP_KERNEL);
-	if (!hotk->name)
+	asus->name = kstrdup(string, GFP_KERNEL);
+	if (!asus->name)
 		return -ENOMEM;
 
 	if (*string)
@@ -1166,7 +1167,7 @@ static int asus_hotk_get_info(void)
 	 * If we don't find the method, we assume the device are present.
 	 */
 	status =
-	    acpi_evaluate_integer(hotk->handle, "HRWS", NULL, &hwrs_result);
+	    acpi_evaluate_integer(asus->handle, "HRWS", NULL, &hwrs_result);
 	if (ACPI_FAILURE(status))
 		hwrs_result = WL_HWRS | BT_HWRS;
 
@@ -1206,30 +1207,30 @@ static int asus_input_init(struct device *dev)
 	const struct key_entry *key;
 	int result;
 
-	hotk->inputdev = input_allocate_device();
-	if (!hotk->inputdev) {
+	asus->inputdev = input_allocate_device();
+	if (!asus->inputdev) {
 		pr_info("Unable to allocate input device\n");
 		return 0;
 	}
-	hotk->inputdev->name = "Asus Laptop extra buttons";
-	hotk->inputdev->dev.parent = dev;
-	hotk->inputdev->phys = ASUS_HOTK_FILE "/input0";
-	hotk->inputdev->id.bustype = BUS_HOST;
-	hotk->inputdev->getkeycode = asus_getkeycode;
-	hotk->inputdev->setkeycode = asus_setkeycode;
+	asus->inputdev->name = "Asus Laptop extra buttons";
+	asus->inputdev->dev.parent = dev;
+	asus->inputdev->phys = ASUS_LAPTOP_FILE "/input0";
+	asus->inputdev->id.bustype = BUS_HOST;
+	asus->inputdev->getkeycode = asus_getkeycode;
+	asus->inputdev->setkeycode = asus_setkeycode;
 
 	for (key = asus_keymap; key->type != KE_END; key++) {
 		switch (key->type) {
 		case KE_KEY:
-			set_bit(EV_KEY, hotk->inputdev->evbit);
-			set_bit(key->keycode, hotk->inputdev->keybit);
+			set_bit(EV_KEY, asus->inputdev->evbit);
+			set_bit(key->keycode, asus->inputdev->keybit);
 			break;
 		}
 	}
-	result = input_register_device(hotk->inputdev);
+	result = input_register_device(asus->inputdev);
 	if (result) {
 		pr_info("Unable to register input device\n");
-		input_free_device(hotk->inputdev);
+		input_free_device(asus->inputdev);
 	}
 	return result;
 }
@@ -1257,8 +1258,8 @@ static void asus_led_exit(void)
 
 static void asus_input_exit(void)
 {
-	if (hotk->inputdev)
-		input_unregister_device(hotk->inputdev);
+	if (asus->inputdev)
+		input_unregister_device(asus->inputdev);
 }
 
 static int asus_backlight_init(struct device *dev)
@@ -1266,7 +1267,7 @@ static int asus_backlight_init(struct device *dev)
 	struct backlight_device *bd;
 
 	if (brightness_set_handle && lcd_switch_handle) {
-		bd = backlight_device_register(ASUS_HOTK_FILE, dev,
+		bd = backlight_device_register(ASUS_LAPTOP_FILE, dev,
 					       NULL, &asusbl_ops);
 		if (IS_ERR(bd)) {
 			pr_err("Could not register asus backlight device\n");
@@ -1354,19 +1355,19 @@ static int __devinit asus_acpi_init(struct acpi_device *device)
 {
 	int result = 0;
 
-	result = acpi_bus_get_status(hotk->device);
+	result = acpi_bus_get_status(asus->device);
 	if (result)
 		return result;
-	if (!hotk->device->status.present) {
+	if (!asus->device->status.present) {
 		pr_err("Hotkey device not present, aborting\n");
 		return -ENODEV;
 	}
 
-	result = asus_hotk_get_info();
+	result = asus_laptop_get_info();
 	if (result)
 		return result;
 
-	asus_hotk_add_fs();
+	asus_laptop_add_fs();
 
 	/* WLED and BLED are on by default */
 	write_status(bt_switch_handle, 1, BT_ON);
@@ -1384,17 +1385,17 @@ static int __devinit asus_acpi_init(struct acpi_device *device)
 		set_kled_lvl(1);
 
 	/* LED display is off by default */
-	hotk->ledd_status = 0xFFF;
+	asus->ledd_status = 0xFFF;
 
 	/* Set initial values of light sensor and level */
 	hotk->light_switch = 0;	/* Default to light sensor disabled */
 	hotk->light_level = 5;	/* level 5 for sensor sensitivity */
 
 	if (ls_switch_handle)
-		set_light_sens_switch(hotk->light_switch);
+		set_light_sens_switch(asus->light_switch);
 
 	if (ls_level_handle)
-		set_light_sens_level(hotk->light_level);
+		set_light_sens_level(asus->light_level);
 
 	/* GPS is on by default */
 	write_status(NULL, 1, GPS_ON);
@@ -1407,14 +1408,14 @@ static int __devinit asus_acpi_add(struct acpi_device *device)
 
 	pr_notice("Asus Laptop Support version %s\n",
 		  ASUS_LAPTOP_VERSION);
-	hotk = kzalloc(sizeof(struct asus_hotk), GFP_KERNEL);
-	if (!hotk)
+	asus = kzalloc(sizeof(struct asus_laptop), GFP_KERNEL);
+	if (!asus)
 		return -ENOMEM;
-	hotk->handle = device->handle;
-	strcpy(acpi_device_name(device), ASUS_HOTK_DEVICE_NAME);
-	strcpy(acpi_device_class(device), ASUS_HOTK_CLASS);
-	device->driver_data = hotk;
-	hotk->device = device;
+	asus->handle = device->handle;
+	strcpy(acpi_device_name(device), ASUS_LAPTOP_DEVICE_NAME);
+	strcpy(acpi_device_class(device), ASUS_LAPTOP_CLASS);
+	device->driver_data = asus;
+	asus->device = device;
 
 	result = asus_acpi_init(device);
 	if (result)
@@ -1429,17 +1430,17 @@ static int __devinit asus_acpi_add(struct acpi_device *device)
 		goto fail_platform;
 
 	if (!acpi_video_backlight_support()) {
-		result = asus_backlight_init(&hotk->platform_device->dev);
+		result = asus_backlight_init(&asus->platform_device->dev);
 		if (result)
 			goto fail_backlight;
 	} else
 		pr_info("Backlight controlled by ACPI video driver\n");
 
-	result = asus_input_init(&hotk->platform_device->dev);
+	result = asus_input_init(&asus->platform_device->dev);
 	if (result)
 		goto fail_input;
 
-	result = asus_led_init(&hotk->platform_device->dev);
+	result = asus_led_init(&asus->platform_device->dev);
 	if (result)
 		goto fail_led;
 
@@ -1453,8 +1454,8 @@ static int __devinit asus_acpi_add(struct acpi_device *device)
 fail_backlight:
 	asus_platform_exit();
 fail_platform:
-	kfree(hotk->name);
-	kfree(hotk);
+	kfree(asus->name);
+	kfree(asus);
 
 	return result;
 }
@@ -1466,8 +1467,8 @@ static int asus_acpi_remove(struct acpi_device *device, int type)
 	asus_input_exit();
 	asus_platform_exit();
 
-	kfree(hotk->name);
-	kfree(hotk);
+	kfree(asus->name);
+	kfree(asus);
 	return 0;
 }
 
@@ -1479,8 +1480,8 @@ static const struct acpi_device_id asus_device_ids[] = {
 MODULE_DEVICE_TABLE(acpi, asus_device_ids);
 
 static struct acpi_driver asus_acpi_driver = {
-	.name = ASUS_HOTK_NAME,
-	.class = ASUS_HOTK_CLASS,
+	.name = ASUS_LAPTOP_NAME,
+	.class = ASUS_LAPTOP_CLASS,
 	.owner = THIS_MODULE,
 	.ids = asus_device_ids,
 	.flags = ACPI_DRIVER_ALL_NOTIFY_EVENTS,

commit 600ad5201d3b9b87159ede7359adccb98635fd48
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Mon Nov 30 21:42:42 2009 +0100

    asus-laptop: change initialization order
    
    Clean asus-laptop initialization to match new eeepc-laptop code.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 74463a07d48b..8834405be1fd 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -201,6 +201,8 @@ ASUS_HANDLE(kled_get, ASUS_HOTK_PREFIX "GLKB");
  */
 struct asus_hotk {
 	char *name;		/* laptop name */
+
+	struct platform_device *platform_device;
 	struct acpi_device *device;	/* the device we are in */
 	acpi_handle handle;	/* the handle of the hotk device */
 	char status;		/* status of the hotk, for LEDs, ... */
@@ -222,33 +224,6 @@ static struct acpi_table_header *asus_info;
 /* The actual device the driver binds to */
 static struct asus_hotk *hotk;
 
-/*
- * The hotkey driver declaration
- */
-static const struct acpi_device_id asus_device_ids[] = {
-	{"ATK0100", 0},
-	{"ATK0101", 0},
-	{"", 0},
-};
-MODULE_DEVICE_TABLE(acpi, asus_device_ids);
-
-static int asus_hotk_add(struct acpi_device *device);
-static int asus_hotk_remove(struct acpi_device *device, int type);
-static void asus_hotk_notify(struct acpi_device *device, u32 event);
-
-static struct acpi_driver asus_hotk_driver = {
-	.name = ASUS_HOTK_NAME,
-	.class = ASUS_HOTK_CLASS,
-	.owner = THIS_MODULE,
-	.ids = asus_device_ids,
-	.flags = ACPI_DRIVER_ALL_NOTIFY_EVENTS,
-	.ops = {
-		.add = asus_hotk_add,
-		.remove = asus_hotk_remove,
-		.notify = asus_hotk_notify,
-		},
-};
-
 /* The backlight device /sys/class/backlight */
 static struct backlight_device *asus_backlight_device;
 
@@ -936,7 +911,7 @@ static int asus_setkeycode(struct input_dev *dev, int scancode, int keycode)
 	return -EINVAL;
 }
 
-static void asus_hotk_notify(struct acpi_device *device, u32 event)
+static void asus_acpi_notify(struct acpi_device *device, u32 event)
 {
 	static struct key_entry *key;
 	u16 count;
@@ -1013,19 +988,49 @@ static struct attribute *asuspf_attributes[] = {
 	NULL
 };
 
-static struct attribute_group asuspf_attribute_group = {
+static struct attribute_group platform_attribute_group = {
 	.attrs = asuspf_attributes
 };
 
-static struct platform_driver asuspf_driver = {
+static int asus_platform_init(void)
+{
+	int result;
+
+	hotk->platform_device = platform_device_alloc(ASUS_HOTK_FILE, -1);
+	if (!hotk->platform_device)
+		return -ENOMEM;
+
+	result = platform_device_add(hotk->platform_device);
+	if (result)
+		goto fail_platform_device;
+
+	result = sysfs_create_group(&hotk->platform_device->dev.kobj,
+				    &platform_attribute_group);
+	if (result)
+		goto fail_sysfs;
+	return 0;
+
+fail_sysfs:
+	platform_device_del(hotk->platform_device);
+fail_platform_device:
+	platform_device_put(hotk->platform_device);
+	return result;
+}
+
+static void asus_platform_exit(void)
+{
+	sysfs_remove_group(&hotk->platform_device->dev.kobj,
+			   &platform_attribute_group);
+	platform_device_unregister(hotk->platform_device);
+}
+
+static struct platform_driver platform_driver = {
 	.driver = {
 		   .name = ASUS_HOTK_FILE,
 		   .owner = THIS_MODULE,
 		   }
 };
 
-static struct platform_device *asuspf_device;
-
 static void asus_hotk_add_fs(void)
 {
 	ASUS_SET_DEVICE_ATTR(infos, 0444, show_infos, NULL);
@@ -1196,7 +1201,7 @@ static int asus_hotk_get_info(void)
 	return AE_OK;
 }
 
-static int asus_input_init(void)
+static int asus_input_init(struct device *dev)
 {
 	const struct key_entry *key;
 	int result;
@@ -1207,6 +1212,7 @@ static int asus_input_init(void)
 		return 0;
 	}
 	hotk->inputdev->name = "Asus Laptop extra buttons";
+	hotk->inputdev->dev.parent = dev;
 	hotk->inputdev->phys = ASUS_HOTK_FILE "/input0";
 	hotk->inputdev->id.bustype = BUS_HOST;
 	hotk->inputdev->getkeycode = asus_getkeycode;
@@ -1228,101 +1234,6 @@ static int asus_input_init(void)
 	return result;
 }
 
-static int asus_hotk_check(void)
-{
-	int result = 0;
-
-	result = acpi_bus_get_status(hotk->device);
-	if (result)
-		return result;
-
-	if (hotk->device->status.present) {
-		result = asus_hotk_get_info();
-	} else {
-		pr_err("Hotkey device not present, aborting\n");
-		return -EINVAL;
-	}
-
-	return result;
-}
-
-static int asus_hotk_found;
-
-static int asus_hotk_add(struct acpi_device *device)
-{
-	int result;
-
-	pr_notice("Asus Laptop Support version %s\n",
-	       ASUS_LAPTOP_VERSION);
-
-	hotk = kzalloc(sizeof(struct asus_hotk), GFP_KERNEL);
-	if (!hotk)
-		return -ENOMEM;
-
-	hotk->handle = device->handle;
-	strcpy(acpi_device_name(device), ASUS_HOTK_DEVICE_NAME);
-	strcpy(acpi_device_class(device), ASUS_HOTK_CLASS);
-	device->driver_data = hotk;
-	hotk->device = device;
-
-	result = asus_hotk_check();
-	if (result)
-		goto end;
-
-	asus_hotk_add_fs();
-
-	asus_hotk_found = 1;
-
-	/* WLED and BLED are on by default */
-	if (bluetooth_status != -1)
-		write_status(bt_switch_handle, !!bluetooth_status, BT_ON);
-	if (wireless_status != -1)
-		write_status(wl_switch_handle, !!wireless_status, WL_ON);
-
-	/* If the h/w switch is off, we need to check the real status */
-	write_status(NULL, read_status(BT_ON), BT_ON);
-	write_status(NULL, read_status(WL_ON), WL_ON);
-
-	/* LCD Backlight is on by default */
-	write_status(NULL, 1, LCD_ON);
-
-	/* Keyboard Backlight is on by default */
-	if (kled_set_handle)
-		set_kled_lvl(1);
-
-	/* LED display is off by default */
-	hotk->ledd_status = 0xFFF;
-
-	/* Set initial values of light sensor and level */
-	hotk->light_switch = 0;	/* Default to light sensor disabled */
-	hotk->light_level = 5;	/* level 5 for sensor sensitivity */
-
-	if (ls_switch_handle)
-		set_light_sens_switch(hotk->light_switch);
-
-	if (ls_level_handle)
-		set_light_sens_level(hotk->light_level);
-
-	/* GPS is on by default */
-	write_status(NULL, 1, GPS_ON);
-
-end:
-	if (result) {
-		kfree(hotk->name);
-		kfree(hotk);
-	}
-
-	return result;
-}
-
-static int asus_hotk_remove(struct acpi_device *device, int type)
-{
-	kfree(hotk->name);
-	kfree(hotk);
-
-	return 0;
-}
-
 static void asus_backlight_exit(void)
 {
 	if (asus_backlight_device)
@@ -1350,18 +1261,6 @@ static void asus_input_exit(void)
 		input_unregister_device(hotk->inputdev);
 }
 
-static void __exit asus_laptop_exit(void)
-{
-	asus_backlight_exit();
-	asus_led_exit();
-	asus_input_exit();
-
-	acpi_bus_unregister_driver(&asus_hotk_driver);
-	sysfs_remove_group(&asuspf_device->dev.kobj, &asuspf_attribute_group);
-	platform_device_unregister(asuspf_device);
-	platform_driver_unregister(&asuspf_driver);
-}
-
 static int asus_backlight_init(struct device *dev)
 {
 	struct backlight_device *bd;
@@ -1448,87 +1347,179 @@ static int asus_led_init(struct device *dev)
 	return rv;
 }
 
-static int __init asus_laptop_init(void)
+
+static bool asus_device_present;
+
+static int __devinit asus_acpi_init(struct acpi_device *device)
 {
-	int result;
+	int result = 0;
 
-	result = acpi_bus_register_driver(&asus_hotk_driver);
-	if (result < 0)
+	result = acpi_bus_get_status(hotk->device);
+	if (result)
 		return result;
-
-	/*
-	 * This is a bit of a kludge.  We only want this module loaded
-	 * for ASUS systems, but there's currently no way to probe the
-	 * ACPI namespace for ASUS HIDs.  So we just return failure if
-	 * we didn't find one, which will cause the module to be
-	 * unloaded.
-	 */
-	if (!asus_hotk_found) {
-		acpi_bus_unregister_driver(&asus_hotk_driver);
+	if (!hotk->device->status.present) {
+		pr_err("Hotkey device not present, aborting\n");
 		return -ENODEV;
 	}
 
-	result = asus_input_init();
+	result = asus_hotk_get_info();
 	if (result)
-		goto fail_input;
+		return result;
 
-	/* Register platform stuff */
-	result = platform_driver_register(&asuspf_driver);
-	if (result)
-		goto fail_platform_driver;
+	asus_hotk_add_fs();
 
-	asuspf_device = platform_device_alloc(ASUS_HOTK_FILE, -1);
-	if (!asuspf_device) {
-		result = -ENOMEM;
-		goto fail_platform_device1;
-	}
+	/* WLED and BLED are on by default */
+	write_status(bt_switch_handle, 1, BT_ON);
+	write_status(wl_switch_handle, 1, WL_ON);
 
-	result = platform_device_add(asuspf_device);
-	if (result)
-		goto fail_platform_device2;
+	/* If the h/w switch is off, we need to check the real status */
+	write_status(NULL, read_status(BT_ON), BT_ON);
+	write_status(NULL, read_status(WL_ON), WL_ON);
+
+	/* LCD Backlight is on by default */
+	write_status(NULL, 1, LCD_ON);
 
-	result = sysfs_create_group(&asuspf_device->dev.kobj,
-				    &asuspf_attribute_group);
+	/* Keyboard Backlight is on by default */
+	if (kled_set_handle)
+		set_kled_lvl(1);
+
+	/* LED display is off by default */
+	hotk->ledd_status = 0xFFF;
+
+	/* Set initial values of light sensor and level */
+	hotk->light_switch = 0;	/* Default to light sensor disabled */
+	hotk->light_level = 5;	/* level 5 for sensor sensitivity */
+
+	if (ls_switch_handle)
+		set_light_sens_switch(hotk->light_switch);
+
+	if (ls_level_handle)
+		set_light_sens_level(hotk->light_level);
+
+	/* GPS is on by default */
+	write_status(NULL, 1, GPS_ON);
+	return result;
+}
+
+static int __devinit asus_acpi_add(struct acpi_device *device)
+{
+	int result;
+
+	pr_notice("Asus Laptop Support version %s\n",
+		  ASUS_LAPTOP_VERSION);
+	hotk = kzalloc(sizeof(struct asus_hotk), GFP_KERNEL);
+	if (!hotk)
+		return -ENOMEM;
+	hotk->handle = device->handle;
+	strcpy(acpi_device_name(device), ASUS_HOTK_DEVICE_NAME);
+	strcpy(acpi_device_class(device), ASUS_HOTK_CLASS);
+	device->driver_data = hotk;
+	hotk->device = device;
+
+	result = asus_acpi_init(device);
 	if (result)
-		goto fail_sysfs;
+		goto fail_platform;
 
-	result = asus_led_init(&asuspf_device->dev);
+	/*
+	 * Register the platform device first.  It is used as a parent for the
+	 * sub-devices below.
+	 */
+	result = asus_platform_init();
 	if (result)
-		goto fail_led;
+		goto fail_platform;
 
 	if (!acpi_video_backlight_support()) {
-		result = asus_backlight_init(&asuspf_device->dev);
+		result = asus_backlight_init(&hotk->platform_device->dev);
 		if (result)
 			goto fail_backlight;
 	} else
-		pr_info("Brightness ignored, must be controlled by "
-		       "ACPI video driver\n");
+		pr_info("Backlight controlled by ACPI video driver\n");
 
+	result = asus_input_init(&hotk->platform_device->dev);
+	if (result)
+		goto fail_input;
+
+	result = asus_led_init(&hotk->platform_device->dev);
+	if (result)
+		goto fail_led;
+
+	asus_device_present = true;
 	return 0;
 
+fail_led:
+	asus_input_exit();
+fail_input:
+	asus_backlight_exit();
 fail_backlight:
-       asus_led_exit();
+	asus_platform_exit();
+fail_platform:
+	kfree(hotk->name);
+	kfree(hotk);
 
-fail_led:
-       sysfs_remove_group(&asuspf_device->dev.kobj,
-			  &asuspf_attribute_group);
+	return result;
+}
 
-fail_sysfs:
-	platform_device_del(asuspf_device);
+static int asus_acpi_remove(struct acpi_device *device, int type)
+{
+	asus_backlight_exit();
+	asus_led_exit();
+	asus_input_exit();
+	asus_platform_exit();
+
+	kfree(hotk->name);
+	kfree(hotk);
+	return 0;
+}
+
+static const struct acpi_device_id asus_device_ids[] = {
+	{"ATK0100", 0},
+	{"ATK0101", 0},
+	{"", 0},
+};
+MODULE_DEVICE_TABLE(acpi, asus_device_ids);
 
-fail_platform_device2:
-	platform_device_put(asuspf_device);
+static struct acpi_driver asus_acpi_driver = {
+	.name = ASUS_HOTK_NAME,
+	.class = ASUS_HOTK_CLASS,
+	.owner = THIS_MODULE,
+	.ids = asus_device_ids,
+	.flags = ACPI_DRIVER_ALL_NOTIFY_EVENTS,
+	.ops = {
+		.add = asus_acpi_add,
+		.remove = asus_acpi_remove,
+		.notify = asus_acpi_notify,
+		},
+};
 
-fail_platform_device1:
-	platform_driver_unregister(&asuspf_driver);
+static int __init asus_laptop_init(void)
+{
+	int result;
 
-fail_platform_driver:
-	asus_input_exit();
+	result = platform_driver_register(&platform_driver);
+	if (result < 0)
+		return result;
 
-fail_input:
+	result = acpi_bus_register_driver(&asus_acpi_driver);
+	if (result < 0)
+		goto fail_acpi_driver;
+	if (!asus_device_present) {
+		result = -ENODEV;
+		goto fail_no_device;
+	}
+	return 0;
 
+fail_no_device:
+	acpi_bus_unregister_driver(&asus_acpi_driver);
+fail_acpi_driver:
+	platform_driver_unregister(&platform_driver);
 	return result;
 }
 
+static void __exit asus_laptop_exit(void)
+{
+	acpi_bus_unregister_driver(&asus_acpi_driver);
+	platform_driver_unregister(&platform_driver);
+}
+
 module_init(asus_laptop_init);
 module_exit(asus_laptop_exit);

commit 619d8b1187f2e13f6f848b1b2a4d83c2c9e2a140
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sat Nov 28 10:35:37 2009 +0100

    asus-laptop: remove unecessary hotk != NULL check
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 5889bda5a03b..74463a07d48b 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -941,10 +941,6 @@ static void asus_hotk_notify(struct acpi_device *device, u32 event)
 	static struct key_entry *key;
 	u16 count;
 
-	/* TODO Find a better way to handle events count. */
-	if (!hotk)
-		return;
-
 	/*
 	 * We need to tell the backlight device when the backlight power is
 	 * switched
@@ -957,6 +953,7 @@ static void asus_hotk_notify(struct acpi_device *device, u32 event)
 		lcd_blank(FB_BLANK_POWERDOWN);
 	}
 
+	/* TODO Find a better way to handle events count. */
 	count = hotk->event_count[event % 128]++;
 	acpi_bus_generate_proc_event(hotk->device, event, count);
 	acpi_bus_generate_netlink_event(hotk->device->pnp.device_class,

commit 91687cc89af4c447483ec65097809c38c8622639
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sat Nov 28 10:32:34 2009 +0100

    asus-laptop: use tabs to indent macros and remove unused ones
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 7058cb56f338..5889bda5a03b 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -50,50 +50,43 @@
 #include <asm/uaccess.h>
 #include <linux/input.h>
 
-#define ASUS_LAPTOP_VERSION "0.42"
+#define ASUS_LAPTOP_VERSION	"0.42"
 
-#define ASUS_HOTK_NAME          "Asus Laptop Support"
-#define ASUS_HOTK_CLASS         "hotkey"
-#define ASUS_HOTK_DEVICE_NAME   "Hotkey"
-#define ASUS_HOTK_FILE          KBUILD_MODNAME
-#define ASUS_HOTK_PREFIX        "\\_SB.ATKD."
+#define ASUS_HOTK_NAME		"Asus Laptop Support"
+#define ASUS_HOTK_CLASS		"hotkey"
+#define ASUS_HOTK_DEVICE_NAME	"Hotkey"
+#define ASUS_HOTK_FILE		KBUILD_MODNAME
+#define ASUS_HOTK_PREFIX	"\\_SB.ATKD."
 
 
 /*
  * Some events we use, same for all Asus
  */
-#define ATKD_BR_UP       0x10
-#define ATKD_BR_DOWN     0x20
-#define ATKD_LCD_ON      0x33
-#define ATKD_LCD_OFF     0x34
+#define ATKD_BR_UP	0x10
+#define ATKD_BR_DOWN	0x20
+#define ATKD_LCD_ON	0x33
+#define ATKD_LCD_OFF	0x34
 
 /*
  * Known bits returned by \_SB.ATKD.HWRS
  */
-#define WL_HWRS     0x80
-#define BT_HWRS     0x100
+#define WL_HWRS		0x80
+#define BT_HWRS		0x100
 
 /*
  * Flags for hotk status
  * WL_ON and BT_ON are also used for wireless_status()
  */
-#define WL_ON       0x01	/* internal Wifi */
-#define BT_ON       0x02	/* internal Bluetooth */
-#define MLED_ON     0x04	/* mail LED */
-#define TLED_ON     0x08	/* touchpad LED */
-#define RLED_ON     0x10	/* Record LED */
-#define PLED_ON     0x20	/* Phone LED */
-#define GLED_ON     0x40	/* Gaming LED */
-#define LCD_ON      0x80	/* LCD backlight */
-#define GPS_ON      0x100	/* GPS */
-#define KEY_ON      0x200	/* Keyboard backlight */
-
-#define ASUS_LOG    ASUS_HOTK_FILE ": "
-#define ASUS_ERR    KERN_ERR    ASUS_LOG
-#define ASUS_WARNING    KERN_WARNING    ASUS_LOG
-#define ASUS_NOTICE KERN_NOTICE ASUS_LOG
-#define ASUS_INFO   KERN_INFO   ASUS_LOG
-#define ASUS_DEBUG  KERN_DEBUG  ASUS_LOG
+#define WL_ON		0x01	/* internal Wifi */
+#define BT_ON		0x02	/* internal Bluetooth */
+#define MLED_ON		0x04	/* mail LED */
+#define TLED_ON		0x08	/* touchpad LED */
+#define RLED_ON		0x10	/* Record LED */
+#define PLED_ON		0x20	/* Phone LED */
+#define GLED_ON		0x40	/* Gaming LED */
+#define LCD_ON		0x80	/* LCD backlight */
+#define GPS_ON		0x100	/* GPS */
+#define KEY_ON		0x200	/* Keyboard backlight */
 
 MODULE_AUTHOR("Julien Lerouge, Karol Kozimor, Corentin Chary");
 MODULE_DESCRIPTION(ASUS_HOTK_NAME);

commit d8c6732382a24d2ef23665207263a17f04e3d75a
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sat Nov 28 10:27:51 2009 +0100

    asus-laptop: simplify write_acpi_int
    
    We only need a buffer for "INIT". Adds write_acpi_init_ret for it.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 013ab86b1c8d..7058cb56f338 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -352,8 +352,8 @@ static struct key_entry asus_keymap[] = {
  *
  * returns 0 if write is successful, -1 else.
  */
-static int write_acpi_int(acpi_handle handle, const char *method, int val,
-			  struct acpi_buffer *output)
+static int write_acpi_int_ret(acpi_handle handle, const char *method, int val,
+			      struct acpi_buffer *output)
 {
 	struct acpi_object_list params;	/* list of input parameters (an int) */
 	union acpi_object in_obj;	/* the only param we use */
@@ -374,6 +374,11 @@ static int write_acpi_int(acpi_handle handle, const char *method, int val,
 		return -1;
 }
 
+static int write_acpi_int(acpi_handle handle, const char *method, int val)
+{
+	return write_acpi_int_ret(handle, method, val, NULL);
+}
+
 static int read_wireless_status(int mask)
 {
 	unsigned long long status;
@@ -437,7 +442,7 @@ static void write_status(acpi_handle handle, int out, int mask)
 		break;
 	}
 
-	if (write_acpi_int(handle, NULL, out, NULL))
+	if (write_acpi_int(handle, NULL, out))
 		pr_warning(" write failed %x\n", mask);
 }
 
@@ -496,7 +501,7 @@ static int set_kled_lvl(int kblv)
 	else
 		kblv = 0;
 
-	if (write_acpi_int(kled_set_handle, NULL, kblv, NULL)) {
+	if (write_acpi_int(kled_set_handle, NULL, kblv)) {
 		pr_warning("Keyboard LED display write failed\n");
 		return -EINVAL;
 	}
@@ -571,7 +576,7 @@ static int read_brightness(struct backlight_device *bd)
 
 static int set_brightness(struct backlight_device *bd, int value)
 {
-	if (write_acpi_int(brightness_set_handle, NULL, value, NULL)) {
+	if (write_acpi_int(brightness_set_handle, NULL, value)) {
 		pr_warning("Error changing brightness\n");
 		return -EIO;
 	}
@@ -710,7 +715,7 @@ static ssize_t store_ledd(struct device *dev, struct device_attribute *attr,
 
 	rv = parse_arg(buf, count, &value);
 	if (rv > 0) {
-		if (write_acpi_int(ledd_set_handle, NULL, value, NULL))
+		if (write_acpi_int(ledd_set_handle, NULL, value))
 			pr_warning("LED display write failed\n");
 		else
 			hotk->ledd_status = (u32) value;
@@ -755,7 +760,7 @@ static ssize_t store_bluetooth(struct device *dev,
 static void set_display(int value)
 {
 	/* no sanity check needed for now */
-	if (write_acpi_int(display_set_handle, NULL, value, NULL))
+	if (write_acpi_int(display_set_handle, NULL, value))
 		pr_warning("Error setting display\n");
 	return;
 }
@@ -814,7 +819,7 @@ static ssize_t store_disp(struct device *dev, struct device_attribute *attr,
  */
 static void set_light_sens_switch(int value)
 {
-	if (write_acpi_int(ls_switch_handle, NULL, value, NULL))
+	if (write_acpi_int(ls_switch_handle, NULL, value))
 		pr_warning("Error setting light sensor switch\n");
 	hotk->light_switch = value;
 }
@@ -839,7 +844,7 @@ static ssize_t store_lssw(struct device *dev, struct device_attribute *attr,
 
 static void set_light_sens_level(int value)
 {
-	if (write_acpi_int(ls_level_handle, NULL, value, NULL))
+	if (write_acpi_int(ls_level_handle, NULL, value))
 		pr_warning("Error setting light sensor level\n");
 	hotk->light_level = value;
 }
@@ -1104,7 +1109,7 @@ static int asus_hotk_get_info(void)
 		pr_warning("Couldn't get the DSDT table header\n");
 
 	/* We have to write 0 on init this far for all ASUS models */
-	if (write_acpi_int(hotk->handle, "INIT", 0, &buffer)) {
+	if (write_acpi_int_ret(hotk->handle, "INIT", 0, &buffer)) {
 		pr_err("Hotkey initialization failed\n");
 		return -ENODEV;
 	}
@@ -1119,7 +1124,7 @@ static int asus_hotk_get_info(void)
 		       (uint) bsts_result);
 
 	/* This too ... */
-	write_acpi_int(hotk->handle, "CWAP", wapf, NULL);
+	write_acpi_int(hotk->handle, "CWAP", wapf);
 
 	/*
 	 * Try to match the object returned by INIT to the specific model.

commit e5b50f6a2b00de266f03c2c7219b798648124ea5
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sat Nov 28 10:19:55 2009 +0100

    asus-laptop: no need to check argument of set_brightness()
    
    We already tell the backlight class our maximum brightness value; it
    will validate the user requested values for us.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 1d799b3fc4e8..013ab86b1c8d 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -571,17 +571,11 @@ static int read_brightness(struct backlight_device *bd)
 
 static int set_brightness(struct backlight_device *bd, int value)
 {
-	int ret = 0;
-
-	value = (0 < value) ? ((15 < value) ? 15 : value) : 0;
-	/* 0 <= value <= 15 */
-
 	if (write_acpi_int(brightness_set_handle, NULL, value, NULL)) {
 		pr_warning("Error changing brightness\n");
-		ret = -EIO;
+		return -EIO;
 	}
-
-	return ret;
+	return 0;
 }
 
 static int update_bl_status(struct backlight_device *bd)

commit 0e875f4905817c03ba49447b49af093552e66e95
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sun Jan 10 20:49:26 2010 +0100

    asus-laptop: add wireless and bluetooth status parameter
    
    These to parameter allow to set the status of wlan and bluetooth
    device when the module load. On some models, the device will
    always be down on boot, so the default behavior is to always
    enable these devices.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 61a1c7503658..1d799b3fc4e8 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -113,6 +113,19 @@ static uint wapf = 1;
 module_param(wapf, uint, 0644);
 MODULE_PARM_DESC(wapf, "WAPF value");
 
+static uint wireless_status = 1;
+static uint bluetooth_status = 1;
+
+module_param(wireless_status, uint, 0644);
+MODULE_PARM_DESC(wireless_status, "Set the wireless status on boot "
+		 "(0 = disabled, 1 = enabled, -1 = don't do anything). "
+		 "default is 1");
+
+module_param(bluetooth_status, uint, 0644);
+MODULE_PARM_DESC(bluetooth_status, "Set the wireless status on boot "
+		 "(0 = disabled, 1 = enabled, -1 = don't do anything). "
+		 "default is 1");
+
 #define ASUS_HANDLE(object, paths...)					\
 	static acpi_handle  object##_handle = NULL;			\
 	static char *object##_paths[] = { paths }
@@ -1272,8 +1285,10 @@ static int asus_hotk_add(struct acpi_device *device)
 	asus_hotk_found = 1;
 
 	/* WLED and BLED are on by default */
-	write_status(bt_switch_handle, 1, BT_ON);
-	write_status(wl_switch_handle, 1, WL_ON);
+	if (bluetooth_status != -1)
+		write_status(bt_switch_handle, !!bluetooth_status, BT_ON);
+	if (wireless_status != -1)
+		write_status(wl_switch_handle, !!wireless_status, WL_ON);
 
 	/* If the h/w switch is off, we need to check the real status */
 	write_status(NULL, read_status(BT_ON), BT_ON);

commit d951d4cc84e8b5ddb8e0ab81cf6a72cc73fdd668
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Mon Dec 7 22:05:50 2009 +0100

    asus-laptop: change light sens default values.
    
    The light sensor disable brightness key and
    /sys/class/backlight/ control. There was a lot of report
    from users who didn't understand why they couldn't change their
    brightness, including:
    
    https://bugs.launchpad.net/bugs/222171
    https://bugzilla.novell.com/show_bug.cgi?id=514747
    http://bugzilla.kernel.org/show_bug.cgi?id=13671
    http://bugzilla.kernel.org/show_bug.cgi?id=14432
    
    Now the light sensor is disabled, and if the user want to enable
    it, the level should be ok.
    
    The funny thing is that comments where ok, not code.
    
    Cc: stable@kernel.org
    Cc: Thomas Renninger <trenn@suse.de>
    Cc: Peter Küppers <peter-mailbox@web.de>
    Cc: Michael Franzl <michaelfranzl@gmx.at>
    Cc: Ian Turner <vectro@vectro.org>
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 3348cc6731d9..61a1c7503658 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -1290,8 +1290,8 @@ static int asus_hotk_add(struct acpi_device *device)
 	hotk->ledd_status = 0xFFF;
 
 	/* Set initial values of light sensor and level */
-	hotk->light_switch = 1;	/* Default to light sensor disabled */
-	hotk->light_level = 0;	/* level 5 for sensor sensitivity */
+	hotk->light_switch = 0;	/* Default to light sensor disabled */
+	hotk->light_level = 5;	/* level 5 for sensor sensitivity */
 
 	if (ls_switch_handle)
 		set_light_sens_switch(hotk->light_switch);

commit 1f0233eee9b385d78fda78626136c43e045082f7
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Thu Dec 3 07:45:12 2009 +0000

    asus-laptop: Add wlan switch found on V6V
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 83948dff2419..3348cc6731d9 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -323,6 +323,7 @@ static struct key_entry asus_keymap[] = {
 	{KE_KEY, 0x63, KEY_SWITCHVIDEOMODE},
 	{KE_KEY, 0x6B, KEY_F13}, /* Lock Touchpad */
 	{KE_KEY, 0x82, KEY_CAMERA},
+	{KE_KEY, 0x88, KEY_WLAN },
 	{KE_KEY, 0x8A, KEY_PROG1},
 	{KE_KEY, 0x95, KEY_MEDIA},
 	{KE_KEY, 0x99, KEY_PHONE},

commit 14f8af311e7d3e4198cbaade84a34f86505dcb37
Author: Ike Panhc <ike.pan@canonical.com>
Date:   Thu Dec 3 07:45:11 2009 +0000

    asus-laptop: add Lenovo SL hotkey support
    
    Lenovo SL series laptop has a very similar DSDT with Asus laptops. We can
    easily have the extra ACPI function support with little modification in
    asus-laptop.c
    
    Here is the hotkey enablement for Lenovo SL series laptop.
    
    This patch will enable the following hotkey:
     - Volumn Up
     - Volumn Down
     - Mute
     - Screen Lock (Fn+F2)
     - Battery Status (Fn+F3)
     - WLAN switch (Fn+F5)
     - Video output switch (Fn+F7)
     - Touchpad switch (Fn+F8)
     - Screen Magnifier (Fn+Space)
    
    The following function of Lenovo SL laptop is still need to be enabled:
     - Hotkey: KEY_SUSPEND (Fn+F4), KEY_SLEEP (Fn+F12), Dock Eject (Fn+F9)
     - Rfkill for bluetooth and wlan
     - LenovoCare LED
     - Hwmon for fan speed
     - Fingerprint scanner
     - Active Protection System
    
    Signed-off-by: Ike Panhc <ike.pan@canonical.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index e931e8004233..83948dff2419 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -221,6 +221,7 @@ static struct asus_hotk *hotk;
  */
 static const struct acpi_device_id asus_device_ids[] = {
 	{"ATK0100", 0},
+	{"ATK0101", 0},
 	{"", 0},
 };
 MODULE_DEVICE_TABLE(acpi, asus_device_ids);
@@ -294,6 +295,11 @@ struct key_entry {
 enum { KE_KEY, KE_END };
 
 static struct key_entry asus_keymap[] = {
+	{KE_KEY, 0x02, KEY_SCREENLOCK},
+	{KE_KEY, 0x05, KEY_WLAN},
+	{KE_KEY, 0x08, KEY_F13},
+	{KE_KEY, 0x17, KEY_ZOOM},
+	{KE_KEY, 0x1f, KEY_BATTERY},
 	{KE_KEY, 0x30, KEY_VOLUMEUP},
 	{KE_KEY, 0x31, KEY_VOLUMEDOWN},
 	{KE_KEY, 0x32, KEY_MUTE},
@@ -313,6 +319,8 @@ static struct key_entry asus_keymap[] = {
 	{KE_KEY, 0x5F, KEY_WLAN},
 	{KE_KEY, 0x60, KEY_SWITCHVIDEOMODE},
 	{KE_KEY, 0x61, KEY_SWITCHVIDEOMODE},
+	{KE_KEY, 0x62, KEY_SWITCHVIDEOMODE},
+	{KE_KEY, 0x63, KEY_SWITCHVIDEOMODE},
 	{KE_KEY, 0x6B, KEY_F13}, /* Lock Touchpad */
 	{KE_KEY, 0x82, KEY_CAMERA},
 	{KE_KEY, 0x8A, KEY_PROG1},

commit 16851f92a5998bf8880a7401898ecfe351913854
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Thu Dec 3 07:45:10 2009 +0000

    asus-laptop: use KEY_F13 to map "Disable Touchpad" event
    
    The same key is used in toshiba-laptop, and there is no
    reserved key for that.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 6c05172bf3d3..e931e8004233 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -313,7 +313,7 @@ static struct key_entry asus_keymap[] = {
 	{KE_KEY, 0x5F, KEY_WLAN},
 	{KE_KEY, 0x60, KEY_SWITCHVIDEOMODE},
 	{KE_KEY, 0x61, KEY_SWITCHVIDEOMODE},
-	{KE_KEY, 0x6B, BTN_TOUCH}, /* Lock Mouse */
+	{KE_KEY, 0x6B, KEY_F13}, /* Lock Touchpad */
 	{KE_KEY, 0x82, KEY_CAMERA},
 	{KE_KEY, 0x8A, KEY_PROG1},
 	{KE_KEY, 0x95, KEY_MEDIA},

commit edf624522757adec8ceb83a4b97747eba645c454
Author: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
Date:   Thu Dec 3 07:44:51 2009 +0000

    asus-laptop: set acpi_driver.owner
    
    The owner field provides the link between drivers and modules in sysfs,
    but no ACPI driver was setting it.
    
    After setting the owner field, we can see which module provides which
    driver and vice versa by looking at /sys/bus/acpi/driver/*/module and
    /sys/module/*/drivers/acpi:*.
    
    Signed-off-by: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 4234edbe6ffc..6c05172bf3d3 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -232,6 +232,7 @@ static void asus_hotk_notify(struct acpi_device *device, u32 event);
 static struct acpi_driver asus_hotk_driver = {
 	.name = ASUS_HOTK_NAME,
 	.class = ASUS_HOTK_CLASS,
+	.owner = THIS_MODULE,
 	.ids = asus_device_ids,
 	.flags = ACPI_DRIVER_ALL_NOTIFY_EVENTS,
 	.ops = {

commit b7fab7a0703a9d3a3b4b59aa2f7b098b2b83b8fe
Author: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
Date:   Thu Dec 3 07:44:48 2009 +0000

    asus-laptop: Remove uneccesary acpi_disabled check
    
    acpi_bus_register_driver() already checks acpi_disabled, so acpi bus
    drivers don't need to.
    
    Signed-off-by: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 8af43e9b6183..4234edbe6ffc 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -1438,9 +1438,6 @@ static int __init asus_laptop_init(void)
 {
 	int result;
 
-	if (acpi_disabled)
-		return -ENODEV;
-
 	result = acpi_bus_register_driver(&asus_hotk_driver);
 	if (result < 0)
 		return result;

commit 1df8d8d4efb7bce0e44d2aa91c4c0fa7ffe613c0
Author: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
Date:   Thu Dec 3 07:44:46 2009 +0000

    asus-laptop: Remove redundant NULL checks
    
    The acpi device callbacks add, start, remove, suspend and resume can
    never be called with a NULL acpi_device. Each callsite in acpi/scan.c
    has to dereference the device in order to get the ops structure, e.g.
    
        struct acpi_device *acpi_dev = to_acpi_device(dev);
        struct acpi_driver *acpi_drv = acpi_dev->driver;
    
        if (acpi_drv && acpi_drv->ops.suspend)
            return acpi_drv->ops.suspend(acpi_dev, state);
    
    Remove all checks for acpi_dev == NULL within these callbacks.
    
    Also remove the checks for acpi_driver_data(acpi_dev) == NULL. None of
    these checks could fail unless the driver does something strange
    (which none of them do), the acpi core did something terribly wrong,
    or we have a memory corruption issue. If this does happen then it's
    best to dereference the pointer and crash noisily.
    
    Signed-off-by: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index b39d2bb3e75b..8af43e9b6183 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -1240,9 +1240,6 @@ static int asus_hotk_add(struct acpi_device *device)
 {
 	int result;
 
-	if (!device)
-		return -EINVAL;
-
 	pr_notice("Asus Laptop Support version %s\n",
 	       ASUS_LAPTOP_VERSION);
 
@@ -1306,9 +1303,6 @@ static int asus_hotk_add(struct acpi_device *device)
 
 static int asus_hotk_remove(struct acpi_device *device, int type)
 {
-	if (!device || !acpi_driver_data(device))
-		return -EINVAL;
-
 	kfree(hotk->name);
 	kfree(hotk);
 

commit be96666065fd36ccfa09a13903d31d7ff5f4ef91
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sat Aug 29 10:28:29 2009 +0200

    asus-laptop: Fix coding style for comments
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 5b912cc5cbee..b39d2bb3e75b 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -77,16 +77,16 @@
  * Flags for hotk status
  * WL_ON and BT_ON are also used for wireless_status()
  */
-#define WL_ON       0x01	//internal Wifi
-#define BT_ON       0x02	//internal Bluetooth
-#define MLED_ON     0x04	//mail LED
-#define TLED_ON     0x08	//touchpad LED
-#define RLED_ON     0x10	//Record LED
-#define PLED_ON     0x20	//Phone LED
-#define GLED_ON     0x40	//Gaming LED
-#define LCD_ON      0x80	//LCD backlight
-#define GPS_ON      0x100	//GPS
-#define KEY_ON      0x200       //Keyboard backlight
+#define WL_ON       0x01	/* internal Wifi */
+#define BT_ON       0x02	/* internal Bluetooth */
+#define MLED_ON     0x04	/* mail LED */
+#define TLED_ON     0x08	/* touchpad LED */
+#define RLED_ON     0x10	/* Record LED */
+#define PLED_ON     0x20	/* Phone LED */
+#define GLED_ON     0x40	/* Gaming LED */
+#define LCD_ON      0x80	/* LCD backlight */
+#define GPS_ON      0x100	/* GPS */
+#define KEY_ON      0x200	/* Keyboard backlight */
 
 #define ASUS_LOG    ASUS_HOTK_FILE ": "
 #define ASUS_ERR    KERN_ERR    ASUS_LOG
@@ -99,7 +99,8 @@ MODULE_AUTHOR("Julien Lerouge, Karol Kozimor, Corentin Chary");
 MODULE_DESCRIPTION(ASUS_HOTK_NAME);
 MODULE_LICENSE("GPL");
 
-/* WAPF defines the behavior of the Fn+Fx wlan key
+/*
+ * WAPF defines the behavior of the Fn+Fx wlan key
  * The significance of values is yet to be found, but
  * most of the time:
  * 0x0 will do nothing
@@ -126,7 +127,8 @@ ASUS_HANDLE(gled_set, ASUS_HOTK_PREFIX "GLED");	/* G1, G2 (probably) */
 /* LEDD */
 ASUS_HANDLE(ledd_set, ASUS_HOTK_PREFIX "SLCM");
 
-/* Bluetooth and WLAN
+/*
+ * Bluetooth and WLAN
  * WLED and BLED are not handled like other XLED, because in some dsdt
  * they also control the WLAN/Bluetooth device.
  */
@@ -150,22 +152,32 @@ ASUS_HANDLE(lcd_switch, "\\_SB.PCI0.SBRG.EC0._Q10",	/* All new models */
 
 /* Display */
 ASUS_HANDLE(display_set, ASUS_HOTK_PREFIX "SDSP");
-ASUS_HANDLE(display_get, "\\_SB.PCI0.P0P1.VGA.GETD",	/*  A6B, A6K A6R A7D F3JM L4R M6R A3G
-							   M6A M6V VX-1 V6J V6V W3Z */
-	    "\\_SB.PCI0.P0P2.VGA.GETD",	/* A3E A4K, A4D A4L A6J A7J A8J Z71V M9V
-					   S5A M5A z33A W1Jc W2V G1 */
-	    "\\_SB.PCI0.P0P3.VGA.GETD",	/* A6V A6Q */
-	    "\\_SB.PCI0.P0PA.VGA.GETD",	/* A6T, A6M */
-	    "\\_SB.PCI0.PCI1.VGAC.NMAP",	/* L3C */
-	    "\\_SB.PCI0.VGA.GETD",	/* Z96F */
-	    "\\ACTD",		/* A2D */
-	    "\\ADVG",		/* A4G Z71A W1N W5A W5F M2N M3N M5N M6N S1N S5N */
-	    "\\DNXT",		/* P30 */
-	    "\\INFB",		/* A2H D1 L2D L3D L3H L2E L5D L5C M1A M2E L4L W3V */
-	    "\\SSTE");		/* A3F A6F A3N A3L M6N W3N W6A */
-
-ASUS_HANDLE(ls_switch, ASUS_HOTK_PREFIX "ALSC");	/* Z71A Z71V */
-ASUS_HANDLE(ls_level, ASUS_HOTK_PREFIX "ALSL");	/* Z71A Z71V */
+ASUS_HANDLE(display_get,
+	    /* A6B, A6K A6R A7D F3JM L4R M6R A3G M6A M6V VX-1 V6J V6V W3Z */
+	    "\\_SB.PCI0.P0P1.VGA.GETD",
+	    /* A3E A4K, A4D A4L A6J A7J A8J Z71V M9V S5A M5A z33A W1Jc W2V G1 */
+	    "\\_SB.PCI0.P0P2.VGA.GETD",
+	    /* A6V A6Q */
+	    "\\_SB.PCI0.P0P3.VGA.GETD",
+	    /* A6T, A6M */
+	    "\\_SB.PCI0.P0PA.VGA.GETD",
+	    /* L3C */
+	    "\\_SB.PCI0.PCI1.VGAC.NMAP",
+	    /* Z96F */
+	    "\\_SB.PCI0.VGA.GETD",
+	    /* A2D */
+	    "\\ACTD",
+	    /* A4G Z71A W1N W5A W5F M2N M3N M5N M6N S1N S5N */
+	    "\\ADVG",
+	    /* P30 */
+	    "\\DNXT",
+	    /* A2H D1 L2D L3D L3H L2E L5D L5C M1A M2E L4L W3V */
+	    "\\INFB",
+	    /* A3F A6F A3N A3L M6N W3N W6A */
+	    "\\SSTE");
+
+ASUS_HANDLE(ls_switch, ASUS_HOTK_PREFIX "ALSC"); /* Z71A Z71V */
+ASUS_HANDLE(ls_level, ASUS_HOTK_PREFIX "ALSL");	 /* Z71A Z71V */
 
 /* GPS */
 /* R2H use different handle for GPS on/off */
@@ -182,14 +194,14 @@ ASUS_HANDLE(kled_get, ASUS_HOTK_PREFIX "GLKB");
  * about the hotk device
  */
 struct asus_hotk {
-	char *name;		//laptop name
-	struct acpi_device *device;	//the device we are in
-	acpi_handle handle;	//the handle of the hotk device
-	char status;		//status of the hotk, for LEDs, ...
-	u32 ledd_status;	//status of the LED display
-	u8 light_level;		//light sensor level
-	u8 light_switch;	//light sensor switch value
-	u16 event_count[128];	//count for each event TODO make this better
+	char *name;		/* laptop name */
+	struct acpi_device *device;	/* the device we are in */
+	acpi_handle handle;	/* the handle of the hotk device */
+	char status;		/* status of the hotk, for LEDs, ... */
+	u32 ledd_status;	/* status of the LED display */
+	u8 light_level;		/* light sensor level */
+	u8 light_switch;	/* light sensor switch value */
+	u16 event_count[128];	/* count for each event TODO make this better */
 	struct input_dev *inputdev;
 	u16 *keycode_map;
 };
@@ -242,10 +254,12 @@ static struct backlight_ops asusbl_ops = {
 	.update_status = update_bl_status,
 };
 
-/* These functions actually update the LED's, and are called from a
+/*
+ * These functions actually update the LED's, and are called from a
  * workqueue. By doing this as separate work rather than when the LED
  * subsystem asks, we avoid messing with the Asus ACPI stuff during a
- * potentially bad time, such as a timer interrupt. */
+ * potentially bad time, such as a timer interrupt.
+ */
 static struct workqueue_struct *led_workqueue;
 
 #define ASUS_LED(object, ledname, max)					\
@@ -318,8 +332,8 @@ static struct key_entry asus_keymap[] = {
 static int write_acpi_int(acpi_handle handle, const char *method, int val,
 			  struct acpi_buffer *output)
 {
-	struct acpi_object_list params;	//list of input parameters (an int here)
-	union acpi_object in_obj;	//the only param we use
+	struct acpi_object_list params;	/* list of input parameters (an int) */
+	union acpi_object in_obj;	/* the only param we use */
 	acpi_status status;
 
 	if (!handle)
@@ -574,7 +588,7 @@ static ssize_t show_infos(struct device *dev,
 {
 	int len = 0;
 	unsigned long long temp;
-	char buf[16];		//enough for all info
+	char buf[16];		/* enough for all info */
 	acpi_status rv = AE_OK;
 
 	/*
@@ -734,8 +748,10 @@ static int read_display(void)
 	unsigned long long value = 0;
 	acpi_status rv = AE_OK;
 
-	/* In most of the case, we know how to set the display, but sometime
-	   we can't read it */
+	/*
+	 * In most of the case, we know how to set the display, but sometime
+	 * we can't read it
+	 */
 	if (display_get_handle) {
 		rv = acpi_evaluate_integer(display_get_handle, NULL,
 					   NULL, &value);
@@ -1152,8 +1168,10 @@ static int asus_hotk_get_info(void)
 	ASUS_HANDLE_INIT(display_set);
 	ASUS_HANDLE_INIT(display_get);
 
-	/* There is a lot of models with "ALSL", but a few get
-	   a real light sens, so we need to check it. */
+	/*
+	 * There is a lot of models with "ALSL", but a few get
+	 * a real light sens, so we need to check it.
+	 */
 	if (!ASUS_HANDLE_INIT(ls_switch))
 		ASUS_HANDLE_INIT(ls_level);
 

commit 0aa20f7d720ed1feeb74df8c63a6427d9a2d3ebd
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Fri Aug 28 12:56:53 2009 +0000

    asus-laptop: Add "calculator" hotkey
    
    Found on UX50V.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 0325f7c2d7a0..5b912cc5cbee 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -291,6 +291,7 @@ static struct key_entry asus_keymap[] = {
 	{KE_KEY, 0x4c, KEY_MEDIA},
 	{KE_KEY, 0x50, KEY_EMAIL},
 	{KE_KEY, 0x51, KEY_WWW},
+	{KE_KEY, 0x55, KEY_CALC},
 	{KE_KEY, 0x5C, KEY_SCREENLOCK},  /* Screenlock */
 	{KE_KEY, 0x5D, KEY_WLAN},
 	{KE_KEY, 0x5E, KEY_WLAN},

commit 4644d0e5bd1412bbaed77e46c0c3376c6d060a74
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Fri Aug 28 12:56:52 2009 +0000

    asus-laptop: Add suport for another "Media" key
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index dd926b913ec9..0325f7c2d7a0 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -288,6 +288,7 @@ static struct key_entry asus_keymap[] = {
 	{KE_KEY, 0x41, KEY_NEXTSONG},
 	{KE_KEY, 0x43, KEY_STOPCD},
 	{KE_KEY, 0x45, KEY_PLAYPAUSE},
+	{KE_KEY, 0x4c, KEY_MEDIA},
 	{KE_KEY, 0x50, KEY_EMAIL},
 	{KE_KEY, 0x51, KEY_WWW},
 	{KE_KEY, 0x5C, KEY_SCREENLOCK},  /* Screenlock */

commit dc79526078d2c0f01445e54e1d9fdf7c15ffd63d
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Fri Aug 28 12:56:51 2009 +0000

    asus-laptop: handle keyboard backlight keys
    
    Add support for the Fn+F3/Fn+F4 keys and map them
    as KEY_KBDILLUMUP and KEY_KBDILLUMDOWN.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 0fb4e5971516..dd926b913ec9 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -301,6 +301,8 @@ static struct key_entry asus_keymap[] = {
 	{KE_KEY, 0x8A, KEY_PROG1},
 	{KE_KEY, 0x95, KEY_MEDIA},
 	{KE_KEY, 0x99, KEY_PHONE},
+	{KE_KEY, 0xc4, KEY_KBDILLUMUP},
+	{KE_KEY, 0xc5, KEY_KBDILLUMDOWN},
 	{KE_END, 0},
 };
 

commit b7d3fbc2ed624cc216adda0f2574570e6d6d6aed
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Fri Aug 28 12:56:50 2009 +0000

    asus-laptop: Add support for Keyboard backlight
    
    Add support for keyboard backlight found in Asus U50VG.
    
    The SMC driver for the Apples does it via LED. To be
    consistent with that we create /sys/class/leds/asus::kbd_backlight/
    to control the keyboard backlight.
    
    SLKB and GLKB are used to get/set the backlight. On
    the U50VG is supports 4 brightness level, but this may
    change with other models.
    
    SLKB take a 8 bit integer where the higher bit is used
    to toggle the backlight, and the over 7 bits control the
    brightness level.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 652902e6f205..0fb4e5971516 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -86,6 +86,7 @@
 #define GLED_ON     0x40	//Gaming LED
 #define LCD_ON      0x80	//LCD backlight
 #define GPS_ON      0x100	//GPS
+#define KEY_ON      0x200       //Keyboard backlight
 
 #define ASUS_LOG    ASUS_HOTK_FILE ": "
 #define ASUS_ERR    KERN_ERR    ASUS_LOG
@@ -172,6 +173,10 @@ ASUS_HANDLE(gps_on, ASUS_HOTK_PREFIX "SDON");	/* R2H */
 ASUS_HANDLE(gps_off, ASUS_HOTK_PREFIX "SDOF");	/* R2H */
 ASUS_HANDLE(gps_status, ASUS_HOTK_PREFIX "GPST");
 
+/* Keyboard light */
+ASUS_HANDLE(kled_set, ASUS_HOTK_PREFIX "SLKB");
+ASUS_HANDLE(kled_get, ASUS_HOTK_PREFIX "GLKB");
+
 /*
  * This is the main structure, we can use it to store anything interesting
  * about the hotk device
@@ -263,6 +268,7 @@ ASUS_LED(tled, "touchpad", 1);
 ASUS_LED(rled, "record", 1);
 ASUS_LED(pled, "phone", 1);
 ASUS_LED(gled, "gaming", 1);
+ASUS_LED(kled, "kbd_backlight", 3);
 
 struct key_entry {
 	char type;
@@ -419,6 +425,60 @@ ASUS_LED_HANDLER(rled, RLED_ON);
 ASUS_LED_HANDLER(tled, TLED_ON);
 ASUS_LED_HANDLER(gled, GLED_ON);
 
+/*
+ * Keyboard backlight
+ */
+static int get_kled_lvl(void)
+{
+	unsigned long long kblv;
+	struct acpi_object_list params;
+	union acpi_object in_obj;
+	acpi_status rv;
+
+	params.count = 1;
+	params.pointer = &in_obj;
+	in_obj.type = ACPI_TYPE_INTEGER;
+	in_obj.integer.value = 2;
+
+	rv = acpi_evaluate_integer(kled_get_handle, NULL, &params, &kblv);
+	if (ACPI_FAILURE(rv)) {
+		pr_warning("Error reading kled level\n");
+		return 0;
+	}
+	return kblv;
+}
+
+static int set_kled_lvl(int kblv)
+{
+	if (kblv > 0)
+		kblv = (1 << 7) | (kblv & 0x7F);
+	else
+		kblv = 0;
+
+	if (write_acpi_int(kled_set_handle, NULL, kblv, NULL)) {
+		pr_warning("Keyboard LED display write failed\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void kled_led_set(struct led_classdev *led_cdev,
+			 enum led_brightness value)
+{
+	kled_led_wk = value;
+	queue_work(led_workqueue, &kled_led_work);
+}
+
+static void kled_led_update(struct work_struct *ignored)
+{
+	set_kled_lvl(kled_led_wk);
+}
+
+static enum led_brightness kled_led_get(struct led_classdev *led_cdev)
+{
+	return get_kled_lvl();
+}
+
 static int get_lcd_state(void)
 {
 	return read_status(LCD_ON);
@@ -1059,6 +1119,9 @@ static int asus_hotk_get_info(void)
 
 	ASUS_HANDLE_INIT(ledd_set);
 
+	ASUS_HANDLE_INIT(kled_set);
+	ASUS_HANDLE_INIT(kled_get);
+
 	/*
 	 * The HWRS method return informations about the hardware.
 	 * 0x80 bit is for WLAN, 0x100 for Bluetooth.
@@ -1190,6 +1253,10 @@ static int asus_hotk_add(struct acpi_device *device)
 	/* LCD Backlight is on by default */
 	write_status(NULL, 1, LCD_ON);
 
+	/* Keyboard Backlight is on by default */
+	if (kled_set_handle)
+		set_kled_lvl(1);
+
 	/* LED display is off by default */
 	hotk->ledd_status = 0xFFF;
 
@@ -1244,6 +1311,7 @@ static void asus_led_exit(void)
 	ASUS_LED_UNREGISTER(pled);
 	ASUS_LED_UNREGISTER(rled);
 	ASUS_LED_UNREGISTER(gled);
+	ASUS_LED_UNREGISTER(kled);
 }
 
 static void asus_input_exit(void)
@@ -1323,13 +1391,20 @@ static int asus_led_init(struct device *dev)
 	if (rv)
 		goto out4;
 
+	if (kled_set_handle && kled_get_handle)
+		rv = ASUS_LED_REGISTER(kled, dev);
+	if (rv)
+		goto out5;
+
 	led_workqueue = create_singlethread_workqueue("led_workqueue");
 	if (!led_workqueue)
-		goto out5;
+		goto out6;
 
 	return 0;
-out5:
+out6:
 	rv = -ENOMEM;
+	ASUS_LED_UNREGISTER(kled);
+out5:
 	ASUS_LED_UNREGISTER(gled);
 out4:
 	ASUS_LED_UNREGISTER(pled);

commit 977c328d81e31fde70c5ba381d9cf7357451dd74
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Fri Aug 28 12:56:49 2009 +0000

    asus-laptop: set maximum led brightness
    
    Set the right maximum brightness which is one, because
    they can only be on or off.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 410e545e427b..652902e6f205 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -243,7 +243,7 @@ static struct backlight_ops asusbl_ops = {
  * potentially bad time, such as a timer interrupt. */
 static struct workqueue_struct *led_workqueue;
 
-#define ASUS_LED(object, ledname)					\
+#define ASUS_LED(object, ledname, max)					\
 	static void object##_led_set(struct led_classdev *led_cdev,	\
 				     enum led_brightness value);	\
 	static enum led_brightness object##_led_get(			\
@@ -255,13 +255,14 @@ static struct workqueue_struct *led_workqueue;
 		.name           = "asus::" ledname,			\
 		.brightness_set = object##_led_set,			\
 		.brightness_get = object##_led_get,			\
+		.max_brightness = max					\
 	}
 
-ASUS_LED(mled, "mail");
-ASUS_LED(tled, "touchpad");
-ASUS_LED(rled, "record");
-ASUS_LED(pled, "phone");
-ASUS_LED(gled, "gaming");
+ASUS_LED(mled, "mail", 1);
+ASUS_LED(tled, "touchpad", 1);
+ASUS_LED(rled, "record", 1);
+ASUS_LED(pled, "phone", 1);
+ASUS_LED(gled, "gaming", 1);
 
 struct key_entry {
 	char type;

commit f641375b65f64e83be8be68ae1ebce21ee4fd578
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Fri Aug 28 12:56:48 2009 +0000

    asus-laptop: Map X50R hotkeys
    
    Map some new hotkeys found on X50R.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 88cc9a1045b4..410e545e427b 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -285,6 +285,9 @@ static struct key_entry asus_keymap[] = {
 	{KE_KEY, 0x51, KEY_WWW},
 	{KE_KEY, 0x5C, KEY_SCREENLOCK},  /* Screenlock */
 	{KE_KEY, 0x5D, KEY_WLAN},
+	{KE_KEY, 0x5E, KEY_WLAN},
+	{KE_KEY, 0x5F, KEY_WLAN},
+	{KE_KEY, 0x60, KEY_SWITCHVIDEOMODE},
 	{KE_KEY, 0x61, KEY_SWITCHVIDEOMODE},
 	{KE_KEY, 0x6B, BTN_TOUCH}, /* Lock Mouse */
 	{KE_KEY, 0x82, KEY_CAMERA},

commit abfa57e15acaa6e1ec567c250e5212bc55d79e43
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Fri Aug 28 12:56:47 2009 +0000

    asus-laptop: Add *_led_get() functions
    
    Add support for getting led brightness directly from
    the hardware. Currently we don't need it, but it is needed
    to support keyboard backlight/led.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 23449508d86b..88cc9a1045b4 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -246,12 +246,15 @@ static struct workqueue_struct *led_workqueue;
 #define ASUS_LED(object, ledname)					\
 	static void object##_led_set(struct led_classdev *led_cdev,	\
 				     enum led_brightness value);	\
+	static enum led_brightness object##_led_get(			\
+		struct led_classdev *led_cdev);				\
 	static void object##_led_update(struct work_struct *ignored);	\
 	static int object##_led_wk;					\
 	static DECLARE_WORK(object##_led_work, object##_led_update);	\
 	static struct led_classdev object##_led = {			\
 		.name           = "asus::" ledname,			\
 		.brightness_set = object##_led_set,			\
+		.brightness_get = object##_led_get,			\
 	}
 
 ASUS_LED(mled, "mail");
@@ -399,6 +402,11 @@ static void write_status(acpi_handle handle, int out, int mask)
 	{								\
 		int value = object##_led_wk;				\
 		write_status(object##_set_handle, value, (mask));	\
+	}								\
+	static enum led_brightness object##_led_get(			\
+		struct led_classdev *led_cdev)				\
+	{								\
+		return led_cdev->brightness;				\
 	}
 
 ASUS_LED_HANDLER(mled, MLED_ON);

commit 1d4a3800c764d111d67462a14589ed1611b2f55e
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Fri Aug 28 12:56:46 2009 +0000

    asus-laptop: Show HRWS in infos and fix output format
    
    Show HRWS in /sys/platform/devices/asus-laptop/infos.
    HRWS is a bitfield used to get information about Hardware
    available in the laptop.
    Also change sprintf format from 0x%04x to %#x.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index db657bbeec90..23449508d86b 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -516,7 +516,17 @@ static ssize_t show_infos(struct device *dev,
 	 */
 	rv = acpi_evaluate_integer(hotk->handle, "SFUN", NULL, &temp);
 	if (!ACPI_FAILURE(rv))
-		len += sprintf(page + len, "SFUN value         : 0x%04x\n",
+		len += sprintf(page + len, "SFUN value         : %#x\n",
+			       (uint) temp);
+	/*
+	 * The HWRS method return informations about the hardware.
+	 * 0x80 bit is for WLAN, 0x100 for Bluetooth.
+	 * The significance of others is yet to be found.
+	 * If we don't find the method, we assume the device are present.
+	 */
+	rv = acpi_evaluate_integer(hotk->handle, "HRWS", NULL, &temp);
+	if (!ACPI_FAILURE(rv))
+		len += sprintf(page + len, "HRWS value         : %#x\n",
 			       (uint) temp);
 	/*
 	 * Another value for userspace: the ASYM method returns 0x02 for
@@ -527,7 +537,7 @@ static ssize_t show_infos(struct device *dev,
 	 */
 	rv = acpi_evaluate_integer(hotk->handle, "ASYM", NULL, &temp);
 	if (!ACPI_FAILURE(rv))
-		len += sprintf(page + len, "ASYM value         : 0x%04x\n",
+		len += sprintf(page + len, "ASYM value         : %#x\n",
 			       (uint) temp);
 	if (asus_info) {
 		snprintf(buf, 16, "%d", asus_info->length);

commit 2fcc23da5522b89677fb0af6043a88e88fdd09a2
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Fri Jun 19 14:52:03 2009 +0200

    asus-laptop: use pr_fmt and pr_<level>
    
    Convert the unusual printk(ASUS_<level> uses to
    the more standard pr_fmt and pr_<level>(.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index faa87d3e3983..db657bbeec90 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -33,6 +33,8 @@
  *  Sam Lin        - GPS support
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -53,9 +55,10 @@
 #define ASUS_HOTK_NAME          "Asus Laptop Support"
 #define ASUS_HOTK_CLASS         "hotkey"
 #define ASUS_HOTK_DEVICE_NAME   "Hotkey"
-#define ASUS_HOTK_FILE          "asus-laptop"
+#define ASUS_HOTK_FILE          KBUILD_MODNAME
 #define ASUS_HOTK_PREFIX        "\\_SB.ATKD."
 
+
 /*
  * Some events we use, same for all Asus
  */
@@ -327,7 +330,7 @@ static int read_wireless_status(int mask)
 
 	rv = acpi_evaluate_integer(wireless_status_handle, NULL, NULL, &status);
 	if (ACPI_FAILURE(rv))
-		printk(ASUS_WARNING "Error reading Wireless status\n");
+		pr_warning("Error reading Wireless status\n");
 	else
 		return (status & mask) ? 1 : 0;
 
@@ -341,7 +344,7 @@ static int read_gps_status(void)
 
 	rv = acpi_evaluate_integer(gps_status_handle, NULL, NULL, &status);
 	if (ACPI_FAILURE(rv))
-		printk(ASUS_WARNING "Error reading GPS status\n");
+		pr_warning("Error reading GPS status\n");
 	else
 		return status ? 1 : 0;
 
@@ -381,7 +384,7 @@ static void write_status(acpi_handle handle, int out, int mask)
 	}
 
 	if (write_acpi_int(handle, NULL, out, NULL))
-		printk(ASUS_WARNING " write failed %x\n", mask);
+		pr_warning(" write failed %x\n", mask);
 }
 
 /* /sys/class/led handlers */
@@ -424,7 +427,7 @@ static int set_lcd_state(int value)
 					      NULL, NULL, NULL);
 
 		if (ACPI_FAILURE(status))
-			printk(ASUS_WARNING "Error switching LCD\n");
+			pr_warning("Error switching LCD\n");
 	}
 
 	write_status(NULL, lcd, LCD_ON);
@@ -448,7 +451,7 @@ static int read_brightness(struct backlight_device *bd)
 
 	rv = acpi_evaluate_integer(brightness_get_handle, NULL, NULL, &value);
 	if (ACPI_FAILURE(rv))
-		printk(ASUS_WARNING "Error reading brightness\n");
+		pr_warning("Error reading brightness\n");
 
 	return value;
 }
@@ -461,7 +464,7 @@ static int set_brightness(struct backlight_device *bd, int value)
 	/* 0 <= value <= 15 */
 
 	if (write_acpi_int(brightness_set_handle, NULL, value, NULL)) {
-		printk(ASUS_WARNING "Error changing brightness\n");
+		pr_warning("Error changing brightness\n");
 		ret = -EIO;
 	}
 
@@ -591,7 +594,7 @@ static ssize_t store_ledd(struct device *dev, struct device_attribute *attr,
 	rv = parse_arg(buf, count, &value);
 	if (rv > 0) {
 		if (write_acpi_int(ledd_set_handle, NULL, value, NULL))
-			printk(ASUS_WARNING "LED display write failed\n");
+			pr_warning("LED display write failed\n");
 		else
 			hotk->ledd_status = (u32) value;
 	}
@@ -636,7 +639,7 @@ static void set_display(int value)
 {
 	/* no sanity check needed for now */
 	if (write_acpi_int(display_set_handle, NULL, value, NULL))
-		printk(ASUS_WARNING "Error setting display\n");
+		pr_warning("Error setting display\n");
 	return;
 }
 
@@ -651,7 +654,7 @@ static int read_display(void)
 		rv = acpi_evaluate_integer(display_get_handle, NULL,
 					   NULL, &value);
 		if (ACPI_FAILURE(rv))
-			printk(ASUS_WARNING "Error reading display status\n");
+			pr_warning("Error reading display status\n");
 	}
 
 	value &= 0x0F;		/* needed for some models, shouldn't hurt others */
@@ -693,7 +696,7 @@ static ssize_t store_disp(struct device *dev, struct device_attribute *attr,
 static void set_light_sens_switch(int value)
 {
 	if (write_acpi_int(ls_switch_handle, NULL, value, NULL))
-		printk(ASUS_WARNING "Error setting light sensor switch\n");
+		pr_warning("Error setting light sensor switch\n");
 	hotk->light_switch = value;
 }
 
@@ -718,7 +721,7 @@ static ssize_t store_lssw(struct device *dev, struct device_attribute *attr,
 static void set_light_sens_level(int value)
 {
 	if (write_acpi_int(ls_level_handle, NULL, value, NULL))
-		printk(ASUS_WARNING "Error setting light sensor level\n");
+		pr_warning("Error setting light sensor level\n");
 	hotk->light_level = value;
 }
 
@@ -979,11 +982,11 @@ static int asus_hotk_get_info(void)
 	 */
 	status = acpi_get_table(ACPI_SIG_DSDT, 1, &asus_info);
 	if (ACPI_FAILURE(status))
-		printk(ASUS_WARNING "Couldn't get the DSDT table header\n");
+		pr_warning("Couldn't get the DSDT table header\n");
 
 	/* We have to write 0 on init this far for all ASUS models */
 	if (write_acpi_int(hotk->handle, "INIT", 0, &buffer)) {
-		printk(ASUS_ERR "Hotkey initialization failed\n");
+		pr_err("Hotkey initialization failed\n");
 		return -ENODEV;
 	}
 
@@ -991,9 +994,9 @@ static int asus_hotk_get_info(void)
 	status =
 	    acpi_evaluate_integer(hotk->handle, "BSTS", NULL, &bsts_result);
 	if (ACPI_FAILURE(status))
-		printk(ASUS_WARNING "Error calling BSTS\n");
+		pr_warning("Error calling BSTS\n");
 	else if (bsts_result)
-		printk(ASUS_NOTICE "BSTS called, 0x%02x returned\n",
+		pr_notice("BSTS called, 0x%02x returned\n",
 		       (uint) bsts_result);
 
 	/* This too ... */
@@ -1024,7 +1027,7 @@ static int asus_hotk_get_info(void)
 		return -ENOMEM;
 
 	if (*string)
-		printk(ASUS_NOTICE "  %s model detected\n", string);
+		pr_notice("  %s model detected\n", string);
 
 	ASUS_HANDLE_INIT(mled_set);
 	ASUS_HANDLE_INIT(tled_set);
@@ -1081,7 +1084,7 @@ static int asus_input_init(void)
 
 	hotk->inputdev = input_allocate_device();
 	if (!hotk->inputdev) {
-		printk(ASUS_INFO "Unable to allocate input device\n");
+		pr_info("Unable to allocate input device\n");
 		return 0;
 	}
 	hotk->inputdev->name = "Asus Laptop extra buttons";
@@ -1100,7 +1103,7 @@ static int asus_input_init(void)
 	}
 	result = input_register_device(hotk->inputdev);
 	if (result) {
-		printk(ASUS_INFO "Unable to register input device\n");
+		pr_info("Unable to register input device\n");
 		input_free_device(hotk->inputdev);
 	}
 	return result;
@@ -1117,7 +1120,7 @@ static int asus_hotk_check(void)
 	if (hotk->device->status.present) {
 		result = asus_hotk_get_info();
 	} else {
-		printk(ASUS_ERR "Hotkey device not present, aborting\n");
+		pr_err("Hotkey device not present, aborting\n");
 		return -EINVAL;
 	}
 
@@ -1133,7 +1136,7 @@ static int asus_hotk_add(struct acpi_device *device)
 	if (!device)
 		return -EINVAL;
 
-	printk(ASUS_NOTICE "Asus Laptop Support version %s\n",
+	pr_notice("Asus Laptop Support version %s\n",
 	       ASUS_LAPTOP_VERSION);
 
 	hotk = kzalloc(sizeof(struct asus_hotk), GFP_KERNEL);
@@ -1247,8 +1250,7 @@ static int asus_backlight_init(struct device *dev)
 		bd = backlight_device_register(ASUS_HOTK_FILE, dev,
 					       NULL, &asusbl_ops);
 		if (IS_ERR(bd)) {
-			printk(ASUS_ERR
-			       "Could not register asus backlight device\n");
+			pr_err("Could not register asus backlight device\n");
 			asus_backlight_device = NULL;
 			return PTR_ERR(bd);
 		}
@@ -1375,7 +1377,7 @@ static int __init asus_laptop_init(void)
 		if (result)
 			goto fail_backlight;
 	} else
-		printk(ASUS_INFO "Brightness ignored, must be controlled by "
+		pr_info("Brightness ignored, must be controlled by "
 		       "ACPI video driver\n");
 
 	return 0;

commit 116bf2e010a0600371aede450351973821dfd9e2
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Tue Jun 16 19:28:46 2009 +0000

    asus-laptop: platform dev as parent for led and backlight
    
    Makes asus-laptop platform device the parent device of
    backlight and led classes.
    
    With this patch, leds and backlight are also available in
    /sys/devices/platform/asus-laptop/ like thinkpad_acpi.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index eaffe732653a..faa87d3e3983 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -1321,7 +1321,6 @@ static int asus_led_init(struct device *dev)
 
 static int __init asus_laptop_init(void)
 {
-	struct device *dev;
 	int result;
 
 	if (acpi_disabled)
@@ -1343,24 +1342,10 @@ static int __init asus_laptop_init(void)
 		return -ENODEV;
 	}
 
-	dev = acpi_get_physical_device(hotk->device->handle);
-
-	if (!acpi_video_backlight_support()) {
-		result = asus_backlight_init(dev);
-		if (result)
-			goto fail_backlight;
-	} else
-		printk(ASUS_INFO "Brightness ignored, must be controlled by "
-		       "ACPI video driver\n");
-
 	result = asus_input_init();
 	if (result)
 		goto fail_input;
 
-	result = asus_led_init(dev);
-	if (result)
-		goto fail_led;
-
 	/* Register platform stuff */
 	result = platform_driver_register(&asuspf_driver);
 	if (result)
@@ -1381,8 +1366,27 @@ static int __init asus_laptop_init(void)
 	if (result)
 		goto fail_sysfs;
 
+	result = asus_led_init(&asuspf_device->dev);
+	if (result)
+		goto fail_led;
+
+	if (!acpi_video_backlight_support()) {
+		result = asus_backlight_init(&asuspf_device->dev);
+		if (result)
+			goto fail_backlight;
+	} else
+		printk(ASUS_INFO "Brightness ignored, must be controlled by "
+		       "ACPI video driver\n");
+
 	return 0;
 
+fail_backlight:
+       asus_led_exit();
+
+fail_led:
+       sysfs_remove_group(&asuspf_device->dev.kobj,
+			  &asuspf_attribute_group);
+
 fail_sysfs:
 	platform_device_del(asuspf_device);
 
@@ -1393,15 +1397,9 @@ static int __init asus_laptop_init(void)
 	platform_driver_unregister(&asuspf_driver);
 
 fail_platform_driver:
-	asus_led_exit();
-
-fail_led:
 	asus_input_exit();
 
 fail_input:
-	asus_backlight_exit();
-
-fail_backlight:
 
 	return result;
 }

commit 586ed1604fd6137cae1e8ede8143c3b8897306fd
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Apr 30 09:35:53 2009 -0600

    ACPI: asus-laptop: use .notify method instead of installing handler directly
    
    This patch adds a .notify() method.  The presence of .notify() causes
    Linux/ACPI to manage event handlers and notify handlers on our behalf,
    so we don't have to install and remove them ourselves.
    
    This driver apparently relies on seeing ALL notify events, not just
    device-specific ones (because it used ACPI_ALL_NOTIFY).  We use the
    ACPI_DRIVER_ALL_NOTIFY_EVENTS driver flag to request all events.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    CC: Corentin Chary <corentincj@iksaif.net>
    CC: acpi4asus-user@lists.sourceforge.net
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index bfc1a8892a32..eaffe732653a 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -207,13 +207,17 @@ MODULE_DEVICE_TABLE(acpi, asus_device_ids);
 
 static int asus_hotk_add(struct acpi_device *device);
 static int asus_hotk_remove(struct acpi_device *device, int type);
+static void asus_hotk_notify(struct acpi_device *device, u32 event);
+
 static struct acpi_driver asus_hotk_driver = {
 	.name = ASUS_HOTK_NAME,
 	.class = ASUS_HOTK_CLASS,
 	.ids = asus_device_ids,
+	.flags = ACPI_DRIVER_ALL_NOTIFY_EVENTS,
 	.ops = {
 		.add = asus_hotk_add,
 		.remove = asus_hotk_remove,
+		.notify = asus_hotk_notify,
 		},
 };
 
@@ -812,7 +816,7 @@ static int asus_setkeycode(struct input_dev *dev, int scancode, int keycode)
 	return -EINVAL;
 }
 
-static void asus_hotk_notify(acpi_handle handle, u32 event, void *data)
+static void asus_hotk_notify(struct acpi_device *device, u32 event)
 {
 	static struct key_entry *key;
 	u16 count;
@@ -1124,7 +1128,6 @@ static int asus_hotk_found;
 
 static int asus_hotk_add(struct acpi_device *device)
 {
-	acpi_status status = AE_OK;
 	int result;
 
 	if (!device)
@@ -1149,15 +1152,6 @@ static int asus_hotk_add(struct acpi_device *device)
 
 	asus_hotk_add_fs();
 
-	/*
-	 * We install the handler, it will receive the hotk in parameter, so, we
-	 * could add other data to the hotk struct
-	 */
-	status = acpi_install_notify_handler(hotk->handle, ACPI_ALL_NOTIFY,
-					     asus_hotk_notify, hotk);
-	if (ACPI_FAILURE(status))
-		printk(ASUS_ERR "Error installing notify handler\n");
-
 	asus_hotk_found = 1;
 
 	/* WLED and BLED are on by default */
@@ -1198,16 +1192,9 @@ static int asus_hotk_add(struct acpi_device *device)
 
 static int asus_hotk_remove(struct acpi_device *device, int type)
 {
-	acpi_status status = 0;
-
 	if (!device || !acpi_driver_data(device))
 		return -EINVAL;
 
-	status = acpi_remove_notify_handler(hotk->handle, ACPI_ALL_NOTIFY,
-					    asus_hotk_notify);
-	if (ACPI_FAILURE(status))
-		printk(ASUS_ERR "Error removing notify handler\n");
-
 	kfree(hotk->name);
 	kfree(hotk);
 

commit 309f5fbda37d5e8f1233e8b80b8e9de77262e864
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Mon Apr 27 09:23:42 2009 +0200

    asus-laptop: fix input keycode
    
    KEY_STOP is now KEY_STOPCD
     It's the correct key to stop a media
    BTN_EXTRA is now KEY_SCREENLOCK:
     The laptop manual tells us that this key is for screenlock
    KEY_TV is now KEY_PROG1
     So it can be reported to X server
    
    Ref: https://bugs.launchpad.net/ubuntu/+source/linux/+bug/361505
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index eeafc6c0160d..bfc1a8892a32 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -269,16 +269,16 @@ static struct key_entry asus_keymap[] = {
 	{KE_KEY, 0x34, KEY_SWITCHVIDEOMODE},
 	{KE_KEY, 0x40, KEY_PREVIOUSSONG},
 	{KE_KEY, 0x41, KEY_NEXTSONG},
-	{KE_KEY, 0x43, KEY_STOP},
+	{KE_KEY, 0x43, KEY_STOPCD},
 	{KE_KEY, 0x45, KEY_PLAYPAUSE},
 	{KE_KEY, 0x50, KEY_EMAIL},
 	{KE_KEY, 0x51, KEY_WWW},
-	{KE_KEY, 0x5C, BTN_EXTRA},  /* Performance */
+	{KE_KEY, 0x5C, KEY_SCREENLOCK},  /* Screenlock */
 	{KE_KEY, 0x5D, KEY_WLAN},
 	{KE_KEY, 0x61, KEY_SWITCHVIDEOMODE},
 	{KE_KEY, 0x6B, BTN_TOUCH}, /* Lock Mouse */
 	{KE_KEY, 0x82, KEY_CAMERA},
-	{KE_KEY, 0x8A, KEY_TV},
+	{KE_KEY, 0x8A, KEY_PROG1},
 	{KE_KEY, 0x95, KEY_MEDIA},
 	{KE_KEY, 0x99, KEY_PHONE},
 	{KE_END, 0},

commit 6050c8dd70b21a9d927983aeb6357fecffa7fb23
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Sun Feb 15 19:30:19 2009 +0100

    asus-laptop: restore acpi_generate_proc_event()
    
    Restore acpi_generate_proc_event() for backward
    compatibility with old acpi scripts.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 56af6cf385b0..eeafc6c0160d 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -815,6 +815,7 @@ static int asus_setkeycode(struct input_dev *dev, int scancode, int keycode)
 static void asus_hotk_notify(acpi_handle handle, u32 event, void *data)
 {
 	static struct key_entry *key;
+	u16 count;
 
 	/* TODO Find a better way to handle events count. */
 	if (!hotk)
@@ -832,9 +833,11 @@ static void asus_hotk_notify(acpi_handle handle, u32 event, void *data)
 		lcd_blank(FB_BLANK_POWERDOWN);
 	}
 
+	count = hotk->event_count[event % 128]++;
+	acpi_bus_generate_proc_event(hotk->device, event, count);
 	acpi_bus_generate_netlink_event(hotk->device->pnp.device_class,
 					dev_name(&hotk->device->dev), event,
-					hotk->event_count[event % 128]++);
+					count);
 
 	if (hotk->inputdev) {
 		key = asus_get_entry_by_scancode(event);

commit ed6f44215374d94c35cbe98b582d004b9a3f5fbe
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Tue Jan 20 16:17:45 2009 +0100

    asus-laptop: fix label indentation
    
    Fix the label indentation
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 53dbfb420627..56af6cf385b0 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -1184,7 +1184,7 @@ static int asus_hotk_add(struct acpi_device *device)
 	/* GPS is on by default */
 	write_status(NULL, 1, GPS_ON);
 
-      end:
+end:
 	if (result) {
 		kfree(hotk->name);
 		kfree(hotk);
@@ -1393,25 +1393,25 @@ static int __init asus_laptop_init(void)
 
 	return 0;
 
-      fail_sysfs:
+fail_sysfs:
 	platform_device_del(asuspf_device);
 
-      fail_platform_device2:
+fail_platform_device2:
 	platform_device_put(asuspf_device);
 
-      fail_platform_device1:
+fail_platform_device1:
 	platform_driver_unregister(&asuspf_driver);
 
-      fail_platform_driver:
+fail_platform_driver:
 	asus_led_exit();
 
-      fail_led:
+fail_led:
 	asus_input_exit();
 
-      fail_input:
+fail_input:
 	asus_backlight_exit();
 
-      fail_backlight:
+fail_backlight:
 
 	return result;
 }

commit 034ce90a8d1051deaeb31bae7f26ff1440a5b988
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Tue Jan 20 16:17:43 2009 +0100

    asus-laptop: hotkeys via the generic input interface
    
    This patch is based on eeepc-laptop.c and the patchs
    from Nicolas Trangez and Daniel Nascimento (mainly for the keymap).
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 1b7a28c1da73..53dbfb420627 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -46,6 +46,7 @@
 #include <acpi/acpi_drivers.h>
 #include <acpi/acpi_bus.h>
 #include <asm/uaccess.h>
+#include <linux/input.h>
 
 #define ASUS_LAPTOP_VERSION "0.42"
 
@@ -181,6 +182,8 @@ struct asus_hotk {
 	u8 light_level;		//light sensor level
 	u8 light_switch;	//light sensor switch value
 	u16 event_count[128];	//count for each event TODO make this better
+	struct input_dev *inputdev;
+	u16 *keycode_map;
 };
 
 /*
@@ -250,6 +253,37 @@ ASUS_LED(rled, "record");
 ASUS_LED(pled, "phone");
 ASUS_LED(gled, "gaming");
 
+struct key_entry {
+	char type;
+	u8 code;
+	u16 keycode;
+};
+
+enum { KE_KEY, KE_END };
+
+static struct key_entry asus_keymap[] = {
+	{KE_KEY, 0x30, KEY_VOLUMEUP},
+	{KE_KEY, 0x31, KEY_VOLUMEDOWN},
+	{KE_KEY, 0x32, KEY_MUTE},
+	{KE_KEY, 0x33, KEY_SWITCHVIDEOMODE},
+	{KE_KEY, 0x34, KEY_SWITCHVIDEOMODE},
+	{KE_KEY, 0x40, KEY_PREVIOUSSONG},
+	{KE_KEY, 0x41, KEY_NEXTSONG},
+	{KE_KEY, 0x43, KEY_STOP},
+	{KE_KEY, 0x45, KEY_PLAYPAUSE},
+	{KE_KEY, 0x50, KEY_EMAIL},
+	{KE_KEY, 0x51, KEY_WWW},
+	{KE_KEY, 0x5C, BTN_EXTRA},  /* Performance */
+	{KE_KEY, 0x5D, KEY_WLAN},
+	{KE_KEY, 0x61, KEY_SWITCHVIDEOMODE},
+	{KE_KEY, 0x6B, BTN_TOUCH}, /* Lock Mouse */
+	{KE_KEY, 0x82, KEY_CAMERA},
+	{KE_KEY, 0x8A, KEY_TV},
+	{KE_KEY, 0x95, KEY_MEDIA},
+	{KE_KEY, 0x99, KEY_PHONE},
+	{KE_END, 0},
+};
+
 /*
  * This function evaluates an ACPI method, given an int as parameter, the
  * method is searched within the scope of the handle, can be NULL. The output
@@ -720,8 +754,68 @@ static ssize_t store_gps(struct device *dev, struct device_attribute *attr,
 	return store_status(buf, count, NULL, GPS_ON);
 }
 
+/*
+ * Hotkey functions
+ */
+static struct key_entry *asus_get_entry_by_scancode(int code)
+{
+	struct key_entry *key;
+
+	for (key = asus_keymap; key->type != KE_END; key++)
+		if (code == key->code)
+			return key;
+
+	return NULL;
+}
+
+static struct key_entry *asus_get_entry_by_keycode(int code)
+{
+	struct key_entry *key;
+
+	for (key = asus_keymap; key->type != KE_END; key++)
+		if (code == key->keycode && key->type == KE_KEY)
+			return key;
+
+	return NULL;
+}
+
+static int asus_getkeycode(struct input_dev *dev, int scancode, int *keycode)
+{
+	struct key_entry *key = asus_get_entry_by_scancode(scancode);
+
+	if (key && key->type == KE_KEY) {
+		*keycode = key->keycode;
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int asus_setkeycode(struct input_dev *dev, int scancode, int keycode)
+{
+	struct key_entry *key;
+	int old_keycode;
+
+	if (keycode < 0 || keycode > KEY_MAX)
+		return -EINVAL;
+
+	key = asus_get_entry_by_scancode(scancode);
+	if (key && key->type == KE_KEY) {
+		old_keycode = key->keycode;
+		key->keycode = keycode;
+		set_bit(keycode, dev->keybit);
+		if (!asus_get_entry_by_keycode(old_keycode))
+			clear_bit(old_keycode, dev->keybit);
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
 static void asus_hotk_notify(acpi_handle handle, u32 event, void *data)
 {
+	static struct key_entry *key;
+
 	/* TODO Find a better way to handle events count. */
 	if (!hotk)
 		return;
@@ -742,7 +836,20 @@ static void asus_hotk_notify(acpi_handle handle, u32 event, void *data)
 					dev_name(&hotk->device->dev), event,
 					hotk->event_count[event % 128]++);
 
-	return;
+	if (hotk->inputdev) {
+		key = asus_get_entry_by_scancode(event);
+		if (!key)
+			return ;
+
+		switch (key->type) {
+		case KE_KEY:
+			input_report_key(hotk->inputdev, key->keycode, 1);
+			input_sync(hotk->inputdev);
+			input_report_key(hotk->inputdev, key->keycode, 0);
+			input_sync(hotk->inputdev);
+			break;
+		}
+	}
 }
 
 #define ASUS_CREATE_DEVICE_ATTR(_name)					\
@@ -960,6 +1067,38 @@ static int asus_hotk_get_info(void)
 	return AE_OK;
 }
 
+static int asus_input_init(void)
+{
+	const struct key_entry *key;
+	int result;
+
+	hotk->inputdev = input_allocate_device();
+	if (!hotk->inputdev) {
+		printk(ASUS_INFO "Unable to allocate input device\n");
+		return 0;
+	}
+	hotk->inputdev->name = "Asus Laptop extra buttons";
+	hotk->inputdev->phys = ASUS_HOTK_FILE "/input0";
+	hotk->inputdev->id.bustype = BUS_HOST;
+	hotk->inputdev->getkeycode = asus_getkeycode;
+	hotk->inputdev->setkeycode = asus_setkeycode;
+
+	for (key = asus_keymap; key->type != KE_END; key++) {
+		switch (key->type) {
+		case KE_KEY:
+			set_bit(EV_KEY, hotk->inputdev->evbit);
+			set_bit(key->keycode, hotk->inputdev->keybit);
+			break;
+		}
+	}
+	result = input_register_device(hotk->inputdev);
+	if (result) {
+		printk(ASUS_INFO "Unable to register input device\n");
+		input_free_device(hotk->inputdev);
+	}
+	return result;
+}
+
 static int asus_hotk_check(void)
 {
 	int result = 0;
@@ -1092,10 +1231,17 @@ static void asus_led_exit(void)
 	ASUS_LED_UNREGISTER(gled);
 }
 
+static void asus_input_exit(void)
+{
+	if (hotk->inputdev)
+		input_unregister_device(hotk->inputdev);
+}
+
 static void __exit asus_laptop_exit(void)
 {
 	asus_backlight_exit();
 	asus_led_exit();
+	asus_input_exit();
 
 	acpi_bus_unregister_driver(&asus_hotk_driver);
 	sysfs_remove_group(&asuspf_device->dev.kobj, &asuspf_attribute_group);
@@ -1217,6 +1363,10 @@ static int __init asus_laptop_init(void)
 		printk(ASUS_INFO "Brightness ignored, must be controlled by "
 		       "ACPI video driver\n");
 
+	result = asus_input_init();
+	if (result)
+		goto fail_input;
+
 	result = asus_led_init(dev);
 	if (result)
 		goto fail_led;
@@ -1256,6 +1406,9 @@ static int __init asus_laptop_init(void)
 	asus_led_exit();
 
       fail_led:
+	asus_input_exit();
+
+      fail_input:
 	asus_backlight_exit();
 
       fail_backlight:

commit 2a7dc0d8c60325e9bf820900bf919430e5a419ab
Author: Corentin Chary <corentincj@iksaif.net>
Date:   Tue Jan 20 16:17:42 2009 +0100

    asus-laptop: use generic netlink interface
    
    To be prepared for /proc/acpi/event removal we export events
    also through generic netlink interface.
    
    Signed-off-by: Corentin Chary <corentincj@iksaif.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 8fb8b3591048..1b7a28c1da73 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -738,8 +738,9 @@ static void asus_hotk_notify(acpi_handle handle, u32 event, void *data)
 		lcd_blank(FB_BLANK_POWERDOWN);
 	}
 
-	acpi_bus_generate_proc_event(hotk->device, event,
-				hotk->event_count[event % 128]++);
+	acpi_bus_generate_netlink_event(hotk->device->pnp.device_class,
+					dev_name(&hotk->device->dev), event,
+					hotk->event_count[event % 128]++);
 
 	return;
 }

commit 41b16dce390510f550a4d2b12b98e0258bbed6e2
Author: Len Brown <len.brown@intel.com>
Date:   Mon Dec 1 00:09:47 2008 -0500

    create drivers/platform/x86/ from drivers/misc/
    
    Move x86 platform specific drivers from drivers/misc/
    to a new home under drivers/platform/x86/.
    
    The community has been maintaining x86 vendor-specific
    platform specific drivers under /drivers/misc/ for a few years.
    The oldest ones started life under drivers/acpi.
    They moved out of drivers/acpi/ because they don't actually
    implement the ACPI specification, but either simply
    use ACPI, or implement vendor-specific ACPI extensions.
    
    In the future we anticipate...
    drivers/misc/ will go away.
    other architectures will create drivers/platform/<arch>
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
new file mode 100644
index 000000000000..8fb8b3591048
--- /dev/null
+++ b/drivers/platform/x86/asus-laptop.c
@@ -0,0 +1,1266 @@
+/*
+ *  asus-laptop.c - Asus Laptop Support
+ *
+ *
+ *  Copyright (C) 2002-2005 Julien Lerouge, 2003-2006 Karol Kozimor
+ *  Copyright (C) 2006-2007 Corentin Chary
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *
+ *  The development page for this driver is located at
+ *  http://sourceforge.net/projects/acpi4asus/
+ *
+ *  Credits:
+ *  Pontus Fuchs   - Helper functions, cleanup
+ *  Johann Wiesner - Small compile fixes
+ *  John Belmonte  - ACPI code for Toshiba laptop was a good starting point.
+ *  Eric Burghard  - LED display support for W1N
+ *  Josh Green     - Light Sens support
+ *  Thomas Tuttle  - His first patch for led support was very helpfull
+ *  Sam Lin        - GPS support
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/err.h>
+#include <linux/proc_fs.h>
+#include <linux/backlight.h>
+#include <linux/fb.h>
+#include <linux/leds.h>
+#include <linux/platform_device.h>
+#include <acpi/acpi_drivers.h>
+#include <acpi/acpi_bus.h>
+#include <asm/uaccess.h>
+
+#define ASUS_LAPTOP_VERSION "0.42"
+
+#define ASUS_HOTK_NAME          "Asus Laptop Support"
+#define ASUS_HOTK_CLASS         "hotkey"
+#define ASUS_HOTK_DEVICE_NAME   "Hotkey"
+#define ASUS_HOTK_FILE          "asus-laptop"
+#define ASUS_HOTK_PREFIX        "\\_SB.ATKD."
+
+/*
+ * Some events we use, same for all Asus
+ */
+#define ATKD_BR_UP       0x10
+#define ATKD_BR_DOWN     0x20
+#define ATKD_LCD_ON      0x33
+#define ATKD_LCD_OFF     0x34
+
+/*
+ * Known bits returned by \_SB.ATKD.HWRS
+ */
+#define WL_HWRS     0x80
+#define BT_HWRS     0x100
+
+/*
+ * Flags for hotk status
+ * WL_ON and BT_ON are also used for wireless_status()
+ */
+#define WL_ON       0x01	//internal Wifi
+#define BT_ON       0x02	//internal Bluetooth
+#define MLED_ON     0x04	//mail LED
+#define TLED_ON     0x08	//touchpad LED
+#define RLED_ON     0x10	//Record LED
+#define PLED_ON     0x20	//Phone LED
+#define GLED_ON     0x40	//Gaming LED
+#define LCD_ON      0x80	//LCD backlight
+#define GPS_ON      0x100	//GPS
+
+#define ASUS_LOG    ASUS_HOTK_FILE ": "
+#define ASUS_ERR    KERN_ERR    ASUS_LOG
+#define ASUS_WARNING    KERN_WARNING    ASUS_LOG
+#define ASUS_NOTICE KERN_NOTICE ASUS_LOG
+#define ASUS_INFO   KERN_INFO   ASUS_LOG
+#define ASUS_DEBUG  KERN_DEBUG  ASUS_LOG
+
+MODULE_AUTHOR("Julien Lerouge, Karol Kozimor, Corentin Chary");
+MODULE_DESCRIPTION(ASUS_HOTK_NAME);
+MODULE_LICENSE("GPL");
+
+/* WAPF defines the behavior of the Fn+Fx wlan key
+ * The significance of values is yet to be found, but
+ * most of the time:
+ * 0x0 will do nothing
+ * 0x1 will allow to control the device with Fn+Fx key.
+ * 0x4 will send an ACPI event (0x88) while pressing the Fn+Fx key
+ * 0x5 like 0x1 or 0x4
+ * So, if something doesn't work as you want, just try other values =)
+ */
+static uint wapf = 1;
+module_param(wapf, uint, 0644);
+MODULE_PARM_DESC(wapf, "WAPF value");
+
+#define ASUS_HANDLE(object, paths...)					\
+	static acpi_handle  object##_handle = NULL;			\
+	static char *object##_paths[] = { paths }
+
+/* LED */
+ASUS_HANDLE(mled_set, ASUS_HOTK_PREFIX "MLED");
+ASUS_HANDLE(tled_set, ASUS_HOTK_PREFIX "TLED");
+ASUS_HANDLE(rled_set, ASUS_HOTK_PREFIX "RLED");	/* W1JC */
+ASUS_HANDLE(pled_set, ASUS_HOTK_PREFIX "PLED");	/* A7J */
+ASUS_HANDLE(gled_set, ASUS_HOTK_PREFIX "GLED");	/* G1, G2 (probably) */
+
+/* LEDD */
+ASUS_HANDLE(ledd_set, ASUS_HOTK_PREFIX "SLCM");
+
+/* Bluetooth and WLAN
+ * WLED and BLED are not handled like other XLED, because in some dsdt
+ * they also control the WLAN/Bluetooth device.
+ */
+ASUS_HANDLE(wl_switch, ASUS_HOTK_PREFIX "WLED");
+ASUS_HANDLE(bt_switch, ASUS_HOTK_PREFIX "BLED");
+ASUS_HANDLE(wireless_status, ASUS_HOTK_PREFIX "RSTS");	/* All new models */
+
+/* Brightness */
+ASUS_HANDLE(brightness_set, ASUS_HOTK_PREFIX "SPLV");
+ASUS_HANDLE(brightness_get, ASUS_HOTK_PREFIX "GPLV");
+
+/* Backlight */
+ASUS_HANDLE(lcd_switch, "\\_SB.PCI0.SBRG.EC0._Q10",	/* All new models */
+	    "\\_SB.PCI0.ISA.EC0._Q10",	/* A1x */
+	    "\\_SB.PCI0.PX40.ECD0._Q10",	/* L3C */
+	    "\\_SB.PCI0.PX40.EC0.Q10",	/* M1A */
+	    "\\_SB.PCI0.LPCB.EC0._Q10",	/* P30 */
+	    "\\_SB.PCI0.LPCB.EC0._Q0E", /* P30/P35 */
+	    "\\_SB.PCI0.PX40.Q10",	/* S1x */
+	    "\\Q10");		/* A2x, L2D, L3D, M2E */
+
+/* Display */
+ASUS_HANDLE(display_set, ASUS_HOTK_PREFIX "SDSP");
+ASUS_HANDLE(display_get, "\\_SB.PCI0.P0P1.VGA.GETD",	/*  A6B, A6K A6R A7D F3JM L4R M6R A3G
+							   M6A M6V VX-1 V6J V6V W3Z */
+	    "\\_SB.PCI0.P0P2.VGA.GETD",	/* A3E A4K, A4D A4L A6J A7J A8J Z71V M9V
+					   S5A M5A z33A W1Jc W2V G1 */
+	    "\\_SB.PCI0.P0P3.VGA.GETD",	/* A6V A6Q */
+	    "\\_SB.PCI0.P0PA.VGA.GETD",	/* A6T, A6M */
+	    "\\_SB.PCI0.PCI1.VGAC.NMAP",	/* L3C */
+	    "\\_SB.PCI0.VGA.GETD",	/* Z96F */
+	    "\\ACTD",		/* A2D */
+	    "\\ADVG",		/* A4G Z71A W1N W5A W5F M2N M3N M5N M6N S1N S5N */
+	    "\\DNXT",		/* P30 */
+	    "\\INFB",		/* A2H D1 L2D L3D L3H L2E L5D L5C M1A M2E L4L W3V */
+	    "\\SSTE");		/* A3F A6F A3N A3L M6N W3N W6A */
+
+ASUS_HANDLE(ls_switch, ASUS_HOTK_PREFIX "ALSC");	/* Z71A Z71V */
+ASUS_HANDLE(ls_level, ASUS_HOTK_PREFIX "ALSL");	/* Z71A Z71V */
+
+/* GPS */
+/* R2H use different handle for GPS on/off */
+ASUS_HANDLE(gps_on, ASUS_HOTK_PREFIX "SDON");	/* R2H */
+ASUS_HANDLE(gps_off, ASUS_HOTK_PREFIX "SDOF");	/* R2H */
+ASUS_HANDLE(gps_status, ASUS_HOTK_PREFIX "GPST");
+
+/*
+ * This is the main structure, we can use it to store anything interesting
+ * about the hotk device
+ */
+struct asus_hotk {
+	char *name;		//laptop name
+	struct acpi_device *device;	//the device we are in
+	acpi_handle handle;	//the handle of the hotk device
+	char status;		//status of the hotk, for LEDs, ...
+	u32 ledd_status;	//status of the LED display
+	u8 light_level;		//light sensor level
+	u8 light_switch;	//light sensor switch value
+	u16 event_count[128];	//count for each event TODO make this better
+};
+
+/*
+ * This header is made available to allow proper configuration given model,
+ * revision number , ... this info cannot go in struct asus_hotk because it is
+ * available before the hotk
+ */
+static struct acpi_table_header *asus_info;
+
+/* The actual device the driver binds to */
+static struct asus_hotk *hotk;
+
+/*
+ * The hotkey driver declaration
+ */
+static const struct acpi_device_id asus_device_ids[] = {
+	{"ATK0100", 0},
+	{"", 0},
+};
+MODULE_DEVICE_TABLE(acpi, asus_device_ids);
+
+static int asus_hotk_add(struct acpi_device *device);
+static int asus_hotk_remove(struct acpi_device *device, int type);
+static struct acpi_driver asus_hotk_driver = {
+	.name = ASUS_HOTK_NAME,
+	.class = ASUS_HOTK_CLASS,
+	.ids = asus_device_ids,
+	.ops = {
+		.add = asus_hotk_add,
+		.remove = asus_hotk_remove,
+		},
+};
+
+/* The backlight device /sys/class/backlight */
+static struct backlight_device *asus_backlight_device;
+
+/*
+ * The backlight class declaration
+ */
+static int read_brightness(struct backlight_device *bd);
+static int update_bl_status(struct backlight_device *bd);
+static struct backlight_ops asusbl_ops = {
+	.get_brightness = read_brightness,
+	.update_status = update_bl_status,
+};
+
+/* These functions actually update the LED's, and are called from a
+ * workqueue. By doing this as separate work rather than when the LED
+ * subsystem asks, we avoid messing with the Asus ACPI stuff during a
+ * potentially bad time, such as a timer interrupt. */
+static struct workqueue_struct *led_workqueue;
+
+#define ASUS_LED(object, ledname)					\
+	static void object##_led_set(struct led_classdev *led_cdev,	\
+				     enum led_brightness value);	\
+	static void object##_led_update(struct work_struct *ignored);	\
+	static int object##_led_wk;					\
+	static DECLARE_WORK(object##_led_work, object##_led_update);	\
+	static struct led_classdev object##_led = {			\
+		.name           = "asus::" ledname,			\
+		.brightness_set = object##_led_set,			\
+	}
+
+ASUS_LED(mled, "mail");
+ASUS_LED(tled, "touchpad");
+ASUS_LED(rled, "record");
+ASUS_LED(pled, "phone");
+ASUS_LED(gled, "gaming");
+
+/*
+ * This function evaluates an ACPI method, given an int as parameter, the
+ * method is searched within the scope of the handle, can be NULL. The output
+ * of the method is written is output, which can also be NULL
+ *
+ * returns 0 if write is successful, -1 else.
+ */
+static int write_acpi_int(acpi_handle handle, const char *method, int val,
+			  struct acpi_buffer *output)
+{
+	struct acpi_object_list params;	//list of input parameters (an int here)
+	union acpi_object in_obj;	//the only param we use
+	acpi_status status;
+
+	if (!handle)
+		return 0;
+
+	params.count = 1;
+	params.pointer = &in_obj;
+	in_obj.type = ACPI_TYPE_INTEGER;
+	in_obj.integer.value = val;
+
+	status = acpi_evaluate_object(handle, (char *)method, &params, output);
+	if (status == AE_OK)
+		return 0;
+	else
+		return -1;
+}
+
+static int read_wireless_status(int mask)
+{
+	unsigned long long status;
+	acpi_status rv = AE_OK;
+
+	if (!wireless_status_handle)
+		return (hotk->status & mask) ? 1 : 0;
+
+	rv = acpi_evaluate_integer(wireless_status_handle, NULL, NULL, &status);
+	if (ACPI_FAILURE(rv))
+		printk(ASUS_WARNING "Error reading Wireless status\n");
+	else
+		return (status & mask) ? 1 : 0;
+
+	return (hotk->status & mask) ? 1 : 0;
+}
+
+static int read_gps_status(void)
+{
+	unsigned long long status;
+	acpi_status rv = AE_OK;
+
+	rv = acpi_evaluate_integer(gps_status_handle, NULL, NULL, &status);
+	if (ACPI_FAILURE(rv))
+		printk(ASUS_WARNING "Error reading GPS status\n");
+	else
+		return status ? 1 : 0;
+
+	return (hotk->status & GPS_ON) ? 1 : 0;
+}
+
+/* Generic LED functions */
+static int read_status(int mask)
+{
+	/* There is a special method for both wireless devices */
+	if (mask == BT_ON || mask == WL_ON)
+		return read_wireless_status(mask);
+	else if (mask == GPS_ON)
+		return read_gps_status();
+
+	return (hotk->status & mask) ? 1 : 0;
+}
+
+static void write_status(acpi_handle handle, int out, int mask)
+{
+	hotk->status = (out) ? (hotk->status | mask) : (hotk->status & ~mask);
+
+	switch (mask) {
+	case MLED_ON:
+		out = !(out & 0x1);
+		break;
+	case GLED_ON:
+		out = (out & 0x1) + 1;
+		break;
+	case GPS_ON:
+		handle = (out) ? gps_on_handle : gps_off_handle;
+		out = 0x02;
+		break;
+	default:
+		out &= 0x1;
+		break;
+	}
+
+	if (write_acpi_int(handle, NULL, out, NULL))
+		printk(ASUS_WARNING " write failed %x\n", mask);
+}
+
+/* /sys/class/led handlers */
+#define ASUS_LED_HANDLER(object, mask)					\
+	static void object##_led_set(struct led_classdev *led_cdev,	\
+				     enum led_brightness value)		\
+	{								\
+		object##_led_wk = (value > 0) ? 1 : 0;			\
+		queue_work(led_workqueue, &object##_led_work);		\
+	}								\
+	static void object##_led_update(struct work_struct *ignored)	\
+	{								\
+		int value = object##_led_wk;				\
+		write_status(object##_set_handle, value, (mask));	\
+	}
+
+ASUS_LED_HANDLER(mled, MLED_ON);
+ASUS_LED_HANDLER(pled, PLED_ON);
+ASUS_LED_HANDLER(rled, RLED_ON);
+ASUS_LED_HANDLER(tled, TLED_ON);
+ASUS_LED_HANDLER(gled, GLED_ON);
+
+static int get_lcd_state(void)
+{
+	return read_status(LCD_ON);
+}
+
+static int set_lcd_state(int value)
+{
+	int lcd = 0;
+	acpi_status status = 0;
+
+	lcd = value ? 1 : 0;
+
+	if (lcd == get_lcd_state())
+		return 0;
+
+	if (lcd_switch_handle) {
+		status = acpi_evaluate_object(lcd_switch_handle,
+					      NULL, NULL, NULL);
+
+		if (ACPI_FAILURE(status))
+			printk(ASUS_WARNING "Error switching LCD\n");
+	}
+
+	write_status(NULL, lcd, LCD_ON);
+	return 0;
+}
+
+static void lcd_blank(int blank)
+{
+	struct backlight_device *bd = asus_backlight_device;
+
+	if (bd) {
+		bd->props.power = blank;
+		backlight_update_status(bd);
+	}
+}
+
+static int read_brightness(struct backlight_device *bd)
+{
+	unsigned long long value;
+	acpi_status rv = AE_OK;
+
+	rv = acpi_evaluate_integer(brightness_get_handle, NULL, NULL, &value);
+	if (ACPI_FAILURE(rv))
+		printk(ASUS_WARNING "Error reading brightness\n");
+
+	return value;
+}
+
+static int set_brightness(struct backlight_device *bd, int value)
+{
+	int ret = 0;
+
+	value = (0 < value) ? ((15 < value) ? 15 : value) : 0;
+	/* 0 <= value <= 15 */
+
+	if (write_acpi_int(brightness_set_handle, NULL, value, NULL)) {
+		printk(ASUS_WARNING "Error changing brightness\n");
+		ret = -EIO;
+	}
+
+	return ret;
+}
+
+static int update_bl_status(struct backlight_device *bd)
+{
+	int rv;
+	int value = bd->props.brightness;
+
+	rv = set_brightness(bd, value);
+	if (rv)
+		return rv;
+
+	value = (bd->props.power == FB_BLANK_UNBLANK) ? 1 : 0;
+	return set_lcd_state(value);
+}
+
+/*
+ * Platform device handlers
+ */
+
+/*
+ * We write our info in page, we begin at offset off and cannot write more
+ * than count bytes. We set eof to 1 if we handle those 2 values. We return the
+ * number of bytes written in page
+ */
+static ssize_t show_infos(struct device *dev,
+			  struct device_attribute *attr, char *page)
+{
+	int len = 0;
+	unsigned long long temp;
+	char buf[16];		//enough for all info
+	acpi_status rv = AE_OK;
+
+	/*
+	 * We use the easy way, we don't care of off and count, so we don't set eof
+	 * to 1
+	 */
+
+	len += sprintf(page, ASUS_HOTK_NAME " " ASUS_LAPTOP_VERSION "\n");
+	len += sprintf(page + len, "Model reference    : %s\n", hotk->name);
+	/*
+	 * The SFUN method probably allows the original driver to get the list
+	 * of features supported by a given model. For now, 0x0100 or 0x0800
+	 * bit signifies that the laptop is equipped with a Wi-Fi MiniPCI card.
+	 * The significance of others is yet to be found.
+	 */
+	rv = acpi_evaluate_integer(hotk->handle, "SFUN", NULL, &temp);
+	if (!ACPI_FAILURE(rv))
+		len += sprintf(page + len, "SFUN value         : 0x%04x\n",
+			       (uint) temp);
+	/*
+	 * Another value for userspace: the ASYM method returns 0x02 for
+	 * battery low and 0x04 for battery critical, its readings tend to be
+	 * more accurate than those provided by _BST.
+	 * Note: since not all the laptops provide this method, errors are
+	 * silently ignored.
+	 */
+	rv = acpi_evaluate_integer(hotk->handle, "ASYM", NULL, &temp);
+	if (!ACPI_FAILURE(rv))
+		len += sprintf(page + len, "ASYM value         : 0x%04x\n",
+			       (uint) temp);
+	if (asus_info) {
+		snprintf(buf, 16, "%d", asus_info->length);
+		len += sprintf(page + len, "DSDT length        : %s\n", buf);
+		snprintf(buf, 16, "%d", asus_info->checksum);
+		len += sprintf(page + len, "DSDT checksum      : %s\n", buf);
+		snprintf(buf, 16, "%d", asus_info->revision);
+		len += sprintf(page + len, "DSDT revision      : %s\n", buf);
+		snprintf(buf, 7, "%s", asus_info->oem_id);
+		len += sprintf(page + len, "OEM id             : %s\n", buf);
+		snprintf(buf, 9, "%s", asus_info->oem_table_id);
+		len += sprintf(page + len, "OEM table id       : %s\n", buf);
+		snprintf(buf, 16, "%x", asus_info->oem_revision);
+		len += sprintf(page + len, "OEM revision       : 0x%s\n", buf);
+		snprintf(buf, 5, "%s", asus_info->asl_compiler_id);
+		len += sprintf(page + len, "ASL comp vendor id : %s\n", buf);
+		snprintf(buf, 16, "%x", asus_info->asl_compiler_revision);
+		len += sprintf(page + len, "ASL comp revision  : 0x%s\n", buf);
+	}
+
+	return len;
+}
+
+static int parse_arg(const char *buf, unsigned long count, int *val)
+{
+	if (!count)
+		return 0;
+	if (count > 31)
+		return -EINVAL;
+	if (sscanf(buf, "%i", val) != 1)
+		return -EINVAL;
+	return count;
+}
+
+static ssize_t store_status(const char *buf, size_t count,
+			    acpi_handle handle, int mask)
+{
+	int rv, value;
+	int out = 0;
+
+	rv = parse_arg(buf, count, &value);
+	if (rv > 0)
+		out = value ? 1 : 0;
+
+	write_status(handle, out, mask);
+
+	return rv;
+}
+
+/*
+ * LEDD display
+ */
+static ssize_t show_ledd(struct device *dev,
+			 struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "0x%08x\n", hotk->ledd_status);
+}
+
+static ssize_t store_ledd(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	int rv, value;
+
+	rv = parse_arg(buf, count, &value);
+	if (rv > 0) {
+		if (write_acpi_int(ledd_set_handle, NULL, value, NULL))
+			printk(ASUS_WARNING "LED display write failed\n");
+		else
+			hotk->ledd_status = (u32) value;
+	}
+	return rv;
+}
+
+/*
+ * WLAN
+ */
+static ssize_t show_wlan(struct device *dev,
+			 struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", read_status(WL_ON));
+}
+
+static ssize_t store_wlan(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	return store_status(buf, count, wl_switch_handle, WL_ON);
+}
+
+/*
+ * Bluetooth
+ */
+static ssize_t show_bluetooth(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", read_status(BT_ON));
+}
+
+static ssize_t store_bluetooth(struct device *dev,
+			       struct device_attribute *attr, const char *buf,
+			       size_t count)
+{
+	return store_status(buf, count, bt_switch_handle, BT_ON);
+}
+
+/*
+ * Display
+ */
+static void set_display(int value)
+{
+	/* no sanity check needed for now */
+	if (write_acpi_int(display_set_handle, NULL, value, NULL))
+		printk(ASUS_WARNING "Error setting display\n");
+	return;
+}
+
+static int read_display(void)
+{
+	unsigned long long value = 0;
+	acpi_status rv = AE_OK;
+
+	/* In most of the case, we know how to set the display, but sometime
+	   we can't read it */
+	if (display_get_handle) {
+		rv = acpi_evaluate_integer(display_get_handle, NULL,
+					   NULL, &value);
+		if (ACPI_FAILURE(rv))
+			printk(ASUS_WARNING "Error reading display status\n");
+	}
+
+	value &= 0x0F;		/* needed for some models, shouldn't hurt others */
+
+	return value;
+}
+
+/*
+ * Now, *this* one could be more user-friendly, but so far, no-one has
+ * complained. The significance of bits is the same as in store_disp()
+ */
+static ssize_t show_disp(struct device *dev,
+			 struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", read_display());
+}
+
+/*
+ * Experimental support for display switching. As of now: 1 should activate
+ * the LCD output, 2 should do for CRT, 4 for TV-Out and 8 for DVI.
+ * Any combination (bitwise) of these will suffice. I never actually tested 4
+ * displays hooked up simultaneously, so be warned. See the acpi4asus README
+ * for more info.
+ */
+static ssize_t store_disp(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	int rv, value;
+
+	rv = parse_arg(buf, count, &value);
+	if (rv > 0)
+		set_display(value);
+	return rv;
+}
+
+/*
+ * Light Sens
+ */
+static void set_light_sens_switch(int value)
+{
+	if (write_acpi_int(ls_switch_handle, NULL, value, NULL))
+		printk(ASUS_WARNING "Error setting light sensor switch\n");
+	hotk->light_switch = value;
+}
+
+static ssize_t show_lssw(struct device *dev,
+			 struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", hotk->light_switch);
+}
+
+static ssize_t store_lssw(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	int rv, value;
+
+	rv = parse_arg(buf, count, &value);
+	if (rv > 0)
+		set_light_sens_switch(value ? 1 : 0);
+
+	return rv;
+}
+
+static void set_light_sens_level(int value)
+{
+	if (write_acpi_int(ls_level_handle, NULL, value, NULL))
+		printk(ASUS_WARNING "Error setting light sensor level\n");
+	hotk->light_level = value;
+}
+
+static ssize_t show_lslvl(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", hotk->light_level);
+}
+
+static ssize_t store_lslvl(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	int rv, value;
+
+	rv = parse_arg(buf, count, &value);
+	if (rv > 0) {
+		value = (0 < value) ? ((15 < value) ? 15 : value) : 0;
+		/* 0 <= value <= 15 */
+		set_light_sens_level(value);
+	}
+
+	return rv;
+}
+
+/*
+ * GPS
+ */
+static ssize_t show_gps(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", read_status(GPS_ON));
+}
+
+static ssize_t store_gps(struct device *dev, struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	return store_status(buf, count, NULL, GPS_ON);
+}
+
+static void asus_hotk_notify(acpi_handle handle, u32 event, void *data)
+{
+	/* TODO Find a better way to handle events count. */
+	if (!hotk)
+		return;
+
+	/*
+	 * We need to tell the backlight device when the backlight power is
+	 * switched
+	 */
+	if (event == ATKD_LCD_ON) {
+		write_status(NULL, 1, LCD_ON);
+		lcd_blank(FB_BLANK_UNBLANK);
+	} else if (event == ATKD_LCD_OFF) {
+		write_status(NULL, 0, LCD_ON);
+		lcd_blank(FB_BLANK_POWERDOWN);
+	}
+
+	acpi_bus_generate_proc_event(hotk->device, event,
+				hotk->event_count[event % 128]++);
+
+	return;
+}
+
+#define ASUS_CREATE_DEVICE_ATTR(_name)					\
+	struct device_attribute dev_attr_##_name = {			\
+		.attr = {						\
+			.name = __stringify(_name),			\
+			.mode = 0 },					\
+		.show   = NULL,						\
+		.store  = NULL,						\
+	}
+
+#define ASUS_SET_DEVICE_ATTR(_name, _mode, _show, _store)		\
+	do {								\
+		dev_attr_##_name.attr.mode = _mode;			\
+		dev_attr_##_name.show = _show;				\
+		dev_attr_##_name.store = _store;			\
+	} while(0)
+
+static ASUS_CREATE_DEVICE_ATTR(infos);
+static ASUS_CREATE_DEVICE_ATTR(wlan);
+static ASUS_CREATE_DEVICE_ATTR(bluetooth);
+static ASUS_CREATE_DEVICE_ATTR(display);
+static ASUS_CREATE_DEVICE_ATTR(ledd);
+static ASUS_CREATE_DEVICE_ATTR(ls_switch);
+static ASUS_CREATE_DEVICE_ATTR(ls_level);
+static ASUS_CREATE_DEVICE_ATTR(gps);
+
+static struct attribute *asuspf_attributes[] = {
+	&dev_attr_infos.attr,
+	&dev_attr_wlan.attr,
+	&dev_attr_bluetooth.attr,
+	&dev_attr_display.attr,
+	&dev_attr_ledd.attr,
+	&dev_attr_ls_switch.attr,
+	&dev_attr_ls_level.attr,
+	&dev_attr_gps.attr,
+	NULL
+};
+
+static struct attribute_group asuspf_attribute_group = {
+	.attrs = asuspf_attributes
+};
+
+static struct platform_driver asuspf_driver = {
+	.driver = {
+		   .name = ASUS_HOTK_FILE,
+		   .owner = THIS_MODULE,
+		   }
+};
+
+static struct platform_device *asuspf_device;
+
+static void asus_hotk_add_fs(void)
+{
+	ASUS_SET_DEVICE_ATTR(infos, 0444, show_infos, NULL);
+
+	if (wl_switch_handle)
+		ASUS_SET_DEVICE_ATTR(wlan, 0644, show_wlan, store_wlan);
+
+	if (bt_switch_handle)
+		ASUS_SET_DEVICE_ATTR(bluetooth, 0644,
+				     show_bluetooth, store_bluetooth);
+
+	if (display_set_handle && display_get_handle)
+		ASUS_SET_DEVICE_ATTR(display, 0644, show_disp, store_disp);
+	else if (display_set_handle)
+		ASUS_SET_DEVICE_ATTR(display, 0200, NULL, store_disp);
+
+	if (ledd_set_handle)
+		ASUS_SET_DEVICE_ATTR(ledd, 0644, show_ledd, store_ledd);
+
+	if (ls_switch_handle && ls_level_handle) {
+		ASUS_SET_DEVICE_ATTR(ls_level, 0644, show_lslvl, store_lslvl);
+		ASUS_SET_DEVICE_ATTR(ls_switch, 0644, show_lssw, store_lssw);
+	}
+
+	if (gps_status_handle && gps_on_handle && gps_off_handle)
+		ASUS_SET_DEVICE_ATTR(gps, 0644, show_gps, store_gps);
+}
+
+static int asus_handle_init(char *name, acpi_handle * handle,
+			    char **paths, int num_paths)
+{
+	int i;
+	acpi_status status;
+
+	for (i = 0; i < num_paths; i++) {
+		status = acpi_get_handle(NULL, paths[i], handle);
+		if (ACPI_SUCCESS(status))
+			return 0;
+	}
+
+	*handle = NULL;
+	return -ENODEV;
+}
+
+#define ASUS_HANDLE_INIT(object)					\
+	asus_handle_init(#object, &object##_handle, object##_paths,	\
+			 ARRAY_SIZE(object##_paths))
+
+/*
+ * This function is used to initialize the hotk with right values. In this
+ * method, we can make all the detection we want, and modify the hotk struct
+ */
+static int asus_hotk_get_info(void)
+{
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *model = NULL;
+	unsigned long long bsts_result, hwrs_result;
+	char *string = NULL;
+	acpi_status status;
+
+	/*
+	 * Get DSDT headers early enough to allow for differentiating between
+	 * models, but late enough to allow acpi_bus_register_driver() to fail
+	 * before doing anything ACPI-specific. Should we encounter a machine,
+	 * which needs special handling (i.e. its hotkey device has a different
+	 * HID), this bit will be moved. A global variable asus_info contains
+	 * the DSDT header.
+	 */
+	status = acpi_get_table(ACPI_SIG_DSDT, 1, &asus_info);
+	if (ACPI_FAILURE(status))
+		printk(ASUS_WARNING "Couldn't get the DSDT table header\n");
+
+	/* We have to write 0 on init this far for all ASUS models */
+	if (write_acpi_int(hotk->handle, "INIT", 0, &buffer)) {
+		printk(ASUS_ERR "Hotkey initialization failed\n");
+		return -ENODEV;
+	}
+
+	/* This needs to be called for some laptops to init properly */
+	status =
+	    acpi_evaluate_integer(hotk->handle, "BSTS", NULL, &bsts_result);
+	if (ACPI_FAILURE(status))
+		printk(ASUS_WARNING "Error calling BSTS\n");
+	else if (bsts_result)
+		printk(ASUS_NOTICE "BSTS called, 0x%02x returned\n",
+		       (uint) bsts_result);
+
+	/* This too ... */
+	write_acpi_int(hotk->handle, "CWAP", wapf, NULL);
+
+	/*
+	 * Try to match the object returned by INIT to the specific model.
+	 * Handle every possible object (or the lack of thereof) the DSDT
+	 * writers might throw at us. When in trouble, we pass NULL to
+	 * asus_model_match() and try something completely different.
+	 */
+	if (buffer.pointer) {
+		model = buffer.pointer;
+		switch (model->type) {
+		case ACPI_TYPE_STRING:
+			string = model->string.pointer;
+			break;
+		case ACPI_TYPE_BUFFER:
+			string = model->buffer.pointer;
+			break;
+		default:
+			string = "";
+			break;
+		}
+	}
+	hotk->name = kstrdup(string, GFP_KERNEL);
+	if (!hotk->name)
+		return -ENOMEM;
+
+	if (*string)
+		printk(ASUS_NOTICE "  %s model detected\n", string);
+
+	ASUS_HANDLE_INIT(mled_set);
+	ASUS_HANDLE_INIT(tled_set);
+	ASUS_HANDLE_INIT(rled_set);
+	ASUS_HANDLE_INIT(pled_set);
+	ASUS_HANDLE_INIT(gled_set);
+
+	ASUS_HANDLE_INIT(ledd_set);
+
+	/*
+	 * The HWRS method return informations about the hardware.
+	 * 0x80 bit is for WLAN, 0x100 for Bluetooth.
+	 * The significance of others is yet to be found.
+	 * If we don't find the method, we assume the device are present.
+	 */
+	status =
+	    acpi_evaluate_integer(hotk->handle, "HRWS", NULL, &hwrs_result);
+	if (ACPI_FAILURE(status))
+		hwrs_result = WL_HWRS | BT_HWRS;
+
+	if (hwrs_result & WL_HWRS)
+		ASUS_HANDLE_INIT(wl_switch);
+	if (hwrs_result & BT_HWRS)
+		ASUS_HANDLE_INIT(bt_switch);
+
+	ASUS_HANDLE_INIT(wireless_status);
+
+	ASUS_HANDLE_INIT(brightness_set);
+	ASUS_HANDLE_INIT(brightness_get);
+
+	ASUS_HANDLE_INIT(lcd_switch);
+
+	ASUS_HANDLE_INIT(display_set);
+	ASUS_HANDLE_INIT(display_get);
+
+	/* There is a lot of models with "ALSL", but a few get
+	   a real light sens, so we need to check it. */
+	if (!ASUS_HANDLE_INIT(ls_switch))
+		ASUS_HANDLE_INIT(ls_level);
+
+	ASUS_HANDLE_INIT(gps_on);
+	ASUS_HANDLE_INIT(gps_off);
+	ASUS_HANDLE_INIT(gps_status);
+
+	kfree(model);
+
+	return AE_OK;
+}
+
+static int asus_hotk_check(void)
+{
+	int result = 0;
+
+	result = acpi_bus_get_status(hotk->device);
+	if (result)
+		return result;
+
+	if (hotk->device->status.present) {
+		result = asus_hotk_get_info();
+	} else {
+		printk(ASUS_ERR "Hotkey device not present, aborting\n");
+		return -EINVAL;
+	}
+
+	return result;
+}
+
+static int asus_hotk_found;
+
+static int asus_hotk_add(struct acpi_device *device)
+{
+	acpi_status status = AE_OK;
+	int result;
+
+	if (!device)
+		return -EINVAL;
+
+	printk(ASUS_NOTICE "Asus Laptop Support version %s\n",
+	       ASUS_LAPTOP_VERSION);
+
+	hotk = kzalloc(sizeof(struct asus_hotk), GFP_KERNEL);
+	if (!hotk)
+		return -ENOMEM;
+
+	hotk->handle = device->handle;
+	strcpy(acpi_device_name(device), ASUS_HOTK_DEVICE_NAME);
+	strcpy(acpi_device_class(device), ASUS_HOTK_CLASS);
+	device->driver_data = hotk;
+	hotk->device = device;
+
+	result = asus_hotk_check();
+	if (result)
+		goto end;
+
+	asus_hotk_add_fs();
+
+	/*
+	 * We install the handler, it will receive the hotk in parameter, so, we
+	 * could add other data to the hotk struct
+	 */
+	status = acpi_install_notify_handler(hotk->handle, ACPI_ALL_NOTIFY,
+					     asus_hotk_notify, hotk);
+	if (ACPI_FAILURE(status))
+		printk(ASUS_ERR "Error installing notify handler\n");
+
+	asus_hotk_found = 1;
+
+	/* WLED and BLED are on by default */
+	write_status(bt_switch_handle, 1, BT_ON);
+	write_status(wl_switch_handle, 1, WL_ON);
+
+	/* If the h/w switch is off, we need to check the real status */
+	write_status(NULL, read_status(BT_ON), BT_ON);
+	write_status(NULL, read_status(WL_ON), WL_ON);
+
+	/* LCD Backlight is on by default */
+	write_status(NULL, 1, LCD_ON);
+
+	/* LED display is off by default */
+	hotk->ledd_status = 0xFFF;
+
+	/* Set initial values of light sensor and level */
+	hotk->light_switch = 1;	/* Default to light sensor disabled */
+	hotk->light_level = 0;	/* level 5 for sensor sensitivity */
+
+	if (ls_switch_handle)
+		set_light_sens_switch(hotk->light_switch);
+
+	if (ls_level_handle)
+		set_light_sens_level(hotk->light_level);
+
+	/* GPS is on by default */
+	write_status(NULL, 1, GPS_ON);
+
+      end:
+	if (result) {
+		kfree(hotk->name);
+		kfree(hotk);
+	}
+
+	return result;
+}
+
+static int asus_hotk_remove(struct acpi_device *device, int type)
+{
+	acpi_status status = 0;
+
+	if (!device || !acpi_driver_data(device))
+		return -EINVAL;
+
+	status = acpi_remove_notify_handler(hotk->handle, ACPI_ALL_NOTIFY,
+					    asus_hotk_notify);
+	if (ACPI_FAILURE(status))
+		printk(ASUS_ERR "Error removing notify handler\n");
+
+	kfree(hotk->name);
+	kfree(hotk);
+
+	return 0;
+}
+
+static void asus_backlight_exit(void)
+{
+	if (asus_backlight_device)
+		backlight_device_unregister(asus_backlight_device);
+}
+
+#define  ASUS_LED_UNREGISTER(object)				\
+	if (object##_led.dev)					\
+		led_classdev_unregister(&object##_led)
+
+static void asus_led_exit(void)
+{
+	destroy_workqueue(led_workqueue);
+	ASUS_LED_UNREGISTER(mled);
+	ASUS_LED_UNREGISTER(tled);
+	ASUS_LED_UNREGISTER(pled);
+	ASUS_LED_UNREGISTER(rled);
+	ASUS_LED_UNREGISTER(gled);
+}
+
+static void __exit asus_laptop_exit(void)
+{
+	asus_backlight_exit();
+	asus_led_exit();
+
+	acpi_bus_unregister_driver(&asus_hotk_driver);
+	sysfs_remove_group(&asuspf_device->dev.kobj, &asuspf_attribute_group);
+	platform_device_unregister(asuspf_device);
+	platform_driver_unregister(&asuspf_driver);
+}
+
+static int asus_backlight_init(struct device *dev)
+{
+	struct backlight_device *bd;
+
+	if (brightness_set_handle && lcd_switch_handle) {
+		bd = backlight_device_register(ASUS_HOTK_FILE, dev,
+					       NULL, &asusbl_ops);
+		if (IS_ERR(bd)) {
+			printk(ASUS_ERR
+			       "Could not register asus backlight device\n");
+			asus_backlight_device = NULL;
+			return PTR_ERR(bd);
+		}
+
+		asus_backlight_device = bd;
+
+		bd->props.max_brightness = 15;
+		bd->props.brightness = read_brightness(NULL);
+		bd->props.power = FB_BLANK_UNBLANK;
+		backlight_update_status(bd);
+	}
+	return 0;
+}
+
+static int asus_led_register(acpi_handle handle,
+			     struct led_classdev *ldev, struct device *dev)
+{
+	if (!handle)
+		return 0;
+
+	return led_classdev_register(dev, ldev);
+}
+
+#define ASUS_LED_REGISTER(object, device)				\
+	asus_led_register(object##_set_handle, &object##_led, device)
+
+static int asus_led_init(struct device *dev)
+{
+	int rv;
+
+	rv = ASUS_LED_REGISTER(mled, dev);
+	if (rv)
+		goto out;
+
+	rv = ASUS_LED_REGISTER(tled, dev);
+	if (rv)
+		goto out1;
+
+	rv = ASUS_LED_REGISTER(rled, dev);
+	if (rv)
+		goto out2;
+
+	rv = ASUS_LED_REGISTER(pled, dev);
+	if (rv)
+		goto out3;
+
+	rv = ASUS_LED_REGISTER(gled, dev);
+	if (rv)
+		goto out4;
+
+	led_workqueue = create_singlethread_workqueue("led_workqueue");
+	if (!led_workqueue)
+		goto out5;
+
+	return 0;
+out5:
+	rv = -ENOMEM;
+	ASUS_LED_UNREGISTER(gled);
+out4:
+	ASUS_LED_UNREGISTER(pled);
+out3:
+	ASUS_LED_UNREGISTER(rled);
+out2:
+	ASUS_LED_UNREGISTER(tled);
+out1:
+	ASUS_LED_UNREGISTER(mled);
+out:
+	return rv;
+}
+
+static int __init asus_laptop_init(void)
+{
+	struct device *dev;
+	int result;
+
+	if (acpi_disabled)
+		return -ENODEV;
+
+	result = acpi_bus_register_driver(&asus_hotk_driver);
+	if (result < 0)
+		return result;
+
+	/*
+	 * This is a bit of a kludge.  We only want this module loaded
+	 * for ASUS systems, but there's currently no way to probe the
+	 * ACPI namespace for ASUS HIDs.  So we just return failure if
+	 * we didn't find one, which will cause the module to be
+	 * unloaded.
+	 */
+	if (!asus_hotk_found) {
+		acpi_bus_unregister_driver(&asus_hotk_driver);
+		return -ENODEV;
+	}
+
+	dev = acpi_get_physical_device(hotk->device->handle);
+
+	if (!acpi_video_backlight_support()) {
+		result = asus_backlight_init(dev);
+		if (result)
+			goto fail_backlight;
+	} else
+		printk(ASUS_INFO "Brightness ignored, must be controlled by "
+		       "ACPI video driver\n");
+
+	result = asus_led_init(dev);
+	if (result)
+		goto fail_led;
+
+	/* Register platform stuff */
+	result = platform_driver_register(&asuspf_driver);
+	if (result)
+		goto fail_platform_driver;
+
+	asuspf_device = platform_device_alloc(ASUS_HOTK_FILE, -1);
+	if (!asuspf_device) {
+		result = -ENOMEM;
+		goto fail_platform_device1;
+	}
+
+	result = platform_device_add(asuspf_device);
+	if (result)
+		goto fail_platform_device2;
+
+	result = sysfs_create_group(&asuspf_device->dev.kobj,
+				    &asuspf_attribute_group);
+	if (result)
+		goto fail_sysfs;
+
+	return 0;
+
+      fail_sysfs:
+	platform_device_del(asuspf_device);
+
+      fail_platform_device2:
+	platform_device_put(asuspf_device);
+
+      fail_platform_device1:
+	platform_driver_unregister(&asuspf_driver);
+
+      fail_platform_driver:
+	asus_led_exit();
+
+      fail_led:
+	asus_backlight_exit();
+
+      fail_backlight:
+
+	return result;
+}
+
+module_init(asus_laptop_init);
+module_exit(asus_laptop_exit);
