commit b2057c64017e96f1f9471fe49569508711f7663f
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Thu Mar 26 22:09:51 2020 +0100

    platform/chrome: chromeos_laptop: make I2C API conversion complete
    
    When converting to i2c_new_scanned_device(), it was overlooked that a
    conversion to i2c_new_client_device() was also needed. Fix it.
    
    Fixes: c82ebf1bf738 ("platform/chrome: chromeos_laptop: Convert to i2c_new_scanned_device")
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 4f3651fcd9fe..472a03daa869 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -103,7 +103,7 @@ chromes_laptop_instantiate_i2c_device(struct i2c_adapter *adapter,
 			pr_debug("%d-%02x is probed at %02x\n",
 				 adapter->nr, info->addr, dummy->addr);
 			i2c_unregister_device(dummy);
-			client = i2c_new_device(adapter, info);
+			client = i2c_new_client_device(adapter, info);
 		}
 	}
 

commit c82ebf1bf738e2d6f62266ddfd42f539b344a558
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Mon Dec 16 13:29:51 2019 +0100

    platform/chrome: chromeos_laptop: Convert to i2c_new_scanned_device
    
    Move from the deprecated i2c_new_probed_device() to the new
    i2c_new_scanned_device(). Make use of the new ERRPTR if suitable.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 8723bcf10c93..4f3651fcd9fe 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -63,7 +63,7 @@ struct acpi_peripheral {
 struct chromeos_laptop {
 	/*
 	 * Note that we can't mark this pointer as const because
-	 * i2c_new_probed_device() changes passed in I2C board info, so.
+	 * i2c_new_scanned_device() changes passed in I2C board info, so.
 	 */
 	struct i2c_peripheral *i2c_peripherals;
 	unsigned int num_i2c_peripherals;
@@ -87,8 +87,8 @@ chromes_laptop_instantiate_i2c_device(struct i2c_adapter *adapter,
 	 * address we scan secondary addresses. In any case the client
 	 * structure gets assigned primary address.
 	 */
-	client = i2c_new_probed_device(adapter, info, addr_list, NULL);
-	if (!client && alt_addr) {
+	client = i2c_new_scanned_device(adapter, info, addr_list, NULL);
+	if (IS_ERR(client) && alt_addr) {
 		struct i2c_board_info dummy_info = {
 			I2C_BOARD_INFO("dummy", info->addr),
 		};
@@ -97,9 +97,9 @@ chromes_laptop_instantiate_i2c_device(struct i2c_adapter *adapter,
 		};
 		struct i2c_client *dummy;
 
-		dummy = i2c_new_probed_device(adapter, &dummy_info,
-					      alt_addr_list, NULL);
-		if (dummy) {
+		dummy = i2c_new_scanned_device(adapter, &dummy_info,
+					       alt_addr_list, NULL);
+		if (!IS_ERR(dummy)) {
 			pr_debug("%d-%02x is probed at %02x\n",
 				 adapter->nr, info->addr, dummy->addr);
 			i2c_unregister_device(dummy);
@@ -107,12 +107,14 @@ chromes_laptop_instantiate_i2c_device(struct i2c_adapter *adapter,
 		}
 	}
 
-	if (!client)
+	if (IS_ERR(client)) {
+		client = NULL;
 		pr_debug("failed to register device %d-%02x\n",
 			 adapter->nr, info->addr);
-	else
+	} else {
 		pr_debug("added i2c device %d-%02x\n",
 			 adapter->nr, info->addr);
+	}
 
 	return client;
 }

commit 38d3cfbc95624fa2e8e84cd36c10bfef31d90f0c
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue Aug 20 17:34:49 2019 +0200

    platform/chrome: chromeos_laptop: drop checks of NULL-safe functions
    
    No need to check the argument of i2c_unregister_device() and
    property_entries_free() because the functions do check it.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 7abbb6167766..8723bcf10c93 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -838,18 +838,14 @@ static void chromeos_laptop_destroy(const struct chromeos_laptop *cros_laptop)
 		i2c_dev = &cros_laptop->i2c_peripherals[i];
 		info = &i2c_dev->board_info;
 
-		if (i2c_dev->client)
-			i2c_unregister_device(i2c_dev->client);
-
-		if (info->properties)
-			property_entries_free(info->properties);
+		i2c_unregister_device(i2c_dev->client);
+		property_entries_free(info->properties);
 	}
 
 	for (i = 0; i < cros_laptop->num_acpi_peripherals; i++) {
 		acpi_dev = &cros_laptop->acpi_peripherals[i];
 
-		if (acpi_dev->properties)
-			property_entries_free(acpi_dev->properties);
+		property_entries_free(acpi_dev->properties);
 	}
 
 	kfree(cros_laptop->i2c_peripherals);

commit 3b9f900fa0636b7b530e517b4fbefa6cc5819f52
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Apr 24 21:17:19 2019 +0200

    platform/chrome: chromeos_laptop: use pci_dev_id() helper
    
    Use new helper pci_dev_id() to simplify the code.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-By: Benson Leung <bleung@chromium.org>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 24326eecd787..7abbb6167766 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -125,7 +125,7 @@ static bool chromeos_laptop_match_adapter_devid(struct device *dev, u32 devid)
 		return false;
 
 	pdev = to_pci_dev(dev);
-	return devid == PCI_DEVID(pdev->bus->number, pdev->devfn);
+	return devid == pci_dev_id(pdev);
 }
 
 static void chromeos_laptop_check_adapter(struct i2c_adapter *adapter)

commit 683b647309fc8b4d9d176d2df994efc03f9f8073
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue May 29 12:06:59 2018 -0700

    platform/chrome: chromeos_laptop: fix touchpad button mapping on Celes
    
    Celes has newer touch controller (compared to the controllers used in
    older BayTrail-based devices) and so uses the same button mapping as
    Samus.
    
    This fixes the issue with mouse button being stuck in pressed state
    after the first click.
    
    Reported-by: Sultan Alsawaf <sultanxda@gmail.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Benson Leung <bleung@chromium.org>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 3cecf7933f75..24326eecd787 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -620,10 +620,18 @@ static const struct dmi_system_id chromeos_laptop_dmi_table[] __initconst = {
 		},
 		.driver_data = (void *)&samus,
 	},
+	{
+		.ident = "Samsung Chromebook 3",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GOOGLE"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Celes"),
+		},
+		.driver_data = (void *)&samus,
+	},
 	{
 		/*
 		 * Other Chromebooks with Atmel touch controllers:
-		 * - Celes, Winky (touchpad)
+		 * - Winky (touchpad)
 		 * - Clapper, Expresso, Rambi, Glimmer (touchscreen)
 		 */
 		.ident = "Other Chromebook",

commit 5020cd29d8bfcb3f3add43ea7d58b07011ab96d8
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Thu May 3 17:41:34 2018 -0700

    platform/chrome: chromeos_laptop - supply properties for ACPI devices
    
    BayTrail-based and newer Chromebooks describe their peripherals in ACPI;
    unfortunately their description is not complete, and peripherals
    drivers, such as driver for Atmel Touch controllers, has to resort to
    DMI-matching to configure the peripherals properly. To avoid polluting
    peripheral driver code, let's teach chromeos_laptop driver to supply
    missing data via generic device properties.
    
    Note we supply "compatible" string for Atmel peripherals not because it is
    needed for matching devices and driver (matching is still done on ACPI HID
    entries), but because peripherals driver will be using presence of
    "compatible" property to determine if device properties have been attached
    to the device, and fail to bind if they are absent.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Benson Leung <bleung@chromium.org>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 5c47f451e43b..3cecf7933f75 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -6,6 +6,7 @@
 
 #define pr_fmt(fmt)		KBUILD_MODNAME ": " fmt
 
+#include <linux/acpi.h>
 #include <linux/dmi.h>
 #include <linux/i2c.h>
 #include <linux/input.h>
@@ -54,6 +55,11 @@ struct i2c_peripheral {
 	struct i2c_client *client;
 };
 
+struct acpi_peripheral {
+	char hid[ACPI_ID_LEN];
+	const struct property_entry *properties;
+};
+
 struct chromeos_laptop {
 	/*
 	 * Note that we can't mark this pointer as const because
@@ -61,6 +67,9 @@ struct chromeos_laptop {
 	 */
 	struct i2c_peripheral *i2c_peripherals;
 	unsigned int num_i2c_peripherals;
+
+	const struct acpi_peripheral *acpi_peripherals;
+	unsigned int num_acpi_peripherals;
 };
 
 static const struct chromeos_laptop *cros_laptop;
@@ -148,6 +157,38 @@ static void chromeos_laptop_check_adapter(struct i2c_adapter *adapter)
 	}
 }
 
+static bool chromeos_laptop_adjust_client(struct i2c_client *client)
+{
+	const struct acpi_peripheral *acpi_dev;
+	struct acpi_device_id acpi_ids[2] = { };
+	int i;
+	int error;
+
+	if (!has_acpi_companion(&client->dev))
+		return false;
+
+	for (i = 0; i < cros_laptop->num_acpi_peripherals; i++) {
+		acpi_dev = &cros_laptop->acpi_peripherals[i];
+
+		memcpy(acpi_ids[0].id, acpi_dev->hid, ACPI_ID_LEN);
+
+		if (acpi_match_device(acpi_ids, &client->dev)) {
+			error = device_add_properties(&client->dev,
+						      acpi_dev->properties);
+			if (error) {
+				dev_err(&client->dev,
+					"failed to add properties: %d\n",
+					error);
+				break;
+			}
+
+			return true;
+		}
+	}
+
+	return false;
+}
+
 static void chromeos_laptop_detach_i2c_client(struct i2c_client *client)
 {
 	struct i2c_peripheral *i2c_dev;
@@ -170,6 +211,8 @@ static int chromeos_laptop_i2c_notifier_call(struct notifier_block *nb,
 	case BUS_NOTIFY_ADD_DEVICE:
 		if (dev->type == &i2c_adapter_type)
 			chromeos_laptop_check_adapter(to_i2c_adapter(dev));
+		else if (dev->type == &i2c_client_type)
+			chromeos_laptop_adjust_client(to_i2c_client(dev));
 		break;
 
 	case BUS_NOTIFY_REMOVED_DEVICE:
@@ -191,6 +234,12 @@ static const struct chromeos_laptop _name __initconst = {		\
 	.num_i2c_peripherals	= ARRAY_SIZE(_name##_peripherals),	\
 }
 
+#define DECLARE_ACPI_CROS_LAPTOP(_name)					\
+static const struct chromeos_laptop _name __initconst = {		\
+	.acpi_peripherals	= _name##_peripherals,			\
+	.num_acpi_peripherals	= ARRAY_SIZE(_name##_peripherals),	\
+}
+
 static struct i2c_peripheral samsung_series_5_550_peripherals[] __initdata = {
 	/* Touchpad. */
 	{
@@ -234,16 +283,25 @@ static const int chromebook_pixel_tp_keys[] __initconst = {
 
 static const struct property_entry
 chromebook_pixel_trackpad_props[] __initconst = {
+	PROPERTY_ENTRY_STRING("compatible", "atmel,maxtouch"),
 	PROPERTY_ENTRY_U32_ARRAY("linux,gpio-keymap", chromebook_pixel_tp_keys),
 	{ }
 };
 
+static const struct property_entry
+chromebook_atmel_touchscreen_props[] __initconst = {
+	PROPERTY_ENTRY_STRING("compatible", "atmel,maxtouch"),
+	{ }
+};
+
 static struct i2c_peripheral chromebook_pixel_peripherals[] __initdata = {
 	/* Touch Screen. */
 	{
 		.board_info	= {
 			I2C_BOARD_INFO("atmel_mxt_ts",
 					ATMEL_TS_I2C_ADDR),
+			.properties	=
+				chromebook_atmel_touchscreen_props,
 			.flags		= I2C_CLIENT_WAKE,
 		},
 		.dmi_name	= "touchscreen",
@@ -354,6 +412,8 @@ static struct i2c_peripheral acer_c720_peripherals[] __initdata = {
 		.board_info	= {
 			I2C_BOARD_INFO("atmel_mxt_ts",
 					ATMEL_TS_I2C_ADDR),
+			.properties	=
+				chromebook_atmel_touchscreen_props,
 			.flags		= I2C_CLIENT_WAKE,
 		},
 		.dmi_name	= "touchscreen",
@@ -419,6 +479,47 @@ static struct i2c_peripheral cr48_peripherals[] __initdata = {
 };
 DECLARE_CROS_LAPTOP(cr48);
 
+static const u32 samus_touchpad_buttons[] __initconst = {
+	KEY_RESERVED,
+	KEY_RESERVED,
+	KEY_RESERVED,
+	BTN_LEFT
+};
+
+static const struct property_entry samus_trackpad_props[] __initconst = {
+	PROPERTY_ENTRY_STRING("compatible", "atmel,maxtouch"),
+	PROPERTY_ENTRY_U32_ARRAY("linux,gpio-keymap", samus_touchpad_buttons),
+	{ }
+};
+
+static struct acpi_peripheral samus_peripherals[] __initdata = {
+	/* Touchpad */
+	{
+		.hid		= "ATML0000",
+		.properties	= samus_trackpad_props,
+	},
+	/* Touchsceen */
+	{
+		.hid		= "ATML0001",
+		.properties	= chromebook_atmel_touchscreen_props,
+	},
+};
+DECLARE_ACPI_CROS_LAPTOP(samus);
+
+static struct acpi_peripheral generic_atmel_peripherals[] __initdata = {
+	/* Touchpad */
+	{
+		.hid		= "ATML0000",
+		.properties	= chromebook_pixel_trackpad_props,
+	},
+	/* Touchsceen */
+	{
+		.hid		= "ATML0001",
+		.properties	= chromebook_atmel_touchscreen_props,
+	},
+};
+DECLARE_ACPI_CROS_LAPTOP(generic_atmel);
+
 static const struct dmi_system_id chromeos_laptop_dmi_table[] __initconst = {
 	{
 		.ident = "Samsung Series 5 550",
@@ -502,17 +603,64 @@ static const struct dmi_system_id chromeos_laptop_dmi_table[] __initconst = {
 		},
 		.driver_data = (void *)&cr48,
 	},
+	/* Devices with peripherals incompletely described in ACPI */
+	{
+		.ident = "Chromebook Pro",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Google"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Caroline"),
+		},
+		.driver_data = (void *)&samus,
+	},
+	{
+		.ident = "Google Pixel 2 (2015)",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GOOGLE"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Samus"),
+		},
+		.driver_data = (void *)&samus,
+	},
+	{
+		/*
+		 * Other Chromebooks with Atmel touch controllers:
+		 * - Celes, Winky (touchpad)
+		 * - Clapper, Expresso, Rambi, Glimmer (touchscreen)
+		 */
+		.ident = "Other Chromebook",
+		.matches = {
+			/*
+			 * This will match all Google devices, not only devices
+			 * with Atmel, but we will validate that the device
+			 * actually has matching peripherals.
+			 */
+			DMI_MATCH(DMI_SYS_VENDOR, "GOOGLE"),
+		},
+		.driver_data = (void *)&generic_atmel,
+	},
 	{ }
 };
 MODULE_DEVICE_TABLE(dmi, chromeos_laptop_dmi_table);
 
-static int __init chromeos_laptop_scan_adapter(struct device *dev, void *data)
+static int __init chromeos_laptop_scan_peripherals(struct device *dev, void *data)
 {
-	struct i2c_adapter *adapter;
+	int error;
 
-	adapter = i2c_verify_adapter(dev);
-	if (adapter)
-		chromeos_laptop_check_adapter(adapter);
+	if (dev->type == &i2c_adapter_type) {
+		chromeos_laptop_check_adapter(to_i2c_adapter(dev));
+	} else if (dev->type == &i2c_client_type) {
+		if (chromeos_laptop_adjust_client(to_i2c_client(dev))) {
+			/*
+			 * Now that we have needed properties re-trigger
+			 * driver probe in case driver was initialized
+			 * earlier and probe failed.
+			 */
+			error = device_attach(dev);
+			if (error < 0)
+				dev_warn(dev,
+					 "%s: device_attach() failed: %d\n",
+					 __func__, error);
+		}
+	}
 
 	return 0;
 }
@@ -556,27 +704,24 @@ static int __init chromeos_laptop_setup_irq(struct i2c_peripheral *i2c_dev)
 	return 0;
 }
 
-static struct chromeos_laptop * __init
-chromeos_laptop_prepare(const struct chromeos_laptop *src)
+static int __init
+chromeos_laptop_prepare_i2c_peripherals(struct chromeos_laptop *cros_laptop,
+					const struct chromeos_laptop *src)
 {
-	struct chromeos_laptop *cros_laptop;
 	struct i2c_peripheral *i2c_dev;
 	struct i2c_board_info *info;
-	int error;
 	int i;
+	int error;
 
-	cros_laptop = kzalloc(sizeof(*cros_laptop), GFP_KERNEL);
-	if (!cros_laptop)
-		return ERR_PTR(-ENOMEM);
+	if (!src->num_i2c_peripherals)
+		return 0;
 
 	cros_laptop->i2c_peripherals = kmemdup(src->i2c_peripherals,
 					       src->num_i2c_peripherals *
 						sizeof(*src->i2c_peripherals),
 					       GFP_KERNEL);
-	if (!cros_laptop->i2c_peripherals) {
-		error = -ENOMEM;
-		goto err_free_cros_laptop;
-	}
+	if (!cros_laptop->i2c_peripherals)
+		return -ENOMEM;
 
 	cros_laptop->num_i2c_peripherals = src->num_i2c_peripherals;
 
@@ -586,7 +731,7 @@ chromeos_laptop_prepare(const struct chromeos_laptop *src)
 
 		error = chromeos_laptop_setup_irq(i2c_dev);
 		if (error)
-			goto err_destroy_cros_peripherals;
+			goto err_out;
 
 		/* We need to deep-copy properties */
 		if (info->properties) {
@@ -594,14 +739,14 @@ chromeos_laptop_prepare(const struct chromeos_laptop *src)
 				property_entries_dup(info->properties);
 			if (IS_ERR(info->properties)) {
 				error = PTR_ERR(info->properties);
-				goto err_destroy_cros_peripherals;
+				goto err_out;
 			}
 		}
 	}
 
-	return cros_laptop;
+	return 0;
 
-err_destroy_cros_peripherals:
+err_out:
 	while (--i >= 0) {
 		i2c_dev = &cros_laptop->i2c_peripherals[i];
 		info = &i2c_dev->board_info;
@@ -609,13 +754,74 @@ chromeos_laptop_prepare(const struct chromeos_laptop *src)
 			property_entries_free(info->properties);
 	}
 	kfree(cros_laptop->i2c_peripherals);
-err_free_cros_laptop:
-	kfree(cros_laptop);
-	return ERR_PTR(error);
+	return error;
+}
+
+static int __init
+chromeos_laptop_prepare_acpi_peripherals(struct chromeos_laptop *cros_laptop,
+					const struct chromeos_laptop *src)
+{
+	struct acpi_peripheral *acpi_peripherals;
+	struct acpi_peripheral *acpi_dev;
+	const struct acpi_peripheral *src_dev;
+	int n_peripherals = 0;
+	int i;
+	int error;
+
+	for (i = 0; i < src->num_acpi_peripherals; i++) {
+		if (acpi_dev_present(src->acpi_peripherals[i].hid, NULL, -1))
+			n_peripherals++;
+	}
+
+	if (!n_peripherals)
+		return 0;
+
+	acpi_peripherals = kcalloc(n_peripherals,
+				   sizeof(*src->acpi_peripherals),
+				   GFP_KERNEL);
+	if (!acpi_peripherals)
+		return -ENOMEM;
+
+	acpi_dev = acpi_peripherals;
+	for (i = 0; i < src->num_acpi_peripherals; i++) {
+		src_dev = &src->acpi_peripherals[i];
+		if (!acpi_dev_present(src_dev->hid, NULL, -1))
+			continue;
+
+		*acpi_dev = *src_dev;
+
+		/* We need to deep-copy properties */
+		if (src_dev->properties) {
+			acpi_dev->properties =
+				property_entries_dup(src_dev->properties);
+			if (IS_ERR(acpi_dev->properties)) {
+				error = PTR_ERR(acpi_dev->properties);
+				goto err_out;
+			}
+		}
+
+		acpi_dev++;
+	}
+
+	cros_laptop->acpi_peripherals = acpi_peripherals;
+	cros_laptop->num_acpi_peripherals = n_peripherals;
+
+	return 0;
+
+err_out:
+	while (--i >= 0) {
+		acpi_dev = &acpi_peripherals[i];
+		if (acpi_dev->properties)
+			property_entries_free(acpi_dev->properties);
+	}
+
+	kfree(acpi_peripherals);
+	return error;
 }
 
 static void chromeos_laptop_destroy(const struct chromeos_laptop *cros_laptop)
 {
+	const struct acpi_peripheral *acpi_dev;
 	struct i2c_peripheral *i2c_dev;
 	struct i2c_board_info *info;
 	int i;
@@ -631,10 +837,41 @@ static void chromeos_laptop_destroy(const struct chromeos_laptop *cros_laptop)
 			property_entries_free(info->properties);
 	}
 
+	for (i = 0; i < cros_laptop->num_acpi_peripherals; i++) {
+		acpi_dev = &cros_laptop->acpi_peripherals[i];
+
+		if (acpi_dev->properties)
+			property_entries_free(acpi_dev->properties);
+	}
+
 	kfree(cros_laptop->i2c_peripherals);
+	kfree(cros_laptop->acpi_peripherals);
 	kfree(cros_laptop);
 }
 
+static struct chromeos_laptop * __init
+chromeos_laptop_prepare(const struct chromeos_laptop *src)
+{
+	struct chromeos_laptop *cros_laptop;
+	int error;
+
+	cros_laptop = kzalloc(sizeof(*cros_laptop), GFP_KERNEL);
+	if (!cros_laptop)
+		return ERR_PTR(-ENOMEM);
+
+	error = chromeos_laptop_prepare_i2c_peripherals(cros_laptop, src);
+	if (!error)
+		error = chromeos_laptop_prepare_acpi_peripherals(cros_laptop,
+								 src);
+
+	if (error) {
+		chromeos_laptop_destroy(cros_laptop);
+		return ERR_PTR(error);
+	}
+
+	return cros_laptop;
+}
+
 static int __init chromeos_laptop_init(void)
 {
 	const struct dmi_system_id *dmi_id;
@@ -652,21 +889,33 @@ static int __init chromeos_laptop_init(void)
 	if (IS_ERR(cros_laptop))
 		return PTR_ERR(cros_laptop);
 
+	if (!cros_laptop->num_i2c_peripherals &&
+	    !cros_laptop->num_acpi_peripherals) {
+		pr_debug("no relevant devices detected\n");
+		error = -ENODEV;
+		goto err_destroy_cros_laptop;
+	}
+
 	error = bus_register_notifier(&i2c_bus_type,
 				      &chromeos_laptop_i2c_notifier);
 	if (error) {
-		pr_err("failed to register i2c bus notifier: %d\n", error);
-		chromeos_laptop_destroy(cros_laptop);
-		return error;
+		pr_err("failed to register i2c bus notifier: %d\n",
+		       error);
+		goto err_destroy_cros_laptop;
 	}
 
 	/*
-	 * Scan adapters that have been registered before we installed
-	 * the notifier to make sure we do not miss any devices.
+	 * Scan adapters that have been registered and clients that have
+	 * been created before we installed the notifier to make sure
+	 * we do not miss any devices.
 	 */
-	i2c_for_each_dev(NULL, chromeos_laptop_scan_adapter);
+	i2c_for_each_dev(NULL, chromeos_laptop_scan_peripherals);
 
 	return 0;
+
+err_destroy_cros_laptop:
+	chromeos_laptop_destroy(cros_laptop);
+	return error;
 }
 
 static void __exit chromeos_laptop_exit(void)

commit c0bb0608ec79f8480432e169ccc3857dc7f7c205
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Mar 20 15:31:37 2018 -0700

    platform/chrome: chromeos_laptop - discard data for unneeded boards
    
    Mark board data as __intconst/__initdata and make a copy of appropriate
    entry once we identified the board we are running on. The rest of the data
    will be discarded once the kernel finished booting (or module finished
    loading).
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Benson Leung <bleung@chromium.org>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index fe83a2a4900e..5c47f451e43b 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -54,13 +54,16 @@ struct i2c_peripheral {
 	struct i2c_client *client;
 };
 
-#define MAX_I2C_PERIPHERALS 4
-
 struct chromeos_laptop {
-	struct i2c_peripheral i2c_peripherals[MAX_I2C_PERIPHERALS];
+	/*
+	 * Note that we can't mark this pointer as const because
+	 * i2c_new_probed_device() changes passed in I2C board info, so.
+	 */
+	struct i2c_peripheral *i2c_peripherals;
+	unsigned int num_i2c_peripherals;
 };
 
-static struct chromeos_laptop *cros_laptop;
+static const struct chromeos_laptop *cros_laptop;
 
 static struct i2c_client *
 chromes_laptop_instantiate_i2c_device(struct i2c_adapter *adapter,
@@ -121,13 +124,9 @@ static void chromeos_laptop_check_adapter(struct i2c_adapter *adapter)
 	struct i2c_peripheral *i2c_dev;
 	int i;
 
-	for (i = 0; i < MAX_I2C_PERIPHERALS; i++) {
+	for (i = 0; i < cros_laptop->num_i2c_peripherals; i++) {
 		i2c_dev = &cros_laptop->i2c_peripherals[i];
 
-		/* No more peripherals */
-		if (!i2c_dev->board_info.addr)
-			break;
-
 		/* Skip devices already created */
 		if (i2c_dev->client)
 			continue;
@@ -154,7 +153,7 @@ static void chromeos_laptop_detach_i2c_client(struct i2c_client *client)
 	struct i2c_peripheral *i2c_dev;
 	int i;
 
-	for (i = 0; i < MAX_I2C_PERIPHERALS; i++) {
+	for (i = 0; i < cros_laptop->num_i2c_peripherals; i++) {
 		i2c_dev = &cros_laptop->i2c_peripherals[i];
 
 		if (i2c_dev->client == client)
@@ -186,41 +185,45 @@ static struct notifier_block chromeos_laptop_i2c_notifier = {
 	.notifier_call = chromeos_laptop_i2c_notifier_call,
 };
 
-static struct chromeos_laptop samsung_series_5_550 = {
-	.i2c_peripherals = {
-		/* Touchpad. */
-		{
-			.board_info	= {
-				I2C_BOARD_INFO("cyapa", CYAPA_TP_I2C_ADDR),
-				.flags		= I2C_CLIENT_WAKE,
-			},
-			.dmi_name	= "trackpad",
-			.type		= I2C_ADAPTER_SMBUS,
+#define DECLARE_CROS_LAPTOP(_name)					\
+static const struct chromeos_laptop _name __initconst = {		\
+	.i2c_peripherals	= _name##_peripherals,			\
+	.num_i2c_peripherals	= ARRAY_SIZE(_name##_peripherals),	\
+}
+
+static struct i2c_peripheral samsung_series_5_550_peripherals[] __initdata = {
+	/* Touchpad. */
+	{
+		.board_info	= {
+			I2C_BOARD_INFO("cyapa", CYAPA_TP_I2C_ADDR),
+			.flags		= I2C_CLIENT_WAKE,
 		},
-		/* Light Sensor. */
-		{
-			.board_info	= {
-				I2C_BOARD_INFO("isl29018", ISL_ALS_I2C_ADDR),
-			},
-			.dmi_name	= "lightsensor",
-			.type		= I2C_ADAPTER_SMBUS,
+		.dmi_name	= "trackpad",
+		.type		= I2C_ADAPTER_SMBUS,
+	},
+	/* Light Sensor. */
+	{
+		.board_info	= {
+			I2C_BOARD_INFO("isl29018", ISL_ALS_I2C_ADDR),
 		},
+		.dmi_name	= "lightsensor",
+		.type		= I2C_ADAPTER_SMBUS,
 	},
 };
+DECLARE_CROS_LAPTOP(samsung_series_5_550);
 
-static struct chromeos_laptop samsung_series_5 = {
-	.i2c_peripherals = {
-		/* Light Sensor. */
-		{
-			.board_info	= {
-				I2C_BOARD_INFO("tsl2583", TAOS_ALS_I2C_ADDR),
-			},
-			.type		= I2C_ADAPTER_SMBUS,
+static struct i2c_peripheral samsung_series_5_peripherals[] __initdata = {
+	/* Light Sensor. */
+	{
+		.board_info	= {
+			I2C_BOARD_INFO("tsl2583", TAOS_ALS_I2C_ADDR),
 		},
+		.type		= I2C_ADAPTER_SMBUS,
 	},
 };
+DECLARE_CROS_LAPTOP(samsung_series_5);
 
-static int chromebook_pixel_tp_keys[] = {
+static const int chromebook_pixel_tp_keys[] __initconst = {
 	KEY_RESERVED,
 	KEY_RESERVED,
 	KEY_RESERVED,
@@ -229,199 +232,192 @@ static int chromebook_pixel_tp_keys[] = {
 	BTN_LEFT
 };
 
-static const struct property_entry chromebook_pixel_trackpad_props[] = {
+static const struct property_entry
+chromebook_pixel_trackpad_props[] __initconst = {
 	PROPERTY_ENTRY_U32_ARRAY("linux,gpio-keymap", chromebook_pixel_tp_keys),
 	{ }
 };
 
-static struct chromeos_laptop chromebook_pixel = {
-	.i2c_peripherals = {
-		/* Touch Screen. */
-		{
-			.board_info	= {
-				I2C_BOARD_INFO("atmel_mxt_ts",
-						ATMEL_TS_I2C_ADDR),
-				.flags		= I2C_CLIENT_WAKE,
-			},
-			.dmi_name	= "touchscreen",
-			.irqflags	= IRQF_TRIGGER_FALLING,
-			.type		= I2C_ADAPTER_PANEL,
-			.alt_addr	= ATMEL_TS_I2C_BL_ADDR,
+static struct i2c_peripheral chromebook_pixel_peripherals[] __initdata = {
+	/* Touch Screen. */
+	{
+		.board_info	= {
+			I2C_BOARD_INFO("atmel_mxt_ts",
+					ATMEL_TS_I2C_ADDR),
+			.flags		= I2C_CLIENT_WAKE,
 		},
-		/* Touchpad. */
-		{
-			.board_info	= {
-				I2C_BOARD_INFO("atmel_mxt_tp",
-						ATMEL_TP_I2C_ADDR),
-				.properties	=
-					chromebook_pixel_trackpad_props,
-				.flags		= I2C_CLIENT_WAKE,
-			},
-			.dmi_name	= "trackpad",
-			.irqflags	= IRQF_TRIGGER_FALLING,
-			.type		= I2C_ADAPTER_VGADDC,
-			.alt_addr	= ATMEL_TP_I2C_BL_ADDR,
+		.dmi_name	= "touchscreen",
+		.irqflags	= IRQF_TRIGGER_FALLING,
+		.type		= I2C_ADAPTER_PANEL,
+		.alt_addr	= ATMEL_TS_I2C_BL_ADDR,
+	},
+	/* Touchpad. */
+	{
+		.board_info	= {
+			I2C_BOARD_INFO("atmel_mxt_tp",
+					ATMEL_TP_I2C_ADDR),
+			.properties	=
+				chromebook_pixel_trackpad_props,
+			.flags		= I2C_CLIENT_WAKE,
 		},
-		/* Light Sensor. */
-		{
-			.board_info	= {
-				I2C_BOARD_INFO("isl29018", ISL_ALS_I2C_ADDR),
-			},
-			.dmi_name	= "lightsensor",
-			.type		= I2C_ADAPTER_PANEL,
+		.dmi_name	= "trackpad",
+		.irqflags	= IRQF_TRIGGER_FALLING,
+		.type		= I2C_ADAPTER_VGADDC,
+		.alt_addr	= ATMEL_TP_I2C_BL_ADDR,
+	},
+	/* Light Sensor. */
+	{
+		.board_info	= {
+			I2C_BOARD_INFO("isl29018", ISL_ALS_I2C_ADDR),
 		},
+		.dmi_name	= "lightsensor",
+		.type		= I2C_ADAPTER_PANEL,
 	},
 };
+DECLARE_CROS_LAPTOP(chromebook_pixel);
 
-static struct chromeos_laptop hp_chromebook_14 = {
-	.i2c_peripherals = {
-		/* Touchpad. */
-		{
-			.board_info	= {
-				I2C_BOARD_INFO("cyapa", CYAPA_TP_I2C_ADDR),
-				.flags		= I2C_CLIENT_WAKE,
-			},
-			.dmi_name	= "trackpad",
-			.type		= I2C_ADAPTER_DESIGNWARE,
+static struct i2c_peripheral hp_chromebook_14_peripherals[] __initdata = {
+	/* Touchpad. */
+	{
+		.board_info	= {
+			I2C_BOARD_INFO("cyapa", CYAPA_TP_I2C_ADDR),
+			.flags		= I2C_CLIENT_WAKE,
 		},
+		.dmi_name	= "trackpad",
+		.type		= I2C_ADAPTER_DESIGNWARE,
 	},
 };
+DECLARE_CROS_LAPTOP(hp_chromebook_14);
 
-static struct chromeos_laptop dell_chromebook_11 = {
-	.i2c_peripherals = {
-		/* Touchpad. */
-		{
-			.board_info	= {
-				I2C_BOARD_INFO("cyapa", CYAPA_TP_I2C_ADDR),
-				.flags		= I2C_CLIENT_WAKE,
-			},
-			.dmi_name	= "trackpad",
-			.type		= I2C_ADAPTER_DESIGNWARE,
+static struct i2c_peripheral dell_chromebook_11_peripherals[] __initdata = {
+	/* Touchpad. */
+	{
+		.board_info	= {
+			I2C_BOARD_INFO("cyapa", CYAPA_TP_I2C_ADDR),
+			.flags		= I2C_CLIENT_WAKE,
 		},
-		/* Elan Touchpad option. */
-		{
-			.board_info	= {
-				I2C_BOARD_INFO("elan_i2c", ELAN_TP_I2C_ADDR),
-				.flags		= I2C_CLIENT_WAKE,
-			},
-			.dmi_name	= "trackpad",
-			.type		= I2C_ADAPTER_DESIGNWARE,
+		.dmi_name	= "trackpad",
+		.type		= I2C_ADAPTER_DESIGNWARE,
+	},
+	/* Elan Touchpad option. */
+	{
+		.board_info	= {
+			I2C_BOARD_INFO("elan_i2c", ELAN_TP_I2C_ADDR),
+			.flags		= I2C_CLIENT_WAKE,
 		},
+		.dmi_name	= "trackpad",
+		.type		= I2C_ADAPTER_DESIGNWARE,
 	},
 };
+DECLARE_CROS_LAPTOP(dell_chromebook_11);
 
-static struct chromeos_laptop toshiba_cb35 = {
-	.i2c_peripherals = {
-		/* Touchpad. */
-		{
-			.board_info	= {
-				I2C_BOARD_INFO("cyapa", CYAPA_TP_I2C_ADDR),
-				.flags		= I2C_CLIENT_WAKE,
-			},
-			.dmi_name	= "trackpad",
-			.type		= I2C_ADAPTER_DESIGNWARE,
+static struct i2c_peripheral toshiba_cb35_peripherals[] __initdata = {
+	/* Touchpad. */
+	{
+		.board_info	= {
+			I2C_BOARD_INFO("cyapa", CYAPA_TP_I2C_ADDR),
+			.flags		= I2C_CLIENT_WAKE,
 		},
+		.dmi_name	= "trackpad",
+		.type		= I2C_ADAPTER_DESIGNWARE,
 	},
 };
+DECLARE_CROS_LAPTOP(toshiba_cb35);
 
-static struct chromeos_laptop acer_c7_chromebook = {
-	.i2c_peripherals = {
-		/* Touchpad. */
-		{
-			.board_info	= {
-				I2C_BOARD_INFO("cyapa", CYAPA_TP_I2C_ADDR),
-				.flags		= I2C_CLIENT_WAKE,
-			},
-			.dmi_name	= "trackpad",
-			.type		= I2C_ADAPTER_SMBUS,
+static struct i2c_peripheral acer_c7_chromebook_peripherals[] __initdata = {
+	/* Touchpad. */
+	{
+		.board_info	= {
+			I2C_BOARD_INFO("cyapa", CYAPA_TP_I2C_ADDR),
+			.flags		= I2C_CLIENT_WAKE,
 		},
+		.dmi_name	= "trackpad",
+		.type		= I2C_ADAPTER_SMBUS,
 	},
 };
+DECLARE_CROS_LAPTOP(acer_c7_chromebook);
 
-static struct chromeos_laptop acer_ac700 = {
-	.i2c_peripherals = {
-		/* Light Sensor. */
-		{
-			.board_info	= {
-				I2C_BOARD_INFO("tsl2583", TAOS_ALS_I2C_ADDR),
-			},
-			.type		= I2C_ADAPTER_SMBUS,
+static struct i2c_peripheral acer_ac700_peripherals[] __initdata = {
+	/* Light Sensor. */
+	{
+		.board_info	= {
+			I2C_BOARD_INFO("tsl2583", TAOS_ALS_I2C_ADDR),
 		},
+		.type		= I2C_ADAPTER_SMBUS,
 	},
 };
+DECLARE_CROS_LAPTOP(acer_ac700);
 
-static struct chromeos_laptop acer_c720 = {
-	.i2c_peripherals = {
-		/* Touchscreen. */
-		{
-			.board_info	= {
-				I2C_BOARD_INFO("atmel_mxt_ts",
-						ATMEL_TS_I2C_ADDR),
-				.flags		= I2C_CLIENT_WAKE,
-			},
-			.dmi_name	= "touchscreen",
-			.irqflags	= IRQF_TRIGGER_FALLING,
-			.type		= I2C_ADAPTER_DESIGNWARE,
-			.pci_devid	= PCI_DEVID(0, PCI_DEVFN(0x15, 0x2)),
-			.alt_addr	= ATMEL_TS_I2C_BL_ADDR,
+static struct i2c_peripheral acer_c720_peripherals[] __initdata = {
+	/* Touchscreen. */
+	{
+		.board_info	= {
+			I2C_BOARD_INFO("atmel_mxt_ts",
+					ATMEL_TS_I2C_ADDR),
+			.flags		= I2C_CLIENT_WAKE,
 		},
-		/* Touchpad. */
-		{
-			.board_info	= {
-				I2C_BOARD_INFO("cyapa", CYAPA_TP_I2C_ADDR),
-				.flags		= I2C_CLIENT_WAKE,
-			},
-			.dmi_name	= "trackpad",
-			.type		= I2C_ADAPTER_DESIGNWARE,
-			.pci_devid	= PCI_DEVID(0, PCI_DEVFN(0x15, 0x1)),
+		.dmi_name	= "touchscreen",
+		.irqflags	= IRQF_TRIGGER_FALLING,
+		.type		= I2C_ADAPTER_DESIGNWARE,
+		.pci_devid	= PCI_DEVID(0, PCI_DEVFN(0x15, 0x2)),
+		.alt_addr	= ATMEL_TS_I2C_BL_ADDR,
+	},
+	/* Touchpad. */
+	{
+		.board_info	= {
+			I2C_BOARD_INFO("cyapa", CYAPA_TP_I2C_ADDR),
+			.flags		= I2C_CLIENT_WAKE,
 		},
-		/* Elan Touchpad option. */
-		{
-			.board_info	= {
-				I2C_BOARD_INFO("elan_i2c", ELAN_TP_I2C_ADDR),
-				.flags		= I2C_CLIENT_WAKE,
-			},
-			.dmi_name	= "trackpad",
-			.type		= I2C_ADAPTER_DESIGNWARE,
-			.pci_devid	= PCI_DEVID(0, PCI_DEVFN(0x15, 0x1)),
+		.dmi_name	= "trackpad",
+		.type		= I2C_ADAPTER_DESIGNWARE,
+		.pci_devid	= PCI_DEVID(0, PCI_DEVFN(0x15, 0x1)),
+	},
+	/* Elan Touchpad option. */
+	{
+		.board_info	= {
+			I2C_BOARD_INFO("elan_i2c", ELAN_TP_I2C_ADDR),
+			.flags		= I2C_CLIENT_WAKE,
 		},
-		/* Light Sensor. */
-		{
-			.board_info	= {
-				I2C_BOARD_INFO("isl29018", ISL_ALS_I2C_ADDR),
-			},
-			.dmi_name	= "lightsensor",
-			.type		= I2C_ADAPTER_DESIGNWARE,
-			.pci_devid	= PCI_DEVID(0, PCI_DEVFN(0x15, 0x2)),
+		.dmi_name	= "trackpad",
+		.type		= I2C_ADAPTER_DESIGNWARE,
+		.pci_devid	= PCI_DEVID(0, PCI_DEVFN(0x15, 0x1)),
+	},
+	/* Light Sensor. */
+	{
+		.board_info	= {
+			I2C_BOARD_INFO("isl29018", ISL_ALS_I2C_ADDR),
 		},
+		.dmi_name	= "lightsensor",
+		.type		= I2C_ADAPTER_DESIGNWARE,
+		.pci_devid	= PCI_DEVID(0, PCI_DEVFN(0x15, 0x2)),
 	},
 };
+DECLARE_CROS_LAPTOP(acer_c720);
 
-static struct chromeos_laptop hp_pavilion_14_chromebook = {
-	.i2c_peripherals = {
-		/* Touchpad. */
-		{
-			.board_info	= {
-				I2C_BOARD_INFO("cyapa", CYAPA_TP_I2C_ADDR),
-				.flags		= I2C_CLIENT_WAKE,
-			},
-			.dmi_name	= "trackpad",
-			.type		= I2C_ADAPTER_SMBUS,
+static struct i2c_peripheral
+hp_pavilion_14_chromebook_peripherals[] __initdata = {
+	/* Touchpad. */
+	{
+		.board_info	= {
+			I2C_BOARD_INFO("cyapa", CYAPA_TP_I2C_ADDR),
+			.flags		= I2C_CLIENT_WAKE,
 		},
+		.dmi_name	= "trackpad",
+		.type		= I2C_ADAPTER_SMBUS,
 	},
 };
+DECLARE_CROS_LAPTOP(hp_pavilion_14_chromebook);
 
-static struct chromeos_laptop cr48 = {
-	.i2c_peripherals = {
-		/* Light Sensor. */
-		{
-			.board_info	= {
-				I2C_BOARD_INFO("tsl2563", TAOS_ALS_I2C_ADDR),
-			},
-			.type		= I2C_ADAPTER_SMBUS,
+static struct i2c_peripheral cr48_peripherals[] __initdata = {
+	/* Light Sensor. */
+	{
+		.board_info	= {
+			I2C_BOARD_INFO("tsl2563", TAOS_ALS_I2C_ADDR),
 		},
+		.type		= I2C_ADAPTER_SMBUS,
 	},
 };
+DECLARE_CROS_LAPTOP(cr48);
 
 static const struct dmi_system_id chromeos_laptop_dmi_table[] __initconst = {
 	{
@@ -541,24 +537,14 @@ static int __init chromeos_laptop_get_irq_from_dmi(const char *dmi_name)
 	return dev_data->instance;
 }
 
-static struct chromeos_laptop * __init
-chromeos_laptop_prepare(const struct dmi_system_id *id)
+static int __init chromeos_laptop_setup_irq(struct i2c_peripheral *i2c_dev)
 {
-	struct i2c_peripheral *i2c_dev;
 	int irq;
-	int i;
-
-	cros_laptop = (void *)id->driver_data;
-
-	for (i = 0; i < MAX_I2C_PERIPHERALS; i++) {
-		i2c_dev = &cros_laptop->i2c_peripherals[i];
-
-		if (!i2c_dev->dmi_name)
-			continue;
 
+	if (i2c_dev->dmi_name) {
 		irq = chromeos_laptop_get_irq_from_dmi(i2c_dev->dmi_name);
 		if (irq < 0)
-			return ERR_PTR(irq);
+			return irq;
 
 		i2c_dev->irq_resource  = (struct resource)
 			DEFINE_RES_NAMED(irq, 1, NULL,
@@ -567,9 +553,87 @@ chromeos_laptop_prepare(const struct dmi_system_id *id)
 		i2c_dev->board_info.num_resources = 1;
 	}
 
+	return 0;
+}
+
+static struct chromeos_laptop * __init
+chromeos_laptop_prepare(const struct chromeos_laptop *src)
+{
+	struct chromeos_laptop *cros_laptop;
+	struct i2c_peripheral *i2c_dev;
+	struct i2c_board_info *info;
+	int error;
+	int i;
+
+	cros_laptop = kzalloc(sizeof(*cros_laptop), GFP_KERNEL);
+	if (!cros_laptop)
+		return ERR_PTR(-ENOMEM);
+
+	cros_laptop->i2c_peripherals = kmemdup(src->i2c_peripherals,
+					       src->num_i2c_peripherals *
+						sizeof(*src->i2c_peripherals),
+					       GFP_KERNEL);
+	if (!cros_laptop->i2c_peripherals) {
+		error = -ENOMEM;
+		goto err_free_cros_laptop;
+	}
+
+	cros_laptop->num_i2c_peripherals = src->num_i2c_peripherals;
+
+	for (i = 0; i < cros_laptop->num_i2c_peripherals; i++) {
+		i2c_dev = &cros_laptop->i2c_peripherals[i];
+		info = &i2c_dev->board_info;
+
+		error = chromeos_laptop_setup_irq(i2c_dev);
+		if (error)
+			goto err_destroy_cros_peripherals;
+
+		/* We need to deep-copy properties */
+		if (info->properties) {
+			info->properties =
+				property_entries_dup(info->properties);
+			if (IS_ERR(info->properties)) {
+				error = PTR_ERR(info->properties);
+				goto err_destroy_cros_peripherals;
+			}
+		}
+	}
+
 	return cros_laptop;
+
+err_destroy_cros_peripherals:
+	while (--i >= 0) {
+		i2c_dev = &cros_laptop->i2c_peripherals[i];
+		info = &i2c_dev->board_info;
+		if (info->properties)
+			property_entries_free(info->properties);
+	}
+	kfree(cros_laptop->i2c_peripherals);
+err_free_cros_laptop:
+	kfree(cros_laptop);
+	return ERR_PTR(error);
 }
 
+static void chromeos_laptop_destroy(const struct chromeos_laptop *cros_laptop)
+{
+	struct i2c_peripheral *i2c_dev;
+	struct i2c_board_info *info;
+	int i;
+
+	for (i = 0; i < cros_laptop->num_i2c_peripherals; i++) {
+		i2c_dev = &cros_laptop->i2c_peripherals[i];
+		info = &i2c_dev->board_info;
+
+		if (i2c_dev->client)
+			i2c_unregister_device(i2c_dev->client);
+
+		if (info->properties)
+			property_entries_free(info->properties);
+	}
+
+	kfree(cros_laptop->i2c_peripherals);
+	kfree(cros_laptop);
+}
 
 static int __init chromeos_laptop_init(void)
 {
@@ -584,7 +648,7 @@ static int __init chromeos_laptop_init(void)
 
 	pr_debug("DMI Matched %s\n", dmi_id->ident);
 
-	cros_laptop = chromeos_laptop_prepare(dmi_id->driver_data);
+	cros_laptop = chromeos_laptop_prepare((void *)dmi_id->driver_data);
 	if (IS_ERR(cros_laptop))
 		return PTR_ERR(cros_laptop);
 
@@ -592,6 +656,7 @@ static int __init chromeos_laptop_init(void)
 				      &chromeos_laptop_i2c_notifier);
 	if (error) {
 		pr_err("failed to register i2c bus notifier: %d\n", error);
+		chromeos_laptop_destroy(cros_laptop);
 		return error;
 	}
 
@@ -606,21 +671,8 @@ static int __init chromeos_laptop_init(void)
 
 static void __exit chromeos_laptop_exit(void)
 {
-	struct i2c_peripheral *i2c_dev;
-	int i;
-
 	bus_unregister_notifier(&i2c_bus_type, &chromeos_laptop_i2c_notifier);
-
-	for (i = 0; i < MAX_I2C_PERIPHERALS; i++) {
-		i2c_dev = &cros_laptop->i2c_peripherals[i];
-
-		/* No more peripherals */
-		if (!i2c_dev->board_info.type)
-			break;
-
-		if (i2c_dev->client)
-			i2c_unregister_device(i2c_dev->client);
-	}
+	chromeos_laptop_destroy(cros_laptop);
 }
 
 module_init(chromeos_laptop_init);

commit f00c1d199e05f4f633a3ae34f16f707257d56fcf
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Mar 20 15:31:36 2018 -0700

    platform/chrome: chromeos_laptop - use device properties for Pixel
    
    Now that Atmel driver uses generic device properties we can use them
    instead of platform data when setting up touchpad on the original
    Google Pixel.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Benson Leung <bleung@chromium.org>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 1191c1a3a0cd..fe83a2a4900e 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -8,13 +8,13 @@
 
 #include <linux/dmi.h>
 #include <linux/i2c.h>
-#include <linux/platform_data/atmel_mxt_ts.h>
 #include <linux/input.h>
 #include <linux/interrupt.h>
 #include <linux/ioport.h>
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/platform_device.h>
+#include <linux/property.h>
 
 #define ATMEL_TP_I2C_ADDR	0x4b
 #define ATMEL_TP_I2C_BL_ADDR	0x25
@@ -229,9 +229,9 @@ static int chromebook_pixel_tp_keys[] = {
 	BTN_LEFT
 };
 
-static struct mxt_platform_data chromebook_pixel_tp_platform_data = {
-	.t19_num_keys		= ARRAY_SIZE(chromebook_pixel_tp_keys),
-	.t19_keymap		= chromebook_pixel_tp_keys,
+static const struct property_entry chromebook_pixel_trackpad_props[] = {
+	PROPERTY_ENTRY_U32_ARRAY("linux,gpio-keymap", chromebook_pixel_tp_keys),
+	{ }
 };
 
 static struct chromeos_laptop chromebook_pixel = {
@@ -253,8 +253,8 @@ static struct chromeos_laptop chromebook_pixel = {
 			.board_info	= {
 				I2C_BOARD_INFO("atmel_mxt_tp",
 						ATMEL_TP_I2C_ADDR),
-				.platform_data	=
-					&chromebook_pixel_tp_platform_data,
+				.properties	=
+					chromebook_pixel_trackpad_props,
 				.flags		= I2C_CLIENT_WAKE,
 			},
 			.dmi_name	= "trackpad",

commit e6215eeaa23c5d80a72caa91fc80795b9cde038f
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Mar 20 15:31:35 2018 -0700

    platform/chrome: chromeos_laptop - rely on I2C to set up interrupt trigger
    
    Instead of passing interrupt flags via platform data to drivers, or
    hoping that drivers will do the right thing and set it up the way we
    need, let's set up IRQ resource and attach it to the I2C board info, and
    let I2C core set it up for us.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Benson Leung <bleung@chromium.org>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index e5015dfaa81e..1191c1a3a0cd 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -11,6 +11,7 @@
 #include <linux/platform_data/atmel_mxt_ts.h>
 #include <linux/input.h>
 #include <linux/interrupt.h>
+#include <linux/ioport.h>
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/platform_device.h>
@@ -42,7 +43,11 @@ enum i2c_adapter_type {
 struct i2c_peripheral {
 	struct i2c_board_info board_info;
 	unsigned short alt_addr;
+
 	const char *dmi_name;
+	unsigned long irqflags;
+	struct resource irq_resource;
+
 	enum i2c_adapter_type type;
 	u32 pci_devid;
 
@@ -215,10 +220,6 @@ static struct chromeos_laptop samsung_series_5 = {
 	},
 };
 
-static struct mxt_platform_data atmel_1664s_platform_data = {
-	.irqflags		= IRQF_TRIGGER_FALLING,
-};
-
 static int chromebook_pixel_tp_keys[] = {
 	KEY_RESERVED,
 	KEY_RESERVED,
@@ -229,7 +230,6 @@ static int chromebook_pixel_tp_keys[] = {
 };
 
 static struct mxt_platform_data chromebook_pixel_tp_platform_data = {
-	.irqflags		= IRQF_TRIGGER_FALLING,
 	.t19_num_keys		= ARRAY_SIZE(chromebook_pixel_tp_keys),
 	.t19_keymap		= chromebook_pixel_tp_keys,
 };
@@ -241,10 +241,10 @@ static struct chromeos_laptop chromebook_pixel = {
 			.board_info	= {
 				I2C_BOARD_INFO("atmel_mxt_ts",
 						ATMEL_TS_I2C_ADDR),
-				.platform_data	= &atmel_1664s_platform_data,
 				.flags		= I2C_CLIENT_WAKE,
 			},
 			.dmi_name	= "touchscreen",
+			.irqflags	= IRQF_TRIGGER_FALLING,
 			.type		= I2C_ADAPTER_PANEL,
 			.alt_addr	= ATMEL_TS_I2C_BL_ADDR,
 		},
@@ -258,6 +258,7 @@ static struct chromeos_laptop chromebook_pixel = {
 				.flags		= I2C_CLIENT_WAKE,
 			},
 			.dmi_name	= "trackpad",
+			.irqflags	= IRQF_TRIGGER_FALLING,
 			.type		= I2C_ADAPTER_VGADDC,
 			.alt_addr	= ATMEL_TP_I2C_BL_ADDR,
 		},
@@ -356,10 +357,10 @@ static struct chromeos_laptop acer_c720 = {
 			.board_info	= {
 				I2C_BOARD_INFO("atmel_mxt_ts",
 						ATMEL_TS_I2C_ADDR),
-				.platform_data	= &atmel_1664s_platform_data,
 				.flags		= I2C_CLIENT_WAKE,
 			},
 			.dmi_name	= "touchscreen",
+			.irqflags	= IRQF_TRIGGER_FALLING,
 			.type		= I2C_ADAPTER_DESIGNWARE,
 			.pci_devid	= PCI_DEVID(0, PCI_DEVFN(0x15, 0x2)),
 			.alt_addr	= ATMEL_TS_I2C_BL_ADDR,
@@ -558,6 +559,12 @@ chromeos_laptop_prepare(const struct dmi_system_id *id)
 		irq = chromeos_laptop_get_irq_from_dmi(i2c_dev->dmi_name);
 		if (irq < 0)
 			return ERR_PTR(irq);
+
+		i2c_dev->irq_resource  = (struct resource)
+			DEFINE_RES_NAMED(irq, 1, NULL,
+					 IORESOURCE_IRQ | i2c_dev->irqflags);
+		i2c_dev->board_info.resources = &i2c_dev->irq_resource;
+		i2c_dev->board_info.num_resources = 1;
 	}
 
 	return cros_laptop;

commit 8d88cb03c22e4cbde4c3020883f534e8ba7f5c79
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Mar 20 15:31:34 2018 -0700

    platform/chrome: chromeos_laptop - use I2C notifier to create devices
    
    Instead of using platform device and deferrals to handle the case when i2C
    adapters appear late in the game, and not handling device unbinding all
    that well, let's switch to using I2C bus notifier to get told when a new
    I2C adapter appears in the system, and attempt to add appropriate devices
    at that time.
    
    In case when we have 2 Designware adapters in the system (Acer C720),
    instead of counting and hoping they get enumerate din the right order,
    let's switch to using their PCI devids (slot/function) that should be
    stable.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Benson Leung <bleung@chromium.org>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index d6d2bc6f3aaf..e5015dfaa81e 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -12,6 +12,7 @@
 #include <linux/input.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
+#include <linux/pci.h>
 #include <linux/platform_device.h>
 
 #define ATMEL_TP_I2C_ADDR	0x4b
@@ -23,14 +24,11 @@
 #define ISL_ALS_I2C_ADDR	0x44
 #define TAOS_ALS_I2C_ADDR	0x29
 
-#define MAX_I2C_DEVICE_DEFERRALS	5
-
 static const char *i2c_adapter_names[] = {
 	"SMBus I801 adapter",
 	"i915 gmbus vga",
 	"i915 gmbus panel",
 	"Synopsys DesignWare I2C adapter",
-	"Synopsys DesignWare I2C adapter",
 };
 
 /* Keep this enum consistent with i2c_adapter_names */
@@ -38,15 +36,7 @@ enum i2c_adapter_type {
 	I2C_ADAPTER_SMBUS = 0,
 	I2C_ADAPTER_VGADDC,
 	I2C_ADAPTER_PANEL,
-	I2C_ADAPTER_DESIGNWARE_0,
-	I2C_ADAPTER_DESIGNWARE_1,
-};
-
-enum i2c_peripheral_state {
-	UNPROBED = 0,
-	PROBED,
-	TIMEDOUT,
-	FAILED,
+	I2C_ADAPTER_DESIGNWARE,
 };
 
 struct i2c_peripheral {
@@ -54,10 +44,9 @@ struct i2c_peripheral {
 	unsigned short alt_addr;
 	const char *dmi_name;
 	enum i2c_adapter_type type;
+	u32 pci_devid;
 
-	enum i2c_peripheral_state state;
 	struct i2c_client *client;
-	int tries;
 };
 
 #define MAX_I2C_PERIPHERALS 4
@@ -69,19 +58,12 @@ struct chromeos_laptop {
 static struct chromeos_laptop *cros_laptop;
 
 static struct i2c_client *
-chromes_laptop_instantiate_i2c_device(int bus,
+chromes_laptop_instantiate_i2c_device(struct i2c_adapter *adapter,
 				      struct i2c_board_info *info,
 				      unsigned short alt_addr)
 {
-	struct i2c_adapter *adapter;
-	struct i2c_client *client = NULL;
 	const unsigned short addr_list[] = { info->addr, I2C_CLIENT_END };
-
-	adapter = i2c_get_adapter(bus);
-	if (!adapter) {
-		pr_err("failed to get i2c adapter %d\n", bus);
-		return NULL;
-	}
+	struct i2c_client *client;
 
 	/*
 	 * Add the i2c device. If we can't detect it at the primary
@@ -102,126 +84,103 @@ chromes_laptop_instantiate_i2c_device(int bus,
 					      alt_addr_list, NULL);
 		if (dummy) {
 			pr_debug("%d-%02x is probed at %02x\n",
-				 bus, info->addr, dummy->addr);
+				 adapter->nr, info->addr, dummy->addr);
 			i2c_unregister_device(dummy);
 			client = i2c_new_device(adapter, info);
 		}
 	}
 
 	if (!client)
-		pr_notice("failed to register device %d-%02x\n",
-			  bus, info->addr);
+		pr_debug("failed to register device %d-%02x\n",
+			 adapter->nr, info->addr);
 	else
-		pr_debug("added i2c device %d-%02x\n", bus, info->addr);
+		pr_debug("added i2c device %d-%02x\n",
+			 adapter->nr, info->addr);
 
-	i2c_put_adapter(adapter);
 	return client;
 }
 
-struct i2c_lookup {
-	const char *name;
-	int instance;
-	int n;
-};
-
-static int __find_i2c_adap(struct device *dev, void *data)
+static bool chromeos_laptop_match_adapter_devid(struct device *dev, u32 devid)
 {
-	struct i2c_lookup *lookup = data;
-	static const char *prefix = "i2c-";
-	struct i2c_adapter *adapter;
+	struct pci_dev *pdev;
 
-	if (strncmp(dev_name(dev), prefix, strlen(prefix)) != 0)
-		return 0;
-	adapter = to_i2c_adapter(dev);
-	if (strncmp(adapter->name, lookup->name, strlen(lookup->name)) == 0 &&
-	    lookup->n++ == lookup->instance)
-		return 1;
-	return 0;
-}
+	if (!dev_is_pci(dev))
+		return false;
 
-static int find_i2c_adapter_num(enum i2c_adapter_type type)
-{
-	struct device *dev = NULL;
-	struct i2c_adapter *adapter;
-	struct i2c_lookup lookup;
-
-	memset(&lookup, 0, sizeof(lookup));
-	lookup.name = i2c_adapter_names[type];
-	lookup.instance = (type == I2C_ADAPTER_DESIGNWARE_1) ? 1 : 0;
-
-	/* find the adapter by name */
-	dev = bus_find_device(&i2c_bus_type, NULL, &lookup, __find_i2c_adap);
-	if (!dev) {
-		/* Adapters may appear later. Deferred probing will retry */
-		pr_notice("i2c adapter %s not found on system.\n",
-			  lookup.name);
-		return -ENODEV;
-	}
-	adapter = to_i2c_adapter(dev);
-	return adapter->nr;
+	pdev = to_pci_dev(dev);
+	return devid == PCI_DEVID(pdev->bus->number, pdev->devfn);
 }
 
-static int chromeos_laptop_add_peripheral(struct i2c_peripheral *i2c_dev)
+static void chromeos_laptop_check_adapter(struct i2c_adapter *adapter)
 {
-	struct i2c_client *client;
-	int bus;
+	struct i2c_peripheral *i2c_dev;
+	int i;
 
-	/*
-	 * Check that the i2c adapter is present.
-	 * -EPROBE_DEFER if missing as the adapter may appear much
-	 * later.
-	 */
-	bus = find_i2c_adapter_num(i2c_dev->type);
-	if (bus < 0)
-		return bus == -ENODEV ? -EPROBE_DEFER : bus;
-
-	client = chromes_laptop_instantiate_i2c_device(bus,
-						       &i2c_dev->board_info,
-						       i2c_dev->alt_addr);
-	if (!client) {
-		/*
-		 * Set -EPROBE_DEFER a limited num of times
-		 * if device is not successfully added.
-		 */
-		if (++i2c_dev->tries < MAX_I2C_DEVICE_DEFERRALS) {
-			return -EPROBE_DEFER;
-		} else {
-			/* Ran out of tries. */
-			pr_notice("ran out of tries for device.\n");
-			i2c_dev->state = TIMEDOUT;
-			return -EIO;
-		}
-	}
+	for (i = 0; i < MAX_I2C_PERIPHERALS; i++) {
+		i2c_dev = &cros_laptop->i2c_peripherals[i];
 
-	i2c_dev->client = client;
-	i2c_dev->state = PROBED;
+		/* No more peripherals */
+		if (!i2c_dev->board_info.addr)
+			break;
 
-	return 0;
+		/* Skip devices already created */
+		if (i2c_dev->client)
+			continue;
+
+		if (strncmp(adapter->name, i2c_adapter_names[i2c_dev->type],
+			    strlen(i2c_adapter_names[i2c_dev->type])))
+			continue;
+
+		if (i2c_dev->pci_devid &&
+		    !chromeos_laptop_match_adapter_devid(adapter->dev.parent,
+							 i2c_dev->pci_devid)) {
+			continue;
+		}
+
+		i2c_dev->client =
+			chromes_laptop_instantiate_i2c_device(adapter,
+							&i2c_dev->board_info,
+							i2c_dev->alt_addr);
+	}
 }
 
-static int chromeos_laptop_probe(struct platform_device *pdev)
+static void chromeos_laptop_detach_i2c_client(struct i2c_client *client)
 {
 	struct i2c_peripheral *i2c_dev;
 	int i;
-	int ret = 0;
 
 	for (i = 0; i < MAX_I2C_PERIPHERALS; i++) {
 		i2c_dev = &cros_laptop->i2c_peripherals[i];
 
-		/* No more peripherals. */
-		if (!i2c_dev->board_info.addr)
-			break;
-
-		if (i2c_dev->state != UNPROBED)
-			continue;
+		if (i2c_dev->client == client)
+			i2c_dev->client = NULL;
+	}
+}
 
-		if (chromeos_laptop_add_peripheral(i2c_dev) == -EPROBE_DEFER)
-			ret = -EPROBE_DEFER;
+static int chromeos_laptop_i2c_notifier_call(struct notifier_block *nb,
+					     unsigned long action, void *data)
+{
+	struct device *dev = data;
+
+	switch (action) {
+	case BUS_NOTIFY_ADD_DEVICE:
+		if (dev->type == &i2c_adapter_type)
+			chromeos_laptop_check_adapter(to_i2c_adapter(dev));
+		break;
+
+	case BUS_NOTIFY_REMOVED_DEVICE:
+		if (dev->type == &i2c_client_type)
+			chromeos_laptop_detach_i2c_client(to_i2c_client(dev));
+		break;
 	}
 
-	return ret;
+	return 0;
 }
 
+static struct notifier_block chromeos_laptop_i2c_notifier = {
+	.notifier_call = chromeos_laptop_i2c_notifier_call,
+};
+
 static struct chromeos_laptop samsung_series_5_550 = {
 	.i2c_peripherals = {
 		/* Touchpad. */
@@ -322,7 +281,7 @@ static struct chromeos_laptop hp_chromebook_14 = {
 				.flags		= I2C_CLIENT_WAKE,
 			},
 			.dmi_name	= "trackpad",
-			.type		= I2C_ADAPTER_DESIGNWARE_0,
+			.type		= I2C_ADAPTER_DESIGNWARE,
 		},
 	},
 };
@@ -336,7 +295,7 @@ static struct chromeos_laptop dell_chromebook_11 = {
 				.flags		= I2C_CLIENT_WAKE,
 			},
 			.dmi_name	= "trackpad",
-			.type		= I2C_ADAPTER_DESIGNWARE_0,
+			.type		= I2C_ADAPTER_DESIGNWARE,
 		},
 		/* Elan Touchpad option. */
 		{
@@ -345,7 +304,7 @@ static struct chromeos_laptop dell_chromebook_11 = {
 				.flags		= I2C_CLIENT_WAKE,
 			},
 			.dmi_name	= "trackpad",
-			.type		= I2C_ADAPTER_DESIGNWARE_0,
+			.type		= I2C_ADAPTER_DESIGNWARE,
 		},
 	},
 };
@@ -359,7 +318,7 @@ static struct chromeos_laptop toshiba_cb35 = {
 				.flags		= I2C_CLIENT_WAKE,
 			},
 			.dmi_name	= "trackpad",
-			.type		= I2C_ADAPTER_DESIGNWARE_0,
+			.type		= I2C_ADAPTER_DESIGNWARE,
 		},
 	},
 };
@@ -401,7 +360,8 @@ static struct chromeos_laptop acer_c720 = {
 				.flags		= I2C_CLIENT_WAKE,
 			},
 			.dmi_name	= "touchscreen",
-			.type		= I2C_ADAPTER_DESIGNWARE_1,
+			.type		= I2C_ADAPTER_DESIGNWARE,
+			.pci_devid	= PCI_DEVID(0, PCI_DEVFN(0x15, 0x2)),
 			.alt_addr	= ATMEL_TS_I2C_BL_ADDR,
 		},
 		/* Touchpad. */
@@ -411,7 +371,8 @@ static struct chromeos_laptop acer_c720 = {
 				.flags		= I2C_CLIENT_WAKE,
 			},
 			.dmi_name	= "trackpad",
-			.type		= I2C_ADAPTER_DESIGNWARE_0,
+			.type		= I2C_ADAPTER_DESIGNWARE,
+			.pci_devid	= PCI_DEVID(0, PCI_DEVFN(0x15, 0x1)),
 		},
 		/* Elan Touchpad option. */
 		{
@@ -420,7 +381,8 @@ static struct chromeos_laptop acer_c720 = {
 				.flags		= I2C_CLIENT_WAKE,
 			},
 			.dmi_name	= "trackpad",
-			.type		= I2C_ADAPTER_DESIGNWARE_0,
+			.type		= I2C_ADAPTER_DESIGNWARE,
+			.pci_devid	= PCI_DEVID(0, PCI_DEVFN(0x15, 0x1)),
 		},
 		/* Light Sensor. */
 		{
@@ -428,7 +390,8 @@ static struct chromeos_laptop acer_c720 = {
 				I2C_BOARD_INFO("isl29018", ISL_ALS_I2C_ADDR),
 			},
 			.dmi_name	= "lightsensor",
-			.type		= I2C_ADAPTER_DESIGNWARE_1,
+			.type		= I2C_ADAPTER_DESIGNWARE,
+			.pci_devid	= PCI_DEVID(0, PCI_DEVFN(0x15, 0x2)),
 		},
 	},
 };
@@ -546,14 +509,16 @@ static const struct dmi_system_id chromeos_laptop_dmi_table[] __initconst = {
 };
 MODULE_DEVICE_TABLE(dmi, chromeos_laptop_dmi_table);
 
-static struct platform_device *cros_platform_device;
+static int __init chromeos_laptop_scan_adapter(struct device *dev, void *data)
+{
+	struct i2c_adapter *adapter;
 
-static struct platform_driver cros_platform_driver = {
-	.driver = {
-		.name = "chromeos_laptop",
-	},
-	.probe = chromeos_laptop_probe,
-};
+	adapter = i2c_verify_adapter(dev);
+	if (adapter)
+		chromeos_laptop_check_adapter(adapter);
+
+	return 0;
+}
 
 static int __init chromeos_laptop_get_irq_from_dmi(const char *dmi_name)
 {
@@ -602,7 +567,7 @@ chromeos_laptop_prepare(const struct dmi_system_id *id)
 static int __init chromeos_laptop_init(void)
 {
 	const struct dmi_system_id *dmi_id;
-	int ret;
+	int error;
 
 	dmi_id = dmi_first_match(chromeos_laptop_dmi_table);
 	if (!dmi_id) {
@@ -616,27 +581,20 @@ static int __init chromeos_laptop_init(void)
 	if (IS_ERR(cros_laptop))
 		return PTR_ERR(cros_laptop);
 
-	ret = platform_driver_register(&cros_platform_driver);
-	if (ret)
-		return ret;
-
-	cros_platform_device = platform_device_alloc("chromeos_laptop", -1);
-	if (!cros_platform_device) {
-		ret = -ENOMEM;
-		goto fail_platform_device1;
+	error = bus_register_notifier(&i2c_bus_type,
+				      &chromeos_laptop_i2c_notifier);
+	if (error) {
+		pr_err("failed to register i2c bus notifier: %d\n", error);
+		return error;
 	}
 
-	ret = platform_device_add(cros_platform_device);
-	if (ret)
-		goto fail_platform_device2;
+	/*
+	 * Scan adapters that have been registered before we installed
+	 * the notifier to make sure we do not miss any devices.
+	 */
+	i2c_for_each_dev(NULL, chromeos_laptop_scan_adapter);
 
 	return 0;
-
-fail_platform_device2:
-	platform_device_put(cros_platform_device);
-fail_platform_device1:
-	platform_driver_unregister(&cros_platform_driver);
-	return ret;
 }
 
 static void __exit chromeos_laptop_exit(void)
@@ -644,8 +602,7 @@ static void __exit chromeos_laptop_exit(void)
 	struct i2c_peripheral *i2c_dev;
 	int i;
 
-	platform_device_unregister(cros_platform_device);
-	platform_driver_unregister(&cros_platform_driver);
+	bus_unregister_notifier(&i2c_bus_type, &chromeos_laptop_i2c_notifier);
 
 	for (i = 0; i < MAX_I2C_PERIPHERALS; i++) {
 		i2c_dev = &cros_laptop->i2c_peripherals[i];
@@ -654,7 +611,7 @@ static void __exit chromeos_laptop_exit(void)
 		if (!i2c_dev->board_info.type)
 			break;
 
-		if (i2c_dev->state == PROBED)
+		if (i2c_dev->client)
 			i2c_unregister_device(i2c_dev->client);
 	}
 }

commit 65582920d72d2562e44c07aa530586a3583477b9
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Mar 20 15:31:33 2018 -0700

    platform/chrome: chromeos_laptop - parse DMI IRQ data once
    
    Instead of trying to parse DMI IRQ data every time we try to instantiate a
    device, let's do it once, when we identify the device we are working with.
    This allows us to mark chromeos_laptop_get_irq_from_dmi() as __init and
    discard it once module is initialized.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Benson Leung <bleung@chromium.org>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 2a81ae4c15c9..d6d2bc6f3aaf 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -68,26 +68,6 @@ struct chromeos_laptop {
 
 static struct chromeos_laptop *cros_laptop;
 
-static int chromeos_laptop_get_irq_from_dmi(const char *dmi_name)
-{
-	const struct dmi_device *dmi_dev;
-	const struct dmi_dev_onboard *dev_data;
-
-	dmi_dev = dmi_find_device(DMI_DEV_TYPE_DEV_ONBOARD, dmi_name, NULL);
-	if (!dmi_dev) {
-		pr_err("failed to find DMI device '%s'\n", dmi_name);
-		return -ENOENT;
-	}
-
-	dev_data = dmi_dev->device_data;
-	if (!dev_data) {
-		pr_err("failed to get data from DMI for '%s'\n", dmi_name);
-		return -EINVAL;
-	}
-
-	return dev_data->instance;
-}
-
 static struct i2c_client *
 chromes_laptop_instantiate_i2c_device(int bus,
 				      struct i2c_board_info *info,
@@ -185,7 +165,6 @@ static int chromeos_laptop_add_peripheral(struct i2c_peripheral *i2c_dev)
 {
 	struct i2c_client *client;
 	int bus;
-	int irq;
 
 	/*
 	 * Check that the i2c adapter is present.
@@ -196,16 +175,6 @@ static int chromeos_laptop_add_peripheral(struct i2c_peripheral *i2c_dev)
 	if (bus < 0)
 		return bus == -ENODEV ? -EPROBE_DEFER : bus;
 
-	if (i2c_dev->dmi_name) {
-		irq = chromeos_laptop_get_irq_from_dmi(i2c_dev->dmi_name);
-		if (irq < 0) {
-			i2c_dev->state = FAILED;
-			return irq;
-		}
-
-		i2c_dev->board_info.irq = irq;
-	}
-
 	client = chromes_laptop_instantiate_i2c_device(bus,
 						       &i2c_dev->board_info,
 						       i2c_dev->alt_addr);
@@ -230,15 +199,6 @@ static int chromeos_laptop_add_peripheral(struct i2c_peripheral *i2c_dev)
 	return 0;
 }
 
-static int __init chromeos_laptop_dmi_matched(const struct dmi_system_id *id)
-{
-	cros_laptop = (void *)id->driver_data;
-	pr_debug("DMI Matched %s\n", id->ident);
-
-	/* Indicate to dmi_scan that processing is done. */
-	return 1;
-}
-
 static int chromeos_laptop_probe(struct platform_device *pdev)
 {
 	struct i2c_peripheral *i2c_dev;
@@ -499,10 +459,6 @@ static struct chromeos_laptop cr48 = {
 	},
 };
 
-#define _CBDD(board_) \
-	.callback = chromeos_laptop_dmi_matched, \
-	.driver_data = (void *)&board_
-
 static const struct dmi_system_id chromeos_laptop_dmi_table[] __initconst = {
 	{
 		.ident = "Samsung Series 5 550",
@@ -510,14 +466,14 @@ static const struct dmi_system_id chromeos_laptop_dmi_table[] __initconst = {
 			DMI_MATCH(DMI_SYS_VENDOR, "SAMSUNG"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Lumpy"),
 		},
-		_CBDD(samsung_series_5_550),
+		.driver_data = (void *)&samsung_series_5_550,
 	},
 	{
 		.ident = "Samsung Series 5",
 		.matches = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "Alex"),
 		},
-		_CBDD(samsung_series_5),
+		.driver_data = (void *)&samsung_series_5,
 	},
 	{
 		.ident = "Chromebook Pixel",
@@ -525,7 +481,7 @@ static const struct dmi_system_id chromeos_laptop_dmi_table[] __initconst = {
 			DMI_MATCH(DMI_SYS_VENDOR, "GOOGLE"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Link"),
 		},
-		_CBDD(chromebook_pixel),
+		.driver_data = (void *)&chromebook_pixel,
 	},
 	{
 		.ident = "Wolf",
@@ -533,7 +489,7 @@ static const struct dmi_system_id chromeos_laptop_dmi_table[] __initconst = {
 			DMI_MATCH(DMI_BIOS_VENDOR, "coreboot"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Wolf"),
 		},
-		_CBDD(dell_chromebook_11),
+		.driver_data = (void *)&dell_chromebook_11,
 	},
 	{
 		.ident = "HP Chromebook 14",
@@ -541,7 +497,7 @@ static const struct dmi_system_id chromeos_laptop_dmi_table[] __initconst = {
 			DMI_MATCH(DMI_BIOS_VENDOR, "coreboot"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Falco"),
 		},
-		_CBDD(hp_chromebook_14),
+		.driver_data = (void *)&hp_chromebook_14,
 	},
 	{
 		.ident = "Toshiba CB35",
@@ -549,42 +505,42 @@ static const struct dmi_system_id chromeos_laptop_dmi_table[] __initconst = {
 			DMI_MATCH(DMI_BIOS_VENDOR, "coreboot"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Leon"),
 		},
-		_CBDD(toshiba_cb35),
+		.driver_data = (void *)&toshiba_cb35,
 	},
 	{
 		.ident = "Acer C7 Chromebook",
 		.matches = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "Parrot"),
 		},
-		_CBDD(acer_c7_chromebook),
+		.driver_data = (void *)&acer_c7_chromebook,
 	},
 	{
 		.ident = "Acer AC700",
 		.matches = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "ZGB"),
 		},
-		_CBDD(acer_ac700),
+		.driver_data = (void *)&acer_ac700,
 	},
 	{
 		.ident = "Acer C720",
 		.matches = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "Peppy"),
 		},
-		_CBDD(acer_c720),
+		.driver_data = (void *)&acer_c720,
 	},
 	{
 		.ident = "HP Pavilion 14 Chromebook",
 		.matches = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "Butterfly"),
 		},
-		_CBDD(hp_pavilion_14_chromebook),
+		.driver_data = (void *)&hp_pavilion_14_chromebook,
 	},
 	{
 		.ident = "Cr-48",
 		.matches = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "Mario"),
 		},
-		_CBDD(cr48),
+		.driver_data = (void *)&cr48,
 	},
 	{ }
 };
@@ -599,15 +555,67 @@ static struct platform_driver cros_platform_driver = {
 	.probe = chromeos_laptop_probe,
 };
 
+static int __init chromeos_laptop_get_irq_from_dmi(const char *dmi_name)
+{
+	const struct dmi_device *dmi_dev;
+	const struct dmi_dev_onboard *dev_data;
+
+	dmi_dev = dmi_find_device(DMI_DEV_TYPE_DEV_ONBOARD, dmi_name, NULL);
+	if (!dmi_dev) {
+		pr_err("failed to find DMI device '%s'\n", dmi_name);
+		return -ENOENT;
+	}
+
+	dev_data = dmi_dev->device_data;
+	if (!dev_data) {
+		pr_err("failed to get data from DMI for '%s'\n", dmi_name);
+		return -EINVAL;
+	}
+
+	return dev_data->instance;
+}
+
+static struct chromeos_laptop * __init
+chromeos_laptop_prepare(const struct dmi_system_id *id)
+{
+	struct i2c_peripheral *i2c_dev;
+	int irq;
+	int i;
+
+	cros_laptop = (void *)id->driver_data;
+
+	for (i = 0; i < MAX_I2C_PERIPHERALS; i++) {
+		i2c_dev = &cros_laptop->i2c_peripherals[i];
+
+		if (!i2c_dev->dmi_name)
+			continue;
+
+		irq = chromeos_laptop_get_irq_from_dmi(i2c_dev->dmi_name);
+		if (irq < 0)
+			return ERR_PTR(irq);
+	}
+
+	return cros_laptop;
+}
+
+
 static int __init chromeos_laptop_init(void)
 {
+	const struct dmi_system_id *dmi_id;
 	int ret;
 
-	if (!dmi_check_system(chromeos_laptop_dmi_table)) {
+	dmi_id = dmi_first_match(chromeos_laptop_dmi_table);
+	if (!dmi_id) {
 		pr_debug("unsupported system\n");
 		return -ENODEV;
 	}
 
+	pr_debug("DMI Matched %s\n", dmi_id->ident);
+
+	cros_laptop = chromeos_laptop_prepare(dmi_id->driver_data);
+	if (IS_ERR(cros_laptop))
+		return PTR_ERR(cros_laptop);
+
 	ret = platform_driver_register(&cros_platform_driver);
 	if (ret)
 		return ret;

commit 28cd38f105fc30ccda7a15170cbaa977d2601272
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Mar 20 15:31:32 2018 -0700

    platform/chrome: chromeos_laptop - rework i2c peripherals initialization
    
    Instead of having separate setup() functions responsible for instantiating
    i2c client for each peripheral, let's generalize the behavior and use
    common code for instantiating all i2c peripherals.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Benson Leung <bleung@chromium.org>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 96e962ff38e8..2a81ae4c15c9 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -25,10 +25,6 @@
 
 #define MAX_I2C_DEVICE_DEFERRALS	5
 
-static struct i2c_client *als;
-static struct i2c_client *tp;
-static struct i2c_client *ts;
-
 static const char *i2c_adapter_names[] = {
 	"SMBus I801 adapter",
 	"i915 gmbus vga",
@@ -50,12 +46,17 @@ enum i2c_peripheral_state {
 	UNPROBED = 0,
 	PROBED,
 	TIMEDOUT,
+	FAILED,
 };
 
 struct i2c_peripheral {
-	int (*add)(enum i2c_adapter_type type);
+	struct i2c_board_info board_info;
+	unsigned short alt_addr;
+	const char *dmi_name;
 	enum i2c_adapter_type type;
+
 	enum i2c_peripheral_state state;
+	struct i2c_client *client;
 	int tries;
 };
 
@@ -67,59 +68,6 @@ struct chromeos_laptop {
 
 static struct chromeos_laptop *cros_laptop;
 
-static struct i2c_board_info cyapa_device = {
-	I2C_BOARD_INFO("cyapa", CYAPA_TP_I2C_ADDR),
-	.flags		= I2C_CLIENT_WAKE,
-};
-
-static struct i2c_board_info elantech_device = {
-	I2C_BOARD_INFO("elan_i2c", ELAN_TP_I2C_ADDR),
-	.flags		= I2C_CLIENT_WAKE,
-};
-
-static struct i2c_board_info isl_als_device = {
-	I2C_BOARD_INFO("isl29018", ISL_ALS_I2C_ADDR),
-};
-
-static struct i2c_board_info tsl2583_als_device = {
-	I2C_BOARD_INFO("tsl2583", TAOS_ALS_I2C_ADDR),
-};
-
-static struct i2c_board_info tsl2563_als_device = {
-	I2C_BOARD_INFO("tsl2563", TAOS_ALS_I2C_ADDR),
-};
-
-static int mxt_t19_keys[] = {
-	KEY_RESERVED,
-	KEY_RESERVED,
-	KEY_RESERVED,
-	KEY_RESERVED,
-	KEY_RESERVED,
-	BTN_LEFT
-};
-
-static struct mxt_platform_data atmel_224s_tp_platform_data = {
-	.irqflags		= IRQF_TRIGGER_FALLING,
-	.t19_num_keys		= ARRAY_SIZE(mxt_t19_keys),
-	.t19_keymap		= mxt_t19_keys,
-};
-
-static struct i2c_board_info atmel_224s_tp_device = {
-	I2C_BOARD_INFO("atmel_mxt_tp", ATMEL_TP_I2C_ADDR),
-	.platform_data = &atmel_224s_tp_platform_data,
-	.flags		= I2C_CLIENT_WAKE,
-};
-
-static struct mxt_platform_data atmel_1664s_platform_data = {
-	.irqflags		= IRQF_TRIGGER_FALLING,
-};
-
-static struct i2c_board_info atmel_1664s_device = {
-	I2C_BOARD_INFO("atmel_mxt_ts", ATMEL_TS_I2C_ADDR),
-	.platform_data = &atmel_1664s_platform_data,
-	.flags		= I2C_CLIENT_WAKE,
-};
-
 static int chromeos_laptop_get_irq_from_dmi(const char *dmi_name)
 {
 	const struct dmi_device *dmi_dev;
@@ -140,29 +88,15 @@ static int chromeos_laptop_get_irq_from_dmi(const char *dmi_name)
 	return dev_data->instance;
 }
 
-static struct i2c_client *__add_probed_i2c_device(
-		const char *name,
-		int bus,
-		struct i2c_board_info *info,
-		const unsigned short *alt_addr_list)
+static struct i2c_client *
+chromes_laptop_instantiate_i2c_device(int bus,
+				      struct i2c_board_info *info,
+				      unsigned short alt_addr)
 {
 	struct i2c_adapter *adapter;
 	struct i2c_client *client = NULL;
 	const unsigned short addr_list[] = { info->addr, I2C_CLIENT_END };
 
-	if (bus < 0)
-		return NULL;
-
-	/*
-	 * If a name is specified, look for irq platform information stashed
-	 * in DMI_DEV_TYPE_DEV_ONBOARD by the Chrome OS custom system firmware.
-	 */
-	if (name) {
-		info->irq = chromeos_laptop_get_irq_from_dmi(name);
-		if (info->irq < 0)
-			return NULL;
-	}
-
 	adapter = i2c_get_adapter(bus);
 	if (!adapter) {
 		pr_err("failed to get i2c adapter %d\n", bus);
@@ -175,10 +109,13 @@ static struct i2c_client *__add_probed_i2c_device(
 	 * structure gets assigned primary address.
 	 */
 	client = i2c_new_probed_device(adapter, info, addr_list, NULL);
-	if (!client && alt_addr_list) {
+	if (!client && alt_addr) {
 		struct i2c_board_info dummy_info = {
 			I2C_BOARD_INFO("dummy", info->addr),
 		};
+		const unsigned short alt_addr_list[] = {
+			alt_addr, I2C_CLIENT_END
+		};
 		struct i2c_client *dummy;
 
 		dummy = i2c_new_probed_device(adapter, &dummy_info,
@@ -244,115 +181,53 @@ static int find_i2c_adapter_num(enum i2c_adapter_type type)
 	return adapter->nr;
 }
 
-/*
- * Takes a list of addresses in addrs as such :
- * { addr1, ... , addrn, I2C_CLIENT_END };
- * add_probed_i2c_device will use i2c_new_probed_device
- * and probe for devices at all of the addresses listed.
- * Returns NULL if no devices found.
- * See Documentation/i2c/instantiating-devices for more information.
- */
-static struct i2c_client *add_probed_i2c_device(
-		const char *name,
-		enum i2c_adapter_type type,
-		struct i2c_board_info *info,
-		const unsigned short *addrs)
+static int chromeos_laptop_add_peripheral(struct i2c_peripheral *i2c_dev)
 {
-	return __add_probed_i2c_device(name,
-				       find_i2c_adapter_num(type),
-				       info,
-				       addrs);
-}
+	struct i2c_client *client;
+	int bus;
+	int irq;
 
-/*
- * Probes for a device at a single address, the one provided by
- * info->addr.
- * Returns NULL if no device found.
- */
-static struct i2c_client *add_i2c_device(const char *name,
-						enum i2c_adapter_type type,
-						struct i2c_board_info *info)
-{
-	return __add_probed_i2c_device(name,
-				       find_i2c_adapter_num(type),
-				       info,
-				       NULL);
-}
-
-static int setup_cyapa_tp(enum i2c_adapter_type type)
-{
-	if (tp)
-		return 0;
-
-	/* add cyapa touchpad */
-	tp = add_i2c_device("trackpad", type, &cyapa_device);
-	return (!tp) ? -EAGAIN : 0;
-}
-
-static int setup_atmel_224s_tp(enum i2c_adapter_type type)
-{
-	const unsigned short addr_list[] = { ATMEL_TP_I2C_BL_ADDR,
-					     I2C_CLIENT_END };
-	if (tp)
-		return 0;
-
-	/* add atmel mxt touchpad */
-	tp = add_probed_i2c_device("trackpad", type,
-				   &atmel_224s_tp_device, addr_list);
-	return (!tp) ? -EAGAIN : 0;
-}
-
-static int setup_elantech_tp(enum i2c_adapter_type type)
-{
-	if (tp)
-		return 0;
-
-	/* add elantech touchpad */
-	tp = add_i2c_device("trackpad", type, &elantech_device);
-	return (!tp) ? -EAGAIN : 0;
-}
-
-static int setup_atmel_1664s_ts(enum i2c_adapter_type type)
-{
-	const unsigned short addr_list[] = { ATMEL_TS_I2C_BL_ADDR,
-					     I2C_CLIENT_END };
-	if (ts)
-		return 0;
-
-	/* add atmel mxt touch device */
-	ts = add_probed_i2c_device("touchscreen", type,
-				   &atmel_1664s_device, addr_list);
-	return (!ts) ? -EAGAIN : 0;
-}
-
-static int setup_isl29018_als(enum i2c_adapter_type type)
-{
-	if (als)
-		return 0;
+	/*
+	 * Check that the i2c adapter is present.
+	 * -EPROBE_DEFER if missing as the adapter may appear much
+	 * later.
+	 */
+	bus = find_i2c_adapter_num(i2c_dev->type);
+	if (bus < 0)
+		return bus == -ENODEV ? -EPROBE_DEFER : bus;
 
-	/* add isl29018 light sensor */
-	als = add_i2c_device("lightsensor", type, &isl_als_device);
-	return (!als) ? -EAGAIN : 0;
-}
+	if (i2c_dev->dmi_name) {
+		irq = chromeos_laptop_get_irq_from_dmi(i2c_dev->dmi_name);
+		if (irq < 0) {
+			i2c_dev->state = FAILED;
+			return irq;
+		}
 
-static int setup_tsl2583_als(enum i2c_adapter_type type)
-{
-	if (als)
-		return 0;
+		i2c_dev->board_info.irq = irq;
+	}
 
-	/* add tsl2583 light sensor */
-	als = add_i2c_device(NULL, type, &tsl2583_als_device);
-	return (!als) ? -EAGAIN : 0;
-}
+	client = chromes_laptop_instantiate_i2c_device(bus,
+						       &i2c_dev->board_info,
+						       i2c_dev->alt_addr);
+	if (!client) {
+		/*
+		 * Set -EPROBE_DEFER a limited num of times
+		 * if device is not successfully added.
+		 */
+		if (++i2c_dev->tries < MAX_I2C_DEVICE_DEFERRALS) {
+			return -EPROBE_DEFER;
+		} else {
+			/* Ran out of tries. */
+			pr_notice("ran out of tries for device.\n");
+			i2c_dev->state = TIMEDOUT;
+			return -EIO;
+		}
+	}
 
-static int setup_tsl2563_als(enum i2c_adapter_type type)
-{
-	if (als)
-		return 0;
+	i2c_dev->client = client;
+	i2c_dev->state = PROBED;
 
-	/* add tsl2563 light sensor */
-	als = add_i2c_device(NULL, type, &tsl2563_als_device);
-	return (!als) ? -EAGAIN : 0;
+	return 0;
 }
 
 static int __init chromeos_laptop_dmi_matched(const struct dmi_system_id *id)
@@ -366,47 +241,22 @@ static int __init chromeos_laptop_dmi_matched(const struct dmi_system_id *id)
 
 static int chromeos_laptop_probe(struct platform_device *pdev)
 {
+	struct i2c_peripheral *i2c_dev;
 	int i;
 	int ret = 0;
 
 	for (i = 0; i < MAX_I2C_PERIPHERALS; i++) {
-		struct i2c_peripheral *i2c_dev;
-
 		i2c_dev = &cros_laptop->i2c_peripherals[i];
 
 		/* No more peripherals. */
-		if (i2c_dev->add == NULL)
+		if (!i2c_dev->board_info.addr)
 			break;
 
-		if (i2c_dev->state == TIMEDOUT || i2c_dev->state == PROBED)
+		if (i2c_dev->state != UNPROBED)
 			continue;
 
-		/*
-		 * Check that the i2c adapter is present.
-		 * -EPROBE_DEFER if missing as the adapter may appear much
-		 * later.
-		 */
-		if (find_i2c_adapter_num(i2c_dev->type) == -ENODEV) {
+		if (chromeos_laptop_add_peripheral(i2c_dev) == -EPROBE_DEFER)
 			ret = -EPROBE_DEFER;
-			continue;
-		}
-
-		/* Add the device. */
-		if (i2c_dev->add(i2c_dev->type) == -EAGAIN) {
-			/*
-			 * Set -EPROBE_DEFER a limited num of times
-			 * if device is not successfully added.
-			 */
-			if (++i2c_dev->tries < MAX_I2C_DEVICE_DEFERRALS) {
-				ret = -EPROBE_DEFER;
-			} else {
-				/* Ran out of tries. */
-				pr_notice("ran out of tries for device.\n");
-				i2c_dev->state = TIMEDOUT;
-			}
-		} else {
-			i2c_dev->state = PROBED;
-		}
 	}
 
 	return ret;
@@ -415,91 +265,237 @@ static int chromeos_laptop_probe(struct platform_device *pdev)
 static struct chromeos_laptop samsung_series_5_550 = {
 	.i2c_peripherals = {
 		/* Touchpad. */
-		{ .add = setup_cyapa_tp, I2C_ADAPTER_SMBUS },
+		{
+			.board_info	= {
+				I2C_BOARD_INFO("cyapa", CYAPA_TP_I2C_ADDR),
+				.flags		= I2C_CLIENT_WAKE,
+			},
+			.dmi_name	= "trackpad",
+			.type		= I2C_ADAPTER_SMBUS,
+		},
 		/* Light Sensor. */
-		{ .add = setup_isl29018_als, I2C_ADAPTER_SMBUS },
+		{
+			.board_info	= {
+				I2C_BOARD_INFO("isl29018", ISL_ALS_I2C_ADDR),
+			},
+			.dmi_name	= "lightsensor",
+			.type		= I2C_ADAPTER_SMBUS,
+		},
 	},
 };
 
 static struct chromeos_laptop samsung_series_5 = {
 	.i2c_peripherals = {
 		/* Light Sensor. */
-		{ .add = setup_tsl2583_als, I2C_ADAPTER_SMBUS },
+		{
+			.board_info	= {
+				I2C_BOARD_INFO("tsl2583", TAOS_ALS_I2C_ADDR),
+			},
+			.type		= I2C_ADAPTER_SMBUS,
+		},
 	},
 };
 
+static struct mxt_platform_data atmel_1664s_platform_data = {
+	.irqflags		= IRQF_TRIGGER_FALLING,
+};
+
+static int chromebook_pixel_tp_keys[] = {
+	KEY_RESERVED,
+	KEY_RESERVED,
+	KEY_RESERVED,
+	KEY_RESERVED,
+	KEY_RESERVED,
+	BTN_LEFT
+};
+
+static struct mxt_platform_data chromebook_pixel_tp_platform_data = {
+	.irqflags		= IRQF_TRIGGER_FALLING,
+	.t19_num_keys		= ARRAY_SIZE(chromebook_pixel_tp_keys),
+	.t19_keymap		= chromebook_pixel_tp_keys,
+};
+
 static struct chromeos_laptop chromebook_pixel = {
 	.i2c_peripherals = {
 		/* Touch Screen. */
-		{ .add = setup_atmel_1664s_ts, I2C_ADAPTER_PANEL },
+		{
+			.board_info	= {
+				I2C_BOARD_INFO("atmel_mxt_ts",
+						ATMEL_TS_I2C_ADDR),
+				.platform_data	= &atmel_1664s_platform_data,
+				.flags		= I2C_CLIENT_WAKE,
+			},
+			.dmi_name	= "touchscreen",
+			.type		= I2C_ADAPTER_PANEL,
+			.alt_addr	= ATMEL_TS_I2C_BL_ADDR,
+		},
 		/* Touchpad. */
-		{ .add = setup_atmel_224s_tp, I2C_ADAPTER_VGADDC },
+		{
+			.board_info	= {
+				I2C_BOARD_INFO("atmel_mxt_tp",
+						ATMEL_TP_I2C_ADDR),
+				.platform_data	=
+					&chromebook_pixel_tp_platform_data,
+				.flags		= I2C_CLIENT_WAKE,
+			},
+			.dmi_name	= "trackpad",
+			.type		= I2C_ADAPTER_VGADDC,
+			.alt_addr	= ATMEL_TP_I2C_BL_ADDR,
+		},
 		/* Light Sensor. */
-		{ .add = setup_isl29018_als, I2C_ADAPTER_PANEL },
+		{
+			.board_info	= {
+				I2C_BOARD_INFO("isl29018", ISL_ALS_I2C_ADDR),
+			},
+			.dmi_name	= "lightsensor",
+			.type		= I2C_ADAPTER_PANEL,
+		},
 	},
 };
 
 static struct chromeos_laptop hp_chromebook_14 = {
 	.i2c_peripherals = {
 		/* Touchpad. */
-		{ .add = setup_cyapa_tp, I2C_ADAPTER_DESIGNWARE_0 },
+		{
+			.board_info	= {
+				I2C_BOARD_INFO("cyapa", CYAPA_TP_I2C_ADDR),
+				.flags		= I2C_CLIENT_WAKE,
+			},
+			.dmi_name	= "trackpad",
+			.type		= I2C_ADAPTER_DESIGNWARE_0,
+		},
 	},
 };
 
 static struct chromeos_laptop dell_chromebook_11 = {
 	.i2c_peripherals = {
 		/* Touchpad. */
-		{ .add = setup_cyapa_tp, I2C_ADAPTER_DESIGNWARE_0 },
+		{
+			.board_info	= {
+				I2C_BOARD_INFO("cyapa", CYAPA_TP_I2C_ADDR),
+				.flags		= I2C_CLIENT_WAKE,
+			},
+			.dmi_name	= "trackpad",
+			.type		= I2C_ADAPTER_DESIGNWARE_0,
+		},
 		/* Elan Touchpad option. */
-		{ .add = setup_elantech_tp, I2C_ADAPTER_DESIGNWARE_0 },
+		{
+			.board_info	= {
+				I2C_BOARD_INFO("elan_i2c", ELAN_TP_I2C_ADDR),
+				.flags		= I2C_CLIENT_WAKE,
+			},
+			.dmi_name	= "trackpad",
+			.type		= I2C_ADAPTER_DESIGNWARE_0,
+		},
 	},
 };
 
 static struct chromeos_laptop toshiba_cb35 = {
 	.i2c_peripherals = {
 		/* Touchpad. */
-		{ .add = setup_cyapa_tp, I2C_ADAPTER_DESIGNWARE_0 },
+		{
+			.board_info	= {
+				I2C_BOARD_INFO("cyapa", CYAPA_TP_I2C_ADDR),
+				.flags		= I2C_CLIENT_WAKE,
+			},
+			.dmi_name	= "trackpad",
+			.type		= I2C_ADAPTER_DESIGNWARE_0,
+		},
 	},
 };
 
 static struct chromeos_laptop acer_c7_chromebook = {
 	.i2c_peripherals = {
 		/* Touchpad. */
-		{ .add = setup_cyapa_tp, I2C_ADAPTER_SMBUS },
+		{
+			.board_info	= {
+				I2C_BOARD_INFO("cyapa", CYAPA_TP_I2C_ADDR),
+				.flags		= I2C_CLIENT_WAKE,
+			},
+			.dmi_name	= "trackpad",
+			.type		= I2C_ADAPTER_SMBUS,
+		},
 	},
 };
 
 static struct chromeos_laptop acer_ac700 = {
 	.i2c_peripherals = {
 		/* Light Sensor. */
-		{ .add = setup_tsl2563_als, I2C_ADAPTER_SMBUS },
+		{
+			.board_info	= {
+				I2C_BOARD_INFO("tsl2583", TAOS_ALS_I2C_ADDR),
+			},
+			.type		= I2C_ADAPTER_SMBUS,
+		},
 	},
 };
 
 static struct chromeos_laptop acer_c720 = {
 	.i2c_peripherals = {
 		/* Touchscreen. */
-		{ .add = setup_atmel_1664s_ts, I2C_ADAPTER_DESIGNWARE_1 },
+		{
+			.board_info	= {
+				I2C_BOARD_INFO("atmel_mxt_ts",
+						ATMEL_TS_I2C_ADDR),
+				.platform_data	= &atmel_1664s_platform_data,
+				.flags		= I2C_CLIENT_WAKE,
+			},
+			.dmi_name	= "touchscreen",
+			.type		= I2C_ADAPTER_DESIGNWARE_1,
+			.alt_addr	= ATMEL_TS_I2C_BL_ADDR,
+		},
 		/* Touchpad. */
-		{ .add = setup_cyapa_tp, I2C_ADAPTER_DESIGNWARE_0 },
+		{
+			.board_info	= {
+				I2C_BOARD_INFO("cyapa", CYAPA_TP_I2C_ADDR),
+				.flags		= I2C_CLIENT_WAKE,
+			},
+			.dmi_name	= "trackpad",
+			.type		= I2C_ADAPTER_DESIGNWARE_0,
+		},
 		/* Elan Touchpad option. */
-		{ .add = setup_elantech_tp, I2C_ADAPTER_DESIGNWARE_0 },
+		{
+			.board_info	= {
+				I2C_BOARD_INFO("elan_i2c", ELAN_TP_I2C_ADDR),
+				.flags		= I2C_CLIENT_WAKE,
+			},
+			.dmi_name	= "trackpad",
+			.type		= I2C_ADAPTER_DESIGNWARE_0,
+		},
 		/* Light Sensor. */
-		{ .add = setup_isl29018_als, I2C_ADAPTER_DESIGNWARE_1 },
+		{
+			.board_info	= {
+				I2C_BOARD_INFO("isl29018", ISL_ALS_I2C_ADDR),
+			},
+			.dmi_name	= "lightsensor",
+			.type		= I2C_ADAPTER_DESIGNWARE_1,
+		},
 	},
 };
 
 static struct chromeos_laptop hp_pavilion_14_chromebook = {
 	.i2c_peripherals = {
 		/* Touchpad. */
-		{ .add = setup_cyapa_tp, I2C_ADAPTER_SMBUS },
+		{
+			.board_info	= {
+				I2C_BOARD_INFO("cyapa", CYAPA_TP_I2C_ADDR),
+				.flags		= I2C_CLIENT_WAKE,
+			},
+			.dmi_name	= "trackpad",
+			.type		= I2C_ADAPTER_SMBUS,
+		},
 	},
 };
 
 static struct chromeos_laptop cr48 = {
 	.i2c_peripherals = {
 		/* Light Sensor. */
-		{ .add = setup_tsl2563_als, I2C_ADAPTER_SMBUS },
+		{
+			.board_info	= {
+				I2C_BOARD_INFO("tsl2563", TAOS_ALS_I2C_ADDR),
+			},
+			.type		= I2C_ADAPTER_SMBUS,
+		},
 	},
 };
 
@@ -637,15 +633,22 @@ static int __init chromeos_laptop_init(void)
 
 static void __exit chromeos_laptop_exit(void)
 {
-	if (als)
-		i2c_unregister_device(als);
-	if (tp)
-		i2c_unregister_device(tp);
-	if (ts)
-		i2c_unregister_device(ts);
+	struct i2c_peripheral *i2c_dev;
+	int i;
 
 	platform_device_unregister(cros_platform_device);
 	platform_driver_unregister(&cros_platform_driver);
+
+	for (i = 0; i < MAX_I2C_PERIPHERALS; i++) {
+		i2c_dev = &cros_laptop->i2c_peripherals[i];
+
+		/* No more peripherals */
+		if (!i2c_dev->board_info.type)
+			break;
+
+		if (i2c_dev->state == PROBED)
+			i2c_unregister_device(i2c_dev->client);
+	}
 }
 
 module_init(chromeos_laptop_init);

commit ab6c5600d8caf5ee9a8a5081344f055bc80bc271
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Mar 20 15:31:31 2018 -0700

    platform/chrome: chromeos_laptop - factor out getting IRQ from DMI
    
    This will make code instantiating I2C device a bit clearer.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Benson Leung <bleung@chromium.org>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 08ce7a105e76..96e962ff38e8 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -120,36 +120,47 @@ static struct i2c_board_info atmel_1664s_device = {
 	.flags		= I2C_CLIENT_WAKE,
 };
 
+static int chromeos_laptop_get_irq_from_dmi(const char *dmi_name)
+{
+	const struct dmi_device *dmi_dev;
+	const struct dmi_dev_onboard *dev_data;
+
+	dmi_dev = dmi_find_device(DMI_DEV_TYPE_DEV_ONBOARD, dmi_name, NULL);
+	if (!dmi_dev) {
+		pr_err("failed to find DMI device '%s'\n", dmi_name);
+		return -ENOENT;
+	}
+
+	dev_data = dmi_dev->device_data;
+	if (!dev_data) {
+		pr_err("failed to get data from DMI for '%s'\n", dmi_name);
+		return -EINVAL;
+	}
+
+	return dev_data->instance;
+}
+
 static struct i2c_client *__add_probed_i2c_device(
 		const char *name,
 		int bus,
 		struct i2c_board_info *info,
 		const unsigned short *alt_addr_list)
 {
-	const struct dmi_device *dmi_dev;
-	const struct dmi_dev_onboard *dev_data;
 	struct i2c_adapter *adapter;
 	struct i2c_client *client = NULL;
 	const unsigned short addr_list[] = { info->addr, I2C_CLIENT_END };
 
 	if (bus < 0)
 		return NULL;
+
 	/*
 	 * If a name is specified, look for irq platform information stashed
 	 * in DMI_DEV_TYPE_DEV_ONBOARD by the Chrome OS custom system firmware.
 	 */
 	if (name) {
-		dmi_dev = dmi_find_device(DMI_DEV_TYPE_DEV_ONBOARD, name, NULL);
-		if (!dmi_dev) {
-			pr_err("failed to dmi find device %s\n", name);
-			return NULL;
-		}
-		dev_data = (struct dmi_dev_onboard *)dmi_dev->device_data;
-		if (!dev_data) {
-			pr_err("failed to get data from dmi for %s\n", name);
+		info->irq = chromeos_laptop_get_irq_from_dmi(name);
+		if (info->irq < 0)
 			return NULL;
-		}
-		info->irq = dev_data->instance;
 	}
 
 	adapter = i2c_get_adapter(bus);

commit 4f27f677c9541c02b7a62761f93bccbc404be8bb
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Mar 20 15:31:30 2018 -0700

    platform/chrome: chromeos_laptop - introduce pr_fmt()
    
    Define pr_fmt() to standardize driver messages.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Benson Leung <bleung@chromium.org>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 0a43f1833de3..08ce7a105e76 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -4,6 +4,8 @@
 // Copyright (C) 2012 Google, Inc.
 // Author: Benson Leung <bleung@chromium.org>
 
+#define pr_fmt(fmt)		KBUILD_MODNAME ": " fmt
+
 #include <linux/dmi.h>
 #include <linux/i2c.h>
 #include <linux/platform_data/atmel_mxt_ts.h>
@@ -139,15 +141,12 @@ static struct i2c_client *__add_probed_i2c_device(
 	if (name) {
 		dmi_dev = dmi_find_device(DMI_DEV_TYPE_DEV_ONBOARD, name, NULL);
 		if (!dmi_dev) {
-			pr_err("%s failed to dmi find device %s.\n",
-			       __func__,
-			       name);
+			pr_err("failed to dmi find device %s\n", name);
 			return NULL;
 		}
 		dev_data = (struct dmi_dev_onboard *)dmi_dev->device_data;
 		if (!dev_data) {
-			pr_err("%s failed to get data from dmi for %s.\n",
-			       __func__, name);
+			pr_err("failed to get data from dmi for %s\n", name);
 			return NULL;
 		}
 		info->irq = dev_data->instance;
@@ -155,7 +154,7 @@ static struct i2c_client *__add_probed_i2c_device(
 
 	adapter = i2c_get_adapter(bus);
 	if (!adapter) {
-		pr_err("%s failed to get i2c adapter %d.\n", __func__, bus);
+		pr_err("failed to get i2c adapter %d\n", bus);
 		return NULL;
 	}
 
@@ -174,19 +173,18 @@ static struct i2c_client *__add_probed_i2c_device(
 		dummy = i2c_new_probed_device(adapter, &dummy_info,
 					      alt_addr_list, NULL);
 		if (dummy) {
-			pr_debug("%s %d-%02x is probed at %02x\n",
-				  __func__, bus, info->addr, dummy->addr);
+			pr_debug("%d-%02x is probed at %02x\n",
+				 bus, info->addr, dummy->addr);
 			i2c_unregister_device(dummy);
 			client = i2c_new_device(adapter, info);
 		}
 	}
 
 	if (!client)
-		pr_notice("%s failed to register device %d-%02x\n",
-			  __func__, bus, info->addr);
+		pr_notice("failed to register device %d-%02x\n",
+			  bus, info->addr);
 	else
-		pr_debug("%s added i2c device %d-%02x\n",
-			 __func__, bus, info->addr);
+		pr_debug("added i2c device %d-%02x\n", bus, info->addr);
 
 	i2c_put_adapter(adapter);
 	return client;
@@ -227,7 +225,7 @@ static int find_i2c_adapter_num(enum i2c_adapter_type type)
 	dev = bus_find_device(&i2c_bus_type, NULL, &lookup, __find_i2c_adap);
 	if (!dev) {
 		/* Adapters may appear later. Deferred probing will retry */
-		pr_notice("%s: i2c adapter %s not found on system.\n", __func__,
+		pr_notice("i2c adapter %s not found on system.\n",
 			  lookup.name);
 		return -ENODEV;
 	}
@@ -349,7 +347,7 @@ static int setup_tsl2563_als(enum i2c_adapter_type type)
 static int __init chromeos_laptop_dmi_matched(const struct dmi_system_id *id)
 {
 	cros_laptop = (void *)id->driver_data;
-	pr_debug("DMI Matched %s.\n", id->ident);
+	pr_debug("DMI Matched %s\n", id->ident);
 
 	/* Indicate to dmi_scan that processing is done. */
 	return 1;
@@ -392,8 +390,7 @@ static int chromeos_laptop_probe(struct platform_device *pdev)
 				ret = -EPROBE_DEFER;
 			} else {
 				/* Ran out of tries. */
-				pr_notice("%s: Ran out of tries for device.\n",
-					  __func__);
+				pr_notice("ran out of tries for device.\n");
 				i2c_dev->state = TIMEDOUT;
 			}
 		} else {
@@ -600,7 +597,7 @@ static int __init chromeos_laptop_init(void)
 	int ret;
 
 	if (!dmi_check_system(chromeos_laptop_dmi_table)) {
-		pr_debug("%s unsupported system.\n", __func__);
+		pr_debug("unsupported system\n");
 		return -ENODEV;
 	}
 

commit ed58f90c11696dee3a27fb56b00b507ad4cbad53
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Mar 20 15:31:29 2018 -0700

    platform/chrome: chromeos_laptop - stop setting suspend mode for Atmel devices
    
    Atmel touch controller driver no longer respects suspend mode specified in
    platform data, so let's stop setting it.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Benson Leung <bleung@chromium.org>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 54a13c70e1d8..0a43f1833de3 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -100,7 +100,6 @@ static struct mxt_platform_data atmel_224s_tp_platform_data = {
 	.irqflags		= IRQF_TRIGGER_FALLING,
 	.t19_num_keys		= ARRAY_SIZE(mxt_t19_keys),
 	.t19_keymap		= mxt_t19_keys,
-	.suspend_mode		= MXT_SUSPEND_T9_CTRL,
 };
 
 static struct i2c_board_info atmel_224s_tp_device = {
@@ -111,7 +110,6 @@ static struct i2c_board_info atmel_224s_tp_device = {
 
 static struct mxt_platform_data atmel_1664s_platform_data = {
 	.irqflags		= IRQF_TRIGGER_FALLING,
-	.suspend_mode		= MXT_SUSPEND_T9_CTRL,
 };
 
 static struct i2c_board_info atmel_1664s_device = {

commit 203e0baedb984f1f206f853675cd169f9a646c72
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Mar 20 15:31:28 2018 -0700

    platform/chrome: chromeos_laptop - add SPDX identifier
    
    Replace the original license statement with the SPDX identifier.
    Add also one line of description as recommended by the COPYING file.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Benson Leung <bleung@chromium.org>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index d8599736a41a..54a13c70e1d8 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -1,25 +1,8 @@
-/*
- *  chromeos_laptop.c - Driver to instantiate Chromebook i2c/smbus devices.
- *
- *  Author : Benson Leung <bleung@chromium.org>
- *
- *  Copyright (C) 2012 Google, Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
+// SPDX-License-Identifier: GPL-2.0+
+// Driver to instantiate Chromebook i2c/smbus devices.
+//
+// Copyright (C) 2012 Google, Inc.
+// Author: Benson Leung <bleung@chromium.org>
 
 #include <linux/dmi.h>
 #include <linux/i2c.h>

commit fc88bbdae049683f321dfa19648d035c93a0b613
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Mar 6 10:59:15 2018 -0800

    Revert "platform/chrome: chromeos_laptop: make chromeos_laptop const"
    
    This reverts commit a376cd91606365609d8fbd57247618bd51da1fc6 because
    chromeos_laptop instances should not be marked as "const" (at this
    time), since i2c_peripheral is being modified (we change "state" and
    "tries") when we instantiate devices.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Benson Leung <bleung@chromium.org>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 6dec6ab13300..d8599736a41a 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -423,7 +423,7 @@ static int chromeos_laptop_probe(struct platform_device *pdev)
 	return ret;
 }
 
-static const struct chromeos_laptop samsung_series_5_550 = {
+static struct chromeos_laptop samsung_series_5_550 = {
 	.i2c_peripherals = {
 		/* Touchpad. */
 		{ .add = setup_cyapa_tp, I2C_ADAPTER_SMBUS },
@@ -432,14 +432,14 @@ static const struct chromeos_laptop samsung_series_5_550 = {
 	},
 };
 
-static const struct chromeos_laptop samsung_series_5 = {
+static struct chromeos_laptop samsung_series_5 = {
 	.i2c_peripherals = {
 		/* Light Sensor. */
 		{ .add = setup_tsl2583_als, I2C_ADAPTER_SMBUS },
 	},
 };
 
-static const struct chromeos_laptop chromebook_pixel = {
+static struct chromeos_laptop chromebook_pixel = {
 	.i2c_peripherals = {
 		/* Touch Screen. */
 		{ .add = setup_atmel_1664s_ts, I2C_ADAPTER_PANEL },
@@ -450,14 +450,14 @@ static const struct chromeos_laptop chromebook_pixel = {
 	},
 };
 
-static const struct chromeos_laptop hp_chromebook_14 = {
+static struct chromeos_laptop hp_chromebook_14 = {
 	.i2c_peripherals = {
 		/* Touchpad. */
 		{ .add = setup_cyapa_tp, I2C_ADAPTER_DESIGNWARE_0 },
 	},
 };
 
-static const struct chromeos_laptop dell_chromebook_11 = {
+static struct chromeos_laptop dell_chromebook_11 = {
 	.i2c_peripherals = {
 		/* Touchpad. */
 		{ .add = setup_cyapa_tp, I2C_ADAPTER_DESIGNWARE_0 },
@@ -466,28 +466,28 @@ static const struct chromeos_laptop dell_chromebook_11 = {
 	},
 };
 
-static const struct chromeos_laptop toshiba_cb35 = {
+static struct chromeos_laptop toshiba_cb35 = {
 	.i2c_peripherals = {
 		/* Touchpad. */
 		{ .add = setup_cyapa_tp, I2C_ADAPTER_DESIGNWARE_0 },
 	},
 };
 
-static const struct chromeos_laptop acer_c7_chromebook = {
+static struct chromeos_laptop acer_c7_chromebook = {
 	.i2c_peripherals = {
 		/* Touchpad. */
 		{ .add = setup_cyapa_tp, I2C_ADAPTER_SMBUS },
 	},
 };
 
-static const struct chromeos_laptop acer_ac700 = {
+static struct chromeos_laptop acer_ac700 = {
 	.i2c_peripherals = {
 		/* Light Sensor. */
 		{ .add = setup_tsl2563_als, I2C_ADAPTER_SMBUS },
 	},
 };
 
-static const struct chromeos_laptop acer_c720 = {
+static struct chromeos_laptop acer_c720 = {
 	.i2c_peripherals = {
 		/* Touchscreen. */
 		{ .add = setup_atmel_1664s_ts, I2C_ADAPTER_DESIGNWARE_1 },
@@ -500,14 +500,14 @@ static const struct chromeos_laptop acer_c720 = {
 	},
 };
 
-static const struct chromeos_laptop hp_pavilion_14_chromebook = {
+static struct chromeos_laptop hp_pavilion_14_chromebook = {
 	.i2c_peripherals = {
 		/* Touchpad. */
 		{ .add = setup_cyapa_tp, I2C_ADAPTER_SMBUS },
 	},
 };
 
-static const struct chromeos_laptop cr48 = {
+static struct chromeos_laptop cr48 = {
 	.i2c_peripherals = {
 		/* Light Sensor. */
 		{ .add = setup_tsl2563_als, I2C_ADAPTER_SMBUS },

commit a376cd91606365609d8fbd57247618bd51da1fc6
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Aug 5 13:50:42 2017 +0530

    platform/chrome: chromeos_laptop: make chromeos_laptop const
    
    Declare chromeos_laptop structures as const as they are only used during
    a copy operation. As their value is never modified during runtime, they
    can be made const.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Benson Leung <bleung@chromium.org>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index d8599736a41a..6dec6ab13300 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -423,7 +423,7 @@ static int chromeos_laptop_probe(struct platform_device *pdev)
 	return ret;
 }
 
-static struct chromeos_laptop samsung_series_5_550 = {
+static const struct chromeos_laptop samsung_series_5_550 = {
 	.i2c_peripherals = {
 		/* Touchpad. */
 		{ .add = setup_cyapa_tp, I2C_ADAPTER_SMBUS },
@@ -432,14 +432,14 @@ static struct chromeos_laptop samsung_series_5_550 = {
 	},
 };
 
-static struct chromeos_laptop samsung_series_5 = {
+static const struct chromeos_laptop samsung_series_5 = {
 	.i2c_peripherals = {
 		/* Light Sensor. */
 		{ .add = setup_tsl2583_als, I2C_ADAPTER_SMBUS },
 	},
 };
 
-static struct chromeos_laptop chromebook_pixel = {
+static const struct chromeos_laptop chromebook_pixel = {
 	.i2c_peripherals = {
 		/* Touch Screen. */
 		{ .add = setup_atmel_1664s_ts, I2C_ADAPTER_PANEL },
@@ -450,14 +450,14 @@ static struct chromeos_laptop chromebook_pixel = {
 	},
 };
 
-static struct chromeos_laptop hp_chromebook_14 = {
+static const struct chromeos_laptop hp_chromebook_14 = {
 	.i2c_peripherals = {
 		/* Touchpad. */
 		{ .add = setup_cyapa_tp, I2C_ADAPTER_DESIGNWARE_0 },
 	},
 };
 
-static struct chromeos_laptop dell_chromebook_11 = {
+static const struct chromeos_laptop dell_chromebook_11 = {
 	.i2c_peripherals = {
 		/* Touchpad. */
 		{ .add = setup_cyapa_tp, I2C_ADAPTER_DESIGNWARE_0 },
@@ -466,28 +466,28 @@ static struct chromeos_laptop dell_chromebook_11 = {
 	},
 };
 
-static struct chromeos_laptop toshiba_cb35 = {
+static const struct chromeos_laptop toshiba_cb35 = {
 	.i2c_peripherals = {
 		/* Touchpad. */
 		{ .add = setup_cyapa_tp, I2C_ADAPTER_DESIGNWARE_0 },
 	},
 };
 
-static struct chromeos_laptop acer_c7_chromebook = {
+static const struct chromeos_laptop acer_c7_chromebook = {
 	.i2c_peripherals = {
 		/* Touchpad. */
 		{ .add = setup_cyapa_tp, I2C_ADAPTER_SMBUS },
 	},
 };
 
-static struct chromeos_laptop acer_ac700 = {
+static const struct chromeos_laptop acer_ac700 = {
 	.i2c_peripherals = {
 		/* Light Sensor. */
 		{ .add = setup_tsl2563_als, I2C_ADAPTER_SMBUS },
 	},
 };
 
-static struct chromeos_laptop acer_c720 = {
+static const struct chromeos_laptop acer_c720 = {
 	.i2c_peripherals = {
 		/* Touchscreen. */
 		{ .add = setup_atmel_1664s_ts, I2C_ADAPTER_DESIGNWARE_1 },
@@ -500,14 +500,14 @@ static struct chromeos_laptop acer_c720 = {
 	},
 };
 
-static struct chromeos_laptop hp_pavilion_14_chromebook = {
+static const struct chromeos_laptop hp_pavilion_14_chromebook = {
 	.i2c_peripherals = {
 		/* Touchpad. */
 		{ .add = setup_cyapa_tp, I2C_ADAPTER_SMBUS },
 	},
 };
 
-static struct chromeos_laptop cr48 = {
+static const struct chromeos_laptop cr48 = {
 	.i2c_peripherals = {
 		/* Light Sensor. */
 		{ .add = setup_tsl2563_als, I2C_ADAPTER_SMBUS },

commit 6faadbbb7f9da70ce484f98f72223c20125a1009
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Sep 14 11:59:30 2017 +0200

    dmi: Mark all struct dmi_system_id instances const
    
    ... and __initconst if applicable.
    
    Based on similar work for an older kernel in the Grsecurity patch.
    
    [JD: fix toshiba-wmi build]
    [JD: add htcpen]
    [JD: move __initconst where checkscript wants it]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jean Delvare <jdelvare@suse.de>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index e8a44a9bc916..d8599736a41a 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -518,7 +518,7 @@ static struct chromeos_laptop cr48 = {
 	.callback = chromeos_laptop_dmi_matched, \
 	.driver_data = (void *)&board_
 
-static struct dmi_system_id chromeos_laptop_dmi_table[] __initdata = {
+static const struct dmi_system_id chromeos_laptop_dmi_table[] __initconst = {
 	{
 		.ident = "Samsung Series 5 550",
 		.matches = {

commit 8d057e3a180da16b0d1519056295165e7b8dc8f5
Author: Benson Leung <bleung@chromium.org>
Date:   Sat May 28 08:25:33 2016 -0700

    Revert "platform/chrome: chromeos_laptop: Add Leon Touch"
    
    This reverts commit bff3c624dc7261a084a4d25a0b09c3fb0fec872a.
    
    Board "Leon" is otherwise known as "Toshiba CB35" and we already have
    the entry that supports that board as of this commit :
    963cb6f platform/chrome: chromeos_laptop - Add Toshiba CB35 Touch
    
    Remove this duplicate.
    
    Signed-off-by: Benson Leung <bleung@chromium.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 8398a7d96490..e8a44a9bc916 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -514,13 +514,6 @@ static struct chromeos_laptop cr48 = {
 	},
 };
 
-static struct chromeos_laptop leon = {
-	.i2c_peripherals = {
-		/* Touchpad. */
-		{ .add = setup_cyapa_tp, I2C_ADAPTER_DESIGNWARE_0 },
-	},
-};
-
 #define _CBDD(board_) \
 	.callback = chromeos_laptop_dmi_matched, \
 	.driver_data = (void *)&board_
@@ -608,14 +601,6 @@ static struct dmi_system_id chromeos_laptop_dmi_table[] __initdata = {
 		},
 		_CBDD(cr48),
 	},
-	{
-		.ident = "Leon",
-		.matches = {
-			DMI_MATCH(DMI_BIOS_VENDOR, "coreboot"),
-			DMI_MATCH(DMI_PRODUCT_NAME, "Leon"),
-		},
-		_CBDD(leon),
-	},
 	{ }
 };
 MODULE_DEVICE_TABLE(dmi, chromeos_laptop_dmi_table);

commit 9e96aa70e9acd03eee61c2094b4755b80a386c47
Author: Charlie Mooney <charliemooney@chromium.org>
Date:   Mon May 2 08:57:17 2016 +0800

    platform/chrome: chromeos_laptop - Add Elan touchpad for Wolf
    
    The upcoming Elan Wolf (Dell Chromebook 11) devices need to know to look
    for Elan touchpads on the i2c bus so that they will be functional.
    
    Based on the chromeos-kernel commit :
    https://chromium-review.googlesource.com/198283
    
    Signed-off-by: Charlie Mooney <charliemooney@chromium.org>
    Signed-off-by: Benson Leung <bleung@chromium.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 6ea4f1ad382a..8398a7d96490 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -461,6 +461,8 @@ static struct chromeos_laptop dell_chromebook_11 = {
 	.i2c_peripherals = {
 		/* Touchpad. */
 		{ .add = setup_cyapa_tp, I2C_ADAPTER_DESIGNWARE_0 },
+		/* Elan Touchpad option. */
+		{ .add = setup_elantech_tp, I2C_ADAPTER_DESIGNWARE_0 },
 	},
 };
 

commit 9bd9a90b013c647ed88ed4fa69b664b770924cf0
Author: Benson Leung <bleung@chromium.org>
Date:   Mon May 2 08:57:16 2016 +0800

    platform/chrome: chromeos_laptop - Add elan trackpad option for C720
    
    Add the elan trackpad to the Acer C720 (peppy) list, as it is an alternate
    trackpad option. It may exist at i2c address 0x15.
    
    Based on this change from the chromeos kernel :
    https://chromium-review.googlesource.com/186253
    
    Signed-off-by: Benson Leung <bleung@chromium.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index f5aa0a361412..6ea4f1ad382a 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -34,6 +34,7 @@
 #define ATMEL_TS_I2C_ADDR	0x4a
 #define ATMEL_TS_I2C_BL_ADDR	0x26
 #define CYAPA_TP_I2C_ADDR	0x67
+#define ELAN_TP_I2C_ADDR	0x15
 #define ISL_ALS_I2C_ADDR	0x44
 #define TAOS_ALS_I2C_ADDR	0x29
 
@@ -73,7 +74,7 @@ struct i2c_peripheral {
 	int tries;
 };
 
-#define MAX_I2C_PERIPHERALS 3
+#define MAX_I2C_PERIPHERALS 4
 
 struct chromeos_laptop {
 	struct i2c_peripheral i2c_peripherals[MAX_I2C_PERIPHERALS];
@@ -86,6 +87,11 @@ static struct i2c_board_info cyapa_device = {
 	.flags		= I2C_CLIENT_WAKE,
 };
 
+static struct i2c_board_info elantech_device = {
+	I2C_BOARD_INFO("elan_i2c", ELAN_TP_I2C_ADDR),
+	.flags		= I2C_CLIENT_WAKE,
+};
+
 static struct i2c_board_info isl_als_device = {
 	I2C_BOARD_INFO("isl29018", ISL_ALS_I2C_ADDR),
 };
@@ -306,6 +312,16 @@ static int setup_atmel_224s_tp(enum i2c_adapter_type type)
 	return (!tp) ? -EAGAIN : 0;
 }
 
+static int setup_elantech_tp(enum i2c_adapter_type type)
+{
+	if (tp)
+		return 0;
+
+	/* add elantech touchpad */
+	tp = add_i2c_device("trackpad", type, &elantech_device);
+	return (!tp) ? -EAGAIN : 0;
+}
+
 static int setup_atmel_1664s_ts(enum i2c_adapter_type type)
 {
 	const unsigned short addr_list[] = { ATMEL_TS_I2C_BL_ADDR,
@@ -475,6 +491,8 @@ static struct chromeos_laptop acer_c720 = {
 		{ .add = setup_atmel_1664s_ts, I2C_ADAPTER_DESIGNWARE_1 },
 		/* Touchpad. */
 		{ .add = setup_cyapa_tp, I2C_ADAPTER_DESIGNWARE_0 },
+		/* Elan Touchpad option. */
+		{ .add = setup_elantech_tp, I2C_ADAPTER_DESIGNWARE_0 },
 		/* Light Sensor. */
 		{ .add = setup_isl29018_als, I2C_ADAPTER_DESIGNWARE_1 },
 	},

commit bff3c624dc7261a084a4d25a0b09c3fb0fec872a
Author: Gene Chen <gene.chen@intel.com>
Date:   Tue Feb 16 08:25:14 2016 +0100

    platform/chrome: chromeos_laptop: Add Leon Touch
    
    Add support for Leon touch devices, which is the same as
    slippy/falco/peppy/wolf on the same buses using the LynxPoint-LP I2C via
    the i2c-designware-pci driver.
    
    Based on the following patch:
    https://chromium-review.googlesource.com/#/c/168351/
    
    Signed-off-by: Gene Chen <gene.chen@intel.com>
    Reviewed-by: Benson Leung <bleung@chromium.org>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 2b441e9ae593..f5aa0a361412 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -494,6 +494,13 @@ static struct chromeos_laptop cr48 = {
 	},
 };
 
+static struct chromeos_laptop leon = {
+	.i2c_peripherals = {
+		/* Touchpad. */
+		{ .add = setup_cyapa_tp, I2C_ADAPTER_DESIGNWARE_0 },
+	},
+};
+
 #define _CBDD(board_) \
 	.callback = chromeos_laptop_dmi_matched, \
 	.driver_data = (void *)&board_
@@ -581,6 +588,14 @@ static struct dmi_system_id chromeos_laptop_dmi_table[] __initdata = {
 		},
 		_CBDD(cr48),
 	},
+	{
+		.ident = "Leon",
+		.matches = {
+			DMI_MATCH(DMI_BIOS_VENDOR, "coreboot"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Leon"),
+		},
+		_CBDD(leon),
+	},
 	{ }
 };
 MODULE_DEVICE_TABLE(dmi, chromeos_laptop_dmi_table);

commit ebaf31c46cce0dc8a6ed690b5456b295aa7586a6
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Tue Nov 3 13:09:00 2015 +0200

    platform/chrome: Fix i2c-designware adapter name
    
    Commit d80d134182ba ("i2c: designware: Move common probe code into
    i2c_dw_probe()") caused the I2C adapter lookup code here to fail for PCI
    enumerated i2c-designware because commit changed the adapter name but
    didn't update it here.
    
    Fix the I2C adapter lookup by using the "Synopsys DesignWare I2C adapter"
    name.
    
    Reported-by: Jeremiah Mahler <jmmahler@gmail.com>
    Fixes: d80d134182ba ("i2c: designware: Move common probe code into i2c_dw_probe()")
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Tested-by: Jeremiah Mahler <jmmahler@gmail.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 02072749fff3..2b441e9ae593 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -47,8 +47,8 @@ static const char *i2c_adapter_names[] = {
 	"SMBus I801 adapter",
 	"i915 gmbus vga",
 	"i915 gmbus panel",
-	"i2c-designware-pci",
-	"i2c-designware-pci",
+	"Synopsys DesignWare I2C adapter",
+	"Synopsys DesignWare I2C adapter",
 };
 
 /* Keep this enum consistent with i2c_adapter_names */

commit 7f3884f7de89c49439fdaa115f6d1caec3256cc3
Author: Nick Dyer <nick.dyer@itdev.co.uk>
Date:   Tue Aug 4 16:36:29 2015 -0700

    Input: atmel_mxt_ts - use deep sleep mode when stopped
    
    The hardcoded 0x83 CTRL setting overrides other settings in that byte,
    enabling extra reporting that may not be useful on a particular platform.
    
    Implement improved suspend mechanism via deep sleep. By writing zero to
    both the active and idle cycle times the maXTouch device can be put into a
    deep sleep mode, using minimal power. It is necessary to issue a calibrate
    command after the chip has spent any time in deep sleep, however a soft
    reset is unnecessary.
    
    Use the old method on Chromebook Pixel via platform data option.
    
    This patch also deals with the situation where the power configuration is
    zero on probe, which would mean that the device never wakes up to execute
    commands.
    
    After a config download, the T7 power configuration may have changed so it
    is necessary to re-read it.
    
    Signed-off-by: Nick Dyer <nick.dyer@itdev.co.uk>
    Acked-by: Benson Leung <bleung@chromium.org>
    Acked-by: Yufeng Shen <miletus@chromium.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index a04019ab9feb..02072749fff3 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -23,7 +23,7 @@
 
 #include <linux/dmi.h>
 #include <linux/i2c.h>
-#include <linux/i2c/atmel_mxt_ts.h>
+#include <linux/platform_data/atmel_mxt_ts.h>
 #include <linux/input.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
@@ -111,6 +111,7 @@ static struct mxt_platform_data atmel_224s_tp_platform_data = {
 	.irqflags		= IRQF_TRIGGER_FALLING,
 	.t19_num_keys		= ARRAY_SIZE(mxt_t19_keys),
 	.t19_keymap		= mxt_t19_keys,
+	.suspend_mode		= MXT_SUSPEND_T9_CTRL,
 };
 
 static struct i2c_board_info atmel_224s_tp_device = {
@@ -121,6 +122,7 @@ static struct i2c_board_info atmel_224s_tp_device = {
 
 static struct mxt_platform_data atmel_1664s_platform_data = {
 	.irqflags		= IRQF_TRIGGER_FALLING,
+	.suspend_mode		= MXT_SUSPEND_T9_CTRL,
 };
 
 static struct i2c_board_info atmel_1664s_device = {

commit 96cba9b00e297303774bec59e192064d20adeb3d
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Apr 14 13:50:09 2015 -0700

    platform/chrome: chromeos_laptop - instantiate Atmel at primary address
    
    The new Atmel MXT driver expects i2c client's address contain the
    primary (main address) of the chip, and calculates the expected
    bootloader address form the primary address. Unfortunately chrome_laptop
    does probe the devices and if touchpad (or touchscreen, or both) comes
    up in bootloader mode the i2c device gets instantiated with the
    bootloader address which confuses the driver.
    
    To work around this issue let's probe the primary address first. If the
    device is not detected at the primary address we'll probe alternative
    addresses as "dummy" devices. If any of them are found, destroy the
    dummy client and instantiate client with proper name at primary address
    still.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index b84fdd6b629b..a04019ab9feb 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -133,12 +133,13 @@ static struct i2c_client *__add_probed_i2c_device(
 		const char *name,
 		int bus,
 		struct i2c_board_info *info,
-		const unsigned short *addrs)
+		const unsigned short *alt_addr_list)
 {
 	const struct dmi_device *dmi_dev;
 	const struct dmi_dev_onboard *dev_data;
 	struct i2c_adapter *adapter;
-	struct i2c_client *client;
+	struct i2c_client *client = NULL;
+	const unsigned short addr_list[] = { info->addr, I2C_CLIENT_END };
 
 	if (bus < 0)
 		return NULL;
@@ -169,8 +170,28 @@ static struct i2c_client *__add_probed_i2c_device(
 		return NULL;
 	}
 
-	/* add the i2c device */
-	client = i2c_new_probed_device(adapter, info, addrs, NULL);
+	/*
+	 * Add the i2c device. If we can't detect it at the primary
+	 * address we scan secondary addresses. In any case the client
+	 * structure gets assigned primary address.
+	 */
+	client = i2c_new_probed_device(adapter, info, addr_list, NULL);
+	if (!client && alt_addr_list) {
+		struct i2c_board_info dummy_info = {
+			I2C_BOARD_INFO("dummy", info->addr),
+		};
+		struct i2c_client *dummy;
+
+		dummy = i2c_new_probed_device(adapter, &dummy_info,
+					      alt_addr_list, NULL);
+		if (dummy) {
+			pr_debug("%s %d-%02x is probed at %02x\n",
+				  __func__, bus, info->addr, dummy->addr);
+			i2c_unregister_device(dummy);
+			client = i2c_new_device(adapter, info);
+		}
+	}
+
 	if (!client)
 		pr_notice("%s failed to register device %d-%02x\n",
 			  __func__, bus, info->addr);
@@ -254,12 +275,10 @@ static struct i2c_client *add_i2c_device(const char *name,
 						enum i2c_adapter_type type,
 						struct i2c_board_info *info)
 {
-	const unsigned short addr_list[] = { info->addr, I2C_CLIENT_END };
-
 	return __add_probed_i2c_device(name,
 				       find_i2c_adapter_num(type),
 				       info,
-				       addr_list);
+				       NULL);
 }
 
 static int setup_cyapa_tp(enum i2c_adapter_type type)
@@ -275,7 +294,6 @@ static int setup_cyapa_tp(enum i2c_adapter_type type)
 static int setup_atmel_224s_tp(enum i2c_adapter_type type)
 {
 	const unsigned short addr_list[] = { ATMEL_TP_I2C_BL_ADDR,
-					     ATMEL_TP_I2C_ADDR,
 					     I2C_CLIENT_END };
 	if (tp)
 		return 0;
@@ -289,7 +307,6 @@ static int setup_atmel_224s_tp(enum i2c_adapter_type type)
 static int setup_atmel_1664s_ts(enum i2c_adapter_type type)
 {
 	const unsigned short addr_list[] = { ATMEL_TS_I2C_BL_ADDR,
-					     ATMEL_TS_I2C_ADDR,
 					     I2C_CLIENT_END };
 	if (ts)
 		return 0;

commit 38c53fa8f0b2bdf4e534a24bd224e4480d8d9dc4
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:26 2014 +0200

    platform: chrome: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index d866db80b4fd..b84fdd6b629b 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -571,7 +571,6 @@ static struct platform_device *cros_platform_device;
 static struct platform_driver cros_platform_driver = {
 	.driver = {
 		.name = "chromeos_laptop",
-		.owner = THIS_MODULE,
 	},
 	.probe = chromeos_laptop_probe,
 };

commit 58d08e3b2c2033354b91467da33deffa06360c28
Merge: 64e3bbc7ef70 5502486a2077
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Aug 10 11:13:58 2014 -0700

    Merge tag 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/olof/chrome-platform
    
    Pull chrome platform updates from Olof Johansson:
     "Updates to the Chromebook/box platform drivers:
    
       - a bugfix to pstore registration that makes it also work on
         non-Google systems
       - addition of new shipped Chromebooks (later models have more probing
         through ACPI so the need for these updates will be less over time).
       - A couple of minor coding style updates"
    
    * tag 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/olof/chrome-platform:
      platform/chrome: chromeos_laptop - Add a limit for deferred retries
      platform/chrome: Add support for the acer c720p touchscreen.
      platform/chrome: pstore: fix dmi table to match all chrome systems
      platform/chrome: coding style fixes
      platform/chrome: chromeos_laptop - Add Toshiba CB35 Touch
      platform/chrome: chromeos_laptop - Add Dell Chromebook 11 touch
      platform/chrome: chromeos_laptop - Add HP Chromebook 14
      platform/chrome: chromeos_laptop - Add support for Acer C720

commit 50a77c658b80e7e3303e3bcec195b30e2b62d513
Author: Nick Dyer <nick.dyer@itdev.co.uk>
Date:   Wed Jul 23 12:38:48 2014 -0700

    Input: atmel_mxt_ts - download device config using firmware loader
    
    The existing implementation which encodes the configuration as a binary
    blob in platform data is unsatisfactory since it requires a kernel
    recompile for the configuration to be changed, and it doesn't deal well
    with firmware changes that move values around on the chip.
    
    Atmel define an ASCII format for the configuration which can be exported
    from their tools. This patch implements a parser for that format which
    loads the configuration via the firmware loader and sends it to the MXT
    chip.
    
    Signed-off-by: Nick Dyer <nick.dyer@itdev.co.uk>
    Acked-by: Benson Leung <bleung@chromium.org>
    Acked-by: Yufeng Shen <miletus@chromium.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 7f1a2e2711bd..67b316b2a2bd 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -97,8 +97,6 @@ static struct mxt_platform_data atmel_224s_tp_platform_data = {
 	.irqflags		= IRQF_TRIGGER_FALLING,
 	.t19_num_keys		= ARRAY_SIZE(mxt_t19_keys),
 	.t19_keymap		= mxt_t19_keys,
-	.config			= NULL,
-	.config_length		= 0,
 };
 
 static struct i2c_board_info atmel_224s_tp_device = {
@@ -109,8 +107,6 @@ static struct i2c_board_info atmel_224s_tp_device = {
 
 static struct mxt_platform_data atmel_1664s_platform_data = {
 	.irqflags		= IRQF_TRIGGER_FALLING,
-	.config			= NULL,
-	.config_length		= 0,
 };
 
 static struct i2c_board_info atmel_1664s_device = {

commit 5502486a2077e4280c618b82e8a77ed35932956f
Author: Benson Leung <bleung@chromium.org>
Date:   Tue Jul 15 17:43:11 2014 -0700

    platform/chrome: chromeos_laptop - Add a limit for deferred retries
    
    Limit the number of times we allow deferred probing to attempt to add
    i2c devices. This will help with some device flakiness at probe time.
    For example, some touchpads and touchscreens may be in transition between
    bootloader and operational mode and may appear at neither address briefly.
    
    Adapters, however, have no limit as it depends on when the i2c adapter driver
    module is loaded. The module may even be loaded manually by the user using
    modprobe or insmod.
    
    By default, set MAX_I2C_DEVICE_DEFERALS to 5.
    
    Based on this patch from the chromeos-kernel :
    https://chromium-review.googlesource.com/168130
    
    Signed-off-by: Benson Leung <bleung@chromium.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 15b1b162890f..6ed6375fe6bf 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -37,6 +37,8 @@
 #define ISL_ALS_I2C_ADDR	0x44
 #define TAOS_ALS_I2C_ADDR	0x29
 
+#define MAX_I2C_DEVICE_DEFERRALS	5
+
 static struct i2c_client *als;
 static struct i2c_client *tp;
 static struct i2c_client *ts;
@@ -58,9 +60,17 @@ enum i2c_adapter_type {
 	I2C_ADAPTER_DESIGNWARE_1,
 };
 
+enum i2c_peripheral_state {
+	UNPROBED = 0,
+	PROBED,
+	TIMEDOUT,
+};
+
 struct i2c_peripheral {
 	int (*add)(enum i2c_adapter_type type);
 	enum i2c_adapter_type type;
+	enum i2c_peripheral_state state;
+	int tries;
 };
 
 #define MAX_I2C_PERIPHERALS 3
@@ -166,8 +176,8 @@ static struct i2c_client *__add_probed_i2c_device(
 	/* add the i2c device */
 	client = i2c_new_probed_device(adapter, info, addrs, NULL);
 	if (!client)
-		pr_err("%s failed to register device %d-%02x\n",
-		       __func__, bus, info->addr);
+		pr_notice("%s failed to register device %d-%02x\n",
+			  __func__, bus, info->addr);
 	else
 		pr_debug("%s added i2c device %d-%02x\n",
 			 __func__, bus, info->addr);
@@ -347,9 +357,36 @@ static int chromeos_laptop_probe(struct platform_device *pdev)
 		if (i2c_dev->add == NULL)
 			break;
 
-		/* Add the device. Set -EPROBE_DEFER on any failure */
-		if (i2c_dev->add(i2c_dev->type))
+		if (i2c_dev->state == TIMEDOUT || i2c_dev->state == PROBED)
+			continue;
+
+		/*
+		 * Check that the i2c adapter is present.
+		 * -EPROBE_DEFER if missing as the adapter may appear much
+		 * later.
+		 */
+		if (find_i2c_adapter_num(i2c_dev->type) == -ENODEV) {
 			ret = -EPROBE_DEFER;
+			continue;
+		}
+
+		/* Add the device. */
+		if (i2c_dev->add(i2c_dev->type) == -EAGAIN) {
+			/*
+			 * Set -EPROBE_DEFER a limited num of times
+			 * if device is not successfully added.
+			 */
+			if (++i2c_dev->tries < MAX_I2C_DEVICE_DEFERRALS) {
+				ret = -EPROBE_DEFER;
+			} else {
+				/* Ran out of tries. */
+				pr_notice("%s: Ran out of tries for device.\n",
+					  __func__);
+				i2c_dev->state = TIMEDOUT;
+			}
+		} else {
+			i2c_dev->state = PROBED;
+		}
 	}
 
 	return ret;

commit b90b3c4ae06af135e279c9a5aa1c640d22787fc4
Author: Michael Mullin <masmullin@gmail.com>
Date:   Tue Jul 15 20:00:54 2014 -0400

    platform/chrome: Add support for the acer c720p touchscreen.
    
    Add support for the acer c720p touchscreen.
    Tested manually by using the touchscreen on the acer c720p-2664
    
    Based on the following patch by Dave Parker <dparker@chromium.org>:
    https://chromium-review.googlesource.com/#/c/167136/
    
    Signed-off-by: Michael Mullin <masmullin@gmail.com>
    Reviewed-by: Benson Leung <bleung@chromium.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index a53fe76de5d1..15b1b162890f 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -419,6 +419,8 @@ static struct chromeos_laptop acer_ac700 = {
 
 static struct chromeos_laptop acer_c720 = {
 	.i2c_peripherals = {
+		/* Touchscreen. */
+		{ .add = setup_atmel_1664s_ts, I2C_ADAPTER_DESIGNWARE_1 },
 		/* Touchpad. */
 		{ .add = setup_cyapa_tp, I2C_ADAPTER_DESIGNWARE_0 },
 		/* Light Sensor. */

commit 49c68a21d4f308d67b8a4ff8bcf5cd3af53f027d
Author: Robin Schroer <sulamiification@gmail.com>
Date:   Thu May 29 20:45:07 2014 +0200

    platform/chrome: coding style fixes
    
    added blank lines after declarations in some places
    
    Signed-off-by: Robin Schroer <sulamiification@gmail.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 37fa570a7636..a53fe76de5d1 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -187,6 +187,7 @@ static int __find_i2c_adap(struct device *dev, void *data)
 	struct i2c_lookup *lookup = data;
 	static const char *prefix = "i2c-";
 	struct i2c_adapter *adapter;
+
 	if (strncmp(dev_name(dev), prefix, strlen(prefix)) != 0)
 		return 0;
 	adapter = to_i2c_adapter(dev);
@@ -248,6 +249,7 @@ static struct i2c_client *add_i2c_device(const char *name,
 						struct i2c_board_info *info)
 {
 	const unsigned short addr_list[] = { info->addr, I2C_CLIENT_END };
+
 	return __add_probed_i2c_device(name,
 				       find_i2c_adapter_num(type),
 				       info,
@@ -542,6 +544,7 @@ static struct platform_driver cros_platform_driver = {
 static int __init chromeos_laptop_init(void)
 {
 	int ret;
+
 	if (!dmi_check_system(chromeos_laptop_dmi_table)) {
 		pr_debug("%s unsupported system.\n", __func__);
 		return -ENODEV;

commit 963cb6fa0f5f115986e970b9d97440e4906524fa
Author: Gene Chen <gene.chen@intel.com>
Date:   Tue Jun 17 14:02:03 2014 -0700

    platform/chrome: chromeos_laptop - Add Toshiba CB35 Touch
    
    Add support for Leon touch devices, which is the same as
    falco/peppy/wolf on the same buses using the LynxPoint-LP I2C
    via the i2c-designware-pci driver.
    
    Based on these patches from the chromeos-3.8 kernel:
    https://chromium-review.googlesource.com/168351
    https://chromium-review.googlesource.com/173445
    
    Signed-off-by: Gene Chen <gene.chen@intel.com>
    Signed-off-by: Benson Leung <bleung@chromium.org>
    Tested-by: Scot Doyle <lkml14@scotdoyle.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index e0a671075b28..37fa570a7636 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -394,6 +394,13 @@ static struct chromeos_laptop dell_chromebook_11 = {
 	},
 };
 
+static struct chromeos_laptop toshiba_cb35 = {
+	.i2c_peripherals = {
+		/* Touchpad. */
+		{ .add = setup_cyapa_tp, I2C_ADAPTER_DESIGNWARE_0 },
+	},
+};
+
 static struct chromeos_laptop acer_c7_chromebook = {
 	.i2c_peripherals = {
 		/* Touchpad. */
@@ -475,6 +482,14 @@ static struct dmi_system_id chromeos_laptop_dmi_table[] __initdata = {
 		},
 		_CBDD(hp_chromebook_14),
 	},
+	{
+		.ident = "Toshiba CB35",
+		.matches = {
+			DMI_MATCH(DMI_BIOS_VENDOR, "coreboot"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Leon"),
+		},
+		_CBDD(toshiba_cb35),
+	},
 	{
 		.ident = "Acer C7 Chromebook",
 		.matches = {

commit 0e1e5e590a457063c94d55c219b349bcf0d1f93a
Author: Mohammed Habibulla <moch@chromium.org>
Date:   Tue Jun 17 14:02:02 2014 -0700

    platform/chrome: chromeos_laptop - Add Dell Chromebook 11 touch
    
    Add support for Dell Chromebook 11's touch device, which is the same
    as falco/peppy on the same bus using the LynxPoint-LP I2C via the
    i2c-designware-pci driver.
    
    Based on these patches from the chromeos-3.8 kernel:
    https://chromium-review.googlesource.com/#/c/65320/
    https://chromium-review.googlesource.com/#/c/174664/
    
    Signed-off-by: Mohammed Habibulla <moch@chromium.org>
    Signed-off-by: Benson Leung <bleung@chromium.org>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 02e014b8927c..e0a671075b28 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -387,6 +387,13 @@ static struct chromeos_laptop hp_chromebook_14 = {
 	},
 };
 
+static struct chromeos_laptop dell_chromebook_11 = {
+	.i2c_peripherals = {
+		/* Touchpad. */
+		{ .add = setup_cyapa_tp, I2C_ADAPTER_DESIGNWARE_0 },
+	},
+};
+
 static struct chromeos_laptop acer_c7_chromebook = {
 	.i2c_peripherals = {
 		/* Touchpad. */
@@ -452,6 +459,14 @@ static struct dmi_system_id chromeos_laptop_dmi_table[] __initdata = {
 		},
 		_CBDD(chromebook_pixel),
 	},
+	{
+		.ident = "Wolf",
+		.matches = {
+			DMI_MATCH(DMI_BIOS_VENDOR, "coreboot"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Wolf"),
+		},
+		_CBDD(dell_chromebook_11),
+	},
 	{
 		.ident = "HP Chromebook 14",
 		.matches = {

commit 5ea9567f6126846f5dcfa8515d7ef2c238133c0d
Author: Benson Leung <bleung@chromium.org>
Date:   Tue Jun 17 14:02:01 2014 -0700

    platform/chrome: chromeos_laptop - Add HP Chromebook 14
    
    Add support for the trackpad on HP Chromebook 14.
    
    Signed-off-by: Benson Leung <bleung@chromium.org>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index a241e5fa6c83..02e014b8927c 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -380,6 +380,13 @@ static struct chromeos_laptop chromebook_pixel = {
 	},
 };
 
+static struct chromeos_laptop hp_chromebook_14 = {
+	.i2c_peripherals = {
+		/* Touchpad. */
+		{ .add = setup_cyapa_tp, I2C_ADAPTER_DESIGNWARE_0 },
+	},
+};
+
 static struct chromeos_laptop acer_c7_chromebook = {
 	.i2c_peripherals = {
 		/* Touchpad. */
@@ -445,6 +452,14 @@ static struct dmi_system_id chromeos_laptop_dmi_table[] __initdata = {
 		},
 		_CBDD(chromebook_pixel),
 	},
+	{
+		.ident = "HP Chromebook 14",
+		.matches = {
+			DMI_MATCH(DMI_BIOS_VENDOR, "coreboot"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Falco"),
+		},
+		_CBDD(hp_chromebook_14),
+	},
 	{
 		.ident = "Acer C7 Chromebook",
 		.matches = {

commit da3b0ab75aadab63d1ffd5563100c9386e444dad
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Tue Jun 17 14:02:00 2014 -0700

    platform/chrome: chromeos_laptop - Add support for Acer C720
    
    Acer C720 has touchpad and light sensor connected to a separate I2C buses.
    Since the designware I2C host controller driver has two instances on this
    particular machine we need a way to match the correct instance. Add support
    for this and then register both C720 touchpad and light sensor.
    
    This code is based on following patch from Benson Leung:
    
    https://patchwork.kernel.org/patch/3074411/
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Signed-off-by: Benson Leung <bleung@chromium.org>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 7f1a2e2711bd..a241e5fa6c83 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -45,6 +45,8 @@ static const char *i2c_adapter_names[] = {
 	"SMBus I801 adapter",
 	"i915 gmbus vga",
 	"i915 gmbus panel",
+	"i2c-designware-pci",
+	"i2c-designware-pci",
 };
 
 /* Keep this enum consistent with i2c_adapter_names */
@@ -52,6 +54,8 @@ enum i2c_adapter_type {
 	I2C_ADAPTER_SMBUS = 0,
 	I2C_ADAPTER_VGADDC,
 	I2C_ADAPTER_PANEL,
+	I2C_ADAPTER_DESIGNWARE_0,
+	I2C_ADAPTER_DESIGNWARE_1,
 };
 
 struct i2c_peripheral {
@@ -172,29 +176,42 @@ static struct i2c_client *__add_probed_i2c_device(
 	return client;
 }
 
+struct i2c_lookup {
+	const char *name;
+	int instance;
+	int n;
+};
+
 static int __find_i2c_adap(struct device *dev, void *data)
 {
-	const char *name = data;
+	struct i2c_lookup *lookup = data;
 	static const char *prefix = "i2c-";
 	struct i2c_adapter *adapter;
 	if (strncmp(dev_name(dev), prefix, strlen(prefix)) != 0)
 		return 0;
 	adapter = to_i2c_adapter(dev);
-	return (strncmp(adapter->name, name, strlen(name)) == 0);
+	if (strncmp(adapter->name, lookup->name, strlen(lookup->name)) == 0 &&
+	    lookup->n++ == lookup->instance)
+		return 1;
+	return 0;
 }
 
 static int find_i2c_adapter_num(enum i2c_adapter_type type)
 {
 	struct device *dev = NULL;
 	struct i2c_adapter *adapter;
-	const char *name = i2c_adapter_names[type];
+	struct i2c_lookup lookup;
+
+	memset(&lookup, 0, sizeof(lookup));
+	lookup.name = i2c_adapter_names[type];
+	lookup.instance = (type == I2C_ADAPTER_DESIGNWARE_1) ? 1 : 0;
+
 	/* find the adapter by name */
-	dev = bus_find_device(&i2c_bus_type, NULL, (void *)name,
-			      __find_i2c_adap);
+	dev = bus_find_device(&i2c_bus_type, NULL, &lookup, __find_i2c_adap);
 	if (!dev) {
 		/* Adapters may appear later. Deferred probing will retry */
 		pr_notice("%s: i2c adapter %s not found on system.\n", __func__,
-			  name);
+			  lookup.name);
 		return -ENODEV;
 	}
 	adapter = to_i2c_adapter(dev);
@@ -377,6 +394,15 @@ static struct chromeos_laptop acer_ac700 = {
 	},
 };
 
+static struct chromeos_laptop acer_c720 = {
+	.i2c_peripherals = {
+		/* Touchpad. */
+		{ .add = setup_cyapa_tp, I2C_ADAPTER_DESIGNWARE_0 },
+		/* Light Sensor. */
+		{ .add = setup_isl29018_als, I2C_ADAPTER_DESIGNWARE_1 },
+	},
+};
+
 static struct chromeos_laptop hp_pavilion_14_chromebook = {
 	.i2c_peripherals = {
 		/* Touchpad. */
@@ -433,6 +459,13 @@ static struct dmi_system_id chromeos_laptop_dmi_table[] __initdata = {
 		},
 		_CBDD(acer_ac700),
 	},
+	{
+		.ident = "Acer C720",
+		.matches = {
+			DMI_MATCH(DMI_PRODUCT_NAME, "Peppy"),
+		},
+		_CBDD(acer_c720),
+	},
 	{
 		.ident = "HP Pavilion 14 Chromebook",
 		.matches = {

commit 61dc1abae64854c7cef543598b9e6f04886c4ebd
Author: Nick Dyer <nick.dyer@itdev.co.uk>
Date:   Sun May 18 23:16:49 2014 -0700

    Input: atmel_mxt_ts - read screen config from chip
    
    By reading the touchscreen configuration from the settings that the
    maXTouch chip is actually using, we can remove some platform data.
    
    The matrix size is not used for anything, and results in some rather
    confusing code to re-read it because it may change when configuration
    is downloaded, so don't print it out.
    
    Signed-off-by: Nick Dyer <nick.dyer@itdev.co.uk>
    Acked-by: Benson Leung <bleung@chromium.org>
    Acked-by: Yufeng Shen <miletus@chromium.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 8b7523ab62e5..7f1a2e2711bd 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -94,9 +94,6 @@ static int mxt_t19_keys[] = {
 };
 
 static struct mxt_platform_data atmel_224s_tp_platform_data = {
-	.x_size			= 102*20,
-	.y_size			= 68*20,
-	.orient			= MXT_VERTICAL_FLIP,
 	.irqflags		= IRQF_TRIGGER_FALLING,
 	.t19_num_keys		= ARRAY_SIZE(mxt_t19_keys),
 	.t19_keymap		= mxt_t19_keys,
@@ -111,9 +108,6 @@ static struct i2c_board_info atmel_224s_tp_device = {
 };
 
 static struct mxt_platform_data atmel_1664s_platform_data = {
-	.x_size			= 1700,
-	.y_size			= 2560,
-	.orient			= MXT_ROTATED_90_COUNTER,
 	.irqflags		= IRQF_TRIGGER_FALLING,
 	.config			= NULL,
 	.config_length		= 0,

commit fb5e4c3ee140b29e1935b4bbb19c319177bed231
Author: Nick Dyer <nick.dyer@itdev.co.uk>
Date:   Sun May 18 23:00:15 2014 -0700

    Input: atmel_mxt_ts - improve T19 GPIO keys handling
    
     * The mapping of the GPIO numbers into the T19 status byte varies between
       different maXTouch chips. Some have up to 7 GPIOs. Allowing a keycode array
       of up to 8 items is simpler and more generic. So replace #define with
       configurable number of keys which also allows the removal of is_tp.
     * Rename platform data parameters to include "t19" to prevent confusion with
       T15 key array.
     * Probe aborts early on when pdata is NULL, so no need to check.
     * Move "int i" to beginning of function (mixed declarations and code)
     * Use API calls rather than __set_bit()
     * Remove unused dev variable.
    
    Signed-off-by: Nick Dyer <nick.dyer@itdev.co.uk>
    Acked-by: Yufeng Shen <miletus@chromium.org>
    Reviewed-by: Henrik Rydberg <rydberg@euromail.se>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 2559a0407c58..8b7523ab62e5 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -84,16 +84,22 @@ static struct i2c_board_info tsl2563_als_device = {
 	I2C_BOARD_INFO("tsl2563", TAOS_ALS_I2C_ADDR),
 };
 
+static int mxt_t19_keys[] = {
+	KEY_RESERVED,
+	KEY_RESERVED,
+	KEY_RESERVED,
+	KEY_RESERVED,
+	KEY_RESERVED,
+	BTN_LEFT
+};
+
 static struct mxt_platform_data atmel_224s_tp_platform_data = {
 	.x_size			= 102*20,
 	.y_size			= 68*20,
 	.orient			= MXT_VERTICAL_FLIP,
 	.irqflags		= IRQF_TRIGGER_FALLING,
-	.is_tp			= true,
-	.key_map		= { KEY_RESERVED,
-				    KEY_RESERVED,
-				    KEY_RESERVED,
-				    BTN_LEFT },
+	.t19_num_keys		= ARRAY_SIZE(mxt_t19_keys),
+	.t19_keymap		= mxt_t19_keys,
 	.config			= NULL,
 	.config_length		= 0,
 };
@@ -109,7 +115,6 @@ static struct mxt_platform_data atmel_1664s_platform_data = {
 	.y_size			= 2560,
 	.orient			= MXT_ROTATED_90_COUNTER,
 	.irqflags		= IRQF_TRIGGER_FALLING,
-	.is_tp			= false,
 	.config			= NULL,
 	.config_length		= 0,
 };

commit 2cefdb1f0a27150755ef2730bafc58bf2ed16571
Author: Nick Dyer <nick.dyer@itdev.co.uk>
Date:   Sun May 18 22:59:20 2014 -0700

    Input: atmel_mxt_ts - remove unnecessary platform data
    
    It is not necessary to download these values to the maXTouch chip on every
    probe, since they are stored in NVRAM. It makes life difficult when tuning
    the device to keep them in sync with the config array/file, and requires a
    new kernel build for minor tweaks.
    
    These parameters only represent a tiny subset of the available
    configuration options, tracking all of these options in platform data would
    be a endless task. In addition, different versions of maXTouch chips may
    have these values in different places or may not even have them at all.
    
    Having these values also makes life more complex for device tree and other
    platforms where having to define a static configuration isn't helpful.
    
    Signed-off-by: Nick Dyer <nick.dyer@itdev.co.uk>
    Acked-by: Benson Leung <bleung@chromium.org>
    Acked-by: Yufeng Shen <miletus@chromium.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 7f3aad0e115c..2559a0407c58 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -85,13 +85,8 @@ static struct i2c_board_info tsl2563_als_device = {
 };
 
 static struct mxt_platform_data atmel_224s_tp_platform_data = {
-	.x_line			= 18,
-	.y_line			= 12,
 	.x_size			= 102*20,
 	.y_size			= 68*20,
-	.blen			= 0x80,	/* Gain setting is in upper 4 bits */
-	.threshold		= 0x32,
-	.voltage		= 0,	/* 3.3V */
 	.orient			= MXT_VERTICAL_FLIP,
 	.irqflags		= IRQF_TRIGGER_FALLING,
 	.is_tp			= true,
@@ -110,13 +105,8 @@ static struct i2c_board_info atmel_224s_tp_device = {
 };
 
 static struct mxt_platform_data atmel_1664s_platform_data = {
-	.x_line			= 32,
-	.y_line			= 50,
 	.x_size			= 1700,
 	.y_size			= 2560,
-	.blen			= 0x89,	/* Gain setting is in upper 4 bits */
-	.threshold		= 0x28,
-	.voltage		= 0,	/* 3.3V */
 	.orient			= MXT_ROTATED_90_COUNTER,
 	.irqflags		= IRQF_TRIGGER_FALLING,
 	.is_tp			= false,

commit 2b8454a75b90d7cd1ac325a0baba77244733354f
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Wed Nov 27 11:34:58 2013 +0800

    platform/chrome: unregister platform driver/device when module exit
    
    We have registered platform driver and device when module
    init, and need unregister them when module exit.
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 446ef0f9c256..7f3aad0e115c 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -511,6 +511,9 @@ static void __exit chromeos_laptop_exit(void)
 		i2c_unregister_device(tp);
 	if (ts)
 		i2c_unregister_device(ts);
+
+	platform_device_unregister(cros_platform_device);
+	platform_driver_unregister(&cros_platform_driver);
 }
 
 module_init(chromeos_laptop_init);

commit 6d3c1afe7367447c8f7d2fec7a132f723834efd1
Author: Olof Johansson <olof@lixom.net>
Date:   Mon Nov 25 13:10:25 2013 -0800

    platform/chrome: Make i2c_adapter_names static
    
    Not used outside of the file, so declaration should be static. Picked up by
    sparse:
    
    drivers/platform/chrome/chromeos_laptop.c:44:12: warning: symbol
        'i2c_adapter_names' was not declared. Should it be static?
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Reviewed-by: Benson Leung <bleung@chromium.org>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 1c2747f119d1..446ef0f9c256 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -41,7 +41,7 @@ static struct i2c_client *als;
 static struct i2c_client *tp;
 static struct i2c_client *ts;
 
-const char *i2c_adapter_names[] = {
+static const char *i2c_adapter_names[] = {
 	"SMBus I801 adapter",
 	"i915 gmbus vga",
 	"i915 gmbus panel",

commit cdddd23fa2536cd4273e95d66b6ef83e67b747bf
Author: Benson Leung <bleung@chromium.org>
Date:   Sun Oct 20 20:58:26 2013 -0700

    platform/chrome: chromeos_laptop - fix incorrect placement of __initdata tag
    
    __initdata tag should be placed between the variable name and equal
    sign for the variable to be placed in the intended .init.data section.
    
    Signed-off-by: Benson Leung <bleung@chromium.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index e542330f8048..1c2747f119d1 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -406,7 +406,7 @@ static struct chromeos_laptop cr48 = {
 	.callback = chromeos_laptop_dmi_matched, \
 	.driver_data = (void *)&board_
 
-static struct dmi_system_id __initdata chromeos_laptop_dmi_table[] = {
+static struct dmi_system_id chromeos_laptop_dmi_table[] __initdata = {
 	{
 		.ident = "Samsung Series 5 550",
 		.matches = {

commit 9ad3692458c387eb9537da73b2b75841ed7acdaf
Author: Benson Leung <bleung@chromium.org>
Date:   Sun Oct 20 20:58:25 2013 -0700

    platform/chrome: chromeos_laptop - Use deferred probing
    
    Further refactor chromeos_laptop, adding a probe function.
    Init will call dmi_check_system, but will only use the match to select
    a chromeos_laptop structure of the current board.
    
    Probe will add the devices, and on errors return -EPROBE_DEFER.
    If i2c adapters are loaded after chromeos_laptop inits, the deferred
    probe will instantiate the peripherals when the bus appears.
    
    Signed-off-by: Benson Leung <bleung@chromium.org>
    Reviewed-by: Aaron Durbin <adurbin@chromium.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 5c69cfd97ff0..e542330f8048 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -27,6 +27,7 @@
 #include <linux/input.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
+#include <linux/platform_device.h>
 
 #define ATMEL_TP_I2C_ADDR	0x4b
 #define ATMEL_TP_I2C_BL_ADDR	0x25
@@ -54,7 +55,7 @@ enum i2c_adapter_type {
 };
 
 struct i2c_peripheral {
-	void (*add)(enum i2c_adapter_type type);
+	int (*add)(enum i2c_adapter_type type);
 	enum i2c_adapter_type type;
 };
 
@@ -64,20 +65,22 @@ struct chromeos_laptop {
 	struct i2c_peripheral i2c_peripherals[MAX_I2C_PERIPHERALS];
 };
 
-static struct i2c_board_info __initdata cyapa_device = {
+static struct chromeos_laptop *cros_laptop;
+
+static struct i2c_board_info cyapa_device = {
 	I2C_BOARD_INFO("cyapa", CYAPA_TP_I2C_ADDR),
 	.flags		= I2C_CLIENT_WAKE,
 };
 
-static struct i2c_board_info __initdata isl_als_device = {
+static struct i2c_board_info isl_als_device = {
 	I2C_BOARD_INFO("isl29018", ISL_ALS_I2C_ADDR),
 };
 
-static struct i2c_board_info __initdata tsl2583_als_device = {
+static struct i2c_board_info tsl2583_als_device = {
 	I2C_BOARD_INFO("tsl2583", TAOS_ALS_I2C_ADDR),
 };
 
-static struct i2c_board_info __initdata tsl2563_als_device = {
+static struct i2c_board_info tsl2563_als_device = {
 	I2C_BOARD_INFO("tsl2563", TAOS_ALS_I2C_ADDR),
 };
 
@@ -100,7 +103,7 @@ static struct mxt_platform_data atmel_224s_tp_platform_data = {
 	.config_length		= 0,
 };
 
-static struct i2c_board_info __initdata atmel_224s_tp_device = {
+static struct i2c_board_info atmel_224s_tp_device = {
 	I2C_BOARD_INFO("atmel_mxt_tp", ATMEL_TP_I2C_ADDR),
 	.platform_data = &atmel_224s_tp_platform_data,
 	.flags		= I2C_CLIENT_WAKE,
@@ -121,13 +124,13 @@ static struct mxt_platform_data atmel_1664s_platform_data = {
 	.config_length		= 0,
 };
 
-static struct i2c_board_info __initdata atmel_1664s_device = {
+static struct i2c_board_info atmel_1664s_device = {
 	I2C_BOARD_INFO("atmel_mxt_ts", ATMEL_TS_I2C_ADDR),
 	.platform_data = &atmel_1664s_platform_data,
 	.flags		= I2C_CLIENT_WAKE,
 };
 
-static struct i2c_client __init *__add_probed_i2c_device(
+static struct i2c_client *__add_probed_i2c_device(
 		const char *name,
 		int bus,
 		struct i2c_board_info *info,
@@ -180,7 +183,7 @@ static struct i2c_client __init *__add_probed_i2c_device(
 	return client;
 }
 
-static int __init __find_i2c_adap(struct device *dev, void *data)
+static int __find_i2c_adap(struct device *dev, void *data)
 {
 	const char *name = data;
 	static const char *prefix = "i2c-";
@@ -191,7 +194,7 @@ static int __init __find_i2c_adap(struct device *dev, void *data)
 	return (strncmp(adapter->name, name, strlen(name)) == 0);
 }
 
-static int __init find_i2c_adapter_num(enum i2c_adapter_type type)
+static int find_i2c_adapter_num(enum i2c_adapter_type type)
 {
 	struct device *dev = NULL;
 	struct i2c_adapter *adapter;
@@ -200,8 +203,9 @@ static int __init find_i2c_adapter_num(enum i2c_adapter_type type)
 	dev = bus_find_device(&i2c_bus_type, NULL, (void *)name,
 			      __find_i2c_adap);
 	if (!dev) {
-		pr_err("%s: i2c adapter %s not found on system.\n", __func__,
-		       name);
+		/* Adapters may appear later. Deferred probing will retry */
+		pr_notice("%s: i2c adapter %s not found on system.\n", __func__,
+			  name);
 		return -ENODEV;
 	}
 	adapter = to_i2c_adapter(dev);
@@ -216,7 +220,7 @@ static int __init find_i2c_adapter_num(enum i2c_adapter_type type)
  * Returns NULL if no devices found.
  * See Documentation/i2c/instantiating-devices for more information.
  */
-static __init struct i2c_client *add_probed_i2c_device(
+static struct i2c_client *add_probed_i2c_device(
 		const char *name,
 		enum i2c_adapter_type type,
 		struct i2c_board_info *info,
@@ -233,7 +237,7 @@ static __init struct i2c_client *add_probed_i2c_device(
  * info->addr.
  * Returns NULL if no device found.
  */
-static __init struct i2c_client *add_i2c_device(const char *name,
+static struct i2c_client *add_i2c_device(const char *name,
 						enum i2c_adapter_type type,
 						struct i2c_board_info *info)
 {
@@ -244,65 +248,87 @@ static __init struct i2c_client *add_i2c_device(const char *name,
 				       addr_list);
 }
 
-static int __init setup_cyapa_tp(enum i2c_adapter_type type)
+static int setup_cyapa_tp(enum i2c_adapter_type type)
 {
+	if (tp)
+		return 0;
+
 	/* add cyapa touchpad */
 	tp = add_i2c_device("trackpad", type, &cyapa_device);
-	return 0;
+	return (!tp) ? -EAGAIN : 0;
 }
 
-static int __init setup_atmel_224s_tp(enum i2c_adapter_type type)
+static int setup_atmel_224s_tp(enum i2c_adapter_type type)
 {
 	const unsigned short addr_list[] = { ATMEL_TP_I2C_BL_ADDR,
 					     ATMEL_TP_I2C_ADDR,
 					     I2C_CLIENT_END };
+	if (tp)
+		return 0;
 
 	/* add atmel mxt touchpad */
 	tp = add_probed_i2c_device("trackpad", type,
 				   &atmel_224s_tp_device, addr_list);
-	return 0;
+	return (!tp) ? -EAGAIN : 0;
 }
 
-static int __init setup_atmel_1664s_ts(enum i2c_adapter_type type)
+static int setup_atmel_1664s_ts(enum i2c_adapter_type type)
 {
 	const unsigned short addr_list[] = { ATMEL_TS_I2C_BL_ADDR,
 					     ATMEL_TS_I2C_ADDR,
 					     I2C_CLIENT_END };
+	if (ts)
+		return 0;
 
 	/* add atmel mxt touch device */
 	ts = add_probed_i2c_device("touchscreen", type,
 				   &atmel_1664s_device, addr_list);
-	return 0;
+	return (!ts) ? -EAGAIN : 0;
 }
 
-static int __init setup_isl29018_als(enum i2c_adapter_type type)
+static int setup_isl29018_als(enum i2c_adapter_type type)
 {
+	if (als)
+		return 0;
+
 	/* add isl29018 light sensor */
 	als = add_i2c_device("lightsensor", type, &isl_als_device);
-	return 0;
+	return (!als) ? -EAGAIN : 0;
 }
 
-static int __init setup_tsl2583_als(enum i2c_adapter_type type)
+static int setup_tsl2583_als(enum i2c_adapter_type type)
 {
+	if (als)
+		return 0;
+
 	/* add tsl2583 light sensor */
 	als = add_i2c_device(NULL, type, &tsl2583_als_device);
-	return 0;
+	return (!als) ? -EAGAIN : 0;
 }
 
-static int __init setup_tsl2563_als(enum i2c_adapter_type type)
+static int setup_tsl2563_als(enum i2c_adapter_type type)
 {
+	if (als)
+		return 0;
+
 	/* add tsl2563 light sensor */
 	als = add_i2c_device(NULL, type, &tsl2563_als_device);
-	return 0;
+	return (!als) ? -EAGAIN : 0;
 }
 
-static int __init
-chromeos_laptop_add_peripherals(const struct dmi_system_id *id)
+static int __init chromeos_laptop_dmi_matched(const struct dmi_system_id *id)
 {
-	int i;
-	struct chromeos_laptop *cros_laptop = (void *)id->driver_data;
+	cros_laptop = (void *)id->driver_data;
+	pr_debug("DMI Matched %s.\n", id->ident);
 
-	pr_debug("Adding peripherals for %s.\n", id->ident);
+	/* Indicate to dmi_scan that processing is done. */
+	return 1;
+}
+
+static int chromeos_laptop_probe(struct platform_device *pdev)
+{
+	int i;
+	int ret = 0;
 
 	for (i = 0; i < MAX_I2C_PERIPHERALS; i++) {
 		struct i2c_peripheral *i2c_dev;
@@ -313,15 +339,15 @@ chromeos_laptop_add_peripherals(const struct dmi_system_id *id)
 		if (i2c_dev->add == NULL)
 			break;
 
-		/* Add the device. */
-		i2c_dev->add(i2c_dev->type);
+		/* Add the device. Set -EPROBE_DEFER on any failure */
+		if (i2c_dev->add(i2c_dev->type))
+			ret = -EPROBE_DEFER;
 	}
 
-	/* Indicate to dmi_scan that processing is done. */
-	return 1;
+	return ret;
 }
 
-static struct chromeos_laptop samsung_series_5_550 __initdata = {
+static struct chromeos_laptop samsung_series_5_550 = {
 	.i2c_peripherals = {
 		/* Touchpad. */
 		{ .add = setup_cyapa_tp, I2C_ADAPTER_SMBUS },
@@ -330,14 +356,14 @@ static struct chromeos_laptop samsung_series_5_550 __initdata = {
 	},
 };
 
-static struct chromeos_laptop samsung_series_5 __initdata = {
+static struct chromeos_laptop samsung_series_5 = {
 	.i2c_peripherals = {
 		/* Light Sensor. */
 		{ .add = setup_tsl2583_als, I2C_ADAPTER_SMBUS },
 	},
 };
 
-static struct chromeos_laptop chromebook_pixel __initdata = {
+static struct chromeos_laptop chromebook_pixel = {
 	.i2c_peripherals = {
 		/* Touch Screen. */
 		{ .add = setup_atmel_1664s_ts, I2C_ADAPTER_PANEL },
@@ -348,28 +374,28 @@ static struct chromeos_laptop chromebook_pixel __initdata = {
 	},
 };
 
-static struct chromeos_laptop acer_c7_chromebook __initdata = {
+static struct chromeos_laptop acer_c7_chromebook = {
 	.i2c_peripherals = {
 		/* Touchpad. */
 		{ .add = setup_cyapa_tp, I2C_ADAPTER_SMBUS },
 	},
 };
 
-static struct chromeos_laptop acer_ac700 __initdata = {
+static struct chromeos_laptop acer_ac700 = {
 	.i2c_peripherals = {
 		/* Light Sensor. */
 		{ .add = setup_tsl2563_als, I2C_ADAPTER_SMBUS },
 	},
 };
 
-static struct chromeos_laptop hp_pavilion_14_chromebook __initdata = {
+static struct chromeos_laptop hp_pavilion_14_chromebook = {
 	.i2c_peripherals = {
 		/* Touchpad. */
 		{ .add = setup_cyapa_tp, I2C_ADAPTER_SMBUS },
 	},
 };
 
-static struct chromeos_laptop cr48 __initdata = {
+static struct chromeos_laptop cr48 = {
 	.i2c_peripherals = {
 		/* Light Sensor. */
 		{ .add = setup_tsl2563_als, I2C_ADAPTER_SMBUS },
@@ -377,7 +403,7 @@ static struct chromeos_laptop cr48 __initdata = {
 };
 
 #define _CBDD(board_) \
-	.callback = &chromeos_laptop_add_peripherals, \
+	.callback = chromeos_laptop_dmi_matched, \
 	.driver_data = (void *)&board_
 
 static struct dmi_system_id __initdata chromeos_laptop_dmi_table[] = {
@@ -436,13 +462,45 @@ static struct dmi_system_id __initdata chromeos_laptop_dmi_table[] = {
 };
 MODULE_DEVICE_TABLE(dmi, chromeos_laptop_dmi_table);
 
+static struct platform_device *cros_platform_device;
+
+static struct platform_driver cros_platform_driver = {
+	.driver = {
+		.name = "chromeos_laptop",
+		.owner = THIS_MODULE,
+	},
+	.probe = chromeos_laptop_probe,
+};
+
 static int __init chromeos_laptop_init(void)
 {
+	int ret;
 	if (!dmi_check_system(chromeos_laptop_dmi_table)) {
 		pr_debug("%s unsupported system.\n", __func__);
 		return -ENODEV;
 	}
+
+	ret = platform_driver_register(&cros_platform_driver);
+	if (ret)
+		return ret;
+
+	cros_platform_device = platform_device_alloc("chromeos_laptop", -1);
+	if (!cros_platform_device) {
+		ret = -ENOMEM;
+		goto fail_platform_device1;
+	}
+
+	ret = platform_device_add(cros_platform_device);
+	if (ret)
+		goto fail_platform_device2;
+
 	return 0;
+
+fail_platform_device2:
+	platform_device_put(cros_platform_device);
+fail_platform_device1:
+	platform_driver_unregister(&cros_platform_driver);
+	return ret;
 }
 
 static void __exit chromeos_laptop_exit(void)

commit ec199dd57ef71858b53828283ac495ed82164933
Author: Aaron Durbin <adurbin@chromium.org>
Date:   Sun Oct 20 20:58:24 2013 -0700

    platform/chrome: chromeos_laptop - Restructure device associations
    
    The previous code had a single DMI matching entry
    for each device on a board. Instead provide a single
    DMI entry for each board which references a structure
    about each board that lists the associated peripherals.
    This allows for a lower number of DMI matching sequences
    as well making it easier to add new boards.
    
    Signed-off-by: Aaron Durbin <adurbin@chromium.org>
    Signed-off-by: Benson Leung <bleung@chromium.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 3e5b4497a1d0..5c69cfd97ff0 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -53,6 +53,17 @@ enum i2c_adapter_type {
 	I2C_ADAPTER_PANEL,
 };
 
+struct i2c_peripheral {
+	void (*add)(enum i2c_adapter_type type);
+	enum i2c_adapter_type type;
+};
+
+#define MAX_I2C_PERIPHERALS 3
+
+struct chromeos_laptop {
+	struct i2c_peripheral i2c_peripherals[MAX_I2C_PERIPHERALS];
+};
+
 static struct i2c_board_info __initdata cyapa_device = {
 	I2C_BOARD_INFO("cyapa", CYAPA_TP_I2C_ADDR),
 	.flags		= I2C_CLIENT_WAKE,
@@ -233,149 +244,193 @@ static __init struct i2c_client *add_i2c_device(const char *name,
 				       addr_list);
 }
 
-
-static struct i2c_client __init *add_smbus_device(const char *name,
-						  struct i2c_board_info *info)
-{
-	return add_i2c_device(name, I2C_ADAPTER_SMBUS, info);
-}
-
-static int __init setup_cyapa_smbus_tp(const struct dmi_system_id *id)
+static int __init setup_cyapa_tp(enum i2c_adapter_type type)
 {
-	/* add cyapa touchpad on smbus */
-	tp = add_smbus_device("trackpad", &cyapa_device);
+	/* add cyapa touchpad */
+	tp = add_i2c_device("trackpad", type, &cyapa_device);
 	return 0;
 }
 
-static int __init setup_atmel_224s_tp(const struct dmi_system_id *id)
+static int __init setup_atmel_224s_tp(enum i2c_adapter_type type)
 {
 	const unsigned short addr_list[] = { ATMEL_TP_I2C_BL_ADDR,
 					     ATMEL_TP_I2C_ADDR,
 					     I2C_CLIENT_END };
 
-	/* add atmel mxt touchpad on VGA DDC GMBus */
-	tp = add_probed_i2c_device("trackpad", I2C_ADAPTER_VGADDC,
+	/* add atmel mxt touchpad */
+	tp = add_probed_i2c_device("trackpad", type,
 				   &atmel_224s_tp_device, addr_list);
 	return 0;
 }
 
-static int __init setup_atmel_1664s_ts(const struct dmi_system_id *id)
+static int __init setup_atmel_1664s_ts(enum i2c_adapter_type type)
 {
 	const unsigned short addr_list[] = { ATMEL_TS_I2C_BL_ADDR,
 					     ATMEL_TS_I2C_ADDR,
 					     I2C_CLIENT_END };
 
-	/* add atmel mxt touch device on PANEL GMBus */
-	ts = add_probed_i2c_device("touchscreen", I2C_ADAPTER_PANEL,
+	/* add atmel mxt touch device */
+	ts = add_probed_i2c_device("touchscreen", type,
 				   &atmel_1664s_device, addr_list);
 	return 0;
 }
 
-
-static int __init setup_isl29018_als(const struct dmi_system_id *id)
+static int __init setup_isl29018_als(enum i2c_adapter_type type)
 {
 	/* add isl29018 light sensor */
-	als = add_smbus_device("lightsensor", &isl_als_device);
+	als = add_i2c_device("lightsensor", type, &isl_als_device);
 	return 0;
 }
 
-static int __init setup_isl29023_als(const struct dmi_system_id *id)
+static int __init setup_tsl2583_als(enum i2c_adapter_type type)
 {
-	/* add isl29023 light sensor on Panel GMBus */
-	als = add_i2c_device("lightsensor", I2C_ADAPTER_PANEL,
-			     &isl_als_device);
+	/* add tsl2583 light sensor */
+	als = add_i2c_device(NULL, type, &tsl2583_als_device);
 	return 0;
 }
 
-static int __init setup_tsl2583_als(const struct dmi_system_id *id)
+static int __init setup_tsl2563_als(enum i2c_adapter_type type)
 {
-	/* add tsl2583 light sensor on smbus */
-	als = add_smbus_device(NULL, &tsl2583_als_device);
+	/* add tsl2563 light sensor */
+	als = add_i2c_device(NULL, type, &tsl2563_als_device);
 	return 0;
 }
 
-static int __init setup_tsl2563_als(const struct dmi_system_id *id)
+static int __init
+chromeos_laptop_add_peripherals(const struct dmi_system_id *id)
 {
-	/* add tsl2563 light sensor on smbus */
-	als = add_smbus_device(NULL, &tsl2563_als_device);
-	return 0;
+	int i;
+	struct chromeos_laptop *cros_laptop = (void *)id->driver_data;
+
+	pr_debug("Adding peripherals for %s.\n", id->ident);
+
+	for (i = 0; i < MAX_I2C_PERIPHERALS; i++) {
+		struct i2c_peripheral *i2c_dev;
+
+		i2c_dev = &cros_laptop->i2c_peripherals[i];
+
+		/* No more peripherals. */
+		if (i2c_dev->add == NULL)
+			break;
+
+		/* Add the device. */
+		i2c_dev->add(i2c_dev->type);
+	}
+
+	/* Indicate to dmi_scan that processing is done. */
+	return 1;
 }
 
+static struct chromeos_laptop samsung_series_5_550 __initdata = {
+	.i2c_peripherals = {
+		/* Touchpad. */
+		{ .add = setup_cyapa_tp, I2C_ADAPTER_SMBUS },
+		/* Light Sensor. */
+		{ .add = setup_isl29018_als, I2C_ADAPTER_SMBUS },
+	},
+};
+
+static struct chromeos_laptop samsung_series_5 __initdata = {
+	.i2c_peripherals = {
+		/* Light Sensor. */
+		{ .add = setup_tsl2583_als, I2C_ADAPTER_SMBUS },
+	},
+};
+
+static struct chromeos_laptop chromebook_pixel __initdata = {
+	.i2c_peripherals = {
+		/* Touch Screen. */
+		{ .add = setup_atmel_1664s_ts, I2C_ADAPTER_PANEL },
+		/* Touchpad. */
+		{ .add = setup_atmel_224s_tp, I2C_ADAPTER_VGADDC },
+		/* Light Sensor. */
+		{ .add = setup_isl29018_als, I2C_ADAPTER_PANEL },
+	},
+};
+
+static struct chromeos_laptop acer_c7_chromebook __initdata = {
+	.i2c_peripherals = {
+		/* Touchpad. */
+		{ .add = setup_cyapa_tp, I2C_ADAPTER_SMBUS },
+	},
+};
+
+static struct chromeos_laptop acer_ac700 __initdata = {
+	.i2c_peripherals = {
+		/* Light Sensor. */
+		{ .add = setup_tsl2563_als, I2C_ADAPTER_SMBUS },
+	},
+};
+
+static struct chromeos_laptop hp_pavilion_14_chromebook __initdata = {
+	.i2c_peripherals = {
+		/* Touchpad. */
+		{ .add = setup_cyapa_tp, I2C_ADAPTER_SMBUS },
+	},
+};
+
+static struct chromeos_laptop cr48 __initdata = {
+	.i2c_peripherals = {
+		/* Light Sensor. */
+		{ .add = setup_tsl2563_als, I2C_ADAPTER_SMBUS },
+	},
+};
+
+#define _CBDD(board_) \
+	.callback = &chromeos_laptop_add_peripherals, \
+	.driver_data = (void *)&board_
+
 static struct dmi_system_id __initdata chromeos_laptop_dmi_table[] = {
 	{
-		.ident = "Samsung Series 5 550 - Touchpad",
+		.ident = "Samsung Series 5 550",
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "SAMSUNG"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Lumpy"),
 		},
-		.callback = setup_cyapa_smbus_tp,
-	},
-	{
-		.ident = "Chromebook Pixel - Touchscreen",
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "GOOGLE"),
-			DMI_MATCH(DMI_PRODUCT_NAME, "Link"),
-		},
-		.callback = setup_atmel_1664s_ts,
-	},
-	{
-		.ident = "Chromebook Pixel - Touchpad",
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "GOOGLE"),
-			DMI_MATCH(DMI_PRODUCT_NAME, "Link"),
-		},
-		.callback = setup_atmel_224s_tp,
+		_CBDD(samsung_series_5_550),
 	},
 	{
-		.ident = "Samsung Series 5 550 - Light Sensor",
+		.ident = "Samsung Series 5",
 		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "SAMSUNG"),
-			DMI_MATCH(DMI_PRODUCT_NAME, "Lumpy"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Alex"),
 		},
-		.callback = setup_isl29018_als,
+		_CBDD(samsung_series_5),
 	},
 	{
-		.ident = "Chromebook Pixel - Light Sensor",
+		.ident = "Chromebook Pixel",
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "GOOGLE"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Link"),
 		},
-		.callback = setup_isl29023_als,
+		_CBDD(chromebook_pixel),
 	},
 	{
-		.ident = "Acer C7 Chromebook - Touchpad",
+		.ident = "Acer C7 Chromebook",
 		.matches = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "Parrot"),
 		},
-		.callback = setup_cyapa_smbus_tp,
+		_CBDD(acer_c7_chromebook),
 	},
 	{
-		.ident = "HP Pavilion 14 Chromebook - Touchpad",
+		.ident = "Acer AC700",
 		.matches = {
-			DMI_MATCH(DMI_PRODUCT_NAME, "Butterfly"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "ZGB"),
 		},
-		.callback = setup_cyapa_smbus_tp,
+		_CBDD(acer_ac700),
 	},
 	{
-		.ident = "Samsung Series 5 - Light Sensor",
+		.ident = "HP Pavilion 14 Chromebook",
 		.matches = {
-			DMI_MATCH(DMI_PRODUCT_NAME, "Alex"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Butterfly"),
 		},
-		.callback = setup_tsl2583_als,
+		_CBDD(hp_pavilion_14_chromebook),
 	},
 	{
-		.ident = "Cr-48 - Light Sensor",
+		.ident = "Cr-48",
 		.matches = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "Mario"),
 		},
-		.callback = setup_tsl2563_als,
-	},
-	{
-		.ident = "Acer AC700 - Light Sensor",
-		.matches = {
-			DMI_MATCH(DMI_PRODUCT_NAME, "ZGB"),
-		},
-		.callback = setup_tsl2563_als,
+		_CBDD(cr48),
 	},
 	{ }
 };

commit ab0431059ed0d0e3a9e532ad0488ada25021249d
Author: Olof Johansson <olof@lixom.net>
Date:   Thu Nov 7 14:25:45 2013 -0800

    platform: add chrome platform directory
    
    It makes sense to split out the Chromebook/Chromebox hardware platform
    drivers to a separate subdirectory, since some of it will be shared
    between ARM and x86.
    
    This moves over the existing chromeos_laptop driver without making
    any other changes, and adds appropriate Kconfig entries for the new
    directory. It also adds a MAINTAINERS entry for the new subdir.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>

diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
new file mode 100644
index 000000000000..3e5b4497a1d0
--- /dev/null
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -0,0 +1,408 @@
+/*
+ *  chromeos_laptop.c - Driver to instantiate Chromebook i2c/smbus devices.
+ *
+ *  Author : Benson Leung <bleung@chromium.org>
+ *
+ *  Copyright (C) 2012 Google, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/dmi.h>
+#include <linux/i2c.h>
+#include <linux/i2c/atmel_mxt_ts.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+
+#define ATMEL_TP_I2C_ADDR	0x4b
+#define ATMEL_TP_I2C_BL_ADDR	0x25
+#define ATMEL_TS_I2C_ADDR	0x4a
+#define ATMEL_TS_I2C_BL_ADDR	0x26
+#define CYAPA_TP_I2C_ADDR	0x67
+#define ISL_ALS_I2C_ADDR	0x44
+#define TAOS_ALS_I2C_ADDR	0x29
+
+static struct i2c_client *als;
+static struct i2c_client *tp;
+static struct i2c_client *ts;
+
+const char *i2c_adapter_names[] = {
+	"SMBus I801 adapter",
+	"i915 gmbus vga",
+	"i915 gmbus panel",
+};
+
+/* Keep this enum consistent with i2c_adapter_names */
+enum i2c_adapter_type {
+	I2C_ADAPTER_SMBUS = 0,
+	I2C_ADAPTER_VGADDC,
+	I2C_ADAPTER_PANEL,
+};
+
+static struct i2c_board_info __initdata cyapa_device = {
+	I2C_BOARD_INFO("cyapa", CYAPA_TP_I2C_ADDR),
+	.flags		= I2C_CLIENT_WAKE,
+};
+
+static struct i2c_board_info __initdata isl_als_device = {
+	I2C_BOARD_INFO("isl29018", ISL_ALS_I2C_ADDR),
+};
+
+static struct i2c_board_info __initdata tsl2583_als_device = {
+	I2C_BOARD_INFO("tsl2583", TAOS_ALS_I2C_ADDR),
+};
+
+static struct i2c_board_info __initdata tsl2563_als_device = {
+	I2C_BOARD_INFO("tsl2563", TAOS_ALS_I2C_ADDR),
+};
+
+static struct mxt_platform_data atmel_224s_tp_platform_data = {
+	.x_line			= 18,
+	.y_line			= 12,
+	.x_size			= 102*20,
+	.y_size			= 68*20,
+	.blen			= 0x80,	/* Gain setting is in upper 4 bits */
+	.threshold		= 0x32,
+	.voltage		= 0,	/* 3.3V */
+	.orient			= MXT_VERTICAL_FLIP,
+	.irqflags		= IRQF_TRIGGER_FALLING,
+	.is_tp			= true,
+	.key_map		= { KEY_RESERVED,
+				    KEY_RESERVED,
+				    KEY_RESERVED,
+				    BTN_LEFT },
+	.config			= NULL,
+	.config_length		= 0,
+};
+
+static struct i2c_board_info __initdata atmel_224s_tp_device = {
+	I2C_BOARD_INFO("atmel_mxt_tp", ATMEL_TP_I2C_ADDR),
+	.platform_data = &atmel_224s_tp_platform_data,
+	.flags		= I2C_CLIENT_WAKE,
+};
+
+static struct mxt_platform_data atmel_1664s_platform_data = {
+	.x_line			= 32,
+	.y_line			= 50,
+	.x_size			= 1700,
+	.y_size			= 2560,
+	.blen			= 0x89,	/* Gain setting is in upper 4 bits */
+	.threshold		= 0x28,
+	.voltage		= 0,	/* 3.3V */
+	.orient			= MXT_ROTATED_90_COUNTER,
+	.irqflags		= IRQF_TRIGGER_FALLING,
+	.is_tp			= false,
+	.config			= NULL,
+	.config_length		= 0,
+};
+
+static struct i2c_board_info __initdata atmel_1664s_device = {
+	I2C_BOARD_INFO("atmel_mxt_ts", ATMEL_TS_I2C_ADDR),
+	.platform_data = &atmel_1664s_platform_data,
+	.flags		= I2C_CLIENT_WAKE,
+};
+
+static struct i2c_client __init *__add_probed_i2c_device(
+		const char *name,
+		int bus,
+		struct i2c_board_info *info,
+		const unsigned short *addrs)
+{
+	const struct dmi_device *dmi_dev;
+	const struct dmi_dev_onboard *dev_data;
+	struct i2c_adapter *adapter;
+	struct i2c_client *client;
+
+	if (bus < 0)
+		return NULL;
+	/*
+	 * If a name is specified, look for irq platform information stashed
+	 * in DMI_DEV_TYPE_DEV_ONBOARD by the Chrome OS custom system firmware.
+	 */
+	if (name) {
+		dmi_dev = dmi_find_device(DMI_DEV_TYPE_DEV_ONBOARD, name, NULL);
+		if (!dmi_dev) {
+			pr_err("%s failed to dmi find device %s.\n",
+			       __func__,
+			       name);
+			return NULL;
+		}
+		dev_data = (struct dmi_dev_onboard *)dmi_dev->device_data;
+		if (!dev_data) {
+			pr_err("%s failed to get data from dmi for %s.\n",
+			       __func__, name);
+			return NULL;
+		}
+		info->irq = dev_data->instance;
+	}
+
+	adapter = i2c_get_adapter(bus);
+	if (!adapter) {
+		pr_err("%s failed to get i2c adapter %d.\n", __func__, bus);
+		return NULL;
+	}
+
+	/* add the i2c device */
+	client = i2c_new_probed_device(adapter, info, addrs, NULL);
+	if (!client)
+		pr_err("%s failed to register device %d-%02x\n",
+		       __func__, bus, info->addr);
+	else
+		pr_debug("%s added i2c device %d-%02x\n",
+			 __func__, bus, info->addr);
+
+	i2c_put_adapter(adapter);
+	return client;
+}
+
+static int __init __find_i2c_adap(struct device *dev, void *data)
+{
+	const char *name = data;
+	static const char *prefix = "i2c-";
+	struct i2c_adapter *adapter;
+	if (strncmp(dev_name(dev), prefix, strlen(prefix)) != 0)
+		return 0;
+	adapter = to_i2c_adapter(dev);
+	return (strncmp(adapter->name, name, strlen(name)) == 0);
+}
+
+static int __init find_i2c_adapter_num(enum i2c_adapter_type type)
+{
+	struct device *dev = NULL;
+	struct i2c_adapter *adapter;
+	const char *name = i2c_adapter_names[type];
+	/* find the adapter by name */
+	dev = bus_find_device(&i2c_bus_type, NULL, (void *)name,
+			      __find_i2c_adap);
+	if (!dev) {
+		pr_err("%s: i2c adapter %s not found on system.\n", __func__,
+		       name);
+		return -ENODEV;
+	}
+	adapter = to_i2c_adapter(dev);
+	return adapter->nr;
+}
+
+/*
+ * Takes a list of addresses in addrs as such :
+ * { addr1, ... , addrn, I2C_CLIENT_END };
+ * add_probed_i2c_device will use i2c_new_probed_device
+ * and probe for devices at all of the addresses listed.
+ * Returns NULL if no devices found.
+ * See Documentation/i2c/instantiating-devices for more information.
+ */
+static __init struct i2c_client *add_probed_i2c_device(
+		const char *name,
+		enum i2c_adapter_type type,
+		struct i2c_board_info *info,
+		const unsigned short *addrs)
+{
+	return __add_probed_i2c_device(name,
+				       find_i2c_adapter_num(type),
+				       info,
+				       addrs);
+}
+
+/*
+ * Probes for a device at a single address, the one provided by
+ * info->addr.
+ * Returns NULL if no device found.
+ */
+static __init struct i2c_client *add_i2c_device(const char *name,
+						enum i2c_adapter_type type,
+						struct i2c_board_info *info)
+{
+	const unsigned short addr_list[] = { info->addr, I2C_CLIENT_END };
+	return __add_probed_i2c_device(name,
+				       find_i2c_adapter_num(type),
+				       info,
+				       addr_list);
+}
+
+
+static struct i2c_client __init *add_smbus_device(const char *name,
+						  struct i2c_board_info *info)
+{
+	return add_i2c_device(name, I2C_ADAPTER_SMBUS, info);
+}
+
+static int __init setup_cyapa_smbus_tp(const struct dmi_system_id *id)
+{
+	/* add cyapa touchpad on smbus */
+	tp = add_smbus_device("trackpad", &cyapa_device);
+	return 0;
+}
+
+static int __init setup_atmel_224s_tp(const struct dmi_system_id *id)
+{
+	const unsigned short addr_list[] = { ATMEL_TP_I2C_BL_ADDR,
+					     ATMEL_TP_I2C_ADDR,
+					     I2C_CLIENT_END };
+
+	/* add atmel mxt touchpad on VGA DDC GMBus */
+	tp = add_probed_i2c_device("trackpad", I2C_ADAPTER_VGADDC,
+				   &atmel_224s_tp_device, addr_list);
+	return 0;
+}
+
+static int __init setup_atmel_1664s_ts(const struct dmi_system_id *id)
+{
+	const unsigned short addr_list[] = { ATMEL_TS_I2C_BL_ADDR,
+					     ATMEL_TS_I2C_ADDR,
+					     I2C_CLIENT_END };
+
+	/* add atmel mxt touch device on PANEL GMBus */
+	ts = add_probed_i2c_device("touchscreen", I2C_ADAPTER_PANEL,
+				   &atmel_1664s_device, addr_list);
+	return 0;
+}
+
+
+static int __init setup_isl29018_als(const struct dmi_system_id *id)
+{
+	/* add isl29018 light sensor */
+	als = add_smbus_device("lightsensor", &isl_als_device);
+	return 0;
+}
+
+static int __init setup_isl29023_als(const struct dmi_system_id *id)
+{
+	/* add isl29023 light sensor on Panel GMBus */
+	als = add_i2c_device("lightsensor", I2C_ADAPTER_PANEL,
+			     &isl_als_device);
+	return 0;
+}
+
+static int __init setup_tsl2583_als(const struct dmi_system_id *id)
+{
+	/* add tsl2583 light sensor on smbus */
+	als = add_smbus_device(NULL, &tsl2583_als_device);
+	return 0;
+}
+
+static int __init setup_tsl2563_als(const struct dmi_system_id *id)
+{
+	/* add tsl2563 light sensor on smbus */
+	als = add_smbus_device(NULL, &tsl2563_als_device);
+	return 0;
+}
+
+static struct dmi_system_id __initdata chromeos_laptop_dmi_table[] = {
+	{
+		.ident = "Samsung Series 5 550 - Touchpad",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "SAMSUNG"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Lumpy"),
+		},
+		.callback = setup_cyapa_smbus_tp,
+	},
+	{
+		.ident = "Chromebook Pixel - Touchscreen",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GOOGLE"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Link"),
+		},
+		.callback = setup_atmel_1664s_ts,
+	},
+	{
+		.ident = "Chromebook Pixel - Touchpad",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GOOGLE"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Link"),
+		},
+		.callback = setup_atmel_224s_tp,
+	},
+	{
+		.ident = "Samsung Series 5 550 - Light Sensor",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "SAMSUNG"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Lumpy"),
+		},
+		.callback = setup_isl29018_als,
+	},
+	{
+		.ident = "Chromebook Pixel - Light Sensor",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GOOGLE"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Link"),
+		},
+		.callback = setup_isl29023_als,
+	},
+	{
+		.ident = "Acer C7 Chromebook - Touchpad",
+		.matches = {
+			DMI_MATCH(DMI_PRODUCT_NAME, "Parrot"),
+		},
+		.callback = setup_cyapa_smbus_tp,
+	},
+	{
+		.ident = "HP Pavilion 14 Chromebook - Touchpad",
+		.matches = {
+			DMI_MATCH(DMI_PRODUCT_NAME, "Butterfly"),
+		},
+		.callback = setup_cyapa_smbus_tp,
+	},
+	{
+		.ident = "Samsung Series 5 - Light Sensor",
+		.matches = {
+			DMI_MATCH(DMI_PRODUCT_NAME, "Alex"),
+		},
+		.callback = setup_tsl2583_als,
+	},
+	{
+		.ident = "Cr-48 - Light Sensor",
+		.matches = {
+			DMI_MATCH(DMI_PRODUCT_NAME, "Mario"),
+		},
+		.callback = setup_tsl2563_als,
+	},
+	{
+		.ident = "Acer AC700 - Light Sensor",
+		.matches = {
+			DMI_MATCH(DMI_PRODUCT_NAME, "ZGB"),
+		},
+		.callback = setup_tsl2563_als,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(dmi, chromeos_laptop_dmi_table);
+
+static int __init chromeos_laptop_init(void)
+{
+	if (!dmi_check_system(chromeos_laptop_dmi_table)) {
+		pr_debug("%s unsupported system.\n", __func__);
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static void __exit chromeos_laptop_exit(void)
+{
+	if (als)
+		i2c_unregister_device(als);
+	if (tp)
+		i2c_unregister_device(tp);
+	if (ts)
+		i2c_unregister_device(ts);
+}
+
+module_init(chromeos_laptop_init);
+module_exit(chromeos_laptop_exit);
+
+MODULE_DESCRIPTION("Chrome OS Laptop driver");
+MODULE_AUTHOR("Benson Leung <bleung@chromium.org>");
+MODULE_LICENSE("GPL");
