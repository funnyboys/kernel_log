commit c06e58b6b7336d717b1ec9a5c7f825a94b67386e
Author: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date:   Thu Feb 20 16:58:58 2020 +0100

    platform/chrome: cros_ec: Use cros_ec_cmd_xfer_status helper
    
    This patch makes use of cros_ec_cmd_xfer_status() instead of
    cros_ec_cmd_xfer(). In this case the change is trivial and the only
    reason to do it is because we want to make cros_ec_cmd_xfer() a private
    function for the EC protocol and let people only use the
    cros_ec_cmd_xfer_status() to return Linux standard error codes.
    
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Tested-by: Prashant Malani <pmalani@chromium.org>

diff --git a/drivers/platform/chrome/cros_ec.c b/drivers/platform/chrome/cros_ec.c
index 7ee43b2e0654..3104680b7485 100644
--- a/drivers/platform/chrome/cros_ec.c
+++ b/drivers/platform/chrome/cros_ec.c
@@ -120,7 +120,7 @@ static int cros_ec_sleep_event(struct cros_ec_device *ec_dev, u8 sleep_event)
 
 	buf.msg.command = EC_CMD_HOST_SLEEP_EVENT;
 
-	ret = cros_ec_cmd_xfer(ec_dev, &buf.msg);
+	ret = cros_ec_cmd_xfer_status(ec_dev, &buf.msg);
 
 	/* For now, report failure to transition to S0ix with a warning. */
 	if (ret >= 0 && ec_dev->host_sleep_v1 &&

commit 42cd0ab476e2daffc23982c37822a78f9a53cdd5
Author: Yicheng Li <yichengli@chromium.org>
Date:   Mon Feb 3 14:53:56 2020 -0800

    platform/chrome: cros_ec: Query EC protocol version if EC transitions between RO/RW
    
    RO and RW of EC may have different EC protocol version. If EC transitions
    between RO and RW, but AP does not reboot (this is true for fingerprint
    microcontroller / cros_fp, but not true for main ec / cros_ec), the AP
    still uses the protocol version queried before transition, which can
    cause problems. In the case of fingerprint microcontroller, this causes
    AP to send the wrong version of EC_CMD_GET_NEXT_EVENT to RO in the
    interrupt handler, which in turn prevents RO to clear the interrupt
    line to AP, in an infinite loop.
    
    Once an EC_HOST_EVENT_INTERFACE_READY is received, we know that there
    might have been a transition between RO and RW, so re-query the protocol.
    
    Signed-off-by: Yicheng Li <yichengli@chromium.org>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Reviewed-by: Gwendal Grignou <gwendal@chromium.org>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>

diff --git a/drivers/platform/chrome/cros_ec.c b/drivers/platform/chrome/cros_ec.c
index 6fc8f2c3ac51..7ee43b2e0654 100644
--- a/drivers/platform/chrome/cros_ec.c
+++ b/drivers/platform/chrome/cros_ec.c
@@ -138,6 +138,24 @@ static int cros_ec_sleep_event(struct cros_ec_device *ec_dev, u8 sleep_event)
 	return ret;
 }
 
+static int cros_ec_ready_event(struct notifier_block *nb,
+			       unsigned long queued_during_suspend,
+			       void *_notify)
+{
+	struct cros_ec_device *ec_dev = container_of(nb, struct cros_ec_device,
+						     notifier_ready);
+	u32 host_event = cros_ec_get_host_event(ec_dev);
+
+	if (host_event & EC_HOST_EVENT_MASK(EC_HOST_EVENT_INTERFACE_READY)) {
+		mutex_lock(&ec_dev->lock);
+		cros_ec_query_all(ec_dev);
+		mutex_unlock(&ec_dev->lock);
+		return NOTIFY_OK;
+	}
+
+	return NOTIFY_DONE;
+}
+
 /**
  * cros_ec_register() - Register a new ChromeOS EC, using the provided info.
  * @ec_dev: Device to register.
@@ -237,6 +255,18 @@ int cros_ec_register(struct cros_ec_device *ec_dev)
 		dev_dbg(ec_dev->dev, "Error %d clearing sleep event to ec",
 			err);
 
+	if (ec_dev->mkbp_event_supported) {
+		/*
+		 * Register the notifier for EC_HOST_EVENT_INTERFACE_READY
+		 * event.
+		 */
+		ec_dev->notifier_ready.notifier_call = cros_ec_ready_event;
+		err = blocking_notifier_chain_register(&ec_dev->event_notifier,
+						      &ec_dev->notifier_ready);
+		if (err)
+			return err;
+	}
+
 	dev_info(dev, "Chrome EC device registered\n");
 
 	return 0;

commit 034dbec179e5d2820480f477c43acbc50245e56d
Author: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date:   Wed Jan 22 10:07:01 2020 +0100

    platform/chrome: cros_ec: Match implementation with headers
    
    The 'cros_ec' core driver is the common interface for the cros_ec
    transport drivers to do the shared operations to register, unregister,
    suspend, resume and handle_event. The interface is provided by including
    the header 'include/linux/platform_data/cros_ec_proto.h', however, instead
    of have the implementation of these functions in cros_ec_proto.c, it is in
    'cros_ec.c', which is a different kernel module. Apart from being a bad
    practice, this can induce confusions allowing the users of the cros_ec
    protocol to call these functions.
    
    The register, unregister, suspend, resume and handle_event functions
    *should* only be called by the different transport drivers (i2c, spi, lpc,
    etc.), so make this a bit less confusing by moving these functions from
    the public in-kernel space to a private include in platform/chrome, and
    then, the interface for cros_ec module and for the cros_ec_proto module is
    clean.
    
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Signed-off-by: Benson Leung <bleung@chromium.org>

diff --git a/drivers/platform/chrome/cros_ec.c b/drivers/platform/chrome/cros_ec.c
index 81054de0dd81..6fc8f2c3ac51 100644
--- a/drivers/platform/chrome/cros_ec.c
+++ b/drivers/platform/chrome/cros_ec.c
@@ -17,6 +17,8 @@
 #include <linux/platform_data/cros_ec_proto.h>
 #include <linux/suspend.h>
 
+#include "cros_ec.h"
+
 #define CROS_EC_DEV_EC_INDEX 0
 #define CROS_EC_DEV_PD_INDEX 1
 

commit 943063b65d93fb396cab55764e1075e50e1cd331
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Tue Jan 21 16:49:58 2020 -0800

    platform/chrome: cros_ec: Drop unaligned.h include
    
    This include isn't used. Remove it.
    
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>

diff --git a/drivers/platform/chrome/cros_ec.c b/drivers/platform/chrome/cros_ec.c
index 6d6ce86a1408..81054de0dd81 100644
--- a/drivers/platform/chrome/cros_ec.c
+++ b/drivers/platform/chrome/cros_ec.c
@@ -16,7 +16,6 @@
 #include <linux/platform_data/cros_ec_commands.h>
 #include <linux/platform_data/cros_ec_proto.h>
 #include <linux/suspend.h>
-#include <asm/unaligned.h>
 
 #define CROS_EC_DEV_EC_INDEX 0
 #define CROS_EC_DEV_PD_INDEX 1

commit 3300fdd630d4d3d96e3ba9af63a740d3a4e8fc61
Author: Enrico Granata <egranata@chromium.org>
Date:   Tue Nov 19 13:45:46 2019 +0100

    platform/chrome: cros_ec: handle MKBP more events flag
    
    The ChromeOS EC has support for signaling to the host that a single IRQ
    can serve multiple MKBP (Matrix KeyBoard Protocol) events.
    
    Doing this serves an optimization purpose, as it minimizes the number of
    round-trips into the interrupt handling machinery, and it proves
    beneficial to sensor timestamping as it keeps the desired synchronization
    of event times between the two processors.
    
    This patch adds kernel support for this EC feature, allowing the ec_irq
    to loop until all events have been served.
    
    Signed-off-by: Enrico Granata <egranata@chromium.org>
    Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
    Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>

diff --git a/drivers/platform/chrome/cros_ec.c b/drivers/platform/chrome/cros_ec.c
index d3dfa27171e6..6d6ce86a1408 100644
--- a/drivers/platform/chrome/cros_ec.c
+++ b/drivers/platform/chrome/cros_ec.c
@@ -40,13 +40,23 @@ static irqreturn_t ec_irq_handler(int irq, void *data)
 	return IRQ_WAKE_THREAD;
 }
 
-static irqreturn_t ec_irq_thread(int irq, void *data)
+/**
+ * cros_ec_handle_event() - process and forward pending events on EC
+ * @ec_dev: Device with events to process.
+ *
+ * Call this function in a loop when the kernel is notified that the EC has
+ * pending events.
+ *
+ * Return: true if more events are still pending and this function should be
+ * called again.
+ */
+bool cros_ec_handle_event(struct cros_ec_device *ec_dev)
 {
-	struct cros_ec_device *ec_dev = data;
-	bool wake_event = true;
+	bool wake_event;
+	bool ec_has_more_events;
 	int ret;
 
-	ret = cros_ec_get_next_event(ec_dev, &wake_event);
+	ret = cros_ec_get_next_event(ec_dev, &wake_event, &ec_has_more_events);
 
 	/*
 	 * Signal only if wake host events or any interrupt if
@@ -59,6 +69,20 @@ static irqreturn_t ec_irq_thread(int irq, void *data)
 	if (ret > 0)
 		blocking_notifier_call_chain(&ec_dev->event_notifier,
 					     0, ec_dev);
+
+	return ec_has_more_events;
+}
+EXPORT_SYMBOL(cros_ec_handle_event);
+
+static irqreturn_t ec_irq_thread(int irq, void *data)
+{
+	struct cros_ec_device *ec_dev = data;
+	bool ec_has_more_events;
+
+	do {
+		ec_has_more_events = cros_ec_handle_event(ec_dev);
+	} while (ec_has_more_events);
+
 	return IRQ_HANDLED;
 }
 
@@ -274,7 +298,7 @@ EXPORT_SYMBOL(cros_ec_suspend);
 static void cros_ec_report_events_during_suspend(struct cros_ec_device *ec_dev)
 {
 	while (ec_dev->mkbp_event_supported &&
-	       cros_ec_get_next_event(ec_dev, NULL) > 0)
+	       cros_ec_get_next_event(ec_dev, NULL, NULL) > 0)
 		blocking_notifier_call_chain(&ec_dev->event_notifier,
 					     1, ec_dev);
 }

commit da946589b1b9b643c538e6c977ac0f963362ee3c
Author: Gwendal Grignou <gwendal@chromium.org>
Date:   Tue Nov 19 13:45:46 2019 +0100

    platform/chrome: cros_ec: Do not attempt to register a non-positive IRQ number
    
    Add a layer of sanity checking to cros_ec_register against attempting to
    register IRQ values that are not strictly greater than 0.
    
    Signed-off-by: Enrico Granata <egranata@chromium.org>
    Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
    Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>

diff --git a/drivers/platform/chrome/cros_ec.c b/drivers/platform/chrome/cros_ec.c
index 925f84dbf621..d3dfa27171e6 100644
--- a/drivers/platform/chrome/cros_ec.c
+++ b/drivers/platform/chrome/cros_ec.c
@@ -149,7 +149,7 @@ int cros_ec_register(struct cros_ec_device *ec_dev)
 		return err;
 	}
 
-	if (ec_dev->irq) {
+	if (ec_dev->irq > 0) {
 		err = devm_request_threaded_irq(dev, ec_dev->irq,
 						ec_irq_handler,
 						ec_irq_thread,

commit 05a3c420eaa6857cb20afe7e3a3c39ed94a3b2c1
Author: Gwendal Grignou <gwendal@chromium.org>
Date:   Tue Nov 19 13:45:46 2019 +0100

    platform/chrome: cros-ec: Record event timestamp in the hard irq
    
    To improve sensor timestamp precision, given EC and AP are in different
    time domains, the AP needs to try to record the exact moment an event
    was signalled to the AP by the EC as soon as possible after it happens.
    
    First thing in the hard irq is the best place for this.
    
    Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
    Acked-by: Jonathan Cameron <Jonathan.Cameron@kernel.org>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>

diff --git a/drivers/platform/chrome/cros_ec.c b/drivers/platform/chrome/cros_ec.c
index 9b2d07422e17..925f84dbf621 100644
--- a/drivers/platform/chrome/cros_ec.c
+++ b/drivers/platform/chrome/cros_ec.c
@@ -31,6 +31,15 @@ static struct cros_ec_platform pd_p = {
 	.cmd_offset = EC_CMD_PASSTHRU_OFFSET(CROS_EC_DEV_PD_INDEX),
 };
 
+static irqreturn_t ec_irq_handler(int irq, void *data)
+{
+	struct cros_ec_device *ec_dev = data;
+
+	ec_dev->last_event_time = cros_ec_get_time_ns();
+
+	return IRQ_WAKE_THREAD;
+}
+
 static irqreturn_t ec_irq_thread(int irq, void *data)
 {
 	struct cros_ec_device *ec_dev = data;
@@ -141,9 +150,11 @@ int cros_ec_register(struct cros_ec_device *ec_dev)
 	}
 
 	if (ec_dev->irq) {
-		err = devm_request_threaded_irq(dev, ec_dev->irq, NULL,
-				ec_irq_thread, IRQF_TRIGGER_LOW | IRQF_ONESHOT,
-				"chromeos-ec", ec_dev);
+		err = devm_request_threaded_irq(dev, ec_dev->irq,
+						ec_irq_handler,
+						ec_irq_thread,
+						IRQF_TRIGGER_LOW | IRQF_ONESHOT,
+						"chromeos-ec", ec_dev);
 		if (err) {
 			dev_err(dev, "Failed to request IRQ %d: %d",
 				ec_dev->irq, err);

commit c9b465683a554212c3dd92915ed2088849c513bf
Author: Gwendal Grignou <gwendal@chromium.org>
Date:   Tue Nov 19 13:45:45 2019 +0100

    platform/chrome: cros_ec: Put docs with the code
    
    To avoid doc rot, put function documentations with code, not header.
    Use kernel-doc style comments for exported functions.
    
    Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
    Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>

diff --git a/drivers/platform/chrome/cros_ec.c b/drivers/platform/chrome/cros_ec.c
index fd77e6fa74c2..9b2d07422e17 100644
--- a/drivers/platform/chrome/cros_ec.c
+++ b/drivers/platform/chrome/cros_ec.c
@@ -104,6 +104,15 @@ static int cros_ec_sleep_event(struct cros_ec_device *ec_dev, u8 sleep_event)
 	return ret;
 }
 
+/**
+ * cros_ec_register() - Register a new ChromeOS EC, using the provided info.
+ * @ec_dev: Device to register.
+ *
+ * Before calling this, allocate a pointer to a new device and then fill
+ * in all the fields up to the --private-- marker.
+ *
+ * Return: 0 on success or negative error code.
+ */
 int cros_ec_register(struct cros_ec_device *ec_dev)
 {
 	struct device *dev = ec_dev->dev;
@@ -198,6 +207,14 @@ int cros_ec_register(struct cros_ec_device *ec_dev)
 }
 EXPORT_SYMBOL(cros_ec_register);
 
+/**
+ * cros_ec_unregister() - Remove a ChromeOS EC.
+ * @ec_dev: Device to unregister.
+ *
+ * Call this to deregister a ChromeOS EC, then clean up any private data.
+ *
+ * Return: 0 on success or negative error code.
+ */
 int cros_ec_unregister(struct cros_ec_device *ec_dev)
 {
 	if (ec_dev->pd)
@@ -209,6 +226,14 @@ int cros_ec_unregister(struct cros_ec_device *ec_dev)
 EXPORT_SYMBOL(cros_ec_unregister);
 
 #ifdef CONFIG_PM_SLEEP
+/**
+ * cros_ec_suspend() - Handle a suspend operation for the ChromeOS EC device.
+ * @ec_dev: Device to suspend.
+ *
+ * This can be called by drivers to handle a suspend event.
+ *
+ * Return: 0 on success or negative error code.
+ */
 int cros_ec_suspend(struct cros_ec_device *ec_dev)
 {
 	struct device *dev = ec_dev->dev;
@@ -243,6 +268,14 @@ static void cros_ec_report_events_during_suspend(struct cros_ec_device *ec_dev)
 					     1, ec_dev);
 }
 
+/**
+ * cros_ec_resume() - Handle a resume operation for the ChromeOS EC device.
+ * @ec_dev: Device to resume.
+ *
+ * This can be called by drivers to handle a resume event.
+ *
+ * Return: 0 on success or negative error code.
+ */
 int cros_ec_resume(struct cros_ec_device *ec_dev)
 {
 	int ret;

commit 840d9f131f65b021e0a73f3371f3194897dba6ad
Author: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date:   Mon Sep 2 11:53:05 2019 +0200

    mfd / platform: cros_ec: Reorganize platform and mfd includes
    
    There is a bit of mess between cros-ec mfd includes and platform
    includes. For example, we have a linux/mfd/cros_ec.h include that
    exports the interface implemented in platform/chrome/cros_ec_proto.c. Or
    we have a linux/mfd/cros_ec_commands.h file that is non related to the
    multifunction device (in the sense that is not exporting any function of
    the mfd device). This causes crossed includes between mfd and
    platform/chrome subsystems and makes the code difficult to read, apart
    from creating 'curious' situations where a platform/chrome driver includes
    a linux/mfd/cros_ec.h file just to get the exported functions that are
    implemented in another platform/chrome driver.
    
    In order to have a better separation on what the cros-ec multifunction
    driver does and what the cros-ec core provides move and rework the
    affected includes doing:
    
     - Move cros_ec_commands.h to include/linux/platform_data/cros_ec_commands.h
     - Get rid of the parts that are implemented in the platform/chrome/cros_ec_proto.c
       driver from include/linux/mfd/cros_ec.h to a new file
       include/linux/platform_data/cros_ec_proto.h
     - Update all the drivers with the new includes, so
       - Drivers that only need to know about the protocol include
         - linux/platform_data/cros_ec_proto.h
         - linux/platform_data/cros_ec_commands.h
       - Drivers that need to know about the cros-ec mfd device also include
         - linux/mfd/cros_ec.h
    
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Acked-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Acked-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Acked-by: Chanwoo Choi <cw00.choi@samsung.com>
    Reviewed-by: Gwendal Grignou <gwendal@chromium.org>
    Tested-by: Gwendal Grignou <gwendal@chromium.org>
    Series changes: 3
    - Fix dereferencing pointer to incomplete type 'struct cros_ec_dev' (lkp)
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/platform/chrome/cros_ec.c b/drivers/platform/chrome/cros_ec.c
index a54ad47c7b02..fd77e6fa74c2 100644
--- a/drivers/platform/chrome/cros_ec.c
+++ b/drivers/platform/chrome/cros_ec.c
@@ -13,7 +13,8 @@
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 #include <linux/module.h>
-#include <linux/mfd/cros_ec.h>
+#include <linux/platform_data/cros_ec_commands.h>
+#include <linux/platform_data/cros_ec_proto.h>
 #include <linux/suspend.h>
 #include <asm/unaligned.h>
 

commit 47f11e0b40e97f373da4efbacee0a9526c816ed5
Author: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date:   Mon Sep 2 11:53:01 2019 +0200

    mfd / platform: cros_ec: Move cros-ec core driver out from MFD
    
    Now, the ChromeOS EC core driver has nothing related to an MFD device, so
    move that driver from the MFD subsystem to the platform/chrome subsystem.
    
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Thierry Reding <thierry.reding@gmail.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Acked-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Acked-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Acked-by: Chanwoo Choi <cw00.choi@samsung.com>
    Reviewed-by: Gwendal Grignou <gwendal@chromium.org>
    Tested-by: Gwendal Grignou <gwendal@chromium.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/platform/chrome/cros_ec.c b/drivers/platform/chrome/cros_ec.c
new file mode 100644
index 000000000000..a54ad47c7b02
--- /dev/null
+++ b/drivers/platform/chrome/cros_ec.c
@@ -0,0 +1,280 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * ChromeOS EC multi-function device
+ *
+ * Copyright (C) 2012 Google, Inc
+ *
+ * The ChromeOS EC multi function device is used to mux all the requests
+ * to the EC device for its multiple features: keyboard controller,
+ * battery charging and regulator control, firmware update.
+ */
+
+#include <linux/of_platform.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/mfd/cros_ec.h>
+#include <linux/suspend.h>
+#include <asm/unaligned.h>
+
+#define CROS_EC_DEV_EC_INDEX 0
+#define CROS_EC_DEV_PD_INDEX 1
+
+static struct cros_ec_platform ec_p = {
+	.ec_name = CROS_EC_DEV_NAME,
+	.cmd_offset = EC_CMD_PASSTHRU_OFFSET(CROS_EC_DEV_EC_INDEX),
+};
+
+static struct cros_ec_platform pd_p = {
+	.ec_name = CROS_EC_DEV_PD_NAME,
+	.cmd_offset = EC_CMD_PASSTHRU_OFFSET(CROS_EC_DEV_PD_INDEX),
+};
+
+static irqreturn_t ec_irq_thread(int irq, void *data)
+{
+	struct cros_ec_device *ec_dev = data;
+	bool wake_event = true;
+	int ret;
+
+	ret = cros_ec_get_next_event(ec_dev, &wake_event);
+
+	/*
+	 * Signal only if wake host events or any interrupt if
+	 * cros_ec_get_next_event() returned an error (default value for
+	 * wake_event is true)
+	 */
+	if (wake_event && device_may_wakeup(ec_dev->dev))
+		pm_wakeup_event(ec_dev->dev, 0);
+
+	if (ret > 0)
+		blocking_notifier_call_chain(&ec_dev->event_notifier,
+					     0, ec_dev);
+	return IRQ_HANDLED;
+}
+
+static int cros_ec_sleep_event(struct cros_ec_device *ec_dev, u8 sleep_event)
+{
+	int ret;
+	struct {
+		struct cros_ec_command msg;
+		union {
+			struct ec_params_host_sleep_event req0;
+			struct ec_params_host_sleep_event_v1 req1;
+			struct ec_response_host_sleep_event_v1 resp1;
+		} u;
+	} __packed buf;
+
+	memset(&buf, 0, sizeof(buf));
+
+	if (ec_dev->host_sleep_v1) {
+		buf.u.req1.sleep_event = sleep_event;
+		buf.u.req1.suspend_params.sleep_timeout_ms =
+				EC_HOST_SLEEP_TIMEOUT_DEFAULT;
+
+		buf.msg.outsize = sizeof(buf.u.req1);
+		if ((sleep_event == HOST_SLEEP_EVENT_S3_RESUME) ||
+		    (sleep_event == HOST_SLEEP_EVENT_S0IX_RESUME))
+			buf.msg.insize = sizeof(buf.u.resp1);
+
+		buf.msg.version = 1;
+
+	} else {
+		buf.u.req0.sleep_event = sleep_event;
+		buf.msg.outsize = sizeof(buf.u.req0);
+	}
+
+	buf.msg.command = EC_CMD_HOST_SLEEP_EVENT;
+
+	ret = cros_ec_cmd_xfer(ec_dev, &buf.msg);
+
+	/* For now, report failure to transition to S0ix with a warning. */
+	if (ret >= 0 && ec_dev->host_sleep_v1 &&
+	    (sleep_event == HOST_SLEEP_EVENT_S0IX_RESUME)) {
+		ec_dev->last_resume_result =
+			buf.u.resp1.resume_response.sleep_transitions;
+
+		WARN_ONCE(buf.u.resp1.resume_response.sleep_transitions &
+			  EC_HOST_RESUME_SLEEP_TIMEOUT,
+			  "EC detected sleep transition timeout. Total slp_s0 transitions: %d",
+			  buf.u.resp1.resume_response.sleep_transitions &
+			  EC_HOST_RESUME_SLEEP_TRANSITIONS_MASK);
+	}
+
+	return ret;
+}
+
+int cros_ec_register(struct cros_ec_device *ec_dev)
+{
+	struct device *dev = ec_dev->dev;
+	int err = 0;
+
+	BLOCKING_INIT_NOTIFIER_HEAD(&ec_dev->event_notifier);
+
+	ec_dev->max_request = sizeof(struct ec_params_hello);
+	ec_dev->max_response = sizeof(struct ec_response_get_protocol_info);
+	ec_dev->max_passthru = 0;
+
+	ec_dev->din = devm_kzalloc(dev, ec_dev->din_size, GFP_KERNEL);
+	if (!ec_dev->din)
+		return -ENOMEM;
+
+	ec_dev->dout = devm_kzalloc(dev, ec_dev->dout_size, GFP_KERNEL);
+	if (!ec_dev->dout)
+		return -ENOMEM;
+
+	mutex_init(&ec_dev->lock);
+
+	err = cros_ec_query_all(ec_dev);
+	if (err) {
+		dev_err(dev, "Cannot identify the EC: error %d\n", err);
+		return err;
+	}
+
+	if (ec_dev->irq) {
+		err = devm_request_threaded_irq(dev, ec_dev->irq, NULL,
+				ec_irq_thread, IRQF_TRIGGER_LOW | IRQF_ONESHOT,
+				"chromeos-ec", ec_dev);
+		if (err) {
+			dev_err(dev, "Failed to request IRQ %d: %d",
+				ec_dev->irq, err);
+			return err;
+		}
+	}
+
+	/* Register a platform device for the main EC instance */
+	ec_dev->ec = platform_device_register_data(ec_dev->dev, "cros-ec-dev",
+					PLATFORM_DEVID_AUTO, &ec_p,
+					sizeof(struct cros_ec_platform));
+	if (IS_ERR(ec_dev->ec)) {
+		dev_err(ec_dev->dev,
+			"Failed to create CrOS EC platform device\n");
+		return PTR_ERR(ec_dev->ec);
+	}
+
+	if (ec_dev->max_passthru) {
+		/*
+		 * Register a platform device for the PD behind the main EC.
+		 * We make the following assumptions:
+		 * - behind an EC, we have a pd
+		 * - only one device added.
+		 * - the EC is responsive at init time (it is not true for a
+		 *   sensor hub).
+		 */
+		ec_dev->pd = platform_device_register_data(ec_dev->dev,
+					"cros-ec-dev",
+					PLATFORM_DEVID_AUTO, &pd_p,
+					sizeof(struct cros_ec_platform));
+		if (IS_ERR(ec_dev->pd)) {
+			dev_err(ec_dev->dev,
+				"Failed to create CrOS PD platform device\n");
+			platform_device_unregister(ec_dev->ec);
+			return PTR_ERR(ec_dev->pd);
+		}
+	}
+
+	if (IS_ENABLED(CONFIG_OF) && dev->of_node) {
+		err = devm_of_platform_populate(dev);
+		if (err) {
+			platform_device_unregister(ec_dev->pd);
+			platform_device_unregister(ec_dev->ec);
+			dev_err(dev, "Failed to register sub-devices\n");
+			return err;
+		}
+	}
+
+	/*
+	 * Clear sleep event - this will fail harmlessly on platforms that
+	 * don't implement the sleep event host command.
+	 */
+	err = cros_ec_sleep_event(ec_dev, 0);
+	if (err < 0)
+		dev_dbg(ec_dev->dev, "Error %d clearing sleep event to ec",
+			err);
+
+	dev_info(dev, "Chrome EC device registered\n");
+
+	return 0;
+}
+EXPORT_SYMBOL(cros_ec_register);
+
+int cros_ec_unregister(struct cros_ec_device *ec_dev)
+{
+	if (ec_dev->pd)
+		platform_device_unregister(ec_dev->pd);
+	platform_device_unregister(ec_dev->ec);
+
+	return 0;
+}
+EXPORT_SYMBOL(cros_ec_unregister);
+
+#ifdef CONFIG_PM_SLEEP
+int cros_ec_suspend(struct cros_ec_device *ec_dev)
+{
+	struct device *dev = ec_dev->dev;
+	int ret;
+	u8 sleep_event;
+
+	sleep_event = (!IS_ENABLED(CONFIG_ACPI) || pm_suspend_via_firmware()) ?
+		      HOST_SLEEP_EVENT_S3_SUSPEND :
+		      HOST_SLEEP_EVENT_S0IX_SUSPEND;
+
+	ret = cros_ec_sleep_event(ec_dev, sleep_event);
+	if (ret < 0)
+		dev_dbg(ec_dev->dev, "Error %d sending suspend event to ec",
+			ret);
+
+	if (device_may_wakeup(dev))
+		ec_dev->wake_enabled = !enable_irq_wake(ec_dev->irq);
+
+	disable_irq(ec_dev->irq);
+	ec_dev->was_wake_device = ec_dev->wake_enabled;
+	ec_dev->suspended = true;
+
+	return 0;
+}
+EXPORT_SYMBOL(cros_ec_suspend);
+
+static void cros_ec_report_events_during_suspend(struct cros_ec_device *ec_dev)
+{
+	while (ec_dev->mkbp_event_supported &&
+	       cros_ec_get_next_event(ec_dev, NULL) > 0)
+		blocking_notifier_call_chain(&ec_dev->event_notifier,
+					     1, ec_dev);
+}
+
+int cros_ec_resume(struct cros_ec_device *ec_dev)
+{
+	int ret;
+	u8 sleep_event;
+
+	ec_dev->suspended = false;
+	enable_irq(ec_dev->irq);
+
+	sleep_event = (!IS_ENABLED(CONFIG_ACPI) || pm_suspend_via_firmware()) ?
+		      HOST_SLEEP_EVENT_S3_RESUME :
+		      HOST_SLEEP_EVENT_S0IX_RESUME;
+
+	ret = cros_ec_sleep_event(ec_dev, sleep_event);
+	if (ret < 0)
+		dev_dbg(ec_dev->dev, "Error %d sending resume event to ec",
+			ret);
+
+	if (ec_dev->wake_enabled) {
+		disable_irq_wake(ec_dev->irq);
+		ec_dev->wake_enabled = 0;
+	}
+	/*
+	 * Let the mfd devices know about events that occur during
+	 * suspend. This way the clients know what to do with them.
+	 */
+	cros_ec_report_events_during_suspend(ec_dev);
+
+
+	return 0;
+}
+EXPORT_SYMBOL(cros_ec_resume);
+
+#endif
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("ChromeOS EC core driver");
