commit 45620da40f6fe627f6f98ba4f6edc2e43dd8d291
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Fri Mar 20 18:15:42 2020 -0500

    platform/chrome: cros_ec_chardev: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>

diff --git a/drivers/platform/chrome/cros_ec_chardev.c b/drivers/platform/chrome/cros_ec_chardev.c
index b51ab24055f3..e0bce869c49a 100644
--- a/drivers/platform/chrome/cros_ec_chardev.c
+++ b/drivers/platform/chrome/cros_ec_chardev.c
@@ -48,7 +48,7 @@ struct ec_event {
 	struct list_head node;
 	size_t size;
 	u8 event_type;
-	u8 data[0];
+	u8 data[];
 };
 
 static int ec_get_version(struct cros_ec_dev *ec, char *str, int maxlen)

commit 413dda8f2c6f1ba90e93ba7b4214b1d8cf8ec171
Author: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date:   Thu Feb 20 16:58:55 2020 +0100

    platform/chrome: cros_ec_chardev: Use cros_ec_cmd_xfer_status helper
    
    This patch makes use of cros_ec_cmd_xfer_status() instead of
    cros_ec_cmd_xfer(). In this case the change is trivial and the only
    reason to do it is because we want to make cros_ec_cmd_xfer() a private
    function for the EC protocol and let people only use the
    cros_ec_cmd_xfer_status() to return Linux standard error codes.
    
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Tested-by: Prashant Malani <pmalani@chromium.org>

diff --git a/drivers/platform/chrome/cros_ec_chardev.c b/drivers/platform/chrome/cros_ec_chardev.c
index c65e70bc168d..b51ab24055f3 100644
--- a/drivers/platform/chrome/cros_ec_chardev.c
+++ b/drivers/platform/chrome/cros_ec_chardev.c
@@ -301,7 +301,7 @@ static long cros_ec_chardev_ioctl_xcmd(struct cros_ec_dev *ec, void __user *arg)
 	}
 
 	s_cmd->command += ec->cmd_offset;
-	ret = cros_ec_cmd_xfer(ec->ec_dev, s_cmd);
+	ret = cros_ec_cmd_xfer_status(ec->ec_dev, s_cmd);
 	/* Only copy data to userland if data was received. */
 	if (ret < 0)
 		goto exit;

commit 11f1eabee0ba0aafe023ad92d1e3c29d0a96683e
Author: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date:   Tue Dec 3 15:50:18 2019 +0100

    cros_ec: treewide: Remove 'include/linux/mfd/cros_ec.h'
    
    This header file now only includes the cros_ec_dev struct, however, is the
    'include/linux/platform_data/cros_ec_proto.h' who contains the definition of
    all the Chrome OS EC related structs. There is no reason to have a
    separate include for this struct so move to the place where other
    structs are defined. That way, we can remove the include itself, but also
    simplify the common pattern
    
        #include <linux/mfd/cros_ec.h>
        #include <linux/platform_data/cros_ec_proto.h>
    
    for a single include
    
        #include <linux/platform_data/cros_ec_proto.h>
    
    The changes to remove the cros_ec.h include were generated with the
    following shell script:
    
        git grep -l "<linux/mfd/cros_ec.h>" | xargs sed -i '/<linux\/mfd\/cros_ec.h>/d'
    
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Acked-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Acked-by: Sebastian Reichel <sre@kernel.org>
    Acked-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>

diff --git a/drivers/platform/chrome/cros_ec_chardev.c b/drivers/platform/chrome/cros_ec_chardev.c
index 74ded441bb50..c65e70bc168d 100644
--- a/drivers/platform/chrome/cros_ec_chardev.c
+++ b/drivers/platform/chrome/cros_ec_chardev.c
@@ -13,7 +13,6 @@
 #include <linux/init.h>
 #include <linux/device.h>
 #include <linux/fs.h>
-#include <linux/mfd/cros_ec.h>
 #include <linux/miscdevice.h>
 #include <linux/module.h>
 #include <linux/notifier.h>

commit 96a0a80738461d6d2421ae64ee9990b702efd2a6
Author: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date:   Mon Sep 2 18:08:48 2019 +0200

    platform/chrome: cros_ec_chardev: Add a poll handler to receive MKBP events
    
    Allow to poll on the cros_ec device to receive the MKBP events.
    
    The /dev/cros_[ec|fp|..] file operations now implements the poll
    operation. The userspace can now receive specific MKBP events by doing
    the following:
    
    - Open the /dev/cros_XX file.
    - Call the CROS_EC_DEV_IOCEVENTMASK ioctl with the bitmap of the MKBP
      events it wishes to receive as argument.
    - Poll on the file descriptor.
    - When it gets POLLIN, do a read on the file descriptor, the first
      queued event will be returned (using the struct
      ec_response_get_next_event format: one byte of event type, then
      the payload).
    
    The read() operation returns at most one event even if there are several
    queued, and it might be truncated if the buffer is smaller than the
    event (but the caller should know the maximum size of the events it is
    reading).
    
    read() used to return the EC version string, it still does it when no
    event mask or an empty event is set for backward compatibility (despite
    nobody really using this feature).
    
    This will be used, for example, by the userspace daemon to receive and
    treat the EC_MKBP_EVENT_FINGERPRINT sent by the FP MCU.
    
    Signed-off-by: Vincent Palatin <vpalatin@chromium.org>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Gwendal Grignou <gwendal@chromium.org>

diff --git a/drivers/platform/chrome/cros_ec_chardev.c b/drivers/platform/chrome/cros_ec_chardev.c
index 08abd7e5c7bf..74ded441bb50 100644
--- a/drivers/platform/chrome/cros_ec_chardev.c
+++ b/drivers/platform/chrome/cros_ec_chardev.c
@@ -16,21 +16,42 @@
 #include <linux/mfd/cros_ec.h>
 #include <linux/miscdevice.h>
 #include <linux/module.h>
+#include <linux/notifier.h>
 #include <linux/platform_data/cros_ec_chardev.h>
 #include <linux/platform_data/cros_ec_commands.h>
 #include <linux/platform_data/cros_ec_proto.h>
 #include <linux/platform_device.h>
+#include <linux/poll.h>
 #include <linux/slab.h>
 #include <linux/types.h>
 #include <linux/uaccess.h>
 
 #define DRV_NAME		"cros-ec-chardev"
 
+/* Arbitrary bounded size for the event queue */
+#define CROS_MAX_EVENT_LEN	PAGE_SIZE
+
 struct chardev_data {
 	struct cros_ec_dev *ec_dev;
 	struct miscdevice misc;
 };
 
+struct chardev_priv {
+	struct cros_ec_dev *ec_dev;
+	struct notifier_block notifier;
+	wait_queue_head_t wait_event;
+	unsigned long event_mask;
+	struct list_head events;
+	size_t event_len;
+};
+
+struct ec_event {
+	struct list_head node;
+	size_t size;
+	u8 event_type;
+	u8 data[0];
+};
+
 static int ec_get_version(struct cros_ec_dev *ec, char *str, int maxlen)
 {
 	static const char * const current_image_name[] = {
@@ -69,6 +90,71 @@ static int ec_get_version(struct cros_ec_dev *ec, char *str, int maxlen)
 	return ret;
 }
 
+static int cros_ec_chardev_mkbp_event(struct notifier_block *nb,
+				      unsigned long queued_during_suspend,
+				      void *_notify)
+{
+	struct chardev_priv *priv = container_of(nb, struct chardev_priv,
+						 notifier);
+	struct cros_ec_device *ec_dev = priv->ec_dev->ec_dev;
+	struct ec_event *event;
+	unsigned long event_bit = 1 << ec_dev->event_data.event_type;
+	int total_size = sizeof(*event) + ec_dev->event_size;
+
+	if (!(event_bit & priv->event_mask) ||
+	    (priv->event_len + total_size) > CROS_MAX_EVENT_LEN)
+		return NOTIFY_DONE;
+
+	event = kzalloc(total_size, GFP_KERNEL);
+	if (!event)
+		return NOTIFY_DONE;
+
+	event->size = ec_dev->event_size;
+	event->event_type = ec_dev->event_data.event_type;
+	memcpy(event->data, &ec_dev->event_data.data, ec_dev->event_size);
+
+	spin_lock(&priv->wait_event.lock);
+	list_add_tail(&event->node, &priv->events);
+	priv->event_len += total_size;
+	wake_up_locked(&priv->wait_event);
+	spin_unlock(&priv->wait_event.lock);
+
+	return NOTIFY_OK;
+}
+
+static struct ec_event *cros_ec_chardev_fetch_event(struct chardev_priv *priv,
+						    bool fetch, bool block)
+{
+	struct ec_event *event;
+	int err;
+
+	spin_lock(&priv->wait_event.lock);
+	if (!block && list_empty(&priv->events)) {
+		event = ERR_PTR(-EWOULDBLOCK);
+		goto out;
+	}
+
+	if (!fetch) {
+		event = NULL;
+		goto out;
+	}
+
+	err = wait_event_interruptible_locked(priv->wait_event,
+					      !list_empty(&priv->events));
+	if (err) {
+		event = ERR_PTR(err);
+		goto out;
+	}
+
+	event = list_first_entry(&priv->events, struct ec_event, node);
+	list_del(&event->node);
+	priv->event_len -= sizeof(*event) + event->size;
+
+out:
+	spin_unlock(&priv->wait_event.lock);
+	return event;
+}
+
 /*
  * Device file ops
  */
@@ -76,11 +162,40 @@ static int cros_ec_chardev_open(struct inode *inode, struct file *filp)
 {
 	struct miscdevice *mdev = filp->private_data;
 	struct cros_ec_dev *ec_dev = dev_get_drvdata(mdev->parent);
+	struct chardev_priv *priv;
+	int ret;
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
 
-	filp->private_data = ec_dev;
+	priv->ec_dev = ec_dev;
+	filp->private_data = priv;
+	INIT_LIST_HEAD(&priv->events);
+	init_waitqueue_head(&priv->wait_event);
 	nonseekable_open(inode, filp);
 
-	return 0;
+	priv->notifier.notifier_call = cros_ec_chardev_mkbp_event;
+	ret = blocking_notifier_chain_register(&ec_dev->ec_dev->event_notifier,
+					       &priv->notifier);
+	if (ret) {
+		dev_err(ec_dev->dev, "failed to register event notifier\n");
+		kfree(priv);
+	}
+
+	return ret;
+}
+
+static __poll_t cros_ec_chardev_poll(struct file *filp, poll_table *wait)
+{
+	struct chardev_priv *priv = filp->private_data;
+
+	poll_wait(filp, &priv->wait_event, wait);
+
+	if (list_empty(&priv->events))
+		return 0;
+
+	return EPOLLIN | EPOLLRDNORM;
 }
 
 static ssize_t cros_ec_chardev_read(struct file *filp, char __user *buffer,
@@ -88,14 +203,42 @@ static ssize_t cros_ec_chardev_read(struct file *filp, char __user *buffer,
 {
 	char msg[sizeof(struct ec_response_get_version) +
 		 sizeof(CROS_EC_DEV_VERSION)];
-	struct cros_ec_dev *ec = filp->private_data;
+	struct chardev_priv *priv = filp->private_data;
+	struct cros_ec_dev *ec_dev = priv->ec_dev;
 	size_t count;
 	int ret;
 
+	if (priv->event_mask) { /* queued MKBP event */
+		struct ec_event *event;
+
+		event = cros_ec_chardev_fetch_event(priv, length != 0,
+						!(filp->f_flags & O_NONBLOCK));
+		if (IS_ERR(event))
+			return PTR_ERR(event);
+		/*
+		 * length == 0 is special - no IO is done but we check
+		 * for error conditions.
+		 */
+		if (length == 0)
+			return 0;
+
+		/* The event is 1 byte of type plus the payload */
+		count = min(length, event->size + 1);
+		ret = copy_to_user(buffer, &event->event_type, count);
+		kfree(event);
+		if (ret) /* the copy failed */
+			return -EFAULT;
+		*offset = count;
+		return count;
+	}
+
+	/*
+	 * Legacy behavior if no event mask is defined
+	 */
 	if (*offset != 0)
 		return 0;
 
-	ret = ec_get_version(ec, msg, sizeof(msg));
+	ret = ec_get_version(ec_dev, msg, sizeof(msg));
 	if (ret)
 		return ret;
 
@@ -108,6 +251,24 @@ static ssize_t cros_ec_chardev_read(struct file *filp, char __user *buffer,
 	return count;
 }
 
+static int cros_ec_chardev_release(struct inode *inode, struct file *filp)
+{
+	struct chardev_priv *priv = filp->private_data;
+	struct cros_ec_dev *ec_dev = priv->ec_dev;
+	struct ec_event *event, *e;
+
+	blocking_notifier_chain_unregister(&ec_dev->ec_dev->event_notifier,
+					   &priv->notifier);
+
+	list_for_each_entry_safe(event, e, &priv->events, node) {
+		list_del(&event->node);
+		kfree(event);
+	}
+	kfree(priv);
+
+	return 0;
+}
+
 /*
  * Ioctls
  */
@@ -181,7 +342,8 @@ static long cros_ec_chardev_ioctl_readmem(struct cros_ec_dev *ec,
 static long cros_ec_chardev_ioctl(struct file *filp, unsigned int cmd,
 				   unsigned long arg)
 {
-	struct cros_ec_dev *ec = filp->private_data;
+	struct chardev_priv *priv = filp->private_data;
+	struct cros_ec_dev *ec = priv->ec_dev;
 
 	if (_IOC_TYPE(cmd) != CROS_EC_DEV_IOC)
 		return -ENOTTY;
@@ -191,6 +353,9 @@ static long cros_ec_chardev_ioctl(struct file *filp, unsigned int cmd,
 		return cros_ec_chardev_ioctl_xcmd(ec, (void __user *)arg);
 	case CROS_EC_DEV_IOCRDMEM:
 		return cros_ec_chardev_ioctl_readmem(ec, (void __user *)arg);
+	case CROS_EC_DEV_IOCEVENTMASK:
+		priv->event_mask = arg;
+		return 0;
 	}
 
 	return -ENOTTY;
@@ -198,7 +363,9 @@ static long cros_ec_chardev_ioctl(struct file *filp, unsigned int cmd,
 
 static const struct file_operations chardev_fops = {
 	.open		= cros_ec_chardev_open,
+	.poll		= cros_ec_chardev_poll,
 	.read		= cros_ec_chardev_read,
+	.release	= cros_ec_chardev_release,
 	.unlocked_ioctl	= cros_ec_chardev_ioctl,
 #ifdef CONFIG_COMPAT
 	.compat_ioctl	= cros_ec_chardev_ioctl,

commit 840d9f131f65b021e0a73f3371f3194897dba6ad
Author: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date:   Mon Sep 2 11:53:05 2019 +0200

    mfd / platform: cros_ec: Reorganize platform and mfd includes
    
    There is a bit of mess between cros-ec mfd includes and platform
    includes. For example, we have a linux/mfd/cros_ec.h include that
    exports the interface implemented in platform/chrome/cros_ec_proto.c. Or
    we have a linux/mfd/cros_ec_commands.h file that is non related to the
    multifunction device (in the sense that is not exporting any function of
    the mfd device). This causes crossed includes between mfd and
    platform/chrome subsystems and makes the code difficult to read, apart
    from creating 'curious' situations where a platform/chrome driver includes
    a linux/mfd/cros_ec.h file just to get the exported functions that are
    implemented in another platform/chrome driver.
    
    In order to have a better separation on what the cros-ec multifunction
    driver does and what the cros-ec core provides move and rework the
    affected includes doing:
    
     - Move cros_ec_commands.h to include/linux/platform_data/cros_ec_commands.h
     - Get rid of the parts that are implemented in the platform/chrome/cros_ec_proto.c
       driver from include/linux/mfd/cros_ec.h to a new file
       include/linux/platform_data/cros_ec_proto.h
     - Update all the drivers with the new includes, so
       - Drivers that only need to know about the protocol include
         - linux/platform_data/cros_ec_proto.h
         - linux/platform_data/cros_ec_commands.h
       - Drivers that need to know about the cros-ec mfd device also include
         - linux/mfd/cros_ec.h
    
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Acked-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Acked-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Acked-by: Chanwoo Choi <cw00.choi@samsung.com>
    Reviewed-by: Gwendal Grignou <gwendal@chromium.org>
    Tested-by: Gwendal Grignou <gwendal@chromium.org>
    Series changes: 3
    - Fix dereferencing pointer to incomplete type 'struct cros_ec_dev' (lkp)
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/platform/chrome/cros_ec_chardev.c b/drivers/platform/chrome/cros_ec_chardev.c
index 174f940822c9..08abd7e5c7bf 100644
--- a/drivers/platform/chrome/cros_ec_chardev.c
+++ b/drivers/platform/chrome/cros_ec_chardev.c
@@ -14,10 +14,11 @@
 #include <linux/device.h>
 #include <linux/fs.h>
 #include <linux/mfd/cros_ec.h>
-#include <linux/mfd/cros_ec_commands.h>
 #include <linux/miscdevice.h>
 #include <linux/module.h>
 #include <linux/platform_data/cros_ec_chardev.h>
+#include <linux/platform_data/cros_ec_commands.h>
+#include <linux/platform_data/cros_ec_proto.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 #include <linux/types.h>

commit eda2e30c6684d67288edb841c6125d48c608a242
Author: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date:   Mon Sep 2 11:53:02 2019 +0200

    mfd / platform: cros_ec: Miscellaneous character device to talk with the EC
    
    That's a driver to talk with the ChromeOS Embedded Controller via a
    miscellaneous character device, it creates an entry in /dev for every
    instance and implements basic file operations for communicating with the
    Embedded Controller with an userspace application. The API is moved to
    the uapi folder, which is supposed to contain the user space API of the
    kernel.
    
    Note that this will replace current character device interface
    implemented in the cros-ec-dev driver in the MFD subsystem. The idea is
    to move all the functionality that extends the bounds of what MFD was
    designed to platform/chrome subsystem.
    
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Gwendal Grignou <gwendal@chromium.org>
    Tested-by: Gwendal Grignou <gwendal@chromium.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/platform/chrome/cros_ec_chardev.c b/drivers/platform/chrome/cros_ec_chardev.c
new file mode 100644
index 000000000000..174f940822c9
--- /dev/null
+++ b/drivers/platform/chrome/cros_ec_chardev.c
@@ -0,0 +1,251 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Miscellaneous character driver for ChromeOS Embedded Controller
+ *
+ * Copyright 2014 Google, Inc.
+ * Copyright 2019 Google LLC
+ *
+ * This file is a rework and part of the code is ported from
+ * drivers/mfd/cros_ec_dev.c that was originally written by
+ * Bill Richardson.
+ */
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/mfd/cros_ec.h>
+#include <linux/mfd/cros_ec_commands.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/platform_data/cros_ec_chardev.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/uaccess.h>
+
+#define DRV_NAME		"cros-ec-chardev"
+
+struct chardev_data {
+	struct cros_ec_dev *ec_dev;
+	struct miscdevice misc;
+};
+
+static int ec_get_version(struct cros_ec_dev *ec, char *str, int maxlen)
+{
+	static const char * const current_image_name[] = {
+		"unknown", "read-only", "read-write", "invalid",
+	};
+	struct ec_response_get_version *resp;
+	struct cros_ec_command *msg;
+	int ret;
+
+	msg = kzalloc(sizeof(*msg) + sizeof(*resp), GFP_KERNEL);
+	if (!msg)
+		return -ENOMEM;
+
+	msg->command = EC_CMD_GET_VERSION + ec->cmd_offset;
+	msg->insize = sizeof(*resp);
+
+	ret = cros_ec_cmd_xfer_status(ec->ec_dev, msg);
+	if (ret < 0) {
+		snprintf(str, maxlen,
+			 "Unknown EC version, returned error: %d\n",
+			 msg->result);
+		goto exit;
+	}
+
+	resp = (struct ec_response_get_version *)msg->data;
+	if (resp->current_image >= ARRAY_SIZE(current_image_name))
+		resp->current_image = 3; /* invalid */
+
+	snprintf(str, maxlen, "%s\n%s\n%s\n%s\n", CROS_EC_DEV_VERSION,
+		 resp->version_string_ro, resp->version_string_rw,
+		 current_image_name[resp->current_image]);
+
+	ret = 0;
+exit:
+	kfree(msg);
+	return ret;
+}
+
+/*
+ * Device file ops
+ */
+static int cros_ec_chardev_open(struct inode *inode, struct file *filp)
+{
+	struct miscdevice *mdev = filp->private_data;
+	struct cros_ec_dev *ec_dev = dev_get_drvdata(mdev->parent);
+
+	filp->private_data = ec_dev;
+	nonseekable_open(inode, filp);
+
+	return 0;
+}
+
+static ssize_t cros_ec_chardev_read(struct file *filp, char __user *buffer,
+				     size_t length, loff_t *offset)
+{
+	char msg[sizeof(struct ec_response_get_version) +
+		 sizeof(CROS_EC_DEV_VERSION)];
+	struct cros_ec_dev *ec = filp->private_data;
+	size_t count;
+	int ret;
+
+	if (*offset != 0)
+		return 0;
+
+	ret = ec_get_version(ec, msg, sizeof(msg));
+	if (ret)
+		return ret;
+
+	count = min(length, strlen(msg));
+
+	if (copy_to_user(buffer, msg, count))
+		return -EFAULT;
+
+	*offset = count;
+	return count;
+}
+
+/*
+ * Ioctls
+ */
+static long cros_ec_chardev_ioctl_xcmd(struct cros_ec_dev *ec, void __user *arg)
+{
+	struct cros_ec_command *s_cmd;
+	struct cros_ec_command u_cmd;
+	long ret;
+
+	if (copy_from_user(&u_cmd, arg, sizeof(u_cmd)))
+		return -EFAULT;
+
+	if (u_cmd.outsize > EC_MAX_MSG_BYTES ||
+	    u_cmd.insize > EC_MAX_MSG_BYTES)
+		return -EINVAL;
+
+	s_cmd = kmalloc(sizeof(*s_cmd) + max(u_cmd.outsize, u_cmd.insize),
+			GFP_KERNEL);
+	if (!s_cmd)
+		return -ENOMEM;
+
+	if (copy_from_user(s_cmd, arg, sizeof(*s_cmd) + u_cmd.outsize)) {
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	if (u_cmd.outsize != s_cmd->outsize ||
+	    u_cmd.insize != s_cmd->insize) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	s_cmd->command += ec->cmd_offset;
+	ret = cros_ec_cmd_xfer(ec->ec_dev, s_cmd);
+	/* Only copy data to userland if data was received. */
+	if (ret < 0)
+		goto exit;
+
+	if (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + s_cmd->insize))
+		ret = -EFAULT;
+exit:
+	kfree(s_cmd);
+	return ret;
+}
+
+static long cros_ec_chardev_ioctl_readmem(struct cros_ec_dev *ec,
+					   void __user *arg)
+{
+	struct cros_ec_device *ec_dev = ec->ec_dev;
+	struct cros_ec_readmem s_mem = { };
+	long num;
+
+	/* Not every platform supports direct reads */
+	if (!ec_dev->cmd_readmem)
+		return -ENOTTY;
+
+	if (copy_from_user(&s_mem, arg, sizeof(s_mem)))
+		return -EFAULT;
+
+	num = ec_dev->cmd_readmem(ec_dev, s_mem.offset, s_mem.bytes,
+				  s_mem.buffer);
+	if (num <= 0)
+		return num;
+
+	if (copy_to_user((void __user *)arg, &s_mem, sizeof(s_mem)))
+		return -EFAULT;
+
+	return num;
+}
+
+static long cros_ec_chardev_ioctl(struct file *filp, unsigned int cmd,
+				   unsigned long arg)
+{
+	struct cros_ec_dev *ec = filp->private_data;
+
+	if (_IOC_TYPE(cmd) != CROS_EC_DEV_IOC)
+		return -ENOTTY;
+
+	switch (cmd) {
+	case CROS_EC_DEV_IOCXCMD:
+		return cros_ec_chardev_ioctl_xcmd(ec, (void __user *)arg);
+	case CROS_EC_DEV_IOCRDMEM:
+		return cros_ec_chardev_ioctl_readmem(ec, (void __user *)arg);
+	}
+
+	return -ENOTTY;
+}
+
+static const struct file_operations chardev_fops = {
+	.open		= cros_ec_chardev_open,
+	.read		= cros_ec_chardev_read,
+	.unlocked_ioctl	= cros_ec_chardev_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl	= cros_ec_chardev_ioctl,
+#endif
+};
+
+static int cros_ec_chardev_probe(struct platform_device *pdev)
+{
+	struct cros_ec_dev *ec_dev = dev_get_drvdata(pdev->dev.parent);
+	struct cros_ec_platform *ec_platform = dev_get_platdata(ec_dev->dev);
+	struct chardev_data *data;
+
+	/* Create a char device: we want to create it anew */
+	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->ec_dev = ec_dev;
+	data->misc.minor = MISC_DYNAMIC_MINOR;
+	data->misc.fops = &chardev_fops;
+	data->misc.name = ec_platform->ec_name;
+	data->misc.parent = pdev->dev.parent;
+
+	dev_set_drvdata(&pdev->dev, data);
+
+	return misc_register(&data->misc);
+}
+
+static int cros_ec_chardev_remove(struct platform_device *pdev)
+{
+	struct chardev_data *data = dev_get_drvdata(&pdev->dev);
+
+	misc_deregister(&data->misc);
+
+	return 0;
+}
+
+static struct platform_driver cros_ec_chardev_driver = {
+	.driver = {
+		.name = DRV_NAME,
+	},
+	.probe = cros_ec_chardev_probe,
+	.remove = cros_ec_chardev_remove,
+};
+
+module_platform_driver(cros_ec_chardev_driver);
+
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_AUTHOR("Enric Balletbo i Serra <enric.balletbo@collabora.com>");
+MODULE_DESCRIPTION("ChromeOS EC Miscellaneous Character Driver");
+MODULE_LICENSE("GPL");
