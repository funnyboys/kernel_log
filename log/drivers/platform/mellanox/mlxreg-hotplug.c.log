commit 84c0eb212c88176142a0aaf1f896d9bddd8bcb7a
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Thu Mar 26 22:09:52 2020 +0100

    platform/mellanox: mlxreg-hotplug: convert to use i2c_new_client_device()
    
    Move away from the deprecated API and return the shiny new ERRPTR where
    useful.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Acked-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/platform/mellanox/mlxreg-hotplug.c b/drivers/platform/mellanox/mlxreg-hotplug.c
index 77be37a1fbcf..ed48917af162 100644
--- a/drivers/platform/mellanox/mlxreg-hotplug.c
+++ b/drivers/platform/mellanox/mlxreg-hotplug.c
@@ -101,6 +101,7 @@ static int mlxreg_hotplug_device_create(struct mlxreg_hotplug_priv_data *priv,
 					struct mlxreg_core_data *data)
 {
 	struct mlxreg_core_hotplug_platform_data *pdata;
+	struct i2c_client *client;
 
 	/* Notify user by sending hwmon uevent. */
 	kobject_uevent(&priv->hwmon->kobj, KOBJ_CHANGE);
@@ -121,18 +122,20 @@ static int mlxreg_hotplug_device_create(struct mlxreg_hotplug_priv_data *priv,
 		return -EFAULT;
 	}
 
-	data->hpdev.client = i2c_new_device(data->hpdev.adapter,
-					    data->hpdev.brdinfo);
-	if (!data->hpdev.client) {
+	client = i2c_new_client_device(data->hpdev.adapter,
+				       data->hpdev.brdinfo);
+	if (IS_ERR(client)) {
 		dev_err(priv->dev, "Failed to create client %s at bus %d at addr 0x%02x\n",
 			data->hpdev.brdinfo->type, data->hpdev.nr +
 			pdata->shift_nr, data->hpdev.brdinfo->addr);
 
 		i2c_put_adapter(data->hpdev.adapter);
 		data->hpdev.adapter = NULL;
-		return -EFAULT;
+		return PTR_ERR(client);
 	}
 
+	data->hpdev.client = client;
+
 	return 0;
 }
 

commit 0e41bf06eefe969ee5092f4ec55ae1b0ff9c1ea0
Author: Vadim Pasternak <vadimp@mellanox.com>
Date:   Mon Jan 13 16:28:38 2020 +0000

    platform/mellanox: mlxreg-hotplug: Add support for new capability register
    
    Add support for capability register, which is used for detection of the
    actual number of interrupt capable components within the particular
    group, supported by the specific system.
    Such components could be for example the number of power units and
    interrupts related to these units.
    The motivation is to avoid adding a new code in the future in order to
    distinct between the systems type supported different number of the
    components like power supplies, FANs, ASICs, line cards.
    
    Signed-off-by: Vadim Pasternak <vadimp@mellanox.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/mellanox/mlxreg-hotplug.c b/drivers/platform/mellanox/mlxreg-hotplug.c
index 706207d192ae..77be37a1fbcf 100644
--- a/drivers/platform/mellanox/mlxreg-hotplug.c
+++ b/drivers/platform/mellanox/mlxreg-hotplug.c
@@ -504,6 +504,20 @@ static int mlxreg_hotplug_set_irq(struct mlxreg_hotplug_priv_data *priv)
 	item = pdata->items;
 
 	for (i = 0; i < pdata->counter; i++, item++) {
+		if (item->capability) {
+			/*
+			 * Read group capability register to get actual number
+			 * of interrupt capable components and set group mask
+			 * accordingly.
+			 */
+			ret = regmap_read(priv->regmap, item->capability,
+					  &regval);
+			if (ret)
+				goto out;
+
+			item->mask = GENMASK((regval & item->mask) - 1, 0);
+		}
+
 		/* Clear group presense event. */
 		ret = regmap_write(priv->regmap, item->reg +
 				   MLXREG_HOTPLUG_EVENT_OFF, 0);

commit eaae882c4a77c8aa2ca20d4447aeb81d9d5eec97
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Tue Jul 30 11:15:53 2019 -0700

    platform/mellanox: mlxreg-hotplug: Remove dev_err() usage after platform_get_irq()
    
    We don't need dev_err() messages when platform_get_irq() fails now that
    platform_get_irq() prints an error message itself when something goes
    wrong. Let's remove these prints with a simple semantic patch.
    
    // <smpl>
    @@
    expression ret;
    struct platform_device *E;
    @@
    
    ret =
    (
    platform_get_irq(E, ...)
    |
    platform_get_irq_byname(E, ...)
    );
    
    if ( \( ret < 0 \| ret <= 0 \) )
    {
    (
    -if (ret != -EPROBE_DEFER)
    -{ ...
    -dev_err(...);
    -... }
    |
    ...
    -dev_err(...);
    )
    ...
    }
    // </smpl>
    
    While we're here, remove braces on if statements that only have one
    statement (manually).
    
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Cc: Hans de Goede <hdegoede@redhat.com>
    Cc: "Darren Hart (VMware)" <dvhart@infradead.org>
    Cc: Roman Kiryanov <rkir@google.com>
    Cc: Vadim Pasternak <vadimp@mellanox.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/mellanox/mlxreg-hotplug.c b/drivers/platform/mellanox/mlxreg-hotplug.c
index f85a1b9d129b..706207d192ae 100644
--- a/drivers/platform/mellanox/mlxreg-hotplug.c
+++ b/drivers/platform/mellanox/mlxreg-hotplug.c
@@ -642,11 +642,8 @@ static int mlxreg_hotplug_probe(struct platform_device *pdev)
 		priv->irq = pdata->irq;
 	} else {
 		priv->irq = platform_get_irq(pdev, 0);
-		if (priv->irq < 0) {
-			dev_err(&pdev->dev, "Failed to get platform irq: %d\n",
-				priv->irq);
+		if (priv->irq < 0)
 			return priv->irq;
-		}
 	}
 
 	priv->regmap = pdata->regmap;

commit 8c2eb7b6468ad4aa5600aed01aa0715f921a3f8b
Author: Vadim Pasternak <vadimp@mellanox.com>
Date:   Thu May 23 16:41:52 2019 +0000

    platform/mellanox: mlxreg-hotplug: Add devm_free_irq call to remove flow
    
    Add devm_free_irq() call to mlxreg-hotplug remove() for clean release
    of devices irq resource. Fix debugobjects warning triggered by rmmod
    It prevents of use-after-free memory, related to
    mlxreg_hotplug_work_handler.
    
    Issue has been reported as debugobjects warning triggered by
    'rmmod mlxtreg-hotplug' flow, while running kernel with
    CONFIG_DEBUG_OBJECTS* options.
    
    [ 2489.623551] ODEBUG: free active (active state 0) object type: work_struct hint: mlxreg_hotplug_work_handler+0x0/0x7f0 [mlxreg_hotplug]
    [ 2489.637097] WARNING: CPU: 5 PID: 3924 at lib/debugobjects.c:328 debug_print_object+0xfe/0x180
    [ 2489.637165] RIP: 0010:debug_print_object+0xfe/0x180
    ?
    [ 2489.637214] Call Trace:
    [ 2489.637225]  __debug_check_no_obj_freed+0x25e/0x320
    [ 2489.637231]  kfree+0x82/0x110
    [ 2489.637238]  release_nodes+0x33c/0x4e0
    [ 2489.637242]  ? devres_remove_group+0x1b0/0x1b0
    [ 2489.637247]  device_release_driver_internal+0x146/0x270
    [ 2489.637251]  driver_detach+0x73/0xe0
    [ 2489.637254]  bus_remove_driver+0xa1/0x170
    [ 2489.637261]  __x64_sys_delete_module+0x29e/0x320
    [ 2489.637265]  ? __ia32_sys_delete_module+0x320/0x320
    [ 2489.637268]  ? blkcg_exit_queue+0x20/0x20
    [ 2489.637273]  ? task_work_run+0x7d/0x100
    [ 2489.637278]  ? exit_to_usermode_loop+0x5b/0xf0
    [ 2489.637281]  do_syscall_64+0x73/0x160
    [ 2489.637287]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
    [ 2489.637290] RIP: 0033:0x7f95c3596fd7
    
    The difference in release flow with and with no devm_free_irq is listed
    below:
    
    bus: 'platform': remove driver mlxreg-hotplug
     mlxreg_hotplug_remove(start)
                                            -> devm_free_irq (with new code)
     mlxreg_hotplug_remove (end)
     release_nodes (start)
      mlxreg-hotplug: DEVRES REL devm_hwmon_release (8 bytes)
      device: 'hwmon3': device_unregister
      PM: Removing info for No Bus:hwmon3
      mlxreg-hotplug: DEVRES REL devm_kzalloc_release (88 bytes)
      mlxreg-hotplug: DEVRES REL devm_kzalloc_release (6 bytes)
      mlxreg-hotplug: DEVRES REL devm_kzalloc_release (5 bytes)
      mlxreg-hotplug: DEVRES REL devm_kzalloc_release (5 bytes)
      mlxreg-hotplug: DEVRES REL devm_kzalloc_release (5 bytes)
      mlxreg-hotplug: DEVRES REL devm_kzalloc_release (5 bytes)
      mlxreg-hotplug: DEVRES REL devm_kzalloc_release (5 bytes)
      mlxreg-hotplug: DEVRES REL devm_kzalloc_release (5 bytes)
      mlxreg-hotplug: DEVRES REL devm_kzalloc_release (5 bytes)
      mlxreg-hotplug: DEVRES REL devm_kzalloc_release (5 bytes)
      mlxreg-hotplug: DEVRES REL devm_kzalloc_release (5 bytes)
      mlxreg-hotplug: DEVRES REL devm_kzalloc_release (5 bytes)
      mlxreg-hotplug: DEVRES REL devm_irq_release (16 bytes) (no new code)
      mlxreg-hotplug: DEVRES REL devm_kzalloc_release (1376 bytes)
       ------------[ cut here ]------------ (no new code):
       ODEBUG: free active (active state 0) object type: work_struct hint: mlxreg_hotplug_work_handler
    
     release_nodes(end)
    driver: 'mlxreg-hotplug': driver_release
    
    Fixes: 1f976f6978bf ("platform/x86: Move Mellanox platform hotplug driver to platform/mellanox")
    Signed-off-by: Vadim Pasternak <vadimp@mellanox.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/platform/mellanox/mlxreg-hotplug.c b/drivers/platform/mellanox/mlxreg-hotplug.c
index 687ce6817d0d..f85a1b9d129b 100644
--- a/drivers/platform/mellanox/mlxreg-hotplug.c
+++ b/drivers/platform/mellanox/mlxreg-hotplug.c
@@ -694,6 +694,7 @@ static int mlxreg_hotplug_remove(struct platform_device *pdev)
 
 	/* Clean interrupts setup. */
 	mlxreg_hotplug_unset_irq(priv);
+	devm_free_irq(&pdev->dev, priv->irq, priv);
 
 	return 0;
 }

commit e4c275f77624961b56cce397814d9d770a45ac59
Author: Vadim Pasternak <vadimp@mellanox.com>
Date:   Sun Feb 17 18:15:30 2019 +0000

    platform/mellanox: mlxreg-hotplug: Fix KASAN warning
    
    Fix the following KASAN warning produced when booting a 64-bit kernel:
    [   13.334750] BUG: KASAN: stack-out-of-bounds in find_first_bit+0x19/0x70
    [   13.342166] Read of size 8 at addr ffff880235067178 by task kworker/2:1/42
    [   13.342176] CPU: 2 PID: 42 Comm: kworker/2:1 Not tainted 4.20.0-rc1+ #106
    [   13.342179] Hardware name: Mellanox Technologies Ltd. MSN2740/Mellanox x86 SFF board, BIOS 5.6.5 06/07/2016
    [   13.342190] Workqueue: events deferred_probe_work_func
    [   13.342194] Call Trace:
    [   13.342206]  dump_stack+0xc7/0x15b
    [   13.342214]  ? show_regs_print_info+0x5/0x5
    [   13.342220]  ? kmsg_dump_rewind_nolock+0x59/0x59
    [   13.342234]  ? _raw_write_lock_irqsave+0x100/0x100
    [   13.351593]  print_address_description+0x73/0x260
    [   13.351603]  kasan_report+0x260/0x380
    [   13.351611]  ? find_first_bit+0x19/0x70
    [   13.351619]  find_first_bit+0x19/0x70
    [   13.351630]  mlxreg_hotplug_work_handler+0x73c/0x920 [mlxreg_hotplug]
    [   13.351639]  ? __lock_text_start+0x8/0x8
    [   13.351646]  ? _raw_write_lock_irqsave+0x80/0x100
    [   13.351656]  ? mlxreg_hotplug_remove+0x1e0/0x1e0 [mlxreg_hotplug]
    [   13.351663]  ? regmap_volatile+0x40/0xb0
    [   13.351668]  ? regcache_write+0x4c/0x90
    [   13.351676]  ? mlxplat_mlxcpld_reg_write+0x24/0x30 [mlx_platform]
    [   13.351681]  ? _regmap_write+0xea/0x220
    [   13.351688]  ? __mutex_lock_slowpath+0x10/0x10
    [   13.351696]  ? devm_add_action+0x70/0x70
    [   13.351701]  ? mutex_unlock+0x1d/0x40
    [   13.351710]  mlxreg_hotplug_probe+0x82e/0x989 [mlxreg_hotplug]
    [   13.351723]  ? mlxreg_hotplug_work_handler+0x920/0x920 [mlxreg_hotplug]
    [   13.351731]  ? sysfs_do_create_link_sd.isra.2+0xf4/0x190
    [   13.351737]  ? sysfs_rename_link_ns+0xf0/0xf0
    [   13.351743]  ? devres_close_group+0x2b0/0x2b0
    [   13.351749]  ? pinctrl_put+0x20/0x20
    [   13.351755]  ? acpi_dev_pm_attach+0x2c/0xd0
    [   13.351763]  platform_drv_probe+0x70/0xd0
    [   13.351771]  really_probe+0x480/0x6e0
    [   13.351778]  ? device_attach+0x10/0x10
    [   13.351784]  ? __lock_text_start+0x8/0x8
    [   13.351790]  ? _raw_write_lock_irqsave+0x80/0x100
    [   13.351797]  ? _raw_write_lock_irqsave+0x80/0x100
    [   13.351806]  ? __driver_attach+0x190/0x190
    [   13.351812]  driver_probe_device+0x17d/0x1a0
    [   13.351819]  ? __driver_attach+0x190/0x190
    [   13.351825]  bus_for_each_drv+0xd6/0x130
    [   13.351831]  ? bus_rescan_devices+0x20/0x20
    [   13.351837]  ? __mutex_lock_slowpath+0x10/0x10
    [   13.351845]  __device_attach+0x18c/0x230
    [   13.351852]  ? device_bind_driver+0x70/0x70
    [   13.351859]  ? __mutex_lock_slowpath+0x10/0x10
    [   13.351866]  bus_probe_device+0xea/0x110
    [   13.351874]  deferred_probe_work_func+0x1c9/0x290
    [   13.351882]  ? driver_deferred_probe_add+0x1d0/0x1d0
    [   13.351889]  ? preempt_notifier_dec+0x20/0x20
    [   13.351897]  ? read_word_at_a_time+0xe/0x20
    [   13.351904]  ? strscpy+0x151/0x290
    [   13.351912]  ? set_work_pool_and_clear_pending+0x9c/0xf0
    [   13.351918]  ? __switch_to_asm+0x34/0x70
    [   13.351924]  ? __switch_to_asm+0x40/0x70
    [   13.351929]  ? __switch_to_asm+0x34/0x70
    [   13.351935]  ? __switch_to_asm+0x40/0x70
    [   13.351942]  process_one_work+0x5cc/0xa00
    [   13.351952]  ? pwq_dec_nr_in_flight+0x1e0/0x1e0
    [   13.351960]  ? pci_mmcfg_check_reserved+0x80/0xb8
    [   13.351967]  ? run_rebalance_domains+0x250/0x250
    [   13.351980]  ? stack_access_ok+0x35/0x80
    [   13.351986]  ? deref_stack_reg+0xa1/0xe0
    [   13.351994]  ? schedule+0xcd/0x250
    [   13.352000]  ? worker_enter_idle+0x2d6/0x330
    [   13.352006]  ? __schedule+0xeb0/0xeb0
    [   13.352014]  ? fork_usermode_blob+0x130/0x130
    [   13.352019]  ? mutex_lock+0xa7/0x100
    [   13.352026]  ? _raw_spin_lock_irq+0x98/0xf0
    [   13.352032]  ? _raw_read_unlock_irqrestore+0x30/0x30
    [   13.352037] i2c i2c-2: Added multiplexed i2c bus 11
    [   13.352043]  worker_thread+0x181/0xa80
    [   13.352052]  ? __switch_to_asm+0x34/0x70
    [   13.352058]  ? __switch_to_asm+0x40/0x70
    [   13.352064]  ? process_one_work+0xa00/0xa00
    [   13.352070]  ? __switch_to_asm+0x34/0x70
    [   13.352076]  ? __switch_to_asm+0x40/0x70
    [   13.352081]  ? __switch_to_asm+0x34/0x70
    [   13.352086]  ? __switch_to_asm+0x40/0x70
    [   13.352092]  ? __switch_to_asm+0x34/0x70
    [   13.352097]  ? __switch_to_asm+0x40/0x70
    [   13.352105]  ? __schedule+0x3d6/0xeb0
    [   13.352112]  ? migrate_swap_stop+0x470/0x470
    [   13.352119]  ? save_stack+0x89/0xb0
    [   13.352127]  ? kmem_cache_alloc_trace+0xe5/0x570
    [   13.352132]  ? kthread+0x59/0x1d0
    [   13.352138]  ? ret_from_fork+0x35/0x40
    [   13.352154]  ? __schedule+0xeb0/0xeb0
    [   13.352161]  ? remove_wait_queue+0x150/0x150
    [   13.352169]  ? _raw_write_lock_irqsave+0x80/0x100
    [   13.352175]  ? __lock_text_start+0x8/0x8
    [   13.352183]  ? process_one_work+0xa00/0xa00
    [   13.352188]  kthread+0x1a4/0x1d0
    [   13.352195]  ? kthread_create_worker_on_cpu+0xc0/0xc0
    [   13.352202]  ret_from_fork+0x35/0x40
    
    [   13.353879] The buggy address belongs to the page:
    [   13.353885] page:ffffea0008d419c0 count:0 mapcount:0 mapping:0000000000000000 index:0x0
    [   13.353890] flags: 0x2ffff8000000000()
    [   13.353897] raw: 02ffff8000000000 ffffea0008d419c8 ffffea0008d419c8 0000000000000000
    [   13.353903] raw: 0000000000000000 0000000000000000 00000000ffffffff 0000000000000000
    [   13.353905] page dumped because: kasan: bad access detected
    
    [   13.353908] Memory state around the buggy address:
    [   13.353912]  ffff880235067000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    [   13.353917]  ffff880235067080: 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1 04
    [   13.353921] >ffff880235067100: f2 f2 f2 f2 f2 f2 f2 04 f2 f2 f2 f2 f2 f2 f2 04
    [   13.353923]                                                                 ^
    [   13.353927]  ffff880235067180: f2 f2 f2 f2 f2 f2 f2 04 f2 f2 f2 00 00 00 00 00
    [   13.353931]  ffff880235067200: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    [   13.353933] ==================================================================
    
    The warning is caused by the below loop:
            for_each_set_bit(bit, (unsigned long *)&asserted, 8) {
    while "asserted" is declared as 'unsigned'.
    
    The casting of 32-bit unsigned integer pointer to a 64-bit unsigned long
    pointer. There are two problems here.
    It causes the access of four extra byte, which can corrupt memory
    The 32-bit pointer address may not be 64-bit aligned.
    
    The fix changes variable "asserted" to "unsigned long".
    
    Fixes: 1f976f6978bf ("platform/x86: Move Mellanox platform hotplug driver to platform/mellanox")
    Signed-off-by: Vadim Pasternak <vadimp@mellanox.com>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/mellanox/mlxreg-hotplug.c b/drivers/platform/mellanox/mlxreg-hotplug.c
index 52314a1ffaaf..687ce6817d0d 100644
--- a/drivers/platform/mellanox/mlxreg-hotplug.c
+++ b/drivers/platform/mellanox/mlxreg-hotplug.c
@@ -248,7 +248,8 @@ mlxreg_hotplug_work_helper(struct mlxreg_hotplug_priv_data *priv,
 			   struct mlxreg_core_item *item)
 {
 	struct mlxreg_core_data *data;
-	u32 asserted, regval, bit;
+	unsigned long asserted;
+	u32 regval, bit;
 	int ret;
 
 	/*
@@ -281,7 +282,7 @@ mlxreg_hotplug_work_helper(struct mlxreg_hotplug_priv_data *priv,
 	asserted = item->cache ^ regval;
 	item->cache = regval;
 
-	for_each_set_bit(bit, (unsigned long *)&asserted, 8) {
+	for_each_set_bit(bit, &asserted, 8) {
 		data = item->data + bit;
 		if (regval & BIT(bit)) {
 			if (item->inversed)

commit 83cdb2c11173ee4aa621c8cce6e1c33fb564d2be
Author: Vadim Pasternak <vadimp@mellanox.com>
Date:   Wed Dec 12 23:59:15 2018 +0000

    platform/x86: mlx-platform: Add support for fan capability registers
    
    Provide support for the fan capability registers for the next generation
    systems of types MQM87xx, MSN34xx, MSN37xx. These new registers provide
    configuration for tachometers and fan drawers connectivity.  Use these
    registers for next generation led, fan and hotplug structures in order
    to distinguish between the systems which have minor configuration
    differences. This reduces the amount of code used to describe such
    systems.
    
    Signed-off-by: Vadim Pasternak <vadimp@mellanox.com>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/mellanox/mlxreg-hotplug.c b/drivers/platform/mellanox/mlxreg-hotplug.c
index b6d44550d98c..52314a1ffaaf 100644
--- a/drivers/platform/mellanox/mlxreg-hotplug.c
+++ b/drivers/platform/mellanox/mlxreg-hotplug.c
@@ -495,7 +495,9 @@ static int mlxreg_hotplug_set_irq(struct mlxreg_hotplug_priv_data *priv)
 {
 	struct mlxreg_core_hotplug_platform_data *pdata;
 	struct mlxreg_core_item *item;
-	int i, ret;
+	struct mlxreg_core_data *data;
+	u32 regval;
+	int i, j, ret;
 
 	pdata = dev_get_platdata(&priv->pdev->dev);
 	item = pdata->items;
@@ -507,6 +509,25 @@ static int mlxreg_hotplug_set_irq(struct mlxreg_hotplug_priv_data *priv)
 		if (ret)
 			goto out;
 
+		/*
+		 * Verify if hardware configuration requires to disable
+		 * interrupt capability for some of components.
+		 */
+		data = item->data;
+		for (j = 0; j < item->count; j++, data++) {
+			/* Verify if the attribute has capability register. */
+			if (data->capability) {
+				/* Read capability register. */
+				ret = regmap_read(priv->regmap,
+						  data->capability, &regval);
+				if (ret)
+					goto out;
+
+				if (!(regval & data->bit))
+					item->mask &= ~BIT(j);
+			}
+		}
+
 		/* Set group initial status as mask and unmask group event. */
 		if (item->inversed) {
 			item->cache = item->mask;

commit 9272d2d1d3bf5b66242acaeffe442fcd6079624e
Author: Vadim Pasternak <vadimp@mellanox.com>
Date:   Thu Jul 26 22:40:59 2018 +0000

    platform/mellanox: mlxreg-hotplug: Add hotplug hwmon uevent notification
    
    Notify user when hotplug device signal is received in order to allow user
    to handle such case, if it wishes to take some action on this matter.
    
    Signed-off-by: Vadim Pasternak <vadimp@mellanox.com>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/mellanox/mlxreg-hotplug.c b/drivers/platform/mellanox/mlxreg-hotplug.c
index f363e0786ef4..b6d44550d98c 100644
--- a/drivers/platform/mellanox/mlxreg-hotplug.c
+++ b/drivers/platform/mellanox/mlxreg-hotplug.c
@@ -102,6 +102,9 @@ static int mlxreg_hotplug_device_create(struct mlxreg_hotplug_priv_data *priv,
 {
 	struct mlxreg_core_hotplug_platform_data *pdata;
 
+	/* Notify user by sending hwmon uevent. */
+	kobject_uevent(&priv->hwmon->kobj, KOBJ_CHANGE);
+
 	/*
 	 * Return if adapter number is negative. It could be in case hotplug
 	 * event is not associated with hotplug device.
@@ -133,8 +136,13 @@ static int mlxreg_hotplug_device_create(struct mlxreg_hotplug_priv_data *priv,
 	return 0;
 }
 
-static void mlxreg_hotplug_device_destroy(struct mlxreg_core_data *data)
+static void
+mlxreg_hotplug_device_destroy(struct mlxreg_hotplug_priv_data *priv,
+			      struct mlxreg_core_data *data)
 {
+	/* Notify user by sending hwmon uevent. */
+	kobject_uevent(&priv->hwmon->kobj, KOBJ_CHANGE);
+
 	if (data->hpdev.client) {
 		i2c_unregister_device(data->hpdev.client);
 		data->hpdev.client = NULL;
@@ -277,14 +285,14 @@ mlxreg_hotplug_work_helper(struct mlxreg_hotplug_priv_data *priv,
 		data = item->data + bit;
 		if (regval & BIT(bit)) {
 			if (item->inversed)
-				mlxreg_hotplug_device_destroy(data);
+				mlxreg_hotplug_device_destroy(priv, data);
 			else
 				mlxreg_hotplug_device_create(priv, data);
 		} else {
 			if (item->inversed)
 				mlxreg_hotplug_device_create(priv, data);
 			else
-				mlxreg_hotplug_device_destroy(data);
+				mlxreg_hotplug_device_destroy(priv, data);
 		}
 	}
 
@@ -351,7 +359,7 @@ mlxreg_hotplug_health_work_helper(struct mlxreg_hotplug_priv_data *priv,
 				 * in steady state. Disconnect associated
 				 * device, if it has been connected.
 				 */
-				mlxreg_hotplug_device_destroy(data);
+				mlxreg_hotplug_device_destroy(priv, data);
 				data->attached = false;
 				data->health_cntr = 0;
 			}
@@ -569,7 +577,7 @@ static void mlxreg_hotplug_unset_irq(struct mlxreg_hotplug_priv_data *priv)
 		/* Remove all the attached devices in group. */
 		count = item->count;
 		for (j = 0; j < count; j++, data++)
-			mlxreg_hotplug_device_destroy(data);
+			mlxreg_hotplug_device_destroy(priv, data);
 	}
 }
 
@@ -634,10 +642,6 @@ static int mlxreg_hotplug_probe(struct platform_device *pdev)
 	disable_irq(priv->irq);
 	spin_lock_init(&priv->lock);
 	INIT_DELAYED_WORK(&priv->dwork_irq, mlxreg_hotplug_work_handler);
-	/* Perform initial interrupts setup. */
-	mlxreg_hotplug_set_irq(priv);
-
-	priv->after_probe = true;
 	dev_set_drvdata(&pdev->dev, priv);
 
 	err = mlxreg_hotplug_attr_init(priv);
@@ -655,6 +659,10 @@ static int mlxreg_hotplug_probe(struct platform_device *pdev)
 		return PTR_ERR(priv->hwmon);
 	}
 
+	/* Perform initial interrupts setup. */
+	mlxreg_hotplug_set_irq(priv);
+	priv->after_probe = true;
+
 	return 0;
 }
 

commit 66342d1c9c2460fe7d2d9c75f7e88f14d88318f2
Author: Vadim Pasternak <vadimp@mellanox.com>
Date:   Thu Jul 26 22:40:58 2018 +0000

    platform/mellanox: mlxreg-hotplug: Improve mechanism of ASIC health discovery
    
    Simplify the logic of ASIC health discovery.
    ASIC device can indicate its health state as a good, booting or dormant.
    During ASIC reset the device is dropped to dormant state and should get to
    the stable good health state through the intermediate booting state.
    The sequence for getting to the steady state health after reset is:
    (dormant -> booting -> good)+.
    Initial implementation assumes that ?good? within this sequence is always
    repeated twice and device is getting steady state only after the second
    ?good?. This patch removes this dependency, since the second ?good? is
    received because of the noise on line and can be ignored. Device reaches
    steady state after the first ?good? is received.
    
    Signed-off-by: Vadim Pasternak <vadimp@mellanox.com>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/mellanox/mlxreg-hotplug.c b/drivers/platform/mellanox/mlxreg-hotplug.c
index ac97aa020db3..f363e0786ef4 100644
--- a/drivers/platform/mellanox/mlxreg-hotplug.c
+++ b/drivers/platform/mellanox/mlxreg-hotplug.c
@@ -50,9 +50,8 @@
 #define MLXREG_HOTPLUG_MASK_OFF		2
 #define MLXREG_HOTPLUG_AGGR_MASK_OFF	1
 
-/* ASIC health parameters. */
-#define MLXREG_HOTPLUG_HEALTH_MASK	0x02
-#define MLXREG_HOTPLUG_RST_CNTR		3
+/* ASIC good health mask. */
+#define MLXREG_HOTPLUG_GOOD_HEALTH_MASK	0x02
 
 #define MLXREG_HOTPLUG_ATTRS_MAX	24
 #define MLXREG_HOTPLUG_NOT_ASSERT	3
@@ -325,21 +324,40 @@ mlxreg_hotplug_health_work_helper(struct mlxreg_hotplug_priv_data *priv,
 			goto out;
 
 		regval &= data->mask;
-		item->cache = regval;
-		if (regval == MLXREG_HOTPLUG_HEALTH_MASK) {
-			if ((data->health_cntr++ == MLXREG_HOTPLUG_RST_CNTR) ||
-			    !priv->after_probe) {
+
+		if (item->cache == regval)
+			goto ack_event;
+
+		/*
+		 * ASIC health indication is provided through two bits. Bits
+		 * value 0x2 indicates that ASIC reached the good health, value
+		 * 0x0 indicates ASIC the bad health or dormant state and value
+		 * 0x3 indicates the booting state. During ASIC reset it should
+		 * pass the following states: dormant -> booting -> good.
+		 */
+		if (regval == MLXREG_HOTPLUG_GOOD_HEALTH_MASK) {
+			if (!data->attached) {
+				/*
+				 * ASIC is in steady state. Connect associated
+				 * device, if configured.
+				 */
 				mlxreg_hotplug_device_create(priv, data);
 				data->attached = true;
 			}
 		} else {
 			if (data->attached) {
+				/*
+				 * ASIC health is failed after ASIC has been
+				 * in steady state. Disconnect associated
+				 * device, if it has been connected.
+				 */
 				mlxreg_hotplug_device_destroy(data);
 				data->attached = false;
 				data->health_cntr = 0;
 			}
 		}
-
+		item->cache = regval;
+ack_event:
 		/* Acknowledge event. */
 		ret = regmap_write(priv->regmap, data->reg +
 				   MLXREG_HOTPLUG_EVENT_OFF, 0);

commit f3b5020e168a383496e3096b754a1ad17f09df36
Merge: 4b4bb99b6246 26ed9d1c07ef
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 14 16:30:30 2018 +0900

    Merge tag 'platform-drivers-x86-v4.18-1' of git://git.infradead.org/linux-platform-drivers-x86
    
    Pull x86 platform driver updates from Darren Hart:
     "Several incremental improvements including new keycodes, new models,
      new quirks, and related documentation. Adds LED platform driver
      activation for Mellanox systems. Some minor optimizations and
      cleanups. Includes several bug fixes, message silencing, mostly minor
    
      Automated summary:
    
      acer-wmi:
       -  add another KEY_POWER keycode
    
      apple-gmux:
       -  fix gmux_get_client_id()'s return type
    
      asus-laptop:
       -  Simplify getting .drvdata
    
      asus-wireless:
       -  Fix format specifier
    
      dell-laptop:
       -  Fix keyboard backlight timeout on XPS 13 9370
    
      dell-smbios:
       -  Match on www.dell.com in OEM strings too
    
      dell-wmi:
       -  Ignore new rfkill and fn-lock events
       -  Set correct keycode for Fn + left arrow
    
      fujitsu-laptop:
       -  Simplify soft key handling
    
      ideapad-laptop:
       -  Add E42-80 to no_hw_rfkill
       -  Add fn-lock setting
       -  Add MIIX 720-12IKB to no_hw_rfkill
    
      lib/string_helpers:
       -  Add missed declaration of struct task_struct
    
      intel_scu_ipc:
       -  Replace mdelay with usleep_range in intel_scu_ipc_i2c_cntrl
    
      mlx-platform:
       -  Add LED platform driver activation
    
      platform/mellanox:
       -  Add new ODM system types to mlx-platform
       -  mlxreg-hotplug: add extra cycle for hotplug work queue
       -  mlxreg-hotplug: Document fixes for hotplug private data
    
      platform_data/mlxreg:
       -  Document fixes for hotplug device
    
      silead_dmi:
       -  Add entry for Chuwi Hi8 tablet touchscreen
       -  Add touchscreen info for the Onda V891w tablet
       -  Add info for the PoV mobii TAB-P800W (v2.0)
       -  Add touchscreen info for the Jumper EZpad 6 Pro
    
      thinkpad_acpi:
       -  silence false-positive-prone pr_warn
       -  do not report thermal sensor state for tablet mode switch
       -  silence HKEY 0x6032, 0x60f0, 0x6030"
    
    * tag 'platform-drivers-x86-v4.18-1' of git://git.infradead.org/linux-platform-drivers-x86: (30 commits)
      platform/x86: silead_dmi: Add entry for Chuwi Hi8 tablet touchscreen
      platform/x86: dell-laptop: Fix keyboard backlight timeout on XPS 13 9370
      platform/x86: dell-wmi: Ignore new rfkill and fn-lock events
      platform/x86: mlx-platform: Add LED platform driver activation
      platform/mellanox: Add new ODM system types to mlx-platform
      platform/mellanox: mlxreg-hotplug: add extra cycle for hotplug work queue
      platform/x86: ideapad-laptop: Add E42-80 to no_hw_rfkill
      platform/x86: silead_dmi: Add touchscreen info for the Onda V891w tablet
      platform/x86: silead_dmi: Add info for the PoV mobii TAB-P800W (v2.0)
      platform/x86: silead_dmi: Add touchscreen info for the Jumper EZpad 6 Pro
      platform/x86: asus-wireless: Fix format specifier
      platform/x86: asus-wmi: Fix NULL pointer dereference
      platform/x86: dell-wmi: Set correct keycode for Fn + left arrow
      platform/x86: acer-wmi: add another KEY_POWER keycode
      platform/x86: ideapad-laptop: Add fn-lock setting
      platform/x86: ideapad-laptop: Add MIIX 720-12IKB to no_hw_rfkill
      lib/string_helpers: Add missed declaration of struct task_struct
      platform/x86: DELL_WMI use depends on instead of select for DELL_SMBIOS
      platform/mellanox: mlxreg-hotplug: Document fixes for hotplug private data
      platform_data/mlxreg: Document fixes for hotplug device
      ...

commit a86854d0c599b3202307abceb68feee4d7061578
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:07:58 2018 -0700

    treewide: devm_kzalloc() -> devm_kcalloc()
    
    The devm_kzalloc() function has a 2-factor argument form, devm_kcalloc().
    This patch replaces cases of:
    
            devm_kzalloc(handle, a * b, gfp)
    
    with:
            devm_kcalloc(handle, a * b, gfp)
    
    as well as handling cases of:
    
            devm_kzalloc(handle, a * b * c, gfp)
    
    with:
    
            devm_kzalloc(handle, array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            devm_kcalloc(handle, array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            devm_kzalloc(handle, 4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    Some manual whitespace fixes were needed in this patch, as Coccinelle
    really liked to write "=devm_kcalloc..." instead of "= devm_kcalloc...".
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    expression HANDLE;
    type TYPE;
    expression THING, E;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression HANDLE;
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    expression HANDLE;
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    expression HANDLE;
    identifier SIZE, COUNT;
    @@
    
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression HANDLE;
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression HANDLE;
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    expression HANDLE;
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression HANDLE;
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression HANDLE;
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, sizeof(THING) * C2, ...)
    |
      devm_kzalloc(HANDLE, sizeof(TYPE) * C2, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2, ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/platform/mellanox/mlxreg-hotplug.c b/drivers/platform/mellanox/mlxreg-hotplug.c
index ea9e7f4479ca..36a41ff506f0 100644
--- a/drivers/platform/mellanox/mlxreg-hotplug.c
+++ b/drivers/platform/mellanox/mlxreg-hotplug.c
@@ -217,7 +217,8 @@ static int mlxreg_hotplug_attr_init(struct mlxreg_hotplug_priv_data *priv)
 		}
 	}
 
-	priv->group.attrs = devm_kzalloc(&priv->pdev->dev, num_attrs *
+	priv->group.attrs = devm_kcalloc(&priv->pdev->dev,
+					 num_attrs,
 					 sizeof(struct attribute *),
 					 GFP_KERNEL);
 	if (!priv->group.attrs)

commit 4b5e32df66877d5ba0ae9ea00c304dc60a18322d
Author: Vadim Pasternak <vadimp@mellanox.com>
Date:   Mon May 7 06:48:51 2018 +0000

    platform/mellanox: mlxreg-hotplug: add extra cycle for hotplug work queue
    
    Add extra cycle for hotplug work queue to handle the case when a signal is
    It adds missed logic for signal acknowledge, by adding an extra run for
    received, but no specific signal assertion is detected. Such case
    theoretically can happen for example in case several units are removed or
    inserted at the same time. In this situation acknowledge for some signal
    can be missed at signal top aggreagation status level. The extra run will
    allow to handler to acknowledge the missed signal.
    
    The interrupt handling flow performs the next steps:
    (1)
    Enter mlxreg_hotplug_work_handler due to signal assertion.
    Aggregation status register is changed for example from 0xff to 0xfd
    (event signal group related to bit 1).
    (2)
    Mask aggregation interrupts, read aggregation status register and save it
    (0xfd) in aggr_cache, then traverse down to handle signal from groups
    related to the changed bit.
    (3)
    Read and mask group related signal.
    Acknowledge and unmask group related signal (acknowledge should clear
    aggregation status register from 0xfd back to 0xff).
    (4)
    Re-schedule work queue for the immediate execution.
    (5)
    Enter mlxreg_hotplug_work_handler due to re-scheduling.
    Aggregation status is changed from previous 0xfd to 0xff.
    Go over steps (2) - (5) and in case no new signal assertion
    is detected - unmask aggregation interrupts.
    
    The possible race could happen in case new signal from the same group is
    asserted after step (3) and prior step (5). In such case aggregation
    status will change back from 0xff to 0xfd and the value read from the
    aggregation status register will be the same as a value saved in
    aggr_cache. As a result the handler will not traverse down and signal
    will stay unhandled.
    
    Example of faulty flow:
    The signal routing flow is as following (f.e. for of FANi removing):
     - FAN status and event registers related bit is changed;
     -- intermediate aggregation status register is changed;
     --- top aggregation status register is changed;
     ---- interrupt routed to CPU and interrupt handler is invoked.
    
    When interrupt handler is invoked it follows the next simple logic (f.e
    FAN3 is removed):
     (a1) mask top aggregation interrupt mask register;
     (a2) read top aggregation interrupt status register and test to which
          underling group belongs a signal (FANs in this case and is changed
              from 0xff to 0xfb and 0xfb is saved as a last status value);
       (b1) mask FANs interrupt mask register;
       (b2) read FANs status register and test which FAN has been changed
            FAN3 in this example);
         (c1) perform relevant action;
                  <--------------- (FAN2 is removed at this point)
       (b3) clear FANs interrupt event register to acknowledge FAN3 signal;
       (b4) unmask FANs interrupt mask register
     (a3) unmask top aggregation interrupt mask register;
    
     An interrupt handler is invoked, since FAN2 interrupt is not acknowledge.
     It should set top aggregation interrupt status register bit 6 (0xfb).
     In step (a2)
     (a2) read top aggregation interrupt and comparing it with saved value
          does not show change (same 0xfb) and after (a2) execution jumps to
              (a3) and signal leaved unhandled
    
    The fix will enforce handler to traverse down in case the signal is
    received, but signal assertion is not detected.
    
    Fixes: 304887041d95 ("platform/x86: Introduce support for Mellanox hotplug driver")
    Signed-off-by: Vadim Pasternak <vadimp@mellanox.com>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/mellanox/mlxreg-hotplug.c b/drivers/platform/mellanox/mlxreg-hotplug.c
index b56953ae1ab8..922913b8870f 100644
--- a/drivers/platform/mellanox/mlxreg-hotplug.c
+++ b/drivers/platform/mellanox/mlxreg-hotplug.c
@@ -55,6 +55,7 @@
 #define MLXREG_HOTPLUG_RST_CNTR		3
 
 #define MLXREG_HOTPLUG_ATTRS_MAX	24
+#define MLXREG_HOTPLUG_NOT_ASSERT	3
 
 /**
  * struct mlxreg_hotplug_priv_data - platform private data:
@@ -74,6 +75,7 @@
  * @mask: top aggregation interrupt common mask;
  * @aggr_cache: last value of aggregation register status;
  * @after_probe: flag indication probing completion;
+ * @not_asserted: number of entries in workqueue with no signal assertion;
  */
 struct mlxreg_hotplug_priv_data {
 	int irq;
@@ -93,6 +95,7 @@ struct mlxreg_hotplug_priv_data {
 	u32 mask;
 	u32 aggr_cache;
 	bool after_probe;
+	u8 not_asserted;
 };
 
 static int mlxreg_hotplug_device_create(struct mlxreg_hotplug_priv_data *priv,
@@ -410,6 +413,18 @@ static void mlxreg_hotplug_work_handler(struct work_struct *work)
 	aggr_asserted = priv->aggr_cache ^ regval;
 	priv->aggr_cache = regval;
 
+	/*
+	 * Handler is invoked, but no assertion is detected at top aggregation
+	 * status level. Set aggr_asserted to mask value to allow handler extra
+	 * run over all relevant signals to recover any missed signal.
+	 */
+	if (priv->not_asserted == MLXREG_HOTPLUG_NOT_ASSERT) {
+		priv->not_asserted = 0;
+		aggr_asserted = pdata->mask;
+	}
+	if (!aggr_asserted)
+		goto unmask_event;
+
 	/* Handle topology and health configuration changes. */
 	for (i = 0; i < pdata->counter; i++, item++) {
 		if (aggr_asserted & item->aggr_mask) {
@@ -420,27 +435,26 @@ static void mlxreg_hotplug_work_handler(struct work_struct *work)
 		}
 	}
 
-	if (aggr_asserted) {
-		spin_lock_irqsave(&priv->lock, flags);
+	spin_lock_irqsave(&priv->lock, flags);
 
-		/*
-		 * It is possible, that some signals have been inserted, while
-		 * interrupt has been masked by mlxreg_hotplug_work_handler.
-		 * In this case such signals will be missed. In order to handle
-		 * these signals delayed work is canceled and work task
-		 * re-scheduled for immediate execution. It allows to handle
-		 * missed signals, if any. In other case work handler just
-		 * validates that no new signals have been received during
-		 * masking.
-		 */
-		cancel_delayed_work(&priv->dwork_irq);
-		schedule_delayed_work(&priv->dwork_irq, 0);
+	/*
+	 * It is possible, that some signals have been inserted, while
+	 * interrupt has been masked by mlxreg_hotplug_work_handler. In this
+	 * case such signals will be missed. In order to handle these signals
+	 * delayed work is canceled and work task re-scheduled for immediate
+	 * execution. It allows to handle missed signals, if any. In other case
+	 * work handler just validates that no new signals have been received
+	 * during masking.
+	 */
+	cancel_delayed_work(&priv->dwork_irq);
+	schedule_delayed_work(&priv->dwork_irq, 0);
 
-		spin_unlock_irqrestore(&priv->lock, flags);
+	spin_unlock_irqrestore(&priv->lock, flags);
 
-		return;
-	}
+	return;
 
+unmask_event:
+	priv->not_asserted++;
 	/* Unmask aggregation event (no need acknowledge). */
 	ret = regmap_write(priv->regmap, pdata->cell +
 			   MLXREG_HOTPLUG_AGGR_MASK_OFF, pdata->mask);

commit 321089a4da2f6b20bb8af96354f76d260a4ca2c6
Author: Vadim Pasternak <vadimp@mellanox.com>
Date:   Tue Mar 27 10:02:02 2018 +0000

    platform/mellanox: mlxreg-hotplug: Document fixes for hotplug private data
    
    Add missing description of dev, regmap, dwork_irq, after_probe in struct
    mlxreg_hotplug_priv_data.
    
    Remove dwork field from the structure mlxreg_hotplug_priv_data itself and
    for the descriptions, since it is not used.
    
    Signed-off-by: Vadim Pasternak <vadimp@mellanox.com>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/mellanox/mlxreg-hotplug.c b/drivers/platform/mellanox/mlxreg-hotplug.c
index ea9e7f4479ca..b56953ae1ab8 100644
--- a/drivers/platform/mellanox/mlxreg-hotplug.c
+++ b/drivers/platform/mellanox/mlxreg-hotplug.c
@@ -59,9 +59,11 @@
 /**
  * struct mlxreg_hotplug_priv_data - platform private data:
  * @irq: platform device interrupt number;
+ * @dev: basic device;
  * @pdev: platform device;
  * @plat: platform data;
- * @dwork: delayed work template;
+ * @regmap: register map handle;
+ * @dwork_irq: delayed work template;
  * @lock: spin lock;
  * @hwmon: hwmon device;
  * @mlxreg_hotplug_attr: sysfs attributes array;
@@ -71,6 +73,7 @@
  * @cell: location of top aggregation interrupt register;
  * @mask: top aggregation interrupt common mask;
  * @aggr_cache: last value of aggregation register status;
+ * @after_probe: flag indication probing completion;
  */
 struct mlxreg_hotplug_priv_data {
 	int irq;
@@ -79,7 +82,6 @@ struct mlxreg_hotplug_priv_data {
 	struct mlxreg_hotplug_platform_data *plat;
 	struct regmap *regmap;
 	struct delayed_work dwork_irq;
-	struct delayed_work dwork;
 	spinlock_t lock; /* sync with interrupt */
 	struct device *hwmon;
 	struct attribute *mlxreg_hotplug_attr[MLXREG_HOTPLUG_ATTRS_MAX + 1];

commit ef0f62264b2a9e6fc73476ed22ade1ff1f3ad7f3
Author: Vadim Pasternak <vadimp@mellanox.com>
Date:   Tue Feb 13 22:09:36 2018 +0000

    platform/x86: mlx-platform: Add physical bus number auto detection
    
    mlx-platform does not provide a bus number to i2c-mlxcpld, assuming it
    is always one. On some x86 systems, other i2c drivers may probe before
    i2c-mlxcpld, causing bus one to be busy.
    
    Make mlx-platform determine which adapter number is free prior to
    activating i2c-mlxpld, adjusting the mux base numbers accordingly.
    Update the mlxreg-hotplug pdata similarly.
    
    This adds an explicit mlx-platform build dependency on I2C, update the
    Kconfig accordingly. Add the missing REGMAP dependency while we're at
    it.
    
    Signed-off-by: Vadim Pasternak <vadimp@mellanox.com>
    [dvhart: Rewrite commit message more concisely]
    [dvhart: Add build dependencies]
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/mellanox/mlxreg-hotplug.c b/drivers/platform/mellanox/mlxreg-hotplug.c
index c1e1c4f254ce..ea9e7f4479ca 100644
--- a/drivers/platform/mellanox/mlxreg-hotplug.c
+++ b/drivers/platform/mellanox/mlxreg-hotplug.c
@@ -96,6 +96,8 @@ struct mlxreg_hotplug_priv_data {
 static int mlxreg_hotplug_device_create(struct mlxreg_hotplug_priv_data *priv,
 					struct mlxreg_core_data *data)
 {
+	struct mlxreg_core_hotplug_platform_data *pdata;
+
 	/*
 	 * Return if adapter number is negative. It could be in case hotplug
 	 * event is not associated with hotplug device.
@@ -103,10 +105,12 @@ static int mlxreg_hotplug_device_create(struct mlxreg_hotplug_priv_data *priv,
 	if (data->hpdev.nr < 0)
 		return 0;
 
-	data->hpdev.adapter = i2c_get_adapter(data->hpdev.nr);
+	pdata = dev_get_platdata(&priv->pdev->dev);
+	data->hpdev.adapter = i2c_get_adapter(data->hpdev.nr +
+					      pdata->shift_nr);
 	if (!data->hpdev.adapter) {
 		dev_err(priv->dev, "Failed to get adapter for bus %d\n",
-			data->hpdev.nr);
+			data->hpdev.nr + pdata->shift_nr);
 		return -EFAULT;
 	}
 
@@ -114,8 +118,8 @@ static int mlxreg_hotplug_device_create(struct mlxreg_hotplug_priv_data *priv,
 					    data->hpdev.brdinfo);
 	if (!data->hpdev.client) {
 		dev_err(priv->dev, "Failed to create client %s at bus %d at addr 0x%02x\n",
-			data->hpdev.brdinfo->type, data->hpdev.nr,
-			data->hpdev.brdinfo->addr);
+			data->hpdev.brdinfo->type, data->hpdev.nr +
+			pdata->shift_nr, data->hpdev.brdinfo->addr);
 
 		i2c_put_adapter(data->hpdev.adapter);
 		data->hpdev.adapter = NULL;

commit f709e1bfb0c643a866b909d101442c7a7f425655
Author: Vadim Pasternak <vadimp@mellanox.com>
Date:   Tue Feb 13 22:09:35 2018 +0000

    platform/mellanox: mlxreg-hotplug: Change input for device create routine
    
    Change the first input parameter in mlxreg_hotplug_device_create to the
    pointer to mlxreg_hotplug private data in order to use the fields from
    the private data structure.
    
    Signed-off-by: Vadim Pasternak <vadimp@mellanox.com>
    [dvhart: Cleaned up commit message]
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/mellanox/mlxreg-hotplug.c b/drivers/platform/mellanox/mlxreg-hotplug.c
index fe4910bc0f96..c1e1c4f254ce 100644
--- a/drivers/platform/mellanox/mlxreg-hotplug.c
+++ b/drivers/platform/mellanox/mlxreg-hotplug.c
@@ -93,7 +93,7 @@ struct mlxreg_hotplug_priv_data {
 	bool after_probe;
 };
 
-static int mlxreg_hotplug_device_create(struct device *dev,
+static int mlxreg_hotplug_device_create(struct mlxreg_hotplug_priv_data *priv,
 					struct mlxreg_core_data *data)
 {
 	/*
@@ -105,7 +105,7 @@ static int mlxreg_hotplug_device_create(struct device *dev,
 
 	data->hpdev.adapter = i2c_get_adapter(data->hpdev.nr);
 	if (!data->hpdev.adapter) {
-		dev_err(dev, "Failed to get adapter for bus %d\n",
+		dev_err(priv->dev, "Failed to get adapter for bus %d\n",
 			data->hpdev.nr);
 		return -EFAULT;
 	}
@@ -113,7 +113,7 @@ static int mlxreg_hotplug_device_create(struct device *dev,
 	data->hpdev.client = i2c_new_device(data->hpdev.adapter,
 					    data->hpdev.brdinfo);
 	if (!data->hpdev.client) {
-		dev_err(dev, "Failed to create client %s at bus %d at addr 0x%02x\n",
+		dev_err(priv->dev, "Failed to create client %s at bus %d at addr 0x%02x\n",
 			data->hpdev.brdinfo->type, data->hpdev.nr,
 			data->hpdev.brdinfo->addr);
 
@@ -270,10 +270,10 @@ mlxreg_hotplug_work_helper(struct mlxreg_hotplug_priv_data *priv,
 			if (item->inversed)
 				mlxreg_hotplug_device_destroy(data);
 			else
-				mlxreg_hotplug_device_create(priv->dev, data);
+				mlxreg_hotplug_device_create(priv, data);
 		} else {
 			if (item->inversed)
-				mlxreg_hotplug_device_create(priv->dev, data);
+				mlxreg_hotplug_device_create(priv, data);
 			else
 				mlxreg_hotplug_device_destroy(data);
 		}
@@ -319,7 +319,7 @@ mlxreg_hotplug_health_work_helper(struct mlxreg_hotplug_priv_data *priv,
 		if (regval == MLXREG_HOTPLUG_HEALTH_MASK) {
 			if ((data->health_cntr++ == MLXREG_HOTPLUG_RST_CNTR) ||
 			    !priv->after_probe) {
-				mlxreg_hotplug_device_create(priv->dev, data);
+				mlxreg_hotplug_device_create(priv, data);
 				data->attached = true;
 			}
 		} else {

commit d726f6b1997528354e1053accbb6223981e81802
Author: Vadim Pasternak <vadimp@mellanox.com>
Date:   Tue Feb 13 22:09:34 2018 +0000

    platform/x86: mlx-platform: Add deffered bus functionality
    
    mlx-platform activates i2c-mux-reg, which creates buses needed by
    mlxreg-hotplug. If the mlxreg-hotplug probe runs before the i2c-mux-reg
    probe completes, it may attempt to connect a device to an adapter number
    that has not been created yet, and fail.
    
    Make mlx-platform driver record the highest bus number in mlxreg-hotplug
    platform data and defer mlxreg-hotplug probe until all the buses are
    created.
    
    Signed-off-by: Vadim Pasternak <vadimp@mellanox.com>
    [dvhart: rewrite commit message more concisely]
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/mellanox/mlxreg-hotplug.c b/drivers/platform/mellanox/mlxreg-hotplug.c
index 313cf8ad77bf..fe4910bc0f96 100644
--- a/drivers/platform/mellanox/mlxreg-hotplug.c
+++ b/drivers/platform/mellanox/mlxreg-hotplug.c
@@ -550,6 +550,7 @@ static int mlxreg_hotplug_probe(struct platform_device *pdev)
 {
 	struct mlxreg_core_hotplug_platform_data *pdata;
 	struct mlxreg_hotplug_priv_data *priv;
+	struct i2c_adapter *deferred_adap;
 	int err;
 
 	pdata = dev_get_platdata(&pdev->dev);
@@ -558,6 +559,12 @@ static int mlxreg_hotplug_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
+	/* Defer probing if the necessary adapter is not configured yet. */
+	deferred_adap = i2c_get_adapter(pdata->deferred_nr);
+	if (!deferred_adap)
+		return -EPROBE_DEFER;
+	i2c_put_adapter(deferred_adap);
+
 	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;

commit b81e830c9ad041aba81b495d9386dc31aed3f1e6
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Feb 7 10:12:04 2018 +0100

    platform/mellanox: mlxreg-hotplug: Fix uninitialized variable
    
    With gcc-4.1.2:
    
        drivers/platform/mellanox/mlxreg-hotplug.c: In function mlxreg_hotplug_health_work_helper:
        drivers/platform/mellanox/mlxreg-hotplug.c:347: warning: ret is used uninitialized in this function
    
    Indeed, if mlxreg_core_item.count is zero, ret is used uninitialized.
    
    While this is unlikely to happen (it is set to ARRAY_SIZE(...) in x86
    board files), this is done in another source file, so fix this by
    preinitializing ret to zero.
    
    Fixes: c6acad68eb2dbffd ("platform/mellanox: mlxreg-hotplug: Modify to use a regmap interface")
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Vadim Pasternak <vadimp@mellanox.com>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/mellanox/mlxreg-hotplug.c b/drivers/platform/mellanox/mlxreg-hotplug.c
index 0dfa1ca0d05b..313cf8ad77bf 100644
--- a/drivers/platform/mellanox/mlxreg-hotplug.c
+++ b/drivers/platform/mellanox/mlxreg-hotplug.c
@@ -300,7 +300,7 @@ mlxreg_hotplug_health_work_helper(struct mlxreg_hotplug_priv_data *priv,
 {
 	struct mlxreg_core_data *data = item->data;
 	u32 regval;
-	int i, ret;
+	int i, ret = 0;
 
 	for (i = 0; i < item->count; i++, data++) {
 		/* Mask event. */

commit 7805fa8d78d0ea8c9c5a6603960e8f23901c7f17
Author: Vadim Pasternak <vadimp@mellanox.com>
Date:   Fri Jan 26 19:03:45 2018 +0000

    platform/mellanox: mlxreg-hotplug: Add check for negative adapter number
    
    Verify before creation of hotplug device if the associated adapter number
    is negative. It could be in case hotplug event is not associated with
    hotplug device.
    
    Signed-off-by: Vadim Pasternak <vadimp@mellanox.com>
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/mellanox/mlxreg-hotplug.c b/drivers/platform/mellanox/mlxreg-hotplug.c
index bcb564fd9f04..0dfa1ca0d05b 100644
--- a/drivers/platform/mellanox/mlxreg-hotplug.c
+++ b/drivers/platform/mellanox/mlxreg-hotplug.c
@@ -96,6 +96,13 @@ struct mlxreg_hotplug_priv_data {
 static int mlxreg_hotplug_device_create(struct device *dev,
 					struct mlxreg_core_data *data)
 {
+	/*
+	 * Return if adapter number is negative. It could be in case hotplug
+	 * event is not associated with hotplug device.
+	 */
+	if (data->hpdev.nr < 0)
+		return 0;
+
 	data->hpdev.adapter = i2c_get_adapter(data->hpdev.nr);
 	if (!data->hpdev.adapter) {
 		dev_err(dev, "Failed to get adapter for bus %d\n",

commit c6acad68eb2dbffd0497f91b206de5c362f59ee4
Author: Vadim Pasternak <vadimp@mellanox.com>
Date:   Mon Jan 22 19:55:11 2018 -0800

    platform/mellanox: mlxreg-hotplug: Modify to use a regmap interface
    
    Restructure mlxreg header for unification of hotplug item definitions.
    
    Unify hotplug items to allow any kind of item (power controller, fan
    eeprom, psu eeprom, asic health) in common way.
    
    Use a hardware independent regmap interface, enabling the support of
    hotplug events over programmable devices attached to different bus
    types, such as I2C, LPC, or SPI. Add a device node to the
    mlxreg_core_data structure.
    
    Signed-off-by: Vadim Pasternak <vadimp@mellanox.com>
    Acked-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    [dvhart: spelling corrections, refactor device node introduction]
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/mellanox/mlxreg-hotplug.c b/drivers/platform/mellanox/mlxreg-hotplug.c
index e4f7e8efd397..bcb564fd9f04 100644
--- a/drivers/platform/mellanox/mlxreg-hotplug.c
+++ b/drivers/platform/mellanox/mlxreg-hotplug.c
@@ -37,99 +37,97 @@
 #include <linux/hwmon-sysfs.h>
 #include <linux/i2c.h>
 #include <linux/interrupt.h>
-#include <linux/io.h>
 #include <linux/module.h>
+#include <linux/of_device.h>
 #include <linux/platform_data/mlxreg.h>
 #include <linux/platform_device.h>
 #include <linux/spinlock.h>
+#include <linux/regmap.h>
 #include <linux/workqueue.h>
 
-/* Offset of event and mask registers from status register */
+/* Offset of event and mask registers from status register. */
 #define MLXREG_HOTPLUG_EVENT_OFF	1
-#define MLXREG_HOTPLUG_MASK_OFF	2
+#define MLXREG_HOTPLUG_MASK_OFF		2
 #define MLXREG_HOTPLUG_AGGR_MASK_OFF	1
 
-#define MLXREG_HOTPLUG_ATTRS_NUM	8
+/* ASIC health parameters. */
+#define MLXREG_HOTPLUG_HEALTH_MASK	0x02
+#define MLXREG_HOTPLUG_RST_CNTR		3
 
-/**
- * enum mlxreg_hotplug_attr_type - sysfs attributes for hotplug events:
- * @MLXREG_HOTPLUG_ATTR_TYPE_PSU: power supply unit attribute;
- * @MLXREG_HOTPLUG_ATTR_TYPE_PWR: power cable attribute;
- * @MLXREG_HOTPLUG_ATTR_TYPE_FAN: FAN drawer attribute;
- */
-enum mlxreg_hotplug_attr_type {
-	MLXREG_HOTPLUG_ATTR_TYPE_PSU,
-	MLXREG_HOTPLUG_ATTR_TYPE_PWR,
-	MLXREG_HOTPLUG_ATTR_TYPE_FAN,
-};
+#define MLXREG_HOTPLUG_ATTRS_MAX	24
 
 /**
  * struct mlxreg_hotplug_priv_data - platform private data:
- * @irq: platform interrupt number;
+ * @irq: platform device interrupt number;
  * @pdev: platform device;
  * @plat: platform data;
+ * @dwork: delayed work template;
+ * @lock: spin lock;
  * @hwmon: hwmon device;
  * @mlxreg_hotplug_attr: sysfs attributes array;
  * @mlxreg_hotplug_dev_attr: sysfs sensor device attribute array;
  * @group: sysfs attribute group;
  * @groups: list of sysfs attribute group for hwmon registration;
- * @dwork: delayed work template;
- * @lock: spin lock;
+ * @cell: location of top aggregation interrupt register;
+ * @mask: top aggregation interrupt common mask;
  * @aggr_cache: last value of aggregation register status;
- * @psu_cache: last value of PSU register status;
- * @pwr_cache: last value of power register status;
- * @fan_cache: last value of FAN register status;
  */
 struct mlxreg_hotplug_priv_data {
 	int irq;
+	struct device *dev;
 	struct platform_device *pdev;
 	struct mlxreg_hotplug_platform_data *plat;
+	struct regmap *regmap;
+	struct delayed_work dwork_irq;
+	struct delayed_work dwork;
+	spinlock_t lock; /* sync with interrupt */
 	struct device *hwmon;
-	struct attribute *mlxreg_hotplug_attr[MLXREG_HOTPLUG_ATTRS_NUM + 1];
+	struct attribute *mlxreg_hotplug_attr[MLXREG_HOTPLUG_ATTRS_MAX + 1];
 	struct sensor_device_attribute_2
-			mlxreg_hotplug_dev_attr[MLXREG_HOTPLUG_ATTRS_NUM];
+			mlxreg_hotplug_dev_attr[MLXREG_HOTPLUG_ATTRS_MAX];
 	struct attribute_group group;
 	const struct attribute_group *groups[2];
-	struct delayed_work dwork;
-	spinlock_t lock;
-	u8 aggr_cache;
-	u8 psu_cache;
-	u8 pwr_cache;
-	u8 fan_cache;
+	u32 cell;
+	u32 mask;
+	u32 aggr_cache;
+	bool after_probe;
 };
 
 static int mlxreg_hotplug_device_create(struct device *dev,
-					struct mlxreg_hotplug_device *item)
+					struct mlxreg_core_data *data)
 {
-	item->adapter = i2c_get_adapter(item->nr);
-	if (!item->adapter) {
+	data->hpdev.adapter = i2c_get_adapter(data->hpdev.nr);
+	if (!data->hpdev.adapter) {
 		dev_err(dev, "Failed to get adapter for bus %d\n",
-			item->nr);
+			data->hpdev.nr);
 		return -EFAULT;
 	}
 
-	item->client = i2c_new_device(item->adapter, &item->brdinfo);
-	if (!item->client) {
+	data->hpdev.client = i2c_new_device(data->hpdev.adapter,
+					    data->hpdev.brdinfo);
+	if (!data->hpdev.client) {
 		dev_err(dev, "Failed to create client %s at bus %d at addr 0x%02x\n",
-			item->brdinfo.type, item->nr, item->brdinfo.addr);
-		i2c_put_adapter(item->adapter);
-		item->adapter = NULL;
+			data->hpdev.brdinfo->type, data->hpdev.nr,
+			data->hpdev.brdinfo->addr);
+
+		i2c_put_adapter(data->hpdev.adapter);
+		data->hpdev.adapter = NULL;
 		return -EFAULT;
 	}
 
 	return 0;
 }
 
-static void mlxreg_hotplug_device_destroy(struct mlxreg_hotplug_device *item)
+static void mlxreg_hotplug_device_destroy(struct mlxreg_core_data *data)
 {
-	if (item->client) {
-		i2c_unregister_device(item->client);
-		item->client = NULL;
+	if (data->hpdev.client) {
+		i2c_unregister_device(data->hpdev.client);
+		data->hpdev.client = NULL;
 	}
 
-	if (item->adapter) {
-		i2c_put_adapter(item->adapter);
-		item->adapter = NULL;
+	if (data->hpdev.adapter) {
+		i2c_put_adapter(data->hpdev.adapter);
+		data->hpdev.adapter = NULL;
 	}
 }
 
@@ -137,41 +135,76 @@ static ssize_t mlxreg_hotplug_attr_show(struct device *dev,
 					struct device_attribute *attr,
 					char *buf)
 {
-	struct platform_device *pdev = to_platform_device(dev);
-	struct mlxreg_hotplug_priv_data *priv = platform_get_drvdata(pdev);
+	struct mlxreg_hotplug_priv_data *priv = dev_get_drvdata(dev);
+	struct mlxreg_core_hotplug_platform_data *pdata;
 	int index = to_sensor_dev_attr_2(attr)->index;
 	int nr = to_sensor_dev_attr_2(attr)->nr;
-	u8 reg_val = 0;
-
-	switch (nr) {
-	case MLXREG_HOTPLUG_ATTR_TYPE_PSU:
-		/* Bit = 0 : PSU is present. */
-		reg_val = !!!(inb(priv->plat->psu_reg_offset) & BIT(index));
-		break;
-
-	case MLXREG_HOTPLUG_ATTR_TYPE_PWR:
-		/* Bit = 1 : power cable is attached. */
-		reg_val = !!(inb(priv->plat->pwr_reg_offset) & BIT(index %
-						priv->plat->pwr_count));
-		break;
-
-	case MLXREG_HOTPLUG_ATTR_TYPE_FAN:
-		/* Bit = 0 : FAN is present. */
-		reg_val = !!!(inb(priv->plat->fan_reg_offset) & BIT(index %
-						priv->plat->fan_count));
-		break;
+	struct mlxreg_core_item *item;
+	struct mlxreg_core_data *data;
+	u32 regval;
+	int ret;
+
+	pdata = dev_get_platdata(&priv->pdev->dev);
+	item = pdata->items + nr;
+	data = item->data + index;
+
+	ret = regmap_read(priv->regmap, data->reg, &regval);
+	if (ret)
+		return ret;
+
+	if (item->health) {
+		regval &= data->mask;
+	} else {
+		/* Bit = 0 : functional if item->inversed is true. */
+		if (item->inversed)
+			regval = !(regval & data->mask);
+		else
+			regval = !!(regval & data->mask);
 	}
 
-	return sprintf(buf, "%u\n", reg_val);
+	return sprintf(buf, "%u\n", regval);
 }
 
 #define PRIV_ATTR(i) priv->mlxreg_hotplug_attr[i]
 #define PRIV_DEV_ATTR(i) priv->mlxreg_hotplug_dev_attr[i]
+
 static int mlxreg_hotplug_attr_init(struct mlxreg_hotplug_priv_data *priv)
 {
-	int num_attrs = priv->plat->psu_count + priv->plat->pwr_count +
-			priv->plat->fan_count;
-	int i;
+	struct mlxreg_core_hotplug_platform_data *pdata;
+	struct mlxreg_core_item *item;
+	struct mlxreg_core_data *data;
+	int num_attrs = 0, id = 0, i, j;
+
+	pdata = dev_get_platdata(&priv->pdev->dev);
+	item = pdata->items;
+
+	/* Go over all kinds of items - psu, pwr, fan. */
+	for (i = 0; i < pdata->counter; i++, item++) {
+		num_attrs += item->count;
+		data = item->data;
+		/* Go over all units within the item. */
+		for (j = 0; j < item->count; j++, data++, id++) {
+			PRIV_ATTR(id) = &PRIV_DEV_ATTR(id).dev_attr.attr;
+			PRIV_ATTR(id)->name = devm_kasprintf(&priv->pdev->dev,
+							     GFP_KERNEL,
+							     data->label);
+
+			if (!PRIV_ATTR(id)->name) {
+				dev_err(priv->dev, "Memory allocation failed for attr %d.\n",
+					id);
+				return -ENOMEM;
+			}
+
+			PRIV_DEV_ATTR(id).dev_attr.attr.name =
+							PRIV_ATTR(id)->name;
+			PRIV_DEV_ATTR(id).dev_attr.attr.mode = 0444;
+			PRIV_DEV_ATTR(id).dev_attr.show =
+						mlxreg_hotplug_attr_show;
+			PRIV_DEV_ATTR(id).nr = i;
+			PRIV_DEV_ATTR(id).index = j;
+			sysfs_attr_init(&PRIV_DEV_ATTR(id).dev_attr.attr);
+		}
+	}
 
 	priv->group.attrs = devm_kzalloc(&priv->pdev->dev, num_attrs *
 					 sizeof(struct attribute *),
@@ -179,38 +212,6 @@ static int mlxreg_hotplug_attr_init(struct mlxreg_hotplug_priv_data *priv)
 	if (!priv->group.attrs)
 		return -ENOMEM;
 
-	for (i = 0; i < num_attrs; i++) {
-		PRIV_ATTR(i) = &PRIV_DEV_ATTR(i).dev_attr.attr;
-
-		if (i < priv->plat->psu_count) {
-			PRIV_ATTR(i)->name = devm_kasprintf(&priv->pdev->dev,
-						GFP_KERNEL, "psu%u", i + 1);
-			PRIV_DEV_ATTR(i).nr = MLXREG_HOTPLUG_ATTR_TYPE_PSU;
-		} else if (i < priv->plat->psu_count + priv->plat->pwr_count) {
-			PRIV_ATTR(i)->name = devm_kasprintf(&priv->pdev->dev,
-						GFP_KERNEL, "pwr%u", i %
-						priv->plat->pwr_count + 1);
-			PRIV_DEV_ATTR(i).nr = MLXREG_HOTPLUG_ATTR_TYPE_PWR;
-		} else {
-			PRIV_ATTR(i)->name = devm_kasprintf(&priv->pdev->dev,
-						GFP_KERNEL, "fan%u", i %
-						priv->plat->fan_count + 1);
-			PRIV_DEV_ATTR(i).nr = MLXREG_HOTPLUG_ATTR_TYPE_FAN;
-		}
-
-		if (!PRIV_ATTR(i)->name) {
-			dev_err(&priv->pdev->dev, "Memory allocation failed for sysfs attribute %d.\n",
-				i + 1);
-			return -ENOMEM;
-		}
-
-		PRIV_DEV_ATTR(i).dev_attr.attr.name = PRIV_ATTR(i)->name;
-		PRIV_DEV_ATTR(i).dev_attr.attr.mode = S_IRUGO;
-		PRIV_DEV_ATTR(i).dev_attr.show = mlxreg_hotplug_attr_show;
-		PRIV_DEV_ATTR(i).index = i;
-		sysfs_attr_init(&PRIV_DEV_ATTR(i).dev_attr.attr);
-	}
-
 	priv->group.attrs = priv->mlxreg_hotplug_attr;
 	priv->groups[0] = &priv->group;
 	priv->groups[1] = NULL;
@@ -218,20 +219,13 @@ static int mlxreg_hotplug_attr_init(struct mlxreg_hotplug_priv_data *priv)
 	return 0;
 }
 
-static inline void
-mlxreg_hotplug_work_helper(struct device *dev,
-			   struct mlxreg_hotplug_device *item, u8 is_inverse,
-			   u16 offset, u8 mask, u8 *cache)
+static void
+mlxreg_hotplug_work_helper(struct mlxreg_hotplug_priv_data *priv,
+			   struct mlxreg_core_item *item)
 {
-	u8 val, asserted;
-	int bit;
-
-	/* Mask event. */
-	outb(0, offset + MLXREG_HOTPLUG_MASK_OFF);
-	/* Read status. */
-	val = inb(offset) & mask;
-	asserted = *cache ^ val;
-	*cache = val;
+	struct mlxreg_core_data *data;
+	u32 asserted, regval, bit;
+	int ret;
 
 	/*
 	 * Validate if item related to received signal type is valid.
@@ -241,86 +235,177 @@ mlxreg_hotplug_work_helper(struct device *dev,
 	 * signals from other devices if any.
 	 */
 	if (unlikely(!item)) {
-		dev_err(dev, "False signal is received: register at offset 0x%02x, mask 0x%02x.\n",
-			offset, mask);
+		dev_err(priv->dev, "False signal: at offset:mask 0x%02x:0x%02x.\n",
+			item->reg, item->mask);
+
 		return;
 	}
 
+	/* Mask event. */
+	ret = regmap_write(priv->regmap, item->reg + MLXREG_HOTPLUG_MASK_OFF,
+			   0);
+	if (ret)
+		goto out;
+
+	/* Read status. */
+	ret = regmap_read(priv->regmap, item->reg, &regval);
+	if (ret)
+		goto out;
+
+	/* Set asserted bits and save last status. */
+	regval &= item->mask;
+	asserted = item->cache ^ regval;
+	item->cache = regval;
+
 	for_each_set_bit(bit, (unsigned long *)&asserted, 8) {
-		if (val & BIT(bit)) {
-			if (is_inverse)
-				mlxreg_hotplug_device_destroy(item + bit);
+		data = item->data + bit;
+		if (regval & BIT(bit)) {
+			if (item->inversed)
+				mlxreg_hotplug_device_destroy(data);
 			else
-				mlxreg_hotplug_device_create(dev, item + bit);
+				mlxreg_hotplug_device_create(priv->dev, data);
 		} else {
-			if (is_inverse)
-				mlxreg_hotplug_device_create(dev, item + bit);
+			if (item->inversed)
+				mlxreg_hotplug_device_create(priv->dev, data);
 			else
-				mlxreg_hotplug_device_destroy(item + bit);
+				mlxreg_hotplug_device_destroy(data);
 		}
 	}
 
 	/* Acknowledge event. */
-	outb(0, offset + MLXREG_HOTPLUG_EVENT_OFF);
+	ret = regmap_write(priv->regmap, item->reg + MLXREG_HOTPLUG_EVENT_OFF,
+			   0);
+	if (ret)
+		goto out;
+
 	/* Unmask event. */
-	outb(mask, offset + MLXREG_HOTPLUG_MASK_OFF);
+	ret = regmap_write(priv->regmap, item->reg + MLXREG_HOTPLUG_MASK_OFF,
+			   item->mask);
+
+ out:
+	if (ret)
+		dev_err(priv->dev, "Failed to complete workqueue.\n");
+}
+
+static void
+mlxreg_hotplug_health_work_helper(struct mlxreg_hotplug_priv_data *priv,
+				  struct mlxreg_core_item *item)
+{
+	struct mlxreg_core_data *data = item->data;
+	u32 regval;
+	int i, ret;
+
+	for (i = 0; i < item->count; i++, data++) {
+		/* Mask event. */
+		ret = regmap_write(priv->regmap, data->reg +
+				   MLXREG_HOTPLUG_MASK_OFF, 0);
+		if (ret)
+			goto out;
+
+		/* Read status. */
+		ret = regmap_read(priv->regmap, data->reg, &regval);
+		if (ret)
+			goto out;
+
+		regval &= data->mask;
+		item->cache = regval;
+		if (regval == MLXREG_HOTPLUG_HEALTH_MASK) {
+			if ((data->health_cntr++ == MLXREG_HOTPLUG_RST_CNTR) ||
+			    !priv->after_probe) {
+				mlxreg_hotplug_device_create(priv->dev, data);
+				data->attached = true;
+			}
+		} else {
+			if (data->attached) {
+				mlxreg_hotplug_device_destroy(data);
+				data->attached = false;
+				data->health_cntr = 0;
+			}
+		}
+
+		/* Acknowledge event. */
+		ret = regmap_write(priv->regmap, data->reg +
+				   MLXREG_HOTPLUG_EVENT_OFF, 0);
+		if (ret)
+			goto out;
+
+		/* Unmask event. */
+		ret = regmap_write(priv->regmap, data->reg +
+				   MLXREG_HOTPLUG_MASK_OFF, data->mask);
+		if (ret)
+			goto out;
+	}
+
+ out:
+	if (ret)
+		dev_err(priv->dev, "Failed to complete workqueue.\n");
 }
 
 /*
- * mlxreg_hotplug_work_handler - performs traversing of CPLD interrupt
+ * mlxreg_hotplug_work_handler - performs traversing of device interrupt
  * registers according to the below hierarchy schema:
  *
- *                   Aggregation registers (status/mask)
- * PSU registers:           *---*
- * *-----------------*      |   |
- * |status/event/mask|----->| * |
- * *-----------------*      |   |
- * Power registers:         |   |
- * *-----------------*      |   |
- * |status/event/mask|----->| * |---> CPU
- * *-----------------*      |   |
- * FAN registers:
- * *-----------------*      |   |
- * |status/event/mask|----->| * |
- * *-----------------*      |   |
- *                          *---*
+ *				Aggregation registers (status/mask)
+ * PSU registers:		*---*
+ * *-----------------*		|   |
+ * |status/event/mask|----->    | * |
+ * *-----------------*		|   |
+ * Power registers:		|   |
+ * *-----------------*		|   |
+ * |status/event/mask|----->    | * |
+ * *-----------------*		|   |
+ * FAN registers:		|   |--> CPU
+ * *-----------------*		|   |
+ * |status/event/mask|----->    | * |
+ * *-----------------*		|   |
+ * ASIC registers:		|   |
+ * *-----------------*		|   |
+ * |status/event/mask|----->    | * |
+ * *-----------------*		|   |
+ *				*---*
+ *
  * In case some system changed are detected: FAN in/out, PSU in/out, power
- * cable attached/detached, relevant device is created or destroyed.
+ * cable attached/detached, ASIC health good/bad, relevant device is created
+ * or destroyed.
  */
 static void mlxreg_hotplug_work_handler(struct work_struct *work)
 {
-	struct mlxreg_hotplug_priv_data *priv = container_of(work,
-				struct mlxreg_hotplug_priv_data, dwork.work);
-	u8 val, aggr_asserted;
+	struct mlxreg_core_hotplug_platform_data *pdata;
+	struct mlxreg_hotplug_priv_data *priv;
+	struct mlxreg_core_item *item;
+	u32 regval, aggr_asserted;
 	unsigned long flags;
+	int i, ret;
+
+	priv = container_of(work, struct mlxreg_hotplug_priv_data,
+			    dwork_irq.work);
+	pdata = dev_get_platdata(&priv->pdev->dev);
+	item = pdata->items;
 
 	/* Mask aggregation event. */
-	outb(0, priv->plat->top_aggr_offset + MLXREG_HOTPLUG_AGGR_MASK_OFF);
+	ret = regmap_write(priv->regmap, pdata->cell +
+			   MLXREG_HOTPLUG_AGGR_MASK_OFF, 0);
+	if (ret < 0)
+		goto out;
+
 	/* Read aggregation status. */
-	val = inb(priv->plat->top_aggr_offset) & priv->plat->top_aggr_mask;
-	aggr_asserted = priv->aggr_cache ^ val;
-	priv->aggr_cache = val;
-
-	/* Handle PSU configuration changes. */
-	if (aggr_asserted & priv->plat->top_aggr_psu_mask)
-		mlxreg_hotplug_work_helper(&priv->pdev->dev, priv->plat->psu,
-					   1, priv->plat->psu_reg_offset,
-					   priv->plat->psu_mask,
-					   &priv->psu_cache);
-
-	/* Handle power cable configuration changes. */
-	if (aggr_asserted & priv->plat->top_aggr_pwr_mask)
-		mlxreg_hotplug_work_helper(&priv->pdev->dev, priv->plat->pwr,
-					   0, priv->plat->pwr_reg_offset,
-					   priv->plat->pwr_mask,
-					   &priv->pwr_cache);
-
-	/* Handle FAN configuration changes. */
-	if (aggr_asserted & priv->plat->top_aggr_fan_mask)
-		mlxreg_hotplug_work_helper(&priv->pdev->dev, priv->plat->fan,
-					   1, priv->plat->fan_reg_offset,
-					   priv->plat->fan_mask,
-					   &priv->fan_cache);
+	ret = regmap_read(priv->regmap, pdata->cell, &regval);
+	if (ret)
+		goto out;
+
+	regval &= pdata->mask;
+	aggr_asserted = priv->aggr_cache ^ regval;
+	priv->aggr_cache = regval;
+
+	/* Handle topology and health configuration changes. */
+	for (i = 0; i < pdata->counter; i++, item++) {
+		if (aggr_asserted & item->aggr_mask) {
+			if (item->health)
+				mlxreg_hotplug_health_work_helper(priv, item);
+			else
+				mlxreg_hotplug_work_helper(priv, item);
+		}
+	}
 
 	if (aggr_asserted) {
 		spin_lock_irqsave(&priv->lock, flags);
@@ -335,8 +420,8 @@ static void mlxreg_hotplug_work_handler(struct work_struct *work)
 		 * validates that no new signals have been received during
 		 * masking.
 		 */
-		cancel_delayed_work(&priv->dwork);
-		schedule_delayed_work(&priv->dwork, 0);
+		cancel_delayed_work(&priv->dwork_irq);
+		schedule_delayed_work(&priv->dwork_irq, 0);
 
 		spin_unlock_irqrestore(&priv->lock, flags);
 
@@ -344,92 +429,119 @@ static void mlxreg_hotplug_work_handler(struct work_struct *work)
 	}
 
 	/* Unmask aggregation event (no need acknowledge). */
-	outb(priv->plat->top_aggr_mask, priv->plat->top_aggr_offset +
-						MLXREG_HOTPLUG_AGGR_MASK_OFF);
+	ret = regmap_write(priv->regmap, pdata->cell +
+			   MLXREG_HOTPLUG_AGGR_MASK_OFF, pdata->mask);
+
+ out:
+	if (ret)
+		dev_err(priv->dev, "Failed to complete workqueue.\n");
 }
 
-static void mlxreg_hotplug_set_irq(struct mlxreg_hotplug_priv_data *priv)
+static int mlxreg_hotplug_set_irq(struct mlxreg_hotplug_priv_data *priv)
 {
-	/* Clear psu presense event. */
-	outb(0, priv->plat->psu_reg_offset + MLXREG_HOTPLUG_EVENT_OFF);
-	/* Set psu initial status as mask and unmask psu event. */
-	priv->psu_cache = priv->plat->psu_mask;
-	outb(priv->plat->psu_mask, priv->plat->psu_reg_offset +
-						MLXREG_HOTPLUG_MASK_OFF);
-
-	/* Clear power cable event. */
-	outb(0, priv->plat->pwr_reg_offset + MLXREG_HOTPLUG_EVENT_OFF);
-	/* Keep power initial status as zero and unmask power event. */
-	outb(priv->plat->pwr_mask, priv->plat->pwr_reg_offset +
-						MLXREG_HOTPLUG_MASK_OFF);
-
-	/* Clear fan presense event. */
-	outb(0, priv->plat->fan_reg_offset + MLXREG_HOTPLUG_EVENT_OFF);
-	/* Set fan initial status as mask and unmask fan event. */
-	priv->fan_cache = priv->plat->fan_mask;
-	outb(priv->plat->fan_mask, priv->plat->fan_reg_offset +
-						MLXREG_HOTPLUG_MASK_OFF);
+	struct mlxreg_core_hotplug_platform_data *pdata;
+	struct mlxreg_core_item *item;
+	int i, ret;
+
+	pdata = dev_get_platdata(&priv->pdev->dev);
+	item = pdata->items;
+
+	for (i = 0; i < pdata->counter; i++, item++) {
+		/* Clear group presense event. */
+		ret = regmap_write(priv->regmap, item->reg +
+				   MLXREG_HOTPLUG_EVENT_OFF, 0);
+		if (ret)
+			goto out;
+
+		/* Set group initial status as mask and unmask group event. */
+		if (item->inversed) {
+			item->cache = item->mask;
+			ret = regmap_write(priv->regmap, item->reg +
+					   MLXREG_HOTPLUG_MASK_OFF,
+					   item->mask);
+			if (ret)
+				goto out;
+		}
+	}
 
 	/* Keep aggregation initial status as zero and unmask events. */
-	outb(priv->plat->top_aggr_mask, priv->plat->top_aggr_offset +
-						MLXREG_HOTPLUG_AGGR_MASK_OFF);
+	ret = regmap_write(priv->regmap, pdata->cell +
+			   MLXREG_HOTPLUG_AGGR_MASK_OFF, pdata->mask);
+	if (ret)
+		goto out;
+
+	/* Keep low aggregation initial status as zero and unmask events. */
+	if (pdata->cell_low) {
+		ret = regmap_write(priv->regmap, pdata->cell_low +
+				   MLXREG_HOTPLUG_AGGR_MASK_OFF,
+				   pdata->mask_low);
+		if (ret)
+			goto out;
+	}
 
 	/* Invoke work handler for initializing hot plug devices setting. */
-	mlxreg_hotplug_work_handler(&priv->dwork.work);
+	mlxreg_hotplug_work_handler(&priv->dwork_irq.work);
 
+ out:
+	if (ret)
+		dev_err(priv->dev, "Failed to set interrupts.\n");
 	enable_irq(priv->irq);
+	return ret;
 }
 
 static void mlxreg_hotplug_unset_irq(struct mlxreg_hotplug_priv_data *priv)
 {
-	int i;
+	struct mlxreg_core_hotplug_platform_data *pdata;
+	struct mlxreg_core_item *item;
+	struct mlxreg_core_data *data;
+	int count, i, j;
 
+	pdata = dev_get_platdata(&priv->pdev->dev);
+	item = pdata->items;
 	disable_irq(priv->irq);
-	cancel_delayed_work_sync(&priv->dwork);
-
-	/* Mask aggregation event. */
-	outb(0, priv->plat->top_aggr_offset + MLXREG_HOTPLUG_AGGR_MASK_OFF);
-
-	/* Mask psu presense event. */
-	outb(0, priv->plat->psu_reg_offset + MLXREG_HOTPLUG_MASK_OFF);
-	/* Clear psu presense event. */
-	outb(0, priv->plat->psu_reg_offset + MLXREG_HOTPLUG_EVENT_OFF);
-
-	/* Mask power cable event. */
-	outb(0, priv->plat->pwr_reg_offset + MLXREG_HOTPLUG_MASK_OFF);
-	/* Clear power cable event. */
-	outb(0, priv->plat->pwr_reg_offset + MLXREG_HOTPLUG_EVENT_OFF);
-
-	/* Mask fan presense event. */
-	outb(0, priv->plat->fan_reg_offset + MLXREG_HOTPLUG_MASK_OFF);
-	/* Clear fan presense event. */
-	outb(0, priv->plat->fan_reg_offset + MLXREG_HOTPLUG_EVENT_OFF);
-
-	/* Remove all the attached devices. */
-	for (i = 0; i < priv->plat->psu_count; i++)
-		mlxreg_hotplug_device_destroy(priv->plat->psu + i);
+	cancel_delayed_work_sync(&priv->dwork_irq);
 
-	for (i = 0; i < priv->plat->pwr_count; i++)
-		mlxreg_hotplug_device_destroy(priv->plat->pwr + i);
+	/* Mask low aggregation event, if defined. */
+	if (pdata->cell_low)
+		regmap_write(priv->regmap, pdata->cell_low +
+			     MLXREG_HOTPLUG_AGGR_MASK_OFF, 0);
 
-	for (i = 0; i < priv->plat->fan_count; i++)
-		mlxreg_hotplug_device_destroy(priv->plat->fan + i);
+	/* Mask aggregation event. */
+	regmap_write(priv->regmap, pdata->cell + MLXREG_HOTPLUG_AGGR_MASK_OFF,
+		     0);
+
+	/* Clear topology configurations. */
+	for (i = 0; i < pdata->counter; i++, item++) {
+		data = item->data;
+		/* Mask group presense event. */
+		regmap_write(priv->regmap, data->reg + MLXREG_HOTPLUG_MASK_OFF,
+			     0);
+		/* Clear group presense event. */
+		regmap_write(priv->regmap, data->reg +
+			     MLXREG_HOTPLUG_EVENT_OFF, 0);
+
+		/* Remove all the attached devices in group. */
+		count = item->count;
+		for (j = 0; j < count; j++, data++)
+			mlxreg_hotplug_device_destroy(data);
+	}
 }
 
 static irqreturn_t mlxreg_hotplug_irq_handler(int irq, void *dev)
 {
-	struct mlxreg_hotplug_priv_data *priv =
-				(struct mlxreg_hotplug_priv_data *)dev;
+	struct mlxreg_hotplug_priv_data *priv;
+
+	priv = (struct mlxreg_hotplug_priv_data *)dev;
 
 	/* Schedule work task for immediate execution.*/
-	schedule_delayed_work(&priv->dwork, 0);
+	schedule_delayed_work(&priv->dwork_irq, 0);
 
 	return IRQ_HANDLED;
 }
 
 static int mlxreg_hotplug_probe(struct platform_device *pdev)
 {
-	struct mlxreg_hotplug_platform_data *pdata;
+	struct mlxreg_core_hotplug_platform_data *pdata;
 	struct mlxreg_hotplug_priv_data *priv;
 	int err;
 
@@ -443,31 +555,42 @@ static int mlxreg_hotplug_probe(struct platform_device *pdev)
 	if (!priv)
 		return -ENOMEM;
 
-	priv->pdev = pdev;
-	priv->plat = pdata;
-
-	priv->irq = platform_get_irq(pdev, 0);
-	if (priv->irq < 0) {
-		dev_err(&pdev->dev, "Failed to get platform irq: %d\n",
-			priv->irq);
-		return priv->irq;
+	if (pdata->irq) {
+		priv->irq = pdata->irq;
+	} else {
+		priv->irq = platform_get_irq(pdev, 0);
+		if (priv->irq < 0) {
+			dev_err(&pdev->dev, "Failed to get platform irq: %d\n",
+				priv->irq);
+			return priv->irq;
+		}
 	}
 
+	priv->regmap = pdata->regmap;
+	priv->dev = pdev->dev.parent;
+	priv->pdev = pdev;
+
 	err = devm_request_irq(&pdev->dev, priv->irq,
-			       mlxreg_hotplug_irq_handler, 0, pdev->name,
-			       priv);
+			       mlxreg_hotplug_irq_handler, IRQF_TRIGGER_FALLING
+			       | IRQF_SHARED, "mlxreg-hotplug", priv);
 	if (err) {
 		dev_err(&pdev->dev, "Failed to request irq: %d\n", err);
 		return err;
 	}
-	disable_irq(priv->irq);
 
-	INIT_DELAYED_WORK(&priv->dwork, mlxreg_hotplug_work_handler);
+	disable_irq(priv->irq);
 	spin_lock_init(&priv->lock);
+	INIT_DELAYED_WORK(&priv->dwork_irq, mlxreg_hotplug_work_handler);
+	/* Perform initial interrupts setup. */
+	mlxreg_hotplug_set_irq(priv);
+
+	priv->after_probe = true;
+	dev_set_drvdata(&pdev->dev, priv);
 
 	err = mlxreg_hotplug_attr_init(priv);
 	if (err) {
-		dev_err(&pdev->dev, "Failed to allocate attributes: %d\n", err);
+		dev_err(&pdev->dev, "Failed to allocate attributes: %d\n",
+			err);
 		return err;
 	}
 
@@ -479,17 +602,12 @@ static int mlxreg_hotplug_probe(struct platform_device *pdev)
 		return PTR_ERR(priv->hwmon);
 	}
 
-	platform_set_drvdata(pdev, priv);
-
-	/* Perform initial interrupts setup. */
-	mlxreg_hotplug_set_irq(priv);
-
 	return 0;
 }
 
 static int mlxreg_hotplug_remove(struct platform_device *pdev)
 {
-	struct mlxreg_hotplug_priv_data *priv = platform_get_drvdata(pdev);
+	struct mlxreg_hotplug_priv_data *priv = dev_get_drvdata(&pdev->dev);
 
 	/* Clean interrupts setup. */
 	mlxreg_hotplug_unset_irq(priv);

commit 752849e69715fdc2190945f5532d70e8c80bf384
Author: Vadim Pasternak <vadimp@mellanox.com>
Date:   Mon Jan 22 18:50:20 2018 -0800

    platform/mellanox: Group create/destroy with attribute functions
    
    Move the mlxreg_hotplug_device_create and _destroy functions up with the
    related attribute functions. No functional changes.
    
    Signed-off-by: Vadim Pasternak <vadimp@mellanox.com>
    Acked-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    [dvhart: refactored commit into smaller functional changes]
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/mellanox/mlxreg-hotplug.c b/drivers/platform/mellanox/mlxreg-hotplug.c
index 752f756723e0..e4f7e8efd397 100644
--- a/drivers/platform/mellanox/mlxreg-hotplug.c
+++ b/drivers/platform/mellanox/mlxreg-hotplug.c
@@ -98,6 +98,41 @@ struct mlxreg_hotplug_priv_data {
 	u8 fan_cache;
 };
 
+static int mlxreg_hotplug_device_create(struct device *dev,
+					struct mlxreg_hotplug_device *item)
+{
+	item->adapter = i2c_get_adapter(item->nr);
+	if (!item->adapter) {
+		dev_err(dev, "Failed to get adapter for bus %d\n",
+			item->nr);
+		return -EFAULT;
+	}
+
+	item->client = i2c_new_device(item->adapter, &item->brdinfo);
+	if (!item->client) {
+		dev_err(dev, "Failed to create client %s at bus %d at addr 0x%02x\n",
+			item->brdinfo.type, item->nr, item->brdinfo.addr);
+		i2c_put_adapter(item->adapter);
+		item->adapter = NULL;
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static void mlxreg_hotplug_device_destroy(struct mlxreg_hotplug_device *item)
+{
+	if (item->client) {
+		i2c_unregister_device(item->client);
+		item->client = NULL;
+	}
+
+	if (item->adapter) {
+		i2c_put_adapter(item->adapter);
+		item->adapter = NULL;
+	}
+}
+
 static ssize_t mlxreg_hotplug_attr_show(struct device *dev,
 					struct device_attribute *attr,
 					char *buf)
@@ -183,41 +218,6 @@ static int mlxreg_hotplug_attr_init(struct mlxreg_hotplug_priv_data *priv)
 	return 0;
 }
 
-static int mlxreg_hotplug_device_create(struct device *dev,
-					struct mlxreg_hotplug_device *item)
-{
-	item->adapter = i2c_get_adapter(item->nr);
-	if (!item->adapter) {
-		dev_err(dev, "Failed to get adapter for bus %d\n",
-			item->nr);
-		return -EFAULT;
-	}
-
-	item->client = i2c_new_device(item->adapter, &item->brdinfo);
-	if (!item->client) {
-		dev_err(dev, "Failed to create client %s at bus %d at addr 0x%02x\n",
-			item->brdinfo.type, item->nr, item->brdinfo.addr);
-		i2c_put_adapter(item->adapter);
-		item->adapter = NULL;
-		return -EFAULT;
-	}
-
-	return 0;
-}
-
-static void mlxreg_hotplug_device_destroy(struct mlxreg_hotplug_device *item)
-{
-	if (item->client) {
-		i2c_unregister_device(item->client);
-		item->client = NULL;
-	}
-
-	if (item->adapter) {
-		i2c_put_adapter(item->adapter);
-		item->adapter = NULL;
-	}
-}
-
 static inline void
 mlxreg_hotplug_work_helper(struct device *dev,
 			   struct mlxreg_hotplug_device *item, u8 is_inverse,

commit 3d838f5514ca5318f46bdb5b3f997cee66091695
Author: Vadim Pasternak <vadimp@mellanox.com>
Date:   Mon Jan 22 18:43:27 2018 -0800

    platform/mellanox: Rename i2c bus to nr
    
    Use Linux convention of nr instead of bus for i2c adapter number.
    
    Signed-off-by: Vadim Pasternak <vadimp@mellanox.com>
    Acked-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    [dvhart: refactored commit into smaller functional changes]
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/mellanox/mlxreg-hotplug.c b/drivers/platform/mellanox/mlxreg-hotplug.c
index e55f57639cc1..752f756723e0 100644
--- a/drivers/platform/mellanox/mlxreg-hotplug.c
+++ b/drivers/platform/mellanox/mlxreg-hotplug.c
@@ -186,17 +186,17 @@ static int mlxreg_hotplug_attr_init(struct mlxreg_hotplug_priv_data *priv)
 static int mlxreg_hotplug_device_create(struct device *dev,
 					struct mlxreg_hotplug_device *item)
 {
-	item->adapter = i2c_get_adapter(item->bus);
+	item->adapter = i2c_get_adapter(item->nr);
 	if (!item->adapter) {
 		dev_err(dev, "Failed to get adapter for bus %d\n",
-			item->bus);
+			item->nr);
 		return -EFAULT;
 	}
 
 	item->client = i2c_new_device(item->adapter, &item->brdinfo);
 	if (!item->client) {
 		dev_err(dev, "Failed to create client %s at bus %d at addr 0x%02x\n",
-			item->brdinfo.type, item->bus, item->brdinfo.addr);
+			item->brdinfo.type, item->nr, item->brdinfo.addr);
 		i2c_put_adapter(item->adapter);
 		item->adapter = NULL;
 		return -EFAULT;

commit 4abdbfa7331ef5a79a6f89d2d8061ac085878756
Author: Vadim Pasternak <vadimp@mellanox.com>
Date:   Mon Jan 22 18:34:49 2018 -0800

    platform/mellanox: mlxreg-hotplug: Remove unused wait.h include
    
    The driver does not make use of anything defined in wait.h.
    
    Signed-off-by: Vadim Pasternak <vadimp@mellanox.com>
    Acked-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    [dvhart: refactor into smaller functional changes, leave spinlock.h]
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/mellanox/mlxreg-hotplug.c b/drivers/platform/mellanox/mlxreg-hotplug.c
index 5cfc82ba34be..e55f57639cc1 100644
--- a/drivers/platform/mellanox/mlxreg-hotplug.c
+++ b/drivers/platform/mellanox/mlxreg-hotplug.c
@@ -42,7 +42,6 @@
 #include <linux/platform_data/mlxreg.h>
 #include <linux/platform_device.h>
 #include <linux/spinlock.h>
-#include <linux/wait.h>
 #include <linux/workqueue.h>
 
 /* Offset of event and mask registers from status register */

commit 1f976f6978bf6156ce822eb279ac86c519b10329
Author: Vadim Pasternak <vadimp@mellanox.com>
Date:   Wed Jan 17 18:21:53 2018 +0000

    platform/x86: Move Mellanox platform hotplug driver to platform/mellanox
    
    In preparation for making the hotplug driver build for different
    architectures, move mlxcpld-hotplug.c to platform/mellanox and the
    header to include/linux/platform_data as mlxreg.h to reflect the new
    interface changes to come.
    
    Replace references to CPLD with REG throughout the files, consistent
    with the new name.
    
    Signed-off-by: Vadim Pasternak <vadimp@mellanox.com>
    Acked-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    [dvhart: update copyright, rewrite commit message]
    Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>

diff --git a/drivers/platform/mellanox/mlxreg-hotplug.c b/drivers/platform/mellanox/mlxreg-hotplug.c
new file mode 100644
index 000000000000..5cfc82ba34be
--- /dev/null
+++ b/drivers/platform/mellanox/mlxreg-hotplug.c
@@ -0,0 +1,514 @@
+/*
+ * Copyright (c) 2016-2018 Mellanox Technologies. All rights reserved.
+ * Copyright (c) 2016-2018 Vadim Pasternak <vadimp@mellanox.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the names of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/bitops.h>
+#include <linux/device.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_data/mlxreg.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+#include <linux/workqueue.h>
+
+/* Offset of event and mask registers from status register */
+#define MLXREG_HOTPLUG_EVENT_OFF	1
+#define MLXREG_HOTPLUG_MASK_OFF	2
+#define MLXREG_HOTPLUG_AGGR_MASK_OFF	1
+
+#define MLXREG_HOTPLUG_ATTRS_NUM	8
+
+/**
+ * enum mlxreg_hotplug_attr_type - sysfs attributes for hotplug events:
+ * @MLXREG_HOTPLUG_ATTR_TYPE_PSU: power supply unit attribute;
+ * @MLXREG_HOTPLUG_ATTR_TYPE_PWR: power cable attribute;
+ * @MLXREG_HOTPLUG_ATTR_TYPE_FAN: FAN drawer attribute;
+ */
+enum mlxreg_hotplug_attr_type {
+	MLXREG_HOTPLUG_ATTR_TYPE_PSU,
+	MLXREG_HOTPLUG_ATTR_TYPE_PWR,
+	MLXREG_HOTPLUG_ATTR_TYPE_FAN,
+};
+
+/**
+ * struct mlxreg_hotplug_priv_data - platform private data:
+ * @irq: platform interrupt number;
+ * @pdev: platform device;
+ * @plat: platform data;
+ * @hwmon: hwmon device;
+ * @mlxreg_hotplug_attr: sysfs attributes array;
+ * @mlxreg_hotplug_dev_attr: sysfs sensor device attribute array;
+ * @group: sysfs attribute group;
+ * @groups: list of sysfs attribute group for hwmon registration;
+ * @dwork: delayed work template;
+ * @lock: spin lock;
+ * @aggr_cache: last value of aggregation register status;
+ * @psu_cache: last value of PSU register status;
+ * @pwr_cache: last value of power register status;
+ * @fan_cache: last value of FAN register status;
+ */
+struct mlxreg_hotplug_priv_data {
+	int irq;
+	struct platform_device *pdev;
+	struct mlxreg_hotplug_platform_data *plat;
+	struct device *hwmon;
+	struct attribute *mlxreg_hotplug_attr[MLXREG_HOTPLUG_ATTRS_NUM + 1];
+	struct sensor_device_attribute_2
+			mlxreg_hotplug_dev_attr[MLXREG_HOTPLUG_ATTRS_NUM];
+	struct attribute_group group;
+	const struct attribute_group *groups[2];
+	struct delayed_work dwork;
+	spinlock_t lock;
+	u8 aggr_cache;
+	u8 psu_cache;
+	u8 pwr_cache;
+	u8 fan_cache;
+};
+
+static ssize_t mlxreg_hotplug_attr_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct mlxreg_hotplug_priv_data *priv = platform_get_drvdata(pdev);
+	int index = to_sensor_dev_attr_2(attr)->index;
+	int nr = to_sensor_dev_attr_2(attr)->nr;
+	u8 reg_val = 0;
+
+	switch (nr) {
+	case MLXREG_HOTPLUG_ATTR_TYPE_PSU:
+		/* Bit = 0 : PSU is present. */
+		reg_val = !!!(inb(priv->plat->psu_reg_offset) & BIT(index));
+		break;
+
+	case MLXREG_HOTPLUG_ATTR_TYPE_PWR:
+		/* Bit = 1 : power cable is attached. */
+		reg_val = !!(inb(priv->plat->pwr_reg_offset) & BIT(index %
+						priv->plat->pwr_count));
+		break;
+
+	case MLXREG_HOTPLUG_ATTR_TYPE_FAN:
+		/* Bit = 0 : FAN is present. */
+		reg_val = !!!(inb(priv->plat->fan_reg_offset) & BIT(index %
+						priv->plat->fan_count));
+		break;
+	}
+
+	return sprintf(buf, "%u\n", reg_val);
+}
+
+#define PRIV_ATTR(i) priv->mlxreg_hotplug_attr[i]
+#define PRIV_DEV_ATTR(i) priv->mlxreg_hotplug_dev_attr[i]
+static int mlxreg_hotplug_attr_init(struct mlxreg_hotplug_priv_data *priv)
+{
+	int num_attrs = priv->plat->psu_count + priv->plat->pwr_count +
+			priv->plat->fan_count;
+	int i;
+
+	priv->group.attrs = devm_kzalloc(&priv->pdev->dev, num_attrs *
+					 sizeof(struct attribute *),
+					 GFP_KERNEL);
+	if (!priv->group.attrs)
+		return -ENOMEM;
+
+	for (i = 0; i < num_attrs; i++) {
+		PRIV_ATTR(i) = &PRIV_DEV_ATTR(i).dev_attr.attr;
+
+		if (i < priv->plat->psu_count) {
+			PRIV_ATTR(i)->name = devm_kasprintf(&priv->pdev->dev,
+						GFP_KERNEL, "psu%u", i + 1);
+			PRIV_DEV_ATTR(i).nr = MLXREG_HOTPLUG_ATTR_TYPE_PSU;
+		} else if (i < priv->plat->psu_count + priv->plat->pwr_count) {
+			PRIV_ATTR(i)->name = devm_kasprintf(&priv->pdev->dev,
+						GFP_KERNEL, "pwr%u", i %
+						priv->plat->pwr_count + 1);
+			PRIV_DEV_ATTR(i).nr = MLXREG_HOTPLUG_ATTR_TYPE_PWR;
+		} else {
+			PRIV_ATTR(i)->name = devm_kasprintf(&priv->pdev->dev,
+						GFP_KERNEL, "fan%u", i %
+						priv->plat->fan_count + 1);
+			PRIV_DEV_ATTR(i).nr = MLXREG_HOTPLUG_ATTR_TYPE_FAN;
+		}
+
+		if (!PRIV_ATTR(i)->name) {
+			dev_err(&priv->pdev->dev, "Memory allocation failed for sysfs attribute %d.\n",
+				i + 1);
+			return -ENOMEM;
+		}
+
+		PRIV_DEV_ATTR(i).dev_attr.attr.name = PRIV_ATTR(i)->name;
+		PRIV_DEV_ATTR(i).dev_attr.attr.mode = S_IRUGO;
+		PRIV_DEV_ATTR(i).dev_attr.show = mlxreg_hotplug_attr_show;
+		PRIV_DEV_ATTR(i).index = i;
+		sysfs_attr_init(&PRIV_DEV_ATTR(i).dev_attr.attr);
+	}
+
+	priv->group.attrs = priv->mlxreg_hotplug_attr;
+	priv->groups[0] = &priv->group;
+	priv->groups[1] = NULL;
+
+	return 0;
+}
+
+static int mlxreg_hotplug_device_create(struct device *dev,
+					struct mlxreg_hotplug_device *item)
+{
+	item->adapter = i2c_get_adapter(item->bus);
+	if (!item->adapter) {
+		dev_err(dev, "Failed to get adapter for bus %d\n",
+			item->bus);
+		return -EFAULT;
+	}
+
+	item->client = i2c_new_device(item->adapter, &item->brdinfo);
+	if (!item->client) {
+		dev_err(dev, "Failed to create client %s at bus %d at addr 0x%02x\n",
+			item->brdinfo.type, item->bus, item->brdinfo.addr);
+		i2c_put_adapter(item->adapter);
+		item->adapter = NULL;
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static void mlxreg_hotplug_device_destroy(struct mlxreg_hotplug_device *item)
+{
+	if (item->client) {
+		i2c_unregister_device(item->client);
+		item->client = NULL;
+	}
+
+	if (item->adapter) {
+		i2c_put_adapter(item->adapter);
+		item->adapter = NULL;
+	}
+}
+
+static inline void
+mlxreg_hotplug_work_helper(struct device *dev,
+			   struct mlxreg_hotplug_device *item, u8 is_inverse,
+			   u16 offset, u8 mask, u8 *cache)
+{
+	u8 val, asserted;
+	int bit;
+
+	/* Mask event. */
+	outb(0, offset + MLXREG_HOTPLUG_MASK_OFF);
+	/* Read status. */
+	val = inb(offset) & mask;
+	asserted = *cache ^ val;
+	*cache = val;
+
+	/*
+	 * Validate if item related to received signal type is valid.
+	 * It should never happen, excepted the situation when some
+	 * piece of hardware is broken. In such situation just produce
+	 * error message and return. Caller must continue to handle the
+	 * signals from other devices if any.
+	 */
+	if (unlikely(!item)) {
+		dev_err(dev, "False signal is received: register at offset 0x%02x, mask 0x%02x.\n",
+			offset, mask);
+		return;
+	}
+
+	for_each_set_bit(bit, (unsigned long *)&asserted, 8) {
+		if (val & BIT(bit)) {
+			if (is_inverse)
+				mlxreg_hotplug_device_destroy(item + bit);
+			else
+				mlxreg_hotplug_device_create(dev, item + bit);
+		} else {
+			if (is_inverse)
+				mlxreg_hotplug_device_create(dev, item + bit);
+			else
+				mlxreg_hotplug_device_destroy(item + bit);
+		}
+	}
+
+	/* Acknowledge event. */
+	outb(0, offset + MLXREG_HOTPLUG_EVENT_OFF);
+	/* Unmask event. */
+	outb(mask, offset + MLXREG_HOTPLUG_MASK_OFF);
+}
+
+/*
+ * mlxreg_hotplug_work_handler - performs traversing of CPLD interrupt
+ * registers according to the below hierarchy schema:
+ *
+ *                   Aggregation registers (status/mask)
+ * PSU registers:           *---*
+ * *-----------------*      |   |
+ * |status/event/mask|----->| * |
+ * *-----------------*      |   |
+ * Power registers:         |   |
+ * *-----------------*      |   |
+ * |status/event/mask|----->| * |---> CPU
+ * *-----------------*      |   |
+ * FAN registers:
+ * *-----------------*      |   |
+ * |status/event/mask|----->| * |
+ * *-----------------*      |   |
+ *                          *---*
+ * In case some system changed are detected: FAN in/out, PSU in/out, power
+ * cable attached/detached, relevant device is created or destroyed.
+ */
+static void mlxreg_hotplug_work_handler(struct work_struct *work)
+{
+	struct mlxreg_hotplug_priv_data *priv = container_of(work,
+				struct mlxreg_hotplug_priv_data, dwork.work);
+	u8 val, aggr_asserted;
+	unsigned long flags;
+
+	/* Mask aggregation event. */
+	outb(0, priv->plat->top_aggr_offset + MLXREG_HOTPLUG_AGGR_MASK_OFF);
+	/* Read aggregation status. */
+	val = inb(priv->plat->top_aggr_offset) & priv->plat->top_aggr_mask;
+	aggr_asserted = priv->aggr_cache ^ val;
+	priv->aggr_cache = val;
+
+	/* Handle PSU configuration changes. */
+	if (aggr_asserted & priv->plat->top_aggr_psu_mask)
+		mlxreg_hotplug_work_helper(&priv->pdev->dev, priv->plat->psu,
+					   1, priv->plat->psu_reg_offset,
+					   priv->plat->psu_mask,
+					   &priv->psu_cache);
+
+	/* Handle power cable configuration changes. */
+	if (aggr_asserted & priv->plat->top_aggr_pwr_mask)
+		mlxreg_hotplug_work_helper(&priv->pdev->dev, priv->plat->pwr,
+					   0, priv->plat->pwr_reg_offset,
+					   priv->plat->pwr_mask,
+					   &priv->pwr_cache);
+
+	/* Handle FAN configuration changes. */
+	if (aggr_asserted & priv->plat->top_aggr_fan_mask)
+		mlxreg_hotplug_work_helper(&priv->pdev->dev, priv->plat->fan,
+					   1, priv->plat->fan_reg_offset,
+					   priv->plat->fan_mask,
+					   &priv->fan_cache);
+
+	if (aggr_asserted) {
+		spin_lock_irqsave(&priv->lock, flags);
+
+		/*
+		 * It is possible, that some signals have been inserted, while
+		 * interrupt has been masked by mlxreg_hotplug_work_handler.
+		 * In this case such signals will be missed. In order to handle
+		 * these signals delayed work is canceled and work task
+		 * re-scheduled for immediate execution. It allows to handle
+		 * missed signals, if any. In other case work handler just
+		 * validates that no new signals have been received during
+		 * masking.
+		 */
+		cancel_delayed_work(&priv->dwork);
+		schedule_delayed_work(&priv->dwork, 0);
+
+		spin_unlock_irqrestore(&priv->lock, flags);
+
+		return;
+	}
+
+	/* Unmask aggregation event (no need acknowledge). */
+	outb(priv->plat->top_aggr_mask, priv->plat->top_aggr_offset +
+						MLXREG_HOTPLUG_AGGR_MASK_OFF);
+}
+
+static void mlxreg_hotplug_set_irq(struct mlxreg_hotplug_priv_data *priv)
+{
+	/* Clear psu presense event. */
+	outb(0, priv->plat->psu_reg_offset + MLXREG_HOTPLUG_EVENT_OFF);
+	/* Set psu initial status as mask and unmask psu event. */
+	priv->psu_cache = priv->plat->psu_mask;
+	outb(priv->plat->psu_mask, priv->plat->psu_reg_offset +
+						MLXREG_HOTPLUG_MASK_OFF);
+
+	/* Clear power cable event. */
+	outb(0, priv->plat->pwr_reg_offset + MLXREG_HOTPLUG_EVENT_OFF);
+	/* Keep power initial status as zero and unmask power event. */
+	outb(priv->plat->pwr_mask, priv->plat->pwr_reg_offset +
+						MLXREG_HOTPLUG_MASK_OFF);
+
+	/* Clear fan presense event. */
+	outb(0, priv->plat->fan_reg_offset + MLXREG_HOTPLUG_EVENT_OFF);
+	/* Set fan initial status as mask and unmask fan event. */
+	priv->fan_cache = priv->plat->fan_mask;
+	outb(priv->plat->fan_mask, priv->plat->fan_reg_offset +
+						MLXREG_HOTPLUG_MASK_OFF);
+
+	/* Keep aggregation initial status as zero and unmask events. */
+	outb(priv->plat->top_aggr_mask, priv->plat->top_aggr_offset +
+						MLXREG_HOTPLUG_AGGR_MASK_OFF);
+
+	/* Invoke work handler for initializing hot plug devices setting. */
+	mlxreg_hotplug_work_handler(&priv->dwork.work);
+
+	enable_irq(priv->irq);
+}
+
+static void mlxreg_hotplug_unset_irq(struct mlxreg_hotplug_priv_data *priv)
+{
+	int i;
+
+	disable_irq(priv->irq);
+	cancel_delayed_work_sync(&priv->dwork);
+
+	/* Mask aggregation event. */
+	outb(0, priv->plat->top_aggr_offset + MLXREG_HOTPLUG_AGGR_MASK_OFF);
+
+	/* Mask psu presense event. */
+	outb(0, priv->plat->psu_reg_offset + MLXREG_HOTPLUG_MASK_OFF);
+	/* Clear psu presense event. */
+	outb(0, priv->plat->psu_reg_offset + MLXREG_HOTPLUG_EVENT_OFF);
+
+	/* Mask power cable event. */
+	outb(0, priv->plat->pwr_reg_offset + MLXREG_HOTPLUG_MASK_OFF);
+	/* Clear power cable event. */
+	outb(0, priv->plat->pwr_reg_offset + MLXREG_HOTPLUG_EVENT_OFF);
+
+	/* Mask fan presense event. */
+	outb(0, priv->plat->fan_reg_offset + MLXREG_HOTPLUG_MASK_OFF);
+	/* Clear fan presense event. */
+	outb(0, priv->plat->fan_reg_offset + MLXREG_HOTPLUG_EVENT_OFF);
+
+	/* Remove all the attached devices. */
+	for (i = 0; i < priv->plat->psu_count; i++)
+		mlxreg_hotplug_device_destroy(priv->plat->psu + i);
+
+	for (i = 0; i < priv->plat->pwr_count; i++)
+		mlxreg_hotplug_device_destroy(priv->plat->pwr + i);
+
+	for (i = 0; i < priv->plat->fan_count; i++)
+		mlxreg_hotplug_device_destroy(priv->plat->fan + i);
+}
+
+static irqreturn_t mlxreg_hotplug_irq_handler(int irq, void *dev)
+{
+	struct mlxreg_hotplug_priv_data *priv =
+				(struct mlxreg_hotplug_priv_data *)dev;
+
+	/* Schedule work task for immediate execution.*/
+	schedule_delayed_work(&priv->dwork, 0);
+
+	return IRQ_HANDLED;
+}
+
+static int mlxreg_hotplug_probe(struct platform_device *pdev)
+{
+	struct mlxreg_hotplug_platform_data *pdata;
+	struct mlxreg_hotplug_priv_data *priv;
+	int err;
+
+	pdata = dev_get_platdata(&pdev->dev);
+	if (!pdata) {
+		dev_err(&pdev->dev, "Failed to get platform data.\n");
+		return -EINVAL;
+	}
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->pdev = pdev;
+	priv->plat = pdata;
+
+	priv->irq = platform_get_irq(pdev, 0);
+	if (priv->irq < 0) {
+		dev_err(&pdev->dev, "Failed to get platform irq: %d\n",
+			priv->irq);
+		return priv->irq;
+	}
+
+	err = devm_request_irq(&pdev->dev, priv->irq,
+			       mlxreg_hotplug_irq_handler, 0, pdev->name,
+			       priv);
+	if (err) {
+		dev_err(&pdev->dev, "Failed to request irq: %d\n", err);
+		return err;
+	}
+	disable_irq(priv->irq);
+
+	INIT_DELAYED_WORK(&priv->dwork, mlxreg_hotplug_work_handler);
+	spin_lock_init(&priv->lock);
+
+	err = mlxreg_hotplug_attr_init(priv);
+	if (err) {
+		dev_err(&pdev->dev, "Failed to allocate attributes: %d\n", err);
+		return err;
+	}
+
+	priv->hwmon = devm_hwmon_device_register_with_groups(&pdev->dev,
+					"mlxreg_hotplug", priv, priv->groups);
+	if (IS_ERR(priv->hwmon)) {
+		dev_err(&pdev->dev, "Failed to register hwmon device %ld\n",
+			PTR_ERR(priv->hwmon));
+		return PTR_ERR(priv->hwmon);
+	}
+
+	platform_set_drvdata(pdev, priv);
+
+	/* Perform initial interrupts setup. */
+	mlxreg_hotplug_set_irq(priv);
+
+	return 0;
+}
+
+static int mlxreg_hotplug_remove(struct platform_device *pdev)
+{
+	struct mlxreg_hotplug_priv_data *priv = platform_get_drvdata(pdev);
+
+	/* Clean interrupts setup. */
+	mlxreg_hotplug_unset_irq(priv);
+
+	return 0;
+}
+
+static struct platform_driver mlxreg_hotplug_driver = {
+	.driver = {
+		.name = "mlxreg-hotplug",
+	},
+	.probe = mlxreg_hotplug_probe,
+	.remove = mlxreg_hotplug_remove,
+};
+
+module_platform_driver(mlxreg_hotplug_driver);
+
+MODULE_AUTHOR("Vadim Pasternak <vadimp@mellanox.com>");
+MODULE_DESCRIPTION("Mellanox regmap hotplug platform driver");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_ALIAS("platform:mlxreg-hotplug");
