commit edfc23f6f9fdbd7825d50ac1f380243cde19b679
Author: Zenghui Yu <yuzenghui@huawei.com>
Date:   Wed Apr 8 19:43:52 2020 +0800

    irqchip/mbigen: Free msi_desc on device teardown
    
    Using irq_domain_free_irqs_common() on the irqdomain free path will
    leave the MSI descriptor unfreed when platform devices get removed.
    Properly free it by MSI domain free function.
    
    Fixes: 9650c60ebfec0 ("irqchip/mbigen: Create irq domain for each mbigen device")
    Signed-off-by: Zenghui Yu <yuzenghui@huawei.com>
    Signed-off-by: Marc Zyngier <maz@kernel.org>
    Link: https://lore.kernel.org/r/20200408114352.1604-1-yuzenghui@huawei.com

diff --git a/drivers/irqchip/irq-mbigen.c b/drivers/irqchip/irq-mbigen.c
index 6b566bba263b..ff7627b57772 100644
--- a/drivers/irqchip/irq-mbigen.c
+++ b/drivers/irqchip/irq-mbigen.c
@@ -220,10 +220,16 @@ static int mbigen_irq_domain_alloc(struct irq_domain *domain,
 	return 0;
 }
 
+static void mbigen_irq_domain_free(struct irq_domain *domain, unsigned int virq,
+				   unsigned int nr_irqs)
+{
+	platform_msi_domain_free(domain, virq, nr_irqs);
+}
+
 static const struct irq_domain_ops mbigen_domain_ops = {
 	.translate	= mbigen_domain_translate,
 	.alloc		= mbigen_irq_domain_alloc,
-	.free		= irq_domain_free_irqs_common,
+	.free		= mbigen_irq_domain_free,
 };
 
 static int mbigen_of_create_domain(struct platform_device *pdev,

commit d6152e6ec9e2171280436f7b31a571509b9287e1
Author: John Garry <john.garry@huawei.com>
Date:   Fri Jan 17 01:38:43 2020 +0800

    irqchip/mbigen: Set driver .suppress_bind_attrs to avoid remove problems
    
    The following crash can be seen for setting
    CONFIG_DEBUG_TEST_DRIVER_REMOVE=y for DT FW (which some people still use):
    
    Hisilicon MBIGEN-V2 60080000.interrupt-controller: Failed to create mbi-gen irqdomain
    Hisilicon MBIGEN-V2: probe of 60080000.interrupt-controller failed with error -12
    
    [...]
    
    Unable to handle kernel paging request at virtual address 0000000000005008
     Mem abort info:
       ESR = 0x96000004
       EC = 0x25: DABT (current EL), IL = 32 bits
       SET = 0, FnV = 0
       EA = 0, S1PTW = 0
     Data abort info:
       ISV = 0, ISS = 0x00000004
       CM = 0, WnR = 0
     user pgtable: 4k pages, 48-bit VAs, pgdp=0000041fb9990000
     [0000000000005008] pgd=0000000000000000
     Internal error: Oops: 96000004 [#1] PREEMPT SMP
     Modules linked in:
     CPU: 7 PID: 1 Comm: swapper/0 Not tainted 5.5.0-rc6-00002-g3fc42638a506-dirty #1622
     Hardware name: Huawei Taishan 2280 /D05, BIOS Hisilicon D05 IT21 Nemo 2.0 RC0 04/18/2018
     pstate: 40000085 (nZcv daIf -PAN -UAO)
     pc : mbigen_set_type+0x38/0x60
     lr : __irq_set_trigger+0x6c/0x188
     sp : ffff800014b4b400
     x29: ffff800014b4b400 x28: 0000000000000007
     x27: 0000000000000000 x26: 0000000000000000
     x25: ffff041fd83bd0d4 x24: ffff041fd83bd188
     x23: 0000000000000000 x22: ffff80001193ce00
     x21: 0000000000000004 x20: 0000000000000000
     x19: ffff041fd83bd000 x18: ffffffffffffffff
     x17: 0000000000000000 x16: 0000000000000000
     x15: ffff8000119098c8 x14: ffff041fb94ec91c
     x13: ffff041fb94ec1a1 x12: 0000000000000030
     x11: 0101010101010101 x10: 0000000000000040
     x9 : 0000000000000000 x8 : ffff041fb98c6680
     x7 : ffff800014b4b380 x6 : ffff041fd81636c8
     x5 : 0000000000000000 x4 : 000000000000025f
     x3 : 0000000000005000 x2 : 0000000000005008
     x1 : 0000000000000004 x0 : 0000000080000000
     Call trace:
      mbigen_set_type+0x38/0x60
      __setup_irq+0x744/0x900
      request_threaded_irq+0xe0/0x198
      pcie_pme_probe+0x98/0x118
      pcie_port_probe_service+0x38/0x78
      really_probe+0xa0/0x3e0
      driver_probe_device+0x58/0x100
      __device_attach_driver+0x90/0xb0
      bus_for_each_drv+0x64/0xc8
      __device_attach+0xd8/0x138
      device_initial_probe+0x10/0x18
      bus_probe_device+0x90/0x98
      device_add+0x4c4/0x770
      device_register+0x1c/0x28
      pcie_port_device_register+0x1e4/0x4f0
      pcie_portdrv_probe+0x34/0xd8
      local_pci_probe+0x3c/0xa0
      pci_device_probe+0x128/0x1c0
      really_probe+0xa0/0x3e0
      driver_probe_device+0x58/0x100
      __device_attach_driver+0x90/0xb0
      bus_for_each_drv+0x64/0xc8
      __device_attach+0xd8/0x138
      device_attach+0x10/0x18
      pci_bus_add_device+0x4c/0xb8
      pci_bus_add_devices+0x38/0x88
      pci_host_probe+0x3c/0xc0
      pci_host_common_probe+0xf0/0x208
      hisi_pcie_almost_ecam_probe+0x24/0x30
      platform_drv_probe+0x50/0xa0
      really_probe+0xa0/0x3e0
      driver_probe_device+0x58/0x100
      device_driver_attach+0x6c/0x90
      __driver_attach+0x84/0xc8
      bus_for_each_dev+0x74/0xc8
      driver_attach+0x20/0x28
      bus_add_driver+0x148/0x1f0
      driver_register+0x60/0x110
      __platform_driver_register+0x40/0x48
      hisi_pcie_almost_ecam_driver_init+0x1c/0x24
    
    The specific problem here is that the mbigen driver real probe has failed
    as the mbigen_of_create_domain()->of_platform_device_create() call fails,
    the reason for that being that we never destroyed the platform device
    created during the remove test dry run and there is some conflict.
    
    Since we generally would never want to unbind this driver, and to save
    adding a driver tear down path for that, just set the driver
    .suppress_bind_attrs member to avoid this possibility.
    
    Signed-off-by: John Garry <john.garry@huawei.com>
    Signed-off-by: Marc Zyngier <maz@kernel.org>
    Reviewed-by: Hanjun Guo <guohanjun@huawei.com>
    Link: https://lore.kernel.org/r/1579196323-180137-1-git-send-email-john.garry@huawei.com

diff --git a/drivers/irqchip/irq-mbigen.c b/drivers/irqchip/irq-mbigen.c
index 3f09f658e8e2..6b566bba263b 100644
--- a/drivers/irqchip/irq-mbigen.c
+++ b/drivers/irqchip/irq-mbigen.c
@@ -374,6 +374,7 @@ static struct platform_driver mbigen_platform_driver = {
 		.name		= "Hisilicon MBIGEN-V2",
 		.of_match_table	= mbigen_of_match,
 		.acpi_match_table = ACPI_PTR(mbigen_acpi_match),
+		.suppress_bind_attrs = true,
 	},
 	.probe			= mbigen_device_probe,
 };

commit a5dbba8f443e2046c63e5dd2907f562c1179169f
Merge: 5f9e832c1370 b5fa9fc9e809
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Aug 1 20:21:00 2019 +0200

    Merge tag 'irqchip-fixes-5.3' of git://git.kernel.org/pub/scm/linux/kernel/git/maz/arm-platforms into irq/urgent
    
    Pull irqchip fixes from Marc Zyngier:
    
      A small bunch of fixes from the irqchip department:
    
        - Fix a couple of UAF on error paths (RZA1, GICv3 ITS)
        - Fix iMX GPCv2 trigger setting
        - Add missing of_node_put on error path in MBIGEN
        - Add another bunch of /* fall-through */ to silence warnings

commit 321275f0d8f5939f2a98749fe03ee97ac97e73d0
Author: Nishka Dasgupta <nishkadg.linux@gmail.com>
Date:   Tue Jul 23 16:09:10 2019 +0530

    irqchip/irq-mbigen: Add of_node_put() before return
    
    Each iteration of for_each_child_of_node puts the previous node, but
    in the case of a return from the middle of the loop, there is no put,
    thus causing a memory leak. Add an of_node_put before the return in
    three places.
    Issue found with Coccinelle.
    
    Signed-off-by: Nishka Dasgupta <nishkadg.linux@gmail.com>
    Signed-off-by: Marc Zyngier <maz@kernel.org>

diff --git a/drivers/irqchip/irq-mbigen.c b/drivers/irqchip/irq-mbigen.c
index c0f65ea0ae0f..64f3574cc009 100644
--- a/drivers/irqchip/irq-mbigen.c
+++ b/drivers/irqchip/irq-mbigen.c
@@ -252,12 +252,15 @@ static int mbigen_of_create_domain(struct platform_device *pdev,
 
 		parent = platform_bus_type.dev_root;
 		child = of_platform_device_create(np, NULL, parent);
-		if (!child)
+		if (!child) {
+			of_node_put(np);
 			return -ENOMEM;
+		}
 
 		if (of_property_read_u32(child->dev.of_node, "num-pins",
 					 &num_pins) < 0) {
 			dev_err(&pdev->dev, "No num-pins property\n");
+			of_node_put(np);
 			return -EINVAL;
 		}
 
@@ -265,8 +268,10 @@ static int mbigen_of_create_domain(struct platform_device *pdev,
 							   mbigen_write_msg,
 							   &mbigen_domain_ops,
 							   mgn_chip);
-		if (!domain)
+		if (!domain) {
+			of_node_put(np);
 			return -ENOMEM;
+		}
 	}
 
 	return 0;

commit 2a1ccd31420a7b1acd6ca37b2bec2d723aa093e4
Merge: e0e86b111bca 3a1d24ca9573
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 8 11:01:13 2019 -0700

    Merge branch 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull irq updates from Thomas Gleixner:
     "The irq departement provides the usual mixed bag:
    
      Core:
    
       - Further improvements to the irq timings code which aims to predict
         the next interrupt for power state selection to achieve better
         latency/power balance
    
       - Add interrupt statistics to the core NMI handlers
    
       - The usual small fixes and cleanups
    
      Drivers:
    
       - Support for Renesas RZ/A1, Annapurna Labs FIC, Meson-G12A SoC and
         Amazon Gravition AMR/GIC interrupt controllers.
    
       - Rework of the Renesas INTC controller driver
    
       - ACPI support for Socionext SoCs
    
       - Enhancements to the CSKY interrupt controller
    
       - The usual small fixes and cleanups"
    
    * 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (39 commits)
      irq/irqdomain: Fix comment typo
      genirq: Update irq stats from NMI handlers
      irqchip/gic-pm: Remove PM_CLK dependency
      irqchip/al-fic: Introduce Amazon's Annapurna Labs Fabric Interrupt Controller Driver
      dt-bindings: interrupt-controller: Add Amazon's Annapurna Labs FIC
      softirq: Use __this_cpu_write() in takeover_tasklets()
      irqchip/mbigen: Stop printing kernel addresses
      irqchip/gic: Add dependency for ARM_GIC_MAX_NR
      genirq/affinity: Remove unused argument from [__]irq_build_affinity_masks()
      genirq/timings: Add selftest for next event computation
      genirq/timings: Add selftest for irqs circular buffer
      genirq/timings: Add selftest for circular array
      genirq/timings: Encapsulate storing function
      genirq/timings: Encapsulate timings push
      genirq/timings: Optimize the period detection speed
      genirq/timings: Fix timings buffer inspection
      genirq/timings: Fix next event index function
      irqchip/qcom: Use struct_size() in devm_kzalloc()
      irqchip/irq-csky-mpintc: Remove unnecessary loop in interrupt handler
      dt-bindings: interrupt-controller: Update csky mpintc
      ...

commit caab277b1de0a22b675c4c95fc7b285ec2eb5bf5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jun 3 07:44:50 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 234
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 503 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190602204653.811534538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/irqchip/irq-mbigen.c b/drivers/irqchip/irq-mbigen.c
index 98b6e1d4b1a6..a89c693d5b90 100644
--- a/drivers/irqchip/irq-mbigen.c
+++ b/drivers/irqchip/irq-mbigen.c
@@ -1,19 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2015 Hisilicon Limited, All Rights Reserved.
  * Author: Jun Ma <majun258@huawei.com>
  * Author: Yun Wu <wuyun.wu@huawei.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include <linux/acpi.h>

commit 0bdd0047ec949661b61692198dc1773d99694d1c
Author: Kefeng Wang <wangkefeng.wang@huawei.com>
Date:   Tue Jun 18 17:15:05 2019 +0800

    irqchip/mbigen: Stop printing kernel addresses
    
    After commit ad67b74d2469d9b8 ("printk: hash addresses printed with %p"),
    it will print "____ptrval____" instead of actual addresses when mbigen
    create domain fails,
    
      Hisilicon MBIGEN-V2 HISI0152:00: Failed to create mbi-gen@(____ptrval____) irqdomain
      Hisilicon MBIGEN-V2: probe of HISI0152:00 failed with error -12
    
    dev_xxx() helper contains the device info, HISI0152:00, which stands for
    mbigen ACPI HID and its UID, we can identify the failing probed mbigen,
    so just remove the printing "mgn_chip->base", and also add missing "\n".
    
    Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Reviewed-by: Hanjun Guo <guohanjun@huawei.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/irqchip/irq-mbigen.c b/drivers/irqchip/irq-mbigen.c
index 98b6e1d4b1a6..c0f65ea0ae0f 100644
--- a/drivers/irqchip/irq-mbigen.c
+++ b/drivers/irqchip/irq-mbigen.c
@@ -355,8 +355,7 @@ static int mbigen_device_probe(struct platform_device *pdev)
 		err = -EINVAL;
 
 	if (err) {
-		dev_err(&pdev->dev, "Failed to create mbi-gen@%p irqdomain",
-			mgn_chip->base);
+		dev_err(&pdev->dev, "Failed to create mbi-gen irqdomain\n");
 		return err;
 	}
 

commit fca269f201a8d9985c0a31fb60b15d4eb57cef80
Author: Jianguo Chen <chenjianguo3@huawei.com>
Date:   Wed Mar 20 18:54:21 2019 +0000

    irqchip/mbigen: Don't clear eventid when freeing an MSI
    
    mbigen_write_msg clears eventid bits of a mbigen register
    when free a interrupt, because msi_domain_deactivate memset
    struct msg to zero. Then multiple mbigen pins with zero eventid
    will report the same interrupt number.
    
    The eventid clear call trace:
                    free_irq
                    __free_irq
                    irq_shutdown
                    irq_domain_deactivate_irq
                    __irq_domain_deactivate_irq
                    __irq_domain_deactivate_irq
                    msi_domain_deactivate
                    platform_msi_write_msg
                    mbigen_write_msg
    
    Signed-off-by: Jianguo Chen <chenjianguo3@huawei.com>
    [maz: massaged subject]
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/irqchip/irq-mbigen.c b/drivers/irqchip/irq-mbigen.c
index 567b29c47608..98b6e1d4b1a6 100644
--- a/drivers/irqchip/irq-mbigen.c
+++ b/drivers/irqchip/irq-mbigen.c
@@ -161,6 +161,9 @@ static void mbigen_write_msg(struct msi_desc *desc, struct msi_msg *msg)
 	void __iomem *base = d->chip_data;
 	u32 val;
 
+	if (!msg->address_lo && !msg->address_hi)
+		return;
+ 
 	base += get_mbigen_vec_reg(d->hwirq);
 	val = readl_relaxed(base);
 

commit e183c2a3ea1996932fef7d5867df387793b1941f
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Fri Jun 2 10:20:55 2017 +0200

    irqchip/irq-mbigen: Constify irq_domain_ops
    
    struct irq_domain_ops is not modified, so it can be made const.
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/irqchip/irq-mbigen.c b/drivers/irqchip/irq-mbigen.c
index 31d6b5a582d2..567b29c47608 100644
--- a/drivers/irqchip/irq-mbigen.c
+++ b/drivers/irqchip/irq-mbigen.c
@@ -228,7 +228,7 @@ static int mbigen_irq_domain_alloc(struct irq_domain *domain,
 	return 0;
 }
 
-static struct irq_domain_ops mbigen_domain_ops = {
+static const struct irq_domain_ops mbigen_domain_ops = {
 	.translate	= mbigen_domain_translate,
 	.alloc		= mbigen_irq_domain_alloc,
 	.free		= irq_domain_free_irqs_common,

commit 9459a04b6a5a09967eec94a1b66f0a74312819d9
Author: MaJun <majun258@huawei.com>
Date:   Fri May 12 11:55:28 2017 +0800

    irqchip/mbigen: Fix the clear register offset calculation
    
    The register array offset for clearing an interrupt is calculated by:
    
        offset = (hwirq - RESERVED_IRQ_PER_MBIGEN_CHIP) / 32;
    
    This is wrong because the clear register array includes the reserved
    interrupts. So the clear operation ends up in the wrong register.
    
    This went unnoticed so far, because the hardware clears the real bit
    through a timeout mechanism when the hardware is configured in debug
    mode. That debug mode was enabled on early generations of the hardware, so
    the problem was papered over.
    
    On newer hardware with updated firmware the debug mode was disabled, so the
    bits did not get cleared which causes the system to malfunction.
    
    Remove the subtraction of RESERVED_IRQ_PER_MBIGEN_CHIP, so the correct
    register is accessed.
    
    [ tglx: Rewrote changelog ]
    
    Fixes: a6c2f87b8820 ("irqchip/mbigen: Implement the mbigen irq chip operation functions")
    Signed-off-by: MaJun <majun258@huawei.com>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Kefeng Wang <wangkefeng.wang@huawei.com>
    Cc: linuxarm@huawei.com
    Cc: Wei Yongjun <weiyongjun1@huawei.com>
    Link: http://lkml.kernel.org/r/1494561328-39514-4-git-send-email-guohanjun@huawei.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/irq-mbigen.c b/drivers/irqchip/irq-mbigen.c
index 2fa1e457190d..31d6b5a582d2 100644
--- a/drivers/irqchip/irq-mbigen.c
+++ b/drivers/irqchip/irq-mbigen.c
@@ -106,10 +106,7 @@ static inline void get_mbigen_type_reg(irq_hw_number_t hwirq,
 static inline void get_mbigen_clear_reg(irq_hw_number_t hwirq,
 					u32 *mask, u32 *addr)
 {
-	unsigned int ofst;
-
-	hwirq -= RESERVED_IRQ_PER_MBIGEN_CHIP;
-	ofst = hwirq / 32 * 4;
+	unsigned int ofst = (hwirq / 32) * 4;
 
 	*mask = 1 << (hwirq % 32);
 	*addr = ofst + REG_MBIGEN_CLEAR_OFFSET;

commit ad7cc3c0c57d77b442db323056354d0e49833569
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Fri May 12 11:55:27 2017 +0800

    irqchip/mbigen: Fix potential NULL dereferencing
    
    platform_get_resource() may return NULL, add proper
    check to avoid potential NULL dereferencing.
    
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Kefeng Wang <wangkefeng.wang@huawei.com>
    Cc: linuxarm@huawei.com
    Cc: Wei Yongjun <weiyongjun1@huawei.com>
    Cc: MaJun <majun258@huawei.com>
    Link: http://lkml.kernel.org/r/1494561328-39514-3-git-send-email-guohanjun@huawei.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/irq-mbigen.c b/drivers/irqchip/irq-mbigen.c
index 0f5e66e96bd9..2fa1e457190d 100644
--- a/drivers/irqchip/irq-mbigen.c
+++ b/drivers/irqchip/irq-mbigen.c
@@ -337,6 +337,9 @@ static int mbigen_device_probe(struct platform_device *pdev)
 	mgn_chip->pdev = pdev;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -EINVAL;
+
 	mgn_chip->base = devm_ioremap(&pdev->dev, res->start,
 				      resource_size(res));
 	if (!mgn_chip->base) {

commit 5ba9b0a14132d0b8d97affe909f324045a968d03
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Fri May 12 11:55:26 2017 +0800

    irqchip/mbigen: Fix memory mapping code
    
    Some mbigens share memory regions, and devm_ioremap_resource
    does not allow to share resources which will break the probe
    of mbigen, in opposition to devm_ioremap.
    
    This patch restores back usage of devm_ioremap function, but
    with proper error handling and logging.
    
    Fixes: 216646e4d82e ("irqchip/mbigen: Fix return value check in mbigen_device_probe()")
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Kefeng Wang <wangkefeng.wang@huawei.com>
    Cc: linuxarm@huawei.com
    Cc: Wei Yongjun <weiyongjun1@huawei.com>
    Cc: MaJun <majun258@huawei.com>
    Link: http://lkml.kernel.org/r/1494561328-39514-2-git-send-email-guohanjun@huawei.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/irq-mbigen.c b/drivers/irqchip/irq-mbigen.c
index d2306c821ebb..0f5e66e96bd9 100644
--- a/drivers/irqchip/irq-mbigen.c
+++ b/drivers/irqchip/irq-mbigen.c
@@ -337,9 +337,12 @@ static int mbigen_device_probe(struct platform_device *pdev)
 	mgn_chip->pdev = pdev;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	mgn_chip->base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(mgn_chip->base))
-		return PTR_ERR(mgn_chip->base);
+	mgn_chip->base = devm_ioremap(&pdev->dev, res->start,
+				      resource_size(res));
+	if (!mgn_chip->base) {
+		dev_err(&pdev->dev, "failed to ioremap %pR\n", res);
+		return -ENOMEM;
+	}
 
 	if (IS_ENABLED(CONFIG_OF) && pdev->dev.of_node)
 		err = mbigen_of_create_domain(pdev, mgn_chip);

commit 216646e4d82e847791f0ba66c439dedd36cb119f
Author: Wei Yongjun <weiyongjun1@huawei.com>
Date:   Thu Apr 27 15:21:13 2017 +0000

    irqchip/mbigen: Fix return value check in mbigen_device_probe()
    
    In case of error, the function devm_ioremap() returns NULL pointer
    not ERR_PTR(). Use devm_ioremap_resource() instead of devm_ioremap()
    to fix the IS_ERR() test issue.
    
    Fixes: 76e1f77f9c26 ("irqchip/mbigen: Introduce mbigen_of_create_domain()")
    Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Kefeng Wang <wangkefeng.wang@huawei.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Link: http://lkml.kernel.org/r/20170427152113.31147-1-weiyj.lk@gmail.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/irq-mbigen.c b/drivers/irqchip/irq-mbigen.c
index 061cdb8bde8b..d2306c821ebb 100644
--- a/drivers/irqchip/irq-mbigen.c
+++ b/drivers/irqchip/irq-mbigen.c
@@ -337,8 +337,7 @@ static int mbigen_device_probe(struct platform_device *pdev)
 	mgn_chip->pdev = pdev;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	mgn_chip->base = devm_ioremap(&pdev->dev, res->start,
-				      resource_size(res));
+	mgn_chip->base = devm_ioremap_resource(&pdev->dev, res);
 	if (IS_ERR(mgn_chip->base))
 		return PTR_ERR(mgn_chip->base);
 

commit f907c515ffb06e6fd5e74397badd674f3c233418
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Tue Mar 28 20:21:05 2017 +0800

    irqchip/mbigen: Add ACPI support
    
    With the preparation of platform msi support and interrupt producer
    in commit d44fa3d46079 ("ACPI: Add support for ResourceSource/IRQ
    domain mapping"), we can add mbigen ACPI support now.
    
    Now that the major framework changes are ready, we just need to add
    the ACPI probe code which creates the irqdomain for devices connecting
    to it.
    
    In order to create the irqdomain, we need to know the number of hw
    irqs as input which is provided by mbigen. In DT case, we are using
    "num-pins" property to describe it, and we will take advantage of
    that too using _DSD in ACPI as there is no standard way of describe
    it in ACPI way, also according to the _DSD rule described in
    Documentation/acpi/DSD-properties-rules.txt, it doesn't break
    the rules.
    
    The DSDT is represented as below:
    
    For mbigen,
      Device(MBI0) {
              Name(_HID, "HISI0152")
              Name(_UID, Zero)
              Name(_CRS, ResourceTemplate() {
                      Memory32Fixed(ReadWrite, 0xa0080000, 0x10000)
              })
    
             Name(_DSD, Package () {
                     ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
                     Package () {
                             Package () {"num-pins", 378}
                     }
            })
     }
    
    For devices,
     Device(SAS0) {
             Name(_HID, "HISIxxxx")
             Name(_UID, Zero)
             Name(_CRS, ResourceTemplate() {
                     Memory32Fixed(ReadWrite, 0xb0030000, 0x10000)
                     Interrupt(ResourceConsumer,..., "\_SB.MBI0") {12, ...}
             })
     }
    
    So for the devices connected to the mbigen, as we clearly say that
    it refers to a specific interrupt controller (mbigen), we can get
    the virq from mbigen's irqdomain once it's created successfully.
    
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: MaJun <majun258@huawei.com>
    Cc: Al Stone <ahs3@redhat.com>
    Cc: Darren Hart <dvhart@infradead.org>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/irqchip/irq-mbigen.c b/drivers/irqchip/irq-mbigen.c
index 37564084ce84..061cdb8bde8b 100644
--- a/drivers/irqchip/irq-mbigen.c
+++ b/drivers/irqchip/irq-mbigen.c
@@ -16,6 +16,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include <linux/acpi.h>
 #include <linux/interrupt.h>
 #include <linux/irqchip.h>
 #include <linux/module.h>
@@ -180,7 +181,7 @@ static int mbigen_domain_translate(struct irq_domain *d,
 				    unsigned long *hwirq,
 				    unsigned int *type)
 {
-	if (is_of_node(fwspec->fwnode)) {
+	if (is_of_node(fwspec->fwnode) || is_acpi_device_node(fwspec->fwnode)) {
 		if (fwspec->param_count != 2)
 			return -EINVAL;
 
@@ -271,6 +272,58 @@ static int mbigen_of_create_domain(struct platform_device *pdev,
 	return 0;
 }
 
+#ifdef CONFIG_ACPI
+static int mbigen_acpi_create_domain(struct platform_device *pdev,
+				     struct mbigen_device *mgn_chip)
+{
+	struct irq_domain *domain;
+	u32 num_pins = 0;
+	int ret;
+
+	/*
+	 * "num-pins" is the total number of interrupt pins implemented in
+	 * this mbigen instance, and mbigen is an interrupt controller
+	 * connected to ITS  converting wired interrupts into MSI, so we
+	 * use "num-pins" to alloc MSI vectors which are needed by client
+	 * devices connected to it.
+	 *
+	 * Here is the DSDT device node used for mbigen in firmware:
+	 *	Device(MBI0) {
+	 *		Name(_HID, "HISI0152")
+	 *		Name(_UID, Zero)
+	 *		Name(_CRS, ResourceTemplate() {
+	 *			Memory32Fixed(ReadWrite, 0xa0080000, 0x10000)
+	 *		})
+	 *
+	 *		Name(_DSD, Package () {
+	 *			ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
+	 *			Package () {
+	 *				Package () {"num-pins", 378}
+	 *			}
+	 *		})
+	 *	}
+	 */
+	ret = device_property_read_u32(&pdev->dev, "num-pins", &num_pins);
+	if (ret || num_pins == 0)
+		return -EINVAL;
+
+	domain = platform_msi_create_device_domain(&pdev->dev, num_pins,
+						   mbigen_write_msg,
+						   &mbigen_domain_ops,
+						   mgn_chip);
+	if (!domain)
+		return -ENOMEM;
+
+	return 0;
+}
+#else
+static inline int mbigen_acpi_create_domain(struct platform_device *pdev,
+					    struct mbigen_device *mgn_chip)
+{
+	return -ENODEV;
+}
+#endif
+
 static int mbigen_device_probe(struct platform_device *pdev)
 {
 	struct mbigen_device *mgn_chip;
@@ -289,9 +342,18 @@ static int mbigen_device_probe(struct platform_device *pdev)
 	if (IS_ERR(mgn_chip->base))
 		return PTR_ERR(mgn_chip->base);
 
-	err = mbigen_of_create_domain(pdev, mgn_chip);
-	if (err)
+	if (IS_ENABLED(CONFIG_OF) && pdev->dev.of_node)
+		err = mbigen_of_create_domain(pdev, mgn_chip);
+	else if (ACPI_COMPANION(&pdev->dev))
+		err = mbigen_acpi_create_domain(pdev, mgn_chip);
+	else
+		err = -EINVAL;
+
+	if (err) {
+		dev_err(&pdev->dev, "Failed to create mbi-gen@%p irqdomain",
+			mgn_chip->base);
 		return err;
+	}
 
 	platform_set_drvdata(pdev, mgn_chip);
 	return 0;
@@ -303,10 +365,17 @@ static const struct of_device_id mbigen_of_match[] = {
 };
 MODULE_DEVICE_TABLE(of, mbigen_of_match);
 
+static const struct acpi_device_id mbigen_acpi_match[] = {
+	{ "HISI0152", 0 },
+	{}
+};
+MODULE_DEVICE_TABLE(acpi, mbigen_acpi_match);
+
 static struct platform_driver mbigen_platform_driver = {
 	.driver = {
 		.name		= "Hisilicon MBIGEN-V2",
 		.of_match_table	= mbigen_of_match,
+		.acpi_match_table = ACPI_PTR(mbigen_acpi_match),
 	},
 	.probe			= mbigen_device_probe,
 };

commit 76e1f77f9c26ec96ce58f46cc74ad07c731bd7ba
Author: Kefeng Wang <wangkefeng.wang@huawei.com>
Date:   Tue Mar 7 20:40:09 2017 +0800

    irqchip/mbigen: Introduce mbigen_of_create_domain()
    
    Introduce mbigen_of_create_domain() to consolidate OF related
    code and prepare for ACPI later, no funtional change.
    
    Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Reviewed-by: Ma Jun <majun258@huawei.com>
    Tested-by: Ming Lei <ming.lei@canonical.com>
    Tested-by: Wei Xu <xuwei5@hisilicon.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/irqchip/irq-mbigen.c b/drivers/irqchip/irq-mbigen.c
index c01ab4100f9a..37564084ce84 100644
--- a/drivers/irqchip/irq-mbigen.c
+++ b/drivers/irqchip/irq-mbigen.c
@@ -236,27 +236,15 @@ static struct irq_domain_ops mbigen_domain_ops = {
 	.free		= irq_domain_free_irqs_common,
 };
 
-static int mbigen_device_probe(struct platform_device *pdev)
+static int mbigen_of_create_domain(struct platform_device *pdev,
+				   struct mbigen_device *mgn_chip)
 {
-	struct mbigen_device *mgn_chip;
+	struct device *parent;
 	struct platform_device *child;
 	struct irq_domain *domain;
 	struct device_node *np;
-	struct device *parent;
-	struct resource *res;
 	u32 num_pins;
 
-	mgn_chip = devm_kzalloc(&pdev->dev, sizeof(*mgn_chip), GFP_KERNEL);
-	if (!mgn_chip)
-		return -ENOMEM;
-
-	mgn_chip->pdev = pdev;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	mgn_chip->base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(mgn_chip->base))
-		return PTR_ERR(mgn_chip->base);
-
 	for_each_child_of_node(pdev->dev.of_node, np) {
 		if (!of_property_read_bool(np, "interrupt-controller"))
 			continue;
@@ -280,6 +268,31 @@ static int mbigen_device_probe(struct platform_device *pdev)
 			return -ENOMEM;
 	}
 
+	return 0;
+}
+
+static int mbigen_device_probe(struct platform_device *pdev)
+{
+	struct mbigen_device *mgn_chip;
+	struct resource *res;
+	int err;
+
+	mgn_chip = devm_kzalloc(&pdev->dev, sizeof(*mgn_chip), GFP_KERNEL);
+	if (!mgn_chip)
+		return -ENOMEM;
+
+	mgn_chip->pdev = pdev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	mgn_chip->base = devm_ioremap(&pdev->dev, res->start,
+				      resource_size(res));
+	if (IS_ERR(mgn_chip->base))
+		return PTR_ERR(mgn_chip->base);
+
+	err = mbigen_of_create_domain(pdev, mgn_chip);
+	if (err)
+		return err;
+
 	platform_set_drvdata(pdev, mgn_chip);
 	return 0;
 }

commit 2911c6d961b35fceaf1fdede3c55e11dc3423be1
Author: Kefeng Wang <wangkefeng.wang@huawei.com>
Date:   Tue Mar 7 20:40:08 2017 +0800

    irqchip/mbigen: Drop module owner
    
    Module owner will be set by driver core, so drop it.
    
    Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Reviewed-by: Ma Jun <majun258@huawei.com>
    Tested-by: Ming Lei <ming.lei@canonical.com>
    Tested-by: Wei Xu <xuwei5@hisilicon.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/irqchip/irq-mbigen.c b/drivers/irqchip/irq-mbigen.c
index 03b79b061d24..c01ab4100f9a 100644
--- a/drivers/irqchip/irq-mbigen.c
+++ b/drivers/irqchip/irq-mbigen.c
@@ -293,7 +293,6 @@ MODULE_DEVICE_TABLE(of, mbigen_of_match);
 static struct platform_driver mbigen_platform_driver = {
 	.driver = {
 		.name		= "Hisilicon MBIGEN-V2",
-		.owner		= THIS_MODULE,
 		.of_match_table	= mbigen_of_match,
 	},
 	.probe			= mbigen_device_probe,

commit 086eec2de00ef5c1ac12ddb5a537289fbdc22689
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Mon Apr 4 14:17:36 2016 +0300

    irqchip/mbigen: Checking for IS_ERR() instead of NULL
    
    of_platform_device_create() returns NULL on error, it never returns
    error pointers.
    
    Fixes: ed2a1002d25c ('irqchip/mbigen: Handle multiple device nodes in a mbigen module')
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/irqchip/irq-mbigen.c b/drivers/irqchip/irq-mbigen.c
index d67baa231c13..03b79b061d24 100644
--- a/drivers/irqchip/irq-mbigen.c
+++ b/drivers/irqchip/irq-mbigen.c
@@ -263,8 +263,8 @@ static int mbigen_device_probe(struct platform_device *pdev)
 
 		parent = platform_bus_type.dev_root;
 		child = of_platform_device_create(np, NULL, parent);
-		if (IS_ERR(child))
-			return PTR_ERR(child);
+		if (!child)
+			return -ENOMEM;
 
 		if (of_property_read_u32(child->dev.of_node, "num-pins",
 					 &num_pins) < 0) {

commit ed2a1002d25ccdb6606c8ccb608524118bd30614
Author: MaJun <majun258@huawei.com>
Date:   Thu Mar 17 16:34:01 2016 +0800

    irqchip/mbigen: Handle multiple device nodes in a mbigen module
    
    Each mbigen device is represented as a independent platform device. If the
    devices belong to the same mbigen hardware module, then the register space for
    these devices is the same. That leads to a resource conflict.
    
    The solution for this is to represent the mbigen module as a platform device
    and make the mbigen devices subdevices of that. The register space is
    associated to the mbigen module and therefor the resource conflict is avoided.
    
    [ tglx: Massaged changelog, cleaned up the code and removed the silly printk ]
    
    Signed-off-by: Ma Jun <majun258@huawei.com>
    Cc: mark.rutland@arm.com
    Cc: jason@lakedaemon.net
    Cc: marc.zyngier@arm.com
    Cc: Catalin.Marinas@arm.com
    Cc: guohanjun@huawei.com
    Cc: Will.Deacon@arm.com
    Cc: huxinwei@huawei.com
    Cc: lizefan@huawei.com
    Cc: dingtianhong@huawei.com
    Cc: zhaojunhua@hisilicon.com
    Cc: liguozhu@hisilicon.com
    Cc: linux-arm-kernel@lists.infradead.org
    Link: http://lkml.kernel.org/r/1458203641-17172-3-git-send-email-majun258@huawei.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/irq-mbigen.c b/drivers/irqchip/irq-mbigen.c
index 4dd3eb8a40b3..d67baa231c13 100644
--- a/drivers/irqchip/irq-mbigen.c
+++ b/drivers/irqchip/irq-mbigen.c
@@ -239,8 +239,11 @@ static struct irq_domain_ops mbigen_domain_ops = {
 static int mbigen_device_probe(struct platform_device *pdev)
 {
 	struct mbigen_device *mgn_chip;
-	struct resource *res;
+	struct platform_device *child;
 	struct irq_domain *domain;
+	struct device_node *np;
+	struct device *parent;
+	struct resource *res;
 	u32 num_pins;
 
 	mgn_chip = devm_kzalloc(&pdev->dev, sizeof(*mgn_chip), GFP_KERNEL);
@@ -254,23 +257,30 @@ static int mbigen_device_probe(struct platform_device *pdev)
 	if (IS_ERR(mgn_chip->base))
 		return PTR_ERR(mgn_chip->base);
 
-	if (of_property_read_u32(pdev->dev.of_node, "num-pins", &num_pins) < 0) {
-		dev_err(&pdev->dev, "No num-pins property\n");
-		return -EINVAL;
-	}
+	for_each_child_of_node(pdev->dev.of_node, np) {
+		if (!of_property_read_bool(np, "interrupt-controller"))
+			continue;
 
-	domain = platform_msi_create_device_domain(&pdev->dev, num_pins,
-							mbigen_write_msg,
-							&mbigen_domain_ops,
-							mgn_chip);
+		parent = platform_bus_type.dev_root;
+		child = of_platform_device_create(np, NULL, parent);
+		if (IS_ERR(child))
+			return PTR_ERR(child);
 
-	if (!domain)
-		return -ENOMEM;
+		if (of_property_read_u32(child->dev.of_node, "num-pins",
+					 &num_pins) < 0) {
+			dev_err(&pdev->dev, "No num-pins property\n");
+			return -EINVAL;
+		}
+
+		domain = platform_msi_create_device_domain(&child->dev, num_pins,
+							   mbigen_write_msg,
+							   &mbigen_domain_ops,
+							   mgn_chip);
+		if (!domain)
+			return -ENOMEM;
+	}
 
 	platform_set_drvdata(pdev, mgn_chip);
-
-	dev_info(&pdev->dev, "Allocated %d MSIs\n", num_pins);
-
 	return 0;
 }
 

commit a6c2f87b8820e956ea0f731dcf0e45949bb37a8b
Author: Ma Jun <majun258@huawei.com>
Date:   Thu Dec 17 19:56:37 2015 +0800

    irqchip/mbigen: Implement the mbigen irq chip operation functions
    
    Add the interrupt controller chip operation functions of mbigen chip.
    
    Signed-off-by: Ma Jun <majun258@huawei.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/irqchip/irq-mbigen.c b/drivers/irqchip/irq-mbigen.c
index 2ab1c2d7232c..4dd3eb8a40b3 100644
--- a/drivers/irqchip/irq-mbigen.c
+++ b/drivers/irqchip/irq-mbigen.c
@@ -49,6 +49,20 @@
 /* offset of vector register in mbigen node */
 #define REG_MBIGEN_VEC_OFFSET		0x200
 
+/**
+ * offset of clear register in mbigen node
+ * This register is used to clear the status
+ * of interrupt
+ */
+#define REG_MBIGEN_CLEAR_OFFSET		0xa000
+
+/**
+ * offset of interrupt type register
+ * This register is used to configure interrupt
+ * trigger type
+ */
+#define REG_MBIGEN_TYPE_OFFSET		0x0
+
 /**
  * struct mbigen_device - holds the information of mbigen device.
  *
@@ -72,8 +86,75 @@ static inline unsigned int get_mbigen_vec_reg(irq_hw_number_t hwirq)
 			+ REG_MBIGEN_VEC_OFFSET;
 }
 
+static inline void get_mbigen_type_reg(irq_hw_number_t hwirq,
+					u32 *mask, u32 *addr)
+{
+	unsigned int nid, irq_ofst, ofst;
+
+	hwirq -= RESERVED_IRQ_PER_MBIGEN_CHIP;
+	nid = hwirq / IRQS_PER_MBIGEN_NODE + 1;
+	irq_ofst = hwirq % IRQS_PER_MBIGEN_NODE;
+
+	*mask = 1 << (irq_ofst % 32);
+	ofst = irq_ofst / 32 * 4;
+
+	*addr = ofst + nid * MBIGEN_NODE_OFFSET
+		+ REG_MBIGEN_TYPE_OFFSET;
+}
+
+static inline void get_mbigen_clear_reg(irq_hw_number_t hwirq,
+					u32 *mask, u32 *addr)
+{
+	unsigned int ofst;
+
+	hwirq -= RESERVED_IRQ_PER_MBIGEN_CHIP;
+	ofst = hwirq / 32 * 4;
+
+	*mask = 1 << (hwirq % 32);
+	*addr = ofst + REG_MBIGEN_CLEAR_OFFSET;
+}
+
+static void mbigen_eoi_irq(struct irq_data *data)
+{
+	void __iomem *base = data->chip_data;
+	u32 mask, addr;
+
+	get_mbigen_clear_reg(data->hwirq, &mask, &addr);
+
+	writel_relaxed(mask, base + addr);
+
+	irq_chip_eoi_parent(data);
+}
+
+static int mbigen_set_type(struct irq_data *data, unsigned int type)
+{
+	void __iomem *base = data->chip_data;
+	u32 mask, addr, val;
+
+	if (type != IRQ_TYPE_LEVEL_HIGH && type != IRQ_TYPE_EDGE_RISING)
+		return -EINVAL;
+
+	get_mbigen_type_reg(data->hwirq, &mask, &addr);
+
+	val = readl_relaxed(base + addr);
+
+	if (type == IRQ_TYPE_LEVEL_HIGH)
+		val |= mask;
+	else
+		val &= ~mask;
+
+	writel_relaxed(val, base + addr);
+
+	return 0;
+}
+
 static struct irq_chip mbigen_irq_chip = {
 	.name =			"mbigen-v2",
+	.irq_mask =		irq_chip_mask_parent,
+	.irq_unmask =		irq_chip_unmask_parent,
+	.irq_eoi =		mbigen_eoi_irq,
+	.irq_set_type =		mbigen_set_type,
+	.irq_set_affinity =	irq_chip_set_affinity_parent,
 };
 
 static void mbigen_write_msg(struct msi_desc *desc, struct msi_msg *msg)

commit 9650c60ebfec05fcf74d9b3eb97837501f2bb541
Author: Ma Jun <majun258@huawei.com>
Date:   Thu Dec 17 19:56:36 2015 +0800

    irqchip/mbigen: Create irq domain for each mbigen device
    
    For peripheral devices which connect to mbigen,mbigen is a interrupt
    controller. So, we create irq domain for each mbigen device and add
    mbigen irq domain into irq hierarchy structure.
    
    Signed-off-by: Ma Jun <majun258@huawei.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/irqchip/irq-mbigen.c b/drivers/irqchip/irq-mbigen.c
index 9f036c22f9b2..2ab1c2d7232c 100644
--- a/drivers/irqchip/irq-mbigen.c
+++ b/drivers/irqchip/irq-mbigen.c
@@ -16,13 +16,39 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include <linux/interrupt.h>
+#include <linux/irqchip.h>
 #include <linux/module.h>
+#include <linux/msi.h>
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
 #include <linux/of_platform.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 
+/* Interrupt numbers per mbigen node supported */
+#define IRQS_PER_MBIGEN_NODE		128
+
+/* 64 irqs (Pin0-pin63) are reserved for each mbigen chip */
+#define RESERVED_IRQ_PER_MBIGEN_CHIP	64
+
+/* The maximum IRQ pin number of mbigen chip(start from 0) */
+#define MAXIMUM_IRQ_PIN_NUM		1407
+
+/**
+ * In mbigen vector register
+ * bit[21:12]:	event id value
+ * bit[11:0]:	device id
+ */
+#define IRQ_EVENT_ID_SHIFT		12
+#define IRQ_EVENT_ID_MASK		0x3ff
+
+/* register range of each mbigen node */
+#define MBIGEN_NODE_OFFSET		0x1000
+
+/* offset of vector register in mbigen node */
+#define REG_MBIGEN_VEC_OFFSET		0x200
+
 /**
  * struct mbigen_device - holds the information of mbigen device.
  *
@@ -34,10 +60,107 @@ struct mbigen_device {
 	void __iomem		*base;
 };
 
+static inline unsigned int get_mbigen_vec_reg(irq_hw_number_t hwirq)
+{
+	unsigned int nid, pin;
+
+	hwirq -= RESERVED_IRQ_PER_MBIGEN_CHIP;
+	nid = hwirq / IRQS_PER_MBIGEN_NODE + 1;
+	pin = hwirq % IRQS_PER_MBIGEN_NODE;
+
+	return pin * 4 + nid * MBIGEN_NODE_OFFSET
+			+ REG_MBIGEN_VEC_OFFSET;
+}
+
+static struct irq_chip mbigen_irq_chip = {
+	.name =			"mbigen-v2",
+};
+
+static void mbigen_write_msg(struct msi_desc *desc, struct msi_msg *msg)
+{
+	struct irq_data *d = irq_get_irq_data(desc->irq);
+	void __iomem *base = d->chip_data;
+	u32 val;
+
+	base += get_mbigen_vec_reg(d->hwirq);
+	val = readl_relaxed(base);
+
+	val &= ~(IRQ_EVENT_ID_MASK << IRQ_EVENT_ID_SHIFT);
+	val |= (msg->data << IRQ_EVENT_ID_SHIFT);
+
+	/* The address of doorbell is encoded in mbigen register by default
+	 * So,we don't need to program the doorbell address at here
+	 */
+	writel_relaxed(val, base);
+}
+
+static int mbigen_domain_translate(struct irq_domain *d,
+				    struct irq_fwspec *fwspec,
+				    unsigned long *hwirq,
+				    unsigned int *type)
+{
+	if (is_of_node(fwspec->fwnode)) {
+		if (fwspec->param_count != 2)
+			return -EINVAL;
+
+		if ((fwspec->param[0] > MAXIMUM_IRQ_PIN_NUM) ||
+			(fwspec->param[0] < RESERVED_IRQ_PER_MBIGEN_CHIP))
+			return -EINVAL;
+		else
+			*hwirq = fwspec->param[0];
+
+		/* If there is no valid irq type, just use the default type */
+		if ((fwspec->param[1] == IRQ_TYPE_EDGE_RISING) ||
+			(fwspec->param[1] == IRQ_TYPE_LEVEL_HIGH))
+			*type = fwspec->param[1];
+		else
+			return -EINVAL;
+
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static int mbigen_irq_domain_alloc(struct irq_domain *domain,
+					unsigned int virq,
+					unsigned int nr_irqs,
+					void *args)
+{
+	struct irq_fwspec *fwspec = args;
+	irq_hw_number_t hwirq;
+	unsigned int type;
+	struct mbigen_device *mgn_chip;
+	int i, err;
+
+	err = mbigen_domain_translate(domain, fwspec, &hwirq, &type);
+	if (err)
+		return err;
+
+	err = platform_msi_domain_alloc(domain, virq, nr_irqs);
+	if (err)
+		return err;
+
+	mgn_chip = platform_msi_get_host_data(domain);
+
+	for (i = 0; i < nr_irqs; i++)
+		irq_domain_set_hwirq_and_chip(domain, virq + i, hwirq + i,
+				      &mbigen_irq_chip, mgn_chip->base);
+
+	return 0;
+}
+
+static struct irq_domain_ops mbigen_domain_ops = {
+	.translate	= mbigen_domain_translate,
+	.alloc		= mbigen_irq_domain_alloc,
+	.free		= irq_domain_free_irqs_common,
+};
+
 static int mbigen_device_probe(struct platform_device *pdev)
 {
 	struct mbigen_device *mgn_chip;
 	struct resource *res;
+	struct irq_domain *domain;
+	u32 num_pins;
 
 	mgn_chip = devm_kzalloc(&pdev->dev, sizeof(*mgn_chip), GFP_KERNEL);
 	if (!mgn_chip)
@@ -50,8 +173,23 @@ static int mbigen_device_probe(struct platform_device *pdev)
 	if (IS_ERR(mgn_chip->base))
 		return PTR_ERR(mgn_chip->base);
 
+	if (of_property_read_u32(pdev->dev.of_node, "num-pins", &num_pins) < 0) {
+		dev_err(&pdev->dev, "No num-pins property\n");
+		return -EINVAL;
+	}
+
+	domain = platform_msi_create_device_domain(&pdev->dev, num_pins,
+							mbigen_write_msg,
+							&mbigen_domain_ops,
+							mgn_chip);
+
+	if (!domain)
+		return -ENOMEM;
+
 	platform_set_drvdata(pdev, mgn_chip);
 
+	dev_info(&pdev->dev, "Allocated %d MSIs\n", num_pins);
+
 	return 0;
 }
 

commit 717c3dbc118ecbbd5dab06c7e02dac68d3f62e1d
Author: Ma Jun <majun258@huawei.com>
Date:   Thu Dec 17 19:56:35 2015 +0800

    irqchip/mgigen: Add platform device driver for mbigen device
    
    Mbigen means Message Based Interrupt Generator(MBIGEN).
    
    Its a kind of interrupt controller that collects
    the interrupts from external devices and generate msi interrupt.
    Mbigen is applied to reduce the number of wire connected interrupts.
    
    As the peripherals increasing, the interrupts lines needed is
    increasing much, especially on the Arm64 server SOC.
    
    Therefore, the interrupt pin in GIC is not enough to cover so
    many peripherals.
    
    Mbigen is designed to fix this problem.
    
    Mbigen chip locates in ITS or outside of ITS.
    
    Mbigen chip hardware structure shows as below:
    
                    mbigen chip
    |---------------------|-------------------|
    mgn_node0         mgn_node1             mgn_node2
     |               |-------|              |-------|------|
    dev1            dev1    dev2            dev1   dev3   dev4
    
    Each mbigen chip contains several mbigen nodes.
    
    External devices can connect to mbigen node through wire connecting way.
    
    Because a mbigen node only can support 128 interrupt maximum, depends
    on the interrupt lines number of devices, a device can connects to one
    more mbigen nodes.
    
    Also, several different devices can connect to a same mbigen node.
    
    When devices triggered interrupt,mbigen chip detects and collects
    the interrupts and generates the MBI interrupts by writing the ITS
    Translator register.
    
    To simplify mbigen driver,I used a new conception--mbigen device.
    Each mbigen device is initialized as a platform device.
    
    Mbigen device presents the parts(register, pin definition etc.) in
    mbigen chip corresponding to a peripheral device.
    
    So from software view, the structure likes below
    
                        mbigen chip
         |---------------------|-----------------|
    mbigen device1       mbigen device2  mbigen device3
          |                   |                |
         dev1                dev2             dev3
    
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Ma Jun <majun258@huawei.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/irqchip/irq-mbigen.c b/drivers/irqchip/irq-mbigen.c
new file mode 100644
index 000000000000..9f036c22f9b2
--- /dev/null
+++ b/drivers/irqchip/irq-mbigen.c
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2015 Hisilicon Limited, All Rights Reserved.
+ * Author: Jun Ma <majun258@huawei.com>
+ * Author: Yun Wu <wuyun.wu@huawei.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+/**
+ * struct mbigen_device - holds the information of mbigen device.
+ *
+ * @pdev:		pointer to the platform device structure of mbigen chip.
+ * @base:		mapped address of this mbigen chip.
+ */
+struct mbigen_device {
+	struct platform_device	*pdev;
+	void __iomem		*base;
+};
+
+static int mbigen_device_probe(struct platform_device *pdev)
+{
+	struct mbigen_device *mgn_chip;
+	struct resource *res;
+
+	mgn_chip = devm_kzalloc(&pdev->dev, sizeof(*mgn_chip), GFP_KERNEL);
+	if (!mgn_chip)
+		return -ENOMEM;
+
+	mgn_chip->pdev = pdev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	mgn_chip->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(mgn_chip->base))
+		return PTR_ERR(mgn_chip->base);
+
+	platform_set_drvdata(pdev, mgn_chip);
+
+	return 0;
+}
+
+static const struct of_device_id mbigen_of_match[] = {
+	{ .compatible = "hisilicon,mbigen-v2" },
+	{ /* END */ }
+};
+MODULE_DEVICE_TABLE(of, mbigen_of_match);
+
+static struct platform_driver mbigen_platform_driver = {
+	.driver = {
+		.name		= "Hisilicon MBIGEN-V2",
+		.owner		= THIS_MODULE,
+		.of_match_table	= mbigen_of_match,
+	},
+	.probe			= mbigen_device_probe,
+};
+
+module_platform_driver(mbigen_platform_driver);
+
+MODULE_AUTHOR("Jun Ma <majun258@huawei.com>");
+MODULE_AUTHOR("Yun Wu <wuyun.wu@huawei.com>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Hisilicon MBI Generator driver");
