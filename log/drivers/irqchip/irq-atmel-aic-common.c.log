commit 0a46230bf03549435156b36dee9e7489b8270be7
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Tue Jul 4 11:10:41 2017 +0200

    irqchip/atmel-aic: Remove root argument from ->fixup() prototype
    
    We are no longer using the root argument passed to the ->fixup() hooks.
    Remove it.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/irqchip/irq-atmel-aic-common.c b/drivers/irqchip/irq-atmel-aic-common.c
index 056507099725..072bd227b6c6 100644
--- a/drivers/irqchip/irq-atmel-aic-common.c
+++ b/drivers/irqchip/irq-atmel-aic-common.c
@@ -137,7 +137,7 @@ static void __init aic_common_ext_irq_of_init(struct irq_domain *domain)
 #define AT91_RTC_IMR           0x28
 #define AT91_RTC_IRQ_MASK      0x1f
 
-void __init aic_common_rtc_irq_fixup(struct device_node *root)
+void __init aic_common_rtc_irq_fixup(void)
 {
 	struct device_node *np;
 	void __iomem *regs;
@@ -165,7 +165,7 @@ void __init aic_common_rtc_irq_fixup(struct device_node *root)
 #define AT91_RTT_ALMIEN		(1 << 16)		/* Alarm Interrupt Enable */
 #define AT91_RTT_RTTINCIEN	(1 << 17)		/* Real Time Timer Increment Interrupt Enable */
 
-void __init aic_common_rtt_irq_fixup(struct device_node *root)
+void __init aic_common_rtt_irq_fixup(void)
 {
 	struct device_node *np;
 	void __iomem *regs;
@@ -198,8 +198,8 @@ static void __init aic_common_irq_fixup(const struct of_device_id *matches)
 	match = of_match_node(matches, root);
 
 	if (match) {
-		void (*fixup)(struct device_node *) = match->data;
-		fixup(root);
+		void (*fixup)(void) = match->data;
+		fixup();
 	}
 
 	of_node_put(root);

commit 277867ade8262583f4280cadbe90e0031a3706a7
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Tue Jul 4 11:10:40 2017 +0200

    irqchip/atmel-aic: Fix unbalanced refcount in aic_common_rtc_irq_fixup()
    
    of_find_compatible_node() is calling of_node_put() on its first argument
    thus leading to an unbalanced of_node_get/put() issue if the node has not
    been retained before that.
    
    Instead of passing the root node, pass NULL, which does exactly the same:
    iterate over all DT nodes, starting from the root node.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Reported-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Fixes: 3d61467f9bab ("irqchip: atmel-aic: Implement RTC irq fixup")
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/irqchip/irq-atmel-aic-common.c b/drivers/irqchip/irq-atmel-aic-common.c
index 7c5a43488d27..056507099725 100644
--- a/drivers/irqchip/irq-atmel-aic-common.c
+++ b/drivers/irqchip/irq-atmel-aic-common.c
@@ -142,9 +142,9 @@ void __init aic_common_rtc_irq_fixup(struct device_node *root)
 	struct device_node *np;
 	void __iomem *regs;
 
-	np = of_find_compatible_node(root, NULL, "atmel,at91rm9200-rtc");
+	np = of_find_compatible_node(NULL, NULL, "atmel,at91rm9200-rtc");
 	if (!np)
-		np = of_find_compatible_node(root, NULL,
+		np = of_find_compatible_node(NULL, NULL,
 					     "atmel,at91sam9x5-rtc");
 
 	if (!np)

commit 469bcef53c546bb792aa66303933272991b7831d
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Tue Jul 4 11:10:39 2017 +0200

    irqchip/atmel-aic: Fix unbalanced of_node_put() in aic_common_irq_fixup()
    
    aic_common_irq_fixup() is calling twice of_node_put() on the same node
    thus leading to an unbalanced refcount on the root node.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Reported-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Fixes: b2f579b58e93 ("irqchip: atmel-aic: Add irq fixup infrastructure")
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/irqchip/irq-atmel-aic-common.c b/drivers/irqchip/irq-atmel-aic-common.c
index 28b26c80f4cf..7c5a43488d27 100644
--- a/drivers/irqchip/irq-atmel-aic-common.c
+++ b/drivers/irqchip/irq-atmel-aic-common.c
@@ -196,7 +196,6 @@ static void __init aic_common_irq_fixup(const struct of_device_id *matches)
 		return;
 
 	match = of_match_node(matches, root);
-	of_node_put(root);
 
 	if (match) {
 		void (*fixup)(struct device_node *) = match->data;

commit 5fd26a0bb1e479014adf024df779172d33defdd5
Author: Milo Kim <milo.kim@ti.com>
Date:   Wed Jan 13 16:19:51 2016 +0900

    irqchip/atmel-aic: Change return type of aic_common_set_priority()
    
    Priority validation is not necessary because aic_common_irq_domain_xlate()
    already handles it. With this removal, return type can be changed to void.
    
    Signed-off-by: Milo Kim <milo.kim@ti.com>
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Ludovic Desroches <ludovic.desroches@atmel.com>
    Cc: Nicholas Ferre <nicolas.ferre@atmel.com>
    Link: http://lkml.kernel.org/r/1452669592-3401-3-git-send-email-milo.kim@ti.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/irq-atmel-aic-common.c b/drivers/irqchip/irq-atmel-aic-common.c
index 661840b5d553..28b26c80f4cf 100644
--- a/drivers/irqchip/irq-atmel-aic-common.c
+++ b/drivers/irqchip/irq-atmel-aic-common.c
@@ -80,16 +80,10 @@ int aic_common_set_type(struct irq_data *d, unsigned type, unsigned *val)
 	return 0;
 }
 
-int aic_common_set_priority(int priority, unsigned *val)
+void aic_common_set_priority(int priority, unsigned *val)
 {
-	if (priority < AT91_AIC_IRQ_MIN_PRIORITY ||
-	    priority > AT91_AIC_IRQ_MAX_PRIORITY)
-		return -EINVAL;
-
 	*val &= ~AT91_AIC_PRIOR;
 	*val |= priority;
-
-	return 0;
 }
 
 int aic_common_irq_domain_xlate(struct irq_domain *d,

commit dd85c79150079339b3ded62dda5f6985d192900a
Author: Milo Kim <milo.kim@ti.com>
Date:   Wed Jan 13 16:19:49 2016 +0900

    irqchip/atmel-aic: Handle aic_common_irq_fixup in aic_common_of_init
    
    AIC IRQ fixup is handled in each IRQ chip driver.
    It can be moved into aic_common_of_init() before returning the result.
    Then, aic_common_irq_fixup() can be changed to static type.
    
    Signed-off-by: Milo Kim <milo.kim@ti.com>
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Ludovic Desroches <ludovic.desroches@atmel.com>
    Cc: Nicholas Ferre <nicolas.ferre@atmel.com>
    Link: http://lkml.kernel.org/r/1452669592-3401-1-git-send-email-milo.kim@ti.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/irq-atmel-aic-common.c b/drivers/irqchip/irq-atmel-aic-common.c
index 37199b9b2cfa..661840b5d553 100644
--- a/drivers/irqchip/irq-atmel-aic-common.c
+++ b/drivers/irqchip/irq-atmel-aic-common.c
@@ -193,7 +193,7 @@ void __init aic_common_rtt_irq_fixup(struct device_node *root)
 	}
 }
 
-void __init aic_common_irq_fixup(const struct of_device_id *matches)
+static void __init aic_common_irq_fixup(const struct of_device_id *matches)
 {
 	struct device_node *root = of_find_node_by_path("/");
 	const struct of_device_id *match;
@@ -214,7 +214,8 @@ void __init aic_common_irq_fixup(const struct of_device_id *matches)
 
 struct irq_domain *__init aic_common_of_init(struct device_node *node,
 					     const struct irq_domain_ops *ops,
-					     const char *name, int nirqs)
+					     const char *name, int nirqs,
+					     const struct of_device_id *matches)
 {
 	struct irq_chip_generic *gc;
 	struct irq_domain *domain;
@@ -264,6 +265,7 @@ struct irq_domain *__init aic_common_of_init(struct device_node *node,
 	}
 
 	aic_common_ext_irq_of_init(domain);
+	aic_common_irq_fixup(matches);
 
 	return domain;
 

commit 49f34134aea74f19ca016f055d25ee55ec359dee
Author: Milo Kim <milo.kim@ti.com>
Date:   Wed Jan 13 16:19:50 2016 +0900

    irqchip/atmel-aic: Fix wrong bit operation for IRQ priority
    
    Atmel AIC has common structure for SMR (Source Mode Register).
    
      bit[6:5] Interrupt source type
      bit[2:0] Priority level
      Other bits are unused.
    
    To update new priority value, bit[2:0] should be cleared first and then
    new priority level can be written. However, aic_common_set_priority()
    helper clears source type bits instead of priority bits.
    This patch fixes wrong mask bit operation.
    
    Fixes: b1479ebb7720 "irqchip: atmel-aic: Add atmel AIC/AIC5 drivers"
    Signed-off-by: Milo Kim <milo.kim@ti.com>
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Ludovic Desroches <ludovic.desroches@atmel.com>
    Cc: Nicholas Ferre <nicolas.ferre@atmel.com>
    Cc: stable@vger.kernel.org #v3.17+
    Link: http://lkml.kernel.org/r/1452669592-3401-2-git-send-email-milo.kim@ti.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/irq-atmel-aic-common.c b/drivers/irqchip/irq-atmel-aic-common.c
index b12a5d58546f..37199b9b2cfa 100644
--- a/drivers/irqchip/irq-atmel-aic-common.c
+++ b/drivers/irqchip/irq-atmel-aic-common.c
@@ -86,7 +86,7 @@ int aic_common_set_priority(int priority, unsigned *val)
 	    priority > AT91_AIC_IRQ_MAX_PRIORITY)
 		return -EINVAL;
 
-	*val &= AT91_AIC_PRIOR;
+	*val &= ~AT91_AIC_PRIOR;
 	*val |= priority;
 
 	return 0;

commit 5d4c9bc7767bc86eb9a0e66df783e3fbada7dc97
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Oct 13 12:51:29 2015 +0100

    irqdomain: Use irq_domain_get_of_node() instead of direct field access
    
    The struct irq_domain contains a "struct device_node *" field
    (of_node) that is almost the only link between the irqdomain
    and the device tree infrastructure.
    
    In order to prepare for the removal of that field, convert all
    users to use irq_domain_get_of_node() instead.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-and-tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Cc: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Cc: Graeme Gregory <graeme@xora.org.uk>
    Cc: Jake Oshins <jakeo@microsoft.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Link: http://lkml.kernel.org/r/1444737105-31573-2-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/irq-atmel-aic-common.c b/drivers/irqchip/irq-atmel-aic-common.c
index 63cd031b2c28..b12a5d58546f 100644
--- a/drivers/irqchip/irq-atmel-aic-common.c
+++ b/drivers/irqchip/irq-atmel-aic-common.c
@@ -114,7 +114,7 @@ int aic_common_irq_domain_xlate(struct irq_domain *d,
 
 static void __init aic_common_ext_irq_of_init(struct irq_domain *domain)
 {
-	struct device_node *node = domain->of_node;
+	struct device_node *node = irq_domain_get_of_node(domain);
 	struct irq_chip_generic *gc;
 	struct aic_chip_data *aic;
 	struct property *prop;

commit 91d1179212161f220938198b742c328ad38fd0a3
Author: Gavin Li <git@thegavinli.com>
Date:   Tue Jan 6 18:47:23 2015 -0800

    irqchip: atmel-aic-common: Prevent clobbering of priority when changing IRQ type
    
    This patch makes the bitmask for AIC_SRCTYPE consistent
    with that of its valid values, and prevents the priority
    field at bits 2:0 from being clobbered by an incorrect
    AND with the AIC_SRCTYPE mask.
    
    Signed-off-by: Gavin Li <gavinli@thegavinli.com>
    Cc: <stable@vger.kernel.org> # v3.17+
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Link: https://lkml.kernel.org/r/1420598843-8409-1-git-send-email-gavinli@thegavinli.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/irq-atmel-aic-common.c b/drivers/irqchip/irq-atmel-aic-common.c
index d111ac779c40..63cd031b2c28 100644
--- a/drivers/irqchip/irq-atmel-aic-common.c
+++ b/drivers/irqchip/irq-atmel-aic-common.c
@@ -28,7 +28,7 @@
 #define AT91_AIC_IRQ_MIN_PRIORITY	0
 #define AT91_AIC_IRQ_MAX_PRIORITY	7
 
-#define AT91_AIC_SRCTYPE		GENMASK(7, 6)
+#define AT91_AIC_SRCTYPE		GENMASK(6, 5)
 #define AT91_AIC_SRCTYPE_LOW		(0 << 5)
 #define AT91_AIC_SRCTYPE_FALLING	(1 << 5)
 #define AT91_AIC_SRCTYPE_HIGH		(2 << 5)
@@ -74,7 +74,7 @@ int aic_common_set_type(struct irq_data *d, unsigned type, unsigned *val)
 		return -EINVAL;
 	}
 
-	*val &= AT91_AIC_SRCTYPE;
+	*val &= ~AT91_AIC_SRCTYPE;
 	*val |= aic_type;
 
 	return 0;

commit ecb50f0afd35a51ef487e8a54b976052eb03d729
Merge: a157508c9790 1655b0530d95
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 10 08:38:57 2014 -0800

    Merge branch 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull irq core updates from Thomas Gleixner:
     "This is the first (boring) part of irq updates:
    
       - support for big endian I/O accessors in the generic irq chip
    
       - cleanup of brcmstb/bcm7120 drivers so they can be reused for non
         ARM SoCs
    
       - the usual pile of fixes and updates for the various ARM irq chips"
    
    * 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (25 commits)
      irqchip: dw-apb-ictl: Add PM support
      irqchip: dw-apb-ictl: Enable IRQ_GC_MASK_CACHE_PER_TYPE
      irqchip: dw-apb-ictl: Always use use {readl|writel}_relaxed
      ARM: orion: convert the irq_reg_{readl,writel} calls to the new API
      irqchip: atmel-aic: Add missing entry for rm9200 irq fixups
      irqchip: atmel-aic: Rename at91sam9_aic_irq_fixup for naming consistency
      irqchip: atmel-aic: Add specific irq fixup function for sam9g45 and sam9rl
      irqchip: atmel-aic: Add irq fixups for at91sam926x SoCs
      irqchip: atmel-aic: Add irq fixup for RTT block
      irqchip: brcmstb-l2: Convert driver to use irq_reg_{readl,writel}
      irqchip: bcm7120-l2: Convert driver to use irq_reg_{readl,writel}
      irqchip: bcm7120-l2: Decouple driver from brcmstb-l2
      irqchip: bcm7120-l2: Extend driver to support 64+ bit controllers
      irqchip: bcm7120-l2: Use gc->mask_cache to simplify suspend/resume functions
      irqchip: bcm7120-l2: Fix missing nibble in gc->unused mask
      irqchip: bcm7120-l2: Make sure all register accesses use base+offset
      irqchip: bcm7120-l2, brcmstb-l2: Remove ARM Kconfig dependency
      irqchip: bcm7120-l2: Eliminate bad IRQ check
      irqchip: brcmstb-l2: Eliminate dependency on ARM code
      genirq: Generic chip: Add big endian I/O accessors
      ...

commit 45977fe35bf014f5cf9552717e1320783398ae0d
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Tue Nov 11 14:33:36 2014 +0100

    irqchip: atmel-aic: Fix irqdomain initialization
    
    First of all IRQCHIP_SKIP_SET_WAKE is not a valid irq_gc_flags and thus
    should not be passed as the last argument of
    irq_alloc_domain_generic_chips.
    
    Then pass the correct handler (handle_fasteoi_irq) to
    irq_alloc_domain_generic_chips instead of manually re-setting it in the
    initialization loop.
    
    And eventually initialize default irq flags to the pseudo standard:
    IRQ_REQUEST | IRQ_PROBE | IRQ_AUTOEN.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Tested-by: Kevin Hilman <khilman@linaro.org>
    Fixes: b1479ebb77200 ("irqchip: atmel-aic: Add atmel AIC/AIC5 drivers")
    Cc: <stable@vger.kernel.org> # v3.17+
    Link: https://lkml.kernel.org/r/1415712816-9202-1-git-send-email-boris.brezillon@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/irq-atmel-aic-common.c b/drivers/irqchip/irq-atmel-aic-common.c
index 6ae3cdee0681..cc4f9d80122e 100644
--- a/drivers/irqchip/irq-atmel-aic-common.c
+++ b/drivers/irqchip/irq-atmel-aic-common.c
@@ -217,8 +217,9 @@ struct irq_domain *__init aic_common_of_init(struct device_node *node,
 	}
 
 	ret = irq_alloc_domain_generic_chips(domain, 32, 1, name,
-					     handle_level_irq, 0, 0,
-					     IRQCHIP_SKIP_SET_WAKE);
+					     handle_fasteoi_irq,
+					     IRQ_NOREQUEST | IRQ_NOPROBE |
+					     IRQ_NOAUTOEN, 0, 0);
 	if (ret)
 		goto err_domain_remove;
 
@@ -230,7 +231,6 @@ struct irq_domain *__init aic_common_of_init(struct device_node *node,
 		gc->unused = 0;
 		gc->wake_enabled = ~0;
 		gc->chip_types[0].type = IRQ_TYPE_SENSE_MASK;
-		gc->chip_types[0].handler = handle_fasteoi_irq;
 		gc->chip_types[0].chip.irq_eoi = irq_gc_eoi;
 		gc->chip_types[0].chip.irq_set_wake = irq_gc_set_wake;
 		gc->chip_types[0].chip.irq_shutdown = aic_common_shutdown;

commit 4185315a9ad3d2ae0ee2fdb7e8f2f75a3f3c5e66
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Mon Nov 3 09:31:00 2014 +0100

    irqchip: atmel-aic: Add irq fixup for RTT block
    
    Signed-off-by: Boris BREZILLON <boris.brezillon@free-electrons.com>
    Link: https://lkml.kernel.org/r/1415003464-29239-2-git-send-email-boris.brezillon@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/irq-atmel-aic-common.c b/drivers/irqchip/irq-atmel-aic-common.c
index 6ae3cdee0681..656cfe336837 100644
--- a/drivers/irqchip/irq-atmel-aic-common.c
+++ b/drivers/irqchip/irq-atmel-aic-common.c
@@ -167,6 +167,32 @@ void __init aic_common_rtc_irq_fixup(struct device_node *root)
 	iounmap(regs);
 }
 
+#define AT91_RTT_MR		0x00			/* Real-time Mode Register */
+#define AT91_RTT_ALMIEN		(1 << 16)		/* Alarm Interrupt Enable */
+#define AT91_RTT_RTTINCIEN	(1 << 17)		/* Real Time Timer Increment Interrupt Enable */
+
+void __init aic_common_rtt_irq_fixup(struct device_node *root)
+{
+	struct device_node *np;
+	void __iomem *regs;
+
+	/*
+	 * The at91sam9263 SoC has 2 instances of the RTT block, hence we
+	 * iterate over the DT to find each occurrence.
+	 */
+	for_each_compatible_node(np, NULL, "atmel,at91sam9260-rtt") {
+		regs = of_iomap(np, 0);
+		if (!regs)
+			continue;
+
+		writel(readl(regs + AT91_RTT_MR) &
+		       ~(AT91_RTT_ALMIEN | AT91_RTT_RTTINCIEN),
+		       regs + AT91_RTT_MR);
+
+		iounmap(regs);
+	}
+}
+
 void __init aic_common_irq_fixup(const struct of_device_id *matches)
 {
 	struct device_node *root = of_find_node_by_path("/");

commit 3d61467f9bab36aee786f762730b73565dbef3bf
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Thu Jul 10 20:25:40 2014 +0200

    irqchip: atmel-aic: Implement RTC irq fixup
    
    Provide an implementation to fix RTC irqs before enabling the irqchip.
    
    This was previously done in arch/arm/mach-at91/sysirq_mask.c but as we're
    trying to use standard implementation (IRQCHIP_DECLARE and automatic call
    of irqchip_init within arch/arm/kernel/irq.c) we need to do those fixups
    in the irqchip driver.
    
    Signed-off-by: Boris BREZILLON <boris.brezillon@free-electrons.com>
    Link: https://lkml.kernel.org/r/1405016741-2407-3-git-send-email-boris.brezillon@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/irq-atmel-aic-common.c b/drivers/irqchip/irq-atmel-aic-common.c
index 4705bdbc6e7b..6ae3cdee0681 100644
--- a/drivers/irqchip/irq-atmel-aic-common.c
+++ b/drivers/irqchip/irq-atmel-aic-common.c
@@ -139,6 +139,34 @@ static void __init aic_common_ext_irq_of_init(struct irq_domain *domain)
 	}
 }
 
+#define AT91_RTC_IDR           0x24
+#define AT91_RTC_IMR           0x28
+#define AT91_RTC_IRQ_MASK      0x1f
+
+void __init aic_common_rtc_irq_fixup(struct device_node *root)
+{
+	struct device_node *np;
+	void __iomem *regs;
+
+	np = of_find_compatible_node(root, NULL, "atmel,at91rm9200-rtc");
+	if (!np)
+		np = of_find_compatible_node(root, NULL,
+					     "atmel,at91sam9x5-rtc");
+
+	if (!np)
+		return;
+
+	regs = of_iomap(np, 0);
+	of_node_put(np);
+
+	if (!regs)
+		return;
+
+	writel(AT91_RTC_IRQ_MASK, regs + AT91_RTC_IDR);
+
+	iounmap(regs);
+}
+
 void __init aic_common_irq_fixup(const struct of_device_id *matches)
 {
 	struct device_node *root = of_find_node_by_path("/");

commit b2f579b58e93ded5916fb69a28cfc86e0ab951a6
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Thu Jul 10 20:25:39 2014 +0200

    irqchip: atmel-aic: Add irq fixup infrastructure
    
    Add irq fixup infrastructure to handle IP blocks connected to shared irqs
    that are left in an unknown state when booting the kernel.
    
    In this case the IP block which has not masked its interrupt and has no
    driver loaded (either because it is not compiled or because it is not
    loaded yet) might generate spurious interrupts when another IP block
    request the shared irq.
    
    A good example of this case is the RTC block on which register configs are
    kept even after a shutdown (if a proper VDDcore is supplied), and thus
    might generate spurious interrupts when the platform is switched on.
    
    Signed-off-by: Boris BREZILLON <boris.brezillon@free-electrons.com>
    Link: https://lkml.kernel.org/r/1405016741-2407-2-git-send-email-boris.brezillon@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/irq-atmel-aic-common.c b/drivers/irqchip/irq-atmel-aic-common.c
index 18b76fc03d53..4705bdbc6e7b 100644
--- a/drivers/irqchip/irq-atmel-aic-common.c
+++ b/drivers/irqchip/irq-atmel-aic-common.c
@@ -139,6 +139,25 @@ static void __init aic_common_ext_irq_of_init(struct irq_domain *domain)
 	}
 }
 
+void __init aic_common_irq_fixup(const struct of_device_id *matches)
+{
+	struct device_node *root = of_find_node_by_path("/");
+	const struct of_device_id *match;
+
+	if (!root)
+		return;
+
+	match = of_match_node(matches, root);
+	of_node_put(root);
+
+	if (match) {
+		void (*fixup)(struct device_node *) = match->data;
+		fixup(root);
+	}
+
+	of_node_put(root);
+}
+
 struct irq_domain *__init aic_common_of_init(struct device_node *node,
 					     const struct irq_domain_ops *ops,
 					     const char *name, int nirqs)

commit b1479ebb772003461f0458a0b3a68cb1c4036288
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Thu Jul 10 19:14:18 2014 +0200

    irqchip: atmel-aic: Add atmel AIC/AIC5 drivers
    
    Add AIC (Advanced Interrupt Controller) and AIC5 (AIC5 is an evolution of
    the AIC block) drivers.
    Put common code in irq-atmel-aic-common.c/.h so that both driver can access
    shared functions (this will ease maintenance).
    
    These drivers are only compatible with dt enabled board and replace the
    old implementation found in arch/arm/mach-at91/irq.c.
    
    Signed-off-by: Boris BREZILLON <boris.brezillon@free-electrons.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Link: https://lkml.kernel.org/r/1405012462-766-4-git-send-email-boris.brezillon@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/irq-atmel-aic-common.c b/drivers/irqchip/irq-atmel-aic-common.c
new file mode 100644
index 000000000000..18b76fc03d53
--- /dev/null
+++ b/drivers/irqchip/irq-atmel-aic-common.c
@@ -0,0 +1,207 @@
+/*
+ * Atmel AT91 common AIC (Advanced Interrupt Controller) code shared by
+ * irq-atmel-aic and irq-atmel-aic5 drivers
+ *
+ *  Copyright (C) 2004 SAN People
+ *  Copyright (C) 2004 ATMEL
+ *  Copyright (C) Rick Bronson
+ *  Copyright (C) 2014 Free Electrons
+ *
+ *  Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/errno.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/slab.h>
+
+#include "irq-atmel-aic-common.h"
+
+#define AT91_AIC_PRIOR			GENMASK(2, 0)
+#define AT91_AIC_IRQ_MIN_PRIORITY	0
+#define AT91_AIC_IRQ_MAX_PRIORITY	7
+
+#define AT91_AIC_SRCTYPE		GENMASK(7, 6)
+#define AT91_AIC_SRCTYPE_LOW		(0 << 5)
+#define AT91_AIC_SRCTYPE_FALLING	(1 << 5)
+#define AT91_AIC_SRCTYPE_HIGH		(2 << 5)
+#define AT91_AIC_SRCTYPE_RISING		(3 << 5)
+
+struct aic_chip_data {
+	u32 ext_irqs;
+};
+
+static void aic_common_shutdown(struct irq_data *d)
+{
+	struct irq_chip_type *ct = irq_data_get_chip_type(d);
+
+	ct->chip.irq_mask(d);
+}
+
+int aic_common_set_type(struct irq_data *d, unsigned type, unsigned *val)
+{
+	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
+	struct aic_chip_data *aic = gc->private;
+	unsigned aic_type;
+
+	switch (type) {
+	case IRQ_TYPE_LEVEL_HIGH:
+		aic_type = AT91_AIC_SRCTYPE_HIGH;
+		break;
+	case IRQ_TYPE_EDGE_RISING:
+		aic_type = AT91_AIC_SRCTYPE_RISING;
+		break;
+	case IRQ_TYPE_LEVEL_LOW:
+		if (!(d->mask & aic->ext_irqs))
+			return -EINVAL;
+
+		aic_type = AT91_AIC_SRCTYPE_LOW;
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		if (!(d->mask & aic->ext_irqs))
+			return -EINVAL;
+
+		aic_type = AT91_AIC_SRCTYPE_FALLING;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	*val &= AT91_AIC_SRCTYPE;
+	*val |= aic_type;
+
+	return 0;
+}
+
+int aic_common_set_priority(int priority, unsigned *val)
+{
+	if (priority < AT91_AIC_IRQ_MIN_PRIORITY ||
+	    priority > AT91_AIC_IRQ_MAX_PRIORITY)
+		return -EINVAL;
+
+	*val &= AT91_AIC_PRIOR;
+	*val |= priority;
+
+	return 0;
+}
+
+int aic_common_irq_domain_xlate(struct irq_domain *d,
+				struct device_node *ctrlr,
+				const u32 *intspec,
+				unsigned int intsize,
+				irq_hw_number_t *out_hwirq,
+				unsigned int *out_type)
+{
+	if (WARN_ON(intsize < 3))
+		return -EINVAL;
+
+	if (WARN_ON((intspec[2] < AT91_AIC_IRQ_MIN_PRIORITY) ||
+		    (intspec[2] > AT91_AIC_IRQ_MAX_PRIORITY)))
+		return -EINVAL;
+
+	*out_hwirq = intspec[0];
+	*out_type = intspec[1] & IRQ_TYPE_SENSE_MASK;
+
+	return 0;
+}
+
+static void __init aic_common_ext_irq_of_init(struct irq_domain *domain)
+{
+	struct device_node *node = domain->of_node;
+	struct irq_chip_generic *gc;
+	struct aic_chip_data *aic;
+	struct property *prop;
+	const __be32 *p;
+	u32 hwirq;
+
+	gc = irq_get_domain_generic_chip(domain, 0);
+
+	aic = gc->private;
+	aic->ext_irqs |= 1;
+
+	of_property_for_each_u32(node, "atmel,external-irqs", prop, p, hwirq) {
+		gc = irq_get_domain_generic_chip(domain, hwirq);
+		if (!gc) {
+			pr_warn("AIC: external irq %d >= %d skip it\n",
+				hwirq, domain->revmap_size);
+			continue;
+		}
+
+		aic = gc->private;
+		aic->ext_irqs |= (1 << (hwirq % 32));
+	}
+}
+
+struct irq_domain *__init aic_common_of_init(struct device_node *node,
+					     const struct irq_domain_ops *ops,
+					     const char *name, int nirqs)
+{
+	struct irq_chip_generic *gc;
+	struct irq_domain *domain;
+	struct aic_chip_data *aic;
+	void __iomem *reg_base;
+	int nchips;
+	int ret;
+	int i;
+
+	nchips = DIV_ROUND_UP(nirqs, 32);
+
+	reg_base = of_iomap(node, 0);
+	if (!reg_base)
+		return ERR_PTR(-ENOMEM);
+
+	aic = kcalloc(nchips, sizeof(*aic), GFP_KERNEL);
+	if (!aic) {
+		ret = -ENOMEM;
+		goto err_iounmap;
+	}
+
+	domain = irq_domain_add_linear(node, nchips * 32, ops, aic);
+	if (!domain) {
+		ret = -ENOMEM;
+		goto err_free_aic;
+	}
+
+	ret = irq_alloc_domain_generic_chips(domain, 32, 1, name,
+					     handle_level_irq, 0, 0,
+					     IRQCHIP_SKIP_SET_WAKE);
+	if (ret)
+		goto err_domain_remove;
+
+	for (i = 0; i < nchips; i++) {
+		gc = irq_get_domain_generic_chip(domain, i * 32);
+
+		gc->reg_base = reg_base;
+
+		gc->unused = 0;
+		gc->wake_enabled = ~0;
+		gc->chip_types[0].type = IRQ_TYPE_SENSE_MASK;
+		gc->chip_types[0].handler = handle_fasteoi_irq;
+		gc->chip_types[0].chip.irq_eoi = irq_gc_eoi;
+		gc->chip_types[0].chip.irq_set_wake = irq_gc_set_wake;
+		gc->chip_types[0].chip.irq_shutdown = aic_common_shutdown;
+		gc->private = &aic[i];
+	}
+
+	aic_common_ext_irq_of_init(domain);
+
+	return domain;
+
+err_domain_remove:
+	irq_domain_remove(domain);
+
+err_free_aic:
+	kfree(aic);
+
+err_iounmap:
+	iounmap(reg_base);
+
+	return ERR_PTR(ret);
+}
