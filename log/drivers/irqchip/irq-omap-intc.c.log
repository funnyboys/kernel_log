commit 77c858fa343bb09cc3fe1456fda5710c974845b9
Author: Ladislav Michl <ladis@linux-mips.org>
Date:   Mon Oct 16 18:13:03 2017 +0200

    irqchip/irq-omap-intc: Do not statically initialize variables
    
    omap_nr_pending and omap_nr_irqs variables are initialized
    right at the beginning of intc_of_init function, so there's
    no need to statically initialize them.
    
    Signed-off-by: Ladislav Michl <ladis@linux-mips.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: linux-omap@vger.kernel.org
    Cc: Jason Cooper <jason@lakedaemon.net>
    Link: https://lkml.kernel.org/r/20171016161303.veumgcd3xom5c54r@lenoch

diff --git a/drivers/irqchip/irq-omap-intc.c b/drivers/irqchip/irq-omap-intc.c
index 05f7f06dd711..d360a6eddd6d 100644
--- a/drivers/irqchip/irq-omap-intc.c
+++ b/drivers/irqchip/irq-omap-intc.c
@@ -66,8 +66,8 @@ static struct omap_intc_regs intc_context;
 
 static struct irq_domain *domain;
 static void __iomem *omap_irq_base;
-static int omap_nr_pending = 3;
-static int omap_nr_irqs = 96;
+static int omap_nr_pending;
+static int omap_nr_irqs;
 
 static void intc_writel(u32 reg, u32 val)
 {

commit 62518c02f75ff9b19c07b53b8e13ed878211b795
Author: Ladislav Michl <ladis@linux-mips.org>
Date:   Mon Oct 16 18:04:22 2017 +0200

    irqchip/irq-omap-intc: Remove omap3_init_irq()
    
    All mach-omap2 variants are device tree only now, so this function is dead
    code. Remove it.
    
    Signed-off-by: Ladislav Michl <ladis@linux-mips.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: linux-omap@vger.kernel.org
    Cc: Jason Cooper <jason@lakedaemon.net>
    Link: https://lkml.kernel.org/r/20171016160422.uu2i7vvrgy7cc4aw@lenoch

diff --git a/drivers/irqchip/irq-omap-intc.c b/drivers/irqchip/irq-omap-intc.c
index b04a8ac6e744..05f7f06dd711 100644
--- a/drivers/irqchip/irq-omap-intc.c
+++ b/drivers/irqchip/irq-omap-intc.c
@@ -25,10 +25,6 @@
 
 #include <linux/irqchip/irq-omap-intc.h>
 
-/* Define these here for now until we drop all board-files */
-#define OMAP24XX_IC_BASE	0x480fe000
-#define OMAP34XX_IC_BASE	0x48200000
-
 /* selected INTC register offsets */
 
 #define INTC_REVISION		0x0000
@@ -364,14 +360,6 @@ omap_intc_handle_irq(struct pt_regs *regs)
 	handle_domain_irq(domain, irqnr, regs);
 }
 
-void __init omap3_init_irq(void)
-{
-	omap_nr_irqs = 96;
-	omap_nr_pending = 3;
-	omap_init_irq(OMAP34XX_IC_BASE, NULL);
-	set_handle_irq(omap_intc_handle_irq);
-}
-
 static int __init intc_of_init(struct device_node *node,
 			     struct device_node *parent)
 {

commit f3142635de32cba695149a00efa9980958d5afdc
Author: Ben Dooks <ben.dooks@codethink.co.uk>
Date:   Wed Jun 8 18:44:32 2016 +0100

    irqchip/omap-intc: Fix missing <linux/irqchip/irq-omap-intc.h> include
    
    Fix the missing include of <linux/irqchip/irq-omap-intc.h> which
    declares all the missing functions from the following warnings:
    
    drivers/irqchip/irq-omap-intc.c:84:6: warning: symbol 'omap_intc_save_context' was not declared. Should it be static?
    drivers/irqchip/irq-omap-intc.c:105:6: warning: symbol 'omap_intc_restore_context' was not declared. Should it be static?
    drivers/irqchip/irq-omap-intc.c:124:6: warning: symbol 'omap3_intc_prepare_idle' was not declared. Should it be static?
    drivers/irqchip/irq-omap-intc.c:134:6: warning: symbol 'omap3_intc_resume_idle' was not declared. Should it be static?
    drivers/irqchip/irq-omap-intc.c:173:5: warning: symbol 'omap_irq_pending' was not declared. Should it be static?
    drivers/irqchip/irq-omap-intc.c:183:6: warning: symbol 'omap3_intc_suspend' was not declared. Should it be static?
    drivers/irqchip/irq-omap-intc.c:365:13: warning: symbol 'omap3_init_irq' was not declared. Should it be static?
    
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Link: https://lkml.kernel.org/r/1465407872-10299-1-git-send-email-ben.dooks@codethink.co.uk
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/irq-omap-intc.c b/drivers/irqchip/irq-omap-intc.c
index 9d1bcfc33e4c..b04a8ac6e744 100644
--- a/drivers/irqchip/irq-omap-intc.c
+++ b/drivers/irqchip/irq-omap-intc.c
@@ -23,6 +23,8 @@
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
 
+#include <linux/irqchip/irq-omap-intc.h>
+
 /* Define these here for now until we drop all board-files */
 #define OMAP24XX_IC_BASE	0x480fe000
 #define OMAP34XX_IC_BASE	0x48200000

commit d3b421cd07e4c0d4d6c0bbd55ca169c054fc081d
Author: Sekhar Nori <nsekhar@ti.com>
Date:   Tue Dec 15 19:56:12 2015 +0530

    irqchip/omap-intc: Add support for spurious irq handling
    
    Under some conditions, irq sorting procedure used by INTC can go wrong
    resulting in a spurious irq getting reported.
    
    If this condition is not handled, it results in endless stream of:
    
        unexpected IRQ trap at vector 00
    
    messages from ack_bad_irq()
    
    Handle the spurious interrupt condition in omap-intc driver to prevent this.
    
    Measurements using kernel function profiler on AM335x EVM running at 720MHz
    show that after this patch omap_intc_handle_irq() takes about 37.4us against
    34us before this patch.
    
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Cc: John Ogness <john.ogness@linutronix.de>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Link: http://lkml.kernel.org/r/9c78a6db02ac55f7af7371b417b6e414d2c3095b.1450188128.git.nsekhar@ti.com
    Cc: stable@vger.kernel.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/irq-omap-intc.c b/drivers/irqchip/irq-omap-intc.c
index ed25175ae9fa..9d1bcfc33e4c 100644
--- a/drivers/irqchip/irq-omap-intc.c
+++ b/drivers/irqchip/irq-omap-intc.c
@@ -47,6 +47,7 @@
 #define INTC_ILR0		0x0100
 
 #define ACTIVEIRQ_MASK		0x7f	/* omap2/3 active interrupt bits */
+#define SPURIOUSIRQ_MASK	(0x1ffffff << 7)
 #define INTCPS_NR_ILR_REGS	128
 #define INTCPS_NR_MIR_REGS	4
 
@@ -329,11 +330,35 @@ static int __init omap_init_irq(u32 base, struct device_node *node)
 static asmlinkage void __exception_irq_entry
 omap_intc_handle_irq(struct pt_regs *regs)
 {
+	extern unsigned long irq_err_count;
 	u32 irqnr;
 
 	irqnr = intc_readl(INTC_SIR);
+
+	/*
+	 * A spurious IRQ can result if interrupt that triggered the
+	 * sorting is no longer active during the sorting (10 INTC
+	 * functional clock cycles after interrupt assertion). Or a
+	 * change in interrupt mask affected the result during sorting
+	 * time. There is no special handling required except ignoring
+	 * the SIR register value just read and retrying.
+	 * See section 6.2.5 of AM335x TRM Literature Number: SPRUH73K
+	 *
+	 * Many a times, a spurious interrupt situation has been fixed
+	 * by adding a flush for the posted write acking the IRQ in
+	 * the device driver. Typically, this is going be the device
+	 * driver whose interrupt was handled just before the spurious
+	 * IRQ occurred. Pay attention to those device drivers if you
+	 * run into hitting the spurious IRQ condition below.
+	 */
+	if (unlikely((irqnr & SPURIOUSIRQ_MASK) == SPURIOUSIRQ_MASK)) {
+		pr_err_once("%s: spurious irq!\n", __func__);
+		irq_err_count++;
+		omap_ack_irq(NULL);
+		return;
+	}
+
 	irqnr &= ACTIVEIRQ_MASK;
-	WARN_ONCE(!irqnr, "Spurious IRQ ?\n");
 	handle_domain_irq(domain, irqnr, regs);
 }
 

commit fee48dfcd76b21b9a7117c3014e1345697ff08ec
Author: Milo Kim <milo.kim@ti.com>
Date:   Mon Dec 21 17:53:14 2015 +0900

    irqchip/omap-intc: Remove duplicate setup for IRQ chip type handler
    
    Some OMAP interrupt controllers use generic level detection, so
    handle_level_irq() is used as the chip type handler.
    Allocated IRQ chip type handler doesn't need to set it again because
    irq_alloc_domain_generic_chips() has already registered it.
    
    Tested with BeagleBoneBlack Rev C.
    
    Signed-off-by: Milo Kim <milo.kim@ti.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: linux-omap@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Link: http://lkml.kernel.org/r/1450687994-12580-1-git-send-email-milo.kim@ti.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/irq-omap-intc.c b/drivers/irqchip/irq-omap-intc.c
index 8587d0f8d8c0..ed25175ae9fa 100644
--- a/drivers/irqchip/irq-omap-intc.c
+++ b/drivers/irqchip/irq-omap-intc.c
@@ -207,7 +207,6 @@ static int __init omap_alloc_gc_of(struct irq_domain *d, void __iomem *base)
 		ct = gc->chip_types;
 
 		ct->type = IRQ_TYPE_LEVEL_MASK;
-		ct->handler = handle_level_irq;
 
 		ct->chip.irq_ack = omap_mask_ack_irq;
 		ct->chip.irq_mask = irq_gc_mask_disable_reg;

commit 6ed3464897cc825a75218653c710d673282dfcf8
Author: Felipe Balbi <balbi@ti.com>
Date:   Fri Jan 2 16:18:54 2015 -0600

    irqchip: omap-intc: Improve IRQ handler
    
    As it turns out the current IRQ number will *always* be available from
    SIR register which renders the reads of PENDING registers as plain
    unnecessary overhead.
    
    In order to catch any situation where SIR reads as zero, we're adding
    a WARN() to turn it into a very verbose error and users actually
    report it.
    
    With this patch average running time of omap_intc_handle_irq() reduced
    from about 28.5us to 19.8us as measured by the kernel function
    profiler.
    
    Tested with BeagleBoneBlack Rev A5C.
    
    Tested-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Cc: Linux ARM Kernel Mailing List <linux-arm-kernel@lists.infradead.org>
    Link: http://lkml.kernel.org/r/20150720204910.GH5394@saruman.tx.rr.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/irq-omap-intc.c b/drivers/irqchip/irq-omap-intc.c
index 6cc0ad57ffab..8587d0f8d8c0 100644
--- a/drivers/irqchip/irq-omap-intc.c
+++ b/drivers/irqchip/irq-omap-intc.c
@@ -330,37 +330,12 @@ static int __init omap_init_irq(u32 base, struct device_node *node)
 static asmlinkage void __exception_irq_entry
 omap_intc_handle_irq(struct pt_regs *regs)
 {
-	u32 irqnr = 0;
-	int handled_irq = 0;
-	int i;
-
-	do {
-		for (i = 0; i < omap_nr_pending; i++) {
-			irqnr = intc_readl(INTC_PENDING_IRQ0 + (0x20 * i));
-			if (irqnr)
-				goto out;
-		}
-
-out:
-		if (!irqnr)
-			break;
-
-		irqnr = intc_readl(INTC_SIR);
-		irqnr &= ACTIVEIRQ_MASK;
+	u32 irqnr;
 
-		if (irqnr) {
-			handle_domain_irq(domain, irqnr, regs);
-			handled_irq = 1;
-		}
-	} while (irqnr);
-
-	/*
-	 * If an irq is masked or deasserted while active, we will
-	 * keep ending up here with no irq handled. So remove it from
-	 * the INTC with an ack.
-	 */
-	if (!handled_irq)
-		omap_ack_irq(NULL);
+	irqnr = intc_readl(INTC_SIR);
+	irqnr &= ACTIVEIRQ_MASK;
+	WARN_ONCE(!irqnr, "Spurious IRQ ?\n");
+	handle_domain_irq(domain, irqnr, regs);
 }
 
 void __init omap3_init_irq(void)

commit 41a83e06e2bb9ac46731681fd44d1e6ab184dac5
Author: Joel Porquet <joel@porquet.org>
Date:   Tue Jul 7 17:11:46 2015 -0400

    irqchip: Prepare for local stub header removal
    
    The IRQCHIP_DECLARE macro moved to to 'include/linux/irqchip.h', so
    the local irqchip.h became an empty shell, which solely includes
    include/linux/irqchip.h
    
    Include the global header in all irqchip drivers instead of the local
    header, so we can remove it.
    
    Signed-off-by: Joel Porquet <joel@porquet.org>
    Cc: vgupta@synopsys.com
    Cc: monstr@monstr.eu
    Cc: ralf@linux-mips.org
    Cc: jason@lakedaemon.net
    Link: http://lkml.kernel.org/r/1882096.X39jVG8e0D@joel-zenbook
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/irq-omap-intc.c b/drivers/irqchip/irq-omap-intc.c
index a569c6dbd1d1..6cc0ad57ffab 100644
--- a/drivers/irqchip/irq-omap-intc.c
+++ b/drivers/irqchip/irq-omap-intc.c
@@ -17,13 +17,12 @@
 #include <linux/io.h>
 
 #include <asm/exception.h>
+#include <linux/irqchip.h>
 #include <linux/irqdomain.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
 
-#include "irqchip.h"
-
 /* Define these here for now until we drop all board-files */
 #define OMAP24XX_IC_BASE	0x480fe000
 #define OMAP34XX_IC_BASE	0x48200000

commit c7f2a2ac377626897ad68e63d24d85ee21f47bb1
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Jan 13 14:23:26 2015 -0800

    irqchip: omap-intc: Remove unused legacy interface for omap2
    
    Nowadays omap2 is booting in device tree only mode so there is no
    need to keep the legacy interface around for omap2_init_irq().
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Felipe Balbi <balbi@ti.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Link: http://lkml.kernel.org/r/1421187806-6804-3-git-send-email-tony@atomide.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/irq-omap-intc.c b/drivers/irqchip/irq-omap-intc.c
index b444d0e48f1f..a569c6dbd1d1 100644
--- a/drivers/irqchip/irq-omap-intc.c
+++ b/drivers/irqchip/irq-omap-intc.c
@@ -364,14 +364,6 @@ omap_intc_handle_irq(struct pt_regs *regs)
 		omap_ack_irq(NULL);
 }
 
-void __init omap2_init_irq(void)
-{
-	omap_nr_irqs = 96;
-	omap_nr_pending = 3;
-	omap_init_irq(OMAP24XX_IC_BASE, NULL);
-	set_handle_irq(omap_intc_handle_irq);
-}
-
 void __init omap3_init_irq(void)
 {
 	omap_nr_irqs = 96;

commit 19f92b237b1700d30b788f00b16a627ffbfdf0e5
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Jan 13 14:23:25 2015 -0800

    irqchip: omap-intc: Fix support for dm814 and dm816
    
    On dm81xx we have 128 interrupts like am33xx has. Let's add
    compatible flags for dm814x and dm816x, and document the
    existing binding.
    
    As the dm81xx are booting in device tree only mode, we can now
    also remove ti81xx_init_irq() legacy function.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Felipe Balbi <balbi@ti.com>
    Cc: Brian Hutchinson <b.hutchman@gmail.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Link: http://lkml.kernel.org/r/1421187806-6804-2-git-send-email-tony@atomide.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/irq-omap-intc.c b/drivers/irqchip/irq-omap-intc.c
index c03f140acbae..b444d0e48f1f 100644
--- a/drivers/irqchip/irq-omap-intc.c
+++ b/drivers/irqchip/irq-omap-intc.c
@@ -380,14 +380,6 @@ void __init omap3_init_irq(void)
 	set_handle_irq(omap_intc_handle_irq);
 }
 
-void __init ti81xx_init_irq(void)
-{
-	omap_nr_irqs = 96;
-	omap_nr_pending = 4;
-	omap_init_irq(OMAP34XX_IC_BASE, NULL);
-	set_handle_irq(omap_intc_handle_irq);
-}
-
 static int __init intc_of_init(struct device_node *node,
 			     struct device_node *parent)
 {
@@ -399,7 +391,9 @@ static int __init intc_of_init(struct device_node *node,
 	if (WARN_ON(!node))
 		return -ENODEV;
 
-	if (of_device_is_compatible(node, "ti,am33xx-intc")) {
+	if (of_device_is_compatible(node, "ti,dm814-intc") ||
+	    of_device_is_compatible(node, "ti,dm816-intc") ||
+	    of_device_is_compatible(node, "ti,am33xx-intc")) {
 		omap_nr_irqs = 128;
 		omap_nr_pending = 4;
 	}
@@ -415,4 +409,6 @@ static int __init intc_of_init(struct device_node *node,
 
 IRQCHIP_DECLARE(omap2_intc, "ti,omap2-intc", intc_of_init);
 IRQCHIP_DECLARE(omap3_intc, "ti,omap3-intc", intc_of_init);
+IRQCHIP_DECLARE(dm814x_intc, "ti,dm814-intc", intc_of_init);
+IRQCHIP_DECLARE(dm816x_intc, "ti,dm816-intc", intc_of_init);
 IRQCHIP_DECLARE(am33xx_intc, "ti,am33xx-intc", intc_of_init);

commit 4b149e417463bbb6d1d9b805f729627ca2b54495
Author: Felipe Balbi <balbi@ti.com>
Date:   Tue Jan 6 14:38:08 2015 -0600

    irqchip: omap-intc: Fix legacy DMA regression
    
    commit 55601c9f2467 (arm: omap: intc: switch over
    to linear irq domain) introduced a regression with
    SDMA legacy driver because that driver strictly depends
    on INTC's IRQs starting at NR_IRQs. Aparently
    irq_domain_add_linear() won't guarantee that, since we see
    a 7 IRQs difference when booting with and without the
    commit cited above.
    
    Until arch/arm/plat-omap/dma.c is properly fixed, we
    must maintain OMAP2/3 using irq_domain_add_legacy().
    
    A FIXME note was added so people know to delete that
    code once that legacy DMA driver is fixed up.
    
    Fixes: 55601c9f2467 (arm: omap: intc: switch over to linear irq domain)
    Cc: <stable@vger.kernel.org> # v3.18
    Tested-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Link: https://lkml.kernel.org/r/1420576688-10604-1-git-send-email-balbi@ti.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/irq-omap-intc.c b/drivers/irqchip/irq-omap-intc.c
index 28718d3e8281..c03f140acbae 100644
--- a/drivers/irqchip/irq-omap-intc.c
+++ b/drivers/irqchip/irq-omap-intc.c
@@ -263,7 +263,7 @@ static int __init omap_init_irq_of(struct device_node *node)
 	return ret;
 }
 
-static int __init omap_init_irq_legacy(u32 base)
+static int __init omap_init_irq_legacy(u32 base, struct device_node *node)
 {
 	int j, irq_base;
 
@@ -277,7 +277,7 @@ static int __init omap_init_irq_legacy(u32 base)
 		irq_base = 0;
 	}
 
-	domain = irq_domain_add_legacy(NULL, omap_nr_irqs, irq_base, 0,
+	domain = irq_domain_add_legacy(node, omap_nr_irqs, irq_base, 0,
 			&irq_domain_simple_ops, NULL);
 
 	omap_irq_soft_reset();
@@ -301,10 +301,26 @@ static int __init omap_init_irq(u32 base, struct device_node *node)
 {
 	int ret;
 
-	if (node)
+	/*
+	 * FIXME legacy OMAP DMA driver sitting under arch/arm/plat-omap/dma.c
+	 * depends is still not ready for linear IRQ domains; because of that
+	 * we need to temporarily "blacklist" OMAP2 and OMAP3 devices from using
+	 * linear IRQ Domain until that driver is finally fixed.
+	 */
+	if (of_device_is_compatible(node, "ti,omap2-intc") ||
+			of_device_is_compatible(node, "ti,omap3-intc")) {
+		struct resource res;
+
+		if (of_address_to_resource(node, 0, &res))
+			return -ENOMEM;
+
+		base = res.start;
+		ret = omap_init_irq_legacy(base, node);
+	} else if (node) {
 		ret = omap_init_irq_of(node);
-	else
-		ret = omap_init_irq_legacy(base);
+	} else {
+		ret = omap_init_irq_legacy(base, NULL);
+	}
 
 	if (ret == 0)
 		omap_irq_enable_protection();

commit 782d59c5dfc5ac39ac8cfb4c6dd40597938dde9c
Merge: 47137c6ba1bc 2828c9cdb8bd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 9 06:42:04 2014 -0400

    Merge branch 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull irq updates from Thomas Gleixner:
     "The irq departement delivers:
    
       - a cleanup series to get rid of mindlessly copied code.
    
       - another bunch of new pointlessly different interrupt chip drivers.
    
         Adding homebrewn irq chips (and timers) to SoCs must provide a
         value add which is beyond the imagination of mere mortals.
    
       - the usual SoC irq controller updates, IOW my second cat herding
         project"
    
    * 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (44 commits)
      irqchip: gic-v3: Implement CPU PM notifier
      irqchip: gic-v3: Refactor gic_enable_redist to support both enabling and disabling
      irqchip: renesas-intc-irqpin: Add minimal runtime PM support
      irqchip: renesas-intc-irqpin: Add helper variable dev = &pdev->dev
      irqchip: atmel-aic5: Add sama5d4 support
      irqchip: atmel-aic5: The sama5d3 has 48 IRQs
      Documentation: bcm7120-l2: Add Broadcom BCM7120-style L2 binding
      irqchip: bcm7120-l2: Add Broadcom BCM7120-style Level 2 interrupt controller
      irqchip: renesas-irqc: Add binding docs for new R-Car Gen2 SoCs
      irqchip: renesas-irqc: Add DT binding documentation
      irqchip: renesas-intc-irqpin: Document SoC-specific bindings
      openrisc: Get rid of handle_IRQ
      arm64: Get rid of handle_IRQ
      ARM: omap2: irq: Convert to handle_domain_irq
      ARM: imx: tzic: Convert to handle_domain_irq
      ARM: imx: avic: Convert to handle_domain_irq
      irqchip: or1k-pic: Convert to handle_domain_irq
      irqchip: atmel-aic5: Convert to handle_domain_irq
      irqchip: atmel-aic: Convert to handle_domain_irq
      irqchip: gic-v3: Convert to handle_domain_irq
      ...

commit 64d5947b9ee1284b38b8e212e7c94024452b2bb4
Author: Felipe Balbi <balbi@ti.com>
Date:   Mon Sep 15 16:15:09 2014 -0500

    irqchip: omap-intc: remove unnecessary comments
    
    no fuctional changes.
    
    Acked-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/irqchip/irq-omap-intc.c b/drivers/irqchip/irq-omap-intc.c
index 976d4c15fefd..f3814e79192d 100644
--- a/drivers/irqchip/irq-omap-intc.c
+++ b/drivers/irqchip/irq-omap-intc.c
@@ -56,14 +56,6 @@
 
 #define INTC_PROTECTION_ENABLE	(1 << 0)
 
-/*
- * OMAP2 has a number of different interrupt controllers, each interrupt
- * controller is identified as its own "bank". Register definitions are
- * fairly consistent for each bank, but not all registers are implemented
- * for each bank.. when in doubt, consult the TRM.
- */
-
-/* Structure to save interrupt controller context */
 struct omap_intc_regs {
 	u32 sysconfig;
 	u32 protection;
@@ -79,7 +71,6 @@ static void __iomem *omap_irq_base;
 static int omap_nr_pending = 3;
 static int omap_nr_irqs = 96;
 
-/* INTC bank register get/set */
 static void intc_writel(u32 reg, u32 val)
 {
 	writel_relaxed(val, omap_irq_base + reg);

commit 74b6c8ef546dec98f1817147d31f17a1f3aab09e
Author: Felipe Balbi <balbi@ti.com>
Date:   Mon Sep 15 16:15:08 2014 -0500

    irqchip: omap-intc: correct maximum number or MIR registers
    
    maximum number of MIR register is 4, rather than 3.
    Fix that.
    
    Acked-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/irqchip/irq-omap-intc.c b/drivers/irqchip/irq-omap-intc.c
index dfa2d9de5361..976d4c15fefd 100644
--- a/drivers/irqchip/irq-omap-intc.c
+++ b/drivers/irqchip/irq-omap-intc.c
@@ -49,7 +49,7 @@
 
 #define ACTIVEIRQ_MASK		0x7f	/* omap2/3 active interrupt bits */
 #define INTCPS_NR_ILR_REGS	128
-#define INTCPS_NR_MIR_REGS	3
+#define INTCPS_NR_MIR_REGS	4
 
 #define INTC_IDLE_FUNCIDLE	(1 << 0)
 #define INTC_IDLE_TURBO		(1 << 1)

commit b30791498a140d9460dfb9cb8edcb6fd1065363c
Author: Felipe Balbi <balbi@ti.com>
Date:   Mon Sep 15 16:15:07 2014 -0500

    irqchip: omap-intc: enable TURBO idle mode
    
    When TURBO bit is set in the INTC_IDLE register,
    the input synchronizer clock will be autogated
    based on activity on the INTC.
    
    Because this idle mode increases the interrupt
    latency by 2 clock cycles, we're only enabling
    it during suspend.
    
    Acked-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/irqchip/irq-omap-intc.c b/drivers/irqchip/irq-omap-intc.c
index 7681b1329976..dfa2d9de5361 100644
--- a/drivers/irqchip/irq-omap-intc.c
+++ b/drivers/irqchip/irq-omap-intc.c
@@ -51,6 +51,9 @@
 #define INTCPS_NR_ILR_REGS	128
 #define INTCPS_NR_MIR_REGS	3
 
+#define INTC_IDLE_FUNCIDLE	(1 << 0)
+#define INTC_IDLE_TURBO		(1 << 1)
+
 #define INTC_PROTECTION_ENABLE	(1 << 0)
 
 /*
@@ -134,12 +137,14 @@ void omap3_intc_prepare_idle(void)
 	 * cf. errata ID i540 for 3430 (all revisions up to 3.1.x)
 	 */
 	intc_writel(INTC_SYSCONFIG, 0);
+	intc_writel(INTC_IDLE, INTC_IDLE_TURBO);
 }
 
 void omap3_intc_resume_idle(void)
 {
 	/* Re-enable autoidle */
 	intc_writel(INTC_SYSCONFIG, 1);
+	intc_writel(INTC_IDLE, 0);
 }
 
 /* XXX: FIQ and additional INTC support (only MPU at the moment) */

commit 9836ee9f87dc669c8ce2b24ba986600a6977ca8b
Author: Felipe Balbi <balbi@ti.com>
Date:   Mon Sep 15 16:15:06 2014 -0500

    irqchip: omap-intc: enable IP protection
    
    When PROTECTION bit in enabled in PROTECTION
    register, INTC's registers are only accessible
    from privileged mode.
    
    Acked-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/irqchip/irq-omap-intc.c b/drivers/irqchip/irq-omap-intc.c
index e97b53539386..7681b1329976 100644
--- a/drivers/irqchip/irq-omap-intc.c
+++ b/drivers/irqchip/irq-omap-intc.c
@@ -51,6 +51,8 @@
 #define INTCPS_NR_ILR_REGS	128
 #define INTCPS_NR_MIR_REGS	3
 
+#define INTC_PROTECTION_ENABLE	(1 << 0)
+
 /*
  * OMAP2 has a number of different interrupt controllers, each interrupt
  * controller is identified as its own "bank". Register definitions are
@@ -290,12 +292,28 @@ static int __init omap_init_irq_legacy(u32 base)
 	return 0;
 }
 
+static void __init omap_irq_enable_protection(void)
+{
+	u32 reg;
+
+	reg = intc_readl(INTC_PROTECTION);
+	reg |= INTC_PROTECTION_ENABLE;
+	intc_writel(INTC_PROTECTION, reg);
+}
+
 static int __init omap_init_irq(u32 base, struct device_node *node)
 {
+	int ret;
+
 	if (node)
-		return omap_init_irq_of(node);
+		ret = omap_init_irq_of(node);
 	else
-		return omap_init_irq_legacy(base);
+		ret = omap_init_irq_legacy(base);
+
+	if (ret == 0)
+		omap_irq_enable_protection();
+
+	return ret;
 }
 
 static asmlinkage void __exception_irq_entry

commit 8bb3b375c8837ea73740883a90b1d7719b2653cc
Author: Felipe Balbi <balbi@ti.com>
Date:   Mon Sep 15 16:15:05 2014 -0500

    irqchip: omap-intc: remove unnecesary of_address_to_resource() call
    
    of_iomap(), which is called from omap_init_irq_of(),
    already takes care of making sure we have a valid
    resource to deal with. Because of that, we can
    safely remove our explicit call to of_address_to_resource().
    
    Acked-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/irqchip/irq-omap-intc.c b/drivers/irqchip/irq-omap-intc.c
index f4d562ee3f29..e97b53539386 100644
--- a/drivers/irqchip/irq-omap-intc.c
+++ b/drivers/irqchip/irq-omap-intc.c
@@ -362,7 +362,6 @@ void __init ti81xx_init_irq(void)
 static int __init intc_of_init(struct device_node *node,
 			     struct device_node *parent)
 {
-	struct resource res;
 	int ret;
 
 	omap_nr_pending = 3;
@@ -371,11 +370,6 @@ static int __init intc_of_init(struct device_node *node,
 	if (WARN_ON(!node))
 		return -ENODEV;
 
-	if (of_address_to_resource(node, 0, &res)) {
-		WARN(1, "unable to get intc registers\n");
-		return -EINVAL;
-	}
-
 	if (of_device_is_compatible(node, "ti,am33xx-intc")) {
 		omap_nr_irqs = 128;
 		omap_nr_pending = 4;

commit 503b8d12e7462df0aea9b31ab65ac17b538540c9
Author: Felipe Balbi <balbi@ti.com>
Date:   Mon Sep 15 16:15:04 2014 -0500

    irqchip: omap-intc: comment style cleanup
    
    no functional changes, just making sure comment
    follows Coding Style.
    
    Acked-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/irqchip/irq-omap-intc.c b/drivers/irqchip/irq-omap-intc.c
index 2933760f95aa..f4d562ee3f29 100644
--- a/drivers/irqchip/irq-omap-intc.c
+++ b/drivers/irqchip/irq-omap-intc.c
@@ -326,9 +326,11 @@ omap_intc_handle_irq(struct pt_regs *regs)
 		}
 	} while (irqnr);
 
-	/* If an irq is masked or deasserted while active, we will
+	/*
+	 * If an irq is masked or deasserted while active, we will
 	 * keep ending up here with no irq handled. So remove it from
-	 * the INTC with an ack.*/
+	 * the INTC with an ack.
+	 */
 	if (!handled_irq)
 		omap_ack_irq(NULL);
 }

commit 6bd0f16e322b4572fe1e0ff3b0e78c800c2633b4
Author: Felipe Balbi <balbi@ti.com>
Date:   Mon Sep 15 16:15:03 2014 -0500

    irqchip: omap-intc: minor improvement to omap_irq_pending()
    
    We already hold the number of Pending registers
    in omap_nr_pending. Let's use that instead.
    
    Acked-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/irqchip/irq-omap-intc.c b/drivers/irqchip/irq-omap-intc.c
index 1478f1a3c400..2933760f95aa 100644
--- a/drivers/irqchip/irq-omap-intc.c
+++ b/drivers/irqchip/irq-omap-intc.c
@@ -174,11 +174,10 @@ static void __init omap_irq_soft_reset(void)
 
 int omap_irq_pending(void)
 {
-	int irq;
+	int i;
 
-	for (irq = 0; irq < omap_nr_irqs; irq += 32)
-		if (intc_readl(INTC_PENDING_IRQ0 +
-					((irq >> 5) << 5)))
+	for (i = 0; i < omap_nr_pending; i++)
+		if (intc_readl(INTC_PENDING_IRQ0 + (0x20 * i)))
 			return 1;
 	return 0;
 }

commit 8598066cddd186809c4edf5aae5f018c00079e8c
Author: Felipe Balbi <balbi@ti.com>
Date:   Mon Sep 15 16:15:02 2014 -0500

    arm: omap: irq: move irq.c to drivers/irqchip/
    
    Just move the code over as it has no dependencies
    on arch/arm/ anymore.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/irqchip/irq-omap-intc.c b/drivers/irqchip/irq-omap-intc.c
new file mode 100644
index 000000000000..1478f1a3c400
--- /dev/null
+++ b/drivers/irqchip/irq-omap-intc.c
@@ -0,0 +1,394 @@
+/*
+ * linux/arch/arm/mach-omap2/irq.c
+ *
+ * Interrupt handler for OMAP2 boards.
+ *
+ * Copyright (C) 2005 Nokia Corporation
+ * Author: Paul Mundt <paul.mundt@nokia.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+
+#include <asm/exception.h>
+#include <linux/irqdomain.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+
+#include "irqchip.h"
+
+/* Define these here for now until we drop all board-files */
+#define OMAP24XX_IC_BASE	0x480fe000
+#define OMAP34XX_IC_BASE	0x48200000
+
+/* selected INTC register offsets */
+
+#define INTC_REVISION		0x0000
+#define INTC_SYSCONFIG		0x0010
+#define INTC_SYSSTATUS		0x0014
+#define INTC_SIR		0x0040
+#define INTC_CONTROL		0x0048
+#define INTC_PROTECTION		0x004C
+#define INTC_IDLE		0x0050
+#define INTC_THRESHOLD		0x0068
+#define INTC_MIR0		0x0084
+#define INTC_MIR_CLEAR0		0x0088
+#define INTC_MIR_SET0		0x008c
+#define INTC_PENDING_IRQ0	0x0098
+#define INTC_PENDING_IRQ1	0x00b8
+#define INTC_PENDING_IRQ2	0x00d8
+#define INTC_PENDING_IRQ3	0x00f8
+#define INTC_ILR0		0x0100
+
+#define ACTIVEIRQ_MASK		0x7f	/* omap2/3 active interrupt bits */
+#define INTCPS_NR_ILR_REGS	128
+#define INTCPS_NR_MIR_REGS	3
+
+/*
+ * OMAP2 has a number of different interrupt controllers, each interrupt
+ * controller is identified as its own "bank". Register definitions are
+ * fairly consistent for each bank, but not all registers are implemented
+ * for each bank.. when in doubt, consult the TRM.
+ */
+
+/* Structure to save interrupt controller context */
+struct omap_intc_regs {
+	u32 sysconfig;
+	u32 protection;
+	u32 idle;
+	u32 threshold;
+	u32 ilr[INTCPS_NR_ILR_REGS];
+	u32 mir[INTCPS_NR_MIR_REGS];
+};
+static struct omap_intc_regs intc_context;
+
+static struct irq_domain *domain;
+static void __iomem *omap_irq_base;
+static int omap_nr_pending = 3;
+static int omap_nr_irqs = 96;
+
+/* INTC bank register get/set */
+static void intc_writel(u32 reg, u32 val)
+{
+	writel_relaxed(val, omap_irq_base + reg);
+}
+
+static u32 intc_readl(u32 reg)
+{
+	return readl_relaxed(omap_irq_base + reg);
+}
+
+void omap_intc_save_context(void)
+{
+	int i;
+
+	intc_context.sysconfig =
+		intc_readl(INTC_SYSCONFIG);
+	intc_context.protection =
+		intc_readl(INTC_PROTECTION);
+	intc_context.idle =
+		intc_readl(INTC_IDLE);
+	intc_context.threshold =
+		intc_readl(INTC_THRESHOLD);
+
+	for (i = 0; i < omap_nr_irqs; i++)
+		intc_context.ilr[i] =
+			intc_readl((INTC_ILR0 + 0x4 * i));
+	for (i = 0; i < INTCPS_NR_MIR_REGS; i++)
+		intc_context.mir[i] =
+			intc_readl(INTC_MIR0 + (0x20 * i));
+}
+
+void omap_intc_restore_context(void)
+{
+	int i;
+
+	intc_writel(INTC_SYSCONFIG, intc_context.sysconfig);
+	intc_writel(INTC_PROTECTION, intc_context.protection);
+	intc_writel(INTC_IDLE, intc_context.idle);
+	intc_writel(INTC_THRESHOLD, intc_context.threshold);
+
+	for (i = 0; i < omap_nr_irqs; i++)
+		intc_writel(INTC_ILR0 + 0x4 * i,
+				intc_context.ilr[i]);
+
+	for (i = 0; i < INTCPS_NR_MIR_REGS; i++)
+		intc_writel(INTC_MIR0 + 0x20 * i,
+			intc_context.mir[i]);
+	/* MIRs are saved and restore with other PRCM registers */
+}
+
+void omap3_intc_prepare_idle(void)
+{
+	/*
+	 * Disable autoidle as it can stall interrupt controller,
+	 * cf. errata ID i540 for 3430 (all revisions up to 3.1.x)
+	 */
+	intc_writel(INTC_SYSCONFIG, 0);
+}
+
+void omap3_intc_resume_idle(void)
+{
+	/* Re-enable autoidle */
+	intc_writel(INTC_SYSCONFIG, 1);
+}
+
+/* XXX: FIQ and additional INTC support (only MPU at the moment) */
+static void omap_ack_irq(struct irq_data *d)
+{
+	intc_writel(INTC_CONTROL, 0x1);
+}
+
+static void omap_mask_ack_irq(struct irq_data *d)
+{
+	irq_gc_mask_disable_reg(d);
+	omap_ack_irq(d);
+}
+
+static void __init omap_irq_soft_reset(void)
+{
+	unsigned long tmp;
+
+	tmp = intc_readl(INTC_REVISION) & 0xff;
+
+	pr_info("IRQ: Found an INTC at 0x%p (revision %ld.%ld) with %d interrupts\n",
+		omap_irq_base, tmp >> 4, tmp & 0xf, omap_nr_irqs);
+
+	tmp = intc_readl(INTC_SYSCONFIG);
+	tmp |= 1 << 1;	/* soft reset */
+	intc_writel(INTC_SYSCONFIG, tmp);
+
+	while (!(intc_readl(INTC_SYSSTATUS) & 0x1))
+		/* Wait for reset to complete */;
+
+	/* Enable autoidle */
+	intc_writel(INTC_SYSCONFIG, 1 << 0);
+}
+
+int omap_irq_pending(void)
+{
+	int irq;
+
+	for (irq = 0; irq < omap_nr_irqs; irq += 32)
+		if (intc_readl(INTC_PENDING_IRQ0 +
+					((irq >> 5) << 5)))
+			return 1;
+	return 0;
+}
+
+void omap3_intc_suspend(void)
+{
+	/* A pending interrupt would prevent OMAP from entering suspend */
+	omap_ack_irq(NULL);
+}
+
+static int __init omap_alloc_gc_of(struct irq_domain *d, void __iomem *base)
+{
+	int ret;
+	int i;
+
+	ret = irq_alloc_domain_generic_chips(d, 32, 1, "INTC",
+			handle_level_irq, IRQ_NOREQUEST | IRQ_NOPROBE,
+			IRQ_LEVEL, 0);
+	if (ret) {
+		pr_warn("Failed to allocate irq chips\n");
+		return ret;
+	}
+
+	for (i = 0; i < omap_nr_pending; i++) {
+		struct irq_chip_generic *gc;
+		struct irq_chip_type *ct;
+
+		gc = irq_get_domain_generic_chip(d, 32 * i);
+		gc->reg_base = base;
+		ct = gc->chip_types;
+
+		ct->type = IRQ_TYPE_LEVEL_MASK;
+		ct->handler = handle_level_irq;
+
+		ct->chip.irq_ack = omap_mask_ack_irq;
+		ct->chip.irq_mask = irq_gc_mask_disable_reg;
+		ct->chip.irq_unmask = irq_gc_unmask_enable_reg;
+
+		ct->chip.flags |= IRQCHIP_SKIP_SET_WAKE;
+
+		ct->regs.enable = INTC_MIR_CLEAR0 + 32 * i;
+		ct->regs.disable = INTC_MIR_SET0 + 32 * i;
+	}
+
+	return 0;
+}
+
+static void __init omap_alloc_gc_legacy(void __iomem *base,
+		unsigned int irq_start, unsigned int num)
+{
+	struct irq_chip_generic *gc;
+	struct irq_chip_type *ct;
+
+	gc = irq_alloc_generic_chip("INTC", 1, irq_start, base,
+			handle_level_irq);
+	ct = gc->chip_types;
+	ct->chip.irq_ack = omap_mask_ack_irq;
+	ct->chip.irq_mask = irq_gc_mask_disable_reg;
+	ct->chip.irq_unmask = irq_gc_unmask_enable_reg;
+	ct->chip.flags |= IRQCHIP_SKIP_SET_WAKE;
+
+	ct->regs.enable = INTC_MIR_CLEAR0;
+	ct->regs.disable = INTC_MIR_SET0;
+	irq_setup_generic_chip(gc, IRQ_MSK(num), IRQ_GC_INIT_MASK_CACHE,
+			IRQ_NOREQUEST | IRQ_NOPROBE, 0);
+}
+
+static int __init omap_init_irq_of(struct device_node *node)
+{
+	int ret;
+
+	omap_irq_base = of_iomap(node, 0);
+	if (WARN_ON(!omap_irq_base))
+		return -ENOMEM;
+
+	domain = irq_domain_add_linear(node, omap_nr_irqs,
+			&irq_generic_chip_ops, NULL);
+
+	omap_irq_soft_reset();
+
+	ret = omap_alloc_gc_of(domain, omap_irq_base);
+	if (ret < 0)
+		irq_domain_remove(domain);
+
+	return ret;
+}
+
+static int __init omap_init_irq_legacy(u32 base)
+{
+	int j, irq_base;
+
+	omap_irq_base = ioremap(base, SZ_4K);
+	if (WARN_ON(!omap_irq_base))
+		return -ENOMEM;
+
+	irq_base = irq_alloc_descs(-1, 0, omap_nr_irqs, 0);
+	if (irq_base < 0) {
+		pr_warn("Couldn't allocate IRQ numbers\n");
+		irq_base = 0;
+	}
+
+	domain = irq_domain_add_legacy(NULL, omap_nr_irqs, irq_base, 0,
+			&irq_domain_simple_ops, NULL);
+
+	omap_irq_soft_reset();
+
+	for (j = 0; j < omap_nr_irqs; j += 32)
+		omap_alloc_gc_legacy(omap_irq_base + j, j + irq_base, 32);
+
+	return 0;
+}
+
+static int __init omap_init_irq(u32 base, struct device_node *node)
+{
+	if (node)
+		return omap_init_irq_of(node);
+	else
+		return omap_init_irq_legacy(base);
+}
+
+static asmlinkage void __exception_irq_entry
+omap_intc_handle_irq(struct pt_regs *regs)
+{
+	u32 irqnr = 0;
+	int handled_irq = 0;
+	int i;
+
+	do {
+		for (i = 0; i < omap_nr_pending; i++) {
+			irqnr = intc_readl(INTC_PENDING_IRQ0 + (0x20 * i));
+			if (irqnr)
+				goto out;
+		}
+
+out:
+		if (!irqnr)
+			break;
+
+		irqnr = intc_readl(INTC_SIR);
+		irqnr &= ACTIVEIRQ_MASK;
+
+		if (irqnr) {
+			irqnr = irq_find_mapping(domain, irqnr);
+			handle_IRQ(irqnr, regs);
+			handled_irq = 1;
+		}
+	} while (irqnr);
+
+	/* If an irq is masked or deasserted while active, we will
+	 * keep ending up here with no irq handled. So remove it from
+	 * the INTC with an ack.*/
+	if (!handled_irq)
+		omap_ack_irq(NULL);
+}
+
+void __init omap2_init_irq(void)
+{
+	omap_nr_irqs = 96;
+	omap_nr_pending = 3;
+	omap_init_irq(OMAP24XX_IC_BASE, NULL);
+	set_handle_irq(omap_intc_handle_irq);
+}
+
+void __init omap3_init_irq(void)
+{
+	omap_nr_irqs = 96;
+	omap_nr_pending = 3;
+	omap_init_irq(OMAP34XX_IC_BASE, NULL);
+	set_handle_irq(omap_intc_handle_irq);
+}
+
+void __init ti81xx_init_irq(void)
+{
+	omap_nr_irqs = 96;
+	omap_nr_pending = 4;
+	omap_init_irq(OMAP34XX_IC_BASE, NULL);
+	set_handle_irq(omap_intc_handle_irq);
+}
+
+static int __init intc_of_init(struct device_node *node,
+			     struct device_node *parent)
+{
+	struct resource res;
+	int ret;
+
+	omap_nr_pending = 3;
+	omap_nr_irqs = 96;
+
+	if (WARN_ON(!node))
+		return -ENODEV;
+
+	if (of_address_to_resource(node, 0, &res)) {
+		WARN(1, "unable to get intc registers\n");
+		return -EINVAL;
+	}
+
+	if (of_device_is_compatible(node, "ti,am33xx-intc")) {
+		omap_nr_irqs = 128;
+		omap_nr_pending = 4;
+	}
+
+	ret = omap_init_irq(-1, of_node_get(node));
+	if (ret < 0)
+		return ret;
+
+	set_handle_irq(omap_intc_handle_irq);
+
+	return 0;
+}
+
+IRQCHIP_DECLARE(omap2_intc, "ti,omap2-intc", intc_of_init);
+IRQCHIP_DECLARE(omap3_intc, "ti,omap3-intc", intc_of_init);
+IRQCHIP_DECLARE(am33xx_intc, "ti,am33xx-intc", intc_of_init);
