commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index 99d97d7e3fd7..a05a7501e107 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -1,13 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  drivers/irqchip/irq-crossbar.c
  *
  *  Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com
  *  Author: Sricharan R <r.sricharan@ti.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  */
 #include <linux/err.h>
 #include <linux/io.h>

commit e81f54c668d89e50bad38f3fc4c5ea6e4be3a96e
Author: Rob Herring <robh@kernel.org>
Date:   Tue Jul 18 16:43:10 2017 -0500

    irqchip: Convert to using %pOF instead of full_name
    
    Now that we have a custom printf format specifier, convert users of
    full_name to use %pOF instead. This is preparation to remove storing
    of the full path string for each node.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Lee Jones <lee@kernel.org>
    Cc: Stefan Wahren <stefan.wahren@i2se.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Ray Jui <rjui@broadcom.com>
    Cc: Scott Branden <sbranden@broadcom.com>
    Cc: bcm-kernel-feedback-list@broadcom.com
    Cc: Sylvain Lemieux <slemieux.tyco@gmail.com>
    Cc: Maxime Coquelin <mcoquelin.stm32@gmail.com>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Cc: Michal Simek <michal.simek@xilinx.com>
    Cc: "SÃ¶ren Brinkmann" <soren.brinkmann@xilinx.com>
    Cc: linux-rpi-kernel@lists.infradead.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-mediatek@lists.infradead.org
    Cc: linux-tegra@vger.kernel.org
    Acked-by: Eric Anholt <eric@anholt.net>
    Acked-by: Baruch Siach <baruch@tkos.co.il>
    Acked-by: Vladimir Zapolskiy <vz@mleia.com>
    Acked-by: Matthias Brugger <matthias.bgg@gmail.com>
    Acked-by: Alexandre Torgue <alexandre.torgue@st.com>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index f96601268f71..99d97d7e3fd7 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -341,13 +341,13 @@ static int __init irqcrossbar_init(struct device_node *node,
 	int err;
 
 	if (!parent) {
-		pr_err("%s: no parent, giving up\n", node->full_name);
+		pr_err("%pOF: no parent, giving up\n", node);
 		return -ENODEV;
 	}
 
 	parent_domain = irq_find_host(parent);
 	if (!parent_domain) {
-		pr_err("%s: unable to obtain parent domain\n", node->full_name);
+		pr_err("%pOF: unable to obtain parent domain\n", node);
 		return -ENXIO;
 	}
 
@@ -360,7 +360,7 @@ static int __init irqcrossbar_init(struct device_node *node,
 					  node, &crossbar_domain_ops,
 					  NULL);
 	if (!domain) {
-		pr_err("%s: failed to allocated domain\n", node->full_name);
+		pr_err("%pOF: failed to allocated domain\n", node);
 		return -ENOMEM;
 	}
 

commit 920c634aff6cb66e7f352668521eb1313897e93c
Merge: b28ace12661f 4b9de5da7e12
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 9 12:06:41 2017 +0100

    Merge tag 'irq-fixes-4.11-rc2' of git://git.kernel.org/pub/scm/linux/kernel/git/maz/arm-platforms into irq/urgent
    
    Pull irqchip/irqdomain updates for 4.11-rc2 from Marc Zyngier
    
     - irqchip/crossbar: Some type tidying up
     - irqchip/gicv3-its: Workaround for a Qualcomm erratum
     - irqdomain: Compile for for systems that don't use CONFIG_IRQ_DOMAIN
    
    Fixed up minor conflict in the crossbar driver.

commit 4b9de5da7e120c7f02395da729f0ec77ce7a6044
Author: Franck Demathieu <fdemathieu@gmail.com>
Date:   Mon Mar 6 14:41:06 2017 +0100

    irqchip/crossbar: Fix incorrect type of register size
    
    The 'size' variable is unsigned according to the dt-bindings.
    As this variable is used as integer in other places, create a new variable
    that allows to fix the following sparse issue (-Wtypesign):
    
      drivers/irqchip/irq-crossbar.c:279:52: warning: incorrect type in argument 3 (different signedness)
      drivers/irqchip/irq-crossbar.c:279:52:    expected unsigned int [usertype] *out_value
      drivers/irqchip/irq-crossbar.c:279:52:    got int *<noident>
    
    Signed-off-by: Franck Demathieu <fdemathieu@gmail.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index 05bbf171df37..1070b7b959f2 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -199,7 +199,7 @@ static const struct irq_domain_ops crossbar_domain_ops = {
 static int __init crossbar_of_init(struct device_node *node)
 {
 	int i, size, reserved = 0;
-	u32 max = 0, entry;
+	u32 max = 0, entry, reg_size;
 	const __be32 *irqsr;
 	int ret = -ENOMEM;
 
@@ -276,9 +276,9 @@ static int __init crossbar_of_init(struct device_node *node)
 	if (!cb->register_offsets)
 		goto err_irq_map;
 
-	of_property_read_u32(node, "ti,reg-size", &size);
+	of_property_read_u32(node, "ti,reg-size", &reg_size);
 
-	switch (size) {
+	switch (reg_size) {
 	case 1:
 		cb->write = crossbar_writeb;
 		break;
@@ -304,7 +304,7 @@ static int __init crossbar_of_init(struct device_node *node)
 			continue;
 
 		cb->register_offsets[i] = reserved;
-		reserved += size;
+		reserved += reg_size;
 	}
 
 	of_property_read_u32(node, "ti,irqs-safe-map", &cb->safe_map);

commit 077dbaee9df53c597df532a08d721d03f4570f3d
Author: Franck Demathieu <fdemathieu@gmail.com>
Date:   Thu Feb 23 10:48:55 2017 +0100

    irqchip/crossbar: Fix incorrect type of local variables
    
    The max and entry variables are unsigned according to the dt-bindings.
    Fix following 3 sparse issues (-Wtypesign):
    
      drivers/irqchip/irq-crossbar.c:222:52: warning: incorrect type in argument 3 (different signedness)
      drivers/irqchip/irq-crossbar.c:222:52:    expected unsigned int [usertype] *out_value
      drivers/irqchip/irq-crossbar.c:222:52:    got int *<noident>
    
      drivers/irqchip/irq-crossbar.c:245:56: warning: incorrect type in argument 4 (different signedness)
      drivers/irqchip/irq-crossbar.c:245:56:    expected unsigned int [usertype] *out_value
      drivers/irqchip/irq-crossbar.c:245:56:    got int *<noident>
    
      drivers/irqchip/irq-crossbar.c:263:56: warning: incorrect type in argument 4 (different signedness)
      drivers/irqchip/irq-crossbar.c:263:56:    expected unsigned int [usertype] *out_value
      drivers/irqchip/irq-crossbar.c:263:56:    got int *<noident>
    
    Signed-off-by: Franck Demathieu <fdemathieu@gmail.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index 1eef56a89b1f..05bbf171df37 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -198,7 +198,8 @@ static const struct irq_domain_ops crossbar_domain_ops = {
 
 static int __init crossbar_of_init(struct device_node *node)
 {
-	int i, size, max = 0, reserved = 0, entry;
+	int i, size, reserved = 0;
+	u32 max = 0, entry;
 	const __be32 *irqsr;
 	int ret = -ENOMEM;
 

commit b28ace12661fbcfd90959c1e84ff5a85113a82a1
Author: Franck Demathieu <fdemathieu@gmail.com>
Date:   Thu Feb 23 10:48:55 2017 +0100

    irqchip/crossbar: Fix incorrect type of local variables
    
    The max and entry variables are unsigned according to the dt-bindings.
    Fix following 3 sparse issues (-Wtypesign):
    
      drivers/irqchip/irq-crossbar.c:222:52: warning: incorrect type in argument 3 (different signedness)
      drivers/irqchip/irq-crossbar.c:222:52:    expected unsigned int [usertype] *out_value
      drivers/irqchip/irq-crossbar.c:222:52:    got int *<noident>
    
      drivers/irqchip/irq-crossbar.c:245:56: warning: incorrect type in argument 4 (different signedness)
      drivers/irqchip/irq-crossbar.c:245:56:    expected unsigned int [usertype] *out_value
      drivers/irqchip/irq-crossbar.c:245:56:    got int *<noident>
    
      drivers/irqchip/irq-crossbar.c:263:56: warning: incorrect type in argument 4 (different signedness)
      drivers/irqchip/irq-crossbar.c:263:56:    expected unsigned int [usertype] *out_value
      drivers/irqchip/irq-crossbar.c:263:56:    got int *<noident>
    
    Signed-off-by: Franck Demathieu <fdemathieu@gmail.com>
    Cc: marc.zyngier@arm.com
    Cc: jason@lakedaemon.net
    Link: http://lkml.kernel.org/r/20170223094855.6546-1-fdemathieu@gmail.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index 1eef56a89b1f..05bbf171df37 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -198,7 +198,8 @@ static const struct irq_domain_ops crossbar_domain_ops = {
 
 static int __init crossbar_of_init(struct device_node *node)
 {
-	int i, size, max = 0, reserved = 0, entry;
+	int i, size, reserved = 0;
+	u32 max = 0, entry;
 	const __be32 *irqsr;
 	int ret = -ENOMEM;
 

commit a2a8fa5563d8740efaa8e62f653a6a85569c858b
Author: Jon Hunter <jonathanh@nvidia.com>
Date:   Tue May 10 16:14:37 2016 +0100

    irqchip: Mask the non-type/sense bits when translating an IRQ
    
    The firmware parameter that contains the IRQ sense bits may also contain
    other data. When return the IRQ type, bits outside of these sense bits
    should be masked. If these bits are not masked and
    irq_create_fwspec_mapping() is called to map an IRQ, then the comparison
    of the type returned from irq_domain_translate() will never match
    that returned by irq_get_trigger_type() (because this function masks the
    none sense bits) and so we will always call irq_set_irq_type() to program
    the type even if it was not really necessary.
    
    Currently, the downside to this is unnecessarily re-programmming the type
    but nevertheless this should be avoided.
    
    The Tegra LIC and TI Crossbar irqchips all have client instances (from
    reviewing the device-tree sources) where bits outside the IRQ sense bits
    are set, but do not mask these bits. Therefore, ensure these bits are
    masked for these irqchips.
    
    Signed-off-by: Jon Hunter <jonathanh@nvidia.com>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index 75573fa431ba..1eef56a89b1f 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -183,7 +183,7 @@ static int crossbar_domain_translate(struct irq_domain *d,
 			return -EINVAL;
 
 		*hwirq = fwspec->param[1];
-		*type = fwspec->param[2];
+		*type = fwspec->param[2] & IRQ_TYPE_SENSE_MASK;
 		return 0;
 	}
 

commit f833f57ff25450b7161798dceaf8575a48d80249
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Oct 13 12:51:33 2015 +0100

    irqchip: Convert all alloc/xlate users from of_node to fwnode
    
    Since we now have a generic data structure to express an
    interrupt specifier, convert all hierarchical irqchips that
    are OF based to use a fwnode_handle as part of their alloc
    and xlate (which becomes translate) callbacks.
    
    As most of these drivers have dependencies (they exchange IRQ
    specifiers), change them all in a single, massive patch...
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-and-tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Cc: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Cc: Graeme Gregory <graeme@xora.org.uk>
    Cc: Jake Oshins <jakeo@microsoft.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Link: http://lkml.kernel.org/r/1444737105-31573-6-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index f1d666a835a8..75573fa431ba 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -78,10 +78,13 @@ static struct irq_chip crossbar_chip = {
 static int allocate_gic_irq(struct irq_domain *domain, unsigned virq,
 			    irq_hw_number_t hwirq)
 {
-	struct of_phandle_args args;
+	struct irq_fwspec fwspec;
 	int i;
 	int err;
 
+	if (!irq_domain_get_of_node(domain->parent))
+		return -EINVAL;
+
 	raw_spin_lock(&cb->lock);
 	for (i = cb->int_max - 1; i >= 0; i--) {
 		if (cb->irq_map[i] == IRQ_FREE) {
@@ -94,13 +97,13 @@ static int allocate_gic_irq(struct irq_domain *domain, unsigned virq,
 	if (i < 0)
 		return -ENODEV;
 
-	args.np = irq_domain_get_of_node(domain->parent);
-	args.args_count = 3;
-	args.args[0] = 0;	/* SPI */
-	args.args[1] = i;
-	args.args[2] = IRQ_TYPE_LEVEL_HIGH;
+	fwspec.fwnode = domain->parent->fwnode;
+	fwspec.param_count = 3;
+	fwspec.param[0] = 0;	/* SPI */
+	fwspec.param[1] = i;
+	fwspec.param[2] = IRQ_TYPE_LEVEL_HIGH;
 
-	err = irq_domain_alloc_irqs_parent(domain, virq, 1, &args);
+	err = irq_domain_alloc_irqs_parent(domain, virq, 1, &fwspec);
 	if (err)
 		cb->irq_map[i] = IRQ_FREE;
 	else
@@ -112,16 +115,16 @@ static int allocate_gic_irq(struct irq_domain *domain, unsigned virq,
 static int crossbar_domain_alloc(struct irq_domain *d, unsigned int virq,
 				 unsigned int nr_irqs, void *data)
 {
-	struct of_phandle_args *args = data;
+	struct irq_fwspec *fwspec = data;
 	irq_hw_number_t hwirq;
 	int i;
 
-	if (args->args_count != 3)
+	if (fwspec->param_count != 3)
 		return -EINVAL;	/* Not GIC compliant */
-	if (args->args[0] != 0)
+	if (fwspec->param[0] != 0)
 		return -EINVAL;	/* No PPI should point to this domain */
 
-	hwirq = args->args[1];
+	hwirq = fwspec->param[1];
 	if ((hwirq + nr_irqs) > cb->max_crossbar_sources)
 		return -EINVAL;	/* Can't deal with this */
 
@@ -166,28 +169,31 @@ static void crossbar_domain_free(struct irq_domain *domain, unsigned int virq,
 	raw_spin_unlock(&cb->lock);
 }
 
-static int crossbar_domain_xlate(struct irq_domain *d,
-				 struct device_node *controller,
-				 const u32 *intspec, unsigned int intsize,
-				 unsigned long *out_hwirq,
-				 unsigned int *out_type)
+static int crossbar_domain_translate(struct irq_domain *d,
+				     struct irq_fwspec *fwspec,
+				     unsigned long *hwirq,
+				     unsigned int *type)
 {
-	if (irq_domain_get_of_node(d) != controller)
-		return -EINVAL;	/* Shouldn't happen, really... */
-	if (intsize != 3)
-		return -EINVAL;	/* Not GIC compliant */
-	if (intspec[0] != 0)
-		return -EINVAL;	/* No PPI should point to this domain */
+	if (is_of_node(fwspec->fwnode)) {
+		if (fwspec->param_count != 3)
+			return -EINVAL;
 
-	*out_hwirq = intspec[1];
-	*out_type = intspec[2];
-	return 0;
+		/* No PPI should point to this domain */
+		if (fwspec->param[0] != 0)
+			return -EINVAL;
+
+		*hwirq = fwspec->param[1];
+		*type = fwspec->param[2];
+		return 0;
+	}
+
+	return -EINVAL;
 }
 
 static const struct irq_domain_ops crossbar_domain_ops = {
-	.alloc	= crossbar_domain_alloc,
-	.free	= crossbar_domain_free,
-	.xlate	= crossbar_domain_xlate,
+	.alloc		= crossbar_domain_alloc,
+	.free		= crossbar_domain_free,
+	.translate	= crossbar_domain_translate,
 };
 
 static int __init crossbar_of_init(struct device_node *node)

commit 5d4c9bc7767bc86eb9a0e66df783e3fbada7dc97
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Oct 13 12:51:29 2015 +0100

    irqdomain: Use irq_domain_get_of_node() instead of direct field access
    
    The struct irq_domain contains a "struct device_node *" field
    (of_node) that is almost the only link between the irqdomain
    and the device tree infrastructure.
    
    In order to prepare for the removal of that field, convert all
    users to use irq_domain_get_of_node() instead.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-and-tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Cc: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Cc: Graeme Gregory <graeme@xora.org.uk>
    Cc: Jake Oshins <jakeo@microsoft.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Link: http://lkml.kernel.org/r/1444737105-31573-2-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index a7f5626930f5..f1d666a835a8 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -94,7 +94,7 @@ static int allocate_gic_irq(struct irq_domain *domain, unsigned virq,
 	if (i < 0)
 		return -ENODEV;
 
-	args.np = domain->parent->of_node;
+	args.np = irq_domain_get_of_node(domain->parent);
 	args.args_count = 3;
 	args.args[0] = 0;	/* SPI */
 	args.args[1] = i;
@@ -172,7 +172,7 @@ static int crossbar_domain_xlate(struct irq_domain *d,
 				 unsigned long *out_hwirq,
 				 unsigned int *out_type)
 {
-	if (d->of_node != controller)
+	if (irq_domain_get_of_node(d) != controller)
 		return -EINVAL;	/* Shouldn't happen, really... */
 	if (intsize != 3)
 		return -EINVAL;	/* Not GIC compliant */

commit 17e6b00ac422b49d44a0b8d98402a211f726282d
Merge: 5e359bf2219d e324c4dc4a59
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 1 14:33:35 2015 -0700

    Merge branch 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull irq updates from Thomas Gleixner:
     "This updated pull request does not contain the last few GIC related
      patches which were reported to cause a regression.  There is a fix
      available, but I let it breed for a couple of days first.
    
      The irq departement provides:
    
       - new infrastructure to support non PCI based MSI interrupts
       - a couple of new irq chip drivers
       - the usual pile of fixlets and updates to irq chip drivers
       - preparatory changes for removal of the irq argument from interrupt
         flow handlers
       - preparatory changes to remove IRQF_VALID"
    
    * 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (129 commits)
      irqchip/imx-gpcv2: IMX GPCv2 driver for wakeup sources
      irqchip: Add bcm2836 interrupt controller for Raspberry Pi 2
      irqchip: Add documentation for the bcm2836 interrupt controller
      irqchip/bcm2835: Add support for being used as a second level controller
      irqchip/bcm2835: Refactor handle_IRQ() calls out of MAKE_HWIRQ
      PCI: xilinx: Fix typo in function name
      irqchip/gic: Ensure gic_cpu_if_up/down() programs correct GIC instance
      irqchip/gic: Only allow the primary GIC to set the CPU map
      PCI/MSI: pci-xgene-msi: Consolidate chained IRQ handler install/remove
      unicore32/irq: Prepare puv3_gpio_handler for irq argument removal
      tile/pci_gx: Prepare trio_handle_level_irq for irq argument removal
      m68k/irq: Prepare irq handlers for irq argument removal
      C6X/megamode-pic: Prepare megamod_irq_cascade for irq argument removal
      blackfin: Prepare irq handlers for irq argument removal
      arc/irq: Prepare idu_cascade_isr for irq argument removal
      sparc/irq: Use access helper irq_data_get_affinity_mask()
      sparc/irq: Use helper irq_data_get_irq_handler_data()
      parisc/irq: Use access helper irq_data_get_affinity_mask()
      mn10300/irq: Use access helper irq_data_get_affinity_mask()
      irqchip/i8259: Prepare i8259_irq_dispatch for irq argument removal
      ...

commit 8200fe4347870d4ad6475048bcdf3e7c106c5268
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Fri Aug 14 15:20:30 2015 +0300

    irqchip/crossbar: Restore set_wake functionality
    
    The TI crossbar irqchip doesn't provides any facility to configure the
    wakeup sources, but the conversion to hierarchical irqdomains set the
    irq_set_wake callback to irq_chip_set_wake_parent. The parent chip
    (OMAP wakeupgen) has no irq_set_wake function either so the call will
    fail with -ENOSYS. As a result the irq_set_wake() call in the resume
    path will trigger an 'Unbalanced wake disable' warning.
    
    Before the conversion the GIC irqchip was the top level irqchip and
    correctly flagged with IRQCHIP_SKIP_SET_WAKE.
    
    Restore the correct behaviour by removing the irq_set_type callback
    from the crossbar irqchip and set the IRQCHIP_SKIP_SET_WAKE flag which
    lets the irq_set_irq_wake() call from the driver succeed.
    
    [ tglx: Massaged changelog ]
    
    Fixes: 783d31863fb8 ('irqchip: crossbar: Convert dra7 crossbar...')
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: <linux@arm.linux.org.uk>
    Cc: <nsekhar@ti.com>
    Cc: <jason@lakedaemon.net>
    Cc: <balbi@ti.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: <tony@atomide.com>
    Cc: <marc.zyngier@arm.com>
    Cc: stable@vger.kernel.org # 4.1
    Link: http://lkml.kernel.org/r/1439554830-19502-7-git-send-email-grygorii.strashko@ti.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index f5a72ccb4376..c12bb93334ff 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -68,9 +68,9 @@ static struct irq_chip crossbar_chip = {
 	.irq_mask		= irq_chip_mask_parent,
 	.irq_unmask		= irq_chip_unmask_parent,
 	.irq_retrigger		= irq_chip_retrigger_hierarchy,
-	.irq_set_wake		= irq_chip_set_wake_parent,
 	.irq_set_type		= irq_chip_set_type_parent,
-	.flags			= IRQCHIP_MASK_ON_SUSPEND,
+	.flags			= IRQCHIP_MASK_ON_SUSPEND |
+				  IRQCHIP_SKIP_SET_WAKE,
 #ifdef CONFIG_SMP
 	.irq_set_affinity	= irq_chip_set_affinity_parent,
 #endif

commit 4fd8f47e7e5b64a74b60f23c2e08ba8234d659d1
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Fri Aug 14 15:20:29 2015 +0300

    irqchip/crossbar: Restore the mask on suspend behaviour
    
    The ARM GIC requires that all interrupts which are not used as a
    wakeup source have to be masked during suspend.
    
    The conversion of the crossbar irqchip to hierarchical irq domains
    failed to mark the crossbar irqchip with the IRQCHIP_MASK_ON_SUSPEND
    flag and therefor broke the suspend requirement of the GIC.
    
    Before the conversion the flags were visible because the GIC was the
    top level irqchip. After the conversion the crossbar irqchip is the
    top level irq chip whose flags are evaluated in suspend_device_irq().
    As the flag is not set the masking of the non-wakeup irqs is not
    invoked which breaks suspend.
    
    Add the IRQCHIP_MASK_ON_SUSPEND flag to the crossbar irqchip, so the
    GIC interrupts get masked properly.
    
    [ tglx: Massaged changelog ]
    
    Fixes: 783d31863fb8 ('irqchip: crossbar: Convert dra7 crossbar...')
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: <linux@arm.linux.org.uk>
    Cc: <nsekhar@ti.com>
    Cc: <jason@lakedaemon.net>
    Cc: <balbi@ti.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: <tony@atomide.com>
    Cc: <marc.zyngier@arm.com>
    Cc: stable@vger.kernel.org # 4.1
    Link: http://lkml.kernel.org/r/1439554830-19502-6-git-send-email-grygorii.strashko@ti.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index 3ba58e7b4724..f5a72ccb4376 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -70,6 +70,7 @@ static struct irq_chip crossbar_chip = {
 	.irq_retrigger		= irq_chip_retrigger_hierarchy,
 	.irq_set_wake		= irq_chip_set_wake_parent,
 	.irq_set_type		= irq_chip_set_type_parent,
+	.flags			= IRQCHIP_MASK_ON_SUSPEND,
 #ifdef CONFIG_SMP
 	.irq_set_affinity	= irq_chip_set_affinity_parent,
 #endif

commit e269ec42328783e51be08c191aa935dba56141fc
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Fri Aug 14 15:20:27 2015 +0300

    irqchip/crossbar: Restore the irq_set_type() mechanism
    
    The conversion of the crossbar irqchip to hierarchical irq domains
    failed to provide a mechanism to properly set the trigger type of an
    interrupt.
    
    The crossbar irq chip itself has no mechanism and therefor no
    irq_set_type() callback. The code before the conversion relayed the
    trigger configuration directly to the underlying GIC.
    
    Restore the correct behaviour by setting the crossbar irq_set_type
    callback to irq_chip_set_type_parent(). This propagates the
    set_trigger() call to the underlying GIC irqchip.
    
    [ tglx: Massaged changelog ]
    
    Fixes: 783d31863fb8 ('irqchip: crossbar: Convert dra7 crossbar...')
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: <linux@arm.linux.org.uk>
    Cc: <nsekhar@ti.com>
    Cc: <jason@lakedaemon.net>
    Cc: <balbi@ti.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: <tony@atomide.com>
    Cc: <marc.zyngier@arm.com>
    Cc: stable@vger.kernel.org # 4.1
    Link: http://lkml.kernel.org/r/1439554830-19502-4-git-send-email-grygorii.strashko@ti.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index 692fe2bc8197..3ba58e7b4724 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -69,6 +69,7 @@ static struct irq_chip crossbar_chip = {
 	.irq_unmask		= irq_chip_unmask_parent,
 	.irq_retrigger		= irq_chip_retrigger_hierarchy,
 	.irq_set_wake		= irq_chip_set_wake_parent,
+	.irq_set_type		= irq_chip_set_type_parent,
 #ifdef CONFIG_SMP
 	.irq_set_affinity	= irq_chip_set_affinity_parent,
 #endif

commit 41a83e06e2bb9ac46731681fd44d1e6ab184dac5
Author: Joel Porquet <joel@porquet.org>
Date:   Tue Jul 7 17:11:46 2015 -0400

    irqchip: Prepare for local stub header removal
    
    The IRQCHIP_DECLARE macro moved to to 'include/linux/irqchip.h', so
    the local irqchip.h became an empty shell, which solely includes
    include/linux/irqchip.h
    
    Include the global header in all irqchip drivers instead of the local
    header, so we can remove it.
    
    Signed-off-by: Joel Porquet <joel@porquet.org>
    Cc: vgupta@synopsys.com
    Cc: monstr@monstr.eu
    Cc: ralf@linux-mips.org
    Cc: jason@lakedaemon.net
    Link: http://lkml.kernel.org/r/1882096.X39jVG8e0D@joel-zenbook
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index 692fe2bc8197..1240c4deda75 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -11,13 +11,12 @@
  */
 #include <linux/err.h>
 #include <linux/io.h>
+#include <linux/irqchip.h>
 #include <linux/irqdomain.h>
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
 #include <linux/slab.h>
 
-#include "irqchip.h"
-
 #define IRQ_FREE	-1
 #define IRQ_RESERVED	-2
 #define IRQ_SKIP	-3

commit 783d31863fb826f1a3754a2d5959a022a1b12d54
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Wed Mar 11 15:43:44 2015 +0000

    irqchip: crossbar: Convert dra7 crossbar to stacked domains
    
    Support for the TI crossbar used on the DRA7 family of chips
    is implemented as an ugly hack on the side of the GIC.
    
    Converting it to stacked domains makes it slightly more
    palatable, as it results in a cleanup.
    
    Unfortunately, as the DT bindings failed to acknowledge the
    fact that this is actually yet another interrupt controller
    (the third, actually), we have yet another breakage. Oh well.
    
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Link: https://lkml.kernel.org/r/1426088629-15377-3-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index bbbaf5de65d2..692fe2bc8197 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -11,11 +11,12 @@
  */
 #include <linux/err.h>
 #include <linux/io.h>
+#include <linux/irqdomain.h>
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
 #include <linux/slab.h>
-#include <linux/irqchip/arm-gic.h>
-#include <linux/irqchip/irq-crossbar.h>
+
+#include "irqchip.h"
 
 #define IRQ_FREE	-1
 #define IRQ_RESERVED	-2
@@ -24,6 +25,7 @@
 
 /**
  * struct crossbar_device - crossbar device description
+ * @lock: spinlock serializing access to @irq_map
  * @int_max: maximum number of supported interrupts
  * @safe_map: safe default value to initialize the crossbar
  * @max_crossbar_sources: Maximum number of crossbar sources
@@ -33,6 +35,7 @@
  * @write: register write function pointer
  */
 struct crossbar_device {
+	raw_spinlock_t lock;
 	uint int_max;
 	uint safe_map;
 	uint max_crossbar_sources;
@@ -44,72 +47,101 @@ struct crossbar_device {
 
 static struct crossbar_device *cb;
 
-static inline void crossbar_writel(int irq_no, int cb_no)
+static void crossbar_writel(int irq_no, int cb_no)
 {
 	writel(cb_no, cb->crossbar_base + cb->register_offsets[irq_no]);
 }
 
-static inline void crossbar_writew(int irq_no, int cb_no)
+static void crossbar_writew(int irq_no, int cb_no)
 {
 	writew(cb_no, cb->crossbar_base + cb->register_offsets[irq_no]);
 }
 
-static inline void crossbar_writeb(int irq_no, int cb_no)
+static void crossbar_writeb(int irq_no, int cb_no)
 {
 	writeb(cb_no, cb->crossbar_base + cb->register_offsets[irq_no]);
 }
 
-static inline int get_prev_map_irq(int cb_no)
-{
-	int i;
-
-	for (i = cb->int_max - 1; i >= 0; i--)
-		if (cb->irq_map[i] == cb_no)
-			return i;
-
-	return -ENODEV;
-}
+static struct irq_chip crossbar_chip = {
+	.name			= "CBAR",
+	.irq_eoi		= irq_chip_eoi_parent,
+	.irq_mask		= irq_chip_mask_parent,
+	.irq_unmask		= irq_chip_unmask_parent,
+	.irq_retrigger		= irq_chip_retrigger_hierarchy,
+	.irq_set_wake		= irq_chip_set_wake_parent,
+#ifdef CONFIG_SMP
+	.irq_set_affinity	= irq_chip_set_affinity_parent,
+#endif
+};
 
-static inline int allocate_free_irq(int cb_no)
+static int allocate_gic_irq(struct irq_domain *domain, unsigned virq,
+			    irq_hw_number_t hwirq)
 {
+	struct of_phandle_args args;
 	int i;
+	int err;
 
+	raw_spin_lock(&cb->lock);
 	for (i = cb->int_max - 1; i >= 0; i--) {
 		if (cb->irq_map[i] == IRQ_FREE) {
-			cb->irq_map[i] = cb_no;
-			return i;
+			cb->irq_map[i] = hwirq;
+			break;
 		}
 	}
+	raw_spin_unlock(&cb->lock);
 
-	return -ENODEV;
-}
+	if (i < 0)
+		return -ENODEV;
 
-static inline bool needs_crossbar_write(irq_hw_number_t hw)
-{
-	int cb_no;
+	args.np = domain->parent->of_node;
+	args.args_count = 3;
+	args.args[0] = 0;	/* SPI */
+	args.args[1] = i;
+	args.args[2] = IRQ_TYPE_LEVEL_HIGH;
 
-	if (hw > GIC_IRQ_START) {
-		cb_no = cb->irq_map[hw - GIC_IRQ_START];
-		if (cb_no != IRQ_RESERVED && cb_no != IRQ_SKIP)
-			return true;
-	}
+	err = irq_domain_alloc_irqs_parent(domain, virq, 1, &args);
+	if (err)
+		cb->irq_map[i] = IRQ_FREE;
+	else
+		cb->write(i, hwirq);
 
-	return false;
+	return err;
 }
 
-static int crossbar_domain_map(struct irq_domain *d, unsigned int irq,
-			       irq_hw_number_t hw)
+static int crossbar_domain_alloc(struct irq_domain *d, unsigned int virq,
+				 unsigned int nr_irqs, void *data)
 {
-	if (needs_crossbar_write(hw))
-		cb->write(hw - GIC_IRQ_START, cb->irq_map[hw - GIC_IRQ_START]);
+	struct of_phandle_args *args = data;
+	irq_hw_number_t hwirq;
+	int i;
+
+	if (args->args_count != 3)
+		return -EINVAL;	/* Not GIC compliant */
+	if (args->args[0] != 0)
+		return -EINVAL;	/* No PPI should point to this domain */
+
+	hwirq = args->args[1];
+	if ((hwirq + nr_irqs) > cb->max_crossbar_sources)
+		return -EINVAL;	/* Can't deal with this */
+
+	for (i = 0; i < nr_irqs; i++) {
+		int err = allocate_gic_irq(d, virq + i, hwirq + i);
+
+		if (err)
+			return err;
+
+		irq_domain_set_hwirq_and_chip(d, virq + i, hwirq + i,
+					      &crossbar_chip, NULL);
+	}
 
 	return 0;
 }
 
 /**
- * crossbar_domain_unmap - unmap a crossbar<->irq connection
- * @d: domain of irq to unmap
- * @irq: virq number
+ * crossbar_domain_free - unmap/free a crossbar<->irq connection
+ * @domain: domain of irq to unmap
+ * @virq: virq number
+ * @nr_irqs: number of irqs to free
  *
  * We do not maintain a use count of total number of map/unmap
  * calls for a particular irq to find out if a irq can be really
@@ -117,14 +149,20 @@ static int crossbar_domain_map(struct irq_domain *d, unsigned int irq,
  * after which irq is anyways unusable. So an explicit map has to be called
  * after that.
  */
-static void crossbar_domain_unmap(struct irq_domain *d, unsigned int irq)
+static void crossbar_domain_free(struct irq_domain *domain, unsigned int virq,
+				 unsigned int nr_irqs)
 {
-	irq_hw_number_t hw = irq_get_irq_data(irq)->hwirq;
+	int i;
 
-	if (needs_crossbar_write(hw)) {
-		cb->irq_map[hw - GIC_IRQ_START] = IRQ_FREE;
-		cb->write(hw - GIC_IRQ_START, cb->safe_map);
+	raw_spin_lock(&cb->lock);
+	for (i = 0; i < nr_irqs; i++) {
+		struct irq_data *d = irq_domain_get_irq_data(domain, virq + i);
+
+		irq_domain_reset_irq_data(d);
+		cb->irq_map[d->hwirq] = IRQ_FREE;
+		cb->write(d->hwirq, cb->safe_map);
 	}
+	raw_spin_unlock(&cb->lock);
 }
 
 static int crossbar_domain_xlate(struct irq_domain *d,
@@ -133,44 +171,22 @@ static int crossbar_domain_xlate(struct irq_domain *d,
 				 unsigned long *out_hwirq,
 				 unsigned int *out_type)
 {
-	int ret;
-	int req_num = intspec[1];
-	int direct_map_num;
-
-	if (req_num >= cb->max_crossbar_sources) {
-		direct_map_num = req_num - cb->max_crossbar_sources;
-		if (direct_map_num < cb->int_max) {
-			ret = cb->irq_map[direct_map_num];
-			if (ret == IRQ_RESERVED || ret == IRQ_SKIP) {
-				/* We use the interrupt num as h/w irq num */
-				ret = direct_map_num;
-				goto found;
-			}
-		}
-
-		pr_err("%s: requested crossbar number %d > max %d\n",
-		       __func__, req_num, cb->max_crossbar_sources);
-		return -EINVAL;
-	}
-
-	ret = get_prev_map_irq(req_num);
-	if (ret >= 0)
-		goto found;
-
-	ret = allocate_free_irq(req_num);
-
-	if (ret < 0)
-		return ret;
-
-found:
-	*out_hwirq = ret + GIC_IRQ_START;
+	if (d->of_node != controller)
+		return -EINVAL;	/* Shouldn't happen, really... */
+	if (intsize != 3)
+		return -EINVAL;	/* Not GIC compliant */
+	if (intspec[0] != 0)
+		return -EINVAL;	/* No PPI should point to this domain */
+
+	*out_hwirq = intspec[1];
+	*out_type = intspec[2];
 	return 0;
 }
 
-static const struct irq_domain_ops routable_irq_domain_ops = {
-	.map = crossbar_domain_map,
-	.unmap = crossbar_domain_unmap,
-	.xlate = crossbar_domain_xlate
+static const struct irq_domain_ops crossbar_domain_ops = {
+	.alloc	= crossbar_domain_alloc,
+	.free	= crossbar_domain_free,
+	.xlate	= crossbar_domain_xlate,
 };
 
 static int __init crossbar_of_init(struct device_node *node)
@@ -293,7 +309,8 @@ static int __init crossbar_of_init(struct device_node *node)
 		cb->write(i, cb->safe_map);
 	}
 
-	register_routable_domain_ops(&routable_irq_domain_ops);
+	raw_spin_lock_init(&cb->lock);
+
 	return 0;
 
 err_reg_offset:
@@ -309,18 +326,37 @@ static int __init crossbar_of_init(struct device_node *node)
 	return ret;
 }
 
-static const struct of_device_id crossbar_match[] __initconst = {
-	{ .compatible = "ti,irq-crossbar" },
-	{}
-};
-
-int __init irqcrossbar_init(void)
+static int __init irqcrossbar_init(struct device_node *node,
+				   struct device_node *parent)
 {
-	struct device_node *np;
-	np = of_find_matching_node(NULL, crossbar_match);
-	if (!np)
+	struct irq_domain *parent_domain, *domain;
+	int err;
+
+	if (!parent) {
+		pr_err("%s: no parent, giving up\n", node->full_name);
 		return -ENODEV;
+	}
+
+	parent_domain = irq_find_host(parent);
+	if (!parent_domain) {
+		pr_err("%s: unable to obtain parent domain\n", node->full_name);
+		return -ENXIO;
+	}
+
+	err = crossbar_of_init(node);
+	if (err)
+		return err;
+
+	domain = irq_domain_add_hierarchy(parent_domain, 0,
+					  cb->max_crossbar_sources,
+					  node, &crossbar_domain_ops,
+					  NULL);
+	if (!domain) {
+		pr_err("%s: failed to allocated domain\n", node->full_name);
+		return -ENOMEM;
+	}
 
-	crossbar_of_init(np);
 	return 0;
 }
+
+IRQCHIP_DECLARE(ti_irqcrossbar, "ti,irq-crossbar", irqcrossbar_init);

commit 702f7e36f74254e3e9c013eb969663433885cea7
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Aug 7 18:28:21 2014 +0300

    irqchip: crossbar: Off by one bugs in init
    
    My static checker complains that the ">" should be ">=" or else we go
    beyond the end of the cb->irq_map[] array on the next line.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index 85c2985d8bcb..bbbaf5de65d2 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -220,7 +220,7 @@ static int __init crossbar_of_init(struct device_node *node)
 			of_property_read_u32_index(node,
 						   "ti,irqs-reserved",
 						   i, &entry);
-			if (entry > max) {
+			if (entry >= max) {
 				pr_err("Invalid reserved entry\n");
 				ret = -EINVAL;
 				goto err_irq_map;
@@ -238,7 +238,7 @@ static int __init crossbar_of_init(struct device_node *node)
 			of_property_read_u32_index(node,
 						   "ti,irqs-skip",
 						   i, &entry);
-			if (entry > max) {
+			if (entry >= max) {
 				pr_err("Invalid skip entry\n");
 				ret = -EINVAL;
 				goto err_irq_map;

commit d360892d37b5d0e82595001c4be6d49311e2c265
Author: Nishanth Menon <nm@ti.com>
Date:   Thu Jun 26 12:40:34 2014 +0530

    irqchip: crossbar: Allow for quirky hardware with direct hardwiring of GIC
    
    On certain platforms such as DRA7, SPIs 0, 1, 2, 3, 5, 6, 10, 131,
    132, 133 are direct wired to hardware blocks bypassing crossbar.
    This quirky implementation is *NOT* supposed to be the expectation
    of crossbar hardware usage. However, these are already marked in our
    description of the hardware with SKIP and RESERVED where appropriate.
    
    Unfortunately, we need to be able to refer to these hardwired IRQs.
    So, to request these, crossbar driver can use the existing information
    from it's table that these SKIP/RESERVED maps are direct wired sources
    and generic allocation/programming of crossbar should be avoided.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Sricharan R <r.sricharan@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Link: https://lkml.kernel.org/r/1403766634-18543-17-git-send-email-r.sricharan@ti.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index 83f803bfab76..85c2985d8bcb 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -86,8 +86,13 @@ static inline int allocate_free_irq(int cb_no)
 
 static inline bool needs_crossbar_write(irq_hw_number_t hw)
 {
-	if (hw > GIC_IRQ_START)
-		return true;
+	int cb_no;
+
+	if (hw > GIC_IRQ_START) {
+		cb_no = cb->irq_map[hw - GIC_IRQ_START];
+		if (cb_no != IRQ_RESERVED && cb_no != IRQ_SKIP)
+			return true;
+	}
 
 	return false;
 }
@@ -130,8 +135,19 @@ static int crossbar_domain_xlate(struct irq_domain *d,
 {
 	int ret;
 	int req_num = intspec[1];
+	int direct_map_num;
 
 	if (req_num >= cb->max_crossbar_sources) {
+		direct_map_num = req_num - cb->max_crossbar_sources;
+		if (direct_map_num < cb->int_max) {
+			ret = cb->irq_map[direct_map_num];
+			if (ret == IRQ_RESERVED || ret == IRQ_SKIP) {
+				/* We use the interrupt num as h/w irq num */
+				ret = direct_map_num;
+				goto found;
+			}
+		}
+
 		pr_err("%s: requested crossbar number %d > max %d\n",
 		       __func__, req_num, cb->max_crossbar_sources);
 		return -EINVAL;

commit 29918b6790d92456cab87ff41a01224e0882d04a
Author: Nishanth Menon <nm@ti.com>
Date:   Thu Jun 26 12:40:32 2014 +0530

    irqchip: crossbar: Introduce centralized check for crossbar write
    
    This is a basic check to ensure that crossbar register needs to be
    written. This ensures that we have a common check which is used in
    both map and unmap logic.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Sricharan R <r.sricharan@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Link: https://lkml.kernel.org/r/1403766634-18543-15-git-send-email-r.sricharan@ti.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index c9f068ca7bc9..83f803bfab76 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -84,10 +84,20 @@ static inline int allocate_free_irq(int cb_no)
 	return -ENODEV;
 }
 
+static inline bool needs_crossbar_write(irq_hw_number_t hw)
+{
+	if (hw > GIC_IRQ_START)
+		return true;
+
+	return false;
+}
+
 static int crossbar_domain_map(struct irq_domain *d, unsigned int irq,
 			       irq_hw_number_t hw)
 {
-	cb->write(hw - GIC_IRQ_START, cb->irq_map[hw - GIC_IRQ_START]);
+	if (needs_crossbar_write(hw))
+		cb->write(hw - GIC_IRQ_START, cb->irq_map[hw - GIC_IRQ_START]);
+
 	return 0;
 }
 
@@ -106,7 +116,7 @@ static void crossbar_domain_unmap(struct irq_domain *d, unsigned int irq)
 {
 	irq_hw_number_t hw = irq_get_irq_data(irq)->hwirq;
 
-	if (hw > GIC_IRQ_START) {
+	if (needs_crossbar_write(hw)) {
 		cb->irq_map[hw - GIC_IRQ_START] = IRQ_FREE;
 		cb->write(hw - GIC_IRQ_START, cb->safe_map);
 	}

commit 2f7d2fb71dd0c14f9c0fe66f2ed7b4685fa745e2
Author: Nishanth Menon <nm@ti.com>
Date:   Thu Jun 26 12:40:31 2014 +0530

    irqchip: crossbar: Introduce ti, max-crossbar-sources to identify valid crossbar mapping
    
    Currently we attempt to map any crossbar value to an IRQ, however,
    this is not correct from hardware perspective. There is a max crossbar
    event number upto which hardware supports. So describe the same in
    device tree using 'ti,max-crossbar-sources' property and use it to
    validate requests.
    
    [ jac - remove MAX_SOURCES from binding doc, use integer because we
    shouldn't put implementation details in the binding docs ]
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Sricharan R <r.sricharan@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Link: https://lkml.kernel.org/r/1403766634-18543-14-git-send-email-r.sricharan@ti.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index 518d712c475a..c9f068ca7bc9 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -26,6 +26,7 @@
  * struct crossbar_device - crossbar device description
  * @int_max: maximum number of supported interrupts
  * @safe_map: safe default value to initialize the crossbar
+ * @max_crossbar_sources: Maximum number of crossbar sources
  * @irq_map: array of interrupts to crossbar number mapping
  * @crossbar_base: crossbar base address
  * @register_offsets: offsets for each irq number
@@ -34,6 +35,7 @@
 struct crossbar_device {
 	uint int_max;
 	uint safe_map;
+	uint max_crossbar_sources;
 	uint *irq_map;
 	void __iomem *crossbar_base;
 	int *register_offsets;
@@ -117,12 +119,19 @@ static int crossbar_domain_xlate(struct irq_domain *d,
 				 unsigned int *out_type)
 {
 	int ret;
+	int req_num = intspec[1];
 
-	ret = get_prev_map_irq(intspec[1]);
+	if (req_num >= cb->max_crossbar_sources) {
+		pr_err("%s: requested crossbar number %d > max %d\n",
+		       __func__, req_num, cb->max_crossbar_sources);
+		return -EINVAL;
+	}
+
+	ret = get_prev_map_irq(req_num);
 	if (ret >= 0)
 		goto found;
 
-	ret = allocate_free_irq(intspec[1]);
+	ret = allocate_free_irq(req_num);
 
 	if (ret < 0)
 		return ret;
@@ -153,6 +162,14 @@ static int __init crossbar_of_init(struct device_node *node)
 	if (!cb->crossbar_base)
 		goto err_cb;
 
+	of_property_read_u32(node, "ti,max-crossbar-sources",
+			     &cb->max_crossbar_sources);
+	if (!cb->max_crossbar_sources) {
+		pr_err("missing 'ti,max-crossbar-sources' property\n");
+		ret = -EINVAL;
+		goto err_base;
+	}
+
 	of_property_read_u32(node, "ti,max-irqs", &max);
 	if (!max) {
 		pr_err("missing 'ti,max-irqs' property\n");

commit 8b09a45dc12f83f2312a47f0f0087ec4004ebacc
Author: Sricharan R <r.sricharan@ti.com>
Date:   Thu Jun 26 12:40:30 2014 +0530

    irqchip: crossbar: Add kerneldoc for crossbar_domain_unmap callback
    
    Adding kerneldoc for unmap callback function.
    
    Signed-off-by: Sricharan R <r.sricharan@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Link: https://lkml.kernel.org/r/1403766634-18543-13-git-send-email-r.sricharan@ti.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index a8c615692803..518d712c475a 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -89,6 +89,17 @@ static int crossbar_domain_map(struct irq_domain *d, unsigned int irq,
 	return 0;
 }
 
+/**
+ * crossbar_domain_unmap - unmap a crossbar<->irq connection
+ * @d: domain of irq to unmap
+ * @irq: virq number
+ *
+ * We do not maintain a use count of total number of map/unmap
+ * calls for a particular irq to find out if a irq can be really
+ * unmapped. This is because unmap is called during irq_dispose_mapping(irq),
+ * after which irq is anyways unusable. So an explicit map has to be called
+ * after that.
+ */
 static void crossbar_domain_unmap(struct irq_domain *d, unsigned int irq)
 {
 	irq_hw_number_t hw = irq_get_irq_data(irq)->hwirq;

commit 99e37d0ea607623f286b4841cc355e65b297170c
Author: Sricharan R <r.sricharan@ti.com>
Date:   Thu Jun 26 12:40:29 2014 +0530

    irqchip: crossbar: Set cb pointer to null in case of error
    
    If crossbar_of_init returns with a error, then set the cb pointer
    to null.
    
    Signed-off-by: Sricharan R <r.sricharan@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Link: https://lkml.kernel.org/r/1403766634-18543-12-git-send-email-r.sricharan@ti.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index afc35fd1d9aa..a8c615692803 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -250,6 +250,8 @@ static int __init crossbar_of_init(struct device_node *node)
 	iounmap(cb->crossbar_base);
 err_cb:
 	kfree(cb);
+
+	cb = NULL;
 	return ret;
 }
 

commit 3c44d5151246947442f2fe8eede842e3f76dd2f1
Author: Nishanth Menon <nm@ti.com>
Date:   Thu Jun 26 12:40:28 2014 +0530

    irqchip: crossbar: Change the goto naming
    
    Using err1,2,3,4 etc makes it hard to ensure a new exit path in the
    middle will not result in spurious changes, so rename the error paths
    as per the function it does.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Sricharan R <r.sricharan@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Link: https://lkml.kernel.org/r/1403766634-18543-11-git-send-email-r.sricharan@ti.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index 10d723dfa348..afc35fd1d9aa 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -140,17 +140,17 @@ static int __init crossbar_of_init(struct device_node *node)
 
 	cb->crossbar_base = of_iomap(node, 0);
 	if (!cb->crossbar_base)
-		goto err1;
+		goto err_cb;
 
 	of_property_read_u32(node, "ti,max-irqs", &max);
 	if (!max) {
 		pr_err("missing 'ti,max-irqs' property\n");
 		ret = -EINVAL;
-		goto err2;
+		goto err_base;
 	}
 	cb->irq_map = kcalloc(max, sizeof(int), GFP_KERNEL);
 	if (!cb->irq_map)
-		goto err2;
+		goto err_base;
 
 	cb->int_max = max;
 
@@ -169,7 +169,7 @@ static int __init crossbar_of_init(struct device_node *node)
 			if (entry > max) {
 				pr_err("Invalid reserved entry\n");
 				ret = -EINVAL;
-				goto err3;
+				goto err_irq_map;
 			}
 			cb->irq_map[entry] = IRQ_RESERVED;
 		}
@@ -187,7 +187,7 @@ static int __init crossbar_of_init(struct device_node *node)
 			if (entry > max) {
 				pr_err("Invalid skip entry\n");
 				ret = -EINVAL;
-				goto err3;
+				goto err_irq_map;
 			}
 			cb->irq_map[entry] = IRQ_SKIP;
 		}
@@ -196,7 +196,7 @@ static int __init crossbar_of_init(struct device_node *node)
 
 	cb->register_offsets = kcalloc(max, sizeof(int), GFP_KERNEL);
 	if (!cb->register_offsets)
-		goto err3;
+		goto err_irq_map;
 
 	of_property_read_u32(node, "ti,reg-size", &size);
 
@@ -213,7 +213,7 @@ static int __init crossbar_of_init(struct device_node *node)
 	default:
 		pr_err("Invalid reg-size property\n");
 		ret = -EINVAL;
-		goto err4;
+		goto err_reg_offset;
 		break;
 	}
 
@@ -230,7 +230,6 @@ static int __init crossbar_of_init(struct device_node *node)
 	}
 
 	of_property_read_u32(node, "ti,irqs-safe-map", &cb->safe_map);
-
 	/* Initialize the crossbar with safe map to start with */
 	for (i = 0; i < max; i++) {
 		if (cb->irq_map[i] == IRQ_RESERVED ||
@@ -243,13 +242,13 @@ static int __init crossbar_of_init(struct device_node *node)
 	register_routable_domain_ops(&routable_irq_domain_ops);
 	return 0;
 
-err4:
+err_reg_offset:
 	kfree(cb->register_offsets);
-err3:
+err_irq_map:
 	kfree(cb->irq_map);
-err2:
+err_base:
 	iounmap(cb->crossbar_base);
-err1:
+err_cb:
 	kfree(cb);
 	return ret;
 }

commit edb442def98c3c64acc316b6b1a64791c138ab07
Author: Nishanth Menon <nm@ti.com>
Date:   Thu Jun 26 12:40:27 2014 +0530

    irqchip: crossbar: Return proper error value
    
    crossbar_of_init always returns -ENOMEM in case of errors.
    There can be other causes of failure like invalid data from
    DT. So return a appropriate error value for that case.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Sricharan R <r.sricharan@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Link: https://lkml.kernel.org/r/1403766634-18543-10-git-send-email-r.sricharan@ti.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index cee556bf603c..10d723dfa348 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -129,19 +129,25 @@ static const struct irq_domain_ops routable_irq_domain_ops = {
 
 static int __init crossbar_of_init(struct device_node *node)
 {
-	int i, size, max, reserved = 0, entry;
+	int i, size, max = 0, reserved = 0, entry;
 	const __be32 *irqsr;
+	int ret = -ENOMEM;
 
 	cb = kzalloc(sizeof(*cb), GFP_KERNEL);
 
 	if (!cb)
-		return -ENOMEM;
+		return ret;
 
 	cb->crossbar_base = of_iomap(node, 0);
 	if (!cb->crossbar_base)
 		goto err1;
 
 	of_property_read_u32(node, "ti,max-irqs", &max);
+	if (!max) {
+		pr_err("missing 'ti,max-irqs' property\n");
+		ret = -EINVAL;
+		goto err2;
+	}
 	cb->irq_map = kcalloc(max, sizeof(int), GFP_KERNEL);
 	if (!cb->irq_map)
 		goto err2;
@@ -162,6 +168,7 @@ static int __init crossbar_of_init(struct device_node *node)
 						   i, &entry);
 			if (entry > max) {
 				pr_err("Invalid reserved entry\n");
+				ret = -EINVAL;
 				goto err3;
 			}
 			cb->irq_map[entry] = IRQ_RESERVED;
@@ -205,6 +212,7 @@ static int __init crossbar_of_init(struct device_node *node)
 		break;
 	default:
 		pr_err("Invalid reg-size property\n");
+		ret = -EINVAL;
 		goto err4;
 		break;
 	}
@@ -243,7 +251,7 @@ static int __init crossbar_of_init(struct device_node *node)
 	iounmap(cb->crossbar_base);
 err1:
 	kfree(cb);
-	return -ENOMEM;
+	return ret;
 }
 
 static const struct of_device_id crossbar_match[] __initconst = {

commit e30ef8abb383903f2b7e1bced971b98fd30cafc3
Author: Nishanth Menon <nm@ti.com>
Date:   Thu Jun 26 12:40:26 2014 +0530

    irqchip: crossbar: Fix kerneldoc warning
    
    Adding missing properties for kerneldoc (@write) and cleanup
    of harmless warnings while we are here.
    
    kerneldoc warnings:
    Warning(drivers/irqchip/irq-crossbar.c:27): missing initial short description on line:
     * struct crossbar_device: crossbar device description
    Info(drivers/irqchip/irq-crossbar.c:27): Scanning doc for struct
    Warning(drivers/irqchip/irq-crossbar.c:39): No description found for parameter 'write'
    2 warnings
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Sricharan R <r.sricharan@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Link: https://lkml.kernel.org/r/1403766634-18543-9-git-send-email-r.sricharan@ti.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index f7eda9f5997e..cee556bf603c 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -22,12 +22,14 @@
 #define IRQ_SKIP	-3
 #define GIC_IRQ_START	32
 
-/*
+/**
+ * struct crossbar_device - crossbar device description
  * @int_max: maximum number of supported interrupts
  * @safe_map: safe default value to initialize the crossbar
  * @irq_map: array of interrupts to crossbar number mapping
  * @crossbar_base: crossbar base address
  * @register_offsets: offsets for each irq number
+ * @write: register write function pointer
  */
 struct crossbar_device {
 	uint int_max;

commit 4dbf45e3c2f3acfd2096cb6a731d159492ddca99
Author: Nishanth Menon <nm@ti.com>
Date:   Thu Jun 26 12:40:25 2014 +0530

    irqchip: crossbar: Fix sparse and checkpatch warnings
    
    There is absolutely no need for crossbar driver to expose functions and
    variables into global namespace. So make them all static
    
    Also fix a couple of checkpatch warnings.
    
    Fixes sparse warnings:
    drivers/irqchip/irq-crossbar.c:129:29: warning: symbol 'routable_irq_domain_ops' was not declared. Should it be static?
    drivers/irqchip/irq-crossbar.c:261:12: warning: symbol 'irqcrossbar_init' was not declared. Should it be static?
    
    Checkpatch warnings:
    WARNING: Prefer kcalloc over kzalloc with multiply
    +       cb->irq_map = kzalloc(max * sizeof(int), GFP_KERNEL);
    
    WARNING: Prefer kcalloc over kzalloc with multiply
    +       cb->register_offsets = kzalloc(max * sizeof(int), GFP_KERNEL);
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Sricharan R <r.sricharan@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Link: https://lkml.kernel.org/r/1403766634-18543-8-git-send-email-r.sricharan@ti.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index 88fbe0ff1dde..f7eda9f5997e 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -15,6 +15,7 @@
 #include <linux/of_irq.h>
 #include <linux/slab.h>
 #include <linux/irqchip/arm-gic.h>
+#include <linux/irqchip/irq-crossbar.h>
 
 #define IRQ_FREE	-1
 #define IRQ_RESERVED	-2
@@ -118,7 +119,7 @@ static int crossbar_domain_xlate(struct irq_domain *d,
 	return 0;
 }
 
-const struct irq_domain_ops routable_irq_domain_ops = {
+static const struct irq_domain_ops routable_irq_domain_ops = {
 	.map = crossbar_domain_map,
 	.unmap = crossbar_domain_unmap,
 	.xlate = crossbar_domain_xlate
@@ -139,7 +140,7 @@ static int __init crossbar_of_init(struct device_node *node)
 		goto err1;
 
 	of_property_read_u32(node, "ti,max-irqs", &max);
-	cb->irq_map = kzalloc(max * sizeof(int), GFP_KERNEL);
+	cb->irq_map = kcalloc(max, sizeof(int), GFP_KERNEL);
 	if (!cb->irq_map)
 		goto err2;
 
@@ -184,7 +185,7 @@ static int __init crossbar_of_init(struct device_node *node)
 	}
 
 
-	cb->register_offsets = kzalloc(max * sizeof(int), GFP_KERNEL);
+	cb->register_offsets = kcalloc(max, sizeof(int), GFP_KERNEL);
 	if (!cb->register_offsets)
 		goto err3;
 

commit d4922a95a70f0c8c5e45e22af629a5b5f370b867
Author: Nishanth Menon <nm@ti.com>
Date:   Thu Jun 26 12:40:24 2014 +0530

    irqchip: crossbar: Remove IS_ERR_VALUE check
    
    IS_ERR_VALUE makes sense only *if* there could be valid values in
    negative error range. But in the cases that we do use it, there is no
    such case. Just remove the same.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Sricharan R <r.sricharan@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Link: https://lkml.kernel.org/r/1403766634-18543-7-git-send-email-r.sricharan@ti.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index a39cb316d2b0..88fbe0ff1dde 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -102,15 +102,15 @@ static int crossbar_domain_xlate(struct irq_domain *d,
 				 unsigned long *out_hwirq,
 				 unsigned int *out_type)
 {
-	unsigned long ret;
+	int ret;
 
 	ret = get_prev_map_irq(intspec[1]);
-	if (!IS_ERR_VALUE(ret))
+	if (ret >= 0)
 		goto found;
 
 	ret = allocate_free_irq(intspec[1]);
 
-	if (IS_ERR_VALUE(ret))
+	if (ret < 0)
 		return ret;
 
 found:

commit ddee0fb46d26174e71ee1df225b9f9feaff05e10
Author: Nishanth Menon <nm@ti.com>
Date:   Thu Jun 26 12:40:23 2014 +0530

    irqchip: crossbar: Change allocation logic by reversing search for free irqs
    
    Reverse the search algorithm to ensure that address mapping and IRQ
    allocation logics are proper. This makes the below bugs visible sooner.
    
    class 1. address space errors -> example:
    reg = <a size_b>
    ti,max-irqs =  is a wrong parameter
    
    class 2: irq-reserved list - which decides which entries in the
    address space is not actually wired in
    
    class 3: wrong list of routable-irqs.
    
    In general allocating from max to min tends to have benefits in
    ensuring the different issues that may be present in dts is easily
    caught at definition time, rather than at a later point in time.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Sricharan R <r.sricharan@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Link: https://lkml.kernel.org/r/1403766634-18543-6-git-send-email-r.sricharan@ti.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index 4be30c00f041..a39cb316d2b0 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -58,7 +58,7 @@ static inline int get_prev_map_irq(int cb_no)
 {
 	int i;
 
-	for (i = 0; i < cb->int_max; i++)
+	for (i = cb->int_max - 1; i >= 0; i--)
 		if (cb->irq_map[i] == cb_no)
 			return i;
 
@@ -69,7 +69,7 @@ static inline int allocate_free_irq(int cb_no)
 {
 	int i;
 
-	for (i = 0; i < cb->int_max; i++) {
+	for (i = cb->int_max - 1; i >= 0; i--) {
 		if (cb->irq_map[i] == IRQ_FREE) {
 			cb->irq_map[i] = cb_no;
 			return i;

commit a35057d1dcb11ae67c9347ef7987cf65ac743c36
Author: Nishanth Menon <nm@ti.com>
Date:   Thu Jun 26 12:40:22 2014 +0530

    irqchip: crossbar: Initialise the crossbar with a safe value
    
    Since crossbar is s/w configurable, the initial settings of the
    crossbar cannot be assumed to be sane. This implies that:
    a) On initialization all un-reserved crossbars must be initialized to
       a known 'safe' value.
    b) When unmapping the interrupt, the safe value must be written to
       ensure that the crossbar mapping matches with interrupt controller
       usage.
    
    So provide a safe value in the dt data to map if
    '0' is not safe for the platform and use it during init and unmap
    
    While at this, fix the below checkpatch warning.
    Fixes checkpatch warning:
    WARNING: Unnecessary space before function pointer arguments
     #37: FILE: drivers/irqchip/irq-crossbar.c:37:
     +      void (*write) (int, int);
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Sricharan R <r.sricharan@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Link: https://lkml.kernel.org/r/1403766634-18543-5-git-send-email-r.sricharan@ti.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index 0533a71fa86f..4be30c00f041 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -23,16 +23,18 @@
 
 /*
  * @int_max: maximum number of supported interrupts
+ * @safe_map: safe default value to initialize the crossbar
  * @irq_map: array of interrupts to crossbar number mapping
  * @crossbar_base: crossbar base address
  * @register_offsets: offsets for each irq number
  */
 struct crossbar_device {
 	uint int_max;
+	uint safe_map;
 	uint *irq_map;
 	void __iomem *crossbar_base;
 	int *register_offsets;
-	void (*write) (int, int);
+	void (*write)(int, int);
 };
 
 static struct crossbar_device *cb;
@@ -88,8 +90,10 @@ static void crossbar_domain_unmap(struct irq_domain *d, unsigned int irq)
 {
 	irq_hw_number_t hw = irq_get_irq_data(irq)->hwirq;
 
-	if (hw > GIC_IRQ_START)
+	if (hw > GIC_IRQ_START) {
 		cb->irq_map[hw - GIC_IRQ_START] = IRQ_FREE;
+		cb->write(hw - GIC_IRQ_START, cb->safe_map);
+	}
 }
 
 static int crossbar_domain_xlate(struct irq_domain *d,
@@ -214,6 +218,17 @@ static int __init crossbar_of_init(struct device_node *node)
 		reserved += size;
 	}
 
+	of_property_read_u32(node, "ti,irqs-safe-map", &cb->safe_map);
+
+	/* Initialize the crossbar with safe map to start with */
+	for (i = 0; i < max; i++) {
+		if (cb->irq_map[i] == IRQ_RESERVED ||
+		    cb->irq_map[i] == IRQ_SKIP)
+			continue;
+
+		cb->write(i, cb->safe_map);
+	}
+
 	register_routable_domain_ops(&routable_irq_domain_ops);
 	return 0;
 

commit 64e0f8ba5cae74471f72e0cb218c67915e365f47
Author: Nishanth Menon <nm@ti.com>
Date:   Thu Jun 26 12:40:21 2014 +0530

    irqchip: crossbar: Introduce ti, irqs-skip to skip irqs that bypass crossbar
    
    When, in the system due to varied reasons, interrupts might be unusable
    due to hardware behavior, but register maps do exist, then those interrupts
    should be skipped while mapping irq to crossbars.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Sricharan R <r.sricharan@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Link: https://lkml.kernel.org/r/1403766634-18543-4-git-send-email-r.sricharan@ti.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index 51d4b878e5d6..0533a71fa86f 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -18,6 +18,7 @@
 
 #define IRQ_FREE	-1
 #define IRQ_RESERVED	-2
+#define IRQ_SKIP	-3
 #define GIC_IRQ_START	32
 
 /*
@@ -160,6 +161,25 @@ static int __init crossbar_of_init(struct device_node *node)
 		}
 	}
 
+	/* Skip irqs hardwired to bypass the crossbar */
+	irqsr = of_get_property(node, "ti,irqs-skip", &size);
+	if (irqsr) {
+		size /= sizeof(__be32);
+
+		for (i = 0; i < size; i++) {
+			of_property_read_u32_index(node,
+						   "ti,irqs-skip",
+						   i, &entry);
+			if (entry > max) {
+				pr_err("Invalid skip entry\n");
+				ret = -EINVAL;
+				goto err3;
+			}
+			cb->irq_map[entry] = IRQ_SKIP;
+		}
+	}
+
+
 	cb->register_offsets = kzalloc(max * sizeof(int), GFP_KERNEL);
 	if (!cb->register_offsets)
 		goto err3;

commit 6f16fc878a51572a998655e5ef1c396cb269648d
Author: Nishanth Menon <nm@ti.com>
Date:   Thu Jun 26 12:40:20 2014 +0530

    irqchip: crossbar: Check for premapped crossbar before allocating
    
    If irq_of_parse_and_map is executed twice, the same crossbar is mapped to two
    different GIC interrupts. This is completely undesirable. Instead, check
    if the requested crossbar event is pre-allocated and provide that GIC
    mapping back to caller if already allocated.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Sricharan R <r.sricharan@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Link: https://lkml.kernel.org/r/1403766634-18543-3-git-send-email-r.sricharan@ti.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index 20105bcdf408..51d4b878e5d6 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -51,6 +51,17 @@ static inline void crossbar_writeb(int irq_no, int cb_no)
 	writeb(cb_no, cb->crossbar_base + cb->register_offsets[irq_no]);
 }
 
+static inline int get_prev_map_irq(int cb_no)
+{
+	int i;
+
+	for (i = 0; i < cb->int_max; i++)
+		if (cb->irq_map[i] == cb_no)
+			return i;
+
+	return -ENODEV;
+}
+
 static inline int allocate_free_irq(int cb_no)
 {
 	int i;
@@ -88,11 +99,16 @@ static int crossbar_domain_xlate(struct irq_domain *d,
 {
 	unsigned long ret;
 
+	ret = get_prev_map_irq(intspec[1]);
+	if (!IS_ERR_VALUE(ret))
+		goto found;
+
 	ret = allocate_free_irq(intspec[1]);
 
 	if (IS_ERR_VALUE(ret))
 		return ret;
 
+found:
 	*out_hwirq = ret + GIC_IRQ_START;
 	return 0;
 }

commit 1d50d2ce6337724d30055bdbe082236cc86e6785
Author: Nishanth Menon <nm@ti.com>
Date:   Thu Jun 26 12:40:19 2014 +0530

    irqchip: crossbar: Dont use '0' to mark reserved interrupts
    
    Today '0' is actually reserved, but may not be the same in the future.
    
    So, use a flag to mark the GIC interrupts that are reserved.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Sricharan R <r.sricharan@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Link: https://lkml.kernel.org/r/1403766634-18543-2-git-send-email-r.sricharan@ti.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index 3d15d16a7088..20105bcdf408 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -17,6 +17,7 @@
 #include <linux/irqchip/arm-gic.h>
 
 #define IRQ_FREE	-1
+#define IRQ_RESERVED	-2
 #define GIC_IRQ_START	32
 
 /*
@@ -139,7 +140,7 @@ static int __init crossbar_of_init(struct device_node *node)
 				pr_err("Invalid reserved entry\n");
 				goto err3;
 			}
-			cb->irq_map[entry] = 0;
+			cb->irq_map[entry] = IRQ_RESERVED;
 		}
 	}
 
@@ -170,7 +171,7 @@ static int __init crossbar_of_init(struct device_node *node)
 	 * reserved irqs. so find and store the offsets once.
 	 */
 	for (i = 0; i < max; i++) {
-		if (!cb->irq_map[i])
+		if (cb->irq_map[i] == IRQ_RESERVED)
 			continue;
 
 		cb->register_offsets[i] = reserved;

commit 3894e9e82dfdc87fa35dc7976e0472d220228826
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Apr 3 10:21:34 2014 +0300

    irqchip: irq-crossbar: Not allocating enough memory
    
    We are allocating the size of a pointer and not the size of the data.
    This will lead to memory corruption.
    
    There isn't actually a "cb_device" struct, btw.  The code is only able
    to compile because GCC knows that all pointers are the same size.
    
    Fixes: 96ca848ef7ea ('DRIVERS: IRQCHIP: CROSSBAR: Add support for Crossbar IP')
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Acked-by: Sricharan R <r.sricharan@ti.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Link: http://lkml.kernel.org/r/20140403072134.GA14286@mwanda
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
index fc817d28d1fe..3d15d16a7088 100644
--- a/drivers/irqchip/irq-crossbar.c
+++ b/drivers/irqchip/irq-crossbar.c
@@ -107,7 +107,7 @@ static int __init crossbar_of_init(struct device_node *node)
 	int i, size, max, reserved = 0, entry;
 	const __be32 *irqsr;
 
-	cb = kzalloc(sizeof(struct cb_device *), GFP_KERNEL);
+	cb = kzalloc(sizeof(*cb), GFP_KERNEL);
 
 	if (!cb)
 		return -ENOMEM;

commit 96ca848ef7ea1be7e92d1cceb34ef3aa86053828
Author: Sricharan R <r.sricharan@ti.com>
Date:   Tue Dec 3 15:57:23 2013 +0530

    DRIVERS: IRQCHIP: CROSSBAR: Add support for Crossbar IP
    
    Some socs have a large number of interrupts requests to service
    the needs of its many peripherals and subsystems. All of the
    interrupt lines from the subsystems are not needed at the same
    time, so they have to be muxed to the irq-controller appropriately.
    In such places a interrupt controllers are preceded by an CROSSBAR
    that provides flexibility in muxing the device requests to the controller
    inputs.
    
    This driver takes care a allocating a free irq and then configuring the
    crossbar IP as a part of the mpu's irqchip callbacks. crossbar_init should
    be called right before the irqchip_init, so that it is setup to handle the
    irqchip callbacks.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Signed-off-by: Sricharan R <r.sricharan@ti.com>
    Acked-by: Kumar Gala <galak@codeaurora.org> (for DT binding portion)
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c
new file mode 100644
index 000000000000..fc817d28d1fe
--- /dev/null
+++ b/drivers/irqchip/irq-crossbar.c
@@ -0,0 +1,208 @@
+/*
+ *  drivers/irqchip/irq-crossbar.c
+ *
+ *  Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com
+ *  Author: Sricharan R <r.sricharan@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/slab.h>
+#include <linux/irqchip/arm-gic.h>
+
+#define IRQ_FREE	-1
+#define GIC_IRQ_START	32
+
+/*
+ * @int_max: maximum number of supported interrupts
+ * @irq_map: array of interrupts to crossbar number mapping
+ * @crossbar_base: crossbar base address
+ * @register_offsets: offsets for each irq number
+ */
+struct crossbar_device {
+	uint int_max;
+	uint *irq_map;
+	void __iomem *crossbar_base;
+	int *register_offsets;
+	void (*write) (int, int);
+};
+
+static struct crossbar_device *cb;
+
+static inline void crossbar_writel(int irq_no, int cb_no)
+{
+	writel(cb_no, cb->crossbar_base + cb->register_offsets[irq_no]);
+}
+
+static inline void crossbar_writew(int irq_no, int cb_no)
+{
+	writew(cb_no, cb->crossbar_base + cb->register_offsets[irq_no]);
+}
+
+static inline void crossbar_writeb(int irq_no, int cb_no)
+{
+	writeb(cb_no, cb->crossbar_base + cb->register_offsets[irq_no]);
+}
+
+static inline int allocate_free_irq(int cb_no)
+{
+	int i;
+
+	for (i = 0; i < cb->int_max; i++) {
+		if (cb->irq_map[i] == IRQ_FREE) {
+			cb->irq_map[i] = cb_no;
+			return i;
+		}
+	}
+
+	return -ENODEV;
+}
+
+static int crossbar_domain_map(struct irq_domain *d, unsigned int irq,
+			       irq_hw_number_t hw)
+{
+	cb->write(hw - GIC_IRQ_START, cb->irq_map[hw - GIC_IRQ_START]);
+	return 0;
+}
+
+static void crossbar_domain_unmap(struct irq_domain *d, unsigned int irq)
+{
+	irq_hw_number_t hw = irq_get_irq_data(irq)->hwirq;
+
+	if (hw > GIC_IRQ_START)
+		cb->irq_map[hw - GIC_IRQ_START] = IRQ_FREE;
+}
+
+static int crossbar_domain_xlate(struct irq_domain *d,
+				 struct device_node *controller,
+				 const u32 *intspec, unsigned int intsize,
+				 unsigned long *out_hwirq,
+				 unsigned int *out_type)
+{
+	unsigned long ret;
+
+	ret = allocate_free_irq(intspec[1]);
+
+	if (IS_ERR_VALUE(ret))
+		return ret;
+
+	*out_hwirq = ret + GIC_IRQ_START;
+	return 0;
+}
+
+const struct irq_domain_ops routable_irq_domain_ops = {
+	.map = crossbar_domain_map,
+	.unmap = crossbar_domain_unmap,
+	.xlate = crossbar_domain_xlate
+};
+
+static int __init crossbar_of_init(struct device_node *node)
+{
+	int i, size, max, reserved = 0, entry;
+	const __be32 *irqsr;
+
+	cb = kzalloc(sizeof(struct cb_device *), GFP_KERNEL);
+
+	if (!cb)
+		return -ENOMEM;
+
+	cb->crossbar_base = of_iomap(node, 0);
+	if (!cb->crossbar_base)
+		goto err1;
+
+	of_property_read_u32(node, "ti,max-irqs", &max);
+	cb->irq_map = kzalloc(max * sizeof(int), GFP_KERNEL);
+	if (!cb->irq_map)
+		goto err2;
+
+	cb->int_max = max;
+
+	for (i = 0; i < max; i++)
+		cb->irq_map[i] = IRQ_FREE;
+
+	/* Get and mark reserved irqs */
+	irqsr = of_get_property(node, "ti,irqs-reserved", &size);
+	if (irqsr) {
+		size /= sizeof(__be32);
+
+		for (i = 0; i < size; i++) {
+			of_property_read_u32_index(node,
+						   "ti,irqs-reserved",
+						   i, &entry);
+			if (entry > max) {
+				pr_err("Invalid reserved entry\n");
+				goto err3;
+			}
+			cb->irq_map[entry] = 0;
+		}
+	}
+
+	cb->register_offsets = kzalloc(max * sizeof(int), GFP_KERNEL);
+	if (!cb->register_offsets)
+		goto err3;
+
+	of_property_read_u32(node, "ti,reg-size", &size);
+
+	switch (size) {
+	case 1:
+		cb->write = crossbar_writeb;
+		break;
+	case 2:
+		cb->write = crossbar_writew;
+		break;
+	case 4:
+		cb->write = crossbar_writel;
+		break;
+	default:
+		pr_err("Invalid reg-size property\n");
+		goto err4;
+		break;
+	}
+
+	/*
+	 * Register offsets are not linear because of the
+	 * reserved irqs. so find and store the offsets once.
+	 */
+	for (i = 0; i < max; i++) {
+		if (!cb->irq_map[i])
+			continue;
+
+		cb->register_offsets[i] = reserved;
+		reserved += size;
+	}
+
+	register_routable_domain_ops(&routable_irq_domain_ops);
+	return 0;
+
+err4:
+	kfree(cb->register_offsets);
+err3:
+	kfree(cb->irq_map);
+err2:
+	iounmap(cb->crossbar_base);
+err1:
+	kfree(cb);
+	return -ENOMEM;
+}
+
+static const struct of_device_id crossbar_match[] __initconst = {
+	{ .compatible = "ti,irq-crossbar" },
+	{}
+};
+
+int __init irqcrossbar_init(void)
+{
+	struct device_node *np;
+	np = of_find_matching_node(NULL, crossbar_match);
+	if (!np)
+		return -ENODEV;
+
+	crossbar_of_init(np);
+	return 0;
+}
