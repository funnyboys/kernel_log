commit 287980e49ffc0f6d911601e7e352a812ed27768e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri May 27 23:23:25 2016 +0200

    remove lots of IS_ERR_VALUE abuses
    
    Most users of IS_ERR_VALUE() in the kernel are wrong, as they
    pass an 'int' into a function that takes an 'unsigned long'
    argument. This happens to work because the type is sign-extended
    on 64-bit architectures before it gets converted into an
    unsigned type.
    
    However, anything that passes an 'unsigned short' or 'unsigned int'
    argument into IS_ERR_VALUE() is guaranteed to be broken, as are
    8-bit integers and types that are wider than 'unsigned long'.
    
    Andrzej Hajda has already fixed a lot of the worst abusers that
    were causing actual bugs, but it would be nice to prevent any
    users that are not passing 'unsigned long' arguments.
    
    This patch changes all users of IS_ERR_VALUE() that I could find
    on 32-bit ARM randconfig builds and x86 allmodconfig. For the
    moment, this doesn't change the definition of IS_ERR_VALUE()
    because there are probably still architecture specific users
    elsewhere.
    
    Almost all the warnings I got are for files that are better off
    using 'if (err)' or 'if (err < 0)'.
    The only legitimate user I could find that we get a warning for
    is the (32-bit only) freescale fman driver, so I did not remove
    the IS_ERR_VALUE() there but changed the type to 'unsigned long'.
    For 9pfs, I just worked around one user whose calling conventions
    are so obscure that I did not dare change the behavior.
    
    I was using this definition for testing:
    
     #define IS_ERR_VALUE(x) ((unsigned long*)NULL == (typeof (x)*)NULL && \
           unlikely((unsigned long long)(x) >= (unsigned long long)(typeof(x))-MAX_ERRNO))
    
    which ends up making all 16-bit or wider types work correctly with
    the most plausible interpretation of what IS_ERR_VALUE() was supposed
    to return according to its users, but also causes a compile-time
    warning for any users that do not pass an 'unsigned long' argument.
    
    I suggested this approach earlier this year, but back then we ended
    up deciding to just fix the users that are obviously broken. After
    the initial warning that caused me to get involved in the discussion
    (fs/gfs2/dir.c) showed up again in the mainline kernel, Linus
    asked me to send the whole thing again.
    
    [ Updated the 9p parts as per Al Viro  - Linus ]
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Andrzej Hajda <a.hajda@samsung.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Link: https://lkml.org/lkml/2016/1/7/363
    Link: https://lkml.org/lkml/2016/5/27/486
    Acked-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org> # For nvmem part
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/irqchip/spear-shirq.c b/drivers/irqchip/spear-shirq.c
index 1ccd2abed65f..1518ba31a80c 100644
--- a/drivers/irqchip/spear-shirq.c
+++ b/drivers/irqchip/spear-shirq.c
@@ -232,7 +232,7 @@ static int __init shirq_init(struct spear_shirq **shirq_blocks, int block_nr,
 		nr_irqs += shirq_blocks[i]->nr_irqs;
 
 	virq_base = irq_alloc_descs(-1, 0, nr_irqs, 0);
-	if (IS_ERR_VALUE(virq_base)) {
+	if (virq_base < 0) {
 		pr_err("%s: irq desc alloc failed\n", __func__);
 		goto err_unmap;
 	}

commit d17cab4451df1f25f3a46369e0aaeaa18390fa6b
Author: Rob Herring <robh@kernel.org>
Date:   Sat Aug 29 18:01:22 2015 -0500

    irqchip: Kill off set_irq_flags usage
    
    set_irq_flags is ARM specific with custom flags which have genirq
    equivalents. Convert drivers to use the genirq interfaces directly, so we
    can kill off set_irq_flags. The translation of flags is as follows:
    
    IRQF_VALID -> !IRQ_NOREQUEST
    IRQF_PROBE -> !IRQ_NOPROBE
    IRQF_NOAUTOEN -> IRQ_NOAUTOEN
    
    For IRQs managed by an irqdomain, the irqdomain core code handles clearing
    and setting IRQ_NOREQUEST already, so there is no need to do this in
    .map() functions and we can simply remove the set_irq_flags calls. Some
    users also modify IRQ_NOPROBE and this has been maintained although it
    is not clear that is really needed. There appears to be a great deal of
    blind copy and paste of this code.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Lee Jones <lee@kernel.org>
    Cc: Alexander Shiyan <shc_work@mail.ru>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: linux-rpi-kernel@lists.infradead.org
    Cc: linux-samsung-soc@vger.kernel.org
    Link: http://lkml.kernel.org/r/1440889285-5637-3-git-send-email-robh@kernel.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/spear-shirq.c b/drivers/irqchip/spear-shirq.c
index c838c9286ea5..1ccd2abed65f 100644
--- a/drivers/irqchip/spear-shirq.c
+++ b/drivers/irqchip/spear-shirq.c
@@ -211,7 +211,6 @@ static void __init spear_shirq_register(struct spear_shirq *shirq,
 	for (i = 0; i < shirq->nr_irqs; i++) {
 		irq_set_chip_and_handler(shirq->virq_base + i,
 					 shirq->irq_chip, handle_simple_irq);
-		set_irq_flags(shirq->virq_base + i, IRQF_VALID);
 		irq_set_chip_data(shirq->virq_base + i, shirq);
 	}
 }

commit bd0b9ac405e1794d72533c3d487aa65b6b955a0c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 14 10:42:37 2015 +0200

    genirq: Remove irq argument from irq flow handlers
    
    Most interrupt flow handlers do not use the irq argument. Those few
    which use it can retrieve the irq number from the irq descriptor.
    
    Remove the argument.
    
    Search and replace was done with coccinelle and some extra helper
    scripts around it. Thanks to Julia for her help!
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>

diff --git a/drivers/irqchip/spear-shirq.c b/drivers/irqchip/spear-shirq.c
index 4cbd9c5dc1e6..c838c9286ea5 100644
--- a/drivers/irqchip/spear-shirq.c
+++ b/drivers/irqchip/spear-shirq.c
@@ -182,7 +182,7 @@ static struct spear_shirq *spear320_shirq_blocks[] = {
 	&spear320_shirq_intrcomm_ras,
 };
 
-static void shirq_handler(unsigned __irq, struct irq_desc *desc)
+static void shirq_handler(struct irq_desc *desc)
 {
 	struct spear_shirq *shirq = irq_desc_get_handler_data(desc);
 	u32 pend;

commit 4b979e4c611ce750d32b51737f837b485f43c69b
Merge: 1559f3b8d052 cbfe8fa6cd67
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jul 30 00:13:24 2015 +0200

    Merge branch 'linus' into irq/core
    
    Pull in upstream fixes before applying conflicting changes

commit da89947b47a3a355f33a75d7672892c147ed880d
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jul 17 16:23:50 2015 -0700

    Update Viresh Kumar's email address
    
    Switch to my kernel.org alias instead of a badly named gmail address,
    which I rarely use.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/irqchip/spear-shirq.c b/drivers/irqchip/spear-shirq.c
index a45121546caf..acb721b31bcf 100644
--- a/drivers/irqchip/spear-shirq.c
+++ b/drivers/irqchip/spear-shirq.c
@@ -2,7 +2,7 @@
  * SPEAr platform shared irq layer source file
  *
  * Copyright (C) 2009-2012 ST Microelectronics
- * Viresh Kumar <viresh.linux@gmail.com>
+ * Viresh Kumar <vireshk@kernel.org>
  *
  * Copyright (C) 2012 ST Microelectronics
  * Shiraz Hashim <shiraz.linux.kernel@gmail.com>

commit 9fc0fd6b052be4390138bb6c4bae07d6b7e1aa66
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jul 16 22:42:21 2015 +0200

    irqchip/spear-shirq: Prepare shirq_handler for irq argument removal
    
    The irq argument of most interrupt flow handlers is unused or merily
    used instead of a local variable. The handlers which need the irq
    argument can retrieve the irq number from the irq descriptor.
    
    Search and update was done with coccinelle and the invaluable help of
    Julia Lawall.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>

diff --git a/drivers/irqchip/spear-shirq.c b/drivers/irqchip/spear-shirq.c
index 61718550a064..ee175d2b9926 100644
--- a/drivers/irqchip/spear-shirq.c
+++ b/drivers/irqchip/spear-shirq.c
@@ -182,7 +182,7 @@ static struct spear_shirq *spear320_shirq_blocks[] = {
 	&spear320_shirq_intrcomm_ras,
 };
 
-static void shirq_handler(unsigned irq, struct irq_desc *desc)
+static void shirq_handler(unsigned __irq, struct irq_desc *desc)
 {
 	struct spear_shirq *shirq = irq_desc_get_handler_data(desc);
 	u32 pend;

commit 5b29264c659c31bada65582005d99adb3bb41fea
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Thu Jun 4 12:13:20 2015 +0800

    irqchip: Use irq_desc_get_xxx() to avoid redundant lookup of irq_desc
    
    Use irq_desc_get_xxx() to avoid redundant lookup of irq_desc while we
    already have a pointer to corresponding irq_desc.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Link: http://lkml.kernel.org/r/1433391238-19471-11-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/spear-shirq.c b/drivers/irqchip/spear-shirq.c
index 3df144f0f79b..61718550a064 100644
--- a/drivers/irqchip/spear-shirq.c
+++ b/drivers/irqchip/spear-shirq.c
@@ -184,7 +184,7 @@ static struct spear_shirq *spear320_shirq_blocks[] = {
 
 static void shirq_handler(unsigned irq, struct irq_desc *desc)
 {
-	struct spear_shirq *shirq = irq_get_handler_data(irq);
+	struct spear_shirq *shirq = irq_desc_get_handler_data(desc);
 	u32 pend;
 
 	pend = readl(shirq->base + shirq->status_reg) & shirq->mask;

commit 41a83e06e2bb9ac46731681fd44d1e6ab184dac5
Author: Joel Porquet <joel@porquet.org>
Date:   Tue Jul 7 17:11:46 2015 -0400

    irqchip: Prepare for local stub header removal
    
    The IRQCHIP_DECLARE macro moved to to 'include/linux/irqchip.h', so
    the local irqchip.h became an empty shell, which solely includes
    include/linux/irqchip.h
    
    Include the global header in all irqchip drivers instead of the local
    header, so we can remove it.
    
    Signed-off-by: Joel Porquet <joel@porquet.org>
    Cc: vgupta@synopsys.com
    Cc: monstr@monstr.eu
    Cc: ralf@linux-mips.org
    Cc: jason@lakedaemon.net
    Link: http://lkml.kernel.org/r/1882096.X39jVG8e0D@joel-zenbook
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/spear-shirq.c b/drivers/irqchip/spear-shirq.c
index a45121546caf..3df144f0f79b 100644
--- a/drivers/irqchip/spear-shirq.c
+++ b/drivers/irqchip/spear-shirq.c
@@ -18,14 +18,13 @@
 #include <linux/interrupt.h>
 #include <linux/io.h>
 #include <linux/irq.h>
+#include <linux/irqchip.h>
 #include <linux/irqdomain.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
 #include <linux/spinlock.h>
 
-#include "irqchip.h"
-
 /*
  * struct spear_shirq: shared irq structure
  *

commit 2aedd0fdc69467b1544773acf08333c6f0027e42
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Jun 16 23:07:01 2015 +0100

    irq: spear-shirq: Fix race in installing chained IRQ handler
    
    Fix a race where a pending interrupt could be received and the handler
    called before the handler's data has been setup, by converting to
    irq_set_chained_handler_and_data().
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Alexandre Courbot <gnurou@gmail.com>
    Cc: Hans Ulli Kroll <ulli.kroll@googlemail.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Lee Jones <lee.jones@linaro.org>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Link: http://lkml.kernel.org/r/E1Z4z0X-0002T1-6U@rmk-PC.arm.linux.org.uk
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/spear-shirq.c b/drivers/irqchip/spear-shirq.c
index 9c145a7cb056..a45121546caf 100644
--- a/drivers/irqchip/spear-shirq.c
+++ b/drivers/irqchip/spear-shirq.c
@@ -207,8 +207,7 @@ static void __init spear_shirq_register(struct spear_shirq *shirq,
 	if (!shirq->irq_chip)
 		return;
 
-	irq_set_chained_handler(parent_irq, shirq_handler);
-	irq_set_handler_data(parent_irq, shirq);
+	irq_set_chained_handler_and_data(parent_irq, shirq_handler, shirq);
 
 	for (i = 0; i < shirq->nr_irqs; i++) {
 		irq_set_chip_and_handler(shirq->virq_base + i,

commit 1b0a76c146adce782ddb8e71f01729f5f3671c66
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 19 21:34:44 2014 +0000

    irqchip: spear_shirq: Simplify register access code
    
    The extra register data structure is pointless. Move the offsets of
    the status and the mask register into the shirq block structure.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20140619212713.923306179@linutronix.de
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/spear-shirq.c b/drivers/irqchip/spear-shirq.c
index 169ef9a385d0..9c145a7cb056 100644
--- a/drivers/irqchip/spear-shirq.c
+++ b/drivers/irqchip/spear-shirq.c
@@ -26,25 +26,12 @@
 
 #include "irqchip.h"
 
-/*
- * struct shirq_regs: shared irq register configuration
- *
- * enb_reg: enable register offset
- * reset_to_enb: val 1 indicates, we need to clear bit for enabling interrupt
- * status_reg: status register offset
- * status_reg_mask: status register valid mask
- */
-struct shirq_regs {
-	u32 enb_reg;
-	u32 reset_to_enb;
-	u32 status_reg;
-};
-
 /*
  * struct spear_shirq: shared irq structure
  *
  * base:	Base register address
- * regs:	Register configuration for shared irq block
+ * status_reg:	Status register offset for chained interrupt handler
+ * mask_reg:	Mask register offset for irq chip
  * mask:	Mask to apply to the status register
  * virq_base:	Base virtual interrupt number
  * nr_irqs:	Number of interrupts handled by this block
@@ -54,7 +41,8 @@ struct shirq_regs {
  */
 struct spear_shirq {
 	void __iomem		*base;
-	struct shirq_regs	regs;
+	u32			status_reg;
+	u32			mask_reg;
 	u32			mask;
 	u32			virq_base;
 	u32			nr_irqs;
@@ -72,7 +60,7 @@ static void shirq_irq_mask(struct irq_data *d)
 {
 	struct spear_shirq *shirq = irq_data_get_irq_chip_data(d);
 	u32 val, shift = d->irq - shirq->virq_base + shirq->offset;
-	u32 __iomem *reg = shirq->base + shirq->regs.enb_reg;
+	u32 __iomem *reg = shirq->base + shirq->mask_reg;
 
 	raw_spin_lock(&shirq_lock);
 	val = readl(reg) & ~(0x1 << shift);
@@ -84,7 +72,7 @@ static void shirq_irq_unmask(struct irq_data *d)
 {
 	struct spear_shirq *shirq = irq_data_get_irq_chip_data(d);
 	u32 val, shift = d->irq - shirq->virq_base + shirq->offset;
-	u32 __iomem *reg = shirq->base + shirq->regs.enb_reg;
+	u32 __iomem *reg = shirq->base + shirq->mask_reg;
 
 	raw_spin_lock(&shirq_lock);
 	val = readl(reg) | (0x1 << shift);
@@ -103,10 +91,8 @@ static struct spear_shirq spear300_shirq_ras1 = {
 	.nr_irqs	= 9,
 	.mask		= ((0x1 << 9) - 1) << 0,
 	.irq_chip	= &shirq_chip,
-	.regs = {
-		.enb_reg = SPEAR300_INT_ENB_MASK_REG,
-		.status_reg = SPEAR300_INT_STS_MASK_REG,
-	},
+	.status_reg	= SPEAR300_INT_STS_MASK_REG,
+	.mask_reg	= SPEAR300_INT_ENB_MASK_REG,
 };
 
 static struct spear_shirq *spear300_shirq_blocks[] = {
@@ -121,9 +107,7 @@ static struct spear_shirq spear310_shirq_ras1 = {
 	.nr_irqs	= 8,
 	.mask		= ((0x1 << 8) - 1) << 0,
 	.irq_chip	= &dummy_irq_chip,
-	.regs = {
-		.status_reg = SPEAR310_INT_STS_MASK_REG,
-	},
+	.status_reg	= SPEAR310_INT_STS_MASK_REG,
 };
 
 static struct spear_shirq spear310_shirq_ras2 = {
@@ -131,10 +115,7 @@ static struct spear_shirq spear310_shirq_ras2 = {
 	.nr_irqs	= 5,
 	.mask		= ((0x1 << 5) - 1) << 8,
 	.irq_chip	= &dummy_irq_chip,
-	.regs = {
-		.enb_reg = -1,
-		.status_reg = SPEAR310_INT_STS_MASK_REG,
-	},
+	.status_reg	= SPEAR310_INT_STS_MASK_REG,
 };
 
 static struct spear_shirq spear310_shirq_ras3 = {
@@ -142,9 +123,7 @@ static struct spear_shirq spear310_shirq_ras3 = {
 	.nr_irqs	= 1,
 	.mask		= ((0x1 << 1) - 1) << 13,
 	.irq_chip	= &dummy_irq_chip,
-	.regs = {
-		.status_reg = SPEAR310_INT_STS_MASK_REG,
-	},
+	.status_reg	= SPEAR310_INT_STS_MASK_REG,
 };
 
 static struct spear_shirq spear310_shirq_intrcomm_ras = {
@@ -152,9 +131,7 @@ static struct spear_shirq spear310_shirq_intrcomm_ras = {
 	.nr_irqs	= 3,
 	.mask		= ((0x1 << 3) - 1) << 14,
 	.irq_chip	= &dummy_irq_chip,
-	.regs = {
-		.status_reg = SPEAR310_INT_STS_MASK_REG,
-	},
+	.status_reg	= SPEAR310_INT_STS_MASK_REG,
 };
 
 static struct spear_shirq *spear310_shirq_blocks[] = {
@@ -180,9 +157,7 @@ static struct spear_shirq spear320_shirq_ras1 = {
 	.nr_irqs	= 3,
 	.mask		= ((0x1 << 3) - 1) << 7,
 	.irq_chip	= &dummy_irq_chip,
-	.regs = {
-		.status_reg = SPEAR320_INT_STS_MASK_REG,
-	},
+	.status_reg	= SPEAR320_INT_STS_MASK_REG,
 };
 
 static struct spear_shirq spear320_shirq_ras2 = {
@@ -190,9 +165,7 @@ static struct spear_shirq spear320_shirq_ras2 = {
 	.nr_irqs	= 1,
 	.mask		= ((0x1 << 1) - 1) << 10,
 	.irq_chip	= &dummy_irq_chip,
-	.regs = {
-		.status_reg = SPEAR320_INT_STS_MASK_REG,
-	},
+	.status_reg	= SPEAR320_INT_STS_MASK_REG,
 };
 
 static struct spear_shirq spear320_shirq_intrcomm_ras = {
@@ -200,9 +173,7 @@ static struct spear_shirq spear320_shirq_intrcomm_ras = {
 	.nr_irqs	= 11,
 	.mask		= ((0x1 << 11) - 1) << 11,
 	.irq_chip	= &dummy_irq_chip,
-	.regs = {
-		.status_reg = SPEAR320_INT_STS_MASK_REG,
-	},
+	.status_reg	= SPEAR320_INT_STS_MASK_REG,
 };
 
 static struct spear_shirq *spear320_shirq_blocks[] = {
@@ -217,7 +188,7 @@ static void shirq_handler(unsigned irq, struct irq_desc *desc)
 	struct spear_shirq *shirq = irq_get_handler_data(irq);
 	u32 pend;
 
-	pend = readl(shirq->base + shirq->regs.status_reg) & shirq->mask;
+	pend = readl(shirq->base + shirq->status_reg) & shirq->mask;
 	pend >>= shirq->offset;
 
 	while (pend) {

commit f07e42f96f06dca3f9f897b956d83aec165ee693
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 19 21:34:43 2014 +0000

    irqchip: spear_shirq: Use proper irq chips for the different SoCs
    
    Only spear300 has an actual mask register for the RAS interrupts. Add
    an irq chip pointer to the shirq struct and initialize spear300 with
    the actual implementation and the others with dummy_irq_chip. The
    disabled RAS3 block has no irq chip assigned, so we can check for this
    and remove the disabled member.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20140619212713.831341023@linutronix.de
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/spear-shirq.c b/drivers/irqchip/spear-shirq.c
index 8765aa7f7a15..169ef9a385d0 100644
--- a/drivers/irqchip/spear-shirq.c
+++ b/drivers/irqchip/spear-shirq.c
@@ -49,7 +49,8 @@ struct shirq_regs {
  * virq_base:	Base virtual interrupt number
  * nr_irqs:	Number of interrupts handled by this block
  * offset:	Bit offset of the first interrupt
- * disabled:	Group is disabled, but accounted
+ * irq_chip:	Interrupt controller chip used for this instance,
+ *		if NULL group is disabled, but accounted
  */
 struct spear_shirq {
 	void __iomem		*base;
@@ -58,19 +59,50 @@ struct spear_shirq {
 	u32			virq_base;
 	u32			nr_irqs;
 	u32			offset;
-	bool			disabled;
+	struct irq_chip		*irq_chip;
 };
 
-static DEFINE_SPINLOCK(lock);
-
 /* spear300 shared irq registers offsets and masks */
 #define SPEAR300_INT_ENB_MASK_REG	0x54
 #define SPEAR300_INT_STS_MASK_REG	0x58
 
+static DEFINE_RAW_SPINLOCK(shirq_lock);
+
+static void shirq_irq_mask(struct irq_data *d)
+{
+	struct spear_shirq *shirq = irq_data_get_irq_chip_data(d);
+	u32 val, shift = d->irq - shirq->virq_base + shirq->offset;
+	u32 __iomem *reg = shirq->base + shirq->regs.enb_reg;
+
+	raw_spin_lock(&shirq_lock);
+	val = readl(reg) & ~(0x1 << shift);
+	writel(val, reg);
+	raw_spin_unlock(&shirq_lock);
+}
+
+static void shirq_irq_unmask(struct irq_data *d)
+{
+	struct spear_shirq *shirq = irq_data_get_irq_chip_data(d);
+	u32 val, shift = d->irq - shirq->virq_base + shirq->offset;
+	u32 __iomem *reg = shirq->base + shirq->regs.enb_reg;
+
+	raw_spin_lock(&shirq_lock);
+	val = readl(reg) | (0x1 << shift);
+	writel(val, reg);
+	raw_spin_unlock(&shirq_lock);
+}
+
+static struct irq_chip shirq_chip = {
+	.name		= "spear-shirq",
+	.irq_mask	= shirq_irq_mask,
+	.irq_unmask	= shirq_irq_unmask,
+};
+
 static struct spear_shirq spear300_shirq_ras1 = {
 	.offset		= 0,
 	.nr_irqs	= 9,
 	.mask		= ((0x1 << 9) - 1) << 0,
+	.irq_chip	= &shirq_chip,
 	.regs = {
 		.enb_reg = SPEAR300_INT_ENB_MASK_REG,
 		.status_reg = SPEAR300_INT_STS_MASK_REG,
@@ -88,8 +120,8 @@ static struct spear_shirq spear310_shirq_ras1 = {
 	.offset		= 0,
 	.nr_irqs	= 8,
 	.mask		= ((0x1 << 8) - 1) << 0,
+	.irq_chip	= &dummy_irq_chip,
 	.regs = {
-		.enb_reg = -1,
 		.status_reg = SPEAR310_INT_STS_MASK_REG,
 	},
 };
@@ -98,6 +130,7 @@ static struct spear_shirq spear310_shirq_ras2 = {
 	.offset		= 8,
 	.nr_irqs	= 5,
 	.mask		= ((0x1 << 5) - 1) << 8,
+	.irq_chip	= &dummy_irq_chip,
 	.regs = {
 		.enb_reg = -1,
 		.status_reg = SPEAR310_INT_STS_MASK_REG,
@@ -108,8 +141,8 @@ static struct spear_shirq spear310_shirq_ras3 = {
 	.offset		= 13,
 	.nr_irqs	= 1,
 	.mask		= ((0x1 << 1) - 1) << 13,
+	.irq_chip	= &dummy_irq_chip,
 	.regs = {
-		.enb_reg = -1,
 		.status_reg = SPEAR310_INT_STS_MASK_REG,
 	},
 };
@@ -118,8 +151,8 @@ static struct spear_shirq spear310_shirq_intrcomm_ras = {
 	.offset		= 14,
 	.nr_irqs	= 3,
 	.mask		= ((0x1 << 3) - 1) << 14,
+	.irq_chip	= &dummy_irq_chip,
 	.regs = {
-		.enb_reg = -1,
 		.status_reg = SPEAR310_INT_STS_MASK_REG,
 	},
 };
@@ -140,15 +173,14 @@ static struct spear_shirq spear320_shirq_ras3 = {
 	.offset		= 0,
 	.nr_irqs	= 7,
 	.mask		= ((0x1 << 7) - 1) << 0,
-	.disabled	= 1,
 };
 
 static struct spear_shirq spear320_shirq_ras1 = {
 	.offset		= 7,
 	.nr_irqs	= 3,
 	.mask		= ((0x1 << 3) - 1) << 7,
+	.irq_chip	= &dummy_irq_chip,
 	.regs = {
-		.enb_reg = -1,
 		.status_reg = SPEAR320_INT_STS_MASK_REG,
 	},
 };
@@ -157,8 +189,8 @@ static struct spear_shirq spear320_shirq_ras2 = {
 	.offset		= 10,
 	.nr_irqs	= 1,
 	.mask		= ((0x1 << 1) - 1) << 10,
+	.irq_chip	= &dummy_irq_chip,
 	.regs = {
-		.enb_reg = -1,
 		.status_reg = SPEAR320_INT_STS_MASK_REG,
 	},
 };
@@ -167,8 +199,8 @@ static struct spear_shirq spear320_shirq_intrcomm_ras = {
 	.offset		= 11,
 	.nr_irqs	= 11,
 	.mask		= ((0x1 << 11) - 1) << 11,
+	.irq_chip	= &dummy_irq_chip,
 	.regs = {
-		.enb_reg = -1,
 		.status_reg = SPEAR320_INT_STS_MASK_REG,
 	},
 };
@@ -180,45 +212,6 @@ static struct spear_shirq *spear320_shirq_blocks[] = {
 	&spear320_shirq_intrcomm_ras,
 };
 
-static void shirq_irq_mask_unmask(struct irq_data *d, bool mask)
-{
-	struct spear_shirq *shirq = irq_data_get_irq_chip_data(d);
-	u32 val, offset = d->irq - shirq->virq_base;
-	unsigned long flags;
-
-	if (shirq->regs.enb_reg == -1)
-		return;
-
-	spin_lock_irqsave(&lock, flags);
-	val = readl(shirq->base + shirq->regs.enb_reg);
-
-	if (mask ^ shirq->regs.reset_to_enb)
-		val &= ~(0x1 << shirq->offset << offset);
-	else
-		val |= 0x1 << shirq->offset << offset;
-
-	writel(val, shirq->base + shirq->regs.enb_reg);
-	spin_unlock_irqrestore(&lock, flags);
-
-}
-
-static void shirq_irq_mask(struct irq_data *d)
-{
-	shirq_irq_mask_unmask(d, 1);
-}
-
-static void shirq_irq_unmask(struct irq_data *d)
-{
-	shirq_irq_mask_unmask(d, 0);
-}
-
-static struct irq_chip shirq_chip = {
-	.name		= "spear-shirq",
-	.irq_ack	= shirq_irq_mask,
-	.irq_mask	= shirq_irq_mask,
-	.irq_unmask	= shirq_irq_unmask,
-};
-
 static void shirq_handler(unsigned irq, struct irq_desc *desc)
 {
 	struct spear_shirq *shirq = irq_get_handler_data(irq);
@@ -240,7 +233,7 @@ static void __init spear_shirq_register(struct spear_shirq *shirq,
 {
 	int i;
 
-	if (shirq->disabled)
+	if (!shirq->irq_chip)
 		return;
 
 	irq_set_chained_handler(parent_irq, shirq_handler);
@@ -248,7 +241,7 @@ static void __init spear_shirq_register(struct spear_shirq *shirq,
 
 	for (i = 0; i < shirq->nr_irqs; i++) {
 		irq_set_chip_and_handler(shirq->virq_base + i,
-					 &shirq_chip, handle_simple_irq);
+					 shirq->irq_chip, handle_simple_irq);
 		set_irq_flags(shirq->virq_base + i, IRQF_VALID);
 		irq_set_chip_data(shirq->virq_base + i, shirq);
 	}

commit fe64ac89cf8f5067cf7f6757b6cd9fd77c527bdf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 19 21:34:43 2014 +0000

    irqchip: spear_shirq: Remove the parent irq "ack"/unmask
    
    "ack" is actually a mask in the parent irq. The demultiplexer and the
    handlers run with interrupts disabled. No point in masking and
    unmasking the parent.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20140619212713.754300980@linutronix.de
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/spear-shirq.c b/drivers/irqchip/spear-shirq.c
index 8521a7295b02..8765aa7f7a15 100644
--- a/drivers/irqchip/spear-shirq.c
+++ b/drivers/irqchip/spear-shirq.c
@@ -222,12 +222,8 @@ static struct irq_chip shirq_chip = {
 static void shirq_handler(unsigned irq, struct irq_desc *desc)
 {
 	struct spear_shirq *shirq = irq_get_handler_data(irq);
-	struct irq_data *idata = irq_desc_get_irq_data(desc);
-	struct irq_chip *chip = irq_data_get_irq_chip(idata);
 	u32 pend;
 
-	chip->irq_ack(idata);
-
 	pend = readl(shirq->base + shirq->regs.status_reg) & shirq->mask;
 	pend >>= shirq->offset;
 
@@ -237,8 +233,6 @@ static void shirq_handler(unsigned irq, struct irq_desc *desc)
 		pend &= ~(0x1 << irq);
 		generic_handle_irq(shirq->virq_base + irq);
 	}
-
-	chip->irq_unmask(idata);
 }
 
 static void __init spear_shirq_register(struct spear_shirq *shirq,

commit 25dc49e3321a3b3f17b3f78297432073bb14ec0b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 19 21:34:42 2014 +0000

    irqchip: spear_shirq: Simplify chained handler
    
    I don't know if there are less efficient ways to code that. Get rid of
    the loop mess and use efficient code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20140619212713.662897061@linutronix.de
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/spear-shirq.c b/drivers/irqchip/spear-shirq.c
index 2a33129c4f4b..8521a7295b02 100644
--- a/drivers/irqchip/spear-shirq.c
+++ b/drivers/irqchip/spear-shirq.c
@@ -224,23 +224,20 @@ static void shirq_handler(unsigned irq, struct irq_desc *desc)
 	struct spear_shirq *shirq = irq_get_handler_data(irq);
 	struct irq_data *idata = irq_desc_get_irq_data(desc);
 	struct irq_chip *chip = irq_data_get_irq_chip(idata);
-	u32 i, j, val, mask;
+	u32 pend;
 
 	chip->irq_ack(idata);
 
-	mask = shirq->mask;
-	while ((val = readl(shirq->base + shirq->regs.status_reg) &
-				mask)) {
+	pend = readl(shirq->base + shirq->regs.status_reg) & shirq->mask;
+	pend >>= shirq->offset;
 
-		val >>= shirq->offset;
-		for (i = 0, j = 1; i < shirq->nr_irqs; i++, j <<= 1) {
+	while (pend) {
+		int irq = __ffs(pend);
 
-			if (!(j & val))
-				continue;
-
-			generic_handle_irq(shirq->virq_base + i);
-		}
+		pend &= ~(0x1 << irq);
+		generic_handle_irq(shirq->virq_base + irq);
 	}
+
 	chip->irq_unmask(idata);
 }
 

commit 97dcc21bd3dc7f04a48ff37700ae838feb35fca4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 19 21:34:41 2014 +0000

    irqchip: spear_shirq: Kill the clear_reg nonsense
    
    None of the chips has a ACK register. The code brainlessly fiddles
    with the enable register, so it might even reenable a disabled
    interrupt at least on spear300.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20140619212713.570396433@linutronix.de
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/spear-shirq.c b/drivers/irqchip/spear-shirq.c
index fc57c35a20b4..2a33129c4f4b 100644
--- a/drivers/irqchip/spear-shirq.c
+++ b/drivers/irqchip/spear-shirq.c
@@ -33,15 +33,11 @@
  * reset_to_enb: val 1 indicates, we need to clear bit for enabling interrupt
  * status_reg: status register offset
  * status_reg_mask: status register valid mask
- * clear_reg: clear register offset
- * reset_to_clear: val 1 indicates, we need to clear bit for clearing interrupt
  */
 struct shirq_regs {
 	u32 enb_reg;
 	u32 reset_to_enb;
 	u32 status_reg;
-	u32 clear_reg;
-	u32 reset_to_clear;
 };
 
 /*
@@ -78,7 +74,6 @@ static struct spear_shirq spear300_shirq_ras1 = {
 	.regs = {
 		.enb_reg = SPEAR300_INT_ENB_MASK_REG,
 		.status_reg = SPEAR300_INT_STS_MASK_REG,
-		.clear_reg = -1,
 	},
 };
 
@@ -96,7 +91,6 @@ static struct spear_shirq spear310_shirq_ras1 = {
 	.regs = {
 		.enb_reg = -1,
 		.status_reg = SPEAR310_INT_STS_MASK_REG,
-		.clear_reg = -1,
 	},
 };
 
@@ -107,7 +101,6 @@ static struct spear_shirq spear310_shirq_ras2 = {
 	.regs = {
 		.enb_reg = -1,
 		.status_reg = SPEAR310_INT_STS_MASK_REG,
-		.clear_reg = -1,
 	},
 };
 
@@ -118,7 +111,6 @@ static struct spear_shirq spear310_shirq_ras3 = {
 	.regs = {
 		.enb_reg = -1,
 		.status_reg = SPEAR310_INT_STS_MASK_REG,
-		.clear_reg = -1,
 	},
 };
 
@@ -129,7 +121,6 @@ static struct spear_shirq spear310_shirq_intrcomm_ras = {
 	.regs = {
 		.enb_reg = -1,
 		.status_reg = SPEAR310_INT_STS_MASK_REG,
-		.clear_reg = -1,
 	},
 };
 
@@ -150,13 +141,6 @@ static struct spear_shirq spear320_shirq_ras3 = {
 	.nr_irqs	= 7,
 	.mask		= ((0x1 << 7) - 1) << 0,
 	.disabled	= 1,
-	.regs = {
-		.enb_reg = SPEAR320_INT_ENB_MASK_REG,
-		.reset_to_enb = 1,
-		.status_reg = SPEAR320_INT_STS_MASK_REG,
-		.clear_reg = SPEAR320_INT_CLR_MASK_REG,
-		.reset_to_clear = 1,
-	},
 };
 
 static struct spear_shirq spear320_shirq_ras1 = {
@@ -166,8 +150,6 @@ static struct spear_shirq spear320_shirq_ras1 = {
 	.regs = {
 		.enb_reg = -1,
 		.status_reg = SPEAR320_INT_STS_MASK_REG,
-		.clear_reg = SPEAR320_INT_CLR_MASK_REG,
-		.reset_to_clear = 1,
 	},
 };
 
@@ -178,8 +160,6 @@ static struct spear_shirq spear320_shirq_ras2 = {
 	.regs = {
 		.enb_reg = -1,
 		.status_reg = SPEAR320_INT_STS_MASK_REG,
-		.clear_reg = SPEAR320_INT_CLR_MASK_REG,
-		.reset_to_clear = 1,
 	},
 };
 
@@ -190,8 +170,6 @@ static struct spear_shirq spear320_shirq_intrcomm_ras = {
 	.regs = {
 		.enb_reg = -1,
 		.status_reg = SPEAR320_INT_STS_MASK_REG,
-		.clear_reg = SPEAR320_INT_CLR_MASK_REG,
-		.reset_to_clear = 1,
 	},
 };
 
@@ -246,7 +224,7 @@ static void shirq_handler(unsigned irq, struct irq_desc *desc)
 	struct spear_shirq *shirq = irq_get_handler_data(irq);
 	struct irq_data *idata = irq_desc_get_irq_data(desc);
 	struct irq_chip *chip = irq_data_get_irq_chip(idata);
-	u32 i, j, val, mask, tmp;
+	u32 i, j, val, mask;
 
 	chip->irq_ack(idata);
 
@@ -261,17 +239,6 @@ static void shirq_handler(unsigned irq, struct irq_desc *desc)
 				continue;
 
 			generic_handle_irq(shirq->virq_base + i);
-
-			/* clear interrupt */
-			if (shirq->regs.clear_reg == -1)
-				continue;
-
-			tmp = readl(shirq->base + shirq->regs.clear_reg);
-			if (shirq->regs.reset_to_clear)
-				tmp &= ~(j << shirq->offset);
-			else
-				tmp |= (j << shirq->offset);
-			writel(tmp, shirq->base + shirq->regs.clear_reg);
 		}
 	}
 	chip->irq_unmask(idata);

commit 4ecc832f4ef25dcb684ca986de3612e881748c0e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 19 21:34:41 2014 +0000

    irqchip: spear_shirq: Precalculate status mask
    
    Calculate the status mask at compile time, not at runtime.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20140619212713.496614337@linutronix.de
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/spear-shirq.c b/drivers/irqchip/spear-shirq.c
index 874950c014be..fc57c35a20b4 100644
--- a/drivers/irqchip/spear-shirq.c
+++ b/drivers/irqchip/spear-shirq.c
@@ -49,6 +49,7 @@ struct shirq_regs {
  *
  * base:	Base register address
  * regs:	Register configuration for shared irq block
+ * mask:	Mask to apply to the status register
  * virq_base:	Base virtual interrupt number
  * nr_irqs:	Number of interrupts handled by this block
  * offset:	Bit offset of the first interrupt
@@ -57,6 +58,7 @@ struct shirq_regs {
 struct spear_shirq {
 	void __iomem		*base;
 	struct shirq_regs	regs;
+	u32			mask;
 	u32			virq_base;
 	u32			nr_irqs;
 	u32			offset;
@@ -72,6 +74,7 @@ static DEFINE_SPINLOCK(lock);
 static struct spear_shirq spear300_shirq_ras1 = {
 	.offset		= 0,
 	.nr_irqs	= 9,
+	.mask		= ((0x1 << 9) - 1) << 0,
 	.regs = {
 		.enb_reg = SPEAR300_INT_ENB_MASK_REG,
 		.status_reg = SPEAR300_INT_STS_MASK_REG,
@@ -89,6 +92,7 @@ static struct spear_shirq *spear300_shirq_blocks[] = {
 static struct spear_shirq spear310_shirq_ras1 = {
 	.offset		= 0,
 	.nr_irqs	= 8,
+	.mask		= ((0x1 << 8) - 1) << 0,
 	.regs = {
 		.enb_reg = -1,
 		.status_reg = SPEAR310_INT_STS_MASK_REG,
@@ -99,6 +103,7 @@ static struct spear_shirq spear310_shirq_ras1 = {
 static struct spear_shirq spear310_shirq_ras2 = {
 	.offset		= 8,
 	.nr_irqs	= 5,
+	.mask		= ((0x1 << 5) - 1) << 8,
 	.regs = {
 		.enb_reg = -1,
 		.status_reg = SPEAR310_INT_STS_MASK_REG,
@@ -109,6 +114,7 @@ static struct spear_shirq spear310_shirq_ras2 = {
 static struct spear_shirq spear310_shirq_ras3 = {
 	.offset		= 13,
 	.nr_irqs	= 1,
+	.mask		= ((0x1 << 1) - 1) << 13,
 	.regs = {
 		.enb_reg = -1,
 		.status_reg = SPEAR310_INT_STS_MASK_REG,
@@ -119,6 +125,7 @@ static struct spear_shirq spear310_shirq_ras3 = {
 static struct spear_shirq spear310_shirq_intrcomm_ras = {
 	.offset		= 14,
 	.nr_irqs	= 3,
+	.mask		= ((0x1 << 3) - 1) << 14,
 	.regs = {
 		.enb_reg = -1,
 		.status_reg = SPEAR310_INT_STS_MASK_REG,
@@ -141,6 +148,7 @@ static struct spear_shirq *spear310_shirq_blocks[] = {
 static struct spear_shirq spear320_shirq_ras3 = {
 	.offset		= 0,
 	.nr_irqs	= 7,
+	.mask		= ((0x1 << 7) - 1) << 0,
 	.disabled	= 1,
 	.regs = {
 		.enb_reg = SPEAR320_INT_ENB_MASK_REG,
@@ -154,6 +162,7 @@ static struct spear_shirq spear320_shirq_ras3 = {
 static struct spear_shirq spear320_shirq_ras1 = {
 	.offset		= 7,
 	.nr_irqs	= 3,
+	.mask		= ((0x1 << 3) - 1) << 7,
 	.regs = {
 		.enb_reg = -1,
 		.status_reg = SPEAR320_INT_STS_MASK_REG,
@@ -165,6 +174,7 @@ static struct spear_shirq spear320_shirq_ras1 = {
 static struct spear_shirq spear320_shirq_ras2 = {
 	.offset		= 10,
 	.nr_irqs	= 1,
+	.mask		= ((0x1 << 1) - 1) << 10,
 	.regs = {
 		.enb_reg = -1,
 		.status_reg = SPEAR320_INT_STS_MASK_REG,
@@ -176,6 +186,7 @@ static struct spear_shirq spear320_shirq_ras2 = {
 static struct spear_shirq spear320_shirq_intrcomm_ras = {
 	.offset		= 11,
 	.nr_irqs	= 11,
+	.mask		= ((0x1 << 11) - 1) << 11,
 	.regs = {
 		.enb_reg = -1,
 		.status_reg = SPEAR320_INT_STS_MASK_REG,
@@ -239,7 +250,7 @@ static void shirq_handler(unsigned irq, struct irq_desc *desc)
 
 	chip->irq_ack(idata);
 
-	mask = ((0x1 << shirq->nr_irqs) - 1) << shirq->offset;
+	mask = shirq->mask;
 	while ((val = readl(shirq->base + shirq->regs.status_reg) &
 				mask)) {
 

commit e3c871ab232ccc5fd82f76b21b9cae0113f01dc0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 19 21:34:40 2014 +0000

    irqchip: spear_shirq: Use the proper interfaces
    
    No point in doing a full irq lookup, when the desc pointer is
    available.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20140619212713.404243909@linutronix.de
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/spear-shirq.c b/drivers/irqchip/spear-shirq.c
index 7ebb1a2fbfc7..874950c014be 100644
--- a/drivers/irqchip/spear-shirq.c
+++ b/drivers/irqchip/spear-shirq.c
@@ -232,12 +232,12 @@ static struct irq_chip shirq_chip = {
 
 static void shirq_handler(unsigned irq, struct irq_desc *desc)
 {
-	u32 i, j, val, mask, tmp;
-	struct irq_chip *chip;
 	struct spear_shirq *shirq = irq_get_handler_data(irq);
+	struct irq_data *idata = irq_desc_get_irq_data(desc);
+	struct irq_chip *chip = irq_data_get_irq_chip(idata);
+	u32 i, j, val, mask, tmp;
 
-	chip = irq_get_chip(irq);
-	chip->irq_ack(&desc->irq_data);
+	chip->irq_ack(idata);
 
 	mask = ((0x1 << shirq->nr_irqs) - 1) << shirq->offset;
 	while ((val = readl(shirq->base + shirq->regs.status_reg) &
@@ -263,7 +263,7 @@ static void shirq_handler(unsigned irq, struct irq_desc *desc)
 			writel(tmp, shirq->base + shirq->regs.clear_reg);
 		}
 	}
-	chip->irq_unmask(&desc->irq_data);
+	chip->irq_unmask(idata);
 }
 
 static void __init spear_shirq_register(struct spear_shirq *shirq,

commit 03319a1a2966ec39be79182d6d529221c38fde72
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 19 21:34:40 2014 +0000

    irqchip: spear_shirq: Reorder the spear320 ras blocks
    
    Order the ras blocks in the order of interrupts not alphabetically.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20140619212713.310591579@linutronix.de
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/spear-shirq.c b/drivers/irqchip/spear-shirq.c
index f7c25a77845a..7ebb1a2fbfc7 100644
--- a/drivers/irqchip/spear-shirq.c
+++ b/drivers/irqchip/spear-shirq.c
@@ -138,20 +138,22 @@ static struct spear_shirq *spear310_shirq_blocks[] = {
 #define SPEAR320_INT_CLR_MASK_REG		0x04
 #define SPEAR320_INT_ENB_MASK_REG		0x08
 
-static struct spear_shirq spear320_shirq_ras1 = {
-	.offset		= 7,
-	.nr_irqs	= 3,
+static struct spear_shirq spear320_shirq_ras3 = {
+	.offset		= 0,
+	.nr_irqs	= 7,
+	.disabled	= 1,
 	.regs = {
-		.enb_reg = -1,
+		.enb_reg = SPEAR320_INT_ENB_MASK_REG,
+		.reset_to_enb = 1,
 		.status_reg = SPEAR320_INT_STS_MASK_REG,
 		.clear_reg = SPEAR320_INT_CLR_MASK_REG,
 		.reset_to_clear = 1,
 	},
 };
 
-static struct spear_shirq spear320_shirq_ras2 = {
-	.offset		= 10,
-	.nr_irqs	= 1,
+static struct spear_shirq spear320_shirq_ras1 = {
+	.offset		= 7,
+	.nr_irqs	= 3,
 	.regs = {
 		.enb_reg = -1,
 		.status_reg = SPEAR320_INT_STS_MASK_REG,
@@ -160,13 +162,11 @@ static struct spear_shirq spear320_shirq_ras2 = {
 	},
 };
 
-static struct spear_shirq spear320_shirq_ras3 = {
-	.offset		= 0,
-	.nr_irqs	= 7,
-	.disabled	= 1,
+static struct spear_shirq spear320_shirq_ras2 = {
+	.offset		= 10,
+	.nr_irqs	= 1,
 	.regs = {
-		.enb_reg = SPEAR320_INT_ENB_MASK_REG,
-		.reset_to_enb = 1,
+		.enb_reg = -1,
 		.status_reg = SPEAR320_INT_STS_MASK_REG,
 		.clear_reg = SPEAR320_INT_CLR_MASK_REG,
 		.reset_to_clear = 1,

commit c5d1d857482b080875640bb68bc9d8b65ad29b6f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 19 21:34:39 2014 +0000

    irqchip: spear_shirq: Namespace cleanup
    
    The struct members of the shirq block struct are named to confuse the
    hell out of the casual reader. Clean it up.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20140619212713.219411832@linutronix.de
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/spear-shirq.c b/drivers/irqchip/spear-shirq.c
index 576968efbc4d..f7c25a77845a 100644
--- a/drivers/irqchip/spear-shirq.c
+++ b/drivers/irqchip/spear-shirq.c
@@ -47,20 +47,20 @@ struct shirq_regs {
 /*
  * struct spear_shirq: shared irq structure
  *
- * irq_base: base irq in linux domain
- * irq_nr: no. of shared interrupts in a particular block
- * irq_bit_off: starting bit offset in the status register
- * invalid_irq: irq group is currently disabled
- * base: base address of shared irq register
- * regs: register configuration for shared irq block
+ * base:	Base register address
+ * regs:	Register configuration for shared irq block
+ * virq_base:	Base virtual interrupt number
+ * nr_irqs:	Number of interrupts handled by this block
+ * offset:	Bit offset of the first interrupt
+ * disabled:	Group is disabled, but accounted
  */
 struct spear_shirq {
-	u32 irq_base;
-	u32 irq_nr;
-	u32 irq_bit_off;
-	int invalid_irq;
-	void __iomem *base;
-	struct shirq_regs regs;
+	void __iomem		*base;
+	struct shirq_regs	regs;
+	u32			virq_base;
+	u32			nr_irqs;
+	u32			offset;
+	bool			disabled;
 };
 
 static DEFINE_SPINLOCK(lock);
@@ -70,8 +70,8 @@ static DEFINE_SPINLOCK(lock);
 #define SPEAR300_INT_STS_MASK_REG	0x58
 
 static struct spear_shirq spear300_shirq_ras1 = {
-	.irq_nr = 9,
-	.irq_bit_off = 0,
+	.offset		= 0,
+	.nr_irqs	= 9,
 	.regs = {
 		.enb_reg = SPEAR300_INT_ENB_MASK_REG,
 		.status_reg = SPEAR300_INT_STS_MASK_REG,
@@ -87,8 +87,8 @@ static struct spear_shirq *spear300_shirq_blocks[] = {
 #define SPEAR310_INT_STS_MASK_REG	0x04
 
 static struct spear_shirq spear310_shirq_ras1 = {
-	.irq_nr = 8,
-	.irq_bit_off = 0,
+	.offset		= 0,
+	.nr_irqs	= 8,
 	.regs = {
 		.enb_reg = -1,
 		.status_reg = SPEAR310_INT_STS_MASK_REG,
@@ -97,8 +97,8 @@ static struct spear_shirq spear310_shirq_ras1 = {
 };
 
 static struct spear_shirq spear310_shirq_ras2 = {
-	.irq_nr = 5,
-	.irq_bit_off = 8,
+	.offset		= 8,
+	.nr_irqs	= 5,
 	.regs = {
 		.enb_reg = -1,
 		.status_reg = SPEAR310_INT_STS_MASK_REG,
@@ -107,8 +107,8 @@ static struct spear_shirq spear310_shirq_ras2 = {
 };
 
 static struct spear_shirq spear310_shirq_ras3 = {
-	.irq_nr = 1,
-	.irq_bit_off = 13,
+	.offset		= 13,
+	.nr_irqs	= 1,
 	.regs = {
 		.enb_reg = -1,
 		.status_reg = SPEAR310_INT_STS_MASK_REG,
@@ -117,8 +117,8 @@ static struct spear_shirq spear310_shirq_ras3 = {
 };
 
 static struct spear_shirq spear310_shirq_intrcomm_ras = {
-	.irq_nr = 3,
-	.irq_bit_off = 14,
+	.offset		= 14,
+	.nr_irqs	= 3,
 	.regs = {
 		.enb_reg = -1,
 		.status_reg = SPEAR310_INT_STS_MASK_REG,
@@ -139,8 +139,8 @@ static struct spear_shirq *spear310_shirq_blocks[] = {
 #define SPEAR320_INT_ENB_MASK_REG		0x08
 
 static struct spear_shirq spear320_shirq_ras1 = {
-	.irq_nr = 3,
-	.irq_bit_off = 7,
+	.offset		= 7,
+	.nr_irqs	= 3,
 	.regs = {
 		.enb_reg = -1,
 		.status_reg = SPEAR320_INT_STS_MASK_REG,
@@ -150,8 +150,8 @@ static struct spear_shirq spear320_shirq_ras1 = {
 };
 
 static struct spear_shirq spear320_shirq_ras2 = {
-	.irq_nr = 1,
-	.irq_bit_off = 10,
+	.offset		= 10,
+	.nr_irqs	= 1,
 	.regs = {
 		.enb_reg = -1,
 		.status_reg = SPEAR320_INT_STS_MASK_REG,
@@ -161,9 +161,9 @@ static struct spear_shirq spear320_shirq_ras2 = {
 };
 
 static struct spear_shirq spear320_shirq_ras3 = {
-	.irq_nr = 7,
-	.irq_bit_off = 0,
-	.invalid_irq = 1,
+	.offset		= 0,
+	.nr_irqs	= 7,
+	.disabled	= 1,
 	.regs = {
 		.enb_reg = SPEAR320_INT_ENB_MASK_REG,
 		.reset_to_enb = 1,
@@ -174,8 +174,8 @@ static struct spear_shirq spear320_shirq_ras3 = {
 };
 
 static struct spear_shirq spear320_shirq_intrcomm_ras = {
-	.irq_nr = 11,
-	.irq_bit_off = 11,
+	.offset		= 11,
+	.nr_irqs	= 11,
 	.regs = {
 		.enb_reg = -1,
 		.status_reg = SPEAR320_INT_STS_MASK_REG,
@@ -194,7 +194,7 @@ static struct spear_shirq *spear320_shirq_blocks[] = {
 static void shirq_irq_mask_unmask(struct irq_data *d, bool mask)
 {
 	struct spear_shirq *shirq = irq_data_get_irq_chip_data(d);
-	u32 val, offset = d->irq - shirq->irq_base;
+	u32 val, offset = d->irq - shirq->virq_base;
 	unsigned long flags;
 
 	if (shirq->regs.enb_reg == -1)
@@ -204,9 +204,9 @@ static void shirq_irq_mask_unmask(struct irq_data *d, bool mask)
 	val = readl(shirq->base + shirq->regs.enb_reg);
 
 	if (mask ^ shirq->regs.reset_to_enb)
-		val &= ~(0x1 << shirq->irq_bit_off << offset);
+		val &= ~(0x1 << shirq->offset << offset);
 	else
-		val |= 0x1 << shirq->irq_bit_off << offset;
+		val |= 0x1 << shirq->offset << offset;
 
 	writel(val, shirq->base + shirq->regs.enb_reg);
 	spin_unlock_irqrestore(&lock, flags);
@@ -239,17 +239,17 @@ static void shirq_handler(unsigned irq, struct irq_desc *desc)
 	chip = irq_get_chip(irq);
 	chip->irq_ack(&desc->irq_data);
 
-	mask = ((0x1 << shirq->irq_nr) - 1) << shirq->irq_bit_off;
+	mask = ((0x1 << shirq->nr_irqs) - 1) << shirq->offset;
 	while ((val = readl(shirq->base + shirq->regs.status_reg) &
 				mask)) {
 
-		val >>= shirq->irq_bit_off;
-		for (i = 0, j = 1; i < shirq->irq_nr; i++, j <<= 1) {
+		val >>= shirq->offset;
+		for (i = 0, j = 1; i < shirq->nr_irqs; i++, j <<= 1) {
 
 			if (!(j & val))
 				continue;
 
-			generic_handle_irq(shirq->irq_base + i);
+			generic_handle_irq(shirq->virq_base + i);
 
 			/* clear interrupt */
 			if (shirq->regs.clear_reg == -1)
@@ -257,9 +257,9 @@ static void shirq_handler(unsigned irq, struct irq_desc *desc)
 
 			tmp = readl(shirq->base + shirq->regs.clear_reg);
 			if (shirq->regs.reset_to_clear)
-				tmp &= ~(j << shirq->irq_bit_off);
+				tmp &= ~(j << shirq->offset);
 			else
-				tmp |= (j << shirq->irq_bit_off);
+				tmp |= (j << shirq->offset);
 			writel(tmp, shirq->base + shirq->regs.clear_reg);
 		}
 	}
@@ -271,24 +271,24 @@ static void __init spear_shirq_register(struct spear_shirq *shirq,
 {
 	int i;
 
-	if (shirq->invalid_irq)
+	if (shirq->disabled)
 		return;
 
 	irq_set_chained_handler(parent_irq, shirq_handler);
 	irq_set_handler_data(parent_irq, shirq);
 
-	for (i = 0; i < shirq->irq_nr; i++) {
-		irq_set_chip_and_handler(shirq->irq_base + i,
+	for (i = 0; i < shirq->nr_irqs; i++) {
+		irq_set_chip_and_handler(shirq->virq_base + i,
 					 &shirq_chip, handle_simple_irq);
-		set_irq_flags(shirq->irq_base + i, IRQF_VALID);
-		irq_set_chip_data(shirq->irq_base + i, shirq);
+		set_irq_flags(shirq->virq_base + i, IRQF_VALID);
+		irq_set_chip_data(shirq->virq_base + i, shirq);
 	}
 }
 
 static int __init shirq_init(struct spear_shirq **shirq_blocks, int block_nr,
 		struct device_node *np)
 {
-	int i, parent_irq, irq_base, hwirq = 0, irq_nr = 0;
+	int i, parent_irq, virq_base, hwirq = 0, nr_irqs = 0;
 	struct irq_domain *shirq_domain;
 	void __iomem *base;
 
@@ -299,15 +299,15 @@ static int __init shirq_init(struct spear_shirq **shirq_blocks, int block_nr,
 	}
 
 	for (i = 0; i < block_nr; i++)
-		irq_nr += shirq_blocks[i]->irq_nr;
+		nr_irqs += shirq_blocks[i]->nr_irqs;
 
-	irq_base = irq_alloc_descs(-1, 0, irq_nr, 0);
-	if (IS_ERR_VALUE(irq_base)) {
+	virq_base = irq_alloc_descs(-1, 0, nr_irqs, 0);
+	if (IS_ERR_VALUE(virq_base)) {
 		pr_err("%s: irq desc alloc failed\n", __func__);
 		goto err_unmap;
 	}
 
-	shirq_domain = irq_domain_add_legacy(np, irq_nr, irq_base, 0,
+	shirq_domain = irq_domain_add_legacy(np, nr_irqs, virq_base, 0,
 			&irq_domain_simple_ops, NULL);
 	if (WARN_ON(!shirq_domain)) {
 		pr_warn("%s: irq domain init failed\n", __func__);
@@ -316,18 +316,18 @@ static int __init shirq_init(struct spear_shirq **shirq_blocks, int block_nr,
 
 	for (i = 0; i < block_nr; i++) {
 		shirq_blocks[i]->base = base;
-		shirq_blocks[i]->irq_base = irq_find_mapping(shirq_domain,
+		shirq_blocks[i]->virq_base = irq_find_mapping(shirq_domain,
 				hwirq);
 
 		parent_irq = irq_of_parse_and_map(np, i);
 		spear_shirq_register(shirq_blocks[i], parent_irq);
-		hwirq += shirq_blocks[i]->irq_nr;
+		hwirq += shirq_blocks[i]->nr_irqs;
 	}
 
 	return 0;
 
 err_free_desc:
-	irq_free_descs(irq_base, irq_nr);
+	irq_free_descs(virq_base, nr_irqs);
 err_unmap:
 	iounmap(base);
 	return -ENXIO;

commit f37ecbce8bf8867ce19fe9ef09e789002d7aad15
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 19 21:34:39 2014 +0000

    irqchip: spear_shirq: No point in storing the parent irq
    
    The struct member is pointless and a nismomer as well.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20140619212713.129694036@linutronix.de
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/spear-shirq.c b/drivers/irqchip/spear-shirq.c
index 441e39f08135..576968efbc4d 100644
--- a/drivers/irqchip/spear-shirq.c
+++ b/drivers/irqchip/spear-shirq.c
@@ -47,7 +47,6 @@ struct shirq_regs {
 /*
  * struct spear_shirq: shared irq structure
  *
- * irq: hardware irq number
  * irq_base: base irq in linux domain
  * irq_nr: no. of shared interrupts in a particular block
  * irq_bit_off: starting bit offset in the status register
@@ -56,7 +55,6 @@ struct shirq_regs {
  * regs: register configuration for shared irq block
  */
 struct spear_shirq {
-	u32 irq;
 	u32 irq_base;
 	u32 irq_nr;
 	u32 irq_bit_off;
@@ -268,28 +266,29 @@ static void shirq_handler(unsigned irq, struct irq_desc *desc)
 	chip->irq_unmask(&desc->irq_data);
 }
 
-static void __init spear_shirq_register(struct spear_shirq *shirq)
+static void __init spear_shirq_register(struct spear_shirq *shirq,
+					int parent_irq)
 {
 	int i;
 
 	if (shirq->invalid_irq)
 		return;
 
-	irq_set_chained_handler(shirq->irq, shirq_handler);
+	irq_set_chained_handler(parent_irq, shirq_handler);
+	irq_set_handler_data(parent_irq, shirq);
+
 	for (i = 0; i < shirq->irq_nr; i++) {
 		irq_set_chip_and_handler(shirq->irq_base + i,
 					 &shirq_chip, handle_simple_irq);
 		set_irq_flags(shirq->irq_base + i, IRQF_VALID);
 		irq_set_chip_data(shirq->irq_base + i, shirq);
 	}
-
-	irq_set_handler_data(shirq->irq, shirq);
 }
 
 static int __init shirq_init(struct spear_shirq **shirq_blocks, int block_nr,
 		struct device_node *np)
 {
-	int i, irq_base, hwirq = 0, irq_nr = 0;
+	int i, parent_irq, irq_base, hwirq = 0, irq_nr = 0;
 	struct irq_domain *shirq_domain;
 	void __iomem *base;
 
@@ -319,9 +318,9 @@ static int __init shirq_init(struct spear_shirq **shirq_blocks, int block_nr,
 		shirq_blocks[i]->base = base;
 		shirq_blocks[i]->irq_base = irq_find_mapping(shirq_domain,
 				hwirq);
-		shirq_blocks[i]->irq = irq_of_parse_and_map(np, i);
 
-		spear_shirq_register(shirq_blocks[i]);
+		parent_irq = irq_of_parse_and_map(np, i);
+		spear_shirq_register(shirq_blocks[i], parent_irq);
 		hwirq += shirq_blocks[i]->irq_nr;
 	}
 

commit 078bc005651cfb134135c5f6eca48a997afb4014
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 19 21:34:38 2014 +0000

    irqchip: spear_shirq: Move private structs to source
    
    No point in having them in a separate header file. Make the init
    functions static.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20140619212713.038658058@linutronix.de
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/spear-shirq.c b/drivers/irqchip/spear-shirq.c
index 93f2196e8a08..441e39f08135 100644
--- a/drivers/irqchip/spear-shirq.c
+++ b/drivers/irqchip/spear-shirq.c
@@ -19,7 +19,6 @@
 #include <linux/io.h>
 #include <linux/irq.h>
 #include <linux/irqdomain.h>
-#include <linux/irqchip/spear-shirq.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
@@ -27,6 +26,45 @@
 
 #include "irqchip.h"
 
+/*
+ * struct shirq_regs: shared irq register configuration
+ *
+ * enb_reg: enable register offset
+ * reset_to_enb: val 1 indicates, we need to clear bit for enabling interrupt
+ * status_reg: status register offset
+ * status_reg_mask: status register valid mask
+ * clear_reg: clear register offset
+ * reset_to_clear: val 1 indicates, we need to clear bit for clearing interrupt
+ */
+struct shirq_regs {
+	u32 enb_reg;
+	u32 reset_to_enb;
+	u32 status_reg;
+	u32 clear_reg;
+	u32 reset_to_clear;
+};
+
+/*
+ * struct spear_shirq: shared irq structure
+ *
+ * irq: hardware irq number
+ * irq_base: base irq in linux domain
+ * irq_nr: no. of shared interrupts in a particular block
+ * irq_bit_off: starting bit offset in the status register
+ * invalid_irq: irq group is currently disabled
+ * base: base address of shared irq register
+ * regs: register configuration for shared irq block
+ */
+struct spear_shirq {
+	u32 irq;
+	u32 irq_base;
+	u32 irq_nr;
+	u32 irq_bit_off;
+	int invalid_irq;
+	void __iomem *base;
+	struct shirq_regs regs;
+};
+
 static DEFINE_SPINLOCK(lock);
 
 /* spear300 shared irq registers offsets and masks */
@@ -296,24 +334,24 @@ static int __init shirq_init(struct spear_shirq **shirq_blocks, int block_nr,
 	return -ENXIO;
 }
 
-int __init spear300_shirq_of_init(struct device_node *np,
-		struct device_node *parent)
+static int __init spear300_shirq_of_init(struct device_node *np,
+					 struct device_node *parent)
 {
 	return shirq_init(spear300_shirq_blocks,
 			ARRAY_SIZE(spear300_shirq_blocks), np);
 }
 IRQCHIP_DECLARE(spear300_shirq, "st,spear300-shirq", spear300_shirq_of_init);
 
-int __init spear310_shirq_of_init(struct device_node *np,
-		struct device_node *parent)
+static int __init spear310_shirq_of_init(struct device_node *np,
+					 struct device_node *parent)
 {
 	return shirq_init(spear310_shirq_blocks,
 			ARRAY_SIZE(spear310_shirq_blocks), np);
 }
 IRQCHIP_DECLARE(spear310_shirq, "st,spear310-shirq", spear310_shirq_of_init);
 
-int __init spear320_shirq_of_init(struct device_node *np,
-		struct device_node *parent)
+static int __init spear320_shirq_of_init(struct device_node *np,
+					 struct device_node *parent)
 {
 	return shirq_init(spear320_shirq_blocks,
 			ARRAY_SIZE(spear320_shirq_blocks), np);

commit a26c06f96eff6cb1834320463b7945b7a4c516ad
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 19 21:34:37 2014 +0000

    irqchip: spear_shirq: Kill pointless static
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20140619212712.948802939@linutronix.de
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/spear-shirq.c b/drivers/irqchip/spear-shirq.c
index 6ce6bd3441bf..93f2196e8a08 100644
--- a/drivers/irqchip/spear-shirq.c
+++ b/drivers/irqchip/spear-shirq.c
@@ -252,7 +252,7 @@ static int __init shirq_init(struct spear_shirq **shirq_blocks, int block_nr,
 		struct device_node *np)
 {
 	int i, irq_base, hwirq = 0, irq_nr = 0;
-	static struct irq_domain *shirq_domain;
+	struct irq_domain *shirq_domain;
 	void __iomem *base;
 
 	base = of_iomap(np, 0);

commit 4f4366033945419b0c52118c29d3057d7c558765
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 19 21:34:37 2014 +0000

    irqchip: spear_shirq: Fix interrupt offset
    
    The ras3 block on spear320 claims to have 3 interrupts. In fact it has
    one and 6 reserved interrupts. Account the 6 reserved to this block so
    it has 7 interrupts total. That matches the datasheet and the device
    tree entries.
    
    Broken since commit 80515a5a(ARM: SPEAr3xx: shirq: simplify and move
    the shared irq multiplexor to DT). Testing is overrated....
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20140619212712.872379208@linutronix.de
    Fixes: 80515a5a2e3c ('ARM: SPEAr3xx: shirq: simplify and move the shared irq multiplexor to DT')
    Cc: <stable@vger.kernel.org> # v3.8+
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/spear-shirq.c b/drivers/irqchip/spear-shirq.c
index 3fdda3a40269..6ce6bd3441bf 100644
--- a/drivers/irqchip/spear-shirq.c
+++ b/drivers/irqchip/spear-shirq.c
@@ -125,7 +125,7 @@ static struct spear_shirq spear320_shirq_ras2 = {
 };
 
 static struct spear_shirq spear320_shirq_ras3 = {
-	.irq_nr = 3,
+	.irq_nr = 7,
 	.irq_bit_off = 0,
 	.invalid_irq = 1,
 	.regs = {

commit 9cc236827fde5e254fd995a0023c05c5ee3a3ba6
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Apr 18 15:07:16 2014 -0700

    Shiraz has moved
    
    shiraz.hashim@st.com email-id doesn't exist anymore as he has left the
    company.  Replace ST's id with shiraz.linux.kernel@gmail.com.
    
    It also updates .mailmap file to fix address for 'git shortlog'.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Shiraz Hashim <shiraz.linux.kernel@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/irqchip/spear-shirq.c b/drivers/irqchip/spear-shirq.c
index 8527743b5cef..3fdda3a40269 100644
--- a/drivers/irqchip/spear-shirq.c
+++ b/drivers/irqchip/spear-shirq.c
@@ -5,7 +5,7 @@
  * Viresh Kumar <viresh.linux@gmail.com>
  *
  * Copyright (C) 2012 ST Microelectronics
- * Shiraz Hashim <shiraz.hashim@st.com>
+ * Shiraz Hashim <shiraz.linux.kernel@gmail.com>
  *
  * This file is licensed under the terms of the GNU General Public
  * License version 2. This program is licensed "as is" without any

commit e9c515589df7731591d15e506ba6d69713faae41
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Wed Jan 2 09:37:56 2013 -0600

    ARM: spear: use common irqchip_init function
    
    Convert spear DT irq initialization over to use common irqchip_init
    function.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Viresh Kumar <viresh.linux@gmail.com>
    Cc: Shiraz Hashim <shiraz.hashim@st.com>
    Cc: Rajeev Kumar <rajeev-dlh.kumar@st.com>

diff --git a/drivers/irqchip/spear-shirq.c b/drivers/irqchip/spear-shirq.c
index 80e1d2fd9d4c..8527743b5cef 100644
--- a/drivers/irqchip/spear-shirq.c
+++ b/drivers/irqchip/spear-shirq.c
@@ -25,6 +25,8 @@
 #include <linux/of_irq.h>
 #include <linux/spinlock.h>
 
+#include "irqchip.h"
+
 static DEFINE_SPINLOCK(lock);
 
 /* spear300 shared irq registers offsets and masks */
@@ -300,6 +302,7 @@ int __init spear300_shirq_of_init(struct device_node *np,
 	return shirq_init(spear300_shirq_blocks,
 			ARRAY_SIZE(spear300_shirq_blocks), np);
 }
+IRQCHIP_DECLARE(spear300_shirq, "st,spear300-shirq", spear300_shirq_of_init);
 
 int __init spear310_shirq_of_init(struct device_node *np,
 		struct device_node *parent)
@@ -307,6 +310,7 @@ int __init spear310_shirq_of_init(struct device_node *np,
 	return shirq_init(spear310_shirq_blocks,
 			ARRAY_SIZE(spear310_shirq_blocks), np);
 }
+IRQCHIP_DECLARE(spear310_shirq, "st,spear310-shirq", spear310_shirq_of_init);
 
 int __init spear320_shirq_of_init(struct device_node *np,
 		struct device_node *parent)
@@ -314,3 +318,4 @@ int __init spear320_shirq_of_init(struct device_node *np,
 	return shirq_init(spear320_shirq_blocks,
 			ARRAY_SIZE(spear320_shirq_blocks), np);
 }
+IRQCHIP_DECLARE(spear320_shirq, "st,spear320-shirq", spear320_shirq_of_init);

commit df1590d9ae5e37e07e7cf91107e4c2c946ce8bf4
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Nov 12 22:56:03 2012 +0530

    ARM: SPEAr3xx: Shirq: Move shirq controller out of plat/
    
    This patch moves shirq interrupt controllers driver and header file out of
    plat-spear directory. It is moved to drivers/irqchip/ directory.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/irqchip/spear-shirq.c b/drivers/irqchip/spear-shirq.c
new file mode 100644
index 000000000000..80e1d2fd9d4c
--- /dev/null
+++ b/drivers/irqchip/spear-shirq.c
@@ -0,0 +1,316 @@
+/*
+ * SPEAr platform shared irq layer source file
+ *
+ * Copyright (C) 2009-2012 ST Microelectronics
+ * Viresh Kumar <viresh.linux@gmail.com>
+ *
+ * Copyright (C) 2012 ST Microelectronics
+ * Shiraz Hashim <shiraz.hashim@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/err.h>
+#include <linux/export.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/irqchip/spear-shirq.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/spinlock.h>
+
+static DEFINE_SPINLOCK(lock);
+
+/* spear300 shared irq registers offsets and masks */
+#define SPEAR300_INT_ENB_MASK_REG	0x54
+#define SPEAR300_INT_STS_MASK_REG	0x58
+
+static struct spear_shirq spear300_shirq_ras1 = {
+	.irq_nr = 9,
+	.irq_bit_off = 0,
+	.regs = {
+		.enb_reg = SPEAR300_INT_ENB_MASK_REG,
+		.status_reg = SPEAR300_INT_STS_MASK_REG,
+		.clear_reg = -1,
+	},
+};
+
+static struct spear_shirq *spear300_shirq_blocks[] = {
+	&spear300_shirq_ras1,
+};
+
+/* spear310 shared irq registers offsets and masks */
+#define SPEAR310_INT_STS_MASK_REG	0x04
+
+static struct spear_shirq spear310_shirq_ras1 = {
+	.irq_nr = 8,
+	.irq_bit_off = 0,
+	.regs = {
+		.enb_reg = -1,
+		.status_reg = SPEAR310_INT_STS_MASK_REG,
+		.clear_reg = -1,
+	},
+};
+
+static struct spear_shirq spear310_shirq_ras2 = {
+	.irq_nr = 5,
+	.irq_bit_off = 8,
+	.regs = {
+		.enb_reg = -1,
+		.status_reg = SPEAR310_INT_STS_MASK_REG,
+		.clear_reg = -1,
+	},
+};
+
+static struct spear_shirq spear310_shirq_ras3 = {
+	.irq_nr = 1,
+	.irq_bit_off = 13,
+	.regs = {
+		.enb_reg = -1,
+		.status_reg = SPEAR310_INT_STS_MASK_REG,
+		.clear_reg = -1,
+	},
+};
+
+static struct spear_shirq spear310_shirq_intrcomm_ras = {
+	.irq_nr = 3,
+	.irq_bit_off = 14,
+	.regs = {
+		.enb_reg = -1,
+		.status_reg = SPEAR310_INT_STS_MASK_REG,
+		.clear_reg = -1,
+	},
+};
+
+static struct spear_shirq *spear310_shirq_blocks[] = {
+	&spear310_shirq_ras1,
+	&spear310_shirq_ras2,
+	&spear310_shirq_ras3,
+	&spear310_shirq_intrcomm_ras,
+};
+
+/* spear320 shared irq registers offsets and masks */
+#define SPEAR320_INT_STS_MASK_REG		0x04
+#define SPEAR320_INT_CLR_MASK_REG		0x04
+#define SPEAR320_INT_ENB_MASK_REG		0x08
+
+static struct spear_shirq spear320_shirq_ras1 = {
+	.irq_nr = 3,
+	.irq_bit_off = 7,
+	.regs = {
+		.enb_reg = -1,
+		.status_reg = SPEAR320_INT_STS_MASK_REG,
+		.clear_reg = SPEAR320_INT_CLR_MASK_REG,
+		.reset_to_clear = 1,
+	},
+};
+
+static struct spear_shirq spear320_shirq_ras2 = {
+	.irq_nr = 1,
+	.irq_bit_off = 10,
+	.regs = {
+		.enb_reg = -1,
+		.status_reg = SPEAR320_INT_STS_MASK_REG,
+		.clear_reg = SPEAR320_INT_CLR_MASK_REG,
+		.reset_to_clear = 1,
+	},
+};
+
+static struct spear_shirq spear320_shirq_ras3 = {
+	.irq_nr = 3,
+	.irq_bit_off = 0,
+	.invalid_irq = 1,
+	.regs = {
+		.enb_reg = SPEAR320_INT_ENB_MASK_REG,
+		.reset_to_enb = 1,
+		.status_reg = SPEAR320_INT_STS_MASK_REG,
+		.clear_reg = SPEAR320_INT_CLR_MASK_REG,
+		.reset_to_clear = 1,
+	},
+};
+
+static struct spear_shirq spear320_shirq_intrcomm_ras = {
+	.irq_nr = 11,
+	.irq_bit_off = 11,
+	.regs = {
+		.enb_reg = -1,
+		.status_reg = SPEAR320_INT_STS_MASK_REG,
+		.clear_reg = SPEAR320_INT_CLR_MASK_REG,
+		.reset_to_clear = 1,
+	},
+};
+
+static struct spear_shirq *spear320_shirq_blocks[] = {
+	&spear320_shirq_ras3,
+	&spear320_shirq_ras1,
+	&spear320_shirq_ras2,
+	&spear320_shirq_intrcomm_ras,
+};
+
+static void shirq_irq_mask_unmask(struct irq_data *d, bool mask)
+{
+	struct spear_shirq *shirq = irq_data_get_irq_chip_data(d);
+	u32 val, offset = d->irq - shirq->irq_base;
+	unsigned long flags;
+
+	if (shirq->regs.enb_reg == -1)
+		return;
+
+	spin_lock_irqsave(&lock, flags);
+	val = readl(shirq->base + shirq->regs.enb_reg);
+
+	if (mask ^ shirq->regs.reset_to_enb)
+		val &= ~(0x1 << shirq->irq_bit_off << offset);
+	else
+		val |= 0x1 << shirq->irq_bit_off << offset;
+
+	writel(val, shirq->base + shirq->regs.enb_reg);
+	spin_unlock_irqrestore(&lock, flags);
+
+}
+
+static void shirq_irq_mask(struct irq_data *d)
+{
+	shirq_irq_mask_unmask(d, 1);
+}
+
+static void shirq_irq_unmask(struct irq_data *d)
+{
+	shirq_irq_mask_unmask(d, 0);
+}
+
+static struct irq_chip shirq_chip = {
+	.name		= "spear-shirq",
+	.irq_ack	= shirq_irq_mask,
+	.irq_mask	= shirq_irq_mask,
+	.irq_unmask	= shirq_irq_unmask,
+};
+
+static void shirq_handler(unsigned irq, struct irq_desc *desc)
+{
+	u32 i, j, val, mask, tmp;
+	struct irq_chip *chip;
+	struct spear_shirq *shirq = irq_get_handler_data(irq);
+
+	chip = irq_get_chip(irq);
+	chip->irq_ack(&desc->irq_data);
+
+	mask = ((0x1 << shirq->irq_nr) - 1) << shirq->irq_bit_off;
+	while ((val = readl(shirq->base + shirq->regs.status_reg) &
+				mask)) {
+
+		val >>= shirq->irq_bit_off;
+		for (i = 0, j = 1; i < shirq->irq_nr; i++, j <<= 1) {
+
+			if (!(j & val))
+				continue;
+
+			generic_handle_irq(shirq->irq_base + i);
+
+			/* clear interrupt */
+			if (shirq->regs.clear_reg == -1)
+				continue;
+
+			tmp = readl(shirq->base + shirq->regs.clear_reg);
+			if (shirq->regs.reset_to_clear)
+				tmp &= ~(j << shirq->irq_bit_off);
+			else
+				tmp |= (j << shirq->irq_bit_off);
+			writel(tmp, shirq->base + shirq->regs.clear_reg);
+		}
+	}
+	chip->irq_unmask(&desc->irq_data);
+}
+
+static void __init spear_shirq_register(struct spear_shirq *shirq)
+{
+	int i;
+
+	if (shirq->invalid_irq)
+		return;
+
+	irq_set_chained_handler(shirq->irq, shirq_handler);
+	for (i = 0; i < shirq->irq_nr; i++) {
+		irq_set_chip_and_handler(shirq->irq_base + i,
+					 &shirq_chip, handle_simple_irq);
+		set_irq_flags(shirq->irq_base + i, IRQF_VALID);
+		irq_set_chip_data(shirq->irq_base + i, shirq);
+	}
+
+	irq_set_handler_data(shirq->irq, shirq);
+}
+
+static int __init shirq_init(struct spear_shirq **shirq_blocks, int block_nr,
+		struct device_node *np)
+{
+	int i, irq_base, hwirq = 0, irq_nr = 0;
+	static struct irq_domain *shirq_domain;
+	void __iomem *base;
+
+	base = of_iomap(np, 0);
+	if (!base) {
+		pr_err("%s: failed to map shirq registers\n", __func__);
+		return -ENXIO;
+	}
+
+	for (i = 0; i < block_nr; i++)
+		irq_nr += shirq_blocks[i]->irq_nr;
+
+	irq_base = irq_alloc_descs(-1, 0, irq_nr, 0);
+	if (IS_ERR_VALUE(irq_base)) {
+		pr_err("%s: irq desc alloc failed\n", __func__);
+		goto err_unmap;
+	}
+
+	shirq_domain = irq_domain_add_legacy(np, irq_nr, irq_base, 0,
+			&irq_domain_simple_ops, NULL);
+	if (WARN_ON(!shirq_domain)) {
+		pr_warn("%s: irq domain init failed\n", __func__);
+		goto err_free_desc;
+	}
+
+	for (i = 0; i < block_nr; i++) {
+		shirq_blocks[i]->base = base;
+		shirq_blocks[i]->irq_base = irq_find_mapping(shirq_domain,
+				hwirq);
+		shirq_blocks[i]->irq = irq_of_parse_and_map(np, i);
+
+		spear_shirq_register(shirq_blocks[i]);
+		hwirq += shirq_blocks[i]->irq_nr;
+	}
+
+	return 0;
+
+err_free_desc:
+	irq_free_descs(irq_base, irq_nr);
+err_unmap:
+	iounmap(base);
+	return -ENXIO;
+}
+
+int __init spear300_shirq_of_init(struct device_node *np,
+		struct device_node *parent)
+{
+	return shirq_init(spear300_shirq_blocks,
+			ARRAY_SIZE(spear300_shirq_blocks), np);
+}
+
+int __init spear310_shirq_of_init(struct device_node *np,
+		struct device_node *parent)
+{
+	return shirq_init(spear310_shirq_blocks,
+			ARRAY_SIZE(spear310_shirq_blocks), np);
+}
+
+int __init spear320_shirq_of_init(struct device_node *np,
+		struct device_node *parent)
+{
+	return shirq_init(spear320_shirq_blocks,
+			ARRAY_SIZE(spear320_shirq_blocks), np);
+}
