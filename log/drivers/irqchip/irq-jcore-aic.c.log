commit c024f06b3de372cd67f86b142992ac88fc3a7d18
Author: Rich Felker <dalias@libc.org>
Date:   Thu Oct 13 20:35:30 2016 +0000

    irqchip/jcore: Fix lost per-cpu interrupts
    
    The J-Core AIC does not have separate interrupt numbers reserved for
    cpu-local vs global interrupts. Instead, the driver requesting the irq
    is expected to know whether its device uses per-cpu interrupts or not.
    Previously it was assumed that handle_simple_irq could work for both
    cases, but it intentionally drops interrupts for an irq number that
    already has a handler running. This resulted in the timer interrupt
    for one cpu being lost when multiple cpus' timers were set for
    approximately the same expiration time, leading to stalls. In theory
    the same could also happen with IPIs.
    
    To solve the problem, instead of registering handle_simple_irq as the
    handler, register a wrapper function which checks whether the irq to
    be handled was requested as per-cpu or not, and passes it to
    handle_simple_irq or handle_percpu_irq accordingly.
    
    Fixes: 981b58f66cfc ("irqchip/jcore-aic: Add J-Core AIC driver")
    Signed-off-by: Rich Felker <dalias@libc.org>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: linux-sh@vger.kernel.org
    Link: http://lkml.kernel.org/r/f18cec30bc17e3f52e478dd9f6714bfab02f227f.1476390724.git.dalias@libc.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/irqchip/irq-jcore-aic.c b/drivers/irqchip/irq-jcore-aic.c
index 84b01dec277d..033bccb41455 100644
--- a/drivers/irqchip/irq-jcore-aic.c
+++ b/drivers/irqchip/irq-jcore-aic.c
@@ -25,12 +25,30 @@
 
 static struct irq_chip jcore_aic;
 
+/*
+ * The J-Core AIC1 and AIC2 are cpu-local interrupt controllers and do
+ * not distinguish or use distinct irq number ranges for per-cpu event
+ * interrupts (timer, IPI). Since information to determine whether a
+ * particular irq number should be treated as per-cpu is not available
+ * at mapping time, we use a wrapper handler function which chooses
+ * the right handler at runtime based on whether IRQF_PERCPU was used
+ * when requesting the irq.
+ */
+
+static void handle_jcore_irq(struct irq_desc *desc)
+{
+	if (irqd_is_per_cpu(irq_desc_get_irq_data(desc)))
+		handle_percpu_irq(desc);
+	else
+		handle_simple_irq(desc);
+}
+
 static int jcore_aic_irqdomain_map(struct irq_domain *d, unsigned int irq,
 				   irq_hw_number_t hwirq)
 {
 	struct irq_chip *aic = d->host_data;
 
-	irq_set_chip_and_handler(irq, aic, handle_simple_irq);
+	irq_set_chip_and_handler(irq, aic, handle_jcore_irq);
 
 	return 0;
 }

commit 21118df66c198d6ebb23e6827e2e92ab1e148e78
Author: Wei Yongjun <weiyj.lk@gmail.com>
Date:   Sat Aug 20 15:26:28 2016 +0000

    irqchip/jcore-aic: Fix non static symbol warning
    
    Fixes the following sparse warning:
    
    drivers/irqchip/irq-jcore-aic.c:47:12: warning:
     symbol 'aic_irq_of_init' was not declared. Should it be static?
    
    Signed-off-by: Wei Yongjun <weiyj.lk@gmail.com>
    Link: https://lkml.kernel.org/r/1471706788-27587-1-git-send-email-weiyj.lk@gmail.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/irq-jcore-aic.c b/drivers/irqchip/irq-jcore-aic.c
index 5e5e3bb7d3c7..84b01dec277d 100644
--- a/drivers/irqchip/irq-jcore-aic.c
+++ b/drivers/irqchip/irq-jcore-aic.c
@@ -44,7 +44,8 @@ static void noop(struct irq_data *data)
 {
 }
 
-int __init aic_irq_of_init(struct device_node *node, struct device_node *parent)
+static int __init aic_irq_of_init(struct device_node *node,
+				  struct device_node *parent)
 {
 	unsigned min_irq = JCORE_AIC2_MIN_HWIRQ;
 	unsigned dom_sz = JCORE_AIC_MAX_HWIRQ+1;

commit 981b58f66cfcd32dc4ebbaeef8451daf393b6c94
Author: Rich Felker <dalias@libc.org>
Date:   Thu Aug 4 04:30:37 2016 +0000

    irqchip/jcore-aic: Add J-Core AIC driver
    
    There are two versions of the J-Core interrupt controller in use, aic1
    which generates interrupts with programmable priorities, but only
    supports 8 irq lines and maps them to cpu traps in the range 17 to 24,
    and aic2 which uses traps in the range 64-127 and supports up to 128
    irqs, with priorities dependent on the interrupt number. The Linux
    driver does not make use of priorities anyway.
    
    For simplicity, there is no aic1-specific logic in the driver beyond
    setting the priority register, which is necessary for interrupts to
    work at all. Eventually aic1 will likely be phased out, but it's
    currently in use in deployments and all released bitstream binaries.
    
    Signed-off-by: Rich Felker <dalias@libc.org>
    Link: https://lkml.kernel.org/r/c3b89ef74aaa6477575dbe2d410eb1d182503243.147018b6529.git.dalias@libc.org
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/irqchip/irq-jcore-aic.c b/drivers/irqchip/irq-jcore-aic.c
new file mode 100644
index 000000000000..5e5e3bb7d3c7
--- /dev/null
+++ b/drivers/irqchip/irq-jcore-aic.c
@@ -0,0 +1,94 @@
+/*
+ * J-Core SoC AIC driver
+ *
+ * Copyright (C) 2015-2016 Smart Energy Instruments, Inc.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/irqchip.h>
+#include <linux/irqdomain.h>
+#include <linux/cpu.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+
+#define JCORE_AIC_MAX_HWIRQ	127
+#define JCORE_AIC1_MIN_HWIRQ	16
+#define JCORE_AIC2_MIN_HWIRQ	64
+
+#define JCORE_AIC1_INTPRI_REG	8
+
+static struct irq_chip jcore_aic;
+
+static int jcore_aic_irqdomain_map(struct irq_domain *d, unsigned int irq,
+				   irq_hw_number_t hwirq)
+{
+	struct irq_chip *aic = d->host_data;
+
+	irq_set_chip_and_handler(irq, aic, handle_simple_irq);
+
+	return 0;
+}
+
+static const struct irq_domain_ops jcore_aic_irqdomain_ops = {
+	.map = jcore_aic_irqdomain_map,
+	.xlate = irq_domain_xlate_onecell,
+};
+
+static void noop(struct irq_data *data)
+{
+}
+
+int __init aic_irq_of_init(struct device_node *node, struct device_node *parent)
+{
+	unsigned min_irq = JCORE_AIC2_MIN_HWIRQ;
+	unsigned dom_sz = JCORE_AIC_MAX_HWIRQ+1;
+	struct irq_domain *domain;
+
+	pr_info("Initializing J-Core AIC\n");
+
+	/* AIC1 needs priority initialization to receive interrupts. */
+	if (of_device_is_compatible(node, "jcore,aic1")) {
+		unsigned cpu;
+
+		for_each_present_cpu(cpu) {
+			void __iomem *base = of_iomap(node, cpu);
+
+			if (!base) {
+				pr_err("Unable to map AIC for cpu %u\n", cpu);
+				return -ENOMEM;
+			}
+			__raw_writel(0xffffffff, base + JCORE_AIC1_INTPRI_REG);
+			iounmap(base);
+		}
+		min_irq = JCORE_AIC1_MIN_HWIRQ;
+	}
+
+	/*
+	 * The irq chip framework requires either mask/unmask or enable/disable
+	 * function pointers to be provided, but the hardware does not have any
+	 * such mechanism; the only interrupt masking is at the cpu level and
+	 * it affects all interrupts. We provide dummy mask/unmask. The hardware
+	 * handles all interrupt control and clears pending status when the cpu
+	 * accepts the interrupt.
+	 */
+	jcore_aic.irq_mask = noop;
+	jcore_aic.irq_unmask = noop;
+	jcore_aic.name = "AIC";
+
+	domain = irq_domain_add_linear(node, dom_sz, &jcore_aic_irqdomain_ops,
+				       &jcore_aic);
+	if (!domain)
+		return -ENOMEM;
+	irq_create_strict_mappings(domain, min_irq, min_irq, dom_sz - min_irq);
+
+	return 0;
+}
+
+IRQCHIP_DECLARE(jcore_aic2, "jcore,aic2", aic_irq_of_init);
+IRQCHIP_DECLARE(jcore_aic1, "jcore,aic1", aic_irq_of_init);
