commit 8ce5f84157530ffa64b3e0acf00b9261f41c8da8
Author: Rob Herring <robh@kernel.org>
Date:   Tue Dec 11 14:31:05 2018 -0600

    of: Remove struct device_node.type pointer
    
    Now that all users of device_node.type pointer have been removed in
    favor of accessor functions, we can remove it.
    
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: devicetree@vger.kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/pdt.c b/drivers/of/pdt.c
index d3185063d369..7eda43c66c91 100644
--- a/drivers/of/pdt.c
+++ b/drivers/of/pdt.c
@@ -155,7 +155,6 @@ static struct device_node * __init of_pdt_create_node(phandle node,
 	dp->parent = parent;
 
 	dp->name = of_pdt_get_one_property(node, "name");
-	dp->type = of_pdt_get_one_property(node, "device_type");
 	dp->phandle = node;
 
 	dp->properties = of_pdt_build_prop_list(node);

commit 030672aea826adf3dee9100ee8ac303b62c8fe7f
Merge: 24dc83635ffe 5801169a2ed2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 28 20:08:34 2018 -0800

    Merge tag 'devicetree-for-4.21' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull Devicetree updates from Rob Herring:
     "The biggest highlight here is the start of using json-schema for DT
      bindings. Being able to validate bindings has been discussed for years
      with little progress.
    
       - Initial support for DT bindings using json-schema language. This is
         the start of converting DT bindings from free-form text to a
         structured format.
    
       - Reworking of initrd address initialization. This moves to using the
         phys address instead of virt addr in the DT parsing code. This
         rework was motivated by CONFIG_DEV_BLK_INITRD causing unnecessary
         rebuilding of lots of files.
    
       - Fix stale phandle entries in phandle cache
    
       - DT overlay validation improvements. This exposed several memory
         leak bugs which have been fixed.
    
       - Use node name and device_type helper functions in DT code
    
       - Last remaining conversions to using %pOFn printk specifier instead
         of device_node.name directly
    
       - Create new common RTC binding doc and move all trivial RTC devices
         out of trivial-devices.txt.
    
       - New bindings for Freescale MAG3110 magnetometer, Cadence Sierra
         PHY, and Xen shared memory
    
       - Update dtc to upstream version v1.4.7-57-gf267e674d145"
    
    * tag 'devicetree-for-4.21' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (68 commits)
      of: __of_detach_node() - remove node from phandle cache
      of: of_node_get()/of_node_put() nodes held in phandle cache
      gpio-omap.txt: add reg and interrupts properties
      dt-bindings: mrvl,intc: fix a trivial typo
      dt-bindings: iio: magnetometer: add dt-bindings for freescale mag3110
      dt-bindings: Convert trivial-devices.txt to json-schema
      dt-bindings: arm: mrvl: amend Browstone compatible string
      dt-bindings: arm: Convert Tegra board/soc bindings to json-schema
      dt-bindings: arm: Convert ZTE board/soc bindings to json-schema
      dt-bindings: arm: Add missing Xilinx boards
      dt-bindings: arm: Convert Xilinx board/soc bindings to json-schema
      dt-bindings: arm: Convert VIA board/soc bindings to json-schema
      dt-bindings: arm: Convert ST STi board/soc bindings to json-schema
      dt-bindings: arm: Convert SPEAr board/soc bindings to json-schema
      dt-bindings: arm: Convert CSR SiRF board/soc bindings to json-schema
      dt-bindings: arm: Convert QCom board/soc bindings to json-schema
      dt-bindings: arm: Convert TI nspire board/soc bindings to json-schema
      dt-bindings: arm: Convert TI davinci board/soc bindings to json-schema
      dt-bindings: arm: Convert Calxeda board/soc bindings to json-schema
      dt-bindings: arm: Convert Altera board/soc bindings to json-schema
      ...

commit 0c5eaa7749726b2e4667a5e3668c3eb8516e7440
Author: Rob Herring <robh@kernel.org>
Date:   Fri Nov 16 15:06:55 2018 -0600

    of: Drop full path from full_name for PDT systems
    
    Now that there are no more users of path_component_name for Sparc
    outside of the PDT code and all users of device_node.full_name are
    converted to use "%pOF" printf specifier, we can align Sparc with FDT
    and store just the base node name and unit address in full_name. This
    makes path_component_name redundant, so it can be removed.
    
    As full_name is used by printf specifiers, set it as early as possible.
    
    Cc: Frank Rowand <frowand.list@gmail.com>
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/pdt.c b/drivers/of/pdt.c
index 013e65de074a..c1633041621d 100644
--- a/drivers/of/pdt.c
+++ b/drivers/of/pdt.c
@@ -32,24 +32,7 @@ unsigned int of_pdt_unique_id __initdata;
 
 static char * __init of_pdt_build_full_name(struct device_node *dp)
 {
-	int len, ourlen, plen;
-	char *n;
-
-	dp->path_component_name = build_path_component(dp);
-
-	plen = strlen(dp->parent->full_name);
-	ourlen = strlen(dp->path_component_name);
-	len = ourlen + plen + 2;
-
-	n = prom_early_alloc(len);
-	strcpy(n, dp->parent->full_name);
-	if (!of_node_is_root(dp->parent)) {
-		strcpy(n + plen, "/");
-		plen++;
-	}
-	strcpy(n + plen, dp->path_component_name);
-
-	return n;
+	return build_path_component(dp);
 }
 
 #else /* CONFIG_SPARC */
@@ -60,23 +43,21 @@ static inline void irq_trans_init(struct device_node *dp) { }
 static char * __init of_pdt_build_full_name(struct device_node *dp)
 {
 	static int failsafe_id = 0; /* for generating unique names on failure */
+	const char *name;
+	char path[256];
 	char *buf;
 	int len;
 
-	if (of_pdt_prom_ops->pkg2path(dp->phandle, NULL, 0, &len))
-		goto failsafe;
-
-	buf = prom_early_alloc(len + 1);
-	if (of_pdt_prom_ops->pkg2path(dp->phandle, buf, len, &len))
-		goto failsafe;
-	return buf;
+	if (!of_pdt_prom_ops->pkg2path(dp->phandle, path, sizeof(path), &len)) {
+		name = kbasename(path);
+		buf = prom_early_alloc(strlen(name) + 1);
+		strcpy(buf, name);
+		return buf;
+	}
 
- failsafe:
-	buf = prom_early_alloc(strlen(dp->parent->full_name) +
-			       strlen(dp->name) + 16);
-	sprintf(buf, "%s/%s@unknown%i",
-		of_node_is_root(dp->parent) ? "" : dp->parent->full_name,
-		dp->name, failsafe_id++);
+	name = of_get_property(dp, "name", &len);
+	buf = prom_early_alloc(len + 16);
+	sprintf(buf, "%s@unknown%i", name, failsafe_id++);
 	pr_err("%s: pkg2path failed; assigning %s\n", __func__, buf);
 	return buf;
 }
@@ -181,6 +162,8 @@ static struct device_node * __init of_pdt_create_node(phandle node,
 
 	dp->properties = of_pdt_build_prop_list(node);
 
+	dp->full_name = of_pdt_build_full_name(dp);
+
 	irq_trans_init(dp);
 
 	return dp;
@@ -204,8 +187,6 @@ static struct device_node * __init of_pdt_build_tree(struct device_node *parent,
 			ret = dp;
 		prev_sibling = dp;
 
-		dp->full_name = of_pdt_build_full_name(dp);
-
 		dp->child = of_pdt_build_tree(dp, of_pdt_prom_ops->getchild(node));
 
 		if (of_pdt_build_more)
@@ -228,9 +209,6 @@ void __init of_pdt_build_devicetree(phandle root_node, struct of_pdt_ops *ops)
 	of_pdt_prom_ops = ops;
 
 	of_root = of_pdt_create_node(root_node, NULL);
-#if defined(CONFIG_SPARC)
-	of_root->path_component_name = "";
-#endif
 	of_root->full_name = "/";
 
 	of_root->child = of_pdt_build_tree(of_root,

commit 1ae367a2451e0b249074461d2d8ac76d8e929a53
Author: Rob Herring <robh@kernel.org>
Date:   Tue Nov 6 18:07:37 2018 -0600

    of/pdt: Remove unused of_pdt_build_more function ptr
    
    There are no users of of_pdt_build_more since 2012, so remove it.
    
    Cc: Frank Rowand <frowand.list@gmail.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/pdt.c b/drivers/of/pdt.c
index 013e65de074a..4fc0fd96ed04 100644
--- a/drivers/of/pdt.c
+++ b/drivers/of/pdt.c
@@ -21,8 +21,6 @@
 
 static struct of_pdt_ops *of_pdt_prom_ops __initdata;
 
-void __initdata (*of_pdt_build_more)(struct device_node *dp);
-
 #if defined(CONFIG_SPARC)
 unsigned int of_pdt_unique_id __initdata;
 
@@ -208,9 +206,6 @@ static struct device_node * __init of_pdt_build_tree(struct device_node *parent,
 
 		dp->child = of_pdt_build_tree(dp, of_pdt_prom_ops->getchild(node));
 
-		if (of_pdt_build_more)
-			of_pdt_build_more(dp);
-
 		node = of_pdt_prom_ops->getsibling(node);
 	}
 

commit af6074fc9aa4b29517375634189ada1869eea598
Author: Rob Herring <robh@kernel.org>
Date:   Wed Dec 27 12:55:14 2017 -0600

    of: Use SPDX license tag for DT files
    
    Convert remaining DT files to use SPDX-License-Identifier tags.
    
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    Reviewed-by: Frank Rowand <frank.rowand@sony.com>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/pdt.c b/drivers/of/pdt.c
index d2acae825af9..013e65de074a 100644
--- a/drivers/of/pdt.c
+++ b/drivers/of/pdt.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /* pdt.c: OF PROM device tree support code.
  *
  * Paul Mackerras	August 1996.
@@ -8,11 +9,6 @@
  *
  *  Adapted for sparc by David S. Miller davem@davemloft.net
  *  Adapted for multiple architectures by Andres Salomon <dilinger@queued.net>
- *
- *      This program is free software; you can redistribute it and/or
- *      modify it under the terms of the GNU General Public License
- *      as published by the Free Software Foundation; either version
- *      2 of the License, or (at your option) any later version.
  */
 
 #include <linux/kernel.h>

commit 5063e25a302e6a83f6590d9a06bd5f6400b17430
Author: Grant Likely <grant.likely@linaro.org>
Date:   Fri Oct 3 16:28:27 2014 +0100

    of: Eliminate of_allnodes list
    
    The device tree structure is composed of two lists; the 'allnodes' list
    which is a singly linked list containing every node in the tree, and the
    child->parent structure where each parent node has a singly linked list
    of children. All of the data in the allnodes list can be easily
    reproduced with the parent-child lists, so of_allnodes is actually
    unnecessary. Remove it entirely which saves a bit of memory and
    simplifies the data structure quite a lot.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Gaurav Minocha <gaurav.minocha.os@gmail.com>
    Cc: Pantelis Antoniou <pantelis@pantelis.antoniou@konsulko.com>

diff --git a/drivers/of/pdt.c b/drivers/of/pdt.c
index 36b4035881b0..d2acae825af9 100644
--- a/drivers/of/pdt.c
+++ b/drivers/of/pdt.c
@@ -25,8 +25,7 @@
 
 static struct of_pdt_ops *of_pdt_prom_ops __initdata;
 
-void __initdata (*of_pdt_build_more)(struct device_node *dp,
-		struct device_node ***nextp);
+void __initdata (*of_pdt_build_more)(struct device_node *dp);
 
 #if defined(CONFIG_SPARC)
 unsigned int of_pdt_unique_id __initdata;
@@ -192,8 +191,7 @@ static struct device_node * __init of_pdt_create_node(phandle node,
 }
 
 static struct device_node * __init of_pdt_build_tree(struct device_node *parent,
-						   phandle node,
-						   struct device_node ***nextp)
+						   phandle node)
 {
 	struct device_node *ret = NULL, *prev_sibling = NULL;
 	struct device_node *dp;
@@ -210,16 +208,12 @@ static struct device_node * __init of_pdt_build_tree(struct device_node *parent,
 			ret = dp;
 		prev_sibling = dp;
 
-		*(*nextp) = dp;
-		*nextp = &dp->allnext;
-
 		dp->full_name = of_pdt_build_full_name(dp);
 
-		dp->child = of_pdt_build_tree(dp,
-				of_pdt_prom_ops->getchild(node), nextp);
+		dp->child = of_pdt_build_tree(dp, of_pdt_prom_ops->getchild(node));
 
 		if (of_pdt_build_more)
-			of_pdt_build_more(dp, nextp);
+			of_pdt_build_more(dp);
 
 		node = of_pdt_prom_ops->getsibling(node);
 	}
@@ -234,20 +228,17 @@ static void * __init kernel_tree_alloc(u64 size, u64 align)
 
 void __init of_pdt_build_devicetree(phandle root_node, struct of_pdt_ops *ops)
 {
-	struct device_node **nextp;
-
 	BUG_ON(!ops);
 	of_pdt_prom_ops = ops;
 
-	of_allnodes = of_pdt_create_node(root_node, NULL);
+	of_root = of_pdt_create_node(root_node, NULL);
 #if defined(CONFIG_SPARC)
-	of_allnodes->path_component_name = "";
+	of_root->path_component_name = "";
 #endif
-	of_allnodes->full_name = "/";
+	of_root->full_name = "/";
 
-	nextp = &of_allnodes->allnext;
-	of_allnodes->child = of_pdt_build_tree(of_allnodes,
-			of_pdt_prom_ops->getchild(of_allnodes->phandle), &nextp);
+	of_root->child = of_pdt_build_tree(of_root,
+				of_pdt_prom_ops->getchild(of_root->phandle));
 
 	/* Get pointer to "/chosen" and "/aliases" nodes for use everywhere */
 	of_alias_scan(kernel_tree_alloc);

commit 0829f6d1f69e4f2fae4062987ae6531a9af1a2e3
Author: Pantelis Antoniou <panto@antoniou-consulting.com>
Date:   Fri Dec 13 20:08:59 2013 +0200

    of: device_node kobject lifecycle fixes
    
    After the move to having device nodes be proper kobjects the lifecycle
    of the node needs to be controlled better.
    
    At first convert of_add_node() in the unflattened functions to
    of_init_node() which initializes the kobject so that of_node_get/put
    work correctly even before of_init is called.
    
    Afterwards introduce of_node_is_initialized & of_node_is_attached that
    query the underlying kobject about the state (attached means kobj
    is visible in sysfs)
    
    Using that make sure the lifecycle of the tree is correct at all
    times.
    
    Signed-off-by: Pantelis Antoniou <panto@antoniou-consulting.com>
    [grant.likely: moved of_node_init() calls, fixed up locking, and
                   dropped __of_populate() hunks]
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/pdt.c b/drivers/of/pdt.c
index e64fa3d3da5f..36b4035881b0 100644
--- a/drivers/of/pdt.c
+++ b/drivers/of/pdt.c
@@ -176,6 +176,7 @@ static struct device_node * __init of_pdt_create_node(phandle node,
 		return NULL;
 
 	dp = prom_early_alloc(sizeof(*dp));
+	of_node_init(dp);
 	of_pdt_incr_unique_id(dp);
 	dp->parent = parent;
 
@@ -213,7 +214,6 @@ static struct device_node * __init of_pdt_build_tree(struct device_node *parent,
 		*nextp = &dp->allnext;
 
 		dp->full_name = of_pdt_build_full_name(dp);
-		of_node_add(dp);
 
 		dp->child = of_pdt_build_tree(dp,
 				of_pdt_prom_ops->getchild(node), nextp);
@@ -244,7 +244,6 @@ void __init of_pdt_build_devicetree(phandle root_node, struct of_pdt_ops *ops)
 	of_allnodes->path_component_name = "";
 #endif
 	of_allnodes->full_name = "/";
-	of_node_add(of_allnodes);
 
 	nextp = &of_allnodes->allnext;
 	of_allnodes->child = of_pdt_build_tree(of_allnodes,

commit 75b57ecf9d1d1e17d099ab13b8f48e6e038676be
Author: Grant Likely <grant.likely@linaro.org>
Date:   Thu Feb 20 18:02:11 2014 +0000

    of: Make device nodes kobjects so they show up in sysfs
    
    Device tree nodes are already treated as objects, and we already want to
    expose them to userspace which is done using the /proc filesystem today.
    Right now the kernel has to do a lot of work to keep the /proc view in
    sync with the in-kernel representation. If device_nodes are switched to
    be kobjects then the device tree code can be a whole lot simpler. It
    also turns out that switching to using /sysfs from /proc results in
    smaller code and data size, and the userspace ABI won't change if
    /proc/device-tree symlinks to /sys/firmware/devicetree/base.
    
    v7: Add missing sysfs_bin_attr_init()
    v6: Add __of_add_property() early init fixes from Pantelis
    v5: Rename firmware/ofw to firmware/devicetree
        Fix updating property values in sysfs
    v4: Fixed build error on Powerpc
        Fixed handling of dynamic nodes on powerpc
    v3: Fixed handling of duplicate attribute and child node names
    v2: switch to using sysfs bin_attributes which solve the problem of
        reporting incorrect property size.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Tested-by: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Nathan Fontenot <nfont@linux.vnet.ibm.com>
    Cc: Pantelis Antoniou <panto@antoniou-consulting.com>

diff --git a/drivers/of/pdt.c b/drivers/of/pdt.c
index 7b666736c168..e64fa3d3da5f 100644
--- a/drivers/of/pdt.c
+++ b/drivers/of/pdt.c
@@ -179,8 +179,6 @@ static struct device_node * __init of_pdt_create_node(phandle node,
 	of_pdt_incr_unique_id(dp);
 	dp->parent = parent;
 
-	kref_init(&dp->kref);
-
 	dp->name = of_pdt_get_one_property(node, "name");
 	dp->type = of_pdt_get_one_property(node, "device_type");
 	dp->phandle = node;
@@ -215,6 +213,7 @@ static struct device_node * __init of_pdt_build_tree(struct device_node *parent,
 		*nextp = &dp->allnext;
 
 		dp->full_name = of_pdt_build_full_name(dp);
+		of_node_add(dp);
 
 		dp->child = of_pdt_build_tree(dp,
 				of_pdt_prom_ops->getchild(node), nextp);
@@ -245,6 +244,7 @@ void __init of_pdt_build_devicetree(phandle root_node, struct of_pdt_ops *ops)
 	of_allnodes->path_component_name = "";
 #endif
 	of_allnodes->full_name = "/";
+	of_node_add(of_allnodes);
 
 	nextp = &of_allnodes->allnext;
 	of_allnodes->child = of_pdt_build_tree(of_allnodes,

commit 9cae09c5a9940b9e02474be0639f0b49bd592a33
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Mon Sep 9 18:13:46 2013 -0500

    of: remove unnecessary prom.h includes
    
    Remove unnecessary prom.h includes in preparation to make prom.h optional.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/pdt.c b/drivers/of/pdt.c
index 4ec19cbee57f..7b666736c168 100644
--- a/drivers/of/pdt.c
+++ b/drivers/of/pdt.c
@@ -22,7 +22,6 @@
 #include <linux/slab.h>
 #include <linux/of.h>
 #include <linux/of_pdt.h>
-#include <asm/prom.h>
 
 static struct of_pdt_ops *of_pdt_prom_ops __initdata;
 

commit 4c7d6361fa0dc9817ef878a7fbb6e50dd33c2f6d
Author: Robert P. J. Day <rpjday@crashcourse.ca>
Date:   Thu May 30 05:38:08 2013 -0400

    open firmware: "/aliasas" -> "/aliases"
    
    Fix "/aliasas" typo in comments, no functional change.
    
    Signed-off-by: Robert P. J. Day <rpjday@crashcourse.ca>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/of/pdt.c b/drivers/of/pdt.c
index 37b56fd716e6..4ec19cbee57f 100644
--- a/drivers/of/pdt.c
+++ b/drivers/of/pdt.c
@@ -251,6 +251,6 @@ void __init of_pdt_build_devicetree(phandle root_node, struct of_pdt_ops *ops)
 	of_allnodes->child = of_pdt_build_tree(of_allnodes,
 			of_pdt_prom_ops->getchild(of_allnodes->phandle), &nextp);
 
-	/* Get pointer to "/chosen" and "/aliasas" nodes for use everywhere */
+	/* Get pointer to "/chosen" and "/aliases" nodes for use everywhere */
 	of_alias_scan(kernel_tree_alloc);
 }

commit 465aac6d496aa3e99caaa6868865fb3830f73d80
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Fri Nov 30 10:01:51 2012 +0000

    Fix build when CONFIG_W1_MASTER_GPIO=m b exporting "allnodes"
    
    ERROR: "allnodes" [drivers/w1/masters/w1-gpio.ko] undefined!
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    [grant.likely: allnodes is too generic; rename to of_allnodes]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Ville Syrjala <syrjala@sci.fi>

diff --git a/drivers/of/pdt.c b/drivers/of/pdt.c
index 07cc1d678e4d..37b56fd716e6 100644
--- a/drivers/of/pdt.c
+++ b/drivers/of/pdt.c
@@ -241,15 +241,15 @@ void __init of_pdt_build_devicetree(phandle root_node, struct of_pdt_ops *ops)
 	BUG_ON(!ops);
 	of_pdt_prom_ops = ops;
 
-	allnodes = of_pdt_create_node(root_node, NULL);
+	of_allnodes = of_pdt_create_node(root_node, NULL);
 #if defined(CONFIG_SPARC)
-	allnodes->path_component_name = "";
+	of_allnodes->path_component_name = "";
 #endif
-	allnodes->full_name = "/";
+	of_allnodes->full_name = "/";
 
-	nextp = &allnodes->allnext;
-	allnodes->child = of_pdt_build_tree(allnodes,
-			of_pdt_prom_ops->getchild(allnodes->phandle), &nextp);
+	nextp = &of_allnodes->allnext;
+	of_allnodes->child = of_pdt_build_tree(of_allnodes,
+			of_pdt_prom_ops->getchild(of_allnodes->phandle), &nextp);
 
 	/* Get pointer to "/chosen" and "/aliasas" nodes for use everywhere */
 	of_alias_scan(kernel_tree_alloc);

commit 75c71848f22e6381f48614da23df2a43e374b498
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Tue Dec 27 22:58:40 2011 +0100

    of/pdt: fix section mismatch warning
    
    Fix the following section mismatch warning - seen when building sparc32:
    
    WARNING: vmlinux.o(.text+0x1ff9c0): Section mismatch in reference from the function kernel_tree_alloc() to the function .init.text:prom_early_alloc()
    The function kernel_tree_alloc() references
    the function __init prom_early_alloc().
    This is often because kernel_tree_alloc lacks a __init
    annotation or the annotation of prom_early_alloc is wrong.
    
    prom_early_alloc() is annotated __init, and users of
    kernel_tree_alloc() is also annotated __init.
    So simply match the annoation of these to fix the warning.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/pdt.c b/drivers/of/pdt.c
index bc5b3990f6ed..07cc1d678e4d 100644
--- a/drivers/of/pdt.c
+++ b/drivers/of/pdt.c
@@ -229,7 +229,7 @@ static struct device_node * __init of_pdt_build_tree(struct device_node *parent,
 	return ret;
 }
 
-static void *kernel_tree_alloc(u64 size, u64 align)
+static void * __init kernel_tree_alloc(u64 size, u64 align)
 {
 	return prom_early_alloc(size);
 }

commit 611cad720148c899db5a383c1c676fd820df7023
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Mon Aug 15 15:28:14 2011 +0800

    dt: add of_alias_scan and of_alias_get_id
    
    The patch adds function of_alias_scan to populate a global lookup
    table with the properties of 'aliases' node and function
    of_alias_get_id for drivers to find alias id from the lookup table.
    
    v3: Split out automatic addition of aliases on id lookup so that it can be
        debated separately from the core functionality.
    v2: - Add of_chosen/of_aliases populating and of_alias_scan() invocation
        for OF_PROMTREE.
        - Add locking
        - rework parse loop
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/pdt.c b/drivers/of/pdt.c
index 4d87b5dc9284..bc5b3990f6ed 100644
--- a/drivers/of/pdt.c
+++ b/drivers/of/pdt.c
@@ -229,6 +229,11 @@ static struct device_node * __init of_pdt_build_tree(struct device_node *parent,
 	return ret;
 }
 
+static void *kernel_tree_alloc(u64 size, u64 align)
+{
+	return prom_early_alloc(size);
+}
+
 void __init of_pdt_build_devicetree(phandle root_node, struct of_pdt_ops *ops)
 {
 	struct device_node **nextp;
@@ -245,4 +250,7 @@ void __init of_pdt_build_devicetree(phandle root_node, struct of_pdt_ops *ops)
 	nextp = &allnodes->allnext;
 	allnodes->child = of_pdt_build_tree(allnodes,
 			of_pdt_prom_ops->getchild(allnodes->phandle), &nextp);
+
+	/* Get pointer to "/chosen" and "/aliasas" nodes for use everywhere */
+	of_alias_scan(kernel_tree_alloc);
 }

commit a74ea43df1afc68f265c0ac2cb64031d855ae97b
Author: Andres Salomon <dilinger@queued.net>
Date:   Wed Feb 23 22:38:22 2011 -0800

    of/promtree: allow DT device matching by fixing 'name' brokenness (v5)
    
    Commit e2f2a93b, "of/promtree: add package-to-path support to pdt"
    changed dp->name from using the 'name' property to using
    package-to-path.  This fixed /proc/device-tree creation by eliminating
    conflicts between names (the 'name' property provides names like
    'battery', whereas package-to-path provides names like
    '/foo/bar/battery@0', which we stripped to 'battery@0').  However, it
    also breaks of_device_id table matching.
    
    The fix that we _really_ wanted was to keep dp->name based upon
    the name property ('battery'), but based dp->full_name upon
    package-to-path ('battery@0').  This patch does just that.
    
    This changes all users (except SPARC) of promtree to use the full
    result from package-to-path for full_name, rather than stripping the
    directory out.  In practice, the strings end up being exactly the
    same; this change saves time, code, and memory.
    
    SPARC continues to use the existing build_path_component() code.
    
    v2: combine two patches and revert of_pdt_node_name to original version
    v3: use dp->phandle instead of passing around node
    v4: warn/bail out for non-sparc archs if pkg2path is not set
    v5: split of_pdt_build_full_name into sparc & non-sparc versions
    v6: Pass NULL to pkg2path before buf gets assigned.
        Drop check for pkg2path hook on each and every node.
    v7: Don't BUG() when unable to get the full_path; create a
        known-unique name instead.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/pdt.c b/drivers/of/pdt.c
index 28295d0a50f6..4d87b5dc9284 100644
--- a/drivers/of/pdt.c
+++ b/drivers/of/pdt.c
@@ -36,19 +36,55 @@ unsigned int of_pdt_unique_id __initdata;
 	(p)->unique_id = of_pdt_unique_id++; \
 } while (0)
 
-static inline const char *of_pdt_node_name(struct device_node *dp)
+static char * __init of_pdt_build_full_name(struct device_node *dp)
 {
-	return dp->path_component_name;
+	int len, ourlen, plen;
+	char *n;
+
+	dp->path_component_name = build_path_component(dp);
+
+	plen = strlen(dp->parent->full_name);
+	ourlen = strlen(dp->path_component_name);
+	len = ourlen + plen + 2;
+
+	n = prom_early_alloc(len);
+	strcpy(n, dp->parent->full_name);
+	if (!of_node_is_root(dp->parent)) {
+		strcpy(n + plen, "/");
+		plen++;
+	}
+	strcpy(n + plen, dp->path_component_name);
+
+	return n;
 }
 
-#else
+#else /* CONFIG_SPARC */
 
 static inline void of_pdt_incr_unique_id(void *p) { }
 static inline void irq_trans_init(struct device_node *dp) { }
 
-static inline const char *of_pdt_node_name(struct device_node *dp)
+static char * __init of_pdt_build_full_name(struct device_node *dp)
 {
-	return dp->name;
+	static int failsafe_id = 0; /* for generating unique names on failure */
+	char *buf;
+	int len;
+
+	if (of_pdt_prom_ops->pkg2path(dp->phandle, NULL, 0, &len))
+		goto failsafe;
+
+	buf = prom_early_alloc(len + 1);
+	if (of_pdt_prom_ops->pkg2path(dp->phandle, buf, len, &len))
+		goto failsafe;
+	return buf;
+
+ failsafe:
+	buf = prom_early_alloc(strlen(dp->parent->full_name) +
+			       strlen(dp->name) + 16);
+	sprintf(buf, "%s/%s@unknown%i",
+		of_node_is_root(dp->parent) ? "" : dp->parent->full_name,
+		dp->name, failsafe_id++);
+	pr_err("%s: pkg2path failed; assigning %s\n", __func__, buf);
+	return buf;
 }
 
 #endif /* !CONFIG_SPARC */
@@ -132,47 +168,6 @@ static char * __init of_pdt_get_one_property(phandle node, const char *name)
 	return buf;
 }
 
-static char * __init of_pdt_try_pkg2path(phandle node)
-{
-	char *res, *buf = NULL;
-	int len;
-
-	if (!of_pdt_prom_ops->pkg2path)
-		return NULL;
-
-	if (of_pdt_prom_ops->pkg2path(node, buf, 0, &len))
-		return NULL;
-	buf = prom_early_alloc(len + 1);
-	if (of_pdt_prom_ops->pkg2path(node, buf, len, &len)) {
-		pr_err("%s: package-to-path failed\n", __func__);
-		return NULL;
-	}
-
-	res = strrchr(buf, '/');
-	if (!res) {
-		pr_err("%s: couldn't find / in %s\n", __func__, buf);
-		return NULL;
-	}
-	return res+1;
-}
-
-/*
- * When fetching the node's name, first try using package-to-path; if
- * that fails (either because the arch hasn't supplied a PROM callback,
- * or some other random failure), fall back to just looking at the node's
- * 'name' property.
- */
-static char * __init of_pdt_build_name(phandle node)
-{
-	char *buf;
-
-	buf = of_pdt_try_pkg2path(node);
-	if (!buf)
-		buf = of_pdt_get_one_property(node, "name");
-
-	return buf;
-}
-
 static struct device_node * __init of_pdt_create_node(phandle node,
 						    struct device_node *parent)
 {
@@ -187,7 +182,7 @@ static struct device_node * __init of_pdt_create_node(phandle node,
 
 	kref_init(&dp->kref);
 
-	dp->name = of_pdt_build_name(node);
+	dp->name = of_pdt_get_one_property(node, "name");
 	dp->type = of_pdt_get_one_property(node, "device_type");
 	dp->phandle = node;
 
@@ -198,26 +193,6 @@ static struct device_node * __init of_pdt_create_node(phandle node,
 	return dp;
 }
 
-static char * __init of_pdt_build_full_name(struct device_node *dp)
-{
-	int len, ourlen, plen;
-	char *n;
-
-	plen = strlen(dp->parent->full_name);
-	ourlen = strlen(of_pdt_node_name(dp));
-	len = ourlen + plen + 2;
-
-	n = prom_early_alloc(len);
-	strcpy(n, dp->parent->full_name);
-	if (!of_node_is_root(dp->parent)) {
-		strcpy(n + plen, "/");
-		plen++;
-	}
-	strcpy(n + plen, of_pdt_node_name(dp));
-
-	return n;
-}
-
 static struct device_node * __init of_pdt_build_tree(struct device_node *parent,
 						   phandle node,
 						   struct device_node ***nextp)
@@ -240,9 +215,6 @@ static struct device_node * __init of_pdt_build_tree(struct device_node *parent,
 		*(*nextp) = dp;
 		*nextp = &dp->allnext;
 
-#if defined(CONFIG_SPARC)
-		dp->path_component_name = build_path_component(dp);
-#endif
 		dp->full_name = of_pdt_build_full_name(dp);
 
 		dp->child = of_pdt_build_tree(dp,

commit e2f2a93b6384cfe0face0be595bfbda1475d864b
Author: Andres Salomon <dilinger@queued.net>
Date:   Sun Oct 10 21:52:57 2010 -0600

    of/promtree: add package-to-path support to pdt
    
    package-to-path is a PROM function which tells us the real (full) name of the
    node.  This provides a hook for that in the prom ops struct, and makes use
    of it in the pdt code when attempting to determine a node's name.  If the
    hook is available, try using it (falling back to looking at the "name"
    property if it fails).
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/pdt.c b/drivers/of/pdt.c
index 31a4fb8694db..28295d0a50f6 100644
--- a/drivers/of/pdt.c
+++ b/drivers/of/pdt.c
@@ -132,6 +132,47 @@ static char * __init of_pdt_get_one_property(phandle node, const char *name)
 	return buf;
 }
 
+static char * __init of_pdt_try_pkg2path(phandle node)
+{
+	char *res, *buf = NULL;
+	int len;
+
+	if (!of_pdt_prom_ops->pkg2path)
+		return NULL;
+
+	if (of_pdt_prom_ops->pkg2path(node, buf, 0, &len))
+		return NULL;
+	buf = prom_early_alloc(len + 1);
+	if (of_pdt_prom_ops->pkg2path(node, buf, len, &len)) {
+		pr_err("%s: package-to-path failed\n", __func__);
+		return NULL;
+	}
+
+	res = strrchr(buf, '/');
+	if (!res) {
+		pr_err("%s: couldn't find / in %s\n", __func__, buf);
+		return NULL;
+	}
+	return res+1;
+}
+
+/*
+ * When fetching the node's name, first try using package-to-path; if
+ * that fails (either because the arch hasn't supplied a PROM callback,
+ * or some other random failure), fall back to just looking at the node's
+ * 'name' property.
+ */
+static char * __init of_pdt_build_name(phandle node)
+{
+	char *buf;
+
+	buf = of_pdt_try_pkg2path(node);
+	if (!buf)
+		buf = of_pdt_get_one_property(node, "name");
+
+	return buf;
+}
+
 static struct device_node * __init of_pdt_create_node(phandle node,
 						    struct device_node *parent)
 {
@@ -146,7 +187,7 @@ static struct device_node * __init of_pdt_create_node(phandle node,
 
 	kref_init(&dp->kref);
 
-	dp->name = of_pdt_get_one_property(node, "name");
+	dp->name = of_pdt_build_name(node);
 	dp->type = of_pdt_get_one_property(node, "device_type");
 	dp->phandle = node;
 

commit ed41850298f7a55519de0b8573e217ed8a45c199
Author: Andres Salomon <dilinger@queued.net>
Date:   Sun Oct 10 21:51:25 2010 -0600

    of/promtree: add of_pdt namespace to pdt code
    
    For symbols still lacking namespace qualifiers, add an of_pdt_ prefix.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/pdt.c b/drivers/of/pdt.c
index fd02fc1dd891..31a4fb8694db 100644
--- a/drivers/of/pdt.c
+++ b/drivers/of/pdt.c
@@ -26,7 +26,7 @@
 
 static struct of_pdt_ops *of_pdt_prom_ops __initdata;
 
-void __initdata (*prom_build_more)(struct device_node *dp,
+void __initdata (*of_pdt_build_more)(struct device_node *dp,
 		struct device_node ***nextp);
 
 #if defined(CONFIG_SPARC)
@@ -53,7 +53,7 @@ static inline const char *of_pdt_node_name(struct device_node *dp)
 
 #endif /* !CONFIG_SPARC */
 
-static struct property * __init build_one_prop(phandle node, char *prev,
+static struct property * __init of_pdt_build_one_prop(phandle node, char *prev,
 					       char *special_name,
 					       void *special_val,
 					       int special_len)
@@ -100,17 +100,17 @@ static struct property * __init build_one_prop(phandle node, char *prev,
 	return p;
 }
 
-static struct property * __init build_prop_list(phandle node)
+static struct property * __init of_pdt_build_prop_list(phandle node)
 {
 	struct property *head, *tail;
 
-	head = tail = build_one_prop(node, NULL,
+	head = tail = of_pdt_build_one_prop(node, NULL,
 				     ".node", &node, sizeof(node));
 
-	tail->next = build_one_prop(node, NULL, NULL, NULL, 0);
+	tail->next = of_pdt_build_one_prop(node, NULL, NULL, NULL, 0);
 	tail = tail->next;
 	while(tail) {
-		tail->next = build_one_prop(node, tail->name,
+		tail->next = of_pdt_build_one_prop(node, tail->name,
 					    NULL, NULL, 0);
 		tail = tail->next;
 	}
@@ -118,7 +118,7 @@ static struct property * __init build_prop_list(phandle node)
 	return head;
 }
 
-static char * __init get_one_property(phandle node, const char *name)
+static char * __init of_pdt_get_one_property(phandle node, const char *name)
 {
 	char *buf = "<NULL>";
 	int len;
@@ -132,7 +132,7 @@ static char * __init get_one_property(phandle node, const char *name)
 	return buf;
 }
 
-static struct device_node * __init prom_create_node(phandle node,
+static struct device_node * __init of_pdt_create_node(phandle node,
 						    struct device_node *parent)
 {
 	struct device_node *dp;
@@ -146,18 +146,18 @@ static struct device_node * __init prom_create_node(phandle node,
 
 	kref_init(&dp->kref);
 
-	dp->name = get_one_property(node, "name");
-	dp->type = get_one_property(node, "device_type");
+	dp->name = of_pdt_get_one_property(node, "name");
+	dp->type = of_pdt_get_one_property(node, "device_type");
 	dp->phandle = node;
 
-	dp->properties = build_prop_list(node);
+	dp->properties = of_pdt_build_prop_list(node);
 
 	irq_trans_init(dp);
 
 	return dp;
 }
 
-static char * __init build_full_name(struct device_node *dp)
+static char * __init of_pdt_build_full_name(struct device_node *dp)
 {
 	int len, ourlen, plen;
 	char *n;
@@ -177,7 +177,7 @@ static char * __init build_full_name(struct device_node *dp)
 	return n;
 }
 
-static struct device_node * __init prom_build_tree(struct device_node *parent,
+static struct device_node * __init of_pdt_build_tree(struct device_node *parent,
 						   phandle node,
 						   struct device_node ***nextp)
 {
@@ -185,7 +185,7 @@ static struct device_node * __init prom_build_tree(struct device_node *parent,
 	struct device_node *dp;
 
 	while (1) {
-		dp = prom_create_node(node, parent);
+		dp = of_pdt_create_node(node, parent);
 		if (!dp)
 			break;
 
@@ -202,13 +202,13 @@ static struct device_node * __init prom_build_tree(struct device_node *parent,
 #if defined(CONFIG_SPARC)
 		dp->path_component_name = build_path_component(dp);
 #endif
-		dp->full_name = build_full_name(dp);
+		dp->full_name = of_pdt_build_full_name(dp);
 
-		dp->child = prom_build_tree(dp,
+		dp->child = of_pdt_build_tree(dp,
 				of_pdt_prom_ops->getchild(node), nextp);
 
-		if (prom_build_more)
-			prom_build_more(dp, nextp);
+		if (of_pdt_build_more)
+			of_pdt_build_more(dp, nextp);
 
 		node = of_pdt_prom_ops->getsibling(node);
 	}
@@ -223,13 +223,13 @@ void __init of_pdt_build_devicetree(phandle root_node, struct of_pdt_ops *ops)
 	BUG_ON(!ops);
 	of_pdt_prom_ops = ops;
 
-	allnodes = prom_create_node(root_node, NULL);
+	allnodes = of_pdt_create_node(root_node, NULL);
 #if defined(CONFIG_SPARC)
 	allnodes->path_component_name = "";
 #endif
 	allnodes->full_name = "/";
 
 	nextp = &allnodes->allnext;
-	allnodes->child = prom_build_tree(allnodes,
+	allnodes->child = of_pdt_build_tree(allnodes,
 			of_pdt_prom_ops->getchild(allnodes->phandle), &nextp);
 }

commit f90c34bd658d240cb5ebc5fe0a17796e590c6ec8
Author: Andres Salomon <dilinger@queued.net>
Date:   Sun Oct 10 21:49:45 2010 -0600

    of/promtree: no longer call prom_ functions directly; use an ops structure
    
    Rather than assuming an architecture defines prom_getchild and friends,
    define an ops struct with hooks for the various prom functions that
    pdt.c needs.  This ops struct is filled in by the
    arch-(and sometimes firmware-)specific code, and passed to
    of_pdt_build_devicetree.
    
    Update sparc code to define the ops struct as well.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/pdt.c b/drivers/of/pdt.c
index 2fdb1b478d6f..fd02fc1dd891 100644
--- a/drivers/of/pdt.c
+++ b/drivers/of/pdt.c
@@ -23,7 +23,8 @@
 #include <linux/of.h>
 #include <linux/of_pdt.h>
 #include <asm/prom.h>
-#include <asm/oplib.h>
+
+static struct of_pdt_ops *of_pdt_prom_ops __initdata;
 
 void __initdata (*prom_build_more)(struct device_node *dp,
 		struct device_node ***nextp);
@@ -59,7 +60,7 @@ static struct property * __init build_one_prop(phandle node, char *prev,
 {
 	static struct property *tmp = NULL;
 	struct property *p;
-	const char *name;
+	int err;
 
 	if (tmp) {
 		p = tmp;
@@ -77,28 +78,20 @@ static struct property * __init build_one_prop(phandle node, char *prev,
 		p->value = prom_early_alloc(special_len);
 		memcpy(p->value, special_val, special_len);
 	} else {
-		if (prev == NULL) {
-			name = prom_firstprop(node, p->name);
-		} else {
-			name = prom_nextprop(node, prev, p->name);
-		}
-
-		if (!name || strlen(name) == 0) {
+		err = of_pdt_prom_ops->nextprop(node, prev, p->name);
+		if (err) {
 			tmp = p;
 			return NULL;
 		}
-#ifdef CONFIG_SPARC32
-		strcpy(p->name, name);
-#endif
-		p->length = prom_getproplen(node, p->name);
+		p->length = of_pdt_prom_ops->getproplen(node, p->name);
 		if (p->length <= 0) {
 			p->length = 0;
 		} else {
 			int len;
 
 			p->value = prom_early_alloc(p->length + 1);
-			len = prom_getproperty(node, p->name, p->value,
-					       p->length);
+			len = of_pdt_prom_ops->getproperty(node, p->name,
+					p->value, p->length);
 			if (len <= 0)
 				p->length = 0;
 			((unsigned char *)p->value)[p->length] = '\0';
@@ -130,10 +123,10 @@ static char * __init get_one_property(phandle node, const char *name)
 	char *buf = "<NULL>";
 	int len;
 
-	len = prom_getproplen(node, name);
+	len = of_pdt_prom_ops->getproplen(node, name);
 	if (len > 0) {
 		buf = prom_early_alloc(len);
-		len = prom_getproperty(node, name, buf, len);
+		len = of_pdt_prom_ops->getproperty(node, name, buf, len);
 	}
 
 	return buf;
@@ -211,21 +204,25 @@ static struct device_node * __init prom_build_tree(struct device_node *parent,
 #endif
 		dp->full_name = build_full_name(dp);
 
-		dp->child = prom_build_tree(dp, prom_getchild(node), nextp);
+		dp->child = prom_build_tree(dp,
+				of_pdt_prom_ops->getchild(node), nextp);
 
 		if (prom_build_more)
 			prom_build_more(dp, nextp);
 
-		node = prom_getsibling(node);
+		node = of_pdt_prom_ops->getsibling(node);
 	}
 
 	return ret;
 }
 
-void __init of_pdt_build_devicetree(phandle root_node)
+void __init of_pdt_build_devicetree(phandle root_node, struct of_pdt_ops *ops)
 {
 	struct device_node **nextp;
 
+	BUG_ON(!ops);
+	of_pdt_prom_ops = ops;
+
 	allnodes = prom_create_node(root_node, NULL);
 #if defined(CONFIG_SPARC)
 	allnodes->path_component_name = "";
@@ -234,6 +231,5 @@ void __init of_pdt_build_devicetree(phandle root_node)
 
 	nextp = &allnodes->allnext;
 	allnodes->child = prom_build_tree(allnodes,
-					  prom_getchild(allnodes->phandle),
-					  &nextp);
+			of_pdt_prom_ops->getchild(allnodes->phandle), &nextp);
 }

commit 3cfc535c5df8122af1258ae05aaf2770c033425d
Author: Andres Salomon <dilinger@queued.net>
Date:   Sun Oct 10 21:42:33 2010 -0600

    of/promtree: make drivers/of/pdt.c no longer sparc-only
    
    Clean up pdt.c:
     - make build dependent upon config OF_PROMTREE
     - #ifdef out the sparc-specific stuff
     - create pdt-specific header
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/pdt.c b/drivers/of/pdt.c
index c3c2d70b3f75..2fdb1b478d6f 100644
--- a/drivers/of/pdt.c
+++ b/drivers/of/pdt.c
@@ -1,4 +1,4 @@
-/* prom_common.c: OF device tree support common code.
+/* pdt.c: OF PROM device tree support code.
  *
  * Paul Mackerras	August 1996.
  * Copyright (C) 1996-2005 Paul Mackerras.
@@ -7,6 +7,7 @@
  *    {engebret|bergner}@us.ibm.com
  *
  *  Adapted for sparc by David S. Miller davem@davemloft.net
+ *  Adapted for multiple architectures by Andres Salomon <dilinger@queued.net>
  *
  *      This program is free software; you can redistribute it and/or
  *      modify it under the terms of the GNU General Public License
@@ -20,13 +21,36 @@
 #include <linux/mutex.h>
 #include <linux/slab.h>
 #include <linux/of.h>
+#include <linux/of_pdt.h>
 #include <asm/prom.h>
 #include <asm/oplib.h>
-#include <asm/leon.h>
 
-void (*prom_build_more)(struct device_node *dp, struct device_node ***nextp);
+void __initdata (*prom_build_more)(struct device_node *dp,
+		struct device_node ***nextp);
 
-unsigned int prom_unique_id;
+#if defined(CONFIG_SPARC)
+unsigned int of_pdt_unique_id __initdata;
+
+#define of_pdt_incr_unique_id(p) do { \
+	(p)->unique_id = of_pdt_unique_id++; \
+} while (0)
+
+static inline const char *of_pdt_node_name(struct device_node *dp)
+{
+	return dp->path_component_name;
+}
+
+#else
+
+static inline void of_pdt_incr_unique_id(void *p) { }
+static inline void irq_trans_init(struct device_node *dp) { }
+
+static inline const char *of_pdt_node_name(struct device_node *dp)
+{
+	return dp->name;
+}
+
+#endif /* !CONFIG_SPARC */
 
 static struct property * __init build_one_prop(phandle node, char *prev,
 					       char *special_name,
@@ -43,7 +67,7 @@ static struct property * __init build_one_prop(phandle node, char *prev,
 		tmp = NULL;
 	} else {
 		p = prom_early_alloc(sizeof(struct property) + 32);
-		p->unique_id = prom_unique_id++;
+		of_pdt_incr_unique_id(p);
 	}
 
 	p->name = (char *) (p + 1);
@@ -124,7 +148,7 @@ static struct device_node * __init prom_create_node(phandle node,
 		return NULL;
 
 	dp = prom_early_alloc(sizeof(*dp));
-	dp->unique_id = prom_unique_id++;
+	of_pdt_incr_unique_id(dp);
 	dp->parent = parent;
 
 	kref_init(&dp->kref);
@@ -140,13 +164,13 @@ static struct device_node * __init prom_create_node(phandle node,
 	return dp;
 }
 
-char * __init build_full_name(struct device_node *dp)
+static char * __init build_full_name(struct device_node *dp)
 {
 	int len, ourlen, plen;
 	char *n;
 
 	plen = strlen(dp->parent->full_name);
-	ourlen = strlen(dp->path_component_name);
+	ourlen = strlen(of_pdt_node_name(dp));
 	len = ourlen + plen + 2;
 
 	n = prom_early_alloc(len);
@@ -155,7 +179,7 @@ char * __init build_full_name(struct device_node *dp)
 		strcpy(n + plen, "/");
 		plen++;
 	}
-	strcpy(n + plen, dp->path_component_name);
+	strcpy(n + plen, of_pdt_node_name(dp));
 
 	return n;
 }
@@ -182,7 +206,9 @@ static struct device_node * __init prom_build_tree(struct device_node *parent,
 		*(*nextp) = dp;
 		*nextp = &dp->allnext;
 
+#if defined(CONFIG_SPARC)
 		dp->path_component_name = build_path_component(dp);
+#endif
 		dp->full_name = build_full_name(dp);
 
 		dp->child = prom_build_tree(dp, prom_getchild(node), nextp);
@@ -196,20 +222,18 @@ static struct device_node * __init prom_build_tree(struct device_node *parent,
 	return ret;
 }
 
-void __init prom_build_devicetree(void)
+void __init of_pdt_build_devicetree(phandle root_node)
 {
 	struct device_node **nextp;
 
-	allnodes = prom_create_node(prom_root_node, NULL);
+	allnodes = prom_create_node(root_node, NULL);
+#if defined(CONFIG_SPARC)
 	allnodes->path_component_name = "";
+#endif
 	allnodes->full_name = "/";
 
 	nextp = &allnodes->allnext;
 	allnodes->child = prom_build_tree(allnodes,
 					  prom_getchild(allnodes->phandle),
 					  &nextp);
-	of_console_init();
-
-	printk("PROM: Built device tree with %u bytes of memory.\n",
-	       prom_early_allocated);
 }

commit 9bdf6bab4ecfb6a8ca50c0c46f2365ef6c3e35b7
Author: Andres Salomon <dilinger@queued.net>
Date:   Mon Aug 30 03:57:28 2010 +0000

    sparc: break out some PROM device-tree building code out into drivers/of
    
    Transitioning into making this useful for architectures other than sparc.
    This is a verbatim copy of all functions/variables that've been moved.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/pdt.c b/drivers/of/pdt.c
new file mode 100644
index 000000000000..c3c2d70b3f75
--- /dev/null
+++ b/drivers/of/pdt.c
@@ -0,0 +1,215 @@
+/* prom_common.c: OF device tree support common code.
+ *
+ * Paul Mackerras	August 1996.
+ * Copyright (C) 1996-2005 Paul Mackerras.
+ *
+ *  Adapted for 64bit PowerPC by Dave Engebretsen and Peter Bergner.
+ *    {engebret|bergner}@us.ibm.com
+ *
+ *  Adapted for sparc by David S. Miller davem@davemloft.net
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <asm/prom.h>
+#include <asm/oplib.h>
+#include <asm/leon.h>
+
+void (*prom_build_more)(struct device_node *dp, struct device_node ***nextp);
+
+unsigned int prom_unique_id;
+
+static struct property * __init build_one_prop(phandle node, char *prev,
+					       char *special_name,
+					       void *special_val,
+					       int special_len)
+{
+	static struct property *tmp = NULL;
+	struct property *p;
+	const char *name;
+
+	if (tmp) {
+		p = tmp;
+		memset(p, 0, sizeof(*p) + 32);
+		tmp = NULL;
+	} else {
+		p = prom_early_alloc(sizeof(struct property) + 32);
+		p->unique_id = prom_unique_id++;
+	}
+
+	p->name = (char *) (p + 1);
+	if (special_name) {
+		strcpy(p->name, special_name);
+		p->length = special_len;
+		p->value = prom_early_alloc(special_len);
+		memcpy(p->value, special_val, special_len);
+	} else {
+		if (prev == NULL) {
+			name = prom_firstprop(node, p->name);
+		} else {
+			name = prom_nextprop(node, prev, p->name);
+		}
+
+		if (!name || strlen(name) == 0) {
+			tmp = p;
+			return NULL;
+		}
+#ifdef CONFIG_SPARC32
+		strcpy(p->name, name);
+#endif
+		p->length = prom_getproplen(node, p->name);
+		if (p->length <= 0) {
+			p->length = 0;
+		} else {
+			int len;
+
+			p->value = prom_early_alloc(p->length + 1);
+			len = prom_getproperty(node, p->name, p->value,
+					       p->length);
+			if (len <= 0)
+				p->length = 0;
+			((unsigned char *)p->value)[p->length] = '\0';
+		}
+	}
+	return p;
+}
+
+static struct property * __init build_prop_list(phandle node)
+{
+	struct property *head, *tail;
+
+	head = tail = build_one_prop(node, NULL,
+				     ".node", &node, sizeof(node));
+
+	tail->next = build_one_prop(node, NULL, NULL, NULL, 0);
+	tail = tail->next;
+	while(tail) {
+		tail->next = build_one_prop(node, tail->name,
+					    NULL, NULL, 0);
+		tail = tail->next;
+	}
+
+	return head;
+}
+
+static char * __init get_one_property(phandle node, const char *name)
+{
+	char *buf = "<NULL>";
+	int len;
+
+	len = prom_getproplen(node, name);
+	if (len > 0) {
+		buf = prom_early_alloc(len);
+		len = prom_getproperty(node, name, buf, len);
+	}
+
+	return buf;
+}
+
+static struct device_node * __init prom_create_node(phandle node,
+						    struct device_node *parent)
+{
+	struct device_node *dp;
+
+	if (!node)
+		return NULL;
+
+	dp = prom_early_alloc(sizeof(*dp));
+	dp->unique_id = prom_unique_id++;
+	dp->parent = parent;
+
+	kref_init(&dp->kref);
+
+	dp->name = get_one_property(node, "name");
+	dp->type = get_one_property(node, "device_type");
+	dp->phandle = node;
+
+	dp->properties = build_prop_list(node);
+
+	irq_trans_init(dp);
+
+	return dp;
+}
+
+char * __init build_full_name(struct device_node *dp)
+{
+	int len, ourlen, plen;
+	char *n;
+
+	plen = strlen(dp->parent->full_name);
+	ourlen = strlen(dp->path_component_name);
+	len = ourlen + plen + 2;
+
+	n = prom_early_alloc(len);
+	strcpy(n, dp->parent->full_name);
+	if (!of_node_is_root(dp->parent)) {
+		strcpy(n + plen, "/");
+		plen++;
+	}
+	strcpy(n + plen, dp->path_component_name);
+
+	return n;
+}
+
+static struct device_node * __init prom_build_tree(struct device_node *parent,
+						   phandle node,
+						   struct device_node ***nextp)
+{
+	struct device_node *ret = NULL, *prev_sibling = NULL;
+	struct device_node *dp;
+
+	while (1) {
+		dp = prom_create_node(node, parent);
+		if (!dp)
+			break;
+
+		if (prev_sibling)
+			prev_sibling->sibling = dp;
+
+		if (!ret)
+			ret = dp;
+		prev_sibling = dp;
+
+		*(*nextp) = dp;
+		*nextp = &dp->allnext;
+
+		dp->path_component_name = build_path_component(dp);
+		dp->full_name = build_full_name(dp);
+
+		dp->child = prom_build_tree(dp, prom_getchild(node), nextp);
+
+		if (prom_build_more)
+			prom_build_more(dp, nextp);
+
+		node = prom_getsibling(node);
+	}
+
+	return ret;
+}
+
+void __init prom_build_devicetree(void)
+{
+	struct device_node **nextp;
+
+	allnodes = prom_create_node(prom_root_node, NULL);
+	allnodes->path_component_name = "";
+	allnodes->full_name = "/";
+
+	nextp = &allnodes->allnext;
+	allnodes->child = prom_build_tree(allnodes,
+					  prom_getchild(allnodes->phandle),
+					  &nextp);
+	of_console_init();
+
+	printk("PROM: Built device tree with %u bytes of memory.\n",
+	       prom_early_allocated);
+}
