commit 7456427af9def0fec5508dd8b861556038ee96a8
Author: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
Date:   Mon Apr 20 14:01:02 2020 +0200

    of: property: Do not link to disabled devices
    
    When creating a consumer/supplier relationship between two devices,
    make sure the supplier node is actually active. Otherwise this will
    create a link relationship that will never be fulfilled. This, in the
    worst case scenario, will hang the system during boot.
    
    Note that, in practice, the fact that a device-tree represented
    consumer/supplier relationship isn't fulfilled will not prevent devices
    from successfully probing.
    
    Fixes: a3e1d1a7f5fc ("of: property: Add functional dependency link from DT bindings")
    Signed-off-by: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
    Reviewed-by: Saravana Kannan <saravanak@google.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index 9674b3cf500d..1f2086f4e7ce 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -1045,8 +1045,20 @@ static int of_link_to_phandle(struct device *dev, struct device_node *sup_np,
 	 * Find the device node that contains the supplier phandle.  It may be
 	 * @sup_np or it may be an ancestor of @sup_np.
 	 */
-	while (sup_np && !of_find_property(sup_np, "compatible", NULL))
+	while (sup_np) {
+
+		/* Don't allow linking to a disabled supplier */
+		if (!of_device_is_available(sup_np)) {
+			of_node_put(sup_np);
+			sup_np = NULL;
+		}
+
+		if (of_find_property(sup_np, "compatible", NULL))
+			break;
+
 		sup_np = of_get_next_parent(sup_np);
+	}
+
 	if (!sup_np) {
 		dev_dbg(dev, "Not linking to %pOFP - No device\n", tmp_np);
 		return -ENODEV;

commit ed3655729182a59b9bef1b564c6fc2dcbbbe954e
Author: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
Date:   Mon Apr 20 14:01:01 2020 +0200

    of: property: Fix create device links for all child-supplier dependencies
    
    Upon adding a new device from a DT node, we scan its properties and its
    children's properties in order to create a consumer/supplier
    relationship between the device and the property provider.
    
    That said, it's possible for some of the node's children to be disabled,
    which will create links that'll never be fulfilled.
    
    To get around this, use the for_each_available_child_of_node() function
    instead of for_each_available_node() when iterating over the node's
    children.
    
    Fixes: d4387cd11741 ("of: property: Create device links for all child-supplier depencencies")
    Signed-off-by: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
    Reviewed-by: Saravana Kannan <saravanak@google.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index ee1bc267f975..9674b3cf500d 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -1298,7 +1298,7 @@ static int of_link_to_suppliers(struct device *dev,
 		if (of_link_property(dev, con_np, p->name))
 			ret = -ENODEV;
 
-	for_each_child_of_node(con_np, child)
+	for_each_available_child_of_node(con_np, child)
 		if (of_link_to_suppliers(dev, child) && !ret)
 			ret = -EAGAIN;
 

commit 8f88fad370bb0884f7f7217dea254b202df44716
Author: Saravana Kannan <saravanak@google.com>
Date:   Thu Apr 16 13:58:38 2020 -0700

    of: property: Don't retry device_link_add() upon failure
    
    When of_link_to_phandle() was implemented initially, there was no way to
    tell if device_link_add() was failing because the supplier device hasn't
    been parsed yet, hasn't been added yet, the links were creating a cycle,
    etc. Some of these were transient errors that'd go away at a later
    point.
    
    However, with the current set of improved checks, if device_link_add()
    fails, it'll only be for permanent errors like cycles or out-of-memory
    errors.
    
    Also, with the addition of DL_FLAG_SYNC_STATE_ONLY flag [1] to device
    links, all the valid dependency cycles due to "proxy" device links
    (needed for correctness of sync_state() device callback) will never fail
    device_link_add() due to cycles.
    
    So, continuing to retry failing device links (by returning -EAGAIN) is
    no longer useful. At worst, it prevents platforms from setting
    fw_devlink=on (or better) because it prevents proper boot up. So, let's
    not do that anymore.
    
    [1] - https://lore.kernel.org/lkml/20191028220027.251605-1-saravanak@google.com/
    Cc: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Tested-by: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index 252e4f600155..ee1bc267f975 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -1074,7 +1074,7 @@ static int of_link_to_phandle(struct device *dev, struct device_node *sup_np,
 		return -EAGAIN;
 	}
 	if (!device_link_add(dev, sup_dev, dl_flags))
-		ret = -EAGAIN;
+		ret = -EINVAL;
 	put_device(sup_dev);
 	return ret;
 }

commit 78056e701c61132d15e0942e415926a6393fcf17
Author: Saravana Kannan <saravanak@google.com>
Date:   Wed Apr 1 15:52:03 2020 -0700

    of: property: Add device link support for extcon
    
    Add support for creating device links out of more DT properties.
    
    Cc: MyungJoo Ham <myungjoo.ham@samsung.com>
    Cc: Chanwoo Choi <cw00.choi@samsung.com>
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index b4916dcc9e72..252e4f600155 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -1206,6 +1206,7 @@ DEFINE_SIMPLE_PROP(interrupt_parent, "interrupt-parent", NULL)
 DEFINE_SIMPLE_PROP(dmas, "dmas", "#dma-cells")
 DEFINE_SIMPLE_PROP(power_domains, "power-domains", "#power-domain-cells")
 DEFINE_SIMPLE_PROP(hwlocks, "hwlocks", "#hwlock-cells")
+DEFINE_SIMPLE_PROP(extcon, "extcon", NULL)
 DEFINE_SUFFIX_PROP(regulators, "-supply", NULL)
 DEFINE_SUFFIX_PROP(gpio, "-gpio", "#gpio-cells")
 DEFINE_SUFFIX_PROP(gpios, "-gpios", "#gpio-cells")
@@ -1230,6 +1231,7 @@ static const struct supplier_bindings of_supplier_bindings[] = {
 	{ .parse_prop = parse_dmas, },
 	{ .parse_prop = parse_power_domains, },
 	{ .parse_prop = parse_hwlocks, },
+	{ .parse_prop = parse_extcon, },
 	{ .parse_prop = parse_regulators, },
 	{ .parse_prop = parse_gpio, },
 	{ .parse_prop = parse_gpios, },

commit bef7b2a7be28638770972ab2709adf11d601c11a
Merge: 79f51b7b9c47 8967918e7cee
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 2 17:32:52 2020 -0700

    Merge tag 'devicetree-for-5.7' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull devicetree updates from Rob Herring:
    
     - Unit test for overlays with GPIO hogs
    
     - Improve dma-ranges parsing to handle dma-ranges with multiple entries
    
     - Update dtc to upstream version v1.6.0-2-g87a656ae5ff9
    
     - Improve overlay error reporting
    
     - Device link support for power-domains and hwlocks bindings
    
     - Add vendor prefixes for Beacon, Topwise, ENE, Dell, SG Micro, Elida,
       PocketBook, Xiaomi, Linutronix, OzzMaker, Waveshare Electronics, and
       ITE Tech
    
     - Add deprecated Marvell vendor prefix 'mrvl'
    
     - A bunch of binding conversions to DT schema continues. Of note, the
       common serial and USB connector bindings are converted.
    
     - Add more Arm CPU compatibles
    
     - Drop Mark Rutland as DT maintainer :(
    
    * tag 'devicetree-for-5.7' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (106 commits)
      MAINTAINERS: drop an old reference to stm32 pwm timers doc
      MAINTAINERS: dt: update etnaviv file reference
      dt-bindings: usb: dwc2: fix bindings for amlogic, meson-gxbb-usb
      dt-bindings: uniphier-system-bus: fix warning in the example
      dt-bindings: display: meson-vpu: fix indentation of reg-names' "items"
      dt-bindings: iio: Fix adi, ltc2983 uint64-matrix schema constraints
      dt-bindings: power: Fix example for power-domain
      dt-bindings: arm: Add some constraints for PSCI nodes
      of: some unittest overlays not untracked
      of: gpio unittest kfree() wrong object
      dt-bindings: phy: convert phy-rockchip-inno-usb2 bindings to yaml
      dt-bindings: serial: sh-sci: Convert to json-schema
      dt-bindings: serial: Document serialN aliases
      dt-bindings: thermal: tsens: Set 'additionalProperties: false'
      dt-bindings: thermal: tsens: Fix nvmem-cell-names schema
      dt-bindings: vendor-prefixes: Add Beacon vendor prefix
      dt-bindings: vendor-prefixes: Add Topwise
      of: of_private.h: Replace zero-length array with flexible-array member
      docs: dt: fix a broken reference to input.yaml
      docs: dt: fix references to ap806-system-controller.txt
      ...

commit e94f62b7140fa3da4c69a685b2e73ef52dd32c51
Author: Saravana Kannan <saravanak@google.com>
Date:   Fri Feb 21 17:40:38 2020 -0800

    of: property: Delete of_devlink kernel commandline option
    
    With the addition of fw_devlink kernel commandline option, of_devlink is
    redundant and not useful anymore. So, delete it.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20200222014038.180923-6-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index 15fc9315f1a7..f104f15b57fb 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -1299,15 +1299,9 @@ static int of_link_to_suppliers(struct device *dev,
 	return ret;
 }
 
-static bool of_devlink;
-core_param(of_devlink, of_devlink, bool, 0);
-
 static int of_fwnode_add_links(const struct fwnode_handle *fwnode,
 			       struct device *dev)
 {
-	if (!of_devlink)
-		return 0;
-
 	if (unlikely(!is_of_node(fwnode)))
 		return 0;
 

commit bc749007ad8d8ff19ae1939b24e8173ef23e42bd
Author: Saravana Kannan <saravanak@google.com>
Date:   Fri Feb 21 17:40:37 2020 -0800

    of: property: Start using fw_devlink_get_flags()
    
    The fw_devlink_get_flags() provides the right flags to use when creating
    mandatory device links derived from information provided by the
    firmware. So, use that.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20200222014038.180923-5-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index e851c57a15b0..15fc9315f1a7 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -1262,7 +1262,7 @@ static int of_link_property(struct device *dev, struct device_node *con_np,
 	u32 dl_flags;
 
 	if (dev->of_node == con_np)
-		dl_flags = DL_FLAG_AUTOPROBE_CONSUMER;
+		dl_flags = fw_devlink_get_flags();
 	else
 		dl_flags = DL_FLAG_SYNC_STATE_ONLY;
 

commit 2f7afc343d49eea0bf88ea5fc8cb3afc392356c3
Author: Saravana Kannan <saravanak@google.com>
Date:   Wed Feb 19 21:52:50 2020 -0800

    of: property: Add device link support for power-domains and hwlocks
    
    Add support for creating device links out of more DT properties.
    
    To: lkml <linux-kernel@vger.kernel.org>
    To: John Stultz <john.stultz@linaro.org>
    To: Rob Herring <robh@kernel.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Kevin Hilman <khilman@kernel.org>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Todd Kjos <tkjos@google.com>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: linux-pm@vger.kernel.org
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Tested-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index e851c57a15b0..d977c11decda 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -1204,6 +1204,8 @@ DEFINE_SIMPLE_PROP(mboxes, "mboxes", "#mbox-cells")
 DEFINE_SIMPLE_PROP(io_channels, "io-channel", "#io-channel-cells")
 DEFINE_SIMPLE_PROP(interrupt_parent, "interrupt-parent", NULL)
 DEFINE_SIMPLE_PROP(dmas, "dmas", "#dma-cells")
+DEFINE_SIMPLE_PROP(power_domains, "power-domains", "#power-domain-cells")
+DEFINE_SIMPLE_PROP(hwlocks, "hwlocks", "#hwlock-cells")
 DEFINE_SUFFIX_PROP(regulators, "-supply", NULL)
 DEFINE_SUFFIX_PROP(gpio, "-gpio", "#gpio-cells")
 DEFINE_SUFFIX_PROP(gpios, "-gpios", "#gpio-cells")
@@ -1226,6 +1228,8 @@ static const struct supplier_bindings of_supplier_bindings[] = {
 	{ .parse_prop = parse_io_channels, },
 	{ .parse_prop = parse_interrupt_parent, },
 	{ .parse_prop = parse_dmas, },
+	{ .parse_prop = parse_power_domains, },
+	{ .parse_prop = parse_hwlocks, },
 	{ .parse_prop = parse_regulators, },
 	{ .parse_prop = parse_gpio, },
 	{ .parse_prop = parse_gpios, },

commit 2c97b5ae83dca56718774e7b4bf9640f05d11867
Merge: 8328dd2f394e a8de1304b7df
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Dec 2 11:41:35 2019 -0800

    Merge tag 'devicetree-for-5.5' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull Devicetree updates from Rob Herring:
    
     - DT schemas for PWM, syscon, power domains, SRAM, syscon-reboot,
       syscon-poweroff, renesas-irqc, simple-pm-bus, renesas-bsc, pwm-rcar,
       Renesas tpu, at24 eeprom, rtc-sh, Allwinner PS/2, sharp,ld-d5116z01b
       panel, Arm SMMU, max77650, Meson CEC, Amlogic canvas and DWC3 glue,
       Allwinner A10 mUSB and CAN, TI Davinci MDIO, QCom QCS404
       interconnect, Unisoc/Spreadtrum SoCs and UART
    
     - Convert a bunch of Samsung bindings to DT schema
    
     - Convert a bunch of ST stm32 bindings to DT schema
    
     - Realtek and Exynos additions to Arm Mali bindings
    
     - Fix schema errors in RiscV CPU schema
    
     - Various schema fixes from improved meta-schema checks
    
     - Improve the handling of 'dma-ranges' and in particular fix DMA mask
       setup on PCI bridges
    
     - Fix a memory leak in add_changeset_property() and DT unit tests.
    
     - Several documentation improvements for schema validation
    
     - Rework build rules to improve schema validation errors
    
     - Color output for dtx_diff
    
    * tag 'devicetree-for-5.5' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (138 commits)
      libfdt: define INT32_MAX and UINT32_MAX in libfdt_env.h
      dt-bindings: arm: Remove leftover axentia.txt
      of: unittest: fix memory leak in attach_node_and_children
      of: overlay: add_changeset_property() memory leak
      dt-bindings: interrupt-controller: arm,gic-v3: Add missing type to interrupt-partition-* nodes
      dt-bindings: firmware: ixp4xx: Drop redundant minItems/maxItems
      dt-bindings: power: Rename back power_domain.txt bindings to fix references
      dt-bindings: i2c: stm32: Migrate i2c-stm32 documentation to yaml
      dt-bindings: mtd: Convert stm32 fmc2-nand bindings to json-schema
      dt-bindings: remoteproc: convert stm32-rproc to json-schema
      dt-bindings: mailbox: convert stm32-ipcc to json-schema
      dt-bindings: mfd: Convert stm32 low power timers bindings to json-schema
      dt-bindings: interrupt-controller: Convert stm32-exti to json-schema
      dt-bindings: crypto: Convert stm32 HASH bindings to json-schema
      dt-bindings: rng: Convert stm32 RNG bindings to json-schema
      dt-bindings: pwm: Convert Samsung PWM bindings to json-schema
      dt-bindings: pwm: Convert PWM bindings to json-schema
      dt-bindings: serial: Add a new compatible string for SC9863A
      dt-bindings: serial: Convert sprd-uart to json-schema
      dt-bindings: arm: Add bindings for Unisoc SC9863A
      ...

commit 9a3d7fd275be4559277667228902824165153c80
Merge: 0dd09bc02c1b 0e4a459f56c3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 27 11:06:20 2019 -0800

    Merge tag 'driver-core-5.5-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here is the "big" set of driver core patches for 5.5-rc1
    
      There's a few minor cleanups and fixes in here, but the majority of
      the patches in here fall into two buckets:
    
       - debugfs api cleanups and fixes
    
       - driver core device link support for boot dependancy issues
    
      The debugfs api cleanups are working to slowly refactor the debugfs
      apis so that it is even harder to use incorrectly. That work has been
      happening for the past few kernel releases and will continue over
      time, it's a long-term project/goal
    
      The driver core device link support missed 5.4 by just a bit, so it's
      been sitting and baking for many months now. It's from Saravana Kannan
      to help resolve the problems that DT-based systems have at boot time
      with dependancy graphs and kernel modules. Turns out that no one has
      actually tried to build a generic arm64 kernel with loads of modules
      and have it "just work" for a variety of platforms (like a distro
      kernel). The big problem turned out to be a lack of dependency
      information between different areas of DT entries, and the work here
      resolves that problem and now allows devices to boot properly, and
      quicker than a monolith kernel.
    
      All of these patches have been in linux-next for a long time with no
      reported issues"
    
    * tag 'driver-core-5.5-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (68 commits)
      tracing: Remove unnecessary DEBUG_FS dependency
      of: property: Add device link support for interrupt-parent, dmas and -gpio(s)
      debugfs: Fix !DEBUG_FS debugfs_create_automount
      of: property: Add device link support for "iommu-map"
      of: property: Fix the semantics of of_is_ancestor_of()
      i2c: of: Populate fwnode in of_i2c_get_board_info()
      drivers: base: Fix Kconfig indentation
      firmware_loader: Fix labels with comma for builtin firmware
      driver core: Allow device link operations inside sync_state()
      driver core: platform: Declare ret variable only once
      cpu-topology: declare parse_acpi_topology in <linux/arch_topology.h>
      crypto: hisilicon: no need to check return value of debugfs_create functions
      driver core: platform: use the correct callback type for bus_find_device
      firmware_class: make firmware caching configurable
      driver core: Clarify documentation for fwnode_operations.add_links()
      mailbox: tegra: Fix superfluous IRQ error message
      net: caif: Fix debugfs on 64-bit platforms
      mac80211: Use debugfs_create_xul() helper
      media: c8sectpfe: no need to check return value of debugfs_create functions
      of: property: Add device link support for iommus, mboxes and io-channels
      ...

commit 7f00be96f1252f1e97fd2300e19250b4dc521fb1
Author: Saravana Kannan <saravanak@google.com>
Date:   Tue Nov 19 23:13:01 2019 -0800

    of: property: Add device link support for interrupt-parent, dmas and -gpio(s)
    
    Add support for creating device links out of more DT properties.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Vinod Koul <vkoul@kernel.org>
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Link: https://lore.kernel.org/r/20191120071302.227777-1-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index 5e3ad3ab6e34..5ebdb9f35fc7 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -1188,7 +1188,11 @@ DEFINE_SIMPLE_PROP(interconnects, "interconnects", "#interconnect-cells")
 DEFINE_SIMPLE_PROP(iommus, "iommus", "#iommu-cells")
 DEFINE_SIMPLE_PROP(mboxes, "mboxes", "#mbox-cells")
 DEFINE_SIMPLE_PROP(io_channels, "io-channel", "#io-channel-cells")
+DEFINE_SIMPLE_PROP(interrupt_parent, "interrupt-parent", NULL)
+DEFINE_SIMPLE_PROP(dmas, "dmas", "#dma-cells")
 DEFINE_SUFFIX_PROP(regulators, "-supply", NULL)
+DEFINE_SUFFIX_PROP(gpio, "-gpio", "#gpio-cells")
+DEFINE_SUFFIX_PROP(gpios, "-gpios", "#gpio-cells")
 
 static struct device_node *parse_iommu_maps(struct device_node *np,
 					    const char *prop_name, int index)
@@ -1206,7 +1210,11 @@ static const struct supplier_bindings of_supplier_bindings[] = {
 	{ .parse_prop = parse_iommu_maps, },
 	{ .parse_prop = parse_mboxes, },
 	{ .parse_prop = parse_io_channels, },
+	{ .parse_prop = parse_interrupt_parent, },
+	{ .parse_prop = parse_dmas, },
 	{ .parse_prop = parse_regulators, },
+	{ .parse_prop = parse_gpio, },
+	{ .parse_prop = parse_gpios, },
 	{}
 };
 

commit e149573b2f84d0517648dafc0db625afa681ed54
Author: Will Deacon <will@kernel.org>
Date:   Wed Nov 20 19:00:28 2019 +0000

    of: property: Add device link support for "iommu-map"
    
    Commit 8e12257dead7 ("of: property: Add device link support for iommus,
    mboxes and io-channels") added device link support for IOMMU linkages
    described using the "iommus" property. For PCI devices, this property
    is not present and instead the "iommu-map" property is used on the host
    bridge node to map the endpoint RequesterIDs to their corresponding
    IOMMU instance.
    
    Add support for "iommu-map" to the device link supplier bindings so that
    probing of PCI devices can be deferred until after the IOMMU is
    available.
    
    Cc: Rob Herring <robh@kernel.org>
    Cc: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Will Deacon <will@kernel.org>
    Acked-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20191120190028.4722-1-will@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index 3c75dd2f7c02..5e3ad3ab6e34 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -1190,10 +1190,20 @@ DEFINE_SIMPLE_PROP(mboxes, "mboxes", "#mbox-cells")
 DEFINE_SIMPLE_PROP(io_channels, "io-channel", "#io-channel-cells")
 DEFINE_SUFFIX_PROP(regulators, "-supply", NULL)
 
+static struct device_node *parse_iommu_maps(struct device_node *np,
+					    const char *prop_name, int index)
+{
+	if (strcmp(prop_name, "iommu-map"))
+		return NULL;
+
+	return of_parse_phandle(np, prop_name, (index * 4) + 1);
+}
+
 static const struct supplier_bindings of_supplier_bindings[] = {
 	{ .parse_prop = parse_clocks, },
 	{ .parse_prop = parse_interconnects, },
 	{ .parse_prop = parse_iommus, },
+	{ .parse_prop = parse_iommu_maps, },
 	{ .parse_prop = parse_mboxes, },
 	{ .parse_prop = parse_io_channels, },
 	{ .parse_prop = parse_regulators, },

commit 3883539140b8ce67ad000938c3cd3b3e59498520
Author: Saravana Kannan <saravanak@google.com>
Date:   Wed Nov 20 00:02:29 2019 -0800

    of: property: Fix the semantics of of_is_ancestor_of()
    
    The of_is_ancestor_of() function was renamed from of_link_is_valid()
    based on review feedback. The rename meant the semantics of the function
    had to be inverted, but this was missed in the earlier patch.
    
    So, fix the semantics of of_is_ancestor_of() and invert the conditional
    expressions where it is used.
    
    Fixes: a3e1d1a7f5fc ("of: property: Add functional dependency link from DT bindings")
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20191120080230.16007-1-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index 0fa04692e3cc..3c75dd2f7c02 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -993,11 +993,11 @@ static bool of_is_ancestor_of(struct device_node *test_ancestor,
 	while (child) {
 		if (child == test_ancestor) {
 			of_node_put(child);
-			return false;
+			return true;
 		}
 		child = of_get_next_parent(child);
 	}
-	return true;
+	return false;
 }
 
 /**
@@ -1043,7 +1043,7 @@ static int of_link_to_phandle(struct device *dev, struct device_node *sup_np,
 	 * descendant nodes. By definition, a child node can't be a functional
 	 * dependency for the parent node.
 	 */
-	if (!of_is_ancestor_of(dev->of_node, sup_np)) {
+	if (of_is_ancestor_of(dev->of_node, sup_np)) {
 		dev_dbg(dev, "Not linking to %pOFP - is descendant\n", sup_np);
 		of_node_put(sup_np);
 		return -EINVAL;

commit 7f3fefeec2ce0d8f3598c53d6decca3a4fd5cdaf
Author: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
Date:   Wed Nov 13 08:43:38 2019 +0200

    of: property: Fix documentation for out values
    
    Property fetching functions which return number of successfully fetched
    properties should not state that out-values are only modified if 0 is
    returned. Fix this. Also, "pointer to return value" is slightly suboptimal
    phrase as "return value" commonly refers to value function returns (not via
    arguments). Rather use "pointer to found values".
    
    Signed-off-by: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
    Reviewed-by: Frank Rowand <frowand.list@gmail.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index d7fa75e31f22..c1dd22ed03f3 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -164,7 +164,7 @@ EXPORT_SYMBOL_GPL(of_property_read_u64_index);
  *
  * @np:		device node from which the property value is to be read.
  * @propname:	name of the property to be searched.
- * @out_values:	pointer to return value, modified only if return value is 0.
+ * @out_values:	pointer to found values.
  * @sz_min:	minimum number of array elements to read
  * @sz_max:	maximum number of array elements to read, if zero there is no
  *		upper limit on the number of elements in the dts entry but only
@@ -212,7 +212,7 @@ EXPORT_SYMBOL_GPL(of_property_read_variable_u8_array);
  *
  * @np:		device node from which the property value is to be read.
  * @propname:	name of the property to be searched.
- * @out_values:	pointer to return value, modified only if return value is 0.
+ * @out_values:	pointer to found values.
  * @sz_min:	minimum number of array elements to read
  * @sz_max:	maximum number of array elements to read, if zero there is no
  *		upper limit on the number of elements in the dts entry but only
@@ -260,7 +260,7 @@ EXPORT_SYMBOL_GPL(of_property_read_variable_u16_array);
  *
  * @np:		device node from which the property value is to be read.
  * @propname:	name of the property to be searched.
- * @out_values:	pointer to return value, modified only if return value is 0.
+ * @out_values:	pointer to return found values.
  * @sz_min:	minimum number of array elements to read
  * @sz_max:	maximum number of array elements to read, if zero there is no
  *		upper limit on the number of elements in the dts entry but only
@@ -334,7 +334,7 @@ EXPORT_SYMBOL_GPL(of_property_read_u64);
  *
  * @np:		device node from which the property value is to be read.
  * @propname:	name of the property to be searched.
- * @out_values:	pointer to return value, modified only if return value is 0.
+ * @out_values:	pointer to found values.
  * @sz_min:	minimum number of array elements to read
  * @sz_max:	maximum number of array elements to read, if zero there is no
  *		upper limit on the number of elements in the dts entry but only

commit 8e12257dead76131701c90a3555b0967727efc3f
Author: Saravana Kannan <saravanak@google.com>
Date:   Mon Nov 4 22:50:00 2019 -0800

    of: property: Add device link support for iommus, mboxes and io-channels
    
    Add support for creating device links out of more DT properties.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Link: https://lore.kernel.org/r/20191105065000.50407-4-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index 812b69a029d1..0fa04692e3cc 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -1185,11 +1185,17 @@ struct supplier_bindings {
 
 DEFINE_SIMPLE_PROP(clocks, "clocks", "#clock-cells")
 DEFINE_SIMPLE_PROP(interconnects, "interconnects", "#interconnect-cells")
+DEFINE_SIMPLE_PROP(iommus, "iommus", "#iommu-cells")
+DEFINE_SIMPLE_PROP(mboxes, "mboxes", "#mbox-cells")
+DEFINE_SIMPLE_PROP(io_channels, "io-channel", "#io-channel-cells")
 DEFINE_SUFFIX_PROP(regulators, "-supply", NULL)
 
 static const struct supplier_bindings of_supplier_bindings[] = {
 	{ .parse_prop = parse_clocks, },
 	{ .parse_prop = parse_interconnects, },
+	{ .parse_prop = parse_iommus, },
+	{ .parse_prop = parse_mboxes, },
+	{ .parse_prop = parse_io_channels, },
 	{ .parse_prop = parse_regulators, },
 	{}
 };

commit a436ef4aba1f011fa25f35fe7922d577ecde6c7c
Author: Saravana Kannan <saravanak@google.com>
Date:   Mon Nov 4 22:49:59 2019 -0800

    of: property: Make it easy to add device links from DT properties
    
    Add a DEFINE_SIMPLE_PROP macro to make it easy to add support for simple
    properties with fixed names that just list phandles and phandle args.
    
    Add a DEFINE_SUFFIX_PROP macro to make it easy to add support for
    properties with fixes suffix that just list phandles and phandle args.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Link: https://lore.kernel.org/r/20191105065000.50407-3-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index fbc201330ba0..812b69a029d1 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -1101,17 +1101,11 @@ static struct device_node *parse_prop_cells(struct device_node *np,
 	return sup_args.np;
 }
 
-static struct device_node *parse_clocks(struct device_node *np,
-					const char *prop_name, int index)
-{
-	return parse_prop_cells(np, prop_name, index, "clocks", "#clock-cells");
-}
-
-static struct device_node *parse_interconnects(struct device_node *np,
-					       const char *prop_name, int index)
-{
-	return parse_prop_cells(np, prop_name, index, "interconnects",
-				"#interconnect-cells");
+#define DEFINE_SIMPLE_PROP(fname, name, cells)				  \
+static struct device_node *parse_##fname(struct device_node *np,	  \
+					const char *prop_name, int index) \
+{									  \
+	return parse_prop_cells(np, prop_name, index, name, cells);	  \
 }
 
 static int strcmp_suffix(const char *str, const char *suffix)
@@ -1125,13 +1119,47 @@ static int strcmp_suffix(const char *str, const char *suffix)
 	return strcmp(str + len - suffix_len, suffix);
 }
 
-static struct device_node *parse_regulators(struct device_node *np,
-					    const char *prop_name, int index)
+/**
+ * parse_suffix_prop_cells - Suffix property parsing function for suppliers
+ *
+ * @np:		Pointer to device tree node containing a list
+ * @prop_name:	Name of property to be parsed. Expected to hold phandle values
+ * @index:	For properties holding a list of phandles, this is the index
+ *		into the list.
+ * @suffix:	Property suffix that is known to contain list of phandle(s) to
+ *		supplier(s)
+ * @cells_name:	property name that specifies phandles' arguments count
+ *
+ * This is a helper function to parse properties that have a known fixed suffix
+ * and are a list of phandles and phandle arguments.
+ *
+ * Returns:
+ * - phandle node pointer with refcount incremented. Caller must of_node_put()
+ *   on it when done.
+ * - NULL if no phandle found at index
+ */
+static struct device_node *parse_suffix_prop_cells(struct device_node *np,
+					    const char *prop_name, int index,
+					    const char *suffix,
+					    const char *cells_name)
 {
-	if (index || strcmp_suffix(prop_name, "-supply"))
+	struct of_phandle_args sup_args;
+
+	if (strcmp_suffix(prop_name, suffix))
 		return NULL;
 
-	return of_parse_phandle(np, prop_name, 0);
+	if (of_parse_phandle_with_args(np, prop_name, cells_name, index,
+				       &sup_args))
+		return NULL;
+
+	return sup_args.np;
+}
+
+#define DEFINE_SUFFIX_PROP(fname, suffix, cells)			     \
+static struct device_node *parse_##fname(struct device_node *np,	     \
+					const char *prop_name, int index)    \
+{									     \
+	return parse_suffix_prop_cells(np, prop_name, index, suffix, cells); \
 }
 
 /**
@@ -1155,6 +1183,10 @@ struct supplier_bindings {
 					  const char *prop_name, int index);
 };
 
+DEFINE_SIMPLE_PROP(clocks, "clocks", "#clock-cells")
+DEFINE_SIMPLE_PROP(interconnects, "interconnects", "#interconnect-cells")
+DEFINE_SUFFIX_PROP(regulators, "-supply", NULL)
+
 static const struct supplier_bindings of_supplier_bindings[] = {
 	{ .parse_prop = parse_clocks, },
 	{ .parse_prop = parse_interconnects, },

commit ba861f8e07bf38c457b98e1abf6ecd9fd8c4ee92
Author: Saravana Kannan <saravanak@google.com>
Date:   Mon Nov 4 22:49:58 2019 -0800

    of: property: Minor style clean up of of_link_to_phandle()
    
    Adding a debug log instead of silently ignoring a phandle for an early
    device. Also, return the right error code instead of 0 even though the
    actual execution flow won't change.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Link: https://lore.kernel.org/r/20191105065000.50407-2-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index e225ab17f598..fbc201330ba0 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -1051,8 +1051,14 @@ static int of_link_to_phandle(struct device *dev, struct device_node *sup_np,
 	sup_dev = get_dev_from_fwnode(&sup_np->fwnode);
 	is_populated = of_node_check_flag(sup_np, OF_POPULATED);
 	of_node_put(sup_np);
-	if (!sup_dev)
-		return is_populated ? 0 : -EAGAIN;
+	if (!sup_dev && is_populated) {
+		/* Early device without struct device. */
+		dev_dbg(dev, "Not linking to %pOFP - No struct device\n",
+			sup_np);
+		return -ENODEV;
+	} else if (!sup_dev) {
+		return -EAGAIN;
+	}
 	if (!device_link_add(dev, sup_dev, dl_flags))
 		ret = -EAGAIN;
 	put_device(sup_dev);

commit 15956dad5c1016155c82d094f8c1273a30f79c3d
Author: Saravana Kannan <saravanak@google.com>
Date:   Mon Oct 28 15:00:26 2019 -0700

    of: property: Skip adding device links to suppliers that aren't devices
    
    Some devices need to be initialized really early and can't wait for
    driver core or drivers to be functional.  These devices are typically
    initialized without creating a struct device for their device nodes.
    
    If a supplier ends up being one of these devices, skip trying to add
    device links to them.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20191028220027.251605-6-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index 69a6ec8711bd..e225ab17f598 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -1024,6 +1024,7 @@ static int of_link_to_phandle(struct device *dev, struct device_node *sup_np,
 	struct device *sup_dev;
 	int ret = 0;
 	struct device_node *tmp_np = sup_np;
+	int is_populated;
 
 	of_node_get(sup_np);
 	/*
@@ -1048,9 +1049,10 @@ static int of_link_to_phandle(struct device *dev, struct device_node *sup_np,
 		return -EINVAL;
 	}
 	sup_dev = get_dev_from_fwnode(&sup_np->fwnode);
+	is_populated = of_node_check_flag(sup_np, OF_POPULATED);
 	of_node_put(sup_np);
 	if (!sup_dev)
-		return -EAGAIN;
+		return is_populated ? 0 : -EAGAIN;
 	if (!device_link_add(dev, sup_dev, dl_flags))
 		ret = -EAGAIN;
 	put_device(sup_dev);

commit 0ff5cc1ec33b4b7540c4bc09f50123befc6ed947
Author: Saravana Kannan <saravanak@google.com>
Date:   Mon Oct 28 15:00:25 2019 -0700

    of: property: Make sure child dependencies don't block probing of parent
    
    When creating device links to proxy the sync_state() needs of child
    dependencies, create SYNC_STATE_ONLY device links so that children
    dependencies don't block probing of the parent.
    
    Also, differentiate between missing suppliers of parent device vs
    missing suppliers of child devices so that driver core doesn't block
    parent device probing when only child supplier dependencies are missing.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20191028220027.251605-5-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index 6f6e1d9644cf..69a6ec8711bd 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -1018,10 +1018,10 @@ static bool of_is_ancestor_of(struct device_node *test_ancestor,
  * - -EINVAL if the supplier link is invalid and should not be created
  * - -ENODEV if there is no device that corresponds to the supplier phandle
  */
-static int of_link_to_phandle(struct device *dev, struct device_node *sup_np)
+static int of_link_to_phandle(struct device *dev, struct device_node *sup_np,
+			      u32 dl_flags)
 {
 	struct device *sup_dev;
-	u32 dl_flags = DL_FLAG_AUTOPROBE_CONSUMER;
 	int ret = 0;
 	struct device_node *tmp_np = sup_np;
 
@@ -1181,13 +1181,20 @@ static int of_link_property(struct device *dev, struct device_node *con_np,
 	unsigned int i = 0;
 	bool matched = false;
 	int ret = 0;
+	u32 dl_flags;
+
+	if (dev->of_node == con_np)
+		dl_flags = DL_FLAG_AUTOPROBE_CONSUMER;
+	else
+		dl_flags = DL_FLAG_SYNC_STATE_ONLY;
 
 	/* Do not stop at first failed link, link all available suppliers. */
 	while (!matched && s->parse_prop) {
 		while ((phandle = s->parse_prop(con_np, prop_name, i))) {
 			matched = true;
 			i++;
-			if (of_link_to_phandle(dev, phandle) == -EAGAIN)
+			if (of_link_to_phandle(dev, phandle, dl_flags)
+								== -EAGAIN)
 				ret = -EAGAIN;
 			of_node_put(phandle);
 		}
@@ -1205,10 +1212,10 @@ static int of_link_to_suppliers(struct device *dev,
 
 	for_each_property_of_node(con_np, p)
 		if (of_link_property(dev, con_np, p->name))
-			ret = -EAGAIN;
+			ret = -ENODEV;
 
 	for_each_child_of_node(con_np, child)
-		if (of_link_to_suppliers(dev, child))
+		if (of_link_to_suppliers(dev, child) && !ret)
 			ret = -EAGAIN;
 
 	return ret;

commit af1b967af5ffb94aaed5b9b3259349cc2d398fa7
Author: Saravana Kannan <saravanak@google.com>
Date:   Fri Oct 11 12:15:19 2019 -0700

    of: property: Minor code formatting/style clean ups
    
    Better variable and function names. Remove "," after the sentinel in an
    array initialization list.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Link: https://lore.kernel.org/r/20191011191521.179614-2-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index 923d6f88a99c..6f6e1d9644cf 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -1147,11 +1147,11 @@ struct supplier_bindings {
 					  const char *prop_name, int index);
 };
 
-static const struct supplier_bindings bindings[] = {
+static const struct supplier_bindings of_supplier_bindings[] = {
 	{ .parse_prop = parse_clocks, },
 	{ .parse_prop = parse_interconnects, },
 	{ .parse_prop = parse_regulators, },
-	{},
+	{}
 };
 
 /**
@@ -1177,7 +1177,7 @@ static int of_link_property(struct device *dev, struct device_node *con_np,
 			     const char *prop_name)
 {
 	struct device_node *phandle;
-	const struct supplier_bindings *s = bindings;
+	const struct supplier_bindings *s = of_supplier_bindings;
 	unsigned int i = 0;
 	bool matched = false;
 	int ret = 0;
@@ -1196,7 +1196,7 @@ static int of_link_property(struct device *dev, struct device_node *con_np,
 	return ret;
 }
 
-static int __of_link_to_suppliers(struct device *dev,
+static int of_link_to_suppliers(struct device *dev,
 				  struct device_node *con_np)
 {
 	struct device_node *child;
@@ -1208,7 +1208,7 @@ static int __of_link_to_suppliers(struct device *dev,
 			ret = -EAGAIN;
 
 	for_each_child_of_node(con_np, child)
-		if (__of_link_to_suppliers(dev, child))
+		if (of_link_to_suppliers(dev, child))
 			ret = -EAGAIN;
 
 	return ret;
@@ -1226,7 +1226,7 @@ static int of_fwnode_add_links(const struct fwnode_handle *fwnode,
 	if (unlikely(!is_of_node(fwnode)))
 		return 0;
 
-	return __of_link_to_suppliers(dev, to_of_node(fwnode));
+	return of_link_to_suppliers(dev, to_of_node(fwnode));
 }
 
 const struct fwnode_operations of_fwnode_ops = {

commit e7e242bccb209b5f73455b33928b8680cc6e3319
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Thu Oct 3 15:32:13 2019 +0300

    device property: Add a function to obtain a node's prefix
    
    The prefix is used for printing purpose before a node, and it also works
    as a separator between two nodes.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Acked-by: Rob Herring <robh@kernel.org> (for OF)
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index 5bed634551ea..e8202f61a5d9 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -877,6 +877,15 @@ static const char *of_fwnode_get_name(const struct fwnode_handle *fwnode)
 	return kbasename(to_of_node(fwnode)->full_name);
 }
 
+static const char *of_fwnode_get_name_prefix(const struct fwnode_handle *fwnode)
+{
+	/* Root needs no prefix here (its name is "/"). */
+	if (!to_of_node(fwnode)->parent)
+		return "";
+
+	return "/";
+}
+
 static struct fwnode_handle *
 of_fwnode_get_parent(const struct fwnode_handle *fwnode)
 {
@@ -999,6 +1008,7 @@ const struct fwnode_operations of_fwnode_ops = {
 	.property_read_int_array = of_fwnode_property_read_int_array,
 	.property_read_string_array = of_fwnode_property_read_string_array,
 	.get_name = of_fwnode_get_name,
+	.get_name_prefix = of_fwnode_get_name_prefix,
 	.get_parent = of_fwnode_get_parent,
 	.get_next_child_node = of_fwnode_get_next_child_node,
 	.get_named_child_node = of_fwnode_get_named_child_node,

commit bc0500c1e43d95cca5352d2345fb0769f314ba22
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Thu Oct 3 15:32:12 2019 +0300

    device property: Add fwnode_get_name for returning the name of a node
    
    The fwnode framework did not have means to obtain the name of a node. Add
    that now, in form of the fwnode_get_name() function and a corresponding
    get_name fwnode op. OF and ACPI support is included.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Acked-by: Rob Herring <robh@kernel.org> (for OF)
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index d7fa75e31f22..5bed634551ea 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -872,6 +872,11 @@ of_fwnode_property_read_string_array(const struct fwnode_handle *fwnode,
 		of_property_count_strings(node, propname);
 }
 
+static const char *of_fwnode_get_name(const struct fwnode_handle *fwnode)
+{
+	return kbasename(to_of_node(fwnode)->full_name);
+}
+
 static struct fwnode_handle *
 of_fwnode_get_parent(const struct fwnode_handle *fwnode)
 {
@@ -993,6 +998,7 @@ const struct fwnode_operations of_fwnode_ops = {
 	.property_present = of_fwnode_property_present,
 	.property_read_int_array = of_fwnode_property_read_int_array,
 	.property_read_string_array = of_fwnode_property_read_string_array,
+	.get_name = of_fwnode_get_name,
 	.get_parent = of_fwnode_get_parent,
 	.get_next_child_node = of_fwnode_get_next_child_node,
 	.get_named_child_node = of_fwnode_get_named_child_node,

commit d4387cd117414ba80230f27a514be5ca4a09cfcc
Author: Saravana Kannan <saravanak@google.com>
Date:   Wed Sep 4 14:11:25 2019 -0700

    of: property: Create device links for all child-supplier depencencies
    
    A parent device can have child devices that it adds when it probes. But
    this probing of the parent device can happen way after kernel init is done
    -- for example, when the parent device's driver is loaded as a module.
    
    In such cases, if the child devices depend on a supplier in the system, we
    need to make sure the supplier gets the sync_state() callback only after
    these child devices are added and probed.
    
    To achieve this, when creating device links for a device by looking at its
    DT node, don't just look at DT references at the top node level. Look at DT
    references in all the descendant nodes too and create device links from the
    ancestor device to all these supplier devices.
    
    This way, when the parent device probes and adds child devices, the child
    devices can then create their own device links to the suppliers and further
    delay the supplier's sync_state() callback to after the child devices are
    probed.
    
    Example:
    In this illustration, -> denotes DT references and indentation
    represents child status.
    
    Device node A
            Device node B -> D
            Device node C -> B, D
    
    Device node D
    
    Assume all these devices have their drivers loaded as modules.
    
    Without this patch, this is the sequence of events:
    1. D is added.
    2. A is added.
    3. Device D probes.
    4. Device D gets its sync_state() callback.
    5. Device B and C might malfunction because their resources got
       altered/turned off before they can make active requests for them.
    
    With this patch, this is the sequence of events:
    1. D is added.
    2. A is added and creates device links to D.
    3. Device link from A to B is not added because A is a parent of B.
    4. Device D probes.
    5. Device D does not get it's sync_state() callback because consumer A
       hasn't probed yet.
    5. Device A probes.
    5. a. Devices B and C are added.
    5. b. Device links from B and C to D are added.
    5. c. Device A's probe completes.
    6. Device D does not get it's sync_state() callback because consumer A
       has probed but consumers B and C haven't probed yet.
    7. Device B and C probe.
    8. Device D gets it's sync_state() callback because all its consumers
       have probed.
    9. None of the devices malfunction.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20190904211126.47518-7-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index 23b5ee5b0570..923d6f88a99c 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -1207,6 +1207,10 @@ static int __of_link_to_suppliers(struct device *dev,
 		if (of_link_property(dev, con_np, p->name))
 			ret = -EAGAIN;
 
+	for_each_child_of_node(con_np, child)
+		if (__of_link_to_suppliers(dev, child))
+			ret = -EAGAIN;
+
 	return ret;
 }
 

commit a3e1d1a7f5fcccaf1d252278425fea9a4a553100
Author: Saravana Kannan <saravanak@google.com>
Date:   Wed Sep 4 14:11:22 2019 -0700

    of: property: Add functional dependency link from DT bindings
    
    Add device links after the devices are created (but before they are
    probed) by looking at common DT bindings like clocks and
    interconnects.
    
    Automatically adding device links for functional dependencies at the
    framework level provides the following benefits:
    
    - Optimizes device probe order and avoids the useless work of
      attempting probes of devices that will not probe successfully
      (because their suppliers aren't present or haven't probed yet).
    
      For example, in a commonly available mobile SoC, registering just
      one consumer device's driver at an initcall level earlier than the
      supplier device's driver causes 11 failed probe attempts before the
      consumer device probes successfully. This was with a kernel with all
      the drivers statically compiled in. This problem gets a lot worse if
      all the drivers are loaded as modules without direct symbol
      dependencies.
    
    - Supplier devices like clock providers, interconnect providers, etc
      need to keep the resources they provide active and at a particular
      state(s) during boot up even if their current set of consumers don't
      request the resource to be active. This is because the rest of the
      consumers might not have probed yet and turning off the resource
      before all the consumers have probed could lead to a hang or
      undesired user experience.
    
      Some frameworks (Eg: regulator) handle this today by turning off
      "unused" resources at late_initcall_sync and hoping all the devices
      have probed by then. This is not a valid assumption for systems with
      loadable modules. Other frameworks (Eg: clock) just don't handle
      this due to the lack of a clear signal for when they can turn off
      resources. This leads to downstream hacks to handle cases like this
      that can easily be solved in the upstream kernel.
    
      By linking devices before they are probed, we give suppliers a clear
      count of the number of dependent consumers. Once all of the
      consumers are active, the suppliers can turn off the unused
      resources without making assumptions about the number of consumers.
    
    By default we just add device-links to track "driver presence" (probe
    succeeded) of the supplier device. If any other functionality provided
    by device-links are needed, it is left to the consumer/supplier
    devices to change the link when they probe.
    
    kbuild test robot reported clang error about missing const
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20190904211126.47518-4-saravanak@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index d7fa75e31f22..23b5ee5b0570 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -25,6 +25,7 @@
 #include <linux/of_device.h>
 #include <linux/of_graph.h>
 #include <linux/string.h>
+#include <linux/moduleparam.h>
 
 #include "of_private.h"
 
@@ -985,6 +986,245 @@ of_fwnode_device_get_match_data(const struct fwnode_handle *fwnode,
 	return of_device_get_match_data(dev);
 }
 
+static bool of_is_ancestor_of(struct device_node *test_ancestor,
+			      struct device_node *child)
+{
+	of_node_get(child);
+	while (child) {
+		if (child == test_ancestor) {
+			of_node_put(child);
+			return false;
+		}
+		child = of_get_next_parent(child);
+	}
+	return true;
+}
+
+/**
+ * of_link_to_phandle - Add device link to supplier from supplier phandle
+ * @dev: consumer device
+ * @sup_np: phandle to supplier device tree node
+ *
+ * Given a phandle to a supplier device tree node (@sup_np), this function
+ * finds the device that owns the supplier device tree node and creates a
+ * device link from @dev consumer device to the supplier device. This function
+ * doesn't create device links for invalid scenarios such as trying to create a
+ * link with a parent device as the consumer of its child device. In such
+ * cases, it returns an error.
+ *
+ * Returns:
+ * - 0 if link successfully created to supplier
+ * - -EAGAIN if linking to the supplier should be reattempted
+ * - -EINVAL if the supplier link is invalid and should not be created
+ * - -ENODEV if there is no device that corresponds to the supplier phandle
+ */
+static int of_link_to_phandle(struct device *dev, struct device_node *sup_np)
+{
+	struct device *sup_dev;
+	u32 dl_flags = DL_FLAG_AUTOPROBE_CONSUMER;
+	int ret = 0;
+	struct device_node *tmp_np = sup_np;
+
+	of_node_get(sup_np);
+	/*
+	 * Find the device node that contains the supplier phandle.  It may be
+	 * @sup_np or it may be an ancestor of @sup_np.
+	 */
+	while (sup_np && !of_find_property(sup_np, "compatible", NULL))
+		sup_np = of_get_next_parent(sup_np);
+	if (!sup_np) {
+		dev_dbg(dev, "Not linking to %pOFP - No device\n", tmp_np);
+		return -ENODEV;
+	}
+
+	/*
+	 * Don't allow linking a device node as a consumer of one of its
+	 * descendant nodes. By definition, a child node can't be a functional
+	 * dependency for the parent node.
+	 */
+	if (!of_is_ancestor_of(dev->of_node, sup_np)) {
+		dev_dbg(dev, "Not linking to %pOFP - is descendant\n", sup_np);
+		of_node_put(sup_np);
+		return -EINVAL;
+	}
+	sup_dev = get_dev_from_fwnode(&sup_np->fwnode);
+	of_node_put(sup_np);
+	if (!sup_dev)
+		return -EAGAIN;
+	if (!device_link_add(dev, sup_dev, dl_flags))
+		ret = -EAGAIN;
+	put_device(sup_dev);
+	return ret;
+}
+
+/**
+ * parse_prop_cells - Property parsing function for suppliers
+ *
+ * @np:		Pointer to device tree node containing a list
+ * @prop_name:	Name of property to be parsed. Expected to hold phandle values
+ * @index:	For properties holding a list of phandles, this is the index
+ *		into the list.
+ * @list_name:	Property name that is known to contain list of phandle(s) to
+ *		supplier(s)
+ * @cells_name:	property name that specifies phandles' arguments count
+ *
+ * This is a helper function to parse properties that have a known fixed name
+ * and are a list of phandles and phandle arguments.
+ *
+ * Returns:
+ * - phandle node pointer with refcount incremented. Caller must of_node_put()
+ *   on it when done.
+ * - NULL if no phandle found at index
+ */
+static struct device_node *parse_prop_cells(struct device_node *np,
+					    const char *prop_name, int index,
+					    const char *list_name,
+					    const char *cells_name)
+{
+	struct of_phandle_args sup_args;
+
+	if (strcmp(prop_name, list_name))
+		return NULL;
+
+	if (of_parse_phandle_with_args(np, list_name, cells_name, index,
+				       &sup_args))
+		return NULL;
+
+	return sup_args.np;
+}
+
+static struct device_node *parse_clocks(struct device_node *np,
+					const char *prop_name, int index)
+{
+	return parse_prop_cells(np, prop_name, index, "clocks", "#clock-cells");
+}
+
+static struct device_node *parse_interconnects(struct device_node *np,
+					       const char *prop_name, int index)
+{
+	return parse_prop_cells(np, prop_name, index, "interconnects",
+				"#interconnect-cells");
+}
+
+static int strcmp_suffix(const char *str, const char *suffix)
+{
+	unsigned int len, suffix_len;
+
+	len = strlen(str);
+	suffix_len = strlen(suffix);
+	if (len <= suffix_len)
+		return -1;
+	return strcmp(str + len - suffix_len, suffix);
+}
+
+static struct device_node *parse_regulators(struct device_node *np,
+					    const char *prop_name, int index)
+{
+	if (index || strcmp_suffix(prop_name, "-supply"))
+		return NULL;
+
+	return of_parse_phandle(np, prop_name, 0);
+}
+
+/**
+ * struct supplier_bindings - Property parsing functions for suppliers
+ *
+ * @parse_prop: function name
+ *	parse_prop() finds the node corresponding to a supplier phandle
+ * @parse_prop.np: Pointer to device node holding supplier phandle property
+ * @parse_prop.prop_name: Name of property holding a phandle value
+ * @parse_prop.index: For properties holding a list of phandles, this is the
+ *		      index into the list
+ *
+ * Returns:
+ * parse_prop() return values are
+ * - phandle node pointer with refcount incremented. Caller must of_node_put()
+ *   on it when done.
+ * - NULL if no phandle found at index
+ */
+struct supplier_bindings {
+	struct device_node *(*parse_prop)(struct device_node *np,
+					  const char *prop_name, int index);
+};
+
+static const struct supplier_bindings bindings[] = {
+	{ .parse_prop = parse_clocks, },
+	{ .parse_prop = parse_interconnects, },
+	{ .parse_prop = parse_regulators, },
+	{},
+};
+
+/**
+ * of_link_property - Create device links to suppliers listed in a property
+ * @dev: Consumer device
+ * @con_np: The consumer device tree node which contains the property
+ * @prop_name: Name of property to be parsed
+ *
+ * This function checks if the property @prop_name that is present in the
+ * @con_np device tree node is one of the known common device tree bindings
+ * that list phandles to suppliers. If @prop_name isn't one, this function
+ * doesn't do anything.
+ *
+ * If @prop_name is one, this function attempts to create device links from the
+ * consumer device @dev to all the devices of the suppliers listed in
+ * @prop_name.
+ *
+ * Any failed attempt to create a device link will NOT result in an immediate
+ * return.  of_link_property() must create links to all the available supplier
+ * devices even when attempts to create a link to one or more suppliers fail.
+ */
+static int of_link_property(struct device *dev, struct device_node *con_np,
+			     const char *prop_name)
+{
+	struct device_node *phandle;
+	const struct supplier_bindings *s = bindings;
+	unsigned int i = 0;
+	bool matched = false;
+	int ret = 0;
+
+	/* Do not stop at first failed link, link all available suppliers. */
+	while (!matched && s->parse_prop) {
+		while ((phandle = s->parse_prop(con_np, prop_name, i))) {
+			matched = true;
+			i++;
+			if (of_link_to_phandle(dev, phandle) == -EAGAIN)
+				ret = -EAGAIN;
+			of_node_put(phandle);
+		}
+		s++;
+	}
+	return ret;
+}
+
+static int __of_link_to_suppliers(struct device *dev,
+				  struct device_node *con_np)
+{
+	struct device_node *child;
+	struct property *p;
+	int ret = 0;
+
+	for_each_property_of_node(con_np, p)
+		if (of_link_property(dev, con_np, p->name))
+			ret = -EAGAIN;
+
+	return ret;
+}
+
+static bool of_devlink;
+core_param(of_devlink, of_devlink, bool, 0);
+
+static int of_fwnode_add_links(const struct fwnode_handle *fwnode,
+			       struct device *dev)
+{
+	if (!of_devlink)
+		return 0;
+
+	if (unlikely(!is_of_node(fwnode)))
+		return 0;
+
+	return __of_link_to_suppliers(dev, to_of_node(fwnode));
+}
+
 const struct fwnode_operations of_fwnode_ops = {
 	.get = of_fwnode_get,
 	.put = of_fwnode_put,
@@ -1001,5 +1241,6 @@ const struct fwnode_operations of_fwnode_ops = {
 	.graph_get_remote_endpoint = of_fwnode_graph_get_remote_endpoint,
 	.graph_get_port_parent = of_fwnode_graph_get_port_parent,
 	.graph_parse_endpoint = of_fwnode_graph_parse_endpoint,
+	.add_links = of_fwnode_add_links,
 };
 EXPORT_SYMBOL_GPL(of_fwnode_ops);

commit deb387d4af5a4be3b656b5d69ae4d87ccee325b8
Author: Maxime Ripard <maxime.ripard@bootlin.com>
Date:   Fri Mar 15 10:22:47 2019 +0100

    of: property: Document that of_graph_get_endpoint_by_regs needs of_node_put
    
    The node returned by of_graph_get_endpoint_by_regs has a reference taken,
    and we need to put that reference back when done with the node.
    
    However, the documentation for that node doesn't mention it, so let's make
    sure it does.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index 8631efa1daa1..d7fa75e31f22 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -659,7 +659,7 @@ EXPORT_SYMBOL(of_graph_get_next_endpoint);
  *
  * Return: An 'endpoint' node pointer which is identified by reg and at the same
  * is the child of a port node identified by port_reg. reg and port_reg are
- * ignored when they are -1.
+ * ignored when they are -1. Use of_node_put() on the pointer when done.
  */
 struct device_node *of_graph_get_endpoint_by_regs(
 	const struct device_node *parent, int port_reg, int reg)

commit 28b170e88bc0c7509e6724717c15cb4b5686026e
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sun Jan 13 10:44:50 2019 +0100

    OF: properties: add missing of_node_put
    
    Add an of_node_put when the result of of_graph_get_remote_port_parent is
    not available.
    
    The semantic match that finds this problem is as follows
    (http://coccinelle.lip6.fr):
    
    // <smpl>
    @r exists@
    local idexpression e;
    expression x;
    @@
    e = of_graph_get_remote_port_parent(...);
    ... when != x = e
        when != true e == NULL
        when != of_node_put(e)
        when != of_fwnode_handle(e)
    (
    return e;
    |
    *return ...;
    )
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: stable@vger.kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index 08430031bd28..8631efa1daa1 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -806,6 +806,7 @@ struct device_node *of_graph_get_remote_node(const struct device_node *node,
 
 	if (!of_device_is_available(remote)) {
 		pr_debug("not available for remote node\n");
+		of_node_put(remote);
 		return NULL;
 	}
 

commit b3e46d1a0590500335f0b95e669ad6d84b12b03a
Author: Rob Herring <robh@kernel.org>
Date:   Mon Aug 27 08:37:06 2018 -0500

    of: Use of_node_name_eq for node name comparisons
    
    Convert string compares of DT node names to use of_node_name_eq helper
    instead. This removes direct access to the node name pointer.
    
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    Cc: devicetree@vger.kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index f46828e3b082..08430031bd28 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -571,7 +571,7 @@ struct device_node *of_graph_get_port_by_id(struct device_node *parent, u32 id)
 	for_each_child_of_node(parent, port) {
 		u32 port_id = 0;
 
-		if (of_node_cmp(port->name, "port") != 0)
+		if (!of_node_name_eq(port, "port"))
 			continue;
 		of_property_read_u32(port, "reg", &port_id);
 		if (id == port_id)
@@ -646,7 +646,7 @@ struct device_node *of_graph_get_next_endpoint(const struct device_node *parent,
 			port = of_get_next_child(parent, port);
 			if (!port)
 				return NULL;
-		} while (of_node_cmp(port->name, "port"));
+		} while (!of_node_name_eq(port, "port"));
 	}
 }
 EXPORT_SYMBOL(of_graph_get_next_endpoint);
@@ -715,7 +715,7 @@ struct device_node *of_graph_get_port_parent(struct device_node *node)
 	/* Walk 3 levels up only if there is 'ports' node. */
 	for (depth = 3; depth && node; depth--) {
 		node = of_get_next_parent(node);
-		if (depth == 2 && of_node_cmp(node->name, "ports"))
+		if (depth == 2 && !of_node_name_eq(node, "ports"))
 			break;
 	}
 	return node;
@@ -893,7 +893,7 @@ of_fwnode_get_named_child_node(const struct fwnode_handle *fwnode,
 	struct device_node *child;
 
 	for_each_available_child_of_node(node, child)
-		if (!of_node_cmp(child->name, childname))
+		if (of_node_name_eq(child, childname))
 			return of_fwnode_handle(child);
 
 	return NULL;
@@ -955,7 +955,7 @@ of_fwnode_graph_get_port_parent(struct fwnode_handle *fwnode)
 		return NULL;
 
 	/* Is this the "ports" node? If not, it's the port parent. */
-	if (of_node_cmp(np->name, "ports"))
+	if (!of_node_name_eq(np, "ports"))
 		return of_fwnode_handle(np);
 
 	return of_fwnode_handle(of_get_next_parent(np));

commit 67dcc26d208ca5578f08c3c78cb254418c24e9ec
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Feb 9 17:38:36 2018 +0200

    device property: Constify device_get_match_data()
    
    Constify device_get_match_data() as OF and ACPI variants return
    constant value.
    
    Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index 36ed84e26d9c..f46828e3b082 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -977,11 +977,11 @@ static int of_fwnode_graph_parse_endpoint(const struct fwnode_handle *fwnode,
 	return 0;
 }
 
-static void *
+static const void *
 of_fwnode_device_get_match_data(const struct fwnode_handle *fwnode,
 				const struct device *dev)
 {
-	return (void *)of_device_get_match_data(dev);
+	return of_device_get_match_data(dev);
 }
 
 const struct fwnode_operations of_fwnode_ops = {

commit 2bed26606b61a7b20fc1cc54df53c48c06cd9aa8
Merge: eea43ed86f38 3a6fbcb2e2e4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 1 10:57:45 2018 -0800

    Merge tag 'devicetree-for-4.16' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull DeviceTree updates from Rob Herring:
    
     - Convert to use memblock_virt_alloc in DT code which supports
       bootmem arches. With this we can remove the arch specific
       early_init_dt_alloc_memory_arch() functions.
    
     - Enable running the DT unittests on UML
    
     - Use SPDX license tags on DT files
    
     - Fix early FDT kconfig ifdef logic
    
     - Clean-up unittest Makefile
    
     - Fix function comment for of_irq_parse_raw
    
     - Add missing documentation for linux,initrd-{start,end} properties
    
     - Clean-up of binding examples using uppercase hex
    
     - Add trivial devices W83773G and Infineon TLV493D-A1B6
    
     - Add missing STM32 SoC bindings
    
     - Various small binding doc fixes
    
    * tag 'devicetree-for-4.16' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (23 commits)
      xtensa: remove arch specific early DT functions
      x86: remove arch specific early_init_dt_alloc_memory_arch
      nios2: remove arch specific early_init_dt_alloc_memory_arch
      mips: remove arch specific early_init_dt_alloc_memory_arch
      metag: remove arch specific early DT functions
      cris: remove arch specific early DT functions
      libfdt: remove unnecessary include directive from <linux/libfdt.h>
      of: unittest: refactor Makefile
      of/fdt: use memblock_virt_alloc for early alloc
      of: Use SPDX license tag for DT files
      of/fdt: Fix #ifdef dependency of early flattree declarations
      dt-bindings: h8300 clocksource: correct spelling of pulse
      dt-bindings: imx6q-pcie: Add required property for i.MX6SX
      mmc: Don't reference Linux-specific OF_GPIO_ACTIVE_LOW flag in DT binding
      dt-bindings: Use lower case hex in unit-addresses
      dt-bindings: display: panel: Fix compatible string for Toshiba LT089AC29000
      dt-bindings: Add Infineon TLV493D-A1B6
      dt-bindings: mailbox: ti,message-manager: Fix interrupt name error
      dt-bindings: chosen: Document linux,initrd-{start,end}
      dt-bindings: arm: document supported STM32 SoC family
      ...

commit af6074fc9aa4b29517375634189ada1869eea598
Author: Rob Herring <robh@kernel.org>
Date:   Wed Dec 27 12:55:14 2017 -0600

    of: Use SPDX license tag for DT files
    
    Convert remaining DT files to use SPDX-License-Identifier tags.
    
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    Reviewed-by: Frank Rowand <frank.rowand@sony.com>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index 8ad33a44a7b8..2b22560b60c1 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * drivers/of/property.c - Procedures for accessing and interpreting
  *			   Devicetree properties and graphs.
@@ -16,11 +17,6 @@
  *
  *  Reconsolidated from arch/x/kernel/prom.c by Stephen Rothwell and
  *  Grant Likely.
- *
- *      This program is free software; you can redistribute it and/or
- *      modify it under the terms of the GNU General Public License
- *      as published by the Free Software Foundation; either version
- *      2 of the License, or (at your option) any later version.
  */
 
 #define pr_fmt(fmt)	"OF: " fmt

commit 1c2c82ea2826602717c32b72f7c6debbbf6aff48
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Wed Dec 13 02:20:50 2017 -0500

    OF: properties: Implement get_match_data() callback
    
    Now that we have a get_match_data() callback as part of the firmware node,
    implement the OF specific piece for it.
    
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index 8ad33a44a7b8..f25d36358187 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -981,10 +981,18 @@ static int of_fwnode_graph_parse_endpoint(const struct fwnode_handle *fwnode,
 	return 0;
 }
 
+static void *
+of_fwnode_device_get_match_data(const struct fwnode_handle *fwnode,
+				const struct device *dev)
+{
+	return (void *)of_device_get_match_data(dev);
+}
+
 const struct fwnode_operations of_fwnode_ops = {
 	.get = of_fwnode_get,
 	.put = of_fwnode_put,
 	.device_is_available = of_fwnode_device_is_available,
+	.device_get_match_data = of_fwnode_device_get_match_data,
 	.property_present = of_fwnode_property_present,
 	.property_read_int_array = of_fwnode_property_read_int_array,
 	.property_read_string_array = of_fwnode_property_read_string_array,

commit cf89a31ca55272e1dfb9527b5a61eee4d417747a
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Tue Sep 19 12:39:11 2017 +0300

    device property: Make fwnode_handle_get() return the fwnode
    
    The fwnode_handle_get() function is used to obtain a reference to an
    fwnode. A common usage pattern for the OF equivalent of the function is:
    
            mynode = of_node_get(node);
    
    Similarly make fwnode_handle_get() return the fwnode to which the
    reference was obtained.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index 264c355ba1ff..8ad33a44a7b8 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -817,9 +817,9 @@ struct device_node *of_graph_get_remote_node(const struct device_node *node,
 }
 EXPORT_SYMBOL(of_graph_get_remote_node);
 
-static void of_fwnode_get(struct fwnode_handle *fwnode)
+static struct fwnode_handle *of_fwnode_get(struct fwnode_handle *fwnode)
 {
-	of_node_get(to_of_node(fwnode));
+	return of_fwnode_handle(of_node_get(to_of_node(fwnode)));
 }
 
 static void of_fwnode_put(struct fwnode_handle *fwnode)

commit 3314c6bdd26880e0dfbcb0cb85a1b36d185ce47c
Author: Niklas Sderlund <niklas.soderlund+renesas@ragnatech.se>
Date:   Tue Aug 22 02:19:12 2017 +0200

    device property: preserve usecount for node passed to of_fwnode_graph_get_port_parent()
    
    Using CONFIG_OF_DYNAMIC=y uncovered an imbalance in the usecount of the
    node being passed to of_fwnode_graph_get_port_parent(). Preserve the
    usecount by using of_get_parent() instead of of_get_next_parent() which
    don't decrement the usecount of the node passed to it.
    
    Fixes: 3b27d00e7b6d7c88 ("device property: Move fwnode graph ops to firmware specific locations")
    Signed-off-by: Niklas Sderlund <niklas.soderlund+renesas@ragnatech.se>
    Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index fbb72116e9d4..264c355ba1ff 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -954,7 +954,7 @@ of_fwnode_graph_get_port_parent(struct fwnode_handle *fwnode)
 	struct device_node *np;
 
 	/* Get the parent of the port */
-	np = of_get_next_parent(to_of_node(fwnode));
+	np = of_get_parent(to_of_node(fwnode));
 	if (!np)
 		return NULL;
 

commit 74fee4e88fd196c712abfdae89acfa272abf10f8
Merge: 7d955656121f 84024468cf16
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 7 14:43:33 2017 -0700

    Merge tag 'devicetree-for-4.14' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull DeviceTree updates from Rob Herring:
     "There's a few orphans in the conversion to %pOF printf specifiers
      included here that no one else picked up.
    
      Summary:
    
       - Convert more DT code to use of_property_read_* API.
    
       - Improve DT overlay support when adding multiple overlays
    
       - Convert printk's to %pOF format specifiers. Most went via subsystem
         trees, but picked up the remaining orphans
    
       - Correct unittests to use preferred "okay" for "status" property
         value
    
       - Add a KASLR seed property
    
       - Vendor prefixes for Mellanox, Theobroma System, Adaptrum, Moxa
    
       - Fix modalias buffer handling
    
       - Clean-up of include paths for building dtbs
    
       - Add bindings for amc6821, isl1208, tsl2x7x, srf02, and srf10
         devices
    
       - Add nvmem bindings for MediaTek MT7623 and MT7622 SoC
    
       - Add compatible string for Allwinner H5 Mali-450 GPU
    
       - Fix links to old OpenFirmware docs with new mirror on
         devicetree.org
    
       - Remove status property from binding doc examples"
    
    * tag 'devicetree-for-4.14' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (45 commits)
      devicetree: Adjust status "ok" -> "okay" under drivers/of/
      dt-bindings: Remove "status" from examples
      dt-bindings: pinctrl: sh-pfc: Use generic node name
      dt-bindings: Add vendor Mellanox
      dt-binding: net/phy: fix interrupts description
      virt: Convert to using %pOF instead of full_name
      macintosh: Convert to using %pOF instead of full_name
      ide: pmac: Convert to using %pOF instead of full_name
      microblaze: Convert to using %pOF instead of full_name
      dt-bindings: usb: musb: Grammar s/the/to/, s/is/are/
      of: Use PLATFORM_DEVID_NONE definition
      of/device: Fix of_device_get_modalias() buffer handling
      of/device: Prevent buffer overflow in of_device_modalias()
      dt-bindings: add amc6821, isl1208 trivial bindings
      dt-bindings: add vendor prefix for Theobroma Systems
      of: search scripts/dtc/include-prefixes path for both CPP and DTC
      of: remove arch/$(SRCARCH)/boot/dts from include search path for CPP
      of: remove drivers/of/testcase-data from include search path for CPP
      of: return of_get_cpu_node from of_cpu_device_node_get if CPUs are not registered
      iio: srf08: add device tree binding for srf02 and srf10
      ...

commit e7d0c41ecc2e372a81741a30894f556afec24315
Merge: 53ac64aac9af 3689d3d69072
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 5 12:50:00 2017 -0700

    Merge tag 'devprop-4.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull device properties framework updates from Rafael Wysocki:
     "These introduce fwnode operations for all of the separate types of
      'firmware nodes' that can be handled by the device properties
      framework, make the framework use const fwnode arguments all over, add
      a helper for the consolidated handling of node references and switch
      over the framework to the new UUID API.
    
      Specifics:
    
       - Introduce fwnode operations for all of the separate types of
         'firmware nodes' that can be handled by the device properties
         framework and drop the type field from struct fwnode_handle (Sakari
         Ailus, Arnd Bergmann).
    
       - Make the device properties framework use const fwnode arguments
         where possible (Sakari Ailus).
    
       - Add a helper for the consolidated handling of node references to
         the device properties framework (Sakari Ailus).
    
       - Switch over the ACPI part of the device properties framework to the
         new UUID API (Andy Shevchenko)"
    
    * tag 'devprop-4.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      ACPI: device property: Switch to use new generic UUID API
      device property: export irqchip_fwnode_ops
      device property: Introduce fwnode_property_get_reference_args
      device property: Constify fwnode property API
      device property: Constify argument to pset fwnode backend
      ACPI: Constify internal fwnode arguments
      ACPI: Constify acpi_bus helper functions, switch to macros
      ACPI: Prepare for constifying acpi_get_next_subnode() fwnode argument
      device property: Get rid of struct fwnode_handle type field
      ACPI: Use IS_ERR_OR_NULL() instead of non-NULL check in is_acpi_data_node()

commit 358155ede4fbd047d055a0ffee95d042b02872ae
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Aug 10 04:38:16 2017 +0000

    device property: use of_graph_get_remote_endpoint() for of_fwnode
    
    Now, we can use of_graph_get_remote_endpoint(). Let's use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index ab4cf1da77b5..9eb45f69db2f 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -899,8 +899,8 @@ of_fwnode_graph_get_next_endpoint(struct fwnode_handle *fwnode,
 static struct fwnode_handle *
 of_fwnode_graph_get_remote_endpoint(struct fwnode_handle *fwnode)
 {
-	return of_fwnode_handle(of_parse_phandle(to_of_node(fwnode),
-						 "remote-endpoint", 0));
+	return of_fwnode_handle(
+		of_graph_get_remote_endpoint(to_of_node(fwnode)));
 }
 
 static struct fwnode_handle *

commit c0a480d1acf7dc184f9f3e7cf724483b0d28dc2e
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Jul 28 01:23:15 2017 -0700

    device property: Fix usecount for of_graph_get_port_parent()
    
    Fix inconsistent use of of_graph_get_port_parent() where
    asoc_simple_card_parse_graph_dai() does of_node_get() before
    calling it while other callers do not. We can fix this by
    not trashing the node passed to of_graph_get_port_parent().
    
    Let's also make sure the callers have correct refcounts and remove
    related incorrect of_node_put() calls for of_for_each_phandle
    as that's done by of_phandle_iterator_next() except when
    we break out of the loop early.
    
    Let's fix both issues with a single patch to avoid kobject
    refcounts getting messed up more if two patches are merged
    separately.
    
    Otherwise strange issues can happen caused by memory corruption
    caused by too many kobject_del() calls such as:
    
    BUG: sleeping function called from invalid context at
    kernel/locking/mutex.c:747
    ...
    (___might_sleep)
    (__mutex_lock)
    (mutex_lock_nested)
    (kernfs_remove)
    (kobject_del)
    (kobject_put)
    (of_get_next_parent)
    (of_graph_get_port_parent)
    (asoc_simple_card_parse_graph_dai [snd_soc_simple_card_utils])
    (asoc_graph_card_probe [snd_soc_audio_graph_card])
    
    Fixes: 0ef472a973eb ("of_graph: add of_graph_get_port_parent()")
    Fixes: 2692c1c63c29 ("ASoC: add audio-graph-card support")
    Fixes: 1689333f8311 ("ASoC: simple-card-utils: add asoc_simple_card_parse_graph_dai()")
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Tested-by: Antonio Borneo <borneo.antonio@gmail.com>
    Tested-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index eda50b4be934..067f9fab7b77 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -708,6 +708,15 @@ struct device_node *of_graph_get_port_parent(struct device_node *node)
 {
 	unsigned int depth;
 
+	if (!node)
+		return NULL;
+
+	/*
+	 * Preserve usecount for passed in node as of_get_next_parent()
+	 * will do of_node_put() on it.
+	 */
+	of_node_get(node);
+
 	/* Walk 3 levels up only if there is 'ports' node. */
 	for (depth = 3; depth && node; depth--) {
 		node = of_get_next_parent(node);
@@ -728,12 +737,16 @@ EXPORT_SYMBOL(of_graph_get_port_parent);
 struct device_node *of_graph_get_remote_port_parent(
 			       const struct device_node *node)
 {
-	struct device_node *np;
+	struct device_node *np, *pp;
 
 	/* Get remote endpoint node. */
 	np = of_graph_get_remote_endpoint(node);
 
-	return of_graph_get_port_parent(np);
+	pp = of_graph_get_port_parent(np);
+
+	of_node_put(np);
+
+	return pp;
 }
 EXPORT_SYMBOL(of_graph_get_remote_port_parent);
 

commit 3e3119d3088f41106f3581d39e7694a50ca3fc02
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Fri Jul 21 15:11:49 2017 +0300

    device property: Introduce fwnode_property_get_reference_args
    
    The new fwnode_property_get_reference_args() interface amends the fwnode
    property API with the functionality of both of_parse_phandle_with_args()
    and __acpi_node_get_property_reference().
    
    The semantics is slightly different: the cells property is ignored on ACPI
    as the number of arguments can be explicitly obtained from the firmware
    interface.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index ae46a6f0ea36..3868400972b8 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -891,6 +891,36 @@ of_fwnode_get_named_child_node(const struct fwnode_handle *fwnode,
 	return NULL;
 }
 
+static int
+of_fwnode_get_reference_args(const struct fwnode_handle *fwnode,
+			     const char *prop, const char *nargs_prop,
+			     unsigned int nargs, unsigned int index,
+			     struct fwnode_reference_args *args)
+{
+	struct of_phandle_args of_args;
+	unsigned int i;
+	int ret;
+
+	if (nargs_prop)
+		ret = of_parse_phandle_with_args(to_of_node(fwnode), prop,
+						 nargs_prop, index, &of_args);
+	else
+		ret = of_parse_phandle_with_fixed_args(to_of_node(fwnode), prop,
+						       nargs, index, &of_args);
+	if (ret < 0)
+		return ret;
+	if (!args)
+		return 0;
+
+	args->nargs = of_args.args_count;
+	args->fwnode = of_fwnode_handle(of_args.np);
+
+	for (i = 0; i < NR_FWNODE_REFERENCE_ARGS; i++)
+		args->args[i] = i < of_args.args_count ? of_args.args[i] : 0;
+
+	return 0;
+}
+
 static struct fwnode_handle *
 of_fwnode_graph_get_next_endpoint(const struct fwnode_handle *fwnode,
 				  struct fwnode_handle *prev)
@@ -949,6 +979,7 @@ const struct fwnode_operations of_fwnode_ops = {
 	.get_parent = of_fwnode_get_parent,
 	.get_next_child_node = of_fwnode_get_next_child_node,
 	.get_named_child_node = of_fwnode_get_named_child_node,
+	.get_reference_args = of_fwnode_get_reference_args,
 	.graph_get_next_endpoint = of_fwnode_graph_get_next_endpoint,
 	.graph_get_remote_endpoint = of_fwnode_graph_get_remote_endpoint,
 	.graph_get_port_parent = of_fwnode_graph_get_port_parent,

commit 37ba983cfb47cc7b353146422c437468fcb29c61
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Fri Jul 21 14:39:36 2017 +0300

    device property: Constify fwnode property API
    
    Make fwnode arguments to the fwnode property API const.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index 2d5988820405..ae46a6f0ea36 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -815,23 +815,23 @@ static void of_fwnode_put(struct fwnode_handle *fwnode)
 	of_node_put(to_of_node(fwnode));
 }
 
-static bool of_fwnode_device_is_available(struct fwnode_handle *fwnode)
+static bool of_fwnode_device_is_available(const struct fwnode_handle *fwnode)
 {
 	return of_device_is_available(to_of_node(fwnode));
 }
 
-static bool of_fwnode_property_present(struct fwnode_handle *fwnode,
+static bool of_fwnode_property_present(const struct fwnode_handle *fwnode,
 				       const char *propname)
 {
 	return of_property_read_bool(to_of_node(fwnode), propname);
 }
 
-static int of_fwnode_property_read_int_array(struct fwnode_handle *fwnode,
+static int of_fwnode_property_read_int_array(const struct fwnode_handle *fwnode,
 					     const char *propname,
 					     unsigned int elem_size, void *val,
 					     size_t nval)
 {
-	struct device_node *node = to_of_node(fwnode);
+	const struct device_node *node = to_of_node(fwnode);
 
 	if (!val)
 		return of_property_count_elems_of_size(node, propname,
@@ -851,24 +851,26 @@ static int of_fwnode_property_read_int_array(struct fwnode_handle *fwnode,
 	return -ENXIO;
 }
 
-static int of_fwnode_property_read_string_array(struct fwnode_handle *fwnode,
-						const char *propname,
-						const char **val, size_t nval)
+static int
+of_fwnode_property_read_string_array(const struct fwnode_handle *fwnode,
+				     const char *propname, const char **val,
+				     size_t nval)
 {
-	struct device_node *node = to_of_node(fwnode);
+	const struct device_node *node = to_of_node(fwnode);
 
 	return val ?
 		of_property_read_string_array(node, propname, val, nval) :
 		of_property_count_strings(node, propname);
 }
 
-static struct fwnode_handle *of_fwnode_get_parent(struct fwnode_handle *fwnode)
+static struct fwnode_handle *
+of_fwnode_get_parent(const struct fwnode_handle *fwnode)
 {
 	return of_fwnode_handle(of_get_parent(to_of_node(fwnode)));
 }
 
 static struct fwnode_handle *
-of_fwnode_get_next_child_node(struct fwnode_handle *fwnode,
+of_fwnode_get_next_child_node(const struct fwnode_handle *fwnode,
 			      struct fwnode_handle *child)
 {
 	return of_fwnode_handle(of_get_next_available_child(to_of_node(fwnode),
@@ -876,10 +878,10 @@ of_fwnode_get_next_child_node(struct fwnode_handle *fwnode,
 }
 
 static struct fwnode_handle *
-of_fwnode_get_named_child_node(struct fwnode_handle *fwnode,
+of_fwnode_get_named_child_node(const struct fwnode_handle *fwnode,
 			       const char *childname)
 {
-	struct device_node *node = to_of_node(fwnode);
+	const struct device_node *node = to_of_node(fwnode);
 	struct device_node *child;
 
 	for_each_available_child_of_node(node, child)
@@ -890,7 +892,7 @@ of_fwnode_get_named_child_node(struct fwnode_handle *fwnode,
 }
 
 static struct fwnode_handle *
-of_fwnode_graph_get_next_endpoint(struct fwnode_handle *fwnode,
+of_fwnode_graph_get_next_endpoint(const struct fwnode_handle *fwnode,
 				  struct fwnode_handle *prev)
 {
 	return of_fwnode_handle(of_graph_get_next_endpoint(to_of_node(fwnode),
@@ -898,7 +900,7 @@ of_fwnode_graph_get_next_endpoint(struct fwnode_handle *fwnode,
 }
 
 static struct fwnode_handle *
-of_fwnode_graph_get_remote_endpoint(struct fwnode_handle *fwnode)
+of_fwnode_graph_get_remote_endpoint(const struct fwnode_handle *fwnode)
 {
 	return of_fwnode_handle(of_parse_phandle(to_of_node(fwnode),
 						 "remote-endpoint", 0));
@@ -921,10 +923,10 @@ of_fwnode_graph_get_port_parent(struct fwnode_handle *fwnode)
 	return of_fwnode_handle(of_get_next_parent(np));
 }
 
-static int of_fwnode_graph_parse_endpoint(struct fwnode_handle *fwnode,
+static int of_fwnode_graph_parse_endpoint(const struct fwnode_handle *fwnode,
 					  struct fwnode_endpoint *endpoint)
 {
-	struct device_node *node = to_of_node(fwnode);
+	const struct device_node *node = to_of_node(fwnode);
 	struct device_node *port_node = of_get_parent(node);
 
 	endpoint->local_fwnode = fwnode;

commit db3e50f3234ba1a477413f56a9e5800a73dca786
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Fri Jul 21 14:39:31 2017 +0300

    device property: Get rid of struct fwnode_handle type field
    
    Instead of relying on the struct fwnode_handle type field, define
    fwnode_operations structs for all separate types of fwnodes. To find out
    the type, compare to the ops field to relevant ops structs.
    
    This change has two benefits:
    
    1. it avoids adding the type field to each and every instance of struct
    fwnode_handle, thus saving memory and
    
    2. makes the ops field the single factor that defines both the types of
    the fwnode as well as defines the implementation of its operations,
    decreasing the possibility of bugs when developing code dealing with
    fwnode internals.
    
    Suggested-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index eda50b4be934..2d5988820405 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -952,3 +952,4 @@ const struct fwnode_operations of_fwnode_ops = {
 	.graph_get_port_parent = of_fwnode_graph_get_port_parent,
 	.graph_parse_endpoint = of_fwnode_graph_parse_endpoint,
 };
+EXPORT_SYMBOL_GPL(of_fwnode_ops);

commit 0d638a07d3a1e98a7598eb2812a6236324e4c55f
Author: Rob Herring <robh@kernel.org>
Date:   Thu Jun 1 15:50:55 2017 -0500

    of: Convert to using %pOF instead of full_name
    
    Now that we have a custom printf format specifier, convert users of
    full_name to use %pOF instead. This is preparation to remove storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index eda50b4be934..ab4cf1da77b5 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -55,8 +55,8 @@ int of_property_count_elems_of_size(const struct device_node *np,
 		return -ENODATA;
 
 	if (prop->length % elem_size != 0) {
-		pr_err("size of %s in node %s is not a multiple of %d\n",
-		       propname, np->full_name, elem_size);
+		pr_err("size of %s in node %pOF is not a multiple of %d\n",
+		       propname, np, elem_size);
 		return -EINVAL;
 	}
 
@@ -537,8 +537,8 @@ int of_graph_parse_endpoint(const struct device_node *node,
 {
 	struct device_node *port_node = of_get_parent(node);
 
-	WARN_ONCE(!port_node, "%s(): endpoint %s has no parent node\n",
-		  __func__, node->full_name);
+	WARN_ONCE(!port_node, "%s(): endpoint %pOF has no parent node\n",
+		  __func__, node);
 
 	memset(endpoint, 0, sizeof(*endpoint));
 
@@ -621,14 +621,13 @@ struct device_node *of_graph_get_next_endpoint(const struct device_node *parent,
 		of_node_put(node);
 
 		if (!port) {
-			pr_err("graph: no port node found in %s\n",
-			       parent->full_name);
+			pr_err("graph: no port node found in %pOF\n", parent);
 			return NULL;
 		}
 	} else {
 		port = of_get_parent(prev);
-		if (WARN_ONCE(!port, "%s(): endpoint %s has no parent node\n",
-			      __func__, prev->full_name))
+		if (WARN_ONCE(!port, "%s(): endpoint %pOF has no parent node\n",
+			      __func__, prev))
 			return NULL;
 	}
 
@@ -784,8 +783,8 @@ struct device_node *of_graph_get_remote_node(const struct device_node *node,
 
 	endpoint_node = of_graph_get_endpoint_by_regs(node, port, endpoint);
 	if (!endpoint_node) {
-		pr_debug("no valid endpoint (%d, %d) for node %s\n",
-			 port, endpoint, node->full_name);
+		pr_debug("no valid endpoint (%d, %d) for node %pOF\n",
+			 port, endpoint, node);
 		return NULL;
 	}
 

commit 548aa0e3c516d906dae5edb1fc9a1ad2e490120a
Merge: 322618684353 6a71d8d77795
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 10 15:23:45 2017 -0700

    Merge tag 'devprop-4.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull device properties framework updates from Rafael Wysocki:
     "These mostly rearrange the device properties core code and add a few
      helper functions to it as a foundation for future work.
    
      Specifics:
    
       - Rearrange the core device properties code by moving the code
         specific to each supported platform configuration framework (ACPI,
         DT and build-in) into a separate file (Sakari Ailus).
    
       - Add helper functions for accessing device properties in a
         firmware-agnostic way (Sakari Ailus, Kieran Bingham)"
    
    * tag 'devprop-4.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      device property: Add fwnode_graph_get_port_parent
      device property: Add FW type agnostic fwnode_graph_get_remote_node
      device property: Introduce fwnode_device_is_available()
      device property: Move fwnode graph ops to firmware specific locations
      device property: Move FW type specific functionality to FW specific files
      ACPI: Constify argument to acpi_device_is_present()

commit b8ba92b101e82b82a5359dc2dfbd772eb46780d4
Merge: d20dc1493db4 ac1e6958d3be
Author: Rob Herring <robh@kernel.org>
Date:   Wed Jul 5 08:24:05 2017 -0500

    Merge branch 'topic/of-graph-base' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound into dt/property-move
    
    OF graph changes for ALSA conflict with the move of graph functions into
    property.c.

commit 2294b3af05e9b3fe0b84a78971e709037bd7593c
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Tue Jun 6 12:37:39 2017 +0300

    device property: Introduce fwnode_device_is_available()
    
    Add fwnode_device_is_available() to tell whether the device corresponding
    to a certain fwnode_handle is available for use.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index e859e41e33f3..c96389b7c6b3 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -775,6 +775,11 @@ static void of_fwnode_put(struct fwnode_handle *fwnode)
 	of_node_put(to_of_node(fwnode));
 }
 
+static bool of_fwnode_device_is_available(struct fwnode_handle *fwnode)
+{
+	return of_device_is_available(to_of_node(fwnode));
+}
+
 static bool of_fwnode_property_present(struct fwnode_handle *fwnode,
 				       const char *propname)
 {
@@ -895,6 +900,7 @@ static int of_fwnode_graph_parse_endpoint(struct fwnode_handle *fwnode,
 const struct fwnode_operations of_fwnode_ops = {
 	.get = of_fwnode_get,
 	.put = of_fwnode_put,
+	.device_is_available = of_fwnode_device_is_available,
 	.property_present = of_fwnode_property_present,
 	.property_read_int_array = of_fwnode_property_read_int_array,
 	.property_read_string_array = of_fwnode_property_read_string_array,

commit 3b27d00e7b6d7c889d87fd00df600c495b968e30
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Tue Jun 6 12:37:38 2017 +0300

    device property: Move fwnode graph ops to firmware specific locations
    
    Move firmware specific implementations of the fwnode graph operations to
    firmware specific locations.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index 250859234fb0..e859e41e33f3 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -844,6 +844,54 @@ of_fwnode_get_named_child_node(struct fwnode_handle *fwnode,
 	return NULL;
 }
 
+static struct fwnode_handle *
+of_fwnode_graph_get_next_endpoint(struct fwnode_handle *fwnode,
+				  struct fwnode_handle *prev)
+{
+	return of_fwnode_handle(of_graph_get_next_endpoint(to_of_node(fwnode),
+							   to_of_node(prev)));
+}
+
+static struct fwnode_handle *
+of_fwnode_graph_get_remote_endpoint(struct fwnode_handle *fwnode)
+{
+	return of_fwnode_handle(of_parse_phandle(to_of_node(fwnode),
+						 "remote-endpoint", 0));
+}
+
+static struct fwnode_handle *
+of_fwnode_graph_get_port_parent(struct fwnode_handle *fwnode)
+{
+	struct device_node *np;
+
+	/* Get the parent of the port */
+	np = of_get_next_parent(to_of_node(fwnode));
+	if (!np)
+		return NULL;
+
+	/* Is this the "ports" node? If not, it's the port parent. */
+	if (of_node_cmp(np->name, "ports"))
+		return of_fwnode_handle(np);
+
+	return of_fwnode_handle(of_get_next_parent(np));
+}
+
+static int of_fwnode_graph_parse_endpoint(struct fwnode_handle *fwnode,
+					  struct fwnode_endpoint *endpoint)
+{
+	struct device_node *node = to_of_node(fwnode);
+	struct device_node *port_node = of_get_parent(node);
+
+	endpoint->local_fwnode = fwnode;
+
+	of_property_read_u32(port_node, "reg", &endpoint->port);
+	of_property_read_u32(node, "reg", &endpoint->id);
+
+	of_node_put(port_node);
+
+	return 0;
+}
+
 const struct fwnode_operations of_fwnode_ops = {
 	.get = of_fwnode_get,
 	.put = of_fwnode_put,
@@ -853,4 +901,8 @@ const struct fwnode_operations of_fwnode_ops = {
 	.get_parent = of_fwnode_get_parent,
 	.get_next_child_node = of_fwnode_get_next_child_node,
 	.get_named_child_node = of_fwnode_get_named_child_node,
+	.graph_get_next_endpoint = of_fwnode_graph_get_next_endpoint,
+	.graph_get_remote_endpoint = of_fwnode_graph_get_remote_endpoint,
+	.graph_get_port_parent = of_fwnode_graph_get_port_parent,
+	.graph_parse_endpoint = of_fwnode_graph_parse_endpoint,
 };

commit 3708184afc77bb67709a67a35d9f367ebd32cbc4
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Tue Jun 6 12:37:37 2017 +0300

    device property: Move FW type specific functionality to FW specific files
    
    The device and fwnode property API supports Devicetree, ACPI and pset
    properties. The implementation of this functionality for each firmware
    type was embedded in the fwnode property core. Move it out to firmware
    type specific locations, making it easier to maintain.
    
    Depends-on: ("of: Move OF property and graph API from base.c to property.c")
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/of/property.c b/drivers/of/property.c
index 457c313a8924..250859234fb0 100644
--- a/drivers/of/property.c
+++ b/drivers/of/property.c
@@ -764,3 +764,93 @@ struct device_node *of_graph_get_remote_node(const struct device_node *node,
 	return remote;
 }
 EXPORT_SYMBOL(of_graph_get_remote_node);
+
+static void of_fwnode_get(struct fwnode_handle *fwnode)
+{
+	of_node_get(to_of_node(fwnode));
+}
+
+static void of_fwnode_put(struct fwnode_handle *fwnode)
+{
+	of_node_put(to_of_node(fwnode));
+}
+
+static bool of_fwnode_property_present(struct fwnode_handle *fwnode,
+				       const char *propname)
+{
+	return of_property_read_bool(to_of_node(fwnode), propname);
+}
+
+static int of_fwnode_property_read_int_array(struct fwnode_handle *fwnode,
+					     const char *propname,
+					     unsigned int elem_size, void *val,
+					     size_t nval)
+{
+	struct device_node *node = to_of_node(fwnode);
+
+	if (!val)
+		return of_property_count_elems_of_size(node, propname,
+						       elem_size);
+
+	switch (elem_size) {
+	case sizeof(u8):
+		return of_property_read_u8_array(node, propname, val, nval);
+	case sizeof(u16):
+		return of_property_read_u16_array(node, propname, val, nval);
+	case sizeof(u32):
+		return of_property_read_u32_array(node, propname, val, nval);
+	case sizeof(u64):
+		return of_property_read_u64_array(node, propname, val, nval);
+	}
+
+	return -ENXIO;
+}
+
+static int of_fwnode_property_read_string_array(struct fwnode_handle *fwnode,
+						const char *propname,
+						const char **val, size_t nval)
+{
+	struct device_node *node = to_of_node(fwnode);
+
+	return val ?
+		of_property_read_string_array(node, propname, val, nval) :
+		of_property_count_strings(node, propname);
+}
+
+static struct fwnode_handle *of_fwnode_get_parent(struct fwnode_handle *fwnode)
+{
+	return of_fwnode_handle(of_get_parent(to_of_node(fwnode)));
+}
+
+static struct fwnode_handle *
+of_fwnode_get_next_child_node(struct fwnode_handle *fwnode,
+			      struct fwnode_handle *child)
+{
+	return of_fwnode_handle(of_get_next_available_child(to_of_node(fwnode),
+							    to_of_node(child)));
+}
+
+static struct fwnode_handle *
+of_fwnode_get_named_child_node(struct fwnode_handle *fwnode,
+			       const char *childname)
+{
+	struct device_node *node = to_of_node(fwnode);
+	struct device_node *child;
+
+	for_each_available_child_of_node(node, child)
+		if (!of_node_cmp(child->name, childname))
+			return of_fwnode_handle(child);
+
+	return NULL;
+}
+
+const struct fwnode_operations of_fwnode_ops = {
+	.get = of_fwnode_get,
+	.put = of_fwnode_put,
+	.property_present = of_fwnode_property_present,
+	.property_read_int_array = of_fwnode_property_read_int_array,
+	.property_read_string_array = of_fwnode_property_read_string_array,
+	.get_parent = of_fwnode_get_parent,
+	.get_next_child_node = of_fwnode_get_next_child_node,
+	.get_named_child_node = of_fwnode_get_named_child_node,
+};

commit 1df09bc66f9bc146732628f8426787f35ab1804b
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Wed May 24 17:53:53 2017 +0300

    of: Move OF property and graph API from base.c to property.c
    
    base.c contains both core OF functions and increasingly other
    functionality such as accessing properties and graphs, including
    convenience functions. In the near future this would also include OF
    specific implementation of the fwnode property and graph APIs.
    
    Create driver/of/property.c to contain procedures for accessing and
    interpreting device tree properties. The procedures are moved from
    drivers/of/base.c, with no changes other than copying only the includes
    required by the moved procedures.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/property.c b/drivers/of/property.c
new file mode 100644
index 000000000000..457c313a8924
--- /dev/null
+++ b/drivers/of/property.c
@@ -0,0 +1,766 @@
+/*
+ * drivers/of/property.c - Procedures for accessing and interpreting
+ *			   Devicetree properties and graphs.
+ *
+ * Initially created by copying procedures from drivers/of/base.c. This
+ * file contains the OF property as well as the OF graph interface
+ * functions.
+ *
+ * Paul Mackerras	August 1996.
+ * Copyright (C) 1996-2005 Paul Mackerras.
+ *
+ *  Adapted for 64bit PowerPC by Dave Engebretsen and Peter Bergner.
+ *    {engebret|bergner}@us.ibm.com
+ *
+ *  Adapted for sparc and sparc64 by David S. Miller davem@davemloft.net
+ *
+ *  Reconsolidated from arch/x/kernel/prom.c by Stephen Rothwell and
+ *  Grant Likely.
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+
+#define pr_fmt(fmt)	"OF: " fmt
+
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_graph.h>
+#include <linux/string.h>
+
+#include "of_private.h"
+
+/**
+ * of_property_count_elems_of_size - Count the number of elements in a property
+ *
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ * @elem_size:	size of the individual element
+ *
+ * Search for a property in a device node and count the number of elements of
+ * size elem_size in it. Returns number of elements on sucess, -EINVAL if the
+ * property does not exist or its length does not match a multiple of elem_size
+ * and -ENODATA if the property does not have a value.
+ */
+int of_property_count_elems_of_size(const struct device_node *np,
+				const char *propname, int elem_size)
+{
+	struct property *prop = of_find_property(np, propname, NULL);
+
+	if (!prop)
+		return -EINVAL;
+	if (!prop->value)
+		return -ENODATA;
+
+	if (prop->length % elem_size != 0) {
+		pr_err("size of %s in node %s is not a multiple of %d\n",
+		       propname, np->full_name, elem_size);
+		return -EINVAL;
+	}
+
+	return prop->length / elem_size;
+}
+EXPORT_SYMBOL_GPL(of_property_count_elems_of_size);
+
+/**
+ * of_find_property_value_of_size
+ *
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ * @min:	minimum allowed length of property value
+ * @max:	maximum allowed length of property value (0 means unlimited)
+ * @len:	if !=NULL, actual length is written to here
+ *
+ * Search for a property in a device node and valid the requested size.
+ * Returns the property value on success, -EINVAL if the property does not
+ *  exist, -ENODATA if property does not have a value, and -EOVERFLOW if the
+ * property data is too small or too large.
+ *
+ */
+static void *of_find_property_value_of_size(const struct device_node *np,
+			const char *propname, u32 min, u32 max, size_t *len)
+{
+	struct property *prop = of_find_property(np, propname, NULL);
+
+	if (!prop)
+		return ERR_PTR(-EINVAL);
+	if (!prop->value)
+		return ERR_PTR(-ENODATA);
+	if (prop->length < min)
+		return ERR_PTR(-EOVERFLOW);
+	if (max && prop->length > max)
+		return ERR_PTR(-EOVERFLOW);
+
+	if (len)
+		*len = prop->length;
+
+	return prop->value;
+}
+
+/**
+ * of_property_read_u32_index - Find and read a u32 from a multi-value property.
+ *
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ * @index:	index of the u32 in the list of values
+ * @out_value:	pointer to return value, modified only if no error.
+ *
+ * Search for a property in a device node and read nth 32-bit value from
+ * it. Returns 0 on success, -EINVAL if the property does not exist,
+ * -ENODATA if property does not have a value, and -EOVERFLOW if the
+ * property data isn't large enough.
+ *
+ * The out_value is modified only if a valid u32 value can be decoded.
+ */
+int of_property_read_u32_index(const struct device_node *np,
+				       const char *propname,
+				       u32 index, u32 *out_value)
+{
+	const u32 *val = of_find_property_value_of_size(np, propname,
+					((index + 1) * sizeof(*out_value)),
+					0,
+					NULL);
+
+	if (IS_ERR(val))
+		return PTR_ERR(val);
+
+	*out_value = be32_to_cpup(((__be32 *)val) + index);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(of_property_read_u32_index);
+
+/**
+ * of_property_read_u64_index - Find and read a u64 from a multi-value property.
+ *
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ * @index:	index of the u64 in the list of values
+ * @out_value:	pointer to return value, modified only if no error.
+ *
+ * Search for a property in a device node and read nth 64-bit value from
+ * it. Returns 0 on success, -EINVAL if the property does not exist,
+ * -ENODATA if property does not have a value, and -EOVERFLOW if the
+ * property data isn't large enough.
+ *
+ * The out_value is modified only if a valid u64 value can be decoded.
+ */
+int of_property_read_u64_index(const struct device_node *np,
+				       const char *propname,
+				       u32 index, u64 *out_value)
+{
+	const u64 *val = of_find_property_value_of_size(np, propname,
+					((index + 1) * sizeof(*out_value)),
+					0, NULL);
+
+	if (IS_ERR(val))
+		return PTR_ERR(val);
+
+	*out_value = be64_to_cpup(((__be64 *)val) + index);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(of_property_read_u64_index);
+
+/**
+ * of_property_read_variable_u8_array - Find and read an array of u8 from a
+ * property, with bounds on the minimum and maximum array size.
+ *
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ * @out_values:	pointer to return value, modified only if return value is 0.
+ * @sz_min:	minimum number of array elements to read
+ * @sz_max:	maximum number of array elements to read, if zero there is no
+ *		upper limit on the number of elements in the dts entry but only
+ *		sz_min will be read.
+ *
+ * Search for a property in a device node and read 8-bit value(s) from
+ * it. Returns number of elements read on success, -EINVAL if the property
+ * does not exist, -ENODATA if property does not have a value, and -EOVERFLOW
+ * if the property data is smaller than sz_min or longer than sz_max.
+ *
+ * dts entry of array should be like:
+ *	property = /bits/ 8 <0x50 0x60 0x70>;
+ *
+ * The out_values is modified only if a valid u8 value can be decoded.
+ */
+int of_property_read_variable_u8_array(const struct device_node *np,
+					const char *propname, u8 *out_values,
+					size_t sz_min, size_t sz_max)
+{
+	size_t sz, count;
+	const u8 *val = of_find_property_value_of_size(np, propname,
+						(sz_min * sizeof(*out_values)),
+						(sz_max * sizeof(*out_values)),
+						&sz);
+
+	if (IS_ERR(val))
+		return PTR_ERR(val);
+
+	if (!sz_max)
+		sz = sz_min;
+	else
+		sz /= sizeof(*out_values);
+
+	count = sz;
+	while (count--)
+		*out_values++ = *val++;
+
+	return sz;
+}
+EXPORT_SYMBOL_GPL(of_property_read_variable_u8_array);
+
+/**
+ * of_property_read_variable_u16_array - Find and read an array of u16 from a
+ * property, with bounds on the minimum and maximum array size.
+ *
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ * @out_values:	pointer to return value, modified only if return value is 0.
+ * @sz_min:	minimum number of array elements to read
+ * @sz_max:	maximum number of array elements to read, if zero there is no
+ *		upper limit on the number of elements in the dts entry but only
+ *		sz_min will be read.
+ *
+ * Search for a property in a device node and read 16-bit value(s) from
+ * it. Returns number of elements read on success, -EINVAL if the property
+ * does not exist, -ENODATA if property does not have a value, and -EOVERFLOW
+ * if the property data is smaller than sz_min or longer than sz_max.
+ *
+ * dts entry of array should be like:
+ *	property = /bits/ 16 <0x5000 0x6000 0x7000>;
+ *
+ * The out_values is modified only if a valid u16 value can be decoded.
+ */
+int of_property_read_variable_u16_array(const struct device_node *np,
+					const char *propname, u16 *out_values,
+					size_t sz_min, size_t sz_max)
+{
+	size_t sz, count;
+	const __be16 *val = of_find_property_value_of_size(np, propname,
+						(sz_min * sizeof(*out_values)),
+						(sz_max * sizeof(*out_values)),
+						&sz);
+
+	if (IS_ERR(val))
+		return PTR_ERR(val);
+
+	if (!sz_max)
+		sz = sz_min;
+	else
+		sz /= sizeof(*out_values);
+
+	count = sz;
+	while (count--)
+		*out_values++ = be16_to_cpup(val++);
+
+	return sz;
+}
+EXPORT_SYMBOL_GPL(of_property_read_variable_u16_array);
+
+/**
+ * of_property_read_variable_u32_array - Find and read an array of 32 bit
+ * integers from a property, with bounds on the minimum and maximum array size.
+ *
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ * @out_values:	pointer to return value, modified only if return value is 0.
+ * @sz_min:	minimum number of array elements to read
+ * @sz_max:	maximum number of array elements to read, if zero there is no
+ *		upper limit on the number of elements in the dts entry but only
+ *		sz_min will be read.
+ *
+ * Search for a property in a device node and read 32-bit value(s) from
+ * it. Returns number of elements read on success, -EINVAL if the property
+ * does not exist, -ENODATA if property does not have a value, and -EOVERFLOW
+ * if the property data is smaller than sz_min or longer than sz_max.
+ *
+ * The out_values is modified only if a valid u32 value can be decoded.
+ */
+int of_property_read_variable_u32_array(const struct device_node *np,
+			       const char *propname, u32 *out_values,
+			       size_t sz_min, size_t sz_max)
+{
+	size_t sz, count;
+	const __be32 *val = of_find_property_value_of_size(np, propname,
+						(sz_min * sizeof(*out_values)),
+						(sz_max * sizeof(*out_values)),
+						&sz);
+
+	if (IS_ERR(val))
+		return PTR_ERR(val);
+
+	if (!sz_max)
+		sz = sz_min;
+	else
+		sz /= sizeof(*out_values);
+
+	count = sz;
+	while (count--)
+		*out_values++ = be32_to_cpup(val++);
+
+	return sz;
+}
+EXPORT_SYMBOL_GPL(of_property_read_variable_u32_array);
+
+/**
+ * of_property_read_u64 - Find and read a 64 bit integer from a property
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ * @out_value:	pointer to return value, modified only if return value is 0.
+ *
+ * Search for a property in a device node and read a 64-bit value from
+ * it. Returns 0 on success, -EINVAL if the property does not exist,
+ * -ENODATA if property does not have a value, and -EOVERFLOW if the
+ * property data isn't large enough.
+ *
+ * The out_value is modified only if a valid u64 value can be decoded.
+ */
+int of_property_read_u64(const struct device_node *np, const char *propname,
+			 u64 *out_value)
+{
+	const __be32 *val = of_find_property_value_of_size(np, propname,
+						sizeof(*out_value),
+						0,
+						NULL);
+
+	if (IS_ERR(val))
+		return PTR_ERR(val);
+
+	*out_value = of_read_number(val, 2);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(of_property_read_u64);
+
+/**
+ * of_property_read_variable_u64_array - Find and read an array of 64 bit
+ * integers from a property, with bounds on the minimum and maximum array size.
+ *
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ * @out_values:	pointer to return value, modified only if return value is 0.
+ * @sz_min:	minimum number of array elements to read
+ * @sz_max:	maximum number of array elements to read, if zero there is no
+ *		upper limit on the number of elements in the dts entry but only
+ *		sz_min will be read.
+ *
+ * Search for a property in a device node and read 64-bit value(s) from
+ * it. Returns number of elements read on success, -EINVAL if the property
+ * does not exist, -ENODATA if property does not have a value, and -EOVERFLOW
+ * if the property data is smaller than sz_min or longer than sz_max.
+ *
+ * The out_values is modified only if a valid u64 value can be decoded.
+ */
+int of_property_read_variable_u64_array(const struct device_node *np,
+			       const char *propname, u64 *out_values,
+			       size_t sz_min, size_t sz_max)
+{
+	size_t sz, count;
+	const __be32 *val = of_find_property_value_of_size(np, propname,
+						(sz_min * sizeof(*out_values)),
+						(sz_max * sizeof(*out_values)),
+						&sz);
+
+	if (IS_ERR(val))
+		return PTR_ERR(val);
+
+	if (!sz_max)
+		sz = sz_min;
+	else
+		sz /= sizeof(*out_values);
+
+	count = sz;
+	while (count--) {
+		*out_values++ = of_read_number(val, 2);
+		val += 2;
+	}
+
+	return sz;
+}
+EXPORT_SYMBOL_GPL(of_property_read_variable_u64_array);
+
+/**
+ * of_property_read_string - Find and read a string from a property
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ * @out_string:	pointer to null terminated return string, modified only if
+ *		return value is 0.
+ *
+ * Search for a property in a device tree node and retrieve a null
+ * terminated string value (pointer to data, not a copy). Returns 0 on
+ * success, -EINVAL if the property does not exist, -ENODATA if property
+ * does not have a value, and -EILSEQ if the string is not null-terminated
+ * within the length of the property data.
+ *
+ * The out_string pointer is modified only if a valid string can be decoded.
+ */
+int of_property_read_string(const struct device_node *np, const char *propname,
+				const char **out_string)
+{
+	const struct property *prop = of_find_property(np, propname, NULL);
+	if (!prop)
+		return -EINVAL;
+	if (!prop->value)
+		return -ENODATA;
+	if (strnlen(prop->value, prop->length) >= prop->length)
+		return -EILSEQ;
+	*out_string = prop->value;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(of_property_read_string);
+
+/**
+ * of_property_match_string() - Find string in a list and return index
+ * @np: pointer to node containing string list property
+ * @propname: string list property name
+ * @string: pointer to string to search for in string list
+ *
+ * This function searches a string list property and returns the index
+ * of a specific string value.
+ */
+int of_property_match_string(const struct device_node *np, const char *propname,
+			     const char *string)
+{
+	const struct property *prop = of_find_property(np, propname, NULL);
+	size_t l;
+	int i;
+	const char *p, *end;
+
+	if (!prop)
+		return -EINVAL;
+	if (!prop->value)
+		return -ENODATA;
+
+	p = prop->value;
+	end = p + prop->length;
+
+	for (i = 0; p < end; i++, p += l) {
+		l = strnlen(p, end - p) + 1;
+		if (p + l > end)
+			return -EILSEQ;
+		pr_debug("comparing %s with %s\n", string, p);
+		if (strcmp(string, p) == 0)
+			return i; /* Found it; return index */
+	}
+	return -ENODATA;
+}
+EXPORT_SYMBOL_GPL(of_property_match_string);
+
+/**
+ * of_property_read_string_helper() - Utility helper for parsing string properties
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ * @out_strs:	output array of string pointers.
+ * @sz:		number of array elements to read.
+ * @skip:	Number of strings to skip over at beginning of list.
+ *
+ * Don't call this function directly. It is a utility helper for the
+ * of_property_read_string*() family of functions.
+ */
+int of_property_read_string_helper(const struct device_node *np,
+				   const char *propname, const char **out_strs,
+				   size_t sz, int skip)
+{
+	const struct property *prop = of_find_property(np, propname, NULL);
+	int l = 0, i = 0;
+	const char *p, *end;
+
+	if (!prop)
+		return -EINVAL;
+	if (!prop->value)
+		return -ENODATA;
+	p = prop->value;
+	end = p + prop->length;
+
+	for (i = 0; p < end && (!out_strs || i < skip + sz); i++, p += l) {
+		l = strnlen(p, end - p) + 1;
+		if (p + l > end)
+			return -EILSEQ;
+		if (out_strs && i >= skip)
+			*out_strs++ = p;
+	}
+	i -= skip;
+	return i <= 0 ? -ENODATA : i;
+}
+EXPORT_SYMBOL_GPL(of_property_read_string_helper);
+
+const __be32 *of_prop_next_u32(struct property *prop, const __be32 *cur,
+			       u32 *pu)
+{
+	const void *curv = cur;
+
+	if (!prop)
+		return NULL;
+
+	if (!cur) {
+		curv = prop->value;
+		goto out_val;
+	}
+
+	curv += sizeof(*cur);
+	if (curv >= prop->value + prop->length)
+		return NULL;
+
+out_val:
+	*pu = be32_to_cpup(curv);
+	return curv;
+}
+EXPORT_SYMBOL_GPL(of_prop_next_u32);
+
+const char *of_prop_next_string(struct property *prop, const char *cur)
+{
+	const void *curv = cur;
+
+	if (!prop)
+		return NULL;
+
+	if (!cur)
+		return prop->value;
+
+	curv += strlen(cur) + 1;
+	if (curv >= prop->value + prop->length)
+		return NULL;
+
+	return curv;
+}
+EXPORT_SYMBOL_GPL(of_prop_next_string);
+
+/**
+ * of_graph_parse_endpoint() - parse common endpoint node properties
+ * @node: pointer to endpoint device_node
+ * @endpoint: pointer to the OF endpoint data structure
+ *
+ * The caller should hold a reference to @node.
+ */
+int of_graph_parse_endpoint(const struct device_node *node,
+			    struct of_endpoint *endpoint)
+{
+	struct device_node *port_node = of_get_parent(node);
+
+	WARN_ONCE(!port_node, "%s(): endpoint %s has no parent node\n",
+		  __func__, node->full_name);
+
+	memset(endpoint, 0, sizeof(*endpoint));
+
+	endpoint->local_node = node;
+	/*
+	 * It doesn't matter whether the two calls below succeed.
+	 * If they don't then the default value 0 is used.
+	 */
+	of_property_read_u32(port_node, "reg", &endpoint->port);
+	of_property_read_u32(node, "reg", &endpoint->id);
+
+	of_node_put(port_node);
+
+	return 0;
+}
+EXPORT_SYMBOL(of_graph_parse_endpoint);
+
+/**
+ * of_graph_get_port_by_id() - get the port matching a given id
+ * @parent: pointer to the parent device node
+ * @id: id of the port
+ *
+ * Return: A 'port' node pointer with refcount incremented. The caller
+ * has to use of_node_put() on it when done.
+ */
+struct device_node *of_graph_get_port_by_id(struct device_node *parent, u32 id)
+{
+	struct device_node *node, *port;
+
+	node = of_get_child_by_name(parent, "ports");
+	if (node)
+		parent = node;
+
+	for_each_child_of_node(parent, port) {
+		u32 port_id = 0;
+
+		if (of_node_cmp(port->name, "port") != 0)
+			continue;
+		of_property_read_u32(port, "reg", &port_id);
+		if (id == port_id)
+			break;
+	}
+
+	of_node_put(node);
+
+	return port;
+}
+EXPORT_SYMBOL(of_graph_get_port_by_id);
+
+/**
+ * of_graph_get_next_endpoint() - get next endpoint node
+ * @parent: pointer to the parent device node
+ * @prev: previous endpoint node, or NULL to get first
+ *
+ * Return: An 'endpoint' node pointer with refcount incremented. Refcount
+ * of the passed @prev node is decremented.
+ */
+struct device_node *of_graph_get_next_endpoint(const struct device_node *parent,
+					struct device_node *prev)
+{
+	struct device_node *endpoint;
+	struct device_node *port;
+
+	if (!parent)
+		return NULL;
+
+	/*
+	 * Start by locating the port node. If no previous endpoint is specified
+	 * search for the first port node, otherwise get the previous endpoint
+	 * parent port node.
+	 */
+	if (!prev) {
+		struct device_node *node;
+
+		node = of_get_child_by_name(parent, "ports");
+		if (node)
+			parent = node;
+
+		port = of_get_child_by_name(parent, "port");
+		of_node_put(node);
+
+		if (!port) {
+			pr_err("graph: no port node found in %s\n",
+			       parent->full_name);
+			return NULL;
+		}
+	} else {
+		port = of_get_parent(prev);
+		if (WARN_ONCE(!port, "%s(): endpoint %s has no parent node\n",
+			      __func__, prev->full_name))
+			return NULL;
+	}
+
+	while (1) {
+		/*
+		 * Now that we have a port node, get the next endpoint by
+		 * getting the next child. If the previous endpoint is NULL this
+		 * will return the first child.
+		 */
+		endpoint = of_get_next_child(port, prev);
+		if (endpoint) {
+			of_node_put(port);
+			return endpoint;
+		}
+
+		/* No more endpoints under this port, try the next one. */
+		prev = NULL;
+
+		do {
+			port = of_get_next_child(parent, port);
+			if (!port)
+				return NULL;
+		} while (of_node_cmp(port->name, "port"));
+	}
+}
+EXPORT_SYMBOL(of_graph_get_next_endpoint);
+
+/**
+ * of_graph_get_endpoint_by_regs() - get endpoint node of specific identifiers
+ * @parent: pointer to the parent device node
+ * @port_reg: identifier (value of reg property) of the parent port node
+ * @reg: identifier (value of reg property) of the endpoint node
+ *
+ * Return: An 'endpoint' node pointer which is identified by reg and at the same
+ * is the child of a port node identified by port_reg. reg and port_reg are
+ * ignored when they are -1.
+ */
+struct device_node *of_graph_get_endpoint_by_regs(
+	const struct device_node *parent, int port_reg, int reg)
+{
+	struct of_endpoint endpoint;
+	struct device_node *node = NULL;
+
+	for_each_endpoint_of_node(parent, node) {
+		of_graph_parse_endpoint(node, &endpoint);
+		if (((port_reg == -1) || (endpoint.port == port_reg)) &&
+			((reg == -1) || (endpoint.id == reg)))
+			return node;
+	}
+
+	return NULL;
+}
+EXPORT_SYMBOL(of_graph_get_endpoint_by_regs);
+
+/**
+ * of_graph_get_remote_port_parent() - get remote port's parent node
+ * @node: pointer to a local endpoint device_node
+ *
+ * Return: Remote device node associated with remote endpoint node linked
+ *	   to @node. Use of_node_put() on it when done.
+ */
+struct device_node *of_graph_get_remote_port_parent(
+			       const struct device_node *node)
+{
+	struct device_node *np;
+	unsigned int depth;
+
+	/* Get remote endpoint node. */
+	np = of_parse_phandle(node, "remote-endpoint", 0);
+
+	/* Walk 3 levels up only if there is 'ports' node. */
+	for (depth = 3; depth && np; depth--) {
+		np = of_get_next_parent(np);
+		if (depth == 2 && of_node_cmp(np->name, "ports"))
+			break;
+	}
+	return np;
+}
+EXPORT_SYMBOL(of_graph_get_remote_port_parent);
+
+/**
+ * of_graph_get_remote_port() - get remote port node
+ * @node: pointer to a local endpoint device_node
+ *
+ * Return: Remote port node associated with remote endpoint node linked
+ *	   to @node. Use of_node_put() on it when done.
+ */
+struct device_node *of_graph_get_remote_port(const struct device_node *node)
+{
+	struct device_node *np;
+
+	/* Get remote endpoint node. */
+	np = of_parse_phandle(node, "remote-endpoint", 0);
+	if (!np)
+		return NULL;
+	return of_get_next_parent(np);
+}
+EXPORT_SYMBOL(of_graph_get_remote_port);
+
+/**
+ * of_graph_get_remote_node() - get remote parent device_node for given port/endpoint
+ * @node: pointer to parent device_node containing graph port/endpoint
+ * @port: identifier (value of reg property) of the parent port node
+ * @endpoint: identifier (value of reg property) of the endpoint node
+ *
+ * Return: Remote device node associated with remote endpoint node linked
+ *	   to @node. Use of_node_put() on it when done.
+ */
+struct device_node *of_graph_get_remote_node(const struct device_node *node,
+					     u32 port, u32 endpoint)
+{
+	struct device_node *endpoint_node, *remote;
+
+	endpoint_node = of_graph_get_endpoint_by_regs(node, port, endpoint);
+	if (!endpoint_node) {
+		pr_debug("no valid endpoint (%d, %d) for node %s\n",
+			 port, endpoint, node->full_name);
+		return NULL;
+	}
+
+	remote = of_graph_get_remote_port_parent(endpoint_node);
+	of_node_put(endpoint_node);
+	if (!remote) {
+		pr_debug("no valid remote node\n");
+		return NULL;
+	}
+
+	if (!of_device_is_available(remote)) {
+		pr_debug("not available for remote node\n");
+		return NULL;
+	}
+
+	return remote;
+}
+EXPORT_SYMBOL(of_graph_get_remote_node);
