commit 89c38422e072bb453e3045b8f1b962a344c3edea
Author: John Garry <john.garry@huawei.com>
Date:   Thu Nov 8 18:17:03 2018 +0800

    of, numa: Validate some distance map rules
    
    Currently the NUMA distance map parsing does not validate the distance
    table for the distance-matrix rules 1-2 in [1].
    
    However the arch NUMA code may enforce some of these rules, but not all.
    Such is the case for the arm64 port, which does not enforce the rule that
    the distance between separates nodes cannot equal LOCAL_DISTANCE.
    
    The patch adds the following rules validation:
    - distance of node to self equals LOCAL_DISTANCE
    - distance of separate nodes > LOCAL_DISTANCE
    
    This change avoids a yet-unresolved crash reported in [2].
    
    A note on dealing with symmetrical distances between nodes:
    
    Validating symmetrical distances between nodes is difficult. If it were
    mandated in the bindings that every distance must be recorded in the
    table, then it would be easy. However, it isn't.
    
    In addition to this, it is also possible to record [b, a] distance only
    (and not [a, b]). So, when processing the table for [b, a], we cannot
    assert that current distance of [a, b] != [b, a] as invalid, as [a, b]
    distance may not be present in the table and current distance would be
    default at REMOTE_DISTANCE.
    
    As such, we maintain the policy that we overwrite distance [a, b] = [b, a]
    for b > a. This policy is different to kernel ACPI SLIT validation, which
    allows non-symmetrical distances (ACPI spec SLIT rules allow it). However,
    the distance debug message is dropped as it may be misleading (for a distance
    which is later overwritten).
    
    Some final notes on semantics:
    
    - It is implied that it is the responsibility of the arch NUMA code to
      reset the NUMA distance map for an error in distance map parsing.
    
    - It is the responsibility of the FW NUMA topology parsing (whether OF or
      ACPI) to enforce NUMA distance rules, and not arch NUMA code.
    
    [1] Documents/devicetree/bindings/numa.txt
    [2] https://www.spinics.net/lists/arm-kernel/msg683304.html
    
    Cc: stable@vger.kernel.org # 4.7
    Signed-off-by: John Garry <john.garry@huawei.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_numa.c b/drivers/of/of_numa.c
index 35c64a4295e0..fe6b13608e51 100644
--- a/drivers/of/of_numa.c
+++ b/drivers/of/of_numa.c
@@ -104,9 +104,14 @@ static int __init of_numa_parse_distance_map_v1(struct device_node *map)
 		distance = of_read_number(matrix, 1);
 		matrix++;
 
+		if ((nodea == nodeb && distance != LOCAL_DISTANCE) ||
+		    (nodea != nodeb && distance <= LOCAL_DISTANCE)) {
+			pr_err("Invalid distance[node%d -> node%d] = %d\n",
+			       nodea, nodeb, distance);
+			return -EINVAL;
+		}
+
 		numa_set_distance(nodea, nodeb, distance);
-		pr_debug("distance[node%d -> node%d] = %d\n",
-			 nodea, nodeb, distance);
 
 		/* Set default distance of node B->A same as A->B */
 		if (nodeb > nodea)

commit 651d44f9679cf49992c59fee5570c2c8b9b8ac4c
Author: Rob Herring <robh@kernel.org>
Date:   Mon Aug 27 09:47:00 2018 -0500

    of: use for_each_of_cpu_node iterator
    
    Use the for_each_of_cpu_node iterator to iterate over cpu nodes. This
    has the side effect of defaulting to iterating using "cpu" node names in
    preference to the deprecated (for FDT) device_type == "cpu".
    
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: devicetree@vger.kernel.org
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_numa.c b/drivers/of/of_numa.c
index 67d3386195bf..35c64a4295e0 100644
--- a/drivers/of/of_numa.c
+++ b/drivers/of/of_numa.c
@@ -24,18 +24,9 @@ static void __init of_numa_parse_cpu_nodes(void)
 {
 	u32 nid;
 	int r;
-	struct device_node *cpus;
-	struct device_node *np = NULL;
-
-	cpus = of_find_node_by_path("/cpus");
-	if (!cpus)
-		return;
-
-	for_each_child_of_node(cpus, np) {
-		/* Skip things that are not CPUs */
-		if (of_node_cmp(np->type, "cpu") != 0)
-			continue;
+	struct device_node *np;
 
+	for_each_of_cpu_node(np) {
 		r = of_property_read_u32(np, "numa-node-id", &nid);
 		if (r)
 			continue;
@@ -46,8 +37,6 @@ static void __init of_numa_parse_cpu_nodes(void)
 		else
 			node_set(nid, numa_nodes_parsed);
 	}
-
-	of_node_put(cpus);
 }
 
 static int __init of_numa_parse_memory_nodes(void)

commit a613b26a50136ae90ab13943afe90bcbd34adb44
Author: Rob Herring <robh@kernel.org>
Date:   Mon Aug 27 20:00:19 2018 -0500

    of: Convert to using %pOFn instead of device_node.name
    
    In preparation to remove the node name pointer from struct device_node,
    convert printf users to use the %pOFn format specifier.
    
    Reviewed-by: Frank Rowand <frank.rowand@sony.com>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: netdev@vger.kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_numa.c b/drivers/of/of_numa.c
index 27d9b4bba535..67d3386195bf 100644
--- a/drivers/of/of_numa.c
+++ b/drivers/of/of_numa.c
@@ -163,8 +163,8 @@ int of_node_to_nid(struct device_node *device)
 		np = of_get_next_parent(np);
 	}
 	if (np && r)
-		pr_warn("Invalid \"numa-node-id\" property in node %s\n",
-			np->name);
+		pr_warn("Invalid \"numa-node-id\" property in node %pOFn\n",
+			np);
 	of_node_put(np);
 
 	/*

commit 9cf7c9cb6b4d869cc26fafd3fe54c2cb69fc81ac
Author: Rob Herring <robh@kernel.org>
Date:   Mon Apr 16 12:00:02 2018 -0500

    of/numa: drop export of of_node_to_nid
    
    The "generic" implementation of of_node_to_nid is only used by
    arm64 and only in built-in code, so remove its export. Any
    device with a struct device should be able to use dev_to_node()
    instead. Also, exporting of_node_to_nid doesn't actually work if
    we build a module on an arch that doesn't select OF_NUMA nor provide its
    own of_node_to_nid implementation.
    
    Cc: Frank Rowand <frowand.list@gmail.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_numa.c b/drivers/of/of_numa.c
index f9d5480a4ae5..27d9b4bba535 100644
--- a/drivers/of/of_numa.c
+++ b/drivers/of/of_numa.c
@@ -177,7 +177,6 @@ int of_node_to_nid(struct device_node *device)
 
 	return NUMA_NO_NODE;
 }
-EXPORT_SYMBOL(of_node_to_nid);
 
 int __init of_numa_init(void)
 {

commit af6074fc9aa4b29517375634189ada1869eea598
Author: Rob Herring <robh@kernel.org>
Date:   Wed Dec 27 12:55:14 2017 -0600

    of: Use SPDX license tag for DT files
    
    Convert remaining DT files to use SPDX-License-Identifier tags.
    
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    Reviewed-by: Frank Rowand <frank.rowand@sony.com>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_numa.c b/drivers/of/of_numa.c
index 2db1f7a04baf..f9d5480a4ae5 100644
--- a/drivers/of/of_numa.c
+++ b/drivers/of/of_numa.c
@@ -1,19 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * OF NUMA Parsing support.
  *
  * Copyright (C) 2015 - 2016 Cavium Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #define pr_fmt(fmt) "OF: NUMA: " fmt

commit b8475cbee5ab2eac05f9cd5dbcc94c453d3cbf10
Author: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
Date:   Mon Apr 17 20:29:17 2017 -0400

    of: fix "/cpus" reference leak in of_numa_parse_cpu_nodes()
    
    The call to of_find_node_by_path("/cpus") returns the cpus device_node
    with its reference count incremented. There is no matching of_node_put()
    call in of_numa_parse_cpu_nodes() which results in a leaked reference
    to the "/cpus" node.
    
    This patch adds an of_node_put() to release the reference.
    
    fixes: 298535c00a2c ("of, numa: Add NUMA of binding implementation.")
    Signed-off-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
    Acked-by: David Daney <david.daney@cavium.com>
    Cc: stable@vger.kernel.org # v4.7+
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_numa.c b/drivers/of/of_numa.c
index a53982a330ea..2db1f7a04baf 100644
--- a/drivers/of/of_numa.c
+++ b/drivers/of/of_numa.c
@@ -57,6 +57,8 @@ static void __init of_numa_parse_cpu_nodes(void)
 		else
 			node_set(nid, numa_nodes_parsed);
 	}
+
+	of_node_put(cpus);
 }
 
 static int __init of_numa_parse_memory_nodes(void)

commit b6cc9474e2dd9f0c19b694b40961d81117f1e918
Author: David Daney <david.daney@cavium.com>
Date:   Fri Oct 28 14:15:02 2016 -0700

    of, numa: Return NUMA_NO_NODE from disable of_node_to_nid() if nid not possible.
    
    On arm64 NUMA kernels we can pass "numa=off" on the command line to
    disable NUMA.  A side effect of this is that kmalloc_node() calls to
    non-zero nodes will crash the system with an OOPS:
    
    [    0.000000] ITS@0x0000901000020000: allocated 2097152 Devices @10002000000 (flat, esz 8, psz 64K, shr 1)
    [    0.000000] Unable to handle kernel NULL pointer dereference at virtual address 00001680
    [    0.000000] pgd = fffffc0009470000
    [    0.000000] [00001680] *pgd=0000010ffff90003, *pud=0000010ffff90003, *pmd=0000010ffff90003, *pte=0000000000000000
    [    0.000000] Internal error: Oops: 96000006 [#1] SMP
    .
    .
    .
    [    0.000000] [<fffffc00081c8950>] __alloc_pages_nodemask+0xa4/0xe68
    [    0.000000] [<fffffc000821fa70>] new_slab+0xd0/0x564
    [    0.000000] [<fffffc0008221e24>] ___slab_alloc+0x2e4/0x514
    [    0.000000] [<fffffc0008239498>] __slab_alloc+0x48/0x58
    [    0.000000] [<fffffc0008222c20>] __kmalloc_node+0xd0/0x2dc
    [    0.000000] [<fffffc0008115374>] __irq_domain_add+0x7c/0x164
    [    0.000000] [<fffffc0008b461dc>] its_probe+0x784/0x81c
    [    0.000000] [<fffffc0008b462bc>] its_init+0x48/0x1b0
    [    0.000000] [<fffffc0008b4543c>] gic_init_bases+0x228/0x360
    [    0.000000] [<fffffc0008b456bc>] gic_of_init+0x148/0x1cc
    [    0.000000] [<fffffc0008b5aec8>] of_irq_init+0x184/0x298
    [    0.000000] [<fffffc0008b43f9c>] irqchip_init+0x14/0x38
    [    0.000000] [<fffffc0008b12d60>] init_IRQ+0xc/0x30
    [    0.000000] [<fffffc0008b10a3c>] start_kernel+0x240/0x3b8
    [    0.000000] [<fffffc0008b101c4>] __primary_switched+0x30/0x6c
    [    0.000000] Code: 912ec2a0 b9403809 0a0902fb 37b007db (f9400300)
    .
    .
    .
    
    This is caused by code like this in kernel/irq/irqdomain.c
    
        domain = kzalloc_node(sizeof(*domain) + (sizeof(unsigned int) * size),
                      GFP_KERNEL, of_node_to_nid(of_node));
    
    When NUMA is disabled, the concept of a node is really undefined, so
    of_node_to_nid() should unconditionally return NUMA_NO_NODE.
    
    Fix by returning NUMA_NO_NODE when the nid is not in the set of
    possible nodes.
    
    Reported-by: Gilbert Netzer <noname@pdc.kth.se>
    Signed-off-by: David Daney <david.daney@cavium.com>
    Cc: stable@vger.kernel.org # 4.7+
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_numa.c b/drivers/of/of_numa.c
index f63d4b0deff0..a53982a330ea 100644
--- a/drivers/of/of_numa.c
+++ b/drivers/of/of_numa.c
@@ -176,7 +176,12 @@ int of_node_to_nid(struct device_node *device)
 			np->name);
 	of_node_put(np);
 
-	if (!r)
+	/*
+	 * If numa=off passed on command line, or with a defective
+	 * device tree, the nid may not be in the set of possible
+	 * nodes.  Check for this case and return NUMA_NO_NODE.
+	 */
+	if (!r && nid < MAX_NUMNODES && node_possible(nid))
 		return nid;
 
 	return NUMA_NO_NODE;

commit ad02180515d4856702bc656f754e9df83ab0345b
Author: Kefeng Wang <wangkefeng.wang@huawei.com>
Date:   Thu Sep 1 14:54:58 2016 +0800

    of_numa: Use pr_fmt()
    
    Use pr_fmt to prefix kernel output.
    
    Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/of/of_numa.c b/drivers/of/of_numa.c
index 0d7459bd31f0..f63d4b0deff0 100644
--- a/drivers/of/of_numa.c
+++ b/drivers/of/of_numa.c
@@ -16,6 +16,8 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#define pr_fmt(fmt) "OF: NUMA: " fmt
+
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/nodemask.h>
@@ -49,10 +51,9 @@ static void __init of_numa_parse_cpu_nodes(void)
 		if (r)
 			continue;
 
-		pr_debug("NUMA: CPU on %u\n", nid);
+		pr_debug("CPU on %u\n", nid);
 		if (nid >= MAX_NUMNODES)
-			pr_warn("NUMA: Node id %u exceeds maximum value\n",
-				nid);
+			pr_warn("Node id %u exceeds maximum value\n", nid);
 		else
 			node_set(nid, numa_nodes_parsed);
 	}
@@ -76,7 +77,7 @@ static int __init of_numa_parse_memory_nodes(void)
 			continue;
 
 		if (nid >= MAX_NUMNODES) {
-			pr_warn("NUMA: Node id %u exceeds maximum value\n", nid);
+			pr_warn("Node id %u exceeds maximum value\n", nid);
 			r = -EINVAL;
 		}
 
@@ -85,7 +86,7 @@ static int __init of_numa_parse_memory_nodes(void)
 
 		if (!i || r) {
 			of_node_put(np);
-			pr_err("NUMA: bad property in memory node\n");
+			pr_err("bad property in memory node\n");
 			return r ? : -EINVAL;
 		}
 	}
@@ -99,17 +100,17 @@ static int __init of_numa_parse_distance_map_v1(struct device_node *map)
 	int entry_count;
 	int i;
 
-	pr_info("NUMA: parsing numa-distance-map-v1\n");
+	pr_info("parsing numa-distance-map-v1\n");
 
 	matrix = of_get_property(map, "distance-matrix", NULL);
 	if (!matrix) {
-		pr_err("NUMA: No distance-matrix property in distance-map\n");
+		pr_err("No distance-matrix property in distance-map\n");
 		return -EINVAL;
 	}
 
 	entry_count = of_property_count_u32_elems(map, "distance-matrix");
 	if (entry_count <= 0) {
-		pr_err("NUMA: Invalid distance-matrix\n");
+		pr_err("Invalid distance-matrix\n");
 		return -EINVAL;
 	}
 
@@ -124,7 +125,7 @@ static int __init of_numa_parse_distance_map_v1(struct device_node *map)
 		matrix++;
 
 		numa_set_distance(nodea, nodeb, distance);
-		pr_debug("NUMA:  distance[node%d -> node%d] = %d\n",
+		pr_debug("distance[node%d -> node%d] = %d\n",
 			 nodea, nodeb, distance);
 
 		/* Set default distance of node B->A same as A->B */
@@ -171,7 +172,7 @@ int of_node_to_nid(struct device_node *device)
 		np = of_get_next_parent(np);
 	}
 	if (np && r)
-		pr_warn("NUMA: Invalid \"numa-node-id\" property in node %s\n",
+		pr_warn("Invalid \"numa-node-id\" property in node %s\n",
 			np->name);
 	of_node_put(np);
 

commit 837dae1b4308f2dfc9c5bc76c367553670198c63
Author: Kefeng Wang <wangkefeng.wang@huawei.com>
Date:   Thu Sep 1 14:54:57 2016 +0800

    of_numa: Use of_get_next_parent to simplify code
    
    Use of_get_next_parent() instead of open-code.
    
    Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/of/of_numa.c b/drivers/of/of_numa.c
index 625b0573e5f8..0d7459bd31f0 100644
--- a/drivers/of/of_numa.c
+++ b/drivers/of/of_numa.c
@@ -158,8 +158,6 @@ int of_node_to_nid(struct device_node *device)
 	np = of_node_get(device);
 
 	while (np) {
-		struct device_node *parent;
-
 		r = of_property_read_u32(np, "numa-node-id", &nid);
 		/*
 		 * -EINVAL indicates the property was not found, and
@@ -170,9 +168,7 @@ int of_node_to_nid(struct device_node *device)
 		if (r != -EINVAL)
 			break;
 
-		parent = of_get_parent(np);
-		of_node_put(np);
-		np = parent;
+		np = of_get_next_parent(np);
 	}
 	if (np && r)
 		pr_warn("NUMA: Invalid \"numa-node-id\" property in node %s\n",

commit 9787ed6e5cee7a62320f3014eb5e7b373502c292
Author: Zhen Lei <thunder.leizhen@huawei.com>
Date:   Thu Sep 1 14:54:55 2016 +0800

    of/numa: remove a duplicated warning
    
    This warning has been printed in of_numa_parse_cpu_nodes before.
    
    Signed-off-by: Zhen Lei <thunder.leizhen@huawei.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/of/of_numa.c b/drivers/of/of_numa.c
index c1bd62ce3144..625b0573e5f8 100644
--- a/drivers/of/of_numa.c
+++ b/drivers/of/of_numa.c
@@ -179,13 +179,8 @@ int of_node_to_nid(struct device_node *device)
 			np->name);
 	of_node_put(np);
 
-	if (!r) {
-		if (nid >= MAX_NUMNODES)
-			pr_warn("NUMA: Node id %u exceeds maximum value\n",
-				nid);
-		else
-			return nid;
-	}
+	if (!r)
+		return nid;
 
 	return NUMA_NO_NODE;
 }

commit 571a588fec2de4efd6043805ab0b017c67b63a4d
Author: Zhen Lei <thunder.leizhen@huawei.com>
Date:   Thu Sep 1 14:54:54 2016 +0800

    of/numa: add nid check for memory block
    
    If the numa-id which was configured in memory@ devicetree node is greater
    than MAX_NUMNODES, we should report a warning. We have done this for cpus
    and distance-map dt nodes, this patch help them to be consistent.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Zhen Lei <thunder.leizhen@huawei.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/of/of_numa.c b/drivers/of/of_numa.c
index 7b3fbdc0b278..c1bd62ce3144 100644
--- a/drivers/of/of_numa.c
+++ b/drivers/of/of_numa.c
@@ -75,6 +75,11 @@ static int __init of_numa_parse_memory_nodes(void)
 			 */
 			continue;
 
+		if (nid >= MAX_NUMNODES) {
+			pr_warn("NUMA: Node id %u exceeds maximum value\n", nid);
+			r = -EINVAL;
+		}
+
 		for (i = 0; !r && !of_address_to_resource(np, i, &rsrc); i++)
 			r = numa_add_memblk(nid, rsrc.start, rsrc.end + 1);
 

commit 84b14256c18c967afd3cf4ee2df09535587154e0
Author: Zhen Lei <thunder.leizhen@huawei.com>
Date:   Thu Sep 1 14:54:53 2016 +0800

    of/numa: fix a memory@ node can only contains one memory block
    
    For a normal memory@ devicetree node, its reg property can contains more
    memory blocks.
    
    Because we don't known how many memory blocks maybe contained, so we try
    from index=0, increase 1 until error returned(the end).
    
    Signed-off-by: Zhen Lei <thunder.leizhen@huawei.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/of/of_numa.c b/drivers/of/of_numa.c
index fb71b4ef1eeb..7b3fbdc0b278 100644
--- a/drivers/of/of_numa.c
+++ b/drivers/of/of_numa.c
@@ -63,13 +63,9 @@ static int __init of_numa_parse_memory_nodes(void)
 	struct device_node *np = NULL;
 	struct resource rsrc;
 	u32 nid;
-	int r = 0;
-
-	for (;;) {
-		np = of_find_node_by_type(np, "memory");
-		if (!np)
-			break;
+	int i, r;
 
+	for_each_node_by_type(np, "memory") {
 		r = of_property_read_u32(np, "numa-node-id", &nid);
 		if (r == -EINVAL)
 			/*
@@ -78,23 +74,18 @@ static int __init of_numa_parse_memory_nodes(void)
 			 * "numa-node-id" property
 			 */
 			continue;
-		else if (r)
-			/* some other error */
-			break;
 
-		r = of_address_to_resource(np, 0, &rsrc);
-		if (r) {
-			pr_err("NUMA: bad reg property in memory node\n");
-			break;
-		}
+		for (i = 0; !r && !of_address_to_resource(np, i, &rsrc); i++)
+			r = numa_add_memblk(nid, rsrc.start, rsrc.end + 1);
 
-		r = numa_add_memblk(nid, rsrc.start, rsrc.end + 1);
-		if (r)
-			break;
+		if (!i || r) {
+			of_node_put(np);
+			pr_err("NUMA: bad property in memory node\n");
+			return r ? : -EINVAL;
+		}
 	}
-	of_node_put(np);
 
-	return r;
+	return 0;
 }
 
 static int __init of_numa_parse_distance_map_v1(struct device_node *map)

commit 16a82f06c40301045e4c05297ea93b85595dbbc4
Author: Zhen Lei <thunder.leizhen@huawei.com>
Date:   Thu Sep 1 14:54:52 2016 +0800

    of/numa: remove a duplicated pr_debug information
    
    This information will be printed in the subfunction numa_add_memblk.
    They are not the same, but very similar.
    
    Signed-off-by: Zhen Lei <thunder.leizhen@huawei.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/of/of_numa.c b/drivers/of/of_numa.c
index ed5a097f0801..fb71b4ef1eeb 100644
--- a/drivers/of/of_numa.c
+++ b/drivers/of/of_numa.c
@@ -88,10 +88,6 @@ static int __init of_numa_parse_memory_nodes(void)
 			break;
 		}
 
-		pr_debug("NUMA:  base = %llx len = %llx, node = %u\n",
-			 rsrc.start, rsrc.end - rsrc.start + 1, nid);
-
-
 		r = numa_add_memblk(nid, rsrc.start, rsrc.end + 1);
 		if (r)
 			break;

commit 8ccbbdaa2bc06f7b11fec7f44bf2501786a189ba
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Tue May 24 15:35:36 2016 -0700

    arm64, NUMA: rework numa_add_memblk()
    
    Rework numa_add_memblk() to update the parameter "u64 size" to "u64
    end", this will make it consistent with x86 and simplifies the arm64
    ACPI NUMA code to be added later.
    
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Robert Richter <rrichter@cavium.com>
    Signed-off-by: David Daney <david.daney@cavium.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/of/of_numa.c b/drivers/of/of_numa.c
index 0f2784bc1874..ed5a097f0801 100644
--- a/drivers/of/of_numa.c
+++ b/drivers/of/of_numa.c
@@ -91,8 +91,8 @@ static int __init of_numa_parse_memory_nodes(void)
 		pr_debug("NUMA:  base = %llx len = %llx, node = %u\n",
 			 rsrc.start, rsrc.end - rsrc.start + 1, nid);
 
-		r = numa_add_memblk(nid, rsrc.start,
-				    rsrc.end - rsrc.start + 1);
+
+		r = numa_add_memblk(nid, rsrc.start, rsrc.end + 1);
 		if (r)
 			break;
 	}

commit 298535c00a2cbcd59e38f8f1c0c9ae7b9911e946
Author: David Daney <david.daney@cavium.com>
Date:   Fri Apr 8 15:50:25 2016 -0700

    of, numa: Add NUMA of binding implementation.
    
    Add device tree parsing for NUMA topology using device
    "numa-node-id" property in distance-map and cpu nodes.
    
    This is a complete rewrite of a previous patch by:
       Ganapatrao Kulkarni<gkulkarni@caviumnetworks.com>
    
    Signed-off-by: David Daney <david.daney@cavium.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/of/of_numa.c b/drivers/of/of_numa.c
new file mode 100644
index 000000000000..0f2784bc1874
--- /dev/null
+++ b/drivers/of/of_numa.c
@@ -0,0 +1,211 @@
+/*
+ * OF NUMA Parsing support.
+ *
+ * Copyright (C) 2015 - 2016 Cavium Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/nodemask.h>
+
+#include <asm/numa.h>
+
+/* define default numa node to 0 */
+#define DEFAULT_NODE 0
+
+/*
+ * Even though we connect cpus to numa domains later in SMP
+ * init, we need to know the node ids now for all cpus.
+*/
+static void __init of_numa_parse_cpu_nodes(void)
+{
+	u32 nid;
+	int r;
+	struct device_node *cpus;
+	struct device_node *np = NULL;
+
+	cpus = of_find_node_by_path("/cpus");
+	if (!cpus)
+		return;
+
+	for_each_child_of_node(cpus, np) {
+		/* Skip things that are not CPUs */
+		if (of_node_cmp(np->type, "cpu") != 0)
+			continue;
+
+		r = of_property_read_u32(np, "numa-node-id", &nid);
+		if (r)
+			continue;
+
+		pr_debug("NUMA: CPU on %u\n", nid);
+		if (nid >= MAX_NUMNODES)
+			pr_warn("NUMA: Node id %u exceeds maximum value\n",
+				nid);
+		else
+			node_set(nid, numa_nodes_parsed);
+	}
+}
+
+static int __init of_numa_parse_memory_nodes(void)
+{
+	struct device_node *np = NULL;
+	struct resource rsrc;
+	u32 nid;
+	int r = 0;
+
+	for (;;) {
+		np = of_find_node_by_type(np, "memory");
+		if (!np)
+			break;
+
+		r = of_property_read_u32(np, "numa-node-id", &nid);
+		if (r == -EINVAL)
+			/*
+			 * property doesn't exist if -EINVAL, continue
+			 * looking for more memory nodes with
+			 * "numa-node-id" property
+			 */
+			continue;
+		else if (r)
+			/* some other error */
+			break;
+
+		r = of_address_to_resource(np, 0, &rsrc);
+		if (r) {
+			pr_err("NUMA: bad reg property in memory node\n");
+			break;
+		}
+
+		pr_debug("NUMA:  base = %llx len = %llx, node = %u\n",
+			 rsrc.start, rsrc.end - rsrc.start + 1, nid);
+
+		r = numa_add_memblk(nid, rsrc.start,
+				    rsrc.end - rsrc.start + 1);
+		if (r)
+			break;
+	}
+	of_node_put(np);
+
+	return r;
+}
+
+static int __init of_numa_parse_distance_map_v1(struct device_node *map)
+{
+	const __be32 *matrix;
+	int entry_count;
+	int i;
+
+	pr_info("NUMA: parsing numa-distance-map-v1\n");
+
+	matrix = of_get_property(map, "distance-matrix", NULL);
+	if (!matrix) {
+		pr_err("NUMA: No distance-matrix property in distance-map\n");
+		return -EINVAL;
+	}
+
+	entry_count = of_property_count_u32_elems(map, "distance-matrix");
+	if (entry_count <= 0) {
+		pr_err("NUMA: Invalid distance-matrix\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i + 2 < entry_count; i += 3) {
+		u32 nodea, nodeb, distance;
+
+		nodea = of_read_number(matrix, 1);
+		matrix++;
+		nodeb = of_read_number(matrix, 1);
+		matrix++;
+		distance = of_read_number(matrix, 1);
+		matrix++;
+
+		numa_set_distance(nodea, nodeb, distance);
+		pr_debug("NUMA:  distance[node%d -> node%d] = %d\n",
+			 nodea, nodeb, distance);
+
+		/* Set default distance of node B->A same as A->B */
+		if (nodeb > nodea)
+			numa_set_distance(nodeb, nodea, distance);
+	}
+
+	return 0;
+}
+
+static int __init of_numa_parse_distance_map(void)
+{
+	int ret = 0;
+	struct device_node *np;
+
+	np = of_find_compatible_node(NULL, NULL,
+				     "numa-distance-map-v1");
+	if (np)
+		ret = of_numa_parse_distance_map_v1(np);
+
+	of_node_put(np);
+	return ret;
+}
+
+int of_node_to_nid(struct device_node *device)
+{
+	struct device_node *np;
+	u32 nid;
+	int r = -ENODATA;
+
+	np = of_node_get(device);
+
+	while (np) {
+		struct device_node *parent;
+
+		r = of_property_read_u32(np, "numa-node-id", &nid);
+		/*
+		 * -EINVAL indicates the property was not found, and
+		 *  we walk up the tree trying to find a parent with a
+		 *  "numa-node-id".  Any other type of error indicates
+		 *  a bad device tree and we give up.
+		 */
+		if (r != -EINVAL)
+			break;
+
+		parent = of_get_parent(np);
+		of_node_put(np);
+		np = parent;
+	}
+	if (np && r)
+		pr_warn("NUMA: Invalid \"numa-node-id\" property in node %s\n",
+			np->name);
+	of_node_put(np);
+
+	if (!r) {
+		if (nid >= MAX_NUMNODES)
+			pr_warn("NUMA: Node id %u exceeds maximum value\n",
+				nid);
+		else
+			return nid;
+	}
+
+	return NUMA_NO_NODE;
+}
+EXPORT_SYMBOL(of_node_to_nid);
+
+int __init of_numa_init(void)
+{
+	int r;
+
+	of_numa_parse_cpu_nodes();
+	r = of_numa_parse_memory_nodes();
+	if (r)
+		return r;
+	return of_numa_parse_distance_map();
+}
