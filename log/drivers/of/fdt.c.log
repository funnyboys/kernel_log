commit 7536c7e03e745bcc6881d0af66e747040943560a
Author: Qi Zheng <arch0.zheng@gmail.com>
Date:   Thu May 28 21:25:41 2020 +0800

    of/fdt: Remove redundant kbasename function call
    
    For version 1 to 3 of the device tree, this is the node full
    path as a zero terminated string, starting with "/". The
    following equation will not hold, since the node name has
    been processed in the fdt_get_name().
    
            *pathp == '/'
    
    For version 16 and later, this is the node unit name only
    (or an empty string for the root node). So the above
    equation will still not hold.
    
    So the kbasename() is redundant, just remove it.
    
    Signed-off-by: Qi Zheng <arch0.zheng@gmail.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 38619e9ef6b2..4602e467ca8b 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -643,8 +643,6 @@ int __init of_scan_flat_dt(int (*it)(unsigned long node,
 	     offset = fdt_next_node(blob, offset, &depth)) {
 
 		pathp = fdt_get_name(blob, offset, NULL);
-		if (*pathp == '/')
-			pathp = kbasename(pathp);
 		rc = it(offset, pathp, depth, data);
 	}
 	return rc;
@@ -671,8 +669,6 @@ int __init of_scan_flat_dt_subnodes(unsigned long parent,
 		int rc;
 
 		pathp = fdt_get_name(blob, node, NULL);
-		if (*pathp == '/')
-			pathp = kbasename(pathp);
 		rc = it(node, pathp, data);
 		if (rc)
 			return rc;

commit c8813f7ec01c676a8995c894ce49d40f5de62ed0
Author: chenqiwu <chenqiwu@xiaomi.com>
Date:   Mon May 11 23:04:57 2020 +0800

    drivers/of: keep description of function consistent with function name
    
    Currently, there are some descriptions of function not
    consistent with function name, fixing them will make
    the code more readable.
    
    Signed-off-by: chenqiwu <chenqiwu@xiaomi.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 8a8e07a8f03d..38619e9ef6b2 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -471,7 +471,7 @@ void *initial_boot_params __ro_after_init;
 static u32 of_fdt_crc32;
 
 /**
- * res_mem_reserve_reg() - reserve all memory described in 'reg' property
+ * __reserved_mem_reserve_reg() - reserve all memory described in 'reg' property
  */
 static int __init __reserved_mem_reserve_reg(unsigned long node,
 					     const char *uname)

commit 8d3cdfeca808f2b2dee11dda4282770c4b579b48
Author: tangjianqiang <wyqt1985@gmail.com>
Date:   Fri Apr 10 16:32:04 2020 +0800

    of: fix the warnings from command line.
    
    Gerrit will complain with this warnings:
    ERROR: (foo*) should be (foo *)
    
    Signed-off-by: tangjianqiang <tangjianqiang@xiaomi.com>
    Reviewed-by: Frank Rowand <frank.rowand@sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 2cdf64d2456f..8a8e07a8f03d 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -1078,7 +1078,7 @@ int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
 #endif
 #endif /* CONFIG_CMDLINE */
 
-	pr_debug("Command line is: %s\n", (char*)data);
+	pr_debug("Command line is: %s\n", (char *)data);
 
 	rng_seed = of_get_flat_dt_prop(node, "rng-seed", &l);
 	if (rng_seed && l > 0) {

commit 2c97b5ae83dca56718774e7b4bf9640f05d11867
Merge: 8328dd2f394e a8de1304b7df
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Dec 2 11:41:35 2019 -0800

    Merge tag 'devicetree-for-5.5' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull Devicetree updates from Rob Herring:
    
     - DT schemas for PWM, syscon, power domains, SRAM, syscon-reboot,
       syscon-poweroff, renesas-irqc, simple-pm-bus, renesas-bsc, pwm-rcar,
       Renesas tpu, at24 eeprom, rtc-sh, Allwinner PS/2, sharp,ld-d5116z01b
       panel, Arm SMMU, max77650, Meson CEC, Amlogic canvas and DWC3 glue,
       Allwinner A10 mUSB and CAN, TI Davinci MDIO, QCom QCS404
       interconnect, Unisoc/Spreadtrum SoCs and UART
    
     - Convert a bunch of Samsung bindings to DT schema
    
     - Convert a bunch of ST stm32 bindings to DT schema
    
     - Realtek and Exynos additions to Arm Mali bindings
    
     - Fix schema errors in RiscV CPU schema
    
     - Various schema fixes from improved meta-schema checks
    
     - Improve the handling of 'dma-ranges' and in particular fix DMA mask
       setup on PCI bridges
    
     - Fix a memory leak in add_changeset_property() and DT unit tests.
    
     - Several documentation improvements for schema validation
    
     - Rework build rules to improve schema validation errors
    
     - Color output for dtx_diff
    
    * tag 'devicetree-for-5.5' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (138 commits)
      libfdt: define INT32_MAX and UINT32_MAX in libfdt_env.h
      dt-bindings: arm: Remove leftover axentia.txt
      of: unittest: fix memory leak in attach_node_and_children
      of: overlay: add_changeset_property() memory leak
      dt-bindings: interrupt-controller: arm,gic-v3: Add missing type to interrupt-partition-* nodes
      dt-bindings: firmware: ixp4xx: Drop redundant minItems/maxItems
      dt-bindings: power: Rename back power_domain.txt bindings to fix references
      dt-bindings: i2c: stm32: Migrate i2c-stm32 documentation to yaml
      dt-bindings: mtd: Convert stm32 fmc2-nand bindings to json-schema
      dt-bindings: remoteproc: convert stm32-rproc to json-schema
      dt-bindings: mailbox: convert stm32-ipcc to json-schema
      dt-bindings: mfd: Convert stm32 low power timers bindings to json-schema
      dt-bindings: interrupt-controller: Convert stm32-exti to json-schema
      dt-bindings: crypto: Convert stm32 HASH bindings to json-schema
      dt-bindings: rng: Convert stm32 RNG bindings to json-schema
      dt-bindings: pwm: Convert Samsung PWM bindings to json-schema
      dt-bindings: pwm: Convert PWM bindings to json-schema
      dt-bindings: serial: Add a new compatible string for SC9863A
      dt-bindings: serial: Convert sprd-uart to json-schema
      dt-bindings: arm: Add bindings for Unisoc SC9863A
      ...

commit 436b2a8039ac00f8dc6ae8f3bd2be83748f72312
Merge: 1b96a41b4209 1d28122131b2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 25 19:40:40 2019 -0800

    Merge tag 'printk-for-5.5' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk
    
    Pull printk updates from Petr Mladek:
    
     - Allow to print symbolic error names via new %pe modifier.
    
     - Use pr_warn() instead of the remaining pr_warning() calls. Fix
       formatting of the related lines.
    
     - Add VSPRINTF entry to MAINTAINERS.
    
    * tag 'printk-for-5.5' of git://git.kernel.org/pub/scm/linux/kernel/git/pmladek/printk: (32 commits)
      checkpatch: don't warn about new vsprintf pointer extension '%pe'
      MAINTAINERS: Add VSPRINTF
      tools lib api: Renaming pr_warning to pr_warn
      ASoC: samsung: Use pr_warn instead of pr_warning
      lib: cpu_rmap: Use pr_warn instead of pr_warning
      trace: Use pr_warn instead of pr_warning
      dma-debug: Use pr_warn instead of pr_warning
      vgacon: Use pr_warn instead of pr_warning
      fs: afs: Use pr_warn instead of pr_warning
      sh/intc: Use pr_warn instead of pr_warning
      scsi: Use pr_warn instead of pr_warning
      platform/x86: intel_oaktrail: Use pr_warn instead of pr_warning
      platform/x86: asus-laptop: Use pr_warn instead of pr_warning
      platform/x86: eeepc-laptop: Use pr_warn instead of pr_warning
      oprofile: Use pr_warn instead of pr_warning
      of: Use pr_warn instead of pr_warning
      macintosh: Use pr_warn instead of pr_warning
      idsn: Use pr_warn instead of pr_warning
      ide: Use pr_warn instead of pr_warning
      crypto: n2: Use pr_warn instead of pr_warning
      ...

commit e2f04da75c0f96f7198cbda73ec53c9fae818c0e
Author: Kefeng Wang <wangkefeng.wang@huawei.com>
Date:   Fri Oct 18 11:18:33 2019 +0800

    of: Use pr_warn instead of pr_warning
    
    As said in commit f2c2cbcc35d4 ("powerpc: Use pr_warn instead of
    pr_warning"), removing pr_warning so all logging messages use a
    consistent <prefix>_warn style. Let's do it.
    
    Link: http://lkml.kernel.org/r/20191018031850.48498-16-wangkefeng.wang@huawei.com
    To: linux-kernel@vger.kernel.org
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index de893c9616a1..24718865ca0a 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -483,8 +483,8 @@ void *__unflatten_device_tree(const void *blob,
 	/* Second pass, do actual unflattening */
 	unflatten_dt_nodes(blob, mem, dad, mynodes);
 	if (be32_to_cpup(mem + size) != 0xdeadbeef)
-		pr_warning("End of tree marker overwritten: %08x\n",
-			   be32_to_cpup(mem + size));
+		pr_warn("End of tree marker overwritten: %08x\n",
+			be32_to_cpup(mem + size));
 
 	if (detached && mynodes) {
 		of_node_set_flag(*mynodes, OF_DETACHED);
@@ -1141,25 +1141,25 @@ void __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)
 	size &= PAGE_MASK;
 
 	if (base > MAX_MEMBLOCK_ADDR) {
-		pr_warning("Ignoring memory block 0x%llx - 0x%llx\n",
-				base, base + size);
+		pr_warn("Ignoring memory block 0x%llx - 0x%llx\n",
+			base, base + size);
 		return;
 	}
 
 	if (base + size - 1 > MAX_MEMBLOCK_ADDR) {
-		pr_warning("Ignoring memory range 0x%llx - 0x%llx\n",
-				((u64)MAX_MEMBLOCK_ADDR) + 1, base + size);
+		pr_warn("Ignoring memory range 0x%llx - 0x%llx\n",
+			((u64)MAX_MEMBLOCK_ADDR) + 1, base + size);
 		size = MAX_MEMBLOCK_ADDR - base + 1;
 	}
 
 	if (base + size < phys_offset) {
-		pr_warning("Ignoring memory block 0x%llx - 0x%llx\n",
-			   base, base + size);
+		pr_warn("Ignoring memory block 0x%llx - 0x%llx\n",
+			base, base + size);
 		return;
 	}
 	if (base < phys_offset) {
-		pr_warning("Ignoring memory range 0x%llx - 0x%llx\n",
-			   base, phys_offset);
+		pr_warn("Ignoring memory range 0x%llx - 0x%llx\n",
+			base, phys_offset);
 		size -= phys_offset - base;
 		base = phys_offset;
 	}

commit b204731689059f0e27b676e86b089d59bd1a4805
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Sep 10 07:58:33 2019 +0200

    of/fdt: don't ignore errors from of_setup_earlycon
    
    If of_setup_earlycon we should keep on iterating earlycon options
    instead of breaking out of the loop.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 223d617ecfe1..d01d834b26b0 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -947,8 +947,8 @@ int __init early_init_dt_scan_chosen_stdout(void)
 		if (fdt_node_check_compatible(fdt, offset, match->compatible))
 			continue;
 
-		of_setup_earlycon(match, offset, options);
-		return 0;
+		if (of_setup_earlycon(match, offset, options) == 0)
+			return 0;
 	}
 	return -ENODEV;
 }

commit dd753d961c4844a39f947be115b3d81e10376ee5
Author: Hsin-Yi Wang <hsinyi@chromium.org>
Date:   Tue Aug 27 18:33:53 2019 +0800

    fdt: Update CRC check for rng-seed
    
    Commit 428826f5358c ("fdt: add support for rng-seed") moves of_fdt_crc32
    from early_init_dt_verify() to early_init_dt_scan() since
    early_init_dt_scan_chosen() may modify fdt to erase rng-seed.
    
    However, arm and some other arch won't call early_init_dt_scan(), they
    call early_init_dt_verify() then early_init_dt_scan_nodes().
    
    Restore of_fdt_crc32 to early_init_dt_verify() then update it in
    early_init_dt_scan_chosen() if fdt if updated.
    
    Fixes: 428826f5358c ("fdt: add support for rng-seed")
    Reported-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Hsin-Yi Wang <hsinyi@chromium.org>
    Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 7d97ab6d0e31..223d617ecfe1 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -1086,6 +1086,10 @@ int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
 
 		/* try to clear seed so it won't be found. */
 		fdt_nop_property(initial_boot_params, node, "rng-seed");
+
+		/* update CRC check value */
+		of_fdt_crc32 = crc32_be(~0, initial_boot_params,
+				fdt_totalsize(initial_boot_params));
 	}
 
 	/* break now */
@@ -1176,6 +1180,8 @@ bool __init early_init_dt_verify(void *params)
 
 	/* Setup flat device-tree pointer */
 	initial_boot_params = params;
+	of_fdt_crc32 = crc32_be(~0, initial_boot_params,
+				fdt_totalsize(initial_boot_params));
 	return true;
 }
 
@@ -1205,8 +1211,6 @@ bool __init early_init_dt_scan(void *params)
 		return false;
 
 	early_init_dt_scan_nodes();
-	of_fdt_crc32 = crc32_be(~0, initial_boot_params,
-				fdt_totalsize(initial_boot_params));
 	return true;
 }
 

commit 428826f5358c922dc378830a1717b682c0823160
Author: Hsin-Yi Wang <hsinyi@chromium.org>
Date:   Fri Aug 23 14:24:51 2019 +0800

    fdt: add support for rng-seed
    
    Introducing a chosen node, rng-seed, which is an entropy that can be
    passed to kernel called very early to increase initial device
    randomness. Bootloader should provide this entropy and the value is
    read from /chosen/rng-seed in DT.
    
    Obtain of_fdt_crc32 for CRC check after early_init_dt_scan_nodes(),
    since early_init_dt_scan_chosen() would modify fdt to erase rng-seed.
    
    Add a new interface add_bootloader_randomness() for rng-seed use case.
    Depends on whether the seed is trustworthy, rng seed would be passed to
    add_hwgenerator_randomness(). Otherwise it would be passed to
    add_device_randomness(). Decision is controlled by kernel config
    RANDOM_TRUST_BOOTLOADER.
    
    Signed-off-by: Hsin-Yi Wang <hsinyi@chromium.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Reviewed-by: Theodore Ts'o <tytso@mit.edu> # drivers/char/random.c
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 9cdf14b9aaab..7d97ab6d0e31 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -24,6 +24,7 @@
 #include <linux/debugfs.h>
 #include <linux/serial_core.h>
 #include <linux/sysfs.h>
+#include <linux/random.h>
 
 #include <asm/setup.h>  /* for COMMAND_LINE_SIZE */
 #include <asm/page.h>
@@ -1044,6 +1045,7 @@ int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
 {
 	int l;
 	const char *p;
+	const void *rng_seed;
 
 	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);
 
@@ -1078,6 +1080,14 @@ int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
 
 	pr_debug("Command line is: %s\n", (char*)data);
 
+	rng_seed = of_get_flat_dt_prop(node, "rng-seed", &l);
+	if (rng_seed && l > 0) {
+		add_bootloader_randomness(rng_seed, l);
+
+		/* try to clear seed so it won't be found. */
+		fdt_nop_property(initial_boot_params, node, "rng-seed");
+	}
+
 	/* break now */
 	return 1;
 }
@@ -1166,8 +1176,6 @@ bool __init early_init_dt_verify(void *params)
 
 	/* Setup flat device-tree pointer */
 	initial_boot_params = params;
-	of_fdt_crc32 = crc32_be(~0, initial_boot_params,
-				fdt_totalsize(initial_boot_params));
 	return true;
 }
 
@@ -1197,6 +1205,8 @@ bool __init early_init_dt_scan(void *params)
 		return false;
 
 	early_init_dt_scan_nodes();
+	of_fdt_crc32 = crc32_be(~0, initial_boot_params,
+				fdt_totalsize(initial_boot_params));
 	return true;
 }
 

commit 5c68b8231e9c361fc3dc96997ea377b31c4dbd3e
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu May 30 19:39:27 2019 +0900

    of/fdt: pass early_init_dt_reserve_memory_arch() with bool type nomap
    
    The third argument 'nomap' of early_init_dt_reserve_memory_arch() is
    bool. It is preferred to pass it with a bool type parameter.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Frank Rowand <frank.rowand@sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index cd17dc62a719..9cdf14b9aaab 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -479,7 +479,8 @@ static int __init __reserved_mem_reserve_reg(unsigned long node,
 	phys_addr_t base, size;
 	int len;
 	const __be32 *prop;
-	int nomap, first = 1;
+	int first = 1;
+	bool nomap;
 
 	prop = of_get_flat_dt_prop(node, "reg", &len);
 	if (!prop)
@@ -594,7 +595,7 @@ void __init early_init_fdt_scan_reserved_mem(void)
 		fdt_get_mem_rsv(initial_boot_params, n, &base, &size);
 		if (!size)
 			break;
-		early_init_dt_reserve_memory_arch(base, size, 0);
+		early_init_dt_reserve_memory_arch(base, size, false);
 	}
 
 	of_scan_flat_dt(__fdt_scan_reserved_mem, NULL);
@@ -612,7 +613,7 @@ void __init early_init_fdt_reserve_self(void)
 	/* Reserve the dtb region */
 	early_init_dt_reserve_memory_arch(__pa(initial_boot_params),
 					  fdt_totalsize(initial_boot_params),
-					  0);
+					  false);
 }
 
 /**

commit 5d9c4e9591dc0cce80dac170cbdc9015e34b074a
Author: Kefeng Wang <wangkefeng.wang@huawei.com>
Date:   Sat Jun 15 11:03:43 2019 +0800

    of/fdt: Fix ‘of_fdt_match’ defined but not used compiler warning
    
    When CONFIG_OF_EARLY_FLATTREE is disabled, there is a compiler
    warning,
    
    drivers/of/fdt.c:129:19: warning: ‘of_fdt_match’ defined but not used [-Wunused-function]
     static int __init of_fdt_match(const void *blob, unsigned long node,
    
    Since the only caller of of_fdt_match() is of_flat_dt_match(),
    let's move the body of of_fdt_match() into of_flat_dt_match()
    and eliminate of_fdt_match().
    
    Meanwhile, move of_fdt_is_compatible() under CONFIG_OF_EARLY_FLATTREE,
    as all callers are over there.
    
    Fixes: 9b4d2b635bd0 ("of/fdt: Remove dead code and mark functions with __init")
    Cc: Frank Rowand <frowand.list@gmail.com>
    Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 3d36b5afd9bd..cd17dc62a719 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -78,38 +78,6 @@ void __init of_fdt_limit_memory(int limit)
 	}
 }
 
-/**
- * of_fdt_is_compatible - Return true if given node from the given blob has
- * compat in its compatible list
- * @blob: A device tree blob
- * @node: node to test
- * @compat: compatible string to compare with compatible list.
- *
- * On match, returns a non-zero value with smaller values returned for more
- * specific compatible values.
- */
-static int of_fdt_is_compatible(const void *blob,
-		      unsigned long node, const char *compat)
-{
-	const char *cp;
-	int cplen;
-	unsigned long l, score = 0;
-
-	cp = fdt_getprop(blob, node, "compatible", &cplen);
-	if (cp == NULL)
-		return 0;
-	while (cplen > 0) {
-		score++;
-		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
-			return score;
-		l = strlen(cp) + 1;
-		cp += l;
-		cplen -= l;
-	}
-
-	return 0;
-}
-
 static bool of_fdt_device_is_available(const void *blob, unsigned long node)
 {
 	const char *status = fdt_getprop(blob, node, "status", NULL);
@@ -123,27 +91,6 @@ static bool of_fdt_device_is_available(const void *blob, unsigned long node)
 	return false;
 }
 
-/**
- * of_fdt_match - Return true if node matches a list of compatible values
- */
-static int __init of_fdt_match(const void *blob, unsigned long node,
-			       const char *const *compat)
-{
-	unsigned int tmp, score = 0;
-
-	if (!compat)
-		return 0;
-
-	while (*compat) {
-		tmp = of_fdt_is_compatible(blob, node, *compat);
-		if (tmp && (score == 0 || (tmp < score)))
-			score = tmp;
-		compat++;
-	}
-
-	return score;
-}
-
 static void *unflatten_dt_alloc(void **mem, unsigned long size,
 				       unsigned long align)
 {
@@ -764,6 +711,38 @@ const void *__init of_get_flat_dt_prop(unsigned long node, const char *name,
 	return fdt_getprop(initial_boot_params, node, name, size);
 }
 
+/**
+ * of_fdt_is_compatible - Return true if given node from the given blob has
+ * compat in its compatible list
+ * @blob: A device tree blob
+ * @node: node to test
+ * @compat: compatible string to compare with compatible list.
+ *
+ * On match, returns a non-zero value with smaller values returned for more
+ * specific compatible values.
+ */
+static int of_fdt_is_compatible(const void *blob,
+		      unsigned long node, const char *compat)
+{
+	const char *cp;
+	int cplen;
+	unsigned long l, score = 0;
+
+	cp = fdt_getprop(blob, node, "compatible", &cplen);
+	if (cp == NULL)
+		return 0;
+	while (cplen > 0) {
+		score++;
+		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
+			return score;
+		l = strlen(cp) + 1;
+		cp += l;
+		cplen -= l;
+	}
+
+	return 0;
+}
+
 /**
  * of_flat_dt_is_compatible - Return true if given node has compat in compatible list
  * @node: node to test
@@ -779,7 +758,19 @@ int __init of_flat_dt_is_compatible(unsigned long node, const char *compat)
  */
 static int __init of_flat_dt_match(unsigned long node, const char *const *compat)
 {
-	return of_fdt_match(initial_boot_params, node, compat);
+	unsigned int tmp, score = 0;
+
+	if (!compat)
+		return 0;
+
+	while (*compat) {
+		tmp = of_fdt_is_compatible(initial_boot_params, node, *compat);
+		if (tmp && (score == 0 || (tmp < score)))
+			score = tmp;
+		compat++;
+	}
+
+	return score;
 }
 
 /**

commit 7c71650f9a3640464dd907bd7a6510cc7ea02ba6
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Tue May 14 13:40:53 2019 -0700

    of/fdt: Mark initial_boot_params as __ro_after_init
    
    The FDT pointer, i.e. initial_boot_params, shouldn't be changed after
    init. It's only set by boot code and then the only user of the FDT is
    the raw sysfs reading API. Mark this pointer with __ro_after_init so
    that the pointer can't be changed after init.
    
    Cc: Hsin-Yi Wang <hsinyi@chromium.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 918098c9f72a..3d36b5afd9bd 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -516,7 +516,7 @@ EXPORT_SYMBOL_GPL(of_fdt_unflatten_tree);
 int __initdata dt_root_addr_cells;
 int __initdata dt_root_size_cells;
 
-void *initial_boot_params;
+void *initial_boot_params __ro_after_init;
 
 #ifdef CONFIG_OF_EARLY_FLATTREE
 

commit 9b4d2b635bd0cf8dfc45223f66fd85792fd2dc7b
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Tue May 14 13:40:52 2019 -0700

    of/fdt: Remove dead code and mark functions with __init
    
    Some functions in here are never called, and others are only called
    during __init. Remove the dead code and some dead exports for functions
    that don't exist (I'm looking at you of_fdt_get_string!). Mark some
    functions with __init so we can throw them away after we boot up and
    poke at the FDT blob too.
    
    Cc: Hsin-Yi Wang <hsinyi@chromium.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index de893c9616a1..918098c9f72a 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -38,7 +38,7 @@
  * memory entries in the /memory node. This function may be called
  * any time after initial_boot_param is set.
  */
-void of_fdt_limit_memory(int limit)
+void __init of_fdt_limit_memory(int limit)
 {
 	int memory;
 	int len;
@@ -110,25 +110,6 @@ static int of_fdt_is_compatible(const void *blob,
 	return 0;
 }
 
-/**
- * of_fdt_is_big_endian - Return true if given node needs BE MMIO accesses
- * @blob: A device tree blob
- * @node: node to test
- *
- * Returns true if the node has a "big-endian" property, or if the kernel
- * was compiled for BE *and* the node has a "native-endian" property.
- * Returns false otherwise.
- */
-bool of_fdt_is_big_endian(const void *blob, unsigned long node)
-{
-	if (fdt_getprop(blob, node, "big-endian", NULL))
-		return true;
-	if (IS_ENABLED(CONFIG_CPU_BIG_ENDIAN) &&
-	    fdt_getprop(blob, node, "native-endian", NULL))
-		return true;
-	return false;
-}
-
 static bool of_fdt_device_is_available(const void *blob, unsigned long node)
 {
 	const char *status = fdt_getprop(blob, node, "status", NULL);
@@ -145,8 +126,8 @@ static bool of_fdt_device_is_available(const void *blob, unsigned long node)
 /**
  * of_fdt_match - Return true if node matches a list of compatible values
  */
-int of_fdt_match(const void *blob, unsigned long node,
-                 const char *const *compat)
+static int __init of_fdt_match(const void *blob, unsigned long node,
+			       const char *const *compat)
 {
 	unsigned int tmp, score = 0;
 
@@ -758,7 +739,7 @@ int __init of_scan_flat_dt_subnodes(unsigned long parent,
  * @return offset of the subnode, or -FDT_ERR_NOTFOUND if there is none
  */
 
-int of_get_flat_dt_subnode_by_name(unsigned long node, const char *uname)
+int __init of_get_flat_dt_subnode_by_name(unsigned long node, const char *uname)
 {
 	return fdt_subnode_offset(initial_boot_params, node, uname);
 }
@@ -771,14 +752,6 @@ unsigned long __init of_get_flat_dt_root(void)
 	return 0;
 }
 
-/**
- * of_get_flat_dt_size - Return the total size of the FDT
- */
-int __init of_get_flat_dt_size(void)
-{
-	return fdt_totalsize(initial_boot_params);
-}
-
 /**
  * of_get_flat_dt_prop - Given a node in the flat blob, return the property ptr
  *
@@ -804,7 +777,7 @@ int __init of_flat_dt_is_compatible(unsigned long node, const char *compat)
 /**
  * of_flat_dt_match - Return true if node matches a list of compatible values
  */
-int __init of_flat_dt_match(unsigned long node, const char *const *compat)
+static int __init of_flat_dt_match(unsigned long node, const char *const *compat)
 {
 	return of_fdt_match(initial_boot_params, node, compat);
 }

commit b827bcbba36d0b9447239136e2237710cca70383
Author: xiaojiangfeng <xiaojiangfeng@huawei.com>
Date:   Wed Apr 10 16:29:41 2019 +0800

    of: del redundant type conversion
    
    The type of variable l in early_init_dt_scan_chosen is
    int, there is no need to convert to int.
    
    Signed-off-by: xiaojiangfeng <xiaojiangfeng@huawei.com>
    Reviewed-by: Frank Rowand <frank.rowand@sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 4734223ab702..de893c9616a1 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -1091,7 +1091,7 @@ int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
 	/* Retrieve command line */
 	p = of_get_flat_dt_prop(node, "bootargs", &l);
 	if (p != NULL && l > 0)
-		strlcpy(data, p, min((int)l, COMMAND_LINE_SIZE));
+		strlcpy(data, p, min(l, COMMAND_LINE_SIZE));
 
 	/*
 	 * CONFIG_CMDLINE is meant to be a default in case nothing else

commit 8a7f97b902f4fb0d94b355b6b3f1fbd7154cafb9
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Mar 11 23:30:31 2019 -0700

    treewide: add checks for the return value of memblock_alloc*()
    
    Add check for the return value of memblock_alloc*() functions and call
    panic() in case of error.  The panic message repeats the one used by
    panicing memblock allocators with adjustment of parameters to include
    only relevant ones.
    
    The replacement was mostly automated with semantic patches like the one
    below with manual massaging of format strings.
    
      @@
      expression ptr, size, align;
      @@
      ptr = memblock_alloc(size, align);
      + if (!ptr)
      +     panic("%s: Failed to allocate %lu bytes align=0x%lx\n", __func__, size, align);
    
    [anders.roxell@linaro.org: use '%pa' with 'phys_addr_t' type]
      Link: http://lkml.kernel.org/r/20190131161046.21886-1-anders.roxell@linaro.org
    [rppt@linux.ibm.com: fix format strings for panics after memblock_alloc]
      Link: http://lkml.kernel.org/r/1548950940-15145-1-git-send-email-rppt@linux.ibm.com
    [rppt@linux.ibm.com: don't panic if the allocation in sparse_buffer_init fails]
      Link: http://lkml.kernel.org/r/20190131074018.GD28876@rapoport-lnx
    [akpm@linux-foundation.org: fix xtensa printk warning]
    Link: http://lkml.kernel.org/r/1548057848-15136-20-git-send-email-rppt@linux.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Anders Roxell <anders.roxell@linaro.org>
    Reviewed-by: Guo Ren <ren_guo@c-sky.com>                [c-sky]
    Acked-by: Paul Burton <paul.burton@mips.com>            [MIPS]
    Acked-by: Heiko Carstens <heiko.carstens@de.ibm.com>    [s390]
    Reviewed-by: Juergen Gross <jgross@suse.com>            [Xen]
    Reviewed-by: Geert Uytterhoeven <geert@linux-m68k.org>  [m68k]
    Acked-by: Max Filippov <jcmvbkbc@gmail.com>             [xtensa]
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Christophe Leroy <christophe.leroy@c-s.fr>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Dennis Zhou <dennis@kernel.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 9cc1461aac7d..4734223ab702 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -1181,7 +1181,13 @@ int __init __weak early_init_dt_reserve_memory_arch(phys_addr_t base,
 
 static void * __init early_init_dt_alloc_memory_arch(u64 size, u64 align)
 {
-	return memblock_alloc(size, align);
+	void *ptr = memblock_alloc(size, align);
+
+	if (!ptr)
+		panic("%s: Failed to allocate %llu bytes align=0x%llx\n",
+		      __func__, size, align);
+
+	return ptr;
 }
 
 bool __init early_init_dt_verify(void *params)

commit 8ce5f84157530ffa64b3e0acf00b9261f41c8da8
Author: Rob Herring <robh@kernel.org>
Date:   Tue Dec 11 14:31:05 2018 -0600

    of: Remove struct device_node.type pointer
    
    Now that all users of device_node.type pointer have been removed in
    favor of accessor functions, we can remove it.
    
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: devicetree@vger.kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 7099c652c6a5..9cc1461aac7d 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -314,12 +314,8 @@ static bool populate_node(const void *blob,
 	populate_properties(blob, offset, mem, np, pathp, dryrun);
 	if (!dryrun) {
 		np->name = of_get_property(np, "name", NULL);
-		np->type = of_get_property(np, "device_type", NULL);
-
 		if (!np->name)
 			np->name = "<NULL>";
-		if (!np->type)
-			np->type = "<NULL>";
 	}
 
 	*pnp = np;

commit e1e5254427525d59a184771b122469c998e53b58
Author: Nick Kossifidis <mick@ics.forth.gr>
Date:   Sat Nov 10 02:53:17 2018 +0200

    OF: Add a warning in case chosen node is not present
    
    On architectures that only get their bootargs through devicetree's
    chosen node (such as RISC-V), that node is mandatory. After a
    discussion with Rob [1] I'm adding a warning in case chosen node
    is not present, to let users know about it.
    
    [1]: https://patchwork.ozlabs.org/patch/984224/#2016136
    
    Signed-off-by: Nick Kossifidis <mick@ics.forth.gr>
    Reviewed-by: Palmer Dabbelt <palmer@sifive.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index cd72a41fcab2..7099c652c6a5 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -1207,8 +1207,12 @@ bool __init early_init_dt_verify(void *params)
 
 void __init early_init_dt_scan_nodes(void)
 {
+	int rc = 0;
+
 	/* Retrieve various information from the /chosen node */
-	of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);
+	rc = of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);
+	if (!rc)
+		pr_warn("No chosen node found, continuing without\n");
 
 	/* Initialize {size,address}-cells info */
 	of_scan_flat_dt(early_init_dt_scan_root, NULL);

commit cdbc848b03414c75b7badccd8ada29deba7ec6e4
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Mon Nov 5 14:54:30 2018 -0800

    of/fdt: Remove custom __early_init_dt_declare_initrd() implementation
    
    Now that ARM64 uses phys_initrd_start/phys_initrd_size, we can get rid
    of its custom __early_init_dt_declare_initrd() which causes a fair
    amount of objects rebuild when changing CONFIG_BLK_DEV_INITRD. In order
    to make sure ARM64 does not produce a BUG() when VM debugging is turned
    on though, we must avoid early calls to __va() which is what
    __early_init_dt_declare_initrd() does and wrap this around to avoid
    running that code on ARM64.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 88760a0983a7..cd72a41fcab2 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -891,15 +891,20 @@ const void * __init of_flat_dt_match_machine(const void *default_match,
 }
 
 #ifdef CONFIG_BLK_DEV_INITRD
-#ifndef __early_init_dt_declare_initrd
 static void __early_init_dt_declare_initrd(unsigned long start,
 					   unsigned long end)
 {
-	initrd_start = (unsigned long)__va(start);
-	initrd_end = (unsigned long)__va(end);
-	initrd_below_start_ok = 1;
+	/* ARM64 would cause a BUG to occur here when CONFIG_DEBUG_VM is
+	 * enabled since __va() is called too early. ARM64 does make use
+	 * of phys_initrd_start/phys_initrd_size so we can skip this
+	 * conversion.
+	 */
+	if (!IS_ENABLED(CONFIG_ARM64)) {
+		initrd_start = (unsigned long)__va(start);
+		initrd_end = (unsigned long)__va(end);
+		initrd_below_start_ok = 1;
+	}
 }
-#endif
 
 /**
  * early_init_dt_check_for_initrd - Decode initrd location from flat tree

commit fe7db7570379dafec67430bb843d2e78df89e7f1
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Mon Nov 5 14:54:28 2018 -0800

    of/fdt: Populate phys_initrd_start/phys_initrd_size from FDT
    
    Now that we have central and global variables holding the physical
    address and size of the initrd, we can have
    early_init_dt_check_for_initrd() populate
    phys_initrd_start/phys_initrd_size for us.
    
    This allows us to remove a chunk of code from arch/arm/mm/init.c
    introduced with commit 65939301acdb ("arm: set initrd_start/initrd_end
    for fdt scan").
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index bb532aae0d92..88760a0983a7 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -924,6 +924,8 @@ static void __init early_init_dt_check_for_initrd(unsigned long node)
 	end = of_read_number(prop, len/4);
 
 	__early_init_dt_declare_initrd(start, end);
+	phys_initrd_start = start;
+	phys_initrd_size = end - start;
 
 	pr_debug("initrd_start=0x%llx  initrd_end=0x%llx\n",
 		 (unsigned long long)start, (unsigned long long)end);

commit 57c8a661d95dff48dd9c2f2496139082bbaf241a
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:49 2018 -0700

    mm: remove include/linux/bootmem.h
    
    Move remaining definitions and declarations from include/linux/bootmem.h
    into include/linux/memblock.h and remove the redundant header.
    
    The includes were replaced with the semantic patch below and then
    semi-automated removal of duplicated '#include <linux/memblock.h>
    
    @@
    @@
    - #include <linux/bootmem.h>
    + #include <linux/memblock.h>
    
    [sfr@canb.auug.org.au: dma-direct: fix up for the removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181002185342.133d1680@canb.auug.org.au
    [sfr@canb.auug.org.au: powerpc: fix up for removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181005161406.73ef8727@canb.auug.org.au
    [sfr@canb.auug.org.au: x86/kaslr, ACPI/NUMA: fix for linux/bootmem.h removal]
      Link: http://lkml.kernel.org/r/20181008190341.5e396491@canb.auug.org.au
    Link: http://lkml.kernel.org/r/1536927045-23536-30-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index ffe62a7ae19b..bb532aae0d92 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -11,7 +11,6 @@
 #include <linux/crc32.h>
 #include <linux/kernel.h>
 #include <linux/initrd.h>
-#include <linux/bootmem.h>
 #include <linux/memblock.h>
 #include <linux/mutex.h>
 #include <linux/of.h>

commit eb31d559f1e8390195372cd51cfb198da8bc84b9
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:08:04 2018 -0700

    memblock: remove _virt from APIs returning virtual address
    
    The conversion is done using
    
    sed -i 's@memblock_virt_alloc@memblock_alloc@g' \
            $(git grep -l memblock_virt_alloc)
    
    Link: http://lkml.kernel.org/r/1536927045-23536-8-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 4f915cea6f75..ffe62a7ae19b 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -1179,7 +1179,7 @@ int __init __weak early_init_dt_reserve_memory_arch(phys_addr_t base,
 
 static void * __init early_init_dt_alloc_memory_arch(u64 size, u64 align)
 {
-	return memblock_virt_alloc(size, align);
+	return memblock_alloc(size, align);
 }
 
 bool __init early_init_dt_verify(void *params)

commit aca52c39838910605b1063a2243f553aa2a02d5c
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:07:44 2018 -0700

    mm: remove CONFIG_HAVE_MEMBLOCK
    
    All architecures use memblock for early memory management. There is no need
    for the CONFIG_HAVE_MEMBLOCK configuration option.
    
    [rppt@linux.vnet.ibm.com: of/fdt: fixup #ifdefs]
      Link: http://lkml.kernel.org/r/20180919103457.GA20545@rapoport-lnx
    [rppt@linux.vnet.ibm.com: csky: fixups after bootmem removal]
      Link: http://lkml.kernel.org/r/20180926112744.GC4628@rapoport-lnx
    [rppt@linux.vnet.ibm.com: remove stale #else and the code it protects]
      Link: http://lkml.kernel.org/r/1538067825-24835-1-git-send-email-rppt@linux.vnet.ibm.com
    Link: http://lkml.kernel.org/r/1536927045-23536-4-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Tested-by: Jonathan Cameron <jonathan.cameron@huawei.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 76c83c1ffeda..4f915cea6f75 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -1115,7 +1115,6 @@ int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
 	return 1;
 }
 
-#ifdef CONFIG_HAVE_MEMBLOCK
 #ifndef MIN_MEMBLOCK_ADDR
 #define MIN_MEMBLOCK_ADDR	__pa(PAGE_OFFSET)
 #endif
@@ -1178,26 +1177,6 @@ int __init __weak early_init_dt_reserve_memory_arch(phys_addr_t base,
 	return memblock_reserve(base, size);
 }
 
-#else
-void __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)
-{
-	WARN_ON(1);
-}
-
-int __init __weak early_init_dt_mark_hotplug_memory_arch(u64 base, u64 size)
-{
-	return -ENOSYS;
-}
-
-int __init __weak early_init_dt_reserve_memory_arch(phys_addr_t base,
-					phys_addr_t size, bool nomap)
-{
-	pr_err("Reserved memory not supported, ignoring range %pa - %pa%s\n",
-		  &base, &size, nomap ? " (nomap)" : "");
-	return -ENOSYS;
-}
-#endif
-
 static void * __init early_init_dt_alloc_memory_arch(u64 size, u64 align)
 {
 	return memblock_virt_alloc(size, align);

commit 6072cf567a2be7f13fb3522156409ca0e7a27ff9
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Fri Oct 26 15:04:48 2018 -0700

    of: ignore sub-page memory regions
    
    Memory region size is rounded down to page boundary and with sub-page
    region it becomes 0 and there is no point to add an empty region.
    Moreover, when the base is less than PAGE_SIZE we get a bogus size as
    (base + size - 1) evaluates to -1.
    
    8cccffc52694 ("of: check for size < 0 after rounding in
    early_init_dt_add_memory_arch") introduced a test for wrap around for the
    case when base is not page aligned, the same test can be used to ignore
    sub-page region sizes.
    
    Link: http://lkml.kernel.org/r/1533326330-31677-3-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Michal Hocko <mhocko@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 800ad252cf9c..76c83c1ffeda 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -1127,12 +1127,13 @@ void __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)
 {
 	const u64 phys_offset = MIN_MEMBLOCK_ADDR;
 
+	if (size < PAGE_SIZE - (base & ~PAGE_MASK)) {
+		pr_warn("Ignoring memory block 0x%llx - 0x%llx\n",
+			base, base + size);
+		return;
+	}
+
 	if (!PAGE_ALIGNED(base)) {
-		if (size < PAGE_SIZE - (base & ~PAGE_MASK)) {
-			pr_warn("Ignoring memory block 0x%llx - 0x%llx\n",
-				base, base + size);
-			return;
-		}
 		size -= PAGE_SIZE - (base & ~PAGE_MASK);
 		base = PAGE_ALIGN(base);
 	}

commit da653130a9faaf5df18c5f84e7bf5cb5f5d256e4
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Fri Jul 27 15:35:55 2018 +1000

    of/fdt: Remove PPC32 longtrail hack in memory scan
    
    When the OF code was originally made common by Grant in commit
    51975db0b733 ("of/flattree: merge early_init_dt_scan_memory() common
    code") (Feb 2010), the common code inherited a hack to handle
    PPC "longtrail" machines, which had a "memory@0" node with no
    device_type.
    
    That check was then made to only apply to PPC32 in b44aa25d20e2 ("of:
    Handle memory@0 node on PPC32 only") (May 2014).
    
    But according to Paul Mackerras the "longtrail" machines are long
    dead, if they were ever seen in the wild at all. If someone does still
    have one, we can handle this firmware wart in powerpc platform code.
    
    So remove the hack once and for all.
    
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 6da20b9688f7..800ad252cf9c 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -1034,14 +1034,7 @@ int __init early_init_dt_scan_memory(unsigned long node, const char *uname,
 	bool hotpluggable;
 
 	/* We are scanning "memory" nodes only */
-	if (type == NULL) {
-		/*
-		 * The longtrail doesn't have a device_type on the
-		 * /memory node, so look for the node called /memory@0.
-		 */
-		if (!IS_ENABLED(CONFIG_PPC32) || depth != 1 || strcmp(uname, "memory@0") != 0)
-			return 0;
-	} else if (strcmp(type, "memory") != 0)
+	if (type == NULL || strcmp(type, "memory") != 0)
 		return 0;
 
 	reg = of_get_flat_dt_prop(node, "linux,usable-memory", &l);

commit dd709e72cb934eefd44de8d9969097173fbf45dc
Author: Daniel Kurtz <djkurtz@chromium.org>
Date:   Fri Apr 6 17:21:53 2018 -0600

    earlycon: Use a pointer table to fix __earlycon_table stride
    
    Commit 99492c39f39f ("earlycon: Fix __earlycon_table stride") tried to fix
    __earlycon_table stride by forcing the earlycon_id struct alignment to 32
    and asking the linker to 32-byte align the __earlycon_table symbol.  This
    fix was based on commit 07fca0e57fca92 ("tracing: Properly align linker
    defined symbols") which tried a similar fix for the tracing subsystem.
    
    However, this fix doesn't quite work because there is no guarantee that
    gcc will place structures packed into an array format.  In fact, gcc 4.9
    chooses to 64-byte align these structs by inserting additional padding
    between the entries because it has no clue that they are supposed to be in
    an array.  If we are unlucky, the linker will assign symbol
    "__earlycon_table" to a 32-byte aligned address which does not correspond
    to the 64-byte aligned contents of section "__earlycon_table".
    
    To address this same problem, the fix to the tracing system was
    subsequently re-implemented using a more robust table of pointers approach
    by commits:
     3d56e331b653 ("tracing: Replace syscall_meta_data struct array with pointer array")
     654986462939 ("tracepoints: Fix section alignment using pointer array")
     e4a9ea5ee7c8 ("tracing: Replace trace_event struct array with pointer array")
    
    Let's use this same "array of pointers to structs" approach for
    EARLYCON_TABLE.
    
    Fixes: 99492c39f39f ("earlycon: Fix __earlycon_table stride")
    Signed-off-by: Daniel Kurtz <djkurtz@chromium.org>
    Suggested-by: Aaron Durbin <adurbin@chromium.org>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Tested-by: Guenter Roeck <groeck@chromium.org>
    Reviewed-by: Guenter Roeck <groeck@chromium.org>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 84aa9d676375..6da20b9688f7 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -942,7 +942,7 @@ int __init early_init_dt_scan_chosen_stdout(void)
 	int offset;
 	const char *p, *q, *options = NULL;
 	int l;
-	const struct earlycon_id *match;
+	const struct earlycon_id **p_match;
 	const void *fdt = initial_boot_params;
 
 	offset = fdt_path_offset(fdt, "/chosen");
@@ -969,7 +969,10 @@ int __init early_init_dt_scan_chosen_stdout(void)
 		return 0;
 	}
 
-	for (match = __earlycon_table; match < __earlycon_table_end; match++) {
+	for (p_match = __earlycon_table; p_match < __earlycon_table_end;
+	     p_match++) {
+		const struct earlycon_id *match = *p_match;
+
 		if (!match->compatible[0])
 			continue;
 

commit 0fa1c579349fdd90173381712ad78aa99c09d38b
Author: Rob Herring <robh@kernel.org>
Date:   Fri Jan 5 15:32:33 2018 -0600

    of/fdt: use memblock_virt_alloc for early alloc
    
    memblock_virt_alloc() works for both memblock and bootmem, so use it and
    make early_init_dt_alloc_memory_arch a static function. The arches using
    bootmem define early_init_dt_alloc_memory_arch as either:
    
    __alloc_bootmem(size, align, __pa(MAX_DMA_ADDRESS))
    
    or:
    
    alloc_bootmem_align(size, align)
    
    Both of these evaluate to the same thing as does memblock_virt_alloc for
    bootmem. So we can disable the arch specific functions by making
    early_init_dt_alloc_memory_arch static and they can be removed in
    subsequent commits.
    
    Cc: Frank Rowand <frowand.list@gmail.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 7db5353a24c0..84aa9d676375 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -11,6 +11,7 @@
 #include <linux/crc32.h>
 #include <linux/kernel.h>
 #include <linux/initrd.h>
+#include <linux/bootmem.h>
 #include <linux/memblock.h>
 #include <linux/mutex.h>
 #include <linux/of.h>
@@ -1180,14 +1181,6 @@ int __init __weak early_init_dt_reserve_memory_arch(phys_addr_t base,
 	return memblock_reserve(base, size);
 }
 
-/*
- * called from unflatten_device_tree() to bootstrap devicetree itself
- * Architectures can override this definition if memblock isn't used
- */
-void * __init __weak early_init_dt_alloc_memory_arch(u64 size, u64 align)
-{
-	return __va(memblock_alloc(size, align));
-}
 #else
 void __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)
 {
@@ -1206,13 +1199,12 @@ int __init __weak early_init_dt_reserve_memory_arch(phys_addr_t base,
 		  &base, &size, nomap ? " (nomap)" : "");
 	return -ENOSYS;
 }
+#endif
 
-void * __init __weak early_init_dt_alloc_memory_arch(u64 size, u64 align)
+static void * __init early_init_dt_alloc_memory_arch(u64 size, u64 align)
 {
-	WARN_ON(1);
-	return NULL;
+	return memblock_virt_alloc(size, align);
 }
-#endif
 
 bool __init early_init_dt_verify(void *params)
 {

commit af6074fc9aa4b29517375634189ada1869eea598
Author: Rob Herring <robh@kernel.org>
Date:   Wed Dec 27 12:55:14 2017 -0600

    of: Use SPDX license tag for DT files
    
    Convert remaining DT files to use SPDX-License-Identifier tags.
    
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    Reviewed-by: Frank Rowand <frank.rowand@sony.com>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 4675e5ac4d11..7db5353a24c0 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Functions for working with the Flattened Device Tree data format
  *
  * Copyright 2009 Benjamin Herrenschmidt, IBM Corp
  * benh@kernel.crashing.org
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
  */
 
 #define pr_fmt(fmt)	"OF: fdt: " fmt

commit f5d2da67714a48e9d06f27714967630c3d3b28a2
Author: Stephen Boyd <stephen.boyd@linaro.org>
Date:   Fri Oct 13 00:41:29 2017 -0700

    of/fdt: Document detached argument to __unflatten_device_tree()
    
    This wasn't documented.
    
    Signed-off-by: Stephen Boyd <stephen.boyd@linaro.org>
    Reviewed-by: Frank Rowand <frowand.list@gmail.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 2d515b85a198..4675e5ac4d11 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -437,6 +437,7 @@ static int unflatten_dt_nodes(const void *blob,
  * @mynodes: The device_node tree created by the call
  * @dt_alloc: An allocator that provides a virtual address to memory
  * for the resulting tree
+ * @detached: if true set OF_DETACHED on @mynodes
  *
  * Returns NULL on failure or the memory chunk containing the unflattened
  * device tree on success.

commit 77ea8a68c54ede3fd60dadb6a49b597f6eb5aee7
Author: Rob Herring <robh@kernel.org>
Date:   Tue Oct 3 11:07:55 2017 -0500

    of/fdt: skip unflattening of disabled nodes
    
    For static DT usecases, we don't need the disabled nodes and can skip
    unflattening. This saves a significant amount of RAM in memory constrained
    cases. In one example on STM32F469, the RAM usage goes from 118K to 26K.
    
    There are a few cases in the kernel that modify the status property
    dynamically. These all are changes from enabled to disabled, depend on
    OF_DYNAMIC or are not FDT based (PDT based).
    
    Tested-by: Nicolas Pitre <nico@linaro.org>
    Reviewed-by: Frank Rowand <frowand.list@gmail.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index f8c39705418b..2d515b85a198 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -396,6 +396,10 @@ static int unflatten_dt_nodes(const void *blob,
 		if (WARN_ON_ONCE(depth >= FDT_MAX_DEPTH))
 			continue;
 
+		if (!IS_ENABLED(CONFIG_OF_KOBJ) &&
+		    !of_fdt_device_is_available(blob, offset))
+			continue;
+
 		if (!populate_node(blob, offset, &mem, nps[depth],
 				   &nps[depth+1], dryrun))
 			return mem - base;

commit ecc8a96e251dc43d13841bac44fbfa34ec20fc52
Author: Rob Herring <robh@kernel.org>
Date:   Thu Sep 28 19:20:32 2017 -0500

    of/fdt: add of_fdt_device_is_available function
    
    Add an equivalent function to of_device_is_available for flattened DT, and
    convert the one existing open coded occurrence.
    
    Tested-by: Nicolas Pitre <nico@linaro.org>
    Reviewed-by: Frank Rowand <frowand.list@gmail.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 27c535af0be8..f8c39705418b 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -132,6 +132,19 @@ bool of_fdt_is_big_endian(const void *blob, unsigned long node)
 	return false;
 }
 
+static bool of_fdt_device_is_available(const void *blob, unsigned long node)
+{
+	const char *status = fdt_getprop(blob, node, "status", NULL);
+
+	if (!status)
+		return true;
+
+	if (!strcmp(status, "ok") || !strcmp(status, "okay"))
+		return true;
+
+	return false;
+}
+
 /**
  * of_fdt_match - Return true if node matches a list of compatible values
  */
@@ -605,7 +618,6 @@ static int __init __fdt_scan_reserved_mem(unsigned long node, const char *uname,
 					  int depth, void *data)
 {
 	static int found;
-	const char *status;
 	int err;
 
 	if (!found && depth == 1 && strcmp(uname, "reserved-memory") == 0) {
@@ -625,8 +637,7 @@ static int __init __fdt_scan_reserved_mem(unsigned long node, const char *uname,
 		return 1;
 	}
 
-	status = of_get_flat_dt_prop(node, "status", NULL);
-	if (status && strcmp(status, "okay") != 0 && strcmp(status, "ok") != 0)
+	if (!of_fdt_device_is_available(initial_boot_params, node))
 		return 0;
 
 	err = __reserved_mem_reserve_reg(node, uname);

commit a7e4cfb0a7ca4773e7d0dd1d9c018ab27a15360e
Author: Rob Herring <robh@kernel.org>
Date:   Thu Jun 1 18:01:47 2017 -0500

    of/fdt: only store the device node basename in full_name
    
    With dependencies on a statically allocated full path name converted to
    use %pOF format specifier, we can store just the basename of node, and
    the unflattening of the FDT can be simplified.
    
    This commit will affect the remaining users of full_name. After
    analyzing these users, the remaining cases should only change some print
    messages. The main users of full_name are providing a name for struct
    resource. The resource names shouldn't be important other than providing
    /proc/iomem names.
    
    We no longer distinguish between pre and post 0x10 dtb formats as either
    a full path or basename will work. However, less than 0x10 formats have
    been broken since the conversion to use libfdt (and no one has cared).
    The conversion of the unflattening code to be non-recursive also broke
    pre 0x10 formats as the populate_node function would return 0 in that
    case.
    
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index ce30c9a588a4..27c535af0be8 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -266,74 +266,32 @@ static void populate_properties(const void *blob,
 		*pprev = NULL;
 }
 
-static unsigned int populate_node(const void *blob,
-				  int offset,
-				  void **mem,
-				  struct device_node *dad,
-				  unsigned int fpsize,
-				  struct device_node **pnp,
-				  bool dryrun)
+static bool populate_node(const void *blob,
+			  int offset,
+			  void **mem,
+			  struct device_node *dad,
+			  struct device_node **pnp,
+			  bool dryrun)
 {
 	struct device_node *np;
 	const char *pathp;
 	unsigned int l, allocl;
-	int new_format = 0;
 
 	pathp = fdt_get_name(blob, offset, &l);
 	if (!pathp) {
 		*pnp = NULL;
-		return 0;
+		return false;
 	}
 
 	allocl = ++l;
 
-	/* version 0x10 has a more compact unit name here instead of the full
-	 * path. we accumulate the full path size using "fpsize", we'll rebuild
-	 * it later. We detect this because the first character of the name is
-	 * not '/'.
-	 */
-	if ((*pathp) != '/') {
-		new_format = 1;
-		if (fpsize == 0) {
-			/* root node: special case. fpsize accounts for path
-			 * plus terminating zero. root node only has '/', so
-			 * fpsize should be 2, but we want to avoid the first
-			 * level nodes to have two '/' so we use fpsize 1 here
-			 */
-			fpsize = 1;
-			allocl = 2;
-			l = 1;
-			pathp = "";
-		} else {
-			/* account for '/' and path size minus terminal 0
-			 * already in 'l'
-			 */
-			fpsize += l;
-			allocl = fpsize;
-		}
-	}
-
 	np = unflatten_dt_alloc(mem, sizeof(struct device_node) + allocl,
 				__alignof__(struct device_node));
 	if (!dryrun) {
 		char *fn;
 		of_node_init(np);
 		np->full_name = fn = ((char *)np) + sizeof(*np);
-		if (new_format) {
-			/* rebuild full path for new format */
-			if (dad && dad->parent) {
-				strcpy(fn, dad->full_name);
-#ifdef DEBUG
-				if ((strlen(fn) + l + 1) != allocl) {
-					pr_debug("%s: p: %d, l: %d, a: %d\n",
-						pathp, (int)strlen(fn),
-						l, allocl);
-				}
-#endif
-				fn += strlen(fn);
-			}
-			*(fn++) = '/';
-		}
+
 		memcpy(fn, pathp, l);
 
 		if (dad != NULL) {
@@ -355,7 +313,7 @@ static unsigned int populate_node(const void *blob,
 	}
 
 	*pnp = np;
-	return fpsize;
+	return true;
 }
 
 static void reverse_nodes(struct device_node *parent)
@@ -399,7 +357,6 @@ static int unflatten_dt_nodes(const void *blob,
 	struct device_node *root;
 	int offset = 0, depth = 0, initial_depth = 0;
 #define FDT_MAX_DEPTH	64
-	unsigned int fpsizes[FDT_MAX_DEPTH];
 	struct device_node *nps[FDT_MAX_DEPTH];
 	void *base = mem;
 	bool dryrun = !base;
@@ -418,7 +375,6 @@ static int unflatten_dt_nodes(const void *blob,
 		depth = initial_depth = 1;
 
 	root = dad;
-	fpsizes[depth] = dad ? strlen(of_node_full_name(dad)) : 0;
 	nps[depth] = dad;
 
 	for (offset = 0;
@@ -427,11 +383,8 @@ static int unflatten_dt_nodes(const void *blob,
 		if (WARN_ON_ONCE(depth >= FDT_MAX_DEPTH))
 			continue;
 
-		fpsizes[depth+1] = populate_node(blob, offset, &mem,
-						 nps[depth],
-						 fpsizes[depth],
-						 &nps[depth+1], dryrun);
-		if (!fpsizes[depth+1])
+		if (!populate_node(blob, offset, &mem, nps[depth],
+				   &nps[depth+1], dryrun))
 			return mem - base;
 
 		if (!dryrun && nodepp && !*nodepp)

commit dd6ec12f3bf83ca3c4e712a9f35960aec779f6f9
Merge: 21c19bc7ee25 a4485b545e2f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 7 10:37:54 2017 -0700

    Merge tag 'devicetree-for-4.13' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull DeviceTree updates from Rob Herring:
    
     - vsprintf format specifier %pOF for device_node's. This will enable us
       to stop storing the full node names. Conversion of users will happen
       next cycle.
    
     - Update documentation to point to DT specification instead of ePAPR.
    
     - Split out graph and property functions to a separate file.
    
     - New of-graph functions for ALSA
    
     - Add vendor prefixes for RISC-V, Linksys, iWave Systems, Roofull,
       Itead, and BananaPi.
    
     - Improve dtx_diff utility filename printing.
    
    * tag 'devicetree-for-4.13' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (32 commits)
      of: document /sys/firmware/fdt
      dt-bindings: Add RISC-V vendor prefix
      vsprintf: Add %p extension "%pOF" for device tree
      of: find_node_by_full_name rewrite to compare each level
      of: use kbasename instead of open coding
      dt-bindings: thermal: add file extension to brcm,ns-thermal
      of: update ePAPR references to point to Devicetree Specification
      scripts/dtc: dtx_diff - Show real file names in diff header
      of: detect invalid phandle in overlay
      of: be consistent in form of file mode
      of: make __of_attach_node() static
      of: address.c header comment typo
      of: fdt.c header comment typo
      of: make of_fdt_is_compatible() static
      dt-bindings: display-timing.txt convert non-ascii characters to ascii
      Documentation: remove overlay-notes reference to non-existent file
      dt-bindings: usb: exynos-usb: Add missing required VDD properties
      dt-bindings: Add vendor prefix for Linksys
      MAINTAINERS: add device tree ABI documentation file
      of: Add vendor prefix for iWave Systems Technologies Pvt. Ltd
      ...

commit 0ef5adca5b212c705a7c61cf721db223fafecf07
Author: Frank Rowand <frank.rowand@sony.com>
Date:   Tue Jun 20 16:46:28 2017 -0700

    of: fdt.c header comment typo
    
    Fix typo in header comment for early_init_dt_scan_memory()
    
    Signed-off-by: Frank Rowand <frank.rowand@sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 5c71cb933426..3361b5b34ee4 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -1050,7 +1050,7 @@ u64 __init dt_mem_next_cell(int s, const __be32 **cellp)
 }
 
 /**
- * early_init_dt_scan_memory - Look for an parse memory nodes
+ * early_init_dt_scan_memory - Look for and parse memory nodes
  */
 int __init early_init_dt_scan_memory(unsigned long node, const char *uname,
 				     int depth, void *data)

commit 92af08990cc49408119ca2549dfe9e37235864d8
Author: Frank Rowand <frank.rowand@sony.com>
Date:   Tue Jun 20 16:38:28 2017 -0700

    of: make of_fdt_is_compatible() static
    
    The callers of of_fdt_is_compatible() are all in fdt.c so
    make it static.
    
    Signed-off-by: Frank Rowand <frank.rowand@sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 3080d9dd031d..5c71cb933426 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -91,7 +91,7 @@ void of_fdt_limit_memory(int limit)
  * On match, returns a non-zero value with smaller values returned for more
  * specific compatible values.
  */
-int of_fdt_is_compatible(const void *blob,
+static int of_fdt_is_compatible(const void *blob,
 		      unsigned long node, const char *compat)
 {
 	const char *cp;

commit 1fbbed4137de93e02fc62776b8bf08a2d9ae1141
Merge: f538a82c075b 49e67dd17649
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 19 15:03:24 2017 -0700

    Merge tag 'devicetree-fixes-for-4.12' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull DeviceTree fixes from Rob Herring:
    
     - fix missing allocation failure handling in fdt code
    
     - fix dtc compile error on 32-bit hosts
    
     - revert bad sparse changes causing GCC7 warnings
    
    * tag 'devicetree-fixes-for-4.12' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux:
      of: fdt: add missing allocation-failure check
      dtc: check.c fix compile error
      Partially Revert "of: fix sparse warnings in fdt, irq, reserved mem, and resolver code"

commit 49e67dd17649b60b4d54966e18ec9c80198227f0
Author: Johan Hovold <johan@kernel.org>
Date:   Wed May 17 17:29:09 2017 +0200

    of: fdt: add missing allocation-failure check
    
    The memory allocator passed to __unflatten_device_tree() (e.g. a wrapped
    kzalloc) can fail so add the missing sanity check to avoid dereferencing
    a NULL pointer.
    
    Fixes: fe14042358fa ("of/flattree: Refactor unflatten_device_tree and add fdt_unflatten_tree")
    Cc: stable <stable@vger.kernel.org>     # 2.6.38
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index a0972219ccfc..0373ae49d24d 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -507,6 +507,9 @@ void *__unflatten_device_tree(const void *blob,
 
 	/* Allocate memory for the expanded device tree */
 	mem = dt_alloc(size + 4, __alignof__(struct device_node));
+	if (!mem)
+		return NULL;
+
 	memset(mem, 0, size);
 
 	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);

commit dc2a24816637ff6c60f08c4245aba01c6e9b6a79
Merge: ac3c4aa248c5 5a61ef74f269
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 12 10:04:09 2017 -0700

    Merge tag 'powerpc-4.12-2' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux
    
    Pull more powerpc updates from Michael Ellerman:
     "The change to the Linux page table geometry was delayed for more
      testing with 16G pages, and there's the new CPU features stuff which
      just needed one more polish before going in. Plus a few changes from
      Scott which came in a bit late. And then various fixes, mostly minor.
    
      Summary highlights:
    
       - rework the Linux page table geometry to lower memory usage on
         64-bit Book3S (IBM chips) using the Hash MMU.
    
       - support for a new device tree binding for discovering CPU features
         on future firmwares.
    
       - Freescale updates from Scott:
          "Includes a fix for a powerpc/next mm regression on 64e, a fix for
           a kernel hang on 64e when using a debugger inside a relocated
           kernel, a qman fix, and misc qe improvements."
    
      Thanks to: Christophe Leroy, Gavin Shan, Horia Geantă, LiuHailong,
      Nicholas Piggin, Roy Pledge, Scott Wood, Valentin Longchamp"
    
    * tag 'powerpc-4.12-2' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux:
      powerpc/64s: Support new device tree binding for discovering CPU features
      powerpc: Don't print cpu_spec->cpu_name if it's NULL
      of/fdt: introduce of_scan_flat_dt_subnodes and of_get_flat_dt_phandle
      powerpc/64s: Fix unnecessary machine check handler relocation branch
      powerpc/mm/book3s/64: Rework page table geometry for lower memory usage
      powerpc: Fix distclean with Makefile.postlink
      powerpc/64e: Don't place the stack beyond TASK_SIZE
      powerpc/powernv: Block PCI config access on BCM5718 during EEH recovery
      powerpc/8xx: Adding support of IRQ in MPC8xx GPIO
      soc/fsl/qbman: Disable IRQs for deferred QBMan work
      soc/fsl/qe: add EXPORT_SYMBOL for the 2 qe_tdm functions
      soc/fsl/qe: only apply QE_General4 workaround on affected SoCs
      soc/fsl/qe: round brg_freq to 1kHz granularity
      soc/fsl/qe: get rid of immrbar_virt_to_phys()
      net: ethernet: ucc_geth: fix MEM_PART_MURAM mode
      powerpc/64e: Fix hang when debugging programs with relocated kernel

commit ea47dd191d543f81e0912b5dc0471b48346b016e
Author: Nicholas Piggin <npiggin@gmail.com>
Date:   Wed Apr 19 05:12:18 2017 +1000

    of/fdt: introduce of_scan_flat_dt_subnodes and of_get_flat_dt_phandle
    
    Introduce primitives for FDT parsing. These will be used for powerpc
    cpufeatures node scanning, which has quite complex structure but should
    be processed early.
    
    Cc: devicetree@vger.kernel.org
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index e5ce4b59e162..961ca97072a9 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -753,6 +753,36 @@ int __init of_scan_flat_dt(int (*it)(unsigned long node,
 	return rc;
 }
 
+/**
+ * of_scan_flat_dt_subnodes - scan sub-nodes of a node call callback on each.
+ * @it: callback function
+ * @data: context data pointer
+ *
+ * This function is used to scan sub-nodes of a node.
+ */
+int __init of_scan_flat_dt_subnodes(unsigned long parent,
+				    int (*it)(unsigned long node,
+					      const char *uname,
+					      void *data),
+				    void *data)
+{
+	const void *blob = initial_boot_params;
+	int node;
+
+	fdt_for_each_subnode(node, blob, parent) {
+		const char *pathp;
+		int rc;
+
+		pathp = fdt_get_name(blob, node, NULL);
+		if (*pathp == '/')
+			pathp = kbasename(pathp);
+		rc = it(node, pathp, data);
+		if (rc)
+			return rc;
+	}
+	return 0;
+}
+
 /**
  * of_get_flat_dt_subnode_by_name - get the subnode by given name
  *
@@ -812,6 +842,14 @@ int __init of_flat_dt_match(unsigned long node, const char *const *compat)
 	return of_fdt_match(initial_boot_params, node, compat);
 }
 
+/**
+ * of_get_flat_dt_prop - Given a node in the flat blob, return the phandle
+ */
+uint32_t __init of_get_flat_dt_phandle(unsigned long node)
+{
+	return fdt_get_phandle(initial_boot_params, node);
+}
+
 struct fdt_scan_status {
 	const char *name;
 	int namelen;

commit 17a70355ea576843a7ac851f1db26872a50b2850
Author: Rob Herring <robh@kernel.org>
Date:   Thu May 4 12:56:12 2017 -0500

    of: fix sparse warnings in fdt, irq, reserved mem, and resolver code
    
    sparse generates the following warnings in drivers/of/:
    
    ../drivers/of/fdt.c:63:36: warning: cast to restricted __be32
    ../drivers/of/fdt.c:68:33: warning: cast to restricted __be32
    ../drivers/of/irq.c:105:88: warning: incorrect type in initializer (different base types)
    ../drivers/of/irq.c:105:88:    expected restricted __be32
    ../drivers/of/irq.c:105:88:    got int
    ../drivers/of/irq.c:526:35: warning: incorrect type in assignment (different modifiers)
    ../drivers/of/irq.c:526:35:    expected int ( *const [usertype] irq_init_cb )( ... )
    ../drivers/of/irq.c:526:35:    got void const *const data
    ../drivers/of/of_reserved_mem.c:200:50: warning: incorrect type in initializer (different modifiers)
    ../drivers/of/of_reserved_mem.c:200:50:    expected int ( *[usertype] initfn )( ... )
    ../drivers/of/of_reserved_mem.c:200:50:    got void const *const data
    ../drivers/of/resolver.c:95:42: warning: incorrect type in assignment (different base types)
    ../drivers/of/resolver.c:95:42:    expected unsigned int [unsigned] [usertype] <noident>
    ../drivers/of/resolver.c:95:42:    got restricted __be32 [usertype] <noident>
    
    All these are harmless type mismatches fixed by adjusting the types.
    
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index e33f7818bc6c..a0972219ccfc 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -48,8 +48,8 @@ void of_fdt_limit_memory(int limit)
 	const void *val;
 	int nr_address_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;
 	int nr_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
-	const uint32_t *addr_prop;
-	const uint32_t *size_prop;
+	const __be32 *addr_prop;
+	const __be32 *size_prop;
 	int root_offset;
 	int cell_size;
 

commit 81d0848fc8d2058c4cc645d971435c889869433b
Author: Frank Rowand <frank.rowand@sony.com>
Date:   Tue Apr 25 17:09:54 2017 -0700

    of: Add unit tests for applying overlays
    
    Existing overlay unit tests examine individual pieces of the overlay
    code.  The new tests target the entire process of applying an overlay.
    
    Signed-off-by: Frank Rowand <frank.rowand@sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index e5ce4b59e162..e33f7818bc6c 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -31,6 +31,8 @@
 #include <asm/setup.h>  /* for COMMAND_LINE_SIZE */
 #include <asm/page.h>
 
+#include "of_private.h"
+
 /*
  * of_fdt_limit_memory - limit the number of regions in the /memory node
  * @limit: maximum entries
@@ -469,11 +471,11 @@ static int unflatten_dt_nodes(const void *blob,
  * Returns NULL on failure or the memory chunk containing the unflattened
  * device tree on success.
  */
-static void *__unflatten_device_tree(const void *blob,
-				     struct device_node *dad,
-				     struct device_node **mynodes,
-				     void *(*dt_alloc)(u64 size, u64 align),
-				     bool detached)
+void *__unflatten_device_tree(const void *blob,
+			      struct device_node *dad,
+			      struct device_node **mynodes,
+			      void *(*dt_alloc)(u64 size, u64 align),
+			      bool detached)
 {
 	int size;
 	void *mem;
@@ -1261,6 +1263,8 @@ void __init unflatten_device_tree(void)
 
 	/* Get pointer to "/chosen" and "/aliases" nodes for use everywhere */
 	of_alias_scan(early_init_dt_alloc_memory_arch);
+
+	unittest_unflatten_overlay_base();
 }
 
 /**

commit be5165a51d2500ae1afa1236a8b09858831fdf7e
Merge: c1aac62f36c1 4e29ccdb240e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Feb 22 19:23:14 2017 -0800

    Merge tag 'devicetree-for-4.11' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull DeviceTree updates from Rob Herring:
     "Pretty standard stuff with dtc upstream sync being the biggest piece.
    
       - Sync dtc to upstream commit 0931cea3ba20. This picks up overlay
         support in dtc.
    
       - Set dma_ops for reserved memory users.
    
       - Make references to IOMMU consistent in DT bindings.
    
       - Cleanup references to pm_power_off in bindings.
    
       - Move some display bindings that snuck into the old bindings/video/
         path.
    
       - Fix some wrong documentation paths caused from binding
         restructuring.
    
       - Vendor prefixes for Faraday and Fujitsu.
    
       - Fix an of_node ref counting leak in of_find_node_opts_by_path
    
       - Introduce new graph helper of_graph_get_remote_node() which will be
         used by DRM drivers in 4.12"
    
    * tag 'devicetree-for-4.11' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (27 commits)
      DT: add Faraday Tec. as vendor
      of: introduce of_graph_get_remote_node
      of: Add missing space at end of pr_fmt().
      of: make of_device_make_bus_id() static
      of: fix of_node leak caused in of_find_node_opts_by_path
      dt-bindings: net: remove reference to fixed link support
      dt-bindings: power: reset: qnap-poweroff: Drop reference to pm_power_off
      dt-bindings: power: reset: gpio-poweroff: Drop reference to pm_power_off
      dt-bindings: mfd: as3722: Drop reference to pm_power_off
      dt-bindings: display: move ANX7814 and SiI8620 bridge bindings
      of/unittest: Swap arguments of of_unittest_apply_overlay()
      Documentation: usb: fix wrong documentation paths
      serial: fsl-imx-uart.txt: Remove generic property
      devicetree: Add Fujitsu Ltd. vendor prefix
      Documentation: display: fix wrong documentation paths
      of: remove redundant memset in overlay
      bus:qcom : Fix typo in qcom,ebi2.txt
      dt-bindings: qman: Remove pool channel node
      Documentation: panel-dpi: fix path to display-timing.txt
      devicetree: bindings: clk: mvebu: fix description for sata1 on Armada XP
      ...

commit bd0096d7467fbfa723cb1c12011098abf16de525
Author: Frank Rowand <frank.rowand@am.sony.com>
Date:   Mon Oct 17 12:21:23 2016 -0700

    of: Add missing space at end of pr_fmt().
    
    Make pr_fmt() in fdt.c consistent with all other files in drivers/of/
    
    Signed-off-by: Frank Rowand <frank.rowand@am.sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index c9b5cac03b36..4ae68bc50677 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -9,7 +9,7 @@
  * version 2 as published by the Free Software Foundation.
  */
 
-#define pr_fmt(fmt)	"OF: fdt:" fmt
+#define pr_fmt(fmt)	"OF: fdt: " fmt
 
 #include <linux/crc32.h>
 #include <linux/kernel.h>

commit 3ec754410cb3e931a6c4920b1a150f21a94a2bf4
Author: Tobias Wolf <dev-NTEO@vplace.de>
Date:   Wed Nov 23 10:40:07 2016 +0100

    of: Add check to of_scan_flat_dt() before accessing initial_boot_params
    
    An empty __dtb_start to __dtb_end section might result in
    initial_boot_params being null for arch/mips/ralink. This showed that the
    boot process hangs indefinitely in of_scan_flat_dt().
    
    Signed-off-by: Tobias Wolf <dev-NTEO@vplace.de>
    Cc: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/14605/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index c9b5cac03b36..82967b07f7be 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -738,9 +738,12 @@ int __init of_scan_flat_dt(int (*it)(unsigned long node,
 	const char *pathp;
 	int offset, rc = 0, depth = -1;
 
-        for (offset = fdt_next_node(blob, -1, &depth);
-             offset >= 0 && depth >= 0 && !rc;
-             offset = fdt_next_node(blob, offset, &depth)) {
+	if (!blob)
+		return 0;
+
+	for (offset = fdt_next_node(blob, -1, &depth);
+	     offset >= 0 && depth >= 0 && !rc;
+	     offset = fdt_next_node(blob, offset, &depth)) {
 
 		pathp = fdt_get_name(blob, offset, NULL);
 		if (*pathp == '/')

commit 41a9ada3e6b4253f1a3ce42699c6aaeb8584306c
Author: Reza Arbab <arbab@linux.vnet.ibm.com>
Date:   Mon Dec 12 16:43:02 2016 -0800

    of/fdt: mark hotpluggable memory
    
    When movable nodes are enabled, any node containing only hotpluggable
    memory is made movable at boot time.
    
    On x86, hotpluggable memory is discovered by parsing the ACPI SRAT,
    making corresponding calls to memblock_mark_hotplug().
    
    If we introduce a dt property to describe memory as hotpluggable,
    configs supporting early fdt may then also do this marking and use
    movable nodes.
    
    Link: http://lkml.kernel.org/r/1479160961-25840-5-git-send-email-arbab@linux.vnet.ibm.com
    Signed-off-by: Reza Arbab <arbab@linux.vnet.ibm.com>
    Tested-by: Balbir Singh <bsingharora@gmail.com>
    Acked-by: Balbir Singh <bsingharora@gmail.com>
    Cc: "Aneesh Kumar K.V" <aneesh.kumar@linux.vnet.ibm.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Alistair Popple <apopple@au1.ibm.com>
    Cc: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Bharata B Rao <bharata@linux.vnet.ibm.com>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Nathan Fontenot <nfont@linux.vnet.ibm.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Stewart Smith <stewart@linux.vnet.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index c89d5d231a0e..c9b5cac03b36 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -1015,6 +1015,7 @@ int __init early_init_dt_scan_memory(unsigned long node, const char *uname,
 	const char *type = of_get_flat_dt_prop(node, "device_type", NULL);
 	const __be32 *reg, *endp;
 	int l;
+	bool hotpluggable;
 
 	/* We are scanning "memory" nodes only */
 	if (type == NULL) {
@@ -1034,6 +1035,7 @@ int __init early_init_dt_scan_memory(unsigned long node, const char *uname,
 		return 0;
 
 	endp = reg + (l / sizeof(__be32));
+	hotpluggable = of_get_flat_dt_prop(node, "hotpluggable", NULL);
 
 	pr_debug("memory scan node %s, reg size %d,\n", uname, l);
 
@@ -1049,6 +1051,13 @@ int __init early_init_dt_scan_memory(unsigned long node, const char *uname,
 		    (unsigned long long)size);
 
 		early_init_dt_add_memory_arch(base, size);
+
+		if (!hotpluggable)
+			continue;
+
+		if (early_init_dt_mark_hotplug_memory_arch(base, size))
+			pr_warn("failed to mark hotplug range 0x%llx - 0x%llx\n",
+				base, base + size);
 	}
 
 	return 0;
@@ -1146,6 +1155,11 @@ void __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)
 	memblock_add(base, size);
 }
 
+int __init __weak early_init_dt_mark_hotplug_memory_arch(u64 base, u64 size)
+{
+	return memblock_mark_hotplug(base, size);
+}
+
 int __init __weak early_init_dt_reserve_memory_arch(phys_addr_t base,
 					phys_addr_t size, bool nomap)
 {
@@ -1168,6 +1182,11 @@ void __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)
 	WARN_ON(1);
 }
 
+int __init __weak early_init_dt_mark_hotplug_memory_arch(u64 base, u64 size)
+{
+	return -ENOSYS;
+}
+
 int __init __weak early_init_dt_reserve_memory_arch(phys_addr_t base,
 					phys_addr_t size, bool nomap)
 {

commit d503187b6cc4e41c21c02e695e0e7b5acdd066de
Author: Leif Lindholm <leif.lindholm@linaro.org>
Date:   Tue Sep 27 23:54:12 2016 +0300

    of/serial: move earlycon early_param handling to serial
    
    We have multiple "earlycon" early_param handlers - merge the DT one into
    the main earlycon one.  It's a cleanup that also will be useful
    to defer setting up DT console until ACPI/DT decision is made.
    
    Rename the exported function to avoid clashing with the function from
    arch/microblaze/kernel/prom.c
    
    Signed-off-by: Leif Lindholm <leif.lindholm@linaro.org>
    Signed-off-by: Aleksey Makarov <aleksey.makarov@linaro.org>
    Acked-by: Rob Herring <robh@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Peter Hurley <peter@hurleysoftware.com>
    Tested-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Tested-by: Christopher Covington <cov@codeaurora.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 085c6389afd1..c89d5d231a0e 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -924,7 +924,7 @@ static inline void early_init_dt_check_for_initrd(unsigned long node)
 
 #ifdef CONFIG_SERIAL_EARLYCON
 
-static int __init early_init_dt_scan_chosen_serial(void)
+int __init early_init_dt_scan_chosen_stdout(void)
 {
 	int offset;
 	const char *p, *q, *options = NULL;
@@ -968,15 +968,6 @@ static int __init early_init_dt_scan_chosen_serial(void)
 	}
 	return -ENODEV;
 }
-
-static int __init setup_of_earlycon(char *buf)
-{
-	if (buf)
-		return 0;
-
-	return early_init_dt_scan_chosen_serial();
-}
-early_param("earlycon", setup_of_earlycon);
 #endif
 
 /**

commit 89c67752ae4dedc1244344b266c837ddb4053ebd
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Mon Aug 1 17:17:53 2016 +1000

    drivers/of: Validate device node in __unflatten_device_tree()
    
    @mynodes is set to NULL when __unflatten_device_tree() is called
    to unflatten device sub-tree in PCI hot add scenario on PowerPC
    PowerNV platform. Marking @mynodes detached unconditionally causes
    kernel crash as below backtrace shows:
    
    Unable to handle kernel paging request for data at address 0x00000000
    Faulting instruction address: 0xc000000000b26f64
    cpu 0x0: Vector: 300 (Data Access) at [c000003fcc7cf740]
        pc: c000000000b26f64: __unflatten_device_tree+0xf4/0x190
        lr: c000000000b26f40: __unflatten_device_tree+0xd0/0x190
        sp: c000003fcc7cf9c0
       msr: 900000000280b033
       dar: 0
     dsisr: 40000000
      current = 0xc000003fcc281680
      paca    = 0xc00000000ff00000   softe: 0        irq_happened: 0x01
        pid   = 2724, comm = sh
    Linux version 4.7.0-gavin-07754-g92a6836 (gwshan@gwshan) (gcc version \
    4.9.3 (Buildroot 2016.02-rc2-00093-g5ea3bce) ) #539 SMP Mon Aug 1 \
    12:40:29 AEST 2016
    enter ? for help
    [c000003fcc7cfa50] c000000000b27060 of_fdt_unflatten_tree+0x60/0x90
    [c000003fcc7cfaa0] c0000000004c6288 pnv_php_set_slot_power_state+0x118/0x440
    [c000003fcc7cfb80] c0000000004c6a10 pnv_php_enable+0xc0/0x170
    [c000003fcc7cfbd0] c0000000004c4d80 power_write_file+0xa0/0x190
    [c000003fcc7cfc50] c0000000004be93c pci_slot_attr_store+0x3c/0x60
    [c000003fcc7cfc70] c0000000002d3fd4 sysfs_kf_write+0x94/0xc0
    [c000003fcc7cfcb0] c0000000002d2c30 kernfs_fop_write+0x180/0x260
    [c000003fcc7cfd00] c000000000230fe0 __vfs_write+0x40/0x190
    [c000003fcc7cfd90] c000000000232278 vfs_write+0xc8/0x240
    [c000003fcc7cfde0] c000000000233d90 SyS_write+0x60/0x110
    [c000003fcc7cfe30] c000000000009524 system_call+0x38/0x108
    
    This avoids the kernel crash by marking @mynodes detached only when
    @mynodes is dereferencing valid device node in __unflatten_device_tree().
    
    Fixes: 1d1bde550ea3 ("of: fdt: mark unflattened tree as detached")
    Reported-by: Meng Li <shlimeng@cn.ibm.com>
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 55f1b8391149..085c6389afd1 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -517,7 +517,7 @@ static void *__unflatten_device_tree(const void *blob,
 		pr_warning("End of tree marker overwritten: %08x\n",
 			   be32_to_cpup(mem + size));
 
-	if (detached) {
+	if (detached && mynodes) {
 		of_node_set_flag(*mynodes, OF_DETACHED);
 		pr_debug("unflattened tree is detached\n");
 	}

commit f64d6e2aaa79f0ad588fd7ad595a0a8eb8f04645
Merge: 1056c9bd2702 099c0cbd2025
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 30 11:32:01 2016 -0700

    Merge tag 'devicetree-for-4.8' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull DeviceTree updates from Rob Herring:
    
     - remove most of_platform_populate() calls in arch code.  Now the DT
       core code calls it in the default case and platforms only need to
       call it if they have special needs
    
     - use pr_fmt on all the DT core print statements
    
     - CoreSight binding doc improvements to block name descriptions
    
     - add dt_to_config script which can parse dts files and list
       corresponding kernel config options
    
     - fix memory leak hit with a PowerMac DT
    
     - correct a bunch of STMicro compatible strings to use the correct
       vendor prefix
    
     - fix DA9052 PMIC binding doc to match what is actually used in dts
       files
    
    * tag 'devicetree-for-4.8' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (35 commits)
      documentation: da9052: Update regulator bindings names to match DA9052/53 DTS expectations
      xtensa: Partially Revert "xtensa: Remove unnecessary of_platform_populate with default match table"
      xtensa: Fix build error due to missing include file
      MIPS: ath79: Add missing include file
      Fix spelling errors in Documentation/devicetree
      ARM: dts: fix STMicroelectronics compatible strings
      powerpc/dts: fix STMicroelectronics compatible strings
      Documentation: dt: i2c: use correct STMicroelectronics vendor prefix
      scripts/dtc: dt_to_config - kernel config options for a devicetree
      of: fdt: mark unflattened tree as detached
      of: overlay: add resolver error prints
      coresight: document binding acronyms
      Documentation/devicetree: document cavium-pip rx-delay/tx-delay properties
      of: use pr_fmt prefix for all console printing
      of/irq: Mark initialised interrupt controllers as populated
      of: fix memory leak related to safe_name()
      Revert "of/platform: export of_default_bus_match_table"
      of: unittest: use of_platform_default_populate() to populate default bus
      memory: omap-gpmc: use of_platform_default_populate() to populate default bus
      bus: uniphier-system-bus: use of_platform_default_populate() to populate default bus
      ...

commit 1d1bde550ea3b08a95bd9b6b3adb6d7cd3781870
Author: Michal Suchanek <hramrach@gmail.com>
Date:   Tue Jul 19 00:01:12 2016 +0200

    of: fdt: mark unflattened tree as detached
    
    The tree returned from of_fdt_unflatten_tree cannot be attached to the
    live tree because it is not marked as detached so mark it as such. The
    dt resolver checks the flag and refuses to process the tree otherwise.
    
    Signed-off-by: Michal Suchanek <hramrach@gmail.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index a0a7b76be381..ae4d07bcce24 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -472,7 +472,8 @@ static int unflatten_dt_nodes(const void *blob,
 static void *__unflatten_device_tree(const void *blob,
 				     struct device_node *dad,
 				     struct device_node **mynodes,
-				     void *(*dt_alloc)(u64 size, u64 align))
+				     void *(*dt_alloc)(u64 size, u64 align),
+				     bool detached)
 {
 	int size;
 	void *mem;
@@ -516,6 +517,11 @@ static void *__unflatten_device_tree(const void *blob,
 		pr_warning("End of tree marker overwritten: %08x\n",
 			   be32_to_cpup(mem + size));
 
+	if (detached) {
+		of_node_set_flag(*mynodes, OF_DETACHED);
+		pr_debug("unflattened tree is detached\n");
+	}
+
 	pr_debug(" <- unflatten_device_tree()\n");
 	return mem;
 }
@@ -548,7 +554,8 @@ void *of_fdt_unflatten_tree(const unsigned long *blob,
 	void *mem;
 
 	mutex_lock(&of_fdt_unflatten_mutex);
-	mem = __unflatten_device_tree(blob, dad, mynodes, &kernel_tree_alloc);
+	mem = __unflatten_device_tree(blob, dad, mynodes, &kernel_tree_alloc,
+				      true);
 	mutex_unlock(&of_fdt_unflatten_mutex);
 
 	return mem;
@@ -1224,7 +1231,7 @@ bool __init early_init_dt_scan(void *params)
 void __init unflatten_device_tree(void)
 {
 	__unflatten_device_tree(initial_boot_params, NULL, &of_root,
-				early_init_dt_alloc_memory_arch);
+				early_init_dt_alloc_memory_arch, false);
 
 	/* Get pointer to "/chosen" and "/aliases" nodes for use everywhere */
 	of_alias_scan(early_init_dt_alloc_memory_arch);

commit 606ad42aa3b1fe8bb122305bef5aea79a6cef54b
Author: Rob Herring <robh@kernel.org>
Date:   Wed Jun 15 08:32:18 2016 -0500

    of: use pr_fmt prefix for all console printing
    
    Clean-up all the DT printk functions to use common pr_fmt prefix.
    
    Some print statements such as kmalloc errors were redundant, so just
    drop those.
    
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    Reviewed-by: Frank Rowand <frank.rowand@am.sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 33daffc4392c..a0a7b76be381 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -9,6 +9,8 @@
  * version 2 as published by the Free Software Foundation.
  */
 
+#define pr_fmt(fmt)	"OF: fdt:" fmt
+
 #include <linux/crc32.h>
 #include <linux/kernel.h>
 #include <linux/initrd.h>
@@ -182,14 +184,12 @@ static void populate_properties(const void *blob,
 
 		val = fdt_getprop_by_offset(blob, cur, &pname, &sz);
 		if (!val) {
-			pr_warn("%s: Cannot locate property at 0x%x\n",
-				__func__, cur);
+			pr_warn("Cannot locate property at 0x%x\n", cur);
 			continue;
 		}
 
 		if (!pname) {
-			pr_warn("%s: Cannot find property name at 0x%x\n",
-				__func__, cur);
+			pr_warn("Cannot find property name at 0x%x\n", cur);
 			continue;
 		}
 
@@ -439,7 +439,7 @@ static int unflatten_dt_nodes(const void *blob,
 	}
 
 	if (offset < 0 && offset != -FDT_ERR_NOTFOUND) {
-		pr_err("%s: Error %d processing FDT\n", __func__, offset);
+		pr_err("Error %d processing FDT\n", offset);
 		return -EINVAL;
 	}
 
@@ -1281,7 +1281,7 @@ static int __init of_fdt_raw_init(void)
 
 	if (of_fdt_crc32 != crc32_be(~0, initial_boot_params,
 				     fdt_totalsize(initial_boot_params))) {
-		pr_warn("fdt: not creating '/sys/firmware/fdt': CRC check failed\n");
+		pr_warn("not creating '/sys/firmware/fdt': CRC check failed\n");
 		return 0;
 	}
 	of_fdt_raw_attr.size = fdt_totalsize(initial_boot_params);

commit 9c6098685a1d5df72da61ff7838ebb1524796869
Author: Shannon Zhao <shannon.zhao@linaro.org>
Date:   Thu Apr 7 20:03:33 2016 +0800

    FDT: Add a helper to get the subnode by given name
    
    Sometimes it needs to check if there is a subnode of given node in FDT
    by given name. Introduce this helper to get the subnode if it exists.
    
    CC: Rob Herring <robh@kernel.org>
    Signed-off-by: Shannon Zhao <shannon.zhao@linaro.org>
    Acked-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Tested-by: Julien Grall <julien.grall@arm.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 33daffc4392c..0e02947a8a7a 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -743,6 +743,19 @@ int __init of_scan_flat_dt(int (*it)(unsigned long node,
 	return rc;
 }
 
+/**
+ * of_get_flat_dt_subnode_by_name - get the subnode by given name
+ *
+ * @node: the parent node
+ * @uname: the name of subnode
+ * @return offset of the subnode, or -FDT_ERR_NOTFOUND if there is none
+ */
+
+int of_get_flat_dt_subnode_by_name(unsigned long node, const char *uname)
+{
+	return fdt_subnode_offset(initial_boot_params, node, uname);
+}
+
 /**
  * of_get_flat_dt_root - find the root node in the flat blob
  */

commit 8c237cd0ccb570d13158758af02e11359a4a5b1c
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Thu Jun 9 15:50:49 2016 +1000

    drivers/of: Fix depth for sub-tree blob in unflatten_dt_nodes()
    
    The function is unflattening device sub-tree blob if @dad passed to
    the function is valid. Currently, this functionality is used by PPC
    PowerNV PCI hotplug driver only. There are possibly multiple nodes
    in the first level of depth, fdt_next_node() bails immediately when
    @depth becomes negative before the second device node can be probed
    successfully. It leads to the device nodes except the first one won't
    be unflattened successfully.
    
    This fixes the issue by setting the initial depth (@inital_depth) to
    1 when this function is called to unflatten device sub-tree blob. No
    logic changes when this function is used to unflatten non-sub-tree
    blob.
    
    Cc: Rhyland Klein <rklein@nvidia.com>
    Fixes: 78c44d910 ("drivers/of: Fix depth when unflattening devicetree")
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Tested-by: Rhyland Klein <rklein@nvidia.com>
    Tested-by: Andrew Donnellan <andrew.donnellan@au1.ibm.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 14f2f8c7c260..33daffc4392c 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -395,7 +395,7 @@ static int unflatten_dt_nodes(const void *blob,
 			      struct device_node **nodepp)
 {
 	struct device_node *root;
-	int offset = 0, depth = 0;
+	int offset = 0, depth = 0, initial_depth = 0;
 #define FDT_MAX_DEPTH	64
 	unsigned int fpsizes[FDT_MAX_DEPTH];
 	struct device_node *nps[FDT_MAX_DEPTH];
@@ -405,11 +405,22 @@ static int unflatten_dt_nodes(const void *blob,
 	if (nodepp)
 		*nodepp = NULL;
 
+	/*
+	 * We're unflattening device sub-tree if @dad is valid. There are
+	 * possibly multiple nodes in the first level of depth. We need
+	 * set @depth to 1 to make fdt_next_node() happy as it bails
+	 * immediately when negative @depth is found. Otherwise, the device
+	 * nodes except the first one won't be unflattened successfully.
+	 */
+	if (dad)
+		depth = initial_depth = 1;
+
 	root = dad;
 	fpsizes[depth] = dad ? strlen(of_node_full_name(dad)) : 0;
 	nps[depth] = dad;
+
 	for (offset = 0;
-	     offset >= 0 && depth >= 0;
+	     offset >= 0 && depth >= initial_depth;
 	     offset = fdt_next_node(blob, offset, &depth)) {
 		if (WARN_ON_ONCE(depth >= FDT_MAX_DEPTH))
 			continue;

commit dddc33e50a074152d0ba447dcaa6184b19dffab2
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Fri May 13 21:31:39 2016 +1000

    drivers/of: Fix build warning in populate_node()
    
    Function populate_node() is used to unflatten FDT blob to device
    tree. It supports maximal 64 level of device nodes. There is one
    array @fpsizes[64] tracking the full name length of last unflattened
    device node in the corresponding level (index of element in the
    array - 1). Build warning is seen with CONFIG_FRAME_WARN=1024 like
    below on ARM64 as Geert reported. The issue can be reproduced on
    PPC64 as well.
    
      $ make drivers/of/fdt.o
      drivers/of/fdt.c:443:1: warning: the frame size of 1136 bytes is \
      larger than 1024 bytes [-Wframe-larger-than=]
    
    This changes the data type of @fpsizes[i] from "unsigned long" to
    "unsigned int" to avoid the build warning. The return value type
    of populate_node() and its @fpsize argument is adjusted accordingly.
    With this applied, 256 bytes saved from the stack frame on ARM64 and
    PPC64 platforms and the above warning isn't seen.
    
    Fixes: 50800082f176 ("drivers/of: Avoid recursively calling unflatten_dt_node()")
    Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index b352f67d710b..14f2f8c7c260 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -264,13 +264,13 @@ static void populate_properties(const void *blob,
 		*pprev = NULL;
 }
 
-static unsigned long populate_node(const void *blob,
-				   int offset,
-				   void **mem,
-				   struct device_node *dad,
-				   unsigned long fpsize,
-				   struct device_node **pnp,
-				   bool dryrun)
+static unsigned int populate_node(const void *blob,
+				  int offset,
+				  void **mem,
+				  struct device_node *dad,
+				  unsigned int fpsize,
+				  struct device_node **pnp,
+				  bool dryrun)
 {
 	struct device_node *np;
 	const char *pathp;
@@ -397,7 +397,7 @@ static int unflatten_dt_nodes(const void *blob,
 	struct device_node *root;
 	int offset = 0, depth = 0;
 #define FDT_MAX_DEPTH	64
-	unsigned long fpsizes[FDT_MAX_DEPTH];
+	unsigned int fpsizes[FDT_MAX_DEPTH];
 	struct device_node *nps[FDT_MAX_DEPTH];
 	void *base = mem;
 	bool dryrun = !base;

commit 78c44d910d3e5f96dc6b3695fc1e4efd7c46a455
Author: Rhyland Klein <rklein@nvidia.com>
Date:   Wed May 11 13:36:57 2016 -0400

    drivers/of: Fix depth when unflattening devicetree
    
    When the implementation for unflatten_dt_node() changed from being
    recursive to being non-recursive, it had a side effect of increasing the
    depth passed to fdt_next_node() by 1. This is fine most of the time, but
    it seems that when the end of the dtb is being parsed, it will cause the
    FDT_END condition in fdt_next_node() to return a different value
    (returning nextoffset instead of -FDT_ERR_NOTFOUND). This ends up passing
    an FDT_ERR_TRUNCATED error back to the unflatten_dt_node() which then
    sees that and complains "Error -8 processing FDT" causing boot to fail.
    
    This patch simply avoids incrementing depth and uses modified accesses
    for local array indices so that the depth is the same as it was before
    the change as far as fdt_next_node() is concerned.
    
    This problem was discovered trying to boot Tegra210-Smaug platforms.
    
    Fixes: 50800082f176 ("drivers/of: Avoid recursively calling unflatten_dt_node()")
    Signed-off-by: Rhyland Klein <rklein@nvidia.com>
    [robh: squashed in KASAN fix from Rhyland]
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index ef1ccee51af8..b352f67d710b 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -407,24 +407,24 @@ static int unflatten_dt_nodes(const void *blob,
 
 	root = dad;
 	fpsizes[depth] = dad ? strlen(of_node_full_name(dad)) : 0;
-	nps[depth++] = dad;
+	nps[depth] = dad;
 	for (offset = 0;
-	     offset >= 0;
+	     offset >= 0 && depth >= 0;
 	     offset = fdt_next_node(blob, offset, &depth)) {
 		if (WARN_ON_ONCE(depth >= FDT_MAX_DEPTH))
 			continue;
 
-		fpsizes[depth] = populate_node(blob, offset, &mem,
-					       nps[depth - 1],
-					       fpsizes[depth - 1],
-					       &nps[depth], dryrun);
-		if (!fpsizes[depth])
+		fpsizes[depth+1] = populate_node(blob, offset, &mem,
+						 nps[depth],
+						 fpsizes[depth],
+						 &nps[depth+1], dryrun);
+		if (!fpsizes[depth+1])
 			return mem - base;
 
 		if (!dryrun && nodepp && !*nodepp)
-			*nodepp = nps[depth];
+			*nodepp = nps[depth+1];
 		if (!dryrun && !root)
-			root = nps[depth];
+			root = nps[depth+1];
 	}
 
 	if (offset < 0 && offset != -FDT_ERR_NOTFOUND) {

commit 83262418b0ef8bda66eca7c72d4c24ae6f7b230e
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Tue May 3 23:22:51 2016 +1000

    drivers/of: Return allocated memory from of_fdt_unflatten_tree()
    
    This returns the allocate memory chunk, storing the unflattened device
    tree, from of_fdt_unflatten_tree() so that memory chunk can be released
    on demand in PowerNV PCI hotplug driver.
    
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 0d53687d4b8c..ef1ccee51af8 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -454,11 +454,14 @@ static int unflatten_dt_nodes(const void *blob,
  * @mynodes: The device_node tree created by the call
  * @dt_alloc: An allocator that provides a virtual address to memory
  * for the resulting tree
+ *
+ * Returns NULL on failure or the memory chunk containing the unflattened
+ * device tree on success.
  */
-static void __unflatten_device_tree(const void *blob,
-			     struct device_node *dad,
-			     struct device_node **mynodes,
-			     void * (*dt_alloc)(u64 size, u64 align))
+static void *__unflatten_device_tree(const void *blob,
+				     struct device_node *dad,
+				     struct device_node **mynodes,
+				     void *(*dt_alloc)(u64 size, u64 align))
 {
 	int size;
 	void *mem;
@@ -467,7 +470,7 @@ static void __unflatten_device_tree(const void *blob,
 
 	if (!blob) {
 		pr_debug("No device tree pointer\n");
-		return;
+		return NULL;
 	}
 
 	pr_debug("Unflattening device tree:\n");
@@ -477,13 +480,13 @@ static void __unflatten_device_tree(const void *blob,
 
 	if (fdt_check_header(blob)) {
 		pr_err("Invalid device tree blob header\n");
-		return;
+		return NULL;
 	}
 
 	/* First pass, scan for size */
 	size = unflatten_dt_nodes(blob, NULL, dad, NULL);
 	if (size < 0)
-		return;
+		return NULL;
 
 	size = ALIGN(size, 4);
 	pr_debug("  size is %d, allocating...\n", size);
@@ -503,6 +506,7 @@ static void __unflatten_device_tree(const void *blob,
 			   be32_to_cpup(mem + size));
 
 	pr_debug(" <- unflatten_device_tree()\n");
+	return mem;
 }
 
 static void *kernel_tree_alloc(u64 size, u64 align)
@@ -522,14 +526,21 @@ static DEFINE_MUTEX(of_fdt_unflatten_mutex);
  * tree of struct device_node. It also fills the "name" and "type"
  * pointers of the nodes so the normal device-tree walking functions
  * can be used.
+ *
+ * Returns NULL on failure or the memory chunk containing the unflattened
+ * device tree on success.
  */
-void of_fdt_unflatten_tree(const unsigned long *blob,
-			struct device_node *dad,
-			struct device_node **mynodes)
+void *of_fdt_unflatten_tree(const unsigned long *blob,
+			    struct device_node *dad,
+			    struct device_node **mynodes)
 {
+	void *mem;
+
 	mutex_lock(&of_fdt_unflatten_mutex);
-	__unflatten_device_tree(blob, dad, mynodes, &kernel_tree_alloc);
+	mem = __unflatten_device_tree(blob, dad, mynodes, &kernel_tree_alloc);
 	mutex_unlock(&of_fdt_unflatten_mutex);
+
+	return mem;
 }
 EXPORT_SYMBOL_GPL(of_fdt_unflatten_tree);
 

commit c4263233f30e72f2645ff83c9074c994f88b015a
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Tue May 3 23:22:50 2016 +1000

    drivers/of: Specify parent node in of_fdt_unflatten_tree()
    
    This adds one more argument to of_fdt_unflatten_tree() to specify
    the parent node of the FDT blob that is going to be unflattened.
    In the result, the function can be used to unflatten FDT blob that
    represents device sub-tree in PowerNV PCI hotplug driver.
    
    Cc: Jyri Sarha <jsarha@ti.com>
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Acked-by: Jyri Sarha <jsarha@ti.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 9c3e52d0d570..0d53687d4b8c 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -450,11 +450,13 @@ static int unflatten_dt_nodes(const void *blob,
  * pointers of the nodes so the normal device-tree walking functions
  * can be used.
  * @blob: The blob to expand
+ * @dad: Parent device node
  * @mynodes: The device_node tree created by the call
  * @dt_alloc: An allocator that provides a virtual address to memory
  * for the resulting tree
  */
 static void __unflatten_device_tree(const void *blob,
+			     struct device_node *dad,
 			     struct device_node **mynodes,
 			     void * (*dt_alloc)(u64 size, u64 align))
 {
@@ -479,7 +481,7 @@ static void __unflatten_device_tree(const void *blob,
 	}
 
 	/* First pass, scan for size */
-	size = unflatten_dt_nodes(blob, NULL, NULL, NULL);
+	size = unflatten_dt_nodes(blob, NULL, dad, NULL);
 	if (size < 0)
 		return;
 
@@ -495,7 +497,7 @@ static void __unflatten_device_tree(const void *blob,
 	pr_debug("  unflattening %p...\n", mem);
 
 	/* Second pass, do actual unflattening */
-	unflatten_dt_nodes(blob, mem, NULL, mynodes);
+	unflatten_dt_nodes(blob, mem, dad, mynodes);
 	if (be32_to_cpup(mem + size) != 0xdeadbeef)
 		pr_warning("End of tree marker overwritten: %08x\n",
 			   be32_to_cpup(mem + size));
@@ -512,6 +514,9 @@ static DEFINE_MUTEX(of_fdt_unflatten_mutex);
 
 /**
  * of_fdt_unflatten_tree - create tree of device_nodes from flat blob
+ * @blob: Flat device tree blob
+ * @dad: Parent device node
+ * @mynodes: The device tree created by the call
  *
  * unflattens the device-tree passed by the firmware, creating the
  * tree of struct device_node. It also fills the "name" and "type"
@@ -519,10 +524,11 @@ static DEFINE_MUTEX(of_fdt_unflatten_mutex);
  * can be used.
  */
 void of_fdt_unflatten_tree(const unsigned long *blob,
+			struct device_node *dad,
 			struct device_node **mynodes)
 {
 	mutex_lock(&of_fdt_unflatten_mutex);
-	__unflatten_device_tree(blob, mynodes, &kernel_tree_alloc);
+	__unflatten_device_tree(blob, dad, mynodes, &kernel_tree_alloc);
 	mutex_unlock(&of_fdt_unflatten_mutex);
 }
 EXPORT_SYMBOL_GPL(of_fdt_unflatten_tree);
@@ -1195,7 +1201,7 @@ bool __init early_init_dt_scan(void *params)
  */
 void __init unflatten_device_tree(void)
 {
-	__unflatten_device_tree(initial_boot_params, &of_root,
+	__unflatten_device_tree(initial_boot_params, NULL, &of_root,
 				early_init_dt_alloc_memory_arch);
 
 	/* Get pointer to "/chosen" and "/aliases" nodes for use everywhere */

commit 947c82cbf01c9c6012cb96e385b5f6d6d1e1decb
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Tue May 3 23:22:49 2016 +1000

    drivers/of: Rename unflatten_dt_node()
    
    This renames unflatten_dt_node() to unflatten_dt_nodes() as it
    populates multiple device nodes from FDT blob. No logical changes
    introduced.
    
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index c2c4afcbb971..9c3e52d0d570 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -381,7 +381,7 @@ static void reverse_nodes(struct device_node *parent)
 }
 
 /**
- * unflatten_dt_node - Alloc and populate a device_node from the flat tree
+ * unflatten_dt_nodes - Alloc and populate a device_node from the flat tree
  * @blob: The parent device tree blob
  * @mem: Memory chunk to use for allocating device nodes and properties
  * @dad: Parent struct device_node
@@ -389,10 +389,10 @@ static void reverse_nodes(struct device_node *parent)
  *
  * It returns the size of unflattened device tree or error code
  */
-static int unflatten_dt_node(const void *blob,
-			     void *mem,
-			     struct device_node *dad,
-			     struct device_node **nodepp)
+static int unflatten_dt_nodes(const void *blob,
+			      void *mem,
+			      struct device_node *dad,
+			      struct device_node **nodepp)
 {
 	struct device_node *root;
 	int offset = 0, depth = 0;
@@ -479,7 +479,7 @@ static void __unflatten_device_tree(const void *blob,
 	}
 
 	/* First pass, scan for size */
-	size = unflatten_dt_node(blob, NULL, NULL, NULL);
+	size = unflatten_dt_nodes(blob, NULL, NULL, NULL);
 	if (size < 0)
 		return;
 
@@ -495,7 +495,7 @@ static void __unflatten_device_tree(const void *blob,
 	pr_debug("  unflattening %p...\n", mem);
 
 	/* Second pass, do actual unflattening */
-	unflatten_dt_node(blob, mem, NULL, mynodes);
+	unflatten_dt_nodes(blob, mem, NULL, mynodes);
 	if (be32_to_cpup(mem + size) != 0xdeadbeef)
 		pr_warning("End of tree marker overwritten: %08x\n",
 			   be32_to_cpup(mem + size));

commit 50800082f17645620bfdd357ba9141c86b76363d
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Tue May 3 23:22:48 2016 +1000

    drivers/of: Avoid recursively calling unflatten_dt_node()
    
    In current implementation, unflatten_dt_node() is called recursively
    to unflatten device nodes in FDT blob. It's stress to limited stack
    capacity, especially to adopt the function to unflatten device sub-tree
    that possibly has multiple root nodes. In that case, we runs out of
    stack and the system can't boot up successfully.
    
    In order to reuse the function to unflatten device sub-tree, this avoids
    calling the function recursively, meaning the device nodes are unflattened
    in one call on unflatten_dt_node(): two arrays are introduced to track the
    parent path size and the device node of current level of depth, which will
    be used by the device node on next level of depth to be unflattened. All
    device nodes in more than 64 level of depth are dropped and hopefully,
    the system can boot up successfully with the partial device-tree.
    
    Also, the parameter "poffset" and "fpsize" are unused and dropped and the
    parameter "dryrun" is figured out from "mem == NULL". Besides, the return
    value of the function is changed to indicate the size of memory consumed by
    the unflatten device tree or error code.
    
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 1b8c4ab0574d..c2c4afcbb971 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -356,63 +356,90 @@ static unsigned long populate_node(const void *blob,
 	return fpsize;
 }
 
+static void reverse_nodes(struct device_node *parent)
+{
+	struct device_node *child, *next;
+
+	/* In-depth first */
+	child = parent->child;
+	while (child) {
+		reverse_nodes(child);
+
+		child = child->sibling;
+	}
+
+	/* Reverse the nodes in the child list */
+	child = parent->child;
+	parent->child = NULL;
+	while (child) {
+		next = child->sibling;
+
+		child->sibling = parent->child;
+		parent->child = child;
+		child = next;
+	}
+}
+
 /**
  * unflatten_dt_node - Alloc and populate a device_node from the flat tree
  * @blob: The parent device tree blob
  * @mem: Memory chunk to use for allocating device nodes and properties
- * @poffset: pointer to node in flat tree
  * @dad: Parent struct device_node
  * @nodepp: The device_node tree created by the call
- * @fpsize: Size of the node path up at the current depth.
- * @dryrun: If true, do not allocate device nodes but still calculate needed
- * memory size
+ *
+ * It returns the size of unflattened device tree or error code
  */
-static void *unflatten_dt_node(const void *blob,
-			       void *mem,
-			       int *poffset,
-			       struct device_node *dad,
-			       struct device_node **nodepp,
-			       unsigned long fpsize,
-			       bool dryrun)
+static int unflatten_dt_node(const void *blob,
+			     void *mem,
+			     struct device_node *dad,
+			     struct device_node **nodepp)
 {
-	struct device_node *np;
-	static int depth;
-	int old_depth;
+	struct device_node *root;
+	int offset = 0, depth = 0;
+#define FDT_MAX_DEPTH	64
+	unsigned long fpsizes[FDT_MAX_DEPTH];
+	struct device_node *nps[FDT_MAX_DEPTH];
+	void *base = mem;
+	bool dryrun = !base;
 
-	fpsize = populate_node(blob, *poffset, &mem, dad, fpsize, &np, dryrun);
-	if (!fpsize)
-		return mem;
+	if (nodepp)
+		*nodepp = NULL;
+
+	root = dad;
+	fpsizes[depth] = dad ? strlen(of_node_full_name(dad)) : 0;
+	nps[depth++] = dad;
+	for (offset = 0;
+	     offset >= 0;
+	     offset = fdt_next_node(blob, offset, &depth)) {
+		if (WARN_ON_ONCE(depth >= FDT_MAX_DEPTH))
+			continue;
 
-	old_depth = depth;
-	*poffset = fdt_next_node(blob, *poffset, &depth);
-	if (depth < 0)
-		depth = 0;
-	while (*poffset > 0 && depth > old_depth)
-		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
-					fpsize, dryrun);
+		fpsizes[depth] = populate_node(blob, offset, &mem,
+					       nps[depth - 1],
+					       fpsizes[depth - 1],
+					       &nps[depth], dryrun);
+		if (!fpsizes[depth])
+			return mem - base;
+
+		if (!dryrun && nodepp && !*nodepp)
+			*nodepp = nps[depth];
+		if (!dryrun && !root)
+			root = nps[depth];
+	}
 
-	if (*poffset < 0 && *poffset != -FDT_ERR_NOTFOUND)
-		pr_err("unflatten: error %d processing FDT\n", *poffset);
+	if (offset < 0 && offset != -FDT_ERR_NOTFOUND) {
+		pr_err("%s: Error %d processing FDT\n", __func__, offset);
+		return -EINVAL;
+	}
 
 	/*
 	 * Reverse the child list. Some drivers assumes node order matches .dts
 	 * node order
 	 */
-	if (!dryrun && np->child) {
-		struct device_node *child = np->child;
-		np->child = NULL;
-		while (child) {
-			struct device_node *next = child->sibling;
-			child->sibling = np->child;
-			np->child = child;
-			child = next;
-		}
-	}
-
-	if (nodepp)
-		*nodepp = np;
+	if (!dryrun)
+		reverse_nodes(root);
 
-	return mem;
+	return mem - base;
 }
 
 /**
@@ -431,8 +458,7 @@ static void __unflatten_device_tree(const void *blob,
 			     struct device_node **mynodes,
 			     void * (*dt_alloc)(u64 size, u64 align))
 {
-	unsigned long size;
-	int start;
+	int size;
 	void *mem;
 
 	pr_debug(" -> unflatten_device_tree()\n");
@@ -453,11 +479,12 @@ static void __unflatten_device_tree(const void *blob,
 	}
 
 	/* First pass, scan for size */
-	start = 0;
-	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0, true);
-	size = ALIGN(size, 4);
+	size = unflatten_dt_node(blob, NULL, NULL, NULL);
+	if (size < 0)
+		return;
 
-	pr_debug("  size is %lx, allocating...\n", size);
+	size = ALIGN(size, 4);
+	pr_debug("  size is %d, allocating...\n", size);
 
 	/* Allocate memory for the expanded device tree */
 	mem = dt_alloc(size + 4, __alignof__(struct device_node));
@@ -468,8 +495,7 @@ static void __unflatten_device_tree(const void *blob,
 	pr_debug("  unflattening %p...\n", mem);
 
 	/* Second pass, do actual unflattening */
-	start = 0;
-	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
+	unflatten_dt_node(blob, mem, NULL, mynodes);
 	if (be32_to_cpup(mem + size) != 0xdeadbeef)
 		pr_warning("End of tree marker overwritten: %08x\n",
 			   be32_to_cpup(mem + size));

commit dfbd4c6eff35f1b1065cca046003cc9d7ff27222
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Tue May 3 23:22:47 2016 +1000

    drivers/of: Split unflatten_dt_node()
    
    The function unflatten_dt_node() is called recursively to unflatten
    device nodes and properties in the FDT blob. It looks complicated
    and hard to be understood.
    
    This splits the function into 3 functions: populate_properties(),
    populate_node() and unflatten_dt_node(). populate_properties(),
    which is called by populate_node(), creates properties for the
    indicated device node. The later one creates the device nodes
    from FDT blob. populate_node() gets the offset in FDT blob for
    next device nodes and then calls populate_node(). No logical
    changes introduced.
    
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 5e897bfe6628..1b8c4ab0574d 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -161,39 +161,127 @@ static void *unflatten_dt_alloc(void **mem, unsigned long size,
 	return res;
 }
 
-/**
- * unflatten_dt_node - Alloc and populate a device_node from the flat tree
- * @blob: The parent device tree blob
- * @mem: Memory chunk to use for allocating device nodes and properties
- * @poffset: pointer to node in flat tree
- * @dad: Parent struct device_node
- * @nodepp: The device_node tree created by the call
- * @fpsize: Size of the node path up at the current depth.
- * @dryrun: If true, do not allocate device nodes but still calculate needed
- * memory size
- */
-static void * unflatten_dt_node(const void *blob,
-				void *mem,
-				int *poffset,
-				struct device_node *dad,
-				struct device_node **nodepp,
-				unsigned long fpsize,
+static void populate_properties(const void *blob,
+				int offset,
+				void **mem,
+				struct device_node *np,
+				const char *nodename,
 				bool dryrun)
 {
-	const __be32 *p;
+	struct property *pp, **pprev = NULL;
+	int cur;
+	bool has_name = false;
+
+	pprev = &np->properties;
+	for (cur = fdt_first_property_offset(blob, offset);
+	     cur >= 0;
+	     cur = fdt_next_property_offset(blob, cur)) {
+		const __be32 *val;
+		const char *pname;
+		u32 sz;
+
+		val = fdt_getprop_by_offset(blob, cur, &pname, &sz);
+		if (!val) {
+			pr_warn("%s: Cannot locate property at 0x%x\n",
+				__func__, cur);
+			continue;
+		}
+
+		if (!pname) {
+			pr_warn("%s: Cannot find property name at 0x%x\n",
+				__func__, cur);
+			continue;
+		}
+
+		if (!strcmp(pname, "name"))
+			has_name = true;
+
+		pp = unflatten_dt_alloc(mem, sizeof(struct property),
+					__alignof__(struct property));
+		if (dryrun)
+			continue;
+
+		/* We accept flattened tree phandles either in
+		 * ePAPR-style "phandle" properties, or the
+		 * legacy "linux,phandle" properties.  If both
+		 * appear and have different values, things
+		 * will get weird. Don't do that.
+		 */
+		if (!strcmp(pname, "phandle") ||
+		    !strcmp(pname, "linux,phandle")) {
+			if (!np->phandle)
+				np->phandle = be32_to_cpup(val);
+		}
+
+		/* And we process the "ibm,phandle" property
+		 * used in pSeries dynamic device tree
+		 * stuff
+		 */
+		if (!strcmp(pname, "ibm,phandle"))
+			np->phandle = be32_to_cpup(val);
+
+		pp->name   = (char *)pname;
+		pp->length = sz;
+		pp->value  = (__be32 *)val;
+		*pprev     = pp;
+		pprev      = &pp->next;
+	}
+
+	/* With version 0x10 we may not have the name property,
+	 * recreate it here from the unit name if absent
+	 */
+	if (!has_name) {
+		const char *p = nodename, *ps = p, *pa = NULL;
+		int len;
+
+		while (*p) {
+			if ((*p) == '@')
+				pa = p;
+			else if ((*p) == '/')
+				ps = p + 1;
+			p++;
+		}
+
+		if (pa < ps)
+			pa = p;
+		len = (pa - ps) + 1;
+		pp = unflatten_dt_alloc(mem, sizeof(struct property) + len,
+					__alignof__(struct property));
+		if (!dryrun) {
+			pp->name   = "name";
+			pp->length = len;
+			pp->value  = pp + 1;
+			*pprev     = pp;
+			pprev      = &pp->next;
+			memcpy(pp->value, ps, len - 1);
+			((char *)pp->value)[len - 1] = 0;
+			pr_debug("fixed up name for %s -> %s\n",
+				 nodename, (char *)pp->value);
+		}
+	}
+
+	if (!dryrun)
+		*pprev = NULL;
+}
+
+static unsigned long populate_node(const void *blob,
+				   int offset,
+				   void **mem,
+				   struct device_node *dad,
+				   unsigned long fpsize,
+				   struct device_node **pnp,
+				   bool dryrun)
+{
 	struct device_node *np;
-	struct property *pp, **prev_pp = NULL;
 	const char *pathp;
 	unsigned int l, allocl;
-	static int depth;
-	int old_depth;
-	int offset;
-	int has_name = 0;
 	int new_format = 0;
 
-	pathp = fdt_get_name(blob, *poffset, &l);
-	if (!pathp)
-		return mem;
+	pathp = fdt_get_name(blob, offset, &l);
+	if (!pathp) {
+		*pnp = NULL;
+		return 0;
+	}
 
 	allocl = ++l;
 
@@ -223,7 +311,7 @@ static void * unflatten_dt_node(const void *blob,
 		}
 	}
 
-	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
+	np = unflatten_dt_alloc(mem, sizeof(struct device_node) + allocl,
 				__alignof__(struct device_node));
 	if (!dryrun) {
 		char *fn;
@@ -246,89 +334,15 @@ static void * unflatten_dt_node(const void *blob,
 		}
 		memcpy(fn, pathp, l);
 
-		prev_pp = &np->properties;
 		if (dad != NULL) {
 			np->parent = dad;
 			np->sibling = dad->child;
 			dad->child = np;
 		}
 	}
-	/* process properties */
-	for (offset = fdt_first_property_offset(blob, *poffset);
-	     (offset >= 0);
-	     (offset = fdt_next_property_offset(blob, offset))) {
-		const char *pname;
-		u32 sz;
 
-		if (!(p = fdt_getprop_by_offset(blob, offset, &pname, &sz))) {
-			offset = -FDT_ERR_INTERNAL;
-			break;
-		}
-
-		if (pname == NULL) {
-			pr_info("Can't find property name in list !\n");
-			break;
-		}
-		if (strcmp(pname, "name") == 0)
-			has_name = 1;
-		pp = unflatten_dt_alloc(&mem, sizeof(struct property),
-					__alignof__(struct property));
-		if (!dryrun) {
-			/* We accept flattened tree phandles either in
-			 * ePAPR-style "phandle" properties, or the
-			 * legacy "linux,phandle" properties.  If both
-			 * appear and have different values, things
-			 * will get weird.  Don't do that. */
-			if ((strcmp(pname, "phandle") == 0) ||
-			    (strcmp(pname, "linux,phandle") == 0)) {
-				if (np->phandle == 0)
-					np->phandle = be32_to_cpup(p);
-			}
-			/* And we process the "ibm,phandle" property
-			 * used in pSeries dynamic device tree
-			 * stuff */
-			if (strcmp(pname, "ibm,phandle") == 0)
-				np->phandle = be32_to_cpup(p);
-			pp->name = (char *)pname;
-			pp->length = sz;
-			pp->value = (__be32 *)p;
-			*prev_pp = pp;
-			prev_pp = &pp->next;
-		}
-	}
-	/* with version 0x10 we may not have the name property, recreate
-	 * it here from the unit name if absent
-	 */
-	if (!has_name) {
-		const char *p1 = pathp, *ps = pathp, *pa = NULL;
-		int sz;
-
-		while (*p1) {
-			if ((*p1) == '@')
-				pa = p1;
-			if ((*p1) == '/')
-				ps = p1 + 1;
-			p1++;
-		}
-		if (pa < ps)
-			pa = p1;
-		sz = (pa - ps) + 1;
-		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
-					__alignof__(struct property));
-		if (!dryrun) {
-			pp->name = "name";
-			pp->length = sz;
-			pp->value = pp + 1;
-			*prev_pp = pp;
-			prev_pp = &pp->next;
-			memcpy(pp->value, ps, sz - 1);
-			((char *)pp->value)[sz - 1] = 0;
-			pr_debug("fixed up name for %s -> %s\n", pathp,
-				(char *)pp->value);
-		}
-	}
+	populate_properties(blob, offset, mem, np, pathp, dryrun);
 	if (!dryrun) {
-		*prev_pp = NULL;
 		np->name = of_get_property(np, "name", NULL);
 		np->type = of_get_property(np, "device_type", NULL);
 
@@ -338,6 +352,37 @@ static void * unflatten_dt_node(const void *blob,
 			np->type = "<NULL>";
 	}
 
+	*pnp = np;
+	return fpsize;
+}
+
+/**
+ * unflatten_dt_node - Alloc and populate a device_node from the flat tree
+ * @blob: The parent device tree blob
+ * @mem: Memory chunk to use for allocating device nodes and properties
+ * @poffset: pointer to node in flat tree
+ * @dad: Parent struct device_node
+ * @nodepp: The device_node tree created by the call
+ * @fpsize: Size of the node path up at the current depth.
+ * @dryrun: If true, do not allocate device nodes but still calculate needed
+ * memory size
+ */
+static void *unflatten_dt_node(const void *blob,
+			       void *mem,
+			       int *poffset,
+			       struct device_node *dad,
+			       struct device_node **nodepp,
+			       unsigned long fpsize,
+			       bool dryrun)
+{
+	struct device_node *np;
+	static int depth;
+	int old_depth;
+
+	fpsize = populate_node(blob, *poffset, &mem, dad, fpsize, &np, dryrun);
+	if (!fpsize)
+		return mem;
+
 	old_depth = depth;
 	*poffset = fdt_next_node(blob, *poffset, &depth);
 	if (depth < 0)

commit 34b82026a507ec0092398d9fc7893c00dd11b7da
Author: Max Uvarov <muvarov@gmail.com>
Date:   Wed Apr 13 12:52:16 2016 +0300

    fdt: fix extend of cmd line
    
    On arm CONFIG_CMDLINE_EXTEND does not append build-in
    cmdline in kernel to U-boot parameters. Fix it here.
    Theoretically this patch should repair kdump work where
    it adds elfcorehdr= and memmap additional parameters
    to second kernel.
    
    Signed-off-by: Max Uvarov <muvarov@gmail.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 3349d2aa6634..5e897bfe6628 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -969,10 +969,16 @@ int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
 	 * is set in which case we override whatever was found earlier.
 	 */
 #ifdef CONFIG_CMDLINE
-#ifndef CONFIG_CMDLINE_FORCE
+#if defined(CONFIG_CMDLINE_EXTEND)
+	strlcat(data, " ", COMMAND_LINE_SIZE);
+	strlcat(data, CONFIG_CMDLINE, COMMAND_LINE_SIZE);
+#elif defined(CONFIG_CMDLINE_FORCE)
+	strlcpy(data, CONFIG_CMDLINE, COMMAND_LINE_SIZE);
+#else
+	/* No arguments from boot loader, use kernel's  cmdl*/
 	if (!((char *)data)[0])
-#endif
 		strlcpy(data, CONFIG_CMDLINE, COMMAND_LINE_SIZE);
+#endif
 #endif /* CONFIG_CMDLINE */
 
 	pr_debug("Command line is: %s\n", (char*)data);

commit 588ab3f9afdfa1a6b1e5761c858b2c4ab6098285
Merge: 3d15cfdb1b77 2776e0e8ef68
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 17 20:03:47 2016 -0700

    Merge tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux
    
    Pull arm64 updates from Catalin Marinas:
     "Here are the main arm64 updates for 4.6.  There are some relatively
      intrusive changes to support KASLR, the reworking of the kernel
      virtual memory layout and initial page table creation.
    
      Summary:
    
       - Initial page table creation reworked to avoid breaking large block
         mappings (huge pages) into smaller ones.  The ARM architecture
         requires break-before-make in such cases to avoid TLB conflicts but
         that's not always possible on live page tables
    
       - Kernel virtual memory layout: the kernel image is no longer linked
         to the bottom of the linear mapping (PAGE_OFFSET) but at the bottom
         of the vmalloc space, allowing the kernel to be loaded (nearly)
         anywhere in physical RAM
    
       - Kernel ASLR: position independent kernel Image and modules being
         randomly mapped in the vmalloc space with the randomness is
         provided by UEFI (efi_get_random_bytes() patches merged via the
         arm64 tree, acked by Matt Fleming)
    
       - Implement relative exception tables for arm64, required by KASLR
         (initial code for ARCH_HAS_RELATIVE_EXTABLE added to lib/extable.c
         but actual x86 conversion to deferred to 4.7 because of the merge
         dependencies)
    
       - Support for the User Access Override feature of ARMv8.2: this
         allows uaccess functions (get_user etc.) to be implemented using
         LDTR/STTR instructions.  Such instructions, when run by the kernel,
         perform unprivileged accesses adding an extra level of protection.
         The set_fs() macro is used to "upgrade" such instruction to
         privileged accesses via the UAO bit
    
       - Half-precision floating point support (part of ARMv8.2)
    
       - Optimisations for CPUs with or without a hardware prefetcher (using
         run-time code patching)
    
       - copy_page performance improvement to deal with 128 bytes at a time
    
       - Sanity checks on the CPU capabilities (via CPUID) to prevent
         incompatible secondary CPUs from being brought up (e.g.  weird
         big.LITTLE configurations)
    
       - valid_user_regs() reworked for better sanity check of the
         sigcontext information (restored pstate information)
    
       - ACPI parking protocol implementation
    
       - CONFIG_DEBUG_RODATA enabled by default
    
       - VDSO code marked as read-only
    
       - DEBUG_PAGEALLOC support
    
       - ARCH_HAS_UBSAN_SANITIZE_ALL enabled
    
       - Erratum workaround Cavium ThunderX SoC
    
       - set_pte_at() fix for PROT_NONE mappings
    
       - Code clean-ups"
    
    * tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux: (99 commits)
      arm64: kasan: Fix zero shadow mapping overriding kernel image shadow
      arm64: kasan: Use actual memory node when populating the kernel image shadow
      arm64: Update PTE_RDONLY in set_pte_at() for PROT_NONE permission
      arm64: Fix misspellings in comments.
      arm64: efi: add missing frame pointer assignment
      arm64: make mrs_s prefixing implicit in read_cpuid
      arm64: enable CONFIG_DEBUG_RODATA by default
      arm64: Rework valid_user_regs
      arm64: mm: check at build time that PAGE_OFFSET divides the VA space evenly
      arm64: KVM: Move kvm_call_hyp back to its original localtion
      arm64: mm: treat memstart_addr as a signed quantity
      arm64: mm: list kernel sections in order
      arm64: lse: deal with clobbered IP registers after branch via PLT
      arm64: mm: dump: Use VA_START directly instead of private LOWEST_ADDR
      arm64: kconfig: add submenu for 8.2 architectural features
      arm64: kernel: acpi: fix ioremap in ACPI parking protocol cpu_postboot
      arm64: Add support for Half precision floating point
      arm64: Remove fixmap include fragility
      arm64: Add workaround for Cavium erratum 27456
      arm64: mm: Mark .rodata as RO
      ...

commit 369bc9abf22bf026e8645a4dd746b90649a2f6ee
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Feb 16 13:52:33 2016 +0100

    of/fdt: factor out assignment of initrd_start/initrd_end
    
    Since architectures may not yet have their linear mapping up and running
    when the initrd address is discovered from the DT, factor out the
    assignment of initrd_start and initrd_end, so that an architecture can
    override it and use the translation it needs.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 1f98156f8996..3e90bce70545 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -760,6 +760,16 @@ const void * __init of_flat_dt_match_machine(const void *default_match,
 }
 
 #ifdef CONFIG_BLK_DEV_INITRD
+#ifndef __early_init_dt_declare_initrd
+static void __early_init_dt_declare_initrd(unsigned long start,
+					   unsigned long end)
+{
+	initrd_start = (unsigned long)__va(start);
+	initrd_end = (unsigned long)__va(end);
+	initrd_below_start_ok = 1;
+}
+#endif
+
 /**
  * early_init_dt_check_for_initrd - Decode initrd location from flat tree
  * @node: reference to node containing initrd location ('chosen')
@@ -782,9 +792,7 @@ static void __init early_init_dt_check_for_initrd(unsigned long node)
 		return;
 	end = of_read_number(prop, len/4);
 
-	initrd_start = (unsigned long)__va(start);
-	initrd_end = (unsigned long)__va(end);
-	initrd_below_start_ok = 1;
+	__early_init_dt_declare_initrd(start, end);
 
 	pr_debug("initrd_start=0x%llx  initrd_end=0x%llx\n",
 		 (unsigned long long)start, (unsigned long long)end);

commit 270522a04f7a9911983878fa37da467f9ff1c938
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Feb 16 13:52:32 2016 +0100

    of/fdt: make memblock minimum physical address arch configurable
    
    By default, early_init_dt_add_memory_arch() ignores memory below
    the base of the kernel image since it won't be addressable via the
    linear mapping. However, this is not appropriate anymore once we
    decouple the kernel text mapping from the linear mapping, so archs
    may want to drop the low limit entirely. So allow the minimum to be
    overridden by setting MIN_MEMBLOCK_ADDR.
    
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 655f79db7899..1f98156f8996 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -976,13 +976,16 @@ int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
 }
 
 #ifdef CONFIG_HAVE_MEMBLOCK
+#ifndef MIN_MEMBLOCK_ADDR
+#define MIN_MEMBLOCK_ADDR	__pa(PAGE_OFFSET)
+#endif
 #ifndef MAX_MEMBLOCK_ADDR
 #define MAX_MEMBLOCK_ADDR	((phys_addr_t)~0)
 #endif
 
 void __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)
 {
-	const u64 phys_offset = __pa(PAGE_OFFSET);
+	const u64 phys_offset = MIN_MEMBLOCK_ADDR;
 
 	if (!PAGE_ALIGNED(base)) {
 		if (size < PAGE_SIZE - (base & ~PAGE_MASK)) {

commit 0fcc286f6a952d6ec40f74f26fd9cd5d63c25f9e
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sat Jan 16 15:23:48 2016 -0800

    of: earlycon: Log more helpful message if stdout-path node not found
    
    Earlycon may fail to initialize for a variety of reasons, most of
    which log the default early param message. If the stdout-path node is
    not found, log the path which was not found (and suppress the
    default early param message).
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 918809e6f913..e2295b2c9836 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -820,11 +820,14 @@ static int __init early_init_dt_scan_chosen_serial(void)
 	q = strchrnul(p, ':');
 	if (*q != '\0')
 		options = q + 1;
+	l = q - p;
 
 	/* Get the node specified by stdout-path */
-	offset = fdt_path_offset_namelen(fdt, p, q - p);
-	if (offset < 0)
-		return -ENODEV;
+	offset = fdt_path_offset_namelen(fdt, p, l);
+	if (offset < 0) {
+		pr_warn("earlycon: stdout-path %.*s not found\n", l, p);
+		return 0;
+	}
 
 	for (match = __earlycon_table; match < __earlycon_table_end; match++) {
 		if (!match->compatible[0])

commit c90fe9c0394b068ceca16f66e9f35bcd8d948295
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sat Jan 16 15:23:44 2016 -0800

    of: earlycon: Move address translation to of_setup_earlycon()
    
    Cleanup the early DT/earlycon separation; remove the 'addr' parameter
    from of_setup_earlycon() and get the uart phys addr directly with a
    new wrapper function, of_flat_dt_translate_addr(). Limit
    fdt_translate_address() to file scope.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index e8fd54a30802..918809e6f913 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -827,19 +827,13 @@ static int __init early_init_dt_scan_chosen_serial(void)
 		return -ENODEV;
 
 	for (match = __earlycon_table; match < __earlycon_table_end; match++) {
-		u64 addr;
-
 		if (!match->compatible[0])
 			continue;
 
 		if (fdt_node_check_compatible(fdt, offset, match->compatible))
 			continue;
 
-		addr = fdt_translate_address(fdt, offset);
-		if (addr == OF_BAD_ADDR)
-			return -ENXIO;
-
-		of_setup_earlycon(addr, match, offset, options);
+		of_setup_earlycon(match, offset, options);
 		return 0;
 	}
 	return -ENODEV;

commit 088da2a17619cf0113b62a76ad38c6a14470ffa6
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sat Jan 16 15:23:43 2016 -0800

    of: earlycon: Initialize port fields from DT properties
    
    Read the optional "reg-offset", "reg-shift", "reg-io-width" and endianness
    properties and initialize the respective struct uart_port field if found.
    
    NB: These bindings are common to several drivers and the values merely
    indicate the default value; the registering earlycon setup() method can
    simply override the values if required.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index cfd3b35e8d81..e8fd54a30802 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -839,7 +839,7 @@ static int __init early_init_dt_scan_chosen_serial(void)
 		if (addr == OF_BAD_ADDR)
 			return -ENXIO;
 
-		of_setup_earlycon(addr, match, options);
+		of_setup_earlycon(addr, match, offset, options);
 		return 0;
 	}
 	return -ENODEV;

commit 4d118c9a866590850dad8689262a95345d2c6e09
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sat Jan 16 15:23:42 2016 -0800

    of: earlycon: Add options string handling
    
    Pass-through any options string in the 'stdout-path' property to the
    earlycon "driver" setup.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index ec1459517de6..cfd3b35e8d81 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -800,7 +800,7 @@ static inline void early_init_dt_check_for_initrd(unsigned long node)
 static int __init early_init_dt_scan_chosen_serial(void)
 {
 	int offset;
-	const char *p;
+	const char *p, *q, *options = NULL;
 	int l;
 	const struct earlycon_id *match;
 	const void *fdt = initial_boot_params;
@@ -817,11 +817,12 @@ static int __init early_init_dt_scan_chosen_serial(void)
 	if (!p || !l)
 		return -ENOENT;
 
-	/* Remove console options if present */
-	l = strchrnul(p, ':') - p;
+	q = strchrnul(p, ':');
+	if (*q != '\0')
+		options = q + 1;
 
 	/* Get the node specified by stdout-path */
-	offset = fdt_path_offset_namelen(fdt, p, l);
+	offset = fdt_path_offset_namelen(fdt, p, q - p);
 	if (offset < 0)
 		return -ENODEV;
 
@@ -838,7 +839,7 @@ static int __init early_init_dt_scan_chosen_serial(void)
 		if (addr == OF_BAD_ADDR)
 			return -ENXIO;
 
-		of_setup_earlycon(addr, match);
+		of_setup_earlycon(addr, match, options);
 		return 0;
 	}
 	return -ENODEV;

commit 05d961320ba624c98b16d72b32f947307674b341
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sat Jan 16 15:23:41 2016 -0800

    of: earlycon: Fixup earlycon console name and index
    
    Use the console name embedded in the OF earlycon table by the
    OF_EARLYCON_DECLARE() macro to initialize the struct console 'name'
    and 'index' fields.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 168611867611..ec1459517de6 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -838,7 +838,7 @@ static int __init early_init_dt_scan_chosen_serial(void)
 		if (addr == OF_BAD_ADDR)
 			return -ENXIO;
 
-		of_setup_earlycon(addr, match->setup);
+		of_setup_earlycon(addr, match);
 		return 0;
 	}
 	return -ENODEV;

commit 2eaa790989e03900298ad24f77f1086dbbc1aebd
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sat Jan 16 15:23:39 2016 -0800

    earlycon: Use common framework for earlycon declarations
    
    Use a single common table of struct earlycon_id for both command line
    and devicetree. Re-define OF_EARLYCON_DECLARE() macro to instance a
    unique earlycon declaration (the declaration is only guaranteed to be
    unique within a compilation unit; separate compilation units must still
    use unique earlycon names).
    
    The semantics of OF_EARLYCON_DECLARE() is different; it declares an
    earlycon which can matched either on the command line or by devicetree.
    EARLYCON_DECLARE() is semantically unchanged; it declares an earlycon
    which is matched by command line only. Remove redundant instances of
    EARLYCON_DECLARE().
    
    This enables all earlycons to properly initialize struct console
    with the appropriate name and index, which improves diagnostics and
    enables direct earlycon-to-console handoff.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 655f79db7899..168611867611 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -796,14 +796,13 @@ static inline void early_init_dt_check_for_initrd(unsigned long node)
 #endif /* CONFIG_BLK_DEV_INITRD */
 
 #ifdef CONFIG_SERIAL_EARLYCON
-extern struct of_device_id __earlycon_of_table[];
 
 static int __init early_init_dt_scan_chosen_serial(void)
 {
 	int offset;
 	const char *p;
 	int l;
-	const struct of_device_id *match = __earlycon_of_table;
+	const struct earlycon_id *match;
 	const void *fdt = initial_boot_params;
 
 	offset = fdt_path_offset(fdt, "/chosen");
@@ -826,19 +825,20 @@ static int __init early_init_dt_scan_chosen_serial(void)
 	if (offset < 0)
 		return -ENODEV;
 
-	while (match->compatible[0]) {
+	for (match = __earlycon_table; match < __earlycon_table_end; match++) {
 		u64 addr;
 
-		if (fdt_node_check_compatible(fdt, offset, match->compatible)) {
-			match++;
+		if (!match->compatible[0])
+			continue;
+
+		if (fdt_node_check_compatible(fdt, offset, match->compatible))
 			continue;
-		}
 
 		addr = fdt_translate_address(fdt, offset);
 		if (addr == OF_BAD_ADDR)
 			return -ENXIO;
 
-		of_setup_earlycon(addr, match->data);
+		of_setup_earlycon(addr, match->setup);
 		return 0;
 	}
 	return -ENODEV;

commit f8062386671a596ca7022c61727a14a25679a0a1
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Sat Dec 5 16:13:53 2015 -0800

    of/fdt: Add mutex protection for calls to __unflatten_device_tree()
    
    __unflatten_device_tree() calls unflatten_dt_node(), which declares
    a static variable. It is therefore not reentrant.
    
    One of the callers of __unflatten_device_tree(), unflatten_device_tree(),
    is only called once during early initialization and does not need to be
    protected. The other caller, of_fdt_unflatten_tree(), can be called at
    any time, possibly multiple times in parallel. This can happen, for
    example, if multiple devicetree overlays have to be loaded and installed.
    
    Without this protection, errors such as the following may be seen.
    
    kernel: End of tree marker overwritten: e6a3a458
    kernel: find_target_node:
            Failed to find target-indirect node at /fragment@0
    kernel: __of_overlay_create: of_build_overlay_info() failed for tree@/
    
    Add a mutex to of_fdt_unflatten_tree() to make the call reentrant.
    
    Cc: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Cc: stable@vger.kernel.org # v4.1+
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 1bbe3a990ef1..655f79db7899 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -13,6 +13,7 @@
 #include <linux/kernel.h>
 #include <linux/initrd.h>
 #include <linux/memblock.h>
+#include <linux/mutex.h>
 #include <linux/of.h>
 #include <linux/of_fdt.h>
 #include <linux/of_reserved_mem.h>
@@ -436,6 +437,8 @@ static void *kernel_tree_alloc(u64 size, u64 align)
 	return kzalloc(size, GFP_KERNEL);
 }
 
+static DEFINE_MUTEX(of_fdt_unflatten_mutex);
+
 /**
  * of_fdt_unflatten_tree - create tree of device_nodes from flat blob
  *
@@ -447,7 +450,9 @@ static void *kernel_tree_alloc(u64 size, u64 align)
 void of_fdt_unflatten_tree(const unsigned long *blob,
 			struct device_node **mynodes)
 {
+	mutex_lock(&of_fdt_unflatten_mutex);
 	__unflatten_device_tree(blob, mynodes, &kernel_tree_alloc);
+	mutex_unlock(&of_fdt_unflatten_mutex);
 }
 EXPORT_SYMBOL_GPL(of_fdt_unflatten_tree);
 

commit 78bb2abe09d6bd15eeee7250f2fa0cb76432a8a2
Author: Dmitry V. Krivenok <krivenok.dmitry@gmail.com>
Date:   Mon Nov 30 23:45:48 2015 +0300

    of: do not use 0x in front of %pa
    
    Signed-off-by: Dmitry V. Krivenok <krivenok.dmitry@gmail.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index d2430298a309..1bbe3a990ef1 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -1041,7 +1041,7 @@ void __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)
 int __init __weak early_init_dt_reserve_memory_arch(phys_addr_t base,
 					phys_addr_t size, bool nomap)
 {
-	pr_err("Reserved memory not supported, ignoring range 0x%pa - 0x%pa%s\n",
+	pr_err("Reserved memory not supported, ignoring range %pa - %pa%s\n",
 		  &base, &size, nomap ? " (nomap)" : "");
 	return -ENOSYS;
 }

commit 0b13ea8e2661822960b59924b02b4a0ebcf22149
Author: Saurabh Sengar <saurabh.truth@gmail.com>
Date:   Tue Oct 27 09:12:01 2015 +0530

    drivers: of: removing assignment of 0 to static variable
    
    no need to initialise static variable with 0, hence correcting it.
    
    Signed-off-by: Saurabh Sengar <saurabh.truth@gmail.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 196e449fc853..d2430298a309 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -184,7 +184,7 @@ static void * unflatten_dt_node(const void *blob,
 	struct property *pp, **prev_pp = NULL;
 	const char *pathp;
 	unsigned int l, allocl;
-	static int depth = 0;
+	static int depth;
 	int old_depth;
 	int offset;
 	int has_name = 0;

commit 3f5ceec96470050d20d7281d49985e3b1cfc3995
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Oct 23 20:47:20 2015 +0900

    of/fdt: fix error checking for earlycon address
    
    fdt_translate_address() returns OF_BAD_ADDR on error.  It is defined as
    a u64 value, so the variable "addr" should be defined as u64 as well.
    
    Fixes: fb11ffe74c79 ("of/fdt: add FDT serial scanning for earlycon")
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 9fc356830226..196e449fc853 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -822,14 +822,15 @@ static int __init early_init_dt_scan_chosen_serial(void)
 		return -ENODEV;
 
 	while (match->compatible[0]) {
-		unsigned long addr;
+		u64 addr;
+
 		if (fdt_node_check_compatible(fdt, offset, match->compatible)) {
 			match++;
 			continue;
 		}
 
 		addr = fdt_translate_address(fdt, offset);
-		if (!addr)
+		if (addr == OF_BAD_ADDR)
 			return -ENXIO;
 
 		of_setup_earlycon(addr, match->data);

commit 6296ad9e3375c6c1ddbb371f589ba6a145bb31df
Author: Stefan Agner <stefan@agner.ch>
Date:   Sat Oct 10 01:29:30 2015 -0700

    of/fdt: fix aliases with baudrate in earlycon
    
    Many boards use an alias in the stdout-path specification along
    with console options after a colon (e.g. serial0:115200n8). When
    using earlycon, this specification currently does not work. While
    fdt_path_offset supports alias resolution, it does not remove the
    console options by itself. Use the fdt_path_offset_namelen variant
    and provide the length of the alias to enable aliases with console
    options in the stdout-path.
    
    Signed-off-by: Stefan Agner <stefan@agner.ch>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 6e82bc42373b..9fc356830226 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -813,8 +813,11 @@ static int __init early_init_dt_scan_chosen_serial(void)
 	if (!p || !l)
 		return -ENOENT;
 
+	/* Remove console options if present */
+	l = strchrnul(p, ':') - p;
+
 	/* Get the node specified by stdout-path */
-	offset = fdt_path_offset(fdt, p);
+	offset = fdt_path_offset_namelen(fdt, p, l);
 	if (offset < 0)
 		return -ENODEV;
 

commit 8eafeb48022816513abc4f440bdad4c350fe81a3
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Aug 18 10:34:41 2015 +0100

    of/fdt: make memblock maximum physical address arch configurable
    
    When parsing the memory nodes to populate the memblock memory
    table, we check against high and low limits and clip any memory
    that exceeds either one of them.
    
    However, for arm64, the high limit of (phys_addr_t)~0 is not very
    meaningful, since phys_addr_t is 64 bits (i.e., no limit) but there
    may be other constraints that limit the memory ranges that we can
    support.
    
    So rename MAX_PHYS_ADDR to MAX_MEMBLOCK_ADDR (for clarity) and only
    define it if the arch does not supply a definition of its own.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Tested-by: Stuart Yoder <stuart.yoder@freescale.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 07496560e5b9..6e82bc42373b 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -967,7 +967,9 @@ int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
 }
 
 #ifdef CONFIG_HAVE_MEMBLOCK
-#define MAX_PHYS_ADDR	((phys_addr_t)~0)
+#ifndef MAX_MEMBLOCK_ADDR
+#define MAX_MEMBLOCK_ADDR	((phys_addr_t)~0)
+#endif
 
 void __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)
 {
@@ -984,16 +986,16 @@ void __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)
 	}
 	size &= PAGE_MASK;
 
-	if (base > MAX_PHYS_ADDR) {
+	if (base > MAX_MEMBLOCK_ADDR) {
 		pr_warning("Ignoring memory block 0x%llx - 0x%llx\n",
 				base, base + size);
 		return;
 	}
 
-	if (base + size - 1 > MAX_PHYS_ADDR) {
+	if (base + size - 1 > MAX_MEMBLOCK_ADDR) {
 		pr_warning("Ignoring memory range 0x%llx - 0x%llx\n",
-				((u64)MAX_PHYS_ADDR) + 1, base + size);
-		size = MAX_PHYS_ADDR - base + 1;
+				((u64)MAX_MEMBLOCK_ADDR) + 1, base + size);
+		size = MAX_MEMBLOCK_ADDR - base + 1;
 	}
 
 	if (base + size < phys_offset) {

commit 4da3064d1775810f10f7ddc1c34c3f1ff502a654
Merge: 93899e39e86b 48a9b733e644
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 1 19:40:18 2015 -0700

    Merge tag 'devicetree-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/glikely/linux
    
    Pull devicetree updates from Grant Likely:
     "A whole lot of bug fixes.
    
      Nothing stands out here except the ability to enable CONFIG_OF on
      every architecture, and an import of a newer version of dtc"
    
    * tag 'devicetree-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/glikely/linux: (22 commits)
      of/irq: Rename "intc_desc" to "of_intc_desc" to fix OF on sh
      of/irq: Fix pSeries boot failure
      Documentation: DT: Fix a typo in the filename "lantiq,<chip>-pinumx.txt"
      of: define of_find_node_by_phandle for !CONFIG_OF
      of/address: use atomic allocation in pci_register_io_range()
      of: Add vendor prefix for Zodiac Inflight Innovations
      dt/fdt: add empty versions of early_init_dt_*_memory_arch
      of: clean-up unnecessary libfdt include paths
      of: make unittest select OF_EARLY_FLATTREE instead of depend on it
      of: make CONFIG_OF user selectable
      MIPS: prepare for user enabling of CONFIG_OF
      of/fdt: fix argument name and add comments of unflatten_dt_node()
      of: return NUMA_NO_NODE from fallback of_node_to_nid()
      tps6507x.txt: Remove executable permission
      of/overlay: Grammar s/an negative/a negative/
      of/fdt: Make fdt blob input parameters of unflatten functions const
      of: add helper function to retrive match data
      of: Grammar s/property exist/property exists/
      of: Move OF flags to be visible even when !CONFIG_OF
      scripts/dtc: Update to upstream version 9d3649bd3be245c9
      ...

commit becfc3c86df963491ff1d5ffc6131a06af6bb851
Merge: ce32f859646b 0b34c1a489f6
Author: Grant Likely <grant.likely@linaro.org>
Date:   Tue Jun 30 14:28:52 2015 +0100

    Merge remote-tracking branch 'robh/for-next' into devicetree/next

commit aefc7ec27c318faa58e7e92dbe85217b2bab7a0e
Author: Rob Herring <robh@kernel.org>
Date:   Thu Jun 18 20:35:46 2015 -0500

    dt/fdt: add empty versions of early_init_dt_*_memory_arch
    
    With the addition of commit 0166dc1 (of: make CONFIG_OF user
    selectable), architectures which don't enable memblock and don't
    have their own early_init_dt_*_memory_arch implementations will break
    when CONFIG_OF is enabled.
    
    Really, we should have better separation of CONFIG_OF and
    CONFIG_OF_EARLY_FLATTREE, but doing that will require quite a bit of
    shuffling of architecture code. That will have to wait for another day.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Cc: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 9628c4a77f76..0e314ba1f985 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -1015,6 +1015,11 @@ void * __init __weak early_init_dt_alloc_memory_arch(u64 size, u64 align)
 	return __va(memblock_alloc(size, align));
 }
 #else
+void __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)
+{
+	WARN_ON(1);
+}
+
 int __init __weak early_init_dt_reserve_memory_arch(phys_addr_t base,
 					phys_addr_t size, bool nomap)
 {
@@ -1022,6 +1027,12 @@ int __init __weak early_init_dt_reserve_memory_arch(phys_addr_t base,
 		  &base, &size, nomap ? " (nomap)" : "");
 	return -ENOSYS;
 }
+
+void * __init __weak early_init_dt_alloc_memory_arch(u64 size, u64 align)
+{
+	WARN_ON(1);
+	return NULL;
+}
 #endif
 
 bool __init early_init_dt_verify(void *params)

commit ce32f859646bab2ed724393398b90aa50149bb44
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Apr 13 10:30:20 2015 +0900

    of/fdt: fix argument name and add comments of unflatten_dt_node()
    
    Match the name of the third argument in the comment block
    to the actual function: p -> poffset
    
    Add missing comments about the arguments "nodepp" and "dryrun".
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index cde35c5d0191..293f80bd83dd 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -164,9 +164,12 @@ static void *unflatten_dt_alloc(void **mem, unsigned long size,
  * unflatten_dt_node - Alloc and populate a device_node from the flat tree
  * @blob: The parent device tree blob
  * @mem: Memory chunk to use for allocating device nodes and properties
- * @p: pointer to node in flat tree
+ * @poffset: pointer to node in flat tree
  * @dad: Parent struct device_node
+ * @nodepp: The device_node tree created by the call
  * @fpsize: Size of the node path up at the current depth.
+ * @dryrun: If true, do not allocate device nodes but still calculate needed
+ * memory size
  */
 static void * unflatten_dt_node(void *blob,
 				void *mem,

commit 24bbd929e6b9e62afd263c42b4318d3b603c956c
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Jun 1 13:40:31 2015 +0200

    of/fdt: split off FDT self reservation from memreserve processing
    
    This splits off the reservation of the memory occupied by the FDT
    binary itself from the processing of the memory reservations it
    contains. This is necessary because the physical address of the FDT,
    which is needed to perform the reservation, may not be known to the
    FDT driver core, i.e., it may be mapped outside the linear direct
    mapping, in which case __pa() returns a bogus value.
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Acked-by: Rob Herring <robh@kernel.org>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index cde35c5d0191..f2dd23a32267 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -580,11 +580,6 @@ void __init early_init_fdt_scan_reserved_mem(void)
 	if (!initial_boot_params)
 		return;
 
-	/* Reserve the dtb region */
-	early_init_dt_reserve_memory_arch(__pa(initial_boot_params),
-					  fdt_totalsize(initial_boot_params),
-					  0);
-
 	/* Process header /memreserve/ fields */
 	for (n = 0; ; n++) {
 		fdt_get_mem_rsv(initial_boot_params, n, &base, &size);
@@ -597,6 +592,20 @@ void __init early_init_fdt_scan_reserved_mem(void)
 	fdt_init_reserved_mem();
 }
 
+/**
+ * early_init_fdt_reserve_self() - reserve the memory used by the FDT blob
+ */
+void __init early_init_fdt_reserve_self(void)
+{
+	if (!initial_boot_params)
+		return;
+
+	/* Reserve the dtb region */
+	early_init_dt_reserve_memory_arch(__pa(initial_boot_params),
+					  fdt_totalsize(initial_boot_params),
+					  0);
+}
+
 /**
  * of_scan_flat_dt - scan flattened tree blob and call callback on each.
  * @it: callback function

commit 3b1a2c97210b1edd1a999ff8c1f72ab28f7609f7
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed May 13 16:33:56 2015 +0200

    of/fdt: Make fdt blob input parameters of unflatten functions const
    
    Operations to unflatten fdt blobs never modify the input blobs, hence
    make them const. Now we no longer need to cast arbitrary const data to
    "void *" when calling of_fdt_unflatten_tree().
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index cde35c5d0191..9628c4a77f76 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -168,7 +168,7 @@ static void *unflatten_dt_alloc(void **mem, unsigned long size,
  * @dad: Parent struct device_node
  * @fpsize: Size of the node path up at the current depth.
  */
-static void * unflatten_dt_node(void *blob,
+static void * unflatten_dt_node(const void *blob,
 				void *mem,
 				int *poffset,
 				struct device_node *dad,
@@ -378,7 +378,7 @@ static void * unflatten_dt_node(void *blob,
  * @dt_alloc: An allocator that provides a virtual address to memory
  * for the resulting tree
  */
-static void __unflatten_device_tree(void *blob,
+static void __unflatten_device_tree(const void *blob,
 			     struct device_node **mynodes,
 			     void * (*dt_alloc)(u64 size, u64 align))
 {
@@ -441,7 +441,7 @@ static void *kernel_tree_alloc(u64 size, u64 align)
  * pointers of the nodes so the normal device-tree walking functions
  * can be used.
  */
-void of_fdt_unflatten_tree(unsigned long *blob,
+void of_fdt_unflatten_tree(const unsigned long *blob,
 			struct device_node **mynodes)
 {
 	__unflatten_device_tree(blob, mynodes, &kernel_tree_alloc);

commit 05f4647b10233dd2e18106abb16ff7fb68abbd08
Author: Ricky Liang <jcliang@chromium.org>
Date:   Tue Apr 14 12:36:05 2015 +0800

    of/fdt: fix allocation size for device node path
    
    The allocation size of device node path is off by one which drops the
    '\0' terminator.
    
    Signed-off-by: Ricky Liang <jcliang@chromium.org>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 4b15aa163b6e..cde35c5d0191 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -191,7 +191,7 @@ static void * unflatten_dt_node(void *blob,
 	if (!pathp)
 		return mem;
 
-	allocl = l++;
+	allocl = ++l;
 
 	/* version 0x10 has a more compact unit name here instead of the full
 	 * path. we accumulate the full path size using "fpsize", we'll rebuild

commit cc7837867a559feba70fdf68eb53c24a84e3712f
Author: Kevin Cernekee <cernekee@gmail.com>
Date:   Thu Apr 9 13:05:15 2015 -0700

    of/fdt: Add endianness helper function for early init code
    
    Provide a libfdt-based equivalent for of_device_is_big_endian(), suitable
    for use in the early_init_* functions.
    
    Signed-off-by: Kevin Cernekee <cernekee@gmail.com>
    Reviewed-by: Peter Hurley <peter@hurleysoftware.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 34bdc4de83d0..4b15aa163b6e 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -108,6 +108,25 @@ int of_fdt_is_compatible(const void *blob,
 	return 0;
 }
 
+/**
+ * of_fdt_is_big_endian - Return true if given node needs BE MMIO accesses
+ * @blob: A device tree blob
+ * @node: node to test
+ *
+ * Returns true if the node has a "big-endian" property, or if the kernel
+ * was compiled for BE *and* the node has a "native-endian" property.
+ * Returns false otherwise.
+ */
+bool of_fdt_is_big_endian(const void *blob, unsigned long node)
+{
+	if (fdt_getprop(blob, node, "big-endian", NULL))
+		return true;
+	if (IS_ENABLED(CONFIG_CPU_BIG_ENDIAN) &&
+	    fdt_getprop(blob, node, "native-endian", NULL))
+		return true;
+	return false;
+}
+
 /**
  * of_fdt_match - Return true if node matches a list of compatible values
  */

commit c954b36e3f5bfdd5aeceba49614a4864d7efec87
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sun Apr 12 13:16:26 2015 -0700

    of/fdt: Remove "reg" data prints from early_init_dt_scan_memory
    
    Commit 51975db0b7333 ("of/flattree: merge early_init_dt_scan_memory()
    common code") consolidated some code from PowerPC (typically
    big-endian), and ended-up adding a pr_debug() printing reg properties in
    big-endian (DT native) format, not CPU endian.
    
    This debug print suffers from two problems:
    - we only print 4 "reg" values, while there could be more on typical
      systems having multiple memory ranges
    - we print these 4 "reg" values in FDT endianess, that is big-endian,
      and these values could be confusing for little-endian configurations
    
    Since we are already printing the base address and size of the memory
    regions parsed by early_init_dt_scan_memory() later in a way that is
    both endian correct, and takes into account arbitrary number of memory
    banks, just remove that part of the debug print.
    
    Suggested-by: Frank Rowand <frowand.list@gmail.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 3a896c9aeb74..34bdc4de83d0 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -879,8 +879,7 @@ int __init early_init_dt_scan_memory(unsigned long node, const char *uname,
 
 	endp = reg + (l / sizeof(__be32));
 
-	pr_debug("memory scan node %s, reg size %d, data: %x %x %x %x,\n",
-	    uname, l, reg[0], reg[1], reg[2], reg[3]);
+	pr_debug("memory scan node %s, reg size %d,\n", uname, l);
 
 	while ((endp - reg) >= (dt_root_addr_cells + dt_root_size_cells)) {
 		u64 base, size;

commit 523bf17f1c7c3171e03dbd31402dfa263e63d178
Author: Lad, Prabhakar <prabhakar.csengg@gmail.com>
Date:   Wed Feb 4 12:04:06 2015 +0000

    of/fdt: fix sparse warning
    
    this patch fixes following sparse warning:
    
    fdt.c:765:12: warning: symbol 'early_init_dt_scan_chosen_serial' was not declared. Should it be static?
    
    Signed-off-by: Lad, Prabhakar <prabhakar.csengg@gmail.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 510074226d57..3a896c9aeb74 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -762,7 +762,7 @@ static inline void early_init_dt_check_for_initrd(unsigned long node)
 #ifdef CONFIG_SERIAL_EARLYCON
 extern struct of_device_id __earlycon_of_table[];
 
-int __init early_init_dt_scan_chosen_serial(void)
+static int __init early_init_dt_scan_chosen_serial(void)
 {
 	int offset;
 	const char *p;

commit 7ef58b32f571bffb7763c6252ad7527562081f34
Merge: 413fd0e3fbf5 c46ca3c8310b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 11 13:06:58 2014 -0800

    Merge tag 'devicetree-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/glikely/linux
    
    Pull devicetree changes from Grant Likely:
     "Lots of activity in the devicetree code for v3.18.  Most of it is
      related to getting all of the overlay support code in place, but there
      are other important things in there.
    
      Highlights:
    
       - OF_RECONFIG notifiers for SPI, I2C and Platform devices.  Those
         subsystems can now respond to live changes to the device tree.
    
       - CONFIG_OF_OVERLAY method for applying live changes to the device
         tree
    
       - Removal of the of_allnodes list.  This used to be used to iterate
         over all the nodes in the device tree, but it is unnecessary
         because the same thing can be done by iterating over the list of
         child pointers.  Getting rid of of_allnodes saves some memory and
         avoids the possibility of of_allnodes being sorted differently from
         the child lists.
    
       - Support for retrieving original DTB blob via sysfs.  Needed by
         kexec.
    
       - More unittests
    
       - Documentation and minor bug fixes"
    
    * tag 'devicetree-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/glikely/linux: (42 commits)
      of: Delete unnecessary check before calling "of_node_put()"
      of: Drop ->next pointer from struct device_node
      spi: Check for spi_of_notifier when CONFIG_OF_DYNAMIC=y
      of: support passing console options with stdout-path
      of: add optional options parameter to of_find_node_by_path()
      of: Add bindings for chosen node, stdout-path
      of: Remove unneeded and incorrect MODULE_DEVICE_TABLE
      ARM: dt: fix up PL011 device tree bindings
      of: base, fix of_property_read_string_helper kernel-doc
      of: remove select of non-existant OF_DEVICE config symbol
      spi/of: Add OF notifier handler
      spi/of: Create new device registration method and accessors
      i2c/of: Add OF_RECONFIG notifier handler
      i2c/of: Factor out Devicetree registration code
      of/overlay: Add overlay unittests
      of/overlay: Introduce DT overlay support
      of/reconfig: Add OF_DYNAMIC notifier for platform_bus_type
      of/reconfig: Always use the same structure for notifiers
      of/reconfig: Add debug output for OF_RECONFIG notifiers
      of/reconfig: Add empty stubs for the of_reconfig methods
      ...

commit 70161ff336674ecfd20614a9c0c61cb17a6e9e83
Author: Grant Likely <grant.likely@linaro.org>
Date:   Fri Nov 28 16:03:33 2014 +0000

    of: Drop ->next pointer from struct device_node
    
    The ->next pointer in struct device_node is a hanger-on from when it was
    used to iterate over the whole tree by a particular device_type property
    value. Those days are long over, but the fdt unflattening code still
    uses it to put nodes in the unflattened tree into the same order as node
    in the flat tree. By reworking the unflattening code to reverse the list
    after unflattening all the children of a node, the pointer can be
    dropped which gives a small amount of memory savings.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Acked-by: Frank Rowand <frank.rowand@sonymobile.com>
    Cc: Gaurav Minocha <gaurav.minocha.os@gmail.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 7f6ee31d5650..a41f9fdb1aa0 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -226,12 +226,8 @@ static void * unflatten_dt_node(void *blob,
 		prev_pp = &np->properties;
 		if (dad != NULL) {
 			np->parent = dad;
-			/* we temporarily use the next field as `last_child'*/
-			if (dad->next == NULL)
-				dad->child = np;
-			else
-				dad->next->sibling = np;
-			dad->next = np;
+			np->sibling = dad->child;
+			dad->child = np;
 		}
 	}
 	/* process properties */
@@ -329,6 +325,22 @@ static void * unflatten_dt_node(void *blob,
 
 	if (*poffset < 0 && *poffset != -FDT_ERR_NOTFOUND)
 		pr_err("unflatten: error %d processing FDT\n", *poffset);
+
+	/*
+	 * Reverse the child list. Some drivers assumes node order matches .dts
+	 * node order
+	 */
+	if (!dryrun && np->child) {
+		struct device_node *child = np->child;
+		np->child = NULL;
+		while (child) {
+			struct device_node *next = child->sibling;
+			child->sibling = np->child;
+			np->child = child;
+			child = next;
+		}
+	}
+
 	if (nodepp)
 		*nodepp = np;
 

commit 094cb98179f19b75acf9ff471daabf3948ce98e6
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Tue Nov 25 15:05:13 2014 +0000

    of/fdt: memblock_reserve /memreserve/ regions in the case of partial overlap
    
    memblock_is_region_reserved() returns true in the case of a partial
    overlap, meaning that the current code fails to reserve the
    non-overlapping portion.
    
    This call was introduced as part of d1552ce449eb "of/fdt: move
    memreserve and dtb memory reservations into core" which went into
    v3.16.
    
    I observed this causing a Midway system with a buggy fdt (the header
    declares itself to be larger than it really is) failing to boot
    because the over-inflated size of the fdt was causing it to seem to
    run into the swapper_pg_dir region, meaning the DT wasn't reserved.
    The symptoms were failing to find an disks or network and failing to
    boot.
    
    However given the ambiguity of whether things like the initrd are
    covered by /memreserve/ and similar I think it is best to also
    register the region rather than just ignoring it.
    
    Since memblock_reserve() handles overlaps just fine lets just warn and
    carry on.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: stable@vger.kernel.org # v3.16+

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 30e97bcc4f88..d134710de96d 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -964,8 +964,6 @@ void __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)
 int __init __weak early_init_dt_reserve_memory_arch(phys_addr_t base,
 					phys_addr_t size, bool nomap)
 {
-	if (memblock_is_region_reserved(base, size))
-		return -EBUSY;
 	if (nomap)
 		return memblock_remove(base, size);
 	return memblock_reserve(base, size);

commit 66e6a5a1fcd2f3e05f4d499b539a1f77ceb52d1d
Merge: 2d0747c4b68b 5d01410fe4d9
Author: Grant Likely <grant.likely@linaro.org>
Date:   Mon Nov 24 14:50:07 2014 +0000

    Merge tag 'v3.18-rc6' into devicetree/next
    
    v3.18-rc6 contains an important DT bug fix, c1a2086e2d, "of/selftest:
    Fix off-by-one error in removal path" which affects testing of the
    overlay patch series. Merge it into the devicetree/next staging branch
    so that the overlay patches are applied on top of a known working tree.
    
    Linux 3.18-rc6
    
    Conflicts:
            drivers/of/address.c

commit 08d53aa58cb162e65e25dbe31d28438657cb8e33
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Nov 14 18:05:35 2014 +0100

    of/fdt: export fdt blob as /sys/firmware/fdt
    
    Create a new /sys entry '/sys/firmware/fdt' to export the FDT blob
    that was passed to the kernel by the bootloader. This allows userland
    applications such as kexec to access the raw binary.
    
    The fact that this node does not reside under /sys/firmware/device-tree
    is deliberate: FDT is also used on arm64 UEFI/ACPI systems to
    communicate just the UEFI and ACPI entry points, but the FDT is never
    unflattened and used to configure the system.
    
    A CRC32 checksum is calculated over the entire FDT blob, and verified
    at late_initcall time. The sysfs entry is instantiated only if the
    checksum is valid, i.e., if the FDT blob has not been modified in the
    mean time. Otherwise, a warning is printed.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 83a8e1154602..cb19adfb3933 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -9,6 +9,7 @@
  * version 2 as published by the Free Software Foundation.
  */
 
+#include <linux/crc32.h>
 #include <linux/kernel.h>
 #include <linux/initrd.h>
 #include <linux/memblock.h>
@@ -22,6 +23,7 @@
 #include <linux/libfdt.h>
 #include <linux/debugfs.h>
 #include <linux/serial_core.h>
+#include <linux/sysfs.h>
 
 #include <asm/setup.h>  /* for COMMAND_LINE_SIZE */
 #include <asm/page.h>
@@ -423,6 +425,8 @@ void *initial_boot_params;
 
 #ifdef CONFIG_OF_EARLY_FLATTREE
 
+static u32 of_fdt_crc32;
+
 /**
  * res_mem_reserve_reg() - reserve all memory described in 'reg' property
  */
@@ -1003,6 +1007,8 @@ bool __init early_init_dt_verify(void *params)
 
 	/* Setup flat device-tree pointer */
 	initial_boot_params = params;
+	of_fdt_crc32 = crc32_be(~0, initial_boot_params,
+				fdt_totalsize(initial_boot_params));
 	return true;
 }
 
@@ -1080,27 +1086,32 @@ void __init unflatten_and_copy_device_tree(void)
 	unflatten_device_tree();
 }
 
-#if defined(CONFIG_DEBUG_FS) && defined(DEBUG)
-static struct debugfs_blob_wrapper flat_dt_blob;
-
-static int __init of_flat_dt_debugfs_export_fdt(void)
+#ifdef CONFIG_SYSFS
+static ssize_t of_fdt_raw_read(struct file *filp, struct kobject *kobj,
+			       struct bin_attribute *bin_attr,
+			       char *buf, loff_t off, size_t count)
 {
-	struct dentry *d = debugfs_create_dir("device-tree", NULL);
-
-	if (!d)
-		return -ENOENT;
+	memcpy(buf, initial_boot_params + off, count);
+	return count;
+}
 
-	flat_dt_blob.data = initial_boot_params;
-	flat_dt_blob.size = fdt_totalsize(initial_boot_params);
+static int __init of_fdt_raw_init(void)
+{
+	static struct bin_attribute of_fdt_raw_attr =
+		__BIN_ATTR(fdt, S_IRUSR, of_fdt_raw_read, NULL, 0);
 
-	d = debugfs_create_blob("flat-device-tree", S_IFREG | S_IRUSR,
-				d, &flat_dt_blob);
-	if (!d)
-		return -ENOENT;
+	if (!initial_boot_params)
+		return 0;
 
-	return 0;
+	if (of_fdt_crc32 != crc32_be(~0, initial_boot_params,
+				     fdt_totalsize(initial_boot_params))) {
+		pr_warn("fdt: not creating '/sys/firmware/fdt': CRC check failed\n");
+		return 0;
+	}
+	of_fdt_raw_attr.size = fdt_totalsize(initial_boot_params);
+	return sysfs_create_bin_file(firmware_kobj, &of_fdt_raw_attr);
 }
-module_init(of_flat_dt_debugfs_export_fdt);
+late_initcall(of_fdt_raw_init);
 #endif
 
 #endif /* CONFIG_OF_EARLY_FLATTREE */

commit ab74d00a39f70e1bc34a01322bb59f3750ca7a8c
Author: Kevin Cernekee <cernekee@gmail.com>
Date:   Sun Nov 9 00:55:47 2014 -0800

    of: Fix crash if an earlycon driver is not found
    
    __earlycon_of_table_sentinel.compatible is a char[128], not a pointer, so
    it will never be NULL.  Checking it against NULL causes the match loop to
    run past the end of the array, and eventually match a bogus entry, under
    the following conditions:
    
     - Kernel command line specifies "earlycon" with no parameters
     - DT has a stdout-path pointing to a UART node
     - The UART driver doesn't use OF_EARLYCON_DECLARE (or maybe the console
       driver is compiled out)
    
    Fix this by checking to see if match->compatible is a non-empty string.
    
    Signed-off-by: Kevin Cernekee <cernekee@gmail.com>
    Cc: <stable@vger.kernel.org> # 3.16+
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index d1ffca8b34ea..30e97bcc4f88 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -773,7 +773,7 @@ int __init early_init_dt_scan_chosen_serial(void)
 	if (offset < 0)
 		return -ENODEV;
 
-	while (match->compatible) {
+	while (match->compatible[0]) {
 		unsigned long addr;
 		if (fdt_node_check_compatible(fdt, offset, match->compatible)) {
 			match++;

commit 8cccffc52694938fc88f3d90bc7fed8460e27191
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Oct 29 17:09:32 2014 +0100

    of: check for size < 0 after rounding in early_init_dt_add_memory_arch
    
    Memory regions passed to early_init_dt_add_memory_arch() are rounded to
    PAGE_SIZE by subtracting the size of the leading fractional page from
    the 'size' argument. However, size being a u64 type, if its value is
    sufficiently small, the subtraction wraps around and produces a bogus
    value, potentially leading to crashes.
    
    Fix this by ignoring the memory range in such cases.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 535124670257..83a8e1154602 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -928,6 +928,11 @@ void __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)
 	const u64 phys_offset = __pa(PAGE_OFFSET);
 
 	if (!PAGE_ALIGNED(base)) {
+		if (size < PAGE_SIZE - (base & ~PAGE_MASK)) {
+			pr_warn("Ignoring memory block 0x%llx - 0x%llx\n",
+				base, base + size);
+			return;
+		}
 		size -= PAGE_SIZE - (base & ~PAGE_MASK);
 		base = PAGE_ALIGN(base);
 	}

commit 50ba08f301a1b0310775deeed00c9b24ba75fe8a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Oct 29 12:15:00 2014 -0600

    of/fdt: Don't clear initial_boot_params if fdt_check_header() fails
    
    If the device tree pointer is NULL, early_init_dt_verify() fails, leaving
    initial_boot_params unchanged.  If the device tree pointer is non-NULL but
    invalid, early_init_dt_verify() again fails but this time it also clears
    initial_boot_params.
    
    Leave initial_boot_params unchanged if the device tree pointer is invalid.
    This doesn't fix a bug, but it makes the behavior more consistent and
    easier to analyze.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Zhen Lei <thunder.leizhen@huawei.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 1d30b9f96466..535124670257 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -992,15 +992,12 @@ bool __init early_init_dt_verify(void *params)
 	if (!params)
 		return false;
 
-	/* Setup flat device-tree pointer */
-	initial_boot_params = params;
-
 	/* check device tree validity */
-	if (fdt_check_header(params)) {
-		initial_boot_params = NULL;
+	if (fdt_check_header(params))
 		return false;
-	}
 
+	/* Setup flat device-tree pointer */
+	initial_boot_params = params;
 	return true;
 }
 

commit 5063e25a302e6a83f6590d9a06bd5f6400b17430
Author: Grant Likely <grant.likely@linaro.org>
Date:   Fri Oct 3 16:28:27 2014 +0100

    of: Eliminate of_allnodes list
    
    The device tree structure is composed of two lists; the 'allnodes' list
    which is a singly linked list containing every node in the tree, and the
    child->parent structure where each parent node has a singly linked list
    of children. All of the data in the allnodes list can be easily
    reproduced with the parent-child lists, so of_allnodes is actually
    unnecessary. Remove it entirely which saves a bit of memory and
    simplifies the data structure quite a lot.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Gaurav Minocha <gaurav.minocha.os@gmail.com>
    Cc: Pantelis Antoniou <pantelis@pantelis.antoniou@konsulko.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index d1ffca8b34ea..1d30b9f96466 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -145,15 +145,15 @@ static void *unflatten_dt_alloc(void **mem, unsigned long size,
  * @mem: Memory chunk to use for allocating device nodes and properties
  * @p: pointer to node in flat tree
  * @dad: Parent struct device_node
- * @allnextpp: pointer to ->allnext from last allocated device_node
  * @fpsize: Size of the node path up at the current depth.
  */
 static void * unflatten_dt_node(void *blob,
 				void *mem,
 				int *poffset,
 				struct device_node *dad,
-				struct device_node ***allnextpp,
-				unsigned long fpsize)
+				struct device_node **nodepp,
+				unsigned long fpsize,
+				bool dryrun)
 {
 	const __be32 *p;
 	struct device_node *np;
@@ -200,7 +200,7 @@ static void * unflatten_dt_node(void *blob,
 
 	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
 				__alignof__(struct device_node));
-	if (allnextpp) {
+	if (!dryrun) {
 		char *fn;
 		of_node_init(np);
 		np->full_name = fn = ((char *)np) + sizeof(*np);
@@ -222,8 +222,6 @@ static void * unflatten_dt_node(void *blob,
 		memcpy(fn, pathp, l);
 
 		prev_pp = &np->properties;
-		**allnextpp = np;
-		*allnextpp = &np->allnext;
 		if (dad != NULL) {
 			np->parent = dad;
 			/* we temporarily use the next field as `last_child'*/
@@ -254,7 +252,7 @@ static void * unflatten_dt_node(void *blob,
 			has_name = 1;
 		pp = unflatten_dt_alloc(&mem, sizeof(struct property),
 					__alignof__(struct property));
-		if (allnextpp) {
+		if (!dryrun) {
 			/* We accept flattened tree phandles either in
 			 * ePAPR-style "phandle" properties, or the
 			 * legacy "linux,phandle" properties.  If both
@@ -296,7 +294,7 @@ static void * unflatten_dt_node(void *blob,
 		sz = (pa - ps) + 1;
 		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
 					__alignof__(struct property));
-		if (allnextpp) {
+		if (!dryrun) {
 			pp->name = "name";
 			pp->length = sz;
 			pp->value = pp + 1;
@@ -308,7 +306,7 @@ static void * unflatten_dt_node(void *blob,
 				(char *)pp->value);
 		}
 	}
-	if (allnextpp) {
+	if (!dryrun) {
 		*prev_pp = NULL;
 		np->name = of_get_property(np, "name", NULL);
 		np->type = of_get_property(np, "device_type", NULL);
@@ -324,11 +322,13 @@ static void * unflatten_dt_node(void *blob,
 	if (depth < 0)
 		depth = 0;
 	while (*poffset > 0 && depth > old_depth)
-		mem = unflatten_dt_node(blob, mem, poffset, np, allnextpp,
-					fpsize);
+		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
+					fpsize, dryrun);
 
 	if (*poffset < 0 && *poffset != -FDT_ERR_NOTFOUND)
 		pr_err("unflatten: error %d processing FDT\n", *poffset);
+	if (nodepp)
+		*nodepp = np;
 
 	return mem;
 }
@@ -352,7 +352,6 @@ static void __unflatten_device_tree(void *blob,
 	unsigned long size;
 	int start;
 	void *mem;
-	struct device_node **allnextp = mynodes;
 
 	pr_debug(" -> unflatten_device_tree()\n");
 
@@ -373,7 +372,7 @@ static void __unflatten_device_tree(void *blob,
 
 	/* First pass, scan for size */
 	start = 0;
-	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0);
+	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0, true);
 	size = ALIGN(size, 4);
 
 	pr_debug("  size is %lx, allocating...\n", size);
@@ -388,11 +387,10 @@ static void __unflatten_device_tree(void *blob,
 
 	/* Second pass, do actual unflattening */
 	start = 0;
-	unflatten_dt_node(blob, mem, &start, NULL, &allnextp, 0);
+	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
 	if (be32_to_cpup(mem + size) != 0xdeadbeef)
 		pr_warning("End of tree marker overwritten: %08x\n",
 			   be32_to_cpup(mem + size));
-	*allnextp = NULL;
 
 	pr_debug(" <- unflatten_device_tree()\n");
 }
@@ -1041,7 +1039,7 @@ bool __init early_init_dt_scan(void *params)
  */
 void __init unflatten_device_tree(void)
 {
-	__unflatten_device_tree(initial_boot_params, &of_allnodes,
+	__unflatten_device_tree(initial_boot_params, &of_root,
 				early_init_dt_alloc_memory_arch);
 
 	/* Get pointer to "/chosen" and "/aliases" nodes for use everywhere */

commit 9aacd602f0246f1b1f3c4684b2ab13d0772976f7
Author: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
Date:   Tue Sep 23 10:59:09 2014 +0100

    of/fdt: fix memory range check
    
    In cases where board has below memory DT node
    
    memory{
            device_type = "memory";
            reg = <0x80000000 0x80000000>;
    };
    
    Check on the memory range in fdt.c will always fail because it is
    comparing MAX_PHYS_ADDR with base + size, in fact it should compare
    it with base + size - 1.
    
    This issue was originally noticed on Qualcomm IFC6410 board.
    Without this patch kernel shows up noticed unnecessary warnings
    
    [    0.000000] Machine model: Qualcomm APQ8064/IFC6410
    [    0.000000] Ignoring memory range 0xffffffff - 0x100000000
    [    0.000000] cma: Reserved 64 MiB at ab800000
    
    as a result the size get reduced to 0x7fffffff which looks wrong.
    
    This patch fixes the check involved in generating this warning and
    as a result it also fixes the wrong size calculation.
    
    Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    [grant.likely: adjust new size calculation also]
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 2d34afb2647d..d1ffca8b34ea 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -941,10 +941,10 @@ void __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)
 		return;
 	}
 
-	if (base + size > MAX_PHYS_ADDR) {
-		pr_warning("Ignoring memory range 0x%lx - 0x%llx\n",
-				ULONG_MAX, base + size);
-		size = MAX_PHYS_ADDR - base;
+	if (base + size - 1 > MAX_PHYS_ADDR) {
+		pr_warning("Ignoring memory range 0x%llx - 0x%llx\n",
+				((u64)MAX_PHYS_ADDR) + 1, base + size);
+		size = MAX_PHYS_ADDR - base + 1;
 	}
 
 	if (base + size < phys_offset) {

commit 8f73d4b7011061f46ba6f46006b2848b412ff43f
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Aug 20 17:10:31 2014 +0200

    of: Fix memory block alignment in early_init_dt_add_memory_arch()
    
    If a memory block is not aligned to PAGE_SIZE, its base address must be
    rounded up, not down, and its size must be reduced.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 79cb8313c7d8..2d34afb2647d 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -928,7 +928,11 @@ int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
 void __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)
 {
 	const u64 phys_offset = __pa(PAGE_OFFSET);
-	base &= PAGE_MASK;
+
+	if (!PAGE_ALIGNED(base)) {
+		size -= PAGE_SIZE - (base & ~PAGE_MASK);
+		base = PAGE_ALIGN(base);
+	}
 	size &= PAGE_MASK;
 
 	if (base > MAX_PHYS_ADDR) {

commit b5f2a8c02697c3685ccbbb66495465742ffa0dc1
Author: Al Cooper <alcooperx@gmail.com>
Date:   Wed Aug 6 16:30:04 2014 -0400

    of: Allow mem_reserve of memory with a base address of zero
    
    __reserved_mem_reserve_reg() won't reserve memory if the base address
    is zero. This change removes the check for a base address of zero and
    allows it to be reserved.
    
    Allowing the first 4K of memory to be reserved will help solve a
    problem on some ARM systems where the the first 16K of memory is
    unused and becomes allocable memory. This will prevent this memory
    from being used for DMA by drivers like the USB OHCI driver which
    consider a physical address of zero to be illegal.
    
    Cc: stable@vger.kernel.org # 3.15+
    Signed-off-by: Al Cooper <alcooperx@gmail.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index f46a24ffa3fe..79cb8313c7d8 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -453,7 +453,7 @@ static int __init __reserved_mem_reserve_reg(unsigned long node,
 		base = dt_mem_next_cell(dt_root_addr_cells, &prop);
 		size = dt_mem_next_cell(dt_root_size_cells, &prop);
 
-		if (base && size &&
+		if (size &&
 		    early_init_dt_reserve_memory_arch(base, size, nomap) == 0)
 			pr_debug("Reserved memory: reserved region for node '%s': base %pa, size %ld MiB\n",
 				uname, &base, (unsigned long)size / SZ_1M);

commit ae36e95cf81c98b111b84317adeb358aaffa80e2
Merge: cc8a44c671fd 663d3f7c2e5e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Aug 14 09:53:39 2014 -0600

    Merge tag 'devicetree-for-linus' of git://git.secretlab.ca/git/linux
    
    Pull device tree updates from Grant Likely:
     "The branch contains the following device tree changes the v3.17 merge
      window:
    
      Group changes to the device tree.  In preparation for adding device
      tree overlay support, OF_DYNAMIC is reworked so that a set of device
      tree changes can be prepared and applied to the tree all at once.
      OF_RECONFIG notifiers see the most significant change here so that
      users always get a consistent view of the tree.  Notifiers generation
      is moved from before a change to after it, and notifiers for a group
      of changes are emitted after the entire block of changes have been
      applied
    
      Automatic console selection from DT.  Console drivers can now use
      of_console_check() to see if the device node is specified as a console
      device.  If so then it gets added as a preferred console.  UART
      devices get this support automatically when uart_add_one_port() is
      called.
    
      DT unit tests no longer depend on pre-loaded data in the device tree.
      Data is loaded dynamically at the start of unit tests, and then
      unloaded again when the tests have completed.
    
      Also contains a few bugfixes for reserved regions and early memory
      setup"
    
    * tag 'devicetree-for-linus' of git://git.secretlab.ca/git/linux: (21 commits)
      of: Fixing OF Selftest build error
      drivers: of: add automated assignment of reserved regions to client devices
      of: Use proper types for checking memory overflow
      of: typo fix in __of_prop_dup()
      Adding selftest testdata dynamically into live tree
      of: Add todo tasklist for Devicetree
      of: Transactional DT support.
      of: Reorder device tree changes and notifiers
      of: Move dynamic node fixups out of powerpc and into common code
      of: Make sure attached nodes don't carry along extra children
      of: Make devicetree sysfs update functions consistent.
      of: Create unlocked versions of node and property add/remove functions
      OF: Utility helper functions for dynamic nodes
      of: Move CONFIG_OF_DYNAMIC code into a separate file
      of: rename of_aliases_mutex to just of_mutex
      of/platform: Fix of_platform_device_destroy iteration of devices
      of: Migrate of_find_node_by_name() users to for_each_node_by_name()
      tty: Update hypervisor tty drivers to use core stdout parsing code.
      arm/versatile: Add the uart as the stdout device.
      of: Enable console on serial ports specified by /chosen/stdout-path
      ...

commit 3069f0c07f8d64ebf6ff5d2d1553e0a6dad4316e
Author: Laura Abbott <lauraa@codeaurora.org>
Date:   Mon Jul 7 17:45:43 2014 -0700

    of: Use proper types for checking memory overflow
    
    Commit a67a6ed15513541579d38bcbd127e7be170710e5
    (of: Check for phys_addr_t overflows in early_init_dt_add_memory_arch)
    corrected early_init_dt_add_memory_arch to account for overflows
    but did so in an unclean way using ULONG_MAX. There is no
    guarantee that sizeof(unsigned long) == sizeof(phys_addr_t).
    Check against phys_addr_t instead.
    
    Signed-off-by: Laura Abbott <lauraa@codeaurora.org>
    Tested-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index b777d8f46bd5..b88a68eee86b 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -875,24 +875,24 @@ int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
 }
 
 #ifdef CONFIG_HAVE_MEMBLOCK
+#define MAX_PHYS_ADDR	((phys_addr_t)~0)
+
 void __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)
 {
 	const u64 phys_offset = __pa(PAGE_OFFSET);
 	base &= PAGE_MASK;
 	size &= PAGE_MASK;
 
-	if (sizeof(phys_addr_t) < sizeof(u64)) {
-		if (base > ULONG_MAX) {
-			pr_warning("Ignoring memory block 0x%llx - 0x%llx\n",
-					base, base + size);
-			return;
-		}
+	if (base > MAX_PHYS_ADDR) {
+		pr_warning("Ignoring memory block 0x%llx - 0x%llx\n",
+				base, base + size);
+		return;
+	}
 
-		if (base + size > ULONG_MAX) {
-			pr_warning("Ignoring memory range 0x%lx - 0x%llx\n",
-					ULONG_MAX, base + size);
-			size = ULONG_MAX - base;
-		}
+	if (base + size > MAX_PHYS_ADDR) {
+		pr_warning("Ignoring memory range 0x%lx - 0x%llx\n",
+				ULONG_MAX, base + size);
+		size = MAX_PHYS_ADDR - base;
 	}
 
 	if (base + size < phys_offset) {

commit 704033cee2e5b3c1c6eaf5bb398e465a9c3667b5
Author: Laura Abbott <lauraa@codeaurora.org>
Date:   Tue Jul 15 10:03:35 2014 -0700

    of: Add memory limiting function for flattened devicetrees
    
    Buggy bootloaders may pass bogus memory entries in the devicetree.
    Add of_fdt_limit_memory to add an upper bound on the number of
    entries that can be present in the devicetree.
    
    Signed-off-by: Laura Abbott <lauraa@codeaurora.org>
    Tested-by: Andreas Färber <afaerber@suse.de>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index ecc7a02d868e..9aa012e6ea0a 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -26,6 +26,54 @@
 #include <asm/setup.h>  /* for COMMAND_LINE_SIZE */
 #include <asm/page.h>
 
+/*
+ * of_fdt_limit_memory - limit the number of regions in the /memory node
+ * @limit: maximum entries
+ *
+ * Adjust the flattened device tree to have at most 'limit' number of
+ * memory entries in the /memory node. This function may be called
+ * any time after initial_boot_param is set.
+ */
+void of_fdt_limit_memory(int limit)
+{
+	int memory;
+	int len;
+	const void *val;
+	int nr_address_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;
+	int nr_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
+	const uint32_t *addr_prop;
+	const uint32_t *size_prop;
+	int root_offset;
+	int cell_size;
+
+	root_offset = fdt_path_offset(initial_boot_params, "/");
+	if (root_offset < 0)
+		return;
+
+	addr_prop = fdt_getprop(initial_boot_params, root_offset,
+				"#address-cells", NULL);
+	if (addr_prop)
+		nr_address_cells = fdt32_to_cpu(*addr_prop);
+
+	size_prop = fdt_getprop(initial_boot_params, root_offset,
+				"#size-cells", NULL);
+	if (size_prop)
+		nr_size_cells = fdt32_to_cpu(*size_prop);
+
+	cell_size = sizeof(uint32_t)*(nr_address_cells + nr_size_cells);
+
+	memory = fdt_path_offset(initial_boot_params, "/memory");
+	if (memory > 0) {
+		val = fdt_getprop(initial_boot_params, memory, "reg", &len);
+		if (len > limit*cell_size) {
+			len = limit*cell_size;
+			pr_debug("Limiting number of entries to %d\n", limit);
+			fdt_setprop(initial_boot_params, memory, "reg", val,
+					len);
+		}
+	}
+}
+
 /**
  * of_fdt_is_compatible - Return true if given node from the given blob has
  * compat in its compatible list

commit 4972a74b888c6b52ca41fae6076786dbbeb746d5
Author: Laura Abbott <lauraa@codeaurora.org>
Date:   Tue Jul 15 10:03:34 2014 -0700

    of: Split early_init_dt_scan into two parts
    
    Currently, early_init_dt_scan validates the header, sets the
    boot params, and scans for chosen/memory all in one function.
    Split this up into two separate functions (validation/setting
    boot params in one, scanning in another) to allow for
    additional setup between boot params and scanning the memory.
    
    Signed-off-by: Laura Abbott <lauraa@codeaurora.org>
    Tested-by: Andreas Färber <afaerber@suse.de>
    [glikely: s/early_init_dt_scan_all/early_init_dt_scan_nodes/]
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index b777d8f46bd5..ecc7a02d868e 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -937,7 +937,7 @@ int __init __weak early_init_dt_reserve_memory_arch(phys_addr_t base,
 }
 #endif
 
-bool __init early_init_dt_scan(void *params)
+bool __init early_init_dt_verify(void *params)
 {
 	if (!params)
 		return false;
@@ -951,6 +951,12 @@ bool __init early_init_dt_scan(void *params)
 		return false;
 	}
 
+	return true;
+}
+
+
+void __init early_init_dt_scan_nodes(void)
+{
 	/* Retrieve various information from the /chosen node */
 	of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);
 
@@ -959,7 +965,17 @@ bool __init early_init_dt_scan(void *params)
 
 	/* Setup memory, calling early_init_dt_add_memory_arch */
 	of_scan_flat_dt(early_init_dt_scan_memory, NULL);
+}
+
+bool __init early_init_dt_scan(void *params)
+{
+	bool status;
+
+	status = early_init_dt_verify(params);
+	if (!status)
+		return false;
 
+	early_init_dt_scan_nodes();
 	return true;
 }
 

commit a67a6ed15513541579d38bcbd127e7be170710e5
Author: Laura Abbott <lauraa@codeaurora.org>
Date:   Thu Jun 19 20:13:38 2014 -0700

    of: Check for phys_addr_t overflows in early_init_dt_add_memory_arch
    
    The common early_init_dt_add_memory_arch takes the base and size
    of a memory region as u64 types. The function never checks if
    the base and size can actually fit in a phys_addr_t which may
    be smaller than 64-bits. This may result in incorrect memory
    being passed to memblock_add if the memory falls outside the
    range of phys_addr_t. Add range checks for the base and size if
    phys_addr_t is smaller than u64.
    
    Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Tested-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Laura Abbott <lauraa@codeaurora.org>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index c4cddf0cd96d..b777d8f46bd5 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -880,6 +880,21 @@ void __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)
 	const u64 phys_offset = __pa(PAGE_OFFSET);
 	base &= PAGE_MASK;
 	size &= PAGE_MASK;
+
+	if (sizeof(phys_addr_t) < sizeof(u64)) {
+		if (base > ULONG_MAX) {
+			pr_warning("Ignoring memory block 0x%llx - 0x%llx\n",
+					base, base + size);
+			return;
+		}
+
+		if (base + size > ULONG_MAX) {
+			pr_warning("Ignoring memory range 0x%lx - 0x%llx\n",
+					ULONG_MAX, base + size);
+			size = ULONG_MAX - base;
+		}
+	}
+
 	if (base + size < phys_offset) {
 		pr_warning("Ignoring memory block 0x%llx - 0x%llx\n",
 			   base, base + size);

commit 728dd198aa543397c88f6f8e35f4f187b2bbc09d
Merge: e723e4429983 45e0f0f56843
Author: Rob Herring <robh@kernel.org>
Date:   Wed May 28 11:23:39 2014 -0500

    Merge branch 'earlycon-dt' into for-next

commit b44aa25d20e2ef6b824901cbc50a281791f3b421
Author: Leif Lindholm <leif.lindholm@linaro.org>
Date:   Thu Apr 17 18:42:01 2014 +0100

    of: Handle memory@0 node on PPC32 only
    
    In order to deal with an firmware bug on a specific ppc32 platform
    (longtrail), early_init_dt_scan_memory() looks for a node called
    memory@0 on all platforms. Restrict this quirk to ppc32 kernels only.
    
    Signed-off-by: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: devicetree@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index d429826b61a5..17be90f5445f 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -748,7 +748,7 @@ int __init early_init_dt_scan_memory(unsigned long node, const char *uname,
 		 * The longtrail doesn't have a device_type on the
 		 * /memory node, so look for the node called /memory@0.
 		 */
-		if (depth != 1 || strcmp(uname, "memory@0") != 0)
+		if (!IS_ENABLED(CONFIG_PPC32) || depth != 1 || strcmp(uname, "memory@0") != 0)
 			return 0;
 	} else if (strcmp(type, "memory") != 0)
 		return 0;

commit d2d3d7cd81e90e1ffac1a6eed7b3edcbf11f4c97
Author: Thierry Reding <treding@nvidia.com>
Date:   Wed Apr 2 09:47:01 2014 +0200

    of: Use NULL for pointers
    
    Commit 4485681939b9 (of/fdt: Clean up casting in unflattening path)
    modified unflatten_dt_node() to take a void * for the mem parameter
    instead of an unsigned long. One of the call sites wasn't updated.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    
    Conflicts:
            drivers/of/fdt.c

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index a6f83ea107ae..d429826b61a5 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -324,7 +324,7 @@ static void __unflatten_device_tree(void *blob,
 
 	/* First pass, scan for size */
 	start = 0;
-	size = (unsigned long)unflatten_dt_node(blob, 0, &start, NULL, NULL, 0);
+	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0);
 	size = ALIGN(size, 4);
 
 	pr_debug("  size is %lx, allocating...\n", size);

commit fb11ffe74c794a510a29ad8cd81d4e9e3b1c9158
Author: Rob Herring <robh@kernel.org>
Date:   Thu Mar 27 08:07:01 2014 -0500

    of/fdt: add FDT serial scanning for earlycon
    
    This adds FDT parsing of {linux,}stdout-path to setup an early serial
    console. Enabling of the early console is triggered with "earlycon"
    (with no options) on the kernel command line.
    
    Platforms must either have fixmap permanent mapping support,
    have a functioning ioremap when early params are parsed, or explicitly
    call early_init_dt_scan_chosen_serial from architecture code.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Acked-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index a6f83ea107ae..1fbeab27075f 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -21,6 +21,7 @@
 #include <linux/slab.h>
 #include <linux/libfdt.h>
 #include <linux/debugfs.h>
+#include <linux/serial_core.h>
 
 #include <asm/setup.h>  /* for COMMAND_LINE_SIZE */
 #include <asm/page.h>
@@ -696,6 +697,61 @@ static inline void early_init_dt_check_for_initrd(unsigned long node)
 }
 #endif /* CONFIG_BLK_DEV_INITRD */
 
+#ifdef CONFIG_SERIAL_EARLYCON
+extern struct of_device_id __earlycon_of_table[];
+
+int __init early_init_dt_scan_chosen_serial(void)
+{
+	int offset;
+	const char *p;
+	int l;
+	const struct of_device_id *match = __earlycon_of_table;
+	const void *fdt = initial_boot_params;
+
+	offset = fdt_path_offset(fdt, "/chosen");
+	if (offset < 0)
+		offset = fdt_path_offset(fdt, "/chosen@0");
+	if (offset < 0)
+		return -ENOENT;
+
+	p = fdt_getprop(fdt, offset, "stdout-path", &l);
+	if (!p)
+		p = fdt_getprop(fdt, offset, "linux,stdout-path", &l);
+	if (!p || !l)
+		return -ENOENT;
+
+	/* Get the node specified by stdout-path */
+	offset = fdt_path_offset(fdt, p);
+	if (offset < 0)
+		return -ENODEV;
+
+	while (match->compatible) {
+		unsigned long addr;
+		if (fdt_node_check_compatible(fdt, offset, match->compatible)) {
+			match++;
+			continue;
+		}
+
+		addr = fdt_translate_address(fdt, offset);
+		if (!addr)
+			return -ENXIO;
+
+		of_setup_earlycon(addr, match->data);
+		return 0;
+	}
+	return -ENODEV;
+}
+
+static int __init setup_of_earlycon(char *buf)
+{
+	if (buf)
+		return 0;
+
+	return early_init_dt_scan_chosen_serial();
+}
+early_param("earlycon", setup_of_earlycon);
+#endif
+
 /**
  * early_init_dt_scan_root - fetch the top level address and size cells
  */

commit 1daa0c4ced334f18f458aba6ace7e01e8cdc2ecf
Author: Rob Herring <robh@kernel.org>
Date:   Mon Mar 31 15:25:04 2014 -0500

    of/fdt: convert initial_boot_params to opaque pointer
    
    Now that all accesses to FDT header data has been converted to accessor
    helpers, initial_boot_params can become an opaque pointer.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Tested-by: Michal Simek <michal.simek@xilinx.com>
    Tested-by: Grant Likely <grant.likely@linaro.org>
    Tested-by: Stephen Chivers <schivers@csc.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 358bcf0500d2..a6f83ea107ae 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -372,7 +372,7 @@ EXPORT_SYMBOL_GPL(of_fdt_unflatten_tree);
 int __initdata dt_root_addr_cells;
 int __initdata dt_root_size_cells;
 
-struct boot_param_header *initial_boot_params;
+void *initial_boot_params;
 
 #ifdef CONFIG_OF_EARLY_FLATTREE
 

commit c0556d3f2c3f42eaed049139ce6f0899ecdb0217
Author: Rob Herring <robh@kernel.org>
Date:   Tue Apr 22 12:55:10 2014 -0500

    of/fdt: introduce of_get_flat_dt_size
    
    Add a wrapper function to retrieve the FDT size from the FDT header. This
    is primarily to avoid libfdt include paths for the whole kernel.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Tested-by: Grant Likely <grant.likely@linaro.org>
    Tested-by: Stephen Chivers <schivers@csc.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index d9e64504cda0..358bcf0500d2 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -553,6 +553,14 @@ unsigned long __init of_get_flat_dt_root(void)
 	return 0;
 }
 
+/**
+ * of_get_flat_dt_size - Return the total size of the FDT
+ */
+int __init of_get_flat_dt_size(void)
+{
+	return fdt_totalsize(initial_boot_params);
+}
+
 /**
  * of_get_flat_dt_prop - Given a node in the flat blob, return the property ptr
  *

commit 1d1a661da4c8468b3fa6f567b2b1f8cdeafa847a
Author: Rob Herring <robh@kernel.org>
Date:   Tue Apr 22 12:50:24 2014 -0500

    of/fdt: fix phys_addr_t related print size warnings
    
    Fix warnings in early_init_dt_reserve_memory_arch when phys_addr_t is
    32-bit and memblock is not enabled.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Tested-by: Grant Likely <grant.likely@linaro.org>
    Tested-by: Stephen Chivers <schivers@csc.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 051be4ca25b9..d9e64504cda0 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -852,8 +852,8 @@ void * __init __weak early_init_dt_alloc_memory_arch(u64 size, u64 align)
 int __init __weak early_init_dt_reserve_memory_arch(phys_addr_t base,
 					phys_addr_t size, bool nomap)
 {
-	pr_err("Reserved memory not supported, ignoring range 0x%llx - 0x%llx%s\n",
-		  base, size, nomap ? " (nomap)" : "");
+	pr_err("Reserved memory not supported, ignoring range 0x%pa - 0x%pa%s\n",
+		  &base, &size, nomap ? " (nomap)" : "");
 	return -ENOSYS;
 }
 #endif

commit d1552ce449eb0a8d2f0bd6599da3a8a3d7f77a84
Author: Rob Herring <robh@kernel.org>
Date:   Tue Apr 1 22:46:48 2014 -0500

    of/fdt: move memreserve and dtb memory reservations into core
    
    Move the /memreserve/ processing and dtb memory reservations into
    early_init_fdt_scan_reserved_mem. This converts arm, arm64, and powerpc
    as they are the only users of early_init_fdt_scan_reserved_mem.
    
    memblock_reserve is safe to call on the same region twice, so the
    reservation check for the dtb in powerpc 32-bit reservations is safe to
    remove.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Tested-by: Michal Simek <michal.simek@xilinx.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Tested-by: Grant Likely <grant.likely@linaro.org>
    Tested-by: Stephen Chivers <schivers@csc.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 4129f7442244..051be4ca25b9 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -492,9 +492,25 @@ static int __init __fdt_scan_reserved_mem(unsigned long node, const char *uname,
  */
 void __init early_init_fdt_scan_reserved_mem(void)
 {
+	int n;
+	u64 base, size;
+
 	if (!initial_boot_params)
 		return;
 
+	/* Reserve the dtb region */
+	early_init_dt_reserve_memory_arch(__pa(initial_boot_params),
+					  fdt_totalsize(initial_boot_params),
+					  0);
+
+	/* Process header /memreserve/ fields */
+	for (n = 0; ; n++) {
+		fdt_get_mem_rsv(initial_boot_params, n, &base, &size);
+		if (!size)
+			break;
+		early_init_dt_reserve_memory_arch(base, size, 0);
+	}
+
 	of_scan_flat_dt(__fdt_scan_reserved_mem, NULL);
 	fdt_init_reserved_mem();
 }

commit b0a6fb36a49f720c93c3da0b3f040e49e42435ad
Author: Rob Herring <robh@kernel.org>
Date:   Wed Apr 2 16:56:48 2014 -0500

    of/fdt: create common debugfs
    
    Both powerpc and microblaze have the same FDT blob in debugfs feature.
    Move this to common location and remove the powerpc and microblaze
    implementations. This feature could become more useful when FDT
    overlay support is added.
    
    This changes the path of the blob from "$arch/flat-device-tree" to
    "device-tree/flat-device-tree".
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Tested-by: Michal Simek <michal.simek@xilinx.com>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: linuxppc-dev@lists.ozlabs.org
    Tested-by: Grant Likely <grant.likely@linaro.org>
    Tested-by: Stephen Chivers <schivers@csc.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 0b38a6aa8603..4129f7442244 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -20,6 +20,7 @@
 #include <linux/errno.h>
 #include <linux/slab.h>
 #include <linux/libfdt.h>
+#include <linux/debugfs.h>
 
 #include <asm/setup.h>  /* for COMMAND_LINE_SIZE */
 #include <asm/page.h>
@@ -916,4 +917,27 @@ void __init unflatten_and_copy_device_tree(void)
 	unflatten_device_tree();
 }
 
+#if defined(CONFIG_DEBUG_FS) && defined(DEBUG)
+static struct debugfs_blob_wrapper flat_dt_blob;
+
+static int __init of_flat_dt_debugfs_export_fdt(void)
+{
+	struct dentry *d = debugfs_create_dir("device-tree", NULL);
+
+	if (!d)
+		return -ENOENT;
+
+	flat_dt_blob.data = initial_boot_params;
+	flat_dt_blob.size = fdt_totalsize(initial_boot_params);
+
+	d = debugfs_create_blob("flat-device-tree", S_IFREG | S_IRUSR,
+				d, &flat_dt_blob);
+	if (!d)
+		return -ENOENT;
+
+	return 0;
+}
+module_init(of_flat_dt_debugfs_export_fdt);
+#endif
+
 #endif /* CONFIG_OF_EARLY_FLATTREE */

commit c972de14971f1482ab482f0a7abc85679a23326a
Author: Rob Herring <robh@kernel.org>
Date:   Tue Apr 1 22:48:01 2014 -0500

    of/fdt: use libfdt accessors for header data
    
    With libfdt support, we can take advantage of helper accessors in libfdt
    for accessing the FDT header data. This makes the code more readable and
    makes the FDT blob structure more opaque to the kernel. This also
    prepares for removing struct boot_param_header completely.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Tested-by: Michal Simek <michal.simek@xilinx.com>
    Tested-by: Grant Likely <grant.likely@linaro.org>
    Tested-by: Stephen Chivers <schivers@csc.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 8e820a2b106d..0b38a6aa8603 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -34,7 +34,7 @@
  * On match, returns a non-zero value with smaller values returned for more
  * specific compatible values.
  */
-int of_fdt_is_compatible(struct boot_param_header *blob,
+int of_fdt_is_compatible(const void *blob,
 		      unsigned long node, const char *compat)
 {
 	const char *cp;
@@ -59,7 +59,7 @@ int of_fdt_is_compatible(struct boot_param_header *blob,
 /**
  * of_fdt_match - Return true if node matches a list of compatible values
  */
-int of_fdt_match(struct boot_param_header *blob, unsigned long node,
+int of_fdt_match(const void *blob, unsigned long node,
                  const char *const *compat)
 {
 	unsigned int tmp, score = 0;
@@ -98,7 +98,7 @@ static void *unflatten_dt_alloc(void **mem, unsigned long size,
  * @allnextpp: pointer to ->allnext from last allocated device_node
  * @fpsize: Size of the node path up at the current depth.
  */
-static void * unflatten_dt_node(struct boot_param_header *blob,
+static void * unflatten_dt_node(void *blob,
 				void *mem,
 				int *poffset,
 				struct device_node *dad,
@@ -295,7 +295,7 @@ static void * unflatten_dt_node(struct boot_param_header *blob,
  * @dt_alloc: An allocator that provides a virtual address to memory
  * for the resulting tree
  */
-static void __unflatten_device_tree(struct boot_param_header *blob,
+static void __unflatten_device_tree(void *blob,
 			     struct device_node **mynodes,
 			     void * (*dt_alloc)(u64 size, u64 align))
 {
@@ -312,11 +312,11 @@ static void __unflatten_device_tree(struct boot_param_header *blob,
 	}
 
 	pr_debug("Unflattening device tree:\n");
-	pr_debug("magic: %08x\n", be32_to_cpu(blob->magic));
-	pr_debug("size: %08x\n", be32_to_cpu(blob->totalsize));
-	pr_debug("version: %08x\n", be32_to_cpu(blob->version));
+	pr_debug("magic: %08x\n", fdt_magic(blob));
+	pr_debug("size: %08x\n", fdt_totalsize(blob));
+	pr_debug("version: %08x\n", fdt_version(blob));
 
-	if (be32_to_cpu(blob->magic) != OF_DT_HEADER) {
+	if (fdt_check_header(blob)) {
 		pr_err("Invalid device tree blob header\n");
 		return;
 	}
@@ -363,9 +363,7 @@ static void *kernel_tree_alloc(u64 size, u64 align)
 void of_fdt_unflatten_tree(unsigned long *blob,
 			struct device_node **mynodes)
 {
-	struct boot_param_header *device_tree =
-		(struct boot_param_header *)blob;
-	__unflatten_device_tree(device_tree, mynodes, &kernel_tree_alloc);
+	__unflatten_device_tree(blob, mynodes, &kernel_tree_alloc);
 }
 EXPORT_SYMBOL_GPL(of_fdt_unflatten_tree);
 
@@ -852,7 +850,7 @@ bool __init early_init_dt_scan(void *params)
 	initial_boot_params = params;
 
 	/* check device tree validity */
-	if (be32_to_cpu(initial_boot_params->magic) != OF_DT_HEADER) {
+	if (fdt_check_header(params)) {
 		initial_boot_params = NULL;
 		return false;
 	}
@@ -907,9 +905,9 @@ void __init unflatten_and_copy_device_tree(void)
 		return;
 	}
 
-	size = __be32_to_cpu(initial_boot_params->totalsize);
+	size = fdt_totalsize(initial_boot_params);
 	dt = early_init_dt_alloc_memory_arch(size,
-		__alignof__(struct boot_param_header));
+					     roundup_pow_of_two(FDT_V17_SIZE));
 
 	if (dt) {
 		memcpy(dt, initial_boot_params, size);

commit e6a6928c3ea1d0195ed75a091e345696b916c09b
Author: Rob Herring <robh@kernel.org>
Date:   Wed Apr 2 15:10:14 2014 -0500

    of/fdt: Convert FDT functions to use libfdt
    
    The kernel FDT functions predate libfdt and are much more limited in
    functionality. Also, the kernel functions and libfdt functions are
    not compatible with each other because they have different definitions
    of node offsets. To avoid this incompatibility and in preparation to
    add more FDT parsing functions which will need libfdt, let's first
    convert the existing code to use libfdt.
    
    The FDT unflattening, top-level FDT scanning, and property retrieval
    functions are converted to use libfdt. The scanning code should be
    re-worked to be more efficient and understandable by using libfdt to
    find nodes directly by path or compatible strings.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Tested-by: Michal Simek <michal.simek@xilinx.com>
    Tested-by: Grant Likely <grant.likely@linaro.org>
    Tested-by: Stephen Chivers <schivers@csc.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 1d1582bb81fb..8e820a2b106d 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -19,58 +19,11 @@
 #include <linux/string.h>
 #include <linux/errno.h>
 #include <linux/slab.h>
+#include <linux/libfdt.h>
 
 #include <asm/setup.h>  /* for COMMAND_LINE_SIZE */
 #include <asm/page.h>
 
-char *of_fdt_get_string(struct boot_param_header *blob, u32 offset)
-{
-	return ((char *)blob) +
-		be32_to_cpu(blob->off_dt_strings) + offset;
-}
-
-/**
- * of_fdt_get_property - Given a node in the given flat blob, return
- * the property ptr
- */
-void *of_fdt_get_property(struct boot_param_header *blob,
-		       unsigned long node, const char *name,
-		       int *size)
-{
-	unsigned long p = node;
-
-	do {
-		u32 tag = be32_to_cpup((__be32 *)p);
-		u32 sz, noff;
-		const char *nstr;
-
-		p += 4;
-		if (tag == OF_DT_NOP)
-			continue;
-		if (tag != OF_DT_PROP)
-			return NULL;
-
-		sz = be32_to_cpup((__be32 *)p);
-		noff = be32_to_cpup((__be32 *)(p + 4));
-		p += 8;
-		if (be32_to_cpu(blob->version) < 0x10)
-			p = ALIGN(p, sz >= 8 ? 8 : 4);
-
-		nstr = of_fdt_get_string(blob, noff);
-		if (nstr == NULL) {
-			pr_warning("Can't find property index name !\n");
-			return NULL;
-		}
-		if (strcmp(name, nstr) == 0) {
-			if (size)
-				*size = sz;
-			return (void *)p;
-		}
-		p += sz;
-		p = ALIGN(p, 4);
-	} while (1);
-}
-
 /**
  * of_fdt_is_compatible - Return true if given node from the given blob has
  * compat in its compatible list
@@ -88,7 +41,7 @@ int of_fdt_is_compatible(struct boot_param_header *blob,
 	int cplen;
 	unsigned long l, score = 0;
 
-	cp = of_fdt_get_property(blob, node, "compatible", &cplen);
+	cp = fdt_getprop(blob, node, "compatible", &cplen);
 	if (cp == NULL)
 		return 0;
 	while (cplen > 0) {
@@ -147,28 +100,27 @@ static void *unflatten_dt_alloc(void **mem, unsigned long size,
  */
 static void * unflatten_dt_node(struct boot_param_header *blob,
 				void *mem,
-				void **p,
+				int *poffset,
 				struct device_node *dad,
 				struct device_node ***allnextpp,
 				unsigned long fpsize)
 {
+	const __be32 *p;
 	struct device_node *np;
 	struct property *pp, **prev_pp = NULL;
-	char *pathp;
-	u32 tag;
+	const char *pathp;
 	unsigned int l, allocl;
+	static int depth = 0;
+	int old_depth;
+	int offset;
 	int has_name = 0;
 	int new_format = 0;
 
-	tag = be32_to_cpup(*p);
-	if (tag != OF_DT_BEGIN_NODE) {
-		pr_err("Weird tag at start of node: %x\n", tag);
+	pathp = fdt_get_name(blob, *poffset, &l);
+	if (!pathp)
 		return mem;
-	}
-	*p += 4;
-	pathp = *p;
-	l = allocl = strlen(pathp) + 1;
-	*p = PTR_ALIGN(*p + l, 4);
+
+	allocl = l++;
 
 	/* version 0x10 has a more compact unit name here instead of the full
 	 * path. we accumulate the full path size using "fpsize", we'll rebuild
@@ -186,7 +138,7 @@ static void * unflatten_dt_node(struct boot_param_header *blob,
 			fpsize = 1;
 			allocl = 2;
 			l = 1;
-			*pathp = '\0';
+			pathp = "";
 		} else {
 			/* account for '/' and path size minus terminal 0
 			 * already in 'l'
@@ -233,32 +185,23 @@ static void * unflatten_dt_node(struct boot_param_header *blob,
 		}
 	}
 	/* process properties */
-	while (1) {
-		u32 sz, noff;
-		char *pname;
-
-		tag = be32_to_cpup(*p);
-		if (tag == OF_DT_NOP) {
-			*p += 4;
-			continue;
-		}
-		if (tag != OF_DT_PROP)
+	for (offset = fdt_first_property_offset(blob, *poffset);
+	     (offset >= 0);
+	     (offset = fdt_next_property_offset(blob, offset))) {
+		const char *pname;
+		u32 sz;
+
+		if (!(p = fdt_getprop_by_offset(blob, offset, &pname, &sz))) {
+			offset = -FDT_ERR_INTERNAL;
 			break;
-		*p += 4;
-		sz = be32_to_cpup(*p);
-		noff = be32_to_cpup(*p + 4);
-		*p += 8;
-		if (be32_to_cpu(blob->version) < 0x10)
-			*p = PTR_ALIGN(*p, sz >= 8 ? 8 : 4);
-
-		pname = of_fdt_get_string(blob, noff);
+		}
+
 		if (pname == NULL) {
 			pr_info("Can't find property name in list !\n");
 			break;
 		}
 		if (strcmp(pname, "name") == 0)
 			has_name = 1;
-		l = strlen(pname) + 1;
 		pp = unflatten_dt_alloc(&mem, sizeof(struct property),
 					__alignof__(struct property));
 		if (allnextpp) {
@@ -270,26 +213,25 @@ static void * unflatten_dt_node(struct boot_param_header *blob,
 			if ((strcmp(pname, "phandle") == 0) ||
 			    (strcmp(pname, "linux,phandle") == 0)) {
 				if (np->phandle == 0)
-					np->phandle = be32_to_cpup((__be32*)*p);
+					np->phandle = be32_to_cpup(p);
 			}
 			/* And we process the "ibm,phandle" property
 			 * used in pSeries dynamic device tree
 			 * stuff */
 			if (strcmp(pname, "ibm,phandle") == 0)
-				np->phandle = be32_to_cpup((__be32 *)*p);
-			pp->name = pname;
+				np->phandle = be32_to_cpup(p);
+			pp->name = (char *)pname;
 			pp->length = sz;
-			pp->value = *p;
+			pp->value = (__be32 *)p;
 			*prev_pp = pp;
 			prev_pp = &pp->next;
 		}
-		*p = PTR_ALIGN((*p) + sz, 4);
 	}
 	/* with version 0x10 we may not have the name property, recreate
 	 * it here from the unit name if absent
 	 */
 	if (!has_name) {
-		char *p1 = pathp, *ps = pathp, *pa = NULL;
+		const char *p1 = pathp, *ps = pathp, *pa = NULL;
 		int sz;
 
 		while (*p1) {
@@ -326,19 +268,18 @@ static void * unflatten_dt_node(struct boot_param_header *blob,
 		if (!np->type)
 			np->type = "<NULL>";
 	}
-	while (tag == OF_DT_BEGIN_NODE || tag == OF_DT_NOP) {
-		if (tag == OF_DT_NOP)
-			*p += 4;
-		else
-			mem = unflatten_dt_node(blob, mem, p, np, allnextpp,
-						fpsize);
-		tag = be32_to_cpup(*p);
-	}
-	if (tag != OF_DT_END_NODE) {
-		pr_err("Weird tag at end of node: %x\n", tag);
-		return mem;
-	}
-	*p += 4;
+
+	old_depth = depth;
+	*poffset = fdt_next_node(blob, *poffset, &depth);
+	if (depth < 0)
+		depth = 0;
+	while (*poffset > 0 && depth > old_depth)
+		mem = unflatten_dt_node(blob, mem, poffset, np, allnextpp,
+					fpsize);
+
+	if (*poffset < 0 && *poffset != -FDT_ERR_NOTFOUND)
+		pr_err("unflatten: error %d processing FDT\n", *poffset);
+
 	return mem;
 }
 
@@ -359,7 +300,8 @@ static void __unflatten_device_tree(struct boot_param_header *blob,
 			     void * (*dt_alloc)(u64 size, u64 align))
 {
 	unsigned long size;
-	void *start, *mem;
+	int start;
+	void *mem;
 	struct device_node **allnextp = mynodes;
 
 	pr_debug(" -> unflatten_device_tree()\n");
@@ -380,7 +322,7 @@ static void __unflatten_device_tree(struct boot_param_header *blob,
 	}
 
 	/* First pass, scan for size */
-	start = ((void *)blob) + be32_to_cpu(blob->off_dt_struct);
+	start = 0;
 	size = (unsigned long)unflatten_dt_node(blob, 0, &start, NULL, NULL, 0);
 	size = ALIGN(size, 4);
 
@@ -395,10 +337,8 @@ static void __unflatten_device_tree(struct boot_param_header *blob,
 	pr_debug("  unflattening %p...\n", mem);
 
 	/* Second pass, do actual unflattening */
-	start = ((void *)blob) + be32_to_cpu(blob->off_dt_struct);
+	start = 0;
 	unflatten_dt_node(blob, mem, &start, NULL, &allnextp, 0);
-	if (be32_to_cpup(start) != OF_DT_END)
-		pr_warning("Weird tag at end of tree: %08x\n", be32_to_cpup(start));
 	if (be32_to_cpup(mem + size) != 0xdeadbeef)
 		pr_warning("End of tree marker overwritten: %08x\n",
 			   be32_to_cpup(mem + size));
@@ -574,47 +514,19 @@ int __init of_scan_flat_dt(int (*it)(unsigned long node,
 				     void *data),
 			   void *data)
 {
-	unsigned long p = ((unsigned long)initial_boot_params) +
-		be32_to_cpu(initial_boot_params->off_dt_struct);
-	int rc = 0;
-	int depth = -1;
-
-	do {
-		u32 tag = be32_to_cpup((__be32 *)p);
-		const char *pathp;
-
-		p += 4;
-		if (tag == OF_DT_END_NODE) {
-			depth--;
-			continue;
-		}
-		if (tag == OF_DT_NOP)
-			continue;
-		if (tag == OF_DT_END)
-			break;
-		if (tag == OF_DT_PROP) {
-			u32 sz = be32_to_cpup((__be32 *)p);
-			p += 8;
-			if (be32_to_cpu(initial_boot_params->version) < 0x10)
-				p = ALIGN(p, sz >= 8 ? 8 : 4);
-			p += sz;
-			p = ALIGN(p, 4);
-			continue;
-		}
-		if (tag != OF_DT_BEGIN_NODE) {
-			pr_err("Invalid tag %x in flat device tree!\n", tag);
-			return -EINVAL;
-		}
-		depth++;
-		pathp = (char *)p;
-		p = ALIGN(p + strlen(pathp) + 1, 4);
+	const void *blob = initial_boot_params;
+	const char *pathp;
+	int offset, rc = 0, depth = -1;
+
+        for (offset = fdt_next_node(blob, -1, &depth);
+             offset >= 0 && depth >= 0 && !rc;
+             offset = fdt_next_node(blob, offset, &depth)) {
+
+		pathp = fdt_get_name(blob, offset, NULL);
 		if (*pathp == '/')
 			pathp = kbasename(pathp);
-		rc = it(p, pathp, depth, data);
-		if (rc != 0)
-			break;
-	} while (1);
-
+		rc = it(offset, pathp, depth, data);
+	}
 	return rc;
 }
 
@@ -623,14 +535,7 @@ int __init of_scan_flat_dt(int (*it)(unsigned long node,
  */
 unsigned long __init of_get_flat_dt_root(void)
 {
-	unsigned long p = ((unsigned long)initial_boot_params) +
-		be32_to_cpu(initial_boot_params->off_dt_struct);
-
-	while (be32_to_cpup((__be32 *)p) == OF_DT_NOP)
-		p += 4;
-	BUG_ON(be32_to_cpup((__be32 *)p) != OF_DT_BEGIN_NODE);
-	p += 4;
-	return ALIGN(p + strlen((char *)p) + 1, 4);
+	return 0;
 }
 
 /**
@@ -642,7 +547,7 @@ unsigned long __init of_get_flat_dt_root(void)
 const void *__init of_get_flat_dt_prop(unsigned long node, const char *name,
 				       int *size)
 {
-	return of_fdt_get_property(initial_boot_params, node, name, size);
+	return fdt_getprop(initial_boot_params, node, name, size);
 }
 
 /**

commit 9d0c4dfedd96ee54fc075b16d02f82499c8cc3a6
Author: Rob Herring <robh@kernel.org>
Date:   Tue Apr 1 23:49:03 2014 -0500

    of/fdt: update of_get_flat_dt_prop in prep for libfdt
    
    Make of_get_flat_dt_prop arguments compatible with libfdt fdt_getprop
    call in preparation to convert FDT code to use libfdt. Make the return
    value const and the property length ptr type an int.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Tested-by: Michal Simek <michal.simek@xilinx.com>
    Tested-by: Grant Likely <grant.likely@linaro.org>
    Tested-by: Stephen Chivers <schivers@csc.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 9c8535291909..1d1582bb81fb 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -35,7 +35,7 @@ char *of_fdt_get_string(struct boot_param_header *blob, u32 offset)
  */
 void *of_fdt_get_property(struct boot_param_header *blob,
 		       unsigned long node, const char *name,
-		       unsigned long *size)
+		       int *size)
 {
 	unsigned long p = node;
 
@@ -85,7 +85,8 @@ int of_fdt_is_compatible(struct boot_param_header *blob,
 		      unsigned long node, const char *compat)
 {
 	const char *cp;
-	unsigned long cplen, l, score = 0;
+	int cplen;
+	unsigned long l, score = 0;
 
 	cp = of_fdt_get_property(blob, node, "compatible", &cplen);
 	if (cp == NULL)
@@ -444,8 +445,8 @@ static int __init __reserved_mem_reserve_reg(unsigned long node,
 {
 	int t_len = (dt_root_addr_cells + dt_root_size_cells) * sizeof(__be32);
 	phys_addr_t base, size;
-	unsigned long len;
-	__be32 *prop;
+	int len;
+	const __be32 *prop;
 	int nomap, first = 1;
 
 	prop = of_get_flat_dt_prop(node, "reg", &len);
@@ -488,7 +489,7 @@ static int __init __reserved_mem_reserve_reg(unsigned long node,
  */
 static int __init __reserved_mem_check_root(unsigned long node)
 {
-	__be32 *prop;
+	const __be32 *prop;
 
 	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
 	if (!prop || be32_to_cpup(prop) != dt_root_size_cells)
@@ -638,8 +639,8 @@ unsigned long __init of_get_flat_dt_root(void)
  * This function can be used within scan_flattened_dt callback to get
  * access to properties
  */
-void *__init of_get_flat_dt_prop(unsigned long node, const char *name,
-				 unsigned long *size)
+const void *__init of_get_flat_dt_prop(unsigned long node, const char *name,
+				       int *size)
 {
 	return of_fdt_get_property(initial_boot_params, node, name, size);
 }
@@ -710,7 +711,7 @@ const void * __init of_flat_dt_match_machine(const void *default_match,
 	}
 	if (!best_data) {
 		const char *prop;
-		long size;
+		int size;
 
 		pr_err("\n unrecognized device tree list:\n[ ");
 
@@ -739,8 +740,8 @@ const void * __init of_flat_dt_match_machine(const void *default_match,
 static void __init early_init_dt_check_for_initrd(unsigned long node)
 {
 	u64 start, end;
-	unsigned long len;
-	__be32 *prop;
+	int len;
+	const __be32 *prop;
 
 	pr_debug("Looking for initrd properties... ");
 
@@ -773,7 +774,7 @@ static inline void early_init_dt_check_for_initrd(unsigned long node)
 int __init early_init_dt_scan_root(unsigned long node, const char *uname,
 				   int depth, void *data)
 {
-	__be32 *prop;
+	const __be32 *prop;
 
 	if (depth != 0)
 		return 0;
@@ -795,9 +796,9 @@ int __init early_init_dt_scan_root(unsigned long node, const char *uname,
 	return 1;
 }
 
-u64 __init dt_mem_next_cell(int s, __be32 **cellp)
+u64 __init dt_mem_next_cell(int s, const __be32 **cellp)
 {
-	__be32 *p = *cellp;
+	const __be32 *p = *cellp;
 
 	*cellp = p + s;
 	return of_read_number(p, s);
@@ -809,9 +810,9 @@ u64 __init dt_mem_next_cell(int s, __be32 **cellp)
 int __init early_init_dt_scan_memory(unsigned long node, const char *uname,
 				     int depth, void *data)
 {
-	char *type = of_get_flat_dt_prop(node, "device_type", NULL);
-	__be32 *reg, *endp;
-	unsigned long l;
+	const char *type = of_get_flat_dt_prop(node, "device_type", NULL);
+	const __be32 *reg, *endp;
+	int l;
 
 	/* We are scanning "memory" nodes only */
 	if (type == NULL) {
@@ -832,7 +833,7 @@ int __init early_init_dt_scan_memory(unsigned long node, const char *uname,
 
 	endp = reg + (l / sizeof(__be32));
 
-	pr_debug("memory scan node %s, reg size %ld, data: %x %x %x %x,\n",
+	pr_debug("memory scan node %s, reg size %d, data: %x %x %x %x,\n",
 	    uname, l, reg[0], reg[1], reg[2], reg[3]);
 
 	while ((endp - reg) >= (dt_root_addr_cells + dt_root_size_cells)) {
@@ -855,8 +856,8 @@ int __init early_init_dt_scan_memory(unsigned long node, const char *uname,
 int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
 				     int depth, void *data)
 {
-	unsigned long l;
-	char *p;
+	int l;
+	const char *p;
 
 	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);
 

commit bba04d965d06abbbe10afd3687742389107e198e
Author: Rob Herring <robh@kernel.org>
Date:   Sat Mar 29 14:14:17 2014 -0500

    of/fdt: remove unused of_scan_flat_dt_by_path
    
    of_scan_flat_dt_by_path is unused anywhere in the kernel, so remove it.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Tested-by: Michal Simek <michal.simek@xilinx.com>
    Tested-by: Grant Likely <grant.likely@linaro.org>
    Tested-by: Stephen Chivers <schivers@csc.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 63bdcee473fa..9c8535291909 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -671,73 +671,6 @@ struct fdt_scan_status {
 	void *data;
 };
 
-/**
- * fdt_scan_node_by_path - iterator for of_scan_flat_dt_by_path function
- */
-static int __init fdt_scan_node_by_path(unsigned long node, const char *uname,
-					int depth, void *data)
-{
-	struct fdt_scan_status *st = data;
-
-	/*
-	 * if scan at the requested fdt node has been completed,
-	 * return -ENXIO to abort further scanning
-	 */
-	if (depth <= st->depth)
-		return -ENXIO;
-
-	/* requested fdt node has been found, so call iterator function */
-	if (st->found)
-		return st->iterator(node, uname, depth, st->data);
-
-	/* check if scanning automata is entering next level of fdt nodes */
-	if (depth == st->depth + 1 &&
-	    strncmp(st->name, uname, st->namelen) == 0 &&
-	    uname[st->namelen] == 0) {
-		st->depth += 1;
-		if (st->name[st->namelen] == 0) {
-			st->found = 1;
-		} else {
-			const char *next = st->name + st->namelen + 1;
-			st->name = next;
-			st->namelen = strcspn(next, "/");
-		}
-		return 0;
-	}
-
-	/* scan next fdt node */
-	return 0;
-}
-
-/**
- * of_scan_flat_dt_by_path - scan flattened tree blob and call callback on each
- *			     child of the given path.
- * @path: path to start searching for children
- * @it: callback function
- * @data: context data pointer
- *
- * This function is used to scan the flattened device-tree starting from the
- * node given by path. It is used to extract information (like reserved
- * memory), which is required on ealy boot before we can unflatten the tree.
- */
-int __init of_scan_flat_dt_by_path(const char *path,
-	int (*it)(unsigned long node, const char *name, int depth, void *data),
-	void *data)
-{
-	struct fdt_scan_status st = {path, 0, -1, 0, it, data};
-	int ret = 0;
-
-	if (initial_boot_params)
-                ret = of_scan_flat_dt(fdt_scan_node_by_path, &st);
-
-	if (!st.found)
-		return -ENOENT;
-	else if (ret == -ENXIO)	/* scan has been completed */
-		return 0;
-	else
-		return ret;
-}
-
 const char * __init of_flat_dt_get_machine_name(void)
 {
 	const char *name;

commit 0ee0496de97c6a511ce915f9b44f5b3db15350b7
Author: Rob Herring <robh@kernel.org>
Date:   Thu Mar 27 07:24:57 2014 -0500

    of/fdt: remove some unneeded includes
    
    Whatever needed powerpc machdep.h appears to have been removed, so the
    include can be dropped.
    
    module.h is not needed as this code is always built-in.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Cc: Grant Likely <grant.likely@linaro.org>
    Tested-by: Michal Simek <michal.simek@xilinx.com>
    Tested-by: Grant Likely <grant.likely@linaro.org>
    Tested-by: Stephen Chivers <schivers@csc.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 7a2ef7bb8022..63bdcee473fa 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -12,7 +12,6 @@
 #include <linux/kernel.h>
 #include <linux/initrd.h>
 #include <linux/memblock.h>
-#include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_fdt.h>
 #include <linux/of_reserved_mem.h>
@@ -22,10 +21,6 @@
 #include <linux/slab.h>
 
 #include <asm/setup.h>  /* for COMMAND_LINE_SIZE */
-#ifdef CONFIG_PPC
-#include <asm/machdep.h>
-#endif /* CONFIG_PPC */
-
 #include <asm/page.h>
 
 char *of_fdt_get_string(struct boot_param_header *blob, u32 offset)

commit 5b6241185e2cded07ca3f5f646b55c641928ba4e
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Tue Apr 8 13:48:07 2014 +0800

    of: Fix the section mismatch warnings.
    
    In tag next-20140407, building with CONFIG_DEBUG_SECTION_MISMATCH
    enabled, the following WARNING is occured:
    
    WARNING: drivers/built-in.o(.text.unlikely+0x2220): Section mismatch
    in reference from the function __reserved_mem_check_root() to the
    function .init.text:of_get_flat_dt_prop()
    The function __reserved_mem_check_root() references
    the function __init of_get_flat_dt_prop().
    This is often because __reserved_mem_check_root lacks a __init
    annotation or the annotation of of_get_flat_dt_prop is wrong.
    
    WARNING: vmlinux.o(.text.unlikely+0xb9d0): Section mismatch in reference
    from the function __reserved_mem_check_root() to the (unknown reference)
    .init.data:(unknown)
    The function __reserved_mem_check_root() references
    the (unknown reference) __initdata (unknown).
    This is often because __reserved_mem_check_root lacks a __initdata
    annotation or the annotation of (unknown) is wrong.
    
    This is cause by :
    'drivers: of: add initialization code for dynamic reserved memory'.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index fa16a912a927..7a2ef7bb8022 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -491,7 +491,7 @@ static int __init __reserved_mem_reserve_reg(unsigned long node,
  * in /reserved-memory matches the values supported by the current implementation,
  * also check if ranges property has been provided
  */
-static int __reserved_mem_check_root(unsigned long node)
+static int __init __reserved_mem_check_root(unsigned long node)
 {
 	__be32 *prop;
 

commit ca3992bc0c12e381deb84cd47ec1181a6d34660d
Merge: 0829f6d1f69e 2040b52768eb
Author: Grant Likely <grant.likely@linaro.org>
Date:   Wed Mar 19 15:01:53 2014 +0000

    Merge branch 'devicetree/next-reserved-mem' into devicetree/next

commit 0829f6d1f69e4f2fae4062987ae6531a9af1a2e3
Author: Pantelis Antoniou <panto@antoniou-consulting.com>
Date:   Fri Dec 13 20:08:59 2013 +0200

    of: device_node kobject lifecycle fixes
    
    After the move to having device nodes be proper kobjects the lifecycle
    of the node needs to be controlled better.
    
    At first convert of_add_node() in the unflattened functions to
    of_init_node() which initializes the kobject so that of_node_get/put
    work correctly even before of_init is called.
    
    Afterwards introduce of_node_is_initialized & of_node_is_attached that
    query the underlying kobject about the state (attached means kobj
    is visible in sysfs)
    
    Using that make sure the lifecycle of the tree is correct at all
    times.
    
    Signed-off-by: Pantelis Antoniou <panto@antoniou-consulting.com>
    [grant.likely: moved of_node_init() calls, fixed up locking, and
                   dropped __of_populate() hunks]
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 96ad1ab7f9d6..70ccc36513e7 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -202,6 +202,7 @@ static void * unflatten_dt_node(struct boot_param_header *blob,
 				__alignof__(struct device_node));
 	if (allnextpp) {
 		char *fn;
+		of_node_init(np);
 		np->full_name = fn = ((char *)np) + sizeof(*np);
 		if (new_format) {
 			/* rebuild full path for new format */
@@ -326,8 +327,6 @@ static void * unflatten_dt_node(struct boot_param_header *blob,
 			np->name = "<NULL>";
 		if (!np->type)
 			np->type = "<NULL>";
-
-		of_node_add(np);
 	}
 	while (tag == OF_DT_BEGIN_NODE || tag == OF_DT_NOP) {
 		if (tag == OF_DT_NOP)

commit 2040b52768ebab6e7bd73af0dc63703269c62f17
Author: Josh Cartwright <joshc@codeaurora.org>
Date:   Thu Mar 13 16:36:36 2014 -0500

    of: only scan for reserved mem when fdt present
    
    When the reserved memory patches hit -next, several legacy (non-DT) boot
    failures were detected and bisected down to that commit. There needs to
    be some sanity checking whether a DT is even present before parsing the
    reserved ranges.
    
    Reported-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Josh Cartwright <joshc@codeaurora.org>
    Tested-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 510c0d8de8a0..501bc83f8cdf 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -557,6 +557,9 @@ static int __init __fdt_scan_reserved_mem(unsigned long node, const char *uname,
  */
 void __init early_init_fdt_scan_reserved_mem(void)
 {
+	if (!initial_boot_params)
+		return;
+
 	of_scan_flat_dt(__fdt_scan_reserved_mem, NULL);
 	fdt_init_reserved_mem();
 }

commit 75b57ecf9d1d1e17d099ab13b8f48e6e038676be
Author: Grant Likely <grant.likely@linaro.org>
Date:   Thu Feb 20 18:02:11 2014 +0000

    of: Make device nodes kobjects so they show up in sysfs
    
    Device tree nodes are already treated as objects, and we already want to
    expose them to userspace which is done using the /proc filesystem today.
    Right now the kernel has to do a lot of work to keep the /proc view in
    sync with the in-kernel representation. If device_nodes are switched to
    be kobjects then the device tree code can be a whole lot simpler. It
    also turns out that switching to using /sysfs from /proc results in
    smaller code and data size, and the userspace ABI won't change if
    /proc/device-tree symlinks to /sys/firmware/devicetree/base.
    
    v7: Add missing sysfs_bin_attr_init()
    v6: Add __of_add_property() early init fixes from Pantelis
    v5: Rename firmware/ofw to firmware/devicetree
        Fix updating property values in sysfs
    v4: Fixed build error on Powerpc
        Fixed handling of dynamic nodes on powerpc
    v3: Fixed handling of duplicate attribute and child node names
    v2: switch to using sysfs bin_attributes which solve the problem of
        reporting incorrect property size.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Tested-by: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Nathan Fontenot <nfont@linux.vnet.ibm.com>
    Cc: Pantelis Antoniou <panto@antoniou-consulting.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 758b4f8b30b7..96ad1ab7f9d6 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -232,7 +232,6 @@ static void * unflatten_dt_node(struct boot_param_header *blob,
 				dad->next->sibling = np;
 			dad->next = np;
 		}
-		kref_init(&np->kref);
 	}
 	/* process properties */
 	while (1) {
@@ -327,6 +326,8 @@ static void * unflatten_dt_node(struct boot_param_header *blob,
 			np->name = "<NULL>";
 		if (!np->type)
 			np->type = "<NULL>";
+
+		of_node_add(np);
 	}
 	while (tag == OF_DT_BEGIN_NODE || tag == OF_DT_NOP) {
 		if (tag == OF_DT_NOP)

commit 3f0c8206644836e4f10a6b9fc47cda6a9a372f9b
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Fri Feb 28 14:42:48 2014 +0100

    drivers: of: add initialization code for dynamic reserved memory
    
    This patch adds support for dynamically allocated reserved memory regions
    declared in device tree. Such regions are defined by 'size', 'alignment'
    and 'alloc-ranges' properties.
    
    Based on previous code provided by Josh Cartwright <joshc@codeaurora.org>
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 819e11209718..510c0d8de8a0 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -15,6 +15,7 @@
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_fdt.h>
+#include <linux/of_reserved_mem.h>
 #include <linux/sizes.h>
 #include <linux/string.h>
 #include <linux/errno.h>
@@ -450,7 +451,7 @@ static int __init __reserved_mem_reserve_reg(unsigned long node,
 	phys_addr_t base, size;
 	unsigned long len;
 	__be32 *prop;
-	int nomap;
+	int nomap, first = 1;
 
 	prop = of_get_flat_dt_prop(node, "reg", &len);
 	if (!prop)
@@ -477,6 +478,10 @@ static int __init __reserved_mem_reserve_reg(unsigned long node,
 				uname, &base, (unsigned long)size / SZ_1M);
 
 		len -= t_len;
+		if (first) {
+			fdt_reserved_mem_save_node(node, uname, base, size);
+			first = 0;
+		}
 	}
 	return 0;
 }
@@ -512,6 +517,7 @@ static int __init __fdt_scan_reserved_mem(unsigned long node, const char *uname,
 {
 	static int found;
 	const char *status;
+	int err;
 
 	if (!found && depth == 1 && strcmp(uname, "reserved-memory") == 0) {
 		if (__reserved_mem_check_root(node) != 0) {
@@ -534,7 +540,9 @@ static int __init __fdt_scan_reserved_mem(unsigned long node, const char *uname,
 	if (status && strcmp(status, "okay") != 0 && strcmp(status, "ok") != 0)
 		return 0;
 
-	__reserved_mem_reserve_reg(node, uname);
+	err = __reserved_mem_reserve_reg(node, uname);
+	if (err == -ENOENT && of_get_flat_dt_prop(node, "size", NULL))
+		fdt_reserved_mem_save_node(node, uname, 0, 0);
 
 	/* scan next node */
 	return 0;
@@ -550,6 +558,7 @@ static int __init __fdt_scan_reserved_mem(unsigned long node, const char *uname,
 void __init early_init_fdt_scan_reserved_mem(void)
 {
 	of_scan_flat_dt(__fdt_scan_reserved_mem, NULL);
+	fdt_init_reserved_mem();
 }
 
 /**

commit e8d9d1f5485b52ec3c4d7af839e6914438f6c285
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Fri Feb 28 14:42:47 2014 +0100

    drivers: of: add initialization code for static reserved memory
    
    This patch adds support for static (defined by 'reg' property) reserved
    memory regions declared in device tree.
    
    Memory blocks can be reliably reserved only during early boot. This must
    happen before the whole memory management subsystem is initialized,
    because we need to ensure that the given contiguous blocks are not yet
    allocated by kernel. Also it must happen before kernel mappings for the
    whole low memory are created, to ensure that there will be no mappings
    (for reserved blocks). Typically, all this happens before device tree
    structures are unflattened, so we need to get reserved memory layout
    directly from fdt.
    
    Based on previous code provided by Josh Cartwright <joshc@codeaurora.org>
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 758b4f8b30b7..819e11209718 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -15,6 +15,7 @@
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_fdt.h>
+#include <linux/sizes.h>
 #include <linux/string.h>
 #include <linux/errno.h>
 #include <linux/slab.h>
@@ -439,6 +440,118 @@ struct boot_param_header *initial_boot_params;
 
 #ifdef CONFIG_OF_EARLY_FLATTREE
 
+/**
+ * res_mem_reserve_reg() - reserve all memory described in 'reg' property
+ */
+static int __init __reserved_mem_reserve_reg(unsigned long node,
+					     const char *uname)
+{
+	int t_len = (dt_root_addr_cells + dt_root_size_cells) * sizeof(__be32);
+	phys_addr_t base, size;
+	unsigned long len;
+	__be32 *prop;
+	int nomap;
+
+	prop = of_get_flat_dt_prop(node, "reg", &len);
+	if (!prop)
+		return -ENOENT;
+
+	if (len && len % t_len != 0) {
+		pr_err("Reserved memory: invalid reg property in '%s', skipping node.\n",
+		       uname);
+		return -EINVAL;
+	}
+
+	nomap = of_get_flat_dt_prop(node, "no-map", NULL) != NULL;
+
+	while (len >= t_len) {
+		base = dt_mem_next_cell(dt_root_addr_cells, &prop);
+		size = dt_mem_next_cell(dt_root_size_cells, &prop);
+
+		if (base && size &&
+		    early_init_dt_reserve_memory_arch(base, size, nomap) == 0)
+			pr_debug("Reserved memory: reserved region for node '%s': base %pa, size %ld MiB\n",
+				uname, &base, (unsigned long)size / SZ_1M);
+		else
+			pr_info("Reserved memory: failed to reserve memory for node '%s': base %pa, size %ld MiB\n",
+				uname, &base, (unsigned long)size / SZ_1M);
+
+		len -= t_len;
+	}
+	return 0;
+}
+
+/**
+ * __reserved_mem_check_root() - check if #size-cells, #address-cells provided
+ * in /reserved-memory matches the values supported by the current implementation,
+ * also check if ranges property has been provided
+ */
+static int __reserved_mem_check_root(unsigned long node)
+{
+	__be32 *prop;
+
+	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
+	if (!prop || be32_to_cpup(prop) != dt_root_size_cells)
+		return -EINVAL;
+
+	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
+	if (!prop || be32_to_cpup(prop) != dt_root_addr_cells)
+		return -EINVAL;
+
+	prop = of_get_flat_dt_prop(node, "ranges", NULL);
+	if (!prop)
+		return -EINVAL;
+	return 0;
+}
+
+/**
+ * fdt_scan_reserved_mem() - scan a single FDT node for reserved memory
+ */
+static int __init __fdt_scan_reserved_mem(unsigned long node, const char *uname,
+					  int depth, void *data)
+{
+	static int found;
+	const char *status;
+
+	if (!found && depth == 1 && strcmp(uname, "reserved-memory") == 0) {
+		if (__reserved_mem_check_root(node) != 0) {
+			pr_err("Reserved memory: unsupported node format, ignoring\n");
+			/* break scan */
+			return 1;
+		}
+		found = 1;
+		/* scan next node */
+		return 0;
+	} else if (!found) {
+		/* scan next node */
+		return 0;
+	} else if (found && depth < 2) {
+		/* scanning of /reserved-memory has been finished */
+		return 1;
+	}
+
+	status = of_get_flat_dt_prop(node, "status", NULL);
+	if (status && strcmp(status, "okay") != 0 && strcmp(status, "ok") != 0)
+		return 0;
+
+	__reserved_mem_reserve_reg(node, uname);
+
+	/* scan next node */
+	return 0;
+}
+
+/**
+ * early_init_fdt_scan_reserved_mem() - create reserved memory regions
+ *
+ * This function grabs memory from early allocator for device exclusive use
+ * defined in device tree structures. It should be called by arch specific code
+ * once the early allocator (i.e. memblock) has been fully activated.
+ */
+void __init early_init_fdt_scan_reserved_mem(void)
+{
+	of_scan_flat_dt(__fdt_scan_reserved_mem, NULL);
+}
+
 /**
  * of_scan_flat_dt - scan flattened tree blob and call callback on each.
  * @it: callback function
@@ -856,6 +969,16 @@ void __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)
 	memblock_add(base, size);
 }
 
+int __init __weak early_init_dt_reserve_memory_arch(phys_addr_t base,
+					phys_addr_t size, bool nomap)
+{
+	if (memblock_is_region_reserved(base, size))
+		return -EBUSY;
+	if (nomap)
+		return memblock_remove(base, size);
+	return memblock_reserve(base, size);
+}
+
 /*
  * called from unflatten_device_tree() to bootstrap devicetree itself
  * Architectures can override this definition if memblock isn't used
@@ -864,6 +987,14 @@ void * __init __weak early_init_dt_alloc_memory_arch(u64 size, u64 align)
 {
 	return __va(memblock_alloc(size, align));
 }
+#else
+int __init __weak early_init_dt_reserve_memory_arch(phys_addr_t base,
+					phys_addr_t size, bool nomap)
+{
+	pr_err("Reserved memory not supported, ignoring range 0x%llx - 0x%llx%s\n",
+		  base, size, nomap ? " (nomap)" : "");
+	return -ENOSYS;
+}
 #endif
 
 bool __init early_init_dt_scan(void *params)

commit 6f041e99fc7ba00e7e65a431527f9235d6b16463
Author: James Hogan <james.hogan@imgtec.com>
Date:   Thu Nov 21 13:44:14 2013 +0000

    of: Fix NULL dereference in unflatten_and_copy()
    
    Check whether initial_boot_params is NULL before dereferencing it in
    unflatten_and_copy_device_tree() for the case where no device tree is
    available but the arch can still boot to a minimal usable system without
    it. In this case also log a warning for when the kernel log buffer is
    obtainable.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 2fa024b97c43..758b4f8b30b7 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -922,8 +922,16 @@ void __init unflatten_device_tree(void)
  */
 void __init unflatten_and_copy_device_tree(void)
 {
-	int size = __be32_to_cpu(initial_boot_params->totalsize);
-	void *dt = early_init_dt_alloc_memory_arch(size,
+	int size;
+	void *dt;
+
+	if (!initial_boot_params) {
+		pr_warn("No valid device tree found, continuing without\n");
+		return;
+	}
+
+	size = __be32_to_cpu(initial_boot_params->totalsize);
+	dt = early_init_dt_alloc_memory_arch(size,
 		__alignof__(struct boot_param_header));
 
 	if (dt) {

commit 10d0c9705e80bbd3d587c5fad24599aabaca6688
Merge: 85b656cf1560 c11eede69b6a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 12 16:52:17 2013 +0900

    Merge tag 'devicetree-for-3.13' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull devicetree updates from Rob Herring:
     "DeviceTree updates for 3.13.  This is a bit larger pull request than
      usual for this cycle with lots of clean-up.
    
       - Cross arch clean-up and consolidation of early DT scanning code.
       - Clean-up and removal of arch prom.h headers.  Makes arch specific
         prom.h optional on all but Sparc.
       - Addition of interrupts-extended property for devices connected to
         multiple interrupt controllers.
       - Refactoring of DT interrupt parsing code in preparation for
         deferred probe of interrupts.
       - ARM cpu and cpu topology bindings documentation.
       - Various DT vendor binding documentation updates"
    
    * tag 'devicetree-for-3.13' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (82 commits)
      powerpc: add missing explicit OF includes for ppc
      dt/irq: add empty of_irq_count for !OF_IRQ
      dt: disable self-tests for !OF_IRQ
      of: irq: Fix interrupt-map entry matching
      MIPS: Netlogic: replace early_init_devtree() call
      of: Add Panasonic Corporation vendor prefix
      of: Add Chunghwa Picture Tubes Ltd. vendor prefix
      of: Add AU Optronics Corporation vendor prefix
      of/irq: Fix potential buffer overflow
      of/irq: Fix bug in interrupt parsing refactor.
      of: set dma_mask to point to coherent_dma_mask
      of: add vendor prefix for PHYTEC Messtechnik GmbH
      DT: sort vendor-prefixes.txt
      of: Add vendor prefix for Cadence
      of: Add empty for_each_available_child_of_node() macro definition
      arm/versatile: Fix versatile irq specifications.
      of/irq: create interrupts-extended property
      microblaze/pci: Drop PowerPC-ism from irq parsing
      of/irq: Create of_irq_parse_and_map_pci() to consolidate arch code.
      of/irq: Use irq_of_parse_and_map()
      ...

commit b920ecc826eacf7ad7dfeabc0cf74a8b88e3b7f5
Author: Grant Likely <grant.likely@linaro.org>
Date:   Mon Oct 14 12:46:04 2013 +0100

    Revert "of: Feed entire flattened device tree into the random pool"
    
    This reverts commit 109b6236294b53d8eaa50be7d9e9ad37079f5f7e.
    
    Tim Bird expressed concern that this will have a bad effect on boot
    time, and while simple tests have shown it to be okay with simple tree,
    a device tree blob can potentially be quite large and
    add_device_randomness() is not a fast function. Rather than do this for
    all platforms unconditionally, I'm reverting this patch and would like
    to see it revisited. Instead of feeding the entire tree into the random
    pool, it would probably be appropriate to hash the tree and feed the
    hash result into the pool. There really isn't a lot of randomness in a
    device tree anyway. In the majority of cases only a handful of
    properties are going to be different between machines with the same
    baseboard.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 229dd9d69e18..a4fa9ad31b8f 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -18,7 +18,6 @@
 #include <linux/string.h>
 #include <linux/errno.h>
 #include <linux/slab.h>
-#include <linux/random.h>
 
 #include <asm/setup.h>  /* for COMMAND_LINE_SIZE */
 #ifdef CONFIG_PPC
@@ -803,14 +802,3 @@ void __init unflatten_device_tree(void)
 }
 
 #endif /* CONFIG_OF_EARLY_FLATTREE */
-
-/* Feed entire flattened device tree into the random pool */
-static int __init add_fdt_randomness(void)
-{
-	if (initial_boot_params)
-		add_device_randomness(initial_boot_params,
-				be32_to_cpu(initial_boot_params->totalsize));
-
-	return 0;
-}
-core_initcall(add_fdt_randomness);

commit 6a903a2551ef778d60ce4341722d611144251398
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Tue Aug 27 21:41:56 2013 -0500

    of: introduce common FDT machine related functions
    
    Introduce common of_flat_dt_match_machine and
    of_flat_dt_get_machine_name functions to unify architectures' handling
    of machine level model and compatible properties.
    
    Several architectures match the root compatible string with an arch
    specific list of machine descriptors duplicating the same search
    algorithm. Create a common implementation with a simple architecture
    specific hook to iterate over each machine's match table.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 5f4cc88cd89e..5c479104fc67 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -619,6 +619,66 @@ int __init of_scan_flat_dt_by_path(const char *path,
 		return ret;
 }
 
+const char * __init of_flat_dt_get_machine_name(void)
+{
+	const char *name;
+	unsigned long dt_root = of_get_flat_dt_root();
+
+	name = of_get_flat_dt_prop(dt_root, "model", NULL);
+	if (!name)
+		name = of_get_flat_dt_prop(dt_root, "compatible", NULL);
+	return name;
+}
+
+/**
+ * of_flat_dt_match_machine - Iterate match tables to find matching machine.
+ *
+ * @default_match: A machine specific ptr to return in case of no match.
+ * @get_next_compat: callback function to return next compatible match table.
+ *
+ * Iterate through machine match tables to find the best match for the machine
+ * compatible string in the FDT.
+ */
+const void * __init of_flat_dt_match_machine(const void *default_match,
+		const void * (*get_next_compat)(const char * const**))
+{
+	const void *data = NULL;
+	const void *best_data = default_match;
+	const char *const *compat;
+	unsigned long dt_root;
+	unsigned int best_score = ~1, score = 0;
+
+	dt_root = of_get_flat_dt_root();
+	while ((data = get_next_compat(&compat))) {
+		score = of_flat_dt_match(dt_root, compat);
+		if (score > 0 && score < best_score) {
+			best_data = data;
+			best_score = score;
+		}
+	}
+	if (!best_data) {
+		const char *prop;
+		long size;
+
+		pr_err("\n unrecognized device tree list:\n[ ");
+
+		prop = of_get_flat_dt_prop(dt_root, "compatible", &size);
+		if (prop) {
+			while (size > 0) {
+				printk("'%s' ", prop);
+				size -= strlen(prop) + 1;
+				prop += strlen(prop) + 1;
+			}
+		}
+		printk("]\n\n");
+		return NULL;
+	}
+
+	pr_info("Machine model: %s\n", of_flat_dt_get_machine_name());
+
+	return best_data;
+}
+
 #ifdef CONFIG_BLK_DEV_INITRD
 /**
  * early_init_dt_check_for_initrd - Decode initrd location from flat tree

commit 29eb45a9ab4839a1e9cef2bcf369b918c9c4fcad
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Fri Aug 30 17:06:53 2013 -0500

    of: remove early_init_dt_setup_initrd_arch
    
    All arches do essentially the same thing now for
    early_init_dt_setup_initrd_arch, so it can now be removed.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Aurelien Jacquiot <a-jacquiot@ti.com>
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: x86@kernel.org
    Cc: Chris Zankel <chris@zankel.net>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Acked-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 5bc55b6e2b41..5f4cc88cd89e 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -624,7 +624,7 @@ int __init of_scan_flat_dt_by_path(const char *path,
  * early_init_dt_check_for_initrd - Decode initrd location from flat tree
  * @node: reference to node containing initrd location ('chosen')
  */
-void __init early_init_dt_check_for_initrd(unsigned long node)
+static void __init early_init_dt_check_for_initrd(unsigned long node)
 {
 	u64 start, end;
 	unsigned long len;
@@ -642,12 +642,15 @@ void __init early_init_dt_check_for_initrd(unsigned long node)
 		return;
 	end = of_read_number(prop, len/4);
 
-	early_init_dt_setup_initrd_arch(start, end);
+	initrd_start = (unsigned long)__va(start);
+	initrd_end = (unsigned long)__va(end);
+	initrd_below_start_ok = 1;
+
 	pr_debug("initrd_start=0x%llx  initrd_end=0x%llx\n",
 		 (unsigned long long)start, (unsigned long long)end);
 }
 #else
-inline void early_init_dt_check_for_initrd(unsigned long node)
+static inline void early_init_dt_check_for_initrd(unsigned long node)
 {
 }
 #endif /* CONFIG_BLK_DEV_INITRD */

commit 068f6310b965d67d57f89ebf4c539e5933754366
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Tue Sep 24 22:20:01 2013 -0500

    of: create default early_init_dt_add_memory_arch
    
    Create a weak version of early_init_dt_add_memory_arch which uses
    memblock. This will unify all architectures except ones with custom
    memory bank structs.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Jonas Bonn <jonas@southpole.se>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: microblaze-uclinux@itee.uq.edu.au
    Cc: linux@lists.openrisc.net
    Cc: devicetree@vger.kernel.org

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index bfbfda543768..5bc55b6e2b41 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -775,6 +775,25 @@ int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
 }
 
 #ifdef CONFIG_HAVE_MEMBLOCK
+void __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)
+{
+	const u64 phys_offset = __pa(PAGE_OFFSET);
+	base &= PAGE_MASK;
+	size &= PAGE_MASK;
+	if (base + size < phys_offset) {
+		pr_warning("Ignoring memory block 0x%llx - 0x%llx\n",
+			   base, base + size);
+		return;
+	}
+	if (base < phys_offset) {
+		pr_warning("Ignoring memory range 0x%llx - 0x%llx\n",
+			   base, phys_offset);
+		size -= phys_offset - base;
+		base = phys_offset;
+	}
+	memblock_add(base, size);
+}
+
 /*
  * called from unflatten_device_tree() to bootstrap devicetree itself
  * Architectures can override this definition if memblock isn't used

commit 0288ffcbfdf9b8656e7320c24caa1e4c1d498287
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Mon Aug 26 09:47:40 2013 -0500

    of: Introduce common early_init_dt_scan
    
    Most architectures scan the all the same items early in the FDT and none
    are really architecture specific. Create a common early_init_dt_scan to
    unify the early scan of root, memory, and chosen nodes in the flattened
    DT.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 51776166d2b0..bfbfda543768 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -785,6 +785,32 @@ void * __init __weak early_init_dt_alloc_memory_arch(u64 size, u64 align)
 }
 #endif
 
+bool __init early_init_dt_scan(void *params)
+{
+	if (!params)
+		return false;
+
+	/* Setup flat device-tree pointer */
+	initial_boot_params = params;
+
+	/* check device tree validity */
+	if (be32_to_cpu(initial_boot_params->magic) != OF_DT_HEADER) {
+		initial_boot_params = NULL;
+		return false;
+	}
+
+	/* Retrieve various information from the /chosen node */
+	of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);
+
+	/* Initialize {size,address}-cells info */
+	of_scan_flat_dt(early_init_dt_scan_root, NULL);
+
+	/* Setup memory, calling early_init_dt_add_memory_arch */
+	of_scan_flat_dt(early_init_dt_scan_memory, NULL);
+
+	return true;
+}
+
 /**
  * unflatten_device_tree - create tree of device_nodes from flat blob
  *

commit a8bf7527a2e17ccf1366e67f6ac728327ca34c40
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Mon Aug 26 11:22:45 2013 -0500

    of: create unflatten_and_copy_device_tree
    
    Several architectures using DT support built-in dtb's in the init
    section. These platforms need to copy the dtb from init since the
    strings are referenced after unflattening. Every arch has their own
    copying routine which do the same thing. Create a common function,
    unflatten_and_copy_device_tree, to copy the dtb when unflattening the
    dtb.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 229dd9d69e18..51776166d2b0 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -802,6 +802,30 @@ void __init unflatten_device_tree(void)
 	of_alias_scan(early_init_dt_alloc_memory_arch);
 }
 
+/**
+ * unflatten_and_copy_device_tree - copy and create tree of device_nodes from flat blob
+ *
+ * Copies and unflattens the device-tree passed by the firmware, creating the
+ * tree of struct device_node. It also fills the "name" and "type"
+ * pointers of the nodes so the normal device-tree walking functions
+ * can be used. This should only be used when the FDT memory has not been
+ * reserved such is the case when the FDT is built-in to the kernel init
+ * section. If the FDT memory is reserved already then unflatten_device_tree
+ * should be used instead.
+ */
+void __init unflatten_and_copy_device_tree(void)
+{
+	int size = __be32_to_cpu(initial_boot_params->totalsize);
+	void *dt = early_init_dt_alloc_memory_arch(size,
+		__alignof__(struct boot_param_header));
+
+	if (dt) {
+		memcpy(dt, initial_boot_params, size);
+		initial_boot_params = dt;
+	}
+	unflatten_device_tree();
+}
+
 #endif /* CONFIG_OF_EARLY_FLATTREE */
 
 /* Feed entire flattened device tree into the random pool */

commit 31f7c3a688f75bceaf2fd009efc489659ad6aa61
Merge: ec5b103ecfde 2bc552df76d8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 10 13:53:52 2013 -0700

    Merge tag 'devicetree-for-linus' of git://git.secretlab.ca/git/linux
    
    Pull device tree core updates from Grant Likely:
     "Generally minor changes.  A bunch of bug fixes, particularly for
      initialization and some refactoring.  Most notable change if feeding
      the entire flattened tree into the random pool at boot.  May not be
      significant, but shouldn't hurt either"
    
    Tim Bird questions whether the boot time cost of the random feeding may
    be noticeable.  And "add_device_randomness()" is definitely not some
    speed deamon of a function.
    
    * tag 'devicetree-for-linus' of git://git.secretlab.ca/git/linux:
      of/platform: add error reporting to of_amba_device_create()
      irq/of: Fix comment typo for irq_of_parse_and_map
      of: Feed entire flattened device tree into the random pool
      of/fdt: Clean up casting in unflattening path
      of/fdt: Remove duplicate memory clearing on FDT unflattening
      gpio: implement gpio-ranges binding document fix
      of: call __of_parse_phandle_with_args from of_parse_phandle
      of: introduce of_parse_phandle_with_fixed_args
      of: move of_parse_phandle()
      of: move documentation of of_parse_phandle_with_args
      of: Fix missing memory initialization on FDT unflattening
      of: consolidate definition of early_init_dt_alloc_memory_arch()
      of: Make of_get_phy_mode() return int i.s.o. const int
      include: dt-binding: input: create a DT header defining key codes.
      of/platform: Staticize of_platform_device_create_pdata()
      of: Specify initrd location using 64-bit
      dt: Typo fix
      OF: make of_property_for_each_{u32|string}() use parameters if OF is not enabled

commit 64c353864e3f7ccba0ade1bd6f562f9a3bc7e68d
Merge: d8cacd3a259b 10bcdfb8ba24
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Sep 9 10:26:33 2013 -0700

    Merge branch 'for-v3.12' of git://git.linaro.org/people/mszyprowski/linux-dma-mapping
    
    Pull DMA mapping update from Marek Szyprowski:
     "This contains an addition of Device Tree support for reserved memory
      regions (Contiguous Memory Allocator is one of the drivers for it) and
      changes required by the KVM extensions for PowerPC architectue"
    
    * 'for-v3.12' of git://git.linaro.org/people/mszyprowski/linux-dma-mapping:
      ARM: init: add support for reserved memory defined by device tree
      drivers: of: add initialization code for dma reserved memory
      drivers: of: add function to scan fdt nodes given by path
      drivers: dma-contiguous: clean source code and prepare for device tree

commit 109b6236294b53d8eaa50be7d9e9ad37079f5f7e
Author: Anton Blanchard <anton@samba.org>
Date:   Mon Jul 29 13:11:50 2013 +1000

    of: Feed entire flattened device tree into the random pool
    
    We feed the entire DMI table into the random pool to provide
    better random data during early boot, so do the same with the
    flattened device tree.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 4c5ee96bf487..543c5002831e 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -18,6 +18,7 @@
 #include <linux/string.h>
 #include <linux/errno.h>
 #include <linux/slab.h>
+#include <linux/random.h>
 
 #include <asm/setup.h>  /* for COMMAND_LINE_SIZE */
 #ifdef CONFIG_PPC
@@ -726,3 +727,14 @@ void __init unflatten_device_tree(void)
 }
 
 #endif /* CONFIG_OF_EARLY_FLATTREE */
+
+/* Feed entire flattened device tree into the random pool */
+static int __init add_fdt_randomness(void)
+{
+	if (initial_boot_params)
+		add_device_randomness(initial_boot_params,
+				be32_to_cpu(initial_boot_params->totalsize));
+
+	return 0;
+}
+core_initcall(add_fdt_randomness);

commit 4485681939b99d80893e2016ebb9d44e1c414561
Author: Grant Likely <grant.likely@linaro.org>
Date:   Thu Aug 29 13:30:35 2013 +0100

    of/fdt: Clean up casting in unflattening path
    
    The flat tree unflatting path is using unsigned longs to carry around
    virtual address pointers to the device tree and the allocated memory
    used to unpack it. This is a little insane since every access to them
    needs to be cast to a pointer type before using it. This patch changes
    the data type to void* for the 'start' and 'mem' pointers and reworks
    the unflattening functions to use those values directly which results in
    slightly simpler code.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 8263d2da3252..4c5ee96bf487 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -126,13 +126,13 @@ int of_fdt_match(struct boot_param_header *blob, unsigned long node,
 	return score;
 }
 
-static void *unflatten_dt_alloc(unsigned long *mem, unsigned long size,
+static void *unflatten_dt_alloc(void **mem, unsigned long size,
 				       unsigned long align)
 {
 	void *res;
 
-	*mem = ALIGN(*mem, align);
-	res = (void *)*mem;
+	*mem = PTR_ALIGN(*mem, align);
+	res = *mem;
 	*mem += size;
 
 	return res;
@@ -147,9 +147,9 @@ static void *unflatten_dt_alloc(unsigned long *mem, unsigned long size,
  * @allnextpp: pointer to ->allnext from last allocated device_node
  * @fpsize: Size of the node path up at the current depth.
  */
-static unsigned long unflatten_dt_node(struct boot_param_header *blob,
-				unsigned long mem,
-				unsigned long *p,
+static void * unflatten_dt_node(struct boot_param_header *blob,
+				void *mem,
+				void **p,
 				struct device_node *dad,
 				struct device_node ***allnextpp,
 				unsigned long fpsize)
@@ -162,15 +162,15 @@ static unsigned long unflatten_dt_node(struct boot_param_header *blob,
 	int has_name = 0;
 	int new_format = 0;
 
-	tag = be32_to_cpup((__be32 *)(*p));
+	tag = be32_to_cpup(*p);
 	if (tag != OF_DT_BEGIN_NODE) {
 		pr_err("Weird tag at start of node: %x\n", tag);
 		return mem;
 	}
 	*p += 4;
-	pathp = (char *)*p;
+	pathp = *p;
 	l = allocl = strlen(pathp) + 1;
-	*p = ALIGN(*p + l, 4);
+	*p = PTR_ALIGN(*p + l, 4);
 
 	/* version 0x10 has a more compact unit name here instead of the full
 	 * path. we accumulate the full path size using "fpsize", we'll rebuild
@@ -239,7 +239,7 @@ static unsigned long unflatten_dt_node(struct boot_param_header *blob,
 		u32 sz, noff;
 		char *pname;
 
-		tag = be32_to_cpup((__be32 *)(*p));
+		tag = be32_to_cpup(*p);
 		if (tag == OF_DT_NOP) {
 			*p += 4;
 			continue;
@@ -247,11 +247,11 @@ static unsigned long unflatten_dt_node(struct boot_param_header *blob,
 		if (tag != OF_DT_PROP)
 			break;
 		*p += 4;
-		sz = be32_to_cpup((__be32 *)(*p));
-		noff = be32_to_cpup((__be32 *)((*p) + 4));
+		sz = be32_to_cpup(*p);
+		noff = be32_to_cpup(*p + 4);
 		*p += 8;
 		if (be32_to_cpu(blob->version) < 0x10)
-			*p = ALIGN(*p, sz >= 8 ? 8 : 4);
+			*p = PTR_ALIGN(*p, sz >= 8 ? 8 : 4);
 
 		pname = of_fdt_get_string(blob, noff);
 		if (pname == NULL) {
@@ -281,11 +281,11 @@ static unsigned long unflatten_dt_node(struct boot_param_header *blob,
 				np->phandle = be32_to_cpup((__be32 *)*p);
 			pp->name = pname;
 			pp->length = sz;
-			pp->value = (void *)*p;
+			pp->value = *p;
 			*prev_pp = pp;
 			prev_pp = &pp->next;
 		}
-		*p = ALIGN((*p) + sz, 4);
+		*p = PTR_ALIGN((*p) + sz, 4);
 	}
 	/* with version 0x10 we may not have the name property, recreate
 	 * it here from the unit name if absent
@@ -334,7 +334,7 @@ static unsigned long unflatten_dt_node(struct boot_param_header *blob,
 		else
 			mem = unflatten_dt_node(blob, mem, p, np, allnextpp,
 						fpsize);
-		tag = be32_to_cpup((__be32 *)(*p));
+		tag = be32_to_cpup(*p);
 	}
 	if (tag != OF_DT_END_NODE) {
 		pr_err("Weird tag at end of node: %x\n", tag);
@@ -360,7 +360,8 @@ static void __unflatten_device_tree(struct boot_param_header *blob,
 			     struct device_node **mynodes,
 			     void * (*dt_alloc)(u64 size, u64 align))
 {
-	unsigned long start, mem, size;
+	unsigned long size;
+	void *start, *mem;
 	struct device_node **allnextp = mynodes;
 
 	pr_debug(" -> unflatten_device_tree()\n");
@@ -381,32 +382,28 @@ static void __unflatten_device_tree(struct boot_param_header *blob,
 	}
 
 	/* First pass, scan for size */
-	start = ((unsigned long)blob) +
-		be32_to_cpu(blob->off_dt_struct);
-	size = unflatten_dt_node(blob, 0, &start, NULL, NULL, 0);
-	size = (size | 3) + 1;
+	start = ((void *)blob) + be32_to_cpu(blob->off_dt_struct);
+	size = (unsigned long)unflatten_dt_node(blob, 0, &start, NULL, NULL, 0);
+	size = ALIGN(size, 4);
 
 	pr_debug("  size is %lx, allocating...\n", size);
 
 	/* Allocate memory for the expanded device tree */
-	mem = (unsigned long)
-		dt_alloc(size + 4, __alignof__(struct device_node));
+	mem = dt_alloc(size + 4, __alignof__(struct device_node));
+	memset(mem, 0, size);
 
-	memset((void *)mem, 0, size);
+	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
 
-	((__be32 *)mem)[size / 4] = cpu_to_be32(0xdeadbeef);
-
-	pr_debug("  unflattening %lx...\n", mem);
+	pr_debug("  unflattening %p...\n", mem);
 
 	/* Second pass, do actual unflattening */
-	start = ((unsigned long)blob) +
-		be32_to_cpu(blob->off_dt_struct);
+	start = ((void *)blob) + be32_to_cpu(blob->off_dt_struct);
 	unflatten_dt_node(blob, mem, &start, NULL, &allnextp, 0);
-	if (be32_to_cpup((__be32 *)start) != OF_DT_END)
-		pr_warning("Weird tag at end of tree: %08x\n", *((u32 *)start));
-	if (be32_to_cpu(((__be32 *)mem)[size / 4]) != 0xdeadbeef)
+	if (be32_to_cpup(start) != OF_DT_END)
+		pr_warning("Weird tag at end of tree: %08x\n", be32_to_cpup(start));
+	if (be32_to_cpup(mem + size) != 0xdeadbeef)
 		pr_warning("End of tree marker overwritten: %08x\n",
-			   be32_to_cpu(((__be32 *)mem)[size / 4]));
+			   be32_to_cpup(mem + size));
 	*allnextp = NULL;
 
 	pr_debug(" <- unflatten_device_tree()\n");

commit 92d31610aac907c046f0e9c0f888c30415f20936
Author: Grant Likely <grant.likely@linaro.org>
Date:   Wed Aug 28 21:24:17 2013 +0100

    of/fdt: Remove duplicate memory clearing on FDT unflattening
    
    Patch 9e4012752, "of: fdt: fix memory initialization for expanded DT"
    fixed incomplete clearing of memory when unflattening the device tree.
    However the code was already clearing some of the memory, it just wasn't
    doing so for all allocations. Now that the memory is cleared right at
    the point of allocation, the memset after unflatten_dt_alloc() is
    redundant. Remove it.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Acked-by: Wladislav Wiebe <wladislav.kw@gmail.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index d49b3e8159bb..8263d2da3252 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -202,7 +202,6 @@ static unsigned long unflatten_dt_node(struct boot_param_header *blob,
 				__alignof__(struct device_node));
 	if (allnextpp) {
 		char *fn;
-		memset(np, 0, sizeof(*np));
 		np->full_name = fn = ((char *)np) + sizeof(*np);
 		if (new_format) {
 			/* rebuild full path for new format */

commit a1727da599ad030ccaf4073473fd235c8ee28219
Author: Grant Likely <grant.likely@linaro.org>
Date:   Wed Aug 28 21:18:32 2013 +0100

    of: consolidate definition of early_init_dt_alloc_memory_arch()
    
    Most architectures use the same implementation. Collapse the common ones
    into a single weak function that can be overridden.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index b9657e5304ed..d49b3e8159bb 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -11,6 +11,7 @@
 
 #include <linux/kernel.h>
 #include <linux/initrd.h>
+#include <linux/memblock.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_fdt.h>
@@ -700,6 +701,17 @@ int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
 	return 1;
 }
 
+#ifdef CONFIG_HAVE_MEMBLOCK
+/*
+ * called from unflatten_device_tree() to bootstrap devicetree itself
+ * Architectures can override this definition if memblock isn't used
+ */
+void * __init __weak early_init_dt_alloc_memory_arch(u64 size, u64 align)
+{
+	return __va(memblock_alloc(size, align));
+}
+#endif
+
 /**
  * unflatten_device_tree - create tree of device_nodes from flat blob
  *

commit 8be137f2664f0abb096626a9d2ce0fcdd955b109
Merge: 8851b9f1625c d8dfad3876e4
Author: Grant Likely <grant.likely@linaro.org>
Date:   Wed Aug 28 20:18:13 2013 +0100

    Merge tag 'v3.11-rc7' into devicetree/next
    
    Linux 3.11-rc7

commit 57d74bcf3072b65bde5aa540cedc976a75c48e5c
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Mon Aug 26 14:41:56 2013 +0200

    drivers: of: add function to scan fdt nodes given by path
    
    Add a function to scan the flattened device-tree starting from the
    node given by the path. It is used to extract information (like reserved
    memory), which is required on early boot before we can unflatten the tree.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Acked-by: Tomasz Figa <t.figa@samsung.com>
    Reviewed-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 6bb7cf2de556..585b1a67cfbe 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -543,6 +543,82 @@ int __init of_flat_dt_match(unsigned long node, const char *const *compat)
 	return of_fdt_match(initial_boot_params, node, compat);
 }
 
+struct fdt_scan_status {
+	const char *name;
+	int namelen;
+	int depth;
+	int found;
+	int (*iterator)(unsigned long node, const char *uname, int depth, void *data);
+	void *data;
+};
+
+/**
+ * fdt_scan_node_by_path - iterator for of_scan_flat_dt_by_path function
+ */
+static int __init fdt_scan_node_by_path(unsigned long node, const char *uname,
+					int depth, void *data)
+{
+	struct fdt_scan_status *st = data;
+
+	/*
+	 * if scan at the requested fdt node has been completed,
+	 * return -ENXIO to abort further scanning
+	 */
+	if (depth <= st->depth)
+		return -ENXIO;
+
+	/* requested fdt node has been found, so call iterator function */
+	if (st->found)
+		return st->iterator(node, uname, depth, st->data);
+
+	/* check if scanning automata is entering next level of fdt nodes */
+	if (depth == st->depth + 1 &&
+	    strncmp(st->name, uname, st->namelen) == 0 &&
+	    uname[st->namelen] == 0) {
+		st->depth += 1;
+		if (st->name[st->namelen] == 0) {
+			st->found = 1;
+		} else {
+			const char *next = st->name + st->namelen + 1;
+			st->name = next;
+			st->namelen = strcspn(next, "/");
+		}
+		return 0;
+	}
+
+	/* scan next fdt node */
+	return 0;
+}
+
+/**
+ * of_scan_flat_dt_by_path - scan flattened tree blob and call callback on each
+ *			     child of the given path.
+ * @path: path to start searching for children
+ * @it: callback function
+ * @data: context data pointer
+ *
+ * This function is used to scan the flattened device-tree starting from the
+ * node given by path. It is used to extract information (like reserved
+ * memory), which is required on ealy boot before we can unflatten the tree.
+ */
+int __init of_scan_flat_dt_by_path(const char *path,
+	int (*it)(unsigned long node, const char *name, int depth, void *data),
+	void *data)
+{
+	struct fdt_scan_status st = {path, 0, -1, 0, it, data};
+	int ret = 0;
+
+	if (initial_boot_params)
+                ret = of_scan_flat_dt(fdt_scan_node_by_path, &st);
+
+	if (!st.found)
+		return -ENOENT;
+	else if (ret == -ENXIO)	/* scan has been completed */
+		return 0;
+	else
+		return ret;
+}
+
 #ifdef CONFIG_BLK_DEV_INITRD
 /**
  * early_init_dt_check_for_initrd - Decode initrd location from flat tree

commit 9e40127526e857fa3f29d51e83277204fbdfc6ba
Author: Wladislav Wiebe <wladislav.kw@gmail.com>
Date:   Mon Aug 12 13:06:53 2013 +0200

    of: fdt: fix memory initialization for expanded DT
    
    Already existing property flags are filled wrong for properties created from
    initial FDT. This could cause problems if this DYNAMIC device-tree functions
    are used later, i.e. properties are attached/detached/replaced. Simply dumping
    flags from the running system show, that some initial static (not allocated via
    kzmalloc()) nodes are marked as dynamic.
    
    I putted some debug extensions to property_proc_show(..) :
    ..
    +       if (OF_IS_DYNAMIC(pp))
    +               pr_err("DEBUG: xxx : OF_IS_DYNAMIC\n");
    +       if (OF_IS_DETACHED(pp))
    +               pr_err("DEBUG: xxx : OF_IS_DETACHED\n");
    
    when you operate on the nodes (e.g.: ~$ cat /proc/device-tree/*some_node*) you
    will see that those flags are filled wrong, basically in most cases it will dump
    a DYNAMIC or DETACHED status, which is in not true.
    (BTW. this OF_IS_DETACHED is a own define for debug purposes which which just
    make a test_bit(OF_DETACHED, &x->_flags)
    
    If nodes are dynamic kernel is allowed to kfree() them. But it will crash
    attempting to do so on the nodes from FDT -- they are not allocated via
    kzmalloc().
    
    Signed-off-by: Wladislav Wiebe <wladislav.kw@gmail.com>
    Acked-by: Alexander Sverdlin <alexander.sverdlin@nsn.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 6bb7cf2de556..b10ba00cc3e6 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -392,6 +392,8 @@ static void __unflatten_device_tree(struct boot_param_header *blob,
 	mem = (unsigned long)
 		dt_alloc(size + 4, __alignof__(struct device_node));
 
+	memset((void *)mem, 0, size);
+
 	((__be32 *)mem)[size / 4] = cpu_to_be32(0xdeadbeef);
 
 	pr_debug("  unflattening %lx...\n", mem);

commit 374d5c9964c10373ba39bbe934f4262eb87d7114
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Mon Jul 1 14:20:35 2013 -0400

    of: Specify initrd location using 64-bit
    
    On some PAE architectures, the entire range of physical memory could reside
    outside the 32-bit limit.  These systems need the ability to specify the
    initrd location using 64-bit numbers.
    
    This patch globally modifies the early_init_dt_setup_initrd_arch() function to
    use 64-bit numbers instead of the current unsigned long.
    
    There has been quite a bit of debate about whether to use u64 or phys_addr_t.
    It was concluded to stick to u64 to be consistent with rest of the device
    tree code. As summarized by Geert, "The address to load the initrd is decided
    by the bootloader/user and set at that point later in time. The dtb should not
    be tied to the kernel you are booting"
    
    More details on the discussion can be found here:
    https://lkml.org/lkml/2013/6/20/690
    https://lkml.org/lkml/2012/9/13/544
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Vineet Gupta <vgupta@synopsys.com>
    Acked-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 6bb7cf2de556..3f473d158d79 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -550,7 +550,8 @@ int __init of_flat_dt_match(unsigned long node, const char *const *compat)
  */
 void __init early_init_dt_check_for_initrd(unsigned long node)
 {
-	unsigned long start, end, len;
+	u64 start, end;
+	unsigned long len;
 	__be32 *prop;
 
 	pr_debug("Looking for initrd properties... ");
@@ -558,15 +559,16 @@ void __init early_init_dt_check_for_initrd(unsigned long node)
 	prop = of_get_flat_dt_prop(node, "linux,initrd-start", &len);
 	if (!prop)
 		return;
-	start = of_read_ulong(prop, len/4);
+	start = of_read_number(prop, len/4);
 
 	prop = of_get_flat_dt_prop(node, "linux,initrd-end", &len);
 	if (!prop)
 		return;
-	end = of_read_ulong(prop, len/4);
+	end = of_read_number(prop, len/4);
 
 	early_init_dt_setup_initrd_arch(start, end);
-	pr_debug("initrd_start=0x%lx  initrd_end=0x%lx\n", start, end);
+	pr_debug("initrd_start=0x%llx  initrd_end=0x%llx\n",
+		 (unsigned long long)start, (unsigned long long)end);
 }
 #else
 inline void early_init_dt_check_for_initrd(unsigned long node)

commit 4c7d6361fa0dc9817ef878a7fbb6e50dd33c2f6d
Author: Robert P. J. Day <rpjday@crashcourse.ca>
Date:   Thu May 30 05:38:08 2013 -0400

    open firmware: "/aliasas" -> "/aliases"
    
    Fix "/aliasas" typo in comments, no functional change.
    
    Signed-off-by: Robert P. J. Day <rpjday@crashcourse.ca>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 808be06bb67e..6bb7cf2de556 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -709,7 +709,7 @@ void __init unflatten_device_tree(void)
 	__unflatten_device_tree(initial_boot_params, &of_allnodes,
 				early_init_dt_alloc_memory_arch);
 
-	/* Get pointer to "/chosen" and "/aliasas" nodes for use everywhere */
+	/* Get pointer to "/chosen" and "/aliases" nodes for use everywhere */
 	of_alias_scan(early_init_dt_alloc_memory_arch);
 }
 

commit 375da3a76dc49f10c35e243ebef62df12e3adf4e
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Dec 17 16:01:28 2012 -0800

    drivers/of/fdt.c: re-use kernel's kbasename()
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index a65c39c473bf..808be06bb67e 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -488,14 +488,8 @@ int __init of_scan_flat_dt(int (*it)(unsigned long node,
 		depth++;
 		pathp = (char *)p;
 		p = ALIGN(p + strlen(pathp) + 1, 4);
-		if ((*pathp) == '/') {
-			const char *lp, *np;
-			for (lp = NULL, np = pathp; *np; np++)
-				if ((*np) == '/')
-					lp = np+1;
-			if (lp != NULL)
-				pathp = lp;
-		}
+		if (*pathp == '/')
+			pathp = kbasename(pathp);
 		rc = it(p, pathp, depth, data);
 		if (rc != 0)
 			break;

commit 465aac6d496aa3e99caaa6868865fb3830f73d80
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Fri Nov 30 10:01:51 2012 +0000

    Fix build when CONFIG_W1_MASTER_GPIO=m b exporting "allnodes"
    
    ERROR: "allnodes" [drivers/w1/masters/w1-gpio.ko] undefined!
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    [grant.likely: allnodes is too generic; rename to of_allnodes]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Ville Syrjala <syrjala@sci.fi>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index e36ff40011f4..a65c39c473bf 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -712,7 +712,7 @@ int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
  */
 void __init unflatten_device_tree(void)
 {
-	__unflatten_device_tree(initial_boot_params, &allnodes,
+	__unflatten_device_tree(initial_boot_params, &of_allnodes,
 				early_init_dt_alloc_memory_arch);
 
 	/* Get pointer to "/chosen" and "/aliasas" nodes for use everywhere */

commit 0fca5deafeac764c2ab0d37c2409fdd0962d5724
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Fri Nov 16 15:14:38 2012 +0000

    of/fdt: NULL-terminate the root node path
    
    Commit 509b7455 (of/fdt: Don't copy garbage after "/" in root node path)
    sets the path length to 0 to ignore any garbage after "/" in the root
    node path. This has the side effect of also ignoring '\0' at the end of
    the root node path. This patch sets the ignores the garbage by setting
    the last character to '\0' and length to 1.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 135b8083212a..e36ff40011f4 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -186,7 +186,8 @@ static unsigned long unflatten_dt_node(struct boot_param_header *blob,
 			 */
 			fpsize = 1;
 			allocl = 2;
-			l = 0;
+			l = 1;
+			*pathp = '\0';
 		} else {
 			/* account for '/' and path size minus terminal 0
 			 * already in 'l'

commit e55b0829cbace88f4b50036432a12146d22cd106
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Mon Nov 12 18:30:49 2012 -0200

    of: fdt: Constify 'pathp'
    
    Constify 'pathp' in order to get rid of the following warning:
    
    drivers/of/fdt.c:491:10: warning: assignment discards 'const' qualifier from pointer target type [enabled by default]
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    [Rob Herring: also constify np and lp]
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index c8be32644c85..135b8083212a 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -460,7 +460,7 @@ int __init of_scan_flat_dt(int (*it)(unsigned long node,
 
 	do {
 		u32 tag = be32_to_cpup((__be32 *)p);
-		char *pathp;
+		const char *pathp;
 
 		p += 4;
 		if (tag == OF_DT_END_NODE) {
@@ -488,7 +488,7 @@ int __init of_scan_flat_dt(int (*it)(unsigned long node,
 		pathp = (char *)p;
 		p = ALIGN(p + strlen(pathp) + 1, 4);
 		if ((*pathp) == '/') {
-			char *lp, *np;
+			const char *lp, *np;
 			for (lp = NULL, np = pathp; *np; np++)
 				if ((*np) == '/')
 					lp = np+1;

commit c22618a11d1ba2966bd2cfd5e4918ed4f2dad13e
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Wed Nov 14 22:37:12 2012 +0000

    drivers/of: Constify device_node->name and ->path_component_name
    
    Neither of these should ever be changed once set. Make them const and
    fix up the users that try to modify it in-place. In one case
    kmalloc+memcpy is replaced with kstrdup() to avoid modifying the string.
    
    Build tested with defconfigs on ARM, PowerPC, Sparc, MIPS, x86 among
    others.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: David S. Miller <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Julian Calaby <julian.calaby@gmail.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index c2b08dcdbc53..c8be32644c85 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -199,10 +199,10 @@ static unsigned long unflatten_dt_node(struct boot_param_header *blob,
 	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
 				__alignof__(struct device_node));
 	if (allnextpp) {
+		char *fn;
 		memset(np, 0, sizeof(*np));
-		np->full_name = ((char *)np) + sizeof(struct device_node);
+		np->full_name = fn = ((char *)np) + sizeof(*np);
 		if (new_format) {
-			char *fn = np->full_name;
 			/* rebuild full path for new format */
 			if (dad && dad->parent) {
 				strcpy(fn, dad->full_name);
@@ -216,9 +216,9 @@ static unsigned long unflatten_dt_node(struct boot_param_header *blob,
 				fn += strlen(fn);
 			}
 			*(fn++) = '/';
-			memcpy(fn, pathp, l);
-		} else
-			memcpy(np->full_name, pathp, l);
+		}
+		memcpy(fn, pathp, l);
+
 		prev_pp = &np->properties;
 		**allnextpp = np;
 		*allnextpp = &np->allnext;

commit 509b7455ef87e1447670c51037cabbf93d772d6f
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Oct 22 11:32:30 2012 +1100

    of/fdt: Don't copy garbage after "/" in root node path
    
    The root node path must be internally converted to "/", or various
    pieces of code looking for it that way will fail. The code to do
    that however had a bug where we might incorrectly append pieces
    of the original path from the fdt to the "/".
    
    We should probably add a proper dedicated accessor for the root node
    but in the meantime this patch should fix it.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 91a375fb6ae6..c2b08dcdbc53 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -186,6 +186,7 @@ static unsigned long unflatten_dt_node(struct boot_param_header *blob,
 			 */
 			fpsize = 1;
 			allocl = 2;
+			l = 0;
 		} else {
 			/* account for '/' and path size minus terminal 0
 			 * already in 'l'

commit d022bbc712eb1fc53fbbec27a9f0ae07f55f9b65
Author: Danny Kukawka <danny.kukawka@bisect.de>
Date:   Wed Feb 15 18:55:28 2012 +0100

    of/fdt.c: asm/setup.h included twice
    
    drivers/of/fdt.c included 'asm/setup.h' twice, remove the duplicate.
    
    Signed-off-by: Danny Kukawka <danny.kukawka@bisect.de>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index ea2bd1be2640..91a375fb6ae6 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -23,7 +23,6 @@
 #include <asm/machdep.h>
 #endif /* CONFIG_PPC */
 
-#include <asm/setup.h>
 #include <asm/page.h>
 
 char *of_fdt_get_string(struct boot_param_header *blob, u32 offset)

commit eb52d5801302a3515506891c13338fbaa7222f36
Author: Yu Yue <yuyue@mprc.pku.edu.cn>
Date:   Fri Aug 26 18:03:42 2011 +0800

    of: add include asm/setup.h in drivers/of/fdt.c
    
    In the file drivers/of/fdt.c, it uses the COMMAND_LINE_SIZE which is stated
    in asm/setup.h, so asm/setup.h should be included in drivers/of/fdt.c.
    
    Signed-off-by: Yu Yue <yuyue@mprc.pku.edu.cn>
    Signed-off-by: Guan Xuetao <guanxuetao@mprc.pku.edu.cn>
    
    Cc: Grant Likerly <grant.likely@secretlab.ca>
    Cc: devicetree-discuss@lists.ozlabs.org
    Cc: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 91a375fb6ae6..ea2bd1be2640 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -23,6 +23,7 @@
 #include <asm/machdep.h>
 #endif /* CONFIG_PPC */
 
+#include <asm/setup.h>
 #include <asm/page.h>
 
 char *of_fdt_get_string(struct boot_param_header *blob, u32 offset)

commit c89810acbcf48c7004e912b2b4b862480b2d00e1
Author: Fabio Estevam <festevam@gmail.com>
Date:   Mon Jan 2 14:19:03 2012 -0200

    ARM: prom.h: Fix build error by removing unneeded header file
    
    Fix the following build error:
    
      CC [M]  fs/udf/balloc.o
    In file included from /home/fabio/next/linux-next/arch/arm/include/asm/prom.h:16,
                     from include/linux/of.h:140,
                     from include/asm-generic/gpio.h:7,
                     from arch/arm/plat-mxc/include/mach/irqs.h:14,
                     from /home/fabio/next/linux-next/arch/arm/include/asm/irq.h:4,
                     from /home/fabio/next/linux-next/arch/arm/include/asm/hardirq.h:6,
                     from include/linux/hardirq.h:7,
                     from include/linux/highmem.h:8,
                     from include/linux/pagemap.h:10,
                     from include/linux/buffer_head.h:13,
                     from fs/udf/udfdecl.h:11,
                     from fs/udf/balloc.c:22:
    /home/fabio/next/linux-next/arch/arm/include/asm/setup.h:146: error: redefinition of 'struct tag'
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    [grant.likely: fix build failure on drivers/of/fdt.c]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 7dc8e6da858d..91a375fb6ae6 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -18,6 +18,7 @@
 #include <linux/errno.h>
 #include <linux/slab.h>
 
+#include <asm/setup.h>  /* for COMMAND_LINE_SIZE */
 #ifdef CONFIG_PPC
 #include <asm/machdep.h>
 #endif /* CONFIG_PPC */

commit 7b482c8360d368fd495685a2c69ca4f1e7b29764
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Tue Dec 20 22:56:45 2011 +0100

    ARM/of: allow *machine_desc.dt_compat to be const
    
    This allows dt_compat to point to a constant list of compatible strings.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index fd85fa298e0f..7dc8e6da858d 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -107,7 +107,7 @@ int of_fdt_is_compatible(struct boot_param_header *blob,
  * of_fdt_match - Return true if node matches a list of compatible values
  */
 int of_fdt_match(struct boot_param_header *blob, unsigned long node,
-                 const char **compat)
+                 const char *const *compat)
 {
 	unsigned int tmp, score = 0;
 
@@ -541,7 +541,7 @@ int __init of_flat_dt_is_compatible(unsigned long node, const char *compat)
 /**
  * of_flat_dt_match - Return true if node matches a list of compatible values
  */
-int __init of_flat_dt_match(unsigned long node, const char **compat)
+int __init of_flat_dt_match(unsigned long node, const char *const *compat)
 {
 	return of_fdt_match(initial_boot_params, node, compat);
 }

commit 1197ab2942f920f261952de0c392ac749a35796b
Merge: ec773e99ab4a 96cc017c5b7e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Nov 6 17:12:03 2011 -0800

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc: (106 commits)
      powerpc/p3060qds: Add support for P3060QDS board
      powerpc/83xx: Add shutdown request support to MCU handling on MPC8349 MITX
      powerpc/85xx: Make kexec to interate over online cpus
      powerpc/fsl_booke: Fix comment in head_fsl_booke.S
      powerpc/85xx: issue 15 EOI after core reset for FSL CoreNet devices
      powerpc/8xxx: Fix interrupt handling in MPC8xxx GPIO driver
      powerpc/85xx: Add 'fsl,pq3-gpio' compatiable for GPIO driver
      powerpc/86xx: Correct Gianfar support for GE boards
      powerpc/cpm: Clear muram before it is in use.
      drivers/virt: add ioctl for 32-bit compat on 64-bit to fsl-hv-manager
      powerpc/fsl_msi: add support for "msi-address-64" property
      powerpc/85xx: Setup secondary cores PIR with hard SMP id
      powerpc/fsl-booke: Fix settlbcam for 64-bit
      powerpc/85xx: Adding DCSR node to dtsi device trees
      powerpc/85xx: clean up FPGA device tree nodes for Freecsale QorIQ boards
      powerpc/85xx: fix PHYS_64BIT selection for P1022DS
      powerpc/fsl-booke: Fix setup_initial_memory_limit to not blindly map
      powerpc: respect mem= setting for early memory limit setup
      powerpc: Update corenet64_smp_defconfig
      powerpc: Update mpc85xx/corenet 32-bit defconfigs
      ...
    
    Fix up trivial conflicts in:
     - arch/powerpc/configs/40x/hcu4_defconfig
            removed stale file, edited elsewhere
     - arch/powerpc/include/asm/udbg.h, arch/powerpc/kernel/udbg.c:
            added opal and gelic drivers vs added ePAPR driver
     - drivers/tty/serial/8250.c
            moved UPIO_TSI to powerpc vs removed UPIO_DWAPB support

commit 611cad720148c899db5a383c1c676fd820df7023
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Mon Aug 15 15:28:14 2011 +0800

    dt: add of_alias_scan and of_alias_get_id
    
    The patch adds function of_alias_scan to populate a global lookup
    table with the properties of 'aliases' node and function
    of_alias_get_id for drivers to find alias id from the lookup table.
    
    v3: Split out automatic addition of aliases on id lookup so that it can be
        debated separately from the core functionality.
    v2: - Add of_chosen/of_aliases populating and of_alias_scan() invocation
        for OF_PROMTREE.
        - Add locking
        - rework parse loop
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 65200af29c52..aeec35bc3789 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -707,10 +707,8 @@ void __init unflatten_device_tree(void)
 	__unflatten_device_tree(initial_boot_params, &allnodes,
 				early_init_dt_alloc_memory_arch);
 
-	/* Get pointer to OF "/chosen" node for use everywhere */
-	of_chosen = of_find_node_by_path("/chosen");
-	if (of_chosen == NULL)
-		of_chosen = of_find_node_by_path("/chosen@0");
+	/* Get pointer to "/chosen" and "/aliasas" nodes for use everywhere */
+	of_alias_scan(early_init_dt_alloc_memory_arch);
 }
 
 #endif /* CONFIG_OF_EARLY_FLATTREE */

commit 78b782cb788cadbda151ecb61753c109602a250c
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Sep 19 18:50:15 2011 +0000

    of: Change logic to overwrite cmd_line with CONFIG_CMDLINE
    
    We used to overwrite with CONFIG_CMDLINE if we found a chosen
    node but failed to get bootargs out of it or they were empty,
    unless CONFIG_CMDLINE_FORCE is set.
    
    Instead change that to overwrite if "data" is non empty after
    the bootargs check. It allows arch code to have other mechanisms
    to retrieve the command line prior to parsing the device-tree.
    
    Note: CONFIG_CMDLINE_FORCE case should ideally be handled elsewhere
    as it won't work as it-is if the device-tree has no /chosen node
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    CC: devicetree-discuss@lists-ozlabs.org
    CC: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 65200af29c52..4af69a3564cc 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -681,9 +681,14 @@ int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
 	if (p != NULL && l > 0)
 		strlcpy(data, p, min((int)l, COMMAND_LINE_SIZE));
 
+	/*
+	 * CONFIG_CMDLINE is meant to be a default in case nothing else
+	 * managed to set the command line, unless CONFIG_CMDLINE_FORCE
+	 * is set in which case we override whatever was found earlier.
+	 */
 #ifdef CONFIG_CMDLINE
 #ifndef CONFIG_CMDLINE_FORCE
-	if (p == NULL || l == 0 || (l == 1 && (*p) == 0))
+	if (!((char *)data)[0])
 #endif
 		strlcpy(data, CONFIG_CMDLINE, COMMAND_LINE_SIZE);
 #endif /* CONFIG_CMDLINE */

commit fe55c1844a1c106e9d9d3dd27cbfcf8caeb9e77e
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Aug 4 10:27:32 2011 +0100

    Revert "dt: add of_alias_scan and of_alias_get_id"
    
    This reverts commit 750f463a749e28464151ad26938d11b07b1c43cb.
    
    of_alias_* still needs work to be generalized for 'promtree' dt
    platforms, and to no implicitly create entries for available ids.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 13d6d3a96b31..65200af29c52 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -707,12 +707,10 @@ void __init unflatten_device_tree(void)
 	__unflatten_device_tree(initial_boot_params, &allnodes,
 				early_init_dt_alloc_memory_arch);
 
-	/* Get pointer to "/chosen" and "/aliasas" nodes for use everywhere */
+	/* Get pointer to OF "/chosen" node for use everywhere */
 	of_chosen = of_find_node_by_path("/chosen");
 	if (of_chosen == NULL)
 		of_chosen = of_find_node_by_path("/chosen@0");
-	of_aliases = of_find_node_by_path("/aliases");
-	of_alias_scan();
 }
 
 #endif /* CONFIG_OF_EARLY_FLATTREE */

commit 750f463a749e28464151ad26938d11b07b1c43cb
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Wed Aug 3 11:28:14 2011 +0100

    dt: add of_alias_scan and of_alias_get_id
    
    The patch adds function of_alias_scan to populate a global lookup
    table with the properties of 'aliases' node and function
    of_alias_get_id for drivers to find alias id from the lookup table.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    [grant.likely: add locking and rework parse loop]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 65200af29c52..13d6d3a96b31 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -707,10 +707,12 @@ void __init unflatten_device_tree(void)
 	__unflatten_device_tree(initial_boot_params, &allnodes,
 				early_init_dt_alloc_memory_arch);
 
-	/* Get pointer to OF "/chosen" node for use everywhere */
+	/* Get pointer to "/chosen" and "/aliasas" nodes for use everywhere */
 	of_chosen = of_find_node_by_path("/chosen");
 	if (of_chosen == NULL)
 		of_chosen = of_find_node_by_path("/chosen@0");
+	of_aliases = of_find_node_by_path("/aliases");
+	of_alias_scan();
 }
 
 #endif /* CONFIG_OF_EARLY_FLATTREE */

commit 85f60ae4ee817174b0f78928bc7066f28c3551ab
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Apr 29 00:18:16 2011 -0600

    dt/flattree: explicitly pass command line pointer to early_init_dt_scan_chosen
    
    This patch drops the reference to a global 'cmd_line' variable from
    early_init_dt_scan_chosen, and instead passes the pointer to the command
    line string via the *data argument.  Each architecture does something
    slightly different with the initial command line, so it makes sense for
    the architecture to be able to specify the variable name.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 8b63a691a9ed..65200af29c52 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -670,7 +670,7 @@ int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
 
 	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);
 
-	if (depth != 1 ||
+	if (depth != 1 || !data ||
 	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))
 		return 0;
 
@@ -679,16 +679,16 @@ int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
 	/* Retrieve command line */
 	p = of_get_flat_dt_prop(node, "bootargs", &l);
 	if (p != NULL && l > 0)
-		strlcpy(cmd_line, p, min((int)l, COMMAND_LINE_SIZE));
+		strlcpy(data, p, min((int)l, COMMAND_LINE_SIZE));
 
 #ifdef CONFIG_CMDLINE
 #ifndef CONFIG_CMDLINE_FORCE
 	if (p == NULL || l == 0 || (l == 1 && (*p) == 0))
 #endif
-		strlcpy(cmd_line, CONFIG_CMDLINE, COMMAND_LINE_SIZE);
+		strlcpy(data, CONFIG_CMDLINE, COMMAND_LINE_SIZE);
 #endif /* CONFIG_CMDLINE */
 
-	pr_debug("Command line is: %s\n", cmd_line);
+	pr_debug("Command line is: %s\n", (char*)data);
 
 	/* break now */
 	return 1;

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index c9db49c10f45..8b63a691a9ed 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -676,7 +676,7 @@ int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
 
 	early_init_dt_check_for_initrd(node);
 
-	/* Retreive command line */
+	/* Retrieve command line */
 	p = of_get_flat_dt_prop(node, "bootargs", &l);
 	if (p != NULL && l > 0)
 		strlcpy(cmd_line, p, min((int)l, COMMAND_LINE_SIZE));

commit a7006c9747ef225ab070d96c054e85682a09a13e
Author: Andres Salomon <dilinger@queued.net>
Date:   Thu Mar 17 17:32:35 2011 -0700

    of/flattree: minor cleanups
    
     - static-ize some functions
     - add some additional comments
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index af824e7e0367..c9db49c10f45 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -139,12 +139,13 @@ static void *unflatten_dt_alloc(unsigned long *mem, unsigned long size,
 /**
  * unflatten_dt_node - Alloc and populate a device_node from the flat tree
  * @blob: The parent device tree blob
+ * @mem: Memory chunk to use for allocating device nodes and properties
  * @p: pointer to node in flat tree
  * @dad: Parent struct device_node
  * @allnextpp: pointer to ->allnext from last allocated device_node
  * @fpsize: Size of the node path up at the current depth.
  */
-unsigned long unflatten_dt_node(struct boot_param_header *blob,
+static unsigned long unflatten_dt_node(struct boot_param_header *blob,
 				unsigned long mem,
 				unsigned long *p,
 				struct device_node *dad,
@@ -230,6 +231,7 @@ unsigned long unflatten_dt_node(struct boot_param_header *blob,
 		}
 		kref_init(&np->kref);
 	}
+	/* process properties */
 	while (1) {
 		u32 sz, noff;
 		char *pname;
@@ -351,7 +353,7 @@ unsigned long unflatten_dt_node(struct boot_param_header *blob,
  * @dt_alloc: An allocator that provides a virtual address to memory
  * for the resulting tree
  */
-void __unflatten_device_tree(struct boot_param_header *blob,
+static void __unflatten_device_tree(struct boot_param_header *blob,
 			     struct device_node **mynodes,
 			     void * (*dt_alloc)(u64 size, u64 align))
 {

commit 672c54466d24994eb9633f993862c89539504a42
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Jan 13 15:36:09 2011 -0700

    dt/flattree: Return virtual address from early_init_dt_alloc_memory_arch()
    
    The physical address is never used by the device tree code when
    allocating memory for unflattening.  Change the architecture's alloc
    hook to return the virutal address instead.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index c787c3d95c60..af824e7e0367 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -692,12 +692,6 @@ int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
 	return 1;
 }
 
-static void *__init early_device_tree_alloc(u64 size, u64 align)
-{
-	unsigned long mem = early_init_dt_alloc_memory_arch(size, align);
-	return __va(mem);
-}
-
 /**
  * unflatten_device_tree - create tree of device_nodes from flat blob
  *
@@ -709,7 +703,7 @@ static void *__init early_device_tree_alloc(u64 size, u64 align)
 void __init unflatten_device_tree(void)
 {
 	__unflatten_device_tree(initial_boot_params, &allnodes,
-				early_device_tree_alloc);
+				early_init_dt_alloc_memory_arch);
 
 	/* Get pointer to OF "/chosen" node for use everywhere */
 	of_chosen = of_find_node_by_path("/chosen");

commit a4f740cf33f7f6c164bbde3c0cdbcc77b0c4997c
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Sat Oct 30 11:49:09 2010 -0400

    of/flattree: Add of_flat_dt_match() helper function
    
    This patch adds of_flat_dt_match() which tests a node for
    compatibility with a list of values and converts the relevant powerpc
    platform code to use it.  This approach simplifies the board support
    code a bit.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Reviewed-by: Stephen Neuendorffer <stephen.neuendorffer@xilinx.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 8a90ee42071a..c787c3d95c60 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -78,19 +78,23 @@ void *of_fdt_get_property(struct boot_param_header *blob,
  * @blob: A device tree blob
  * @node: node to test
  * @compat: compatible string to compare with compatible list.
+ *
+ * On match, returns a non-zero value with smaller values returned for more
+ * specific compatible values.
  */
 int of_fdt_is_compatible(struct boot_param_header *blob,
 		      unsigned long node, const char *compat)
 {
 	const char *cp;
-	unsigned long cplen, l;
+	unsigned long cplen, l, score = 0;
 
 	cp = of_fdt_get_property(blob, node, "compatible", &cplen);
 	if (cp == NULL)
 		return 0;
 	while (cplen > 0) {
+		score++;
 		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
-			return 1;
+			return score;
 		l = strlen(cp) + 1;
 		cp += l;
 		cplen -= l;
@@ -99,6 +103,27 @@ int of_fdt_is_compatible(struct boot_param_header *blob,
 	return 0;
 }
 
+/**
+ * of_fdt_match - Return true if node matches a list of compatible values
+ */
+int of_fdt_match(struct boot_param_header *blob, unsigned long node,
+                 const char **compat)
+{
+	unsigned int tmp, score = 0;
+
+	if (!compat)
+		return 0;
+
+	while (*compat) {
+		tmp = of_fdt_is_compatible(blob, node, *compat);
+		if (tmp && (score == 0 || (tmp < score)))
+			score = tmp;
+		compat++;
+	}
+
+	return score;
+}
+
 static void *unflatten_dt_alloc(unsigned long *mem, unsigned long size,
 				       unsigned long align)
 {
@@ -511,6 +536,14 @@ int __init of_flat_dt_is_compatible(unsigned long node, const char *compat)
 	return of_fdt_is_compatible(initial_boot_params, node, compat);
 }
 
+/**
+ * of_flat_dt_match - Return true if node matches a list of compatible values
+ */
+int __init of_flat_dt_match(unsigned long node, const char **compat)
+{
+	return of_fdt_match(initial_boot_params, node, compat);
+}
+
 #ifdef CONFIG_BLK_DEV_INITRD
 /**
  * early_init_dt_check_for_initrd - Decode initrd location from flat tree

commit fe14042358fac0673d4b6362a73796fd64379938
Author: Stephen Neuendorffer <stephen.neuendorffer@xilinx.com>
Date:   Thu Nov 18 15:55:02 2010 -0800

    of/flattree: Refactor unflatten_device_tree and add fdt_unflatten_tree
    
    unflatten_device_tree has two dependencies on things that happen
    during boot time.  Firstly, it references the initial device tree
    directly. Secondly, it allocates memory using the early boot
    allocator.  This patch factors out these dependencies and uses
    the new __unflatten_device_tree function to implement a driver-visible
    fdt_unflatten_tree function, which can be used to unflatten a
    blob after boot time.
    
    V2:
    - remove extra __va() call
    - make dt_alloc functions return void *.  This doesn't fix the general
      strangeness in this code that constantly casts back and forth between
      unsigned long and __be32 *
    
    Signed-off-by: Stephen Neuendorffer <stephen.neuendorffer@xilinx.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 71edc9cecd62..8a90ee42071a 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -11,10 +11,12 @@
 
 #include <linux/kernel.h>
 #include <linux/initrd.h>
+#include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_fdt.h>
 #include <linux/string.h>
 #include <linux/errno.h>
+#include <linux/slab.h>
 
 #ifdef CONFIG_PPC
 #include <asm/machdep.h>
@@ -312,6 +314,94 @@ unsigned long unflatten_dt_node(struct boot_param_header *blob,
 	return mem;
 }
 
+/**
+ * __unflatten_device_tree - create tree of device_nodes from flat blob
+ *
+ * unflattens a device-tree, creating the
+ * tree of struct device_node. It also fills the "name" and "type"
+ * pointers of the nodes so the normal device-tree walking functions
+ * can be used.
+ * @blob: The blob to expand
+ * @mynodes: The device_node tree created by the call
+ * @dt_alloc: An allocator that provides a virtual address to memory
+ * for the resulting tree
+ */
+void __unflatten_device_tree(struct boot_param_header *blob,
+			     struct device_node **mynodes,
+			     void * (*dt_alloc)(u64 size, u64 align))
+{
+	unsigned long start, mem, size;
+	struct device_node **allnextp = mynodes;
+
+	pr_debug(" -> unflatten_device_tree()\n");
+
+	if (!blob) {
+		pr_debug("No device tree pointer\n");
+		return;
+	}
+
+	pr_debug("Unflattening device tree:\n");
+	pr_debug("magic: %08x\n", be32_to_cpu(blob->magic));
+	pr_debug("size: %08x\n", be32_to_cpu(blob->totalsize));
+	pr_debug("version: %08x\n", be32_to_cpu(blob->version));
+
+	if (be32_to_cpu(blob->magic) != OF_DT_HEADER) {
+		pr_err("Invalid device tree blob header\n");
+		return;
+	}
+
+	/* First pass, scan for size */
+	start = ((unsigned long)blob) +
+		be32_to_cpu(blob->off_dt_struct);
+	size = unflatten_dt_node(blob, 0, &start, NULL, NULL, 0);
+	size = (size | 3) + 1;
+
+	pr_debug("  size is %lx, allocating...\n", size);
+
+	/* Allocate memory for the expanded device tree */
+	mem = (unsigned long)
+		dt_alloc(size + 4, __alignof__(struct device_node));
+
+	((__be32 *)mem)[size / 4] = cpu_to_be32(0xdeadbeef);
+
+	pr_debug("  unflattening %lx...\n", mem);
+
+	/* Second pass, do actual unflattening */
+	start = ((unsigned long)blob) +
+		be32_to_cpu(blob->off_dt_struct);
+	unflatten_dt_node(blob, mem, &start, NULL, &allnextp, 0);
+	if (be32_to_cpup((__be32 *)start) != OF_DT_END)
+		pr_warning("Weird tag at end of tree: %08x\n", *((u32 *)start));
+	if (be32_to_cpu(((__be32 *)mem)[size / 4]) != 0xdeadbeef)
+		pr_warning("End of tree marker overwritten: %08x\n",
+			   be32_to_cpu(((__be32 *)mem)[size / 4]));
+	*allnextp = NULL;
+
+	pr_debug(" <- unflatten_device_tree()\n");
+}
+
+static void *kernel_tree_alloc(u64 size, u64 align)
+{
+	return kzalloc(size, GFP_KERNEL);
+}
+
+/**
+ * of_fdt_unflatten_tree - create tree of device_nodes from flat blob
+ *
+ * unflattens the device-tree passed by the firmware, creating the
+ * tree of struct device_node. It also fills the "name" and "type"
+ * pointers of the nodes so the normal device-tree walking functions
+ * can be used.
+ */
+void of_fdt_unflatten_tree(unsigned long *blob,
+			struct device_node **mynodes)
+{
+	struct boot_param_header *device_tree =
+		(struct boot_param_header *)blob;
+	__unflatten_device_tree(device_tree, mynodes, &kernel_tree_alloc);
+}
+EXPORT_SYMBOL_GPL(of_fdt_unflatten_tree);
+
 /* Everything below here references initial_boot_params directly. */
 int __initdata dt_root_addr_cells;
 int __initdata dt_root_size_cells;
@@ -569,6 +659,12 @@ int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
 	return 1;
 }
 
+static void *__init early_device_tree_alloc(u64 size, u64 align)
+{
+	unsigned long mem = early_init_dt_alloc_memory_arch(size, align);
+	return __va(mem);
+}
+
 /**
  * unflatten_device_tree - create tree of device_nodes from flat blob
  *
@@ -579,62 +675,13 @@ int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
  */
 void __init unflatten_device_tree(void)
 {
-	unsigned long start, mem, size;
-	struct device_node **allnextp = &allnodes;
-
-	pr_debug(" -> unflatten_device_tree()\n");
-
-	if (!initial_boot_params) {
-		pr_debug("No device tree pointer\n");
-		return;
-	}
-
-	pr_debug("Unflattening device tree:\n");
-	pr_debug("magic: %08x\n", be32_to_cpu(initial_boot_params->magic));
-	pr_debug("size: %08x\n", be32_to_cpu(initial_boot_params->totalsize));
-	pr_debug("version: %08x\n", be32_to_cpu(initial_boot_params->version));
-
-	if (be32_to_cpu(initial_boot_params->magic) != OF_DT_HEADER) {
-		pr_err("Invalid device tree blob header\n");
-		return;
-	}
-
-	/* First pass, scan for size */
-	start = ((unsigned long)initial_boot_params) +
-		be32_to_cpu(initial_boot_params->off_dt_struct);
-	size = unflatten_dt_node(initial_boot_params, 0, &start,
-				 NULL, NULL, 0);
-	size = (size | 3) + 1;
-
-	pr_debug("  size is %lx, allocating...\n", size);
-
-	/* Allocate memory for the expanded device tree */
-	mem = early_init_dt_alloc_memory_arch(size + 4,
-			__alignof__(struct device_node));
-	mem = (unsigned long) __va(mem);
-
-	((__be32 *)mem)[size / 4] = cpu_to_be32(0xdeadbeef);
-
-	pr_debug("  unflattening %lx...\n", mem);
-
-	/* Second pass, do actual unflattening */
-	start = ((unsigned long)initial_boot_params) +
-		be32_to_cpu(initial_boot_params->off_dt_struct);
-	unflatten_dt_node(initial_boot_params, mem, &start,
-			  NULL, &allnextp, 0);
-	if (be32_to_cpup((__be32 *)start) != OF_DT_END)
-		pr_warning("Weird tag at end of tree: %08x\n", *((u32 *)start));
-	if (be32_to_cpu(((__be32 *)mem)[size / 4]) != 0xdeadbeef)
-		pr_warning("End of tree marker overwritten: %08x\n",
-			   be32_to_cpu(((__be32 *)mem)[size / 4]));
-	*allnextp = NULL;
+	__unflatten_device_tree(initial_boot_params, &allnodes,
+				early_device_tree_alloc);
 
 	/* Get pointer to OF "/chosen" node for use everywhere */
 	of_chosen = of_find_node_by_path("/chosen");
 	if (of_chosen == NULL)
 		of_chosen = of_find_node_by_path("/chosen@0");
-
-	pr_debug(" <- unflatten_device_tree()\n");
 }
 
 #endif /* CONFIG_OF_EARLY_FLATTREE */

commit 57d00ecf90cc9854973da2960012b734acc26e51
Author: Stephen Neuendorffer <stephen.neuendorffer@xilinx.com>
Date:   Thu Nov 18 15:55:01 2010 -0800

    of/flattree: Reorder unflatten_dt_node
    
    Move unflatten_dt_node to be grouped with non-__init functions.
    
    Signed-off-by: Stephen Neuendorffer <stephen.neuendorffer@xilinx.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index cf74e546faf2..71edc9cecd62 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -97,115 +97,6 @@ int of_fdt_is_compatible(struct boot_param_header *blob,
 	return 0;
 }
 
-/* Everything below here references initial_boot_params directly. */
-int __initdata dt_root_addr_cells;
-int __initdata dt_root_size_cells;
-
-struct boot_param_header *initial_boot_params;
-
-#ifdef CONFIG_OF_EARLY_FLATTREE
-
-/**
- * of_scan_flat_dt - scan flattened tree blob and call callback on each.
- * @it: callback function
- * @data: context data pointer
- *
- * This function is used to scan the flattened device-tree, it is
- * used to extract the memory information at boot before we can
- * unflatten the tree
- */
-int __init of_scan_flat_dt(int (*it)(unsigned long node,
-				     const char *uname, int depth,
-				     void *data),
-			   void *data)
-{
-	unsigned long p = ((unsigned long)initial_boot_params) +
-		be32_to_cpu(initial_boot_params->off_dt_struct);
-	int rc = 0;
-	int depth = -1;
-
-	do {
-		u32 tag = be32_to_cpup((__be32 *)p);
-		char *pathp;
-
-		p += 4;
-		if (tag == OF_DT_END_NODE) {
-			depth--;
-			continue;
-		}
-		if (tag == OF_DT_NOP)
-			continue;
-		if (tag == OF_DT_END)
-			break;
-		if (tag == OF_DT_PROP) {
-			u32 sz = be32_to_cpup((__be32 *)p);
-			p += 8;
-			if (be32_to_cpu(initial_boot_params->version) < 0x10)
-				p = ALIGN(p, sz >= 8 ? 8 : 4);
-			p += sz;
-			p = ALIGN(p, 4);
-			continue;
-		}
-		if (tag != OF_DT_BEGIN_NODE) {
-			pr_err("Invalid tag %x in flat device tree!\n", tag);
-			return -EINVAL;
-		}
-		depth++;
-		pathp = (char *)p;
-		p = ALIGN(p + strlen(pathp) + 1, 4);
-		if ((*pathp) == '/') {
-			char *lp, *np;
-			for (lp = NULL, np = pathp; *np; np++)
-				if ((*np) == '/')
-					lp = np+1;
-			if (lp != NULL)
-				pathp = lp;
-		}
-		rc = it(p, pathp, depth, data);
-		if (rc != 0)
-			break;
-	} while (1);
-
-	return rc;
-}
-
-/**
- * of_get_flat_dt_root - find the root node in the flat blob
- */
-unsigned long __init of_get_flat_dt_root(void)
-{
-	unsigned long p = ((unsigned long)initial_boot_params) +
-		be32_to_cpu(initial_boot_params->off_dt_struct);
-
-	while (be32_to_cpup((__be32 *)p) == OF_DT_NOP)
-		p += 4;
-	BUG_ON(be32_to_cpup((__be32 *)p) != OF_DT_BEGIN_NODE);
-	p += 4;
-	return ALIGN(p + strlen((char *)p) + 1, 4);
-}
-
-/**
- * of_get_flat_dt_prop - Given a node in the flat blob, return the property ptr
- *
- * This function can be used within scan_flattened_dt callback to get
- * access to properties
- */
-void *__init of_get_flat_dt_prop(unsigned long node, const char *name,
-				 unsigned long *size)
-{
-	return of_fdt_get_property(initial_boot_params, node, name, size);
-}
-
-/**
- * of_flat_dt_is_compatible - Return true if given node has compat in compatible list
- * @node: node to test
- * @compat: compatible string to compare with compatible list.
- */
-int __init of_flat_dt_is_compatible(unsigned long node, const char *compat)
-{
-	return of_fdt_is_compatible(initial_boot_params, node, compat);
-}
-
 static void *unflatten_dt_alloc(unsigned long *mem, unsigned long size,
 				       unsigned long align)
 {
@@ -421,6 +312,115 @@ unsigned long unflatten_dt_node(struct boot_param_header *blob,
 	return mem;
 }
 
+/* Everything below here references initial_boot_params directly. */
+int __initdata dt_root_addr_cells;
+int __initdata dt_root_size_cells;
+
+struct boot_param_header *initial_boot_params;
+
+#ifdef CONFIG_OF_EARLY_FLATTREE
+
+/**
+ * of_scan_flat_dt - scan flattened tree blob and call callback on each.
+ * @it: callback function
+ * @data: context data pointer
+ *
+ * This function is used to scan the flattened device-tree, it is
+ * used to extract the memory information at boot before we can
+ * unflatten the tree
+ */
+int __init of_scan_flat_dt(int (*it)(unsigned long node,
+				     const char *uname, int depth,
+				     void *data),
+			   void *data)
+{
+	unsigned long p = ((unsigned long)initial_boot_params) +
+		be32_to_cpu(initial_boot_params->off_dt_struct);
+	int rc = 0;
+	int depth = -1;
+
+	do {
+		u32 tag = be32_to_cpup((__be32 *)p);
+		char *pathp;
+
+		p += 4;
+		if (tag == OF_DT_END_NODE) {
+			depth--;
+			continue;
+		}
+		if (tag == OF_DT_NOP)
+			continue;
+		if (tag == OF_DT_END)
+			break;
+		if (tag == OF_DT_PROP) {
+			u32 sz = be32_to_cpup((__be32 *)p);
+			p += 8;
+			if (be32_to_cpu(initial_boot_params->version) < 0x10)
+				p = ALIGN(p, sz >= 8 ? 8 : 4);
+			p += sz;
+			p = ALIGN(p, 4);
+			continue;
+		}
+		if (tag != OF_DT_BEGIN_NODE) {
+			pr_err("Invalid tag %x in flat device tree!\n", tag);
+			return -EINVAL;
+		}
+		depth++;
+		pathp = (char *)p;
+		p = ALIGN(p + strlen(pathp) + 1, 4);
+		if ((*pathp) == '/') {
+			char *lp, *np;
+			for (lp = NULL, np = pathp; *np; np++)
+				if ((*np) == '/')
+					lp = np+1;
+			if (lp != NULL)
+				pathp = lp;
+		}
+		rc = it(p, pathp, depth, data);
+		if (rc != 0)
+			break;
+	} while (1);
+
+	return rc;
+}
+
+/**
+ * of_get_flat_dt_root - find the root node in the flat blob
+ */
+unsigned long __init of_get_flat_dt_root(void)
+{
+	unsigned long p = ((unsigned long)initial_boot_params) +
+		be32_to_cpu(initial_boot_params->off_dt_struct);
+
+	while (be32_to_cpup((__be32 *)p) == OF_DT_NOP)
+		p += 4;
+	BUG_ON(be32_to_cpup((__be32 *)p) != OF_DT_BEGIN_NODE);
+	p += 4;
+	return ALIGN(p + strlen((char *)p) + 1, 4);
+}
+
+/**
+ * of_get_flat_dt_prop - Given a node in the flat blob, return the property ptr
+ *
+ * This function can be used within scan_flattened_dt callback to get
+ * access to properties
+ */
+void *__init of_get_flat_dt_prop(unsigned long node, const char *name,
+				 unsigned long *size)
+{
+	return of_fdt_get_property(initial_boot_params, node, name, size);
+}
+
+/**
+ * of_flat_dt_is_compatible - Return true if given node has compat in compatible list
+ * @node: node to test
+ * @compat: compatible string to compare with compatible list.
+ */
+int __init of_flat_dt_is_compatible(unsigned long node, const char *compat)
+{
+	return of_fdt_is_compatible(initial_boot_params, node, compat);
+}
+
 #ifdef CONFIG_BLK_DEV_INITRD
 /**
  * early_init_dt_check_for_initrd - Decode initrd location from flat tree

commit a40d6c4cf12d87980c10b230df435d0f56adc40b
Author: Stephen Neuendorffer <stephen.neuendorffer@xilinx.com>
Date:   Thu Nov 18 15:55:00 2010 -0800

    of/flattree: Refactor unflatten_dt_node
    
    unflatten_dt_node is a helper function that does most of the work to
    convert a device tree blob into tree of device nodes.  This code
    now uses a passed-in blob instead of using the single boot-time blob,
    allowing it to be called in more contexts.
    
    Signed-off-by: Stephen Neuendorffer <stephen.neuendorffer@xilinx.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 10eab21076ea..cf74e546faf2 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -206,7 +206,7 @@ int __init of_flat_dt_is_compatible(unsigned long node, const char *compat)
 	return of_fdt_is_compatible(initial_boot_params, node, compat);
 }
 
-static void *__init unflatten_dt_alloc(unsigned long *mem, unsigned long size,
+static void *unflatten_dt_alloc(unsigned long *mem, unsigned long size,
 				       unsigned long align)
 {
 	void *res;
@@ -220,16 +220,18 @@ static void *__init unflatten_dt_alloc(unsigned long *mem, unsigned long size,
 
 /**
  * unflatten_dt_node - Alloc and populate a device_node from the flat tree
+ * @blob: The parent device tree blob
  * @p: pointer to node in flat tree
  * @dad: Parent struct device_node
  * @allnextpp: pointer to ->allnext from last allocated device_node
  * @fpsize: Size of the node path up at the current depth.
  */
-unsigned long __init unflatten_dt_node(unsigned long mem,
-					unsigned long *p,
-					struct device_node *dad,
-					struct device_node ***allnextpp,
-					unsigned long fpsize)
+unsigned long unflatten_dt_node(struct boot_param_header *blob,
+				unsigned long mem,
+				unsigned long *p,
+				struct device_node *dad,
+				struct device_node ***allnextpp,
+				unsigned long fpsize)
 {
 	struct device_node *np;
 	struct property *pp, **prev_pp = NULL;
@@ -325,10 +327,10 @@ unsigned long __init unflatten_dt_node(unsigned long mem,
 		sz = be32_to_cpup((__be32 *)(*p));
 		noff = be32_to_cpup((__be32 *)((*p) + 4));
 		*p += 8;
-		if (be32_to_cpu(initial_boot_params->version) < 0x10)
+		if (be32_to_cpu(blob->version) < 0x10)
 			*p = ALIGN(*p, sz >= 8 ? 8 : 4);
 
-		pname = of_fdt_get_string(initial_boot_params, noff);
+		pname = of_fdt_get_string(blob, noff);
 		if (pname == NULL) {
 			pr_info("Can't find property name in list !\n");
 			break;
@@ -407,7 +409,8 @@ unsigned long __init unflatten_dt_node(unsigned long mem,
 		if (tag == OF_DT_NOP)
 			*p += 4;
 		else
-			mem = unflatten_dt_node(mem, p, np, allnextpp, fpsize);
+			mem = unflatten_dt_node(blob, mem, p, np, allnextpp,
+						fpsize);
 		tag = be32_to_cpup((__be32 *)(*p));
 	}
 	if (tag != OF_DT_END_NODE) {
@@ -599,7 +602,8 @@ void __init unflatten_device_tree(void)
 	/* First pass, scan for size */
 	start = ((unsigned long)initial_boot_params) +
 		be32_to_cpu(initial_boot_params->off_dt_struct);
-	size = unflatten_dt_node(0, &start, NULL, NULL, 0);
+	size = unflatten_dt_node(initial_boot_params, 0, &start,
+				 NULL, NULL, 0);
 	size = (size | 3) + 1;
 
 	pr_debug("  size is %lx, allocating...\n", size);
@@ -616,7 +620,8 @@ void __init unflatten_device_tree(void)
 	/* Second pass, do actual unflattening */
 	start = ((unsigned long)initial_boot_params) +
 		be32_to_cpu(initial_boot_params->off_dt_struct);
-	unflatten_dt_node(mem, &start, NULL, &allnextp, 0);
+	unflatten_dt_node(initial_boot_params, mem, &start,
+			  NULL, &allnextp, 0);
 	if (be32_to_cpup((__be32 *)start) != OF_DT_END)
 		pr_warning("Weird tag at end of tree: %08x\n", *((u32 *)start));
 	if (be32_to_cpu(((__be32 *)mem)[size / 4]) != 0xdeadbeef)

commit 9706a36e35c4ce04f28a62cfe1205b4e3b0dd13c
Author: Stephen Neuendorffer <stephen.neuendorffer@xilinx.com>
Date:   Thu Nov 18 15:54:59 2010 -0800

    of/flattree: Add non-boottime device tree functions
    
    In preparation for providing run-time handling of device trees, factor
    out some of the basic functions so that they take an arbitrary blob,
    rather than relying on the single boot-time tree.
    
    V2:
    - functions have of_fdt_* names
    - removed find_flat_dt_string
    - blob argument is first
    
    Signed-off-by: Stephen Neuendorffer <stephen.neuendorffer@xilinx.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 2ebacf14e7de..10eab21076ea 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -22,6 +22,82 @@
 
 #include <asm/page.h>
 
+char *of_fdt_get_string(struct boot_param_header *blob, u32 offset)
+{
+	return ((char *)blob) +
+		be32_to_cpu(blob->off_dt_strings) + offset;
+}
+
+/**
+ * of_fdt_get_property - Given a node in the given flat blob, return
+ * the property ptr
+ */
+void *of_fdt_get_property(struct boot_param_header *blob,
+		       unsigned long node, const char *name,
+		       unsigned long *size)
+{
+	unsigned long p = node;
+
+	do {
+		u32 tag = be32_to_cpup((__be32 *)p);
+		u32 sz, noff;
+		const char *nstr;
+
+		p += 4;
+		if (tag == OF_DT_NOP)
+			continue;
+		if (tag != OF_DT_PROP)
+			return NULL;
+
+		sz = be32_to_cpup((__be32 *)p);
+		noff = be32_to_cpup((__be32 *)(p + 4));
+		p += 8;
+		if (be32_to_cpu(blob->version) < 0x10)
+			p = ALIGN(p, sz >= 8 ? 8 : 4);
+
+		nstr = of_fdt_get_string(blob, noff);
+		if (nstr == NULL) {
+			pr_warning("Can't find property index name !\n");
+			return NULL;
+		}
+		if (strcmp(name, nstr) == 0) {
+			if (size)
+				*size = sz;
+			return (void *)p;
+		}
+		p += sz;
+		p = ALIGN(p, 4);
+	} while (1);
+}
+
+/**
+ * of_fdt_is_compatible - Return true if given node from the given blob has
+ * compat in its compatible list
+ * @blob: A device tree blob
+ * @node: node to test
+ * @compat: compatible string to compare with compatible list.
+ */
+int of_fdt_is_compatible(struct boot_param_header *blob,
+		      unsigned long node, const char *compat)
+{
+	const char *cp;
+	unsigned long cplen, l;
+
+	cp = of_fdt_get_property(blob, node, "compatible", &cplen);
+	if (cp == NULL)
+		return 0;
+	while (cplen > 0) {
+		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
+			return 1;
+		l = strlen(cp) + 1;
+		cp += l;
+		cplen -= l;
+	}
+
+	return 0;
+}
+
+/* Everything below here references initial_boot_params directly. */
 int __initdata dt_root_addr_cells;
 int __initdata dt_root_size_cells;
 
@@ -29,12 +105,6 @@ struct boot_param_header *initial_boot_params;
 
 #ifdef CONFIG_OF_EARLY_FLATTREE
 
-char *find_flat_dt_string(u32 offset)
-{
-	return ((char *)initial_boot_params) +
-		be32_to_cpu(initial_boot_params->off_dt_strings) + offset;
-}
-
 /**
  * of_scan_flat_dt - scan flattened tree blob and call callback on each.
  * @it: callback function
@@ -123,38 +193,7 @@ unsigned long __init of_get_flat_dt_root(void)
 void *__init of_get_flat_dt_prop(unsigned long node, const char *name,
 				 unsigned long *size)
 {
-	unsigned long p = node;
-
-	do {
-		u32 tag = be32_to_cpup((__be32 *)p);
-		u32 sz, noff;
-		const char *nstr;
-
-		p += 4;
-		if (tag == OF_DT_NOP)
-			continue;
-		if (tag != OF_DT_PROP)
-			return NULL;
-
-		sz = be32_to_cpup((__be32 *)p);
-		noff = be32_to_cpup((__be32 *)(p + 4));
-		p += 8;
-		if (be32_to_cpu(initial_boot_params->version) < 0x10)
-			p = ALIGN(p, sz >= 8 ? 8 : 4);
-
-		nstr = find_flat_dt_string(noff);
-		if (nstr == NULL) {
-			pr_warning("Can't find property index name !\n");
-			return NULL;
-		}
-		if (strcmp(name, nstr) == 0) {
-			if (size)
-				*size = sz;
-			return (void *)p;
-		}
-		p += sz;
-		p = ALIGN(p, 4);
-	} while (1);
+	return of_fdt_get_property(initial_boot_params, node, name, size);
 }
 
 /**
@@ -164,21 +203,7 @@ void *__init of_get_flat_dt_prop(unsigned long node, const char *name,
  */
 int __init of_flat_dt_is_compatible(unsigned long node, const char *compat)
 {
-	const char *cp;
-	unsigned long cplen, l;
-
-	cp = of_get_flat_dt_prop(node, "compatible", &cplen);
-	if (cp == NULL)
-		return 0;
-	while (cplen > 0) {
-		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
-			return 1;
-		l = strlen(cp) + 1;
-		cp += l;
-		cplen -= l;
-	}
-
-	return 0;
+	return of_fdt_is_compatible(initial_boot_params, node, compat);
 }
 
 static void *__init unflatten_dt_alloc(unsigned long *mem, unsigned long size,
@@ -303,7 +328,7 @@ unsigned long __init unflatten_dt_node(unsigned long mem,
 		if (be32_to_cpu(initial_boot_params->version) < 0x10)
 			*p = ALIGN(*p, sz >= 8 ? 8 : 4);
 
-		pname = find_flat_dt_string(noff);
+		pname = of_fdt_get_string(initial_boot_params, noff);
 		if (pname == NULL) {
 			pr_info("Can't find property name in list !\n");
 			break;

commit e6ce1324e4f08b0d984340201a125806dae0e9a6
Author: Stephen Neuendorffer <stephen.neuendorffer@xilinx.com>
Date:   Thu Nov 18 15:54:56 2010 -0800

    of/flattree: Add Kconfig for EARLY_FLATTREE
    
    The device tree code is now in two pieces: some which can be used generically
    on any platform which selects CONFIG_OF_FLATTREE, and some early which is used
    at boot time on only a few architectures.  This patch segregates the early
    code so that only those architectures which care about it need compile it.
    This also means that some of the requirements in the early code (such as
    a cmd_line variable) that most architectures (e.g. X86) don't provide
    can be ignored.
    
    Signed-off-by: Stephen Neuendorffer <stephen.neuendorffer@xilinx.com>
    [grant.likely@secretlab.ca: remove extra blank line addition]
    [grant.likely@secretlab.ca: fixed incorrect #ifdef CONFIG_EARLY_FLATTREE check]
    [grant.likely@secretlab.ca: Made OF_EARLY_FLATTREE select instead of depend
                                on OF_FLATTREE]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index c1360e02f921..2ebacf14e7de 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -27,6 +27,8 @@ int __initdata dt_root_size_cells;
 
 struct boot_param_header *initial_boot_params;
 
+#ifdef CONFIG_OF_EARLY_FLATTREE
+
 char *find_flat_dt_string(u32 offset)
 {
 	return ((char *)initial_boot_params) +
@@ -604,3 +606,5 @@ void __init unflatten_device_tree(void)
 
 	pr_debug(" <- unflatten_device_tree()\n");
 }
+
+#endif /* CONFIG_OF_EARLY_FLATTREE */

commit 32c97689c46b272302053778f1a6c2facb0e220c
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Wed Oct 20 11:45:14 2010 -0600

    of/flattree: Eliminate need to provide early_init_dt_scan_chosen_arch
    
    This patch refactors the early init parsing of the chosen node so that
    architectures aren't forced to provide an empty implementation of
    early_init_dt_scan_chosen_arch.  Instead, if an architecture wants to
    do something different, it can either use a wrapper function around
    early_init_dt_scan_chosen(), or it can replace it altogether.
    
    This patch was written in preparation to adding device tree support to
    both x86 ad MIPS.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Tested-by: David Daney <ddaney@caviumnetworks.com>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 65da5aec7552..c1360e02f921 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -533,8 +533,6 @@ int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
 		strlcpy(cmd_line, CONFIG_CMDLINE, COMMAND_LINE_SIZE);
 #endif /* CONFIG_CMDLINE */
 
-	early_init_dt_scan_chosen_arch(node);
-
 	pr_debug("Command line is: %s\n", cmd_line);
 
 	/* break now */

commit 9a6b2e588c7809e86161236da3d29581bf5f8402
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Jul 23 01:48:25 2010 -0600

    of: Fix phandle endian issues
    
    The flat tree code wasn't fixing the endianness on phandle values when
    unflattening the tree, and the code in drivers/of wasn't always doing a
    be32_to_cpu before trying to dereference the phandle values.  This patch
    fixes them.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index dc876cbbd9dd..65da5aec7552 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -320,13 +320,13 @@ unsigned long __init unflatten_dt_node(unsigned long mem,
 			if ((strcmp(pname, "phandle") == 0) ||
 			    (strcmp(pname, "linux,phandle") == 0)) {
 				if (np->phandle == 0)
-					np->phandle = *((u32 *)*p);
+					np->phandle = be32_to_cpup((__be32*)*p);
 			}
 			/* And we process the "ibm,phandle" property
 			 * used in pSeries dynamic device tree
 			 * stuff */
 			if (strcmp(pname, "ibm,phandle") == 0)
-				np->phandle = *((u32 *)*p);
+				np->phandle = be32_to_cpup((__be32 *)*p);
 			pp->name = pname;
 			pp->length = sz;
 			pp->value = (void *)*p;

commit 883c2cfc8bcc0fd00c5d9f596fb8870f481b5bda
Author: Stuart Yoder <stuart.yoder@freescale.com>
Date:   Fri Jul 23 13:42:44 2010 -0500

    of/flattree: fix of_flat_dt_is_compatible() to match the full compatible string
    
    With the current string comparison, a device tree compatible of "foo-bar"
    would match as compatible with a driver looking for "foo".  This patch
    fixes the function to use the of_compat_cmp() macro so that it does the
    right thing on all platforms (If sparc ever uses this code, it will still
    want the strncasecmp() behaviour).
    
    Signed-off-by: Stuart Yoder <stuart.yoder@freescale.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index d61fda836e03..dc876cbbd9dd 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -169,7 +169,7 @@ int __init of_flat_dt_is_compatible(unsigned long node, const char *compat)
 	if (cp == NULL)
 		return 0;
 	while (cplen > 0) {
-		if (strncasecmp(cp, compat, strlen(compat)) == 0)
+		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
 			return 1;
 		l = strlen(cp) + 1;
 		cp += l;

commit f1d4c3a76981addcd7669f404f75041435a04e6a
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Jun 25 12:16:52 2010 -0600

    of/flattree: Use common ALIGN() macro instead of arch specific _ALIGN
    
    There's no reason to use the powerpc-specific _ALIGN macro in the fdt
    code.  Replace it with ALIGN() from kernel.h
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-By: Jeremy Kerr <jeremy.kerr@canonical.com>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index b6987bba8556..d61fda836e03 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -69,9 +69,9 @@ int __init of_scan_flat_dt(int (*it)(unsigned long node,
 			u32 sz = be32_to_cpup((__be32 *)p);
 			p += 8;
 			if (be32_to_cpu(initial_boot_params->version) < 0x10)
-				p = _ALIGN(p, sz >= 8 ? 8 : 4);
+				p = ALIGN(p, sz >= 8 ? 8 : 4);
 			p += sz;
-			p = _ALIGN(p, 4);
+			p = ALIGN(p, 4);
 			continue;
 		}
 		if (tag != OF_DT_BEGIN_NODE) {
@@ -80,7 +80,7 @@ int __init of_scan_flat_dt(int (*it)(unsigned long node,
 		}
 		depth++;
 		pathp = (char *)p;
-		p = _ALIGN(p + strlen(pathp) + 1, 4);
+		p = ALIGN(p + strlen(pathp) + 1, 4);
 		if ((*pathp) == '/') {
 			char *lp, *np;
 			for (lp = NULL, np = pathp; *np; np++)
@@ -109,7 +109,7 @@ unsigned long __init of_get_flat_dt_root(void)
 		p += 4;
 	BUG_ON(be32_to_cpup((__be32 *)p) != OF_DT_BEGIN_NODE);
 	p += 4;
-	return _ALIGN(p + strlen((char *)p) + 1, 4);
+	return ALIGN(p + strlen((char *)p) + 1, 4);
 }
 
 /**
@@ -138,7 +138,7 @@ void *__init of_get_flat_dt_prop(unsigned long node, const char *name,
 		noff = be32_to_cpup((__be32 *)(p + 4));
 		p += 8;
 		if (be32_to_cpu(initial_boot_params->version) < 0x10)
-			p = _ALIGN(p, sz >= 8 ? 8 : 4);
+			p = ALIGN(p, sz >= 8 ? 8 : 4);
 
 		nstr = find_flat_dt_string(noff);
 		if (nstr == NULL) {
@@ -151,7 +151,7 @@ void *__init of_get_flat_dt_prop(unsigned long node, const char *name,
 			return (void *)p;
 		}
 		p += sz;
-		p = _ALIGN(p, 4);
+		p = ALIGN(p, 4);
 	} while (1);
 }
 
@@ -184,7 +184,7 @@ static void *__init unflatten_dt_alloc(unsigned long *mem, unsigned long size,
 {
 	void *res;
 
-	*mem = _ALIGN(*mem, align);
+	*mem = ALIGN(*mem, align);
 	res = (void *)*mem;
 	*mem += size;
 
@@ -220,7 +220,7 @@ unsigned long __init unflatten_dt_node(unsigned long mem,
 	*p += 4;
 	pathp = (char *)*p;
 	l = allocl = strlen(pathp) + 1;
-	*p = _ALIGN(*p + l, 4);
+	*p = ALIGN(*p + l, 4);
 
 	/* version 0x10 has a more compact unit name here instead of the full
 	 * path. we accumulate the full path size using "fpsize", we'll rebuild
@@ -299,7 +299,7 @@ unsigned long __init unflatten_dt_node(unsigned long mem,
 		noff = be32_to_cpup((__be32 *)((*p) + 4));
 		*p += 8;
 		if (be32_to_cpu(initial_boot_params->version) < 0x10)
-			*p = _ALIGN(*p, sz >= 8 ? 8 : 4);
+			*p = ALIGN(*p, sz >= 8 ? 8 : 4);
 
 		pname = find_flat_dt_string(noff);
 		if (pname == NULL) {
@@ -333,7 +333,7 @@ unsigned long __init unflatten_dt_node(unsigned long mem,
 			*prev_pp = pp;
 			prev_pp = &pp->next;
 		}
-		*p = _ALIGN((*p) + sz, 4);
+		*p = ALIGN((*p) + sz, 4);
 	}
 	/* with version 0x10 we may not have the name property, recreate
 	 * it here from the unit name if absent

commit 8bfe9b5c3a684fe39eb58a65e466c103d1c32c9a
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Apr 13 16:12:26 2010 -0700

    of/flattree: Make unflatten_device_tree() safe to call from any arch
    
    This patch makes unflatten_device_tree() safe to call from any arch
    setup code with the following changes:
    - Make sure initial_boot_params actually points to a device tree blob
      before unflattening
    - Make sure the initial_boot_params->magic field is correct
    - If CONFIG_OF_FLATTREE is not set, then make unflatten_device_tree()
      an empty static inline function.
    
    This patch also adds some additional debug output to the top of
    unflatten_device_tree().
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index dee4fb56b094..b6987bba8556 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -556,6 +556,21 @@ void __init unflatten_device_tree(void)
 
 	pr_debug(" -> unflatten_device_tree()\n");
 
+	if (!initial_boot_params) {
+		pr_debug("No device tree pointer\n");
+		return;
+	}
+
+	pr_debug("Unflattening device tree:\n");
+	pr_debug("magic: %08x\n", be32_to_cpu(initial_boot_params->magic));
+	pr_debug("size: %08x\n", be32_to_cpu(initial_boot_params->totalsize));
+	pr_debug("version: %08x\n", be32_to_cpu(initial_boot_params->version));
+
+	if (be32_to_cpu(initial_boot_params->magic) != OF_DT_HEADER) {
+		pr_err("Invalid device tree blob header\n");
+		return;
+	}
+
 	/* First pass, scan for size */
 	start = ((unsigned long)initial_boot_params) +
 		be32_to_cpu(initial_boot_params->off_dt_struct);

commit 7f809e1f8e2f46c486bfe529579a16a28daacd62
Author: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
Date:   Fri Mar 26 22:09:56 2010 -0600

    of/flattree: Fix unhandled OF_DT_NOP tag when unflattening the device tree
    
    NOPs within the property section are skipped, but NOPs between
    OF_DT_END_NODE and OF_DT_BEGIN_NODE were not. My firmware NOPs out
    entire nodes depending on various environment parameters.
    
    of_scan_flat_dt already handles NOP more generally.
    
    Signed-off-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 406757a9d7ea..dee4fb56b094 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -376,8 +376,11 @@ unsigned long __init unflatten_dt_node(unsigned long mem,
 		if (!np->type)
 			np->type = "<NULL>";
 	}
-	while (tag == OF_DT_BEGIN_NODE) {
-		mem = unflatten_dt_node(mem, p, np, allnextpp, fpsize);
+	while (tag == OF_DT_BEGIN_NODE || tag == OF_DT_NOP) {
+		if (tag == OF_DT_NOP)
+			*p += 4;
+		else
+			mem = unflatten_dt_node(mem, p, np, allnextpp, fpsize);
 		tag = be32_to_cpup((__be32 *)(*p));
 	}
 	if (tag != OF_DT_END_NODE) {

commit 4ef7b373df330bc0ff037dc4792d373c9346375f
Author: Jeremy Kerr <jeremy.kerr@canonical.com>
Date:   Sun Feb 14 07:13:47 2010 -0700

    of/flattree: Don't assume HAVE_LMB
    
    We don't always have lmb available, so make arches provide an
    early_init_dt_alloc_memory_arch() to handle the allocation of
    memory in the fdt code.
    
    When we don't have lmb.h included, we need asm/page.h for __va.
    
    Signed-off-by: Jeremy Kerr <jeremy.kerr@canonical.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Michal Simek <monstr@monstr.eu>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index b51f797d9d9d..406757a9d7ea 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -10,16 +10,18 @@
  */
 
 #include <linux/kernel.h>
-#include <linux/lmb.h>
 #include <linux/initrd.h>
 #include <linux/of.h>
 #include <linux/of_fdt.h>
-
+#include <linux/string.h>
+#include <linux/errno.h>
 
 #ifdef CONFIG_PPC
 #include <asm/machdep.h>
 #endif /* CONFIG_PPC */
 
+#include <asm/page.h>
+
 int __initdata dt_root_addr_cells;
 int __initdata dt_root_size_cells;
 
@@ -560,7 +562,8 @@ void __init unflatten_device_tree(void)
 	pr_debug("  size is %lx, allocating...\n", size);
 
 	/* Allocate memory for the expanded device tree */
-	mem = lmb_alloc(size + 4, __alignof__(struct device_node));
+	mem = early_init_dt_alloc_memory_arch(size + 4,
+			__alignof__(struct device_node));
 	mem = (unsigned long) __va(mem);
 
 	((__be32 *)mem)[size / 4] = cpu_to_be32(0xdeadbeef);

commit 04b954a673dd02f585a2769c4945a43880faa989
Author: David Gibson <david@gibson.dropbear.id.au>
Date:   Mon Feb 1 21:34:15 2010 -0700

    of/flattree: Make the kernel accept ePAPR style phandle information
    
    Currently when processing flattened device trees, the kernel expects
    the phandle in a property called "linux,phandle".  The ePAPR spec -
    not being Linux specific - instead requires phandles to be encoded in
    a property named simply "phandle".  This patch makes the kernel accept
    either form when unflattening the device tree.
    
    Signed-off-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 18d282fefe58..b51f797d9d9d 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -310,10 +310,19 @@ unsigned long __init unflatten_dt_node(unsigned long mem,
 		pp = unflatten_dt_alloc(&mem, sizeof(struct property),
 					__alignof__(struct property));
 		if (allnextpp) {
-			if (strcmp(pname, "linux,phandle") == 0) {
+			/* We accept flattened tree phandles either in
+			 * ePAPR-style "phandle" properties, or the
+			 * legacy "linux,phandle" properties.  If both
+			 * appear and have different values, things
+			 * will get weird.  Don't do that. */
+			if ((strcmp(pname, "phandle") == 0) ||
+			    (strcmp(pname, "linux,phandle") == 0)) {
 				if (np->phandle == 0)
 					np->phandle = *((u32 *)*p);
 			}
+			/* And we process the "ibm,phandle" property
+			 * used in pSeries dynamic device tree
+			 * stuff */
 			if (strcmp(pname, "ibm,phandle") == 0)
 				np->phandle = *((u32 *)*p);
 			pp->name = pname;

commit 087f79c48c090a2c0cd9ee45231d63290d2036d2
Author: Jeremy Kerr <jeremy.kerr@canonical.com>
Date:   Sat Jan 30 04:14:19 2010 -0700

    of/flattree: endian-convert members of boot_param_header
    
    The boot_param_header has big-endian fields, so change the types to
    __be32, and perform endian conversion when we access them.
    
    Signed-off-by: Jeremy Kerr <jeremy.kerr@canonical.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 5c5f03ef7f06..18d282fefe58 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -28,7 +28,7 @@ struct boot_param_header *initial_boot_params;
 char *find_flat_dt_string(u32 offset)
 {
 	return ((char *)initial_boot_params) +
-		initial_boot_params->off_dt_strings + offset;
+		be32_to_cpu(initial_boot_params->off_dt_strings) + offset;
 }
 
 /**
@@ -46,7 +46,7 @@ int __init of_scan_flat_dt(int (*it)(unsigned long node,
 			   void *data)
 {
 	unsigned long p = ((unsigned long)initial_boot_params) +
-		initial_boot_params->off_dt_struct;
+		be32_to_cpu(initial_boot_params->off_dt_struct);
 	int rc = 0;
 	int depth = -1;
 
@@ -66,7 +66,7 @@ int __init of_scan_flat_dt(int (*it)(unsigned long node,
 		if (tag == OF_DT_PROP) {
 			u32 sz = be32_to_cpup((__be32 *)p);
 			p += 8;
-			if (initial_boot_params->version < 0x10)
+			if (be32_to_cpu(initial_boot_params->version) < 0x10)
 				p = _ALIGN(p, sz >= 8 ? 8 : 4);
 			p += sz;
 			p = _ALIGN(p, 4);
@@ -101,7 +101,7 @@ int __init of_scan_flat_dt(int (*it)(unsigned long node,
 unsigned long __init of_get_flat_dt_root(void)
 {
 	unsigned long p = ((unsigned long)initial_boot_params) +
-		initial_boot_params->off_dt_struct;
+		be32_to_cpu(initial_boot_params->off_dt_struct);
 
 	while (be32_to_cpup((__be32 *)p) == OF_DT_NOP)
 		p += 4;
@@ -135,7 +135,7 @@ void *__init of_get_flat_dt_prop(unsigned long node, const char *name,
 		sz = be32_to_cpup((__be32 *)p);
 		noff = be32_to_cpup((__be32 *)(p + 4));
 		p += 8;
-		if (initial_boot_params->version < 0x10)
+		if (be32_to_cpu(initial_boot_params->version) < 0x10)
 			p = _ALIGN(p, sz >= 8 ? 8 : 4);
 
 		nstr = find_flat_dt_string(noff);
@@ -296,7 +296,7 @@ unsigned long __init unflatten_dt_node(unsigned long mem,
 		sz = be32_to_cpup((__be32 *)(*p));
 		noff = be32_to_cpup((__be32 *)((*p) + 4));
 		*p += 8;
-		if (initial_boot_params->version < 0x10)
+		if (be32_to_cpu(initial_boot_params->version) < 0x10)
 			*p = _ALIGN(*p, sz >= 8 ? 8 : 4);
 
 		pname = find_flat_dt_string(noff);
@@ -544,7 +544,7 @@ void __init unflatten_device_tree(void)
 
 	/* First pass, scan for size */
 	start = ((unsigned long)initial_boot_params) +
-		initial_boot_params->off_dt_struct;
+		be32_to_cpu(initial_boot_params->off_dt_struct);
 	size = unflatten_dt_node(0, &start, NULL, NULL, 0);
 	size = (size | 3) + 1;
 
@@ -560,7 +560,7 @@ void __init unflatten_device_tree(void)
 
 	/* Second pass, do actual unflattening */
 	start = ((unsigned long)initial_boot_params) +
-		initial_boot_params->off_dt_struct;
+		be32_to_cpu(initial_boot_params->off_dt_struct);
 	unflatten_dt_node(mem, &start, NULL, &allnextp, 0);
 	if (be32_to_cpup((__be32 *)start) != OF_DT_END)
 		pr_warning("Weird tag at end of tree: %08x\n", *((u32 *)start));

commit 337148812f97368a8ec4a69f1691e4c5ce3af494
Author: Jeremy Kerr <jeremy.kerr@canonical.com>
Date:   Sat Jan 30 01:45:26 2010 -0700

    of: assume big-endian properties, adding conversions where necessary
    
    Properties in the device tree are specified as big-endian. At present,
    the only platforms to support device trees are also big-endian, so we've
    been acessing the properties as raw values.
    
    We'd like to add device tree support to little-endian platforms too, so
    add endian conversion to the sites where we access property values in
    the common of code.
    
    Compiled on powerpc (ppc44x_defconfig & ppc64_defconfig) and arm (fdt
    support only for now).
    
    Signed-off-by: Jeremy Kerr <jeremy.kerr@canonical.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 968a86af5301..5c5f03ef7f06 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -51,7 +51,7 @@ int __init of_scan_flat_dt(int (*it)(unsigned long node,
 	int depth = -1;
 
 	do {
-		u32 tag = *((u32 *)p);
+		u32 tag = be32_to_cpup((__be32 *)p);
 		char *pathp;
 
 		p += 4;
@@ -64,7 +64,7 @@ int __init of_scan_flat_dt(int (*it)(unsigned long node,
 		if (tag == OF_DT_END)
 			break;
 		if (tag == OF_DT_PROP) {
-			u32 sz = *((u32 *)p);
+			u32 sz = be32_to_cpup((__be32 *)p);
 			p += 8;
 			if (initial_boot_params->version < 0x10)
 				p = _ALIGN(p, sz >= 8 ? 8 : 4);
@@ -103,9 +103,9 @@ unsigned long __init of_get_flat_dt_root(void)
 	unsigned long p = ((unsigned long)initial_boot_params) +
 		initial_boot_params->off_dt_struct;
 
-	while (*((u32 *)p) == OF_DT_NOP)
+	while (be32_to_cpup((__be32 *)p) == OF_DT_NOP)
 		p += 4;
-	BUG_ON(*((u32 *)p) != OF_DT_BEGIN_NODE);
+	BUG_ON(be32_to_cpup((__be32 *)p) != OF_DT_BEGIN_NODE);
 	p += 4;
 	return _ALIGN(p + strlen((char *)p) + 1, 4);
 }
@@ -122,7 +122,7 @@ void *__init of_get_flat_dt_prop(unsigned long node, const char *name,
 	unsigned long p = node;
 
 	do {
-		u32 tag = *((u32 *)p);
+		u32 tag = be32_to_cpup((__be32 *)p);
 		u32 sz, noff;
 		const char *nstr;
 
@@ -132,8 +132,8 @@ void *__init of_get_flat_dt_prop(unsigned long node, const char *name,
 		if (tag != OF_DT_PROP)
 			return NULL;
 
-		sz = *((u32 *)p);
-		noff = *((u32 *)(p + 4));
+		sz = be32_to_cpup((__be32 *)p);
+		noff = be32_to_cpup((__be32 *)(p + 4));
 		p += 8;
 		if (initial_boot_params->version < 0x10)
 			p = _ALIGN(p, sz >= 8 ? 8 : 4);
@@ -210,7 +210,7 @@ unsigned long __init unflatten_dt_node(unsigned long mem,
 	int has_name = 0;
 	int new_format = 0;
 
-	tag = *((u32 *)(*p));
+	tag = be32_to_cpup((__be32 *)(*p));
 	if (tag != OF_DT_BEGIN_NODE) {
 		pr_err("Weird tag at start of node: %x\n", tag);
 		return mem;
@@ -285,7 +285,7 @@ unsigned long __init unflatten_dt_node(unsigned long mem,
 		u32 sz, noff;
 		char *pname;
 
-		tag = *((u32 *)(*p));
+		tag = be32_to_cpup((__be32 *)(*p));
 		if (tag == OF_DT_NOP) {
 			*p += 4;
 			continue;
@@ -293,8 +293,8 @@ unsigned long __init unflatten_dt_node(unsigned long mem,
 		if (tag != OF_DT_PROP)
 			break;
 		*p += 4;
-		sz = *((u32 *)(*p));
-		noff = *((u32 *)((*p) + 4));
+		sz = be32_to_cpup((__be32 *)(*p));
+		noff = be32_to_cpup((__be32 *)((*p) + 4));
 		*p += 8;
 		if (initial_boot_params->version < 0x10)
 			*p = _ALIGN(*p, sz >= 8 ? 8 : 4);
@@ -367,7 +367,7 @@ unsigned long __init unflatten_dt_node(unsigned long mem,
 	}
 	while (tag == OF_DT_BEGIN_NODE) {
 		mem = unflatten_dt_node(mem, p, np, allnextpp, fpsize);
-		tag = *((u32 *)(*p));
+		tag = be32_to_cpup((__be32 *)(*p));
 	}
 	if (tag != OF_DT_END_NODE) {
 		pr_err("Weird tag at end of node: %x\n", tag);
@@ -385,7 +385,7 @@ unsigned long __init unflatten_dt_node(unsigned long mem,
 void __init early_init_dt_check_for_initrd(unsigned long node)
 {
 	unsigned long start, end, len;
-	u32 *prop;
+	__be32 *prop;
 
 	pr_debug("Looking for initrd properties... ");
 
@@ -414,17 +414,22 @@ inline void early_init_dt_check_for_initrd(unsigned long node)
 int __init early_init_dt_scan_root(unsigned long node, const char *uname,
 				   int depth, void *data)
 {
-	u32 *prop;
+	__be32 *prop;
 
 	if (depth != 0)
 		return 0;
 
+	dt_root_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
+	dt_root_addr_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;
+
 	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
-	dt_root_size_cells = prop ? *prop : OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
+	if (prop)
+		dt_root_size_cells = be32_to_cpup(prop);
 	pr_debug("dt_root_size_cells = %x\n", dt_root_size_cells);
 
 	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
-	dt_root_addr_cells = prop ? *prop : OF_ROOT_NODE_ADDR_CELLS_DEFAULT;
+	if (prop)
+		dt_root_addr_cells = be32_to_cpup(prop);
 	pr_debug("dt_root_addr_cells = %x\n", dt_root_addr_cells);
 
 	/* break now */
@@ -549,7 +554,7 @@ void __init unflatten_device_tree(void)
 	mem = lmb_alloc(size + 4, __alignof__(struct device_node));
 	mem = (unsigned long) __va(mem);
 
-	((u32 *)mem)[size / 4] = 0xdeadbeef;
+	((__be32 *)mem)[size / 4] = cpu_to_be32(0xdeadbeef);
 
 	pr_debug("  unflattening %lx...\n", mem);
 
@@ -557,11 +562,11 @@ void __init unflatten_device_tree(void)
 	start = ((unsigned long)initial_boot_params) +
 		initial_boot_params->off_dt_struct;
 	unflatten_dt_node(mem, &start, NULL, &allnextp, 0);
-	if (*((u32 *)start) != OF_DT_END)
+	if (be32_to_cpup((__be32 *)start) != OF_DT_END)
 		pr_warning("Weird tag at end of tree: %08x\n", *((u32 *)start));
-	if (((u32 *)mem)[size / 4] != 0xdeadbeef)
+	if (be32_to_cpu(((__be32 *)mem)[size / 4]) != 0xdeadbeef)
 		pr_warning("End of tree marker overwritten: %08x\n",
-			   ((u32 *)mem)[size / 4]);
+			   be32_to_cpu(((__be32 *)mem)[size / 4]));
 	*allnextp = NULL;
 
 	/* Get pointer to OF "/chosen" node for use everywhere */

commit 2e89e685a8fd0e8334de967739d11e2e28c1a4dd
Author: Jeremy Kerr <jeremy.kerr@canonical.com>
Date:   Sat Jan 30 01:41:49 2010 -0700

    of: use __be32 for cell value accessors
    
    Currently, we're using u32 for cell values, and hence assuming
    host-endian device trees.
    
    As we'd like to support little-endian platforms, use a __be32 for cell
    values, and convert in the cell accessors.
    
    Signed-off-by: Jeremy Kerr <jeremy.kerr@canonical.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 56fbd6e3122a..968a86af5301 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -431,9 +431,9 @@ int __init early_init_dt_scan_root(unsigned long node, const char *uname,
 	return 1;
 }
 
-u64 __init dt_mem_next_cell(int s, u32 **cellp)
+u64 __init dt_mem_next_cell(int s, __be32 **cellp)
 {
-	u32 *p = *cellp;
+	__be32 *p = *cellp;
 
 	*cellp = p + s;
 	return of_read_number(p, s);

commit 36b9d3070d653af5807cef74ff129721d9047107
Author: Jeremy Kerr <jeremy.kerr@canonical.com>
Date:   Mon Feb 1 21:34:14 2010 -0700

    of/flattree: use OF_ROOT_NODE_{SIZE,ADDR}_CELLS DEFAULT for fdt parsing
    
    At present we're using hard-coded values for defaults when parsing the
    FDT. This change uses the #defines instead.
    
    Signed-off-by: Jeremy Kerr <jeremy.kerr@canonical.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 9290ca5aa892..56fbd6e3122a 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -420,11 +420,11 @@ int __init early_init_dt_scan_root(unsigned long node, const char *uname,
 		return 0;
 
 	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
-	dt_root_size_cells = (prop == NULL) ? 1 : *prop;
+	dt_root_size_cells = prop ? *prop : OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
 	pr_debug("dt_root_size_cells = %x\n", dt_root_size_cells);
 
 	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
-	dt_root_addr_cells = (prop == NULL) ? 2 : *prop;
+	dt_root_addr_cells = prop ? *prop : OF_ROOT_NODE_ADDR_CELLS_DEFAULT;
 	pr_debug("dt_root_addr_cells = %x\n", dt_root_addr_cells);
 
 	/* break now */

commit 1406bc2f57787797d1f6a3675c019a7093769275
Author: Jeremy Kerr <jeremy.kerr@canonical.com>
Date:   Sat Jan 30 01:31:21 2010 -0700

    of/flattree: use callback to setup initrd from /chosen
    
    At present, the fdt code sets the kernel-wide initrd_start and
    initrd_end variables when parsing /chosen. On ARM, we only set these
    once the bootmem has been reserved.
    
    This change adds an arch hook to setup the initrd from the device
    tree:
    
     void early_init_dt_setup_initrd_arch(unsigned long start,
                                          unsigned long end);
    
    The arch-specific code can then setup the initrd however it likes.
    
    Compiled on powerpc, with CONFIG_BLK_DEV_INITRD=y and =n.
    
    Signed-off-by: Jeremy Kerr <jeremy.kerr@canonical.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index f84152d112b0..9290ca5aa892 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -384,28 +384,23 @@ unsigned long __init unflatten_dt_node(unsigned long mem,
  */
 void __init early_init_dt_check_for_initrd(unsigned long node)
 {
-	unsigned long len;
+	unsigned long start, end, len;
 	u32 *prop;
 
 	pr_debug("Looking for initrd properties... ");
 
 	prop = of_get_flat_dt_prop(node, "linux,initrd-start", &len);
-	if (prop) {
-		initrd_start = (unsigned long)
-				__va(of_read_ulong(prop, len/4));
-
-		prop = of_get_flat_dt_prop(node, "linux,initrd-end", &len);
-		if (prop) {
-			initrd_end = (unsigned long)
-				__va(of_read_ulong(prop, len/4));
-			initrd_below_start_ok = 1;
-		} else {
-			initrd_start = 0;
-		}
-	}
+	if (!prop)
+		return;
+	start = of_read_ulong(prop, len/4);
+
+	prop = of_get_flat_dt_prop(node, "linux,initrd-end", &len);
+	if (!prop)
+		return;
+	end = of_read_ulong(prop, len/4);
 
-	pr_debug("initrd_start=0x%lx  initrd_end=0x%lx\n",
-		 initrd_start, initrd_end);
+	early_init_dt_setup_initrd_arch(start, end);
+	pr_debug("initrd_start=0x%lx  initrd_end=0x%lx\n", start, end);
 }
 #else
 inline void early_init_dt_check_for_initrd(unsigned long node)

commit 51975db0b7333cf389b64b5040c2a910341d241a
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Mon Feb 1 21:34:14 2010 -0700

    of/flattree: merge early_init_dt_scan_memory() common code
    
    Merge common code between PowerPC and Microblaze architectures.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Michal Simek <monstr@monstr.eu>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 7f8861121a31..f84152d112b0 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -15,6 +15,7 @@
 #include <linux/of.h>
 #include <linux/of_fdt.h>
 
+
 #ifdef CONFIG_PPC
 #include <asm/machdep.h>
 #endif /* CONFIG_PPC */
@@ -443,6 +444,55 @@ u64 __init dt_mem_next_cell(int s, u32 **cellp)
 	return of_read_number(p, s);
 }
 
+/**
+ * early_init_dt_scan_memory - Look for an parse memory nodes
+ */
+int __init early_init_dt_scan_memory(unsigned long node, const char *uname,
+				     int depth, void *data)
+{
+	char *type = of_get_flat_dt_prop(node, "device_type", NULL);
+	__be32 *reg, *endp;
+	unsigned long l;
+
+	/* We are scanning "memory" nodes only */
+	if (type == NULL) {
+		/*
+		 * The longtrail doesn't have a device_type on the
+		 * /memory node, so look for the node called /memory@0.
+		 */
+		if (depth != 1 || strcmp(uname, "memory@0") != 0)
+			return 0;
+	} else if (strcmp(type, "memory") != 0)
+		return 0;
+
+	reg = of_get_flat_dt_prop(node, "linux,usable-memory", &l);
+	if (reg == NULL)
+		reg = of_get_flat_dt_prop(node, "reg", &l);
+	if (reg == NULL)
+		return 0;
+
+	endp = reg + (l / sizeof(__be32));
+
+	pr_debug("memory scan node %s, reg size %ld, data: %x %x %x %x,\n",
+	    uname, l, reg[0], reg[1], reg[2], reg[3]);
+
+	while ((endp - reg) >= (dt_root_addr_cells + dt_root_size_cells)) {
+		u64 base, size;
+
+		base = dt_mem_next_cell(dt_root_addr_cells, &reg);
+		size = dt_mem_next_cell(dt_root_size_cells, &reg);
+
+		if (size == 0)
+			continue;
+		pr_debug(" - %llx ,  %llx\n", (unsigned long long)base,
+		    (unsigned long long)size);
+
+		early_init_dt_add_memory_arch(base, size);
+	}
+
+	return 0;
+}
+
 int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
 				     int depth, void *data)
 {

commit 6016a363f6b56b46b24655bcfc0499b715851cf3
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Jan 28 14:06:53 2010 -0700

    of: unify phandle name in struct device_node
    
    In struct device_node, the phandle is named 'linux_phandle' for PowerPC
    and MicroBlaze, and 'node' for SPARC.  There is no good reason for the
    difference, it is just an artifact of the code diverging over a couple
    of years.  This patch renames both to simply .phandle.
    
    Note: the .node also existed in PowerPC/MicroBlaze, but the only user
    seems to be arch/powerpc/platforms/powermac/pfunc_core.c.  It doesn't
    look like the assignment between .linux_phandle and .node is
    significantly different enough to warrant the separate code paths
    unless ibm,phandle properties actually appear in Apple device trees.
    
    I think it is safe to eliminate the old .node property and use
    phandle everywhere.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: David S. Miller <davem@davemloft.net>
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 616a4767a950..7f8861121a31 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -310,12 +310,11 @@ unsigned long __init unflatten_dt_node(unsigned long mem,
 					__alignof__(struct property));
 		if (allnextpp) {
 			if (strcmp(pname, "linux,phandle") == 0) {
-				np->node = *((u32 *)*p);
-				if (np->linux_phandle == 0)
-					np->linux_phandle = np->node;
+				if (np->phandle == 0)
+					np->phandle = *((u32 *)*p);
 			}
 			if (strcmp(pname, "ibm,phandle") == 0)
-				np->linux_phandle = *((u32 *)*p);
+				np->phandle = *((u32 *)*p);
 			pp->name = pname;
 			pp->length = sz;
 			pp->value = (void *)*p;

commit 86e032213424958b45564d0cc96b3316641a49d3
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Dec 10 23:42:21 2009 -0700

    of/flattree: merge early_init_dt_scan_chosen()
    
    Merge common code between PowerPC and Microblaze.  This patch
    splits the arch-specific stuff out into a new function,
    early_init_dt_scan_chosen_arch().
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index ebce509b0886..616a4767a950 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -15,6 +15,10 @@
 #include <linux/of.h>
 #include <linux/of_fdt.h>
 
+#ifdef CONFIG_PPC
+#include <asm/machdep.h>
+#endif /* CONFIG_PPC */
+
 int __initdata dt_root_addr_cells;
 int __initdata dt_root_size_cells;
 
@@ -440,6 +444,40 @@ u64 __init dt_mem_next_cell(int s, u32 **cellp)
 	return of_read_number(p, s);
 }
 
+int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
+				     int depth, void *data)
+{
+	unsigned long l;
+	char *p;
+
+	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);
+
+	if (depth != 1 ||
+	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))
+		return 0;
+
+	early_init_dt_check_for_initrd(node);
+
+	/* Retreive command line */
+	p = of_get_flat_dt_prop(node, "bootargs", &l);
+	if (p != NULL && l > 0)
+		strlcpy(cmd_line, p, min((int)l, COMMAND_LINE_SIZE));
+
+#ifdef CONFIG_CMDLINE
+#ifndef CONFIG_CMDLINE_FORCE
+	if (p == NULL || l == 0 || (l == 1 && (*p) == 0))
+#endif
+		strlcpy(cmd_line, CONFIG_CMDLINE, COMMAND_LINE_SIZE);
+#endif /* CONFIG_CMDLINE */
+
+	early_init_dt_scan_chosen_arch(node);
+
+	pr_debug("Command line is: %s\n", cmd_line);
+
+	/* break now */
+	return 1;
+}
+
 /**
  * unflatten_device_tree - create tree of device_nodes from flat blob
  *

commit 83f7a06eb479e2aeb83536e77a2cb14cc2285e32
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Nov 24 03:37:56 2009 -0700

    of/flattree: merge dt_mem_next_cell
    
    Merge common code between PowerPC and Microblaze
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index be200be47269..ebce509b0886 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -432,6 +432,14 @@ int __init early_init_dt_scan_root(unsigned long node, const char *uname,
 	return 1;
 }
 
+u64 __init dt_mem_next_cell(int s, u32 **cellp)
+{
+	u32 *p = *cellp;
+
+	*cellp = p + s;
+	return of_read_number(p, s);
+}
+
 /**
  * unflatten_device_tree - create tree of device_nodes from flat blob
  *

commit f00abd94918c9780f9d2d961fc0e419c11457922
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Nov 24 03:27:10 2009 -0700

    of/flattree: Merge earlyinit_dt_scan_root()
    
    Merge common code between PowerPC and Microblaze
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 6ad98e85dc93..be200be47269 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -15,6 +15,9 @@
 #include <linux/of.h>
 #include <linux/of_fdt.h>
 
+int __initdata dt_root_addr_cells;
+int __initdata dt_root_size_cells;
+
 struct boot_param_header *initial_boot_params;
 
 char *find_flat_dt_string(u32 offset)
@@ -406,6 +409,29 @@ inline void early_init_dt_check_for_initrd(unsigned long node)
 }
 #endif /* CONFIG_BLK_DEV_INITRD */
 
+/**
+ * early_init_dt_scan_root - fetch the top level address and size cells
+ */
+int __init early_init_dt_scan_root(unsigned long node, const char *uname,
+				   int depth, void *data)
+{
+	u32 *prop;
+
+	if (depth != 0)
+		return 0;
+
+	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
+	dt_root_size_cells = (prop == NULL) ? 1 : *prop;
+	pr_debug("dt_root_size_cells = %x\n", dt_root_size_cells);
+
+	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
+	dt_root_addr_cells = (prop == NULL) ? 2 : *prop;
+	pr_debug("dt_root_addr_cells = %x\n", dt_root_addr_cells);
+
+	/* break now */
+	return 1;
+}
+
 /**
  * unflatten_device_tree - create tree of device_nodes from flat blob
  *

commit f7b3a8355ba6cad251297844a0bdd08898ea36e0
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Nov 24 03:26:58 2009 -0700

    of/flattree: Merge early_init_dt_check_for_initrd()
    
    Merge common code between PowerPC and Microblaze
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 43d236cbc17b..6ad98e85dc93 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -11,6 +11,7 @@
 
 #include <linux/kernel.h>
 #include <linux/lmb.h>
+#include <linux/initrd.h>
 #include <linux/of.h>
 #include <linux/of_fdt.h>
 
@@ -369,6 +370,42 @@ unsigned long __init unflatten_dt_node(unsigned long mem,
 	return mem;
 }
 
+#ifdef CONFIG_BLK_DEV_INITRD
+/**
+ * early_init_dt_check_for_initrd - Decode initrd location from flat tree
+ * @node: reference to node containing initrd location ('chosen')
+ */
+void __init early_init_dt_check_for_initrd(unsigned long node)
+{
+	unsigned long len;
+	u32 *prop;
+
+	pr_debug("Looking for initrd properties... ");
+
+	prop = of_get_flat_dt_prop(node, "linux,initrd-start", &len);
+	if (prop) {
+		initrd_start = (unsigned long)
+				__va(of_read_ulong(prop, len/4));
+
+		prop = of_get_flat_dt_prop(node, "linux,initrd-end", &len);
+		if (prop) {
+			initrd_end = (unsigned long)
+				__va(of_read_ulong(prop, len/4));
+			initrd_below_start_ok = 1;
+		} else {
+			initrd_start = 0;
+		}
+	}
+
+	pr_debug("initrd_start=0x%lx  initrd_end=0x%lx\n",
+		 initrd_start, initrd_end);
+}
+#else
+inline void early_init_dt_check_for_initrd(unsigned long node)
+{
+}
+#endif /* CONFIG_BLK_DEV_INITRD */
+
 /**
  * unflatten_device_tree - create tree of device_nodes from flat blob
  *

commit 41f880091c15b039ffcc8b3d831656b81517a6d3
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Mon Nov 23 20:07:01 2009 -0700

    of/flattree: Merge unflatten_device_tree
    
    Merge common code between PowerPC and MicroBlaze
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Reviewed-by: Wolfram Sang <w.sang@pengutronix.de>
    Tested-by: Michal Simek <monstr@monstr.eu>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 6852ecf6d1e1..43d236cbc17b 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -9,6 +9,8 @@
  * version 2 as published by the Free Software Foundation.
  */
 
+#include <linux/kernel.h>
+#include <linux/lmb.h>
 #include <linux/of.h>
 #include <linux/of_fdt.h>
 
@@ -366,3 +368,53 @@ unsigned long __init unflatten_dt_node(unsigned long mem,
 	*p += 4;
 	return mem;
 }
+
+/**
+ * unflatten_device_tree - create tree of device_nodes from flat blob
+ *
+ * unflattens the device-tree passed by the firmware, creating the
+ * tree of struct device_node. It also fills the "name" and "type"
+ * pointers of the nodes so the normal device-tree walking functions
+ * can be used.
+ */
+void __init unflatten_device_tree(void)
+{
+	unsigned long start, mem, size;
+	struct device_node **allnextp = &allnodes;
+
+	pr_debug(" -> unflatten_device_tree()\n");
+
+	/* First pass, scan for size */
+	start = ((unsigned long)initial_boot_params) +
+		initial_boot_params->off_dt_struct;
+	size = unflatten_dt_node(0, &start, NULL, NULL, 0);
+	size = (size | 3) + 1;
+
+	pr_debug("  size is %lx, allocating...\n", size);
+
+	/* Allocate memory for the expanded device tree */
+	mem = lmb_alloc(size + 4, __alignof__(struct device_node));
+	mem = (unsigned long) __va(mem);
+
+	((u32 *)mem)[size / 4] = 0xdeadbeef;
+
+	pr_debug("  unflattening %lx...\n", mem);
+
+	/* Second pass, do actual unflattening */
+	start = ((unsigned long)initial_boot_params) +
+		initial_boot_params->off_dt_struct;
+	unflatten_dt_node(mem, &start, NULL, &allnextp, 0);
+	if (*((u32 *)start) != OF_DT_END)
+		pr_warning("Weird tag at end of tree: %08x\n", *((u32 *)start));
+	if (((u32 *)mem)[size / 4] != 0xdeadbeef)
+		pr_warning("End of tree marker overwritten: %08x\n",
+			   ((u32 *)mem)[size / 4]);
+	*allnextp = NULL;
+
+	/* Get pointer to OF "/chosen" node for use everywhere */
+	of_chosen = of_find_node_by_path("/chosen");
+	if (of_chosen == NULL)
+		of_chosen = of_find_node_by_path("/chosen@0");
+
+	pr_debug(" <- unflatten_device_tree()\n");
+}

commit bbd33931a08362f78266a4016211a35947b91041
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Mon Nov 23 20:07:00 2009 -0700

    of/flattree: Merge unflatten_dt_node
    
    Merge common code between PowerPC and MicroBlaze
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Reviewed-by: Wolfram Sang <w.sang@pengutronix.de>
    Tested-by: Michal Simek <monstr@monstr.eu>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 5cdd958db9af..6852ecf6d1e1 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -166,3 +166,203 @@ int __init of_flat_dt_is_compatible(unsigned long node, const char *compat)
 	return 0;
 }
 
+static void *__init unflatten_dt_alloc(unsigned long *mem, unsigned long size,
+				       unsigned long align)
+{
+	void *res;
+
+	*mem = _ALIGN(*mem, align);
+	res = (void *)*mem;
+	*mem += size;
+
+	return res;
+}
+
+/**
+ * unflatten_dt_node - Alloc and populate a device_node from the flat tree
+ * @p: pointer to node in flat tree
+ * @dad: Parent struct device_node
+ * @allnextpp: pointer to ->allnext from last allocated device_node
+ * @fpsize: Size of the node path up at the current depth.
+ */
+unsigned long __init unflatten_dt_node(unsigned long mem,
+					unsigned long *p,
+					struct device_node *dad,
+					struct device_node ***allnextpp,
+					unsigned long fpsize)
+{
+	struct device_node *np;
+	struct property *pp, **prev_pp = NULL;
+	char *pathp;
+	u32 tag;
+	unsigned int l, allocl;
+	int has_name = 0;
+	int new_format = 0;
+
+	tag = *((u32 *)(*p));
+	if (tag != OF_DT_BEGIN_NODE) {
+		pr_err("Weird tag at start of node: %x\n", tag);
+		return mem;
+	}
+	*p += 4;
+	pathp = (char *)*p;
+	l = allocl = strlen(pathp) + 1;
+	*p = _ALIGN(*p + l, 4);
+
+	/* version 0x10 has a more compact unit name here instead of the full
+	 * path. we accumulate the full path size using "fpsize", we'll rebuild
+	 * it later. We detect this because the first character of the name is
+	 * not '/'.
+	 */
+	if ((*pathp) != '/') {
+		new_format = 1;
+		if (fpsize == 0) {
+			/* root node: special case. fpsize accounts for path
+			 * plus terminating zero. root node only has '/', so
+			 * fpsize should be 2, but we want to avoid the first
+			 * level nodes to have two '/' so we use fpsize 1 here
+			 */
+			fpsize = 1;
+			allocl = 2;
+		} else {
+			/* account for '/' and path size minus terminal 0
+			 * already in 'l'
+			 */
+			fpsize += l;
+			allocl = fpsize;
+		}
+	}
+
+	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
+				__alignof__(struct device_node));
+	if (allnextpp) {
+		memset(np, 0, sizeof(*np));
+		np->full_name = ((char *)np) + sizeof(struct device_node);
+		if (new_format) {
+			char *fn = np->full_name;
+			/* rebuild full path for new format */
+			if (dad && dad->parent) {
+				strcpy(fn, dad->full_name);
+#ifdef DEBUG
+				if ((strlen(fn) + l + 1) != allocl) {
+					pr_debug("%s: p: %d, l: %d, a: %d\n",
+						pathp, (int)strlen(fn),
+						l, allocl);
+				}
+#endif
+				fn += strlen(fn);
+			}
+			*(fn++) = '/';
+			memcpy(fn, pathp, l);
+		} else
+			memcpy(np->full_name, pathp, l);
+		prev_pp = &np->properties;
+		**allnextpp = np;
+		*allnextpp = &np->allnext;
+		if (dad != NULL) {
+			np->parent = dad;
+			/* we temporarily use the next field as `last_child'*/
+			if (dad->next == NULL)
+				dad->child = np;
+			else
+				dad->next->sibling = np;
+			dad->next = np;
+		}
+		kref_init(&np->kref);
+	}
+	while (1) {
+		u32 sz, noff;
+		char *pname;
+
+		tag = *((u32 *)(*p));
+		if (tag == OF_DT_NOP) {
+			*p += 4;
+			continue;
+		}
+		if (tag != OF_DT_PROP)
+			break;
+		*p += 4;
+		sz = *((u32 *)(*p));
+		noff = *((u32 *)((*p) + 4));
+		*p += 8;
+		if (initial_boot_params->version < 0x10)
+			*p = _ALIGN(*p, sz >= 8 ? 8 : 4);
+
+		pname = find_flat_dt_string(noff);
+		if (pname == NULL) {
+			pr_info("Can't find property name in list !\n");
+			break;
+		}
+		if (strcmp(pname, "name") == 0)
+			has_name = 1;
+		l = strlen(pname) + 1;
+		pp = unflatten_dt_alloc(&mem, sizeof(struct property),
+					__alignof__(struct property));
+		if (allnextpp) {
+			if (strcmp(pname, "linux,phandle") == 0) {
+				np->node = *((u32 *)*p);
+				if (np->linux_phandle == 0)
+					np->linux_phandle = np->node;
+			}
+			if (strcmp(pname, "ibm,phandle") == 0)
+				np->linux_phandle = *((u32 *)*p);
+			pp->name = pname;
+			pp->length = sz;
+			pp->value = (void *)*p;
+			*prev_pp = pp;
+			prev_pp = &pp->next;
+		}
+		*p = _ALIGN((*p) + sz, 4);
+	}
+	/* with version 0x10 we may not have the name property, recreate
+	 * it here from the unit name if absent
+	 */
+	if (!has_name) {
+		char *p1 = pathp, *ps = pathp, *pa = NULL;
+		int sz;
+
+		while (*p1) {
+			if ((*p1) == '@')
+				pa = p1;
+			if ((*p1) == '/')
+				ps = p1 + 1;
+			p1++;
+		}
+		if (pa < ps)
+			pa = p1;
+		sz = (pa - ps) + 1;
+		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
+					__alignof__(struct property));
+		if (allnextpp) {
+			pp->name = "name";
+			pp->length = sz;
+			pp->value = pp + 1;
+			*prev_pp = pp;
+			prev_pp = &pp->next;
+			memcpy(pp->value, ps, sz - 1);
+			((char *)pp->value)[sz - 1] = 0;
+			pr_debug("fixed up name for %s -> %s\n", pathp,
+				(char *)pp->value);
+		}
+	}
+	if (allnextpp) {
+		*prev_pp = NULL;
+		np->name = of_get_property(np, "name", NULL);
+		np->type = of_get_property(np, "device_type", NULL);
+
+		if (!np->name)
+			np->name = "<NULL>";
+		if (!np->type)
+			np->type = "<NULL>";
+	}
+	while (tag == OF_DT_BEGIN_NODE) {
+		mem = unflatten_dt_node(mem, p, np, allnextpp, fpsize);
+		tag = *((u32 *)(*p));
+	}
+	if (tag != OF_DT_END_NODE) {
+		pr_err("Weird tag at end of node: %x\n", tag);
+		return mem;
+	}
+	*p += 4;
+	return mem;
+}

commit 00e38efd90f27518ec96b37b1c7773e3ac529966
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Mon Nov 23 20:07:00 2009 -0700

    of/flattree: Merge of_flat_dt_is_compatible
    
    Merge common code between PowerPC and Microblaze
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Reviewed-by: Wolfram Sang <w.sang@pengutronix.de>
    Tested-by: Michal Simek <monstr@monstr.eu>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index b17a9086cbfc..5cdd958db9af 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -142,3 +142,27 @@ void *__init of_get_flat_dt_prop(unsigned long node, const char *name,
 	} while (1);
 }
 
+/**
+ * of_flat_dt_is_compatible - Return true if given node has compat in compatible list
+ * @node: node to test
+ * @compat: compatible string to compare with compatible list.
+ */
+int __init of_flat_dt_is_compatible(unsigned long node, const char *compat)
+{
+	const char *cp;
+	unsigned long cplen, l;
+
+	cp = of_get_flat_dt_prop(node, "compatible", &cplen);
+	if (cp == NULL)
+		return 0;
+	while (cplen > 0) {
+		if (strncasecmp(cp, compat, strlen(compat)) == 0)
+			return 1;
+		l = strlen(cp) + 1;
+		cp += l;
+		cplen -= l;
+	}
+
+	return 0;
+}
+

commit ca900cfa2944448bdb76e1246f282e59bc65f472
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Mon Nov 23 20:06:59 2009 -0700

    of/flattree: merge of_get_flat_dt_prop
    
    Merge common code between PowerPC and Microblaze
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Reviewed-by: Wolfram Sang <w.sang@pengutronix.de>
    Tested-by: Michal Simek <monstr@monstr.eu>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index f41d739aa2f7..b17a9086cbfc 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -99,3 +99,46 @@ unsigned long __init of_get_flat_dt_root(void)
 	return _ALIGN(p + strlen((char *)p) + 1, 4);
 }
 
+/**
+ * of_get_flat_dt_prop - Given a node in the flat blob, return the property ptr
+ *
+ * This function can be used within scan_flattened_dt callback to get
+ * access to properties
+ */
+void *__init of_get_flat_dt_prop(unsigned long node, const char *name,
+				 unsigned long *size)
+{
+	unsigned long p = node;
+
+	do {
+		u32 tag = *((u32 *)p);
+		u32 sz, noff;
+		const char *nstr;
+
+		p += 4;
+		if (tag == OF_DT_NOP)
+			continue;
+		if (tag != OF_DT_PROP)
+			return NULL;
+
+		sz = *((u32 *)p);
+		noff = *((u32 *)(p + 4));
+		p += 8;
+		if (initial_boot_params->version < 0x10)
+			p = _ALIGN(p, sz >= 8 ? 8 : 4);
+
+		nstr = find_flat_dt_string(noff);
+		if (nstr == NULL) {
+			pr_warning("Can't find property index name !\n");
+			return NULL;
+		}
+		if (strcmp(name, nstr) == 0) {
+			if (size)
+				*size = sz;
+			return (void *)p;
+		}
+		p += sz;
+		p = _ALIGN(p, 4);
+	} while (1);
+}
+

commit 819d2819303654c6829d572e698e2d0021c08599
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Mon Nov 23 19:44:23 2009 -0700

    of/flattree: merge of_get_flat_dt_root
    
    Merge common code between PowerPC and MicroBlaze
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Reviewed-by: Wolfram Sang <w.sang@pengutronix.de>
    Tested-by: Michal Simek <monstr@monstr.eu>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index dd9057cb7aa7..f41d739aa2f7 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -83,3 +83,19 @@ int __init of_scan_flat_dt(int (*it)(unsigned long node,
 
 	return rc;
 }
+
+/**
+ * of_get_flat_dt_root - find the root node in the flat blob
+ */
+unsigned long __init of_get_flat_dt_root(void)
+{
+	unsigned long p = ((unsigned long)initial_boot_params) +
+		initial_boot_params->off_dt_struct;
+
+	while (*((u32 *)p) == OF_DT_NOP)
+		p += 4;
+	BUG_ON(*((u32 *)p) != OF_DT_BEGIN_NODE);
+	p += 4;
+	return _ALIGN(p + strlen((char *)p) + 1, 4);
+}
+

commit c8cb7a59842c0b512b44f6f818cdb0b5a3ddc89e
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Mon Nov 23 18:54:23 2009 -0700

    of/flattree: merge of_scan_flat_dt
    
    Merge common code between PowerPC and Microblaze
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Reviewed-by: Wolfram Sang <w.sang@pengutronix.de>
    Tested-by: Michal Simek <monstr@monstr.eu>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 9faa9a5cbdf0..dd9057cb7aa7 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -19,3 +19,67 @@ char *find_flat_dt_string(u32 offset)
 	return ((char *)initial_boot_params) +
 		initial_boot_params->off_dt_strings + offset;
 }
+
+/**
+ * of_scan_flat_dt - scan flattened tree blob and call callback on each.
+ * @it: callback function
+ * @data: context data pointer
+ *
+ * This function is used to scan the flattened device-tree, it is
+ * used to extract the memory information at boot before we can
+ * unflatten the tree
+ */
+int __init of_scan_flat_dt(int (*it)(unsigned long node,
+				     const char *uname, int depth,
+				     void *data),
+			   void *data)
+{
+	unsigned long p = ((unsigned long)initial_boot_params) +
+		initial_boot_params->off_dt_struct;
+	int rc = 0;
+	int depth = -1;
+
+	do {
+		u32 tag = *((u32 *)p);
+		char *pathp;
+
+		p += 4;
+		if (tag == OF_DT_END_NODE) {
+			depth--;
+			continue;
+		}
+		if (tag == OF_DT_NOP)
+			continue;
+		if (tag == OF_DT_END)
+			break;
+		if (tag == OF_DT_PROP) {
+			u32 sz = *((u32 *)p);
+			p += 8;
+			if (initial_boot_params->version < 0x10)
+				p = _ALIGN(p, sz >= 8 ? 8 : 4);
+			p += sz;
+			p = _ALIGN(p, 4);
+			continue;
+		}
+		if (tag != OF_DT_BEGIN_NODE) {
+			pr_err("Invalid tag %x in flat device tree!\n", tag);
+			return -EINVAL;
+		}
+		depth++;
+		pathp = (char *)p;
+		p = _ALIGN(p + strlen(pathp) + 1, 4);
+		if ((*pathp) == '/') {
+			char *lp, *np;
+			for (lp = NULL, np = pathp; *np; np++)
+				if ((*np) == '/')
+					lp = np+1;
+			if (lp != NULL)
+				pathp = lp;
+		}
+		rc = it(p, pathp, depth, data);
+		if (rc != 0)
+			break;
+	} while (1);
+
+	return rc;
+}

commit e169cfbef46d62e042614ffafa8880eed1d894bb
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Mon Nov 23 14:53:09 2009 -0700

    of/flattree: merge find_flat_dt_string and initial_boot_params
    
    Merge common code between Microblaze and PowerPC.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Reviewed-by: Wolfram Sang <w.sang@pengutronix.de>
    Tested-by: Michal Simek <monstr@monstr.eu>

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
new file mode 100644
index 000000000000..9faa9a5cbdf0
--- /dev/null
+++ b/drivers/of/fdt.c
@@ -0,0 +1,21 @@
+/*
+ * Functions for working with the Flattened Device Tree data format
+ *
+ * Copyright 2009 Benjamin Herrenschmidt, IBM Corp
+ * benh@kernel.crashing.org
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ */
+
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+
+struct boot_param_header *initial_boot_params;
+
+char *find_flat_dt_string(u32 offset)
+{
+	return ((char *)initial_boot_params) +
+		initial_boot_params->off_dt_strings + offset;
+}
