commit eab3540562fb44f830e09492374fcc69a283ce47
Merge: 1afa9c3b7c9b 88b4750151a2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Feb 8 14:04:19 2020 -0800

    Merge tag 'armsoc-drivers' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc
    
    Pull ARM SoC-related driver updates from Olof Johansson:
     "Various driver updates for platforms:
    
       - Nvidia: Fuse support for Tegra194, continued memory controller
         pieces for Tegra30
    
       - NXP/FSL: Refactorings of QuickEngine drivers to support
         ARM/ARM64/PPC
    
       - NXP/FSL: i.MX8MP SoC driver pieces
    
       - TI Keystone: ring accelerator driver
    
       - Qualcomm: SCM driver cleanup/refactoring + support for new SoCs.
    
       - Xilinx ZynqMP: feature checking interface for firmware. Mailbox
         communication for power management
    
       - Overall support patch set for cpuidle on more complex hierarchies
         (PSCI-based)
    
      and misc cleanups, refactorings of Marvell, TI, other platforms"
    
    * tag 'armsoc-drivers' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc: (166 commits)
      drivers: soc: xilinx: Use mailbox IPI callback
      dt-bindings: power: reset: xilinx: Add bindings for ipi mailbox
      drivers: soc: ti: knav_qmss_queue: Pass lockdep expression to RCU lists
      MAINTAINERS: Add brcmstb PCIe controller entry
      soc/tegra: fuse: Unmap registers once they are not needed anymore
      soc/tegra: fuse: Correct straps' address for older Tegra124 device trees
      soc/tegra: fuse: Warn if straps are not ready
      soc/tegra: fuse: Cache values of straps and Chip ID registers
      memory: tegra30-emc: Correct error message for timed out auto calibration
      memory: tegra30-emc: Firm up hardware programming sequence
      memory: tegra30-emc: Firm up suspend/resume sequence
      soc/tegra: regulators: Do nothing if voltage is unchanged
      memory: tegra: Correct reset value of xusb_hostr
      soc/tegra: fuse: Add APB DMA dependency for Tegra20
      bus: tegra-aconnect: Remove PM_CLK dependency
      dt-bindings: mediatek: add MT6765 power dt-bindings
      soc: mediatek: cmdq: delete not used define
      memory: tegra: Add support for the Tegra194 memory controller
      memory: tegra: Only include support for enabled SoCs
      memory: tegra: Support DVFS on Tegra186 and later
      ...

commit b9f8c26afc405a4a616e765e949bdd551151e41d
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Oct 10 12:01:48 2019 +0200

    of: base: Add of_get_cpu_state_node() to get idle states for a CPU node
    
    The CPU's idle state nodes are currently parsed at the common cpuidle DT
    library, but also when initializing data for specific CPU idle operations,
    as in the PSCI cpuidle driver case and qcom-spm cpuidle case.
    
    To avoid open-coding, let's introduce of_get_cpu_state_node(), which takes
    the device node for the CPU and the index to the requested idle state node,
    as in-parameters. In case a corresponding idle state node is found, it
    returns the node with the refcount incremented for it, else it returns
    NULL.
    
    Moreover, for PSCI there are two options to describe the CPU's idle states
    [1], either via a flattened description or a hierarchical layout. Hence,
    let's take both options into account.
    
    [1] Documentation/devicetree/bindings/arm/psci.yaml
    
    Suggested-by: Sudeep Holla <sudeep.holla@arm.com>
    Co-developed-by: Lina Iyer <lina.iyer@linaro.org>
    Signed-off-by: Lina Iyer <lina.iyer@linaro.org>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Reviewed-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Sudeep Holla <sudeep.holla@arm.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index db7fbc0c0893..614f0c674995 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -489,6 +489,42 @@ int of_cpu_node_to_id(struct device_node *cpu_node)
 }
 EXPORT_SYMBOL(of_cpu_node_to_id);
 
+/**
+ * of_get_cpu_state_node - Get CPU's idle state node at the given index
+ *
+ * @cpu_node: The device node for the CPU
+ * @index: The index in the list of the idle states
+ *
+ * Two generic methods can be used to describe a CPU's idle states, either via
+ * a flattened description through the "cpu-idle-states" binding or via the
+ * hierarchical layout, using the "power-domains" and the "domain-idle-states"
+ * bindings. This function check for both and returns the idle state node for
+ * the requested index.
+ *
+ * In case an idle state node is found at @index, the refcount is incremented
+ * for it, so call of_node_put() on it when done. Returns NULL if not found.
+ */
+struct device_node *of_get_cpu_state_node(struct device_node *cpu_node,
+					  int index)
+{
+	struct of_phandle_args args;
+	int err;
+
+	err = of_parse_phandle_with_args(cpu_node, "power-domains",
+					"#power-domain-cells", 0, &args);
+	if (!err) {
+		struct device_node *state_node =
+			of_parse_phandle(args.np, "domain-idle-states", index);
+
+		of_node_put(args.np);
+		if (state_node)
+			return state_node;
+	}
+
+	return of_parse_phandle(cpu_node, "cpu-idle-states", index);
+}
+EXPORT_SYMBOL(of_get_cpu_state_node);
+
 /**
  * __of_device_is_compatible() - Check if the node matches given constraints
  * @device: pointer to node

commit 90dc0d1ce890419f977e460b8258d25187dde64f
Author: Rob Herring <robh@kernel.org>
Date:   Fri Dec 6 16:27:41 2019 -0600

    of: Rework and simplify phandle cache to use a fixed size
    
    The phandle cache was added to speed up of_find_node_by_phandle() by
    avoiding walking the whole DT to find a matching phandle. The
    implementation has several shortcomings:
    
      - The cache is designed to work on a linear set of phandle values.
        This is true for dtc generated DTs, but not for other cases such as
        Power.
      - The cache isn't enabled until of_core_init() and a typical system
        may see hundreds of calls to of_find_node_by_phandle() before that
        point.
      - The cache is freed and re-allocated when the number of phandles
        changes.
      - It takes a raw spinlock around a memory allocation which breaks on
        RT.
    
    Change the implementation to a fixed size and use hash_32() as the
    cache index. This greatly simplifies the implementation. It avoids
    the need for any re-alloc of the cache and taking a reference on nodes
    in the cache. We only have a single source of removing cache entries
    which is of_detach_node().
    
    Using hash_32() removes any assumption on phandle values improving
    the hit rate for non-linear phandle values. The effect on linear values
    using hash_32() is about a 10% collision. The chances of thrashing on
    colliding values seems to be low.
    
    To compare performance, I used a RK3399 board which is a pretty typical
    system. I found that just measuring boot time as done previously is
    noisy and may be impacted by other things. Also bringing up secondary
    cores causes some issues with measuring, so I booted with 'nr_cpus=1'.
    With no caching, calls to of_find_node_by_phandle() take about 20124 us
    for 1248 calls. There's an additional 288 calls before time keeping is
    up. Using the average time per hit/miss with the cache, we can calculate
    these calls to take 690 us (277 hit / 11 miss) with a 128 entry cache
    and 13319 us with no cache or an uninitialized cache.
    
    Comparing the 3 implementations the time spent in
    of_find_node_by_phandle() is:
    
    no cache:        20124 us (+ 13319 us)
    128 entry cache:  5134 us (+ 690 us)
    current cache:     819 us (+ 13319 us)
    
    We could move the allocation of the cache earlier to improve the
    current cache, but that just further complicates the situation as it
    needs to be after slab is up, so we can't do it when unflattening (which
    uses memblock).
    
    Reported-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Segher Boessenkool <segher@kernel.crashing.org>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Acked-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Reviewed-by: Frank Rowand <frowand.list@gmail.com>
    Tested-by: Frank Rowand <frowand.list@gmail.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index db7fbc0c0893..8d173fb3552a 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -135,115 +135,38 @@ int __weak of_node_to_nid(struct device_node *np)
 }
 #endif
 
-/*
- * Assumptions behind phandle_cache implementation:
- *   - phandle property values are in a contiguous range of 1..n
- *
- * If the assumptions do not hold, then
- *   - the phandle lookup overhead reduction provided by the cache
- *     will likely be less
- */
+#define OF_PHANDLE_CACHE_BITS	7
+#define OF_PHANDLE_CACHE_SZ	BIT(OF_PHANDLE_CACHE_BITS)
 
-static struct device_node **phandle_cache;
-static u32 phandle_cache_mask;
+static struct device_node *phandle_cache[OF_PHANDLE_CACHE_SZ];
 
-/*
- * Caller must hold devtree_lock.
- */
-static void __of_free_phandle_cache(void)
+static u32 of_phandle_cache_hash(phandle handle)
 {
-	u32 cache_entries = phandle_cache_mask + 1;
-	u32 k;
-
-	if (!phandle_cache)
-		return;
-
-	for (k = 0; k < cache_entries; k++)
-		of_node_put(phandle_cache[k]);
-
-	kfree(phandle_cache);
-	phandle_cache = NULL;
+	return hash_32(handle, OF_PHANDLE_CACHE_BITS);
 }
 
-int of_free_phandle_cache(void)
-{
-	unsigned long flags;
-
-	raw_spin_lock_irqsave(&devtree_lock, flags);
-
-	__of_free_phandle_cache();
-
-	raw_spin_unlock_irqrestore(&devtree_lock, flags);
-
-	return 0;
-}
-#if !defined(CONFIG_MODULES)
-late_initcall_sync(of_free_phandle_cache);
-#endif
-
 /*
  * Caller must hold devtree_lock.
  */
-void __of_free_phandle_cache_entry(phandle handle)
+void __of_phandle_cache_inv_entry(phandle handle)
 {
-	phandle masked_handle;
+	u32 handle_hash;
 	struct device_node *np;
 
 	if (!handle)
 		return;
 
-	masked_handle = handle & phandle_cache_mask;
-
-	if (phandle_cache) {
-		np = phandle_cache[masked_handle];
-		if (np && handle == np->phandle) {
-			of_node_put(np);
-			phandle_cache[masked_handle] = NULL;
-		}
-	}
-}
-
-void of_populate_phandle_cache(void)
-{
-	unsigned long flags;
-	u32 cache_entries;
-	struct device_node *np;
-	u32 phandles = 0;
-
-	raw_spin_lock_irqsave(&devtree_lock, flags);
-
-	__of_free_phandle_cache();
-
-	for_each_of_allnodes(np)
-		if (np->phandle && np->phandle != OF_PHANDLE_ILLEGAL)
-			phandles++;
-
-	if (!phandles)
-		goto out;
+	handle_hash = of_phandle_cache_hash(handle);
 
-	cache_entries = roundup_pow_of_two(phandles);
-	phandle_cache_mask = cache_entries - 1;
-
-	phandle_cache = kcalloc(cache_entries, sizeof(*phandle_cache),
-				GFP_ATOMIC);
-	if (!phandle_cache)
-		goto out;
-
-	for_each_of_allnodes(np)
-		if (np->phandle && np->phandle != OF_PHANDLE_ILLEGAL) {
-			of_node_get(np);
-			phandle_cache[np->phandle & phandle_cache_mask] = np;
-		}
-
-out:
-	raw_spin_unlock_irqrestore(&devtree_lock, flags);
+	np = phandle_cache[handle_hash];
+	if (np && handle == np->phandle)
+		phandle_cache[handle_hash] = NULL;
 }
 
 void __init of_core_init(void)
 {
 	struct device_node *np;
 
-	of_populate_phandle_cache();
 
 	/* Create the kset, and register existing nodes */
 	mutex_lock(&of_mutex);
@@ -253,8 +176,11 @@ void __init of_core_init(void)
 		pr_err("failed to register existing nodes\n");
 		return;
 	}
-	for_each_of_allnodes(np)
+	for_each_of_allnodes(np) {
 		__of_attach_node_sysfs(np);
+		if (np->phandle && !phandle_cache[of_phandle_cache_hash(np->phandle)])
+			phandle_cache[of_phandle_cache_hash(np->phandle)] = np;
+	}
 	mutex_unlock(&of_mutex);
 
 	/* Symlink in /proc as required by userspace ABI */
@@ -1235,36 +1161,24 @@ struct device_node *of_find_node_by_phandle(phandle handle)
 {
 	struct device_node *np = NULL;
 	unsigned long flags;
-	phandle masked_handle;
+	u32 handle_hash;
 
 	if (!handle)
 		return NULL;
 
+	handle_hash = of_phandle_cache_hash(handle);
+
 	raw_spin_lock_irqsave(&devtree_lock, flags);
 
-	masked_handle = handle & phandle_cache_mask;
-
-	if (phandle_cache) {
-		if (phandle_cache[masked_handle] &&
-		    handle == phandle_cache[masked_handle]->phandle)
-			np = phandle_cache[masked_handle];
-		if (np && of_node_check_flag(np, OF_DETACHED)) {
-			WARN_ON(1); /* did not uncache np on node removal */
-			of_node_put(np);
-			phandle_cache[masked_handle] = NULL;
-			np = NULL;
-		}
-	}
+	if (phandle_cache[handle_hash] &&
+	    handle == phandle_cache[handle_hash]->phandle)
+		np = phandle_cache[handle_hash];
 
 	if (!np) {
 		for_each_of_allnodes(np)
 			if (np->phandle == handle &&
 			    !of_node_check_flag(np, OF_DETACHED)) {
-				if (phandle_cache) {
-					/* will put when removed from cache */
-					of_node_get(np);
-					phandle_cache[masked_handle] = np;
-				}
+				phandle_cache[handle_hash] = np;
 				break;
 			}
 	}

commit b68ac8dc22ebbf003e26e44bf4dd3030c076df5a
Author: Robin Murphy <robin.murphy@arm.com>
Date:   Tue Jul 2 18:42:39 2019 +0100

    of: Factor out #{addr,size}-cells parsing
    
    In some cases such as PCI host controllers, we may have a "parent bus"
    which is an OF leaf node, but still need to correctly parse ranges from
    the point of view of that bus. For that, factor out variants of the
    "#addr-cells" and "#size-cells" parsers which do not assume they have a
    device node and thus immediately traverse upwards before reading the
    relevant property.
    
    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    [robh: don't make of_bus_n_{addr,size}_cells() public]
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Tested-by: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
    Reviewed-by: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 1d667eb730e1..db7fbc0c0893 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -86,34 +86,46 @@ static bool __of_node_is_type(const struct device_node *np, const char *type)
 	return np && match && type && !strcmp(match, type);
 }
 
-int of_n_addr_cells(struct device_node *np)
+int of_bus_n_addr_cells(struct device_node *np)
 {
 	u32 cells;
 
-	do {
-		if (np->parent)
-			np = np->parent;
+	for (; np; np = np->parent)
 		if (!of_property_read_u32(np, "#address-cells", &cells))
 			return cells;
-	} while (np->parent);
+
 	/* No #address-cells property for the root node */
 	return OF_ROOT_NODE_ADDR_CELLS_DEFAULT;
 }
+
+int of_n_addr_cells(struct device_node *np)
+{
+	if (np->parent)
+		np = np->parent;
+
+	return of_bus_n_addr_cells(np);
+}
 EXPORT_SYMBOL(of_n_addr_cells);
 
-int of_n_size_cells(struct device_node *np)
+int of_bus_n_size_cells(struct device_node *np)
 {
 	u32 cells;
 
-	do {
-		if (np->parent)
-			np = np->parent;
+	for (; np; np = np->parent)
 		if (!of_property_read_u32(np, "#size-cells", &cells))
 			return cells;
-	} while (np->parent);
+
 	/* No #size-cells property for the root node */
 	return OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
 }
+
+int of_n_size_cells(struct device_node *np)
+{
+	if (np->parent)
+		np = np->parent;
+
+	return of_bus_n_size_cells(np);
+}
 EXPORT_SYMBOL(of_n_size_cells);
 
 #ifdef CONFIG_NUMA

commit 59e9fcf8772bd97b6d681706fb8c9a972500c524
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Wed Sep 18 10:47:48 2019 +0200

    of: restore old handling of cells_name=NULL in of_*_phandle_with_args()
    
    Before commit e42ee61017f5 ("of: Let of_for_each_phandle fallback to
    non-negative cell_count") the iterator functions calling
    of_for_each_phandle assumed a cell count of 0 if cells_name was NULL.
    This corner case was missed when implementing the fallback logic in
    e42ee61017f5 and resulted in an endless loop.
    
    Restore the old behaviour of of_count_phandle_with_args() and
    of_parse_phandle_with_args() and add a check to
    of_phandle_iterator_init() to prevent a similar failure as a safety
    precaution. of_parse_phandle_with_args_map() doesn't need a similar fix
    as cells_name isn't NULL there.
    
    Affected drivers are:
     - drivers/base/power/domain.c
     - drivers/base/power/domain.c
     - drivers/clk/ti/clk-dra7-atl.c
     - drivers/hwmon/ibmpowernv.c
     - drivers/i2c/muxes/i2c-demux-pinctrl.c
     - drivers/iommu/mtk_iommu.c
     - drivers/net/ethernet/freescale/fman/mac.c
     - drivers/opp/of.c
     - drivers/perf/arm_dsu_pmu.c
     - drivers/regulator/of_regulator.c
     - drivers/remoteproc/imx_rproc.c
     - drivers/soc/rockchip/pm_domains.c
     - sound/soc/fsl/imx-audmix.c
     - sound/soc/fsl/imx-audmix.c
     - sound/soc/meson/axg-card.c
     - sound/soc/samsung/tm2_wm5110.c
     - sound/soc/samsung/tm2_wm5110.c
    
    Thanks to Geert Uytterhoeven for reporting the issue, Peter Rosin for
    helping pinpoint the actual problem and the testers for confirming this
    fix.
    
    Fixes: e42ee61017f5 ("of: Let of_for_each_phandle fallback to non-negative cell_count")
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 2f25d2dfecfa..1d667eb730e1 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1286,6 +1286,13 @@ int of_phandle_iterator_init(struct of_phandle_iterator *it,
 
 	memset(it, 0, sizeof(*it));
 
+	/*
+	 * one of cell_count or cells_name must be provided to determine the
+	 * argument length.
+	 */
+	if (cell_count < 0 && !cells_name)
+		return -EINVAL;
+
 	list = of_get_property(np, list_name, &size);
 	if (!list)
 		return -ENOENT;
@@ -1512,10 +1519,17 @@ int of_parse_phandle_with_args(const struct device_node *np, const char *list_na
 				const char *cells_name, int index,
 				struct of_phandle_args *out_args)
 {
+	int cell_count = -1;
+
 	if (index < 0)
 		return -EINVAL;
-	return __of_parse_phandle_with_args(np, list_name, cells_name, -1,
-					    index, out_args);
+
+	/* If cells_name is NULL we assume a cell count of 0 */
+	if (!cells_name)
+		cell_count = 0;
+
+	return __of_parse_phandle_with_args(np, list_name, cells_name,
+					    cell_count, index, out_args);
 }
 EXPORT_SYMBOL(of_parse_phandle_with_args);
 
@@ -1765,6 +1779,23 @@ int of_count_phandle_with_args(const struct device_node *np, const char *list_na
 	struct of_phandle_iterator it;
 	int rc, cur_index = 0;
 
+	/*
+	 * If cells_name is NULL we assume a cell count of 0. This makes
+	 * counting the phandles trivial as each 32bit word in the list is a
+	 * phandle and no arguments are to consider. So we don't iterate through
+	 * the list but just use the length to determine the phandle count.
+	 */
+	if (!cells_name) {
+		const __be32 *list;
+		int size;
+
+		list = of_get_property(np, list_name, &size);
+		if (!list)
+			return -ENOENT;
+
+		return size / sizeof(*list);
+	}
+
 	rc = of_phandle_iterator_init(&it, np, list_name, cells_name, -1);
 	if (rc)
 		return rc;

commit e42ee61017f58cd91cb9e30001450be3981e0e83
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Sat Aug 24 15:28:46 2019 +0200

    of: Let of_for_each_phandle fallback to non-negative cell_count
    
    Referencing device tree nodes from a property allows to pass arguments.
    This is for example used for referencing gpios. This looks as follows:
    
            gpio_ctrl: gpio-controller {
                    #gpio-cells = <2>
                    ...
            }
    
            someothernode {
                    gpios = <&gpio_ctrl 5 0 &gpio_ctrl 3 0>;
                    ...
            }
    
    To know the number of arguments this must be either fixed, or the
    referenced node is checked for a $cells_name (here: "#gpio-cells")
    property and with this information the start of the second reference can
    be determined.
    
    Currently regulators are referenced with no additional arguments. To
    allow some optional arguments without having to change all referenced
    nodes this change introduces a way to specify a default cell_count. So
    when a phandle is parsed we check for the $cells_name property and use
    it as before if present. If it is not present we fall back to
    cells_count if non-negative and only fail if cells_count is smaller than
    zero.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 55e7f5bb0549..2f25d2dfecfa 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1335,11 +1335,20 @@ int of_phandle_iterator_next(struct of_phandle_iterator *it)
 
 			if (of_property_read_u32(it->node, it->cells_name,
 						 &count)) {
-				pr_err("%pOF: could not get %s for %pOF\n",
-				       it->parent,
-				       it->cells_name,
-				       it->node);
-				goto err;
+				/*
+				 * If both cell_count and cells_name is given,
+				 * fall back to cell_count in absence
+				 * of the cells_name property
+				 */
+				if (it->cell_count >= 0) {
+					count = it->cell_count;
+				} else {
+					pr_err("%pOF: could not get %s for %pOF\n",
+					       it->parent,
+					       it->cells_name,
+					       it->node);
+					goto err;
+				}
 			}
 		} else {
 			count = it->cell_count;
@@ -1505,7 +1514,7 @@ int of_parse_phandle_with_args(const struct device_node *np, const char *list_na
 {
 	if (index < 0)
 		return -EINVAL;
-	return __of_parse_phandle_with_args(np, list_name, cells_name, 0,
+	return __of_parse_phandle_with_args(np, list_name, cells_name, -1,
 					    index, out_args);
 }
 EXPORT_SYMBOL(of_parse_phandle_with_args);
@@ -1588,7 +1597,7 @@ int of_parse_phandle_with_args_map(const struct device_node *np,
 	if (!pass_name)
 		goto free;
 
-	ret = __of_parse_phandle_with_args(np, list_name, cells_name, 0, index,
+	ret = __of_parse_phandle_with_args(np, list_name, cells_name, -1, index,
 					   out_args);
 	if (ret)
 		goto free;
@@ -1756,7 +1765,7 @@ int of_count_phandle_with_args(const struct device_node *np, const char *list_na
 	struct of_phandle_iterator it;
 	int rc, cur_index = 0;
 
-	rc = of_phandle_iterator_init(&it, np, list_name, cells_name, 0);
+	rc = of_phandle_iterator_init(&it, np, list_name, cells_name, -1);
 	if (rc)
 		return rc;
 

commit fb709b5e1cca55d88a1d089fd935021310ce129b
Author: Jean-Philippe Brucker <jean-philippe.brucker@arm.com>
Date:   Tue Jan 15 12:19:55 2019 +0000

    of: Allow the iommu-map property to omit untranslated devices
    
    In PCI root complex nodes, the iommu-map property describes the IOMMU that
    translates each endpoint. On some platforms, the IOMMU itself is presented
    as a PCI endpoint (e.g. AMD IOMMU and virtio-iommu). This isn't supported
    by the current OF driver, which expects all endpoints to have an IOMMU.
    Allow the iommu-map property to have gaps.
    
    Relaxing of_map_rid() also allows the msi-map property to have gaps, which
    is invalid since MSIs always reach an MSI controller. In that case
    pci_msi_setup_msi_irqs() will return an error when attempting to find the
    device's MSI domain.
    
    Reviewed-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Jean-Philippe Brucker <jean-philippe.brucker@arm.com>
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 20e0e7ee4edf..55e7f5bb0549 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -2294,8 +2294,12 @@ int of_map_rid(struct device_node *np, u32 rid,
 		return 0;
 	}
 
-	pr_err("%pOF: Invalid %s translation - no match for rid 0x%x on %pOF\n",
-		np, map_name, rid, target && *target ? *target : NULL);
-	return -EFAULT;
+	pr_info("%pOF: no %s translation for rid 0x%x on %pOF\n", np, map_name,
+		rid, target && *target ? *target : NULL);
+
+	/* Bypasses translation */
+	if (id_out)
+		*id_out = rid;
+	return 0;
 }
 EXPORT_SYMBOL_GPL(of_map_rid);

commit af3be70a32113787da9f15e4ce8a357ae6caa293
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Wed Apr 3 10:56:33 2019 -0700

    of: Improve of_phandle_iterator_next() error message
    
    Understanding why of_phandle_iterator_next() returns an error can
    sometimes be hard to decipher based solely on the error message, a
    typical error example is that #foo-cells = <X> and the phandle property
    used has a smaller number of cells specified, e.g.:
    
            #thermal-sensor-cells = <1>;
            phandle = <&scmi_sensor>
    
    instead of:
    
            phandle <&scmi_sensor 0>;
    
    Instead, make it clear what the expectations are towards debugging
    incorrect Device Tree faster:
    
    OF: /thermal-zones/scmi-thermal: #thermal-sensor-cells = 1, found 0 instead
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 5226e898476e..20e0e7ee4edf 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1350,8 +1350,9 @@ int of_phandle_iterator_next(struct of_phandle_iterator *it)
 		 * property data length
 		 */
 		if (it->cur + count > it->list_end) {
-			pr_err("%pOF: arguments longer than property\n",
-			       it->parent);
+			pr_err("%pOF: %s = %d found %d\n",
+			       it->parent, it->cells_name,
+			       count, it->cell_count);
 			goto err;
 		}
 	}

commit 5801169a2ed20003f771acecf3ac00574cf10a38
Author: Frank Rowand <frank.rowand@sony.com>
Date:   Tue Dec 18 11:40:03 2018 -0800

    of: __of_detach_node() - remove node from phandle cache
    
    Non-overlay dynamic devicetree node removal may leave the node in
    the phandle cache.  Subsequent calls to of_find_node_by_phandle()
    will incorrectly find the stale entry.  Remove the node from the
    cache.
    
    Add paranoia checks in of_find_node_by_phandle() as a second level
    of defense (do not return cached node if detached, do not add node
    to cache if detached).
    
    Fixes: 0b3ce78e90fc ("of: cache phandle nodes to reduce cost of of_find_node_by_phandle()")
    Reported-by: Michael Bringmann <mwb@linux.vnet.ibm.com>
    Cc: stable@vger.kernel.org # v4.17+
    Signed-off-by: Frank Rowand <frank.rowand@sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 4da1c688995b..5226e898476e 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -169,6 +169,28 @@ int of_free_phandle_cache(void)
 late_initcall_sync(of_free_phandle_cache);
 #endif
 
+/*
+ * Caller must hold devtree_lock.
+ */
+void __of_free_phandle_cache_entry(phandle handle)
+{
+	phandle masked_handle;
+	struct device_node *np;
+
+	if (!handle)
+		return;
+
+	masked_handle = handle & phandle_cache_mask;
+
+	if (phandle_cache) {
+		np = phandle_cache[masked_handle];
+		if (np && handle == np->phandle) {
+			of_node_put(np);
+			phandle_cache[masked_handle] = NULL;
+		}
+	}
+}
+
 void of_populate_phandle_cache(void)
 {
 	unsigned long flags;
@@ -1214,11 +1236,18 @@ struct device_node *of_find_node_by_phandle(phandle handle)
 		if (phandle_cache[masked_handle] &&
 		    handle == phandle_cache[masked_handle]->phandle)
 			np = phandle_cache[masked_handle];
+		if (np && of_node_check_flag(np, OF_DETACHED)) {
+			WARN_ON(1); /* did not uncache np on node removal */
+			of_node_put(np);
+			phandle_cache[masked_handle] = NULL;
+			np = NULL;
+		}
 	}
 
 	if (!np) {
 		for_each_of_allnodes(np)
-			if (np->phandle == handle) {
+			if (np->phandle == handle &&
+			    !of_node_check_flag(np, OF_DETACHED)) {
 				if (phandle_cache) {
 					/* will put when removed from cache */
 					of_node_get(np);

commit b8a9ac1a5b99a2fcbed19fd29d2d59270c281a31
Author: Frank Rowand <frank.rowand@sony.com>
Date:   Tue Dec 18 11:40:02 2018 -0800

    of: of_node_get()/of_node_put() nodes held in phandle cache
    
    The phandle cache contains struct device_node pointers.  The refcount
    of the pointers was not incremented while in the cache, allowing use
    after free error after kfree() of the node.  Add the proper increment
    and decrement of the use count.
    
    Fixes: 0b3ce78e90fc ("of: cache phandle nodes to reduce cost of of_find_node_by_phandle()")
    Cc: stable@vger.kernel.org # v4.17+
    Signed-off-by: Frank Rowand <frank.rowand@sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 998d032fcef9..4da1c688995b 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -123,9 +123,6 @@ int __weak of_node_to_nid(struct device_node *np)
 }
 #endif
 
-static struct device_node **phandle_cache;
-static u32 phandle_cache_mask;
-
 /*
  * Assumptions behind phandle_cache implementation:
  *   - phandle property values are in a contiguous range of 1..n
@@ -134,6 +131,44 @@ static u32 phandle_cache_mask;
  *   - the phandle lookup overhead reduction provided by the cache
  *     will likely be less
  */
+
+static struct device_node **phandle_cache;
+static u32 phandle_cache_mask;
+
+/*
+ * Caller must hold devtree_lock.
+ */
+static void __of_free_phandle_cache(void)
+{
+	u32 cache_entries = phandle_cache_mask + 1;
+	u32 k;
+
+	if (!phandle_cache)
+		return;
+
+	for (k = 0; k < cache_entries; k++)
+		of_node_put(phandle_cache[k]);
+
+	kfree(phandle_cache);
+	phandle_cache = NULL;
+}
+
+int of_free_phandle_cache(void)
+{
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&devtree_lock, flags);
+
+	__of_free_phandle_cache();
+
+	raw_spin_unlock_irqrestore(&devtree_lock, flags);
+
+	return 0;
+}
+#if !defined(CONFIG_MODULES)
+late_initcall_sync(of_free_phandle_cache);
+#endif
+
 void of_populate_phandle_cache(void)
 {
 	unsigned long flags;
@@ -143,8 +178,7 @@ void of_populate_phandle_cache(void)
 
 	raw_spin_lock_irqsave(&devtree_lock, flags);
 
-	kfree(phandle_cache);
-	phandle_cache = NULL;
+	__of_free_phandle_cache();
 
 	for_each_of_allnodes(np)
 		if (np->phandle && np->phandle != OF_PHANDLE_ILLEGAL)
@@ -162,30 +196,15 @@ void of_populate_phandle_cache(void)
 		goto out;
 
 	for_each_of_allnodes(np)
-		if (np->phandle && np->phandle != OF_PHANDLE_ILLEGAL)
+		if (np->phandle && np->phandle != OF_PHANDLE_ILLEGAL) {
+			of_node_get(np);
 			phandle_cache[np->phandle & phandle_cache_mask] = np;
+		}
 
 out:
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 }
 
-int of_free_phandle_cache(void)
-{
-	unsigned long flags;
-
-	raw_spin_lock_irqsave(&devtree_lock, flags);
-
-	kfree(phandle_cache);
-	phandle_cache = NULL;
-
-	raw_spin_unlock_irqrestore(&devtree_lock, flags);
-
-	return 0;
-}
-#if !defined(CONFIG_MODULES)
-late_initcall_sync(of_free_phandle_cache);
-#endif
-
 void __init of_core_init(void)
 {
 	struct device_node *np;
@@ -1200,8 +1219,11 @@ struct device_node *of_find_node_by_phandle(phandle handle)
 	if (!np) {
 		for_each_of_allnodes(np)
 			if (np->phandle == handle) {
-				if (phandle_cache)
+				if (phandle_cache) {
+					/* will put when removed from cache */
+					of_node_get(np);
 					phandle_cache[masked_handle] = np;
+				}
 				break;
 			}
 	}

commit b3e46d1a0590500335f0b95e669ad6d84b12b03a
Author: Rob Herring <robh@kernel.org>
Date:   Mon Aug 27 08:37:06 2018 -0500

    of: Use of_node_name_eq for node name comparisons
    
    Convert string compares of DT node names to use of_node_name_eq helper
    instead. This removes direct access to the node name pointer.
    
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    Cc: devicetree@vger.kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 57c837140a8b..998d032fcef9 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -496,7 +496,7 @@ static int __of_device_is_compatible(const struct device_node *device,
 
 	/* Matching name is a bit better than not */
 	if (name && name[0]) {
-		if (!device->name || of_node_cmp(name, device->name))
+		if (!of_node_name_eq(device, name))
 			return 0;
 		score++;
 	}
@@ -835,7 +835,7 @@ struct device_node *of_get_child_by_name(const struct device_node *node,
 	struct device_node *child;
 
 	for_each_child_of_node(node, child)
-		if (child->name && (of_node_cmp(child->name, name) == 0))
+		if (of_node_name_eq(child, name))
 			break;
 	return child;
 }
@@ -961,8 +961,7 @@ struct device_node *of_find_node_by_name(struct device_node *from,
 
 	raw_spin_lock_irqsave(&devtree_lock, flags);
 	for_each_of_allnodes_from(from, np)
-		if (np->name && (of_node_cmp(np->name, name) == 0)
-		    && of_node_get(np))
+		if (of_node_name_eq(np, name) && of_node_get(np))
 			break;
 	of_node_put(from);
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);

commit e8b1dee21420f871e300d46342f2c98a2e08158d
Author: Rob Herring <robh@kernel.org>
Date:   Wed Aug 29 08:36:12 2018 -0500

    of: Use device_type helpers to access the node type
    
    Remove directly accessing device_node.type pointer and use the accessors
    instead. This will eventually allow removing the type pointer.
    
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: devicetree@vger.kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 09692c9b32a7..57c837140a8b 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -79,6 +79,13 @@ bool of_node_name_prefix(const struct device_node *np, const char *prefix)
 }
 EXPORT_SYMBOL(of_node_name_prefix);
 
+static bool __of_node_is_type(const struct device_node *np, const char *type)
+{
+	const char *match = __of_get_property(np, "device_type", NULL);
+
+	return np && match && type && !strcmp(match, type);
+}
+
 int of_n_addr_cells(struct device_node *np)
 {
 	u32 cells;
@@ -482,7 +489,7 @@ static int __of_device_is_compatible(const struct device_node *device,
 
 	/* Matching type is better than matching name */
 	if (type && type[0]) {
-		if (!device->type || of_node_cmp(type, device->type))
+		if (!__of_node_is_type(device, type))
 			return 0;
 		score += 2;
 	}
@@ -775,7 +782,7 @@ struct device_node *of_get_next_cpu_node(struct device_node *prev)
 	}
 	for (; next; next = next->sibling) {
 		if (!(of_node_name_eq(next, "cpu") ||
-		      (next->type && !of_node_cmp(next->type, "cpu"))))
+		      __of_node_is_type(next, "cpu")))
 			continue;
 		if (of_node_get(next))
 			break;
@@ -983,8 +990,7 @@ struct device_node *of_find_node_by_type(struct device_node *from,
 
 	raw_spin_lock_irqsave(&devtree_lock, flags);
 	for_each_of_allnodes_from(from, np)
-		if (np->type && (of_node_cmp(np->type, type) == 0)
-		    && of_node_get(np))
+		if (__of_node_is_type(np, type) && of_node_get(np))
 			break;
 	of_node_put(from);
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
@@ -2108,9 +2114,9 @@ struct device_node *of_find_next_cache_node(const struct device_node *np)
 	/* OF on pmac has nodes instead of properties named "l2-cache"
 	 * beneath CPU nodes.
 	 */
-	if (IS_ENABLED(CONFIG_PPC_PMAC) && !strcmp(np->type, "cpu"))
+	if (IS_ENABLED(CONFIG_PPC_PMAC) && of_node_is_type(np, "cpu"))
 		for_each_child_of_node(np, child)
-			if (!strcmp(child->type, "cache"))
+			if (of_node_is_type(child, "cache"))
 				return child;
 
 	return NULL;

commit 34c7685a177a7bc98066f7e5daa42eef621d0bdb
Merge: b5b1de3537e2 c961cb3be906
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Nov 1 14:45:38 2018 -0700

    Merge tag 'devicetree-fixes-for-4.20-1' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull Devicetree fixes from Rob Herring:
    
     - fix cpu node iterator for powerpc systems
    
     - clarify ARM CPU binding 'capacities-dmips-mhz' property calculations
    
    * tag 'devicetree-fixes-for-4.20-1' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux:
      of: Fix cpu node iterator to not ignore disabled cpu nodes
      dt-bindings: arm: Explain capacities-dmips-mhz calculations in example

commit c961cb3be9064d1097ccc019390f8b5739daafc6
Author: Rob Herring <robh@kernel.org>
Date:   Wed Oct 31 09:28:06 2018 -0500

    of: Fix cpu node iterator to not ignore disabled cpu nodes
    
    In most cases, nodes with 'status = "disabled";' are treated as if the
    node is not present though it is a common bug to forget to check that.
    However, cpu nodes are different in that "disabled" simply means offline
    and the OS can bring the CPU core online. Commit f1f207e43b8a ("of: Add
    cpu node iterator for_each_of_cpu_node()") followed the common behavior
    of ignoring disabled cpu nodes. This breaks some powerpc systems (at
    least NXP P50XX/e5500). Fix this by dropping the status check.
    
    Fixes: 651d44f9679c ("of: use for_each_of_cpu_node iterator")
    Fixes: f1f207e43b8a ("of: Add cpu node iterator for_each_of_cpu_node()")
    Reported-by: Christian Zigotzky <chzigotzky@xenosoft.de>
    Tested-by: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index cc62da278663..e47c5ce6cd58 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -776,8 +776,6 @@ struct device_node *of_get_next_cpu_node(struct device_node *prev)
 		if (!(of_node_name_eq(next, "cpu") ||
 		      (next->type && !of_node_cmp(next->type, "cpu"))))
 			continue;
-		if (!__of_device_is_available(next))
-			continue;
 		if (of_node_get(next))
 			break;
 	}

commit 5bd4af34a09a381a0f8b1552684650698937e6b0
Merge: 738b04fba18d 59eaeba63a17
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 29 10:42:20 2018 -0700

    Merge tag 'tty-4.20-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty
    
    Pull tty/serial updates from Greg KH:
     "Here is the big tty and serial pull request for 4.20-rc1
    
      Lots of little things here, including a merge from the SPI tree in
      order to keep things simpler for everyone to sync around for one
      platform.
    
      Major stuff is:
    
       - tty buffer clearing after use
    
       - atmel_serial fixes and additions
    
       - xilinx uart driver updates
    
      and of course, lots of tiny fixes and additions to individual serial
      drivers.
    
      All of these have been in linux-next with no reported issues for a
      while"
    
    * tag 'tty-4.20-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty: (66 commits)
      of: base: Change logic in of_alias_get_alias_list()
      of: base: Fix english spelling in of_alias_get_alias_list()
      serial: sh-sci: do not warn if DMA transfers are not supported
      serial: uartps: Do not allow use aliases >= MAX_UART_INSTANCES
      tty: check name length in tty_find_polling_driver()
      serial: sh-sci: Add r8a77990 support
      tty: wipe buffer if not echoing data
      tty: wipe buffer.
      serial: fsl_lpuart: Remove the alias node dependence
      TTY: sn_console: Replace spin_is_locked() with spin_trylock()
      Revert "serial:serial_core: Allow use of CTS for PPS line discipline"
      serial: 8250_uniphier: add auto-flow-control support
      serial: 8250_uniphier: flatten probe function
      serial: 8250_uniphier: remove unused "fifo-size" property
      dt-bindings: serial: sh-sci: Document r8a7744 bindings
      serial: uartps: Fix missing unlock on error in cdns_get_id()
      tty/serial: atmel: add ISO7816 support
      tty/serial_core: add ISO7816 infrastructure
      serial:serial_core: Allow use of CTS for PPS line discipline
      serial: docs: Fix filename for serial reference implementation
      ...

commit b27186abb37b7bd19e0ca434f4f425c807dbd708
Merge: 0ef7791e2bfb d061864b89c3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 26 12:09:58 2018 -0700

    Merge tag 'devicetree-for-4.20' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull Devicetree updates from Rob Herring:
     "A bit bigger than normal as I've been busy this cycle.
    
      There's a few things with dependencies and a few things subsystem
      maintainers didn't pick up, so I'm taking them thru my tree.
    
      The fixes from Johan didn't get into linux-next, but they've been
      waiting for some time now and they are what's left of what subsystem
      maintainers didn't pick up.
    
      Summary:
    
       - Sync dtc with upstream version v1.4.7-14-gc86da84d30e4
    
       - Work to get rid of direct accesses to struct device_node name and
         type pointers in preparation for removing them. New helpers for
         parsing DT cpu nodes and conversions to use the helpers. printk
         conversions to %pOFn for printing DT node names. Most went thru
         subystem trees, so this is the remainder.
    
       - Fixes to DT child node lookups to actually be restricted to child
         nodes instead of treewide.
    
       - Refactoring of dtb targets out of arch code. This makes the support
         more uniform and enables building all dtbs on c6x, microblaze, and
         powerpc.
    
       - Various DT binding updates for Renesas r8a7744 SoC
    
       - Vendor prefixes for Facebook, OLPC
    
       - Restructuring of some ARM binding docs moving some peripheral
         bindings out of board/SoC binding files
    
       - New "secure-chosen" binding for secure world settings on ARM
    
       - Dual licensing of 2 DT IRQ binding headers"
    
    * tag 'devicetree-for-4.20' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (78 commits)
      ARM: dt: relicense two DT binding IRQ headers
      power: supply: twl4030-charger: fix OF sibling-node lookup
      NFC: nfcmrvl_uart: fix OF child-node lookup
      net: stmmac: dwmac-sun8i: fix OF child-node lookup
      net: bcmgenet: fix OF child-node lookup
      drm/msm: fix OF child-node lookup
      drm/mediatek: fix OF sibling-node lookup
      of: Add missing exports of node name compare functions
      dt-bindings: Add OLPC vendor prefix
      dt-bindings: misc: bk4: Add device tree binding for Liebherr's BK4 SPI bus
      dt-bindings: thermal: samsung: Add SPDX license identifier
      dt-bindings: clock: samsung: Add SPDX license identifiers
      dt-bindings: timer: ostm: Add R7S9210 support
      dt-bindings: phy: rcar-gen2: Add r8a7744 support
      dt-bindings: can: rcar_can: Add r8a7744 support
      dt-bindings: timer: renesas, cmt: Document r8a7744 CMT support
      dt-bindings: watchdog: renesas-wdt: Document r8a7744 support
      dt-bindings: thermal: rcar: Add device tree support for r8a7744
      Documentation: dt: Add binding for /secure-chosen/stdout-path
      dt-bindings: arm: zte: Move sysctrl bindings to their own doc
      ...

commit 173ee3962959a1985a109f81539a403b5cd07ae7
Author: Rob Herring <robh@kernel.org>
Date:   Mon Oct 22 09:03:54 2018 -0500

    of: Add missing exports of node name compare functions
    
    Commit f42b0e18f2e5 ("of: add node name compare helper functions")
    failed to add the module exports to of_node_name_eq() and
    of_node_name_prefix(). Add them now.
    
    Fixes: f42b0e18f2e5 ("of: add node name compare helper functions")
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 32444299db45..cc62da278663 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -67,6 +67,7 @@ bool of_node_name_eq(const struct device_node *np, const char *name)
 
 	return (strlen(name) == len) && (strncmp(node_name, name, len) == 0);
 }
+EXPORT_SYMBOL(of_node_name_eq);
 
 bool of_node_name_prefix(const struct device_node *np, const char *prefix)
 {
@@ -75,6 +76,7 @@ bool of_node_name_prefix(const struct device_node *np, const char *prefix)
 
 	return strncmp(kbasename(np->full_name), prefix, strlen(prefix)) == 0;
 }
+EXPORT_SYMBOL(of_node_name_prefix);
 
 int of_n_addr_cells(struct device_node *np)
 {

commit 59eaeba63a171127a90bb76187536ba66076af40
Author: Michal Simek <michal.simek@xilinx.com>
Date:   Fri Oct 12 07:43:11 2018 +0200

    of: base: Change logic in of_alias_get_alias_list()
    
    Check compatible string first before setting up bit in bitmap to also
    cover cases that allocated bitfield is not big enough.
    Show warning about it but let driver to continue to work with allocated
    bitfield to keep at least some devices (included console which
    is commonly close to serial0) to work.
    
    Fixes: b1078c355d76 ("of: base: Introduce of_alias_get_alias_list() to check alias IDs")
    Fixes: ae1cca3fa347 ("serial: uartps: Change uart ID port allocation")
    Signed-off-by: Michal Simek <michal.simek@xilinx.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 908de45f966b..6418205a05f5 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1953,13 +1953,15 @@ EXPORT_SYMBOL_GPL(of_alias_get_id);
  * The function travels the lookup table to record alias ids for the given
  * device match structures and alias stem.
  *
- * Return:	0 or -ENOSYS when !CONFIG_OF
+ * Return:	0 or -ENOSYS when !CONFIG_OF or
+ *		-EOVERFLOW if alias ID is greater then allocated nbits
  */
 int of_alias_get_alias_list(const struct of_device_id *matches,
 			     const char *stem, unsigned long *bitmap,
 			     unsigned int nbits)
 {
 	struct alias_prop *app;
+	int ret = 0;
 
 	/* Zero bitmap field to make sure that all the time it is clean */
 	bitmap_zero(bitmap, nbits);
@@ -1976,21 +1978,21 @@ int of_alias_get_alias_list(const struct of_device_id *matches,
 			continue;
 		}
 
-		if (app->id >= nbits) {
-			pr_debug("%s: ID %d greater then bitmap field %d\n",
-				__func__, app->id, nbits);
-			continue;
-		}
-
 		if (of_match_node(matches, app->np)) {
 			pr_debug("%s: Allocated ID %d\n", __func__, app->id);
-			set_bit(app->id, bitmap);
+
+			if (app->id >= nbits) {
+				pr_warn("%s: ID %d >= than bitmap field %d\n",
+					__func__, app->id, nbits);
+				ret = -EOVERFLOW;
+			} else {
+				set_bit(app->id, bitmap);
+			}
 		}
-		/* Alias exists but is not compatible with matches */
 	}
 	mutex_unlock(&of_mutex);
 
-	return 0;
+	return ret;
 }
 EXPORT_SYMBOL_GPL(of_alias_get_alias_list);
 

commit 7acf79b6b2160540af87f47a55d7e3e5637ddeb5
Author: Michal Simek <michal.simek@xilinx.com>
Date:   Mon Oct 8 13:58:47 2018 +0200

    of: base: Fix english spelling in of_alias_get_alias_list()
    
    Fix english spelling in of_alias_get_alias_list().
    
    Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Reported-by: Randy Dunlap <rdunlap@infradead.org>
    Fixes: b1078c355d76 ("of: base: Introduce of_alias_get_alias_list() to check alias IDs")
    Signed-off-by: Michal Simek <michal.simek@xilinx.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 33011b88ed3f..908de45f966b 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1948,7 +1948,7 @@ EXPORT_SYMBOL_GPL(of_alias_get_id);
  * @matches:	Array of OF device match structures to search in
  * @stem:	Alias stem of the given device_node
  * @bitmap:	Bitmap field pointer
- * @nbits:	Maximum number of alias ID which can be recorded it bitmap
+ * @nbits:	Maximum number of alias IDs which can be recorded in bitmap
  *
  * The function travels the lookup table to record alias ids for the given
  * device match structures and alias stem.
@@ -1971,7 +1971,7 @@ int of_alias_get_alias_list(const struct of_device_id *matches,
 			 __func__, app->stem, app->id);
 
 		if (strcmp(app->stem, stem) != 0) {
-			pr_debug("%s: stem comparison doesn't passed %s\n",
+			pr_debug("%s: stem comparison didn't pass %s\n",
 				 __func__, app->stem);
 			continue;
 		}
@@ -1986,7 +1986,7 @@ int of_alias_get_alias_list(const struct of_device_id *matches,
 			pr_debug("%s: Allocated ID %d\n", __func__, app->id);
 			set_bit(app->id, bitmap);
 		}
-		/* Alias exist but it not compatible with matches */
+		/* Alias exists but is not compatible with matches */
 	}
 	mutex_unlock(&of_mutex);
 

commit 389d0a8a7af8ff8bb6301382333c7e8f748d7cd6
Merge: da08d8cb8cfc 4c29e5934f6c
Author: Rob Herring <robh@kernel.org>
Date:   Fri Sep 28 15:48:39 2018 -0500

    Merge branch 'dt/cpu-type-rework' into dt/next

commit 651d44f9679cf49992c59fee5570c2c8b9b8ac4c
Author: Rob Herring <robh@kernel.org>
Date:   Mon Aug 27 09:47:00 2018 -0500

    of: use for_each_of_cpu_node iterator
    
    Use the for_each_of_cpu_node iterator to iterate over cpu nodes. This
    has the side effect of defaulting to iterating using "cpu" node names in
    preference to the deprecated (for FDT) device_type == "cpu".
    
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: devicetree@vger.kernel.org
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index bd51d2113cc0..5fd6eee99015 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -389,7 +389,7 @@ struct device_node *of_get_cpu_node(int cpu, unsigned int *thread)
 {
 	struct device_node *cpun;
 
-	for_each_node_by_type(cpun, "cpu") {
+	for_each_of_cpu_node(cpun) {
 		if (arch_find_n_match_cpu_physical_id(cpun, cpu, thread))
 			return cpun;
 	}

commit 6487c15f1cc9340fa010d94eeab72ebb657b21dc
Author: Rob Herring <robh@kernel.org>
Date:   Mon Aug 27 13:46:51 2018 -0500

    of: Support matching cpu nodes with no 'reg' property
    
    For some single core ARM systems, the DTs can have a single cpu node
    without a reg property and #address-cells == 0. This case is valid and
    should match on cpu #0.
    
    Cc: Frank Rowand <frowand.list@gmail.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 4807db0a35b3..bd51d2113cc0 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -327,6 +327,8 @@ static bool __of_find_n_match_cpu_property(struct device_node *cpun,
 
 	ac = of_n_addr_cells(cpun);
 	cell = of_get_property(cpun, prop_name, &prop_len);
+	if (!cell && !ac && arch_match_cpu_phys_id(cpu, 0))
+		return true;
 	if (!cell || !ac)
 		return false;
 	prop_len /= sizeof(*cell) * ac;

commit f1f207e43b8a49ac2ee3c36a64de1f84651c6079
Author: Rob Herring <robh@kernel.org>
Date:   Wed Aug 22 15:04:40 2018 -0500

    of: Add cpu node iterator for_each_of_cpu_node()
    
    Iterating thru cpu nodes is a common pattern. Create a common iterator
    which can find child nodes either by node name or device_type == cpu.
    Using the former will allow for eventually dropping device_type
    properties which are deprecated for FDT.
    
    Cc: Frank Rowand <frowand.list@gmail.com>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index a055cd1ef96d..4807db0a35b3 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -741,6 +741,45 @@ struct device_node *of_get_next_available_child(const struct device_node *node,
 }
 EXPORT_SYMBOL(of_get_next_available_child);
 
+/**
+ *	of_get_next_cpu_node - Iterate on cpu nodes
+ *	@prev:	previous child of the /cpus node, or NULL to get first
+ *
+ *	Returns a cpu node pointer with refcount incremented, use of_node_put()
+ *	on it when done. Returns NULL when prev is the last child. Decrements
+ *	the refcount of prev.
+ */
+struct device_node *of_get_next_cpu_node(struct device_node *prev)
+{
+	struct device_node *next = NULL;
+	unsigned long flags;
+	struct device_node *node;
+
+	if (!prev)
+		node = of_find_node_by_path("/cpus");
+
+	raw_spin_lock_irqsave(&devtree_lock, flags);
+	if (prev)
+		next = prev->sibling;
+	else if (node) {
+		next = node->child;
+		of_node_put(node);
+	}
+	for (; next; next = next->sibling) {
+		if (!(of_node_name_eq(next, "cpu") ||
+		      (next->type && !of_node_cmp(next->type, "cpu"))))
+			continue;
+		if (!__of_device_is_available(next))
+			continue;
+		if (of_node_get(next))
+			break;
+	}
+	of_node_put(prev);
+	raw_spin_unlock_irqrestore(&devtree_lock, flags);
+	return next;
+}
+EXPORT_SYMBOL(of_get_next_cpu_node);
+
 /**
  * of_get_compatible_child - Find compatible child node
  * @parent:	parent node

commit 2a6db719c92dbfe43c9eea7e4358ea2e51b5004e
Author: Nipun Gupta <nipun.gupta@nxp.com>
Date:   Mon Sep 10 19:19:16 2018 +0530

    iommu/of: make of_pci_map_rid() available for other devices too
    
    iommu-map property is also used by devices with fsl-mc. This
    patch moves the of_pci_map_rid to generic location, so that it
    can be used by other busses too.
    
    'of_pci_map_rid' is renamed here to 'of_map_rid' and there is no
    functional change done in the API.
    
    Signed-off-by: Nipun Gupta <nipun.gupta@nxp.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Reviewed-by: Robin Murphy <robin.murphy@arm.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 74eaedd5b860..90bf7d9fa17b 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -2045,3 +2045,105 @@ int of_find_last_cache_level(unsigned int cpu)
 
 	return cache_level;
 }
+
+/**
+ * of_map_rid - Translate a requester ID through a downstream mapping.
+ * @np: root complex device node.
+ * @rid: device requester ID to map.
+ * @map_name: property name of the map to use.
+ * @map_mask_name: optional property name of the mask to use.
+ * @target: optional pointer to a target device node.
+ * @id_out: optional pointer to receive the translated ID.
+ *
+ * Given a device requester ID, look up the appropriate implementation-defined
+ * platform ID and/or the target device which receives transactions on that
+ * ID, as per the "iommu-map" and "msi-map" bindings. Either of @target or
+ * @id_out may be NULL if only the other is required. If @target points to
+ * a non-NULL device node pointer, only entries targeting that node will be
+ * matched; if it points to a NULL value, it will receive the device node of
+ * the first matching target phandle, with a reference held.
+ *
+ * Return: 0 on success or a standard error code on failure.
+ */
+int of_map_rid(struct device_node *np, u32 rid,
+	       const char *map_name, const char *map_mask_name,
+	       struct device_node **target, u32 *id_out)
+{
+	u32 map_mask, masked_rid;
+	int map_len;
+	const __be32 *map = NULL;
+
+	if (!np || !map_name || (!target && !id_out))
+		return -EINVAL;
+
+	map = of_get_property(np, map_name, &map_len);
+	if (!map) {
+		if (target)
+			return -ENODEV;
+		/* Otherwise, no map implies no translation */
+		*id_out = rid;
+		return 0;
+	}
+
+	if (!map_len || map_len % (4 * sizeof(*map))) {
+		pr_err("%pOF: Error: Bad %s length: %d\n", np,
+			map_name, map_len);
+		return -EINVAL;
+	}
+
+	/* The default is to select all bits. */
+	map_mask = 0xffffffff;
+
+	/*
+	 * Can be overridden by "{iommu,msi}-map-mask" property.
+	 * If of_property_read_u32() fails, the default is used.
+	 */
+	if (map_mask_name)
+		of_property_read_u32(np, map_mask_name, &map_mask);
+
+	masked_rid = map_mask & rid;
+	for ( ; map_len > 0; map_len -= 4 * sizeof(*map), map += 4) {
+		struct device_node *phandle_node;
+		u32 rid_base = be32_to_cpup(map + 0);
+		u32 phandle = be32_to_cpup(map + 1);
+		u32 out_base = be32_to_cpup(map + 2);
+		u32 rid_len = be32_to_cpup(map + 3);
+
+		if (rid_base & ~map_mask) {
+			pr_err("%pOF: Invalid %s translation - %s-mask (0x%x) ignores rid-base (0x%x)\n",
+				np, map_name, map_name,
+				map_mask, rid_base);
+			return -EFAULT;
+		}
+
+		if (masked_rid < rid_base || masked_rid >= rid_base + rid_len)
+			continue;
+
+		phandle_node = of_find_node_by_phandle(phandle);
+		if (!phandle_node)
+			return -ENODEV;
+
+		if (target) {
+			if (*target)
+				of_node_put(phandle_node);
+			else
+				*target = phandle_node;
+
+			if (*target != phandle_node)
+				continue;
+		}
+
+		if (id_out)
+			*id_out = masked_rid - rid_base + out_base;
+
+		pr_debug("%pOF: %s, using mask %08x, rid-base: %08x, out-base: %08x, length: %08x, rid: %08x -> %08x\n",
+			np, map_name, map_mask, rid_base, out_base,
+			rid_len, rid, masked_rid - rid_base + out_base);
+		return 0;
+	}
+
+	pr_err("%pOF: Invalid %s translation - no match for rid 0x%x on %pOF\n",
+		np, map_name, rid, target && *target ? *target : NULL);
+	return -EFAULT;
+}
+EXPORT_SYMBOL_GPL(of_map_rid);

commit b1078c355d76769b5ddefc67d143fbd9b6e52c05
Author: Michal Simek <michal.simek@xilinx.com>
Date:   Thu Sep 20 13:41:52 2018 +0200

    of: base: Introduce of_alias_get_alias_list() to check alias IDs
    
    The function travels the lookup table to record alias ids for the given
    device match structures and alias stem.
    This function will be used by serial drivers to check if requested alias
    is allocated or free to use.
    
    Signed-off-by: Michal Simek <michal.simek@xilinx.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 74eaedd5b860..33011b88ed3f 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -16,6 +16,7 @@
 
 #define pr_fmt(fmt)	"OF: " fmt
 
+#include <linux/bitmap.h>
 #include <linux/console.h>
 #include <linux/ctype.h>
 #include <linux/cpu.h>
@@ -1942,6 +1943,57 @@ int of_alias_get_id(struct device_node *np, const char *stem)
 }
 EXPORT_SYMBOL_GPL(of_alias_get_id);
 
+/**
+ * of_alias_get_alias_list - Get alias list for the given device driver
+ * @matches:	Array of OF device match structures to search in
+ * @stem:	Alias stem of the given device_node
+ * @bitmap:	Bitmap field pointer
+ * @nbits:	Maximum number of alias ID which can be recorded it bitmap
+ *
+ * The function travels the lookup table to record alias ids for the given
+ * device match structures and alias stem.
+ *
+ * Return:	0 or -ENOSYS when !CONFIG_OF
+ */
+int of_alias_get_alias_list(const struct of_device_id *matches,
+			     const char *stem, unsigned long *bitmap,
+			     unsigned int nbits)
+{
+	struct alias_prop *app;
+
+	/* Zero bitmap field to make sure that all the time it is clean */
+	bitmap_zero(bitmap, nbits);
+
+	mutex_lock(&of_mutex);
+	pr_debug("%s: Looking for stem: %s\n", __func__, stem);
+	list_for_each_entry(app, &aliases_lookup, link) {
+		pr_debug("%s: stem: %s, id: %d\n",
+			 __func__, app->stem, app->id);
+
+		if (strcmp(app->stem, stem) != 0) {
+			pr_debug("%s: stem comparison doesn't passed %s\n",
+				 __func__, app->stem);
+			continue;
+		}
+
+		if (app->id >= nbits) {
+			pr_debug("%s: ID %d greater then bitmap field %d\n",
+				__func__, app->id, nbits);
+			continue;
+		}
+
+		if (of_match_node(matches, app->np)) {
+			pr_debug("%s: Allocated ID %d\n", __func__, app->id);
+			set_bit(app->id, bitmap);
+		}
+		/* Alias exist but it not compatible with matches */
+	}
+	mutex_unlock(&of_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(of_alias_get_alias_list);
+
 /**
  * of_alias_get_highest_id - Get highest alias id for the given stem
  * @stem:	Alias stem to be examined

commit 362ce2b8e52be97dcc3986ce6f8dbe9e7a84e1a0
Merge: 00b7d1cf4667 e54192b48da7
Author: Rob Herring <robh@kernel.org>
Date:   Wed Sep 19 15:10:03 2018 -0700

    Merge branch 'dt/linus' into HEAD

commit e54192b48da75f025ae4b277925eaf6aca1d13bd
Author: Rob Herring <robh@kernel.org>
Date:   Tue Sep 11 09:28:14 2018 -0500

    of: fix phandle cache creation for DTs with no phandles
    
    With commit 0b3ce78e90fc ("of: cache phandle nodes to reduce cost of
    of_find_node_by_phandle()"), a G3 PowerMac fails to boot. The root cause
    is the DT for this system has no phandle properties when booted with
    BootX. of_populate_phandle_cache() does not handle the case of no
    phandles correctly. The problem is roundup_pow_of_two() for 0 is
    undefined. The implementation subtracts 1 underflowing and then things
    are in the weeds.
    
    Fixes: 0b3ce78e90fc ("of: cache phandle nodes to reduce cost of of_find_node_by_phandle()")
    Cc: stable@vger.kernel.org # 4.17+
    Reported-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Reviewed-by: Frank Rowand <frank.rowand@sony.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 9095b8290150..74eaedd5b860 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -140,6 +140,9 @@ void of_populate_phandle_cache(void)
 		if (np->phandle && np->phandle != OF_PHANDLE_ILLEGAL)
 			phandles++;
 
+	if (!phandles)
+		goto out;
+
 	cache_entries = roundup_pow_of_two(phandles);
 	phandle_cache_mask = cache_entries - 1;
 

commit f6707fd6241e483f6fea2caae82d876e422bb11a
Author: Rob Herring <robh@kernel.org>
Date:   Mon Aug 27 09:50:09 2018 -0500

    of: make PowerMac cache node search conditional on CONFIG_PPC_PMAC
    
    Cache nodes under the cpu node(s) is PowerMac specific according to the
    comment above, so make the code enforce that.
    
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 9095b8290150..a055cd1ef96d 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -2010,7 +2010,7 @@ struct device_node *of_find_next_cache_node(const struct device_node *np)
 	/* OF on pmac has nodes instead of properties named "l2-cache"
 	 * beneath CPU nodes.
 	 */
-	if (!strcmp(np->type, "cpu"))
+	if (IS_ENABLED(CONFIG_PPC_PMAC) && !strcmp(np->type, "cpu"))
 		for_each_child_of_node(np, child)
 			if (!strcmp(child->type, "cache"))
 				return child;

commit f42b0e18f2e5cf34f73ef1b6327b49040b307a33
Author: Rob Herring <robh@kernel.org>
Date:   Mon Aug 27 07:50:47 2018 -0500

    of: add node name compare helper functions
    
    In preparation to remove device_node.name pointer, add helper functions
    for node name comparisons which are a common pattern throughout the kernel.
    
    Cc: Frank Rowand <frowand.list@gmail.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index bc420d2aa5f5..9095b8290150 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -54,6 +54,28 @@ DEFINE_MUTEX(of_mutex);
  */
 DEFINE_RAW_SPINLOCK(devtree_lock);
 
+bool of_node_name_eq(const struct device_node *np, const char *name)
+{
+	const char *node_name;
+	size_t len;
+
+	if (!np)
+		return false;
+
+	node_name = kbasename(np->full_name);
+	len = strchrnul(node_name, '@') - node_name;
+
+	return (strlen(name) == len) && (strncmp(node_name, name, len) == 0);
+}
+
+bool of_node_name_prefix(const struct device_node *np, const char *prefix)
+{
+	if (!np)
+		return false;
+
+	return strncmp(kbasename(np->full_name), prefix, strlen(prefix)) == 0;
+}
+
 int of_n_addr_cells(struct device_node *np)
 {
 	u32 cells;

commit 36156f9241cb0f9e37d998052873ca7501ad4b36
Author: Johan Hovold <johan@kernel.org>
Date:   Mon Aug 27 10:21:45 2018 +0200

    of: add helper to lookup compatible child node
    
    Add of_get_compatible_child() helper that can be used to lookup
    compatible child nodes.
    
    Several drivers currently use of_find_compatible_node() to lookup child
    nodes while failing to notice that the of_find_ functions search the
    entire tree depth-first (from a given start node) and therefore can
    match unrelated nodes. The fact that these functions also drop a
    reference to the node they start searching from (e.g. the parent node)
    is typically also overlooked, something which can lead to use-after-free
    bugs.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 466e3c8582f0..bc420d2aa5f5 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -719,6 +719,31 @@ struct device_node *of_get_next_available_child(const struct device_node *node,
 }
 EXPORT_SYMBOL(of_get_next_available_child);
 
+/**
+ * of_get_compatible_child - Find compatible child node
+ * @parent:	parent node
+ * @compatible:	compatible string
+ *
+ * Lookup child node whose compatible property contains the given compatible
+ * string.
+ *
+ * Returns a node pointer with refcount incremented, use of_node_put() on it
+ * when done; or NULL if not found.
+ */
+struct device_node *of_get_compatible_child(const struct device_node *parent,
+				const char *compatible)
+{
+	struct device_node *child;
+
+	for_each_child_of_node(parent, child) {
+		if (of_device_is_compatible(child, compatible))
+			break;
+	}
+
+	return child;
+}
+EXPORT_SYMBOL(of_get_compatible_child);
+
 /**
  *	of_get_child_by_name - Find the child node by name for a given parent
  *	@node:	parent node

commit b9952b5218added5577e4a3443969bc20884cea9
Author: Frank Rowand <frank.rowand@sony.com>
Date:   Thu Jul 12 14:00:07 2018 -0700

    of: overlay: update phandle cache on overlay apply and remove
    
    A comment in the review of the patch adding the phandle cache said that
    the cache would have to be updated when modules are applied and removed.
    This patch implements the cache updates.
    
    Fixes: 0b3ce78e90fc ("of: cache phandle nodes to reduce cost of of_find_node_by_phandle()")
    Reported-by: Alan Tull <atull@kernel.org>
    Suggested-by: Alan Tull <atull@kernel.org>
    Signed-off-by: Frank Rowand <frank.rowand@sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 848f549164cd..466e3c8582f0 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -102,7 +102,7 @@ static u32 phandle_cache_mask;
  *   - the phandle lookup overhead reduction provided by the cache
  *     will likely be less
  */
-static void of_populate_phandle_cache(void)
+void of_populate_phandle_cache(void)
 {
 	unsigned long flags;
 	u32 cache_entries;
@@ -134,8 +134,7 @@ static void of_populate_phandle_cache(void)
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 }
 
-#ifndef CONFIG_MODULES
-static int __init of_free_phandle_cache(void)
+int of_free_phandle_cache(void)
 {
 	unsigned long flags;
 
@@ -148,6 +147,7 @@ static int __init of_free_phandle_cache(void)
 
 	return 0;
 }
+#if !defined(CONFIG_MODULES)
 late_initcall_sync(of_free_phandle_cache);
 #endif
 

commit 0b3ce78e90fc66c50a944320d6e39fa6fdb46cdf
Author: Frank Rowand <frank.rowand@sony.com>
Date:   Sun Mar 4 16:14:47 2018 -0800

    of: cache phandle nodes to reduce cost of of_find_node_by_phandle()
    
    Create a cache of the nodes that contain a phandle property.  Use this
    cache to find the node for a given phandle value instead of scanning
    the devicetree to find the node.  If the phandle value is not found
    in the cache, of_find_node_by_phandle() will fall back to the tree
    scan algorithm.
    
    The cache is initialized in of_core_init().
    
    The cache is freed via a late_initcall_sync() if modules are not
    enabled.
    
    If the devicetree is created by the dtc compiler, with all phandle
    property values auto generated, then the size required by the cache
    could be 4 * (1 + number of phandles) bytes.  This results in an O(1)
    node lookup cost for a given phandle value.  Due to a concern that the
    phandle property values might not be consistent with what is generated
    by the dtc compiler, a mask has been added to the cache lookup algorithm.
    To maintain the O(1) node lookup cost, the size of the cache has been
    increased by rounding the number of entries up to the next power of
    two.
    
    The overhead of finding the devicetree node containing a given phandle
    value has been noted by several people in the recent past, in some cases
    with a patch to add a hashed index of devicetree nodes, based on the
    phandle value of the node.  One concern with this approach is the extra
    space added to each node.  This patch takes advantage of the phandle
    property values auto generated by the dtc compiler, which begin with
    one and monotonically increase by one, resulting in a range of 1..n
    for n phandle values.  This implementation should also provide a good
    reduction of overhead for any range of phandle values that are mostly
    in a monotonic range.
    
    Performance measurements by Chintan Pandya <cpandya@codeaurora.org>
    of several implementations of patches that are similar to this one
    suggest an expected reduction of boot time by ~400ms for his test
    system.  If the cache size was decreased to 64 entries, the boot
    time was reduced by ~340 ms.  The measurements were on a 4.9.73 kernel
    for arch/arm64/boot/dts/qcom/sda670-mtp.dts, contains 2371 nodes and
    814 phandle values.
    
    Reported-by: Chintan Pandya <cpandya@codeaurora.org>
    Signed-off-by: Frank Rowand <frank.rowand@sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 091aa9449c3a..848f549164cd 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -91,10 +91,72 @@ int __weak of_node_to_nid(struct device_node *np)
 }
 #endif
 
+static struct device_node **phandle_cache;
+static u32 phandle_cache_mask;
+
+/*
+ * Assumptions behind phandle_cache implementation:
+ *   - phandle property values are in a contiguous range of 1..n
+ *
+ * If the assumptions do not hold, then
+ *   - the phandle lookup overhead reduction provided by the cache
+ *     will likely be less
+ */
+static void of_populate_phandle_cache(void)
+{
+	unsigned long flags;
+	u32 cache_entries;
+	struct device_node *np;
+	u32 phandles = 0;
+
+	raw_spin_lock_irqsave(&devtree_lock, flags);
+
+	kfree(phandle_cache);
+	phandle_cache = NULL;
+
+	for_each_of_allnodes(np)
+		if (np->phandle && np->phandle != OF_PHANDLE_ILLEGAL)
+			phandles++;
+
+	cache_entries = roundup_pow_of_two(phandles);
+	phandle_cache_mask = cache_entries - 1;
+
+	phandle_cache = kcalloc(cache_entries, sizeof(*phandle_cache),
+				GFP_ATOMIC);
+	if (!phandle_cache)
+		goto out;
+
+	for_each_of_allnodes(np)
+		if (np->phandle && np->phandle != OF_PHANDLE_ILLEGAL)
+			phandle_cache[np->phandle & phandle_cache_mask] = np;
+
+out:
+	raw_spin_unlock_irqrestore(&devtree_lock, flags);
+}
+
+#ifndef CONFIG_MODULES
+static int __init of_free_phandle_cache(void)
+{
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&devtree_lock, flags);
+
+	kfree(phandle_cache);
+	phandle_cache = NULL;
+
+	raw_spin_unlock_irqrestore(&devtree_lock, flags);
+
+	return 0;
+}
+late_initcall_sync(of_free_phandle_cache);
+#endif
+
 void __init of_core_init(void)
 {
 	struct device_node *np;
 
+	of_populate_phandle_cache();
+
 	/* Create the kset, and register existing nodes */
 	mutex_lock(&of_mutex);
 	of_kset = kset_create_and_add("devicetree", NULL, firmware_kobj);
@@ -1021,16 +1083,32 @@ EXPORT_SYMBOL_GPL(of_modalias_node);
  */
 struct device_node *of_find_node_by_phandle(phandle handle)
 {
-	struct device_node *np;
+	struct device_node *np = NULL;
 	unsigned long flags;
+	phandle masked_handle;
 
 	if (!handle)
 		return NULL;
 
 	raw_spin_lock_irqsave(&devtree_lock, flags);
-	for_each_of_allnodes(np)
-		if (np->phandle == handle)
-			break;
+
+	masked_handle = handle & phandle_cache_mask;
+
+	if (phandle_cache) {
+		if (phandle_cache[masked_handle] &&
+		    handle == phandle_cache[masked_handle]->phandle)
+			np = phandle_cache[masked_handle];
+	}
+
+	if (!np) {
+		for_each_of_allnodes(np)
+			if (np->phandle == handle) {
+				if (phandle_cache)
+					phandle_cache[masked_handle] = np;
+				break;
+			}
+	}
+
 	of_node_get(np);
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 	return np;

commit bd6f2fd5a1d52198468c5cdc3c2472362dff5aaa
Author: Stephen Boyd <stephen.boyd@linaro.org>
Date:   Tue Jan 30 18:36:16 2018 -0800

    of: Support parsing phandle argument lists through a nexus node
    
    Platforms like 96boards have a standardized connector/expansion
    slot that exposes signals like GPIOs to expansion boards in an
    SoC agnostic way. We'd like the DT overlays for the expansion
    boards to be written once without knowledge of the SoC on the
    other side of the connector. This avoids the unscalable
    combinatorial explosion of a different DT overlay for each
    expansion board and SoC pair.
    
    We need a way to describe the GPIOs routed through the connector
    in an SoC agnostic way. Let's introduce nexus property parsing
    into the OF core to do this. This is largely based on the
    interrupt nexus support we already have. This allows us to remap
    a phandle list in a consumer node (e.g. reset-gpios) through a
    connector in a generic way (e.g. via gpio-map). Do this in a
    generic routine so that we can remap any sort of variable length
    phandle list.
    
    Taking GPIOs as an example, the connector would be a GPIO nexus,
    supporting the remapping of a GPIO specifier space to multiple
    GPIO providers on the SoC. DT would look as shown below, where
    'soc_gpio1' and 'soc_gpio2' are inside the SoC, 'connector' is an
    expansion port where boards can be plugged in, and
    'expansion_device' is a device on the expansion board.
    
            soc {
                    soc_gpio1: gpio-controller1 {
                            #gpio-cells = <2>;
                    };
    
                    soc_gpio2: gpio-controller2 {
                            #gpio-cells = <2>;
                    };
            };
    
            connector: connector {
                    #gpio-cells = <2>;
                    gpio-map = <0 0 &soc_gpio1 1 0>,
                               <1 0 &soc_gpio2 4 0>,
                               <2 0 &soc_gpio1 3 0>,
                               <3 0 &soc_gpio2 2 0>;
                    gpio-map-mask = <0xf 0x0>;
                    gpio-map-pass-thru = <0x0 0x1>
            };
    
            expansion_device {
                    reset-gpios = <&connector 2 GPIO_ACTIVE_LOW>;
            };
    
    The GPIO core would use of_parse_phandle_with_args_map() instead
    of of_parse_phandle_with_args() and arrive at the same type of
    result, a phandle and argument list. The difference is that the
    phandle and arguments will be remapped through the nexus node to
    the underlying SoC GPIO controller node. In the example above,
    we would remap 'reset-gpios' from <&connector 2 GPIO_ACTIVE_LOW>
    to <&soc_gpio1 3 GPIO_ACTIVE_LOW>.
    
    Cc: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Mark Brown <broonie@kernel.org>
    Signed-off-by: Stephen Boyd <stephen.boyd@linaro.org>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index ad28de96e13f..091aa9449c3a 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1283,6 +1283,190 @@ int of_parse_phandle_with_args(const struct device_node *np, const char *list_na
 }
 EXPORT_SYMBOL(of_parse_phandle_with_args);
 
+/**
+ * of_parse_phandle_with_args_map() - Find a node pointed by phandle in a list and remap it
+ * @np:		pointer to a device tree node containing a list
+ * @list_name:	property name that contains a list
+ * @stem_name:	stem of property names that specify phandles' arguments count
+ * @index:	index of a phandle to parse out
+ * @out_args:	optional pointer to output arguments structure (will be filled)
+ *
+ * This function is useful to parse lists of phandles and their arguments.
+ * Returns 0 on success and fills out_args, on error returns appropriate errno
+ * value. The difference between this function and of_parse_phandle_with_args()
+ * is that this API remaps a phandle if the node the phandle points to has
+ * a <@stem_name>-map property.
+ *
+ * Caller is responsible to call of_node_put() on the returned out_args->np
+ * pointer.
+ *
+ * Example:
+ *
+ * phandle1: node1 {
+ *	#list-cells = <2>;
+ * }
+ *
+ * phandle2: node2 {
+ *	#list-cells = <1>;
+ * }
+ *
+ * phandle3: node3 {
+ * 	#list-cells = <1>;
+ * 	list-map = <0 &phandle2 3>,
+ * 		   <1 &phandle2 2>,
+ * 		   <2 &phandle1 5 1>;
+ *	list-map-mask = <0x3>;
+ * };
+ *
+ * node4 {
+ *	list = <&phandle1 1 2 &phandle3 0>;
+ * }
+ *
+ * To get a device_node of the `node2' node you may call this:
+ * of_parse_phandle_with_args(node4, "list", "list", 1, &args);
+ */
+int of_parse_phandle_with_args_map(const struct device_node *np,
+				   const char *list_name,
+				   const char *stem_name,
+				   int index, struct of_phandle_args *out_args)
+{
+	char *cells_name, *map_name = NULL, *mask_name = NULL;
+	char *pass_name = NULL;
+	struct device_node *cur, *new = NULL;
+	const __be32 *map, *mask, *pass;
+	static const __be32 dummy_mask[] = { [0 ... MAX_PHANDLE_ARGS] = ~0 };
+	static const __be32 dummy_pass[] = { [0 ... MAX_PHANDLE_ARGS] = 0 };
+	__be32 initial_match_array[MAX_PHANDLE_ARGS];
+	const __be32 *match_array = initial_match_array;
+	int i, ret, map_len, match;
+	u32 list_size, new_size;
+
+	if (index < 0)
+		return -EINVAL;
+
+	cells_name = kasprintf(GFP_KERNEL, "#%s-cells", stem_name);
+	if (!cells_name)
+		return -ENOMEM;
+
+	ret = -ENOMEM;
+	map_name = kasprintf(GFP_KERNEL, "%s-map", stem_name);
+	if (!map_name)
+		goto free;
+
+	mask_name = kasprintf(GFP_KERNEL, "%s-map-mask", stem_name);
+	if (!mask_name)
+		goto free;
+
+	pass_name = kasprintf(GFP_KERNEL, "%s-map-pass-thru", stem_name);
+	if (!pass_name)
+		goto free;
+
+	ret = __of_parse_phandle_with_args(np, list_name, cells_name, 0, index,
+					   out_args);
+	if (ret)
+		goto free;
+
+	/* Get the #<list>-cells property */
+	cur = out_args->np;
+	ret = of_property_read_u32(cur, cells_name, &list_size);
+	if (ret < 0)
+		goto put;
+
+	/* Precalculate the match array - this simplifies match loop */
+	for (i = 0; i < list_size; i++)
+		initial_match_array[i] = cpu_to_be32(out_args->args[i]);
+
+	ret = -EINVAL;
+	while (cur) {
+		/* Get the <list>-map property */
+		map = of_get_property(cur, map_name, &map_len);
+		if (!map) {
+			ret = 0;
+			goto free;
+		}
+		map_len /= sizeof(u32);
+
+		/* Get the <list>-map-mask property (optional) */
+		mask = of_get_property(cur, mask_name, NULL);
+		if (!mask)
+			mask = dummy_mask;
+		/* Iterate through <list>-map property */
+		match = 0;
+		while (map_len > (list_size + 1) && !match) {
+			/* Compare specifiers */
+			match = 1;
+			for (i = 0; i < list_size; i++, map_len--)
+				match &= !((match_array[i] ^ *map++) & mask[i]);
+
+			of_node_put(new);
+			new = of_find_node_by_phandle(be32_to_cpup(map));
+			map++;
+			map_len--;
+
+			/* Check if not found */
+			if (!new)
+				goto put;
+
+			if (!of_device_is_available(new))
+				match = 0;
+
+			ret = of_property_read_u32(new, cells_name, &new_size);
+			if (ret)
+				goto put;
+
+			/* Check for malformed properties */
+			if (WARN_ON(new_size > MAX_PHANDLE_ARGS))
+				goto put;
+			if (map_len < new_size)
+				goto put;
+
+			/* Move forward by new node's #<list>-cells amount */
+			map += new_size;
+			map_len -= new_size;
+		}
+		if (!match)
+			goto put;
+
+		/* Get the <list>-map-pass-thru property (optional) */
+		pass = of_get_property(cur, pass_name, NULL);
+		if (!pass)
+			pass = dummy_pass;
+
+		/*
+		 * Successfully parsed a <list>-map translation; copy new
+		 * specifier into the out_args structure, keeping the
+		 * bits specified in <list>-map-pass-thru.
+		 */
+		match_array = map - new_size;
+		for (i = 0; i < new_size; i++) {
+			__be32 val = *(map - new_size + i);
+
+			if (i < list_size) {
+				val &= ~pass[i];
+				val |= cpu_to_be32(out_args->args[i]) & pass[i];
+			}
+
+			out_args->args[i] = be32_to_cpu(val);
+		}
+		out_args->args_count = list_size = new_size;
+		/* Iterate again with new provider */
+		out_args->np = new;
+		of_node_put(cur);
+		cur = new;
+	}
+put:
+	of_node_put(cur);
+	of_node_put(new);
+free:
+	kfree(mask_name);
+	kfree(map_name);
+	kfree(cells_name);
+	kfree(pass_name);
+
+	return ret;
+}
+EXPORT_SYMBOL(of_parse_phandle_with_args_map);
+
 /**
  * of_parse_phandle_with_fixed_args() - Find a node pointed by phandle in a list
  * @np:		pointer to a device tree node containing a list

commit 2bed26606b61a7b20fc1cc54df53c48c06cd9aa8
Merge: eea43ed86f38 3a6fbcb2e2e4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 1 10:57:45 2018 -0800

    Merge tag 'devicetree-for-4.16' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull DeviceTree updates from Rob Herring:
    
     - Convert to use memblock_virt_alloc in DT code which supports
       bootmem arches. With this we can remove the arch specific
       early_init_dt_alloc_memory_arch() functions.
    
     - Enable running the DT unittests on UML
    
     - Use SPDX license tags on DT files
    
     - Fix early FDT kconfig ifdef logic
    
     - Clean-up unittest Makefile
    
     - Fix function comment for of_irq_parse_raw
    
     - Add missing documentation for linux,initrd-{start,end} properties
    
     - Clean-up of binding examples using uppercase hex
    
     - Add trivial devices W83773G and Infineon TLV493D-A1B6
    
     - Add missing STM32 SoC bindings
    
     - Various small binding doc fixes
    
    * tag 'devicetree-for-4.16' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (23 commits)
      xtensa: remove arch specific early DT functions
      x86: remove arch specific early_init_dt_alloc_memory_arch
      nios2: remove arch specific early_init_dt_alloc_memory_arch
      mips: remove arch specific early_init_dt_alloc_memory_arch
      metag: remove arch specific early DT functions
      cris: remove arch specific early DT functions
      libfdt: remove unnecessary include directive from <linux/libfdt.h>
      of: unittest: refactor Makefile
      of/fdt: use memblock_virt_alloc for early alloc
      of: Use SPDX license tag for DT files
      of/fdt: Fix #ifdef dependency of early flattree declarations
      dt-bindings: h8300 clocksource: correct spelling of pulse
      dt-bindings: imx6q-pcie: Add required property for i.MX6SX
      mmc: Don't reference Linux-specific OF_GPIO_ACTIVE_LOW flag in DT binding
      dt-bindings: Use lower case hex in unit-addresses
      dt-bindings: display: panel: Fix compatible string for Toshiba LT089AC29000
      dt-bindings: Add Infineon TLV493D-A1B6
      dt-bindings: mailbox: ti,message-manager: Fix interrupt name error
      dt-bindings: chosen: Document linux,initrd-{start,end}
      dt-bindings: arm: document supported STM32 SoC family
      ...

commit af6074fc9aa4b29517375634189ada1869eea598
Author: Rob Herring <robh@kernel.org>
Date:   Wed Dec 27 12:55:14 2017 -0600

    of: Use SPDX license tag for DT files
    
    Convert remaining DT files to use SPDX-License-Identifier tags.
    
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    Reviewed-by: Frank Rowand <frank.rowand@sony.com>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 26618ba8f92a..dd0b4201f1cc 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Procedures for creating, accessing and interpreting the device tree.
  *
@@ -11,11 +12,6 @@
  *
  *  Reconsolidated from arch/x/kernel/prom.c by Stephen Rothwell and
  *  Grant Likely.
- *
- *      This program is free software; you can redistribute it and/or
- *      modify it under the terms of the GNU General Public License
- *      as published by the Free Software Foundation; either version
- *      2 of the License, or (at your option) any later version.
  */
 
 #define pr_fmt(fmt)	"OF: " fmt

commit a0e71cd9b1a0195f96500b2268759873ff8ff819
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Tue Jan 2 11:25:27 2018 +0000

    of: Add helper for mapping device node to logical CPU number
    
    Add a helper to map a device node to a logical CPU number to avoid
    duplication. Currently this is open coded in different places (e.g
    gic-v3, coresight). The helper tries to map device node to a "possible"
    logical CPU id, which may not be online yet. It is the responsibility
    of the user to make sure that the CPU is online. The helper uses
    of_cpu_device_node_get() to retrieve the device node for a given CPU
    (which uses per_cpu data if available else falls back to slower
    of_get_cpu_node()).
    
    Cc: devicetree@vger.kernel.org
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 26618ba8f92a..a9d6fe86585b 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -315,6 +315,32 @@ struct device_node *of_get_cpu_node(int cpu, unsigned int *thread)
 }
 EXPORT_SYMBOL(of_get_cpu_node);
 
+/**
+ * of_cpu_node_to_id: Get the logical CPU number for a given device_node
+ *
+ * @cpu_node: Pointer to the device_node for CPU.
+ *
+ * Returns the logical CPU number of the given CPU device_node.
+ * Returns -ENODEV if the CPU is not found.
+ */
+int of_cpu_node_to_id(struct device_node *cpu_node)
+{
+	int cpu;
+	bool found = false;
+	struct device_node *np;
+
+	for_each_possible_cpu(cpu) {
+		np = of_cpu_device_node_get(cpu);
+		found = (cpu_node == np);
+		of_node_put(np);
+		if (found)
+			return cpu;
+	}
+
+	return -ENODEV;
+}
+EXPORT_SYMBOL(of_cpu_node_to_id);
+
 /**
  * __of_device_is_compatible() - Check if the node matches given constraints
  * @device: pointer to node

commit c633e898bde8990a34907c91b7d5245cab866c6e
Merge: bf8973fc76e4 def4db33e696
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 20 21:38:41 2017 -1000

    Merge tag 'devicetree-fixes-for-4.15' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull DeviceTree fixes from Rob Herring:
    
     - Remove mc13892 as a trivial device
    
     - Improve of_find_node_by_name() documentation
    
     - Fix unit test dtc warnings
    
     - Clean-ups of USB binding documentation
    
     - Fix potential NULL deref in of_pci_map_rid
    
    * tag 'devicetree-fixes-for-4.15' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux:
      dt-bindings: trivial-devices: Remove fsl,mc13892
      of: Document exactly what of_find_node_by_name() puts
      of: unittest: disable interrupts_property warning
      of: unittest: let dtc generate __local_fixups__
      dt-bindings: usb: document hub and host-controller properties
      dt-bindings: usb: clean up compatible property
      dt-bindings: usb: fix reg-property port-number range
      dt-bindings: usb: fix example hub node name
      of/pci: Fix theoretical NULL dereference

commit 02a876b504152335b49d99185ef5de4ced235555
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Nov 17 08:53:21 2017 -0800

    of: Document exactly what of_find_node_by_name() puts
    
    It isn't clear if this function of_node_put()s the 'from'
    argument, or the node it searches. Clearly indicate which
    variable is touched. Fold in some more fixes from Randy too
    because we're in the area.
    
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Acked-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 3de07e6e82a0..e6818a935b96 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -761,10 +761,10 @@ EXPORT_SYMBOL(of_find_node_opts_by_path);
 
 /**
  *	of_find_node_by_name - Find a node by its "name" property
- *	@from:	The node to start searching from or NULL, the node
+ *	@from:	The node to start searching from or NULL; the node
  *		you pass will not be searched, only the next one
- *		will; typically, you pass what the previous call
- *		returned. of_node_put() will be called on it
+ *		will. Typically, you pass what the previous call
+ *		returned. of_node_put() will be called on @from.
  *	@name:	The name string to match against
  *
  *	Returns a node pointer with refcount incremented, use

commit 37cb8e1f8e10c6e9bd2a1b95cdda0620a21b0551
Merge: 6a77d86655a1 aa25e446ce76
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 14 18:25:40 2017 -0800

    Merge tag 'devicetree-for-4.15' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull DeviceTree updates from Rob Herring:
     "A bigger diffstat than usual with the kbuild changes and a tree wide
      fix in the binding documentation.
    
      Summary:
    
       - kbuild cleanups and improvements for dtbs
    
       - Code clean-up of overlay code and fixing for some long standing
         memory leak and race condition in applying overlays
    
       - Improvements to DT memory usage making sysfs/kobjects optional and
         skipping unflattening of disabled nodes. This is part of kernel
         tinification efforts.
    
       - Final piece of removing storing the full path for every DT node.
         The prerequisite conversion of printk's to use device_node format
         specifier happened in 4.14.
    
       - Sync with current upstream dtc. This brings additional checks to
         dtb compiling.
    
       - Binding doc tree wide removal of leading 0s from examples
    
       - RTC binding documentation adding missing devices and some
         consolidation of duplicated bindings
    
       - Vendor prefix documentation for nutsboard, Silicon Storage
         Technology, shimafuji, Tecon Microprocessor Technologies, DH
         electronics GmbH, Opal Kelly, and Next Thing"
    
    * tag 'devicetree-for-4.15' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (55 commits)
      dt-bindings: usb: add #phy-cells to usb-nop-xceiv
      dt-bindings: Remove leading zeros from bindings notation
      kbuild: handle dtb-y and CONFIG_OF_ALL_DTBS natively in Makefile.lib
      MIPS: dts: remove bogus bcm96358nb4ser.dtb from dtb-y entry
      kbuild: clean up *.dtb and *.dtb.S patterns from top-level Makefile
      .gitignore: move *.dtb and *.dtb.S patterns to the top-level .gitignore
      .gitignore: sort normal pattern rules alphabetically
      dt-bindings: add vendor prefix for Next Thing Co.
      scripts/dtc: Update to upstream version v1.4.5-6-gc1e55a5513e9
      of: dynamic: fix memory leak related to properties of __of_node_dup
      of: overlay: make pr_err() string unique
      of: overlay: pr_err from return NOTIFY_OK to overlay apply/remove
      of: overlay: remove unneeded check for NULL kbasename()
      of: overlay: remove a dependency on device node full_name
      of: overlay: simplify applying symbols from an overlay
      of: overlay: avoid race condition between applying multiple overlays
      of: overlay: loosen overly strict phandle clash check
      of: overlay: expand check of whether overlay changeset can be removed
      of: overlay: detect cases where device tree may become corrupt
      of: overlay: minor restructuring
      ...

commit e0a58f3e08d4b7fa8e2a4075c522f1a98c9e4cab
Author: Frank Rowand <frank.rowand@sony.com>
Date:   Tue Oct 17 16:36:31 2017 -0700

    of: overlay: remove a dependency on device node full_name
    
    The "%pOF" printf format was recently added to print the
    full name of a device tree node, with the intent of changing
    the node full_name field to contain only the node name instead
    of the full path of the node.
    
    dup_and_fixup_symbol_prop() duplicates a property from the
    "/__symbols__" node of an overlay device tree.  The value
    of each duplicated property must be fixed up to include
    the full path of a node in the live device tree.  The
    current code uses the node's full_name for that purpose.
    Update the code to use the "%pOF" printf format to
    determine the node's full path.
    
    Signed-off-by: Frank Rowand <frank.rowand@sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index b98f3adffbb0..3de07e6e82a0 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -658,7 +658,7 @@ struct device_node *of_get_child_by_name(const struct device_node *node,
 }
 EXPORT_SYMBOL(of_get_child_by_name);
 
-static struct device_node *__of_find_node_by_path(struct device_node *parent,
+struct device_node *__of_find_node_by_path(struct device_node *parent,
 						const char *path)
 {
 	struct device_node *child;

commit b56b5528f5b3c3d47e7c0ca67318c45e980d93f0
Author: Rob Herring <robh@kernel.org>
Date:   Wed Oct 4 14:09:40 2017 -0500

    of: make kobject and bin_attribute support configurable
    
    Having device_nodes be kobjects is only needed if sysfs or OF_DYNAMIC is
    enabled. Otherwise, having a kobject in struct device_node is
    unnecessary bloat in minimal kernel configurations.
    
    Likewise, bin_attribute is only needed in struct property when sysfs is
    enabled, so we can make it configurable too.
    
    Tested-by: Nicolas Pitre <nico@linaro.org>
    Reviewed-by: Frank Rowand <frowand.list@gmail.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 9e9bd17121fb..b98f3adffbb0 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -95,105 +95,6 @@ int __weak of_node_to_nid(struct device_node *np)
 }
 #endif
 
-#ifndef CONFIG_OF_DYNAMIC
-static void of_node_release(struct kobject *kobj)
-{
-	/* Without CONFIG_OF_DYNAMIC, no nodes gets freed */
-}
-#endif /* CONFIG_OF_DYNAMIC */
-
-struct kobj_type of_node_ktype = {
-	.release = of_node_release,
-};
-
-static ssize_t of_node_property_read(struct file *filp, struct kobject *kobj,
-				struct bin_attribute *bin_attr, char *buf,
-				loff_t offset, size_t count)
-{
-	struct property *pp = container_of(bin_attr, struct property, attr);
-	return memory_read_from_buffer(buf, count, &offset, pp->value, pp->length);
-}
-
-/* always return newly allocated name, caller must free after use */
-static const char *safe_name(struct kobject *kobj, const char *orig_name)
-{
-	const char *name = orig_name;
-	struct kernfs_node *kn;
-	int i = 0;
-
-	/* don't be a hero. After 16 tries give up */
-	while (i < 16 && (kn = sysfs_get_dirent(kobj->sd, name))) {
-		sysfs_put(kn);
-		if (name != orig_name)
-			kfree(name);
-		name = kasprintf(GFP_KERNEL, "%s#%i", orig_name, ++i);
-	}
-
-	if (name == orig_name) {
-		name = kstrdup(orig_name, GFP_KERNEL);
-	} else {
-		pr_warn("Duplicate name in %s, renamed to \"%s\"\n",
-			kobject_name(kobj), name);
-	}
-	return name;
-}
-
-int __of_add_property_sysfs(struct device_node *np, struct property *pp)
-{
-	int rc;
-
-	/* Important: Don't leak passwords */
-	bool secure = strncmp(pp->name, "security-", 9) == 0;
-
-	if (!IS_ENABLED(CONFIG_SYSFS))
-		return 0;
-
-	if (!of_kset || !of_node_is_attached(np))
-		return 0;
-
-	sysfs_bin_attr_init(&pp->attr);
-	pp->attr.attr.name = safe_name(&np->kobj, pp->name);
-	pp->attr.attr.mode = secure ? 0400 : 0444;
-	pp->attr.size = secure ? 0 : pp->length;
-	pp->attr.read = of_node_property_read;
-
-	rc = sysfs_create_bin_file(&np->kobj, &pp->attr);
-	WARN(rc, "error adding attribute %s to node %pOF\n", pp->name, np);
-	return rc;
-}
-
-int __of_attach_node_sysfs(struct device_node *np)
-{
-	const char *name;
-	struct kobject *parent;
-	struct property *pp;
-	int rc;
-
-	if (!of_kset)
-		return 0;
-
-	np->kobj.kset = of_kset;
-	if (!np->parent) {
-		/* Nodes without parents are new top level trees */
-		name = safe_name(&of_kset->kobj, "base");
-		parent = NULL;
-	} else {
-		name = safe_name(&np->parent->kobj, kbasename(np->full_name));
-		parent = &np->parent->kobj;
-	}
-	if (!name)
-		return -ENOMEM;
-	rc = kobject_add(&np->kobj, parent, "%s", name);
-	kfree(name);
-	if (rc)
-		return rc;
-
-	for_each_property_of_node(np, pp)
-		__of_add_property_sysfs(np, pp);
-
-	return 0;
-}
-
 void __init of_core_init(void)
 {
 	struct device_node *np;
@@ -1501,22 +1402,6 @@ int __of_remove_property(struct device_node *np, struct property *prop)
 	return 0;
 }
 
-void __of_sysfs_remove_bin_file(struct device_node *np, struct property *prop)
-{
-	sysfs_remove_bin_file(&np->kobj, &prop->attr);
-	kfree(prop->attr.attr.name);
-}
-
-void __of_remove_property_sysfs(struct device_node *np, struct property *prop)
-{
-	if (!IS_ENABLED(CONFIG_SYSFS))
-		return;
-
-	/* at early boot, bail here and defer setup to of_init() */
-	if (of_kset && of_node_is_attached(np))
-		__of_sysfs_remove_bin_file(np, prop);
-}
-
 /**
  * of_remove_property - Remove a property from a node.
  *
@@ -1576,21 +1461,6 @@ int __of_update_property(struct device_node *np, struct property *newprop,
 	return 0;
 }
 
-void __of_update_property_sysfs(struct device_node *np, struct property *newprop,
-		struct property *oldprop)
-{
-	if (!IS_ENABLED(CONFIG_SYSFS))
-		return;
-
-	/* At early boot, bail out and defer setup to of_init() */
-	if (!of_kset)
-		return;
-
-	if (oldprop)
-		__of_sysfs_remove_bin_file(np, oldprop);
-	__of_add_property_sysfs(np, newprop);
-}
-
 /*
  * of_update_property - Update a property in a node, if the property does
  * not exist, add it.

commit bd82bbf38cbe27f2c65660da801900d71bcc5cc8
Author: Rob Herring <robh@kernel.org>
Date:   Thu Oct 5 12:01:46 2017 -0500

    of: fix missing kobject init for !SYSFS && OF_DYNAMIC config
    
    The ref counting is broken for OF_DYNAMIC when sysfs is disabled because
    the kobject initialization is skipped. Only the properties
    add/remove/update should be skipped for !SYSFS config.
    
    Tested-by: Nicolas Pitre <nico@linaro.org>
    Reviewed-by: Frank Rowand <frowand.list@gmail.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 260d33c0f26c..9e9bd17121fb 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -169,9 +169,6 @@ int __of_attach_node_sysfs(struct device_node *np)
 	struct property *pp;
 	int rc;
 
-	if (!IS_ENABLED(CONFIG_SYSFS))
-		return 0;
-
 	if (!of_kset)
 		return 0;
 

commit db179e0d0d1003f10b798e072524be6bcdae5053
Author: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
Date:   Tue Sep 26 15:25:10 2017 +0900

    of: do not leak console options
    
    Do not strdup() console options. It seems that the only reason for
    it to be strdup()-ed was a compilation warning: printk, UART and
    console drivers, for some reason, expect char pointer instead of
    const char pointer. So we can just pass `of_stdout_options', but
    need to cast it to char pointer. A better fix would be to change
    printk, console drivers and UART to accept const char `options';
    but that will take time - there are lots of drivers to update.
    
    The patch also fixes a possible memory leak: add_preferred_console()
    can fail, but we don't kfree() options.
    
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 260d33c0f26c..63897531cd75 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1781,8 +1781,12 @@ bool of_console_check(struct device_node *dn, char *name, int index)
 {
 	if (!dn || dn != of_stdout || console_set_on_cmdline)
 		return false;
-	return !add_preferred_console(name, index,
-				      kstrdup(of_stdout_options, GFP_KERNEL));
+
+	/*
+	 * XXX: cast `options' to char pointer to suppress complication
+	 * warnings: printk, UART and console drivers expect char pointer.
+	 */
+	return !add_preferred_console(name, index, (char *)of_stdout_options);
 }
 EXPORT_SYMBOL_GPL(of_console_check);
 

commit b0d9d92f9ce60cd070a62c136914e6fe9d20d49d
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Sun Jul 23 19:55:48 2017 +0300

    of: base: use of_property_read_string()
    
    of_alias_scan() can use of_property_read_string() -- using the modern DT API
    adds some prop sanity checks as a bonus; it does add couple LoCs but only
    because the original code violated the 80-column limit...
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 830f8d2f3594..260d33c0f26c 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1662,11 +1662,13 @@ void of_alias_scan(void * (*dt_alloc)(u64 size, u64 align))
 
 	if (of_chosen) {
 		/* linux,stdout-path and /aliases/stdout are for legacy compatibility */
-		const char *name = of_get_property(of_chosen, "stdout-path", NULL);
-		if (!name)
-			name = of_get_property(of_chosen, "linux,stdout-path", NULL);
+		const char *name = NULL;
+
+		if (of_property_read_string(of_chosen, "stdout-path", &name))
+			of_property_read_string(of_chosen, "linux,stdout-path",
+						&name);
 		if (IS_ENABLED(CONFIG_PPC) && !name)
-			name = of_get_property(of_aliases, "stdout", NULL);
+			of_property_read_string(of_aliases, "stdout", &name);
 		if (name)
 			of_stdout = of_find_node_opts_by_path(name, &of_stdout_options);
 	}

commit 8832963d89f09e4cef6c1ec62f0082a545baf69d
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Sun Jul 23 19:55:47 2017 +0300

    of: base: use of_property_read_u32()
    
    of_n_{addr|size}_cells() predate of_property_read_u32(), so they have to
    basically open-code it. Using the modern DT API saves several LoCs and also
    adds some prop sanity checks as a bonus...
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 5551ac2a9d4c..830f8d2f3594 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -60,14 +60,13 @@ DEFINE_RAW_SPINLOCK(devtree_lock);
 
 int of_n_addr_cells(struct device_node *np)
 {
-	const __be32 *ip;
+	u32 cells;
 
 	do {
 		if (np->parent)
 			np = np->parent;
-		ip = of_get_property(np, "#address-cells", NULL);
-		if (ip)
-			return be32_to_cpup(ip);
+		if (!of_property_read_u32(np, "#address-cells", &cells))
+			return cells;
 	} while (np->parent);
 	/* No #address-cells property for the root node */
 	return OF_ROOT_NODE_ADDR_CELLS_DEFAULT;
@@ -76,14 +75,13 @@ EXPORT_SYMBOL(of_n_addr_cells);
 
 int of_n_size_cells(struct device_node *np)
 {
-	const __be32 *ip;
+	u32 cells;
 
 	do {
 		if (np->parent)
 			np = np->parent;
-		ip = of_get_property(np, "#size-cells", NULL);
-		if (ip)
-			return be32_to_cpup(ip);
+		if (!of_property_read_u32(np, "#size-cells", &cells))
+			return cells;
 	} while (np->parent);
 	/* No #size-cells property for the root node */
 	return OF_ROOT_NODE_SIZE_CELLS_DEFAULT;

commit 0d638a07d3a1e98a7598eb2812a6236324e4c55f
Author: Rob Herring <robh@kernel.org>
Date:   Thu Jun 1 15:50:55 2017 -0500

    of: Convert to using %pOF instead of full_name
    
    Now that we have a custom printf format specifier, convert users of
    full_name to use %pOF instead. This is preparation to remove storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 686628d1dfa6..5551ac2a9d4c 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -160,7 +160,7 @@ int __of_add_property_sysfs(struct device_node *np, struct property *pp)
 	pp->attr.read = of_node_property_read;
 
 	rc = sysfs_create_bin_file(&np->kobj, &pp->attr);
-	WARN(rc, "error adding attribute %s to node %s\n", pp->name, np->full_name);
+	WARN(rc, "error adding attribute %s to node %pOF\n", pp->name, np);
 	return rc;
 }
 
@@ -1122,7 +1122,7 @@ EXPORT_SYMBOL(of_find_node_by_phandle);
 void of_print_phandle_args(const char *msg, const struct of_phandle_args *args)
 {
 	int i;
-	printk("%s %s", msg, of_node_full_name(args->np));
+	printk("%s %pOF", msg, args->np);
 	for (i = 0; i < args->args_count; i++) {
 		const char delim = i ? ',' : ':';
 
@@ -1184,17 +1184,17 @@ int of_phandle_iterator_next(struct of_phandle_iterator *it)
 
 		if (it->cells_name) {
 			if (!it->node) {
-				pr_err("%s: could not find phandle\n",
-				       it->parent->full_name);
+				pr_err("%pOF: could not find phandle\n",
+				       it->parent);
 				goto err;
 			}
 
 			if (of_property_read_u32(it->node, it->cells_name,
 						 &count)) {
-				pr_err("%s: could not get %s for %s\n",
-				       it->parent->full_name,
+				pr_err("%pOF: could not get %s for %pOF\n",
+				       it->parent,
 				       it->cells_name,
-				       it->node->full_name);
+				       it->node);
 				goto err;
 			}
 		} else {
@@ -1206,8 +1206,8 @@ int of_phandle_iterator_next(struct of_phandle_iterator *it)
 		 * property data length
 		 */
 		if (it->cur + count > it->list_end) {
-			pr_err("%s: arguments longer than property\n",
-			       it->parent->full_name);
+			pr_err("%pOF: arguments longer than property\n",
+			       it->parent);
 			goto err;
 		}
 	}
@@ -1639,8 +1639,8 @@ static void of_alias_add(struct alias_prop *ap, struct device_node *np,
 	strncpy(ap->stem, stem, stem_len);
 	ap->stem[stem_len] = 0;
 	list_add_tail(&ap->link, &aliases_lookup);
-	pr_debug("adding DT alias:%s: stem=%s id=%i node=%s\n",
-		 ap->alias, ap->stem, ap->id, of_node_full_name(np));
+	pr_debug("adding DT alias:%s: stem=%s id=%i node=%pOF\n",
+		 ap->alias, ap->stem, ap->id, np);
 }
 
 /**

commit a4485b545e2fad4d65732cb7c60089bf4246de5c
Merge: 5e1743c0af9d b8ba92b101e8
Author: Rob Herring <robh@kernel.org>
Date:   Wed Jul 5 08:31:52 2017 -0500

    Merge branch 'dt/property-move' into dt/next

commit b8ba92b101e82b82a5359dc2dfbd772eb46780d4
Merge: d20dc1493db4 ac1e6958d3be
Author: Rob Herring <robh@kernel.org>
Date:   Wed Jul 5 08:24:05 2017 -0500

    Merge branch 'topic/of-graph-base' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound into dt/property-move
    
    OF graph changes for ALSA conflict with the move of graph functions into
    property.c.

commit 27497e11b56a072dfd80e9f1f229049b2921a1a6
Author: Rob Herring <robh@kernel.org>
Date:   Fri Jun 2 12:43:18 2017 -0500

    of: find_node_by_full_name rewrite to compare each level
    
    find_node_by_full_name() does the same thing as of_find_node_by_path(),
    but takes no locks and doesn't work on aliases. Refactor
    of_find_node_opts_by_path() into __of_find_node_by_full_path() and
    replace find_node_by_full_name() with it.
    
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 74b0a27dab9f..87b4968f3d8f 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -780,6 +780,24 @@ static struct device_node *__of_find_node_by_path(struct device_node *parent,
 	return NULL;
 }
 
+struct device_node *__of_find_node_by_full_path(struct device_node *node,
+						const char *path)
+{
+	const char *separator = strchr(path, ':');
+
+	while (node && *path == '/') {
+		struct device_node *tmp = node;
+
+		path++; /* Increment past '/' delimiter */
+		node = __of_find_node_by_path(node, path);
+		of_node_put(tmp);
+		path = strchrnul(path, '/');
+		if (separator && separator < path)
+			break;
+	}
+	return node;
+}
+
 /**
  *	of_find_node_opts_by_path - Find a node matching a full OF path
  *	@path: Either the full path to match, or if the path does not
@@ -839,16 +857,7 @@ struct device_node *of_find_node_opts_by_path(const char *path, const char **opt
 	raw_spin_lock_irqsave(&devtree_lock, flags);
 	if (!np)
 		np = of_node_get(of_root);
-	while (np && *path == '/') {
-		struct device_node *tmp = np;
-
-		path++; /* Increment past '/' delimiter */
-		np = __of_find_node_by_path(np, path);
-		of_node_put(tmp);
-		path = strchrnul(path, '/');
-		if (separator && separator < path)
-			break;
-	}
+	np = __of_find_node_by_full_path(np, path);
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 	return np;
 }

commit 95e6b1fa3311c8a7b151d38540695409048d1495
Author: Rob Herring <robh@kernel.org>
Date:   Thu Jun 1 18:00:00 2017 -0500

    of: use kbasename instead of open coding
    
    Several places in DT code open code the equivalent of kbasename.
    Replace them.
    
    The behavior for root nodes in node_name_cmp will be slightly different.
    Instead of comparing "/", "" will be compared. The comparison will be
    the same.
    
    Reviewed-by: Andy Shevchenko <andy.shevhchenko@gmail.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 974d51269a02..74b0a27dab9f 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -773,10 +773,7 @@ static struct device_node *__of_find_node_by_path(struct device_node *parent,
 		return NULL;
 
 	__for_each_child_of_node(parent, child) {
-		const char *name = strrchr(child->full_name, '/');
-		if (WARN(!name, "malformed device_node %s\n", child->full_name))
-			continue;
-		name++;
+		const char *name = kbasename(child->full_name);
 		if (strncmp(path, name, len) == 0 && (strlen(name) == len))
 			return child;
 	}

commit 7ace5f4806e895b2227f3ebb00d1fe24f60596c4
Author: Frank Rowand <frank.rowand@sony.com>
Date:   Wed Jun 21 12:20:03 2017 -0700

    of: be consistent in form of file mode
    
    checkpatch whined about using S_IRUGO instead of octal equivalent
    when adding phandle sysfs code, so used octal in that pending patch.
    Change other instances of the S_* constants in the same file to
    the octal form.
    
    Signed-off-by: Frank Rowand <frank.rowand@sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 28d5f53bc631..974d51269a02 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -155,7 +155,7 @@ int __of_add_property_sysfs(struct device_node *np, struct property *pp)
 
 	sysfs_bin_attr_init(&pp->attr);
 	pp->attr.attr.name = safe_name(&np->kobj, pp->name);
-	pp->attr.attr.mode = secure ? S_IRUSR : S_IRUGO;
+	pp->attr.attr.mode = secure ? 0400 : 0444;
 	pp->attr.size = secure ? 0 : pp->length;
 	pp->attr.read = of_node_property_read;
 

commit 1df09bc66f9bc146732628f8426787f35ab1804b
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Wed May 24 17:53:53 2017 +0300

    of: Move OF property and graph API from base.c to property.c
    
    base.c contains both core OF functions and increasingly other
    functionality such as accessing properties and graphs, including
    convenience functions. In the near future this would also include OF
    specific implementation of the fwnode property and graph APIs.
    
    Create driver/of/property.c to contain procedures for accessing and
    interpreting device tree properties. The procedures are moved from
    drivers/of/base.c, with no changes other than copying only the includes
    required by the moved procedures.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 28d5f53bc631..9f70464772a3 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1113,458 +1113,6 @@ struct device_node *of_find_node_by_phandle(phandle handle)
 }
 EXPORT_SYMBOL(of_find_node_by_phandle);
 
-/**
- * of_property_count_elems_of_size - Count the number of elements in a property
- *
- * @np:		device node from which the property value is to be read.
- * @propname:	name of the property to be searched.
- * @elem_size:	size of the individual element
- *
- * Search for a property in a device node and count the number of elements of
- * size elem_size in it. Returns number of elements on sucess, -EINVAL if the
- * property does not exist or its length does not match a multiple of elem_size
- * and -ENODATA if the property does not have a value.
- */
-int of_property_count_elems_of_size(const struct device_node *np,
-				const char *propname, int elem_size)
-{
-	struct property *prop = of_find_property(np, propname, NULL);
-
-	if (!prop)
-		return -EINVAL;
-	if (!prop->value)
-		return -ENODATA;
-
-	if (prop->length % elem_size != 0) {
-		pr_err("size of %s in node %s is not a multiple of %d\n",
-		       propname, np->full_name, elem_size);
-		return -EINVAL;
-	}
-
-	return prop->length / elem_size;
-}
-EXPORT_SYMBOL_GPL(of_property_count_elems_of_size);
-
-/**
- * of_find_property_value_of_size
- *
- * @np:		device node from which the property value is to be read.
- * @propname:	name of the property to be searched.
- * @min:	minimum allowed length of property value
- * @max:	maximum allowed length of property value (0 means unlimited)
- * @len:	if !=NULL, actual length is written to here
- *
- * Search for a property in a device node and valid the requested size.
- * Returns the property value on success, -EINVAL if the property does not
- *  exist, -ENODATA if property does not have a value, and -EOVERFLOW if the
- * property data is too small or too large.
- *
- */
-static void *of_find_property_value_of_size(const struct device_node *np,
-			const char *propname, u32 min, u32 max, size_t *len)
-{
-	struct property *prop = of_find_property(np, propname, NULL);
-
-	if (!prop)
-		return ERR_PTR(-EINVAL);
-	if (!prop->value)
-		return ERR_PTR(-ENODATA);
-	if (prop->length < min)
-		return ERR_PTR(-EOVERFLOW);
-	if (max && prop->length > max)
-		return ERR_PTR(-EOVERFLOW);
-
-	if (len)
-		*len = prop->length;
-
-	return prop->value;
-}
-
-/**
- * of_property_read_u32_index - Find and read a u32 from a multi-value property.
- *
- * @np:		device node from which the property value is to be read.
- * @propname:	name of the property to be searched.
- * @index:	index of the u32 in the list of values
- * @out_value:	pointer to return value, modified only if no error.
- *
- * Search for a property in a device node and read nth 32-bit value from
- * it. Returns 0 on success, -EINVAL if the property does not exist,
- * -ENODATA if property does not have a value, and -EOVERFLOW if the
- * property data isn't large enough.
- *
- * The out_value is modified only if a valid u32 value can be decoded.
- */
-int of_property_read_u32_index(const struct device_node *np,
-				       const char *propname,
-				       u32 index, u32 *out_value)
-{
-	const u32 *val = of_find_property_value_of_size(np, propname,
-					((index + 1) * sizeof(*out_value)),
-					0,
-					NULL);
-
-	if (IS_ERR(val))
-		return PTR_ERR(val);
-
-	*out_value = be32_to_cpup(((__be32 *)val) + index);
-	return 0;
-}
-EXPORT_SYMBOL_GPL(of_property_read_u32_index);
-
-/**
- * of_property_read_u64_index - Find and read a u64 from a multi-value property.
- *
- * @np:		device node from which the property value is to be read.
- * @propname:	name of the property to be searched.
- * @index:	index of the u64 in the list of values
- * @out_value:	pointer to return value, modified only if no error.
- *
- * Search for a property in a device node and read nth 64-bit value from
- * it. Returns 0 on success, -EINVAL if the property does not exist,
- * -ENODATA if property does not have a value, and -EOVERFLOW if the
- * property data isn't large enough.
- *
- * The out_value is modified only if a valid u64 value can be decoded.
- */
-int of_property_read_u64_index(const struct device_node *np,
-				       const char *propname,
-				       u32 index, u64 *out_value)
-{
-	const u64 *val = of_find_property_value_of_size(np, propname,
-					((index + 1) * sizeof(*out_value)),
-					0, NULL);
-
-	if (IS_ERR(val))
-		return PTR_ERR(val);
-
-	*out_value = be64_to_cpup(((__be64 *)val) + index);
-	return 0;
-}
-EXPORT_SYMBOL_GPL(of_property_read_u64_index);
-
-/**
- * of_property_read_variable_u8_array - Find and read an array of u8 from a
- * property, with bounds on the minimum and maximum array size.
- *
- * @np:		device node from which the property value is to be read.
- * @propname:	name of the property to be searched.
- * @out_values:	pointer to return value, modified only if return value is 0.
- * @sz_min:	minimum number of array elements to read
- * @sz_max:	maximum number of array elements to read, if zero there is no
- *		upper limit on the number of elements in the dts entry but only
- *		sz_min will be read.
- *
- * Search for a property in a device node and read 8-bit value(s) from
- * it. Returns number of elements read on success, -EINVAL if the property
- * does not exist, -ENODATA if property does not have a value, and -EOVERFLOW
- * if the property data is smaller than sz_min or longer than sz_max.
- *
- * dts entry of array should be like:
- *	property = /bits/ 8 <0x50 0x60 0x70>;
- *
- * The out_values is modified only if a valid u8 value can be decoded.
- */
-int of_property_read_variable_u8_array(const struct device_node *np,
-					const char *propname, u8 *out_values,
-					size_t sz_min, size_t sz_max)
-{
-	size_t sz, count;
-	const u8 *val = of_find_property_value_of_size(np, propname,
-						(sz_min * sizeof(*out_values)),
-						(sz_max * sizeof(*out_values)),
-						&sz);
-
-	if (IS_ERR(val))
-		return PTR_ERR(val);
-
-	if (!sz_max)
-		sz = sz_min;
-	else
-		sz /= sizeof(*out_values);
-
-	count = sz;
-	while (count--)
-		*out_values++ = *val++;
-
-	return sz;
-}
-EXPORT_SYMBOL_GPL(of_property_read_variable_u8_array);
-
-/**
- * of_property_read_variable_u16_array - Find and read an array of u16 from a
- * property, with bounds on the minimum and maximum array size.
- *
- * @np:		device node from which the property value is to be read.
- * @propname:	name of the property to be searched.
- * @out_values:	pointer to return value, modified only if return value is 0.
- * @sz_min:	minimum number of array elements to read
- * @sz_max:	maximum number of array elements to read, if zero there is no
- *		upper limit on the number of elements in the dts entry but only
- *		sz_min will be read.
- *
- * Search for a property in a device node and read 16-bit value(s) from
- * it. Returns number of elements read on success, -EINVAL if the property
- * does not exist, -ENODATA if property does not have a value, and -EOVERFLOW
- * if the property data is smaller than sz_min or longer than sz_max.
- *
- * dts entry of array should be like:
- *	property = /bits/ 16 <0x5000 0x6000 0x7000>;
- *
- * The out_values is modified only if a valid u16 value can be decoded.
- */
-int of_property_read_variable_u16_array(const struct device_node *np,
-					const char *propname, u16 *out_values,
-					size_t sz_min, size_t sz_max)
-{
-	size_t sz, count;
-	const __be16 *val = of_find_property_value_of_size(np, propname,
-						(sz_min * sizeof(*out_values)),
-						(sz_max * sizeof(*out_values)),
-						&sz);
-
-	if (IS_ERR(val))
-		return PTR_ERR(val);
-
-	if (!sz_max)
-		sz = sz_min;
-	else
-		sz /= sizeof(*out_values);
-
-	count = sz;
-	while (count--)
-		*out_values++ = be16_to_cpup(val++);
-
-	return sz;
-}
-EXPORT_SYMBOL_GPL(of_property_read_variable_u16_array);
-
-/**
- * of_property_read_variable_u32_array - Find and read an array of 32 bit
- * integers from a property, with bounds on the minimum and maximum array size.
- *
- * @np:		device node from which the property value is to be read.
- * @propname:	name of the property to be searched.
- * @out_values:	pointer to return value, modified only if return value is 0.
- * @sz_min:	minimum number of array elements to read
- * @sz_max:	maximum number of array elements to read, if zero there is no
- *		upper limit on the number of elements in the dts entry but only
- *		sz_min will be read.
- *
- * Search for a property in a device node and read 32-bit value(s) from
- * it. Returns number of elements read on success, -EINVAL if the property
- * does not exist, -ENODATA if property does not have a value, and -EOVERFLOW
- * if the property data is smaller than sz_min or longer than sz_max.
- *
- * The out_values is modified only if a valid u32 value can be decoded.
- */
-int of_property_read_variable_u32_array(const struct device_node *np,
-			       const char *propname, u32 *out_values,
-			       size_t sz_min, size_t sz_max)
-{
-	size_t sz, count;
-	const __be32 *val = of_find_property_value_of_size(np, propname,
-						(sz_min * sizeof(*out_values)),
-						(sz_max * sizeof(*out_values)),
-						&sz);
-
-	if (IS_ERR(val))
-		return PTR_ERR(val);
-
-	if (!sz_max)
-		sz = sz_min;
-	else
-		sz /= sizeof(*out_values);
-
-	count = sz;
-	while (count--)
-		*out_values++ = be32_to_cpup(val++);
-
-	return sz;
-}
-EXPORT_SYMBOL_GPL(of_property_read_variable_u32_array);
-
-/**
- * of_property_read_u64 - Find and read a 64 bit integer from a property
- * @np:		device node from which the property value is to be read.
- * @propname:	name of the property to be searched.
- * @out_value:	pointer to return value, modified only if return value is 0.
- *
- * Search for a property in a device node and read a 64-bit value from
- * it. Returns 0 on success, -EINVAL if the property does not exist,
- * -ENODATA if property does not have a value, and -EOVERFLOW if the
- * property data isn't large enough.
- *
- * The out_value is modified only if a valid u64 value can be decoded.
- */
-int of_property_read_u64(const struct device_node *np, const char *propname,
-			 u64 *out_value)
-{
-	const __be32 *val = of_find_property_value_of_size(np, propname,
-						sizeof(*out_value),
-						0,
-						NULL);
-
-	if (IS_ERR(val))
-		return PTR_ERR(val);
-
-	*out_value = of_read_number(val, 2);
-	return 0;
-}
-EXPORT_SYMBOL_GPL(of_property_read_u64);
-
-/**
- * of_property_read_variable_u64_array - Find and read an array of 64 bit
- * integers from a property, with bounds on the minimum and maximum array size.
- *
- * @np:		device node from which the property value is to be read.
- * @propname:	name of the property to be searched.
- * @out_values:	pointer to return value, modified only if return value is 0.
- * @sz_min:	minimum number of array elements to read
- * @sz_max:	maximum number of array elements to read, if zero there is no
- *		upper limit on the number of elements in the dts entry but only
- *		sz_min will be read.
- *
- * Search for a property in a device node and read 64-bit value(s) from
- * it. Returns number of elements read on success, -EINVAL if the property
- * does not exist, -ENODATA if property does not have a value, and -EOVERFLOW
- * if the property data is smaller than sz_min or longer than sz_max.
- *
- * The out_values is modified only if a valid u64 value can be decoded.
- */
-int of_property_read_variable_u64_array(const struct device_node *np,
-			       const char *propname, u64 *out_values,
-			       size_t sz_min, size_t sz_max)
-{
-	size_t sz, count;
-	const __be32 *val = of_find_property_value_of_size(np, propname,
-						(sz_min * sizeof(*out_values)),
-						(sz_max * sizeof(*out_values)),
-						&sz);
-
-	if (IS_ERR(val))
-		return PTR_ERR(val);
-
-	if (!sz_max)
-		sz = sz_min;
-	else
-		sz /= sizeof(*out_values);
-
-	count = sz;
-	while (count--) {
-		*out_values++ = of_read_number(val, 2);
-		val += 2;
-	}
-
-	return sz;
-}
-EXPORT_SYMBOL_GPL(of_property_read_variable_u64_array);
-
-/**
- * of_property_read_string - Find and read a string from a property
- * @np:		device node from which the property value is to be read.
- * @propname:	name of the property to be searched.
- * @out_string:	pointer to null terminated return string, modified only if
- *		return value is 0.
- *
- * Search for a property in a device tree node and retrieve a null
- * terminated string value (pointer to data, not a copy). Returns 0 on
- * success, -EINVAL if the property does not exist, -ENODATA if property
- * does not have a value, and -EILSEQ if the string is not null-terminated
- * within the length of the property data.
- *
- * The out_string pointer is modified only if a valid string can be decoded.
- */
-int of_property_read_string(const struct device_node *np, const char *propname,
-				const char **out_string)
-{
-	const struct property *prop = of_find_property(np, propname, NULL);
-	if (!prop)
-		return -EINVAL;
-	if (!prop->value)
-		return -ENODATA;
-	if (strnlen(prop->value, prop->length) >= prop->length)
-		return -EILSEQ;
-	*out_string = prop->value;
-	return 0;
-}
-EXPORT_SYMBOL_GPL(of_property_read_string);
-
-/**
- * of_property_match_string() - Find string in a list and return index
- * @np: pointer to node containing string list property
- * @propname: string list property name
- * @string: pointer to string to search for in string list
- *
- * This function searches a string list property and returns the index
- * of a specific string value.
- */
-int of_property_match_string(const struct device_node *np, const char *propname,
-			     const char *string)
-{
-	const struct property *prop = of_find_property(np, propname, NULL);
-	size_t l;
-	int i;
-	const char *p, *end;
-
-	if (!prop)
-		return -EINVAL;
-	if (!prop->value)
-		return -ENODATA;
-
-	p = prop->value;
-	end = p + prop->length;
-
-	for (i = 0; p < end; i++, p += l) {
-		l = strnlen(p, end - p) + 1;
-		if (p + l > end)
-			return -EILSEQ;
-		pr_debug("comparing %s with %s\n", string, p);
-		if (strcmp(string, p) == 0)
-			return i; /* Found it; return index */
-	}
-	return -ENODATA;
-}
-EXPORT_SYMBOL_GPL(of_property_match_string);
-
-/**
- * of_property_read_string_helper() - Utility helper for parsing string properties
- * @np:		device node from which the property value is to be read.
- * @propname:	name of the property to be searched.
- * @out_strs:	output array of string pointers.
- * @sz:		number of array elements to read.
- * @skip:	Number of strings to skip over at beginning of list.
- *
- * Don't call this function directly. It is a utility helper for the
- * of_property_read_string*() family of functions.
- */
-int of_property_read_string_helper(const struct device_node *np,
-				   const char *propname, const char **out_strs,
-				   size_t sz, int skip)
-{
-	const struct property *prop = of_find_property(np, propname, NULL);
-	int l = 0, i = 0;
-	const char *p, *end;
-
-	if (!prop)
-		return -EINVAL;
-	if (!prop->value)
-		return -ENODATA;
-	p = prop->value;
-	end = p + prop->length;
-
-	for (i = 0; p < end && (!out_strs || i < skip + sz); i++, p += l) {
-		l = strnlen(p, end - p) + 1;
-		if (p + l > end)
-			return -EILSEQ;
-		if (out_strs && i >= skip)
-			*out_strs++ = p;
-	}
-	i -= skip;
-	return i <= 0 ? -ENODATA : i;
-}
-EXPORT_SYMBOL_GPL(of_property_read_string_helper);
-
 void of_print_phandle_args(const char *msg, const struct of_phandle_args *args)
 {
 	int i;
@@ -2211,47 +1759,6 @@ int of_alias_get_highest_id(const char *stem)
 }
 EXPORT_SYMBOL_GPL(of_alias_get_highest_id);
 
-const __be32 *of_prop_next_u32(struct property *prop, const __be32 *cur,
-			       u32 *pu)
-{
-	const void *curv = cur;
-
-	if (!prop)
-		return NULL;
-
-	if (!cur) {
-		curv = prop->value;
-		goto out_val;
-	}
-
-	curv += sizeof(*cur);
-	if (curv >= prop->value + prop->length)
-		return NULL;
-
-out_val:
-	*pu = be32_to_cpup(curv);
-	return curv;
-}
-EXPORT_SYMBOL_GPL(of_prop_next_u32);
-
-const char *of_prop_next_string(struct property *prop, const char *cur)
-{
-	const void *curv = cur;
-
-	if (!prop)
-		return NULL;
-
-	if (!cur)
-		return prop->value;
-
-	curv += strlen(cur) + 1;
-	if (curv >= prop->value + prop->length)
-		return NULL;
-
-	return curv;
-}
-EXPORT_SYMBOL_GPL(of_prop_next_string);
-
 /**
  * of_console_check() - Test and setup console for DT setup
  * @dn - Pointer to device node
@@ -2325,243 +1832,3 @@ int of_find_last_cache_level(unsigned int cpu)
 
 	return cache_level;
 }
-
-/**
- * of_graph_parse_endpoint() - parse common endpoint node properties
- * @node: pointer to endpoint device_node
- * @endpoint: pointer to the OF endpoint data structure
- *
- * The caller should hold a reference to @node.
- */
-int of_graph_parse_endpoint(const struct device_node *node,
-			    struct of_endpoint *endpoint)
-{
-	struct device_node *port_node = of_get_parent(node);
-
-	WARN_ONCE(!port_node, "%s(): endpoint %s has no parent node\n",
-		  __func__, node->full_name);
-
-	memset(endpoint, 0, sizeof(*endpoint));
-
-	endpoint->local_node = node;
-	/*
-	 * It doesn't matter whether the two calls below succeed.
-	 * If they don't then the default value 0 is used.
-	 */
-	of_property_read_u32(port_node, "reg", &endpoint->port);
-	of_property_read_u32(node, "reg", &endpoint->id);
-
-	of_node_put(port_node);
-
-	return 0;
-}
-EXPORT_SYMBOL(of_graph_parse_endpoint);
-
-/**
- * of_graph_get_port_by_id() - get the port matching a given id
- * @parent: pointer to the parent device node
- * @id: id of the port
- *
- * Return: A 'port' node pointer with refcount incremented. The caller
- * has to use of_node_put() on it when done.
- */
-struct device_node *of_graph_get_port_by_id(struct device_node *parent, u32 id)
-{
-	struct device_node *node, *port;
-
-	node = of_get_child_by_name(parent, "ports");
-	if (node)
-		parent = node;
-
-	for_each_child_of_node(parent, port) {
-		u32 port_id = 0;
-
-		if (of_node_cmp(port->name, "port") != 0)
-			continue;
-		of_property_read_u32(port, "reg", &port_id);
-		if (id == port_id)
-			break;
-	}
-
-	of_node_put(node);
-
-	return port;
-}
-EXPORT_SYMBOL(of_graph_get_port_by_id);
-
-/**
- * of_graph_get_next_endpoint() - get next endpoint node
- * @parent: pointer to the parent device node
- * @prev: previous endpoint node, or NULL to get first
- *
- * Return: An 'endpoint' node pointer with refcount incremented. Refcount
- * of the passed @prev node is decremented.
- */
-struct device_node *of_graph_get_next_endpoint(const struct device_node *parent,
-					struct device_node *prev)
-{
-	struct device_node *endpoint;
-	struct device_node *port;
-
-	if (!parent)
-		return NULL;
-
-	/*
-	 * Start by locating the port node. If no previous endpoint is specified
-	 * search for the first port node, otherwise get the previous endpoint
-	 * parent port node.
-	 */
-	if (!prev) {
-		struct device_node *node;
-
-		node = of_get_child_by_name(parent, "ports");
-		if (node)
-			parent = node;
-
-		port = of_get_child_by_name(parent, "port");
-		of_node_put(node);
-
-		if (!port) {
-			pr_err("graph: no port node found in %s\n",
-			       parent->full_name);
-			return NULL;
-		}
-	} else {
-		port = of_get_parent(prev);
-		if (WARN_ONCE(!port, "%s(): endpoint %s has no parent node\n",
-			      __func__, prev->full_name))
-			return NULL;
-	}
-
-	while (1) {
-		/*
-		 * Now that we have a port node, get the next endpoint by
-		 * getting the next child. If the previous endpoint is NULL this
-		 * will return the first child.
-		 */
-		endpoint = of_get_next_child(port, prev);
-		if (endpoint) {
-			of_node_put(port);
-			return endpoint;
-		}
-
-		/* No more endpoints under this port, try the next one. */
-		prev = NULL;
-
-		do {
-			port = of_get_next_child(parent, port);
-			if (!port)
-				return NULL;
-		} while (of_node_cmp(port->name, "port"));
-	}
-}
-EXPORT_SYMBOL(of_graph_get_next_endpoint);
-
-/**
- * of_graph_get_endpoint_by_regs() - get endpoint node of specific identifiers
- * @parent: pointer to the parent device node
- * @port_reg: identifier (value of reg property) of the parent port node
- * @reg: identifier (value of reg property) of the endpoint node
- *
- * Return: An 'endpoint' node pointer which is identified by reg and at the same
- * is the child of a port node identified by port_reg. reg and port_reg are
- * ignored when they are -1.
- */
-struct device_node *of_graph_get_endpoint_by_regs(
-	const struct device_node *parent, int port_reg, int reg)
-{
-	struct of_endpoint endpoint;
-	struct device_node *node = NULL;
-
-	for_each_endpoint_of_node(parent, node) {
-		of_graph_parse_endpoint(node, &endpoint);
-		if (((port_reg == -1) || (endpoint.port == port_reg)) &&
-			((reg == -1) || (endpoint.id == reg)))
-			return node;
-	}
-
-	return NULL;
-}
-EXPORT_SYMBOL(of_graph_get_endpoint_by_regs);
-
-/**
- * of_graph_get_remote_port_parent() - get remote port's parent node
- * @node: pointer to a local endpoint device_node
- *
- * Return: Remote device node associated with remote endpoint node linked
- *	   to @node. Use of_node_put() on it when done.
- */
-struct device_node *of_graph_get_remote_port_parent(
-			       const struct device_node *node)
-{
-	struct device_node *np;
-	unsigned int depth;
-
-	/* Get remote endpoint node. */
-	np = of_parse_phandle(node, "remote-endpoint", 0);
-
-	/* Walk 3 levels up only if there is 'ports' node. */
-	for (depth = 3; depth && np; depth--) {
-		np = of_get_next_parent(np);
-		if (depth == 2 && of_node_cmp(np->name, "ports"))
-			break;
-	}
-	return np;
-}
-EXPORT_SYMBOL(of_graph_get_remote_port_parent);
-
-/**
- * of_graph_get_remote_port() - get remote port node
- * @node: pointer to a local endpoint device_node
- *
- * Return: Remote port node associated with remote endpoint node linked
- *	   to @node. Use of_node_put() on it when done.
- */
-struct device_node *of_graph_get_remote_port(const struct device_node *node)
-{
-	struct device_node *np;
-
-	/* Get remote endpoint node. */
-	np = of_parse_phandle(node, "remote-endpoint", 0);
-	if (!np)
-		return NULL;
-	return of_get_next_parent(np);
-}
-EXPORT_SYMBOL(of_graph_get_remote_port);
-
-/**
- * of_graph_get_remote_node() - get remote parent device_node for given port/endpoint
- * @node: pointer to parent device_node containing graph port/endpoint
- * @port: identifier (value of reg property) of the parent port node
- * @endpoint: identifier (value of reg property) of the endpoint node
- *
- * Return: Remote device node associated with remote endpoint node linked
- *	   to @node. Use of_node_put() on it when done.
- */
-struct device_node *of_graph_get_remote_node(const struct device_node *node,
-					     u32 port, u32 endpoint)
-{
-	struct device_node *endpoint_node, *remote;
-
-	endpoint_node = of_graph_get_endpoint_by_regs(node, port, endpoint);
-	if (!endpoint_node) {
-		pr_debug("no valid endpoint (%d, %d) for node %s\n",
-			 port, endpoint, node->full_name);
-		return NULL;
-	}
-
-	remote = of_graph_get_remote_port_parent(endpoint_node);
-	of_node_put(endpoint_node);
-	if (!remote) {
-		pr_debug("no valid remote node\n");
-		return NULL;
-	}
-
-	if (!of_device_is_available(remote)) {
-		pr_debug("not available for remote node\n");
-		return NULL;
-	}
-
-	return remote;
-}
-EXPORT_SYMBOL(of_graph_get_remote_node);

commit ac1e6958d3be29a28889b09e4eec1798eccc1606
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Apr 20 01:32:47 2017 +0000

    of_graph: add of_graph_get_endpoint_count()
    
    OF graph want to count its endpoint number, same as
    of_get_child_count(). This patch adds of_graph_get_endpoint_count()
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 4c305599a664..cb1c49ae3b88 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -2559,6 +2559,18 @@ struct device_node *of_graph_get_remote_port(const struct device_node *node)
 }
 EXPORT_SYMBOL(of_graph_get_remote_port);
 
+int of_graph_get_endpoint_count(const struct device_node *np)
+{
+	struct device_node *endpoint;
+	int num = 0;
+
+	for_each_endpoint_of_node(np, endpoint)
+		num++;
+
+	return num;
+}
+EXPORT_SYMBOL(of_graph_get_endpoint_count);
+
 /**
  * of_graph_get_remote_node() - get remote parent device_node for given port/endpoint
  * @node: pointer to parent device_node containing graph port/endpoint

commit 0ef472a973ebbfc20f2f12769e77a8cfd3612778
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Apr 20 01:32:17 2017 +0000

    of_graph: add of_graph_get_port_parent()
    
    Linux kernel already has of_graph_get_remote_port_parent(),
    but, sometimes we want to get own port parent.
    This patch adds of_graph_get_port_parent()
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index b169508a9b56..4c305599a664 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -2500,6 +2500,27 @@ struct device_node *of_graph_get_remote_endpoint(const struct device_node *node)
 }
 EXPORT_SYMBOL(of_graph_get_remote_endpoint);
 
+/**
+ * of_graph_get_port_parent() - get port's parent node
+ * @node: pointer to a local endpoint device_node
+ *
+ * Return: device node associated with endpoint node linked
+ *	   to @node. Use of_node_put() on it when done.
+ */
+struct device_node *of_graph_get_port_parent(struct device_node *node)
+{
+	unsigned int depth;
+
+	/* Walk 3 levels up only if there is 'ports' node. */
+	for (depth = 3; depth && node; depth--) {
+		node = of_get_next_parent(node);
+		if (depth == 2 && of_node_cmp(node->name, "ports"))
+			break;
+	}
+	return node;
+}
+EXPORT_SYMBOL(of_graph_get_port_parent);
+
 /**
  * of_graph_get_remote_port_parent() - get remote port's parent node
  * @node: pointer to a local endpoint device_node
@@ -2511,18 +2532,11 @@ struct device_node *of_graph_get_remote_port_parent(
 			       const struct device_node *node)
 {
 	struct device_node *np;
-	unsigned int depth;
 
 	/* Get remote endpoint node. */
 	np = of_graph_get_remote_endpoint(node);
 
-	/* Walk 3 levels up only if there is 'ports' node. */
-	for (depth = 3; depth && np; depth--) {
-		np = of_get_next_parent(np);
-		if (depth == 2 && of_node_cmp(np->name, "ports"))
-			break;
-	}
-	return np;
+	return of_graph_get_port_parent(np);
 }
 EXPORT_SYMBOL(of_graph_get_remote_port_parent);
 

commit 4c9c3d595f1bad021cc126d20879df4016801736
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Apr 20 01:31:42 2017 +0000

    of_graph: add of_graph_get_remote_endpoint()
    
    It should use same method to get same result.
    To getting remote-endpoint node,
    let's use of_graph_get_remote_endpoint()
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 5db6aa1688e9..b169508a9b56 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -2486,6 +2486,20 @@ struct device_node *of_graph_get_endpoint_by_regs(
 }
 EXPORT_SYMBOL(of_graph_get_endpoint_by_regs);
 
+/**
+ * of_graph_get_remote_endpoint() - get remote endpoint node
+ * @node: pointer to a local endpoint device_node
+ *
+ * Return: Remote endpoint node associated with remote endpoint node linked
+ *	   to @node. Use of_node_put() on it when done.
+ */
+struct device_node *of_graph_get_remote_endpoint(const struct device_node *node)
+{
+	/* Get remote endpoint node. */
+	return of_parse_phandle(node, "remote-endpoint", 0);
+}
+EXPORT_SYMBOL(of_graph_get_remote_endpoint);
+
 /**
  * of_graph_get_remote_port_parent() - get remote port's parent node
  * @node: pointer to a local endpoint device_node
@@ -2500,7 +2514,7 @@ struct device_node *of_graph_get_remote_port_parent(
 	unsigned int depth;
 
 	/* Get remote endpoint node. */
-	np = of_parse_phandle(node, "remote-endpoint", 0);
+	np = of_graph_get_remote_endpoint(node);
 
 	/* Walk 3 levels up only if there is 'ports' node. */
 	for (depth = 3; depth && np; depth--) {
@@ -2524,7 +2538,7 @@ struct device_node *of_graph_get_remote_port(const struct device_node *node)
 	struct device_node *np;
 
 	/* Get remote endpoint node. */
-	np = of_parse_phandle(node, "remote-endpoint", 0);
+	np = of_graph_get_remote_endpoint(node);
 	if (!np)
 		return NULL;
 	return of_get_next_parent(np);

commit 00bab23f72100a5fd8a3030f81d0af07a859ed17
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Apr 20 01:31:16 2017 +0000

    of-graph: export symbol of_phandle_iterator_init/next
    
    of_for_each_phandle() uses of_phandle_iterator_init/next
    but it isn't exported. So kernel module complile will say
    
    ERROR: "of_phandle_iterator_init" [xxx.ko] undefined!
    ERROR: "of_phandle_iterator_next" [xxx.ko] undefined!
    
    This patch solved this issue
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 28d5f53bc631..5db6aa1688e9 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1601,6 +1601,7 @@ int of_phandle_iterator_init(struct of_phandle_iterator *it,
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(of_phandle_iterator_init);
 
 int of_phandle_iterator_next(struct of_phandle_iterator *it)
 {
@@ -1670,6 +1671,7 @@ int of_phandle_iterator_next(struct of_phandle_iterator *it)
 
 	return -EINVAL;
 }
+EXPORT_SYMBOL_GPL(of_phandle_iterator_next);
 
 int of_phandle_iterator_args(struct of_phandle_iterator *it,
 			     uint32_t *args,

commit 3ef2bc099d1cce09e2844467e2ced98e1a44609d
Merge: 2eecf3a49f1f 17a70355ea57
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 5 19:33:07 2017 -0700

    Merge tag 'devicetree-for-4.12' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull DeviceTree updates from Rob Herring:
    
     - fix sparse warnings in drivers/of/
    
     - add more overlay unittests
    
     - update dtc to v1.4.4-8-g756ffc4f52f6. This adds more checks on dts
       files such as unit-address formatting and stricter character sets for
       node and property names
    
     - add a common DT modalias function
    
     - move trivial-devices.txt up and out of i2c dir
    
     - ARM NVIC interrupt controller binding
    
     - vendor prefixes for Sensirion, Dioo, Nordic, ROHM
    
     - correct some binding file locations
    
    * tag 'devicetree-for-4.12' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (24 commits)
      of: fix sparse warnings in fdt, irq, reserved mem, and resolver code
      of: fix sparse warning in of_pci_range_parser_one
      of: fix sparse warnings in of_find_next_cache_node
      of/unittest: Missing unlocks on error
      of: fix uninitialized variable warning for overlay test
      of: fix unittest build without CONFIG_OF_OVERLAY
      of: Add unit tests for applying overlays
      of: per-file dtc compiler flags
      fpga: region: add missing DT documentation for config complete timeout
      of: Add vendor prefix for ROHM Semiconductor
      of: fix "/cpus" reference leak in of_numa_parse_cpu_nodes()
      of: Add vendor prefix for Nordic Semiconductor
      dt-bindings: arm,nvic: Binding for ARM NVIC interrupt controller on Cortex-M
      dtc: update warning settings for new bus and node/property name checks
      scripts/dtc: Update to upstream version v1.4.4-8-g756ffc4f52f6
      scripts/dtc: automate getting dtc version and log in update script
      of: Add function for generating a DT modalias with a newline
      of: fix of_device_get_modalias returned length when truncating buffers
      Documentation: devicetree: move trivial-devices out of I2C realm
      dt-bindings: add vendor prefix for Dioo
      ..

commit 91d967497f11dbb5038c7b84bc30dae684ae5ffb
Author: Rob Herring <robh@kernel.org>
Date:   Thu May 4 12:30:07 2017 -0500

    of: fix sparse warnings in of_find_next_cache_node
    
    sparse gives a warning that 'handle' is not a __be32:
    
    ../drivers/of/base.c:2261:61: warning: incorrect type in argument 1 (different base types)
    ../drivers/of/base.c:2261:61:    expected restricted __be32 const [usertype] *p
    ../drivers/of/base.c:2261:61:    got unsigned int const [usertype] *[assigned] handle
    
    We could just change the type, but the code can be improved by using
    of_parse_phandle instead of open coding it with of_get_property and
    of_find_node_by_phandle.
    
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index d7c4629a3a2d..016f9d77d64d 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -2250,15 +2250,14 @@ EXPORT_SYMBOL_GPL(of_console_check);
  */
 struct device_node *of_find_next_cache_node(const struct device_node *np)
 {
-	struct device_node *child;
-	const phandle *handle;
+	struct device_node *child, *cache_node;
 
-	handle = of_get_property(np, "l2-cache", NULL);
-	if (!handle)
-		handle = of_get_property(np, "next-level-cache", NULL);
+	cache_node = of_parse_phandle(np, "l2-cache", 0);
+	if (!cache_node)
+		cache_node = of_parse_phandle(np, "next-level-cache", 0);
 
-	if (handle)
-		return of_find_node_by_phandle(be32_to_cpup(handle));
+	if (cache_node)
+		return cache_node;
 
 	/* OF on pmac has nodes instead of properties named "l2-cache"
 	 * beneath CPU nodes.

commit 2475a2b6c877a0c8d1ca42c3f2b30f8ce518ac0b
Author: Alistair Popple <alistair@popple.id.au>
Date:   Mon Apr 3 19:51:42 2017 +1000

    drivers/of/base.c: Add of_property_read_u64_index
    
    There is of_property_read_u32_index but no u64 variant. This patch
    adds one similar to the u32 version for u64.
    
    Signed-off-by: Alistair Popple <alistair@popple.id.au>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index d7c4629a3a2d..0ea16bd3c8f1 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1212,6 +1212,37 @@ int of_property_read_u32_index(const struct device_node *np,
 }
 EXPORT_SYMBOL_GPL(of_property_read_u32_index);
 
+/**
+ * of_property_read_u64_index - Find and read a u64 from a multi-value property.
+ *
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ * @index:	index of the u64 in the list of values
+ * @out_value:	pointer to return value, modified only if no error.
+ *
+ * Search for a property in a device node and read nth 64-bit value from
+ * it. Returns 0 on success, -EINVAL if the property does not exist,
+ * -ENODATA if property does not have a value, and -EOVERFLOW if the
+ * property data isn't large enough.
+ *
+ * The out_value is modified only if a valid u64 value can be decoded.
+ */
+int of_property_read_u64_index(const struct device_node *np,
+				       const char *propname,
+				       u32 index, u64 *out_value)
+{
+	const u64 *val = of_find_property_value_of_size(np, propname,
+					((index + 1) * sizeof(*out_value)),
+					0, NULL);
+
+	if (IS_ERR(val))
+		return PTR_ERR(val);
+
+	*out_value = be64_to_cpup(((__be64 *)val) + index);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(of_property_read_u64_index);
+
 /**
  * of_property_read_variable_u8_array - Find and read an array of u8 from a
  * property, with bounds on the minimum and maximum array size.

commit be5165a51d2500ae1afa1236a8b09858831fdf7e
Merge: c1aac62f36c1 4e29ccdb240e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Feb 22 19:23:14 2017 -0800

    Merge tag 'devicetree-for-4.11' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull DeviceTree updates from Rob Herring:
     "Pretty standard stuff with dtc upstream sync being the biggest piece.
    
       - Sync dtc to upstream commit 0931cea3ba20. This picks up overlay
         support in dtc.
    
       - Set dma_ops for reserved memory users.
    
       - Make references to IOMMU consistent in DT bindings.
    
       - Cleanup references to pm_power_off in bindings.
    
       - Move some display bindings that snuck into the old bindings/video/
         path.
    
       - Fix some wrong documentation paths caused from binding
         restructuring.
    
       - Vendor prefixes for Faraday and Fujitsu.
    
       - Fix an of_node ref counting leak in of_find_node_opts_by_path
    
       - Introduce new graph helper of_graph_get_remote_node() which will be
         used by DRM drivers in 4.12"
    
    * tag 'devicetree-for-4.11' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (27 commits)
      DT: add Faraday Tec. as vendor
      of: introduce of_graph_get_remote_node
      of: Add missing space at end of pr_fmt().
      of: make of_device_make_bus_id() static
      of: fix of_node leak caused in of_find_node_opts_by_path
      dt-bindings: net: remove reference to fixed link support
      dt-bindings: power: reset: qnap-poweroff: Drop reference to pm_power_off
      dt-bindings: power: reset: gpio-poweroff: Drop reference to pm_power_off
      dt-bindings: mfd: as3722: Drop reference to pm_power_off
      dt-bindings: display: move ANX7814 and SiI8620 bridge bindings
      of/unittest: Swap arguments of of_unittest_apply_overlay()
      Documentation: usb: fix wrong documentation paths
      serial: fsl-imx-uart.txt: Remove generic property
      devicetree: Add Fujitsu Ltd. vendor prefix
      Documentation: display: fix wrong documentation paths
      of: remove redundant memset in overlay
      bus:qcom : Fix typo in qcom,ebi2.txt
      dt-bindings: qman: Remove pool channel node
      Documentation: panel-dpi: fix path to display-timing.txt
      devicetree: bindings: clk: mvebu: fix description for sata1 on Armada XP
      ...

commit ca78d3173cff3503bcd15723b049757f75762d15
Merge: a4ee7bacd6c0 ffe7afd17135
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Feb 22 10:46:44 2017 -0800

    Merge tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux
    
    Pull arm64 updates from Will Deacon:
     - Errata workarounds for Qualcomm's Falkor CPU
     - Qualcomm L2 Cache PMU driver
     - Qualcomm SMCCC firmware quirk
     - Support for DEBUG_VIRTUAL
     - CPU feature detection for userspace via MRS emulation
     - Preliminary work for the Statistical Profiling Extension
     - Misc cleanups and non-critical fixes
    
    * tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux: (74 commits)
      arm64/kprobes: consistently handle MRS/MSR with XZR
      arm64: cpufeature: correctly handle MRS to XZR
      arm64: traps: correctly handle MRS/MSR with XZR
      arm64: ptrace: add XZR-safe regs accessors
      arm64: include asm/assembler.h in entry-ftrace.S
      arm64: fix warning about swapper_pg_dir overflow
      arm64: Work around Falkor erratum 1003
      arm64: head.S: Enable EL1 (host) access to SPE when entered at EL2
      arm64: arch_timer: document Hisilicon erratum 161010101
      arm64: use is_vmalloc_addr
      arm64: use linux/sizes.h for constants
      arm64: uaccess: consistently check object sizes
      perf: add qcom l2 cache perf events driver
      arm64: remove wrong CONFIG_PROC_SYSCTL ifdef
      ARM: smccc: Update HVC comment to describe new quirk parameter
      arm64: do not trace atomic operations
      ACPI/IORT: Fix the error return code in iort_add_smmu_platform_device()
      ACPI/IORT: Fix iort_node_get_id() mapping entries indexing
      arm64: mm: enable CONFIG_HOLES_IN_ZONE for NUMA
      perf: xgene: Include module.h
      ...

commit b85ad494098bf881c3713218fbd74193e5d5c488
Author: Rob Herring <robh@kernel.org>
Date:   Fri Feb 3 12:39:03 2017 -0600

    of: introduce of_graph_get_remote_node
    
    The OF graph API leaves too much of the graph walking to clients when
    in many cases the driver doesn't care about accessing the port or
    endpoint nodes. The drivers typically just want the device connected via
    a particular graph connection. of_graph_get_remote_node provides this
    functionality.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index ce8206f9f97a..8f2a1dbfe75c 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -2472,3 +2472,40 @@ struct device_node *of_graph_get_remote_port(const struct device_node *node)
 	return of_get_next_parent(np);
 }
 EXPORT_SYMBOL(of_graph_get_remote_port);
+
+/**
+ * of_graph_get_remote_node() - get remote parent device_node for given port/endpoint
+ * @node: pointer to parent device_node containing graph port/endpoint
+ * @port: identifier (value of reg property) of the parent port node
+ * @endpoint: identifier (value of reg property) of the endpoint node
+ *
+ * Return: Remote device node associated with remote endpoint node linked
+ *	   to @node. Use of_node_put() on it when done.
+ */
+struct device_node *of_graph_get_remote_node(const struct device_node *node,
+					     u32 port, u32 endpoint)
+{
+	struct device_node *endpoint_node, *remote;
+
+	endpoint_node = of_graph_get_endpoint_by_regs(node, port, endpoint);
+	if (!endpoint_node) {
+		pr_debug("no valid endpoint (%d, %d) for node %s\n",
+			 port, endpoint, node->full_name);
+		return NULL;
+	}
+
+	remote = of_graph_get_remote_port_parent(endpoint_node);
+	of_node_put(endpoint_node);
+	if (!remote) {
+		pr_debug("no valid remote node\n");
+		return NULL;
+	}
+
+	if (!of_device_is_available(remote)) {
+		pr_debug("not available for remote node\n");
+		return NULL;
+	}
+
+	return remote;
+}
+EXPORT_SYMBOL(of_graph_get_remote_node);

commit 0549bde0fcb11a95773e7dc4121738b9e653abf4
Author: Qi Hou <qi.hou@windriver.com>
Date:   Mon Feb 6 12:55:19 2017 +0800

    of: fix of_node leak caused in of_find_node_opts_by_path
    
    During stepping down the tree, parent node is gotten first and its refcount is
    increased with of_node_get() in __of_get_next_child(). Since it just being used
    as tmp node, its refcount must be decreased with of_node_put() after traversing
    its child nodes.
    
    Or, its refcount will never be descreased to ZERO, then it will never be freed,
    as well as other related memory blocks.
    
    To fix this, decrease refcount of parent with of_node_put() after
    __of_find_node_by_path().
    
    Signed-off-by: Qi Hou <qi.hou@windriver.com>
    Acked-by: Peter Rosin <peda@axentia.se>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index d4bea3c797d6..ce8206f9f97a 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -842,8 +842,11 @@ struct device_node *of_find_node_opts_by_path(const char *path, const char **opt
 	if (!np)
 		np = of_node_get(of_root);
 	while (np && *path == '/') {
+		struct device_node *tmp = np;
+
 		path++; /* Increment past '/' delimiter */
 		np = __of_find_node_by_path(np, path);
+		of_node_put(tmp);
 		path = strchrnul(path, '/');
 		if (separator && separator < path)
 			break;

commit 5fa23530d4fcc7e84be9a557c58d0e670a15c042
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Mon Jan 16 10:40:43 2017 +0000

    of: base: add support to find the level of the last cache
    
    It is useful to have helper function just to get the number of cache
    levels for a given logical cpu. We can obtain the same by just checking
    the level at which the last cache is present. This patch adds support
    to find the level of the last cache for a given cpu.
    
    It will be used on ARM64 platform where the device tree provides the
    information for the additional non-architected/transparent/external
    last level caches that are not integrated with the processors.
    
    Cc: Mark Rutland <mark.rutland@arm.com>
    Suggested-by: Rob Herring <robh+dt@kernel.org>
    Acked-by: Rob Herring <robh+dt@kernel.org>
    Tested-by: Tan Xiaojun <tanxiaojun@huawei.com>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    [will: use u32 instead of int for cache_level]
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index d4bea3c797d6..a641b1faf057 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -25,6 +25,7 @@
 #include <linux/cpu.h>
 #include <linux/module.h>
 #include <linux/of.h>
+#include <linux/of_device.h>
 #include <linux/of_graph.h>
 #include <linux/spinlock.h>
 #include <linux/slab.h>
@@ -2267,6 +2268,31 @@ struct device_node *of_find_next_cache_node(const struct device_node *np)
 	return NULL;
 }
 
+/**
+ * of_find_last_cache_level - Find the level at which the last cache is
+ * 		present for the given logical cpu
+ *
+ * @cpu: cpu number(logical index) for which the last cache level is needed
+ *
+ * Returns the the level at which the last cache is present. It is exactly
+ * same as  the total number of cache levels for the given logical cpu.
+ */
+int of_find_last_cache_level(unsigned int cpu)
+{
+	u32 cache_level = 0;
+	struct device_node *prev = NULL, *np = of_cpu_device_node_get(cpu);
+
+	while (np) {
+		prev = np;
+		of_node_put(np);
+		np = of_find_next_cache_node(np);
+	}
+
+	of_property_read_u32(prev, "cache-level", &cache_level);
+
+	return cache_level;
+}
+
 /**
  * of_graph_parse_endpoint() - parse common endpoint node properties
  * @node: pointer to endpoint device_node

commit de96ec2a77c6d06a423c2c495bb4a2f4299f3d9e
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Fri Sep 23 16:38:27 2016 +0100

    OF: Prevent unaligned access in of_alias_scan()
    
    When allocating a struct alias_prop, of_alias_scan() only requested that
    it be aligned on a 4 byte boundary. The struct contains pointers which
    leads to us attempting 64 bit writes on 64 bit systems, and if the CPU
    doesn't support unaligned memory accesses then this causes problems -
    for example on some MIPS64r2 CPUs including the "mips64r2-generic" QEMU
    emulated CPU it will trigger an address error exception.
    
    Fix this by requesting alignment for the struct alias_prop allocation
    matching that which the compiler expects, using the __alignof__ keyword.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Reviewed-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: devicetree@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/14306/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index d4bea3c797d6..84cf2f3f396c 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -2112,7 +2112,7 @@ void of_alias_scan(void * (*dt_alloc)(u64 size, u64 align))
 			continue;
 
 		/* Allocate an alias_prop with enough space for the stem */
-		ap = dt_alloc(sizeof(*ap) + len + 1, 4);
+		ap = dt_alloc(sizeof(*ap) + len + 1, __alignof__(*ap));
 		if (!ap)
 			continue;
 		memset(ap, 0, sizeof(*ap) + len + 1);

commit 6df8b74b1720db1133ace0861cb6721bfe57819a
Merge: 57d64e6f5fac 61eb3a04f978
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 15 11:49:41 2016 -0800

    Merge tag 'devicetree-for-4.10' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull DeviceTree updates from Rob Herring:
    
     - add various vendor prefixes.
    
     - fix NUMA node handling when "numa=off" is passed on kernel command
       line.
    
     - coding style Clean-up of overlay handling code.
    
     - DocBook fixes in DT platform driver code
    
     - Altera SoCFPGA binding addtions for freeze bridge, arria10 FPGA
       manager and FPGA bridges.
    
     - a couple of printk message fixes.
    
    * tag 'devicetree-for-4.10' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (33 commits)
      dt: pwm: bcm2835: fix typo in clocks property name
      devicetree: add vendor prefix for National Instruments
      Revert "of: base: add support to get machine model name"
      of: Fix issue where code would fall through to error case.
      drivers/of: fix missing pr_cont()s in of_print_phandle_args
      devicetree: bindings: Add vendor prefix for Oki
      devicetree: bindings: Add vendor prefix for Andes Technology Corporation
      dt-bindings: add MYIR Tech hardware vendor prefix
      add bindings document for altera freeze bridge
      ARM: socfpga: add bindings doc for arria10 fpga manager
      ARM: socfpga: add bindings document for fpga bridge drivers
      of: base: add support to get machine model name
      of/platform: clarify of_find_device_by_node refcounting
      of/platform: fix of_platform_device_destroy comment
      of: Remove unused variable overlay_symbols
      of: Move setting of pointer to beside test for non-null
      of: Add back an error message, restructured
      of: Update comments to reflect changes and increase clarity
      of: Remove redundant size check
      of: Update structure of code to be clearer, also remove BUG_ON()
      ...

commit 0a8b13eab1349337db4a4b5755466460bfbbaa1e
Author: Rob Herring <robh@kernel.org>
Date:   Fri Dec 9 10:33:48 2016 -0600

    Revert "of: base: add support to get machine model name"
    
    This reverts commit e5269794d2e9046dd45be15bdb213a229df46b7e.

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 5e04572e692a..60b878e88a48 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -545,38 +545,6 @@ int of_machine_is_compatible(const char *compat)
 }
 EXPORT_SYMBOL(of_machine_is_compatible);
 
-/**
- * of_machine_get_model_name - Find and read the model name or the compatible
- *		value for the machine.
- * @model:	pointer to null terminated return string, modified only if
- *		return value is 0.
- *
- * Returns a string containing either the model name or the compatible value
- * of the machine if found, else return error.
- *
- * Search for a machine model name or the compatible if model name is missing
- * in a device tree node and retrieve a null terminated string value (pointer
- * to data, not a copy). Returns 0 on success, -EINVAL if root of the device
- * tree is not found and other error returned by of_property_read_string on
- * failure.
- */
-int of_machine_get_model_name(const char **model)
-{
-	int error;
-
-	if (!of_node_get(of_root))
-		return -EINVAL;
-
-	error = of_property_read_string(of_root, "model", model);
-	if (error)
-		error = of_property_read_string_index(of_root, "compatible",
-						      0, model);
-	of_node_put(of_root);
-
-	return error;
-}
-EXPORT_SYMBOL(of_machine_get_model_name);
-
 /**
  *  __of_device_is_available - check if a device is available for use
  *

commit 4aa663444048396799b49b5b782552c1ba15c39d
Author: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
Date:   Thu Dec 1 09:00:55 2016 +0100

    drivers/of: fix missing pr_cont()s in of_print_phandle_args
    
    Since the KERN_CONT changes, the current debug printks have a lot of
    empty lines making the log messages very hard to read.
    
    Signed-off-by: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 128e114f9210..5e04572e692a 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1566,9 +1566,12 @@ void of_print_phandle_args(const char *msg, const struct of_phandle_args *args)
 {
 	int i;
 	printk("%s %s", msg, of_node_full_name(args->np));
-	for (i = 0; i < args->args_count; i++)
-		printk(i ? ",%08x" : ":%08x", args->args[i]);
-	printk("\n");
+	for (i = 0; i < args->args_count; i++) {
+		const char delim = i ? ',' : ':';
+
+		pr_cont("%c%08x", delim, args->args[i]);
+	}
+	pr_cont("\n");
 }
 
 int of_phandle_iterator_init(struct of_phandle_iterator *it,

commit e5269794d2e9046dd45be15bdb213a229df46b7e
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Thu Nov 17 15:32:54 2016 +0000

    of: base: add support to get machine model name
    
    Currently platforms/drivers needing to get the machine model name are
    replicating the same snippet of code. In some case, the OF reference
    counting is either missing or incorrect.
    
    This patch adds support to read the machine model name either using
    the "model" or the "compatible" property in the device tree root node
    to the core OF/DT code.
    
    This can be used to remove all the duplicate code snippets doing exactly
    same thing later.
    
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index d687e6de24a0..128e114f9210 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -545,6 +545,38 @@ int of_machine_is_compatible(const char *compat)
 }
 EXPORT_SYMBOL(of_machine_is_compatible);
 
+/**
+ * of_machine_get_model_name - Find and read the model name or the compatible
+ *		value for the machine.
+ * @model:	pointer to null terminated return string, modified only if
+ *		return value is 0.
+ *
+ * Returns a string containing either the model name or the compatible value
+ * of the machine if found, else return error.
+ *
+ * Search for a machine model name or the compatible if model name is missing
+ * in a device tree node and retrieve a null terminated string value (pointer
+ * to data, not a copy). Returns 0 on success, -EINVAL if root of the device
+ * tree is not found and other error returned by of_property_read_string on
+ * failure.
+ */
+int of_machine_get_model_name(const char **model)
+{
+	int error;
+
+	if (!of_node_get(of_root))
+		return -EINVAL;
+
+	error = of_property_read_string(of_root, "model", model);
+	if (error)
+		error = of_property_read_string_index(of_root, "compatible",
+						      0, model);
+	of_node_put(of_root);
+
+	return error;
+}
+EXPORT_SYMBOL(of_machine_get_model_name);
+
 /**
  *  __of_device_is_available - check if a device is available for use
  *

commit c6c7d83b9c9e6a8b3e6d84c820ac61fbffc9e396
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Nov 10 10:46:26 2016 -0800

    Revert "console: don't prefer first registered if DT specifies stdout-path"
    
    This reverts commit 05fd007e4629 ("console: don't prefer first
    registered if DT specifies stdout-path").
    
    The reverted commit changes existing behavior on which many ARM boards
    rely.  Many ARM small-board-computers, like e.g.  the Raspberry Pi have
    both a video output and a serial console.  Depending on whether the user
    is using the device as a more regular computer; or as a headless device
    we need to have the console on either one or the other.
    
    Many users rely on the kernel behavior of the console being present on
    both outputs, before the reverted commit the console setup with no
    console= kernel arguments on an ARM board which sets stdout-path in dt
    would look like this:
    
      [root@localhost ~]# cat /proc/consoles
      ttyS0                -W- (EC p a)    4:64
      tty0                 -WU (E  p  )    4:1
    
    Where as after the reverted commit, it looks like this:
    
      [root@localhost ~]# cat /proc/consoles
      ttyS0                -W- (EC p a)    4:64
    
    This commit reverts commit 05fd007e4629 ("console: don't prefer first
    registered if DT specifies stdout-path") restoring the original
    behavior.
    
    Fixes: 05fd007e4629 ("console: don't prefer first registered if DT specifies stdout-path")
    Link: http://lkml.kernel.org/r/20161104121135.4780-2-hdegoede@redhat.com
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Thorsten Leemhuis <regressions@leemhuis.info>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index d687e6de24a0..a0bccb54a9bd 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -2077,8 +2077,6 @@ void of_alias_scan(void * (*dt_alloc)(u64 size, u64 align))
 			name = of_get_property(of_aliases, "stdout", NULL);
 		if (name)
 			of_stdout = of_find_node_opts_by_path(name, &of_stdout_options);
-		if (of_stdout)
-			console_set_by_of();
 	}
 
 	if (!of_aliases)

commit 05fd007e46296afb24d15c7d589d535e5a5b9d5c
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Fri Oct 7 17:03:15 2016 -0700

    console: don't prefer first registered if DT specifies stdout-path
    
    If a device tree specifies a preferred device for kernel console output
    via the stdout-path or linux,stdout-path chosen node properties or the
    stdout alias then the kernel ought to honor it & output the kernel
    console to that device.  As it stands, this isn't the case.  Whilst we
    parse the stdout-path properties & set an of_stdout variable from
    of_alias_scan(), and use that from of_console_check() to determine
    whether to add a console device as a preferred console whilst
    registering it, we also prefer the first registered console if no other
    has been selected at the time of its registration.
    
    This means that if a console other than the one the device tree selects
    via stdout-path is registered first, we will switch to using it & when
    the stdout-path console is later registered the call to
    add_preferred_console() via of_console_check() is too late to do
    anything useful.  In practice this seems to mean that we switch to the
    dummy console device fairly early & see no further console output:
    
        Console: colour dummy device 80x25
        console [tty0] enabled
        bootconsole [ns16550a0] disabled
    
    Fix this by not automatically preferring the first registered console if
    one is specified by the device tree.  This allows consoles to be
    registered but not enabled, and once the driver for the console selected
    by stdout-path calls of_console_check() the driver will be added to the
    list of preferred consoles before any other console has been enabled.
    When that console is then registered via register_console() it will be
    enabled as expected.
    
    Link: http://lkml.kernel.org/r/20160809151937.26118-1-paul.burton@imgtec.com
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Ivan Delalande <colona@arista.com>
    Cc: Thierry Reding <treding@nvidia.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Jan Kara <jack@suse.com>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index a0bccb54a9bd..d687e6de24a0 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -2077,6 +2077,8 @@ void of_alias_scan(void * (*dt_alloc)(u64 size, u64 align))
 			name = of_get_property(of_aliases, "stdout", NULL);
 		if (name)
 			of_stdout = of_find_node_opts_by_path(name, &of_stdout_options);
+		if (of_stdout)
+			console_set_by_of();
 	}
 
 	if (!of_aliases)

commit a67e9472da423ec47a3586920b526ebaedf25fc3
Author: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
Date:   Mon Sep 12 14:01:29 2016 +0100

    of: Add array read functions with min/max size limits
    
    Add a new set of array reading functions that take a minimum and
    maximum size limit and will fail if the property size is not within
    the size limits. This makes it more convenient for drivers that
    use variable-size DT arrays which must be bounded at both ends -
    data must be at least N entries but must not overflow the array
    it is being copied into. It is also more efficient than making this
    functionality out of existing public functions and avoids duplication.
    
    The existing array functions have been left in the API, since there
    are a very large number of clients of those functions and their
    existing functionality is still useful. This avoids turning a small
    API improvement into a major kernel rework.
    
    The old functions have been turned into mininmal static inlines calling
    the new functions. The old functions had no upper limit on the actual
    size of the dts entry, to preserve this functionality rather than keeping
    two near-identical implementations, if the new function is called with
    max=0 there is no limit on the size of the dts entry but only the min
    number of elements are read.
    
    Signed-off-by: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index b85373768ce1..a0bccb54a9bd 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1209,108 +1209,145 @@ int of_property_read_u32_index(const struct device_node *np,
 EXPORT_SYMBOL_GPL(of_property_read_u32_index);
 
 /**
- * of_property_read_u8_array - Find and read an array of u8 from a property.
+ * of_property_read_variable_u8_array - Find and read an array of u8 from a
+ * property, with bounds on the minimum and maximum array size.
  *
  * @np:		device node from which the property value is to be read.
  * @propname:	name of the property to be searched.
  * @out_values:	pointer to return value, modified only if return value is 0.
- * @sz:		number of array elements to read
+ * @sz_min:	minimum number of array elements to read
+ * @sz_max:	maximum number of array elements to read, if zero there is no
+ *		upper limit on the number of elements in the dts entry but only
+ *		sz_min will be read.
  *
  * Search for a property in a device node and read 8-bit value(s) from
- * it. Returns 0 on success, -EINVAL if the property does not exist,
- * -ENODATA if property does not have a value, and -EOVERFLOW if the
- * property data isn't large enough.
+ * it. Returns number of elements read on success, -EINVAL if the property
+ * does not exist, -ENODATA if property does not have a value, and -EOVERFLOW
+ * if the property data is smaller than sz_min or longer than sz_max.
  *
  * dts entry of array should be like:
  *	property = /bits/ 8 <0x50 0x60 0x70>;
  *
  * The out_values is modified only if a valid u8 value can be decoded.
  */
-int of_property_read_u8_array(const struct device_node *np,
-			const char *propname, u8 *out_values, size_t sz)
+int of_property_read_variable_u8_array(const struct device_node *np,
+					const char *propname, u8 *out_values,
+					size_t sz_min, size_t sz_max)
 {
+	size_t sz, count;
 	const u8 *val = of_find_property_value_of_size(np, propname,
-						(sz * sizeof(*out_values)),
-						0,
-						NULL);
+						(sz_min * sizeof(*out_values)),
+						(sz_max * sizeof(*out_values)),
+						&sz);
 
 	if (IS_ERR(val))
 		return PTR_ERR(val);
 
-	while (sz--)
+	if (!sz_max)
+		sz = sz_min;
+	else
+		sz /= sizeof(*out_values);
+
+	count = sz;
+	while (count--)
 		*out_values++ = *val++;
-	return 0;
+
+	return sz;
 }
-EXPORT_SYMBOL_GPL(of_property_read_u8_array);
+EXPORT_SYMBOL_GPL(of_property_read_variable_u8_array);
 
 /**
- * of_property_read_u16_array - Find and read an array of u16 from a property.
+ * of_property_read_variable_u16_array - Find and read an array of u16 from a
+ * property, with bounds on the minimum and maximum array size.
  *
  * @np:		device node from which the property value is to be read.
  * @propname:	name of the property to be searched.
  * @out_values:	pointer to return value, modified only if return value is 0.
- * @sz:		number of array elements to read
+ * @sz_min:	minimum number of array elements to read
+ * @sz_max:	maximum number of array elements to read, if zero there is no
+ *		upper limit on the number of elements in the dts entry but only
+ *		sz_min will be read.
  *
  * Search for a property in a device node and read 16-bit value(s) from
- * it. Returns 0 on success, -EINVAL if the property does not exist,
- * -ENODATA if property does not have a value, and -EOVERFLOW if the
- * property data isn't large enough.
+ * it. Returns number of elements read on success, -EINVAL if the property
+ * does not exist, -ENODATA if property does not have a value, and -EOVERFLOW
+ * if the property data is smaller than sz_min or longer than sz_max.
  *
  * dts entry of array should be like:
  *	property = /bits/ 16 <0x5000 0x6000 0x7000>;
  *
  * The out_values is modified only if a valid u16 value can be decoded.
  */
-int of_property_read_u16_array(const struct device_node *np,
-			const char *propname, u16 *out_values, size_t sz)
+int of_property_read_variable_u16_array(const struct device_node *np,
+					const char *propname, u16 *out_values,
+					size_t sz_min, size_t sz_max)
 {
+	size_t sz, count;
 	const __be16 *val = of_find_property_value_of_size(np, propname,
-						(sz * sizeof(*out_values)),
-						0,
-						NULL);
+						(sz_min * sizeof(*out_values)),
+						(sz_max * sizeof(*out_values)),
+						&sz);
 
 	if (IS_ERR(val))
 		return PTR_ERR(val);
 
-	while (sz--)
+	if (!sz_max)
+		sz = sz_min;
+	else
+		sz /= sizeof(*out_values);
+
+	count = sz;
+	while (count--)
 		*out_values++ = be16_to_cpup(val++);
-	return 0;
+
+	return sz;
 }
-EXPORT_SYMBOL_GPL(of_property_read_u16_array);
+EXPORT_SYMBOL_GPL(of_property_read_variable_u16_array);
 
 /**
- * of_property_read_u32_array - Find and read an array of 32 bit integers
- * from a property.
+ * of_property_read_variable_u32_array - Find and read an array of 32 bit
+ * integers from a property, with bounds on the minimum and maximum array size.
  *
  * @np:		device node from which the property value is to be read.
  * @propname:	name of the property to be searched.
  * @out_values:	pointer to return value, modified only if return value is 0.
- * @sz:		number of array elements to read
+ * @sz_min:	minimum number of array elements to read
+ * @sz_max:	maximum number of array elements to read, if zero there is no
+ *		upper limit on the number of elements in the dts entry but only
+ *		sz_min will be read.
  *
  * Search for a property in a device node and read 32-bit value(s) from
- * it. Returns 0 on success, -EINVAL if the property does not exist,
- * -ENODATA if property does not have a value, and -EOVERFLOW if the
- * property data isn't large enough.
+ * it. Returns number of elements read on success, -EINVAL if the property
+ * does not exist, -ENODATA if property does not have a value, and -EOVERFLOW
+ * if the property data is smaller than sz_min or longer than sz_max.
  *
  * The out_values is modified only if a valid u32 value can be decoded.
  */
-int of_property_read_u32_array(const struct device_node *np,
+int of_property_read_variable_u32_array(const struct device_node *np,
 			       const char *propname, u32 *out_values,
-			       size_t sz)
+			       size_t sz_min, size_t sz_max)
 {
+	size_t sz, count;
 	const __be32 *val = of_find_property_value_of_size(np, propname,
-						(sz * sizeof(*out_values)),
-						0,
-						NULL);
+						(sz_min * sizeof(*out_values)),
+						(sz_max * sizeof(*out_values)),
+						&sz);
 
 	if (IS_ERR(val))
 		return PTR_ERR(val);
 
-	while (sz--)
+	if (!sz_max)
+		sz = sz_min;
+	else
+		sz /= sizeof(*out_values);
+
+	count = sz;
+	while (count--)
 		*out_values++ = be32_to_cpup(val++);
-	return 0;
+
+	return sz;
 }
-EXPORT_SYMBOL_GPL(of_property_read_u32_array);
+EXPORT_SYMBOL_GPL(of_property_read_variable_u32_array);
 
 /**
  * of_property_read_u64 - Find and read a 64 bit integer from a property
@@ -1342,40 +1379,51 @@ int of_property_read_u64(const struct device_node *np, const char *propname,
 EXPORT_SYMBOL_GPL(of_property_read_u64);
 
 /**
- * of_property_read_u64_array - Find and read an array of 64 bit integers
- * from a property.
+ * of_property_read_variable_u64_array - Find and read an array of 64 bit
+ * integers from a property, with bounds on the minimum and maximum array size.
  *
  * @np:		device node from which the property value is to be read.
  * @propname:	name of the property to be searched.
  * @out_values:	pointer to return value, modified only if return value is 0.
- * @sz:		number of array elements to read
+ * @sz_min:	minimum number of array elements to read
+ * @sz_max:	maximum number of array elements to read, if zero there is no
+ *		upper limit on the number of elements in the dts entry but only
+ *		sz_min will be read.
  *
  * Search for a property in a device node and read 64-bit value(s) from
- * it. Returns 0 on success, -EINVAL if the property does not exist,
- * -ENODATA if property does not have a value, and -EOVERFLOW if the
- * property data isn't large enough.
+ * it. Returns number of elements read on success, -EINVAL if the property
+ * does not exist, -ENODATA if property does not have a value, and -EOVERFLOW
+ * if the property data is smaller than sz_min or longer than sz_max.
  *
  * The out_values is modified only if a valid u64 value can be decoded.
  */
-int of_property_read_u64_array(const struct device_node *np,
+int of_property_read_variable_u64_array(const struct device_node *np,
 			       const char *propname, u64 *out_values,
-			       size_t sz)
+			       size_t sz_min, size_t sz_max)
 {
+	size_t sz, count;
 	const __be32 *val = of_find_property_value_of_size(np, propname,
-						(sz * sizeof(*out_values)),
-						0,
-						NULL);
+						(sz_min * sizeof(*out_values)),
+						(sz_max * sizeof(*out_values)),
+						&sz);
 
 	if (IS_ERR(val))
 		return PTR_ERR(val);
 
-	while (sz--) {
+	if (!sz_max)
+		sz = sz_min;
+	else
+		sz /= sizeof(*out_values);
+
+	count = sz;
+	while (count--) {
 		*out_values++ = of_read_number(val, 2);
 		val += 2;
 	}
-	return 0;
+
+	return sz;
 }
-EXPORT_SYMBOL_GPL(of_property_read_u64_array);
+EXPORT_SYMBOL_GPL(of_property_read_variable_u64_array);
 
 /**
  * of_property_read_string - Find and read a string from a property

commit 79ac5d31df7011e2b60dba4bd1e2f9a9f65e5e1e
Author: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
Date:   Mon Sep 12 14:01:28 2016 +0100

    of: Make of_find_property_value_of_size take a length range
    
    In preparation for adding variable-length array reads, change
    of_find_property_value_of_size so that it takes an optional
    maximum length. If the maximum is passed as 0, the behaviour is
    unchanged and it will return a property if it's >= the requested
    minimum length. If maximum is non-zero it will only return a
    property whose length is min <= l <= max.
    
    Signed-off-by: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 3ce69536a7b3..b85373768ce1 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1146,16 +1146,18 @@ EXPORT_SYMBOL_GPL(of_property_count_elems_of_size);
  *
  * @np:		device node from which the property value is to be read.
  * @propname:	name of the property to be searched.
- * @len:	requested length of property value
+ * @min:	minimum allowed length of property value
+ * @max:	maximum allowed length of property value (0 means unlimited)
+ * @len:	if !=NULL, actual length is written to here
  *
  * Search for a property in a device node and valid the requested size.
  * Returns the property value on success, -EINVAL if the property does not
  *  exist, -ENODATA if property does not have a value, and -EOVERFLOW if the
- * property data isn't large enough.
+ * property data is too small or too large.
  *
  */
 static void *of_find_property_value_of_size(const struct device_node *np,
-			const char *propname, u32 len)
+			const char *propname, u32 min, u32 max, size_t *len)
 {
 	struct property *prop = of_find_property(np, propname, NULL);
 
@@ -1163,9 +1165,14 @@ static void *of_find_property_value_of_size(const struct device_node *np,
 		return ERR_PTR(-EINVAL);
 	if (!prop->value)
 		return ERR_PTR(-ENODATA);
-	if (len > prop->length)
+	if (prop->length < min)
+		return ERR_PTR(-EOVERFLOW);
+	if (max && prop->length > max)
 		return ERR_PTR(-EOVERFLOW);
 
+	if (len)
+		*len = prop->length;
+
 	return prop->value;
 }
 
@@ -1189,7 +1196,9 @@ int of_property_read_u32_index(const struct device_node *np,
 				       u32 index, u32 *out_value)
 {
 	const u32 *val = of_find_property_value_of_size(np, propname,
-					((index + 1) * sizeof(*out_value)));
+					((index + 1) * sizeof(*out_value)),
+					0,
+					NULL);
 
 	if (IS_ERR(val))
 		return PTR_ERR(val);
@@ -1221,7 +1230,9 @@ int of_property_read_u8_array(const struct device_node *np,
 			const char *propname, u8 *out_values, size_t sz)
 {
 	const u8 *val = of_find_property_value_of_size(np, propname,
-						(sz * sizeof(*out_values)));
+						(sz * sizeof(*out_values)),
+						0,
+						NULL);
 
 	if (IS_ERR(val))
 		return PTR_ERR(val);
@@ -1254,7 +1265,9 @@ int of_property_read_u16_array(const struct device_node *np,
 			const char *propname, u16 *out_values, size_t sz)
 {
 	const __be16 *val = of_find_property_value_of_size(np, propname,
-						(sz * sizeof(*out_values)));
+						(sz * sizeof(*out_values)),
+						0,
+						NULL);
 
 	if (IS_ERR(val))
 		return PTR_ERR(val);
@@ -1286,7 +1299,9 @@ int of_property_read_u32_array(const struct device_node *np,
 			       size_t sz)
 {
 	const __be32 *val = of_find_property_value_of_size(np, propname,
-						(sz * sizeof(*out_values)));
+						(sz * sizeof(*out_values)),
+						0,
+						NULL);
 
 	if (IS_ERR(val))
 		return PTR_ERR(val);
@@ -1314,7 +1329,9 @@ int of_property_read_u64(const struct device_node *np, const char *propname,
 			 u64 *out_value)
 {
 	const __be32 *val = of_find_property_value_of_size(np, propname,
-						sizeof(*out_value));
+						sizeof(*out_value),
+						0,
+						NULL);
 
 	if (IS_ERR(val))
 		return PTR_ERR(val);
@@ -1345,7 +1362,9 @@ int of_property_read_u64_array(const struct device_node *np,
 			       size_t sz)
 {
 	const __be32 *val = of_find_property_value_of_size(np, propname,
-						(sz * sizeof(*out_values)));
+						(sz * sizeof(*out_values)),
+						0,
+						NULL);
 
 	if (IS_ERR(val))
 		return PTR_ERR(val);

commit 34276bb062b8449b3b0a208c9b848a1a27920075
Author: Lucas Stach <l.stach@pengutronix.de>
Date:   Mon Aug 15 14:58:43 2016 +0200

    of: fix reference counting in of_graph_get_endpoint_by_regs
    
    The called of_graph_get_next_endpoint() already decrements the refcount
    of the prev node, so it is wrong to do it again in the calling function.
    
    Use the for_each_endpoint_of_node() helper to interate through the
    endpoint OF nodes, which already does the right thing and simplifies
    the code a bit.
    
    Fixes: 8ccd0d0ca041
    (of: add helper for getting endpoint node of specific identifiers)
    Cc: stable@vger.kernel.org
    Reported-by: David Jander <david@protonic.nl>
    Signed-off-by: Lucas Stach <l.stach@pengutronix.de>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index cb255a07baa0..3ce69536a7b3 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -2342,20 +2342,13 @@ struct device_node *of_graph_get_endpoint_by_regs(
 	const struct device_node *parent, int port_reg, int reg)
 {
 	struct of_endpoint endpoint;
-	struct device_node *node, *prev_node = NULL;
-
-	while (1) {
-		node = of_graph_get_next_endpoint(parent, prev_node);
-		of_node_put(prev_node);
-		if (!node)
-			break;
+	struct device_node *node = NULL;
 
+	for_each_endpoint_of_node(parent, node) {
 		of_graph_parse_endpoint(node, &endpoint);
 		if (((port_reg == -1) || (endpoint.port == port_reg)) &&
 			((reg == -1) || (endpoint.id == reg)))
 			return node;
-
-		prev_node = node;
 	}
 
 	return NULL;

commit beab47d55b883e85bec7771a899ac791c6f92c80
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Tue Jul 19 22:42:22 2016 +0200

    of: Delete an unnecessary check before the function call "of_node_put"
    
    The of_node_put() function tests whether its argument is NULL
    and then returns immediately.
    Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 7792266db259..cb255a07baa0 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1631,8 +1631,7 @@ static int __of_parse_phandle_with_args(const struct device_node *np,
 	 */
 
  err:
-	if (it.node)
-		of_node_put(it.node);
+	of_node_put(it.node);
 	return rc;
 }
 

commit bad60e6f259a01cf9f29a1ef8d435ab6c60b2de9
Merge: dd0f0cf58af7 719dbb2df78f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 30 21:01:36 2016 -0700

    Merge tag 'powerpc-4.8-1' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux
    
    Pull powerpc updates from Michael Ellerman:
     "Highlights:
       - PowerNV PCI hotplug support.
       - Lots more Power9 support.
       - eBPF JIT support on ppc64le.
       - Lots of cxl updates.
       - Boot code consolidation.
    
      Bug fixes:
       - Fix spin_unlock_wait() from Boqun Feng
       - Fix stack pointer corruption in __tm_recheckpoint() from Michael
         Neuling
       - Fix multiple bugs in memory_hotplug_max() from Bharata B Rao
       - mm: Ensure "special" zones are empty from Oliver O'Halloran
       - ftrace: Separate the heuristics for checking call sites from
         Michael Ellerman
       - modules: Never restore r2 for a mprofile-kernel style mcount() call
         from Michael Ellerman
       - Fix endianness when reading TCEs from Alexey Kardashevskiy
       - start rtasd before PCI probing from Greg Kurz
       - PCI: rpaphp: Fix slot registration for multiple slots under a PHB
         from Tyrel Datwyler
       - powerpc/mm: Add memory barrier in __hugepte_alloc() from Sukadev
         Bhattiprolu
    
      Cleanups & fixes:
       - Drop support for MPIC in pseries from Rashmica Gupta
       - Define and use PPC64_ELF_ABI_v2/v1 from Michael Ellerman
       - Remove unused symbols in asm-offsets.c from Rashmica Gupta
       - Fix SRIOV not building without EEH enabled from Russell Currey
       - Remove kretprobe_trampoline_holder from Thiago Jung Bauermann
       - Reduce log level of PCI I/O space warning from Benjamin
         Herrenschmidt
       - Add array bounds checking to crash_shutdown_handlers from Suraj
         Jitindar Singh
       - Avoid -maltivec when using clang integrated assembler from Anton
         Blanchard
       - Fix array overrun in ppc_rtas() syscall from Andrew Donnellan
       - Fix error return value in cmm_mem_going_offline() from Rasmus
         Villemoes
       - export cpu_to_core_id() from Mauricio Faria de Oliveira
       - Remove old symbols from defconfigs from Andrew Donnellan
       - Update obsolete comments in setup_32.c about entry conditions from
         Benjamin Herrenschmidt
       - Add comment explaining the purpose of setup_kdump_trampoline() from
         Benjamin Herrenschmidt
       - Merge the RELOCATABLE config entries for ppc32 and ppc64 from Kevin
         Hao
       - Remove RELOCATABLE_PPC32 from Kevin Hao
       - Fix .long's in tlb-radix.c to more meaningful from Balbir Singh
    
      Minor cleanups & fixes:
       - Andrew Donnellan, Anna-Maria Gleixner, Anton Blanchard, Benjamin
         Herrenschmidt, Bharata B Rao, Christophe Leroy, Colin Ian King,
         Geliang Tang, Greg Kurz, Madhavan Srinivasan, Michael Ellerman,
         Michael Ellerman, Stephen Rothwell, Stewart Smith.
    
      Freescale updates from Scott:
       - "Highlights include more 8xx optimizations, device tree updates,
         and MVME7100 support."
    
      PowerNV PCI hotplug from Gavin Shan:
       - PCI: Add pcibios_setup_bridge()
       - Override pcibios_setup_bridge()
       - Remove PCI_RESET_DELAY_US
       - Move pnv_pci_ioda_setup_opal_tce_kill() around
       - Increase PE# capacity
       - Allocate PE# in reverse order
       - Create PEs in pcibios_setup_bridge()
       - Setup PE for root bus
       - Extend PCI bridge resources
       - Make pnv_ioda_deconfigure_pe() visible
       - Dynamically release PE
       - Update bridge windows on PCI plug
       - Delay populating pdn
       - Support PCI slot ID
       - Use PCI slot reset infrastructure
       - Introduce pnv_pci_get_slot_id()
       - Functions to get/set PCI slot state
       - PCI/hotplug: PowerPC PowerNV PCI hotplug driver
       - Print correct PHB type names
    
      Power9 idle support from Shreyas B. Prabhu:
       - set power_save func after the idle states are initialized
       - Use PNV_THREAD_WINKLE macro while requesting for winkle
       - make hypervisor state restore a function
       - Rename idle_power7.S to idle_book3s.S
       - Rename reusable idle functions to hardware agnostic names
       - Make pnv_powersave_common more generic
       - abstraction for saving SPRs before entering deep idle states
       - Add platform support for stop instruction
       - cpuidle/powernv: Use CPUIDLE_STATE_MAX instead of MAX_POWERNV_IDLE_STATES
       - cpuidle/powernv: cleanup cpuidle-powernv.c
       - cpuidle/powernv: Add support for POWER ISA v3 idle states
       - Use deepest stop state when cpu is offlined
    
      Power9 PMU from Madhavan Srinivasan:
       - factor out power8 pmu macros and defines
       - factor out power8 pmu functions
       - factor out power8 __init_pmu code
       - Add power9 event list macros for generic and cache events
       - Power9 PMU support
       - Export Power9 generic and cache events to sysfs
    
      Power9 preliminary interrupt & PCI support from Benjamin Herrenschmidt:
       - Add XICS emulation APIs
       - Move a few exception common handlers to make room
       - Add support for HV virtualization interrupts
       - Add mechanism to force a replay of interrupts
       - Add ICP OPAL backend
       - Discover IODA3 PHBs
       - pci: Remove obsolete SW invalidate
       - opal: Add real mode call wrappers
       - Rename TCE invalidation calls
       - Remove SWINV constants and obsolete TCE code
       - Rework accessing the TCE invalidate register
       - Fallback to OPAL for TCE invalidations
       - Use the device-tree to get available range of M64's
       - Check status of a PHB before using it
       - pci: Don't try to allocate resources that will be reassigned
    
      Other Power9:
       - Send SIGBUS on unaligned copy and paste from Chris Smart
       - Large Decrementer support from Oliver O'Halloran
       - Load Monitor Register Support from Jack Miller
    
      Performance improvements from Anton Blanchard:
       - Avoid load hit store in __giveup_fpu() and __giveup_altivec()
       - Avoid load hit store in setup_sigcontext()
       - Remove assembly versions of strcpy, strcat, strlen and strcmp
       - Align hot loops of some string functions
    
      eBPF JIT from Naveen N. Rao:
       - Fix/enhance 32-bit Load Immediate implementation
       - Optimize 64-bit Immediate loads
       - Introduce rotate immediate instructions
       - A few cleanups
       - Isolate classic BPF JIT specifics into a separate header
       - Implement JIT compiler for extended BPF
    
      Operator Panel driver from Suraj Jitindar Singh:
       - devicetree/bindings: Add binding for operator panel on FSP machines
       - Add inline function to get rc from an ASYNC_COMP opal_msg
       - Add driver for operator panel on FSP machines
    
      Sparse fixes from Daniel Axtens:
       - make some things static
       - Introduce asm-prototypes.h
       - Include headers containing prototypes
       - Use #ifdef __BIG_ENDIAN__ #else for REG_BYTE
       - kvm: Clarify __user annotations
       - Pass endianness to sparse
       - Make ppc_md.{halt, restart} __noreturn
    
      MM fixes & cleanups from Aneesh Kumar K.V:
       - radix: Update LPCR HR bit as per ISA
       - use _raw variant of page table accessors
       - Compile out radix related functions if RADIX_MMU is disabled
       - Clear top 16 bits of va only on older cpus
       - Print formation regarding the the MMU mode
       - hash: Update SDR1 size encoding as documented in ISA 3.0
       - radix: Update PID switch sequence
       - radix: Update machine call back to support new HCALL.
       - radix: Add LPID based tlb flush helpers
       - radix: Add a kernel command line to disable radix
       - Cleanup LPCR defines
    
      Boot code consolidation from Benjamin Herrenschmidt:
       - Move epapr_paravirt_early_init() to early_init_devtree()
       - cell: Don't use flat device-tree after boot
       - ge_imp3a: Don't use the flat device-tree after boot
       - mpc85xx_ds: Don't use the flat device-tree after boot
       - mpc85xx_rdb: Don't use the flat device-tree after boot
       - Don't test for machine type in rtas_initialize()
       - Don't test for machine type in smp_setup_cpu_maps()
       - dt: Add of_device_compatible_match()
       - Factor do_feature_fixup calls
       - Move 64-bit feature fixup earlier
       - Move 64-bit memory reserves to setup_arch()
       - Use a cachable DART
       - Move FW feature probing out of pseries probe()
       - Put exception configuration in a common place
       - Remove early allocation of the SMU command buffer
       - Move MMU backend selection out of platform code
       - pasemi: Remove IOBMAP allocation from platform probe()
       - mm/hash: Don't use machine_is() early during boot
       - Don't test for machine type to detect HEA special case
       - pmac: Remove spurrious machine type test
       - Move hash table ops to a separate structure
       - Ensure that ppc_md is empty before probing for machine type
       - Move 64-bit probe_machine() to later in the boot process
       - Move 32-bit probe() machine to later in the boot process
       - Get rid of ppc_md.init_early()
       - Move the boot time info banner to a separate function
       - Move setting of {i,d}cache_bsize to initialize_cache_info()
       - Move the content of setup_system() to setup_arch()
       - Move cache info inits to a separate function
       - Re-order the call to smp_setup_cpu_maps()
       - Re-order setup_panic()
       - Make a few boot functions __init
       - Merge 32-bit and 64-bit setup_arch()
    
      Other new features:
       - tty/hvc: Use IRQF_SHARED for OPAL hvc consoles from Sam Mendoza-Jonas
       - tty/hvc: Use opal irqchip interface if available from Sam Mendoza-Jonas
       - powerpc: Add module autoloading based on CPU features from Alastair D'Silva
       - crypto: vmx - Convert to CPU feature based module autoloading from Alastair D'Silva
       - Wake up kopald polling thread before waiting for events from Benjamin Herrenschmidt
       - xmon: Dump ISA 2.06 SPRs from Michael Ellerman
       - xmon: Dump ISA 2.07 SPRs from Michael Ellerman
       - Add a parameter to disable 1TB segs from Oliver O'Halloran
       - powerpc/boot: Add OPAL console to epapr wrappers from Oliver O'Halloran
       - Assign fixed PHB number based on device-tree properties from Guilherme G. Piccoli
       - pseries: Add pseries hotplug workqueue from John Allen
       - pseries: Add support for hotplug interrupt source from John Allen
       - pseries: Use kernel hotplug queue for PowerVM hotplug events from John Allen
       - pseries: Move property cloning into its own routine from Nathan Fontenot
       - pseries: Dynamic add entires to associativity lookup array from Nathan Fontenot
       - pseries: Auto-online hotplugged memory from Nathan Fontenot
       - pseries: Remove call to memblock_add() from Nathan Fontenot
    
      cxl:
       - Add set and get private data to context struct from Michael Neuling
       - make base more explicitly non-modular from Paul Gortmaker
       - Use for_each_compatible_node() macro from Wei Yongjun
       - Frederic Barrat
       - Abstract the differences between the PSL and XSL
       - Make vPHB device node match adapter's
       - Philippe Bergheaud
       - Add mechanism for delivering AFU driver specific events
       - Ignore CAPI adapters misplaced in switched slots
       - Refine slice error debug messages
       - Andrew Donnellan
       - static-ify variables to fix sparse warnings
       - PCI/hotplug: pnv_php: export symbols and move struct types needed by cxl
       - PCI/hotplug: pnv_php: handle OPAL_PCI_SLOT_OFFLINE power state
       - Add cxl_check_and_switch_mode() API to switch bi-modal cards
       - remove dead Kconfig options
       - fix potential NULL dereference in free_adapter()
       - Ian Munsie
       - Update process element after allocating interrupts
       - Add support for CAPP DMA mode
       - Fix allowing bogus AFU descriptors with 0 maximum processes
       - Fix allocating a minimum of 2 pages for the SPA
       - Fix bug where AFU disable operation had no effect
       - Workaround XSL bug that does not clear the RA bit after a reset
       - Fix NULL pointer dereference on kernel contexts with no AFU interrupts
       - powerpc/powernv: Split cxl code out into a separate file
       - Add cxl_slot_is_supported API
       - Enable bus mastering for devices using CAPP DMA mode
       - Move cxl_afu_get / cxl_afu_put to base
       - Allow a default context to be associated with an external pci_dev
       - Do not create vPHB if there are no AFU configuration records
       - powerpc/powernv: Add support for the cxl kernel api on the real phb
       - Add support for using the kernel API with a real PHB
       - Add kernel APIs to get & set the max irqs per context
       - Add preliminary workaround for CX4 interrupt limitation
       - Add support for interrupts on the Mellanox CX4
       - Workaround PE=0 hardware limitation in Mellanox CX4
       - powerpc/powernv: Fix pci-cxl.c build when CONFIG_MODULES=n
    
      selftests:
       - Test unaligned copy and paste from Chris Smart
       - Load Monitor Register Tests from Jack Miller
       - Cyril Bur
       - exec() with suspended transaction
       - Use signed long to read perf_event_paranoid
       - Fix usage message in context_switch
       - Fix generation of vector instructions/types in context_switch
       - Michael Ellerman
       - Use "Delta" rather than "Error" in normal output
       - Import Anton's mmap & futex micro benchmarks
       - Add a test for PROT_SAO"
    
    * tag 'powerpc-4.8-1' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux: (263 commits)
      powerpc/mm: Parenthesise IS_ENABLED() in if condition
      tty/hvc: Use opal irqchip interface if available
      tty/hvc: Use IRQF_SHARED for OPAL hvc consoles
      selftests/powerpc: exec() with suspended transaction
      powerpc: Improve comment explaining why we modify VRSAVE
      powerpc/mm: Drop unused externs for hpte_init_beat[_v3]()
      powerpc/mm: Rename hpte_init_lpar() and move the fallback to a header
      powerpc/mm: Fix build break when PPC_NATIVE=n
      crypto: vmx - Convert to CPU feature based module autoloading
      powerpc: Add module autoloading based on CPU features
      powerpc/powernv/ioda: Fix endianness when reading TCEs
      powerpc/mm: Add memory barrier in __hugepte_alloc()
      powerpc/modules: Never restore r2 for a mprofile-kernel style mcount() call
      powerpc/ftrace: Separate the heuristics for checking call sites
      powerpc: Merge 32-bit and 64-bit setup_arch()
      powerpc/64: Make a few boot functions __init
      powerpc: Re-order setup_panic()
      powerpc: Re-order the call to smp_setup_cpu_maps()
      powerpc/32: Move cache info inits to a separate function
      powerpc/64: Move the content of setup_system() to setup_arch()
      ...

commit b9c13fe32faaa71c4e4f8a426d79f8c93495e9f9
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Fri Jul 8 08:35:59 2016 +1000

    dt: Add of_device_compatible_match()
    
    This provides an equivalent of of_fdt_match() for non-flat trees.
    
    This is more practical than matching an array of of_device_id structs
    when converting a bunch of existing users of of_fdt_match().
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index ebf84e3b56d5..c382e1fcd988 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -493,6 +493,28 @@ int of_device_is_compatible(const struct device_node *device,
 }
 EXPORT_SYMBOL(of_device_is_compatible);
 
+/** Checks if the device is compatible with any of the entries in
+ *  a NULL terminated array of strings. Returns the best match
+ *  score or 0.
+ */
+int of_device_compatible_match(struct device_node *device,
+			       const char *const *compat)
+{
+	unsigned int tmp, score = 0;
+
+	if (!compat)
+		return 0;
+
+	while (*compat) {
+		tmp = of_device_is_compatible(device, *compat);
+		if (tmp > score)
+			score = tmp;
+		compat++;
+	}
+
+	return score;
+}
+
 /**
  * of_machine_is_compatible - Test root of device tree for a given compatible value
  * @compat: compatible string to look for in root node's compatible property.

commit 606ad42aa3b1fe8bb122305bef5aea79a6cef54b
Author: Rob Herring <robh@kernel.org>
Date:   Wed Jun 15 08:32:18 2016 -0500

    of: use pr_fmt prefix for all console printing
    
    Clean-up all the DT printk functions to use common pr_fmt prefix.
    
    Some print statements such as kmalloc errors were redundant, so just
    drop those.
    
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    Reviewed-by: Frank Rowand <frank.rowand@am.sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 8bb3d1adf1b0..a4b608776c73 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -17,6 +17,9 @@
  *      as published by the Free Software Foundation; either version
  *      2 of the License, or (at your option) any later version.
  */
+
+#define pr_fmt(fmt)	"OF: " fmt
+
 #include <linux/console.h>
 #include <linux/ctype.h>
 #include <linux/cpu.h>
@@ -130,7 +133,7 @@ static const char *safe_name(struct kobject *kobj, const char *orig_name)
 	if (name == orig_name) {
 		name = kstrdup(orig_name, GFP_KERNEL);
 	} else {
-		pr_warn("device-tree: Duplicate name in %s, renamed to \"%s\"\n",
+		pr_warn("Duplicate name in %s, renamed to \"%s\"\n",
 			kobject_name(kobj), name);
 	}
 	return name;
@@ -204,7 +207,7 @@ void __init of_core_init(void)
 	of_kset = kset_create_and_add("devicetree", NULL, firmware_kobj);
 	if (!of_kset) {
 		mutex_unlock(&of_mutex);
-		pr_err("devicetree: failed to register existing nodes\n");
+		pr_err("failed to register existing nodes\n");
 		return;
 	}
 	for_each_of_allnodes(np)
@@ -2269,8 +2272,8 @@ struct device_node *of_graph_get_next_endpoint(const struct device_node *parent,
 		of_node_put(node);
 
 		if (!port) {
-			pr_err("%s(): no port node found in %s\n",
-			       __func__, parent->full_name);
+			pr_err("graph: no port node found in %s\n",
+			       parent->full_name);
 			return NULL;
 		}
 	} else {

commit d9fc880723321dbf16b2981e3f3e916b73942210
Author: Frank Rowand <frank.rowand@am.sony.com>
Date:   Thu Jun 16 10:51:46 2016 -0700

    of: fix memory leak related to safe_name()
    
    Fix a memory leak resulting from memory allocation in safe_name().
    This patch fixes all call sites of safe_name().
    
    Mathieu Malaterre reported the memory leak on boot:
    
    On my PowerMac device-tree would generate a duplicate name:
    
    [    0.023043] device-tree: Duplicate name in PowerPC,G4@0, renamed to "l2-cache#1"
    
    in this case a newly allocated name is generated by `safe_name`. However
    in this case it is never deallocated.
    
    The bug was found using kmemleak reported as:
    
    unreferenced object 0xdf532e60 (size 32):
      comm "swapper", pid 1, jiffies 4294892300 (age 1993.532s)
      hex dump (first 32 bytes):
        6c 32 2d 63 61 63 68 65 23 31 00 dd e4 dd 1e c2  l2-cache#1......
        ec d4 ba ce 04 ec cc de 8e 85 e9 ca c4 ec cc 9e  ................
      backtrace:
        [<c02d3350>] kvasprintf+0x64/0xc8
        [<c02d3400>] kasprintf+0x4c/0x5c
        [<c0453814>] safe_name.isra.1+0x80/0xc4
        [<c04545d8>] __of_attach_node_sysfs+0x6c/0x11c
        [<c075f21c>] of_core_init+0x8c/0xf8
        [<c0729594>] kernel_init_freeable+0xd4/0x208
        [<c00047e8>] kernel_init+0x24/0x11c
        [<c00158ec>] ret_from_kernel_thread+0x5c/0x64
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=120331
    
    Signed-off-by: Frank Rowand <frank.rowand@am.sony.com>
    Reported-by: mathieu.malaterre@gmail.com
    Tested-by: Mathieu Malaterre <mathieu.malaterre@gmail.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index ebf84e3b56d5..8bb3d1adf1b0 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -112,6 +112,7 @@ static ssize_t of_node_property_read(struct file *filp, struct kobject *kobj,
 	return memory_read_from_buffer(buf, count, &offset, pp->value, pp->length);
 }
 
+/* always return newly allocated name, caller must free after use */
 static const char *safe_name(struct kobject *kobj, const char *orig_name)
 {
 	const char *name = orig_name;
@@ -126,9 +127,12 @@ static const char *safe_name(struct kobject *kobj, const char *orig_name)
 		name = kasprintf(GFP_KERNEL, "%s#%i", orig_name, ++i);
 	}
 
-	if (name != orig_name)
+	if (name == orig_name) {
+		name = kstrdup(orig_name, GFP_KERNEL);
+	} else {
 		pr_warn("device-tree: Duplicate name in %s, renamed to \"%s\"\n",
 			kobject_name(kobj), name);
+	}
 	return name;
 }
 
@@ -159,6 +163,7 @@ int __of_add_property_sysfs(struct device_node *np, struct property *pp)
 int __of_attach_node_sysfs(struct device_node *np)
 {
 	const char *name;
+	struct kobject *parent;
 	struct property *pp;
 	int rc;
 
@@ -171,15 +176,16 @@ int __of_attach_node_sysfs(struct device_node *np)
 	np->kobj.kset = of_kset;
 	if (!np->parent) {
 		/* Nodes without parents are new top level trees */
-		rc = kobject_add(&np->kobj, NULL, "%s",
-				 safe_name(&of_kset->kobj, "base"));
+		name = safe_name(&of_kset->kobj, "base");
+		parent = NULL;
 	} else {
 		name = safe_name(&np->parent->kobj, kbasename(np->full_name));
-		if (!name || !name[0])
-			return -EINVAL;
-
-		rc = kobject_add(&np->kobj, &np->parent->kobj, "%s", name);
+		parent = &np->parent->kobj;
 	}
+	if (!name)
+		return -ENOMEM;
+	rc = kobject_add(&np->kobj, parent, "%s", name);
+	kfree(name);
 	if (rc)
 		return rc;
 
@@ -1815,6 +1821,12 @@ int __of_remove_property(struct device_node *np, struct property *prop)
 	return 0;
 }
 
+void __of_sysfs_remove_bin_file(struct device_node *np, struct property *prop)
+{
+	sysfs_remove_bin_file(&np->kobj, &prop->attr);
+	kfree(prop->attr.attr.name);
+}
+
 void __of_remove_property_sysfs(struct device_node *np, struct property *prop)
 {
 	if (!IS_ENABLED(CONFIG_SYSFS))
@@ -1822,7 +1834,7 @@ void __of_remove_property_sysfs(struct device_node *np, struct property *prop)
 
 	/* at early boot, bail here and defer setup to of_init() */
 	if (of_kset && of_node_is_attached(np))
-		sysfs_remove_bin_file(&np->kobj, &prop->attr);
+		__of_sysfs_remove_bin_file(np, prop);
 }
 
 /**
@@ -1895,7 +1907,7 @@ void __of_update_property_sysfs(struct device_node *np, struct property *newprop
 		return;
 
 	if (oldprop)
-		sysfs_remove_bin_file(&np->kobj, &oldprop->attr);
+		__of_sysfs_remove_bin_file(np, oldprop);
 	__of_add_property_sysfs(np, newprop);
 }
 

commit e7f44b65b532040ac90b73b60ea0b629742ced33
Merge: 76b584d3125a f2c27767af0a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 20 14:51:34 2016 -0700

    Merge tag 'devicetree-for-4.7' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull devicetree updates from Rob Herring:
    
     - Rewrite of the unflattening code to avoid recursion and lessen the
       stack usage.
    
     - Rewrite of the phandle args parsing code to get rid of the fixed args
       size.  This is needed for IOMMU code.
    
     - Sync to latest dtc which adds more dts style checking.  These
       warnings are enabled with "W=1" compiles.
    
     - Tegra documentation updates related to the above warnings.
    
     - A bunch of spelling and other doc fixes.
    
     - Various vendor prefix additions.
    
    * tag 'devicetree-for-4.7' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (52 commits)
      devicetree: Add Creative Technology vendor id
      gpio: dt-bindings: add ibm,ppc4xx-gpio binding
      of/unittest: Remove unnecessary module.h header inclusion
      drivers/of: Fix build warning in populate_node()
      drivers/of: Fix depth when unflattening devicetree
      of: dynamic: changeset prop-update revert fix
      drivers/of: Export of_detach_node()
      drivers/of: Return allocated memory from of_fdt_unflatten_tree()
      drivers/of: Specify parent node in of_fdt_unflatten_tree()
      drivers/of: Rename unflatten_dt_node()
      drivers/of: Avoid recursively calling unflatten_dt_node()
      drivers/of: Split unflatten_dt_node()
      of: include errno.h in of_graph.h
      of: document refcount incrementation of of_get_cpu_node()
      Documentation: dt: soc: fix spelling mistakes
      Documentation: dt: power: fix spelling mistake
      Documentation: dt: pinctrl: fix spelling mistake
      Documentation: dt: opp: fix spelling mistake
      Documentation: dt: net: fix spelling mistakes
      Documentation: dt: mtd: fix spelling mistake
      ...

commit 201b3fe586361c0241105f6e3de2c4749010f897
Author: Suraj Jitindar Singh <sjitindarsingh@gmail.com>
Date:   Thu Apr 28 15:34:54 2016 +1000

    drivers/of: Add check for null property in of_remove_property()
    
    The validity of the property input argument to of_remove_property() is
    never checked within the function and thus it is possible to pass a null
    value. It happens that this will be picked up in __of_remove_property()
    as no matching property of the device node will be found and thus an
    error will be returned, however once again there is no explicit check
    for a null value. By the time this is detected 2 locks have already been
    acquired which is completely unnecessary if the property to remove is
    null.
    
    Add an explicit check in the function of_remove_property() for a null
    property value and return -ENODEV in this case, this is consistent with
    what the previous return value would have been when the null value was
    not detected and passed to __of_remove_property().
    
    By moving an explicit check for the property paramenter into the
    of_remove_property() function, this will remove the need to perform this
    check in calling code before invocation of the of_remove_property()
    function.
    
    Signed-off-by: Suraj Jitindar Singh <sjitindarsingh@gmail.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index b299de2b3afa..64018ebcc861 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1777,6 +1777,9 @@ int of_remove_property(struct device_node *np, struct property *prop)
 	unsigned long flags;
 	int rc;
 
+	if (!prop)
+		return -ENODEV;
+
 	mutex_lock(&of_mutex);
 
 	raw_spin_lock_irqsave(&devtree_lock, flags);

commit 1c986e3643d278d93e9ca67b3c752f486cc32318
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed Apr 20 10:18:46 2016 +0900

    of: document refcount incrementation of of_get_cpu_node()
    
    This function increments refcount.  This is worth noting.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Frank Rowand <frank.rowand@am.sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index e87e21df19d8..116666b088cc 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -394,7 +394,8 @@ bool __weak arch_find_n_match_cpu_physical_id(struct device_node *cpun,
  * before booting secondary cores. This function uses arch_match_cpu_phys_id
  * which can be overridden by architecture specific implementation.
  *
- * Returns a node pointer for the logical cpu if found, else NULL.
+ * Returns a node pointer for the logical cpu with refcount incremented, use
+ * of_node_put() on it when done. Returns NULL if not found.
  */
 struct device_node *of_get_cpu_node(int cpu, unsigned int *thread)
 {

commit abdaa77b18480361f3565d958a2acffad268c39c
Author: Joerg Roedel <jroedel@suse.de>
Date:   Mon Apr 4 17:49:21 2016 +0200

    of: Introduce of_phandle_iterator_args()
    
    This helper function can be used to copy the arguments of a
    phandle to an array.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index ea5a13d3c5a5..e87e21df19d8 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1534,6 +1534,23 @@ int of_phandle_iterator_next(struct of_phandle_iterator *it)
 	return -EINVAL;
 }
 
+int of_phandle_iterator_args(struct of_phandle_iterator *it,
+			     uint32_t *args,
+			     int size)
+{
+	int i, count;
+
+	count = it->cur_count;
+
+	if (WARN_ON(size < count))
+		count = size;
+
+	for (i = 0; i < count; i++)
+		args[i] = be32_to_cpup(it->cur++);
+
+	return count;
+}
+
 static int __of_parse_phandle_with_args(const struct device_node *np,
 					const char *list_name,
 					const char *cells_name,
@@ -1557,13 +1574,13 @@ static int __of_parse_phandle_with_args(const struct device_node *np,
 				goto err;
 
 			if (out_args) {
-				int i;
-				if (WARN_ON(it.cur_count > MAX_PHANDLE_ARGS))
-					it.cur_count = MAX_PHANDLE_ARGS;
+				int c;
+
+				c = of_phandle_iterator_args(&it,
+							     out_args->args,
+							     MAX_PHANDLE_ARGS);
 				out_args->np = it.node;
-				out_args->args_count = it.cur_count;
-				for (i = 0; i < it.cur_count; i++)
-					out_args->args[i] = be32_to_cpup(it.cur++);
+				out_args->args_count = c;
 			} else {
 				of_node_put(it.node);
 			}

commit f623ce95a51baee6a6638f0b025efc0229a9ac0d
Author: Joerg Roedel <jroedel@suse.de>
Date:   Mon Apr 4 17:49:20 2016 +0200

    of: Introduce of_for_each_phandle() helper macro
    
    With this macro any user can easily iterate over a list of
    phandles. The patch also converts __of_parse_phandle_with_args()
    to make use of the macro.
    
    The of_count_phandle_with_args() function is not converted,
    because the macro hides the return value of of_phandle_iterator_init(),
    which is needed in there.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index fcff2b62ec10..ea5a13d3c5a5 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1543,13 +1543,8 @@ static int __of_parse_phandle_with_args(const struct device_node *np,
 	struct of_phandle_iterator it;
 	int rc, cur_index = 0;
 
-	rc = of_phandle_iterator_init(&it, np, list_name,
-				      cells_name, cell_count);
-	if (rc)
-		return rc;
-
 	/* Loop over the phandles until all the requested entry is found */
-	while ((rc = of_phandle_iterator_next(&it)) == 0) {
+	of_for_each_phandle(&it, rc, np, list_name, cells_name, cell_count) {
 		/*
 		 * All of the error cases bail out of the loop, so at
 		 * this point, the parsing is successful. If the requested

commit 2021bd01ffccf2728a591070008d7de5bc41306a
Author: Joerg Roedel <jroedel@suse.de>
Date:   Mon Apr 4 17:49:19 2016 +0200

    of: Remove counting special case from __of_parse_phandle_with_args()
    
    The index = -1 case in __of_parse_phandle_with_args() is
    used to just return the number of phandles. That special
    case needs extra handling, so move it to the place where it
    is needed: of_count_phandle_with_args().
    
    This allows to further simplify __of_parse_phandle_with_args()
    later on.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 69286ec206f7..fcff2b62ec10 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1584,10 +1584,7 @@ static int __of_parse_phandle_with_args(const struct device_node *np,
 	 * Unlock node before returning result; will be one of:
 	 * -ENOENT : index is for empty phandle
 	 * -EINVAL : parsing error on data
-	 * [1..n]  : Number of phandle (count mode; when index = -1)
 	 */
-	if (rc == -ENOENT && index < 0)
-		rc = cur_index;
 
  err:
 	if (it.node)
@@ -1723,8 +1720,20 @@ EXPORT_SYMBOL(of_parse_phandle_with_fixed_args);
 int of_count_phandle_with_args(const struct device_node *np, const char *list_name,
 				const char *cells_name)
 {
-	return __of_parse_phandle_with_args(np, list_name, cells_name, 0, -1,
-					    NULL);
+	struct of_phandle_iterator it;
+	int rc, cur_index = 0;
+
+	rc = of_phandle_iterator_init(&it, np, list_name, cells_name, 0);
+	if (rc)
+		return rc;
+
+	while ((rc = of_phandle_iterator_next(&it)) == 0)
+		cur_index += 1;
+
+	if (rc != -ENOENT)
+		return rc;
+
+	return cur_index;
 }
 EXPORT_SYMBOL(of_count_phandle_with_args);
 

commit cd209b412c8a5d632b51af1e45576f0d00b8105f
Author: Joerg Roedel <jroedel@suse.de>
Date:   Mon Apr 4 17:49:18 2016 +0200

    of: Move phandle walking to of_phandle_iterator_next()
    
    Move the code to walk over the phandles out of the loop in
    __of_parse_phandle_with_args() to a separate function that
    just works with the iterator handle: of_phandle_iterator_next().
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 1c6f43b5737d..69286ec206f7 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1465,6 +1465,75 @@ int of_phandle_iterator_init(struct of_phandle_iterator *it,
 	return 0;
 }
 
+int of_phandle_iterator_next(struct of_phandle_iterator *it)
+{
+	uint32_t count = 0;
+
+	if (it->node) {
+		of_node_put(it->node);
+		it->node = NULL;
+	}
+
+	if (!it->cur || it->phandle_end >= it->list_end)
+		return -ENOENT;
+
+	it->cur = it->phandle_end;
+
+	/* If phandle is 0, then it is an empty entry with no arguments. */
+	it->phandle = be32_to_cpup(it->cur++);
+
+	if (it->phandle) {
+
+		/*
+		 * Find the provider node and parse the #*-cells property to
+		 * determine the argument length.
+		 */
+		it->node = of_find_node_by_phandle(it->phandle);
+
+		if (it->cells_name) {
+			if (!it->node) {
+				pr_err("%s: could not find phandle\n",
+				       it->parent->full_name);
+				goto err;
+			}
+
+			if (of_property_read_u32(it->node, it->cells_name,
+						 &count)) {
+				pr_err("%s: could not get %s for %s\n",
+				       it->parent->full_name,
+				       it->cells_name,
+				       it->node->full_name);
+				goto err;
+			}
+		} else {
+			count = it->cell_count;
+		}
+
+		/*
+		 * Make sure that the arguments actually fit in the remaining
+		 * property data length
+		 */
+		if (it->cur + count > it->list_end) {
+			pr_err("%s: arguments longer than property\n",
+			       it->parent->full_name);
+			goto err;
+		}
+	}
+
+	it->phandle_end = it->cur + count;
+	it->cur_count = count;
+
+	return 0;
+
+err:
+	if (it->node) {
+		of_node_put(it->node);
+		it->node = NULL;
+	}
+
+	return -EINVAL;
+}
+
 static int __of_parse_phandle_with_args(const struct device_node *np,
 					const char *list_name,
 					const char *cells_name,
@@ -1480,59 +1549,9 @@ static int __of_parse_phandle_with_args(const struct device_node *np,
 		return rc;
 
 	/* Loop over the phandles until all the requested entry is found */
-	while (it.cur < it.list_end) {
-		rc = -EINVAL;
-		it.cur_count = 0;
-
-		/*
-		 * If phandle is 0, then it is an empty entry with no
-		 * arguments.  Skip forward to the next entry.
-		 */
-		it.phandle = be32_to_cpup(it.cur++);
-		if (it.phandle) {
-			/*
-			 * Find the provider node and parse the #*-cells
-			 * property to determine the argument length.
-			 *
-			 * This is not needed if the cell count is hard-coded
-			 * (i.e. cells_name not set, but cell_count is set),
-			 * except when we're going to return the found node
-			 * below.
-			 */
-			if (it.cells_name || cur_index == index) {
-				it.node = of_find_node_by_phandle(it.phandle);
-				if (!it.node) {
-					pr_err("%s: could not find phandle\n",
-						it.parent->full_name);
-					goto err;
-				}
-			}
-
-			if (it.cells_name) {
-				if (of_property_read_u32(it.node, it.cells_name,
-							 &it.cur_count)) {
-					pr_err("%s: could not get %s for %s\n",
-						it.parent->full_name, it.cells_name,
-						it.node->full_name);
-					goto err;
-				}
-			} else {
-				it.cur_count = it.cell_count;
-			}
-
-			/*
-			 * Make sure that the arguments actually fit in the
-			 * remaining property data length
-			 */
-			if (it.cur + it.cur_count > it.list_end) {
-				pr_err("%s: arguments longer than property\n",
-					 it.parent->full_name);
-				goto err;
-			}
-		}
-
+	while ((rc = of_phandle_iterator_next(&it)) == 0) {
 		/*
-		 * All of the error cases above bail out of the loop, so at
+		 * All of the error cases bail out of the loop, so at
 		 * this point, the parsing is successful. If the requested
 		 * index matches, then fill the out_args structure and return,
 		 * or return -ENOENT for an empty entry.
@@ -1558,9 +1577,6 @@ static int __of_parse_phandle_with_args(const struct device_node *np,
 			return 0;
 		}
 
-		of_node_put(it.node);
-		it.node = NULL;
-		it.cur += it.cur_count;
 		cur_index++;
 	}
 
@@ -1570,7 +1586,9 @@ static int __of_parse_phandle_with_args(const struct device_node *np,
 	 * -EINVAL : parsing error on data
 	 * [1..n]  : Number of phandle (count mode; when index = -1)
 	 */
-	rc = index < 0 ? cur_index : -ENOENT;
+	if (rc == -ENOENT && index < 0)
+		rc = cur_index;
+
  err:
 	if (it.node)
 		of_node_put(it.node);

commit 74e1fbb1375a3ede3e17da22911761ce9bc8f53f
Author: Joerg Roedel <jroedel@suse.de>
Date:   Mon Apr 4 17:49:17 2016 +0200

    of: Introduce struct of_phandle_iterator
    
    This struct carrys all necessary information to iterate over
    a list of phandles and extract the arguments. Add an
    init-function for the iterator and make use of it in
    __of_parse_phandle_with_args().
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index b299de2b3afa..1c6f43b5737d 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1440,35 +1440,56 @@ void of_print_phandle_args(const char *msg, const struct of_phandle_args *args)
 	printk("\n");
 }
 
+int of_phandle_iterator_init(struct of_phandle_iterator *it,
+		const struct device_node *np,
+		const char *list_name,
+		const char *cells_name,
+		int cell_count)
+{
+	const __be32 *list;
+	int size;
+
+	memset(it, 0, sizeof(*it));
+
+	list = of_get_property(np, list_name, &size);
+	if (!list)
+		return -ENOENT;
+
+	it->cells_name = cells_name;
+	it->cell_count = cell_count;
+	it->parent = np;
+	it->list_end = list + size / sizeof(*list);
+	it->phandle_end = list;
+	it->cur = list;
+
+	return 0;
+}
+
 static int __of_parse_phandle_with_args(const struct device_node *np,
 					const char *list_name,
 					const char *cells_name,
 					int cell_count, int index,
 					struct of_phandle_args *out_args)
 {
-	const __be32 *list, *list_end;
-	int rc = 0, size, cur_index = 0;
-	uint32_t count = 0;
-	struct device_node *node = NULL;
-	phandle phandle;
+	struct of_phandle_iterator it;
+	int rc, cur_index = 0;
 
-	/* Retrieve the phandle list property */
-	list = of_get_property(np, list_name, &size);
-	if (!list)
-		return -ENOENT;
-	list_end = list + size / sizeof(*list);
+	rc = of_phandle_iterator_init(&it, np, list_name,
+				      cells_name, cell_count);
+	if (rc)
+		return rc;
 
 	/* Loop over the phandles until all the requested entry is found */
-	while (list < list_end) {
+	while (it.cur < it.list_end) {
 		rc = -EINVAL;
-		count = 0;
+		it.cur_count = 0;
 
 		/*
 		 * If phandle is 0, then it is an empty entry with no
 		 * arguments.  Skip forward to the next entry.
 		 */
-		phandle = be32_to_cpup(list++);
-		if (phandle) {
+		it.phandle = be32_to_cpup(it.cur++);
+		if (it.phandle) {
 			/*
 			 * Find the provider node and parse the #*-cells
 			 * property to determine the argument length.
@@ -1478,34 +1499,34 @@ static int __of_parse_phandle_with_args(const struct device_node *np,
 			 * except when we're going to return the found node
 			 * below.
 			 */
-			if (cells_name || cur_index == index) {
-				node = of_find_node_by_phandle(phandle);
-				if (!node) {
+			if (it.cells_name || cur_index == index) {
+				it.node = of_find_node_by_phandle(it.phandle);
+				if (!it.node) {
 					pr_err("%s: could not find phandle\n",
-						np->full_name);
+						it.parent->full_name);
 					goto err;
 				}
 			}
 
-			if (cells_name) {
-				if (of_property_read_u32(node, cells_name,
-							 &count)) {
+			if (it.cells_name) {
+				if (of_property_read_u32(it.node, it.cells_name,
+							 &it.cur_count)) {
 					pr_err("%s: could not get %s for %s\n",
-						np->full_name, cells_name,
-						node->full_name);
+						it.parent->full_name, it.cells_name,
+						it.node->full_name);
 					goto err;
 				}
 			} else {
-				count = cell_count;
+				it.cur_count = it.cell_count;
 			}
 
 			/*
 			 * Make sure that the arguments actually fit in the
 			 * remaining property data length
 			 */
-			if (list + count > list_end) {
+			if (it.cur + it.cur_count > it.list_end) {
 				pr_err("%s: arguments longer than property\n",
-					 np->full_name);
+					 it.parent->full_name);
 				goto err;
 			}
 		}
@@ -1518,28 +1539,28 @@ static int __of_parse_phandle_with_args(const struct device_node *np,
 		 */
 		rc = -ENOENT;
 		if (cur_index == index) {
-			if (!phandle)
+			if (!it.phandle)
 				goto err;
 
 			if (out_args) {
 				int i;
-				if (WARN_ON(count > MAX_PHANDLE_ARGS))
-					count = MAX_PHANDLE_ARGS;
-				out_args->np = node;
-				out_args->args_count = count;
-				for (i = 0; i < count; i++)
-					out_args->args[i] = be32_to_cpup(list++);
+				if (WARN_ON(it.cur_count > MAX_PHANDLE_ARGS))
+					it.cur_count = MAX_PHANDLE_ARGS;
+				out_args->np = it.node;
+				out_args->args_count = it.cur_count;
+				for (i = 0; i < it.cur_count; i++)
+					out_args->args[i] = be32_to_cpup(it.cur++);
 			} else {
-				of_node_put(node);
+				of_node_put(it.node);
 			}
 
 			/* Found it! return success */
 			return 0;
 		}
 
-		of_node_put(node);
-		node = NULL;
-		list += count;
+		of_node_put(it.node);
+		it.node = NULL;
+		it.cur += it.cur_count;
 		cur_index++;
 	}
 
@@ -1551,8 +1572,8 @@ static int __of_parse_phandle_with_args(const struct device_node *np,
 	 */
 	rc = index < 0 ? cur_index : -ENOENT;
  err:
-	if (node)
-		of_node_put(node);
+	if (it.node)
+		of_node_put(it.node);
 	return rc;
 }
 

commit fe99c707fc7bb0baba75b26ed585ee3464612dbe
Author: David Rivshin <drivshin@allworx.com>
Date:   Wed Mar 2 16:35:51 2016 -0500

    of: add 'const' for of_property_*_string*() parameter '*np'
    
    The of_property_{read,count,match}_string* family of functions never
    modify the struct device_node pointer that is passed in, so there is no
    reason for it to be non-const. Equivalent functions for all other types
    already take a 'const struct device_node *np'.
    
    Signed-off-by: David Rivshin <drivshin@allworx.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 017dd94f16ea..b299de2b3afa 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1341,10 +1341,10 @@ EXPORT_SYMBOL_GPL(of_property_read_u64_array);
  *
  * The out_string pointer is modified only if a valid string can be decoded.
  */
-int of_property_read_string(struct device_node *np, const char *propname,
+int of_property_read_string(const struct device_node *np, const char *propname,
 				const char **out_string)
 {
-	struct property *prop = of_find_property(np, propname, NULL);
+	const struct property *prop = of_find_property(np, propname, NULL);
 	if (!prop)
 		return -EINVAL;
 	if (!prop->value)
@@ -1365,10 +1365,10 @@ EXPORT_SYMBOL_GPL(of_property_read_string);
  * This function searches a string list property and returns the index
  * of a specific string value.
  */
-int of_property_match_string(struct device_node *np, const char *propname,
+int of_property_match_string(const struct device_node *np, const char *propname,
 			     const char *string)
 {
-	struct property *prop = of_find_property(np, propname, NULL);
+	const struct property *prop = of_find_property(np, propname, NULL);
 	size_t l;
 	int i;
 	const char *p, *end;
@@ -1404,10 +1404,11 @@ EXPORT_SYMBOL_GPL(of_property_match_string);
  * Don't call this function directly. It is a utility helper for the
  * of_property_read_string*() family of functions.
  */
-int of_property_read_string_helper(struct device_node *np, const char *propname,
-				   const char **out_strs, size_t sz, int skip)
+int of_property_read_string_helper(const struct device_node *np,
+				   const char *propname, const char **out_strs,
+				   size_t sz, int skip)
 {
-	struct property *prop = of_find_property(np, propname, NULL);
+	const struct property *prop = of_find_property(np, propname, NULL);
 	int l = 0, i = 0;
 	const char *p, *end;
 

commit 510bd068db34b946a067629679c5cc99c8b99f1e
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed Oct 28 12:05:27 2015 +0900

    of: simplify arch_find_n_match_cpu_physical_id() function
    
    This commit does not change the function behavior.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 8b5a187a7682..017dd94f16ea 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -375,10 +375,7 @@ bool __weak arch_find_n_match_cpu_physical_id(struct device_node *cpun,
 					   cpu, thread))
 		return true;
 
-	if (__of_find_n_match_cpu_property(cpun, "reg", cpu, thread))
-		return true;
-
-	return false;
+	return __of_find_n_match_cpu_property(cpun, "reg", cpu, thread);
 }
 
 /**

commit 4da3064d1775810f10f7ddc1c34c3f1ff502a654
Merge: 93899e39e86b 48a9b733e644
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 1 19:40:18 2015 -0700

    Merge tag 'devicetree-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/glikely/linux
    
    Pull devicetree updates from Grant Likely:
     "A whole lot of bug fixes.
    
      Nothing stands out here except the ability to enable CONFIG_OF on
      every architecture, and an import of a newer version of dtc"
    
    * tag 'devicetree-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/glikely/linux: (22 commits)
      of/irq: Rename "intc_desc" to "of_intc_desc" to fix OF on sh
      of/irq: Fix pSeries boot failure
      Documentation: DT: Fix a typo in the filename "lantiq,<chip>-pinumx.txt"
      of: define of_find_node_by_phandle for !CONFIG_OF
      of/address: use atomic allocation in pci_register_io_range()
      of: Add vendor prefix for Zodiac Inflight Innovations
      dt/fdt: add empty versions of early_init_dt_*_memory_arch
      of: clean-up unnecessary libfdt include paths
      of: make unittest select OF_EARLY_FLATTREE instead of depend on it
      of: make CONFIG_OF user selectable
      MIPS: prepare for user enabling of CONFIG_OF
      of/fdt: fix argument name and add comments of unflatten_dt_node()
      of: return NUMA_NO_NODE from fallback of_node_to_nid()
      tps6507x.txt: Remove executable permission
      of/overlay: Grammar s/an negative/a negative/
      of/fdt: Make fdt blob input parameters of unflatten functions const
      of: add helper function to retrive match data
      of: Grammar s/property exist/property exists/
      of: Move OF flags to be visible even when !CONFIG_OF
      scripts/dtc: Update to upstream version 9d3649bd3be245c9
      ...

commit 099bfbfc7fbbe22356c02f0caf709ac32e1126ea
Merge: 22165fa79814 c5fd936e992d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 26 13:18:51 2015 -0700

    Merge branch 'drm-next' of git://people.freedesktop.org/~airlied/linux
    
    Pull drm updates from Dave Airlie:
     "This is the main drm pull request for v4.2.
    
      I've one other new driver from freescale on my radar, it's been posted
      and reviewed, I'd just like to get someone to give it a last look, so
      maybe I'll send it or maybe I'll leave it.
    
      There is no major nouveau changes in here, Ben was working on
      something big, and we agreed it was a bit late, there wasn't anything
      else he considered urgent to merge.
    
      There might be another msm pull for some bits that are waiting on
      arm-soc, I'll see how we time it.
    
      This touches some "of" stuff, acks are in place except for the fixes
      to the build in various configs,t hat I just applied.
    
      Summary:
    
      New drivers:
          - virtio-gpu:
                    KMS only pieces of driver for virtio-gpu in qemu.
                    This is just the first part of this driver, enough to run
                    unaccelerated userspace on. As qemu merges more we'll start
                    adding the 3D features for the virgl 3d work.
          - amdgpu:
                    a new driver from AMD to driver their newer GPUs. (VI+)
                    It contains a new cleaner userspace API, and is a clean
                    break from radeon moving forward, that AMD are going to
                    concentrate on. It also contains a set of register headers
                    auto generated from AMD internal database.
    
      core:
          - atomic modesetting API completed, enabled by default now.
          - Add support for mode_id blob to atomic ioctl to complete interface.
          - bunch of Displayport MST fixes
          - lots of misc fixes.
    
      panel:
          - new simple panels
          - fix some long-standing build issues with bridge drivers
    
      radeon:
          - VCE1 support
          - add a GPU reset counter for userspace
          - lots of fixes.
    
      amdkfd:
          - H/W debugger support module
          - static user-mode queues
          - support killing all the waves when a process terminates
          - use standard DECLARE_BITMAP
    
      i915:
          - Add Broxton support
          - S3, rotation support for Skylake
          - RPS booting tuning
          - CPT modeset sequence fixes
          - ns2501 dither support
          - enable cmd parser on haswell
          - cdclk handling fixes
          - gen8 dynamic pte allocation
          - lots of atomic conversion work
    
      exynos:
          - Add atomic modesetting support
          - Add iommu support
          - Consolidate drm driver initialization
          - and MIC, DECON and MIPI-DSI support for exynos5433
    
      omapdrm:
          - atomic modesetting support (fixes lots of things in rewrite)
    
      tegra:
          - DP aux transaction fixes
          - iommu support fix
    
      msm:
          - adreno a306 support
          - various dsi bits
          - various 64-bit fixes
          - NV12MT support
    
      rcar-du:
          - atomic and misc fixes
    
      sti:
          - fix HDMI timing complaince
    
      tilcdc:
          - use drm component API to access tda998x driver
          - fix module unloading
    
      qxl:
          - stability fixes"
    
    * 'drm-next' of git://people.freedesktop.org/~airlied/linux: (872 commits)
      drm/nouveau: Pause between setting gpu to D3hot and cutting the power
      drm/dp/mst: close deadlock in connector destruction.
      drm: Always enable atomic API
      drm/vgem: Set unique to "vgem"
      of: fix a build error to of_graph_get_endpoint_by_regs function
      drm/dp/mst: take lock around looking up the branch device on hpd irq
      drm/dp/mst: make sure mst_primary mstb is valid in work function
      of: add EXPORT_SYMBOL for of_graph_get_endpoint_by_regs
      ARM: dts: rename the clock of MIPI DSI 'pll_clk' to 'sclk_mipi'
      drm/atomic: Don't set crtc_state->enable manually
      drm/exynos: dsi: do not set TE GPIO direction by input
      drm/exynos: dsi: add support for MIC driver as a bridge
      drm/exynos: dsi: add support for Exynos5433
      drm/exynos: dsi: make use of array for clock access
      drm/exynos: dsi: make use of driver data for static values
      drm/exynos: dsi: add macros for register access
      drm/exynos: dsi: rename pll_clk to sclk_clk
      drm/exynos: mic: add MIC driver
      of: add helper for getting endpoint node of specific identifiers
      drm/exynos: add Exynos5433 decon driver
      ...

commit 8ffaa90347d80cc20d08c5dd2cdd27dc3fb51b8d
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Jun 23 10:19:10 2015 +1000

    of: add EXPORT_SYMBOL for of_graph_get_endpoint_by_regs
    
    This symbol came via exynos-next, but modular builds are broken
    so just fix it up now.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index f3b583b81105..62bb4ef96c0c 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -2264,6 +2264,7 @@ struct device_node *of_graph_get_endpoint_by_regs(
 
 	return NULL;
 }
+EXPORT_SYMBOL(of_graph_get_endpoint_by_regs);
 
 /**
  * of_graph_get_remote_port_parent() - get remote port's parent node

commit 8ccd0d0ca04147e91890c373677f1e741dda2631
Author: Hyungwon Hwang <human.hwang@samsung.com>
Date:   Fri Jun 12 21:59:01 2015 +0900

    of: add helper for getting endpoint node of specific identifiers
    
    When there are multiple ports or multiple endpoints in a port, they have to be
    distinguished by the value of reg property. It is common. The drivers can get
    the specific endpoint in the specific port via this function. Now the drivers
    have to implement this code in themselves or have to force the order of dt nodes
    to get the right node.
    
    Signed-off-by: Hyungwon Hwang <human.hwang@samsung.com>
    Acked-by: Rob Herring <robh+dt@kernel.org>
    Signed-off-by: Inki Dae <inki.dae@samsung.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 99764db0875a..f3b583b81105 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -2232,6 +2232,39 @@ struct device_node *of_graph_get_next_endpoint(const struct device_node *parent,
 }
 EXPORT_SYMBOL(of_graph_get_next_endpoint);
 
+/**
+ * of_graph_get_endpoint_by_regs() - get endpoint node of specific identifiers
+ * @parent: pointer to the parent device node
+ * @port_reg: identifier (value of reg property) of the parent port node
+ * @reg: identifier (value of reg property) of the endpoint node
+ *
+ * Return: An 'endpoint' node pointer which is identified by reg and at the same
+ * is the child of a port node identified by port_reg. reg and port_reg are
+ * ignored when they are -1.
+ */
+struct device_node *of_graph_get_endpoint_by_regs(
+	const struct device_node *parent, int port_reg, int reg)
+{
+	struct of_endpoint endpoint;
+	struct device_node *node, *prev_node = NULL;
+
+	while (1) {
+		node = of_graph_get_next_endpoint(parent, prev_node);
+		of_node_put(prev_node);
+		if (!node)
+			break;
+
+		of_graph_parse_endpoint(node, &endpoint);
+		if (((port_reg == -1) || (endpoint.port == port_reg)) &&
+			((reg == -1) || (endpoint.id == reg)))
+			return node;
+
+		prev_node = node;
+	}
+
+	return NULL;
+}
+
 /**
  * of_graph_get_remote_port_parent() - get remote port's parent node
  * @node: pointer to a local endpoint device_node

commit c8fff7bc5bba6bd59cad40441c189c4efe7190f6
Author: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
Date:   Wed Apr 8 19:59:20 2015 +0300

    of: return NUMA_NO_NODE from fallback of_node_to_nid()
    
    Node 0 might be offline as well as any other numa node,
    in this case kernel cannot handle memory allocation and crashes.
    
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Fixes: 0c3f061c195c ("of: implement of_node_to_nid as a weak function")
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 99764db0875a..8e39b38ca206 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -89,7 +89,7 @@ EXPORT_SYMBOL(of_n_size_cells);
 #ifdef CONFIG_NUMA
 int __weak of_node_to_nid(struct device_node *np)
 {
-	return numa_node_id();
+	return NUMA_NO_NODE;
 }
 #endif
 

commit 194ec9368c0dbc421acdb2620d4dfb3cc3d022ff
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Thu May 14 15:28:24 2015 +0100

    drivers: of/base: move of_init to driver_init
    
    Commit 5590f3196b29 ("drivers/core/of: Add symlink to device-tree from
    devices with an OF node") adds the symlink `of_node` for each device
    pointing to it's device tree node while creating/initialising it.
    
    However the devicetree sysfs is created and setup in of_init which is
    executed at core_initcall level. For all the devices created before
    of_init, the following error is thrown:
            "Error -2(-ENOENT) creating of_node link"
    
    Like many other components in driver model, initialize the sysfs support
    for OF/devicetree from driver_init so that it's ready before any devices
    are created.
    
    Fixes: 5590f3196b29 ("drivers/core/of: Add symlink to device-tree from
            devices with an OF node")
    Suggested-by: Rob Herring <robh+dt@kernel.org>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Pawel Moll <pawel.moll@arm.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Tested-by: Robert Schwebel <r.schwebel@pengutronix.de>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 99764db0875a..f0650265febf 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -189,7 +189,7 @@ int __of_attach_node_sysfs(struct device_node *np)
 	return 0;
 }
 
-static int __init of_init(void)
+void __init of_core_init(void)
 {
 	struct device_node *np;
 
@@ -198,7 +198,8 @@ static int __init of_init(void)
 	of_kset = kset_create_and_add("devicetree", NULL, firmware_kobj);
 	if (!of_kset) {
 		mutex_unlock(&of_mutex);
-		return -ENOMEM;
+		pr_err("devicetree: failed to register existing nodes\n");
+		return;
 	}
 	for_each_of_allnodes(np)
 		__of_attach_node_sysfs(np);
@@ -207,10 +208,7 @@ static int __init of_init(void)
 	/* Symlink in /proc as required by userspace ABI */
 	if (of_root)
 		proc_symlink("device-tree", NULL, "/sys/firmware/devicetree/base");
-
-	return 0;
 }
-core_initcall(of_init);
 
 static struct property *__of_find_property(const struct device_node *np,
 					   const char *name, int *lenp)

commit d56a669ca59c37ed0a7282a251b2f2f22533343a
Merge: 836ee4874e20 04fca0e390e8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 24 08:46:18 2015 -0700

    Merge tag 'devicetree-for-4.1' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull second batch of devicetree updates from Rob Herring:
     "As Grant mentioned in the first devicetree pull request, here is the
      2nd batch of DT changes for 4.1.  The main remaining item here is the
      endianness bindings and related 8250 driver support.
    
       - DT endianness specification bindings
    
       - big-endian 8250 serial support
    
       - DT overlay unittest updates
    
       - various DT doc updates
    
       - compile fixes for OF_IRQ=n"
    
    * tag 'devicetree-for-4.1' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux:
      frv: add io{read,write}{16,32}be functions
      mn10300: add io{read,write}{16,32}be functions
      Documentation: DT bindings: add doc for Altera's SoCFPGA platform
      of: base: improve of_get_next_child() kernel-doc
      Doc: dt: arch_timer: discourage clock-frequency use
      of: unittest: overlay: Keep track of created overlays
      of/fdt: fix allocation size for device node path
      serial: of_serial: Support big-endian register accesses
      serial: 8250: Add support for big-endian MMIO accesses
      of: Document {little,big,native}-endian bindings
      of/fdt: Add endianness helper function for early init code
      of: Add helper function to check MMIO register endianness
      of/fdt: Remove "reg" data prints from early_init_dt_scan_memory
      of: add vendor prefix for Artesyn
      of: Add dummy of_irq_to_resource_table() for IRQ_OF=n
      of: OF_IRQ should depend on IRQ_DOMAIN

commit 7505256626b0b3d11ea5a3ec1a89046d07c3c366
Merge: 510965dd4a0a a2166ca5f320
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Apr 18 08:30:10 2015 -0400

    Merge tag 'devicetree-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/glikely/linux
    
    Pull devicetree changes from Grant Likely:
     "Here are the devicetree changes queued up for v4.1.  Nothing really
      exciting here.  Rob has another few commits for big-endian attached
      UARTs, but those will be sent in a separate merge request since they
      haven't been as thoroughly tested as this batch.
    
      Here are the highlights:
    
       - lots of unittest cleanup from Frank Rowand
    
       - bugfixes and updates to the of_graph code
    
       - tighten up of_get_mac_address() code
    
       - documentation updates"
    
    * tag 'devicetree-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/glikely/linux:
      of/unittest: Fix of_platform_depopulate test case
      of/unittest: early return from test skips tests
      of/unittest: breadcrumbs to reduce pain of future maintainers
      of/unittest: reduce checkpatch noise - line after declarations
      of/unittest: typo in error string
      of/unittest: add const where needed
      of_net: factor out repetitive code from of_get_mac_address()
      drivers/of: Add empty ranges quirk for PA-Semi
      of: Allow selection of OF_DYNAMIC and OF_OVERLAY if OF_UNITTEST
      of: Empty node & property flag accessors when !OF
      of: Explicitly include linux/types.h in of_graph.h
      dt-bindings: brcm: rationalize Broadcom documentation naming
      of/unittest: replace 'selftest' with 'unittest'
      Documentation: rename of_selftest.txt to of_unittest.txt
      Documentation: update the of_selftest.txt
      dt: OF_UNITTEST make dependency broken
      MAINTAINERS: Pantelis Antoniou device tree overlay maintainer
      of: Add of_graph_get_port_by_id function
      of: Add for_each_endpoint_of_node helper macro
      of: Decrement refcount of previous endpoint in of_graph_get_next_endpoint

commit 6480827357923b3977b97c9413a7307be850975d
Author: Baruch Siach <baruch@tkos.co.il>
Date:   Thu Mar 19 14:03:41 2015 +0200

    of: base: improve of_get_next_child() kernel-doc
    
    Add two new facts to of_get_next_child() documentation:
    
       * of_get_next_child() returns NULL when there is not next child
    
       * of_get_next_child() decrements the refcount of prev
    
    Signed-off-by: Baruch Siach <baruch@tkos.co.il>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 31ca3c8dae61..7183e825d658 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -663,8 +663,9 @@ static struct device_node *__of_get_next_child(const struct device_node *node,
  *	@node:	parent node
  *	@prev:	previous child of the parent node, or NULL to get first
  *
- *	Returns a node pointer with refcount incremented, use
- *	of_node_put() on it when done.
+ *	Returns a node pointer with refcount incremented, use of_node_put() on
+ *	it when done. Returns NULL when prev is the last child. Decrements the
+ *	refcount of prev.
  */
 struct device_node *of_get_next_child(const struct device_node *node,
 	struct device_node *prev)

commit c3a416a669eb83cfa9ccb52db030e72d654bd105
Merge: 8c194f3bd322 2bbd681ba2bf
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 14 18:10:45 2015 -0700

    Merge branch 'i2c/for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux
    
    Pull i2c updates from Wolfram Sang:
     "Most notable:
    
       - introducing the i2c_quirk infrastructure.  Now, flaws of I2C
         controllers can be described and the core will check if the flaws
         collide with the messages to be sent
    
       - wait_for_completion return type cleanup series
    
       - new drivers for Digicolor, Netlogic XLP, Ingenic JZ4780
    
       - updates to the I2C slave framework which include API changes.  Its
         only user was updated, too.  Documentation was finally added
    
       - changed dynamic bus numbering for the DT case.  This could change
         bus numbers for users.  However, it fixes a collision where dynamic
         and static busses request the same id.
    
       - driver bugfixes, cleanups"
    
    * 'i2c/for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux: (52 commits)
      i2c: xlp9xx: Driver for Netlogic XLP9XX/5XX I2C controller
      of: Add vendor prefix 'netlogic'
      i2c: davinci: use ICPFUNC to toggle I2C as gpio for bus recovery
      i2c: davinci: use bus recovery infrastructure
      i2c: change input parameter to i2c_adapter for prepare/unprepare_recovery
      i2c: i2c-mux-gpio: remove error messages for probe deferrals
      i2c: jz4780: Add i2c bus controller driver for Ingenic JZ4780
      i2c: dln2: set the device tree node of the adapter
      i2c: davinci: fixup wait_for_completion_timeout handling
      i2c: mpc: Fix ISR return value
      i2c: slave-eeprom: add more info when to increase the pointer
      i2c: slave: add documentation for i2c-slave-eeprom
      Documentation: i2c: describe the new slave mode
      i2c: slave: rework the slave API
      i2c: add support for the Digicolor I2C controller
      i2c: busses with dynamic ids should start after fixed ids for DT
      of: base: add function to get highest id of an alias stem
      i2c: designware: Suppress error message if platform_get_irq() < 0
      i2c: mpc: assign the correct prescaler from SVR
      i2c: img-scb: fixup of wait_for_completion_timeout return handling
      ...

commit 37786c7fee40771d13901de129af7e084ed48b55
Author: Kevin Cernekee <cernekee@gmail.com>
Date:   Thu Apr 9 13:05:14 2015 -0700

    of: Add helper function to check MMIO register endianness
    
    SoC peripherals can come in several different flavors:
    
     - little-endian: registers always need to be accessed in LE mode (so the
       kernel should perform a swap if the CPU is running BE)
    
     - big-endian: registers always need to be accessed in BE mode (so the
       kernel should perform a swap if the CPU is running LE)
    
     - native-endian: the bus will automatically swap accesses, so the kernel
       should never swap
    
    Introduce a function that checks an OF device node to see whether it
    contains a "big-endian" or "native-endian" property.  For the former case,
    always return true.  For the latter case, return true iff the kernel was
    built for BE (implying that the BE MMIO accessors do not perform a swap).
    Otherwise return false, assuming LE registers.
    
    LE registers are assumed by default because most existing drivers (libahci,
    serial8250, usb) always use readl/writel in the absence of instructions
    to the contrary, so that will be our fallback.
    
    Signed-off-by: Kevin Cernekee <cernekee@gmail.com>
    Reviewed-by: Peter Hurley <peter@hurleysoftware.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 69566b6a876d..31ca3c8dae61 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -567,6 +567,29 @@ bool of_device_is_available(const struct device_node *device)
 }
 EXPORT_SYMBOL(of_device_is_available);
 
+/**
+ *  of_device_is_big_endian - check if a device has BE registers
+ *
+ *  @device: Node to check for endianness
+ *
+ *  Returns true if the device has a "big-endian" property, or if the kernel
+ *  was compiled for BE *and* the device has a "native-endian" property.
+ *  Returns false otherwise.
+ *
+ *  Callers would nominally use ioread32be/iowrite32be if
+ *  of_device_is_big_endian() == true, or readl/writel otherwise.
+ */
+bool of_device_is_big_endian(const struct device_node *device)
+{
+	if (of_property_read_bool(device, "big-endian"))
+		return true;
+	if (IS_ENABLED(CONFIG_CPU_BIG_ENDIAN) &&
+	    of_property_read_bool(device, "native-endian"))
+		return true;
+	return false;
+}
+EXPORT_SYMBOL(of_device_is_big_endian);
+
 /**
  *	of_get_parent - Get a node's parent if any
  *	@node:	Node to get parent

commit 8147e2e8f13d823307e1edf2add5a8df84180cca
Merge: bc465aa9d045 bfe446e37c4e
Author: Rob Herring <robh@kernel.org>
Date:   Wed Mar 25 00:41:08 2015 -0500

    Merge tag 'of-graph-for-4.0' of git://git.pengutronix.de/git/pza/linux into for-next
    
    Pull of-graph helpers from Philipp Zabel:
    of: Add of-graph helpers to loop over endpoints and find ports by id
    
    This series converts of_graph_get_next_endpoint to decrement the refcount of
    the passed prev parameter. This allows to add a for_each_endpoint_of_node
    helper macro to loop over all endpoints in a device tree node.
    The of_graph_get_port_by_id function is added to retrieve a port by its known
    port id (contained in the reg property) from the device tree.

commit f64255b5072d9c46cef8655d51cf7e10285abed7
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Tue Mar 17 16:46:33 2015 -0400

    Revert "of: Fix premature bootconsole disable with 'stdout-path'"
    
    This reverts commit 2fa645cb2703d9b3786d850db815414dfeefa51d.
    
    The assumption that at least 1 preferred console will be registered
    when the stdout-path property is set is invalid, which can result
    in _no_ consoles.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 966d6fdcf427..8f165b112e03 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1888,10 +1888,8 @@ void of_alias_scan(void * (*dt_alloc)(u64 size, u64 align))
 			name = of_get_property(of_chosen, "linux,stdout-path", NULL);
 		if (IS_ENABLED(CONFIG_PPC) && !name)
 			name = of_get_property(of_aliases, "stdout", NULL);
-		if (name) {
+		if (name)
 			of_stdout = of_find_node_opts_by_path(name, &of_stdout_options);
-			add_preferred_console("stdout-path", 0, NULL);
-		}
 	}
 
 	if (!of_aliases)

commit 721a09e95c786346b4188863a1cfa3909c76f690
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Mar 17 12:30:31 2015 -0700

    of: handle both '/' and ':' in path strings
    
    Commit 106937e8ccdc ("of: fix handling of '/' in options for
    of_find_node_by_path()") caused a regression in OF handling of
    stdout-path. While it fixes some cases which have '/' after the ':', it
    breaks cases where there is more than one '/' *before* the ':'.
    
    For example, it breaks this boot string
    
      stdout-path = "/rdb/serial@f040ab00:115200";
    
    So rather than doing sequentialized checks (first for '/', then for ':';
    or vice versa), to get the correct behavior we need to check for the
    first occurrence of either one of them.
    
    It so happens that the handy strcspn() helper can do just that.
    
    Fixes: 106937e8ccdc ("of: fix handling of '/' in options for of_find_node_by_path()")
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Cc: stable@vger.kernel.org # 3.19
    Acked-by: Leif Lindholm <leif.lindholm@linaro.org>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index adb8764861c0..966d6fdcf427 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -715,13 +715,8 @@ static struct device_node *__of_find_node_by_path(struct device_node *parent,
 {
 	struct device_node *child;
 	int len;
-	const char *end;
 
-	end = strchr(path, ':');
-	if (!end)
-		end = strchrnul(path, '/');
-
-	len = end - path;
+	len = strcspn(path, "/:");
 	if (!len)
 		return NULL;
 

commit 351d224f64afc1b3b359a1738b7d4600c7e64061
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Thu Mar 12 17:17:58 2015 +0100

    of: base: add function to get highest id of an alias stem
    
    I2C supports adding adapters using either a dynamic or fixed id. The
    latter is provided by aliases in the DT case. To prevent id collisions
    of those two types, install this function which gives us the highest
    fixed id, so we can then let the dynamically created ones come after
    this highest number.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 0a8aeb8523fe..63cba04aacf6 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1958,6 +1958,32 @@ int of_alias_get_id(struct device_node *np, const char *stem)
 }
 EXPORT_SYMBOL_GPL(of_alias_get_id);
 
+/**
+ * of_alias_get_highest_id - Get highest alias id for the given stem
+ * @stem:	Alias stem to be examined
+ *
+ * The function travels the lookup table to get the highest alias id for the
+ * given alias stem.  It returns the alias id if found.
+ */
+int of_alias_get_highest_id(const char *stem)
+{
+	struct alias_prop *app;
+	int id = -ENODEV;
+
+	mutex_lock(&of_mutex);
+	list_for_each_entry(app, &aliases_lookup, link) {
+		if (strcmp(app->stem, stem) != 0)
+			continue;
+
+		if (app->id > id)
+			id = app->id;
+	}
+	mutex_unlock(&of_mutex);
+
+	return id;
+}
+EXPORT_SYMBOL_GPL(of_alias_get_highest_id);
+
 const __be32 *of_prop_next_u32(struct property *prop, const __be32 *cur,
 			       u32 *pu)
 {

commit 106937e8ccdcf0f4b95fbf0fe9abd42766cade33
Author: Leif Lindholm <leif.lindholm@linaro.org>
Date:   Fri Mar 6 16:52:53 2015 +0000

    of: fix handling of '/' in options for of_find_node_by_path()
    
    Ensure proper handling of paths with appended options (after ':'),
    where those options may contain a '/'.
    
    Fixes: 7914a7c5651a ("of: support passing console options with stdout-path")
    Reported-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Leif Lindholm <leif.lindholm@linaro.org>
    Cc: <stable@vger.kernel.org> # 3.19
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 3b1aa08bf5f3..adb8764861c0 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -714,16 +714,17 @@ static struct device_node *__of_find_node_by_path(struct device_node *parent,
 						const char *path)
 {
 	struct device_node *child;
-	int len = strchrnul(path, '/') - path;
-	int term;
+	int len;
+	const char *end;
 
+	end = strchr(path, ':');
+	if (!end)
+		end = strchrnul(path, '/');
+
+	len = end - path;
 	if (!len)
 		return NULL;
 
-	term = strchrnul(path, ':') - path;
-	if (term < len)
-		len = term;
-
 	__for_each_child_of_node(parent, child) {
 		const char *name = strrchr(child->full_name, '/');
 		if (WARN(!name, "malformed device_node %s\n", child->full_name))
@@ -768,8 +769,12 @@ struct device_node *of_find_node_opts_by_path(const char *path, const char **opt
 
 	/* The path could begin with an alias */
 	if (*path != '/') {
-		char *p = strchrnul(path, '/');
-		int len = separator ? separator - path : p - path;
+		int len;
+		const char *p = separator;
+
+		if (!p)
+			p = strchrnul(path, '/');
+		len = p - path;
 
 		/* of_aliases must not be NULL */
 		if (!of_aliases)
@@ -794,6 +799,8 @@ struct device_node *of_find_node_opts_by_path(const char *path, const char **opt
 		path++; /* Increment past '/' delimiter */
 		np = __of_find_node_by_path(np, path);
 		path = strchrnul(path, '/');
+		if (separator && separator < path)
+			break;
 	}
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 	return np;

commit 2fa645cb2703d9b3786d850db815414dfeefa51d
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sun Mar 1 12:21:22 2015 -0500

    of: Fix premature bootconsole disable with 'stdout-path'
    
    Support for devicetree serial consoles via 'stdout-path' causes
    bootconsoles to be disabled when the vt dummy console loads, since
    there is no preferred console (the preferred console is not added
    until the device is probed).
    
    Ensure there is at least a preferred console, even if never matched.
    
    Requires: "console: Fix console name size mismatch"
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 0a8aeb8523fe..3b1aa08bf5f3 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1886,8 +1886,10 @@ void of_alias_scan(void * (*dt_alloc)(u64 size, u64 align))
 			name = of_get_property(of_chosen, "linux,stdout-path", NULL);
 		if (IS_ENABLED(CONFIG_PPC) && !name)
 			name = of_get_property(of_aliases, "stdout", NULL);
-		if (name)
+		if (name) {
 			of_stdout = of_find_node_opts_by_path(name, &of_stdout_options);
+			add_preferred_console("stdout-path", 0, NULL);
+		}
 	}
 
 	if (!of_aliases)

commit bfe446e37c4efd8ade454911e8f80414bcbfc10d
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Tue Mar 11 11:21:11 2014 +0100

    of: Add of_graph_get_port_by_id function
    
    This patch adds a function to get a port device tree node by port id,
    or reg property value.
    
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 05b20f1cca7b..6398b9ca9157 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -2080,6 +2080,38 @@ int of_graph_parse_endpoint(const struct device_node *node,
 }
 EXPORT_SYMBOL(of_graph_parse_endpoint);
 
+/**
+ * of_graph_get_port_by_id() - get the port matching a given id
+ * @parent: pointer to the parent device node
+ * @id: id of the port
+ *
+ * Return: A 'port' node pointer with refcount incremented. The caller
+ * has to use of_node_put() on it when done.
+ */
+struct device_node *of_graph_get_port_by_id(struct device_node *parent, u32 id)
+{
+	struct device_node *node, *port;
+
+	node = of_get_child_by_name(parent, "ports");
+	if (node)
+		parent = node;
+
+	for_each_child_of_node(parent, port) {
+		u32 port_id = 0;
+
+		if (of_node_cmp(port->name, "port") != 0)
+			continue;
+		of_property_read_u32(port, "reg", &port_id);
+		if (id == port_id)
+			break;
+	}
+
+	of_node_put(node);
+
+	return port;
+}
+EXPORT_SYMBOL(of_graph_get_port_by_id);
+
 /**
  * of_graph_get_next_endpoint() - get next endpoint node
  * @parent: pointer to the parent device node

commit f033c0bcc53675562200680f4cb4a86710d9fbae
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Mon Dec 1 13:32:32 2014 +0100

    of: Decrement refcount of previous endpoint in of_graph_get_next_endpoint
    
    Decrementing the reference count of the previous endpoint node allows to
    use the of_graph_get_next_endpoint function in a for_each_... style macro.
    All current users of this function that pass a non-NULL prev parameter
    (that is, soc_camera and imx-drm) are changed to not decrement the passed
    prev argument's refcount themselves.
    
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Acked-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 0a8aeb8523fe..05b20f1cca7b 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -2086,8 +2086,7 @@ EXPORT_SYMBOL(of_graph_parse_endpoint);
  * @prev: previous endpoint node, or NULL to get first
  *
  * Return: An 'endpoint' node pointer with refcount incremented. Refcount
- * of the passed @prev node is not decremented, the caller have to use
- * of_node_put() on it when done.
+ * of the passed @prev node is decremented.
  */
 struct device_node *of_graph_get_next_endpoint(const struct device_node *parent,
 					struct device_node *prev)
@@ -2123,12 +2122,6 @@ struct device_node *of_graph_get_next_endpoint(const struct device_node *parent,
 		if (WARN_ONCE(!port, "%s(): endpoint %s has no parent node\n",
 			      __func__, prev->full_name))
 			return NULL;
-
-		/*
-		 * Avoid dropping prev node refcount to 0 when getting the next
-		 * child below.
-		 */
-		of_node_get(prev);
 	}
 
 	while (1) {

commit 2d4c0aef0ff4d4374590d6c7b259a259bb2cb21b
Author: Sakari Ailus <sakari.ailus@iki.fi>
Date:   Tue Jan 27 12:26:35 2015 +0200

    of: EXPORT_SYMBOL_GPL of_property_read_u64_array
    
    Make of_property_read_u64_array() available for modules as well. This was
    missing from the patch which originally added the function.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@iki.fi>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 36536b6a8834..0a8aeb8523fe 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1303,6 +1303,7 @@ int of_property_read_u64_array(const struct device_node *np,
 	}
 	return 0;
 }
+EXPORT_SYMBOL_GPL(of_property_read_u64_array);
 
 /**
  * of_property_read_string - Find and read a string from a property

commit 7ef58b32f571bffb7763c6252ad7527562081f34
Merge: 413fd0e3fbf5 c46ca3c8310b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 11 13:06:58 2014 -0800

    Merge tag 'devicetree-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/glikely/linux
    
    Pull devicetree changes from Grant Likely:
     "Lots of activity in the devicetree code for v3.18.  Most of it is
      related to getting all of the overlay support code in place, but there
      are other important things in there.
    
      Highlights:
    
       - OF_RECONFIG notifiers for SPI, I2C and Platform devices.  Those
         subsystems can now respond to live changes to the device tree.
    
       - CONFIG_OF_OVERLAY method for applying live changes to the device
         tree
    
       - Removal of the of_allnodes list.  This used to be used to iterate
         over all the nodes in the device tree, but it is unnecessary
         because the same thing can be done by iterating over the list of
         child pointers.  Getting rid of of_allnodes saves some memory and
         avoids the possibility of of_allnodes being sorted differently from
         the child lists.
    
       - Support for retrieving original DTB blob via sysfs.  Needed by
         kexec.
    
       - More unittests
    
       - Documentation and minor bug fixes"
    
    * tag 'devicetree-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/glikely/linux: (42 commits)
      of: Delete unnecessary check before calling "of_node_put()"
      of: Drop ->next pointer from struct device_node
      spi: Check for spi_of_notifier when CONFIG_OF_DYNAMIC=y
      of: support passing console options with stdout-path
      of: add optional options parameter to of_find_node_by_path()
      of: Add bindings for chosen node, stdout-path
      of: Remove unneeded and incorrect MODULE_DEVICE_TABLE
      ARM: dt: fix up PL011 device tree bindings
      of: base, fix of_property_read_string_helper kernel-doc
      of: remove select of non-existant OF_DEVICE config symbol
      spi/of: Add OF notifier handler
      spi/of: Create new device registration method and accessors
      i2c/of: Add OF_RECONFIG notifier handler
      i2c/of: Factor out Devicetree registration code
      of/overlay: Add overlay unittests
      of/overlay: Introduce DT overlay support
      of/reconfig: Add OF_DYNAMIC notifier for platform_bus_type
      of/reconfig: Always use the same structure for notifiers
      of/reconfig: Add debug output for OF_RECONFIG notifiers
      of/reconfig: Add empty stubs for the of_reconfig methods
      ...

commit 7914a7c5651a51617d952e8fa745000ed8c4f001
Author: Leif Lindholm <leif.lindholm@linaro.org>
Date:   Thu Nov 27 17:56:07 2014 +0000

    of: support passing console options with stdout-path
    
    Support specifying console options (like with console=ttyXN,<options>)
    by appending them to the stdout-path property after a separating ':'.
    
    Example:
            stdout-path = "uart0:115200";
    
    Signed-off-by: Leif Lindholm <leif.lindholm@linaro.org>
    [grant.likely: minor rework to shorten the diffstat]
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index bdf051d0a7e6..f2be7c860cf2 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -37,6 +37,7 @@ EXPORT_SYMBOL(of_root);
 struct device_node *of_chosen;
 struct device_node *of_aliases;
 struct device_node *of_stdout;
+static const char *of_stdout_options;
 
 struct kset *of_kset;
 
@@ -1852,7 +1853,7 @@ void of_alias_scan(void * (*dt_alloc)(u64 size, u64 align))
 		if (IS_ENABLED(CONFIG_PPC) && !name)
 			name = of_get_property(of_aliases, "stdout", NULL);
 		if (name)
-			of_stdout = of_find_node_by_path(name);
+			of_stdout = of_find_node_opts_by_path(name, &of_stdout_options);
 	}
 
 	if (!of_aliases)
@@ -1978,7 +1979,8 @@ bool of_console_check(struct device_node *dn, char *name, int index)
 {
 	if (!dn || dn != of_stdout || console_set_on_cmdline)
 		return false;
-	return !add_preferred_console(name, index, NULL);
+	return !add_preferred_console(name, index,
+				      kstrdup(of_stdout_options, GFP_KERNEL));
 }
 EXPORT_SYMBOL_GPL(of_console_check);
 

commit 75c28c09af99a0db0ccd8b4395469761aa736543
Author: Leif Lindholm <leif.lindholm@linaro.org>
Date:   Fri Nov 28 11:34:28 2014 +0000

    of: add optional options parameter to of_find_node_by_path()
    
    Update of_find_node_by_path():
    1) Rename function to of_find_node_opts_by_path(), adding an optional
       pointer argument. Provide a static inline wrapper version of
       of_find_node_by_path() which calls the new function with NULL as
       the optional argument.
    2) Ignore any part of the path beyond and including the ':' separator.
    3) Set the new provided pointer argument to the beginning of the string
       following the ':' separator.
    4: Add tests.
    
    Signed-off-by: Leif Lindholm <leif.lindholm@linaro.org>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 99bc95e83d09..bdf051d0a7e6 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -714,10 +714,15 @@ static struct device_node *__of_find_node_by_path(struct device_node *parent,
 {
 	struct device_node *child;
 	int len = strchrnul(path, '/') - path;
+	int term;
 
 	if (!len)
 		return NULL;
 
+	term = strchrnul(path, ':') - path;
+	if (term < len)
+		len = term;
+
 	__for_each_child_of_node(parent, child) {
 		const char *name = strrchr(child->full_name, '/');
 		if (WARN(!name, "malformed device_node %s\n", child->full_name))
@@ -730,11 +735,14 @@ static struct device_node *__of_find_node_by_path(struct device_node *parent,
 }
 
 /**
- *	of_find_node_by_path - Find a node matching a full OF path
+ *	of_find_node_opts_by_path - Find a node matching a full OF path
  *	@path: Either the full path to match, or if the path does not
  *	       start with '/', the name of a property of the /aliases
  *	       node (an alias).  In the case of an alias, the node
  *	       matching the alias' value will be returned.
+ *	@opts: Address of a pointer into which to store the start of
+ *	       an options string appended to the end of the path with
+ *	       a ':' separator.
  *
  *	Valid paths:
  *		/foo/bar	Full path
@@ -744,11 +752,15 @@ static struct device_node *__of_find_node_by_path(struct device_node *parent,
  *	Returns a node pointer with refcount incremented, use
  *	of_node_put() on it when done.
  */
-struct device_node *of_find_node_by_path(const char *path)
+struct device_node *of_find_node_opts_by_path(const char *path, const char **opts)
 {
 	struct device_node *np = NULL;
 	struct property *pp;
 	unsigned long flags;
+	const char *separator = strchr(path, ':');
+
+	if (opts)
+		*opts = separator ? separator + 1 : NULL;
 
 	if (strcmp(path, "/") == 0)
 		return of_node_get(of_root);
@@ -756,7 +768,7 @@ struct device_node *of_find_node_by_path(const char *path)
 	/* The path could begin with an alias */
 	if (*path != '/') {
 		char *p = strchrnul(path, '/');
-		int len = p - path;
+		int len = separator ? separator - path : p - path;
 
 		/* of_aliases must not be NULL */
 		if (!of_aliases)
@@ -785,7 +797,7 @@ struct device_node *of_find_node_by_path(const char *path)
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 	return np;
 }
-EXPORT_SYMBOL(of_find_node_by_path);
+EXPORT_SYMBOL(of_find_node_opts_by_path);
 
 /**
  *	of_find_node_by_name - Find a node by its "name" property

commit e99010edb37f5d5bca6a4d4b78d74cddfc0fc5a4
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Fri Nov 21 13:23:09 2014 +0100

    of: base, fix of_property_read_string_helper kernel-doc
    
    It referenced of_property_read_string_util whereas the function name
    is of_property_read_string_helper.
    
    Introduced in a87fa1d81a9fb5e9adca9820e16008c40ad09f33 (of: Fix
    overflow bug in string property parsing functions). Found out when
    reviewing the stable 3.12 queue.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 2d5dfb8b2e65..99bc95e83d09 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1326,7 +1326,7 @@ int of_property_match_string(struct device_node *np, const char *propname,
 EXPORT_SYMBOL_GPL(of_property_match_string);
 
 /**
- * of_property_read_string_util() - Utility helper for parsing string properties
+ * of_property_read_string_helper() - Utility helper for parsing string properties
  * @np:		device node from which the property value is to be read.
  * @propname:	name of the property to be searched.
  * @out_strs:	output array of string pointers.

commit 53a4ab96c61a34d62717b1481f6043e0b4338d74
Author: Kevin Cernekee <cernekee@gmail.com>
Date:   Wed Nov 12 12:54:01 2014 -0800

    of: Change of_device_is_available() to return bool
    
    This function can only return true or false; using a bool makes it more
    obvious to the reader.
    
    Signed-off-by: Kevin Cernekee <cernekee@gmail.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 4627e0acf4ad..2d5dfb8b2e65 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -522,27 +522,27 @@ EXPORT_SYMBOL(of_machine_is_compatible);
  *
  *  @device: Node to check for availability, with locks already held
  *
- *  Returns 1 if the status property is absent or set to "okay" or "ok",
- *  0 otherwise
+ *  Returns true if the status property is absent or set to "okay" or "ok",
+ *  false otherwise
  */
-static int __of_device_is_available(const struct device_node *device)
+static bool __of_device_is_available(const struct device_node *device)
 {
 	const char *status;
 	int statlen;
 
 	if (!device)
-		return 0;
+		return false;
 
 	status = __of_get_property(device, "status", &statlen);
 	if (status == NULL)
-		return 1;
+		return true;
 
 	if (statlen > 0) {
 		if (!strcmp(status, "okay") || !strcmp(status, "ok"))
-			return 1;
+			return true;
 	}
 
-	return 0;
+	return false;
 }
 
 /**
@@ -550,13 +550,13 @@ static int __of_device_is_available(const struct device_node *device)
  *
  *  @device: Node to check for availability
  *
- *  Returns 1 if the status property is absent or set to "okay" or "ok",
- *  0 otherwise
+ *  Returns true if the status property is absent or set to "okay" or "ok",
+ *  false otherwise
  */
-int of_device_is_available(const struct device_node *device)
+bool of_device_is_available(const struct device_node *device)
 {
 	unsigned long flags;
-	int res;
+	bool res;
 
 	raw_spin_lock_irqsave(&devtree_lock, flags);
 	res = __of_device_is_available(device);

commit 25c7a1de6c4b9f9eb867af4dc9215bbf9e08ef2e
Author: Kevin Cernekee <cernekee@gmail.com>
Date:   Wed Nov 12 12:54:00 2014 -0800

    of: Fix of_device_is_compatible() comment
    
    This function passes back a value from __of_device_is_compatible(), which
    returns a score in the range 0..11, not a bool.
    
    Signed-off-by: Kevin Cernekee <cernekee@gmail.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 6137f18d4244..4627e0acf4ad 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -500,7 +500,7 @@ EXPORT_SYMBOL(of_device_is_compatible);
  * of_machine_is_compatible - Test root of device tree for a given compatible value
  * @compat: compatible string to look for in root node's compatible property.
  *
- * Returns true if the root node has the given value in its
+ * Returns a positive integer if the root node has the given value in its
  * compatible property.
  */
 int of_machine_is_compatible(const char *compat)

commit b31384fa5de37a100507751dfb5c0a49d06cee67
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Nov 4 01:28:56 2014 +0100

    Driver core: Unified device properties interface for platform firmware
    
    Add a uniform interface by which device drivers can request device
    properties from the platform firmware by providing a property name
    and the corresponding data type.  The purpose of it is to help to
    write portable code that won't depend on any particular platform
    firmware interface.
    
    The following general helper functions are added:
    
    device_property_present()
    device_property_read_u8()
    device_property_read_u16()
    device_property_read_u32()
    device_property_read_u64()
    device_property_read_string()
    device_property_read_u8_array()
    device_property_read_u16_array()
    device_property_read_u32_array()
    device_property_read_u64_array()
    device_property_read_string_array()
    
    The first one allows the caller to check if the given property is
    present.  The next 5 of them allow single-valued properties of
    various types to be retrieved in a uniform way.  The remaining 5 are
    for reading properties with multiple values (arrays of either numbers
    or strings).
    
    The interface covers both ACPI and Device Trees.
    
    This change set includes material from Mika Westerberg and Aaron Lu.
    
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 3823edf2d012..4c2ccde42427 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1249,6 +1249,39 @@ int of_property_read_u64(const struct device_node *np, const char *propname,
 }
 EXPORT_SYMBOL_GPL(of_property_read_u64);
 
+/**
+ * of_property_read_u64_array - Find and read an array of 64 bit integers
+ * from a property.
+ *
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ * @out_values:	pointer to return value, modified only if return value is 0.
+ * @sz:		number of array elements to read
+ *
+ * Search for a property in a device node and read 64-bit value(s) from
+ * it. Returns 0 on success, -EINVAL if the property does not exist,
+ * -ENODATA if property does not have a value, and -EOVERFLOW if the
+ * property data isn't large enough.
+ *
+ * The out_values is modified only if a valid u64 value can be decoded.
+ */
+int of_property_read_u64_array(const struct device_node *np,
+			       const char *propname, u64 *out_values,
+			       size_t sz)
+{
+	const __be32 *val = of_find_property_value_of_size(np, propname,
+						(sz * sizeof(*out_values)));
+
+	if (IS_ERR(val))
+		return PTR_ERR(val);
+
+	while (sz--) {
+		*out_values++ = of_read_number(val, 2);
+		val += 2;
+	}
+	return 0;
+}
+
 /**
  * of_property_read_string - Find and read a string from a property
  * @np:		device node from which the property value is to be read.

commit c0e848d8b878c1868914de7193423cb715d49400
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Oct 22 11:44:55 2014 +0200

    of: Remove spaces before tabs
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 8452e50f5755..6137f18d4244 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -592,9 +592,9 @@ EXPORT_SYMBOL(of_get_parent);
  *	of_get_next_parent - Iterate to a node's parent
  *	@node:	Node to get parent of
  *
- * 	This is like of_get_parent() except that it drops the
- * 	refcount on the passed node, making it suitable for iterating
- * 	through a node's parents.
+ *	This is like of_get_parent() except that it drops the
+ *	refcount on the passed node, making it suitable for iterating
+ *	through a node's parents.
  *
  *	Returns a node pointer with refcount incremented, use
  *	of_node_put() on it when done.
@@ -1531,15 +1531,15 @@ EXPORT_SYMBOL(of_parse_phandle);
  * Example:
  *
  * phandle1: node1 {
- * 	#list-cells = <2>;
+ *	#list-cells = <2>;
  * }
  *
  * phandle2: node2 {
- * 	#list-cells = <1>;
+ *	#list-cells = <1>;
  * }
  *
  * node3 {
- * 	list = <&phandle1 1 2 &phandle2 3>;
+ *	list = <&phandle1 1 2 &phandle2 3>;
  * }
  *
  * To get a device_node of the `node2' node you may call this:
@@ -1580,7 +1580,7 @@ EXPORT_SYMBOL(of_parse_phandle_with_args);
  * }
  *
  * node3 {
- * 	list = <&phandle1 0 2 &phandle2 2 3>;
+ *	list = <&phandle1 0 2 &phandle2 2 3>;
  * }
  *
  * To get a device_node of the `node2' node you may call this:

commit c50949d3298d30f24a8eca1f9d5053f4d2b0a96e
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Oct 22 11:44:54 2014 +0200

    of: Grammar s/an/a/
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 3ab72f578344..8452e50f5755 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -933,7 +933,7 @@ const struct of_device_id *__of_match_node(const struct of_device_id *matches,
 }
 
 /**
- * of_match_node - Tell if an device_node has a matching of_match structure
+ * of_match_node - Tell if a device_node has a matching of_match structure
  *	@matches:	array of of device match structures to search in
  *	@node:		the of device structure to match against
  *

commit 1821dda4ae1f857f24094de88a5694e6fd9029e9
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Oct 22 11:44:53 2014 +0200

    of: Improve grammar for of_alias_scan() documentation
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index ea3c363ef085..3ab72f578344 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1814,14 +1814,14 @@ static void of_alias_add(struct alias_prop *ap, struct device_node *np,
 }
 
 /**
- * of_alias_scan - Scan all properties of 'aliases' node
+ * of_alias_scan - Scan all properties of the 'aliases' node
  *
- * The function scans all the properties of 'aliases' node and populate
- * the the global lookup table with the properties.  It returns the
- * number of alias_prop found, or error code in error case.
+ * The function scans all the properties of the 'aliases' node and populates
+ * the global lookup table with the properties.  It returns the
+ * number of alias properties found, or an error code in case of failure.
  *
  * @dt_alloc:	An allocator that provides a virtual address to memory
- *		for the resulting tree
+ *		for storing the resulting tree
  */
 void of_alias_scan(void * (*dt_alloc)(u64 size, u64 align))
 {

commit d94a75c13331cc00675b09d56f1a910bd53b7dd4
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Oct 22 11:44:52 2014 +0200

    of: Correct of_phandle_args node reference in comments
    
    The device_node pointer in struct of_phandle_args is called "np", not
    "node".
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 1f61a908a767..ea3c363ef085 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1525,7 +1525,7 @@ EXPORT_SYMBOL(of_parse_phandle);
  * Returns 0 on success and fills out_args, on error returns appropriate
  * errno value.
  *
- * Caller is responsible to call of_node_put() on the returned out_args->node
+ * Caller is responsible to call of_node_put() on the returned out_args->np
  * pointer.
  *
  * Example:
@@ -1568,7 +1568,7 @@ EXPORT_SYMBOL(of_parse_phandle_with_args);
  * Returns 0 on success and fills out_args, on error returns appropriate
  * errno value.
  *
- * Caller is responsible to call of_node_put() on the returned out_args->node
+ * Caller is responsible to call of_node_put() on the returned out_args->np
  * pointer.
  *
  * Example:

commit 5063e25a302e6a83f6590d9a06bd5f6400b17430
Author: Grant Likely <grant.likely@linaro.org>
Date:   Fri Oct 3 16:28:27 2014 +0100

    of: Eliminate of_allnodes list
    
    The device tree structure is composed of two lists; the 'allnodes' list
    which is a singly linked list containing every node in the tree, and the
    child->parent structure where each parent node has a singly linked list
    of children. All of the data in the allnodes list can be easily
    reproduced with the parent-child lists, so of_allnodes is actually
    unnecessary. Remove it entirely which saves a bit of memory and
    simplifies the data structure quite a lot.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Gaurav Minocha <gaurav.minocha.os@gmail.com>
    Cc: Pantelis Antoniou <pantelis@pantelis.antoniou@konsulko.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 3823edf2d012..1f61a908a767 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -32,8 +32,8 @@
 
 LIST_HEAD(aliases_lookup);
 
-struct device_node *of_allnodes;
-EXPORT_SYMBOL(of_allnodes);
+struct device_node *of_root;
+EXPORT_SYMBOL(of_root);
 struct device_node *of_chosen;
 struct device_node *of_aliases;
 struct device_node *of_stdout;
@@ -48,7 +48,7 @@ struct kset *of_kset;
  */
 DEFINE_MUTEX(of_mutex);
 
-/* use when traversing tree through the allnext, child, sibling,
+/* use when traversing tree through the child, sibling,
  * or parent members of struct device_node.
  */
 DEFINE_RAW_SPINLOCK(devtree_lock);
@@ -204,7 +204,7 @@ static int __init of_init(void)
 	mutex_unlock(&of_mutex);
 
 	/* Symlink in /proc as required by userspace ABI */
-	if (of_allnodes)
+	if (of_root)
 		proc_symlink("device-tree", NULL, "/sys/firmware/devicetree/base");
 
 	return 0;
@@ -245,6 +245,23 @@ struct property *of_find_property(const struct device_node *np,
 }
 EXPORT_SYMBOL(of_find_property);
 
+struct device_node *__of_find_all_nodes(struct device_node *prev)
+{
+	struct device_node *np;
+	if (!prev) {
+		np = of_root;
+	} else if (prev->child) {
+		np = prev->child;
+	} else {
+		/* Walk back up looking for a sibling, or the end of the structure */
+		np = prev;
+		while (np->parent && !np->sibling)
+			np = np->parent;
+		np = np->sibling; /* Might be null at the end of the tree */
+	}
+	return np;
+}
+
 /**
  * of_find_all_nodes - Get next node in global list
  * @prev:	Previous node or NULL to start iteration
@@ -259,10 +276,8 @@ struct device_node *of_find_all_nodes(struct device_node *prev)
 	unsigned long flags;
 
 	raw_spin_lock_irqsave(&devtree_lock, flags);
-	np = prev ? prev->allnext : of_allnodes;
-	for (; np != NULL; np = np->allnext)
-		if (of_node_get(np))
-			break;
+	np = __of_find_all_nodes(prev);
+	of_node_get(np);
 	of_node_put(prev);
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 	return np;
@@ -736,7 +751,7 @@ struct device_node *of_find_node_by_path(const char *path)
 	unsigned long flags;
 
 	if (strcmp(path, "/") == 0)
-		return of_node_get(of_allnodes);
+		return of_node_get(of_root);
 
 	/* The path could begin with an alias */
 	if (*path != '/') {
@@ -761,7 +776,7 @@ struct device_node *of_find_node_by_path(const char *path)
 	/* Step down the tree matching path components */
 	raw_spin_lock_irqsave(&devtree_lock, flags);
 	if (!np)
-		np = of_node_get(of_allnodes);
+		np = of_node_get(of_root);
 	while (np && *path == '/') {
 		path++; /* Increment past '/' delimiter */
 		np = __of_find_node_by_path(np, path);
@@ -790,8 +805,7 @@ struct device_node *of_find_node_by_name(struct device_node *from,
 	unsigned long flags;
 
 	raw_spin_lock_irqsave(&devtree_lock, flags);
-	np = from ? from->allnext : of_allnodes;
-	for (; np; np = np->allnext)
+	for_each_of_allnodes_from(from, np)
 		if (np->name && (of_node_cmp(np->name, name) == 0)
 		    && of_node_get(np))
 			break;
@@ -820,8 +834,7 @@ struct device_node *of_find_node_by_type(struct device_node *from,
 	unsigned long flags;
 
 	raw_spin_lock_irqsave(&devtree_lock, flags);
-	np = from ? from->allnext : of_allnodes;
-	for (; np; np = np->allnext)
+	for_each_of_allnodes_from(from, np)
 		if (np->type && (of_node_cmp(np->type, type) == 0)
 		    && of_node_get(np))
 			break;
@@ -852,12 +865,10 @@ struct device_node *of_find_compatible_node(struct device_node *from,
 	unsigned long flags;
 
 	raw_spin_lock_irqsave(&devtree_lock, flags);
-	np = from ? from->allnext : of_allnodes;
-	for (; np; np = np->allnext) {
+	for_each_of_allnodes_from(from, np)
 		if (__of_device_is_compatible(np, compatible, type, NULL) &&
 		    of_node_get(np))
 			break;
-	}
 	of_node_put(from);
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 	return np;
@@ -884,8 +895,7 @@ struct device_node *of_find_node_with_property(struct device_node *from,
 	unsigned long flags;
 
 	raw_spin_lock_irqsave(&devtree_lock, flags);
-	np = from ? from->allnext : of_allnodes;
-	for (; np; np = np->allnext) {
+	for_each_of_allnodes_from(from, np) {
 		for (pp = np->properties; pp; pp = pp->next) {
 			if (of_prop_cmp(pp->name, prop_name) == 0) {
 				of_node_get(np);
@@ -967,8 +977,7 @@ struct device_node *of_find_matching_node_and_match(struct device_node *from,
 		*match = NULL;
 
 	raw_spin_lock_irqsave(&devtree_lock, flags);
-	np = from ? from->allnext : of_allnodes;
-	for (; np; np = np->allnext) {
+	for_each_of_allnodes_from(from, np) {
 		m = __of_match_node(matches, np);
 		if (m && of_node_get(np)) {
 			if (match)
@@ -1025,7 +1034,7 @@ struct device_node *of_find_node_by_phandle(phandle handle)
 		return NULL;
 
 	raw_spin_lock_irqsave(&devtree_lock, flags);
-	for (np = of_allnodes; np; np = np->allnext)
+	for_each_of_allnodes(np)
 		if (np->phandle == handle)
 			break;
 	of_node_get(np);

commit a87fa1d81a9fb5e9adca9820e16008c40ad09f33
Author: Grant Likely <grant.likely@linaro.org>
Date:   Mon Nov 3 15:15:35 2014 +0000

    of: Fix overflow bug in string property parsing functions
    
    The string property read helpers will run off the end of the buffer if
    it is handed a malformed string property. Rework the parsers to make
    sure that doesn't happen. At the same time add new test cases to make
    sure the functions behave themselves.
    
    The original implementations of of_property_read_string_index() and
    of_property_count_strings() both open-coded the same block of parsing
    code, each with it's own subtly different bugs. The fix here merges
    functions into a single helper and makes the original functions static
    inline wrappers around the helper.
    
    One non-bugfix aspect of this patch is the addition of a new wrapper,
    of_property_read_string_array(). The new wrapper is needed by the
    device_properties feature that Rafael is working on and planning to
    merge for v3.19. The implementation is identical both with and without
    the new static inline wrapper, so it just got left in to reduce the
    churn on the header file.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Darren Hart <darren.hart@intel.com>
    Cc: <stable@vger.kernel.org>  # v3.3+: Drop selftest hunks that don't apply

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 2305dc0382bc..3823edf2d012 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1279,52 +1279,6 @@ int of_property_read_string(struct device_node *np, const char *propname,
 }
 EXPORT_SYMBOL_GPL(of_property_read_string);
 
-/**
- * of_property_read_string_index - Find and read a string from a multiple
- * strings property.
- * @np:		device node from which the property value is to be read.
- * @propname:	name of the property to be searched.
- * @index:	index of the string in the list of strings
- * @out_string:	pointer to null terminated return string, modified only if
- *		return value is 0.
- *
- * Search for a property in a device tree node and retrieve a null
- * terminated string value (pointer to data, not a copy) in the list of strings
- * contained in that property.
- * Returns 0 on success, -EINVAL if the property does not exist, -ENODATA if
- * property does not have a value, and -EILSEQ if the string is not
- * null-terminated within the length of the property data.
- *
- * The out_string pointer is modified only if a valid string can be decoded.
- */
-int of_property_read_string_index(struct device_node *np, const char *propname,
-				  int index, const char **output)
-{
-	struct property *prop = of_find_property(np, propname, NULL);
-	int i = 0;
-	size_t l = 0, total = 0;
-	const char *p;
-
-	if (!prop)
-		return -EINVAL;
-	if (!prop->value)
-		return -ENODATA;
-	if (strnlen(prop->value, prop->length) >= prop->length)
-		return -EILSEQ;
-
-	p = prop->value;
-
-	for (i = 0; total < prop->length; total += l, p += l) {
-		l = strlen(p) + 1;
-		if (i++ == index) {
-			*output = p;
-			return 0;
-		}
-	}
-	return -ENODATA;
-}
-EXPORT_SYMBOL_GPL(of_property_read_string_index);
-
 /**
  * of_property_match_string() - Find string in a list and return index
  * @np: pointer to node containing string list property
@@ -1351,7 +1305,7 @@ int of_property_match_string(struct device_node *np, const char *propname,
 	end = p + prop->length;
 
 	for (i = 0; p < end; i++, p += l) {
-		l = strlen(p) + 1;
+		l = strnlen(p, end - p) + 1;
 		if (p + l > end)
 			return -EILSEQ;
 		pr_debug("comparing %s with %s\n", string, p);
@@ -1363,39 +1317,41 @@ int of_property_match_string(struct device_node *np, const char *propname,
 EXPORT_SYMBOL_GPL(of_property_match_string);
 
 /**
- * of_property_count_strings - Find and return the number of strings from a
- * multiple strings property.
+ * of_property_read_string_util() - Utility helper for parsing string properties
  * @np:		device node from which the property value is to be read.
  * @propname:	name of the property to be searched.
+ * @out_strs:	output array of string pointers.
+ * @sz:		number of array elements to read.
+ * @skip:	Number of strings to skip over at beginning of list.
  *
- * Search for a property in a device tree node and retrieve the number of null
- * terminated string contain in it. Returns the number of strings on
- * success, -EINVAL if the property does not exist, -ENODATA if property
- * does not have a value, and -EILSEQ if the string is not null-terminated
- * within the length of the property data.
+ * Don't call this function directly. It is a utility helper for the
+ * of_property_read_string*() family of functions.
  */
-int of_property_count_strings(struct device_node *np, const char *propname)
+int of_property_read_string_helper(struct device_node *np, const char *propname,
+				   const char **out_strs, size_t sz, int skip)
 {
 	struct property *prop = of_find_property(np, propname, NULL);
-	int i = 0;
-	size_t l = 0, total = 0;
-	const char *p;
+	int l = 0, i = 0;
+	const char *p, *end;
 
 	if (!prop)
 		return -EINVAL;
 	if (!prop->value)
 		return -ENODATA;
-	if (strnlen(prop->value, prop->length) >= prop->length)
-		return -EILSEQ;
-
 	p = prop->value;
+	end = p + prop->length;
 
-	for (i = 0; total < prop->length; total += l, p += l, i++)
-		l = strlen(p) + 1;
-
-	return i;
+	for (i = 0; p < end && (!out_strs || i < skip + sz); i++, p += l) {
+		l = strnlen(p, end - p) + 1;
+		if (p + l > end)
+			return -EILSEQ;
+		if (out_strs && i >= skip)
+			*out_strs++ = p;
+	}
+	i -= skip;
+	return i <= 0 ? -ENODATA : i;
 }
-EXPORT_SYMBOL_GPL(of_property_count_strings);
+EXPORT_SYMBOL_GPL(of_property_read_string_helper);
 
 void of_print_phandle_args(const char *msg, const struct of_phandle_args *args)
 {

commit fc59b4479c172e413df615cea1635247265e07a0
Author: Grant Likely <grant.likely@linaro.org>
Date:   Thu Oct 2 13:08:02 2014 +0100

    of: Don't try to search when phandle == 0
    
    A value of '0' isn't a valid phandle, so searching for a node with that
    phandle is pointless. It will result in nothing but false positives.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 293ed4b687ba..2305dc0382bc 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1021,6 +1021,9 @@ struct device_node *of_find_node_by_phandle(phandle handle)
 	struct device_node *np;
 	unsigned long flags;
 
+	if (!handle)
+		return NULL;
+
 	raw_spin_lock_irqsave(&devtree_lock, flags);
 	for (np = of_allnodes; np; np = np->allnext)
 		if (np->phandle == handle)

commit 7dbe5849fb50fc9b5b77a8f590c87a577ddc9bb6
Author: Laurentiu Tudor <b10716@freescale.com>
Date:   Wed Aug 27 17:09:39 2014 +0300

    of: make sure of_alias is initialized before accessing it
    
    Simply swap of_alias and of_chosen initialization so
    that of_alias ends up read first. This must be done
    because it is accessed couple of lines below when
    trying to initialize the of_stdout using the alias
    based legacy method.
    
    [Fixes a752ee5 - tty: Update hypervisor tty drivers to
    use core stdout parsing code]
    
    Signed-off-by: Laurentiu Tudor <Laurentiu.Tudor@freescale.com>
    [glikely: Don't move the 'if (!of_aliases)' test]
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 7af64c48ca42..293ed4b687ba 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1859,6 +1859,7 @@ void of_alias_scan(void * (*dt_alloc)(u64 size, u64 align))
 {
 	struct property *pp;
 
+	of_aliases = of_find_node_by_path("/aliases");
 	of_chosen = of_find_node_by_path("/chosen");
 	if (of_chosen == NULL)
 		of_chosen = of_find_node_by_path("/chosen@0");
@@ -1874,7 +1875,6 @@ void of_alias_scan(void * (*dt_alloc)(u64 size, u64 align))
 			of_stdout = of_find_node_by_path(name);
 	}
 
-	of_aliases = of_find_node_by_path("/aliases");
 	if (!of_aliases)
 		return;
 

commit ef69d74035befbddd7c2b7e86120e49191107acc
Author: Gaurav Minocha <gaurav.minocha.os@gmail.com>
Date:   Fri Sep 5 09:56:13 2014 -0700

    of: Disabling OF functions that use sysfs if CONFIG_SYSFS disabled
    
    This patch is to the fix the recent runtime bug in kernel reported by
    <fengguang.wu@intel.com>. The bug was exposed by commit b951f9dc,
    "Enabling OF selftest to run without machine's devicetree" and is
    exposed when CONFIG_OF_SELFTEST is enabled and CONFIG_SYSFS is
    disabled.
    
    Mail Subject: [OF test] BUG: unable to handle kernel NULL pointer
    dereference at 00000038
    
    Tested on x86 and arm architecture
    
    Signed-off-by: Gaurav Minocha <gaurav.minocha.os@gmail.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index bcfd08c2795c..7af64c48ca42 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -138,6 +138,9 @@ int __of_add_property_sysfs(struct device_node *np, struct property *pp)
 	/* Important: Don't leak passwords */
 	bool secure = strncmp(pp->name, "security-", 9) == 0;
 
+	if (!IS_ENABLED(CONFIG_SYSFS))
+		return 0;
+
 	if (!of_kset || !of_node_is_attached(np))
 		return 0;
 
@@ -158,6 +161,9 @@ int __of_attach_node_sysfs(struct device_node *np)
 	struct property *pp;
 	int rc;
 
+	if (!IS_ENABLED(CONFIG_SYSFS))
+		return 0;
+
 	if (!of_kset)
 		return 0;
 
@@ -1713,6 +1719,9 @@ int __of_remove_property(struct device_node *np, struct property *prop)
 
 void __of_remove_property_sysfs(struct device_node *np, struct property *prop)
 {
+	if (!IS_ENABLED(CONFIG_SYSFS))
+		return;
+
 	/* at early boot, bail here and defer setup to of_init() */
 	if (of_kset && of_node_is_attached(np))
 		sysfs_remove_bin_file(&np->kobj, &prop->attr);
@@ -1777,6 +1786,9 @@ int __of_update_property(struct device_node *np, struct property *newprop,
 void __of_update_property_sysfs(struct device_node *np, struct property *newprop,
 		struct property *oldprop)
 {
+	if (!IS_ENABLED(CONFIG_SYSFS))
+		return;
+
 	/* At early boot, bail out and defer setup to of_init() */
 	if (!of_kset)
 		return;

commit 5f74d8b7b8546255db6af45b017e9cbb18aed609
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Wed Sep 3 11:06:43 2014 -0700

    of: correct of_console_check()'s return value
    
    The comments above of_console_check() say that it will return TRUE if it
    registers a preferred console, but add_preferred_console() uses a
    0-equals-success convention, so this leaves of_console_check() with an
    inconsistent policy for its return values.
    
    Fortunately, nobody was actually checking the return value of
    of_console_check(), so this isn't significant at the moment.
    
    But let's match the comments, so we're doing what we say.
    
    Fixes: 3482f2c52b77 ('of: Create of_console_check() for selecting a console specified in /chosen')
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index d8574adf0d62..bcfd08c2795c 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1986,7 +1986,7 @@ bool of_console_check(struct device_node *dn, char *name, int index)
 {
 	if (!dn || dn != of_stdout || console_set_on_cmdline)
 		return false;
-	return add_preferred_console(name, index, NULL);
+	return !add_preferred_console(name, index, NULL);
 }
 EXPORT_SYMBOL_GPL(of_console_check);
 

commit 663d3f7c2e5e1b018a4c53277ccfde40329d98ca
Merge: b775e642bf95 b6ae5dc54b0a
Author: Grant Likely <grant.likely@linaro.org>
Date:   Mon Aug 11 14:06:23 2014 +0100

    Merge branch 'devicetree/next-overlay' into devicetree/next
    
    Conflicts:
            drivers/of/testcase-data/testcases.dts

commit 259092a35c7e11f1d4616b0f5b3ba7b851fe4fa6
Author: Grant Likely <grant.likely@linaro.org>
Date:   Wed Jul 16 12:48:23 2014 -0600

    of: Reorder device tree changes and notifiers
    
    Currently, devicetree reconfig notifiers get emitted before the change
    is applied to the tree, but that behaviour is problematic if the
    receiver wants the determine the new state of the tree. The current
    users don't care, but the changeset code to follow will be making
    multiple changes at once. Reorder notifiers to get emitted after the
    change has been applied to the tree so that callbacks see the new tree
    state.
    
    At the same time, fixup the existing callbacks to expect the new order.
    There are a few callbacks that compare the old and new values of a
    changed property. Put both property pointers into the of_prop_reconfig
    structure.
    
    The current notifiers also allow the notifier callback to fail and
    cancel the change to the tree, but that feature isn't actually used.
    It really isn't valid to ignore a tree modification provided by firmware
    anyway, so remove the ability to cancel a change to the tree.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Cc: Nathan Fontenot <nfont@austin.ibm.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index ededf8e33145..a7ad1013edfa 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1674,10 +1674,6 @@ int of_add_property(struct device_node *np, struct property *prop)
 	unsigned long flags;
 	int rc;
 
-	rc = of_property_notify(OF_RECONFIG_ADD_PROPERTY, np, prop);
-	if (rc)
-		return rc;
-
 	mutex_lock(&of_mutex);
 
 	raw_spin_lock_irqsave(&devtree_lock, flags);
@@ -1689,6 +1685,9 @@ int of_add_property(struct device_node *np, struct property *prop)
 
 	mutex_unlock(&of_mutex);
 
+	if (!rc)
+		of_property_notify(OF_RECONFIG_ADD_PROPERTY, np, prop, NULL);
+
 	return rc;
 }
 
@@ -1731,10 +1730,6 @@ int of_remove_property(struct device_node *np, struct property *prop)
 	unsigned long flags;
 	int rc;
 
-	rc = of_property_notify(OF_RECONFIG_REMOVE_PROPERTY, np, prop);
-	if (rc)
-		return rc;
-
 	mutex_lock(&of_mutex);
 
 	raw_spin_lock_irqsave(&devtree_lock, flags);
@@ -1746,6 +1741,9 @@ int of_remove_property(struct device_node *np, struct property *prop)
 
 	mutex_unlock(&of_mutex);
 
+	if (!rc)
+		of_property_notify(OF_RECONFIG_REMOVE_PROPERTY, np, prop, NULL);
+
 	return rc;
 }
 
@@ -1805,10 +1803,6 @@ int of_update_property(struct device_node *np, struct property *newprop)
 	if (!newprop->name)
 		return -EINVAL;
 
-	rc = of_property_notify(OF_RECONFIG_UPDATE_PROPERTY, np, newprop);
-	if (rc)
-		return rc;
-
 	mutex_lock(&of_mutex);
 
 	raw_spin_lock_irqsave(&devtree_lock, flags);
@@ -1820,6 +1814,9 @@ int of_update_property(struct device_node *np, struct property *newprop)
 
 	mutex_unlock(&of_mutex);
 
+	if (!rc)
+		of_property_notify(OF_RECONFIG_UPDATE_PROPERTY, np, newprop, oldprop);
+
 	return rc;
 }
 

commit a25095d451ece23b1fef34474f3230100db7aa05
Author: Grant Likely <grant.likely@linaro.org>
Date:   Tue Jul 15 23:25:43 2014 -0600

    of: Move dynamic node fixups out of powerpc and into common code
    
    PowerPC does an odd thing with dynamic nodes. It uses a notifier to
    catch new node additions and set some of the values like name and type.
    This makes no sense since that same code can be put directly into
    of_attach_node(). Besides, all dynamic node users need this, not just
    powerpc. Fix this problem by moving the logic out of arch/powerpc and
    into drivers/of/dynamic.c.
    
    It is also important to remove this notifier because we want to move the
    firing of notifiers from before the tree is modified to after so that
    the receiver gets a consistent view of the tree, but that is
    incompatible with notifiers that modify the node.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Cc: Nathan Fontenot <nfont@austin.ibm.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index ad4929cbd876..ededf8e33145 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -266,8 +266,8 @@ EXPORT_SYMBOL(of_find_all_nodes);
  * Find a property with a given name for a given node
  * and return the value.
  */
-static const void *__of_get_property(const struct device_node *np,
-				     const char *name, int *lenp)
+const void *__of_get_property(const struct device_node *np,
+			      const char *name, int *lenp)
 {
 	struct property *pp = __of_find_property(np, name, lenp);
 

commit 8a2b22a2595bf89d4396530edf8388159fad9d83
Author: Grant Likely <grant.likely@linaro.org>
Date:   Wed Jul 23 17:05:06 2014 -0600

    of: Make devicetree sysfs update functions consistent.
    
    All of the DT modification functions are split into two parts, the first
    part manipulates the DT data structure, and the second part updates
    sysfs, but the code isn't very consistent about how the second half is
    called. They don't all enforce the same rules about when it is valid to
    update sysfs, and there isn't any clarity on locking.
    
    The transactional DT modification feature that is coming also needs
    access to these functions so that it can perform all the structure
    changes together, and then all the sysfs updates as a second stage
    instead of doing each one at a time.
    
    Fix up the second have by creating a separate __of_*_sysfs() function
    for each of the helpers. The new functions have consistent naming (ie.
    of_node_add() becomes __of_attach_node_sysfs()) and all of them now
    defer if of_init hasn't been called yet.
    
    Callers of the new functions must hold the of_mutex to ensure there are
    no race conditions with of_init(). The mutex ensures that there will
    only ever be one writer to the tree at any given time. There can still
    be any number of readers and the raw_spin_lock is still used to make
    sure access to the data structure is still consistent.
    
    Finally, put the function prototypes into of_private.h so they are
    accessible to the transaction code.
    
    Signed-off-by: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    [grant.likely: Changed suffix from _post to _sysfs to match existing code]
    [grant.likely: Reorganized to eliminate trivial wrappers]
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index b403f9d98461..ad4929cbd876 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -37,10 +37,13 @@ struct device_node *of_chosen;
 struct device_node *of_aliases;
 static struct device_node *of_stdout;
 
-static struct kset *of_kset;
+struct kset *of_kset;
 
 /*
- * Used to protect the of_aliases, to hold off addition of nodes to sysfs
+ * Used to protect the of_aliases, to hold off addition of nodes to sysfs.
+ * This mutex must be held whenever modifications are being made to the
+ * device tree. The of_{attach,detach}_node() and
+ * of_{add,remove,update}_property() helpers make sure this happens.
  */
 DEFINE_MUTEX(of_mutex);
 
@@ -127,13 +130,16 @@ static const char *safe_name(struct kobject *kobj, const char *orig_name)
 	return name;
 }
 
-static int __of_add_property_sysfs(struct device_node *np, struct property *pp)
+int __of_add_property_sysfs(struct device_node *np, struct property *pp)
 {
 	int rc;
 
 	/* Important: Don't leak passwords */
 	bool secure = strncmp(pp->name, "security-", 9) == 0;
 
+	if (!of_kset || !of_node_is_attached(np))
+		return 0;
+
 	sysfs_bin_attr_init(&pp->attr);
 	pp->attr.attr.name = safe_name(&np->kobj, pp->name);
 	pp->attr.attr.mode = secure ? S_IRUSR : S_IRUGO;
@@ -145,12 +151,15 @@ static int __of_add_property_sysfs(struct device_node *np, struct property *pp)
 	return rc;
 }
 
-static int __of_node_add(struct device_node *np)
+int __of_attach_node_sysfs(struct device_node *np)
 {
 	const char *name;
 	struct property *pp;
 	int rc;
 
+	if (!of_kset)
+		return 0;
+
 	np->kobj.kset = of_kset;
 	if (!np->parent) {
 		/* Nodes without parents are new top level trees */
@@ -172,26 +181,6 @@ static int __of_node_add(struct device_node *np)
 	return 0;
 }
 
-int of_node_add(struct device_node *np)
-{
-	int rc = 0;
-
-	BUG_ON(!of_node_is_initialized(np));
-
-	/*
-	 * Grab the mutex here so that in a race condition between of_init() and
-	 * of_node_add(), node addition will still be consistent.
-	 */
-	mutex_lock(&of_mutex);
-	if (of_kset)
-		rc = __of_node_add(np);
-	else
-		/* This scenario may be perfectly valid, but report it anyway */
-		pr_info("of_node_add(%s) before of_init()\n", np->full_name);
-	mutex_unlock(&of_mutex);
-	return rc;
-}
-
 static int __init of_init(void)
 {
 	struct device_node *np;
@@ -204,7 +193,7 @@ static int __init of_init(void)
 		return -ENOMEM;
 	}
 	for_each_of_allnodes(np)
-		__of_node_add(np);
+		__of_attach_node_sysfs(np);
 	mutex_unlock(&of_mutex);
 
 	/* Symlink in /proc as required by userspace ABI */
@@ -1689,15 +1678,17 @@ int of_add_property(struct device_node *np, struct property *prop)
 	if (rc)
 		return rc;
 
+	mutex_lock(&of_mutex);
+
 	raw_spin_lock_irqsave(&devtree_lock, flags);
 	rc = __of_add_property(np, prop);
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
-	if (rc)
-		return rc;
 
-	if (of_node_is_attached(np))
+	if (!rc)
 		__of_add_property_sysfs(np, prop);
 
+	mutex_unlock(&of_mutex);
+
 	return rc;
 }
 
@@ -1720,6 +1711,13 @@ int __of_remove_property(struct device_node *np, struct property *prop)
 	return 0;
 }
 
+void __of_remove_property_sysfs(struct device_node *np, struct property *prop)
+{
+	/* at early boot, bail here and defer setup to of_init() */
+	if (of_kset && of_node_is_attached(np))
+		sysfs_remove_bin_file(&np->kobj, &prop->attr);
+}
+
 /**
  * of_remove_property - Remove a property from a node.
  *
@@ -1737,20 +1735,18 @@ int of_remove_property(struct device_node *np, struct property *prop)
 	if (rc)
 		return rc;
 
+	mutex_lock(&of_mutex);
+
 	raw_spin_lock_irqsave(&devtree_lock, flags);
 	rc = __of_remove_property(np, prop);
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 
-	if (rc)
-		return rc;
-
-	/* at early boot, bail hear and defer setup to of_init() */
-	if (!of_kset)
-		return 0;
+	if (!rc)
+		__of_remove_property_sysfs(np, prop);
 
-	sysfs_remove_bin_file(&np->kobj, &prop->attr);
+	mutex_unlock(&of_mutex);
 
-	return 0;
+	return rc;
 }
 
 int __of_update_property(struct device_node *np, struct property *newprop,
@@ -1779,6 +1775,18 @@ int __of_update_property(struct device_node *np, struct property *newprop,
 	return 0;
 }
 
+void __of_update_property_sysfs(struct device_node *np, struct property *newprop,
+		struct property *oldprop)
+{
+	/* At early boot, bail out and defer setup to of_init() */
+	if (!of_kset)
+		return;
+
+	if (oldprop)
+		sysfs_remove_bin_file(&np->kobj, &oldprop->attr);
+	__of_add_property_sysfs(np, newprop);
+}
+
 /*
  * of_update_property - Update a property in a node, if the property does
  * not exist, add it.
@@ -1801,22 +1809,18 @@ int of_update_property(struct device_node *np, struct property *newprop)
 	if (rc)
 		return rc;
 
+	mutex_lock(&of_mutex);
+
 	raw_spin_lock_irqsave(&devtree_lock, flags);
 	rc = __of_update_property(np, newprop, &oldprop);
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
-	if (rc)
-		return rc;
 
-	/* At early boot, bail out and defer setup to of_init() */
-	if (!of_kset)
-		return 0;
+	if (!rc)
+		__of_update_property_sysfs(np, newprop, oldprop);
 
-	/* Update the sysfs attribute */
-	if (oldprop)
-		sysfs_remove_bin_file(&np->kobj, &oldprop->attr);
-	__of_add_property_sysfs(np, newprop);
+	mutex_unlock(&of_mutex);
 
-	return 0;
+	return rc;
 }
 
 static void of_alias_add(struct alias_prop *ap, struct device_node *np,

commit d8c50088417ebf61ad8b132caad20d10f7736034
Author: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
Date:   Fri Jul 4 19:58:46 2014 +0300

    of: Create unlocked versions of node and property add/remove functions
    
    The DT overlay code will need to manipulate nodes and properties while
    already holding the devicetree lock, or on nodes that are not yet
    attached to the tree, but the current helper functions don't allow that.
    Extract the core behaviour from the accessors and create the following
    unlocked variants.
    
    The unlocked variants require either the lock to already be held or for
    the nodes to be detached from the tree. Changes to live nodes will not
    get updated in sysfs, so the caller must arrange for housekeeping to
    take place after dropping the lock.
    
    The new functions are: __of_add_property(), __of_remove_property(),
    __of_update_property(), __of_attach_node() and __of_detach_node().
    
    Signed-off-by: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    [Remove unnecessary diff hunks and rewrite commit text]
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 0d8955605738..b403f9d98461 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1659,7 +1659,7 @@ EXPORT_SYMBOL(of_count_phandle_with_args);
 /**
  * __of_add_property - Add a property to a node without lock operations
  */
-static int __of_add_property(struct device_node *np, struct property *prop)
+int __of_add_property(struct device_node *np, struct property *prop)
 {
 	struct property **next;
 
@@ -1701,6 +1701,25 @@ int of_add_property(struct device_node *np, struct property *prop)
 	return rc;
 }
 
+int __of_remove_property(struct device_node *np, struct property *prop)
+{
+	struct property **next;
+
+	for (next = &np->properties; *next; next = &(*next)->next) {
+		if (*next == prop)
+			break;
+	}
+	if (*next == NULL)
+		return -ENODEV;
+
+	/* found the node */
+	*next = prop->next;
+	prop->next = np->deadprops;
+	np->deadprops = prop;
+
+	return 0;
+}
+
 /**
  * of_remove_property - Remove a property from a node.
  *
@@ -1711,9 +1730,7 @@ int of_add_property(struct device_node *np, struct property *prop)
  */
 int of_remove_property(struct device_node *np, struct property *prop)
 {
-	struct property **next;
 	unsigned long flags;
-	int found = 0;
 	int rc;
 
 	rc = of_property_notify(OF_RECONFIG_REMOVE_PROPERTY, np, prop);
@@ -1721,22 +1738,11 @@ int of_remove_property(struct device_node *np, struct property *prop)
 		return rc;
 
 	raw_spin_lock_irqsave(&devtree_lock, flags);
-	next = &np->properties;
-	while (*next) {
-		if (*next == prop) {
-			/* found the node */
-			*next = prop->next;
-			prop->next = np->deadprops;
-			np->deadprops = prop;
-			found = 1;
-			break;
-		}
-		next = &(*next)->next;
-	}
+	rc = __of_remove_property(np, prop);
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 
-	if (!found)
-		return -ENODEV;
+	if (rc)
+		return rc;
 
 	/* at early boot, bail hear and defer setup to of_init() */
 	if (!of_kset)
@@ -1747,6 +1753,32 @@ int of_remove_property(struct device_node *np, struct property *prop)
 	return 0;
 }
 
+int __of_update_property(struct device_node *np, struct property *newprop,
+		struct property **oldpropp)
+{
+	struct property **next, *oldprop;
+
+	for (next = &np->properties; *next; next = &(*next)->next) {
+		if (of_prop_cmp((*next)->name, newprop->name) == 0)
+			break;
+	}
+	*oldpropp = oldprop = *next;
+
+	if (oldprop) {
+		/* replace the node */
+		newprop->next = oldprop->next;
+		*next = newprop;
+		oldprop->next = np->deadprops;
+		np->deadprops = oldprop;
+	} else {
+		/* new node */
+		newprop->next = NULL;
+		*next = newprop;
+	}
+
+	return 0;
+}
+
 /*
  * of_update_property - Update a property in a node, if the property does
  * not exist, add it.
@@ -1758,34 +1790,19 @@ int of_remove_property(struct device_node *np, struct property *prop)
  */
 int of_update_property(struct device_node *np, struct property *newprop)
 {
-	struct property **next, *oldprop;
+	struct property *oldprop;
 	unsigned long flags;
 	int rc;
 
+	if (!newprop->name)
+		return -EINVAL;
+
 	rc = of_property_notify(OF_RECONFIG_UPDATE_PROPERTY, np, newprop);
 	if (rc)
 		return rc;
 
-	if (!newprop->name)
-		return -EINVAL;
-
 	raw_spin_lock_irqsave(&devtree_lock, flags);
-	next = &np->properties;
-	oldprop = __of_find_property(np, newprop->name, NULL);
-	if (!oldprop) {
-		/* add the new node */
-		rc = __of_add_property(np, newprop);
-	} else while (*next) {
-		/* replace the node */
-		if (*next == oldprop) {
-			newprop->next = oldprop->next;
-			*next = newprop;
-			oldprop->next = np->deadprops;
-			np->deadprops = oldprop;
-			break;
-		}
-		next = &(*next)->next;
-	}
+	rc = __of_update_property(np, newprop, &oldprop);
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 	if (rc)
 		return rc;

commit 6afc0dc381573559251de9a8259404f49e6aed14
Author: Grant Likely <grant.likely@linaro.org>
Date:   Thu Jun 26 15:40:48 2014 +0100

    of: Move CONFIG_OF_DYNAMIC code into a separate file
    
    Split the dynamic device tree code into a separate file to make it
    really clear what features CONFIF_OF_DYNAMIC add to the kernel. Without
    CONFIG_OF_DYNAMIC only properties can be changed, and notifiers do not
    get sent. Enabling it turns on reference counting, notifiers and the
    ability to add and remove nodes.
    
    v2: Moved of_node_release() into dynamic.c
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    Cc: Rob Herring <robh+dt@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index e48a1b90a392..0d8955605738 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -88,79 +88,7 @@ int __weak of_node_to_nid(struct device_node *np)
 }
 #endif
 
-#if defined(CONFIG_OF_DYNAMIC)
-/**
- *	of_node_get - Increment refcount of a node
- *	@node:	Node to inc refcount, NULL is supported to
- *		simplify writing of callers
- *
- *	Returns node.
- */
-struct device_node *of_node_get(struct device_node *node)
-{
-	if (node)
-		kobject_get(&node->kobj);
-	return node;
-}
-EXPORT_SYMBOL(of_node_get);
-
-static inline struct device_node *kobj_to_device_node(struct kobject *kobj)
-{
-	return container_of(kobj, struct device_node, kobj);
-}
-
-/**
- *	of_node_release - release a dynamically allocated node
- *	@kref:  kref element of the node to be released
- *
- *	In of_node_put() this function is passed to kref_put()
- *	as the destructor.
- */
-static void of_node_release(struct kobject *kobj)
-{
-	struct device_node *node = kobj_to_device_node(kobj);
-	struct property *prop = node->properties;
-
-	/* We should never be releasing nodes that haven't been detached. */
-	if (!of_node_check_flag(node, OF_DETACHED)) {
-		pr_err("ERROR: Bad of_node_put() on %s\n", node->full_name);
-		dump_stack();
-		return;
-	}
-
-	if (!of_node_check_flag(node, OF_DYNAMIC))
-		return;
-
-	while (prop) {
-		struct property *next = prop->next;
-		kfree(prop->name);
-		kfree(prop->value);
-		kfree(prop);
-		prop = next;
-
-		if (!prop) {
-			prop = node->deadprops;
-			node->deadprops = NULL;
-		}
-	}
-	kfree(node->full_name);
-	kfree(node->data);
-	kfree(node);
-}
-
-/**
- *	of_node_put - Decrement refcount of a node
- *	@node:	Node to dec refcount, NULL is supported to
- *		simplify writing of callers
- *
- */
-void of_node_put(struct device_node *node)
-{
-	if (node)
-		kobject_put(&node->kobj);
-}
-EXPORT_SYMBOL(of_node_put);
-#else
+#ifndef CONFIG_OF_DYNAMIC
 static void of_node_release(struct kobject *kobj)
 {
 	/* Without CONFIG_OF_DYNAMIC, no nodes gets freed */
@@ -264,25 +192,6 @@ int of_node_add(struct device_node *np)
 	return rc;
 }
 
-#if defined(CONFIG_OF_DYNAMIC)
-static void of_node_remove(struct device_node *np)
-{
-	struct property *pp;
-
-	BUG_ON(!of_node_is_initialized(np));
-
-	/* only remove properties if on sysfs */
-	if (of_node_is_attached(np)) {
-		for_each_property_of_node(np, pp)
-			sysfs_remove_bin_file(&np->kobj, &pp->attr);
-		kobject_del(&np->kobj);
-	}
-
-	/* finally remove the kobj_init ref */
-	of_node_put(np);
-}
-#endif
-
 static int __init of_init(void)
 {
 	struct device_node *np;
@@ -1747,28 +1656,6 @@ int of_count_phandle_with_args(const struct device_node *np, const char *list_na
 }
 EXPORT_SYMBOL(of_count_phandle_with_args);
 
-#if defined(CONFIG_OF_DYNAMIC)
-static int of_property_notify(int action, struct device_node *np,
-			      struct property *prop)
-{
-	struct of_prop_reconfig pr;
-
-	/* only call notifiers if the node is attached */
-	if (!of_node_is_attached(np))
-		return 0;
-
-	pr.dn = np;
-	pr.prop = prop;
-	return of_reconfig_notify(action, &pr);
-}
-#else
-static int of_property_notify(int action, struct device_node *np,
-			      struct property *prop)
-{
-	return 0;
-}
-#endif
-
 /**
  * __of_add_property - Add a property to a node without lock operations
  */
@@ -1915,121 +1802,6 @@ int of_update_property(struct device_node *np, struct property *newprop)
 	return 0;
 }
 
-#if defined(CONFIG_OF_DYNAMIC)
-/*
- * Support for dynamic device trees.
- *
- * On some platforms, the device tree can be manipulated at runtime.
- * The routines in this section support adding, removing and changing
- * device tree nodes.
- */
-
-static BLOCKING_NOTIFIER_HEAD(of_reconfig_chain);
-
-int of_reconfig_notifier_register(struct notifier_block *nb)
-{
-	return blocking_notifier_chain_register(&of_reconfig_chain, nb);
-}
-EXPORT_SYMBOL_GPL(of_reconfig_notifier_register);
-
-int of_reconfig_notifier_unregister(struct notifier_block *nb)
-{
-	return blocking_notifier_chain_unregister(&of_reconfig_chain, nb);
-}
-EXPORT_SYMBOL_GPL(of_reconfig_notifier_unregister);
-
-int of_reconfig_notify(unsigned long action, void *p)
-{
-	int rc;
-
-	rc = blocking_notifier_call_chain(&of_reconfig_chain, action, p);
-	return notifier_to_errno(rc);
-}
-
-/**
- * of_attach_node - Plug a device node into the tree and global list.
- */
-int of_attach_node(struct device_node *np)
-{
-	unsigned long flags;
-	int rc;
-
-	rc = of_reconfig_notify(OF_RECONFIG_ATTACH_NODE, np);
-	if (rc)
-		return rc;
-
-	raw_spin_lock_irqsave(&devtree_lock, flags);
-	np->sibling = np->parent->child;
-	np->allnext = np->parent->allnext;
-	np->parent->allnext = np;
-	np->parent->child = np;
-	of_node_clear_flag(np, OF_DETACHED);
-	raw_spin_unlock_irqrestore(&devtree_lock, flags);
-
-	of_node_add(np);
-	return 0;
-}
-
-/**
- * of_detach_node - "Unplug" a node from the device tree.
- *
- * The caller must hold a reference to the node.  The memory associated with
- * the node is not freed until its refcount goes to zero.
- */
-int of_detach_node(struct device_node *np)
-{
-	struct device_node *parent;
-	unsigned long flags;
-	int rc = 0;
-
-	rc = of_reconfig_notify(OF_RECONFIG_DETACH_NODE, np);
-	if (rc)
-		return rc;
-
-	raw_spin_lock_irqsave(&devtree_lock, flags);
-
-	if (of_node_check_flag(np, OF_DETACHED)) {
-		/* someone already detached it */
-		raw_spin_unlock_irqrestore(&devtree_lock, flags);
-		return rc;
-	}
-
-	parent = np->parent;
-	if (!parent) {
-		raw_spin_unlock_irqrestore(&devtree_lock, flags);
-		return rc;
-	}
-
-	if (of_allnodes == np)
-		of_allnodes = np->allnext;
-	else {
-		struct device_node *prev;
-		for (prev = of_allnodes;
-		     prev->allnext != np;
-		     prev = prev->allnext)
-			;
-		prev->allnext = np->allnext;
-	}
-
-	if (parent->child == np)
-		parent->child = np->sibling;
-	else {
-		struct device_node *prevsib;
-		for (prevsib = np->parent->child;
-		     prevsib->sibling != np;
-		     prevsib = prevsib->sibling)
-			;
-		prevsib->sibling = np->sibling;
-	}
-
-	of_node_set_flag(np, OF_DETACHED);
-	raw_spin_unlock_irqrestore(&devtree_lock, flags);
-
-	of_node_remove(np);
-	return rc;
-}
-#endif /* defined(CONFIG_OF_DYNAMIC) */
-
 static void of_alias_add(struct alias_prop *ap, struct device_node *np,
 			 int id, const char *stem, int stem_len)
 {

commit c05aba2bd5f9dd3f363611ff844513de1341ac60
Author: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
Date:   Fri Jul 4 19:58:03 2014 +0300

    of: rename of_aliases_mutex to just of_mutex
    
    We're overloading usage of of_aliases_mutex for sysfs changes,
    so rename to something that is more generic.
    
    Signed-off-by: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index b9864806e9b8..e48a1b90a392 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -40,10 +40,9 @@ static struct device_node *of_stdout;
 static struct kset *of_kset;
 
 /*
- * Used to protect the of_aliases; but also overloaded to hold off addition of
- * nodes to sysfs
+ * Used to protect the of_aliases, to hold off addition of nodes to sysfs
  */
-DEFINE_MUTEX(of_aliases_mutex);
+DEFINE_MUTEX(of_mutex);
 
 /* use when traversing tree through the allnext, child, sibling,
  * or parent members of struct device_node.
@@ -255,13 +254,13 @@ int of_node_add(struct device_node *np)
 	 * Grab the mutex here so that in a race condition between of_init() and
 	 * of_node_add(), node addition will still be consistent.
 	 */
-	mutex_lock(&of_aliases_mutex);
+	mutex_lock(&of_mutex);
 	if (of_kset)
 		rc = __of_node_add(np);
 	else
 		/* This scenario may be perfectly valid, but report it anyway */
 		pr_info("of_node_add(%s) before of_init()\n", np->full_name);
-	mutex_unlock(&of_aliases_mutex);
+	mutex_unlock(&of_mutex);
 	return rc;
 }
 
@@ -289,15 +288,15 @@ static int __init of_init(void)
 	struct device_node *np;
 
 	/* Create the kset, and register existing nodes */
-	mutex_lock(&of_aliases_mutex);
+	mutex_lock(&of_mutex);
 	of_kset = kset_create_and_add("devicetree", NULL, firmware_kobj);
 	if (!of_kset) {
-		mutex_unlock(&of_aliases_mutex);
+		mutex_unlock(&of_mutex);
 		return -ENOMEM;
 	}
 	for_each_of_allnodes(np)
 		__of_node_add(np);
-	mutex_unlock(&of_aliases_mutex);
+	mutex_unlock(&of_mutex);
 
 	/* Symlink in /proc as required by userspace ABI */
 	if (of_allnodes)
@@ -2122,7 +2121,7 @@ int of_alias_get_id(struct device_node *np, const char *stem)
 	struct alias_prop *app;
 	int id = -ENODEV;
 
-	mutex_lock(&of_aliases_mutex);
+	mutex_lock(&of_mutex);
 	list_for_each_entry(app, &aliases_lookup, link) {
 		if (strcmp(app->stem, stem) != 0)
 			continue;
@@ -2132,7 +2131,7 @@ int of_alias_get_id(struct device_node *np, const char *stem)
 			break;
 		}
 	}
-	mutex_unlock(&of_aliases_mutex);
+	mutex_unlock(&of_mutex);
 
 	return id;
 }

commit a752ee56ad84bf9a35b8323af1ad22b03c1df2c4
Author: Grant Likely <grant.likely@linaro.org>
Date:   Fri Mar 28 08:12:18 2014 -0700

    tty: Update hypervisor tty drivers to use core stdout parsing code.
    
    The evh_bytechan, hvc_opal and hvc_vio drivers all open code the parsing
    of the stdout node in the device tree. This patch simplifies the driver
    by removing the duplicated functionality.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index df9b2bb7bb27..e4f95ba0a3eb 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -36,7 +36,7 @@ struct device_node *of_allnodes;
 EXPORT_SYMBOL(of_allnodes);
 struct device_node *of_chosen;
 struct device_node *of_aliases;
-static struct device_node *of_stdout;
+struct device_node *of_stdout;
 
 static struct kset *of_kset;
 
@@ -2063,9 +2063,12 @@ void of_alias_scan(void * (*dt_alloc)(u64 size, u64 align))
 		of_chosen = of_find_node_by_path("/chosen@0");
 
 	if (of_chosen) {
+		/* linux,stdout-path and /aliases/stdout are for legacy compatibility */
 		const char *name = of_get_property(of_chosen, "stdout-path", NULL);
 		if (!name)
 			name = of_get_property(of_chosen, "linux,stdout-path", NULL);
+		if (IS_ENABLED(CONFIG_PPC) && !name)
+			name = of_get_property(of_aliases, "stdout", NULL);
 		if (name)
 			of_stdout = of_find_node_by_path(name);
 	}

commit 3482f2c52b77bf6596e24aae82e204a0603eba66
Author: Grant Likely <grant.likely@linaro.org>
Date:   Thu Mar 27 17:18:55 2014 -0700

    of: Create of_console_check() for selecting a console specified in /chosen
    
    The devicetree has a binding for specifying the console device in the
    /chosen node, but the kernel doesn't use it consistently. This change
    adds an API for testing if a device node is a console, and adds a
    preferred console entry if it is.
    
    At the same time this patch removes the of_device_is_stdout_path() API
    since it is unused.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Tested-by: Sascha Hauer <s.hauer@pengutronix.de>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index b9864806e9b8..df9b2bb7bb27 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -17,6 +17,7 @@
  *      as published by the Free Software Foundation; either version
  *      2 of the License, or (at your option) any later version.
  */
+#include <linux/console.h>
 #include <linux/ctype.h>
 #include <linux/cpu.h>
 #include <linux/module.h>
@@ -2180,20 +2181,22 @@ const char *of_prop_next_string(struct property *prop, const char *cur)
 EXPORT_SYMBOL_GPL(of_prop_next_string);
 
 /**
- * of_device_is_stdout_path - check if a device node matches the
- *                            linux,stdout-path property
- *
- * Check if this device node matches the linux,stdout-path property
- * in the chosen node. return true if yes, false otherwise.
+ * of_console_check() - Test and setup console for DT setup
+ * @dn - Pointer to device node
+ * @name - Name to use for preferred console without index. ex. "ttyS"
+ * @index - Index to use for preferred console.
+ *
+ * Check if the given device node matches the stdout-path property in the
+ * /chosen node. If it does then register it as the preferred console and return
+ * TRUE. Otherwise return FALSE.
  */
-int of_device_is_stdout_path(struct device_node *dn)
+bool of_console_check(struct device_node *dn, char *name, int index)
 {
-	if (!of_stdout)
+	if (!dn || dn != of_stdout || console_set_on_cmdline)
 		return false;
-
-	return of_stdout == dn;
+	return add_preferred_console(name, index, NULL);
 }
-EXPORT_SYMBOL_GPL(of_device_is_stdout_path);
+EXPORT_SYMBOL_GPL(of_console_check);
 
 /**
  *	of_find_next_cache_node - Find a node's subsidiary cache

commit 99de64984c3a7c9bf56a50e6dcc51006c9485620
Author: Frank Rowand <frank.rowand@sonymobile.com>
Date:   Sat Jun 14 20:39:05 2014 -0700

    OF: fix of_find_node_by_path() assumption that of_allnodes is root
    
    of_find_node_by_path() is borked because of_allnodes is not guaranteed to
    contain the root of the tree after using any of the dynamic update functions
    because some other nodes ends up as of_allnodes.
    
    Fixes: c22e650e66b8 of: Make of_find_node_by_path() handle /aliases
    Reported-by: pantelis.antoniou@konsulko.com
    Signed-off-by: Frank Rowand <frank.rowand@sonymobile.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index f27d922eaece..b9864806e9b8 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1961,9 +1961,9 @@ int of_attach_node(struct device_node *np)
 
 	raw_spin_lock_irqsave(&devtree_lock, flags);
 	np->sibling = np->parent->child;
-	np->allnext = of_allnodes;
+	np->allnext = np->parent->allnext;
+	np->parent->allnext = np;
 	np->parent->child = np;
-	of_allnodes = np;
 	of_node_clear_flag(np, OF_DETACHED);
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 

commit 28d3ee40ef5ad488f4ad3376d8f237b9502cecfb
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 10 09:57:00 2014 -0700

    of: avoid format string parsing in kobject names
    
    This makes sure a format string cannot leak into the kobject name that
    is constructed. (And splits the >80 character line.)
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 8368d96ae7b4..f27d922eaece 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -227,7 +227,8 @@ static int __of_node_add(struct device_node *np)
 	np->kobj.kset = of_kset;
 	if (!np->parent) {
 		/* Nodes without parents are new top level trees */
-		rc = kobject_add(&np->kobj, NULL, safe_name(&of_kset->kobj, "base"));
+		rc = kobject_add(&np->kobj, NULL, "%s",
+				 safe_name(&of_kset->kobj, "base"));
 	} else {
 		name = safe_name(&np->parent->kobj, kbasename(np->full_name));
 		if (!name || !name[0])

commit d27050641e9bc056446deb0814e7ba1aa7911f5a
Merge: b77279bc2e81 43cb43678705
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 4 10:02:38 2014 -0700

    Merge tag 'devicetree-for-3.16' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux into next
    
    Pull DeviceTree updates from Rob Herring:
     - Another round of clean-up of FDT related code in architecture code.
       This removes knowledge of internal FDT details from most
       architectures except powerpc.
     - Conversion of kernel's custom FDT parsing code to use libfdt.
     - DT based initialization for generic serial earlycon.  The
       introduction of generic serial earlycon support went in through the
       tty tree.
     - Improve the platform device naming for DT probed devices to ensure
       unique naming and use parent names instead of a global index.
     - Fix a race condition in of_update_property.
     - Unify the various linker section OF match tables and fix several
       function prototype errors.
     - Update platform_get_irq_byname to work in deferred probe cases.
     - 2 binding doc updates
    
    * tag 'devicetree-for-3.16' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (58 commits)
      of: handle NULL node in next_child iterators
      of/irq: provide more wrappers for !CONFIG_OF
      devicetree: bindings: Document micrel vendor prefix
      dt: bindings: dwc2: fix required value for the phy-names property
      of_pci_irq: kill useless variable in of_irq_parse_pci()
      of/irq: do irq resolution in platform_get_irq_byname()
      of: Add a testcase for of_find_node_by_path()
      of: Make of_find_node_by_path() handle /aliases
      of: Create unlocked version of for_each_child_of_node()
      lib: add glibc style strchrnul() variant
      of: Handle memory@0 node on PPC32 only
      pci/of: Remove dead code
      of: fix race between search and remove in of_update_property()
      of: Use NULL for pointers
      of: Stop naming platform_device using dcr address
      of: Ensure unique names without sacrificing determinism
      tty/serial: pl011: add DT based earlycon support
      of/fdt: add FDT serial scanning for earlycon
      of/fdt: add FDT address translation support
      serial: earlycon: add DT support
      ...

commit 1aacb90eaaac057c10fd746e189553e04cfeb291
Merge: b05d59dfceae 31789538e3ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 4 08:50:34 2014 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial into next
    
    Pull trivial tree changes from Jiri Kosina:
     "Usual pile of patches from trivial tree that make the world go round"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (23 commits)
      staging: go7007: remove reference to CONFIG_KMOD
      aic7xxx: Remove obsolete preprocessor define
      of: dma: doc fixes
      doc: fix incorrect formula to calculate CommitLimit value
      doc: Note need of bc in the kernel build from 3.10 onwards
      mm: Fix printk typo in dmapool.c
      modpost: Fix comment typo "Modules.symvers"
      Kconfig.debug: Grammar s/addition/additional/
      wimax: Spelling s/than/that/, wording s/destinatary/recipient/
      aic7xxx: Spelling s/termnation/termination/
      arm64: mm: Remove superfluous "the" in comment
      of: Spelling s/anonymouns/anonymous/
      dma: imx-sdma: Spelling s/determnine/determine/
      ath10k: Improve grammar in comments
      ath6kl: Spelling s/determnine/determine/
      of: Improve grammar for of_alias_get_id() documentation
      drm/exynos: Spelling s/contro/control/
      radio-bcm2048.c: fix wrong overflow check
      doc: printk-formats: do not mention casts for u64/s64
      doc: spelling error changes
      ...

commit 43cb43678705e39b175b325f17938295996aefc7
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Wed May 28 10:39:02 2014 -0700

    of: handle NULL node in next_child iterators
    
    Add an early check for the node argument in __of_get_next_child and
    of_get_next_available_child() to avoid dereferencing a NULL node pointer
    a few lines after.
    
    CC: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index e67b308819c9..567e6e1b7921 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -700,6 +700,9 @@ static struct device_node *__of_get_next_child(const struct device_node *node,
 {
 	struct device_node *next;
 
+	if (!node)
+		return NULL;
+
 	next = prev ? prev->sibling : node->child;
 	for (; next; next = next->sibling)
 		if (of_node_get(next))
@@ -746,6 +749,9 @@ struct device_node *of_get_next_available_child(const struct device_node *node,
 	struct device_node *next;
 	unsigned long flags;
 
+	if (!node)
+		return NULL;
+
 	raw_spin_lock_irqsave(&devtree_lock, flags);
 	next = prev ? prev->sibling : node->child;
 	for (; next; next = next->sibling) {

commit c22e650e66b862babe9c00bebb20b8029c7b0362
Author: Grant Likely <grant.likely@linaro.org>
Date:   Fri Mar 14 17:07:12 2014 +0000

    of: Make of_find_node_by_path() handle /aliases
    
    Make of_find_node_by_path() handle aliases as prefixes. To make this
    work the name search is refactored to search by path component instead
    of by full string. This should be a more efficient search, and it makes
    it possible to start a search at a subnode of a tree.
    
    Signed-off-by: David Daney <david.daney@cavium.com>
    Signed-off-by: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    [grant.likely: Rework to not require allocating at runtime]
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 9df50c74162c..e67b308819c9 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -783,23 +783,78 @@ struct device_node *of_get_child_by_name(const struct device_node *node,
 }
 EXPORT_SYMBOL(of_get_child_by_name);
 
+static struct device_node *__of_find_node_by_path(struct device_node *parent,
+						const char *path)
+{
+	struct device_node *child;
+	int len = strchrnul(path, '/') - path;
+
+	if (!len)
+		return NULL;
+
+	__for_each_child_of_node(parent, child) {
+		const char *name = strrchr(child->full_name, '/');
+		if (WARN(!name, "malformed device_node %s\n", child->full_name))
+			continue;
+		name++;
+		if (strncmp(path, name, len) == 0 && (strlen(name) == len))
+			return child;
+	}
+	return NULL;
+}
+
 /**
  *	of_find_node_by_path - Find a node matching a full OF path
- *	@path:	The full path to match
+ *	@path: Either the full path to match, or if the path does not
+ *	       start with '/', the name of a property of the /aliases
+ *	       node (an alias).  In the case of an alias, the node
+ *	       matching the alias' value will be returned.
+ *
+ *	Valid paths:
+ *		/foo/bar	Full path
+ *		foo		Valid alias
+ *		foo/bar		Valid alias + relative path
  *
  *	Returns a node pointer with refcount incremented, use
  *	of_node_put() on it when done.
  */
 struct device_node *of_find_node_by_path(const char *path)
 {
-	struct device_node *np = of_allnodes;
+	struct device_node *np = NULL;
+	struct property *pp;
 	unsigned long flags;
 
+	if (strcmp(path, "/") == 0)
+		return of_node_get(of_allnodes);
+
+	/* The path could begin with an alias */
+	if (*path != '/') {
+		char *p = strchrnul(path, '/');
+		int len = p - path;
+
+		/* of_aliases must not be NULL */
+		if (!of_aliases)
+			return NULL;
+
+		for_each_property_of_node(of_aliases, pp) {
+			if (strlen(pp->name) == len && !strncmp(pp->name, path, len)) {
+				np = of_find_node_by_path(pp->value);
+				break;
+			}
+		}
+		if (!np)
+			return NULL;
+		path = p;
+	}
+
+	/* Step down the tree matching path components */
 	raw_spin_lock_irqsave(&devtree_lock, flags);
-	for (; np; np = np->allnext) {
-		if (np->full_name && (of_node_cmp(np->full_name, path) == 0)
-		    && of_node_get(np))
-			break;
+	if (!np)
+		np = of_node_get(of_allnodes);
+	while (np && *path == '/') {
+		path++; /* Increment past '/' delimiter */
+		np = __of_find_node_by_path(np, path);
+		path = strchrnul(path, '/');
 	}
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 	return np;

commit 0d0e02d605c5696a5076510f564fefe659127aa4
Author: Grant Likely <grant.likely@linaro.org>
Date:   Thu May 22 01:04:17 2014 +0900

    of: Create unlocked version of for_each_child_of_node()
    
    When iterating over nodes, sometimes it needs to be done when the DT
    lock is already held. This patch makes an unlocked version of the
    for_each_child_of_node() macro.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 63ae00ec72ff..9df50c74162c 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -695,6 +695,22 @@ struct device_node *of_get_next_parent(struct device_node *node)
 }
 EXPORT_SYMBOL(of_get_next_parent);
 
+static struct device_node *__of_get_next_child(const struct device_node *node,
+						struct device_node *prev)
+{
+	struct device_node *next;
+
+	next = prev ? prev->sibling : node->child;
+	for (; next; next = next->sibling)
+		if (of_node_get(next))
+			break;
+	of_node_put(prev);
+	return next;
+}
+#define __for_each_child_of_node(parent, child) \
+	for (child = __of_get_next_child(parent, NULL); child != NULL; \
+	     child = __of_get_next_child(parent, child))
+
 /**
  *	of_get_next_child - Iterate a node childs
  *	@node:	parent node
@@ -710,11 +726,7 @@ struct device_node *of_get_next_child(const struct device_node *node,
 	unsigned long flags;
 
 	raw_spin_lock_irqsave(&devtree_lock, flags);
-	next = prev ? prev->sibling : node->child;
-	for (; next; next = next->sibling)
-		if (of_node_get(next))
-			break;
-	of_node_put(prev);
+	next = __of_get_next_child(node, prev);
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 	return next;
 }

commit 947fdaad0627e277c5f3a2573203c4fab3db513b
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Thu Apr 17 15:48:29 2014 +0800

    of: fix race between search and remove in of_update_property()
    
    The of_update_property() is intented to update a property in a node
    and if the property does not exist, will add it.
    
    The second search of the property is possibly won't be found, that
    maybe removed by other thread just before the second search begain.
    
    Using the __of_find_property() and __of_add_property() instead and
    move them into lock operations.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    [grant.likely: conflict with another change in same function]
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 6d4ee22708c9..63ae00ec72ff 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1800,7 +1800,7 @@ int of_update_property(struct device_node *np, struct property *newprop)
 {
 	struct property **next, *oldprop;
 	unsigned long flags;
-	int rc, found = 0;
+	int rc;
 
 	rc = of_property_notify(OF_RECONFIG_UPDATE_PROPERTY, np, newprop);
 	if (rc)
@@ -1809,30 +1809,34 @@ int of_update_property(struct device_node *np, struct property *newprop)
 	if (!newprop->name)
 		return -EINVAL;
 
-	oldprop = of_find_property(np, newprop->name, NULL);
-	if (!oldprop)
-		return of_add_property(np, newprop);
-
 	raw_spin_lock_irqsave(&devtree_lock, flags);
 	next = &np->properties;
-	while (*next) {
+	oldprop = __of_find_property(np, newprop->name, NULL);
+	if (!oldprop) {
+		/* add the new node */
+		rc = __of_add_property(np, newprop);
+	} else while (*next) {
+		/* replace the node */
 		if (*next == oldprop) {
-			/* found the node */
 			newprop->next = oldprop->next;
 			*next = newprop;
 			oldprop->next = np->deadprops;
 			np->deadprops = oldprop;
-			found = 1;
 			break;
 		}
 		next = &(*next)->next;
 	}
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
-	if (!found)
-		return -ENODEV;
+	if (rc)
+		return rc;
+
+	/* At early boot, bail out and defer setup to of_init() */
+	if (!of_kset)
+		return 0;
 
 	/* Update the sysfs attribute */
-	sysfs_remove_bin_file(&np->kobj, &oldprop->attr);
+	if (oldprop)
+		sysfs_remove_bin_file(&np->kobj, &oldprop->attr);
 	__of_add_property_sysfs(np, newprop);
 
 	return 0;

commit 582da6527da30f6e21a95c9f3f2810d46a8f406e
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Wed May 14 13:36:36 2014 +0200

    of: make of_update_property() usable earlier in the boot process
    
    Commit 75b57ecf9d1d1e17d099ab13b8f48e6e038676be ('of: Make device
    nodes kobjects so they show up in sysfs') has turned Device Tree nodes
    in kobjects and added a sysfs based representation for Device Tree
    nodes. Since the sysfs logic is only available after the execution of
    a core_initcall(), the patch took precautions in of_add_property() and
    of_remove_property() to not do any sysfs related manipulation early in
    the boot process.
    
    However, it forgot to do the same for of_update_property(), which if
    used early in the boot process (before core_initcalls have been
    called), tries to call sysfs_remove_bin_file(), and crashes:
    
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 0 at /home/thomas/projets/linux-2.6/fs/kernfs/dir.c:1216 kernfs_remove_by_name_ns+0x80/0x88()
    kernfs: can not remove '(null)', no directory
    Modules linked in:
    CPU: 0 PID: 0 Comm: swapper/0 Not tainted 3.15.0-rc1-00127-g1d7e7b2-dirty #423
    [<c0014910>] (unwind_backtrace) from [<c00110ec>] (show_stack+0x10/0x14)
    [<c00110ec>] (show_stack) from [<c04c84b8>] (dump_stack+0x84/0x94)
    [<c04c84b8>] (dump_stack) from [<c001d8c0>] (warn_slowpath_common+0x6c/0x88)
    [<c001d8c0>] (warn_slowpath_common) from [<c001d90c>] (warn_slowpath_fmt+0x30/0x40)
    [<c001d90c>] (warn_slowpath_fmt) from [<c0104468>] (kernfs_remove_by_name_ns+0x80/0x88)
    [<c0104468>] (kernfs_remove_by_name_ns) from [<c0394d98>] (of_update_property+0xc0/0xf0)
    [<c0394d98>] (of_update_property) from [<c0647248>] (mvebu_timer_and_clk_init+0xfc/0x194)
    [<c0647248>] (mvebu_timer_and_clk_init) from [<c0640934>] (start_kernel+0x218/0x350)
    [<c0640934>] (start_kernel) from [<00008070>] (0x8070)
    ---[ end trace 3406ff24bd97382e ]---
    Unable to handle kernel NULL pointer dereference at virtual address 0000003c
    pgd = c0004000
    [0000003c] *pgd=00000000
    Internal error: Oops: 5 [#1] SMP ARM
    Modules linked in:
    CPU: 0 PID: 0 Comm: swapper/0 Tainted: G        W     3.15.0-rc1-00127-g1d7e7b2-dirty #423
    task: c10ad4d8 ti: c10a2000 task.ti: c10a2000
    PC is at kernfs_find_ns+0x8/0xf0
    LR is at kernfs_find_and_get_ns+0x30/0x48
    pc : [<c0103834>]    lr : [<c010394c>]    psr: 600001d3
    sp : c10a3f34  ip : 00000073  fp : 00000000
    r10: 00000000  r9 : cfffc240  r8 : cfdf2980
    r7 : cf812c00  r6 : 00000000  r5 : 00000000  r4 : c10b45e0
    r3 : c10ad4d8  r2 : 00000000  r1 : cf812c00  r0 : 00000000
    Flags: nZCv  IRQs off  FIQs off  Mode SVC_32  ISA ARM  Segment kernel
    Control: 10c53c7d  Table: 0000404a  DAC: 00000015
    Process swapper/0 (pid: 0, stack limit = 0xc10a2240)
    Stack: (0xc10a3f34 to 0xc10a4000)
    3f20:                                              c10b45e0 00000000 00000000
    3f40: cf812c00 c010394c 00000063 cf812c00 00000001 cf812c00 cfdf29ac c03932cc
    3f60: 00000063 cf812bc0 cfdf29ac cf812c00 ffffffff c03943f8 cfdf2980 c0104468
    3f80: cfdf2a04 cfdf2980 cf812bc0 c06634b0 c10aa3c0 c0394da4 c10f74dc cfdf2980
    3fa0: cf812bc0 c0647248 c10aa3c0 ffffffff c10de940 c10aa3c0 ffffffff c0640934
    3fc0: ffffffff ffffffff c06404ec 00000000 00000000 c06634b0 00000000 10c53c7d
    3fe0: c10aa434 c06634ac c10ae4c8 0000406a 414fc091 00008070 00000000 00000000
    [<c0103834>] (kernfs_find_ns) from [<00000001>] (0x1)
    Code: e5c89001 eaffffcf e92d40f0 e1a06002 (e1d023bc)
    ---[ end trace 3406ff24bd97382f ]---
    Kernel panic - not syncing: Attempted to kill the idle task!
    ---[ end Kernel panic - not syncing: Attempted to kill the idle task!
    
    To fix this problem, we simply skip the sysfs related calls in
    of_update_property(), and rely on of_init() to fix up things when it
    will be called, exactly as is done in of_add_property() and
    of_remove_property().
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Fixes: 75b57ecf9d1d ("of: Make device nodes kobjects so they show up in sysfs")
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 6d4ee22708c9..32e969d95319 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1831,6 +1831,10 @@ int of_update_property(struct device_node *np, struct property *newprop)
 	if (!found)
 		return -ENODEV;
 
+	/* At early boot, bail out and defer setup to of_init() */
+	if (!of_kset)
+		return found ? 0 : -ENODEV;
+
 	/* Update the sysfs attribute */
 	sysfs_remove_bin_file(&np->kobj, &oldprop->attr);
 	__of_add_property_sysfs(np, newprop);

commit 5a53a07f12da4377df8016ffc7fd465411cc1a7b
Author: Geert Uytterhoeven <geert+renesas@linux-m68k.org>
Date:   Tue Mar 11 11:23:38 2014 +0100

    of: Improve grammar for of_alias_get_id() documentation
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@linux-m68k.org>
    Acked-by: Rob Herring <robh@kernel.org>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: devicetree@vger.kernel.org
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 4557a142c752..ce1d3d8a0cd8 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -2040,8 +2040,8 @@ void of_alias_scan(void * (*dt_alloc)(u64 size, u64 align))
  * @np:		Pointer to the given device_node
  * @stem:	Alias stem of the given device_node
  *
- * The function travels the lookup table to get alias id for the given
- * device_node and alias stem.  It returns the alias id if find it.
+ * The function travels the lookup table to get the alias id for the given
+ * device_node and alias stem.  It returns the alias id if found.
  */
 int of_alias_get_id(struct device_node *np, const char *stem)
 {

commit e7a62df8e8b4a5ecbbf4339b5b3671ae6582e50a
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Tue Apr 15 08:38:17 2014 -0700

    of: Clean up of_update_property
    
    After searching for the old property, bail out with -ENODEV
    if it was not found.
    
    It is unnecessary to check if oldprop is NULL before removing
    its binary file; the check was already done before.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index f72d19b7e5d2..6d4ee22708c9 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1828,17 +1828,13 @@ int of_update_property(struct device_node *np, struct property *newprop)
 		next = &(*next)->next;
 	}
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
-	if (rc)
-		return rc;
+	if (!found)
+		return -ENODEV;
 
 	/* Update the sysfs attribute */
-	if (oldprop)
-		sysfs_remove_bin_file(&np->kobj, &oldprop->attr);
+	sysfs_remove_bin_file(&np->kobj, &oldprop->attr);
 	__of_add_property_sysfs(np, newprop);
 
-	if (!found)
-		return -ENODEV;
-
 	return 0;
 }
 

commit 3c83e61e67256e0bb08c46cc2db43b58fd617251
Merge: 4a4389abdd98 a83b93a74804
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 4 09:50:07 2014 -0700

    Merge branch 'v4l_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media
    
    Pull media updates from Mauro Carvalho Chehab:
     "The main set of series of patches for media subsystem, including:
       - document RC sysfs class
       - added an API to setup scancode to allow waking up systems using the
         Remote Controller
       - add API for SDR devices.  Drivers are still on staging
       - some API improvements for getting EDID data from media
         inputs/outputs
       - new DVB frontend driver for drx-j (ATSC)
       - one driver (it913x/it9137) got removed, in favor of an improvement
         on another driver (af9035)
       - added a skeleton V4L2 PCI driver at documentation
       - added a dual flash driver (lm3646)
       - added a new IR driver (img-ir)
       - added an IR scancode decoder for the Sharp protocol
       - some improvements at the usbtv driver, to allow its core to be
         reused.
       - added a new SDR driver (rtl2832u_sdr)
       - added a new tuner driver (msi001)
       - several improvements at em28xx driver to fix PM support, device
         removal and to split the V4L2 specific bits into a separate
         sub-driver
       - one driver got converted to videobuf2 (s2255drv)
       - the e4000 tuner driver now follows an improved binding model
       - some fixes at V4L2 compat32 code
       - several fixes and enhancements at videobuf2 code
       - some cleanups at V4L2 API documentation
       - usual driver enhancements, new board additions and misc fixups"
    
    [ NOTE! This merge effective drops commit 4329b93b283c ("of: Reduce
      indentation in of_graph_get_next_endpoint").
    
      The of_graph_get_next_endpoint() function was moved and renamed by
      commit fd9fdb78a9bf ("[media] of: move graph helpers from
      drivers/media/v4l2-core to drivers/of").  It was originally called
      v4l2_of_get_next_endpoint() and lived in the file
      drivers/media/v4l2-core/v4l2-of.c.
    
      In that original location, it was then fixed to support empty port
      nodes by commit b9db140c1e46 ("[media] v4l: of: Support empty port
      nodes"), and that commit clashes badly with the dropped "Reduce
      intendation" commit.  I had to choose one or the other, and decided
      that the "Support empty port nodes" commit was more important ]
    
    * 'v4l_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media: (426 commits)
      [media] em28xx-dvb: fix PCTV 461e tuner I2C binding
      Revert "[media] em28xx-dvb: fix PCTV 461e tuner I2C binding"
      [media] em28xx: fix PCTV 290e LNA oops
      [media] em28xx-dvb: fix PCTV 461e tuner I2C binding
      [media] m88ds3103: fix bug on .set_tone()
      [media] saa7134: fix WARN_ON during resume
      [media] v4l2-dv-timings: add module name, description, license
      [media] videodev2.h: add parenthesis around macro arguments
      [media] saa6752hs: depends on CRC32
      [media] si4713: fix Kconfig dependencies
      [media] Sensoray 2255 uses videobuf2
      [media] adv7180: free an interrupt on failure paths in init_device()
      [media] e4000: make VIDEO_V4L2 dependency optional
      [media] af9033: Don't export functions for the hardware filter
      [media] af9035: use af9033 PID filters
      [media] af9033: implement PID filter
      [media] rtl2832_sdr: do not use dynamic stack allocation
      [media] e4000: fix 32-bit build error
      [media] em28xx-audio: make sure audio is unmuted on open()
      [media] DocBook media: v4l2_format_sdr was renamed to v4l2_sdr_format
      ...

commit b9f2b21a32906a47c220b5167b88869f2c90f1c4
Merge: 70f6c087573e a0e7398357f2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Apr 2 14:27:15 2014 -0700

    Merge tag 'dt-for-linus' of git://git.secretlab.ca/git/linux
    
    Pull devicetree changes from Grant Likely:
     "Updates to devicetree core code.  This branch contains the following
      notable changes:
    
       - add reserved memory binding
       - make struct device_node a kobject and remove legacy
         /proc/device-tree
       - ePAPR conformance fixes
       - update in-kernel DTC copy to version v1.4.0
       - preparatory changes for dynamic device tree overlays
       - minor bug fixes and documentation changes
    
      The most significant change in this branch is the conversion of struct
      device_node to be a kobject that is exposed via sysfs and removal of
      the old /proc/device-tree code.  This simplifies the device tree
      handling code and tightens up the lifecycle on device tree nodes.
    
      [updated: added fix for dangling select PROC_DEVICETREE]"
    
    * tag 'dt-for-linus' of git://git.secretlab.ca/git/linux: (29 commits)
      dt: Remove dangling "select PROC_DEVICETREE"
      of: Add support for ePAPR "stdout-path" property
      of: device_node kobject lifecycle fixes
      of: only scan for reserved mem when fdt present
      powerpc: add support for reserved memory defined by device tree
      arm64: add support for reserved memory defined by device tree
      of: add missing major vendors
      of: add vendor prefix for SMSC
      of: remove /proc/device-tree
      of/selftest: Add self tests for manipulation of properties
      of: Make device nodes kobjects so they show up in sysfs
      arm: add support for reserved memory defined by device tree
      drivers: of: add support for custom reserved memory drivers
      drivers: of: add initialization code for dynamic reserved memory
      drivers: of: add initialization code for static reserved memory
      of: document bindings for reserved-memory nodes
      Revert "of: fix of_update_property()"
      kbuild: dtbs_install: new make target
      ARM: mvebu: Allows to get the SoC ID even without PCI enabled
      of: Allows to use the PCI translator without the PCI core
      ...

commit c12e69c6aaf785fd307d05cb6f36ca0e7577ead7
Merge: 158e0d362168 94debda32429
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 1 16:45:00 2014 -0700

    Merge tag 'staging-3.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    Pull staging driver updates from Greg KH:
     "Here's the huge drivers/staging/ update for 3.15-rc1.
    
      Loads of cleanup fixes, a few drivers removed, and some new ones
      added.
    
      All have been in linux-next for a while"
    
    * tag 'staging-3.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (1375 commits)
      staging: xillybus: XILLYBUS_PCIE depends on PCI_MSI
      staging: xillybus: Added "select CRC32" for XILLYBUS in Kconfig
      staging: comedi: poc: remove obsolete driver
      staging: unisys: replace kzalloc/kfree with UISMALLOC/UISFREE
      staging: octeon-usb: prevent memory corruption
      staging: usbip: fix line over 80 characters
      staging: usbip: fix quoted string split across lines
      Staging: unisys: Remove RETINT macro
      Staging: unisys: Remove FAIL macro
      Staging: unisys: Remove RETVOID macro
      Staging: unisys: Remove RETPTR macro
      Staging: unisys: Remove RETBOOL macro
      Staging: unisys: Remove FAIL_WPOSTCODE_1 macro
      Staging: unisys: Cleanup macros to get rid of goto statements
      Staging: unisys: include: Remove unused macros from timskmod.h
      staging: dgap: fix the rest of the checkpatch warnings in dgap.c
      Staging: bcm: Remove unnecessary parentheses
      staging: wlags49_h2: Delete unnecessary braces
      staging: wlags49_h2: Do not use assignment in if condition
      staging: wlags49_h2: Enclose macro in a do-while loop
      ...

commit 676e1b2fcd9dbb47a59baac13d089621d22c68b8
Author: Grant Likely <grant.likely@linaro.org>
Date:   Thu Mar 27 17:11:23 2014 -0700

    of: Add support for ePAPR "stdout-path" property
    
    ePAPR 1.1 defines the "stdout-path" property for specifying the console
    device, but Linux currently only handles the older "linux,stdout-path"
    property. This patch adds parsing for the new property name.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 418a4ff9d97c..be2861d69b02 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1955,9 +1955,9 @@ void of_alias_scan(void * (*dt_alloc)(u64 size, u64 align))
 		of_chosen = of_find_node_by_path("/chosen@0");
 
 	if (of_chosen) {
-		const char *name;
-
-		name = of_get_property(of_chosen, "linux,stdout-path", NULL);
+		const char *name = of_get_property(of_chosen, "stdout-path", NULL);
+		if (!name)
+			name = of_get_property(of_chosen, "linux,stdout-path", NULL);
 		if (name)
 			of_stdout = of_find_node_by_path(name);
 	}

commit 794016f9dcb5930205becb040860190662c5847c
Merge: c9cbbd4fc066 7f196ec93896 ca5d1b3524b4 df948bbf4868 f1b3f9031d25 1f5a9623eb43 a1985d469d5c ad5ec6cdb2c4 4d047d6c1fbe
Author: Mark Brown <broonie@linaro.org>
Date:   Wed Mar 26 16:57:57 2014 +0000

    Merge remote-tracking branches 'regulator/topic/doc', 'regulator/topic/enable', 'regulator/topic/fan53555', 'regulator/topic/fixed', 'regulator/topic/gpio', 'regulator/topic/lp3971', 'regulator/topic/lp872x' and 'regulator/topic/max14577' into regulator-next

commit 0829f6d1f69e4f2fae4062987ae6531a9af1a2e3
Author: Pantelis Antoniou <panto@antoniou-consulting.com>
Date:   Fri Dec 13 20:08:59 2013 +0200

    of: device_node kobject lifecycle fixes
    
    After the move to having device nodes be proper kobjects the lifecycle
    of the node needs to be controlled better.
    
    At first convert of_add_node() in the unflattened functions to
    of_init_node() which initializes the kobject so that of_node_get/put
    work correctly even before of_init is called.
    
    Afterwards introduce of_node_is_initialized & of_node_is_attached that
    query the underlying kobject about the state (attached means kobj
    is visible in sysfs)
    
    Using that make sure the lifecycle of the tree is correct at all
    times.
    
    Signed-off-by: Pantelis Antoniou <panto@antoniou-consulting.com>
    [grant.likely: moved of_node_init() calls, fixed up locking, and
                   dropped __of_populate() hunks]
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index ed3e70b84957..418a4ff9d97c 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -246,10 +246,19 @@ static int __of_node_add(struct device_node *np)
 int of_node_add(struct device_node *np)
 {
 	int rc = 0;
-	kobject_init(&np->kobj, &of_node_ktype);
+
+	BUG_ON(!of_node_is_initialized(np));
+
+	/*
+	 * Grab the mutex here so that in a race condition between of_init() and
+	 * of_node_add(), node addition will still be consistent.
+	 */
 	mutex_lock(&of_aliases_mutex);
 	if (of_kset)
 		rc = __of_node_add(np);
+	else
+		/* This scenario may be perfectly valid, but report it anyway */
+		pr_info("of_node_add(%s) before of_init()\n", np->full_name);
 	mutex_unlock(&of_aliases_mutex);
 	return rc;
 }
@@ -259,10 +268,17 @@ static void of_node_remove(struct device_node *np)
 {
 	struct property *pp;
 
-	for_each_property_of_node(np, pp)
-		sysfs_remove_bin_file(&np->kobj, &pp->attr);
+	BUG_ON(!of_node_is_initialized(np));
+
+	/* only remove properties if on sysfs */
+	if (of_node_is_attached(np)) {
+		for_each_property_of_node(np, pp)
+			sysfs_remove_bin_file(&np->kobj, &pp->attr);
+		kobject_del(&np->kobj);
+	}
 
-	kobject_del(&np->kobj);
+	/* finally remove the kobj_init ref */
+	of_node_put(np);
 }
 #endif
 
@@ -1631,6 +1647,10 @@ static int of_property_notify(int action, struct device_node *np,
 {
 	struct of_prop_reconfig pr;
 
+	/* only call notifiers if the node is attached */
+	if (!of_node_is_attached(np))
+		return 0;
+
 	pr.dn = np;
 	pr.prop = prop;
 	return of_reconfig_notify(action, &pr);
@@ -1682,11 +1702,8 @@ int of_add_property(struct device_node *np, struct property *prop)
 	if (rc)
 		return rc;
 
-	/* at early boot, bail hear and defer setup to of_init() */
-	if (!of_kset)
-		return 0;
-
-	__of_add_property_sysfs(np, prop);
+	if (of_node_is_attached(np))
+		__of_add_property_sysfs(np, prop);
 
 	return rc;
 }

commit 8357041a69b368991d1b04d9f1d297f8d71e1314
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Nov 6 21:03:27 2012 +0000

    of: remove /proc/device-tree
    
    The same data is now available in sysfs, so we can remove the code
    that exports it in /proc and replace it with a symlink to the sysfs
    version.
    
    Tested on versatile qemu model and mpc5200 eval board. More testing
    would be appreciated.
    
    v5: Fixed up conflicts with mainline changes
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Nathan Fontenot <nfont@linux.vnet.ibm.com>
    Cc: Pantelis Antoniou <panto@antoniou-consulting.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 3b70a468c8ab..ed3e70b84957 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -281,11 +281,9 @@ static int __init of_init(void)
 		__of_node_add(np);
 	mutex_unlock(&of_aliases_mutex);
 
-#if !defined(CONFIG_PROC_DEVICETREE)
-	/* Symlink to the new tree when PROC_DEVICETREE is disabled */
+	/* Symlink in /proc as required by userspace ABI */
 	if (of_allnodes)
 		proc_symlink("device-tree", NULL, "/sys/firmware/devicetree/base");
-#endif /* CONFIG_PROC_DEVICETREE */
 
 	return 0;
 }
@@ -1690,12 +1688,6 @@ int of_add_property(struct device_node *np, struct property *prop)
 
 	__of_add_property_sysfs(np, prop);
 
-#ifdef CONFIG_PROC_DEVICETREE
-	/* try to add to proc as well if it was initialized */
-	if (!rc && np->pde)
-		proc_device_tree_add_prop(np->pde, prop);
-#endif /* CONFIG_PROC_DEVICETREE */
-
 	return rc;
 }
 
@@ -1742,12 +1734,6 @@ int of_remove_property(struct device_node *np, struct property *prop)
 
 	sysfs_remove_bin_file(&np->kobj, &prop->attr);
 
-#ifdef CONFIG_PROC_DEVICETREE
-	/* try to remove the proc node as well */
-	if (np->pde)
-		proc_device_tree_remove_prop(np->pde, prop);
-#endif /* CONFIG_PROC_DEVICETREE */
-
 	return 0;
 }
 
@@ -1803,12 +1789,6 @@ int of_update_property(struct device_node *np, struct property *newprop)
 	if (!found)
 		return -ENODEV;
 
-#ifdef CONFIG_PROC_DEVICETREE
-	/* try to add to proc as well if it was initialized */
-	if (np->pde)
-		proc_device_tree_update_prop(np->pde, newprop, oldprop);
-#endif /* CONFIG_PROC_DEVICETREE */
-
 	return 0;
 }
 
@@ -1843,22 +1823,6 @@ int of_reconfig_notify(unsigned long action, void *p)
 	return notifier_to_errno(rc);
 }
 
-#ifdef CONFIG_PROC_DEVICETREE
-static void of_add_proc_dt_entry(struct device_node *dn)
-{
-	struct proc_dir_entry *ent;
-
-	ent = proc_mkdir(strrchr(dn->full_name, '/') + 1, dn->parent->pde);
-	if (ent)
-		proc_device_tree_add_node(dn, ent);
-}
-#else
-static void of_add_proc_dt_entry(struct device_node *dn)
-{
-	return;
-}
-#endif
-
 /**
  * of_attach_node - Plug a device node into the tree and global list.
  */
@@ -1880,22 +1844,9 @@ int of_attach_node(struct device_node *np)
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 
 	of_node_add(np);
-	of_add_proc_dt_entry(np);
 	return 0;
 }
 
-#ifdef CONFIG_PROC_DEVICETREE
-static void of_remove_proc_dt_entry(struct device_node *dn)
-{
-	proc_remove(dn->pde);
-}
-#else
-static void of_remove_proc_dt_entry(struct device_node *dn)
-{
-	return;
-}
-#endif
-
 /**
  * of_detach_node - "Unplug" a node from the device tree.
  *
@@ -1951,7 +1902,6 @@ int of_detach_node(struct device_node *np)
 	of_node_set_flag(np, OF_DETACHED);
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 
-	of_remove_proc_dt_entry(np);
 	of_node_remove(np);
 	return rc;
 }

commit 75b57ecf9d1d1e17d099ab13b8f48e6e038676be
Author: Grant Likely <grant.likely@linaro.org>
Date:   Thu Feb 20 18:02:11 2014 +0000

    of: Make device nodes kobjects so they show up in sysfs
    
    Device tree nodes are already treated as objects, and we already want to
    expose them to userspace which is done using the /proc filesystem today.
    Right now the kernel has to do a lot of work to keep the /proc view in
    sync with the in-kernel representation. If device_nodes are switched to
    be kobjects then the device tree code can be a whole lot simpler. It
    also turns out that switching to using /sysfs from /proc results in
    smaller code and data size, and the userspace ABI won't change if
    /proc/device-tree symlinks to /sys/firmware/devicetree/base.
    
    v7: Add missing sysfs_bin_attr_init()
    v6: Add __of_add_property() early init fixes from Pantelis
    v5: Rename firmware/ofw to firmware/devicetree
        Fix updating property values in sysfs
    v4: Fixed build error on Powerpc
        Fixed handling of dynamic nodes on powerpc
    v3: Fixed handling of duplicate attribute and child node names
    v2: switch to using sysfs bin_attributes which solve the problem of
        reporting incorrect property size.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Tested-by: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Nathan Fontenot <nfont@linux.vnet.ibm.com>
    Cc: Pantelis Antoniou <panto@antoniou-consulting.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 48594f334151..3b70a468c8ab 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -23,6 +23,7 @@
 #include <linux/of.h>
 #include <linux/spinlock.h>
 #include <linux/slab.h>
+#include <linux/string.h>
 #include <linux/proc_fs.h>
 
 #include "of_private.h"
@@ -35,6 +36,12 @@ struct device_node *of_chosen;
 struct device_node *of_aliases;
 static struct device_node *of_stdout;
 
+static struct kset *of_kset;
+
+/*
+ * Used to protect the of_aliases; but also overloaded to hold off addition of
+ * nodes to sysfs
+ */
 DEFINE_MUTEX(of_aliases_mutex);
 
 /* use when traversing tree through the allnext, child, sibling,
@@ -92,14 +99,14 @@ int __weak of_node_to_nid(struct device_node *np)
 struct device_node *of_node_get(struct device_node *node)
 {
 	if (node)
-		kref_get(&node->kref);
+		kobject_get(&node->kobj);
 	return node;
 }
 EXPORT_SYMBOL(of_node_get);
 
-static inline struct device_node *kref_to_device_node(struct kref *kref)
+static inline struct device_node *kobj_to_device_node(struct kobject *kobj)
 {
-	return container_of(kref, struct device_node, kref);
+	return container_of(kobj, struct device_node, kobj);
 }
 
 /**
@@ -109,16 +116,15 @@ static inline struct device_node *kref_to_device_node(struct kref *kref)
  *	In of_node_put() this function is passed to kref_put()
  *	as the destructor.
  */
-static void of_node_release(struct kref *kref)
+static void of_node_release(struct kobject *kobj)
 {
-	struct device_node *node = kref_to_device_node(kref);
+	struct device_node *node = kobj_to_device_node(kobj);
 	struct property *prop = node->properties;
 
 	/* We should never be releasing nodes that haven't been detached. */
 	if (!of_node_check_flag(node, OF_DETACHED)) {
 		pr_err("ERROR: Bad of_node_put() on %s\n", node->full_name);
 		dump_stack();
-		kref_init(&node->kref);
 		return;
 	}
 
@@ -151,11 +157,140 @@ static void of_node_release(struct kref *kref)
 void of_node_put(struct device_node *node)
 {
 	if (node)
-		kref_put(&node->kref, of_node_release);
+		kobject_put(&node->kobj);
 }
 EXPORT_SYMBOL(of_node_put);
+#else
+static void of_node_release(struct kobject *kobj)
+{
+	/* Without CONFIG_OF_DYNAMIC, no nodes gets freed */
+}
 #endif /* CONFIG_OF_DYNAMIC */
 
+struct kobj_type of_node_ktype = {
+	.release = of_node_release,
+};
+
+static ssize_t of_node_property_read(struct file *filp, struct kobject *kobj,
+				struct bin_attribute *bin_attr, char *buf,
+				loff_t offset, size_t count)
+{
+	struct property *pp = container_of(bin_attr, struct property, attr);
+	return memory_read_from_buffer(buf, count, &offset, pp->value, pp->length);
+}
+
+static const char *safe_name(struct kobject *kobj, const char *orig_name)
+{
+	const char *name = orig_name;
+	struct kernfs_node *kn;
+	int i = 0;
+
+	/* don't be a hero. After 16 tries give up */
+	while (i < 16 && (kn = sysfs_get_dirent(kobj->sd, name))) {
+		sysfs_put(kn);
+		if (name != orig_name)
+			kfree(name);
+		name = kasprintf(GFP_KERNEL, "%s#%i", orig_name, ++i);
+	}
+
+	if (name != orig_name)
+		pr_warn("device-tree: Duplicate name in %s, renamed to \"%s\"\n",
+			kobject_name(kobj), name);
+	return name;
+}
+
+static int __of_add_property_sysfs(struct device_node *np, struct property *pp)
+{
+	int rc;
+
+	/* Important: Don't leak passwords */
+	bool secure = strncmp(pp->name, "security-", 9) == 0;
+
+	sysfs_bin_attr_init(&pp->attr);
+	pp->attr.attr.name = safe_name(&np->kobj, pp->name);
+	pp->attr.attr.mode = secure ? S_IRUSR : S_IRUGO;
+	pp->attr.size = secure ? 0 : pp->length;
+	pp->attr.read = of_node_property_read;
+
+	rc = sysfs_create_bin_file(&np->kobj, &pp->attr);
+	WARN(rc, "error adding attribute %s to node %s\n", pp->name, np->full_name);
+	return rc;
+}
+
+static int __of_node_add(struct device_node *np)
+{
+	const char *name;
+	struct property *pp;
+	int rc;
+
+	np->kobj.kset = of_kset;
+	if (!np->parent) {
+		/* Nodes without parents are new top level trees */
+		rc = kobject_add(&np->kobj, NULL, safe_name(&of_kset->kobj, "base"));
+	} else {
+		name = safe_name(&np->parent->kobj, kbasename(np->full_name));
+		if (!name || !name[0])
+			return -EINVAL;
+
+		rc = kobject_add(&np->kobj, &np->parent->kobj, "%s", name);
+	}
+	if (rc)
+		return rc;
+
+	for_each_property_of_node(np, pp)
+		__of_add_property_sysfs(np, pp);
+
+	return 0;
+}
+
+int of_node_add(struct device_node *np)
+{
+	int rc = 0;
+	kobject_init(&np->kobj, &of_node_ktype);
+	mutex_lock(&of_aliases_mutex);
+	if (of_kset)
+		rc = __of_node_add(np);
+	mutex_unlock(&of_aliases_mutex);
+	return rc;
+}
+
+#if defined(CONFIG_OF_DYNAMIC)
+static void of_node_remove(struct device_node *np)
+{
+	struct property *pp;
+
+	for_each_property_of_node(np, pp)
+		sysfs_remove_bin_file(&np->kobj, &pp->attr);
+
+	kobject_del(&np->kobj);
+}
+#endif
+
+static int __init of_init(void)
+{
+	struct device_node *np;
+
+	/* Create the kset, and register existing nodes */
+	mutex_lock(&of_aliases_mutex);
+	of_kset = kset_create_and_add("devicetree", NULL, firmware_kobj);
+	if (!of_kset) {
+		mutex_unlock(&of_aliases_mutex);
+		return -ENOMEM;
+	}
+	for_each_of_allnodes(np)
+		__of_node_add(np);
+	mutex_unlock(&of_aliases_mutex);
+
+#if !defined(CONFIG_PROC_DEVICETREE)
+	/* Symlink to the new tree when PROC_DEVICETREE is disabled */
+	if (of_allnodes)
+		proc_symlink("device-tree", NULL, "/sys/firmware/devicetree/base");
+#endif /* CONFIG_PROC_DEVICETREE */
+
+	return 0;
+}
+core_initcall(of_init);
+
 static struct property *__of_find_property(const struct device_node *np,
 					   const char *name, int *lenp)
 {
@@ -1546,6 +1681,14 @@ int of_add_property(struct device_node *np, struct property *prop)
 	raw_spin_lock_irqsave(&devtree_lock, flags);
 	rc = __of_add_property(np, prop);
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
+	if (rc)
+		return rc;
+
+	/* at early boot, bail hear and defer setup to of_init() */
+	if (!of_kset)
+		return 0;
+
+	__of_add_property_sysfs(np, prop);
 
 #ifdef CONFIG_PROC_DEVICETREE
 	/* try to add to proc as well if it was initialized */
@@ -1593,6 +1736,12 @@ int of_remove_property(struct device_node *np, struct property *prop)
 	if (!found)
 		return -ENODEV;
 
+	/* at early boot, bail hear and defer setup to of_init() */
+	if (!of_kset)
+		return 0;
+
+	sysfs_remove_bin_file(&np->kobj, &prop->attr);
+
 #ifdef CONFIG_PROC_DEVICETREE
 	/* try to remove the proc node as well */
 	if (np->pde)
@@ -1643,13 +1792,20 @@ int of_update_property(struct device_node *np, struct property *newprop)
 		next = &(*next)->next;
 	}
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
+	if (rc)
+		return rc;
+
+	/* Update the sysfs attribute */
+	if (oldprop)
+		sysfs_remove_bin_file(&np->kobj, &oldprop->attr);
+	__of_add_property_sysfs(np, newprop);
 
 	if (!found)
 		return -ENODEV;
 
 #ifdef CONFIG_PROC_DEVICETREE
 	/* try to add to proc as well if it was initialized */
-	if (!rc && np->pde)
+	if (np->pde)
 		proc_device_tree_update_prop(np->pde, newprop, oldprop);
 #endif /* CONFIG_PROC_DEVICETREE */
 
@@ -1723,6 +1879,7 @@ int of_attach_node(struct device_node *np)
 	of_node_clear_flag(np, OF_DETACHED);
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 
+	of_node_add(np);
 	of_add_proc_dt_entry(np);
 	return 0;
 }
@@ -1795,6 +1952,7 @@ int of_detach_node(struct device_node *np)
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 
 	of_remove_proc_dt_entry(np);
+	of_node_remove(np);
 	return rc;
 }
 #endif /* defined(CONFIG_OF_DYNAMIC) */

commit d484700a36952c6675aa47dec4d7a536929aa922
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Tue Mar 4 12:31:24 2014 +0100

    of: Warn if of_graph_parse_endpoint is called with the root node
    
    If of_graph_parse_endpoint is given a parentless node instead of an
    endpoint node, it is clearly a bug.
    
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Mauro Carvalho Chehab <m.chehab@samsung.com>
    Acked-by: Sylwester Nawrocki <s.nawrocki@samsung.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 715144af3a83..fd4b9c2eaa15 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1996,6 +1996,9 @@ int of_graph_parse_endpoint(const struct device_node *node,
 {
 	struct device_node *port_node = of_get_parent(node);
 
+	WARN_ONCE(!port_node, "%s(): endpoint %s has no parent node\n",
+		  __func__, node->full_name);
+
 	memset(endpoint, 0, sizeof(*endpoint));
 
 	endpoint->local_node = node;

commit f2a575f67695dcba9062acd666ae5aab2380b95c
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Fri Feb 14 11:53:56 2014 +0100

    [media] of: move common endpoint parsing to drivers/of
    
    This patch adds a new struct of_endpoint which is then embedded in struct
    v4l2_of_endpoint and contains the endpoint properties that are not V4L2
    (or even media) specific: the port number, endpoint id, local device tree
    node and remote endpoint phandle. of_graph_parse_endpoint parses those
    properties and is used by v4l2_of_parse_endpoint, which just adds the
    V4L2 MBUS information to the containing v4l2_of_endpoint structure.
    
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Mauro Carvalho Chehab <m.chehab@samsung.com>
    Acked-by: Sylwester Nawrocki <s.nawrocki@samsung.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index a8e47d37cc7f..715144af3a83 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1984,6 +1984,34 @@ struct device_node *of_find_next_cache_node(const struct device_node *np)
 	return NULL;
 }
 
+/**
+ * of_graph_parse_endpoint() - parse common endpoint node properties
+ * @node: pointer to endpoint device_node
+ * @endpoint: pointer to the OF endpoint data structure
+ *
+ * The caller should hold a reference to @node.
+ */
+int of_graph_parse_endpoint(const struct device_node *node,
+			    struct of_endpoint *endpoint)
+{
+	struct device_node *port_node = of_get_parent(node);
+
+	memset(endpoint, 0, sizeof(*endpoint));
+
+	endpoint->local_node = node;
+	/*
+	 * It doesn't matter whether the two calls below succeed.
+	 * If they don't then the default value 0 is used.
+	 */
+	of_property_read_u32(port_node, "reg", &endpoint->port);
+	of_property_read_u32(node, "reg", &endpoint->id);
+
+	of_node_put(port_node);
+
+	return 0;
+}
+EXPORT_SYMBOL(of_graph_parse_endpoint);
+
 /**
  * of_graph_get_next_endpoint() - get next endpoint node
  * @parent: pointer to the parent device node

commit 4329b93b283cce828967c01bc3827fdff51c8d7e
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Wed Feb 26 20:43:42 2014 +0100

    of: Reduce indentation in of_graph_get_next_endpoint
    
    A 'return endpoint;' at the end of the (!prev) case allows to
    reduce the indentation level of the (prev) case.
    
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Mauro Carvalho Chehab <m.chehab@samsung.com>
    Acked-by: Sylwester Nawrocki <s.nawrocki@samsung.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index b5e690bd6e9c..a8e47d37cc7f 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -2026,32 +2026,34 @@ struct device_node *of_graph_get_next_endpoint(const struct device_node *parent,
 			pr_err("%s(): no endpoint nodes specified for %s\n",
 			       __func__, parent->full_name);
 		of_node_put(node);
-	} else {
-		port = of_get_parent(prev);
-		if (WARN_ONCE(!port, "%s(): endpoint %s has no parent node\n",
-			      __func__, prev->full_name))
-			return NULL;
 
-		/* Avoid dropping prev node refcount to 0. */
-		of_node_get(prev);
-		endpoint = of_get_next_child(port, prev);
-		if (endpoint) {
-			of_node_put(port);
-			return endpoint;
-		}
+		return endpoint;
+	}
 
-		/* No more endpoints under this port, try the next one. */
-		do {
-			port = of_get_next_child(parent, port);
-			if (!port)
-				return NULL;
-		} while (of_node_cmp(port->name, "port"));
+	port = of_get_parent(prev);
+	if (WARN_ONCE(!port, "%s(): endpoint %s has no parent node\n",
+		      __func__, prev->full_name))
+		return NULL;
 
-		/* Pick up the first endpoint in this port. */
-		endpoint = of_get_next_child(port, NULL);
+	/* Avoid dropping prev node refcount to 0. */
+	of_node_get(prev);
+	endpoint = of_get_next_child(port, prev);
+	if (endpoint) {
 		of_node_put(port);
+		return endpoint;
 	}
 
+	/* No more endpoints under this port, try the next one. */
+	do {
+		port = of_get_next_child(parent, port);
+		if (!port)
+			return NULL;
+	} while (of_node_cmp(port->name, "port"));
+
+	/* Pick up the first endpoint in this port. */
+	endpoint = of_get_next_child(port, NULL);
+	of_node_put(port);
+
 	return endpoint;
 }
 EXPORT_SYMBOL(of_graph_get_next_endpoint);

commit 6ff60d397b172bd89955433bd9e74be4627d7b9e
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Wed Feb 26 20:41:09 2014 +0100

    of: Warn if of_graph_get_next_endpoint is called with the root node
    
    If of_graph_get_next_endpoint is given a parentless node instead of an
    endpoint node, it is clearly a bug.
    
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Mauro Carvalho Chehab <m.chehab@samsung.com>
    Acked-by: Sylwester Nawrocki <s.nawrocki@samsung.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index b2f223fa47e9..b5e690bd6e9c 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -2028,8 +2028,8 @@ struct device_node *of_graph_get_next_endpoint(const struct device_node *parent,
 		of_node_put(node);
 	} else {
 		port = of_get_parent(prev);
-		if (!port)
-			/* Hm, has someone given us the root node ?... */
+		if (WARN_ONCE(!port, "%s(): endpoint %s has no parent node\n",
+			      __func__, prev->full_name))
 			return NULL;
 
 		/* Avoid dropping prev node refcount to 0. */

commit fd9fdb78a9bf85b94fb2190c82ff280c8f8375cc
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Mon Feb 10 22:01:48 2014 +0100

    [media] of: move graph helpers from drivers/media/v4l2-core to drivers/of
    
    This patch moves the parsing helpers used to parse connected graphs
    in the device tree, like the video interface bindings documented in
    Documentation/devicetree/bindings/media/video-interfaces.txt, from
    drivers/media/v4l2-core/v4l2-of.c into drivers/of/base.c.
    
    This allows to reuse the same parser code from outside the V4L2
    framework, most importantly from display drivers.
    The functions v4l2_of_get_next_endpoint, v4l2_of_get_remote_port,
    and v4l2_of_get_remote_port_parent are moved. They are renamed to
    of_graph_get_next_endpoint, of_graph_get_remote_port, and
    of_graph_get_remote_port_parent, respectively.
    Since there are not that many current users yet, switch all of
    them to the new functions right away.
    
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Mauro Carvalho Chehab <m.chehab@samsung.com>
    Acked-by: Sylwester Nawrocki <s.nawrocki@samsung.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 89e888a78899..b2f223fa47e9 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -21,6 +21,7 @@
 #include <linux/cpu.h>
 #include <linux/module.h>
 #include <linux/of.h>
+#include <linux/of_graph.h>
 #include <linux/spinlock.h>
 #include <linux/slab.h>
 #include <linux/proc_fs.h>
@@ -1982,3 +1983,120 @@ struct device_node *of_find_next_cache_node(const struct device_node *np)
 
 	return NULL;
 }
+
+/**
+ * of_graph_get_next_endpoint() - get next endpoint node
+ * @parent: pointer to the parent device node
+ * @prev: previous endpoint node, or NULL to get first
+ *
+ * Return: An 'endpoint' node pointer with refcount incremented. Refcount
+ * of the passed @prev node is not decremented, the caller have to use
+ * of_node_put() on it when done.
+ */
+struct device_node *of_graph_get_next_endpoint(const struct device_node *parent,
+					struct device_node *prev)
+{
+	struct device_node *endpoint;
+	struct device_node *port = NULL;
+
+	if (!parent)
+		return NULL;
+
+	if (!prev) {
+		struct device_node *node;
+		/*
+		 * It's the first call, we have to find a port subnode
+		 * within this node or within an optional 'ports' node.
+		 */
+		node = of_get_child_by_name(parent, "ports");
+		if (node)
+			parent = node;
+
+		port = of_get_child_by_name(parent, "port");
+
+		if (port) {
+			/* Found a port, get an endpoint. */
+			endpoint = of_get_next_child(port, NULL);
+			of_node_put(port);
+		} else {
+			endpoint = NULL;
+		}
+
+		if (!endpoint)
+			pr_err("%s(): no endpoint nodes specified for %s\n",
+			       __func__, parent->full_name);
+		of_node_put(node);
+	} else {
+		port = of_get_parent(prev);
+		if (!port)
+			/* Hm, has someone given us the root node ?... */
+			return NULL;
+
+		/* Avoid dropping prev node refcount to 0. */
+		of_node_get(prev);
+		endpoint = of_get_next_child(port, prev);
+		if (endpoint) {
+			of_node_put(port);
+			return endpoint;
+		}
+
+		/* No more endpoints under this port, try the next one. */
+		do {
+			port = of_get_next_child(parent, port);
+			if (!port)
+				return NULL;
+		} while (of_node_cmp(port->name, "port"));
+
+		/* Pick up the first endpoint in this port. */
+		endpoint = of_get_next_child(port, NULL);
+		of_node_put(port);
+	}
+
+	return endpoint;
+}
+EXPORT_SYMBOL(of_graph_get_next_endpoint);
+
+/**
+ * of_graph_get_remote_port_parent() - get remote port's parent node
+ * @node: pointer to a local endpoint device_node
+ *
+ * Return: Remote device node associated with remote endpoint node linked
+ *	   to @node. Use of_node_put() on it when done.
+ */
+struct device_node *of_graph_get_remote_port_parent(
+			       const struct device_node *node)
+{
+	struct device_node *np;
+	unsigned int depth;
+
+	/* Get remote endpoint node. */
+	np = of_parse_phandle(node, "remote-endpoint", 0);
+
+	/* Walk 3 levels up only if there is 'ports' node. */
+	for (depth = 3; depth && np; depth--) {
+		np = of_get_next_parent(np);
+		if (depth == 2 && of_node_cmp(np->name, "ports"))
+			break;
+	}
+	return np;
+}
+EXPORT_SYMBOL(of_graph_get_remote_port_parent);
+
+/**
+ * of_graph_get_remote_port() - get remote port node
+ * @node: pointer to a local endpoint device_node
+ *
+ * Return: Remote port node associated with remote endpoint node linked
+ *	   to @node. Use of_node_put() on it when done.
+ */
+struct device_node *of_graph_get_remote_port(const struct device_node *node)
+{
+	struct device_node *np;
+
+	/* Get remote endpoint node. */
+	np = of_parse_phandle(node, "remote-endpoint", 0);
+	if (!np)
+		return NULL;
+	return of_get_next_parent(np);
+}
+EXPORT_SYMBOL(of_graph_get_remote_port);

commit dab2310d9d90eded48625c5382c6a60389bf8ca9
Merge: a3dbeb5b45af 0414855fdc4a
Author: Grant Likely <grant.likely@linaro.org>
Date:   Tue Mar 4 16:44:10 2014 +0800

    Merge tag 'v3.14-rc5' into HEAD
    
    Linux 3.14-rc5

commit a3dbeb5b45af5b6113385db89fce2a8279278e8b
Author: Grant Likely <grant.likely@linaro.org>
Date:   Tue Mar 4 16:07:17 2014 +0800

    Revert "of: fix of_update_property()"
    
    This reverts commit 02ed594e7113644c06ae3a89bc9215d839510efc.
    
    The change is completely broken. It attempt to get the previous item in
    a linked list by grabbing the address of a stack variable. Outright
    wrong.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 239e3da9e728..a63e77694d0f 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1597,7 +1597,7 @@ int of_update_property(struct device_node *np, struct property *newprop)
 {
 	struct property **next, *oldprop;
 	unsigned long flags;
-	int rc = 0;
+	int rc, found = 0;
 
 	rc = of_property_notify(OF_RECONFIG_UPDATE_PROPERTY, np, newprop);
 	if (rc)
@@ -1606,28 +1606,36 @@ int of_update_property(struct device_node *np, struct property *newprop)
 	if (!newprop->name)
 		return -EINVAL;
 
+	oldprop = of_find_property(np, newprop->name, NULL);
+	if (!oldprop)
+		return of_add_property(np, newprop);
+
 	raw_spin_lock_irqsave(&devtree_lock, flags);
-	oldprop = __of_find_property(np, newprop->name, NULL);
-	if (!oldprop) {
-		/* add the node */
-		rc = __of_add_property(np, newprop);
-	} else {
-		/* replace the node */
-		next = &oldprop;
-		newprop->next = oldprop->next;
-		*next = newprop;
-		oldprop->next = np->deadprops;
-		np->deadprops = oldprop;
+	next = &np->properties;
+	while (*next) {
+		if (*next == oldprop) {
+			/* found the node */
+			newprop->next = oldprop->next;
+			*next = newprop;
+			oldprop->next = np->deadprops;
+			np->deadprops = oldprop;
+			found = 1;
+			break;
+		}
+		next = &(*next)->next;
 	}
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 
+	if (!found)
+		return -ENODEV;
+
 #ifdef CONFIG_PROC_DEVICETREE
 	/* try to add to proc as well if it was initialized */
 	if (!rc && np->pde)
 		proc_device_tree_update_prop(np->pde, newprop, oldprop);
 #endif /* CONFIG_PROC_DEVICETREE */
 
-	return rc;
+	return 0;
 }
 
 #if defined(CONFIG_OF_DYNAMIC)

commit 215a14cface21ba205f6edc813be157fdf7899b8
Author: Kevin Hao <haokexin@gmail.com>
Date:   Wed Feb 19 16:15:45 2014 +0800

    of: reimplement the matching method for __of_match_node()
    
    In the current implementation of __of_match_node(), it will compare
    each given match entry against all the node's compatible strings
    with of_device_is_compatible().
    
    To achieve multiple compatible strings per node with ordering from
    specific to generic, this requires given matches to be ordered from
    specific to generic. For most of the drivers this is not true and
    also an alphabetical ordering is more sane there.
    
    Therefore, we define a following priority order for the match, and
    then scan all the entries to find the best match.
      1. specific compatible && type && name
      2. specific compatible && type
      3. specific compatible && name
      4. specific compatible
      5. general compatible && type && name
      6. general compatible && type
      7. general compatible && name
      8. general compatible
      9. type && name
      10. type
      11. name
    
    v5: Fix nested locking bug
    v4: Short-circuit failure cases instead of mucking with score, and
        remove extra __of_device_is_compatible() wrapper stub.
        Move scoring logic directly into __of_device_is_compatible()
    v3: Also need to bail out when there does have a compatible member in match
        entry, but it doesn't match with the device node's compatible.
    v2: Fix the bug such as we get the same score for the following two match
        entries with the empty node 'name2 { };'
            struct of_device_id matches[] = {
                    {.name = "name2", },
                    {.name = "name2", .type = "type1", },
                    {}
            };
    
    Signed-off-by: Kevin Hao <haokexin@gmail.com>
    [grant.likely: added v4 changes]
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Tested-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Tested-by: Stephen Chivers <schivers@csc.com>
    Tested-by: Sachin Kamat <sachin.kamat@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index ba195fbce4c6..89e888a78899 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -342,27 +342,72 @@ struct device_node *of_get_cpu_node(int cpu, unsigned int *thread)
 }
 EXPORT_SYMBOL(of_get_cpu_node);
 
-/** Checks if the given "compat" string matches one of the strings in
- * the device's "compatible" property
+/**
+ * __of_device_is_compatible() - Check if the node matches given constraints
+ * @device: pointer to node
+ * @compat: required compatible string, NULL or "" for any match
+ * @type: required device_type value, NULL or "" for any match
+ * @name: required node name, NULL or "" for any match
+ *
+ * Checks if the given @compat, @type and @name strings match the
+ * properties of the given @device. A constraints can be skipped by
+ * passing NULL or an empty string as the constraint.
+ *
+ * Returns 0 for no match, and a positive integer on match. The return
+ * value is a relative score with larger values indicating better
+ * matches. The score is weighted for the most specific compatible value
+ * to get the highest score. Matching type is next, followed by matching
+ * name. Practically speaking, this results in the following priority
+ * order for matches:
+ *
+ * 1. specific compatible && type && name
+ * 2. specific compatible && type
+ * 3. specific compatible && name
+ * 4. specific compatible
+ * 5. general compatible && type && name
+ * 6. general compatible && type
+ * 7. general compatible && name
+ * 8. general compatible
+ * 9. type && name
+ * 10. type
+ * 11. name
  */
 static int __of_device_is_compatible(const struct device_node *device,
-				     const char *compat)
-{
-	const char* cp;
-	int cplen, l;
+				     const char *compat, const char *type, const char *name)
+{
+	struct property *prop;
+	const char *cp;
+	int index = 0, score = 0;
+
+	/* Compatible match has highest priority */
+	if (compat && compat[0]) {
+		prop = __of_find_property(device, "compatible", NULL);
+		for (cp = of_prop_next_string(prop, NULL); cp;
+		     cp = of_prop_next_string(prop, cp), index++) {
+			if (of_compat_cmp(cp, compat, strlen(compat)) == 0) {
+				score = INT_MAX/2 - (index << 2);
+				break;
+			}
+		}
+		if (!score)
+			return 0;
+	}
 
-	cp = __of_get_property(device, "compatible", &cplen);
-	if (cp == NULL)
-		return 0;
-	while (cplen > 0) {
-		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
-			return 1;
-		l = strlen(cp) + 1;
-		cp += l;
-		cplen -= l;
+	/* Matching type is better than matching name */
+	if (type && type[0]) {
+		if (!device->type || of_node_cmp(type, device->type))
+			return 0;
+		score += 2;
 	}
 
-	return 0;
+	/* Matching name is a bit better than not */
+	if (name && name[0]) {
+		if (!device->name || of_node_cmp(name, device->name))
+			return 0;
+		score++;
+	}
+
+	return score;
 }
 
 /** Checks if the given "compat" string matches one of the strings in
@@ -375,7 +420,7 @@ int of_device_is_compatible(const struct device_node *device,
 	int res;
 
 	raw_spin_lock_irqsave(&devtree_lock, flags);
-	res = __of_device_is_compatible(device, compat);
+	res = __of_device_is_compatible(device, compat, NULL, NULL);
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 	return res;
 }
@@ -681,10 +726,7 @@ struct device_node *of_find_compatible_node(struct device_node *from,
 	raw_spin_lock_irqsave(&devtree_lock, flags);
 	np = from ? from->allnext : of_allnodes;
 	for (; np; np = np->allnext) {
-		if (type
-		    && !(np->type && (of_node_cmp(np->type, type) == 0)))
-			continue;
-		if (__of_device_is_compatible(np, compatible) &&
+		if (__of_device_is_compatible(np, compatible, type, NULL) &&
 		    of_node_get(np))
 			break;
 	}
@@ -734,25 +776,22 @@ static
 const struct of_device_id *__of_match_node(const struct of_device_id *matches,
 					   const struct device_node *node)
 {
+	const struct of_device_id *best_match = NULL;
+	int score, best_score = 0;
+
 	if (!matches)
 		return NULL;
 
-	while (matches->name[0] || matches->type[0] || matches->compatible[0]) {
-		int match = 1;
-		if (matches->name[0])
-			match &= node->name
-				&& !strcmp(matches->name, node->name);
-		if (matches->type[0])
-			match &= node->type
-				&& !strcmp(matches->type, node->type);
-		if (matches->compatible[0])
-			match &= __of_device_is_compatible(node,
-							   matches->compatible);
-		if (match)
-			return matches;
-		matches++;
+	for (; matches->name[0] || matches->type[0] || matches->compatible[0]; matches++) {
+		score = __of_device_is_compatible(node, matches->compatible,
+						  matches->type, matches->name);
+		if (score > best_score) {
+			best_match = matches;
+			best_score = score;
+		}
 	}
-	return NULL;
+
+	return best_match;
 }
 
 /**

commit 71c5498eed06b5ac4325a525ed83aeed3e9a250a
Author: Kevin Hao <haokexin@gmail.com>
Date:   Tue Feb 18 15:57:29 2014 +0800

    Revert "of: search the best compatible match first in __of_match_node()"
    
    This reverts commit 06b29e76a74b2373e6f8b5a7938b3630b9ae98b2.
    As pointed out by Grant Likely, we should also take the type and name
    into account when searching the best compatible match. That means the
    match with compatible, type and name should be better than the match
    just with the same compatible string. So revert this and we will
    implement another method to find the best match entry.
    
    Signed-off-by: Kevin Hao <haokexin@gmail.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 10b51106c854..ba195fbce4c6 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -730,49 +730,13 @@ struct device_node *of_find_node_with_property(struct device_node *from,
 }
 EXPORT_SYMBOL(of_find_node_with_property);
 
-static const struct of_device_id *
-of_match_compatible(const struct of_device_id *matches,
-			const struct device_node *node)
-{
-	const char *cp;
-	int cplen, l;
-	const struct of_device_id *m;
-
-	cp = __of_get_property(node, "compatible", &cplen);
-	while (cp && (cplen > 0)) {
-		m = matches;
-		while (m->name[0] || m->type[0] || m->compatible[0]) {
-			/* Only match for the entries without type and name */
-			if (m->name[0] || m->type[0] ||
-				of_compat_cmp(m->compatible, cp,
-					 strlen(m->compatible)))
-				m++;
-			else
-				return m;
-		}
-
-		/* Get node's next compatible string */
-		l = strlen(cp) + 1;
-		cp += l;
-		cplen -= l;
-	}
-
-	return NULL;
-}
-
 static
 const struct of_device_id *__of_match_node(const struct of_device_id *matches,
 					   const struct device_node *node)
 {
-	const struct of_device_id *m;
-
 	if (!matches)
 		return NULL;
 
-	m = of_match_compatible(matches, node);
-	if (m)
-		return m;
-
 	while (matches->name[0] || matches->type[0] || matches->compatible[0]) {
 		int match = 1;
 		if (matches->name[0])
@@ -796,12 +760,7 @@ const struct of_device_id *__of_match_node(const struct of_device_id *matches,
  *	@matches:	array of of device match structures to search in
  *	@node:		the of device structure to match against
  *
- *	Low level utility function used by device matching. We have two ways
- *	of matching:
- *	- Try to find the best compatible match by comparing each compatible
- *	  string of device node with all the given matches respectively.
- *	- If the above method failed, then try to match the compatible by using
- *	  __of_device_is_compatible() besides the match in type and name.
+ *	Low level utility function used by device matching.
  */
 const struct of_device_id *of_match_node(const struct of_device_id *matches,
 					 const struct device_node *node)

commit 06b29e76a74b2373e6f8b5a7938b3630b9ae98b2
Author: Kevin Hao <haokexin@gmail.com>
Date:   Fri Feb 14 13:22:46 2014 +0800

    of: search the best compatible match first in __of_match_node()
    
    Currently, of_match_node compares each given match against all node's
    compatible strings with of_device_is_compatible.
    
    To achieve multiple compatible strings per node with ordering from
    specific to generic, this requires given matches to be ordered from
    specific to generic. For most of the drivers this is not true and also
    an alphabetical ordering is more sane there.
    
    Therefore, this patch introduces a function to match each of the node's
    compatible strings against all given compatible matches without type and
    name first, before checking the next compatible string. This implies
    that node's compatibles are ordered from specific to generic while
    given matches can be in any order. If we fail to find such a match
    entry, then fall-back to the old method in order to keep compatibility.
    
    Cc: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Signed-off-by: Kevin Hao <haokexin@gmail.com>
    Tested-by: Stephen Chivers <schivers@csc.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index ba195fbce4c6..10b51106c854 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -730,13 +730,49 @@ struct device_node *of_find_node_with_property(struct device_node *from,
 }
 EXPORT_SYMBOL(of_find_node_with_property);
 
+static const struct of_device_id *
+of_match_compatible(const struct of_device_id *matches,
+			const struct device_node *node)
+{
+	const char *cp;
+	int cplen, l;
+	const struct of_device_id *m;
+
+	cp = __of_get_property(node, "compatible", &cplen);
+	while (cp && (cplen > 0)) {
+		m = matches;
+		while (m->name[0] || m->type[0] || m->compatible[0]) {
+			/* Only match for the entries without type and name */
+			if (m->name[0] || m->type[0] ||
+				of_compat_cmp(m->compatible, cp,
+					 strlen(m->compatible)))
+				m++;
+			else
+				return m;
+		}
+
+		/* Get node's next compatible string */
+		l = strlen(cp) + 1;
+		cp += l;
+		cplen -= l;
+	}
+
+	return NULL;
+}
+
 static
 const struct of_device_id *__of_match_node(const struct of_device_id *matches,
 					   const struct device_node *node)
 {
+	const struct of_device_id *m;
+
 	if (!matches)
 		return NULL;
 
+	m = of_match_compatible(matches, node);
+	if (m)
+		return m;
+
 	while (matches->name[0] || matches->type[0] || matches->compatible[0]) {
 		int match = 1;
 		if (matches->name[0])
@@ -760,7 +796,12 @@ const struct of_device_id *__of_match_node(const struct of_device_id *matches,
  *	@matches:	array of of device match structures to search in
  *	@node:		the of device structure to match against
  *
- *	Low level utility function used by device matching.
+ *	Low level utility function used by device matching. We have two ways
+ *	of matching:
+ *	- Try to find the best compatible match by comparing each compatible
+ *	  string of device node with all the given matches respectively.
+ *	- If the above method failed, then try to match the compatible by using
+ *	  __of_device_is_compatible() besides the match in type and name.
  */
 const struct of_device_id *of_match_node(const struct of_device_id *matches,
 					 const struct device_node *node)

commit 4e8ca6ee3a5d0e0f4c0cb32e43dc3d69e79e5a76
Author: Kevin Hao <haokexin@gmail.com>
Date:   Fri Feb 14 13:22:45 2014 +0800

    Revert "OF: base: match each node compatible against all given matches first"
    
    This reverts commit 105353145eafb3ea919f5cdeb652a9d8f270228e.
    Stephen Chivers reported this is broken as we will get a match
    entry '.type = "serial"' instead of the '.compatible = "ns16550"'
    in the following scenario:
            serial0: serial@4500 {
                    compatible = "fsl,ns16550", "ns16550";
            }
    
            struct of_device_id of_platform_serial_table[] = {
                    { .compatible = "ns8250",   .data = (void *)PORT_8250, },
                    { .compatible = "ns16450",  .data = (void *)PORT_16450, },
                    { .compatible = "ns16550a", .data = (void *)PORT_16550A, },
                    { .compatible = "ns16550",  .data = (void *)PORT_16550, },
                    { .compatible = "ns16750",  .data = (void *)PORT_16750, },
                    { .compatible = "ns16850",  .data = (void *)PORT_16850, },
                    ...
                    { .type = "serial",         .data = (void *)PORT_UNKNOWN, },
                    { /* end of list */ },
            };
    
    So just revert this patch, we will use another implementation to find
    the best compatible match in a follow-on patch.
    
    Reported-by: Stephen N Chivers <schivers@csc.com.au>
    Cc: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Signed-off-by: Kevin Hao <haokexin@gmail.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index ff85450d5683..ba195fbce4c6 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -734,42 +734,24 @@ static
 const struct of_device_id *__of_match_node(const struct of_device_id *matches,
 					   const struct device_node *node)
 {
-	const char *cp;
-	int cplen, l;
-
 	if (!matches)
 		return NULL;
 
-	cp = __of_get_property(node, "compatible", &cplen);
-	do {
-		const struct of_device_id *m = matches;
-
-		/* Check against matches with current compatible string */
-		while (m->name[0] || m->type[0] || m->compatible[0]) {
-			int match = 1;
-			if (m->name[0])
-				match &= node->name
-					&& !strcmp(m->name, node->name);
-			if (m->type[0])
-				match &= node->type
-					&& !strcmp(m->type, node->type);
-			if (m->compatible[0])
-				match &= cp
-					&& !of_compat_cmp(m->compatible, cp,
-							strlen(m->compatible));
-			if (match)
-				return m;
-			m++;
-		}
-
-		/* Get node's next compatible string */ 
-		if (cp) {
-			l = strlen(cp) + 1;
-			cp += l;
-			cplen -= l;
-		}
-	} while (cp && (cplen > 0));
-
+	while (matches->name[0] || matches->type[0] || matches->compatible[0]) {
+		int match = 1;
+		if (matches->name[0])
+			match &= node->name
+				&& !strcmp(matches->name, node->name);
+		if (matches->type[0])
+			match &= node->type
+				&& !strcmp(matches->type, node->type);
+		if (matches->compatible[0])
+			match &= __of_device_is_compatible(node,
+							   matches->compatible);
+		if (match)
+			return matches;
+		matches++;
+	}
 	return NULL;
 }
 
@@ -778,10 +760,7 @@ const struct of_device_id *__of_match_node(const struct of_device_id *matches,
  *	@matches:	array of of device match structures to search in
  *	@node:		the of device structure to match against
  *
- *	Low level utility function used by device matching. Matching order
- *	is to compare each of the node's compatibles with all given matches
- *	first. This implies node's compatible is sorted from specific to
- *	generic while matches can be in any order.
+ *	Low level utility function used by device matching.
  */
 const struct of_device_id *of_match_node(const struct of_device_id *matches,
 					 const struct device_node *node)

commit ad54a0cfbeb4bd4033d09017557ccbc423f9d5ff
Author: Heiko Stuebner <heiko.stuebner@bqreaders.com>
Date:   Wed Feb 12 01:00:34 2014 +0100

    of: add functions to count number of elements in a property
    
    The need to know the number of array elements in a property is
    a common pattern. To prevent duplication of open-coded implementations
    add a helper static function that also centralises strict sanity
    checking and DTB format details, as well as a set of wrapper functions
    for u8, u16, u32 and u64.
    
    Suggested-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Heiko Stuebner <heiko.stuebner@bqreaders.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index ff85450d5683..8a2a55c65e5d 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -885,6 +885,38 @@ struct device_node *of_find_node_by_phandle(phandle handle)
 }
 EXPORT_SYMBOL(of_find_node_by_phandle);
 
+/**
+ * of_property_count_elems_of_size - Count the number of elements in a property
+ *
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ * @elem_size:	size of the individual element
+ *
+ * Search for a property in a device node and count the number of elements of
+ * size elem_size in it. Returns number of elements on sucess, -EINVAL if the
+ * property does not exist or its length does not match a multiple of elem_size
+ * and -ENODATA if the property does not have a value.
+ */
+int of_property_count_elems_of_size(const struct device_node *np,
+				const char *propname, int elem_size)
+{
+	struct property *prop = of_find_property(np, propname, NULL);
+
+	if (!prop)
+		return -EINVAL;
+	if (!prop->value)
+		return -ENODATA;
+
+	if (prop->length % elem_size != 0) {
+		pr_err("size of %s in node %s is not a multiple of %d\n",
+		       propname, np->full_name, elem_size);
+		return -EINVAL;
+	}
+
+	return prop->length / elem_size;
+}
+EXPORT_SYMBOL_GPL(of_property_count_elems_of_size);
+
 /**
  * of_find_property_value_of_size
  *

commit 02ed594e7113644c06ae3a89bc9215d839510efc
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Wed Jan 22 13:57:40 2014 +0800

    of: fix of_update_property()
    
    The of_update_property() is intented to update a property in a node
    and if the property does not exist, will add it.
    
    The second search of the property is possibly won't be found, that
    maybe removed by other thread just before the second search begain.
    
    Using the __of_find_property() and __of_add_property() instead and
    move them into lock operations.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Cc: Pantelis Antoniou <panto@antoniou-consulting.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 6ad3dc976b18..239e3da9e728 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1597,7 +1597,7 @@ int of_update_property(struct device_node *np, struct property *newprop)
 {
 	struct property **next, *oldprop;
 	unsigned long flags;
-	int rc, found = 0;
+	int rc = 0;
 
 	rc = of_property_notify(OF_RECONFIG_UPDATE_PROPERTY, np, newprop);
 	if (rc)
@@ -1606,36 +1606,28 @@ int of_update_property(struct device_node *np, struct property *newprop)
 	if (!newprop->name)
 		return -EINVAL;
 
-	oldprop = of_find_property(np, newprop->name, NULL);
-	if (!oldprop)
-		return of_add_property(np, newprop);
-
 	raw_spin_lock_irqsave(&devtree_lock, flags);
-	next = &np->properties;
-	while (*next) {
-		if (*next == oldprop) {
-			/* found the node */
-			newprop->next = oldprop->next;
-			*next = newprop;
-			oldprop->next = np->deadprops;
-			np->deadprops = oldprop;
-			found = 1;
-			break;
-		}
-		next = &(*next)->next;
+	oldprop = __of_find_property(np, newprop->name, NULL);
+	if (!oldprop) {
+		/* add the node */
+		rc = __of_add_property(np, newprop);
+	} else {
+		/* replace the node */
+		next = &oldprop;
+		newprop->next = oldprop->next;
+		*next = newprop;
+		oldprop->next = np->deadprops;
+		np->deadprops = oldprop;
 	}
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 
-	if (!found)
-		return -ENODEV;
-
 #ifdef CONFIG_PROC_DEVICETREE
 	/* try to add to proc as well if it was initialized */
-	if (np->pde)
+	if (!rc && np->pde)
 		proc_device_tree_update_prop(np->pde, newprop, oldprop);
 #endif /* CONFIG_PROC_DEVICETREE */
 
-	return 0;
+	return rc;
 }
 
 #if defined(CONFIG_OF_DYNAMIC)

commit 62664f67775fad840cf6f68d6b5f428817bef6c5
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Wed Jan 22 13:57:39 2014 +0800

    of: add __of_add_property() without lock operations
    
    There two places will use the same code for adding one new property to
    the DT node. Adding __of_add_property() and prepare for fixing
    of_update_property()'s bug.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 87038d80b473..6ad3dc976b18 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1492,12 +1492,32 @@ static int of_property_notify(int action, struct device_node *np,
 }
 #endif
 
+/**
+ * __of_add_property - Add a property to a node without lock operations
+ */
+static int __of_add_property(struct device_node *np, struct property *prop)
+{
+	struct property **next;
+
+	prop->next = NULL;
+	next = &np->properties;
+	while (*next) {
+		if (strcmp(prop->name, (*next)->name) == 0)
+			/* duplicate ! don't insert it */
+			return -EEXIST;
+
+		next = &(*next)->next;
+	}
+	*next = prop;
+
+	return 0;
+}
+
 /**
  * of_add_property - Add a property to a node
  */
 int of_add_property(struct device_node *np, struct property *prop)
 {
-	struct property **next;
 	unsigned long flags;
 	int rc;
 
@@ -1505,27 +1525,17 @@ int of_add_property(struct device_node *np, struct property *prop)
 	if (rc)
 		return rc;
 
-	prop->next = NULL;
 	raw_spin_lock_irqsave(&devtree_lock, flags);
-	next = &np->properties;
-	while (*next) {
-		if (strcmp(prop->name, (*next)->name) == 0) {
-			/* duplicate ! don't insert it */
-			raw_spin_unlock_irqrestore(&devtree_lock, flags);
-			return -1;
-		}
-		next = &(*next)->next;
-	}
-	*next = prop;
+	rc = __of_add_property(np, prop);
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 
 #ifdef CONFIG_PROC_DEVICETREE
 	/* try to add to proc as well if it was initialized */
-	if (np->pde)
+	if (!rc && np->pde)
 		proc_device_tree_add_prop(np->pde, prop);
 #endif /* CONFIG_PROC_DEVICETREE */
 
-	return 0;
+	return rc;
 }
 
 /**

commit e3963fd60a83967573f6330c9db134bd581da746
Author: Pantelis Antoniou <panto@antoniou-consulting.com>
Date:   Fri Nov 8 17:03:57 2013 +0200

    of: Clear detach flag on attach
    
    When attaching a node always clear the detach flag. Without this change
    the sequence detach, attach fails.
    
    Signed-off-by: Pantelis Antoniou <panto@antoniou-consulting.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index ff85450d5683..87038d80b473 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1692,6 +1692,7 @@ int of_attach_node(struct device_node *np)
 	np->allnext = of_allnodes;
 	np->parent->child = np;
 	of_allnodes = np;
+	of_node_clear_flag(np, OF_DETACHED);
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 
 	of_add_proc_dt_entry(np);

commit 619d144013cb30a19d1dfa8294fbe29fcc2c2363
Merge: 9b9900aa60e2 2a9330010bea
Author: Rob Herring <robh@kernel.org>
Date:   Thu Jan 23 08:23:04 2014 -0600

    Merge remote-tracking branch 'grant/devicetree/next' into for-3.14

commit 42ccd781bb206804501ff490fd771bb940ca9969
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Mon Jan 13 11:07:28 2014 +0800

    of: Fix __of_device_is_available check
    
    From IEEE 1275, there defined a standard 'status' property indicating the
    operational status of one device. The 'status' property has four possible
    values: 'okay/ok', 'disabled', 'fail' and 'fail-xxx'.
    
    If it is absent, that means the status of the device is unknown or okay.
    
    The __of_device_is_available checks the state of the 'status' property of
    a device. If the property is absent or set to 'okay/ok', it returns 1.
    Otherwise it returns 0.
    
    While in __of_device_is_available:
     >      status = of_get_property(device, "status", &statlen);
     >      if (status == NULL)
     >              return 1;
    The status value returned from 'of_get_property()' will be NULL in two cases:
    Firstly: the 'device' value (device node) is NULL.
    Secondly: the 'status' property is actaully not exist.
    
    If the device node is NULL, the __of_device_is_available will return true,
    that will mean the absent state of the 'status' property.
    
    So this add the device node check before checking the 'status' property's
    state, and if the device node is not exist, 0 will be returned.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index f807d0edabf3..ba195fbce4c6 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -415,6 +415,9 @@ static int __of_device_is_available(const struct device_node *device)
 	const char *status;
 	int statlen;
 
+	if (!device)
+		return 0;
+
 	status = __of_get_property(device, "status", &statlen);
 	if (status == NULL)
 		return 1;

commit 105353145eafb3ea919f5cdeb652a9d8f270228e
Author: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
Date:   Tue Dec 3 14:52:00 2013 +0100

    OF: base: match each node compatible against all given matches first
    
    Currently, of_match_node compares each given match against all node's
    compatible strings with of_device_is_compatible.
    
    To achieve multiple compatible strings per node with ordering from
    specific to generic, this requires given matches to be ordered from
    specific to generic. For most of the drivers this is not true and also
    an alphabetical ordering is more sane there.
    
    Therefore, this patch modifies of_match_node to match each of the node's
    compatible strings against all given matches first, before checking the
    next compatible string. This implies that node's compatibles are ordered
    from specific to generic while given matches can be in any order.
    
    Signed-off-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Tested-by: Meelis Roos <mroos@linux.ee>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index f807d0edabf3..8d007d8b8c78 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -731,24 +731,42 @@ static
 const struct of_device_id *__of_match_node(const struct of_device_id *matches,
 					   const struct device_node *node)
 {
+	const char *cp;
+	int cplen, l;
+
 	if (!matches)
 		return NULL;
 
-	while (matches->name[0] || matches->type[0] || matches->compatible[0]) {
-		int match = 1;
-		if (matches->name[0])
-			match &= node->name
-				&& !strcmp(matches->name, node->name);
-		if (matches->type[0])
-			match &= node->type
-				&& !strcmp(matches->type, node->type);
-		if (matches->compatible[0])
-			match &= __of_device_is_compatible(node,
-							   matches->compatible);
-		if (match)
-			return matches;
-		matches++;
-	}
+	cp = __of_get_property(node, "compatible", &cplen);
+	do {
+		const struct of_device_id *m = matches;
+
+		/* Check against matches with current compatible string */
+		while (m->name[0] || m->type[0] || m->compatible[0]) {
+			int match = 1;
+			if (m->name[0])
+				match &= node->name
+					&& !strcmp(m->name, node->name);
+			if (m->type[0])
+				match &= node->type
+					&& !strcmp(m->type, node->type);
+			if (m->compatible[0])
+				match &= cp
+					&& !of_compat_cmp(m->compatible, cp,
+							strlen(m->compatible));
+			if (match)
+				return m;
+			m++;
+		}
+
+		/* Get node's next compatible string */ 
+		if (cp) {
+			l = strlen(cp) + 1;
+			cp += l;
+			cplen -= l;
+		}
+	} while (cp && (cplen > 0));
+
 	return NULL;
 }
 
@@ -757,7 +775,10 @@ const struct of_device_id *__of_match_node(const struct of_device_id *matches,
  *	@matches:	array of of device match structures to search in
  *	@node:		the of device structure to match against
  *
- *	Low level utility function used by device matching.
+ *	Low level utility function used by device matching. Matching order
+ *	is to compare each of the node's compatibles with all given matches
+ *	first. This implies node's compatible is sorted from specific to
+ *	generic while matches can be in any order.
  */
 const struct of_device_id *of_match_node(const struct of_device_id *matches,
 					 const struct device_node *node)

commit 10d0c9705e80bbd3d587c5fad24599aabaca6688
Merge: 85b656cf1560 c11eede69b6a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 12 16:52:17 2013 +0900

    Merge tag 'devicetree-for-3.13' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull devicetree updates from Rob Herring:
     "DeviceTree updates for 3.13.  This is a bit larger pull request than
      usual for this cycle with lots of clean-up.
    
       - Cross arch clean-up and consolidation of early DT scanning code.
       - Clean-up and removal of arch prom.h headers.  Makes arch specific
         prom.h optional on all but Sparc.
       - Addition of interrupts-extended property for devices connected to
         multiple interrupt controllers.
       - Refactoring of DT interrupt parsing code in preparation for
         deferred probe of interrupts.
       - ARM cpu and cpu topology bindings documentation.
       - Various DT vendor binding documentation updates"
    
    * tag 'devicetree-for-3.13' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (82 commits)
      powerpc: add missing explicit OF includes for ppc
      dt/irq: add empty of_irq_count for !OF_IRQ
      dt: disable self-tests for !OF_IRQ
      of: irq: Fix interrupt-map entry matching
      MIPS: Netlogic: replace early_init_devtree() call
      of: Add Panasonic Corporation vendor prefix
      of: Add Chunghwa Picture Tubes Ltd. vendor prefix
      of: Add AU Optronics Corporation vendor prefix
      of/irq: Fix potential buffer overflow
      of/irq: Fix bug in interrupt parsing refactor.
      of: set dma_mask to point to coherent_dma_mask
      of: add vendor prefix for PHYTEC Messtechnik GmbH
      DT: sort vendor-prefixes.txt
      of: Add vendor prefix for Cadence
      of: Add empty for_each_available_child_of_node() macro definition
      arm/versatile: Fix versatile irq specifications.
      of/irq: create interrupts-extended property
      microblaze/pci: Drop PowerPC-ism from irq parsing
      of/irq: Create of_irq_parse_and_map_pci() to consolidate arch code.
      of/irq: Use irq_of_parse_and_map()
      ...

commit 66a173b926891023e34e78cb32f4681d19777e01
Merge: 11db81a59d0b 0c4888ef1d8a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 12 14:34:19 2013 +0900

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc
    
    Pull powerpc updates from Benjamin Herrenschmidt:
     "The bulk of this is LE updates.  One should now be able to build an LE
      kernel and even run some things in it.
    
      I'm still sitting on a handful of patches to enable the new ABI that I
      *might* still send this merge window around, but due to the
      incertainty (they are pretty fresh) I want to keep them separate.
    
      Other notable changes are some infrastructure bits to better handle
      PCI pass-through under KVM, some bits and pieces added to the new
      PowerNV platform support such as access to the CPU SCOM bus via sysfs,
      and support for EEH error handling on PHB3 (Power8 PCIe).
    
      We also grew arch_get_random_long() for both pseries and powernv when
      running on P7+ and P8, exploiting the HW rng.
    
      And finally various embedded updates from freescale"
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc: (154 commits)
      powerpc: Fix fatal SLB miss when restoring PPR
      powerpc/powernv: Reserve the correct PE number
      powerpc/powernv: Add PE to its own PELTV
      powerpc/powernv: Add support for indirect XSCOM via debugfs
      powerpc/scom: Improve debugfs interface
      powerpc/scom: Enable 64-bit addresses
      powerpc/boot: Properly handle the base "of" boot wrapper
      powerpc/bpf: Support MOD operation
      powerpc/bpf: Fix DIVWU instruction opcode
      of: Move definition of of_find_next_cache_node into common code.
      powerpc: Remove big endianness assumption in of_find_next_cache_node
      powerpc/tm: Remove interrupt disable in __switch_to()
      powerpc: word-at-a-time optimization for 64-bit Little Endian
      powerpc/bpf: BPF JIT compiler for 64-bit Little Endian
      powerpc: Only save/restore SDR1 if in hypervisor mode
      powerpc/pmu: Fix ADB_PMU_LED_IDE dependencies
      powerpc/nvram: Fix endian issue when using the partition length
      powerpc/nvram: Fix endian issue when reading the NVRAM size
      powerpc/nvram: Scan partitions only once
      powerpc/mpc512x: remove unnecessary #if
      ...

commit b5480950c6cbb7b07ab1c1a5af0dc661a1cb6f24
Merge: e363bbac316f 355e62f5ad12
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Thu Nov 7 10:34:46 2013 -0600

    Merge remote-tracking branch 'grant/devicetree/next' into for-next

commit a3e31b4588443f37d82195096c6b30dff1c152c2
Author: Sudeep KarkadaNagesha <sudeep.karkadanagesha@arm.com>
Date:   Wed Sep 18 11:53:05 2013 +0100

    of: Move definition of of_find_next_cache_node into common code.
    
    Since the definition of_find_next_cache_node is architecture independent,
    the existing definition in powerpc can be moved to driver/of/base.c
    
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Signed-off-by: Sudeep KarkadaNagesha <sudeep.karkadanagesha@arm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 865d3f66c86b..b2cee3db5ceb 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1884,3 +1884,34 @@ int of_device_is_stdout_path(struct device_node *dn)
 	return of_stdout == dn;
 }
 EXPORT_SYMBOL_GPL(of_device_is_stdout_path);
+
+/**
+ *	of_find_next_cache_node - Find a node's subsidiary cache
+ *	@np:	node of type "cpu" or "cache"
+ *
+ *	Returns a node pointer with refcount incremented, use
+ *	of_node_put() on it when done.  Caller should hold a reference
+ *	to np.
+ */
+struct device_node *of_find_next_cache_node(const struct device_node *np)
+{
+	struct device_node *child;
+	const phandle *handle;
+
+	handle = of_get_property(np, "l2-cache", NULL);
+	if (!handle)
+		handle = of_get_property(np, "next-level-cache", NULL);
+
+	if (handle)
+		return of_find_node_by_phandle(be32_to_cpup(handle));
+
+	/* OF on pmac has nodes instead of properties named "l2-cache"
+	 * beneath CPU nodes.
+	 */
+	if (!strcmp(np->type, "cpu"))
+		for_each_child_of_node(np, child)
+			if (!strcmp(child->type, "cache"))
+				return child;
+
+	return NULL;
+}

commit 624cfca534f9b1ffb1326617b4e973a3d5ecff4a
Author: Grant Likely <grant.likely@linaro.org>
Date:   Fri Oct 11 22:05:10 2013 +0100

    of: Add helper for printing an of_phandle_args structure
    
    It is sometimes useful for debug to get the contents of an
    of_phandle_args structure out into the kernel log.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 3ae106d89791..021db96245e7 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1185,6 +1185,15 @@ int of_property_count_strings(struct device_node *np, const char *propname)
 }
 EXPORT_SYMBOL_GPL(of_property_count_strings);
 
+void of_print_phandle_args(const char *msg, const struct of_phandle_args *args)
+{
+	int i;
+	printk("%s %s", msg, of_node_full_name(args->np));
+	for (i = 0; i < args->args_count; i++)
+		printk(i ? ",%08x" : ":%08x", args->args[i]);
+	printk("\n");
+}
+
 static int __of_parse_phandle_with_args(const struct device_node *np,
 					const char *list_name,
 					const char *cells_name,

commit f3cea45a77c8ebdb7efad100e576eb6cb401bf25
Author: Grant Likely <grant.likely@linaro.org>
Date:   Fri Oct 4 17:24:26 2013 +0100

    of: Fix iteration bug over CPU reg properties
    
    The size of each hwid in a cpu nodes 'reg' property is defined by the
    parents #address-cells property in the normal way. The cpu parsing code
    has a bug where it will overrun the end of the property if
    address-cells is greater than one. This commit fixes the problem by
    adjusting the array size by the number of address cells. It also makes
    sure address-cells isn't zero for that would cause an infinite loop.
    
    v2: bail if #address-cells is zero instead of forcing to
        OF_ROOT_NODE_ADDR_CELLS_DEFAULT. Forcing it will cause the reg
        property to be parsed incorrectly.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index e4c99453adf1..3ae106d89791 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -265,9 +265,9 @@ static bool __of_find_n_match_cpu_property(struct device_node *cpun,
 
 	ac = of_n_addr_cells(cpun);
 	cell = of_get_property(cpun, prop_name, &prop_len);
-	if (!cell)
+	if (!cell || !ac)
 		return false;
-	prop_len /= sizeof(*cell);
+	prop_len /= sizeof(*cell) * ac;
 	for (tid = 0; tid < prop_len; tid++) {
 		hwid = of_read_number(cell, ac);
 		if (arch_match_cpu_phys_id(cpu, hwid)) {

commit d1cb9d1af0bc11b7450a6032f43935c746609418
Author: David Miller <davem@davemloft.net>
Date:   Thu Oct 3 17:24:51 2013 -0400

    of: Make cpu node handling more portable.
    
    Use for_each_node_by_type() to iterate all cpu nodes in the
    system.
    
    Provide and overridable function arch_find_n_match_cpu_physical_id,
    which sees if the given device node matches 'cpu' and if so sets
    '*thread' when non-NULL to the cpu thread number within the core.
    
    The default implementation behaves the same as the existing code.
    
    Add a sparc64 implementation.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Tested-by: Sudeep KarkadaNagesha <Sudeep.KarkadaNagesha@arm.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 7d4c70f859e3..e4c99453adf1 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -280,6 +280,31 @@ static bool __of_find_n_match_cpu_property(struct device_node *cpun,
 	return false;
 }
 
+/*
+ * arch_find_n_match_cpu_physical_id - See if the given device node is
+ * for the cpu corresponding to logical cpu 'cpu'.  Return true if so,
+ * else false.  If 'thread' is non-NULL, the local thread number within the
+ * core is returned in it.
+ */
+bool __weak arch_find_n_match_cpu_physical_id(struct device_node *cpun,
+					      int cpu, unsigned int *thread)
+{
+	/* Check for non-standard "ibm,ppc-interrupt-server#s" property
+	 * for thread ids on PowerPC. If it doesn't exist fallback to
+	 * standard "reg" property.
+	 */
+	if (IS_ENABLED(CONFIG_PPC) &&
+	    __of_find_n_match_cpu_property(cpun,
+					   "ibm,ppc-interrupt-server#s",
+					   cpu, thread))
+		return true;
+
+	if (__of_find_n_match_cpu_property(cpun, "reg", cpu, thread))
+		return true;
+
+	return false;
+}
+
 /**
  * of_get_cpu_node - Get device node associated with the given logical CPU
  *
@@ -300,24 +325,10 @@ static bool __of_find_n_match_cpu_property(struct device_node *cpun,
  */
 struct device_node *of_get_cpu_node(int cpu, unsigned int *thread)
 {
-	struct device_node *cpun, *cpus;
-
-	cpus = of_find_node_by_path("/cpus");
-	if (!cpus)
-		return NULL;
+	struct device_node *cpun;
 
-	for_each_child_of_node(cpus, cpun) {
-		if (of_node_cmp(cpun->type, "cpu"))
-			continue;
-		/* Check for non-standard "ibm,ppc-interrupt-server#s" property
-		 * for thread ids on PowerPC. If it doesn't exist fallback to
-		 * standard "reg" property.
-		 */
-		if (IS_ENABLED(CONFIG_PPC) &&
-			__of_find_n_match_cpu_property(cpun,
-				"ibm,ppc-interrupt-server#s", cpu, thread))
-			return cpun;
-		if (__of_find_n_match_cpu_property(cpun, "reg", cpu, thread))
+	for_each_node_by_type(cpun, "cpu") {
+		if (arch_find_n_match_cpu_physical_id(cpun, cpu, thread))
 			return cpun;
 	}
 	return NULL;

commit 444c91e5720cb5b825356e32c67c2c5184d1c09a
Author: Grant Likely <grant.likely@linaro.org>
Date:   Thu Oct 3 21:04:31 2013 +0100

    of: fix unnecessary warning on missing /cpus node
    
    Not all DT platforms have all the cpus collected under a /cpus node.
    That just happens to be a details of FDT, ePAPR and PowerPC platforms.
    Sparc does something different, but unfortunately the current code
    complains with a warning if /cpus isn't there. This became a problem
    with commit f86e4718, "driver/core cpu: initialize of_node in cpu's
    device structure", which caused the function to get called for all
    architectures.
    
    This commit is a temporary fix to fail silently if the cpus node isn't
    present. A proper fix will come later to allow arch code to provide a
    custom mechanism for decoding the CPU hwid if the 'reg' property isn't
    appropriate.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Cc: David Miller <davem@davemloft.net>
    Cc: Sudeep KarkadaNagesha <Sudeep.KarkadaNagesha@arm.com>
    Cc: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 865d3f66c86b..7d4c70f859e3 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -303,10 +303,8 @@ struct device_node *of_get_cpu_node(int cpu, unsigned int *thread)
 	struct device_node *cpun, *cpus;
 
 	cpus = of_find_node_by_path("/cpus");
-	if (!cpus) {
-		pr_warn("Missing cpus node, bailing out\n");
+	if (!cpus)
 		return NULL;
-	}
 
 	for_each_child_of_node(cpus, cpun) {
 		if (of_node_cmp(cpun->type, "cpu"))

commit 0c3f061c195ceb891067b6de9e4ecc347c4dea31
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Tue Sep 17 10:42:50 2013 -0500

    of: implement of_node_to_nid as a weak function
    
    Implement of_node_to_nid as weak function to remove the dependency on
    asm/prom.h. This is in preparation to make prom.h optional.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 865d3f66c86b..ced4c06d79b3 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -74,6 +74,13 @@ int of_n_size_cells(struct device_node *np)
 }
 EXPORT_SYMBOL(of_n_size_cells);
 
+#ifdef CONFIG_NUMA
+int __weak of_node_to_nid(struct device_node *np)
+{
+	return numa_node_id();
+}
+#endif
+
 #if defined(CONFIG_OF_DYNAMIC)
 /**
  *	of_node_get - Increment refcount of a node

commit 31f7c3a688f75bceaf2fd009efc489659ad6aa61
Merge: ec5b103ecfde 2bc552df76d8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 10 13:53:52 2013 -0700

    Merge tag 'devicetree-for-linus' of git://git.secretlab.ca/git/linux
    
    Pull device tree core updates from Grant Likely:
     "Generally minor changes.  A bunch of bug fixes, particularly for
      initialization and some refactoring.  Most notable change if feeding
      the entire flattened tree into the random pool at boot.  May not be
      significant, but shouldn't hurt either"
    
    Tim Bird questions whether the boot time cost of the random feeding may
    be noticeable.  And "add_device_randomness()" is definitely not some
    speed deamon of a function.
    
    * tag 'devicetree-for-linus' of git://git.secretlab.ca/git/linux:
      of/platform: add error reporting to of_amba_device_create()
      irq/of: Fix comment typo for irq_of_parse_and_map
      of: Feed entire flattened device tree into the random pool
      of/fdt: Clean up casting in unflattening path
      of/fdt: Remove duplicate memory clearing on FDT unflattening
      gpio: implement gpio-ranges binding document fix
      of: call __of_parse_phandle_with_args from of_parse_phandle
      of: introduce of_parse_phandle_with_fixed_args
      of: move of_parse_phandle()
      of: move documentation of of_parse_phandle_with_args
      of: Fix missing memory initialization on FDT unflattening
      of: consolidate definition of early_init_dt_alloc_memory_arch()
      of: Make of_get_phy_mode() return int i.s.o. const int
      include: dt-binding: input: create a DT header defining key codes.
      of/platform: Staticize of_platform_device_create_pdata()
      of: Specify initrd location using 64-bit
      dt: Typo fix
      OF: make of_property_for_each_{u32|string}() use parameters if OF is not enabled

commit 40031da445fb4d269af9c7c445b2adf674f171e7
Merge: dcaaaeac871f f41b83126cba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 3 15:59:39 2013 -0700

    Merge tag 'pm+acpi-3.12-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI and power management updates from Rafael Wysocki:
    
     1) ACPI-based PCI hotplug (ACPIPHP) subsystem rework and introduction
        of Intel Thunderbolt support on systems that use ACPI for signalling
        Thunderbolt hotplug events.  This also should make ACPIPHP work in
        some cases in which it was known to have problems.  From
        Rafael J Wysocki, Mika Westerberg and Kirill A Shutemov.
    
     2) ACPI core code cleanups and dock station support cleanups from
        Jiang Liu and Rafael J Wysocki.
    
     3) Fixes for locking problems related to ACPI device hotplug from
        Rafael J Wysocki.
    
     4) ACPICA update to version 20130725 includig fixes, cleanups, support
        for more than 256 GPEs per GPE block and a change to make the ACPI
        PM Timer optional (we've seen systems without the PM Timer in the
        field already).  One of the fixes, related to the DeRefOf operator,
        is necessary to prevent some Windows 8 oriented AML from causing
        problems to happen.  From Bob Moore, Lv Zheng, and Jung-uk Kim.
    
     5) Removal of the old and long deprecated /proc/acpi/event interface
        and related driver changes from Thomas Renninger.
    
     6) ACPI and Xen changes to make the reduced hardware sleep work with
        the latter from Ben Guthro.
    
     7) ACPI video driver cleanups and a blacklist of systems that should
        not tell the BIOS that they are compatible with Windows 8 (or ACPI
        backlight and possibly other things will not work on them).  From
        Felipe Contreras.
    
     8) Assorted ACPI fixes and cleanups from Aaron Lu, Hanjun Guo,
        Kuppuswamy Sathyanarayanan, Lan Tianyu, Sachin Kamat, Tang Chen,
        Toshi Kani, and Wei Yongjun.
    
     9) cpufreq ondemand governor target frequency selection change to
        reduce oscillations between min and max frequencies (essentially,
        it causes the governor to choose target frequencies proportional
        to load) from Stratos Karafotis.
    
    10) cpufreq fixes allowing sysfs attributes file permissions to be
        preserved over suspend/resume cycles Srivatsa S Bhat.
    
    11) Removal of Device Tree parsing for CPU device nodes from multiple
        cpufreq drivers that required some changes related to
        of_get_cpu_node() to be made in a few architectures and in the
        driver core.  From Sudeep KarkadaNagesha.
    
    12) cpufreq core fixes and cleanups related to mutual exclusion and
        driver module references from Viresh Kumar, Lukasz Majewski and
        Rafael J Wysocki.
    
    13) Assorted cpufreq fixes and cleanups from Amit Daniel Kachhap,
        Bartlomiej Zolnierkiewicz, Hanjun Guo, Jingoo Han, Joseph Lo,
        Julia Lawall, Li Zhong, Mark Brown, Sascha Hauer, Stephen Boyd,
        Stratos Karafotis, and Viresh Kumar.
    
    14) Fixes to prevent race conditions in coupled cpuidle from happening
        from Colin Cross.
    
    15) cpuidle core fixes and cleanups from Daniel Lezcano and
        Tuukka Tikkanen.
    
    16) Assorted cpuidle fixes and cleanups from Daniel Lezcano,
        Geert Uytterhoeven, Jingoo Han, Julia Lawall, Linus Walleij,
        and Sahara.
    
    17) System sleep tracing changes from Todd E Brandt and Shuah Khan.
    
    18) PNP subsystem conversion to using struct dev_pm_ops for power
        management from Shuah Khan.
    
    * tag 'pm+acpi-3.12-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (217 commits)
      cpufreq: Don't use smp_processor_id() in preemptible context
      cpuidle: coupled: fix race condition between pokes and safe state
      cpuidle: coupled: abort idle if pokes are pending
      cpuidle: coupled: disable interrupts after entering safe state
      ACPI / hotplug: Remove containers synchronously
      driver core / ACPI: Avoid device hot remove locking issues
      cpufreq: governor: Fix typos in comments
      cpufreq: governors: Remove duplicate check of target freq in supported range
      cpufreq: Fix timer/workqueue corruption due to double queueing
      ACPI / EC: Add ASUSTEK L4R to quirk list in order to validate ECDT
      ACPI / thermal: Add check of "_TZD" availability and evaluating result
      cpufreq: imx6q: Fix clock enable balance
      ACPI: blacklist win8 OSI for buggy laptops
      cpufreq: tegra: fix the wrong clock name
      cpuidle: Change struct menu_device field types
      cpuidle: Add a comment warning about possible overflow
      cpuidle: Fix variable domains in get_typical_interval()
      cpuidle: Fix menu_device->intervals type
      cpuidle: CodingStyle: Break up multiple assignments on single line
      cpuidle: Check called function parameter in get_typical_interval()
      ...

commit 91d9942c28ee691dab47185f38b052f84db4e0f7
Author: Stephen Warren <swarren@nvidia.com>
Date:   Wed Aug 14 15:27:11 2013 -0600

    of: call __of_parse_phandle_with_args from of_parse_phandle
    
    The simplest case of __of_parse_phandle_with_args() now implements the
    semantics of of_parse_phandle(). Rewrite of_parse_phandle() to call
    __of_parse_phandle_with_args() rather than open-coding the simple case.
    
    Optimize __of_parse_phandle_with_args() so that it doesn't call
    of_find_node_by_phandle() except when it's strictly needed. This avoids
    introducing too much overhead when replacing of_parse_phandle().
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 1f80acf4c16a..7c75d7551eb9 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1111,13 +1111,20 @@ static int __of_parse_phandle_with_args(const struct device_node *np,
 		if (phandle) {
 			/*
 			 * Find the provider node and parse the #*-cells
-			 * property to determine the argument length
+			 * property to determine the argument length.
+			 *
+			 * This is not needed if the cell count is hard-coded
+			 * (i.e. cells_name not set, but cell_count is set),
+			 * except when we're going to return the found node
+			 * below.
 			 */
-			node = of_find_node_by_phandle(phandle);
-			if (!node) {
-				pr_err("%s: could not find phandle\n",
-					 np->full_name);
-				goto err;
+			if (cells_name || cur_index == index) {
+				node = of_find_node_by_phandle(phandle);
+				if (!node) {
+					pr_err("%s: could not find phandle\n",
+						np->full_name);
+					goto err;
+				}
 			}
 
 			if (cells_name) {
@@ -1202,14 +1209,16 @@ static int __of_parse_phandle_with_args(const struct device_node *np,
 struct device_node *of_parse_phandle(const struct device_node *np,
 				     const char *phandle_name, int index)
 {
-	const __be32 *phandle;
-	int size;
+	struct of_phandle_args args;
+
+	if (index < 0)
+		return NULL;
 
-	phandle = of_get_property(np, phandle_name, &size);
-	if ((!phandle) || (size < sizeof(*phandle) * (index + 1)))
+	if (__of_parse_phandle_with_args(np, phandle_name, NULL, 0,
+					 index, &args))
 		return NULL;
 
-	return of_find_node_by_phandle(be32_to_cpup(phandle + index));
+	return args.np;
 }
 EXPORT_SYMBOL(of_parse_phandle);
 

commit 035fd9482274bf43858b00e0ff95179af66df8e8
Author: Stephen Warren <swarren@nvidia.com>
Date:   Wed Aug 14 15:27:10 2013 -0600

    of: introduce of_parse_phandle_with_fixed_args
    
    This is identical to of_parse_phandle_with_args(), except that the
    number of argument cells is fixed, rather than being parsed out of the
    node referenced by each phandle.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index ef2f1d0dd80a..1f80acf4c16a 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1082,7 +1082,8 @@ EXPORT_SYMBOL_GPL(of_property_count_strings);
 
 static int __of_parse_phandle_with_args(const struct device_node *np,
 					const char *list_name,
-					const char *cells_name, int index,
+					const char *cells_name,
+					int cell_count, int index,
 					struct of_phandle_args *out_args)
 {
 	const __be32 *list, *list_end;
@@ -1118,11 +1119,17 @@ static int __of_parse_phandle_with_args(const struct device_node *np,
 					 np->full_name);
 				goto err;
 			}
-			if (of_property_read_u32(node, cells_name, &count)) {
-				pr_err("%s: could not get %s for %s\n",
-					 np->full_name, cells_name,
-					 node->full_name);
-				goto err;
+
+			if (cells_name) {
+				if (of_property_read_u32(node, cells_name,
+							 &count)) {
+					pr_err("%s: could not get %s for %s\n",
+						np->full_name, cells_name,
+						node->full_name);
+					goto err;
+				}
+			} else {
+				count = cell_count;
 			}
 
 			/*
@@ -1244,10 +1251,52 @@ int of_parse_phandle_with_args(const struct device_node *np, const char *list_na
 {
 	if (index < 0)
 		return -EINVAL;
-	return __of_parse_phandle_with_args(np, list_name, cells_name, index, out_args);
+	return __of_parse_phandle_with_args(np, list_name, cells_name, 0,
+					    index, out_args);
 }
 EXPORT_SYMBOL(of_parse_phandle_with_args);
 
+/**
+ * of_parse_phandle_with_fixed_args() - Find a node pointed by phandle in a list
+ * @np:		pointer to a device tree node containing a list
+ * @list_name:	property name that contains a list
+ * @cell_count: number of argument cells following the phandle
+ * @index:	index of a phandle to parse out
+ * @out_args:	optional pointer to output arguments structure (will be filled)
+ *
+ * This function is useful to parse lists of phandles and their arguments.
+ * Returns 0 on success and fills out_args, on error returns appropriate
+ * errno value.
+ *
+ * Caller is responsible to call of_node_put() on the returned out_args->node
+ * pointer.
+ *
+ * Example:
+ *
+ * phandle1: node1 {
+ * }
+ *
+ * phandle2: node2 {
+ * }
+ *
+ * node3 {
+ * 	list = <&phandle1 0 2 &phandle2 2 3>;
+ * }
+ *
+ * To get a device_node of the `node2' node you may call this:
+ * of_parse_phandle_with_fixed_args(node3, "list", 2, 1, &args);
+ */
+int of_parse_phandle_with_fixed_args(const struct device_node *np,
+				const char *list_name, int cell_count,
+				int index, struct of_phandle_args *out_args)
+{
+	if (index < 0)
+		return -EINVAL;
+	return __of_parse_phandle_with_args(np, list_name, NULL, cell_count,
+					   index, out_args);
+}
+EXPORT_SYMBOL(of_parse_phandle_with_fixed_args);
+
 /**
  * of_count_phandle_with_args() - Find the number of phandles references in a property
  * @np:		pointer to a device tree node containing a list
@@ -1266,7 +1315,8 @@ EXPORT_SYMBOL(of_parse_phandle_with_args);
 int of_count_phandle_with_args(const struct device_node *np, const char *list_name,
 				const char *cells_name)
 {
-	return __of_parse_phandle_with_args(np, list_name, cells_name, -1, NULL);
+	return __of_parse_phandle_with_args(np, list_name, cells_name, 0, -1,
+					    NULL);
 }
 EXPORT_SYMBOL(of_count_phandle_with_args);
 

commit 5fba49e3a8c22a7bb71c3526ec32b373b3ef32b8
Author: Stephen Warren <swarren@nvidia.com>
Date:   Wed Aug 14 15:27:09 2013 -0600

    of: move of_parse_phandle()
    
    Move of_parse_phandle() after __of_parse_phandle_with_args(), since a
    future patch will call __of_parse_phandle_with_args() from
    of_parse_phandle(). Moving the function avoids adding a prototype. Doing
    the move separately highlights the code changes separately.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index ab32561117c1..ef2f1d0dd80a 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1080,30 +1080,6 @@ int of_property_count_strings(struct device_node *np, const char *propname)
 }
 EXPORT_SYMBOL_GPL(of_property_count_strings);
 
-/**
- * of_parse_phandle - Resolve a phandle property to a device_node pointer
- * @np: Pointer to device node holding phandle property
- * @phandle_name: Name of property holding a phandle value
- * @index: For properties holding a table of phandles, this is the index into
- *         the table
- *
- * Returns the device_node pointer with refcount incremented.  Use
- * of_node_put() on it when done.
- */
-struct device_node *of_parse_phandle(const struct device_node *np,
-				     const char *phandle_name, int index)
-{
-	const __be32 *phandle;
-	int size;
-
-	phandle = of_get_property(np, phandle_name, &size);
-	if ((!phandle) || (size < sizeof(*phandle) * (index + 1)))
-		return NULL;
-
-	return of_find_node_by_phandle(be32_to_cpup(phandle + index));
-}
-EXPORT_SYMBOL(of_parse_phandle);
-
 static int __of_parse_phandle_with_args(const struct device_node *np,
 					const char *list_name,
 					const char *cells_name, int index,
@@ -1206,6 +1182,30 @@ static int __of_parse_phandle_with_args(const struct device_node *np,
 	return rc;
 }
 
+/**
+ * of_parse_phandle - Resolve a phandle property to a device_node pointer
+ * @np: Pointer to device node holding phandle property
+ * @phandle_name: Name of property holding a phandle value
+ * @index: For properties holding a table of phandles, this is the index into
+ *         the table
+ *
+ * Returns the device_node pointer with refcount incremented.  Use
+ * of_node_put() on it when done.
+ */
+struct device_node *of_parse_phandle(const struct device_node *np,
+				     const char *phandle_name, int index)
+{
+	const __be32 *phandle;
+	int size;
+
+	phandle = of_get_property(np, phandle_name, &size);
+	if ((!phandle) || (size < sizeof(*phandle) * (index + 1)))
+		return NULL;
+
+	return of_find_node_by_phandle(be32_to_cpup(phandle + index));
+}
+EXPORT_SYMBOL(of_parse_phandle);
+
 /**
  * of_parse_phandle_with_args() - Find a node pointed by phandle in a list
  * @np:		pointer to a device tree node containing a list

commit eded9dd40b1e30215ab7379dc433f3d3c662ec88
Author: Stephen Warren <swarren@nvidia.com>
Date:   Wed Aug 14 15:27:08 2013 -0600

    of: move documentation of of_parse_phandle_with_args
    
    Commit bd69f73 "of: Create function for counting number of phandles in
    a property" renamed of_parse_phandle_with_args(), and created a wrapper
    function that implemented the original name. However, the documentation
    of the original function was not moved, leaving it apparently documenting
    the newly renamed function.
    
    Move the documentation so that it is adjacent to the function it
    documents.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index bf8432f580f6..ab32561117c1 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1104,38 +1104,6 @@ struct device_node *of_parse_phandle(const struct device_node *np,
 }
 EXPORT_SYMBOL(of_parse_phandle);
 
-/**
- * of_parse_phandle_with_args() - Find a node pointed by phandle in a list
- * @np:		pointer to a device tree node containing a list
- * @list_name:	property name that contains a list
- * @cells_name:	property name that specifies phandles' arguments count
- * @index:	index of a phandle to parse out
- * @out_args:	optional pointer to output arguments structure (will be filled)
- *
- * This function is useful to parse lists of phandles and their arguments.
- * Returns 0 on success and fills out_args, on error returns appropriate
- * errno value.
- *
- * Caller is responsible to call of_node_put() on the returned out_args->node
- * pointer.
- *
- * Example:
- *
- * phandle1: node1 {
- * 	#list-cells = <2>;
- * }
- *
- * phandle2: node2 {
- * 	#list-cells = <1>;
- * }
- *
- * node3 {
- * 	list = <&phandle1 1 2 &phandle2 3>;
- * }
- *
- * To get a device_node of the `node2' node you may call this:
- * of_parse_phandle_with_args(node3, "list", "#list-cells", 1, &args);
- */
 static int __of_parse_phandle_with_args(const struct device_node *np,
 					const char *list_name,
 					const char *cells_name, int index,
@@ -1238,6 +1206,38 @@ static int __of_parse_phandle_with_args(const struct device_node *np,
 	return rc;
 }
 
+/**
+ * of_parse_phandle_with_args() - Find a node pointed by phandle in a list
+ * @np:		pointer to a device tree node containing a list
+ * @list_name:	property name that contains a list
+ * @cells_name:	property name that specifies phandles' arguments count
+ * @index:	index of a phandle to parse out
+ * @out_args:	optional pointer to output arguments structure (will be filled)
+ *
+ * This function is useful to parse lists of phandles and their arguments.
+ * Returns 0 on success and fills out_args, on error returns appropriate
+ * errno value.
+ *
+ * Caller is responsible to call of_node_put() on the returned out_args->node
+ * pointer.
+ *
+ * Example:
+ *
+ * phandle1: node1 {
+ * 	#list-cells = <2>;
+ * }
+ *
+ * phandle2: node2 {
+ * 	#list-cells = <1>;
+ * }
+ *
+ * node3 {
+ * 	list = <&phandle1 1 2 &phandle2 3>;
+ * }
+ *
+ * To get a device_node of the `node2' node you may call this:
+ * of_parse_phandle_with_args(node3, "list", "#list-cells", 1, &args);
+ */
 int of_parse_phandle_with_args(const struct device_node *np, const char *list_name,
 				const char *cells_name, int index,
 				struct of_phandle_args *out_args)

commit 0640332e073be9207f0784df43595c0c39716e42
Author: Grant Likely <grant.likely@linaro.org>
Date:   Wed Aug 28 21:24:17 2013 +0100

    of: Fix missing memory initialization on FDT unflattening
    
    Any calls to dt_alloc() need to be zeroed. This is a temporary fix, but
    the allocation function itself needs to zero memory before returning
    it. This is a follow up to patch 9e4012752, "of: fdt: fix memory
    initialization for expanded DT" which fixed one call site but missed
    another.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Acked-by: Wladislav Wiebe <wladislav.kw@gmail.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 5c5427918eb2..bf8432f580f6 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1629,6 +1629,7 @@ void of_alias_scan(void * (*dt_alloc)(u64 size, u64 align))
 		ap = dt_alloc(sizeof(*ap) + len + 1, 4);
 		if (!ap)
 			continue;
+		memset(ap, 0, sizeof(*ap) + len + 1);
 		ap->alias = start;
 		of_alias_add(ap, np, id, start, len);
 	}

commit 183912d352a242a276a7877852f107459a13aff9
Author: Sudeep KarkadaNagesha <sudeep.karkadanagesha@arm.com>
Date:   Thu Aug 15 14:01:40 2013 +0100

    of: move of_get_cpu_node implementation to DT core library
    
    This patch moves the generalized implementation of of_get_cpu_node from
    PowerPC to DT core library, thereby adding support for retrieving cpu
    node for a given logical cpu index on any architecture.
    
    The CPU subsystem can now use this function to assign of_node in the
    cpu device while registering CPUs.
    
    It is recommended to use these helper function only in pre-SMP/early
    initialisation stages to retrieve CPU device node pointers in logical
    ordering. Once the cpu devices are registered, it can be retrieved easily
    from cpu device of_node which avoids unnecessary parsing and matching.
    
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Grant Likely <grant.likely@linaro.org>
    Acked-by: Rob Herring <rob.herring@calxeda.com>
    Signed-off-by: Sudeep KarkadaNagesha <sudeep.karkadanagesha@arm.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 5c5427918eb2..605afa9fbe5e 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -18,6 +18,7 @@
  *      2 of the License, or (at your option) any later version.
  */
 #include <linux/ctype.h>
+#include <linux/cpu.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/spinlock.h>
@@ -230,6 +231,100 @@ const void *of_get_property(const struct device_node *np, const char *name,
 }
 EXPORT_SYMBOL(of_get_property);
 
+/*
+ * arch_match_cpu_phys_id - Match the given logical CPU and physical id
+ *
+ * @cpu: logical cpu index of a core/thread
+ * @phys_id: physical identifier of a core/thread
+ *
+ * CPU logical to physical index mapping is architecture specific.
+ * However this __weak function provides a default match of physical
+ * id to logical cpu index. phys_id provided here is usually values read
+ * from the device tree which must match the hardware internal registers.
+ *
+ * Returns true if the physical identifier and the logical cpu index
+ * correspond to the same core/thread, false otherwise.
+ */
+bool __weak arch_match_cpu_phys_id(int cpu, u64 phys_id)
+{
+	return (u32)phys_id == cpu;
+}
+
+/**
+ * Checks if the given "prop_name" property holds the physical id of the
+ * core/thread corresponding to the logical cpu 'cpu'. If 'thread' is not
+ * NULL, local thread number within the core is returned in it.
+ */
+static bool __of_find_n_match_cpu_property(struct device_node *cpun,
+			const char *prop_name, int cpu, unsigned int *thread)
+{
+	const __be32 *cell;
+	int ac, prop_len, tid;
+	u64 hwid;
+
+	ac = of_n_addr_cells(cpun);
+	cell = of_get_property(cpun, prop_name, &prop_len);
+	if (!cell)
+		return false;
+	prop_len /= sizeof(*cell);
+	for (tid = 0; tid < prop_len; tid++) {
+		hwid = of_read_number(cell, ac);
+		if (arch_match_cpu_phys_id(cpu, hwid)) {
+			if (thread)
+				*thread = tid;
+			return true;
+		}
+		cell += ac;
+	}
+	return false;
+}
+
+/**
+ * of_get_cpu_node - Get device node associated with the given logical CPU
+ *
+ * @cpu: CPU number(logical index) for which device node is required
+ * @thread: if not NULL, local thread number within the physical core is
+ *          returned
+ *
+ * The main purpose of this function is to retrieve the device node for the
+ * given logical CPU index. It should be used to initialize the of_node in
+ * cpu device. Once of_node in cpu device is populated, all the further
+ * references can use that instead.
+ *
+ * CPU logical to physical index mapping is architecture specific and is built
+ * before booting secondary cores. This function uses arch_match_cpu_phys_id
+ * which can be overridden by architecture specific implementation.
+ *
+ * Returns a node pointer for the logical cpu if found, else NULL.
+ */
+struct device_node *of_get_cpu_node(int cpu, unsigned int *thread)
+{
+	struct device_node *cpun, *cpus;
+
+	cpus = of_find_node_by_path("/cpus");
+	if (!cpus) {
+		pr_warn("Missing cpus node, bailing out\n");
+		return NULL;
+	}
+
+	for_each_child_of_node(cpus, cpun) {
+		if (of_node_cmp(cpun->type, "cpu"))
+			continue;
+		/* Check for non-standard "ibm,ppc-interrupt-server#s" property
+		 * for thread ids on PowerPC. If it doesn't exist fallback to
+		 * standard "reg" property.
+		 */
+		if (IS_ENABLED(CONFIG_PPC) &&
+			__of_find_n_match_cpu_property(cpun,
+				"ibm,ppc-interrupt-server#s", cpu, thread))
+			return cpun;
+		if (__of_find_n_match_cpu_property(cpun, "reg", cpu, thread))
+			return cpun;
+	}
+	return NULL;
+}
+EXPORT_SYMBOL(of_get_cpu_node);
+
 /** Checks if the given "compat" string matches one of the strings in
  * the device's "compatible" property
  */

commit 5c19e95216b93b0d29c6a4887e69a980edc6fc81
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Mon Aug 5 14:40:44 2013 +0200

    OF: Add helper for matching against linux,stdout-path
    
    devicetrees may have a linux,stdout-path property in the chosen
    node describing the console device. This adds a helper function
    to match a device against this property so a driver can call
    add_preferred_console for a matching device.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Rob Herring <rob.herring@calxeda.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 5c5427918eb2..1c3c79c79742 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -32,6 +32,7 @@ struct device_node *of_allnodes;
 EXPORT_SYMBOL(of_allnodes);
 struct device_node *of_chosen;
 struct device_node *of_aliases;
+static struct device_node *of_stdout;
 
 DEFINE_MUTEX(of_aliases_mutex);
 
@@ -1595,6 +1596,15 @@ void of_alias_scan(void * (*dt_alloc)(u64 size, u64 align))
 	of_chosen = of_find_node_by_path("/chosen");
 	if (of_chosen == NULL)
 		of_chosen = of_find_node_by_path("/chosen@0");
+
+	if (of_chosen) {
+		const char *name;
+
+		name = of_get_property(of_chosen, "linux,stdout-path", NULL);
+		if (name)
+			of_stdout = of_find_node_by_path(name);
+	}
+
 	of_aliases = of_find_node_by_path("/aliases");
 	if (!of_aliases)
 		return;
@@ -1703,3 +1713,19 @@ const char *of_prop_next_string(struct property *prop, const char *cur)
 	return curv;
 }
 EXPORT_SYMBOL_GPL(of_prop_next_string);
+
+/**
+ * of_device_is_stdout_path - check if a device node matches the
+ *                            linux,stdout-path property
+ *
+ * Check if this device node matches the linux,stdout-path property
+ * in the chosen node. return true if yes, false otherwise.
+ */
+int of_device_is_stdout_path(struct device_node *dn)
+{
+	if (!of_stdout)
+		return false;
+
+	return of_stdout == dn;
+}
+EXPORT_SYMBOL_GPL(of_device_is_stdout_path);

commit 74b9272bbedf45cb01a048217830d64d59aaa73b
Merge: f5b63ac0f77e 6dd18e4684f3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 4 15:51:45 2013 -0700

    Merge tag 'devicetree-for-linus' of git://git.secretlab.ca/git/linux
    
    Pull device tree updates from Grant Likely:
     "This branch contains the following changes:
       - Removal of CONFIG_OF_DEVICE, it is always enabled by CONFIG_OF
       - Remove #ifdef from linux/of_platform.h to increase compiler syntax
         coverage
       - Bug fix for address decoding on Bimini and js2x powerpc platforms.
       - miscellaneous binding changes
    
      One note on the above.  The binding changes going in from all kinds of
      different trees has gotten rather out of hand.  I picked up some
      during this cycle, but even going though my tree isn't a great fit.
    
      Ian Campbell has prototyped splitting the bindings and .dtb files into
      a separate repository.  The plan is to migrate to using that sometime
      in the next few kernel releases which should get rid of a lot of the
      churn on binding docs and .dts files"
    
    * tag 'devicetree-for-linus' of git://git.secretlab.ca/git/linux:
      of: Fix address decoding on Bimini and js2x machines
      of: remove CONFIG_OF_DEVICE
      usb: chipidea: depend on CONFIG_OF instead of CONFIG_OF_DEVICE
      of: remove of_platform_driver
      ibmebus: convert of_platform_driver to platform_driver
      driver core: move to_platform_driver to platform_device.h
      mfd: DT bindings for the palmas family MFD
      ARM: dts: omap3-devkit8000: fix NAND memory binding
      of/base: fix typos
      of: remove #ifdef from linux/of_platform.h

commit d25d86949b6799c35d78f4910498c2b65a3f0841
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed Jun 12 15:39:04 2013 +1000

    of: Fix locking vs. interrupts
    
    The OF code uses irqsafe locks everywhere except in a handful of functions
    for no obvious reasons. Since the conversion from the old rwlocks, this
    now triggers lockdep warnings when used at interrupt time. At least one
    driver (ibmvscsi) seems to be doing that from softirq context.
    
    This converts the few non-irqsafe locks into irqsafe ones, making them
    consistent with the rest of the code.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index f53b992f060a..a6f584a7f4a1 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -192,14 +192,15 @@ EXPORT_SYMBOL(of_find_property);
 struct device_node *of_find_all_nodes(struct device_node *prev)
 {
 	struct device_node *np;
+	unsigned long flags;
 
-	raw_spin_lock(&devtree_lock);
+	raw_spin_lock_irqsave(&devtree_lock, flags);
 	np = prev ? prev->allnext : of_allnodes;
 	for (; np != NULL; np = np->allnext)
 		if (of_node_get(np))
 			break;
 	of_node_put(prev);
-	raw_spin_unlock(&devtree_lock);
+	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 	return np;
 }
 EXPORT_SYMBOL(of_find_all_nodes);
@@ -421,8 +422,9 @@ struct device_node *of_get_next_available_child(const struct device_node *node,
 	struct device_node *prev)
 {
 	struct device_node *next;
+	unsigned long flags;
 
-	raw_spin_lock(&devtree_lock);
+	raw_spin_lock_irqsave(&devtree_lock, flags);
 	next = prev ? prev->sibling : node->child;
 	for (; next; next = next->sibling) {
 		if (!__of_device_is_available(next))
@@ -431,7 +433,7 @@ struct device_node *of_get_next_available_child(const struct device_node *node,
 			break;
 	}
 	of_node_put(prev);
-	raw_spin_unlock(&devtree_lock);
+	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 	return next;
 }
 EXPORT_SYMBOL(of_get_next_available_child);
@@ -735,13 +737,14 @@ EXPORT_SYMBOL_GPL(of_modalias_node);
 struct device_node *of_find_node_by_phandle(phandle handle)
 {
 	struct device_node *np;
+	unsigned long flags;
 
-	raw_spin_lock(&devtree_lock);
+	raw_spin_lock_irqsave(&devtree_lock, flags);
 	for (np = of_allnodes; np; np = np->allnext)
 		if (np->phandle == handle)
 			break;
 	of_node_get(np);
-	raw_spin_unlock(&devtree_lock);
+	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 	return np;
 }
 EXPORT_SYMBOL(of_find_node_by_phandle);

commit 792efb84670c5b4c58669645cb6fd7e943376ee0
Author: Lad, Prabhakar <prabhakar.csengg@gmail.com>
Date:   Tue May 7 11:34:11 2013 +0530

    of/base: fix typos
    
    the function of_property_read_u8/16/32_array() has a parameter
    out_values, but the description mentioned it as out_value. This
    patch fixes this typo.
    
    Signed-off-by: Lad, Prabhakar <prabhakar.csengg@gmail.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index f53b992f060a..c1cfc4553a5d 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -809,7 +809,7 @@ EXPORT_SYMBOL_GPL(of_property_read_u32_index);
  *
  * @np:		device node from which the property value is to be read.
  * @propname:	name of the property to be searched.
- * @out_value:	pointer to return value, modified only if return value is 0.
+ * @out_values:	pointer to return value, modified only if return value is 0.
  * @sz:		number of array elements to read
  *
  * Search for a property in a device node and read 8-bit value(s) from
@@ -820,7 +820,7 @@ EXPORT_SYMBOL_GPL(of_property_read_u32_index);
  * dts entry of array should be like:
  *	property = /bits/ 8 <0x50 0x60 0x70>;
  *
- * The out_value is modified only if a valid u8 value can be decoded.
+ * The out_values is modified only if a valid u8 value can be decoded.
  */
 int of_property_read_u8_array(const struct device_node *np,
 			const char *propname, u8 *out_values, size_t sz)
@@ -842,7 +842,7 @@ EXPORT_SYMBOL_GPL(of_property_read_u8_array);
  *
  * @np:		device node from which the property value is to be read.
  * @propname:	name of the property to be searched.
- * @out_value:	pointer to return value, modified only if return value is 0.
+ * @out_values:	pointer to return value, modified only if return value is 0.
  * @sz:		number of array elements to read
  *
  * Search for a property in a device node and read 16-bit value(s) from
@@ -853,7 +853,7 @@ EXPORT_SYMBOL_GPL(of_property_read_u8_array);
  * dts entry of array should be like:
  *	property = /bits/ 16 <0x5000 0x6000 0x7000>;
  *
- * The out_value is modified only if a valid u16 value can be decoded.
+ * The out_values is modified only if a valid u16 value can be decoded.
  */
 int of_property_read_u16_array(const struct device_node *np,
 			const char *propname, u16 *out_values, size_t sz)
@@ -876,7 +876,7 @@ EXPORT_SYMBOL_GPL(of_property_read_u16_array);
  *
  * @np:		device node from which the property value is to be read.
  * @propname:	name of the property to be searched.
- * @out_value:	pointer to return value, modified only if return value is 0.
+ * @out_values:	pointer to return value, modified only if return value is 0.
  * @sz:		number of array elements to read
  *
  * Search for a property in a device node and read 32-bit value(s) from
@@ -884,7 +884,7 @@ EXPORT_SYMBOL_GPL(of_property_read_u16_array);
  * -ENODATA if property does not have a value, and -EOVERFLOW if the
  * property data isn't large enough.
  *
- * The out_value is modified only if a valid u32 value can be decoded.
+ * The out_values is modified only if a valid u32 value can be decoded.
  */
 int of_property_read_u32_array(const struct device_node *np,
 			       const char *propname, u32 *out_values,

commit ff9129b06cfb05cb5920f1151c75506afe1586fe
Merge: 3c6a279ffccd 3132f623386e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat May 18 10:46:50 2013 -0700

    Merge tag 'devicetree-for-linus' of git://git.secretlab.ca/git/linux
    
    Pull device tree fixes from Grant Likely:
     "Device tree bug fixes and documentation updates for v3.10
    
      Nothing earth shattering here.  A build failure fix, and fix for
      releasing nodes and some documenation updates."
    
    * tag 'devicetree-for-linus' of git://git.secretlab.ca/git/linux:
      Documentation/devicetree: make semantic of initrd-end more explicit
      of/base: release the node correctly in of_parse_phandle_with_args()
      of/documentation: move video device bindings to a common place
      <linux/of_platform.h>: fix compilation warnings with DT disabled

commit 6fa52ed33bea997374a88dbacbba5bf8c7ac4fef
Merge: 1db772216f48 bc8fd900c4d4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat May 4 12:31:18 2013 -0700

    Merge tag 'drivers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC driver changes from Olof Johansson:
     "This is a rather large set of patches for device drivers that for one
      reason or another the subsystem maintainer preferred to get merged
      through the arm-soc tree.  There are both new drivers as well as
      existing drivers that are getting converted from platform-specific
      code into standalone drivers using the appropriate subsystem specific
      interfaces.
    
      In particular, we can now have pinctrl, clk, clksource and irqchip
      drivers in one file per driver, without the need to call into platform
      specific interface, or to get called from platform specific code, as
      long as all information about the hardware is provided through a
      device tree.
    
      Most of the drivers we touch this time are for clocksource.  Since now
      most of them are part of drivers/clocksource, I expect that we won't
      have to touch these again from arm-soc and can let the clocksource
      maintainers take care of these in the future.
    
      Another larger part of this series is specific to the exynos platform,
      which is seeing some significant effort in upstreaming and
      modernization of its device drivers this time around, which
      unfortunately is also the cause for the churn and a lot of the merge
      conflicts.
    
      There is one new subsystem that gets merged as part of this series:
      the reset controller interface, which is a very simple interface for
      taking devices on the SoC out of reset or back into reset.  Patches to
      use this interface on i.MX follow later in this merge window, and we
      are going to have other platforms (at least tegra and sirf) get
      converted in 3.11.  This will let us get rid of platform specific
      callbacks in a number of platform independent device drivers."
    
    * tag 'drivers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (256 commits)
      irqchip: s3c24xx: add missing __init annotations
      ARM: dts: Disable the RTC by default on exynos5
      clk: exynos5250: Fix parent clock for sclk_mmc{0,1,2,3}
      ARM: exynos: restore mach/regs-clock.h for exynos5
      clocksource: exynos_mct: fix build error on non-DT
      pinctrl: vt8500: wmt: Fix checking return value of pinctrl_register()
      irqchip: vt8500: Convert arch-vt8500 to new irqchip infrastructure
      reset: NULL deref on allocation failure
      reset: Add reset controller API
      dt: describe base reset signal binding
      ARM: EXYNOS: Add arm-pmu DT binding for exynos421x
      ARM: EXYNOS: Add arm-pmu DT binding for exynos5250
      ARM: EXYNOS: Enable PMUs for exynos4
      irqchip: exynos-combiner: Correct combined IRQs for exynos4
      irqchip: exynos-combiner: Add set_irq_affinity function for combiner_irq
      ARM: EXYNOS: fix compilation error introduced due to common clock migration
      clk: exynos5250: Fix divider values for sclk_mmc{0,1,2,3}
      clk: exynos4: export clocks required for fimc-is
      clk: samsung: Fix compilation error
      clk: tegra: fix enum tegra114_clk to match binding
      ...

commit 20b4fb485227404329e41ad15588afad3df23050
Merge: b9394d8a657c ac3e3c5b1164
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 1 17:51:54 2013 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull VFS updates from Al Viro,
    
    Misc cleanups all over the place, mainly wrt /proc interfaces (switch
    create_proc_entry to proc_create(), get rid of the deprecated
    create_proc_read_entry() in favor of using proc_create_data() and
    seq_file etc).
    
    7kloc removed.
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (204 commits)
      don't bother with deferred freeing of fdtables
      proc: Move non-public stuff from linux/proc_fs.h to fs/proc/internal.h
      proc: Make the PROC_I() and PDE() macros internal to procfs
      proc: Supply a function to remove a proc entry by PDE
      take cgroup_open() and cpuset_open() to fs/proc/base.c
      ppc: Clean up scanlog
      ppc: Clean up rtas_flash driver somewhat
      hostap: proc: Use remove_proc_subtree()
      drm: proc: Use remove_proc_subtree()
      drm: proc: Use minor->index to label things, not PDE->name
      drm: Constify drm_proc_list[]
      zoran: Don't print proc_dir_entry data in debug
      reiserfs: Don't access the proc_dir_entry in r_open(), r_start() r_show()
      proc: Supply an accessor for getting the data from a PDE's parent
      airo: Use remove_proc_subtree()
      rtl8192u: Don't need to save device proc dir PDE
      rtl8187se: Use a dir under /proc/net/r8180/
      proc: Add proc_mkdir_data()
      proc: Move some bits from linux/proc_fs.h to linux/{of.h,signal.h,tty.h}
      proc: Move PDE_NET() to fs/proc/proc_net.c
      ...

commit a8ca16ea7b0abb0a7e49492d1123b715f0ec62e8
Author: David Howells <dhowells@redhat.com>
Date:   Fri Apr 12 17:27:28 2013 +0100

    proc: Supply a function to remove a proc entry by PDE
    
    Supply a function (proc_remove()) to remove a proc entry (and any subtree
    rooted there) by proc_dir_entry pointer rather than by name and (optionally)
    root dir entry pointer.  This allows us to eliminate all remaining pde->name
    accesses outside of procfs.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Grant Likely <grant.likely@linaro.or>
    cc: linux-acpi@vger.kernel.org
    cc: openipmi-developer@lists.sourceforge.net
    cc: devicetree-discuss@lists.ozlabs.org
    cc: linux-pci@vger.kernel.org
    cc: netdev@vger.kernel.org
    cc: netfilter-devel@vger.kernel.org
    cc: alsa-devel@alsa-project.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 321d3ef05006..9c704369eda8 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1452,16 +1452,7 @@ int of_attach_node(struct device_node *np)
 #ifdef CONFIG_PROC_DEVICETREE
 static void of_remove_proc_dt_entry(struct device_node *dn)
 {
-	struct device_node *parent = dn->parent;
-	struct property *prop = dn->properties;
-
-	while (prop) {
-		remove_proc_entry(prop->name, dn->pde);
-		prop = prop->next;
-	}
-
-	if (dn->pde)
-		remove_proc_entry(dn->pde->name, parent->pde);
+	proc_remove(dn->pde);
 }
 #else
 static void of_remove_proc_dt_entry(struct device_node *dn)

commit 6695be6863b75620ffa6d422965680ce785cb7c8
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Tue Apr 2 12:28:11 2013 -0300

    [media] DT: export of_get_next_parent() for use by modules: fix modular V4L2
    
    Currently modular V4L2 build with enabled OF is broken dur to the
    of_get_next_parent() function being unavailable to modules. Export it to
    fix the build.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 321d3ef05006..1733081eb873 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -382,6 +382,7 @@ struct device_node *of_get_next_parent(struct device_node *node)
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 	return parent;
 }
+EXPORT_SYMBOL(of_get_next_parent);
 
 /**
  *	of_get_next_child - Iterate a node childs

commit b855f16b05a697ac1863adabe99bfba56e6d3199
Author: Tang Yuantian <yuantian.tang@freescale.com>
Date:   Wed Apr 10 11:36:39 2013 +0800

    of/base: release the node correctly in of_parse_phandle_with_args()
    
    Call of_node_put() only when the out_args is NULL on success,
    or the node's reference count will not be correct because the caller
    will call of_node_put() again.
    
    Signed-off-by: Tang Yuantian <Yuantian.Tang@freescale.com>
    [grant.likely: tightened up the patch]
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 321d3ef05006..e77e71989e81 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1166,11 +1166,11 @@ static int __of_parse_phandle_with_args(const struct device_node *np,
 				out_args->args_count = count;
 				for (i = 0; i < count; i++)
 					out_args->args[i] = be32_to_cpup(list++);
+			} else {
+				of_node_put(node);
 			}
 
 			/* Found it! return success */
-			if (node)
-				of_node_put(node);
 			return 0;
 		}
 

commit daeec1f083e02c9ee235e29d2cb28d7b9e81d899
Author: Tony Prisk <linux@prisktech.co.nz>
Date:   Wed Apr 3 17:57:11 2013 +1300

    of: Remove duplicated code for validating property and value
    
    Several functions in of/base.c have the same code duplicated for
    finding and validating a property and value.
    
    struct property *prop = of_find_property(np, propname, NULL);
    if (!prop)
            return -EINVAL;
    if (!prop->value)
            return -ENODATA;
    if (<some length> > prop->length)
            return -EOVERFLOW;
    
    This patch adds of_find_property_value_of_size() which performs the
    equivalent of the above code and removes the instances where it was
    duplicated in several functions.
    
    Reported-by: Rob Herring <robherring2@gmail.com>
    Signed-off-by: Tony Prisk <linux@prisktech.co.nz>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index f6c89ed38db9..c6443de58fb0 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -745,6 +745,34 @@ struct device_node *of_find_node_by_phandle(phandle handle)
 }
 EXPORT_SYMBOL(of_find_node_by_phandle);
 
+/**
+ * of_find_property_value_of_size
+ *
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ * @len:	requested length of property value
+ *
+ * Search for a property in a device node and valid the requested size.
+ * Returns the property value on success, -EINVAL if the property does not
+ *  exist, -ENODATA if property does not have a value, and -EOVERFLOW if the
+ * property data isn't large enough.
+ *
+ */
+static void *of_find_property_value_of_size(const struct device_node *np,
+			const char *propname, u32 len)
+{
+	struct property *prop = of_find_property(np, propname, NULL);
+
+	if (!prop)
+		return ERR_PTR(-EINVAL);
+	if (!prop->value)
+		return ERR_PTR(-ENODATA);
+	if (len > prop->length)
+		return ERR_PTR(-EOVERFLOW);
+
+	return prop->value;
+}
+
 /**
  * of_property_read_u32_index - Find and read a u32 from a multi-value property.
  *
@@ -764,16 +792,13 @@ int of_property_read_u32_index(const struct device_node *np,
 				       const char *propname,
 				       u32 index, u32 *out_value)
 {
-	struct property *prop = of_find_property(np, propname, NULL);
+	const u32 *val = of_find_property_value_of_size(np, propname,
+					((index + 1) * sizeof(*out_value)));
 
-	if (!prop)
-		return -EINVAL;
-	if (!prop->value)
-		return -ENODATA;
-	if (((index + 1) * sizeof(*out_value)) > prop->length)
-		return -EOVERFLOW;
+	if (IS_ERR(val))
+		return PTR_ERR(val);
 
-	*out_value = be32_to_cpup(((__be32 *)prop->value) + index);
+	*out_value = be32_to_cpup(((__be32 *)val) + index);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(of_property_read_u32_index);
@@ -799,17 +824,12 @@ EXPORT_SYMBOL_GPL(of_property_read_u32_index);
 int of_property_read_u8_array(const struct device_node *np,
 			const char *propname, u8 *out_values, size_t sz)
 {
-	struct property *prop = of_find_property(np, propname, NULL);
-	const u8 *val;
+	const u8 *val = of_find_property_value_of_size(np, propname,
+						(sz * sizeof(*out_values)));
 
-	if (!prop)
-		return -EINVAL;
-	if (!prop->value)
-		return -ENODATA;
-	if ((sz * sizeof(*out_values)) > prop->length)
-		return -EOVERFLOW;
+	if (IS_ERR(val))
+		return PTR_ERR(val);
 
-	val = prop->value;
 	while (sz--)
 		*out_values++ = *val++;
 	return 0;
@@ -837,17 +857,12 @@ EXPORT_SYMBOL_GPL(of_property_read_u8_array);
 int of_property_read_u16_array(const struct device_node *np,
 			const char *propname, u16 *out_values, size_t sz)
 {
-	struct property *prop = of_find_property(np, propname, NULL);
-	const __be16 *val;
+	const __be16 *val = of_find_property_value_of_size(np, propname,
+						(sz * sizeof(*out_values)));
 
-	if (!prop)
-		return -EINVAL;
-	if (!prop->value)
-		return -ENODATA;
-	if ((sz * sizeof(*out_values)) > prop->length)
-		return -EOVERFLOW;
+	if (IS_ERR(val))
+		return PTR_ERR(val);
 
-	val = prop->value;
 	while (sz--)
 		*out_values++ = be16_to_cpup(val++);
 	return 0;
@@ -874,17 +889,12 @@ int of_property_read_u32_array(const struct device_node *np,
 			       const char *propname, u32 *out_values,
 			       size_t sz)
 {
-	struct property *prop = of_find_property(np, propname, NULL);
-	const __be32 *val;
+	const __be32 *val = of_find_property_value_of_size(np, propname,
+						(sz * sizeof(*out_values)));
 
-	if (!prop)
-		return -EINVAL;
-	if (!prop->value)
-		return -ENODATA;
-	if ((sz * sizeof(*out_values)) > prop->length)
-		return -EOVERFLOW;
+	if (IS_ERR(val))
+		return PTR_ERR(val);
 
-	val = prop->value;
 	while (sz--)
 		*out_values++ = be32_to_cpup(val++);
 	return 0;
@@ -907,15 +917,13 @@ EXPORT_SYMBOL_GPL(of_property_read_u32_array);
 int of_property_read_u64(const struct device_node *np, const char *propname,
 			 u64 *out_value)
 {
-	struct property *prop = of_find_property(np, propname, NULL);
+	const __be32 *val = of_find_property_value_of_size(np, propname,
+						sizeof(*out_value));
 
-	if (!prop)
-		return -EINVAL;
-	if (!prop->value)
-		return -ENODATA;
-	if (sizeof(*out_value) > prop->length)
-		return -EOVERFLOW;
-	*out_value = of_read_number(prop->value, 2);
+	if (IS_ERR(val))
+		return PTR_ERR(val);
+
+	*out_value = of_read_number(val, 2);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(of_property_read_u64);

commit 3daf37260e965aa4bb060db99c2ed10b28109e04
Author: Tony Prisk <linux@prisktech.co.nz>
Date:   Sat Mar 23 17:02:15 2013 +1300

    of: Add support for reading a u32 from a multi-value property.
    
    This patch adds an of_property_read_u32_index() function to allow
    reading a single indexed u32 value from a property containing multiple
    u32 values.
    
    Signed-off-by: Tony Prisk <linux@prisktech.co.nz>
    Reviewed-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Rob Herring <robherring2@gmail.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 321d3ef05006..f6c89ed38db9 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -745,6 +745,39 @@ struct device_node *of_find_node_by_phandle(phandle handle)
 }
 EXPORT_SYMBOL(of_find_node_by_phandle);
 
+/**
+ * of_property_read_u32_index - Find and read a u32 from a multi-value property.
+ *
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ * @index:	index of the u32 in the list of values
+ * @out_value:	pointer to return value, modified only if no error.
+ *
+ * Search for a property in a device node and read nth 32-bit value from
+ * it. Returns 0 on success, -EINVAL if the property does not exist,
+ * -ENODATA if property does not have a value, and -EOVERFLOW if the
+ * property data isn't large enough.
+ *
+ * The out_value is modified only if a valid u32 value can be decoded.
+ */
+int of_property_read_u32_index(const struct device_node *np,
+				       const char *propname,
+				       u32 index, u32 *out_value)
+{
+	struct property *prop = of_find_property(np, propname, NULL);
+
+	if (!prop)
+		return -EINVAL;
+	if (!prop->value)
+		return -ENODATA;
+	if (((index + 1) * sizeof(*out_value)) > prop->length)
+		return -EOVERFLOW;
+
+	*out_value = be32_to_cpup(((__be32 *)prop->value) + index);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(of_property_read_u32_index);
+
 /**
  * of_property_read_u8_array - Find and read an array of u8 from a property.
  *

commit bd69f73f2c81eed9a398708b8c4bb3409ba1b0f9
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Sun Feb 10 22:57:21 2013 +0000

    of: Create function for counting number of phandles in a property
    
    This patch creates of_count_phandle_with_args(), a new function for
    counting the number of phandle+argument tuples in a given property. This
    is better than the existing method of parsing each phandle individually
    until parsing fails which is a horribly slow way to do the count.
    
    Tested on ARM using the selftest code.
    
    v3: - Rebased on top of selftest code cleanup patch
    v2: - fix bug where of_parse_phandle_with_args() could behave like _count_.
        - made of_gpio_named_count() into a static inline regardless of CONFIG_OF_GPIO
    
    Tested-by: Andreas Larsson <andreas@gaisler.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index c5572cb87a88..321d3ef05006 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1091,9 +1091,10 @@ EXPORT_SYMBOL(of_parse_phandle);
  * To get a device_node of the `node2' node you may call this:
  * of_parse_phandle_with_args(node3, "list", "#list-cells", 1, &args);
  */
-int of_parse_phandle_with_args(const struct device_node *np, const char *list_name,
-				const char *cells_name, int index,
-				struct of_phandle_args *out_args)
+static int __of_parse_phandle_with_args(const struct device_node *np,
+					const char *list_name,
+					const char *cells_name, int index,
+					struct of_phandle_args *out_args)
 {
 	const __be32 *list, *list_end;
 	int rc = 0, size, cur_index = 0;
@@ -1183,15 +1184,47 @@ int of_parse_phandle_with_args(const struct device_node *np, const char *list_na
 	 * Unlock node before returning result; will be one of:
 	 * -ENOENT : index is for empty phandle
 	 * -EINVAL : parsing error on data
+	 * [1..n]  : Number of phandle (count mode; when index = -1)
 	 */
-	rc = -ENOENT;
+	rc = index < 0 ? cur_index : -ENOENT;
  err:
 	if (node)
 		of_node_put(node);
 	return rc;
 }
+
+int of_parse_phandle_with_args(const struct device_node *np, const char *list_name,
+				const char *cells_name, int index,
+				struct of_phandle_args *out_args)
+{
+	if (index < 0)
+		return -EINVAL;
+	return __of_parse_phandle_with_args(np, list_name, cells_name, index, out_args);
+}
 EXPORT_SYMBOL(of_parse_phandle_with_args);
 
+/**
+ * of_count_phandle_with_args() - Find the number of phandles references in a property
+ * @np:		pointer to a device tree node containing a list
+ * @list_name:	property name that contains a list
+ * @cells_name:	property name that specifies phandles' arguments count
+ *
+ * Returns the number of phandle + argument tuples within a property. It
+ * is a typical pattern to encode a list of phandle and variable
+ * arguments into a single property. The number of arguments is encoded
+ * by a property in the phandle-target node. For example, a gpios
+ * property would contain a list of GPIO specifies consisting of a
+ * phandle and 1 or more arguments. The number of arguments are
+ * determined by the #gpio-cells property in the node pointed to by the
+ * phandle.
+ */
+int of_count_phandle_with_args(const struct device_node *np, const char *list_name,
+				const char *cells_name)
+{
+	return __of_parse_phandle_with_args(np, list_name, cells_name, -1, NULL);
+}
+EXPORT_SYMBOL(of_count_phandle_with_args);
+
 #if defined(CONFIG_OF_DYNAMIC)
 static int of_property_notify(int action, struct device_node *np,
 			      struct property *prop)

commit 23ce04c0734e33b1042273b0ed11a8e4f7f988ca
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Feb 12 21:21:49 2013 +0000

    of/base: Clean up exit paths for of_parse_phandle_with_args()
    
    Some of the exit paths were not correctly releasing the node. Fix it by
    creating an 'err' label for collecting the error paths and releasing the
    node.
    
    Cc: Rob Herring <rob.herring@calxeda.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index f7a87ce1b480..c5572cb87a88 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1096,7 +1096,7 @@ int of_parse_phandle_with_args(const struct device_node *np, const char *list_na
 				struct of_phandle_args *out_args)
 {
 	const __be32 *list, *list_end;
-	int size, cur_index = 0;
+	int rc = 0, size, cur_index = 0;
 	uint32_t count = 0;
 	struct device_node *node = NULL;
 	phandle phandle;
@@ -1109,6 +1109,7 @@ int of_parse_phandle_with_args(const struct device_node *np, const char *list_na
 
 	/* Loop over the phandles until all the requested entry is found */
 	while (list < list_end) {
+		rc = -EINVAL;
 		count = 0;
 
 		/*
@@ -1125,13 +1126,13 @@ int of_parse_phandle_with_args(const struct device_node *np, const char *list_na
 			if (!node) {
 				pr_err("%s: could not find phandle\n",
 					 np->full_name);
-				break;
+				goto err;
 			}
 			if (of_property_read_u32(node, cells_name, &count)) {
 				pr_err("%s: could not get %s for %s\n",
 					 np->full_name, cells_name,
 					 node->full_name);
-				break;
+				goto err;
 			}
 
 			/*
@@ -1141,7 +1142,7 @@ int of_parse_phandle_with_args(const struct device_node *np, const char *list_na
 			if (list + count > list_end) {
 				pr_err("%s: arguments longer than property\n",
 					 np->full_name);
-				break;
+				goto err;
 			}
 		}
 
@@ -1151,9 +1152,10 @@ int of_parse_phandle_with_args(const struct device_node *np, const char *list_na
 		 * index matches, then fill the out_args structure and return,
 		 * or return -ENOENT for an empty entry.
 		 */
+		rc = -ENOENT;
 		if (cur_index == index) {
 			if (!phandle)
-				return -ENOENT;
+				goto err;
 
 			if (out_args) {
 				int i;
@@ -1164,6 +1166,10 @@ int of_parse_phandle_with_args(const struct device_node *np, const char *list_na
 				for (i = 0; i < count; i++)
 					out_args->args[i] = be32_to_cpup(list++);
 			}
+
+			/* Found it! return success */
+			if (node)
+				of_node_put(node);
 			return 0;
 		}
 
@@ -1173,10 +1179,16 @@ int of_parse_phandle_with_args(const struct device_node *np, const char *list_na
 		cur_index++;
 	}
 
-	/* Loop exited without finding a valid entry; return an error */
+	/*
+	 * Unlock node before returning result; will be one of:
+	 * -ENOENT : index is for empty phandle
+	 * -EINVAL : parsing error on data
+	 */
+	rc = -ENOENT;
+ err:
 	if (node)
 		of_node_put(node);
-	return -EINVAL;
+	return rc;
 }
 EXPORT_SYMBOL(of_parse_phandle_with_args);
 

commit c31a0c052205e3ec24efc3fe18ef70c3e913f2d4
Author: Stephen Warren <swarren@nvidia.com>
Date:   Mon Feb 11 14:15:32 2013 -0700

    of: fix recursive locking in of_get_next_available_child()
    
    of_get_next_available_child() acquires devtree_lock, then calls
    of_device_is_available() which calls of_get_property() which calls
    of_find_property() which tries to re-acquire devtree_lock, thus causing
    deadlock.
    
    To avoid this, create a new __of_device_is_available() which calls
    __of_get_property() instead, which calls __of_find_property(), which
    does not take the lock,. Update of_get_next_available_child() to call
    the new __of_device_is_available() since it already owns the lock.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index e8d65aff8639..f7a87ce1b480 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -290,19 +290,19 @@ int of_machine_is_compatible(const char *compat)
 EXPORT_SYMBOL(of_machine_is_compatible);
 
 /**
- *  of_device_is_available - check if a device is available for use
+ *  __of_device_is_available - check if a device is available for use
  *
- *  @device: Node to check for availability
+ *  @device: Node to check for availability, with locks already held
  *
  *  Returns 1 if the status property is absent or set to "okay" or "ok",
  *  0 otherwise
  */
-int of_device_is_available(const struct device_node *device)
+static int __of_device_is_available(const struct device_node *device)
 {
 	const char *status;
 	int statlen;
 
-	status = of_get_property(device, "status", &statlen);
+	status = __of_get_property(device, "status", &statlen);
 	if (status == NULL)
 		return 1;
 
@@ -313,6 +313,26 @@ int of_device_is_available(const struct device_node *device)
 
 	return 0;
 }
+
+/**
+ *  of_device_is_available - check if a device is available for use
+ *
+ *  @device: Node to check for availability
+ *
+ *  Returns 1 if the status property is absent or set to "okay" or "ok",
+ *  0 otherwise
+ */
+int of_device_is_available(const struct device_node *device)
+{
+	unsigned long flags;
+	int res;
+
+	raw_spin_lock_irqsave(&devtree_lock, flags);
+	res = __of_device_is_available(device);
+	raw_spin_unlock_irqrestore(&devtree_lock, flags);
+	return res;
+
+}
 EXPORT_SYMBOL(of_device_is_available);
 
 /**
@@ -404,7 +424,7 @@ struct device_node *of_get_next_available_child(const struct device_node *node,
 	raw_spin_lock(&devtree_lock);
 	next = prev ? prev->sibling : node->child;
 	for (; next; next = next->sibling) {
-		if (!of_device_is_available(next))
+		if (!__of_device_is_available(next))
 			continue;
 		if (of_node_get(next))
 			break;

commit bfc4a58986ba3934bb256ef3567aeeab262aa959
Merge: 09495dda6a62 1421954bf9b9
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Wed Feb 13 09:59:13 2013 +0000

    Merge branch 'for-next' from git://sources.calxeda.com/kernel/linux.git
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

commit d6d3c4e656513dcea61ce900f0ecb9ca820ee7cd
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Feb 6 15:30:56 2013 -0500

    OF: convert devtree lock from rw_lock to raw spinlock
    
    With the locking cleanup in place (from "OF: Fixup resursive
    locking code paths"), we can now do the conversion from the
    rw_lock to a raw spinlock as required for preempt-rt.
    
    The previous cleanup and this conversion were originally
    separate since they predated when mainline got raw spinlock (in
    commit c2f21ce2e31286a "locking: Implement new raw_spinlock").
    
    So, at that point in time, the cleanup was considered plausible
    for mainline, but not this conversion.  In any case, we've kept
    them separate as it makes for easier review and better bisection.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [PG: taken from preempt-rt, update subject & add a commit log]
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 16ee7a08e044..f86be5594a15 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -55,7 +55,7 @@ static DEFINE_MUTEX(of_aliases_mutex);
 /* use when traversing tree through the allnext, child, sibling,
  * or parent members of struct device_node.
  */
-DEFINE_RWLOCK(devtree_lock);
+DEFINE_RAW_SPINLOCK(devtree_lock);
 
 int of_n_addr_cells(struct device_node *np)
 {
@@ -188,10 +188,11 @@ struct property *of_find_property(const struct device_node *np,
 				  int *lenp)
 {
 	struct property *pp;
+	unsigned long flags;
 
-	read_lock(&devtree_lock);
+	raw_spin_lock_irqsave(&devtree_lock, flags);
 	pp = __of_find_property(np, name, lenp);
-	read_unlock(&devtree_lock);
+	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 
 	return pp;
 }
@@ -209,13 +210,13 @@ struct device_node *of_find_all_nodes(struct device_node *prev)
 {
 	struct device_node *np;
 
-	read_lock(&devtree_lock);
+	raw_spin_lock(&devtree_lock);
 	np = prev ? prev->allnext : of_allnodes;
 	for (; np != NULL; np = np->allnext)
 		if (of_node_get(np))
 			break;
 	of_node_put(prev);
-	read_unlock(&devtree_lock);
+	raw_spin_unlock(&devtree_lock);
 	return np;
 }
 EXPORT_SYMBOL(of_find_all_nodes);
@@ -274,11 +275,12 @@ static int __of_device_is_compatible(const struct device_node *device,
 int of_device_is_compatible(const struct device_node *device,
 		const char *compat)
 {
+	unsigned long flags;
 	int res;
 
-	read_lock(&devtree_lock);
+	raw_spin_lock_irqsave(&devtree_lock, flags);
 	res = __of_device_is_compatible(device, compat);
-	read_unlock(&devtree_lock);
+	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 	return res;
 }
 EXPORT_SYMBOL(of_device_is_compatible);
@@ -340,13 +342,14 @@ EXPORT_SYMBOL(of_device_is_available);
 struct device_node *of_get_parent(const struct device_node *node)
 {
 	struct device_node *np;
+	unsigned long flags;
 
 	if (!node)
 		return NULL;
 
-	read_lock(&devtree_lock);
+	raw_spin_lock_irqsave(&devtree_lock, flags);
 	np = of_node_get(node->parent);
-	read_unlock(&devtree_lock);
+	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 	return np;
 }
 EXPORT_SYMBOL(of_get_parent);
@@ -365,14 +368,15 @@ EXPORT_SYMBOL(of_get_parent);
 struct device_node *of_get_next_parent(struct device_node *node)
 {
 	struct device_node *parent;
+	unsigned long flags;
 
 	if (!node)
 		return NULL;
 
-	read_lock(&devtree_lock);
+	raw_spin_lock_irqsave(&devtree_lock, flags);
 	parent = of_node_get(node->parent);
 	of_node_put(node);
-	read_unlock(&devtree_lock);
+	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 	return parent;
 }
 
@@ -388,14 +392,15 @@ struct device_node *of_get_next_child(const struct device_node *node,
 	struct device_node *prev)
 {
 	struct device_node *next;
+	unsigned long flags;
 
-	read_lock(&devtree_lock);
+	raw_spin_lock_irqsave(&devtree_lock, flags);
 	next = prev ? prev->sibling : node->child;
 	for (; next; next = next->sibling)
 		if (of_node_get(next))
 			break;
 	of_node_put(prev);
-	read_unlock(&devtree_lock);
+	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 	return next;
 }
 EXPORT_SYMBOL(of_get_next_child);
@@ -413,7 +418,7 @@ struct device_node *of_get_next_available_child(const struct device_node *node,
 {
 	struct device_node *next;
 
-	read_lock(&devtree_lock);
+	raw_spin_lock(&devtree_lock);
 	next = prev ? prev->sibling : node->child;
 	for (; next; next = next->sibling) {
 		if (!of_device_is_available(next))
@@ -422,7 +427,7 @@ struct device_node *of_get_next_available_child(const struct device_node *node,
 			break;
 	}
 	of_node_put(prev);
-	read_unlock(&devtree_lock);
+	raw_spin_unlock(&devtree_lock);
 	return next;
 }
 EXPORT_SYMBOL(of_get_next_available_child);
@@ -460,14 +465,15 @@ EXPORT_SYMBOL(of_get_child_by_name);
 struct device_node *of_find_node_by_path(const char *path)
 {
 	struct device_node *np = of_allnodes;
+	unsigned long flags;
 
-	read_lock(&devtree_lock);
+	raw_spin_lock_irqsave(&devtree_lock, flags);
 	for (; np; np = np->allnext) {
 		if (np->full_name && (of_node_cmp(np->full_name, path) == 0)
 		    && of_node_get(np))
 			break;
 	}
-	read_unlock(&devtree_lock);
+	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 	return np;
 }
 EXPORT_SYMBOL(of_find_node_by_path);
@@ -487,15 +493,16 @@ struct device_node *of_find_node_by_name(struct device_node *from,
 	const char *name)
 {
 	struct device_node *np;
+	unsigned long flags;
 
-	read_lock(&devtree_lock);
+	raw_spin_lock_irqsave(&devtree_lock, flags);
 	np = from ? from->allnext : of_allnodes;
 	for (; np; np = np->allnext)
 		if (np->name && (of_node_cmp(np->name, name) == 0)
 		    && of_node_get(np))
 			break;
 	of_node_put(from);
-	read_unlock(&devtree_lock);
+	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 	return np;
 }
 EXPORT_SYMBOL(of_find_node_by_name);
@@ -516,15 +523,16 @@ struct device_node *of_find_node_by_type(struct device_node *from,
 	const char *type)
 {
 	struct device_node *np;
+	unsigned long flags;
 
-	read_lock(&devtree_lock);
+	raw_spin_lock_irqsave(&devtree_lock, flags);
 	np = from ? from->allnext : of_allnodes;
 	for (; np; np = np->allnext)
 		if (np->type && (of_node_cmp(np->type, type) == 0)
 		    && of_node_get(np))
 			break;
 	of_node_put(from);
-	read_unlock(&devtree_lock);
+	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 	return np;
 }
 EXPORT_SYMBOL(of_find_node_by_type);
@@ -547,8 +555,9 @@ struct device_node *of_find_compatible_node(struct device_node *from,
 	const char *type, const char *compatible)
 {
 	struct device_node *np;
+	unsigned long flags;
 
-	read_lock(&devtree_lock);
+	raw_spin_lock_irqsave(&devtree_lock, flags);
 	np = from ? from->allnext : of_allnodes;
 	for (; np; np = np->allnext) {
 		if (type
@@ -559,7 +568,7 @@ struct device_node *of_find_compatible_node(struct device_node *from,
 			break;
 	}
 	of_node_put(from);
-	read_unlock(&devtree_lock);
+	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 	return np;
 }
 EXPORT_SYMBOL(of_find_compatible_node);
@@ -581,8 +590,9 @@ struct device_node *of_find_node_with_property(struct device_node *from,
 {
 	struct device_node *np;
 	struct property *pp;
+	unsigned long flags;
 
-	read_lock(&devtree_lock);
+	raw_spin_lock_irqsave(&devtree_lock, flags);
 	np = from ? from->allnext : of_allnodes;
 	for (; np; np = np->allnext) {
 		for (pp = np->properties; pp; pp = pp->next) {
@@ -594,7 +604,7 @@ struct device_node *of_find_node_with_property(struct device_node *from,
 	}
 out:
 	of_node_put(from);
-	read_unlock(&devtree_lock);
+	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 	return np;
 }
 EXPORT_SYMBOL(of_find_node_with_property);
@@ -635,10 +645,11 @@ const struct of_device_id *of_match_node(const struct of_device_id *matches,
 					 const struct device_node *node)
 {
 	const struct of_device_id *match;
+	unsigned long flags;
 
-	read_lock(&devtree_lock);
+	raw_spin_lock_irqsave(&devtree_lock, flags);
 	match = __of_match_node(matches, node);
-	read_unlock(&devtree_lock);
+	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 	return match;
 }
 EXPORT_SYMBOL(of_match_node);
@@ -662,11 +673,12 @@ struct device_node *of_find_matching_node_and_match(struct device_node *from,
 {
 	struct device_node *np;
 	const struct of_device_id *m;
+	unsigned long flags;
 
 	if (match)
 		*match = NULL;
 
-	read_lock(&devtree_lock);
+	raw_spin_lock_irqsave(&devtree_lock, flags);
 	np = from ? from->allnext : of_allnodes;
 	for (; np; np = np->allnext) {
 		m = __of_match_node(matches, np);
@@ -677,7 +689,7 @@ struct device_node *of_find_matching_node_and_match(struct device_node *from,
 		}
 	}
 	of_node_put(from);
-	read_unlock(&devtree_lock);
+	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 	return np;
 }
 EXPORT_SYMBOL(of_find_matching_node_and_match);
@@ -720,12 +732,12 @@ struct device_node *of_find_node_by_phandle(phandle handle)
 {
 	struct device_node *np;
 
-	read_lock(&devtree_lock);
+	raw_spin_lock(&devtree_lock);
 	for (np = of_allnodes; np; np = np->allnext)
 		if (np->phandle == handle)
 			break;
 	of_node_get(np);
-	read_unlock(&devtree_lock);
+	raw_spin_unlock(&devtree_lock);
 	return np;
 }
 EXPORT_SYMBOL(of_find_node_by_phandle);
@@ -1197,18 +1209,18 @@ int of_add_property(struct device_node *np, struct property *prop)
 		return rc;
 
 	prop->next = NULL;
-	write_lock_irqsave(&devtree_lock, flags);
+	raw_spin_lock_irqsave(&devtree_lock, flags);
 	next = &np->properties;
 	while (*next) {
 		if (strcmp(prop->name, (*next)->name) == 0) {
 			/* duplicate ! don't insert it */
-			write_unlock_irqrestore(&devtree_lock, flags);
+			raw_spin_unlock_irqrestore(&devtree_lock, flags);
 			return -1;
 		}
 		next = &(*next)->next;
 	}
 	*next = prop;
-	write_unlock_irqrestore(&devtree_lock, flags);
+	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 
 #ifdef CONFIG_PROC_DEVICETREE
 	/* try to add to proc as well if it was initialized */
@@ -1238,7 +1250,7 @@ int of_remove_property(struct device_node *np, struct property *prop)
 	if (rc)
 		return rc;
 
-	write_lock_irqsave(&devtree_lock, flags);
+	raw_spin_lock_irqsave(&devtree_lock, flags);
 	next = &np->properties;
 	while (*next) {
 		if (*next == prop) {
@@ -1251,7 +1263,7 @@ int of_remove_property(struct device_node *np, struct property *prop)
 		}
 		next = &(*next)->next;
 	}
-	write_unlock_irqrestore(&devtree_lock, flags);
+	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 
 	if (!found)
 		return -ENODEV;
@@ -1291,7 +1303,7 @@ int of_update_property(struct device_node *np, struct property *newprop)
 	if (!oldprop)
 		return of_add_property(np, newprop);
 
-	write_lock_irqsave(&devtree_lock, flags);
+	raw_spin_lock_irqsave(&devtree_lock, flags);
 	next = &np->properties;
 	while (*next) {
 		if (*next == oldprop) {
@@ -1305,7 +1317,7 @@ int of_update_property(struct device_node *np, struct property *newprop)
 		}
 		next = &(*next)->next;
 	}
-	write_unlock_irqrestore(&devtree_lock, flags);
+	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 
 	if (!found)
 		return -ENODEV;
@@ -1378,12 +1390,12 @@ int of_attach_node(struct device_node *np)
 	if (rc)
 		return rc;
 
-	write_lock_irqsave(&devtree_lock, flags);
+	raw_spin_lock_irqsave(&devtree_lock, flags);
 	np->sibling = np->parent->child;
 	np->allnext = of_allnodes;
 	np->parent->child = np;
 	of_allnodes = np;
-	write_unlock_irqrestore(&devtree_lock, flags);
+	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 
 	of_add_proc_dt_entry(np);
 	return 0;
@@ -1426,17 +1438,17 @@ int of_detach_node(struct device_node *np)
 	if (rc)
 		return rc;
 
-	write_lock_irqsave(&devtree_lock, flags);
+	raw_spin_lock_irqsave(&devtree_lock, flags);
 
 	if (of_node_check_flag(np, OF_DETACHED)) {
 		/* someone already detached it */
-		write_unlock_irqrestore(&devtree_lock, flags);
+		raw_spin_unlock_irqrestore(&devtree_lock, flags);
 		return rc;
 	}
 
 	parent = np->parent;
 	if (!parent) {
-		write_unlock_irqrestore(&devtree_lock, flags);
+		raw_spin_unlock_irqrestore(&devtree_lock, flags);
 		return rc;
 	}
 
@@ -1463,7 +1475,7 @@ int of_detach_node(struct device_node *np)
 	}
 
 	of_node_set_flag(np, OF_DETACHED);
-	write_unlock_irqrestore(&devtree_lock, flags);
+	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 
 	of_remove_proc_dt_entry(np);
 	return rc;

commit d2f4ec1026fecbef9b72cc899a626516ef3f265f
Merge: 12514aa0e6c6 eb7ccb8184ab
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Feb 8 09:23:33 2013 +0000

    Merge branch 'robherring/for-next' from git://sources.calxeda.com/kernel/linux.git
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

commit ced4eec900850627409d7ff566b009471162b56b
Author: Stepan Moskovchenko <stepanm@codeaurora.org>
Date:   Thu Dec 6 14:55:41 2012 -0800

    of: Output devicetree alias names in uevent
    
    In some situations, userspace may want to resolve a
    device by function and logical number (ie, "serial0")
    rather than by the base address or full device path. Being
    able to resolve a device by alias frees userspace from the
    burden of otherwise having to maintain a mapping between
    device addresses and their logical assignments on each
    platform when multiple instances of the same hardware block
    are present in the system.
    
    Although the uevent device attribute contains devicetree
    compatible information and the full device path, the uevent
    does not list the alises that may have been defined for the
    device.
    
    Signed-off-by: Stepan Moskovchenko <stepanm@codeaurora.org>
    [grant.likely: Removed OF_ALIAS_N field; I don't think it's needed]
    [grant.likely: Added #ifndef _LINUX_OF_PRIVATE_H wrapper]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 2390ddb22d60..d1bb50719ed7 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -24,33 +24,16 @@
 #include <linux/slab.h>
 #include <linux/proc_fs.h>
 
-/**
- * struct alias_prop - Alias property in 'aliases' node
- * @link:	List node to link the structure in aliases_lookup list
- * @alias:	Alias property name
- * @np:		Pointer to device_node that the alias stands for
- * @id:		Index value from end of alias name
- * @stem:	Alias string without the index
- *
- * The structure represents one alias property of 'aliases' node as
- * an entry in aliases_lookup list.
- */
-struct alias_prop {
-	struct list_head link;
-	const char *alias;
-	struct device_node *np;
-	int id;
-	char stem[0];
-};
+#include "of_private.h"
 
-static LIST_HEAD(aliases_lookup);
+LIST_HEAD(aliases_lookup);
 
 struct device_node *of_allnodes;
 EXPORT_SYMBOL(of_allnodes);
 struct device_node *of_chosen;
 struct device_node *of_aliases;
 
-static DEFINE_MUTEX(of_aliases_mutex);
+DEFINE_MUTEX(of_aliases_mutex);
 
 /* use when traversing tree through the allnext, child, sibling,
  * or parent members of struct device_node.

commit 28d0e36bf96863df1195f8f7b9fd559142873389
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jan 25 13:21:47 2013 -0500

    OF: Fixup resursive locking code paths
    
    There is no real reason to use a rwlock for devtree_lock. It even
    could be a mutex, but unfortunately it's locked from cpu hotplug
    paths which can't schedule :(
    
    So it needs to become a raw lock on rt as well.  The devtree_lock would
    be the only user of a raw_rw_lock, so we are better off cleaning up the
    recursive locking paths which allows us to convert devtree_lock to a
    read_lock.
    
    Here we do the standard thing of introducing __foo() as the "raw"
    version of foo(), so that we can take better control of the locking.
    The "raw" versions are not exported and are for internal use within
    the file itself.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 960ae5bf3ddc..16ee7a08e044 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -164,16 +164,14 @@ void of_node_put(struct device_node *node)
 EXPORT_SYMBOL(of_node_put);
 #endif /* CONFIG_OF_DYNAMIC */
 
-struct property *of_find_property(const struct device_node *np,
-				  const char *name,
-				  int *lenp)
+static struct property *__of_find_property(const struct device_node *np,
+					   const char *name, int *lenp)
 {
 	struct property *pp;
 
 	if (!np)
 		return NULL;
 
-	read_lock(&devtree_lock);
 	for (pp = np->properties; pp; pp = pp->next) {
 		if (of_prop_cmp(pp->name, name) == 0) {
 			if (lenp)
@@ -181,6 +179,18 @@ struct property *of_find_property(const struct device_node *np,
 			break;
 		}
 	}
+
+	return pp;
+}
+
+struct property *of_find_property(const struct device_node *np,
+				  const char *name,
+				  int *lenp)
+{
+	struct property *pp;
+
+	read_lock(&devtree_lock);
+	pp = __of_find_property(np, name, lenp);
 	read_unlock(&devtree_lock);
 
 	return pp;
@@ -210,12 +220,24 @@ struct device_node *of_find_all_nodes(struct device_node *prev)
 }
 EXPORT_SYMBOL(of_find_all_nodes);
 
+/*
+ * Find a property with a given name for a given node
+ * and return the value.
+ */
+static const void *__of_get_property(const struct device_node *np,
+				     const char *name, int *lenp)
+{
+	struct property *pp = __of_find_property(np, name, lenp);
+
+	return pp ? pp->value : NULL;
+}
+
 /*
  * Find a property with a given name for a given node
  * and return the value.
  */
 const void *of_get_property(const struct device_node *np, const char *name,
-			 int *lenp)
+			    int *lenp)
 {
 	struct property *pp = of_find_property(np, name, lenp);
 
@@ -226,13 +248,13 @@ EXPORT_SYMBOL(of_get_property);
 /** Checks if the given "compat" string matches one of the strings in
  * the device's "compatible" property
  */
-int of_device_is_compatible(const struct device_node *device,
-		const char *compat)
+static int __of_device_is_compatible(const struct device_node *device,
+				     const char *compat)
 {
 	const char* cp;
 	int cplen, l;
 
-	cp = of_get_property(device, "compatible", &cplen);
+	cp = __of_get_property(device, "compatible", &cplen);
 	if (cp == NULL)
 		return 0;
 	while (cplen > 0) {
@@ -245,6 +267,20 @@ int of_device_is_compatible(const struct device_node *device,
 
 	return 0;
 }
+
+/** Checks if the given "compat" string matches one of the strings in
+ * the device's "compatible" property
+ */
+int of_device_is_compatible(const struct device_node *device,
+		const char *compat)
+{
+	int res;
+
+	read_lock(&devtree_lock);
+	res = __of_device_is_compatible(device, compat);
+	read_unlock(&devtree_lock);
+	return res;
+}
 EXPORT_SYMBOL(of_device_is_compatible);
 
 /**
@@ -518,7 +554,8 @@ struct device_node *of_find_compatible_node(struct device_node *from,
 		if (type
 		    && !(np->type && (of_node_cmp(np->type, type) == 0)))
 			continue;
-		if (of_device_is_compatible(np, compatible) && of_node_get(np))
+		if (__of_device_is_compatible(np, compatible) &&
+		    of_node_get(np))
 			break;
 	}
 	of_node_put(from);
@@ -562,15 +599,9 @@ struct device_node *of_find_node_with_property(struct device_node *from,
 }
 EXPORT_SYMBOL(of_find_node_with_property);
 
-/**
- * of_match_node - Tell if an device_node has a matching of_match structure
- *	@matches:	array of of device match structures to search in
- *	@node:		the of device structure to match against
- *
- *	Low level utility function used by device matching.
- */
-const struct of_device_id *of_match_node(const struct of_device_id *matches,
-					 const struct device_node *node)
+static
+const struct of_device_id *__of_match_node(const struct of_device_id *matches,
+					   const struct device_node *node)
 {
 	if (!matches)
 		return NULL;
@@ -584,14 +615,32 @@ const struct of_device_id *of_match_node(const struct of_device_id *matches,
 			match &= node->type
 				&& !strcmp(matches->type, node->type);
 		if (matches->compatible[0])
-			match &= of_device_is_compatible(node,
-						matches->compatible);
+			match &= __of_device_is_compatible(node,
+							   matches->compatible);
 		if (match)
 			return matches;
 		matches++;
 	}
 	return NULL;
 }
+
+/**
+ * of_match_node - Tell if an device_node has a matching of_match structure
+ *	@matches:	array of of device match structures to search in
+ *	@node:		the of device structure to match against
+ *
+ *	Low level utility function used by device matching.
+ */
+const struct of_device_id *of_match_node(const struct of_device_id *matches,
+					 const struct device_node *node)
+{
+	const struct of_device_id *match;
+
+	read_lock(&devtree_lock);
+	match = __of_match_node(matches, node);
+	read_unlock(&devtree_lock);
+	return match;
+}
 EXPORT_SYMBOL(of_match_node);
 
 /**
@@ -620,7 +669,7 @@ struct device_node *of_find_matching_node_and_match(struct device_node *from,
 	read_lock(&devtree_lock);
 	np = from ? from->allnext : of_allnodes;
 	for (; np; np = np->allnext) {
-		m = of_match_node(matches, np);
+		m = __of_match_node(matches, np);
 		if (m && of_node_get(np)) {
 			if (match)
 				*match = m;

commit dc71bcf1b99c265fffdb1e8c60e7933612f3bca7
Author: Thomas Abraham <thomas.abraham@linaro.org>
Date:   Sat Jan 19 10:20:42 2013 -0800

    of: fix incorrect return value of of_find_matching_node_and_match()
    
    The of_find_matching_node_and_match() function incorrectly sets the matched
    entry to 'matches' when the compatible value of a node matches one of the
    possible values. This results in incorrectly selecting the the first entry in
    the 'matches' list as the matched entry. Fix this by noting down the result of
    the call to of_match_node() and setting that as the matched entry.
    
    Signed-off-by: Thomas Abraham <thomas.abraham@linaro.org>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 2390ddb22d60..960ae5bf3ddc 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -612,6 +612,7 @@ struct device_node *of_find_matching_node_and_match(struct device_node *from,
 					const struct of_device_id **match)
 {
 	struct device_node *np;
+	const struct of_device_id *m;
 
 	if (match)
 		*match = NULL;
@@ -619,9 +620,10 @@ struct device_node *of_find_matching_node_and_match(struct device_node *from,
 	read_lock(&devtree_lock);
 	np = from ? from->allnext : of_allnodes;
 	for (; np; np = np->allnext) {
-		if (of_match_node(matches, np) && of_node_get(np)) {
+		m = of_match_node(matches, np);
+		if (m && of_node_get(np)) {
 			if (match)
-				*match = matches;
+				*match = m;
 			break;
 		}
 	}

commit 80c2022e5645a1a789531d13010292c5c18bf1db
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Wed Dec 19 10:45:36 2012 +0000

    of: Fix export of of_find_matching_node_and_match()
    
    Commit 50c8af4cf9, "of: introduce for_each_matching_node_and_match()"
    renamed of_find_matching_node() to of_find_matching_node_and_match() and
    created a new static inline of_find_matching_node() wrapper around the
    new name. However, the change neglected to change the EXPORT_SYMBOL()
    reference causing build errors for modules.
    
    This patch fixes the EXPORT_SYMBOL() statement. Discovered on a PowerPC
    Efika build with the mpc52xx_uart driver being built as a module.
    
    Reported-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index db8d211a0d05..2390ddb22d60 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -629,7 +629,7 @@ struct device_node *of_find_matching_node_and_match(struct device_node *from,
 	read_unlock(&devtree_lock);
 	return np;
 }
-EXPORT_SYMBOL(of_find_matching_node);
+EXPORT_SYMBOL(of_find_matching_node_and_match);
 
 /**
  * of_modalias_node - Lookup appropriate modalias for a device node

commit 16e024f30ce96ef5fa651e2914e19d175a924cab
Merge: c36e0501ee91 376bddd34433
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 18 09:58:09 2012 -0800

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc
    
    Pull powerpc update from Benjamin Herrenschmidt:
     "The main highlight is probably some base POWER8 support.  There's more
      to come such as transactional memory support but that will wait for
      the next one.
    
      Overall it's pretty quiet, or rather I've been pretty poor at picking
      things up from patchwork and reviewing them this time around and Kumar
      no better on the FSL side it seems..."
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc: (73 commits)
      powerpc+of: Rename and fix OF reconfig notifier error inject module
      powerpc: mpc5200: Add a3m071 board support
      powerpc/512x: don't compile any platform DIU code if the DIU is not enabled
      powerpc/mpc52xx: use module_platform_driver macro
      powerpc+of: Export of_reconfig_notifier_[register,unregister]
      powerpc/dma/raidengine: add raidengine device
      powerpc/iommu/fsl: Add PAMU bypass enable register to ccsr_guts struct
      powerpc/mpc85xx: Change spin table to cached memory
      powerpc/fsl-pci: Add PCI controller ATMU PM support
      powerpc/86xx: fsl_pcibios_fixup_bus requires CONFIG_PCI
      drivers/virt: the Freescale hypervisor driver doesn't need to check MSR[GS]
      powerpc/85xx: p1022ds: Use NULL instead of 0 for pointers
      powerpc: Disable relocation on exceptions when kexecing
      powerpc: Enable relocation on during exceptions at boot
      powerpc: Move get_longbusy_msecs into hvcall.h and remove duplicate function
      powerpc: Add wrappers to enable/disable relocation on exceptions
      powerpc: Add set_mode hcall
      powerpc: Setup relocation on exceptions for bare metal systems
      powerpc: Move initial mfspr LPCR out of __init_LPCR
      powerpc: Add relocation on exception vector handlers
      ...

commit 93c667ca2598bd84f1bd3f2fa176af69707699fe
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Mon Dec 10 20:41:30 2012 +0100

    of: *node argument to of_parse_phandle_with_args should be const
    
    The "struct device_node *" argument of of_parse_phandle_with_args() can
    be const. Making this change makes it explicit that the function will
    not modify a node.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    [grant.likely: Resolved conflict with previous patch modifying of_parse_phandle()]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 538e3cfad23e..be846408dbc1 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1025,7 +1025,7 @@ EXPORT_SYMBOL(of_parse_phandle);
  * To get a device_node of the `node2' node you may call this:
  * of_parse_phandle_with_args(node3, "list", "#list-cells", 1, &args);
  */
-int of_parse_phandle_with_args(struct device_node *np, const char *list_name,
+int of_parse_phandle_with_args(const struct device_node *np, const char *list_name,
 				const char *cells_name, int index,
 				struct of_phandle_args *out_args)
 {

commit 465aac6d496aa3e99caaa6868865fb3830f73d80
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Fri Nov 30 10:01:51 2012 +0000

    Fix build when CONFIG_W1_MASTER_GPIO=m b exporting "allnodes"
    
    ERROR: "allnodes" [drivers/w1/masters/w1-gpio.ko] undefined!
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    [grant.likely: allnodes is too generic; rename to of_allnodes]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Ville Syrjala <syrjala@sci.fi>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index c3724110a288..538e3cfad23e 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -45,7 +45,8 @@ struct alias_prop {
 
 static LIST_HEAD(aliases_lookup);
 
-struct device_node *allnodes;
+struct device_node *of_allnodes;
+EXPORT_SYMBOL(of_allnodes);
 struct device_node *of_chosen;
 struct device_node *of_aliases;
 
@@ -199,7 +200,7 @@ struct device_node *of_find_all_nodes(struct device_node *prev)
 	struct device_node *np;
 
 	read_lock(&devtree_lock);
-	np = prev ? prev->allnext : allnodes;
+	np = prev ? prev->allnext : of_allnodes;
 	for (; np != NULL; np = np->allnext)
 		if (of_node_get(np))
 			break;
@@ -422,7 +423,7 @@ EXPORT_SYMBOL(of_get_child_by_name);
  */
 struct device_node *of_find_node_by_path(const char *path)
 {
-	struct device_node *np = allnodes;
+	struct device_node *np = of_allnodes;
 
 	read_lock(&devtree_lock);
 	for (; np; np = np->allnext) {
@@ -452,7 +453,7 @@ struct device_node *of_find_node_by_name(struct device_node *from,
 	struct device_node *np;
 
 	read_lock(&devtree_lock);
-	np = from ? from->allnext : allnodes;
+	np = from ? from->allnext : of_allnodes;
 	for (; np; np = np->allnext)
 		if (np->name && (of_node_cmp(np->name, name) == 0)
 		    && of_node_get(np))
@@ -481,7 +482,7 @@ struct device_node *of_find_node_by_type(struct device_node *from,
 	struct device_node *np;
 
 	read_lock(&devtree_lock);
-	np = from ? from->allnext : allnodes;
+	np = from ? from->allnext : of_allnodes;
 	for (; np; np = np->allnext)
 		if (np->type && (of_node_cmp(np->type, type) == 0)
 		    && of_node_get(np))
@@ -512,7 +513,7 @@ struct device_node *of_find_compatible_node(struct device_node *from,
 	struct device_node *np;
 
 	read_lock(&devtree_lock);
-	np = from ? from->allnext : allnodes;
+	np = from ? from->allnext : of_allnodes;
 	for (; np; np = np->allnext) {
 		if (type
 		    && !(np->type && (of_node_cmp(np->type, type) == 0)))
@@ -545,7 +546,7 @@ struct device_node *of_find_node_with_property(struct device_node *from,
 	struct property *pp;
 
 	read_lock(&devtree_lock);
-	np = from ? from->allnext : allnodes;
+	np = from ? from->allnext : of_allnodes;
 	for (; np; np = np->allnext) {
 		for (pp = np->properties; pp; pp = pp->next) {
 			if (of_prop_cmp(pp->name, prop_name) == 0) {
@@ -616,7 +617,7 @@ struct device_node *of_find_matching_node_and_match(struct device_node *from,
 		*match = NULL;
 
 	read_lock(&devtree_lock);
-	np = from ? from->allnext : allnodes;
+	np = from ? from->allnext : of_allnodes;
 	for (; np; np = np->allnext) {
 		if (of_match_node(matches, np) && of_node_get(np)) {
 			if (match)
@@ -669,7 +670,7 @@ struct device_node *of_find_node_by_phandle(phandle handle)
 	struct device_node *np;
 
 	read_lock(&devtree_lock);
-	for (np = allnodes; np; np = np->allnext)
+	for (np = of_allnodes; np; np = np->allnext)
 		if (np->phandle == handle)
 			break;
 	of_node_get(np);
@@ -1254,9 +1255,9 @@ void of_attach_node(struct device_node *np)
 
 	write_lock_irqsave(&devtree_lock, flags);
 	np->sibling = np->parent->child;
-	np->allnext = allnodes;
+	np->allnext = of_allnodes;
 	np->parent->child = np;
-	allnodes = np;
+	of_allnodes = np;
 	write_unlock_irqrestore(&devtree_lock, flags);
 }
 
@@ -1277,11 +1278,11 @@ void of_detach_node(struct device_node *np)
 	if (!parent)
 		goto out_unlock;
 
-	if (allnodes == np)
-		allnodes = np->allnext;
+	if (of_allnodes == np)
+		of_allnodes = np->allnext;
 	else {
 		struct device_node *prev;
-		for (prev = allnodes;
+		for (prev = of_allnodes;
 		     prev->allnext != np;
 		     prev = prev->allnext)
 			;

commit b8fbdc42c5c5df8ab1f358fe90e3a8a1bdc9ae48
Author: Steffen Trumtrar <s.trumtrar@pengutronix.de>
Date:   Thu Nov 22 12:16:43 2012 +0100

    of: add 'const' for of_parse_phandle parameter *np
    
    The existing function does not change the passed device_node pointer. It is
    only handed to of_get_property which itself takes a const struct device_node.
    
    of_parse_phandle() can therefore take a const pointer as well.
    
    Signed-off-by: Steffen Trumtrar <s.trumtrar@pengutronix.de>
    [grant.likely: drop extraneous whitespace change]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 0ceb26a16050..c3724110a288 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -978,8 +978,8 @@ EXPORT_SYMBOL_GPL(of_property_count_strings);
  * Returns the device_node pointer with refcount incremented.  Use
  * of_node_put() on it when done.
  */
-struct device_node *
-of_parse_phandle(struct device_node *np, const char *phandle_name, int index)
+struct device_node *of_parse_phandle(const struct device_node *np,
+				     const char *phandle_name, int index)
 {
 	const __be32 *phandle;
 	int size;

commit 1a9bd45412665e73c72612b6f744378d860e02a8
Author: Nathan Fontenot <nfont@linux.vnet.ibm.com>
Date:   Wed Nov 28 09:42:26 2012 +0000

    powerpc+of: Export of_reconfig_notifier_[register,unregister]
    
    The of reconfiguration notification chains should be exported for use
    by modules.
    
    Signed-off-by:Nathan Fontenot <nfont@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 02d94c4ea83c..fa40402fe8d5 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1197,11 +1197,13 @@ int of_reconfig_notifier_register(struct notifier_block *nb)
 {
 	return blocking_notifier_chain_register(&of_reconfig_chain, nb);
 }
+EXPORT_SYMBOL_GPL(of_reconfig_notifier_register);
 
 int of_reconfig_notifier_unregister(struct notifier_block *nb)
 {
 	return blocking_notifier_chain_unregister(&of_reconfig_chain, nb);
 }
+EXPORT_SYMBOL_GPL(of_reconfig_notifier_unregister);
 
 int of_reconfig_notify(unsigned long action, void *p)
 {

commit 50c8af4cf98fd97d6779f244215154e4c89699c7
Author: Stephen Warren <swarren@nvidia.com>
Date:   Tue Nov 20 16:12:20 2012 -0700

    of: introduce for_each_matching_node_and_match()
    
    The following pattern of code is tempting:
    
        for_each_matching_node(np, table) {
            match = of_match_node(table, np);
    
    However, this results in iterating over table twice; the second time
    inside of_match_node(). The implementation of for_each_matching_node()
    already found the match, so this is redundant. Invent new function
    of_find_matching_node_and_match() and macro
    for_each_matching_node_and_match() to remove the double iteration,
    thus transforming the above code to:
    
        for_each_matching_node_and_match(np, table, &match)
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index f564e3107b3e..0ceb26a16050 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -594,27 +594,35 @@ const struct of_device_id *of_match_node(const struct of_device_id *matches,
 EXPORT_SYMBOL(of_match_node);
 
 /**
- *	of_find_matching_node - Find a node based on an of_device_id match
- *				table.
+ *	of_find_matching_node_and_match - Find a node based on an of_device_id
+ *					  match table.
  *	@from:		The node to start searching from or NULL, the node
  *			you pass will not be searched, only the next one
  *			will; typically, you pass what the previous call
  *			returned. of_node_put() will be called on it
  *	@matches:	array of of device match structures to search in
+ *	@match		Updated to point at the matches entry which matched
  *
  *	Returns a node pointer with refcount incremented, use
  *	of_node_put() on it when done.
  */
-struct device_node *of_find_matching_node(struct device_node *from,
-					  const struct of_device_id *matches)
+struct device_node *of_find_matching_node_and_match(struct device_node *from,
+					const struct of_device_id *matches,
+					const struct of_device_id **match)
 {
 	struct device_node *np;
 
+	if (match)
+		*match = NULL;
+
 	read_lock(&devtree_lock);
 	np = from ? from->allnext : allnodes;
 	for (; np; np = np->allnext) {
-		if (of_match_node(matches, np) && of_node_get(np))
+		if (of_match_node(matches, np) && of_node_get(np)) {
+			if (match)
+				*match = matches;
 			break;
+		}
 	}
 	of_node_put(from);
 	read_unlock(&devtree_lock);

commit be193249b4178158c0f697cb452b2bbf0cb16361
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Nov 20 10:15:19 2012 +0530

    dt: add helper function to read u8 & u16 variables & arrays
    
    This adds following helper routines:
    - of_property_read_u8_array()
    - of_property_read_u16_array()
    - of_property_read_u8()
    - of_property_read_u16()
    
    This expects arrays from DT to be passed as:
    - u8 array:
            property = /bits/ 8 <0x50 0x60 0x70>;
    - u16 array:
            property = /bits/ 16 <0x5000 0x6000 0x7000>;
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index af3b22ac7627..f564e3107b3e 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -670,6 +670,82 @@ struct device_node *of_find_node_by_phandle(phandle handle)
 }
 EXPORT_SYMBOL(of_find_node_by_phandle);
 
+/**
+ * of_property_read_u8_array - Find and read an array of u8 from a property.
+ *
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ * @out_value:	pointer to return value, modified only if return value is 0.
+ * @sz:		number of array elements to read
+ *
+ * Search for a property in a device node and read 8-bit value(s) from
+ * it. Returns 0 on success, -EINVAL if the property does not exist,
+ * -ENODATA if property does not have a value, and -EOVERFLOW if the
+ * property data isn't large enough.
+ *
+ * dts entry of array should be like:
+ *	property = /bits/ 8 <0x50 0x60 0x70>;
+ *
+ * The out_value is modified only if a valid u8 value can be decoded.
+ */
+int of_property_read_u8_array(const struct device_node *np,
+			const char *propname, u8 *out_values, size_t sz)
+{
+	struct property *prop = of_find_property(np, propname, NULL);
+	const u8 *val;
+
+	if (!prop)
+		return -EINVAL;
+	if (!prop->value)
+		return -ENODATA;
+	if ((sz * sizeof(*out_values)) > prop->length)
+		return -EOVERFLOW;
+
+	val = prop->value;
+	while (sz--)
+		*out_values++ = *val++;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(of_property_read_u8_array);
+
+/**
+ * of_property_read_u16_array - Find and read an array of u16 from a property.
+ *
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ * @out_value:	pointer to return value, modified only if return value is 0.
+ * @sz:		number of array elements to read
+ *
+ * Search for a property in a device node and read 16-bit value(s) from
+ * it. Returns 0 on success, -EINVAL if the property does not exist,
+ * -ENODATA if property does not have a value, and -EOVERFLOW if the
+ * property data isn't large enough.
+ *
+ * dts entry of array should be like:
+ *	property = /bits/ 16 <0x5000 0x6000 0x7000>;
+ *
+ * The out_value is modified only if a valid u16 value can be decoded.
+ */
+int of_property_read_u16_array(const struct device_node *np,
+			const char *propname, u16 *out_values, size_t sz)
+{
+	struct property *prop = of_find_property(np, propname, NULL);
+	const __be16 *val;
+
+	if (!prop)
+		return -EINVAL;
+	if (!prop->value)
+		return -ENODATA;
+	if ((sz * sizeof(*out_values)) > prop->length)
+		return -EOVERFLOW;
+
+	val = prop->value;
+	while (sz--)
+		*out_values++ = be16_to_cpup(val++);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(of_property_read_u16_array);
+
 /**
  * of_property_read_u32_array - Find and read an array of 32 bit integers
  * from a property.
@@ -677,6 +753,7 @@ EXPORT_SYMBOL(of_find_node_by_phandle);
  * @np:		device node from which the property value is to be read.
  * @propname:	name of the property to be searched.
  * @out_value:	pointer to return value, modified only if return value is 0.
+ * @sz:		number of array elements to read
  *
  * Search for a property in a device node and read 32-bit value(s) from
  * it. Returns 0 on success, -EINVAL if the property does not exist,

commit 79d1c712958f94372482ad74578b00f44e744c12
Author: Nathan Fontenot <nfont@linux.vnet.ibm.com>
Date:   Tue Oct 2 16:58:46 2012 +0000

    powerpc+of: Rename the drivers/of prom_* functions to of_*
    
    Rename the prom_*_property routines of the generic OF code to of_*_property.
    This brings them in line with the naming used by the rest of the OF code.
    
    Signed-off-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
    Acked-by: Geoff Levand <geoff@infradead.org>
    Acked-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 87b63850e8dc..02d94c4ea83c 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1047,9 +1047,9 @@ static int of_property_notify(int action, struct device_node *np,
 #endif
 
 /**
- * prom_add_property - Add a property to a node
+ * of_add_property - Add a property to a node
  */
-int prom_add_property(struct device_node *np, struct property *prop)
+int of_add_property(struct device_node *np, struct property *prop)
 {
 	struct property **next;
 	unsigned long flags;
@@ -1083,14 +1083,14 @@ int prom_add_property(struct device_node *np, struct property *prop)
 }
 
 /**
- * prom_remove_property - Remove a property from a node.
+ * of_remove_property - Remove a property from a node.
  *
  * Note that we don't actually remove it, since we have given out
  * who-knows-how-many pointers to the data using get-property.
  * Instead we just move the property to the "dead properties"
  * list, so it won't be found any more.
  */
-int prom_remove_property(struct device_node *np, struct property *prop)
+int of_remove_property(struct device_node *np, struct property *prop)
 {
 	struct property **next;
 	unsigned long flags;
@@ -1129,7 +1129,7 @@ int prom_remove_property(struct device_node *np, struct property *prop)
 }
 
 /*
- * prom_update_property - Update a property in a node, if the property does
+ * of_update_property - Update a property in a node, if the property does
  * not exist, add it.
  *
  * Note that we don't actually remove it, since we have given out
@@ -1137,8 +1137,7 @@ int prom_remove_property(struct device_node *np, struct property *prop)
  * Instead we just move the property to the "dead properties" list,
  * and add the new property to the property list
  */
-int prom_update_property(struct device_node *np,
-			 struct property *newprop)
+int of_update_property(struct device_node *np, struct property *newprop)
 {
 	struct property **next, *oldprop;
 	unsigned long flags;
@@ -1153,7 +1152,7 @@ int prom_update_property(struct device_node *np,
 
 	oldprop = of_find_property(np, newprop->name, NULL);
 	if (!oldprop)
-		return prom_add_property(np, newprop);
+		return of_add_property(np, newprop);
 
 	write_lock_irqsave(&devtree_lock, flags);
 	next = &np->properties;

commit 1cf3d8b3d24cd383ddfd5442c83ec5c355ffc2f7
Author: Nathan Fontenot <nfont@linux.vnet.ibm.com>
Date:   Tue Oct 2 16:57:57 2012 +0000

    powerpc+of: Add of node/property notification chain for adds and removes
    
    This patch moves the notification chain for updates to the device tree
    from the powerpc/pseries code to the base OF code. This makes this
    functionality available to all architectures.
    
    Additionally the notification chain is updated to allow notifications
    for property add/remove/update. To make this work a pointer to a new
    struct (of_prop_reconfig) is passed to the routines in the notification chain.
    The of_prop_reconfig property contains a pointer to the node containing the
    property and a pointer to the property itself. In the case of property
    updates, the property pointer refers to the new property.
    
    Signed-off-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
    Acked-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index bbd073f53c9f..87b63850e8dc 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1028,6 +1028,24 @@ int of_parse_phandle_with_args(struct device_node *np, const char *list_name,
 }
 EXPORT_SYMBOL(of_parse_phandle_with_args);
 
+#if defined(CONFIG_OF_DYNAMIC)
+static int of_property_notify(int action, struct device_node *np,
+			      struct property *prop)
+{
+	struct of_prop_reconfig pr;
+
+	pr.dn = np;
+	pr.prop = prop;
+	return of_reconfig_notify(action, &pr);
+}
+#else
+static int of_property_notify(int action, struct device_node *np,
+			      struct property *prop)
+{
+	return 0;
+}
+#endif
+
 /**
  * prom_add_property - Add a property to a node
  */
@@ -1035,6 +1053,11 @@ int prom_add_property(struct device_node *np, struct property *prop)
 {
 	struct property **next;
 	unsigned long flags;
+	int rc;
+
+	rc = of_property_notify(OF_RECONFIG_ADD_PROPERTY, np, prop);
+	if (rc)
+		return rc;
 
 	prop->next = NULL;
 	write_lock_irqsave(&devtree_lock, flags);
@@ -1072,6 +1095,11 @@ int prom_remove_property(struct device_node *np, struct property *prop)
 	struct property **next;
 	unsigned long flags;
 	int found = 0;
+	int rc;
+
+	rc = of_property_notify(OF_RECONFIG_REMOVE_PROPERTY, np, prop);
+	if (rc)
+		return rc;
 
 	write_lock_irqsave(&devtree_lock, flags);
 	next = &np->properties;
@@ -1114,7 +1142,11 @@ int prom_update_property(struct device_node *np,
 {
 	struct property **next, *oldprop;
 	unsigned long flags;
-	int found = 0;
+	int rc, found = 0;
+
+	rc = of_property_notify(OF_RECONFIG_UPDATE_PROPERTY, np, newprop);
+	if (rc)
+		return rc;
 
 	if (!newprop->name)
 		return -EINVAL;
@@ -1160,6 +1192,26 @@ int prom_update_property(struct device_node *np,
  * device tree nodes.
  */
 
+static BLOCKING_NOTIFIER_HEAD(of_reconfig_chain);
+
+int of_reconfig_notifier_register(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&of_reconfig_chain, nb);
+}
+
+int of_reconfig_notifier_unregister(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&of_reconfig_chain, nb);
+}
+
+int of_reconfig_notify(unsigned long action, void *p)
+{
+	int rc;
+
+	rc = blocking_notifier_call_chain(&of_reconfig_chain, action, p);
+	return notifier_to_errno(rc);
+}
+
 #ifdef CONFIG_PROC_DEVICETREE
 static void of_add_proc_dt_entry(struct device_node *dn)
 {
@@ -1179,9 +1231,14 @@ static void of_add_proc_dt_entry(struct device_node *dn)
 /**
  * of_attach_node - Plug a device node into the tree and global list.
  */
-void of_attach_node(struct device_node *np)
+int of_attach_node(struct device_node *np)
 {
 	unsigned long flags;
+	int rc;
+
+	rc = of_reconfig_notify(OF_RECONFIG_ATTACH_NODE, np);
+	if (rc)
+		return rc;
 
 	write_lock_irqsave(&devtree_lock, flags);
 	np->sibling = np->parent->child;
@@ -1191,6 +1248,7 @@ void of_attach_node(struct device_node *np)
 	write_unlock_irqrestore(&devtree_lock, flags);
 
 	of_add_proc_dt_entry(np);
+	return 0;
 }
 
 #ifdef CONFIG_PROC_DEVICETREE
@@ -1220,23 +1278,28 @@ static void of_remove_proc_dt_entry(struct device_node *dn)
  * The caller must hold a reference to the node.  The memory associated with
  * the node is not freed until its refcount goes to zero.
  */
-void of_detach_node(struct device_node *np)
+int of_detach_node(struct device_node *np)
 {
 	struct device_node *parent;
 	unsigned long flags;
+	int rc = 0;
+
+	rc = of_reconfig_notify(OF_RECONFIG_DETACH_NODE, np);
+	if (rc)
+		return rc;
 
 	write_lock_irqsave(&devtree_lock, flags);
 
 	if (of_node_check_flag(np, OF_DETACHED)) {
 		/* someone already detached it */
 		write_unlock_irqrestore(&devtree_lock, flags);
-		return;
+		return rc;
 	}
 
 	parent = np->parent;
 	if (!parent) {
 		write_unlock_irqrestore(&devtree_lock, flags);
-		return;
+		return rc;
 	}
 
 	if (allnodes == np)
@@ -1265,6 +1328,7 @@ void of_detach_node(struct device_node *np)
 	write_unlock_irqrestore(&devtree_lock, flags);
 
 	of_remove_proc_dt_entry(np);
+	return rc;
 }
 #endif /* defined(CONFIG_OF_DYNAMIC) */
 

commit e81b3295bc54eb0d03f4cdfc8cbf72e731d1b402
Author: Nathan Fontenot <nfont@linux.vnet.ibm.com>
Date:   Tue Oct 2 16:55:01 2012 +0000

    powerpc+of: Add /proc device tree updating to of node add/remove
    
    When adding or removing a device tree node we should also update
    the device tree in /proc/device-tree. This action is already done in the
    generic OF code for adding/removing properties of a node. This patch adds
    this functionality for nodes.
    
    Signed-off-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
    Acked-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index af3b22ac7627..bbd073f53c9f 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1160,6 +1160,22 @@ int prom_update_property(struct device_node *np,
  * device tree nodes.
  */
 
+#ifdef CONFIG_PROC_DEVICETREE
+static void of_add_proc_dt_entry(struct device_node *dn)
+{
+	struct proc_dir_entry *ent;
+
+	ent = proc_mkdir(strrchr(dn->full_name, '/') + 1, dn->parent->pde);
+	if (ent)
+		proc_device_tree_add_node(dn, ent);
+}
+#else
+static void of_add_proc_dt_entry(struct device_node *dn)
+{
+	return;
+}
+#endif
+
 /**
  * of_attach_node - Plug a device node into the tree and global list.
  */
@@ -1173,8 +1189,31 @@ void of_attach_node(struct device_node *np)
 	np->parent->child = np;
 	allnodes = np;
 	write_unlock_irqrestore(&devtree_lock, flags);
+
+	of_add_proc_dt_entry(np);
 }
 
+#ifdef CONFIG_PROC_DEVICETREE
+static void of_remove_proc_dt_entry(struct device_node *dn)
+{
+	struct device_node *parent = dn->parent;
+	struct property *prop = dn->properties;
+
+	while (prop) {
+		remove_proc_entry(prop->name, dn->pde);
+		prop = prop->next;
+	}
+
+	if (dn->pde)
+		remove_proc_entry(dn->pde->name, parent->pde);
+}
+#else
+static void of_remove_proc_dt_entry(struct device_node *dn)
+{
+	return;
+}
+#endif
+
 /**
  * of_detach_node - "Unplug" a node from the device tree.
  *
@@ -1188,9 +1227,17 @@ void of_detach_node(struct device_node *np)
 
 	write_lock_irqsave(&devtree_lock, flags);
 
+	if (of_node_check_flag(np, OF_DETACHED)) {
+		/* someone already detached it */
+		write_unlock_irqrestore(&devtree_lock, flags);
+		return;
+	}
+
 	parent = np->parent;
-	if (!parent)
-		goto out_unlock;
+	if (!parent) {
+		write_unlock_irqrestore(&devtree_lock, flags);
+		return;
+	}
 
 	if (allnodes == np)
 		allnodes = np->allnext;
@@ -1215,9 +1262,9 @@ void of_detach_node(struct device_node *np)
 	}
 
 	of_node_set_flag(np, OF_DETACHED);
-
-out_unlock:
 	write_unlock_irqrestore(&devtree_lock, flags);
+
+	of_remove_proc_dt_entry(np);
 }
 #endif /* defined(CONFIG_OF_DYNAMIC) */
 

commit a54dfb1a845c38a97686268d8c4086a63d9493aa
Merge: eb0ad9c06d51 36165f550557
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 3 09:44:08 2012 -0700

    Merge tag 'dt-for-3.7' of git://sources.calxeda.com/kernel/linux
    
    Pull devicetree updates from Rob Herring:
     - Import of latest upstream device tree compiler (dtc)
     - New function of_get_child_by_name
     - Support for #size-cells of 0 and #addr-cells of >2
     - Couple of DT binding documentation updates
    
    Fix up trivial conflicts due to of_get_child_by_name() having been added
    next to the new of_get_next_available_child().
    
    * tag 'dt-for-3.7' of git://sources.calxeda.com/kernel/linux:
      MAINTAINERS: add scripts/dtc under Devicetree maintainers
      dtc: import latest upstream dtc
      dt: Document general interrupt controller bindings
      dt/s3c64xx/spi: Use of_get_child_by_name to get a named child
      dt: introduce of_get_child_by_name to get child node by name
      of: i2c: add support for wakeup-source property
      of/address: Handle #address-cells > 2 specially
      DT: export of_irq_to_resource_table()
      devicetree: serial: Add documentation for imx serial
      devicetree: pwm: mxs-pwm.txt: Fix reg field annotation
      of: Allow busses with #size-cells=0

commit 9c19761a7ecdc86abb2fba0feb81e8952eccc1f1
Author: Srinivas Kandagatla <srinivas.kandagatla@st.com>
Date:   Tue Sep 18 08:10:28 2012 +0100

    dt: introduce of_get_child_by_name to get child node by name
    
    This patch introduces of_get_child_by_name function to get a child node
    by its name in a given parent node.
    
    Without this patch each driver code has to iterate the parent and do
    a string compare, However having of_get_child_by_name libary function would
    avoid code duplication, errors and is more convenient.
    
    Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@st.com>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index c181b94abc36..e2e813624df5 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -363,6 +363,29 @@ struct device_node *of_get_next_child(const struct device_node *node,
 }
 EXPORT_SYMBOL(of_get_next_child);
 
+/**
+ *	of_get_child_by_name - Find the child node by name for a given parent
+ *	@node:	parent node
+ *	@name:	child name to look for.
+ *
+ *      This function looks for child node for given matching name
+ *
+ *	Returns a node pointer if found, with refcount incremented, use
+ *	of_node_put() on it when done.
+ *	Returns NULL if node is not found.
+ */
+struct device_node *of_get_child_by_name(const struct device_node *node,
+				const char *name)
+{
+	struct device_node *child;
+
+	for_each_child_of_node(node, child)
+		if (child->name && (of_node_cmp(child->name, name) == 0))
+			break;
+	return child;
+}
+EXPORT_SYMBOL(of_get_child_by_name);
+
 /**
  *	of_find_node_by_path - Find a node matching a full OF path
  *	@path:	The full path to match

commit 3296193d1421c2d6f9e49e181cecfd917f0f5764
Author: Timur Tabi <timur@freescale.com>
Date:   Tue Aug 14 13:20:23 2012 +0000

    dt: introduce for_each_available_child_of_node, of_get_next_available_child
    
    Macro for_each_child_of_node() makes it easy to iterate over all of the
    children for a given device tree node, including those nodes that are
    marked as unavailable (i.e. status = "disabled").
    
    Introduce for_each_available_child_of_node(), which is like
    for_each_child_of_node(), but it automatically skips unavailable nodes.
    This also requires the introduction of helper function
    of_get_next_available_child(), which returns the next available child
    node.
    
    Signed-off-by: Timur Tabi <timur@freescale.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index c181b94abc36..d4a1c9a043e1 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -363,6 +363,33 @@ struct device_node *of_get_next_child(const struct device_node *node,
 }
 EXPORT_SYMBOL(of_get_next_child);
 
+/**
+ *	of_get_next_available_child - Find the next available child node
+ *	@node:	parent node
+ *	@prev:	previous child of the parent node, or NULL to get first
+ *
+ *      This function is like of_get_next_child(), except that it
+ *      automatically skips any disabled nodes (i.e. status = "disabled").
+ */
+struct device_node *of_get_next_available_child(const struct device_node *node,
+	struct device_node *prev)
+{
+	struct device_node *next;
+
+	read_lock(&devtree_lock);
+	next = prev ? prev->sibling : node->child;
+	for (; next; next = next->sibling) {
+		if (!of_device_is_available(next))
+			continue;
+		if (of_node_get(next))
+			break;
+	}
+	of_node_put(prev);
+	read_unlock(&devtree_lock);
+	return next;
+}
+EXPORT_SYMBOL(of_get_next_available_child);
+
 /**
  *	of_find_node_by_path - Find a node matching a full OF path
  *	@path:	The full path to match

commit f14121ab35912e3d2e57ac9a4ce1f9d4b7baeffb
Merge: 914311c9fb9b e95d8aafa5d9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 24 14:07:22 2012 -0700

    Merge tag 'dt-for-3.6' of git://sources.calxeda.com/kernel/linux
    
    Pull devicetree updates from Rob Herring:
     "A small set of changes for devicetree:
       - Couple of Documentation fixes
       - Addition of new helper function of_node_full_name
       - Improve of_parse_phandle_with_args return values
       - Some NULL related sparse fixes"
    
    Grant's busy packing.
    
    * tag 'dt-for-3.6' of git://sources.calxeda.com/kernel/linux:
      of: mtd: nuke useless const qualifier
      devicetree: add helper inline for retrieving a node's full name
      of: return -ENOENT when no property
      usage-model.txt: fix typo machine_init->init_machine
      of: Fix null pointer related warnings in base.c file
      LED: Fix missing semicolon in OF documentation
      of: fix a few typos in the binding documentation

commit 83c7f72259ea4bd0561e2f2762d97ee2888126ce
Merge: e05644e17e74 574ce79cea9d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 23 18:54:23 2012 -0700

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc
    
    Pull powerpc updates from Benjamin Herrenschmidt:
     "Notable highlights:
    
       - iommu improvements from Anton removing the per-iommu global lock in
         favor of dividing the DMA space into pools, each with its own lock,
         and hashed on the CPU number.  Along with making the locking more
         fine grained, this gives significant improvements in multiqueue
         networking scalability.
    
       - Still from Anton, we know provide a vdso based variant of getcpu
         which makes sched_getcpu with the appropriate glibc patch something
         like 18 times faster.
    
       - More anton goodness (he's been busy !) in other areas such as a
         faster __clear_user and copy_page on P7, various perf fixes to
         improve sampling quality, etc...
    
       - One more step toward removing legacy i2c interfaces by using new
         device-tree based probing of platform devices for the AOA audio
         drivers
    
       - A nice series of patches from Michael Neuling that helps avoiding
         confusion between register numbers and litterals in assembly code,
         trying to enforce the use of "%rN" register names in gas rather
         than plain numbers.
    
       - A pile of FSL updates
    
       - The usual bunch of small fixes, cleanups etc...
    
      You may spot a change to drivers/char/mem.  The patch got no comment
      or ack from outside, it's a trivial patch to allow the architecture to
      skip creating /dev/port, which we use to disable it on ppc64 that
      don't have a legacy brige.  On those, IO ports 0...64K are not mapped
      in kernel space at all, so accesses to /dev/port cause oopses (and
      yes, distros -still- ship userspace that bangs hard coded ports such
      as kbdrate)."
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc: (106 commits)
      powerpc/mpic: Create a revmap with enough entries for IPIs and timers
      Remove stale .rej file
      powerpc/iommu: Fix iommu pool initialization
      powerpc/eeh: Check handle_eeh_events() return value
      powerpc/85xx: Add phy nodes in SGMII mode for MPC8536/44/72DS & P2020DS
      powerpc/e500: add paravirt QEMU platform
      powerpc/mpc85xx_ds: convert to unified PCI init
      powerpc/fsl-pci: get PCI init out of board files
      powerpc/85xx: Update corenet64_smp_defconfig
      powerpc/85xx: Update corenet32_smp_defconfig
      powerpc/85xx: Rename P1021RDB-PC device trees to be consistent
      powerpc/watchdog: move booke watchdog param related code to setup-common.c
      sound/aoa: Adapt to new i2c probing scheme
      i2c/powermac: Improve detection of devices from device-tree
      powerpc: Disable /dev/port interface on systems without an ISA bridge
      of: Improve prom_update_property() function
      powerpc: Add "memory" attribute for mfmsr()
      powerpc/ftrace: Fix assembly trampoline register usage
      powerpc/hw_breakpoints: Fix incorrect pointer access
      powerpc: Put the gpr save/restore functions in their own section
      ...

commit 475d0094293b51353e342d1198377967dbc48169
Author: Dong Aisheng <dong.aisheng@linaro.org>
Date:   Wed Jul 11 15:16:37 2012 +1000

    of: Improve prom_update_property() function
    
    prom_update_property() currently fails if the property doesn't
    actually exist yet which isn't what we want. Change to add-or-update
    instead of update-only, then we can remove a lot duplicated lines.
    
    Suggested-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Dong Aisheng <dong.aisheng@linaro.org>
    Acked-by: Rob Herring <rob.herring@calxeda.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index eada3f4ef801..bc86ea2af668 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1073,7 +1073,8 @@ int prom_remove_property(struct device_node *np, struct property *prop)
 }
 
 /*
- * prom_update_property - Update a property in a node.
+ * prom_update_property - Update a property in a node, if the property does
+ * not exist, add it.
  *
  * Note that we don't actually remove it, since we have given out
  * who-knows-how-many pointers to the data using get-property.
@@ -1081,13 +1082,19 @@ int prom_remove_property(struct device_node *np, struct property *prop)
  * and add the new property to the property list
  */
 int prom_update_property(struct device_node *np,
-			 struct property *newprop,
-			 struct property *oldprop)
+			 struct property *newprop)
 {
-	struct property **next;
+	struct property **next, *oldprop;
 	unsigned long flags;
 	int found = 0;
 
+	if (!newprop->name)
+		return -EINVAL;
+
+	oldprop = of_find_property(np, newprop->name, NULL);
+	if (!oldprop)
+		return prom_add_property(np, newprop);
+
 	write_lock_irqsave(&devtree_lock, flags);
 	next = &np->properties;
 	while (*next) {

commit bc51b0c22cebf5c311a6f1895fcca9f78efd0478
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 10 12:49:32 2012 -0700

    Revert "of: match by compatible property first"
    
    This reverts commit 107a84e61cdd3406c842a0e4be7efffd3a05dba6.
    
    Meelis Roos reports a regression since 3.5-rc5 that stops Sun Fire V100
    and Sun Netra X1 sparc64 machines from booting, hanging after enabling
    serial console.  He bisected it to commit 107a84e61cdd.
    
    Rob Herring explains:
     "The problem is match combinations of compatible plus name and/or type
      fail to match correctly.  I have a fix for this, but given how late it
      is for 3.5 I think it is best to revert this for now.  There could be
      other cases that rely on the current although wrong behavior.  I will
      post an updated version for 3.6."
    
    Bisected-and-reported-by: Meelis Roos <mroos@linux.ee>
    Requested-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Thierry Reding <thierry.reding@avionic-design.de>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index eada3f4ef801..d9bfd49b1935 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -511,22 +511,6 @@ struct device_node *of_find_node_with_property(struct device_node *from,
 }
 EXPORT_SYMBOL(of_find_node_with_property);
 
-static const struct of_device_id *of_match_compat(const struct of_device_id *matches,
-						  const char *compat)
-{
-	while (matches->name[0] || matches->type[0] || matches->compatible[0]) {
-		const char *cp = matches->compatible;
-		int len = strlen(cp);
-
-		if (len > 0 && of_compat_cmp(compat, cp, len) == 0)
-			return matches;
-
-		matches++;
-	}
-
-	return NULL;
-}
-
 /**
  * of_match_node - Tell if an device_node has a matching of_match structure
  *	@matches:	array of of device match structures to search in
@@ -537,18 +521,9 @@ static const struct of_device_id *of_match_compat(const struct of_device_id *mat
 const struct of_device_id *of_match_node(const struct of_device_id *matches,
 					 const struct device_node *node)
 {
-	struct property *prop;
-	const char *cp;
-
 	if (!matches)
 		return NULL;
 
-	of_property_for_each_string(node, "compatible", prop, cp) {
-		const struct of_device_id *match = of_match_compat(matches, cp);
-		if (match)
-			return match;
-	}
-
 	while (matches->name[0] || matches->type[0] || matches->compatible[0]) {
 		int match = 1;
 		if (matches->name[0])
@@ -557,7 +532,10 @@ const struct of_device_id *of_match_node(const struct of_device_id *matches,
 		if (matches->type[0])
 			match &= node->type
 				&& !strcmp(matches->type, node->type);
-		if (match && !matches->compatible[0])
+		if (matches->compatible[0])
+			match &= of_device_is_compatible(node,
+						matches->compatible);
+		if (match)
 			return matches;
 		matches++;
 	}

commit 74a7f08448adea6cb47cd9b260c98ff168117e92
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Jun 15 11:50:25 2012 -0600

    devicetree: add helper inline for retrieving a node's full name
    
    The pattern (np ? np->full_name : "<none>") is rather common in the
    kernel, but can also make for quite long lines.  This patch adds a new
    inline function, of_node_full_name() so that the test for a valid node
    pointer doesn't need to be open coded at all call sites.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 85757952f12d..9ec0a2f1b028 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1173,7 +1173,7 @@ static void of_alias_add(struct alias_prop *ap, struct device_node *np,
 	ap->stem[stem_len] = 0;
 	list_add_tail(&ap->link, &aliases_lookup);
 	pr_debug("adding DT alias:%s: stem=%s id=%i node=%s\n",
-		 ap->alias, ap->stem, ap->id, np ? np->full_name : NULL);
+		 ap->alias, ap->stem, ap->id, of_node_full_name(np));
 }
 
 /**

commit 1af4c7f18a442771d86d496c761e9816349f98c9
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Fri Jun 29 13:57:58 2012 +0900

    of: return -ENOENT when no property
    
    Make of_parse_phandle_with_args return -ENOENT instead of -EINVAL when
    no matching property is found, which allows to discriminate between
    absence of property and parsing error.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index ddba57799fd7..85757952f12d 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -902,7 +902,7 @@ int of_parse_phandle_with_args(struct device_node *np, const char *list_name,
 	/* Retrieve the phandle list property */
 	list = of_get_property(np, list_name, &size);
 	if (!list)
-		return -EINVAL;
+		return -ENOENT;
 	list_end = list + size / sizeof(*list);
 
 	/* Loop over the phandles until all the requested entry is found */

commit a3a7cab17d36bb591867a6d3ea41b5fdb4e44d87
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Wed Jun 27 09:44:45 2012 +0530

    of: Fix null pointer related warnings in base.c file
    
    Fixes the following sparse warnings:
    drivers/of/base.c:176:41: warning: Using plain integer as NULL pointer
    drivers/of/base.c:178:37: warning: Using plain integer as NULL pointer
    drivers/of/base.c:500:49: warning: Using plain integer as NULL pointer
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index d9bfd49b1935..ddba57799fd7 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -173,9 +173,9 @@ struct property *of_find_property(const struct device_node *np,
 		return NULL;
 
 	read_lock(&devtree_lock);
-	for (pp = np->properties; pp != 0; pp = pp->next) {
+	for (pp = np->properties; pp; pp = pp->next) {
 		if (of_prop_cmp(pp->name, name) == 0) {
-			if (lenp != 0)
+			if (lenp)
 				*lenp = pp->length;
 			break;
 		}
@@ -497,7 +497,7 @@ struct device_node *of_find_node_with_property(struct device_node *from,
 	read_lock(&devtree_lock);
 	np = from ? from->allnext : allnodes;
 	for (; np; np = np->allnext) {
-		for (pp = np->properties; pp != 0; pp = pp->next) {
+		for (pp = np->properties; pp; pp = pp->next) {
 			if (of_prop_cmp(pp->name, prop_name) == 0) {
 				of_node_get(np);
 				goto out;

commit 107a84e61cdd3406c842a0e4be7efffd3a05dba6
Author: Thierry Reding <thierry.reding@avionic-design.de>
Date:   Thu Jun 14 09:12:35 2012 +0200

    of: match by compatible property first
    
    When matching devices against an OF device ID table, the first string of
    the compatible property that is listed in the table should match,
    regardless of its position in the table.
    
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: devicetree-discuss@lists.ozlabs.org
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index d9bfd49b1935..eada3f4ef801 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -511,6 +511,22 @@ struct device_node *of_find_node_with_property(struct device_node *from,
 }
 EXPORT_SYMBOL(of_find_node_with_property);
 
+static const struct of_device_id *of_match_compat(const struct of_device_id *matches,
+						  const char *compat)
+{
+	while (matches->name[0] || matches->type[0] || matches->compatible[0]) {
+		const char *cp = matches->compatible;
+		int len = strlen(cp);
+
+		if (len > 0 && of_compat_cmp(compat, cp, len) == 0)
+			return matches;
+
+		matches++;
+	}
+
+	return NULL;
+}
+
 /**
  * of_match_node - Tell if an device_node has a matching of_match structure
  *	@matches:	array of of device match structures to search in
@@ -521,9 +537,18 @@ EXPORT_SYMBOL(of_find_node_with_property);
 const struct of_device_id *of_match_node(const struct of_device_id *matches,
 					 const struct device_node *node)
 {
+	struct property *prop;
+	const char *cp;
+
 	if (!matches)
 		return NULL;
 
+	of_property_for_each_string(node, "compatible", prop, cp) {
+		const struct of_device_id *match = of_match_compat(matches, cp);
+		if (match)
+			return match;
+	}
+
 	while (matches->name[0] || matches->type[0] || matches->compatible[0]) {
 		int match = 1;
 		if (matches->name[0])
@@ -532,10 +557,7 @@ const struct of_device_id *of_match_node(const struct of_device_id *matches,
 		if (matches->type[0])
 			match &= node->type
 				&& !strcmp(matches->type, node->type);
-		if (matches->compatible[0])
-			match &= of_device_is_compatible(node,
-						matches->compatible);
-		if (match)
+		if (match && !matches->compatible[0])
 			return matches;
 		matches++;
 	}

commit c541adc637066407d4cda9db14dcb0e618966a4c
Author: Stephen Warren <swarren@nvidia.com>
Date:   Wed Apr 4 09:27:46 2012 -0600

    dt: add property iteration helpers
    
    This patch adds macros of_property_for_each_u32() and
    of_property_for_each_string(), which iterate over an array of values
    within a device-tree property. Usage is for example:
    
    struct property *prop;
    const __be32 *p;
    u32 u;
    of_property_for_each_u32(np, "propname", prop, p, u)
            printk("U32 value: %x\n", u);
    
    struct property *prop;
    const char *s;
    of_property_for_each_string(np, "propname", prop, s)
            printk("String value: %s\n", s);
    
    Based on work by Rob Herring <robherring2@gmail.com>
    
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Rob Herring <rob.herring@calxeda.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 580644986945..d9bfd49b1935 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1260,3 +1260,44 @@ int of_alias_get_id(struct device_node *np, const char *stem)
 	return id;
 }
 EXPORT_SYMBOL_GPL(of_alias_get_id);
+
+const __be32 *of_prop_next_u32(struct property *prop, const __be32 *cur,
+			       u32 *pu)
+{
+	const void *curv = cur;
+
+	if (!prop)
+		return NULL;
+
+	if (!cur) {
+		curv = prop->value;
+		goto out_val;
+	}
+
+	curv += sizeof(*cur);
+	if (curv >= prop->value + prop->length)
+		return NULL;
+
+out_val:
+	*pu = be32_to_cpup(curv);
+	return curv;
+}
+EXPORT_SYMBOL_GPL(of_prop_next_u32);
+
+const char *of_prop_next_string(struct property *prop, const char *cur)
+{
+	const void *curv = cur;
+
+	if (!prop)
+		return NULL;
+
+	if (!cur)
+		return prop->value;
+
+	curv += strlen(cur) + 1;
+	if (curv >= prop->value + prop->length)
+		return NULL;
+
+	return curv;
+}
+EXPORT_SYMBOL_GPL(of_prop_next_string);

commit 0f22dd395fc473cee252b9af50249b8e0f32fde7
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Wed Feb 15 20:38:40 2012 -0700

    of: Only compile OF_DYNAMIC on PowerPC pseries and iseries
    
    Only two architectures use the OF node reference counting and reclaim bits.
    There is no need to compile it for the rest of the PowerPC platforms or for
    any of the other architectures.  This patch makes iseries and pseries
    select CONFIG_OF_DYNAMIC, and makes it default to off for everything else.
    
    It is still safe to turn on CONFIG_OF_DYNAMIC on all architectures, it just
    isn't necessary.
    
    v2: Also select OF_DYNAMIC for PPC_CHROMA and MPC885ADS as reported by Michael
        Meuling
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: David S. Miller <davem@davemloft.net>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Jimi Xenidis <jimix@pobox.com> (for PPC_CHROMA bug fix)
    Cc: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 13ba72875e25..580644986945 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -88,7 +88,7 @@ int of_n_size_cells(struct device_node *np)
 }
 EXPORT_SYMBOL(of_n_size_cells);
 
-#if !defined(CONFIG_SPARC)   /* SPARC doesn't do ref counting (yet) */
+#if defined(CONFIG_OF_DYNAMIC)
 /**
  *	of_node_get - Increment refcount of a node
  *	@node:	Node to inc refcount, NULL is supported to
@@ -161,7 +161,7 @@ void of_node_put(struct device_node *node)
 		kref_put(&node->kref, of_node_release);
 }
 EXPORT_SYMBOL(of_node_put);
-#endif /* !CONFIG_SPARC */
+#endif /* CONFIG_OF_DYNAMIC */
 
 struct property *of_find_property(const struct device_node *np,
 				  const char *name,

commit 7aff0fe33033fc75b61446ba29d38b1b1354af9f
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Mon Dec 12 09:25:58 2011 -0700

    of: Add of_property_match_string() to find index into a string list
    
    Add a helper function for finding the index of a string in a string
    list property.  This helper is useful for bindings that use a separate
    *-name property for attaching names to tuples in another property such
    as 'reg' or 'gpios'.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 133908a6fd8d..13ba72875e25 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -761,6 +761,42 @@ int of_property_read_string_index(struct device_node *np, const char *propname,
 }
 EXPORT_SYMBOL_GPL(of_property_read_string_index);
 
+/**
+ * of_property_match_string() - Find string in a list and return index
+ * @np: pointer to node containing string list property
+ * @propname: string list property name
+ * @string: pointer to string to search for in string list
+ *
+ * This function searches a string list property and returns the index
+ * of a specific string value.
+ */
+int of_property_match_string(struct device_node *np, const char *propname,
+			     const char *string)
+{
+	struct property *prop = of_find_property(np, propname, NULL);
+	size_t l;
+	int i;
+	const char *p, *end;
+
+	if (!prop)
+		return -EINVAL;
+	if (!prop->value)
+		return -ENODATA;
+
+	p = prop->value;
+	end = p + prop->length;
+
+	for (i = 0; p < end; i++, p += l) {
+		l = strlen(p) + 1;
+		if (p + l > end)
+			return -EILSEQ;
+		pr_debug("comparing %s with %s\n", string, p);
+		if (strcmp(string, p) == 0)
+			return i; /* Found it; return index */
+	}
+	return -ENODATA;
+}
+EXPORT_SYMBOL_GPL(of_property_match_string);
 
 /**
  * of_property_count_strings - Find and return the number of strings from a

commit 02550d61f49266930e674286379d3601006b2893
Merge: 2d51daaa615e c89810acbcf4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jan 7 12:18:52 2012 -0800

    Merge tag 'devicetree-for-linus' of git://git.secretlab.ca/git/linux-2.6
    
    devicetree/next changes queued for v3.3 merge window
    
    * tag 'devicetree-for-linus-20120104' of git://git.secretlab.ca/git/linux-2.6:
      ARM: prom.h: Fix build error by removing unneeded header file
      irq: check domain hwirq range for DT translate
      dt: add empty of_get_node/of_put_node functions
      of/pdt: fix section mismatch warning
      i2c-designware: add OF binding support
      dt/i2c: Enumerate some of the known trivial i2c devices
      dt: reform for_each_property to for_each_property_of_node
      ARM/of: allow *machine_desc.dt_compat to be const
      of/base: Take NULL string into account for property with multiple strings
      OF/device-tree: Add some entries to vendor-prefixes.txt
    
    Fix up trivial add-add conflicts in include/linux/of.h

commit 8af0da93da7c40526959ab5291964581c678d3e7
Author: Dong Aisheng <dong.aisheng@linaro.org>
Date:   Thu Dec 22 20:19:24 2011 +0800

    dt: reform for_each_property to for_each_property_of_node
    
    Make this macro easier to use(do not need to pass properties, a node is
    enough), also change to a more sensible name as for_each_child_of_node.
    
    Signed-off-by: Dong Aisheng <dong.aisheng@linaro.org>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index b7072437eb8c..0181eeb88c92 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1157,7 +1157,7 @@ void of_alias_scan(void * (*dt_alloc)(u64 size, u64 align))
 	if (!of_aliases)
 		return;
 
-	for_each_property(pp, of_aliases->properties) {
+	for_each_property_of_node(of_aliases, pp) {
 		const char *start = pp->name;
 		const char *end = start + strlen(start);
 		struct device_node *np;

commit 88af7f58c6f1fa28d617392c791f11317bcb590d
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Mon Dec 5 15:23:54 2011 +0100

    of/base: Take NULL string into account for property with multiple strings
    
    The current implementation just ignore any NULL string inserted in a
    multiple strings property.
    In some cases we can have a property with a fix number of strings but
    not necessarily used, like for example in a list of valid pinmux modes.
    
     prop = "uart_rx", "uart_tx", "", "", "safe_mode";
    
    Do no skip NULL string and take them into account in
    of_property_read_string_index and of_property_count_strings.
    
    Reported-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 9b6588ef0673..b7072437eb8c 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -752,7 +752,7 @@ int of_property_read_string_index(struct device_node *np, const char *propname,
 
 	for (i = 0; total < prop->length; total += l, p += l) {
 		l = strlen(p) + 1;
-		if ((*p != 0) && (i++ == index)) {
+		if (i++ == index) {
 			*output = p;
 			return 0;
 		}
@@ -790,11 +790,9 @@ int of_property_count_strings(struct device_node *np, const char *propname)
 
 	p = prop->value;
 
-	for (i = 0; total < prop->length; total += l, p += l) {
+	for (i = 0; total < prop->length; total += l, p += l, i++)
 		l = strlen(p) + 1;
-		if (*p != 0)
-			i++;
-	}
+
 	return i;
 }
 EXPORT_SYMBOL_GPL(of_property_count_strings);

commit 15c9a0acc3f7873db4b7d35d016729b2dc229b49
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Mon Dec 12 09:25:57 2011 -0700

    of: create of_phandle_args to simplify return of phandle parsing data
    
    of_parse_phandle_with_args() needs to return quite a bit of data.  Rather
    than making each datum a separate **out_ argument, this patch creates
    struct of_phandle_args to contain all the returned data and reworks the
    user of the function.  This patch also enables of_parse_phandle_with_args()
    to return the device node pointer for the phandle node.
    
    This patch also ends up being fairly major surgery to
    of_parse_handle_with_args().  The existing structure didn't work well
    when extending to use of_phandle_args, and I discovered bugs during testing.
    I also took the opportunity to rename the function to be like the
    existing of_parse_phandle().
    
    v2: - moved declaration of of_phandle_args to fix compile on non-DT builds
        - fixed incorrect index in example usage
        - fixed incorrect return code handling for empty entries
    
    Reviewed-by: Shawn Guo <shawn.guo@freescale.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 9b6588ef0673..c6db9ab9046e 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -824,17 +824,19 @@ of_parse_phandle(struct device_node *np, const char *phandle_name, int index)
 EXPORT_SYMBOL(of_parse_phandle);
 
 /**
- * of_parse_phandles_with_args - Find a node pointed by phandle in a list
+ * of_parse_phandle_with_args() - Find a node pointed by phandle in a list
  * @np:		pointer to a device tree node containing a list
  * @list_name:	property name that contains a list
  * @cells_name:	property name that specifies phandles' arguments count
  * @index:	index of a phandle to parse out
- * @out_node:	optional pointer to device_node struct pointer (will be filled)
- * @out_args:	optional pointer to arguments pointer (will be filled)
+ * @out_args:	optional pointer to output arguments structure (will be filled)
  *
  * This function is useful to parse lists of phandles and their arguments.
- * Returns 0 on success and fills out_node and out_args, on error returns
- * appropriate errno value.
+ * Returns 0 on success and fills out_args, on error returns appropriate
+ * errno value.
+ *
+ * Caller is responsible to call of_node_put() on the returned out_args->node
+ * pointer.
  *
  * Example:
  *
@@ -851,94 +853,96 @@ EXPORT_SYMBOL(of_parse_phandle);
  * }
  *
  * To get a device_node of the `node2' node you may call this:
- * of_parse_phandles_with_args(node3, "list", "#list-cells", 2, &node2, &args);
+ * of_parse_phandle_with_args(node3, "list", "#list-cells", 1, &args);
  */
-int of_parse_phandles_with_args(struct device_node *np, const char *list_name,
+int of_parse_phandle_with_args(struct device_node *np, const char *list_name,
 				const char *cells_name, int index,
-				struct device_node **out_node,
-				const void **out_args)
+				struct of_phandle_args *out_args)
 {
-	int ret = -EINVAL;
-	const __be32 *list;
-	const __be32 *list_end;
-	int size;
-	int cur_index = 0;
+	const __be32 *list, *list_end;
+	int size, cur_index = 0;
+	uint32_t count = 0;
 	struct device_node *node = NULL;
-	const void *args = NULL;
+	phandle phandle;
 
+	/* Retrieve the phandle list property */
 	list = of_get_property(np, list_name, &size);
-	if (!list) {
-		ret = -ENOENT;
-		goto err0;
-	}
+	if (!list)
+		return -EINVAL;
 	list_end = list + size / sizeof(*list);
 
+	/* Loop over the phandles until all the requested entry is found */
 	while (list < list_end) {
-		const __be32 *cells;
-		phandle phandle;
+		count = 0;
 
+		/*
+		 * If phandle is 0, then it is an empty entry with no
+		 * arguments.  Skip forward to the next entry.
+		 */
 		phandle = be32_to_cpup(list++);
-		args = list;
-
-		/* one cell hole in the list = <>; */
-		if (!phandle)
-			goto next;
-
-		node = of_find_node_by_phandle(phandle);
-		if (!node) {
-			pr_debug("%s: could not find phandle\n",
-				 np->full_name);
-			goto err0;
-		}
+		if (phandle) {
+			/*
+			 * Find the provider node and parse the #*-cells
+			 * property to determine the argument length
+			 */
+			node = of_find_node_by_phandle(phandle);
+			if (!node) {
+				pr_err("%s: could not find phandle\n",
+					 np->full_name);
+				break;
+			}
+			if (of_property_read_u32(node, cells_name, &count)) {
+				pr_err("%s: could not get %s for %s\n",
+					 np->full_name, cells_name,
+					 node->full_name);
+				break;
+			}
 
-		cells = of_get_property(node, cells_name, &size);
-		if (!cells || size != sizeof(*cells)) {
-			pr_debug("%s: could not get %s for %s\n",
-				 np->full_name, cells_name, node->full_name);
-			goto err1;
+			/*
+			 * Make sure that the arguments actually fit in the
+			 * remaining property data length
+			 */
+			if (list + count > list_end) {
+				pr_err("%s: arguments longer than property\n",
+					 np->full_name);
+				break;
+			}
 		}
 
-		list += be32_to_cpup(cells);
-		if (list > list_end) {
-			pr_debug("%s: insufficient arguments length\n",
-				 np->full_name);
-			goto err1;
+		/*
+		 * All of the error cases above bail out of the loop, so at
+		 * this point, the parsing is successful. If the requested
+		 * index matches, then fill the out_args structure and return,
+		 * or return -ENOENT for an empty entry.
+		 */
+		if (cur_index == index) {
+			if (!phandle)
+				return -ENOENT;
+
+			if (out_args) {
+				int i;
+				if (WARN_ON(count > MAX_PHANDLE_ARGS))
+					count = MAX_PHANDLE_ARGS;
+				out_args->np = node;
+				out_args->args_count = count;
+				for (i = 0; i < count; i++)
+					out_args->args[i] = be32_to_cpup(list++);
+			}
+			return 0;
 		}
-next:
-		if (cur_index == index)
-			break;
 
 		of_node_put(node);
 		node = NULL;
-		args = NULL;
+		list += count;
 		cur_index++;
 	}
 
-	if (!node) {
-		/*
-		 * args w/o node indicates that the loop above has stopped at
-		 * the 'hole' cell. Report this differently.
-		 */
-		if (args)
-			ret = -EEXIST;
-		else
-			ret = -ENOENT;
-		goto err0;
-	}
-
-	if (out_node)
-		*out_node = node;
-	if (out_args)
-		*out_args = args;
-
-	return 0;
-err1:
-	of_node_put(node);
-err0:
-	pr_debug("%s failed with status %d\n", __func__, ret);
-	return ret;
+	/* Loop exited without finding a valid entry; return an error */
+	if (node)
+		of_node_put(node);
+	return -EINVAL;
 }
-EXPORT_SYMBOL(of_parse_phandles_with_args);
+EXPORT_SYMBOL(of_parse_phandle_with_args);
 
 /**
  * prom_add_property - Add a property to a node

commit 81a3c10ce8a7fd5bf9a06bfc38bd417512911831
Merge: 6585dea1f99c df80442d1ee2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 1 20:58:25 2011 -0700

    Merge branch 'next/cleanup2' of git://git.linaro.org/people/arnd/arm-soc
    
    * 'next/cleanup2' of git://git.linaro.org/people/arnd/arm-soc: (31 commits)
      ARM: OMAP: Warn if omap_ioremap is called before SoC detection
      ARM: OMAP: Move set_globals initialization to happen in init_early
      ARM: OMAP: Map SRAM later on with ioremap_exec()
      ARM: OMAP: Remove calls to SRAM allocations for framebuffer
      ARM: OMAP: Avoid cpu_is_omapxxxx usage until map_io is done
      ARM: OMAP1: Use generic map_io, init_early and init_irq
      arm/dts: OMAP3+: Add mpu, dsp and iva nodes
      arm/dts: OMAP4: Add a main ocp entry bound to l3-noc driver
      ARM: OMAP2+: l3-noc: Add support for device-tree
      ARM: OMAP2+: board-generic: Add i2c static init
      ARM: OMAP2+: board-generic: Add DT support to generic board
      arm/dts: Add support for OMAP3 Beagle board
      arm/dts: Add initial device tree support for OMAP3 SoC
      arm/dts: Add support for OMAP4 SDP board
      arm/dts: Add support for OMAP4 PandaBoard
      arm/dts: Add initial device tree support for OMAP4 SoC
      ARM: OMAP: omap_device: Add a method to build an omap_device from a DT node
      ARM: OMAP: omap_device: Add omap_device_[alloc|delete] for DT integration
      of: Add helpers to get one string in multiple strings property
      ARM: OMAP2+: devices: Remove all omap_device_pm_latency structures
      ...
    
    Fix up trivial header file conflicts in arch/arm/mach-omap2/board-generic.c

commit 4cd7f7a31178ff8a15ad2bc1258b9b2bf2cf51a4
Author: Jamie Iles <jamie@jamieiles.com>
Date:   Wed Sep 14 20:49:59 2011 +0100

    dt: add helper to read 64-bit integers
    
    Add a helper similar to of_property_read_u32() that handles 64-bit
    integers.
    
    v2/v3: constify device node and property name parameters.
    
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Reviewed-by: Rob Herring <rob.herring@calxeda.com>
    Signed-off-by: Jamie Iles <jamie@jamieiles.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 8abde58cbe82..b970562e0111 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -656,6 +656,35 @@ int of_property_read_u32_array(const struct device_node *np,
 }
 EXPORT_SYMBOL_GPL(of_property_read_u32_array);
 
+/**
+ * of_property_read_u64 - Find and read a 64 bit integer from a property
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ * @out_value:	pointer to return value, modified only if return value is 0.
+ *
+ * Search for a property in a device node and read a 64-bit value from
+ * it. Returns 0 on success, -EINVAL if the property does not exist,
+ * -ENODATA if property does not have a value, and -EOVERFLOW if the
+ * property data isn't large enough.
+ *
+ * The out_value is modified only if a valid u64 value can be decoded.
+ */
+int of_property_read_u64(const struct device_node *np, const char *propname,
+			 u64 *out_value)
+{
+	struct property *prop = of_find_property(np, propname, NULL);
+
+	if (!prop)
+		return -EINVAL;
+	if (!prop->value)
+		return -ENODATA;
+	if (sizeof(*out_value) > prop->length)
+		return -EOVERFLOW;
+	*out_value = of_read_number(prop->value, 2);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(of_property_read_u64);
+
 /**
  * of_property_read_string - Find and read a string from a property
  * @np:		device node from which the property value is to be read.

commit 4fcd15a032cec4b2684a32c86e895b50cdbee50c
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Tue Sep 27 17:45:43 2011 +0200

    of: Add helpers to get one string in multiple strings property
    
    Add of_property_read_string_index and of_property_count_strings
    to retrieve one string inside a property that will contains
    severals strings.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 3ff22e32b602..f7239b33d762 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -661,6 +661,90 @@ int of_property_read_string(struct device_node *np, const char *propname,
 }
 EXPORT_SYMBOL_GPL(of_property_read_string);
 
+/**
+ * of_property_read_string_index - Find and read a string from a multiple
+ * strings property.
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ * @index:	index of the string in the list of strings
+ * @out_string:	pointer to null terminated return string, modified only if
+ *		return value is 0.
+ *
+ * Search for a property in a device tree node and retrieve a null
+ * terminated string value (pointer to data, not a copy) in the list of strings
+ * contained in that property.
+ * Returns 0 on success, -EINVAL if the property does not exist, -ENODATA if
+ * property does not have a value, and -EILSEQ if the string is not
+ * null-terminated within the length of the property data.
+ *
+ * The out_string pointer is modified only if a valid string can be decoded.
+ */
+int of_property_read_string_index(struct device_node *np, const char *propname,
+				  int index, const char **output)
+{
+	struct property *prop = of_find_property(np, propname, NULL);
+	int i = 0;
+	size_t l = 0, total = 0;
+	const char *p;
+
+	if (!prop)
+		return -EINVAL;
+	if (!prop->value)
+		return -ENODATA;
+	if (strnlen(prop->value, prop->length) >= prop->length)
+		return -EILSEQ;
+
+	p = prop->value;
+
+	for (i = 0; total < prop->length; total += l, p += l) {
+		l = strlen(p) + 1;
+		if ((*p != 0) && (i++ == index)) {
+			*output = p;
+			return 0;
+		}
+	}
+	return -ENODATA;
+}
+EXPORT_SYMBOL_GPL(of_property_read_string_index);
+
+
+/**
+ * of_property_count_strings - Find and return the number of strings from a
+ * multiple strings property.
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ *
+ * Search for a property in a device tree node and retrieve the number of null
+ * terminated string contain in it. Returns the number of strings on
+ * success, -EINVAL if the property does not exist, -ENODATA if property
+ * does not have a value, and -EILSEQ if the string is not null-terminated
+ * within the length of the property data.
+ */
+int of_property_count_strings(struct device_node *np, const char *propname)
+{
+	struct property *prop = of_find_property(np, propname, NULL);
+	int i = 0;
+	size_t l = 0, total = 0;
+	const char *p;
+
+	if (!prop)
+		return -EINVAL;
+	if (!prop->value)
+		return -ENODATA;
+	if (strnlen(prop->value, prop->length) >= prop->length)
+		return -EILSEQ;
+
+	p = prop->value;
+
+	for (i = 0; total < prop->length; total += l, p += l) {
+		l = strlen(p) + 1;
+		if (*p != 0)
+			i++;
+	}
+	return i;
+}
+EXPORT_SYMBOL_GPL(of_property_count_strings);
+
 /**
  * of_parse_phandle - Resolve a phandle property to a device_node pointer
  * @np: Pointer to device node holding phandle property

commit 611cad720148c899db5a383c1c676fd820df7023
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Mon Aug 15 15:28:14 2011 +0800

    dt: add of_alias_scan and of_alias_get_id
    
    The patch adds function of_alias_scan to populate a global lookup
    table with the properties of 'aliases' node and function
    of_alias_get_id for drivers to find alias id from the lookup table.
    
    v3: Split out automatic addition of aliases on id lookup so that it can be
        debated separately from the core functionality.
    v2: - Add of_chosen/of_aliases populating and of_alias_scan() invocation
        for OF_PROMTREE.
        - Add locking
        - rework parse loop
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 3ff22e32b602..8abde58cbe82 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -17,14 +17,39 @@
  *      as published by the Free Software Foundation; either version
  *      2 of the License, or (at your option) any later version.
  */
+#include <linux/ctype.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/spinlock.h>
 #include <linux/slab.h>
 #include <linux/proc_fs.h>
 
+/**
+ * struct alias_prop - Alias property in 'aliases' node
+ * @link:	List node to link the structure in aliases_lookup list
+ * @alias:	Alias property name
+ * @np:		Pointer to device_node that the alias stands for
+ * @id:		Index value from end of alias name
+ * @stem:	Alias string without the index
+ *
+ * The structure represents one alias property of 'aliases' node as
+ * an entry in aliases_lookup list.
+ */
+struct alias_prop {
+	struct list_head link;
+	const char *alias;
+	struct device_node *np;
+	int id;
+	char stem[0];
+};
+
+static LIST_HEAD(aliases_lookup);
+
 struct device_node *allnodes;
 struct device_node *of_chosen;
+struct device_node *of_aliases;
+
+static DEFINE_MUTEX(of_aliases_mutex);
 
 /* use when traversing tree through the allnext, child, sibling,
  * or parent members of struct device_node.
@@ -988,3 +1013,99 @@ void of_detach_node(struct device_node *np)
 }
 #endif /* defined(CONFIG_OF_DYNAMIC) */
 
+static void of_alias_add(struct alias_prop *ap, struct device_node *np,
+			 int id, const char *stem, int stem_len)
+{
+	ap->np = np;
+	ap->id = id;
+	strncpy(ap->stem, stem, stem_len);
+	ap->stem[stem_len] = 0;
+	list_add_tail(&ap->link, &aliases_lookup);
+	pr_debug("adding DT alias:%s: stem=%s id=%i node=%s\n",
+		 ap->alias, ap->stem, ap->id, np ? np->full_name : NULL);
+}
+
+/**
+ * of_alias_scan - Scan all properties of 'aliases' node
+ *
+ * The function scans all the properties of 'aliases' node and populate
+ * the the global lookup table with the properties.  It returns the
+ * number of alias_prop found, or error code in error case.
+ *
+ * @dt_alloc:	An allocator that provides a virtual address to memory
+ *		for the resulting tree
+ */
+void of_alias_scan(void * (*dt_alloc)(u64 size, u64 align))
+{
+	struct property *pp;
+
+	of_chosen = of_find_node_by_path("/chosen");
+	if (of_chosen == NULL)
+		of_chosen = of_find_node_by_path("/chosen@0");
+	of_aliases = of_find_node_by_path("/aliases");
+	if (!of_aliases)
+		return;
+
+	for_each_property(pp, of_aliases->properties) {
+		const char *start = pp->name;
+		const char *end = start + strlen(start);
+		struct device_node *np;
+		struct alias_prop *ap;
+		int id, len;
+
+		/* Skip those we do not want to proceed */
+		if (!strcmp(pp->name, "name") ||
+		    !strcmp(pp->name, "phandle") ||
+		    !strcmp(pp->name, "linux,phandle"))
+			continue;
+
+		np = of_find_node_by_path(pp->value);
+		if (!np)
+			continue;
+
+		/* walk the alias backwards to extract the id and work out
+		 * the 'stem' string */
+		while (isdigit(*(end-1)) && end > start)
+			end--;
+		len = end - start;
+
+		if (kstrtoint(end, 10, &id) < 0)
+			continue;
+
+		/* Allocate an alias_prop with enough space for the stem */
+		ap = dt_alloc(sizeof(*ap) + len + 1, 4);
+		if (!ap)
+			continue;
+		ap->alias = start;
+		of_alias_add(ap, np, id, start, len);
+	}
+}
+
+/**
+ * of_alias_get_id - Get alias id for the given device_node
+ * @np:		Pointer to the given device_node
+ * @stem:	Alias stem of the given device_node
+ *
+ * The function travels the lookup table to get alias id for the given
+ * device_node and alias stem.  It returns the alias id if find it.
+ */
+int of_alias_get_id(struct device_node *np, const char *stem)
+{
+	struct alias_prop *app;
+	int id = -ENODEV;
+
+	mutex_lock(&of_aliases_mutex);
+	list_for_each_entry(app, &aliases_lookup, link) {
+		if (strcmp(app->stem, stem) != 0)
+			continue;
+
+		if (np == app->np) {
+			id = app->id;
+			break;
+		}
+	}
+	mutex_unlock(&of_aliases_mutex);
+
+	return id;
+}
+EXPORT_SYMBOL_GPL(of_alias_get_id);

commit fe55c1844a1c106e9d9d3dd27cbfcf8caeb9e77e
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Aug 4 10:27:32 2011 +0100

    Revert "dt: add of_alias_scan and of_alias_get_id"
    
    This reverts commit 750f463a749e28464151ad26938d11b07b1c43cb.
    
    of_alias_* still needs work to be generalized for 'promtree' dt
    platforms, and to no implicitly create entries for available ids.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index fb28b5af733b..3ff22e32b602 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -17,39 +17,14 @@
  *      as published by the Free Software Foundation; either version
  *      2 of the License, or (at your option) any later version.
  */
-#include <linux/ctype.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/spinlock.h>
 #include <linux/slab.h>
 #include <linux/proc_fs.h>
 
-/**
- * struct alias_prop - Alias property in 'aliases' node
- * @link:	List node to link the structure in aliases_lookup list
- * @alias:	Alias property name
- * @np:		Pointer to device_node that the alias stands for
- * @id:		Index value from end of alias name
- * @stem:	Alias string without the index
- *
- * The structure represents one alias property of 'aliases' node as
- * an entry in aliases_lookup list.
- */
-struct alias_prop {
-	struct list_head link;
-	const char *alias;
-	struct device_node *np;
-	int id;
-	char stem[0];
-};
-
-static LIST_HEAD(aliases_lookup);
-
 struct device_node *allnodes;
 struct device_node *of_chosen;
-struct device_node *of_aliases;
-
-static DEFINE_MUTEX(of_aliases_mutex);
 
 /* use when traversing tree through the allnext, child, sibling,
  * or parent members of struct device_node.
@@ -1013,108 +988,3 @@ void of_detach_node(struct device_node *np)
 }
 #endif /* defined(CONFIG_OF_DYNAMIC) */
 
-static void of_alias_add(struct alias_prop *ap, struct device_node *np,
-			 int id, const char *stem, int stem_len)
-{
-	ap->id = id;
-	ap->np = np;
-	strncpy(ap->stem, stem, stem_len);
-	ap->stem[stem_len] = 0;
-	list_add_tail(&ap->link, &aliases_lookup);
-	pr_debug("adding DT alias:%s: stem=%s id=%i node=%s\n",
-		 ap->alias, ap->stem, ap->id, np ? np->full_name : NULL);
-}
-
-/**
- * of_alias_scan() - Scan all properties of 'aliases' node
- *
- * The function scans all the properties of 'aliases' node and populate
- * the global lookup table with the properties.  It returns the
- * number of alias_prop found, or error code in error case.
- */
-__init void of_alias_scan(void)
-{
-	struct property *pp;
-
-	if (!of_aliases)
-		return;
-
-	for_each_property(pp, of_aliases->properties) {
-		const char *start = pp->name;
-		const char *end = start + strlen(start);
-		struct device_node *np;
-		struct alias_prop *ap;
-		int id, len;
-
-		/* Skip those we do not want to proceed */
-		if (!strcmp(pp->name, "name") ||
-		    !strcmp(pp->name, "phandle") ||
-		    !strcmp(pp->name, "linux,phandle"))
-			continue;
-
-		np = of_find_node_by_path(pp->value);
-		if (!np)
-			continue;
-
-		/* walk alias backwards to extract the id and 'stem' string */
-		while (isdigit(*(end-1)) && end > start)
-			end--;
-		len = end - start;
-		id = strlen(end) ? simple_strtoul(end, NULL, 10) : -1;
-
-		/* Allocate an alias_prop with enough space for the stem */
-		ap = early_init_dt_alloc_memory_arch(sizeof(*ap) + len + 1, 4);
-		if (!ap)
-			continue;
-		ap->alias = start;
-		of_alias_add(ap, np, id, start, len);
-	}
-}
-
-/**
- * of_alias_get_id() - Get alias id for the given device_node
- * @np:		Pointer to the given device_node
- * @stem:	Alias stem of the given device_node
- *
- * The function travels the lookup table to get alias id for the given
- * device_node and alias stem.  It returns the alias id if find it.
- * If not, dynamically creates one in the lookup table and returns it,
- * or returns error code if fail to create.
- */
-int of_alias_get_id(struct device_node *np, const char *stem)
-{
-	struct alias_prop *app;
-	int id = 0;
-	bool found = false;
-
-	mutex_lock(&of_aliases_mutex);
-	list_for_each_entry(app, &aliases_lookup, link) {
-		if (strcmp(app->stem, stem) != 0)
-			continue;
-
-		if (np == app->np) {
-			found = true;
-			id = app->id;
-			break;
-		}
-
-		if (id <= app->id)
-			id = app->id + 1;
-	}
-
-	/* If an id is not found, then allocate a new one */
-	if (!found) {
-		app = kzalloc(sizeof(*app) + strlen(stem) + 1, 4);
-		if (!app) {
-			id = -ENODEV;
-			goto out;
-		}
-		of_alias_add(app, np, id, stem, strlen(stem));
-	}
-
- out:
-	mutex_unlock(&of_aliases_mutex);
-
-	return id;
-}
-EXPORT_SYMBOL_GPL(of_alias_get_id);

commit 750f463a749e28464151ad26938d11b07b1c43cb
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Wed Aug 3 11:28:14 2011 +0100

    dt: add of_alias_scan and of_alias_get_id
    
    The patch adds function of_alias_scan to populate a global lookup
    table with the properties of 'aliases' node and function
    of_alias_get_id for drivers to find alias id from the lookup table.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    [grant.likely: add locking and rework parse loop]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 3ff22e32b602..fb28b5af733b 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -17,14 +17,39 @@
  *      as published by the Free Software Foundation; either version
  *      2 of the License, or (at your option) any later version.
  */
+#include <linux/ctype.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/spinlock.h>
 #include <linux/slab.h>
 #include <linux/proc_fs.h>
 
+/**
+ * struct alias_prop - Alias property in 'aliases' node
+ * @link:	List node to link the structure in aliases_lookup list
+ * @alias:	Alias property name
+ * @np:		Pointer to device_node that the alias stands for
+ * @id:		Index value from end of alias name
+ * @stem:	Alias string without the index
+ *
+ * The structure represents one alias property of 'aliases' node as
+ * an entry in aliases_lookup list.
+ */
+struct alias_prop {
+	struct list_head link;
+	const char *alias;
+	struct device_node *np;
+	int id;
+	char stem[0];
+};
+
+static LIST_HEAD(aliases_lookup);
+
 struct device_node *allnodes;
 struct device_node *of_chosen;
+struct device_node *of_aliases;
+
+static DEFINE_MUTEX(of_aliases_mutex);
 
 /* use when traversing tree through the allnext, child, sibling,
  * or parent members of struct device_node.
@@ -988,3 +1013,108 @@ void of_detach_node(struct device_node *np)
 }
 #endif /* defined(CONFIG_OF_DYNAMIC) */
 
+static void of_alias_add(struct alias_prop *ap, struct device_node *np,
+			 int id, const char *stem, int stem_len)
+{
+	ap->id = id;
+	ap->np = np;
+	strncpy(ap->stem, stem, stem_len);
+	ap->stem[stem_len] = 0;
+	list_add_tail(&ap->link, &aliases_lookup);
+	pr_debug("adding DT alias:%s: stem=%s id=%i node=%s\n",
+		 ap->alias, ap->stem, ap->id, np ? np->full_name : NULL);
+}
+
+/**
+ * of_alias_scan() - Scan all properties of 'aliases' node
+ *
+ * The function scans all the properties of 'aliases' node and populate
+ * the global lookup table with the properties.  It returns the
+ * number of alias_prop found, or error code in error case.
+ */
+__init void of_alias_scan(void)
+{
+	struct property *pp;
+
+	if (!of_aliases)
+		return;
+
+	for_each_property(pp, of_aliases->properties) {
+		const char *start = pp->name;
+		const char *end = start + strlen(start);
+		struct device_node *np;
+		struct alias_prop *ap;
+		int id, len;
+
+		/* Skip those we do not want to proceed */
+		if (!strcmp(pp->name, "name") ||
+		    !strcmp(pp->name, "phandle") ||
+		    !strcmp(pp->name, "linux,phandle"))
+			continue;
+
+		np = of_find_node_by_path(pp->value);
+		if (!np)
+			continue;
+
+		/* walk alias backwards to extract the id and 'stem' string */
+		while (isdigit(*(end-1)) && end > start)
+			end--;
+		len = end - start;
+		id = strlen(end) ? simple_strtoul(end, NULL, 10) : -1;
+
+		/* Allocate an alias_prop with enough space for the stem */
+		ap = early_init_dt_alloc_memory_arch(sizeof(*ap) + len + 1, 4);
+		if (!ap)
+			continue;
+		ap->alias = start;
+		of_alias_add(ap, np, id, start, len);
+	}
+}
+
+/**
+ * of_alias_get_id() - Get alias id for the given device_node
+ * @np:		Pointer to the given device_node
+ * @stem:	Alias stem of the given device_node
+ *
+ * The function travels the lookup table to get alias id for the given
+ * device_node and alias stem.  It returns the alias id if find it.
+ * If not, dynamically creates one in the lookup table and returns it,
+ * or returns error code if fail to create.
+ */
+int of_alias_get_id(struct device_node *np, const char *stem)
+{
+	struct alias_prop *app;
+	int id = 0;
+	bool found = false;
+
+	mutex_lock(&of_aliases_mutex);
+	list_for_each_entry(app, &aliases_lookup, link) {
+		if (strcmp(app->stem, stem) != 0)
+			continue;
+
+		if (np == app->np) {
+			found = true;
+			id = app->id;
+			break;
+		}
+
+		if (id <= app->id)
+			id = app->id + 1;
+	}
+
+	/* If an id is not found, then allocate a new one */
+	if (!found) {
+		app = kzalloc(sizeof(*app) + strlen(stem) + 1, 4);
+		if (!app) {
+			id = -ENODEV;
+			goto out;
+		}
+		of_alias_add(app, np, id, stem, strlen(stem));
+	}
+
+ out:
+	mutex_unlock(&of_aliases_mutex);
+
+	return id;
+}
+EXPORT_SYMBOL_GPL(of_alias_get_id);

commit aac285c6cb9622f1cc05ed162604bf5ad2da9a8d
Author: Jamie Iles <jamie@jamieiles.com>
Date:   Tue Aug 2 15:45:07 2011 +0100

    of: constify property name parameters for helper functions
    
    The helper functions for reading u32 integers, u32 arrays and strings
    should have the property name as a const pointer.
    
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Jamie Iles <jamie@jamieiles.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 02ed36719def..3ff22e32b602 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -610,8 +610,9 @@ EXPORT_SYMBOL(of_find_node_by_phandle);
  *
  * The out_value is modified only if a valid u32 value can be decoded.
  */
-int of_property_read_u32_array(const struct device_node *np, char *propname,
-			       u32 *out_values, size_t sz)
+int of_property_read_u32_array(const struct device_node *np,
+			       const char *propname, u32 *out_values,
+			       size_t sz)
 {
 	struct property *prop = of_find_property(np, propname, NULL);
 	const __be32 *val;
@@ -645,7 +646,7 @@ EXPORT_SYMBOL_GPL(of_property_read_u32_array);
  *
  * The out_string pointer is modified only if a valid string can be decoded.
  */
-int of_property_read_string(struct device_node *np, char *propname,
+int of_property_read_string(struct device_node *np, const char *propname,
 				const char **out_string)
 {
 	struct property *prop = of_find_property(np, propname, NULL);

commit 0e373639ad7c7ef2b0c9cf907574b266791b9778
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Wed Jul 6 15:42:58 2011 -0500

    dt: add helper function to read u32 arrays
    
    Rework of_property_read_u32 to read an array of values. Then
    of_property_read_u32 becomes an inline with array size of 1.
    
    Also make struct device_node ptr const.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 57ec27bed44f..02ed36719def 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -596,32 +596,39 @@ struct device_node *of_find_node_by_phandle(phandle handle)
 EXPORT_SYMBOL(of_find_node_by_phandle);
 
 /**
- * of_property_read_u32 - Find and read a 32 bit integer from a property
+ * of_property_read_u32_array - Find and read an array of 32 bit integers
+ * from a property.
+ *
  * @np:		device node from which the property value is to be read.
  * @propname:	name of the property to be searched.
  * @out_value:	pointer to return value, modified only if return value is 0.
  *
- * Search for a property in a device node and read a 32-bit value from
+ * Search for a property in a device node and read 32-bit value(s) from
  * it. Returns 0 on success, -EINVAL if the property does not exist,
  * -ENODATA if property does not have a value, and -EOVERFLOW if the
  * property data isn't large enough.
  *
  * The out_value is modified only if a valid u32 value can be decoded.
  */
-int of_property_read_u32(struct device_node *np, char *propname, u32 *out_value)
+int of_property_read_u32_array(const struct device_node *np, char *propname,
+			       u32 *out_values, size_t sz)
 {
 	struct property *prop = of_find_property(np, propname, NULL);
+	const __be32 *val;
 
 	if (!prop)
 		return -EINVAL;
 	if (!prop->value)
 		return -ENODATA;
-	if (sizeof(*out_value) > prop->length)
+	if ((sz * sizeof(*out_values)) > prop->length)
 		return -EOVERFLOW;
-	*out_value = be32_to_cpup(prop->value);
+
+	val = prop->value;
+	while (sz--)
+		*out_values++ = be32_to_cpup(val++);
 	return 0;
 }
-EXPORT_SYMBOL_GPL(of_property_read_u32);
+EXPORT_SYMBOL_GPL(of_property_read_u32_array);
 
 /**
  * of_property_read_string - Find and read a string from a property

commit f09bc831b7693f93ecb95dea7180d55b45b88e76
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Mon Jul 4 09:01:18 2011 +0800

    dt: add 'const' for of_property_read_string parameter **out_string
    
    The existing dt codes usually call of_get_property to get a string
    property and save it as a 'const char *'.  The patch adds'const' for
    of_property_read_string parameter **out_string to make the converting
    of existing code a little easier.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index b8b65fddbeb5..57ec27bed44f 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -639,7 +639,7 @@ EXPORT_SYMBOL_GPL(of_property_read_u32);
  * The out_string pointer is modified only if a valid string can be decoded.
  */
 int of_property_read_string(struct device_node *np, char *propname,
-				char **out_string)
+				const char **out_string)
 {
 	struct property *prop = of_find_property(np, propname, NULL);
 	if (!prop)

commit a3b853633d78c3930b513ee219df48637ac82eed
Author: Thomas Abraham <thomas.abraham@linaro.org>
Date:   Thu Jun 30 21:26:10 2011 +0530

    dt: add helper functions to read u32 and string property values
    
    Add helper functions to retrieve unsigned integer and string property
    values from properties of a device node. These helper functions can be
    used to lookup a property in a device node, perform error checking and
    read the property value.
    
    [grant.likely@secretlab.ca: Proposal and initial implementation]
    Signed-off-by: Thomas Abraham <thomas.abraham@linaro.org>
    [grant.likely: some word smithing and be more defensive validating the string]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 632ebae7f17a..b8b65fddbeb5 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -595,6 +595,64 @@ struct device_node *of_find_node_by_phandle(phandle handle)
 }
 EXPORT_SYMBOL(of_find_node_by_phandle);
 
+/**
+ * of_property_read_u32 - Find and read a 32 bit integer from a property
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ * @out_value:	pointer to return value, modified only if return value is 0.
+ *
+ * Search for a property in a device node and read a 32-bit value from
+ * it. Returns 0 on success, -EINVAL if the property does not exist,
+ * -ENODATA if property does not have a value, and -EOVERFLOW if the
+ * property data isn't large enough.
+ *
+ * The out_value is modified only if a valid u32 value can be decoded.
+ */
+int of_property_read_u32(struct device_node *np, char *propname, u32 *out_value)
+{
+	struct property *prop = of_find_property(np, propname, NULL);
+
+	if (!prop)
+		return -EINVAL;
+	if (!prop->value)
+		return -ENODATA;
+	if (sizeof(*out_value) > prop->length)
+		return -EOVERFLOW;
+	*out_value = be32_to_cpup(prop->value);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(of_property_read_u32);
+
+/**
+ * of_property_read_string - Find and read a string from a property
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ * @out_string:	pointer to null terminated return string, modified only if
+ *		return value is 0.
+ *
+ * Search for a property in a device tree node and retrieve a null
+ * terminated string value (pointer to data, not a copy). Returns 0 on
+ * success, -EINVAL if the property does not exist, -ENODATA if property
+ * does not have a value, and -EILSEQ if the string is not null-terminated
+ * within the length of the property data.
+ *
+ * The out_string pointer is modified only if a valid string can be decoded.
+ */
+int of_property_read_string(struct device_node *np, char *propname,
+				char **out_string)
+{
+	struct property *prop = of_find_property(np, propname, NULL);
+	if (!prop)
+		return -EINVAL;
+	if (!prop->value)
+		return -ENODATA;
+	if (strnlen(prop->value, prop->length) >= prop->length)
+		return -EILSEQ;
+	*out_string = prop->value;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(of_property_read_string);
+
 /**
  * of_parse_phandle - Resolve a phandle property to a device_node pointer
  * @np: Pointer to device node holding phandle property

commit a52f07ecd143baee51623b063be5007585748a4f
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Mar 18 10:21:29 2011 -0600

    dt: protect against NULL matches passed to of_match_node()
    
    There are a few use cases where it is convenient to pass NULL to
    of_match_node() and have it fail gracefully.  The patch adds a null
    check to the beginning so taht it does so.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 710b53bfac6d..632ebae7f17a 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -496,6 +496,9 @@ EXPORT_SYMBOL(of_find_node_with_property);
 const struct of_device_id *of_match_node(const struct of_device_id *matches,
 					 const struct device_node *node)
 {
+	if (!matches)
+		return NULL;
+
 	while (matches->name[0] || matches->type[0] || matches->compatible[0]) {
 		int match = 1;
 		if (matches->name[0])

commit a9fadeefdc869ff792591f57a9e33d8790d63292
Author: Jeremy Kerr <jeremy.kerr@canonical.com>
Date:   Sun Oct 10 21:24:10 2010 -0600

    of: use __be32 types for big-endian device tree data
    
    Use the sparse annotations so we can keep track of endianness.
    
    Signed-off-by: Jeremy Kerr <jeremy.kerr@canonical.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index aa805250de76..710b53bfac6d 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -33,7 +33,7 @@ DEFINE_RWLOCK(devtree_lock);
 
 int of_n_addr_cells(struct device_node *np)
 {
-	const int *ip;
+	const __be32 *ip;
 
 	do {
 		if (np->parent)
@@ -49,7 +49,7 @@ EXPORT_SYMBOL(of_n_addr_cells);
 
 int of_n_size_cells(struct device_node *np)
 {
-	const int *ip;
+	const __be32 *ip;
 
 	do {
 		if (np->parent)

commit 9a6b2e588c7809e86161236da3d29581bf5f8402
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Jul 23 01:48:25 2010 -0600

    of: Fix phandle endian issues
    
    The flat tree code wasn't fixing the endianness on phandle values when
    unflattening the tree, and the code in drivers/of wasn't always doing a
    be32_to_cpu before trying to dereference the phandle values.  This patch
    fixes them.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index e3f7af882e45..aa805250de76 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -605,14 +605,14 @@ EXPORT_SYMBOL(of_find_node_by_phandle);
 struct device_node *
 of_parse_phandle(struct device_node *np, const char *phandle_name, int index)
 {
-	const phandle *phandle;
+	const __be32 *phandle;
 	int size;
 
 	phandle = of_get_property(np, phandle_name, &size);
 	if ((!phandle) || (size < sizeof(*phandle) * (index + 1)))
 		return NULL;
 
-	return of_find_node_by_phandle(phandle[index]);
+	return of_find_node_by_phandle(be32_to_cpup(phandle + index));
 }
 EXPORT_SYMBOL(of_parse_phandle);
 
@@ -668,16 +668,16 @@ int of_parse_phandles_with_args(struct device_node *np, const char *list_name,
 
 	while (list < list_end) {
 		const __be32 *cells;
-		const phandle *phandle;
+		phandle phandle;
 
-		phandle = list++;
+		phandle = be32_to_cpup(list++);
 		args = list;
 
 		/* one cell hole in the list = <>; */
-		if (!*phandle)
+		if (!phandle)
 			goto next;
 
-		node = of_find_node_by_phandle(*phandle);
+		node = of_find_node_by_phandle(phandle);
 		if (!node) {
 			pr_debug("%s: could not find phandle\n",
 				 np->full_name);

commit 2ffe8c5f323c3b9749bf7bc2375d909d20bdbb15
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Jun 8 07:48:19 2010 -0600

    of: refactor of_modalias_node() and remove explicit match table.
    
    This patch tightens up the behaviour of of_modalias_node() to be more
    predicatable and to eliminate the explicit of_modalias_tablep[] that
    is currently used to override the first entry in the compatible list
    of a device.  The override table was needed originally because spi
    and i2c drivers had no way to do of-style matching.  Now that all
    devices can have an of_node pointer, and all drivers can have an
    of_match_table, the explicit override table is no longer needed
    because each driver can specify its own OF-style match data.
    
    The mpc8349emitx-mcu driver is modified to explicitly specify the
    correct device to bind against.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index b5ad9740d8b2..e3f7af882e45 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -544,75 +544,29 @@ struct device_node *of_find_matching_node(struct device_node *from,
 }
 EXPORT_SYMBOL(of_find_matching_node);
 
-/**
- * of_modalias_table: Table of explicit compatible ==> modalias mappings
- *
- * This table allows particulare compatible property values to be mapped
- * to modalias strings.  This is useful for busses which do not directly
- * understand the OF device tree but are populated based on data contained
- * within the device tree.  SPI and I2C are the two current users of this
- * table.
- *
- * In most cases, devices do not need to be listed in this table because
- * the modalias value can be derived directly from the compatible table.
- * However, if for any reason a value cannot be derived, then this table
- * provides a method to override the implicit derivation.
- *
- * At the moment, a single table is used for all bus types because it is
- * assumed that the data size is small and that the compatible values
- * should already be distinct enough to differentiate between SPI, I2C
- * and other devices.
- */
-struct of_modalias_table {
-	char *of_device;
-	char *modalias;
-};
-static struct of_modalias_table of_modalias_table[] = {
-	{ "fsl,mcu-mpc8349emitx", "mcu-mpc8349emitx" },
-	{ "mmc-spi-slot", "mmc_spi" },
-};
-
 /**
  * of_modalias_node - Lookup appropriate modalias for a device node
  * @node:	pointer to a device tree node
  * @modalias:	Pointer to buffer that modalias value will be copied into
  * @len:	Length of modalias value
  *
- * Based on the value of the compatible property, this routine will determine
- * an appropriate modalias value for a particular device tree node.  Two
- * separate methods are attempted to derive a modalias value.
+ * Based on the value of the compatible property, this routine will attempt
+ * to choose an appropriate modalias value for a particular device tree node.
+ * It does this by stripping the manufacturer prefix (as delimited by a ',')
+ * from the first entry in the compatible list property.
  *
- * First method is to lookup the compatible value in of_modalias_table.
- * Second is to strip off the manufacturer prefix from the first
- * compatible entry and use the remainder as modalias
- *
- * This routine returns 0 on success
+ * This routine returns 0 on success, <0 on failure.
  */
 int of_modalias_node(struct device_node *node, char *modalias, int len)
 {
-	int i, cplen;
-	const char *compatible;
-	const char *p;
-
-	/* 1. search for exception list entry */
-	for (i = 0; i < ARRAY_SIZE(of_modalias_table); i++) {
-		compatible = of_modalias_table[i].of_device;
-		if (!of_device_is_compatible(node, compatible))
-			continue;
-		strlcpy(modalias, of_modalias_table[i].modalias, len);
-		return 0;
-	}
+	const char *compatible, *p;
+	int cplen;
 
 	compatible = of_get_property(node, "compatible", &cplen);
-	if (!compatible)
+	if (!compatible || strlen(compatible) > cplen)
 		return -ENODEV;
-
-	/* 2. take first compatible entry and strip manufacturer */
 	p = strchr(compatible, ',');
-	if (!p)
-		return -ENODEV;
-	p++;
-	strlcpy(modalias, p, len);
+	strlcpy(modalias, p ? p + 1 : compatible, len);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(of_modalias_node);

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index cb96888d1427..b5ad9740d8b2 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -20,6 +20,7 @@
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/spinlock.h>
+#include <linux/slab.h>
 #include <linux/proc_fs.h>
 
 struct device_node *allnodes;

commit fc0bdae49d810e4cb32d7b547bc6d4dfb08f9e2e
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Sun Feb 14 07:13:55 2010 -0700

    of: move definition of of_chosen into common code.
    
    Rather than defining of_chosen in each arch, it can be defined for all
    in driver/of/base.c
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Michal Simek <monstr@monstr.eu>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 873479a21c80..cb96888d1427 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -23,6 +23,7 @@
 #include <linux/proc_fs.h>
 
 struct device_node *allnodes;
+struct device_node *of_chosen;
 
 /* use when traversing tree through the allnext, child, sibling,
  * or parent members of struct device_node.

commit 337148812f97368a8ec4a69f1691e4c5ce3af494
Author: Jeremy Kerr <jeremy.kerr@canonical.com>
Date:   Sat Jan 30 01:45:26 2010 -0700

    of: assume big-endian properties, adding conversions where necessary
    
    Properties in the device tree are specified as big-endian. At present,
    the only platforms to support device trees are also big-endian, so we've
    been acessing the properties as raw values.
    
    We'd like to add device tree support to little-endian platforms too, so
    add endian conversion to the sites where we access property values in
    the common of code.
    
    Compiled on powerpc (ppc44x_defconfig & ppc64_defconfig) and arm (fdt
    support only for now).
    
    Signed-off-by: Jeremy Kerr <jeremy.kerr@canonical.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 524645ab42a4..873479a21c80 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -38,7 +38,7 @@ int of_n_addr_cells(struct device_node *np)
 			np = np->parent;
 		ip = of_get_property(np, "#address-cells", NULL);
 		if (ip)
-			return *ip;
+			return be32_to_cpup(ip);
 	} while (np->parent);
 	/* No #address-cells property for the root node */
 	return OF_ROOT_NODE_ADDR_CELLS_DEFAULT;
@@ -54,7 +54,7 @@ int of_n_size_cells(struct device_node *np)
 			np = np->parent;
 		ip = of_get_property(np, "#size-cells", NULL);
 		if (ip)
-			return *ip;
+			return be32_to_cpup(ip);
 	} while (np->parent);
 	/* No #size-cells property for the root node */
 	return OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
@@ -696,8 +696,8 @@ int of_parse_phandles_with_args(struct device_node *np, const char *list_name,
 				const void **out_args)
 {
 	int ret = -EINVAL;
-	const u32 *list;
-	const u32 *list_end;
+	const __be32 *list;
+	const __be32 *list_end;
 	int size;
 	int cur_index = 0;
 	struct device_node *node = NULL;
@@ -711,7 +711,7 @@ int of_parse_phandles_with_args(struct device_node *np, const char *list_name,
 	list_end = list + size / sizeof(*list);
 
 	while (list < list_end) {
-		const u32 *cells;
+		const __be32 *cells;
 		const phandle *phandle;
 
 		phandle = list++;
@@ -735,7 +735,7 @@ int of_parse_phandles_with_args(struct device_node *np, const char *list_name,
 			goto err1;
 		}
 
-		list += *cells;
+		list += be32_to_cpup(cells);
 		if (list > list_end) {
 			pr_debug("%s: insufficient arguments length\n",
 				 np->full_name);

commit a9f2f63a671d5e91ed89ade408d87f1692a373de
Author: Jeremy Kerr <jeremy.kerr@canonical.com>
Date:   Mon Feb 1 21:34:14 2010 -0700

    of: include linux/proc_fs.h
    
    We use a few procfs-specific functions (eg, proc_device_tree_*) which
    aren't covered by the current includes. This causes the following build
    error on arm:
    
    drivers/of/base.c: In function 'prom_add_property':
    drivers/of/base.c:861: error: implicit declaration of function 'proc_device_tree_add_prop'
    drivers/of/base.c: In function 'prom_remove_property':
    drivers/of/base.c:902: error: implicit declaration of function 'proc_device_tree_remove_prop'
    drivers/of/base.c: In function 'prom_update_property':
    drivers/of/base.c:946: error: implicit declaration of function 'proc_device_tree_update_prop'
    
    Add proc_fs.h for these prototypes.
    
    Signed-off-by: Jeremy Kerr <jeremy.kerr@canonical.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 6bc8740c21ad..524645ab42a4 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -20,6 +20,7 @@
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/spinlock.h>
+#include <linux/proc_fs.h>
 
 struct device_node *allnodes;
 

commit 71a157e8edca55198e808f8561dd49017a54ee34
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Mon Feb 1 21:34:14 2010 -0700

    of: add 'of_' prefix to machine_is_compatible()
    
    machine is compatible is an OF-specific call.  It should have
    the of_ prefix to protect the global namespace.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Michal Simek <monstr@monstr.eu>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 785e9cc1b207..6bc8740c21ad 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -219,13 +219,13 @@ int of_device_is_compatible(const struct device_node *device,
 EXPORT_SYMBOL(of_device_is_compatible);
 
 /**
- * machine_is_compatible - Test root of device tree for a given compatible value
+ * of_machine_is_compatible - Test root of device tree for a given compatible value
  * @compat: compatible string to look for in root node's compatible property.
  *
  * Returns true if the root node has the given value in its
  * compatible property.
  */
-int machine_is_compatible(const char *compat)
+int of_machine_is_compatible(const char *compat)
 {
 	struct device_node *root;
 	int rc = 0;
@@ -237,7 +237,7 @@ int machine_is_compatible(const char *compat)
 	}
 	return rc;
 }
-EXPORT_SYMBOL(machine_is_compatible);
+EXPORT_SYMBOL(of_machine_is_compatible);
 
 /**
  *  of_device_is_available - check if a device is available for use

commit 89751a7cb70a20f0d604dd7c4be29dd7b0011718
Author: Jeremy Kerr <jeremy.kerr@canonical.com>
Date:   Mon Feb 1 21:34:11 2010 -0700

    of: merge of_find_node_by_phandle
    
    Merge common function between powerpc, sparc and microblaze. Code is
    identical for powerpc and microblaze, but adds a lock (and release) of
    the devtree_lock on sparc.
    
    Signed-off-by: Jeremy Kerr <jeremy.kerr@canonical.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 2ce58be314af..785e9cc1b207 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -614,6 +614,27 @@ int of_modalias_node(struct device_node *node, char *modalias, int len)
 }
 EXPORT_SYMBOL_GPL(of_modalias_node);
 
+/**
+ * of_find_node_by_phandle - Find a node given a phandle
+ * @handle:	phandle of the node to find
+ *
+ * Returns a node pointer with refcount incremented, use
+ * of_node_put() on it when done.
+ */
+struct device_node *of_find_node_by_phandle(phandle handle)
+{
+	struct device_node *np;
+
+	read_lock(&devtree_lock);
+	for (np = allnodes; np; np = np->allnext)
+		if (np->phandle == handle)
+			break;
+	of_node_get(np);
+	read_unlock(&devtree_lock);
+	return np;
+}
+EXPORT_SYMBOL(of_find_node_by_phandle);
+
 /**
  * of_parse_phandle - Resolve a phandle property to a device_node pointer
  * @np: Pointer to device node holding phandle property

commit fcdeb7fedf89f4bbc2e11959794968080cd8426e
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Jan 29 05:04:33 2010 -0700

    of: merge of_attach_node() & of_detach_node()
    
    Merge common code between PowerPC and Microblaze
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index cf89ee6253f3..2ce58be314af 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -870,3 +870,74 @@ int prom_update_property(struct device_node *np,
 
 	return 0;
 }
+
+#if defined(CONFIG_OF_DYNAMIC)
+/*
+ * Support for dynamic device trees.
+ *
+ * On some platforms, the device tree can be manipulated at runtime.
+ * The routines in this section support adding, removing and changing
+ * device tree nodes.
+ */
+
+/**
+ * of_attach_node - Plug a device node into the tree and global list.
+ */
+void of_attach_node(struct device_node *np)
+{
+	unsigned long flags;
+
+	write_lock_irqsave(&devtree_lock, flags);
+	np->sibling = np->parent->child;
+	np->allnext = allnodes;
+	np->parent->child = np;
+	allnodes = np;
+	write_unlock_irqrestore(&devtree_lock, flags);
+}
+
+/**
+ * of_detach_node - "Unplug" a node from the device tree.
+ *
+ * The caller must hold a reference to the node.  The memory associated with
+ * the node is not freed until its refcount goes to zero.
+ */
+void of_detach_node(struct device_node *np)
+{
+	struct device_node *parent;
+	unsigned long flags;
+
+	write_lock_irqsave(&devtree_lock, flags);
+
+	parent = np->parent;
+	if (!parent)
+		goto out_unlock;
+
+	if (allnodes == np)
+		allnodes = np->allnext;
+	else {
+		struct device_node *prev;
+		for (prev = allnodes;
+		     prev->allnext != np;
+		     prev = prev->allnext)
+			;
+		prev->allnext = np->allnext;
+	}
+
+	if (parent->child == np)
+		parent->child = np->sibling;
+	else {
+		struct device_node *prevsib;
+		for (prevsib = np->parent->child;
+		     prevsib->sibling != np;
+		     prevsib = prevsib->sibling)
+			;
+		prevsib->sibling = np->sibling;
+	}
+
+	of_node_set_flag(np, OF_DETACHED);
+
+out_unlock:
+	write_unlock_irqrestore(&devtree_lock, flags);
+}
+#endif /* defined(CONFIG_OF_DYNAMIC) */
+

commit 923f7e30b480438f1e86e01e5cde814248b59a39
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Jan 28 13:52:53 2010 -0700

    of: Merge of_node_get() and of_node_put()
    
    Merge common code between PowerPC and MicroBlaze
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index dba995b70b84..cf89ee6253f3 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -60,6 +60,81 @@ int of_n_size_cells(struct device_node *np)
 }
 EXPORT_SYMBOL(of_n_size_cells);
 
+#if !defined(CONFIG_SPARC)   /* SPARC doesn't do ref counting (yet) */
+/**
+ *	of_node_get - Increment refcount of a node
+ *	@node:	Node to inc refcount, NULL is supported to
+ *		simplify writing of callers
+ *
+ *	Returns node.
+ */
+struct device_node *of_node_get(struct device_node *node)
+{
+	if (node)
+		kref_get(&node->kref);
+	return node;
+}
+EXPORT_SYMBOL(of_node_get);
+
+static inline struct device_node *kref_to_device_node(struct kref *kref)
+{
+	return container_of(kref, struct device_node, kref);
+}
+
+/**
+ *	of_node_release - release a dynamically allocated node
+ *	@kref:  kref element of the node to be released
+ *
+ *	In of_node_put() this function is passed to kref_put()
+ *	as the destructor.
+ */
+static void of_node_release(struct kref *kref)
+{
+	struct device_node *node = kref_to_device_node(kref);
+	struct property *prop = node->properties;
+
+	/* We should never be releasing nodes that haven't been detached. */
+	if (!of_node_check_flag(node, OF_DETACHED)) {
+		pr_err("ERROR: Bad of_node_put() on %s\n", node->full_name);
+		dump_stack();
+		kref_init(&node->kref);
+		return;
+	}
+
+	if (!of_node_check_flag(node, OF_DYNAMIC))
+		return;
+
+	while (prop) {
+		struct property *next = prop->next;
+		kfree(prop->name);
+		kfree(prop->value);
+		kfree(prop);
+		prop = next;
+
+		if (!prop) {
+			prop = node->deadprops;
+			node->deadprops = NULL;
+		}
+	}
+	kfree(node->full_name);
+	kfree(node->data);
+	kfree(node);
+}
+
+/**
+ *	of_node_put - Decrement refcount of a node
+ *	@node:	Node to dec refcount, NULL is supported to
+ *		simplify writing of callers
+ *
+ */
+void of_node_put(struct device_node *node)
+{
+	if (node)
+		kref_put(&node->kref, of_node_release);
+}
+EXPORT_SYMBOL(of_node_put);
+#endif /* !CONFIG_SPARC */
+
 struct property *of_find_property(const struct device_node *np,
 				  const char *name,
 				  int *lenp)

commit 1f43cfb9474d1c4f22598b6e3213ec035be6dd56
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Jan 28 13:47:25 2010 -0700

    of: merge machine_is_compatible()
    
    Merge common code between PowerPC and Microblaze
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index ec56739eb247..dba995b70b84 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -143,6 +143,27 @@ int of_device_is_compatible(const struct device_node *device,
 }
 EXPORT_SYMBOL(of_device_is_compatible);
 
+/**
+ * machine_is_compatible - Test root of device tree for a given compatible value
+ * @compat: compatible string to look for in root node's compatible property.
+ *
+ * Returns true if the root node has the given value in its
+ * compatible property.
+ */
+int machine_is_compatible(const char *compat)
+{
+	struct device_node *root;
+	int rc = 0;
+
+	root = of_find_node_by_path("/");
+	if (root) {
+		rc = of_device_is_compatible(root, compat);
+		of_node_put(root);
+	}
+	return rc;
+}
+EXPORT_SYMBOL(machine_is_compatible);
+
 /**
  *  of_device_is_available - check if a device is available for use
  *

commit 02af11b03fce3ddb264d7873d7a2e295e697938c
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Mon Nov 23 20:16:45 2009 -0700

    of: merge prom_{add,remove,modify}_property
    
    Merge common code between PowerPC and MicroBlaze
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Reviewed-by: Wolfram Sang <w.sang@pengutronix.de>
    Tested-by: Michal Simek <monstr@monstr.eu>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index e6627b2320f1..ec56739eb247 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -658,3 +658,119 @@ int of_parse_phandles_with_args(struct device_node *np, const char *list_name,
 	return ret;
 }
 EXPORT_SYMBOL(of_parse_phandles_with_args);
+
+/**
+ * prom_add_property - Add a property to a node
+ */
+int prom_add_property(struct device_node *np, struct property *prop)
+{
+	struct property **next;
+	unsigned long flags;
+
+	prop->next = NULL;
+	write_lock_irqsave(&devtree_lock, flags);
+	next = &np->properties;
+	while (*next) {
+		if (strcmp(prop->name, (*next)->name) == 0) {
+			/* duplicate ! don't insert it */
+			write_unlock_irqrestore(&devtree_lock, flags);
+			return -1;
+		}
+		next = &(*next)->next;
+	}
+	*next = prop;
+	write_unlock_irqrestore(&devtree_lock, flags);
+
+#ifdef CONFIG_PROC_DEVICETREE
+	/* try to add to proc as well if it was initialized */
+	if (np->pde)
+		proc_device_tree_add_prop(np->pde, prop);
+#endif /* CONFIG_PROC_DEVICETREE */
+
+	return 0;
+}
+
+/**
+ * prom_remove_property - Remove a property from a node.
+ *
+ * Note that we don't actually remove it, since we have given out
+ * who-knows-how-many pointers to the data using get-property.
+ * Instead we just move the property to the "dead properties"
+ * list, so it won't be found any more.
+ */
+int prom_remove_property(struct device_node *np, struct property *prop)
+{
+	struct property **next;
+	unsigned long flags;
+	int found = 0;
+
+	write_lock_irqsave(&devtree_lock, flags);
+	next = &np->properties;
+	while (*next) {
+		if (*next == prop) {
+			/* found the node */
+			*next = prop->next;
+			prop->next = np->deadprops;
+			np->deadprops = prop;
+			found = 1;
+			break;
+		}
+		next = &(*next)->next;
+	}
+	write_unlock_irqrestore(&devtree_lock, flags);
+
+	if (!found)
+		return -ENODEV;
+
+#ifdef CONFIG_PROC_DEVICETREE
+	/* try to remove the proc node as well */
+	if (np->pde)
+		proc_device_tree_remove_prop(np->pde, prop);
+#endif /* CONFIG_PROC_DEVICETREE */
+
+	return 0;
+}
+
+/*
+ * prom_update_property - Update a property in a node.
+ *
+ * Note that we don't actually remove it, since we have given out
+ * who-knows-how-many pointers to the data using get-property.
+ * Instead we just move the property to the "dead properties" list,
+ * and add the new property to the property list
+ */
+int prom_update_property(struct device_node *np,
+			 struct property *newprop,
+			 struct property *oldprop)
+{
+	struct property **next;
+	unsigned long flags;
+	int found = 0;
+
+	write_lock_irqsave(&devtree_lock, flags);
+	next = &np->properties;
+	while (*next) {
+		if (*next == oldprop) {
+			/* found the node */
+			newprop->next = oldprop->next;
+			*next = newprop;
+			oldprop->next = np->deadprops;
+			np->deadprops = oldprop;
+			found = 1;
+			break;
+		}
+		next = &(*next)->next;
+	}
+	write_unlock_irqrestore(&devtree_lock, flags);
+
+	if (!found)
+		return -ENODEV;
+
+#ifdef CONFIG_PROC_DEVICETREE
+	/* try to add to proc as well if it was initialized */
+	if (np->pde)
+		proc_device_tree_update_prop(np->pde, newprop, oldprop);
+#endif /* CONFIG_PROC_DEVICETREE */
+
+	return 0;
+}

commit e91edcf5a2940bb7f1f316c871dfe9e2aaf9d6d9
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Oct 15 10:58:09 2009 -0600

    of: merge of_find_all_nodes() implementations
    
    Merge common code between Microblaze and PowerPC, and make it available
    to Sparc
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: David S. Miller <davem@davemloft.net>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>
    Acked-by: Michal Simek <monstr@monstr.eu>
    Acked-by: Stephen Neuendorffer <stephen.neuendorffer@xilinx.com>
    Acked-by: Stephen Rothwell <sfr@canb.auug.org.au>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index ddf224d456b2..e6627b2320f1 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -9,7 +9,8 @@
  *
  *  Adapted for sparc and sparc64 by David S. Miller davem@davemloft.net
  *
- *  Reconsolidated from arch/x/kernel/prom.c by Stephen Rothwell.
+ *  Reconsolidated from arch/x/kernel/prom.c by Stephen Rothwell and
+ *  Grant Likely.
  *
  *      This program is free software; you can redistribute it and/or
  *      modify it under the terms of the GNU General Public License
@@ -82,6 +83,29 @@ struct property *of_find_property(const struct device_node *np,
 }
 EXPORT_SYMBOL(of_find_property);
 
+/**
+ * of_find_all_nodes - Get next node in global list
+ * @prev:	Previous node or NULL to start iteration
+ *		of_node_put() will be called on it
+ *
+ * Returns a node pointer with refcount incremented, use
+ * of_node_put() on it when done.
+ */
+struct device_node *of_find_all_nodes(struct device_node *prev)
+{
+	struct device_node *np;
+
+	read_lock(&devtree_lock);
+	np = prev ? prev->allnext : allnodes;
+	for (; np != NULL; np = np->allnext)
+		if (of_node_get(np))
+			break;
+	of_node_put(prev);
+	read_unlock(&devtree_lock);
+	return np;
+}
+EXPORT_SYMBOL(of_find_all_nodes);
+
 /*
  * Find a property with a given name for a given node
  * and return the value.

commit 225d8b248843d1b3fbcf616d5e7d9544463aca3e
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Tue Sep 22 16:46:04 2009 -0700

    of: remove "stm,m25p40" alias
    
    The alias isn't needed any longer since the m25p80 driver converted to the
    module device table matching.
    
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: Jean Delvare <khali@linux-fr.org>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 69f85c07d17f..ddf224d456b2 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -447,7 +447,6 @@ struct of_modalias_table {
 static struct of_modalias_table of_modalias_table[] = {
 	{ "fsl,mcu-mpc8349emitx", "mcu-mpc8349emitx" },
 	{ "mmc-spi-slot", "mmc_spi" },
-	{ "stm,m25p40", "m25p80" },
 };
 
 /**

commit 2ed0e21b30b53d3a94e204196e523e6c8f732b56
Merge: 0fa213310cd8 9cbc1cb8cd46
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 15 09:40:05 2009 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next-2.6: (1244 commits)
      pkt_sched: Rename PSCHED_US2NS and PSCHED_NS2US
      ipv4: Fix fib_trie rebalancing
      Bluetooth: Fix issue with uninitialized nsh.type in DTL-1 driver
      Bluetooth: Fix Kconfig issue with RFKILL integration
      PIM-SM: namespace changes
      ipv4: update ARPD help text
      net: use a deferred timer in rt_check_expire
      ieee802154: fix kconfig bool/tristate muckup
      bonding: initialization rework
      bonding: use is_zero_ether_addr
      bonding: network device names are case sensative
      bonding: elminate bad refcount code
      bonding: fix style issues
      bonding: fix destructor
      bonding: remove bonding read/write semaphore
      bonding: initialize before registration
      bonding: bond_create always called with default parameters
      x_tables: Convert printk to pr_err
      netfilter: conntrack: optional reliable conntrack event delivery
      list_nulls: add hlist_nulls_add_head and hlist_nulls_del
      ...

commit bd78c33a096a73f09b1b998a481290e229382a8b
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Sat May 2 06:16:59 2009 +0400

    powerpc/85xx: Add STMicro M25P40 serial flash support for MPC8569E-MDS
    
    For serial flash support we need to:
    
    - Add QE Par IO Bank E device tree node, a GPIO from this bank is
      used for SPI chip-select line;
    - Add serial-flash node;
    - Add proper module alias into of/base.c.
    
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 41c5dfd85358..391f91c0bf55 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -447,6 +447,7 @@ struct of_modalias_table {
 static struct of_modalias_table of_modalias_table[] = {
 	{ "fsl,mcu-mpc8349emitx", "mcu-mpc8349emitx" },
 	{ "mmc-spi-slot", "mmc_spi" },
+	{ "stm,m25p40", "m25p80" },
 };
 
 /**

commit 739649c53d7f78f5bf41bdfd1a858ee90c7a687a
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Sat Apr 25 12:52:40 2009 +0000

    of: add of_parse_phandle() helper for parsing phandle properties
    
    of_parse_phandle() is a helper function to read and parse a phandle
    property and return a pointer to the resulting device_node.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Andy Fleming <afleming@freescale.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 41c5dfd85358..ddf224d456b2 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -494,6 +494,30 @@ int of_modalias_node(struct device_node *node, char *modalias, int len)
 }
 EXPORT_SYMBOL_GPL(of_modalias_node);
 
+/**
+ * of_parse_phandle - Resolve a phandle property to a device_node pointer
+ * @np: Pointer to device node holding phandle property
+ * @phandle_name: Name of property holding a phandle value
+ * @index: For properties holding a table of phandles, this is the index into
+ *         the table
+ *
+ * Returns the device_node pointer with refcount incremented.  Use
+ * of_node_put() on it when done.
+ */
+struct device_node *
+of_parse_phandle(struct device_node *np, const char *phandle_name, int index)
+{
+	const phandle *phandle;
+	int size;
+
+	phandle = of_get_property(np, phandle_name, &size);
+	if ((!phandle) || (size < sizeof(*phandle) * (index + 1)))
+		return NULL;
+
+	return of_find_node_by_phandle(phandle[index]);
+}
+EXPORT_SYMBOL(of_parse_phandle);
+
 /**
  * of_parse_phandles_with_args - Find a node pointed by phandle in a list
  * @np:		pointer to a device tree node containing a list

commit 3f1c6ebf57b815ad709e89291e446935fee78f75
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Tue Mar 31 15:24:38 2009 -0700

    powerpc: add mmc-spi-slot bindings
    
    The bindings describes a case where MMC/SD/SDIO slot directly connected to
    a SPI bus.  Such setups are widely used on embedded PowerPC boards.
    
    The patch also adds the mmc-spi-slot entry to the OpenFirmware modalias
    table.
    
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Cc: David Brownell <david-b@pacbell.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Kumar Gala <galak@gate.crashing.org>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index cd17092b82bd..41c5dfd85358 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -446,6 +446,7 @@ struct of_modalias_table {
 };
 static struct of_modalias_table of_modalias_table[] = {
 	{ "fsl,mcu-mpc8349emitx", "mcu-mpc8349emitx" },
+	{ "mmc-spi-slot", "mmc_spi" },
 };
 
 /**

commit 7736a3db98bed028d0e5235f8958a730acfd822e
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Fri Dec 5 08:15:46 2008 +0000

    of: of_parse_phandles_with_args() learns to differentiate 'hole' cells
    
    Given this list (contains three gpio specifiers, one of which is a hole):
    
    gpios = <&phandle1 1 2 3
             0 /* a hole */
             &phandle2 4 5 6>;
    
    of_parse_phandles_with_args() would report -ENOENT for the `hole'
    specifier item, the same error value is used to report the end of the
    list, for example.
    
    Sometimes we want to differentiate holes from real errors -- for
    example when we want to count all the [syntax correct] specifiers.
    
    With this patch of_parse_phandles_with_args() will report -EEXITS when
    somebody requested to parse a hole.
    
    Also, make the out_{node,args} arguments optional, when counting we
    don't really need the out values.
    
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index cf04d4dd4a53..cd17092b82bd 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -499,8 +499,8 @@ EXPORT_SYMBOL_GPL(of_modalias_node);
  * @list_name:	property name that contains a list
  * @cells_name:	property name that specifies phandles' arguments count
  * @index:	index of a phandle to parse out
- * @out_node:	pointer to device_node struct pointer (will be filled)
- * @out_args:	pointer to arguments pointer (will be filled)
+ * @out_node:	optional pointer to device_node struct pointer (will be filled)
+ * @out_args:	optional pointer to arguments pointer (will be filled)
  *
  * This function is useful to parse lists of phandles and their arguments.
  * Returns 0 on success and fills out_node and out_args, on error returns
@@ -534,7 +534,7 @@ int of_parse_phandles_with_args(struct device_node *np, const char *list_name,
 	int size;
 	int cur_index = 0;
 	struct device_node *node = NULL;
-	const void *args;
+	const void *args = NULL;
 
 	list = of_get_property(np, list_name, &size);
 	if (!list) {
@@ -580,16 +580,26 @@ int of_parse_phandles_with_args(struct device_node *np, const char *list_name,
 
 		of_node_put(node);
 		node = NULL;
+		args = NULL;
 		cur_index++;
 	}
 
 	if (!node) {
-		ret = -ENOENT;
+		/*
+		 * args w/o node indicates that the loop above has stopped at
+		 * the 'hole' cell. Report this differently.
+		 */
+		if (args)
+			ret = -EEXIST;
+		else
+			ret = -ENOENT;
 		goto err0;
 	}
 
-	*out_node = node;
-	*out_args = args;
+	if (out_node)
+		*out_node = node;
+	if (out_args)
+		*out_args = args;
 
 	return 0;
 err1:

commit c1bb7c6d04ebdf48998649100c5267a9139debf5
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Fri Dec 5 08:15:39 2008 +0000

    of: Minor simplification for the of_parse_phandles_with_args()
    
    By using 'list++' in the beginning we can simplify the code a
    little bit.
    
    Suggested-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 4f884a358a7b..cf04d4dd4a53 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -547,14 +547,12 @@ int of_parse_phandles_with_args(struct device_node *np, const char *list_name,
 		const u32 *cells;
 		const phandle *phandle;
 
-		phandle = list;
-		args = list + 1;
+		phandle = list++;
+		args = list;
 
 		/* one cell hole in the list = <>; */
-		if (!*phandle) {
-			list++;
+		if (!*phandle)
 			goto next;
-		}
 
 		node = of_find_node_by_phandle(*phandle);
 		if (!node) {
@@ -570,8 +568,7 @@ int of_parse_phandles_with_args(struct device_node *np, const char *list_name,
 			goto err1;
 		}
 
-		/* Next phandle is at offset of one phandle cell + #cells */
-		list += 1 + *cells;
+		list += *cells;
 		if (list > list_end) {
 			pr_debug("%s: insufficient arguments length\n",
 				 np->full_name);

commit 1e291b14c8f1101b9093434489bd4dc0e03f3d0f
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Wed Nov 12 18:54:42 2008 +0000

    of: Add helpers for finding device nodes which have a given property
    
    This commit adds a routine for finding a device node which has a
    certain property.  The contents of the property are not taken into
    account, merely the presence or absence of the property.
    
    Based on that routine, we add a for_each_ macro for iterating over all
    nodes that have a certain property.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 7c79e94a35ea..4f884a358a7b 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -328,6 +328,41 @@ struct device_node *of_find_compatible_node(struct device_node *from,
 }
 EXPORT_SYMBOL(of_find_compatible_node);
 
+/**
+ *	of_find_node_with_property - Find a node which has a property with
+ *                                   the given name.
+ *	@from:		The node to start searching from or NULL, the node
+ *			you pass will not be searched, only the next one
+ *			will; typically, you pass what the previous call
+ *			returned. of_node_put() will be called on it
+ *	@prop_name:	The name of the property to look for.
+ *
+ *	Returns a node pointer with refcount incremented, use
+ *	of_node_put() on it when done.
+ */
+struct device_node *of_find_node_with_property(struct device_node *from,
+	const char *prop_name)
+{
+	struct device_node *np;
+	struct property *pp;
+
+	read_lock(&devtree_lock);
+	np = from ? from->allnext : allnodes;
+	for (; np; np = np->allnext) {
+		for (pp = np->properties; pp != 0; pp = pp->next) {
+			if (of_prop_cmp(pp->name, prop_name) == 0) {
+				of_node_get(np);
+				goto out;
+			}
+		}
+	}
+out:
+	of_node_put(from);
+	read_unlock(&devtree_lock);
+	return np;
+}
+EXPORT_SYMBOL(of_find_node_with_property);
+
 /**
  * of_match_node - Tell if an device_node has a matching of_match structure
  *	@matches:	array of of device match structures to search in

commit 5006d1aae813727cc77cc56cca9e90ef748650ce
Merge: 22d660ffd0db 4c3ed7d61bd4
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Oct 14 10:11:27 2008 +1100

    Merge commit 'gcl/gcl-next'

commit 64b60e096fa391c56f93e6216115e6757bf86b7e
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Fri Oct 10 04:43:17 2008 +0000

    of: Add new helper of_parse_phandles_with_args()
    
    The helper is factored out of of_get_gpio(). Will be used by the QE
    pin multiplexing functions (they need to parse the gpios = <> too).
    
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index cd1ce7ab8517..4270eb4a26a1 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -458,3 +458,112 @@ int of_modalias_node(struct device_node *node, char *modalias, int len)
 }
 EXPORT_SYMBOL_GPL(of_modalias_node);
 
+/**
+ * of_parse_phandles_with_args - Find a node pointed by phandle in a list
+ * @np:		pointer to a device tree node containing a list
+ * @list_name:	property name that contains a list
+ * @cells_name:	property name that specifies phandles' arguments count
+ * @index:	index of a phandle to parse out
+ * @out_node:	pointer to device_node struct pointer (will be filled)
+ * @out_args:	pointer to arguments pointer (will be filled)
+ *
+ * This function is useful to parse lists of phandles and their arguments.
+ * Returns 0 on success and fills out_node and out_args, on error returns
+ * appropriate errno value.
+ *
+ * Example:
+ *
+ * phandle1: node1 {
+ * 	#list-cells = <2>;
+ * }
+ *
+ * phandle2: node2 {
+ * 	#list-cells = <1>;
+ * }
+ *
+ * node3 {
+ * 	list = <&phandle1 1 2 &phandle2 3>;
+ * }
+ *
+ * To get a device_node of the `node2' node you may call this:
+ * of_parse_phandles_with_args(node3, "list", "#list-cells", 2, &node2, &args);
+ */
+int of_parse_phandles_with_args(struct device_node *np, const char *list_name,
+				const char *cells_name, int index,
+				struct device_node **out_node,
+				const void **out_args)
+{
+	int ret = -EINVAL;
+	const u32 *list;
+	const u32 *list_end;
+	int size;
+	int cur_index = 0;
+	struct device_node *node = NULL;
+	const void *args;
+
+	list = of_get_property(np, list_name, &size);
+	if (!list) {
+		ret = -ENOENT;
+		goto err0;
+	}
+	list_end = list + size / sizeof(*list);
+
+	while (list < list_end) {
+		const u32 *cells;
+		const phandle *phandle;
+
+		phandle = list;
+		args = list + 1;
+
+		/* one cell hole in the list = <>; */
+		if (!*phandle) {
+			list++;
+			goto next;
+		}
+
+		node = of_find_node_by_phandle(*phandle);
+		if (!node) {
+			pr_debug("%s: could not find phandle\n",
+				 np->full_name);
+			goto err0;
+		}
+
+		cells = of_get_property(node, cells_name, &size);
+		if (!cells || size != sizeof(*cells)) {
+			pr_debug("%s: could not get %s for %s\n",
+				 np->full_name, cells_name, node->full_name);
+			goto err1;
+		}
+
+		/* Next phandle is at offset of one phandle cell + #cells */
+		list += 1 + *cells;
+		if (list > list_end) {
+			pr_debug("%s: insufficient arguments length\n",
+				 np->full_name);
+			goto err1;
+		}
+next:
+		if (cur_index == index)
+			break;
+
+		of_node_put(node);
+		node = NULL;
+		cur_index++;
+	}
+
+	if (!node) {
+		ret = -ENOENT;
+		goto err0;
+	}
+
+	*out_node = node;
+	*out_args = args;
+
+	return 0;
+err1:
+	of_node_put(node);
+err0:
+	pr_debug("%s failed with status %d\n", __func__, ret);
+	return ret;
+}
+EXPORT_SYMBOL(of_parse_phandles_with_args);

commit 58f467ce1476f5b2a347cee3a32275b737fbd667
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Wed Oct 8 05:05:29 2008 +0000

    powerpc/of-bindings: Don't support linux,<modalias> "compatible" values
    
    Compatible property values in the form linux,<modalias> is not documented
    anywhere and using it leaks Linux implementation details into the device
    tree data (which is bad).  Remove support for compatible values of this
    form.
    
    If any platforms exist which depended on this code (and I don't know of
    any), then they can be fixed up by adding legacy translations to the
    lookup table in this file.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index ad8ac1a8af28..cd1ce7ab8517 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -420,13 +420,12 @@ static struct of_modalias_table of_modalias_table[] = {
  * @len:	Length of modalias value
  *
  * Based on the value of the compatible property, this routine will determine
- * an appropriate modalias value for a particular device tree node.  Three
- * separate methods are used to derive a modalias value.
+ * an appropriate modalias value for a particular device tree node.  Two
+ * separate methods are attempted to derive a modalias value.
  *
  * First method is to lookup the compatible value in of_modalias_table.
- * Second is to look for a "linux,<modalias>" entry in the compatible list
- * and used that for modalias.  Third is to strip off the manufacturer
- * prefix from the first compatible entry and use the remainder as modalias
+ * Second is to strip off the manufacturer prefix from the first
+ * compatible entry and use the remainder as modalias
  *
  * This routine returns 0 on success
  */
@@ -449,21 +448,7 @@ int of_modalias_node(struct device_node *node, char *modalias, int len)
 	if (!compatible)
 		return -ENODEV;
 
-	/* 2. search for linux,<modalias> entry */
-	p = compatible;
-	while (cplen > 0) {
-		if (!strncmp(p, "linux,", 6)) {
-			p += 6;
-			strlcpy(modalias, p, len);
-			return 0;
-		}
-
-		i = strlen(p) + 1;
-		p += i;
-		cplen -= i;
-	}
-
-	/* 3. take first compatible entry and strip manufacturer */
+	/* 2. take first compatible entry and strip manufacturer */
 	p = strchr(compatible, ',');
 	if (!p)
 		return -ENODEV;

commit 4c3ed7d61bd474380e0d3e1eb0da164942f7c84e
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Tue Sep 23 14:12:19 2008 +0400

    OF: add fsl,mcu-mpc8349emitx to the exception list
    
    of/base.c matches on the first (most specific) entries, which isn't
    quite practical but it was discussed[1] that this won't change.
    
    The bindings specifies verbose information for the devices, but
    it doesn't fit in the I2C ID's 20 characters limit. The limit won't
    change[2], and the bindings won't change either as they're correct.
    
    So we have to put an exception for the MPC8349E-mITX-compatible
    MCUs.
    
    [1] http://www.mail-archive.com/linuxppc-dev@ozlabs.org/msg21196.html
    [2] http://www.nabble.com/-PATCH-1-2--i2c:-expand-I2C's-id.name-to-23-characters-td19577063.html
    
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index ad8ac1a8af28..a7264644003f 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -410,7 +410,7 @@ struct of_modalias_table {
 	char *modalias;
 };
 static struct of_modalias_table of_modalias_table[] = {
-	/* Empty for now; add entries as needed */
+	{ "fsl,mcu-mpc8349emitx", "mcu-mpc8349emitx" },
 };
 
 /**

commit 3f07af494dfa6de43137dae430431c9fbf929c0c
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Jul 25 22:25:13 2008 -0400

    of: adapt of_find_i2c_driver() to be usable by SPI also
    
    SPI has a similar problem as I2C in that it needs to determine an
    appropriate modalias value for each device node.  This patch adapts
    the of_i2c of_find_i2c_driver() function to be usable by of_spi also.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 23ffb7c0caf2..ad8ac1a8af28 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -385,3 +385,91 @@ struct device_node *of_find_matching_node(struct device_node *from,
 	return np;
 }
 EXPORT_SYMBOL(of_find_matching_node);
+
+/**
+ * of_modalias_table: Table of explicit compatible ==> modalias mappings
+ *
+ * This table allows particulare compatible property values to be mapped
+ * to modalias strings.  This is useful for busses which do not directly
+ * understand the OF device tree but are populated based on data contained
+ * within the device tree.  SPI and I2C are the two current users of this
+ * table.
+ *
+ * In most cases, devices do not need to be listed in this table because
+ * the modalias value can be derived directly from the compatible table.
+ * However, if for any reason a value cannot be derived, then this table
+ * provides a method to override the implicit derivation.
+ *
+ * At the moment, a single table is used for all bus types because it is
+ * assumed that the data size is small and that the compatible values
+ * should already be distinct enough to differentiate between SPI, I2C
+ * and other devices.
+ */
+struct of_modalias_table {
+	char *of_device;
+	char *modalias;
+};
+static struct of_modalias_table of_modalias_table[] = {
+	/* Empty for now; add entries as needed */
+};
+
+/**
+ * of_modalias_node - Lookup appropriate modalias for a device node
+ * @node:	pointer to a device tree node
+ * @modalias:	Pointer to buffer that modalias value will be copied into
+ * @len:	Length of modalias value
+ *
+ * Based on the value of the compatible property, this routine will determine
+ * an appropriate modalias value for a particular device tree node.  Three
+ * separate methods are used to derive a modalias value.
+ *
+ * First method is to lookup the compatible value in of_modalias_table.
+ * Second is to look for a "linux,<modalias>" entry in the compatible list
+ * and used that for modalias.  Third is to strip off the manufacturer
+ * prefix from the first compatible entry and use the remainder as modalias
+ *
+ * This routine returns 0 on success
+ */
+int of_modalias_node(struct device_node *node, char *modalias, int len)
+{
+	int i, cplen;
+	const char *compatible;
+	const char *p;
+
+	/* 1. search for exception list entry */
+	for (i = 0; i < ARRAY_SIZE(of_modalias_table); i++) {
+		compatible = of_modalias_table[i].of_device;
+		if (!of_device_is_compatible(node, compatible))
+			continue;
+		strlcpy(modalias, of_modalias_table[i].modalias, len);
+		return 0;
+	}
+
+	compatible = of_get_property(node, "compatible", &cplen);
+	if (!compatible)
+		return -ENODEV;
+
+	/* 2. search for linux,<modalias> entry */
+	p = compatible;
+	while (cplen > 0) {
+		if (!strncmp(p, "linux,", 6)) {
+			p += 6;
+			strlcpy(modalias, p, len);
+			return 0;
+		}
+
+		i = strlen(p) + 1;
+		p += i;
+		cplen -= i;
+	}
+
+	/* 3. take first compatible entry and strip manufacturer */
+	p = strchr(compatible, ',');
+	if (!p)
+		return -ENODEV;
+	p++;
+	strlcpy(modalias, p, len);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(of_modalias_node);
+

commit 64e4566f6d590fbb284da061b9b664c2486dd2de
Author: Timur Tabi <timur@freescale.com>
Date:   Thu May 8 05:19:59 2008 +1000

    [POWERPC] Add null pointer check to of_find_property
    
    Update function of_find_property() to return NULL if the device_node
    passed to it is also NULL.  Otherwise, passing NULL will cause a null
    pointer dereference.
    
    Without this, the legacy_serial driver will crash if there's no
    'chosen' node in the device tree.
    
    Signed-off-by: Timur Tabi <timur@freescale.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 9bd7c4a31253..23ffb7c0caf2 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -65,6 +65,9 @@ struct property *of_find_property(const struct device_node *np,
 {
 	struct property *pp;
 
+	if (!np)
+		return NULL;
+
 	read_lock(&devtree_lock);
 	for (pp = np->properties; pp != 0; pp = pp->next) {
 		if (of_prop_cmp(pp->name, name) == 0) {

commit 834d97d452208279edf11c57eca150360d2dd1d6
Author: Josh Boyer <jwboyer@linux.vnet.ibm.com>
Date:   Thu Mar 27 00:33:14 2008 +1100

    [POWERPC] Add of_device_is_available function
    
    IEEE 1275 defined a standard "status" property to indicate the operational
    status of a device.  The property has four possible values: okay, disabled,
    fail, fail-xxx.  The absence of this property means the operational status
    of the device is unknown or okay.
    
    This adds a function called of_device_is_available that checks the state
    of the status property of a device.  If the property is absent or set to
    either "okay" or "ok", it returns 1.  Otherwise it returns 0.
    
    Signed-off-by: Josh Boyer <jwboyer@linux.vnet.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 80c9deca5f35..9bd7c4a31253 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -116,6 +116,32 @@ int of_device_is_compatible(const struct device_node *device,
 }
 EXPORT_SYMBOL(of_device_is_compatible);
 
+/**
+ *  of_device_is_available - check if a device is available for use
+ *
+ *  @device: Node to check for availability
+ *
+ *  Returns 1 if the status property is absent or set to "okay" or "ok",
+ *  0 otherwise
+ */
+int of_device_is_available(const struct device_node *device)
+{
+	const char *status;
+	int statlen;
+
+	status = of_get_property(device, "status", &statlen);
+	if (status == NULL)
+		return 1;
+
+	if (statlen > 0) {
+		if (!strcmp(status, "okay") || !strcmp(status, "ok"))
+			return 1;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(of_device_is_available);
+
 /**
  *	of_get_parent - Get a node's parent if any
  *	@node:	Node to get parent

commit f4eb010706b6c96c136c7aaa9079159743f33fa8
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Fri Oct 26 16:54:31 2007 +1000

    [POWERPC] Add of_get_next_parent()
    
    Iterating through a device node's parents is simple enough, but dealing
    with the refcounts properly is a little ugly, and replicating that logic
    is asking for someone to get it wrong or forget it all together, eg:
    
    while (dn != NULL) {
            /* loop body */
            tmp = of_get_parent(dn);
            of_node_put(dn);
            dn = tmp;
    }
    
    So add of_get_next_parent(), inspired by of_get_next_child().  The
    contract is that it returns the parent and drops the reference on the
    current node, this makes the loop look like:
    
    while (dn != NULL) {
            /* loop body */
            dn = of_get_next_parent(dn);
    }
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index b306fef1ac41..80c9deca5f35 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -137,6 +137,31 @@ struct device_node *of_get_parent(const struct device_node *node)
 }
 EXPORT_SYMBOL(of_get_parent);
 
+/**
+ *	of_get_next_parent - Iterate to a node's parent
+ *	@node:	Node to get parent of
+ *
+ * 	This is like of_get_parent() except that it drops the
+ * 	refcount on the passed node, making it suitable for iterating
+ * 	through a node's parents.
+ *
+ *	Returns a node pointer with refcount incremented, use
+ *	of_node_put() on it when done.
+ */
+struct device_node *of_get_next_parent(struct device_node *node)
+{
+	struct device_node *parent;
+
+	if (!node)
+		return NULL;
+
+	read_lock(&devtree_lock);
+	parent = of_node_get(node->parent);
+	of_node_put(node);
+	read_unlock(&devtree_lock);
+	return parent;
+}
+
 /**
  *	of_get_next_child - Iterate a node childs
  *	@node:	parent node

commit 283029d16a882539ab0027afd94ac52858d050b2
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Wed Jan 9 06:20:40 2008 +1100

    [POWERPC] Add of_find_matching_node() helper function
    
    Similar to of_find_compatible_node(), of_find_matching_node() and
    for_each_matching_node() allow you to iterate over the device tree
    looking for specific nodes, except that they take of_device_id
    tables instead of strings.
    
    This also moves of_match_node() from driver/of/device.c to
    driver/of/base.c to colocate it with the of_find_matching_node which
    depends on it.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 9377f3bc410a..b306fef1ac41 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -273,3 +273,61 @@ struct device_node *of_find_compatible_node(struct device_node *from,
 	return np;
 }
 EXPORT_SYMBOL(of_find_compatible_node);
+
+/**
+ * of_match_node - Tell if an device_node has a matching of_match structure
+ *	@matches:	array of of device match structures to search in
+ *	@node:		the of device structure to match against
+ *
+ *	Low level utility function used by device matching.
+ */
+const struct of_device_id *of_match_node(const struct of_device_id *matches,
+					 const struct device_node *node)
+{
+	while (matches->name[0] || matches->type[0] || matches->compatible[0]) {
+		int match = 1;
+		if (matches->name[0])
+			match &= node->name
+				&& !strcmp(matches->name, node->name);
+		if (matches->type[0])
+			match &= node->type
+				&& !strcmp(matches->type, node->type);
+		if (matches->compatible[0])
+			match &= of_device_is_compatible(node,
+						matches->compatible);
+		if (match)
+			return matches;
+		matches++;
+	}
+	return NULL;
+}
+EXPORT_SYMBOL(of_match_node);
+
+/**
+ *	of_find_matching_node - Find a node based on an of_device_id match
+ *				table.
+ *	@from:		The node to start searching from or NULL, the node
+ *			you pass will not be searched, only the next one
+ *			will; typically, you pass what the previous call
+ *			returned. of_node_put() will be called on it
+ *	@matches:	array of of device match structures to search in
+ *
+ *	Returns a node pointer with refcount incremented, use
+ *	of_node_put() on it when done.
+ */
+struct device_node *of_find_matching_node(struct device_node *from,
+					  const struct of_device_id *matches)
+{
+	struct device_node *np;
+
+	read_lock(&devtree_lock);
+	np = from ? from->allnext : allnodes;
+	for (; np; np = np->allnext) {
+		if (of_match_node(matches, np) && of_node_get(np))
+			break;
+	}
+	of_node_put(from);
+	read_unlock(&devtree_lock);
+	return np;
+}
+EXPORT_SYMBOL(of_find_matching_node);

commit 1ef4d4242d9c494c49ae1ae66dc938fce0272816
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Tue Apr 24 17:57:33 2007 +1000

    Consolidate of_find_node_by routines
    
    This consolidates the routines of_find_node_by_path, of_find_node_by_name,
    of_find_node_by_type and of_find_compatible_device.  Again, the comparison
    of strings are done differently by Sparc and PowerPC and also these add
    read_locks around the iterations.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Paul Mackerras <paulus@samba.org>
    Acked-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 6b6dfcc56522..9377f3bc410a 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -20,6 +20,8 @@
 #include <linux/of.h>
 #include <linux/spinlock.h>
 
+struct device_node *allnodes;
+
 /* use when traversing tree through the allnext, child, sibling,
  * or parent members of struct device_node.
  */
@@ -158,3 +160,116 @@ struct device_node *of_get_next_child(const struct device_node *node,
 	return next;
 }
 EXPORT_SYMBOL(of_get_next_child);
+
+/**
+ *	of_find_node_by_path - Find a node matching a full OF path
+ *	@path:	The full path to match
+ *
+ *	Returns a node pointer with refcount incremented, use
+ *	of_node_put() on it when done.
+ */
+struct device_node *of_find_node_by_path(const char *path)
+{
+	struct device_node *np = allnodes;
+
+	read_lock(&devtree_lock);
+	for (; np; np = np->allnext) {
+		if (np->full_name && (of_node_cmp(np->full_name, path) == 0)
+		    && of_node_get(np))
+			break;
+	}
+	read_unlock(&devtree_lock);
+	return np;
+}
+EXPORT_SYMBOL(of_find_node_by_path);
+
+/**
+ *	of_find_node_by_name - Find a node by its "name" property
+ *	@from:	The node to start searching from or NULL, the node
+ *		you pass will not be searched, only the next one
+ *		will; typically, you pass what the previous call
+ *		returned. of_node_put() will be called on it
+ *	@name:	The name string to match against
+ *
+ *	Returns a node pointer with refcount incremented, use
+ *	of_node_put() on it when done.
+ */
+struct device_node *of_find_node_by_name(struct device_node *from,
+	const char *name)
+{
+	struct device_node *np;
+
+	read_lock(&devtree_lock);
+	np = from ? from->allnext : allnodes;
+	for (; np; np = np->allnext)
+		if (np->name && (of_node_cmp(np->name, name) == 0)
+		    && of_node_get(np))
+			break;
+	of_node_put(from);
+	read_unlock(&devtree_lock);
+	return np;
+}
+EXPORT_SYMBOL(of_find_node_by_name);
+
+/**
+ *	of_find_node_by_type - Find a node by its "device_type" property
+ *	@from:	The node to start searching from, or NULL to start searching
+ *		the entire device tree. The node you pass will not be
+ *		searched, only the next one will; typically, you pass
+ *		what the previous call returned. of_node_put() will be
+ *		called on from for you.
+ *	@type:	The type string to match against
+ *
+ *	Returns a node pointer with refcount incremented, use
+ *	of_node_put() on it when done.
+ */
+struct device_node *of_find_node_by_type(struct device_node *from,
+	const char *type)
+{
+	struct device_node *np;
+
+	read_lock(&devtree_lock);
+	np = from ? from->allnext : allnodes;
+	for (; np; np = np->allnext)
+		if (np->type && (of_node_cmp(np->type, type) == 0)
+		    && of_node_get(np))
+			break;
+	of_node_put(from);
+	read_unlock(&devtree_lock);
+	return np;
+}
+EXPORT_SYMBOL(of_find_node_by_type);
+
+/**
+ *	of_find_compatible_node - Find a node based on type and one of the
+ *                                tokens in its "compatible" property
+ *	@from:		The node to start searching from or NULL, the node
+ *			you pass will not be searched, only the next one
+ *			will; typically, you pass what the previous call
+ *			returned. of_node_put() will be called on it
+ *	@type:		The type string to match "device_type" or NULL to ignore
+ *	@compatible:	The string to match to one of the tokens in the device
+ *			"compatible" list.
+ *
+ *	Returns a node pointer with refcount incremented, use
+ *	of_node_put() on it when done.
+ */
+struct device_node *of_find_compatible_node(struct device_node *from,
+	const char *type, const char *compatible)
+{
+	struct device_node *np;
+
+	read_lock(&devtree_lock);
+	np = from ? from->allnext : allnodes;
+	for (; np; np = np->allnext) {
+		if (type
+		    && !(np->type && (of_node_cmp(np->type, type) == 0)))
+			continue;
+		if (of_device_is_compatible(np, compatible) && of_node_get(np))
+			break;
+	}
+	of_node_put(from);
+	read_unlock(&devtree_lock);
+	return np;
+}
+EXPORT_SYMBOL(of_find_compatible_node);

commit d1cd355a5e44dfe993efc0c0458ca9f99a28a9a3
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Tue Apr 24 17:21:29 2007 +1000

    Consolidate of_get_next_child
    
    This adds a read_lock around the child/next accesses on Sparc.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Paul Mackerras <paulus@samba.org>
    Acked-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 82bb78680ff6..6b6dfcc56522 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -134,3 +134,27 @@ struct device_node *of_get_parent(const struct device_node *node)
 	return np;
 }
 EXPORT_SYMBOL(of_get_parent);
+
+/**
+ *	of_get_next_child - Iterate a node childs
+ *	@node:	parent node
+ *	@prev:	previous child of the parent node, or NULL to get first
+ *
+ *	Returns a node pointer with refcount incremented, use
+ *	of_node_put() on it when done.
+ */
+struct device_node *of_get_next_child(const struct device_node *node,
+	struct device_node *prev)
+{
+	struct device_node *next;
+
+	read_lock(&devtree_lock);
+	next = prev ? prev->sibling : node->child;
+	for (; next; next = next->sibling)
+		if (of_node_get(next))
+			break;
+	of_node_put(prev);
+	read_unlock(&devtree_lock);
+	return next;
+}
+EXPORT_SYMBOL(of_get_next_child);

commit e679c5f445fe142940e0962de9c5c82f10d9357c
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Tue Apr 24 17:16:16 2007 +1000

    Consolidate of_get_parent
    
    This requires creating dummy of_node_{get,put} routines for sparc and
    sparc64.  It also adds a read_lock around the parent accesses.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Paul Mackerras <paulus@samba.org>
    Acked-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 70b60845140e..82bb78680ff6 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -113,3 +113,24 @@ int of_device_is_compatible(const struct device_node *device,
 	return 0;
 }
 EXPORT_SYMBOL(of_device_is_compatible);
+
+/**
+ *	of_get_parent - Get a node's parent if any
+ *	@node:	Node to get parent
+ *
+ *	Returns a node pointer with refcount incremented, use
+ *	of_node_put() on it when done.
+ */
+struct device_node *of_get_parent(const struct device_node *node)
+{
+	struct device_node *np;
+
+	if (!node)
+		return NULL;
+
+	read_lock(&devtree_lock);
+	np = of_node_get(node->parent);
+	read_unlock(&devtree_lock);
+	return np;
+}
+EXPORT_SYMBOL(of_get_parent);

commit 581b605a83ec241a2aff8ef780e08b9414c8dfd8
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Tue Apr 24 16:46:53 2007 +1000

    Consolidate of_find_property
    
    The only change here is that a readlock is taken while the property list
    is being traversed on Sparc where it was not taken previously.
    
    Also, Sparc uses strcasecmp to compare property names while PowerPC
    uses strcmp.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Paul Mackerras <paulus@samba.org>
    Acked-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index d6dc5e74c27c..70b60845140e 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -18,6 +18,12 @@
  */
 #include <linux/module.h>
 #include <linux/of.h>
+#include <linux/spinlock.h>
+
+/* use when traversing tree through the allnext, child, sibling,
+ * or parent members of struct device_node.
+ */
+DEFINE_RWLOCK(devtree_lock);
 
 int of_n_addr_cells(struct device_node *np)
 {
@@ -51,6 +57,26 @@ int of_n_size_cells(struct device_node *np)
 }
 EXPORT_SYMBOL(of_n_size_cells);
 
+struct property *of_find_property(const struct device_node *np,
+				  const char *name,
+				  int *lenp)
+{
+	struct property *pp;
+
+	read_lock(&devtree_lock);
+	for (pp = np->properties; pp != 0; pp = pp->next) {
+		if (of_prop_cmp(pp->name, name) == 0) {
+			if (lenp != 0)
+				*lenp = pp->length;
+			break;
+		}
+	}
+	read_unlock(&devtree_lock);
+
+	return pp;
+}
+EXPORT_SYMBOL(of_find_property);
+
 /*
  * Find a property with a given name for a given node
  * and return the value.

commit 0081cbc3731de8ad4744ba433af51f17bf27eb9c
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Tue May 1 16:29:19 2007 +1000

    Consolidate of_device_is_compatible
    
    The only difference here is that Sparc uses strncmp to match compatibility
    names while PowerPC uses strncasecmp.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Paul Mackerras <paulus@samba.org>
    Acked-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 723d80d704e0..d6dc5e74c27c 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -63,3 +63,27 @@ const void *of_get_property(const struct device_node *np, const char *name,
 	return pp ? pp->value : NULL;
 }
 EXPORT_SYMBOL(of_get_property);
+
+/** Checks if the given "compat" string matches one of the strings in
+ * the device's "compatible" property
+ */
+int of_device_is_compatible(const struct device_node *device,
+		const char *compat)
+{
+	const char* cp;
+	int cplen, l;
+
+	cp = of_get_property(device, "compatible", &cplen);
+	if (cp == NULL)
+		return 0;
+	while (cplen > 0) {
+		if (of_compat_cmp(cp, compat, strlen(compat)) == 0)
+			return 1;
+		l = strlen(cp) + 1;
+		cp += l;
+		cplen -= l;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(of_device_is_compatible);

commit 97e873e5c8ad8711ce4cca080cff4eb5d21b3aeb
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Tue May 1 16:26:07 2007 +1000

    Start split out of common open firmware code
    
    This creates drivers/of/base.c (depending on CONFIG_OF) and puts
    the first trivially common bits from the prom.c files into it.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Paul Mackerras <paulus@samba.org>
    Acked-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/base.c b/drivers/of/base.c
new file mode 100644
index 000000000000..723d80d704e0
--- /dev/null
+++ b/drivers/of/base.c
@@ -0,0 +1,65 @@
+/*
+ * Procedures for creating, accessing and interpreting the device tree.
+ *
+ * Paul Mackerras	August 1996.
+ * Copyright (C) 1996-2005 Paul Mackerras.
+ *
+ *  Adapted for 64bit PowerPC by Dave Engebretsen and Peter Bergner.
+ *    {engebret|bergner}@us.ibm.com
+ *
+ *  Adapted for sparc and sparc64 by David S. Miller davem@davemloft.net
+ *
+ *  Reconsolidated from arch/x/kernel/prom.c by Stephen Rothwell.
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+#include <linux/module.h>
+#include <linux/of.h>
+
+int of_n_addr_cells(struct device_node *np)
+{
+	const int *ip;
+
+	do {
+		if (np->parent)
+			np = np->parent;
+		ip = of_get_property(np, "#address-cells", NULL);
+		if (ip)
+			return *ip;
+	} while (np->parent);
+	/* No #address-cells property for the root node */
+	return OF_ROOT_NODE_ADDR_CELLS_DEFAULT;
+}
+EXPORT_SYMBOL(of_n_addr_cells);
+
+int of_n_size_cells(struct device_node *np)
+{
+	const int *ip;
+
+	do {
+		if (np->parent)
+			np = np->parent;
+		ip = of_get_property(np, "#size-cells", NULL);
+		if (ip)
+			return *ip;
+	} while (np->parent);
+	/* No #size-cells property for the root node */
+	return OF_ROOT_NODE_SIZE_CELLS_DEFAULT;
+}
+EXPORT_SYMBOL(of_n_size_cells);
+
+/*
+ * Find a property with a given name for a given node
+ * and return the value.
+ */
+const void *of_get_property(const struct device_node *np, const char *name,
+			 int *lenp)
+{
+	struct property *pp = of_find_property(np, name, lenp);
+
+	return pp ? pp->value : NULL;
+}
+EXPORT_SYMBOL(of_get_property);
