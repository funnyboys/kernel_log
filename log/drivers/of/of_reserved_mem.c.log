commit 571d54ed91c0fae174d933683c0c2e11c84843d9
Merge: 9d71d3cd9ef0 8211d1e83ade
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 4 20:11:25 2020 -0700

    Merge tag 'devicetree-for-5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull devicetree updates from Rob Herring:
    
     - Convert various DT (non-binding) doc files to ReST
    
     - Various improvements to device link code
    
     - Fix __of_attach_node_sysfs refcounting bug
    
     - Add support for 'memory-region-names' with reserved-memory binding
    
     - Vendor prefixes for Protonic Holland, BeagleBoard.org, Alps, Check
       Point, WÃ¼rth Elektronik, U-Boot, Vaisala, Baikal Electronics,
       Shanghai Awinic Technology Co., MikroTik, Silex Insight
    
     - A bunch more binding conversions to DT schema. Only 3K to go.
    
     - Add a minimum version check for schema tools
    
     - Treewide dropping of 'allOf' usage with schema references. Not needed
       in new json-schema spec.
    
     - Some formatting clean-ups of schemas
    
    * tag 'devicetree-for-5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (194 commits)
      dt-bindings: clock: Add documentation for X1830 bindings.
      dt-bindings: mailbox: Convert imx mu to json-schema
      dt-bindings: power: Convert imx gpcv2 to json-schema
      dt-bindings: power: Convert imx gpc to json-schema
      dt-bindings: Merge gpio-usb-b-connector with usb-connector
      dt-bindings: timer: renesas: cmt: Convert to json-schema
      dt-bindings: clock: Convert i.MX8QXP LPCG to json-schema
      dt-bindings: timer: Convert i.MX GPT to json-schema
      dt-bindings: thermal: rcar-thermal: Add device tree support for r8a7742
      dt-bindings: serial: Add binding for UART pin swap
      dt-bindings: geni-se: Add interconnect binding for GENI QUP
      dt-bindings: geni-se: Convert QUP geni-se bindings to YAML
      dt-bindings: vendor-prefixes: Add Silex Insight vendor prefix
      dt-bindings: input: touchscreen: edt-ft5x06: change reg property
      dt-bindings: usb: qcom,dwc3: Introduce interconnect properties for Qualcomm DWC3 driver
      dt-bindings: timer: renesas: mtu2: Convert to json-schema
      of/fdt: Remove redundant kbasename function call
      dt-bindings: clock: Convert i.MX1 clock to json-schema
      dt-bindings: clock: Convert i.MX21 clock to json-schema
      dt-bindings: clock: Convert i.MX25 clock to json-schema
      ...

commit c8813f7ec01c676a8995c894ce49d40f5de62ed0
Author: chenqiwu <chenqiwu@xiaomi.com>
Date:   Mon May 11 23:04:57 2020 +0800

    drivers/of: keep description of function consistent with function name
    
    Currently, there are some descriptions of function not
    consistent with function name, fixing them will make
    the code more readable.
    
    Signed-off-by: chenqiwu <chenqiwu@xiaomi.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index 1a84bc0d5fa8..6f6fea3e96de 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -46,7 +46,7 @@ static int __init early_init_dt_alloc_reserved_memory_arch(phys_addr_t size,
 }
 
 /**
- * res_mem_save_node() - save fdt node for second pass initialization
+ * fdt_reserved_mem_save_node() - save fdt node for second pass initialization
  */
 void __init fdt_reserved_mem_save_node(unsigned long node, const char *uname,
 				      phys_addr_t base, phys_addr_t size)
@@ -68,8 +68,8 @@ void __init fdt_reserved_mem_save_node(unsigned long node, const char *uname,
 }
 
 /**
- * res_mem_alloc_size() - allocate reserved memory described by 'size', 'align'
- *			  and 'alloc-ranges' properties
+ * __reserved_mem_alloc_size() - allocate reserved memory described by
+ *	'size', 'align'  and 'alloc-ranges' properties.
  */
 static int __init __reserved_mem_alloc_size(unsigned long node,
 	const char *uname, phys_addr_t *res_base, phys_addr_t *res_size)
@@ -165,7 +165,7 @@ static const struct of_device_id __rmem_of_table_sentinel
 	__used __section(__reservedmem_of_table_end);
 
 /**
- * res_mem_init_node() - call region specific reserved memory init code
+ * __reserved_mem_init_node() - call region specific reserved memory init code
  */
 static int __init __reserved_mem_init_node(struct reserved_mem *rmem)
 {
@@ -232,7 +232,7 @@ static void __init __rmem_check_for_overlap(void)
 }
 
 /**
- * fdt_init_reserved_mem - allocate and init all saved reserved memory regions
+ * fdt_init_reserved_mem() - allocate and init all saved reserved memory regions
  */
 void __init fdt_init_reserved_mem(void)
 {

commit 081df76a040df3e31e78df4ca9106eb114dabc6a
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Apr 3 19:46:57 2020 +0200

    of: reserved-memory: Support multiple regions per device
    
    While the lookup/initialization code already supports multiple memory
    regions per device, the release code will only ever release the first
    matching memory region.
    
    Enhance the code to release all matching regions. Each attachment of
    a region to a device is uniquely identifiable using a struct device
    pointer and a pointer to the memory region's struct reserved_mem.
    
    Reviewed-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index ed2ff6f01d32..f61e8739502a 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -385,24 +385,22 @@ EXPORT_SYMBOL_GPL(of_reserved_mem_device_init_by_name);
  */
 void of_reserved_mem_device_release(struct device *dev)
 {
-	struct rmem_assigned_device *rd;
-	struct reserved_mem *rmem = NULL;
+	struct rmem_assigned_device *rd, *tmp;
+	LIST_HEAD(release_list);
 
 	mutex_lock(&of_rmem_assigned_device_mutex);
-	list_for_each_entry(rd, &of_rmem_assigned_device_list, list) {
-		if (rd->dev == dev) {
-			rmem = rd->rmem;
-			list_del(&rd->list);
-			kfree(rd);
-			break;
-		}
+	list_for_each_entry_safe(rd, tmp, &of_rmem_assigned_device_list, list) {
+		if (rd->dev == dev)
+			list_move_tail(&rd->list, &release_list);
 	}
 	mutex_unlock(&of_rmem_assigned_device_mutex);
 
-	if (!rmem || !rmem->ops || !rmem->ops->device_release)
-		return;
+	list_for_each_entry_safe(rd, tmp, &release_list, list) {
+		if (rd->rmem && rd->rmem->ops && rd->rmem->ops->device_release)
+			rd->rmem->ops->device_release(rd->rmem, dev);
 
-	rmem->ops->device_release(rmem, dev);
+		kfree(rd);
+	}
 }
 EXPORT_SYMBOL_GPL(of_reserved_mem_device_release);
 

commit 0da0e31600e8a42c6f1dfaa7a06211c8bb243ea7
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Apr 3 19:44:52 2020 +0200

    of: reserved-memory: Support lookup of regions by name
    
    Add support for looking up memory regions by name. This looks up the
    given name in the newly introduced memory-region-names property and
    returns the memory region at the corresponding index in the memory-
    region(s) property.
    
    Reviewed-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index 1a84bc0d5fa8..ed2ff6f01d32 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -357,6 +357,25 @@ int of_reserved_mem_device_init_by_idx(struct device *dev,
 }
 EXPORT_SYMBOL_GPL(of_reserved_mem_device_init_by_idx);
 
+/**
+ * of_reserved_mem_device_init_by_name() - assign named reserved memory region
+ *					   to given device
+ * @dev: pointer to the device to configure
+ * @np: pointer to the device node with 'memory-region' property
+ * @name: name of the selected memory region
+ *
+ * Returns: 0 on success or a negative error-code on failure.
+ */
+int of_reserved_mem_device_init_by_name(struct device *dev,
+					struct device_node *np,
+					const char *name)
+{
+	int idx = of_property_match_string(np, "memory-region-names", name);
+
+	return of_reserved_mem_device_init_by_idx(dev, np, idx);
+}
+EXPORT_SYMBOL_GPL(of_reserved_mem_device_init_by_name);
+
 /**
  * of_reserved_mem_device_release() - release reserved memory device structures
  * @dev:	Pointer to the device to deconfigure

commit 632c99084052aef1c9dcfe43d2720306026d6d21
Author: Patrick Daly <pdaly@codeaurora.org>
Date:   Mon Feb 24 10:02:32 2020 -0800

    of: of_reserved_mem: Increase limit on number of reserved regions
    
    Certain SoCs need to support a large amount of reserved memory
    regions. For example, Qualcomm's SM8150 SoC requires that 20
    regions of memory be reserved for a variety of reasons (e.g.
    loading a peripheral subsystem's firmware image into a
    particular space).
    
    When adding more reserved memory regions to cater to different
    usecases, the remaining number of reserved memory regions--12
    to be exact--becomes too small. Thus, double the existing
    limit of reserved memory regions.
    
    Signed-off-by: Patrick Daly <pdaly@codeaurora.org>
    Signed-off-by: Isaac J. Manjarres <isaacm@codeaurora.org>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index 6bd610ee2cd7..1a84bc0d5fa8 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -22,7 +22,7 @@
 #include <linux/slab.h>
 #include <linux/memblock.h>
 
-#define MAX_RESERVED_REGIONS	32
+#define MAX_RESERVED_REGIONS	64
 static struct reserved_mem reserved_mem[MAX_RESERVED_REGIONS];
 static int reserved_mem_count;
 

commit 5dba51754b04a941a1064f584e7a7f607df3f9bc
Author: Chris Goldsworthy <cgoldswo@codeaurora.org>
Date:   Sat Oct 19 18:57:24 2019 -0700

    of: reserved_mem: add missing of_node_put() for proper ref-counting
    
    Commit d698a388146c ("of: reserved-memory: ignore disabled memory-region
    nodes") added an early return in of_reserved_mem_device_init_by_idx(), but
    didn't call of_node_put() on a device_node whose ref-count was incremented
    in the call to of_parse_phandle() preceding the early exit.
    
    Fixes: d698a388146c ("of: reserved-memory: ignore disabled memory-region nodes")
    Signed-off-by: Chris Goldsworthy <cgoldswo@codeaurora.org>
    Cc: stable@vger.kernel.org
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index 7989703b883c..6bd610ee2cd7 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -324,8 +324,10 @@ int of_reserved_mem_device_init_by_idx(struct device *dev,
 	if (!target)
 		return -ENODEV;
 
-	if (!of_device_is_available(target))
+	if (!of_device_is_available(target)) {
+		of_node_put(target);
 		return 0;
+	}
 
 	rmem = __find_rmem(target);
 	of_node_put(target);

commit d698a388146c5ba72e7cf7e79f13932f2046bf29
Author: Krishna Reddy <vdumpa@nvidia.com>
Date:   Wed May 22 16:17:11 2019 +0530

    of: reserved-memory: ignore disabled memory-region nodes
    
    Ignore disabled nodes in the memory-region
    nodes list and continue to initialize the rest
    of enabled nodes.
    
    Check if the "reserved-memory" node is available
    and if it's not available, return 0 to ignore the
    "reserved-memory" node and continue parsing with
    next node in memory-region nodes list.
    
    Signed-off-by: Krishna Reddy <vdumpa@nvidia.com>
    Signed-off-by: Puneet Saxena <puneets@nvidia.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index 89e190e94af7..7989703b883c 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -324,6 +324,9 @@ int of_reserved_mem_device_init_by_idx(struct device *dev,
 	if (!target)
 		return -ENODEV;
 
+	if (!of_device_is_available(target))
+		return 0;
+
 	rmem = __find_rmem(target);
 	of_node_put(target);
 

commit d0b8ed47e83a2253897500ea4fcae8e8198942b4
Author: pierre Kuo <vichy.kuo@gmail.com>
Date:   Tue Feb 19 15:45:00 2019 +0800

    of: reserved_mem: fix reserve memory leak
    
    The __reserved_mem_init_node will call region specific reserved memory
    init codes, but once all compatibled init codes failed, the memory region
    will left in memory.reserved and cause leakage.
    
    Take cma reserve memory DTS for example, if user declare 1MB size,
    which is not align to (PAGE_SIZE << max(MAX_ORDER - 1,
    pageblock_order)), rmem_cma_setup will return -EINVAL.
    Meanwhile, rmem_dma_setup will also return -EINVAL since "reusable"
    property is not set. If finally there is no reserved memory init pick up
    this memory, kernel will left the 1MB leak in memory.reserved.
    
    This patch will remove this kind of memory from memory.reserved, only
    when __reserved_mem_init_node return neither 0 nor -ENOENT.
    
    Signed-off-by: pierre Kuo <vichy.kuo@gmail.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index 6a36bc0b3d64..89e190e94af7 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -171,6 +171,7 @@ static int __init __reserved_mem_init_node(struct reserved_mem *rmem)
 {
 	extern const struct of_device_id __reservedmem_of_table[];
 	const struct of_device_id *i;
+	int ret = -ENOENT;
 
 	for (i = __reservedmem_of_table; i < &__rmem_of_table_sentinel; i++) {
 		reservedmem_of_init_fn initfn = i->data;
@@ -179,13 +180,14 @@ static int __init __reserved_mem_init_node(struct reserved_mem *rmem)
 		if (!of_flat_dt_is_compatible(rmem->fdt_node, compat))
 			continue;
 
-		if (initfn(rmem) == 0) {
+		ret = initfn(rmem);
+		if (ret == 0) {
 			pr_info("initialized node %s, compatible id %s\n",
 				rmem->name, compat);
-			return 0;
+			break;
 		}
 	}
-	return -ENOENT;
+	return ret;
 }
 
 static int __init __rmem_cmp(const void *a, const void *b)
@@ -245,7 +247,9 @@ void __init fdt_init_reserved_mem(void)
 		int len;
 		const __be32 *prop;
 		int err = 0;
+		int nomap;
 
+		nomap = of_get_flat_dt_prop(node, "no-map", NULL) != NULL;
 		prop = of_get_flat_dt_prop(node, "phandle", &len);
 		if (!prop)
 			prop = of_get_flat_dt_prop(node, "linux,phandle", &len);
@@ -255,8 +259,16 @@ void __init fdt_init_reserved_mem(void)
 		if (rmem->size == 0)
 			err = __reserved_mem_alloc_size(node, rmem->name,
 						 &rmem->base, &rmem->size);
-		if (err == 0)
-			__reserved_mem_init_node(rmem);
+		if (err == 0) {
+			err = __reserved_mem_init_node(rmem);
+			if (err != 0 && err != -ENOENT) {
+				pr_info("node %s compatible matching fail\n",
+					rmem->name);
+				memblock_free(rmem->base, rmem->size);
+				if (nomap)
+					memblock_add(rmem->base, rmem->size);
+			}
+		}
 	}
 }
 

commit 5c01a25a210366362a40dc63f550e72688a60c48
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Mar 11 23:30:58 2019 -0700

    of: fix kmemleak crash caused by imbalance in early memory reservation
    
    Marc Gonzalez reported the following kmemleak crash:
    
      Unable to handle kernel paging request at virtual address ffffffc021e00000
      Mem abort info:
        ESR = 0x96000006
        Exception class = DABT (current EL), IL = 32 bits
        SET = 0, FnV = 0
        EA = 0, S1PTW = 0
      Data abort info:
        ISV = 0, ISS = 0x00000006
        CM = 0, WnR = 0
      swapper pgtable: 4k pages, 39-bit VAs, pgdp = (____ptrval____) [ffffffc021e00000] pgd=000000017e3ba803, pud=000000017e3ba803, pmd=0000000000000000
      Internal error: Oops: 96000006 [#1] PREEMPT SMP
      Modules linked in:
      CPU: 6 PID: 523 Comm: kmemleak Tainted: G S      W         5.0.0-rc1 #13
      Hardware name: Qualcomm Technologies, Inc. MSM8998 v1 MTP (DT)
      pstate: 80000085 (Nzcv daIf -PAN -UAO)
      pc : scan_block+0x70/0x190
      lr : scan_block+0x6c/0x190
      Process kmemleak (pid: 523, stack limit = 0x(____ptrval____))
      Call trace:
       scan_block+0x70/0x190
       scan_gray_list+0x108/0x1c0
       kmemleak_scan+0x33c/0x7c0
       kmemleak_scan_thread+0x98/0xf0
       kthread+0x11c/0x120
       ret_from_fork+0x10/0x1c
      Code: f9000fb4 d503201f 97ffffd2 35000580 (f9400260)
    
    The crash happens when a no-map area is allocated in
    early_init_dt_alloc_reserved_memory_arch().  The allocated region is
    registered with kmemleak, but it is then removed from memblock using
    memblock_remove() that is not kmemleak-aware.
    
    Replacing memblock_phys_alloc_range() with memblock_find_in_range()
    makes sure that the allocated memory is not added to kmemleak and then
    memblock_remove()'ing this memory is safe.
    
    As a bonus, since memblock_find_in_range() ensures the allocation in the
    specified range, the bounds check can be removed.
    
    [rppt@linux.ibm.com: of: fix parameters order for call to memblock_find_in_range()]
      Link: http://lkml.kernel.org/r/20190221112619.GC32004@rapoport-lnx
    Link: http://lkml.kernel.org/r/20190213181921.GB15270@rapoport-lnx
    Fixes: 3f0c820664483 ("drivers: of: add initialization code for dynamic reserved memory")
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Acked-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Acked-by: Prateek Patel <prpatel@nvidia.com>
    Tested-by: Marc Gonzalez <marc.w.gonzalez@free.fr>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index 8c07d7da5256..6a36bc0b3d64 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -34,22 +34,15 @@ static int __init early_init_dt_alloc_reserved_memory_arch(phys_addr_t size,
 
 	end = !end ? MEMBLOCK_ALLOC_ANYWHERE : end;
 	align = !align ? SMP_CACHE_BYTES : align;
-	base = memblock_phys_alloc_range(size, align, 0, end);
+	base = memblock_find_in_range(start, end, size, align);
 	if (!base)
 		return -ENOMEM;
 
-	/*
-	 * Check if the allocated region fits in to start..end window
-	 */
-	if (base < start) {
-		memblock_free(base, size);
-		return -ENOMEM;
-	}
-
 	*res_base = base;
 	if (nomap)
 		return memblock_remove(base, size);
-	return 0;
+
+	return memblock_reserve(base, size);
 }
 
 /**

commit 42b46aeff2e366bad54bd1c069b7b5381d9be8b3
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Mar 11 23:29:31 2019 -0700

    memblock: drop __memblock_alloc_base()
    
    The __memblock_alloc_base() function tries to allocate a memory up to
    the limit specified by its max_addr parameter.  Depending on the value
    of this parameter, the __memblock_alloc_base() can is replaced with the
    appropriate memblock_phys_alloc*() variant.
    
    Link: http://lkml.kernel.org/r/1548057848-15136-9-git-send-email-rppt@linux.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Christophe Leroy <christophe.leroy@c-s.fr>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Dennis Zhou <dennis@kernel.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Guo Ren <ren_guo@c-sky.com>                         [c-sky]
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Juergen Gross <jgross@suse.com>                     [Xen]
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index e773063c6de9..8c07d7da5256 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -31,13 +31,10 @@ static int __init early_init_dt_alloc_reserved_memory_arch(phys_addr_t size,
 	phys_addr_t *res_base)
 {
 	phys_addr_t base;
-	/*
-	 * We use __memblock_alloc_base() because memblock_alloc_base()
-	 * panic()s on allocation failure.
-	 */
+
 	end = !end ? MEMBLOCK_ALLOC_ANYWHERE : end;
 	align = !align ? SMP_CACHE_BYTES : align;
-	base = __memblock_alloc_base(size, align, end);
+	base = memblock_phys_alloc_range(size, align, 0, end);
 	if (!base)
 		return -ENOMEM;
 

commit 221e1e0b016529f33b0d1bbf7d07c54463b55ca6
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Feb 11 14:35:45 2019 +0100

    of: mark early_init_dt_alloc_reserved_memory_arch static
    
    This function is only used in of_reserved_mem.c, and never overridden
    despite the __weak marker.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index 9e02a5d80225..e773063c6de9 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -26,7 +26,7 @@
 static struct reserved_mem reserved_mem[MAX_RESERVED_REGIONS];
 static int reserved_mem_count;
 
-int __init __weak early_init_dt_alloc_reserved_memory_arch(phys_addr_t size,
+static int __init early_init_dt_alloc_reserved_memory_arch(phys_addr_t size,
 	phys_addr_t align, phys_addr_t start, phys_addr_t end, bool nomap,
 	phys_addr_t *res_base)
 {

commit 42e45a9449f1376d4decd751612a48f6db1f6e37
Author: Robin Murphy <robin.murphy@arm.com>
Date:   Mon Jan 14 15:14:14 2019 +0000

    media: s5p-mfc: Fix memdev DMA configuration
    
    Having of_reserved_mem_device_init() forcibly reconfigure DMA for all
    callers, potentially overriding the work done by a bus-specific
    .dma_configure method earlier, is at best a bad idea and at worst
    actively harmful. If drivers really need virtual devices to own
    dma-coherent memory, they should explicitly configure those devices
    based on the appropriate firmware node as they create them.
    
    It looks like the only driver not passing in a proper OF platform device
    is s5p-mfc, so move the rogue of_dma_configure() call into that driver
    where it logically belongs.
    
    Reviewed-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Acked-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index 1977ee0adcb1..9e02a5d80225 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -340,10 +340,6 @@ int of_reserved_mem_device_init_by_idx(struct device *dev,
 		mutex_lock(&of_rmem_assigned_device_mutex);
 		list_add(&rd->list, &of_rmem_assigned_device_list);
 		mutex_unlock(&of_rmem_assigned_device_mutex);
-		/* ensure that dma_ops is set for virtual devices
-		 * using reserved memory
-		 */
-		of_dma_configure(dev, np, true);
 
 		dev_info(dev, "assigned reserved memory node %s\n", rmem->name);
 	} else {

commit 7e1c4e27928e5f87b9b1eaf06dc31773b2f1e7f1
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:57 2018 -0700

    memblock: stop using implicit alignment to SMP_CACHE_BYTES
    
    When a memblock allocation APIs are called with align = 0, the alignment
    is implicitly set to SMP_CACHE_BYTES.
    
    Implicit alignment is done deep in the memblock allocator and it can
    come as a surprise.  Not that such an alignment would be wrong even
    when used incorrectly but it is better to be explicit for the sake of
    clarity and the prinicple of the least surprise.
    
    Replace all such uses of memblock APIs with the 'align' parameter
    explicitly set to SMP_CACHE_BYTES and stop implicit alignment assignment
    in the memblock internal allocation functions.
    
    For the case when memblock APIs are used via helper functions, e.g.  like
    iommu_arena_new_node() in Alpha, the helper functions were detected with
    Coccinelle's help and then manually examined and updated where
    appropriate.
    
    The direct memblock APIs users were updated using the semantic patch below:
    
    @@
    expression size, min_addr, max_addr, nid;
    @@
    (
    |
    - memblock_alloc_try_nid_raw(size, 0, min_addr, max_addr, nid)
    + memblock_alloc_try_nid_raw(size, SMP_CACHE_BYTES, min_addr, max_addr,
    nid)
    |
    - memblock_alloc_try_nid_nopanic(size, 0, min_addr, max_addr, nid)
    + memblock_alloc_try_nid_nopanic(size, SMP_CACHE_BYTES, min_addr, max_addr,
    nid)
    |
    - memblock_alloc_try_nid(size, 0, min_addr, max_addr, nid)
    + memblock_alloc_try_nid(size, SMP_CACHE_BYTES, min_addr, max_addr, nid)
    |
    - memblock_alloc(size, 0)
    + memblock_alloc(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_raw(size, 0)
    + memblock_alloc_raw(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_from(size, 0, min_addr)
    + memblock_alloc_from(size, SMP_CACHE_BYTES, min_addr)
    |
    - memblock_alloc_nopanic(size, 0)
    + memblock_alloc_nopanic(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_low(size, 0)
    + memblock_alloc_low(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_low_nopanic(size, 0)
    + memblock_alloc_low_nopanic(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_from_nopanic(size, 0, min_addr)
    + memblock_alloc_from_nopanic(size, SMP_CACHE_BYTES, min_addr)
    |
    - memblock_alloc_node(size, 0, nid)
    + memblock_alloc_node(size, SMP_CACHE_BYTES, nid)
    )
    
    [mhocko@suse.com: changelog update]
    [akpm@linux-foundation.org: coding-style fixes]
    [rppt@linux.ibm.com: fix missed uses of implicit alignment]
      Link: http://lkml.kernel.org/r/20181016133656.GA10925@rapoport-lnx
    Link: http://lkml.kernel.org/r/1538687224-17535-1-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Suggested-by: Michal Hocko <mhocko@suse.com>
    Acked-by: Paul Burton <paul.burton@mips.com>    [MIPS]
    Acked-by: Michael Ellerman <mpe@ellerman.id.au> [powerpc]
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index d6255c276a41..1977ee0adcb1 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -36,6 +36,7 @@ int __init __weak early_init_dt_alloc_reserved_memory_arch(phys_addr_t size,
 	 * panic()s on allocation failure.
 	 */
 	end = !end ? MEMBLOCK_ALLOC_ANYWHERE : end;
+	align = !align ? SMP_CACHE_BYTES : align;
 	base = __memblock_alloc_base(size, align, end);
 	if (!base)
 		return -ENOMEM;

commit aca52c39838910605b1063a2243f553aa2a02d5c
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:07:44 2018 -0700

    mm: remove CONFIG_HAVE_MEMBLOCK
    
    All architecures use memblock for early memory management. There is no need
    for the CONFIG_HAVE_MEMBLOCK configuration option.
    
    [rppt@linux.vnet.ibm.com: of/fdt: fixup #ifdefs]
      Link: http://lkml.kernel.org/r/20180919103457.GA20545@rapoport-lnx
    [rppt@linux.vnet.ibm.com: csky: fixups after bootmem removal]
      Link: http://lkml.kernel.org/r/20180926112744.GC4628@rapoport-lnx
    [rppt@linux.vnet.ibm.com: remove stale #else and the code it protects]
      Link: http://lkml.kernel.org/r/1538067825-24835-1-git-send-email-rppt@linux.vnet.ibm.com
    Link: http://lkml.kernel.org/r/1536927045-23536-4-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Tested-by: Jonathan Cameron <jonathan.cameron@huawei.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index 895c83e0c7b6..d6255c276a41 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -20,13 +20,12 @@
 #include <linux/of_reserved_mem.h>
 #include <linux/sort.h>
 #include <linux/slab.h>
+#include <linux/memblock.h>
 
 #define MAX_RESERVED_REGIONS	32
 static struct reserved_mem reserved_mem[MAX_RESERVED_REGIONS];
 static int reserved_mem_count;
 
-#if defined(CONFIG_HAVE_MEMBLOCK)
-#include <linux/memblock.h>
 int __init __weak early_init_dt_alloc_reserved_memory_arch(phys_addr_t size,
 	phys_addr_t align, phys_addr_t start, phys_addr_t end, bool nomap,
 	phys_addr_t *res_base)
@@ -54,16 +53,6 @@ int __init __weak early_init_dt_alloc_reserved_memory_arch(phys_addr_t size,
 		return memblock_remove(base, size);
 	return 0;
 }
-#else
-int __init __weak early_init_dt_alloc_reserved_memory_arch(phys_addr_t size,
-	phys_addr_t align, phys_addr_t start, phys_addr_t end, bool nomap,
-	phys_addr_t *res_base)
-{
-	pr_err("Reserved memory not supported, ignoring region 0x%llx%s\n",
-		  size, nomap ? " (nomap)" : "");
-	return -ENOSYS;
-}
-#endif
 
 /**
  * res_mem_save_node() - save fdt node for second pass initialization

commit 3d6ce86ee79465e1b1b6e287f8ea26b553fc768e
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu May 3 16:25:08 2018 +0200

    drivers: remove force dma flag from buses
    
    With each bus implementing its own DMA configuration callback, there is no
    need for bus to explicitly set the force_dma flag.  Modify the
    of_dma_configure function to accept an input parameter which specifies if
    implicit DMA configuration is required when it is not described by the
    firmware.
    
    Signed-off-by: Nipun Gupta <nipun.gupta@nxp.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>  # PCI parts
    Reviewed-by: Rob Herring <robh@kernel.org>
    [hch: tweaked the changelog a bit]
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index 9a4f4246231d..895c83e0c7b6 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -353,7 +353,7 @@ int of_reserved_mem_device_init_by_idx(struct device *dev,
 		/* ensure that dma_ops is set for virtual devices
 		 * using reserved memory
 		 */
-		of_dma_configure(dev, np);
+		of_dma_configure(dev, np, true);
 
 		dev_info(dev, "assigned reserved memory node %s\n", rmem->name);
 	} else {

commit af6074fc9aa4b29517375634189ada1869eea598
Author: Rob Herring <robh@kernel.org>
Date:   Wed Dec 27 12:55:14 2017 -0600

    of: Use SPDX license tag for DT files
    
    Convert remaining DT files to use SPDX-License-Identifier tags.
    
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    Reviewed-by: Frank Rowand <frank.rowand@sony.com>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index 22b75c82e377..9a4f4246231d 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Device tree based initialization code for reserved memory.
  *
@@ -6,11 +7,6 @@
  *		http://www.samsung.com
  * Author: Marek Szyprowski <m.szyprowski@samsung.com>
  * Author: Josh Cartwright <joshc@codeaurora.org>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License or (at your optional) any later version of the license.
  */
 
 #define pr_fmt(fmt)	"OF: reserved mem: " fmt

commit cf9b0772f2e410645fece13b749bd56505b998b8
Merge: 527d1470744d 339cd0ea0822
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Nov 16 16:05:01 2017 -0800

    Merge tag 'armsoc-drivers' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC driver updates from Arnd Bergmann:
     "This branch contains platform-related driver updates for ARM and
      ARM64, these are the areas that bring the changes:
    
      New drivers:
    
       - driver support for Renesas R-Car V3M (R8A77970)
    
       - power management support for Amlogic GX
    
       - a new driver for the Tegra BPMP thermal sensor
    
       - a new bus driver for Technologic Systems NBUS
    
      Changes for subsystems that prefer to merge through arm-soc:
    
       - the usual updates for reset controller drivers from Philipp Zabel,
         with five added drivers for SoCs in the arc, meson, socfpa,
         uniphier and mediatek families
    
       - updates to the ARM SCPI and PSCI frameworks, from Sudeep Holla,
         Heiner Kallweit and Lorenzo Pieralisi
    
      Changes specific to some ARM-based SoC
    
       - the Freescale/NXP DPAA QBMan drivers from PowerPC can now work on
         ARM as well
    
       - several changes for power management on Broadcom SoCs
    
       - various improvements on Qualcomm, Broadcom, Amlogic, Atmel,
         Mediatek
    
       - minor Cleanups for Samsung, TI OMAP SoCs"
    
    [ NOTE! This doesn't work without the previous ARM SoC device-tree pull,
      because the R8A77970 driver is missing a header file that came from
      that pull.
    
      The fact that this got merged afterwards only fixes it at this point,
      and bisection of that driver will fail if/when you walk into the
      history of that driver.           - Linus ]
    
    * tag 'armsoc-drivers' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (96 commits)
      soc: amlogic: meson-gx-pwrc-vpu: fix power-off when powered by bootloader
      bus: add driver for the Technologic Systems NBUS
      memory: omap-gpmc: Remove deprecated gpmc_update_nand_reg()
      soc: qcom: remove unused label
      soc: amlogic: gx pm domain: add PM and OF dependencies
      drivers/firmware: psci_checker: Add missing destroy_timer_on_stack()
      dt-bindings: power: add amlogic meson power domain bindings
      soc: amlogic: add Meson GX VPU Domains driver
      soc: qcom: Remote filesystem memory driver
      dt-binding: soc: qcom: Add binding for rmtfs memory
      of: reserved_mem: Accessor for acquiring reserved_mem
      of/platform: Generalize /reserved-memory handling
      soc: mediatek: pwrap: fix fatal compiler error
      soc: mediatek: pwrap: fix compiler errors
      arm64: mediatek: cleanup message for platform selection
      soc: Allow test-building of MediaTek drivers
      soc: mediatek: place Kconfig for all SoC drivers under menu
      soc: mediatek: pwrap: add support for MT7622 SoC
      soc: mediatek: pwrap: add common way for setup CS timing extenstion
      soc: mediatek: pwrap: add MediaTek MT6380 as one slave of pwrap
      ..

commit eb297bc716ec2cb3147e6e99002e37058c65cba3
Author: Bjorn Andersson <bjorn.andersson@linaro.org>
Date:   Tue Oct 10 22:08:54 2017 -0700

    of: reserved_mem: Accessor for acquiring reserved_mem
    
    In some cases drivers referencing a reserved-memory region might want to
    remap the entire region, but when defining the reserved-memory by "size"
    the client driver has no means to know the associated base address of
    the reserved memory region.
    
    This patch adds an accessor for such drivers to acquire a handle to
    their associated reserved-memory for this purpose.
    
    A complicating factor for the implementation is that the reserved_mem
    objects are created from the flattened DeviceTree, as such we can't
    use the device_node address for comparison. Fortunately the name of the
    node will be used as "name" of the reserved_mem and will be used when
    building the full_name, so we can compare the "name" with the basename
    of the full_name to find the match.
    
    Reviewed-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Andy Gross <andy.gross@linaro.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index d507c3569a88..b108c7a1f74c 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -397,3 +397,29 @@ void of_reserved_mem_device_release(struct device *dev)
 	rmem->ops->device_release(rmem, dev);
 }
 EXPORT_SYMBOL_GPL(of_reserved_mem_device_release);
+
+/**
+ * of_reserved_mem_lookup() - acquire reserved_mem from a device node
+ * @np:		node pointer of the desired reserved-memory region
+ *
+ * This function allows drivers to acquire a reference to the reserved_mem
+ * struct based on a device node handle.
+ *
+ * Returns a reserved_mem reference, or NULL on error.
+ */
+struct reserved_mem *of_reserved_mem_lookup(struct device_node *np)
+{
+	const char *name;
+	int i;
+
+	if (!np->full_name)
+		return NULL;
+
+	name = kbasename(np->full_name);
+	for (i = 0; i < reserved_mem_count; i++)
+		if (!strcmp(reserved_mem[i].name, name))
+			return &reserved_mem[i];
+
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(of_reserved_mem_lookup);

commit 22f8cc6e33731678e7687a18ffd0f578131edb4c
Author: Stewart Smith <stewart@linux.vnet.ibm.com>
Date:   Tue Sep 26 18:40:00 2017 +1000

    drivers: of: increase MAX_RESERVED_REGIONS to 32
    
    There are two types of memory reservations firmware can ask the kernel
    to make in the device tree: static and dynamic.
    See Documentation/devicetree/bindings/reserved-memory/reserved-memory.txt
    
    If you have greater than 16 entries in /reserved-memory (as we do on
    POWER9 systems) you would get this scary looking error message:
     [    0.000000] OF: reserved mem: not enough space all defined regions.
    
    This is harmless if all your reservations are static (which with OPAL on
    POWER9, they are).
    
    It is not harmless if you have any dynamic reservations after the 16th.
    
    In the first pass over the fdt to find reservations, the child nodes of
    /reserved-memory are added to a static array in of_reserved_mem.c so that
    memory can be reserved in a 2nd pass. The array has 16 entries. This is why,
    on my dual socket POWER9 system, I get that error 4 times with 20 static
    reservations.
    
    We don't have a problem on ppc though, as in arch/powerpc/kernel/prom.c
    we look at the new style /reserved-ranges property to do reservations,
    and this logic was introduced in 0962e8004e974 (well before any powernv
    system shipped).
    
    A Google search shows up no occurances of that exact error message, so we're
    probably safe in that no machine that people use has memory not being reserved
    when it should be.
    
    The simple fix is to bump the length of the array to 32 which "should be
    enough for everyone(TM)". The simple fix of not recording static allocations
    in the array would cause problems for devices with "memory-region" properties.
    A more future-proof fix is likely possible, although more invasive and this
    simple fix is perfectly suitable in the meantime while a more future-proof
    fix is developed.
    
    Signed-off-by: Stewart Smith <stewart@linux.vnet.ibm.com>
    Tested-by: Mauricio Faria de Oliveira <mauricfo@linux.vnet.ibm.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index d507c3569a88..32771c2ced7b 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -25,7 +25,7 @@
 #include <linux/sort.h>
 #include <linux/slab.h>
 
-#define MAX_RESERVED_REGIONS	16
+#define MAX_RESERVED_REGIONS	32
 static struct reserved_mem reserved_mem[MAX_RESERVED_REGIONS];
 static int reserved_mem_count;
 

commit df3ed932394488e57e72dd0e73c224d1804fdc8f
Author: Rob Herring <robh@kernel.org>
Date:   Thu May 11 10:15:10 2017 -0500

    Partially Revert "of: fix sparse warnings in fdt, irq, reserved mem, and resolver code"
    
    A change to function pointers that was meant to address a sparse warning
    turned out to cause hundreds of new gcc-7 warnings:
    
    include/linux/of_irq.h:11:13: error: type qualifiers ignored on function return type [-Werror=ignored-qualifiers]
    drivers/of/of_reserved_mem.c: In function '__reserved_mem_init_node':
    drivers/of/of_reserved_mem.c:200:7: error: type qualifiers ignored on function return type [-Werror=ignored-qualifiers]
       int const (*initfn)(struct reserved_mem *rmem) = i->data;
    
    Turns out the sparse warnings were spurious and have been fixed in
    upstream sparse since 0.5.0 in commit "sparse: treat function pointers
    as pointers to const data".
    
    This partially reverts commit 17a70355ea576843a7ac851f1db26872a50b2850.
    
    Fixes: 17a70355ea57 ("of: fix sparse warnings in fdt, irq, reserved mem, and resolver code")
    Reported-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index 4dec07ea510f..d507c3569a88 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -197,7 +197,7 @@ static int __init __reserved_mem_init_node(struct reserved_mem *rmem)
 	const struct of_device_id *i;
 
 	for (i = __reservedmem_of_table; i < &__rmem_of_table_sentinel; i++) {
-		int const (*initfn)(struct reserved_mem *rmem) = i->data;
+		reservedmem_of_init_fn initfn = i->data;
 		const char *compat = i->compatible;
 
 		if (!of_flat_dt_is_compatible(rmem->fdt_node, compat))

commit 17a70355ea576843a7ac851f1db26872a50b2850
Author: Rob Herring <robh@kernel.org>
Date:   Thu May 4 12:56:12 2017 -0500

    of: fix sparse warnings in fdt, irq, reserved mem, and resolver code
    
    sparse generates the following warnings in drivers/of/:
    
    ../drivers/of/fdt.c:63:36: warning: cast to restricted __be32
    ../drivers/of/fdt.c:68:33: warning: cast to restricted __be32
    ../drivers/of/irq.c:105:88: warning: incorrect type in initializer (different base types)
    ../drivers/of/irq.c:105:88:    expected restricted __be32
    ../drivers/of/irq.c:105:88:    got int
    ../drivers/of/irq.c:526:35: warning: incorrect type in assignment (different modifiers)
    ../drivers/of/irq.c:526:35:    expected int ( *const [usertype] irq_init_cb )( ... )
    ../drivers/of/irq.c:526:35:    got void const *const data
    ../drivers/of/of_reserved_mem.c:200:50: warning: incorrect type in initializer (different modifiers)
    ../drivers/of/of_reserved_mem.c:200:50:    expected int ( *[usertype] initfn )( ... )
    ../drivers/of/of_reserved_mem.c:200:50:    got void const *const data
    ../drivers/of/resolver.c:95:42: warning: incorrect type in assignment (different base types)
    ../drivers/of/resolver.c:95:42:    expected unsigned int [unsigned] [usertype] <noident>
    ../drivers/of/resolver.c:95:42:    got restricted __be32 [usertype] <noident>
    
    All these are harmless type mismatches fixed by adjusting the types.
    
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index d507c3569a88..4dec07ea510f 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -197,7 +197,7 @@ static int __init __reserved_mem_init_node(struct reserved_mem *rmem)
 	const struct of_device_id *i;
 
 	for (i = __reservedmem_of_table; i < &__rmem_of_table_sentinel; i++) {
-		reservedmem_of_init_fn initfn = i->data;
+		int const (*initfn)(struct reserved_mem *rmem) = i->data;
 		const char *compat = i->compatible;
 
 		if (!of_flat_dt_is_compatible(rmem->fdt_node, compat))

commit a3b398e6f2f169f09e60ba99745ca444d7de693e
Author: Smitha T Murthy <smitha.t@samsung.com>
Date:   Wed Dec 21 11:14:31 2016 +0530

    of: reserved_mem: set dma_ops for devices using reserved mem
    
    For some IPs, there may be virtual child devices created and for them its
    necessary to set the dma_ops if it's using reserved memory else it will call
    the dummy dma_ops during buffer operations for the child devices which will
    lead to memory mapping failure.
    
    Signed-off-by: Smitha T Murthy <smitha.t@samsung.com>
    Signed-off-by: Pankaj Dubey <pankaj.dubey@samsung.com>
    Acked-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index 366d8c3c7989..d507c3569a88 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -354,6 +354,10 @@ int of_reserved_mem_device_init_by_idx(struct device *dev,
 		mutex_lock(&of_rmem_assigned_device_mutex);
 		list_add(&rd->list, &of_rmem_assigned_device_list);
 		mutex_unlock(&of_rmem_assigned_device_mutex);
+		/* ensure that dma_ops is set for virtual devices
+		 * using reserved memory
+		 */
+		of_dma_configure(dev, np);
 
 		dev_info(dev, "assigned reserved memory node %s\n", rmem->name);
 	} else {

commit f64d6e2aaa79f0ad588fd7ad595a0a8eb8f04645
Merge: 1056c9bd2702 099c0cbd2025
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 30 11:32:01 2016 -0700

    Merge tag 'devicetree-for-4.8' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull DeviceTree updates from Rob Herring:
    
     - remove most of_platform_populate() calls in arch code.  Now the DT
       core code calls it in the default case and platforms only need to
       call it if they have special needs
    
     - use pr_fmt on all the DT core print statements
    
     - CoreSight binding doc improvements to block name descriptions
    
     - add dt_to_config script which can parse dts files and list
       corresponding kernel config options
    
     - fix memory leak hit with a PowerMac DT
    
     - correct a bunch of STMicro compatible strings to use the correct
       vendor prefix
    
     - fix DA9052 PMIC binding doc to match what is actually used in dts
       files
    
    * tag 'devicetree-for-4.8' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (35 commits)
      documentation: da9052: Update regulator bindings names to match DA9052/53 DTS expectations
      xtensa: Partially Revert "xtensa: Remove unnecessary of_platform_populate with default match table"
      xtensa: Fix build error due to missing include file
      MIPS: ath79: Add missing include file
      Fix spelling errors in Documentation/devicetree
      ARM: dts: fix STMicroelectronics compatible strings
      powerpc/dts: fix STMicroelectronics compatible strings
      Documentation: dt: i2c: use correct STMicroelectronics vendor prefix
      scripts/dtc: dt_to_config - kernel config options for a devicetree
      of: fdt: mark unflattened tree as detached
      of: overlay: add resolver error prints
      coresight: document binding acronyms
      Documentation/devicetree: document cavium-pip rx-delay/tx-delay properties
      of: use pr_fmt prefix for all console printing
      of/irq: Mark initialised interrupt controllers as populated
      of: fix memory leak related to safe_name()
      Revert "of/platform: export of_default_bus_match_table"
      of: unittest: use of_platform_default_populate() to populate default bus
      memory: omap-gpmc: use of_platform_default_populate() to populate default bus
      bus: uniphier-system-bus: use of_platform_default_populate() to populate default bus
      ...

commit 606ad42aa3b1fe8bb122305bef5aea79a6cef54b
Author: Rob Herring <robh@kernel.org>
Date:   Wed Jun 15 08:32:18 2016 -0500

    of: use pr_fmt prefix for all console printing
    
    Clean-up all the DT printk functions to use common pr_fmt prefix.
    
    Some print statements such as kmalloc errors were redundant, so just
    drop those.
    
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    Reviewed-by: Frank Rowand <frank.rowand@am.sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index 216648233874..eed788698268 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -13,6 +13,8 @@
  * License or (at your optional) any later version of the license.
  */
 
+#define pr_fmt(fmt)	"OF: reserved mem: " fmt
+
 #include <linux/err.h>
 #include <linux/of.h>
 #include <linux/of_fdt.h>
@@ -75,7 +77,7 @@ void __init fdt_reserved_mem_save_node(unsigned long node, const char *uname,
 	struct reserved_mem *rmem = &reserved_mem[reserved_mem_count];
 
 	if (reserved_mem_count == ARRAY_SIZE(reserved_mem)) {
-		pr_err("Reserved memory: not enough space all defined regions.\n");
+		pr_err("not enough space all defined regions.\n");
 		return;
 	}
 
@@ -108,8 +110,7 @@ static int __init __reserved_mem_alloc_size(unsigned long node,
 		return -EINVAL;
 
 	if (len != dt_root_size_cells * sizeof(__be32)) {
-		pr_err("Reserved memory: invalid size property in '%s' node.\n",
-				uname);
+		pr_err("invalid size property in '%s' node.\n", uname);
 		return -EINVAL;
 	}
 	size = dt_mem_next_cell(dt_root_size_cells, &prop);
@@ -119,7 +120,7 @@ static int __init __reserved_mem_alloc_size(unsigned long node,
 	prop = of_get_flat_dt_prop(node, "alignment", &len);
 	if (prop) {
 		if (len != dt_root_addr_cells * sizeof(__be32)) {
-			pr_err("Reserved memory: invalid alignment property in '%s' node.\n",
+			pr_err("invalid alignment property in '%s' node.\n",
 				uname);
 			return -EINVAL;
 		}
@@ -141,7 +142,7 @@ static int __init __reserved_mem_alloc_size(unsigned long node,
 	if (prop) {
 
 		if (len % t_len != 0) {
-			pr_err("Reserved memory: invalid alloc-ranges property in '%s', skipping node.\n",
+			pr_err("invalid alloc-ranges property in '%s', skipping node.\n",
 			       uname);
 			return -EINVAL;
 		}
@@ -156,7 +157,7 @@ static int __init __reserved_mem_alloc_size(unsigned long node,
 			ret = early_init_dt_alloc_reserved_memory_arch(size,
 					align, start, end, nomap, &base);
 			if (ret == 0) {
-				pr_debug("Reserved memory: allocated memory for '%s' node: base %pa, size %ld MiB\n",
+				pr_debug("allocated memory for '%s' node: base %pa, size %ld MiB\n",
 					uname, &base,
 					(unsigned long)size / SZ_1M);
 				break;
@@ -168,13 +169,12 @@ static int __init __reserved_mem_alloc_size(unsigned long node,
 		ret = early_init_dt_alloc_reserved_memory_arch(size, align,
 							0, 0, nomap, &base);
 		if (ret == 0)
-			pr_debug("Reserved memory: allocated memory for '%s' node: base %pa, size %ld MiB\n",
+			pr_debug("allocated memory for '%s' node: base %pa, size %ld MiB\n",
 				uname, &base, (unsigned long)size / SZ_1M);
 	}
 
 	if (base == 0) {
-		pr_info("Reserved memory: failed to allocate memory for node '%s'\n",
-			uname);
+		pr_info("failed to allocate memory for node '%s'\n", uname);
 		return -ENOMEM;
 	}
 
@@ -203,7 +203,7 @@ static int __init __reserved_mem_init_node(struct reserved_mem *rmem)
 			continue;
 
 		if (initfn(rmem) == 0) {
-			pr_info("Reserved memory: initialized node %s, compatible id %s\n",
+			pr_info("initialized node %s, compatible id %s\n",
 				rmem->name, compat);
 			return 0;
 		}
@@ -245,7 +245,7 @@ static void __init __rmem_check_for_overlap(void)
 
 			this_end = this->base + this->size;
 			next_end = next->base + next->size;
-			pr_err("Reserved memory: OVERLAP DETECTED!\n%s (%pa--%pa) overlaps with %s (%pa--%pa)\n",
+			pr_err("OVERLAP DETECTED!\n%s (%pa--%pa) overlaps with %s (%pa--%pa)\n",
 			       this->name, &this->base, &this_end,
 			       next->name, &next->base, &next_end);
 		}

commit fb810cb5eda8c47e3afbb45ea6b9676841d29e8d
Merge: 241d9bb3427e a99cde438de0
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Fri Jul 8 18:14:03 2016 -0300

    Merge tag 'v4.7-rc6' into patchwork
    
    Linux 4.7-rc6
    
    * tag 'v4.7-rc6': (1245 commits)
      Linux 4.7-rc6
      ovl: warn instead of error if d_type is not supported
      MIPS: Fix possible corruption of cache mode by mprotect.
      locks: use file_inode()
      usb: dwc3: st: Use explicit reset_control_get_exclusive() API
      phy: phy-stih407-usb: Use explicit reset_control_get_exclusive() API
      phy: miphy28lp: Inform the reset framework that our reset line may be shared
      namespace: update event counter when umounting a deleted dentry
      9p: use file_dentry()
      lockd: unregister notifier blocks if the service fails to come up completely
      ACPI,PCI,IRQ: correct operator precedence
      fuse: serialize dirops by default
      drm/i915: Fix missing unlock on error in i915_ppgtt_info()
      powerpc: Initialise pci_io_base as early as possible
      mfd: da9053: Fix compiler warning message for uninitialised variable
      mfd: max77620: Fix FPS switch statements
      phy: phy-stih407-usb: Inform the reset framework that our reset line may be shared
      usb: dwc3: st: Inform the reset framework that our reset line may be shared
      usb: host: ehci-st: Inform the reset framework that our reset line may be shared
      usb: host: ohci-st: Inform the reset framework that our reset line may be shared
      ...

commit 9f5a802b1d51dc80a27d828a5f7dcc8ec4a72f03
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Wed Jun 8 03:51:53 2016 -0300

    [media] of: reserved_mem: restore old behavior when no region is defined
    
    Change return value back to -ENODEV when no region is defined for given
    device. This restores old behavior of this function, as some drivers rely
    on such error code.
    
    Fixes: 59ce4039727ef40 ("of: reserved_mem: add support for using more than
           one region for given device")
    
    Reported-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Reviewed-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Reviewed-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Reviewed-by: Sumit Semwal <sumit.semwal@linaro.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index 04e4fe58fb0c..2b2291bfc38f 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -327,7 +327,7 @@ int of_reserved_mem_device_init_by_idx(struct device *dev,
 
 	target = of_parse_phandle(np, "memory-region", idx);
 	if (!target)
-		return -EINVAL;
+		return -ENODEV;
 
 	rmem = __find_rmem(target);
 	of_node_put(target);

commit aaaab56dba9af4fe75461e0ee13231c1a6ea174d
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Tue May 31 09:38:56 2016 +1000

    of: silence warnings due to max() usage
    
    pageblock_order can be (at least) an unsigned int or an unsigned long
    depending on the kernel config and architecture, so use max_t(unsigned
    long ...) when comparing it.
    
    fixes these warnings:
    
    In file included from include/linux/list.h:8:0,
                     from include/linux/kobject.h:20,
                     from include/linux/of.h:21,
                     from drivers/of/of_reserved_mem.c:17:
    drivers/of/of_reserved_mem.c: In function â__reserved_mem_alloc_sizeâ:
    include/linux/kernel.h:748:17: warning: comparison of distinct pointer types lacks a cast
      (void) (&_max1 == &_max2);  \
                     ^
    include/linux/kernel.h:747:9: note: in definition of macro âmaxâ
      typeof(y) _max2 = (y);   \
             ^
    drivers/of/of_reserved_mem.c:131:48: note: in expansion of macro âmaxâ
       align = max(align, (phys_addr_t)PAGE_SIZE << max(MAX_ORDER - 1, pageblock_ord
                                                    ^
    include/linux/kernel.h:748:17: warning: comparison of distinct pointer types lacks a cast
      (void) (&_max1 == &_max2);  \
                     ^
    include/linux/kernel.h:747:21: note: in definition of macro âmaxâ
      typeof(y) _max2 = (y);   \
                         ^
    drivers/of/of_reserved_mem.c:131:48: note: in expansion of macro âmaxâ
       align = max(align, (phys_addr_t)PAGE_SIZE << max(MAX_ORDER - 1, pageblock_ord
                                                    ^
    
    Fixes: 1cc8e3458b51 ("drivers: of: of_reserved_mem: fixup the alignment with CMA setup")
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index ed7e681efcf0..216648233874 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -130,8 +130,12 @@ static int __init __reserved_mem_alloc_size(unsigned long node,
 	if (IS_ENABLED(CONFIG_CMA)
 	    && of_flat_dt_is_compatible(node, "shared-dma-pool")
 	    && of_get_flat_dt_prop(node, "reusable", NULL)
-	    && !of_get_flat_dt_prop(node, "no-map", NULL))
-		align = max(align, (phys_addr_t)PAGE_SIZE << max(MAX_ORDER - 1, pageblock_order));
+	    && !of_get_flat_dt_prop(node, "no-map", NULL)) {
+		unsigned long order =
+			max_t(unsigned long, MAX_ORDER - 1, pageblock_order);
+
+		align = max(align, (phys_addr_t)PAGE_SIZE << order);
+	}
 
 	prop = of_get_flat_dt_prop(node, "alloc-ranges", &len);
 	if (prop) {

commit 7d482813bb3518cbfeae1b987a5afd76a88c7eb3
Author: Jaewon <jaewon31.kim@samsung.com>
Date:   Wed May 25 13:29:50 2016 +0900

    drivers: of: of_reserved_mem: fixup the CMA alignment not to affect dma-coherent
    
    There was an alignment mismatch issue for CMA and it was fixed by
    commit 1cc8e3458b51 ("drivers: of: of_reserved_mem: fixup the alignment with CMA setup").
    However the way of the commit considers not only dma-contiguous(CMA) but also
    dma-coherent which has no that requirement.
    
    This patch checks more to distinguish dma-contiguous(CMA) from dma-coherent.
    
    Signed-off-by: Jaewon Kim <jaewon31.kim@samsung.com>
    Acked-by: Jason Liu <r64343@freescale.com>
    Acked-by: Marek Szyprowski <m.szyprowski@samsung.com>
    [robh: remove erroneous opening bracket]
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index ed01c0172e4a..ed7e681efcf0 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -127,7 +127,10 @@ static int __init __reserved_mem_alloc_size(unsigned long node,
 	}
 
 	/* Need adjust the alignment to satisfy the CMA requirement */
-	if (IS_ENABLED(CONFIG_CMA) && of_flat_dt_is_compatible(node, "shared-dma-pool"))
+	if (IS_ENABLED(CONFIG_CMA)
+	    && of_flat_dt_is_compatible(node, "shared-dma-pool")
+	    && of_get_flat_dt_prop(node, "reusable", NULL)
+	    && !of_get_flat_dt_prop(node, "no-map", NULL))
 		align = max(align, (phys_addr_t)PAGE_SIZE << max(MAX_ORDER - 1, pageblock_order));
 
 	prop = of_get_flat_dt_prop(node, "alloc-ranges", &len);

commit 59ce4039727ef408769ab0e1263ece893abe22bb
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Tue May 24 15:31:24 2016 +0200

    of: reserved_mem: add support for using more than one region for given device
    
    This patch allows device drivers to initialize more than one reserved
    memory region assigned to given device. When driver needs to use more
    than one reserved memory region, it should allocate child devices and
    initialize regions by index for each of its child devices.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index ed01c0172e4a..04e4fe58fb0c 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -21,6 +21,7 @@
 #include <linux/sizes.h>
 #include <linux/of_reserved_mem.h>
 #include <linux/sort.h>
+#include <linux/slab.h>
 
 #define MAX_RESERVED_REGIONS	16
 static struct reserved_mem reserved_mem[MAX_RESERVED_REGIONS];
@@ -289,53 +290,95 @@ static inline struct reserved_mem *__find_rmem(struct device_node *node)
 	return NULL;
 }
 
+struct rmem_assigned_device {
+	struct device *dev;
+	struct reserved_mem *rmem;
+	struct list_head list;
+};
+
+static LIST_HEAD(of_rmem_assigned_device_list);
+static DEFINE_MUTEX(of_rmem_assigned_device_mutex);
+
 /**
- * of_reserved_mem_device_init() - assign reserved memory region to given device
+ * of_reserved_mem_device_init_by_idx() - assign reserved memory region to
+ *					  given device
+ * @dev:	Pointer to the device to configure
+ * @np:		Pointer to the device_node with 'reserved-memory' property
+ * @idx:	Index of selected region
  *
- * This function assign memory region pointed by "memory-region" device tree
- * property to the given device.
+ * This function assigns respective DMA-mapping operations based on reserved
+ * memory region specified by 'memory-region' property in @np node to the @dev
+ * device. When driver needs to use more than one reserved memory region, it
+ * should allocate child devices and initialize regions by name for each of
+ * child device.
+ *
+ * Returns error code or zero on success.
  */
-int of_reserved_mem_device_init(struct device *dev)
+int of_reserved_mem_device_init_by_idx(struct device *dev,
+				       struct device_node *np, int idx)
 {
+	struct rmem_assigned_device *rd;
+	struct device_node *target;
 	struct reserved_mem *rmem;
-	struct device_node *np;
 	int ret;
 
-	np = of_parse_phandle(dev->of_node, "memory-region", 0);
-	if (!np)
-		return -ENODEV;
+	if (!np || !dev)
+		return -EINVAL;
+
+	target = of_parse_phandle(np, "memory-region", idx);
+	if (!target)
+		return -EINVAL;
 
-	rmem = __find_rmem(np);
-	of_node_put(np);
+	rmem = __find_rmem(target);
+	of_node_put(target);
 
 	if (!rmem || !rmem->ops || !rmem->ops->device_init)
 		return -EINVAL;
 
+	rd = kmalloc(sizeof(struct rmem_assigned_device), GFP_KERNEL);
+	if (!rd)
+		return -ENOMEM;
+
 	ret = rmem->ops->device_init(rmem, dev);
-	if (ret == 0)
+	if (ret == 0) {
+		rd->dev = dev;
+		rd->rmem = rmem;
+
+		mutex_lock(&of_rmem_assigned_device_mutex);
+		list_add(&rd->list, &of_rmem_assigned_device_list);
+		mutex_unlock(&of_rmem_assigned_device_mutex);
+
 		dev_info(dev, "assigned reserved memory node %s\n", rmem->name);
+	} else {
+		kfree(rd);
+	}
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(of_reserved_mem_device_init);
+EXPORT_SYMBOL_GPL(of_reserved_mem_device_init_by_idx);
 
 /**
  * of_reserved_mem_device_release() - release reserved memory device structures
+ * @dev:	Pointer to the device to deconfigure
  *
  * This function releases structures allocated for memory region handling for
  * the given device.
  */
 void of_reserved_mem_device_release(struct device *dev)
 {
-	struct reserved_mem *rmem;
-	struct device_node *np;
-
-	np = of_parse_phandle(dev->of_node, "memory-region", 0);
-	if (!np)
-		return;
-
-	rmem = __find_rmem(np);
-	of_node_put(np);
+	struct rmem_assigned_device *rd;
+	struct reserved_mem *rmem = NULL;
+
+	mutex_lock(&of_rmem_assigned_device_mutex);
+	list_for_each_entry(rd, &of_rmem_assigned_device_list, list) {
+		if (rd->dev == dev) {
+			rmem = rd->rmem;
+			list_del(&rd->list);
+			kfree(rd);
+			break;
+		}
+	}
+	mutex_unlock(&of_rmem_assigned_device_mutex);
 
 	if (!rmem || !rmem->ops || !rmem->ops->device_release)
 		return;

commit e53b50c0cbe392c946807abf7d07615a3c588642
Author: Vinayak Menon <vinmenon@codeaurora.org>
Date:   Mon Feb 22 19:15:44 2016 +0530

    of: alloc anywhere from memblock if range not specified
    
    early_init_dt_alloc_reserved_memory_arch passes end as 0 to
    __memblock_alloc_base, when limits are not specified. But
    __memblock_alloc_base takes end value of 0 as MEMBLOCK_ALLOC_ACCESSIBLE
    and limits the end to memblock.current_limit. This results in regions
    never being placed in HIGHMEM area, for e.g. CMA.
    Let __memblock_alloc_base allocate from anywhere in memory if limits are
    not specified.
    
    Acked-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Vinayak Menon <vinmenon@codeaurora.org>
    Cc: stable@vger.kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index 1a3556a9e9ea..ed01c0172e4a 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -32,11 +32,13 @@ int __init __weak early_init_dt_alloc_reserved_memory_arch(phys_addr_t size,
 	phys_addr_t align, phys_addr_t start, phys_addr_t end, bool nomap,
 	phys_addr_t *res_base)
 {
+	phys_addr_t base;
 	/*
 	 * We use __memblock_alloc_base() because memblock_alloc_base()
 	 * panic()s on allocation failure.
 	 */
-	phys_addr_t base = __memblock_alloc_base(size, align, end);
+	end = !end ? MEMBLOCK_ALLOC_ANYWHERE : end;
+	base = __memblock_alloc_base(size, align, end);
 	if (!base)
 		return -ENOMEM;
 

commit 9eb8cd2b0780bca0719e754e7bdcf5f368f001bd
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Wed Nov 18 21:46:38 2015 +1100

    of: Fix comparison of reserved memory regions
    
    In order to check for overlapping reserved memory regions, we first need
    to sort the array of memory regions. This is implemented using sort(),
    and a custom comparison function __rmem_cmp().
    
    Unfortunatley __rmem_cmp() doesn't work in all cases. Because the two
    base values are phys_addr_t, they may be u64 on some platforms, in which
    case subtracting one from the other and then (implicitly) casting to int
    does not give us the -ve/0/+ve value we need.
    
    This leads to incorrect reports about overlaps, eg:
    
      ibm,slw-image@1ffe600000 (0x0000001ffe600000--0x0000001ffe700000) overlaps with
      ibm,firmware-allocs-memory@1000000000 (0x0000001000000000--0x0000001000dc0200)
    
    Fix it by just doing the standard double if and return 0 logic.
    
    Fixes: ae1add247bf8 ("of: Check for overlap in reserved memory regions")
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index be77e75c587d..1a3556a9e9ea 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -206,7 +206,13 @@ static int __init __rmem_cmp(const void *a, const void *b)
 {
 	const struct reserved_mem *ra = a, *rb = b;
 
-	return ra->base - rb->base;
+	if (ra->base < rb->base)
+		return -1;
+
+	if (ra->base > rb->base)
+		return 1;
+
+	return 0;
 }
 
 static void __init __rmem_check_for_overlap(void)

commit 1cc8e3458b5110253c8f5aaf1890d5ffea9bb7b7
Author: Jason Liu <r64343@freescale.com>
Date:   Tue Nov 10 20:30:26 2015 +0800

    drivers: of: of_reserved_mem: fixup the alignment with CMA setup
    
    There is an alignment mismatch issue between the of_reserved_mem and
    the CMA setup requirement. The of_reserved_mem will try to get the
    alignment value from the DTS and pass it to __memblock_alloc_base to
    do the memory block base allocation, but the alignment value specified
    in the DTS may not satisfy the CAM setup requirement since CMA setup
    required the alignment as the following in the code:
    
    align = PAGE_SIZE << max(MAX_ORDER - 1, pageblock_order);
    
    The sanity check in the function of rmem_cma_setup will fail if the
    alignment does not setup correctly and thus CMA will fail to setup.
    
    This patch is to fixup the alignment to meet the CMA setup required.
    
    Mailing-list-thread: https://lkml.org/lkml/2015/11/9/138
    Signed-off-by: Jason Liu <r64343@freescale.com>
    Acked-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: stable@vger.kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index 49703916a30e..be77e75c587d 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -124,6 +124,10 @@ static int __init __reserved_mem_alloc_size(unsigned long node,
 		align = dt_mem_next_cell(dt_root_addr_cells, &prop);
 	}
 
+	/* Need adjust the alignment to satisfy the CMA requirement */
+	if (IS_ENABLED(CONFIG_CMA) && of_flat_dt_is_compatible(node, "shared-dma-pool"))
+		align = max(align, (phys_addr_t)PAGE_SIZE << max(MAX_ORDER - 1, pageblock_order));
+
 	prop = of_get_flat_dt_prop(node, "alloc-ranges", &len);
 	if (prop) {
 

commit 85a1c77fb8c4ae91d203fd0e8c3b54b50662d3c6
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Tue Nov 10 16:08:33 2015 +1100

    of: Print rather than WARN'ing when overlap check fails
    
    __rmem_check_for_overlap() is called very early in boot, and on some
    powerpc systems it's not safe to call WARN that early in boot.
    
    If the overlap check fails the system will oops instead of printing a
    warning. Furthermore because it's so early in boot the console is not up
    and the user doesn't see the oops, they just get a dead system.
    
    Fix it by printing an error instead of calling WARN.
    
    Fixes: ae1add247bf8 ("of: Check for overlap in reserved memory regions")
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index 62f467b8ccae..49703916a30e 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -226,10 +226,9 @@ static void __init __rmem_check_for_overlap(void)
 
 			this_end = this->base + this->size;
 			next_end = next->base + next->size;
-			WARN(1,
-			     "Reserved memory: OVERLAP DETECTED!\n%s (%pa--%pa) overlaps with %s (%pa--%pa)\n",
-			     this->name, &this->base, &this_end,
-			     next->name, &next->base, &next_end);
+			pr_err("Reserved memory: OVERLAP DETECTED!\n%s (%pa--%pa) overlaps with %s (%pa--%pa)\n",
+			       this->name, &this->base, &this_end,
+			       next->name, &next->base, &next_end);
 		}
 	}
 }

commit ae1add247bf8c22facacbd818142f1f66e735802
Author: Mitchel Humpherys <mitchelh@codeaurora.org>
Date:   Tue Sep 15 18:30:36 2015 -0700

    of: Check for overlap in reserved memory regions
    
    Any overlap in the reserved memory regions (those specified in the
    reserved-memory DT node) is a bug.  These bugs might go undetected as
    long as the contested region isn't used simultaneously by multiple
    software agents, which makes such bugs hard to debug.  Fix this by
    printing a scary warning during boot if overlap is detected.
    
    Signed-off-by: Mitchel Humpherys <mitchelh@codeaurora.org>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index 726ebe792813..62f467b8ccae 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -1,7 +1,7 @@
 /*
  * Device tree based initialization code for reserved memory.
  *
- * Copyright (c) 2013, The Linux Foundation. All Rights Reserved.
+ * Copyright (c) 2013, 2015 The Linux Foundation. All Rights Reserved.
  * Copyright (c) 2013,2014 Samsung Electronics Co., Ltd.
  *		http://www.samsung.com
  * Author: Marek Szyprowski <m.szyprowski@samsung.com>
@@ -20,6 +20,7 @@
 #include <linux/mm.h>
 #include <linux/sizes.h>
 #include <linux/of_reserved_mem.h>
+#include <linux/sort.h>
 
 #define MAX_RESERVED_REGIONS	16
 static struct reserved_mem reserved_mem[MAX_RESERVED_REGIONS];
@@ -197,12 +198,52 @@ static int __init __reserved_mem_init_node(struct reserved_mem *rmem)
 	return -ENOENT;
 }
 
+static int __init __rmem_cmp(const void *a, const void *b)
+{
+	const struct reserved_mem *ra = a, *rb = b;
+
+	return ra->base - rb->base;
+}
+
+static void __init __rmem_check_for_overlap(void)
+{
+	int i;
+
+	if (reserved_mem_count < 2)
+		return;
+
+	sort(reserved_mem, reserved_mem_count, sizeof(reserved_mem[0]),
+	     __rmem_cmp, NULL);
+	for (i = 0; i < reserved_mem_count - 1; i++) {
+		struct reserved_mem *this, *next;
+
+		this = &reserved_mem[i];
+		next = &reserved_mem[i + 1];
+		if (!(this->base && next->base))
+			continue;
+		if (this->base + this->size > next->base) {
+			phys_addr_t this_end, next_end;
+
+			this_end = this->base + this->size;
+			next_end = next->base + next->size;
+			WARN(1,
+			     "Reserved memory: OVERLAP DETECTED!\n%s (%pa--%pa) overlaps with %s (%pa--%pa)\n",
+			     this->name, &this->base, &this_end,
+			     next->name, &next->base, &next_end);
+		}
+	}
+}
+
 /**
  * fdt_init_reserved_mem - allocate and init all saved reserved memory regions
  */
 void __init fdt_init_reserved_mem(void)
 {
 	int i;
+
+	/* check for overlapping reserved regions */
+	__rmem_check_for_overlap();
+
 	for (i = 0; i < reserved_mem_count; i++) {
 		struct reserved_mem *rmem = &reserved_mem[i];
 		unsigned long node = rmem->fdt_node;

commit 615fde79feb854bcda56abf9e5cfcd6638b3d310
Author: George G. Davis <ggdavisiv@gmail.com>
Date:   Fri Jan 9 09:29:05 2015 -0500

    drivers: of: Export of_reserved_mem_device_{init,release}
    
    Export of_reserved_mem_device_{init,release} so that modules
    can initialize and release their assigned per-device cma_area.
    
    Signed-off-by: George G. Davis <george_davis@mentor.com>
    [robh: s/EXPORT_SYMBOL/EXPORT_SYMBOL_GPL/]
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index dc566b38645f..726ebe792813 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -265,6 +265,7 @@ int of_reserved_mem_device_init(struct device *dev)
 
 	return ret;
 }
+EXPORT_SYMBOL_GPL(of_reserved_mem_device_init);
 
 /**
  * of_reserved_mem_device_release() - release reserved memory device structures
@@ -289,3 +290,4 @@ void of_reserved_mem_device_release(struct device *dev)
 
 	rmem->ops->device_release(rmem, dev);
 }
+EXPORT_SYMBOL_GPL(of_reserved_mem_device_release);

commit 47f29df7db78ee4fcdb104cf36918d987ddd0278
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Wed Oct 29 14:50:29 2014 -0700

    drivers: of: add return value to of_reserved_mem_device_init()
    
    Driver calling of_reserved_mem_device_init() might be interested if the
    initialization has been successful or not, so add support for returning
    error code.
    
    This fixes a build warining caused by commit 7bfa5ab6fa1b ("drivers:
    dma-coherent: add initialization from device tree"), which has been
    merged without this change and without fixing function return value.
    
    Fixes: 7bfa5ab6fa1b1 ("drivers: dma-coherent: add initialization from device tree")
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Michal Nazarewicz <mina86@mina86.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Laura Abbott <lauraa@codeaurora.org>
    Cc: Josh Cartwright <joshc@codeaurora.org>
    Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index 59fb12e84e6b..dc566b38645f 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -243,23 +243,27 @@ static inline struct reserved_mem *__find_rmem(struct device_node *node)
  * This function assign memory region pointed by "memory-region" device tree
  * property to the given device.
  */
-void of_reserved_mem_device_init(struct device *dev)
+int of_reserved_mem_device_init(struct device *dev)
 {
 	struct reserved_mem *rmem;
 	struct device_node *np;
+	int ret;
 
 	np = of_parse_phandle(dev->of_node, "memory-region", 0);
 	if (!np)
-		return;
+		return -ENODEV;
 
 	rmem = __find_rmem(np);
 	of_node_put(np);
 
 	if (!rmem || !rmem->ops || !rmem->ops->device_init)
-		return;
+		return -EINVAL;
+
+	ret = rmem->ops->device_init(rmem, dev);
+	if (ret == 0)
+		dev_info(dev, "assigned reserved memory node %s\n", rmem->name);
 
-	rmem->ops->device_init(rmem, dev);
-	dev_info(dev, "assigned reserved memory node %s\n", rmem->name);
+	return ret;
 }
 
 /**

commit 9dcfee01930e6cc1e84d28c232664f0c19a1f86c
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Mon Jul 14 10:28:04 2014 +0200

    drivers: of: add automated assignment of reserved regions to client devices
    
    This patch adds code for automated assignment of reserved memory regions
    to struct device. reserved_mem->ops->device_init()/device_cleanup()
    callbacks are called to perform reserved memory driver specific
    initialization and cleanup
    
    Based on previous code provided by Josh Cartwright <joshc@codeaurora.org>
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index 632aae861375..59fb12e84e6b 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -206,8 +206,16 @@ void __init fdt_init_reserved_mem(void)
 	for (i = 0; i < reserved_mem_count; i++) {
 		struct reserved_mem *rmem = &reserved_mem[i];
 		unsigned long node = rmem->fdt_node;
+		int len;
+		const __be32 *prop;
 		int err = 0;
 
+		prop = of_get_flat_dt_prop(node, "phandle", &len);
+		if (!prop)
+			prop = of_get_flat_dt_prop(node, "linux,phandle", &len);
+		if (prop)
+			rmem->phandle = of_read_number(prop, len/4);
+
 		if (rmem->size == 0)
 			err = __reserved_mem_alloc_size(node, rmem->name,
 						 &rmem->base, &rmem->size);
@@ -215,3 +223,65 @@ void __init fdt_init_reserved_mem(void)
 			__reserved_mem_init_node(rmem);
 	}
 }
+
+static inline struct reserved_mem *__find_rmem(struct device_node *node)
+{
+	unsigned int i;
+
+	if (!node->phandle)
+		return NULL;
+
+	for (i = 0; i < reserved_mem_count; i++)
+		if (reserved_mem[i].phandle == node->phandle)
+			return &reserved_mem[i];
+	return NULL;
+}
+
+/**
+ * of_reserved_mem_device_init() - assign reserved memory region to given device
+ *
+ * This function assign memory region pointed by "memory-region" device tree
+ * property to the given device.
+ */
+void of_reserved_mem_device_init(struct device *dev)
+{
+	struct reserved_mem *rmem;
+	struct device_node *np;
+
+	np = of_parse_phandle(dev->of_node, "memory-region", 0);
+	if (!np)
+		return;
+
+	rmem = __find_rmem(np);
+	of_node_put(np);
+
+	if (!rmem || !rmem->ops || !rmem->ops->device_init)
+		return;
+
+	rmem->ops->device_init(rmem, dev);
+	dev_info(dev, "assigned reserved memory node %s\n", rmem->name);
+}
+
+/**
+ * of_reserved_mem_device_release() - release reserved memory device structures
+ *
+ * This function releases structures allocated for memory region handling for
+ * the given device.
+ */
+void of_reserved_mem_device_release(struct device *dev)
+{
+	struct reserved_mem *rmem;
+	struct device_node *np;
+
+	np = of_parse_phandle(dev->of_node, "memory-region", 0);
+	if (!np)
+		return;
+
+	rmem = __find_rmem(np);
+	of_node_put(np);
+
+	if (!rmem || !rmem->ops || !rmem->ops->device_release)
+		return;
+
+	rmem->ops->device_release(rmem, dev);
+}

commit 9dd3107576c4bbd40e1c2c8b24d560abf9a7b991
Author: Rob Herring <robh@kernel.org>
Date:   Thu May 8 16:06:17 2014 -0500

    of: align RESERVEDMEM_OF_DECLARE function callbacks to other callbacks
    
    All the parameters for RESERVEDMEM_OF_DECLARE function callbacks are
    members of struct reserved_mem, so just pass the struct ptr to callback
    functions so the function callback is more in line with other OF match
    table callbacks.
    
    Acked-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index e420eb52e5c9..632aae861375 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -188,7 +188,7 @@ static int __init __reserved_mem_init_node(struct reserved_mem *rmem)
 		if (!of_flat_dt_is_compatible(rmem->fdt_node, compat))
 			continue;
 
-		if (initfn(rmem, rmem->fdt_node, rmem->name) == 0) {
+		if (initfn(rmem) == 0) {
 			pr_info("Reserved memory: initialized node %s, compatible id %s\n",
 				rmem->name, compat);
 			return 0;

commit 9d0c4dfedd96ee54fc075b16d02f82499c8cc3a6
Author: Rob Herring <robh@kernel.org>
Date:   Tue Apr 1 23:49:03 2014 -0500

    of/fdt: update of_get_flat_dt_prop in prep for libfdt
    
    Make of_get_flat_dt_prop arguments compatible with libfdt fdt_getprop
    call in preparation to convert FDT code to use libfdt. Make the return
    value const and the property length ptr type an int.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Tested-by: Michal Simek <michal.simek@xilinx.com>
    Tested-by: Grant Likely <grant.likely@linaro.org>
    Tested-by: Stephen Chivers <schivers@csc.com>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index daaaf935911d..e420eb52e5c9 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -95,8 +95,8 @@ static int __init __reserved_mem_alloc_size(unsigned long node,
 	int t_len = (dt_root_addr_cells + dt_root_size_cells) * sizeof(__be32);
 	phys_addr_t start = 0, end = 0;
 	phys_addr_t base = 0, align = 0, size;
-	unsigned long len;
-	__be32 *prop;
+	int len;
+	const __be32 *prop;
 	int nomap;
 	int ret;
 

commit f618c4703a14672d27bc2ca5d132a844363d6f5f
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Fri Feb 28 14:42:49 2014 +0100

    drivers: of: add support for custom reserved memory drivers
    
    Add support for custom reserved memory drivers. Call their init() function
    for each reserved region and prepare for using operations provided by them
    with by the reserved_mem->ops array.
    
    Based on previous code provided by Josh Cartwright <joshc@codeaurora.org>
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index 69b811779585..daaaf935911d 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -170,6 +170,33 @@ static int __init __reserved_mem_alloc_size(unsigned long node,
 	return 0;
 }
 
+static const struct of_device_id __rmem_of_table_sentinel
+	__used __section(__reservedmem_of_table_end);
+
+/**
+ * res_mem_init_node() - call region specific reserved memory init code
+ */
+static int __init __reserved_mem_init_node(struct reserved_mem *rmem)
+{
+	extern const struct of_device_id __reservedmem_of_table[];
+	const struct of_device_id *i;
+
+	for (i = __reservedmem_of_table; i < &__rmem_of_table_sentinel; i++) {
+		reservedmem_of_init_fn initfn = i->data;
+		const char *compat = i->compatible;
+
+		if (!of_flat_dt_is_compatible(rmem->fdt_node, compat))
+			continue;
+
+		if (initfn(rmem, rmem->fdt_node, rmem->name) == 0) {
+			pr_info("Reserved memory: initialized node %s, compatible id %s\n",
+				rmem->name, compat);
+			return 0;
+		}
+	}
+	return -ENOENT;
+}
+
 /**
  * fdt_init_reserved_mem - allocate and init all saved reserved memory regions
  */
@@ -184,5 +211,7 @@ void __init fdt_init_reserved_mem(void)
 		if (rmem->size == 0)
 			err = __reserved_mem_alloc_size(node, rmem->name,
 						 &rmem->base, &rmem->size);
+		if (err == 0)
+			__reserved_mem_init_node(rmem);
 	}
 }

commit 3f0c8206644836e4f10a6b9fc47cda6a9a372f9b
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Fri Feb 28 14:42:48 2014 +0100

    drivers: of: add initialization code for dynamic reserved memory
    
    This patch adds support for dynamically allocated reserved memory regions
    declared in device tree. Such regions are defined by 'size', 'alignment'
    and 'alloc-ranges' properties.
    
    Based on previous code provided by Josh Cartwright <joshc@codeaurora.org>
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
new file mode 100644
index 000000000000..69b811779585
--- /dev/null
+++ b/drivers/of/of_reserved_mem.c
@@ -0,0 +1,188 @@
+/*
+ * Device tree based initialization code for reserved memory.
+ *
+ * Copyright (c) 2013, The Linux Foundation. All Rights Reserved.
+ * Copyright (c) 2013,2014 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ * Author: Marek Szyprowski <m.szyprowski@samsung.com>
+ * Author: Josh Cartwright <joshc@codeaurora.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License or (at your optional) any later version of the license.
+ */
+
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+#include <linux/of_platform.h>
+#include <linux/mm.h>
+#include <linux/sizes.h>
+#include <linux/of_reserved_mem.h>
+
+#define MAX_RESERVED_REGIONS	16
+static struct reserved_mem reserved_mem[MAX_RESERVED_REGIONS];
+static int reserved_mem_count;
+
+#if defined(CONFIG_HAVE_MEMBLOCK)
+#include <linux/memblock.h>
+int __init __weak early_init_dt_alloc_reserved_memory_arch(phys_addr_t size,
+	phys_addr_t align, phys_addr_t start, phys_addr_t end, bool nomap,
+	phys_addr_t *res_base)
+{
+	/*
+	 * We use __memblock_alloc_base() because memblock_alloc_base()
+	 * panic()s on allocation failure.
+	 */
+	phys_addr_t base = __memblock_alloc_base(size, align, end);
+	if (!base)
+		return -ENOMEM;
+
+	/*
+	 * Check if the allocated region fits in to start..end window
+	 */
+	if (base < start) {
+		memblock_free(base, size);
+		return -ENOMEM;
+	}
+
+	*res_base = base;
+	if (nomap)
+		return memblock_remove(base, size);
+	return 0;
+}
+#else
+int __init __weak early_init_dt_alloc_reserved_memory_arch(phys_addr_t size,
+	phys_addr_t align, phys_addr_t start, phys_addr_t end, bool nomap,
+	phys_addr_t *res_base)
+{
+	pr_err("Reserved memory not supported, ignoring region 0x%llx%s\n",
+		  size, nomap ? " (nomap)" : "");
+	return -ENOSYS;
+}
+#endif
+
+/**
+ * res_mem_save_node() - save fdt node for second pass initialization
+ */
+void __init fdt_reserved_mem_save_node(unsigned long node, const char *uname,
+				      phys_addr_t base, phys_addr_t size)
+{
+	struct reserved_mem *rmem = &reserved_mem[reserved_mem_count];
+
+	if (reserved_mem_count == ARRAY_SIZE(reserved_mem)) {
+		pr_err("Reserved memory: not enough space all defined regions.\n");
+		return;
+	}
+
+	rmem->fdt_node = node;
+	rmem->name = uname;
+	rmem->base = base;
+	rmem->size = size;
+
+	reserved_mem_count++;
+	return;
+}
+
+/**
+ * res_mem_alloc_size() - allocate reserved memory described by 'size', 'align'
+ *			  and 'alloc-ranges' properties
+ */
+static int __init __reserved_mem_alloc_size(unsigned long node,
+	const char *uname, phys_addr_t *res_base, phys_addr_t *res_size)
+{
+	int t_len = (dt_root_addr_cells + dt_root_size_cells) * sizeof(__be32);
+	phys_addr_t start = 0, end = 0;
+	phys_addr_t base = 0, align = 0, size;
+	unsigned long len;
+	__be32 *prop;
+	int nomap;
+	int ret;
+
+	prop = of_get_flat_dt_prop(node, "size", &len);
+	if (!prop)
+		return -EINVAL;
+
+	if (len != dt_root_size_cells * sizeof(__be32)) {
+		pr_err("Reserved memory: invalid size property in '%s' node.\n",
+				uname);
+		return -EINVAL;
+	}
+	size = dt_mem_next_cell(dt_root_size_cells, &prop);
+
+	nomap = of_get_flat_dt_prop(node, "no-map", NULL) != NULL;
+
+	prop = of_get_flat_dt_prop(node, "alignment", &len);
+	if (prop) {
+		if (len != dt_root_addr_cells * sizeof(__be32)) {
+			pr_err("Reserved memory: invalid alignment property in '%s' node.\n",
+				uname);
+			return -EINVAL;
+		}
+		align = dt_mem_next_cell(dt_root_addr_cells, &prop);
+	}
+
+	prop = of_get_flat_dt_prop(node, "alloc-ranges", &len);
+	if (prop) {
+
+		if (len % t_len != 0) {
+			pr_err("Reserved memory: invalid alloc-ranges property in '%s', skipping node.\n",
+			       uname);
+			return -EINVAL;
+		}
+
+		base = 0;
+
+		while (len > 0) {
+			start = dt_mem_next_cell(dt_root_addr_cells, &prop);
+			end = start + dt_mem_next_cell(dt_root_size_cells,
+						       &prop);
+
+			ret = early_init_dt_alloc_reserved_memory_arch(size,
+					align, start, end, nomap, &base);
+			if (ret == 0) {
+				pr_debug("Reserved memory: allocated memory for '%s' node: base %pa, size %ld MiB\n",
+					uname, &base,
+					(unsigned long)size / SZ_1M);
+				break;
+			}
+			len -= t_len;
+		}
+
+	} else {
+		ret = early_init_dt_alloc_reserved_memory_arch(size, align,
+							0, 0, nomap, &base);
+		if (ret == 0)
+			pr_debug("Reserved memory: allocated memory for '%s' node: base %pa, size %ld MiB\n",
+				uname, &base, (unsigned long)size / SZ_1M);
+	}
+
+	if (base == 0) {
+		pr_info("Reserved memory: failed to allocate memory for node '%s'\n",
+			uname);
+		return -ENOMEM;
+	}
+
+	*res_base = base;
+	*res_size = size;
+
+	return 0;
+}
+
+/**
+ * fdt_init_reserved_mem - allocate and init all saved reserved memory regions
+ */
+void __init fdt_init_reserved_mem(void)
+{
+	int i;
+	for (i = 0; i < reserved_mem_count; i++) {
+		struct reserved_mem *rmem = &reserved_mem[i];
+		unsigned long node = rmem->fdt_node;
+		int err = 0;
+
+		if (rmem->size == 0)
+			err = __reserved_mem_alloc_size(node, rmem->name,
+						 &rmem->base, &rmem->size);
+	}
+}

commit 1931ee143b0ab72924944bc06e363d837ba05063
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Fri Oct 11 09:27:28 2013 +0200

    Revert "drivers: of: add initialization code for dma reserved memory"
    
    This reverts commit 9d8eab7af79cb4ce2de5de39f82c455b1f796963. There is
    still no consensus on the bindings for the reserved memory and various
    drawbacks of the proposed solution has been shown, so the best now is to
    revert it completely and start again from scratch later.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
deleted file mode 100644
index 0fe40c7d6904..000000000000
--- a/drivers/of/of_reserved_mem.c
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Device tree based initialization code for reserved memory.
- *
- * Copyright (c) 2013 Samsung Electronics Co., Ltd.
- *		http://www.samsung.com
- * Author: Marek Szyprowski <m.szyprowski@samsung.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License or (at your optional) any later version of the license.
- */
-
-#include <linux/memblock.h>
-#include <linux/err.h>
-#include <linux/of.h>
-#include <linux/of_fdt.h>
-#include <linux/of_platform.h>
-#include <linux/mm.h>
-#include <linux/sizes.h>
-#include <linux/mm_types.h>
-#include <linux/dma-contiguous.h>
-#include <linux/dma-mapping.h>
-#include <linux/of_reserved_mem.h>
-
-#define MAX_RESERVED_REGIONS	16
-struct reserved_mem {
-	phys_addr_t		base;
-	unsigned long		size;
-	struct cma		*cma;
-	char			name[32];
-};
-static struct reserved_mem reserved_mem[MAX_RESERVED_REGIONS];
-static int reserved_mem_count;
-
-static int __init fdt_scan_reserved_mem(unsigned long node, const char *uname,
-					int depth, void *data)
-{
-	struct reserved_mem *rmem = &reserved_mem[reserved_mem_count];
-	phys_addr_t base, size;
-	int is_cma, is_reserved;
-	unsigned long len;
-	const char *status;
-	__be32 *prop;
-
-	is_cma = IS_ENABLED(CONFIG_DMA_CMA) &&
-	       of_flat_dt_is_compatible(node, "linux,contiguous-memory-region");
-	is_reserved = of_flat_dt_is_compatible(node, "reserved-memory-region");
-
-	if (!is_reserved && !is_cma) {
-		/* ignore node and scan next one */
-		return 0;
-	}
-
-	status = of_get_flat_dt_prop(node, "status", &len);
-	if (status && strcmp(status, "okay") != 0) {
-		/* ignore disabled node nad scan next one */
-		return 0;
-	}
-
-	prop = of_get_flat_dt_prop(node, "reg", &len);
-	if (!prop || (len < (dt_root_size_cells + dt_root_addr_cells) *
-			     sizeof(__be32))) {
-		pr_err("Reserved mem: node %s, incorrect \"reg\" property\n",
-		       uname);
-		/* ignore node and scan next one */
-		return 0;
-	}
-	base = dt_mem_next_cell(dt_root_addr_cells, &prop);
-	size = dt_mem_next_cell(dt_root_size_cells, &prop);
-
-	if (!size) {
-		/* ignore node and scan next one */
-		return 0;
-	}
-
-	pr_info("Reserved mem: found %s, memory base %lx, size %ld MiB\n",
-		uname, (unsigned long)base, (unsigned long)size / SZ_1M);
-
-	if (reserved_mem_count == ARRAY_SIZE(reserved_mem))
-		return -ENOSPC;
-
-	rmem->base = base;
-	rmem->size = size;
-	strlcpy(rmem->name, uname, sizeof(rmem->name));
-
-	if (is_cma) {
-		struct cma *cma;
-		if (dma_contiguous_reserve_area(size, base, 0, &cma) == 0) {
-			rmem->cma = cma;
-			reserved_mem_count++;
-			if (of_get_flat_dt_prop(node,
-						"linux,default-contiguous-region",
-						NULL))
-				dma_contiguous_set_default(cma);
-		}
-	} else if (is_reserved) {
-		if (memblock_remove(base, size) == 0)
-			reserved_mem_count++;
-		else
-			pr_err("Failed to reserve memory for %s\n", uname);
-	}
-
-	return 0;
-}
-
-static struct reserved_mem *get_dma_memory_region(struct device *dev)
-{
-	struct device_node *node;
-	const char *name;
-	int i;
-
-	node = of_parse_phandle(dev->of_node, "memory-region", 0);
-	if (!node)
-		return NULL;
-
-	name = kbasename(node->full_name);
-	for (i = 0; i < reserved_mem_count; i++)
-		if (strcmp(name, reserved_mem[i].name) == 0)
-			return &reserved_mem[i];
-	return NULL;
-}
-
-/**
- * of_reserved_mem_device_init() - assign reserved memory region to given device
- *
- * This function assign memory region pointed by "memory-region" device tree
- * property to the given device.
- */
-void of_reserved_mem_device_init(struct device *dev)
-{
-	struct reserved_mem *region = get_dma_memory_region(dev);
-	if (!region)
-		return;
-
-	if (region->cma) {
-		dev_set_cma_area(dev, region->cma);
-		pr_info("Assigned CMA %s to %s device\n", region->name,
-			dev_name(dev));
-	} else {
-		if (dma_declare_coherent_memory(dev, region->base, region->base,
-		    region->size, DMA_MEMORY_MAP | DMA_MEMORY_EXCLUSIVE) != 0)
-			pr_info("Declared reserved memory %s to %s device\n",
-				region->name, dev_name(dev));
-	}
-}
-
-/**
- * of_reserved_mem_device_release() - release reserved memory device structures
- *
- * This function releases structures allocated for memory region handling for
- * the given device.
- */
-void of_reserved_mem_device_release(struct device *dev)
-{
-	struct reserved_mem *region = get_dma_memory_region(dev);
-	if (!region && !region->cma)
-		dma_release_declared_memory(dev);
-}
-
-/**
- * early_init_dt_scan_reserved_mem() - create reserved memory regions
- *
- * This function grabs memory from early allocator for device exclusive use
- * defined in device tree structures. It should be called by arch specific code
- * once the early allocator (memblock) has been activated and all other
- * subsystems have already allocated/reserved memory.
- */
-void __init early_init_dt_scan_reserved_mem(void)
-{
-	of_scan_flat_dt_by_path("/memory/reserved-memory",
-				fdt_scan_reserved_mem, NULL);
-}

commit aca0156a9c4ba47ca021b69d1fd7442aff49a7ab
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Tue Sep 10 15:43:40 2013 +0200

    drivers: of: fix build break if asm/dma-contiguous.h is missing
    
    It is not needed to include asm/dma-contiguous.h header to compile
    reserved memory initialization code, so remove it to avoid build break
    on architectures without CMA support.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Tested-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index a754b84ba016..0fe40c7d6904 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -11,8 +11,6 @@
  * License or (at your optional) any later version of the license.
  */
 
-#include <asm/dma-contiguous.h>
-
 #include <linux/memblock.h>
 #include <linux/err.h>
 #include <linux/of.h>

commit 9d8eab7af79cb4ce2de5de39f82c455b1f796963
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Mon Aug 26 14:43:10 2013 +0200

    drivers: of: add initialization code for dma reserved memory
    
    This patch adds device tree support for contiguous and reserved memory
    regions defined in device tree.
    
    Large memory blocks can be reliably reserved only during early boot.
    This must happen before the whole memory management subsystem is
    initialized, because we need to ensure that the given contiguous blocks
    are not yet allocated by kernel. Also it must happen before kernel
    mappings for the whole low memory are created, to ensure that there will
    be no mappings (for reserved blocks) or mapping with special properties
    can be created (for CMA blocks). This all happens before device tree
    structures are unflattened, so we need to get reserved memory layout
    directly from fdt.
    
    Later, those reserved memory regions are assigned to devices on each
    device structure initialization.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Acked-by: Tomasz Figa <t.figa@samsung.com>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Reviewed-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
new file mode 100644
index 000000000000..a754b84ba016
--- /dev/null
+++ b/drivers/of/of_reserved_mem.c
@@ -0,0 +1,175 @@
+/*
+ * Device tree based initialization code for reserved memory.
+ *
+ * Copyright (c) 2013 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ * Author: Marek Szyprowski <m.szyprowski@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License or (at your optional) any later version of the license.
+ */
+
+#include <asm/dma-contiguous.h>
+
+#include <linux/memblock.h>
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+#include <linux/of_platform.h>
+#include <linux/mm.h>
+#include <linux/sizes.h>
+#include <linux/mm_types.h>
+#include <linux/dma-contiguous.h>
+#include <linux/dma-mapping.h>
+#include <linux/of_reserved_mem.h>
+
+#define MAX_RESERVED_REGIONS	16
+struct reserved_mem {
+	phys_addr_t		base;
+	unsigned long		size;
+	struct cma		*cma;
+	char			name[32];
+};
+static struct reserved_mem reserved_mem[MAX_RESERVED_REGIONS];
+static int reserved_mem_count;
+
+static int __init fdt_scan_reserved_mem(unsigned long node, const char *uname,
+					int depth, void *data)
+{
+	struct reserved_mem *rmem = &reserved_mem[reserved_mem_count];
+	phys_addr_t base, size;
+	int is_cma, is_reserved;
+	unsigned long len;
+	const char *status;
+	__be32 *prop;
+
+	is_cma = IS_ENABLED(CONFIG_DMA_CMA) &&
+	       of_flat_dt_is_compatible(node, "linux,contiguous-memory-region");
+	is_reserved = of_flat_dt_is_compatible(node, "reserved-memory-region");
+
+	if (!is_reserved && !is_cma) {
+		/* ignore node and scan next one */
+		return 0;
+	}
+
+	status = of_get_flat_dt_prop(node, "status", &len);
+	if (status && strcmp(status, "okay") != 0) {
+		/* ignore disabled node nad scan next one */
+		return 0;
+	}
+
+	prop = of_get_flat_dt_prop(node, "reg", &len);
+	if (!prop || (len < (dt_root_size_cells + dt_root_addr_cells) *
+			     sizeof(__be32))) {
+		pr_err("Reserved mem: node %s, incorrect \"reg\" property\n",
+		       uname);
+		/* ignore node and scan next one */
+		return 0;
+	}
+	base = dt_mem_next_cell(dt_root_addr_cells, &prop);
+	size = dt_mem_next_cell(dt_root_size_cells, &prop);
+
+	if (!size) {
+		/* ignore node and scan next one */
+		return 0;
+	}
+
+	pr_info("Reserved mem: found %s, memory base %lx, size %ld MiB\n",
+		uname, (unsigned long)base, (unsigned long)size / SZ_1M);
+
+	if (reserved_mem_count == ARRAY_SIZE(reserved_mem))
+		return -ENOSPC;
+
+	rmem->base = base;
+	rmem->size = size;
+	strlcpy(rmem->name, uname, sizeof(rmem->name));
+
+	if (is_cma) {
+		struct cma *cma;
+		if (dma_contiguous_reserve_area(size, base, 0, &cma) == 0) {
+			rmem->cma = cma;
+			reserved_mem_count++;
+			if (of_get_flat_dt_prop(node,
+						"linux,default-contiguous-region",
+						NULL))
+				dma_contiguous_set_default(cma);
+		}
+	} else if (is_reserved) {
+		if (memblock_remove(base, size) == 0)
+			reserved_mem_count++;
+		else
+			pr_err("Failed to reserve memory for %s\n", uname);
+	}
+
+	return 0;
+}
+
+static struct reserved_mem *get_dma_memory_region(struct device *dev)
+{
+	struct device_node *node;
+	const char *name;
+	int i;
+
+	node = of_parse_phandle(dev->of_node, "memory-region", 0);
+	if (!node)
+		return NULL;
+
+	name = kbasename(node->full_name);
+	for (i = 0; i < reserved_mem_count; i++)
+		if (strcmp(name, reserved_mem[i].name) == 0)
+			return &reserved_mem[i];
+	return NULL;
+}
+
+/**
+ * of_reserved_mem_device_init() - assign reserved memory region to given device
+ *
+ * This function assign memory region pointed by "memory-region" device tree
+ * property to the given device.
+ */
+void of_reserved_mem_device_init(struct device *dev)
+{
+	struct reserved_mem *region = get_dma_memory_region(dev);
+	if (!region)
+		return;
+
+	if (region->cma) {
+		dev_set_cma_area(dev, region->cma);
+		pr_info("Assigned CMA %s to %s device\n", region->name,
+			dev_name(dev));
+	} else {
+		if (dma_declare_coherent_memory(dev, region->base, region->base,
+		    region->size, DMA_MEMORY_MAP | DMA_MEMORY_EXCLUSIVE) != 0)
+			pr_info("Declared reserved memory %s to %s device\n",
+				region->name, dev_name(dev));
+	}
+}
+
+/**
+ * of_reserved_mem_device_release() - release reserved memory device structures
+ *
+ * This function releases structures allocated for memory region handling for
+ * the given device.
+ */
+void of_reserved_mem_device_release(struct device *dev)
+{
+	struct reserved_mem *region = get_dma_memory_region(dev);
+	if (!region && !region->cma)
+		dma_release_declared_memory(dev);
+}
+
+/**
+ * early_init_dt_scan_reserved_mem() - create reserved memory regions
+ *
+ * This function grabs memory from early allocator for device exclusive use
+ * defined in device tree structures. It should be called by arch specific code
+ * once the early allocator (memblock) has been activated and all other
+ * subsystems have already allocated/reserved memory.
+ */
+void __init early_init_dt_scan_reserved_mem(void)
+{
+	of_scan_flat_dt_by_path("/memory/reserved-memory",
+				fdt_scan_reserved_mem, NULL);
+}
