commit f43775625e28703469198657392168c5fe961edc
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Thu Mar 19 18:10:58 2020 -0500

    of: of_private.h: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index 207863c151a5..edc682249c00 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -24,7 +24,7 @@ struct alias_prop {
 	const char *alias;
 	struct device_node *np;
 	int id;
-	char stem[0];
+	char stem[];
 };
 
 #if defined(CONFIG_SPARC)

commit 90dc0d1ce890419f977e460b8258d25187dde64f
Author: Rob Herring <robh@kernel.org>
Date:   Fri Dec 6 16:27:41 2019 -0600

    of: Rework and simplify phandle cache to use a fixed size
    
    The phandle cache was added to speed up of_find_node_by_phandle() by
    avoiding walking the whole DT to find a matching phandle. The
    implementation has several shortcomings:
    
      - The cache is designed to work on a linear set of phandle values.
        This is true for dtc generated DTs, but not for other cases such as
        Power.
      - The cache isn't enabled until of_core_init() and a typical system
        may see hundreds of calls to of_find_node_by_phandle() before that
        point.
      - The cache is freed and re-allocated when the number of phandles
        changes.
      - It takes a raw spinlock around a memory allocation which breaks on
        RT.
    
    Change the implementation to a fixed size and use hash_32() as the
    cache index. This greatly simplifies the implementation. It avoids
    the need for any re-alloc of the cache and taking a reference on nodes
    in the cache. We only have a single source of removing cache entries
    which is of_detach_node().
    
    Using hash_32() removes any assumption on phandle values improving
    the hit rate for non-linear phandle values. The effect on linear values
    using hash_32() is about a 10% collision. The chances of thrashing on
    colliding values seems to be low.
    
    To compare performance, I used a RK3399 board which is a pretty typical
    system. I found that just measuring boot time as done previously is
    noisy and may be impacted by other things. Also bringing up secondary
    cores causes some issues with measuring, so I booted with 'nr_cpus=1'.
    With no caching, calls to of_find_node_by_phandle() take about 20124 us
    for 1248 calls. There's an additional 288 calls before time keeping is
    up. Using the average time per hit/miss with the cache, we can calculate
    these calls to take 690 us (277 hit / 11 miss) with a 128 entry cache
    and 13319 us with no cache or an uninitialized cache.
    
    Comparing the 3 implementations the time spent in
    of_find_node_by_phandle() is:
    
    no cache:        20124 us (+ 13319 us)
    128 entry cache:  5134 us (+ 690 us)
    current cache:     819 us (+ 13319 us)
    
    We could move the allocation of the cache earlier to improve the
    current cache, but that just further complicates the situation as it
    needs to be after slab is up, so we can't do it when unflattening (which
    uses memblock).
    
    Reported-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Segher Boessenkool <segher@kernel.crashing.org>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Acked-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Reviewed-by: Frank Rowand <frowand.list@gmail.com>
    Tested-by: Frank Rowand <frowand.list@gmail.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index 66294d29942a..207863c151a5 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -84,15 +84,11 @@ static inline void __of_detach_node_sysfs(struct device_node *np) {}
 int of_resolve_phandles(struct device_node *tree);
 #endif
 
-#if defined(CONFIG_OF_DYNAMIC)
-void __of_free_phandle_cache_entry(phandle handle);
-#endif
+void __of_phandle_cache_inv_entry(phandle handle);
 
 #if defined(CONFIG_OF_OVERLAY)
 void of_overlay_mutex_lock(void);
 void of_overlay_mutex_unlock(void);
-int of_free_phandle_cache(void);
-void of_populate_phandle_cache(void);
 #else
 static inline void of_overlay_mutex_lock(void) {};
 static inline void of_overlay_mutex_unlock(void) {};

commit b68ac8dc22ebbf003e26e44bf4dd3030c076df5a
Author: Robin Murphy <robin.murphy@arm.com>
Date:   Tue Jul 2 18:42:39 2019 +0100

    of: Factor out #{addr,size}-cells parsing
    
    In some cases such as PCI host controllers, we may have a "parent bus"
    which is an OF leaf node, but still need to correctly parse ranges from
    the point of view of that bus. For that, factor out variants of the
    "#addr-cells" and "#size-cells" parsers which do not assume they have a
    device node and thus immediately traverse upwards before reading the
    relevant property.
    
    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    [robh: don't make of_bus_n_{addr,size}_cells() public]
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Tested-by: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
    Reviewed-by: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index f8c58615c393..66294d29942a 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -158,6 +158,9 @@ extern void __of_sysfs_remove_bin_file(struct device_node *np,
 #define for_each_transaction_entry_reverse(_oft, _te) \
 	list_for_each_entry_reverse(_te, &(_oft)->te_list, node)
 
+extern int of_bus_n_addr_cells(struct device_node *np);
+extern int of_bus_n_size_cells(struct device_node *np);
+
 #ifdef CONFIG_OF_ADDRESS
 extern int of_dma_get_range(struct device_node *np, u64 *dma_addr,
 			    u64 *paddr, u64 *size);

commit 6e6faf63744333373db8bc64aea52dab86cbf0bc
Author: Rob Herring <robh@kernel.org>
Date:   Thu Sep 5 11:53:27 2019 +0100

    of: Make of_dma_get_range() private
    
    of_dma_get_range() is only used within the DT core code, so remove the
    export and move the header declaration to the private header.
    
    Cc: Robin Murphy <robin.murphy@arm.com>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Tested-by: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
    Reviewed-by: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index 24786818e32e..f8c58615c393 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -158,4 +158,15 @@ extern void __of_sysfs_remove_bin_file(struct device_node *np,
 #define for_each_transaction_entry_reverse(_oft, _te) \
 	list_for_each_entry_reverse(_te, &(_oft)->te_list, node)
 
+#ifdef CONFIG_OF_ADDRESS
+extern int of_dma_get_range(struct device_node *np, u64 *dma_addr,
+			    u64 *paddr, u64 *size);
+#else
+static inline int of_dma_get_range(struct device_node *np, u64 *dma_addr,
+				   u64 *paddr, u64 *size)
+{
+	return -ENODEV;
+}
+#endif
+
 #endif /* _LINUX_OF_PRIVATE_H */

commit 5801169a2ed20003f771acecf3ac00574cf10a38
Author: Frank Rowand <frank.rowand@sony.com>
Date:   Tue Dec 18 11:40:03 2018 -0800

    of: __of_detach_node() - remove node from phandle cache
    
    Non-overlay dynamic devicetree node removal may leave the node in
    the phandle cache.  Subsequent calls to of_find_node_by_phandle()
    will incorrectly find the stale entry.  Remove the node from the
    cache.
    
    Add paranoia checks in of_find_node_by_phandle() as a second level
    of defense (do not return cached node if detached, do not add node
    to cache if detached).
    
    Fixes: 0b3ce78e90fc ("of: cache phandle nodes to reduce cost of of_find_node_by_phandle()")
    Reported-by: Michael Bringmann <mwb@linux.vnet.ibm.com>
    Cc: stable@vger.kernel.org # v4.17+
    Signed-off-by: Frank Rowand <frank.rowand@sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index 5d1567025358..24786818e32e 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -84,6 +84,10 @@ static inline void __of_detach_node_sysfs(struct device_node *np) {}
 int of_resolve_phandles(struct device_node *tree);
 #endif
 
+#if defined(CONFIG_OF_DYNAMIC)
+void __of_free_phandle_cache_entry(phandle handle);
+#endif
+
 #if defined(CONFIG_OF_OVERLAY)
 void of_overlay_mutex_lock(void);
 void of_overlay_mutex_unlock(void);

commit 00b7d1cf46676ad5e6338e80dc6230e1b6e71b86
Author: Rob Herring <robh@kernel.org>
Date:   Wed Aug 29 17:21:45 2018 -0500

    of: make default address and size cells sizes private
    
    Only some old OpenFirmware implementations rely on default sizes. Any
    FDT and modern implementation should have explicit properties. Make the
    OF_ROOT_NODE_*_CELLS_DEFAULT defines private so we don't get any outside
    users.
    
    This also gets us one step closer to removing the asm/prom.h dependency on
    Sparc.
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: sparclinux@vger.kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index 216175d11d3d..5d1567025358 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -27,6 +27,14 @@ struct alias_prop {
 	char stem[0];
 };
 
+#if defined(CONFIG_SPARC)
+#define OF_ROOT_NODE_ADDR_CELLS_DEFAULT 2
+#else
+#define OF_ROOT_NODE_ADDR_CELLS_DEFAULT 1
+#endif
+
+#define OF_ROOT_NODE_SIZE_CELLS_DEFAULT 1
+
 extern struct mutex of_mutex;
 extern struct list_head aliases_lookup;
 extern struct kset *of_kset;

commit b9952b5218added5577e4a3443969bc20884cea9
Author: Frank Rowand <frank.rowand@sony.com>
Date:   Thu Jul 12 14:00:07 2018 -0700

    of: overlay: update phandle cache on overlay apply and remove
    
    A comment in the review of the patch adding the phandle cache said that
    the cache would have to be updated when modules are applied and removed.
    This patch implements the cache updates.
    
    Fixes: 0b3ce78e90fc ("of: cache phandle nodes to reduce cost of of_find_node_by_phandle()")
    Reported-by: Alan Tull <atull@kernel.org>
    Suggested-by: Alan Tull <atull@kernel.org>
    Signed-off-by: Frank Rowand <frank.rowand@sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index 891d780c076a..216175d11d3d 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -79,6 +79,8 @@ int of_resolve_phandles(struct device_node *tree);
 #if defined(CONFIG_OF_OVERLAY)
 void of_overlay_mutex_lock(void);
 void of_overlay_mutex_unlock(void);
+int of_free_phandle_cache(void);
+void of_populate_phandle_cache(void);
 #else
 static inline void of_overlay_mutex_lock(void) {};
 static inline void of_overlay_mutex_unlock(void) {};

commit 0b3ce78e90fc66c50a944320d6e39fa6fdb46cdf
Author: Frank Rowand <frank.rowand@sony.com>
Date:   Sun Mar 4 16:14:47 2018 -0800

    of: cache phandle nodes to reduce cost of of_find_node_by_phandle()
    
    Create a cache of the nodes that contain a phandle property.  Use this
    cache to find the node for a given phandle value instead of scanning
    the devicetree to find the node.  If the phandle value is not found
    in the cache, of_find_node_by_phandle() will fall back to the tree
    scan algorithm.
    
    The cache is initialized in of_core_init().
    
    The cache is freed via a late_initcall_sync() if modules are not
    enabled.
    
    If the devicetree is created by the dtc compiler, with all phandle
    property values auto generated, then the size required by the cache
    could be 4 * (1 + number of phandles) bytes.  This results in an O(1)
    node lookup cost for a given phandle value.  Due to a concern that the
    phandle property values might not be consistent with what is generated
    by the dtc compiler, a mask has been added to the cache lookup algorithm.
    To maintain the O(1) node lookup cost, the size of the cache has been
    increased by rounding the number of entries up to the next power of
    two.
    
    The overhead of finding the devicetree node containing a given phandle
    value has been noted by several people in the recent past, in some cases
    with a patch to add a hashed index of devicetree nodes, based on the
    phandle value of the node.  One concern with this approach is the extra
    space added to each node.  This patch takes advantage of the phandle
    property values auto generated by the dtc compiler, which begin with
    one and monotonically increase by one, resulting in a range of 1..n
    for n phandle values.  This implementation should also provide a good
    reduction of overhead for any range of phandle values that are mostly
    in a monotonic range.
    
    Performance measurements by Chintan Pandya <cpandya@codeaurora.org>
    of several implementations of patches that are similar to this one
    suggest an expected reduction of boot time by ~400ms for his test
    system.  If the cache size was decreased to 64 entries, the boot
    time was reduced by ~340 ms.  The measurements were on a 4.9.73 kernel
    for arch/arm64/boot/dts/qcom/sda670-mtp.dts, contains 2371 nodes and
    814 phandle values.
    
    Reported-by: Chintan Pandya <cpandya@codeaurora.org>
    Signed-off-by: Frank Rowand <frank.rowand@sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index 26bb31beb03e..891d780c076a 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -132,6 +132,9 @@ extern void __of_detach_node_sysfs(struct device_node *np);
 extern void __of_sysfs_remove_bin_file(struct device_node *np,
 				       struct property *prop);
 
+/* illegal phandle value (set when unresolved) */
+#define OF_PHANDLE_ILLEGAL	0xdeadbeef
+
 /* iterators for transactions, used for overlays */
 /* forward iterator */
 #define for_each_transaction_entry(_oft, _te) \

commit b89dae1852869d6bb3e4a8e3c6bdaf86dc2ef9da
Author: Frank Rowand <frank.rowand@sony.com>
Date:   Mon Feb 26 14:01:23 2018 -0800

    of: overlay: do not include path in full_name of added nodes
    
    Struct device_node full_name no longer includes the full path name
    when the devicetree is created from a flattened device tree (FDT).
    The overlay node creation code was not modified to reflect this
    change.  Fix the node full_name generated by overlay code to contain
    only the basename.
    
    Unittests call an overlay internal function to create new nodes.
    Fix up these calls to provide basename only instead of the full
    path.
    
    Fixes: a7e4cfb0a7ca ("of/fdt: only store the device node basename
    in full_name")
    
    Signed-off-by: Frank Rowand <frank.rowand@sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index 0c609e7d0334..26bb31beb03e 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -104,7 +104,8 @@ extern void *__unflatten_device_tree(const void *blob,
  * own the devtree lock or work on detached trees only.
  */
 struct property *__of_prop_dup(const struct property *prop, gfp_t allocflags);
-__printf(2, 3) struct device_node *__of_node_dup(const struct device_node *np, const char *fmt, ...);
+struct device_node *__of_node_dup(const struct device_node *np,
+				  const char *full_name);
 
 struct device_node *__of_find_node_by_path(struct device_node *parent,
 						const char *path);

commit af6074fc9aa4b29517375634189ada1869eea598
Author: Rob Herring <robh@kernel.org>
Date:   Wed Dec 27 12:55:14 2017 -0600

    of: Use SPDX license tag for DT files
    
    Convert remaining DT files to use SPDX-License-Identifier tags.
    
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    Reviewed-by: Frank Rowand <frank.rowand@sony.com>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index 92a9a3687446..0c609e7d0334 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
 #ifndef _LINUX_OF_PRIVATE_H
 #define _LINUX_OF_PRIVATE_H
 /*
@@ -5,11 +6,6 @@
  *
  * Paul Mackerras	August 1996.
  * Copyright (C) 1996-2005 Paul Mackerras.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
  */
 
 /**

commit e0a58f3e08d4b7fa8e2a4075c522f1a98c9e4cab
Author: Frank Rowand <frank.rowand@sony.com>
Date:   Tue Oct 17 16:36:31 2017 -0700

    of: overlay: remove a dependency on device node full_name
    
    The "%pOF" printf format was recently added to print the
    full name of a device tree node, with the intent of changing
    the node full_name field to contain only the node name instead
    of the full path of the node.
    
    dup_and_fixup_symbol_prop() duplicates a property from the
    "/__symbols__" node of an overlay device tree.  The value
    of each duplicated property must be fixed up to include
    the full path of a node in the live device tree.  The
    current code uses the node's full_name for that purpose.
    Update the code to use the "%pOF" printf format to
    determine the node's full path.
    
    Signed-off-by: Frank Rowand <frank.rowand@sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index 248730567dbe..92a9a3687446 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -110,6 +110,8 @@ extern void *__unflatten_device_tree(const void *blob,
 struct property *__of_prop_dup(const struct property *prop, gfp_t allocflags);
 __printf(2, 3) struct device_node *__of_node_dup(const struct device_node *np, const char *fmt, ...);
 
+struct device_node *__of_find_node_by_path(struct device_node *parent,
+						const char *path);
 struct device_node *__of_find_node_by_full_path(struct device_node *node,
 						const char *path);
 

commit f948d6d8b792bb90041edc12eac35faf83030994
Author: Frank Rowand <frank.rowand@sony.com>
Date:   Tue Oct 17 16:36:29 2017 -0700

    of: overlay: avoid race condition between applying multiple overlays
    
    The process of applying an overlay consists of:
      - unflatten an overlay FDT (flattened device tree) into an
        EDT (expanded device tree)
      - fixup the phandle values in the overlay EDT to fit in a
        range above the phandle values in the live device tree
      - create the overlay changeset to reflect the contents of
        the overlay EDT
      - apply the overlay changeset, to modify the live device tree,
        potentially changing the maximum phandle value in the live
        device tree
    
    There is currently no protection against two overlay applies
    concurrently determining what range of phandle values are in use
    in the live device tree, and subsequently changing that range.
    Add a mutex to prevent multiple overlay applies from occurring
    simultaneously.
    
    Move of_resolve_phandles() into of_overlay_apply() so that it does not
    have to be duplicated by each caller of of_overlay_apply().
    
    The test in of_resolve_phandles() that the overlay tree is detached is
    temporarily disabled so that old style overlay unittests do not fail.
    
    Signed-off-by: Frank Rowand <frank.rowand@sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index 36357f571df2..248730567dbe 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -76,6 +76,18 @@ static inline int __of_attach_node_sysfs(struct device_node *np)
 static inline void __of_detach_node_sysfs(struct device_node *np) {}
 #endif
 
+#if defined(CONFIG_OF_RESOLVE)
+int of_resolve_phandles(struct device_node *tree);
+#endif
+
+#if defined(CONFIG_OF_OVERLAY)
+void of_overlay_mutex_lock(void);
+void of_overlay_mutex_unlock(void);
+#else
+static inline void of_overlay_mutex_lock(void) {};
+static inline void of_overlay_mutex_unlock(void) {};
+#endif
+
 #if defined(CONFIG_OF_UNITTEST) && defined(CONFIG_OF_OVERLAY)
 extern void __init unittest_unflatten_overlay_base(void);
 #else

commit 24789c5ce5a373dd55640f9cd79117fcc3ccc46d
Author: Frank Rowand <frank.rowand@sony.com>
Date:   Tue Oct 17 16:36:26 2017 -0700

    of: overlay: detect cases where device tree may become corrupt
    
    When an attempt to apply an overlay changeset fails, an effort
    is made to revert any partial application of the changeset.
    When an attempt to remove an overlay changeset fails, an effort
    is made to re-apply any partial reversion of the changeset.
    
    The existing code does not check for failure to recover a failed
    overlay changeset application or overlay changeset revert.
    
    Add the missing checks and flag the devicetree as corrupt if the
    state of the devicetree can not be determined.
    
    Improve and expand the returned errors to more fully reflect the
    result of the effort to undo the partial effects of a failed attempt
    to apply or remove an overlay changeset.
    
    If the device tree might be corrupt, do not allow further attempts
    to apply or remove an overlay changeset.
    
    When creating an overlay changeset from an overlay device tree,
    add some additional warnings if the state of the overlay device
    tree is not as expected.
    
    Signed-off-by: Frank Rowand <frank.rowand@sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index 43df14f0cbce..36357f571df2 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -39,8 +39,12 @@ extern struct kset *of_kset;
 extern int of_property_notify(int action, struct device_node *np,
 			      struct property *prop, struct property *old_prop);
 extern void of_node_release(struct kobject *kobj);
-extern int __of_changeset_apply(struct of_changeset *ocs);
-extern int __of_changeset_revert(struct of_changeset *ocs);
+extern int __of_changeset_apply_entries(struct of_changeset *ocs,
+					int *ret_revert);
+extern int __of_changeset_apply_notify(struct of_changeset *ocs);
+extern int __of_changeset_revert_entries(struct of_changeset *ocs,
+					 int *ret_apply);
+extern int __of_changeset_revert_notify(struct of_changeset *ocs);
 #else /* CONFIG_OF_DYNAMIC */
 static inline int of_property_notify(int action, struct device_node *np,
 				     struct property *prop, struct property *old_prop)

commit b56b5528f5b3c3d47e7c0ca67318c45e980d93f0
Author: Rob Herring <robh@kernel.org>
Date:   Wed Oct 4 14:09:40 2017 -0500

    of: make kobject and bin_attribute support configurable
    
    Having device_nodes be kobjects is only needed if sysfs or OF_DYNAMIC is
    enabled. Otherwise, having a kobject in struct device_node is
    unnecessary bloat in minimal kernel configurations.
    
    Likewise, bin_attribute is only needed in struct property when sysfs is
    enabled, so we can make it configurable too.
    
    Tested-by: Nicolas Pitre <nico@linaro.org>
    Reviewed-by: Frank Rowand <frowand.list@gmail.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index cc86a974f35f..43df14f0cbce 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -49,6 +49,29 @@ static inline int of_property_notify(int action, struct device_node *np,
 }
 #endif /* CONFIG_OF_DYNAMIC */
 
+#if defined(CONFIG_OF_KOBJ)
+int of_node_is_attached(struct device_node *node);
+int __of_add_property_sysfs(struct device_node *np, struct property *pp);
+void __of_remove_property_sysfs(struct device_node *np, struct property *prop);
+void __of_update_property_sysfs(struct device_node *np, struct property *newprop,
+		struct property *oldprop);
+int __of_attach_node_sysfs(struct device_node *np);
+void __of_detach_node_sysfs(struct device_node *np);
+#else
+static inline int __of_add_property_sysfs(struct device_node *np, struct property *pp)
+{
+	return 0;
+}
+static inline void __of_remove_property_sysfs(struct device_node *np, struct property *prop) {}
+static inline void __of_update_property_sysfs(struct device_node *np,
+		struct property *newprop, struct property *oldprop) {}
+static inline int __of_attach_node_sysfs(struct device_node *np)
+{
+	return 0;
+}
+static inline void __of_detach_node_sysfs(struct device_node *np) {}
+#endif
+
 #if defined(CONFIG_OF_UNITTEST) && defined(CONFIG_OF_OVERLAY)
 extern void __init unittest_unflatten_overlay_base(void);
 #else

commit 4c2bb57400394e4ec631a42dcf637e925db6202e
Author: Rob Herring <robh@kernel.org>
Date:   Wed Oct 4 19:30:53 2017 -0500

    of: move kobj_to_device_node() into dynamic.c
    
    The only user of kobj_to_device_node() is in dynamic.c, so move it
    there. This avoids having to make it conditional once kobject is
    configurable.
    
    Tested-by: Nicolas Pitre <nico@linaro.org>
    Reviewed-by: Frank Rowand <frowand.list@gmail.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index 3ae12ffbf547..cc86a974f35f 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -35,12 +35,6 @@ extern struct mutex of_mutex;
 extern struct list_head aliases_lookup;
 extern struct kset *of_kset;
 
-
-static inline struct device_node *kobj_to_device_node(struct kobject *kobj)
-{
-	return container_of(kobj, struct device_node, kobj);
-}
-
 #if defined(CONFIG_OF_DYNAMIC)
 extern int of_property_notify(int action, struct device_node *np,
 			      struct property *prop, struct property *old_prop);

commit 27497e11b56a072dfd80e9f1f229049b2921a1a6
Author: Rob Herring <robh@kernel.org>
Date:   Fri Jun 2 12:43:18 2017 -0500

    of: find_node_by_full_name rewrite to compare each level
    
    find_node_by_full_name() does the same thing as of_find_node_by_path(),
    but takes no locks and doesn't work on aliases. Refactor
    of_find_node_opts_by_path() into __of_find_node_by_full_path() and
    replace find_node_by_full_name() with it.
    
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index dd535365b5d2..3ae12ffbf547 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -77,6 +77,9 @@ extern void *__unflatten_device_tree(const void *blob,
 struct property *__of_prop_dup(const struct property *prop, gfp_t allocflags);
 __printf(2, 3) struct device_node *__of_node_dup(const struct device_node *np, const char *fmt, ...);
 
+struct device_node *__of_find_node_by_full_path(struct device_node *node,
+						const char *path);
+
 extern const void *__of_get_property(const struct device_node *np,
 				     const char *name, int *lenp);
 extern int __of_add_property(struct device_node *np, struct property *prop);

commit 249969514e23b07d1872fc614bb5cfd3577bde35
Author: Frank Rowand <frank.rowand@sony.com>
Date:   Wed Jun 21 12:16:38 2017 -0700

    of: make __of_attach_node() static
    
    __of_attach_node() is not used outside of drivers/of/dynamic.c.  Make
    it static and remove it from drivers/of/of_private.h.
    
    Signed-off-by: Frank Rowand <frank.rowand@sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index 4ebb0149d118..dd535365b5d2 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -90,7 +90,6 @@ extern int __of_update_property(struct device_node *np,
 extern void __of_update_property_sysfs(struct device_node *np,
 		struct property *newprop, struct property *oldprop);
 
-extern void __of_attach_node(struct device_node *np);
 extern int __of_attach_node_sysfs(struct device_node *np);
 extern void __of_detach_node(struct device_node *np);
 extern void __of_detach_node_sysfs(struct device_node *np);

commit 5d4dd65b1e98ff640c3bdb546a169e397805831e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Apr 28 11:44:12 2017 +0200

    of: fix unittest build without CONFIG_OF_OVERLAY
    
    We get a link error when the new tests are used by overlays
    are not:
    
    drivers/of/built-in.o: In function `unflatten_device_tree':
    (.init.text+0x967): undefined reference to `unittest_unflatten_overlay_base'
    
    This makes the #ifdef check match the symbols that lead to building
    the unittest_unflatten_overlay_base function.
    
    Fixes: 81d0848fc8d2 ("of: Add unit tests for applying overlays")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Frank Rowand <frank.rowand@sony.com>
    Tested-by: Frank Rowand <frank.rowand@sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index de5c604f5cc4..4ebb0149d118 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -55,7 +55,7 @@ static inline int of_property_notify(int action, struct device_node *np,
 }
 #endif /* CONFIG_OF_DYNAMIC */
 
-#ifdef CONFIG_OF_UNITTEST
+#if defined(CONFIG_OF_UNITTEST) && defined(CONFIG_OF_OVERLAY)
 extern void __init unittest_unflatten_overlay_base(void);
 #else
 static inline void unittest_unflatten_overlay_base(void) {};

commit 81d0848fc8d2058c4cc645d971435c889869433b
Author: Frank Rowand <frank.rowand@sony.com>
Date:   Tue Apr 25 17:09:54 2017 -0700

    of: Add unit tests for applying overlays
    
    Existing overlay unit tests examine individual pieces of the overlay
    code.  The new tests target the entire process of applying an overlay.
    
    Signed-off-by: Frank Rowand <frank.rowand@sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index 18bbb4517e25..de5c604f5cc4 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -55,6 +55,18 @@ static inline int of_property_notify(int action, struct device_node *np,
 }
 #endif /* CONFIG_OF_DYNAMIC */
 
+#ifdef CONFIG_OF_UNITTEST
+extern void __init unittest_unflatten_overlay_base(void);
+#else
+static inline void unittest_unflatten_overlay_base(void) {};
+#endif
+
+extern void *__unflatten_device_tree(const void *blob,
+			      struct device_node *dad,
+			      struct device_node **mynodes,
+			      void *(*dt_alloc)(u64 size, u64 align),
+			      bool detached);
+
 /**
  * General utilities for working with live trees.
  *

commit d9fc880723321dbf16b2981e3f3e916b73942210
Author: Frank Rowand <frank.rowand@am.sony.com>
Date:   Thu Jun 16 10:51:46 2016 -0700

    of: fix memory leak related to safe_name()
    
    Fix a memory leak resulting from memory allocation in safe_name().
    This patch fixes all call sites of safe_name().
    
    Mathieu Malaterre reported the memory leak on boot:
    
    On my PowerMac device-tree would generate a duplicate name:
    
    [    0.023043] device-tree: Duplicate name in PowerPC,G4@0, renamed to "l2-cache#1"
    
    in this case a newly allocated name is generated by `safe_name`. However
    in this case it is never deallocated.
    
    The bug was found using kmemleak reported as:
    
    unreferenced object 0xdf532e60 (size 32):
      comm "swapper", pid 1, jiffies 4294892300 (age 1993.532s)
      hex dump (first 32 bytes):
        6c 32 2d 63 61 63 68 65 23 31 00 dd e4 dd 1e c2  l2-cache#1......
        ec d4 ba ce 04 ec cc de 8e 85 e9 ca c4 ec cc 9e  ................
      backtrace:
        [<c02d3350>] kvasprintf+0x64/0xc8
        [<c02d3400>] kasprintf+0x4c/0x5c
        [<c0453814>] safe_name.isra.1+0x80/0xc4
        [<c04545d8>] __of_attach_node_sysfs+0x6c/0x11c
        [<c075f21c>] of_core_init+0x8c/0xf8
        [<c0729594>] kernel_init_freeable+0xd4/0x208
        [<c00047e8>] kernel_init+0x24/0x11c
        [<c00158ec>] ret_from_kernel_thread+0x5c/0x64
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=120331
    
    Signed-off-by: Frank Rowand <frank.rowand@am.sony.com>
    Reported-by: mathieu.malaterre@gmail.com
    Tested-by: Mathieu Malaterre <mathieu.malaterre@gmail.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index 829469faeb23..18bbb4517e25 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -83,6 +83,9 @@ extern int __of_attach_node_sysfs(struct device_node *np);
 extern void __of_detach_node(struct device_node *np);
 extern void __of_detach_node_sysfs(struct device_node *np);
 
+extern void __of_sysfs_remove_bin_file(struct device_node *np,
+				       struct property *prop);
+
 /* iterators for transactions, used for overlays */
 /* forward iterator */
 #define for_each_transaction_entry(_oft, _te) \

commit 183223770ae8625df8966ed15811d1b3ee8720aa
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Thu Nov 5 00:12:49 2015 +1100

    drivers/of: Export OF changeset functions
    
    The PowerNV PCI hotplug driver is going to use the OF changeset
    to manage the changed device sub-tree. This exports those OF
    changeset functions for that.
    
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Acked-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Tested-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index 8e882e706cd8..829469faeb23 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -45,6 +45,8 @@ static inline struct device_node *kobj_to_device_node(struct kobject *kobj)
 extern int of_property_notify(int action, struct device_node *np,
 			      struct property *prop, struct property *old_prop);
 extern void of_node_release(struct kobject *kobj);
+extern int __of_changeset_apply(struct of_changeset *ocs);
+extern int __of_changeset_revert(struct of_changeset *ocs);
 #else /* CONFIG_OF_DYNAMIC */
 static inline int of_property_notify(int action, struct device_node *np,
 				     struct property *prop, struct property *old_prop)

commit e51795815ef1a7adc018cbaf05aac46e3d24eda8
Author: Grant Likely <grant.likely@linaro.org>
Date:   Mon Nov 17 22:31:32 2014 +0000

    of: Refactor __of_node_alloc() into __of_node_dup()
    
    Add a node argument to __of_node_alloc() and rename it to
    __of_node_dup() so that it can also be used to duplicate a node with
    its properties. This is important for the overlay code so that it can
    create new nodes without using separate changeset items for every single
    property.
    
    At the same time rework the overlay code to use the new function and
    drop the extra changeset items.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index 618abcad307e..8e882e706cd8 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -61,7 +61,7 @@ static inline int of_property_notify(int action, struct device_node *np,
  * own the devtree lock or work on detached trees only.
  */
 struct property *__of_prop_dup(const struct property *prop, gfp_t allocflags);
-__printf(1, 2) struct device_node *__of_node_alloc(const char *fmt, ...);
+__printf(2, 3) struct device_node *__of_node_dup(const struct device_node *np, const char *fmt, ...);
 
 extern const void *__of_get_property(const struct device_node *np,
 				     const char *name, int *lenp);

commit ef8bbd73a76197cf8362a2b43aaadc5717bd0746
Author: Grant Likely <grant.likely@linaro.org>
Date:   Fri Nov 14 15:33:07 2014 +0000

    of: Use vargs in __of_node_alloc
    
    The overlay code needs to construct a new full_name from the parent name
    and the node name, but the current method has to allocate and then free
    an temporary string which is wasteful. Fix this problem by using vargs
    to pass in a format and arguments into __of_node_alloc().
    
    At the same time remove the allocflags argument to __of_node_alloc().
    The only users all use GFP_KERNEL, so there is no need to provide it as
    an option. If there is ever a need later it can be added back.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index 858e0a5d9a11..618abcad307e 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -61,7 +61,7 @@ static inline int of_property_notify(int action, struct device_node *np,
  * own the devtree lock or work on detached trees only.
  */
 struct property *__of_prop_dup(const struct property *prop, gfp_t allocflags);
-struct device_node *__of_node_alloc(const char *full_name, gfp_t allocflags);
+__printf(1, 2) struct device_node *__of_node_alloc(const char *fmt, ...);
 
 extern const void *__of_get_property(const struct device_node *np,
 				     const char *name, int *lenp);

commit 201c910bd6898d81d4ac6685d0f421b7e10f3c5d
Author: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
Date:   Fri Jul 4 19:58:49 2014 +0300

    of: Transactional DT support.
    
    Introducing DT transactional support.
    
    A DT transaction is a method which allows one to apply changes
    in the live tree, in such a way that either the full set of changes
    take effect, or the state of the tree can be rolled-back to the
    state it was before it was attempted. An applied transaction
    can be rolled-back at any time.
    
    Documentation is in
            Documentation/devicetree/changesets.txt
    
    Signed-off-by: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    [glikely: Removed device notifiers and reworked to be more consistent]
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index f69ccb1fa308..858e0a5d9a11 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -81,4 +81,13 @@ extern int __of_attach_node_sysfs(struct device_node *np);
 extern void __of_detach_node(struct device_node *np);
 extern void __of_detach_node_sysfs(struct device_node *np);
 
+/* iterators for transactions, used for overlays */
+/* forward iterator */
+#define for_each_transaction_entry(_oft, _te) \
+	list_for_each_entry(_te, &(_oft)->te_list, node)
+
+/* reverse iterator */
+#define for_each_transaction_entry_reverse(_oft, _te) \
+	list_for_each_entry_reverse(_te, &(_oft)->te_list, node)
+
 #endif /* _LINUX_OF_PRIVATE_H */

commit 259092a35c7e11f1d4616b0f5b3ba7b851fe4fa6
Author: Grant Likely <grant.likely@linaro.org>
Date:   Wed Jul 16 12:48:23 2014 -0600

    of: Reorder device tree changes and notifiers
    
    Currently, devicetree reconfig notifiers get emitted before the change
    is applied to the tree, but that behaviour is problematic if the
    receiver wants the determine the new state of the tree. The current
    users don't care, but the changeset code to follow will be making
    multiple changes at once. Reorder notifiers to get emitted after the
    change has been applied to the tree so that callbacks see the new tree
    state.
    
    At the same time, fixup the existing callbacks to expect the new order.
    There are a few callbacks that compare the old and new values of a
    changed property. Put both property pointers into the of_prop_reconfig
    structure.
    
    The current notifiers also allow the notifier callback to fail and
    cancel the change to the tree, but that feature isn't actually used.
    It really isn't valid to ignore a tree modification provided by firmware
    anyway, so remove the ability to cancel a change to the tree.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Cc: Nathan Fontenot <nfont@austin.ibm.com>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index 8129c0e58d70..f69ccb1fa308 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -43,11 +43,11 @@ static inline struct device_node *kobj_to_device_node(struct kobject *kobj)
 
 #if defined(CONFIG_OF_DYNAMIC)
 extern int of_property_notify(int action, struct device_node *np,
-			      struct property *prop);
+			      struct property *prop, struct property *old_prop);
 extern void of_node_release(struct kobject *kobj);
 #else /* CONFIG_OF_DYNAMIC */
 static inline int of_property_notify(int action, struct device_node *np,
-				     struct property *prop)
+				     struct property *prop, struct property *old_prop)
 {
 	return 0;
 }

commit a25095d451ece23b1fef34474f3230100db7aa05
Author: Grant Likely <grant.likely@linaro.org>
Date:   Tue Jul 15 23:25:43 2014 -0600

    of: Move dynamic node fixups out of powerpc and into common code
    
    PowerPC does an odd thing with dynamic nodes. It uses a notifier to
    catch new node additions and set some of the values like name and type.
    This makes no sense since that same code can be put directly into
    of_attach_node(). Besides, all dynamic node users need this, not just
    powerpc. Fix this problem by moving the logic out of arch/powerpc and
    into drivers/of/dynamic.c.
    
    It is also important to remove this notifier because we want to move the
    firing of notifiers from before the tree is modified to after so that
    the receiver gets a consistent view of the tree, but that is
    incompatible with notifiers that modify the node.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Cc: Nathan Fontenot <nfont@austin.ibm.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index 0d99ba8caeed..8129c0e58d70 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -63,6 +63,8 @@ static inline int of_property_notify(int action, struct device_node *np,
 struct property *__of_prop_dup(const struct property *prop, gfp_t allocflags);
 struct device_node *__of_node_alloc(const char *full_name, gfp_t allocflags);
 
+extern const void *__of_get_property(const struct device_node *np,
+				     const char *name, int *lenp);
 extern int __of_add_property(struct device_node *np, struct property *prop);
 extern int __of_add_property_sysfs(struct device_node *np,
 		struct property *prop);

commit 8a2b22a2595bf89d4396530edf8388159fad9d83
Author: Grant Likely <grant.likely@linaro.org>
Date:   Wed Jul 23 17:05:06 2014 -0600

    of: Make devicetree sysfs update functions consistent.
    
    All of the DT modification functions are split into two parts, the first
    part manipulates the DT data structure, and the second part updates
    sysfs, but the code isn't very consistent about how the second half is
    called. They don't all enforce the same rules about when it is valid to
    update sysfs, and there isn't any clarity on locking.
    
    The transactional DT modification feature that is coming also needs
    access to these functions so that it can perform all the structure
    changes together, and then all the sysfs updates as a second stage
    instead of doing each one at a time.
    
    Fix up the second have by creating a separate __of_*_sysfs() function
    for each of the helpers. The new functions have consistent naming (ie.
    of_node_add() becomes __of_attach_node_sysfs()) and all of them now
    defer if of_init hasn't been called yet.
    
    Callers of the new functions must hold the of_mutex to ensure there are
    no race conditions with of_init(). The mutex ensures that there will
    only ever be one writer to the tree at any given time. There can still
    be any number of readers and the raw_spin_lock is still used to make
    sure access to the data structure is still consistent.
    
    Finally, put the function prototypes into of_private.h so they are
    accessible to the transaction code.
    
    Signed-off-by: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    [grant.likely: Changed suffix from _post to _sysfs to match existing code]
    [grant.likely: Reorganized to eliminate trivial wrappers]
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index 0f6089722af9..0d99ba8caeed 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -33,6 +33,8 @@ struct alias_prop {
 
 extern struct mutex of_mutex;
 extern struct list_head aliases_lookup;
+extern struct kset *of_kset;
+
 
 static inline struct device_node *kobj_to_device_node(struct kobject *kobj)
 {
@@ -62,11 +64,19 @@ struct property *__of_prop_dup(const struct property *prop, gfp_t allocflags);
 struct device_node *__of_node_alloc(const char *full_name, gfp_t allocflags);
 
 extern int __of_add_property(struct device_node *np, struct property *prop);
+extern int __of_add_property_sysfs(struct device_node *np,
+		struct property *prop);
 extern int __of_remove_property(struct device_node *np, struct property *prop);
+extern void __of_remove_property_sysfs(struct device_node *np,
+		struct property *prop);
 extern int __of_update_property(struct device_node *np,
 		struct property *newprop, struct property **oldprop);
+extern void __of_update_property_sysfs(struct device_node *np,
+		struct property *newprop, struct property *oldprop);
 
 extern void __of_attach_node(struct device_node *np);
+extern int __of_attach_node_sysfs(struct device_node *np);
 extern void __of_detach_node(struct device_node *np);
+extern void __of_detach_node_sysfs(struct device_node *np);
 
 #endif /* _LINUX_OF_PRIVATE_H */

commit d8c50088417ebf61ad8b132caad20d10f7736034
Author: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
Date:   Fri Jul 4 19:58:46 2014 +0300

    of: Create unlocked versions of node and property add/remove functions
    
    The DT overlay code will need to manipulate nodes and properties while
    already holding the devicetree lock, or on nodes that are not yet
    attached to the tree, but the current helper functions don't allow that.
    Extract the core behaviour from the accessors and create the following
    unlocked variants.
    
    The unlocked variants require either the lock to already be held or for
    the nodes to be detached from the tree. Changes to live nodes will not
    get updated in sysfs, so the caller must arrange for housekeeping to
    take place after dropping the lock.
    
    The new functions are: __of_add_property(), __of_remove_property(),
    __of_update_property(), __of_attach_node() and __of_detach_node().
    
    Signed-off-by: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    [Remove unnecessary diff hunks and rewrite commit text]
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index 1799ed2b3808..0f6089722af9 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -61,4 +61,12 @@ static inline int of_property_notify(int action, struct device_node *np,
 struct property *__of_prop_dup(const struct property *prop, gfp_t allocflags);
 struct device_node *__of_node_alloc(const char *full_name, gfp_t allocflags);
 
+extern int __of_add_property(struct device_node *np, struct property *prop);
+extern int __of_remove_property(struct device_node *np, struct property *prop);
+extern int __of_update_property(struct device_node *np,
+		struct property *newprop, struct property **oldprop);
+
+extern void __of_attach_node(struct device_node *np);
+extern void __of_detach_node(struct device_node *np);
+
 #endif /* _LINUX_OF_PRIVATE_H */

commit 698433963b98d6de7b102c242805c99fda4fa1fb
Author: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
Date:   Fri Jul 4 19:58:47 2014 +0300

    OF: Utility helper functions for dynamic nodes
    
    Introduce helper functions for working with the live DT tree,
    all of them related to dynamically adding/removing nodes and
    properties.
    
    __of_prop_dup() copies a property dynamically
    __of_node_alloc() creates an empty node
    
    Bug fix about prop->len == 0 by Ionut Nicu <ioan.nicu.ext@nsn.com>
    
    Signed-off-by: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    [glikely: Added unittest for of_copy_property and dropped fine-grained allocations]
    [glikely: removed name, type and phandle arguments from __of_node_alloc]
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index c270f2037779..1799ed2b3808 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -51,4 +51,14 @@ static inline int of_property_notify(int action, struct device_node *np,
 }
 #endif /* CONFIG_OF_DYNAMIC */
 
+/**
+ * General utilities for working with live trees.
+ *
+ * All functions with two leading underscores operate
+ * without taking node references, so you either have to
+ * own the devtree lock or work on detached trees only.
+ */
+struct property *__of_prop_dup(const struct property *prop, gfp_t allocflags);
+struct device_node *__of_node_alloc(const char *full_name, gfp_t allocflags);
+
 #endif /* _LINUX_OF_PRIVATE_H */

commit 6afc0dc381573559251de9a8259404f49e6aed14
Author: Grant Likely <grant.likely@linaro.org>
Date:   Thu Jun 26 15:40:48 2014 +0100

    of: Move CONFIG_OF_DYNAMIC code into a separate file
    
    Split the dynamic device tree code into a separate file to make it
    really clear what features CONFIF_OF_DYNAMIC add to the kernel. Without
    CONFIG_OF_DYNAMIC only properties can be changed, and notifiers do not
    get sent. Enabling it turns on reference counting, notifiers and the
    ability to add and remove nodes.
    
    v2: Moved of_node_release() into dynamic.c
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    Cc: Rob Herring <robh+dt@kernel.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index fcc70e74dfe0..c270f2037779 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -33,4 +33,22 @@ struct alias_prop {
 
 extern struct mutex of_mutex;
 extern struct list_head aliases_lookup;
+
+static inline struct device_node *kobj_to_device_node(struct kobject *kobj)
+{
+	return container_of(kobj, struct device_node, kobj);
+}
+
+#if defined(CONFIG_OF_DYNAMIC)
+extern int of_property_notify(int action, struct device_node *np,
+			      struct property *prop);
+extern void of_node_release(struct kobject *kobj);
+#else /* CONFIG_OF_DYNAMIC */
+static inline int of_property_notify(int action, struct device_node *np,
+				     struct property *prop)
+{
+	return 0;
+}
+#endif /* CONFIG_OF_DYNAMIC */
+
 #endif /* _LINUX_OF_PRIVATE_H */

commit c05aba2bd5f9dd3f363611ff844513de1341ac60
Author: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
Date:   Fri Jul 4 19:58:03 2014 +0300

    of: rename of_aliases_mutex to just of_mutex
    
    We're overloading usage of of_aliases_mutex for sysfs changes,
    so rename to something that is more generic.
    
    Signed-off-by: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index ff350c8fa7ac..fcc70e74dfe0 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -31,6 +31,6 @@ struct alias_prop {
 	char stem[0];
 };
 
-extern struct mutex of_aliases_mutex;
+extern struct mutex of_mutex;
 extern struct list_head aliases_lookup;
 #endif /* _LINUX_OF_PRIVATE_H */

commit ced4eec900850627409d7ff566b009471162b56b
Author: Stepan Moskovchenko <stepanm@codeaurora.org>
Date:   Thu Dec 6 14:55:41 2012 -0800

    of: Output devicetree alias names in uevent
    
    In some situations, userspace may want to resolve a
    device by function and logical number (ie, "serial0")
    rather than by the base address or full device path. Being
    able to resolve a device by alias frees userspace from the
    burden of otherwise having to maintain a mapping between
    device addresses and their logical assignments on each
    platform when multiple instances of the same hardware block
    are present in the system.
    
    Although the uevent device attribute contains devicetree
    compatible information and the full device path, the uevent
    does not list the alises that may have been defined for the
    device.
    
    Signed-off-by: Stepan Moskovchenko <stepanm@codeaurora.org>
    [grant.likely: Removed OF_ALIAS_N field; I don't think it's needed]
    [grant.likely: Added #ifndef _LINUX_OF_PRIVATE_H wrapper]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
new file mode 100644
index 000000000000..ff350c8fa7ac
--- /dev/null
+++ b/drivers/of/of_private.h
@@ -0,0 +1,36 @@
+#ifndef _LINUX_OF_PRIVATE_H
+#define _LINUX_OF_PRIVATE_H
+/*
+ * Private symbols used by OF support code
+ *
+ * Paul Mackerras	August 1996.
+ * Copyright (C) 1996-2005 Paul Mackerras.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+/**
+ * struct alias_prop - Alias property in 'aliases' node
+ * @link:	List node to link the structure in aliases_lookup list
+ * @alias:	Alias property name
+ * @np:		Pointer to device_node that the alias stands for
+ * @id:		Index value from end of alias name
+ * @stem:	Alias string without the index
+ *
+ * The structure represents one alias property of 'aliases' node as
+ * an entry in aliases_lookup list.
+ */
+struct alias_prop {
+	struct list_head link;
+	const char *alias;
+	struct device_node *np;
+	int id;
+	char stem[0];
+};
+
+extern struct mutex of_aliases_mutex;
+extern struct list_head aliases_lookup;
+#endif /* _LINUX_OF_PRIVATE_H */
