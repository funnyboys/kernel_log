commit 5a8d7f126c97d04d893f5e5be2b286437a0d01b0
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri Jun 19 11:47:46 2020 -0700

    of: of_mdio: Correct loop scanning logic
    
    Commit 209c65b61d94 ("drivers/of/of_mdio.c:fix of_mdiobus_register()")
    introduced a break of the loop on the premise that a successful
    registration should exit the loop. The premise is correct but not to
    code, because rc && rc != -ENODEV is just a special error condition,
    that means we would exit the loop even with rc == -ENODEV which is
    absolutely not correct since this is the error code to indicate to the
    MDIO bus layer that scanning should continue.
    
    Fix this by explicitly checking for rc = 0 as the only valid condition
    to break out of the loop.
    
    Fixes: 209c65b61d94 ("drivers/of/of_mdio.c:fix of_mdiobus_register()")
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index a04afe79529c..ef6f818ce5b3 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -314,10 +314,15 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 				 child, addr);
 
 			if (of_mdiobus_child_is_phy(child)) {
+				/* -ENODEV is the return code that PHYLIB has
+				 * standardized on to indicate that bus
+				 * scanning should continue.
+				 */
 				rc = of_mdiobus_register_phy(mdio, child, addr);
-				if (rc && rc != -ENODEV)
+				if (!rc)
+					break;
+				if (rc != -ENODEV)
 					goto unregister;
-				break;
 			}
 		}
 	}

commit 5972157c2dde11698d7bcfc55621107d97121c87
Author: Oleksij Rempel <o.rempel@pengutronix.de>
Date:   Wed Apr 22 11:24:55 2020 +0200

    net: mdio: of: export part of of_mdiobus_register_phy()
    
    This function will be needed in tja11xx driver for secondary PHY
    support.
    
    Signed-off-by: Oleksij Rempel <o.rempel@pengutronix.de>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 9f982c0627a0..a04afe79529c 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -60,39 +60,15 @@ static struct mii_timestamper *of_find_mii_timestamper(struct device_node *node)
 	return register_mii_timestamper(arg.np, arg.args[0]);
 }
 
-static int of_mdiobus_register_phy(struct mii_bus *mdio,
-				    struct device_node *child, u32 addr)
+int of_mdiobus_phy_device_register(struct mii_bus *mdio, struct phy_device *phy,
+			      struct device_node *child, u32 addr)
 {
-	struct mii_timestamper *mii_ts;
-	struct phy_device *phy;
-	bool is_c45;
 	int rc;
-	u32 phy_id;
-
-	mii_ts = of_find_mii_timestamper(child);
-	if (IS_ERR(mii_ts))
-		return PTR_ERR(mii_ts);
-
-	is_c45 = of_device_is_compatible(child,
-					 "ethernet-phy-ieee802.3-c45");
-
-	if (!is_c45 && !of_get_phy_id(child, &phy_id))
-		phy = phy_device_create(mdio, addr, phy_id, 0, NULL);
-	else
-		phy = get_phy_device(mdio, addr, is_c45);
-	if (IS_ERR(phy)) {
-		if (mii_ts)
-			unregister_mii_timestamper(mii_ts);
-		return PTR_ERR(phy);
-	}
 
 	rc = of_irq_get(child, 0);
-	if (rc == -EPROBE_DEFER) {
-		if (mii_ts)
-			unregister_mii_timestamper(mii_ts);
-		phy_device_free(phy);
+	if (rc == -EPROBE_DEFER)
 		return rc;
-	}
+
 	if (rc > 0) {
 		phy->irq = rc;
 		mdio->irq[addr] = rc;
@@ -117,11 +93,48 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio,
 	/* All data is now stored in the phy struct;
 	 * register it */
 	rc = phy_device_register(phy);
+	if (rc) {
+		of_node_put(child);
+		return rc;
+	}
+
+	dev_dbg(&mdio->dev, "registered phy %pOFn at address %i\n",
+		child, addr);
+	return 0;
+}
+EXPORT_SYMBOL(of_mdiobus_phy_device_register);
+
+static int of_mdiobus_register_phy(struct mii_bus *mdio,
+				    struct device_node *child, u32 addr)
+{
+	struct mii_timestamper *mii_ts;
+	struct phy_device *phy;
+	bool is_c45;
+	int rc;
+	u32 phy_id;
+
+	mii_ts = of_find_mii_timestamper(child);
+	if (IS_ERR(mii_ts))
+		return PTR_ERR(mii_ts);
+
+	is_c45 = of_device_is_compatible(child,
+					 "ethernet-phy-ieee802.3-c45");
+
+	if (!is_c45 && !of_get_phy_id(child, &phy_id))
+		phy = phy_device_create(mdio, addr, phy_id, 0, NULL);
+	else
+		phy = get_phy_device(mdio, addr, is_c45);
+	if (IS_ERR(phy)) {
+		if (mii_ts)
+			unregister_mii_timestamper(mii_ts);
+		return PTR_ERR(phy);
+	}
+
+	rc = of_mdiobus_phy_device_register(mdio, phy, child, addr);
 	if (rc) {
 		if (mii_ts)
 			unregister_mii_timestamper(mii_ts);
 		phy_device_free(phy);
-		of_node_put(child);
 		return rc;
 	}
 
@@ -132,8 +145,6 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio,
 	if (mii_ts)
 		phy->mii_ts = mii_ts;
 
-	dev_dbg(&mdio->dev, "registered phy %pOFn at address %i\n",
-		child, addr);
 	return 0;
 }
 

commit 209c65b61d94344522c41a83cd6ce51aac5fd0a4
Author: Dajun Jin <adajunjin@gmail.com>
Date:   Mon Mar 2 20:24:21 2020 -0800

    drivers/of/of_mdio.c:fix of_mdiobus_register()
    
    When registers a phy_device successful, should terminate the loop
    or the phy_device would be registered in other addr. If there are
    multiple PHYs without reg properties, it will go wrong.
    
    Signed-off-by: Dajun Jin <adajunjin@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 8270bbf505fb..9f982c0627a0 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -306,6 +306,7 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 				rc = of_mdiobus_register_phy(mdio, child, addr);
 				if (rc && rc != -ENODEV)
 					goto unregister;
+				break;
 			}
 		}
 	}

commit 2e1bf3a76576eebc787d8882c3f91fa4ec743efc
Author: Michael Walle <michael@walle.cc>
Date:   Thu Jan 30 18:44:51 2020 +0100

    net: mii_timestamper: fix static allocation by PHY driver
    
    If phydev->mii_ts is set by the PHY driver, it will always be
    overwritten in of_mdiobus_register_phy(). Fix it. Also make sure, that
    the unregister() doesn't do anything if the mii_timestamper was provided by
    the PHY driver.
    
    Fixes: 1dca22b18421 ("net: mdio: of: Register discovered MII time stampers.")
    Signed-off-by: Michael Walle <michael@walle.cc>
    Acked-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index db0ed5879803..8270bbf505fb 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -124,7 +124,13 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio,
 		of_node_put(child);
 		return rc;
 	}
-	phy->mii_ts = mii_ts;
+
+	/* phy->mii_ts may already be defined by the PHY driver. A
+	 * mii_timestamper probed via the device tree will still have
+	 * precedence.
+	 */
+	if (mii_ts)
+		phy->mii_ts = mii_ts;
 
 	dev_dbg(&mdio->dev, "registered phy %pOFn at address %i\n",
 		child, addr);

commit 0e0daf6ac3be70608569262246f6dc33cb3f45fe
Author: Michael Walle <michael@walle.cc>
Date:   Thu Jan 30 18:44:50 2020 +0100

    net: mdio: of: fix potential NULL pointer derefernce
    
    of_find_mii_timestamper() returns NULL if no timestamper is found.
    Therefore, guard the unregister_mii_timestamper() calls.
    
    Fixes: 1dca22b18421 ("net: mdio: of: Register discovered MII time stampers.")
    Signed-off-by: Michael Walle <michael@walle.cc>
    Acked-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index f5c2a5487761..db0ed5879803 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -81,13 +81,15 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio,
 	else
 		phy = get_phy_device(mdio, addr, is_c45);
 	if (IS_ERR(phy)) {
-		unregister_mii_timestamper(mii_ts);
+		if (mii_ts)
+			unregister_mii_timestamper(mii_ts);
 		return PTR_ERR(phy);
 	}
 
 	rc = of_irq_get(child, 0);
 	if (rc == -EPROBE_DEFER) {
-		unregister_mii_timestamper(mii_ts);
+		if (mii_ts)
+			unregister_mii_timestamper(mii_ts);
 		phy_device_free(phy);
 		return rc;
 	}
@@ -116,7 +118,8 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio,
 	 * register it */
 	rc = phy_device_register(phy);
 	if (rc) {
-		unregister_mii_timestamper(mii_ts);
+		if (mii_ts)
+			unregister_mii_timestamper(mii_ts);
 		phy_device_free(phy);
 		of_node_put(child);
 		return rc;

commit 1dca22b1842136f57e9bd60fefd1715c22ff1874
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Wed Dec 25 18:16:18 2019 -0800

    net: mdio: of: Register discovered MII time stampers.
    
    When parsing a PHY node, register its time stamper, if any, and attach
    the instance to the PHY device.
    
    Signed-off-by: Richard Cochran <richardcochran@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index fc757ef6eadc..f5c2a5487761 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -42,14 +42,37 @@ static int of_get_phy_id(struct device_node *device, u32 *phy_id)
 	return -EINVAL;
 }
 
+static struct mii_timestamper *of_find_mii_timestamper(struct device_node *node)
+{
+	struct of_phandle_args arg;
+	int err;
+
+	err = of_parse_phandle_with_fixed_args(node, "timestamper", 1, 0, &arg);
+
+	if (err == -ENOENT)
+		return NULL;
+	else if (err)
+		return ERR_PTR(err);
+
+	if (arg.args_count != 1)
+		return ERR_PTR(-EINVAL);
+
+	return register_mii_timestamper(arg.np, arg.args[0]);
+}
+
 static int of_mdiobus_register_phy(struct mii_bus *mdio,
 				    struct device_node *child, u32 addr)
 {
+	struct mii_timestamper *mii_ts;
 	struct phy_device *phy;
 	bool is_c45;
 	int rc;
 	u32 phy_id;
 
+	mii_ts = of_find_mii_timestamper(child);
+	if (IS_ERR(mii_ts))
+		return PTR_ERR(mii_ts);
+
 	is_c45 = of_device_is_compatible(child,
 					 "ethernet-phy-ieee802.3-c45");
 
@@ -57,11 +80,14 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio,
 		phy = phy_device_create(mdio, addr, phy_id, 0, NULL);
 	else
 		phy = get_phy_device(mdio, addr, is_c45);
-	if (IS_ERR(phy))
+	if (IS_ERR(phy)) {
+		unregister_mii_timestamper(mii_ts);
 		return PTR_ERR(phy);
+	}
 
 	rc = of_irq_get(child, 0);
 	if (rc == -EPROBE_DEFER) {
+		unregister_mii_timestamper(mii_ts);
 		phy_device_free(phy);
 		return rc;
 	}
@@ -90,10 +116,12 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio,
 	 * register it */
 	rc = phy_device_register(phy);
 	if (rc) {
+		unregister_mii_timestamper(mii_ts);
 		phy_device_free(phy);
 		of_node_put(child);
 		return rc;
 	}
+	phy->mii_ts = mii_ts;
 
 	dev_dbg(&mdio->dev, "registered phy %pOFn at address %i\n",
 		child, addr);

commit 0aa4d016c043d16a282e7e93edf6213a7b954c90
Author: Antoine Tenart <antoine.tenart@bootlin.com>
Date:   Tue Dec 17 18:07:41 2019 +0100

    of: mdio: export of_mdiobus_child_is_phy
    
    This patch exports of_mdiobus_child_is_phy, allowing to check if a child
    node is a network PHY.
    
    Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index c6b87ce2b0cc..fc757ef6eadc 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -162,7 +162,7 @@ static const struct of_device_id whitelist_phys[] = {
  * A device which is not a phy is expected to have a compatible string
  * indicating what sort of device it is.
  */
-static bool of_mdiobus_child_is_phy(struct device_node *child)
+bool of_mdiobus_child_is_phy(struct device_node *child)
 {
 	u32 phy_id;
 
@@ -187,6 +187,7 @@ static bool of_mdiobus_child_is_phy(struct device_node *child)
 
 	return false;
 }
+EXPORT_SYMBOL(of_mdiobus_child_is_phy);
 
 /**
  * of_mdiobus_register - Register mii_bus and create PHYs from the device tree

commit 0c65b2b90d13c1deaee6449304dd367c5d4eb8ae
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Mon Nov 4 02:40:33 2019 +0100

    net: of_get_phy_mode: Change API to solve int/unit warnings
    
    Before this change of_get_phy_mode() returned an enum,
    phy_interface_t. On error, -ENODEV etc, is returned. If the result of
    the function is stored in a variable of type phy_interface_t, and the
    compiler has decided to represent this as an unsigned int, comparision
    with -ENODEV etc, is a signed vs unsigned comparision.
    
    Fix this problem by changing the API. Make the function return an
    error, or 0 on success, and pass a pointer, of type phy_interface_t,
    where the phy mode should be stored.
    
    v2:
    Return with *interface set to PHY_INTERFACE_MODE_NA on error.
    Add error checks to all users of of_get_phy_mode()
    Fixup a few reverse christmas tree errors
    Fixup a few slightly malformed reverse christmas trees
    
    v3:
    Fix 0-day reported errors.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index bd6129db6417..c6b87ce2b0cc 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -361,8 +361,8 @@ struct phy_device *of_phy_get_and_connect(struct net_device *dev,
 	struct phy_device *phy;
 	int ret;
 
-	iface = of_get_phy_mode(np);
-	if ((int)iface < 0)
+	ret = of_get_phy_mode(np, &iface);
+	if (ret)
 		return NULL;
 	if (of_phy_is_fixed_link(np)) {
 		ret = of_phy_register_fixed_link(np);

commit d7eb651212fdbafa82d485d8e76095ac3b14c193
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Sep 25 14:01:00 2019 +0300

    of: mdio: Fix a signedness bug in of_phy_get_and_connect()
    
    The "iface" variable is an enum and in this context GCC treats it as
    an unsigned int so the error handling is never triggered.
    
    Fixes: b78624125304 ("of_mdio: Abstract a general interface for phy connect")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 000b95787df1..bd6129db6417 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -362,7 +362,7 @@ struct phy_device *of_phy_get_and_connect(struct net_device *dev,
 	int ret;
 
 	iface = of_get_phy_mode(np);
-	if (iface < 0)
+	if ((int)iface < 0)
 		return NULL;
 	if (of_phy_is_fixed_link(np)) {
 		ret = of_phy_register_fixed_link(np);

commit cfba5de9b99f8bbb8b4ea11b3049784e78b8759b
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Tue Jul 23 23:18:33 2019 +0100

    drivers: Introduce device lookup variants by of_node
    
    Introduce wrappers for {bus/driver/class}_find_device() to
    locate devices by its of_node.
    
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Maxime Ripard <maxime.ripard@bootlin.com>
    Cc: dri-devel@lists.freedesktop.org
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: devicetree@vger.kernel.org
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Heiko Stuebner <heiko@sntech.de>
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: linux-i2c@vger.kernel.org
    Cc: linux-rockchip@lists.infradead.org
    Cc: linux-spi@vger.kernel.org
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Cc: Takashi Iwai <tiwai@suse.com>
    Cc: Alan Tull <atull@kernel.org>
    Cc: linux-fpga@vger.kernel.org
    Cc: Peter Rosin <peda@axentia.se>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Heiner Kallweit <hkallweit1@gmail.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: Thor Thayer <thor.thayer@linux.intel.com>
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Peter Rosin <peda@axentia.se>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Acked-by: Wolfram Sang <wsa@the-dreams.de> # I2C part
    Acked-by: Moritz Fischer <mdf@kernel.org> # For FPGA part
    Acked-by: Mark Brown <broonie@kernel.org>
    Link: https://lore.kernel.org/r/20190723221838.12024-3-suzuki.poulose@arm.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 44f53496cab1..000b95787df1 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -280,12 +280,6 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 }
 EXPORT_SYMBOL(of_mdiobus_register);
 
-/* Helper function for of_phy_find_device */
-static int of_phy_match(struct device *dev, const void *phy_np)
-{
-	return dev->of_node == phy_np;
-}
-
 /**
  * of_phy_find_device - Give a PHY node, find the phy_device
  * @phy_np: Pointer to the phy's device tree node
@@ -301,7 +295,7 @@ struct phy_device *of_phy_find_device(struct device_node *phy_np)
 	if (!phy_np)
 		return NULL;
 
-	d = bus_find_device(&mdio_bus_type, NULL, phy_np, of_phy_match);
+	d = bus_find_device_by_of_node(&mdio_bus_type, phy_np);
 	if (d) {
 		mdiodev = to_mdio_device(d);
 		if (mdiodev->flags & MDIO_DEVICE_FLAG_PHY)

commit f632a8170a6b667ee4e3f552087588f0fe13c4bb
Merge: ef8f3d48afd6 c33d442328f5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 12 12:24:03 2019 -0700

    Merge tag 'driver-core-5.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core and debugfs updates from Greg KH:
     "Here is the "big" driver core and debugfs changes for 5.3-rc1
    
      It's a lot of different patches, all across the tree due to some api
      changes and lots of debugfs cleanups.
    
      Other than the debugfs cleanups, in this set of changes we have:
    
       - bus iteration function cleanups
    
       - scripts/get_abi.pl tool to display and parse Documentation/ABI
         entries in a simple way
    
       - cleanups to Documenatation/ABI/ entries to make them parse easier
         due to typos and other minor things
    
       - default_attrs use for some ktype users
    
       - driver model documentation file conversions to .rst
    
       - compressed firmware file loading
    
       - deferred probe fixes
    
      All of these have been in linux-next for a while, with a bunch of
      merge issues that Stephen has been patient with me for"
    
    * tag 'driver-core-5.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (102 commits)
      debugfs: make error message a bit more verbose
      orangefs: fix build warning from debugfs cleanup patch
      ubifs: fix build warning after debugfs cleanup patch
      driver: core: Allow subsystems to continue deferring probe
      drivers: base: cacheinfo: Ensure cpu hotplug work is done before Intel RDT
      arch_topology: Remove error messages on out-of-memory conditions
      lib: notifier-error-inject: no need to check return value of debugfs_create functions
      swiotlb: no need to check return value of debugfs_create functions
      ceph: no need to check return value of debugfs_create functions
      sunrpc: no need to check return value of debugfs_create functions
      ubifs: no need to check return value of debugfs_create functions
      orangefs: no need to check return value of debugfs_create functions
      nfsd: no need to check return value of debugfs_create functions
      lib: 842: no need to check return value of debugfs_create functions
      debugfs: provide pr_fmt() macro
      debugfs: log errors when something goes wrong
      drivers: s390/cio: Fix compilation warning about const qualifiers
      drivers: Add generic helper to match by of_node
      driver_find_device: Unify the match function with class_find_device()
      bus_find_device: Unify the match callback with class_find_device
      ...

commit 418e3ea157efb0eb2c6dd412a8d5f052477c7f5a
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Fri Jun 14 18:53:59 2019 +0100

    bus_find_device: Unify the match callback with class_find_device
    
    There is an arbitrary difference between the prototypes of
    bus_find_device() and class_find_device() preventing their callers
    from passing the same pair of data and match() arguments to both of
    them, which is the const qualifier used in the prototype of
    class_find_device().  If that qualifier is also used in the
    bus_find_device() prototype, it will be possible to pass the same
    match() callback function to both bus_find_device() and
    class_find_device(), which will allow some optimizations to be made in
    order to avoid code duplication going forward.  Also with that, constify
    the "data" parameter as it is passed as a const to the match function.
    
    For this reason, change the prototype of bus_find_device() to match
    the prototype of class_find_device() and adjust its callers to use the
    const qualifier in accordance with the new prototype of it.
    
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Andreas Noever <andreas.noever@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Corey Minyard <minyard@acm.org>
    Cc: Christian Borntraeger <borntraeger@de.ibm.com>
    Cc: David Kershner <david.kershner@unisys.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Felipe Balbi <balbi@kernel.org>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: Harald Freudenberger <freude@linux.ibm.com>
    Cc: Hartmut Knaack <knaack.h@gmx.de>
    Cc: Heiko Stuebner <heiko@sntech.de>
    Cc: Jason Gunthorpe <jgg@ziepe.ca>
    Cc: Jonathan Cameron <jic23@kernel.org>
    Cc: "James E.J. Bottomley" <jejb@linux.ibm.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michael Jamet <michael.jamet@intel.com>
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    Cc: Peter Oberparleiter <oberpar@linux.ibm.com>
    Cc: Sebastian Ott <sebott@linux.ibm.com>
    Cc: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Cc: Yehezkel Bernat <YehezkelShB@gmail.com>
    Cc: rafael@kernel.org
    Acked-by: Corey Minyard <minyard@acm.org>
    Acked-by: David Kershner <david.kershner@unisys.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Acked-by: Wolfram Sang <wsa@the-dreams.de> # for the I2C parts
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index de6157357e26..dfe12948c834 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -282,7 +282,7 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 EXPORT_SYMBOL(of_mdiobus_register);
 
 /* Helper function for of_phy_find_device */
-static int of_phy_match(struct device *dev, void *phy_np)
+static int of_phy_match(struct device *dev, const void *phy_np)
 {
 	return dev->of_node == phy_np;
 }

commit 55716d26439f5c4008b0bcb7f17d1f7c0d8fbcfc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:42 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 428
    
    Based on 1 normalized pattern(s):
    
      this file is released under the gplv2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 68 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190114.292346262@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index de6157357e26..3b67896d9d74 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -1,10 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * OF helpers for the MDIO (Ethernet PHY) API
  *
  * Copyright (c) 2009 Secret Lab Technologies, Ltd.
  *
- * This file is released under the GPLv2
- *
  * This file provides helper functions for extracting PHY device information
  * out of the OpenFirmware device tree and using it to populate an mii_bus.
  */

commit 5468e82f7034f0ae175a3ce075441356099bdaa3
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Feb 4 11:26:18 2019 +0100

    net: phy: fixed-phy: Drop GPIO from fixed_phy_add()
    
    All users of the fixed_phy_add() pass -1 as GPIO number
    to the fixed phy driver, and all users of fixed_phy_register()
    pass -1 as GPIO number as well, except for the device
    tree MDIO bus.
    
    Any new users should create a proper device and pass the
    GPIO as a descriptor associated with the device so delete
    the GPIO argument from the calls and drop the code looking
    requesting a GPIO in fixed_phy_add().
    
    In fixed phy_register(), investigate the "fixed-link"
    node and pick the GPIO descriptor from "link-gpios" if
    this property exists. Move the corresponding code out
    of of_mdio.c as the fixed phy code anyways requires
    OF to be in use.
    
    Tested-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 5ad1342f5682..de6157357e26 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -16,7 +16,6 @@
 #include <linux/phy.h>
 #include <linux/phy_fixed.h>
 #include <linux/of.h>
-#include <linux/of_gpio.h>
 #include <linux/of_irq.h>
 #include <linux/of_mdio.h>
 #include <linux/of_net.h>
@@ -463,7 +462,6 @@ int of_phy_register_fixed_link(struct device_node *np)
 	struct device_node *fixed_link_node;
 	u32 fixed_link_prop[5];
 	const char *managed;
-	int link_gpio = -1;
 
 	if (of_property_read_string(np, "managed", &managed) == 0 &&
 	    strcmp(managed, "in-band-status") == 0) {
@@ -485,11 +483,7 @@ int of_phy_register_fixed_link(struct device_node *np)
 		status.pause = of_property_read_bool(fixed_link_node, "pause");
 		status.asym_pause = of_property_read_bool(fixed_link_node,
 							  "asym-pause");
-		link_gpio = of_get_named_gpio_flags(fixed_link_node,
-						    "link-gpios", 0, NULL);
 		of_node_put(fixed_link_node);
-		if (link_gpio == -EPROBE_DEFER)
-			return -EPROBE_DEFER;
 
 		goto register_phy;
 	}
@@ -508,8 +502,7 @@ int of_phy_register_fixed_link(struct device_node *np)
 	return -ENODEV;
 
 register_phy:
-	return PTR_ERR_OR_ZERO(fixed_phy_register(PHY_POLL, &status, link_gpio,
-						  np));
+	return PTR_ERR_OR_ZERO(fixed_phy_register(PHY_POLL, &status, np));
 }
 EXPORT_SYMBOL(of_phy_register_fixed_link);
 

commit a613b26a50136ae90ab13943afe90bcbd34adb44
Author: Rob Herring <robh@kernel.org>
Date:   Mon Aug 27 20:00:19 2018 -0500

    of: Convert to using %pOFn instead of device_node.name
    
    In preparation to remove the node name pointer from struct device_node,
    convert printf users to use the %pOFn format specifier.
    
    Reviewed-by: Frank Rowand <frank.rowand@sony.com>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: netdev@vger.kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index e92391d6d1bd..5ad1342f5682 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -97,8 +97,8 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio,
 		return rc;
 	}
 
-	dev_dbg(&mdio->dev, "registered phy %s at address %i\n",
-		child->name, addr);
+	dev_dbg(&mdio->dev, "registered phy %pOFn at address %i\n",
+		child, addr);
 	return 0;
 }
 
@@ -127,8 +127,8 @@ static int of_mdiobus_register_device(struct mii_bus *mdio,
 		return rc;
 	}
 
-	dev_dbg(&mdio->dev, "registered mdio device %s at address %i\n",
-		child->name, addr);
+	dev_dbg(&mdio->dev, "registered mdio device %pOFn at address %i\n",
+		child, addr);
 	return 0;
 }
 
@@ -263,8 +263,8 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 				continue;
 
 			/* be noisy to encourage people to set reg property */
-			dev_info(&mdio->dev, "scan phy %s at address %i\n",
-				 child->name, addr);
+			dev_info(&mdio->dev, "scan phy %pOFn at address %i\n",
+				 child, addr);
 
 			if (of_mdiobus_child_is_phy(child)) {
 				rc = of_mdiobus_register_phy(mdio, child, addr);

commit 6eb9c9dafd02b6a0236074e3ee7acee9e2271308
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Jul 11 19:45:11 2018 +0200

    of: mdio: Support fixed links in of_phy_get_and_connect()
    
    By a simple extension of of_phy_get_and_connect() drivers
    that have a fixed link on e.g. RGMII can support also
    fixed links, so in addition to:
    
    ethernet-port {
            phy-mode = "rgmii";
            phy-handle = <&foo>;
    };
    
    This setup with a fixed-link node and no phy-handle will
    now also work just fine:
    
    ethernet-port {
            phy-mode = "rgmii";
            fixed-link {
                    speed = <1000>;
                    full-duplex;
                    pause;
            };
    };
    
    This is very helpful for connecting random ethernet ports
    to e.g. DSA switches that typically reside on fixed links.
    
    The phy-mode is still there as the fixes link in this case
    is still an RGMII link.
    
    Tested on the Cortina Gemini driver with the Vitesse DSA
    router chip on a fixed 1Gbit link.
    
    Suggested-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index d963baf8e53a..e92391d6d1bd 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -367,14 +367,23 @@ struct phy_device *of_phy_get_and_connect(struct net_device *dev,
 	phy_interface_t iface;
 	struct device_node *phy_np;
 	struct phy_device *phy;
+	int ret;
 
 	iface = of_get_phy_mode(np);
 	if (iface < 0)
 		return NULL;
-
-	phy_np = of_parse_phandle(np, "phy-handle", 0);
-	if (!phy_np)
-		return NULL;
+	if (of_phy_is_fixed_link(np)) {
+		ret = of_phy_register_fixed_link(np);
+		if (ret < 0) {
+			netdev_err(dev, "broken fixed-link specification\n");
+			return NULL;
+		}
+		phy_np = of_node_get(np);
+	} else {
+		phy_np = of_parse_phandle(np, "phy-handle", 0);
+		if (!phy_np)
+			return NULL;
+	}
 
 	phy = of_phy_connect(dev, phy_np, hndlr, 0, iface);
 

commit 6d07a68a59274fa168a3ddfbcfe5df029ba0afed
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue May 15 16:56:18 2018 -0700

    of: mdio: Fall back to mdiobus_register() with NULL device_node
    
    When the device_node specified is NULL, fall back to mdiobus_register().
    We have a number of drivers having a similar pattern which is:
    
    if (np)
            of_mdiobus_register()
    else
            mdiobus_register()
    
    so incorporate that behavior within the core of_mdiobus_register()
    function. This is also consistent with the stub version that we defined
    when CONFIG_OF=n.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 8c0c92712fc9..d963baf8e53a 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -204,6 +204,9 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 	bool scanphys = false;
 	int addr, rc;
 
+	if (!np)
+		return mdiobus_register(mdio);
+
 	/* Do not continue if the node is disabled */
 	if (!of_device_is_available(np))
 		return -ENODEV;

commit 19d28fbd306e7ae7c1acf05c3e6968b56f0d196b
Merge: 8c2e6c904fd8 1545dec46db3
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Jan 11 21:27:54 2018 -0500

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    BPF alignment tests got a conflict because the registers
    are output as Rn_w instead of just Rn in net-next, and
    in net a fixup for a testcase prohibits logical operations
    on pointers before using them.
    
    Also, we should attempt to patch BPF call args if JIT always on is
    enabled.  Instead, if we fail to JIT the subprogs we should pass
    an error back up and fail immediately.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 95f566de0269a0c59fd6a737a147731302136429
Author: Madalin Bucur <madalin.bucur@nxp.com>
Date:   Tue Jan 9 14:43:34 2018 +0200

    of_mdio: avoid MDIO bus removal when a PHY is missing
    
    If one of the child devices is missing the of_mdiobus_register_phy()
    call will return -ENODEV. When a missing device is encountered the
    registration of the remaining PHYs is stopped and the MDIO bus will
    fail to register. Propagate all errors except ENODEV to avoid it.
    
    Signed-off-by: Madalin Bucur <madalin.bucur@nxp.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 3481e69738b5..a327be1d264b 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -231,7 +231,12 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 			rc = of_mdiobus_register_phy(mdio, child, addr);
 		else
 			rc = of_mdiobus_register_device(mdio, child, addr);
-		if (rc)
+
+		if (rc == -ENODEV)
+			dev_err(&mdio->dev,
+				"MDIO device at address %d is missing.\n",
+				addr);
+		else if (rc)
 			goto unregister;
 	}
 
@@ -255,7 +260,7 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 
 			if (of_mdiobus_child_is_phy(child)) {
 				rc = of_mdiobus_register_phy(mdio, child, addr);
-				if (rc)
+				if (rc && rc != -ENODEV)
 					goto unregister;
 			}
 		}

commit 04f629f730fcd30c811777d186b15c38737eaa3c
Author: Richard Leitner <richard.leitner@skidata.com>
Date:   Fri Dec 22 11:08:09 2017 +0100

    phylib: rename reset-(post-)delay-us to reset-(de)assert-us
    
    As suggested by Rob Herring [1] rename the previously introduced
    reset-{,post-}delay-us bindings to the clearer reset-{,de}assert-us
    
    [1] https://patchwork.kernel.org/patch/10104905/
    
    Signed-off-by: Richard Leitner <richard.leitner@skidata.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index f4c73292b304..1b9ef35cf0d9 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -77,9 +77,10 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio,
 	if (of_property_read_bool(child, "broken-turn-around"))
 		mdio->phy_ignore_ta_mask |= 1 << addr;
 
-	of_property_read_u32(child, "reset-delay-us", &phy->mdio.reset_delay);
-	of_property_read_u32(child, "reset-post-delay-us",
-			     &phy->mdio.reset_post_delay);
+	of_property_read_u32(child, "reset-assert-us",
+			     &phy->mdio.reset_assert_delay);
+	of_property_read_u32(child, "reset-deassert-us",
+			     &phy->mdio.reset_deassert_delay);
 
 	/* Associate the OF node with the device structure so it
 	 * can be looked up later */

commit c30abd5e40dd863f88e26be09b6ce949145a630a
Merge: 28dc4c8f4557 f3b5ad89de16
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Dec 16 22:11:55 2017 -0500

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Three sets of overlapping changes, two in the packet scheduler
    and one in the meson-gxl PHY driver.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 94a5ef1b77da4674a6bc1d3de3051b758859d106
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Tue Dec 12 10:49:15 2017 +0000

    of_mdio / mdiobus: ensure mdio devices have fwnode correctly populated
    
    Ensure that all mdio devices populate the struct device fwnode pointer
    as well as the of_node pointer to allow drivers that wish to use
    fwnode APIs to work.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 98258583abb0..3481e69738b5 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -81,6 +81,7 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio,
 	 * can be looked up later */
 	of_node_get(child);
 	phy->mdio.dev.of_node = child;
+	phy->mdio.dev.fwnode = of_fwnode_handle(child);
 
 	/* All data is now stored in the phy struct;
 	 * register it */
@@ -111,6 +112,7 @@ static int of_mdiobus_register_device(struct mii_bus *mdio,
 	 */
 	of_node_get(child);
 	mdiodev->dev.of_node = child;
+	mdiodev->dev.fwnode = of_fwnode_handle(child);
 
 	/* All data is now stored in the mdiodev struct; register it. */
 	rc = mdio_device_register(mdiodev);
@@ -206,6 +208,7 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 	mdio->phy_mask = ~0;
 
 	mdio->dev.of_node = np;
+	mdio->dev.fwnode = of_fwnode_handle(np);
 
 	/* Get bus level PHY reset GPIO details */
 	mdio->reset_delay_us = DEFAULT_GPIO_RESET_DELAY;

commit 3a30ae6ef3cba29c83ca791bde0d06f182d5678d
Author: Richard Leitner <richard.leitner@skidata.com>
Date:   Mon Dec 11 13:16:57 2017 +0100

    phylib: Add device reset delay support
    
    Some PHYs need a minimum time after the reset gpio was asserted and/or
    deasserted. To ensure we meet these timing requirements add two new
    optional devicetree parameters for the phy: reset-delay-us and
    reset-post-delay-us.
    
    Signed-off-by: Richard Leitner <richard.leitner@skidata.com>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 98258583abb0..7c8767176315 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -77,6 +77,10 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio,
 	if (of_property_read_bool(child, "broken-turn-around"))
 		mdio->phy_ignore_ta_mask |= 1 << addr;
 
+	of_property_read_u32(child, "reset-delay-us", &phy->mdio.reset_delay);
+	of_property_read_u32(child, "reset-post-delay-us",
+			     &phy->mdio.reset_post_delay);
+
 	/* Associate the OF node with the device structure so it
 	 * can be looked up later */
 	of_node_get(child);

commit 66bdede495c71da9c5ce18542976fae53642880b
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Oct 18 13:54:03 2017 +0200

    of_mdio: Fix broken PHY IRQ in case of probe deferral
    
    If an Ethernet PHY is initialized before the interrupt controller it is
    connected to, a message like the following is printed:
    
        irq: no irq domain found for /interrupt-controller@e61c0000 !
    
    However, the actual error is ignored, leading to a non-functional (POLL)
    PHY interrupt later:
    
        Micrel KSZ8041RNLI ee700000.ethernet-ffffffff:01: attached PHY driver [Micrel KSZ8041RNLI] (mii_bus:phy_addr=ee700000.ethernet-ffffffff:01, irq=POLL)
    
    Depending on whether the PHY driver will fall back to polling, Ethernet
    may or may not work.
    
    To fix this:
      1. Switch of_mdiobus_register_phy() from irq_of_parse_and_map() to
         of_irq_get().
         Unlike the former, the latter returns -EPROBE_DEFER if the
         interrupt controller is not yet available, so this condition can be
         detected.
         Other errors are handled the same as before, i.e. use the passed
         mdio->irq[addr] as interrupt.
      2. Propagate and handle errors from of_mdiobus_register_phy() and
         of_mdiobus_register_device().
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index d94dd8b77abd..98258583abb0 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -44,7 +44,7 @@ static int of_get_phy_id(struct device_node *device, u32 *phy_id)
 	return -EINVAL;
 }
 
-static void of_mdiobus_register_phy(struct mii_bus *mdio,
+static int of_mdiobus_register_phy(struct mii_bus *mdio,
 				    struct device_node *child, u32 addr)
 {
 	struct phy_device *phy;
@@ -60,9 +60,13 @@ static void of_mdiobus_register_phy(struct mii_bus *mdio,
 	else
 		phy = get_phy_device(mdio, addr, is_c45);
 	if (IS_ERR(phy))
-		return;
+		return PTR_ERR(phy);
 
-	rc = irq_of_parse_and_map(child, 0);
+	rc = of_irq_get(child, 0);
+	if (rc == -EPROBE_DEFER) {
+		phy_device_free(phy);
+		return rc;
+	}
 	if (rc > 0) {
 		phy->irq = rc;
 		mdio->irq[addr] = rc;
@@ -84,22 +88,23 @@ static void of_mdiobus_register_phy(struct mii_bus *mdio,
 	if (rc) {
 		phy_device_free(phy);
 		of_node_put(child);
-		return;
+		return rc;
 	}
 
 	dev_dbg(&mdio->dev, "registered phy %s at address %i\n",
 		child->name, addr);
+	return 0;
 }
 
-static void of_mdiobus_register_device(struct mii_bus *mdio,
-				       struct device_node *child, u32 addr)
+static int of_mdiobus_register_device(struct mii_bus *mdio,
+				      struct device_node *child, u32 addr)
 {
 	struct mdio_device *mdiodev;
 	int rc;
 
 	mdiodev = mdio_device_create(mdio, addr);
 	if (IS_ERR(mdiodev))
-		return;
+		return PTR_ERR(mdiodev);
 
 	/* Associate the OF node with the device structure so it
 	 * can be looked up later.
@@ -112,11 +117,12 @@ static void of_mdiobus_register_device(struct mii_bus *mdio,
 	if (rc) {
 		mdio_device_free(mdiodev);
 		of_node_put(child);
-		return;
+		return rc;
 	}
 
 	dev_dbg(&mdio->dev, "registered mdio device %s at address %i\n",
 		child->name, addr);
+	return 0;
 }
 
 /* The following is a list of PHY compatible strings which appear in
@@ -219,9 +225,11 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 		}
 
 		if (of_mdiobus_child_is_phy(child))
-			of_mdiobus_register_phy(mdio, child, addr);
+			rc = of_mdiobus_register_phy(mdio, child, addr);
 		else
-			of_mdiobus_register_device(mdio, child, addr);
+			rc = of_mdiobus_register_device(mdio, child, addr);
+		if (rc)
+			goto unregister;
 	}
 
 	if (!scanphys)
@@ -242,12 +250,19 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 			dev_info(&mdio->dev, "scan phy %s at address %i\n",
 				 child->name, addr);
 
-			if (of_mdiobus_child_is_phy(child))
-				of_mdiobus_register_phy(mdio, child, addr);
+			if (of_mdiobus_child_is_phy(child)) {
+				rc = of_mdiobus_register_phy(mdio, child, addr);
+				if (rc)
+					goto unregister;
+			}
 		}
 	}
 
 	return 0;
+
+unregister:
+	mdiobus_unregister(mdio);
+	return rc;
 }
 EXPORT_SYMBOL(of_mdiobus_register);
 

commit 74fee4e88fd196c712abfdae89acfa272abf10f8
Merge: 7d955656121f 84024468cf16
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 7 14:43:33 2017 -0700

    Merge tag 'devicetree-for-4.14' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull DeviceTree updates from Rob Herring:
     "There's a few orphans in the conversion to %pOF printf specifiers
      included here that no one else picked up.
    
      Summary:
    
       - Convert more DT code to use of_property_read_* API.
    
       - Improve DT overlay support when adding multiple overlays
    
       - Convert printk's to %pOF format specifiers. Most went via subsystem
         trees, but picked up the remaining orphans
    
       - Correct unittests to use preferred "okay" for "status" property
         value
    
       - Add a KASLR seed property
    
       - Vendor prefixes for Mellanox, Theobroma System, Adaptrum, Moxa
    
       - Fix modalias buffer handling
    
       - Clean-up of include paths for building dtbs
    
       - Add bindings for amc6821, isl1208, tsl2x7x, srf02, and srf10
         devices
    
       - Add nvmem bindings for MediaTek MT7623 and MT7622 SoC
    
       - Add compatible string for Allwinner H5 Mali-450 GPU
    
       - Fix links to old OpenFirmware docs with new mirror on
         devicetree.org
    
       - Remove status property from binding doc examples"
    
    * tag 'devicetree-for-4.14' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (45 commits)
      devicetree: Adjust status "ok" -> "okay" under drivers/of/
      dt-bindings: Remove "status" from examples
      dt-bindings: pinctrl: sh-pfc: Use generic node name
      dt-bindings: Add vendor Mellanox
      dt-binding: net/phy: fix interrupts description
      virt: Convert to using %pOF instead of full_name
      macintosh: Convert to using %pOF instead of full_name
      ide: pmac: Convert to using %pOF instead of full_name
      microblaze: Convert to using %pOF instead of full_name
      dt-bindings: usb: musb: Grammar s/the/to/, s/is/are/
      of: Use PLATFORM_DEVID_NONE definition
      of/device: Fix of_device_get_modalias() buffer handling
      of/device: Prevent buffer overflow in of_device_modalias()
      dt-bindings: add amc6821, isl1208 trivial bindings
      dt-bindings: add vendor prefix for Theobroma Systems
      of: search scripts/dtc/include-prefixes path for both CPP and DTC
      of: remove arch/$(SRCARCH)/boot/dts from include search path for CPP
      of: remove drivers/of/testcase-data from include search path for CPP
      of: return of_get_cpu_node from of_cpu_device_node_get if CPUs are not registered
      iio: srf08: add device tree binding for srf02 and srf10
      ...

commit 5a7a8346498c02bbb0d6512c561f1dbfab0fcf62
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Sun Aug 13 00:03:06 2017 +0300

    of_mdio: merge branch tails in of_phy_register_fixed_link()
    
    Looks  like gcc isn't always able to figure  out that 3 *if* branches in
    of_phy_register_fixed_link() calling fixed_phy_register() at their ends
    are similar enough and thus can be merged. The "manual" merge saves 40
    bytes of the object code (AArch64 gcc 4.8.5), and still saves 12 bytes
    even  if gcc was able to merge the branch tails (ARM gcc 4.8.5)...
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 94ca3470e943..b14a00034fb1 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -422,16 +422,13 @@ int of_phy_register_fixed_link(struct device_node *np)
 	struct fixed_phy_status status = {};
 	struct device_node *fixed_link_node;
 	u32 fixed_link_prop[5];
-	struct phy_device *phy;
 	const char *managed;
-	int link_gpio;
+	int link_gpio = -1;
 
-	if (of_property_read_string(np, "managed", &managed) == 0) {
-		if (strcmp(managed, "in-band-status") == 0) {
-			/* status is zeroed, namely its .link member */
-			phy = fixed_phy_register(PHY_POLL, &status, -1, np);
-			return PTR_ERR_OR_ZERO(phy);
-		}
+	if (of_property_read_string(np, "managed", &managed) == 0 &&
+	    strcmp(managed, "in-band-status") == 0) {
+		/* status is zeroed, namely its .link member */
+		goto register_phy;
 	}
 
 	/* New binding */
@@ -454,8 +451,7 @@ int of_phy_register_fixed_link(struct device_node *np)
 		if (link_gpio == -EPROBE_DEFER)
 			return -EPROBE_DEFER;
 
-		phy = fixed_phy_register(PHY_POLL, &status, link_gpio, np);
-		return PTR_ERR_OR_ZERO(phy);
+		goto register_phy;
 	}
 
 	/* Old binding */
@@ -466,11 +462,14 @@ int of_phy_register_fixed_link(struct device_node *np)
 		status.speed  = fixed_link_prop[2];
 		status.pause  = fixed_link_prop[3];
 		status.asym_pause = fixed_link_prop[4];
-		phy = fixed_phy_register(PHY_POLL, &status, -1, np);
-		return PTR_ERR_OR_ZERO(phy);
+		goto register_phy;
 	}
 
 	return -ENODEV;
+
+register_phy:
+	return PTR_ERR_OR_ZERO(fixed_phy_register(PHY_POLL, &status, link_gpio,
+						  np));
 }
 EXPORT_SYMBOL(of_phy_register_fixed_link);
 

commit d226a2b84d0528da7e35e7e19e052293889cdd21
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Sat Aug 5 00:43:43 2017 +0300

    of_mdio: use of_property_read_u32_array()
    
    The "fixed-link" prop support predated of_property_read_u32_array(), so
    basically had to open-code it. Using the modern API saves 24 bytes of the
    object code (ARM gcc 4.8.5); the only behavior change would be that the
    prop length check is now less strict (however the strict pre-check done
    in of_phy_is_fixed_link() is left intact anyway)...
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index a0d27c04e22f..94ca3470e943 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -421,10 +421,10 @@ int of_phy_register_fixed_link(struct device_node *np)
 {
 	struct fixed_phy_status status = {};
 	struct device_node *fixed_link_node;
-	const __be32 *fixed_link_prop;
+	u32 fixed_link_prop[5];
 	struct phy_device *phy;
 	const char *managed;
-	int link_gpio, len;
+	int link_gpio;
 
 	if (of_property_read_string(np, "managed", &managed) == 0) {
 		if (strcmp(managed, "in-band-status") == 0) {
@@ -459,13 +459,13 @@ int of_phy_register_fixed_link(struct device_node *np)
 	}
 
 	/* Old binding */
-	fixed_link_prop = of_get_property(np, "fixed-link", &len);
-	if (fixed_link_prop && len == (5 * sizeof(__be32))) {
+	if (of_property_read_u32_array(np, "fixed-link", fixed_link_prop,
+				       ARRAY_SIZE(fixed_link_prop)) == 0) {
 		status.link = 1;
-		status.duplex = be32_to_cpu(fixed_link_prop[1]);
-		status.speed = be32_to_cpu(fixed_link_prop[2]);
-		status.pause = be32_to_cpu(fixed_link_prop[3]);
-		status.asym_pause = be32_to_cpu(fixed_link_prop[4]);
+		status.duplex = fixed_link_prop[1];
+		status.speed  = fixed_link_prop[2];
+		status.pause  = fixed_link_prop[3];
+		status.asym_pause = fixed_link_prop[4];
 		phy = fixed_phy_register(PHY_POLL, &status, -1, np);
 		return PTR_ERR_OR_ZERO(phy);
 	}

commit e470e4f787b94ba0a08cd3b49948e823416f5a6d
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Sun Jul 23 21:45:47 2017 +0300

    of_mdio: kill useless variable in of_phy_register_fixed_link()
    
    of_phy_register_fixed_link() declares the 'err' variable to hold the result
    of of_property_read_string() but only uses it once after that, while that
    function can be called directly from the *if* statement...
    
    Remove that variable and move/regroup 'link_gpio' and 'len' variables in
    order to sort the declarations in the reverse Xmas tree order -- to please
    DaveM. ;-)
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index e0dbd6e48a98..a0d27c04e22f 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -422,13 +422,11 @@ int of_phy_register_fixed_link(struct device_node *np)
 	struct fixed_phy_status status = {};
 	struct device_node *fixed_link_node;
 	const __be32 *fixed_link_prop;
-	int link_gpio;
-	int len, err;
 	struct phy_device *phy;
 	const char *managed;
+	int link_gpio, len;
 
-	err = of_property_read_string(np, "managed", &managed);
-	if (err == 0) {
+	if (of_property_read_string(np, "managed", &managed) == 0) {
 		if (strcmp(managed, "in-band-status") == 0) {
 			/* status is zeroed, namely its .link member */
 			phy = fixed_phy_register(PHY_POLL, &status, -1, np);

commit 0d638a07d3a1e98a7598eb2812a6236324e4c55f
Author: Rob Herring <robh@kernel.org>
Date:   Thu Jun 1 15:50:55 2017 -0500

    of: Convert to using %pOF instead of full_name
    
    Now that we have a custom printf format specifier, convert users of
    full_name to use %pOF instead. This is preparation to remove storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index e0dbd6e48a98..754b9d6cd1cd 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -166,8 +166,8 @@ static bool of_mdiobus_child_is_phy(struct device_node *child)
 
 	if (of_match_node(whitelist_phys, child)) {
 		pr_warn(FW_WARN
-			"%s: Whitelisted compatible string. Please remove\n",
-			child->full_name);
+			"%pOF: Whitelisted compatible string. Please remove\n",
+			child);
 		return true;
 	}
 

commit 4798a714d6a78171d7df48c921dddd0dc004f0a0
Author: Jon Mason <jon.mason@broadcom.com>
Date:   Tue Jun 13 10:56:08 2017 -0400

    of_mdio: move of_mdio_parse_addr to header file
    
    The of_mdio_parse_addr() helper function is useful to other code, but
    the module dependency chain causes issues.  To work around this, we can
    move of_mdio_parse_addr() to be an inline function in the header file.
    This gets rid of the dependencies and still allows for the reuse of
    code.
    
    Reported-by: Liviu Dudau <liviu@dudau.co.uk>
    Signed-off-by: Jon Mason <jon.mason@broadcom.com>
    Fixes: 342fa1964439 ("mdio: mux: make child bus walking more permissive and errors more verbose")
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 9596be9a49d0..e0dbd6e48a98 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -119,28 +119,6 @@ static void of_mdiobus_register_device(struct mii_bus *mdio,
 		child->name, addr);
 }
 
-int of_mdio_parse_addr(struct device *dev, const struct device_node *np)
-{
-	u32 addr;
-	int ret;
-
-	ret = of_property_read_u32(np, "reg", &addr);
-	if (ret < 0) {
-		dev_err(dev, "%s has invalid PHY address\n", np->full_name);
-		return ret;
-	}
-
-	/* A PHY must have a reg property in the range [0-31] */
-	if (addr >= PHY_MAX_ADDR) {
-		dev_err(dev, "%s PHY address %i is too large\n",
-			np->full_name, addr);
-		return -EINVAL;
-	}
-
-	return addr;
-}
-EXPORT_SYMBOL(of_mdio_parse_addr);
-
 /* The following is a list of PHY compatible strings which appear in
  * some DTBs. The compatible string is never matched against a PHY
  * driver, so is pointless. We only expect devices which are not PHYs

commit d396e84c56047b303cac378dde4b2e5cc430b336
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Mon Jun 12 23:55:38 2017 +0300

    mdio_bus: handle only single PHY reset GPIO
    
    Commit 4c5e7a2c0501 ("dt-bindings: mdio: Clarify binding document")
    declared that a MDIO reset GPIO property should have only a single GPIO
    reference/specifier, however the supporting code was left intact, still
    burdening the kernel with now apparently useless loops -- get rid of them.
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 7e4c80f9b6cd..9596be9a49d0 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -226,7 +226,6 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 	/* Get bus level PHY reset GPIO details */
 	mdio->reset_delay_us = DEFAULT_GPIO_RESET_DELAY;
 	of_property_read_u32(np, "reset-delay-us", &mdio->reset_delay_us);
-	mdio->num_reset_gpios = of_gpio_named_count(np, "reset-gpios");
 
 	/* Register the MDIO bus */
 	rc = mdiobus_register(mdio);

commit 69226896ad636b94f6d2e55d75ff21a29c4de83b
Author: Roger Quadros <rogerq@ti.com>
Date:   Fri Apr 21 16:15:38 2017 +0300

    mdio_bus: Issue GPIO RESET to PHYs.
    
    Some boards [1] leave the PHYs at an invalid state
    during system power-up or reset thus causing unreliability
    issues with the PHY which manifests as PHY not being detected
    or link not functional. To fix this, these PHYs need to be RESET
    via a GPIO connected to the PHY's RESET pin.
    
    Some boards have a single GPIO controlling the PHY RESET pin of all
    PHYs on the bus whereas some others have separate GPIOs controlling
    individual PHY RESETs.
    
    In both cases, the RESET de-assertion cannot be done in the PHY driver
    as the PHY will not probe till its reset is de-asserted.
    So do the RESET de-assertion in the MDIO bus driver.
    
    [1] - am572x-idk, am571x-idk, a437x-idk
    
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 0b2979816dbf..7e4c80f9b6cd 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -22,6 +22,8 @@
 #include <linux/of_net.h>
 #include <linux/module.h>
 
+#define DEFAULT_GPIO_RESET_DELAY	10	/* in microseconds */
+
 MODULE_AUTHOR("Grant Likely <grant.likely@secretlab.ca>");
 MODULE_LICENSE("GPL");
 
@@ -221,6 +223,11 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 
 	mdio->dev.of_node = np;
 
+	/* Get bus level PHY reset GPIO details */
+	mdio->reset_delay_us = DEFAULT_GPIO_RESET_DELAY;
+	of_property_read_u32(np, "reset-delay-us", &mdio->reset_delay_us);
+	mdio->num_reset_gpios = of_gpio_named_count(np, "reset-gpios");
+
 	/* Register the MDIO bus */
 	rc = mdiobus_register(mdio);
 	if (rc)

commit 7e1392fb94a7f35421eca52bedead284429f4fed
Author: David Daney <david.daney@cavium.com>
Date:   Fri Feb 17 12:04:12 2017 -0800

    of_mdio: Add "broadcom,bcm5241" to the whitelist.
    
    Some Cavium dev boards have firmware which doesn't supply a proper
    ethernet-phy-ieee802.3-c22" compatible property.  Restore these boards
    to working order by whitelisting this compatible value.
    
    Signed-off-by: David Daney <david.daney@cavium.com>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 262281bd68fa..0b2979816dbf 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -147,6 +147,7 @@ EXPORT_SYMBOL(of_mdio_parse_addr);
  */
 static const struct of_device_id whitelist_phys[] = {
 	{ .compatible = "brcm,40nm-ephy" },
+	{ .compatible = "broadcom,bcm5241" },
 	{ .compatible = "marvell,88E1111", },
 	{ .compatible = "marvell,88e1116", },
 	{ .compatible = "marvell,88e1118", },

commit 3f65047c853a2a5abcd8ac1984af3452b5df4ada
Author: Johan Hovold <johan@kernel.org>
Date:   Mon Nov 28 19:24:55 2016 +0100

    of_mdio: add helper to deregister fixed-link PHYs
    
    Add helper to deregister fixed-link PHYs registered using
    of_phy_register_fixed_link().
    
    Convert the two drivers that care to deregister their fixed-link PHYs to
    use the new helper, but note that most drivers currently fail to do so.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 5a3145a02547..262281bd68fa 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -490,3 +490,18 @@ int of_phy_register_fixed_link(struct device_node *np)
 	return -ENODEV;
 }
 EXPORT_SYMBOL(of_phy_register_fixed_link);
+
+void of_phy_deregister_fixed_link(struct device_node *np)
+{
+	struct phy_device *phydev;
+
+	phydev = of_phy_find_device(np);
+	if (!phydev)
+		return;
+
+	fixed_phy_unregister(phydev);
+
+	put_device(&phydev->mdio.dev);	/* of_phy_find_device() */
+	phy_device_free(phydev);	/* fixed_phy_register() */
+}
+EXPORT_SYMBOL(of_phy_deregister_fixed_link);

commit 3ae30f4ce65e9d4de274b1472169ab3c27f5c666
Author: Johan Hovold <johan@kernel.org>
Date:   Wed Nov 16 15:20:37 2016 +0100

    of_mdio: fix device reference leak in of_phy_find_device
    
    Make sure to drop the reference taken by bus_find_device() before
    returning NULL from of_phy_find_device() when the found device is not a
    PHY.
    
    Fixes: 6ed742363b9c ("of: of_mdio: Ensure mdio device is a PHY")
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 8f4648383fb2..5a3145a02547 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -292,6 +292,7 @@ struct phy_device *of_phy_find_device(struct device_node *phy_np)
 		mdiodev = to_mdio_device(d);
 		if (mdiodev->flags & MDIO_DEVICE_FLAG_PHY)
 			return to_phy_device(d);
+		put_device(d);
 	}
 
 	return NULL;

commit 48c1699d5335bc045b50989a06b1c526b17a25ff
Author: Johan Hovold <johan@kernel.org>
Date:   Wed Nov 16 15:20:36 2016 +0100

    of_mdio: fix node leak in of_phy_register_fixed_link error path
    
    Make sure to drop the of_node reference also on failure to parse the
    speed property in of_phy_register_fixed_link().
    
    Fixes: 3be2a49e5c08 ("of: provide a binding for fixed link PHYs")
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index b470f7e3521d..8f4648383fb2 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -456,8 +456,11 @@ int of_phy_register_fixed_link(struct device_node *np)
 		status.link = 1;
 		status.duplex = of_property_read_bool(fixed_link_node,
 						      "full-duplex");
-		if (of_property_read_u32(fixed_link_node, "speed", &status.speed))
+		if (of_property_read_u32(fixed_link_node, "speed",
+					 &status.speed)) {
+			of_node_put(fixed_link_node);
 			return -EINVAL;
+		}
 		status.pause = of_property_read_bool(fixed_link_node, "pause");
 		status.asym_pause = of_property_read_bool(fixed_link_node,
 							  "asym-pause");

commit b786241253041c13d94309ca4dace301833f63d1
Author: Dongpo Li <lidongpo@hisilicon.com>
Date:   Fri Jul 15 16:26:34 2016 +0800

    of_mdio: Abstract a general interface for phy connect
    
    Abstract a general interface "of_phy_get_and_connect"
    for PHY connect. User will have no bother with getting
    "phy-mode" and "phy-handle" any more.
    
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Dongpo Li <lidongpo@hisilicon.com>
    Reviewed-by: Jiancheng Xue <xuejiancheng@hisilicon.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index e2b50bc12f23..b470f7e3521d 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -19,6 +19,7 @@
 #include <linux/of_gpio.h>
 #include <linux/of_irq.h>
 #include <linux/of_mdio.h>
+#include <linux/of_net.h>
 #include <linux/module.h>
 
 MODULE_AUTHOR("Grant Likely <grant.likely@secretlab.ca>");
@@ -331,6 +332,41 @@ struct phy_device *of_phy_connect(struct net_device *dev,
 }
 EXPORT_SYMBOL(of_phy_connect);
 
+/**
+ * of_phy_get_and_connect
+ * - Get phy node and connect to the phy described in the device tree
+ * @dev: pointer to net_device claiming the phy
+ * @np: Pointer to device tree node for the net_device claiming the phy
+ * @hndlr: Link state callback for the network device
+ *
+ * If successful, returns a pointer to the phy_device with the embedded
+ * struct device refcount incremented by one, or NULL on failure. The
+ * refcount must be dropped by calling phy_disconnect() or phy_detach().
+ */
+struct phy_device *of_phy_get_and_connect(struct net_device *dev,
+					  struct device_node *np,
+					  void (*hndlr)(struct net_device *))
+{
+	phy_interface_t iface;
+	struct device_node *phy_np;
+	struct phy_device *phy;
+
+	iface = of_get_phy_mode(np);
+	if (iface < 0)
+		return NULL;
+
+	phy_np = of_parse_phandle(np, "phy-handle", 0);
+	if (!phy_np)
+		return NULL;
+
+	phy = of_phy_connect(dev, phy_np, hndlr, 0, iface);
+
+	of_node_put(phy_np);
+
+	return phy;
+}
+EXPORT_SYMBOL(of_phy_get_and_connect);
+
 /**
  * of_phy_attach - Attach to a PHY without starting the state machine
  * @dev: pointer to net_device claiming the phy

commit a5e4bd991362223346e1d3561e61d7a25797fe25
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Jun 24 11:24:08 2016 +0200

    of_mdio: select fixed phy support unconditionally
    
    Calling the fixed-phy functions when CONFIG_FIXED_PHY=m as a previous
    change tried cannot work if the caller is in built-in code:
    
    drivers/of/built-in.o: In function `of_phy_register_fixed_link':
    of_reserved_mem.c:(.text+0x85e0): undefined reference to `fixed_phy_register'
    
    Making of_mdio depend on 'FIXED_PHY || !FIXED_PHY' would solve this
    dependency by enforcing that OF_MDIO itself becomes a loadable module
    when FIXED_PHY=y, but that creates a different dependency as it
    breaks any built-in ethernet driver that uses of_mdio.
    
    Making FIXED_PHY a bool option also cannot work, since it depends on
    PHYLIB, which again is tristate.
    
    This version now uses 'select FIXED_PHY' to ensure that the fixed-phy
    portion of of_mdio is not optional. The main downside of this is
    a small increase in code size for cases that do not need fixed phy
    support, but it should avoid all of the link-time problems.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Fixes: d1bd330a229f ("of_mdio: Enable fixed PHY support if driver is a module")
    Acked-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index de68707a99c7..e2b50bc12f23 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -361,7 +361,6 @@ struct phy_device *of_phy_attach(struct net_device *dev,
 }
 EXPORT_SYMBOL(of_phy_attach);
 
-#if IS_ENABLED(CONFIG_FIXED_PHY)
 /*
  * of_phy_is_fixed_link() and of_phy_register_fixed_link() must
  * support two DT bindings:
@@ -451,4 +450,3 @@ int of_phy_register_fixed_link(struct device_node *np)
 	return -ENODEV;
 }
 EXPORT_SYMBOL(of_phy_register_fixed_link);
-#endif

commit d1bd330a229fc8a69f0e7532138dfd42b4542fd4
Author: Ben Hutchings <ben.hutchings@codethink.co.uk>
Date:   Tue Jun 21 01:17:17 2016 +0100

    of_mdio: Enable fixed PHY support if driver is a module
    
    The fixed_phy driver doesn't have to be built-in, and it's
    important that of_mdio supports it even if it's a module.
    
    Signed-off-by: Ben Hutchings <ben.hutchings@codethink.co.uk>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index e051e1b57609..de68707a99c7 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -361,7 +361,7 @@ struct phy_device *of_phy_attach(struct net_device *dev,
 }
 EXPORT_SYMBOL(of_phy_attach);
 
-#if defined(CONFIG_FIXED_PHY)
+#if IS_ENABLED(CONFIG_FIXED_PHY)
 /*
  * of_phy_is_fixed_link() and of_phy_register_fixed_link() must
  * support two DT bindings:

commit a77f4f70fd34ac7b67581fe5b89ddc1c9ac20d39
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Thu Apr 28 16:24:12 2016 -0700

    of: of_mdio: Check if MDIO bus controller is available
    
    Add a check whether the 'struct device_node' pointer passed to
    of_mdiobus_register() is an available (aka enabled) node in the Device
    Tree.
    
    Rationale for doing this are cases where an Ethernet MAC provides a MDIO
    bus controller and node, and an additional Ethernet MAC might be
    connecting its PHY/switches to that first MDIO bus controller, while
    still embedding one internally which is therefore marked as "disabled".
    
    Instead of sprinkling checks like these in callers of
    of_mdiobus_register(), do this in a central location.
    
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index b622b33dbf93..e051e1b57609 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -209,6 +209,10 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 	bool scanphys = false;
 	int addr, rc;
 
+	/* Do not continue if the node is disabled */
+	if (!of_device_is_available(np))
+		return -ENODEV;
+
 	/* Mask out all PHYs from auto probing.  Instead the PHYs listed in
 	 * the device tree are populated after the bus has been registered */
 	mdio->phy_mask = ~0;

commit af5840a968fcb175900e5b821f37363a089f5b75
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Sun Apr 24 20:31:42 2016 +0300

    of_mdio: get_phy_device() doesn't return NULL anymore
    
    Now that get_phy_device() no longer returns NULL on error, we don't need
    to check for it...
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 2c1e52e06102..b622b33dbf93 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -56,7 +56,7 @@ static void of_mdiobus_register_phy(struct mii_bus *mdio,
 		phy = phy_device_create(mdio, addr, phy_id, 0, NULL);
 	else
 		phy = get_phy_device(mdio, addr, is_c45);
-	if (IS_ERR_OR_NULL(phy))
+	if (IS_ERR(phy))
 		return;
 
 	rc = irq_of_parse_and_map(child, 0);

commit b520bd07595b117a08871ebc0a16452cc798d35b
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Sun Apr 17 01:05:19 2016 +0300

    of_mdio: make of_mdiobus_register_{device|phy}() *void*
    
    The results of of_mdiobus_register_{device|phy}() are never checked, so we
    can make  both these functions *void*...
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 8453f08d2ef4..2c1e52e06102 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -41,8 +41,8 @@ static int of_get_phy_id(struct device_node *device, u32 *phy_id)
 	return -EINVAL;
 }
 
-static int of_mdiobus_register_phy(struct mii_bus *mdio, struct device_node *child,
-				   u32 addr)
+static void of_mdiobus_register_phy(struct mii_bus *mdio,
+				    struct device_node *child, u32 addr)
 {
 	struct phy_device *phy;
 	bool is_c45;
@@ -57,7 +57,7 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio, struct device_node *chi
 	else
 		phy = get_phy_device(mdio, addr, is_c45);
 	if (IS_ERR_OR_NULL(phy))
-		return 1;
+		return;
 
 	rc = irq_of_parse_and_map(child, 0);
 	if (rc > 0) {
@@ -81,25 +81,22 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio, struct device_node *chi
 	if (rc) {
 		phy_device_free(phy);
 		of_node_put(child);
-		return 1;
+		return;
 	}
 
 	dev_dbg(&mdio->dev, "registered phy %s at address %i\n",
 		child->name, addr);
-
-	return 0;
 }
 
-static int of_mdiobus_register_device(struct mii_bus *mdio,
-				      struct device_node *child,
-				      u32 addr)
+static void of_mdiobus_register_device(struct mii_bus *mdio,
+				       struct device_node *child, u32 addr)
 {
 	struct mdio_device *mdiodev;
 	int rc;
 
 	mdiodev = mdio_device_create(mdio, addr);
 	if (IS_ERR(mdiodev))
-		return 1;
+		return;
 
 	/* Associate the OF node with the device structure so it
 	 * can be looked up later.
@@ -112,13 +109,11 @@ static int of_mdiobus_register_device(struct mii_bus *mdio,
 	if (rc) {
 		mdio_device_free(mdiodev);
 		of_node_put(child);
-		return 1;
+		return;
 	}
 
 	dev_dbg(&mdio->dev, "registered mdio device %s at address %i\n",
 		child->name, addr);
-
-	return 0;
 }
 
 int of_mdio_parse_addr(struct device *dev, const struct device_node *np)

commit 5189b1d82f1ce6c2749fa3499d28ffd3f5075543
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Sun Mar 13 00:34:58 2016 +0300

    of_mdio: use PTR_ERR_OR_ZERO()
    
    PTR_ERR_OR_ZERO() is open coded in of_phy_register_fixed_link(), so just
    call it directly...
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 52d9b14e1717..8453f08d2ef4 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -412,7 +412,7 @@ int of_phy_register_fixed_link(struct device_node *np)
 		if (strcmp(managed, "in-band-status") == 0) {
 			/* status is zeroed, namely its .link member */
 			phy = fixed_phy_register(PHY_POLL, &status, -1, np);
-			return IS_ERR(phy) ? PTR_ERR(phy) : 0;
+			return PTR_ERR_OR_ZERO(phy);
 		}
 	}
 
@@ -434,7 +434,7 @@ int of_phy_register_fixed_link(struct device_node *np)
 			return -EPROBE_DEFER;
 
 		phy = fixed_phy_register(PHY_POLL, &status, link_gpio, np);
-		return IS_ERR(phy) ? PTR_ERR(phy) : 0;
+		return PTR_ERR_OR_ZERO(phy);
 	}
 
 	/* Old binding */
@@ -446,7 +446,7 @@ int of_phy_register_fixed_link(struct device_node *np)
 		status.pause = be32_to_cpu(fixed_link_prop[3]);
 		status.asym_pause = be32_to_cpu(fixed_link_prop[4]);
 		phy = fixed_phy_register(PHY_POLL, &status, -1, np);
-		return IS_ERR(phy) ? PTR_ERR(phy) : 0;
+		return PTR_ERR_OR_ZERO(phy);
 	}
 
 	return -ENODEV;

commit ac044b902e50ba50713e257e331bc0e0c1c7d4d9
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Sun Mar 13 00:34:02 2016 +0300

    of_mdio: use IS_ERR_OR_NULL()
    
    IS_ERR_OR_NULL() is open coded in of_mdiobus_register_phy(), so just call
    it directly...
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 3bc68acac64c..52d9b14e1717 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -56,7 +56,7 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio, struct device_node *chi
 		phy = phy_device_create(mdio, addr, phy_id, 0, NULL);
 	else
 		phy = get_phy_device(mdio, addr, is_c45);
-	if (!phy || IS_ERR(phy))
+	if (IS_ERR_OR_NULL(phy))
 		return 1;
 
 	rc = irq_of_parse_and_map(child, 0);

commit a3478bae7a2751500386816ca567af4fc0f5eb10
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Sun Mar 13 00:33:13 2016 +0300

    of_mdio: mdio_device_create() never returns NULL
    
    mdio_device_create() never returns NULL, thus checking for it in
    of_mdiobus_register_device() is pointless...
    
    Suggested-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 5e7838290998..3bc68acac64c 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -98,7 +98,7 @@ static int of_mdiobus_register_device(struct mii_bus *mdio,
 	int rc;
 
 	mdiodev = mdio_device_create(mdio, addr);
-	if (!mdiodev || IS_ERR(mdiodev))
+	if (IS_ERR(mdiodev))
 		return 1;
 
 	/* Associate the OF node with the device structure so it

commit 810813c47a564416f6306ae214e2661366c987a7
Merge: d66ab5144221 e2857b8f11a2
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Mar 8 12:34:12 2016 -0500

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Several cases of overlapping changes, as well as one instance
    (vxlan) of a bug fix in 'net' overlapping with code movement
    in 'net-next'.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 735c1e2511a5c4e6c451c8b3d29916c4b0fa39ae
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Sun Feb 28 22:50:59 2016 +0300

    of_mdio: fix kernel-doc for of_phy_connect()
    
    The 'flags' parameter of the of_phy_connect() function wasn't described
    in  the kernel-doc comment...
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 39c4be41ef83..365dc7e83ab4 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -305,6 +305,7 @@ EXPORT_SYMBOL(of_phy_find_device);
  * @dev: pointer to net_device claiming the phy
  * @phy_np: Pointer to device tree node for the PHY
  * @hndlr: Link state callback for the network device
+ * @flags: flags to pass to the PHY
  * @iface: PHY data interface type
  *
  * If successful, returns a pointer to the phy_device with the embedded

commit 2fca6d288d7cac2debf170da021780cd8265c645
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Sun Feb 28 21:56:34 2016 +0300

    of_mdio: kill useless variable in of_mdiobus_register()
    
    of_mdiobus_register()  declares the 'paddr' variable to hold the result of
    the of_get_property()  but only uses it once after that while the function
    can be called directly from the *if* statement. Remove that variable and
    switch to calling of_find_property() instead since  we don't care about
    the "reg" property's value anyway...
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 39c4be41ef83..669739b302b2 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -211,7 +211,6 @@ static bool of_mdiobus_child_is_phy(struct device_node *child)
 int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 {
 	struct device_node *child;
-	const __be32 *paddr;
 	bool scanphys = false;
 	int addr, rc;
 
@@ -246,8 +245,7 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 	/* auto scan for PHYs with empty reg property */
 	for_each_available_child_of_node(np, child) {
 		/* Skip PHYs with reg property set */
-		paddr = of_get_property(child, "reg", NULL);
-		if (paddr)
+		if (of_find_property(child, "reg", NULL))
 			continue;
 
 		for (addr = 0; addr < PHY_MAX_ADDR; addr++) {

commit f5a952c08e842cb06eb5c65947ced9b5128a62ee
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Wed Feb 3 21:35:29 2016 +0200

    of: of_mdio: Add marvell, 88e1145 to whitelist of PHY compatibilities.
    
    Commit ae461131960b ("of: of_mdio: Add a whitelist of PHY
    compatibilities.") missed one compatible string used in in-tree DTBs:
    in OCTEON, for selected boards, the kernel DTB pruning code will overwrite
    the DTB compatible string with "marvell,88e1145", which is missing
    from the whitelist. Add it.
    
    The patch fixes broken networking on EdgeRouter Lite.
    
    Fixes: ae461131960b ("of: of_mdio: Add a whitelist of PHY compatibilities.")
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 5648317d355f..39c4be41ef83 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -154,6 +154,7 @@ static const struct of_device_id whitelist_phys[] = {
 	{ .compatible = "marvell,88E1111", },
 	{ .compatible = "marvell,88e1116", },
 	{ .compatible = "marvell,88e1118", },
+	{ .compatible = "marvell,88e1145", },
 	{ .compatible = "marvell,88e1149r", },
 	{ .compatible = "marvell,88e1310", },
 	{ .compatible = "marvell,88E1510", },

commit ae461131960b27d4be158d62a89d40977388d7a1
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Thu Jan 28 02:30:29 2016 +0100

    of: of_mdio: Add a whitelist of PHY compatibilities.
    
    Some phy nodes list a compatible value indicating the PHY make/model.
    This is never used to match the device to the driver. However it does
    confuse the code to separate a PHY from a generic MDIO device like a
    switch. Generic MDIO devices must have a compatible value, PHYs can
    list clause 22 or 45, but nothing else.
    
    Issue a warning if we find a compatible value known on the whitelist,
    and say it is a PHY.
    
    Fixes: a9049e0c513c ("mdio: Add support for mdio drivers.")
    Reported-by: Aaro Koskinen <aaro.koskinen@nokia.com>
    Reported-by: Olof Johansson <olof@lixom.net>
    Tested-by: Aaro Koskinen <aaro.koskinen@nokia.com>
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index b5aa004a24b6..5648317d355f 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -143,11 +143,31 @@ int of_mdio_parse_addr(struct device *dev, const struct device_node *np)
 }
 EXPORT_SYMBOL(of_mdio_parse_addr);
 
+/* The following is a list of PHY compatible strings which appear in
+ * some DTBs. The compatible string is never matched against a PHY
+ * driver, so is pointless. We only expect devices which are not PHYs
+ * to have a compatible string, so they can be matched to an MDIO
+ * driver.  Encourage users to upgrade their DT blobs to remove these.
+ */
+static const struct of_device_id whitelist_phys[] = {
+	{ .compatible = "brcm,40nm-ephy" },
+	{ .compatible = "marvell,88E1111", },
+	{ .compatible = "marvell,88e1116", },
+	{ .compatible = "marvell,88e1118", },
+	{ .compatible = "marvell,88e1149r", },
+	{ .compatible = "marvell,88e1310", },
+	{ .compatible = "marvell,88E1510", },
+	{ .compatible = "marvell,88E1514", },
+	{ .compatible = "moxa,moxart-rtl8201cp", },
+	{}
+};
+
 /*
  * Return true if the child node is for a phy. It must either:
  * o Compatible string of "ethernet-phy-idX.X"
  * o Compatible string of "ethernet-phy-ieee802.3-c45"
  * o Compatible string of "ethernet-phy-ieee802.3-c22"
+ * o In the white list above (and issue a warning)
  * o No compatibility string
  *
  * A device which is not a phy is expected to have a compatible string
@@ -166,6 +186,13 @@ static bool of_mdiobus_child_is_phy(struct device_node *child)
 	if (of_device_is_compatible(child, "ethernet-phy-ieee802.3-c22"))
 		return true;
 
+	if (of_match_node(whitelist_phys, child)) {
+		pr_warn(FW_WARN
+			"%s: Whitelisted compatible string. Please remove\n",
+			child->full_name);
+		return true;
+	}
+
 	if (!of_find_property(child, "compatible", NULL))
 		return true;
 

commit 6ed742363b9c3d1d038f013591d57a606ae2c261
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Tue Jan 26 15:12:30 2016 +0100

    of: of_mdio: Ensure mdio device is a PHY
    
    of_phy_find_device() is used to find the phy device associated with a
    device node. It is expected the node is for a PHY device, but in fact
    it could of been probed as a generic MDIO device. Ensure the device is
    a PHY before returning it.
    
    Fixes: a9049e0c513c ("mdio: Add support for mdio drivers.")
    Reported-by: Aaro Koskinen <aaro.koskinen@nokia.com>
    Reported-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Tested-by: Aaro Koskinen <aaro.koskinen@nokia.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 86829f8064a6..b5aa004a24b6 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -256,11 +256,19 @@ static int of_phy_match(struct device *dev, void *phy_np)
 struct phy_device *of_phy_find_device(struct device_node *phy_np)
 {
 	struct device *d;
+	struct mdio_device *mdiodev;
+
 	if (!phy_np)
 		return NULL;
 
 	d = bus_find_device(&mdio_bus_type, NULL, phy_np, of_phy_match);
-	return d ? to_phy_device(d) : NULL;
+	if (d) {
+		mdiodev = to_mdio_device(d);
+		if (mdiodev->flags & MDIO_DEVICE_FLAG_PHY)
+			return to_phy_device(d);
+	}
+
+	return NULL;
 }
 EXPORT_SYMBOL(of_phy_find_device);
 

commit 1bc16addc0e92222958010537557b18e25a278c0
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Jan 12 12:35:34 2016 +0300

    mdio: remove an unneed condition
    
    It used to be that mdio->irq was a pointer but after e7f4dc3536a4
    ('mdio: Move allocation of interrupts into core') it's an array inside
    the mdio struct so it can never be NULL.
    
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index c0a8f84d92db..86829f8064a6 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -62,11 +62,9 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio, struct device_node *chi
 	rc = irq_of_parse_and_map(child, 0);
 	if (rc > 0) {
 		phy->irq = rc;
-		if (mdio->irq)
-			mdio->irq[addr] = rc;
+		mdio->irq[addr] = rc;
 	} else {
-		if (mdio->irq)
-			phy->irq = mdio->irq[addr];
+		phy->irq = mdio->irq[addr];
 	}
 
 	if (of_property_read_bool(child, "broken-turn-around"))

commit a9049e0c513c4521dbfaa302af8ed08b3366b41f
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Jan 6 20:11:26 2016 +0100

    mdio: Add support for mdio drivers.
    
    Not all devices on an MDIO bus are PHYs. Meaning not all MDIO drivers
    are PHY drivers. Add support for generic MDIO drivers.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 6febe2df76f9..c0a8f84d92db 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -92,6 +92,37 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio, struct device_node *chi
 	return 0;
 }
 
+static int of_mdiobus_register_device(struct mii_bus *mdio,
+				      struct device_node *child,
+				      u32 addr)
+{
+	struct mdio_device *mdiodev;
+	int rc;
+
+	mdiodev = mdio_device_create(mdio, addr);
+	if (!mdiodev || IS_ERR(mdiodev))
+		return 1;
+
+	/* Associate the OF node with the device structure so it
+	 * can be looked up later.
+	 */
+	of_node_get(child);
+	mdiodev->dev.of_node = child;
+
+	/* All data is now stored in the mdiodev struct; register it. */
+	rc = mdio_device_register(mdiodev);
+	if (rc) {
+		mdio_device_free(mdiodev);
+		of_node_put(child);
+		return 1;
+	}
+
+	dev_dbg(&mdio->dev, "registered mdio device %s at address %i\n",
+		child->name, addr);
+
+	return 0;
+}
+
 int of_mdio_parse_addr(struct device *dev, const struct device_node *np)
 {
 	u32 addr;
@@ -179,6 +210,8 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 
 		if (of_mdiobus_child_is_phy(child))
 			of_mdiobus_register_phy(mdio, child, addr);
+		else
+			of_mdiobus_register_device(mdio, child, addr);
 	}
 
 	if (!scanphys)

commit 7f854420fbfe9d49afe2ffb1df052cfe8e215541
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Jan 6 20:11:18 2016 +0100

    phy: Add API for {un}registering an mdio device to a bus.
    
    Rather than have drivers directly manipulate the mii_bus structure,
    provide and API for registering and unregistering devices on an MDIO
    bus, and performing lookups.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index c0292051392e..6febe2df76f9 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -193,7 +193,7 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 
 		for (addr = 0; addr < PHY_MAX_ADDR; addr++) {
 			/* skip already registered PHYs */
-			if (mdio->phy_map[addr])
+			if (mdiobus_is_registered_device(mdio, addr))
 				continue;
 
 			/* be noisy to encourage people to set reg property */

commit 801a8ef54e8b21eb6699aaa88681259dafb1d1b5
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Jan 6 20:11:17 2016 +0100

    of: phy: Only register a phy device for phys
    
    We will soon support devices other than phys on the mdio bus. Look at
    a child's compatibility string to determine if it is a phy, before
    registering a phy device.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index bc9d76329435..c0292051392e 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -114,6 +114,35 @@ int of_mdio_parse_addr(struct device *dev, const struct device_node *np)
 }
 EXPORT_SYMBOL(of_mdio_parse_addr);
 
+/*
+ * Return true if the child node is for a phy. It must either:
+ * o Compatible string of "ethernet-phy-idX.X"
+ * o Compatible string of "ethernet-phy-ieee802.3-c45"
+ * o Compatible string of "ethernet-phy-ieee802.3-c22"
+ * o No compatibility string
+ *
+ * A device which is not a phy is expected to have a compatible string
+ * indicating what sort of device it is.
+ */
+static bool of_mdiobus_child_is_phy(struct device_node *child)
+{
+	u32 phy_id;
+
+	if (of_get_phy_id(child, &phy_id) != -EINVAL)
+		return true;
+
+	if (of_device_is_compatible(child, "ethernet-phy-ieee802.3-c45"))
+		return true;
+
+	if (of_device_is_compatible(child, "ethernet-phy-ieee802.3-c22"))
+		return true;
+
+	if (!of_find_property(child, "compatible", NULL))
+		return true;
+
+	return false;
+}
+
 /**
  * of_mdiobus_register - Register mii_bus and create PHYs from the device tree
  * @mdio: pointer to mii_bus structure
@@ -140,7 +169,7 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 	if (rc)
 		return rc;
 
-	/* Loop over the child nodes and register a phy_device for each one */
+	/* Loop over the child nodes and register a phy_device for each phy */
 	for_each_available_child_of_node(np, child) {
 		addr = of_mdio_parse_addr(&mdio->dev, child);
 		if (addr < 0) {
@@ -148,9 +177,8 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 			continue;
 		}
 
-		rc = of_mdiobus_register_phy(mdio, child, addr);
-		if (rc)
-			continue;
+		if (of_mdiobus_child_is_phy(child))
+			of_mdiobus_register_phy(mdio, child, addr);
 	}
 
 	if (!scanphys)
@@ -172,9 +200,8 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 			dev_info(&mdio->dev, "scan phy %s at address %i\n",
 				 child->name, addr);
 
-			rc = of_mdiobus_register_phy(mdio, child, addr);
-			if (rc)
-				continue;
+			if (of_mdiobus_child_is_phy(child))
+				of_mdiobus_register_phy(mdio, child, addr);
 		}
 	}
 

commit e5a03bfd873c29eb786655ef2e95e53ed242b404
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Jan 6 20:11:16 2016 +0100

    phy: Add an mdio_device structure
    
    Not all devices attached to an MDIO bus are phys. So add an
    mdio_device structure to represent the generic parts of an mdio
    device, and place this structure into the phy_device.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 2f88ff4654da..bc9d76329435 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -75,7 +75,7 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio, struct device_node *chi
 	/* Associate the OF node with the device structure so it
 	 * can be looked up later */
 	of_node_get(child);
-	phy->dev.of_node = child;
+	phy->mdio.dev.of_node = child;
 
 	/* All data is now stored in the phy struct;
 	 * register it */
@@ -233,7 +233,7 @@ struct phy_device *of_phy_connect(struct net_device *dev,
 	ret = phy_connect_direct(dev, phy, hndlr, iface);
 
 	/* refcount is held by phy_connect_direct() on success */
-	put_device(&phy->dev);
+	put_device(&phy->mdio.dev);
 
 	return ret ? NULL : phy;
 }
@@ -263,7 +263,7 @@ struct phy_device *of_phy_attach(struct net_device *dev,
 	ret = phy_attach_direct(dev, phy, flags, iface);
 
 	/* refcount is held by phy_attach_direct() on success */
-	put_device(&phy->dev);
+	put_device(&phy->mdio.dev);
 
 	return ret ? NULL : phy;
 }

commit e7f4dc3536a40097f95103ddf98dd55b3a980f5b
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Jan 6 20:11:15 2016 +0100

    mdio: Move allocation of interrupts into core
    
    Have mdio_alloc() create the array of interrupt numbers, and
    initialize it to POLLING. This is what most MDIO drivers want, so
    allowing code to be removed from the drivers.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index a87a868fed64..2f88ff4654da 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -127,17 +127,12 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 	struct device_node *child;
 	const __be32 *paddr;
 	bool scanphys = false;
-	int addr, rc, i;
+	int addr, rc;
 
 	/* Mask out all PHYs from auto probing.  Instead the PHYs listed in
 	 * the device tree are populated after the bus has been registered */
 	mdio->phy_mask = ~0;
 
-	/* Clear all the IRQ properties */
-	if (mdio->irq)
-		for (i=0; i<PHY_MAX_ADDR; i++)
-			mdio->irq[i] = PHY_POLL;
-
 	mdio->dev.of_node = np;
 
 	/* Register the MDIO bus */

commit f018ae7a8c576345d56a0cd40d86c0574a2eb360
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Sep 24 20:36:13 2015 +0100

    of_mdio: fix MDIO phy device refcounting
    
    bus_find_device() is defined as:
    
     * This is similar to the bus_for_each_dev() function above, but it
     * returns a reference to a device that is 'found' for later use, as
     * determined by the @match callback.
    
    and it does indeed return a reference-counted pointer to the device:
    
            while ((dev = next_device(&i)))
                    if (match(dev, data) && get_device(dev))
                                            ^^^^^^^^^^^^^^^
                            break;
            klist_iter_exit(&i);
            return dev;
    
    What that means is that when we're done with the struct device, we must
    drop that reference.  Neither of_phy_connect() nor of_phy_attach() did
    this when phy_connect_direct() or phy_attach_direct() failed.
    
    With our previous patch, phy_connect_direct() and phy_attach_direct()
    take a new refcount on the phy device when successful, so we can drop
    our local reference immediatley after these functions, whether or not
    they succeeded.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 1350fa25cdb0..a87a868fed64 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -197,7 +197,8 @@ static int of_phy_match(struct device *dev, void *phy_np)
  * of_phy_find_device - Give a PHY node, find the phy_device
  * @phy_np: Pointer to the phy's device tree node
  *
- * Returns a pointer to the phy_device.
+ * If successful, returns a pointer to the phy_device with the embedded
+ * struct device refcount incremented by one, or NULL on failure.
  */
 struct phy_device *of_phy_find_device(struct device_node *phy_np)
 {
@@ -217,7 +218,9 @@ EXPORT_SYMBOL(of_phy_find_device);
  * @hndlr: Link state callback for the network device
  * @iface: PHY data interface type
  *
- * Returns a pointer to the phy_device if successful.  NULL otherwise
+ * If successful, returns a pointer to the phy_device with the embedded
+ * struct device refcount incremented by one, or NULL on failure. The
+ * refcount must be dropped by calling phy_disconnect() or phy_detach().
  */
 struct phy_device *of_phy_connect(struct net_device *dev,
 				  struct device_node *phy_np,
@@ -225,13 +228,19 @@ struct phy_device *of_phy_connect(struct net_device *dev,
 				  phy_interface_t iface)
 {
 	struct phy_device *phy = of_phy_find_device(phy_np);
+	int ret;
 
 	if (!phy)
 		return NULL;
 
 	phy->dev_flags = flags;
 
-	return phy_connect_direct(dev, phy, hndlr, iface) ? NULL : phy;
+	ret = phy_connect_direct(dev, phy, hndlr, iface);
+
+	/* refcount is held by phy_connect_direct() on success */
+	put_device(&phy->dev);
+
+	return ret ? NULL : phy;
 }
 EXPORT_SYMBOL(of_phy_connect);
 
@@ -241,17 +250,27 @@ EXPORT_SYMBOL(of_phy_connect);
  * @phy_np: Node pointer for the PHY
  * @flags: flags to pass to the PHY
  * @iface: PHY data interface type
+ *
+ * If successful, returns a pointer to the phy_device with the embedded
+ * struct device refcount incremented by one, or NULL on failure. The
+ * refcount must be dropped by calling phy_disconnect() or phy_detach().
  */
 struct phy_device *of_phy_attach(struct net_device *dev,
 				 struct device_node *phy_np, u32 flags,
 				 phy_interface_t iface)
 {
 	struct phy_device *phy = of_phy_find_device(phy_np);
+	int ret;
 
 	if (!phy)
 		return NULL;
 
-	return phy_attach_direct(dev, phy, flags, iface) ? NULL : phy;
+	ret = phy_attach_direct(dev, phy, flags, iface);
+
+	/* refcount is held by phy_attach_direct() on success */
+	put_device(&phy->dev);
+
+	return ret ? NULL : phy;
 }
 EXPORT_SYMBOL(of_phy_attach);
 

commit a5597008dbc230876db2d344561d634f4d52ea4a
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Mon Aug 31 15:56:53 2015 +0200

    phy: fixed_phy: Add gpio to determine link up/down.
    
    An SFP module may have a link up/down status pin which can be
    connection to a GPIO line of the host. Add support for reading such an
    GPIO in the fixed_phy driver.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 7c8c23cc6896..1350fa25cdb0 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -16,6 +16,7 @@
 #include <linux/phy.h>
 #include <linux/phy_fixed.h>
 #include <linux/of.h>
+#include <linux/of_gpio.h>
 #include <linux/of_irq.h>
 #include <linux/of_mdio.h>
 #include <linux/module.h>
@@ -294,6 +295,7 @@ int of_phy_register_fixed_link(struct device_node *np)
 	struct fixed_phy_status status = {};
 	struct device_node *fixed_link_node;
 	const __be32 *fixed_link_prop;
+	int link_gpio;
 	int len, err;
 	struct phy_device *phy;
 	const char *managed;
@@ -302,7 +304,7 @@ int of_phy_register_fixed_link(struct device_node *np)
 	if (err == 0) {
 		if (strcmp(managed, "in-band-status") == 0) {
 			/* status is zeroed, namely its .link member */
-			phy = fixed_phy_register(PHY_POLL, &status, np);
+			phy = fixed_phy_register(PHY_POLL, &status, -1, np);
 			return IS_ERR(phy) ? PTR_ERR(phy) : 0;
 		}
 	}
@@ -318,8 +320,13 @@ int of_phy_register_fixed_link(struct device_node *np)
 		status.pause = of_property_read_bool(fixed_link_node, "pause");
 		status.asym_pause = of_property_read_bool(fixed_link_node,
 							  "asym-pause");
+		link_gpio = of_get_named_gpio_flags(fixed_link_node,
+						    "link-gpios", 0, NULL);
 		of_node_put(fixed_link_node);
-		phy = fixed_phy_register(PHY_POLL, &status, np);
+		if (link_gpio == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+
+		phy = fixed_phy_register(PHY_POLL, &status, link_gpio, np);
 		return IS_ERR(phy) ? PTR_ERR(phy) : 0;
 	}
 
@@ -331,7 +338,7 @@ int of_phy_register_fixed_link(struct device_node *np)
 		status.speed = be32_to_cpu(fixed_link_prop[2]);
 		status.pause = be32_to_cpu(fixed_link_prop[3]);
 		status.asym_pause = be32_to_cpu(fixed_link_prop[4]);
-		phy = fixed_phy_register(PHY_POLL, &status, np);
+		phy = fixed_phy_register(PHY_POLL, &status, -1, np);
 		return IS_ERR(phy) ? PTR_ERR(phy) : 0;
 	}
 

commit 4cba5c2103657d43d0886e4cff8004d95a3d0def
Author: Stas Sergeev <stsp@list.ru>
Date:   Mon Jul 20 17:49:57 2015 -0700

    of_mdio: add new DT property 'managed' to specify the PHY management type
    
    Currently the PHY management type is selected by the MAC driver arbitrary.
    The decision is based on the presence of the "fixed-link" node and on a
    will of the driver's authors.
    This caused a regression recently, when mvneta driver suddenly started
    to use the in-band status for auto-negotiation on fixed links.
    It appears the auto-negotiation may not work when expected by the MAC driver.
    Sebastien Rannou explains:
    << Yes, I confirm that my HW does not generate an in-band status. AFAIK, it's
    a PHY that aggregates 4xSGMIIs to 1xQSGMII ; the MAC side of the PHY (with
    inband status) is connected to the switch through QSGMII, and in this context
    we are on the media side of the PHY. >>
    https://lkml.org/lkml/2015/7/10/206
    
    This patch introduces the new string property 'managed' that allows
    the user to set the management type explicitly.
    The supported values are:
    "auto" - default. Uses either MDIO or nothing, depending on the presence
    of the fixed-link node
    "in-band-status" - use in-band status
    
    Signed-off-by: Stas Sergeev <stsp@users.sourceforge.net>
    
    CC: Rob Herring <robh+dt@kernel.org>
    CC: Pawel Moll <pawel.moll@arm.com>
    CC: Mark Rutland <mark.rutland@arm.com>
    CC: Ian Campbell <ijc+devicetree@hellion.org.uk>
    CC: Kumar Gala <galak@codeaurora.org>
    CC: Florian Fainelli <f.fainelli@gmail.com>
    CC: Grant Likely <grant.likely@linaro.org>
    CC: devicetree@vger.kernel.org
    CC: linux-kernel@vger.kernel.org
    CC: netdev@vger.kernel.org
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index fdc60db60829..7c8c23cc6896 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -266,7 +266,8 @@ EXPORT_SYMBOL(of_phy_attach);
 bool of_phy_is_fixed_link(struct device_node *np)
 {
 	struct device_node *dn;
-	int len;
+	int len, err;
+	const char *managed;
 
 	/* New binding */
 	dn = of_get_child_by_name(np, "fixed-link");
@@ -275,6 +276,10 @@ bool of_phy_is_fixed_link(struct device_node *np)
 		return true;
 	}
 
+	err = of_property_read_string(np, "managed", &managed);
+	if (err == 0 && strcmp(managed, "auto") != 0)
+		return true;
+
 	/* Old binding */
 	if (of_get_property(np, "fixed-link", &len) &&
 	    len == (5 * sizeof(__be32)))
@@ -289,8 +294,18 @@ int of_phy_register_fixed_link(struct device_node *np)
 	struct fixed_phy_status status = {};
 	struct device_node *fixed_link_node;
 	const __be32 *fixed_link_prop;
-	int len;
+	int len, err;
 	struct phy_device *phy;
+	const char *managed;
+
+	err = of_property_read_string(np, "managed", &managed);
+	if (err == 0) {
+		if (strcmp(managed, "in-band-status") == 0) {
+			/* status is zeroed, namely its .link member */
+			phy = fixed_phy_register(PHY_POLL, &status, np);
+			return IS_ERR(phy) ? PTR_ERR(phy) : 0;
+		}
+	}
 
 	/* New binding */
 	fixed_link_node = of_get_child_by_name(np, "fixed-link");

commit ab6016e0c134c3a564e6750f5b246ba17ada4686
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue May 12 10:33:25 2015 -0700

    of: mdio: Add a "broken-turn-around" property
    
    Some Ethernet PHY devices/switches may not properly release the MDIO bus
    during turn-around time, and fail to drive it low, which can be seen by
    some controllers as a read failure, while the data clocked in is still
    correct.
    
    Add a boolean property "broken-turn-around" which is parsed by the
    generic MDIO bus probing code and will set the corresponding bit in the
    MDIO bus phy_ignore_ta_mask bitmask for MDIO bus drivers to utilize that
    information.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 0c064485d1c2..fdc60db60829 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -68,6 +68,9 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio, struct device_node *chi
 			phy->irq = mdio->irq[addr];
 	}
 
+	if (of_property_read_bool(child, "broken-turn-around"))
+		mdio->phy_ignore_ta_mask |= 1 << addr;
+
 	/* Associate the OF node with the device structure so it
 	 * can be looked up later */
 	of_node_get(child);

commit 33d6737761ea425d43f3b6e4561573a4020982f2
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Mar 10 16:57:11 2015 -0700

    of: mdio: export of_mdio_parse_addr
    
    Export of_mdio_parse_addr() which allows parsing a given Ethernet PHY
    node MDIO address, verify it is within the allowed range, and return
    its value. This is going to be useful for the DSA code which needs to
    deal with multiple layers of MDIO buses.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 1bd43053b8c7..0c064485d1c2 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -88,7 +88,7 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio, struct device_node *chi
 	return 0;
 }
 
-static int of_mdio_parse_addr(struct device *dev, const struct device_node *np)
+int of_mdio_parse_addr(struct device *dev, const struct device_node *np)
 {
 	u32 addr;
 	int ret;
@@ -108,6 +108,7 @@ static int of_mdio_parse_addr(struct device *dev, const struct device_node *np)
 
 	return addr;
 }
+EXPORT_SYMBOL(of_mdio_parse_addr);
 
 /**
  * of_mdiobus_register - Register mii_bus and create PHYs from the device tree

commit fd2ef0ba3071c92ac6272ab22ea3f2b16d88a4eb
Author: Petri Gynther <pgynther@google.com>
Date:   Mon Oct 6 11:38:30 2014 -0700

    net: phy: adjust fixed_phy_register() return value
    
    Adjust fixed_phy_register() to return struct phy_device *, so that
    it becomes easy to use fixed PHYs without device tree support:
    
      phydev = fixed_phy_register(PHY_POLL, &fixed_phy_status, NULL);
      fixed_phy_set_link_update(phydev, fixed_phy_link_update);
      phy_connect_direct(netdev, phydev, handler_fn, phy_interface);
    
    This change is a prerequisite for modifying bcmgenet driver to work
    without a device tree on Broadcom's MIPS-based 7xxx platforms.
    
    Signed-off-by: Petri Gynther <pgynther@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index a85d80012993..1bd43053b8c7 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -286,6 +286,7 @@ int of_phy_register_fixed_link(struct device_node *np)
 	struct device_node *fixed_link_node;
 	const __be32 *fixed_link_prop;
 	int len;
+	struct phy_device *phy;
 
 	/* New binding */
 	fixed_link_node = of_get_child_by_name(np, "fixed-link");
@@ -299,7 +300,8 @@ int of_phy_register_fixed_link(struct device_node *np)
 		status.asym_pause = of_property_read_bool(fixed_link_node,
 							  "asym-pause");
 		of_node_put(fixed_link_node);
-		return fixed_phy_register(PHY_POLL, &status, np);
+		phy = fixed_phy_register(PHY_POLL, &status, np);
+		return IS_ERR(phy) ? PTR_ERR(phy) : 0;
 	}
 
 	/* Old binding */
@@ -310,7 +312,8 @@ int of_phy_register_fixed_link(struct device_node *np)
 		status.speed = be32_to_cpu(fixed_link_prop[2]);
 		status.pause = be32_to_cpu(fixed_link_prop[3]);
 		status.asym_pause = be32_to_cpu(fixed_link_prop[4]);
-		return fixed_phy_register(PHY_POLL, &status, np);
+		phy = fixed_phy_register(PHY_POLL, &status, np);
+		return IS_ERR(phy) ? PTR_ERR(phy) : 0;
 	}
 
 	return -ENODEV;

commit 2f63715138233db9f1c2afff33f7d8192a29ff91
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri Sep 19 13:07:49 2014 -0700

    of: mdio: honor flags passed to of_phy_connect
    
    Commit f9a8f83b04e0 ("net: phy: remove flags argument from phy_{attach,
    connect, connect_direct}") removed the flags argument to the PHY library
    calls to: phy_{attach,connect,connect_direct}.
    
    Most Device Tree aware drivers call of_phy_connect() with the flag
    argument set to 0, but some of them might want to set a different value
    there in order for the PHY driver to key a specific behavior based on
    the phy_device::phy_flags value.
    
    Allow such drivers to set custom phy_flags as part of the
    of_phy_connect() call since of_phy_connect() does start the PHY state
    machine, it will call into the PHY driver config_init() callback which
    is usually where a specific phy_flags value is important.
    
    Fixes: f9a8f83b04e0 ("net: phy: remove flags argument from phy_{attach, connect, connect_direct}")
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 401b2453da45..a85d80012993 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -224,6 +224,8 @@ struct phy_device *of_phy_connect(struct net_device *dev,
 	if (!phy)
 		return NULL;
 
+	phy->dev_flags = flags;
+
 	return phy_connect_direct(dev, phy, hndlr, iface) ? NULL : phy;
 }
 EXPORT_SYMBOL(of_phy_connect);

commit d9daa24720891a88bedb93928f57767da96e5c80
Author: Daniel Mack <zonque@gmail.com>
Date:   Sat Jun 28 01:23:35 2014 +0200

    net: fix circular dependency in of_mdio code
    
    Commit 86f6cf4127 (net: of_mdio: add of_mdiobus_link_phydev()) introduced a
    circular dependency between libphy and of_mdio.
    
    depmod: ERROR: <modroot>/kernel/drivers/net/phy/libphy.ko in
    dependency cycle!
    depmod: ERROR: <modroot>/kernel/drivers/of/of_mdio.ko in dependency cycle!
    
    The problem is that of_mdio.c references &mdio_bus_type and libphy now
    references of_mdiobus_link_phydev.
    
    Fix this by not exporting of_mdiobus_link_phydev() from of_mdio.ko.
    Make it a static function in mdio_bus.c instead.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Reported-by: Jeff Mahoney <jeffm@suse.com>
    Fixes: 86f6cf4127 (net: of_mdio: add of_mdiobus_link_phydev())
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index a3bf2122a8d5..401b2453da45 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -182,40 +182,6 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 }
 EXPORT_SYMBOL(of_mdiobus_register);
 
-/**
- * of_mdiobus_link_phydev - Find a device node for a phy
- * @mdio: pointer to mii_bus structure
- * @phydev: phydev for which the of_node pointer should be set
- *
- * Walk the list of subnodes of a mdio bus and look for a node that matches the
- * phy's address with its 'reg' property. If found, set the of_node pointer for
- * the phy. This allows auto-probed pyh devices to be supplied with information
- * passed in via DT.
- */
-void of_mdiobus_link_phydev(struct mii_bus *mdio,
-			    struct phy_device *phydev)
-{
-	struct device *dev = &phydev->dev;
-	struct device_node *child;
-
-	if (dev->of_node || !mdio->dev.of_node)
-		return;
-
-	for_each_available_child_of_node(mdio->dev.of_node, child) {
-		int addr;
-
-		addr = of_mdio_parse_addr(&mdio->dev, child);
-		if (addr < 0)
-			continue;
-
-		if (addr == phydev->addr) {
-			dev->of_node = child;
-			return;
-		}
-	}
-}
-EXPORT_SYMBOL(of_mdiobus_link_phydev);
-
 /* Helper function for of_phy_find_device */
 static int of_phy_match(struct device *dev, void *phy_np)
 {

commit a72e154107340b868e69e0afeb418c9ec0994317
Author: Richard Retanubun <rretanubun.work@gmail.com>
Date:   Fri Jun 20 10:11:07 2014 -0400

    of: mdio: fixup of_phy_register_fixed_link parsing of new bindings
    
    Fixes commit 3be2a49e5c08 ("of: provide a binding for fixed link PHYs")
    
    Fix the parsing of the new fixed link dts bindings for duplex,
    pause, and asym_pause by using the correct device node pointer.
    
    Signed-off-by: Richard Retanubun <rretanubun.work@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index fb4a59830648..a3bf2122a8d5 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -323,11 +323,13 @@ int of_phy_register_fixed_link(struct device_node *np)
 	fixed_link_node = of_get_child_by_name(np, "fixed-link");
 	if (fixed_link_node) {
 		status.link = 1;
-		status.duplex = of_property_read_bool(np, "full-duplex");
+		status.duplex = of_property_read_bool(fixed_link_node,
+						      "full-duplex");
 		if (of_property_read_u32(fixed_link_node, "speed", &status.speed))
 			return -EINVAL;
-		status.pause = of_property_read_bool(np, "pause");
-		status.asym_pause = of_property_read_bool(np, "asym-pause");
+		status.pause = of_property_read_bool(fixed_link_node, "pause");
+		status.asym_pause = of_property_read_bool(fixed_link_node,
+							  "asym-pause");
 		of_node_put(fixed_link_node);
 		return fixed_phy_register(PHY_POLL, &status, np);
 	}

commit e067ee336a9d3f038ffa9699c59f2abec3376bf7
Author: Daniel Mack <zonque@gmail.com>
Date:   Mon Jun 2 13:32:46 2014 +0200

    of: of_mdio: export symbol of_mdiobus_link_phydev
    
    Make of_mdiobus_link_phydev externally available.
    This fixes CONFIG_OF_MDIO=m.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Fixes: 86f6cf41272 ("net: of_mdio: add of_mdiobus_link_phydev()")
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 8478c97f9201..fb4a59830648 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -214,6 +214,7 @@ void of_mdiobus_link_phydev(struct mii_bus *mdio,
 		}
 	}
 }
+EXPORT_SYMBOL(of_mdiobus_link_phydev);
 
 /* Helper function for of_phy_find_device */
 static int of_phy_match(struct device *dev, void *phy_np)

commit 4cd984b022597b3454c7999addf9d48f41189ea6
Author: Daniel Mack <zonque@gmail.com>
Date:   Mon Jun 2 13:32:45 2014 +0200

    net: of_mdio: use int type for address variable
    
    Use int rather than u32 to fix the following warning:
    
    drivers/of/of_mdio.c:147 of_mdiobus_register() warn: unsigned 'addr' is
    never less than zero.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Fixes: 8f8382888cba ("net: of_mdio: factor out code to parse a phy's 'reg' property")
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 2fe922bfade8..8478c97f9201 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -121,9 +121,8 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 {
 	struct device_node *child;
 	const __be32 *paddr;
-	u32 addr;
 	bool scanphys = false;
-	int rc, i;
+	int addr, rc, i;
 
 	/* Mask out all PHYs from auto probing.  Instead the PHYs listed in
 	 * the device tree are populated after the bus has been registered */

commit 24f28dde5bed3b6322003dca903ebf7732efa550
Author: Daniel Mack <zonque@gmail.com>
Date:   Sat May 24 09:34:27 2014 +0200

    net: of_mdio: don't store the length of a property if we don't need to
    
    of_get_property() can be called with NULL as 2nd argument if the caller
    is not interested in the length of a property. Use that here so we can
    get rid of a variable.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 7c8c142e4eb8..2fe922bfade8 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -123,7 +123,7 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 	const __be32 *paddr;
 	u32 addr;
 	bool scanphys = false;
-	int rc, i, len;
+	int rc, i;
 
 	/* Mask out all PHYs from auto probing.  Instead the PHYs listed in
 	 * the device tree are populated after the bus has been registered */
@@ -160,7 +160,7 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 	/* auto scan for PHYs with empty reg property */
 	for_each_available_child_of_node(np, child) {
 		/* Skip PHYs with reg property set */
-		paddr = of_get_property(child, "reg", &len);
+		paddr = of_get_property(child, "reg", NULL);
 		if (paddr)
 			continue;
 

commit 86f6cf41272de9d6ffa05ab46028b15d160a6f3e
Author: Daniel Mack <zonque@gmail.com>
Date:   Sat May 24 09:34:26 2014 +0200

    net: of_mdio: add of_mdiobus_link_phydev()
    
    Add a function to walk the list of subnodes of a mdio bus and look for
    a node that matches the phy's address with its 'reg' property. If found,
    set the of_node pointer for the phy. This allows auto-probed pyh
    devices to be augmented by information passed in via DT.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 731d3d9052d7..7c8c142e4eb8 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -183,6 +183,39 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 }
 EXPORT_SYMBOL(of_mdiobus_register);
 
+/**
+ * of_mdiobus_link_phydev - Find a device node for a phy
+ * @mdio: pointer to mii_bus structure
+ * @phydev: phydev for which the of_node pointer should be set
+ *
+ * Walk the list of subnodes of a mdio bus and look for a node that matches the
+ * phy's address with its 'reg' property. If found, set the of_node pointer for
+ * the phy. This allows auto-probed pyh devices to be supplied with information
+ * passed in via DT.
+ */
+void of_mdiobus_link_phydev(struct mii_bus *mdio,
+			    struct phy_device *phydev)
+{
+	struct device *dev = &phydev->dev;
+	struct device_node *child;
+
+	if (dev->of_node || !mdio->dev.of_node)
+		return;
+
+	for_each_available_child_of_node(mdio->dev.of_node, child) {
+		int addr;
+
+		addr = of_mdio_parse_addr(&mdio->dev, child);
+		if (addr < 0)
+			continue;
+
+		if (addr == phydev->addr) {
+			dev->of_node = child;
+			return;
+		}
+	}
+}
+
 /* Helper function for of_phy_find_device */
 static int of_phy_match(struct device *dev, void *phy_np)
 {

commit 8f8382888cbaf6de13046437d41a1c3d1394d51f
Author: Daniel Mack <zonque@gmail.com>
Date:   Sat May 24 09:34:25 2014 +0200

    net: of_mdio: factor out code to parse a phy's 'reg' property
    
    Factor out some logic into of_mdio_parse_addr() so it can be reused
    later. While at it, use of_property_read_u32() rather than open-coding
    the same logic again.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 7c6e277cdd1f..731d3d9052d7 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -88,6 +88,27 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio, struct device_node *chi
 	return 0;
 }
 
+static int of_mdio_parse_addr(struct device *dev, const struct device_node *np)
+{
+	u32 addr;
+	int ret;
+
+	ret = of_property_read_u32(np, "reg", &addr);
+	if (ret < 0) {
+		dev_err(dev, "%s has invalid PHY address\n", np->full_name);
+		return ret;
+	}
+
+	/* A PHY must have a reg property in the range [0-31] */
+	if (addr >= PHY_MAX_ADDR) {
+		dev_err(dev, "%s PHY address %i is too large\n",
+			np->full_name, addr);
+		return -EINVAL;
+	}
+
+	return addr;
+}
+
 /**
  * of_mdiobus_register - Register mii_bus and create PHYs from the device tree
  * @mdio: pointer to mii_bus structure
@@ -122,19 +143,9 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 
 	/* Loop over the child nodes and register a phy_device for each one */
 	for_each_available_child_of_node(np, child) {
-		/* A PHY must have a reg property in the range [0-31] */
-		paddr = of_get_property(child, "reg", &len);
-		if (!paddr || len < sizeof(*paddr)) {
+		addr = of_mdio_parse_addr(&mdio->dev, child);
+		if (addr < 0) {
 			scanphys = true;
-			dev_err(&mdio->dev, "%s has invalid PHY address\n",
-				child->full_name);
-			continue;
-		}
-
-		addr = be32_to_cpup(paddr);
-		if (addr >= PHY_MAX_ADDR) {
-			dev_err(&mdio->dev, "%s PHY address %i is too large\n",
-				child->full_name, addr);
 			continue;
 		}
 

commit 587b24a54984f626337d8a6ce2931994c342ded3
Author: Christian Engelmayer <cengelma@gmx.at>
Date:   Fri May 23 23:33:55 2014 +0200

    of: mdio: fix compile warning in of_mdiobus_register_phy()
    
    Commit de906af1 (net: phy: make of_set_phy_supported work with genphy driver)
    removed the last user of variable 'max_speed' in function
    of_mdiobus_register_phy(), leading to compile warning "unused variable
    ‘max_speed’ [-Wunused-variable]". Thus remove it.
    
    Signed-off-by: Christian Engelmayer <cengelma@gmx.at>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index b85709458639..7c6e277cdd1f 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -46,7 +46,6 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio, struct device_node *chi
 	struct phy_device *phy;
 	bool is_c45;
 	int rc;
-	u32 max_speed = 0;
 	u32 phy_id;
 
 	is_c45 = of_device_is_compatible(child,

commit de906af1cf8d5f2e9c461148577ac26dcdaea86e
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Wed May 21 15:29:45 2014 +0200

    net: phy: make of_set_phy_supported work with genphy driver
    
    of_set_phy_supported allows overwiting hardware capabilities of
    a phy with values from the devicetree. of_set_phy_supported is
    called right after phy_device_register in the assumption that
    phy_probe is called from phy_device_register and the features
    of the phy are already initialized. For the genphy driver this
    is not true, here phy_probe is called later during phy_connect
    time. phy_probe will then overwrite all settings done from
    of_set_phy_supported
    Fix this by moving of_set_phy_supported to the core phy code
    and calling it from phy_probe.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 4c1e01ed16dc..b85709458639 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -23,27 +23,6 @@
 MODULE_AUTHOR("Grant Likely <grant.likely@secretlab.ca>");
 MODULE_LICENSE("GPL");
 
-static void of_set_phy_supported(struct phy_device *phydev, u32 max_speed)
-{
-	/* The default values for phydev->supported are provided by the PHY
-	 * driver "features" member, we want to reset to sane defaults fist
-	 * before supporting higher speeds.
-	 */
-	phydev->supported &= PHY_DEFAULT_FEATURES;
-
-	switch (max_speed) {
-	default:
-		return;
-
-	case SPEED_1000:
-		phydev->supported |= PHY_1000BT_FEATURES;
-	case SPEED_100:
-		phydev->supported |= PHY_100BT_FEATURES;
-	case SPEED_10:
-		phydev->supported |= PHY_10BT_FEATURES;
-	}
-}
-
 /* Extract the clause 22 phy ID from the compatible string of the form
  * ethernet-phy-idAAAA.BBBB */
 static int of_get_phy_id(struct device_node *device, u32 *phy_id)
@@ -104,11 +83,6 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio, struct device_node *chi
 		return 1;
 	}
 
-	/* Set phydev->supported based on the "max-speed" property
-	 * if present */
-	if (!of_property_read_u32(child, "max-speed", &max_speed))
-		of_set_phy_supported(phy, max_speed);
-
 	dev_dbg(&mdio->dev, "registered phy %s at address %i\n",
 		child->name, addr);
 

commit ea3429c77d4e34cb2983b90e49a5506fedf70b98
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Thu May 22 09:47:50 2014 -0700

    of: mdio: remove of_phy_connect_fixed_link
    
    All in-tree drivers have been converted to use the new pair of
    functions: of_is_fixed_phy_link() plus of_phy_register_fixed_link(), we
    can now safely remove of_phy_connect_fixed_link.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 1def0bb5cb37..4c1e01ed16dc 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -245,44 +245,6 @@ struct phy_device *of_phy_connect(struct net_device *dev,
 }
 EXPORT_SYMBOL(of_phy_connect);
 
-/**
- * of_phy_connect_fixed_link - Parse fixed-link property and return a dummy phy
- * @dev: pointer to net_device claiming the phy
- * @hndlr: Link state callback for the network device
- * @iface: PHY data interface type
- *
- * This function is a temporary stop-gap and will be removed soon.  It is
- * only to support the fs_enet, ucc_geth and gianfar Ethernet drivers.  Do
- * not call this function from new drivers.
- */
-struct phy_device *of_phy_connect_fixed_link(struct net_device *dev,
-					     void (*hndlr)(struct net_device *),
-					     phy_interface_t iface)
-{
-	struct device_node *net_np;
-	char bus_id[MII_BUS_ID_SIZE + 3];
-	struct phy_device *phy;
-	const __be32 *phy_id;
-	int sz;
-
-	if (!dev->dev.parent)
-		return NULL;
-
-	net_np = dev->dev.parent->of_node;
-	if (!net_np)
-		return NULL;
-
-	phy_id = of_get_property(net_np, "fixed-link", &sz);
-	if (!phy_id || sz < sizeof(*phy_id))
-		return NULL;
-
-	sprintf(bus_id, PHY_ID_FMT, "fixed-0", be32_to_cpu(phy_id[0]));
-
-	phy = phy_connect(dev, bus_id, hndlr, iface);
-	return IS_ERR(phy) ? NULL : phy;
-}
-EXPORT_SYMBOL(of_phy_connect_fixed_link);
-
 /**
  * of_phy_attach - Attach to a PHY without starting the state machine
  * @dev: pointer to net_device claiming the phy

commit 3be2a49e5c08d268f8af0dd4fe89a24ea8cdc339
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Fri May 16 16:14:05 2014 +0200

    of: provide a binding for fixed link PHYs
    
    Some Ethernet MACs have a "fixed link", and are not connected to a
    normal MDIO-managed PHY device. For those situations, a Device Tree
    binding allows to describe a "fixed link" using a special PHY node.
    
    This patch adds:
    
     * A documentation for the fixed PHY Device Tree binding.
    
     * An of_phy_is_fixed_link() function that an Ethernet driver can call
       on its PHY phandle to find out whether it's a fixed link PHY or
       not. It should typically be used to know if
       of_phy_register_fixed_link() should be called.
    
     * An of_phy_register_fixed_link() function that instantiates the
       fixed PHY into the PHY subsystem, so that when the driver calls
       of_phy_connect(), the PHY device associated to the OF node will be
       found.
    
    These two additional functions also support the old fixed-link Device
    Tree binding used on PowerPC platforms, so that ultimately, the
    network device drivers for those platforms could be converted to use
    of_phy_is_fixed_link() and of_phy_register_fixed_link() instead of
    of_phy_connect_fixed_link(), while keeping compatibility with their
    respective Device Tree bindings.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Tested-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 9a95831bd065..1def0bb5cb37 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -14,6 +14,7 @@
 #include <linux/netdevice.h>
 #include <linux/err.h>
 #include <linux/phy.h>
+#include <linux/phy_fixed.h>
 #include <linux/of.h>
 #include <linux/of_irq.h>
 #include <linux/of_mdio.h>
@@ -301,3 +302,69 @@ struct phy_device *of_phy_attach(struct net_device *dev,
 	return phy_attach_direct(dev, phy, flags, iface) ? NULL : phy;
 }
 EXPORT_SYMBOL(of_phy_attach);
+
+#if defined(CONFIG_FIXED_PHY)
+/*
+ * of_phy_is_fixed_link() and of_phy_register_fixed_link() must
+ * support two DT bindings:
+ * - the old DT binding, where 'fixed-link' was a property with 5
+ *   cells encoding various informations about the fixed PHY
+ * - the new DT binding, where 'fixed-link' is a sub-node of the
+ *   Ethernet device.
+ */
+bool of_phy_is_fixed_link(struct device_node *np)
+{
+	struct device_node *dn;
+	int len;
+
+	/* New binding */
+	dn = of_get_child_by_name(np, "fixed-link");
+	if (dn) {
+		of_node_put(dn);
+		return true;
+	}
+
+	/* Old binding */
+	if (of_get_property(np, "fixed-link", &len) &&
+	    len == (5 * sizeof(__be32)))
+		return true;
+
+	return false;
+}
+EXPORT_SYMBOL(of_phy_is_fixed_link);
+
+int of_phy_register_fixed_link(struct device_node *np)
+{
+	struct fixed_phy_status status = {};
+	struct device_node *fixed_link_node;
+	const __be32 *fixed_link_prop;
+	int len;
+
+	/* New binding */
+	fixed_link_node = of_get_child_by_name(np, "fixed-link");
+	if (fixed_link_node) {
+		status.link = 1;
+		status.duplex = of_property_read_bool(np, "full-duplex");
+		if (of_property_read_u32(fixed_link_node, "speed", &status.speed))
+			return -EINVAL;
+		status.pause = of_property_read_bool(np, "pause");
+		status.asym_pause = of_property_read_bool(np, "asym-pause");
+		of_node_put(fixed_link_node);
+		return fixed_phy_register(PHY_POLL, &status, np);
+	}
+
+	/* Old binding */
+	fixed_link_prop = of_get_property(np, "fixed-link", &len);
+	if (fixed_link_prop && len == (5 * sizeof(__be32))) {
+		status.link = 1;
+		status.duplex = be32_to_cpu(fixed_link_prop[1]);
+		status.speed = be32_to_cpu(fixed_link_prop[2]);
+		status.pause = be32_to_cpu(fixed_link_prop[3]);
+		status.asym_pause = be32_to_cpu(fixed_link_prop[4]);
+		return fixed_phy_register(PHY_POLL, &status, np);
+	}
+
+	return -ENODEV;
+}
+EXPORT_SYMBOL(of_phy_register_fixed_link);
+#endif

commit 3c6f5592203e8126b70717f040c6c59f953068b3
Author: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
Date:   Wed Mar 19 16:15:24 2014 -0600

    of_mdio: Allow the DT to specify the phy ID and avoid autoprobing
    
    This makes the generic of_mdiobus_register parse the DT compatible string for
    the pattern ethernet-phy-idAAAA.BBBB. If present it should be a value that
    matches the phy-id register normally readable through MDIO.
    
    When the ID is given the phy autoprobing is defeated and the phy is
    created directly.
    
    This is necessary to support phy's that cannot be autoprobed when
    of_mdiobus_register is called. Specifically, my case has the phy in reset at
    of_mdiobus_register, the reset is only released once the ethernet driver
    starts, before it attaches to the phy.
    
    Tested on ARM Kirkwood with phy id 0x01410e90 (Marvell 88E1318)
    
    Signed-off-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 5b3c24f3cde5..9a95831bd065 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -43,6 +43,23 @@ static void of_set_phy_supported(struct phy_device *phydev, u32 max_speed)
 	}
 }
 
+/* Extract the clause 22 phy ID from the compatible string of the form
+ * ethernet-phy-idAAAA.BBBB */
+static int of_get_phy_id(struct device_node *device, u32 *phy_id)
+{
+	struct property *prop;
+	const char *cp;
+	unsigned int upper, lower;
+
+	of_property_for_each_string(device, "compatible", prop, cp) {
+		if (sscanf(cp, "ethernet-phy-id%4x.%4x", &upper, &lower) == 2) {
+			*phy_id = ((upper & 0xFFFF) << 16) | (lower & 0xFFFF);
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+
 static int of_mdiobus_register_phy(struct mii_bus *mdio, struct device_node *child,
 				   u32 addr)
 {
@@ -50,11 +67,15 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio, struct device_node *chi
 	bool is_c45;
 	int rc;
 	u32 max_speed = 0;
+	u32 phy_id;
 
 	is_c45 = of_device_is_compatible(child,
 					 "ethernet-phy-ieee802.3-c45");
 
-	phy = get_phy_device(mdio, addr, is_c45);
+	if (!is_c45 && !of_get_phy_id(child, &phy_id))
+		phy = phy_device_create(mdio, addr, phy_id, 0, NULL);
+	else
+		phy = get_phy_device(mdio, addr, is_c45);
 	if (!phy || IS_ERR(phy))
 		return 1;
 

commit f15c586d1d9d99b04712d2b2eeee31ab29db77ff
Author: Ben Dooks <ben.dooks@codethink.co.uk>
Date:   Tue Feb 18 12:16:58 2014 +0000

    of_mdio: fix phy interrupt passing
    
    The of_mdiobus_register_phy() is not setting phy->irq thus causing
    some drivers to incorrectly assume that the PHY does not have an
    IRQ associated with it. Not only do some drivers report no IRQ
    they do not install an interrupt handler for the PHY.
    
    Simplify the code setting irq and set the phy->irq at the same
    time so that we cover the following issues, which should cover
    all the cases the code will find:
    
    - Set phy->irq if node has irq property and mdio->irq is NULL
    - Set phy->irq if node has no irq and mdio->irq is not NULL
    - Leave phy->irq as PHY_POLL default if none of the above
    
    This fixes the issue:
     net eth0: attached PHY 1 (IRQ -1) to driver Micrel KSZ8041RNLI
    
    to the correct:
     net eth0: attached PHY 1 (IRQ 416) to driver Micrel KSZ8041RNLI
    
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 495faccba763..5b3c24f3cde5 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -48,7 +48,7 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio, struct device_node *chi
 {
 	struct phy_device *phy;
 	bool is_c45;
-	int rc, prev_irq;
+	int rc;
 	u32 max_speed = 0;
 
 	is_c45 = of_device_is_compatible(child,
@@ -58,12 +58,14 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio, struct device_node *chi
 	if (!phy || IS_ERR(phy))
 		return 1;
 
-	if (mdio->irq) {
-		prev_irq = mdio->irq[addr];
-		mdio->irq[addr] =
-			irq_of_parse_and_map(child, 0);
-		if (!mdio->irq[addr])
-			mdio->irq[addr] = prev_irq;
+	rc = irq_of_parse_and_map(child, 0);
+	if (rc > 0) {
+		phy->irq = rc;
+		if (mdio->irq)
+			mdio->irq[addr] = rc;
+	} else {
+		if (mdio->irq)
+			phy->irq = mdio->irq[addr];
 	}
 
 	/* Associate the OF node with the device structure so it

commit ce11c436720cdb8437340be93b2f5efe23ce3e1c
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Thu Feb 13 13:14:48 2014 -0800

    net: of_mdio: fix of_set_phy_supported after driver probing
    
    Commit 8fdade4 ("net: of_mdio: parse "max-speed" property to set PHY
    supported features") introduced a typo in of_set_phy_supported for the
    first assignment of phydev->supported which will not effectively limit
    the PHY device supported features bits if the PHY driver contains
    "higher" features (e.g: max-speed = <100> and PHY driver has
    PHY_GBIT_FEATURES set).
    
    Fix this by making sure that the very first thing is to reset to sane
    defaults (PHY_BASIC_FEATURES) and then progressively add speed features
    as we parse them.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 875b7b6f0d2a..495faccba763 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -24,7 +24,11 @@ MODULE_LICENSE("GPL");
 
 static void of_set_phy_supported(struct phy_device *phydev, u32 max_speed)
 {
-	phydev->supported |= PHY_DEFAULT_FEATURES;
+	/* The default values for phydev->supported are provided by the PHY
+	 * driver "features" member, we want to reset to sane defaults fist
+	 * before supporting higher speeds.
+	 */
+	phydev->supported &= PHY_DEFAULT_FEATURES;
 
 	switch (max_speed) {
 	default:

commit 7614aba6a330a6c4937edc24fd4c6a935c1ae703
Author: Andy Fleming <afleming@gmail.com>
Date:   Fri Jan 10 14:28:11 2014 +0800

    phylib: Add of_phy_attach
    
    10G PHYs don't currently support running the state machine, which
    is implicitly setup via of_phy_connect(). Therefore, it is necessary
    to implement an OF version of phy_attach(), which does everything
    except start the state machine.
    
    Signed-off-by: Andy Fleming <afleming@gmail.com>
    Signed-off-by: Shaohui Xie <Shaohui.Xie@freescale.com>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index a43b8523c61e..875b7b6f0d2a 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -254,3 +254,23 @@ struct phy_device *of_phy_connect_fixed_link(struct net_device *dev,
 	return IS_ERR(phy) ? NULL : phy;
 }
 EXPORT_SYMBOL(of_phy_connect_fixed_link);
+
+/**
+ * of_phy_attach - Attach to a PHY without starting the state machine
+ * @dev: pointer to net_device claiming the phy
+ * @phy_np: Node pointer for the PHY
+ * @flags: flags to pass to the PHY
+ * @iface: PHY data interface type
+ */
+struct phy_device *of_phy_attach(struct net_device *dev,
+				 struct device_node *phy_np, u32 flags,
+				 phy_interface_t iface)
+{
+	struct phy_device *phy = of_phy_find_device(phy_np);
+
+	if (!phy)
+		return NULL;
+
+	return phy_attach_direct(dev, phy, flags, iface) ? NULL : phy;
+}
+EXPORT_SYMBOL(of_phy_attach);

commit 8fdade4be755af17a3d205d07f594f939f173504
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Thu Dec 5 14:52:14 2013 -0800

    net: of_mdio: parse "max-speed" property to set PHY supported features
    
    The "max-speed" property is defined per the ePAPR specification to
    express the maximum speed a PHY supports. Use that property, if present
    to set the phydev->supported features which properly restricts the PHY
    within the range of defined speeds.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 14feffc36964..a43b8523c61e 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -22,12 +22,30 @@
 MODULE_AUTHOR("Grant Likely <grant.likely@secretlab.ca>");
 MODULE_LICENSE("GPL");
 
+static void of_set_phy_supported(struct phy_device *phydev, u32 max_speed)
+{
+	phydev->supported |= PHY_DEFAULT_FEATURES;
+
+	switch (max_speed) {
+	default:
+		return;
+
+	case SPEED_1000:
+		phydev->supported |= PHY_1000BT_FEATURES;
+	case SPEED_100:
+		phydev->supported |= PHY_100BT_FEATURES;
+	case SPEED_10:
+		phydev->supported |= PHY_10BT_FEATURES;
+	}
+}
+
 static int of_mdiobus_register_phy(struct mii_bus *mdio, struct device_node *child,
 				   u32 addr)
 {
 	struct phy_device *phy;
 	bool is_c45;
 	int rc, prev_irq;
+	u32 max_speed = 0;
 
 	is_c45 = of_device_is_compatible(child,
 					 "ethernet-phy-ieee802.3-c45");
@@ -58,8 +76,13 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio, struct device_node *chi
 		return 1;
 	}
 
+	/* Set phydev->supported based on the "max-speed" property
+	 * if present */
+	if (!of_property_read_u32(child, "max-speed", &max_speed))
+		of_set_phy_supported(phy, max_speed);
+
 	dev_dbg(&mdio->dev, "registered phy %s at address %i\n",
-		 child->name, addr);
+		child->name, addr);
 
 	return 0;
 }

commit 7d976376560b72e187c96e4b18d059e0a0f9eba5
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Thu Dec 5 14:52:12 2013 -0800

    net: of_mdio: do not overwrite PHY interrupt configuration
    
    If irq_of_parse_and_map fails to find an interrupt line for a given PHY,
    we will force the PHY interrupt to be PHY_POLL, completely overriding
    the previous value that the MDIO bus may have set for us (e.g:
    PHY_IGNORE_INTERRUPT). In case of failure, just restore the previous
    value.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index f93ebca0fcb7..14feffc36964 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -27,7 +27,7 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio, struct device_node *chi
 {
 	struct phy_device *phy;
 	bool is_c45;
-	int rc;
+	int rc, prev_irq;
 
 	is_c45 = of_device_is_compatible(child,
 					 "ethernet-phy-ieee802.3-c45");
@@ -37,10 +37,11 @@ static int of_mdiobus_register_phy(struct mii_bus *mdio, struct device_node *chi
 		return 1;
 
 	if (mdio->irq) {
+		prev_irq = mdio->irq[addr];
 		mdio->irq[addr] =
 			irq_of_parse_and_map(child, 0);
 		if (!mdio->irq[addr])
-			mdio->irq[addr] = PHY_POLL;
+			mdio->irq[addr] = prev_irq;
 	}
 
 	/* Associate the OF node with the device structure so it

commit bed2f9ed2f3c4debe2e930c44ee95af980db7e20
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Thu Dec 5 14:52:11 2013 -0800

    net: of_mdio: use PHY_MAX_ADDR constant
    
    Use the PHY_MAX_ADDR constant for checking if a MDIO bus address is
    valid instead of using a plain "32".
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 82485d2dac89..f93ebca0fcb7 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -107,7 +107,7 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 		}
 
 		addr = be32_to_cpup(paddr);
-		if (addr >= 32) {
+		if (addr >= PHY_MAX_ADDR) {
 			dev_err(&mdio->dev, "%s PHY address %i is too large\n",
 				child->full_name, addr);
 			continue;

commit 2e79cb303010d5d2b7810c11bc5d1f09a8500405
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Thu Dec 5 14:52:10 2013 -0800

    net: of_mdio: factor PHY registration from of_mdiobus_register
    
    Since commit 779d835e ("net: of_mdio: scan mdiobus for PHYs without reg
    property") we have two foreach loops which do pretty much the same
    thing. Factor the PHY device registration in a function helper:
    of_mdiobus_register_phy() which takes care of the details and allows for
    future PHY specific extensions.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index d5a57a9e329c..82485d2dac89 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -22,6 +22,47 @@
 MODULE_AUTHOR("Grant Likely <grant.likely@secretlab.ca>");
 MODULE_LICENSE("GPL");
 
+static int of_mdiobus_register_phy(struct mii_bus *mdio, struct device_node *child,
+				   u32 addr)
+{
+	struct phy_device *phy;
+	bool is_c45;
+	int rc;
+
+	is_c45 = of_device_is_compatible(child,
+					 "ethernet-phy-ieee802.3-c45");
+
+	phy = get_phy_device(mdio, addr, is_c45);
+	if (!phy || IS_ERR(phy))
+		return 1;
+
+	if (mdio->irq) {
+		mdio->irq[addr] =
+			irq_of_parse_and_map(child, 0);
+		if (!mdio->irq[addr])
+			mdio->irq[addr] = PHY_POLL;
+	}
+
+	/* Associate the OF node with the device structure so it
+	 * can be looked up later */
+	of_node_get(child);
+	phy->dev.of_node = child;
+
+	/* All data is now stored in the phy struct;
+	 * register it */
+	rc = phy_device_register(phy);
+	if (rc) {
+		phy_device_free(phy);
+		of_node_put(child);
+		return 1;
+	}
+
+	dev_dbg(&mdio->dev, "registered phy %s at address %i\n",
+		 child->name, addr);
+
+	return 0;
+}
+
 /**
  * of_mdiobus_register - Register mii_bus and create PHYs from the device tree
  * @mdio: pointer to mii_bus structure
@@ -32,11 +73,10 @@ MODULE_LICENSE("GPL");
  */
 int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 {
-	struct phy_device *phy;
 	struct device_node *child;
 	const __be32 *paddr;
 	u32 addr;
-	bool is_c45, scanphys = false;
+	bool scanphys = false;
 	int rc, i, len;
 
 	/* Mask out all PHYs from auto probing.  Instead the PHYs listed in
@@ -73,38 +113,9 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 			continue;
 		}
 
-		if (mdio->irq) {
-			mdio->irq[addr] = irq_of_parse_and_map(child, 0);
-			if (!mdio->irq[addr])
-				mdio->irq[addr] = PHY_POLL;
-		}
-
-		is_c45 = of_device_is_compatible(child,
-						 "ethernet-phy-ieee802.3-c45");
-		phy = get_phy_device(mdio, addr, is_c45);
-
-		if (!phy || IS_ERR(phy)) {
-			dev_err(&mdio->dev,
-				"cannot get PHY at address %i\n",
-				addr);
-			continue;
-		}
-
-		/* Associate the OF node with the device structure so it
-		 * can be looked up later */
-		of_node_get(child);
-		phy->dev.of_node = child;
-
-		/* All data is now stored in the phy struct; register it */
-		rc = phy_device_register(phy);
-		if (rc) {
-			phy_device_free(phy);
-			of_node_put(child);
+		rc = of_mdiobus_register_phy(mdio, child, addr);
+		if (rc)
 			continue;
-		}
-
-		dev_dbg(&mdio->dev, "registered phy %s at address %i\n",
-			child->name, addr);
 	}
 
 	if (!scanphys)
@@ -117,9 +128,6 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 		if (paddr)
 			continue;
 
-		is_c45 = of_device_is_compatible(child,
-						 "ethernet-phy-ieee802.3-c45");
-
 		for (addr = 0; addr < PHY_MAX_ADDR; addr++) {
 			/* skip already registered PHYs */
 			if (mdio->phy_map[addr])
@@ -129,34 +137,9 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 			dev_info(&mdio->dev, "scan phy %s at address %i\n",
 				 child->name, addr);
 
-			phy = get_phy_device(mdio, addr, is_c45);
-			if (!phy || IS_ERR(phy))
+			rc = of_mdiobus_register_phy(mdio, child, addr);
+			if (rc)
 				continue;
-
-			if (mdio->irq) {
-				mdio->irq[addr] =
-					irq_of_parse_and_map(child, 0);
-				if (!mdio->irq[addr])
-					mdio->irq[addr] = PHY_POLL;
-			}
-
-			/* Associate the OF node with the device structure so it
-			 * can be looked up later */
-			of_node_get(child);
-			phy->dev.of_node = child;
-
-			/* All data is now stored in the phy struct;
-			 * register it */
-			rc = phy_device_register(phy);
-			if (rc) {
-				phy_device_free(phy);
-				of_node_put(child);
-				continue;
-			}
-
-			dev_info(&mdio->dev, "registered phy %s at address %i\n",
-				 child->name, addr);
-			break;
 		}
 	}
 

commit 058112c7efc9ef43bb511c137293dddbe6e42908
Author: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
Date:   Mon May 6 23:49:31 2013 +0000

    net: of_mdio: fix behavior on missing phy device
    
    of_mdiobus_register creates a phy_device even if get_phy_device failed
    to create it previously. This causes indefinite polling on non-existent
    PHYs. This fix makes of_mdio_register rely on get_phy_device to
    properly create the device or fail otherwise.
    
    Signed-off-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 23049aeca662..d5a57a9e329c 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -84,13 +84,10 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 		phy = get_phy_device(mdio, addr, is_c45);
 
 		if (!phy || IS_ERR(phy)) {
-			phy = phy_device_create(mdio, addr, 0, false, NULL);
-			if (!phy || IS_ERR(phy)) {
-				dev_err(&mdio->dev,
-					"error creating PHY at address %i\n",
-					addr);
-				continue;
-			}
+			dev_err(&mdio->dev,
+				"cannot get PHY at address %i\n",
+				addr);
+			continue;
 		}
 
 		/* Associate the OF node with the device structure so it

commit 779d835e7eee114f9bfdf7401d1efcf2d53baccf
Author: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
Date:   Sun Apr 7 01:09:48 2013 +0000

    net: of_mdio: scan mdiobus for PHYs without reg property
    
    Using DT for mdiobus and ethernet-phy requires to know the PHY address, which
    is hard to guess if you don't know it. This patch extends of_mdiobus_register
    to scan mdiobus for PHYs if reg property of the corresponding node is not set.
    This also allows to have phy nodes in SoC DT files where the reg property can
    be overwritten in the board file later. To encourage people to finally set the
    actual phy address, the mdiobus scan is noisier than required.
    
    Signed-off-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index e3a8b22ef9dd..23049aeca662 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -34,7 +34,10 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 {
 	struct phy_device *phy;
 	struct device_node *child;
-	int rc, i;
+	const __be32 *paddr;
+	u32 addr;
+	bool is_c45, scanphys = false;
+	int rc, i, len;
 
 	/* Mask out all PHYs from auto probing.  Instead the PHYs listed in
 	 * the device tree are populated after the bus has been registered */
@@ -54,14 +57,10 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 
 	/* Loop over the child nodes and register a phy_device for each one */
 	for_each_available_child_of_node(np, child) {
-		const __be32 *paddr;
-		u32 addr;
-		int len;
-		bool is_c45;
-
 		/* A PHY must have a reg property in the range [0-31] */
 		paddr = of_get_property(child, "reg", &len);
 		if (!paddr || len < sizeof(*paddr)) {
+			scanphys = true;
 			dev_err(&mdio->dev, "%s has invalid PHY address\n",
 				child->full_name);
 			continue;
@@ -111,6 +110,59 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 			child->name, addr);
 	}
 
+	if (!scanphys)
+		return 0;
+
+	/* auto scan for PHYs with empty reg property */
+	for_each_available_child_of_node(np, child) {
+		/* Skip PHYs with reg property set */
+		paddr = of_get_property(child, "reg", &len);
+		if (paddr)
+			continue;
+
+		is_c45 = of_device_is_compatible(child,
+						 "ethernet-phy-ieee802.3-c45");
+
+		for (addr = 0; addr < PHY_MAX_ADDR; addr++) {
+			/* skip already registered PHYs */
+			if (mdio->phy_map[addr])
+				continue;
+
+			/* be noisy to encourage people to set reg property */
+			dev_info(&mdio->dev, "scan phy %s at address %i\n",
+				 child->name, addr);
+
+			phy = get_phy_device(mdio, addr, is_c45);
+			if (!phy || IS_ERR(phy))
+				continue;
+
+			if (mdio->irq) {
+				mdio->irq[addr] =
+					irq_of_parse_and_map(child, 0);
+				if (!mdio->irq[addr])
+					mdio->irq[addr] = PHY_POLL;
+			}
+
+			/* Associate the OF node with the device structure so it
+			 * can be looked up later */
+			of_node_get(child);
+			phy->dev.of_node = child;
+
+			/* All data is now stored in the phy struct;
+			 * register it */
+			rc = phy_device_register(phy);
+			if (rc) {
+				phy_device_free(phy);
+				of_node_put(child);
+				continue;
+			}
+
+			dev_info(&mdio->dev, "registered phy %s at address %i\n",
+				 child->name, addr);
+			break;
+		}
+	}
+
 	return 0;
 }
 EXPORT_SYMBOL(of_mdiobus_register);

commit f9a8f83b04e0c362a2fc660dbad980d24af209fc
Author: Florian Fainelli <florian@openwrt.org>
Date:   Mon Jan 14 00:52:52 2013 +0000

    net: phy: remove flags argument from phy_{attach, connect, connect_direct}
    
    The flags argument of the phy_{attach,connect,connect_direct} functions
    is then used to assign a struct phy_device dev_flags with its value.
    All callers but the tg3 driver pass the flag 0, which results in the
    underlying PHY drivers in drivers/net/phy/ not being able to actually
    use any of the flags they would set in dev_flags. This patch gets rid of
    the flags argument, and passes phydev->dev_flags to the internal PHY
    library call phy_attach_direct() such that drivers which actually modify
    a phy device dev_flags get the value preserved for use by the underlying
    phy driver.
    
    Acked-by: Kosta Zertsekel <konszert@marvell.com>
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 83ca06f4312b..e3a8b22ef9dd 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -157,7 +157,7 @@ struct phy_device *of_phy_connect(struct net_device *dev,
 	if (!phy)
 		return NULL;
 
-	return phy_connect_direct(dev, phy, hndlr, flags, iface) ? NULL : phy;
+	return phy_connect_direct(dev, phy, hndlr, iface) ? NULL : phy;
 }
 EXPORT_SYMBOL(of_phy_connect);
 
@@ -194,7 +194,7 @@ struct phy_device *of_phy_connect_fixed_link(struct net_device *dev,
 
 	sprintf(bus_id, PHY_ID_FMT, "fixed-0", be32_to_cpu(phy_id[0]));
 
-	phy = phy_connect(dev, bus_id, hndlr, 0, iface);
+	phy = phy_connect(dev, bus_id, hndlr, iface);
 	return IS_ERR(phy) ? NULL : phy;
 }
 EXPORT_SYMBOL(of_phy_connect_fixed_link);

commit e207e7619cc9be8dedd910d9c6ce3ee56c7f53d0
Author: Alexander Sverdlin <alexander.sverdlin@sysgo.com>
Date:   Thu Nov 29 08:45:20 2012 +0100

    of_mdio: Honour "status=disabled" property of device
    
    Currently of_mdiobus_register() function registers all PHY devices,
    independetly from their status property in device tree. According to
    "ePAPR 1.1" spec, device should only be registered if there is no
    "status" property, or it has "ok" (or "okay") value (see
    of_device_is_available()). In case of "platform devices",
    of_platform_device_create_pdata() checks for "status" and ensures
    that disabled devices are not pupulated. But such check for MDIO buses
    was missing until now. Fix it.
    
    Signed-off-by: Alexander Sverdlin <alexander.sverdlin@sysgo.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 8e6c25f35040..83ca06f4312b 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -53,7 +53,7 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 		return rc;
 
 	/* Loop over the child nodes and register a phy_device for each one */
-	for_each_child_of_node(np, child) {
+	for_each_available_child_of_node(np, child) {
 		const __be32 *paddr;
 		u32 addr;
 		int len;

commit 6bd47ac2e434611e52027155438d7b4ad3c76bdb
Author: David Daney <david.daney@cavium.com>
Date:   Wed Jun 27 07:33:36 2012 +0000

    netdev/phy/of: Handle IEEE802.3 clause 45 Ethernet PHYs in of_mdiobus_register()
    
    Define two new "compatible" values for Ethernet
    PHYs. "ethernet-phy-ieee802.3-c22" and "ethernet-phy-ieee802.3-c45"
    are used to indicate a PHY uses the corresponding protocol.
    
    If a PHY is "compatible" with "ethernet-phy-ieee802.3-c45", we
    indicate this so that get_phy_device() can properly probe the device.
    
    If get_phy_device() fails, it was probably due to failing the probe of
    the PHY identifier registers.  Since we have the device tree telling
    us the PHY exists, go ahead and add it anyhow with a phy_id of zero.
    There may be a driver match based on the "compatible" property.
    
    Signed-off-by: David Daney <david.daney@cavium.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 6c24cad322df..8e6c25f35040 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -57,6 +57,7 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 		const __be32 *paddr;
 		u32 addr;
 		int len;
+		bool is_c45;
 
 		/* A PHY must have a reg property in the range [0-31] */
 		paddr = of_get_property(child, "reg", &len);
@@ -79,11 +80,18 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 				mdio->irq[addr] = PHY_POLL;
 		}
 
-		phy = get_phy_device(mdio, addr, false);
+		is_c45 = of_device_is_compatible(child,
+						 "ethernet-phy-ieee802.3-c45");
+		phy = get_phy_device(mdio, addr, is_c45);
+
 		if (!phy || IS_ERR(phy)) {
-			dev_err(&mdio->dev, "error probing PHY at address %i\n",
-				addr);
-			continue;
+			phy = phy_device_create(mdio, addr, 0, false, NULL);
+			if (!phy || IS_ERR(phy)) {
+				dev_err(&mdio->dev,
+					"error creating PHY at address %i\n",
+					addr);
+				continue;
+			}
 		}
 
 		/* Associate the OF node with the device structure so it

commit ac28b9f8cd66d6bc54f8063df59e99abd62173a4
Author: David Daney <david.daney@cavium.com>
Date:   Wed Jun 27 07:33:35 2012 +0000

    netdev/phy: Handle IEEE802.3 clause 45 Ethernet PHYs
    
    The IEEE802.3 clause 45 MDIO bus protocol allows for directly
    addressing PHY registers using a 21 bit address, and is used by many
    10G Ethernet PHYS.  Already existing is the ability of MDIO bus
    drivers to use clause 45, with the MII_ADDR_C45 flag.  Here we add
    struct phy_c45_device_ids to hold the device identifier registers
    present in clause 45. struct phy_device gets a couple of new fields:
    c45_ids to hold the identifiers and is_c45 to signal that it is clause
    45.
    
    get_phy_device() gets a new parameter is_c45 to indicate that the PHY
    device should use the clause 45 protocol, and its callers are adjusted
    to pass false.  The follow-on patch to of_mdio.c will pass true where
    appropriate.
    
    EXPORT phy_device_create() so that the follow-on patch to of_mdio.c
    can use it to create phy devices for PHYs, that have non-standard
    device identifier registers, based on the device tree bindings.
    
    Signed-off-by: David Daney <david.daney@cavium.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 2574abde8d99..6c24cad322df 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -79,7 +79,7 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 				mdio->irq[addr] = PHY_POLL;
 		}
 
-		phy = get_phy_device(mdio, addr);
+		phy = get_phy_device(mdio, addr, false);
 		if (!phy || IS_ERR(phy)) {
 			dev_err(&mdio->dev, "error probing PHY at address %i\n",
 				addr);

commit 251060220021283eef3652145a41f5b26db97ce5
Author: David Daney <david.daney@cavium.com>
Date:   Wed May 2 15:16:37 2012 +0000

    netdev/of/phy: New function: of_mdio_find_bus().
    
    Add of_mdio_find_bus() which allows an mii_bus to be located given its
    associated the device tree node.
    
    This is needed by the follow-on patch to add a driver for MDIO bus
    multiplexers.
    
    The of_mdiobus_register() function is modified so that the device tree
    node is recorded in the mii_bus.  Then we can find it again by
    iterating over all mdio_bus_class devices.
    
    Because the OF device tree has now become an integral part of the
    kernel, this can live in mdio_bus.c (which contains the needed
    mdio_bus_class structure) instead of of_mdio.c.
    
    Signed-off-by: David Daney <david.daney@cavium.com>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 483c0adcad87..2574abde8d99 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -45,6 +45,8 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 		for (i=0; i<PHY_MAX_ADDR; i++)
 			mdio->irq[i] = PHY_POLL;
 
+	mdio->dev.of_node = np;
+
 	/* Register the MDIO bus */
 	rc = mdiobus_register(mdio);
 	if (rc)

commit e5c7d1f669806289e121b9ac3535e8f6de594b8e
Author: Baruch Siach <baruch@tkos.co.il>
Date:   Mon Feb 27 14:48:46 2012 +0200

    of/mdio: fix fixed link bus name
    
    Since 9e6c643b (phy/fixed: use an unique MDIO bus name) the name of the fixed
    PHY bus is "fixed-0". Teach of_phy_connect_fixed_link() the new name.
    
    Tested on a P1020RDB PowerPC system.
    
    Signed-off-by: Baruch Siach <baruch@tkos.co.il>
    Acked-by: Florian Fainelli <florian@openwrt.org>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 980c079e4443..483c0adcad87 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -182,7 +182,7 @@ struct phy_device *of_phy_connect_fixed_link(struct net_device *dev,
 	if (!phy_id || sz < sizeof(*phy_id))
 		return NULL;
 
-	sprintf(bus_id, PHY_ID_FMT, "0", be32_to_cpu(phy_id[0]));
+	sprintf(bus_id, PHY_ID_FMT, "fixed-0", be32_to_cpu(phy_id[0]));
 
 	phy = phy_connect(dev, bus_id, hndlr, 0, iface);
 	return IS_ERR(phy) ? NULL : phy;

commit ae97159aed6eff68f4ac86472b018985f071fed5
Author: Kyle Moffett <Kyle.D.Moffett@boeing.com>
Date:   Thu Oct 20 17:00:09 2011 -0400

    of_mdio: Don't phy_scan_fixups() twice
    
    The "phy_device_register()" call 5 lines down already calls
    phy_scan_fixups(), there's no need to do it a second time.
    
    Signed-off-by: Kyle Moffett <Kyle.D.Moffett@boeing.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index d35e300b0ad1..980c079e4443 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -83,7 +83,6 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 				addr);
 			continue;
 		}
-		phy_scan_fixups(phy);
 
 		/* Associate the OF node with the device structure so it
 		 * can be looked up later */

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index dcd7857784f2..d35e300b0ad1 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -136,7 +136,7 @@ EXPORT_SYMBOL(of_phy_find_device);
  * @hndlr: Link state callback for the network device
  * @iface: PHY data interface type
  *
- * Returns a pointer to the phy_device if successfull.  NULL otherwise
+ * Returns a pointer to the phy_device if successful.  NULL otherwise
  */
 struct phy_device *of_phy_connect(struct net_device *dev,
 				  struct device_node *phy_np,

commit 194588604765ac803f98fb9d19a36f6b835f4620
Author: David Daney <ddaney@caviumnetworks.com>
Date:   Wed Oct 27 18:03:47 2010 -0700

    of/mdio: Fix some endianness problems.
    
    In of_mdiobus_register(), the __be32 *addr variable is dereferenced.
    This will not work on little-endian targets.  Also since it is
    unsigned, checking for less than zero is redundant.
    
    Fix these two issues.
    
    Signed-off-by: David Daney <ddaney@caviumnetworks.com>
    [grant.likely@secretlab.ca: removed goto]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 1fce00eb421b..dcd7857784f2 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -52,27 +52,35 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 
 	/* Loop over the child nodes and register a phy_device for each one */
 	for_each_child_of_node(np, child) {
-		const __be32 *addr;
+		const __be32 *paddr;
+		u32 addr;
 		int len;
 
 		/* A PHY must have a reg property in the range [0-31] */
-		addr = of_get_property(child, "reg", &len);
-		if (!addr || len < sizeof(*addr) || *addr >= 32 || *addr < 0) {
+		paddr = of_get_property(child, "reg", &len);
+		if (!paddr || len < sizeof(*paddr)) {
 			dev_err(&mdio->dev, "%s has invalid PHY address\n",
 				child->full_name);
 			continue;
 		}
 
+		addr = be32_to_cpup(paddr);
+		if (addr >= 32) {
+			dev_err(&mdio->dev, "%s PHY address %i is too large\n",
+				child->full_name, addr);
+			continue;
+		}
+
 		if (mdio->irq) {
-			mdio->irq[*addr] = irq_of_parse_and_map(child, 0);
-			if (!mdio->irq[*addr])
-				mdio->irq[*addr] = PHY_POLL;
+			mdio->irq[addr] = irq_of_parse_and_map(child, 0);
+			if (!mdio->irq[addr])
+				mdio->irq[addr] = PHY_POLL;
 		}
 
-		phy = get_phy_device(mdio, be32_to_cpup(addr));
+		phy = get_phy_device(mdio, addr);
 		if (!phy || IS_ERR(phy)) {
 			dev_err(&mdio->dev, "error probing PHY at address %i\n",
-				*addr);
+				addr);
 			continue;
 		}
 		phy_scan_fixups(phy);
@@ -91,7 +99,7 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 		}
 
 		dev_dbg(&mdio->dev, "registered phy %s at address %i\n",
-			child->name, *addr);
+			child->name, addr);
 	}
 
 	return 0;

commit e3873444990dd6f8a095d1f72b5ad45192f8c506
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Jun 18 11:09:59 2010 -0600

    of/irq: Move irq_of_parse_and_map() to common code
    
    Merge common code between PowerPC and Microblaze.  SPARC implements
    irq_of_parse_and_map(), but the implementation is different, so it
    does not use this code.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Jeremy Kerr <jeremy.kerr@canonical.com>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 42a6715f8e84..1fce00eb421b 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -15,6 +15,7 @@
 #include <linux/err.h>
 #include <linux/phy.h>
 #include <linux/of.h>
+#include <linux/of_irq.h>
 #include <linux/of_mdio.h>
 #include <linux/module.h>
 

commit cf9b59e9d3e008591d1f54830f570982bb307a0d
Merge: 44504b2bebf8 f4b87dee9233
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Sat May 22 00:36:56 2010 -0600

    Merge remote branch 'origin' into secretlab/next-devicetree
    
    Merging in current state of Linus' tree to deal with merge conflicts and
    build failures in vio.c after merge.
    
    Conflicts:
            drivers/i2c/busses/i2c-cpm.c
            drivers/i2c/busses/i2c-mpc.c
            drivers/net/gianfar.c
    
    Also fixed up one line in arch/powerpc/kernel/vio.c to use the
    correct node pointer.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

commit 58f9b0b02414062eaff46716bc04b47d7e79add5
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Apr 13 16:12:56 2010 -0700

    of: eliminate of_device->node and dev_archdata->{of,prom}_node
    
    This patch eliminates the node pointer from struct of_device and the
    of_node (or prom_node) pointer from struct dev_archdata since the node
    pointer is now part of struct device proper when CONFIG_OF is set, and
    all users of the old pointer locations have already been converted over
    to use device->of_node.
    
    Also remove dev_archdata_{get,set}_node() as it is no longer used by
    anything.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 01d794abe105..794fbc2ef73d 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -79,7 +79,6 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 		/* Associate the OF node with the device structure so it
 		 * can be looked up later */
 		of_node_get(child);
-		dev_archdata_set_node(&phy->dev.archdata, child);
 		phy->dev.of_node = child;
 
 		/* All data is now stored in the phy struct; register it */

commit 61c7a080a5a061c976988fd4b844dfb468dda255
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Apr 13 16:12:29 2010 -0700

    of: Always use 'struct device.of_node' to get device node pointer.
    
    The following structure elements duplicate the information in
    'struct device.of_node' and so are being eliminated.  This patch
    makes all readers of these elements use device.of_node instead.
    
    (struct of_device *)->node
    (struct dev_archdata *)->prom_node (sparc)
    (struct dev_archdata *)->of_node (powerpc & microblaze)
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 12090f57dc87..01d794abe105 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -101,7 +101,7 @@ EXPORT_SYMBOL(of_mdiobus_register);
 /* Helper function for of_phy_find_device */
 static int of_phy_match(struct device *dev, void *phy_np)
 {
-	return dev_archdata_get_node(&dev->archdata) == phy_np;
+	return dev->of_node == phy_np;
 }
 
 /**
@@ -167,7 +167,7 @@ struct phy_device *of_phy_connect_fixed_link(struct net_device *dev,
 	if (!dev->dev.parent)
 		return NULL;
 
-	net_np = dev_archdata_get_node(&dev->dev.parent->archdata);
+	net_np = dev->dev.parent->of_node;
 	if (!net_np)
 		return NULL;
 

commit d706c1b050274b3bf97d7cb0542c0d070c9ccb8b
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Apr 13 16:12:28 2010 -0700

    driver-core: Add device node pointer to struct device
    
    Currently, platforms using CONFIG_OF add a 'struct device_node *of_node'
    to dev->archdata.  However, with CONFIG_OF becoming generic for all
    architectures, it makes sense for commonality to move it out of archdata
    and into struct device proper.
    
    This patch adds a struct device_node *of_node member to struct device
    and updates all locations which currently write the device_node pointer
    into archdata to also update dev->of_node.  Subsequent patches will
    modify callers to use the archdata location and ultimately remove
    the archdata member entirely.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    CC: Michal Simek <monstr@monstr.eu>
    CC: Greg Kroah-Hartman <gregkh@suse.de>
    CC: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    CC: "David S. Miller" <davem@davemloft.net>
    CC: Stephen Rothwell <sfr@canb.auug.org.au>
    CC: Jeremy Kerr <jeremy.kerr@canonical.com>
    CC: microblaze-uclinux@itee.uq.edu.au
    CC: linux-kernel@vger.kernel.org
    CC: linuxppc-dev@ozlabs.org
    CC: sparclinux@vger.kernel.org

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 18ecae4a4375..12090f57dc87 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -80,6 +80,7 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 		 * can be looked up later */
 		of_node_get(child);
 		dev_archdata_set_node(&phy->dev.archdata, child);
+		phy->dev.of_node = child;
 
 		/* All data is now stored in the phy struct; register it */
 		rc = phy_device_register(phy);

commit 9bd73715a1f83f640937c121d22fa8dbaab73002
Author: Dan Carpenter <error27@gmail.com>
Date:   Wed Apr 28 01:07:29 2010 -0600

    of: check for IS_ERR()
    
    get_phy_device() can return an ERR_PTR()
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 18ecae4a4375..b4748337223b 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -69,7 +69,7 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 		}
 
 		phy = get_phy_device(mdio, be32_to_cpup(addr));
-		if (!phy) {
+		if (!phy || IS_ERR(phy)) {
 			dev_err(&mdio->dev, "error probing PHY at address %i\n",
 				*addr);
 			continue;

commit 337148812f97368a8ec4a69f1691e4c5ce3af494
Author: Jeremy Kerr <jeremy.kerr@canonical.com>
Date:   Sat Jan 30 01:45:26 2010 -0700

    of: assume big-endian properties, adding conversions where necessary
    
    Properties in the device tree are specified as big-endian. At present,
    the only platforms to support device trees are also big-endian, so we've
    been acessing the properties as raw values.
    
    We'd like to add device tree support to little-endian platforms too, so
    add endian conversion to the sites where we access property values in
    the common of code.
    
    Compiled on powerpc (ppc44x_defconfig & ppc64_defconfig) and arm (fdt
    support only for now).
    
    Signed-off-by: Jeremy Kerr <jeremy.kerr@canonical.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 4b22ba568b19..18ecae4a4375 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -51,7 +51,7 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 
 	/* Loop over the child nodes and register a phy_device for each one */
 	for_each_child_of_node(np, child) {
-		const u32 *addr;
+		const __be32 *addr;
 		int len;
 
 		/* A PHY must have a reg property in the range [0-31] */
@@ -68,7 +68,7 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 				mdio->irq[*addr] = PHY_POLL;
 		}
 
-		phy = get_phy_device(mdio, *addr);
+		phy = get_phy_device(mdio, be32_to_cpup(addr));
 		if (!phy) {
 			dev_err(&mdio->dev, "error probing PHY at address %i\n",
 				*addr);
@@ -160,7 +160,7 @@ struct phy_device *of_phy_connect_fixed_link(struct net_device *dev,
 	struct device_node *net_np;
 	char bus_id[MII_BUS_ID_SIZE + 3];
 	struct phy_device *phy;
-	const u32 *phy_id;
+	const __be32 *phy_id;
 	int sz;
 
 	if (!dev->dev.parent)
@@ -174,7 +174,7 @@ struct phy_device *of_phy_connect_fixed_link(struct net_device *dev,
 	if (!phy_id || sz < sizeof(*phy_id))
 		return NULL;
 
-	sprintf(bus_id, PHY_ID_FMT, "0", phy_id[0]);
+	sprintf(bus_id, PHY_ID_FMT, "0", be32_to_cpu(phy_id[0]));
 
 	phy = phy_connect(dev, bus_id, hndlr, 0, iface);
 	return IS_ERR(phy) ? NULL : phy;

commit 08a7963aad03b5cf515f1e9c35e0ac9eb7dae072
Author: Jérôme Pouiller <jezz@sysmic.org>
Date:   Thu Oct 15 09:58:27 2009 -0600

    of: Remove nested function
    
    Some toolchains dislike nested function definition, so we define function match
    outside of of_phy_find_device.
    
    Signed-off-by: Jérôme Pouiller <jezz@sysmic.org>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index bacaa536fd51..4b22ba568b19 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -97,6 +97,12 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 }
 EXPORT_SYMBOL(of_mdiobus_register);
 
+/* Helper function for of_phy_find_device */
+static int of_phy_match(struct device *dev, void *phy_np)
+{
+	return dev_archdata_get_node(&dev->archdata) == phy_np;
+}
+
 /**
  * of_phy_find_device - Give a PHY node, find the phy_device
  * @phy_np: Pointer to the phy's device tree node
@@ -106,15 +112,10 @@ EXPORT_SYMBOL(of_mdiobus_register);
 struct phy_device *of_phy_find_device(struct device_node *phy_np)
 {
 	struct device *d;
-	int match(struct device *dev, void *phy_np)
-	{
-		return dev_archdata_get_node(&dev->archdata) == phy_np;
-	}
-
 	if (!phy_np)
 		return NULL;
 
-	d = bus_find_device(&mdio_bus_type, NULL, phy_np, match);
+	d = bus_find_device(&mdio_bus_type, NULL, phy_np, of_phy_match);
 	return d ? to_phy_device(d) : NULL;
 }
 EXPORT_SYMBOL(of_phy_find_device);

commit 24c30dbbcdda9aeccb23b4eecb6bb8e538742ea4
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Thu Jul 16 21:31:31 2009 +0000

    of/mdio: Add support function for Ethernet fixed-link property
    
    Fixed-link support is broken for the ucc_eth, gianfar, and fs_enet
    device drivers.  The "OF MDIO rework" patches removed most of the
    support. Instead of re-adding fixed-link stuff to the drivers, this
    patch adds a support function for parsing the fixed-link property
    and obtaining a dummy phy to match.
    
    Note: the dummy phy handling in arch/powerpc is a bit of a hack and
    needs to be reworked.  This function is being added now to solve the
    regression in the Ethernet drivers, but it should be considered a
    temporary measure until the fixed link handling can be reworked.
    
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index aee967d7f760..bacaa536fd51 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -9,6 +9,10 @@
  * out of the OpenFirmware device tree and using it to populate an mii_bus.
  */
 
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/netdevice.h>
+#include <linux/err.h>
 #include <linux/phy.h>
 #include <linux/of.h>
 #include <linux/of_mdio.h>
@@ -137,3 +141,41 @@ struct phy_device *of_phy_connect(struct net_device *dev,
 	return phy_connect_direct(dev, phy, hndlr, flags, iface) ? NULL : phy;
 }
 EXPORT_SYMBOL(of_phy_connect);
+
+/**
+ * of_phy_connect_fixed_link - Parse fixed-link property and return a dummy phy
+ * @dev: pointer to net_device claiming the phy
+ * @hndlr: Link state callback for the network device
+ * @iface: PHY data interface type
+ *
+ * This function is a temporary stop-gap and will be removed soon.  It is
+ * only to support the fs_enet, ucc_geth and gianfar Ethernet drivers.  Do
+ * not call this function from new drivers.
+ */
+struct phy_device *of_phy_connect_fixed_link(struct net_device *dev,
+					     void (*hndlr)(struct net_device *),
+					     phy_interface_t iface)
+{
+	struct device_node *net_np;
+	char bus_id[MII_BUS_ID_SIZE + 3];
+	struct phy_device *phy;
+	const u32 *phy_id;
+	int sz;
+
+	if (!dev->dev.parent)
+		return NULL;
+
+	net_np = dev_archdata_get_node(&dev->dev.parent->archdata);
+	if (!net_np)
+		return NULL;
+
+	phy_id = of_get_property(net_np, "fixed-link", &sz);
+	if (!phy_id || sz < sizeof(*phy_id))
+		return NULL;
+
+	sprintf(bus_id, PHY_ID_FMT, "0", phy_id[0]);
+
+	phy = phy_connect(dev, bus_id, hndlr, 0, iface);
+	return IS_ERR(phy) ? NULL : phy;
+}
+EXPORT_SYMBOL(of_phy_connect_fixed_link);

commit 8bc487d150b939e69830c39322df4ee486efe381
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Sat Apr 25 12:52:56 2009 +0000

    openfirmware: Add OF phylib support code
    
    Add support for parsing the device tree for PHY devices on an MDIO bus.
    Currently many of the PowerPC ethernet drivers are open coding a solution
    for reading data out of the device tree to find the correct PHY device.
    This patch implements a set of common routines to:
    
    a) let MDIO bus drivers register phy_devices described in the tree, and
    b) let MAC drivers find the correct phy_device via the tree.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Andy Fleming <afleming@freescale.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
new file mode 100644
index 000000000000..aee967d7f760
--- /dev/null
+++ b/drivers/of/of_mdio.c
@@ -0,0 +1,139 @@
+/*
+ * OF helpers for the MDIO (Ethernet PHY) API
+ *
+ * Copyright (c) 2009 Secret Lab Technologies, Ltd.
+ *
+ * This file is released under the GPLv2
+ *
+ * This file provides helper functions for extracting PHY device information
+ * out of the OpenFirmware device tree and using it to populate an mii_bus.
+ */
+
+#include <linux/phy.h>
+#include <linux/of.h>
+#include <linux/of_mdio.h>
+#include <linux/module.h>
+
+MODULE_AUTHOR("Grant Likely <grant.likely@secretlab.ca>");
+MODULE_LICENSE("GPL");
+
+/**
+ * of_mdiobus_register - Register mii_bus and create PHYs from the device tree
+ * @mdio: pointer to mii_bus structure
+ * @np: pointer to device_node of MDIO bus.
+ *
+ * This function registers the mii_bus structure and registers a phy_device
+ * for each child node of @np.
+ */
+int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
+{
+	struct phy_device *phy;
+	struct device_node *child;
+	int rc, i;
+
+	/* Mask out all PHYs from auto probing.  Instead the PHYs listed in
+	 * the device tree are populated after the bus has been registered */
+	mdio->phy_mask = ~0;
+
+	/* Clear all the IRQ properties */
+	if (mdio->irq)
+		for (i=0; i<PHY_MAX_ADDR; i++)
+			mdio->irq[i] = PHY_POLL;
+
+	/* Register the MDIO bus */
+	rc = mdiobus_register(mdio);
+	if (rc)
+		return rc;
+
+	/* Loop over the child nodes and register a phy_device for each one */
+	for_each_child_of_node(np, child) {
+		const u32 *addr;
+		int len;
+
+		/* A PHY must have a reg property in the range [0-31] */
+		addr = of_get_property(child, "reg", &len);
+		if (!addr || len < sizeof(*addr) || *addr >= 32 || *addr < 0) {
+			dev_err(&mdio->dev, "%s has invalid PHY address\n",
+				child->full_name);
+			continue;
+		}
+
+		if (mdio->irq) {
+			mdio->irq[*addr] = irq_of_parse_and_map(child, 0);
+			if (!mdio->irq[*addr])
+				mdio->irq[*addr] = PHY_POLL;
+		}
+
+		phy = get_phy_device(mdio, *addr);
+		if (!phy) {
+			dev_err(&mdio->dev, "error probing PHY at address %i\n",
+				*addr);
+			continue;
+		}
+		phy_scan_fixups(phy);
+
+		/* Associate the OF node with the device structure so it
+		 * can be looked up later */
+		of_node_get(child);
+		dev_archdata_set_node(&phy->dev.archdata, child);
+
+		/* All data is now stored in the phy struct; register it */
+		rc = phy_device_register(phy);
+		if (rc) {
+			phy_device_free(phy);
+			of_node_put(child);
+			continue;
+		}
+
+		dev_dbg(&mdio->dev, "registered phy %s at address %i\n",
+			child->name, *addr);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(of_mdiobus_register);
+
+/**
+ * of_phy_find_device - Give a PHY node, find the phy_device
+ * @phy_np: Pointer to the phy's device tree node
+ *
+ * Returns a pointer to the phy_device.
+ */
+struct phy_device *of_phy_find_device(struct device_node *phy_np)
+{
+	struct device *d;
+	int match(struct device *dev, void *phy_np)
+	{
+		return dev_archdata_get_node(&dev->archdata) == phy_np;
+	}
+
+	if (!phy_np)
+		return NULL;
+
+	d = bus_find_device(&mdio_bus_type, NULL, phy_np, match);
+	return d ? to_phy_device(d) : NULL;
+}
+EXPORT_SYMBOL(of_phy_find_device);
+
+/**
+ * of_phy_connect - Connect to the phy described in the device tree
+ * @dev: pointer to net_device claiming the phy
+ * @phy_np: Pointer to device tree node for the PHY
+ * @hndlr: Link state callback for the network device
+ * @iface: PHY data interface type
+ *
+ * Returns a pointer to the phy_device if successfull.  NULL otherwise
+ */
+struct phy_device *of_phy_connect(struct net_device *dev,
+				  struct device_node *phy_np,
+				  void (*hndlr)(struct net_device *), u32 flags,
+				  phy_interface_t iface)
+{
+	struct phy_device *phy = of_phy_find_device(phy_np);
+
+	if (!phy)
+		return NULL;
+
+	return phy_connect_direct(dev, phy, hndlr, flags, iface) ? NULL : phy;
+}
+EXPORT_SYMBOL(of_phy_connect);
