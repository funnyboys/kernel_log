commit 83f82d7a42583e93d0f0dde3d61ed10f75c0f4d8
Author: Lubomir Rintel <lkundrak@v3.sk>
Date:   Wed Aug 7 15:22:31 2019 +0200

    of: irq: fix a trivial typo in a doc comment
    
    Diverged from what the code does with commit 530210c7814e ("of/irq: Replace
    of_irq with of_phandle_args").
    
    Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 7f84bb4903ca..a296eaf52a5b 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -277,7 +277,7 @@ EXPORT_SYMBOL_GPL(of_irq_parse_raw);
  * of_irq_parse_one - Resolve an interrupt for a device
  * @device: the device whose interrupt is to be resolved
  * @index: index of the interrupt to resolve
- * @out_irq: structure of_irq filled by this function
+ * @out_irq: structure of_phandle_args filled by this function
  *
  * This function resolves an interrupt for a node by walking the interrupt tree,
  * finding which interrupt controller node it is attached to, and returning the

commit 6f7dc9a37f2b325fc870d1e1ada6169185f8852c
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu May 2 14:40:15 2019 +0200

    of: irq: Remove WARN_ON() for kzalloc() failure
    
    There is no need to print a backtrace if kzalloc() fails, as the memory
    allocation core already takes care of that.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index e1f6f392a4c0..7f84bb4903ca 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -500,7 +500,7 @@ void __init of_irq_init(const struct of_device_id *matches)
 		 * pointer, interrupt-parent device_node etc.
 		 */
 		desc = kzalloc(sizeof(*desc), GFP_KERNEL);
-		if (WARN_ON(!desc)) {
+		if (!desc) {
 			of_node_put(np);
 			goto err;
 		}

commit 2a6db719c92dbfe43c9eea7e4358ea2e51b5004e
Author: Nipun Gupta <nipun.gupta@nxp.com>
Date:   Mon Sep 10 19:19:16 2018 +0530

    iommu/of: make of_pci_map_rid() available for other devices too
    
    iommu-map property is also used by devices with fsl-mc. This
    patch moves the of_pci_map_rid to generic location, so that it
    can be used by other busses too.
    
    'of_pci_map_rid' is renamed here to 'of_map_rid' and there is no
    functional change done in the API.
    
    Signed-off-by: Nipun Gupta <nipun.gupta@nxp.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Reviewed-by: Robin Murphy <robin.murphy@arm.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 02ad93a304a4..e1f6f392a4c0 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -22,7 +22,6 @@
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_irq.h>
-#include <linux/of_pci.h>
 #include <linux/string.h>
 #include <linux/slab.h>
 
@@ -588,8 +587,8 @@ static u32 __of_msi_map_rid(struct device *dev, struct device_node **np,
 	 * "msi-map" property.
 	 */
 	for (parent_dev = dev; parent_dev; parent_dev = parent_dev->parent)
-		if (!of_pci_map_rid(parent_dev->of_node, rid_in, "msi-map",
-				    "msi-map-mask", np, &rid_out))
+		if (!of_map_rid(parent_dev->of_node, rid_in, "msi-map",
+				"msi-map-mask", np, &rid_out))
 			break;
 	return rid_out;
 }

commit af6074fc9aa4b29517375634189ada1869eea598
Author: Rob Herring <robh@kernel.org>
Date:   Wed Dec 27 12:55:14 2017 -0600

    of: Use SPDX license tag for DT files
    
    Convert remaining DT files to use SPDX-License-Identifier tags.
    
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    Reviewed-by: Frank Rowand <frank.rowand@sony.com>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 7dcea86e052c..02ad93a304a4 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  *  Derived from arch/i386/kernel/irq.c
  *    Copyright (C) 1992 Linus Torvalds
@@ -8,11 +9,6 @@
  *  Adapted for Power Macintosh by Paul Mackerras
  *    Copyright (C) 1996 Paul Mackerras (paulus@cs.anu.edu.au)
  *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
  * This file contains the code used to make IRQ descriptions in the
  * device tree to actual irq numbers on an interrupt controller
  * driver.

commit fae3b9cd70bd0f6f80df1843cb243f7ac4d8b4c3
Author: Vasyl Gomonovych <gomonovych@gmail.com>
Date:   Wed Dec 6 23:43:34 2017 +0100

    of: irq: Fix function description comment
    
    Make small cleanup in function description for
    of_irq_parse_raw
    
    Signed-off-by: Vasyl Gomonovych <gomonovych@gmail.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index ec00ae7384c2..7dcea86e052c 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -83,9 +83,8 @@ EXPORT_SYMBOL_GPL(of_irq_find_parent);
 
 /**
  * of_irq_parse_raw - Low level interrupt tree parsing
- * @parent:	the device interrupt parent
  * @addr:	address specifier (start of "reg" property of the device) in be32 format
- * @out_irq:	structure of_irq updated by this function
+ * @out_irq:	structure of_phandle_args updated by this function
  *
  * Returns 0 on success and a negative number on error
  *

commit 74fee4e88fd196c712abfdae89acfa272abf10f8
Merge: 7d955656121f 84024468cf16
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 7 14:43:33 2017 -0700

    Merge tag 'devicetree-for-4.14' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull DeviceTree updates from Rob Herring:
     "There's a few orphans in the conversion to %pOF printf specifiers
      included here that no one else picked up.
    
      Summary:
    
       - Convert more DT code to use of_property_read_* API.
    
       - Improve DT overlay support when adding multiple overlays
    
       - Convert printk's to %pOF format specifiers. Most went via subsystem
         trees, but picked up the remaining orphans
    
       - Correct unittests to use preferred "okay" for "status" property
         value
    
       - Add a KASLR seed property
    
       - Vendor prefixes for Mellanox, Theobroma System, Adaptrum, Moxa
    
       - Fix modalias buffer handling
    
       - Clean-up of include paths for building dtbs
    
       - Add bindings for amc6821, isl1208, tsl2x7x, srf02, and srf10
         devices
    
       - Add nvmem bindings for MediaTek MT7623 and MT7622 SoC
    
       - Add compatible string for Allwinner H5 Mali-450 GPU
    
       - Fix links to old OpenFirmware docs with new mirror on
         devicetree.org
    
       - Remove status property from binding doc examples"
    
    * tag 'devicetree-for-4.14' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (45 commits)
      devicetree: Adjust status "ok" -> "okay" under drivers/of/
      dt-bindings: Remove "status" from examples
      dt-bindings: pinctrl: sh-pfc: Use generic node name
      dt-bindings: Add vendor Mellanox
      dt-binding: net/phy: fix interrupts description
      virt: Convert to using %pOF instead of full_name
      macintosh: Convert to using %pOF instead of full_name
      ide: pmac: Convert to using %pOF instead of full_name
      microblaze: Convert to using %pOF instead of full_name
      dt-bindings: usb: musb: Grammar s/the/to/, s/is/are/
      of: Use PLATFORM_DEVID_NONE definition
      of/device: Fix of_device_get_modalias() buffer handling
      of/device: Prevent buffer overflow in of_device_modalias()
      dt-bindings: add amc6821, isl1208 trivial bindings
      dt-bindings: add vendor prefix for Theobroma Systems
      of: search scripts/dtc/include-prefixes path for both CPP and DTC
      of: remove arch/$(SRCARCH)/boot/dts from include search path for CPP
      of: remove drivers/of/testcase-data from include search path for CPP
      of: return of_get_cpu_node from of_cpu_device_node_get if CPUs are not registered
      iio: srf08: add device tree binding for srf02 and srf10
      ...

commit b47fe22d82e39551a5049f4bd02eb71f7d497762
Author: Rob Herring <robh@kernel.org>
Date:   Fri Jul 21 16:56:12 2017 -0500

    of/irq: use of_property_read_u32_index to parse interrupts property
    
    Convert the interrupts property parsing to use the OF property API
    instead of open coding the parsing of the raw property value. This saves
    a number of LoC, and the result is easier to read.
    
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index abbd252fe25b..aa2a60c8868e 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -292,8 +292,8 @@ EXPORT_SYMBOL_GPL(of_irq_parse_raw);
 int of_irq_parse_one(struct device_node *device, int index, struct of_phandle_args *out_irq)
 {
 	struct device_node *p;
-	const __be32 *intspec, *addr;
-	u32 intsize, intlen;
+	const __be32 *addr;
+	u32 intsize;
 	int i, res;
 
 	pr_debug("of_irq_parse_one: dev=%pOF, index=%d\n", device, index);
@@ -311,15 +311,6 @@ int of_irq_parse_one(struct device_node *device, int index, struct of_phandle_ar
 	if (!res)
 		return of_irq_parse_raw(addr, out_irq);
 
-	/* Get the interrupts property */
-	intspec = of_get_property(device, "interrupts", &intlen);
-	if (intspec == NULL)
-		return -EINVAL;
-
-	intlen /= sizeof(*intspec);
-
-	pr_debug(" intspec=%d intlen=%d\n", be32_to_cpup(intspec), intlen);
-
 	/* Look for the interrupt parent. */
 	p = of_irq_find_parent(device);
 	if (p == NULL)
@@ -331,20 +322,21 @@ int of_irq_parse_one(struct device_node *device, int index, struct of_phandle_ar
 		goto out;
 	}
 
-	pr_debug(" intsize=%d intlen=%d\n", intsize, intlen);
-
-	/* Check index */
-	if ((index + 1) * intsize > intlen) {
-		res = -EINVAL;
-		goto out;
-	}
+	pr_debug(" parent=%pOF, intsize=%d\n", p, intsize);
 
 	/* Copy intspec into irq structure */
-	intspec += index * intsize;
 	out_irq->np = p;
 	out_irq->args_count = intsize;
-	for (i = 0; i < intsize; i++)
-		out_irq->args[i] = be32_to_cpup(intspec++);
+	for (i = 0; i < intsize; i++) {
+		res = of_property_read_u32_index(device, "interrupts",
+						 (index * intsize) + i,
+						 out_irq->args + i);
+		if (res)
+			goto out;
+	}
+
+	pr_debug(" intspec=%d\n", *out_irq->args);
+
 
 	/* Check if there are any interrupt-map translations to process */
 	res = of_irq_parse_raw(addr, out_irq);

commit 531da74075a7805768ce3cd323e37e3548cbf6c5
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Fri Jul 21 20:30:39 2017 +0300

    of: irq: fix of_irq_to_resource() error check
    
    of_irq_to_resource() has recently been fixed to return negative error #'s
    along with 0, however of_irq_to_resource_table() still only regards 0 as
    invalid IRQ -- fix it up.
    
    Fixes: 7a4228bbff76 ("of: irq: use of_irq_get() in of_irq_to_resource()")
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 6ce72aa65425..ab21c846eb27 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -476,7 +476,7 @@ int of_irq_to_resource_table(struct device_node *dev, struct resource *res,
 	int i;
 
 	for (i = 0; i < nr_irqs; i++, res++)
-		if (!of_irq_to_resource(dev, i, res))
+		if (of_irq_to_resource(dev, i, res) <= 0)
 			break;
 
 	return i;

commit fa976ff7b00c31af2b9069751cd55140d8aa30b4
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Sat Jul 8 23:29:52 2017 +0300

    of: irq: use of_property_read_u32()
    
    The DT interrupt parsing code predates of_property_read_u32(), so it has to
    basically open-code it. Using the modern DT API saves several LoCs and also
    adds some prop sanity checks as a bonus...
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 1f6ef2305daa..abbd252fe25b 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -59,20 +59,19 @@ EXPORT_SYMBOL_GPL(irq_of_parse_and_map);
 struct device_node *of_irq_find_parent(struct device_node *child)
 {
 	struct device_node *p;
-	const __be32 *parp;
+	phandle parent;
 
 	if (!of_node_get(child))
 		return NULL;
 
 	do {
-		parp = of_get_property(child, "interrupt-parent", NULL);
-		if (parp == NULL)
+		if (of_property_read_u32(child, "interrupt-parent", &parent)) {
 			p = of_get_parent(child);
-		else {
+		} else	{
 			if (of_irq_workarounds & OF_IMAP_NO_PHANDLE)
 				p = of_node_get(of_irq_dflt_pic);
 			else
-				p = of_find_node_by_phandle(be32_to_cpup(parp));
+				p = of_find_node_by_phandle(parent);
 		}
 		of_node_put(child);
 		child = p;
@@ -117,11 +116,8 @@ int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
 	 * is none, we are nice and just walk up the tree
 	 */
 	do {
-		tmp = of_get_property(ipar, "#interrupt-cells", NULL);
-		if (tmp != NULL) {
-			intsize = be32_to_cpu(*tmp);
+		if (!of_property_read_u32(ipar, "#interrupt-cells", &intsize))
 			break;
-		}
 		tnode = ipar;
 		ipar = of_irq_find_parent(ipar);
 		of_node_put(tnode);
@@ -228,14 +224,14 @@ int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
 			/* Get #interrupt-cells and #address-cells of new
 			 * parent
 			 */
-			tmp = of_get_property(newpar, "#interrupt-cells", NULL);
-			if (tmp == NULL) {
+			if (of_property_read_u32(newpar, "#interrupt-cells",
+						 &newintsize)) {
 				pr_debug(" -> parent lacks #interrupt-cells!\n");
 				goto fail;
 			}
-			newintsize = be32_to_cpu(*tmp);
-			tmp = of_get_property(newpar, "#address-cells", NULL);
-			newaddrsize = (tmp == NULL) ? 0 : be32_to_cpu(*tmp);
+			if (of_property_read_u32(newpar, "#address-cells",
+						 &newaddrsize))
+				newaddrsize = 0;
 
 			pr_debug(" -> newintsize=%d, newaddrsize=%d\n",
 			    newintsize, newaddrsize);
@@ -296,7 +292,7 @@ EXPORT_SYMBOL_GPL(of_irq_parse_raw);
 int of_irq_parse_one(struct device_node *device, int index, struct of_phandle_args *out_irq)
 {
 	struct device_node *p;
-	const __be32 *intspec, *tmp, *addr;
+	const __be32 *intspec, *addr;
 	u32 intsize, intlen;
 	int i, res;
 
@@ -330,12 +326,10 @@ int of_irq_parse_one(struct device_node *device, int index, struct of_phandle_ar
 		return -EINVAL;
 
 	/* Get size of interrupt specifier */
-	tmp = of_get_property(p, "#interrupt-cells", NULL);
-	if (tmp == NULL) {
+	if (of_property_read_u32(p, "#interrupt-cells", &intsize)) {
 		res = -EINVAL;
 		goto out;
 	}
-	intsize = be32_to_cpu(*tmp);
 
 	pr_debug(" intsize=%d intlen=%d\n", intsize, intlen);
 

commit 6a245d959c747079e88bb1c61baa61d43d460a44
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Sat Jul 8 23:29:51 2017 +0300

    of: irq: use of_property_read_bool() for "interrupt-controller" prop
    
    The "interrupt-controller" property is boolean, i.e. has no value.  The DT
    interrupt parsing code predates of_property_read_bool(), so it uses either
    of_get_property() or of_find_property() -- the former isn't quite correct
    for the boolean props (but works somehow). Use the modern boolean prop API
    instead.
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 9c4b32522bc2..1f6ef2305daa 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -169,8 +169,7 @@ int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
 		/* Now check if cursor is an interrupt-controller and if it is
 		 * then we are done
 		 */
-		if (of_get_property(ipar, "interrupt-controller", NULL) !=
-				NULL) {
+		if (of_property_read_bool(ipar, "interrupt-controller")) {
 			pr_debug(" -> got it !\n");
 			return 0;
 		}
@@ -508,7 +507,7 @@ void __init of_irq_init(const struct of_device_id *matches)
 	INIT_LIST_HEAD(&intc_parent_list);
 
 	for_each_matching_node_and_match(np, matches, &match) {
-		if (!of_find_property(np, "interrupt-controller", NULL) ||
+		if (!of_property_read_bool(np, "interrupt-controller") ||
 				!of_device_is_available(np))
 			continue;
 

commit 0d638a07d3a1e98a7598eb2812a6236324e4c55f
Author: Rob Herring <robh@kernel.org>
Date:   Thu Jun 1 15:50:55 2017 -0500

    of: Convert to using %pOF instead of full_name
    
    Now that we have a custom printf format specifier, convert users of
    full_name to use %pOF instead. This is preparation to remove storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 6ce72aa65425..9c4b32522bc2 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -131,7 +131,7 @@ int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
 		goto fail;
 	}
 
-	pr_debug("of_irq_parse_raw: ipar=%s, size=%d\n", of_node_full_name(ipar), intsize);
+	pr_debug("of_irq_parse_raw: ipar=%pOF, size=%d\n", ipar, intsize);
 
 	if (out_irq->args_count != intsize)
 		goto fail;
@@ -269,7 +269,7 @@ int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
 	skiplevel:
 		/* Iterate again with new parent */
 		out_irq->np = newpar;
-		pr_debug(" -> new parent: %s\n", of_node_full_name(newpar));
+		pr_debug(" -> new parent: %pOF\n", newpar);
 		of_node_put(ipar);
 		ipar = newpar;
 		newpar = NULL;
@@ -301,7 +301,7 @@ int of_irq_parse_one(struct device_node *device, int index, struct of_phandle_ar
 	u32 intsize, intlen;
 	int i, res;
 
-	pr_debug("of_irq_parse_one: dev=%s, index=%d\n", of_node_full_name(device), index);
+	pr_debug("of_irq_parse_one: dev=%pOF, index=%d\n", device, index);
 
 	/* OldWorld mac stuff is "special", handle out of line */
 	if (of_irq_workarounds & OF_IMAP_OLDWORLD_MAC)
@@ -555,8 +555,8 @@ void __init of_irq_init(const struct of_device_id *matches)
 
 			of_node_set_flag(desc->dev, OF_POPULATED);
 
-			pr_debug("of_irq_init: init %s (%p), parent %p\n",
-				 desc->dev->full_name,
+			pr_debug("of_irq_init: init %pOF (%p), parent %p\n",
+				 desc->dev,
 				 desc->dev, desc->interrupt_parent);
 			ret = desc->irq_init_cb(desc->dev,
 						desc->interrupt_parent);

commit 7a4228bbff769ebf449981a4248616db9f0cffec
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Tue May 16 14:09:04 2017 +0200

    of: irq: use of_irq_get() in of_irq_to_resource()
    
    of_irq_to_resource() currently uses irq_of_parse_and_map() to
    translate a DT interrupt specification into a Linux virtual interrupt
    number. While this works in most cases, irq_of_parse_and_map() doesn't
    properly handle the case where the interrupt controller is not yet
    available (due to deferred probing for example).
    
    So instead, use of_irq_get(), which is implemented exactly like
    irq_of_parse_and_map(), with the exception that if the interrupt
    controller is not yet available, it returns -EPROBE_DEFER. Obviously,
    we also handle this error and bail out from of_irq_to_resource() when
    of_irq_get() returns an error.
    
    This allows to avoid silly error messages at boot time caused by
    irq_create_of_mapping() when the interrupt controller is not
    available:
    
    [    0.153168] irq: no irq domain found for /ap806/config-space@f0000000/interrupt-controller@3f0100 !
    [    0.154041] irq: no irq domain found for /cp110-master/config-space@f2000000/interrupt-controller@1e0000 !
    [    0.154124] irq: no irq domain found for /cp110-master/config-space@f2000000/interrupt-controller@1e0000 !
    [    0.154207] irq: no irq domain found for /cp110-master/config-space@f2000000/interrupt-controller@1e0000 !
    [    0.154437] irq: no irq domain found for /cp110-master/config-space@f2000000/interrupt-controller@1e0000 !
    [    0.154518] irq: no irq domain found for /cp110-master/config-space@f2000000/interrupt-controller@1e0000 !
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index d11437cb1187..6ce72aa65425 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -369,7 +369,10 @@ EXPORT_SYMBOL_GPL(of_irq_parse_one);
  */
 int of_irq_to_resource(struct device_node *dev, int index, struct resource *r)
 {
-	int irq = irq_of_parse_and_map(dev, index);
+	int irq = of_irq_get(dev, index);
+
+	if (irq < 0)
+		return irq;
 
 	/* Only dereference the resource if both the
 	 * resource and the irq are valid. */

commit 17a70355ea576843a7ac851f1db26872a50b2850
Author: Rob Herring <robh@kernel.org>
Date:   Thu May 4 12:56:12 2017 -0500

    of: fix sparse warnings in fdt, irq, reserved mem, and resolver code
    
    sparse generates the following warnings in drivers/of/:
    
    ../drivers/of/fdt.c:63:36: warning: cast to restricted __be32
    ../drivers/of/fdt.c:68:33: warning: cast to restricted __be32
    ../drivers/of/irq.c:105:88: warning: incorrect type in initializer (different base types)
    ../drivers/of/irq.c:105:88:    expected restricted __be32
    ../drivers/of/irq.c:105:88:    got int
    ../drivers/of/irq.c:526:35: warning: incorrect type in assignment (different modifiers)
    ../drivers/of/irq.c:526:35:    expected int ( *const [usertype] irq_init_cb )( ... )
    ../drivers/of/irq.c:526:35:    got void const *const data
    ../drivers/of/of_reserved_mem.c:200:50: warning: incorrect type in initializer (different modifiers)
    ../drivers/of/of_reserved_mem.c:200:50:    expected int ( *[usertype] initfn )( ... )
    ../drivers/of/of_reserved_mem.c:200:50:    got void const *const data
    ../drivers/of/resolver.c:95:42: warning: incorrect type in assignment (different base types)
    ../drivers/of/resolver.c:95:42:    expected unsigned int [unsigned] [usertype] <noident>
    ../drivers/of/resolver.c:95:42:    got restricted __be32 [usertype] <noident>
    
    All these are harmless type mismatches fixed by adjusting the types.
    
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 7c56b72d1dc6..d11437cb1187 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -102,7 +102,7 @@ int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
 	struct device_node *ipar, *tnode, *old = NULL, *newpar = NULL;
 	__be32 initial_match_array[MAX_PHANDLE_ARGS];
 	const __be32 *match_array = initial_match_array;
-	const __be32 *tmp, *imap, *imask, dummy_imask[] = { [0 ... MAX_PHANDLE_ARGS] = ~0 };
+	const __be32 *tmp, *imap, *imask, dummy_imask[] = { [0 ... MAX_PHANDLE_ARGS] = cpu_to_be32(~0) };
 	u32 intsize = 1, addrsize, newintsize = 0, newaddrsize = 0;
 	int imaplen, match, i, rc = -EINVAL;
 

commit f1aa54840657fe822b026ab56b75088e08c92362
Author: Guilherme G. Piccoli <gpiccoli@linux.vnet.ibm.com>
Date:   Mon Dec 5 11:59:16 2016 -0200

    of/irq: improve error report on irq discovery process failure
    
    On PowerPC machines some PCI slots might not have level triggered
    interrupts capability (also know as level signaled interrupts),
    leading of_irq_parse_pci() to complain by presenting error messages
    on the kernel log - in this case, the properties "interrupt-map" and
    "interrupt-map-mask" are not present on device's node in the device
    tree.
    
    This patch introduces a different message for this specific case,
    and also reduces its level from error to warning. Besides, we warn
    (once) that possibly some PCI slots on the system have no level
    triggered interrupts available.
    We changed some error return codes too on function of_irq_parse_raw()
    in order other failure's cases can be presented in a more precise way.
    
    Before this patch, when an adapter was plugged in a slot without level
    interrupts capabilitiy on PowerPC, we saw a generic error message
    like this:
    
        [54.239] pci 002d:70:00.0: of_irq_parse_pci() failed with rc=-22
    
    Now, with this applied, we see the following specific message:
    
        [16.154] pci 0014:60:00.1: of_irq_parse_pci: no interrupt-map found,
        INTx interrupts not available
    
    Finally, we standardize the error path in of_irq_parse_raw() by always
    taking the fail path instead of returning directly from the loop.
    
    Signed-off-by: Guilherme G. Piccoli <gpiccoli@linux.vnet.ibm.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 3fda9a32defb..7c56b72d1dc6 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -104,7 +104,7 @@ int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
 	const __be32 *match_array = initial_match_array;
 	const __be32 *tmp, *imap, *imask, dummy_imask[] = { [0 ... MAX_PHANDLE_ARGS] = ~0 };
 	u32 intsize = 1, addrsize, newintsize = 0, newaddrsize = 0;
-	int imaplen, match, i;
+	int imaplen, match, i, rc = -EINVAL;
 
 #ifdef DEBUG
 	of_print_phandle_args("of_irq_parse_raw: ", out_irq);
@@ -134,7 +134,7 @@ int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
 	pr_debug("of_irq_parse_raw: ipar=%s, size=%d\n", of_node_full_name(ipar), intsize);
 
 	if (out_irq->args_count != intsize)
-		return -EINVAL;
+		goto fail;
 
 	/* Look for this #address-cells. We have to implement the old linux
 	 * trick of looking for the parent here as some device-trees rely on it
@@ -153,8 +153,10 @@ int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
 	pr_debug(" -> addrsize=%d\n", addrsize);
 
 	/* Range check so that the temporary buffer doesn't overflow */
-	if (WARN_ON(addrsize + intsize > MAX_PHANDLE_ARGS))
+	if (WARN_ON(addrsize + intsize > MAX_PHANDLE_ARGS)) {
+		rc = -EFAULT;
 		goto fail;
+	}
 
 	/* Precalculate the match array - this simplifies match loop */
 	for (i = 0; i < addrsize; i++)
@@ -240,10 +242,11 @@ int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
 			    newintsize, newaddrsize);
 
 			/* Check for malformed properties */
-			if (WARN_ON(newaddrsize + newintsize > MAX_PHANDLE_ARGS))
-				goto fail;
-			if (imaplen < (newaddrsize + newintsize))
+			if (WARN_ON(newaddrsize + newintsize > MAX_PHANDLE_ARGS)
+			    || (imaplen < (newaddrsize + newintsize))) {
+				rc = -EFAULT;
 				goto fail;
+			}
 
 			imap += newaddrsize + newintsize;
 			imaplen -= newaddrsize + newintsize;
@@ -271,11 +274,13 @@ int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
 		ipar = newpar;
 		newpar = NULL;
 	}
+	rc = -ENOENT; /* No interrupt-map found */
+
  fail:
 	of_node_put(ipar);
 	of_node_put(newpar);
 
-	return -EINVAL;
+	return rc;
 }
 EXPORT_SYMBOL_GPL(of_irq_parse_raw);
 

commit 5282c181662c4cef4823cc16b4641d147c52144f
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Fri Oct 7 01:25:08 2016 -0400

    of: irq: make of_msi_configure accessible from modules
    
    The of_msi_configure routine is only accessible by the built-in
    kernel drivers. Export this function so that modules can use it
    too.
    
    This function is useful for configuring MSI on child device tree
    nodes on hierarchical objects.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 393fea85eb4e..3fda9a32defb 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -697,3 +697,4 @@ void of_msi_configure(struct device *dev, struct device_node *np)
 	dev_set_msi_domain(dev,
 			   of_msi_get_domain(dev, np, DOMAIN_BUS_PLATFORM_MSI));
 }
+EXPORT_SYMBOL_GPL(of_msi_configure);

commit 987068fcbdb7a085bb11151b91dc6f4c956c4a1b
Author: Robin Murphy <robin.murphy@arm.com>
Date:   Mon Sep 12 17:13:40 2016 +0100

    of/irq: Break out msi-map lookup (again)
    
    The PCI msi-map code is already doing double-duty translating IDs and
    retrieving MSI parents, which unsurprisingly is the same functionality
    we need for the identically-formatted PCI iommu-map property. Drag the
    core parsing routine up yet another layer into the general OF-PCI code,
    and further generalise it for either kind of lookup in either flavour
    of map property.
    
    Acked-by: Rob Herring <robh+dt@kernel.org>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Tested-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index a2e68f740eda..393fea85eb4e 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -26,6 +26,7 @@
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_irq.h>
+#include <linux/of_pci.h>
 #include <linux/string.h>
 #include <linux/slab.h>
 
@@ -592,87 +593,16 @@ static u32 __of_msi_map_rid(struct device *dev, struct device_node **np,
 			    u32 rid_in)
 {
 	struct device *parent_dev;
-	struct device_node *msi_controller_node;
-	struct device_node *msi_np = *np;
-	u32 map_mask, masked_rid, rid_base, msi_base, rid_len, phandle;
-	int msi_map_len;
-	bool matched;
 	u32 rid_out = rid_in;
-	const __be32 *msi_map = NULL;
 
 	/*
 	 * Walk up the device parent links looking for one with a
 	 * "msi-map" property.
 	 */
-	for (parent_dev = dev; parent_dev; parent_dev = parent_dev->parent) {
-		if (!parent_dev->of_node)
-			continue;
-
-		msi_map = of_get_property(parent_dev->of_node,
-					  "msi-map", &msi_map_len);
-		if (!msi_map)
-			continue;
-
-		if (msi_map_len % (4 * sizeof(__be32))) {
-			dev_err(parent_dev, "Error: Bad msi-map length: %d\n",
-				msi_map_len);
-			return rid_out;
-		}
-		/* We have a good parent_dev and msi_map, let's use them. */
-		break;
-	}
-	if (!msi_map)
-		return rid_out;
-
-	/* The default is to select all bits. */
-	map_mask = 0xffffffff;
-
-	/*
-	 * Can be overridden by "msi-map-mask" property.  If
-	 * of_property_read_u32() fails, the default is used.
-	 */
-	of_property_read_u32(parent_dev->of_node, "msi-map-mask", &map_mask);
-
-	masked_rid = map_mask & rid_in;
-	matched = false;
-	while (!matched && msi_map_len >= 4 * sizeof(__be32)) {
-		rid_base = be32_to_cpup(msi_map + 0);
-		phandle = be32_to_cpup(msi_map + 1);
-		msi_base = be32_to_cpup(msi_map + 2);
-		rid_len = be32_to_cpup(msi_map + 3);
-
-		if (rid_base & ~map_mask) {
-			dev_err(parent_dev,
-				"Invalid msi-map translation - msi-map-mask (0x%x) ignores rid-base (0x%x)\n",
-				map_mask, rid_base);
-			return rid_out;
-		}
-
-		msi_controller_node = of_find_node_by_phandle(phandle);
-
-		matched = (masked_rid >= rid_base &&
-			   masked_rid < rid_base + rid_len);
-		if (msi_np)
-			matched &= msi_np == msi_controller_node;
-
-		if (matched && !msi_np) {
-			*np = msi_np = msi_controller_node;
+	for (parent_dev = dev; parent_dev; parent_dev = parent_dev->parent)
+		if (!of_pci_map_rid(parent_dev->of_node, rid_in, "msi-map",
+				    "msi-map-mask", np, &rid_out))
 			break;
-		}
-
-		of_node_put(msi_controller_node);
-		msi_map_len -= 4 * sizeof(__be32);
-		msi_map += 4;
-	}
-	if (!matched)
-		return rid_out;
-
-	rid_out = masked_rid - rid_base + msi_base;
-	dev_dbg(dev,
-		"msi-map at: %s, using mask %08x, rid-base: %08x, msi-base: %08x, length: %08x, rid: %08x -> %08x\n",
-		dev_name(parent_dev), map_mask, rid_base, msi_base,
-		rid_len, rid_in, rid_out);
-
 	return rid_out;
 }
 

commit e55aeb6ba4e8cc3549bff1e75ea1d029324bce21
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Tue Aug 9 16:18:51 2016 +0200

    of/irq: Mark interrupt controllers as populated before initialisation
    
    That way the init callback may clear the flag again, in case of drivers
    split between early irq chip and a normal platform driver.
    
    Fixes: 15cc2ed6dcf9 ("of/irq: Mark initialised interrupt controllers as populated")
    Suggested-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 89a71c6074fc..a2e68f740eda 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -544,12 +544,15 @@ void __init of_irq_init(const struct of_device_id *matches)
 
 			list_del(&desc->list);
 
+			of_node_set_flag(desc->dev, OF_POPULATED);
+
 			pr_debug("of_irq_init: init %s (%p), parent %p\n",
 				 desc->dev->full_name,
 				 desc->dev, desc->interrupt_parent);
 			ret = desc->irq_init_cb(desc->dev,
 						desc->interrupt_parent);
 			if (ret) {
+				of_node_clear_flag(desc->dev, OF_POPULATED);
 				kfree(desc);
 				continue;
 			}
@@ -559,8 +562,6 @@ void __init of_irq_init(const struct of_device_id *matches)
 			 * its children can get processed in a subsequent pass.
 			 */
 			list_add_tail(&desc->list, &intc_parent_list);
-
-			of_node_set_flag(desc->dev, OF_POPULATED);
 		}
 
 		/* Get the next pending parent that might have children */

commit 606ad42aa3b1fe8bb122305bef5aea79a6cef54b
Author: Rob Herring <robh@kernel.org>
Date:   Wed Jun 15 08:32:18 2016 -0500

    of: use pr_fmt prefix for all console printing
    
    Clean-up all the DT printk functions to use common pr_fmt prefix.
    
    Some print statements such as kmalloc errors were redundant, so just
    drop those.
    
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    Reviewed-by: Frank Rowand <frank.rowand@am.sony.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 1b58cd574316..89a71c6074fc 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -18,6 +18,8 @@
  * driver.
  */
 
+#define pr_fmt(fmt)	"OF: " fmt
+
 #include <linux/device.h>
 #include <linux/errno.h>
 #include <linux/list.h>

commit 15cc2ed6dcf91a8658e084be4e140147161819d7
Author: Jon Hunter <jonathanh@nvidia.com>
Date:   Mon Jun 20 14:49:18 2016 +0100

    of/irq: Mark initialised interrupt controllers as populated
    
    For interrupt controllers successfully initialised early via device-tree,
    mark these interrupt controllers as populated so we don't unnecessarily
    create a device and populate any platform data later on in the boot
    sequence when we populate all the various platform devices.
    
    Signed-off-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 6ec743faabe8..1b58cd574316 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -557,6 +557,8 @@ void __init of_irq_init(const struct of_device_id *matches)
 			 * its children can get processed in a subsequent pass.
 			 */
 			list_add_tail(&desc->list, &intc_parent_list);
+
+			of_node_set_flag(desc->dev, OF_POPULATED);
 		}
 
 		/* Get the next pending parent that might have children */

commit 3993546646baf1dab5f5c4f7d9bb58f2046fd1c1
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Sat May 28 23:02:50 2016 +0300

    of: irq: fix of_irq_get[_byname]() kernel-doc
    
    The kernel-doc for the of_irq_get[_byname]()  is clearly inadequate in
    describing the return values -- of_irq_get_byname() is documented better
    than of_irq_get() but it  still doesn't mention that 0 is returned iff
    irq_create_of_mapping() fails (it doesn't return an error code in this
    case). Document all possible return value variants, making the writing
    of the word "IRQ" consistent, while at it...
    
    Fixes: 9ec36cafe43b ("of/irq: do irq resolution in platform_get_irq")
    Fixes: ad69674e73a1 ("of/irq: do irq resolution in platform_get_irq_byname()")
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    CC: stable@vger.kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index e7bfc175b8e1..6ec743faabe8 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -386,13 +386,13 @@ int of_irq_to_resource(struct device_node *dev, int index, struct resource *r)
 EXPORT_SYMBOL_GPL(of_irq_to_resource);
 
 /**
- * of_irq_get - Decode a node's IRQ and return it as a Linux irq number
+ * of_irq_get - Decode a node's IRQ and return it as a Linux IRQ number
  * @dev: pointer to device tree node
- * @index: zero-based index of the irq
- *
- * Returns Linux irq number on success, or -EPROBE_DEFER if the irq domain
- * is not yet created.
+ * @index: zero-based index of the IRQ
  *
+ * Returns Linux IRQ number on success, or 0 on the IRQ mapping failure, or
+ * -EPROBE_DEFER if the IRQ domain is not yet created, or error code in case
+ * of any other failure.
  */
 int of_irq_get(struct device_node *dev, int index)
 {
@@ -413,12 +413,13 @@ int of_irq_get(struct device_node *dev, int index)
 EXPORT_SYMBOL_GPL(of_irq_get);
 
 /**
- * of_irq_get_byname - Decode a node's IRQ and return it as a Linux irq number
+ * of_irq_get_byname - Decode a node's IRQ and return it as a Linux IRQ number
  * @dev: pointer to device tree node
- * @name: irq name
+ * @name: IRQ name
  *
- * Returns Linux irq number on success, or -EPROBE_DEFER if the irq domain
- * is not yet created, or error code in case of any other failure.
+ * Returns Linux IRQ number on success, or 0 on the IRQ mapping failure, or
+ * -EPROBE_DEFER if the IRQ domain is not yet created, or error code in case
+ * of any other failure.
  */
 int of_irq_get_byname(struct device_node *dev, const char *name)
 {

commit 5d589d81acf974d23af98044aac56c6339d659f8
Author: Robin Murphy <robin.murphy@arm.com>
Date:   Tue Feb 9 11:04:45 2016 +0000

    of/irq: Fix msi-map calculation for nonzero rid-base
    
    The existing msi-map code is fine for shifting the entire RID space
    upwards, but attempting finer-grained remapping reveals a bug. It turns
    out that we are mistakenly treating the msi-base part as an offset, not
    as a new base to remap onto, so things get squiffy when rid-base is
    nonzero. Fix this, and at the same time add a sanity check against
    having msi-map-mask clash with a nonzero rid-base, as that's another
    thing one can easily get wrong.
    
    CC: <stable@vger.kernel.org>
    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Tested-by: Stuart Yoder <stuart.yoder@nxp.com>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Acked-by: David Daney <david.daney@cavium.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 7ee21ae305ae..e7bfc175b8e1 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -635,6 +635,13 @@ static u32 __of_msi_map_rid(struct device *dev, struct device_node **np,
 		msi_base = be32_to_cpup(msi_map + 2);
 		rid_len = be32_to_cpup(msi_map + 3);
 
+		if (rid_base & ~map_mask) {
+			dev_err(parent_dev,
+				"Invalid msi-map translation - msi-map-mask (0x%x) ignores rid-base (0x%x)\n",
+				map_mask, rid_base);
+			return rid_out;
+		}
+
 		msi_controller_node = of_find_node_by_phandle(phandle);
 
 		matched = (masked_rid >= rid_base &&
@@ -654,7 +661,7 @@ static u32 __of_msi_map_rid(struct device *dev, struct device_node **np,
 	if (!matched)
 		return rid_out;
 
-	rid_out = masked_rid + msi_base;
+	rid_out = masked_rid - rid_base + msi_base;
 	dev_dbg(dev,
 		"msi-map at: %s, using mask %08x, rid-base: %08x, msi-base: %08x, length: %08x, rid: %08x -> %08x\n",
 		dev_name(parent_dev), map_mask, rid_base, msi_base,

commit 30e4c9ad04a7bec4a04b975ce1ad5541d74e1906
Merge: f25a96eada61 c5b635203032
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jan 31 14:48:58 2016 -0800

    Merge branch 'irq-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull IRQ fixes from Ingo Molnar:
     "Mostly irqchip driver fixes, but also an irq core crash fix and a
      build fix"
    
    * 'irq-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      irqchip/mxs: Add missing set_handle_irq()
      irqchip/atmel-aic: Fix wrong bit operation for IRQ priority
      irqchip/gic-v3-its: Recompute the number of pages on page size change
      base: Export platform_msi_domain_[alloc,free]_irqs
      of: MSI: Simplify irqdomain lookup
      irqdomain: Allow domain lookup with DOMAIN_BUS_WIRED token
      irqchip: Fix dependencies for archs w/o HAS_IOMEM
      irqchip/s3c24xx: Mark init_eint as __maybe_unused
      genirq: Validate action before dereferencing it in handle_irq_event_percpu()

commit 14a0db3cdd114da757197193f66786e63649c91e
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Jan 26 13:52:26 2016 +0000

    of: MSI: Simplify irqdomain lookup
    
    So far, when trying to associate a device with its MSI domain,
    we first lookup the domain using a MSI token, and if this
    doesn't return anything useful, we pick up any domain matching
    the same node.
    
    This logic is broken for two reasons:
    1) Only the generic MSI code (PCI or platform) sets this token
       to PCI/MSI or platform MSI. So we're guaranteed that if there
       is something to be found, we will find it with the first call.
    2) If we have a convoluted situation where:
       - a single node implements both wired and MSI interrupts
       - MSI support for that HW hasn't been compiled in
       we'll end up using the wired domain for MSIs anyway, and things
       break badly.
    
    So let's just remove __of_get_msi_domain, and replace it by a direct
    call to irq_find_matching_host, because that's what we really want.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Rob Herring <robh+dt@kernel.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Link: http://lkml.kernel.org/r/1453816347-32720-3-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 4fa916dffc91..a9ea5525109b 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -680,18 +680,6 @@ u32 of_msi_map_rid(struct device *dev, struct device_node *msi_np, u32 rid_in)
 	return __of_msi_map_rid(dev, &msi_np, rid_in);
 }
 
-static struct irq_domain *__of_get_msi_domain(struct device_node *np,
-					      enum irq_domain_bus_token token)
-{
-	struct irq_domain *d;
-
-	d = irq_find_matching_host(np, token);
-	if (!d)
-		d = irq_find_host(np);
-
-	return d;
-}
-
 /**
  * of_msi_map_get_device_domain - Use msi-map to find the relevant MSI domain
  * @dev: device for which the mapping is to be done.
@@ -707,7 +695,7 @@ struct irq_domain *of_msi_map_get_device_domain(struct device *dev, u32 rid)
 	struct device_node *np = NULL;
 
 	__of_msi_map_rid(dev, &np, rid);
-	return __of_get_msi_domain(np, DOMAIN_BUS_PCI_MSI);
+	return irq_find_matching_host(np, DOMAIN_BUS_PCI_MSI);
 }
 
 /**
@@ -731,7 +719,7 @@ struct irq_domain *of_msi_get_domain(struct device *dev,
 	/* Check for a single msi-parent property */
 	msi_np = of_parse_phandle(np, "msi-parent", 0);
 	if (msi_np && !of_property_read_bool(msi_np, "#msi-cells")) {
-		d = __of_get_msi_domain(msi_np, token);
+		d = irq_find_matching_host(msi_np, token);
 		if (!d)
 			of_node_put(msi_np);
 		return d;
@@ -745,7 +733,7 @@ struct irq_domain *of_msi_get_domain(struct device *dev,
 		while (!of_parse_phandle_with_args(np, "msi-parent",
 						   "#msi-cells",
 						   index, &args)) {
-			d = __of_get_msi_domain(args.np, token);
+			d = irq_find_matching_host(args.np, token);
 			if (d)
 				return d;
 

commit 5339f9d4c2ceccab00b28d65bd5c2b2cd6a3de05
Merge: cf8d7e3850ee 183223770ae8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 14 11:13:28 2016 -0800

    Merge tag 'devicetree-for-4.5' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull DeviceTree updates from Rob Herring:
    
     - Rework and export the changeset API to make it available to users
       other than DT overlays
    
     - ARM secure devices binding
    
     - OCTEON USB binding
    
     - Clean-up of various SRAM binding docs
    
     - Various other binding doc updates
    
    * tag 'devicetree-for-4.5' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (21 commits)
      drivers/of: Export OF changeset functions
      Fix documentation for adp1653 DT
      ARM: psci: Fix indentation in DT bindings
      of/platform: export of_default_bus_match_table
      of/unittest: Show broken behaviour in the platform bus
      of: fix declaration of of_io_request_and_map
      of/address: replace printk(KERN_ERR ...) with pr_err(...)
      of/irq: optimize device node matching loop in of_irq_init()
      dt-bindings: tda998x: Document the required 'port' node.
      net/macb: bindings doc: Merge cdns-emac to macb
      dt-bindings: Misc fix for the ATH79 DDR controllers
      dt-bindings: Misc fix for the ATH79 MISC interrupt controllers
      Documentation: dt: Add bindings for Secure-only devices
      dt-bindings: ARM: add arm,cortex-a72 compatible string
      ASoC: Atmel: ClassD: add GCK's parent clock in DT binding
      DT: add Olimex to vendor prefixes
      Documentation: fsl-quadspi: Add fsl,ls1021-qspi compatible string
      Documentation/devicetree: document OCTEON USB bindings
      usb: misc: usb3503: Describe better how to bind clock to the hub
      dt-bindings: Consolidate SRAM bindings from all vendors
      ...

commit 264041e3796133003f010303629a249f9caa3275
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Nov 24 22:10:26 2015 +0900

    of/irq: optimize device node matching loop in of_irq_init()
    
    Currently, of_irq_init() iterates over interrupt controller nodes
    with for_each_matching_node(), and then gets each init function with
    of_match_node() later.
    
    This routine can be optimized with for_each_matching_node_and_match().
    It allows to get the interrupt controller node and its init function
    at the same time, saving __of_match_node() callings.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 902b89be7217..4c0da87b417c 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -472,6 +472,7 @@ EXPORT_SYMBOL_GPL(of_irq_to_resource_table);
 
 struct of_intc_desc {
 	struct list_head	list;
+	of_irq_init_cb_t	irq_init_cb;
 	struct device_node	*dev;
 	struct device_node	*interrupt_parent;
 };
@@ -485,6 +486,7 @@ struct of_intc_desc {
  */
 void __init of_irq_init(const struct of_device_id *matches)
 {
+	const struct of_device_id *match;
 	struct device_node *np, *parent = NULL;
 	struct of_intc_desc *desc, *temp_desc;
 	struct list_head intc_desc_list, intc_parent_list;
@@ -492,10 +494,15 @@ void __init of_irq_init(const struct of_device_id *matches)
 	INIT_LIST_HEAD(&intc_desc_list);
 	INIT_LIST_HEAD(&intc_parent_list);
 
-	for_each_matching_node(np, matches) {
+	for_each_matching_node_and_match(np, matches, &match) {
 		if (!of_find_property(np, "interrupt-controller", NULL) ||
 				!of_device_is_available(np))
 			continue;
+
+		if (WARN(!match->data, "of_irq_init: no init function for %s\n",
+			 match->compatible))
+			continue;
+
 		/*
 		 * Here, we allocate and populate an of_intc_desc with the node
 		 * pointer, interrupt-parent device_node etc.
@@ -506,6 +513,7 @@ void __init of_irq_init(const struct of_device_id *matches)
 			goto err;
 		}
 
+		desc->irq_init_cb = match->data;
 		desc->dev = of_node_get(np);
 		desc->interrupt_parent = of_irq_find_parent(np);
 		if (desc->interrupt_parent == np)
@@ -525,27 +533,18 @@ void __init of_irq_init(const struct of_device_id *matches)
 		 * The assumption is that NULL parent means a root controller.
 		 */
 		list_for_each_entry_safe(desc, temp_desc, &intc_desc_list, list) {
-			const struct of_device_id *match;
 			int ret;
-			of_irq_init_cb_t irq_init_cb;
 
 			if (desc->interrupt_parent != parent)
 				continue;
 
 			list_del(&desc->list);
-			match = of_match_node(matches, desc->dev);
-			if (WARN(!match->data,
-			    "of_irq_init: no init function for %s\n",
-			    match->compatible)) {
-				kfree(desc);
-				continue;
-			}
 
-			pr_debug("of_irq_init: init %s @ %p, parent %p\n",
-				 match->compatible,
+			pr_debug("of_irq_init: init %s (%p), parent %p\n",
+				 desc->dev->full_name,
 				 desc->dev, desc->interrupt_parent);
-			irq_init_cb = (of_irq_init_cb_t)match->data;
-			ret = irq_init_cb(desc->dev, desc->interrupt_parent);
+			ret = desc->irq_init_cb(desc->dev,
+						desc->interrupt_parent);
 			if (ret) {
 				kfree(desc);
 				continue;

commit 4c3141e09cfa6460bfcd5e90f73e498db654c917
Author: Carlo Caione <carlo@endlessm.com>
Date:   Tue Dec 1 17:24:17 2015 +0100

    of/irq: Export of_irq_find_parent again
    
    of_irq_find_parent was made static since it had no users outside of
    of_irq.c. Export it again since we are going to use it again.
    
    Signed-off-by: Carlo Caione <carlo@endlessm.com>
    [robh: move of_irq_find_parent to correct ifdef section]
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 902b89be7217..4fa916dffc91 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -53,7 +53,7 @@ EXPORT_SYMBOL_GPL(irq_of_parse_and_map);
  * Returns a pointer to the interrupt parent node, or NULL if the interrupt
  * parent could not be determined.
  */
-static struct device_node *of_irq_find_parent(struct device_node *child)
+struct device_node *of_irq_find_parent(struct device_node *child)
 {
 	struct device_node *p;
 	const __be32 *parp;
@@ -77,6 +77,7 @@ static struct device_node *of_irq_find_parent(struct device_node *child)
 
 	return p;
 }
+EXPORT_SYMBOL_GPL(of_irq_find_parent);
 
 /**
  * of_irq_parse_raw - Low level interrupt tree parsing

commit 9bbd4b9f38f56b4ee2c8ff268a1104ff38333e90
Merge: 3e069adabc94 2d799dde8e69
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 6 12:17:09 2015 -0800

    Merge tag 'devicetree-for-4.4' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull DeviceTree updates from Rob Herring:
     "A fairly large (by DT standards) pull request this time with the
      majority being some overdue moving DT binding docs around to
      consolidate similar bindings.
    
       - DT binding doc consolidation moving similar bindings to common
         locations.  The majority of these are display related which were
         scattered in video/, fb/, drm/, gpu/, and panel/ directories.
    
       - Add new config option, CONFIG_OF_ALL_DTBS, to enable building all
         dtbs in the tree for most arches with dts files (except powerpc for
         now).
    
       - OF_IRQ=n fixes for user enabled CONFIG_OF.
    
       - of_node_put ref counting fixes from Julia Lawall.
    
       - Common DT binding for wakeup-source and deprecation of all similar
         bindings.
    
       - DT binding for PXA LCD controller.
    
       - Allow ignoring failed PCI resource translations in order to ignore
         64-bit addresses on non-LPAE 32-bit kernels.
    
       - Support setting the NUMA node from DT instead of only from parent
         device.
    
       - Couple of earlycon DT parsing fixes for address and options"
    
    * tag 'devicetree-for-4.4' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (45 commits)
      MAINTAINERS: update DT binding doc locations
      devicetree: add Sigma Designs vendor prefix
      of: simplify arch_find_n_match_cpu_physical_id() function
      Documentation: arm: Fixed typo in socfpga fpga mgr example
      Documentation: devicetree: fix reference to legacy wakeup properties
      Documentation: devicetree: standardize/consolidate on "wakeup-source" property
      drivers: of: removing assignment of 0 to static variable
      xtensa: enable building of all dtbs
      mips: enable building of all dtbs
      metag: enable building of all dtbs
      metag: use common make variables for dtb builds
      h8300: enable building of all dtbs
      arm64: enable building of all dtbs
      arm: enable building of all dtbs
      arc: enable building of all dtbs
      arc: use common make variables for dtb builds
      of: add config option to enable building of all dtbs
      of/fdt: fix error checking for earlycon address
      of/overlay: add missing of_node_put
      of/platform: add missing of_node_put
      ...

commit 8363ccb917c6bd497392f5a6b716f46213d86495
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Thu Oct 22 11:02:51 2015 +0200

    of/irq: add missing of_node_put
    
    for_each_matching_node performs an of_node_get on each iteration, so
    a break out of the loop requires an of_node_put.
    
    A simplified version of the semantic patch that fixes this problem is as
    follows (http://coccinelle.lip6.fr):
    
    // <smpl>
    @@
    local idexpression n;
    expression e;
    identifier l;
    @@
    
     for_each_matching_node(n,...) {
       ...
    (
       of_node_put(n);
    |
       e = n
    |
    +  of_node_put(n);
    ?  goto l;
    )
       ...
     }
    ...
    l: ... when != n
    // </smpl>
    
    Besides the issue found by the semantic patch, this code also stores the
    device_node value in a list, which requires an of_node_get, and then cleans
    up the list on exit from the function, which requires an of_node_put.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 0c7f4cbe3434..bcc1f4b2211e 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -501,10 +501,12 @@ void __init of_irq_init(const struct of_device_id *matches)
 		 * pointer, interrupt-parent device_node etc.
 		 */
 		desc = kzalloc(sizeof(*desc), GFP_KERNEL);
-		if (WARN_ON(!desc))
+		if (WARN_ON(!desc)) {
+			of_node_put(np);
 			goto err;
+		}
 
-		desc->dev = np;
+		desc->dev = of_node_get(np);
 		desc->interrupt_parent = of_irq_find_parent(np);
 		if (desc->interrupt_parent == np)
 			desc->interrupt_parent = NULL;
@@ -575,6 +577,7 @@ void __init of_irq_init(const struct of_device_id *matches)
 err:
 	list_for_each_entry_safe(desc, temp_desc, &intc_desc_list, list) {
 		list_del(&desc->list);
+		of_node_put(desc->dev);
 		kfree(desc);
 	}
 }

commit 82b9b4243c6d99d9e38087fa89183aa7479185e9
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Fri Oct 2 14:38:55 2015 +0100

    of/irq: Use the msi-map property to provide device-specific MSI domain
    
    While msi-parent is used to point to the MSI controller that
    works for all the devices behind a root complex, it doesn't
    allow configurations where each individual device can be routed
    to a separate MSI controller.
    
    The msi-map property provides this flexibility (and much more),
    so let's add a utility function that parses it, and return the
    corresponding MSI domain.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index ed64d98807f9..0baf626da56a 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -688,6 +688,24 @@ static struct irq_domain *__of_get_msi_domain(struct device_node *np,
 	return d;
 }
 
+/**
+ * of_msi_map_get_device_domain - Use msi-map to find the relevant MSI domain
+ * @dev: device for which the mapping is to be done.
+ * @rid: Requester ID for the device.
+ *
+ * Walk up the device hierarchy looking for devices with a "msi-map"
+ * property.
+ *
+ * Returns: the MSI domain for this device (or NULL on failure)
+ */
+struct irq_domain *of_msi_map_get_device_domain(struct device *dev, u32 rid)
+{
+	struct device_node *np = NULL;
+
+	__of_msi_map_rid(dev, &np, rid);
+	return __of_get_msi_domain(np, DOMAIN_BUS_PCI_MSI);
+}
+
 /**
  * of_msi_get_domain - Use msi-parent to find the relevant MSI domain
  * @dev: device for which the domain is requested

commit a251b263346e38b9fafebeb49ada9ce894882616
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Thu Oct 1 17:05:45 2015 +0100

    of/irq: Split of_msi_map_rid to reuse msi-map lookup
    
    The msi-map property is also used to identify the MSI controller
    as a form of grown-up msi-parent property.
    
    Looking it up is complicated enough, and since of_msi_map_rid
    already implements this, let's turn it into an internal utility
    function. We'll put that to good use later on.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 89ebc612293d..ed64d98807f9 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -579,21 +579,12 @@ void __init of_irq_init(const struct of_device_id *matches)
 	}
 }
 
-/**
- * of_msi_map_rid - Map a MSI requester ID for a device.
- * @dev: device for which the mapping is to be done.
- * @msi_np: device node of the expected msi controller.
- * @rid_in: unmapped MSI requester ID for the device.
- *
- * Walk up the device hierarchy looking for devices with a "msi-map"
- * property.  If found, apply the mapping to @rid_in.
- *
- * Returns the mapped MSI requester ID.
- */
-u32 of_msi_map_rid(struct device *dev, struct device_node *msi_np, u32 rid_in)
+static u32 __of_msi_map_rid(struct device *dev, struct device_node **np,
+			    u32 rid_in)
 {
 	struct device *parent_dev;
 	struct device_node *msi_controller_node;
+	struct device_node *msi_np = *np;
 	u32 map_mask, masked_rid, rid_base, msi_base, rid_len, phandle;
 	int msi_map_len;
 	bool matched;
@@ -643,9 +634,15 @@ u32 of_msi_map_rid(struct device *dev, struct device_node *msi_np, u32 rid_in)
 
 		msi_controller_node = of_find_node_by_phandle(phandle);
 
-		matched = masked_rid >= rid_base &&
-			masked_rid < rid_base + rid_len &&
-			msi_np == msi_controller_node;
+		matched = (masked_rid >= rid_base &&
+			   masked_rid < rid_base + rid_len);
+		if (msi_np)
+			matched &= msi_np == msi_controller_node;
+
+		if (matched && !msi_np) {
+			*np = msi_np = msi_controller_node;
+			break;
+		}
 
 		of_node_put(msi_controller_node);
 		msi_map_len -= 4 * sizeof(__be32);
@@ -663,6 +660,22 @@ u32 of_msi_map_rid(struct device *dev, struct device_node *msi_np, u32 rid_in)
 	return rid_out;
 }
 
+/**
+ * of_msi_map_rid - Map a MSI requester ID for a device.
+ * @dev: device for which the mapping is to be done.
+ * @msi_np: device node of the expected msi controller.
+ * @rid_in: unmapped MSI requester ID for the device.
+ *
+ * Walk up the device hierarchy looking for devices with a "msi-map"
+ * property.  If found, apply the mapping to @rid_in.
+ *
+ * Returns the mapped MSI requester ID.
+ */
+u32 of_msi_map_rid(struct device *dev, struct device_node *msi_np, u32 rid_in)
+{
+	return __of_msi_map_rid(dev, &msi_np, rid_in);
+}
+
 static struct irq_domain *__of_get_msi_domain(struct device_node *np,
 					      enum irq_domain_bus_token token)
 {

commit 61c08240a103000b75dcf7ef2cf03d552aa91fa3
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Fri Sep 18 14:07:40 2015 +0100

    of/irq: Use of_msi_get_domain instead of open-coded "msi-parent" parsing
    
    Now that we have a function that implements the complexity of the
    "msi-parent" property parsing, switch to that.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 62cfdc2c86ac..89ebc612293d 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -579,26 +579,6 @@ void __init of_irq_init(const struct of_device_id *matches)
 	}
 }
 
-/**
- * of_msi_configure - Set the msi_domain field of a device
- * @dev: device structure to associate with an MSI irq domain
- * @np: device node for that device
- */
-void of_msi_configure(struct device *dev, struct device_node *np)
-{
-	struct device_node *msi_np;
-	struct irq_domain *d;
-
-	msi_np = of_parse_phandle(np, "msi-parent", 0);
-	if (!msi_np)
-		return;
-
-	d = irq_find_matching_host(msi_np, DOMAIN_BUS_PLATFORM_MSI);
-	if (!d)
-		d = irq_find_host(msi_np);
-	dev_set_msi_domain(dev, d);
-}
-
 /**
  * of_msi_map_rid - Map a MSI requester ID for a device.
  * @dev: device for which the mapping is to be done.
@@ -741,3 +721,14 @@ struct irq_domain *of_msi_get_domain(struct device *dev,
 
 	return NULL;
 }
+
+/**
+ * of_msi_configure - Set the msi_domain field of a device
+ * @dev: device structure to associate with an MSI irq domain
+ * @np: device node for that device
+ */
+void of_msi_configure(struct device *dev, struct device_node *np)
+{
+	dev_set_msi_domain(dev,
+			   of_msi_get_domain(dev, np, DOMAIN_BUS_PLATFORM_MSI));
+}

commit 48ae34fb39b0c0cfc76275e844fba5b0b04fa49e
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Fri Sep 18 14:07:40 2015 +0100

    of/irq: Add support code for multi-parent version of "msi-parent"
    
    Since 126b16e2ad98 ("Docs: dt: add generic MSI bindings"),
    the definition of "msi-parent" has evolved, while maintaining
    some degree of compatibility. It can now express multiple MSI
    controllers as parents, as well as some sideband data being
    communicated to the controller.
    
    This patch adds the parsing of the property, iterating over
    the multiple parents until a suitable irqdomain is found.
    It can also fallback to the original parsing if the old
    binding is detected.
    
    This support code gets used in the subsequent patches.
    
    Suggested-by: Robin Murphy <robin.murphy@arm.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index c90bd4ec3183..62cfdc2c86ac 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -682,3 +682,62 @@ u32 of_msi_map_rid(struct device *dev, struct device_node *msi_np, u32 rid_in)
 
 	return rid_out;
 }
+
+static struct irq_domain *__of_get_msi_domain(struct device_node *np,
+					      enum irq_domain_bus_token token)
+{
+	struct irq_domain *d;
+
+	d = irq_find_matching_host(np, token);
+	if (!d)
+		d = irq_find_host(np);
+
+	return d;
+}
+
+/**
+ * of_msi_get_domain - Use msi-parent to find the relevant MSI domain
+ * @dev: device for which the domain is requested
+ * @np: device node for @dev
+ * @token: bus type for this domain
+ *
+ * Parse the msi-parent property (both the simple and the complex
+ * versions), and returns the corresponding MSI domain.
+ *
+ * Returns: the MSI domain for this device (or NULL on failure).
+ */
+struct irq_domain *of_msi_get_domain(struct device *dev,
+				     struct device_node *np,
+				     enum irq_domain_bus_token token)
+{
+	struct device_node *msi_np;
+	struct irq_domain *d;
+
+	/* Check for a single msi-parent property */
+	msi_np = of_parse_phandle(np, "msi-parent", 0);
+	if (msi_np && !of_property_read_bool(msi_np, "#msi-cells")) {
+		d = __of_get_msi_domain(msi_np, token);
+		if (!d)
+			of_node_put(msi_np);
+		return d;
+	}
+
+	if (token == DOMAIN_BUS_PLATFORM_MSI) {
+		/* Check for the complex msi-parent version */
+		struct of_phandle_args args;
+		int index = 0;
+
+		while (!of_parse_phandle_with_args(np, "msi-parent",
+						   "#msi-cells",
+						   index, &args)) {
+			d = __of_get_msi_domain(args.np, token);
+			if (d)
+				return d;
+
+			of_node_put(args.np);
+			index++;
+		}
+	}
+
+	return NULL;
+}

commit 8db02d8b4089fa8098a170738e8ae7939aa8ae7a
Author: David Daney <david.daney@cavium.com>
Date:   Thu Oct 8 15:10:48 2015 -0700

    of/irq: Add new function of_msi_map_rid()
    
    The device tree property "msi-map" specifies how to create the PCI
    requester id used in some MSI controllers.  Add a new function
    of_msi_map_rid() that finds the msi-map property and applies its
    translation to a given requester id.
    
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: David Daney <david.daney@cavium.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 55317fa9c9dc..c90bd4ec3183 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -598,3 +598,87 @@ void of_msi_configure(struct device *dev, struct device_node *np)
 		d = irq_find_host(msi_np);
 	dev_set_msi_domain(dev, d);
 }
+
+/**
+ * of_msi_map_rid - Map a MSI requester ID for a device.
+ * @dev: device for which the mapping is to be done.
+ * @msi_np: device node of the expected msi controller.
+ * @rid_in: unmapped MSI requester ID for the device.
+ *
+ * Walk up the device hierarchy looking for devices with a "msi-map"
+ * property.  If found, apply the mapping to @rid_in.
+ *
+ * Returns the mapped MSI requester ID.
+ */
+u32 of_msi_map_rid(struct device *dev, struct device_node *msi_np, u32 rid_in)
+{
+	struct device *parent_dev;
+	struct device_node *msi_controller_node;
+	u32 map_mask, masked_rid, rid_base, msi_base, rid_len, phandle;
+	int msi_map_len;
+	bool matched;
+	u32 rid_out = rid_in;
+	const __be32 *msi_map = NULL;
+
+	/*
+	 * Walk up the device parent links looking for one with a
+	 * "msi-map" property.
+	 */
+	for (parent_dev = dev; parent_dev; parent_dev = parent_dev->parent) {
+		if (!parent_dev->of_node)
+			continue;
+
+		msi_map = of_get_property(parent_dev->of_node,
+					  "msi-map", &msi_map_len);
+		if (!msi_map)
+			continue;
+
+		if (msi_map_len % (4 * sizeof(__be32))) {
+			dev_err(parent_dev, "Error: Bad msi-map length: %d\n",
+				msi_map_len);
+			return rid_out;
+		}
+		/* We have a good parent_dev and msi_map, let's use them. */
+		break;
+	}
+	if (!msi_map)
+		return rid_out;
+
+	/* The default is to select all bits. */
+	map_mask = 0xffffffff;
+
+	/*
+	 * Can be overridden by "msi-map-mask" property.  If
+	 * of_property_read_u32() fails, the default is used.
+	 */
+	of_property_read_u32(parent_dev->of_node, "msi-map-mask", &map_mask);
+
+	masked_rid = map_mask & rid_in;
+	matched = false;
+	while (!matched && msi_map_len >= 4 * sizeof(__be32)) {
+		rid_base = be32_to_cpup(msi_map + 0);
+		phandle = be32_to_cpup(msi_map + 1);
+		msi_base = be32_to_cpup(msi_map + 2);
+		rid_len = be32_to_cpup(msi_map + 3);
+
+		msi_controller_node = of_find_node_by_phandle(phandle);
+
+		matched = masked_rid >= rid_base &&
+			masked_rid < rid_base + rid_len &&
+			msi_np == msi_controller_node;
+
+		of_node_put(msi_controller_node);
+		msi_map_len -= 4 * sizeof(__be32);
+		msi_map += 4;
+	}
+	if (!matched)
+		return rid_out;
+
+	rid_out = masked_rid + msi_base;
+	dev_dbg(dev,
+		"msi-map at: %s, using mask %08x, rid-base: %08x, msi-base: %08x, length: %08x, rid: %08x -> %08x\n",
+		dev_name(parent_dev), map_mask, rid_base, msi_base,
+		rid_len, rid_in, rid_out);
+
+	return rid_out;
+}

commit 52493d446141b07c8ba28dd6a529513f8b2342bd
Author: Jonas Gorski <jogo@openwrt.org>
Date:   Mon Oct 12 14:43:23 2015 +0200

    of/irq: make of_irq_find_parent static
    
    of_irq_find_parent has no users outside of of_irq.c, so it does not make
    sense to expose it in of_irq.h. Therefore remove the prototype and dummy
    implmeentation and make the function static instead.
    
    Signed-off-by: Jonas Gorski <jogo@openwrt.org>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 55317fa9c9dc..0c7f4cbe3434 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -53,7 +53,7 @@ EXPORT_SYMBOL_GPL(irq_of_parse_and_map);
  * Returns a pointer to the interrupt parent node, or NULL if the interrupt
  * parent could not be determined.
  */
-struct device_node *of_irq_find_parent(struct device_node *child)
+static struct device_node *of_irq_find_parent(struct device_node *child)
 {
 	struct device_node *p;
 	const __be32 *parp;

commit acceba598eda9817bc187f3a683a2d2ee7e7fbc7
Merge: c19176154b46 5a73882fd2c3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 8 16:16:26 2015 -0700

    Merge branch 'i2c/for-4.3' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux
    
    Pull i2c updates from Wolfram Sang:
     "Features:
    
       - new drivers: Renesas EMEV2, register based MUX, NXP LPC2xxx
       - core: scans DT and assigns wakeup interrupts.  no driver changes needed.
       - core: some refcouting issues fixed and better API for that
       - core: new helper function for best effort block read emulation
       - slave framework: proper DT bindings and userspace instantiation
       - some bigger work for xiic, pxa, omap drivers
    
      .. and quite a number of smaller driver fixes, cleanups, improvements"
    
    * 'i2c/for-4.3' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux: (65 commits)
      i2c: mux: reg Change ioread endianness for readback
      i2c: mux: reg: fix compilation warnings
      i2c: mux: reg: simplify register size checking
      i2c: muxes: fix leaked i2c adapter device node references
      i2c: allow specifying separate wakeup interrupt in device tree
      of/irq: export of_get_irq_byname()
      i2c: xgene-slimpro: dma_mapping_error() doesn't return an error code
      i2c: Replace I2C_CROS_EC_TUNNEL dependency
      eeprom: at24: use i2c_smbus_read_i2c_block_data_or_emulated
      i2c: core: Add support for best effort block read emulation
      i2c: lpc2k: add driver
      i2c: mux: Add register-based mux i2c-mux-reg
      i2c: dt: describe generic bindings
      i2c: slave: print warning if slave flag not set
      i2c: support 10 bit and slave addresses in sysfs 'new_device'
      i2c: take address space into account when checking for used addresses
      i2c: apply DT flags when probing
      i2c: make address check indpendent from client struct
      i2c: rename address check functions
      i2c: apply address offset for slaves, too
      ...

commit 6602c452caf532893c1bde50aacda0bd17f958aa
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Aug 25 17:04:02 2015 -0700

    of/irq: export of_get_irq_byname()
    
    Similarly to of_get_irq(), let's export of_irq_get_byname(), so if a bus core
    can be compiled as a module (such as I2C) it can have access to the symbol.
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 3cf7a01f557f..e9eaed1dc996 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -431,6 +431,7 @@ int of_irq_get_byname(struct device_node *dev, const char *name)
 
 	return of_irq_get(dev, index);
 }
+EXPORT_SYMBOL_GPL(of_irq_get_byname);
 
 /**
  * of_irq_count - Count the number of IRQs a node uses

commit c706c239af5bc297b5fbf1adc715632e1c222f7a
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Jul 28 14:46:15 2015 +0100

    of/platform: Assign MSI domain to platform device
    
    As for PCI, we're able to populate the msi_domain field at probe time,
    provided that the device tree has an "msi-parent" property.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Yijing Wang <wangyijing@huawei.com>
    Cc: Ma Jun <majun258@huawei.com>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Duc Dang <dhdang@apm.com>
    Cc: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Link: http://lkml.kernel.org/r/1438091186-10244-9-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 3cf7a01f557f..2956d725649f 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -18,6 +18,7 @@
  * driver.
  */
 
+#include <linux/device.h>
 #include <linux/errno.h>
 #include <linux/list.h>
 #include <linux/module.h>
@@ -576,3 +577,23 @@ void __init of_irq_init(const struct of_device_id *matches)
 		kfree(desc);
 	}
 }
+
+/**
+ * of_msi_configure - Set the msi_domain field of a device
+ * @dev: device structure to associate with an MSI irq domain
+ * @np: device node for that device
+ */
+void of_msi_configure(struct device *dev, struct device_node *np)
+{
+	struct device_node *msi_np;
+	struct irq_domain *d;
+
+	msi_np = of_parse_phandle(np, "msi-parent", 0);
+	if (!msi_np)
+		return;
+
+	d = irq_find_matching_host(msi_np, DOMAIN_BUS_PLATFORM_MSI);
+	if (!d)
+		d = irq_find_host(msi_np);
+	dev_set_msi_domain(dev, d);
+}

commit 48a9b733e644ab4cc8e2a98950a36ddb12b8c54e
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Jun 26 14:42:45 2015 +0200

    of/irq: Rename "intc_desc" to "of_intc_desc" to fix OF on sh
    
    Now CONFIG_OF can be enabled on sh:
    
        drivers/of/irq.c:472:8: error: redefinition of 'struct intc_desc'
        include/linux/sh_intc.h:109:8: note: originally defined here
    
    As "intc_desc" is used all over the place in sh platform code, while
    drivers/of/irq.c has a local definition used in a single function,
    rename the latter by prefixing it with "of_".
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index cb4b9aeaa10d..3cf7a01f557f 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -468,7 +468,7 @@ int of_irq_to_resource_table(struct device_node *dev, struct resource *res,
 }
 EXPORT_SYMBOL_GPL(of_irq_to_resource_table);
 
-struct intc_desc {
+struct of_intc_desc {
 	struct list_head	list;
 	struct device_node	*dev;
 	struct device_node	*interrupt_parent;
@@ -484,7 +484,7 @@ struct intc_desc {
 void __init of_irq_init(const struct of_device_id *matches)
 {
 	struct device_node *np, *parent = NULL;
-	struct intc_desc *desc, *temp_desc;
+	struct of_intc_desc *desc, *temp_desc;
 	struct list_head intc_desc_list, intc_parent_list;
 
 	INIT_LIST_HEAD(&intc_desc_list);
@@ -495,7 +495,7 @@ void __init of_irq_init(const struct of_device_id *matches)
 				!of_device_is_available(np))
 			continue;
 		/*
-		 * Here, we allocate and populate an intc_desc with the node
+		 * Here, we allocate and populate an of_intc_desc with the node
 		 * pointer, interrupt-parent device_node etc.
 		 */
 		desc = kzalloc(sizeof(*desc), GFP_KERNEL);

commit d23b251669e20b3989643d9c38228039c510478f
Author: Jeremy Linton <lintonrjeremy@gmail.com>
Date:   Mon Jun 29 18:50:55 2015 -0500

    of/irq: Fix pSeries boot failure
    
    of_irq_parse_raw() needs to return the correct interrupt controller
    node when an interrupt-map property doesn't exist.
    
    It allows of_irq_parse_raw() to return the node pointer of the interrupt
    controller, rather than the parent bus. This allows ics_rtas_host_match()
    to detect that the controller is a legacy 8259 and avoid using xics.
    This avoids an RTAS assertion/crash during early kernel bootstrapping.
    
    Signed-off-by: Jeremy Linton <lintonrjeremy@gmail.com>
    Reviewed-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 1a7980692f25..cb4b9aeaa10d 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -252,8 +252,6 @@ int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
 		 * Successfully parsed an interrrupt-map translation; copy new
 		 * interrupt specifier into the out_irq structure
 		 */
-		out_irq->np = newpar;
-
 		match_array = imap - newaddrsize - newintsize;
 		for (i = 0; i < newintsize; i++)
 			out_irq->args[i] = be32_to_cpup(imap - newintsize + i);
@@ -262,6 +260,7 @@ int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
 
 	skiplevel:
 		/* Iterate again with new parent */
+		out_irq->np = newpar;
 		pr_debug(" -> new parent: %s\n", of_node_full_name(newpar));
 		of_node_put(ipar);
 		ipar = newpar;

commit d7c146053dd195b90c79b9b8131431f44541d015
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Wed Mar 18 00:21:32 2015 +0200

    of/irq: Fix of_irq_parse_one() returned error codes
    
    The error code paths that require cleanup use a goto to jump to the
    cleanup code and return an error code. However, the error code variable
    res, which is initialized to -EINVAL when declared, is then overwritten
    with the return value of of_parse_phandle_with_args(), and reused as the
    return code from of_irq_parse_one(). This leads to an undetermined error
    being returned instead of the expected -EINVAL value. Fix it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Cc: stable@vger.kernel.org # 3.13+
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 0d7765807f49..1a7980692f25 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -290,7 +290,7 @@ int of_irq_parse_one(struct device_node *device, int index, struct of_phandle_ar
 	struct device_node *p;
 	const __be32 *intspec, *tmp, *addr;
 	u32 intsize, intlen;
-	int i, res = -EINVAL;
+	int i, res;
 
 	pr_debug("of_irq_parse_one: dev=%s, index=%d\n", of_node_full_name(device), index);
 
@@ -323,15 +323,19 @@ int of_irq_parse_one(struct device_node *device, int index, struct of_phandle_ar
 
 	/* Get size of interrupt specifier */
 	tmp = of_get_property(p, "#interrupt-cells", NULL);
-	if (tmp == NULL)
+	if (tmp == NULL) {
+		res = -EINVAL;
 		goto out;
+	}
 	intsize = be32_to_cpu(*tmp);
 
 	pr_debug(" intsize=%d intlen=%d\n", intsize, intlen);
 
 	/* Check index */
-	if ((index + 1) * intsize > intlen)
+	if ((index + 1) * intsize > intlen) {
+		res = -EINVAL;
 		goto out;
+	}
 
 	/* Copy intspec into irq structure */
 	intspec += index * intsize;

commit 9eb08fb3d15896bfff57fcd4c87e3fd5b19d8581
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Thu Oct 30 15:59:36 2014 +0200

    of/irq: Export of_irq_get()
    
    The function will be used by the I2C core which can be compiled as a
    module.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 1471e0a223a5..0d7765807f49 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -405,6 +405,7 @@ int of_irq_get(struct device_node *dev, int index)
 
 	return irq_create_of_mapping(&oirq);
 }
+EXPORT_SYMBOL_GPL(of_irq_get);
 
 /**
  * of_irq_get_byname - Decode a node's IRQ and return it as a Linux irq number

commit a9ecdc0fdc54aa499604dbd43132988effcac9b4
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Wed Aug 6 13:02:27 2014 -0700

    of/irq: Fix lookup to use 'interrupts-extended' property first
    
    In case the Device Tree blob passed by the boot agent supplies both an
    'interrupts-extended' and an 'interrupts' property in order to allow for
    older kernels to be usable, prefer the new-style 'interrupts-extended'
    property which conveys a lot more information.
    
    This allows us to have bootloaders willingly maintaining backwards
    compatibility with older kernels without entirely deprecating the
    'interrupts' property.
    
    Update the bindings documentation to describe a situation where both the
    'interrupts-extended' and the 'interrupts' property are present, and
    which one takes precedence over the other.
    
    Cc: stable@vger.kernel.org # 3.13+
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 3e06a699352d..1471e0a223a5 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -301,16 +301,17 @@ int of_irq_parse_one(struct device_node *device, int index, struct of_phandle_ar
 	/* Get the reg property (if any) */
 	addr = of_get_property(device, "reg", NULL);
 
+	/* Try the new-style interrupts-extended first */
+	res = of_parse_phandle_with_args(device, "interrupts-extended",
+					"#interrupt-cells", index, out_irq);
+	if (!res)
+		return of_irq_parse_raw(addr, out_irq);
+
 	/* Get the interrupts property */
 	intspec = of_get_property(device, "interrupts", &intlen);
-	if (intspec == NULL) {
-		/* Try the new-style interrupts-extended */
-		res = of_parse_phandle_with_args(device, "interrupts-extended",
-						"#interrupt-cells", index, out_irq);
-		if (res)
-			return -EINVAL;
-		return of_irq_parse_raw(addr, out_irq);
-	}
+	if (intspec == NULL)
+		return -EINVAL;
+
 	intlen /= sizeof(*intspec);
 
 	pr_debug(" intspec=%d intlen=%d\n", be32_to_cpup(intspec), intlen);

commit ad69674e73a18dc3a8da557f4059ccf9389531a5
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Tue May 20 13:42:02 2014 +0300

    of/irq: do irq resolution in platform_get_irq_byname()
    
    The commit 9ec36cafe43bf835f8f29273597a5b0cbc8267ef
    "of/irq: do irq resolution in platform_get_irq" from Rob Herring -
    moves resolving of the interrupt resources in platform_get_irq().
    But this solution isn't complete because platform_get_irq_byname()
    need to be modified the same way.
    
    Hence, fix it by adding interrupt resolution code at the
    platform_get_irq_byname() function too.
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 5aeb89411350..3e06a699352d 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -405,6 +405,28 @@ int of_irq_get(struct device_node *dev, int index)
 	return irq_create_of_mapping(&oirq);
 }
 
+/**
+ * of_irq_get_byname - Decode a node's IRQ and return it as a Linux irq number
+ * @dev: pointer to device tree node
+ * @name: irq name
+ *
+ * Returns Linux irq number on success, or -EPROBE_DEFER if the irq domain
+ * is not yet created, or error code in case of any other failure.
+ */
+int of_irq_get_byname(struct device_node *dev, const char *name)
+{
+	int index;
+
+	if (unlikely(!name))
+		return -EINVAL;
+
+	index = of_property_match_string(dev, "interrupt-names", name);
+	if (index < 0)
+		return index;
+
+	return of_irq_get(dev, index);
+}
+
 /**
  * of_irq_count - Count the number of IRQs a node uses
  * @dev: pointer to device tree node

commit 9ec36cafe43bf835f8f29273597a5b0cbc8267ef
Author: Rob Herring <robh@kernel.org>
Date:   Wed Apr 23 17:57:41 2014 -0500

    of/irq: do irq resolution in platform_get_irq
    
    Currently we get the following kind of errors if we try to use interrupt
    phandles to irqchips that have not yet initialized:
    
    irq: no irq domain found for /ocp/pinmux@48002030 !
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 1 at drivers/of/platform.c:171 of_device_alloc+0x144/0x184()
    Modules linked in:
    CPU: 0 PID: 1 Comm: swapper/0 Not tainted 3.12.0-00038-g42a9708 #1012
    (show_stack+0x14/0x1c)
    (dump_stack+0x6c/0xa0)
    (warn_slowpath_common+0x64/0x84)
    (warn_slowpath_null+0x1c/0x24)
    (of_device_alloc+0x144/0x184)
    (of_platform_device_create_pdata+0x44/0x9c)
    (of_platform_bus_create+0xd0/0x170)
    (of_platform_bus_create+0x12c/0x170)
    (of_platform_populate+0x60/0x98)
    
    This is because we're wrongly trying to populate resources that are not
    yet available. It's perfectly valid to create irqchips dynamically, so
    let's fix up the issue by resolving the interrupt resources when
    platform_get_irq is called.
    
    And then we also need to accept the fact that some irqdomains do not
    exist that early on, and only get initialized later on. So we can
    make the current WARN_ON into just into a pr_debug().
    
    We still attempt to populate irq resources when we create the devices.
    This allows current drivers which don't use platform_get_irq to continue
    to function. Once all drivers are fixed, this code can be removed.
    
    Suggested-by: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Cc: stable@vger.kernel.org # v3.10+
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index e2e4c548a42f..5aeb89411350 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -379,6 +379,32 @@ int of_irq_to_resource(struct device_node *dev, int index, struct resource *r)
 }
 EXPORT_SYMBOL_GPL(of_irq_to_resource);
 
+/**
+ * of_irq_get - Decode a node's IRQ and return it as a Linux irq number
+ * @dev: pointer to device tree node
+ * @index: zero-based index of the irq
+ *
+ * Returns Linux irq number on success, or -EPROBE_DEFER if the irq domain
+ * is not yet created.
+ *
+ */
+int of_irq_get(struct device_node *dev, int index)
+{
+	int rc;
+	struct of_phandle_args oirq;
+	struct irq_domain *domain;
+
+	rc = of_irq_parse_one(dev, index, &oirq);
+	if (rc)
+		return rc;
+
+	domain = irq_find_host(oirq.np);
+	if (!domain)
+		return -EPROBE_DEFER;
+
+	return irq_create_of_mapping(&oirq);
+}
+
 /**
  * of_irq_count - Count the number of IRQs a node uses
  * @dev: pointer to device tree node

commit ae107d06137ce210ea21d1423443d3638599f297
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Apr 22 20:40:25 2014 +0200

    dt: Fix binding typos in clock-names and interrupt-names
    
    s/interrupts-names/interrupt-names/g
    s/clocks-names/clock-names/g
    
    Some of the binding files and device tree files get this wrong and the
    kernel won't be able to pick it up. Fix them up now so that they don't
    get widely used.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by : Patrice Chotard <patrice.chotard@st.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 9bcf2cf19357..e2e4c548a42f 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -364,7 +364,7 @@ int of_irq_to_resource(struct device_node *dev, int index, struct resource *r)
 
 		memset(r, 0, sizeof(*r));
 		/*
-		 * Get optional "interrupts-names" property to add a name
+		 * Get optional "interrupt-names" property to add a name
 		 * to the resource.
 		 */
 		of_property_read_string_index(dev, "interrupt-names", index,

commit 361128fcbf30f590a05c8e8789155364f37367db
Merge: e2897d7e0b04 482c43419fc2
Author: Rob Herring <robh@kernel.org>
Date:   Fri Jan 17 16:01:27 2014 -0600

    Merge remote-tracking branch 'grant/devicetree/next' into for-3.14

commit 2f53a713c4b6c1d2f32d87c532d47ad17861053a
Author: Cdric Le Goater <clg@fr.ibm.com>
Date:   Tue Dec 17 18:32:53 2013 +0100

    of/irq: Fix device_node refcount in of_irq_parse_raw()
    
    Commit 2361613206e6, "of/irq: Refactor interrupt-map parsing" changed
    the refcount on the device_node causing an error in of_node_put():
    
    ERROR: Bad of_node_put() on /pci@800000020000000
    CPU: 0 PID: 1 Comm: swapper/0 Not tainted 3.13.0-rc3-dirty #2
    Call Trace:
    [c00000003e403500] [c0000000000144fc] .show_stack+0x7c/0x1f0 (unreliable)
    [c00000003e4035d0] [c00000000070f250] .dump_stack+0x88/0xb4
    [c00000003e403650] [c0000000005e8768] .of_node_release+0xd8/0xf0
    [c00000003e4036e0] [c0000000005eeafc] .of_irq_parse_one+0x10c/0x280
    [c00000003e4037a0] [c0000000005efd4c] .of_irq_parse_pci+0x3c/0x1d0
    [c00000003e403840] [c000000000038240] .pcibios_setup_device+0xa0/0x2e0
    [c00000003e403910] [c0000000000398f0] .pcibios_setup_bus_devices+0x60/0xd0
    [c00000003e403990] [c00000000003b3a4] .__of_scan_bus+0x1a4/0x2b0
    [c00000003e403a80] [c00000000003a62c] .pcibios_scan_phb+0x30c/0x410
    [c00000003e403b60] [c0000000009fe430] .pcibios_init+0x7c/0xd4
    
    This patch adjusts the refcount in the walk of the interrupt tree.
    When a match is found, there is no need to increase the refcount
    on 'out_irq->np' as 'newpar' is already holding a ref. The refcount
    balance between 'ipar' and 'newpar' is maintained in the skiplevel:
    goto label.
    
    This patch also removes the usage of the device_node variable 'old'
    which seems useless after the latest changes.
    
    Signed-off-by: Cdric Le Goater <clg@fr.ibm.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 786b0b47fae4..27212402c532 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -165,7 +165,6 @@ int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
 		if (of_get_property(ipar, "interrupt-controller", NULL) !=
 				NULL) {
 			pr_debug(" -> got it !\n");
-			of_node_put(old);
 			return 0;
 		}
 
@@ -250,8 +249,7 @@ int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
 		 * Successfully parsed an interrrupt-map translation; copy new
 		 * interrupt specifier into the out_irq structure
 		 */
-		of_node_put(out_irq->np);
-		out_irq->np = of_node_get(newpar);
+		out_irq->np = newpar;
 
 		match_array = imap - newaddrsize - newintsize;
 		for (i = 0; i < newintsize; i++)
@@ -268,7 +266,6 @@ int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
 	}
  fail:
 	of_node_put(ipar);
-	of_node_put(out_irq->np);
 	of_node_put(newpar);
 
 	return -EINVAL;

commit 1ca56e7dcadd865ae2c235789cbdbfebae719ffb
Author: Peter Crosthwaite <peter.crosthwaite@xilinx.com>
Date:   Wed Nov 27 23:26:12 2013 -0800

    of: irq: Ignore disabled intc's when searching map
    
    When searching the interrupt map, if a matched parent is disabled, just
    ignore it and move on with the search.
    
    This allows for specifying connection of a single device IRQ to
    multiple interrupt controllers via the interrupt map schema. This change
    allows for selection of the active interrupt controller via the already
    existing status = "disabled" mechanism.
    
    Signed-off-by: Peter Crosthwaite <peter.crosthwaite@xilinx.com>
    Acked-by: Michal Simek <michal.simek@xilinx.com>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 9876963ed7b3..bf8026895c5e 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -217,6 +217,9 @@ int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
 				goto fail;
 			}
 
+			if (!of_device_is_available(newpar))
+				match = 0;
+
 			/* Get #interrupt-cells and #address-cells of new
 			 * parent
 			 */

commit bf49be02d6f92b95c2462e5027fc90b98f62e324
Author: Peter Crosthwaite <peter.crosthwaite@xilinx.com>
Date:   Wed Nov 27 23:26:13 2013 -0800

    of: irq: Ignore disabled interrupt controllers
    
    When searching the system for interrupt controllers, skip over any
    that are explicitly disabled.
    
    This makes interrupt controllers consistent with regular devices,
    which can be marked as do-not-probe via the status = "disabled" dts
    property.
    
    Signed-off-by: Peter Crosthwaite <peter.crosthwaite@xilinx.com>
    Acked-by: Michal Simek <michal.simek@xilinx.com>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 786b0b47fae4..9876963ed7b3 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -438,7 +438,8 @@ void __init of_irq_init(const struct of_device_id *matches)
 	INIT_LIST_HEAD(&intc_parent_list);
 
 	for_each_matching_node(np, matches) {
-		if (!of_find_property(np, "interrupt-controller", NULL))
+		if (!of_find_property(np, "interrupt-controller", NULL) ||
+				!of_device_is_available(np))
 			continue;
 		/*
 		 * Here, we allocate and populate an intc_desc with the node

commit 74dac2ed699cbe1dee0e4e7891619d53a5f2632f
Author: Tomasz Figa <t.figa@samsung.com>
Date:   Tue Nov 5 16:21:18 2013 +0100

    of: irq: Fix interrupt-map entry matching
    
    This patch fixes interrupt-map entry matching code to properly match all
    specifier cells with interrupt map entries.
    
    Signed-off-by: Tomasz Figa <t.figa@samsung.com>
    Tested-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index d385bb824772..786b0b47fae4 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -199,7 +199,7 @@ int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
 			/* Compare specifiers */
 			match = 1;
 			for (i = 0; i < (addrsize + intsize); i++, imaplen--)
-				match = !((match_array[i] ^ *imap++) & imask[i]);
+				match &= !((match_array[i] ^ *imap++) & imask[i]);
 
 			pr_debug(" -> match=%d (imaplen=%d)\n", match, imaplen);
 

commit 355e62f5ad12b005c862838156262eb2df2f8dff
Author: Grant Likely <grant.likely@linaro.org>
Date:   Sat Nov 2 00:11:02 2013 -0700

    of/irq: Fix potential buffer overflow
    
    Commit 2361613206e6, "of/irq: Refactor interrupt-map parsing" introduced
    a potential buffer overflow bug because it doesn't do sufficient range
    checking on the input data. This patch adds the appropriate checking and
    buffer size adjustments. If the bounds are out of range then warn
    loudly. MAX_PHANDLE_ARGS should be sufficient. If it is not then the
    value can be increased.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Cc: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 52dba6a01423..d385bb824772 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -95,9 +95,9 @@ struct device_node *of_irq_find_parent(struct device_node *child)
 int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
 {
 	struct device_node *ipar, *tnode, *old = NULL, *newpar = NULL;
-	__be32 initial_match_array[8];
+	__be32 initial_match_array[MAX_PHANDLE_ARGS];
 	const __be32 *match_array = initial_match_array;
-	const __be32 *tmp, *imap, *imask, dummy_imask[] = { ~0, ~0, ~0, ~0, ~0 };
+	const __be32 *tmp, *imap, *imask, dummy_imask[] = { [0 ... MAX_PHANDLE_ARGS] = ~0 };
 	u32 intsize = 1, addrsize, newintsize = 0, newaddrsize = 0;
 	int imaplen, match, i;
 
@@ -147,6 +147,10 @@ int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
 
 	pr_debug(" -> addrsize=%d\n", addrsize);
 
+	/* Range check so that the temporary buffer doesn't overflow */
+	if (WARN_ON(addrsize + intsize > MAX_PHANDLE_ARGS))
+		goto fail;
+
 	/* Precalculate the match array - this simplifies match loop */
 	for (i = 0; i < addrsize; i++)
 		initial_match_array[i] = addr ? addr[i] : 0;
@@ -229,6 +233,8 @@ int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
 			    newintsize, newaddrsize);
 
 			/* Check for malformed properties */
+			if (WARN_ON(newaddrsize + newintsize > MAX_PHANDLE_ARGS))
+				goto fail;
 			if (imaplen < (newaddrsize + newintsize))
 				goto fail;
 

commit 78119fd1068cc068f6112a57a5f6de0e5b20245a
Author: Grant Likely <grant.likely@linaro.org>
Date:   Fri Nov 1 10:50:50 2013 -0700

    of/irq: Fix bug in interrupt parsing refactor.
    
    Commit 2361613206e6, "of/irq: Refactor interrupt-map parsing" introduced
    a bug. The irq parsing will fail for some nodes that don't have a reg
    property. It is fixed by deferring the check for reg until it is
    actually needed. Also adjust the testcase data to catch the bug.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Tested-by: Stephen Warren <swarren@nvidia.com>
    Tested-by: Ming Lei <tom.leiming@gmail.com>
    Tested-by: Stephen Warren <swarren@nvidia.com>
    Cc: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 8cc62b4a7988..52dba6a01423 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -147,18 +147,9 @@ int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
 
 	pr_debug(" -> addrsize=%d\n", addrsize);
 
-	/* If we were passed no "reg" property and we attempt to parse
-	 * an interrupt-map, then #address-cells must be 0.
-	 * Fail if it's not.
-	 */
-	if (addr == NULL && addrsize != 0) {
-		pr_debug(" -> no reg passed in when needed !\n");
-		return -EINVAL;
-	}
-
 	/* Precalculate the match array - this simplifies match loop */
 	for (i = 0; i < addrsize; i++)
-		initial_match_array[i] = addr[i];
+		initial_match_array[i] = addr ? addr[i] : 0;
 	for (i = 0; i < intsize; i++)
 		initial_match_array[addrsize + i] = cpu_to_be32(out_irq->args[i]);
 
@@ -174,6 +165,15 @@ int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
 			return 0;
 		}
 
+		/*
+		 * interrupt-map parsing does not work without a reg
+		 * property when #address-cells != 0
+		 */
+		if (addrsize && !addr) {
+			pr_debug(" -> no reg passed in when needed !\n");
+			goto fail;
+		}
+
 		/* Now look for an interrupt-map */
 		imap = of_get_property(ipar, "interrupt-map", &imaplen);
 		/* No interrupt map, check for an interrupt parent */

commit 79d9701559a9f3e9b2021fbd292f5e70ad75f686
Author: Grant Likely <grant.likely@linaro.org>
Date:   Thu Sep 19 16:47:37 2013 -0500

    of/irq: create interrupts-extended property
    
    The standard interrupts property in device tree can only handle
    interrupts coming from a single interrupt parent. If a device is wired
    to multiple interrupt controllers, then it needs to be attached to a
    node with an interrupt-map property to demux the interrupt specifiers
    which is confusing. It would be a lot easier if there was a form of the
    interrupts property that allows for a separate interrupt phandle for
    each interrupt specifier.
    
    This patch does exactly that by creating a new interrupts-extended
    property which reuses the phandle+arguments pattern used by GPIOs and
    other core bindings.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Kumar Gala <galak@codeaurora.org>
    [grant.likely: removed versatile platform hunks into separate patch]
    Cc: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 7c4ff122785f..8cc62b4a7988 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -292,17 +292,23 @@ int of_irq_parse_one(struct device_node *device, int index, struct of_phandle_ar
 	if (of_irq_workarounds & OF_IMAP_OLDWORLD_MAC)
 		return of_irq_parse_oldworld(device, index, out_irq);
 
+	/* Get the reg property (if any) */
+	addr = of_get_property(device, "reg", NULL);
+
 	/* Get the interrupts property */
 	intspec = of_get_property(device, "interrupts", &intlen);
-	if (intspec == NULL)
-		return -EINVAL;
+	if (intspec == NULL) {
+		/* Try the new-style interrupts-extended */
+		res = of_parse_phandle_with_args(device, "interrupts-extended",
+						"#interrupt-cells", index, out_irq);
+		if (res)
+			return -EINVAL;
+		return of_irq_parse_raw(addr, out_irq);
+	}
 	intlen /= sizeof(*intspec);
 
 	pr_debug(" intspec=%d intlen=%d\n", be32_to_cpup(intspec), intlen);
 
-	/* Get the reg property (if any) */
-	addr = of_get_property(device, "reg", NULL);
-
 	/* Look for the interrupt parent. */
 	p = of_irq_find_parent(device);
 	if (p == NULL)

commit 3da5278727a895d49a601f67fd49dffa0b80f9a5
Author: Thierry Reding <thierry.reding@gmail.com>
Date:   Wed Sep 18 15:24:43 2013 +0200

    of/irq: Rework of_irq_count()
    
    The of_irq_to_resource() helper that is used to implement of_irq_count()
    tries to resolve interrupts and in fact creates a mapping for resolved
    interrupts. That's pretty heavy lifting for something that claims to
    just return the number of interrupts requested by a given device node.
    
    Instead, use the more lightweight of_irq_map_one(), which, despite the
    name, doesn't create an actual mapping. Perhaps a better name would be
    of_irq_translate_one().
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Rob Herring <rob.herring@calxeda.com>
    [grant.likely: fixup s/of_irq_map_one/of_irq_parse_one/]
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index ddea945ec29e..7c4ff122785f 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -373,9 +373,10 @@ EXPORT_SYMBOL_GPL(of_irq_to_resource);
  */
 int of_irq_count(struct device_node *dev)
 {
+	struct of_phandle_args irq;
 	int nr = 0;
 
-	while (of_irq_to_resource(dev, nr, NULL))
+	while (of_irq_parse_one(dev, nr, &irq) == 0)
 		nr++;
 
 	return nr;

commit 624cfca534f9b1ffb1326617b4e973a3d5ecff4a
Author: Grant Likely <grant.likely@linaro.org>
Date:   Fri Oct 11 22:05:10 2013 +0100

    of: Add helper for printing an of_phandle_args structure
    
    It is sometimes useful for debug to get the contents of an
    of_phandle_args structure out into the kernel log.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 0ed5ed4a5f9b..ddea945ec29e 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -101,9 +101,9 @@ int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
 	u32 intsize = 1, addrsize, newintsize = 0, newaddrsize = 0;
 	int imaplen, match, i;
 
-	pr_debug("of_irq_parse_raw: par=%s,intspec=[0x%08x 0x%08x...],ointsize=%d\n",
-		 of_node_full_name(out_irq->np), out_irq->args[0], out_irq->args[1],
-		 out_irq->args_count);
+#ifdef DEBUG
+	of_print_phandle_args("of_irq_parse_raw: ", out_irq);
+#endif
 
 	ipar = of_node_get(out_irq->np);
 

commit 2361613206e66ce59cc0e08efa8d98ec15b84ed1
Author: Grant Likely <grant.likely@linaro.org>
Date:   Sun Sep 15 22:32:39 2013 +0100

    of/irq: Refactor interrupt-map parsing
    
    All the users of of_irq_parse_raw pass in a raw interrupt specifier from
    the device tree and expect it to be returned (possibly modified) in an
    of_phandle_args structure. However, the primary function of
    of_irq_parse_raw() is to check for translations due to the presence of
    one or more interrupt-map properties. The actual placing of the data
    into an of_phandle_args structure is trivial. If it is refactored to
    accept an of_phandle_args structure directly, then it becomes possible
    to consume of_phandle_args from other sources. This is important for an
    upcoming patch that allows a device to be connected to more than one
    interrupt parent. It also simplifies the code a bit.
    
    The biggest complication with this patch is that the old version works
    on the interrupt specifiers in __be32 form, but the of_phandle_args
    structure is intended to carry it in the cpu-native version. A bit of
    churn was required to make this work. In the end it results in tighter
    code, so the churn is worth it.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 84184c44e8db..0ed5ed4a5f9b 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -80,31 +80,32 @@ struct device_node *of_irq_find_parent(struct device_node *child)
 /**
  * of_irq_parse_raw - Low level interrupt tree parsing
  * @parent:	the device interrupt parent
- * @intspec:	interrupt specifier ("interrupts" property of the device)
- * @ointsize:   size of the passed in interrupt specifier
- * @addr:	address specifier (start of "reg" property of the device)
- * @out_irq:	structure of_irq filled by this function
+ * @addr:	address specifier (start of "reg" property of the device) in be32 format
+ * @out_irq:	structure of_irq updated by this function
  *
  * Returns 0 on success and a negative number on error
  *
  * This function is a low-level interrupt tree walking function. It
  * can be used to do a partial walk with synthetized reg and interrupts
  * properties, for example when resolving PCI interrupts when no device
- * node exist for the parent.
+ * node exist for the parent. It takes an interrupt specifier structure as
+ * input, walks the tree looking for any interrupt-map properties, translates
+ * the specifier for each map, and then returns the translated map.
  */
-int of_irq_parse_raw(struct device_node *parent, const __be32 *intspec,
-		   u32 ointsize, const __be32 *addr, struct of_phandle_args *out_irq)
+int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
 {
 	struct device_node *ipar, *tnode, *old = NULL, *newpar = NULL;
-	const __be32 *tmp, *imap, *imask;
+	__be32 initial_match_array[8];
+	const __be32 *match_array = initial_match_array;
+	const __be32 *tmp, *imap, *imask, dummy_imask[] = { ~0, ~0, ~0, ~0, ~0 };
 	u32 intsize = 1, addrsize, newintsize = 0, newaddrsize = 0;
 	int imaplen, match, i;
 
 	pr_debug("of_irq_parse_raw: par=%s,intspec=[0x%08x 0x%08x...],ointsize=%d\n",
-		 of_node_full_name(parent), be32_to_cpup(intspec),
-		 be32_to_cpup(intspec + 1), ointsize);
+		 of_node_full_name(out_irq->np), out_irq->args[0], out_irq->args[1],
+		 out_irq->args_count);
 
-	ipar = of_node_get(parent);
+	ipar = of_node_get(out_irq->np);
 
 	/* First get the #interrupt-cells property of the current cursor
 	 * that tells us how to interpret the passed-in intspec. If there
@@ -127,7 +128,7 @@ int of_irq_parse_raw(struct device_node *parent, const __be32 *intspec,
 
 	pr_debug("of_irq_parse_raw: ipar=%s, size=%d\n", of_node_full_name(ipar), intsize);
 
-	if (ointsize != intsize)
+	if (out_irq->args_count != intsize)
 		return -EINVAL;
 
 	/* Look for this #address-cells. We have to implement the old linux
@@ -146,6 +147,21 @@ int of_irq_parse_raw(struct device_node *parent, const __be32 *intspec,
 
 	pr_debug(" -> addrsize=%d\n", addrsize);
 
+	/* If we were passed no "reg" property and we attempt to parse
+	 * an interrupt-map, then #address-cells must be 0.
+	 * Fail if it's not.
+	 */
+	if (addr == NULL && addrsize != 0) {
+		pr_debug(" -> no reg passed in when needed !\n");
+		return -EINVAL;
+	}
+
+	/* Precalculate the match array - this simplifies match loop */
+	for (i = 0; i < addrsize; i++)
+		initial_match_array[i] = addr[i];
+	for (i = 0; i < intsize; i++)
+		initial_match_array[addrsize + i] = cpu_to_be32(out_irq->args[i]);
+
 	/* Now start the actual "proper" walk of the interrupt tree */
 	while (ipar != NULL) {
 		/* Now check if cursor is an interrupt-controller and if it is
@@ -154,11 +170,6 @@ int of_irq_parse_raw(struct device_node *parent, const __be32 *intspec,
 		if (of_get_property(ipar, "interrupt-controller", NULL) !=
 				NULL) {
 			pr_debug(" -> got it !\n");
-			for (i = 0; i < intsize; i++)
-				out_irq->args[i] =
-						of_read_number(intspec +i, 1);
-			out_irq->args_count = intsize;
-			out_irq->np = ipar;
 			of_node_put(old);
 			return 0;
 		}
@@ -175,34 +186,16 @@ int of_irq_parse_raw(struct device_node *parent, const __be32 *intspec,
 
 		/* Look for a mask */
 		imask = of_get_property(ipar, "interrupt-map-mask", NULL);
-
-		/* If we were passed no "reg" property and we attempt to parse
-		 * an interrupt-map, then #address-cells must be 0.
-		 * Fail if it's not.
-		 */
-		if (addr == NULL && addrsize != 0) {
-			pr_debug(" -> no reg passed in when needed !\n");
-			goto fail;
-		}
+		if (!imask)
+			imask = dummy_imask;
 
 		/* Parse interrupt-map */
 		match = 0;
 		while (imaplen > (addrsize + intsize + 1) && !match) {
 			/* Compare specifiers */
 			match = 1;
-			for (i = 0; i < addrsize && match; ++i) {
-				__be32 mask = imask ? imask[i]
-						    : cpu_to_be32(0xffffffffu);
-				match = ((addr[i] ^ imap[i]) & mask) == 0;
-			}
-			for (; i < (addrsize + intsize) && match; ++i) {
-				__be32 mask = imask ? imask[i]
-						    : cpu_to_be32(0xffffffffu);
-				match =
-				   ((intspec[i-addrsize] ^ imap[i]) & mask) == 0;
-			}
-			imap += addrsize + intsize;
-			imaplen -= addrsize + intsize;
+			for (i = 0; i < (addrsize + intsize); i++, imaplen--)
+				match = !((match_array[i] ^ *imap++) & imask[i]);
 
 			pr_debug(" -> match=%d (imaplen=%d)\n", match, imaplen);
 
@@ -247,12 +240,18 @@ int of_irq_parse_raw(struct device_node *parent, const __be32 *intspec,
 		if (!match)
 			goto fail;
 
-		of_node_put(old);
-		old = of_node_get(newpar);
+		/*
+		 * Successfully parsed an interrrupt-map translation; copy new
+		 * interrupt specifier into the out_irq structure
+		 */
+		of_node_put(out_irq->np);
+		out_irq->np = of_node_get(newpar);
+
+		match_array = imap - newaddrsize - newintsize;
+		for (i = 0; i < newintsize; i++)
+			out_irq->args[i] = be32_to_cpup(imap - newintsize + i);
+		out_irq->args_count = intsize = newintsize;
 		addrsize = newaddrsize;
-		intsize = newintsize;
-		intspec = imap - intsize;
-		addr = intspec - addrsize;
 
 	skiplevel:
 		/* Iterate again with new parent */
@@ -263,7 +262,7 @@ int of_irq_parse_raw(struct device_node *parent, const __be32 *intspec,
 	}
  fail:
 	of_node_put(ipar);
-	of_node_put(old);
+	of_node_put(out_irq->np);
 	of_node_put(newpar);
 
 	return -EINVAL;
@@ -276,15 +275,16 @@ EXPORT_SYMBOL_GPL(of_irq_parse_raw);
  * @index: index of the interrupt to resolve
  * @out_irq: structure of_irq filled by this function
  *
- * This function resolves an interrupt, walking the tree, for a given
- * device-tree node. It's the high level pendant to of_irq_parse_raw().
+ * This function resolves an interrupt for a node by walking the interrupt tree,
+ * finding which interrupt controller node it is attached to, and returning the
+ * interrupt specifier that can be used to retrieve a Linux IRQ number.
  */
 int of_irq_parse_one(struct device_node *device, int index, struct of_phandle_args *out_irq)
 {
 	struct device_node *p;
 	const __be32 *intspec, *tmp, *addr;
 	u32 intsize, intlen;
-	int res = -EINVAL;
+	int i, res = -EINVAL;
 
 	pr_debug("of_irq_parse_one: dev=%s, index=%d\n", of_node_full_name(device), index);
 
@@ -320,9 +320,15 @@ int of_irq_parse_one(struct device_node *device, int index, struct of_phandle_ar
 	if ((index + 1) * intsize > intlen)
 		goto out;
 
-	/* Get new specifier and map it */
-	res = of_irq_parse_raw(p, intspec + index * intsize, intsize,
-			     addr, out_irq);
+	/* Copy intspec into irq structure */
+	intspec += index * intsize;
+	out_irq->np = p;
+	out_irq->args_count = intsize;
+	for (i = 0; i < intsize; i++)
+		out_irq->args[i] = be32_to_cpup(intspec++);
+
+	/* Check if there are any interrupt-map translations to process */
+	res = of_irq_parse_raw(addr, out_irq);
  out:
 	of_node_put(p);
 	return res;

commit e6d30ab1e7d1281784672c0fc2ffa385cfb7279e
Author: Grant Likely <grant.likely@linaro.org>
Date:   Sun Sep 15 16:55:53 2013 +0100

    of/irq: simplify args to irq_create_of_mapping
    
    All the callers of irq_create_of_mapping() pass the contents of a struct
    of_phandle_args structure to the function. Since all the callers already
    have an of_phandle_args pointer, why not pass it directly to
    irq_create_of_mapping()?
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Acked-by: Michal Simek <monstr@monstr.eu>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index a7db38a63403..84184c44e8db 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -41,7 +41,7 @@ unsigned int irq_of_parse_and_map(struct device_node *dev, int index)
 	if (of_irq_parse_one(dev, index, &oirq))
 		return 0;
 
-	return irq_create_of_mapping(oirq.np, oirq.args, oirq.args_count);
+	return irq_create_of_mapping(&oirq);
 }
 EXPORT_SYMBOL_GPL(irq_of_parse_and_map);
 

commit 530210c7814e83564c7ca7bca8192515042c0b63
Author: Grant Likely <grant.likely@linaro.org>
Date:   Sun Sep 15 16:39:11 2013 +0100

    of/irq: Replace of_irq with of_phandle_args
    
    struct of_irq and struct of_phandle_args are exactly the same structure.
    This patch makes the kernel use of_phandle_args everywhere. This in
    itself isn't a big deal, but it makes some follow-on patches simpler.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Acked-by: Michal Simek <monstr@monstr.eu>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 410aa2415f42..a7db38a63403 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -36,13 +36,12 @@
  */
 unsigned int irq_of_parse_and_map(struct device_node *dev, int index)
 {
-	struct of_irq oirq;
+	struct of_phandle_args oirq;
 
 	if (of_irq_parse_one(dev, index, &oirq))
 		return 0;
 
-	return irq_create_of_mapping(oirq.controller, oirq.specifier,
-				     oirq.size);
+	return irq_create_of_mapping(oirq.np, oirq.args, oirq.args_count);
 }
 EXPORT_SYMBOL_GPL(irq_of_parse_and_map);
 
@@ -94,7 +93,7 @@ struct device_node *of_irq_find_parent(struct device_node *child)
  * node exist for the parent.
  */
 int of_irq_parse_raw(struct device_node *parent, const __be32 *intspec,
-		   u32 ointsize, const __be32 *addr, struct of_irq *out_irq)
+		   u32 ointsize, const __be32 *addr, struct of_phandle_args *out_irq)
 {
 	struct device_node *ipar, *tnode, *old = NULL, *newpar = NULL;
 	const __be32 *tmp, *imap, *imask;
@@ -156,10 +155,10 @@ int of_irq_parse_raw(struct device_node *parent, const __be32 *intspec,
 				NULL) {
 			pr_debug(" -> got it !\n");
 			for (i = 0; i < intsize; i++)
-				out_irq->specifier[i] =
+				out_irq->args[i] =
 						of_read_number(intspec +i, 1);
-			out_irq->size = intsize;
-			out_irq->controller = ipar;
+			out_irq->args_count = intsize;
+			out_irq->np = ipar;
 			of_node_put(old);
 			return 0;
 		}
@@ -280,7 +279,7 @@ EXPORT_SYMBOL_GPL(of_irq_parse_raw);
  * This function resolves an interrupt, walking the tree, for a given
  * device-tree node. It's the high level pendant to of_irq_parse_raw().
  */
-int of_irq_parse_one(struct device_node *device, int index, struct of_irq *out_irq)
+int of_irq_parse_one(struct device_node *device, int index, struct of_phandle_args *out_irq)
 {
 	struct device_node *p;
 	const __be32 *intspec, *tmp, *addr;

commit 0c02c8007ea5554d028f99fd3e29fc201fdeeab3
Author: Grant Likely <grant.likely@linaro.org>
Date:   Thu Sep 19 11:22:36 2013 -0500

    of/irq: Rename of_irq_map_* functions to of_irq_parse_*
    
    The OF irq handling code has been overloading the term 'map' to refer to
    both parsing the data in the device tree and mapping it to the internal
    linux irq system. This is probably because the device tree does have the
    concept of an 'interrupt-map' function for translating interrupt
    references from one node to another, but 'map' is still confusing when
    the primary purpose of some of the functions are to parse the DT data.
    
    This patch renames all the of_irq_map_* functions to of_irq_parse_*
    which makes it clear that there is a difference between the parsing
    phase and the mapping phase. Kernel code can make use of just the
    parsing or just the mapping support as needed by the subsystem.
    
    The patch was generated mechanically with a handful of sed commands.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Acked-by: Michal Simek <monstr@monstr.eu>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 90068f914911..410aa2415f42 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -31,14 +31,14 @@
  * @dev: Device node of the device whose interrupt is to be mapped
  * @index: Index of the interrupt to map
  *
- * This function is a wrapper that chains of_irq_map_one() and
+ * This function is a wrapper that chains of_irq_parse_one() and
  * irq_create_of_mapping() to make things easier to callers
  */
 unsigned int irq_of_parse_and_map(struct device_node *dev, int index)
 {
 	struct of_irq oirq;
 
-	if (of_irq_map_one(dev, index, &oirq))
+	if (of_irq_parse_one(dev, index, &oirq))
 		return 0;
 
 	return irq_create_of_mapping(oirq.controller, oirq.specifier,
@@ -79,7 +79,7 @@ struct device_node *of_irq_find_parent(struct device_node *child)
 }
 
 /**
- * of_irq_map_raw - Low level interrupt tree parsing
+ * of_irq_parse_raw - Low level interrupt tree parsing
  * @parent:	the device interrupt parent
  * @intspec:	interrupt specifier ("interrupts" property of the device)
  * @ointsize:   size of the passed in interrupt specifier
@@ -93,7 +93,7 @@ struct device_node *of_irq_find_parent(struct device_node *child)
  * properties, for example when resolving PCI interrupts when no device
  * node exist for the parent.
  */
-int of_irq_map_raw(struct device_node *parent, const __be32 *intspec,
+int of_irq_parse_raw(struct device_node *parent, const __be32 *intspec,
 		   u32 ointsize, const __be32 *addr, struct of_irq *out_irq)
 {
 	struct device_node *ipar, *tnode, *old = NULL, *newpar = NULL;
@@ -101,7 +101,7 @@ int of_irq_map_raw(struct device_node *parent, const __be32 *intspec,
 	u32 intsize = 1, addrsize, newintsize = 0, newaddrsize = 0;
 	int imaplen, match, i;
 
-	pr_debug("of_irq_map_raw: par=%s,intspec=[0x%08x 0x%08x...],ointsize=%d\n",
+	pr_debug("of_irq_parse_raw: par=%s,intspec=[0x%08x 0x%08x...],ointsize=%d\n",
 		 of_node_full_name(parent), be32_to_cpup(intspec),
 		 be32_to_cpup(intspec + 1), ointsize);
 
@@ -126,7 +126,7 @@ int of_irq_map_raw(struct device_node *parent, const __be32 *intspec,
 		goto fail;
 	}
 
-	pr_debug("of_irq_map_raw: ipar=%s, size=%d\n", of_node_full_name(ipar), intsize);
+	pr_debug("of_irq_parse_raw: ipar=%s, size=%d\n", of_node_full_name(ipar), intsize);
 
 	if (ointsize != intsize)
 		return -EINVAL;
@@ -269,29 +269,29 @@ int of_irq_map_raw(struct device_node *parent, const __be32 *intspec,
 
 	return -EINVAL;
 }
-EXPORT_SYMBOL_GPL(of_irq_map_raw);
+EXPORT_SYMBOL_GPL(of_irq_parse_raw);
 
 /**
- * of_irq_map_one - Resolve an interrupt for a device
+ * of_irq_parse_one - Resolve an interrupt for a device
  * @device: the device whose interrupt is to be resolved
  * @index: index of the interrupt to resolve
  * @out_irq: structure of_irq filled by this function
  *
  * This function resolves an interrupt, walking the tree, for a given
- * device-tree node. It's the high level pendant to of_irq_map_raw().
+ * device-tree node. It's the high level pendant to of_irq_parse_raw().
  */
-int of_irq_map_one(struct device_node *device, int index, struct of_irq *out_irq)
+int of_irq_parse_one(struct device_node *device, int index, struct of_irq *out_irq)
 {
 	struct device_node *p;
 	const __be32 *intspec, *tmp, *addr;
 	u32 intsize, intlen;
 	int res = -EINVAL;
 
-	pr_debug("of_irq_map_one: dev=%s, index=%d\n", of_node_full_name(device), index);
+	pr_debug("of_irq_parse_one: dev=%s, index=%d\n", of_node_full_name(device), index);
 
 	/* OldWorld mac stuff is "special", handle out of line */
 	if (of_irq_workarounds & OF_IMAP_OLDWORLD_MAC)
-		return of_irq_map_oldworld(device, index, out_irq);
+		return of_irq_parse_oldworld(device, index, out_irq);
 
 	/* Get the interrupts property */
 	intspec = of_get_property(device, "interrupts", &intlen);
@@ -322,13 +322,13 @@ int of_irq_map_one(struct device_node *device, int index, struct of_irq *out_irq
 		goto out;
 
 	/* Get new specifier and map it */
-	res = of_irq_map_raw(p, intspec + index * intsize, intsize,
+	res = of_irq_parse_raw(p, intspec + index * intsize, intsize,
 			     addr, out_irq);
  out:
 	of_node_put(p);
 	return res;
 }
-EXPORT_SYMBOL_GPL(of_irq_map_one);
+EXPORT_SYMBOL_GPL(of_irq_parse_one);
 
 /**
  * of_irq_to_resource - Decode a node's IRQ and return it as a resource

commit 4a43d686fe336cc0e955c4400ba4d3fcff788786
Author: Tomasz Figa <tomasz.figa@gmail.com>
Date:   Sat Sep 28 19:52:51 2013 +0200

    of/irq: Pass trigger type in IRQ resource flags
    
    Some drivers might rely on availability of trigger flags in IRQ
    resource, for example to configure the hardware for particular interrupt
    type. However current code creating IRQ resources from data in device
    tree does not configure trigger flags in resulting resources.
    
    This patch tries to solve the problem, based on the fact that
    irq_of_parse_and_map() configures the trigger based on DT interrupt
    specifier and IRQD_TRIGGER_* flags are consistent with IORESOURCE_IRQ_*,
    and we can get correct trigger flags by calling irqd_get_trigger_type()
    after mapping the interrupt.
    
    Signed-off-by: Tomasz Figa <tomasz.figa@gmail.com>
    [grant.likely: Merged the two assignments to r->flags]
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index f5fa5d84aa06..90068f914911 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -354,7 +354,7 @@ int of_irq_to_resource(struct device_node *dev, int index, struct resource *r)
 					      &name);
 
 		r->start = r->end = irq;
-		r->flags = IORESOURCE_IRQ;
+		r->flags = IORESOURCE_IRQ | irqd_get_trigger_type(irq_get_irq_data(irq));
 		r->name = name ? name : of_node_full_name(dev);
 	}
 

commit 8804827b305dbc1c6e24f2b36f1df4a9856b80e8
Author: Grant Likely <grant.likely@linaro.org>
Date:   Thu Sep 19 11:01:52 2013 -0500

    of: Fix dereferencing node name in debug output to be safe
    
    Several locations in the of_address and of_irq code dereference the
    full_name parameter from a device_node pointer without checking if the
    pointer is valid.  This patch switches to use of_node_full_name() which
    always checks the pointer.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 1752988d6aa8..f5fa5d84aa06 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -102,7 +102,7 @@ int of_irq_map_raw(struct device_node *parent, const __be32 *intspec,
 	int imaplen, match, i;
 
 	pr_debug("of_irq_map_raw: par=%s,intspec=[0x%08x 0x%08x...],ointsize=%d\n",
-		 parent->full_name, be32_to_cpup(intspec),
+		 of_node_full_name(parent), be32_to_cpup(intspec),
 		 be32_to_cpup(intspec + 1), ointsize);
 
 	ipar = of_node_get(parent);
@@ -126,7 +126,7 @@ int of_irq_map_raw(struct device_node *parent, const __be32 *intspec,
 		goto fail;
 	}
 
-	pr_debug("of_irq_map_raw: ipar=%s, size=%d\n", ipar->full_name, intsize);
+	pr_debug("of_irq_map_raw: ipar=%s, size=%d\n", of_node_full_name(ipar), intsize);
 
 	if (ointsize != intsize)
 		return -EINVAL;
@@ -287,7 +287,7 @@ int of_irq_map_one(struct device_node *device, int index, struct of_irq *out_irq
 	u32 intsize, intlen;
 	int res = -EINVAL;
 
-	pr_debug("of_irq_map_one: dev=%s, index=%d\n", device->full_name, index);
+	pr_debug("of_irq_map_one: dev=%s, index=%d\n", of_node_full_name(device), index);
 
 	/* OldWorld mac stuff is "special", handle out of line */
 	if (of_irq_workarounds & OF_IMAP_OLDWORLD_MAC)
@@ -355,7 +355,7 @@ int of_irq_to_resource(struct device_node *dev, int index, struct resource *r)
 
 		r->start = r->end = irq;
 		r->flags = IORESOURCE_IRQ;
-		r->name = name ? name : dev->full_name;
+		r->name = name ? name : of_node_full_name(dev);
 	}
 
 	return irq;

commit d84ff46a9e19fe27ac6e4d7740ca0429c28e778a
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Sat Aug 31 09:44:10 2013 +0800

    irq/of: Fix comment typo for irq_of_parse_and_map
    
    Fix trivial comment typo for irq_of_parse_and_map().
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 1264923ade0f..1752988d6aa8 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -28,7 +28,7 @@
 
 /**
  * irq_of_parse_and_map - Parse and map an interrupt into linux virq space
- * @device: Device node of the device whose interrupt is to be mapped
+ * @dev: Device node of the device whose interrupt is to be mapped
  * @index: Index of the interrupt to map
  *
  * This function is a wrapper that chains of_irq_map_one() and

commit cf9e2368655d86cd800e4d9fe65a407b39d29373
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Thu Jul 18 12:24:10 2013 +0200

    of/irq: init struct resource to 0 in of_irq_to_resource()
    
    It almost does not matter because most users use only the ->start member
    of the struct. However if this struct is passed to a platform device
    which is then added via platform_device_add() then the ->parent member is
    also used.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 5c645c7227b8..1264923ade0f 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -345,6 +345,7 @@ int of_irq_to_resource(struct device_node *dev, int index, struct resource *r)
 	if (r && irq) {
 		const char *name = NULL;
 
+		memset(r, 0, sizeof(*r));
 		/*
 		 * Get optional "interrupts-names" property to add a name
 		 * to the resource.

commit c0cdfaa0a5e7a346ac2f661f63f543cdc5f7cbbe
Author: Axel Lin <axel.lin@ingics.com>
Date:   Sun Jun 23 15:50:07 2013 +0800

    of/irq: Avoid calling list_first_entry() for empty list
    
    list_first_entry() expects the list is not empty, we need to check if list is
    empty before calling list_first_entry(). Thus use list_first_entry_or_null()
    instead of list_first_entry().
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index a3c1c5aae6a9..5c645c7227b8 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -482,8 +482,9 @@ void __init of_irq_init(const struct of_device_id *matches)
 		}
 
 		/* Get the next pending parent that might have children */
-		desc = list_first_entry(&intc_parent_list, typeof(*desc), list);
-		if (list_empty(&intc_parent_list) || !desc) {
+		desc = list_first_entry_or_null(&intc_parent_list,
+						typeof(*desc), list);
+		if (!desc) {
 			pr_err("of_irq_init: children remain, but no parents\n");
 			break;
 		}

commit d2e4151821dc4d1db414de287f6e3503c1718815
Author: Kim Phillips <kim.phillips@freescale.com>
Date:   Mon Oct 8 19:42:04 2012 -0500

    of/irq: sparse fixes
    
    drivers/of/irq.c:195:57: warning: restricted __be32 degrades to integer
    drivers/of/irq.c:196:51: warning: restricted __be32 degrades to integer
    drivers/of/irq.c:199:57: warning: restricted __be32 degrades to integer
    drivers/of/irq.c:201:58: warning: restricted __be32 degrades to integer
    drivers/of/irq.c:470:37: warning: incorrect type in assignment (different modifiers)
    drivers/of/irq.c:470:37:    expected int ( *[usertype] irq_init_cb )( ... )
    drivers/of/irq.c:470:37:    got void const *const data
    drivers/of/irq.c:96:5: error: symbol 'of_irq_map_raw' redeclared with different type (originally declared at include/linux/of_irq.h:61) - incompatible argument 2 (different base types)
    
    drivers/of/of_pci_irq.c:91:40: warning: incorrect type in argument 2 (different base types)
    drivers/of/of_pci_irq.c:91:40:    expected unsigned int const [usertype] *intspec
    drivers/of/of_pci_irq.c:91:40:    got restricted __be32 *<noident>
    drivers/of/of_pci_irq.c:91:53: warning: incorrect type in argument 4 (different base types)
    drivers/of/of_pci_irq.c:91:53:    expected unsigned int const [usertype] *addr
    drivers/of/of_pci_irq.c:91:53:    got restricted __be32 *<noident>
    
    Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index a23ec7779997..a3c1c5aae6a9 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -192,11 +192,13 @@ int of_irq_map_raw(struct device_node *parent, const __be32 *intspec,
 			/* Compare specifiers */
 			match = 1;
 			for (i = 0; i < addrsize && match; ++i) {
-				u32 mask = imask ? imask[i] : 0xffffffffu;
+				__be32 mask = imask ? imask[i]
+						    : cpu_to_be32(0xffffffffu);
 				match = ((addr[i] ^ imap[i]) & mask) == 0;
 			}
 			for (; i < (addrsize + intsize) && match; ++i) {
-				u32 mask = imask ? imask[i] : 0xffffffffu;
+				__be32 mask = imask ? imask[i]
+						    : cpu_to_be32(0xffffffffu);
 				match =
 				   ((intspec[i-addrsize] ^ imap[i]) & mask) == 0;
 			}
@@ -465,7 +467,7 @@ void __init of_irq_init(const struct of_device_id *matches)
 			pr_debug("of_irq_init: init %s @ %p, parent %p\n",
 				 match->compatible,
 				 desc->dev, desc->interrupt_parent);
-			irq_init_cb = match->data;
+			irq_init_cb = (of_irq_init_cb_t)match->data;
 			ret = irq_init_cb(desc->dev, desc->interrupt_parent);
 			if (ret) {
 				kfree(desc);

commit a4f8bf220e415318c739243aaeb2471cf5e8c911
Author: John Crispin <blogic@openwrt.org>
Date:   Sun Aug 26 09:13:09 2012 +0200

    DT: export of_irq_to_resource_table()
    
    Trivial patch that exports the of_irq_to_resource_table() symbol so that
    modules can use it.
    
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index ff8ab7b27373..a23ec7779997 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -392,6 +392,7 @@ int of_irq_to_resource_table(struct device_node *dev, struct resource *res,
 
 	return i;
 }
+EXPORT_SYMBOL_GPL(of_irq_to_resource_table);
 
 struct intc_desc {
 	struct list_head	list;

commit 74a7f08448adea6cb47cd9b260c98ff168117e92
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Jun 15 11:50:25 2012 -0600

    devicetree: add helper inline for retrieving a node's full name
    
    The pattern (np ? np->full_name : "<none>") is rather common in the
    kernel, but can also make for quite long lines.  This patch adds a new
    inline function, of_node_full_name() so that the test for a valid node
    pointer doesn't need to be open coded at all call sites.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 9cf00602f566..ff8ab7b27373 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -255,7 +255,7 @@ int of_irq_map_raw(struct device_node *parent, const __be32 *intspec,
 
 	skiplevel:
 		/* Iterate again with new parent */
-		pr_debug(" -> new parent: %s\n", newpar ? newpar->full_name : "<>");
+		pr_debug(" -> new parent: %s\n", of_node_full_name(newpar));
 		of_node_put(ipar);
 		ipar = newpar;
 		newpar = NULL;

commit 661db794eb8179c7bea02f159bb691a2fff4a8e0
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Mon Dec 5 15:23:56 2011 +0100

    of/irq: Add interrupts-names property to name an irq resource
    
    Add a interrupts-names property to allow the possibility to provide a name
    to any interrupts entries.  If the name is available, use it to name the
    resource, otherwise keep the device full name.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: Rob Herring <rob.herring@calxeda.com>
    [grant.likely: use "interrupt-names" and tidy documentation]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 0f0cfa3bca30..9cf00602f566 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -341,9 +341,18 @@ int of_irq_to_resource(struct device_node *dev, int index, struct resource *r)
 	/* Only dereference the resource if both the
 	 * resource and the irq are valid. */
 	if (r && irq) {
+		const char *name = NULL;
+
+		/*
+		 * Get optional "interrupts-names" property to add a name
+		 * to the resource.
+		 */
+		of_property_read_string_index(dev, "interrupt-names", index,
+					      &name);
+
 		r->start = r->end = irq;
 		r->flags = IORESOURCE_IRQ;
-		r->name = dev->full_name;
+		r->name = name ? name : dev->full_name;
 	}
 
 	return irq;

commit 77a7300abad7fe01891b400e88d746f97307ee5a
Author: Anton Vorontsov <anton.vorontsov@linaro.org>
Date:   Wed Dec 7 03:16:26 2011 +0400

    of/irq: Get rid of NO_IRQ usage
    
    PPC32/64 defines NO_IRQ to zero, so no problems expected.
    ARM defines NO_IRQ to -1, but OF code relies on IRQ domains support,
    which returns correct ('0') value in 'no irq' case. So everything
    should be fine.
    
    Other arches might break if some of their OF drivers rely on NO_IRQ
    being not 0. If so, the drivers must be fixed, finally.
    
    [ Rob Herring points out that microblaze should be fixed, and has posted
      a patch for testing for that.   - Linus ]
    
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 19c0115092dd..0f0cfa3bca30 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -26,11 +26,6 @@
 #include <linux/string.h>
 #include <linux/slab.h>
 
-/* For archs that don't support NO_IRQ (such as x86), provide a dummy value */
-#ifndef NO_IRQ
-#define NO_IRQ 0
-#endif
-
 /**
  * irq_of_parse_and_map - Parse and map an interrupt into linux virq space
  * @device: Device node of the device whose interrupt is to be mapped
@@ -44,7 +39,7 @@ unsigned int irq_of_parse_and_map(struct device_node *dev, int index)
 	struct of_irq oirq;
 
 	if (of_irq_map_one(dev, index, &oirq))
-		return NO_IRQ;
+		return 0;
 
 	return irq_create_of_mapping(oirq.controller, oirq.specifier,
 				     oirq.size);
@@ -345,7 +340,7 @@ int of_irq_to_resource(struct device_node *dev, int index, struct resource *r)
 
 	/* Only dereference the resource if both the
 	 * resource and the irq are valid. */
-	if (r && irq != NO_IRQ) {
+	if (r && irq) {
 		r->start = r->end = irq;
 		r->flags = IORESOURCE_IRQ;
 		r->name = dev->full_name;
@@ -363,7 +358,7 @@ int of_irq_count(struct device_node *dev)
 {
 	int nr = 0;
 
-	while (of_irq_to_resource(dev, nr, NULL) != NO_IRQ)
+	while (of_irq_to_resource(dev, nr, NULL))
 		nr++;
 
 	return nr;
@@ -383,7 +378,7 @@ int of_irq_to_resource_table(struct device_node *dev, struct resource *res,
 	int i;
 
 	for (i = 0; i < nr_irqs; i++, res++)
-		if (of_irq_to_resource(dev, i, res) == NO_IRQ)
+		if (!of_irq_to_resource(dev, i, res))
 			break;
 
 	return i;

commit d7fb6d0adb86ed1c5290e754092a5a1e3de76ee9
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Sun Nov 27 20:16:33 2011 -0600

    of/irq: of_irq_init: add check for parent equal to child node
    
    With the revert of "of/irq: of_irq_find_parent: check for parent equal to
    child" (dc9372808412edb), we need another way to handle parent node equal
    to the child node. This can simply be handled in of_irq_init by checking
    for this condition.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Tested-by: Pawel Moll <pawel.moll@arm.com>
    Tested-by: Stephen Warren <swarren@nvidia.com>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 791270b8bd1c..19c0115092dd 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -424,6 +424,8 @@ void __init of_irq_init(const struct of_device_id *matches)
 
 		desc->dev = np;
 		desc->interrupt_parent = of_irq_find_parent(np);
+		if (desc->interrupt_parent == np)
+			desc->interrupt_parent = NULL;
 		list_add_tail(&desc->list, &intc_desc_list);
 	}
 

commit b4bbb02934e4511d9083f15c23e90703482e84ad
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 22 15:09:20 2011 -0800

    Revert "of/irq: of_irq_find_parent: check for parent equal to child"
    
    This reverts commit dc9372808412edbc653a675a526c2ee6c0c14a91.
    
    As requested by Ben Herrenschmidt:
      "This breaks some powerpc platforms at least.  The practice of having
       a node provide an explicit "interrupt-parent" property pointing to
       itself is an old trick that we've used in the past to allow a
       device-node to have interrupts routed to different controllers.
    
       In that case, the node also contains an interrupt-map, so the node is
       its own parent, the interrupt resolution hits the map, which then can
       route each individual interrupt to a different parent."
    
    Grant says:
      "Ah, nuts, yes that is broken then.  Yes, please revert the commit and
       Rob & I will come up with a better solution.
    
       Rob, I think it can be done by explicitly checking for np ==
       desc->interrupt_parent in of_irq_init() instead of relying on
       of_irq_find_parent() returning NULL."
    
    Requested-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: devicetree-discuss@lists.ozlabs.org
    Cc: linuxppc-dev <linuxppc-dev@lists.ozlabs.org>
    Cc: Tanmay Inamdar <tinamdar@apm.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 6d3dd3988d0f..791270b8bd1c 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -60,27 +60,27 @@ EXPORT_SYMBOL_GPL(irq_of_parse_and_map);
  */
 struct device_node *of_irq_find_parent(struct device_node *child)
 {
-	struct device_node *p, *c = child;
+	struct device_node *p;
 	const __be32 *parp;
 
-	if (!of_node_get(c))
+	if (!of_node_get(child))
 		return NULL;
 
 	do {
-		parp = of_get_property(c, "interrupt-parent", NULL);
+		parp = of_get_property(child, "interrupt-parent", NULL);
 		if (parp == NULL)
-			p = of_get_parent(c);
+			p = of_get_parent(child);
 		else {
 			if (of_irq_workarounds & OF_IMAP_NO_PHANDLE)
 				p = of_node_get(of_irq_dflt_pic);
 			else
 				p = of_find_node_by_phandle(be32_to_cpup(parp));
 		}
-		of_node_put(c);
-		c = p;
+		of_node_put(child);
+		child = p;
 	} while (p && of_get_property(p, "#interrupt-cells", NULL) == NULL);
 
-	return (p == child) ? NULL : p;
+	return p;
 }
 
 /**

commit 367069f16e32e188d4687fe2c3e30f2ca583836f
Merge: 81a3c10ce8a7 c72dbae97140
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 1 21:02:35 2011 -0700

    Merge branch 'next/dt' of git://git.linaro.org/people/arnd/arm-soc
    
    * 'next/dt' of git://git.linaro.org/people/arnd/arm-soc:
      ARM: gic: use module.h instead of export.h
      ARM: gic: fix irq_alloc_descs handling for sparse irq
      ARM: gic: add OF based initialization
      ARM: gic: add irq_domain support
      irq: support domains with non-zero hwirq base
      of/irq: introduce of_irq_init
      ARM: at91: add at91sam9g20 and Calao USB A9G20 DT support
      ARM: at91: dt: at91sam9g45 family and board device tree files
      arm/mx5: add device tree support for imx51 babbage
      arm/mx5: add device tree support for imx53 boards
      ARM: msm: Add devicetree support for msm8660-surf
      msm_serial: Add devicetree support
      msm_serial: Use relative resources for iomem
    
    Fix up conflicts in arch/arm/mach-at91/{at91sam9260.c,at91sam9g45.c}

commit c71a54b0820179e53483d5220cdef1a0df8d5bd1
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Tue Sep 20 15:13:50 2011 -0500

    of/irq: introduce of_irq_init
    
    of_irq_init will scan the devicetree for matching interrupt controller
    nodes. Then it calls an initialization function for each found controller
    in the proper order with parent nodes initialized before child nodes.
    
    Based on initial pseudo code from Grant Likely.
    
    Changes in v4:
    - Drop unnecessary empty list check
    - Be more verbose on errors
    - Simplify "if (!desc) WARN_ON(1)" to "if (WARN_ON(!desc))"
    
    Changes in v3:
    - add missing kfree's found by Jamie
    - Implement Grant's comments to simplify the init loop
    - fix function comments
    
    Changes in v2:
    - Complete re-write of list searching code from Grant Likely
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Reviewed-by: Jamie Iles <jamie@jamieiles.com>
    Tested-by: Thomas Abraham <thomas.abraham@linaro.org>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 9f689f1da0fc..791270b8bd1c 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -19,10 +19,12 @@
  */
 
 #include <linux/errno.h>
+#include <linux/list.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_irq.h>
 #include <linux/string.h>
+#include <linux/slab.h>
 
 /* For archs that don't support NO_IRQ (such as x86), provide a dummy value */
 #ifndef NO_IRQ
@@ -386,3 +388,108 @@ int of_irq_to_resource_table(struct device_node *dev, struct resource *res,
 
 	return i;
 }
+
+struct intc_desc {
+	struct list_head	list;
+	struct device_node	*dev;
+	struct device_node	*interrupt_parent;
+};
+
+/**
+ * of_irq_init - Scan and init matching interrupt controllers in DT
+ * @matches: 0 terminated array of nodes to match and init function to call
+ *
+ * This function scans the device tree for matching interrupt controller nodes,
+ * and calls their initialization functions in order with parents first.
+ */
+void __init of_irq_init(const struct of_device_id *matches)
+{
+	struct device_node *np, *parent = NULL;
+	struct intc_desc *desc, *temp_desc;
+	struct list_head intc_desc_list, intc_parent_list;
+
+	INIT_LIST_HEAD(&intc_desc_list);
+	INIT_LIST_HEAD(&intc_parent_list);
+
+	for_each_matching_node(np, matches) {
+		if (!of_find_property(np, "interrupt-controller", NULL))
+			continue;
+		/*
+		 * Here, we allocate and populate an intc_desc with the node
+		 * pointer, interrupt-parent device_node etc.
+		 */
+		desc = kzalloc(sizeof(*desc), GFP_KERNEL);
+		if (WARN_ON(!desc))
+			goto err;
+
+		desc->dev = np;
+		desc->interrupt_parent = of_irq_find_parent(np);
+		list_add_tail(&desc->list, &intc_desc_list);
+	}
+
+	/*
+	 * The root irq controller is the one without an interrupt-parent.
+	 * That one goes first, followed by the controllers that reference it,
+	 * followed by the ones that reference the 2nd level controllers, etc.
+	 */
+	while (!list_empty(&intc_desc_list)) {
+		/*
+		 * Process all controllers with the current 'parent'.
+		 * First pass will be looking for NULL as the parent.
+		 * The assumption is that NULL parent means a root controller.
+		 */
+		list_for_each_entry_safe(desc, temp_desc, &intc_desc_list, list) {
+			const struct of_device_id *match;
+			int ret;
+			of_irq_init_cb_t irq_init_cb;
+
+			if (desc->interrupt_parent != parent)
+				continue;
+
+			list_del(&desc->list);
+			match = of_match_node(matches, desc->dev);
+			if (WARN(!match->data,
+			    "of_irq_init: no init function for %s\n",
+			    match->compatible)) {
+				kfree(desc);
+				continue;
+			}
+
+			pr_debug("of_irq_init: init %s @ %p, parent %p\n",
+				 match->compatible,
+				 desc->dev, desc->interrupt_parent);
+			irq_init_cb = match->data;
+			ret = irq_init_cb(desc->dev, desc->interrupt_parent);
+			if (ret) {
+				kfree(desc);
+				continue;
+			}
+
+			/*
+			 * This one is now set up; add it to the parent list so
+			 * its children can get processed in a subsequent pass.
+			 */
+			list_add_tail(&desc->list, &intc_parent_list);
+		}
+
+		/* Get the next pending parent that might have children */
+		desc = list_first_entry(&intc_parent_list, typeof(*desc), list);
+		if (list_empty(&intc_parent_list) || !desc) {
+			pr_err("of_irq_init: children remain, but no parents\n");
+			break;
+		}
+		list_del(&desc->list);
+		parent = desc->dev;
+		kfree(desc);
+	}
+
+	list_for_each_entry_safe(desc, temp_desc, &intc_parent_list, list) {
+		list_del(&desc->list);
+		kfree(desc);
+	}
+err:
+	list_for_each_entry_safe(desc, temp_desc, &intc_desc_list, list) {
+		list_del(&desc->list);
+		kfree(desc);
+	}
+}

commit dc9372808412edbc653a675a526c2ee6c0c14a91
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Tue Sep 20 13:02:54 2011 -0500

    of/irq: of_irq_find_parent: check for parent equal to child
    
    An interrupt controller may often implicitly inherit itself from a parent
    node when in fact the controller is the interrupt root controller. Guard
    against the case of child == parent and return NULL in this case.
    
    This can also be fixed by adding an explicit "interrupt-parent;" to a root
    interrupt controller node.
    
    Based on code from Grant Likely.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 9f689f1da0fc..6a5b5e777dd2 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -58,27 +58,27 @@ EXPORT_SYMBOL_GPL(irq_of_parse_and_map);
  */
 struct device_node *of_irq_find_parent(struct device_node *child)
 {
-	struct device_node *p;
+	struct device_node *p, *c = child;
 	const __be32 *parp;
 
-	if (!of_node_get(child))
+	if (!of_node_get(c))
 		return NULL;
 
 	do {
-		parp = of_get_property(child, "interrupt-parent", NULL);
+		parp = of_get_property(c, "interrupt-parent", NULL);
 		if (parp == NULL)
-			p = of_get_parent(child);
+			p = of_get_parent(c);
 		else {
 			if (of_irq_workarounds & OF_IMAP_NO_PHANDLE)
 				p = of_node_get(of_irq_dflt_pic);
 			else
 				p = of_find_node_by_phandle(be32_to_cpup(parp));
 		}
-		of_node_put(child);
-		child = p;
+		of_node_put(c);
+		c = p;
 	} while (p && of_get_property(p, "#interrupt-cells", NULL) == NULL);
 
-	return p;
+	return (p == child) ? NULL : p;
 }
 
 /**

commit 0b2e9a8e10ad2d191e5c37e77f1ce23e148e7a0b
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Thu Apr 14 22:31:57 2011 +0000

    of: Export of_irq_find_parent()
    
    We have platform code that needs to find a node's interrupt parent, so
    export of_irq_find_parent() so we can use it.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 75b0d3cb7676..9f689f1da0fc 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -56,7 +56,7 @@ EXPORT_SYMBOL_GPL(irq_of_parse_and_map);
  * Returns a pointer to the interrupt parent node, or NULL if the interrupt
  * parent could not be determined.
  */
-static struct device_node *of_irq_find_parent(struct device_node *child)
+struct device_node *of_irq_find_parent(struct device_node *child)
 {
 	struct device_node *p;
 	const __be32 *parp;

commit 52f6537cb2f0b461a9ce3457c01a6cfa2ae0bb22
Author: Andres Salomon <dilinger@queued.net>
Date:   Sun Oct 10 21:35:05 2010 -0600

    of/irq: remove references to NO_IRQ in drivers/of/platform.c
    
    Instead of referencing NO_IRQ in platform.c, define some helper functions
    in irq.c to call instead from platform.c.  Keep NO_IRQ usage local to
    irq.c, and define NO_IRQ if not defined in headers.
    
    Signed-off-by: Andres Salomon <dilinger@queued.net>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 6e595e5a3977..75b0d3cb7676 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -24,6 +24,11 @@
 #include <linux/of_irq.h>
 #include <linux/string.h>
 
+/* For archs that don't support NO_IRQ (such as x86), provide a dummy value */
+#ifndef NO_IRQ
+#define NO_IRQ 0
+#endif
+
 /**
  * irq_of_parse_and_map - Parse and map an interrupt into linux virq space
  * @device: Device node of the device whose interrupt is to be mapped
@@ -347,3 +352,37 @@ int of_irq_to_resource(struct device_node *dev, int index, struct resource *r)
 	return irq;
 }
 EXPORT_SYMBOL_GPL(of_irq_to_resource);
+
+/**
+ * of_irq_count - Count the number of IRQs a node uses
+ * @dev: pointer to device tree node
+ */
+int of_irq_count(struct device_node *dev)
+{
+	int nr = 0;
+
+	while (of_irq_to_resource(dev, nr, NULL) != NO_IRQ)
+		nr++;
+
+	return nr;
+}
+
+/**
+ * of_irq_to_resource_table - Fill in resource table with node's IRQ info
+ * @dev: pointer to device tree node
+ * @res: array of resources to fill in
+ * @nr_irqs: the number of IRQs (and upper bound for num of @res elements)
+ *
+ * Returns the size of the filled in table (up to @nr_irqs).
+ */
+int of_irq_to_resource_table(struct device_node *dev, struct resource *res,
+		int nr_irqs)
+{
+	int i;
+
+	for (i = 0; i < nr_irqs; i++, res++)
+		if (of_irq_to_resource(dev, i, res) == NO_IRQ)
+			break;
+
+	return i;
+}

commit d2f718398a21cdb925f12c2b332d206eacd967a6
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Jul 23 16:56:19 2010 -0600

    of/irq: Fix endian issues in parsing interrupt specifiers
    
    This patch fixes some instances where interrupt specifiers are
    dereferenced directly instead of doing a be32_to_cpu() conversion first.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 65cfae1bd670..6e595e5a3977 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -91,8 +91,8 @@ static struct device_node *of_irq_find_parent(struct device_node *child)
  * properties, for example when resolving PCI interrupts when no device
  * node exist for the parent.
  */
-int of_irq_map_raw(struct device_node *parent, const u32 *intspec, u32 ointsize,
-		const u32 *addr, struct of_irq *out_irq)
+int of_irq_map_raw(struct device_node *parent, const __be32 *intspec,
+		   u32 ointsize, const __be32 *addr, struct of_irq *out_irq)
 {
 	struct device_node *ipar, *tnode, *old = NULL, *newpar = NULL;
 	const __be32 *tmp, *imap, *imask;
@@ -100,7 +100,8 @@ int of_irq_map_raw(struct device_node *parent, const u32 *intspec, u32 ointsize,
 	int imaplen, match, i;
 
 	pr_debug("of_irq_map_raw: par=%s,intspec=[0x%08x 0x%08x...],ointsize=%d\n",
-	    parent->full_name, intspec[0], intspec[1], ointsize);
+		 parent->full_name, be32_to_cpup(intspec),
+		 be32_to_cpup(intspec + 1), ointsize);
 
 	ipar = of_node_get(parent);
 
@@ -278,7 +279,7 @@ EXPORT_SYMBOL_GPL(of_irq_map_raw);
 int of_irq_map_one(struct device_node *device, int index, struct of_irq *out_irq)
 {
 	struct device_node *p;
-	const u32 *intspec, *tmp, *addr;
+	const __be32 *intspec, *tmp, *addr;
 	u32 intsize, intlen;
 	int res = -EINVAL;
 
@@ -292,9 +293,9 @@ int of_irq_map_one(struct device_node *device, int index, struct of_irq *out_irq
 	intspec = of_get_property(device, "interrupts", &intlen);
 	if (intspec == NULL)
 		return -EINVAL;
-	intlen /= sizeof(u32);
+	intlen /= sizeof(*intspec);
 
-	pr_debug(" intspec=%d intlen=%d\n", *intspec, intlen);
+	pr_debug(" intspec=%d intlen=%d\n", be32_to_cpup(intspec), intlen);
 
 	/* Get the reg property (if any) */
 	addr = of_get_property(device, "reg", NULL);

commit 9a6b2e588c7809e86161236da3d29581bf5f8402
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Jul 23 01:48:25 2010 -0600

    of: Fix phandle endian issues
    
    The flat tree code wasn't fixing the endianness on phandle values when
    unflattening the tree, and the code in drivers/of wasn't always doing a
    be32_to_cpu before trying to dereference the phandle values.  This patch
    fixes them.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 6cfb307204c3..65cfae1bd670 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -54,7 +54,7 @@ EXPORT_SYMBOL_GPL(irq_of_parse_and_map);
 static struct device_node *of_irq_find_parent(struct device_node *child)
 {
 	struct device_node *p;
-	const phandle *parp;
+	const __be32 *parp;
 
 	if (!of_node_get(child))
 		return NULL;
@@ -67,7 +67,7 @@ static struct device_node *of_irq_find_parent(struct device_node *child)
 			if (of_irq_workarounds & OF_IMAP_NO_PHANDLE)
 				p = of_node_get(of_irq_dflt_pic);
 			else
-				p = of_find_node_by_phandle(*parp);
+				p = of_find_node_by_phandle(be32_to_cpup(parp));
 		}
 		of_node_put(child);
 		child = p;
@@ -206,7 +206,7 @@ int of_irq_map_raw(struct device_node *parent, const u32 *intspec, u32 ointsize,
 			if (of_irq_workarounds & OF_IMAP_NO_PHANDLE)
 				newpar = of_node_get(of_irq_dflt_pic);
 			else
-				newpar = of_find_node_by_phandle((phandle)*imap);
+				newpar = of_find_node_by_phandle(be32_to_cpup(imap));
 			imap++;
 			--imaplen;
 

commit d3571c3acfabb6f3a93b517b75d9b30eb7e8692e
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Jun 8 07:48:12 2010 -0600

    of: Use full node name in resource structures
    
    Resource names appear in human readable output, so when extracting IRQ
    and address resources from a device tree node, use the full node name
    to give proper context in places like /proc/iomem.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    CC: Michal Simek <monstr@monstr.eu>
    CC: Stephen Rothwell <sfr@canb.auug.org.au>
    CC: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    CC: microblaze-uclinux@itee.uq.edu.au
    CC: linuxppc-dev@ozlabs.org

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 623eb661c629..6cfb307204c3 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -340,6 +340,7 @@ int of_irq_to_resource(struct device_node *dev, int index, struct resource *r)
 	if (r && irq != NO_IRQ) {
 		r->start = r->end = irq;
 		r->flags = IORESOURCE_IRQ;
+		r->name = dev->full_name;
 	}
 
 	return irq;

commit a7c194b007ec40a130207e9ace9cecf598fc6ac5
Author: Rob Herring <r.herring@freescale.com>
Date:   Tue Jun 8 07:48:08 2010 -0600

    of/irq: little endian fixes
    
    Fix some endian issues in the irq mapping OF code.
    
    Signed-off-by: Rob Herring <r.herring@freescale.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    CC: Michal Simek <monstr@monstr.eu>
    CC: Wolfram Sang <w.sang@pengutronix.de>
    CC: Stephen Rothwell <sfr@canb.auug.org.au>
    CC: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 598454fbdd1e..623eb661c629 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -95,7 +95,7 @@ int of_irq_map_raw(struct device_node *parent, const u32 *intspec, u32 ointsize,
 		const u32 *addr, struct of_irq *out_irq)
 {
 	struct device_node *ipar, *tnode, *old = NULL, *newpar = NULL;
-	const u32 *tmp, *imap, *imask;
+	const __be32 *tmp, *imap, *imask;
 	u32 intsize = 1, addrsize, newintsize = 0, newaddrsize = 0;
 	int imaplen, match, i;
 
@@ -111,7 +111,7 @@ int of_irq_map_raw(struct device_node *parent, const u32 *intspec, u32 ointsize,
 	do {
 		tmp = of_get_property(ipar, "#interrupt-cells", NULL);
 		if (tmp != NULL) {
-			intsize = *tmp;
+			intsize = be32_to_cpu(*tmp);
 			break;
 		}
 		tnode = ipar;
@@ -140,7 +140,7 @@ int of_irq_map_raw(struct device_node *parent, const u32 *intspec, u32 ointsize,
 	} while (old && tmp == NULL);
 	of_node_put(old);
 	old = NULL;
-	addrsize = (tmp == NULL) ? 2 : *tmp;
+	addrsize = (tmp == NULL) ? 2 : be32_to_cpu(*tmp);
 
 	pr_debug(" -> addrsize=%d\n", addrsize);
 
@@ -152,8 +152,9 @@ int of_irq_map_raw(struct device_node *parent, const u32 *intspec, u32 ointsize,
 		if (of_get_property(ipar, "interrupt-controller", NULL) !=
 				NULL) {
 			pr_debug(" -> got it !\n");
-			memcpy(out_irq->specifier, intspec,
-			       intsize * sizeof(u32));
+			for (i = 0; i < intsize; i++)
+				out_irq->specifier[i] =
+						of_read_number(intspec +i, 1);
 			out_irq->size = intsize;
 			out_irq->controller = ipar;
 			of_node_put(old);
@@ -223,9 +224,9 @@ int of_irq_map_raw(struct device_node *parent, const u32 *intspec, u32 ointsize,
 				pr_debug(" -> parent lacks #interrupt-cells!\n");
 				goto fail;
 			}
-			newintsize = *tmp;
+			newintsize = be32_to_cpu(*tmp);
 			tmp = of_get_property(newpar, "#address-cells", NULL);
-			newaddrsize = (tmp == NULL) ? 0 : *tmp;
+			newaddrsize = (tmp == NULL) ? 0 : be32_to_cpu(*tmp);
 
 			pr_debug(" -> newintsize=%d, newaddrsize=%d\n",
 			    newintsize, newaddrsize);
@@ -307,7 +308,7 @@ int of_irq_map_one(struct device_node *device, int index, struct of_irq *out_irq
 	tmp = of_get_property(p, "#interrupt-cells", NULL);
 	if (tmp == NULL)
 		goto out;
-	intsize = *tmp;
+	intsize = be32_to_cpu(*tmp);
 
 	pr_debug(" intsize=%d intlen=%d\n", intsize, intlen);
 

commit 7dc2e1134a22dc242175d5321c0c9e97d16eb87b
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Jun 8 07:48:06 2010 -0600

    of/irq: merge irq mapping code
    
    Merge common irq mapping code between PowerPC and Microblaze.
    
    This patch merges of_irq_find_parent(), of_irq_map_raw() and
    of_irq_map_one().  The functions are dependent on one another, so all
    three are merged in a single patch.  Other than cosmetic difference
    (ie. DBG() vs. pr_debug()), the implementations are identical.
    
    of_irq_to_resource() is also merged, but in this case the
    implementations are different.  This patch drops the microblaze version
    and uses the powerpc implementation unchanged.  The microblaze version
    essentially open-coded irq_of_parse_and_map() which it does not need
    to do.  Therefore the powerpc version is safe to adopt.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    CC: Michal Simek <monstr@monstr.eu>
    CC: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    CC: Stephen Rothwell <sfr@canb.auug.org.au>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
index 9b3397c27096..598454fbdd1e 100644
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -43,3 +43,304 @@ unsigned int irq_of_parse_and_map(struct device_node *dev, int index)
 				     oirq.size);
 }
 EXPORT_SYMBOL_GPL(irq_of_parse_and_map);
+
+/**
+ * of_irq_find_parent - Given a device node, find its interrupt parent node
+ * @child: pointer to device node
+ *
+ * Returns a pointer to the interrupt parent node, or NULL if the interrupt
+ * parent could not be determined.
+ */
+static struct device_node *of_irq_find_parent(struct device_node *child)
+{
+	struct device_node *p;
+	const phandle *parp;
+
+	if (!of_node_get(child))
+		return NULL;
+
+	do {
+		parp = of_get_property(child, "interrupt-parent", NULL);
+		if (parp == NULL)
+			p = of_get_parent(child);
+		else {
+			if (of_irq_workarounds & OF_IMAP_NO_PHANDLE)
+				p = of_node_get(of_irq_dflt_pic);
+			else
+				p = of_find_node_by_phandle(*parp);
+		}
+		of_node_put(child);
+		child = p;
+	} while (p && of_get_property(p, "#interrupt-cells", NULL) == NULL);
+
+	return p;
+}
+
+/**
+ * of_irq_map_raw - Low level interrupt tree parsing
+ * @parent:	the device interrupt parent
+ * @intspec:	interrupt specifier ("interrupts" property of the device)
+ * @ointsize:   size of the passed in interrupt specifier
+ * @addr:	address specifier (start of "reg" property of the device)
+ * @out_irq:	structure of_irq filled by this function
+ *
+ * Returns 0 on success and a negative number on error
+ *
+ * This function is a low-level interrupt tree walking function. It
+ * can be used to do a partial walk with synthetized reg and interrupts
+ * properties, for example when resolving PCI interrupts when no device
+ * node exist for the parent.
+ */
+int of_irq_map_raw(struct device_node *parent, const u32 *intspec, u32 ointsize,
+		const u32 *addr, struct of_irq *out_irq)
+{
+	struct device_node *ipar, *tnode, *old = NULL, *newpar = NULL;
+	const u32 *tmp, *imap, *imask;
+	u32 intsize = 1, addrsize, newintsize = 0, newaddrsize = 0;
+	int imaplen, match, i;
+
+	pr_debug("of_irq_map_raw: par=%s,intspec=[0x%08x 0x%08x...],ointsize=%d\n",
+	    parent->full_name, intspec[0], intspec[1], ointsize);
+
+	ipar = of_node_get(parent);
+
+	/* First get the #interrupt-cells property of the current cursor
+	 * that tells us how to interpret the passed-in intspec. If there
+	 * is none, we are nice and just walk up the tree
+	 */
+	do {
+		tmp = of_get_property(ipar, "#interrupt-cells", NULL);
+		if (tmp != NULL) {
+			intsize = *tmp;
+			break;
+		}
+		tnode = ipar;
+		ipar = of_irq_find_parent(ipar);
+		of_node_put(tnode);
+	} while (ipar);
+	if (ipar == NULL) {
+		pr_debug(" -> no parent found !\n");
+		goto fail;
+	}
+
+	pr_debug("of_irq_map_raw: ipar=%s, size=%d\n", ipar->full_name, intsize);
+
+	if (ointsize != intsize)
+		return -EINVAL;
+
+	/* Look for this #address-cells. We have to implement the old linux
+	 * trick of looking for the parent here as some device-trees rely on it
+	 */
+	old = of_node_get(ipar);
+	do {
+		tmp = of_get_property(old, "#address-cells", NULL);
+		tnode = of_get_parent(old);
+		of_node_put(old);
+		old = tnode;
+	} while (old && tmp == NULL);
+	of_node_put(old);
+	old = NULL;
+	addrsize = (tmp == NULL) ? 2 : *tmp;
+
+	pr_debug(" -> addrsize=%d\n", addrsize);
+
+	/* Now start the actual "proper" walk of the interrupt tree */
+	while (ipar != NULL) {
+		/* Now check if cursor is an interrupt-controller and if it is
+		 * then we are done
+		 */
+		if (of_get_property(ipar, "interrupt-controller", NULL) !=
+				NULL) {
+			pr_debug(" -> got it !\n");
+			memcpy(out_irq->specifier, intspec,
+			       intsize * sizeof(u32));
+			out_irq->size = intsize;
+			out_irq->controller = ipar;
+			of_node_put(old);
+			return 0;
+		}
+
+		/* Now look for an interrupt-map */
+		imap = of_get_property(ipar, "interrupt-map", &imaplen);
+		/* No interrupt map, check for an interrupt parent */
+		if (imap == NULL) {
+			pr_debug(" -> no map, getting parent\n");
+			newpar = of_irq_find_parent(ipar);
+			goto skiplevel;
+		}
+		imaplen /= sizeof(u32);
+
+		/* Look for a mask */
+		imask = of_get_property(ipar, "interrupt-map-mask", NULL);
+
+		/* If we were passed no "reg" property and we attempt to parse
+		 * an interrupt-map, then #address-cells must be 0.
+		 * Fail if it's not.
+		 */
+		if (addr == NULL && addrsize != 0) {
+			pr_debug(" -> no reg passed in when needed !\n");
+			goto fail;
+		}
+
+		/* Parse interrupt-map */
+		match = 0;
+		while (imaplen > (addrsize + intsize + 1) && !match) {
+			/* Compare specifiers */
+			match = 1;
+			for (i = 0; i < addrsize && match; ++i) {
+				u32 mask = imask ? imask[i] : 0xffffffffu;
+				match = ((addr[i] ^ imap[i]) & mask) == 0;
+			}
+			for (; i < (addrsize + intsize) && match; ++i) {
+				u32 mask = imask ? imask[i] : 0xffffffffu;
+				match =
+				   ((intspec[i-addrsize] ^ imap[i]) & mask) == 0;
+			}
+			imap += addrsize + intsize;
+			imaplen -= addrsize + intsize;
+
+			pr_debug(" -> match=%d (imaplen=%d)\n", match, imaplen);
+
+			/* Get the interrupt parent */
+			if (of_irq_workarounds & OF_IMAP_NO_PHANDLE)
+				newpar = of_node_get(of_irq_dflt_pic);
+			else
+				newpar = of_find_node_by_phandle((phandle)*imap);
+			imap++;
+			--imaplen;
+
+			/* Check if not found */
+			if (newpar == NULL) {
+				pr_debug(" -> imap parent not found !\n");
+				goto fail;
+			}
+
+			/* Get #interrupt-cells and #address-cells of new
+			 * parent
+			 */
+			tmp = of_get_property(newpar, "#interrupt-cells", NULL);
+			if (tmp == NULL) {
+				pr_debug(" -> parent lacks #interrupt-cells!\n");
+				goto fail;
+			}
+			newintsize = *tmp;
+			tmp = of_get_property(newpar, "#address-cells", NULL);
+			newaddrsize = (tmp == NULL) ? 0 : *tmp;
+
+			pr_debug(" -> newintsize=%d, newaddrsize=%d\n",
+			    newintsize, newaddrsize);
+
+			/* Check for malformed properties */
+			if (imaplen < (newaddrsize + newintsize))
+				goto fail;
+
+			imap += newaddrsize + newintsize;
+			imaplen -= newaddrsize + newintsize;
+
+			pr_debug(" -> imaplen=%d\n", imaplen);
+		}
+		if (!match)
+			goto fail;
+
+		of_node_put(old);
+		old = of_node_get(newpar);
+		addrsize = newaddrsize;
+		intsize = newintsize;
+		intspec = imap - intsize;
+		addr = intspec - addrsize;
+
+	skiplevel:
+		/* Iterate again with new parent */
+		pr_debug(" -> new parent: %s\n", newpar ? newpar->full_name : "<>");
+		of_node_put(ipar);
+		ipar = newpar;
+		newpar = NULL;
+	}
+ fail:
+	of_node_put(ipar);
+	of_node_put(old);
+	of_node_put(newpar);
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(of_irq_map_raw);
+
+/**
+ * of_irq_map_one - Resolve an interrupt for a device
+ * @device: the device whose interrupt is to be resolved
+ * @index: index of the interrupt to resolve
+ * @out_irq: structure of_irq filled by this function
+ *
+ * This function resolves an interrupt, walking the tree, for a given
+ * device-tree node. It's the high level pendant to of_irq_map_raw().
+ */
+int of_irq_map_one(struct device_node *device, int index, struct of_irq *out_irq)
+{
+	struct device_node *p;
+	const u32 *intspec, *tmp, *addr;
+	u32 intsize, intlen;
+	int res = -EINVAL;
+
+	pr_debug("of_irq_map_one: dev=%s, index=%d\n", device->full_name, index);
+
+	/* OldWorld mac stuff is "special", handle out of line */
+	if (of_irq_workarounds & OF_IMAP_OLDWORLD_MAC)
+		return of_irq_map_oldworld(device, index, out_irq);
+
+	/* Get the interrupts property */
+	intspec = of_get_property(device, "interrupts", &intlen);
+	if (intspec == NULL)
+		return -EINVAL;
+	intlen /= sizeof(u32);
+
+	pr_debug(" intspec=%d intlen=%d\n", *intspec, intlen);
+
+	/* Get the reg property (if any) */
+	addr = of_get_property(device, "reg", NULL);
+
+	/* Look for the interrupt parent. */
+	p = of_irq_find_parent(device);
+	if (p == NULL)
+		return -EINVAL;
+
+	/* Get size of interrupt specifier */
+	tmp = of_get_property(p, "#interrupt-cells", NULL);
+	if (tmp == NULL)
+		goto out;
+	intsize = *tmp;
+
+	pr_debug(" intsize=%d intlen=%d\n", intsize, intlen);
+
+	/* Check index */
+	if ((index + 1) * intsize > intlen)
+		goto out;
+
+	/* Get new specifier and map it */
+	res = of_irq_map_raw(p, intspec + index * intsize, intsize,
+			     addr, out_irq);
+ out:
+	of_node_put(p);
+	return res;
+}
+EXPORT_SYMBOL_GPL(of_irq_map_one);
+
+/**
+ * of_irq_to_resource - Decode a node's IRQ and return it as a resource
+ * @dev: pointer to device tree node
+ * @index: zero-based index of the irq
+ * @r: pointer to resource structure to return result into.
+ */
+int of_irq_to_resource(struct device_node *dev, int index, struct resource *r)
+{
+	int irq = irq_of_parse_and_map(dev, index);
+
+	/* Only dereference the resource if both the
+	 * resource and the irq are valid. */
+	if (r && irq != NO_IRQ) {
+		r->start = r->end = irq;
+		r->flags = IORESOURCE_IRQ;
+	}
+
+	return irq;
+}
+EXPORT_SYMBOL_GPL(of_irq_to_resource);

commit e3873444990dd6f8a095d1f72b5ad45192f8c506
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Jun 18 11:09:59 2010 -0600

    of/irq: Move irq_of_parse_and_map() to common code
    
    Merge common code between PowerPC and Microblaze.  SPARC implements
    irq_of_parse_and_map(), but the implementation is different, so it
    does not use this code.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Jeremy Kerr <jeremy.kerr@canonical.com>

diff --git a/drivers/of/irq.c b/drivers/of/irq.c
new file mode 100644
index 000000000000..9b3397c27096
--- /dev/null
+++ b/drivers/of/irq.c
@@ -0,0 +1,45 @@
+/*
+ *  Derived from arch/i386/kernel/irq.c
+ *    Copyright (C) 1992 Linus Torvalds
+ *  Adapted from arch/i386 by Gary Thomas
+ *    Copyright (C) 1995-1996 Gary Thomas (gdt@linuxppc.org)
+ *  Updated and modified by Cort Dougan <cort@fsmlabs.com>
+ *    Copyright (C) 1996-2001 Cort Dougan
+ *  Adapted for Power Macintosh by Paul Mackerras
+ *    Copyright (C) 1996 Paul Mackerras (paulus@cs.anu.edu.au)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * This file contains the code used to make IRQ descriptions in the
+ * device tree to actual irq numbers on an interrupt controller
+ * driver.
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/string.h>
+
+/**
+ * irq_of_parse_and_map - Parse and map an interrupt into linux virq space
+ * @device: Device node of the device whose interrupt is to be mapped
+ * @index: Index of the interrupt to map
+ *
+ * This function is a wrapper that chains of_irq_map_one() and
+ * irq_create_of_mapping() to make things easier to callers
+ */
+unsigned int irq_of_parse_and_map(struct device_node *dev, int index)
+{
+	struct of_irq oirq;
+
+	if (of_irq_map_one(dev, index, &oirq))
+		return NO_IRQ;
+
+	return irq_create_of_mapping(oirq.controller, oirq.specifier,
+				     oirq.size);
+}
+EXPORT_SYMBOL_GPL(irq_of_parse_and_map);
