commit 0bec8b7e5ca1a629f26173691526432f9d7cf8c1
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Wed Aug 14 10:46:38 2019 -0700

    Input: remove dev_err() usage after platform_get_irq()
    
    We don't need dev_err() messages when platform_get_irq() fails now that
    platform_get_irq() prints an error message itself when something goes
    wrong. Let's remove these prints with a simple semantic patch.
    
    // <smpl>
    @@
    expression ret;
    struct platform_device *E;
    @@
    
    ret =
    (
    platform_get_irq(E, ...)
    |
    platform_get_irq_byname(E, ...)
    );
    
    if ( \( ret < 0 \| ret <= 0 \) )
    {
    (
    -if (ret != -EPROBE_DEFER)
    -{ ...
    -dev_err(...);
    -... }
    |
    ...
    -dev_err(...);
    )
    ...
    }
    // </smpl>
    
    While we're here, remove braces on if statements that only have one
    statement (manually).
    
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/lpc32xx_ts.c b/drivers/input/touchscreen/lpc32xx_ts.c
index 567ed64b5392..b2cd9472e2d1 100644
--- a/drivers/input/touchscreen/lpc32xx_ts.c
+++ b/drivers/input/touchscreen/lpc32xx_ts.c
@@ -212,10 +212,8 @@ static int lpc32xx_ts_probe(struct platform_device *pdev)
 	}
 
 	irq = platform_get_irq(pdev, 0);
-	if (irq < 0) {
-		dev_err(&pdev->dev, "Can't get interrupt resource\n");
+	if (irq < 0)
 		return irq;
-	}
 
 	tsc = kzalloc(sizeof(*tsc), GFP_KERNEL);
 	input = input_allocate_device();

commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/input/touchscreen/lpc32xx_ts.c b/drivers/input/touchscreen/lpc32xx_ts.c
index 4eb31ec10b18..567ed64b5392 100644
--- a/drivers/input/touchscreen/lpc32xx_ts.c
+++ b/drivers/input/touchscreen/lpc32xx_ts.c
@@ -1,17 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * LPC32xx built-in touchscreen driver
  *
  * Copyright (C) 2010 NXP Semiconductors
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #include <linux/platform_device.h>

commit 71f9f08103cb02f3d5bfad91cb570dcd2d8ed0cb
Author: Fabio Estevam <fabio.estevam@nxp.com>
Date:   Wed Apr 12 08:34:03 2017 -0700

    Input: lpc32xx_ts - check for clk_prepare_enable() error
    
    clk_prepare_enable() may fail, so we better check its return value and
    propagate it in the case of error.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/lpc32xx_ts.c b/drivers/input/touchscreen/lpc32xx_ts.c
index e0baa7de4102..4eb31ec10b18 100644
--- a/drivers/input/touchscreen/lpc32xx_ts.c
+++ b/drivers/input/touchscreen/lpc32xx_ts.c
@@ -142,11 +142,14 @@ static void lpc32xx_stop_tsc(struct lpc32xx_tsc *tsc)
 	clk_disable_unprepare(tsc->clk);
 }
 
-static void lpc32xx_setup_tsc(struct lpc32xx_tsc *tsc)
+static int lpc32xx_setup_tsc(struct lpc32xx_tsc *tsc)
 {
 	u32 tmp;
+	int err;
 
-	clk_prepare_enable(tsc->clk);
+	err = clk_prepare_enable(tsc->clk);
+	if (err)
+		return err;
 
 	tmp = tsc_readl(tsc, LPC32XX_TSC_CON) & ~LPC32XX_TSC_ADCCON_POWER_UP;
 
@@ -184,15 +187,15 @@ static void lpc32xx_setup_tsc(struct lpc32xx_tsc *tsc)
 
 	/* Enable automatic ts event capture */
 	tsc_writel(tsc, LPC32XX_TSC_CON, tmp | LPC32XX_TSC_ADCCON_AUTO_EN);
+
+	return 0;
 }
 
 static int lpc32xx_ts_open(struct input_dev *dev)
 {
 	struct lpc32xx_tsc *tsc = input_get_drvdata(dev);
 
-	lpc32xx_setup_tsc(tsc);
-
-	return 0;
+	return lpc32xx_setup_tsc(tsc);
 }
 
 static void lpc32xx_ts_close(struct input_dev *dev)

commit 8e1b4d83cf8b0e62f5a45792d07f027783c1a07c
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Sat Jan 21 23:49:13 2017 -0800

    Input: touchscreen - drop unnecessary calls to device_init_wakeup
    
    Calling device_init_wakeup in the remove function is unnecessary since the
    device is going away, and thus won't be able to cause any wakeups under any
    circumstances. Besides, the driver cleanup code already handles the
    necessary cleanup.
    
    Similarly, disabling wakeup in the probe error path is unnecessary, as is
    disabling wakeup in the probe function in the first place.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/lpc32xx_ts.c b/drivers/input/touchscreen/lpc32xx_ts.c
index 7fbb3b0c8571..e0baa7de4102 100644
--- a/drivers/input/touchscreen/lpc32xx_ts.c
+++ b/drivers/input/touchscreen/lpc32xx_ts.c
@@ -313,7 +313,6 @@ static int lpc32xx_ts_remove(struct platform_device *pdev)
 	struct lpc32xx_tsc *tsc = platform_get_drvdata(pdev);
 	struct resource *res;
 
-	device_init_wakeup(&pdev->dev, 0);
 	free_irq(tsc->irq, tsc);
 
 	input_unregister_device(tsc->dev);

commit 324700604b04954510ddd4c6841a88a06938a28c
Author: Vladimir Zapolskiy <vz@mleia.com>
Date:   Sat Oct 17 11:30:15 2015 -0700

    Input: lpc32xx_ts - fix warnings caused by enabling unprepared clock
    
    If common clock framework is configured, the driver generates a warning,
    which is fixed by this change:
    
        root@devkit3250:~# cat /dev/input/touchscreen0
        ------------[ cut here ]------------
        WARNING: CPU: 0 PID: 720 at drivers/clk/clk.c:727 clk_core_enable+0x2c/0xa4()
        Modules linked in: sc16is7xx snd_soc_uda1380
        CPU: 0 PID: 720 Comm: cat Not tainted 4.3.0-rc2+ #199
        Hardware name: LPC32XX SoC (Flattened Device Tree)
        Backtrace:
        [<>] (dump_backtrace) from [<>] (show_stack+0x18/0x1c)
        [<>] (show_stack) from [<>] (dump_stack+0x20/0x28)
        [<>] (dump_stack) from [<>] (warn_slowpath_common+0x90/0xb8)
        [<>] (warn_slowpath_common) from [<>] (warn_slowpath_null+0x24/0x2c)
        [<>] (warn_slowpath_null) from [<>] (clk_core_enable+0x2c/0xa4)
        [<>] (clk_core_enable) from [<>] (clk_enable+0x24/0x38)
        [<>] (clk_enable) from [<>] (lpc32xx_setup_tsc+0x18/0xa0)
        [<>] (lpc32xx_setup_tsc) from [<>] (lpc32xx_ts_open+0x14/0x1c)
        [<>] (lpc32xx_ts_open) from [<>] (input_open_device+0x74/0xb0)
        [<>] (input_open_device) from [<>] (evdev_open+0x110/0x16c)
        [<>] (evdev_open) from [<>] (chrdev_open+0x1b4/0x1dc)
        [<>] (chrdev_open) from [<>] (do_dentry_open+0x1dc/0x2f4)
        [<>] (do_dentry_open) from [<>] (vfs_open+0x6c/0x70)
        [<>] (vfs_open) from [<>] (path_openat+0xb4c/0xddc)
        [<>] (path_openat) from [<>] (do_filp_open+0x40/0x8c)
        [<>] (do_filp_open) from [<>] (do_sys_open+0x124/0x1c4)
        [<>] (do_sys_open) from [<>] (SyS_open+0x2c/0x30)
        [<>] (SyS_open) from [<>] (ret_fast_syscall+0x0/0x38)
    
    Signed-off-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/lpc32xx_ts.c b/drivers/input/touchscreen/lpc32xx_ts.c
index 24d704cd9f88..7fbb3b0c8571 100644
--- a/drivers/input/touchscreen/lpc32xx_ts.c
+++ b/drivers/input/touchscreen/lpc32xx_ts.c
@@ -139,14 +139,14 @@ static void lpc32xx_stop_tsc(struct lpc32xx_tsc *tsc)
 		   tsc_readl(tsc, LPC32XX_TSC_CON) &
 			     ~LPC32XX_TSC_ADCCON_AUTO_EN);
 
-	clk_disable(tsc->clk);
+	clk_disable_unprepare(tsc->clk);
 }
 
 static void lpc32xx_setup_tsc(struct lpc32xx_tsc *tsc)
 {
 	u32 tmp;
 
-	clk_enable(tsc->clk);
+	clk_prepare_enable(tsc->clk);
 
 	tmp = tsc_readl(tsc, LPC32XX_TSC_CON) & ~LPC32XX_TSC_ADCCON_POWER_UP;
 

commit 7b8f16c2d1a81b29035379b471226ea09817a29c
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:20:41 2014 +0200

    input: touchscreen: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/input/touchscreen/lpc32xx_ts.c b/drivers/input/touchscreen/lpc32xx_ts.c
index bb47d3442a35..24d704cd9f88 100644
--- a/drivers/input/touchscreen/lpc32xx_ts.c
+++ b/drivers/input/touchscreen/lpc32xx_ts.c
@@ -396,7 +396,6 @@ static struct platform_driver lpc32xx_ts_driver = {
 	.remove		= lpc32xx_ts_remove,
 	.driver		= {
 		.name	= MOD_NAME,
-		.owner	= THIS_MODULE,
 		.pm	= LPC32XX_TS_PM_OPS,
 		.of_match_table = of_match_ptr(lpc32xx_tsc_of_match),
 	},

commit f23e0abdab17420ff11c96f26d6909790060437a
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Wed May 7 13:09:17 2014 -0700

    Input: lpc32xx_ts - make of_device_id array const
    
    Make of_device_id array const, because all OF functions handle it as const.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Acked-by: Roland Stigge <stigge@antcom.de>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/lpc32xx_ts.c b/drivers/input/touchscreen/lpc32xx_ts.c
index 2058253b55d9..bb47d3442a35 100644
--- a/drivers/input/touchscreen/lpc32xx_ts.c
+++ b/drivers/input/touchscreen/lpc32xx_ts.c
@@ -384,7 +384,7 @@ static const struct dev_pm_ops lpc32xx_ts_pm_ops = {
 #endif
 
 #ifdef CONFIG_OF
-static struct of_device_id lpc32xx_tsc_of_match[] = {
+static const struct of_device_id lpc32xx_tsc_of_match[] = {
 	{ .compatible = "nxp,lpc3220-tsc", },
 	{ },
 };

commit bf9a9f8e5105b13cea954b254008f383ed0b4045
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jan 6 10:27:05 2014 -0800

    Input: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/lpc32xx_ts.c b/drivers/input/touchscreen/lpc32xx_ts.c
index 9101ee529c92..2058253b55d9 100644
--- a/drivers/input/touchscreen/lpc32xx_ts.c
+++ b/drivers/input/touchscreen/lpc32xx_ts.c
@@ -15,7 +15,6 @@
  */
 
 #include <linux/platform_device.h>
-#include <linux/init.h>
 #include <linux/input.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>

commit e2619cf78e19476bfd7ceaefa9eff0847529346e
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Nov 23 21:50:47 2012 -0800

    Input: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/lpc32xx_ts.c b/drivers/input/touchscreen/lpc32xx_ts.c
index 39d50b7d470a..9101ee529c92 100644
--- a/drivers/input/touchscreen/lpc32xx_ts.c
+++ b/drivers/input/touchscreen/lpc32xx_ts.c
@@ -309,7 +309,7 @@ static int lpc32xx_ts_probe(struct platform_device *pdev)
 	return error;
 }
 
-static int __devexit lpc32xx_ts_remove(struct platform_device *pdev)
+static int lpc32xx_ts_remove(struct platform_device *pdev)
 {
 	struct lpc32xx_tsc *tsc = platform_get_drvdata(pdev);
 	struct resource *res;

commit 5298cc4cc753bbe4c530b41341834f6ef3344d0d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Nov 23 21:38:25 2012 -0800

    Input: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Javier Martinez Canillas <javier@dowhile0.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/lpc32xx_ts.c b/drivers/input/touchscreen/lpc32xx_ts.c
index 8134f6100de0..39d50b7d470a 100644
--- a/drivers/input/touchscreen/lpc32xx_ts.c
+++ b/drivers/input/touchscreen/lpc32xx_ts.c
@@ -203,7 +203,7 @@ static void lpc32xx_ts_close(struct input_dev *dev)
 	lpc32xx_stop_tsc(tsc);
 }
 
-static int __devinit lpc32xx_ts_probe(struct platform_device *pdev)
+static int lpc32xx_ts_probe(struct platform_device *pdev)
 {
 	struct lpc32xx_tsc *tsc;
 	struct input_dev *input;

commit 1cb0aa88179b7a71c240529e9d781d7bbb43d2e8
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Nov 23 21:27:39 2012 -0800

    Input: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/lpc32xx_ts.c b/drivers/input/touchscreen/lpc32xx_ts.c
index 4c2b8ed3bf16..8134f6100de0 100644
--- a/drivers/input/touchscreen/lpc32xx_ts.c
+++ b/drivers/input/touchscreen/lpc32xx_ts.c
@@ -394,7 +394,7 @@ MODULE_DEVICE_TABLE(of, lpc32xx_tsc_of_match);
 
 static struct platform_driver lpc32xx_ts_driver = {
 	.probe		= lpc32xx_ts_probe,
-	.remove		= __devexit_p(lpc32xx_ts_remove),
+	.remove		= lpc32xx_ts_remove,
 	.driver		= {
 		.name	= MOD_NAME,
 		.owner	= THIS_MODULE,

commit 34604086bea11f1f4d7ff124c84dab9b89956837
Author: Roland Stigge <stigge@antcom.de>
Date:   Mon Apr 23 22:26:38 2012 -0700

    Input: lpc32xx_ts - fix device tree compatible string
    
    During the device tree integration of the various LPC32xx drivers,
    we agreed on using non-wildcard "compatible" strings. This change
    switches lpc32xx_ts touchscreen driver to use "nxp,lpc3220-tsc".
    
    Signed-off-by: Roland Stigge <stigge@antcom.de>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/touchscreen/lpc32xx_ts.c b/drivers/input/touchscreen/lpc32xx_ts.c
index e8fccbc452db..4c2b8ed3bf16 100644
--- a/drivers/input/touchscreen/lpc32xx_ts.c
+++ b/drivers/input/touchscreen/lpc32xx_ts.c
@@ -386,7 +386,7 @@ static const struct dev_pm_ops lpc32xx_ts_pm_ops = {
 
 #ifdef CONFIG_OF
 static struct of_device_id lpc32xx_tsc_of_match[] = {
-	{ .compatible = "nxp,lpc32xx-tsc", },
+	{ .compatible = "nxp,lpc3220-tsc", },
 	{ },
 };
 MODULE_DEVICE_TABLE(of, lpc32xx_tsc_of_match);

commit 5cb727a86780fcac34de871cd12bea3f744d6be2
Author: Roland Stigge <stigge@antcom.de>
Date:   Fri Apr 20 23:02:49 2012 -0700

    Input: lpc32xx_ts - add device tree support
    
    This change implements device tree support for the LPC32xx SoC's touchscreen
    controller.
    
    Signed-off-by: Roland Stigge <stigge@antcom.de>
    Reviewed-by: Thierry Reding <thierry.reding@avionic-design.de>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/touchscreen/lpc32xx_ts.c b/drivers/input/touchscreen/lpc32xx_ts.c
index afcd0691ec67..e8fccbc452db 100644
--- a/drivers/input/touchscreen/lpc32xx_ts.c
+++ b/drivers/input/touchscreen/lpc32xx_ts.c
@@ -22,6 +22,7 @@
 #include <linux/clk.h>
 #include <linux/io.h>
 #include <linux/slab.h>
+#include <linux/of.h>
 
 /*
  * Touchscreen controller register offsets
@@ -383,6 +384,14 @@ static const struct dev_pm_ops lpc32xx_ts_pm_ops = {
 #define LPC32XX_TS_PM_OPS NULL
 #endif
 
+#ifdef CONFIG_OF
+static struct of_device_id lpc32xx_tsc_of_match[] = {
+	{ .compatible = "nxp,lpc32xx-tsc", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lpc32xx_tsc_of_match);
+#endif
+
 static struct platform_driver lpc32xx_ts_driver = {
 	.probe		= lpc32xx_ts_probe,
 	.remove		= __devexit_p(lpc32xx_ts_remove),
@@ -390,6 +399,7 @@ static struct platform_driver lpc32xx_ts_driver = {
 		.name	= MOD_NAME,
 		.owner	= THIS_MODULE,
 		.pm	= LPC32XX_TS_PM_OPS,
+		.of_match_table = of_match_ptr(lpc32xx_tsc_of_match),
 	},
 };
 module_platform_driver(lpc32xx_ts_driver);

commit cdcc96e261909eccf596c070116c8b906a42b328
Author: JJ Ding <dgdunix@gmail.com>
Date:   Tue Nov 29 11:14:13 2011 -0800

    Input: touchscreen - use macro module_platform_driver()
    
    Commit 940ab88962bc1aff3273a8356d64577a6e386736 introduced a new macro to
    save some platform_driver boilerplate code. Use it.
    
    Signed-off-by: JJ Ding <dgdunix@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/touchscreen/lpc32xx_ts.c b/drivers/input/touchscreen/lpc32xx_ts.c
index 0a484ed5295c..afcd0691ec67 100644
--- a/drivers/input/touchscreen/lpc32xx_ts.c
+++ b/drivers/input/touchscreen/lpc32xx_ts.c
@@ -392,18 +392,7 @@ static struct platform_driver lpc32xx_ts_driver = {
 		.pm	= LPC32XX_TS_PM_OPS,
 	},
 };
-
-static int __init lpc32xx_ts_init(void)
-{
-	return platform_driver_register(&lpc32xx_ts_driver);
-}
-module_init(lpc32xx_ts_init);
-
-static void __exit lpc32xx_ts_exit(void)
-{
-	platform_driver_unregister(&lpc32xx_ts_driver);
-}
-module_exit(lpc32xx_ts_exit);
+module_platform_driver(lpc32xx_ts_driver);
 
 MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com");
 MODULE_DESCRIPTION("LPC32XX TSC Driver");

commit ec4665c46b11f6e444911ba73dddae6044dec909
Author: Yong Zhang <yong.zhang0@gmail.com>
Date:   Wed Sep 7 14:04:16 2011 -0700

    Input: remove IRQF_DISABLED from drivers
    
    This flag is a NOOP and can be removed now.
    
    Signed-off-by: Yong Zhang <yong.zhang0@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/touchscreen/lpc32xx_ts.c b/drivers/input/touchscreen/lpc32xx_ts.c
index dcf803f5a1f7..0a484ed5295c 100644
--- a/drivers/input/touchscreen/lpc32xx_ts.c
+++ b/drivers/input/touchscreen/lpc32xx_ts.c
@@ -276,7 +276,7 @@ static int __devinit lpc32xx_ts_probe(struct platform_device *pdev)
 	input_set_drvdata(input, tsc);
 
 	error = request_irq(tsc->irq, lpc32xx_ts_interrupt,
-			    IRQF_DISABLED, pdev->name, tsc);
+			    0, pdev->name, tsc);
 	if (error) {
 		dev_err(&pdev->dev, "failed requesting interrupt\n");
 		goto err_put_clock;

commit 3045a5f5202a1e0ab6ba2bf90a786cf4cae6932a
Author: Kevin Wells <wellsk40@gmail.com>
Date:   Sat Aug 28 22:45:22 2010 -0700

    Input: add LPC32xx touchscreen controller driver
    
    This patch set introduces support for the LPC32xx touchscreen
    controller driver. The LPC32xx touchscreen controller supports
    automated event detection and X/Y data conversion for resistive
    touchscreens.
    
    Signed-off-by: Kevin Wells <wellsk40@gmail.com>
    Signed-off-by: Durgesh Pattamatta <durgesh.pattamatta@nxp.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/touchscreen/lpc32xx_ts.c b/drivers/input/touchscreen/lpc32xx_ts.c
new file mode 100644
index 000000000000..dcf803f5a1f7
--- /dev/null
+++ b/drivers/input/touchscreen/lpc32xx_ts.c
@@ -0,0 +1,411 @@
+/*
+ * LPC32xx built-in touchscreen driver
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+
+/*
+ * Touchscreen controller register offsets
+ */
+#define LPC32XX_TSC_STAT			0x00
+#define LPC32XX_TSC_SEL				0x04
+#define LPC32XX_TSC_CON				0x08
+#define LPC32XX_TSC_FIFO			0x0C
+#define LPC32XX_TSC_DTR				0x10
+#define LPC32XX_TSC_RTR				0x14
+#define LPC32XX_TSC_UTR				0x18
+#define LPC32XX_TSC_TTR				0x1C
+#define LPC32XX_TSC_DXP				0x20
+#define LPC32XX_TSC_MIN_X			0x24
+#define LPC32XX_TSC_MAX_X			0x28
+#define LPC32XX_TSC_MIN_Y			0x2C
+#define LPC32XX_TSC_MAX_Y			0x30
+#define LPC32XX_TSC_AUX_UTR			0x34
+#define LPC32XX_TSC_AUX_MIN			0x38
+#define LPC32XX_TSC_AUX_MAX			0x3C
+
+#define LPC32XX_TSC_STAT_FIFO_OVRRN		(1 << 8)
+#define LPC32XX_TSC_STAT_FIFO_EMPTY		(1 << 7)
+
+#define LPC32XX_TSC_SEL_DEFVAL			0x0284
+
+#define LPC32XX_TSC_ADCCON_IRQ_TO_FIFO_4	(0x1 << 11)
+#define LPC32XX_TSC_ADCCON_X_SAMPLE_SIZE(s)	((10 - (s)) << 7)
+#define LPC32XX_TSC_ADCCON_Y_SAMPLE_SIZE(s)	((10 - (s)) << 4)
+#define LPC32XX_TSC_ADCCON_POWER_UP		(1 << 2)
+#define LPC32XX_TSC_ADCCON_AUTO_EN		(1 << 0)
+
+#define LPC32XX_TSC_FIFO_TS_P_LEVEL		(1 << 31)
+#define LPC32XX_TSC_FIFO_NORMALIZE_X_VAL(x)	(((x) & 0x03FF0000) >> 16)
+#define LPC32XX_TSC_FIFO_NORMALIZE_Y_VAL(y)	((y) & 0x000003FF)
+
+#define LPC32XX_TSC_ADCDAT_VALUE_MASK		0x000003FF
+
+#define LPC32XX_TSC_MIN_XY_VAL			0x0
+#define LPC32XX_TSC_MAX_XY_VAL			0x3FF
+
+#define MOD_NAME "ts-lpc32xx"
+
+#define tsc_readl(dev, reg) \
+	__raw_readl((dev)->tsc_base + (reg))
+#define tsc_writel(dev, reg, val) \
+	__raw_writel((val), (dev)->tsc_base + (reg))
+
+struct lpc32xx_tsc {
+	struct input_dev *dev;
+	void __iomem *tsc_base;
+	int irq;
+	struct clk *clk;
+};
+
+static void lpc32xx_fifo_clear(struct lpc32xx_tsc *tsc)
+{
+	while (!(tsc_readl(tsc, LPC32XX_TSC_STAT) &
+			LPC32XX_TSC_STAT_FIFO_EMPTY))
+		tsc_readl(tsc, LPC32XX_TSC_FIFO);
+}
+
+static irqreturn_t lpc32xx_ts_interrupt(int irq, void *dev_id)
+{
+	u32 tmp, rv[4], xs[4], ys[4];
+	int idx;
+	struct lpc32xx_tsc *tsc = dev_id;
+	struct input_dev *input = tsc->dev;
+
+	tmp = tsc_readl(tsc, LPC32XX_TSC_STAT);
+
+	if (tmp & LPC32XX_TSC_STAT_FIFO_OVRRN) {
+		/* FIFO overflow - throw away samples */
+		lpc32xx_fifo_clear(tsc);
+		return IRQ_HANDLED;
+	}
+
+	/*
+	 * Gather and normalize 4 samples. Pen-up events may have less
+	 * than 4 samples, but its ok to pop 4 and let the last sample
+	 * pen status check drop the samples.
+	 */
+	idx = 0;
+	while (idx < 4 &&
+	       !(tsc_readl(tsc, LPC32XX_TSC_STAT) &
+			LPC32XX_TSC_STAT_FIFO_EMPTY)) {
+		tmp = tsc_readl(tsc, LPC32XX_TSC_FIFO);
+		xs[idx] = LPC32XX_TSC_ADCDAT_VALUE_MASK -
+			LPC32XX_TSC_FIFO_NORMALIZE_X_VAL(tmp);
+		ys[idx] = LPC32XX_TSC_ADCDAT_VALUE_MASK -
+			LPC32XX_TSC_FIFO_NORMALIZE_Y_VAL(tmp);
+		rv[idx] = tmp;
+		idx++;
+	}
+
+	/* Data is only valid if pen is still down in last sample */
+	if (!(rv[3] & LPC32XX_TSC_FIFO_TS_P_LEVEL) && idx == 4) {
+		/* Use average of 2nd and 3rd sample for position */
+		input_report_abs(input, ABS_X, (xs[1] + xs[2]) / 2);
+		input_report_abs(input, ABS_Y, (ys[1] + ys[2]) / 2);
+		input_report_key(input, BTN_TOUCH, 1);
+	} else {
+		input_report_key(input, BTN_TOUCH, 0);
+	}
+
+	input_sync(input);
+
+	return IRQ_HANDLED;
+}
+
+static void lpc32xx_stop_tsc(struct lpc32xx_tsc *tsc)
+{
+	/* Disable auto mode */
+	tsc_writel(tsc, LPC32XX_TSC_CON,
+		   tsc_readl(tsc, LPC32XX_TSC_CON) &
+			     ~LPC32XX_TSC_ADCCON_AUTO_EN);
+
+	clk_disable(tsc->clk);
+}
+
+static void lpc32xx_setup_tsc(struct lpc32xx_tsc *tsc)
+{
+	u32 tmp;
+
+	clk_enable(tsc->clk);
+
+	tmp = tsc_readl(tsc, LPC32XX_TSC_CON) & ~LPC32XX_TSC_ADCCON_POWER_UP;
+
+	/* Set the TSC FIFO depth to 4 samples @ 10-bits per sample (max) */
+	tmp = LPC32XX_TSC_ADCCON_IRQ_TO_FIFO_4 |
+	      LPC32XX_TSC_ADCCON_X_SAMPLE_SIZE(10) |
+	      LPC32XX_TSC_ADCCON_Y_SAMPLE_SIZE(10);
+	tsc_writel(tsc, LPC32XX_TSC_CON, tmp);
+
+	/* These values are all preset */
+	tsc_writel(tsc, LPC32XX_TSC_SEL, LPC32XX_TSC_SEL_DEFVAL);
+	tsc_writel(tsc, LPC32XX_TSC_MIN_X, LPC32XX_TSC_MIN_XY_VAL);
+	tsc_writel(tsc, LPC32XX_TSC_MAX_X, LPC32XX_TSC_MAX_XY_VAL);
+	tsc_writel(tsc, LPC32XX_TSC_MIN_Y, LPC32XX_TSC_MIN_XY_VAL);
+	tsc_writel(tsc, LPC32XX_TSC_MAX_Y, LPC32XX_TSC_MAX_XY_VAL);
+
+	/* Aux support is not used */
+	tsc_writel(tsc, LPC32XX_TSC_AUX_UTR, 0);
+	tsc_writel(tsc, LPC32XX_TSC_AUX_MIN, 0);
+	tsc_writel(tsc, LPC32XX_TSC_AUX_MAX, 0);
+
+	/*
+	 * Set sample rate to about 240Hz per X/Y pair. A single measurement
+	 * consists of 4 pairs which gives about a 60Hz sample rate based on
+	 * a stable 32768Hz clock source. Values are in clocks.
+	 * Rate is (32768 / (RTR + XCONV + RTR + YCONV + DXP + TTR + UTR) / 4
+	 */
+	tsc_writel(tsc, LPC32XX_TSC_RTR, 0x2);
+	tsc_writel(tsc, LPC32XX_TSC_DTR, 0x2);
+	tsc_writel(tsc, LPC32XX_TSC_TTR, 0x10);
+	tsc_writel(tsc, LPC32XX_TSC_DXP, 0x4);
+	tsc_writel(tsc, LPC32XX_TSC_UTR, 88);
+
+	lpc32xx_fifo_clear(tsc);
+
+	/* Enable automatic ts event capture */
+	tsc_writel(tsc, LPC32XX_TSC_CON, tmp | LPC32XX_TSC_ADCCON_AUTO_EN);
+}
+
+static int lpc32xx_ts_open(struct input_dev *dev)
+{
+	struct lpc32xx_tsc *tsc = input_get_drvdata(dev);
+
+	lpc32xx_setup_tsc(tsc);
+
+	return 0;
+}
+
+static void lpc32xx_ts_close(struct input_dev *dev)
+{
+	struct lpc32xx_tsc *tsc = input_get_drvdata(dev);
+
+	lpc32xx_stop_tsc(tsc);
+}
+
+static int __devinit lpc32xx_ts_probe(struct platform_device *pdev)
+{
+	struct lpc32xx_tsc *tsc;
+	struct input_dev *input;
+	struct resource *res;
+	resource_size_t size;
+	int irq;
+	int error;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "Can't get memory resource\n");
+		return -ENOENT;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "Can't get interrupt resource\n");
+		return irq;
+	}
+
+	tsc = kzalloc(sizeof(*tsc), GFP_KERNEL);
+	input = input_allocate_device();
+	if (!tsc || !input) {
+		dev_err(&pdev->dev, "failed allocating memory\n");
+		error = -ENOMEM;
+		goto err_free_mem;
+	}
+
+	tsc->dev = input;
+	tsc->irq = irq;
+
+	size = resource_size(res);
+
+	if (!request_mem_region(res->start, size, pdev->name)) {
+		dev_err(&pdev->dev, "TSC registers are not free\n");
+		error = -EBUSY;
+		goto err_free_mem;
+	}
+
+	tsc->tsc_base = ioremap(res->start, size);
+	if (!tsc->tsc_base) {
+		dev_err(&pdev->dev, "Can't map memory\n");
+		error = -ENOMEM;
+		goto err_release_mem;
+	}
+
+	tsc->clk = clk_get(&pdev->dev, NULL);
+	if (IS_ERR(tsc->clk)) {
+		dev_err(&pdev->dev, "failed getting clock\n");
+		error = PTR_ERR(tsc->clk);
+		goto err_unmap;
+	}
+
+	input->name = MOD_NAME;
+	input->phys = "lpc32xx/input0";
+	input->id.bustype = BUS_HOST;
+	input->id.vendor = 0x0001;
+	input->id.product = 0x0002;
+	input->id.version = 0x0100;
+	input->dev.parent = &pdev->dev;
+	input->open = lpc32xx_ts_open;
+	input->close = lpc32xx_ts_close;
+
+	input->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	input->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+	input_set_abs_params(input, ABS_X, LPC32XX_TSC_MIN_XY_VAL,
+			     LPC32XX_TSC_MAX_XY_VAL, 0, 0);
+	input_set_abs_params(input, ABS_Y, LPC32XX_TSC_MIN_XY_VAL,
+			     LPC32XX_TSC_MAX_XY_VAL, 0, 0);
+
+	input_set_drvdata(input, tsc);
+
+	error = request_irq(tsc->irq, lpc32xx_ts_interrupt,
+			    IRQF_DISABLED, pdev->name, tsc);
+	if (error) {
+		dev_err(&pdev->dev, "failed requesting interrupt\n");
+		goto err_put_clock;
+	}
+
+	error = input_register_device(input);
+	if (error) {
+		dev_err(&pdev->dev, "failed registering input device\n");
+		goto err_free_irq;
+	}
+
+	platform_set_drvdata(pdev, tsc);
+	device_init_wakeup(&pdev->dev, 1);
+
+	return 0;
+
+err_free_irq:
+	free_irq(tsc->irq, tsc);
+err_put_clock:
+	clk_put(tsc->clk);
+err_unmap:
+	iounmap(tsc->tsc_base);
+err_release_mem:
+	release_mem_region(res->start, size);
+err_free_mem:
+	input_free_device(input);
+	kfree(tsc);
+
+	return error;
+}
+
+static int __devexit lpc32xx_ts_remove(struct platform_device *pdev)
+{
+	struct lpc32xx_tsc *tsc = platform_get_drvdata(pdev);
+	struct resource *res;
+
+	device_init_wakeup(&pdev->dev, 0);
+	free_irq(tsc->irq, tsc);
+
+	input_unregister_device(tsc->dev);
+
+	clk_put(tsc->clk);
+
+	iounmap(tsc->tsc_base);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, resource_size(res));
+
+	kfree(tsc);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lpc32xx_ts_suspend(struct device *dev)
+{
+	struct lpc32xx_tsc *tsc = dev_get_drvdata(dev);
+	struct input_dev *input = tsc->dev;
+
+	/*
+	 * Suspend and resume can be called when the device hasn't been
+	 * enabled. If there are no users that have the device open, then
+	 * avoid calling the TSC stop and start functions as the TSC
+	 * isn't yet clocked.
+	 */
+	mutex_lock(&input->mutex);
+
+	if (input->users) {
+		if (device_may_wakeup(dev))
+			enable_irq_wake(tsc->irq);
+		else
+			lpc32xx_stop_tsc(tsc);
+	}
+
+	mutex_unlock(&input->mutex);
+
+	return 0;
+}
+
+static int lpc32xx_ts_resume(struct device *dev)
+{
+	struct lpc32xx_tsc *tsc = dev_get_drvdata(dev);
+	struct input_dev *input = tsc->dev;
+
+	mutex_lock(&input->mutex);
+
+	if (input->users) {
+		if (device_may_wakeup(dev))
+			disable_irq_wake(tsc->irq);
+		else
+			lpc32xx_setup_tsc(tsc);
+	}
+
+	mutex_unlock(&input->mutex);
+
+	return 0;
+}
+
+static const struct dev_pm_ops lpc32xx_ts_pm_ops = {
+	.suspend	= lpc32xx_ts_suspend,
+	.resume		= lpc32xx_ts_resume,
+};
+#define LPC32XX_TS_PM_OPS (&lpc32xx_ts_pm_ops)
+#else
+#define LPC32XX_TS_PM_OPS NULL
+#endif
+
+static struct platform_driver lpc32xx_ts_driver = {
+	.probe		= lpc32xx_ts_probe,
+	.remove		= __devexit_p(lpc32xx_ts_remove),
+	.driver		= {
+		.name	= MOD_NAME,
+		.owner	= THIS_MODULE,
+		.pm	= LPC32XX_TS_PM_OPS,
+	},
+};
+
+static int __init lpc32xx_ts_init(void)
+{
+	return platform_driver_register(&lpc32xx_ts_driver);
+}
+module_init(lpc32xx_ts_init);
+
+static void __exit lpc32xx_ts_exit(void)
+{
+	platform_driver_unregister(&lpc32xx_ts_driver);
+}
+module_exit(lpc32xx_ts_exit);
+
+MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com");
+MODULE_DESCRIPTION("LPC32XX TSC Driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:lpc32xx_ts");
