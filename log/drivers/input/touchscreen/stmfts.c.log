commit 5fc70e350edd30fb22d2f9b4e6d680c5471890ff
Author: Jiada Wang <jiada_wang@mentor.com>
Date:   Mon May 11 13:12:13 2020 -0700

    Input: introduce input_mt_report_slot_inactive()
    
    input_mt_report_slot_state() ignores "tool" argument when the slot is
    closed, which has caused a bit of confusion. Let's introduce
    input_mt_report_slot_inactive() to report inactive slot state.
    
    Suggested-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Jiada Wang <jiada_wang@mentor.com>
    Link: https://lore.kernel.org/r/20200508055656.96389-2-jiada_wang@mentor.com
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/stmfts.c b/drivers/input/touchscreen/stmfts.c
index b6f95f20f924..b54cc64e4ea6 100644
--- a/drivers/input/touchscreen/stmfts.c
+++ b/drivers/input/touchscreen/stmfts.c
@@ -198,7 +198,7 @@ static void stmfts_report_contact_release(struct stmfts_data *sdata,
 	u8 slot_id = (event[0] & STMFTS_MASK_TOUCH_ID) >> 4;
 
 	input_mt_slot(sdata->input, slot_id);
-	input_mt_report_slot_state(sdata->input, MT_TOOL_FINGER, false);
+	input_mt_report_slot_inactive(sdata->input);
 
 	input_sync(sdata->input);
 }

commit 937c4e552fd1174784045684740edfcea536159d
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Feb 5 14:40:40 2019 -0800

    Input: stmfts - acknowledge that setting brightness is a blocking call
    
    We need to turn regulators on and off when switching brightness, and
    that may block, therefore we have to set stmfts_brightness_set() as
    LED's brightness_set_blocking() method.
    
    Fixes: 78bcac7b2ae1 ("Input: add support for the STMicroelectronics FingerTip touchscreen")
    Acked-by: Andi Shyti <andi@etezian.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/stmfts.c b/drivers/input/touchscreen/stmfts.c
index 704e99046916..b6f95f20f924 100644
--- a/drivers/input/touchscreen/stmfts.c
+++ b/drivers/input/touchscreen/stmfts.c
@@ -106,27 +106,29 @@ struct stmfts_data {
 	bool running;
 };
 
-static void stmfts_brightness_set(struct led_classdev *led_cdev,
+static int stmfts_brightness_set(struct led_classdev *led_cdev,
 					enum led_brightness value)
 {
 	struct stmfts_data *sdata = container_of(led_cdev,
 					struct stmfts_data, led_cdev);
 	int err;
 
-	if (value == sdata->led_status || !sdata->ledvdd)
-		return;
-
-	if (!value) {
-		regulator_disable(sdata->ledvdd);
-	} else {
-		err = regulator_enable(sdata->ledvdd);
-		if (err)
-			dev_warn(&sdata->client->dev,
-				 "failed to disable ledvdd regulator: %d\n",
-				 err);
+	if (value != sdata->led_status && sdata->ledvdd) {
+		if (!value) {
+			regulator_disable(sdata->ledvdd);
+		} else {
+			err = regulator_enable(sdata->ledvdd);
+			if (err) {
+				dev_warn(&sdata->client->dev,
+					 "failed to disable ledvdd regulator: %d\n",
+					 err);
+				return err;
+			}
+		}
+		sdata->led_status = value;
 	}
 
-	sdata->led_status = value;
+	return 0;
 }
 
 static enum led_brightness stmfts_brightness_get(struct led_classdev *led_cdev)
@@ -608,7 +610,7 @@ static int stmfts_enable_led(struct stmfts_data *sdata)
 	sdata->led_cdev.name = STMFTS_DEV_NAME;
 	sdata->led_cdev.max_brightness = LED_ON;
 	sdata->led_cdev.brightness = LED_OFF;
-	sdata->led_cdev.brightness_set = stmfts_brightness_set;
+	sdata->led_cdev.brightness_set_blocking = stmfts_brightness_set;
 	sdata->led_cdev.brightness_get = stmfts_brightness_get;
 
 	err = devm_led_classdev_register(&sdata->client->dev, &sdata->led_cdev);

commit adf313f41a0d6495ac9b313d012a291c6dad6b21
Author: Andi Shyti <andi.shyti@samsung.com>
Date:   Fri Mar 30 11:13:10 2018 -0700

    Input: stmfts, s6sy761 - update my e-mail
    
    Because I will be leaving Samsung soon, for reachability update
    my reference e-mail to etezian.org.
    
    Signed-off-by: Andi Shyti <andi.shyti@samsung.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/stmfts.c b/drivers/input/touchscreen/stmfts.c
index 40c833db150a..704e99046916 100644
--- a/drivers/input/touchscreen/stmfts.c
+++ b/drivers/input/touchscreen/stmfts.c
@@ -2,7 +2,7 @@
 // STMicroelectronics FTS Touchscreen device driver
 //
 // Copyright (c) 2017 Samsung Electronics Co., Ltd.
-// Copyright (c) 2017 Andi Shyti <andi.shyti@samsung.com>
+// Copyright (c) 2017 Andi Shyti <andi@etezian.org>
 
 #include <linux/delay.h>
 #include <linux/i2c.h>

commit 1d960003603403f28b9d391087905491b98f3923
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Fri Mar 30 11:12:21 2018 -0700

    Input: stmfts - use async probe & suspend/resume to avoid 2s delay
    
    Executing stmfts_power_on() function lasts over 2 seconds, what
    significantly slows down the boot and resume processes if driver is
    compiled in. Avoid this delay by forcing this driver to be probed
    and suspended/resumed asynchronously.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/stmfts.c b/drivers/input/touchscreen/stmfts.c
index efdb1a75a163..40c833db150a 100644
--- a/drivers/input/touchscreen/stmfts.c
+++ b/drivers/input/touchscreen/stmfts.c
@@ -730,6 +730,7 @@ static int stmfts_probe(struct i2c_client *client,
 		return err;
 
 	pm_runtime_enable(&client->dev);
+	device_enable_async_suspend(&client->dev);
 
 	return 0;
 }
@@ -805,6 +806,7 @@ static struct i2c_driver stmfts_driver = {
 		.name = STMFTS_DEV_NAME,
 		.of_match_table = of_match_ptr(stmfts_of_match),
 		.pm = &stmfts_pm_ops,
+		.probe_type = PROBE_PREFER_ASYNCHRONOUS,
 	},
 	.probe = stmfts_probe,
 	.remove = stmfts_remove,

commit cba04cdf437d745fac85220d1d692a9ae23d7004
Author: Andi Shyti <andi.shyti@samsung.com>
Date:   Mon Jan 22 17:32:46 2018 -0800

    Input: stmfts - set IRQ_NOAUTOEN to the irq flag
    
    The interrupt is requested before the device is powered on and
    it's value in some cases cannot be reliable. It happens on some
    devices that an interrupt is generated as soon as requested
    before having the chance to disable the irq.
    
    Set the irq flag as IRQ_NOAUTOEN before requesting it.
    
    This patch mutes the error:
    
      stmfts 2-0049: failed to read events: -11
    
    received sometimes during boot time.
    
    Signed-off-by: Andi Shyti <andi.shyti@samsung.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/stmfts.c b/drivers/input/touchscreen/stmfts.c
index 2a123e20a42e..efdb1a75a163 100644
--- a/drivers/input/touchscreen/stmfts.c
+++ b/drivers/input/touchscreen/stmfts.c
@@ -682,6 +682,14 @@ static int stmfts_probe(struct i2c_client *client,
 
 	input_set_drvdata(sdata->input, sdata);
 
+	/*
+	 * stmfts_power_on expects interrupt to be disabled, but
+	 * at this point the device is still off and I do not trust
+	 * the status of the irq line that can generate some spurious
+	 * interrupts. To be on the safe side it's better to not enable
+	 * the interrupts during their request.
+	 */
+	irq_set_status_flags(client->irq, IRQ_NOAUTOEN);
 	err = devm_request_threaded_irq(&client->dev, client->irq,
 					NULL, stmfts_irq_handler,
 					IRQF_ONESHOT,
@@ -689,9 +697,6 @@ static int stmfts_probe(struct i2c_client *client,
 	if (err)
 		return err;
 
-	/* stmfts_power_on expects interrupt to be disabled */
-	disable_irq(client->irq);
-
 	dev_dbg(&client->dev, "initializing ST-Microelectronics FTS...\n");
 
 	err = stmfts_power_on(sdata);

commit f8c5938f6919bfe7b82ed34472bee1eb637ddbea
Author: Andi Shyti <andi.shyti@samsung.com>
Date:   Mon Jan 22 11:23:27 2018 -0800

    Input: stmfts,s6sy671 - add SPDX identifier
    
    Replace the original license statement with the SPDX identifier.
    
    Update also the copyright owner adding myself as co-owner of the
    copyright.
    
    Signed-off-by: Andi Shyti <andi.shyti@samsung.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/stmfts.c b/drivers/input/touchscreen/stmfts.c
index c12d01899939..2a123e20a42e 100644
--- a/drivers/input/touchscreen/stmfts.c
+++ b/drivers/input/touchscreen/stmfts.c
@@ -1,13 +1,8 @@
-/*
- * Copyright (c) 2017 Samsung Electronics Co., Ltd.
- * Author: Andi Shyti <andi.shyti@samsung.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * STMicroelectronics FTS Touchscreen device driver
- */
+// SPDX-License-Identifier: GPL-2.0
+// STMicroelectronics FTS Touchscreen device driver
+//
+// Copyright (c) 2017 Samsung Electronics Co., Ltd.
+// Copyright (c) 2017 Andi Shyti <andi.shyti@samsung.com>
 
 #include <linux/delay.h>
 #include <linux/i2c.h>

commit 91de76e661a266731fc2889a398ad1694df9d523
Merge: aed5d0ee77c0 bb176f67090c
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Mon Oct 23 11:43:40 2017 -0700

    Merge tag 'v4.14-rc6' into next
    
    Merge with mainline to bring in the timer API changes.

commit c9bfb2f0031a2de664147ebbfb90f95bb12fdf79
Author: Chanwoo Choi <cw00.choi@samsung.com>
Date:   Wed Oct 18 17:28:36 2017 -0700

    Input: stmfts - fix setting ABS_MT_POSITION_* maximum size
    
    The commit 78bcac7b2ae1e ("Input: add support for the STMicroelectronics
    FingerTip touchscreen) used the 'touchscreen_parse_properties()' helper
    function in order to get the value of common properties.
    
    But, commit 78bcac7b2ae1e didn't set the capability of ABS_MT_POSITION_*
    before calling touchscreen_parse_properties(). In result, the max_x and
    max_y of 'struct touchscreen_properties' were not set.
    
    Fixes: 78bcac7b2ae1e ("Input: add support for the STMicroelectronics FingerTip touchscreen")
    Cc: stable@vger.kernel.org
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/stmfts.c b/drivers/input/touchscreen/stmfts.c
index 157fdb4bb2e8..8c6c6178ec12 100644
--- a/drivers/input/touchscreen/stmfts.c
+++ b/drivers/input/touchscreen/stmfts.c
@@ -663,12 +663,10 @@ static int stmfts_probe(struct i2c_client *client,
 	sdata->input->open = stmfts_input_open;
 	sdata->input->close = stmfts_input_close;
 
+	input_set_capability(sdata->input, EV_ABS, ABS_MT_POSITION_X);
+	input_set_capability(sdata->input, EV_ABS, ABS_MT_POSITION_Y);
 	touchscreen_parse_properties(sdata->input, true, &sdata->prop);
 
-	input_set_abs_params(sdata->input, ABS_MT_POSITION_X, 0,
-						sdata->prop.max_x, 0, 0);
-	input_set_abs_params(sdata->input, ABS_MT_POSITION_Y, 0,
-						sdata->prop.max_y, 0, 0);
 	input_set_abs_params(sdata->input, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
 	input_set_abs_params(sdata->input, ABS_MT_TOUCH_MINOR, 0, 255, 0, 0);
 	input_set_abs_params(sdata->input, ABS_MT_ORIENTATION, 0, 255, 0, 0);

commit c2690bd69788c618bb75e1c7a71582ea93375fdf
Author: Andi Shyti <andi.shyti@samsung.com>
Date:   Fri Sep 22 09:57:53 2017 -0700

    Input: stmfts - use devm_device_add_group
    
    instead of sysfs_create_group.
    
    Signed-off-by: Andi Shyti <andi.shyti@samsung.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/stmfts.c b/drivers/input/touchscreen/stmfts.c
index 157fdb4bb2e8..2351199189a4 100644
--- a/drivers/input/touchscreen/stmfts.c
+++ b/drivers/input/touchscreen/stmfts.c
@@ -727,8 +727,7 @@ static int stmfts_probe(struct i2c_client *client,
 		}
 	}
 
-	err = sysfs_create_group(&sdata->client->dev.kobj,
-				 &stmfts_attribute_group);
+	err = devm_device_add_group(&client->dev, &stmfts_attribute_group);
 	if (err)
 		return err;
 
@@ -740,7 +739,6 @@ static int stmfts_probe(struct i2c_client *client,
 static int stmfts_remove(struct i2c_client *client)
 {
 	pm_runtime_disable(&client->dev);
-	sysfs_remove_group(&client->dev.kobj, &stmfts_attribute_group);
 
 	return 0;
 }

commit d4c9354b4015aa8d1b032c368682dd20a00f4e1f
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Jun 9 09:54:09 2017 -0700

    Input: stmfts - mark all PM functions as __maybe_unused
    
    We get a harmless warning when CONFIG_RUNTIME_PM is disabled:
    
    drivers/input/touchscreen/stmfts.c:760:12: error: 'stmfts_runtime_resume' defined but not used [-Werror=unused-function]
     static int stmfts_runtime_resume(struct device *dev)
    drivers/input/touchscreen/stmfts.c:748:12: error: 'stmfts_runtime_suspend' defined but not used [-Werror=unused-function]
     static int stmfts_runtime_suspend(struct device *dev)
    
    The regular PM functions are already marked as __maybe_unused, so let's
    do the same for the runtime-PM as well.
    
    Fixes: 78bcac7b2ae1 ("Input: add support for the STMicroelectronics FingerTip touchscreen")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/stmfts.c b/drivers/input/touchscreen/stmfts.c
index 802d0e82d034..157fdb4bb2e8 100644
--- a/drivers/input/touchscreen/stmfts.c
+++ b/drivers/input/touchscreen/stmfts.c
@@ -745,7 +745,7 @@ static int stmfts_remove(struct i2c_client *client)
 	return 0;
 }
 
-static int stmfts_runtime_suspend(struct device *dev)
+static int __maybe_unused stmfts_runtime_suspend(struct device *dev)
 {
 	struct stmfts_data *sdata = dev_get_drvdata(dev);
 	int ret;
@@ -757,7 +757,7 @@ static int stmfts_runtime_suspend(struct device *dev)
 	return ret;
 }
 
-static int stmfts_runtime_resume(struct device *dev)
+static int __maybe_unused stmfts_runtime_resume(struct device *dev)
 {
 	struct stmfts_data *sdata = dev_get_drvdata(dev);
 	int ret;

commit 78bcac7b2ae1e4f6e96c68ff353c140669ea231c
Author: Andi Shyti <andi.shyti@samsung.com>
Date:   Mon Jun 5 15:29:18 2017 -0700

    Input: add support for the STMicroelectronics FingerTip touchscreen
    
    The stmfts (ST-Microelectronics FingerTip S) touchscreen device is a
    capacitive multi-touch controller mainly for mobile use.  It's connected
    through i2c bus at the address 0x49 and it interfaces with userspace
    through input event interface.
    
    At the current state it provides a touchscreen multitouch functionality up
    to 10 fingers. Each finger is enumerated with a distinctive id (from 0 to
    9).
    
    If enabled the device can support single "touch" hovering, by providing
    three coordinates, x, y and distance.
    
    It is possible to select the touchkey functionality which provides a basic
    two keys interface for "home" and "back" menu, typical in mobile phones.
    
    Signed-off-by: Andi Shyti <andi.shyti@samsung.com>
    Reviewed-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/stmfts.c b/drivers/input/touchscreen/stmfts.c
new file mode 100644
index 000000000000..802d0e82d034
--- /dev/null
+++ b/drivers/input/touchscreen/stmfts.c
@@ -0,0 +1,822 @@
+/*
+ * Copyright (c) 2017 Samsung Electronics Co., Ltd.
+ * Author: Andi Shyti <andi.shyti@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * STMicroelectronics FTS Touchscreen device driver
+ */
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/input/mt.h>
+#include <linux/input/touchscreen.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/leds.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+
+/* I2C commands */
+#define STMFTS_READ_INFO			0x80
+#define STMFTS_READ_STATUS			0x84
+#define STMFTS_READ_ONE_EVENT			0x85
+#define STMFTS_READ_ALL_EVENT			0x86
+#define STMFTS_LATEST_EVENT			0x87
+#define STMFTS_SLEEP_IN				0x90
+#define STMFTS_SLEEP_OUT			0x91
+#define STMFTS_MS_MT_SENSE_OFF			0x92
+#define STMFTS_MS_MT_SENSE_ON			0x93
+#define STMFTS_SS_HOVER_SENSE_OFF		0x94
+#define STMFTS_SS_HOVER_SENSE_ON		0x95
+#define STMFTS_MS_KEY_SENSE_OFF			0x9a
+#define STMFTS_MS_KEY_SENSE_ON			0x9b
+#define STMFTS_SYSTEM_RESET			0xa0
+#define STMFTS_CLEAR_EVENT_STACK		0xa1
+#define STMFTS_FULL_FORCE_CALIBRATION		0xa2
+#define STMFTS_MS_CX_TUNING			0xa3
+#define STMFTS_SS_CX_TUNING			0xa4
+
+/* events */
+#define STMFTS_EV_NO_EVENT			0x00
+#define STMFTS_EV_MULTI_TOUCH_DETECTED		0x02
+#define STMFTS_EV_MULTI_TOUCH_ENTER		0x03
+#define STMFTS_EV_MULTI_TOUCH_LEAVE		0x04
+#define STMFTS_EV_MULTI_TOUCH_MOTION		0x05
+#define STMFTS_EV_HOVER_ENTER			0x07
+#define STMFTS_EV_HOVER_LEAVE			0x08
+#define STMFTS_EV_HOVER_MOTION			0x09
+#define STMFTS_EV_KEY_STATUS			0x0e
+#define STMFTS_EV_ERROR				0x0f
+#define STMFTS_EV_CONTROLLER_READY		0x10
+#define STMFTS_EV_SLEEP_OUT_CONTROLLER_READY	0x11
+#define STMFTS_EV_STATUS			0x16
+#define STMFTS_EV_DEBUG				0xdb
+
+/* multi touch related event masks */
+#define STMFTS_MASK_EVENT_ID			0x0f
+#define STMFTS_MASK_TOUCH_ID			0xf0
+#define STMFTS_MASK_LEFT_EVENT			0x0f
+#define STMFTS_MASK_X_MSB			0x0f
+#define STMFTS_MASK_Y_LSB			0xf0
+
+/* key related event masks */
+#define STMFTS_MASK_KEY_NO_TOUCH		0x00
+#define STMFTS_MASK_KEY_MENU			0x01
+#define STMFTS_MASK_KEY_BACK			0x02
+
+#define STMFTS_EVENT_SIZE	8
+#define STMFTS_STACK_DEPTH	32
+#define STMFTS_DATA_MAX_SIZE	(STMFTS_EVENT_SIZE * STMFTS_STACK_DEPTH)
+#define STMFTS_MAX_FINGERS	10
+#define STMFTS_DEV_NAME		"stmfts"
+
+enum stmfts_regulators {
+	STMFTS_REGULATOR_VDD,
+	STMFTS_REGULATOR_AVDD,
+};
+
+struct stmfts_data {
+	struct i2c_client *client;
+	struct input_dev *input;
+	struct led_classdev led_cdev;
+	struct mutex mutex;
+
+	struct touchscreen_properties prop;
+
+	struct regulator_bulk_data regulators[2];
+
+	/*
+	 * Presence of ledvdd will be used also to check
+	 * whether the LED is supported.
+	 */
+	struct regulator *ledvdd;
+
+	u16 chip_id;
+	u8 chip_ver;
+	u16 fw_ver;
+	u8 config_id;
+	u8 config_ver;
+
+	u8 data[STMFTS_DATA_MAX_SIZE];
+
+	struct completion cmd_done;
+
+	bool use_key;
+	bool led_status;
+	bool hover_enabled;
+	bool running;
+};
+
+static void stmfts_brightness_set(struct led_classdev *led_cdev,
+					enum led_brightness value)
+{
+	struct stmfts_data *sdata = container_of(led_cdev,
+					struct stmfts_data, led_cdev);
+	int err;
+
+	if (value == sdata->led_status || !sdata->ledvdd)
+		return;
+
+	if (!value) {
+		regulator_disable(sdata->ledvdd);
+	} else {
+		err = regulator_enable(sdata->ledvdd);
+		if (err)
+			dev_warn(&sdata->client->dev,
+				 "failed to disable ledvdd regulator: %d\n",
+				 err);
+	}
+
+	sdata->led_status = value;
+}
+
+static enum led_brightness stmfts_brightness_get(struct led_classdev *led_cdev)
+{
+	struct stmfts_data *sdata = container_of(led_cdev,
+						struct stmfts_data, led_cdev);
+
+	return !!regulator_is_enabled(sdata->ledvdd);
+}
+
+/*
+ * We can't simply use i2c_smbus_read_i2c_block_data because we
+ * need to read more than 255 bytes (
+ */
+static int stmfts_read_events(struct stmfts_data *sdata)
+{
+	u8 cmd = STMFTS_READ_ALL_EVENT;
+	struct i2c_msg msgs[2] = {
+		{
+			.addr	= sdata->client->addr,
+			.len	= 1,
+			.buf	= &cmd,
+		},
+		{
+			.addr	= sdata->client->addr,
+			.flags	= I2C_M_RD,
+			.len	= STMFTS_DATA_MAX_SIZE,
+			.buf	= sdata->data,
+		},
+	};
+	int ret;
+
+	ret = i2c_transfer(sdata->client->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret < 0)
+		return ret;
+
+	return ret == ARRAY_SIZE(msgs) ? 0 : -EIO;
+}
+
+static void stmfts_report_contact_event(struct stmfts_data *sdata,
+					const u8 event[])
+{
+	u8 slot_id = (event[0] & STMFTS_MASK_TOUCH_ID) >> 4;
+	u16 x = event[1] | ((event[2] & STMFTS_MASK_X_MSB) << 8);
+	u16 y = (event[2] >> 4) | (event[3] << 4);
+	u8 maj = event[4];
+	u8 min = event[5];
+	u8 orientation = event[6];
+	u8 area = event[7];
+
+	input_mt_slot(sdata->input, slot_id);
+
+	input_mt_report_slot_state(sdata->input, MT_TOOL_FINGER, true);
+	input_report_abs(sdata->input, ABS_MT_POSITION_X, x);
+	input_report_abs(sdata->input, ABS_MT_POSITION_Y, y);
+	input_report_abs(sdata->input, ABS_MT_TOUCH_MAJOR, maj);
+	input_report_abs(sdata->input, ABS_MT_TOUCH_MINOR, min);
+	input_report_abs(sdata->input, ABS_MT_PRESSURE, area);
+	input_report_abs(sdata->input, ABS_MT_ORIENTATION, orientation);
+
+	input_sync(sdata->input);
+}
+
+static void stmfts_report_contact_release(struct stmfts_data *sdata,
+					  const u8 event[])
+{
+	u8 slot_id = (event[0] & STMFTS_MASK_TOUCH_ID) >> 4;
+
+	input_mt_slot(sdata->input, slot_id);
+	input_mt_report_slot_state(sdata->input, MT_TOOL_FINGER, false);
+
+	input_sync(sdata->input);
+}
+
+static void stmfts_report_hover_event(struct stmfts_data *sdata,
+				      const u8 event[])
+{
+	u16 x = (event[2] << 4) | (event[4] >> 4);
+	u16 y = (event[3] << 4) | (event[4] & STMFTS_MASK_Y_LSB);
+	u8 z = event[5];
+
+	input_report_abs(sdata->input, ABS_X, x);
+	input_report_abs(sdata->input, ABS_Y, y);
+	input_report_abs(sdata->input, ABS_DISTANCE, z);
+
+	input_sync(sdata->input);
+}
+
+static void stmfts_report_key_event(struct stmfts_data *sdata, const u8 event[])
+{
+	switch (event[2]) {
+	case 0:
+		input_report_key(sdata->input, KEY_BACK, 0);
+		input_report_key(sdata->input, KEY_MENU, 0);
+		break;
+
+	case STMFTS_MASK_KEY_BACK:
+		input_report_key(sdata->input, KEY_BACK, 1);
+		break;
+
+	case STMFTS_MASK_KEY_MENU:
+		input_report_key(sdata->input, KEY_MENU, 1);
+		break;
+
+	default:
+		dev_warn(&sdata->client->dev,
+			 "unknown key event: %#02x\n", event[2]);
+		break;
+	}
+
+	input_sync(sdata->input);
+}
+
+static void stmfts_parse_events(struct stmfts_data *sdata)
+{
+	int i;
+
+	for (i = 0; i < STMFTS_STACK_DEPTH; i++) {
+		u8 *event = &sdata->data[i * STMFTS_EVENT_SIZE];
+
+		switch (event[0]) {
+
+		case STMFTS_EV_CONTROLLER_READY:
+		case STMFTS_EV_SLEEP_OUT_CONTROLLER_READY:
+		case STMFTS_EV_STATUS:
+			complete(&sdata->cmd_done);
+			/* fall through */
+
+		case STMFTS_EV_NO_EVENT:
+		case STMFTS_EV_DEBUG:
+			return;
+		}
+
+		switch (event[0] & STMFTS_MASK_EVENT_ID) {
+
+		case STMFTS_EV_MULTI_TOUCH_ENTER:
+		case STMFTS_EV_MULTI_TOUCH_MOTION:
+			stmfts_report_contact_event(sdata, event);
+			break;
+
+		case STMFTS_EV_MULTI_TOUCH_LEAVE:
+			stmfts_report_contact_release(sdata, event);
+			break;
+
+		case STMFTS_EV_HOVER_ENTER:
+		case STMFTS_EV_HOVER_LEAVE:
+		case STMFTS_EV_HOVER_MOTION:
+			stmfts_report_hover_event(sdata, event);
+			break;
+
+		case STMFTS_EV_KEY_STATUS:
+			stmfts_report_key_event(sdata, event);
+			break;
+
+		case STMFTS_EV_ERROR:
+			dev_warn(&sdata->client->dev,
+					"error code: 0x%x%x%x%x%x%x",
+					event[6], event[5], event[4],
+					event[3], event[2], event[1]);
+			break;
+
+		default:
+			dev_err(&sdata->client->dev,
+				"unknown event %#02x\n", event[0]);
+		}
+	}
+}
+
+static irqreturn_t stmfts_irq_handler(int irq, void *dev)
+{
+	struct stmfts_data *sdata = dev;
+	int err;
+
+	mutex_lock(&sdata->mutex);
+
+	err = stmfts_read_events(sdata);
+	if (unlikely(err))
+		dev_err(&sdata->client->dev,
+			"failed to read events: %d\n", err);
+	else
+		stmfts_parse_events(sdata);
+
+	mutex_unlock(&sdata->mutex);
+	return IRQ_HANDLED;
+}
+
+static int stmfts_command(struct stmfts_data *sdata, const u8 cmd)
+{
+	int err;
+
+	reinit_completion(&sdata->cmd_done);
+
+	err = i2c_smbus_write_byte(sdata->client, cmd);
+	if (err)
+		return err;
+
+	if (!wait_for_completion_timeout(&sdata->cmd_done,
+					 msecs_to_jiffies(1000)))
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+static int stmfts_input_open(struct input_dev *dev)
+{
+	struct stmfts_data *sdata = input_get_drvdata(dev);
+	int err;
+
+	err = pm_runtime_get_sync(&sdata->client->dev);
+	if (err < 0)
+		return err;
+
+	err = i2c_smbus_write_byte(sdata->client, STMFTS_MS_MT_SENSE_ON);
+	if (err)
+		return err;
+
+	mutex_lock(&sdata->mutex);
+	sdata->running = true;
+
+	if (sdata->hover_enabled) {
+		err = i2c_smbus_write_byte(sdata->client,
+					   STMFTS_SS_HOVER_SENSE_ON);
+		if (err)
+			dev_warn(&sdata->client->dev,
+				 "failed to enable hover\n");
+	}
+	mutex_unlock(&sdata->mutex);
+
+	if (sdata->use_key) {
+		err = i2c_smbus_write_byte(sdata->client,
+					   STMFTS_MS_KEY_SENSE_ON);
+		if (err)
+			/* I can still use only the touch screen */
+			dev_warn(&sdata->client->dev,
+				 "failed to enable touchkey\n");
+	}
+
+	return 0;
+}
+
+static void stmfts_input_close(struct input_dev *dev)
+{
+	struct stmfts_data *sdata = input_get_drvdata(dev);
+	int err;
+
+	err = i2c_smbus_write_byte(sdata->client, STMFTS_MS_MT_SENSE_OFF);
+	if (err)
+		dev_warn(&sdata->client->dev,
+			 "failed to disable touchscreen: %d\n", err);
+
+	mutex_lock(&sdata->mutex);
+
+	sdata->running = false;
+
+	if (sdata->hover_enabled) {
+		err = i2c_smbus_write_byte(sdata->client,
+					   STMFTS_SS_HOVER_SENSE_OFF);
+		if (err)
+			dev_warn(&sdata->client->dev,
+				 "failed to disable hover: %d\n", err);
+	}
+	mutex_unlock(&sdata->mutex);
+
+	if (sdata->use_key) {
+		err = i2c_smbus_write_byte(sdata->client,
+					   STMFTS_MS_KEY_SENSE_OFF);
+		if (err)
+			dev_warn(&sdata->client->dev,
+				 "failed to disable touchkey: %d\n", err);
+	}
+
+	pm_runtime_put_sync(&sdata->client->dev);
+}
+
+static ssize_t stmfts_sysfs_chip_id(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct stmfts_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%#x\n", sdata->chip_id);
+}
+
+static ssize_t stmfts_sysfs_chip_version(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct stmfts_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", sdata->chip_ver);
+}
+
+static ssize_t stmfts_sysfs_fw_ver(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct stmfts_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", sdata->fw_ver);
+}
+
+static ssize_t stmfts_sysfs_config_id(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct stmfts_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%#x\n", sdata->config_id);
+}
+
+static ssize_t stmfts_sysfs_config_version(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct stmfts_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", sdata->config_ver);
+}
+
+static ssize_t stmfts_sysfs_read_status(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct stmfts_data *sdata = dev_get_drvdata(dev);
+	u8 status[4];
+	int err;
+
+	err = i2c_smbus_read_i2c_block_data(sdata->client, STMFTS_READ_STATUS,
+					    sizeof(status), status);
+	if (err)
+		return err;
+
+	return sprintf(buf, "%#02x\n", status[0]);
+}
+
+static ssize_t stmfts_sysfs_hover_enable_read(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct stmfts_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", sdata->hover_enabled);
+}
+
+static ssize_t stmfts_sysfs_hover_enable_write(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t len)
+{
+	struct stmfts_data *sdata = dev_get_drvdata(dev);
+	unsigned long value;
+	int err = 0;
+
+	if (kstrtoul(buf, 0, &value))
+		return -EINVAL;
+
+	mutex_lock(&sdata->mutex);
+
+	if (value & sdata->hover_enabled)
+		goto out;
+
+	if (sdata->running)
+		err = i2c_smbus_write_byte(sdata->client,
+					   value ? STMFTS_SS_HOVER_SENSE_ON :
+						   STMFTS_SS_HOVER_SENSE_OFF);
+
+	if (!err)
+		sdata->hover_enabled = !!value;
+
+out:
+	mutex_unlock(&sdata->mutex);
+
+	return len;
+}
+
+static DEVICE_ATTR(chip_id, 0444, stmfts_sysfs_chip_id, NULL);
+static DEVICE_ATTR(chip_version, 0444, stmfts_sysfs_chip_version, NULL);
+static DEVICE_ATTR(fw_ver, 0444, stmfts_sysfs_fw_ver, NULL);
+static DEVICE_ATTR(config_id, 0444, stmfts_sysfs_config_id, NULL);
+static DEVICE_ATTR(config_version, 0444, stmfts_sysfs_config_version, NULL);
+static DEVICE_ATTR(status, 0444, stmfts_sysfs_read_status, NULL);
+static DEVICE_ATTR(hover_enable, 0644, stmfts_sysfs_hover_enable_read,
+					stmfts_sysfs_hover_enable_write);
+
+static struct attribute *stmfts_sysfs_attrs[] = {
+	&dev_attr_chip_id.attr,
+	&dev_attr_chip_version.attr,
+	&dev_attr_fw_ver.attr,
+	&dev_attr_config_id.attr,
+	&dev_attr_config_version.attr,
+	&dev_attr_status.attr,
+	&dev_attr_hover_enable.attr,
+	NULL
+};
+
+static struct attribute_group stmfts_attribute_group = {
+	.attrs = stmfts_sysfs_attrs
+};
+
+static int stmfts_power_on(struct stmfts_data *sdata)
+{
+	int err;
+	u8 reg[8];
+
+	err = regulator_bulk_enable(ARRAY_SIZE(sdata->regulators),
+				    sdata->regulators);
+	if (err)
+		return err;
+
+	/*
+	 * The datasheet does not specify the power on time, but considering
+	 * that the reset time is < 10ms, I sleep 20ms to be sure
+	 */
+	msleep(20);
+
+	err = i2c_smbus_read_i2c_block_data(sdata->client, STMFTS_READ_INFO,
+					    sizeof(reg), reg);
+	if (err < 0)
+		return err;
+	if (err != sizeof(reg))
+		return -EIO;
+
+	sdata->chip_id = be16_to_cpup((__be16 *)&reg[6]);
+	sdata->chip_ver = reg[0];
+	sdata->fw_ver = be16_to_cpup((__be16 *)&reg[2]);
+	sdata->config_id = reg[4];
+	sdata->config_ver = reg[5];
+
+	enable_irq(sdata->client->irq);
+
+	msleep(50);
+
+	err = stmfts_command(sdata, STMFTS_SYSTEM_RESET);
+	if (err)
+		return err;
+
+	err = stmfts_command(sdata, STMFTS_SLEEP_OUT);
+	if (err)
+		return err;
+
+	/* optional tuning */
+	err = stmfts_command(sdata, STMFTS_MS_CX_TUNING);
+	if (err)
+		dev_warn(&sdata->client->dev,
+			 "failed to perform mutual auto tune: %d\n", err);
+
+	/* optional tuning */
+	err = stmfts_command(sdata, STMFTS_SS_CX_TUNING);
+	if (err)
+		dev_warn(&sdata->client->dev,
+			 "failed to perform self auto tune: %d\n", err);
+
+	err = stmfts_command(sdata, STMFTS_FULL_FORCE_CALIBRATION);
+	if (err)
+		return err;
+
+	/*
+	 * At this point no one is using the touchscreen
+	 * and I don't really care about the return value
+	 */
+	(void) i2c_smbus_write_byte(sdata->client, STMFTS_SLEEP_IN);
+
+	return 0;
+}
+
+static void stmfts_power_off(void *data)
+{
+	struct stmfts_data *sdata = data;
+
+	disable_irq(sdata->client->irq);
+	regulator_bulk_disable(ARRAY_SIZE(sdata->regulators),
+						sdata->regulators);
+}
+
+/* This function is void because I don't want to prevent using the touch key
+ * only because the LEDs don't get registered
+ */
+static int stmfts_enable_led(struct stmfts_data *sdata)
+{
+	int err;
+
+	/* get the regulator for powering the leds on */
+	sdata->ledvdd = devm_regulator_get(&sdata->client->dev, "ledvdd");
+	if (IS_ERR(sdata->ledvdd))
+		return PTR_ERR(sdata->ledvdd);
+
+	sdata->led_cdev.name = STMFTS_DEV_NAME;
+	sdata->led_cdev.max_brightness = LED_ON;
+	sdata->led_cdev.brightness = LED_OFF;
+	sdata->led_cdev.brightness_set = stmfts_brightness_set;
+	sdata->led_cdev.brightness_get = stmfts_brightness_get;
+
+	err = devm_led_classdev_register(&sdata->client->dev, &sdata->led_cdev);
+	if (err) {
+		devm_regulator_put(sdata->ledvdd);
+		return err;
+	}
+
+	return 0;
+}
+
+static int stmfts_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	int err;
+	struct stmfts_data *sdata;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C |
+						I2C_FUNC_SMBUS_BYTE_DATA |
+						I2C_FUNC_SMBUS_I2C_BLOCK))
+		return -ENODEV;
+
+	sdata = devm_kzalloc(&client->dev, sizeof(*sdata), GFP_KERNEL);
+	if (!sdata)
+		return -ENOMEM;
+
+	i2c_set_clientdata(client, sdata);
+
+	sdata->client = client;
+	mutex_init(&sdata->mutex);
+	init_completion(&sdata->cmd_done);
+
+	sdata->regulators[STMFTS_REGULATOR_VDD].supply = "vdd";
+	sdata->regulators[STMFTS_REGULATOR_AVDD].supply = "avdd";
+	err = devm_regulator_bulk_get(&client->dev,
+				      ARRAY_SIZE(sdata->regulators),
+				      sdata->regulators);
+	if (err)
+		return err;
+
+	sdata->input = devm_input_allocate_device(&client->dev);
+	if (!sdata->input)
+		return -ENOMEM;
+
+	sdata->input->name = STMFTS_DEV_NAME;
+	sdata->input->id.bustype = BUS_I2C;
+	sdata->input->open = stmfts_input_open;
+	sdata->input->close = stmfts_input_close;
+
+	touchscreen_parse_properties(sdata->input, true, &sdata->prop);
+
+	input_set_abs_params(sdata->input, ABS_MT_POSITION_X, 0,
+						sdata->prop.max_x, 0, 0);
+	input_set_abs_params(sdata->input, ABS_MT_POSITION_Y, 0,
+						sdata->prop.max_y, 0, 0);
+	input_set_abs_params(sdata->input, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(sdata->input, ABS_MT_TOUCH_MINOR, 0, 255, 0, 0);
+	input_set_abs_params(sdata->input, ABS_MT_ORIENTATION, 0, 255, 0, 0);
+	input_set_abs_params(sdata->input, ABS_MT_PRESSURE, 0, 255, 0, 0);
+	input_set_abs_params(sdata->input, ABS_DISTANCE, 0, 255, 0, 0);
+
+	sdata->use_key = device_property_read_bool(&client->dev,
+						   "touch-key-connected");
+	if (sdata->use_key) {
+		input_set_capability(sdata->input, EV_KEY, KEY_MENU);
+		input_set_capability(sdata->input, EV_KEY, KEY_BACK);
+	}
+
+	err = input_mt_init_slots(sdata->input,
+				  STMFTS_MAX_FINGERS, INPUT_MT_DIRECT);
+	if (err)
+		return err;
+
+	input_set_drvdata(sdata->input, sdata);
+
+	err = devm_request_threaded_irq(&client->dev, client->irq,
+					NULL, stmfts_irq_handler,
+					IRQF_ONESHOT,
+					"stmfts_irq", sdata);
+	if (err)
+		return err;
+
+	/* stmfts_power_on expects interrupt to be disabled */
+	disable_irq(client->irq);
+
+	dev_dbg(&client->dev, "initializing ST-Microelectronics FTS...\n");
+
+	err = stmfts_power_on(sdata);
+	if (err)
+		return err;
+
+	err = devm_add_action_or_reset(&client->dev, stmfts_power_off, sdata);
+	if (err)
+		return err;
+
+	err = input_register_device(sdata->input);
+	if (err)
+		return err;
+
+	if (sdata->use_key) {
+		err = stmfts_enable_led(sdata);
+		if (err) {
+			/*
+			 * Even if the LEDs have failed to be initialized and
+			 * used in the driver, I can still use the device even
+			 * without LEDs. The ledvdd regulator pointer will be
+			 * used as a flag.
+			 */
+			dev_warn(&client->dev, "unable to use touchkey leds\n");
+			sdata->ledvdd = NULL;
+		}
+	}
+
+	err = sysfs_create_group(&sdata->client->dev.kobj,
+				 &stmfts_attribute_group);
+	if (err)
+		return err;
+
+	pm_runtime_enable(&client->dev);
+
+	return 0;
+}
+
+static int stmfts_remove(struct i2c_client *client)
+{
+	pm_runtime_disable(&client->dev);
+	sysfs_remove_group(&client->dev.kobj, &stmfts_attribute_group);
+
+	return 0;
+}
+
+static int stmfts_runtime_suspend(struct device *dev)
+{
+	struct stmfts_data *sdata = dev_get_drvdata(dev);
+	int ret;
+
+	ret = i2c_smbus_write_byte(sdata->client, STMFTS_SLEEP_IN);
+	if (ret)
+		dev_warn(dev, "failed to suspend device: %d\n", ret);
+
+	return ret;
+}
+
+static int stmfts_runtime_resume(struct device *dev)
+{
+	struct stmfts_data *sdata = dev_get_drvdata(dev);
+	int ret;
+
+	ret = i2c_smbus_write_byte(sdata->client, STMFTS_SLEEP_OUT);
+	if (ret)
+		dev_err(dev, "failed to resume device: %d\n", ret);
+
+	return ret;
+}
+
+static int __maybe_unused stmfts_suspend(struct device *dev)
+{
+	struct stmfts_data *sdata = dev_get_drvdata(dev);
+
+	stmfts_power_off(sdata);
+
+	return 0;
+}
+
+static int __maybe_unused stmfts_resume(struct device *dev)
+{
+	struct stmfts_data *sdata = dev_get_drvdata(dev);
+
+	return stmfts_power_on(sdata);
+}
+
+static const struct dev_pm_ops stmfts_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(stmfts_suspend, stmfts_resume)
+	SET_RUNTIME_PM_OPS(stmfts_runtime_suspend, stmfts_runtime_resume, NULL)
+};
+
+#ifdef CONFIG_OF
+static const struct of_device_id stmfts_of_match[] = {
+	{ .compatible = "st,stmfts", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, stmfts_of_match);
+#endif
+
+static const struct i2c_device_id stmfts_id[] = {
+	{ "stmfts", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, stmfts_id);
+
+static struct i2c_driver stmfts_driver = {
+	.driver = {
+		.name = STMFTS_DEV_NAME,
+		.of_match_table = of_match_ptr(stmfts_of_match),
+		.pm = &stmfts_pm_ops,
+	},
+	.probe = stmfts_probe,
+	.remove = stmfts_remove,
+	.id_table = stmfts_id,
+};
+
+module_i2c_driver(stmfts_driver);
+
+MODULE_AUTHOR("Andi Shyti <andi.shyti@samsung.com>");
+MODULE_DESCRIPTION("STMicroelectronics FTS Touch Screen");
+MODULE_LICENSE("GPL v2");
