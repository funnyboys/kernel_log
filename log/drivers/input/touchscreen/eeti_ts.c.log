commit 073c916bc00571d8662b89a294eba265481b6fbb
Merge: a2d79c7174ae 597473720f4d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 13 14:40:42 2019 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input
    
    Pull input updates from Dmitry Torokhov:
    
     - an update to Elan touchpad SMBus driver to fetch device parameters
       (size, resolution) while it is still in PS/2 mode, before switching
       over to SMBus, as in that mode some devices return garbage dimensions
    
     - update to iforce joystick driver
    
     - miscellaneous driver fixes
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input: (48 commits)
      Input: gpio_keys_polled - allow specifying name of input device
      Input: edt-ft5x06 - simplify event reporting code
      Input: max77650-onkey - add MODULE_ALIAS()
      Input: atmel_mxt_ts - fix leak in mxt_update_cfg()
      Input: synaptics - enable SMBUS on T480 thinkpad trackpad
      Input: atmel_mxt_ts - fix -Wunused-const-variable
      Input: joydev - extend absolute mouse detection
      HID: quirks: Refactor ELAN 400 and 401 handling
      Input: elan_i2c - export the device id whitelist
      Input: edt-ft5x06 - use get_unaligned_be16()
      Input: iforce - add the Saitek R440 Force Wheel
      Input: iforce - use unaligned accessors, where appropriate
      Input: iforce - drop couple of temps from transport code
      Input: iforce - drop bus type from iforce structure
      Input: iforce - use DMA-safe buffores for USB transfers
      Input: iforce - allow callers supply data buffer when fetching device IDs
      Input: iforce - only call iforce_process_packet() if initialized
      Input: iforce - signal command completion from transport code
      Input: iforce - do not combine arguments for iforce_process_packet()
      Input: iforce - factor out hat handling when parsing packets
      ...

commit 736e67ba238fd6935cde5bb9d3ee9d0fc4c1c144
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:09 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 160
    
    Based on 1 normalized pattern(s):
    
      this file is free software you can redistribute it and or modify it
      under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this file is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this library if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.475087903@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index 7fe41965c5d1..c6b85ba7f991 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Touch Screen driver for EETI's I2C connected touch screen panels
  *   Copyright (c) 2009,2018 Daniel Mack <daniel@zonque.org>
@@ -8,20 +9,6 @@
  * Based on migor_ts.c
  *   Copyright (c) 2008 Magnus Damm
  *   Copyright (c) 2007 Ujjwal Pande <ujjwal@kenati.com>
- *
- * This file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU  General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This file is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- * You should have received a copy of the GNU General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
 #include <linux/module.h>

commit b283d0c353dee57869bdff59e0f01500f1316411
Author: Daniel Mack <daniel@zonque.org>
Date:   Mon May 6 20:03:46 2019 -0700

    Input: eeti_ts -  read hardware state once after wakeup
    
    For systems in which the touch IRQ is acting as wakeup source, and that do
    not support level-driven interrupts, the interrupt controller might not
    latch the GPIO IRQ during sleep. In such cases, the interrupt will never
    occur again after resume, hence the touch screen appears dead.
    
    To fix this, check for the assertion of the attn gpio, and read form the
    controller once in the resume path to read the hardware status and
    to arm the IRQ again.
    
    Introduce a mutex to guard eeti_ts_read() against parallel invocations
    from different contexts.
    
    Signed-off-by: Daniel Mack <daniel@zonque.org>
    Reported-by: Sven Neumann <Sven.Neumann@teufel.de>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index 7fe41965c5d1..b508d2693c0e 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -41,6 +41,7 @@ struct eeti_ts {
 	struct input_dev *input;
 	struct gpio_desc *attn_gpio;
 	struct touchscreen_properties props;
+	struct mutex mutex;
 	bool running;
 };
 
@@ -75,42 +76,80 @@ static void eeti_ts_report_event(struct eeti_ts *eeti, u8 *buf)
 	input_sync(eeti->input);
 }
 
+static int eeti_ts_read(struct eeti_ts *eeti)
+{
+	int len, error;
+	char buf[6];
+
+	len = i2c_master_recv(eeti->client, buf, sizeof(buf));
+	if (len != sizeof(buf)) {
+		error = len < 0 ? len : -EIO;
+		dev_err(&eeti->client->dev,
+			"failed to read touchscreen data: %d\n",
+			error);
+		return error;
+	}
+
+	/* Motion packet */
+	if (buf[0] & 0x80)
+		eeti_ts_report_event(eeti, buf);
+
+	return 0;
+}
+
 static irqreturn_t eeti_ts_isr(int irq, void *dev_id)
 {
 	struct eeti_ts *eeti = dev_id;
-	int len;
 	int error;
-	char buf[6];
+
+	mutex_lock(&eeti->mutex);
 
 	do {
-		len = i2c_master_recv(eeti->client, buf, sizeof(buf));
-		if (len != sizeof(buf)) {
-			error = len < 0 ? len : -EIO;
-			dev_err(&eeti->client->dev,
-				"failed to read touchscreen data: %d\n",
-				error);
+		/*
+		 * If we have attention GPIO, trust it. Otherwise we'll read
+		 * once and exit. We assume that in this case we are using
+		 * level triggered interrupt and it will get raised again
+		 * if/when there is more data.
+		 */
+		if (eeti->attn_gpio &&
+		    !gpiod_get_value_cansleep(eeti->attn_gpio)) {
 			break;
 		}
 
-		if (buf[0] & 0x80) {
-			/* Motion packet */
-			eeti_ts_report_event(eeti, buf);
-		}
-	} while (eeti->running &&
-		 eeti->attn_gpio && gpiod_get_value_cansleep(eeti->attn_gpio));
+		error = eeti_ts_read(eeti);
+		if (error)
+			break;
+
+	} while (eeti->running && eeti->attn_gpio);
 
+	mutex_unlock(&eeti->mutex);
 	return IRQ_HANDLED;
 }
 
 static void eeti_ts_start(struct eeti_ts *eeti)
 {
+	mutex_lock(&eeti->mutex);
+
 	eeti->running = true;
-	wmb();
 	enable_irq(eeti->client->irq);
+
+	/*
+	 * Kick the controller in case we are using edge interrupt and
+	 * we missed our edge while interrupt was disabled. We expect
+	 * the attention GPIO to be wired in this case.
+	 */
+	if (eeti->attn_gpio && gpiod_get_value_cansleep(eeti->attn_gpio))
+		eeti_ts_read(eeti);
+
+	mutex_unlock(&eeti->mutex);
 }
 
 static void eeti_ts_stop(struct eeti_ts *eeti)
 {
+	/*
+	 * Not locking here, just setting a flag and expect that the
+	 * interrupt thread will notice the flag eventually.
+	 */
 	eeti->running = false;
 	wmb();
 	disable_irq(eeti->client->irq);
@@ -153,6 +192,8 @@ static int eeti_ts_probe(struct i2c_client *client,
 		return -ENOMEM;
 	}
 
+	mutex_init(&eeti->mutex);
+
 	input = devm_input_allocate_device(dev);
 	if (!input) {
 		dev_err(dev, "Failed to allocate input device.\n");

commit fd8135b6f80a4d2ea2e398fb33e38ec255037111
Author: Daniel Mack <daniel@zonque.org>
Date:   Wed Jul 4 15:46:55 2018 +0000

    Input: eeti - fix link to documentation and email address in header
    
    Keep the documentation link up-to-date in case anybody need to dive into it
    again, and update email address while at it.
    
    Signed-off-by: Daniel Mack <daniel@zonque.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index 84561dfde7c4..7fe41965c5d1 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -1,9 +1,9 @@
 /*
  * Touch Screen driver for EETI's I2C connected touch screen panels
- *   Copyright (c) 2009 Daniel Mack <daniel@caiaq.de>
+ *   Copyright (c) 2009,2018 Daniel Mack <daniel@zonque.org>
  *
  * See EETI's software guide for the protocol specification:
- *   http://home.eeti.com.tw/web20/eg/guide.htm
+ *   http://home.eeti.com.tw/documentation.html
  *
  * Based on migor_ts.c
  *   Copyright (c) 2008 Magnus Damm
@@ -271,5 +271,5 @@ static struct i2c_driver eeti_ts_driver = {
 module_i2c_driver(eeti_ts_driver);
 
 MODULE_DESCRIPTION("EETI Touchscreen driver");
-MODULE_AUTHOR("Daniel Mack <daniel@caiaq.de>");
+MODULE_AUTHOR("Daniel Mack <daniel@zonque.org>");
 MODULE_LICENSE("GPL");

commit a114cbd00afe7afa3a6403fb025632ba6b47b443
Author: Daniel Mack <daniel@zonque.org>
Date:   Wed Jul 4 15:46:22 2018 +0000

    Input: eeti - drop module parameters, parse DT properties
    
    The only user of this driver in mainline does not make use of the module
    parameters, so let's remove them. All properties for this driver should be
    set through DT or pdata.
    
    Use touchscreen_parse_properties() to automatically set some of the common
    touchscreen properties and derive the axis inversion through that.
    
    And finally, use touchscreen_report_pos() to handle the DT properties
    automatically instead of doing the inversion ourselves.
    
    Signed-off-by: Daniel Mack <daniel@zonque.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index cc4fd33f9d6d..84561dfde7c4 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -25,9 +25,9 @@
  */
 
 #include <linux/module.h>
-#include <linux/moduleparam.h>
 #include <linux/kernel.h>
 #include <linux/input.h>
+#include <linux/input/touchscreen.h>
 #include <linux/interrupt.h>
 #include <linux/i2c.h>
 #include <linux/timer.h>
@@ -36,18 +36,11 @@
 #include <linux/slab.h>
 #include <asm/unaligned.h>
 
-static bool flip_x;
-module_param(flip_x, bool, 0644);
-MODULE_PARM_DESC(flip_x, "flip x coordinate");
-
-static bool flip_y;
-module_param(flip_y, bool, 0644);
-MODULE_PARM_DESC(flip_y, "flip y coordinate");
-
 struct eeti_ts {
 	struct i2c_client *client;
 	struct input_dev *input;
 	struct gpio_desc *attn_gpio;
+	struct touchscreen_properties props;
 	bool running;
 };
 
@@ -74,17 +67,10 @@ static void eeti_ts_report_event(struct eeti_ts *eeti, u8 *buf)
 	x >>= res - EETI_TS_BITDEPTH;
 	y >>= res - EETI_TS_BITDEPTH;
 
-	if (flip_x)
-		x = EETI_MAXVAL - x;
-
-	if (flip_y)
-		y = EETI_MAXVAL - y;
-
 	if (buf[0] & REPORT_BIT_HAS_PRESSURE)
 		input_report_abs(eeti->input, ABS_PRESSURE, buf[5]);
 
-	input_report_abs(eeti->input, ABS_X, x);
-	input_report_abs(eeti->input, ABS_Y, y);
+	touchscreen_report_pos(eeti->input, &eeti->props, x, y, false);
 	input_report_key(eeti->input, BTN_TOUCH, buf[0] & REPORT_BIT_PRESSED);
 	input_sync(eeti->input);
 }
@@ -179,6 +165,8 @@ static int eeti_ts_probe(struct i2c_client *client,
 	input_set_abs_params(input, ABS_Y, 0, EETI_MAXVAL, 0, 0);
 	input_set_abs_params(input, ABS_PRESSURE, 0, 0xff, 0, 0);
 
+	touchscreen_parse_properties(input, false, &eeti->props);
+
 	input->name = client->name;
 	input->id.bustype = BUS_I2C;
 	input->open = eeti_ts_open;

commit e32d7f1b246c1aef7b2d4f9fe0ce8863ac21128c
Author: Daniel Mack <daniel@zonque.org>
Date:   Wed Jul 4 15:45:47 2018 +0000

    Input: eeti - add device tree matching table
    
    Provide a match table so that the driver can be used in devicetree setups.
    More properties are added in a later patch.
    
    Signed-off-by: Daniel Mack <daniel@zonque.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index 2facad75eb6d..cc4fd33f9d6d 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -32,6 +32,7 @@
 #include <linux/i2c.h>
 #include <linux/timer.h>
 #include <linux/gpio/consumer.h>
+#include <linux/of.h>
 #include <linux/slab.h>
 #include <asm/unaligned.h>
 
@@ -262,10 +263,18 @@ static const struct i2c_device_id eeti_ts_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, eeti_ts_id);
 
+#ifdef CONFIG_OF
+static const struct of_device_id of_eeti_ts_match[] = {
+	{ .compatible = "eeti,exc3000-i2c", },
+	{ }
+};
+#endif
+
 static struct i2c_driver eeti_ts_driver = {
 	.driver = {
 		.name = "eeti_ts",
 		.pm = &eeti_ts_pm,
+		.of_match_table = of_match_ptr(of_eeti_ts_match),
 	},
 	.probe = eeti_ts_probe,
 	.id_table = eeti_ts_id,

commit d99caa472c0a28dc95dd9b98c30ee46f9755181f
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Sun Feb 19 17:21:56 2017 -0800

    Input: eeti_ts - switch to gpiod API
    
    gpiod API allows standard way of specifying GPIO polarity and takes it into
    account when reading or setting GPIO state. It also allows us to switch to
    common way of obtaining GPIO descriptor and away form legacy platform data.
    
    Reviewed-by: Daniel Mack <daniel@zonque.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index 3627c7b5f5ec..2facad75eb6d 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -31,8 +31,7 @@
 #include <linux/interrupt.h>
 #include <linux/i2c.h>
 #include <linux/timer.h>
-#include <linux/gpio.h>
-#include <linux/input/eeti_ts.h>
+#include <linux/gpio/consumer.h>
 #include <linux/slab.h>
 #include <asm/unaligned.h>
 
@@ -47,7 +46,7 @@ MODULE_PARM_DESC(flip_y, "flip y coordinate");
 struct eeti_ts {
 	struct i2c_client *client;
 	struct input_dev *input;
-	int irq_gpio, irq_active_high;
+	struct gpio_desc *attn_gpio;
 	bool running;
 };
 
@@ -60,11 +59,6 @@ struct eeti_ts {
 #define REPORT_BIT_HAS_PRESSURE	BIT(6)
 #define REPORT_RES_BITS(v)	(((v) >> 1) + EETI_TS_BITDEPTH)
 
-static inline int eeti_ts_irq_active(struct eeti_ts *eeti)
-{
-	return gpio_get_value_cansleep(eeti->irq_gpio) == eeti->irq_active_high;
-}
-
 static void eeti_ts_report_event(struct eeti_ts *eeti, u8 *buf)
 {
 	unsigned int res;
@@ -115,7 +109,8 @@ static irqreturn_t eeti_ts_isr(int irq, void *dev_id)
 			/* Motion packet */
 			eeti_ts_report_event(eeti, buf);
 		}
-	} while (eeti->running && eeti_ts_irq_active(eeti));
+	} while (eeti->running &&
+		 eeti->attn_gpio && gpiod_get_value_cansleep(eeti->attn_gpio));
 
 	return IRQ_HANDLED;
 }
@@ -154,7 +149,6 @@ static int eeti_ts_probe(struct i2c_client *client,
 			 const struct i2c_device_id *idp)
 {
 	struct device *dev = &client->dev;
-	struct eeti_ts_platform_data *pdata = dev_get_platdata(dev);
 	struct eeti_ts *eeti;
 	struct input_dev *input;
 	int error;
@@ -191,14 +185,10 @@ static int eeti_ts_probe(struct i2c_client *client,
 
 	eeti->client = client;
 	eeti->input = input;
-	eeti->irq_gpio = pdata->irq_gpio;
-
-	error = devm_gpio_request_one(dev, pdata->irq_gpio, GPIOF_IN,
-				      client->name);
-	if (error)
-		return error;
 
-	eeti->irq_active_high = pdata->irq_active_high;
+	eeti->attn_gpio = devm_gpiod_get_optional(dev, "attn", GPIOD_IN);
+	if (IS_ERR(eeti->attn_gpio))
+		return PTR_ERR(eeti->attn_gpio);
 
 	i2c_set_clientdata(client, eeti);
 	input_set_drvdata(input, eeti);

commit d422be5f62ef7986d00afa4cd31eda5534ab7991
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Sun Feb 19 16:22:13 2017 -0800

    Input: eeti_ts - expect platform code to set interrupt trigger
    
    Instead of keying interrupt trigger off GPIO polarity, let's rely on
    platform code to set it up properly for us.
    
    Reviewed-by: Daniel Mack <daniel@zonque.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index ee6b87c606ef..3627c7b5f5ec 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -157,7 +157,6 @@ static int eeti_ts_probe(struct i2c_client *client,
 	struct eeti_ts_platform_data *pdata = dev_get_platdata(dev);
 	struct eeti_ts *eeti;
 	struct input_dev *input;
-	unsigned int irq_flags;
 	int error;
 
 	/*
@@ -201,15 +200,12 @@ static int eeti_ts_probe(struct i2c_client *client,
 
 	eeti->irq_active_high = pdata->irq_active_high;
 
-	irq_flags = eeti->irq_active_high ?
-		IRQF_TRIGGER_HIGH : IRQF_TRIGGER_LOW;
-
 	i2c_set_clientdata(client, eeti);
 	input_set_drvdata(input, eeti);
 
 	error = devm_request_threaded_irq(dev, client->irq,
 					  NULL, eeti_ts_isr,
-					  irq_flags | IRQF_ONESHOT,
+					  IRQF_ONESHOT,
 					  client->name, eeti);
 	if (error) {
 		dev_err(dev, "Unable to request touchscreen IRQ: %d\n",

commit 0378008a99243fc492e7f0c3aabfeee69a78398c
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Sun Feb 19 17:23:47 2017 -0800

    Input: eeti_ts - switch to using threaded interrupt
    
    Instead of having standard interrupt handler and manually firing work item
    to perform I2C reads, let's switch to threaded interrupts, which were
    designed specifically for this purpose.
    
    Reviewed-by: Daniel Mack <daniel@zonque.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index fc61dbea4736..ee6b87c606ef 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -47,9 +47,8 @@ MODULE_PARM_DESC(flip_y, "flip y coordinate");
 struct eeti_ts {
 	struct i2c_client *client;
 	struct input_dev *input;
-	struct work_struct work;
-	struct mutex mutex;
 	int irq_gpio, irq_active_high;
+	bool running;
 };
 
 #define EETI_TS_BITDEPTH	(11)
@@ -66,29 +65,11 @@ static inline int eeti_ts_irq_active(struct eeti_ts *eeti)
 	return gpio_get_value_cansleep(eeti->irq_gpio) == eeti->irq_active_high;
 }
 
-static void eeti_ts_read(struct work_struct *work)
+static void eeti_ts_report_event(struct eeti_ts *eeti, u8 *buf)
 {
-	char buf[6];
-	unsigned int x, y, res, pressed, to = 100;
-	struct eeti_ts *eeti =
-		container_of(work, struct eeti_ts, work);
-
-	mutex_lock(&eeti->mutex);
-
-	while (eeti_ts_irq_active(eeti) && --to)
-		i2c_master_recv(eeti->client, buf, sizeof(buf));
-
-	if (!to) {
-		dev_err(&eeti->client->dev,
-			"unable to clear IRQ - line stuck?\n");
-		goto out;
-	}
+	unsigned int res;
+	u16 x, y;
 
-	/* drop non-report packets */
-	if (!(buf[0] & 0x80))
-		goto out;
-
-	pressed = buf[0] & REPORT_BIT_PRESSED;
 	res = REPORT_RES_BITS(buf[0] & (REPORT_BIT_AD0 | REPORT_BIT_AD1));
 
 	x = get_unaligned_be16(&buf[1]);
@@ -109,35 +90,48 @@ static void eeti_ts_read(struct work_struct *work)
 
 	input_report_abs(eeti->input, ABS_X, x);
 	input_report_abs(eeti->input, ABS_Y, y);
-	input_report_key(eeti->input, BTN_TOUCH, !!pressed);
+	input_report_key(eeti->input, BTN_TOUCH, buf[0] & REPORT_BIT_PRESSED);
 	input_sync(eeti->input);
-
-out:
-	mutex_unlock(&eeti->mutex);
 }
 
 static irqreturn_t eeti_ts_isr(int irq, void *dev_id)
 {
 	struct eeti_ts *eeti = dev_id;
+	int len;
+	int error;
+	char buf[6];
 
-	 /* postpone I2C transactions as we are atomic */
-	schedule_work(&eeti->work);
+	do {
+		len = i2c_master_recv(eeti->client, buf, sizeof(buf));
+		if (len != sizeof(buf)) {
+			error = len < 0 ? len : -EIO;
+			dev_err(&eeti->client->dev,
+				"failed to read touchscreen data: %d\n",
+				error);
+			break;
+		}
+
+		if (buf[0] & 0x80) {
+			/* Motion packet */
+			eeti_ts_report_event(eeti, buf);
+		}
+	} while (eeti->running && eeti_ts_irq_active(eeti));
 
 	return IRQ_HANDLED;
 }
 
 static void eeti_ts_start(struct eeti_ts *eeti)
 {
+	eeti->running = true;
+	wmb();
 	enable_irq(eeti->client->irq);
-
-	/* Read the events once to arm the IRQ */
-	eeti_ts_read(&eeti->work);
 }
 
 static void eeti_ts_stop(struct eeti_ts *eeti)
 {
+	eeti->running = false;
+	wmb();
 	disable_irq(eeti->client->irq);
-	cancel_work_sync(&eeti->work);
 }
 
 static int eeti_ts_open(struct input_dev *dev)
@@ -179,8 +173,6 @@ static int eeti_ts_probe(struct i2c_client *client,
 		return -ENOMEM;
 	}
 
-	mutex_init(&eeti->mutex);
-
 	input = devm_input_allocate_device(dev);
 	if (!input) {
 		dev_err(dev, "Failed to allocate input device.\n");
@@ -210,18 +202,15 @@ static int eeti_ts_probe(struct i2c_client *client,
 	eeti->irq_active_high = pdata->irq_active_high;
 
 	irq_flags = eeti->irq_active_high ?
-		IRQF_TRIGGER_RISING : IRQF_TRIGGER_FALLING;
+		IRQF_TRIGGER_HIGH : IRQF_TRIGGER_LOW;
 
-	INIT_WORK(&eeti->work, eeti_ts_read);
 	i2c_set_clientdata(client, eeti);
 	input_set_drvdata(input, eeti);
 
-	error = input_register_device(input);
-	if (error)
-		return error;
-
-	error = devm_request_irq(dev, client->irq, eeti_ts_isr, irq_flags,
-				 client->name, eeti);
+	error = devm_request_threaded_irq(dev, client->irq,
+					  NULL, eeti_ts_isr,
+					  irq_flags | IRQF_ONESHOT,
+					  client->name, eeti);
 	if (error) {
 		dev_err(dev, "Unable to request touchscreen IRQ: %d\n",
 			error);
@@ -234,6 +223,10 @@ static int eeti_ts_probe(struct i2c_client *client,
 	 */
 	eeti_ts_stop(eeti);
 
+	error = input_register_device(input);
+	if (error)
+		return error;
+
 	return 0;
 }
 

commit 173e4d81f76c948acbb49f3900f3ca3f279c5c2a
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Mon Feb 20 23:13:45 2017 -0800

    Input: eeti_ts - use gpio_get_value_cansleep
    
    We are reading GPIO state in a non-atomic context (workqueue), so we can
    use "cansleep" variant, and thus make the driver available on systems where
    GPIO controllers require sleeping when reading GPIO state.
    
    Reviewed-by: Daniel Mack <daniel@zonque.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index ac78ac6d4936..fc61dbea4736 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -63,7 +63,7 @@ struct eeti_ts {
 
 static inline int eeti_ts_irq_active(struct eeti_ts *eeti)
 {
-	return gpio_get_value(eeti->irq_gpio) == eeti->irq_active_high;
+	return gpio_get_value_cansleep(eeti->irq_gpio) == eeti->irq_active_high;
 }
 
 static void eeti_ts_read(struct work_struct *work)

commit 2d3884998945cf3f995e9c2e0f157b59f4ec3e86
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Sun Feb 19 17:14:33 2017 -0800

    Input: eeti_ts - respect interrupt set in client structure
    
    Instead of expecting that GPIO is always interrupt source, let's use
    interrupt specified in I2C client.
    
    Reviewed-by: Daniel Mack <daniel@zonque.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index e99e4fec93f5..ac78ac6d4936 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -49,7 +49,7 @@ struct eeti_ts {
 	struct input_dev *input;
 	struct work_struct work;
 	struct mutex mutex;
-	int irq_gpio, irq, irq_active_high;
+	int irq_gpio, irq_active_high;
 };
 
 #define EETI_TS_BITDEPTH	(11)
@@ -128,7 +128,7 @@ static irqreturn_t eeti_ts_isr(int irq, void *dev_id)
 
 static void eeti_ts_start(struct eeti_ts *eeti)
 {
-	enable_irq(eeti->irq);
+	enable_irq(eeti->client->irq);
 
 	/* Read the events once to arm the IRQ */
 	eeti_ts_read(&eeti->work);
@@ -136,7 +136,7 @@ static void eeti_ts_start(struct eeti_ts *eeti)
 
 static void eeti_ts_stop(struct eeti_ts *eeti)
 {
-	disable_irq(eeti->irq);
+	disable_irq(eeti->client->irq);
 	cancel_work_sync(&eeti->work);
 }
 
@@ -201,7 +201,6 @@ static int eeti_ts_probe(struct i2c_client *client,
 	eeti->client = client;
 	eeti->input = input;
 	eeti->irq_gpio = pdata->irq_gpio;
-	eeti->irq = gpio_to_irq(pdata->irq_gpio);
 
 	error = devm_gpio_request_one(dev, pdata->irq_gpio, GPIOF_IN,
 				      client->name);
@@ -221,7 +220,7 @@ static int eeti_ts_probe(struct i2c_client *client,
 	if (error)
 		return error;
 
-	error = devm_request_irq(dev, eeti->irq, eeti_ts_isr, irq_flags,
+	error = devm_request_irq(dev, client->irq, eeti_ts_isr, irq_flags,
 				 client->name, eeti);
 	if (error) {
 		dev_err(dev, "Unable to request touchscreen IRQ: %d\n",
@@ -252,7 +251,7 @@ static int __maybe_unused eeti_ts_suspend(struct device *dev)
 	mutex_unlock(&input_dev->mutex);
 
 	if (device_may_wakeup(&client->dev))
-		enable_irq_wake(eeti->irq);
+		enable_irq_wake(client->irq);
 
 	return 0;
 }
@@ -264,7 +263,7 @@ static int __maybe_unused eeti_ts_resume(struct device *dev)
 	struct input_dev *input_dev = eeti->input;
 
 	if (device_may_wakeup(&client->dev))
-		disable_irq_wake(eeti->irq);
+		disable_irq_wake(client->irq);
 
 	mutex_lock(&input_dev->mutex);
 

commit 6f9fab69a21d47ac68e78a8a5c613a2a6156bbb7
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Feb 17 15:54:22 2017 -0800

    Input: eeti_ts - switch to using managed resources
    
    Using devm_* APIs simpifies error handling and device teardown.
    
    Reviewed-by: Daniel Mack <daniel@zonque.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index b472e0e467e8..e99e4fec93f5 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -157,13 +157,14 @@ static void eeti_ts_close(struct input_dev *dev)
 }
 
 static int eeti_ts_probe(struct i2c_client *client,
-				   const struct i2c_device_id *idp)
+			 const struct i2c_device_id *idp)
 {
-	struct eeti_ts_platform_data *pdata = dev_get_platdata(&client->dev);
+	struct device *dev = &client->dev;
+	struct eeti_ts_platform_data *pdata = dev_get_platdata(dev);
 	struct eeti_ts *eeti;
 	struct input_dev *input;
 	unsigned int irq_flags;
-	int err = -ENOMEM;
+	int error;
 
 	/*
 	 * In contrast to what's described in the datasheet, there seems
@@ -172,18 +173,18 @@ static int eeti_ts_probe(struct i2c_client *client,
 	 * for interrupts to occur.
 	 */
 
-	eeti = kzalloc(sizeof(*eeti), GFP_KERNEL);
+	eeti = devm_kzalloc(dev, sizeof(*eeti), GFP_KERNEL);
 	if (!eeti) {
-		dev_err(&client->dev, "failed to allocate driver data\n");
+		dev_err(dev, "failed to allocate driver data\n");
 		return -ENOMEM;
 	}
 
 	mutex_init(&eeti->mutex);
 
-	input = input_allocate_device();
+	input = devm_input_allocate_device(dev);
 	if (!input) {
-		dev_err(&client->dev, "Failed to allocate input device.\n");
-		goto err1;
+		dev_err(dev, "Failed to allocate input device.\n");
+		return -ENOMEM;
 	}
 
 	input_set_capability(input, EV_KEY, BTN_TOUCH);
@@ -194,7 +195,6 @@ static int eeti_ts_probe(struct i2c_client *client,
 
 	input->name = client->name;
 	input->id.bustype = BUS_I2C;
-	input->dev.parent = &client->dev;
 	input->open = eeti_ts_open;
 	input->close = eeti_ts_close;
 
@@ -203,9 +203,10 @@ static int eeti_ts_probe(struct i2c_client *client,
 	eeti->irq_gpio = pdata->irq_gpio;
 	eeti->irq = gpio_to_irq(pdata->irq_gpio);
 
-	err = gpio_request_one(pdata->irq_gpio, GPIOF_IN, client->name);
-	if (err < 0)
-		goto err1;
+	error = devm_gpio_request_one(dev, pdata->irq_gpio, GPIOF_IN,
+				      client->name);
+	if (error)
+		return error;
 
 	eeti->irq_active_high = pdata->irq_active_high;
 
@@ -216,15 +217,16 @@ static int eeti_ts_probe(struct i2c_client *client,
 	i2c_set_clientdata(client, eeti);
 	input_set_drvdata(input, eeti);
 
-	err = input_register_device(input);
-	if (err)
-		goto err2;
+	error = input_register_device(input);
+	if (error)
+		return error;
 
-	err = request_irq(eeti->irq, eeti_ts_isr, irq_flags,
-			  client->name, eeti);
-	if (err) {
-		dev_err(&client->dev, "Unable to request touchscreen IRQ.\n");
-		goto err3;
+	error = devm_request_irq(dev, eeti->irq, eeti_ts_isr, irq_flags,
+				 client->name, eeti);
+	if (error) {
+		dev_err(dev, "Unable to request touchscreen IRQ: %d\n",
+			error);
+		return error;
 	}
 
 	/*
@@ -233,33 +235,6 @@ static int eeti_ts_probe(struct i2c_client *client,
 	 */
 	eeti_ts_stop(eeti);
 
-	return 0;
-
-err3:
-	input_unregister_device(input);
-	input = NULL; /* so we dont try to free it below */
-err2:
-	gpio_free(pdata->irq_gpio);
-err1:
-	input_free_device(input);
-	kfree(eeti);
-	return err;
-}
-
-static int eeti_ts_remove(struct i2c_client *client)
-{
-	struct eeti_ts *eeti = i2c_get_clientdata(client);
-
-	free_irq(eeti->irq, eeti);
-	/*
-	 * eeti_ts_stop() leaves IRQ disabled. We need to re-enable it
-	 * so that device still works if we reload the driver.
-	 */
-	enable_irq(eeti->irq);
-
-	input_unregister_device(eeti->input);
-	kfree(eeti);
-
 	return 0;
 }
 
@@ -315,7 +290,6 @@ static struct i2c_driver eeti_ts_driver = {
 		.pm = &eeti_ts_pm,
 	},
 	.probe = eeti_ts_probe,
-	.remove = eeti_ts_remove,
 	.id_table = eeti_ts_id,
 };
 

commit 42e02a6a0db5499d036ff05710fe7370f9a8683a
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Mon Feb 20 21:53:51 2017 -0800

    Input: eeti_ts - use input_set_capability()
    
    Use input_set_capability() instead of manipulating evbit/keybit
    masks directly.
    
    Reviewed-by: Daniel Mack <daniel@zonque.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index 0e4b19236d68..b472e0e467e8 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -186,8 +186,7 @@ static int eeti_ts_probe(struct i2c_client *client,
 		goto err1;
 	}
 
-	input->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
-	input->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+	input_set_capability(input, EV_KEY, BTN_TOUCH);
 
 	input_set_abs_params(input, ABS_X, 0, EETI_MAXVAL, 0, 0);
 	input_set_abs_params(input, ABS_Y, 0, EETI_MAXVAL, 0, 0);

commit e9f66cdb7d5b9c05a76dde4ca5f217ba4af7f333
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Mon Feb 20 21:50:13 2017 -0800

    Input: eeti_ts - use get_unaligned_be16() to retrieve data
    
    Instead of manually converting big endian data on wire into host
    endianness, let's use helpers to do that for us. It might save us
    a few cycles if host endianness matches what's on wire.
    
    Reviewed-by: Daniel Mack <daniel@zonque.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index 26b52496748a..0e4b19236d68 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -34,6 +34,7 @@
 #include <linux/gpio.h>
 #include <linux/input/eeti_ts.h>
 #include <linux/slab.h>
+#include <asm/unaligned.h>
 
 static bool flip_x;
 module_param(flip_x, bool, 0644);
@@ -89,8 +90,9 @@ static void eeti_ts_read(struct work_struct *work)
 
 	pressed = buf[0] & REPORT_BIT_PRESSED;
 	res = REPORT_RES_BITS(buf[0] & (REPORT_BIT_AD0 | REPORT_BIT_AD1));
-	x = buf[2] | (buf[1] << 8);
-	y = buf[4] | (buf[3] << 8);
+
+	x = get_unaligned_be16(&buf[1]);
+	y = get_unaligned_be16(&buf[3]);
 
 	/* fix the range to 11 bits */
 	x >>= res - EETI_TS_BITDEPTH;

commit 272c03bb19018a03e50be44b30b4c7485918b8a2
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Mon Feb 20 21:42:43 2017 -0800

    Input: eeti_ts - use BIT(n)
    
    Use idiomatic BIT(n) to form single-bit masks.
    
    Reviewed-by: Daniel Mack <daniel@zonque.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index 74d57ef68663..26b52496748a 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -54,10 +54,10 @@ struct eeti_ts {
 #define EETI_TS_BITDEPTH	(11)
 #define EETI_MAXVAL		((1 << (EETI_TS_BITDEPTH + 1)) - 1)
 
-#define REPORT_BIT_PRESSED	(1 << 0)
-#define REPORT_BIT_AD0		(1 << 1)
-#define REPORT_BIT_AD1		(1 << 2)
-#define REPORT_BIT_HAS_PRESSURE	(1 << 6)
+#define REPORT_BIT_PRESSED	BIT(0)
+#define REPORT_BIT_AD0		BIT(1)
+#define REPORT_BIT_AD1		BIT(2)
+#define REPORT_BIT_HAS_PRESSURE	BIT(6)
 #define REPORT_RES_BITS(v)	(((v) >> 1) + EETI_TS_BITDEPTH)
 
 static inline int eeti_ts_irq_active(struct eeti_ts *eeti)

commit 720bebdff23ed1a9866e737ccdadbf995f6cac7a
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Sun Feb 19 17:28:11 2017 -0800

    Input: eeti_ts - rename eeti_ts_priv to eeti_ts
    
    Also rename 'priv' variables to eeti.
    
    Reviewed-by: Daniel Mack <daniel@zonque.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index 16023867b9da..74d57ef68663 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -43,7 +43,7 @@ static bool flip_y;
 module_param(flip_y, bool, 0644);
 MODULE_PARM_DESC(flip_y, "flip y coordinate");
 
-struct eeti_ts_priv {
+struct eeti_ts {
 	struct i2c_client *client;
 	struct input_dev *input;
 	struct work_struct work;
@@ -60,25 +60,25 @@ struct eeti_ts_priv {
 #define REPORT_BIT_HAS_PRESSURE	(1 << 6)
 #define REPORT_RES_BITS(v)	(((v) >> 1) + EETI_TS_BITDEPTH)
 
-static inline int eeti_ts_irq_active(struct eeti_ts_priv *priv)
+static inline int eeti_ts_irq_active(struct eeti_ts *eeti)
 {
-	return gpio_get_value(priv->irq_gpio) == priv->irq_active_high;
+	return gpio_get_value(eeti->irq_gpio) == eeti->irq_active_high;
 }
 
 static void eeti_ts_read(struct work_struct *work)
 {
 	char buf[6];
 	unsigned int x, y, res, pressed, to = 100;
-	struct eeti_ts_priv *priv =
-		container_of(work, struct eeti_ts_priv, work);
+	struct eeti_ts *eeti =
+		container_of(work, struct eeti_ts, work);
 
-	mutex_lock(&priv->mutex);
+	mutex_lock(&eeti->mutex);
 
-	while (eeti_ts_irq_active(priv) && --to)
-		i2c_master_recv(priv->client, buf, sizeof(buf));
+	while (eeti_ts_irq_active(eeti) && --to)
+		i2c_master_recv(eeti->client, buf, sizeof(buf));
 
 	if (!to) {
-		dev_err(&priv->client->dev,
+		dev_err(&eeti->client->dev,
 			"unable to clear IRQ - line stuck?\n");
 		goto out;
 	}
@@ -103,62 +103,62 @@ static void eeti_ts_read(struct work_struct *work)
 		y = EETI_MAXVAL - y;
 
 	if (buf[0] & REPORT_BIT_HAS_PRESSURE)
-		input_report_abs(priv->input, ABS_PRESSURE, buf[5]);
+		input_report_abs(eeti->input, ABS_PRESSURE, buf[5]);
 
-	input_report_abs(priv->input, ABS_X, x);
-	input_report_abs(priv->input, ABS_Y, y);
-	input_report_key(priv->input, BTN_TOUCH, !!pressed);
-	input_sync(priv->input);
+	input_report_abs(eeti->input, ABS_X, x);
+	input_report_abs(eeti->input, ABS_Y, y);
+	input_report_key(eeti->input, BTN_TOUCH, !!pressed);
+	input_sync(eeti->input);
 
 out:
-	mutex_unlock(&priv->mutex);
+	mutex_unlock(&eeti->mutex);
 }
 
 static irqreturn_t eeti_ts_isr(int irq, void *dev_id)
 {
-	struct eeti_ts_priv *priv = dev_id;
+	struct eeti_ts *eeti = dev_id;
 
 	 /* postpone I2C transactions as we are atomic */
-	schedule_work(&priv->work);
+	schedule_work(&eeti->work);
 
 	return IRQ_HANDLED;
 }
 
-static void eeti_ts_start(struct eeti_ts_priv *priv)
+static void eeti_ts_start(struct eeti_ts *eeti)
 {
-	enable_irq(priv->irq);
+	enable_irq(eeti->irq);
 
 	/* Read the events once to arm the IRQ */
-	eeti_ts_read(&priv->work);
+	eeti_ts_read(&eeti->work);
 }
 
-static void eeti_ts_stop(struct eeti_ts_priv *priv)
+static void eeti_ts_stop(struct eeti_ts *eeti)
 {
-	disable_irq(priv->irq);
-	cancel_work_sync(&priv->work);
+	disable_irq(eeti->irq);
+	cancel_work_sync(&eeti->work);
 }
 
 static int eeti_ts_open(struct input_dev *dev)
 {
-	struct eeti_ts_priv *priv = input_get_drvdata(dev);
+	struct eeti_ts *eeti = input_get_drvdata(dev);
 
-	eeti_ts_start(priv);
+	eeti_ts_start(eeti);
 
 	return 0;
 }
 
 static void eeti_ts_close(struct input_dev *dev)
 {
-	struct eeti_ts_priv *priv = input_get_drvdata(dev);
+	struct eeti_ts *eeti = input_get_drvdata(dev);
 
-	eeti_ts_stop(priv);
+	eeti_ts_stop(eeti);
 }
 
 static int eeti_ts_probe(struct i2c_client *client,
 				   const struct i2c_device_id *idp)
 {
 	struct eeti_ts_platform_data *pdata = dev_get_platdata(&client->dev);
-	struct eeti_ts_priv *priv;
+	struct eeti_ts *eeti;
 	struct input_dev *input;
 	unsigned int irq_flags;
 	int err = -ENOMEM;
@@ -170,13 +170,14 @@ static int eeti_ts_probe(struct i2c_client *client,
 	 * for interrupts to occur.
 	 */
 
-	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
-	if (!priv) {
+	eeti = kzalloc(sizeof(*eeti), GFP_KERNEL);
+	if (!eeti) {
 		dev_err(&client->dev, "failed to allocate driver data\n");
 		return -ENOMEM;
 	}
 
-	mutex_init(&priv->mutex);
+	mutex_init(&eeti->mutex);
+
 	input = input_allocate_device();
 	if (!input) {
 		dev_err(&client->dev, "Failed to allocate input device.\n");
@@ -196,30 +197,30 @@ static int eeti_ts_probe(struct i2c_client *client,
 	input->open = eeti_ts_open;
 	input->close = eeti_ts_close;
 
-	priv->client = client;
-	priv->input = input;
-	priv->irq_gpio = pdata->irq_gpio;
-	priv->irq = gpio_to_irq(pdata->irq_gpio);
+	eeti->client = client;
+	eeti->input = input;
+	eeti->irq_gpio = pdata->irq_gpio;
+	eeti->irq = gpio_to_irq(pdata->irq_gpio);
 
 	err = gpio_request_one(pdata->irq_gpio, GPIOF_IN, client->name);
 	if (err < 0)
 		goto err1;
 
-	priv->irq_active_high = pdata->irq_active_high;
+	eeti->irq_active_high = pdata->irq_active_high;
 
-	irq_flags = priv->irq_active_high ?
+	irq_flags = eeti->irq_active_high ?
 		IRQF_TRIGGER_RISING : IRQF_TRIGGER_FALLING;
 
-	INIT_WORK(&priv->work, eeti_ts_read);
-	i2c_set_clientdata(client, priv);
-	input_set_drvdata(input, priv);
+	INIT_WORK(&eeti->work, eeti_ts_read);
+	i2c_set_clientdata(client, eeti);
+	input_set_drvdata(input, eeti);
 
 	err = input_register_device(input);
 	if (err)
 		goto err2;
 
-	err = request_irq(priv->irq, eeti_ts_isr, irq_flags,
-			  client->name, priv);
+	err = request_irq(eeti->irq, eeti_ts_isr, irq_flags,
+			  client->name, eeti);
 	if (err) {
 		dev_err(&client->dev, "Unable to request touchscreen IRQ.\n");
 		goto err3;
@@ -229,7 +230,7 @@ static int eeti_ts_probe(struct i2c_client *client,
 	 * Disable the device for now. It will be enabled once the
 	 * input device is opened.
 	 */
-	eeti_ts_stop(priv);
+	eeti_ts_stop(eeti);
 
 	return 0;
 
@@ -240,23 +241,23 @@ static int eeti_ts_probe(struct i2c_client *client,
 	gpio_free(pdata->irq_gpio);
 err1:
 	input_free_device(input);
-	kfree(priv);
+	kfree(eeti);
 	return err;
 }
 
 static int eeti_ts_remove(struct i2c_client *client)
 {
-	struct eeti_ts_priv *priv = i2c_get_clientdata(client);
+	struct eeti_ts *eeti = i2c_get_clientdata(client);
 
-	free_irq(priv->irq, priv);
+	free_irq(eeti->irq, eeti);
 	/*
 	 * eeti_ts_stop() leaves IRQ disabled. We need to re-enable it
 	 * so that device still works if we reload the driver.
 	 */
-	enable_irq(priv->irq);
+	enable_irq(eeti->irq);
 
-	input_unregister_device(priv->input);
-	kfree(priv);
+	input_unregister_device(eeti->input);
+	kfree(eeti);
 
 	return 0;
 }
@@ -264,18 +265,18 @@ static int eeti_ts_remove(struct i2c_client *client)
 static int __maybe_unused eeti_ts_suspend(struct device *dev)
 {
 	struct i2c_client *client = to_i2c_client(dev);
-	struct eeti_ts_priv *priv = i2c_get_clientdata(client);
-	struct input_dev *input_dev = priv->input;
+	struct eeti_ts *eeti = i2c_get_clientdata(client);
+	struct input_dev *input_dev = eeti->input;
 
 	mutex_lock(&input_dev->mutex);
 
 	if (input_dev->users)
-		eeti_ts_stop(priv);
+		eeti_ts_stop(eeti);
 
 	mutex_unlock(&input_dev->mutex);
 
 	if (device_may_wakeup(&client->dev))
-		enable_irq_wake(priv->irq);
+		enable_irq_wake(eeti->irq);
 
 	return 0;
 }
@@ -283,16 +284,16 @@ static int __maybe_unused eeti_ts_suspend(struct device *dev)
 static int __maybe_unused eeti_ts_resume(struct device *dev)
 {
 	struct i2c_client *client = to_i2c_client(dev);
-	struct eeti_ts_priv *priv = i2c_get_clientdata(client);
-	struct input_dev *input_dev = priv->input;
+	struct eeti_ts *eeti = i2c_get_clientdata(client);
+	struct input_dev *input_dev = eeti->input;
 
 	if (device_may_wakeup(&client->dev))
-		disable_irq_wake(priv->irq);
+		disable_irq_wake(eeti->irq);
 
 	mutex_lock(&input_dev->mutex);
 
 	if (input_dev->users)
-		eeti_ts_start(priv);
+		eeti_ts_start(eeti);
 
 	mutex_unlock(&input_dev->mutex);
 

commit 8e1b4d83cf8b0e62f5a45792d07f027783c1a07c
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Sat Jan 21 23:49:13 2017 -0800

    Input: touchscreen - drop unnecessary calls to device_init_wakeup
    
    Calling device_init_wakeup in the remove function is unnecessary since the
    device is going away, and thus won't be able to cause any wakeups under any
    circumstances. Besides, the driver cleanup code already handles the
    necessary cleanup.
    
    Similarly, disabling wakeup in the probe error path is unnecessary, as is
    disabling wakeup in the probe function in the first place.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index fa974579eb41..16023867b9da 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -231,7 +231,6 @@ static int eeti_ts_probe(struct i2c_client *client,
 	 */
 	eeti_ts_stop(priv);
 
-	device_init_wakeup(&client->dev, 0);
 	return 0;
 
 err3:

commit ad03ae44baeb82b28024c8c582e18146b96d637e
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Wed Jan 18 11:24:06 2017 -0800

    Input: eeti_ts - drop goto to return statement
    
    Replace 'goto l; ... l: return e;' with 'return e;'
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index 09be6ced7151..fa974579eb41 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -173,12 +173,11 @@ static int eeti_ts_probe(struct i2c_client *client,
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (!priv) {
 		dev_err(&client->dev, "failed to allocate driver data\n");
-		goto err0;
+		return -ENOMEM;
 	}
 
 	mutex_init(&priv->mutex);
 	input = input_allocate_device();
-
 	if (!input) {
 		dev_err(&client->dev, "Failed to allocate input device.\n");
 		goto err1;
@@ -243,7 +242,6 @@ static int eeti_ts_probe(struct i2c_client *client,
 err1:
 	input_free_device(input);
 	kfree(priv);
-err0:
 	return err;
 }
 

commit 02b6a58b83b2f3d97addaf96ef60ad6596bf715f
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Sun Nov 2 00:04:14 2014 -0700

    Input: touchscreen - use __maybe_unused instead of ifdef around suspend/resume
    
    Use __maybe_unused instead of ifdef guards around suspend/resume
    functions, in order to increase build coverage and fix build warnings.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index b1884ddd7a84..09be6ced7151 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -264,8 +264,7 @@ static int eeti_ts_remove(struct i2c_client *client)
 	return 0;
 }
 
-#ifdef CONFIG_PM_SLEEP
-static int eeti_ts_suspend(struct device *dev)
+static int __maybe_unused eeti_ts_suspend(struct device *dev)
 {
 	struct i2c_client *client = to_i2c_client(dev);
 	struct eeti_ts_priv *priv = i2c_get_clientdata(client);
@@ -284,7 +283,7 @@ static int eeti_ts_suspend(struct device *dev)
 	return 0;
 }
 
-static int eeti_ts_resume(struct device *dev)
+static int __maybe_unused eeti_ts_resume(struct device *dev)
 {
 	struct i2c_client *client = to_i2c_client(dev);
 	struct eeti_ts_priv *priv = i2c_get_clientdata(client);
@@ -302,7 +301,6 @@ static int eeti_ts_resume(struct device *dev)
 
 	return 0;
 }
-#endif
 
 static SIMPLE_DEV_PM_OPS(eeti_ts_pm, eeti_ts_suspend, eeti_ts_resume);
 

commit c838cb3d477f79738ee03ede53a3f724021f3ae0
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Thu Dec 5 19:21:10 2013 -0800

    Input: use dev_get_platdata()
    
    Use the wrapper function for retrieving the platform data instead
    of accessing dev->platform_data directly. This is a cosmetic change
    to make the code simpler and enhance the readability.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Acked-by: Fugang Duan <B38611@freescale.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index 1ce3d29ffca5..b1884ddd7a84 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -157,7 +157,7 @@ static void eeti_ts_close(struct input_dev *dev)
 static int eeti_ts_probe(struct i2c_client *client,
 				   const struct i2c_device_id *idp)
 {
-	struct eeti_ts_platform_data *pdata = client->dev.platform_data;
+	struct eeti_ts_platform_data *pdata = dev_get_platdata(&client->dev);
 	struct eeti_ts_priv *priv;
 	struct input_dev *input;
 	unsigned int irq_flags;

commit 54e9f4501079c837bbcc535c8de5a2e2fcbf6782
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Mon Aug 5 09:06:00 2013 -0700

    Input: eeti_ts - add CONFIG_PM_SLEEP to suspend/resume
    
    Add CONFIG_PM_SLEEP to suspend/resume functions to fix the build
    warnings when CONFIG_PM_SLEEP is not selected. This is because
    sleep PM callbacks defined by SET_SYSTEM_SLEEP_PM_OPS are only used
    when the CONFIG_PM_SLEEP is enabled.
    
    drivers/input/touchscreen/eeti_ts.c:268:12: warning: 'eeti_ts_suspend' defined but not used [-Wunused-function]
    drivers/input/touchscreen/eeti_ts.c:287:12: warning: 'eeti_ts_resume' defined but not used [-Wunused-function]
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index 8fe5086c8d2e..1ce3d29ffca5 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -264,7 +264,7 @@ static int eeti_ts_remove(struct i2c_client *client)
 	return 0;
 }
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 static int eeti_ts_suspend(struct device *dev)
 {
 	struct i2c_client *client = to_i2c_client(dev);
@@ -302,9 +302,9 @@ static int eeti_ts_resume(struct device *dev)
 
 	return 0;
 }
+#endif
 
 static SIMPLE_DEV_PM_OPS(eeti_ts_pm, eeti_ts_suspend, eeti_ts_resume);
-#endif
 
 static const struct i2c_device_id eeti_ts_id[] = {
 	{ "eeti_ts", 0 },
@@ -315,9 +315,7 @@ MODULE_DEVICE_TABLE(i2c, eeti_ts_id);
 static struct i2c_driver eeti_ts_driver = {
 	.driver = {
 		.name = "eeti_ts",
-#ifdef CONFIG_PM
 		.pm = &eeti_ts_pm,
-#endif
 	},
 	.probe = eeti_ts_probe,
 	.remove = eeti_ts_remove,

commit 80e3e5328a9978fae3654ead657e9df653508713
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Thu Mar 28 01:14:46 2013 -0700

    Input: eeti_ts - remove redundant null check
    
    'pdata' is already dereferenced earlier. Hence this check is
    meaningless.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index 55255a940072..8fe5086c8d2e 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -206,8 +206,7 @@ static int eeti_ts_probe(struct i2c_client *client,
 	if (err < 0)
 		goto err1;
 
-	if (pdata)
-		priv->irq_active_high = pdata->irq_active_high;
+	priv->irq_active_high = pdata->irq_active_high;
 
 	irq_flags = priv->irq_active_high ?
 		IRQF_TRIGGER_RISING : IRQF_TRIGGER_FALLING;

commit e2619cf78e19476bfd7ceaefa9eff0847529346e
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Nov 23 21:50:47 2012 -0800

    Input: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index a65709959fa0..55255a940072 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -248,7 +248,7 @@ static int eeti_ts_probe(struct i2c_client *client,
 	return err;
 }
 
-static int __devexit eeti_ts_remove(struct i2c_client *client)
+static int eeti_ts_remove(struct i2c_client *client)
 {
 	struct eeti_ts_priv *priv = i2c_get_clientdata(client);
 

commit 5298cc4cc753bbe4c530b41341834f6ef3344d0d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Nov 23 21:38:25 2012 -0800

    Input: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Javier Martinez Canillas <javier@dowhile0.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index a2d9a65e586d..a65709959fa0 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -154,7 +154,7 @@ static void eeti_ts_close(struct input_dev *dev)
 	eeti_ts_stop(priv);
 }
 
-static int __devinit eeti_ts_probe(struct i2c_client *client,
+static int eeti_ts_probe(struct i2c_client *client,
 				   const struct i2c_device_id *idp)
 {
 	struct eeti_ts_platform_data *pdata = client->dev.platform_data;

commit 1cb0aa88179b7a71c240529e9d781d7bbb43d2e8
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Nov 23 21:27:39 2012 -0800

    Input: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index 908407efc672..a2d9a65e586d 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -321,7 +321,7 @@ static struct i2c_driver eeti_ts_driver = {
 #endif
 	},
 	.probe = eeti_ts_probe,
-	.remove = __devexit_p(eeti_ts_remove),
+	.remove = eeti_ts_remove,
 	.id_table = eeti_ts_id,
 };
 

commit 4eef6cbfcc03b294d9d334368a851b35b496ce53
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Apr 30 16:21:37 2012 +0000

    Input: eeti_ts: pass gpio value instead of IRQ
    
    The EETI touchscreen asserts its IRQ line as soon as it has data in its
    internal buffers. The line is automatically deasserted once all data has
    been read via I2C. Hence, the driver has to monitor the GPIO line and
    cannot simply rely on the interrupt handler reception.
    
    In the current implementation of the driver, irq_to_gpio() is used to
    determine the GPIO number from the i2c_client's IRQ value.
    
    As irq_to_gpio() is not available on all platforms, this patch changes
    this and makes the driver ignore the passed in IRQ. Instead, a GPIO is
    added to the platform_data struct and gpio_to_irq is used to derive the
    IRQ from that GPIO. If this fails, bail out. The driver is only able to
    work in environments where the touchscreen GPIO can be mapped to an
    IRQ.
    
    Without this patch, building raumfeld_defconfig results in:
    
    drivers/input/touchscreen/eeti_ts.c: In function 'eeti_ts_irq_active':
    drivers/input/touchscreen/eeti_ts.c:65:2: error: implicit declaration of function 'irq_to_gpio' [-Werror=implicit-function-declaration]
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: stable@vger.kernel.org (v3.2+)
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Sven Neumann <s.neumann@raumfeld.com>
    Cc: linux-input@vger.kernel.org
    Cc: Haojian Zhuang <haojian.zhuang@gmail.com>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index 503c7096ed36..908407efc672 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -48,7 +48,7 @@ struct eeti_ts_priv {
 	struct input_dev *input;
 	struct work_struct work;
 	struct mutex mutex;
-	int irq, irq_active_high;
+	int irq_gpio, irq, irq_active_high;
 };
 
 #define EETI_TS_BITDEPTH	(11)
@@ -62,7 +62,7 @@ struct eeti_ts_priv {
 
 static inline int eeti_ts_irq_active(struct eeti_ts_priv *priv)
 {
-	return gpio_get_value(irq_to_gpio(priv->irq)) == priv->irq_active_high;
+	return gpio_get_value(priv->irq_gpio) == priv->irq_active_high;
 }
 
 static void eeti_ts_read(struct work_struct *work)
@@ -157,7 +157,7 @@ static void eeti_ts_close(struct input_dev *dev)
 static int __devinit eeti_ts_probe(struct i2c_client *client,
 				   const struct i2c_device_id *idp)
 {
-	struct eeti_ts_platform_data *pdata;
+	struct eeti_ts_platform_data *pdata = client->dev.platform_data;
 	struct eeti_ts_priv *priv;
 	struct input_dev *input;
 	unsigned int irq_flags;
@@ -199,9 +199,12 @@ static int __devinit eeti_ts_probe(struct i2c_client *client,
 
 	priv->client = client;
 	priv->input = input;
-	priv->irq = client->irq;
+	priv->irq_gpio = pdata->irq_gpio;
+	priv->irq = gpio_to_irq(pdata->irq_gpio);
 
-	pdata = client->dev.platform_data;
+	err = gpio_request_one(pdata->irq_gpio, GPIOF_IN, client->name);
+	if (err < 0)
+		goto err1;
 
 	if (pdata)
 		priv->irq_active_high = pdata->irq_active_high;
@@ -215,13 +218,13 @@ static int __devinit eeti_ts_probe(struct i2c_client *client,
 
 	err = input_register_device(input);
 	if (err)
-		goto err1;
+		goto err2;
 
 	err = request_irq(priv->irq, eeti_ts_isr, irq_flags,
 			  client->name, priv);
 	if (err) {
 		dev_err(&client->dev, "Unable to request touchscreen IRQ.\n");
-		goto err2;
+		goto err3;
 	}
 
 	/*
@@ -233,9 +236,11 @@ static int __devinit eeti_ts_probe(struct i2c_client *client,
 	device_init_wakeup(&client->dev, 0);
 	return 0;
 
-err2:
+err3:
 	input_unregister_device(input);
 	input = NULL; /* so we dont try to free it below */
+err2:
+	gpio_free(pdata->irq_gpio);
 err1:
 	input_free_device(input);
 	kfree(priv);

commit 1b92c1cf6b638e7cbe9fdaac3f6efb8874f5cc02
Author: Axel Lin <axel.lin@gmail.com>
Date:   Fri Mar 16 23:05:41 2012 -0700

    Input: convert I2C drivers to use module_i2c_driver()
    
    This patch converts the drivers in drivers/input/* to use the
    module_i2c_driver() macro which makes the code smaller and a bit
    simpler.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index 1df19bb8534a..503c7096ed36 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -320,20 +320,8 @@ static struct i2c_driver eeti_ts_driver = {
 	.id_table = eeti_ts_id,
 };
 
-static int __init eeti_ts_init(void)
-{
-	return i2c_add_driver(&eeti_ts_driver);
-}
-
-static void __exit eeti_ts_exit(void)
-{
-	i2c_del_driver(&eeti_ts_driver);
-}
+module_i2c_driver(eeti_ts_driver);
 
 MODULE_DESCRIPTION("EETI Touchscreen driver");
 MODULE_AUTHOR("Daniel Mack <daniel@caiaq.de>");
 MODULE_LICENSE("GPL");
-
-module_init(eeti_ts_init);
-module_exit(eeti_ts_exit);
-

commit 90ab5ee94171b3e28de6bb42ee30b527014e0be7
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Fri Jan 13 09:32:20 2012 +1030

    module_param: make bool parameters really bool (drivers & misc)
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index 7f8f538a9806..1df19bb8534a 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -35,11 +35,11 @@
 #include <linux/input/eeti_ts.h>
 #include <linux/slab.h>
 
-static int flip_x;
+static bool flip_x;
 module_param(flip_x, bool, 0644);
 MODULE_PARM_DESC(flip_x, "flip x coordinate");
 
-static int flip_y;
+static bool flip_y;
 module_param(flip_y, bool, 0644);
 MODULE_PARM_DESC(flip_y, "flip y coordinate");
 

commit 85012fff38302e0262f838431e853f8c09e754d5
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Jan 6 23:01:02 2011 -0800

    Input: eeti_ts - convert to dev_pm_ops
    
    There is a general move towards the use of dev_pm_ops rather than
    bus specific suspend APIs as this simplifies both the bus and PM core
    implementations. Convert the eeti_ts driver over.
    
    Compile tested only by me, but Sven Neumann reports that the new code
    works.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Tested-by: Sven Neumann <s.neumann@raumfeld.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index 7a3a916f84a8..7f8f538a9806 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -261,8 +261,9 @@ static int __devexit eeti_ts_remove(struct i2c_client *client)
 }
 
 #ifdef CONFIG_PM
-static int eeti_ts_suspend(struct i2c_client *client, pm_message_t mesg)
+static int eeti_ts_suspend(struct device *dev)
 {
+	struct i2c_client *client = to_i2c_client(dev);
 	struct eeti_ts_priv *priv = i2c_get_clientdata(client);
 	struct input_dev *input_dev = priv->input;
 
@@ -279,8 +280,9 @@ static int eeti_ts_suspend(struct i2c_client *client, pm_message_t mesg)
 	return 0;
 }
 
-static int eeti_ts_resume(struct i2c_client *client)
+static int eeti_ts_resume(struct device *dev)
 {
+	struct i2c_client *client = to_i2c_client(dev);
 	struct eeti_ts_priv *priv = i2c_get_clientdata(client);
 	struct input_dev *input_dev = priv->input;
 
@@ -296,9 +298,8 @@ static int eeti_ts_resume(struct i2c_client *client)
 
 	return 0;
 }
-#else
-#define eeti_ts_suspend NULL
-#define eeti_ts_resume NULL
+
+static SIMPLE_DEV_PM_OPS(eeti_ts_pm, eeti_ts_suspend, eeti_ts_resume);
 #endif
 
 static const struct i2c_device_id eeti_ts_id[] = {
@@ -310,11 +311,12 @@ MODULE_DEVICE_TABLE(i2c, eeti_ts_id);
 static struct i2c_driver eeti_ts_driver = {
 	.driver = {
 		.name = "eeti_ts",
+#ifdef CONFIG_PM
+		.pm = &eeti_ts_pm,
+#endif
 	},
 	.probe = eeti_ts_probe,
 	.remove = __devexit_p(eeti_ts_remove),
-	.suspend = eeti_ts_suspend,
-	.resume = eeti_ts_resume,
 	.id_table = eeti_ts_id,
 };
 

commit fbae3fb1546e199ab0cd185348f8124411a1ca9d
Author: Wolfram Sang <w.sang@pengutronix.de>
Date:   Thu Jun 3 11:33:58 2010 +0200

    i2c: Remove all i2c_set_clientdata(client, NULL) in drivers
    
    I2C drivers can use the clientdata-pointer to point to private data. As I2C
    devices are not really unregistered, but merely detached from their driver, it
    used to be the drivers obligation to clear this pointer during remove() or a
    failed probe(). As a couple of drivers forgot to do this, it was agreed that it
    was cleaner if the i2c-core does this clearance when appropriate, as there is
    no guarantee for the lifetime of the clientdata-pointer after remove() anyhow.
    This feature was added to the core with commit
    e4a7b9b04de15f6b63da5ccdd373ffa3057a3681 to fix the faulty drivers.
    
    As there is no need anymore to clear the clientdata-pointer, remove all current
    occurrences in the drivers to simplify the code and prevent confusion.
    
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: Richard Purdie <rpurdie@linux.intel.com>
    Acked-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Jean Delvare <khali@linux-fr.org>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index 75f8b73010fa..7a3a916f84a8 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -238,7 +238,6 @@ static int __devinit eeti_ts_probe(struct i2c_client *client,
 	input = NULL; /* so we dont try to free it below */
 err1:
 	input_free_device(input);
-	i2c_set_clientdata(client, NULL);
 	kfree(priv);
 err0:
 	return err;
@@ -256,7 +255,6 @@ static int __devexit eeti_ts_remove(struct i2c_client *client)
 	enable_irq(priv->irq);
 
 	input_unregister_device(priv->input);
-	i2c_set_clientdata(client, NULL);
 	kfree(priv);
 
 	return 0;

commit 1d7aec304147aadcbc66ef9ab691208f9f22b6a8
Merge: 5157b4aa5b7d 26a6931ba765
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 5 07:53:18 2010 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input:
      Input: joydev - allow binding to button-only devices
      Input: elantech - ignore high bits in the position coordinates
      Input: elantech - allow forcing Elantech protocol
      Input: elantech - fix firmware version check
      Input: ati_remote - add some missing devices from lirc_atiusb
      Input: eeti_ts - cancel pending work when going to suspend
      Input: Add support of Synaptics Clickpad device
      Revert "Input: ALPS - add signature for HP Pavilion dm3 laptops"
      Input: psmouse - ignore parity error for basic protocols

commit 7fbef0d1e278a0a8c803a4d2b1e2bd5740bffa52
Author: Daniel Mack <daniel@caiaq.de>
Date:   Mon Apr 19 00:42:16 2010 -0700

    Input: eeti_ts - cancel pending work when going to suspend
    
    This fixes a race between the suspend code and input events.
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index 9029bd3f34e5..6fb6bd8495e7 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -123,14 +123,25 @@ static irqreturn_t eeti_ts_isr(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static int eeti_ts_open(struct input_dev *dev)
+static void eeti_ts_start(struct eeti_ts_priv *priv)
 {
-	struct eeti_ts_priv *priv = input_get_drvdata(dev);
-
 	enable_irq(priv->irq);
 
 	/* Read the events once to arm the IRQ */
 	eeti_ts_read(&priv->work);
+}
+
+static void eeti_ts_stop(struct eeti_ts_priv *priv)
+{
+	disable_irq(priv->irq);
+	cancel_work_sync(&priv->work);
+}
+
+static int eeti_ts_open(struct input_dev *dev)
+{
+	struct eeti_ts_priv *priv = input_get_drvdata(dev);
+
+	eeti_ts_start(priv);
 
 	return 0;
 }
@@ -139,8 +150,7 @@ static void eeti_ts_close(struct input_dev *dev)
 {
 	struct eeti_ts_priv *priv = input_get_drvdata(dev);
 
-	disable_irq(priv->irq);
-	cancel_work_sync(&priv->work);
+	eeti_ts_stop(priv);
 }
 
 static int __devinit eeti_ts_probe(struct i2c_client *client,
@@ -152,10 +162,12 @@ static int __devinit eeti_ts_probe(struct i2c_client *client,
 	unsigned int irq_flags;
 	int err = -ENOMEM;
 
-	/* In contrast to what's described in the datasheet, there seems
+	/*
+	 * In contrast to what's described in the datasheet, there seems
 	 * to be no way of probing the presence of that device using I2C
 	 * commands. So we need to blindly believe it is there, and wait
-	 * for interrupts to occur. */
+	 * for interrupts to occur.
+	 */
 
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (!priv) {
@@ -211,9 +223,11 @@ static int __devinit eeti_ts_probe(struct i2c_client *client,
 		goto err2;
 	}
 
-	/* Disable the irq for now. It will be enabled once the input device
-	 * is opened. */
-	disable_irq(priv->irq);
+	/*
+	 * Disable the device for now. It will be enabled once the
+	 * input device is opened.
+	 */
+	eeti_ts_stop(priv);
 
 	device_init_wakeup(&client->dev, 0);
 	return 0;
@@ -234,6 +248,12 @@ static int __devexit eeti_ts_remove(struct i2c_client *client)
 	struct eeti_ts_priv *priv = i2c_get_clientdata(client);
 
 	free_irq(priv->irq, priv);
+	/*
+	 * eeti_ts_stop() leaves IRQ disabled. We need to re-enable it
+	 * so that device still works if we reload the driver.
+	 */
+	enable_irq(priv->irq);
+
 	input_unregister_device(priv->input);
 	i2c_set_clientdata(client, NULL);
 	kfree(priv);
@@ -245,6 +265,14 @@ static int __devexit eeti_ts_remove(struct i2c_client *client)
 static int eeti_ts_suspend(struct i2c_client *client, pm_message_t mesg)
 {
 	struct eeti_ts_priv *priv = i2c_get_clientdata(client);
+	struct input_dev *input_dev = priv->input;
+
+	mutex_lock(&input_dev->mutex);
+
+	if (input_dev->users)
+		eeti_ts_stop(priv);
+
+	mutex_unlock(&input_dev->mutex);
 
 	if (device_may_wakeup(&client->dev))
 		enable_irq_wake(priv->irq);
@@ -255,10 +283,18 @@ static int eeti_ts_suspend(struct i2c_client *client, pm_message_t mesg)
 static int eeti_ts_resume(struct i2c_client *client)
 {
 	struct eeti_ts_priv *priv = i2c_get_clientdata(client);
+	struct input_dev *input_dev = priv->input;
 
 	if (device_may_wakeup(&client->dev))
 		disable_irq_wake(priv->irq);
 
+	mutex_lock(&input_dev->mutex);
+
+	if (input_dev->users)
+		eeti_ts_start(priv);
+
+	mutex_unlock(&input_dev->mutex);
+
 	return 0;
 }
 #else

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index 9029bd3f34e5..204b8a1a601c 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -33,6 +33,7 @@
 #include <linux/timer.h>
 #include <linux/gpio.h>
 #include <linux/input/eeti_ts.h>
+#include <linux/slab.h>
 
 static int flip_x;
 module_param(flip_x, bool, 0644);

commit 25a70e38cd57952b09a013bf070e03705ee4f2ff
Author: Daniel Mack <daniel@caiaq.de>
Date:   Wed Aug 12 00:50:09 2009 -0700

    Input: eeti_ts - allow active high irq lines
    
    This adds a struct eeti_ts_platform_data which currently holds only one
    value to specify the interrupt polarity.
    
    The driver has a fallback if no platform data is passed in via the
    i2c_board_info, so no regression is caused.
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
index 3ab92222a525..9029bd3f34e5 100644
--- a/drivers/input/touchscreen/eeti_ts.c
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -32,6 +32,7 @@
 #include <linux/i2c.h>
 #include <linux/timer.h>
 #include <linux/gpio.h>
+#include <linux/input/eeti_ts.h>
 
 static int flip_x;
 module_param(flip_x, bool, 0644);
@@ -46,7 +47,7 @@ struct eeti_ts_priv {
 	struct input_dev *input;
 	struct work_struct work;
 	struct mutex mutex;
-	int irq;
+	int irq, irq_active_high;
 };
 
 #define EETI_TS_BITDEPTH	(11)
@@ -58,6 +59,11 @@ struct eeti_ts_priv {
 #define REPORT_BIT_HAS_PRESSURE	(1 << 6)
 #define REPORT_RES_BITS(v)	(((v) >> 1) + EETI_TS_BITDEPTH)
 
+static inline int eeti_ts_irq_active(struct eeti_ts_priv *priv)
+{
+	return gpio_get_value(irq_to_gpio(priv->irq)) == priv->irq_active_high;
+}
+
 static void eeti_ts_read(struct work_struct *work)
 {
 	char buf[6];
@@ -67,7 +73,7 @@ static void eeti_ts_read(struct work_struct *work)
 
 	mutex_lock(&priv->mutex);
 
-	while (!gpio_get_value(irq_to_gpio(priv->irq)) && --to)
+	while (eeti_ts_irq_active(priv) && --to)
 		i2c_master_recv(priv->client, buf, sizeof(buf));
 
 	if (!to) {
@@ -140,8 +146,10 @@ static void eeti_ts_close(struct input_dev *dev)
 static int __devinit eeti_ts_probe(struct i2c_client *client,
 				   const struct i2c_device_id *idp)
 {
+	struct eeti_ts_platform_data *pdata;
 	struct eeti_ts_priv *priv;
 	struct input_dev *input;
+	unsigned int irq_flags;
 	int err = -ENOMEM;
 
 	/* In contrast to what's described in the datasheet, there seems
@@ -180,6 +188,14 @@ static int __devinit eeti_ts_probe(struct i2c_client *client,
 	priv->input = input;
 	priv->irq = client->irq;
 
+	pdata = client->dev.platform_data;
+
+	if (pdata)
+		priv->irq_active_high = pdata->irq_active_high;
+
+	irq_flags = priv->irq_active_high ?
+		IRQF_TRIGGER_RISING : IRQF_TRIGGER_FALLING;
+
 	INIT_WORK(&priv->work, eeti_ts_read);
 	i2c_set_clientdata(client, priv);
 	input_set_drvdata(input, priv);
@@ -188,7 +204,7 @@ static int __devinit eeti_ts_probe(struct i2c_client *client,
 	if (err)
 		goto err1;
 
-	err = request_irq(priv->irq, eeti_ts_isr, IRQF_TRIGGER_FALLING,
+	err = request_irq(priv->irq, eeti_ts_isr, irq_flags,
 			  client->name, priv);
 	if (err) {
 		dev_err(&client->dev, "Unable to request touchscreen IRQ.\n");

commit 10494dce0b43ed3212abde64bf759705ee3c56ef
Author: Daniel Mack <daniel@caiaq.de>
Date:   Mon May 18 16:10:39 2009 -0700

    Input: add driver for EETI touchpanels
    
    This patch adds a driver for EETI's I2C connected touchscreens.
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Tested-by: Sven Neumann <s.neumann@raumfeld.com>
    Acked-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/touchscreen/eeti_ts.c b/drivers/input/touchscreen/eeti_ts.c
new file mode 100644
index 000000000000..3ab92222a525
--- /dev/null
+++ b/drivers/input/touchscreen/eeti_ts.c
@@ -0,0 +1,286 @@
+/*
+ * Touch Screen driver for EETI's I2C connected touch screen panels
+ *   Copyright (c) 2009 Daniel Mack <daniel@caiaq.de>
+ *
+ * See EETI's software guide for the protocol specification:
+ *   http://home.eeti.com.tw/web20/eg/guide.htm
+ *
+ * Based on migor_ts.c
+ *   Copyright (c) 2008 Magnus Damm
+ *   Copyright (c) 2007 Ujjwal Pande <ujjwal@kenati.com>
+ *
+ * This file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU  General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/timer.h>
+#include <linux/gpio.h>
+
+static int flip_x;
+module_param(flip_x, bool, 0644);
+MODULE_PARM_DESC(flip_x, "flip x coordinate");
+
+static int flip_y;
+module_param(flip_y, bool, 0644);
+MODULE_PARM_DESC(flip_y, "flip y coordinate");
+
+struct eeti_ts_priv {
+	struct i2c_client *client;
+	struct input_dev *input;
+	struct work_struct work;
+	struct mutex mutex;
+	int irq;
+};
+
+#define EETI_TS_BITDEPTH	(11)
+#define EETI_MAXVAL		((1 << (EETI_TS_BITDEPTH + 1)) - 1)
+
+#define REPORT_BIT_PRESSED	(1 << 0)
+#define REPORT_BIT_AD0		(1 << 1)
+#define REPORT_BIT_AD1		(1 << 2)
+#define REPORT_BIT_HAS_PRESSURE	(1 << 6)
+#define REPORT_RES_BITS(v)	(((v) >> 1) + EETI_TS_BITDEPTH)
+
+static void eeti_ts_read(struct work_struct *work)
+{
+	char buf[6];
+	unsigned int x, y, res, pressed, to = 100;
+	struct eeti_ts_priv *priv =
+		container_of(work, struct eeti_ts_priv, work);
+
+	mutex_lock(&priv->mutex);
+
+	while (!gpio_get_value(irq_to_gpio(priv->irq)) && --to)
+		i2c_master_recv(priv->client, buf, sizeof(buf));
+
+	if (!to) {
+		dev_err(&priv->client->dev,
+			"unable to clear IRQ - line stuck?\n");
+		goto out;
+	}
+
+	/* drop non-report packets */
+	if (!(buf[0] & 0x80))
+		goto out;
+
+	pressed = buf[0] & REPORT_BIT_PRESSED;
+	res = REPORT_RES_BITS(buf[0] & (REPORT_BIT_AD0 | REPORT_BIT_AD1));
+	x = buf[2] | (buf[1] << 8);
+	y = buf[4] | (buf[3] << 8);
+
+	/* fix the range to 11 bits */
+	x >>= res - EETI_TS_BITDEPTH;
+	y >>= res - EETI_TS_BITDEPTH;
+
+	if (flip_x)
+		x = EETI_MAXVAL - x;
+
+	if (flip_y)
+		y = EETI_MAXVAL - y;
+
+	if (buf[0] & REPORT_BIT_HAS_PRESSURE)
+		input_report_abs(priv->input, ABS_PRESSURE, buf[5]);
+
+	input_report_abs(priv->input, ABS_X, x);
+	input_report_abs(priv->input, ABS_Y, y);
+	input_report_key(priv->input, BTN_TOUCH, !!pressed);
+	input_sync(priv->input);
+
+out:
+	mutex_unlock(&priv->mutex);
+}
+
+static irqreturn_t eeti_ts_isr(int irq, void *dev_id)
+{
+	struct eeti_ts_priv *priv = dev_id;
+
+	 /* postpone I2C transactions as we are atomic */
+	schedule_work(&priv->work);
+
+	return IRQ_HANDLED;
+}
+
+static int eeti_ts_open(struct input_dev *dev)
+{
+	struct eeti_ts_priv *priv = input_get_drvdata(dev);
+
+	enable_irq(priv->irq);
+
+	/* Read the events once to arm the IRQ */
+	eeti_ts_read(&priv->work);
+
+	return 0;
+}
+
+static void eeti_ts_close(struct input_dev *dev)
+{
+	struct eeti_ts_priv *priv = input_get_drvdata(dev);
+
+	disable_irq(priv->irq);
+	cancel_work_sync(&priv->work);
+}
+
+static int __devinit eeti_ts_probe(struct i2c_client *client,
+				   const struct i2c_device_id *idp)
+{
+	struct eeti_ts_priv *priv;
+	struct input_dev *input;
+	int err = -ENOMEM;
+
+	/* In contrast to what's described in the datasheet, there seems
+	 * to be no way of probing the presence of that device using I2C
+	 * commands. So we need to blindly believe it is there, and wait
+	 * for interrupts to occur. */
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(&client->dev, "failed to allocate driver data\n");
+		goto err0;
+	}
+
+	mutex_init(&priv->mutex);
+	input = input_allocate_device();
+
+	if (!input) {
+		dev_err(&client->dev, "Failed to allocate input device.\n");
+		goto err1;
+	}
+
+	input->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	input->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+
+	input_set_abs_params(input, ABS_X, 0, EETI_MAXVAL, 0, 0);
+	input_set_abs_params(input, ABS_Y, 0, EETI_MAXVAL, 0, 0);
+	input_set_abs_params(input, ABS_PRESSURE, 0, 0xff, 0, 0);
+
+	input->name = client->name;
+	input->id.bustype = BUS_I2C;
+	input->dev.parent = &client->dev;
+	input->open = eeti_ts_open;
+	input->close = eeti_ts_close;
+
+	priv->client = client;
+	priv->input = input;
+	priv->irq = client->irq;
+
+	INIT_WORK(&priv->work, eeti_ts_read);
+	i2c_set_clientdata(client, priv);
+	input_set_drvdata(input, priv);
+
+	err = input_register_device(input);
+	if (err)
+		goto err1;
+
+	err = request_irq(priv->irq, eeti_ts_isr, IRQF_TRIGGER_FALLING,
+			  client->name, priv);
+	if (err) {
+		dev_err(&client->dev, "Unable to request touchscreen IRQ.\n");
+		goto err2;
+	}
+
+	/* Disable the irq for now. It will be enabled once the input device
+	 * is opened. */
+	disable_irq(priv->irq);
+
+	device_init_wakeup(&client->dev, 0);
+	return 0;
+
+err2:
+	input_unregister_device(input);
+	input = NULL; /* so we dont try to free it below */
+err1:
+	input_free_device(input);
+	i2c_set_clientdata(client, NULL);
+	kfree(priv);
+err0:
+	return err;
+}
+
+static int __devexit eeti_ts_remove(struct i2c_client *client)
+{
+	struct eeti_ts_priv *priv = i2c_get_clientdata(client);
+
+	free_irq(priv->irq, priv);
+	input_unregister_device(priv->input);
+	i2c_set_clientdata(client, NULL);
+	kfree(priv);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int eeti_ts_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	struct eeti_ts_priv *priv = i2c_get_clientdata(client);
+
+	if (device_may_wakeup(&client->dev))
+		enable_irq_wake(priv->irq);
+
+	return 0;
+}
+
+static int eeti_ts_resume(struct i2c_client *client)
+{
+	struct eeti_ts_priv *priv = i2c_get_clientdata(client);
+
+	if (device_may_wakeup(&client->dev))
+		disable_irq_wake(priv->irq);
+
+	return 0;
+}
+#else
+#define eeti_ts_suspend NULL
+#define eeti_ts_resume NULL
+#endif
+
+static const struct i2c_device_id eeti_ts_id[] = {
+	{ "eeti_ts", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, eeti_ts_id);
+
+static struct i2c_driver eeti_ts_driver = {
+	.driver = {
+		.name = "eeti_ts",
+	},
+	.probe = eeti_ts_probe,
+	.remove = __devexit_p(eeti_ts_remove),
+	.suspend = eeti_ts_suspend,
+	.resume = eeti_ts_resume,
+	.id_table = eeti_ts_id,
+};
+
+static int __init eeti_ts_init(void)
+{
+	return i2c_add_driver(&eeti_ts_driver);
+}
+
+static void __exit eeti_ts_exit(void)
+{
+	i2c_del_driver(&eeti_ts_driver);
+}
+
+MODULE_DESCRIPTION("EETI Touchscreen driver");
+MODULE_AUTHOR("Daniel Mack <daniel@caiaq.de>");
+MODULE_LICENSE("GPL");
+
+module_init(eeti_ts_init);
+module_exit(eeti_ts_exit);
+
