commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/input/rmi4/rmi_bus.c b/drivers/input/rmi4/rmi_bus.c
index bd0d5ff01b08..af706a583656 100644
--- a/drivers/input/rmi4/rmi_bus.c
+++ b/drivers/input/rmi4/rmi_bus.c
@@ -1,10 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (c) 2011-2016 Synaptics Incorporated
  * Copyright (c) 2011 Unixphere
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
  */
 
 #include <linux/kernel.h>

commit 24d28e4f1271cb2f91613dada8f2acccd00eff56
Author: Nick Dyer <nick@shmanahar.org>
Date:   Tue Jun 5 10:17:51 2018 -0700

    Input: synaptics-rmi4 - convert irq distribution to irq_domain
    
    Convert the RMI driver to use the standard mechanism for
    distributing IRQs to the various functions.
    
    Tested on:
    * S7300 (F11, F34, F54)
    * S7817 (F12, F34, F54)
    
    Signed-off-by: Nick Dyer <nick@shmanahar.org>
    Acked-by: Christopher Heiny <cheiny@synaptics.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/rmi4/rmi_bus.c b/drivers/input/rmi4/rmi_bus.c
index c5fa53adba8d..bd0d5ff01b08 100644
--- a/drivers/input/rmi4/rmi_bus.c
+++ b/drivers/input/rmi4/rmi_bus.c
@@ -9,6 +9,8 @@
 
 #include <linux/kernel.h>
 #include <linux/device.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
 #include <linux/list.h>
 #include <linux/pm.h>
 #include <linux/rmi.h>
@@ -167,6 +169,39 @@ static inline void rmi_function_of_probe(struct rmi_function *fn)
 {}
 #endif
 
+static struct irq_chip rmi_irq_chip = {
+	.name = "rmi4",
+};
+
+static int rmi_create_function_irq(struct rmi_function *fn,
+				   struct rmi_function_handler *handler)
+{
+	struct rmi_driver_data *drvdata = dev_get_drvdata(&fn->rmi_dev->dev);
+	int i, error;
+
+	for (i = 0; i < fn->num_of_irqs; i++) {
+		set_bit(fn->irq_pos + i, fn->irq_mask);
+
+		fn->irq[i] = irq_create_mapping(drvdata->irqdomain,
+						fn->irq_pos + i);
+
+		irq_set_chip_data(fn->irq[i], fn);
+		irq_set_chip_and_handler(fn->irq[i], &rmi_irq_chip,
+					 handle_simple_irq);
+		irq_set_nested_thread(fn->irq[i], 1);
+
+		error = devm_request_threaded_irq(&fn->dev, fn->irq[i], NULL,
+					handler->attention, IRQF_ONESHOT,
+					dev_name(&fn->dev), fn);
+		if (error) {
+			dev_err(&fn->dev, "Error %d registering IRQ\n", error);
+			return error;
+		}
+	}
+
+	return 0;
+}
+
 static int rmi_function_probe(struct device *dev)
 {
 	struct rmi_function *fn = to_rmi_function(dev);
@@ -178,7 +213,14 @@ static int rmi_function_probe(struct device *dev)
 
 	if (handler->probe) {
 		error = handler->probe(fn);
-		return error;
+		if (error)
+			return error;
+	}
+
+	if (fn->num_of_irqs && handler->attention) {
+		error = rmi_create_function_irq(fn, handler);
+		if (error)
+			return error;
 	}
 
 	return 0;
@@ -230,12 +272,18 @@ int rmi_register_function(struct rmi_function *fn)
 
 void rmi_unregister_function(struct rmi_function *fn)
 {
+	int i;
+
 	rmi_dbg(RMI_DEBUG_CORE, &fn->dev, "Unregistering F%02X.\n",
 			fn->fd.function_number);
 
 	device_del(&fn->dev);
 	of_node_put(fn->dev.of_node);
 	put_device(&fn->dev);
+
+	for (i = 0; i < fn->num_of_irqs; i++)
+		irq_dispose_mapping(fn->irq[i]);
+
 }
 
 /**

commit b6492b091784ac4052952e43c7cdb0be12b07fee
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Jan 16 16:41:37 2018 -0800

    Input: synaptics_rmi4 - remove unneeded MODULE_VERSION() usage
    
    MODULE_VERSION is useless for in-kernel drivers, so just remove all
    usage of it in the rmi4 drivers.  Now that this is gone, the
    RMI_DRIVER_VERSION macro was also removed as it was pointless.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/rmi4/rmi_bus.c b/drivers/input/rmi4/rmi_bus.c
index ae1bffe45c75..c5fa53adba8d 100644
--- a/drivers/input/rmi4/rmi_bus.c
+++ b/drivers/input/rmi4/rmi_bus.c
@@ -427,4 +427,3 @@ MODULE_AUTHOR("Christopher Heiny <cheiny@synaptics.com");
 MODULE_AUTHOR("Andrew Duggan <aduggan@synaptics.com");
 MODULE_DESCRIPTION("RMI bus");
 MODULE_LICENSE("GPL");
-MODULE_VERSION(RMI_DRIVER_VERSION);

commit d5e6e0fa442a479e27dfb7d17aeef1260dc19b09
Merge: 57b8443d3e5b f32361b71ae5
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Mon Feb 6 14:17:39 2017 -0800

    Merge branch 'synaptics-rmi4' into next
    
    Bring in latest RMI4 support in preparation to the merge window.

commit f719315b52b56c34d31c51c1926cea33a89cc9af
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Tue Jan 24 10:33:55 2017 -0800

    Input: constify device_type structures
    
    Declare device_type structures as const as they are only stored in the
    type field of a device structure. This field is of type const, so add
    const to declaration of device_type structures.
    
    File size before:
       text    data     bss     dec     hex filename
      17184    1344      80   18608    48b0 drivers/input/input.o
    
    File size after:
       text    data     bss     dec     hex filename
      17248    1280      80   18608    48b0 drivers/input/input.o
    
    File size before:
       text    data     bss     dec     hex filename
       2355     384       8    2747     abb drivers/input/rmi4/rmi_bus.o
    
    File size after:
       text    data     bss     dec     hex filename
       2483     264       8    2755     ac3 drivers/input/rmi4/rmi_bus.o
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/rmi4/rmi_bus.c b/drivers/input/rmi4/rmi_bus.c
index 1c40d94ca506..213e3189f74c 100644
--- a/drivers/input/rmi4/rmi_bus.c
+++ b/drivers/input/rmi4/rmi_bus.c
@@ -55,7 +55,7 @@ static void rmi_release_device(struct device *dev)
 	kfree(rmi_dev);
 }
 
-static struct device_type rmi_device_type = {
+static const struct device_type rmi_device_type = {
 	.name		= "rmi4_sensor",
 	.release	= rmi_release_device,
 };
@@ -134,7 +134,7 @@ static void rmi_release_function(struct device *dev)
 	kfree(fn);
 }
 
-static struct device_type rmi_function_type = {
+static const struct device_type rmi_function_type = {
 	.name		= "rmi4_function",
 	.release	= rmi_release_function,
 };

commit ed77bdf4e4bea810014cdf68b771bcbe3d47163f
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Sat Jan 21 23:46:16 2017 -0800

    Input: synaptics-rmi4 - use local variables consistently
    
    If a function declares a variable to access a structure element,
    use it conssistently.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/rmi4/rmi_bus.c b/drivers/input/rmi4/rmi_bus.c
index df97d8679bad..8f4ca8691a69 100644
--- a/drivers/input/rmi4/rmi_bus.c
+++ b/drivers/input/rmi4/rmi_bus.c
@@ -262,10 +262,10 @@ int __rmi_register_function_handler(struct rmi_function_handler *handler,
 	driver->probe = rmi_function_probe;
 	driver->remove = rmi_function_remove;
 
-	error = driver_register(&handler->driver);
+	error = driver_register(driver);
 	if (error) {
 		pr_err("driver_register() failed for %s, error: %d\n",
-			handler->driver.name, error);
+			driver->name, error);
 		return error;
 	}
 

commit af79ce47efabba36d1db0902d46a80de7f251411
Merge: c07dee7348e2 f26e8817b235
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 17 16:45:00 2016 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input
    
    Pull input subsystem updates from Dmitry Torokhov:
    
     - updated support for Synaptics RMI4 devices, including support for
       SMBus controllers, firmware update support, sensor tuning, and PS/2
       guest support
    
     - ALPS driver now supports tracksticks on SS5 controllers
    
     - i8042 now uses chassis info to skip selftest on Asus laptops as list
       of individual models became too unwieldy
    
     - miscellaneous fixes to other drivers
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input: (67 commits)
      Input: imx6ul_tsc - generalize the averaging property
      Input: drv260x - use generic device properties
      Input: drv260x - use temporary for &client->dev
      Input: drv260x - fix input device's parent assignment
      Input: synaptics-rmi4 - add support for F34 V7 bootloader
      Input: drv260x - fix initializing overdrive voltage
      Input: ALPS - fix protcol -> protocol
      Input: i8042 - comment #else/#endif of CONFIG_PNP
      Input: lpc32xx-keys - fix invalid error handling of a requested irq
      Input: synaptics-rmi4 - fix debug for sensor clip
      Input: synaptics-rmi4 - store the attn data in the driver
      Input: synaptics-rmi4 - allow to add attention data
      Input: synaptics-rmi4 - f03 - grab data passed by transport device
      Input: synaptics-rmi4 - add support for F03
      Input: imx6ul_tsc - convert int to u32
      Input: imx6ul_tsc - add mask when set REG_ADC_CFG
      Input: synaptics-rmi4 - have only one struct platform data
      Input: synaptics-rmi4 - remove EXPORT_SYMBOL_GPL for internal functions
      Input: synaptics-rmi4 - remove mutex calls while updating the firmware
      Input: drv2667 - fix misuse of regmap_update_bits
      ...

commit c5e8848fc98e363ea51b68de01392366312d9efa
Author: Lyude Paul <thatslyude@gmail.com>
Date:   Fri Dec 2 16:59:07 2016 -0800

    Input: synaptics-rmi4 - add support for F03
    
    This adds basic functionality for PS/2 passthrough on Synaptics
    Touchpads using RMI4 through smbus.
    
    Reviewed-by: Andrew Duggan <aduggan@synaptics.com>
    Signed-off-by: Lyude Paul <thatslyude@gmail.com>
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/rmi4/rmi_bus.c b/drivers/input/rmi4/rmi_bus.c
index 2534331ad9dc..df97d8679bad 100644
--- a/drivers/input/rmi4/rmi_bus.c
+++ b/drivers/input/rmi4/rmi_bus.c
@@ -306,6 +306,9 @@ struct bus_type rmi_bus_type = {
 
 static struct rmi_function_handler *fn_handlers[] = {
 	&rmi_f01_handler,
+#ifdef CONFIG_RMI4_F03
+	&rmi_f03_handler,
+#endif
 #ifdef CONFIG_RMI4_F11
 	&rmi_f11_handler,
 #endif

commit 6adba43fd222ea362c36296d1a6897c2e28fdc8e
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Tue Nov 22 17:53:26 2016 -0800

    Input: synaptics-rmi4 - add support for F55 sensor tuning
    
    Sensor tuning support is needed to determine the number of enabled
    tx and rx electrodes for use in F54 functions.
    
    The number of enabled electrodes is not identical to the total number
    of electrodes as reported with F55:Query0 and F55:Query1. It has to be
    calculated by analyzing F55:Ctrl1 (sensor receiver assignment) and
    F55:Ctrl2 (sensor transmitter assignment).
    
    Support for additional sensor tuning functions may be added later.
    
    Fixes: 3a762dbd5347 ("[media] Input: synaptics-rmi4 - add support for F54 ...")
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Tested-by: Nick Dyer <nick@shmanahar.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/rmi4/rmi_bus.c b/drivers/input/rmi4/rmi_bus.c
index ef7a66230d83..2534331ad9dc 100644
--- a/drivers/input/rmi4/rmi_bus.c
+++ b/drivers/input/rmi4/rmi_bus.c
@@ -321,6 +321,9 @@ static struct rmi_function_handler *fn_handlers[] = {
 #ifdef CONFIG_RMI4_F54
 	&rmi_f54_handler,
 #endif
+#ifdef CONFIG_RMI4_F55
+	&rmi_f55_handler,
+#endif
 };
 
 static void __rmi_unregister_function_handlers(int start_idx)

commit 29fd0ec2bdbef6734fd4c39c23f61d9f030a66a0
Author: Nick Dyer <nick@shmanahar.org>
Date:   Tue Nov 22 17:44:12 2016 -0800

    Input: synaptics-rmi4 - add support for F34 device reflash
    
    Add support for updating firmware, triggered by a sysfs attribute.
    
    This patch has been tested on Synaptics S7300.
    
    Signed-off-by: Nick Dyer <nick@shmanahar.org>
    Tested-by: Chris Healy <cphealy@gmail.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/rmi4/rmi_bus.c b/drivers/input/rmi4/rmi_bus.c
index 84b321262d74..ef7a66230d83 100644
--- a/drivers/input/rmi4/rmi_bus.c
+++ b/drivers/input/rmi4/rmi_bus.c
@@ -315,6 +315,9 @@ static struct rmi_function_handler *fn_handlers[] = {
 #ifdef CONFIG_RMI4_F30
 	&rmi_f30_handler,
 #endif
+#ifdef CONFIG_RMI4_F34
+	&rmi_f34_handler,
+#endif
 #ifdef CONFIG_RMI4_F54
 	&rmi_f54_handler,
 #endif

commit 8029a283c4ac100dc4492993633d4c87a7da55d6
Author: Nick Dyer <nick@shmanahar.org>
Date:   Mon Nov 7 17:36:57 2016 -0800

    Input: synaptics-rmi4 - add a couple of debug lines
    
    Signed-off-by: Nick Dyer <nick@shmanahar.org>
    Tested-by: Chris Healy <cphealy@gmail.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/rmi4/rmi_bus.c b/drivers/input/rmi4/rmi_bus.c
index 09c769c6e91f..84b321262d74 100644
--- a/drivers/input/rmi4/rmi_bus.c
+++ b/drivers/input/rmi4/rmi_bus.c
@@ -231,6 +231,9 @@ int rmi_register_function(struct rmi_function *fn)
 
 void rmi_unregister_function(struct rmi_function *fn)
 {
+	rmi_dbg(RMI_DEBUG_CORE, &fn->dev, "Unregistering F%02X.\n",
+			fn->fd.function_number);
+
 	device_del(&fn->dev);
 	of_node_put(fn->dev.of_node);
 	put_device(&fn->dev);

commit a379f71a30dddbd2e7393624e455ce53c87965d1
Merge: de34f4da7f62 9c5d760b8d22
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 11 17:34:10 2016 -0700

    Merge branch 'akpm' (patches from Andrew)
    
    Merge more updates from Andrew Morton:
    
     - a few block updates that fell in my lap
    
     - lib/ updates
    
     - checkpatch
    
     - autofs
    
     - ipc
    
     - a ton of misc other things
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (100 commits)
      mm: split gfp_mask and mapping flags into separate fields
      fs: use mapping_set_error instead of opencoded set_bit
      treewide: remove redundant #include <linux/kconfig.h>
      hung_task: allow hung_task_panic when hung_task_warnings is 0
      kthread: add kerneldoc for kthread_create()
      kthread: better support freezable kthread workers
      kthread: allow to modify delayed kthread work
      kthread: allow to cancel kthread work
      kthread: initial support for delayed kthread work
      kthread: detect when a kthread work is used by more workers
      kthread: add kthread_destroy_worker()
      kthread: add kthread_create_worker*()
      kthread: allow to call __kthread_create_on_node() with va_list args
      kthread/smpboot: do not park in kthread_create_on_cpu()
      kthread: kthread worker API cleanup
      kthread: rename probe_kthread_data() to kthread_probe_data()
      scripts/tags.sh: enable code completion in VIM
      mm: kmemleak: avoid using __va() on addresses that don't have a lowmem mapping
      kdump, vmcoreinfo: report memory sections virtual addresses
      ipc/sem.c: add cond_resched in exit_sme
      ...

commit 97139d4a6f26445de47b378cddd5192c0278f863
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Oct 11 13:55:58 2016 -0700

    treewide: remove redundant #include <linux/kconfig.h>
    
    Kernel source files need not include <linux/kconfig.h> explicitly
    because the top Makefile forces to include it with:
    
      -include $(srctree)/include/linux/kconfig.h
    
    This commit removes explicit includes except the following:
    
      * arch/s390/include/asm/facilities_src.h
      * tools/testing/radix-tree/linux/kernel.h
    
    These two are used for host programs.
    
    Link: http://lkml.kernel.org/r/1473656164-11929-1-git-send-email-yamada.masahiro@socionext.com
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/input/rmi4/rmi_bus.c b/drivers/input/rmi4/rmi_bus.c
index a73580654c6b..e0b5a45e2b15 100644
--- a/drivers/input/rmi4/rmi_bus.c
+++ b/drivers/input/rmi4/rmi_bus.c
@@ -9,7 +9,6 @@
 
 #include <linux/kernel.h>
 #include <linux/device.h>
-#include <linux/kconfig.h>
 #include <linux/list.h>
 #include <linux/pm.h>
 #include <linux/rmi.h>

commit 3a762dbd5347514c3cb2ac756a92a3d1c7646a2d
Author: Nick Dyer <nick@shmanahar.org>
Date:   Mon Jul 18 18:10:37 2016 -0300

    [media] Input: synaptics-rmi4 - add support for F54 diagnostics
    
    Function 54 implements access to various RMI4 diagnostic features.
    
    This patch adds support for retrieving this data. It registers a V4L2
    device to output the data to user space.
    
    Signed-off-by: Nick Dyer <nick@shmanahar.org>
    Tested-by: Andrew Duggan <aduggan@synaptics.com>
    Tested-by: Chris Healy <cphealy@gmail.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/rmi4/rmi_bus.c b/drivers/input/rmi4/rmi_bus.c
index a73580654c6b..09c769c6e91f 100644
--- a/drivers/input/rmi4/rmi_bus.c
+++ b/drivers/input/rmi4/rmi_bus.c
@@ -312,6 +312,9 @@ static struct rmi_function_handler *fn_handlers[] = {
 #ifdef CONFIG_RMI4_F30
 	&rmi_f30_handler,
 #endif
+#ifdef CONFIG_RMI4_F54
+	&rmi_f54_handler,
+#endif
 };
 
 static void __rmi_unregister_function_handlers(int start_idx)

commit 887ec0bfbd146c08e34ccb65a8f4251dc110e52f
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Mon Jul 25 11:29:59 2016 -0700

    Input: synaptics-rmi4 - do not check for NULL when calling of_node_put()
    
    The of_node_put() function tests whether its argument is NULL and then
    returns immediately. Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/rmi4/rmi_bus.c b/drivers/input/rmi4/rmi_bus.c
index 253df96be427..a73580654c6b 100644
--- a/drivers/input/rmi4/rmi_bus.c
+++ b/drivers/input/rmi4/rmi_bus.c
@@ -232,10 +232,7 @@ int rmi_register_function(struct rmi_function *fn)
 void rmi_unregister_function(struct rmi_function *fn)
 {
 	device_del(&fn->dev);
-
-	if (fn->dev.of_node)
-		of_node_put(fn->dev.of_node);
-
+	of_node_put(fn->dev.of_node);
 	put_device(&fn->dev);
 }
 

commit 9624516db0f3ffcbd1ba1007775d068f54049773
Author: Andrew Duggan <aduggan@synaptics.com>
Date:   Thu Jul 14 09:35:44 2016 -0700

    Input: synaptics-rmi4 - use of_get_child_by_name() to fix refcount
    
    Calling of_find_node_by_name() assumes that the caller has incremented
    the refcount of the of_node being passed in. Currently, the caller is
    not incrementing the refcount of the of_node which results in the node
    being prematurely freed when of_find_node_by_name() calls of_node_put()
    on it. Instead use of_get_child_by_name() which does not call put on the
    of_node.
    
    Signed-off-by: Andrew Duggan <aduggan@synaptics.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/rmi4/rmi_bus.c b/drivers/input/rmi4/rmi_bus.c
index b368b0515c5a..253df96be427 100644
--- a/drivers/input/rmi4/rmi_bus.c
+++ b/drivers/input/rmi4/rmi_bus.c
@@ -157,11 +157,11 @@ static int rmi_function_match(struct device *dev, struct device_driver *drv)
 static void rmi_function_of_probe(struct rmi_function *fn)
 {
 	char of_name[9];
+	struct device_node *node = fn->rmi_dev->xport->dev->of_node;
 
 	snprintf(of_name, sizeof(of_name), "rmi4-f%02x",
 		fn->fd.function_number);
-	fn->dev.of_node = of_find_node_by_name(
-				fn->rmi_dev->xport->dev->of_node, of_name);
+	fn->dev.of_node = of_get_child_by_name(node, of_name);
 }
 #else
 static inline void rmi_function_of_probe(struct rmi_function *fn)

commit 562b42d3ee305472e1b2ea31574c59925e95fd7e
Author: Andrew Duggan <aduggan@synaptics.com>
Date:   Thu Mar 10 15:56:58 2016 -0800

    Input: synaptics-rmi4 - add support for F30
    
    RMI4 F30 supports input from clickpad buttons and controls LEDs located
    on the touchpad PCB. This patch adds support of the clickpad buttons and
    defers supporting LEDs for the future.
    
    Signed-off-by: Andrew Duggan <aduggan@synaptics.com>
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Tested-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/rmi4/rmi_bus.c b/drivers/input/rmi4/rmi_bus.c
index a3d766118b61..b368b0515c5a 100644
--- a/drivers/input/rmi4/rmi_bus.c
+++ b/drivers/input/rmi4/rmi_bus.c
@@ -312,6 +312,9 @@ static struct rmi_function_handler *fn_handlers[] = {
 #ifdef CONFIG_RMI4_F12
 	&rmi_f12_handler,
 #endif
+#ifdef CONFIG_RMI4_F30
+	&rmi_f30_handler,
+#endif
 };
 
 static void __rmi_unregister_function_handlers(int start_idx)

commit b43d2c1e9353814ce1716fff03d9223f40fa73b5
Author: Andrew Duggan <aduggan@synaptics.com>
Date:   Thu Mar 10 15:55:29 2016 -0800

    Input: synaptics-rmi4 - add support for F12
    
    Function 12 implements 2D touch position sensor for newer Synaptics touch
    devices. It replaces F11 and no device will contain both functions.
    
    Signed-off-by: Andrew Duggan <aduggan@synaptics.com>
    Signed-off-by: Christopher Heiny <cheiny@synaptics.com>
    Tested-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/rmi4/rmi_bus.c b/drivers/input/rmi4/rmi_bus.c
index 2e3878343961..a3d766118b61 100644
--- a/drivers/input/rmi4/rmi_bus.c
+++ b/drivers/input/rmi4/rmi_bus.c
@@ -309,6 +309,9 @@ static struct rmi_function_handler *fn_handlers[] = {
 #ifdef CONFIG_RMI4_F11
 	&rmi_f11_handler,
 #endif
+#ifdef CONFIG_RMI4_F12
+	&rmi_f12_handler,
+#endif
 };
 
 static void __rmi_unregister_function_handlers(int start_idx)

commit ff8f83708b3e36c050dc3fd7e2f04ea7f1752599
Author: Andrew Duggan <aduggan@synaptics.com>
Date:   Thu Mar 10 15:47:28 2016 -0800

    Input: synaptics-rmi4 - add support for 2D sensors and F11
    
    RMI4 currently defines two functions for reporting data for 2D sensors
    (F11 and F12). This patch adds the common functionality which is shared
    by devices with 2D reporting along with implementing functionality for
    F11.
    
    Signed-off-by: Andrew Duggan <aduggan@synaptics.com>
    Signed-off-by: Christopher Heiny <cheiny@synaptics.com>
    Tested-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/rmi4/rmi_bus.c b/drivers/input/rmi4/rmi_bus.c
index 434477ea0c4e..2e3878343961 100644
--- a/drivers/input/rmi4/rmi_bus.c
+++ b/drivers/input/rmi4/rmi_bus.c
@@ -306,6 +306,9 @@ struct bus_type rmi_bus_type = {
 
 static struct rmi_function_handler *fn_handlers[] = {
 	&rmi_f01_handler,
+#ifdef CONFIG_RMI4_F11
+	&rmi_f11_handler,
+#endif
 };
 
 static void __rmi_unregister_function_handlers(int start_idx)

commit d8a8b3edfd922e3886684a3434bd2b752167ff29
Author: Andrew Duggan <aduggan@synaptics.com>
Date:   Thu Mar 10 15:46:32 2016 -0800

    Input: synaptics-rmi4 - add device tree support for RMI4 I2C devices
    
    Add devicetree binding for I2C devices and add bindings for optional
    parameters in the function drivers. Parameters for function drivers are
    defined in child nodes for each of the functions.
    
    Signed-off-by: Andrew Duggan <aduggan@synaptics.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Tested-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/rmi4/rmi_bus.c b/drivers/input/rmi4/rmi_bus.c
index 0a2bd5a0f2b7..434477ea0c4e 100644
--- a/drivers/input/rmi4/rmi_bus.c
+++ b/drivers/input/rmi4/rmi_bus.c
@@ -153,6 +153,21 @@ static int rmi_function_match(struct device *dev, struct device_driver *drv)
 	return fn->fd.function_number == handler->func;
 }
 
+#ifdef CONFIG_OF
+static void rmi_function_of_probe(struct rmi_function *fn)
+{
+	char of_name[9];
+
+	snprintf(of_name, sizeof(of_name), "rmi4-f%02x",
+		fn->fd.function_number);
+	fn->dev.of_node = of_find_node_by_name(
+				fn->rmi_dev->xport->dev->of_node, of_name);
+}
+#else
+static inline void rmi_function_of_probe(struct rmi_function *fn)
+{}
+#endif
+
 static int rmi_function_probe(struct device *dev)
 {
 	struct rmi_function *fn = to_rmi_function(dev);
@@ -160,6 +175,8 @@ static int rmi_function_probe(struct device *dev)
 					to_rmi_function_handler(dev->driver);
 	int error;
 
+	rmi_function_of_probe(fn);
+
 	if (handler->probe) {
 		error = handler->probe(fn);
 		return error;
@@ -325,6 +342,24 @@ static int rmi_register_function_handlers(void)
 	return ret;
 }
 
+int rmi_of_property_read_u32(struct device *dev, u32 *result,
+				const char *prop, bool optional)
+{
+	int retval;
+	u32 val = 0;
+
+	retval = of_property_read_u32(dev->of_node, prop, &val);
+	if (retval && (!optional && retval == -EINVAL)) {
+		dev_err(dev, "Failed to get %s value: %d\n",
+			prop, retval);
+		return retval;
+	}
+	*result = val;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(rmi_of_property_read_u32);
+
 static int __init rmi_bus_init(void)
 {
 	int error;

commit 2b6a321da9a2d8725a1d3dbb0b2e96a7618ebe56
Author: Andrew Duggan <aduggan@synaptics.com>
Date:   Thu Mar 10 15:35:49 2016 -0800

    Input: synaptics-rmi4 - add support for Synaptics RMI4 devices
    
    Synaptics uses the Register Mapped Interface (RMI) protocol as a
    communications interface for their devices. This driver adds the core
    functionality needed to interface with RMI4 devices.
    
    RMI devices can be connected to the host via several transport protocols
    and can supports a wide variety of functionality defined by RMI functions.
    Support for transport protocols and RMI functions are implemented in
    individual drivers. The RMI4 core driver uses a bus architecture to
    facilitate the various combinations of transport and function drivers
    needed by a particular device.
    
    Signed-off-by: Andrew Duggan <aduggan@synaptics.com>
    Signed-off-by: Christopher Heiny <cheiny@synaptics.com>
    Tested-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/rmi4/rmi_bus.c b/drivers/input/rmi4/rmi_bus.c
new file mode 100644
index 000000000000..0a2bd5a0f2b7
--- /dev/null
+++ b/drivers/input/rmi4/rmi_bus.c
@@ -0,0 +1,375 @@
+/*
+ * Copyright (c) 2011-2016 Synaptics Incorporated
+ * Copyright (c) 2011 Unixphere
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/kconfig.h>
+#include <linux/list.h>
+#include <linux/pm.h>
+#include <linux/rmi.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/of.h>
+#include "rmi_bus.h"
+#include "rmi_driver.h"
+
+static int debug_flags;
+module_param(debug_flags, int, 0644);
+MODULE_PARM_DESC(debug_flags, "control debugging information");
+
+void rmi_dbg(int flags, struct device *dev, const char *fmt, ...)
+{
+	struct va_format vaf;
+	va_list args;
+
+	if (flags & debug_flags) {
+		va_start(args, fmt);
+
+		vaf.fmt = fmt;
+		vaf.va = &args;
+
+		dev_printk(KERN_DEBUG, dev, "%pV", &vaf);
+
+		va_end(args);
+	}
+}
+EXPORT_SYMBOL_GPL(rmi_dbg);
+
+/*
+ * RMI Physical devices
+ *
+ * Physical RMI device consists of several functions serving particular
+ * purpose. For example F11 is a 2D touch sensor while F01 is a generic
+ * function present in every RMI device.
+ */
+
+static void rmi_release_device(struct device *dev)
+{
+	struct rmi_device *rmi_dev = to_rmi_device(dev);
+
+	kfree(rmi_dev);
+}
+
+static struct device_type rmi_device_type = {
+	.name		= "rmi4_sensor",
+	.release	= rmi_release_device,
+};
+
+bool rmi_is_physical_device(struct device *dev)
+{
+	return dev->type == &rmi_device_type;
+}
+
+/**
+ * rmi_register_transport_device - register a transport device connection
+ * on the RMI bus.  Transport drivers provide communication from the devices
+ * on a bus (such as SPI, I2C, and so on) to the RMI4 sensor.
+ *
+ * @xport: the transport device to register
+ */
+int rmi_register_transport_device(struct rmi_transport_dev *xport)
+{
+	static atomic_t transport_device_count = ATOMIC_INIT(0);
+	struct rmi_device *rmi_dev;
+	int error;
+
+	rmi_dev = kzalloc(sizeof(struct rmi_device), GFP_KERNEL);
+	if (!rmi_dev)
+		return -ENOMEM;
+
+	device_initialize(&rmi_dev->dev);
+
+	rmi_dev->xport = xport;
+	rmi_dev->number = atomic_inc_return(&transport_device_count) - 1;
+
+	dev_set_name(&rmi_dev->dev, "rmi4-%02d", rmi_dev->number);
+
+	rmi_dev->dev.bus = &rmi_bus_type;
+	rmi_dev->dev.type = &rmi_device_type;
+
+	xport->rmi_dev = rmi_dev;
+
+	error = device_add(&rmi_dev->dev);
+	if (error)
+		goto err_put_device;
+
+	rmi_dbg(RMI_DEBUG_CORE, xport->dev,
+		"%s: Registered %s as %s.\n", __func__,
+		dev_name(rmi_dev->xport->dev), dev_name(&rmi_dev->dev));
+
+	return 0;
+
+err_put_device:
+	put_device(&rmi_dev->dev);
+	return error;
+}
+EXPORT_SYMBOL_GPL(rmi_register_transport_device);
+
+/**
+ * rmi_unregister_transport_device - unregister a transport device connection
+ * @xport: the transport driver to unregister
+ *
+ */
+void rmi_unregister_transport_device(struct rmi_transport_dev *xport)
+{
+	struct rmi_device *rmi_dev = xport->rmi_dev;
+
+	device_del(&rmi_dev->dev);
+	put_device(&rmi_dev->dev);
+}
+EXPORT_SYMBOL(rmi_unregister_transport_device);
+
+
+/* Function specific stuff */
+
+static void rmi_release_function(struct device *dev)
+{
+	struct rmi_function *fn = to_rmi_function(dev);
+
+	kfree(fn);
+}
+
+static struct device_type rmi_function_type = {
+	.name		= "rmi4_function",
+	.release	= rmi_release_function,
+};
+
+bool rmi_is_function_device(struct device *dev)
+{
+	return dev->type == &rmi_function_type;
+}
+
+static int rmi_function_match(struct device *dev, struct device_driver *drv)
+{
+	struct rmi_function_handler *handler = to_rmi_function_handler(drv);
+	struct rmi_function *fn = to_rmi_function(dev);
+
+	return fn->fd.function_number == handler->func;
+}
+
+static int rmi_function_probe(struct device *dev)
+{
+	struct rmi_function *fn = to_rmi_function(dev);
+	struct rmi_function_handler *handler =
+					to_rmi_function_handler(dev->driver);
+	int error;
+
+	if (handler->probe) {
+		error = handler->probe(fn);
+		return error;
+	}
+
+	return 0;
+}
+
+static int rmi_function_remove(struct device *dev)
+{
+	struct rmi_function *fn = to_rmi_function(dev);
+	struct rmi_function_handler *handler =
+					to_rmi_function_handler(dev->driver);
+
+	if (handler->remove)
+		handler->remove(fn);
+
+	return 0;
+}
+
+int rmi_register_function(struct rmi_function *fn)
+{
+	struct rmi_device *rmi_dev = fn->rmi_dev;
+	int error;
+
+	device_initialize(&fn->dev);
+
+	dev_set_name(&fn->dev, "%s.fn%02x",
+		     dev_name(&rmi_dev->dev), fn->fd.function_number);
+
+	fn->dev.parent = &rmi_dev->dev;
+	fn->dev.type = &rmi_function_type;
+	fn->dev.bus = &rmi_bus_type;
+
+	error = device_add(&fn->dev);
+	if (error) {
+		dev_err(&rmi_dev->dev,
+			"Failed device_register function device %s\n",
+			dev_name(&fn->dev));
+		goto err_put_device;
+	}
+
+	rmi_dbg(RMI_DEBUG_CORE, &rmi_dev->dev, "Registered F%02X.\n",
+			fn->fd.function_number);
+
+	return 0;
+
+err_put_device:
+	put_device(&fn->dev);
+	return error;
+}
+
+void rmi_unregister_function(struct rmi_function *fn)
+{
+	device_del(&fn->dev);
+
+	if (fn->dev.of_node)
+		of_node_put(fn->dev.of_node);
+
+	put_device(&fn->dev);
+}
+
+/**
+ * rmi_register_function_handler - register a handler for an RMI function
+ * @handler: RMI handler that should be registered.
+ * @module: pointer to module that implements the handler
+ * @mod_name: name of the module implementing the handler
+ *
+ * This function performs additional setup of RMI function handler and
+ * registers it with the RMI core so that it can be bound to
+ * RMI function devices.
+ */
+int __rmi_register_function_handler(struct rmi_function_handler *handler,
+				     struct module *owner,
+				     const char *mod_name)
+{
+	struct device_driver *driver = &handler->driver;
+	int error;
+
+	driver->bus = &rmi_bus_type;
+	driver->owner = owner;
+	driver->mod_name = mod_name;
+	driver->probe = rmi_function_probe;
+	driver->remove = rmi_function_remove;
+
+	error = driver_register(&handler->driver);
+	if (error) {
+		pr_err("driver_register() failed for %s, error: %d\n",
+			handler->driver.name, error);
+		return error;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(__rmi_register_function_handler);
+
+/**
+ * rmi_unregister_function_handler - unregister given RMI function handler
+ * @handler: RMI handler that should be unregistered.
+ *
+ * This function unregisters given function handler from RMI core which
+ * causes it to be unbound from the function devices.
+ */
+void rmi_unregister_function_handler(struct rmi_function_handler *handler)
+{
+	driver_unregister(&handler->driver);
+}
+EXPORT_SYMBOL_GPL(rmi_unregister_function_handler);
+
+/* Bus specific stuff */
+
+static int rmi_bus_match(struct device *dev, struct device_driver *drv)
+{
+	bool physical = rmi_is_physical_device(dev);
+
+	/* First see if types are not compatible */
+	if (physical != rmi_is_physical_driver(drv))
+		return 0;
+
+	return physical || rmi_function_match(dev, drv);
+}
+
+struct bus_type rmi_bus_type = {
+	.match		= rmi_bus_match,
+	.name		= "rmi4",
+};
+
+static struct rmi_function_handler *fn_handlers[] = {
+	&rmi_f01_handler,
+};
+
+static void __rmi_unregister_function_handlers(int start_idx)
+{
+	int i;
+
+	for (i = start_idx; i >= 0; i--)
+		rmi_unregister_function_handler(fn_handlers[i]);
+}
+
+static void rmi_unregister_function_handlers(void)
+{
+	__rmi_unregister_function_handlers(ARRAY_SIZE(fn_handlers) - 1);
+}
+
+static int rmi_register_function_handlers(void)
+{
+	int ret;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(fn_handlers); i++)	{
+		ret = rmi_register_function_handler(fn_handlers[i]);
+		if (ret) {
+			pr_err("%s: error registering the RMI F%02x handler: %d\n",
+				__func__, fn_handlers[i]->func, ret);
+			goto err_unregister_function_handlers;
+		}
+	}
+
+	return 0;
+
+err_unregister_function_handlers:
+	__rmi_unregister_function_handlers(i - 1);
+	return ret;
+}
+
+static int __init rmi_bus_init(void)
+{
+	int error;
+
+	error = bus_register(&rmi_bus_type);
+	if (error) {
+		pr_err("%s: error registering the RMI bus: %d\n",
+			__func__, error);
+		return error;
+	}
+
+	error = rmi_register_function_handlers();
+	if (error)
+		goto err_unregister_bus;
+
+	error = rmi_register_physical_driver();
+	if (error) {
+		pr_err("%s: error registering the RMI physical driver: %d\n",
+			__func__, error);
+		goto err_unregister_bus;
+	}
+
+	return 0;
+
+err_unregister_bus:
+	bus_unregister(&rmi_bus_type);
+	return error;
+}
+module_init(rmi_bus_init);
+
+static void __exit rmi_bus_exit(void)
+{
+	/*
+	 * We should only ever get here if all drivers are unloaded, so
+	 * all we have to do at this point is unregister ourselves.
+	 */
+
+	rmi_unregister_physical_driver();
+	rmi_unregister_function_handlers();
+	bus_unregister(&rmi_bus_type);
+}
+module_exit(rmi_bus_exit);
+
+MODULE_AUTHOR("Christopher Heiny <cheiny@synaptics.com");
+MODULE_AUTHOR("Andrew Duggan <aduggan@synaptics.com");
+MODULE_DESCRIPTION("RMI bus");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(RMI_DRIVER_VERSION);
