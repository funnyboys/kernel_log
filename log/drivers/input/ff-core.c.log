commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/input/ff-core.c b/drivers/input/ff-core.c
index 66a46c84e28f..1cf5deda06e1 100644
--- a/drivers/input/ff-core.c
+++ b/drivers/input/ff-core.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Force feedback support for Linux input subsystem
  *
@@ -6,19 +7,6 @@
  */
 
 /*
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
 
 /* #define DEBUG */

commit e8b95728f724797f958912fd9b765a695595d3a6
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Sep 1 17:13:43 2017 -0700

    Input: uinput - avoid FF flush when destroying device
    
    Normally, when input device supporting force feedback effects is being
    destroyed, we try to "flush" currently playing effects, so that the
    physical device does not continue vibrating (or executing other effects).
    Unfortunately this does not work well for uinput as flushing of the effects
    deadlocks with the destroy action:
    
    - if device is being destroyed because the file descriptor is being closed,
      then there is noone to even service FF requests;
    
    - if device is being destroyed because userspace sent UI_DEV_DESTROY,
      while theoretically it could be possible to service FF requests,
      userspace is unlikely to do so (they'd need to make sure FF handling
      happens on a separate thread) even if kernel solves the issue with FF
      ioctls deadlocking with UI_DEV_DESTROY ioctl on udev->mutex.
    
    To avoid lockups like the one below, let's install a custom input device
    flush handler, and avoid trying to flush force feedback effects when we
    destroying the device, and instead rely on uinput to shut off the device
    properly.
    
    NMI watchdog: Watchdog detected hard LOCKUP on cpu 3
    ...
     <<EOE>>  [<ffffffff817a0307>] _raw_spin_lock_irqsave+0x37/0x40
     [<ffffffff810e633d>] complete+0x1d/0x50
     [<ffffffffa00ba08c>] uinput_request_done+0x3c/0x40 [uinput]
     [<ffffffffa00ba587>] uinput_request_submit.part.7+0x47/0xb0 [uinput]
     [<ffffffffa00bb62b>] uinput_dev_erase_effect+0x5b/0x76 [uinput]
     [<ffffffff815d91ad>] erase_effect+0xad/0xf0
     [<ffffffff815d929d>] flush_effects+0x4d/0x90
     [<ffffffff815d4cc0>] input_flush_device+0x40/0x60
     [<ffffffff815daf1c>] evdev_cleanup+0xac/0xc0
     [<ffffffff815daf5b>] evdev_disconnect+0x2b/0x60
     [<ffffffff815d74ac>] __input_unregister_device+0xac/0x150
     [<ffffffff815d75f7>] input_unregister_device+0x47/0x70
     [<ffffffffa00bac45>] uinput_destroy_device+0xb5/0xc0 [uinput]
     [<ffffffffa00bb2de>] uinput_ioctl_handler.isra.9+0x65e/0x740 [uinput]
     [<ffffffff811231ab>] ? do_futex+0x12b/0xad0
     [<ffffffffa00bb3f8>] uinput_ioctl+0x18/0x20 [uinput]
     [<ffffffff81241248>] do_vfs_ioctl+0x298/0x480
     [<ffffffff81337553>] ? security_file_ioctl+0x43/0x60
     [<ffffffff812414a9>] SyS_ioctl+0x79/0x90
     [<ffffffff817a04ee>] entry_SYSCALL_64_fastpath+0x12/0x71
    
    Reported-by: Rodrigo Rivas Costa <rodrigorivascosta@gmail.com>
    Reported-by: Cl√©ment VUCHENER <clement.vuchener@gmail.com>
    Fixes: https://bugzilla.kernel.org/show_bug.cgi?id=193741
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/ff-core.c b/drivers/input/ff-core.c
index 8f2042432c85..66a46c84e28f 100644
--- a/drivers/input/ff-core.c
+++ b/drivers/input/ff-core.c
@@ -237,9 +237,15 @@ int input_ff_erase(struct input_dev *dev, int effect_id, struct file *file)
 EXPORT_SYMBOL_GPL(input_ff_erase);
 
 /*
- * flush_effects - erase all effects owned by a file handle
+ * input_ff_flush - erase all effects owned by a file handle
+ * @dev: input device to erase effect from
+ * @file: purported owner of the effects
+ *
+ * This function erases all force-feedback effects associated with
+ * the given owner from specified device. Note that @file may be %NULL,
+ * in which case all effects will be erased.
  */
-static int flush_effects(struct input_dev *dev, struct file *file)
+int input_ff_flush(struct input_dev *dev, struct file *file)
 {
 	struct ff_device *ff = dev->ff;
 	int i;
@@ -255,6 +261,7 @@ static int flush_effects(struct input_dev *dev, struct file *file)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(input_ff_flush);
 
 /**
  * input_ff_event() - generic handler for force-feedback events
@@ -343,7 +350,7 @@ int input_ff_create(struct input_dev *dev, unsigned int max_effects)
 	mutex_init(&ff->mutex);
 
 	dev->ff = ff;
-	dev->flush = flush_effects;
+	dev->flush = input_ff_flush;
 	dev->event = input_ff_event;
 	__set_bit(EV_FF, dev->evbit);
 

commit 33b96d934902f96e901b72ac18bbc47afad1ac20
Author: Elias Vanderstuyft <elias.vds@gmail.com>
Date:   Wed Oct 14 17:29:37 2015 -0700

    Input: document and check on implicitly defined FF_MAX_EFFECTS
    
    There is an undocumented upper bound for the total number of ff effects:
        FF_GAIN (= 96).
    This can be found as follows:
    - user: write(EV_FF, effect_id, iterations)
        calls kernel: ff->playback(effect_id, ...): starts effect "effect_id"
    - user: write(EV_FF, FF_GAIN, gain)
        calls kernel: ff->set_gain(gain, ...): sets gain
    
    A collision occurs when effect_id equals FF_GAIN.
    According to input_ff_event(),
    FF_GAIN is the smallest value where a collision occurs.
    Therefore the greatest safe value for effect_id is FF_GAIN - 1,
    and thus the total number of effects should never exceed FF_GAIN.
    
    Define FF_MAX_EFFECTS as FF_GAIN and check on this limit in ff-core.
    
    Signed-off-by: Elias Vanderstuyft <elias.vds@gmail.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/ff-core.c b/drivers/input/ff-core.c
index eab56c0aacd5..8f2042432c85 100644
--- a/drivers/input/ff-core.c
+++ b/drivers/input/ff-core.c
@@ -318,6 +318,11 @@ int input_ff_create(struct input_dev *dev, unsigned int max_effects)
 		return -EINVAL;
 	}
 
+	if (max_effects > FF_MAX_EFFECTS) {
+		dev_err(&dev->dev, "cannot allocate more than FF_MAX_EFFECTS effects\n");
+		return -EINVAL;
+	}
+
 	ff_dev_size = sizeof(struct ff_device) +
 				max_effects * sizeof(struct file *);
 	if (ff_dev_size < max_effects) /* overflow */

commit 379d7cfa9bcae3b89299fdcb135ec0e2810e97bc
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Sep 29 16:02:29 2015 -0700

    Input: ff-core - silence an underflow warning
    
    My static checker complains that "value" comes from the user in
    evdev_do_ioctl() and we check that it's not too large here but we don't
    check that it's negative.  It's harmless because the ->set_gain() and
    ->set_autocenter() functions truncate it to a valid u16 value, but we
    may as well fix it just to make the static checker happy.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/ff-core.c b/drivers/input/ff-core.c
index c64208267198..eab56c0aacd5 100644
--- a/drivers/input/ff-core.c
+++ b/drivers/input/ff-core.c
@@ -273,14 +273,14 @@ int input_ff_event(struct input_dev *dev, unsigned int type,
 
 	switch (code) {
 	case FF_GAIN:
-		if (!test_bit(FF_GAIN, dev->ffbit) || value > 0xffff)
+		if (!test_bit(FF_GAIN, dev->ffbit) || value > 0xffffU)
 			break;
 
 		ff->set_gain(dev, value);
 		break;
 
 	case FF_AUTOCENTER:
-		if (!test_bit(FF_AUTOCENTER, dev->ffbit) || value > 0xffff)
+		if (!test_bit(FF_AUTOCENTER, dev->ffbit) || value > 0xffffU)
 			break;
 
 		ff->set_autocenter(dev, value);

commit 948cea14487af7d6e8b8007dc24a5361869f410b
Author: Anshul Garg <aksgarg1989@gmail.com>
Date:   Wed Jul 8 16:43:20 2015 -0700

    Input: ff-core - use for_each_set_bit where appropriate
    
    Use for_each_set_bit to check for set bits in bitmap
    as it is more efficient than checking individual bits.
    
    Signed-off-by: Anshul Garg <aksgarg1989@gmail.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/ff-core.c b/drivers/input/ff-core.c
index 8f4a30fccbb6..c64208267198 100644
--- a/drivers/input/ff-core.c
+++ b/drivers/input/ff-core.c
@@ -343,9 +343,8 @@ int input_ff_create(struct input_dev *dev, unsigned int max_effects)
 	__set_bit(EV_FF, dev->evbit);
 
 	/* Copy "true" bits into ff device bitmap */
-	for (i = 0; i <= FF_MAX; i++)
-		if (test_bit(i, dev->ffbit))
-			__set_bit(i, ff->ffbit);
+	for_each_set_bit(i, dev->ffbit, FF_CNT)
+		__set_bit(i, ff->ffbit);
 
 	/* we can emulate RUMBLE with periodic effects */
 	if (test_bit(FF_PERIODIC, ff->ffbit))

commit 4e3e4629e4c6ef755ce246e4d848eaad6eec7080
Author: Shailendra Verma <shailendra.capricorn@gmail.com>
Date:   Mon May 18 10:45:58 2015 -0700

    Input: ff-core - fix typo in comment to input_ff_erase()
    
    Signed-off-by: Shailendra Verma <shailendra.capricorn@gmail.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/ff-core.c b/drivers/input/ff-core.c
index 375d1ca14bd6..8f4a30fccbb6 100644
--- a/drivers/input/ff-core.c
+++ b/drivers/input/ff-core.c
@@ -213,7 +213,7 @@ static int erase_effect(struct input_dev *dev, int effect_id,
 /**
  * input_ff_erase - erase a force-feedback effect from device
  * @dev: input device to erase effect from
- * @effect_id: id of the ffect to be erased
+ * @effect_id: id of the effect to be erased
  * @file: purported owner of the request
  *
  * This function erases a force-feedback effect from specified device.

commit 8a4dda79a383ed9b09aa3af3ef74941bec2ee042
Author: Dan Murphy <dmurphy@ti.com>
Date:   Fri May 8 16:01:39 2015 -0700

    Input: ff-core - fix spelling mistake in ff-core
    
    Fix spelling of magnitude
    s/manginude/magnitude
    
    Signed-off-by: Dan Murphy <dmurphy@ti.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/ff-core.c b/drivers/input/ff-core.c
index b81c88c43452..375d1ca14bd6 100644
--- a/drivers/input/ff-core.c
+++ b/drivers/input/ff-core.c
@@ -70,7 +70,7 @@ static int compat_effect(struct ff_device *ff, struct ff_effect *effect)
 			return -EINVAL;
 
 		/*
-		 * calculate manginude of sine wave as average of rumble's
+		 * calculate magnitude of sine wave as average of rumble's
 		 * 2/3 of strong magnitude and 1/3 of weak magnitude
 		 */
 		magnitude = effect->u.rumble.strong_magnitude / 3 +

commit 2afebafdbdabd666f6ed3989bb5be21bd94b57bd
Author: Oliver Neukum <oneukum@suse.de>
Date:   Tue Apr 14 14:24:09 2015 -0700

    Input: ff-core - use new debug macros
    
    Replace old pr_* with dev_* debugging macros
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/ff-core.c b/drivers/input/ff-core.c
index f50f6dd92274..b81c88c43452 100644
--- a/drivers/input/ff-core.c
+++ b/drivers/input/ff-core.c
@@ -23,8 +23,6 @@
 
 /* #define DEBUG */
 
-#define pr_fmt(fmt) KBUILD_BASENAME ": " fmt
-
 #include <linux/input.h>
 #include <linux/module.h>
 #include <linux/mutex.h>
@@ -116,7 +114,7 @@ int input_ff_upload(struct input_dev *dev, struct ff_effect *effect,
 
 	if (effect->type < FF_EFFECT_MIN || effect->type > FF_EFFECT_MAX ||
 	    !test_bit(effect->type, dev->ffbit)) {
-		pr_debug("invalid or not supported effect type in upload\n");
+		dev_dbg(&dev->dev, "invalid or not supported effect type in upload\n");
 		return -EINVAL;
 	}
 
@@ -124,7 +122,7 @@ int input_ff_upload(struct input_dev *dev, struct ff_effect *effect,
 	    (effect->u.periodic.waveform < FF_WAVEFORM_MIN ||
 	     effect->u.periodic.waveform > FF_WAVEFORM_MAX ||
 	     !test_bit(effect->u.periodic.waveform, dev->ffbit))) {
-		pr_debug("invalid or not supported wave form in upload\n");
+		dev_dbg(&dev->dev, "invalid or not supported wave form in upload\n");
 		return -EINVAL;
 	}
 
@@ -246,7 +244,7 @@ static int flush_effects(struct input_dev *dev, struct file *file)
 	struct ff_device *ff = dev->ff;
 	int i;
 
-	pr_debug("flushing now\n");
+	dev_dbg(&dev->dev, "flushing now\n");
 
 	mutex_lock(&ff->mutex);
 
@@ -316,7 +314,7 @@ int input_ff_create(struct input_dev *dev, unsigned int max_effects)
 	int i;
 
 	if (!max_effects) {
-		pr_err("cannot allocate device without any effects\n");
+		dev_err(&dev->dev, "cannot allocate device without any effects\n");
 		return -EINVAL;
 	}
 

commit 41091ad0b8f843d36390058362c8f3c52a26a333
Author: Baodong Chen <chenbdchenbd@gmail.com>
Date:   Sun Jul 29 22:33:03 2012 -0700

    Input: random formatting fixes
    
    Fixes for some coding style issues reported by scripts/checkpatch.pl
    utility.
    
    Signed-off-by: Baodong Chen <chenbdchenbd@gmail.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/ff-core.c b/drivers/input/ff-core.c
index 480eb9d9876a..f50f6dd92274 100644
--- a/drivers/input/ff-core.c
+++ b/drivers/input/ff-core.c
@@ -138,8 +138,8 @@ int input_ff_upload(struct input_dev *dev, struct ff_effect *effect,
 
 	if (effect->id == -1) {
 		for (id = 0; id < ff->max_effects; id++)
-		     if (!ff->effect_owners[id])
-			break;
+			if (!ff->effect_owners[id])
+				break;
 
 		if (id >= ff->max_effects) {
 			ret = -ENOSPC;

commit 05be8b81aafd4f95106a91ff3fd8581fa984fad9
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Oct 12 21:05:53 2011 -0700

    Input: force feedback - potential integer wrap in input_ff_create()
    
    The problem here is that max_effects can wrap on 32 bits systems.
    We'd allocate a smaller amount of data than sizeof(struct ff_device).
    The call to kcalloc() on the next line would fail but it would write
    the NULL return outside of the memory we just allocated causing data
    corruption.
    
    The call path is that uinput_setup_device() get ->ff_effects_max from
    the user and sets the value in the ->private_data struct.  From there
    it is:
    -> uinput_ioctl_handler()
       -> uinput_create_device()
          -> input_ff_create(dev, udev->ff_effects_max);
    
    I've also changed ff_effects_max so it's an unsigned int instead of
    a signed int as a cleanup.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/ff-core.c b/drivers/input/ff-core.c
index 3367f760d75a..480eb9d9876a 100644
--- a/drivers/input/ff-core.c
+++ b/drivers/input/ff-core.c
@@ -309,9 +309,10 @@ EXPORT_SYMBOL_GPL(input_ff_event);
  * Once ff device is created you need to setup its upload, erase,
  * playback and other handlers before registering input device
  */
-int input_ff_create(struct input_dev *dev, int max_effects)
+int input_ff_create(struct input_dev *dev, unsigned int max_effects)
 {
 	struct ff_device *ff;
+	size_t ff_dev_size;
 	int i;
 
 	if (!max_effects) {
@@ -319,8 +320,12 @@ int input_ff_create(struct input_dev *dev, int max_effects)
 		return -EINVAL;
 	}
 
-	ff = kzalloc(sizeof(struct ff_device) +
-		     max_effects * sizeof(struct file *), GFP_KERNEL);
+	ff_dev_size = sizeof(struct ff_device) +
+				max_effects * sizeof(struct file *);
+	if (ff_dev_size < max_effects) /* overflow */
+		return -EINVAL;
+
+	ff = kzalloc(ff_dev_size, GFP_KERNEL);
 	if (!ff)
 		return -ENOMEM;
 

commit da0c490115de026618a7fdcd886602da44392a50
Author: Joe Perches <joe@perches.com>
Date:   Mon Nov 29 23:33:07 2010 -0800

    Input: use pr_fmt and pr_<level>
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/ff-core.c b/drivers/input/ff-core.c
index 03078c08309a..3367f760d75a 100644
--- a/drivers/input/ff-core.c
+++ b/drivers/input/ff-core.c
@@ -23,7 +23,7 @@
 
 /* #define DEBUG */
 
-#define debug(format, arg...) pr_debug("ff-core: " format "\n", ## arg)
+#define pr_fmt(fmt) KBUILD_BASENAME ": " fmt
 
 #include <linux/input.h>
 #include <linux/module.h>
@@ -116,7 +116,7 @@ int input_ff_upload(struct input_dev *dev, struct ff_effect *effect,
 
 	if (effect->type < FF_EFFECT_MIN || effect->type > FF_EFFECT_MAX ||
 	    !test_bit(effect->type, dev->ffbit)) {
-		debug("invalid or not supported effect type in upload");
+		pr_debug("invalid or not supported effect type in upload\n");
 		return -EINVAL;
 	}
 
@@ -124,7 +124,7 @@ int input_ff_upload(struct input_dev *dev, struct ff_effect *effect,
 	    (effect->u.periodic.waveform < FF_WAVEFORM_MIN ||
 	     effect->u.periodic.waveform > FF_WAVEFORM_MAX ||
 	     !test_bit(effect->u.periodic.waveform, dev->ffbit))) {
-		debug("invalid or not supported wave form in upload");
+		pr_debug("invalid or not supported wave form in upload\n");
 		return -EINVAL;
 	}
 
@@ -246,7 +246,7 @@ static int flush_effects(struct input_dev *dev, struct file *file)
 	struct ff_device *ff = dev->ff;
 	int i;
 
-	debug("flushing now");
+	pr_debug("flushing now\n");
 
 	mutex_lock(&ff->mutex);
 
@@ -315,8 +315,7 @@ int input_ff_create(struct input_dev *dev, int max_effects)
 	int i;
 
 	if (!max_effects) {
-		printk(KERN_ERR
-		       "ff-core: cannot allocate device without any effects\n");
+		pr_err("cannot allocate device without any effects\n");
 		return -EINVAL;
 	}
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/input/ff-core.c b/drivers/input/ff-core.c
index b2f07aa1604b..03078c08309a 100644
--- a/drivers/input/ff-core.c
+++ b/drivers/input/ff-core.c
@@ -29,6 +29,7 @@
 #include <linux/module.h>
 #include <linux/mutex.h>
 #include <linux/sched.h>
+#include <linux/slab.h>
 
 /*
  * Check that the effect_id is a valid effect and whether the user

commit 6a47081c37b7dd7810ce19e156c1a3bf11987e9a
Author: Jari Vanhala <ext-jari.vanhala@nokia.com>
Date:   Fri Dec 4 10:24:21 2009 -0800

    Input: fix memory leak in force feedback core
    
    Effects were allocated, but not freed anywhere.
    
    Signed-off-by: Jari Vanhala <ext-jari.vanhala@nokia.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/ff-core.c b/drivers/input/ff-core.c
index 572d0a712d2a..b2f07aa1604b 100644
--- a/drivers/input/ff-core.c
+++ b/drivers/input/ff-core.c
@@ -369,6 +369,7 @@ void input_ff_destroy(struct input_dev *dev)
 		if (ff->destroy)
 			ff->destroy(ff);
 		kfree(ff->private);
+		kfree(ff->effects);
 		kfree(ff);
 		dev->ff = NULL;
 	}

commit 467832032cc07626880363efa8625719c16c04eb
Merge: 66d2a5952eab 22763c5cf369
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Wed Dec 2 23:38:13 2009 -0800

    Merge commit 'v2.6.32' into next

commit 721a730eceb009ba61f8eeee31360c02ed8f6aba
Author: Roger Quadros <roger.quadros@nokia.com>
Date:   Mon Nov 23 08:30:18 2009 -0800

    Input: force feedback - fix function name in comment
    
    Function name is input_ff_destroy() and not input_ff_free()
    
    Signed-off-by: Roger Quadros <roger.quadros@nokia.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/ff-core.c b/drivers/input/ff-core.c
index 72c63e5dd630..3d7816ccfe75 100644
--- a/drivers/input/ff-core.c
+++ b/drivers/input/ff-core.c
@@ -353,7 +353,7 @@ int input_ff_create(struct input_dev *dev, int max_effects)
 EXPORT_SYMBOL_GPL(input_ff_create);
 
 /**
- * input_ff_free() - frees force feedback portion of input device
+ * input_ff_destroy() - frees force feedback portion of input device
  * @dev: input device supporting force feedback
  *
  * This function is only needed in error path as input core will

commit bf3204cbff7d2606e758afb0994e8da6ae1c6c26
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Nov 6 21:39:07 2009 -0800

    Input: fix locking in memoryless force-feedback devices
    
    Now that input core acquires dev->event_lock spinlock and disables
    interrupts when propagating input events, using spin_lock_bh() in
    ff-memless driver is not allowed. Actually, the timer_lock itself
    is not needed anymore, we should simply use dev->event_lock
    as well.
    
    Also do a small cleanup in force-feedback core.
    
    Reported-by: kerneloops.org
    Reported-by: http://www.kerneloops.org/searchweek.php?search=ml_ff_set_gain
    Reported-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/ff-core.c b/drivers/input/ff-core.c
index 72c63e5dd630..38df81fcdc3a 100644
--- a/drivers/input/ff-core.c
+++ b/drivers/input/ff-core.c
@@ -337,16 +337,16 @@ int input_ff_create(struct input_dev *dev, int max_effects)
 	dev->ff = ff;
 	dev->flush = flush_effects;
 	dev->event = input_ff_event;
-	set_bit(EV_FF, dev->evbit);
+	__set_bit(EV_FF, dev->evbit);
 
 	/* Copy "true" bits into ff device bitmap */
 	for (i = 0; i <= FF_MAX; i++)
 		if (test_bit(i, dev->ffbit))
-			set_bit(i, ff->ffbit);
+			__set_bit(i, ff->ffbit);
 
 	/* we can emulate RUMBLE with periodic effects */
 	if (test_bit(FF_PERIODIC, ff->ffbit))
-		set_bit(FF_RUMBLE, dev->ffbit);
+		__set_bit(FF_RUMBLE, dev->ffbit);
 
 	return 0;
 }
@@ -362,12 +362,14 @@ EXPORT_SYMBOL_GPL(input_ff_create);
  */
 void input_ff_destroy(struct input_dev *dev)
 {
-	clear_bit(EV_FF, dev->evbit);
-	if (dev->ff) {
-		if (dev->ff->destroy)
-			dev->ff->destroy(dev->ff);
-		kfree(dev->ff->private);
-		kfree(dev->ff);
+	struct ff_device *ff = dev->ff;
+
+	__clear_bit(EV_FF, dev->evbit);
+	if (ff) {
+		if (ff->destroy)
+			ff->destroy(ff);
+		kfree(ff->private);
+		kfree(ff);
 		dev->ff = NULL;
 	}
 }

commit 83680cdbcecd1fd284ad4df060d12bf214bb63a8
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue Jul 1 13:55:25 2008 +0200

    drivers/input/ff-core.c needs <linux/sched.h>
    
    Commit 656acd2bbc4ce7f224de499ee255698701396c48 ("Input: fix locking in
    force-feedback core") causes the following regression on m68k:
    
    | linux/drivers/input/ff-core.c: In function 'input_ff_upload':
    | linux/drivers/input/ff-core.c:172: error: dereferencing pointer to incomplete type
    | linux/drivers/input/ff-core.c: In function 'erase_effect':
    | linux/drivers/input/ff-core.c:197: error: dereferencing pointer to incomplete type
    | linux/drivers/input/ff-core.c:204: error: dereferencing pointer to incomplete type
    | make[4]: *** [drivers/input/ff-core.o] Error 1
    
    As the incomplete type is `struct task_struct', including <linux/sched.h> fixes
    it.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/input/ff-core.c b/drivers/input/ff-core.c
index 4c01464ec8f3..72c63e5dd630 100644
--- a/drivers/input/ff-core.c
+++ b/drivers/input/ff-core.c
@@ -28,6 +28,7 @@
 #include <linux/input.h>
 #include <linux/module.h>
 #include <linux/mutex.h>
+#include <linux/sched.h>
 
 /*
  * Check that the effect_id is a valid effect and whether the user

commit 656acd2bbc4ce7f224de499ee255698701396c48
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Thu Jun 26 11:30:02 2008 -0400

    Input: fix locking in force-feedback core
    
    The newly added event_lock spinlock in the input core disallows sleeping
    and therefore using mutexes in event handlers. Convert force-feedback
    core to rely on event_lock instead of mutex to protect slots allocated
    for fore-feedback effects. The original mutex is still used to serialize
    uploading and erasing of effects.
    
    Reported-by: Anssi Hannula <anssi.hannula@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/ff-core.c b/drivers/input/ff-core.c
index eebc72465fc9..4c01464ec8f3 100644
--- a/drivers/input/ff-core.c
+++ b/drivers/input/ff-core.c
@@ -166,8 +166,10 @@ int input_ff_upload(struct input_dev *dev, struct ff_effect *effect,
 	if (ret)
 		goto out;
 
+	spin_lock_irq(&dev->event_lock);
 	ff->effects[id] = *effect;
 	ff->effect_owners[id] = file;
+	spin_unlock_irq(&dev->event_lock);
 
  out:
 	mutex_unlock(&ff->mutex);
@@ -189,16 +191,22 @@ static int erase_effect(struct input_dev *dev, int effect_id,
 	if (error)
 		return error;
 
+	spin_lock_irq(&dev->event_lock);
 	ff->playback(dev, effect_id, 0);
+	ff->effect_owners[effect_id] = NULL;
+	spin_unlock_irq(&dev->event_lock);
 
 	if (ff->erase) {
 		error = ff->erase(dev, effect_id);
-		if (error)
+		if (error) {
+			spin_lock_irq(&dev->event_lock);
+			ff->effect_owners[effect_id] = file;
+			spin_unlock_irq(&dev->event_lock);
+
 			return error;
+		}
 	}
 
-	ff->effect_owners[effect_id] = NULL;
-
 	return 0;
 }
 
@@ -263,8 +271,6 @@ int input_ff_event(struct input_dev *dev, unsigned int type,
 	if (type != EV_FF)
 		return 0;
 
-	mutex_lock(&ff->mutex);
-
 	switch (code) {
 	case FF_GAIN:
 		if (!test_bit(FF_GAIN, dev->ffbit) || value > 0xffff)
@@ -286,7 +292,6 @@ int input_ff_event(struct input_dev *dev, unsigned int type,
 		break;
 	}
 
-	mutex_unlock(&ff->mutex);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(input_ff_event);

commit dec3eb01c2409ca8276c1152c167add66a37d1ba
Author: Dmitry Torokhov <dtor@insightbb.com>
Date:   Thu May 3 00:51:10 2007 -0400

    Input: force feedback - make sure effect is present before playing
    
    Make sure that requested effect id is not out of range for the
    device and that effect is present before requesting device to
    play it.
    
    Reported-by: Jan Kratochvil <honza@jikos.cz>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/ff-core.c b/drivers/input/ff-core.c
index 783b3412cead..eebc72465fc9 100644
--- a/drivers/input/ff-core.c
+++ b/drivers/input/ff-core.c
@@ -281,7 +281,8 @@ int input_ff_event(struct input_dev *dev, unsigned int type,
 		break;
 
 	default:
-		ff->playback(dev, code, value);
+		if (check_effect_access(ff, code, NULL) == 0)
+			ff->playback(dev, code, value);
 		break;
 	}
 

commit e4477d2d1bc3e6c76e83926f7fa8c8f94ba42615
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Fri Nov 24 00:43:09 2006 -0500

    Input: add to kernel-api docbook
    
    Add input subsystem to kernel-api docbook.
    Enhance some function and parameter comments.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/ff-core.c b/drivers/input/ff-core.c
index 35656cadc914..783b3412cead 100644
--- a/drivers/input/ff-core.c
+++ b/drivers/input/ff-core.c
@@ -203,7 +203,7 @@ static int erase_effect(struct input_dev *dev, int effect_id,
 }
 
 /**
- * input_ff_erase - erase an effect from device
+ * input_ff_erase - erase a force-feedback effect from device
  * @dev: input device to erase effect from
  * @effect_id: id of the ffect to be erased
  * @file: purported owner of the request
@@ -347,7 +347,7 @@ EXPORT_SYMBOL_GPL(input_ff_create);
 
 /**
  * input_ff_free() - frees force feedback portion of input device
- * @dev: input device supporintg force feedback
+ * @dev: input device supporting force feedback
  *
  * This function is only needed in error path as input core will
  * automatically free force feedback structures when device is

commit 509ca1a9383601fdc5612d3d3ba5b981f6eb6c8b
Author: Anssi Hannula <anssi.hannula@gmail.com>
Date:   Wed Jul 19 01:40:22 2006 -0400

    Input: implement new force feedback interface
    
    Implement a new force feedback interface, in which all non-driver-specific
    operations are separated to a common module. This includes handling effect
    type validations, locking, etc.
    
    The effects are now file descriptor specific instead of the previous strange
    half-process half-fd specific behaviour. The effect memory of devices is not
    emptied if the root user opens and closes the device while another user is
    using effects. This is a minor change and most likely no force feedback
    aware programs are affected by this negatively.
    
    Otherwise the userspace interface is left unaltered.
    
    Signed-off-by: Anssi Hannula <anssi.hannula@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/ff-core.c b/drivers/input/ff-core.c
new file mode 100644
index 000000000000..35656cadc914
--- /dev/null
+++ b/drivers/input/ff-core.c
@@ -0,0 +1,367 @@
+/*
+ *  Force feedback support for Linux input subsystem
+ *
+ *  Copyright (c) 2006 Anssi Hannula <anssi.hannula@gmail.com>
+ *  Copyright (c) 2006 Dmitry Torokhov <dtor@mail.ru>
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+/* #define DEBUG */
+
+#define debug(format, arg...) pr_debug("ff-core: " format "\n", ## arg)
+
+#include <linux/input.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+
+/*
+ * Check that the effect_id is a valid effect and whether the user
+ * is the owner
+ */
+static int check_effect_access(struct ff_device *ff, int effect_id,
+				struct file *file)
+{
+	if (effect_id < 0 || effect_id >= ff->max_effects ||
+	    !ff->effect_owners[effect_id])
+		return -EINVAL;
+
+	if (file && ff->effect_owners[effect_id] != file)
+		return -EACCES;
+
+	return 0;
+}
+
+/*
+ * Checks whether 2 effects can be combined together
+ */
+static inline int check_effects_compatible(struct ff_effect *e1,
+					   struct ff_effect *e2)
+{
+	return e1->type == e2->type &&
+	       (e1->type != FF_PERIODIC ||
+		e1->u.periodic.waveform == e2->u.periodic.waveform);
+}
+
+/*
+ * Convert an effect into compatible one
+ */
+static int compat_effect(struct ff_device *ff, struct ff_effect *effect)
+{
+	int magnitude;
+
+	switch (effect->type) {
+	case FF_RUMBLE:
+		if (!test_bit(FF_PERIODIC, ff->ffbit))
+			return -EINVAL;
+
+		/*
+		 * calculate manginude of sine wave as average of rumble's
+		 * 2/3 of strong magnitude and 1/3 of weak magnitude
+		 */
+		magnitude = effect->u.rumble.strong_magnitude / 3 +
+			    effect->u.rumble.weak_magnitude / 6;
+
+		effect->type = FF_PERIODIC;
+		effect->u.periodic.waveform = FF_SINE;
+		effect->u.periodic.period = 50;
+		effect->u.periodic.magnitude = max(magnitude, 0x7fff);
+		effect->u.periodic.offset = 0;
+		effect->u.periodic.phase = 0;
+		effect->u.periodic.envelope.attack_length = 0;
+		effect->u.periodic.envelope.attack_level = 0;
+		effect->u.periodic.envelope.fade_length = 0;
+		effect->u.periodic.envelope.fade_level = 0;
+
+		return 0;
+
+	default:
+		/* Let driver handle conversion */
+		return 0;
+	}
+}
+
+/**
+ * input_ff_upload() - upload effect into force-feedback device
+ * @dev: input device
+ * @effect: effect to be uploaded
+ * @file: owner of the effect
+ */
+int input_ff_upload(struct input_dev *dev, struct ff_effect *effect,
+		    struct file *file)
+{
+	struct ff_device *ff = dev->ff;
+	struct ff_effect *old;
+	int ret = 0;
+	int id;
+
+	if (!test_bit(EV_FF, dev->evbit))
+		return -ENOSYS;
+
+	if (effect->type < FF_EFFECT_MIN || effect->type > FF_EFFECT_MAX ||
+	    !test_bit(effect->type, dev->ffbit)) {
+		debug("invalid or not supported effect type in upload");
+		return -EINVAL;
+	}
+
+	if (effect->type == FF_PERIODIC &&
+	    (effect->u.periodic.waveform < FF_WAVEFORM_MIN ||
+	     effect->u.periodic.waveform > FF_WAVEFORM_MAX ||
+	     !test_bit(effect->u.periodic.waveform, dev->ffbit))) {
+		debug("invalid or not supported wave form in upload");
+		return -EINVAL;
+	}
+
+	if (!test_bit(effect->type, ff->ffbit)) {
+		ret = compat_effect(ff, effect);
+		if (ret)
+			return ret;
+	}
+
+	mutex_lock(&ff->mutex);
+
+	if (effect->id == -1) {
+		for (id = 0; id < ff->max_effects; id++)
+		     if (!ff->effect_owners[id])
+			break;
+
+		if (id >= ff->max_effects) {
+			ret = -ENOSPC;
+			goto out;
+		}
+
+		effect->id = id;
+		old = NULL;
+
+	} else {
+		id = effect->id;
+
+		ret = check_effect_access(ff, id, file);
+		if (ret)
+			goto out;
+
+		old = &ff->effects[id];
+
+		if (!check_effects_compatible(effect, old)) {
+			ret = -EINVAL;
+			goto out;
+		}
+	}
+
+	ret = ff->upload(dev, effect, old);
+	if (ret)
+		goto out;
+
+	ff->effects[id] = *effect;
+	ff->effect_owners[id] = file;
+
+ out:
+	mutex_unlock(&ff->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(input_ff_upload);
+
+/*
+ * Erases the effect if the requester is also the effect owner. The mutex
+ * should already be locked before calling this function.
+ */
+static int erase_effect(struct input_dev *dev, int effect_id,
+			struct file *file)
+{
+	struct ff_device *ff = dev->ff;
+	int error;
+
+	error = check_effect_access(ff, effect_id, file);
+	if (error)
+		return error;
+
+	ff->playback(dev, effect_id, 0);
+
+	if (ff->erase) {
+		error = ff->erase(dev, effect_id);
+		if (error)
+			return error;
+	}
+
+	ff->effect_owners[effect_id] = NULL;
+
+	return 0;
+}
+
+/**
+ * input_ff_erase - erase an effect from device
+ * @dev: input device to erase effect from
+ * @effect_id: id of the ffect to be erased
+ * @file: purported owner of the request
+ *
+ * This function erases a force-feedback effect from specified device.
+ * The effect will only be erased if it was uploaded through the same
+ * file handle that is requesting erase.
+ */
+int input_ff_erase(struct input_dev *dev, int effect_id, struct file *file)
+{
+	struct ff_device *ff = dev->ff;
+	int ret;
+
+	if (!test_bit(EV_FF, dev->evbit))
+		return -ENOSYS;
+
+	mutex_lock(&ff->mutex);
+	ret = erase_effect(dev, effect_id, file);
+	mutex_unlock(&ff->mutex);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(input_ff_erase);
+
+/*
+ * flush_effects - erase all effects owned by a file handle
+ */
+static int flush_effects(struct input_dev *dev, struct file *file)
+{
+	struct ff_device *ff = dev->ff;
+	int i;
+
+	debug("flushing now");
+
+	mutex_lock(&ff->mutex);
+
+	for (i = 0; i < ff->max_effects; i++)
+		erase_effect(dev, i, file);
+
+	mutex_unlock(&ff->mutex);
+
+	return 0;
+}
+
+/**
+ * input_ff_event() - generic handler for force-feedback events
+ * @dev: input device to send the effect to
+ * @type: event type (anything but EV_FF is ignored)
+ * @code: event code
+ * @value: event value
+ */
+int input_ff_event(struct input_dev *dev, unsigned int type,
+		   unsigned int code, int value)
+{
+	struct ff_device *ff = dev->ff;
+
+	if (type != EV_FF)
+		return 0;
+
+	mutex_lock(&ff->mutex);
+
+	switch (code) {
+	case FF_GAIN:
+		if (!test_bit(FF_GAIN, dev->ffbit) || value > 0xffff)
+			break;
+
+		ff->set_gain(dev, value);
+		break;
+
+	case FF_AUTOCENTER:
+		if (!test_bit(FF_AUTOCENTER, dev->ffbit) || value > 0xffff)
+			break;
+
+		ff->set_autocenter(dev, value);
+		break;
+
+	default:
+		ff->playback(dev, code, value);
+		break;
+	}
+
+	mutex_unlock(&ff->mutex);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(input_ff_event);
+
+/**
+ * input_ff_create() - create force-feedback device
+ * @dev: input device supporting force-feedback
+ * @max_effects: maximum number of effects supported by the device
+ *
+ * This function allocates all necessary memory for a force feedback
+ * portion of an input device and installs all default handlers.
+ * @dev->ffbit should be already set up before calling this function.
+ * Once ff device is created you need to setup its upload, erase,
+ * playback and other handlers before registering input device
+ */
+int input_ff_create(struct input_dev *dev, int max_effects)
+{
+	struct ff_device *ff;
+	int i;
+
+	if (!max_effects) {
+		printk(KERN_ERR
+		       "ff-core: cannot allocate device without any effects\n");
+		return -EINVAL;
+	}
+
+	ff = kzalloc(sizeof(struct ff_device) +
+		     max_effects * sizeof(struct file *), GFP_KERNEL);
+	if (!ff)
+		return -ENOMEM;
+
+	ff->effects = kcalloc(max_effects, sizeof(struct ff_effect),
+			      GFP_KERNEL);
+	if (!ff->effects) {
+		kfree(ff);
+		return -ENOMEM;
+	}
+
+	ff->max_effects = max_effects;
+	mutex_init(&ff->mutex);
+
+	dev->ff = ff;
+	dev->flush = flush_effects;
+	dev->event = input_ff_event;
+	set_bit(EV_FF, dev->evbit);
+
+	/* Copy "true" bits into ff device bitmap */
+	for (i = 0; i <= FF_MAX; i++)
+		if (test_bit(i, dev->ffbit))
+			set_bit(i, ff->ffbit);
+
+	/* we can emulate RUMBLE with periodic effects */
+	if (test_bit(FF_PERIODIC, ff->ffbit))
+		set_bit(FF_RUMBLE, dev->ffbit);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(input_ff_create);
+
+/**
+ * input_ff_free() - frees force feedback portion of input device
+ * @dev: input device supporintg force feedback
+ *
+ * This function is only needed in error path as input core will
+ * automatically free force feedback structures when device is
+ * destroyed.
+ */
+void input_ff_destroy(struct input_dev *dev)
+{
+	clear_bit(EV_FF, dev->evbit);
+	if (dev->ff) {
+		if (dev->ff->destroy)
+			dev->ff->destroy(dev->ff);
+		kfree(dev->ff->private);
+		kfree(dev->ff);
+		dev->ff = NULL;
+	}
+}
+EXPORT_SYMBOL_GPL(input_ff_destroy);
