commit 0bec8b7e5ca1a629f26173691526432f9d7cf8c1
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Wed Aug 14 10:46:38 2019 -0700

    Input: remove dev_err() usage after platform_get_irq()
    
    We don't need dev_err() messages when platform_get_irq() fails now that
    platform_get_irq() prints an error message itself when something goes
    wrong. Let's remove these prints with a simple semantic patch.
    
    // <smpl>
    @@
    expression ret;
    struct platform_device *E;
    @@
    
    ret =
    (
    platform_get_irq(E, ...)
    |
    platform_get_irq_byname(E, ...)
    );
    
    if ( \( ret < 0 \| ret <= 0 \) )
    {
    (
    -if (ret != -EPROBE_DEFER)
    -{ ...
    -dev_err(...);
    -... }
    |
    ...
    -dev_err(...);
    )
    ...
    }
    // </smpl>
    
    While we're here, remove braces on if statements that only have one
    statement (manually).
    
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 39023664d2f2..7e65708b25a4 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -727,10 +727,8 @@ static int pxa27x_keypad_probe(struct platform_device *pdev)
 		return -EINVAL;
 
 	irq = platform_get_irq(pdev, 0);
-	if (irq < 0) {
-		dev_err(&pdev->dev, "failed to get keypad irq\n");
+	if (irq < 0)
 		return -ENXIO;
-	}
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (res == NULL) {

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index d0bdaeadf86d..39023664d2f2 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * linux/drivers/input/keyboard/pxa27x_keypad.c
  *
@@ -9,10 +10,6 @@
  * Based on a previous implementations by Kevin O'Connor
  * <kevin_at_koconnor.net> and Alex Osborne <bobofdoom@gmail.com> and
  * on some suggestions by Nicolas Pitre <nico@fluxnic.net>.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 

commit 117b2dc58c07924da7f545f93a1f5862f46e14f7
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Thu Aug 31 11:39:13 2017 -0700

    Input: pxa27x_keypad - handle return value of clk_prepare_enable
    
    clk_prepare_enable() can fail here and we must check its return value.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 3841fa30db33..d0bdaeadf86d 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -644,9 +644,12 @@ static void pxa27x_keypad_config(struct pxa27x_keypad *keypad)
 static int pxa27x_keypad_open(struct input_dev *dev)
 {
 	struct pxa27x_keypad *keypad = input_get_drvdata(dev);
-
+	int ret;
 	/* Enable unit clock */
-	clk_prepare_enable(keypad->clk);
+	ret = clk_prepare_enable(keypad->clk);
+	if (ret)
+		return ret;
+
 	pxa27x_keypad_config(keypad);
 
 	return 0;
@@ -683,6 +686,7 @@ static int pxa27x_keypad_resume(struct device *dev)
 	struct platform_device *pdev = to_platform_device(dev);
 	struct pxa27x_keypad *keypad = platform_get_drvdata(pdev);
 	struct input_dev *input_dev = keypad->input_dev;
+	int ret = 0;
 
 	/*
 	 * If the keypad is used as wake up source, the clock is not turned
@@ -695,14 +699,15 @@ static int pxa27x_keypad_resume(struct device *dev)
 
 		if (input_dev->users) {
 			/* Enable unit clock */
-			clk_prepare_enable(keypad->clk);
-			pxa27x_keypad_config(keypad);
+			ret = clk_prepare_enable(keypad->clk);
+			if (!ret)
+				pxa27x_keypad_config(keypad);
 		}
 
 		mutex_unlock(&input_dev->mutex);
 	}
 
-	return 0;
+	return ret;
 }
 #endif
 

commit aef01aad89e457e34a60ff6e8fd69ff6740cf201
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Nov 11 12:43:12 2016 -0800

    Input: matrix-keypad - switch to using generic device properties
    
    Instead of being OF-specific, let's switch to using generic device
    properties, which will make this code usable on ACPI, device tree and
    legacy boards that use property sets.
    
    As part of the change let's rename matrix_keypad_parse_of_params() to
    matrix_keypad_parse_properties().
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index e24443376e75..3841fa30db33 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -126,7 +126,7 @@ static int pxa27x_keypad_matrix_key_parse_dt(struct pxa27x_keypad *keypad,
 	u32 rows, cols;
 	int error;
 
-	error = matrix_keypad_parse_of_params(dev, &rows, &cols);
+	error = matrix_keypad_parse_properties(dev, &rows, &cols);
 	if (error)
 		return error;
 

commit 6d86c4714da526243d7b0578eaf5e1b54f8c2ed2
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue Oct 25 09:35:40 2016 -0700

    Input: pxa27x_keypad - fix typo "debpunce" -> "debounce"
    
    Trivial fix to typo in dev_err message
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index fcef5d1365e2..e24443376e75 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -316,7 +316,7 @@ static int pxa27x_keypad_build_keycode_from_dt(struct pxa27x_keypad *keypad)
 	error = of_property_read_u32(np, "marvell,debounce-interval",
 				     &pdata->debounce_interval);
 	if (error) {
-		dev_err(dev, "failed to parse debpunce-interval\n");
+		dev_err(dev, "failed to parse debounce-interval\n");
 		return error;
 	}
 

commit 2b2f514705fa00df1bc01d68fe9decbb7d59fcc6
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Feb 11 09:34:03 2015 -0800

    Input: pxa27x_keypad - remove an unneeded NULL check
    
    Static checkers complain about this NULL check because we dereference it
    without checking a couple lines later.  This function is only called
    when "keypad->pdata" is non-NULL so we can just delete the NULL test.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    [Dmitry: remove the variable altogether given that it is used just once and
     dereference directly.]
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index a89488aa1aa4..fcef5d1365e2 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -345,13 +345,11 @@ static int pxa27x_keypad_build_keycode(struct pxa27x_keypad *keypad)
 {
 	const struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
 	struct input_dev *input_dev = keypad->input_dev;
-	const struct matrix_keymap_data *keymap_data =
-				pdata ? pdata->matrix_keymap_data : NULL;
 	unsigned short keycode;
 	int i;
 	int error;
 
-	error = matrix_keypad_build_keymap(keymap_data, NULL,
+	error = matrix_keypad_build_keymap(pdata->matrix_keymap_data, NULL,
 					   pdata->matrix_key_rows,
 					   pdata->matrix_key_cols,
 					   keypad->keycodes, input_dev);

commit d05426779b96767f0c306cbeb8bb77d7e70eb36e
Author: Rob Herring <robh@kernel.org>
Date:   Tue Feb 3 15:12:38 2015 -0800

    Input: pxa27x_keypad - remove unnecessary ARM includes
    
    Remove some left-over ARM only includes in order to enable building on
    ARM64. __raw_{read,write}l were getting implicitly included, so add
    linux/io.h include.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index a90d6bdc499e..a89488aa1aa4 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -20,6 +20,7 @@
 #include <linux/module.h>
 #include <linux/interrupt.h>
 #include <linux/input.h>
+#include <linux/io.h>
 #include <linux/device.h>
 #include <linux/platform_device.h>
 #include <linux/clk.h>
@@ -28,10 +29,6 @@
 #include <linux/slab.h>
 #include <linux/of.h>
 
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-
-#include <mach/hardware.h>
 #include <linux/platform_data/keypad-pxa27x.h>
 /*
  * Keypad Controller registers

commit d797da41b2aceed5daa8cd2eee92cd74b2a0c652
Merge: d6666be6f0c4 f20c86cd75f1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 17 10:06:02 2014 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input
    
    Pull input subsystem updates from Dmitry Torokhov:
     "Two new drivers for Elan hardware (for I2C touchpad and touchscreen
      found in several Chromebooks and other devices), a driver for Goodix
      touch panel, and small fixes to Cypress I2C trackpad and other input
      drivers.
    
      Also we switched to use __maybe_unused instead of gating suspend/
      resume code with #ifdef guards to get better compile coverage"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input: (27 commits)
      Input: gpio_keys - fix warning regarding uninitialized 'button' variable
      Input: add support for Elan eKTH I2C touchscreens
      Input: gpio_keys - fix warning regarding uninitialized  'irq' variable
      Input: cyapa - use 'error' for error codes
      Input: cyapa - fix resuming the device
      Input: gpio_keys - add device tree support for interrupt only keys
      Input: amikbd - allocate temporary keymap buffer on the stack
      Input: amikbd - fix build if !CONFIG_HW_CONSOLE
      Input: lm8323 - missing error check in lm8323_set_disable()
      Input: initialize device counter variables with -1
      Input: initialize input_no to -1 to avoid subtraction
      Input: i8042 - do not try to load on Intel NUC D54250WYK
      Input: atkbd - correct MSC_SCAN events for force_release keys
      Input: cyapa - switch to using managed resources
      Input: lifebook - use "static inline" instead of "inline" in lifebook.h
      Input: touchscreen - use __maybe_unused instead of ifdef around suspend/resume
      Input: mouse - use __maybe_unused instead of ifdef around suspend/resume
      Input: misc - use __maybe_unused instead of ifdef around suspend/resume
      Input: cap11xx - support for irq-active-high option
      Input: cap11xx - add support for various cap11xx devices
      ...

commit 38c3807252085f97e1359400c8bf1312da3168c6
Author: Pramod Gurav <pramod.gurav@smartplayin.com>
Date:   Wed Oct 8 11:19:43 2014 -0700

    Input: pxa27x_keypad - switch to using managed resources
    
    This change switches ithe driver to use devm_* APIs to allocate resources.
    This helps to simplify failure path in probe function and module unloading
    and does away with remove function.
    
    Signed-off-by: Pramod Gurav <pramod.gurav@smartplayin.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index a15063bea700..e08fc0ae913d 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -741,37 +741,27 @@ static int pxa27x_keypad_probe(struct platform_device *pdev)
 		return -ENXIO;
 	}
 
-	keypad = kzalloc(sizeof(struct pxa27x_keypad), GFP_KERNEL);
-	input_dev = input_allocate_device();
-	if (!keypad || !input_dev) {
-		dev_err(&pdev->dev, "failed to allocate memory\n");
-		error = -ENOMEM;
-		goto failed_free;
-	}
+	keypad = devm_kzalloc(&pdev->dev, sizeof(*keypad),
+			      GFP_KERNEL);
+	if (!keypad)
+		return -ENOMEM;
+
+	input_dev = devm_input_allocate_device(&pdev->dev);
+	if (!input_dev)
+		return -ENOMEM;
 
 	keypad->pdata = pdata;
 	keypad->input_dev = input_dev;
 	keypad->irq = irq;
 
-	res = request_mem_region(res->start, resource_size(res), pdev->name);
-	if (res == NULL) {
-		dev_err(&pdev->dev, "failed to request I/O memory\n");
-		error = -EBUSY;
-		goto failed_free;
-	}
-
-	keypad->mmio_base = ioremap(res->start, resource_size(res));
-	if (keypad->mmio_base == NULL) {
-		dev_err(&pdev->dev, "failed to remap I/O memory\n");
-		error = -ENXIO;
-		goto failed_free_mem;
-	}
+	keypad->mmio_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(keypad->mmio_base))
+		return PTR_ERR(keypad->mmio_base);
 
-	keypad->clk = clk_get(&pdev->dev, NULL);
+	keypad->clk = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(keypad->clk)) {
 		dev_err(&pdev->dev, "failed to get keypad clock\n");
-		error = PTR_ERR(keypad->clk);
-		goto failed_free_io;
+		return PTR_ERR(keypad->clk);
 	}
 
 	input_dev->name = pdev->name;
@@ -802,7 +792,7 @@ static int pxa27x_keypad_probe(struct platform_device *pdev)
 	}
 	if (error) {
 		dev_err(&pdev->dev, "failed to build keycode\n");
-		goto failed_put_clk;
+		return error;
 	}
 
 	keypad->row_shift = get_count_order(pdata->matrix_key_cols);
@@ -812,61 +802,26 @@ static int pxa27x_keypad_probe(struct platform_device *pdev)
 		input_dev->evbit[0] |= BIT_MASK(EV_REL);
 	}
 
-	error = request_irq(irq, pxa27x_keypad_irq_handler, 0,
-			    pdev->name, keypad);
+	error = devm_request_irq(&pdev->dev, irq, pxa27x_keypad_irq_handler,
+				 0, pdev->name, keypad);
 	if (error) {
 		dev_err(&pdev->dev, "failed to request IRQ\n");
-		goto failed_put_clk;
+		return error;
 	}
 
 	/* Register the input device */
 	error = input_register_device(input_dev);
 	if (error) {
 		dev_err(&pdev->dev, "failed to register input device\n");
-		goto failed_free_irq;
+		return error;
 	}
 
 	platform_set_drvdata(pdev, keypad);
 	device_init_wakeup(&pdev->dev, 1);
 
 	return 0;
-
-failed_free_irq:
-	free_irq(irq, keypad);
-failed_put_clk:
-	clk_put(keypad->clk);
-failed_free_io:
-	iounmap(keypad->mmio_base);
-failed_free_mem:
-	release_mem_region(res->start, resource_size(res));
-failed_free:
-	input_free_device(input_dev);
-	kfree(keypad);
-	return error;
 }
 
-static int pxa27x_keypad_remove(struct platform_device *pdev)
-{
-	struct pxa27x_keypad *keypad = platform_get_drvdata(pdev);
-	struct resource *res;
-
-	free_irq(keypad->irq, keypad);
-	clk_put(keypad->clk);
-
-	input_unregister_device(keypad->input_dev);
-	iounmap(keypad->mmio_base);
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	release_mem_region(res->start, resource_size(res));
-
-	kfree(keypad);
-
-	return 0;
-}
-
-/* work with hotplug and coldplug */
-MODULE_ALIAS("platform:pxa27x-keypad");
-
 #ifdef CONFIG_OF
 static const struct of_device_id pxa27x_keypad_dt_match[] = {
 	{ .compatible = "marvell,pxa27x-keypad" },
@@ -877,7 +832,6 @@ MODULE_DEVICE_TABLE(of, pxa27x_keypad_dt_match);
 
 static struct platform_driver pxa27x_keypad_driver = {
 	.probe		= pxa27x_keypad_probe,
-	.remove		= pxa27x_keypad_remove,
 	.driver		= {
 		.name	= "pxa27x-keypad",
 		.of_match_table = of_match_ptr(pxa27x_keypad_dt_match),
@@ -889,3 +843,5 @@ module_platform_driver(pxa27x_keypad_driver);
 
 MODULE_DESCRIPTION("PXA27x Keypad Controller Driver");
 MODULE_LICENSE("GPL");
+/* work with hotplug and coldplug */
+MODULE_ALIAS("platform:pxa27x-keypad");

commit 1d05726c315c146b2ac0c5e94f01fde0c2b73dc1
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:20:39 2014 +0200

    input: keyboard: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index a15063bea700..6ab3e7c96329 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -881,7 +881,6 @@ static struct platform_driver pxa27x_keypad_driver = {
 	.driver		= {
 		.name	= "pxa27x-keypad",
 		.of_match_table = of_match_ptr(pxa27x_keypad_dt_match),
-		.owner	= THIS_MODULE,
 		.pm	= &pxa27x_keypad_pm_ops,
 	},
 };

commit c5ec1948eaab7c1c0f412b2804e65a637f1c7443
Author: Chao Xie <chao.xie@marvell.com>
Date:   Mon May 12 19:20:48 2014 -0700

    Input: pxa27x-keypad - fix generating scancode
    
    The number of columns of pxa27x-keypad used by various boards is not fixed.
    When building keymap with call to:
    
    matrix_keypad_build_keymap(keymap_data, NULL,
                               pdata->matrix_key_rows,
                               pdata->matrix_key_cols,
                               keypad->keycodes, input_dev);
    
    it will internally calculate needed row shift and use it to fill the
    keymap. Therefore when calculating the "scancode" we should no longer use
    constant row shift but also calculate it from number of columns.
    
    Signed-off-by: Chao Xie <chao.xie@marvell.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index d8241ba0afa0..a15063bea700 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -111,6 +111,8 @@ struct pxa27x_keypad {
 	unsigned short keycodes[MAX_KEYPAD_KEYS];
 	int rotary_rel_code[2];
 
+	unsigned int row_shift;
+
 	/* state row bits of each column scan */
 	uint32_t matrix_key_state[MAX_MATRIX_KEY_COLS];
 	uint32_t direct_key_state;
@@ -467,7 +469,8 @@ static void pxa27x_keypad_scan_matrix(struct pxa27x_keypad *keypad)
 			if ((bits_changed & (1 << row)) == 0)
 				continue;
 
-			code = MATRIX_SCAN_CODE(row, col, MATRIX_ROW_SHIFT);
+			code = MATRIX_SCAN_CODE(row, col, keypad->row_shift);
+
 			input_event(input_dev, EV_MSC, MSC_SCAN, code);
 			input_report_key(input_dev, keypad->keycodes[code],
 					 new_state[col] & (1 << row));
@@ -802,6 +805,8 @@ static int pxa27x_keypad_probe(struct platform_device *pdev)
 		goto failed_put_clk;
 	}
 
+	keypad->row_shift = get_count_order(pdata->matrix_key_cols);
+
 	if ((pdata->enable_rotary0 && keypad->rotary_rel_code[0] != -1) ||
 	    (pdata->enable_rotary1 && keypad->rotary_rel_code[1] != -1)) {
 		input_dev->evbit[0] |= BIT_MASK(EV_REL);

commit bf9a9f8e5105b13cea954b254008f383ed0b4045
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jan 6 10:27:05 2014 -0800

    Input: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 186138c720c7..d8241ba0afa0 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -18,7 +18,6 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/input.h>
 #include <linux/device.h>

commit 42249094f79422fbf5ed4b54eeb48ff096809b8f
Merge: 936816161978 2c027b7c48a8
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Thu Nov 14 17:38:05 2013 -0800

    Merge branch 'next' into for-linus
    
    Merge first round of changes for 3.13 merge window.

commit 95ba7407e29292eda2ca211845347ad2ccff2842
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Sun Oct 6 00:55:51 2013 -0700

    Input: pxa27x_keypad - include linux/of.h header
    
    'of_match_ptr' is defined in linux/of.h. Include it explicitly.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 134c3b404a54..5446ad4e4aeb 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -27,6 +27,7 @@
 #include <linux/err.h>
 #include <linux/input/matrix_keypad.h>
 #include <linux/slab.h>
+#include <linux/of.h>
 
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>

commit 049d75f72d9b1cce0f5ca66ea324f0b5318046eb
Author: Mike Dunn <mikedunn@newsguy.com>
Date:   Wed Sep 18 08:07:41 2013 -0700

    Input: pxa27x_keypad - fix NULL pointer dereference
    
    A NULL pointer dereference exception occurs in the driver probe function when
    device tree is used.  The pdata pointer will be NULL in this case, but the code
    dereferences it in all cases.  When device tree is used, a platform data
    structure is allocated and initialized, and in all cases this pointer is copied
    to the driver's private data, so the variable being tested should be accessed
    through the driver's private data structure.
    
    Signed-off-by: Mike Dunn <mikedunn@newsguy.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 134c3b404a54..a2e758d27584 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -786,10 +786,17 @@ static int pxa27x_keypad_probe(struct platform_device *pdev)
 	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);
 	input_set_capability(input_dev, EV_MSC, MSC_SCAN);
 
-	if (pdata)
+	if (pdata) {
 		error = pxa27x_keypad_build_keycode(keypad);
-	else
+	} else {
 		error = pxa27x_keypad_build_keycode_from_dt(keypad);
+		/*
+		 * Data that we get from DT resides in dynamically
+		 * allocated memory so we need to update our pdata
+		 * pointer.
+		 */
+		pdata = keypad->pdata;
+	}
 	if (error) {
 		dev_err(&pdev->dev, "failed to build keycode\n");
 		goto failed_put_clk;

commit 9eb521394ea9a50feaf8a9c70b689e4b86ff1b93
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Mon Jun 10 22:16:29 2013 -0700

    Input: pxa27x-keypad - make platform data const
    
    It should not be changed by the driver, so let's make it const pointer.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index aa17cf269aa8..134c3b404a54 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -100,7 +100,7 @@
 #define MAX_KEYPAD_KEYS		(MAX_MATRIX_KEY_NUM + MAX_DIRECT_KEY_NUM)
 
 struct pxa27x_keypad {
-	struct pxa27x_keypad_platform_data *pdata;
+	const struct pxa27x_keypad_platform_data *pdata;
 
 	struct clk *clk;
 	struct input_dev *input_dev;
@@ -119,11 +119,11 @@ struct pxa27x_keypad {
 };
 
 #ifdef CONFIG_OF
-static int pxa27x_keypad_matrix_key_parse_dt(struct pxa27x_keypad *keypad)
+static int pxa27x_keypad_matrix_key_parse_dt(struct pxa27x_keypad *keypad,
+				struct pxa27x_keypad_platform_data *pdata)
 {
 	struct input_dev *input_dev = keypad->input_dev;
 	struct device *dev = input_dev->dev.parent;
-	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
 	u32 rows, cols;
 	int error;
 
@@ -149,11 +149,11 @@ static int pxa27x_keypad_matrix_key_parse_dt(struct pxa27x_keypad *keypad)
 	return 0;
 }
 
-static int pxa27x_keypad_direct_key_parse_dt(struct pxa27x_keypad *keypad)
+static int pxa27x_keypad_direct_key_parse_dt(struct pxa27x_keypad *keypad,
+				struct pxa27x_keypad_platform_data *pdata)
 {
 	struct input_dev *input_dev = keypad->input_dev;
 	struct device *dev = input_dev->dev.parent;
-	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
 	struct device_node *np = dev->of_node;
 	const __be16 *prop;
 	unsigned short code;
@@ -209,7 +209,8 @@ static int pxa27x_keypad_direct_key_parse_dt(struct pxa27x_keypad *keypad)
 	return 0;
 }
 
-static int pxa27x_keypad_rotary_parse_dt(struct pxa27x_keypad *keypad)
+static int pxa27x_keypad_rotary_parse_dt(struct pxa27x_keypad *keypad,
+				struct pxa27x_keypad_platform_data *pdata)
 {
 	const __be32 *prop;
 	int i, relkey_ret;
@@ -219,7 +220,6 @@ static int pxa27x_keypad_rotary_parse_dt(struct pxa27x_keypad *keypad)
 	const char relkeyname[] = {"marvell,rotary-rel-key"};
 	struct input_dev *input_dev = keypad->input_dev;
 	struct device *dev = input_dev->dev.parent;
-	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
 	struct device_node *np = dev->of_node;
 
 	relkey_ret = of_property_read_u32(np, relkeyname, &code);
@@ -287,35 +287,35 @@ static int pxa27x_keypad_build_keycode_from_dt(struct pxa27x_keypad *keypad)
 	struct input_dev *input_dev = keypad->input_dev;
 	struct device *dev = input_dev->dev.parent;
 	struct device_node *np = dev->of_node;
+	struct pxa27x_keypad_platform_data *pdata;
 	int error;
 
-	keypad->pdata = devm_kzalloc(dev, sizeof(*keypad->pdata),
-				     GFP_KERNEL);
-	if (!keypad->pdata) {
+	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata) {
 		dev_err(dev, "failed to allocate memory for pdata\n");
 		return -ENOMEM;
 	}
 
-	error = pxa27x_keypad_matrix_key_parse_dt(keypad);
+	error = pxa27x_keypad_matrix_key_parse_dt(keypad, pdata);
 	if (error) {
 		dev_err(dev, "failed to parse matrix key\n");
 		return error;
 	}
 
-	error = pxa27x_keypad_direct_key_parse_dt(keypad);
+	error = pxa27x_keypad_direct_key_parse_dt(keypad, pdata);
 	if (error) {
 		dev_err(dev, "failed to parse direct key\n");
 		return error;
 	}
 
-	error = pxa27x_keypad_rotary_parse_dt(keypad);
+	error = pxa27x_keypad_rotary_parse_dt(keypad, pdata);
 	if (error) {
 		dev_err(dev, "failed to parse rotary key\n");
 		return error;
 	}
 
 	error = of_property_read_u32(np, "marvell,debounce-interval",
-				    &keypad->pdata->debounce_interval);
+				     &pdata->debounce_interval);
 	if (error) {
 		dev_err(dev, "failed to parse debpunce-interval\n");
 		return error;
@@ -327,6 +327,7 @@ static int pxa27x_keypad_build_keycode_from_dt(struct pxa27x_keypad *keypad)
 	 */
 	input_dev->keycodemax = ARRAY_SIZE(keypad->keycodes);
 
+	keypad->pdata = pdata;
 	return 0;
 }
 
@@ -343,7 +344,7 @@ static int pxa27x_keypad_build_keycode_from_dt(struct pxa27x_keypad *keypad)
 
 static int pxa27x_keypad_build_keycode(struct pxa27x_keypad *keypad)
 {
-	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
+	const struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
 	struct input_dev *input_dev = keypad->input_dev;
 	const struct matrix_keymap_data *keymap_data =
 				pdata ? pdata->matrix_keymap_data : NULL;
@@ -412,7 +413,7 @@ static int pxa27x_keypad_build_keycode(struct pxa27x_keypad *keypad)
 
 static void pxa27x_keypad_scan_matrix(struct pxa27x_keypad *keypad)
 {
-	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
+	const struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
 	struct input_dev *input_dev = keypad->input_dev;
 	int row, col, num_keys_pressed = 0;
 	uint32_t new_state[MAX_MATRIX_KEY_COLS];
@@ -514,7 +515,7 @@ static void report_rotary_event(struct pxa27x_keypad *keypad, int r, int delta)
 
 static void pxa27x_keypad_scan_rotary(struct pxa27x_keypad *keypad)
 {
-	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
+	const struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
 	uint32_t kprec;
 
 	/* read and reset to default count value */
@@ -530,7 +531,7 @@ static void pxa27x_keypad_scan_rotary(struct pxa27x_keypad *keypad)
 
 static void pxa27x_keypad_scan_direct(struct pxa27x_keypad *keypad)
 {
-	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
+	const struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
 	struct input_dev *input_dev = keypad->input_dev;
 	unsigned int new_state;
 	uint32_t kpdk, bits_changed;
@@ -570,7 +571,7 @@ static void pxa27x_keypad_scan_direct(struct pxa27x_keypad *keypad)
 
 static void clear_wakeup_event(struct pxa27x_keypad *keypad)
 {
-	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
+	const struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
 
 	if (pdata->clear_wakeup_event)
 		(pdata->clear_wakeup_event)();
@@ -594,7 +595,7 @@ static irqreturn_t pxa27x_keypad_irq_handler(int irq, void *dev_id)
 
 static void pxa27x_keypad_config(struct pxa27x_keypad *keypad)
 {
-	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
+	const struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
 	unsigned int mask = 0, direct_key_num = 0;
 	unsigned long kpc = 0;
 
@@ -713,7 +714,8 @@ static SIMPLE_DEV_PM_OPS(pxa27x_keypad_pm_ops,
 
 static int pxa27x_keypad_probe(struct platform_device *pdev)
 {
-	struct pxa27x_keypad_platform_data *pdata = pdev->dev.platform_data;
+	const struct pxa27x_keypad_platform_data *pdata =
+					dev_get_platdata(&pdev->dev);
 	struct device_node *np = pdev->dev.of_node;
 	struct pxa27x_keypad *keypad;
 	struct input_dev *input_dev;
@@ -793,9 +795,6 @@ static int pxa27x_keypad_probe(struct platform_device *pdev)
 		goto failed_put_clk;
 	}
 
-	/* If device tree is supported, pdata will be allocated. */
-	pdata = keypad->pdata;
-
 	if ((pdata->enable_rotary0 && keypad->rotary_rel_code[0] != -1) ||
 	    (pdata->enable_rotary1 && keypad->rotary_rel_code[1] != -1)) {
 		input_dev->evbit[0] |= BIT_MASK(EV_REL);

commit f9f6def88ace892f9f90f639664f0e203bafdb22
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Mon Jun 10 22:10:07 2013 -0700

    Input: pxa27x-keypad - convert to using SIMPLE_DEV_PM_OPS
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 533fd6c7c3c8..aa17cf269aa8 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -661,7 +661,7 @@ static void pxa27x_keypad_close(struct input_dev *dev)
 	clk_disable_unprepare(keypad->clk);
 }
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 static int pxa27x_keypad_suspend(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
@@ -705,13 +705,12 @@ static int pxa27x_keypad_resume(struct device *dev)
 
 	return 0;
 }
-
-static const struct dev_pm_ops pxa27x_keypad_pm_ops = {
-	.suspend	= pxa27x_keypad_suspend,
-	.resume		= pxa27x_keypad_resume,
-};
 #endif
 
+static SIMPLE_DEV_PM_OPS(pxa27x_keypad_pm_ops,
+			 pxa27x_keypad_suspend, pxa27x_keypad_resume);
+
+
 static int pxa27x_keypad_probe(struct platform_device *pdev)
 {
 	struct pxa27x_keypad_platform_data *pdata = pdev->dev.platform_data;
@@ -872,9 +871,7 @@ static struct platform_driver pxa27x_keypad_driver = {
 		.name	= "pxa27x-keypad",
 		.of_match_table = of_match_ptr(pxa27x_keypad_dt_match),
 		.owner	= THIS_MODULE,
-#ifdef CONFIG_PM
 		.pm	= &pxa27x_keypad_pm_ops,
-#endif
 	},
 };
 module_platform_driver(pxa27x_keypad_driver);

commit e4156979c7d34e5197b16fa31c1c7549eae675e5
Author: Chao Xie <chao.xie@marvell.com>
Date:   Sun May 5 20:25:10 2013 -0700

    Input: pxa27x-keypad - add device tree support
    
    Signed-off-by: Chao Xie <chao.xie@marvell.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 5b2d8764dd37..533fd6c7c3c8 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -118,6 +118,229 @@ struct pxa27x_keypad {
 	unsigned int direct_key_mask;
 };
 
+#ifdef CONFIG_OF
+static int pxa27x_keypad_matrix_key_parse_dt(struct pxa27x_keypad *keypad)
+{
+	struct input_dev *input_dev = keypad->input_dev;
+	struct device *dev = input_dev->dev.parent;
+	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
+	u32 rows, cols;
+	int error;
+
+	error = matrix_keypad_parse_of_params(dev, &rows, &cols);
+	if (error)
+		return error;
+
+	if (rows > MAX_MATRIX_KEY_ROWS || cols > MAX_MATRIX_KEY_COLS) {
+		dev_err(dev, "rows or cols exceeds maximum value\n");
+		return -EINVAL;
+	}
+
+	pdata->matrix_key_rows = rows;
+	pdata->matrix_key_cols = cols;
+
+	error = matrix_keypad_build_keymap(NULL, NULL,
+					   pdata->matrix_key_rows,
+					   pdata->matrix_key_cols,
+					   keypad->keycodes, input_dev);
+	if (error)
+		return error;
+
+	return 0;
+}
+
+static int pxa27x_keypad_direct_key_parse_dt(struct pxa27x_keypad *keypad)
+{
+	struct input_dev *input_dev = keypad->input_dev;
+	struct device *dev = input_dev->dev.parent;
+	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
+	struct device_node *np = dev->of_node;
+	const __be16 *prop;
+	unsigned short code;
+	unsigned int proplen, size;
+	int i;
+	int error;
+
+	error = of_property_read_u32(np, "marvell,direct-key-count",
+				     &pdata->direct_key_num);
+	if (error) {
+		/*
+		 * If do not have marvel,direct-key-count defined,
+		 * it means direct key is not supported.
+		 */
+		return error == -EINVAL ? 0 : error;
+	}
+
+	error = of_property_read_u32(np, "marvell,direct-key-mask",
+				     &pdata->direct_key_mask);
+	if (error) {
+		if (error != -EINVAL)
+			return error;
+
+		/*
+		 * If marvell,direct-key-mask is not defined, driver will use
+		 * default value. Default value is set when configure the keypad.
+		 */
+		pdata->direct_key_mask = 0;
+	}
+
+	pdata->direct_key_low_active = of_property_read_bool(np,
+					"marvell,direct-key-low-active");
+
+	prop = of_get_property(np, "marvell,direct-key-map", &proplen);
+	if (!prop)
+		return -EINVAL;
+
+	if (proplen % sizeof(u16))
+		return -EINVAL;
+
+	size = proplen / sizeof(u16);
+
+	/* Only MAX_DIRECT_KEY_NUM is accepted.*/
+	if (size > MAX_DIRECT_KEY_NUM)
+		return -EINVAL;
+
+	for (i = 0; i < size; i++) {
+		code = be16_to_cpup(prop + i);
+		keypad->keycodes[MAX_MATRIX_KEY_NUM + i] = code;
+		__set_bit(code, input_dev->keybit);
+	}
+
+	return 0;
+}
+
+static int pxa27x_keypad_rotary_parse_dt(struct pxa27x_keypad *keypad)
+{
+	const __be32 *prop;
+	int i, relkey_ret;
+	unsigned int code, proplen;
+	const char *rotaryname[2] = {
+			"marvell,rotary0", "marvell,rotary1"};
+	const char relkeyname[] = {"marvell,rotary-rel-key"};
+	struct input_dev *input_dev = keypad->input_dev;
+	struct device *dev = input_dev->dev.parent;
+	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
+	struct device_node *np = dev->of_node;
+
+	relkey_ret = of_property_read_u32(np, relkeyname, &code);
+	/* if can read correct rotary key-code, we do not need this. */
+	if (relkey_ret == 0) {
+		unsigned short relcode;
+
+		/* rotary0 taks lower half, rotary1 taks upper half. */
+		relcode = code & 0xffff;
+		pdata->rotary0_rel_code = (code & 0xffff);
+		__set_bit(relcode, input_dev->relbit);
+
+		relcode = code >> 16;
+		pdata->rotary1_rel_code = relcode;
+		__set_bit(relcode, input_dev->relbit);
+	}
+
+	for (i = 0; i < 2; i++) {
+		prop = of_get_property(np, rotaryname[i], &proplen);
+		/*
+		 * If the prop is not set, it means keypad does not need
+		 * initialize the rotaryX.
+		 */
+		if (!prop)
+			continue;
+
+		code = be32_to_cpup(prop);
+		/*
+		 * Not all up/down key code are valid.
+		 * Now we depends on direct-rel-code.
+		 */
+		if ((!(code & 0xffff) || !(code >> 16)) && relkey_ret) {
+			return relkey_ret;
+		} else {
+			unsigned int n = MAX_MATRIX_KEY_NUM + (i << 1);
+			unsigned short keycode;
+
+			keycode = code & 0xffff;
+			keypad->keycodes[n] = keycode;
+			__set_bit(keycode, input_dev->keybit);
+
+			keycode = code >> 16;
+			keypad->keycodes[n + 1] = keycode;
+			__set_bit(keycode, input_dev->keybit);
+
+			if (i == 0)
+				pdata->rotary0_rel_code = -1;
+			else
+				pdata->rotary1_rel_code = -1;
+		}
+		if (i == 0)
+			pdata->enable_rotary0 = 1;
+		else
+			pdata->enable_rotary1 = 1;
+	}
+
+	keypad->rotary_rel_code[0] = pdata->rotary0_rel_code;
+	keypad->rotary_rel_code[1] = pdata->rotary1_rel_code;
+
+	return 0;
+}
+
+static int pxa27x_keypad_build_keycode_from_dt(struct pxa27x_keypad *keypad)
+{
+	struct input_dev *input_dev = keypad->input_dev;
+	struct device *dev = input_dev->dev.parent;
+	struct device_node *np = dev->of_node;
+	int error;
+
+	keypad->pdata = devm_kzalloc(dev, sizeof(*keypad->pdata),
+				     GFP_KERNEL);
+	if (!keypad->pdata) {
+		dev_err(dev, "failed to allocate memory for pdata\n");
+		return -ENOMEM;
+	}
+
+	error = pxa27x_keypad_matrix_key_parse_dt(keypad);
+	if (error) {
+		dev_err(dev, "failed to parse matrix key\n");
+		return error;
+	}
+
+	error = pxa27x_keypad_direct_key_parse_dt(keypad);
+	if (error) {
+		dev_err(dev, "failed to parse direct key\n");
+		return error;
+	}
+
+	error = pxa27x_keypad_rotary_parse_dt(keypad);
+	if (error) {
+		dev_err(dev, "failed to parse rotary key\n");
+		return error;
+	}
+
+	error = of_property_read_u32(np, "marvell,debounce-interval",
+				    &keypad->pdata->debounce_interval);
+	if (error) {
+		dev_err(dev, "failed to parse debpunce-interval\n");
+		return error;
+	}
+
+	/*
+	 * The keycodes may not only includes matrix key but also the direct
+	 * key or rotary key.
+	 */
+	input_dev->keycodemax = ARRAY_SIZE(keypad->keycodes);
+
+	return 0;
+}
+
+#else
+
+static int pxa27x_keypad_build_keycode_from_dt(struct pxa27x_keypad *keypad)
+{
+	dev_info(keypad->input_dev->dev.parent, "missing platform data\n");
+
+	return -EINVAL;
+}
+
+#endif
+
 static int pxa27x_keypad_build_keycode(struct pxa27x_keypad *keypad)
 {
 	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
@@ -492,15 +715,15 @@ static const struct dev_pm_ops pxa27x_keypad_pm_ops = {
 static int pxa27x_keypad_probe(struct platform_device *pdev)
 {
 	struct pxa27x_keypad_platform_data *pdata = pdev->dev.platform_data;
+	struct device_node *np = pdev->dev.of_node;
 	struct pxa27x_keypad *keypad;
 	struct input_dev *input_dev;
 	struct resource *res;
 	int irq, error;
 
-	if (pdata == NULL) {
-		dev_err(&pdev->dev, "no platform data defined\n");
+	/* Driver need build keycode from device tree or pdata */
+	if (!np && !pdata)
 		return -EINVAL;
-	}
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0) {
@@ -562,12 +785,18 @@ static int pxa27x_keypad_probe(struct platform_device *pdev)
 	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);
 	input_set_capability(input_dev, EV_MSC, MSC_SCAN);
 
-	error = pxa27x_keypad_build_keycode(keypad);
+	if (pdata)
+		error = pxa27x_keypad_build_keycode(keypad);
+	else
+		error = pxa27x_keypad_build_keycode_from_dt(keypad);
 	if (error) {
 		dev_err(&pdev->dev, "failed to build keycode\n");
 		goto failed_put_clk;
 	}
 
+	/* If device tree is supported, pdata will be allocated. */
+	pdata = keypad->pdata;
+
 	if ((pdata->enable_rotary0 && keypad->rotary_rel_code[0] != -1) ||
 	    (pdata->enable_rotary1 && keypad->rotary_rel_code[1] != -1)) {
 		input_dev->evbit[0] |= BIT_MASK(EV_REL);
@@ -628,11 +857,20 @@ static int pxa27x_keypad_remove(struct platform_device *pdev)
 /* work with hotplug and coldplug */
 MODULE_ALIAS("platform:pxa27x-keypad");
 
+#ifdef CONFIG_OF
+static const struct of_device_id pxa27x_keypad_dt_match[] = {
+	{ .compatible = "marvell,pxa27x-keypad" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, pxa27x_keypad_dt_match);
+#endif
+
 static struct platform_driver pxa27x_keypad_driver = {
 	.probe		= pxa27x_keypad_probe,
 	.remove		= pxa27x_keypad_remove,
 	.driver		= {
 		.name	= "pxa27x-keypad",
+		.of_match_table = of_match_ptr(pxa27x_keypad_dt_match),
 		.owner	= THIS_MODULE,
 #ifdef CONFIG_PM
 		.pm	= &pxa27x_keypad_pm_ops,

commit 0a085a9482fa51efb58c9d351ea98e83c5df93fc
Author: Chao Xie <chao.xie@marvell.com>
Date:   Sun May 5 20:24:58 2013 -0700

    Input: pxa27x-keypad - use matrix_keymap for matrix keys
    
    pxa27x-keypad includes matrix keys. Make use of matrix_keymap
    for the matrix keys.
    
    Signed-off-by: Chao Xie <chao.xie@marvell.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index b674e7aca404..5b2d8764dd37 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -118,25 +118,30 @@ struct pxa27x_keypad {
 	unsigned int direct_key_mask;
 };
 
-static void pxa27x_keypad_build_keycode(struct pxa27x_keypad *keypad)
+static int pxa27x_keypad_build_keycode(struct pxa27x_keypad *keypad)
 {
 	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
 	struct input_dev *input_dev = keypad->input_dev;
+	const struct matrix_keymap_data *keymap_data =
+				pdata ? pdata->matrix_keymap_data : NULL;
 	unsigned short keycode;
 	int i;
+	int error;
 
-	for (i = 0; i < pdata->matrix_key_map_size; i++) {
-		unsigned int key = pdata->matrix_key_map[i];
-		unsigned int row = KEY_ROW(key);
-		unsigned int col = KEY_COL(key);
-		unsigned int scancode = MATRIX_SCAN_CODE(row, col,
-							 MATRIX_ROW_SHIFT);
+	error = matrix_keypad_build_keymap(keymap_data, NULL,
+					   pdata->matrix_key_rows,
+					   pdata->matrix_key_cols,
+					   keypad->keycodes, input_dev);
+	if (error)
+		return error;
 
-		keycode = KEY_VAL(key);
-		keypad->keycodes[scancode] = keycode;
-		__set_bit(keycode, input_dev->keybit);
-	}
+	/*
+	 * The keycodes may not only include matrix keys but also the direct
+	 * or rotary keys.
+	 */
+	input_dev->keycodemax = ARRAY_SIZE(keypad->keycodes);
 
+	/* For direct keys. */
 	for (i = 0; i < pdata->direct_key_num; i++) {
 		keycode = pdata->direct_key_map[i];
 		keypad->keycodes[MAX_MATRIX_KEY_NUM + i] = keycode;
@@ -178,6 +183,8 @@ static void pxa27x_keypad_build_keycode(struct pxa27x_keypad *keypad)
 	}
 
 	__clear_bit(KEY_RESERVED, input_dev->keybit);
+
+	return 0;
 }
 
 static void pxa27x_keypad_scan_matrix(struct pxa27x_keypad *keypad)
@@ -555,7 +562,11 @@ static int pxa27x_keypad_probe(struct platform_device *pdev)
 	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);
 	input_set_capability(input_dev, EV_MSC, MSC_SCAN);
 
-	pxa27x_keypad_build_keycode(keypad);
+	error = pxa27x_keypad_build_keycode(keypad);
+	if (error) {
+		dev_err(&pdev->dev, "failed to build keycode\n");
+		goto failed_put_clk;
+	}
 
 	if ((pdata->enable_rotary0 && keypad->rotary_rel_code[0] != -1) ||
 	    (pdata->enable_rotary1 && keypad->rotary_rel_code[1] != -1)) {

commit 8c7f5f5833815af06872bd6151604e0e18e24c99
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu May 23 09:30:04 2013 -0700

    Input: pxa27x_keypad - pass correct pointer to free_irq()
    
    free_irq() expects the same pointer that was passed to request_irq(),
    otherwise the IRQ is not freed.
    
    The issue was found using the following coccinelle script:
    
    <smpl>
    @r1@
    type T;
    T devid;
    @@
    request_irq(..., devid)
    
    @r2@
    type r1.T;
    T devid;
    position p;
    @@
    free_irq@p(..., devid)
    
    @@
    position p != r2.p;
    @@
    *free_irq@p(...)
    </smpl>
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 74e30cccbeab..b674e7aca404 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -582,7 +582,7 @@ static int pxa27x_keypad_probe(struct platform_device *pdev)
 	return 0;
 
 failed_free_irq:
-	free_irq(irq, pdev);
+	free_irq(irq, keypad);
 failed_put_clk:
 	clk_put(keypad->clk);
 failed_free_io:
@@ -600,7 +600,7 @@ static int pxa27x_keypad_remove(struct platform_device *pdev)
 	struct pxa27x_keypad *keypad = platform_get_drvdata(pdev);
 	struct resource *res;
 
-	free_irq(keypad->irq, pdev);
+	free_irq(keypad->irq, keypad);
 	clk_put(keypad->clk);
 
 	input_unregister_device(keypad->input_dev);

commit c8712a53671aef12a8b6b3ec4e942ef4f92bc17e
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Mon May 6 07:35:41 2013 -0700

    Input: pxa27x_keypad - remove redundant platform_set_drvdata()
    
    Commit 0998d06310 (device-core: Ensure drvdata = NULL when no
    driver is bound) removes the need to set driver data field to
    NULL.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 5330d8fbf6c0..74e30cccbeab 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -609,7 +609,6 @@ static int pxa27x_keypad_remove(struct platform_device *pdev)
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	release_mem_region(res->start, resource_size(res));
 
-	platform_set_drvdata(pdev, NULL);
 	kfree(keypad);
 
 	return 0;

commit e2619cf78e19476bfd7ceaefa9eff0847529346e
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Nov 23 21:50:47 2012 -0800

    Input: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 91778fee8b99..5330d8fbf6c0 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -595,7 +595,7 @@ static int pxa27x_keypad_probe(struct platform_device *pdev)
 	return error;
 }
 
-static int __devexit pxa27x_keypad_remove(struct platform_device *pdev)
+static int pxa27x_keypad_remove(struct platform_device *pdev)
 {
 	struct pxa27x_keypad *keypad = platform_get_drvdata(pdev);
 	struct resource *res;

commit 5298cc4cc753bbe4c530b41341834f6ef3344d0d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Nov 23 21:38:25 2012 -0800

    Input: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Javier Martinez Canillas <javier@dowhile0.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index a6bcd3129f0f..91778fee8b99 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -482,7 +482,7 @@ static const struct dev_pm_ops pxa27x_keypad_pm_ops = {
 };
 #endif
 
-static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
+static int pxa27x_keypad_probe(struct platform_device *pdev)
 {
 	struct pxa27x_keypad_platform_data *pdata = pdev->dev.platform_data;
 	struct pxa27x_keypad *keypad;

commit 1cb0aa88179b7a71c240529e9d781d7bbb43d2e8
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Nov 23 21:27:39 2012 -0800

    Input: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index cad9d5dd5973..a6bcd3129f0f 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -620,7 +620,7 @@ MODULE_ALIAS("platform:pxa27x-keypad");
 
 static struct platform_driver pxa27x_keypad_driver = {
 	.probe		= pxa27x_keypad_probe,
-	.remove		= __devexit_p(pxa27x_keypad_remove),
+	.remove		= pxa27x_keypad_remove,
 	.driver		= {
 		.name	= "pxa27x-keypad",
 		.owner	= THIS_MODULE,

commit 904adede088f2a6976e417d1d5cf72c9fe686814
Author: Vasily Khoruzhick <anarsoul@gmail.com>
Date:   Mon Oct 29 23:45:09 2012 -0700

    Input: pxa27x_keypad - clear pending interrupts on keypad config
    
    Bootloader can leave interrupt bit pending, and it confuses driver.
    
    Signed-off-by: Vasily Khoruzhick <anarsoul@gmail.com>
    Acked-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 803ff6fe021e..cad9d5dd5973 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -368,6 +368,9 @@ static void pxa27x_keypad_config(struct pxa27x_keypad *keypad)
 	unsigned int mask = 0, direct_key_num = 0;
 	unsigned long kpc = 0;
 
+	/* clear pending interrupt bit */
+	keypad_readl(KPC);
+
 	/* enable matrix keys with automatic scan */
 	if (pdata->matrix_key_rows && pdata->matrix_key_cols) {
 		kpc |= KPC_ASACT | KPC_MIE | KPC_ME | KPC_MS_ALL;

commit 293b2da1b61136813fc2764f43304c66ff8040e9
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Aug 24 15:16:48 2012 +0200

    ARM: pxa: move platform_data definitions
    
    Platform data for device drivers should be defined in
    include/linux/platform_data/*.h, not in the architecture
    and platform specific directories.
    
    This moves such data out of the pxa include directories
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Acked-by: Igor Grinberg <grinberg@compulab.co.il>
    Acked-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: Marek Vasut <marex@denx.de>
    Acked-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Acked-by: Paul Parsons <lost.distance@yahoo.com>
    Acked-by: Vinod Koul <vinod.koul@linux.intel.com>
    Acked-By: Stefan Schmidt <stefan@openezx.org>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Haojian Zhuang <haojian.zhuang@gmail.com>
    Cc: Daniel Ribeiro <drwyrm@gmail.com>
    Cc: Harald Welte <laforge@openezx.org>
    Cc: Philipp Zabel <philipp.zabel@gmail.com>
    Cc: Tomas Cech <sleep_walker@suse.cz>
    Cc: Sergey Lapin <slapin@ossfans.org>
    Cc: Jonathan Cameron <jic23@cam.ac.uk>
    Cc: Dan Williams <djbw@fb.com>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Chris Ball <cjb@laptop.org>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Samuel Ortiz <samuel@sortiz.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Florian Tobias Schandinat <FlorianSchandinat@gmx.de>
    Cc: Liam Girdwood <lrg@ti.com>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Cc: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Cc: openezx-devel@lists.openezx.org

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 7f7b72464a37..803ff6fe021e 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -32,7 +32,7 @@
 #include <asm/mach/map.h>
 
 #include <mach/hardware.h>
-#include <plat/pxa27x_keypad.h>
+#include <linux/platform_data/keypad-pxa27x.h>
 /*
  * Keypad Controller registers
  */

commit fb054bf26914ee4c55cf149bc5b2a8e2c89fb81f
Author: Chao Xie <chao.xie@marvell.com>
Date:   Sun Apr 1 10:08:04 2012 +0800

    Input: pxa27x_keypad add choice to set direct_key_mask
    
    Direct keys usage may not start from KP_DKIN0, add a msk option
    to configure the specifics for platforms that can skip some keys.
    
    Signed-off-by: Chao Xie <chao.xie@marvell.com>
    Signed-off-by: Haojian Zhuang <haojian.zhuang@gmail.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index a60f14e7983e..7f7b72464a37 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -391,7 +391,14 @@ static void pxa27x_keypad_config(struct pxa27x_keypad *keypad)
 	if (pdata->direct_key_num > direct_key_num)
 		direct_key_num = pdata->direct_key_num;
 
-	keypad->direct_key_mask = ((1 << direct_key_num) - 1) & ~mask;
+	/*
+	 * Direct keys usage may not start from KP_DKIN0, check the platfrom
+	 * mask data to config the specific.
+	 */
+	if (pdata->direct_key_mask)
+		keypad->direct_key_mask = pdata->direct_key_mask;
+	else
+		keypad->direct_key_mask = ((1 << direct_key_num) - 1) & ~mask;
 
 	/* enable direct key */
 	if (direct_key_num)

commit ee1d8040a6b0a8106c7d9e80b9193077224493ba
Author: Chao Xie <chao.xie@marvell.com>
Date:   Sun Apr 1 10:08:03 2012 +0800

    Input: pxa27x_keypad direct key may be low active
    
    KPDK_DK only indicates the pin level of direct key.
    So it is related to board, and low level may be active which
    indicates that a key is pressed.
    
    Signed-off-by: Chao Xie <chao.xie@marvell.com>
    Signed-off-by: Haojian Zhuang <haojian.zhuang@gmail.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 5d717202aad8..a60f14e7983e 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -311,7 +311,15 @@ static void pxa27x_keypad_scan_direct(struct pxa27x_keypad *keypad)
 	if (pdata->enable_rotary0 || pdata->enable_rotary1)
 		pxa27x_keypad_scan_rotary(keypad);
 
-	new_state = KPDK_DK(kpdk) & keypad->direct_key_mask;
+	/*
+	 * The KPDR_DK only output the key pin level, so it relates to board,
+	 * and low level may be active.
+	 */
+	if (pdata->direct_key_low_active)
+		new_state = ~KPDK_DK(kpdk) & keypad->direct_key_mask;
+	else
+		new_state = KPDK_DK(kpdk) & keypad->direct_key_mask;
+
 	bits_changed = keypad->direct_key_state ^ new_state;
 
 	if (bits_changed == 0)

commit 5545fa897a0a1a34249e98ea4244b256cbe58df3
Author: Chao Xie <chao.xie@marvell.com>
Date:   Sun Apr 1 10:08:02 2012 +0800

    Input: pxa27x_keypad bug fix for direct_key_mask
    
    When direcct_key_num is 0, the mask should be 0.
    When direcct_key_num is 1, the mask should be 0b1.
    
    Signed-off-by: Chao Xie <chao.xie@marvell.com>
    Signed-off-by: Haojian Zhuang <haojian.zhuang@gmail.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index b07771e83063..5d717202aad8 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -383,7 +383,7 @@ static void pxa27x_keypad_config(struct pxa27x_keypad *keypad)
 	if (pdata->direct_key_num > direct_key_num)
 		direct_key_num = pdata->direct_key_num;
 
-	keypad->direct_key_mask = ((2 << direct_key_num) - 1) & ~mask;
+	keypad->direct_key_mask = ((1 << direct_key_num) - 1) & ~mask;
 
 	/* enable direct key */
 	if (direct_key_num)

commit 6ce34a5fb4955fac1eebe080e1c2784bc8710449
Author: Chao Xie <chao.xie@marvell.com>
Date:   Sun Apr 1 10:08:01 2012 +0800

    Input: pxa27x_keypad keep clock on as wakeup source
    
    When the keypad is used as wake up source, the clock can not
    be disabled. Or it can not detect key pressing.
    If the keypad is used as wake up source, when resume back,
    do not enable the clock and configure it again because the
    register content is retained.
    
    Signed-off-by: Chao Xie <chao.xie@marvell.com>
    Signed-off-by: Haojian Zhuang <haojian.zhuang@gmail.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 29fe1b2be1c1..b07771e83063 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -399,7 +399,7 @@ static int pxa27x_keypad_open(struct input_dev *dev)
 	struct pxa27x_keypad *keypad = input_get_drvdata(dev);
 
 	/* Enable unit clock */
-	clk_enable(keypad->clk);
+	clk_prepare_enable(keypad->clk);
 	pxa27x_keypad_config(keypad);
 
 	return 0;
@@ -410,7 +410,7 @@ static void pxa27x_keypad_close(struct input_dev *dev)
 	struct pxa27x_keypad *keypad = input_get_drvdata(dev);
 
 	/* Disable clock unit */
-	clk_disable(keypad->clk);
+	clk_disable_unprepare(keypad->clk);
 }
 
 #ifdef CONFIG_PM
@@ -419,10 +419,14 @@ static int pxa27x_keypad_suspend(struct device *dev)
 	struct platform_device *pdev = to_platform_device(dev);
 	struct pxa27x_keypad *keypad = platform_get_drvdata(pdev);
 
-	clk_disable(keypad->clk);
-
+	/*
+	 * If the keypad is used a wake up source, clock can not be disabled.
+	 * Or it can not detect the key pressing.
+	 */
 	if (device_may_wakeup(&pdev->dev))
 		enable_irq_wake(keypad->irq);
+	else
+		clk_disable_unprepare(keypad->clk);
 
 	return 0;
 }
@@ -433,19 +437,24 @@ static int pxa27x_keypad_resume(struct device *dev)
 	struct pxa27x_keypad *keypad = platform_get_drvdata(pdev);
 	struct input_dev *input_dev = keypad->input_dev;
 
-	if (device_may_wakeup(&pdev->dev))
+	/*
+	 * If the keypad is used as wake up source, the clock is not turned
+	 * off. So do not need configure it again.
+	 */
+	if (device_may_wakeup(&pdev->dev)) {
 		disable_irq_wake(keypad->irq);
+	} else {
+		mutex_lock(&input_dev->mutex);
 
-	mutex_lock(&input_dev->mutex);
+		if (input_dev->users) {
+			/* Enable unit clock */
+			clk_prepare_enable(keypad->clk);
+			pxa27x_keypad_config(keypad);
+		}
 
-	if (input_dev->users) {
-		/* Enable unit clock */
-		clk_enable(keypad->clk);
-		pxa27x_keypad_config(keypad);
+		mutex_unlock(&input_dev->mutex);
 	}
 
-	mutex_unlock(&input_dev->mutex);
-
 	return 0;
 }
 

commit 5146c84f87c8aa3d115cea0d77ed3553df426752
Author: JJ Ding <dgdunix@gmail.com>
Date:   Tue Nov 29 11:08:39 2011 -0800

    Input: keyboard - use macro module_platform_driver()
    
    Commit 940ab88962bc1aff3273a8356d64577a6e386736 introduced a new macro to
    save some platform_driver boilerplate code. Use it.
    
    Signed-off-by: JJ Ding <dgdunix@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index eca6ae63de14..29fe1b2be1c1 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -602,19 +602,7 @@ static struct platform_driver pxa27x_keypad_driver = {
 #endif
 	},
 };
-
-static int __init pxa27x_keypad_init(void)
-{
-	return platform_driver_register(&pxa27x_keypad_driver);
-}
-
-static void __exit pxa27x_keypad_exit(void)
-{
-	platform_driver_unregister(&pxa27x_keypad_driver);
-}
-
-module_init(pxa27x_keypad_init);
-module_exit(pxa27x_keypad_exit);
+module_platform_driver(pxa27x_keypad_driver);
 
 MODULE_DESCRIPTION("PXA27x Keypad Controller Driver");
 MODULE_LICENSE("GPL");

commit ec4665c46b11f6e444911ba73dddae6044dec909
Author: Yong Zhang <yong.zhang0@gmail.com>
Date:   Wed Sep 7 14:04:16 2011 -0700

    Input: remove IRQF_DISABLED from drivers
    
    This flag is a NOOP and can be removed now.
    
    Signed-off-by: Yong Zhang <yong.zhang0@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 4b0ec35259a1..eca6ae63de14 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -535,7 +535,7 @@ static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
 		input_dev->evbit[0] |= BIT_MASK(EV_REL);
 	}
 
-	error = request_irq(irq, pxa27x_keypad_irq_handler, IRQF_DISABLED,
+	error = request_irq(irq, pxa27x_keypad_irq_handler, 0,
 			    pdev->name, keypad);
 	if (error) {
 		dev_err(&pdev->dev, "failed to request IRQ\n");

commit 3587c258078479824342f33dc513ca7c66d729bc
Author: Mark F. Brown <mark.brown314@gmail.com>
Date:   Fri Sep 3 18:28:09 2010 -0400

    ARM: pxa27x_keypad: added wakeup event handler for keypad interrupts
    
    mach-mmp needs to clear wake event in order to clear the keypad interrupt
    
    Signed-off-by: Mark F. Brown <mark.brown314@gmail.com>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 731bd88bb076..4b0ec35259a1 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -330,11 +330,21 @@ static void pxa27x_keypad_scan_direct(struct pxa27x_keypad *keypad)
 	keypad->direct_key_state = new_state;
 }
 
+static void clear_wakeup_event(struct pxa27x_keypad *keypad)
+{
+	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
+
+	if (pdata->clear_wakeup_event)
+		(pdata->clear_wakeup_event)();
+}
+
 static irqreturn_t pxa27x_keypad_irq_handler(int irq, void *dev_id)
 {
 	struct pxa27x_keypad *keypad = dev_id;
 	unsigned long kpc = keypad_readl(KPC);
 
+	clear_wakeup_event(keypad);
+
 	if (kpc & KPC_DI)
 		pxa27x_keypad_scan_direct(keypad);
 

commit 4a2490eac897e3648c4800b1068b56b7e1ad91b3
Author: Mark F. Brown <mark.brown314@gmail.com>
Date:   Fri Sep 3 18:28:06 2010 -0400

    ARM: pxa: moved pxa27x_keypad.h to platform pxa directory
    
    mach-mmp utilizes pxa27x_keypad code so we need to move header to
    platform pxa directory.
    
    Signed-off-by: Mark F. Brown <mark.brown314@gmail.com>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index f32404f99189..731bd88bb076 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -32,7 +32,7 @@
 #include <asm/mach/map.h>
 
 #include <mach/hardware.h>
-#include <mach/pxa27x_keypad.h>
+#include <plat/pxa27x_keypad.h>
 /*
  * Keypad Controller registers
  */

commit 288933c02b440621d9c8e7bb5f232cfb7bdef7df
Author: Axel Lin <axel.lin@gmail.com>
Date:   Tue Aug 24 16:37:53 2010 -0700

    Input: pxa27x_keypad - remove input_free_device() in pxa27x_keypad_remove()
    
    No need to call input_free_device() after input_unregister_device().
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 0e53b3bc39af..f32404f99189 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -567,8 +567,6 @@ static int __devexit pxa27x_keypad_remove(struct platform_device *pdev)
 	clk_put(keypad->clk);
 
 	input_unregister_device(keypad->input_dev);
-	input_free_device(keypad->input_dev);
-
 	iounmap(keypad->mmio_base);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 79cd3e9fdf2e..0e53b3bc39af 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -26,6 +26,7 @@
 #include <linux/clk.h>
 #include <linux/err.h>
 #include <linux/input/matrix_keypad.h>
+#include <linux/slab.h>
 
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>

commit 2f82af08fcc7dc01a7e98a49a5995a77e32a2925
Author: Nicolas Pitre <nico@fluxnic.net>
Date:   Mon Sep 14 03:25:28 2009 -0400

    Nicolas Pitre has a new email address
    
    Due to problems at cam.org, my nico@cam.org email address is no longer
    valid.  FRom now on, nico@fluxnic.net should be used instead.
    
    Signed-off-by: Nicolas Pitre <nico@fluxnic.net>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 76f9668221a4..79cd3e9fdf2e 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -8,7 +8,7 @@
  *
  * Based on a previous implementations by Kevin O'Connor
  * <kevin_at_koconnor.net> and Alex Osborne <bobofdoom@gmail.com> and
- * on some suggestions by Nicolas Pitre <nico@cam.org>.
+ * on some suggestions by Nicolas Pitre <nico@fluxnic.net>.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as

commit bd96f37895197563bc1d6d6f7c012b3ae7df1c45
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Sep 4 23:46:18 2009 -0700

    Input: pxa27x_keypad - allow modifying keymap from userspace
    
    Tested-by: Mike Rapoport <mike@compulab.co.il>
    Acked-by: Eric Miao <eric.y.miao@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index c987cc75674c..76f9668221a4 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -32,7 +32,6 @@
 
 #include <mach/hardware.h>
 #include <mach/pxa27x_keypad.h>
-
 /*
  * Keypad Controller registers
  */
@@ -96,7 +95,8 @@
 #define keypad_readl(off)	__raw_readl(keypad->mmio_base + (off))
 #define keypad_writel(off, v)	__raw_writel((v), keypad->mmio_base + (off))
 
-#define MAX_MATRIX_KEY_NUM	(8 * 8)
+#define MAX_MATRIX_KEY_NUM	(MAX_MATRIX_KEY_ROWS * MAX_MATRIX_KEY_COLS)
+#define MAX_KEYPAD_KEYS		(MAX_MATRIX_KEY_NUM + MAX_DIRECT_KEY_NUM)
 
 struct pxa27x_keypad {
 	struct pxa27x_keypad_platform_data *pdata;
@@ -107,73 +107,82 @@ struct pxa27x_keypad {
 
 	int irq;
 
-	/* matrix key code map */
-	unsigned short matrix_keycodes[MAX_MATRIX_KEY_NUM];
+	unsigned short keycodes[MAX_KEYPAD_KEYS];
+	int rotary_rel_code[2];
 
 	/* state row bits of each column scan */
 	uint32_t matrix_key_state[MAX_MATRIX_KEY_COLS];
 	uint32_t direct_key_state;
 
 	unsigned int direct_key_mask;
-
-	int rotary_rel_code[2];
-	int rotary_up_key[2];
-	int rotary_down_key[2];
 };
 
 static void pxa27x_keypad_build_keycode(struct pxa27x_keypad *keypad)
 {
 	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
 	struct input_dev *input_dev = keypad->input_dev;
+	unsigned short keycode;
 	int i;
 
 	for (i = 0; i < pdata->matrix_key_map_size; i++) {
 		unsigned int key = pdata->matrix_key_map[i];
 		unsigned int row = KEY_ROW(key);
 		unsigned int col = KEY_COL(key);
-		unsigned short code = KEY_VAL(key);
+		unsigned int scancode = MATRIX_SCAN_CODE(row, col,
+							 MATRIX_ROW_SHIFT);
 
-		keypad->matrix_keycodes[(row << 3) + col] = code;
-		__set_bit(code, input_dev->keybit);
+		keycode = KEY_VAL(key);
+		keypad->keycodes[scancode] = keycode;
+		__set_bit(keycode, input_dev->keybit);
 	}
-	__clear_bit(KEY_RESERVED, input_dev->keybit);
-
-	for (i = 0; i < pdata->direct_key_num; i++)
-		__set_bit(pdata->direct_key_map[i], input_dev->keybit);
 
-	keypad->rotary_up_key[0] = pdata->rotary0_up_key;
-	keypad->rotary_up_key[1] = pdata->rotary1_up_key;
-	keypad->rotary_down_key[0] = pdata->rotary0_down_key;
-	keypad->rotary_down_key[1] = pdata->rotary1_down_key;
-	keypad->rotary_rel_code[0] = pdata->rotary0_rel_code;
-	keypad->rotary_rel_code[1] = pdata->rotary1_rel_code;
+	for (i = 0; i < pdata->direct_key_num; i++) {
+		keycode = pdata->direct_key_map[i];
+		keypad->keycodes[MAX_MATRIX_KEY_NUM + i] = keycode;
+		__set_bit(keycode, input_dev->keybit);
+	}
 
 	if (pdata->enable_rotary0) {
 		if (pdata->rotary0_up_key && pdata->rotary0_down_key) {
-			__set_bit(pdata->rotary0_up_key, input_dev->keybit);
-			__set_bit(pdata->rotary0_down_key, input_dev->keybit);
-		} else
+			keycode = pdata->rotary0_up_key;
+			keypad->keycodes[MAX_MATRIX_KEY_NUM + 0] = keycode;
+			__set_bit(keycode, input_dev->keybit);
+
+			keycode = pdata->rotary0_down_key;
+			keypad->keycodes[MAX_MATRIX_KEY_NUM + 1] = keycode;
+			__set_bit(keycode, input_dev->keybit);
+
+			keypad->rotary_rel_code[0] = -1;
+		} else {
+			keypad->rotary_rel_code[0] = pdata->rotary0_rel_code;
 			__set_bit(pdata->rotary0_rel_code, input_dev->relbit);
+		}
 	}
 
 	if (pdata->enable_rotary1) {
 		if (pdata->rotary1_up_key && pdata->rotary1_down_key) {
-			__set_bit(pdata->rotary1_up_key, input_dev->keybit);
-			__set_bit(pdata->rotary1_down_key, input_dev->keybit);
-		} else
+			keycode = pdata->rotary1_up_key;
+			keypad->keycodes[MAX_MATRIX_KEY_NUM + 2] = keycode;
+			__set_bit(keycode, input_dev->keybit);
+
+			keycode = pdata->rotary1_down_key;
+			keypad->keycodes[MAX_MATRIX_KEY_NUM + 3] = keycode;
+			__set_bit(keycode, input_dev->keybit);
+
+			keypad->rotary_rel_code[1] = -1;
+		} else {
+			keypad->rotary_rel_code[1] = pdata->rotary1_rel_code;
 			__set_bit(pdata->rotary1_rel_code, input_dev->relbit);
+		}
 	}
-}
 
-static inline unsigned int lookup_matrix_keycode(
-		struct pxa27x_keypad *keypad, int row, int col)
-{
-	return keypad->matrix_keycodes[(row << 3) + col];
+	__clear_bit(KEY_RESERVED, input_dev->keybit);
 }
 
 static void pxa27x_keypad_scan_matrix(struct pxa27x_keypad *keypad)
 {
 	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
+	struct input_dev *input_dev = keypad->input_dev;
 	int row, col, num_keys_pressed = 0;
 	uint32_t new_state[MAX_MATRIX_KEY_COLS];
 	uint32_t kpas = keypad_readl(KPAS);
@@ -216,6 +225,7 @@ static void pxa27x_keypad_scan_matrix(struct pxa27x_keypad *keypad)
 scan:
 	for (col = 0; col < pdata->matrix_key_cols; col++) {
 		uint32_t bits_changed;
+		int code;
 
 		bits_changed = keypad->matrix_key_state[col] ^ new_state[col];
 		if (bits_changed == 0)
@@ -225,12 +235,13 @@ static void pxa27x_keypad_scan_matrix(struct pxa27x_keypad *keypad)
 			if ((bits_changed & (1 << row)) == 0)
 				continue;
 
-			input_report_key(keypad->input_dev,
-				lookup_matrix_keycode(keypad, row, col),
-				new_state[col] & (1 << row));
+			code = MATRIX_SCAN_CODE(row, col, MATRIX_ROW_SHIFT);
+			input_event(input_dev, EV_MSC, MSC_SCAN, code);
+			input_report_key(input_dev, keypad->keycodes[code],
+					 new_state[col] & (1 << row));
 		}
 	}
-	input_sync(keypad->input_dev);
+	input_sync(input_dev);
 	memcpy(keypad->matrix_key_state, new_state, sizeof(new_state));
 }
 
@@ -253,13 +264,15 @@ static void report_rotary_event(struct pxa27x_keypad *keypad, int r, int delta)
 	if (delta == 0)
 		return;
 
-	if (keypad->rotary_up_key[r] && keypad->rotary_down_key[r]) {
-		int keycode = (delta > 0) ? keypad->rotary_up_key[r] :
-					    keypad->rotary_down_key[r];
+	if (keypad->rotary_rel_code[r] == -1) {
+		int code = MAX_MATRIX_KEY_NUM + 2 * r + (delta > 0 ? 0 : 1);
+		unsigned char keycode = keypad->keycodes[code];
 
 		/* simulate a press-n-release */
+		input_event(dev, EV_MSC, MSC_SCAN, code);
 		input_report_key(dev, keycode, 1);
 		input_sync(dev);
+		input_event(dev, EV_MSC, MSC_SCAN, code);
 		input_report_key(dev, keycode, 0);
 		input_sync(dev);
 	} else {
@@ -287,6 +300,7 @@ static void pxa27x_keypad_scan_rotary(struct pxa27x_keypad *keypad)
 static void pxa27x_keypad_scan_direct(struct pxa27x_keypad *keypad)
 {
 	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
+	struct input_dev *input_dev = keypad->input_dev;
 	unsigned int new_state;
 	uint32_t kpdk, bits_changed;
 	int i;
@@ -296,9 +310,6 @@ static void pxa27x_keypad_scan_direct(struct pxa27x_keypad *keypad)
 	if (pdata->enable_rotary0 || pdata->enable_rotary1)
 		pxa27x_keypad_scan_rotary(keypad);
 
-	if (pdata->direct_key_map == NULL)
-		return;
-
 	new_state = KPDK_DK(kpdk) & keypad->direct_key_mask;
 	bits_changed = keypad->direct_key_state ^ new_state;
 
@@ -306,12 +317,15 @@ static void pxa27x_keypad_scan_direct(struct pxa27x_keypad *keypad)
 		return;
 
 	for (i = 0; i < pdata->direct_key_num; i++) {
-		if (bits_changed & (1 << i))
-			input_report_key(keypad->input_dev,
-					pdata->direct_key_map[i],
-					(new_state & (1 << i)));
+		if (bits_changed & (1 << i)) {
+			int code = MAX_MATRIX_KEY_NUM + i;
+
+			input_event(input_dev, EV_MSC, MSC_SCAN, code);
+			input_report_key(input_dev, keypad->keycodes[code],
+					 new_state & (1 << i));
+		}
 	}
-	input_sync(keypad->input_dev);
+	input_sync(input_dev);
 	keypad->direct_key_state = new_state;
 }
 
@@ -432,38 +446,41 @@ static const struct dev_pm_ops pxa27x_keypad_pm_ops = {
 
 static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
 {
+	struct pxa27x_keypad_platform_data *pdata = pdev->dev.platform_data;
 	struct pxa27x_keypad *keypad;
 	struct input_dev *input_dev;
 	struct resource *res;
 	int irq, error;
 
-	keypad = kzalloc(sizeof(struct pxa27x_keypad), GFP_KERNEL);
-	if (keypad == NULL) {
-		dev_err(&pdev->dev, "failed to allocate driver data\n");
-		return -ENOMEM;
-	}
-
-	keypad->pdata = pdev->dev.platform_data;
-	if (keypad->pdata == NULL) {
+	if (pdata == NULL) {
 		dev_err(&pdev->dev, "no platform data defined\n");
-		error = -EINVAL;
-		goto failed_free;
+		return -EINVAL;
 	}
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0) {
 		dev_err(&pdev->dev, "failed to get keypad irq\n");
-		error = -ENXIO;
-		goto failed_free;
+		return -ENXIO;
 	}
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (res == NULL) {
 		dev_err(&pdev->dev, "failed to get I/O memory\n");
-		error = -ENXIO;
+		return -ENXIO;
+	}
+
+	keypad = kzalloc(sizeof(struct pxa27x_keypad), GFP_KERNEL);
+	input_dev = input_allocate_device();
+	if (!keypad || !input_dev) {
+		dev_err(&pdev->dev, "failed to allocate memory\n");
+		error = -ENOMEM;
 		goto failed_free;
 	}
 
+	keypad->pdata = pdata;
+	keypad->input_dev = input_dev;
+	keypad->irq = irq;
+
 	res = request_mem_region(res->start, resource_size(res), pdev->name);
 	if (res == NULL) {
 		dev_err(&pdev->dev, "failed to request I/O memory\n");
@@ -485,43 +502,35 @@ static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
 		goto failed_free_io;
 	}
 
-	/* Create and register the input driver. */
-	input_dev = input_allocate_device();
-	if (!input_dev) {
-		dev_err(&pdev->dev, "failed to allocate input device\n");
-		error = -ENOMEM;
-		goto failed_put_clk;
-	}
-
 	input_dev->name = pdev->name;
 	input_dev->id.bustype = BUS_HOST;
 	input_dev->open = pxa27x_keypad_open;
 	input_dev->close = pxa27x_keypad_close;
 	input_dev->dev.parent = &pdev->dev;
 
-	keypad->input_dev = input_dev;
+	input_dev->keycode = keypad->keycodes;
+	input_dev->keycodesize = sizeof(keypad->keycodes[0]);
+	input_dev->keycodemax = ARRAY_SIZE(keypad->keycodes);
+
 	input_set_drvdata(input_dev, keypad);
 
 	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);
-	if ((keypad->pdata->enable_rotary0 &&
-			keypad->pdata->rotary0_rel_code) ||
-	    (keypad->pdata->enable_rotary1 &&
-			keypad->pdata->rotary1_rel_code)) {
-		input_dev->evbit[0] |= BIT_MASK(EV_REL);
-	}
+	input_set_capability(input_dev, EV_MSC, MSC_SCAN);
 
 	pxa27x_keypad_build_keycode(keypad);
-	platform_set_drvdata(pdev, keypad);
+
+	if ((pdata->enable_rotary0 && keypad->rotary_rel_code[0] != -1) ||
+	    (pdata->enable_rotary1 && keypad->rotary_rel_code[1] != -1)) {
+		input_dev->evbit[0] |= BIT_MASK(EV_REL);
+	}
 
 	error = request_irq(irq, pxa27x_keypad_irq_handler, IRQF_DISABLED,
 			    pdev->name, keypad);
 	if (error) {
 		dev_err(&pdev->dev, "failed to request IRQ\n");
-		goto failed_free_dev;
+		goto failed_put_clk;
 	}
 
-	keypad->irq = irq;
-
 	/* Register the input device */
 	error = input_register_device(input_dev);
 	if (error) {
@@ -529,15 +538,13 @@ static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
 		goto failed_free_irq;
 	}
 
+	platform_set_drvdata(pdev, keypad);
 	device_init_wakeup(&pdev->dev, 1);
 
 	return 0;
 
 failed_free_irq:
 	free_irq(irq, pdev);
-	platform_set_drvdata(pdev, NULL);
-failed_free_dev:
-	input_free_device(input_dev);
 failed_put_clk:
 	clk_put(keypad->clk);
 failed_free_io:
@@ -545,6 +552,7 @@ static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
 failed_free_mem:
 	release_mem_region(res->start, resource_size(res));
 failed_free:
+	input_free_device(input_dev);
 	kfree(keypad);
 	return error;
 }
@@ -567,6 +575,7 @@ static int __devexit pxa27x_keypad_remove(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, NULL);
 	kfree(keypad);
+
 	return 0;
 }
 

commit b0010911d52dc7836a78c9f5c3b32ce4ac05b3c3
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Jul 24 22:01:43 2009 -0700

    Input: pxa27x_keypad - switch to using dev_pm_ops
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 094323819398..c987cc75674c 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -389,8 +389,9 @@ static void pxa27x_keypad_close(struct input_dev *dev)
 }
 
 #ifdef CONFIG_PM
-static int pxa27x_keypad_suspend(struct platform_device *pdev, pm_message_t state)
+static int pxa27x_keypad_suspend(struct device *dev)
 {
+	struct platform_device *pdev = to_platform_device(dev);
 	struct pxa27x_keypad *keypad = platform_get_drvdata(pdev);
 
 	clk_disable(keypad->clk);
@@ -401,8 +402,9 @@ static int pxa27x_keypad_suspend(struct platform_device *pdev, pm_message_t stat
 	return 0;
 }
 
-static int pxa27x_keypad_resume(struct platform_device *pdev)
+static int pxa27x_keypad_resume(struct device *dev)
 {
+	struct platform_device *pdev = to_platform_device(dev);
 	struct pxa27x_keypad *keypad = platform_get_drvdata(pdev);
 	struct input_dev *input_dev = keypad->input_dev;
 
@@ -421,9 +423,11 @@ static int pxa27x_keypad_resume(struct platform_device *pdev)
 
 	return 0;
 }
-#else
-#define pxa27x_keypad_suspend	NULL
-#define pxa27x_keypad_resume	NULL
+
+static const struct dev_pm_ops pxa27x_keypad_pm_ops = {
+	.suspend	= pxa27x_keypad_suspend,
+	.resume		= pxa27x_keypad_resume,
+};
 #endif
 
 static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
@@ -572,11 +576,12 @@ MODULE_ALIAS("platform:pxa27x-keypad");
 static struct platform_driver pxa27x_keypad_driver = {
 	.probe		= pxa27x_keypad_probe,
 	.remove		= __devexit_p(pxa27x_keypad_remove),
-	.suspend	= pxa27x_keypad_suspend,
-	.resume		= pxa27x_keypad_resume,
 	.driver		= {
 		.name	= "pxa27x-keypad",
 		.owner	= THIS_MODULE,
+#ifdef CONFIG_PM
+		.pm	= &pxa27x_keypad_pm_ops,
+#endif
 	},
 };
 

commit 52ec7752b457311f10f5a8d16faa8ac2e684eb65
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Wed Jul 22 21:51:40 2009 -0700

    Input: pxa27x_keypad - remove extra clk_disable
    
    clk_disable() in remove method is not needed since we already
    have clk_disable in pxa27x_keypad_close().
    
    Also make sure the driver uses resource_size() and helpers from
    include/input/matrix_keypad.h
    
    Tested-by: Mike Rapoport <mike@compulab.co.il>
    Acked-by: Eric Miao <eric.y.miao@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 0d2fc64a5e1c..094323819398 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -25,6 +25,7 @@
 #include <linux/platform_device.h>
 #include <linux/clk.h>
 #include <linux/err.h>
+#include <linux/input/matrix_keypad.h>
 
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
@@ -107,7 +108,7 @@ struct pxa27x_keypad {
 	int irq;
 
 	/* matrix key code map */
-	unsigned int matrix_keycodes[MAX_MATRIX_KEY_NUM];
+	unsigned short matrix_keycodes[MAX_MATRIX_KEY_NUM];
 
 	/* state row bits of each column scan */
 	uint32_t matrix_key_state[MAX_MATRIX_KEY_COLS];
@@ -124,21 +125,21 @@ static void pxa27x_keypad_build_keycode(struct pxa27x_keypad *keypad)
 {
 	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
 	struct input_dev *input_dev = keypad->input_dev;
-	unsigned int *key;
 	int i;
 
-	key = &pdata->matrix_key_map[0];
-	for (i = 0; i < pdata->matrix_key_map_size; i++, key++) {
-		int row = ((*key) >> 28) & 0xf;
-		int col = ((*key) >> 24) & 0xf;
-		int code = (*key) & 0xffffff;
+	for (i = 0; i < pdata->matrix_key_map_size; i++) {
+		unsigned int key = pdata->matrix_key_map[i];
+		unsigned int row = KEY_ROW(key);
+		unsigned int col = KEY_COL(key);
+		unsigned short code = KEY_VAL(key);
 
 		keypad->matrix_keycodes[(row << 3) + col] = code;
-		set_bit(code, input_dev->keybit);
+		__set_bit(code, input_dev->keybit);
 	}
+	__clear_bit(KEY_RESERVED, input_dev->keybit);
 
 	for (i = 0; i < pdata->direct_key_num; i++)
-		set_bit(pdata->direct_key_map[i], input_dev->keybit);
+		__set_bit(pdata->direct_key_map[i], input_dev->keybit);
 
 	keypad->rotary_up_key[0] = pdata->rotary0_up_key;
 	keypad->rotary_up_key[1] = pdata->rotary1_up_key;
@@ -149,18 +150,18 @@ static void pxa27x_keypad_build_keycode(struct pxa27x_keypad *keypad)
 
 	if (pdata->enable_rotary0) {
 		if (pdata->rotary0_up_key && pdata->rotary0_down_key) {
-			set_bit(pdata->rotary0_up_key, input_dev->keybit);
-			set_bit(pdata->rotary0_down_key, input_dev->keybit);
+			__set_bit(pdata->rotary0_up_key, input_dev->keybit);
+			__set_bit(pdata->rotary0_down_key, input_dev->keybit);
 		} else
-			set_bit(pdata->rotary0_rel_code, input_dev->relbit);
+			__set_bit(pdata->rotary0_rel_code, input_dev->relbit);
 	}
 
 	if (pdata->enable_rotary1) {
 		if (pdata->rotary1_up_key && pdata->rotary1_down_key) {
-			set_bit(pdata->rotary1_up_key, input_dev->keybit);
-			set_bit(pdata->rotary1_down_key, input_dev->keybit);
+			__set_bit(pdata->rotary1_up_key, input_dev->keybit);
+			__set_bit(pdata->rotary1_down_key, input_dev->keybit);
 		} else
-			set_bit(pdata->rotary1_rel_code, input_dev->relbit);
+			__set_bit(pdata->rotary1_rel_code, input_dev->relbit);
 	}
 }
 
@@ -425,8 +426,6 @@ static int pxa27x_keypad_resume(struct platform_device *pdev)
 #define pxa27x_keypad_resume	NULL
 #endif
 
-#define res_size(res)	((res)->end - (res)->start + 1)
-
 static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
 {
 	struct pxa27x_keypad *keypad;
@@ -461,14 +460,14 @@ static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
 		goto failed_free;
 	}
 
-	res = request_mem_region(res->start, res_size(res), pdev->name);
+	res = request_mem_region(res->start, resource_size(res), pdev->name);
 	if (res == NULL) {
 		dev_err(&pdev->dev, "failed to request I/O memory\n");
 		error = -EBUSY;
 		goto failed_free;
 	}
 
-	keypad->mmio_base = ioremap(res->start, res_size(res));
+	keypad->mmio_base = ioremap(res->start, resource_size(res));
 	if (keypad->mmio_base == NULL) {
 		dev_err(&pdev->dev, "failed to remap I/O memory\n");
 		error = -ENXIO;
@@ -540,7 +539,7 @@ static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
 failed_free_io:
 	iounmap(keypad->mmio_base);
 failed_free_mem:
-	release_mem_region(res->start, res_size(res));
+	release_mem_region(res->start, resource_size(res));
 failed_free:
 	kfree(keypad);
 	return error;
@@ -552,8 +551,6 @@ static int __devexit pxa27x_keypad_remove(struct platform_device *pdev)
 	struct resource *res;
 
 	free_irq(keypad->irq, pdev);
-
-	clk_disable(keypad->clk);
 	clk_put(keypad->clk);
 
 	input_unregister_device(keypad->input_dev);
@@ -562,7 +559,7 @@ static int __devexit pxa27x_keypad_remove(struct platform_device *pdev)
 	iounmap(keypad->mmio_base);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	release_mem_region(res->start, res_size(res));
+	release_mem_region(res->start, resource_size(res));
 
 	platform_set_drvdata(pdev, NULL);
 	kfree(keypad);

commit e0d8b13ae1e3ea747620580b6f777992148de182
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Nov 11 17:52:32 2008 +0000

    [ARM] pxa: don't pass a consumer clock name for devices with unique clocks
    
    Where devices only have one consumer, passing a consumer clock ID
    has no real benefit.  Remove it.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 6d30c6d334c3..0d2fc64a5e1c 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -475,7 +475,7 @@ static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
 		goto failed_free_mem;
 	}
 
-	keypad->clk = clk_get(&pdev->dev, "KBDCLK");
+	keypad->clk = clk_get(&pdev->dev, NULL);
 	if (IS_ERR(keypad->clk)) {
 		dev_err(&pdev->dev, "failed to get keypad clock\n");
 		error = PTR_ERR(keypad->clk);

commit a09e64fbc0094e3073dbb09c3b4bfe4ab669244b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Aug 5 16:14:15 2008 +0100

    [ARM] Move include/asm-arm/arch-* to arch/arm/*/include/mach
    
    This just leaves include/asm-arm/plat-* to deal with.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 8a925359d82e..6d30c6d334c3 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -29,8 +29,8 @@
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
 
-#include <asm/arch/hardware.h>
-#include <asm/arch/pxa27x_keypad.h>
+#include <mach/hardware.h>
+#include <mach/pxa27x_keypad.h>
 
 /*
  * Keypad Controller registers

commit 0f8469a54f7bd65f2c740a5480c56260dc8a7ae0
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun Aug 3 15:06:16 2008 +0100

    [ARM] Eliminate useless includes of asm/mach-types.h
    
    There are 43 includes of asm/mach-types.h by files that don't
    reference anything from that file.  Remove these unnecessary
    includes.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 6f1516f50750..8a925359d82e 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -26,7 +26,6 @@
 #include <linux/clk.h>
 #include <linux/err.h>
 
-#include <asm/mach-types.h>
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
 

commit 15439dd37f92f930ac7fc65a4f261834e4215bb0
Merge: 39ab9ddeb3e9 90d95ef617a5
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Jun 17 12:02:44 2008 -0400

    Merge branch 'for-linus' into next
    
    Conflicts:
    
            drivers/input/mouse/appletouch.c

commit 39ab9ddeb3e9573a1ea9a17a1431ea5c81681964
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Mon Jun 2 11:20:55 2008 -0400

    Input: pxa27x_keypad - add wakeup support
    
    Signed-off-by: Eric Miao <eric.miao@marvell.com>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 3dea0c5077a9..c7c9599b315d 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -105,6 +105,8 @@ struct pxa27x_keypad {
 	struct input_dev *input_dev;
 	void __iomem *mmio_base;
 
+	int irq;
+
 	/* matrix key code map */
 	unsigned int matrix_keycodes[MAX_MATRIX_KEY_NUM];
 
@@ -385,6 +387,10 @@ static int pxa27x_keypad_suspend(struct platform_device *pdev, pm_message_t stat
 	struct pxa27x_keypad *keypad = platform_get_drvdata(pdev);
 
 	clk_disable(keypad->clk);
+
+	if (device_may_wakeup(&pdev->dev))
+		enable_irq_wake(keypad->irq);
+
 	return 0;
 }
 
@@ -393,6 +399,9 @@ static int pxa27x_keypad_resume(struct platform_device *pdev)
 	struct pxa27x_keypad *keypad = platform_get_drvdata(pdev);
 	struct input_dev *input_dev = keypad->input_dev;
 
+	if (device_may_wakeup(&pdev->dev))
+		disable_irq_wake(keypad->irq);
+
 	mutex_lock(&input_dev->mutex);
 
 	if (input_dev->users) {
@@ -497,6 +506,8 @@ static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
 		goto failed_free_dev;
 	}
 
+	keypad->irq = irq;
+
 	/* Register the input device */
 	error = input_register_device(input_dev);
 	if (error) {
@@ -504,6 +515,8 @@ static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
 		goto failed_free_irq;
 	}
 
+	device_init_wakeup(&pdev->dev, 1);
+
 	return 0;
 
 failed_free_irq:
@@ -527,7 +540,7 @@ static int __devexit pxa27x_keypad_remove(struct platform_device *pdev)
 	struct pxa27x_keypad *keypad = platform_get_drvdata(pdev);
 	struct resource *res;
 
-	free_irq(platform_get_irq(pdev, 0), pdev);
+	free_irq(keypad->irq, pdev);
 
 	clk_disable(keypad->clk);
 	clk_put(keypad->clk);

commit 471637a575329f9250e7e4099e84084820a35e11
Author: Antonio Ospite <ospite@studenti.unina.it>
Date:   Wed May 28 14:35:52 2008 -0400

    Input: pxa27x_keypad - miscellaneous fixes
    
    1. Set input bits for direct keys codes
    2. Set input bits for rotary encoder codes only if rotary
       encoder is enabled
    3. Enable EV_REL only if rotary encoder is enabled and rel_codes
       are set up
    
    Signed-off-by: Antonio Ospite <ao2@openezx.org>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 3dea0c5077a9..45767e73f071 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -136,6 +136,9 @@ static void pxa27x_keypad_build_keycode(struct pxa27x_keypad *keypad)
 		set_bit(code, input_dev->keybit);
 	}
 
+	for (i = 0; i < pdata->direct_key_num; i++)
+		set_bit(pdata->direct_key_map[i], input_dev->keybit);
+
 	keypad->rotary_up_key[0] = pdata->rotary0_up_key;
 	keypad->rotary_up_key[1] = pdata->rotary1_up_key;
 	keypad->rotary_down_key[0] = pdata->rotary0_down_key;
@@ -143,17 +146,21 @@ static void pxa27x_keypad_build_keycode(struct pxa27x_keypad *keypad)
 	keypad->rotary_rel_code[0] = pdata->rotary0_rel_code;
 	keypad->rotary_rel_code[1] = pdata->rotary1_rel_code;
 
-	if (pdata->rotary0_up_key && pdata->rotary0_down_key) {
-		set_bit(pdata->rotary0_up_key, input_dev->keybit);
-		set_bit(pdata->rotary0_down_key, input_dev->keybit);
-	} else
-		set_bit(pdata->rotary0_rel_code, input_dev->relbit);
-
-	if (pdata->rotary1_up_key && pdata->rotary1_down_key) {
-		set_bit(pdata->rotary1_up_key, input_dev->keybit);
-		set_bit(pdata->rotary1_down_key, input_dev->keybit);
-	} else
-		set_bit(pdata->rotary1_rel_code, input_dev->relbit);
+	if (pdata->enable_rotary0) {
+		if (pdata->rotary0_up_key && pdata->rotary0_down_key) {
+			set_bit(pdata->rotary0_up_key, input_dev->keybit);
+			set_bit(pdata->rotary0_down_key, input_dev->keybit);
+		} else
+			set_bit(pdata->rotary0_rel_code, input_dev->relbit);
+	}
+
+	if (pdata->enable_rotary1) {
+		if (pdata->rotary1_up_key && pdata->rotary1_down_key) {
+			set_bit(pdata->rotary1_up_key, input_dev->keybit);
+			set_bit(pdata->rotary1_down_key, input_dev->keybit);
+		} else
+			set_bit(pdata->rotary1_rel_code, input_dev->relbit);
+	}
 }
 
 static inline unsigned int lookup_matrix_keycode(
@@ -484,8 +491,13 @@ static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
 	keypad->input_dev = input_dev;
 	input_set_drvdata(input_dev, keypad);
 
-	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP) |
-		BIT_MASK(EV_REL);
+	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);
+	if ((keypad->pdata->enable_rotary0 &&
+			keypad->pdata->rotary0_rel_code) ||
+	    (keypad->pdata->enable_rotary1 &&
+			keypad->pdata->rotary1_rel_code)) {
+		input_dev->evbit[0] |= BIT_MASK(EV_REL);
+	}
 
 	pxa27x_keypad_build_keycode(keypad);
 	platform_set_drvdata(pdev, keypad);

commit d7b5247bbcfba2bc96d4b3dec9086a4f1a31363b
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Fri Apr 18 00:24:42 2008 -0400

    Input: add MODULE_ALIAS() to hotpluggable platform modules
    
    Since 43cc71eed1250755986da4c0f9898f9a635cb3bf, the platform modalias
    is prefixed with "platform:". Add MODULE_ALIAS() to the hotpluggable
    "input" platform drivers, to re-enable auto loading.
    
    [dbrownell@users.sourceforge.net: more drivers, registration fixes]
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 4e651c11c1da..3dea0c5077a9 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -545,6 +545,9 @@ static int __devexit pxa27x_keypad_remove(struct platform_device *pdev)
 	return 0;
 }
 
+/* work with hotplug and coldplug */
+MODULE_ALIAS("platform:pxa27x-keypad");
+
 static struct platform_driver pxa27x_keypad_driver = {
 	.probe		= pxa27x_keypad_probe,
 	.remove		= __devexit_p(pxa27x_keypad_remove),
@@ -552,6 +555,7 @@ static struct platform_driver pxa27x_keypad_driver = {
 	.resume		= pxa27x_keypad_resume,
 	.driver		= {
 		.name	= "pxa27x-keypad",
+		.owner	= THIS_MODULE,
 	},
 };
 

commit 688dad4f4c9004fcaa4cadad167b064342be5d63
Author: Samuel Ortiz <sameo@openedhand.com>
Date:   Thu Mar 20 09:48:14 2008 -0400

    Input: pxa27x - fix keypad KPC macros
    
    We want to mask (key_number - 1), not key_number. The current
    implementation works fine for all values but the maximum one,
    i.e. 8.
    
    Signed-off-by: Samuel Ortiz <sameo@openedhand.com>
    Acked-by: Eric Miao <eric.miao@marvell.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 6224c2fb3b65..4e651c11c1da 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -50,9 +50,9 @@
 #define KPKDI           0x0048
 
 /* bit definitions */
-#define KPC_MKRN(n)	((((n) & 0x7) - 1) << 26) /* matrix key row number */
-#define KPC_MKCN(n)	((((n) & 0x7) - 1) << 23) /* matrix key column number */
-#define KPC_DKN(n)	((((n) & 0x7) - 1) << 6)  /* direct key number */
+#define KPC_MKRN(n)	((((n) - 1) & 0x7) << 26) /* matrix key row number */
+#define KPC_MKCN(n)	((((n) - 1) & 0x7) << 23) /* matrix key column number */
+#define KPC_DKN(n)	((((n) - 1) & 0x7) << 6)  /* direct key number */
 
 #define KPC_AS          (0x1 << 30)  /* Automatic Scan bit */
 #define KPC_ASACT       (0x1 << 29)  /* Automatic Scan on Activity */

commit 76cb44e1a853f9c438ccf62eb5006f089430da72
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Thu Jan 31 00:59:23 2008 -0500

    Input: pxa27x_keypad - add debounce_interval to the keypad platform data
    
    Currently, only one debounce_interval is introduced for both direct and
    matrix keys. This is true in most cases, although the keypad controller
    supports different debounce for direct/matrix keys.
    
    Some platforms do require this to be tuned, instead of the default
    reset value of 100ms.
    
    Rotary encoder will always use zero debounce time for now to achieve
    certain sensitivity.
    
    Signed-off-by: Eric Miao <eric.miao@marvell.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index ceaf1e0ab540..6224c2fb3b65 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -357,6 +357,7 @@ static void pxa27x_keypad_config(struct pxa27x_keypad *keypad)
 
 	keypad_writel(KPC, kpc | KPC_RE_ZERO_DEB);
 	keypad_writel(KPREC, DEFAULT_KPREC);
+	keypad_writel(KPKDI, pdata->debounce_interval);
 }
 
 static int pxa27x_keypad_open(struct input_dev *dev)

commit 9c60debd2a666dc0e8466dee556af30ea68e97d2
Author: Eric Miao <eric.miao@marvell.com>
Date:   Thu Jan 31 00:59:15 2008 -0500

    Input: pxa27x_keypad - use device resources for I/O memory mapping and IRQ
    
    1. use ioremap() for registers access, this improves the portability
       of the driver (e.g. same IP on different processor with different
       I/O memory range), and make it possible to remove those registers
       definition in pxa-regs.h as PXA is undergoing a clean-up of that
       header file
    
    2. use device specific IRQ instead of hardcoded IRQ_KEYPAD, same
       reason as above
    
    3. clean up the error handling path in _probe()
    
    4. remove DRIVER_NAME and use pdev->name when necessary, we don't
       actually need a constant string literals
    
    Signed-off-by: Eric Miao <eric.miao@marvell.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index cd25b3414491..ceaf1e0ab540 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -31,25 +31,71 @@
 #include <asm/mach/map.h>
 
 #include <asm/arch/hardware.h>
-#include <asm/arch/pxa-regs.h>
-#include <asm/arch/irqs.h>
 #include <asm/arch/pxa27x_keypad.h>
 
-#define DRIVER_NAME		"pxa27x-keypad"
-
+/*
+ * Keypad Controller registers
+ */
+#define KPC             0x0000 /* Keypad Control register */
+#define KPDK            0x0008 /* Keypad Direct Key register */
+#define KPREC           0x0010 /* Keypad Rotary Encoder register */
+#define KPMK            0x0018 /* Keypad Matrix Key register */
+#define KPAS            0x0020 /* Keypad Automatic Scan register */
+
+/* Keypad Automatic Scan Multiple Key Presser register 0-3 */
+#define KPASMKP0        0x0028
+#define KPASMKP1        0x0030
+#define KPASMKP2        0x0038
+#define KPASMKP3        0x0040
+#define KPKDI           0x0048
+
+/* bit definitions */
 #define KPC_MKRN(n)	((((n) & 0x7) - 1) << 26) /* matrix key row number */
 #define KPC_MKCN(n)	((((n) & 0x7) - 1) << 23) /* matrix key column number */
 #define KPC_DKN(n)	((((n) & 0x7) - 1) << 6)  /* direct key number */
 
+#define KPC_AS          (0x1 << 30)  /* Automatic Scan bit */
+#define KPC_ASACT       (0x1 << 29)  /* Automatic Scan on Activity */
+#define KPC_MI          (0x1 << 22)  /* Matrix interrupt bit */
+#define KPC_IMKP        (0x1 << 21)  /* Ignore Multiple Key Press */
+
+#define KPC_MS(n)	(0x1 << (13 + (n)))	/* Matrix scan line 'n' */
+#define KPC_MS_ALL      (0xff << 13)
+
+#define KPC_ME          (0x1 << 12)  /* Matrix Keypad Enable */
+#define KPC_MIE         (0x1 << 11)  /* Matrix Interrupt Enable */
+#define KPC_DK_DEB_SEL	(0x1 <<  9)  /* Direct Keypad Debounce Select */
+#define KPC_DI          (0x1 <<  5)  /* Direct key interrupt bit */
+#define KPC_RE_ZERO_DEB (0x1 <<  4)  /* Rotary Encoder Zero Debounce */
+#define KPC_REE1        (0x1 <<  3)  /* Rotary Encoder1 Enable */
+#define KPC_REE0        (0x1 <<  2)  /* Rotary Encoder0 Enable */
+#define KPC_DE          (0x1 <<  1)  /* Direct Keypad Enable */
+#define KPC_DIE         (0x1 <<  0)  /* Direct Keypad interrupt Enable */
+
 #define KPDK_DKP        (0x1 << 31)
 #define KPDK_DK(n)	((n) & 0xff)
 
-#define KPAS_MUKP(n)		(((n) >> 26) & 0x1f)
-#define KPAS_RP(n)		(((n) >> 4) & 0xf)
-#define KPAS_CP(n)		((n) & 0xf)
+#define KPREC_OF1       (0x1 << 31)
+#define kPREC_UF1       (0x1 << 30)
+#define KPREC_OF0       (0x1 << 15)
+#define KPREC_UF0       (0x1 << 14)
+
+#define KPREC_RECOUNT0(n)	((n) & 0xff)
+#define KPREC_RECOUNT1(n)	(((n) >> 16) & 0xff)
+
+#define KPMK_MKP        (0x1 << 31)
+#define KPAS_SO         (0x1 << 31)
+#define KPASMKPx_SO     (0x1 << 31)
+
+#define KPAS_MUKP(n)	(((n) >> 26) & 0x1f)
+#define KPAS_RP(n)	(((n) >> 4) & 0xf)
+#define KPAS_CP(n)	((n) & 0xf)
 
 #define KPASMKP_MKC_MASK	(0xff)
 
+#define keypad_readl(off)	__raw_readl(keypad->mmio_base + (off))
+#define keypad_writel(off, v)	__raw_writel((v), keypad->mmio_base + (off))
+
 #define MAX_MATRIX_KEY_NUM	(8 * 8)
 
 struct pxa27x_keypad {
@@ -57,6 +103,7 @@ struct pxa27x_keypad {
 
 	struct clk *clk;
 	struct input_dev *input_dev;
+	void __iomem *mmio_base;
 
 	/* matrix key code map */
 	unsigned int matrix_keycodes[MAX_MATRIX_KEY_NUM];
@@ -120,7 +167,7 @@ static void pxa27x_keypad_scan_matrix(struct pxa27x_keypad *keypad)
 	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
 	int row, col, num_keys_pressed = 0;
 	uint32_t new_state[MAX_MATRIX_KEY_COLS];
-	uint32_t kpas = KPAS;
+	uint32_t kpas = keypad_readl(KPAS);
 
 	num_keys_pressed = KPAS_MUKP(kpas);
 
@@ -143,10 +190,10 @@ static void pxa27x_keypad_scan_matrix(struct pxa27x_keypad *keypad)
 	}
 
 	if (num_keys_pressed > 1) {
-		uint32_t kpasmkp0 = KPASMKP0;
-		uint32_t kpasmkp1 = KPASMKP1;
-		uint32_t kpasmkp2 = KPASMKP2;
-		uint32_t kpasmkp3 = KPASMKP3;
+		uint32_t kpasmkp0 = keypad_readl(KPASMKP0);
+		uint32_t kpasmkp1 = keypad_readl(KPASMKP1);
+		uint32_t kpasmkp2 = keypad_readl(KPASMKP2);
+		uint32_t kpasmkp3 = keypad_readl(KPASMKP3);
 
 		new_state[0] = kpasmkp0 & KPASMKP_MKC_MASK;
 		new_state[1] = (kpasmkp0 >> 16) & KPASMKP_MKC_MASK;
@@ -218,8 +265,8 @@ static void pxa27x_keypad_scan_rotary(struct pxa27x_keypad *keypad)
 	uint32_t kprec;
 
 	/* read and reset to default count value */
-	kprec = KPREC;
-	KPREC = DEFAULT_KPREC;
+	kprec = keypad_readl(KPREC);
+	keypad_writel(KPREC, DEFAULT_KPREC);
 
 	if (pdata->enable_rotary0)
 		report_rotary_event(keypad, 0, rotary_delta(kprec));
@@ -235,7 +282,7 @@ static void pxa27x_keypad_scan_direct(struct pxa27x_keypad *keypad)
 	uint32_t kpdk, bits_changed;
 	int i;
 
-	kpdk = KPDK;
+	kpdk = keypad_readl(KPDK);
 
 	if (pdata->enable_rotary0 || pdata->enable_rotary1)
 		pxa27x_keypad_scan_rotary(keypad);
@@ -262,7 +309,7 @@ static void pxa27x_keypad_scan_direct(struct pxa27x_keypad *keypad)
 static irqreturn_t pxa27x_keypad_irq_handler(int irq, void *dev_id)
 {
 	struct pxa27x_keypad *keypad = dev_id;
-	unsigned long kpc = KPC;
+	unsigned long kpc = keypad_readl(KPC);
 
 	if (kpc & KPC_DI)
 		pxa27x_keypad_scan_direct(keypad);
@@ -308,8 +355,8 @@ static void pxa27x_keypad_config(struct pxa27x_keypad *keypad)
 	if (direct_key_num)
 		kpc |= KPC_DE | KPC_DIE | KPC_DKN(direct_key_num);
 
-	KPC = kpc | KPC_RE_ZERO_DEB;
-	KPREC = DEFAULT_KPREC;
+	keypad_writel(KPC, kpc | KPC_RE_ZERO_DEB);
+	keypad_writel(KPREC, DEFAULT_KPREC);
 }
 
 static int pxa27x_keypad_open(struct input_dev *dev)
@@ -362,11 +409,14 @@ static int pxa27x_keypad_resume(struct platform_device *pdev)
 #define pxa27x_keypad_resume	NULL
 #endif
 
+#define res_size(res)	((res)->end - (res)->start + 1)
+
 static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
 {
 	struct pxa27x_keypad *keypad;
 	struct input_dev *input_dev;
-	int error;
+	struct resource *res;
+	int irq, error;
 
 	keypad = kzalloc(sizeof(struct pxa27x_keypad), GFP_KERNEL);
 	if (keypad == NULL) {
@@ -381,11 +431,39 @@ static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
 		goto failed_free;
 	}
 
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "failed to get keypad irq\n");
+		error = -ENXIO;
+		goto failed_free;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "failed to get I/O memory\n");
+		error = -ENXIO;
+		goto failed_free;
+	}
+
+	res = request_mem_region(res->start, res_size(res), pdev->name);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "failed to request I/O memory\n");
+		error = -EBUSY;
+		goto failed_free;
+	}
+
+	keypad->mmio_base = ioremap(res->start, res_size(res));
+	if (keypad->mmio_base == NULL) {
+		dev_err(&pdev->dev, "failed to remap I/O memory\n");
+		error = -ENXIO;
+		goto failed_free_mem;
+	}
+
 	keypad->clk = clk_get(&pdev->dev, "KBDCLK");
 	if (IS_ERR(keypad->clk)) {
 		dev_err(&pdev->dev, "failed to get keypad clock\n");
 		error = PTR_ERR(keypad->clk);
-		goto failed_free;
+		goto failed_free_io;
 	}
 
 	/* Create and register the input driver. */
@@ -396,7 +474,7 @@ static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
 		goto failed_put_clk;
 	}
 
-	input_dev->name = DRIVER_NAME;
+	input_dev->name = pdev->name;
 	input_dev->id.bustype = BUS_HOST;
 	input_dev->open = pxa27x_keypad_open;
 	input_dev->close = pxa27x_keypad_close;
@@ -409,30 +487,35 @@ static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
 		BIT_MASK(EV_REL);
 
 	pxa27x_keypad_build_keycode(keypad);
+	platform_set_drvdata(pdev, keypad);
 
-	error = request_irq(IRQ_KEYPAD, pxa27x_keypad_irq_handler, IRQF_DISABLED,
-			    DRIVER_NAME, keypad);
+	error = request_irq(irq, pxa27x_keypad_irq_handler, IRQF_DISABLED,
+			    pdev->name, keypad);
 	if (error) {
-		printk(KERN_ERR "Cannot request keypad IRQ\n");
-		goto err_free_dev;
+		dev_err(&pdev->dev, "failed to request IRQ\n");
+		goto failed_free_dev;
 	}
 
-	platform_set_drvdata(pdev, keypad);
-
 	/* Register the input device */
 	error = input_register_device(input_dev);
-	if (error)
-		goto err_free_irq;
+	if (error) {
+		dev_err(&pdev->dev, "failed to register input device\n");
+		goto failed_free_irq;
+	}
 
 	return 0;
 
- err_free_irq:
+failed_free_irq:
+	free_irq(irq, pdev);
 	platform_set_drvdata(pdev, NULL);
-	free_irq(IRQ_KEYPAD, pdev);
- err_free_dev:
+failed_free_dev:
 	input_free_device(input_dev);
 failed_put_clk:
 	clk_put(keypad->clk);
+failed_free_io:
+	iounmap(keypad->mmio_base);
+failed_free_mem:
+	release_mem_region(res->start, res_size(res));
 failed_free:
 	kfree(keypad);
 	return error;
@@ -441,13 +524,20 @@ static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
 static int __devexit pxa27x_keypad_remove(struct platform_device *pdev)
 {
 	struct pxa27x_keypad *keypad = platform_get_drvdata(pdev);
+	struct resource *res;
 
-	free_irq(IRQ_KEYPAD, pdev);
+	free_irq(platform_get_irq(pdev, 0), pdev);
 
 	clk_disable(keypad->clk);
 	clk_put(keypad->clk);
 
 	input_unregister_device(keypad->input_dev);
+	input_free_device(keypad->input_dev);
+
+	iounmap(keypad->mmio_base);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, res_size(res));
 
 	platform_set_drvdata(pdev, NULL);
 	kfree(keypad);
@@ -460,7 +550,7 @@ static struct platform_driver pxa27x_keypad_driver = {
 	.suspend	= pxa27x_keypad_suspend,
 	.resume		= pxa27x_keypad_resume,
 	.driver		= {
-		.name	= DRIVER_NAME,
+		.name	= "pxa27x-keypad",
 	},
 };
 

commit 62059d9e912717abbfb875440621d935d091f289
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Thu Jan 31 00:59:03 2008 -0500

    Input: pxa27x_keypad - enable rotary encoders and direct keys
    
    1. Rotary encoder events can be configured either as relative events
       as the legacy code does or as any specified key code, this is
       useful on some platform which uses the rotary keys as
       KEY_{UP/DOWN/LEFT/RIGHT}
    
    2. Add support for direct keys, the corresponding keycodes for each
       direct key can now be specified within the platform data
    
    3. Remove the direct/rotary key detection code from the IRQ handler
       to dedicated functions to improve readability
    
    Signed-off-by: Eric Miao <eric.miao@marvell.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index e9d4e227a009..cd25b3414491 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -41,6 +41,9 @@
 #define KPC_MKCN(n)	((((n) & 0x7) - 1) << 23) /* matrix key column number */
 #define KPC_DKN(n)	((((n) & 0x7) - 1) << 6)  /* direct key number */
 
+#define KPDK_DKP        (0x1 << 31)
+#define KPDK_DK(n)	((n) & 0xff)
+
 #define KPAS_MUKP(n)		(((n) >> 26) & 0x1f)
 #define KPAS_RP(n)		(((n) >> 4) & 0xf)
 #define KPAS_CP(n)		((n) & 0xf)
@@ -60,6 +63,13 @@ struct pxa27x_keypad {
 
 	/* state row bits of each column scan */
 	uint32_t matrix_key_state[MAX_MATRIX_KEY_COLS];
+	uint32_t direct_key_state;
+
+	unsigned int direct_key_mask;
+
+	int rotary_rel_code[2];
+	int rotary_up_key[2];
+	int rotary_down_key[2];
 };
 
 static void pxa27x_keypad_build_keycode(struct pxa27x_keypad *keypad)
@@ -78,6 +88,25 @@ static void pxa27x_keypad_build_keycode(struct pxa27x_keypad *keypad)
 		keypad->matrix_keycodes[(row << 3) + col] = code;
 		set_bit(code, input_dev->keybit);
 	}
+
+	keypad->rotary_up_key[0] = pdata->rotary0_up_key;
+	keypad->rotary_up_key[1] = pdata->rotary1_up_key;
+	keypad->rotary_down_key[0] = pdata->rotary0_down_key;
+	keypad->rotary_down_key[1] = pdata->rotary1_down_key;
+	keypad->rotary_rel_code[0] = pdata->rotary0_rel_code;
+	keypad->rotary_rel_code[1] = pdata->rotary1_rel_code;
+
+	if (pdata->rotary0_up_key && pdata->rotary0_down_key) {
+		set_bit(pdata->rotary0_up_key, input_dev->keybit);
+		set_bit(pdata->rotary0_down_key, input_dev->keybit);
+	} else
+		set_bit(pdata->rotary0_rel_code, input_dev->relbit);
+
+	if (pdata->rotary1_up_key && pdata->rotary1_down_key) {
+		set_bit(pdata->rotary1_up_key, input_dev->keybit);
+		set_bit(pdata->rotary1_down_key, input_dev->keybit);
+	} else
+		set_bit(pdata->rotary1_rel_code, input_dev->relbit);
 }
 
 static inline unsigned int lookup_matrix_keycode(
@@ -151,35 +180,92 @@ static void pxa27x_keypad_scan_matrix(struct pxa27x_keypad *keypad)
 
 #define DEFAULT_KPREC	(0x007f007f)
 
+static inline int rotary_delta(uint32_t kprec)
+{
+	if (kprec & KPREC_OF0)
+		return (kprec & 0xff) + 0x7f;
+	else if (kprec & KPREC_UF0)
+		return (kprec & 0xff) - 0x7f - 0xff;
+	else
+		return (kprec & 0xff) - 0x7f;
+}
+
+static void report_rotary_event(struct pxa27x_keypad *keypad, int r, int delta)
+{
+	struct input_dev *dev = keypad->input_dev;
+
+	if (delta == 0)
+		return;
+
+	if (keypad->rotary_up_key[r] && keypad->rotary_down_key[r]) {
+		int keycode = (delta > 0) ? keypad->rotary_up_key[r] :
+					    keypad->rotary_down_key[r];
+
+		/* simulate a press-n-release */
+		input_report_key(dev, keycode, 1);
+		input_sync(dev);
+		input_report_key(dev, keycode, 0);
+		input_sync(dev);
+	} else {
+		input_report_rel(dev, keypad->rotary_rel_code[r], delta);
+		input_sync(dev);
+	}
+}
+
+static void pxa27x_keypad_scan_rotary(struct pxa27x_keypad *keypad)
+{
+	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
+	uint32_t kprec;
+
+	/* read and reset to default count value */
+	kprec = KPREC;
+	KPREC = DEFAULT_KPREC;
+
+	if (pdata->enable_rotary0)
+		report_rotary_event(keypad, 0, rotary_delta(kprec));
+
+	if (pdata->enable_rotary1)
+		report_rotary_event(keypad, 1, rotary_delta(kprec >> 16));
+}
+
+static void pxa27x_keypad_scan_direct(struct pxa27x_keypad *keypad)
+{
+	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
+	unsigned int new_state;
+	uint32_t kpdk, bits_changed;
+	int i;
+
+	kpdk = KPDK;
+
+	if (pdata->enable_rotary0 || pdata->enable_rotary1)
+		pxa27x_keypad_scan_rotary(keypad);
+
+	if (pdata->direct_key_map == NULL)
+		return;
+
+	new_state = KPDK_DK(kpdk) & keypad->direct_key_mask;
+	bits_changed = keypad->direct_key_state ^ new_state;
+
+	if (bits_changed == 0)
+		return;
+
+	for (i = 0; i < pdata->direct_key_num; i++) {
+		if (bits_changed & (1 << i))
+			input_report_key(keypad->input_dev,
+					pdata->direct_key_map[i],
+					(new_state & (1 << i)));
+	}
+	input_sync(keypad->input_dev);
+	keypad->direct_key_state = new_state;
+}
+
 static irqreturn_t pxa27x_keypad_irq_handler(int irq, void *dev_id)
 {
 	struct pxa27x_keypad *keypad = dev_id;
-	struct input_dev *input_dev = keypad->input_dev;
 	unsigned long kpc = KPC;
-	int rel;
-
-	if (kpc & KPC_DI) {
-		unsigned long kpdk = KPDK;
-
-		if (!(kpdk & KPDK_DKP)) {
-			/* better luck next time */
-		} else if (kpc & KPC_REE0) {
-			unsigned long kprec = KPREC;
-			KPREC = 0x7f;
-
-			if (kprec & KPREC_OF0)
-				rel = (kprec & 0xff) + 0x7f;
-			else if (kprec & KPREC_UF0)
-				rel = (kprec & 0xff) - 0x7f - 0xff;
-			else
-				rel = (kprec & 0xff) - 0x7f;
-
-			if (rel) {
-				input_report_rel(input_dev, REL_WHEEL, rel);
-				input_sync(input_dev);
-			}
-		}
-	}
+
+	if (kpc & KPC_DI)
+		pxa27x_keypad_scan_direct(keypad);
 
 	if (kpc & KPC_MI)
 		pxa27x_keypad_scan_matrix(keypad);
@@ -190,6 +276,7 @@ static irqreturn_t pxa27x_keypad_irq_handler(int irq, void *dev_id)
 static void pxa27x_keypad_config(struct pxa27x_keypad *keypad)
 {
 	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
+	unsigned int mask = 0, direct_key_num = 0;
 	unsigned long kpc = 0;
 
 	/* enable matrix keys with automatic scan */
@@ -199,10 +286,29 @@ static void pxa27x_keypad_config(struct pxa27x_keypad *keypad)
 		       KPC_MKCN(pdata->matrix_key_cols);
 	}
 
-	/* FIXME: hardcoded to enable rotary 0 _only_ */
-	kpc |= KPC_DKN(2) | KPC_REE0 | KPC_DI | KPC_DIE;
+	/* enable rotary key, debounce interval same as direct keys */
+	if (pdata->enable_rotary0) {
+		mask |= 0x03;
+		direct_key_num = 2;
+		kpc |= KPC_REE0;
+	}
+
+	if (pdata->enable_rotary1) {
+		mask |= 0x0c;
+		direct_key_num = 4;
+		kpc |= KPC_REE1;
+	}
+
+	if (pdata->direct_key_num > direct_key_num)
+		direct_key_num = pdata->direct_key_num;
+
+	keypad->direct_key_mask = ((2 << direct_key_num) - 1) & ~mask;
+
+	/* enable direct key */
+	if (direct_key_num)
+		kpc |= KPC_DE | KPC_DIE | KPC_DKN(direct_key_num);
 
-	KPC = kpc;
+	KPC = kpc | KPC_RE_ZERO_DEB;
 	KPREC = DEFAULT_KPREC;
 }
 
@@ -301,7 +407,6 @@ static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
 
 	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP) |
 		BIT_MASK(EV_REL);
-	input_dev->relbit[BIT_WORD(REL_WHEEL)] = BIT_MASK(REL_WHEEL);
 
 	pxa27x_keypad_build_keycode(keypad);
 

commit d7416f9eaa5427f47648973aac3a65e7a0eeda04
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Thu Jan 31 00:58:52 2008 -0500

    Input: pxa27x_keypad - introduce pxa27x_keypad_config()
    
    Introduce pxa27x_keypad_config() for keypad registers configuration
    and remove the reg_kpc, reg_kprec from platform data structure
    so that configurations of keypad registers can be centralized to a
    single function.
    
    It can also be re-used when resuming.
    
    Signed-off-by: Eric Miao <eric.miao@marvell.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 8de35b0500f3..e9d4e227a009 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -37,6 +37,10 @@
 
 #define DRIVER_NAME		"pxa27x-keypad"
 
+#define KPC_MKRN(n)	((((n) & 0x7) - 1) << 26) /* matrix key row number */
+#define KPC_MKCN(n)	((((n) & 0x7) - 1) << 23) /* matrix key column number */
+#define KPC_DKN(n)	((((n) & 0x7) - 1) << 6)  /* direct key number */
+
 #define KPAS_MUKP(n)		(((n) >> 26) & 0x1f)
 #define KPAS_RP(n)		(((n) >> 4) & 0xf)
 #define KPAS_CP(n)		((n) & 0xf)
@@ -145,6 +149,8 @@ static void pxa27x_keypad_scan_matrix(struct pxa27x_keypad *keypad)
 	memcpy(keypad->matrix_key_state, new_state, sizeof(new_state));
 }
 
+#define DEFAULT_KPREC	(0x007f007f)
+
 static irqreturn_t pxa27x_keypad_irq_handler(int irq, void *dev_id)
 {
 	struct pxa27x_keypad *keypad = dev_id;
@@ -181,24 +187,32 @@ static irqreturn_t pxa27x_keypad_irq_handler(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static int pxa27x_keypad_open(struct input_dev *dev)
+static void pxa27x_keypad_config(struct pxa27x_keypad *keypad)
 {
-	struct pxa27x_keypad *keypad = input_get_drvdata(dev);
+	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
+	unsigned long kpc = 0;
 
-	/* Set keypad control register */
-	KPC |= (KPC_ASACT |
-		KPC_MS_ALL |
-		(2 << 6) | KPC_REE0 | KPC_DK_DEB_SEL |
-		KPC_ME | KPC_MIE | KPC_DE | KPC_DIE);
+	/* enable matrix keys with automatic scan */
+	if (pdata->matrix_key_rows && pdata->matrix_key_cols) {
+		kpc |= KPC_ASACT | KPC_MIE | KPC_ME | KPC_MS_ALL;
+		kpc |= KPC_MKRN(pdata->matrix_key_rows) |
+		       KPC_MKCN(pdata->matrix_key_cols);
+	}
 
-	KPC &= ~KPC_AS;         /* disable automatic scan */
-	KPC &= ~KPC_IMKP;       /* do not ignore multiple keypresses */
+	/* FIXME: hardcoded to enable rotary 0 _only_ */
+	kpc |= KPC_DKN(2) | KPC_REE0 | KPC_DI | KPC_DIE;
 
-	/* Set rotary count to mid-point value */
-	KPREC = 0x7F;
+	KPC = kpc;
+	KPREC = DEFAULT_KPREC;
+}
+
+static int pxa27x_keypad_open(struct input_dev *dev)
+{
+	struct pxa27x_keypad *keypad = input_get_drvdata(dev);
 
 	/* Enable unit clock */
 	clk_enable(keypad->clk);
+	pxa27x_keypad_config(keypad);
 
 	return 0;
 }
@@ -215,30 +229,22 @@ static void pxa27x_keypad_close(struct input_dev *dev)
 static int pxa27x_keypad_suspend(struct platform_device *pdev, pm_message_t state)
 {
 	struct pxa27x_keypad *keypad = platform_get_drvdata(pdev);
-	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
-
-	/* Save controller status */
-	pdata->reg_kpc = KPC;
-	pdata->reg_kprec = KPREC;
 
+	clk_disable(keypad->clk);
 	return 0;
 }
 
 static int pxa27x_keypad_resume(struct platform_device *pdev)
 {
 	struct pxa27x_keypad *keypad = platform_get_drvdata(pdev);
-	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
 	struct input_dev *input_dev = keypad->input_dev;
 
 	mutex_lock(&input_dev->mutex);
 
 	if (input_dev->users) {
-		/* Restore controller status */
-		KPC = pdata->reg_kpc;
-		KPREC = pdata->reg_kprec;
-
 		/* Enable unit clock */
 		clk_enable(keypad->clk);
+		pxa27x_keypad_config(keypad);
 	}
 
 	mutex_unlock(&input_dev->mutex);
@@ -254,7 +260,7 @@ static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
 {
 	struct pxa27x_keypad *keypad;
 	struct input_dev *input_dev;
-	int col, error;
+	int error;
 
 	keypad = kzalloc(sizeof(struct pxa27x_keypad), GFP_KERNEL);
 	if (keypad == NULL) {
@@ -313,16 +319,6 @@ static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
 	if (error)
 		goto err_free_irq;
 
-	/*
-	 * Store rows/cols info into keyboard registers.
-	 */
-
-	KPC |= (keypad->pdata->matrix_key_rows - 1) << 26;
-	KPC |= (keypad->pdata->matrix_key_cols - 1) << 23;
-
-	for (col = 0; col < keypad->pdata->matrix_key_cols; col++)
-		KPC |= KPC_MS0 << col;
-
 	return 0;
 
  err_free_irq:

commit 1814db69698479eec2c000a43c83b5f263f6fbb6
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Thu Jan 31 00:58:37 2008 -0500

    Input: pxa27x_keypad - introduce driver structure and use KEY() to define matrix keys
    
     1. Introduce the "struct pxa27x_keypad" structure for driver specific
        information, such as "struct clk", generated matrix key codes and
        so on
    
     2. Use KEY() macro to define matrix keys, instead of original 8x8 map
        this makes definition easier with keypad where keys are sparse
    
     3. Keep a generated array in "struct pxa27x_keypad" for fast lookup
    
     4. Separate the matrix scan into a dedicated function for readability
        and report only those keys whose state has been changed, instead
        of report all states
    
     5. Make use of KPAS to decide the faster path if only one key has been
        detected
    
    Signed-off-by: Eric Miao <eric.miao@marvell.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 43fb63d68122..8de35b0500f3 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -37,20 +37,120 @@
 
 #define DRIVER_NAME		"pxa27x-keypad"
 
-#define KPASMKP(col)		(col/2 == 0 ? KPASMKP0 : \
-				 col/2 == 1 ? KPASMKP1 : \
-				 col/2 == 2 ? KPASMKP2 : KPASMKP3)
-#define KPASMKPx_MKC(row, col)	(1 << (row + 16 * (col % 2)))
+#define KPAS_MUKP(n)		(((n) >> 26) & 0x1f)
+#define KPAS_RP(n)		(((n) >> 4) & 0xf)
+#define KPAS_CP(n)		((n) & 0xf)
 
-static struct clk *pxa27x_keypad_clk;
+#define KPASMKP_MKC_MASK	(0xff)
+
+#define MAX_MATRIX_KEY_NUM	(8 * 8)
+
+struct pxa27x_keypad {
+	struct pxa27x_keypad_platform_data *pdata;
+
+	struct clk *clk;
+	struct input_dev *input_dev;
+
+	/* matrix key code map */
+	unsigned int matrix_keycodes[MAX_MATRIX_KEY_NUM];
+
+	/* state row bits of each column scan */
+	uint32_t matrix_key_state[MAX_MATRIX_KEY_COLS];
+};
+
+static void pxa27x_keypad_build_keycode(struct pxa27x_keypad *keypad)
+{
+	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
+	struct input_dev *input_dev = keypad->input_dev;
+	unsigned int *key;
+	int i;
+
+	key = &pdata->matrix_key_map[0];
+	for (i = 0; i < pdata->matrix_key_map_size; i++, key++) {
+		int row = ((*key) >> 28) & 0xf;
+		int col = ((*key) >> 24) & 0xf;
+		int code = (*key) & 0xffffff;
+
+		keypad->matrix_keycodes[(row << 3) + col] = code;
+		set_bit(code, input_dev->keybit);
+	}
+}
+
+static inline unsigned int lookup_matrix_keycode(
+		struct pxa27x_keypad *keypad, int row, int col)
+{
+	return keypad->matrix_keycodes[(row << 3) + col];
+}
+
+static void pxa27x_keypad_scan_matrix(struct pxa27x_keypad *keypad)
+{
+	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
+	int row, col, num_keys_pressed = 0;
+	uint32_t new_state[MAX_MATRIX_KEY_COLS];
+	uint32_t kpas = KPAS;
+
+	num_keys_pressed = KPAS_MUKP(kpas);
+
+	memset(new_state, 0, sizeof(new_state));
+
+	if (num_keys_pressed == 0)
+		goto scan;
+
+	if (num_keys_pressed == 1) {
+		col = KPAS_CP(kpas);
+		row = KPAS_RP(kpas);
+
+		/* if invalid row/col, treat as no key pressed */
+		if (col >= pdata->matrix_key_cols ||
+		    row >= pdata->matrix_key_rows)
+			goto scan;
+
+		new_state[col] = (1 << row);
+		goto scan;
+	}
+
+	if (num_keys_pressed > 1) {
+		uint32_t kpasmkp0 = KPASMKP0;
+		uint32_t kpasmkp1 = KPASMKP1;
+		uint32_t kpasmkp2 = KPASMKP2;
+		uint32_t kpasmkp3 = KPASMKP3;
+
+		new_state[0] = kpasmkp0 & KPASMKP_MKC_MASK;
+		new_state[1] = (kpasmkp0 >> 16) & KPASMKP_MKC_MASK;
+		new_state[2] = kpasmkp1 & KPASMKP_MKC_MASK;
+		new_state[3] = (kpasmkp1 >> 16) & KPASMKP_MKC_MASK;
+		new_state[4] = kpasmkp2 & KPASMKP_MKC_MASK;
+		new_state[5] = (kpasmkp2 >> 16) & KPASMKP_MKC_MASK;
+		new_state[6] = kpasmkp3 & KPASMKP_MKC_MASK;
+		new_state[7] = (kpasmkp3 >> 16) & KPASMKP_MKC_MASK;
+	}
+scan:
+	for (col = 0; col < pdata->matrix_key_cols; col++) {
+		uint32_t bits_changed;
+
+		bits_changed = keypad->matrix_key_state[col] ^ new_state[col];
+		if (bits_changed == 0)
+			continue;
+
+		for (row = 0; row < pdata->matrix_key_rows; row++) {
+			if ((bits_changed & (1 << row)) == 0)
+				continue;
+
+			input_report_key(keypad->input_dev,
+				lookup_matrix_keycode(keypad, row, col),
+				new_state[col] & (1 << row));
+		}
+	}
+	input_sync(keypad->input_dev);
+	memcpy(keypad->matrix_key_state, new_state, sizeof(new_state));
+}
 
 static irqreturn_t pxa27x_keypad_irq_handler(int irq, void *dev_id)
 {
-	struct platform_device *pdev = dev_id;
-	struct pxa27x_keypad_platform_data *pdata = pdev->dev.platform_data;
-	struct input_dev *input_dev = platform_get_drvdata(pdev);
+	struct pxa27x_keypad *keypad = dev_id;
+	struct input_dev *input_dev = keypad->input_dev;
 	unsigned long kpc = KPC;
-	int p, row, col, rel;
+	int rel;
 
 	if (kpc & KPC_DI) {
 		unsigned long kpdk = KPDK;
@@ -75,26 +175,16 @@ static irqreturn_t pxa27x_keypad_irq_handler(int irq, void *dev_id)
 		}
 	}
 
-	if (kpc & KPC_MI) {
-		/* report the status of every button */
-		for (row = 0; row < pdata->nr_rows; row++) {
-			for (col = 0; col < pdata->nr_cols; col++) {
-				p = KPASMKP(col) & KPASMKPx_MKC(row, col) ?
-					1 : 0;
-				pr_debug("keycode %x - pressed %x\n",
-						pdata->keycodes[row][col], p);
-				input_report_key(input_dev,
-						pdata->keycodes[row][col], p);
-			}
-		}
-		input_sync(input_dev);
-	}
+	if (kpc & KPC_MI)
+		pxa27x_keypad_scan_matrix(keypad);
 
 	return IRQ_HANDLED;
 }
 
 static int pxa27x_keypad_open(struct input_dev *dev)
 {
+	struct pxa27x_keypad *keypad = input_get_drvdata(dev);
+
 	/* Set keypad control register */
 	KPC |= (KPC_ASACT |
 		KPC_MS_ALL |
@@ -108,21 +198,24 @@ static int pxa27x_keypad_open(struct input_dev *dev)
 	KPREC = 0x7F;
 
 	/* Enable unit clock */
-	clk_enable(pxa27x_keypad_clk);
+	clk_enable(keypad->clk);
 
 	return 0;
 }
 
 static void pxa27x_keypad_close(struct input_dev *dev)
 {
+	struct pxa27x_keypad *keypad = input_get_drvdata(dev);
+
 	/* Disable clock unit */
-	clk_disable(pxa27x_keypad_clk);
+	clk_disable(keypad->clk);
 }
 
 #ifdef CONFIG_PM
 static int pxa27x_keypad_suspend(struct platform_device *pdev, pm_message_t state)
 {
-	struct pxa27x_keypad_platform_data *pdata = pdev->dev.platform_data;
+	struct pxa27x_keypad *keypad = platform_get_drvdata(pdev);
+	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
 
 	/* Save controller status */
 	pdata->reg_kpc = KPC;
@@ -133,8 +226,9 @@ static int pxa27x_keypad_suspend(struct platform_device *pdev, pm_message_t stat
 
 static int pxa27x_keypad_resume(struct platform_device *pdev)
 {
-	struct pxa27x_keypad_platform_data *pdata = pdev->dev.platform_data;
-	struct input_dev *input_dev = platform_get_drvdata(pdev);
+	struct pxa27x_keypad *keypad = platform_get_drvdata(pdev);
+	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
+	struct input_dev *input_dev = keypad->input_dev;
 
 	mutex_lock(&input_dev->mutex);
 
@@ -144,8 +238,7 @@ static int pxa27x_keypad_resume(struct platform_device *pdev)
 		KPREC = pdata->reg_kprec;
 
 		/* Enable unit clock */
-		clk_disable(pxa27x_keypad_clk);
-		clk_enable(pxa27x_keypad_clk);
+		clk_enable(keypad->clk);
 	}
 
 	mutex_unlock(&input_dev->mutex);
@@ -159,22 +252,36 @@ static int pxa27x_keypad_resume(struct platform_device *pdev)
 
 static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
 {
-	struct pxa27x_keypad_platform_data *pdata = pdev->dev.platform_data;
+	struct pxa27x_keypad *keypad;
 	struct input_dev *input_dev;
-	int i, row, col, error;
+	int col, error;
 
-	pxa27x_keypad_clk = clk_get(&pdev->dev, "KBDCLK");
-	if (IS_ERR(pxa27x_keypad_clk)) {
-		error = PTR_ERR(pxa27x_keypad_clk);
-		goto err_clk;
+	keypad = kzalloc(sizeof(struct pxa27x_keypad), GFP_KERNEL);
+	if (keypad == NULL) {
+		dev_err(&pdev->dev, "failed to allocate driver data\n");
+		return -ENOMEM;
+	}
+
+	keypad->pdata = pdev->dev.platform_data;
+	if (keypad->pdata == NULL) {
+		dev_err(&pdev->dev, "no platform data defined\n");
+		error = -EINVAL;
+		goto failed_free;
+	}
+
+	keypad->clk = clk_get(&pdev->dev, "KBDCLK");
+	if (IS_ERR(keypad->clk)) {
+		dev_err(&pdev->dev, "failed to get keypad clock\n");
+		error = PTR_ERR(keypad->clk);
+		goto failed_free;
 	}
 
 	/* Create and register the input driver. */
 	input_dev = input_allocate_device();
 	if (!input_dev) {
-		printk(KERN_ERR "Cannot request keypad device\n");
+		dev_err(&pdev->dev, "failed to allocate input device\n");
 		error = -ENOMEM;
-		goto err_alloc;
+		goto failed_put_clk;
 	}
 
 	input_dev->name = DRIVER_NAME;
@@ -183,25 +290,23 @@ static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
 	input_dev->close = pxa27x_keypad_close;
 	input_dev->dev.parent = &pdev->dev;
 
+	keypad->input_dev = input_dev;
+	input_set_drvdata(input_dev, keypad);
+
 	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP) |
 		BIT_MASK(EV_REL);
 	input_dev->relbit[BIT_WORD(REL_WHEEL)] = BIT_MASK(REL_WHEEL);
-	for (row = 0; row < pdata->nr_rows; row++) {
-		for (col = 0; col < pdata->nr_cols; col++) {
-			int code = pdata->keycodes[row][col];
-			if (code > 0)
-				set_bit(code, input_dev->keybit);
-		}
-	}
+
+	pxa27x_keypad_build_keycode(keypad);
 
 	error = request_irq(IRQ_KEYPAD, pxa27x_keypad_irq_handler, IRQF_DISABLED,
-			    DRIVER_NAME, pdev);
+			    DRIVER_NAME, keypad);
 	if (error) {
 		printk(KERN_ERR "Cannot request keypad IRQ\n");
 		goto err_free_dev;
 	}
 
-	platform_set_drvdata(pdev, input_dev);
+	platform_set_drvdata(pdev, keypad);
 
 	/* Register the input device */
 	error = input_register_device(input_dev);
@@ -212,10 +317,10 @@ static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
 	 * Store rows/cols info into keyboard registers.
 	 */
 
-	KPC |= (pdata->nr_rows - 1) << 26;
-	KPC |= (pdata->nr_cols - 1) << 23;
+	KPC |= (keypad->pdata->matrix_key_rows - 1) << 26;
+	KPC |= (keypad->pdata->matrix_key_cols - 1) << 23;
 
-	for (col = 0; col < pdata->nr_cols; col++)
+	for (col = 0; col < keypad->pdata->matrix_key_cols; col++)
 		KPC |= KPC_MS0 << col;
 
 	return 0;
@@ -225,21 +330,26 @@ static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
 	free_irq(IRQ_KEYPAD, pdev);
  err_free_dev:
 	input_free_device(input_dev);
- err_alloc:
-	clk_put(pxa27x_keypad_clk);
- err_clk:
+failed_put_clk:
+	clk_put(keypad->clk);
+failed_free:
+	kfree(keypad);
 	return error;
 }
 
 static int __devexit pxa27x_keypad_remove(struct platform_device *pdev)
 {
-	struct input_dev *input_dev = platform_get_drvdata(pdev);
+	struct pxa27x_keypad *keypad = platform_get_drvdata(pdev);
 
-	input_unregister_device(input_dev);
 	free_irq(IRQ_KEYPAD, pdev);
-	clk_put(pxa27x_keypad_clk);
-	platform_set_drvdata(pdev, NULL);
 
+	clk_disable(keypad->clk);
+	clk_put(keypad->clk);
+
+	input_unregister_device(keypad->input_dev);
+
+	platform_set_drvdata(pdev, NULL);
+	kfree(keypad);
 	return 0;
 }
 

commit 1a1cd739a4b985f87c47e2809db7e240dba2c385
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Thu Jan 31 00:58:00 2008 -0500

    Input: pxa27x_keypad - remove pin configuration from the driver
    
    The pin configurations will slowly be moved to the board specific code
    at initialization thus to make the driver more generic.
    
    Signed-off-by: Eric Miao <eric.miao@marvell.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
index 06c1d5abaa81..43fb63d68122 100644
--- a/drivers/input/keyboard/pxa27x_keypad.c
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -208,10 +208,6 @@ static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
 	if (error)
 		goto err_free_irq;
 
-	/* Setup GPIOs. */
-	for (i = 0; i < pdata->nr_rows + pdata->nr_cols; i++)
-		pxa_gpio_mode(pdata->gpio_modes[i]);
-
 	/*
 	 * Store rows/cols info into keyboard registers.
 	 */

commit 0e5f11aa80bd01d048f374cc64ef0819ad7d86f2
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Thu Jan 31 00:56:46 2008 -0500

    Input: pxa27x_keypad - rename the driver (was pxa27x_keyboard)
    
    The controller should really be called keypad, and also align
    the naming of functions and structures to use "pxa27x_keypad"
    as prefix, instead of "pxakbd".
    
    Signed-off-by: Eric Miao <eric.miao@marvell.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/keyboard/pxa27x_keypad.c b/drivers/input/keyboard/pxa27x_keypad.c
new file mode 100644
index 000000000000..06c1d5abaa81
--- /dev/null
+++ b/drivers/input/keyboard/pxa27x_keypad.c
@@ -0,0 +1,274 @@
+/*
+ * linux/drivers/input/keyboard/pxa27x_keypad.c
+ *
+ * Driver for the pxa27x matrix keyboard controller.
+ *
+ * Created:	Feb 22, 2007
+ * Author:	Rodolfo Giometti <giometti@linux.it>
+ *
+ * Based on a previous implementations by Kevin O'Connor
+ * <kevin_at_koconnor.net> and Alex Osborne <bobofdoom@gmail.com> and
+ * on some suggestions by Nicolas Pitre <nico@cam.org>.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/input.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/irqs.h>
+#include <asm/arch/pxa27x_keypad.h>
+
+#define DRIVER_NAME		"pxa27x-keypad"
+
+#define KPASMKP(col)		(col/2 == 0 ? KPASMKP0 : \
+				 col/2 == 1 ? KPASMKP1 : \
+				 col/2 == 2 ? KPASMKP2 : KPASMKP3)
+#define KPASMKPx_MKC(row, col)	(1 << (row + 16 * (col % 2)))
+
+static struct clk *pxa27x_keypad_clk;
+
+static irqreturn_t pxa27x_keypad_irq_handler(int irq, void *dev_id)
+{
+	struct platform_device *pdev = dev_id;
+	struct pxa27x_keypad_platform_data *pdata = pdev->dev.platform_data;
+	struct input_dev *input_dev = platform_get_drvdata(pdev);
+	unsigned long kpc = KPC;
+	int p, row, col, rel;
+
+	if (kpc & KPC_DI) {
+		unsigned long kpdk = KPDK;
+
+		if (!(kpdk & KPDK_DKP)) {
+			/* better luck next time */
+		} else if (kpc & KPC_REE0) {
+			unsigned long kprec = KPREC;
+			KPREC = 0x7f;
+
+			if (kprec & KPREC_OF0)
+				rel = (kprec & 0xff) + 0x7f;
+			else if (kprec & KPREC_UF0)
+				rel = (kprec & 0xff) - 0x7f - 0xff;
+			else
+				rel = (kprec & 0xff) - 0x7f;
+
+			if (rel) {
+				input_report_rel(input_dev, REL_WHEEL, rel);
+				input_sync(input_dev);
+			}
+		}
+	}
+
+	if (kpc & KPC_MI) {
+		/* report the status of every button */
+		for (row = 0; row < pdata->nr_rows; row++) {
+			for (col = 0; col < pdata->nr_cols; col++) {
+				p = KPASMKP(col) & KPASMKPx_MKC(row, col) ?
+					1 : 0;
+				pr_debug("keycode %x - pressed %x\n",
+						pdata->keycodes[row][col], p);
+				input_report_key(input_dev,
+						pdata->keycodes[row][col], p);
+			}
+		}
+		input_sync(input_dev);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int pxa27x_keypad_open(struct input_dev *dev)
+{
+	/* Set keypad control register */
+	KPC |= (KPC_ASACT |
+		KPC_MS_ALL |
+		(2 << 6) | KPC_REE0 | KPC_DK_DEB_SEL |
+		KPC_ME | KPC_MIE | KPC_DE | KPC_DIE);
+
+	KPC &= ~KPC_AS;         /* disable automatic scan */
+	KPC &= ~KPC_IMKP;       /* do not ignore multiple keypresses */
+
+	/* Set rotary count to mid-point value */
+	KPREC = 0x7F;
+
+	/* Enable unit clock */
+	clk_enable(pxa27x_keypad_clk);
+
+	return 0;
+}
+
+static void pxa27x_keypad_close(struct input_dev *dev)
+{
+	/* Disable clock unit */
+	clk_disable(pxa27x_keypad_clk);
+}
+
+#ifdef CONFIG_PM
+static int pxa27x_keypad_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct pxa27x_keypad_platform_data *pdata = pdev->dev.platform_data;
+
+	/* Save controller status */
+	pdata->reg_kpc = KPC;
+	pdata->reg_kprec = KPREC;
+
+	return 0;
+}
+
+static int pxa27x_keypad_resume(struct platform_device *pdev)
+{
+	struct pxa27x_keypad_platform_data *pdata = pdev->dev.platform_data;
+	struct input_dev *input_dev = platform_get_drvdata(pdev);
+
+	mutex_lock(&input_dev->mutex);
+
+	if (input_dev->users) {
+		/* Restore controller status */
+		KPC = pdata->reg_kpc;
+		KPREC = pdata->reg_kprec;
+
+		/* Enable unit clock */
+		clk_disable(pxa27x_keypad_clk);
+		clk_enable(pxa27x_keypad_clk);
+	}
+
+	mutex_unlock(&input_dev->mutex);
+
+	return 0;
+}
+#else
+#define pxa27x_keypad_suspend	NULL
+#define pxa27x_keypad_resume	NULL
+#endif
+
+static int __devinit pxa27x_keypad_probe(struct platform_device *pdev)
+{
+	struct pxa27x_keypad_platform_data *pdata = pdev->dev.platform_data;
+	struct input_dev *input_dev;
+	int i, row, col, error;
+
+	pxa27x_keypad_clk = clk_get(&pdev->dev, "KBDCLK");
+	if (IS_ERR(pxa27x_keypad_clk)) {
+		error = PTR_ERR(pxa27x_keypad_clk);
+		goto err_clk;
+	}
+
+	/* Create and register the input driver. */
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		printk(KERN_ERR "Cannot request keypad device\n");
+		error = -ENOMEM;
+		goto err_alloc;
+	}
+
+	input_dev->name = DRIVER_NAME;
+	input_dev->id.bustype = BUS_HOST;
+	input_dev->open = pxa27x_keypad_open;
+	input_dev->close = pxa27x_keypad_close;
+	input_dev->dev.parent = &pdev->dev;
+
+	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP) |
+		BIT_MASK(EV_REL);
+	input_dev->relbit[BIT_WORD(REL_WHEEL)] = BIT_MASK(REL_WHEEL);
+	for (row = 0; row < pdata->nr_rows; row++) {
+		for (col = 0; col < pdata->nr_cols; col++) {
+			int code = pdata->keycodes[row][col];
+			if (code > 0)
+				set_bit(code, input_dev->keybit);
+		}
+	}
+
+	error = request_irq(IRQ_KEYPAD, pxa27x_keypad_irq_handler, IRQF_DISABLED,
+			    DRIVER_NAME, pdev);
+	if (error) {
+		printk(KERN_ERR "Cannot request keypad IRQ\n");
+		goto err_free_dev;
+	}
+
+	platform_set_drvdata(pdev, input_dev);
+
+	/* Register the input device */
+	error = input_register_device(input_dev);
+	if (error)
+		goto err_free_irq;
+
+	/* Setup GPIOs. */
+	for (i = 0; i < pdata->nr_rows + pdata->nr_cols; i++)
+		pxa_gpio_mode(pdata->gpio_modes[i]);
+
+	/*
+	 * Store rows/cols info into keyboard registers.
+	 */
+
+	KPC |= (pdata->nr_rows - 1) << 26;
+	KPC |= (pdata->nr_cols - 1) << 23;
+
+	for (col = 0; col < pdata->nr_cols; col++)
+		KPC |= KPC_MS0 << col;
+
+	return 0;
+
+ err_free_irq:
+	platform_set_drvdata(pdev, NULL);
+	free_irq(IRQ_KEYPAD, pdev);
+ err_free_dev:
+	input_free_device(input_dev);
+ err_alloc:
+	clk_put(pxa27x_keypad_clk);
+ err_clk:
+	return error;
+}
+
+static int __devexit pxa27x_keypad_remove(struct platform_device *pdev)
+{
+	struct input_dev *input_dev = platform_get_drvdata(pdev);
+
+	input_unregister_device(input_dev);
+	free_irq(IRQ_KEYPAD, pdev);
+	clk_put(pxa27x_keypad_clk);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static struct platform_driver pxa27x_keypad_driver = {
+	.probe		= pxa27x_keypad_probe,
+	.remove		= __devexit_p(pxa27x_keypad_remove),
+	.suspend	= pxa27x_keypad_suspend,
+	.resume		= pxa27x_keypad_resume,
+	.driver		= {
+		.name	= DRIVER_NAME,
+	},
+};
+
+static int __init pxa27x_keypad_init(void)
+{
+	return platform_driver_register(&pxa27x_keypad_driver);
+}
+
+static void __exit pxa27x_keypad_exit(void)
+{
+	platform_driver_unregister(&pxa27x_keypad_driver);
+}
+
+module_init(pxa27x_keypad_init);
+module_exit(pxa27x_keypad_exit);
+
+MODULE_DESCRIPTION("PXA27x Keypad Controller Driver");
+MODULE_LICENSE("GPL");
