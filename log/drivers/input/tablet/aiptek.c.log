commit cfa4f6a99fb183742cace65ec551b444852b8ef6
Author: Johan Hovold <johan@kernel.org>
Date:   Fri Jan 10 11:59:52 2020 -0800

    Input: aiptek - use descriptors of current altsetting
    
    Make sure to always use the descriptors of the current alternate setting
    to avoid future issues when accessing fields that may differ between
    settings.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Acked-by: Vladis Dronov <vdronov@redhat.com>
    Link: https://lore.kernel.org/r/20191210113737.4016-4-johan@kernel.org
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 06d0ffef4a17..e08b0ef078e8 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -1713,7 +1713,7 @@ aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 
 	aiptek->inputdev = inputdev;
 	aiptek->intf = intf;
-	aiptek->ifnum = intf->altsetting[0].desc.bInterfaceNumber;
+	aiptek->ifnum = intf->cur_altsetting->desc.bInterfaceNumber;
 	aiptek->inDelay = 0;
 	aiptek->endDelay = 0;
 	aiptek->previousJitterable = 0;

commit 3111491fca4f01764e0c158c5e0f7ced808eef51
Author: Johan Hovold <johan@kernel.org>
Date:   Fri Jan 10 11:59:32 2020 -0800

    Input: aiptek - fix endpoint sanity check
    
    The driver was checking the number of endpoints of the first alternate
    setting instead of the current one, something which could lead to the
    driver binding to an invalid interface.
    
    This in turn could cause the driver to misbehave or trigger a WARN() in
    usb_submit_urb() that kernels with panic_on_warn set would choke on.
    
    Fixes: 8e20cf2bce12 ("Input: aiptek - fix crash on detecting device without endpoints")
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Acked-by: Vladis Dronov <vdronov@redhat.com>
    Link: https://lore.kernel.org/r/20191210113737.4016-3-johan@kernel.org
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 2ca586fb914f..06d0ffef4a17 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -1802,14 +1802,14 @@ aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	input_set_abs_params(inputdev, ABS_WHEEL, AIPTEK_WHEEL_MIN, AIPTEK_WHEEL_MAX - 1, 0, 0);
 
 	/* Verify that a device really has an endpoint */
-	if (intf->altsetting[0].desc.bNumEndpoints < 1) {
+	if (intf->cur_altsetting->desc.bNumEndpoints < 1) {
 		dev_err(&intf->dev,
 			"interface has %d endpoints, but must have minimum 1\n",
-			intf->altsetting[0].desc.bNumEndpoints);
+			intf->cur_altsetting->desc.bNumEndpoints);
 		err = -EINVAL;
 		goto fail3;
 	}
-	endpoint = &intf->altsetting[0].endpoint[0].desc;
+	endpoint = &intf->cur_altsetting->endpoint[0].desc;
 
 	/* Go set up our URB, which is called when the tablet receives
 	 * input.

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index c82cd5079d0e..2ca586fb914f 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Native support for the Aiptek HyperPen USB Tablets
  *  (4000U/5000U/6000U/8000U/12000U)
@@ -54,20 +55,6 @@
  *      so therefore it's easier to document them all as one subsystem.
  *      Please visit the project's "home page", located at,
  *      http://aiptektablet.sourceforge.net.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
 
 #include <linux/jiffies.h>

commit 53fddb6618db53779d96f6a29a98e2a9c5d05877
Author: Jia-Ju Bai <baijiaju1990@gmail.com>
Date:   Fri Jul 27 11:35:17 2018 -0700

    Input: aiptek - replace GFP_ATOMIC with GFP_KERNEL in aiptek_probe()
    
    aiptek_probe() is never called in atomic context. It calls
    usb_alloc_coherent() with GFP_ATOMIC, which is not necessary. GFP_ATOMIC
    can be replaced with GFP_KERNEL.
    
    This is found by a static analysis tool named DCNS written by myself.
    
    Signed-off-by: Jia-Ju Bai <baijiaju1990@gmail.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 545fa6e89035..c82cd5079d0e 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -1712,7 +1712,7 @@ aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
         }
 
 	aiptek->data = usb_alloc_coherent(usbdev, AIPTEK_PACKET_LENGTH,
-					  GFP_ATOMIC, &aiptek->data_dma);
+					  GFP_KERNEL, &aiptek->data_dma);
         if (!aiptek->data) {
 		dev_warn(&intf->dev, "cannot allocate usb buffer\n");
 		goto fail1;

commit 698c03b4745006e14eccb8270f714d52fac1c97e
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Tue Jan 16 16:56:54 2018 -0800

    Input: inline macros for MODULE_LICENSE, etc
    
    Inline macro for MODULE_LICENSE to make the license information easy to
    find, eg with grep.  Inline the other module-related macros at the same
    time.
    
    A simplified version of the semantic patch for the MODULE_LICENSE
    case is as follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @s@
    identifier i; expression e;
    @@
    
    @@
    declarer name MODULE_LICENSE;
    identifier s.i;
    expression s.e;
    @@
    MODULE_LICENSE(
    - i
    + e
     );
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    [dtor: added a couple of drivers missed by the script, removed a few unused
     DRIVER_VERSION macros]
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 0b55e1f375b3..545fa6e89035 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -78,13 +78,6 @@
 #include <linux/uaccess.h>
 #include <asm/unaligned.h>
 
-/*
- * Version Information
- */
-#define DRIVER_VERSION "v2.3 (May 2, 2007)"
-#define DRIVER_AUTHOR  "Bryan W. Headley/Chris Atenasio/Cedric Brun/Rene van Paassen"
-#define DRIVER_DESC    "Aiptek HyperPen USB Tablet Driver (Linux 2.6.x)"
-
 /*
  * Aiptek status packet:
  *
@@ -1941,8 +1934,8 @@ static struct usb_driver aiptek_driver = {
 
 module_usb_driver(aiptek_driver);
 
-MODULE_AUTHOR(DRIVER_AUTHOR);
-MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR("Bryan W. Headley/Chris Atenasio/Cedric Brun/Rene van Paassen");
+MODULE_DESCRIPTION("Aiptek HyperPen USB Tablet Driver");
 MODULE_LICENSE("GPL");
 
 module_param(programmableDelay, int, 0);

commit c4043b57c867a548f888530351505cc1f86dbfb3
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Mon Jul 10 20:15:30 2017 -0700

    Input: aiptek - constify attribute_group structures
    
    attribute_groups are not supposed to change at runtime. All functions
    working with attribute_groups provided by <linux/sysfs.h> work with const
    attribute_group. So mark the non-const structs as const.
    
    File size before:
       text    data     bss     dec     hex filename
       9941    1560       0   11501    2ced drivers/input/tablet/aiptek.o
    
    File size After adding 'const':
       text    data     bss     dec     hex filename
      10005    1496       0   11501    2ced drivers/input/tablet/aiptek.o
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index d67547bded3e..0b55e1f375b3 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -1676,7 +1676,7 @@ static struct attribute *aiptek_attributes[] = {
 	NULL
 };
 
-static struct attribute_group aiptek_attribute_group = {
+static const struct attribute_group aiptek_attribute_group = {
 	.attrs	= aiptek_attributes,
 };
 

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 4613f0aefd08..d67547bded3e 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -75,7 +75,7 @@
 #include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/usb/input.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <asm/unaligned.h>
 
 /*

commit c630901860c3b8ecc22097269fd4605cf584126c
Author: Oliver Neukum <oneukum@suse.com>
Date:   Thu Mar 31 10:59:59 2016 -0700

    Input: aiptek - stop saving struct usb_device
    
    The device can now easily be derived from the interface.
    Stop leaving a private copy.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 78ca44840d60..4613f0aefd08 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -307,7 +307,6 @@ struct aiptek_settings {
 
 struct aiptek {
 	struct input_dev *inputdev;		/* input device struct           */
-	struct usb_device *usbdev;		/* usb device struct             */
 	struct usb_interface *intf;		/* usb interface struct          */
 	struct urb *urb;			/* urb for incoming reports      */
 	dma_addr_t data_dma;			/* our dma stuffage              */
@@ -847,7 +846,7 @@ static int aiptek_open(struct input_dev *inputdev)
 {
 	struct aiptek *aiptek = input_get_drvdata(inputdev);
 
-	aiptek->urb->dev = aiptek->usbdev;
+	aiptek->urb->dev = interface_to_usbdev(aiptek->intf);
 	if (usb_submit_urb(aiptek->urb, GFP_KERNEL) != 0)
 		return -EIO;
 
@@ -873,8 +872,10 @@ aiptek_set_report(struct aiptek *aiptek,
 		  unsigned char report_type,
 		  unsigned char report_id, void *buffer, int size)
 {
-	return usb_control_msg(aiptek->usbdev,
-			       usb_sndctrlpipe(aiptek->usbdev, 0),
+	struct usb_device *udev = interface_to_usbdev(aiptek->intf);
+
+	return usb_control_msg(udev,
+			       usb_sndctrlpipe(udev, 0),
 			       USB_REQ_SET_REPORT,
 			       USB_TYPE_CLASS | USB_RECIP_INTERFACE |
 			       USB_DIR_OUT, (report_type << 8) + report_id,
@@ -886,8 +887,10 @@ aiptek_get_report(struct aiptek *aiptek,
 		  unsigned char report_type,
 		  unsigned char report_id, void *buffer, int size)
 {
-	return usb_control_msg(aiptek->usbdev,
-			       usb_rcvctrlpipe(aiptek->usbdev, 0),
+	struct usb_device *udev = interface_to_usbdev(aiptek->intf);
+
+	return usb_control_msg(udev,
+			       usb_rcvctrlpipe(udev, 0),
 			       USB_REQ_GET_REPORT,
 			       USB_TYPE_CLASS | USB_RECIP_INTERFACE |
 			       USB_DIR_IN, (report_type << 8) + report_id,
@@ -1729,7 +1732,6 @@ aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	}
 
 	aiptek->inputdev = inputdev;
-	aiptek->usbdev = usbdev;
 	aiptek->intf = intf;
 	aiptek->ifnum = intf->altsetting[0].desc.bInterfaceNumber;
 	aiptek->inDelay = 0;
@@ -1833,8 +1835,8 @@ aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	 * input.
 	 */
 	usb_fill_int_urb(aiptek->urb,
-			 aiptek->usbdev,
-			 usb_rcvintpipe(aiptek->usbdev,
+			 usbdev,
+			 usb_rcvintpipe(usbdev,
 					endpoint->bEndpointAddress),
 			 aiptek->data, 8, aiptek_irq, aiptek,
 			 endpoint->bInterval);

commit 8e20cf2bce122ce9262d6034ee5d5b76fbb92f96
Author: Vladis Dronov <vdronov@redhat.com>
Date:   Tue Dec 1 13:09:17 2015 -0800

    Input: aiptek - fix crash on detecting device without endpoints
    
    The aiptek driver crashes in aiptek_probe() when a specially crafted USB
    device without endpoints is detected. This fix adds a check that the device
    has proper configuration expected by the driver. Also an error return value
    is changed to more matching one in one of the error paths.
    
    Reported-by: Ralf Spenneberg <ralf@spenneberg.net>
    Signed-off-by: Vladis Dronov <vdronov@redhat.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index e7f966da6efa..78ca44840d60 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -1819,6 +1819,14 @@ aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	input_set_abs_params(inputdev, ABS_TILT_Y, AIPTEK_TILT_MIN, AIPTEK_TILT_MAX, 0, 0);
 	input_set_abs_params(inputdev, ABS_WHEEL, AIPTEK_WHEEL_MIN, AIPTEK_WHEEL_MAX - 1, 0, 0);
 
+	/* Verify that a device really has an endpoint */
+	if (intf->altsetting[0].desc.bNumEndpoints < 1) {
+		dev_err(&intf->dev,
+			"interface has %d endpoints, but must have minimum 1\n",
+			intf->altsetting[0].desc.bNumEndpoints);
+		err = -EINVAL;
+		goto fail3;
+	}
 	endpoint = &intf->altsetting[0].endpoint[0].desc;
 
 	/* Go set up our URB, which is called when the tablet receives
@@ -1861,6 +1869,7 @@ aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	if (i == ARRAY_SIZE(speeds)) {
 		dev_info(&intf->dev,
 			 "Aiptek tried all speeds, no sane response\n");
+		err = -EINVAL;
 		goto fail3;
 	}
 

commit bf9a9f8e5105b13cea954b254008f383ed0b4045
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jan 6 10:27:05 2014 -0800

    Input: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index ee83c3904ee8..e7f966da6efa 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -74,7 +74,6 @@
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/module.h>
-#include <linux/init.h>
 #include <linux/usb/input.h>
 #include <asm/uaccess.h>
 #include <asm/unaligned.h>

commit 2c01e7bc46f10e9190818437e564f7e0db875ae9
Merge: ab11ca34eea8 e644dae645e1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 24 10:34:29 2012 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input
    
    Pull input layer updates from Dmitry Torokhov:
     - a bunch of new drivers (DA9052/53 touchscreenn controller, Synaptics
       Navpoint, LM8333 keypads, Wacom I2C touhscreen);
     - updates to existing touchpad drivers (ALPS, Sntelic);
     - Wacom driver now supports Intuos5;
     - device-tree bindings in numerous drivers;
     - other cleanups and fixes.
    
    Fix annoying conflict in drivers/input/tablet/wacom_wac.c that I think
    implies that the input layer device naming is broken, but let's see.  I
    brough it up with Dmitry.
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input: (57 commits)
      Input: matrix-keymap - fix building keymaps
      Input: spear-keyboard - document DT bindings
      Input: spear-keyboard - add device tree bindings
      Input: matrix-keymap - wire up device tree support
      Input: matrix-keymap - uninline and prepare for device tree support
      Input: adp5588 - add support for gpio names
      Input: omap-keypad - dynamically handle register offsets
      Input: synaptics - fix compile warning
      MAINTAINERS: adjust input-related patterns
      Input: ALPS - switch to using input_mt_report_finger_count
      Input: ALPS - add semi-MT support for v4 protocol
      Input: Add Synaptics NavPoint (PXA27x SSP/SPI) driver
      Input: atmel_mxt_ts - dump each message on just 1 line
      Input: atmel_mxt_ts - do not read extra (checksum) byte
      Input: atmel_mxt_ts - verify object size in mxt_write_object
      Input: atmel_mxt_ts - only allow root to update firmware
      Input: atmel_mxt_ts - use CONFIG_PM_SLEEP
      Input: sentelic - report device's production serial number
      Input: tl6040-vibra - Device Tree support
      Input: evdev - properly handle read/write with count 0
      ...

commit 871ba51c130d4f2e7d33b8c57e834df701357102
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri May 4 15:33:06 2012 -0700

    USB: input: aiptek.c: fix up dev_* messages
    
    Previously I had made the struct device point to the input device, but
    after talking with Dmitry, he said that the USB device would make more
    sense for this driver to point to.  So converted it to use that instead.
    
    CC: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    CC: Jesper Juhl <jj@chaosbits.net>
    CC: JJ Ding <dgdunix@gmail.com>
    CC: Edwin van Vliet <edwin@cheatah.nl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 37dba769bf0f..755a39e4c9e9 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -309,6 +309,7 @@ struct aiptek_settings {
 struct aiptek {
 	struct input_dev *inputdev;		/* input device struct           */
 	struct usb_device *usbdev;		/* usb device struct             */
+	struct usb_interface *intf;		/* usb interface struct          */
 	struct urb *urb;			/* urb for incoming reports      */
 	dma_addr_t data_dma;			/* our dma stuffage              */
 	struct aiptek_features features;	/* tablet's array of features    */
@@ -435,6 +436,7 @@ static void aiptek_irq(struct urb *urb)
 	struct aiptek *aiptek = urb->context;
 	unsigned char *data = aiptek->data;
 	struct input_dev *inputdev = aiptek->inputdev;
+	struct usb_interface *intf = aiptek->intf;
 	int jitterable = 0;
 	int retval, macro, x, y, z, left, right, middle, p, dv, tip, bs, pck;
 
@@ -447,14 +449,12 @@ static void aiptek_irq(struct urb *urb)
 	case -ENOENT:
 	case -ESHUTDOWN:
 		/* This urb is terminated, clean up */
-		dev_dbg(&inputdev->dev,
-			"%s - urb shutting down with status: %d\n",
+		dev_dbg(&intf->dev, "%s - urb shutting down with status: %d\n",
 			__func__, urb->status);
 		return;
 
 	default:
-		dev_dbg(&inputdev->dev,
-			"%s - nonzero urb status received: %d\n",
+		dev_dbg(&intf->dev, "%s - nonzero urb status received: %d\n",
 			__func__, urb->status);
 		goto exit;
 	}
@@ -787,7 +787,7 @@ static void aiptek_irq(struct urb *urb)
 				 1 | AIPTEK_REPORT_TOOL_UNKNOWN);
 		input_sync(inputdev);
 	} else {
-		dev_dbg(&inputdev->dev, "Unknown report %d\n", data[0]);
+		dev_dbg(&intf->dev, "Unknown report %d\n", data[0]);
 	}
 
 	/* Jitter may occur when the user presses a button on the stlyus
@@ -813,7 +813,7 @@ static void aiptek_irq(struct urb *urb)
 exit:
 	retval = usb_submit_urb(urb, GFP_ATOMIC);
 	if (retval != 0) {
-		dev_err(&inputdev->dev,
+		dev_err(&intf->dev,
 			"%s - usb_submit_urb failed with result %d\n",
 			__func__, retval);
 	}
@@ -915,7 +915,7 @@ aiptek_command(struct aiptek *aiptek, unsigned char command, unsigned char data)
 
 	if ((ret =
 	     aiptek_set_report(aiptek, 3, 2, buf, sizeof_buf)) != sizeof_buf) {
-		dev_dbg(&aiptek->inputdev->dev,
+		dev_dbg(&aiptek->intf->dev,
 			"aiptek_program: failed, tried to send: 0x%02x 0x%02x\n",
 			command, data);
 	}
@@ -951,7 +951,7 @@ aiptek_query(struct aiptek *aiptek, unsigned char command, unsigned char data)
 
 	if ((ret =
 	     aiptek_get_report(aiptek, 3, 2, buf, sizeof_buf)) != sizeof_buf) {
-		dev_dbg(&aiptek->inputdev->dev,
+		dev_dbg(&aiptek->intf->dev,
 			"aiptek_query failed: returned 0x%02x 0x%02x 0x%02x\n",
 			buf[0], buf[1], buf[2]);
 		ret = -EIO;
@@ -1731,6 +1731,7 @@ aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 
 	aiptek->inputdev = inputdev;
 	aiptek->usbdev = usbdev;
+	aiptek->intf = intf;
 	aiptek->ifnum = intf->altsetting[0].desc.bInterfaceNumber;
 	aiptek->inDelay = 0;
 	aiptek->endDelay = 0;

commit 8fb6321b6bd9ebcc03243f27fe98e18e246a5c97
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue May 1 21:33:12 2012 -0700

    USB: aiptek.c: remove dbg() usage
    
    dbg() was a very old USB-specific macro that should no longer
    be used. This patch removes it from being used in the driver
    and uses dev_dbg() instead.
    
    CC: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    CC: Jesper Juhl <jj@chaosbits.net>
    CC: JJ Ding <dgdunix@gmail.com>
    CC: Edwin van Vliet <edwin@cheatah.nl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index dc16bfd24738..37dba769bf0f 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -447,13 +447,15 @@ static void aiptek_irq(struct urb *urb)
 	case -ENOENT:
 	case -ESHUTDOWN:
 		/* This urb is terminated, clean up */
-		dbg("%s - urb shutting down with status: %d",
-		    __func__, urb->status);
+		dev_dbg(&inputdev->dev,
+			"%s - urb shutting down with status: %d\n",
+			__func__, urb->status);
 		return;
 
 	default:
-		dbg("%s - nonzero urb status received: %d",
-		    __func__, urb->status);
+		dev_dbg(&inputdev->dev,
+			"%s - nonzero urb status received: %d\n",
+			__func__, urb->status);
 		goto exit;
 	}
 
@@ -785,7 +787,7 @@ static void aiptek_irq(struct urb *urb)
 				 1 | AIPTEK_REPORT_TOOL_UNKNOWN);
 		input_sync(inputdev);
 	} else {
-		dbg("Unknown report %d", data[0]);
+		dev_dbg(&inputdev->dev, "Unknown report %d\n", data[0]);
 	}
 
 	/* Jitter may occur when the user presses a button on the stlyus
@@ -913,8 +915,9 @@ aiptek_command(struct aiptek *aiptek, unsigned char command, unsigned char data)
 
 	if ((ret =
 	     aiptek_set_report(aiptek, 3, 2, buf, sizeof_buf)) != sizeof_buf) {
-		dbg("aiptek_program: failed, tried to send: 0x%02x 0x%02x",
-		    command, data);
+		dev_dbg(&aiptek->inputdev->dev,
+			"aiptek_program: failed, tried to send: 0x%02x 0x%02x\n",
+			command, data);
 	}
 	kfree(buf);
 	return ret < 0 ? ret : 0;
@@ -948,8 +951,9 @@ aiptek_query(struct aiptek *aiptek, unsigned char command, unsigned char data)
 
 	if ((ret =
 	     aiptek_get_report(aiptek, 3, 2, buf, sizeof_buf)) != sizeof_buf) {
-		dbg("aiptek_query failed: returned 0x%02x 0x%02x 0x%02x",
-		    buf[0], buf[1], buf[2]);
+		dev_dbg(&aiptek->inputdev->dev,
+			"aiptek_query failed: returned 0x%02x 0x%02x 0x%02x\n",
+			buf[0], buf[1], buf[2]);
 		ret = -EIO;
 	} else {
 		ret = get_unaligned_le16(buf + 1);

commit 383c52f3388b5ddb2fbf1ec073081bc9c4bdfeff
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue May 1 20:56:56 2012 -0400

    USB: input: aiptek.c: fix up dev_err() usage
    
    We should always reference the input device for dev_err(), not the USB
    device.  Fix up the places where I got this wrong.
    
    Reported-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    CC: Jesper Juhl <jj@chaosbits.net>
    CC: JJ Ding <dgdunix@gmail.com>
    CC: Edwin van Vliet <edwin@cheatah.nl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index b8d43eb3c8f1..dc16bfd24738 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -811,7 +811,7 @@ static void aiptek_irq(struct urb *urb)
 exit:
 	retval = usb_submit_urb(urb, GFP_ATOMIC);
 	if (retval != 0) {
-		dev_err(&aiptek->usbdev->dev,
+		dev_err(&inputdev->dev,
 			"%s - usb_submit_urb failed with result %d\n",
 			__func__, retval);
 	}

commit 1f80bb943d755d48b894c677097fd80c7d7cce16
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Apr 25 14:48:36 2012 -0700

    USB: aiptek.c: remove err() usage
    
    err() was a very old USB-specific macro that I thought had
    gone away.  This patch removes it from being used in the
    driver and uses dev_err() instead.
    
    CC: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    CC: Jesper Juhl <jj@chaosbits.net>
    CC: JJ Ding <dgdunix@gmail.com>
    CC: Edwin van Vliet <edwin@cheatah.nl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 205d16aab441..b8d43eb3c8f1 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -811,8 +811,9 @@ static void aiptek_irq(struct urb *urb)
 exit:
 	retval = usb_submit_urb(urb, GFP_ATOMIC);
 	if (retval != 0) {
-		err("%s - usb_submit_urb failed with result %d",
-		    __func__, retval);
+		dev_err(&aiptek->usbdev->dev,
+			"%s - usb_submit_urb failed with result %d\n",
+			__func__, retval);
 	}
 }
 

commit 482d74ceb09db45b5d19fd1ae3810b38afbc0518
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Mon Apr 23 22:26:58 2012 -0700

    Input: aiptek - adjust error-handling code label
    
    At the point of this error-handling code, aiptek->urb has been allocated,
    and it does not appear to be less necessary to free it here than in the
    error-handling code just below.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 205d16aab441..a33d3470c47a 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -1856,7 +1856,7 @@ aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	if (i == ARRAY_SIZE(speeds)) {
 		dev_info(&intf->dev,
 			 "Aiptek tried all speeds, no sane response\n");
-		goto fail2;
+		goto fail3;
 	}
 
 	/* Associate this driver's struct with the usb interface.

commit dbe950f201a8edd353b0bd9079e8d536ee4ce37c
Merge: f62f61917d72 da733563be5a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 10 10:55:52 2012 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input: (64 commits)
      Input: tc3589x-keypad - add missing kerneldoc
      Input: ucb1400-ts - switch to using dev_xxx() for diagnostic messages
      Input: ucb1400_ts - convert to threaded IRQ
      Input: ucb1400_ts - drop inline annotations
      Input: usb1400_ts - add __devinit/__devexit section annotations
      Input: ucb1400_ts - set driver owner
      Input: ucb1400_ts - convert to use dev_pm_ops
      Input: psmouse - make sure we do not use stale methods
      Input: evdev - do not block waiting for an event if fd is nonblock
      Input: evdev - if no events and non-block, return EAGAIN not 0
      Input: evdev - only allow reading events if a full packet is present
      Input: add driver for pixcir i2c touchscreens
      Input: samsung-keypad - implement runtime power management support
      Input: tegra-kbc - report wakeup key for some platforms
      Input: tegra-kbc - add device tree bindings
      Input: add driver for AUO In-Cell touchscreens using pixcir ICs
      Input: mpu3050 - configure the sampling method
      Input: mpu3050 - ensure we enable interrupts
      Input: mpu3050 - add of_match table for device-tree probing
      Input: sentelic - document the latest hardware
      ...
    
    Fix up fairly trivial conflicts (device tree matching conflicting with
    some independent cleanups) in drivers/input/keyboard/samsung-keypad.c

commit 08642e7c52cf43616821520828e504bc717e54a6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Nov 18 09:48:31 2011 -0800

    USB: convert drivers/input/* to use module_usb_driver()
    
    This converts the drivers in drivers/input/* to use the
    module_usb_driver() macro which makes the code smaller and a bit
    simpler.
    
    Added bonus is that it removes some unneeded kernel log messages about
    drivers loading and/or unloading.
    
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Ville Syrjala <syrjala@sci.fi>
    Cc: Henk Vergonet <Henk.Vergonet@gmail.com>
    Cc: Alessandro Rubini <rubini@ipvvis.unipv.it>
    Cc: Henrik Rydberg <rydberg@euromail.se>
    Cc: "Magnus HÃ¶rlin" <magnus@alefors.se>
    Cc: Chris Moeller <kode54@gmail.c>
    Cc: Christoph Fritz <chf.fritz@googlemail.com>
    Cc: Lucas De Marchi <lucas.demarchi@profusion.mobi>
    Cc: Jesper Juhl <jj@chaosbits.net>
    Cc: Edwin van Vliet <edwin@cheatah.nl>
    Cc: Ping Cheng <pingc@wacom.com>
    Cc: Eduard Hasenleithner <eduard@hasenleithner.at>
    Cc: Alexander Strakh <strakh@ispras.ru>
    Cc: Glenn Sommer <gsommer@datanordisk.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 6d89fd1842c3..d5ef3debd045 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -1919,21 +1919,7 @@ static struct usb_driver aiptek_driver = {
 	.id_table = aiptek_ids,
 };
 
-static int __init aiptek_init(void)
-{
-	int result = usb_register(&aiptek_driver);
-	if (result == 0) {
-		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-		       DRIVER_DESC "\n");
-		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_AUTHOR "\n");
-	}
-	return result;
-}
-
-static void __exit aiptek_exit(void)
-{
-	usb_deregister(&aiptek_driver);
-}
+module_usb_driver(aiptek_driver);
 
 MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);
@@ -1943,6 +1929,3 @@ module_param(programmableDelay, int, 0);
 MODULE_PARM_DESC(programmableDelay, "delay used during tablet programming");
 module_param(jitterDelay, int, 0);
 MODULE_PARM_DESC(jitterDelay, "stylus/mouse settlement delay");
-
-module_init(aiptek_init);
-module_exit(aiptek_exit);

commit 76496e7a02e99d42844f4fffa145b81e513e7acd
Author: JJ Ding <dgdunix@gmail.com>
Date:   Wed Nov 9 10:20:14 2011 -0800

    Input: convert obsolete strict_strtox to kstrtox
    
    With commit 67d0a0754455f89ef3946946159d8ec9e45ce33a we mark strict_strtox
    as obsolete. Convert all remaining such uses in drivers/input/.
    
    Also change long to appropriate types, and return error conditions
    from kstrtox separately, as Dmitry sugguests.
    
    Signed-off-by: JJ Ding <dgdunix@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 6d89fd1842c3..85bace2c8fe8 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -1198,9 +1198,9 @@ static ssize_t
 store_tabletXtilt(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
-	long x;
+	int x;
 
-	if (strict_strtol(buf, 10, &x)) {
+	if (kstrtoint(buf, 10, &x)) {
 		size_t len = buf[count - 1] == '\n' ? count - 1 : count;
 
 		if (strncmp(buf, "disable", len))
@@ -1240,9 +1240,9 @@ static ssize_t
 store_tabletYtilt(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
-	long y;
+	int y;
 
-	if (strict_strtol(buf, 10, &y)) {
+	if (kstrtoint(buf, 10, &y)) {
 		size_t len = buf[count - 1] == '\n' ? count - 1 : count;
 
 		if (strncmp(buf, "disable", len))
@@ -1277,12 +1277,13 @@ static ssize_t
 store_tabletJitterDelay(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
-	long j;
+	int err, j;
 
-	if (strict_strtol(buf, 10, &j))
-		return -EINVAL;
+	err = kstrtoint(buf, 10, &j);
+	if (err)
+		return err;
 
-	aiptek->newSetting.jitterDelay = (int)j;
+	aiptek->newSetting.jitterDelay = j;
 	return count;
 }
 
@@ -1306,12 +1307,13 @@ static ssize_t
 store_tabletProgrammableDelay(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
-	long d;
+	int err, d;
 
-	if (strict_strtol(buf, 10, &d))
-		return -EINVAL;
+	err = kstrtoint(buf, 10, &d);
+	if (err)
+		return err;
 
-	aiptek->newSetting.programmableDelay = (int)d;
+	aiptek->newSetting.programmableDelay = d;
 	return count;
 }
 
@@ -1557,11 +1559,13 @@ static ssize_t
 store_tabletWheel(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
-	long w;
+	int err, w;
 
-	if (strict_strtol(buf, 10, &w)) return -EINVAL;
+	err = kstrtoint(buf, 10, &w);
+	if (err)
+		return err;
 
-	aiptek->newSetting.wheel = (int)w;
+	aiptek->newSetting.wheel = w;
 	return count;
 }
 

commit eadba0c9c41bfa840b0f1e9ee369a869c2a322b3
Author: Edwin van Vliet <edwin@cheatah.nl>
Date:   Sun Jul 10 16:07:28 2011 -0700

    Input: aiptek - remove double define
    
    Constant AIPTEK_TOOL_BUTTON_PEN_MODE was defined twice.
    
    Signed-off-by: Edwin van Vliet <edwin@cheatah.nl>
    Reviewed-by: Jesper Juhl <jj@chaosbits.net>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 0a619c558bfb..6d89fd1842c3 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -225,7 +225,6 @@
 	/* toolMode codes
 	 */
 #define AIPTEK_TOOL_BUTTON_PEN_MODE			BTN_TOOL_PEN
-#define AIPTEK_TOOL_BUTTON_PEN_MODE			BTN_TOOL_PEN
 #define AIPTEK_TOOL_BUTTON_PENCIL_MODE			BTN_TOOL_PENCIL
 #define AIPTEK_TOOL_BUTTON_BRUSH_MODE			BTN_TOOL_BRUSH
 #define AIPTEK_TOOL_BUTTON_AIRBRUSH_MODE		BTN_TOOL_AIRBRUSH

commit 6f07d31e46639e4b1b23de6ee88c9e079a7bf32d
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Mon Nov 15 13:33:25 2010 -0800

    Input: aiptek - tighten up permissions on sysfs attributes
    
    Sysfs attributes affecting device behavior should not be, by default,
    world-writeable. If distributions want to allow console users access
    these attributes they need to employ udev and friends to adjust
    permissions as needed.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 57b25b84d1fc..0a619c558bfb 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -1097,7 +1097,7 @@ store_tabletPointerMode(struct device *dev, struct device_attribute *attr, const
 }
 
 static DEVICE_ATTR(pointer_mode,
-		   S_IRUGO | S_IWUGO,
+		   S_IRUGO | S_IWUSR,
 		   show_tabletPointerMode, store_tabletPointerMode);
 
 /***********************************************************************
@@ -1134,7 +1134,7 @@ store_tabletCoordinateMode(struct device *dev, struct device_attribute *attr, co
 }
 
 static DEVICE_ATTR(coordinate_mode,
-		   S_IRUGO | S_IWUGO,
+		   S_IRUGO | S_IWUSR,
 		   show_tabletCoordinateMode, store_tabletCoordinateMode);
 
 /***********************************************************************
@@ -1176,7 +1176,7 @@ store_tabletToolMode(struct device *dev, struct device_attribute *attr, const ch
 }
 
 static DEVICE_ATTR(tool_mode,
-		   S_IRUGO | S_IWUGO,
+		   S_IRUGO | S_IWUSR,
 		   show_tabletToolMode, store_tabletToolMode);
 
 /***********************************************************************
@@ -1219,7 +1219,7 @@ store_tabletXtilt(struct device *dev, struct device_attribute *attr, const char
 }
 
 static DEVICE_ATTR(xtilt,
-		   S_IRUGO | S_IWUGO, show_tabletXtilt, store_tabletXtilt);
+		   S_IRUGO | S_IWUSR, show_tabletXtilt, store_tabletXtilt);
 
 /***********************************************************************
  * support routines for the 'ytilt' file. Note that this file
@@ -1261,7 +1261,7 @@ store_tabletYtilt(struct device *dev, struct device_attribute *attr, const char
 }
 
 static DEVICE_ATTR(ytilt,
-		   S_IRUGO | S_IWUGO, show_tabletYtilt, store_tabletYtilt);
+		   S_IRUGO | S_IWUSR, show_tabletYtilt, store_tabletYtilt);
 
 /***********************************************************************
  * support routines for the 'jitter' file. Note that this file
@@ -1288,7 +1288,7 @@ store_tabletJitterDelay(struct device *dev, struct device_attribute *attr, const
 }
 
 static DEVICE_ATTR(jitter,
-		   S_IRUGO | S_IWUGO,
+		   S_IRUGO | S_IWUSR,
 		   show_tabletJitterDelay, store_tabletJitterDelay);
 
 /***********************************************************************
@@ -1317,7 +1317,7 @@ store_tabletProgrammableDelay(struct device *dev, struct device_attribute *attr,
 }
 
 static DEVICE_ATTR(delay,
-		   S_IRUGO | S_IWUGO,
+		   S_IRUGO | S_IWUSR,
 		   show_tabletProgrammableDelay, store_tabletProgrammableDelay);
 
 /***********************************************************************
@@ -1406,7 +1406,7 @@ store_tabletStylusUpper(struct device *dev, struct device_attribute *attr, const
 }
 
 static DEVICE_ATTR(stylus_upper,
-		   S_IRUGO | S_IWUGO,
+		   S_IRUGO | S_IWUSR,
 		   show_tabletStylusUpper, store_tabletStylusUpper);
 
 /***********************************************************************
@@ -1437,7 +1437,7 @@ store_tabletStylusLower(struct device *dev, struct device_attribute *attr, const
 }
 
 static DEVICE_ATTR(stylus_lower,
-		   S_IRUGO | S_IWUGO,
+		   S_IRUGO | S_IWUSR,
 		   show_tabletStylusLower, store_tabletStylusLower);
 
 /***********************************************************************
@@ -1475,7 +1475,7 @@ store_tabletMouseLeft(struct device *dev, struct device_attribute *attr, const c
 }
 
 static DEVICE_ATTR(mouse_left,
-		   S_IRUGO | S_IWUGO,
+		   S_IRUGO | S_IWUSR,
 		   show_tabletMouseLeft, store_tabletMouseLeft);
 
 /***********************************************************************
@@ -1505,7 +1505,7 @@ store_tabletMouseMiddle(struct device *dev, struct device_attribute *attr, const
 }
 
 static DEVICE_ATTR(mouse_middle,
-		   S_IRUGO | S_IWUGO,
+		   S_IRUGO | S_IWUSR,
 		   show_tabletMouseMiddle, store_tabletMouseMiddle);
 
 /***********************************************************************
@@ -1535,7 +1535,7 @@ store_tabletMouseRight(struct device *dev, struct device_attribute *attr, const
 }
 
 static DEVICE_ATTR(mouse_right,
-		   S_IRUGO | S_IWUGO,
+		   S_IRUGO | S_IWUSR,
 		   show_tabletMouseRight, store_tabletMouseRight);
 
 /***********************************************************************
@@ -1567,7 +1567,7 @@ store_tabletWheel(struct device *dev, struct device_attribute *attr, const char
 }
 
 static DEVICE_ATTR(wheel,
-		   S_IRUGO | S_IWUGO, show_tabletWheel, store_tabletWheel);
+		   S_IRUGO | S_IWUSR, show_tabletWheel, store_tabletWheel);
 
 /***********************************************************************
  * support routines for the 'execute' file. Note that this file
@@ -1600,7 +1600,7 @@ store_tabletExecute(struct device *dev, struct device_attribute *attr, const cha
 }
 
 static DEVICE_ATTR(execute,
-		   S_IRUGO | S_IWUGO, show_tabletExecute, store_tabletExecute);
+		   S_IRUGO | S_IWUSR, show_tabletExecute, store_tabletExecute);
 
 /***********************************************************************
  * support routines for the 'odm_code' file. Note that this file

commit 987a6c0298260b7aa40702b349282554d6180e4b
Author: Daniel Mack <daniel@caiaq.de>
Date:   Mon Aug 2 20:15:17 2010 -0700

    Input: switch to input_abs_*() access functions
    
    Change all call sites in drivers/input to not access the ABS axis
    information directly anymore. Make them use the access helpers instead.
    
    Also use input_set_abs_params() when possible.
    Did some code refactoring as I was on it.
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Cc: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 51b80b08d467..57b25b84d1fc 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -987,20 +987,17 @@ static int aiptek_program_tablet(struct aiptek *aiptek)
 	/* Query getXextension */
 	if ((ret = aiptek_query(aiptek, 0x01, 0x00)) < 0)
 		return ret;
-	aiptek->inputdev->absmin[ABS_X] = 0;
-	aiptek->inputdev->absmax[ABS_X] = ret - 1;
+	input_set_abs_params(aiptek->inputdev, ABS_X, 0, ret - 1, 0, 0);
 
 	/* Query getYextension */
 	if ((ret = aiptek_query(aiptek, 0x01, 0x01)) < 0)
 		return ret;
-	aiptek->inputdev->absmin[ABS_Y] = 0;
-	aiptek->inputdev->absmax[ABS_Y] = ret - 1;
+	input_set_abs_params(aiptek->inputdev, ABS_Y, 0, ret - 1, 0, 0);
 
 	/* Query getPressureLevels */
 	if ((ret = aiptek_query(aiptek, 0x08, 0x00)) < 0)
 		return ret;
-	aiptek->inputdev->absmin[ABS_PRESSURE] = 0;
-	aiptek->inputdev->absmax[ABS_PRESSURE] = ret - 1;
+	input_set_abs_params(aiptek->inputdev, ABS_PRESSURE, 0, ret - 1, 0, 0);
 
 	/* Depending on whether we are in absolute or relative mode, we will
 	 * do a switchToTablet(absolute) or switchToMouse(relative) command.
@@ -1054,8 +1051,8 @@ static ssize_t show_tabletSize(struct device *dev, struct device_attribute *attr
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 
 	return snprintf(buf, PAGE_SIZE, "%dx%d\n",
-			aiptek->inputdev->absmax[ABS_X] + 1,
-			aiptek->inputdev->absmax[ABS_Y] + 1);
+			input_abs_get_max(aiptek->inputdev, ABS_X) + 1,
+			input_abs_get_max(aiptek->inputdev, ABS_Y) + 1);
 }
 
 /* These structs define the sysfs files, param #1 is the name of the
@@ -1843,7 +1840,7 @@ aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	for (i = 0; i < ARRAY_SIZE(speeds); ++i) {
 		aiptek->curSetting.programmableDelay = speeds[i];
 		(void)aiptek_program_tablet(aiptek);
-		if (aiptek->inputdev->absmax[ABS_X] > 0) {
+		if (input_abs_get_max(aiptek->inputdev, ABS_X) > 0) {
 			dev_info(&intf->dev,
 				 "Aiptek using %d ms programming speed\n",
 				 aiptek->curSetting.programmableDelay);

commit 997ea58eb92f9970b8af7aae48800d0ef43b9423
Author: Daniel Mack <daniel@caiaq.de>
Date:   Mon Apr 12 13:17:25 2010 +0200

    USB: rename usb_buffer_alloc() and usb_buffer_free() users
    
    For more clearance what the functions actually do,
    
      usb_buffer_alloc() is renamed to usb_alloc_coherent()
      usb_buffer_free()  is renamed to usb_free_coherent()
    
    They should only be used in code which really needs DMA coherency.
    
    All call sites have been changed accordingly, except for staging
    drivers.
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Pedro Ribeiro <pedrib@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 4be039d7dcad..51b80b08d467 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -1711,8 +1711,8 @@ aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 		goto fail1;
         }
 
-	aiptek->data = usb_buffer_alloc(usbdev, AIPTEK_PACKET_LENGTH,
-					GFP_ATOMIC, &aiptek->data_dma);
+	aiptek->data = usb_alloc_coherent(usbdev, AIPTEK_PACKET_LENGTH,
+					  GFP_ATOMIC, &aiptek->data_dma);
         if (!aiptek->data) {
 		dev_warn(&intf->dev, "cannot allocate usb buffer\n");
 		goto fail1;
@@ -1884,8 +1884,8 @@ aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 
  fail4:	sysfs_remove_group(&intf->dev.kobj, &aiptek_attribute_group);
  fail3: usb_free_urb(aiptek->urb);
- fail2:	usb_buffer_free(usbdev, AIPTEK_PACKET_LENGTH, aiptek->data,
-			aiptek->data_dma);
+ fail2:	usb_free_coherent(usbdev, AIPTEK_PACKET_LENGTH, aiptek->data,
+			  aiptek->data_dma);
  fail1: usb_set_intfdata(intf, NULL);
 	input_free_device(inputdev);
 	kfree(aiptek);
@@ -1909,9 +1909,9 @@ static void aiptek_disconnect(struct usb_interface *intf)
 		input_unregister_device(aiptek->inputdev);
 		sysfs_remove_group(&intf->dev.kobj, &aiptek_attribute_group);
 		usb_free_urb(aiptek->urb);
-		usb_buffer_free(interface_to_usbdev(intf),
-				AIPTEK_PACKET_LENGTH,
-				aiptek->data, aiptek->data_dma);
+		usb_free_coherent(interface_to_usbdev(intf),
+				  AIPTEK_PACKET_LENGTH,
+				  aiptek->data, aiptek->data_dma);
 		kfree(aiptek);
 	}
 }

commit c9404c9c392d557a4687c4cbda022b03cb787ce9
Author: Adam Buchbinder <adam.buchbinder@gmail.com>
Date:   Fri Dec 18 15:40:42 2009 -0500

    Fix misspelling of "should" and "shouldn't" in comments.
    
    Some comments misspell "should" or "shouldn't"; this fixes them. No code changes.
    
    Signed-off-by: Adam Buchbinder <adam.buchbinder@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 7d005a3616d7..4be039d7dcad 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -362,7 +362,7 @@ static const int macroKeyEvents[] = {
 };
 
 /***********************************************************************
- * Map values to strings and back. Every map shoudl have the following
+ * Map values to strings and back. Every map should have the following
  * as its last element: { NULL, AIPTEK_INVALID_VALUE }.
  */
 #define AIPTEK_INVALID_VALUE	-1

commit 899ef6e7cf2f057fcfd8071b36de04117313242b
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Aug 18 13:21:04 2008 -0700

    USB: remove info() macro from usb input drivers
    
    USB should not be having it's own printk macros, so remove info() and
    use the system-wide standard of dev_info() wherever possible.
    
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 1aa82e8af614..7d005a3616d7 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -1844,8 +1844,9 @@ aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 		aiptek->curSetting.programmableDelay = speeds[i];
 		(void)aiptek_program_tablet(aiptek);
 		if (aiptek->inputdev->absmax[ABS_X] > 0) {
-			info("input: Aiptek using %d ms programming speed\n",
-			     aiptek->curSetting.programmableDelay);
+			dev_info(&intf->dev,
+				 "Aiptek using %d ms programming speed\n",
+				 aiptek->curSetting.programmableDelay);
 			break;
 		}
 	}
@@ -1853,7 +1854,8 @@ aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	/* Murphy says that some day someone will have a tablet that fails the
 	   above test. That's you, Frederic Rodrigo */
 	if (i == ARRAY_SIZE(speeds)) {
-		info("input: Aiptek tried all speeds, no sane response");
+		dev_info(&intf->dev,
+			 "Aiptek tried all speeds, no sane response\n");
 		goto fail2;
 	}
 
@@ -1925,8 +1927,9 @@ static int __init aiptek_init(void)
 {
 	int result = usb_register(&aiptek_driver);
 	if (result == 0) {
-		info(DRIVER_VERSION ": " DRIVER_AUTHOR);
-		info(DRIVER_DESC);
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+		       DRIVER_DESC "\n");
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_AUTHOR "\n");
 	}
 	return result;
 }

commit 1817b1692a2eab022e805d32e910f4556c89dce8
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Aug 14 09:37:34 2008 -0700

    USB: remove warn() macro from usb input drivers
    
    USB should not be having it's own printk macros, so remove warn() and
    use the system-wide standard of dev_warn() wherever possible.  In the
    few places that will not work out, use a basic printk().
    
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index e53c838f1866..1aa82e8af614 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -1706,20 +1706,21 @@ aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	aiptek = kzalloc(sizeof(struct aiptek), GFP_KERNEL);
 	inputdev = input_allocate_device();
 	if (!aiptek || !inputdev) {
-		warn("aiptek: cannot allocate memory or input device");
+		dev_warn(&intf->dev,
+			 "cannot allocate memory or input device\n");
 		goto fail1;
         }
 
 	aiptek->data = usb_buffer_alloc(usbdev, AIPTEK_PACKET_LENGTH,
 					GFP_ATOMIC, &aiptek->data_dma);
         if (!aiptek->data) {
-		warn("aiptek: cannot allocate usb buffer");
+		dev_warn(&intf->dev, "cannot allocate usb buffer\n");
 		goto fail1;
 	}
 
 	aiptek->urb = usb_alloc_urb(0, GFP_KERNEL);
 	if (!aiptek->urb) {
-	        warn("aiptek: cannot allocate urb");
+	        dev_warn(&intf->dev, "cannot allocate urb\n");
 		goto fail2;
 	}
 
@@ -1864,7 +1865,8 @@ aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	 */
 	err = sysfs_create_group(&intf->dev.kobj, &aiptek_attribute_group);
 	if (err) {
-		warn("aiptek: cannot create sysfs group err: %d", err);
+		dev_warn(&intf->dev, "cannot create sysfs group err: %d\n",
+			 err);
 		goto fail3;
         }
 
@@ -1872,7 +1874,8 @@ aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	 */
 	err = input_register_device(aiptek->inputdev);
 	if (err) {
-		warn("aiptek: input_register_device returned err: %d", err);
+		dev_warn(&intf->dev,
+			 "input_register_device returned err: %d\n", err);
 		goto fail4;
         }
 	return 0;

commit 160f1fef7e52e974489b3c70fbd4e094c06965c2
Author: Joe Rouvier <joe@rouvier.org>
Date:   Sun Aug 10 00:29:25 2008 -0400

    Input: convert drivers to use strict_strtoul()
    
    strict_strtoul() allows newline character at the end of the the input
    string and therefore is more user-friendly.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 8f037a1d44a6..e53c838f1866 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -1202,16 +1202,22 @@ static ssize_t
 store_tabletXtilt(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
-	int x;
+	long x;
+
+	if (strict_strtol(buf, 10, &x)) {
+		size_t len = buf[count - 1] == '\n' ? count - 1 : count;
+
+		if (strncmp(buf, "disable", len))
+			return -EINVAL;
 
-	if (strcmp(buf, "disable") == 0) {
 		aiptek->newSetting.xTilt = AIPTEK_TILT_DISABLE;
 	} else {
-		x = (int)simple_strtol(buf, NULL, 10);
-		if (x >= AIPTEK_TILT_MIN && x <= AIPTEK_TILT_MAX) {
-			aiptek->newSetting.xTilt = x;
-		}
+		if (x < AIPTEK_TILT_MIN || x > AIPTEK_TILT_MAX)
+			return -EINVAL;
+
+		aiptek->newSetting.xTilt = x;
 	}
+
 	return count;
 }
 
@@ -1238,16 +1244,22 @@ static ssize_t
 store_tabletYtilt(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
-	int y;
+	long y;
+
+	if (strict_strtol(buf, 10, &y)) {
+		size_t len = buf[count - 1] == '\n' ? count - 1 : count;
+
+		if (strncmp(buf, "disable", len))
+			return -EINVAL;
 
-	if (strcmp(buf, "disable") == 0) {
 		aiptek->newSetting.yTilt = AIPTEK_TILT_DISABLE;
 	} else {
-		y = (int)simple_strtol(buf, NULL, 10);
-		if (y >= AIPTEK_TILT_MIN && y <= AIPTEK_TILT_MAX) {
-			aiptek->newSetting.yTilt = y;
-		}
+		if (y < AIPTEK_TILT_MIN || y > AIPTEK_TILT_MAX)
+			return -EINVAL;
+
+		aiptek->newSetting.yTilt = y;
 	}
+
 	return count;
 }
 
@@ -1269,8 +1281,12 @@ static ssize_t
 store_tabletJitterDelay(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
+	long j;
+
+	if (strict_strtol(buf, 10, &j))
+		return -EINVAL;
 
-	aiptek->newSetting.jitterDelay = (int)simple_strtol(buf, NULL, 10);
+	aiptek->newSetting.jitterDelay = (int)j;
 	return count;
 }
 
@@ -1294,8 +1310,12 @@ static ssize_t
 store_tabletProgrammableDelay(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
+	long d;
 
-	aiptek->newSetting.programmableDelay = (int)simple_strtol(buf, NULL, 10);
+	if (strict_strtol(buf, 10, &d))
+		return -EINVAL;
+
+	aiptek->newSetting.programmableDelay = (int)d;
 	return count;
 }
 
@@ -1541,8 +1561,11 @@ static ssize_t
 store_tabletWheel(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
+	long w;
+
+	if (strict_strtol(buf, 10, &w)) return -EINVAL;
 
-	aiptek->newSetting.wheel = (int)simple_strtol(buf, NULL, 10);
+	aiptek->newSetting.wheel = (int)w;
 	return count;
 }
 

commit ea3e6c59266b783b103c0f42a8de5dbe565a43d4
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon May 5 11:36:18 2008 -0400

    Input: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 55c1134d6137..8f037a1d44a6 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -449,12 +449,12 @@ static void aiptek_irq(struct urb *urb)
 	case -ESHUTDOWN:
 		/* This urb is terminated, clean up */
 		dbg("%s - urb shutting down with status: %d",
-		    __FUNCTION__, urb->status);
+		    __func__, urb->status);
 		return;
 
 	default:
 		dbg("%s - nonzero urb status received: %d",
-		    __FUNCTION__, urb->status);
+		    __func__, urb->status);
 		goto exit;
 	}
 
@@ -813,7 +813,7 @@ static void aiptek_irq(struct urb *urb)
 	retval = usb_submit_urb(urb, GFP_ATOMIC);
 	if (retval != 0) {
 		err("%s - usb_submit_urb failed with result %d",
-		    __FUNCTION__, retval);
+		    __func__, retval);
 	}
 }
 

commit 858ad08cf4c32a51d26552d3cb5fa8d5e2f0e579
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Tue Apr 29 01:03:34 2008 -0700

    input: use get_unaligned_* helpers
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Cc: Dmitry Torokhov <dtor@mail.ru>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 1d759f6f8076..55c1134d6137 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -528,9 +528,9 @@ static void aiptek_irq(struct urb *urb)
 			    (aiptek->curSetting.pointerMode)) {
 				aiptek->diagnostic = AIPTEK_DIAGNOSTIC_TOOL_DISALLOWED;
 		} else {
-			x = le16_to_cpu(get_unaligned((__le16 *) (data + 1)));
-			y = le16_to_cpu(get_unaligned((__le16 *) (data + 3)));
-			z = le16_to_cpu(get_unaligned((__le16 *) (data + 6)));
+			x = get_unaligned_le16(data + 1);
+			y = get_unaligned_le16(data + 3);
+			z = get_unaligned_le16(data + 6);
 
 			dv = (data[5] & 0x01) != 0 ? 1 : 0;
 			p = (data[5] & 0x02) != 0 ? 1 : 0;
@@ -613,8 +613,8 @@ static void aiptek_irq(struct urb *urb)
 			(aiptek->curSetting.pointerMode)) {
 			aiptek->diagnostic = AIPTEK_DIAGNOSTIC_TOOL_DISALLOWED;
 		} else {
-			x = le16_to_cpu(get_unaligned((__le16 *) (data + 1)));
-			y = le16_to_cpu(get_unaligned((__le16 *) (data + 3)));
+			x = get_unaligned_le16(data + 1);
+			y = get_unaligned_le16(data + 3);
 
 			jitterable = data[5] & 0x1c;
 
@@ -679,7 +679,7 @@ static void aiptek_irq(struct urb *urb)
 		pck = (data[1] & aiptek->curSetting.stylusButtonUpper) != 0 ? 1 : 0;
 
 		macro = dv && p && tip && !(data[3] & 1) ? (data[3] >> 1) : -1;
-		z = le16_to_cpu(get_unaligned((__le16 *) (data + 4)));
+		z = get_unaligned_le16(data + 4);
 
 		if (dv) {
 		        /* If the selected tool changed, reset the old
@@ -757,7 +757,7 @@ static void aiptek_irq(struct urb *urb)
 	 * hat switches (which just so happen to be the macroKeys.)
 	 */
 	else if (data[0] == 6) {
-		macro = le16_to_cpu(get_unaligned((__le16 *) (data + 1)));
+		macro = get_unaligned_le16(data + 1);
 		if (macro > 0) {
 			input_report_key(inputdev, macroKeyEvents[macro - 1],
 					 0);
@@ -952,7 +952,7 @@ aiptek_query(struct aiptek *aiptek, unsigned char command, unsigned char data)
 		    buf[0], buf[1], buf[2]);
 		ret = -EIO;
 	} else {
-		ret = le16_to_cpu(get_unaligned((__le16 *) (buf + 1)));
+		ret = get_unaligned_le16(buf + 1);
 	}
 	kfree(buf);
 	return ret;

commit a32bcc45b9e9d8021b5936c45dc3f8db7a044466
Author: Guryanov Dmitry <guryanov@dgap.mipt.ru>
Date:   Mon Mar 10 03:08:58 2008 -0700

    Input: aiptek - add support for Genius G-PEN 560 tablet
    
    USBHID driver only supports relative mode with this tablet so let aiptek
    module handle it.
    
    Signed-off-by: Dmitry Guryanov <guryanov@dgap.mipt.ru>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 94683f58c9e1..1d759f6f8076 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -184,6 +184,7 @@
  */
 
 #define USB_VENDOR_ID_AIPTEK				0x08ca
+#define USB_VENDOR_ID_KYE				0x0458
 #define USB_REQ_GET_REPORT				0x01
 #define USB_REQ_SET_REPORT				0x09
 
@@ -832,6 +833,7 @@ static const struct usb_device_id aiptek_ids[] = {
 	{USB_DEVICE(USB_VENDOR_ID_AIPTEK, 0x22)},
 	{USB_DEVICE(USB_VENDOR_ID_AIPTEK, 0x23)},
 	{USB_DEVICE(USB_VENDOR_ID_AIPTEK, 0x24)},
+	{USB_DEVICE(USB_VENDOR_ID_KYE, 0x5003)},
 	{}
 };
 

commit 5035522d1a6b55f95e7e01c209b57f5d89f88b16
Author: Rene van Paassen <rene.vanpaassen@gmail.com>
Date:   Mon May 21 00:32:21 2007 -0400

    Input: aiptek - update driver version
    
    Update credits and version number to 2.3
    
    Signed-off-by: Rene van Paassen <rene.vanpaassen@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 292eb507e5d3..94683f58c9e1 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -82,8 +82,8 @@
 /*
  * Version Information
  */
-#define DRIVER_VERSION "v1.5 (May-15-2004)"
-#define DRIVER_AUTHOR  "Bryan W. Headley/Chris Atenasio"
+#define DRIVER_VERSION "v2.3 (May 2, 2007)"
+#define DRIVER_AUTHOR  "Bryan W. Headley/Chris Atenasio/Cedric Brun/Rene van Paassen"
 #define DRIVER_DESC    "Aiptek HyperPen USB Tablet Driver (Linux 2.6.x)"
 
 /*

commit 1e7b3faed1793e7637a774240ae22541c5ba6ca0
Author: Rene van Paassen <rene.vanpaassen@gmail.com>
Date:   Mon May 21 00:32:17 2007 -0400

    Input: aiptek - rework the function key code
    
    Function keys (also called macro keys) code corrected. Using a
    lastMacro variable to keep track of key currently pressed. This
    ensures proper resetting when dragging the pen in the drawing
    area or to another key. Also suppress sending pressure reports
    when over the macro key area.
    
    Signed-off-by: Rene van Paassen <rene.vanpaassen@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 54c8d6f49833..292eb507e5d3 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -509,6 +509,11 @@ static void aiptek_irq(struct urb *urb)
 						 aiptek->curSetting.wheel);
 				aiptek->curSetting.wheel = AIPTEK_WHEEL_DISABLE;
 			}
+			if (aiptek->lastMacro != -1) {
+			        input_report_key(inputdev,
+						 macroKeyEvents[aiptek->lastMacro], 0);
+				aiptek->lastMacro = -1;
+			}
 			input_sync(inputdev);
 		}
 	}
@@ -589,6 +594,11 @@ static void aiptek_irq(struct urb *urb)
 					}
 				}
 				input_report_abs(inputdev, ABS_MISC, p | AIPTEK_REPORT_TOOL_STYLUS);
+				if (aiptek->lastMacro != -1) {
+			                input_report_key(inputdev,
+							 macroKeyEvents[aiptek->lastMacro], 0);
+					aiptek->lastMacro = -1;
+				}
 				input_sync(inputdev);
 			}
 		}
@@ -647,6 +657,11 @@ static void aiptek_irq(struct urb *urb)
 					}
 				}
 				input_report_abs(inputdev, ABS_MISC, p | AIPTEK_REPORT_TOOL_MOUSE);
+				if (aiptek->lastMacro != -1) {
+			                input_report_key(inputdev,
+							 macroKeyEvents[aiptek->lastMacro], 0);
+				        aiptek->lastMacro = -1;
+				}
 				input_sync(inputdev);
 			}
 		}
@@ -662,10 +677,10 @@ static void aiptek_irq(struct urb *urb)
 		bs = (data[1] & aiptek->curSetting.stylusButtonLower) != 0 ? 1 : 0;
 		pck = (data[1] & aiptek->curSetting.stylusButtonUpper) != 0 ? 1 : 0;
 
-		macro = data[3];
+		macro = dv && p && tip && !(data[3] & 1) ? (data[3] >> 1) : -1;
 		z = le16_to_cpu(get_unaligned((__le16 *) (data + 4)));
 
-		if (dv != 0) {
+		if (dv) {
 		        /* If the selected tool changed, reset the old
 			 * tool key, and set the new one.
 			 */
@@ -679,30 +694,20 @@ static void aiptek_irq(struct urb *urb)
 				aiptek->previousToolMode =
 				        aiptek->curSetting.toolMode;
 			}
+		}
 
-			if (p != 0) {
-				input_report_key(inputdev, BTN_TOUCH, tip);
-				input_report_key(inputdev, BTN_STYLUS, bs);
-				input_report_key(inputdev, BTN_STYLUS2, pck);
-				input_report_abs(inputdev, ABS_PRESSURE, z);
-			}
+		if (aiptek->lastMacro != -1 && aiptek->lastMacro != macro) {
+		        input_report_key(inputdev, macroKeyEvents[aiptek->lastMacro], 0);
+			aiptek->lastMacro = -1;
+		}
 
-			/* For safety, we're sending key 'break' codes for the
-			 * neighboring macro keys.
-			 */
-			if (macro > 0) {
-				input_report_key(inputdev,
-						 macroKeyEvents[macro - 1], 0);
-			}
-			if (macro < 25) {
-				input_report_key(inputdev,
-						 macroKeyEvents[macro + 1], 0);
-			}
-			input_report_key(inputdev, macroKeyEvents[macro], p);
-			input_report_abs(inputdev, ABS_MISC,
-					 p | AIPTEK_REPORT_TOOL_STYLUS);
-			input_sync(inputdev);
+		if (macro != -1 && macro != aiptek->lastMacro) {
+			input_report_key(inputdev, macroKeyEvents[macro], 1);
+			aiptek->lastMacro = macro;
 		}
+		input_report_abs(inputdev, ABS_MISC,
+				 p | AIPTEK_REPORT_TOOL_STYLUS);
+		input_sync(inputdev);
 	}
 	/* Report 5s come from the macro keys when pressed by mouse
 	 */
@@ -714,46 +719,35 @@ static void aiptek_irq(struct urb *urb)
 		left = (data[1]& aiptek->curSetting.mouseButtonLeft) != 0 ? 1 : 0;
 		right = (data[1] & aiptek->curSetting.mouseButtonRight) != 0 ? 1 : 0;
 		middle = (data[1] & aiptek->curSetting.mouseButtonMiddle) != 0 ? 1 : 0;
-		macro = data[3];
+		macro = dv && p && left && !(data[3] & 1) ? (data[3] >> 1) : 0;
 
-		if (dv != 0) {
+		if (dv) {
 		        /* If the selected tool changed, reset the old
 			 * tool key, and set the new one.
 			 */
 		        if (aiptek->previousToolMode !=
 			    aiptek->curSetting.toolMode) {
-			        input_report_key(inputdev,
+		                input_report_key(inputdev,
 						 aiptek->previousToolMode, 0);
-				input_report_key(inputdev,
-						 aiptek->curSetting.toolMode,
-						 1);
-				aiptek->previousToolMode =
-				        aiptek->curSetting.toolMode;
-			}
-
-			if (p != 0) {
-				input_report_key(inputdev, BTN_LEFT, left);
-				input_report_key(inputdev, BTN_MIDDLE, middle);
-				input_report_key(inputdev, BTN_RIGHT, right);
+			        input_report_key(inputdev,
+						 aiptek->curSetting.toolMode, 1);
+			        aiptek->previousToolMode = aiptek->curSetting.toolMode;
 			}
+		}
 
-			/* For safety, we're sending key 'break' codes for the
-			 * neighboring macro keys.
-			 */
-			if (macro > 0) {
-				input_report_key(inputdev,
-						 macroKeyEvents[macro - 1], 0);
-			}
-			if (macro < 25) {
-				input_report_key(inputdev,
-						 macroKeyEvents[macro + 1], 0);
-			}
+		if (aiptek->lastMacro != -1 && aiptek->lastMacro != macro) {
+		        input_report_key(inputdev, macroKeyEvents[aiptek->lastMacro], 0);
+			aiptek->lastMacro = -1;
+		}
 
+		if (macro != -1 && macro != aiptek->lastMacro) {
 			input_report_key(inputdev, macroKeyEvents[macro], 1);
-			input_report_rel(inputdev, ABS_MISC,
-					 p | AIPTEK_REPORT_TOOL_MOUSE);
-			input_sync(inputdev);
+			aiptek->lastMacro = macro;
 		}
+
+		input_report_abs(inputdev, ABS_MISC,
+				 p | AIPTEK_REPORT_TOOL_MOUSE);
+		input_sync(inputdev);
 	}
 	/* We have no idea which tool can generate a report 6. Theoretically,
 	 * neither need to, having been given reports 4 & 5 for such use.
@@ -1710,6 +1704,7 @@ aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	aiptek->inDelay = 0;
 	aiptek->endDelay = 0;
 	aiptek->previousJitterable = 0;
+	aiptek->lastMacro = -1;
 
 	/* Set up the curSettings struct. Said struct contains the current
 	 * programmable parameters. The newSetting struct contains changes

commit 0112db36ef95e5632db071297f7df130725c47b9
Author: Rene van Paassen <rene.vanpaassen@gmail.com>
Date:   Mon May 21 00:32:12 2007 -0400

    Input: aiptek - tolerate newlines in sysfs files
    
    Now echo "some value" > /sys/......./somefile is also acceptable.
    
    Signed-off-by: Rene van Paassen <rene.vanpaassen@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 0c78dc4ed5cf..54c8d6f49833 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -375,8 +375,11 @@ static int map_str_to_val(const struct aiptek_map *map, const char *str, size_t
 {
 	const struct aiptek_map *p;
 
+	if (str[count - 1] == '\n')
+		count--;
+
 	for (p = map; p->string; p++)
-		if (!strncmp(str, p->string, count))
+	        if (!strncmp(str, p->string, count))
 			return p->value;
 
 	return AIPTEK_INVALID_VALUE;

commit b3b6cf1d47508a04de859d357789a3fc0cf8c690
Author: Rene van Paassen <rene.vanpaassen@gmail.com>
Date:   Mon May 21 00:32:07 2007 -0400

    Input: aiptek - correct the tool switching code
    
    Now the old tool is remembered, and reset when a new tool is
    selected via the sysfs files.
    
    Signed-off-by: Rene van Paassen <rene.vanpaassen@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index c7db623682de..0c78dc4ed5cf 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -218,15 +218,9 @@
 #define AIPTEK_WHEEL_DISABLE				(-10101)
 
 	/* ToolCode values, which BTW are 0x140 .. 0x14f
-	 * We have things set up such that if TOOL_BUTTON_FIRED_BIT is
-	 * not set, we'll send one instance of AIPTEK_TOOL_BUTTON_xxx.
-	 *
-	 * Whenever the user resets the value, TOOL_BUTTON_FIRED_BIT will
-	 * get reset.
+	 * We have things set up such that if the tool button has changed,
+	 * the tools get reset.
 	 */
-#define TOOL_BUTTON(x)					((x) & 0x14f)
-#define TOOL_BUTTON_FIRED(x)				((x) & 0x200)
-#define TOOL_BUTTON_FIRED_BIT				0x200
 	/* toolMode codes
 	 */
 #define AIPTEK_TOOL_BUTTON_PEN_MODE			BTN_TOOL_PEN
@@ -326,6 +320,9 @@ struct aiptek {
 	int inDelay;				/* jitter: in jitter delay?      */
 	unsigned long endDelay;			/* jitter: time when delay ends  */
 	int previousJitterable;			/* jitterable prev value     */
+
+	int lastMacro;				/* macro key to reset            */
+	int previousToolMode;			/* pen, pencil, brush, etc. tool */
 	unsigned char *data;			/* incoming packet data          */
 };
 
@@ -542,16 +539,18 @@ static void aiptek_irq(struct urb *urb)
 			 * all 'bad' reports...
 			 */
 			if (dv != 0) {
-				/* If we've not already sent a tool_button_?? code, do
-				 * so now. Then set FIRED_BIT so it won't be resent unless
-				 * the user forces FIRED_BIT off.
+				/* If the selected tool changed, reset the old
+				 * tool key, and set the new one.
 				 */
-				if (TOOL_BUTTON_FIRED
-				    (aiptek->curSetting.toolMode) == 0) {
+				if (aiptek->previousToolMode !=
+				    aiptek->curSetting.toolMode) {
+				        input_report_key(inputdev,
+							 aiptek->previousToolMode, 0);
 					input_report_key(inputdev,
-							 TOOL_BUTTON(aiptek->curSetting.toolMode),
+							 aiptek->curSetting.toolMode,
 							 1);
-					aiptek->curSetting.toolMode |= TOOL_BUTTON_FIRED_BIT;
+					aiptek->previousToolMode =
+					          aiptek->curSetting.toolMode;
 				}
 
 				if (p != 0) {
@@ -612,16 +611,18 @@ static void aiptek_irq(struct urb *urb)
 			middle = (data[5] & aiptek->curSetting.mouseButtonMiddle) != 0 ? 1 : 0;
 
 			if (dv != 0) {
-				/* If we've not already sent a tool_button_?? code, do
-				 * so now. Then set FIRED_BIT so it won't be resent unless
-				 * the user forces FIRED_BIT off.
+				/* If the selected tool changed, reset the old
+				 * tool key, and set the new one.
 				 */
-				if (TOOL_BUTTON_FIRED
-				    (aiptek->curSetting.toolMode) == 0) {
+				if (aiptek->previousToolMode !=
+				    aiptek->curSetting.toolMode) {
+				        input_report_key(inputdev,
+							 aiptek->previousToolMode, 0);
 					input_report_key(inputdev,
-							 TOOL_BUTTON(aiptek->curSetting.toolMode),
+							 aiptek->curSetting.toolMode,
 							 1);
-					aiptek->curSetting.toolMode |= TOOL_BUTTON_FIRED_BIT;
+					aiptek->previousToolMode =
+					          aiptek->curSetting.toolMode;
 				}
 
 				if (p != 0) {
@@ -662,15 +663,18 @@ static void aiptek_irq(struct urb *urb)
 		z = le16_to_cpu(get_unaligned((__le16 *) (data + 4)));
 
 		if (dv != 0) {
-			/* If we've not already sent a tool_button_?? code, do
-			 * so now. Then set FIRED_BIT so it won't be resent unless
-			 * the user forces FIRED_BIT off.
+		        /* If the selected tool changed, reset the old
+			 * tool key, and set the new one.
 			 */
-			if (TOOL_BUTTON_FIRED(aiptek->curSetting.toolMode) == 0) {
+		        if (aiptek->previousToolMode !=
+			    aiptek->curSetting.toolMode) {
+			        input_report_key(inputdev,
+						 aiptek->previousToolMode, 0);
 				input_report_key(inputdev,
-						 TOOL_BUTTON(aiptek->curSetting.toolMode),
+						 aiptek->curSetting.toolMode,
 						 1);
-				aiptek->curSetting.toolMode |= TOOL_BUTTON_FIRED_BIT;
+				aiptek->previousToolMode =
+				        aiptek->curSetting.toolMode;
 			}
 
 			if (p != 0) {
@@ -710,15 +714,18 @@ static void aiptek_irq(struct urb *urb)
 		macro = data[3];
 
 		if (dv != 0) {
-			/* If we've not already sent a tool_button_?? code, do
-			 * so now. Then set FIRED_BIT so it won't be resent unless
-			 * the user forces FIRED_BIT off.
+		        /* If the selected tool changed, reset the old
+			 * tool key, and set the new one.
 			 */
-			if (TOOL_BUTTON_FIRED(aiptek->curSetting.toolMode) == 0) {
+		        if (aiptek->previousToolMode !=
+			    aiptek->curSetting.toolMode) {
+			        input_report_key(inputdev,
+						 aiptek->previousToolMode, 0);
 				input_report_key(inputdev,
-						 TOOL_BUTTON(aiptek->curSetting.toolMode),
+						 aiptek->curSetting.toolMode,
 						 1);
-				aiptek->curSetting.toolMode |= TOOL_BUTTON_FIRED_BIT;
+				aiptek->previousToolMode =
+				        aiptek->curSetting.toolMode;
 			}
 
 			if (p != 0) {
@@ -762,15 +769,18 @@ static void aiptek_irq(struct urb *urb)
 					 0);
 		}
 
-		/* If we've not already sent a tool_button_?? code, do
-		 * so now. Then set FIRED_BIT so it won't be resent unless
-		 * the user forces FIRED_BIT off.
-		 */
-		if (TOOL_BUTTON_FIRED(aiptek->curSetting.toolMode) == 0) {
+		/* If the selected tool changed, reset the old
+		   tool key, and set the new one.
+		*/
+		if (aiptek->previousToolMode !=
+		    aiptek->curSetting.toolMode) {
+		        input_report_key(inputdev,
+					 aiptek->previousToolMode, 0);
 			input_report_key(inputdev,
-					 TOOL_BUTTON(aiptek->curSetting.
-						     toolMode), 1);
-			aiptek->curSetting.toolMode |= TOOL_BUTTON_FIRED_BIT;
+					 aiptek->curSetting.toolMode,
+					 1);
+			aiptek->previousToolMode =
+				aiptek->curSetting.toolMode;
 		}
 
 		input_report_key(inputdev, macroKeyEvents[macro], 1);

commit da9fda434cde76dfb8174548a63b685b4ac00a9c
Author: Rene van Paassen <rene.vanpaassen@gmail.com>
Date:   Mon May 21 00:32:03 2007 -0400

    Input: aiptek - use only absolute misc reports
    
    To get an on - off reporting for proximity, absolute misc reports are
    used. The mixture of absolute and relative reports is awkward
    
    Signed-off-by: Rene van Paassen <rene.vanpaassen@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 7fb15af33c49..c7db623682de 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -417,6 +417,9 @@ static const char *map_val_to_str(const struct aiptek_map *map, int val)
  * Proximity. Why two events? I thought it interesting to know if the
  * Proximity event occurred while the tablet was in absolute or relative
  * mode.
+ * Update: REL_MISC proved not to be such a good idea. With REL_MISC you
+ * get an event transmitted each time. ABS_MISC works better, since it
+ * can be set and re-set. Thus, only using ABS_MISC from now on.
  *
  * Other tablets use the notion of a certain minimum stylus pressure
  * to infer proximity. While that could have been done, that is yet
@@ -639,7 +642,7 @@ static void aiptek_irq(struct urb *urb)
 						aiptek->curSetting.wheel = AIPTEK_WHEEL_DISABLE;
 					}
 				}
-				input_report_rel(inputdev, REL_MISC, p | AIPTEK_REPORT_TOOL_MOUSE);
+				input_report_abs(inputdev, ABS_MISC, p | AIPTEK_REPORT_TOOL_MOUSE);
 				input_sync(inputdev);
 			}
 		}

commit 6125a400354c4a02b9dad0e5d8128f9dc08cfd51
Author: Rene van Paassen <rene.vanpaassen@gmail.com>
Date:   Mon May 21 00:31:59 2007 -0400

    Input: aiptek - put sensible warnings in probe
    
    Added warnings to the points where the tablet probe may fail
    
    Signed-off-by: Rene van Paassen <rene.vanpaassen@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 8c62afea5a52..7fb15af33c49 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -1670,17 +1670,23 @@ aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 
 	aiptek = kzalloc(sizeof(struct aiptek), GFP_KERNEL);
 	inputdev = input_allocate_device();
-	if (!aiptek || !inputdev)
+	if (!aiptek || !inputdev) {
+		warn("aiptek: cannot allocate memory or input device");
 		goto fail1;
+        }
 
 	aiptek->data = usb_buffer_alloc(usbdev, AIPTEK_PACKET_LENGTH,
 					GFP_ATOMIC, &aiptek->data_dma);
-	if (!aiptek->data)
+        if (!aiptek->data) {
+		warn("aiptek: cannot allocate usb buffer");
 		goto fail1;
+	}
 
 	aiptek->urb = usb_alloc_urb(0, GFP_KERNEL);
-	if (!aiptek->urb)
+	if (!aiptek->urb) {
+	        warn("aiptek: cannot allocate urb");
 		goto fail2;
+	}
 
 	aiptek->inputdev = inputdev;
 	aiptek->usbdev = usbdev;
@@ -1807,6 +1813,13 @@ aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 		}
 	}
 
+	/* Murphy says that some day someone will have a tablet that fails the
+	   above test. That's you, Frederic Rodrigo */
+	if (i == ARRAY_SIZE(speeds)) {
+		info("input: Aiptek tried all speeds, no sane response");
+		goto fail2;
+	}
+
 	/* Associate this driver's struct with the usb interface.
 	 */
 	usb_set_intfdata(intf, aiptek);
@@ -1814,15 +1827,18 @@ aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	/* Set up the sysfs files
 	 */
 	err = sysfs_create_group(&intf->dev.kobj, &aiptek_attribute_group);
-	if (err)
+	if (err) {
+		warn("aiptek: cannot create sysfs group err: %d", err);
 		goto fail3;
+        }
 
 	/* Register the tablet as an Input Device
 	 */
 	err = input_register_device(aiptek->inputdev);
-	if (err)
+	if (err) {
+		warn("aiptek: input_register_device returned err: %d", err);
 		goto fail4;
-
+        }
 	return 0;
 
  fail4:	sysfs_remove_group(&intf->dev.kobj, &aiptek_attribute_group);

commit 1a54f49e8989462cfc9cab0c377b2d4e60e5b70a
Author: Rene van Paassen <rene.vanpaassen@gmail.com>
Date:   Mon May 21 00:31:55 2007 -0400

    Input: aiptek - use set_bit instead of bitwise or
    
    Have to use set_bit since some bit values are over 32, and bitwise or
    won't work on these. To be safe for the future too, use set_bit for all
    input dev capabilities
    
    Signed-off-by: Rene van Paassen <rene.vanpaassen@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index c18287724a1e..8c62afea5a52 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -329,6 +329,19 @@ struct aiptek {
 	unsigned char *data;			/* incoming packet data          */
 };
 
+static const int eventTypes[] = {
+        EV_KEY, EV_ABS, EV_REL, EV_MSC,
+};
+
+static const int absEvents[] = {
+        ABS_X, ABS_Y, ABS_PRESSURE, ABS_TILT_X, ABS_TILT_Y,
+        ABS_WHEEL, ABS_MISC,
+};
+
+static const int relEvents[] = {
+        REL_X, REL_Y, REL_WHEEL,
+};
+
 static const int buttonEvents[] = {
 	BTN_LEFT, BTN_RIGHT, BTN_MIDDLE,
 	BTN_TOOL_PEN, BTN_TOOL_RUBBER, BTN_TOOL_PENCIL, BTN_TOOL_AIRBRUSH,
@@ -1727,17 +1740,16 @@ aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	/* Now program the capacities of the tablet, in terms of being
 	 * an input device.
 	 */
-	inputdev->evbit[0] |= BIT(EV_KEY)
-	    | BIT(EV_ABS)
-	    | BIT(EV_REL)
-	    | BIT(EV_MSC);
+	for (i = 0; i < ARRAY_SIZE(eventTypes); ++i)
+	        __set_bit(eventTypes[i], inputdev->evbit);
 
-	inputdev->absbit[0] |= BIT(ABS_MISC);
+	for (i = 0; i < ARRAY_SIZE(absEvents); ++i)
+	        __set_bit(absEvents[i], inputdev->absbit);
 
-	inputdev->relbit[0] |=
-	    (BIT(REL_X) | BIT(REL_Y) | BIT(REL_WHEEL) | BIT(REL_MISC));
+	for (i = 0; i < ARRAY_SIZE(relEvents); ++i)
+	        __set_bit(relEvents[i], inputdev->relbit);
 
-	inputdev->mscbit[0] = BIT(MSC_SERIAL);
+	__set_bit(MSC_SERIAL, inputdev->mscbit);
 
 	/* Set up key and button codes */
 	for (i = 0; i < ARRAY_SIZE(buttonEvents); ++i)

commit 0038cae0ffd72b75699010bd112655dc2615e2fd
Author: Mark Vytlacil <mrv@wi.rr.com>
Date:   Mon May 21 00:31:50 2007 -0400

    Input: aiptek - fix relative mode parsing
    
    Corrections to relative mode, was looking at wrong byte
    
    Signed-off-by: Mark Vytlacil <mrv@wi.rr.com>
    Signed-off-by: Rene van Paassen <rene.vanpaassen@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 147ed340e6e1..c18287724a1e 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -470,18 +470,20 @@ static void aiptek_irq(struct urb *urb)
 			 * that a non-zero value indicates that one or more
 			 * mouse button was pressed.)
 			 */
-			jitterable = data[5] & 0x07;
+			jitterable = data[1] & 0x07;
 
-			left = (data[5] & aiptek->curSetting.mouseButtonLeft) != 0 ? 1 : 0;
-			right = (data[5] & aiptek->curSetting.mouseButtonRight) != 0 ? 1 : 0;
-			middle = (data[5] & aiptek->curSetting.mouseButtonMiddle) != 0 ? 1 : 0;
+			left = (data[1] & aiptek->curSetting.mouseButtonLeft >> 2) != 0 ? 1 : 0;
+			right = (data[1] & aiptek->curSetting.mouseButtonRight >> 2) != 0 ? 1 : 0;
+			middle = (data[1] & aiptek->curSetting.mouseButtonMiddle >> 2) != 0 ? 1 : 0;
 
 			input_report_key(inputdev, BTN_LEFT, left);
 			input_report_key(inputdev, BTN_MIDDLE, middle);
 			input_report_key(inputdev, BTN_RIGHT, right);
+
+			input_report_abs(inputdev, ABS_MISC,
+					 1 | AIPTEK_REPORT_TOOL_UNKNOWN);
 			input_report_rel(inputdev, REL_X, x);
 			input_report_rel(inputdev, REL_Y, y);
-			input_report_rel(inputdev, REL_MISC, 1 | AIPTEK_REPORT_TOOL_UNKNOWN);
 
 			/* Wheel support is in the form of a single-event
 			 * firing.

commit ce0982edaec2c46dc9ec466e03f1fe94ee0862d8
Author: Rene van Paassen <rene.vanpaassen@gmail.com>
Date:   Mon May 21 00:31:45 2007 -0400

    Input: aiptek - fixed mouse button defines
    
    Mouse button defines tested the wrong bits, now fixed
    
    Signed-off-by: Rene van Paassen <rene.vanpaassen@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 5aa8abf7ec85..147ed340e6e1 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -264,9 +264,9 @@
 
 	/* Mouse button programming
 	 */
-#define AIPTEK_MOUSE_LEFT_BUTTON		0x01
-#define AIPTEK_MOUSE_RIGHT_BUTTON		0x02
-#define AIPTEK_MOUSE_MIDDLE_BUTTON		0x04
+#define AIPTEK_MOUSE_LEFT_BUTTON		0x04
+#define AIPTEK_MOUSE_RIGHT_BUTTON		0x08
+#define AIPTEK_MOUSE_MIDDLE_BUTTON		0x10
 
 	/* Stylus button programming
 	 */

commit fe981f2340edffcb6aad2203d8f14c9bef0e67e3
Author: Rene van Paassen <rene.vanpaassen@gmail.com>
Date:   Mon May 21 00:31:24 2007 -0400

    Input: aiptek - correct the proximity and validity checks
    
    Calculation of proximity bit and of data valid bits were reversed for
    stylus reports.
    
    Signed-off-by: Rene van Paassen <rene.vanpaassen@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 86a750e88fbb..5aa8abf7ec85 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -508,8 +508,8 @@ static void aiptek_irq(struct urb *urb)
 			y = le16_to_cpu(get_unaligned((__le16 *) (data + 3)));
 			z = le16_to_cpu(get_unaligned((__le16 *) (data + 6)));
 
-			p = (data[5] & 0x01) != 0 ? 1 : 0;
-			dv = (data[5] & 0x02) != 0 ? 1 : 0;
+			dv = (data[5] & 0x01) != 0 ? 1 : 0;
+			p = (data[5] & 0x02) != 0 ? 1 : 0;
 			tip = (data[5] & 0x04) != 0 ? 1 : 0;
 
 			/* Use jitterable to re-arrange button masks
@@ -587,8 +587,8 @@ static void aiptek_irq(struct urb *urb)
 
 			jitterable = data[5] & 0x1c;
 
-			p = (data[5] & 0x01) != 0 ? 1 : 0;
-			dv = (data[5] & 0x02) != 0 ? 1 : 0;
+			dv = (data[5] & 0x01) != 0 ? 1 : 0;
+			p = (data[5] & 0x02) != 0 ? 1 : 0;
 			left = (data[5] & aiptek->curSetting.mouseButtonLeft) != 0 ? 1 : 0;
 			right = (data[5] & aiptek->curSetting.mouseButtonRight) != 0 ? 1 : 0;
 			middle = (data[5] & aiptek->curSetting.mouseButtonMiddle) != 0 ? 1 : 0;
@@ -634,8 +634,8 @@ static void aiptek_irq(struct urb *urb)
 	else if (data[0] == 4) {
 		jitterable = data[1] & 0x18;
 
-		p = (data[1] & 0x01) != 0 ? 1 : 0;
-		dv = (data[1] & 0x02) != 0 ? 1 : 0;
+		dv = (data[1] & 0x01) != 0 ? 1 : 0;
+		p = (data[1] & 0x02) != 0 ? 1 : 0;
 		tip = (data[1] & 0x04) != 0 ? 1 : 0;
 		bs = (data[1] & aiptek->curSetting.stylusButtonLower) != 0 ? 1 : 0;
 		pck = (data[1] & aiptek->curSetting.stylusButtonUpper) != 0 ? 1 : 0;
@@ -684,8 +684,8 @@ static void aiptek_irq(struct urb *urb)
 	else if (data[0] == 5) {
 		jitterable = data[1] & 0x1c;
 
-		p = (data[1] & 0x01) != 0 ? 1 : 0;
-		dv = (data[1] & 0x02) != 0 ? 1 : 0;
+		dv = (data[1] & 0x01) != 0 ? 1 : 0;
+		p = (data[1] & 0x02) != 0 ? 1 : 0;
 		left = (data[1]& aiptek->curSetting.mouseButtonLeft) != 0 ? 1 : 0;
 		right = (data[1] & aiptek->curSetting.mouseButtonRight) != 0 ? 1 : 0;
 		middle = (data[1] & aiptek->curSetting.mouseButtonMiddle) != 0 ? 1 : 0;

commit 2fe574167be6a61d5f37c496da01c4a7daa73f4d
Author: Rene van Paassen <rene.vanpaassen@gmail.com>
Date:   Mon May 21 00:18:24 2007 -0400

    Input: aiptek - correct documentation on reports
    
    Small fix that corrects the documentation on the report byte
    format produced by the mouse
    
    Signed-off-by: Rene van Paassen <rene.vanpaassen@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 86e48930dfa2..86a750e88fbb 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -112,7 +112,7 @@
  * (returned as Report 3 - absolute coordinates from the mouse)
  *
  *        bit7  bit6  bit5  bit4  bit3  bit2  bit1  bit0
- * byte0   0     0     0     0     0     0     1     0
+ * byte0   0     0     0     0     0     0     1     1
  * byte1  X7    X6    X5    X4    X3    X2    X1    X0
  * byte2  X15   X14   X13   X12   X11   X10   X9    X8
  * byte3  Y7    Y6    Y5    Y4    Y3    Y2    Y1    Y0
@@ -134,7 +134,7 @@
  * (returned as Report 5 - macrokeys from the mouse)
  *
  *        bit7  bit6  bit5  bit4  bit3  bit2  bit1  bit0
- * byte0   0     0     0     0     0     1     0     0
+ * byte0   0     0     0     0     0     1     0     1
  * byte1   0     0     0    BS2   BS    Tip   IR    DV
  * byte2   0     0     0     0     0     0     1     0
  * byte3   0     0     0    K4    K3    K2    K1    K0

commit 33936fa603f2524a7dde08d22637d0989a4e8fdd
Author: Dmitry Torokhov <dtor@insightbb.com>
Date:   Mon May 21 00:18:15 2007 -0400

    Input: aiptek - use array to list all buttons
    
    When setting up input device use an array to list all the buttons
    instead of setting every bit separately.
    
    Signed-off-by: Rene van Paassen <rene.vanpaassen@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 3a5e0aafa115..86e48930dfa2 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -329,6 +329,13 @@ struct aiptek {
 	unsigned char *data;			/* incoming packet data          */
 };
 
+static const int buttonEvents[] = {
+	BTN_LEFT, BTN_RIGHT, BTN_MIDDLE,
+	BTN_TOOL_PEN, BTN_TOOL_RUBBER, BTN_TOOL_PENCIL, BTN_TOOL_AIRBRUSH,
+	BTN_TOOL_BRUSH, BTN_TOOL_MOUSE, BTN_TOOL_LENS, BTN_TOUCH,
+	BTN_STYLUS, BTN_STYLUS2,
+};
+
 /*
  * Permit easy lookup of keyboard events to send, versus
  * the bitmap which comes from the tablet. This hides the
@@ -1728,26 +1735,14 @@ aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	inputdev->relbit[0] |=
 	    (BIT(REL_X) | BIT(REL_Y) | BIT(REL_WHEEL) | BIT(REL_MISC));
 
-	inputdev->keybit[LONG(BTN_LEFT)] |=
-	    (BIT(BTN_LEFT) | BIT(BTN_RIGHT) | BIT(BTN_MIDDLE));
-
-	inputdev->keybit[LONG(BTN_DIGI)] |=
-	    (BIT(BTN_TOOL_PEN) |
-	     BIT(BTN_TOOL_RUBBER) |
-	     BIT(BTN_TOOL_PENCIL) |
-	     BIT(BTN_TOOL_AIRBRUSH) |
-	     BIT(BTN_TOOL_BRUSH) |
-	     BIT(BTN_TOOL_MOUSE) |
-	     BIT(BTN_TOOL_LENS) |
-	     BIT(BTN_TOUCH) | BIT(BTN_STYLUS) | BIT(BTN_STYLUS2));
-
 	inputdev->mscbit[0] = BIT(MSC_SERIAL);
 
-	/* Programming the tablet macro keys needs to be done with a for loop
-	 * as the keycodes are discontiguous.
-	 */
+	/* Set up key and button codes */
+	for (i = 0; i < ARRAY_SIZE(buttonEvents); ++i)
+		__set_bit(buttonEvents[i], inputdev->keybit);
+
 	for (i = 0; i < ARRAY_SIZE(macroKeyEvents); ++i)
-		set_bit(macroKeyEvents[i], inputdev->keybit);
+		__set_bit(macroKeyEvents[i], inputdev->keybit);
 
 	/*
 	 * Program the input device coordinate capacities. We do not yet

commit 37767b66ed61ee37f0d8f40523f74c31bc187d1d
Author: Dmitry Torokhov <dtor@insightbb.com>
Date:   Mon May 21 00:18:08 2007 -0400

    Input: aiptek - kill aiptek_convert_from_2s_complement()
    
    There is no reason to do that, just tell the compiler that
    we are dealing with signed values in buffer, that's it.
    
    Signed-off-by: Rene van Paassen <rene.vanpaassen@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 0c990e61ed73..3a5e0aafa115 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -376,26 +376,6 @@ static const char *map_val_to_str(const struct aiptek_map *map, int val)
 	return "unknown";
 }
 
-/***********************************************************************
- * Relative reports deliver values in 2's complement format to
- * deal with negative offsets.
- */
-static int aiptek_convert_from_2s_complement(unsigned char c)
-{
-	int ret;
-	unsigned char b = c;
-	int negate = 0;
-
-	if ((b & 0x80) != 0) {
-		b = ~b;
-		b--;
-		negate = 1;
-	}
-	ret = b;
-	ret = (negate == 1) ? -ret : ret;
-	return ret;
-}
-
 /***********************************************************************
  * aiptek_irq can receive one of six potential reports.
  * The documentation for each is in the body of the function.
@@ -473,8 +453,8 @@ static void aiptek_irq(struct urb *urb)
 			aiptek->diagnostic =
 			    AIPTEK_DIAGNOSTIC_SENDING_RELATIVE_IN_ABSOLUTE;
 		} else {
-			x = aiptek_convert_from_2s_complement(data[2]);
-			y = aiptek_convert_from_2s_complement(data[3]);
+			x = (signed char) data[2];
+			y = (signed char) data[3];
 
 			/* jitterable keeps track of whether any button has been pressed.
 			 * We're also using it to remap the physical mouse button mask

commit cd438a58c89221d8642455d0cc8ec96d3b822f6e
Author: Dmitry Torokhov <dtor@insightbb.com>
Date:   Mon May 21 00:17:57 2007 -0400

    Input: aiptek - use maps in attributes
    
    Use maps to convert for strings to internal constants and vice versa
    in aiptek's sysfs attribute methods instead of open-coding it. This
    results in smaller code that is also easier to maintain.
    
    [Rene: fix a typo - stylys instead of stylus]
    
    Signed-off-by: Rene van Paassen <rene.vanpaassen@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 274c12f4220b..0c990e61ed73 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -343,6 +343,39 @@ static const int macroKeyEvents[] = {
 	KEY_FRONT, KEY_COPY, KEY_OPEN, KEY_PASTE, 0
 };
 
+/***********************************************************************
+ * Map values to strings and back. Every map shoudl have the following
+ * as its last element: { NULL, AIPTEK_INVALID_VALUE }.
+ */
+#define AIPTEK_INVALID_VALUE	-1
+
+struct aiptek_map {
+	const char *string;
+	int value;
+};
+
+static int map_str_to_val(const struct aiptek_map *map, const char *str, size_t count)
+{
+	const struct aiptek_map *p;
+
+	for (p = map; p->string; p++)
+		if (!strncmp(str, p->string, count))
+			return p->value;
+
+	return AIPTEK_INVALID_VALUE;
+}
+
+static const char *map_val_to_str(const struct aiptek_map *map, int val)
+{
+	const struct aiptek_map *p;
+
+	for (p = map; p->value != AIPTEK_INVALID_VALUE; p++)
+		if (val == p->value)
+			return p->string;
+
+	return "unknown";
+}
+
 /***********************************************************************
  * Relative reports deliver values in 2's complement format to
  * deal with negative offsets.
@@ -1023,44 +1056,32 @@ static DEVICE_ATTR(size, S_IRUGO, show_tabletSize, NULL);
  * support routines for the 'pointer_mode' file. Note that this file
  * both displays current setting and allows reprogramming.
  */
+static struct aiptek_map pointer_mode_map[] = {
+	{ "stylus",	AIPTEK_POINTER_ONLY_STYLUS_MODE },
+	{ "mouse",	AIPTEK_POINTER_ONLY_MOUSE_MODE },
+	{ "either",	AIPTEK_POINTER_EITHER_MODE },
+	{ NULL,		AIPTEK_INVALID_VALUE }
+};
+
 static ssize_t show_tabletPointerMode(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
-	char *s;
-
-	switch (aiptek->curSetting.pointerMode) {
-	case AIPTEK_POINTER_ONLY_STYLUS_MODE:
-		s = "stylus";
-		break;
-
-	case AIPTEK_POINTER_ONLY_MOUSE_MODE:
-		s = "mouse";
-		break;
-
-	case AIPTEK_POINTER_EITHER_MODE:
-		s = "either";
-		break;
 
-	default:
-		s = "unknown";
-		break;
-	}
-	return snprintf(buf, PAGE_SIZE, "%s\n", s);
+	return snprintf(buf, PAGE_SIZE, "%s\n",
+			map_val_to_str(pointer_mode_map,
+					aiptek->curSetting.pointerMode));
 }
 
 static ssize_t
 store_tabletPointerMode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
+	int new_mode = map_str_to_val(pointer_mode_map, buf, count);
 
-	if (strcmp(buf, "stylus") == 0) {
-		aiptek->newSetting.pointerMode =
-		    AIPTEK_POINTER_ONLY_STYLUS_MODE;
-	} else if (strcmp(buf, "mouse") == 0) {
-		aiptek->newSetting.pointerMode = AIPTEK_POINTER_ONLY_MOUSE_MODE;
-	} else if (strcmp(buf, "either") == 0) {
-		aiptek->newSetting.pointerMode = AIPTEK_POINTER_EITHER_MODE;
-	}
+	if (new_mode == AIPTEK_INVALID_VALUE)
+		return -EINVAL;
+
+	aiptek->newSetting.pointerMode = new_mode;
 	return count;
 }
 
@@ -1072,39 +1093,32 @@ static DEVICE_ATTR(pointer_mode,
  * support routines for the 'coordinate_mode' file. Note that this file
  * both displays current setting and allows reprogramming.
  */
+
+static struct aiptek_map coordinate_mode_map[] = {
+	{ "absolute",	AIPTEK_COORDINATE_ABSOLUTE_MODE },
+	{ "relative",	AIPTEK_COORDINATE_RELATIVE_MODE },
+	{ NULL,		AIPTEK_INVALID_VALUE }
+};
+
 static ssize_t show_tabletCoordinateMode(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
-	char *s;
-
-	switch (aiptek->curSetting.coordinateMode) {
-	case AIPTEK_COORDINATE_ABSOLUTE_MODE:
-		s = "absolute";
-		break;
-
-	case AIPTEK_COORDINATE_RELATIVE_MODE:
-		s = "relative";
-		break;
 
-	default:
-		s = "unknown";
-		break;
-	}
-	return snprintf(buf, PAGE_SIZE, "%s\n", s);
+	return snprintf(buf, PAGE_SIZE, "%s\n",
+			map_val_to_str(coordinate_mode_map,
+					aiptek->curSetting.coordinateMode));
 }
 
 static ssize_t
 store_tabletCoordinateMode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
+	int new_mode = map_str_to_val(coordinate_mode_map, buf, count);
 
-	if (strcmp(buf, "absolute") == 0) {
-		aiptek->newSetting.pointerMode =
-		    AIPTEK_COORDINATE_ABSOLUTE_MODE;
-	} else if (strcmp(buf, "relative") == 0) {
-		aiptek->newSetting.pointerMode =
-		    AIPTEK_COORDINATE_RELATIVE_MODE;
-	}
+	if (new_mode == AIPTEK_INVALID_VALUE)
+		return -EINVAL;
+
+	aiptek->newSetting.coordinateMode = new_mode;
 	return count;
 }
 
@@ -1116,68 +1130,37 @@ static DEVICE_ATTR(coordinate_mode,
  * support routines for the 'tool_mode' file. Note that this file
  * both displays current setting and allows reprogramming.
  */
+
+static struct aiptek_map tool_mode_map[] = {
+	{ "mouse",	AIPTEK_TOOL_BUTTON_MOUSE_MODE },
+	{ "eraser",	AIPTEK_TOOL_BUTTON_ERASER_MODE },
+	{ "pencil",	AIPTEK_TOOL_BUTTON_PENCIL_MODE },
+	{ "pen",	AIPTEK_TOOL_BUTTON_PEN_MODE },
+	{ "brush",	AIPTEK_TOOL_BUTTON_BRUSH_MODE },
+	{ "airbrush",	AIPTEK_TOOL_BUTTON_AIRBRUSH_MODE },
+	{ "lens",	AIPTEK_TOOL_BUTTON_LENS_MODE },
+	{ NULL,		AIPTEK_INVALID_VALUE }
+};
+
 static ssize_t show_tabletToolMode(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
-	char *s;
-
-	switch (TOOL_BUTTON(aiptek->curSetting.toolMode)) {
-	case AIPTEK_TOOL_BUTTON_MOUSE_MODE:
-		s = "mouse";
-		break;
 
-	case AIPTEK_TOOL_BUTTON_ERASER_MODE:
-		s = "eraser";
-		break;
-
-	case AIPTEK_TOOL_BUTTON_PENCIL_MODE:
-		s = "pencil";
-		break;
-
-	case AIPTEK_TOOL_BUTTON_PEN_MODE:
-		s = "pen";
-		break;
-
-	case AIPTEK_TOOL_BUTTON_BRUSH_MODE:
-		s = "brush";
-		break;
-
-	case AIPTEK_TOOL_BUTTON_AIRBRUSH_MODE:
-		s = "airbrush";
-		break;
-
-	case AIPTEK_TOOL_BUTTON_LENS_MODE:
-		s = "lens";
-		break;
-
-	default:
-		s = "unknown";
-		break;
-	}
-	return snprintf(buf, PAGE_SIZE, "%s\n", s);
+	return snprintf(buf, PAGE_SIZE, "%s\n",
+			map_val_to_str(tool_mode_map,
+					aiptek->curSetting.toolMode));
 }
 
 static ssize_t
 store_tabletToolMode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
+	int new_mode = map_str_to_val(tool_mode_map, buf, count);
 
-	if (strcmp(buf, "mouse") == 0) {
-		aiptek->newSetting.toolMode = AIPTEK_TOOL_BUTTON_MOUSE_MODE;
-	} else if (strcmp(buf, "eraser") == 0) {
-		aiptek->newSetting.toolMode = AIPTEK_TOOL_BUTTON_ERASER_MODE;
-	} else if (strcmp(buf, "pencil") == 0) {
-		aiptek->newSetting.toolMode = AIPTEK_TOOL_BUTTON_PENCIL_MODE;
-	} else if (strcmp(buf, "pen") == 0) {
-		aiptek->newSetting.toolMode = AIPTEK_TOOL_BUTTON_PEN_MODE;
-	} else if (strcmp(buf, "brush") == 0) {
-		aiptek->newSetting.toolMode = AIPTEK_TOOL_BUTTON_BRUSH_MODE;
-	} else if (strcmp(buf, "airbrush") == 0) {
-		aiptek->newSetting.toolMode = AIPTEK_TOOL_BUTTON_AIRBRUSH_MODE;
-	} else if (strcmp(buf, "lens") == 0) {
-		aiptek->newSetting.toolMode = AIPTEK_TOOL_BUTTON_LENS_MODE;
-	}
+	if (new_mode == AIPTEK_INVALID_VALUE)
+		return -EINVAL;
 
+	aiptek->newSetting.toolMode = new_mode;
 	return count;
 }
 
@@ -1362,39 +1345,32 @@ static DEVICE_ATTR(diagnostic, S_IRUGO, show_tabletDiagnosticMessage, NULL);
  * support routines for the 'stylus_upper' file. Note that this file
  * both displays current setting and allows for setting changing.
  */
+
+static struct aiptek_map stylus_button_map[] = {
+	{ "upper",	AIPTEK_STYLUS_UPPER_BUTTON },
+	{ "lower",	AIPTEK_STYLUS_LOWER_BUTTON },
+	{ NULL,		AIPTEK_INVALID_VALUE }
+};
+
 static ssize_t show_tabletStylusUpper(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
-	char *s;
-
-	switch (aiptek->curSetting.stylusButtonUpper) {
-	case AIPTEK_STYLUS_UPPER_BUTTON:
-		s = "upper";
-		break;
-
-	case AIPTEK_STYLUS_LOWER_BUTTON:
-		s = "lower";
-		break;
 
-	default:
-		s = "unknown";
-		break;
-	}
-	return snprintf(buf, PAGE_SIZE, "%s\n", s);
+	return snprintf(buf, PAGE_SIZE, "%s\n",
+			map_val_to_str(stylus_button_map,
+					aiptek->curSetting.stylusButtonUpper));
 }
 
 static ssize_t
 store_tabletStylusUpper(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
+	int new_button = map_str_to_val(stylus_button_map, buf, count);
 
-	if (strcmp(buf, "upper") == 0) {
-		aiptek->newSetting.stylusButtonUpper =
-		    AIPTEK_STYLUS_UPPER_BUTTON;
-	} else if (strcmp(buf, "lower") == 0) {
-		aiptek->newSetting.stylusButtonUpper =
-		    AIPTEK_STYLUS_LOWER_BUTTON;
-	}
+	if (new_button == AIPTEK_INVALID_VALUE)
+		return -EINVAL;
+
+	aiptek->newSetting.stylusButtonUpper = new_button;
 	return count;
 }
 
@@ -1406,39 +1382,26 @@ static DEVICE_ATTR(stylus_upper,
  * support routines for the 'stylus_lower' file. Note that this file
  * both displays current setting and allows for setting changing.
  */
+
 static ssize_t show_tabletStylusLower(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
-	char *s;
-
-	switch (aiptek->curSetting.stylusButtonLower) {
-	case AIPTEK_STYLUS_UPPER_BUTTON:
-		s = "upper";
-		break;
-
-	case AIPTEK_STYLUS_LOWER_BUTTON:
-		s = "lower";
-		break;
 
-	default:
-		s = "unknown";
-		break;
-	}
-	return snprintf(buf, PAGE_SIZE, "%s\n", s);
+	return snprintf(buf, PAGE_SIZE, "%s\n",
+			map_val_to_str(stylus_button_map,
+					aiptek->curSetting.stylusButtonLower));
 }
 
 static ssize_t
 store_tabletStylusLower(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
+	int new_button = map_str_to_val(stylus_button_map, buf, count);
 
-	if (strcmp(buf, "upper") == 0) {
-		aiptek->newSetting.stylusButtonLower =
-		    AIPTEK_STYLUS_UPPER_BUTTON;
-	} else if (strcmp(buf, "lower") == 0) {
-		aiptek->newSetting.stylusButtonLower =
-		    AIPTEK_STYLUS_LOWER_BUTTON;
-	}
+	if (new_button == AIPTEK_INVALID_VALUE)
+		return -EINVAL;
+
+	aiptek->newSetting.stylusButtonLower = new_button;
 	return count;
 }
 
@@ -1450,43 +1413,33 @@ static DEVICE_ATTR(stylus_lower,
  * support routines for the 'mouse_left' file. Note that this file
  * both displays current setting and allows for setting changing.
  */
+
+static struct aiptek_map mouse_button_map[] = {
+	{ "left",	AIPTEK_MOUSE_LEFT_BUTTON },
+	{ "middle",	AIPTEK_MOUSE_MIDDLE_BUTTON },
+	{ "right",	AIPTEK_MOUSE_RIGHT_BUTTON },
+	{ NULL,		AIPTEK_INVALID_VALUE }
+};
+
 static ssize_t show_tabletMouseLeft(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
-	char *s;
-
-	switch (aiptek->curSetting.mouseButtonLeft) {
-	case AIPTEK_MOUSE_LEFT_BUTTON:
-		s = "left";
-		break;
-
-	case AIPTEK_MOUSE_MIDDLE_BUTTON:
-		s = "middle";
-		break;
 
-	case AIPTEK_MOUSE_RIGHT_BUTTON:
-		s = "right";
-		break;
-
-	default:
-		s = "unknown";
-		break;
-	}
-	return snprintf(buf, PAGE_SIZE, "%s\n", s);
+	return snprintf(buf, PAGE_SIZE, "%s\n",
+			map_val_to_str(mouse_button_map,
+					aiptek->curSetting.mouseButtonLeft));
 }
 
 static ssize_t
 store_tabletMouseLeft(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
+	int new_button = map_str_to_val(mouse_button_map, buf, count);
 
-	if (strcmp(buf, "left") == 0) {
-		aiptek->newSetting.mouseButtonLeft = AIPTEK_MOUSE_LEFT_BUTTON;
-	} else if (strcmp(buf, "middle") == 0) {
-		aiptek->newSetting.mouseButtonLeft = AIPTEK_MOUSE_MIDDLE_BUTTON;
-	} else if (strcmp(buf, "right") == 0) {
-		aiptek->newSetting.mouseButtonLeft = AIPTEK_MOUSE_RIGHT_BUTTON;
-	}
+	if (new_button == AIPTEK_INVALID_VALUE)
+		return -EINVAL;
+
+	aiptek->newSetting.mouseButtonLeft = new_button;
 	return count;
 }
 
@@ -1501,42 +1454,22 @@ static DEVICE_ATTR(mouse_left,
 static ssize_t show_tabletMouseMiddle(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
-	char *s;
 
-	switch (aiptek->curSetting.mouseButtonMiddle) {
-	case AIPTEK_MOUSE_LEFT_BUTTON:
-		s = "left";
-		break;
-
-	case AIPTEK_MOUSE_MIDDLE_BUTTON:
-		s = "middle";
-		break;
-
-	case AIPTEK_MOUSE_RIGHT_BUTTON:
-		s = "right";
-		break;
-
-	default:
-		s = "unknown";
-		break;
-	}
-	return snprintf(buf, PAGE_SIZE, "%s\n", s);
+	return snprintf(buf, PAGE_SIZE, "%s\n",
+			map_val_to_str(mouse_button_map,
+					aiptek->curSetting.mouseButtonMiddle));
 }
 
 static ssize_t
 store_tabletMouseMiddle(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
+	int new_button = map_str_to_val(mouse_button_map, buf, count);
 
-	if (strcmp(buf, "left") == 0) {
-		aiptek->newSetting.mouseButtonMiddle = AIPTEK_MOUSE_LEFT_BUTTON;
-	} else if (strcmp(buf, "middle") == 0) {
-		aiptek->newSetting.mouseButtonMiddle =
-		    AIPTEK_MOUSE_MIDDLE_BUTTON;
-	} else if (strcmp(buf, "right") == 0) {
-		aiptek->newSetting.mouseButtonMiddle =
-		    AIPTEK_MOUSE_RIGHT_BUTTON;
-	}
+	if (new_button == AIPTEK_INVALID_VALUE)
+		return -EINVAL;
+
+	aiptek->newSetting.mouseButtonMiddle = new_button;
 	return count;
 }
 
@@ -1551,41 +1484,22 @@ static DEVICE_ATTR(mouse_middle,
 static ssize_t show_tabletMouseRight(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
-	char *s;
-
-	switch (aiptek->curSetting.mouseButtonRight) {
-	case AIPTEK_MOUSE_LEFT_BUTTON:
-		s = "left";
-		break;
-
-	case AIPTEK_MOUSE_MIDDLE_BUTTON:
-		s = "middle";
-		break;
 
-	case AIPTEK_MOUSE_RIGHT_BUTTON:
-		s = "right";
-		break;
-
-	default:
-		s = "unknown";
-		break;
-	}
-	return snprintf(buf, PAGE_SIZE, "%s\n", s);
+	return snprintf(buf, PAGE_SIZE, "%s\n",
+			map_val_to_str(mouse_button_map,
+					aiptek->curSetting.mouseButtonRight));
 }
 
 static ssize_t
 store_tabletMouseRight(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
+	int new_button = map_str_to_val(mouse_button_map, buf, count);
 
-	if (strcmp(buf, "left") == 0) {
-		aiptek->newSetting.mouseButtonRight = AIPTEK_MOUSE_LEFT_BUTTON;
-	} else if (strcmp(buf, "middle") == 0) {
-		aiptek->newSetting.mouseButtonRight =
-		    AIPTEK_MOUSE_MIDDLE_BUTTON;
-	} else if (strcmp(buf, "right") == 0) {
-		aiptek->newSetting.mouseButtonRight = AIPTEK_MOUSE_RIGHT_BUTTON;
-	}
+	if (new_button == AIPTEK_INVALID_VALUE)
+		return -EINVAL;
+
+	aiptek->newSetting.mouseButtonRight = new_button;
 	return count;
 }
 

commit 02fb6c385c72823af4fac83963a05be9163c73ea
Author: Dmitry Torokhov <dtor@insightbb.com>
Date:   Mon May 21 00:17:44 2007 -0400

    Input: aiptek - do not check for NULL in attribute methods
    
    It makes no sense to check for NULL in attribute methods -
    we do usb_set_intfdata before creating attributes and once
    attributes have been removed we are guaranteed to not be
    called.
    
    Signed-off-by: Rene van Paassen <rene.vanpaassen@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index 088da86f0508..274c12f4220b 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -1006,9 +1006,6 @@ static ssize_t show_tabletSize(struct device *dev, struct device_attribute *attr
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 
-	if (aiptek == NULL)
-		return 0;
-
 	return snprintf(buf, PAGE_SIZE, "%dx%d\n",
 			aiptek->inputdev->absmax[ABS_X] + 1,
 			aiptek->inputdev->absmax[ABS_Y] + 1);
@@ -1031,9 +1028,6 @@ static ssize_t show_tabletPointerMode(struct device *dev, struct device_attribut
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 	char *s;
 
-	if (aiptek == NULL)
-		return 0;
-
 	switch (aiptek->curSetting.pointerMode) {
 	case AIPTEK_POINTER_ONLY_STYLUS_MODE:
 		s = "stylus";
@@ -1058,8 +1052,6 @@ static ssize_t
 store_tabletPointerMode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
-	if (aiptek == NULL)
-		return 0;
 
 	if (strcmp(buf, "stylus") == 0) {
 		aiptek->newSetting.pointerMode =
@@ -1085,9 +1077,6 @@ static ssize_t show_tabletCoordinateMode(struct device *dev, struct device_attri
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 	char *s;
 
-	if (aiptek == NULL)
-		return 0;
-
 	switch (aiptek->curSetting.coordinateMode) {
 	case AIPTEK_COORDINATE_ABSOLUTE_MODE:
 		s = "absolute";
@@ -1108,8 +1097,6 @@ static ssize_t
 store_tabletCoordinateMode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
-	if (aiptek == NULL)
-		return 0;
 
 	if (strcmp(buf, "absolute") == 0) {
 		aiptek->newSetting.pointerMode =
@@ -1134,9 +1121,6 @@ static ssize_t show_tabletToolMode(struct device *dev, struct device_attribute *
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 	char *s;
 
-	if (aiptek == NULL)
-		return 0;
-
 	switch (TOOL_BUTTON(aiptek->curSetting.toolMode)) {
 	case AIPTEK_TOOL_BUTTON_MOUSE_MODE:
 		s = "mouse";
@@ -1177,8 +1161,6 @@ static ssize_t
 store_tabletToolMode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
-	if (aiptek == NULL)
-		return 0;
 
 	if (strcmp(buf, "mouse") == 0) {
 		aiptek->newSetting.toolMode = AIPTEK_TOOL_BUTTON_MOUSE_MODE;
@@ -1211,9 +1193,6 @@ static ssize_t show_tabletXtilt(struct device *dev, struct device_attribute *att
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 
-	if (aiptek == NULL)
-		return 0;
-
 	if (aiptek->curSetting.xTilt == AIPTEK_TILT_DISABLE) {
 		return snprintf(buf, PAGE_SIZE, "disable\n");
 	} else {
@@ -1228,9 +1207,6 @@ store_tabletXtilt(struct device *dev, struct device_attribute *attr, const char
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 	int x;
 
-	if (aiptek == NULL)
-		return 0;
-
 	if (strcmp(buf, "disable") == 0) {
 		aiptek->newSetting.xTilt = AIPTEK_TILT_DISABLE;
 	} else {
@@ -1253,9 +1229,6 @@ static ssize_t show_tabletYtilt(struct device *dev, struct device_attribute *att
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 
-	if (aiptek == NULL)
-		return 0;
-
 	if (aiptek->curSetting.yTilt == AIPTEK_TILT_DISABLE) {
 		return snprintf(buf, PAGE_SIZE, "disable\n");
 	} else {
@@ -1270,9 +1243,6 @@ store_tabletYtilt(struct device *dev, struct device_attribute *attr, const char
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 	int y;
 
-	if (aiptek == NULL)
-		return 0;
-
 	if (strcmp(buf, "disable") == 0) {
 		aiptek->newSetting.yTilt = AIPTEK_TILT_DISABLE;
 	} else {
@@ -1295,9 +1265,6 @@ static ssize_t show_tabletJitterDelay(struct device *dev, struct device_attribut
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 
-	if (aiptek == NULL)
-		return 0;
-
 	return snprintf(buf, PAGE_SIZE, "%d\n", aiptek->curSetting.jitterDelay);
 }
 
@@ -1306,9 +1273,6 @@ store_tabletJitterDelay(struct device *dev, struct device_attribute *attr, const
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 
-	if (aiptek == NULL)
-		return 0;
-
 	aiptek->newSetting.jitterDelay = (int)simple_strtol(buf, NULL, 10);
 	return count;
 }
@@ -1325,9 +1289,6 @@ static ssize_t show_tabletProgrammableDelay(struct device *dev, struct device_at
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 
-	if (aiptek == NULL)
-		return 0;
-
 	return snprintf(buf, PAGE_SIZE, "%d\n",
 			aiptek->curSetting.programmableDelay);
 }
@@ -1337,9 +1298,6 @@ store_tabletProgrammableDelay(struct device *dev, struct device_attribute *attr,
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 
-	if (aiptek == NULL)
-		return 0;
-
 	aiptek->newSetting.programmableDelay = (int)simple_strtol(buf, NULL, 10);
 	return count;
 }
@@ -1356,9 +1314,6 @@ static ssize_t show_tabletEventsReceived(struct device *dev, struct device_attri
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 
-	if (aiptek == NULL)
-		return 0;
-
 	return snprintf(buf, PAGE_SIZE, "%ld\n", aiptek->eventCount);
 }
 
@@ -1373,9 +1328,6 @@ static ssize_t show_tabletDiagnosticMessage(struct device *dev, struct device_at
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 	char *retMsg;
 
-	if (aiptek == NULL)
-		return 0;
-
 	switch (aiptek->diagnostic) {
 	case AIPTEK_DIAGNOSTIC_NA:
 		retMsg = "no errors\n";
@@ -1415,9 +1367,6 @@ static ssize_t show_tabletStylusUpper(struct device *dev, struct device_attribut
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 	char *s;
 
-	if (aiptek == NULL)
-		return 0;
-
 	switch (aiptek->curSetting.stylusButtonUpper) {
 	case AIPTEK_STYLUS_UPPER_BUTTON:
 		s = "upper";
@@ -1439,9 +1388,6 @@ store_tabletStylusUpper(struct device *dev, struct device_attribute *attr, const
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 
-	if (aiptek == NULL)
-		return 0;
-
 	if (strcmp(buf, "upper") == 0) {
 		aiptek->newSetting.stylusButtonUpper =
 		    AIPTEK_STYLUS_UPPER_BUTTON;
@@ -1465,9 +1411,6 @@ static ssize_t show_tabletStylusLower(struct device *dev, struct device_attribut
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 	char *s;
 
-	if (aiptek == NULL)
-		return 0;
-
 	switch (aiptek->curSetting.stylusButtonLower) {
 	case AIPTEK_STYLUS_UPPER_BUTTON:
 		s = "upper";
@@ -1489,9 +1432,6 @@ store_tabletStylusLower(struct device *dev, struct device_attribute *attr, const
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 
-	if (aiptek == NULL)
-		return 0;
-
 	if (strcmp(buf, "upper") == 0) {
 		aiptek->newSetting.stylusButtonLower =
 		    AIPTEK_STYLUS_UPPER_BUTTON;
@@ -1515,9 +1455,6 @@ static ssize_t show_tabletMouseLeft(struct device *dev, struct device_attribute
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 	char *s;
 
-	if (aiptek == NULL)
-		return 0;
-
 	switch (aiptek->curSetting.mouseButtonLeft) {
 	case AIPTEK_MOUSE_LEFT_BUTTON:
 		s = "left";
@@ -1543,9 +1480,6 @@ store_tabletMouseLeft(struct device *dev, struct device_attribute *attr, const c
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 
-	if (aiptek == NULL)
-		return 0;
-
 	if (strcmp(buf, "left") == 0) {
 		aiptek->newSetting.mouseButtonLeft = AIPTEK_MOUSE_LEFT_BUTTON;
 	} else if (strcmp(buf, "middle") == 0) {
@@ -1569,9 +1503,6 @@ static ssize_t show_tabletMouseMiddle(struct device *dev, struct device_attribut
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 	char *s;
 
-	if (aiptek == NULL)
-		return 0;
-
 	switch (aiptek->curSetting.mouseButtonMiddle) {
 	case AIPTEK_MOUSE_LEFT_BUTTON:
 		s = "left";
@@ -1597,9 +1528,6 @@ store_tabletMouseMiddle(struct device *dev, struct device_attribute *attr, const
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 
-	if (aiptek == NULL)
-		return 0;
-
 	if (strcmp(buf, "left") == 0) {
 		aiptek->newSetting.mouseButtonMiddle = AIPTEK_MOUSE_LEFT_BUTTON;
 	} else if (strcmp(buf, "middle") == 0) {
@@ -1625,9 +1553,6 @@ static ssize_t show_tabletMouseRight(struct device *dev, struct device_attribute
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 	char *s;
 
-	if (aiptek == NULL)
-		return 0;
-
 	switch (aiptek->curSetting.mouseButtonRight) {
 	case AIPTEK_MOUSE_LEFT_BUTTON:
 		s = "left";
@@ -1653,9 +1578,6 @@ store_tabletMouseRight(struct device *dev, struct device_attribute *attr, const
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 
-	if (aiptek == NULL)
-		return 0;
-
 	if (strcmp(buf, "left") == 0) {
 		aiptek->newSetting.mouseButtonRight = AIPTEK_MOUSE_LEFT_BUTTON;
 	} else if (strcmp(buf, "middle") == 0) {
@@ -1679,9 +1601,6 @@ static ssize_t show_tabletWheel(struct device *dev, struct device_attribute *att
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 
-	if (aiptek == NULL)
-		return 0;
-
 	if (aiptek->curSetting.wheel == AIPTEK_WHEEL_DISABLE) {
 		return snprintf(buf, PAGE_SIZE, "disable\n");
 	} else {
@@ -1695,9 +1614,6 @@ store_tabletWheel(struct device *dev, struct device_attribute *attr, const char
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 
-	if (aiptek == NULL)
-		return 0;
-
 	aiptek->newSetting.wheel = (int)simple_strtol(buf, NULL, 10);
 	return count;
 }
@@ -1711,11 +1627,6 @@ static DEVICE_ATTR(wheel,
  */
 static ssize_t show_tabletExecute(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-
-	if (aiptek == NULL)
-		return 0;
-
 	/* There is nothing useful to display, so a one-line manual
 	 * is in order...
 	 */
@@ -1728,9 +1639,6 @@ store_tabletExecute(struct device *dev, struct device_attribute *attr, const cha
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 
-	if (aiptek == NULL)
-		return 0;
-
 	/* We do not care what you write to this file. Merely the action
 	 * of writing to this file triggers a tablet reprogramming.
 	 */
@@ -1754,9 +1662,6 @@ static ssize_t show_tabletODMCode(struct device *dev, struct device_attribute *a
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 
-	if (aiptek == NULL)
-		return 0;
-
 	return snprintf(buf, PAGE_SIZE, "0x%04x\n", aiptek->features.odmCode);
 }
 
@@ -1770,9 +1675,6 @@ static ssize_t show_tabletModelCode(struct device *dev, struct device_attribute
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 
-	if (aiptek == NULL)
-		return 0;
-
 	return snprintf(buf, PAGE_SIZE, "0x%04x\n", aiptek->features.modelCode);
 }
 
@@ -1786,9 +1688,6 @@ static ssize_t show_firmwareCode(struct device *dev, struct device_attribute *at
 {
 	struct aiptek *aiptek = dev_get_drvdata(dev);
 
-	if (aiptek == NULL)
-		return 0;
-
 	return snprintf(buf, PAGE_SIZE, "%04x\n",
 			aiptek->features.firmwareCode);
 }

commit b087e1f3ee9ae4da49fdeca2b0f0f8fc5a886a79
Author: Dmitry Torokhov <dtor@insightbb.com>
Date:   Mon May 21 00:17:37 2007 -0400

    Input: aiptek - use attribute group
    
    Use attribute group to simplify error handling and reduce code.
    
    [Rene: add missing NULL to properly terminate aiptek_attributes]
    
    Signed-off-by: Rene van Paassen <rene.vanpaassen@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index f9a5f872505f..088da86f0508 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -1795,67 +1795,33 @@ static ssize_t show_firmwareCode(struct device *dev, struct device_attribute *at
 
 static DEVICE_ATTR(firmware_code, S_IRUGO, show_firmwareCode, NULL);
 
-/***********************************************************************
- * This routine removes all existing sysfs files managed by this device
- * driver.
- */
-static void aiptek_delete_files(struct device *dev)
-{
-	device_remove_file(dev, &dev_attr_size);
-	device_remove_file(dev, &dev_attr_pointer_mode);
-	device_remove_file(dev, &dev_attr_coordinate_mode);
-	device_remove_file(dev, &dev_attr_tool_mode);
-	device_remove_file(dev, &dev_attr_xtilt);
-	device_remove_file(dev, &dev_attr_ytilt);
-	device_remove_file(dev, &dev_attr_jitter);
-	device_remove_file(dev, &dev_attr_delay);
-	device_remove_file(dev, &dev_attr_event_count);
-	device_remove_file(dev, &dev_attr_diagnostic);
-	device_remove_file(dev, &dev_attr_odm_code);
-	device_remove_file(dev, &dev_attr_model_code);
-	device_remove_file(dev, &dev_attr_firmware_code);
-	device_remove_file(dev, &dev_attr_stylus_lower);
-	device_remove_file(dev, &dev_attr_stylus_upper);
-	device_remove_file(dev, &dev_attr_mouse_left);
-	device_remove_file(dev, &dev_attr_mouse_middle);
-	device_remove_file(dev, &dev_attr_mouse_right);
-	device_remove_file(dev, &dev_attr_wheel);
-	device_remove_file(dev, &dev_attr_execute);
-}
-
-/***********************************************************************
- * This routine creates the sysfs files managed by this device
- * driver.
- */
-static int aiptek_add_files(struct device *dev)
-{
-	int ret;
+static struct attribute *aiptek_attributes[] = {
+	&dev_attr_size.attr,
+	&dev_attr_pointer_mode.attr,
+	&dev_attr_coordinate_mode.attr,
+	&dev_attr_tool_mode.attr,
+	&dev_attr_xtilt.attr,
+	&dev_attr_ytilt.attr,
+	&dev_attr_jitter.attr,
+	&dev_attr_delay.attr,
+	&dev_attr_event_count.attr,
+	&dev_attr_diagnostic.attr,
+	&dev_attr_odm_code.attr,
+	&dev_attr_model_code.attr,
+	&dev_attr_firmware_code.attr,
+	&dev_attr_stylus_lower.attr,
+	&dev_attr_stylus_upper.attr,
+	&dev_attr_mouse_left.attr,
+	&dev_attr_mouse_middle.attr,
+	&dev_attr_mouse_right.attr,
+	&dev_attr_wheel.attr,
+	&dev_attr_execute.attr,
+	NULL
+};
 
-	if ((ret = device_create_file(dev, &dev_attr_size)) ||
-	    (ret = device_create_file(dev, &dev_attr_pointer_mode)) ||
-	    (ret = device_create_file(dev, &dev_attr_coordinate_mode)) ||
-	    (ret = device_create_file(dev, &dev_attr_tool_mode)) ||
-	    (ret = device_create_file(dev, &dev_attr_xtilt)) ||
-	    (ret = device_create_file(dev, &dev_attr_ytilt)) ||
-	    (ret = device_create_file(dev, &dev_attr_jitter)) ||
-	    (ret = device_create_file(dev, &dev_attr_delay)) ||
-	    (ret = device_create_file(dev, &dev_attr_event_count)) ||
-	    (ret = device_create_file(dev, &dev_attr_diagnostic)) ||
-	    (ret = device_create_file(dev, &dev_attr_odm_code)) ||
-	    (ret = device_create_file(dev, &dev_attr_model_code)) ||
-	    (ret = device_create_file(dev, &dev_attr_firmware_code)) ||
-	    (ret = device_create_file(dev, &dev_attr_stylus_lower)) ||
-	    (ret = device_create_file(dev, &dev_attr_stylus_upper)) ||
-	    (ret = device_create_file(dev, &dev_attr_mouse_left)) ||
-	    (ret = device_create_file(dev, &dev_attr_mouse_middle)) ||
-	    (ret = device_create_file(dev, &dev_attr_mouse_right)) ||
-	    (ret = device_create_file(dev, &dev_attr_wheel)) ||
-	    (ret = device_create_file(dev, &dev_attr_execute))) {
-		err("aiptek: killing own sysfs device files\n");
-		aiptek_delete_files(dev);
-	}
-	return ret;
-}
+static struct attribute_group aiptek_attribute_group = {
+	.attrs	= aiptek_attributes,
+};
 
 /***********************************************************************
  * This routine is called when a tablet has been identified. It basically
@@ -2039,25 +2005,30 @@ aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 		}
 	}
 
-	/* Register the tablet as an Input Device
-	 */
-	err = input_register_device(aiptek->inputdev);
-	if (err)
-		goto fail2;
-
 	/* Associate this driver's struct with the usb interface.
 	 */
 	usb_set_intfdata(intf, aiptek);
 
 	/* Set up the sysfs files
 	 */
-	aiptek_add_files(&intf->dev);
+	err = sysfs_create_group(&intf->dev.kobj, &aiptek_attribute_group);
+	if (err)
+		goto fail3;
+
+	/* Register the tablet as an Input Device
+	 */
+	err = input_register_device(aiptek->inputdev);
+	if (err)
+		goto fail4;
 
 	return 0;
 
+ fail4:	sysfs_remove_group(&intf->dev.kobj, &aiptek_attribute_group);
+ fail3: usb_free_urb(aiptek->urb);
  fail2:	usb_buffer_free(usbdev, AIPTEK_PACKET_LENGTH, aiptek->data,
 			aiptek->data_dma);
- fail1:	input_free_device(inputdev);
+ fail1: usb_set_intfdata(intf, NULL);
+	input_free_device(inputdev);
 	kfree(aiptek);
 	return err;
 }
@@ -2077,7 +2048,7 @@ static void aiptek_disconnect(struct usb_interface *intf)
 		 */
 		usb_kill_urb(aiptek->urb);
 		input_unregister_device(aiptek->inputdev);
-		aiptek_delete_files(&intf->dev);
+		sysfs_remove_group(&intf->dev.kobj, &aiptek_attribute_group);
 		usb_free_urb(aiptek->urb);
 		usb_buffer_free(interface_to_usbdev(intf),
 				AIPTEK_PACKET_LENGTH,

commit 5c659c62f9f60633a8de17bd17afaa448f1e1d68
Author: Dmitry Torokhov <dtor@insightbb.com>
Date:   Mon May 21 00:17:22 2007 -0400

    Input: aiptek - remove vendor and product attributes from sysfs
    
    They are already exported by input core; there is no need to do it twice.
    
    Signed-off-by: Rene van Paassen <rene.vanpaassen@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index c4df4f727f1f..f9a5f872505f 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -1022,71 +1022,6 @@ static ssize_t show_tabletSize(struct device *dev, struct device_attribute *attr
  */
 static DEVICE_ATTR(size, S_IRUGO, show_tabletSize, NULL);
 
-/***********************************************************************
- * support routines for the 'product_id' file
- */
-static ssize_t show_tabletProductId(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-
-	if (aiptek == NULL)
-		return 0;
-
-	return snprintf(buf, PAGE_SIZE, "0x%04x\n",
-			aiptek->inputdev->id.product);
-}
-
-static DEVICE_ATTR(product_id, S_IRUGO, show_tabletProductId, NULL);
-
-/***********************************************************************
- * support routines for the 'vendor_id' file
- */
-static ssize_t show_tabletVendorId(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-
-	if (aiptek == NULL)
-		return 0;
-
-	return snprintf(buf, PAGE_SIZE, "0x%04x\n", aiptek->inputdev->id.vendor);
-}
-
-static DEVICE_ATTR(vendor_id, S_IRUGO, show_tabletVendorId, NULL);
-
-/***********************************************************************
- * support routines for the 'vendor' file
- */
-static ssize_t show_tabletManufacturer(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-	int retval;
-
-	if (aiptek == NULL)
-		return 0;
-
-	retval = snprintf(buf, PAGE_SIZE, "%s\n", aiptek->usbdev->manufacturer);
-	return retval;
-}
-
-static DEVICE_ATTR(vendor, S_IRUGO, show_tabletManufacturer, NULL);
-
-/***********************************************************************
- * support routines for the 'product' file
- */
-static ssize_t show_tabletProduct(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-	int retval;
-
-	if (aiptek == NULL)
-		return 0;
-
-	retval = snprintf(buf, PAGE_SIZE, "%s\n", aiptek->usbdev->product);
-	return retval;
-}
-
-static DEVICE_ATTR(product, S_IRUGO, show_tabletProduct, NULL);
-
 /***********************************************************************
  * support routines for the 'pointer_mode' file. Note that this file
  * both displays current setting and allows reprogramming.
@@ -1867,10 +1802,6 @@ static DEVICE_ATTR(firmware_code, S_IRUGO, show_firmwareCode, NULL);
 static void aiptek_delete_files(struct device *dev)
 {
 	device_remove_file(dev, &dev_attr_size);
-	device_remove_file(dev, &dev_attr_product_id);
-	device_remove_file(dev, &dev_attr_vendor_id);
-	device_remove_file(dev, &dev_attr_vendor);
-	device_remove_file(dev, &dev_attr_product);
 	device_remove_file(dev, &dev_attr_pointer_mode);
 	device_remove_file(dev, &dev_attr_coordinate_mode);
 	device_remove_file(dev, &dev_attr_tool_mode);
@@ -1901,10 +1832,6 @@ static int aiptek_add_files(struct device *dev)
 	int ret;
 
 	if ((ret = device_create_file(dev, &dev_attr_size)) ||
-	    (ret = device_create_file(dev, &dev_attr_product_id)) ||
-	    (ret = device_create_file(dev, &dev_attr_vendor_id)) ||
-	    (ret = device_create_file(dev, &dev_attr_vendor)) ||
-	    (ret = device_create_file(dev, &dev_attr_product)) ||
 	    (ret = device_create_file(dev, &dev_attr_pointer_mode)) ||
 	    (ret = device_create_file(dev, &dev_attr_coordinate_mode)) ||
 	    (ret = device_create_file(dev, &dev_attr_tool_mode)) ||

commit 9b40ed088bb14ebed30540b19d5c417dc4d9d528
Author: Dmitry Torokhov <dtor@insightbb.com>
Date:   Mon May 21 00:17:12 2007 -0400

    Input: aiptek - do not try to export associated event device
    
    Do not try to export via sysfs associated event device - it does not
    work when evdev is a module that is loaded after aiptek; also it pokes
    too deply into input core internals.
    
    Userspace should rely on udev to set up permanent device name for
    the tablet.
    
    Signed-off-by: Rene van Paassen <rene.vanpaassen@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
index cc0a498763d8..c4df4f727f1f 100644
--- a/drivers/input/tablet/aiptek.c
+++ b/drivers/input/tablet/aiptek.c
@@ -294,7 +294,6 @@ struct aiptek_features {
 	int modelCode;		/* Tablet model code (not unique) */
 	int firmwareCode;	/* prom/eeprom version            */
 	char usbPath[64 + 1];	/* device's physical usb path     */
-	char inputPath[64 + 1];	/* input device path              */
 };
 
 struct aiptek_settings {
@@ -1414,23 +1413,6 @@ static DEVICE_ATTR(delay,
 		   S_IRUGO | S_IWUGO,
 		   show_tabletProgrammableDelay, store_tabletProgrammableDelay);
 
-/***********************************************************************
- * support routines for the 'input_path' file. Note that this file
- * only displays current setting.
- */
-static ssize_t show_tabletInputDevice(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	struct aiptek *aiptek = dev_get_drvdata(dev);
-
-	if (aiptek == NULL)
-		return 0;
-
-	return snprintf(buf, PAGE_SIZE, "/dev/input/%s\n",
-			aiptek->features.inputPath);
-}
-
-static DEVICE_ATTR(input_path, S_IRUGO, show_tabletInputDevice, NULL);
-
 /***********************************************************************
  * support routines for the 'event_count' file. Note that this file
  * only displays current setting.
@@ -1896,7 +1878,6 @@ static void aiptek_delete_files(struct device *dev)
 	device_remove_file(dev, &dev_attr_ytilt);
 	device_remove_file(dev, &dev_attr_jitter);
 	device_remove_file(dev, &dev_attr_delay);
-	device_remove_file(dev, &dev_attr_input_path);
 	device_remove_file(dev, &dev_attr_event_count);
 	device_remove_file(dev, &dev_attr_diagnostic);
 	device_remove_file(dev, &dev_attr_odm_code);
@@ -1931,7 +1912,6 @@ static int aiptek_add_files(struct device *dev)
 	    (ret = device_create_file(dev, &dev_attr_ytilt)) ||
 	    (ret = device_create_file(dev, &dev_attr_jitter)) ||
 	    (ret = device_create_file(dev, &dev_attr_delay)) ||
-	    (ret = device_create_file(dev, &dev_attr_input_path)) ||
 	    (ret = device_create_file(dev, &dev_attr_event_count)) ||
 	    (ret = device_create_file(dev, &dev_attr_diagnostic)) ||
 	    (ret = device_create_file(dev, &dev_attr_odm_code)) ||
@@ -1961,8 +1941,6 @@ aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	struct usb_endpoint_descriptor *endpoint;
 	struct aiptek *aiptek;
 	struct input_dev *inputdev;
-	struct input_handle *inputhandle;
-	struct list_head *node, *next;
 	int i;
 	int speeds[] = { 0,
 		AIPTEK_PROGRAMMABLE_DELAY_50,
@@ -2140,21 +2118,6 @@ aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	if (err)
 		goto fail2;
 
-	/* We now will look for the evdev device which is mapped to
-	 * the tablet. The partial name is kept in the link list of
-	 * input_handles associated with this input device.
-	 * What identifies an evdev input_handler is that it begins
-	 * with 'event', continues with a digit, and that in turn
-	 * is mapped to input/eventN.
-	 */
-	list_for_each_safe(node, next, &inputdev->h_list) {
-		inputhandle = to_handle(node);
-		if (strncmp(inputhandle->name, "event", 5) == 0) {
-			strcpy(aiptek->features.inputPath, inputhandle->name);
-			break;
-		}
-	}
-
 	/* Associate this driver's struct with the usb interface.
 	 */
 	usb_set_intfdata(intf, aiptek);
@@ -2163,11 +2126,6 @@ aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	 */
 	aiptek_add_files(&intf->dev);
 
-	/* Make sure the evdev module is loaded. Assuming evdev IS a module :-)
-	 */
-	if (request_module("evdev") != 0)
-		info("aiptek: error loading 'evdev' module");
-
 	return 0;
 
  fail2:	usb_buffer_free(usbdev, AIPTEK_PACKET_LENGTH, aiptek->data,

commit 4104d13fe0194736393d97c88ee045fb689c783b
Author: Dmitry Torokhov <dtor@insightbb.com>
Date:   Mon May 7 16:16:29 2007 -0400

    Input: move USB tablets under drivers/input/tablet
    
    This will allow concentrating all input devices in one place
    in {menu|x|q}config.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/input/tablet/aiptek.c b/drivers/input/tablet/aiptek.c
new file mode 100644
index 000000000000..cc0a498763d8
--- /dev/null
+++ b/drivers/input/tablet/aiptek.c
@@ -0,0 +1,2236 @@
+/*
+ *  Native support for the Aiptek HyperPen USB Tablets
+ *  (4000U/5000U/6000U/8000U/12000U)
+ *
+ *  Copyright (c) 2001      Chris Atenasio   <chris@crud.net>
+ *  Copyright (c) 2002-2004 Bryan W. Headley <bwheadley@earthlink.net>
+ *
+ *  based on wacom.c by
+ *     Vojtech Pavlik      <vojtech@suse.cz>
+ *     Andreas Bach Aaen   <abach@stofanet.dk>
+ *     Clifford Wolf       <clifford@clifford.at>
+ *     Sam Mosel           <sam.mosel@computer.org>
+ *     James E. Blair      <corvus@gnu.org>
+ *     Daniel Egger        <egger@suse.de>
+ *
+ *  Many thanks to Oliver Kuechemann for his support.
+ *
+ *  ChangeLog:
+ *      v0.1 - Initial release
+ *      v0.2 - Hack to get around fake event 28's. (Bryan W. Headley)
+ *      v0.3 - Make URB dynamic (Bryan W. Headley, Jun-8-2002)
+ *             Released to Linux 2.4.19 and 2.5.x
+ *      v0.4 - Rewrote substantial portions of the code to deal with
+ *             corrected control sequences, timing, dynamic configuration,
+ *             support of 6000U - 12000U, procfs, and macro key support
+ *             (Jan-1-2003 - Feb-5-2003, Bryan W. Headley)
+ *      v1.0 - Added support for diagnostic messages, count of messages
+ *             received from URB - Mar-8-2003, Bryan W. Headley
+ *      v1.1 - added support for tablet resolution, changed DV and proximity
+ *             some corrections - Jun-22-2003, martin schneebacher
+ *           - Added support for the sysfs interface, deprecating the
+ *             procfs interface for 2.5.x kernel. Also added support for
+ *             Wheel command. Bryan W. Headley July-15-2003.
+ *      v1.2 - Reworked jitter timer as a kernel thread.
+ *             Bryan W. Headley November-28-2003/Jan-10-2004.
+ *      v1.3 - Repaired issue of kernel thread going nuts on single-processor
+ *             machines, introduced programmableDelay as a command line
+ *             parameter. Feb 7 2004, Bryan W. Headley.
+ *      v1.4 - Re-wire jitter so it does not require a thread. Courtesy of
+ *             Rene van Paassen. Added reporting of physical pointer device
+ *             (e.g., stylus, mouse in reports 2, 3, 4, 5. We don't know
+ *             for reports 1, 6.)
+ *             what physical device reports for reports 1, 6.) Also enabled
+ *             MOUSE and LENS tool button modes. Renamed "rubber" to "eraser".
+ *             Feb 20, 2004, Bryan W. Headley.
+ *      v1.5 - Added previousJitterable, so we don't do jitter delay when the
+ *             user is holding a button down for periods of time.
+ *
+ * NOTE:
+ *      This kernel driver is augmented by the "Aiptek" XFree86 input
+ *      driver for your X server, as well as the Gaiptek GUI Front-end
+ *      "Tablet Manager".
+ *      These three products are highly interactive with one another,
+ *      so therefore it's easier to document them all as one subsystem.
+ *      Please visit the project's "home page", located at,
+ *      http://aiptektablet.sourceforge.net.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/jiffies.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/usb/input.h>
+#include <asm/uaccess.h>
+#include <asm/unaligned.h>
+
+/*
+ * Version Information
+ */
+#define DRIVER_VERSION "v1.5 (May-15-2004)"
+#define DRIVER_AUTHOR  "Bryan W. Headley/Chris Atenasio"
+#define DRIVER_DESC    "Aiptek HyperPen USB Tablet Driver (Linux 2.6.x)"
+
+/*
+ * Aiptek status packet:
+ *
+ * (returned as Report 1 - relative coordinates from mouse and stylus)
+ *
+ *        bit7  bit6  bit5  bit4  bit3  bit2  bit1  bit0
+ * byte0   0     0     0     0     0     0     0     1
+ * byte1   0     0     0     0     0    BS2   BS    Tip
+ * byte2  X7    X6    X5    X4    X3    X2    X1    X0
+ * byte3  Y7    Y6    Y5    Y4    Y3    Y2    Y1    Y0
+ *
+ * (returned as Report 2 - absolute coordinates from the stylus)
+ *
+ *        bit7  bit6  bit5  bit4  bit3  bit2  bit1  bit0
+ * byte0   0     0     0     0     0     0     1     0
+ * byte1  X7    X6    X5    X4    X3    X2    X1    X0
+ * byte2  X15   X14   X13   X12   X11   X10   X9    X8
+ * byte3  Y7    Y6    Y5    Y4    Y3    Y2    Y1    Y0
+ * byte4  Y15   Y14   Y13   Y12   Y11   Y10   Y9    Y8
+ * byte5   *     *     *    BS2   BS1   Tip   IR    DV
+ * byte6  P7    P6    P5    P4    P3    P2    P1    P0
+ * byte7  P15   P14   P13   P12   P11   P10   P9    P8
+ *
+ * (returned as Report 3 - absolute coordinates from the mouse)
+ *
+ *        bit7  bit6  bit5  bit4  bit3  bit2  bit1  bit0
+ * byte0   0     0     0     0     0     0     1     0
+ * byte1  X7    X6    X5    X4    X3    X2    X1    X0
+ * byte2  X15   X14   X13   X12   X11   X10   X9    X8
+ * byte3  Y7    Y6    Y5    Y4    Y3    Y2    Y1    Y0
+ * byte4  Y15   Y14   Y13   Y12   Y11   Y10   Y9    Y8
+ * byte5   *     *     *    BS2   BS1   Tip   IR    DV
+ * byte6  P7    P6    P5    P4    P3    P2    P1    P0
+ * byte7  P15   P14   P13   P12   P11   P10   P9    P8
+ *
+ * (returned as Report 4 - macrokeys from the stylus)
+ *
+ *        bit7  bit6  bit5  bit4  bit3  bit2  bit1  bit0
+ * byte0   0     0     0     0     0     1     0     0
+ * byte1   0     0     0    BS2   BS    Tip   IR    DV
+ * byte2   0     0     0     0     0     0     1     0
+ * byte3   0     0     0    K4    K3    K2    K1    K0
+ * byte4  P7    P6    P5    P4    P3    P2    P1    P0
+ * byte5  P15   P14   P13   P12   P11   P10   P9    P8
+ *
+ * (returned as Report 5 - macrokeys from the mouse)
+ *
+ *        bit7  bit6  bit5  bit4  bit3  bit2  bit1  bit0
+ * byte0   0     0     0     0     0     1     0     0
+ * byte1   0     0     0    BS2   BS    Tip   IR    DV
+ * byte2   0     0     0     0     0     0     1     0
+ * byte3   0     0     0    K4    K3    K2    K1    K0
+ * byte4  P7    P6    P5    P4    P3    P2    P1    P0
+ * byte5  P15   P14   P13   P12   P11   P10   P9    P8
+ *
+ * IR: In Range = Proximity on
+ * DV = Data Valid
+ * BS = Barrel Switch (as in, macro keys)
+ * BS2 also referred to as Tablet Pick
+ *
+ * Command Summary:
+ *
+ * Use report_type CONTROL (3)
+ * Use report_id   2
+ *
+ * Command/Data    Description     Return Bytes    Return Value
+ * 0x10/0x00       SwitchToMouse       0
+ * 0x10/0x01       SwitchToTablet      0
+ * 0x18/0x04       SetResolution       0
+ * 0x12/0xFF       AutoGainOn          0
+ * 0x17/0x00       FilterOn            0
+ * 0x01/0x00       GetXExtension       2           MaxX
+ * 0x01/0x01       GetYExtension       2           MaxY
+ * 0x02/0x00       GetModelCode        2           ModelCode = LOBYTE
+ * 0x03/0x00       GetODMCode          2           ODMCode
+ * 0x08/0x00       GetPressureLevels   2           =512
+ * 0x04/0x00       GetFirmwareVersion  2           Firmware Version
+ * 0x11/0x02       EnableMacroKeys     0
+ *
+ * To initialize the tablet:
+ *
+ * (1) Send Resolution500LPI (Command)
+ * (2) Query for Model code (Option Report)
+ * (3) Query for ODM code (Option Report)
+ * (4) Query for firmware (Option Report)
+ * (5) Query for GetXExtension (Option Report)
+ * (6) Query for GetYExtension (Option Report)
+ * (7) Query for GetPressureLevels (Option Report)
+ * (8) SwitchToTablet for Absolute coordinates, or
+ *     SwitchToMouse for Relative coordinates (Command)
+ * (9) EnableMacroKeys (Command)
+ * (10) FilterOn (Command)
+ * (11) AutoGainOn (Command)
+ *
+ * (Step 9 can be omitted, but you'll then have no function keys.)
+ */
+
+#define USB_VENDOR_ID_AIPTEK				0x08ca
+#define USB_REQ_GET_REPORT				0x01
+#define USB_REQ_SET_REPORT				0x09
+
+	/* PointerMode codes
+	 */
+#define AIPTEK_POINTER_ONLY_MOUSE_MODE			0
+#define AIPTEK_POINTER_ONLY_STYLUS_MODE			1
+#define AIPTEK_POINTER_EITHER_MODE			2
+
+#define AIPTEK_POINTER_ALLOW_MOUSE_MODE(a)		\
+	(a == AIPTEK_POINTER_ONLY_MOUSE_MODE ||		\
+	 a == AIPTEK_POINTER_EITHER_MODE)
+#define AIPTEK_POINTER_ALLOW_STYLUS_MODE(a)		\
+	(a == AIPTEK_POINTER_ONLY_STYLUS_MODE ||	\
+	 a == AIPTEK_POINTER_EITHER_MODE)
+
+	/* CoordinateMode code
+	 */
+#define AIPTEK_COORDINATE_RELATIVE_MODE			0
+#define AIPTEK_COORDINATE_ABSOLUTE_MODE			1
+
+       /* XTilt and YTilt values
+        */
+#define AIPTEK_TILT_MIN					(-128)
+#define AIPTEK_TILT_MAX					127
+#define AIPTEK_TILT_DISABLE				(-10101)
+
+	/* Wheel values
+	 */
+#define AIPTEK_WHEEL_MIN				0
+#define AIPTEK_WHEEL_MAX				1024
+#define AIPTEK_WHEEL_DISABLE				(-10101)
+
+	/* ToolCode values, which BTW are 0x140 .. 0x14f
+	 * We have things set up such that if TOOL_BUTTON_FIRED_BIT is
+	 * not set, we'll send one instance of AIPTEK_TOOL_BUTTON_xxx.
+	 *
+	 * Whenever the user resets the value, TOOL_BUTTON_FIRED_BIT will
+	 * get reset.
+	 */
+#define TOOL_BUTTON(x)					((x) & 0x14f)
+#define TOOL_BUTTON_FIRED(x)				((x) & 0x200)
+#define TOOL_BUTTON_FIRED_BIT				0x200
+	/* toolMode codes
+	 */
+#define AIPTEK_TOOL_BUTTON_PEN_MODE			BTN_TOOL_PEN
+#define AIPTEK_TOOL_BUTTON_PEN_MODE			BTN_TOOL_PEN
+#define AIPTEK_TOOL_BUTTON_PENCIL_MODE			BTN_TOOL_PENCIL
+#define AIPTEK_TOOL_BUTTON_BRUSH_MODE			BTN_TOOL_BRUSH
+#define AIPTEK_TOOL_BUTTON_AIRBRUSH_MODE		BTN_TOOL_AIRBRUSH
+#define AIPTEK_TOOL_BUTTON_ERASER_MODE			BTN_TOOL_RUBBER
+#define AIPTEK_TOOL_BUTTON_MOUSE_MODE			BTN_TOOL_MOUSE
+#define AIPTEK_TOOL_BUTTON_LENS_MODE			BTN_TOOL_LENS
+
+	/* Diagnostic message codes
+	 */
+#define AIPTEK_DIAGNOSTIC_NA				0
+#define AIPTEK_DIAGNOSTIC_SENDING_RELATIVE_IN_ABSOLUTE	1
+#define AIPTEK_DIAGNOSTIC_SENDING_ABSOLUTE_IN_RELATIVE	2
+#define AIPTEK_DIAGNOSTIC_TOOL_DISALLOWED		3
+
+	/* Time to wait (in ms) to help mask hand jittering
+	 * when pressing the stylus buttons.
+	 */
+#define AIPTEK_JITTER_DELAY_DEFAULT			50
+
+	/* Time to wait (in ms) in-between sending the tablet
+	 * a command and beginning the process of reading the return
+	 * sequence from the tablet.
+	 */
+#define AIPTEK_PROGRAMMABLE_DELAY_25		25
+#define AIPTEK_PROGRAMMABLE_DELAY_50		50
+#define AIPTEK_PROGRAMMABLE_DELAY_100		100
+#define AIPTEK_PROGRAMMABLE_DELAY_200		200
+#define AIPTEK_PROGRAMMABLE_DELAY_300		300
+#define AIPTEK_PROGRAMMABLE_DELAY_400		400
+#define AIPTEK_PROGRAMMABLE_DELAY_DEFAULT	AIPTEK_PROGRAMMABLE_DELAY_400
+
+	/* Mouse button programming
+	 */
+#define AIPTEK_MOUSE_LEFT_BUTTON		0x01
+#define AIPTEK_MOUSE_RIGHT_BUTTON		0x02
+#define AIPTEK_MOUSE_MIDDLE_BUTTON		0x04
+
+	/* Stylus button programming
+	 */
+#define AIPTEK_STYLUS_LOWER_BUTTON		0x08
+#define AIPTEK_STYLUS_UPPER_BUTTON		0x10
+
+	/* Length of incoming packet from the tablet
+	 */
+#define AIPTEK_PACKET_LENGTH			8
+
+	/* We report in EV_MISC both the proximity and
+	 * whether the report came from the stylus, tablet mouse
+	 * or "unknown" -- Unknown when the tablet is in relative
+	 * mode, because we only get report 1's.
+	 */
+#define AIPTEK_REPORT_TOOL_UNKNOWN		0x10
+#define AIPTEK_REPORT_TOOL_STYLUS		0x20
+#define AIPTEK_REPORT_TOOL_MOUSE		0x40
+
+static int programmableDelay = AIPTEK_PROGRAMMABLE_DELAY_DEFAULT;
+static int jitterDelay = AIPTEK_JITTER_DELAY_DEFAULT;
+
+struct aiptek_features {
+	int odmCode;		/* Tablet manufacturer code       */
+	int modelCode;		/* Tablet model code (not unique) */
+	int firmwareCode;	/* prom/eeprom version            */
+	char usbPath[64 + 1];	/* device's physical usb path     */
+	char inputPath[64 + 1];	/* input device path              */
+};
+
+struct aiptek_settings {
+	int pointerMode;	/* stylus-, mouse-only or either */
+	int coordinateMode;	/* absolute/relative coords      */
+	int toolMode;		/* pen, pencil, brush, etc. tool */
+	int xTilt;		/* synthetic xTilt amount        */
+	int yTilt;		/* synthetic yTilt amount        */
+	int wheel;		/* synthetic wheel amount        */
+	int stylusButtonUpper;	/* stylus upper btn delivers...  */
+	int stylusButtonLower;	/* stylus lower btn delivers...  */
+	int mouseButtonLeft;	/* mouse left btn delivers...    */
+	int mouseButtonMiddle;	/* mouse middle btn delivers...  */
+	int mouseButtonRight;	/* mouse right btn delivers...   */
+	int programmableDelay;	/* delay for tablet programming  */
+	int jitterDelay;	/* delay for hand jittering      */
+};
+
+struct aiptek {
+	struct input_dev *inputdev;		/* input device struct           */
+	struct usb_device *usbdev;		/* usb device struct             */
+	struct urb *urb;			/* urb for incoming reports      */
+	dma_addr_t data_dma;			/* our dma stuffage              */
+	struct aiptek_features features;	/* tablet's array of features    */
+	struct aiptek_settings curSetting;	/* tablet's current programmable */
+	struct aiptek_settings newSetting;	/* ... and new param settings    */
+	unsigned int ifnum;			/* interface number for IO       */
+	int diagnostic;				/* tablet diagnostic codes       */
+	unsigned long eventCount;		/* event count                   */
+	int inDelay;				/* jitter: in jitter delay?      */
+	unsigned long endDelay;			/* jitter: time when delay ends  */
+	int previousJitterable;			/* jitterable prev value     */
+	unsigned char *data;			/* incoming packet data          */
+};
+
+/*
+ * Permit easy lookup of keyboard events to send, versus
+ * the bitmap which comes from the tablet. This hides the
+ * issue that the F_keys are not sequentially numbered.
+ */
+static const int macroKeyEvents[] = {
+	KEY_ESC, KEY_F1, KEY_F2, KEY_F3, KEY_F4, KEY_F5,
+	KEY_F6, KEY_F7, KEY_F8, KEY_F9, KEY_F10, KEY_F11,
+	KEY_F12, KEY_F13, KEY_F14, KEY_F15, KEY_F16, KEY_F17,
+	KEY_F18, KEY_F19, KEY_F20, KEY_F21, KEY_F22, KEY_F23,
+	KEY_F24, KEY_STOP, KEY_AGAIN, KEY_PROPS, KEY_UNDO,
+	KEY_FRONT, KEY_COPY, KEY_OPEN, KEY_PASTE, 0
+};
+
+/***********************************************************************
+ * Relative reports deliver values in 2's complement format to
+ * deal with negative offsets.
+ */
+static int aiptek_convert_from_2s_complement(unsigned char c)
+{
+	int ret;
+	unsigned char b = c;
+	int negate = 0;
+
+	if ((b & 0x80) != 0) {
+		b = ~b;
+		b--;
+		negate = 1;
+	}
+	ret = b;
+	ret = (negate == 1) ? -ret : ret;
+	return ret;
+}
+
+/***********************************************************************
+ * aiptek_irq can receive one of six potential reports.
+ * The documentation for each is in the body of the function.
+ *
+ * The tablet reports on several attributes per invocation of
+ * aiptek_irq. Because the Linux Input Event system allows the
+ * transmission of ONE attribute per input_report_xxx() call,
+ * collation has to be done on the other end to reconstitute
+ * a complete tablet report. Further, the number of Input Event reports
+ * submitted varies, depending on what USB report type, and circumstance.
+ * To deal with this, EV_MSC is used to indicate an 'end-of-report'
+ * message. This has been an undocumented convention understood by the kernel
+ * tablet driver and clients such as gpm and XFree86's tablet drivers.
+ *
+ * Of the information received from the tablet, the one piece I
+ * cannot transmit is the proximity bit (without resorting to an EV_MSC
+ * convention above.) I therefore have taken over REL_MISC and ABS_MISC
+ * (for relative and absolute reports, respectively) for communicating
+ * Proximity. Why two events? I thought it interesting to know if the
+ * Proximity event occurred while the tablet was in absolute or relative
+ * mode.
+ *
+ * Other tablets use the notion of a certain minimum stylus pressure
+ * to infer proximity. While that could have been done, that is yet
+ * another 'by convention' behavior, the documentation for which
+ * would be spread between two (or more) pieces of software.
+ *
+ * EV_MSC usage was terminated for this purpose in Linux 2.5.x, and
+ * replaced with the input_sync() method (which emits EV_SYN.)
+ */
+
+static void aiptek_irq(struct urb *urb)
+{
+	struct aiptek *aiptek = urb->context;
+	unsigned char *data = aiptek->data;
+	struct input_dev *inputdev = aiptek->inputdev;
+	int jitterable = 0;
+	int retval, macro, x, y, z, left, right, middle, p, dv, tip, bs, pck;
+
+	switch (urb->status) {
+	case 0:
+		/* Success */
+		break;
+
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+		/* This urb is terminated, clean up */
+		dbg("%s - urb shutting down with status: %d",
+		    __FUNCTION__, urb->status);
+		return;
+
+	default:
+		dbg("%s - nonzero urb status received: %d",
+		    __FUNCTION__, urb->status);
+		goto exit;
+	}
+
+	/* See if we are in a delay loop -- throw out report if true.
+	 */
+	if (aiptek->inDelay == 1 && time_after(aiptek->endDelay, jiffies)) {
+		goto exit;
+	}
+
+	aiptek->inDelay = 0;
+	aiptek->eventCount++;
+
+	/* Report 1 delivers relative coordinates with either a stylus
+	 * or the mouse. You do not know, however, which input
+	 * tool generated the event.
+	 */
+	if (data[0] == 1) {
+		if (aiptek->curSetting.coordinateMode ==
+		    AIPTEK_COORDINATE_ABSOLUTE_MODE) {
+			aiptek->diagnostic =
+			    AIPTEK_DIAGNOSTIC_SENDING_RELATIVE_IN_ABSOLUTE;
+		} else {
+			x = aiptek_convert_from_2s_complement(data[2]);
+			y = aiptek_convert_from_2s_complement(data[3]);
+
+			/* jitterable keeps track of whether any button has been pressed.
+			 * We're also using it to remap the physical mouse button mask
+			 * to pseudo-settings. (We don't specifically care about it's
+			 * value after moving/transposing mouse button bitmasks, except
+			 * that a non-zero value indicates that one or more
+			 * mouse button was pressed.)
+			 */
+			jitterable = data[5] & 0x07;
+
+			left = (data[5] & aiptek->curSetting.mouseButtonLeft) != 0 ? 1 : 0;
+			right = (data[5] & aiptek->curSetting.mouseButtonRight) != 0 ? 1 : 0;
+			middle = (data[5] & aiptek->curSetting.mouseButtonMiddle) != 0 ? 1 : 0;
+
+			input_report_key(inputdev, BTN_LEFT, left);
+			input_report_key(inputdev, BTN_MIDDLE, middle);
+			input_report_key(inputdev, BTN_RIGHT, right);
+			input_report_rel(inputdev, REL_X, x);
+			input_report_rel(inputdev, REL_Y, y);
+			input_report_rel(inputdev, REL_MISC, 1 | AIPTEK_REPORT_TOOL_UNKNOWN);
+
+			/* Wheel support is in the form of a single-event
+			 * firing.
+			 */
+			if (aiptek->curSetting.wheel != AIPTEK_WHEEL_DISABLE) {
+				input_report_rel(inputdev, REL_WHEEL,
+						 aiptek->curSetting.wheel);
+				aiptek->curSetting.wheel = AIPTEK_WHEEL_DISABLE;
+			}
+			input_sync(inputdev);
+		}
+	}
+	/* Report 2 is delivered only by the stylus, and delivers
+	 * absolute coordinates.
+	 */
+	else if (data[0] == 2) {
+		if (aiptek->curSetting.coordinateMode == AIPTEK_COORDINATE_RELATIVE_MODE) {
+			aiptek->diagnostic = AIPTEK_DIAGNOSTIC_SENDING_ABSOLUTE_IN_RELATIVE;
+		} else if (!AIPTEK_POINTER_ALLOW_STYLUS_MODE
+			    (aiptek->curSetting.pointerMode)) {
+				aiptek->diagnostic = AIPTEK_DIAGNOSTIC_TOOL_DISALLOWED;
+		} else {
+			x = le16_to_cpu(get_unaligned((__le16 *) (data + 1)));
+			y = le16_to_cpu(get_unaligned((__le16 *) (data + 3)));
+			z = le16_to_cpu(get_unaligned((__le16 *) (data + 6)));
+
+			p = (data[5] & 0x01) != 0 ? 1 : 0;
+			dv = (data[5] & 0x02) != 0 ? 1 : 0;
+			tip = (data[5] & 0x04) != 0 ? 1 : 0;
+
+			/* Use jitterable to re-arrange button masks
+			 */
+			jitterable = data[5] & 0x18;
+
+			bs = (data[5] & aiptek->curSetting.stylusButtonLower) != 0 ? 1 : 0;
+			pck = (data[5] & aiptek->curSetting.stylusButtonUpper) != 0 ? 1 : 0;
+
+			/* dv indicates 'data valid' (e.g., the tablet is in sync
+			 * and has delivered a "correct" report) We will ignore
+			 * all 'bad' reports...
+			 */
+			if (dv != 0) {
+				/* If we've not already sent a tool_button_?? code, do
+				 * so now. Then set FIRED_BIT so it won't be resent unless
+				 * the user forces FIRED_BIT off.
+				 */
+				if (TOOL_BUTTON_FIRED
+				    (aiptek->curSetting.toolMode) == 0) {
+					input_report_key(inputdev,
+							 TOOL_BUTTON(aiptek->curSetting.toolMode),
+							 1);
+					aiptek->curSetting.toolMode |= TOOL_BUTTON_FIRED_BIT;
+				}
+
+				if (p != 0) {
+					input_report_abs(inputdev, ABS_X, x);
+					input_report_abs(inputdev, ABS_Y, y);
+					input_report_abs(inputdev, ABS_PRESSURE, z);
+
+					input_report_key(inputdev, BTN_TOUCH, tip);
+					input_report_key(inputdev, BTN_STYLUS, bs);
+					input_report_key(inputdev, BTN_STYLUS2, pck);
+
+					if (aiptek->curSetting.xTilt !=
+					    AIPTEK_TILT_DISABLE) {
+						input_report_abs(inputdev,
+								 ABS_TILT_X,
+								 aiptek->curSetting.xTilt);
+					}
+					if (aiptek->curSetting.yTilt != AIPTEK_TILT_DISABLE) {
+						input_report_abs(inputdev,
+								 ABS_TILT_Y,
+								 aiptek->curSetting.yTilt);
+					}
+
+					/* Wheel support is in the form of a single-event
+					 * firing.
+					 */
+					if (aiptek->curSetting.wheel !=
+					    AIPTEK_WHEEL_DISABLE) {
+						input_report_abs(inputdev,
+								 ABS_WHEEL,
+								 aiptek->curSetting.wheel);
+						aiptek->curSetting.wheel = AIPTEK_WHEEL_DISABLE;
+					}
+				}
+				input_report_abs(inputdev, ABS_MISC, p | AIPTEK_REPORT_TOOL_STYLUS);
+				input_sync(inputdev);
+			}
+		}
+	}
+	/* Report 3's come from the mouse in absolute mode.
+	 */
+	else if (data[0] == 3) {
+		if (aiptek->curSetting.coordinateMode == AIPTEK_COORDINATE_RELATIVE_MODE) {
+			aiptek->diagnostic = AIPTEK_DIAGNOSTIC_SENDING_ABSOLUTE_IN_RELATIVE;
+		} else if (!AIPTEK_POINTER_ALLOW_MOUSE_MODE
+			(aiptek->curSetting.pointerMode)) {
+			aiptek->diagnostic = AIPTEK_DIAGNOSTIC_TOOL_DISALLOWED;
+		} else {
+			x = le16_to_cpu(get_unaligned((__le16 *) (data + 1)));
+			y = le16_to_cpu(get_unaligned((__le16 *) (data + 3)));
+
+			jitterable = data[5] & 0x1c;
+
+			p = (data[5] & 0x01) != 0 ? 1 : 0;
+			dv = (data[5] & 0x02) != 0 ? 1 : 0;
+			left = (data[5] & aiptek->curSetting.mouseButtonLeft) != 0 ? 1 : 0;
+			right = (data[5] & aiptek->curSetting.mouseButtonRight) != 0 ? 1 : 0;
+			middle = (data[5] & aiptek->curSetting.mouseButtonMiddle) != 0 ? 1 : 0;
+
+			if (dv != 0) {
+				/* If we've not already sent a tool_button_?? code, do
+				 * so now. Then set FIRED_BIT so it won't be resent unless
+				 * the user forces FIRED_BIT off.
+				 */
+				if (TOOL_BUTTON_FIRED
+				    (aiptek->curSetting.toolMode) == 0) {
+					input_report_key(inputdev,
+							 TOOL_BUTTON(aiptek->curSetting.toolMode),
+							 1);
+					aiptek->curSetting.toolMode |= TOOL_BUTTON_FIRED_BIT;
+				}
+
+				if (p != 0) {
+					input_report_abs(inputdev, ABS_X, x);
+					input_report_abs(inputdev, ABS_Y, y);
+
+					input_report_key(inputdev, BTN_LEFT, left);
+					input_report_key(inputdev, BTN_MIDDLE, middle);
+					input_report_key(inputdev, BTN_RIGHT, right);
+
+					/* Wheel support is in the form of a single-event
+					 * firing.
+					 */
+					if (aiptek->curSetting.wheel != AIPTEK_WHEEL_DISABLE) {
+						input_report_abs(inputdev,
+								 ABS_WHEEL,
+								 aiptek->curSetting.wheel);
+						aiptek->curSetting.wheel = AIPTEK_WHEEL_DISABLE;
+					}
+				}
+				input_report_rel(inputdev, REL_MISC, p | AIPTEK_REPORT_TOOL_MOUSE);
+				input_sync(inputdev);
+			}
+		}
+	}
+	/* Report 4s come from the macro keys when pressed by stylus
+	 */
+	else if (data[0] == 4) {
+		jitterable = data[1] & 0x18;
+
+		p = (data[1] & 0x01) != 0 ? 1 : 0;
+		dv = (data[1] & 0x02) != 0 ? 1 : 0;
+		tip = (data[1] & 0x04) != 0 ? 1 : 0;
+		bs = (data[1] & aiptek->curSetting.stylusButtonLower) != 0 ? 1 : 0;
+		pck = (data[1] & aiptek->curSetting.stylusButtonUpper) != 0 ? 1 : 0;
+
+		macro = data[3];
+		z = le16_to_cpu(get_unaligned((__le16 *) (data + 4)));
+
+		if (dv != 0) {
+			/* If we've not already sent a tool_button_?? code, do
+			 * so now. Then set FIRED_BIT so it won't be resent unless
+			 * the user forces FIRED_BIT off.
+			 */
+			if (TOOL_BUTTON_FIRED(aiptek->curSetting.toolMode) == 0) {
+				input_report_key(inputdev,
+						 TOOL_BUTTON(aiptek->curSetting.toolMode),
+						 1);
+				aiptek->curSetting.toolMode |= TOOL_BUTTON_FIRED_BIT;
+			}
+
+			if (p != 0) {
+				input_report_key(inputdev, BTN_TOUCH, tip);
+				input_report_key(inputdev, BTN_STYLUS, bs);
+				input_report_key(inputdev, BTN_STYLUS2, pck);
+				input_report_abs(inputdev, ABS_PRESSURE, z);
+			}
+
+			/* For safety, we're sending key 'break' codes for the
+			 * neighboring macro keys.
+			 */
+			if (macro > 0) {
+				input_report_key(inputdev,
+						 macroKeyEvents[macro - 1], 0);
+			}
+			if (macro < 25) {
+				input_report_key(inputdev,
+						 macroKeyEvents[macro + 1], 0);
+			}
+			input_report_key(inputdev, macroKeyEvents[macro], p);
+			input_report_abs(inputdev, ABS_MISC,
+					 p | AIPTEK_REPORT_TOOL_STYLUS);
+			input_sync(inputdev);
+		}
+	}
+	/* Report 5s come from the macro keys when pressed by mouse
+	 */
+	else if (data[0] == 5) {
+		jitterable = data[1] & 0x1c;
+
+		p = (data[1] & 0x01) != 0 ? 1 : 0;
+		dv = (data[1] & 0x02) != 0 ? 1 : 0;
+		left = (data[1]& aiptek->curSetting.mouseButtonLeft) != 0 ? 1 : 0;
+		right = (data[1] & aiptek->curSetting.mouseButtonRight) != 0 ? 1 : 0;
+		middle = (data[1] & aiptek->curSetting.mouseButtonMiddle) != 0 ? 1 : 0;
+		macro = data[3];
+
+		if (dv != 0) {
+			/* If we've not already sent a tool_button_?? code, do
+			 * so now. Then set FIRED_BIT so it won't be resent unless
+			 * the user forces FIRED_BIT off.
+			 */
+			if (TOOL_BUTTON_FIRED(aiptek->curSetting.toolMode) == 0) {
+				input_report_key(inputdev,
+						 TOOL_BUTTON(aiptek->curSetting.toolMode),
+						 1);
+				aiptek->curSetting.toolMode |= TOOL_BUTTON_FIRED_BIT;
+			}
+
+			if (p != 0) {
+				input_report_key(inputdev, BTN_LEFT, left);
+				input_report_key(inputdev, BTN_MIDDLE, middle);
+				input_report_key(inputdev, BTN_RIGHT, right);
+			}
+
+			/* For safety, we're sending key 'break' codes for the
+			 * neighboring macro keys.
+			 */
+			if (macro > 0) {
+				input_report_key(inputdev,
+						 macroKeyEvents[macro - 1], 0);
+			}
+			if (macro < 25) {
+				input_report_key(inputdev,
+						 macroKeyEvents[macro + 1], 0);
+			}
+
+			input_report_key(inputdev, macroKeyEvents[macro], 1);
+			input_report_rel(inputdev, ABS_MISC,
+					 p | AIPTEK_REPORT_TOOL_MOUSE);
+			input_sync(inputdev);
+		}
+	}
+	/* We have no idea which tool can generate a report 6. Theoretically,
+	 * neither need to, having been given reports 4 & 5 for such use.
+	 * However, report 6 is the 'official-looking' report for macroKeys;
+	 * reports 4 & 5 supposively are used to support unnamed, unknown
+	 * hat switches (which just so happen to be the macroKeys.)
+	 */
+	else if (data[0] == 6) {
+		macro = le16_to_cpu(get_unaligned((__le16 *) (data + 1)));
+		if (macro > 0) {
+			input_report_key(inputdev, macroKeyEvents[macro - 1],
+					 0);
+		}
+		if (macro < 25) {
+			input_report_key(inputdev, macroKeyEvents[macro + 1],
+					 0);
+		}
+
+		/* If we've not already sent a tool_button_?? code, do
+		 * so now. Then set FIRED_BIT so it won't be resent unless
+		 * the user forces FIRED_BIT off.
+		 */
+		if (TOOL_BUTTON_FIRED(aiptek->curSetting.toolMode) == 0) {
+			input_report_key(inputdev,
+					 TOOL_BUTTON(aiptek->curSetting.
+						     toolMode), 1);
+			aiptek->curSetting.toolMode |= TOOL_BUTTON_FIRED_BIT;
+		}
+
+		input_report_key(inputdev, macroKeyEvents[macro], 1);
+		input_report_abs(inputdev, ABS_MISC,
+				 1 | AIPTEK_REPORT_TOOL_UNKNOWN);
+		input_sync(inputdev);
+	} else {
+		dbg("Unknown report %d", data[0]);
+	}
+
+	/* Jitter may occur when the user presses a button on the stlyus
+	 * or the mouse. What we do to prevent that is wait 'x' milliseconds
+	 * following a 'jitterable' event, which should give the hand some time
+	 * stabilize itself.
+	 *
+	 * We just introduced aiptek->previousJitterable to carry forth the
+	 * notion that jitter occurs when the button state changes from on to off:
+	 * a person drawing, holding a button down is not subject to jittering.
+	 * With that in mind, changing from upper button depressed to lower button
+	 * WILL transition through a jitter delay.
+	 */
+
+	if (aiptek->previousJitterable != jitterable &&
+	    aiptek->curSetting.jitterDelay != 0 && aiptek->inDelay != 1) {
+		aiptek->endDelay = jiffies +
+		    ((aiptek->curSetting.jitterDelay * HZ) / 1000);
+		aiptek->inDelay = 1;
+	}
+	aiptek->previousJitterable = jitterable;
+
+exit:
+	retval = usb_submit_urb(urb, GFP_ATOMIC);
+	if (retval != 0) {
+		err("%s - usb_submit_urb failed with result %d",
+		    __FUNCTION__, retval);
+	}
+}
+
+/***********************************************************************
+ * These are the USB id's known so far. We do not identify them to
+ * specific Aiptek model numbers, because there has been overlaps,
+ * use, and reuse of id's in existing models. Certain models have
+ * been known to use more than one ID, indicative perhaps of
+ * manufacturing revisions. In any event, we consider these
+ * IDs to not be model-specific nor unique.
+ */
+static const struct usb_device_id aiptek_ids[] = {
+	{USB_DEVICE(USB_VENDOR_ID_AIPTEK, 0x01)},
+	{USB_DEVICE(USB_VENDOR_ID_AIPTEK, 0x10)},
+	{USB_DEVICE(USB_VENDOR_ID_AIPTEK, 0x20)},
+	{USB_DEVICE(USB_VENDOR_ID_AIPTEK, 0x21)},
+	{USB_DEVICE(USB_VENDOR_ID_AIPTEK, 0x22)},
+	{USB_DEVICE(USB_VENDOR_ID_AIPTEK, 0x23)},
+	{USB_DEVICE(USB_VENDOR_ID_AIPTEK, 0x24)},
+	{}
+};
+
+MODULE_DEVICE_TABLE(usb, aiptek_ids);
+
+/***********************************************************************
+ * Open an instance of the tablet driver.
+ */
+static int aiptek_open(struct input_dev *inputdev)
+{
+	struct aiptek *aiptek = input_get_drvdata(inputdev);
+
+	aiptek->urb->dev = aiptek->usbdev;
+	if (usb_submit_urb(aiptek->urb, GFP_KERNEL) != 0)
+		return -EIO;
+
+	return 0;
+}
+
+/***********************************************************************
+ * Close an instance of the tablet driver.
+ */
+static void aiptek_close(struct input_dev *inputdev)
+{
+	struct aiptek *aiptek = input_get_drvdata(inputdev);
+
+	usb_kill_urb(aiptek->urb);
+}
+
+/***********************************************************************
+ * aiptek_set_report and aiptek_get_report() are borrowed from Linux 2.4.x,
+ * where they were known as usb_set_report and usb_get_report.
+ */
+static int
+aiptek_set_report(struct aiptek *aiptek,
+		  unsigned char report_type,
+		  unsigned char report_id, void *buffer, int size)
+{
+	return usb_control_msg(aiptek->usbdev,
+			       usb_sndctrlpipe(aiptek->usbdev, 0),
+			       USB_REQ_SET_REPORT,
+			       USB_TYPE_CLASS | USB_RECIP_INTERFACE |
+			       USB_DIR_OUT, (report_type << 8) + report_id,
+			       aiptek->ifnum, buffer, size, 5000);
+}
+
+static int
+aiptek_get_report(struct aiptek *aiptek,
+		  unsigned char report_type,
+		  unsigned char report_id, void *buffer, int size)
+{
+	return usb_control_msg(aiptek->usbdev,
+			       usb_rcvctrlpipe(aiptek->usbdev, 0),
+			       USB_REQ_GET_REPORT,
+			       USB_TYPE_CLASS | USB_RECIP_INTERFACE |
+			       USB_DIR_IN, (report_type << 8) + report_id,
+			       aiptek->ifnum, buffer, size, 5000);
+}
+
+/***********************************************************************
+ * Send a command to the tablet.
+ */
+static int
+aiptek_command(struct aiptek *aiptek, unsigned char command, unsigned char data)
+{
+	const int sizeof_buf = 3 * sizeof(u8);
+	int ret;
+	u8 *buf;
+
+	buf = kmalloc(sizeof_buf, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	buf[0] = 2;
+	buf[1] = command;
+	buf[2] = data;
+
+	if ((ret =
+	     aiptek_set_report(aiptek, 3, 2, buf, sizeof_buf)) != sizeof_buf) {
+		dbg("aiptek_program: failed, tried to send: 0x%02x 0x%02x",
+		    command, data);
+	}
+	kfree(buf);
+	return ret < 0 ? ret : 0;
+}
+
+/***********************************************************************
+ * Retrieve information from the tablet. Querying info is defined as first
+ * sending the {command,data} sequence as a command, followed by a wait
+ * (aka, "programmaticDelay") and then a "read" request.
+ */
+static int
+aiptek_query(struct aiptek *aiptek, unsigned char command, unsigned char data)
+{
+	const int sizeof_buf = 3 * sizeof(u8);
+	int ret;
+	u8 *buf;
+
+	buf = kmalloc(sizeof_buf, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	buf[0] = 2;
+	buf[1] = command;
+	buf[2] = data;
+
+	if (aiptek_command(aiptek, command, data) != 0) {
+		kfree(buf);
+		return -EIO;
+	}
+	msleep(aiptek->curSetting.programmableDelay);
+
+	if ((ret =
+	     aiptek_get_report(aiptek, 3, 2, buf, sizeof_buf)) != sizeof_buf) {
+		dbg("aiptek_query failed: returned 0x%02x 0x%02x 0x%02x",
+		    buf[0], buf[1], buf[2]);
+		ret = -EIO;
+	} else {
+		ret = le16_to_cpu(get_unaligned((__le16 *) (buf + 1)));
+	}
+	kfree(buf);
+	return ret;
+}
+
+/***********************************************************************
+ * Program the tablet into either absolute or relative mode.
+ * We also get information about the tablet's size.
+ */
+static int aiptek_program_tablet(struct aiptek *aiptek)
+{
+	int ret;
+	/* Execute Resolution500LPI */
+	if ((ret = aiptek_command(aiptek, 0x18, 0x04)) < 0)
+		return ret;
+
+	/* Query getModelCode */
+	if ((ret = aiptek_query(aiptek, 0x02, 0x00)) < 0)
+		return ret;
+	aiptek->features.modelCode = ret & 0xff;
+
+	/* Query getODMCode */
+	if ((ret = aiptek_query(aiptek, 0x03, 0x00)) < 0)
+		return ret;
+	aiptek->features.odmCode = ret;
+
+	/* Query getFirmwareCode */
+	if ((ret = aiptek_query(aiptek, 0x04, 0x00)) < 0)
+		return ret;
+	aiptek->features.firmwareCode = ret;
+
+	/* Query getXextension */
+	if ((ret = aiptek_query(aiptek, 0x01, 0x00)) < 0)
+		return ret;
+	aiptek->inputdev->absmin[ABS_X] = 0;
+	aiptek->inputdev->absmax[ABS_X] = ret - 1;
+
+	/* Query getYextension */
+	if ((ret = aiptek_query(aiptek, 0x01, 0x01)) < 0)
+		return ret;
+	aiptek->inputdev->absmin[ABS_Y] = 0;
+	aiptek->inputdev->absmax[ABS_Y] = ret - 1;
+
+	/* Query getPressureLevels */
+	if ((ret = aiptek_query(aiptek, 0x08, 0x00)) < 0)
+		return ret;
+	aiptek->inputdev->absmin[ABS_PRESSURE] = 0;
+	aiptek->inputdev->absmax[ABS_PRESSURE] = ret - 1;
+
+	/* Depending on whether we are in absolute or relative mode, we will
+	 * do a switchToTablet(absolute) or switchToMouse(relative) command.
+	 */
+	if (aiptek->curSetting.coordinateMode ==
+	    AIPTEK_COORDINATE_ABSOLUTE_MODE) {
+		/* Execute switchToTablet */
+		if ((ret = aiptek_command(aiptek, 0x10, 0x01)) < 0) {
+			return ret;
+		}
+	} else {
+		/* Execute switchToMouse */
+		if ((ret = aiptek_command(aiptek, 0x10, 0x00)) < 0) {
+			return ret;
+		}
+	}
+
+	/* Enable the macro keys */
+	if ((ret = aiptek_command(aiptek, 0x11, 0x02)) < 0)
+		return ret;
+#if 0
+	/* Execute FilterOn */
+	if ((ret = aiptek_command(aiptek, 0x17, 0x00)) < 0)
+		return ret;
+#endif
+
+	/* Execute AutoGainOn */
+	if ((ret = aiptek_command(aiptek, 0x12, 0xff)) < 0)
+		return ret;
+
+	/* Reset the eventCount, so we track events from last (re)programming
+	 */
+	aiptek->diagnostic = AIPTEK_DIAGNOSTIC_NA;
+	aiptek->eventCount = 0;
+
+	return 0;
+}
+
+/***********************************************************************
+ * Sysfs functions. Sysfs prefers that individually-tunable parameters
+ * exist in their separate pseudo-files. Summary data that is immutable
+ * may exist in a singular file so long as you don't define a writeable
+ * interface.
+ */
+
+/***********************************************************************
+ * support the 'size' file -- display support
+ */
+static ssize_t show_tabletSize(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+
+	if (aiptek == NULL)
+		return 0;
+
+	return snprintf(buf, PAGE_SIZE, "%dx%d\n",
+			aiptek->inputdev->absmax[ABS_X] + 1,
+			aiptek->inputdev->absmax[ABS_Y] + 1);
+}
+
+/* These structs define the sysfs files, param #1 is the name of the
+ * file, param 2 is the file permissions, param 3 & 4 are to the
+ * output generator and input parser routines. Absence of a routine is
+ * permitted -- it only means can't either 'cat' the file, or send data
+ * to it.
+ */
+static DEVICE_ATTR(size, S_IRUGO, show_tabletSize, NULL);
+
+/***********************************************************************
+ * support routines for the 'product_id' file
+ */
+static ssize_t show_tabletProductId(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+
+	if (aiptek == NULL)
+		return 0;
+
+	return snprintf(buf, PAGE_SIZE, "0x%04x\n",
+			aiptek->inputdev->id.product);
+}
+
+static DEVICE_ATTR(product_id, S_IRUGO, show_tabletProductId, NULL);
+
+/***********************************************************************
+ * support routines for the 'vendor_id' file
+ */
+static ssize_t show_tabletVendorId(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+
+	if (aiptek == NULL)
+		return 0;
+
+	return snprintf(buf, PAGE_SIZE, "0x%04x\n", aiptek->inputdev->id.vendor);
+}
+
+static DEVICE_ATTR(vendor_id, S_IRUGO, show_tabletVendorId, NULL);
+
+/***********************************************************************
+ * support routines for the 'vendor' file
+ */
+static ssize_t show_tabletManufacturer(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+	int retval;
+
+	if (aiptek == NULL)
+		return 0;
+
+	retval = snprintf(buf, PAGE_SIZE, "%s\n", aiptek->usbdev->manufacturer);
+	return retval;
+}
+
+static DEVICE_ATTR(vendor, S_IRUGO, show_tabletManufacturer, NULL);
+
+/***********************************************************************
+ * support routines for the 'product' file
+ */
+static ssize_t show_tabletProduct(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+	int retval;
+
+	if (aiptek == NULL)
+		return 0;
+
+	retval = snprintf(buf, PAGE_SIZE, "%s\n", aiptek->usbdev->product);
+	return retval;
+}
+
+static DEVICE_ATTR(product, S_IRUGO, show_tabletProduct, NULL);
+
+/***********************************************************************
+ * support routines for the 'pointer_mode' file. Note that this file
+ * both displays current setting and allows reprogramming.
+ */
+static ssize_t show_tabletPointerMode(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+	char *s;
+
+	if (aiptek == NULL)
+		return 0;
+
+	switch (aiptek->curSetting.pointerMode) {
+	case AIPTEK_POINTER_ONLY_STYLUS_MODE:
+		s = "stylus";
+		break;
+
+	case AIPTEK_POINTER_ONLY_MOUSE_MODE:
+		s = "mouse";
+		break;
+
+	case AIPTEK_POINTER_EITHER_MODE:
+		s = "either";
+		break;
+
+	default:
+		s = "unknown";
+		break;
+	}
+	return snprintf(buf, PAGE_SIZE, "%s\n", s);
+}
+
+static ssize_t
+store_tabletPointerMode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+	if (aiptek == NULL)
+		return 0;
+
+	if (strcmp(buf, "stylus") == 0) {
+		aiptek->newSetting.pointerMode =
+		    AIPTEK_POINTER_ONLY_STYLUS_MODE;
+	} else if (strcmp(buf, "mouse") == 0) {
+		aiptek->newSetting.pointerMode = AIPTEK_POINTER_ONLY_MOUSE_MODE;
+	} else if (strcmp(buf, "either") == 0) {
+		aiptek->newSetting.pointerMode = AIPTEK_POINTER_EITHER_MODE;
+	}
+	return count;
+}
+
+static DEVICE_ATTR(pointer_mode,
+		   S_IRUGO | S_IWUGO,
+		   show_tabletPointerMode, store_tabletPointerMode);
+
+/***********************************************************************
+ * support routines for the 'coordinate_mode' file. Note that this file
+ * both displays current setting and allows reprogramming.
+ */
+static ssize_t show_tabletCoordinateMode(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+	char *s;
+
+	if (aiptek == NULL)
+		return 0;
+
+	switch (aiptek->curSetting.coordinateMode) {
+	case AIPTEK_COORDINATE_ABSOLUTE_MODE:
+		s = "absolute";
+		break;
+
+	case AIPTEK_COORDINATE_RELATIVE_MODE:
+		s = "relative";
+		break;
+
+	default:
+		s = "unknown";
+		break;
+	}
+	return snprintf(buf, PAGE_SIZE, "%s\n", s);
+}
+
+static ssize_t
+store_tabletCoordinateMode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+	if (aiptek == NULL)
+		return 0;
+
+	if (strcmp(buf, "absolute") == 0) {
+		aiptek->newSetting.pointerMode =
+		    AIPTEK_COORDINATE_ABSOLUTE_MODE;
+	} else if (strcmp(buf, "relative") == 0) {
+		aiptek->newSetting.pointerMode =
+		    AIPTEK_COORDINATE_RELATIVE_MODE;
+	}
+	return count;
+}
+
+static DEVICE_ATTR(coordinate_mode,
+		   S_IRUGO | S_IWUGO,
+		   show_tabletCoordinateMode, store_tabletCoordinateMode);
+
+/***********************************************************************
+ * support routines for the 'tool_mode' file. Note that this file
+ * both displays current setting and allows reprogramming.
+ */
+static ssize_t show_tabletToolMode(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+	char *s;
+
+	if (aiptek == NULL)
+		return 0;
+
+	switch (TOOL_BUTTON(aiptek->curSetting.toolMode)) {
+	case AIPTEK_TOOL_BUTTON_MOUSE_MODE:
+		s = "mouse";
+		break;
+
+	case AIPTEK_TOOL_BUTTON_ERASER_MODE:
+		s = "eraser";
+		break;
+
+	case AIPTEK_TOOL_BUTTON_PENCIL_MODE:
+		s = "pencil";
+		break;
+
+	case AIPTEK_TOOL_BUTTON_PEN_MODE:
+		s = "pen";
+		break;
+
+	case AIPTEK_TOOL_BUTTON_BRUSH_MODE:
+		s = "brush";
+		break;
+
+	case AIPTEK_TOOL_BUTTON_AIRBRUSH_MODE:
+		s = "airbrush";
+		break;
+
+	case AIPTEK_TOOL_BUTTON_LENS_MODE:
+		s = "lens";
+		break;
+
+	default:
+		s = "unknown";
+		break;
+	}
+	return snprintf(buf, PAGE_SIZE, "%s\n", s);
+}
+
+static ssize_t
+store_tabletToolMode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+	if (aiptek == NULL)
+		return 0;
+
+	if (strcmp(buf, "mouse") == 0) {
+		aiptek->newSetting.toolMode = AIPTEK_TOOL_BUTTON_MOUSE_MODE;
+	} else if (strcmp(buf, "eraser") == 0) {
+		aiptek->newSetting.toolMode = AIPTEK_TOOL_BUTTON_ERASER_MODE;
+	} else if (strcmp(buf, "pencil") == 0) {
+		aiptek->newSetting.toolMode = AIPTEK_TOOL_BUTTON_PENCIL_MODE;
+	} else if (strcmp(buf, "pen") == 0) {
+		aiptek->newSetting.toolMode = AIPTEK_TOOL_BUTTON_PEN_MODE;
+	} else if (strcmp(buf, "brush") == 0) {
+		aiptek->newSetting.toolMode = AIPTEK_TOOL_BUTTON_BRUSH_MODE;
+	} else if (strcmp(buf, "airbrush") == 0) {
+		aiptek->newSetting.toolMode = AIPTEK_TOOL_BUTTON_AIRBRUSH_MODE;
+	} else if (strcmp(buf, "lens") == 0) {
+		aiptek->newSetting.toolMode = AIPTEK_TOOL_BUTTON_LENS_MODE;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(tool_mode,
+		   S_IRUGO | S_IWUGO,
+		   show_tabletToolMode, store_tabletToolMode);
+
+/***********************************************************************
+ * support routines for the 'xtilt' file. Note that this file
+ * both displays current setting and allows reprogramming.
+ */
+static ssize_t show_tabletXtilt(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+
+	if (aiptek == NULL)
+		return 0;
+
+	if (aiptek->curSetting.xTilt == AIPTEK_TILT_DISABLE) {
+		return snprintf(buf, PAGE_SIZE, "disable\n");
+	} else {
+		return snprintf(buf, PAGE_SIZE, "%d\n",
+				aiptek->curSetting.xTilt);
+	}
+}
+
+static ssize_t
+store_tabletXtilt(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+	int x;
+
+	if (aiptek == NULL)
+		return 0;
+
+	if (strcmp(buf, "disable") == 0) {
+		aiptek->newSetting.xTilt = AIPTEK_TILT_DISABLE;
+	} else {
+		x = (int)simple_strtol(buf, NULL, 10);
+		if (x >= AIPTEK_TILT_MIN && x <= AIPTEK_TILT_MAX) {
+			aiptek->newSetting.xTilt = x;
+		}
+	}
+	return count;
+}
+
+static DEVICE_ATTR(xtilt,
+		   S_IRUGO | S_IWUGO, show_tabletXtilt, store_tabletXtilt);
+
+/***********************************************************************
+ * support routines for the 'ytilt' file. Note that this file
+ * both displays current setting and allows reprogramming.
+ */
+static ssize_t show_tabletYtilt(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+
+	if (aiptek == NULL)
+		return 0;
+
+	if (aiptek->curSetting.yTilt == AIPTEK_TILT_DISABLE) {
+		return snprintf(buf, PAGE_SIZE, "disable\n");
+	} else {
+		return snprintf(buf, PAGE_SIZE, "%d\n",
+				aiptek->curSetting.yTilt);
+	}
+}
+
+static ssize_t
+store_tabletYtilt(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+	int y;
+
+	if (aiptek == NULL)
+		return 0;
+
+	if (strcmp(buf, "disable") == 0) {
+		aiptek->newSetting.yTilt = AIPTEK_TILT_DISABLE;
+	} else {
+		y = (int)simple_strtol(buf, NULL, 10);
+		if (y >= AIPTEK_TILT_MIN && y <= AIPTEK_TILT_MAX) {
+			aiptek->newSetting.yTilt = y;
+		}
+	}
+	return count;
+}
+
+static DEVICE_ATTR(ytilt,
+		   S_IRUGO | S_IWUGO, show_tabletYtilt, store_tabletYtilt);
+
+/***********************************************************************
+ * support routines for the 'jitter' file. Note that this file
+ * both displays current setting and allows reprogramming.
+ */
+static ssize_t show_tabletJitterDelay(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+
+	if (aiptek == NULL)
+		return 0;
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", aiptek->curSetting.jitterDelay);
+}
+
+static ssize_t
+store_tabletJitterDelay(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+
+	if (aiptek == NULL)
+		return 0;
+
+	aiptek->newSetting.jitterDelay = (int)simple_strtol(buf, NULL, 10);
+	return count;
+}
+
+static DEVICE_ATTR(jitter,
+		   S_IRUGO | S_IWUGO,
+		   show_tabletJitterDelay, store_tabletJitterDelay);
+
+/***********************************************************************
+ * support routines for the 'delay' file. Note that this file
+ * both displays current setting and allows reprogramming.
+ */
+static ssize_t show_tabletProgrammableDelay(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+
+	if (aiptek == NULL)
+		return 0;
+
+	return snprintf(buf, PAGE_SIZE, "%d\n",
+			aiptek->curSetting.programmableDelay);
+}
+
+static ssize_t
+store_tabletProgrammableDelay(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+
+	if (aiptek == NULL)
+		return 0;
+
+	aiptek->newSetting.programmableDelay = (int)simple_strtol(buf, NULL, 10);
+	return count;
+}
+
+static DEVICE_ATTR(delay,
+		   S_IRUGO | S_IWUGO,
+		   show_tabletProgrammableDelay, store_tabletProgrammableDelay);
+
+/***********************************************************************
+ * support routines for the 'input_path' file. Note that this file
+ * only displays current setting.
+ */
+static ssize_t show_tabletInputDevice(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+
+	if (aiptek == NULL)
+		return 0;
+
+	return snprintf(buf, PAGE_SIZE, "/dev/input/%s\n",
+			aiptek->features.inputPath);
+}
+
+static DEVICE_ATTR(input_path, S_IRUGO, show_tabletInputDevice, NULL);
+
+/***********************************************************************
+ * support routines for the 'event_count' file. Note that this file
+ * only displays current setting.
+ */
+static ssize_t show_tabletEventsReceived(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+
+	if (aiptek == NULL)
+		return 0;
+
+	return snprintf(buf, PAGE_SIZE, "%ld\n", aiptek->eventCount);
+}
+
+static DEVICE_ATTR(event_count, S_IRUGO, show_tabletEventsReceived, NULL);
+
+/***********************************************************************
+ * support routines for the 'diagnostic' file. Note that this file
+ * only displays current setting.
+ */
+static ssize_t show_tabletDiagnosticMessage(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+	char *retMsg;
+
+	if (aiptek == NULL)
+		return 0;
+
+	switch (aiptek->diagnostic) {
+	case AIPTEK_DIAGNOSTIC_NA:
+		retMsg = "no errors\n";
+		break;
+
+	case AIPTEK_DIAGNOSTIC_SENDING_RELATIVE_IN_ABSOLUTE:
+		retMsg = "Error: receiving relative reports\n";
+		break;
+
+	case AIPTEK_DIAGNOSTIC_SENDING_ABSOLUTE_IN_RELATIVE:
+		retMsg = "Error: receiving absolute reports\n";
+		break;
+
+	case AIPTEK_DIAGNOSTIC_TOOL_DISALLOWED:
+		if (aiptek->curSetting.pointerMode ==
+		    AIPTEK_POINTER_ONLY_MOUSE_MODE) {
+			retMsg = "Error: receiving stylus reports\n";
+		} else {
+			retMsg = "Error: receiving mouse reports\n";
+		}
+		break;
+
+	default:
+		return 0;
+	}
+	return snprintf(buf, PAGE_SIZE, retMsg);
+}
+
+static DEVICE_ATTR(diagnostic, S_IRUGO, show_tabletDiagnosticMessage, NULL);
+
+/***********************************************************************
+ * support routines for the 'stylus_upper' file. Note that this file
+ * both displays current setting and allows for setting changing.
+ */
+static ssize_t show_tabletStylusUpper(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+	char *s;
+
+	if (aiptek == NULL)
+		return 0;
+
+	switch (aiptek->curSetting.stylusButtonUpper) {
+	case AIPTEK_STYLUS_UPPER_BUTTON:
+		s = "upper";
+		break;
+
+	case AIPTEK_STYLUS_LOWER_BUTTON:
+		s = "lower";
+		break;
+
+	default:
+		s = "unknown";
+		break;
+	}
+	return snprintf(buf, PAGE_SIZE, "%s\n", s);
+}
+
+static ssize_t
+store_tabletStylusUpper(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+
+	if (aiptek == NULL)
+		return 0;
+
+	if (strcmp(buf, "upper") == 0) {
+		aiptek->newSetting.stylusButtonUpper =
+		    AIPTEK_STYLUS_UPPER_BUTTON;
+	} else if (strcmp(buf, "lower") == 0) {
+		aiptek->newSetting.stylusButtonUpper =
+		    AIPTEK_STYLUS_LOWER_BUTTON;
+	}
+	return count;
+}
+
+static DEVICE_ATTR(stylus_upper,
+		   S_IRUGO | S_IWUGO,
+		   show_tabletStylusUpper, store_tabletStylusUpper);
+
+/***********************************************************************
+ * support routines for the 'stylus_lower' file. Note that this file
+ * both displays current setting and allows for setting changing.
+ */
+static ssize_t show_tabletStylusLower(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+	char *s;
+
+	if (aiptek == NULL)
+		return 0;
+
+	switch (aiptek->curSetting.stylusButtonLower) {
+	case AIPTEK_STYLUS_UPPER_BUTTON:
+		s = "upper";
+		break;
+
+	case AIPTEK_STYLUS_LOWER_BUTTON:
+		s = "lower";
+		break;
+
+	default:
+		s = "unknown";
+		break;
+	}
+	return snprintf(buf, PAGE_SIZE, "%s\n", s);
+}
+
+static ssize_t
+store_tabletStylusLower(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+
+	if (aiptek == NULL)
+		return 0;
+
+	if (strcmp(buf, "upper") == 0) {
+		aiptek->newSetting.stylusButtonLower =
+		    AIPTEK_STYLUS_UPPER_BUTTON;
+	} else if (strcmp(buf, "lower") == 0) {
+		aiptek->newSetting.stylusButtonLower =
+		    AIPTEK_STYLUS_LOWER_BUTTON;
+	}
+	return count;
+}
+
+static DEVICE_ATTR(stylus_lower,
+		   S_IRUGO | S_IWUGO,
+		   show_tabletStylusLower, store_tabletStylusLower);
+
+/***********************************************************************
+ * support routines for the 'mouse_left' file. Note that this file
+ * both displays current setting and allows for setting changing.
+ */
+static ssize_t show_tabletMouseLeft(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+	char *s;
+
+	if (aiptek == NULL)
+		return 0;
+
+	switch (aiptek->curSetting.mouseButtonLeft) {
+	case AIPTEK_MOUSE_LEFT_BUTTON:
+		s = "left";
+		break;
+
+	case AIPTEK_MOUSE_MIDDLE_BUTTON:
+		s = "middle";
+		break;
+
+	case AIPTEK_MOUSE_RIGHT_BUTTON:
+		s = "right";
+		break;
+
+	default:
+		s = "unknown";
+		break;
+	}
+	return snprintf(buf, PAGE_SIZE, "%s\n", s);
+}
+
+static ssize_t
+store_tabletMouseLeft(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+
+	if (aiptek == NULL)
+		return 0;
+
+	if (strcmp(buf, "left") == 0) {
+		aiptek->newSetting.mouseButtonLeft = AIPTEK_MOUSE_LEFT_BUTTON;
+	} else if (strcmp(buf, "middle") == 0) {
+		aiptek->newSetting.mouseButtonLeft = AIPTEK_MOUSE_MIDDLE_BUTTON;
+	} else if (strcmp(buf, "right") == 0) {
+		aiptek->newSetting.mouseButtonLeft = AIPTEK_MOUSE_RIGHT_BUTTON;
+	}
+	return count;
+}
+
+static DEVICE_ATTR(mouse_left,
+		   S_IRUGO | S_IWUGO,
+		   show_tabletMouseLeft, store_tabletMouseLeft);
+
+/***********************************************************************
+ * support routines for the 'mouse_middle' file. Note that this file
+ * both displays current setting and allows for setting changing.
+ */
+static ssize_t show_tabletMouseMiddle(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+	char *s;
+
+	if (aiptek == NULL)
+		return 0;
+
+	switch (aiptek->curSetting.mouseButtonMiddle) {
+	case AIPTEK_MOUSE_LEFT_BUTTON:
+		s = "left";
+		break;
+
+	case AIPTEK_MOUSE_MIDDLE_BUTTON:
+		s = "middle";
+		break;
+
+	case AIPTEK_MOUSE_RIGHT_BUTTON:
+		s = "right";
+		break;
+
+	default:
+		s = "unknown";
+		break;
+	}
+	return snprintf(buf, PAGE_SIZE, "%s\n", s);
+}
+
+static ssize_t
+store_tabletMouseMiddle(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+
+	if (aiptek == NULL)
+		return 0;
+
+	if (strcmp(buf, "left") == 0) {
+		aiptek->newSetting.mouseButtonMiddle = AIPTEK_MOUSE_LEFT_BUTTON;
+	} else if (strcmp(buf, "middle") == 0) {
+		aiptek->newSetting.mouseButtonMiddle =
+		    AIPTEK_MOUSE_MIDDLE_BUTTON;
+	} else if (strcmp(buf, "right") == 0) {
+		aiptek->newSetting.mouseButtonMiddle =
+		    AIPTEK_MOUSE_RIGHT_BUTTON;
+	}
+	return count;
+}
+
+static DEVICE_ATTR(mouse_middle,
+		   S_IRUGO | S_IWUGO,
+		   show_tabletMouseMiddle, store_tabletMouseMiddle);
+
+/***********************************************************************
+ * support routines for the 'mouse_right' file. Note that this file
+ * both displays current setting and allows for setting changing.
+ */
+static ssize_t show_tabletMouseRight(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+	char *s;
+
+	if (aiptek == NULL)
+		return 0;
+
+	switch (aiptek->curSetting.mouseButtonRight) {
+	case AIPTEK_MOUSE_LEFT_BUTTON:
+		s = "left";
+		break;
+
+	case AIPTEK_MOUSE_MIDDLE_BUTTON:
+		s = "middle";
+		break;
+
+	case AIPTEK_MOUSE_RIGHT_BUTTON:
+		s = "right";
+		break;
+
+	default:
+		s = "unknown";
+		break;
+	}
+	return snprintf(buf, PAGE_SIZE, "%s\n", s);
+}
+
+static ssize_t
+store_tabletMouseRight(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+
+	if (aiptek == NULL)
+		return 0;
+
+	if (strcmp(buf, "left") == 0) {
+		aiptek->newSetting.mouseButtonRight = AIPTEK_MOUSE_LEFT_BUTTON;
+	} else if (strcmp(buf, "middle") == 0) {
+		aiptek->newSetting.mouseButtonRight =
+		    AIPTEK_MOUSE_MIDDLE_BUTTON;
+	} else if (strcmp(buf, "right") == 0) {
+		aiptek->newSetting.mouseButtonRight = AIPTEK_MOUSE_RIGHT_BUTTON;
+	}
+	return count;
+}
+
+static DEVICE_ATTR(mouse_right,
+		   S_IRUGO | S_IWUGO,
+		   show_tabletMouseRight, store_tabletMouseRight);
+
+/***********************************************************************
+ * support routines for the 'wheel' file. Note that this file
+ * both displays current setting and allows for setting changing.
+ */
+static ssize_t show_tabletWheel(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+
+	if (aiptek == NULL)
+		return 0;
+
+	if (aiptek->curSetting.wheel == AIPTEK_WHEEL_DISABLE) {
+		return snprintf(buf, PAGE_SIZE, "disable\n");
+	} else {
+		return snprintf(buf, PAGE_SIZE, "%d\n",
+				aiptek->curSetting.wheel);
+	}
+}
+
+static ssize_t
+store_tabletWheel(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+
+	if (aiptek == NULL)
+		return 0;
+
+	aiptek->newSetting.wheel = (int)simple_strtol(buf, NULL, 10);
+	return count;
+}
+
+static DEVICE_ATTR(wheel,
+		   S_IRUGO | S_IWUGO, show_tabletWheel, store_tabletWheel);
+
+/***********************************************************************
+ * support routines for the 'execute' file. Note that this file
+ * both displays current setting and allows for setting changing.
+ */
+static ssize_t show_tabletExecute(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+
+	if (aiptek == NULL)
+		return 0;
+
+	/* There is nothing useful to display, so a one-line manual
+	 * is in order...
+	 */
+	return snprintf(buf, PAGE_SIZE,
+			"Write anything to this file to program your tablet.\n");
+}
+
+static ssize_t
+store_tabletExecute(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+
+	if (aiptek == NULL)
+		return 0;
+
+	/* We do not care what you write to this file. Merely the action
+	 * of writing to this file triggers a tablet reprogramming.
+	 */
+	memcpy(&aiptek->curSetting, &aiptek->newSetting,
+	       sizeof(struct aiptek_settings));
+
+	if (aiptek_program_tablet(aiptek) < 0)
+		return -EIO;
+
+	return count;
+}
+
+static DEVICE_ATTR(execute,
+		   S_IRUGO | S_IWUGO, show_tabletExecute, store_tabletExecute);
+
+/***********************************************************************
+ * support routines for the 'odm_code' file. Note that this file
+ * only displays current setting.
+ */
+static ssize_t show_tabletODMCode(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+
+	if (aiptek == NULL)
+		return 0;
+
+	return snprintf(buf, PAGE_SIZE, "0x%04x\n", aiptek->features.odmCode);
+}
+
+static DEVICE_ATTR(odm_code, S_IRUGO, show_tabletODMCode, NULL);
+
+/***********************************************************************
+ * support routines for the 'model_code' file. Note that this file
+ * only displays current setting.
+ */
+static ssize_t show_tabletModelCode(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+
+	if (aiptek == NULL)
+		return 0;
+
+	return snprintf(buf, PAGE_SIZE, "0x%04x\n", aiptek->features.modelCode);
+}
+
+static DEVICE_ATTR(model_code, S_IRUGO, show_tabletModelCode, NULL);
+
+/***********************************************************************
+ * support routines for the 'firmware_code' file. Note that this file
+ * only displays current setting.
+ */
+static ssize_t show_firmwareCode(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct aiptek *aiptek = dev_get_drvdata(dev);
+
+	if (aiptek == NULL)
+		return 0;
+
+	return snprintf(buf, PAGE_SIZE, "%04x\n",
+			aiptek->features.firmwareCode);
+}
+
+static DEVICE_ATTR(firmware_code, S_IRUGO, show_firmwareCode, NULL);
+
+/***********************************************************************
+ * This routine removes all existing sysfs files managed by this device
+ * driver.
+ */
+static void aiptek_delete_files(struct device *dev)
+{
+	device_remove_file(dev, &dev_attr_size);
+	device_remove_file(dev, &dev_attr_product_id);
+	device_remove_file(dev, &dev_attr_vendor_id);
+	device_remove_file(dev, &dev_attr_vendor);
+	device_remove_file(dev, &dev_attr_product);
+	device_remove_file(dev, &dev_attr_pointer_mode);
+	device_remove_file(dev, &dev_attr_coordinate_mode);
+	device_remove_file(dev, &dev_attr_tool_mode);
+	device_remove_file(dev, &dev_attr_xtilt);
+	device_remove_file(dev, &dev_attr_ytilt);
+	device_remove_file(dev, &dev_attr_jitter);
+	device_remove_file(dev, &dev_attr_delay);
+	device_remove_file(dev, &dev_attr_input_path);
+	device_remove_file(dev, &dev_attr_event_count);
+	device_remove_file(dev, &dev_attr_diagnostic);
+	device_remove_file(dev, &dev_attr_odm_code);
+	device_remove_file(dev, &dev_attr_model_code);
+	device_remove_file(dev, &dev_attr_firmware_code);
+	device_remove_file(dev, &dev_attr_stylus_lower);
+	device_remove_file(dev, &dev_attr_stylus_upper);
+	device_remove_file(dev, &dev_attr_mouse_left);
+	device_remove_file(dev, &dev_attr_mouse_middle);
+	device_remove_file(dev, &dev_attr_mouse_right);
+	device_remove_file(dev, &dev_attr_wheel);
+	device_remove_file(dev, &dev_attr_execute);
+}
+
+/***********************************************************************
+ * This routine creates the sysfs files managed by this device
+ * driver.
+ */
+static int aiptek_add_files(struct device *dev)
+{
+	int ret;
+
+	if ((ret = device_create_file(dev, &dev_attr_size)) ||
+	    (ret = device_create_file(dev, &dev_attr_product_id)) ||
+	    (ret = device_create_file(dev, &dev_attr_vendor_id)) ||
+	    (ret = device_create_file(dev, &dev_attr_vendor)) ||
+	    (ret = device_create_file(dev, &dev_attr_product)) ||
+	    (ret = device_create_file(dev, &dev_attr_pointer_mode)) ||
+	    (ret = device_create_file(dev, &dev_attr_coordinate_mode)) ||
+	    (ret = device_create_file(dev, &dev_attr_tool_mode)) ||
+	    (ret = device_create_file(dev, &dev_attr_xtilt)) ||
+	    (ret = device_create_file(dev, &dev_attr_ytilt)) ||
+	    (ret = device_create_file(dev, &dev_attr_jitter)) ||
+	    (ret = device_create_file(dev, &dev_attr_delay)) ||
+	    (ret = device_create_file(dev, &dev_attr_input_path)) ||
+	    (ret = device_create_file(dev, &dev_attr_event_count)) ||
+	    (ret = device_create_file(dev, &dev_attr_diagnostic)) ||
+	    (ret = device_create_file(dev, &dev_attr_odm_code)) ||
+	    (ret = device_create_file(dev, &dev_attr_model_code)) ||
+	    (ret = device_create_file(dev, &dev_attr_firmware_code)) ||
+	    (ret = device_create_file(dev, &dev_attr_stylus_lower)) ||
+	    (ret = device_create_file(dev, &dev_attr_stylus_upper)) ||
+	    (ret = device_create_file(dev, &dev_attr_mouse_left)) ||
+	    (ret = device_create_file(dev, &dev_attr_mouse_middle)) ||
+	    (ret = device_create_file(dev, &dev_attr_mouse_right)) ||
+	    (ret = device_create_file(dev, &dev_attr_wheel)) ||
+	    (ret = device_create_file(dev, &dev_attr_execute))) {
+		err("aiptek: killing own sysfs device files\n");
+		aiptek_delete_files(dev);
+	}
+	return ret;
+}
+
+/***********************************************************************
+ * This routine is called when a tablet has been identified. It basically
+ * sets up the tablet and the driver's internal structures.
+ */
+static int
+aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
+{
+	struct usb_device *usbdev = interface_to_usbdev(intf);
+	struct usb_endpoint_descriptor *endpoint;
+	struct aiptek *aiptek;
+	struct input_dev *inputdev;
+	struct input_handle *inputhandle;
+	struct list_head *node, *next;
+	int i;
+	int speeds[] = { 0,
+		AIPTEK_PROGRAMMABLE_DELAY_50,
+		AIPTEK_PROGRAMMABLE_DELAY_400,
+		AIPTEK_PROGRAMMABLE_DELAY_25,
+		AIPTEK_PROGRAMMABLE_DELAY_100,
+		AIPTEK_PROGRAMMABLE_DELAY_200,
+		AIPTEK_PROGRAMMABLE_DELAY_300
+	};
+	int err = -ENOMEM;
+
+	/* programmableDelay is where the command-line specified
+	 * delay is kept. We make it the first element of speeds[],
+	 * so therefore, your override speed is tried first, then the
+	 * remainder. Note that the default value of 400ms will be tried
+	 * if you do not specify any command line parameter.
+	 */
+	speeds[0] = programmableDelay;
+
+	aiptek = kzalloc(sizeof(struct aiptek), GFP_KERNEL);
+	inputdev = input_allocate_device();
+	if (!aiptek || !inputdev)
+		goto fail1;
+
+	aiptek->data = usb_buffer_alloc(usbdev, AIPTEK_PACKET_LENGTH,
+					GFP_ATOMIC, &aiptek->data_dma);
+	if (!aiptek->data)
+		goto fail1;
+
+	aiptek->urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!aiptek->urb)
+		goto fail2;
+
+	aiptek->inputdev = inputdev;
+	aiptek->usbdev = usbdev;
+	aiptek->ifnum = intf->altsetting[0].desc.bInterfaceNumber;
+	aiptek->inDelay = 0;
+	aiptek->endDelay = 0;
+	aiptek->previousJitterable = 0;
+
+	/* Set up the curSettings struct. Said struct contains the current
+	 * programmable parameters. The newSetting struct contains changes
+	 * the user makes to the settings via the sysfs interface. Those
+	 * changes are not "committed" to curSettings until the user
+	 * writes to the sysfs/.../execute file.
+	 */
+	aiptek->curSetting.pointerMode = AIPTEK_POINTER_EITHER_MODE;
+	aiptek->curSetting.coordinateMode = AIPTEK_COORDINATE_ABSOLUTE_MODE;
+	aiptek->curSetting.toolMode = AIPTEK_TOOL_BUTTON_PEN_MODE;
+	aiptek->curSetting.xTilt = AIPTEK_TILT_DISABLE;
+	aiptek->curSetting.yTilt = AIPTEK_TILT_DISABLE;
+	aiptek->curSetting.mouseButtonLeft = AIPTEK_MOUSE_LEFT_BUTTON;
+	aiptek->curSetting.mouseButtonMiddle = AIPTEK_MOUSE_MIDDLE_BUTTON;
+	aiptek->curSetting.mouseButtonRight = AIPTEK_MOUSE_RIGHT_BUTTON;
+	aiptek->curSetting.stylusButtonUpper = AIPTEK_STYLUS_UPPER_BUTTON;
+	aiptek->curSetting.stylusButtonLower = AIPTEK_STYLUS_LOWER_BUTTON;
+	aiptek->curSetting.jitterDelay = jitterDelay;
+	aiptek->curSetting.programmableDelay = programmableDelay;
+
+	/* Both structs should have equivalent settings
+	 */
+	aiptek->newSetting = aiptek->curSetting;
+
+	/* Determine the usb devices' physical path.
+	 * Asketh not why we always pretend we're using "../input0",
+	 * but I suspect this will have to be refactored one
+	 * day if a single USB device can be a keyboard & a mouse
+	 * & a tablet, and the inputX number actually will tell
+	 * us something...
+	 */
+	usb_make_path(usbdev, aiptek->features.usbPath,
+			sizeof(aiptek->features.usbPath));
+	strlcat(aiptek->features.usbPath, "/input0",
+		sizeof(aiptek->features.usbPath));
+
+	/* Set up client data, pointers to open and close routines
+	 * for the input device.
+	 */
+	inputdev->name = "Aiptek";
+	inputdev->phys = aiptek->features.usbPath;
+	usb_to_input_id(usbdev, &inputdev->id);
+	inputdev->dev.parent = &intf->dev;
+
+	input_set_drvdata(inputdev, aiptek);
+
+	inputdev->open = aiptek_open;
+	inputdev->close = aiptek_close;
+
+	/* Now program the capacities of the tablet, in terms of being
+	 * an input device.
+	 */
+	inputdev->evbit[0] |= BIT(EV_KEY)
+	    | BIT(EV_ABS)
+	    | BIT(EV_REL)
+	    | BIT(EV_MSC);
+
+	inputdev->absbit[0] |= BIT(ABS_MISC);
+
+	inputdev->relbit[0] |=
+	    (BIT(REL_X) | BIT(REL_Y) | BIT(REL_WHEEL) | BIT(REL_MISC));
+
+	inputdev->keybit[LONG(BTN_LEFT)] |=
+	    (BIT(BTN_LEFT) | BIT(BTN_RIGHT) | BIT(BTN_MIDDLE));
+
+	inputdev->keybit[LONG(BTN_DIGI)] |=
+	    (BIT(BTN_TOOL_PEN) |
+	     BIT(BTN_TOOL_RUBBER) |
+	     BIT(BTN_TOOL_PENCIL) |
+	     BIT(BTN_TOOL_AIRBRUSH) |
+	     BIT(BTN_TOOL_BRUSH) |
+	     BIT(BTN_TOOL_MOUSE) |
+	     BIT(BTN_TOOL_LENS) |
+	     BIT(BTN_TOUCH) | BIT(BTN_STYLUS) | BIT(BTN_STYLUS2));
+
+	inputdev->mscbit[0] = BIT(MSC_SERIAL);
+
+	/* Programming the tablet macro keys needs to be done with a for loop
+	 * as the keycodes are discontiguous.
+	 */
+	for (i = 0; i < ARRAY_SIZE(macroKeyEvents); ++i)
+		set_bit(macroKeyEvents[i], inputdev->keybit);
+
+	/*
+	 * Program the input device coordinate capacities. We do not yet
+	 * know what maximum X, Y, and Z values are, so we're putting fake
+	 * values in. Later, we'll ask the tablet to put in the correct
+	 * values.
+	 */
+	input_set_abs_params(inputdev, ABS_X, 0, 2999, 0, 0);
+	input_set_abs_params(inputdev, ABS_Y, 0, 2249, 0, 0);
+	input_set_abs_params(inputdev, ABS_PRESSURE, 0, 511, 0, 0);
+	input_set_abs_params(inputdev, ABS_TILT_X, AIPTEK_TILT_MIN, AIPTEK_TILT_MAX, 0, 0);
+	input_set_abs_params(inputdev, ABS_TILT_Y, AIPTEK_TILT_MIN, AIPTEK_TILT_MAX, 0, 0);
+	input_set_abs_params(inputdev, ABS_WHEEL, AIPTEK_WHEEL_MIN, AIPTEK_WHEEL_MAX - 1, 0, 0);
+
+	endpoint = &intf->altsetting[0].endpoint[0].desc;
+
+	/* Go set up our URB, which is called when the tablet receives
+	 * input.
+	 */
+	usb_fill_int_urb(aiptek->urb,
+			 aiptek->usbdev,
+			 usb_rcvintpipe(aiptek->usbdev,
+					endpoint->bEndpointAddress),
+			 aiptek->data, 8, aiptek_irq, aiptek,
+			 endpoint->bInterval);
+
+	aiptek->urb->transfer_dma = aiptek->data_dma;
+	aiptek->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+
+	/* Program the tablet. This sets the tablet up in the mode
+	 * specified in newSetting, and also queries the tablet's
+	 * physical capacities.
+	 *
+	 * Sanity check: if a tablet doesn't like the slow programmatic
+	 * delay, we often get sizes of 0x0. Let's use that as an indicator
+	 * to try faster delays, up to 25 ms. If that logic fails, well, you'll
+	 * have to explain to us how your tablet thinks it's 0x0, and yet that's
+	 * not an error :-)
+	 */
+
+	for (i = 0; i < ARRAY_SIZE(speeds); ++i) {
+		aiptek->curSetting.programmableDelay = speeds[i];
+		(void)aiptek_program_tablet(aiptek);
+		if (aiptek->inputdev->absmax[ABS_X] > 0) {
+			info("input: Aiptek using %d ms programming speed\n",
+			     aiptek->curSetting.programmableDelay);
+			break;
+		}
+	}
+
+	/* Register the tablet as an Input Device
+	 */
+	err = input_register_device(aiptek->inputdev);
+	if (err)
+		goto fail2;
+
+	/* We now will look for the evdev device which is mapped to
+	 * the tablet. The partial name is kept in the link list of
+	 * input_handles associated with this input device.
+	 * What identifies an evdev input_handler is that it begins
+	 * with 'event', continues with a digit, and that in turn
+	 * is mapped to input/eventN.
+	 */
+	list_for_each_safe(node, next, &inputdev->h_list) {
+		inputhandle = to_handle(node);
+		if (strncmp(inputhandle->name, "event", 5) == 0) {
+			strcpy(aiptek->features.inputPath, inputhandle->name);
+			break;
+		}
+	}
+
+	/* Associate this driver's struct with the usb interface.
+	 */
+	usb_set_intfdata(intf, aiptek);
+
+	/* Set up the sysfs files
+	 */
+	aiptek_add_files(&intf->dev);
+
+	/* Make sure the evdev module is loaded. Assuming evdev IS a module :-)
+	 */
+	if (request_module("evdev") != 0)
+		info("aiptek: error loading 'evdev' module");
+
+	return 0;
+
+ fail2:	usb_buffer_free(usbdev, AIPTEK_PACKET_LENGTH, aiptek->data,
+			aiptek->data_dma);
+ fail1:	input_free_device(inputdev);
+	kfree(aiptek);
+	return err;
+}
+
+/***********************************************************************
+ * Deal with tablet disconnecting from the system.
+ */
+static void aiptek_disconnect(struct usb_interface *intf)
+{
+	struct aiptek *aiptek = usb_get_intfdata(intf);
+
+	/* Disassociate driver's struct with usb interface
+	 */
+	usb_set_intfdata(intf, NULL);
+	if (aiptek != NULL) {
+		/* Free & unhook everything from the system.
+		 */
+		usb_kill_urb(aiptek->urb);
+		input_unregister_device(aiptek->inputdev);
+		aiptek_delete_files(&intf->dev);
+		usb_free_urb(aiptek->urb);
+		usb_buffer_free(interface_to_usbdev(intf),
+				AIPTEK_PACKET_LENGTH,
+				aiptek->data, aiptek->data_dma);
+		kfree(aiptek);
+	}
+}
+
+static struct usb_driver aiptek_driver = {
+	.name = "aiptek",
+	.probe = aiptek_probe,
+	.disconnect = aiptek_disconnect,
+	.id_table = aiptek_ids,
+};
+
+static int __init aiptek_init(void)
+{
+	int result = usb_register(&aiptek_driver);
+	if (result == 0) {
+		info(DRIVER_VERSION ": " DRIVER_AUTHOR);
+		info(DRIVER_DESC);
+	}
+	return result;
+}
+
+static void __exit aiptek_exit(void)
+{
+	usb_deregister(&aiptek_driver);
+}
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
+
+module_param(programmableDelay, int, 0);
+MODULE_PARM_DESC(programmableDelay, "delay used during tablet programming");
+module_param(jitterDelay, int, 0);
+MODULE_PARM_DESC(jitterDelay, "stylus/mouse settlement delay");
+
+module_init(aiptek_init);
+module_exit(aiptek_exit);
