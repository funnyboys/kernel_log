commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/input/tablet/hanwang.c b/drivers/input/tablet/hanwang.c
index 4042c41160f4..6d58443bb3e9 100644
--- a/drivers/input/tablet/hanwang.c
+++ b/drivers/input/tablet/hanwang.c
@@ -1,25 +1,11 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  USB Hanwang tablet support
  *
  *  Copyright (c) 2010 Xing Wei <weixing@hanwang.com.cn>
- *
  */
 
 /*
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
  */
 
 #include <linux/types.h>

commit 698c03b4745006e14eccb8270f714d52fac1c97e
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Tue Jan 16 16:56:54 2018 -0800

    Input: inline macros for MODULE_LICENSE, etc
    
    Inline macro for MODULE_LICENSE to make the license information easy to
    find, eg with grep.  Inline the other module-related macros at the same
    time.
    
    A simplified version of the semantic patch for the MODULE_LICENSE
    case is as follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @s@
    identifier i; expression e;
    @@
    
    @@
    declarer name MODULE_LICENSE;
    identifier s.i;
    expression s.e;
    @@
    MODULE_LICENSE(
    - i
    + e
     );
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    [dtor: added a couple of drivers missed by the script, removed a few unused
     DRIVER_VERSION macros]
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/tablet/hanwang.c b/drivers/input/tablet/hanwang.c
index 70cb26bbfe1d..4042c41160f4 100644
--- a/drivers/input/tablet/hanwang.c
+++ b/drivers/input/tablet/hanwang.c
@@ -28,11 +28,8 @@
 #include <linux/module.h>
 #include <linux/usb/input.h>
 
-#define DRIVER_AUTHOR   "Xing Wei <weixing@hanwang.com.cn>"
-#define DRIVER_DESC     "USB Hanwang tablet driver"
-
-MODULE_AUTHOR(DRIVER_AUTHOR);
-MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR("Xing Wei <weixing@hanwang.com.cn>");
+MODULE_DESCRIPTION("USB Hanwang tablet driver");
 MODULE_LICENSE("GPL");
 
 #define USB_VENDOR_ID_HANWANG		0x0b57

commit 9f1d1ea3e06aa4f0b88d724cee890973f8f8727b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Jan 16 16:36:48 2018 -0800

    Input: remove unneeded DRIVER_LICENSE #defines
    
    There is no need to #define the license of the driver, just put it in
    the MODULE_LICENSE() line directly as a text string.
    
    This allows tools that check that the module license matches the source
    code license to work properly, as there is no need to unwind the
    unneeded dereference.  For some of these drivers, the #define is just a
    few lines above the MODULE_LICENSE() line, which is extra pointless.
    
    Reported-by: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/tablet/hanwang.c b/drivers/input/tablet/hanwang.c
index df4bea96d7ed..70cb26bbfe1d 100644
--- a/drivers/input/tablet/hanwang.c
+++ b/drivers/input/tablet/hanwang.c
@@ -30,11 +30,10 @@
 
 #define DRIVER_AUTHOR   "Xing Wei <weixing@hanwang.com.cn>"
 #define DRIVER_DESC     "USB Hanwang tablet driver"
-#define DRIVER_LICENSE  "GPL"
 
 MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);
-MODULE_LICENSE(DRIVER_LICENSE);
+MODULE_LICENSE("GPL");
 
 #define USB_VENDOR_ID_HANWANG		0x0b57
 #define HANWANG_TABLET_INT_CLASS	0x0003

commit ba340d7b83703768ce566f53f857543359aa1b98
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Mar 16 11:39:29 2017 -0700

    Input: hanwang - validate number of endpoints before using them
    
    Make sure to check the number of endpoints to avoid dereferencing a
    NULL-pointer should a malicious device lack endpoints.
    
    Fixes: bba5394ad3bd ("Input: add support for Hanwang tablets")
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Cc: stable@vger.kernel.org      # 2.6.37
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/tablet/hanwang.c b/drivers/input/tablet/hanwang.c
index cd852059b99e..df4bea96d7ed 100644
--- a/drivers/input/tablet/hanwang.c
+++ b/drivers/input/tablet/hanwang.c
@@ -340,6 +340,9 @@ static int hanwang_probe(struct usb_interface *intf, const struct usb_device_id
 	int error;
 	int i;
 
+	if (intf->cur_altsetting->desc.bNumEndpoints < 1)
+		return -ENODEV;
+
 	hanwang = kzalloc(sizeof(struct hanwang), GFP_KERNEL);
 	input_dev = input_allocate_device();
 	if (!hanwang || !input_dev) {

commit bf9a9f8e5105b13cea954b254008f383ed0b4045
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jan 6 10:27:05 2014 -0800

    Input: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/tablet/hanwang.c b/drivers/input/tablet/hanwang.c
index 5cc04124995c..cd852059b99e 100644
--- a/drivers/input/tablet/hanwang.c
+++ b/drivers/input/tablet/hanwang.c
@@ -26,7 +26,6 @@
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/module.h>
-#include <linux/init.h>
 #include <linux/usb/input.h>
 
 #define DRIVER_AUTHOR   "Xing Wei <weixing@hanwang.com.cn>"

commit 8a90c034ae0d4282e2aeb9cf8311dc90c855d815
Author: weixing <weixing@hanwang.com.cn>
Date:   Fri Jul 13 00:08:42 2012 -0700

    Input: hanwang - add support for Art Master II tablet
    
    This change adds support for old Hanwang Art master II tablet
    
    Signed-off-by: weixing <weixing@hanwang.com.cn>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/tablet/hanwang.c b/drivers/input/tablet/hanwang.c
index b2db3cfe3084..5cc04124995c 100644
--- a/drivers/input/tablet/hanwang.c
+++ b/drivers/input/tablet/hanwang.c
@@ -63,6 +63,7 @@ MODULE_LICENSE(DRIVER_LICENSE);
 enum hanwang_tablet_type {
 	HANWANG_ART_MASTER_III,
 	HANWANG_ART_MASTER_HD,
+	HANWANG_ART_MASTER_II,
 };
 
 struct hanwang {
@@ -99,6 +100,8 @@ static const struct hanwang_features features_array[] = {
 	  ART_MASTER_PKGLEN_MAX, 0x7f00, 0x4f60, 0x3f, 0x7f, 2048 },
 	{ 0x8401, "Hanwang Art Master HD 5012", HANWANG_ART_MASTER_HD,
 	  ART_MASTER_PKGLEN_MAX, 0x678e, 0x4150, 0x3f, 0x7f, 1024 },
+	{ 0x8503, "Hanwang Art Master II", HANWANG_ART_MASTER_II,
+	  ART_MASTER_PKGLEN_MAX, 0x27de, 0x1cfe, 0x3f, 0x7f, 1024 },
 };
 
 static const int hw_eventtypes[] = {
@@ -127,14 +130,30 @@ static void hanwang_parse_packet(struct hanwang *hanwang)
 	struct usb_device *dev = hanwang->usbdev;
 	enum hanwang_tablet_type type = hanwang->features->type;
 	int i;
-	u16 x, y, p;
+	u16 p;
+
+	if (type == HANWANG_ART_MASTER_II) {
+		hanwang->current_tool = BTN_TOOL_PEN;
+		hanwang->current_id = STYLUS_DEVICE_ID;
+	}
 
 	switch (data[0]) {
 	case 0x02:	/* data packet */
 		switch (data[1]) {
 		case 0x80:	/* tool prox out */
-			hanwang->current_id = 0;
-			input_report_key(input_dev, hanwang->current_tool, 0);
+			if (type != HANWANG_ART_MASTER_II) {
+				hanwang->current_id = 0;
+				input_report_key(input_dev,
+						 hanwang->current_tool, 0);
+			}
+			break;
+
+		case 0x00:	/* artmaster ii pen leave */
+			if (type == HANWANG_ART_MASTER_II) {
+				hanwang->current_id = 0;
+				input_report_key(input_dev,
+						 hanwang->current_tool, 0);
+			}
 			break;
 
 		case 0xc2:	/* first time tool prox in */
@@ -154,15 +173,12 @@ static void hanwang_parse_packet(struct hanwang *hanwang)
 			default:
 				hanwang->current_id = 0;
 				dev_dbg(&dev->dev,
-					"unknown tablet tool %02x ", data[0]);
+					"unknown tablet tool %02x\n", data[0]);
 				break;
 			}
 			break;
 
 		default:	/* tool data packet */
-			x = (data[2] << 8) | data[3];
-			y = (data[4] << 8) | data[5];
-
 			switch (type) {
 			case HANWANG_ART_MASTER_III:
 				p = (data[6] << 3) |
@@ -171,6 +187,7 @@ static void hanwang_parse_packet(struct hanwang *hanwang)
 				break;
 
 			case HANWANG_ART_MASTER_HD:
+			case HANWANG_ART_MASTER_II:
 				p = (data[7] >> 6) | (data[6] << 2);
 				break;
 
@@ -180,17 +197,23 @@ static void hanwang_parse_packet(struct hanwang *hanwang)
 			}
 
 			input_report_abs(input_dev, ABS_X,
-						le16_to_cpup((__le16 *)&x));
+					 be16_to_cpup((__be16 *)&data[2]));
 			input_report_abs(input_dev, ABS_Y,
-						le16_to_cpup((__le16 *)&y));
-			input_report_abs(input_dev, ABS_PRESSURE,
-						le16_to_cpup((__le16 *)&p));
+					 be16_to_cpup((__be16 *)&data[4]));
+			input_report_abs(input_dev, ABS_PRESSURE, p);
 			input_report_abs(input_dev, ABS_TILT_X, data[7] & 0x3f);
 			input_report_abs(input_dev, ABS_TILT_Y, data[8] & 0x7f);
 			input_report_key(input_dev, BTN_STYLUS, data[1] & 0x02);
-			input_report_key(input_dev, BTN_STYLUS2, data[1] & 0x04);
+
+			if (type != HANWANG_ART_MASTER_II)
+				input_report_key(input_dev, BTN_STYLUS2,
+						 data[1] & 0x04);
+			else
+				input_report_key(input_dev, BTN_TOOL_PEN, 1);
+
 			break;
 		}
+
 		input_report_abs(input_dev, ABS_MISC, hanwang->current_id);
 		input_event(input_dev, EV_MSC, MSC_SERIAL,
 				hanwang->features->pid);
@@ -202,8 +225,8 @@ static void hanwang_parse_packet(struct hanwang *hanwang)
 
 		switch (type) {
 		case HANWANG_ART_MASTER_III:
-			input_report_key(input_dev, BTN_TOOL_FINGER, data[1] ||
-							data[2] || data[3]);
+			input_report_key(input_dev, BTN_TOOL_FINGER,
+					 data[1] || data[2] || data[3]);
 			input_report_abs(input_dev, ABS_WHEEL, data[1]);
 			input_report_key(input_dev, BTN_0, data[2]);
 			for (i = 0; i < 8; i++)
@@ -227,6 +250,10 @@ static void hanwang_parse_packet(struct hanwang *hanwang)
 					 BTN_5 + i, data[6] & (1 << i));
 			}
 			break;
+
+		case HANWANG_ART_MASTER_II:
+			dev_dbg(&dev->dev, "error packet  %02x\n", data[0]);
+			return;
 		}
 
 		input_report_abs(input_dev, ABS_MISC, hanwang->current_id);
@@ -234,7 +261,7 @@ static void hanwang_parse_packet(struct hanwang *hanwang)
 		break;
 
 	default:
-		dev_dbg(&dev->dev, "error packet  %02x ", data[0]);
+		dev_dbg(&dev->dev, "error packet  %02x\n", data[0]);
 		break;
 	}
 

commit 08642e7c52cf43616821520828e504bc717e54a6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Nov 18 09:48:31 2011 -0800

    USB: convert drivers/input/* to use module_usb_driver()
    
    This converts the drivers in drivers/input/* to use the
    module_usb_driver() macro which makes the code smaller and a bit
    simpler.
    
    Added bonus is that it removes some unneeded kernel log messages about
    drivers loading and/or unloading.
    
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Ville Syrjala <syrjala@sci.fi>
    Cc: Henk Vergonet <Henk.Vergonet@gmail.com>
    Cc: Alessandro Rubini <rubini@ipvvis.unipv.it>
    Cc: Henrik Rydberg <rydberg@euromail.se>
    Cc: "Magnus Hörlin" <magnus@alefors.se>
    Cc: Chris Moeller <kode54@gmail.c>
    Cc: Christoph Fritz <chf.fritz@googlemail.com>
    Cc: Lucas De Marchi <lucas.demarchi@profusion.mobi>
    Cc: Jesper Juhl <jj@chaosbits.net>
    Cc: Edwin van Vliet <edwin@cheatah.nl>
    Cc: Ping Cheng <pingc@wacom.com>
    Cc: Eduard Hasenleithner <eduard@hasenleithner.at>
    Cc: Alexander Strakh <strakh@ispras.ru>
    Cc: Glenn Sommer <gsommer@datanordisk.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/input/tablet/hanwang.c b/drivers/input/tablet/hanwang.c
index 6504b627b234..b2db3cfe3084 100644
--- a/drivers/input/tablet/hanwang.c
+++ b/drivers/input/tablet/hanwang.c
@@ -432,15 +432,4 @@ static struct usb_driver hanwang_driver = {
 	.id_table	= hanwang_ids,
 };
 
-static int __init hanwang_init(void)
-{
-	return usb_register(&hanwang_driver);
-}
-
-static void __exit hanwang_exit(void)
-{
-	usb_deregister(&hanwang_driver);
-}
-
-module_init(hanwang_init);
-module_exit(hanwang_exit);
+module_usb_driver(hanwang_driver);

commit 727eeb7dbeac8a7ecd2ad943eb27a5566ab83601
Author: Xing Wei <weixing@hanwang.com.cn>
Date:   Wed Sep 29 18:25:20 2010 -0700

    Input: hanwang - add support for Art Master HD 5012 tablet
    
    This adds support for hanwang Art Master HD 5012 electromagnetic tablet.
    
    Signed-off-by: Xing Wei <weixing@hanwang.com.cn>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/hanwang.c b/drivers/input/tablet/hanwang.c
index 0701d948cdf3..6504b627b234 100644
--- a/drivers/input/tablet/hanwang.c
+++ b/drivers/input/tablet/hanwang.c
@@ -42,7 +42,7 @@ MODULE_LICENSE(DRIVER_LICENSE);
 #define HANWANG_TABLET_INT_SUB_CLASS	0x0001
 #define HANWANG_TABLET_INT_PROTOCOL	0x0002
 
-#define ART_MASTERIII_PKGLEN_MAX	10
+#define ART_MASTER_PKGLEN_MAX	10
 
 /* device IDs */
 #define STYLUS_DEVICE_ID	0x02
@@ -60,6 +60,11 @@ MODULE_LICENSE(DRIVER_LICENSE);
 	.bInterfaceSubClass = (sc), \
 	.bInterfaceProtocol = (pr)
 
+enum hanwang_tablet_type {
+	HANWANG_ART_MASTER_III,
+	HANWANG_ART_MASTER_HD,
+};
+
 struct hanwang {
 	unsigned char *data;
 	dma_addr_t data_dma;
@@ -76,6 +81,7 @@ struct hanwang {
 struct hanwang_features {
 	unsigned short pid;
 	char *name;
+	enum hanwang_tablet_type type;
 	int pkg_len;
 	int max_x;
 	int max_y;
@@ -85,12 +91,14 @@ struct hanwang_features {
 };
 
 static const struct hanwang_features features_array[] = {
-	{ 0x8528, "Hanwang Art Master III 0906",
-	  ART_MASTERIII_PKGLEN_MAX, 0x5757, 0x3692, 0x3f, 0x7f, 2048 },
-	{ 0x8529, "Hanwang Art Master III 0604",
-	  ART_MASTERIII_PKGLEN_MAX, 0x3d84, 0x2672, 0x3f, 0x7f, 2048 },
-	{ 0x852a, "Hanwang Art Master III 1308",
-	  ART_MASTERIII_PKGLEN_MAX, 0x7f00, 0x4f60, 0x3f, 0x7f, 2048 },
+	{ 0x8528, "Hanwang Art Master III 0906", HANWANG_ART_MASTER_III,
+	  ART_MASTER_PKGLEN_MAX, 0x5757, 0x3692, 0x3f, 0x7f, 2048 },
+	{ 0x8529, "Hanwang Art Master III 0604", HANWANG_ART_MASTER_III,
+	  ART_MASTER_PKGLEN_MAX, 0x3d84, 0x2672, 0x3f, 0x7f, 2048 },
+	{ 0x852a, "Hanwang Art Master III 1308", HANWANG_ART_MASTER_III,
+	  ART_MASTER_PKGLEN_MAX, 0x7f00, 0x4f60, 0x3f, 0x7f, 2048 },
+	{ 0x8401, "Hanwang Art Master HD 5012", HANWANG_ART_MASTER_HD,
+	  ART_MASTER_PKGLEN_MAX, 0x678e, 0x4150, 0x3f, 0x7f, 1024 },
 };
 
 static const int hw_eventtypes[] = {
@@ -99,7 +107,7 @@ static const int hw_eventtypes[] = {
 
 static const int hw_absevents[] = {
 	ABS_X, ABS_Y, ABS_TILT_X, ABS_TILT_Y, ABS_WHEEL,
-	ABS_PRESSURE, ABS_MISC,
+	ABS_RX, ABS_RY, ABS_PRESSURE, ABS_MISC,
 };
 
 static const int hw_btnevents[] = {
@@ -117,7 +125,9 @@ static void hanwang_parse_packet(struct hanwang *hanwang)
 	unsigned char *data = hanwang->data;
 	struct input_dev *input_dev = hanwang->dev;
 	struct usb_device *dev = hanwang->usbdev;
+	enum hanwang_tablet_type type = hanwang->features->type;
 	int i;
+	u16 x, y, p;
 
 	switch (data[0]) {
 	case 0x02:	/* data packet */
@@ -129,12 +139,14 @@ static void hanwang_parse_packet(struct hanwang *hanwang)
 
 		case 0xc2:	/* first time tool prox in */
 			switch (data[3] & 0xf0) {
-			case 0x20:
+			case 0x20:	/* art_master III */
+			case 0x30:	/* art_master_HD */
 				hanwang->current_id = STYLUS_DEVICE_ID;
 				hanwang->current_tool = BTN_TOOL_PEN;
 				input_report_key(input_dev, BTN_TOOL_PEN, 1);
 				break;
-			case 0xa0:
+			case 0xa0:	/* art_master III */
+			case 0xb0:	/* art_master_HD */
 				hanwang->current_id = ERASER_DEVICE_ID;
 				hanwang->current_tool = BTN_TOOL_RUBBER;
 				input_report_key(input_dev, BTN_TOOL_RUBBER, 1);
@@ -148,14 +160,31 @@ static void hanwang_parse_packet(struct hanwang *hanwang)
 			break;
 
 		default:	/* tool data packet */
+			x = (data[2] << 8) | data[3];
+			y = (data[4] << 8) | data[5];
+
+			switch (type) {
+			case HANWANG_ART_MASTER_III:
+				p = (data[6] << 3) |
+				    ((data[7] & 0xc0) >> 5) |
+				    (data[1] & 0x01);
+				break;
+
+			case HANWANG_ART_MASTER_HD:
+				p = (data[7] >> 6) | (data[6] << 2);
+				break;
+
+			default:
+				p = 0;
+				break;
+			}
+
 			input_report_abs(input_dev, ABS_X,
-					 (data[2] << 8) | data[3]);
+						le16_to_cpup((__le16 *)&x));
 			input_report_abs(input_dev, ABS_Y,
-					 (data[4] << 8) | data[5]);
+						le16_to_cpup((__le16 *)&y));
 			input_report_abs(input_dev, ABS_PRESSURE,
-					 (data[6] << 3) |
-					 ((data[7] & 0xc0) >> 5) |
-					 (data[1] & 0x01));
+						le16_to_cpup((__le16 *)&p));
 			input_report_abs(input_dev, ABS_TILT_X, data[7] & 0x3f);
 			input_report_abs(input_dev, ABS_TILT_Y, data[8] & 0x7f);
 			input_report_key(input_dev, BTN_STYLUS, data[1] & 0x02);
@@ -170,13 +199,36 @@ static void hanwang_parse_packet(struct hanwang *hanwang)
 	case 0x0c:
 		/* roll wheel */
 		hanwang->current_id = PAD_DEVICE_ID;
-		input_report_key(input_dev, BTN_TOOL_FINGER, data[1] ||
-						data[2] || data[3]);
-		input_report_abs(input_dev, ABS_WHEEL, data[1]);
-		input_report_key(input_dev, BTN_0, data[2]);
-		for (i = 0; i < 8; i++)
-			input_report_key(input_dev,
+
+		switch (type) {
+		case HANWANG_ART_MASTER_III:
+			input_report_key(input_dev, BTN_TOOL_FINGER, data[1] ||
+							data[2] || data[3]);
+			input_report_abs(input_dev, ABS_WHEEL, data[1]);
+			input_report_key(input_dev, BTN_0, data[2]);
+			for (i = 0; i < 8; i++)
+				input_report_key(input_dev,
 					 BTN_1 + i, data[3] & (1 << i));
+			break;
+
+		case HANWANG_ART_MASTER_HD:
+			input_report_key(input_dev, BTN_TOOL_FINGER, data[1] ||
+					data[2] || data[3] || data[4] ||
+					data[5] || data[6]);
+			input_report_abs(input_dev, ABS_RX,
+					((data[1] & 0x1f) << 8) | data[2]);
+			input_report_abs(input_dev, ABS_RY,
+					((data[3] & 0x1f) << 8) | data[4]);
+			input_report_key(input_dev, BTN_0, data[5] & 0x01);
+			for (i = 0; i < 4; i++) {
+				input_report_key(input_dev,
+					 BTN_1 + i, data[5] & (1 << i));
+				input_report_key(input_dev,
+					 BTN_5 + i, data[6] & (1 << i));
+			}
+			break;
+		}
+
 		input_report_abs(input_dev, ABS_MISC, hanwang->current_id);
 		input_event(input_dev, EV_MSC, MSC_SERIAL, 0xffffffff);
 		break;

commit 24dd3b58228d463254ee57c3811afea831b8a024
Author: Xing Wei <weixing@hanwang.com.cn>
Date:   Sun Sep 12 00:24:17 2010 -0700

    Input: hanwang - make compatible with xf86-input-wacom driver
    
    Add necessary events so that Hanwang Art Master III tablet can be handled
    by the stock xf86-input-wacom driver.
    
    Signed-off-by: Xing Wei <weixing@hanwang.com.cn>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/hanwang.c b/drivers/input/tablet/hanwang.c
index 3554e30ab41b..0701d948cdf3 100644
--- a/drivers/input/tablet/hanwang.c
+++ b/drivers/input/tablet/hanwang.c
@@ -44,6 +44,13 @@ MODULE_LICENSE(DRIVER_LICENSE);
 
 #define ART_MASTERIII_PKGLEN_MAX	10
 
+/* device IDs */
+#define STYLUS_DEVICE_ID	0x02
+#define TOUCH_DEVICE_ID		0x03
+#define CURSOR_DEVICE_ID	0x06
+#define ERASER_DEVICE_ID	0x0A
+#define PAD_DEVICE_ID		0x0F
+
 /* match vendor and interface info  */
 #define HANWANG_TABLET_DEVICE(vend, cl, sc, pr) \
 	.match_flags = USB_DEVICE_ID_MATCH_VENDOR \
@@ -61,6 +68,7 @@ struct hanwang {
 	struct urb *irq;
 	const struct hanwang_features *features;
 	unsigned int current_tool;
+	unsigned int current_id;
 	char name[64];
 	char phys[32];
 };
@@ -86,16 +94,22 @@ static const struct hanwang_features features_array[] = {
 };
 
 static const int hw_eventtypes[] = {
-	EV_KEY, EV_ABS,
+	EV_KEY, EV_ABS, EV_MSC,
 };
 
 static const int hw_absevents[] = {
-	ABS_X, ABS_Y, ABS_TILT_X, ABS_TILT_Y, ABS_WHEEL, ABS_PRESSURE,
+	ABS_X, ABS_Y, ABS_TILT_X, ABS_TILT_Y, ABS_WHEEL,
+	ABS_PRESSURE, ABS_MISC,
 };
 
 static const int hw_btnevents[] = {
-	BTN_STYLUS, BTN_STYLUS2, BTN_TOOL_PEN, BTN_TOOL_RUBBER, BTN_TOOL_MOUSE,
-	BTN_0, BTN_1, BTN_2, BTN_3, BTN_4, BTN_5, BTN_6, BTN_7, BTN_8
+	BTN_STYLUS, BTN_STYLUS2, BTN_TOOL_PEN, BTN_TOOL_RUBBER,
+	BTN_TOOL_MOUSE, BTN_TOOL_FINGER,
+	BTN_0, BTN_1, BTN_2, BTN_3, BTN_4, BTN_5, BTN_6, BTN_7, BTN_8,
+};
+
+static const int hw_mscevents[] = {
+	MSC_SERIAL,
 };
 
 static void hanwang_parse_packet(struct hanwang *hanwang)
@@ -109,20 +123,24 @@ static void hanwang_parse_packet(struct hanwang *hanwang)
 	case 0x02:	/* data packet */
 		switch (data[1]) {
 		case 0x80:	/* tool prox out */
+			hanwang->current_id = 0;
 			input_report_key(input_dev, hanwang->current_tool, 0);
 			break;
 
 		case 0xc2:	/* first time tool prox in */
 			switch (data[3] & 0xf0) {
 			case 0x20:
+				hanwang->current_id = STYLUS_DEVICE_ID;
 				hanwang->current_tool = BTN_TOOL_PEN;
 				input_report_key(input_dev, BTN_TOOL_PEN, 1);
 				break;
 			case 0xa0:
+				hanwang->current_id = ERASER_DEVICE_ID;
 				hanwang->current_tool = BTN_TOOL_RUBBER;
 				input_report_key(input_dev, BTN_TOOL_RUBBER, 1);
 				break;
 			default:
+				hanwang->current_id = 0;
 				dev_dbg(&dev->dev,
 					"unknown tablet tool %02x ", data[0]);
 				break;
@@ -144,15 +162,23 @@ static void hanwang_parse_packet(struct hanwang *hanwang)
 			input_report_key(input_dev, BTN_STYLUS2, data[1] & 0x04);
 			break;
 		}
+		input_report_abs(input_dev, ABS_MISC, hanwang->current_id);
+		input_event(input_dev, EV_MSC, MSC_SERIAL,
+				hanwang->features->pid);
 		break;
 
 	case 0x0c:
 		/* roll wheel */
+		hanwang->current_id = PAD_DEVICE_ID;
+		input_report_key(input_dev, BTN_TOOL_FINGER, data[1] ||
+						data[2] || data[3]);
 		input_report_abs(input_dev, ABS_WHEEL, data[1]);
 		input_report_key(input_dev, BTN_0, data[2]);
 		for (i = 0; i < 8; i++)
 			input_report_key(input_dev,
 					 BTN_1 + i, data[3] & (1 << i));
+		input_report_abs(input_dev, ABS_MISC, hanwang->current_id);
+		input_event(input_dev, EV_MSC, MSC_SERIAL, 0xffffffff);
 		break;
 
 	default:
@@ -287,6 +313,9 @@ static int hanwang_probe(struct usb_interface *intf, const struct usb_device_id
 	for (i = 0; i < ARRAY_SIZE(hw_btnevents); ++i)
 		__set_bit(hw_btnevents[i], input_dev->keybit);
 
+	for (i = 0; i < ARRAY_SIZE(hw_mscevents); ++i)
+		__set_bit(hw_mscevents[i], input_dev->mscbit);
+
 	input_set_abs_params(input_dev, ABS_X,
 			     0, hanwang->features->max_x, 4, 0);
 	input_set_abs_params(input_dev, ABS_Y,

commit bba5394ad3bd23fff6987fc8bc3aaf9d12433c63
Author: Xing Wei <weixing@hanwang.com.cn>
Date:   Wed Sep 1 23:25:35 2010 -0700

    Input: add support for Hanwang tablets
    
    Add support for Art Master III tablet of BeiJing HanwangTechnology Co, Ltd.
    
    Signed-off-by: Xing Wei <weixing@hanwang.com.cn>
    Acked-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/tablet/hanwang.c b/drivers/input/tablet/hanwang.c
new file mode 100644
index 000000000000..3554e30ab41b
--- /dev/null
+++ b/drivers/input/tablet/hanwang.c
@@ -0,0 +1,365 @@
+/*
+ *  USB Hanwang tablet support
+ *
+ *  Copyright (c) 2010 Xing Wei <weixing@hanwang.com.cn>
+ *
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/usb/input.h>
+
+#define DRIVER_AUTHOR   "Xing Wei <weixing@hanwang.com.cn>"
+#define DRIVER_DESC     "USB Hanwang tablet driver"
+#define DRIVER_LICENSE  "GPL"
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE(DRIVER_LICENSE);
+
+#define USB_VENDOR_ID_HANWANG		0x0b57
+#define HANWANG_TABLET_INT_CLASS	0x0003
+#define HANWANG_TABLET_INT_SUB_CLASS	0x0001
+#define HANWANG_TABLET_INT_PROTOCOL	0x0002
+
+#define ART_MASTERIII_PKGLEN_MAX	10
+
+/* match vendor and interface info  */
+#define HANWANG_TABLET_DEVICE(vend, cl, sc, pr) \
+	.match_flags = USB_DEVICE_ID_MATCH_VENDOR \
+		| USB_DEVICE_ID_MATCH_INT_INFO, \
+	.idVendor = (vend), \
+	.bInterfaceClass = (cl), \
+	.bInterfaceSubClass = (sc), \
+	.bInterfaceProtocol = (pr)
+
+struct hanwang {
+	unsigned char *data;
+	dma_addr_t data_dma;
+	struct input_dev *dev;
+	struct usb_device *usbdev;
+	struct urb *irq;
+	const struct hanwang_features *features;
+	unsigned int current_tool;
+	char name[64];
+	char phys[32];
+};
+
+struct hanwang_features {
+	unsigned short pid;
+	char *name;
+	int pkg_len;
+	int max_x;
+	int max_y;
+	int max_tilt_x;
+	int max_tilt_y;
+	int max_pressure;
+};
+
+static const struct hanwang_features features_array[] = {
+	{ 0x8528, "Hanwang Art Master III 0906",
+	  ART_MASTERIII_PKGLEN_MAX, 0x5757, 0x3692, 0x3f, 0x7f, 2048 },
+	{ 0x8529, "Hanwang Art Master III 0604",
+	  ART_MASTERIII_PKGLEN_MAX, 0x3d84, 0x2672, 0x3f, 0x7f, 2048 },
+	{ 0x852a, "Hanwang Art Master III 1308",
+	  ART_MASTERIII_PKGLEN_MAX, 0x7f00, 0x4f60, 0x3f, 0x7f, 2048 },
+};
+
+static const int hw_eventtypes[] = {
+	EV_KEY, EV_ABS,
+};
+
+static const int hw_absevents[] = {
+	ABS_X, ABS_Y, ABS_TILT_X, ABS_TILT_Y, ABS_WHEEL, ABS_PRESSURE,
+};
+
+static const int hw_btnevents[] = {
+	BTN_STYLUS, BTN_STYLUS2, BTN_TOOL_PEN, BTN_TOOL_RUBBER, BTN_TOOL_MOUSE,
+	BTN_0, BTN_1, BTN_2, BTN_3, BTN_4, BTN_5, BTN_6, BTN_7, BTN_8
+};
+
+static void hanwang_parse_packet(struct hanwang *hanwang)
+{
+	unsigned char *data = hanwang->data;
+	struct input_dev *input_dev = hanwang->dev;
+	struct usb_device *dev = hanwang->usbdev;
+	int i;
+
+	switch (data[0]) {
+	case 0x02:	/* data packet */
+		switch (data[1]) {
+		case 0x80:	/* tool prox out */
+			input_report_key(input_dev, hanwang->current_tool, 0);
+			break;
+
+		case 0xc2:	/* first time tool prox in */
+			switch (data[3] & 0xf0) {
+			case 0x20:
+				hanwang->current_tool = BTN_TOOL_PEN;
+				input_report_key(input_dev, BTN_TOOL_PEN, 1);
+				break;
+			case 0xa0:
+				hanwang->current_tool = BTN_TOOL_RUBBER;
+				input_report_key(input_dev, BTN_TOOL_RUBBER, 1);
+				break;
+			default:
+				dev_dbg(&dev->dev,
+					"unknown tablet tool %02x ", data[0]);
+				break;
+			}
+			break;
+
+		default:	/* tool data packet */
+			input_report_abs(input_dev, ABS_X,
+					 (data[2] << 8) | data[3]);
+			input_report_abs(input_dev, ABS_Y,
+					 (data[4] << 8) | data[5]);
+			input_report_abs(input_dev, ABS_PRESSURE,
+					 (data[6] << 3) |
+					 ((data[7] & 0xc0) >> 5) |
+					 (data[1] & 0x01));
+			input_report_abs(input_dev, ABS_TILT_X, data[7] & 0x3f);
+			input_report_abs(input_dev, ABS_TILT_Y, data[8] & 0x7f);
+			input_report_key(input_dev, BTN_STYLUS, data[1] & 0x02);
+			input_report_key(input_dev, BTN_STYLUS2, data[1] & 0x04);
+			break;
+		}
+		break;
+
+	case 0x0c:
+		/* roll wheel */
+		input_report_abs(input_dev, ABS_WHEEL, data[1]);
+		input_report_key(input_dev, BTN_0, data[2]);
+		for (i = 0; i < 8; i++)
+			input_report_key(input_dev,
+					 BTN_1 + i, data[3] & (1 << i));
+		break;
+
+	default:
+		dev_dbg(&dev->dev, "error packet  %02x ", data[0]);
+		break;
+	}
+
+	input_sync(input_dev);
+}
+
+static void hanwang_irq(struct urb *urb)
+{
+	struct hanwang *hanwang = urb->context;
+	struct usb_device *dev = hanwang->usbdev;
+	int retval;
+
+	switch (urb->status) {
+	case 0:
+		/* success */;
+		hanwang_parse_packet(hanwang);
+		break;
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+		/* this urb is terminated, clean up */
+		dev_err(&dev->dev, "%s - urb shutting down with status: %d",
+			__func__, urb->status);
+		return;
+	default:
+		dev_err(&dev->dev, "%s - nonzero urb status received: %d",
+			__func__, urb->status);
+		break;
+	}
+
+	retval = usb_submit_urb(urb, GFP_ATOMIC);
+	if (retval)
+		dev_err(&dev->dev, "%s - usb_submit_urb failed with result %d",
+			__func__, retval);
+}
+
+static int hanwang_open(struct input_dev *dev)
+{
+	struct hanwang *hanwang = input_get_drvdata(dev);
+
+	hanwang->irq->dev = hanwang->usbdev;
+	if (usb_submit_urb(hanwang->irq, GFP_KERNEL))
+		return -EIO;
+
+	return 0;
+}
+
+static void hanwang_close(struct input_dev *dev)
+{
+	struct hanwang *hanwang = input_get_drvdata(dev);
+
+	usb_kill_urb(hanwang->irq);
+}
+
+static bool get_features(struct usb_device *dev, struct hanwang *hanwang)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(features_array); i++) {
+		if (le16_to_cpu(dev->descriptor.idProduct) ==
+				features_array[i].pid) {
+			hanwang->features = &features_array[i];
+			return true;
+		}
+	}
+
+	return false;
+}
+
+
+static int hanwang_probe(struct usb_interface *intf, const struct usb_device_id *id)
+{
+	struct usb_device *dev = interface_to_usbdev(intf);
+	struct usb_endpoint_descriptor *endpoint;
+	struct hanwang *hanwang;
+	struct input_dev *input_dev;
+	int error;
+	int i;
+
+	hanwang = kzalloc(sizeof(struct hanwang), GFP_KERNEL);
+	input_dev = input_allocate_device();
+	if (!hanwang || !input_dev) {
+		error = -ENOMEM;
+		goto fail1;
+	}
+
+	if (!get_features(dev, hanwang)) {
+		error = -ENXIO;
+		goto fail1;
+	}
+
+	hanwang->data = usb_alloc_coherent(dev, hanwang->features->pkg_len,
+					GFP_KERNEL, &hanwang->data_dma);
+	if (!hanwang->data) {
+		error = -ENOMEM;
+		goto fail1;
+	}
+
+	hanwang->irq = usb_alloc_urb(0, GFP_KERNEL);
+	if (!hanwang->irq) {
+		error = -ENOMEM;
+		goto fail2;
+	}
+
+	hanwang->usbdev = dev;
+	hanwang->dev = input_dev;
+
+	usb_make_path(dev, hanwang->phys, sizeof(hanwang->phys));
+	strlcat(hanwang->phys, "/input0", sizeof(hanwang->phys));
+
+	strlcpy(hanwang->name, hanwang->features->name, sizeof(hanwang->name));
+	input_dev->name = hanwang->name;
+	input_dev->phys = hanwang->phys;
+	usb_to_input_id(dev, &input_dev->id);
+	input_dev->dev.parent = &intf->dev;
+
+	input_set_drvdata(input_dev, hanwang);
+
+	input_dev->open = hanwang_open;
+	input_dev->close = hanwang_close;
+
+	for (i = 0; i < ARRAY_SIZE(hw_eventtypes); ++i)
+		__set_bit(hw_eventtypes[i], input_dev->evbit);
+
+	for (i = 0; i < ARRAY_SIZE(hw_absevents); ++i)
+		__set_bit(hw_absevents[i], input_dev->absbit);
+
+	for (i = 0; i < ARRAY_SIZE(hw_btnevents); ++i)
+		__set_bit(hw_btnevents[i], input_dev->keybit);
+
+	input_set_abs_params(input_dev, ABS_X,
+			     0, hanwang->features->max_x, 4, 0);
+	input_set_abs_params(input_dev, ABS_Y,
+			     0, hanwang->features->max_y, 4, 0);
+	input_set_abs_params(input_dev, ABS_TILT_X,
+			     0, hanwang->features->max_tilt_x, 0, 0);
+	input_set_abs_params(input_dev, ABS_TILT_Y,
+			     0, hanwang->features->max_tilt_y, 0, 0);
+	input_set_abs_params(input_dev, ABS_PRESSURE,
+			     0, hanwang->features->max_pressure, 0, 0);
+
+	endpoint = &intf->cur_altsetting->endpoint[0].desc;
+	usb_fill_int_urb(hanwang->irq, dev,
+			usb_rcvintpipe(dev, endpoint->bEndpointAddress),
+			hanwang->data, hanwang->features->pkg_len,
+			hanwang_irq, hanwang, endpoint->bInterval);
+	hanwang->irq->transfer_dma = hanwang->data_dma;
+	hanwang->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+
+	error = input_register_device(hanwang->dev);
+	if (error)
+		goto fail3;
+
+	usb_set_intfdata(intf, hanwang);
+
+	return 0;
+
+ fail3:	usb_free_urb(hanwang->irq);
+ fail2:	usb_free_coherent(dev, hanwang->features->pkg_len,
+			hanwang->data, hanwang->data_dma);
+ fail1:	input_free_device(input_dev);
+	kfree(hanwang);
+	return error;
+
+}
+
+static void hanwang_disconnect(struct usb_interface *intf)
+{
+	struct hanwang *hanwang = usb_get_intfdata(intf);
+
+	input_unregister_device(hanwang->dev);
+	usb_free_urb(hanwang->irq);
+	usb_free_coherent(interface_to_usbdev(intf),
+			hanwang->features->pkg_len, hanwang->data,
+			hanwang->data_dma);
+	kfree(hanwang);
+	usb_set_intfdata(intf, NULL);
+}
+
+static const struct usb_device_id hanwang_ids[] = {
+	{ HANWANG_TABLET_DEVICE(USB_VENDOR_ID_HANWANG, HANWANG_TABLET_INT_CLASS,
+		HANWANG_TABLET_INT_SUB_CLASS, HANWANG_TABLET_INT_PROTOCOL) },
+	{}
+};
+
+MODULE_DEVICE_TABLE(usb, hanwang_ids);
+
+static struct usb_driver hanwang_driver = {
+	.name		= "hanwang",
+	.probe		= hanwang_probe,
+	.disconnect	= hanwang_disconnect,
+	.id_table	= hanwang_ids,
+};
+
+static int __init hanwang_init(void)
+{
+	return usb_register(&hanwang_driver);
+}
+
+static void __exit hanwang_exit(void)
+{
+	usb_deregister(&hanwang_driver);
+}
+
+module_init(hanwang_init);
+module_exit(hanwang_exit);
