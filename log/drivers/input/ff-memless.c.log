commit fa3a5a1880c91bb92594ad42dfe9eedad7996b86
Author: Oliver Neukum <oneukum@suse.com>
Date:   Fri Nov 15 11:35:05 2019 -0800

    Input: ff-memless - kill timer in destroy()
    
    No timer must be left running when the device goes away.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.com>
    Reported-and-tested-by: syzbot+b6c55daa701fc389e286@syzkaller.appspotmail.com
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/1573726121.17351.3.camel@suse.com
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/ff-memless.c b/drivers/input/ff-memless.c
index 1cb40c7475af..8229a9006917 100644
--- a/drivers/input/ff-memless.c
+++ b/drivers/input/ff-memless.c
@@ -489,6 +489,15 @@ static void ml_ff_destroy(struct ff_device *ff)
 {
 	struct ml_device *ml = ff->private;
 
+	/*
+	 * Even though we stop all playing effects when tearing down
+	 * an input device (via input_device_flush() that calls into
+	 * input_ff_flush() that stops and erases all effects), we
+	 * do not actually stop the timer, and therefore we should
+	 * do it here.
+	 */
+	del_timer_sync(&ml->timer);
+
 	kfree(ml->private);
 }
 

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/input/ff-memless.c b/drivers/input/ff-memless.c
index 2743ed4656e4..1cb40c7475af 100644
--- a/drivers/input/ff-memless.c
+++ b/drivers/input/ff-memless.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Force feedback support for memoryless devices
  *
@@ -6,19 +7,6 @@
  */
 
 /*
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
 
 /* #define DEBUG */

commit 34445d4b3814b22a225819566f85516f3b04808f
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Oct 19 17:22:46 2017 -0700

    Input: ff_memless - convert to using timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Pali Roh√°r <pali.rohar@gmail.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/ff-memless.c b/drivers/input/ff-memless.c
index fcc6c3368182..2743ed4656e4 100644
--- a/drivers/input/ff-memless.c
+++ b/drivers/input/ff-memless.c
@@ -412,10 +412,10 @@ static void ml_play_effects(struct ml_device *ml)
 	ml_schedule_timer(ml);
 }
 
-static void ml_effect_timer(unsigned long timer_data)
+static void ml_effect_timer(struct timer_list *t)
 {
-	struct input_dev *dev = (struct input_dev *)timer_data;
-	struct ml_device *ml = dev->ff->private;
+	struct ml_device *ml = from_timer(ml, t, timer);
+	struct input_dev *dev = ml->dev;
 	unsigned long flags;
 
 	pr_debug("timer: updating effects\n");
@@ -526,7 +526,7 @@ int input_ff_create_memless(struct input_dev *dev, void *data,
 	ml->private = data;
 	ml->play_effect = play_effect;
 	ml->gain = 0xffff;
-	setup_timer(&ml->timer, ml_effect_timer, (unsigned long)dev);
+	timer_setup(&ml->timer, ml_effect_timer, 0);
 
 	set_bit(FF_GAIN, dev->ffbit);
 

commit 559addc25b00ff3a40eff03a0b3873c2b6d726f8
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Wed Feb 4 06:07:30 2015 -0300

    [media] fixp-arith: replace sin/cos table by a better precision one
    
    The cos table used at fixp-arith.h has only 8 bits of precision.
    That causes problems if it is reused on other drivers.
    
    As some media drivers require a higher precision sin/cos
    implementation, replace the current implementation by one that
    will provide 32 bits precision.
    
    The values generated by the new implementation matches the
    32 bit precision of glibc's sin for an angle measured in
    integer degrees.
    
    It also provides support for fractional angles via linear
    interpolation. On experimental calculus, when used a table
    with a 0.001 degree angle, the maximum error for sin is
    0.000038, which is likely good enough for practical purposes.
    
    There are some logic there that seems to be specific to the
    usage inside ff-memless.c. Move those logic to there, as they're
    not needed elsewhere.
    
    Cc: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Signed-off-by: Prashant Laddha <prladdha@cisco.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/drivers/input/ff-memless.c b/drivers/input/ff-memless.c
index 74c0d8c6002a..fcc6c3368182 100644
--- a/drivers/input/ff-memless.c
+++ b/drivers/input/ff-memless.c
@@ -237,6 +237,18 @@ static u16 ml_calculate_direction(u16 direction, u16 force,
 		(force + new_force)) << 1;
 }
 
+#define FRAC_N 8
+static inline s16 fixp_new16(s16 a)
+{
+	return ((s32)a) >> (16 - FRAC_N);
+}
+
+static inline s16 fixp_mult(s16 a, s16 b)
+{
+	a = ((s32)a * 0x100) / 0x7fff;
+	return ((s32)(a * b)) >> FRAC_N;
+}
+
 /*
  * Combine two effects and apply gain.
  */
@@ -247,7 +259,7 @@ static void ml_combine_effects(struct ff_effect *effect,
 	struct ff_effect *new = state->effect;
 	unsigned int strong, weak, i;
 	int x, y;
-	fixp_t level;
+	s16 level;
 
 	switch (new->type) {
 	case FF_CONSTANT:
@@ -255,8 +267,8 @@ static void ml_combine_effects(struct ff_effect *effect,
 		level = fixp_new16(apply_envelope(state,
 					new->u.constant.level,
 					&new->u.constant.envelope));
-		x = fixp_mult(fixp_sin(i), level) * gain / 0xffff;
-		y = fixp_mult(-fixp_cos(i), level) * gain / 0xffff;
+		x = fixp_mult(fixp_sin16(i), level) * gain / 0xffff;
+		y = fixp_mult(-fixp_cos16(i), level) * gain / 0xffff;
 		/*
 		 * here we abuse ff_ramp to hold x and y of constant force
 		 * If in future any driver wants something else than x and y

commit 41091ad0b8f843d36390058362c8f3c52a26a333
Author: Baodong Chen <chenbdchenbd@gmail.com>
Date:   Sun Jul 29 22:33:03 2012 -0700

    Input: random formatting fixes
    
    Fixes for some coding style issues reported by scripts/checkpatch.pl
    utility.
    
    Signed-off-by: Baodong Chen <chenbdchenbd@gmail.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/ff-memless.c b/drivers/input/ff-memless.c
index b107922514fb..74c0d8c6002a 100644
--- a/drivers/input/ff-memless.c
+++ b/drivers/input/ff-memless.c
@@ -72,12 +72,14 @@ static const struct ff_envelope *get_envelope(const struct ff_effect *effect)
 	static const struct ff_envelope empty_envelope;
 
 	switch (effect->type) {
-		case FF_PERIODIC:
-			return &effect->u.periodic.envelope;
-		case FF_CONSTANT:
-			return &effect->u.constant.envelope;
-		default:
-			return &empty_envelope;
+	case FF_PERIODIC:
+		return &effect->u.periodic.envelope;
+
+	case FF_CONSTANT:
+		return &effect->u.constant.envelope;
+
+	default:
+		return &empty_envelope;
 	}
 }
 

commit 9a932145f2d57bad1092ba006dee9065adc5eb39
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Sat Jul 7 18:17:54 2012 -0700

    Input: ff-memless - fix a couple min_t() casts
    
    envelope->attack_level is a u16 type.  We're trying to clamp it here
    so it's between 0 and 0x7fff.  Unfortunately, the cast to __s16 turns
    all the values larger than 0x7fff into negative numbers and min_t()
    thinks they are less than 0x7fff.  envelope_level is an int so now
    we've got negative values stored there.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/ff-memless.c b/drivers/input/ff-memless.c
index 5f558851d646..b107922514fb 100644
--- a/drivers/input/ff-memless.c
+++ b/drivers/input/ff-memless.c
@@ -176,7 +176,7 @@ static int apply_envelope(struct ml_effect_state *state, int value,
 			 value, envelope->attack_level);
 		time_from_level = jiffies_to_msecs(now - state->play_at);
 		time_of_envelope = envelope->attack_length;
-		envelope_level = min_t(__s16, envelope->attack_level, 0x7fff);
+		envelope_level = min_t(u16, envelope->attack_level, 0x7fff);
 
 	} else if (envelope->fade_length && effect->replay.length &&
 		   time_after(now,
@@ -184,7 +184,7 @@ static int apply_envelope(struct ml_effect_state *state, int value,
 		   time_before(now, state->stop_at)) {
 		time_from_level = jiffies_to_msecs(state->stop_at - now);
 		time_of_envelope = envelope->fade_length;
-		envelope_level = min_t(__s16, envelope->fade_level, 0x7fff);
+		envelope_level = min_t(u16, envelope->fade_level, 0x7fff);
 	} else
 		return value;
 

commit c8e1fb4a67eed95364a50f33f5201a88877c5215
Author: Antonio Ospite <ospite@studenti.unina.it>
Date:   Mon May 14 08:07:44 2012 -0300

    [media] Input: move drivers/input/fixp-arith.h to include/linux
    
    Move drivers/input/fixp-arith.h to include/linux so that the functions
    defined there can be used by other subsystems, for instance some video
    devices ISPs can control the output HUE value by setting registers for
    sin(HUE) and cos(HUE).
    
    Signed-off-by: Antonio Ospite <ospite@studenti.unina.it>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/input/ff-memless.c b/drivers/input/ff-memless.c
index 117a59aaa70e..5f558851d646 100644
--- a/drivers/input/ff-memless.c
+++ b/drivers/input/ff-memless.c
@@ -31,8 +31,7 @@
 #include <linux/mutex.h>
 #include <linux/spinlock.h>
 #include <linux/jiffies.h>
-
-#include "fixp-arith.h"
+#include <linux/fixp-arith.h>
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Anssi Hannula <anssi.hannula@gmail.com>");

commit da0c490115de026618a7fdcd886602da44392a50
Author: Joe Perches <joe@perches.com>
Date:   Mon Nov 29 23:33:07 2010 -0800

    Input: use pr_fmt and pr_<level>
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/ff-memless.c b/drivers/input/ff-memless.c
index 1d881c96ba8f..117a59aaa70e 100644
--- a/drivers/input/ff-memless.c
+++ b/drivers/input/ff-memless.c
@@ -23,7 +23,7 @@
 
 /* #define DEBUG */
 
-#define debug(format, arg...) pr_debug("ff-memless: " format "\n", ## arg)
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
 #include <linux/slab.h>
 #include <linux/input.h>
@@ -129,7 +129,7 @@ static void ml_schedule_timer(struct ml_device *ml)
 	int events = 0;
 	int i;
 
-	debug("calculating next timer");
+	pr_debug("calculating next timer\n");
 
 	for (i = 0; i < FF_MEMLESS_EFFECTS; i++) {
 
@@ -149,10 +149,10 @@ static void ml_schedule_timer(struct ml_device *ml)
 	}
 
 	if (!events) {
-		debug("no actions");
+		pr_debug("no actions\n");
 		del_timer(&ml->timer);
 	} else {
-		debug("timer set");
+		pr_debug("timer set\n");
 		mod_timer(&ml->timer, earliest);
 	}
 }
@@ -173,8 +173,8 @@ static int apply_envelope(struct ml_effect_state *state, int value,
 	if (envelope->attack_length &&
 	    time_before(now,
 			state->play_at + msecs_to_jiffies(envelope->attack_length))) {
-		debug("value = 0x%x, attack_level = 0x%x", value,
-		      envelope->attack_level);
+		pr_debug("value = 0x%x, attack_level = 0x%x\n",
+			 value, envelope->attack_level);
 		time_from_level = jiffies_to_msecs(now - state->play_at);
 		time_of_envelope = envelope->attack_length;
 		envelope_level = min_t(__s16, envelope->attack_level, 0x7fff);
@@ -191,13 +191,13 @@ static int apply_envelope(struct ml_effect_state *state, int value,
 
 	difference = abs(value) - envelope_level;
 
-	debug("difference = %d", difference);
-	debug("time_from_level = 0x%x", time_from_level);
-	debug("time_of_envelope = 0x%x", time_of_envelope);
+	pr_debug("difference = %d\n", difference);
+	pr_debug("time_from_level = 0x%x\n", time_from_level);
+	pr_debug("time_of_envelope = 0x%x\n", time_of_envelope);
 
 	difference = difference * time_from_level / time_of_envelope;
 
-	debug("difference = %d", difference);
+	pr_debug("difference = %d\n", difference);
 
 	return value < 0 ?
 		-(difference + envelope_level) : (difference + envelope_level);
@@ -215,8 +215,7 @@ static int get_compatible_type(struct ff_device *ff, int effect_type)
 	if (effect_type == FF_PERIODIC && test_bit(FF_RUMBLE, ff->ffbit))
 		return FF_RUMBLE;
 
-	printk(KERN_ERR
-	       "ff-memless: invalid type in get_compatible_type()\n");
+	pr_err("invalid type in get_compatible_type()\n");
 
 	return 0;
 }
@@ -312,7 +311,7 @@ static void ml_combine_effects(struct ff_effect *effect,
 		break;
 
 	default:
-		printk(KERN_ERR "ff-memless: invalid type in ml_combine_effects()\n");
+		pr_err("invalid type in ml_combine_effects()\n");
 		break;
 	}
 
@@ -406,7 +405,7 @@ static void ml_effect_timer(unsigned long timer_data)
 	struct ml_device *ml = dev->ff->private;
 	unsigned long flags;
 
-	debug("timer: updating effects");
+	pr_debug("timer: updating effects\n");
 
 	spin_lock_irqsave(&dev->event_lock, flags);
 	ml_play_effects(ml);
@@ -438,7 +437,7 @@ static int ml_ff_playback(struct input_dev *dev, int effect_id, int value)
 	struct ml_effect_state *state = &ml->states[effect_id];
 
 	if (value > 0) {
-		debug("initiated play");
+		pr_debug("initiated play\n");
 
 		__set_bit(FF_EFFECT_STARTED, &state->flags);
 		state->count = value;
@@ -449,7 +448,7 @@ static int ml_ff_playback(struct input_dev *dev, int effect_id, int value)
 		state->adj_at = state->play_at;
 
 	} else {
-		debug("initiated stop");
+		pr_debug("initiated stop\n");
 
 		if (test_bit(FF_EFFECT_PLAYING, &state->flags))
 			__set_bit(FF_EFFECT_ABORTING, &state->flags);

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/input/ff-memless.c b/drivers/input/ff-memless.c
index f967008f332e..1d881c96ba8f 100644
--- a/drivers/input/ff-memless.c
+++ b/drivers/input/ff-memless.c
@@ -25,6 +25,7 @@
 
 #define debug(format, arg...) pr_debug("ff-memless: " format "\n", ## arg)
 
+#include <linux/slab.h>
 #include <linux/input.h>
 #include <linux/module.h>
 #include <linux/mutex.h>

commit 94ec26c855bc675259e4f1658673f458040affd7
Author: Jari Vanhala <ext-jari.vanhala@nokia.com>
Date:   Thu Dec 24 21:52:20 2009 -0800

    Input: ff-memless - add notion of direction to for rumble effects
    
    This adds simple direction calculation when combining effects. It's useful
    to decide motor direction for rumble (vibrator).
    
    Signed-off-by: Jari Vanhala <ext-jari.vanhala@nokia.com>
    Acked-by: Anssi Hannula <anssi.hannula@iki.fi>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/ff-memless.c b/drivers/input/ff-memless.c
index 9667a5fd6bd7..f967008f332e 100644
--- a/drivers/input/ff-memless.c
+++ b/drivers/input/ff-memless.c
@@ -220,6 +220,22 @@ static int get_compatible_type(struct ff_device *ff, int effect_type)
 	return 0;
 }
 
+/*
+ * Only left/right direction should be used (under/over 0x8000) for
+ * forward/reverse motor direction (to keep calculation fast & simple).
+ */
+static u16 ml_calculate_direction(u16 direction, u16 force,
+				  u16 new_direction, u16 new_force)
+{
+	if (!force)
+		return new_direction;
+	if (!new_force)
+		return direction;
+	return (((u32)(direction >> 1) * force +
+		 (new_direction >> 1) * new_force) /
+		(force + new_force)) << 1;
+}
+
 /*
  * Combine two effects and apply gain.
  */
@@ -254,6 +270,19 @@ static void ml_combine_effects(struct ff_effect *effect,
 	case FF_RUMBLE:
 		strong = (u32)new->u.rumble.strong_magnitude * gain / 0xffff;
 		weak = (u32)new->u.rumble.weak_magnitude * gain / 0xffff;
+
+		if (effect->u.rumble.strong_magnitude + strong)
+			effect->direction = ml_calculate_direction(
+				effect->direction,
+				effect->u.rumble.strong_magnitude,
+				new->direction, strong);
+		else if (effect->u.rumble.weak_magnitude + weak)
+			effect->direction = ml_calculate_direction(
+				effect->direction,
+				effect->u.rumble.weak_magnitude,
+				new->direction, weak);
+		else
+			effect->direction = 0;
 		effect->u.rumble.strong_magnitude =
 			min(strong + effect->u.rumble.strong_magnitude,
 			    0xffffU);
@@ -268,6 +297,13 @@ static void ml_combine_effects(struct ff_effect *effect,
 		/* here we also scale it 0x7fff => 0xffff */
 		i = i * gain / 0x7fff;
 
+		if (effect->u.rumble.strong_magnitude + i)
+			effect->direction = ml_calculate_direction(
+				effect->direction,
+				effect->u.rumble.strong_magnitude,
+				new->direction, i);
+		else
+			effect->direction = 0;
 		effect->u.rumble.strong_magnitude =
 			min(i + effect->u.rumble.strong_magnitude, 0xffffU);
 		effect->u.rumble.weak_magnitude =

commit 1b11c88d3e8f55dc9d193d19de11e3f7abc1b7d7
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Thu Dec 24 21:44:19 2009 -0800

    Input: ff-memless - another fix for signed to unsigned overflow
    
    The commit 9e68177ef93b2f34eee5a1e1707bceef4b9ba69c changed 'gain' from
    signed to unsigned to fix an issue with rumble effect calculation, however
    it introduced problems when calculating constant effects. Having 'gain'
    being unsigned int was an unfortunate choice since it dominates all
    implicit type conversions causing everything to be treated as unsigned
    int.
    
    Let's change it back to signed int and simply add proper casts to rumble
    effect calculations.
    
    Reported-by: Gary Stein <lordcnidarian@gmail.com>
    Acked-by: Anssi Hannula <anssi.hannula@iki.fi>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/ff-memless.c b/drivers/input/ff-memless.c
index decc51f45bfd..9667a5fd6bd7 100644
--- a/drivers/input/ff-memless.c
+++ b/drivers/input/ff-memless.c
@@ -225,7 +225,7 @@ static int get_compatible_type(struct ff_device *ff, int effect_type)
  */
 static void ml_combine_effects(struct ff_effect *effect,
 			       struct ml_effect_state *state,
-			       unsigned int gain)
+			       int gain)
 {
 	struct ff_effect *new = state->effect;
 	unsigned int strong, weak, i;
@@ -252,8 +252,8 @@ static void ml_combine_effects(struct ff_effect *effect,
 		break;
 
 	case FF_RUMBLE:
-		strong = new->u.rumble.strong_magnitude * gain / 0xffff;
-		weak = new->u.rumble.weak_magnitude * gain / 0xffff;
+		strong = (u32)new->u.rumble.strong_magnitude * gain / 0xffff;
+		weak = (u32)new->u.rumble.weak_magnitude * gain / 0xffff;
 		effect->u.rumble.strong_magnitude =
 			min(strong + effect->u.rumble.strong_magnitude,
 			    0xffffU);

commit 25ae08317647c68ed9276f7bdc07d0d5fd042628
Author: Jari Vanhala <ext-jari.vanhala@nokia.com>
Date:   Thu Dec 24 21:52:19 2009 -0800

    Input: ff-memless - start playing FF effects immediately
    
    Instead of waiting for the next timer tick to start playing an effect
    do it immediately. This mostly helps systems using low HZ setting.
    
    Signed-off-by: Jari Vanhala <ext-jari.vanhala@nokia.com>
    Acked-by: Anssi Hannula <anssi.hannula@iki.fi>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/ff-memless.c b/drivers/input/ff-memless.c
index b483b2995fa9..decc51f45bfd 100644
--- a/drivers/input/ff-memless.c
+++ b/drivers/input/ff-memless.c
@@ -411,8 +411,6 @@ static int ml_ff_playback(struct input_dev *dev, int effect_id, int value)
 				 msecs_to_jiffies(state->effect->replay.length);
 		state->adj_at = state->play_at;
 
-		ml_schedule_timer(ml);
-
 	} else {
 		debug("initiated stop");
 
@@ -420,10 +418,10 @@ static int ml_ff_playback(struct input_dev *dev, int effect_id, int value)
 			__set_bit(FF_EFFECT_ABORTING, &state->flags);
 		else
 			__clear_bit(FF_EFFECT_STARTED, &state->flags);
-
-		ml_play_effects(ml);
 	}
 
+	ml_play_effects(ml);
+
 	return 0;
 }
 

commit bf3204cbff7d2606e758afb0994e8da6ae1c6c26
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Nov 6 21:39:07 2009 -0800

    Input: fix locking in memoryless force-feedback devices
    
    Now that input core acquires dev->event_lock spinlock and disables
    interrupts when propagating input events, using spin_lock_bh() in
    ff-memless driver is not allowed. Actually, the timer_lock itself
    is not needed anymore, we should simply use dev->event_lock
    as well.
    
    Also do a small cleanup in force-feedback core.
    
    Reported-by: kerneloops.org
    Reported-by: http://www.kerneloops.org/searchweek.php?search=ml_ff_set_gain
    Reported-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/ff-memless.c b/drivers/input/ff-memless.c
index 2d1415e16834..b483b2995fa9 100644
--- a/drivers/input/ff-memless.c
+++ b/drivers/input/ff-memless.c
@@ -61,7 +61,6 @@ struct ml_device {
 	struct ml_effect_state states[FF_MEMLESS_EFFECTS];
 	int gain;
 	struct timer_list timer;
-	spinlock_t timer_lock;
 	struct input_dev *dev;
 
 	int (*play_effect)(struct input_dev *dev, void *data,
@@ -368,38 +367,38 @@ static void ml_effect_timer(unsigned long timer_data)
 {
 	struct input_dev *dev = (struct input_dev *)timer_data;
 	struct ml_device *ml = dev->ff->private;
+	unsigned long flags;
 
 	debug("timer: updating effects");
 
-	spin_lock(&ml->timer_lock);
+	spin_lock_irqsave(&dev->event_lock, flags);
 	ml_play_effects(ml);
-	spin_unlock(&ml->timer_lock);
+	spin_unlock_irqrestore(&dev->event_lock, flags);
 }
 
+/*
+ * Sets requested gain for FF effects. Called with dev->event_lock held.
+ */
 static void ml_ff_set_gain(struct input_dev *dev, u16 gain)
 {
 	struct ml_device *ml = dev->ff->private;
 	int i;
 
-	spin_lock_bh(&ml->timer_lock);
-
 	ml->gain = gain;
 
 	for (i = 0; i < FF_MEMLESS_EFFECTS; i++)
 		__clear_bit(FF_EFFECT_PLAYING, &ml->states[i].flags);
 
 	ml_play_effects(ml);
-
-	spin_unlock_bh(&ml->timer_lock);
 }
 
+/*
+ * Start/stop specified FF effect. Called with dev->event_lock held.
+ */
 static int ml_ff_playback(struct input_dev *dev, int effect_id, int value)
 {
 	struct ml_device *ml = dev->ff->private;
 	struct ml_effect_state *state = &ml->states[effect_id];
-	unsigned long flags;
-
-	spin_lock_irqsave(&ml->timer_lock, flags);
 
 	if (value > 0) {
 		debug("initiated play");
@@ -425,8 +424,6 @@ static int ml_ff_playback(struct input_dev *dev, int effect_id, int value)
 		ml_play_effects(ml);
 	}
 
-	spin_unlock_irqrestore(&ml->timer_lock, flags);
-
 	return 0;
 }
 
@@ -436,7 +433,7 @@ static int ml_ff_upload(struct input_dev *dev,
 	struct ml_device *ml = dev->ff->private;
 	struct ml_effect_state *state = &ml->states[effect->id];
 
-	spin_lock_bh(&ml->timer_lock);
+	spin_lock_irq(&dev->event_lock);
 
 	if (test_bit(FF_EFFECT_STARTED, &state->flags)) {
 		__clear_bit(FF_EFFECT_PLAYING, &state->flags);
@@ -448,7 +445,7 @@ static int ml_ff_upload(struct input_dev *dev,
 		ml_schedule_timer(ml);
 	}
 
-	spin_unlock_bh(&ml->timer_lock);
+	spin_unlock_irq(&dev->event_lock);
 
 	return 0;
 }
@@ -482,7 +479,6 @@ int input_ff_create_memless(struct input_dev *dev, void *data,
 	ml->private = data;
 	ml->play_effect = play_effect;
 	ml->gain = 0xffff;
-	spin_lock_init(&ml->timer_lock);
 	setup_timer(&ml->timer, ml_effect_timer, (unsigned long)dev);
 
 	set_bit(FF_GAIN, dev->ffbit);

commit 9e68177ef93b2f34eee5a1e1707bceef4b9ba69c
Author: Jussi Kivilinna <jussi.kivilinna@mbnet.fi>
Date:   Thu May 7 17:14:21 2009 -0700

    Input: ff-memless - fix signed to unsigned bit overflow
    
    When userspace sets effect->u.rumble.strong_magnitude to 0x8001 or
    larger, ml_combine_effects() would always return strong_magnitude
    0xffff.
    
    Problem is that 'gain' is passed in as signed integer. Multiplying
    magnitude (__u16) with gain (int) causes magnitude read as signed and
    results negative value (with magnitude > 0x8000). This signed integer
    is then divided and value, still negative, converted to 32bit unsigned
    integer. Finally checking combine overflow min(new+old, 0xffff) gives
    out 0xffff.
    
    Fix is to simply change 'gain' to unsigned int.
    
    Signed-off-by: Jussi Kivilinna <jussi.kivilinna@mbnet.fi>
    Acked-by: Anssi Hannula <anssi.hannula@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/ff-memless.c b/drivers/input/ff-memless.c
index bc4e40f3ede7..2d1415e16834 100644
--- a/drivers/input/ff-memless.c
+++ b/drivers/input/ff-memless.c
@@ -226,7 +226,7 @@ static int get_compatible_type(struct ff_device *ff, int effect_type)
  */
 static void ml_combine_effects(struct ff_effect *effect,
 			       struct ml_effect_state *state,
-			       int gain)
+			       unsigned int gain)
 {
 	struct ff_effect *new = state->effect;
 	unsigned int strong, weak, i;

commit 211f05a034f49586fdd071abd174853217ec29ee
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Sun Nov 23 16:57:36 2008 -0800

    input: replace spin_lock_bh with spin_lock_irqsave in ml_ff_playback
    
    ml_ff_playback() uses spin_(un)lock_bh. However this function is called
    with interrupts disabled from erase_effect() in drivers/input/ff-core.c:196.
    
    This is not permitted, and will result in a WARN_ON in the bottom half handling code.
    This patch changes this function to just use spin_lock_irqsave() instead, solving
    the problem and simplifying the locking logic.
    
    This was reported as entry #106559 in kerneloops.org
    
    Reported-by: kerneloops.org
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/input/ff-memless.c b/drivers/input/ff-memless.c
index 6790e975a98c..bc4e40f3ede7 100644
--- a/drivers/input/ff-memless.c
+++ b/drivers/input/ff-memless.c
@@ -397,8 +397,9 @@ static int ml_ff_playback(struct input_dev *dev, int effect_id, int value)
 {
 	struct ml_device *ml = dev->ff->private;
 	struct ml_effect_state *state = &ml->states[effect_id];
+	unsigned long flags;
 
-	spin_lock_bh(&ml->timer_lock);
+	spin_lock_irqsave(&ml->timer_lock, flags);
 
 	if (value > 0) {
 		debug("initiated play");
@@ -424,7 +425,7 @@ static int ml_ff_playback(struct input_dev *dev, int effect_id, int value)
 		ml_play_effects(ml);
 	}
 
-	spin_unlock_bh(&ml->timer_lock);
+	spin_unlock_irqrestore(&ml->timer_lock, flags);
 
 	return 0;
 }

commit 923104747d5c4d58762aa865f71d48d3beb73ae6
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon May 5 11:50:59 2008 -0400

    Input: use clamp_val() macro in ff-memless.c
    
    Replace two opencoded nested min/max macros with clamp_val().
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/ff-memless.c b/drivers/input/ff-memless.c
index d226d935b0dc..6790e975a98c 100644
--- a/drivers/input/ff-memless.c
+++ b/drivers/input/ff-memless.c
@@ -247,9 +247,9 @@ static void ml_combine_effects(struct ff_effect *effect,
 		 * in s8, this should be changed to something more generic
 		 */
 		effect->u.ramp.start_level =
-			max(min(effect->u.ramp.start_level + x, 0x7f), -0x80);
+			clamp_val(effect->u.ramp.start_level + x, -0x80, 0x7f);
 		effect->u.ramp.end_level =
-			max(min(effect->u.ramp.end_level + y, 0x7f), -0x80);
+			clamp_val(effect->u.ramp.end_level + y, -0x80, 0x7f);
 		break;
 
 	case FF_RUMBLE:

commit cd354f1ae75e6466a7e31b727faede57a1f89ca5
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Wed Feb 14 00:33:14 2007 -0800

    [PATCH] remove many unneeded #includes of sched.h
    
    After Al Viro (finally) succeeded in removing the sched.h #include in module.h
    recently, it makes sense again to remove other superfluous sched.h includes.
    There are quite a lot of files which include it but don't actually need
    anything defined in there.  Presumably these includes were once needed for
    macros that used to live in sched.h, but moved to other header files in the
    course of cleaning it up.
    
    To ease the pain, this time I did not fiddle with any header files and only
    removed #includes from .c-files, which tend to cause less trouble.
    
    Compile tested against 2.6.20-rc2 and 2.6.20-rc2-mm2 (with offsets) on alpha,
    arm, i386, ia64, mips, powerpc, and x86_64 with allnoconfig, defconfig,
    allmodconfig, and allyesconfig as well as a few randconfigs on x86_64 and all
    configs in arch/arm/configs on arm.  I also checked that no new warnings were
    introduced by the patch (actually, some warnings are removed that were emitted
    by unnecessarily included header files).
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/input/ff-memless.c b/drivers/input/ff-memless.c
index eba18b6ac5e4..d226d935b0dc 100644
--- a/drivers/input/ff-memless.c
+++ b/drivers/input/ff-memless.c
@@ -29,7 +29,7 @@
 #include <linux/module.h>
 #include <linux/mutex.h>
 #include <linux/spinlock.h>
-#include <linux/sched.h>
+#include <linux/jiffies.h>
 
 #include "fixp-arith.h"
 

commit e4477d2d1bc3e6c76e83926f7fa8c8f94ba42615
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Fri Nov 24 00:43:09 2006 -0500

    Input: add to kernel-api docbook
    
    Add input subsystem to kernel-api docbook.
    Enhance some function and parameter comments.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/ff-memless.c b/drivers/input/ff-memless.c
index cd8b7297e6df..eba18b6ac5e4 100644
--- a/drivers/input/ff-memless.c
+++ b/drivers/input/ff-memless.c
@@ -460,7 +460,7 @@ static void ml_ff_destroy(struct ff_device *ff)
 }
 
 /**
- * input_ff_create_memless() - create memoryless FF device
+ * input_ff_create_memless() - create memoryless force-feedback device
  * @dev: input device supporting force-feedback
  * @data: driver-specific data to be passed into @play_effect
  * @play_effect: driver-specific method for playing FF effect

commit 7d928a2b14eede1f333db7b7b684c57f7fa7f456
Author: Anssi Hannula <anssi.hannula@gmail.com>
Date:   Wed Jul 19 01:40:30 2006 -0400

    Input: unified force feedback support for memoryless devices
    
    Consolidate core implementing memoryless devices in one module; added
    support for gain and envelopes and periodic => rumble conversion.
    
    Signed-off-by: Anssi Hannula <anssi.hannula@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/ff-memless.c b/drivers/input/ff-memless.c
new file mode 100644
index 000000000000..cd8b7297e6df
--- /dev/null
+++ b/drivers/input/ff-memless.c
@@ -0,0 +1,515 @@
+/*
+ *  Force feedback support for memoryless devices
+ *
+ *  Copyright (c) 2006 Anssi Hannula <anssi.hannula@gmail.com>
+ *  Copyright (c) 2006 Dmitry Torokhov <dtor@mail.ru>
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+/* #define DEBUG */
+
+#define debug(format, arg...) pr_debug("ff-memless: " format "\n", ## arg)
+
+#include <linux/input.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+#include <linux/sched.h>
+
+#include "fixp-arith.h"
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Anssi Hannula <anssi.hannula@gmail.com>");
+MODULE_DESCRIPTION("Force feedback support for memoryless devices");
+
+/* Number of effects handled with memoryless devices */
+#define FF_MEMLESS_EFFECTS	16
+
+/* Envelope update interval in ms */
+#define FF_ENVELOPE_INTERVAL	50
+
+#define FF_EFFECT_STARTED	0
+#define FF_EFFECT_PLAYING	1
+#define FF_EFFECT_ABORTING	2
+
+struct ml_effect_state {
+	struct ff_effect *effect;
+	unsigned long flags;	/* effect state (STARTED, PLAYING, etc) */
+	int count;		/* loop count of the effect */
+	unsigned long play_at;	/* start time */
+	unsigned long stop_at;	/* stop time */
+	unsigned long adj_at;	/* last time the effect was sent */
+};
+
+struct ml_device {
+	void *private;
+	struct ml_effect_state states[FF_MEMLESS_EFFECTS];
+	int gain;
+	struct timer_list timer;
+	spinlock_t timer_lock;
+	struct input_dev *dev;
+
+	int (*play_effect)(struct input_dev *dev, void *data,
+			   struct ff_effect *effect);
+};
+
+static const struct ff_envelope *get_envelope(const struct ff_effect *effect)
+{
+	static const struct ff_envelope empty_envelope;
+
+	switch (effect->type) {
+		case FF_PERIODIC:
+			return &effect->u.periodic.envelope;
+		case FF_CONSTANT:
+			return &effect->u.constant.envelope;
+		default:
+			return &empty_envelope;
+	}
+}
+
+/*
+ * Check for the next time envelope requires an update on memoryless devices
+ */
+static unsigned long calculate_next_time(struct ml_effect_state *state)
+{
+	const struct ff_envelope *envelope = get_envelope(state->effect);
+	unsigned long attack_stop, fade_start, next_fade;
+
+	if (envelope->attack_length) {
+		attack_stop = state->play_at +
+			msecs_to_jiffies(envelope->attack_length);
+		if (time_before(state->adj_at, attack_stop))
+			return state->adj_at +
+					msecs_to_jiffies(FF_ENVELOPE_INTERVAL);
+	}
+
+	if (state->effect->replay.length) {
+		if (envelope->fade_length) {
+			/* check when fading should start */
+			fade_start = state->stop_at -
+					msecs_to_jiffies(envelope->fade_length);
+
+			if (time_before(state->adj_at, fade_start))
+				return fade_start;
+
+			/* already fading, advance to next checkpoint */
+			next_fade = state->adj_at +
+					msecs_to_jiffies(FF_ENVELOPE_INTERVAL);
+			if (time_before(next_fade, state->stop_at))
+				return next_fade;
+		}
+
+		return state->stop_at;
+	}
+
+	return state->play_at;
+}
+
+static void ml_schedule_timer(struct ml_device *ml)
+{
+	struct ml_effect_state *state;
+	unsigned long now = jiffies;
+	unsigned long earliest = 0;
+	unsigned long next_at;
+	int events = 0;
+	int i;
+
+	debug("calculating next timer");
+
+	for (i = 0; i < FF_MEMLESS_EFFECTS; i++) {
+
+		state = &ml->states[i];
+
+		if (!test_bit(FF_EFFECT_STARTED, &state->flags))
+			continue;
+
+		if (test_bit(FF_EFFECT_PLAYING, &state->flags))
+			next_at = calculate_next_time(state);
+		else
+			next_at = state->play_at;
+
+		if (time_before_eq(now, next_at) &&
+		    (++events == 1 || time_before(next_at, earliest)))
+			earliest = next_at;
+	}
+
+	if (!events) {
+		debug("no actions");
+		del_timer(&ml->timer);
+	} else {
+		debug("timer set");
+		mod_timer(&ml->timer, earliest);
+	}
+}
+
+/*
+ * Apply an envelope to a value
+ */
+static int apply_envelope(struct ml_effect_state *state, int value,
+			  struct ff_envelope *envelope)
+{
+	struct ff_effect *effect = state->effect;
+	unsigned long now = jiffies;
+	int time_from_level;
+	int time_of_envelope;
+	int envelope_level;
+	int difference;
+
+	if (envelope->attack_length &&
+	    time_before(now,
+			state->play_at + msecs_to_jiffies(envelope->attack_length))) {
+		debug("value = 0x%x, attack_level = 0x%x", value,
+		      envelope->attack_level);
+		time_from_level = jiffies_to_msecs(now - state->play_at);
+		time_of_envelope = envelope->attack_length;
+		envelope_level = min_t(__s16, envelope->attack_level, 0x7fff);
+
+	} else if (envelope->fade_length && effect->replay.length &&
+		   time_after(now,
+			      state->stop_at - msecs_to_jiffies(envelope->fade_length)) &&
+		   time_before(now, state->stop_at)) {
+		time_from_level = jiffies_to_msecs(state->stop_at - now);
+		time_of_envelope = envelope->fade_length;
+		envelope_level = min_t(__s16, envelope->fade_level, 0x7fff);
+	} else
+		return value;
+
+	difference = abs(value) - envelope_level;
+
+	debug("difference = %d", difference);
+	debug("time_from_level = 0x%x", time_from_level);
+	debug("time_of_envelope = 0x%x", time_of_envelope);
+
+	difference = difference * time_from_level / time_of_envelope;
+
+	debug("difference = %d", difference);
+
+	return value < 0 ?
+		-(difference + envelope_level) : (difference + envelope_level);
+}
+
+/*
+ * Return the type the effect has to be converted into (memless devices)
+ */
+static int get_compatible_type(struct ff_device *ff, int effect_type)
+{
+
+	if (test_bit(effect_type, ff->ffbit))
+		return effect_type;
+
+	if (effect_type == FF_PERIODIC && test_bit(FF_RUMBLE, ff->ffbit))
+		return FF_RUMBLE;
+
+	printk(KERN_ERR
+	       "ff-memless: invalid type in get_compatible_type()\n");
+
+	return 0;
+}
+
+/*
+ * Combine two effects and apply gain.
+ */
+static void ml_combine_effects(struct ff_effect *effect,
+			       struct ml_effect_state *state,
+			       int gain)
+{
+	struct ff_effect *new = state->effect;
+	unsigned int strong, weak, i;
+	int x, y;
+	fixp_t level;
+
+	switch (new->type) {
+	case FF_CONSTANT:
+		i = new->direction * 360 / 0xffff;
+		level = fixp_new16(apply_envelope(state,
+					new->u.constant.level,
+					&new->u.constant.envelope));
+		x = fixp_mult(fixp_sin(i), level) * gain / 0xffff;
+		y = fixp_mult(-fixp_cos(i), level) * gain / 0xffff;
+		/*
+		 * here we abuse ff_ramp to hold x and y of constant force
+		 * If in future any driver wants something else than x and y
+		 * in s8, this should be changed to something more generic
+		 */
+		effect->u.ramp.start_level =
+			max(min(effect->u.ramp.start_level + x, 0x7f), -0x80);
+		effect->u.ramp.end_level =
+			max(min(effect->u.ramp.end_level + y, 0x7f), -0x80);
+		break;
+
+	case FF_RUMBLE:
+		strong = new->u.rumble.strong_magnitude * gain / 0xffff;
+		weak = new->u.rumble.weak_magnitude * gain / 0xffff;
+		effect->u.rumble.strong_magnitude =
+			min(strong + effect->u.rumble.strong_magnitude,
+			    0xffffU);
+		effect->u.rumble.weak_magnitude =
+			min(weak + effect->u.rumble.weak_magnitude, 0xffffU);
+		break;
+
+	case FF_PERIODIC:
+		i = apply_envelope(state, abs(new->u.periodic.magnitude),
+				   &new->u.periodic.envelope);
+
+		/* here we also scale it 0x7fff => 0xffff */
+		i = i * gain / 0x7fff;
+
+		effect->u.rumble.strong_magnitude =
+			min(i + effect->u.rumble.strong_magnitude, 0xffffU);
+		effect->u.rumble.weak_magnitude =
+			min(i + effect->u.rumble.weak_magnitude, 0xffffU);
+		break;
+
+	default:
+		printk(KERN_ERR "ff-memless: invalid type in ml_combine_effects()\n");
+		break;
+	}
+
+}
+
+
+/*
+ * Because memoryless devices have only one effect per effect type active
+ * at one time we have to combine multiple effects into one
+ */
+static int ml_get_combo_effect(struct ml_device *ml,
+			       unsigned long *effect_handled,
+			       struct ff_effect *combo_effect)
+{
+	struct ff_effect *effect;
+	struct ml_effect_state *state;
+	int effect_type;
+	int i;
+
+	memset(combo_effect, 0, sizeof(struct ff_effect));
+
+	for (i = 0; i < FF_MEMLESS_EFFECTS; i++) {
+		if (__test_and_set_bit(i, effect_handled))
+			continue;
+
+		state = &ml->states[i];
+		effect = state->effect;
+
+		if (!test_bit(FF_EFFECT_STARTED, &state->flags))
+			continue;
+
+		if (time_before(jiffies, state->play_at))
+			continue;
+
+		/*
+		 * here we have started effects that are either
+		 * currently playing (and may need be aborted)
+		 * or need to start playing.
+		 */
+		effect_type = get_compatible_type(ml->dev->ff, effect->type);
+		if (combo_effect->type != effect_type) {
+			if (combo_effect->type != 0) {
+				__clear_bit(i, effect_handled);
+				continue;
+			}
+			combo_effect->type = effect_type;
+		}
+
+		if (__test_and_clear_bit(FF_EFFECT_ABORTING, &state->flags)) {
+			__clear_bit(FF_EFFECT_PLAYING, &state->flags);
+			__clear_bit(FF_EFFECT_STARTED, &state->flags);
+		} else if (effect->replay.length &&
+			   time_after_eq(jiffies, state->stop_at)) {
+
+			__clear_bit(FF_EFFECT_PLAYING, &state->flags);
+
+			if (--state->count <= 0) {
+				__clear_bit(FF_EFFECT_STARTED, &state->flags);
+			} else {
+				state->play_at = jiffies +
+					msecs_to_jiffies(effect->replay.delay);
+				state->stop_at = state->play_at +
+					msecs_to_jiffies(effect->replay.length);
+			}
+		} else {
+			__set_bit(FF_EFFECT_PLAYING, &state->flags);
+			state->adj_at = jiffies;
+			ml_combine_effects(combo_effect, state, ml->gain);
+		}
+	}
+
+	return combo_effect->type != 0;
+}
+
+static void ml_play_effects(struct ml_device *ml)
+{
+	struct ff_effect effect;
+	DECLARE_BITMAP(handled_bm, FF_MEMLESS_EFFECTS);
+
+	memset(handled_bm, 0, sizeof(handled_bm));
+
+	while (ml_get_combo_effect(ml, handled_bm, &effect))
+		ml->play_effect(ml->dev, ml->private, &effect);
+
+	ml_schedule_timer(ml);
+}
+
+static void ml_effect_timer(unsigned long timer_data)
+{
+	struct input_dev *dev = (struct input_dev *)timer_data;
+	struct ml_device *ml = dev->ff->private;
+
+	debug("timer: updating effects");
+
+	spin_lock(&ml->timer_lock);
+	ml_play_effects(ml);
+	spin_unlock(&ml->timer_lock);
+}
+
+static void ml_ff_set_gain(struct input_dev *dev, u16 gain)
+{
+	struct ml_device *ml = dev->ff->private;
+	int i;
+
+	spin_lock_bh(&ml->timer_lock);
+
+	ml->gain = gain;
+
+	for (i = 0; i < FF_MEMLESS_EFFECTS; i++)
+		__clear_bit(FF_EFFECT_PLAYING, &ml->states[i].flags);
+
+	ml_play_effects(ml);
+
+	spin_unlock_bh(&ml->timer_lock);
+}
+
+static int ml_ff_playback(struct input_dev *dev, int effect_id, int value)
+{
+	struct ml_device *ml = dev->ff->private;
+	struct ml_effect_state *state = &ml->states[effect_id];
+
+	spin_lock_bh(&ml->timer_lock);
+
+	if (value > 0) {
+		debug("initiated play");
+
+		__set_bit(FF_EFFECT_STARTED, &state->flags);
+		state->count = value;
+		state->play_at = jiffies +
+				 msecs_to_jiffies(state->effect->replay.delay);
+		state->stop_at = state->play_at +
+				 msecs_to_jiffies(state->effect->replay.length);
+		state->adj_at = state->play_at;
+
+		ml_schedule_timer(ml);
+
+	} else {
+		debug("initiated stop");
+
+		if (test_bit(FF_EFFECT_PLAYING, &state->flags))
+			__set_bit(FF_EFFECT_ABORTING, &state->flags);
+		else
+			__clear_bit(FF_EFFECT_STARTED, &state->flags);
+
+		ml_play_effects(ml);
+	}
+
+	spin_unlock_bh(&ml->timer_lock);
+
+	return 0;
+}
+
+static int ml_ff_upload(struct input_dev *dev,
+			struct ff_effect *effect, struct ff_effect *old)
+{
+	struct ml_device *ml = dev->ff->private;
+	struct ml_effect_state *state = &ml->states[effect->id];
+
+	spin_lock_bh(&ml->timer_lock);
+
+	if (test_bit(FF_EFFECT_STARTED, &state->flags)) {
+		__clear_bit(FF_EFFECT_PLAYING, &state->flags);
+		state->play_at = jiffies +
+				 msecs_to_jiffies(state->effect->replay.delay);
+		state->stop_at = state->play_at +
+				 msecs_to_jiffies(state->effect->replay.length);
+		state->adj_at = state->play_at;
+		ml_schedule_timer(ml);
+	}
+
+	spin_unlock_bh(&ml->timer_lock);
+
+	return 0;
+}
+
+static void ml_ff_destroy(struct ff_device *ff)
+{
+	struct ml_device *ml = ff->private;
+
+	kfree(ml->private);
+}
+
+/**
+ * input_ff_create_memless() - create memoryless FF device
+ * @dev: input device supporting force-feedback
+ * @data: driver-specific data to be passed into @play_effect
+ * @play_effect: driver-specific method for playing FF effect
+ */
+int input_ff_create_memless(struct input_dev *dev, void *data,
+		int (*play_effect)(struct input_dev *, void *, struct ff_effect *))
+{
+	struct ml_device *ml;
+	struct ff_device *ff;
+	int error;
+	int i;
+
+	ml = kzalloc(sizeof(struct ml_device), GFP_KERNEL);
+	if (!ml)
+		return -ENOMEM;
+
+	ml->dev = dev;
+	ml->private = data;
+	ml->play_effect = play_effect;
+	ml->gain = 0xffff;
+	spin_lock_init(&ml->timer_lock);
+	setup_timer(&ml->timer, ml_effect_timer, (unsigned long)dev);
+
+	set_bit(FF_GAIN, dev->ffbit);
+
+	error = input_ff_create(dev, FF_MEMLESS_EFFECTS);
+	if (error) {
+		kfree(ml);
+		return error;
+	}
+
+	ff = dev->ff;
+	ff->private = ml;
+	ff->upload = ml_ff_upload;
+	ff->playback = ml_ff_playback;
+	ff->set_gain = ml_ff_set_gain;
+	ff->destroy = ml_ff_destroy;
+
+	/* we can emulate periodic effects with RUMBLE */
+	if (test_bit(FF_RUMBLE, ff->ffbit)) {
+		set_bit(FF_PERIODIC, dev->ffbit);
+		set_bit(FF_SINE, dev->ffbit);
+		set_bit(FF_TRIANGLE, dev->ffbit);
+		set_bit(FF_SQUARE, dev->ffbit);
+	}
+
+	for (i = 0; i < FF_MEMLESS_EFFECTS; i++)
+		ml->states[i].effect = &ff->effects[i];
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(input_ff_create_memless);
