commit bcf059578980526d6067a2b1b0cd8344b58bf2d5
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Oct 8 16:40:33 2019 -0700

    Input: soc_button_array - partial revert of support for newer surface devices
    
    Commit c394159310d0 ("Input: soc_button_array - add support for newer
    surface devices") not only added support for the MSHW0040 ACPI HID,
    but for some reason it also makes changes to the error handling of the
    soc_button_lookup_gpio() call in soc_button_device_create(). Note ideally
    this seamingly unrelated change would have been made in a separate commit,
    with a message explaining the what and why of this change.
    
    I guess this change may have been added to deal with -EPROBE_DEFER errors,
    but in case of the existing support for PNP0C40 devices, treating
    -EPROBE_DEFER as any other error is deliberate, see the comment this
    commit adds for why.
    
    The actual returning of -EPROBE_DEFER to the caller of soc_button_probe()
    introduced by the new error checking causes a serious regression:
    
    On devices with so called virtual GPIOs soc_button_lookup_gpio() will
    always return -EPROBE_DEFER for these fake GPIOs, when this happens
    during the second call of soc_button_device_create() we already have
    successfully registered our first child. This causes the kernel to think
    we are making progress with probing things even though we unregister the
    child before again before we return the -EPROBE_DEFER. Since we are making
    progress the kernel will retry deferred-probes again immediately ending
    up stuck in a loop with the following showing in dmesg:
    
    [  124.022697] input: gpio-keys as /devices/platform/INTCFD9:00/gpio-keys.0.auto/input/input6537
    [  124.040764] input: gpio-keys as /devices/platform/INTCFD9:00/gpio-keys.0.auto/input/input6538
    [  124.056967] input: gpio-keys as /devices/platform/INTCFD9:00/gpio-keys.0.auto/input/input6539
    [  124.072143] input: gpio-keys as /devices/platform/INTCFD9:00/gpio-keys.0.auto/input/input6540
    [  124.092373] input: gpio-keys as /devices/platform/INTCFD9:00/gpio-keys.0.auto/input/input6541
    [  124.108065] input: gpio-keys as /devices/platform/INTCFD9:00/gpio-keys.0.auto/input/input6542
    [  124.128483] input: gpio-keys as /devices/platform/INTCFD9:00/gpio-keys.0.auto/input/input6543
    [  124.147141] input: gpio-keys as /devices/platform/INTCFD9:00/gpio-keys.0.auto/input/input6544
    [  124.165070] input: gpio-keys as /devices/platform/INTCFD9:00/gpio-keys.0.auto/input/input6545
    [  124.179775] input: gpio-keys as /devices/platform/INTCFD9:00/gpio-keys.0.auto/input/input6546
    [  124.202726] input: gpio-keys as /devices/platform/INTCFD9:00/gpio-keys.0.auto/input/input6547
    <continues on and on and on>
    
    And 1 CPU core being stuck at 100% and udev hanging since it is waiting
    for the modprobe of soc_button_array to return.
    
    This patch reverts the soc_button_lookup_gpio() error handling changes,
    fixing this regression.
    
    Fixes: c394159310d0 ("Input: soc_button_array - add support for newer surface devices")
    BugLink: https://bugzilla.kernel.org/show_bug.cgi?id=205031
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Tested-by: Maximilian Luz <luzmaximilian@gmail.com>
    Acked-by: Maximilian Luz <luzmaximilian@gmail.com>
    Link: https://lore.kernel.org/r/20191005105551.353273-1-hdegoede@redhat.com
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/soc_button_array.c b/drivers/input/misc/soc_button_array.c
index 97e3639e99d0..08520b3a18b8 100644
--- a/drivers/input/misc/soc_button_array.c
+++ b/drivers/input/misc/soc_button_array.c
@@ -92,11 +92,18 @@ soc_button_device_create(struct platform_device *pdev,
 			continue;
 
 		gpio = soc_button_lookup_gpio(&pdev->dev, info->acpi_index);
-		if (gpio < 0 && gpio != -ENOENT) {
-			error = gpio;
-			goto err_free_mem;
-		} else if (!gpio_is_valid(gpio)) {
-			/* Skip GPIO if not present */
+		if (!gpio_is_valid(gpio)) {
+			/*
+			 * Skip GPIO if not present. Note we deliberately
+			 * ignore -EPROBE_DEFER errors here. On some devices
+			 * Intel is using so called virtual GPIOs which are not
+			 * GPIOs at all but some way for AML code to check some
+			 * random status bits without need a custom opregion.
+			 * In some cases the resources table we parse points to
+			 * such a virtual GPIO, since these are not real GPIOs
+			 * we do not have a driver for these so they will never
+			 * show up, therefore we ignore -EPROBE_DEFER.
+			 */
 			continue;
 		}
 

commit 53119e513478b3b5c2b81a9a049f52cf17fcfff3
Author: Enrico Weigelt <info@metux.net>
Date:   Tue Aug 20 12:08:43 2019 -0700

    Input: soc_button_array - use platform_device_register_resndata()
    
    The registration of gpio-keys device can be written much shorter
    by using the platform_device_register_resndata() helper.
    
    Signed-off-by: Enrico Weigelt <info@metux.net>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/soc_button_array.c b/drivers/input/misc/soc_button_array.c
index 6f0133fe1546..97e3639e99d0 100644
--- a/drivers/input/misc/soc_button_array.c
+++ b/drivers/input/misc/soc_button_array.c
@@ -120,25 +120,19 @@ soc_button_device_create(struct platform_device *pdev,
 	gpio_keys_pdata->nbuttons = n_buttons;
 	gpio_keys_pdata->rep = autorepeat;
 
-	pd = platform_device_alloc("gpio-keys", PLATFORM_DEVID_AUTO);
-	if (!pd) {
-		error = -ENOMEM;
+	pd = platform_device_register_resndata(&pdev->dev, "gpio-keys",
+					       PLATFORM_DEVID_AUTO, NULL, 0,
+					       gpio_keys_pdata,
+					       sizeof(*gpio_keys_pdata));
+	error = PTR_ERR_OR_ZERO(pd);
+	if (error) {
+		dev_err(&pdev->dev,
+			"failed registering gpio-keys: %d\n", error);
 		goto err_free_mem;
 	}
 
-	error = platform_device_add_data(pd, gpio_keys_pdata,
-					 sizeof(*gpio_keys_pdata));
-	if (error)
-		goto err_free_pdev;
-
-	error = platform_device_add(pd);
-	if (error)
-		goto err_free_pdev;
-
 	return pd;
 
-err_free_pdev:
-	platform_device_put(pd);
 err_free_mem:
 	devm_kfree(&pdev->dev, gpio_keys_pdata);
 	return ERR_PTR(error);

commit c394159310d02defcfe63c617f13b0c2974725c5
Author: Maximilian Luz <luzmaximilian@gmail.com>
Date:   Sat Jul 27 11:25:38 2019 +0300

    Input: soc_button_array - add support for newer surface devices
    
    Power and volume button support for 5th and 6th generation Microsoft
    Surface devices via soc_button_array.
    
    Note that these devices use the same MSHW0040 device as on the Surface
    Pro 4, however the implementation is different (GPIOs vs. ACPI
    notifications). Thus some checking is required to ensure we only load
    this driver on the correct devices.
    
    Signed-off-by: Maximilian Luz <luzmaximilian@gmail.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/soc_button_array.c b/drivers/input/misc/soc_button_array.c
index 5e59f8e57f8e..6f0133fe1546 100644
--- a/drivers/input/misc/soc_button_array.c
+++ b/drivers/input/misc/soc_button_array.c
@@ -25,6 +25,11 @@ struct soc_button_info {
 	bool wakeup;
 };
 
+struct soc_device_data {
+	const struct soc_button_info *button_info;
+	int (*check)(struct device *dev);
+};
+
 /*
  * Some of the buttons like volume up/down are auto repeat, while others
  * are not. To support both, we register two platform devices, and put
@@ -87,8 +92,13 @@ soc_button_device_create(struct platform_device *pdev,
 			continue;
 
 		gpio = soc_button_lookup_gpio(&pdev->dev, info->acpi_index);
-		if (!gpio_is_valid(gpio))
+		if (gpio < 0 && gpio != -ENOENT) {
+			error = gpio;
+			goto err_free_mem;
+		} else if (!gpio_is_valid(gpio)) {
+			/* Skip GPIO if not present */
 			continue;
+		}
 
 		gpio_keys[n_buttons].type = info->event_type;
 		gpio_keys[n_buttons].code = info->event_code;
@@ -309,23 +319,26 @@ static int soc_button_remove(struct platform_device *pdev)
 static int soc_button_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
-	const struct acpi_device_id *id;
-	struct soc_button_info *button_info;
+	const struct soc_device_data *device_data;
+	const struct soc_button_info *button_info;
 	struct soc_button_data *priv;
 	struct platform_device *pd;
 	int i;
 	int error;
 
-	id = acpi_match_device(dev->driver->acpi_match_table, dev);
-	if (!id)
-		return -ENODEV;
+	device_data = acpi_device_get_match_data(dev);
+	if (device_data && device_data->check) {
+		error = device_data->check(dev);
+		if (error)
+			return error;
+	}
 
-	if (!id->driver_data) {
+	if (device_data && device_data->button_info) {
+		button_info = device_data->button_info;
+	} else {
 		button_info = soc_button_get_button_info(dev);
 		if (IS_ERR(button_info))
 			return PTR_ERR(button_info);
-	} else {
-		button_info = (struct soc_button_info *)id->driver_data;
 	}
 
 	error = gpiod_count(dev, NULL);
@@ -357,7 +370,7 @@ static int soc_button_probe(struct platform_device *pdev)
 	if (!priv->children[0] && !priv->children[1])
 		return -ENODEV;
 
-	if (!id->driver_data)
+	if (!device_data || !device_data->button_info)
 		devm_kfree(dev, button_info);
 
 	return 0;
@@ -368,7 +381,7 @@ static int soc_button_probe(struct platform_device *pdev)
  * is defined in section 2.8.7.2 of "Windows ACPI Design Guide for SoC
  * Platforms"
  */
-static struct soc_button_info soc_button_PNP0C40[] = {
+static const struct soc_button_info soc_button_PNP0C40[] = {
 	{ "power", 0, EV_KEY, KEY_POWER, false, true },
 	{ "home", 1, EV_KEY, KEY_LEFTMETA, false, true },
 	{ "volume_up", 2, EV_KEY, KEY_VOLUMEUP, true, false },
@@ -377,9 +390,77 @@ static struct soc_button_info soc_button_PNP0C40[] = {
 	{ }
 };
 
+static const struct soc_device_data soc_device_PNP0C40 = {
+	.button_info = soc_button_PNP0C40,
+};
+
+/*
+ * Special device check for Surface Book 2 and Surface Pro (2017).
+ * Both, the Surface Pro 4 (surfacepro3_button.c) and the above mentioned
+ * devices use MSHW0040 for power and volume buttons, however the way they
+ * have to be addressed differs. Make sure that we only load this drivers
+ * for the correct devices by checking the OEM Platform Revision provided by
+ * the _DSM method.
+ */
+#define MSHW0040_DSM_REVISION		0x01
+#define MSHW0040_DSM_GET_OMPR		0x02	// get OEM Platform Revision
+static const guid_t MSHW0040_DSM_UUID =
+	GUID_INIT(0x6fd05c69, 0xcde3, 0x49f4, 0x95, 0xed, 0xab, 0x16, 0x65,
+		  0x49, 0x80, 0x35);
+
+static int soc_device_check_MSHW0040(struct device *dev)
+{
+	acpi_handle handle = ACPI_HANDLE(dev);
+	union acpi_object *result;
+	u64 oem_platform_rev = 0;	// valid revisions are nonzero
+
+	// get OEM platform revision
+	result = acpi_evaluate_dsm_typed(handle, &MSHW0040_DSM_UUID,
+					 MSHW0040_DSM_REVISION,
+					 MSHW0040_DSM_GET_OMPR, NULL,
+					 ACPI_TYPE_INTEGER);
+
+	if (result) {
+		oem_platform_rev = result->integer.value;
+		ACPI_FREE(result);
+	}
+
+	/*
+	 * If the revision is zero here, the _DSM evaluation has failed. This
+	 * indicates that we have a Pro 4 or Book 1 and this driver should not
+	 * be used.
+	 */
+	if (oem_platform_rev == 0)
+		return -ENODEV;
+
+	dev_dbg(dev, "OEM Platform Revision %llu\n", oem_platform_rev);
+
+	return 0;
+}
+
+/*
+ * Button infos for Microsoft Surface Book 2 and Surface Pro (2017).
+ * Obtained from DSDT/testing.
+ */
+static const struct soc_button_info soc_button_MSHW0040[] = {
+	{ "power", 0, EV_KEY, KEY_POWER, false, true },
+	{ "volume_up", 2, EV_KEY, KEY_VOLUMEUP, true, false },
+	{ "volume_down", 4, EV_KEY, KEY_VOLUMEDOWN, true, false },
+	{ }
+};
+
+static const struct soc_device_data soc_device_MSHW0040 = {
+	.button_info = soc_button_MSHW0040,
+	.check = soc_device_check_MSHW0040,
+};
+
 static const struct acpi_device_id soc_button_acpi_match[] = {
-	{ "PNP0C40", (unsigned long)soc_button_PNP0C40 },
+	{ "PNP0C40", (unsigned long)&soc_device_PNP0C40 },
 	{ "ACPI0011", 0 },
+
+	/* Microsoft Surface Devices (5th and 6th generation) */
+	{ "MSHW0040", (unsigned long)&soc_device_MSHW0040 },
+
 	{ }
 };
 

commit b886d83c5b621abc84ff9616f14c529be3f6b147
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:55 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 441
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2 of the license
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 315 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190115.503150771@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/input/misc/soc_button_array.c b/drivers/input/misc/soc_button_array.c
index bb458beecb43..5e59f8e57f8e 100644
--- a/drivers/input/misc/soc_button_array.c
+++ b/drivers/input/misc/soc_button_array.c
@@ -1,13 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Supports for the button array on SoC tablets originally running
  * Windows 8.
  *
  * (C) Copyright 2014 Intel Corporation
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; version 2
- * of the License.
  */
 
 #include <linux/module.h>

commit e9eb788f9442d1b5d93efdb30c3be071ce8a22b1
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Jan 3 18:10:45 2019 -0800

    Input: soc_button_array - fix mapping of the 5th GPIO in a PNP0C40 device
    
    The Microsoft documenation for the PNP0C40 device aka the
    "Windows-compatible button array" describes the 5th GpioInt listed in
    the resources as: '5. Interrupt corresponding to the "Rotation Lock"
    button, if supported'.
    
    Notice this describes the 5th entry as a button while we sofar have been
    mapping it to EV_SW, SW_ROTATE_LOCK. On my Point of View TAB P1006W-232
    which actually comes with a rotation-lock button, the button indeed is a
    button and not a slider/switch. An image search for other Windows tablets
    has found 2 more models with a rotation-lock button and on both of those
    it too is a push-button and not a slider/switch.
    
    Further evidence can be found in the HUT extension HUTRR52 from Microsoft
    which adds rotation lock support to the HUT, which describes 2 different
    usages: "0xC9 System Display Rotation Lock Button" and
    "0xCA System Display Rotation Lock Slider Switch" note that switch is seen
    as a separate thing here and the non switch wording is an exact match for
    the "Windows-compatible button array" spec wording.
    
    TL;DR: our current mapping of the 5th GPIO to SW_ROTATE_LOCK is wrong
    because the 5th GPIO is for a push-button not a switch.
    
    This commit fixes this by maping the 5th GPIO to KEY_ROTATE_LOCK_TOGGLE.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/soc_button_array.c b/drivers/input/misc/soc_button_array.c
index f53923b1593b..bb458beecb43 100644
--- a/drivers/input/misc/soc_button_array.c
+++ b/drivers/input/misc/soc_button_array.c
@@ -377,7 +377,7 @@ static struct soc_button_info soc_button_PNP0C40[] = {
 	{ "home", 1, EV_KEY, KEY_LEFTMETA, false, true },
 	{ "volume_up", 2, EV_KEY, KEY_VOLUMEUP, true, false },
 	{ "volume_down", 3, EV_KEY, KEY_VOLUMEDOWN, true, false },
-	{ "rotation_lock", 4, EV_SW, SW_ROTATE_LOCK, false, false },
+	{ "rotation_lock", 4, EV_KEY, KEY_ROTATE_LOCK_TOGGLE, false, false },
 	{ }
 };
 

commit 39be9b6d0455ed6dc6e9ac7252f56a498db5314e
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Jan 3 18:09:39 2019 -0800

    Input: soc_button_array - add usage-page 0x01 usage-id 0xca mapping
    
    The ACPI0011 _DSD button descriptor on a CHT based Intel Compute Sticks
    contains a mapping for usage-page 0x01 usage-id 0xca.
    
    As described in hutrr52_system_display_rotation_lock_controls_0.pdf this
    should be mapped as a "System Display Rotation Lock Slider Switch", this
    commit adds support for this, silencing the following warning:
    
    soc_button_array ACPI0011:00: Unknown button index 4 upage 01 usage ca,
    ignoring
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/soc_button_array.c b/drivers/input/misc/soc_button_array.c
index 23520df7650f..f53923b1593b 100644
--- a/drivers/input/misc/soc_button_array.c
+++ b/drivers/input/misc/soc_button_array.c
@@ -185,6 +185,10 @@ static int soc_button_parse_btn_desc(struct device *dev,
 		info->name = "power";
 		info->event_code = KEY_POWER;
 		info->wakeup = true;
+	} else if (upage == 0x01 && usage == 0xca) {
+		info->name = "rotation lock switch";
+		info->event_type = EV_SW;
+		info->event_code = SW_ROTATE_LOCK;
 	} else if (upage == 0x07 && usage == 0xe3) {
 		info->name = "home";
 		info->event_code = KEY_LEFTMETA;

commit d912366a59c5384df436fd007667d6e574128b44
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun Aug 20 09:29:03 2017 -0700

    Input: soc_button_array - silence -ENOENT error on Dell XPS13 9365
    
    The Dell XPS13 9365 has an INT33D2 ACPI node with no GPIOs, causing
    the following error in dmesg:
    
    [    7.172275] soc_button_array: probe of INT33D2:00 failed with error -2
    
    This commit silences this, by returning -ENODEV when there are no GPIOs.
    
    BugLink: https://bugzilla.kernel.org/show_bug.cgi?id=196679
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/soc_button_array.c b/drivers/input/misc/soc_button_array.c
index f600f3a7a3c6..23520df7650f 100644
--- a/drivers/input/misc/soc_button_array.c
+++ b/drivers/input/misc/soc_button_array.c
@@ -331,7 +331,7 @@ static int soc_button_probe(struct platform_device *pdev)
 	error = gpiod_count(dev, NULL);
 	if (error < 0) {
 		dev_dbg(dev, "no GPIO attached, ignoring...\n");
-		return error;
+		return -ENODEV;
 	}
 
 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);

commit 779f19ac9d5858a2c159030c0c166f7da46b74ae
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun Jun 18 15:10:26 2017 -0700

    Input: soc_button_array - fix leaking the ACPI button descriptor buffer
    
    We are passing a buffer with ACPI_ALLOCATE_BUFFER set to
    acpi_evaluate_object, so we must free it when we are done with it.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/soc_button_array.c b/drivers/input/misc/soc_button_array.c
index e37d37273182..f600f3a7a3c6 100644
--- a/drivers/input/misc/soc_button_array.c
+++ b/drivers/input/misc/soc_button_array.c
@@ -248,7 +248,8 @@ static struct soc_button_info *soc_button_get_button_info(struct device *dev)
 
 	if (!btns_desc) {
 		dev_err(dev, "ACPI Button Descriptors not found\n");
-		return ERR_PTR(-ENODEV);
+		button_info = ERR_PTR(-ENODEV);
+		goto out;
 	}
 
 	/* The first package describes the collection */
@@ -264,24 +265,31 @@ static struct soc_button_info *soc_button_get_button_info(struct device *dev)
 	}
 	if (collection_uid == -1) {
 		dev_err(dev, "Invalid Button Collection Descriptor\n");
-		return ERR_PTR(-ENODEV);
+		button_info = ERR_PTR(-ENODEV);
+		goto out;
 	}
 
 	/* There are package.count - 1 buttons + 1 terminating empty entry */
 	button_info = devm_kcalloc(dev, btns_desc->package.count,
 				   sizeof(*button_info), GFP_KERNEL);
-	if (!button_info)
-		return ERR_PTR(-ENOMEM);
+	if (!button_info) {
+		button_info = ERR_PTR(-ENOMEM);
+		goto out;
+	}
 
 	/* Parse the button descriptors */
 	for (i = 1, btn = 0; i < btns_desc->package.count; i++, btn++) {
 		if (soc_button_parse_btn_desc(dev,
 					      &btns_desc->package.elements[i],
 					      collection_uid,
-					      &button_info[btn]))
-			return ERR_PTR(-ENODEV);
+					      &button_info[btn])) {
+			button_info = ERR_PTR(-ENODEV);
+			goto out;
+		}
 	}
 
+out:
+	kfree(buf.pointer);
 	return button_info;
 }
 

commit 2bd80401743568ced7d303b008ae5298ce77e695
Merge: 99a7583de5ff b86c86aa9805
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 4 12:05:32 2017 -0700

    Merge tag 'gpio-v4.12-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull GPIO updates from Linus Walleij:
     "This is the bulk of GPIO changes for the v4.12 kernel cycle.
    
      Core changes:
    
       - Return NULL from gpiod_get_optional() when GPIOLIB is disabled.
         This was a much discussed change. It affects use cases where people
         write drivers that might or might not be using GPIO resources. I
         have decided that this is the lesser evil right now.
    
       - Make gpiod_count() behave consistently across different hardware
         descriptions.
    
       - Fix the syntax around open drain/open source to not infer active
         high/low semantics.
    
      New drivers:
    
       - A new single-register fixed-direction framework driver for hardware
         that have lines controlled by a single register that just work in
         one direction (out or in), including IRQ support.
    
       - Support the Fintek F71889A GPIO SuperIO controller.
    
       - Support the National NI 169445 MMIO GPIO.
    
       - Support for the X-Gene derivative of the DWC GPIO controller
    
       - Support for the Rohm BD9571MWV-M PMIC GPIO controller.
    
       - Refactor the Gemini GPIO driver to a generic Faraday FTGPIO driver
         and replace both the Gemini and the Moxa ART custom drivers with
         this driver.
    
      Driver improvements:
    
       - A whole slew of drivers have their spinlocks chaned to raw
         spinlocks as they provide irqchips, and thus we are progressing on
         realtime compliance.
    
       - Use devm_irq_alloc_descs() in a slew of drivers, getting managed
         resources.
    
       - Support for the embedded PWM controller inside the MVEBU driver.
    
       - Debounce, open source and open drain support for the Aspeed driver.
    
       - Misc smaller fixes like spelling and syntax and whatnot"
    
    * tag 'gpio-v4.12-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (77 commits)
      gpio: f7188x: Add a missing break
      gpio: omap: return error if requested debounce time is not possible
      gpio: Add ROHM BD9571MWV-M PMIC GPIO driver
      gpio: gpio-wcove: fix GPIO IRQ status mask
      gpio: DT bindings, move tca9554 from pcf857x to pca953x
      gpio: move tca9554 from pcf857x to pca953x
      gpio: arizona: Correct check whether the pin is an input
      gpio: Add XRA1403 DTS binding documentation
      dt-bindings: add exar to vendor prefixes list
      gpio: gpio-wcove: fix irq pending status bit width
      gpio: dwapb: use dwapb_read instead of readl_relaxed
      gpio: aspeed: Add open-source and open-drain support
      gpio: aspeed: Add debounce support
      gpio: aspeed: dt: Add optional clocks property
      gpio: aspeed: dt: Fix description alignment in bindings document
      gpio: mvebu: Add limited PWM support
      gpio: Use unsigned int for interrupt numbers
      gpio: f7188x: Add F71889A GPIO support.
      gpio: core: Decouple open drain/source flag with active low/high
      gpio: arizona: Correct handling for reading input GPIOs
      ...

commit dd224085d73ab04d14fe78a5fd9970fa808a60fb
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Mon Apr 10 20:34:19 2017 -0700

    Input: soc_button_array - properly map usage 0x07/0xe3 to KEY_LEFTMETA
    
    When submitting the support for the ACPI0011 windows tablet keys device I
    mapped the "windows" logo homekey to KEY_HOMEPAGE. But this is inconsistent
    with how it is done on windows tablets using the old PNP0C40 ACPI device
    and it does not match the HUT spec, which says that usage-page 7 usage 0xe3
    is "Keyboard Left GUI".
    
    This commit maps usage-page 7 usage 0xe3 to KEY_LEFTMETA fixing this.
    
    Fixes: 4c3362f44980 ("Input: soc_button_array - add support for ACPI 6.0...")
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/soc_button_array.c b/drivers/input/misc/soc_button_array.c
index 95b787a63560..f210a3322559 100644
--- a/drivers/input/misc/soc_button_array.c
+++ b/drivers/input/misc/soc_button_array.c
@@ -187,7 +187,7 @@ static int soc_button_parse_btn_desc(struct device *dev,
 		info->wakeup = true;
 	} else if (upage == 0x07 && usage == 0xe3) {
 		info->name = "home";
-		info->event_code = KEY_HOMEPAGE;
+		info->event_code = KEY_LEFTMETA;
 		info->wakeup = true;
 	} else if (upage == 0x0c && usage == 0xe9) {
 		info->name = "volume_up";

commit 4c3362f44980aba8e1e69cd6970effbd9f17dc69
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Mar 17 14:03:54 2017 -0700

    Input: soc_button_array - add support for ACPI 6.0 Generic Button Device
    
    Windows 10 tablets with gpio buttons will typically use the ACPI 6.0
    Generic Button Device with a HID of ACPI0011 for these buttons.
    
    The ACPI description for these in the ACPI0011 devices _DSD object uses
    something resembling HID descriptors, except that instead of indicating
    a bit index into a HID input report, the index indicates the _CRS index
    for the GPIO.
    
    The use of 1 interrupt per button, some of which need to be wakeup
    sources, instead of using input reports makes it impossible to use the
    HID subsystem for this.
    
    This really is just another gpio-keys input device with the platform
    data described in ACPI, so this commit adds parsing for this new way
    to describe gpio-keys to the soc_button_array driver.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/soc_button_array.c b/drivers/input/misc/soc_button_array.c
index b8769f6e3601..95b787a63560 100644
--- a/drivers/input/misc/soc_button_array.c
+++ b/drivers/input/misc/soc_button_array.c
@@ -138,6 +138,153 @@ soc_button_device_create(struct platform_device *pdev,
 	return ERR_PTR(error);
 }
 
+static int soc_button_get_acpi_object_int(const union acpi_object *obj)
+{
+	if (obj->type != ACPI_TYPE_INTEGER)
+		return -1;
+
+	return obj->integer.value;
+}
+
+/* Parse a single ACPI0011 _DSD button descriptor */
+static int soc_button_parse_btn_desc(struct device *dev,
+				     const union acpi_object *desc,
+				     int collection_uid,
+				     struct soc_button_info *info)
+{
+	int upage, usage;
+
+	if (desc->type != ACPI_TYPE_PACKAGE ||
+	    desc->package.count != 5 ||
+	    /* First byte should be 1 (control) */
+	    soc_button_get_acpi_object_int(&desc->package.elements[0]) != 1 ||
+	    /* Third byte should be collection uid */
+	    soc_button_get_acpi_object_int(&desc->package.elements[2]) !=
+							    collection_uid) {
+		dev_err(dev, "Invalid ACPI Button Descriptor\n");
+		return -ENODEV;
+	}
+
+	info->event_type = EV_KEY;
+	info->acpi_index =
+		soc_button_get_acpi_object_int(&desc->package.elements[1]);
+	upage = soc_button_get_acpi_object_int(&desc->package.elements[3]);
+	usage = soc_button_get_acpi_object_int(&desc->package.elements[4]);
+
+	/*
+	 * The UUID: fa6bd625-9ce8-470d-a2c7-b3ca36c4282e descriptors use HID
+	 * usage page and usage codes, but otherwise the device is not HID
+	 * compliant: it uses one irq per button instead of generating HID
+	 * input reports and some buttons should generate wakeups where as
+	 * others should not, so we cannot use the HID subsystem.
+	 *
+	 * Luckily all devices only use a few usage page + usage combinations,
+	 * so we can simply check for the known combinations here.
+	 */
+	if (upage == 0x01 && usage == 0x81) {
+		info->name = "power";
+		info->event_code = KEY_POWER;
+		info->wakeup = true;
+	} else if (upage == 0x07 && usage == 0xe3) {
+		info->name = "home";
+		info->event_code = KEY_HOMEPAGE;
+		info->wakeup = true;
+	} else if (upage == 0x0c && usage == 0xe9) {
+		info->name = "volume_up";
+		info->event_code = KEY_VOLUMEUP;
+		info->autorepeat = true;
+	} else if (upage == 0x0c && usage == 0xea) {
+		info->name = "volume_down";
+		info->event_code = KEY_VOLUMEDOWN;
+		info->autorepeat = true;
+	} else {
+		dev_warn(dev, "Unknown button index %d upage %02x usage %02x, ignoring\n",
+			 info->acpi_index, upage, usage);
+		info->name = "unknown";
+		info->event_code = KEY_RESERVED;
+	}
+
+	return 0;
+}
+
+/* ACPI0011 _DSD btns descriptors UUID: fa6bd625-9ce8-470d-a2c7-b3ca36c4282e */
+static const u8 btns_desc_uuid[16] = {
+	0x25, 0xd6, 0x6b, 0xfa, 0xe8, 0x9c, 0x0d, 0x47,
+	0xa2, 0xc7, 0xb3, 0xca, 0x36, 0xc4, 0x28, 0x2e
+};
+
+/* Parse ACPI0011 _DSD button descriptors */
+static struct soc_button_info *soc_button_get_button_info(struct device *dev)
+{
+	struct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };
+	const union acpi_object *desc, *el0, *uuid, *btns_desc = NULL;
+	struct soc_button_info *button_info;
+	acpi_status status;
+	int i, btn, collection_uid = -1;
+
+	status = acpi_evaluate_object_typed(ACPI_HANDLE(dev), "_DSD", NULL,
+					    &buf, ACPI_TYPE_PACKAGE);
+	if (ACPI_FAILURE(status)) {
+		dev_err(dev, "ACPI _DSD object not found\n");
+		return ERR_PTR(-ENODEV);
+	}
+
+	/* Look for the Button Descriptors UUID */
+	desc = buf.pointer;
+	for (i = 0; (i + 1) < desc->package.count; i += 2) {
+		uuid = &desc->package.elements[i];
+
+		if (uuid->type != ACPI_TYPE_BUFFER ||
+		    uuid->buffer.length != 16 ||
+		    desc->package.elements[i + 1].type != ACPI_TYPE_PACKAGE) {
+			break;
+		}
+
+		if (memcmp(uuid->buffer.pointer, btns_desc_uuid, 16) == 0) {
+			btns_desc = &desc->package.elements[i + 1];
+			break;
+		}
+	}
+
+	if (!btns_desc) {
+		dev_err(dev, "ACPI Button Descriptors not found\n");
+		return ERR_PTR(-ENODEV);
+	}
+
+	/* The first package describes the collection */
+	el0 = &btns_desc->package.elements[0];
+	if (el0->type == ACPI_TYPE_PACKAGE &&
+	    el0->package.count == 5 &&
+	    /* First byte should be 0 (collection) */
+	    soc_button_get_acpi_object_int(&el0->package.elements[0]) == 0 &&
+	    /* Third byte should be 0 (top level collection) */
+	    soc_button_get_acpi_object_int(&el0->package.elements[2]) == 0) {
+		collection_uid = soc_button_get_acpi_object_int(
+						&el0->package.elements[1]);
+	}
+	if (collection_uid == -1) {
+		dev_err(dev, "Invalid Button Collection Descriptor\n");
+		return ERR_PTR(-ENODEV);
+	}
+
+	/* There are package.count - 1 buttons + 1 terminating empty entry */
+	button_info = devm_kcalloc(dev, btns_desc->package.count,
+				   sizeof(*button_info), GFP_KERNEL);
+	if (!button_info)
+		return ERR_PTR(-ENOMEM);
+
+	/* Parse the button descriptors */
+	for (i = 1, btn = 0; i < btns_desc->package.count; i++, btn++) {
+		if (soc_button_parse_btn_desc(dev,
+					      &btns_desc->package.elements[i],
+					      collection_uid,
+					      &button_info[btn]))
+			return ERR_PTR(-ENODEV);
+	}
+
+	return button_info;
+}
+
 static int soc_button_remove(struct platform_device *pdev)
 {
 	struct soc_button_data *priv = platform_get_drvdata(pdev);
@@ -165,7 +312,13 @@ static int soc_button_probe(struct platform_device *pdev)
 	if (!id)
 		return -ENODEV;
 
-	button_info = (struct soc_button_info *)id->driver_data;
+	if (!id->driver_data) {
+		button_info = soc_button_get_button_info(dev);
+		if (IS_ERR(button_info))
+			return PTR_ERR(button_info);
+	} else {
+		button_info = (struct soc_button_info *)id->driver_data;
+	}
 
 	if (gpiod_count(dev, NULL) <= 0) {
 		dev_dbg(dev, "no GPIO attached, ignoring...\n");
@@ -195,6 +348,9 @@ static int soc_button_probe(struct platform_device *pdev)
 	if (!priv->children[0] && !priv->children[1])
 		return -ENODEV;
 
+	if (!id->driver_data)
+		devm_kfree(dev, button_info);
+
 	return 0;
 }
 
@@ -214,6 +370,7 @@ static struct soc_button_info soc_button_PNP0C40[] = {
 
 static const struct acpi_device_id soc_button_acpi_match[] = {
 	{ "PNP0C40", (unsigned long)soc_button_PNP0C40 },
+	{ "ACPI0011", 0 },
 	{ }
 };
 

commit 7283b47d5d4d8e6528a08dc6c7ac6ff7cfed66d9
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Mar 17 14:03:28 2017 -0700

    Input: soc_button_array - get rid of MAX_NBUTTONS
    
    Count how much gpio_keys we actually need, this is a preparation patch
    for adding support for the new Win10 / ACPI-6.0 "Generic Buttons Device"
    support.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/soc_button_array.c b/drivers/input/misc/soc_button_array.c
index 0cd2cac47660..b8769f6e3601 100644
--- a/drivers/input/misc/soc_button_array.c
+++ b/drivers/input/misc/soc_button_array.c
@@ -20,13 +20,6 @@
 #include <linux/gpio.h>
 #include <linux/platform_device.h>
 
-/*
- * Definition of buttons on the tablet. The ACPI index of each button
- * is defined in section 2.8.7.2 of "Windows ACPI Design Guide for SoC
- * Platforms"
- */
-#define MAX_NBUTTONS	5
-
 struct soc_button_info {
 	const char *name;
 	int acpi_index;
@@ -79,14 +72,19 @@ soc_button_device_create(struct platform_device *pdev,
 	int gpio;
 	int error;
 
+	for (info = button_info; info->name; info++)
+		if (info->autorepeat == autorepeat)
+			n_buttons++;
+
 	gpio_keys_pdata = devm_kzalloc(&pdev->dev,
 				       sizeof(*gpio_keys_pdata) +
-					sizeof(*gpio_keys) * MAX_NBUTTONS,
+					sizeof(*gpio_keys) * n_buttons,
 				       GFP_KERNEL);
 	if (!gpio_keys_pdata)
 		return ERR_PTR(-ENOMEM);
 
 	gpio_keys = (void *)(gpio_keys_pdata + 1);
+	n_buttons = 0;
 
 	for (info = button_info; info->name; info++) {
 		if (info->autorepeat != autorepeat)
@@ -200,6 +198,11 @@ static int soc_button_probe(struct platform_device *pdev)
 	return 0;
 }
 
+/*
+ * Definition of buttons on the tablet. The ACPI index of each button
+ * is defined in section 2.8.7.2 of "Windows ACPI Design Guide for SoC
+ * Platforms"
+ */
 static struct soc_button_info soc_button_PNP0C40[] = {
 	{ "power", 0, EV_KEY, KEY_POWER, false, true },
 	{ "home", 1, EV_KEY, KEY_LEFTMETA, false, true },

commit c5097538c86a60c655f7fac33dfd565d22909dae
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Feb 20 18:15:49 2017 +0200

    Input: soc_button_array - Propagate error from gpiod_count()
    
    Since gpiod_count() does not return 0 anymore, we don't need to shadow
    its error code and would safely propagate to the user.
    
    While here, replace second parameter by NULL in order to prevent side
    effects on _DSD enabled firmware.
    
    Cc: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/input/misc/soc_button_array.c b/drivers/input/misc/soc_button_array.c
index ddb2f22fca7a..c3b8e1fb4699 100644
--- a/drivers/input/misc/soc_button_array.c
+++ b/drivers/input/misc/soc_button_array.c
@@ -169,9 +169,10 @@ static int soc_button_probe(struct platform_device *pdev)
 
 	button_info = (struct soc_button_info *)id->driver_data;
 
-	if (gpiod_count(dev, KBUILD_MODNAME) <= 0) {
+	error = gpiod_count(dev, NULL);
+	if (error < 0) {
 		dev_dbg(dev, "no GPIO attached, ignoring...\n");
-		return -ENODEV;
+		return error;
 	}
 
 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);

commit a01cd17000a4eb35060666f181f1d46832b59030
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Mar 9 09:58:30 2017 -0800

    Input: soc_button_array - use NULL for GPIO connection ID
    
    The gpiolib-acpi code is becoming more strict and connection-IDs
    may only be used with devices which have a _DSD with matching IDs
    in there. Since the soc_button_array ACPI binding is pure index
    based pass in NULL as connection-ID to avoid the more strict cheks
    resulting in gpiod_count and gpiod_get_index not returning any gpios.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/soc_button_array.c b/drivers/input/misc/soc_button_array.c
index ddb2f22fca7a..0cd2cac47660 100644
--- a/drivers/input/misc/soc_button_array.c
+++ b/drivers/input/misc/soc_button_array.c
@@ -55,7 +55,7 @@ static int soc_button_lookup_gpio(struct device *dev, int acpi_index)
 	struct gpio_desc *desc;
 	int gpio;
 
-	desc = gpiod_get_index(dev, KBUILD_MODNAME, acpi_index, GPIOD_ASIS);
+	desc = gpiod_get_index(dev, NULL, acpi_index, GPIOD_ASIS);
 	if (IS_ERR(desc))
 		return PTR_ERR(desc);
 
@@ -169,7 +169,7 @@ static int soc_button_probe(struct platform_device *pdev)
 
 	button_info = (struct soc_button_info *)id->driver_data;
 
-	if (gpiod_count(dev, KBUILD_MODNAME) <= 0) {
+	if (gpiod_count(dev, NULL) <= 0) {
 		dev_dbg(dev, "no GPIO attached, ignoring...\n");
 		return -ENODEV;
 	}

commit 5c4fa2a6da7fbc76290d1cb54a7e35633517a522
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat Jan 21 11:14:14 2017 -0800

    Input: soc_button_array - debounce the buttons
    
    The soc_button_array driver was initializing (kzalloc) the
    debounce_interval value to 0, leading to no debouncing at all,
    while the buttons are simple mechanical switches.
    
    This commit sets debounce_interval to 50ms to avoid spurious button
    press reports both on press and release of the button. Note 50ms may
    seem like a lot but soc_button_array is typically used with cheap
    tablets, with not so great buttons. I tried 10ms on my tablet and it
    is not enough, where as 50ms works well.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/soc_button_array.c b/drivers/input/misc/soc_button_array.c
index fb3219a8d3c0..ddb2f22fca7a 100644
--- a/drivers/input/misc/soc_button_array.c
+++ b/drivers/input/misc/soc_button_array.c
@@ -102,6 +102,8 @@ soc_button_device_create(struct platform_device *pdev,
 		gpio_keys[n_buttons].active_low = 1;
 		gpio_keys[n_buttons].desc = info->name;
 		gpio_keys[n_buttons].wakeup = info->wakeup;
+		/* These devices often use cheap buttons, use 50 ms debounce */
+		gpio_keys[n_buttons].debounce_interval = 50;
 		n_buttons++;
 	}
 

commit aa45590ae8581e25b909f2fed591c3499cd8e352
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Wed Jan 18 11:41:51 2017 -0800

    Input: soc_button_array - use 'dev' instead of dereferencing it
    
    Use local variable 'dev' instead of dereferencing it several times.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/soc_button_array.c b/drivers/input/misc/soc_button_array.c
index 908b51089dee..fb3219a8d3c0 100644
--- a/drivers/input/misc/soc_button_array.c
+++ b/drivers/input/misc/soc_button_array.c
@@ -167,12 +167,12 @@ static int soc_button_probe(struct platform_device *pdev)
 
 	button_info = (struct soc_button_info *)id->driver_data;
 
-	if (gpiod_count(&pdev->dev, KBUILD_MODNAME) <= 0) {
-		dev_dbg(&pdev->dev, "no GPIO attached, ignoring...\n");
+	if (gpiod_count(dev, KBUILD_MODNAME) <= 0) {
+		dev_dbg(dev, "no GPIO attached, ignoring...\n");
 		return -ENODEV;
 	}
 
-	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
 

commit 3d5a9437a68a184fbbd0dcf09bf4daf40250505e
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Fri Nov 25 11:36:01 2016 -0800

    Input: soc_button_array - bail out earlier if gpiod_count is zero
    
    The PNP0C40 device of the Surface 3 doesn't have any GPIO attached to it.
    Instead of trying to access the GPIO, request the count beforehand and
    bail out if it is null or if an error is returned.
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/soc_button_array.c b/drivers/input/misc/soc_button_array.c
index bbd433c4a5aa..908b51089dee 100644
--- a/drivers/input/misc/soc_button_array.c
+++ b/drivers/input/misc/soc_button_array.c
@@ -167,6 +167,11 @@ static int soc_button_probe(struct platform_device *pdev)
 
 	button_info = (struct soc_button_info *)id->driver_data;
 
+	if (gpiod_count(&pdev->dev, KBUILD_MODNAME) <= 0) {
+		dev_dbg(&pdev->dev, "no GPIO attached, ignoring...\n");
+		return -ENODEV;
+	}
+
 	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;

commit be8e7a7ec876d509bc61af64b41b314a142aa262
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Fri Nov 25 11:20:43 2016 -0800

    Input: soc_button_array - use gpio_is_valid()
    
    gpio_keys will later use gpio_is_valid(). To match the actual
    behavior, we should use it here too.
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/soc_button_array.c b/drivers/input/misc/soc_button_array.c
index c14b82709b0f..bbd433c4a5aa 100644
--- a/drivers/input/misc/soc_button_array.c
+++ b/drivers/input/misc/soc_button_array.c
@@ -17,6 +17,7 @@
 #include <linux/acpi.h>
 #include <linux/gpio/consumer.h>
 #include <linux/gpio_keys.h>
+#include <linux/gpio.h>
 #include <linux/platform_device.h>
 
 /*
@@ -92,7 +93,7 @@ soc_button_device_create(struct platform_device *pdev,
 			continue;
 
 		gpio = soc_button_lookup_gpio(&pdev->dev, info->acpi_index);
-		if (gpio < 0)
+		if (!gpio_is_valid(gpio))
 			continue;
 
 		gpio_keys[n_buttons].type = info->event_type;

commit 6dd063353f9317955a67bc23249eac43128f7ff7
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Thu Apr 16 13:38:00 2015 -0700

    Input: soc_button_array - remove duplicated include
    
    Remove duplicated include for acpi.h.
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/soc_button_array.c b/drivers/input/misc/soc_button_array.c
index e8e010a85484..c14b82709b0f 100644
--- a/drivers/input/misc/soc_button_array.c
+++ b/drivers/input/misc/soc_button_array.c
@@ -18,7 +18,6 @@
 #include <linux/gpio/consumer.h>
 #include <linux/gpio_keys.h>
 #include <linux/platform_device.h>
-#include <linux/acpi.h>
 
 /*
  * Definition of buttons on the tablet. The ACPI index of each button

commit 791738be57473fddaf393dcedcef31b577231aaa
Author: Bastien Nocera <hadess@hadess.net>
Date:   Tue Feb 10 15:42:21 2015 -0800

    Input: soc_button_array - use "Windows" key for "Home"
    
    KEY_HOME is the key to go back to the beginning of the line, not the key to
    get into an overview mode, as Windows does. GNOME can already make use of
    the Windows key on multiple form factors, and other desktop environments
    can use it depending on the form factor.
    
    Using "Windows" as the emitted key also means that the keycode sent out
    matches the symbol on the key itself.
    
    So switch KEY_HOME to KEY_LEFTMETA ("Windows" key).
    
    Signed-off-by: Bastien Nocera <hadess@hadess.net>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/soc_button_array.c b/drivers/input/misc/soc_button_array.c
index 79cc0f79896f..e8e010a85484 100644
--- a/drivers/input/misc/soc_button_array.c
+++ b/drivers/input/misc/soc_button_array.c
@@ -195,7 +195,7 @@ static int soc_button_probe(struct platform_device *pdev)
 
 static struct soc_button_info soc_button_PNP0C40[] = {
 	{ "power", 0, EV_KEY, KEY_POWER, false, true },
-	{ "home", 1, EV_KEY, KEY_HOME, false, true },
+	{ "home", 1, EV_KEY, KEY_LEFTMETA, false, true },
 	{ "volume_up", 2, EV_KEY, KEY_VOLUMEUP, true, false },
 	{ "volume_down", 3, EV_KEY, KEY_VOLUMEDOWN, true, false },
 	{ "rotation_lock", 4, EV_SW, SW_ROTATE_LOCK, false, false },

commit a8a93c6f9922c0d70459668c1300b226cb3918ab
Merge: 0df1f2487d2f 79cd17629331
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 3 19:53:56 2014 -0800

    Merge branch 'platform/remove_owner' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux into driver-core-next
    
    Remove all .owner fields from platform drivers

commit 4668546f99df6413be19d370c448c6b4b37fb5bc
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Thu Oct 23 08:53:13 2014 -0700

    Input: soc_button_array - update calls to gpiod_get*()
    
    Add the new flags argument to calls of (devm_)gpiod_get*().
    
    Currently both forms (with or without the flags argument) are valid thanks
    to transitional macros in <linux/gpio/consumer.h>. These macros will be
    removed once all consumers are updated and the flags argument will become
    compulsory.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/soc_button_array.c b/drivers/input/misc/soc_button_array.c
index 735604753568..e097f1ab427f 100644
--- a/drivers/input/misc/soc_button_array.c
+++ b/drivers/input/misc/soc_button_array.c
@@ -55,7 +55,7 @@ static int soc_button_lookup_gpio(struct device *dev, int acpi_index)
 	struct gpio_desc *desc;
 	int gpio;
 
-	desc = gpiod_get_index(dev, KBUILD_MODNAME, acpi_index);
+	desc = gpiod_get_index(dev, KBUILD_MODNAME, acpi_index, GPIOD_ASIS);
 	if (IS_ERR(desc))
 		return PTR_ERR(desc);
 

commit 776bd315a7721574d7d687dd9abf200735d12a2a
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:20:40 2014 +0200

    input: misc: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/input/misc/soc_button_array.c b/drivers/input/misc/soc_button_array.c
index 735604753568..e9e4d6a6741e 100644
--- a/drivers/input/misc/soc_button_array.c
+++ b/drivers/input/misc/soc_button_array.c
@@ -214,7 +214,6 @@ static struct platform_driver soc_button_driver = {
 	.remove		= soc_button_remove,
 	.driver		= {
 		.name = KBUILD_MODNAME,
-		.owner = THIS_MODULE,
 		.acpi_match_table = ACPI_PTR(soc_button_acpi_match),
 	},
 };

commit 042e1c79166b9250edd8262bea84e1703f27ad2e
Author: Jin Yao <yao.jin@linux.intel.com>
Date:   Mon Sep 22 10:31:14 2014 -0700

    Input: soc_button_array - convert to platform bus
    
    ACPI device enumeration mechanism changed a lot since 3.16-rc1.
    ACPI device objects with _HID will be enumerated to platform bus by default.
    For the existing PNP drivers that probe the PNPACPI devices, the device ids
    are listed explicitly in drivers/acpi/acpi_pnp.c.
    But ACPI folks will continue their effort on shrinking this id list by
    converting the PNP drivers to platform drivers, for the devices that don't
    belong to PNP bus in nature.
    
    Signed-off-by: Jin Yao <yao.jin@intel.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/soc_button_array.c b/drivers/input/misc/soc_button_array.c
index e34dfc29beb3..735604753568 100644
--- a/drivers/input/misc/soc_button_array.c
+++ b/drivers/input/misc/soc_button_array.c
@@ -18,7 +18,7 @@
 #include <linux/gpio/consumer.h>
 #include <linux/gpio_keys.h>
 #include <linux/platform_device.h>
-#include <linux/pnp.h>
+#include <linux/acpi.h>
 
 /*
  * Definition of buttons on the tablet. The ACPI index of each button
@@ -67,7 +67,7 @@ static int soc_button_lookup_gpio(struct device *dev, int acpi_index)
 }
 
 static struct platform_device *
-soc_button_device_create(struct pnp_dev *pdev,
+soc_button_device_create(struct platform_device *pdev,
 			 const struct soc_button_info *button_info,
 			 bool autorepeat)
 {
@@ -138,30 +138,40 @@ soc_button_device_create(struct pnp_dev *pdev,
 	return ERR_PTR(error);
 }
 
-static void soc_button_remove(struct pnp_dev *pdev)
+static int soc_button_remove(struct platform_device *pdev)
 {
-	struct soc_button_data *priv = pnp_get_drvdata(pdev);
+	struct soc_button_data *priv = platform_get_drvdata(pdev);
+
 	int i;
 
 	for (i = 0; i < BUTTON_TYPES; i++)
 		if (priv->children[i])
 			platform_device_unregister(priv->children[i]);
+
+	return 0;
 }
 
-static int soc_button_pnp_probe(struct pnp_dev *pdev,
-				const struct pnp_device_id *id)
+static int soc_button_probe(struct platform_device *pdev)
 {
-	const struct soc_button_info *button_info = (void *)id->driver_data;
+	struct device *dev = &pdev->dev;
+	const struct acpi_device_id *id;
+	struct soc_button_info *button_info;
 	struct soc_button_data *priv;
 	struct platform_device *pd;
 	int i;
 	int error;
 
+	id = acpi_match_device(dev->driver->acpi_match_table, dev);
+	if (!id)
+		return -ENODEV;
+
+	button_info = (struct soc_button_info *)id->driver_data;
+
 	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
 
-	pnp_set_drvdata(pdev, priv);
+	platform_set_drvdata(pdev, priv);
 
 	for (i = 0; i < BUTTON_TYPES; i++) {
 		pd = soc_button_device_create(pdev, button_info, i == 0);
@@ -192,30 +202,22 @@ static struct soc_button_info soc_button_PNP0C40[] = {
 	{ }
 };
 
-static const struct pnp_device_id soc_button_pnp_match[] = {
-	{ .id = "PNP0C40", .driver_data = (long)soc_button_PNP0C40 },
-	{ .id = "" }
+static const struct acpi_device_id soc_button_acpi_match[] = {
+	{ "PNP0C40", (unsigned long)soc_button_PNP0C40 },
+	{ }
 };
-MODULE_DEVICE_TABLE(pnp, soc_button_pnp_match);
 
-static struct pnp_driver soc_button_pnp_driver = {
-	.name		= KBUILD_MODNAME,
-	.id_table	= soc_button_pnp_match,
-	.probe          = soc_button_pnp_probe,
+MODULE_DEVICE_TABLE(acpi, soc_button_acpi_match);
+
+static struct platform_driver soc_button_driver = {
+	.probe          = soc_button_probe,
 	.remove		= soc_button_remove,
+	.driver		= {
+		.name = KBUILD_MODNAME,
+		.owner = THIS_MODULE,
+		.acpi_match_table = ACPI_PTR(soc_button_acpi_match),
+	},
 };
-
-static int __init soc_button_init(void)
-{
-	return pnp_register_driver(&soc_button_pnp_driver);
-}
-
-static void __exit soc_button_exit(void)
-{
-	pnp_unregister_driver(&soc_button_pnp_driver);
-}
-
-module_init(soc_button_init);
-module_exit(soc_button_exit);
+module_platform_driver(soc_button_driver);
 
 MODULE_LICENSE("GPL");

commit 91cf07cdaedbc29d03f572a1b0e5cf41ee6febab
Author: Pramod Gurav <pramod.gurav@smartplayin.com>
Date:   Fri Jul 25 18:41:39 2014 -0700

    Input: soc_button_array - add missing memory allocation check
    
    Signed-off-by: Pramod Gurav <pramod.gurav@smartplayin.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/soc_button_array.c b/drivers/input/misc/soc_button_array.c
index 5a6334be30b8..e34dfc29beb3 100644
--- a/drivers/input/misc/soc_button_array.c
+++ b/drivers/input/misc/soc_button_array.c
@@ -83,6 +83,9 @@ soc_button_device_create(struct pnp_dev *pdev,
 				       sizeof(*gpio_keys_pdata) +
 					sizeof(*gpio_keys) * MAX_NBUTTONS,
 				       GFP_KERNEL);
+	if (!gpio_keys_pdata)
+		return ERR_PTR(-ENOMEM);
+
 	gpio_keys = (void *)(gpio_keys_pdata + 1);
 
 	for (info = button_info; info->name; info++) {

commit 3e582979e41996c71afc843a0edcec1a2962f89f
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Wed May 28 09:34:25 2014 -0700

    Input: soc_button_array - remove duplicate inclusion of input.h
    
    input.h was included twice.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/soc_button_array.c b/drivers/input/misc/soc_button_array.c
index 20c80f543d5e..5a6334be30b8 100644
--- a/drivers/input/misc/soc_button_array.c
+++ b/drivers/input/misc/soc_button_array.c
@@ -17,7 +17,6 @@
 #include <linux/acpi.h>
 #include <linux/gpio/consumer.h>
 #include <linux/gpio_keys.h>
-#include <linux/input.h>
 #include <linux/platform_device.h>
 #include <linux/pnp.h>
 

commit 7740fc52105c9e6d2beac389a9ae0ce7138cf5ab
Author: Lejun Zhu <lejun.zhu@linux.intel.com>
Date:   Tue Apr 22 22:47:13 2014 -0700

    Input: soc_button_array - fix a crash during rmmod
    
    When the system has zero or one button available, trying to rmmod
    soc_button_array will cause crash. Fix this by properly handling -ENODEV
    in probe().
    
    Signed-off-by: Lejun Zhu <lejun.zhu@linux.intel.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/soc_button_array.c b/drivers/input/misc/soc_button_array.c
index 08ead2aaede5..20c80f543d5e 100644
--- a/drivers/input/misc/soc_button_array.c
+++ b/drivers/input/misc/soc_button_array.c
@@ -169,6 +169,7 @@ static int soc_button_pnp_probe(struct pnp_dev *pdev,
 				soc_button_remove(pdev);
 				return error;
 			}
+			continue;
 		}
 
 		priv->children[i] = pd;

commit 61cd4822dd810e1a3c28eab1af6005728906c0e4
Author: Lejun Zhu <lejun.zhu@linux.intel.com>
Date:   Sun Mar 30 23:12:00 2014 -0700

    Input: add driver for SOC button array
    
    This patch adds support for the GPIO buttons on some Intel Bay Trail
    tablets originally running Windows 8. The ACPI description of these
    buttons follows "Windows ACPI Design Guide for SoC Platforms".
    
    Signed-off-by: Lejun Zhu <lejun.zhu@linux.intel.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/soc_button_array.c b/drivers/input/misc/soc_button_array.c
new file mode 100644
index 000000000000..08ead2aaede5
--- /dev/null
+++ b/drivers/input/misc/soc_button_array.c
@@ -0,0 +1,218 @@
+/*
+ * Supports for the button array on SoC tablets originally running
+ * Windows 8.
+ *
+ * (C) Copyright 2014 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/acpi.h>
+#include <linux/gpio/consumer.h>
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+#include <linux/pnp.h>
+
+/*
+ * Definition of buttons on the tablet. The ACPI index of each button
+ * is defined in section 2.8.7.2 of "Windows ACPI Design Guide for SoC
+ * Platforms"
+ */
+#define MAX_NBUTTONS	5
+
+struct soc_button_info {
+	const char *name;
+	int acpi_index;
+	unsigned int event_type;
+	unsigned int event_code;
+	bool autorepeat;
+	bool wakeup;
+};
+
+/*
+ * Some of the buttons like volume up/down are auto repeat, while others
+ * are not. To support both, we register two platform devices, and put
+ * buttons into them based on whether the key should be auto repeat.
+ */
+#define BUTTON_TYPES	2
+
+struct soc_button_data {
+	struct platform_device *children[BUTTON_TYPES];
+};
+
+/*
+ * Get the Nth GPIO number from the ACPI object.
+ */
+static int soc_button_lookup_gpio(struct device *dev, int acpi_index)
+{
+	struct gpio_desc *desc;
+	int gpio;
+
+	desc = gpiod_get_index(dev, KBUILD_MODNAME, acpi_index);
+	if (IS_ERR(desc))
+		return PTR_ERR(desc);
+
+	gpio = desc_to_gpio(desc);
+
+	gpiod_put(desc);
+
+	return gpio;
+}
+
+static struct platform_device *
+soc_button_device_create(struct pnp_dev *pdev,
+			 const struct soc_button_info *button_info,
+			 bool autorepeat)
+{
+	const struct soc_button_info *info;
+	struct platform_device *pd;
+	struct gpio_keys_button *gpio_keys;
+	struct gpio_keys_platform_data *gpio_keys_pdata;
+	int n_buttons = 0;
+	int gpio;
+	int error;
+
+	gpio_keys_pdata = devm_kzalloc(&pdev->dev,
+				       sizeof(*gpio_keys_pdata) +
+					sizeof(*gpio_keys) * MAX_NBUTTONS,
+				       GFP_KERNEL);
+	gpio_keys = (void *)(gpio_keys_pdata + 1);
+
+	for (info = button_info; info->name; info++) {
+		if (info->autorepeat != autorepeat)
+			continue;
+
+		gpio = soc_button_lookup_gpio(&pdev->dev, info->acpi_index);
+		if (gpio < 0)
+			continue;
+
+		gpio_keys[n_buttons].type = info->event_type;
+		gpio_keys[n_buttons].code = info->event_code;
+		gpio_keys[n_buttons].gpio = gpio;
+		gpio_keys[n_buttons].active_low = 1;
+		gpio_keys[n_buttons].desc = info->name;
+		gpio_keys[n_buttons].wakeup = info->wakeup;
+		n_buttons++;
+	}
+
+	if (n_buttons == 0) {
+		error = -ENODEV;
+		goto err_free_mem;
+	}
+
+	gpio_keys_pdata->buttons = gpio_keys;
+	gpio_keys_pdata->nbuttons = n_buttons;
+	gpio_keys_pdata->rep = autorepeat;
+
+	pd = platform_device_alloc("gpio-keys", PLATFORM_DEVID_AUTO);
+	if (!pd) {
+		error = -ENOMEM;
+		goto err_free_mem;
+	}
+
+	error = platform_device_add_data(pd, gpio_keys_pdata,
+					 sizeof(*gpio_keys_pdata));
+	if (error)
+		goto err_free_pdev;
+
+	error = platform_device_add(pd);
+	if (error)
+		goto err_free_pdev;
+
+	return pd;
+
+err_free_pdev:
+	platform_device_put(pd);
+err_free_mem:
+	devm_kfree(&pdev->dev, gpio_keys_pdata);
+	return ERR_PTR(error);
+}
+
+static void soc_button_remove(struct pnp_dev *pdev)
+{
+	struct soc_button_data *priv = pnp_get_drvdata(pdev);
+	int i;
+
+	for (i = 0; i < BUTTON_TYPES; i++)
+		if (priv->children[i])
+			platform_device_unregister(priv->children[i]);
+}
+
+static int soc_button_pnp_probe(struct pnp_dev *pdev,
+				const struct pnp_device_id *id)
+{
+	const struct soc_button_info *button_info = (void *)id->driver_data;
+	struct soc_button_data *priv;
+	struct platform_device *pd;
+	int i;
+	int error;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	pnp_set_drvdata(pdev, priv);
+
+	for (i = 0; i < BUTTON_TYPES; i++) {
+		pd = soc_button_device_create(pdev, button_info, i == 0);
+		if (IS_ERR(pd)) {
+			error = PTR_ERR(pd);
+			if (error != -ENODEV) {
+				soc_button_remove(pdev);
+				return error;
+			}
+		}
+
+		priv->children[i] = pd;
+	}
+
+	if (!priv->children[0] && !priv->children[1])
+		return -ENODEV;
+
+	return 0;
+}
+
+static struct soc_button_info soc_button_PNP0C40[] = {
+	{ "power", 0, EV_KEY, KEY_POWER, false, true },
+	{ "home", 1, EV_KEY, KEY_HOME, false, true },
+	{ "volume_up", 2, EV_KEY, KEY_VOLUMEUP, true, false },
+	{ "volume_down", 3, EV_KEY, KEY_VOLUMEDOWN, true, false },
+	{ "rotation_lock", 4, EV_SW, SW_ROTATE_LOCK, false, false },
+	{ }
+};
+
+static const struct pnp_device_id soc_button_pnp_match[] = {
+	{ .id = "PNP0C40", .driver_data = (long)soc_button_PNP0C40 },
+	{ .id = "" }
+};
+MODULE_DEVICE_TABLE(pnp, soc_button_pnp_match);
+
+static struct pnp_driver soc_button_pnp_driver = {
+	.name		= KBUILD_MODNAME,
+	.id_table	= soc_button_pnp_match,
+	.probe          = soc_button_pnp_probe,
+	.remove		= soc_button_remove,
+};
+
+static int __init soc_button_init(void)
+{
+	return pnp_register_driver(&soc_button_pnp_driver);
+}
+
+static void __exit soc_button_exit(void)
+{
+	pnp_unregister_driver(&soc_button_pnp_driver);
+}
+
+module_init(soc_button_init);
+module_exit(soc_button_exit);
+
+MODULE_LICENSE("GPL");
