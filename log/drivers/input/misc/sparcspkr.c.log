commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/input/misc/sparcspkr.c b/drivers/input/misc/sparcspkr.c
index 4a5afc7fe96e..fe43e5557ed7 100644
--- a/drivers/input/misc/sparcspkr.c
+++ b/drivers/input/misc/sparcspkr.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  Driver for PC-speaker like devices found on various Sparc systems.
  *

commit d352c0e1f32e168e20d14d666a73f3712fbdc1f5
Author: Thierry Reding <treding@nvidia.com>
Date:   Wed Dec 2 09:28:03 2015 -0800

    Input: sparcspkr - use platform_register/unregister_drivers()
    
    These new helpers simplify implementing multi-driver modules and
    properly handle failure to register one driver by unregistering all
    previously registered drivers.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/sparcspkr.c b/drivers/input/misc/sparcspkr.c
index 6f997aa49183..4a5afc7fe96e 100644
--- a/drivers/input/misc/sparcspkr.c
+++ b/drivers/input/misc/sparcspkr.c
@@ -345,23 +345,19 @@ static struct platform_driver grover_beep_driver = {
 	.shutdown	= sparcspkr_shutdown,
 };
 
+static struct platform_driver * const drivers[] = {
+	&bbc_beep_driver,
+	&grover_beep_driver,
+};
+
 static int __init sparcspkr_init(void)
 {
-	int err = platform_driver_register(&bbc_beep_driver);
-
-	if (!err) {
-		err = platform_driver_register(&grover_beep_driver);
-		if (err)
-			platform_driver_unregister(&bbc_beep_driver);
-	}
-
-	return err;
+	return platform_register_drivers(drivers, ARRAY_SIZE(drivers));
 }
 
 static void __exit sparcspkr_exit(void)
 {
-	platform_driver_unregister(&bbc_beep_driver);
-	platform_driver_unregister(&grover_beep_driver);
+	platform_unregister_drivers(drivers, ARRAY_SIZE(drivers));
 }
 
 module_init(sparcspkr_init);

commit 26492f195eed08b95ad5acdfbe625062ad7d86c6
Author: Luis de Bethencourt <luis@debethencourt.com>
Date:   Thu Sep 3 10:50:57 2015 -0700

    Input: sparcspkr - fix module autoload for OF platform drivers
    
    These platform drivers have a OF device ID table but the OF module
    alias information is not created so module autoloading won't work.
    
    Signed-off-by: Luis de Bethencourt <luis@debethencourt.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/sparcspkr.c b/drivers/input/misc/sparcspkr.c
index 54116e544c96..6f997aa49183 100644
--- a/drivers/input/misc/sparcspkr.c
+++ b/drivers/input/misc/sparcspkr.c
@@ -253,6 +253,7 @@ static const struct of_device_id bbc_beep_match[] = {
 	},
 	{},
 };
+MODULE_DEVICE_TABLE(of, bbc_beep_match);
 
 static struct platform_driver bbc_beep_driver = {
 	.driver = {
@@ -332,6 +333,7 @@ static const struct of_device_id grover_beep_match[] = {
 	},
 	{},
 };
+MODULE_DEVICE_TABLE(of, grover_beep_match);
 
 static struct platform_driver grover_beep_driver = {
 	.driver = {

commit 776bd315a7721574d7d687dd9abf200735d12a2a
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:20:40 2014 +0200

    input: misc: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/input/misc/sparcspkr.c b/drivers/input/misc/sparcspkr.c
index 179ff1cd6f6b..54116e544c96 100644
--- a/drivers/input/misc/sparcspkr.c
+++ b/drivers/input/misc/sparcspkr.c
@@ -257,7 +257,6 @@ static const struct of_device_id bbc_beep_match[] = {
 static struct platform_driver bbc_beep_driver = {
 	.driver = {
 		.name = "bbcbeep",
-		.owner = THIS_MODULE,
 		.of_match_table = bbc_beep_match,
 	},
 	.probe		= bbc_beep_probe,
@@ -337,7 +336,6 @@ static const struct of_device_id grover_beep_match[] = {
 static struct platform_driver grover_beep_driver = {
 	.driver = {
 		.name = "groverbeep",
-		.owner = THIS_MODULE,
 		.of_match_table = grover_beep_match,
 	},
 	.probe		= grover_beep_probe,

commit d650471a399e65e423967e0b7692c86228211522
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun Jul 20 13:38:58 2014 +0200

    sparcspkr: use sbus_*() primitives for IO
    
    The memory are mapped using of_ioremap() which is
    an indication this is sbus memory.
    Shift all uses of inb/outb to the sbus variants.
    
    The inb/outb methods uses ASI_PHYS_BYPASS_EC_E_L,
    whereas sbus_ variants uses ASI_PHYS_BYPASS_EC_E.
    
    The difference is if the reads/writes are done in
    native or little endian.
    But for byte reads/writes there is no difference
    so this does not matter for inb/outb - and this
    driver only uses the byte variants.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/input/misc/sparcspkr.c b/drivers/input/misc/sparcspkr.c
index 65fd3150919b..179ff1cd6f6b 100644
--- a/drivers/input/misc/sparcspkr.c
+++ b/drivers/input/misc/sparcspkr.c
@@ -86,13 +86,13 @@ static int bbc_spkr_event(struct input_dev *dev, unsigned int type, unsigned int
 	spin_lock_irqsave(&state->lock, flags);
 
 	if (count) {
-		outb(0x01,                 info->regs + 0);
-		outb(0x00,                 info->regs + 2);
-		outb((count >> 16) & 0xff, info->regs + 3);
-		outb((count >>  8) & 0xff, info->regs + 4);
-		outb(0x00,                 info->regs + 5);
+		sbus_writeb(0x01,                 info->regs + 0);
+		sbus_writeb(0x00,                 info->regs + 2);
+		sbus_writeb((count >> 16) & 0xff, info->regs + 3);
+		sbus_writeb((count >>  8) & 0xff, info->regs + 4);
+		sbus_writeb(0x00,                 info->regs + 5);
 	} else {
-		outb(0x00,                 info->regs + 0);
+		sbus_writeb(0x00,                 info->regs + 0);
 	}
 
 	spin_unlock_irqrestore(&state->lock, flags);
@@ -123,15 +123,15 @@ static int grover_spkr_event(struct input_dev *dev, unsigned int type, unsigned
 
 	if (count) {
 		/* enable counter 2 */
-		outb(inb(info->enable_reg) | 3, info->enable_reg);
+		sbus_writeb(sbus_readb(info->enable_reg) | 3, info->enable_reg);
 		/* set command for counter 2, 2 byte write */
-		outb(0xB6, info->freq_regs + 1);
+		sbus_writeb(0xB6, info->freq_regs + 1);
 		/* select desired HZ */
-		outb(count & 0xff, info->freq_regs + 0);
-		outb((count >> 8) & 0xff, info->freq_regs + 0);
+		sbus_writeb(count & 0xff, info->freq_regs + 0);
+		sbus_writeb((count >> 8) & 0xff, info->freq_regs + 0);
 	} else {
 		/* disable counter 2 */
-		outb(inb_p(info->enable_reg) & 0xFC, info->enable_reg);
+		sbus_writeb(sbus_readb(info->enable_reg) & 0xFC, info->enable_reg);
 	}
 
 	spin_unlock_irqrestore(&state->lock, flags);

commit 35c4b1227e1f3ea8b8536834aaa96c2cc7c0cfa0
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Thu May 23 09:20:21 2013 -0700

    Input: misc - use platform_{get,set}_drvdata()
    
    Use the wrapper functions for getting and setting the driver data using
    platform_device instead of using dev_{get,set}_drvdata() with &pdev->dev,
    so we can directly pass a struct platform_device.
    
    Also, unnecessary dev_set_drvdata() is removed, because the driver core
    clears the driver data to NULL after device_release or on probe failure.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/sparcspkr.c b/drivers/input/misc/sparcspkr.c
index a53586a7fbdb..65fd3150919b 100644
--- a/drivers/input/misc/sparcspkr.c
+++ b/drivers/input/misc/sparcspkr.c
@@ -175,7 +175,7 @@ static int sparcspkr_probe(struct device *dev)
 
 static void sparcspkr_shutdown(struct platform_device *dev)
 {
-	struct sparcspkr_state *state = dev_get_drvdata(&dev->dev);
+	struct sparcspkr_state *state = platform_get_drvdata(dev);
 	struct input_dev *input_dev = state->input_dev;
 
 	/* turn off the speaker */
@@ -211,7 +211,7 @@ static int bbc_beep_probe(struct platform_device *op)
 	if (!info->regs)
 		goto out_free;
 
-	dev_set_drvdata(&op->dev, state);
+	platform_set_drvdata(op, state);
 
 	err = sparcspkr_probe(&op->dev);
 	if (err)
@@ -220,7 +220,6 @@ static int bbc_beep_probe(struct platform_device *op)
 	return 0;
 
 out_clear_drvdata:
-	dev_set_drvdata(&op->dev, NULL);
 	of_iounmap(&op->resource[0], info->regs, 6);
 
 out_free:
@@ -231,7 +230,7 @@ static int bbc_beep_probe(struct platform_device *op)
 
 static int bbc_remove(struct platform_device *op)
 {
-	struct sparcspkr_state *state = dev_get_drvdata(&op->dev);
+	struct sparcspkr_state *state = platform_get_drvdata(op);
 	struct input_dev *input_dev = state->input_dev;
 	struct bbc_beep_info *info = &state->u.bbc;
 
@@ -242,7 +241,6 @@ static int bbc_remove(struct platform_device *op)
 
 	of_iounmap(&op->resource[0], info->regs, 6);
 
-	dev_set_drvdata(&op->dev, NULL);
 	kfree(state);
 
 	return 0;
@@ -290,7 +288,7 @@ static int grover_beep_probe(struct platform_device *op)
 	if (!info->enable_reg)
 		goto out_unmap_freq_regs;
 
-	dev_set_drvdata(&op->dev, state);
+	platform_set_drvdata(op, state);
 
 	err = sparcspkr_probe(&op->dev);
 	if (err)
@@ -299,7 +297,6 @@ static int grover_beep_probe(struct platform_device *op)
 	return 0;
 
 out_clear_drvdata:
-	dev_set_drvdata(&op->dev, NULL);
 	of_iounmap(&op->resource[3], info->enable_reg, 1);
 
 out_unmap_freq_regs:
@@ -312,7 +309,7 @@ static int grover_beep_probe(struct platform_device *op)
 
 static int grover_remove(struct platform_device *op)
 {
-	struct sparcspkr_state *state = dev_get_drvdata(&op->dev);
+	struct sparcspkr_state *state = platform_get_drvdata(op);
 	struct grover_beep_info *info = &state->u.grover;
 	struct input_dev *input_dev = state->input_dev;
 
@@ -324,7 +321,6 @@ static int grover_remove(struct platform_device *op)
 	of_iounmap(&op->resource[3], info->enable_reg, 1);
 	of_iounmap(&op->resource[2], info->freq_regs, 2);
 
-	dev_set_drvdata(&op->dev, NULL);
 	kfree(state);
 
 	return 0;

commit e2619cf78e19476bfd7ceaefa9eff0847529346e
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Nov 23 21:50:47 2012 -0800

    Input: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/sparcspkr.c b/drivers/input/misc/sparcspkr.c
index d0239b496399..a53586a7fbdb 100644
--- a/drivers/input/misc/sparcspkr.c
+++ b/drivers/input/misc/sparcspkr.c
@@ -229,7 +229,7 @@ static int bbc_beep_probe(struct platform_device *op)
 	return err;
 }
 
-static int __devexit bbc_remove(struct platform_device *op)
+static int bbc_remove(struct platform_device *op)
 {
 	struct sparcspkr_state *state = dev_get_drvdata(&op->dev);
 	struct input_dev *input_dev = state->input_dev;
@@ -310,7 +310,7 @@ static int grover_beep_probe(struct platform_device *op)
 	return err;
 }
 
-static int __devexit grover_remove(struct platform_device *op)
+static int grover_remove(struct platform_device *op)
 {
 	struct sparcspkr_state *state = dev_get_drvdata(&op->dev);
 	struct grover_beep_info *info = &state->u.grover;

commit 5298cc4cc753bbe4c530b41341834f6ef3344d0d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Nov 23 21:38:25 2012 -0800

    Input: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Javier Martinez Canillas <javier@dowhile0.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/sparcspkr.c b/drivers/input/misc/sparcspkr.c
index b9c870251f14..d0239b496399 100644
--- a/drivers/input/misc/sparcspkr.c
+++ b/drivers/input/misc/sparcspkr.c
@@ -139,7 +139,7 @@ static int grover_spkr_event(struct input_dev *dev, unsigned int type, unsigned
 	return 0;
 }
 
-static int __devinit sparcspkr_probe(struct device *dev)
+static int sparcspkr_probe(struct device *dev)
 {
 	struct sparcspkr_state *state = dev_get_drvdata(dev);
 	struct input_dev *input_dev;
@@ -182,7 +182,7 @@ static void sparcspkr_shutdown(struct platform_device *dev)
 	state->event(input_dev, EV_SND, SND_BELL, 0);
 }
 
-static int __devinit bbc_beep_probe(struct platform_device *op)
+static int bbc_beep_probe(struct platform_device *op)
 {
 	struct sparcspkr_state *state;
 	struct bbc_beep_info *info;
@@ -267,7 +267,7 @@ static struct platform_driver bbc_beep_driver = {
 	.shutdown	= sparcspkr_shutdown,
 };
 
-static int __devinit grover_beep_probe(struct platform_device *op)
+static int grover_beep_probe(struct platform_device *op)
 {
 	struct sparcspkr_state *state;
 	struct grover_beep_info *info;

commit 1cb0aa88179b7a71c240529e9d781d7bbb43d2e8
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Nov 23 21:27:39 2012 -0800

    Input: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/misc/sparcspkr.c b/drivers/input/misc/sparcspkr.c
index 0122f5351577..b9c870251f14 100644
--- a/drivers/input/misc/sparcspkr.c
+++ b/drivers/input/misc/sparcspkr.c
@@ -263,7 +263,7 @@ static struct platform_driver bbc_beep_driver = {
 		.of_match_table = bbc_beep_match,
 	},
 	.probe		= bbc_beep_probe,
-	.remove		= __devexit_p(bbc_remove),
+	.remove		= bbc_remove,
 	.shutdown	= sparcspkr_shutdown,
 };
 
@@ -345,7 +345,7 @@ static struct platform_driver grover_beep_driver = {
 		.of_match_table = grover_beep_match,
 	},
 	.probe		= grover_beep_probe,
-	.remove		= __devexit_p(grover_remove),
+	.remove		= grover_remove,
 	.shutdown	= sparcspkr_shutdown,
 };
 

commit 4ebb24f707187196937607c60810d42f7112d7aa
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Feb 22 20:01:33 2011 -0700

    dt/sparc: Eliminate users of of_platform_{,un}register_driver
    
    Get rid of old users of of_platform_driver in arch/sparc.  Most
    of_platform_driver users can be converted to use the platform_bus
    directly.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/input/misc/sparcspkr.c b/drivers/input/misc/sparcspkr.c
index 8e130bf7d32b..0122f5351577 100644
--- a/drivers/input/misc/sparcspkr.c
+++ b/drivers/input/misc/sparcspkr.c
@@ -173,18 +173,16 @@ static int __devinit sparcspkr_probe(struct device *dev)
 	return 0;
 }
 
-static int sparcspkr_shutdown(struct platform_device *dev)
+static void sparcspkr_shutdown(struct platform_device *dev)
 {
 	struct sparcspkr_state *state = dev_get_drvdata(&dev->dev);
 	struct input_dev *input_dev = state->input_dev;
 
 	/* turn off the speaker */
 	state->event(input_dev, EV_SND, SND_BELL, 0);
-
-	return 0;
 }
 
-static int __devinit bbc_beep_probe(struct platform_device *op, const struct of_device_id *match)
+static int __devinit bbc_beep_probe(struct platform_device *op)
 {
 	struct sparcspkr_state *state;
 	struct bbc_beep_info *info;
@@ -258,7 +256,7 @@ static const struct of_device_id bbc_beep_match[] = {
 	{},
 };
 
-static struct of_platform_driver bbc_beep_driver = {
+static struct platform_driver bbc_beep_driver = {
 	.driver = {
 		.name = "bbcbeep",
 		.owner = THIS_MODULE,
@@ -269,7 +267,7 @@ static struct of_platform_driver bbc_beep_driver = {
 	.shutdown	= sparcspkr_shutdown,
 };
 
-static int __devinit grover_beep_probe(struct platform_device *op, const struct of_device_id *match)
+static int __devinit grover_beep_probe(struct platform_device *op)
 {
 	struct sparcspkr_state *state;
 	struct grover_beep_info *info;
@@ -340,7 +338,7 @@ static const struct of_device_id grover_beep_match[] = {
 	{},
 };
 
-static struct of_platform_driver grover_beep_driver = {
+static struct platform_driver grover_beep_driver = {
 	.driver = {
 		.name = "groverbeep",
 		.owner = THIS_MODULE,
@@ -353,12 +351,12 @@ static struct of_platform_driver grover_beep_driver = {
 
 static int __init sparcspkr_init(void)
 {
-	int err = of_register_platform_driver(&bbc_beep_driver);
+	int err = platform_driver_register(&bbc_beep_driver);
 
 	if (!err) {
-		err = of_register_platform_driver(&grover_beep_driver);
+		err = platform_driver_register(&grover_beep_driver);
 		if (err)
-			of_unregister_platform_driver(&bbc_beep_driver);
+			platform_driver_unregister(&bbc_beep_driver);
 	}
 
 	return err;
@@ -366,8 +364,8 @@ static int __init sparcspkr_init(void)
 
 static void __exit sparcspkr_exit(void)
 {
-	of_unregister_platform_driver(&bbc_beep_driver);
-	of_unregister_platform_driver(&grover_beep_driver);
+	platform_driver_unregister(&bbc_beep_driver);
+	platform_driver_unregister(&grover_beep_driver);
 }
 
 module_init(sparcspkr_init);

commit 2dc11581376829303b98eadb2de253bee065a56a
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Aug 6 09:25:50 2010 -0600

    of/device: Replace struct of_device with struct platform_device
    
    of_device is just an alias for platform_device, so remove it entirely.  Also
    replace to_of_device() with to_platform_device() and update comment blocks.
    
    This patch was initially generated from the following semantic patch, and then
    edited by hand to pick up the bits that coccinelle didn't catch.
    
    @@
    @@
    -struct of_device
    +struct platform_device
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Reviewed-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/input/misc/sparcspkr.c b/drivers/input/misc/sparcspkr.c
index f3bb92e9755f..8e130bf7d32b 100644
--- a/drivers/input/misc/sparcspkr.c
+++ b/drivers/input/misc/sparcspkr.c
@@ -173,7 +173,7 @@ static int __devinit sparcspkr_probe(struct device *dev)
 	return 0;
 }
 
-static int sparcspkr_shutdown(struct of_device *dev)
+static int sparcspkr_shutdown(struct platform_device *dev)
 {
 	struct sparcspkr_state *state = dev_get_drvdata(&dev->dev);
 	struct input_dev *input_dev = state->input_dev;
@@ -184,7 +184,7 @@ static int sparcspkr_shutdown(struct of_device *dev)
 	return 0;
 }
 
-static int __devinit bbc_beep_probe(struct of_device *op, const struct of_device_id *match)
+static int __devinit bbc_beep_probe(struct platform_device *op, const struct of_device_id *match)
 {
 	struct sparcspkr_state *state;
 	struct bbc_beep_info *info;
@@ -231,7 +231,7 @@ static int __devinit bbc_beep_probe(struct of_device *op, const struct of_device
 	return err;
 }
 
-static int __devexit bbc_remove(struct of_device *op)
+static int __devexit bbc_remove(struct platform_device *op)
 {
 	struct sparcspkr_state *state = dev_get_drvdata(&op->dev);
 	struct input_dev *input_dev = state->input_dev;
@@ -269,7 +269,7 @@ static struct of_platform_driver bbc_beep_driver = {
 	.shutdown	= sparcspkr_shutdown,
 };
 
-static int __devinit grover_beep_probe(struct of_device *op, const struct of_device_id *match)
+static int __devinit grover_beep_probe(struct platform_device *op, const struct of_device_id *match)
 {
 	struct sparcspkr_state *state;
 	struct grover_beep_info *info;
@@ -312,7 +312,7 @@ static int __devinit grover_beep_probe(struct of_device *op, const struct of_dev
 	return err;
 }
 
-static int __devexit grover_remove(struct of_device *op)
+static int __devexit grover_remove(struct platform_device *op)
 {
 	struct sparcspkr_state *state = dev_get_drvdata(&op->dev);
 	struct grover_beep_info *info = &state->u.grover;

commit 1ab1d63a85cee2545272f63a7644e9f855cb65d0
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Jun 24 15:14:37 2010 -0600

    of/platform: remove all of_bus_type and of_platform_bus_type references
    
    Both of_bus_type and of_platform_bus_type are just #define aliases
    for the platform bus.  This patch removes all references to them and
    switches to the of_register_platform_driver()/of_unregister_platform_driver()
    API for registering.
    
    Subsequent patches will convert each user of of_register_platform_driver()
    into plain platform_drivers without the of_platform_driver shim.  At which
    point the of_register_platform_driver()/of_unregister_platform_driver()
    functions can be removed.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/input/misc/sparcspkr.c b/drivers/input/misc/sparcspkr.c
index 1dacae4b43f0..f3bb92e9755f 100644
--- a/drivers/input/misc/sparcspkr.c
+++ b/drivers/input/misc/sparcspkr.c
@@ -353,14 +353,12 @@ static struct of_platform_driver grover_beep_driver = {
 
 static int __init sparcspkr_init(void)
 {
-	int err = of_register_driver(&bbc_beep_driver,
-				     &of_platform_bus_type);
+	int err = of_register_platform_driver(&bbc_beep_driver);
 
 	if (!err) {
-		err = of_register_driver(&grover_beep_driver,
-					 &of_platform_bus_type);
+		err = of_register_platform_driver(&grover_beep_driver);
 		if (err)
-			of_unregister_driver(&bbc_beep_driver);
+			of_unregister_platform_driver(&bbc_beep_driver);
 	}
 
 	return err;
@@ -368,8 +366,8 @@ static int __init sparcspkr_init(void)
 
 static void __exit sparcspkr_exit(void)
 {
-	of_unregister_driver(&bbc_beep_driver);
-	of_unregister_driver(&grover_beep_driver);
+	of_unregister_platform_driver(&bbc_beep_driver);
+	of_unregister_platform_driver(&grover_beep_driver);
 }
 
 module_init(sparcspkr_init);

commit 4018294b53d1dae026880e45f174c1cc63b5d435
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Apr 13 16:13:02 2010 -0700

    of: Remove duplicate fields from of_platform_driver
    
    .name, .match_table and .owner are duplicated in both of_platform_driver
    and device_driver.  This patch is a removes the extra copies from struct
    of_platform_driver and converts all users to the device_driver members.
    
    This patch is a pretty mechanical change.  The usage model doesn't change
    and if any drivers have been missed, or if anything has been fixed up
    incorrectly, then it will fail with a compile time error, and the fixup
    will be trivial.  This patch looks big and scary because it touches so
    many files, but it should be pretty safe.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Sean MacLennan <smaclennan@pikatech.com>

diff --git a/drivers/input/misc/sparcspkr.c b/drivers/input/misc/sparcspkr.c
index 0d45422f8095..1dacae4b43f0 100644
--- a/drivers/input/misc/sparcspkr.c
+++ b/drivers/input/misc/sparcspkr.c
@@ -259,8 +259,11 @@ static const struct of_device_id bbc_beep_match[] = {
 };
 
 static struct of_platform_driver bbc_beep_driver = {
-	.name		= "bbcbeep",
-	.match_table	= bbc_beep_match,
+	.driver = {
+		.name = "bbcbeep",
+		.owner = THIS_MODULE,
+		.of_match_table = bbc_beep_match,
+	},
 	.probe		= bbc_beep_probe,
 	.remove		= __devexit_p(bbc_remove),
 	.shutdown	= sparcspkr_shutdown,
@@ -338,8 +341,11 @@ static const struct of_device_id grover_beep_match[] = {
 };
 
 static struct of_platform_driver grover_beep_driver = {
-	.name		= "groverbeep",
-	.match_table	= grover_beep_match,
+	.driver = {
+		.name = "groverbeep",
+		.owner = THIS_MODULE,
+		.of_match_table = grover_beep_match,
+	},
 	.probe		= grover_beep_probe,
 	.remove		= __devexit_p(grover_remove),
 	.shutdown	= sparcspkr_shutdown,

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/input/misc/sparcspkr.c b/drivers/input/misc/sparcspkr.c
index b064419b90a2..0d45422f8095 100644
--- a/drivers/input/misc/sparcspkr.c
+++ b/drivers/input/misc/sparcspkr.c
@@ -9,6 +9,7 @@
 #include <linux/init.h>
 #include <linux/input.h>
 #include <linux/of_device.h>
+#include <linux/slab.h>
 
 #include <asm/io.h>
 

commit 9e0af8a49872b8170c5a5da9d0262ae7834d2f9b
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Mon Oct 5 21:43:42 2009 -0700

    Input: sparkspkr - move remove() functions to .devexit.text
    
    The function bbc_remove and grover_remove are used only wrapped
    by __devexit_p so define it using __devexit.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/misc/sparcspkr.c b/drivers/input/misc/sparcspkr.c
index c4f42311fdec..b064419b90a2 100644
--- a/drivers/input/misc/sparcspkr.c
+++ b/drivers/input/misc/sparcspkr.c
@@ -230,7 +230,7 @@ static int __devinit bbc_beep_probe(struct of_device *op, const struct of_device
 	return err;
 }
 
-static int bbc_remove(struct of_device *op)
+static int __devexit bbc_remove(struct of_device *op)
 {
 	struct sparcspkr_state *state = dev_get_drvdata(&op->dev);
 	struct input_dev *input_dev = state->input_dev;
@@ -308,7 +308,7 @@ static int __devinit grover_beep_probe(struct of_device *op, const struct of_dev
 	return err;
 }
 
-static int grover_remove(struct of_device *op)
+static int __devexit grover_remove(struct of_device *op)
 {
 	struct sparcspkr_state *state = dev_get_drvdata(&op->dev);
 	struct grover_beep_info *info = &state->u.grover;

commit fd098316ef533e8441576f020ead4beab93154ce
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Aug 31 01:23:17 2008 -0700

    sparc: Annotate of_device_id arrays with const or __initdata.
    
    As suggested by Stephen Rothwell.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/input/misc/sparcspkr.c b/drivers/input/misc/sparcspkr.c
index d8765cc93d27..c4f42311fdec 100644
--- a/drivers/input/misc/sparcspkr.c
+++ b/drivers/input/misc/sparcspkr.c
@@ -249,7 +249,7 @@ static int bbc_remove(struct of_device *op)
 	return 0;
 }
 
-static struct of_device_id bbc_beep_match[] = {
+static const struct of_device_id bbc_beep_match[] = {
 	{
 		.name = "beep",
 		.compatible = "SUNW,bbc-beep",
@@ -328,7 +328,7 @@ static int grover_remove(struct of_device *op)
 	return 0;
 }
 
-static struct of_device_id grover_beep_match[] = {
+static const struct of_device_id grover_beep_match[] = {
 	{
 		.name = "beep",
 		.compatible = "SUNW,smbus-beep",

commit 9c1a5077fdca99356c891af37931e537dea874f5
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Apr 26 21:02:21 2008 -0700

    input: Rewrite sparcspkr device probing.
    
    Remove all dependencies on EBUS and ISA bus layers, which we'd like to
    remove as they are superfluous.
    
    While we're here, add support for proper frequency changing on BBC
    beep devices.  Unlike the comments that were here, this device can
    in fact use a programmable frequency.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/input/misc/sparcspkr.c b/drivers/input/misc/sparcspkr.c
index fed3c375ccf3..d8765cc93d27 100644
--- a/drivers/input/misc/sparcspkr.c
+++ b/drivers/input/misc/sparcspkr.c
@@ -2,33 +2,69 @@
  *  Driver for PC-speaker like devices found on various Sparc systems.
  *
  *  Copyright (c) 2002 Vojtech Pavlik
- *  Copyright (c) 2002, 2006 David S. Miller (davem@davemloft.net)
+ *  Copyright (c) 2002, 2006, 2008 David S. Miller (davem@davemloft.net)
  */
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/input.h>
-#include <linux/platform_device.h>
+#include <linux/of_device.h>
 
 #include <asm/io.h>
-#include <asm/ebus.h>
-#include <asm/isa.h>
 
 MODULE_AUTHOR("David S. Miller <davem@davemloft.net>");
 MODULE_DESCRIPTION("Sparc Speaker beeper driver");
 MODULE_LICENSE("GPL");
 
+struct grover_beep_info {
+	void __iomem	*freq_regs;
+	void __iomem	*enable_reg;
+};
+
+struct bbc_beep_info {
+	u32		clock_freq;
+	void __iomem	*regs;
+};
+
 struct sparcspkr_state {
 	const char		*name;
-	unsigned long		iobase;
 	int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);
 	spinlock_t		lock;
 	struct input_dev	*input_dev;
+	union {
+		struct grover_beep_info grover;
+		struct bbc_beep_info bbc;
+	} u;
 };
 
-static int ebus_spkr_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)
+static u32 bbc_count_to_reg(struct bbc_beep_info *info, unsigned int count)
+{
+	u32 val, clock_freq = info->clock_freq;
+	int i;
+
+	if (!count)
+		return 0;
+
+	if (count <= clock_freq >> 20)
+		return 1 << 18;
+
+	if (count >= clock_freq >> 12)
+		return 1 << 10;
+
+	val = 1 << 18;
+	for (i = 19; i >= 11; i--) {
+		val >>= 1;
+		if (count <= clock_freq >> i)
+			break;
+	}
+
+	return val;
+}
+
+static int bbc_spkr_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)
 {
 	struct sparcspkr_state *state = dev_get_drvdata(dev->dev.parent);
+	struct bbc_beep_info *info = &state->u.bbc;
 	unsigned int count = 0;
 	unsigned long flags;
 
@@ -44,24 +80,29 @@ static int ebus_spkr_event(struct input_dev *dev, unsigned int type, unsigned in
 	if (value > 20 && value < 32767)
 		count = 1193182 / value;
 
+	count = bbc_count_to_reg(info, count);
+
 	spin_lock_irqsave(&state->lock, flags);
 
-	/* EBUS speaker only has on/off state, the frequency does not
-	 * appear to be programmable.
-	 */
-	if (state->iobase & 0x2UL)
-		outb(!!count, state->iobase);
-	else
-		outl(!!count, state->iobase);
+	if (count) {
+		outb(0x01,                 info->regs + 0);
+		outb(0x00,                 info->regs + 2);
+		outb((count >> 16) & 0xff, info->regs + 3);
+		outb((count >>  8) & 0xff, info->regs + 4);
+		outb(0x00,                 info->regs + 5);
+	} else {
+		outb(0x00,                 info->regs + 0);
+	}
 
 	spin_unlock_irqrestore(&state->lock, flags);
 
 	return 0;
 }
 
-static int isa_spkr_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)
+static int grover_spkr_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)
 {
 	struct sparcspkr_state *state = dev_get_drvdata(dev->dev.parent);
+	struct grover_beep_info *info = &state->u.grover;
 	unsigned int count = 0;
 	unsigned long flags;
 
@@ -81,15 +122,15 @@ static int isa_spkr_event(struct input_dev *dev, unsigned int type, unsigned int
 
 	if (count) {
 		/* enable counter 2 */
-		outb(inb(state->iobase + 0x61) | 3, state->iobase + 0x61);
+		outb(inb(info->enable_reg) | 3, info->enable_reg);
 		/* set command for counter 2, 2 byte write */
-		outb(0xB6, state->iobase + 0x43);
+		outb(0xB6, info->freq_regs + 1);
 		/* select desired HZ */
-		outb(count & 0xff, state->iobase + 0x42);
-		outb((count >> 8) & 0xff, state->iobase + 0x42);
+		outb(count & 0xff, info->freq_regs + 0);
+		outb((count >> 8) & 0xff, info->freq_regs + 0);
 	} else {
 		/* disable counter 2 */
-		outb(inb_p(state->iobase + 0x61) & 0xFC, state->iobase + 0x61);
+		outb(inb_p(info->enable_reg) & 0xFC, info->enable_reg);
 	}
 
 	spin_unlock_irqrestore(&state->lock, flags);
@@ -131,7 +172,7 @@ static int __devinit sparcspkr_probe(struct device *dev)
 	return 0;
 }
 
-static int __devexit sparcspkr_remove(struct of_device *dev)
+static int sparcspkr_shutdown(struct of_device *dev)
 {
 	struct sparcspkr_state *state = dev_get_drvdata(&dev->dev);
 	struct input_dev *input_dev = state->input_dev;
@@ -139,115 +180,180 @@ static int __devexit sparcspkr_remove(struct of_device *dev)
 	/* turn off the speaker */
 	state->event(input_dev, EV_SND, SND_BELL, 0);
 
-	input_unregister_device(input_dev);
-
-	dev_set_drvdata(&dev->dev, NULL);
-	kfree(state);
-
 	return 0;
 }
 
-static int sparcspkr_shutdown(struct of_device *dev)
+static int __devinit bbc_beep_probe(struct of_device *op, const struct of_device_id *match)
 {
-	struct sparcspkr_state *state = dev_get_drvdata(&dev->dev);
-	struct input_dev *input_dev = state->input_dev;
+	struct sparcspkr_state *state;
+	struct bbc_beep_info *info;
+	struct device_node *dp;
+	int err = -ENOMEM;
 
-	/* turn off the speaker */
-	state->event(input_dev, EV_SND, SND_BELL, 0);
+	state = kzalloc(sizeof(*state), GFP_KERNEL);
+	if (!state)
+		goto out_err;
+
+	state->name = "Sparc BBC Speaker";
+	state->event = bbc_spkr_event;
+	spin_lock_init(&state->lock);
+
+	dp = of_find_node_by_path("/");
+	err = -ENODEV;
+	if (!dp)
+		goto out_free;
+
+	info = &state->u.bbc;
+	info->clock_freq = of_getintprop_default(dp, "clock-frequency", 0);
+	if (!info->clock_freq)
+		goto out_free;
+
+	info->regs = of_ioremap(&op->resource[0], 0, 6, "bbc beep");
+	if (!info->regs)
+		goto out_free;
+
+	dev_set_drvdata(&op->dev, state);
+
+	err = sparcspkr_probe(&op->dev);
+	if (err)
+		goto out_clear_drvdata;
 
 	return 0;
+
+out_clear_drvdata:
+	dev_set_drvdata(&op->dev, NULL);
+	of_iounmap(&op->resource[0], info->regs, 6);
+
+out_free:
+	kfree(state);
+out_err:
+	return err;
 }
 
-static int __devinit ebus_beep_probe(struct of_device *dev, const struct of_device_id *match)
+static int bbc_remove(struct of_device *op)
 {
-	struct linux_ebus_device *edev = to_ebus_device(&dev->dev);
-	struct sparcspkr_state *state;
-	int err;
+	struct sparcspkr_state *state = dev_get_drvdata(&op->dev);
+	struct input_dev *input_dev = state->input_dev;
+	struct bbc_beep_info *info = &state->u.bbc;
 
-	state = kzalloc(sizeof(*state), GFP_KERNEL);
-	if (!state)
-		return -ENOMEM;
+	/* turn off the speaker */
+	state->event(input_dev, EV_SND, SND_BELL, 0);
 
-	state->name = "Sparc EBUS Speaker";
-	state->iobase = edev->resource[0].start;
-	state->event = ebus_spkr_event;
-	spin_lock_init(&state->lock);
+	input_unregister_device(input_dev);
 
-	dev_set_drvdata(&dev->dev, state);
+	of_iounmap(&op->resource[0], info->regs, 6);
 
-	err = sparcspkr_probe(&dev->dev);
-	if (err) {
-		dev_set_drvdata(&dev->dev, NULL);
-		kfree(state);
-	}
+	dev_set_drvdata(&op->dev, NULL);
+	kfree(state);
 
 	return 0;
 }
 
-static struct of_device_id ebus_beep_match[] = {
+static struct of_device_id bbc_beep_match[] = {
 	{
 		.name = "beep",
+		.compatible = "SUNW,bbc-beep",
 	},
 	{},
 };
 
-static struct of_platform_driver ebus_beep_driver = {
-	.name		= "beep",
-	.match_table	= ebus_beep_match,
-	.probe		= ebus_beep_probe,
-	.remove		= __devexit_p(sparcspkr_remove),
+static struct of_platform_driver bbc_beep_driver = {
+	.name		= "bbcbeep",
+	.match_table	= bbc_beep_match,
+	.probe		= bbc_beep_probe,
+	.remove		= __devexit_p(bbc_remove),
 	.shutdown	= sparcspkr_shutdown,
 };
 
-static int __devinit isa_beep_probe(struct of_device *dev, const struct of_device_id *match)
+static int __devinit grover_beep_probe(struct of_device *op, const struct of_device_id *match)
 {
-	struct sparc_isa_device *idev = to_isa_device(&dev->dev);
 	struct sparcspkr_state *state;
-	int err;
+	struct grover_beep_info *info;
+	int err = -ENOMEM;
 
 	state = kzalloc(sizeof(*state), GFP_KERNEL);
 	if (!state)
-		return -ENOMEM;
+		goto out_err;
 
-	state->name = "Sparc ISA Speaker";
-	state->iobase = idev->resource.start;
-	state->event = isa_spkr_event;
+	state->name = "Sparc Grover Speaker";
+	state->event = grover_spkr_event;
 	spin_lock_init(&state->lock);
 
-	dev_set_drvdata(&dev->dev, state);
+	info = &state->u.grover;
+	info->freq_regs = of_ioremap(&op->resource[2], 0, 2, "grover beep freq");
+	if (!info->freq_regs)
+		goto out_free;
 
-	err = sparcspkr_probe(&dev->dev);
-	if (err) {
-		dev_set_drvdata(&dev->dev, NULL);
-		kfree(state);
-	}
+	info->enable_reg = of_ioremap(&op->resource[3], 0, 1, "grover beep enable");
+	if (!info->enable_reg)
+		goto out_unmap_freq_regs;
+
+	dev_set_drvdata(&op->dev, state);
+
+	err = sparcspkr_probe(&op->dev);
+	if (err)
+		goto out_clear_drvdata;
+
+	return 0;
+
+out_clear_drvdata:
+	dev_set_drvdata(&op->dev, NULL);
+	of_iounmap(&op->resource[3], info->enable_reg, 1);
+
+out_unmap_freq_regs:
+	of_iounmap(&op->resource[2], info->freq_regs, 2);
+out_free:
+	kfree(state);
+out_err:
+	return err;
+}
+
+static int grover_remove(struct of_device *op)
+{
+	struct sparcspkr_state *state = dev_get_drvdata(&op->dev);
+	struct grover_beep_info *info = &state->u.grover;
+	struct input_dev *input_dev = state->input_dev;
+
+	/* turn off the speaker */
+	state->event(input_dev, EV_SND, SND_BELL, 0);
+
+	input_unregister_device(input_dev);
+
+	of_iounmap(&op->resource[3], info->enable_reg, 1);
+	of_iounmap(&op->resource[2], info->freq_regs, 2);
+
+	dev_set_drvdata(&op->dev, NULL);
+	kfree(state);
 
 	return 0;
 }
 
-static struct of_device_id isa_beep_match[] = {
+static struct of_device_id grover_beep_match[] = {
 	{
-		.name = "dma",
+		.name = "beep",
+		.compatible = "SUNW,smbus-beep",
 	},
 	{},
 };
 
-static struct of_platform_driver isa_beep_driver = {
-	.name		= "beep",
-	.match_table	= isa_beep_match,
-	.probe		= isa_beep_probe,
-	.remove		= __devexit_p(sparcspkr_remove),
+static struct of_platform_driver grover_beep_driver = {
+	.name		= "groverbeep",
+	.match_table	= grover_beep_match,
+	.probe		= grover_beep_probe,
+	.remove		= __devexit_p(grover_remove),
 	.shutdown	= sparcspkr_shutdown,
 };
 
 static int __init sparcspkr_init(void)
 {
-	int err = of_register_driver(&ebus_beep_driver, &ebus_bus_type);
+	int err = of_register_driver(&bbc_beep_driver,
+				     &of_platform_bus_type);
 
 	if (!err) {
-		err = of_register_driver(&isa_beep_driver, &isa_bus_type);
+		err = of_register_driver(&grover_beep_driver,
+					 &of_platform_bus_type);
 		if (err)
-			of_unregister_driver(&ebus_beep_driver);
+			of_unregister_driver(&bbc_beep_driver);
 	}
 
 	return err;
@@ -255,8 +361,8 @@ static int __init sparcspkr_init(void)
 
 static void __exit sparcspkr_exit(void)
 {
-	of_unregister_driver(&ebus_beep_driver);
-	of_unregister_driver(&isa_beep_driver);
+	of_unregister_driver(&bbc_beep_driver);
+	of_unregister_driver(&grover_beep_driver);
 }
 
 module_init(sparcspkr_init);

commit 2ad913babd5d597f9d9d71d9e93dd589d55e66cd
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Jan 21 17:25:37 2008 -0800

    [SPARC64]: Fix section error in sparcspkr
    
    With a sparc64 defconfig modified to set CONFIG_HOTPLUG=n
    the following error happened during link of vmlinux:
    
    local symbol 0: discarded in section `.devexit.text' from drivers/built-in.o
    local symbol 1: discarded in section `.devexit.text' from drivers/built-in.o
    
    (The error message above is from kbuild.git but it happens in mainline too)
    
    The error happens becase there is a reference from .text/.data to a
    function marked __devexit. With CONFIG_HOTPLUG=n all code marked
    __devexit are discarded and the linker complains.
    
    It was tracked down to sparcspkr.c which were missing __devexit_p()
    around the function pointers.
    
    Unfortunately modpost did not catch this since modpost do not warn
    about references from .data to .devexit from variables named *_driver.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/input/misc/sparcspkr.c b/drivers/input/misc/sparcspkr.c
index a3637d870880..fed3c375ccf3 100644
--- a/drivers/input/misc/sparcspkr.c
+++ b/drivers/input/misc/sparcspkr.c
@@ -195,7 +195,7 @@ static struct of_platform_driver ebus_beep_driver = {
 	.name		= "beep",
 	.match_table	= ebus_beep_match,
 	.probe		= ebus_beep_probe,
-	.remove		= sparcspkr_remove,
+	.remove		= __devexit_p(sparcspkr_remove),
 	.shutdown	= sparcspkr_shutdown,
 };
 
@@ -236,7 +236,7 @@ static struct of_platform_driver isa_beep_driver = {
 	.name		= "beep",
 	.match_table	= isa_beep_match,
 	.probe		= isa_beep_probe,
-	.remove		= sparcspkr_remove,
+	.remove		= __devexit_p(sparcspkr_remove),
 	.shutdown	= sparcspkr_shutdown,
 };
 

commit 7b19ada2ed3c1eccb9fe94d74b05e1428224663d
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Oct 18 23:40:32 2007 -0700

    get rid of input BIT* duplicate defines
    
    get rid of input BIT* duplicate defines
    
    use newly global defined macros for input layer. Also remove includes of
    input.h from non-input sources only for BIT macro definiton. Define the
    macro temporarily in local manner, all those local definitons will be
    removed further in this patchset (to not break bisecting).
    BIT macro will be globally defined (1<<x)
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: <dtor@mail.ru>
    Acked-by: Jiri Kosina <jkosina@suse.cz>
    Cc: <lenb@kernel.org>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Cc: <perex@suse.cz>
    Acked-by: Mauro Carvalho Chehab <mchehab@infradead.org>
    Cc: <vernux@us.ibm.com>
    Cc: <malattia@linux.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/input/misc/sparcspkr.c b/drivers/input/misc/sparcspkr.c
index e36ec1d92be8..a3637d870880 100644
--- a/drivers/input/misc/sparcspkr.c
+++ b/drivers/input/misc/sparcspkr.c
@@ -115,8 +115,8 @@ static int __devinit sparcspkr_probe(struct device *dev)
 	input_dev->id.version = 0x0100;
 	input_dev->dev.parent = dev;
 
-	input_dev->evbit[0] = BIT(EV_SND);
-	input_dev->sndbit[0] = BIT(SND_BELL) | BIT(SND_TONE);
+	input_dev->evbit[0] = BIT_MASK(EV_SND);
+	input_dev->sndbit[0] = BIT_MASK(SND_BELL) | BIT_MASK(SND_TONE);
 
 	input_dev->event = state->event;
 

commit 293e6392d72dfaef1f6aef605769869512bec45d
Author: Dmitry Torokhov <dtor@insightbb.com>
Date:   Thu Apr 12 01:35:32 2007 -0400

    Input: misc devices - switch to using input_dev->dev.parent
    
    In preparation for struct class_device -> struct device input
    core conversion, switch to using input_dev->dev.parent when
    specifying device position in sysfs tree.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/misc/sparcspkr.c b/drivers/input/misc/sparcspkr.c
index 106c94f33b93..e36ec1d92be8 100644
--- a/drivers/input/misc/sparcspkr.c
+++ b/drivers/input/misc/sparcspkr.c
@@ -28,7 +28,7 @@ struct sparcspkr_state {
 
 static int ebus_spkr_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)
 {
-	struct sparcspkr_state *state = dev_get_drvdata(dev->cdev.dev);
+	struct sparcspkr_state *state = dev_get_drvdata(dev->dev.parent);
 	unsigned int count = 0;
 	unsigned long flags;
 
@@ -61,7 +61,7 @@ static int ebus_spkr_event(struct input_dev *dev, unsigned int type, unsigned in
 
 static int isa_spkr_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)
 {
-	struct sparcspkr_state *state = dev_get_drvdata(dev->cdev.dev);
+	struct sparcspkr_state *state = dev_get_drvdata(dev->dev.parent);
 	unsigned int count = 0;
 	unsigned long flags;
 
@@ -113,7 +113,7 @@ static int __devinit sparcspkr_probe(struct device *dev)
 	input_dev->id.vendor = 0x001f;
 	input_dev->id.product = 0x0001;
 	input_dev->id.version = 0x0100;
-	input_dev->cdev.dev = dev;
+	input_dev->dev.parent = dev;
 
 	input_dev->evbit[0] = BIT(EV_SND);
 	input_dev->sndbit[0] = BIT(SND_BELL) | BIT(SND_TONE);

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/input/misc/sparcspkr.c b/drivers/input/misc/sparcspkr.c
index 42c11fbf3c79..106c94f33b93 100644
--- a/drivers/input/misc/sparcspkr.c
+++ b/drivers/input/misc/sparcspkr.c
@@ -4,7 +4,6 @@
  *  Copyright (c) 2002 Vojtech Pavlik
  *  Copyright (c) 2002, 2006 David S. Miller (davem@davemloft.net)
  */
-#include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>

commit a2bd4fd17926d715a470fbe0ebe05128ba410984
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Fri Jun 23 01:44:10 2006 -0700

    [SPARC64]: Add of_device layer and make ebus/isa use it.
    
    Sparcspkr and power drivers are converted, to make sure it works.
    Eventually the SBUS device layer will use this as a sub-class.
    
    I really cannot cut loose on that bit until sparc32 is given the
    same infrastructure.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/input/misc/sparcspkr.c b/drivers/input/misc/sparcspkr.c
index ed95dc9420dd..42c11fbf3c79 100644
--- a/drivers/input/misc/sparcspkr.c
+++ b/drivers/input/misc/sparcspkr.c
@@ -2,7 +2,7 @@
  *  Driver for PC-speaker like devices found on various Sparc systems.
  *
  *  Copyright (c) 2002 Vojtech Pavlik
- *  Copyright (c) 2002 David S. Miller (davem@redhat.com)
+ *  Copyright (c) 2002, 2006 David S. Miller (davem@davemloft.net)
  */
 #include <linux/config.h>
 #include <linux/kernel.h>
@@ -13,21 +13,23 @@
 
 #include <asm/io.h>
 #include <asm/ebus.h>
-#ifdef CONFIG_SPARC64
 #include <asm/isa.h>
-#endif
 
-MODULE_AUTHOR("David S. Miller <davem@redhat.com>");
+MODULE_AUTHOR("David S. Miller <davem@davemloft.net>");
 MODULE_DESCRIPTION("Sparc Speaker beeper driver");
 MODULE_LICENSE("GPL");
 
-const char *beep_name;
-static unsigned long beep_iobase;
-static int (*beep_event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);
-static DEFINE_SPINLOCK(beep_lock);
+struct sparcspkr_state {
+	const char		*name;
+	unsigned long		iobase;
+	int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);
+	spinlock_t		lock;
+	struct input_dev	*input_dev;
+};
 
 static int ebus_spkr_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)
 {
+	struct sparcspkr_state *state = dev_get_drvdata(dev->cdev.dev);
 	unsigned int count = 0;
 	unsigned long flags;
 
@@ -43,24 +45,24 @@ static int ebus_spkr_event(struct input_dev *dev, unsigned int type, unsigned in
 	if (value > 20 && value < 32767)
 		count = 1193182 / value;
 
-	spin_lock_irqsave(&beep_lock, flags);
+	spin_lock_irqsave(&state->lock, flags);
 
 	/* EBUS speaker only has on/off state, the frequency does not
 	 * appear to be programmable.
 	 */
-	if (beep_iobase & 0x2UL)
-		outb(!!count, beep_iobase);
+	if (state->iobase & 0x2UL)
+		outb(!!count, state->iobase);
 	else
-		outl(!!count, beep_iobase);
+		outl(!!count, state->iobase);
 
-	spin_unlock_irqrestore(&beep_lock, flags);
+	spin_unlock_irqrestore(&state->lock, flags);
 
 	return 0;
 }
 
-#ifdef CONFIG_SPARC64
 static int isa_spkr_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)
 {
+	struct sparcspkr_state *state = dev_get_drvdata(dev->cdev.dev);
 	unsigned int count = 0;
 	unsigned long flags;
 
@@ -76,29 +78,29 @@ static int isa_spkr_event(struct input_dev *dev, unsigned int type, unsigned int
 	if (value > 20 && value < 32767)
 		count = 1193182 / value;
 
-	spin_lock_irqsave(&beep_lock, flags);
+	spin_lock_irqsave(&state->lock, flags);
 
 	if (count) {
 		/* enable counter 2 */
-		outb(inb(beep_iobase + 0x61) | 3, beep_iobase + 0x61);
+		outb(inb(state->iobase + 0x61) | 3, state->iobase + 0x61);
 		/* set command for counter 2, 2 byte write */
-		outb(0xB6, beep_iobase + 0x43);
+		outb(0xB6, state->iobase + 0x43);
 		/* select desired HZ */
-		outb(count & 0xff, beep_iobase + 0x42);
-		outb((count >> 8) & 0xff, beep_iobase + 0x42);
+		outb(count & 0xff, state->iobase + 0x42);
+		outb((count >> 8) & 0xff, state->iobase + 0x42);
 	} else {
 		/* disable counter 2 */
-		outb(inb_p(beep_iobase + 0x61) & 0xFC, beep_iobase + 0x61);
+		outb(inb_p(state->iobase + 0x61) & 0xFC, state->iobase + 0x61);
 	}
 
-	spin_unlock_irqrestore(&beep_lock, flags);
+	spin_unlock_irqrestore(&state->lock, flags);
 
 	return 0;
 }
-#endif
 
-static int __devinit sparcspkr_probe(struct platform_device *dev)
+static int __devinit sparcspkr_probe(struct device *dev)
 {
+	struct sparcspkr_state *state = dev_get_drvdata(dev);
 	struct input_dev *input_dev;
 	int error;
 
@@ -106,18 +108,18 @@ static int __devinit sparcspkr_probe(struct platform_device *dev)
 	if (!input_dev)
 		return -ENOMEM;
 
-	input_dev->name = beep_name;
+	input_dev->name = state->name;
 	input_dev->phys = "sparc/input0";
 	input_dev->id.bustype = BUS_ISA;
 	input_dev->id.vendor = 0x001f;
 	input_dev->id.product = 0x0001;
 	input_dev->id.version = 0x0100;
-	input_dev->cdev.dev = &dev->dev;
+	input_dev->cdev.dev = dev;
 
 	input_dev->evbit[0] = BIT(EV_SND);
 	input_dev->sndbit[0] = BIT(SND_BELL) | BIT(SND_TONE);
 
-	input_dev->event = beep_event;
+	input_dev->event = state->event;
 
 	error = input_register_device(input_dev);
 	if (error) {
@@ -125,111 +127,137 @@ static int __devinit sparcspkr_probe(struct platform_device *dev)
 		return error;
 	}
 
-	platform_set_drvdata(dev, input_dev);
+	state->input_dev = input_dev;
 
 	return 0;
 }
 
-static int __devexit sparcspkr_remove(struct platform_device *dev)
+static int __devexit sparcspkr_remove(struct of_device *dev)
 {
-	struct input_dev *input_dev = platform_get_drvdata(dev);
+	struct sparcspkr_state *state = dev_get_drvdata(&dev->dev);
+	struct input_dev *input_dev = state->input_dev;
 
-	input_unregister_device(input_dev);
-	platform_set_drvdata(dev, NULL);
 	/* turn off the speaker */
-	beep_event(NULL, EV_SND, SND_BELL, 0);
+	state->event(input_dev, EV_SND, SND_BELL, 0);
+
+	input_unregister_device(input_dev);
+
+	dev_set_drvdata(&dev->dev, NULL);
+	kfree(state);
 
 	return 0;
 }
 
-static void sparcspkr_shutdown(struct platform_device *dev)
+static int sparcspkr_shutdown(struct of_device *dev)
 {
+	struct sparcspkr_state *state = dev_get_drvdata(&dev->dev);
+	struct input_dev *input_dev = state->input_dev;
+
 	/* turn off the speaker */
-	beep_event(NULL, EV_SND, SND_BELL, 0);
+	state->event(input_dev, EV_SND, SND_BELL, 0);
+
+	return 0;
+}
+
+static int __devinit ebus_beep_probe(struct of_device *dev, const struct of_device_id *match)
+{
+	struct linux_ebus_device *edev = to_ebus_device(&dev->dev);
+	struct sparcspkr_state *state;
+	int err;
+
+	state = kzalloc(sizeof(*state), GFP_KERNEL);
+	if (!state)
+		return -ENOMEM;
+
+	state->name = "Sparc EBUS Speaker";
+	state->iobase = edev->resource[0].start;
+	state->event = ebus_spkr_event;
+	spin_lock_init(&state->lock);
+
+	dev_set_drvdata(&dev->dev, state);
+
+	err = sparcspkr_probe(&dev->dev);
+	if (err) {
+		dev_set_drvdata(&dev->dev, NULL);
+		kfree(state);
+	}
+
+	return 0;
 }
 
-static struct platform_driver sparcspkr_platform_driver = {
-	.driver		= {
-		.name	= "sparcspkr",
-		.owner	= THIS_MODULE,
+static struct of_device_id ebus_beep_match[] = {
+	{
+		.name = "beep",
 	},
-	.probe		= sparcspkr_probe,
-	.remove		= __devexit_p(sparcspkr_remove),
-	.shutdown	= sparcspkr_shutdown,
+	{},
 };
 
-static struct platform_device *sparcspkr_platform_device;
+static struct of_platform_driver ebus_beep_driver = {
+	.name		= "beep",
+	.match_table	= ebus_beep_match,
+	.probe		= ebus_beep_probe,
+	.remove		= sparcspkr_remove,
+	.shutdown	= sparcspkr_shutdown,
+};
 
-static int __init sparcspkr_drv_init(void)
+static int __devinit isa_beep_probe(struct of_device *dev, const struct of_device_id *match)
 {
-	int error;
+	struct sparc_isa_device *idev = to_isa_device(&dev->dev);
+	struct sparcspkr_state *state;
+	int err;
 
-	error = platform_driver_register(&sparcspkr_platform_driver);
-	if (error)
-		return error;
+	state = kzalloc(sizeof(*state), GFP_KERNEL);
+	if (!state)
+		return -ENOMEM;
 
-	sparcspkr_platform_device = platform_device_alloc("sparcspkr", -1);
-	if (!sparcspkr_platform_device) {
-		error = -ENOMEM;
-		goto err_unregister_driver;
-	}
+	state->name = "Sparc ISA Speaker";
+	state->iobase = idev->resource.start;
+	state->event = isa_spkr_event;
+	spin_lock_init(&state->lock);
+
+	dev_set_drvdata(&dev->dev, state);
 
-	error = platform_device_add(sparcspkr_platform_device);
-	if (error)
-		goto err_free_device;
+	err = sparcspkr_probe(&dev->dev);
+	if (err) {
+		dev_set_drvdata(&dev->dev, NULL);
+		kfree(state);
+	}
 
 	return 0;
+}
 
- err_free_device:
-	platform_device_put(sparcspkr_platform_device);
- err_unregister_driver:
-	platform_driver_unregister(&sparcspkr_platform_driver);
+static struct of_device_id isa_beep_match[] = {
+	{
+		.name = "dma",
+	},
+	{},
+};
 
-	return error;
-}
+static struct of_platform_driver isa_beep_driver = {
+	.name		= "beep",
+	.match_table	= isa_beep_match,
+	.probe		= isa_beep_probe,
+	.remove		= sparcspkr_remove,
+	.shutdown	= sparcspkr_shutdown,
+};
 
 static int __init sparcspkr_init(void)
 {
-	struct linux_ebus *ebus;
-	struct linux_ebus_device *edev;
-#ifdef CONFIG_SPARC64
-	struct sparc_isa_bridge *isa_br;
-	struct sparc_isa_device *isa_dev;
-#endif
-
-	for_each_ebus(ebus) {
-		for_each_ebusdev(edev, ebus) {
-			if (!strcmp(edev->prom_node->name, "beep")) {
-				beep_name = "Sparc EBUS Speaker";
-				beep_event = ebus_spkr_event;
-				beep_iobase = edev->resource[0].start;
-				return sparcspkr_drv_init();
-			}
-		}
-	}
-#ifdef CONFIG_SPARC64
-	for_each_isa(isa_br) {
-		for_each_isadev(isa_dev, isa_br) {
-			/* A hack, the beep device's base lives in
-			 * the DMA isa node.
-			 */
-			if (!strcmp(isa_dev->prom_node->name, "dma")) {
-				beep_name = "Sparc ISA Speaker";
-				beep_event = isa_spkr_event,
-				beep_iobase = isa_dev->resource.start;
-				return sparcspkr_drv_init();
-			}
-		}
+	int err = of_register_driver(&ebus_beep_driver, &ebus_bus_type);
+
+	if (!err) {
+		err = of_register_driver(&isa_beep_driver, &isa_bus_type);
+		if (err)
+			of_unregister_driver(&ebus_beep_driver);
 	}
-#endif
 
-	return -ENODEV;
+	return err;
 }
 
 static void __exit sparcspkr_exit(void)
 {
-	platform_device_unregister(sparcspkr_platform_device);
-	platform_driver_unregister(&sparcspkr_platform_driver);
+	of_unregister_driver(&ebus_beep_driver);
+	of_unregister_driver(&isa_beep_driver);
 }
 
 module_init(sparcspkr_init);

commit 690c8fd31f1e35985d0f35772fde514da59ec9d1
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Thu Jun 22 19:12:03 2006 -0700

    [SPARC64]: Use in-kernel PROM tree for EBUS and ISA.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/input/misc/sparcspkr.c b/drivers/input/misc/sparcspkr.c
index f0fd2c4740f1..ed95dc9420dd 100644
--- a/drivers/input/misc/sparcspkr.c
+++ b/drivers/input/misc/sparcspkr.c
@@ -199,7 +199,7 @@ static int __init sparcspkr_init(void)
 
 	for_each_ebus(ebus) {
 		for_each_ebusdev(edev, ebus) {
-			if (!strcmp(edev->prom_name, "beep")) {
+			if (!strcmp(edev->prom_node->name, "beep")) {
 				beep_name = "Sparc EBUS Speaker";
 				beep_event = ebus_spkr_event;
 				beep_iobase = edev->resource[0].start;
@@ -213,7 +213,7 @@ static int __init sparcspkr_init(void)
 			/* A hack, the beep device's base lives in
 			 * the DMA isa node.
 			 */
-			if (!strcmp(isa_dev->prom_name, "dma")) {
+			if (!strcmp(isa_dev->prom_node->name, "dma")) {
 				beep_name = "Sparc ISA Speaker";
 				beep_event = isa_spkr_event,
 				beep_iobase = isa_dev->resource.start;

commit f5b64078d75528f36b78d30e945bb1b05cb05f26
Author: Dmitry Torokhov <dtor_core@ameritech.net>
Date:   Wed Dec 21 00:52:35 2005 -0500

    Input: sparcspkr - register with driver core as a platfrom device
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/misc/sparcspkr.c b/drivers/input/misc/sparcspkr.c
index 29d97b12be7a..f0fd2c4740f1 100644
--- a/drivers/input/misc/sparcspkr.c
+++ b/drivers/input/misc/sparcspkr.c
@@ -9,6 +9,7 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/input.h>
+#include <linux/platform_device.h>
 
 #include <asm/io.h>
 #include <asm/ebus.h>
@@ -20,22 +21,10 @@ MODULE_AUTHOR("David S. Miller <davem@redhat.com>");
 MODULE_DESCRIPTION("Sparc Speaker beeper driver");
 MODULE_LICENSE("GPL");
 
+const char *beep_name;
 static unsigned long beep_iobase;
-static struct input_dev *sparcspkr_dev;
-
-DEFINE_SPINLOCK(beep_lock);
-
-static void __init init_sparcspkr_struct(void)
-{
-	sparcspkr_dev->evbit[0] = BIT(EV_SND);
-	sparcspkr_dev->sndbit[0] = BIT(SND_BELL) | BIT(SND_TONE);
-
-	sparcspkr_dev->phys = "sparc/input0";
-	sparcspkr_dev->id.bustype = BUS_ISA;
-	sparcspkr_dev->id.vendor = 0x001f;
-	sparcspkr_dev->id.product = 0x0001;
-	sparcspkr_dev->id.version = 0x0100;
-}
+static int (*beep_event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);
+static DEFINE_SPINLOCK(beep_lock);
 
 static int ebus_spkr_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)
 {
@@ -59,39 +48,16 @@ static int ebus_spkr_event(struct input_dev *dev, unsigned int type, unsigned in
 	/* EBUS speaker only has on/off state, the frequency does not
 	 * appear to be programmable.
 	 */
-	if (count) {
-		if (beep_iobase & 0x2UL)
-			outb(1, beep_iobase);
-		else
-			outl(1, beep_iobase);
-	} else {
-		if (beep_iobase & 0x2UL)
-			outb(0, beep_iobase);
-		else
-			outl(0, beep_iobase);
-	}
+	if (beep_iobase & 0x2UL)
+		outb(!!count, beep_iobase);
+	else
+		outl(!!count, beep_iobase);
 
 	spin_unlock_irqrestore(&beep_lock, flags);
 
 	return 0;
 }
 
-static int __init init_ebus_beep(struct linux_ebus_device *edev)
-{
-	beep_iobase = edev->resource[0].start;
-
-	sparcspkr_dev = input_allocate_device();
-	if (!sparcspkr_dev)
-		return -ENOMEM;
-
-	sparcspkr_dev->name = "Sparc EBUS Speaker";
-	sparcspkr_dev->event = ebus_spkr_event;
-
-	input_register_device(sparcspkr_dev);
-
-	return 0;
-}
-
 #ifdef CONFIG_SPARC64
 static int isa_spkr_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)
 {
@@ -129,30 +95,103 @@ static int isa_spkr_event(struct input_dev *dev, unsigned int type, unsigned int
 
 	return 0;
 }
+#endif
 
-static int __init init_isa_beep(struct sparc_isa_device *isa_dev)
+static int __devinit sparcspkr_probe(struct platform_device *dev)
 {
-	beep_iobase = isa_dev->resource.start;
+	struct input_dev *input_dev;
+	int error;
 
-	sparcspkr_dev = input_allocate_device();
-	if (!sparcspkr_dev)
+	input_dev = input_allocate_device();
+	if (!input_dev)
 		return -ENOMEM;
 
-	init_sparcspkr_struct();
+	input_dev->name = beep_name;
+	input_dev->phys = "sparc/input0";
+	input_dev->id.bustype = BUS_ISA;
+	input_dev->id.vendor = 0x001f;
+	input_dev->id.product = 0x0001;
+	input_dev->id.version = 0x0100;
+	input_dev->cdev.dev = &dev->dev;
 
-	sparcspkr_dev->name = "Sparc ISA Speaker";
-	sparcspkr_dev->event = isa_spkr_event;
+	input_dev->evbit[0] = BIT(EV_SND);
+	input_dev->sndbit[0] = BIT(SND_BELL) | BIT(SND_TONE);
 
-	input_register_device(sparcspkr_dev);
+	input_dev->event = beep_event;
+
+	error = input_register_device(input_dev);
+	if (error) {
+		input_free_device(input_dev);
+		return error;
+	}
+
+	platform_set_drvdata(dev, input_dev);
 
 	return 0;
 }
-#endif
+
+static int __devexit sparcspkr_remove(struct platform_device *dev)
+{
+	struct input_dev *input_dev = platform_get_drvdata(dev);
+
+	input_unregister_device(input_dev);
+	platform_set_drvdata(dev, NULL);
+	/* turn off the speaker */
+	beep_event(NULL, EV_SND, SND_BELL, 0);
+
+	return 0;
+}
+
+static void sparcspkr_shutdown(struct platform_device *dev)
+{
+	/* turn off the speaker */
+	beep_event(NULL, EV_SND, SND_BELL, 0);
+}
+
+static struct platform_driver sparcspkr_platform_driver = {
+	.driver		= {
+		.name	= "sparcspkr",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= sparcspkr_probe,
+	.remove		= __devexit_p(sparcspkr_remove),
+	.shutdown	= sparcspkr_shutdown,
+};
+
+static struct platform_device *sparcspkr_platform_device;
+
+static int __init sparcspkr_drv_init(void)
+{
+	int error;
+
+	error = platform_driver_register(&sparcspkr_platform_driver);
+	if (error)
+		return error;
+
+	sparcspkr_platform_device = platform_device_alloc("sparcspkr", -1);
+	if (!sparcspkr_platform_device) {
+		error = -ENOMEM;
+		goto err_unregister_driver;
+	}
+
+	error = platform_device_add(sparcspkr_platform_device);
+	if (error)
+		goto err_free_device;
+
+	return 0;
+
+ err_free_device:
+	platform_device_put(sparcspkr_platform_device);
+ err_unregister_driver:
+	platform_driver_unregister(&sparcspkr_platform_driver);
+
+	return error;
+}
 
 static int __init sparcspkr_init(void)
 {
 	struct linux_ebus *ebus;
-	struct linux_ebus_device *edev = NULL;
+	struct linux_ebus_device *edev;
 #ifdef CONFIG_SPARC64
 	struct sparc_isa_bridge *isa_br;
 	struct sparc_isa_device *isa_dev;
@@ -160,8 +199,12 @@ static int __init sparcspkr_init(void)
 
 	for_each_ebus(ebus) {
 		for_each_ebusdev(edev, ebus) {
-			if (!strcmp(edev->prom_name, "beep"))
-				return init_ebus_beep(edev);
+			if (!strcmp(edev->prom_name, "beep")) {
+				beep_name = "Sparc EBUS Speaker";
+				beep_event = ebus_spkr_event;
+				beep_iobase = edev->resource[0].start;
+				return sparcspkr_drv_init();
+			}
 		}
 	}
 #ifdef CONFIG_SPARC64
@@ -170,8 +213,12 @@ static int __init sparcspkr_init(void)
 			/* A hack, the beep device's base lives in
 			 * the DMA isa node.
 			 */
-			if (!strcmp(isa_dev->prom_name, "dma"))
-				return init_isa_beep(isa_dev);
+			if (!strcmp(isa_dev->prom_name, "dma")) {
+				beep_name = "Sparc ISA Speaker";
+				beep_event = isa_spkr_event,
+				beep_iobase = isa_dev->resource.start;
+				return sparcspkr_drv_init();
+			}
 		}
 	}
 #endif
@@ -181,7 +228,8 @@ static int __init sparcspkr_init(void)
 
 static void __exit sparcspkr_exit(void)
 {
-	input_unregister_device(sparcspkr_dev);
+	platform_device_unregister(sparcspkr_platform_device);
+	platform_driver_unregister(&sparcspkr_platform_driver);
 }
 
 module_init(sparcspkr_init);

commit 9d86b7d37018c917837477dd4501d44bf8f3f98c
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sat Oct 29 07:08:49 2005 +0100

    [PATCH] missing bits in sparkspkr conversion
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/input/misc/sparcspkr.c b/drivers/input/misc/sparcspkr.c
index 5778220a18d2..29d97b12be7a 100644
--- a/drivers/input/misc/sparcspkr.c
+++ b/drivers/input/misc/sparcspkr.c
@@ -143,7 +143,7 @@ static int __init init_isa_beep(struct sparc_isa_device *isa_dev)
 	sparcspkr_dev->name = "Sparc ISA Speaker";
 	sparcspkr_dev->event = isa_spkr_event;
 
-	input_register_device(&sparcspkr_dev);
+	input_register_device(sparcspkr_dev);
 
 	return 0;
 }

commit 76b7cddfd576331761e945a508254abad11039e9
Author: Dmitry Torokhov <dtor_core@ameritech.net>
Date:   Thu Sep 15 02:01:51 2005 -0500

    [PATCH] Input: convert driver/input/misc to dynamic input_dev allocation
    
    Input: convert driver/input/misc to dynamic input_dev allocation
    
    This is required for input_dev sysfs integration
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/input/misc/sparcspkr.c b/drivers/input/misc/sparcspkr.c
index cdc3fb3d5f46..5778220a18d2 100644
--- a/drivers/input/misc/sparcspkr.c
+++ b/drivers/input/misc/sparcspkr.c
@@ -17,28 +17,24 @@
 #endif
 
 MODULE_AUTHOR("David S. Miller <davem@redhat.com>");
-MODULE_DESCRIPTION("PC Speaker beeper driver");
+MODULE_DESCRIPTION("Sparc Speaker beeper driver");
 MODULE_LICENSE("GPL");
 
 static unsigned long beep_iobase;
-
-static char *sparcspkr_isa_name = "Sparc ISA Speaker";
-static char *sparcspkr_ebus_name = "Sparc EBUS Speaker";
-static char *sparcspkr_phys = "sparc/input0";
-static struct input_dev sparcspkr_dev;
+static struct input_dev *sparcspkr_dev;
 
 DEFINE_SPINLOCK(beep_lock);
 
 static void __init init_sparcspkr_struct(void)
 {
-	sparcspkr_dev.evbit[0] = BIT(EV_SND);
-	sparcspkr_dev.sndbit[0] = BIT(SND_BELL) | BIT(SND_TONE);
-
-	sparcspkr_dev.phys = sparcspkr_phys;
-	sparcspkr_dev.id.bustype = BUS_ISA;
-	sparcspkr_dev.id.vendor = 0x001f;
-	sparcspkr_dev.id.product = 0x0001;
-	sparcspkr_dev.id.version = 0x0100;
+	sparcspkr_dev->evbit[0] = BIT(EV_SND);
+	sparcspkr_dev->sndbit[0] = BIT(SND_BELL) | BIT(SND_TONE);
+
+	sparcspkr_dev->phys = "sparc/input0";
+	sparcspkr_dev->id.bustype = BUS_ISA;
+	sparcspkr_dev->id.vendor = 0x001f;
+	sparcspkr_dev->id.product = 0x0001;
+	sparcspkr_dev->id.version = 0x0100;
 }
 
 static int ebus_spkr_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)
@@ -84,14 +80,15 @@ static int __init init_ebus_beep(struct linux_ebus_device *edev)
 {
 	beep_iobase = edev->resource[0].start;
 
-	init_sparcspkr_struct();
+	sparcspkr_dev = input_allocate_device();
+	if (!sparcspkr_dev)
+		return -ENOMEM;
 
-	sparcspkr_dev.name = sparcspkr_ebus_name;
-	sparcspkr_dev.event = ebus_spkr_event;
+	sparcspkr_dev->name = "Sparc EBUS Speaker";
+	sparcspkr_dev->event = ebus_spkr_event;
 
-	input_register_device(&sparcspkr_dev);
+	input_register_device(sparcspkr_dev);
 
-        printk(KERN_INFO "input: %s\n", sparcspkr_ebus_name);
 	return 0;
 }
 
@@ -137,15 +134,17 @@ static int __init init_isa_beep(struct sparc_isa_device *isa_dev)
 {
 	beep_iobase = isa_dev->resource.start;
 
+	sparcspkr_dev = input_allocate_device();
+	if (!sparcspkr_dev)
+		return -ENOMEM;
+
 	init_sparcspkr_struct();
 
-	sparcspkr_dev.name = sparcspkr_isa_name;
-	sparcspkr_dev.event = isa_spkr_event;
-	sparcspkr_dev.id.bustype = BUS_ISA;
+	sparcspkr_dev->name = "Sparc ISA Speaker";
+	sparcspkr_dev->event = isa_spkr_event;
 
 	input_register_device(&sparcspkr_dev);
 
-        printk(KERN_INFO "input: %s\n", sparcspkr_isa_name);
 	return 0;
 }
 #endif
@@ -182,7 +181,7 @@ static int __init sparcspkr_init(void)
 
 static void __exit sparcspkr_exit(void)
 {
-	input_unregister_device(&sparcspkr_dev);
+	input_unregister_device(sparcspkr_dev);
 }
 
 module_init(sparcspkr_init);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/input/misc/sparcspkr.c b/drivers/input/misc/sparcspkr.c
new file mode 100644
index 000000000000..cdc3fb3d5f46
--- /dev/null
+++ b/drivers/input/misc/sparcspkr.c
@@ -0,0 +1,189 @@
+/*
+ *  Driver for PC-speaker like devices found on various Sparc systems.
+ *
+ *  Copyright (c) 2002 Vojtech Pavlik
+ *  Copyright (c) 2002 David S. Miller (davem@redhat.com)
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/input.h>
+
+#include <asm/io.h>
+#include <asm/ebus.h>
+#ifdef CONFIG_SPARC64
+#include <asm/isa.h>
+#endif
+
+MODULE_AUTHOR("David S. Miller <davem@redhat.com>");
+MODULE_DESCRIPTION("PC Speaker beeper driver");
+MODULE_LICENSE("GPL");
+
+static unsigned long beep_iobase;
+
+static char *sparcspkr_isa_name = "Sparc ISA Speaker";
+static char *sparcspkr_ebus_name = "Sparc EBUS Speaker";
+static char *sparcspkr_phys = "sparc/input0";
+static struct input_dev sparcspkr_dev;
+
+DEFINE_SPINLOCK(beep_lock);
+
+static void __init init_sparcspkr_struct(void)
+{
+	sparcspkr_dev.evbit[0] = BIT(EV_SND);
+	sparcspkr_dev.sndbit[0] = BIT(SND_BELL) | BIT(SND_TONE);
+
+	sparcspkr_dev.phys = sparcspkr_phys;
+	sparcspkr_dev.id.bustype = BUS_ISA;
+	sparcspkr_dev.id.vendor = 0x001f;
+	sparcspkr_dev.id.product = 0x0001;
+	sparcspkr_dev.id.version = 0x0100;
+}
+
+static int ebus_spkr_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)
+{
+	unsigned int count = 0;
+	unsigned long flags;
+
+	if (type != EV_SND)
+		return -1;
+
+	switch (code) {
+		case SND_BELL: if (value) value = 1000;
+		case SND_TONE: break;
+		default: return -1;
+	}
+
+	if (value > 20 && value < 32767)
+		count = 1193182 / value;
+
+	spin_lock_irqsave(&beep_lock, flags);
+
+	/* EBUS speaker only has on/off state, the frequency does not
+	 * appear to be programmable.
+	 */
+	if (count) {
+		if (beep_iobase & 0x2UL)
+			outb(1, beep_iobase);
+		else
+			outl(1, beep_iobase);
+	} else {
+		if (beep_iobase & 0x2UL)
+			outb(0, beep_iobase);
+		else
+			outl(0, beep_iobase);
+	}
+
+	spin_unlock_irqrestore(&beep_lock, flags);
+
+	return 0;
+}
+
+static int __init init_ebus_beep(struct linux_ebus_device *edev)
+{
+	beep_iobase = edev->resource[0].start;
+
+	init_sparcspkr_struct();
+
+	sparcspkr_dev.name = sparcspkr_ebus_name;
+	sparcspkr_dev.event = ebus_spkr_event;
+
+	input_register_device(&sparcspkr_dev);
+
+        printk(KERN_INFO "input: %s\n", sparcspkr_ebus_name);
+	return 0;
+}
+
+#ifdef CONFIG_SPARC64
+static int isa_spkr_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)
+{
+	unsigned int count = 0;
+	unsigned long flags;
+
+	if (type != EV_SND)
+		return -1;
+
+	switch (code) {
+		case SND_BELL: if (value) value = 1000;
+		case SND_TONE: break;
+		default: return -1;
+	}
+
+	if (value > 20 && value < 32767)
+		count = 1193182 / value;
+
+	spin_lock_irqsave(&beep_lock, flags);
+
+	if (count) {
+		/* enable counter 2 */
+		outb(inb(beep_iobase + 0x61) | 3, beep_iobase + 0x61);
+		/* set command for counter 2, 2 byte write */
+		outb(0xB6, beep_iobase + 0x43);
+		/* select desired HZ */
+		outb(count & 0xff, beep_iobase + 0x42);
+		outb((count >> 8) & 0xff, beep_iobase + 0x42);
+	} else {
+		/* disable counter 2 */
+		outb(inb_p(beep_iobase + 0x61) & 0xFC, beep_iobase + 0x61);
+	}
+
+	spin_unlock_irqrestore(&beep_lock, flags);
+
+	return 0;
+}
+
+static int __init init_isa_beep(struct sparc_isa_device *isa_dev)
+{
+	beep_iobase = isa_dev->resource.start;
+
+	init_sparcspkr_struct();
+
+	sparcspkr_dev.name = sparcspkr_isa_name;
+	sparcspkr_dev.event = isa_spkr_event;
+	sparcspkr_dev.id.bustype = BUS_ISA;
+
+	input_register_device(&sparcspkr_dev);
+
+        printk(KERN_INFO "input: %s\n", sparcspkr_isa_name);
+	return 0;
+}
+#endif
+
+static int __init sparcspkr_init(void)
+{
+	struct linux_ebus *ebus;
+	struct linux_ebus_device *edev = NULL;
+#ifdef CONFIG_SPARC64
+	struct sparc_isa_bridge *isa_br;
+	struct sparc_isa_device *isa_dev;
+#endif
+
+	for_each_ebus(ebus) {
+		for_each_ebusdev(edev, ebus) {
+			if (!strcmp(edev->prom_name, "beep"))
+				return init_ebus_beep(edev);
+		}
+	}
+#ifdef CONFIG_SPARC64
+	for_each_isa(isa_br) {
+		for_each_isadev(isa_dev, isa_br) {
+			/* A hack, the beep device's base lives in
+			 * the DMA isa node.
+			 */
+			if (!strcmp(isa_dev->prom_name, "dma"))
+				return init_isa_beep(isa_dev);
+		}
+	}
+#endif
+
+	return -ENODEV;
+}
+
+static void __exit sparcspkr_exit(void)
+{
+	input_unregister_device(&sparcspkr_dev);
+}
+
+module_init(sparcspkr_init);
+module_exit(sparcspkr_exit);
