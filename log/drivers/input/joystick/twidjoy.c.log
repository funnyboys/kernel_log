commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/input/joystick/twidjoy.c b/drivers/input/joystick/twidjoy.c
index e60cb004cb8c..174c69a188fb 100644
--- a/drivers/input/joystick/twidjoy.c
+++ b/drivers/input/joystick/twidjoy.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Copyright (c) 2001 Arndt Schoenewald
  *  Copyright (c) 2000-2001 Vojtech Pavlik
@@ -32,19 +33,6 @@
  */
 
 /*
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
 
 #include <linux/kernel.h>

commit a1e29643bc10873821a1b9fe4551224370379f78
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Fri Aug 18 17:08:41 2017 -0700

    Input: twidjoy - constify serio_device_id
    
    serio_device_id are not supposed to change at runtime. All functions
    working with serio_device_id provided by <linux/serio.h> work with
    const serio_device_id. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/joystick/twidjoy.c b/drivers/input/joystick/twidjoy.c
index 7f7e5ab3f9e3..e60cb004cb8c 100644
--- a/drivers/input/joystick/twidjoy.c
+++ b/drivers/input/joystick/twidjoy.c
@@ -233,7 +233,7 @@ static int twidjoy_connect(struct serio *serio, struct serio_driver *drv)
  * The serio driver structure.
  */
 
-static struct serio_device_id twidjoy_serio_ids[] = {
+static const struct serio_device_id twidjoy_serio_ids[] = {
 	{
 		.type	= SERIO_RS232,
 		.proto	= SERIO_TWIDJOY,

commit bf9a9f8e5105b13cea954b254008f383ed0b4045
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jan 6 10:27:05 2014 -0800

    Input: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/joystick/twidjoy.c b/drivers/input/joystick/twidjoy.c
index 2556a8193579..7f7e5ab3f9e3 100644
--- a/drivers/input/joystick/twidjoy.c
+++ b/drivers/input/joystick/twidjoy.c
@@ -52,7 +52,6 @@
 #include <linux/slab.h>
 #include <linux/input.h>
 #include <linux/serio.h>
-#include <linux/init.h>
 
 #define DRIVER_DESC	"Handykey Twiddler keyboard as a joystick driver"
 

commit 65ac9f7a23c934ee8c40dc20955e75db4924bfea
Author: Axel Lin <axel.lin@gmail.com>
Date:   Tue Apr 3 23:50:17 2012 -0700

    Input: serio - use module_serio_driver
    
    This patch converts the drivers in drivers/input/* to use
    module_serio_driver() macro which makes the code smaller and
    a bit simpler.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/joystick/twidjoy.c b/drivers/input/joystick/twidjoy.c
index 3f4ec73c9553..2556a8193579 100644
--- a/drivers/input/joystick/twidjoy.c
+++ b/drivers/input/joystick/twidjoy.c
@@ -257,19 +257,4 @@ static struct serio_driver twidjoy_drv = {
 	.disconnect	= twidjoy_disconnect,
 };
 
-/*
- * The functions for inserting/removing us as a module.
- */
-
-static int __init twidjoy_init(void)
-{
-	return serio_register_driver(&twidjoy_drv);
-}
-
-static void __exit twidjoy_exit(void)
-{
-	serio_unregister_driver(&twidjoy_drv);
-}
-
-module_init(twidjoy_init);
-module_exit(twidjoy_exit);
+module_serio_driver(twidjoy_drv);

commit d1659fcc59b21ec442564fedb67a5ad371f82380
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue May 20 12:17:39 2008 -0400

    Input: remove CVS keywords
    
    This patch removes CVS keywords that weren't updated for a long time
    from comments.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/joystick/twidjoy.c b/drivers/input/joystick/twidjoy.c
index 1085c841fec4..3f4ec73c9553 100644
--- a/drivers/input/joystick/twidjoy.c
+++ b/drivers/input/joystick/twidjoy.c
@@ -1,8 +1,4 @@
 /*
- * $Id: twidjoy.c,v 1.5 2002/01/22 20:31:53 vojtech Exp $
- *
- *  derived from CVS-ID "stinger.c,v 1.5 2001/05/29 12:57:18 vojtech Exp"
- *
  *  Copyright (c) 2001 Arndt Schoenewald
  *  Copyright (c) 2000-2001 Vojtech Pavlik
  *  Copyright (c) 2000 Mark Fletcher

commit 7b19ada2ed3c1eccb9fe94d74b05e1428224663d
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Oct 18 23:40:32 2007 -0700

    get rid of input BIT* duplicate defines
    
    get rid of input BIT* duplicate defines
    
    use newly global defined macros for input layer. Also remove includes of
    input.h from non-input sources only for BIT macro definiton. Define the
    macro temporarily in local manner, all those local definitons will be
    removed further in this patchset (to not break bisecting).
    BIT macro will be globally defined (1<<x)
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: <dtor@mail.ru>
    Acked-by: Jiri Kosina <jkosina@suse.cz>
    Cc: <lenb@kernel.org>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Cc: <perex@suse.cz>
    Acked-by: Mauro Carvalho Chehab <mchehab@infradead.org>
    Cc: <vernux@us.ibm.com>
    Cc: <malattia@linux.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/input/joystick/twidjoy.c b/drivers/input/joystick/twidjoy.c
index c91504ec38eb..1085c841fec4 100644
--- a/drivers/input/joystick/twidjoy.c
+++ b/drivers/input/joystick/twidjoy.c
@@ -207,7 +207,7 @@ static int twidjoy_connect(struct serio *serio, struct serio_driver *drv)
 	input_dev->id.version = 0x0100;
 	input_dev->dev.parent = &serio->dev;
 
-	input_dev->evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
+	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
 	input_set_abs_params(input_dev, ABS_X, -50, 50, 4, 4);
 	input_set_abs_params(input_dev, ABS_Y, -50, 50, 4, 4);
 

commit 935e658e89678a7e3427b90cd7a1c86025d95bfe
Author: Dmitry Torokhov <dtor@insightbb.com>
Date:   Thu Apr 12 01:35:26 2007 -0400

    Input: joysticks - switch to using input_dev->dev.parent
    
    In preparation for struct class_device -> struct device input
    core conversion, switch to using input_dev->dev.parent when
    specifying device position in sysfs tree.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/joystick/twidjoy.c b/drivers/input/joystick/twidjoy.c
index 458a129b4b22..c91504ec38eb 100644
--- a/drivers/input/joystick/twidjoy.c
+++ b/drivers/input/joystick/twidjoy.c
@@ -205,10 +205,9 @@ static int twidjoy_connect(struct serio *serio, struct serio_driver *drv)
 	input_dev->id.vendor = SERIO_TWIDJOY;
 	input_dev->id.product = 0x0001;
 	input_dev->id.version = 0x0100;
-	input_dev->cdev.dev = &serio->dev;
+	input_dev->dev.parent = &serio->dev;
 
 	input_dev->evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
-	input_dev->absbit[0] = BIT(ABS_X) | BIT(ABS_Y);
 	input_set_abs_params(input_dev, ABS_X, -50, 50, 4, 4);
 	input_set_abs_params(input_dev, ABS_Y, -50, 50, 4, 4);
 

commit 8715c1cfadf8cce24e79d254f95bd4a84c7741f0
Author: Dmitry Torokhov <dtor@insightbb.com>
Date:   Thu Apr 12 01:34:14 2007 -0400

    Input: drivers/input/joystick - don't access dev->private directly
    
    Use input_get_drvdata() and input_set_drvdata() instead.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/joystick/twidjoy.c b/drivers/input/joystick/twidjoy.c
index 9cf17d6ced82..458a129b4b22 100644
--- a/drivers/input/joystick/twidjoy.c
+++ b/drivers/input/joystick/twidjoy.c
@@ -206,7 +206,6 @@ static int twidjoy_connect(struct serio *serio, struct serio_driver *drv)
 	input_dev->id.product = 0x0001;
 	input_dev->id.version = 0x0100;
 	input_dev->cdev.dev = &serio->dev;
-	input_dev->private = twidjoy;
 
 	input_dev->evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
 	input_dev->absbit[0] = BIT(ABS_X) | BIT(ABS_Y);

commit 153a9df01c0d1ecdc56161c7a0f830325145dd64
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Thu Nov 23 23:35:10 2006 -0500

    Input: handle serio_register_driver() errors
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/joystick/twidjoy.c b/drivers/input/joystick/twidjoy.c
index 3c1c83e8609a..9cf17d6ced82 100644
--- a/drivers/input/joystick/twidjoy.c
+++ b/drivers/input/joystick/twidjoy.c
@@ -269,8 +269,7 @@ static struct serio_driver twidjoy_drv = {
 
 static int __init twidjoy_init(void)
 {
-	serio_register_driver(&twidjoy_drv);
-	return 0;
+	return serio_register_driver(&twidjoy_drv);
 }
 
 static void __exit twidjoy_exit(void)

commit 127278ce2254c61f1346500374d61e33f74a8729
Author: Dmitry Torokhov <dtor@insightbb.com>
Date:   Sun Nov 5 22:40:09 2006 -0500

    Input: joysticks - handle errors when registering input devices
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/joystick/twidjoy.c b/drivers/input/joystick/twidjoy.c
index 49085df2d631..3c1c83e8609a 100644
--- a/drivers/input/joystick/twidjoy.c
+++ b/drivers/input/joystick/twidjoy.c
@@ -194,7 +194,7 @@ static int twidjoy_connect(struct serio *serio, struct serio_driver *drv)
 	twidjoy = kzalloc(sizeof(struct twidjoy), GFP_KERNEL);
 	input_dev = input_allocate_device();
 	if (!twidjoy || !input_dev)
-		goto fail;
+		goto fail1;
 
 	twidjoy->dev = input_dev;
 	snprintf(twidjoy->phys, sizeof(twidjoy->phys), "%s/input0", serio->phys);
@@ -221,13 +221,17 @@ static int twidjoy_connect(struct serio *serio, struct serio_driver *drv)
 
 	err = serio_open(serio, drv);
 	if (err)
-		goto fail;
+		goto fail2;
+
+	err = input_register_device(twidjoy->dev);
+	if (err)
+		goto fail3;
 
-	input_register_device(twidjoy->dev);
 	return 0;
 
- fail:	serio_set_drvdata(serio, NULL);
-	input_free_device(input_dev);
+ fail3:	serio_close(serio);
+ fail2:	serio_set_drvdata(serio, NULL);
+ fail1:	input_free_device(input_dev);
 	kfree(twidjoy);
 	return err;
 }

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/input/joystick/twidjoy.c b/drivers/input/joystick/twidjoy.c
index 076f237d9654..49085df2d631 100644
--- a/drivers/input/joystick/twidjoy.c
+++ b/drivers/input/joystick/twidjoy.c
@@ -104,7 +104,7 @@ struct twidjoy {
  * Twiddler. It updates the data accordingly.
  */
 
-static void twidjoy_process_packet(struct twidjoy *twidjoy, struct pt_regs *regs)
+static void twidjoy_process_packet(struct twidjoy *twidjoy)
 {
 	struct input_dev *dev = twidjoy->dev;
 	unsigned char *data = twidjoy->data;
@@ -113,8 +113,6 @@ static void twidjoy_process_packet(struct twidjoy *twidjoy, struct pt_regs *regs
 
 	button_bits = ((data[1] & 0x7f) << 7) | (data[0] & 0x7f);
 
-	input_regs(dev, regs);
-
 	for (bp = twidjoy_buttons; bp->bitmask; bp++) {
 		int value = (button_bits & (bp->bitmask << bp->bitshift)) >> bp->bitshift;
 		int i;
@@ -141,7 +139,7 @@ static void twidjoy_process_packet(struct twidjoy *twidjoy, struct pt_regs *regs
  * packet processing routine.
  */
 
-static irqreturn_t twidjoy_interrupt(struct serio *serio, unsigned char data, unsigned int flags, struct pt_regs *regs)
+static irqreturn_t twidjoy_interrupt(struct serio *serio, unsigned char data, unsigned int flags)
 {
 	struct twidjoy *twidjoy = serio_get_drvdata(serio);
 
@@ -158,7 +156,7 @@ static irqreturn_t twidjoy_interrupt(struct serio *serio, unsigned char data, un
 		twidjoy->data[twidjoy->idx++] = data;
 
 	if (twidjoy->idx == TWIDJOY_MAX_LENGTH) {
-		twidjoy_process_packet(twidjoy, regs);
+		twidjoy_process_packet(twidjoy);
 		twidjoy->idx = 0;
 	}
 

commit 10ca4c0a622a942e55dc8a6d57ebd441089c9e38
Author: Dmitry Torokhov <dtor_core@ameritech.net>
Date:   Mon Jun 26 01:45:48 2006 -0400

    Input: fix potential overflows in driver/input/joystick
    
    Change all sprintfs into snprintfs to make sure we won't stomp on
    data adjacent to our buffers.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/joystick/twidjoy.c b/drivers/input/joystick/twidjoy.c
index 7f8b0093c5bc..076f237d9654 100644
--- a/drivers/input/joystick/twidjoy.c
+++ b/drivers/input/joystick/twidjoy.c
@@ -199,7 +199,7 @@ static int twidjoy_connect(struct serio *serio, struct serio_driver *drv)
 		goto fail;
 
 	twidjoy->dev = input_dev;
-	sprintf(twidjoy->phys, "%s/input0", serio->phys);
+	snprintf(twidjoy->phys, sizeof(twidjoy->phys), "%s/input0", serio->phys);
 
 	input_dev->name = "Handykey Twiddler";
 	input_dev->phys = twidjoy->phys;

commit ffc6b529e8c46c73827008c7406f43482d71beed
Author: Adrian Bunk <bunk@stusta.de>
Date:   Sun Jan 29 21:51:07 2006 -0500

    Input: make needlessly global code static
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/joystick/twidjoy.c b/drivers/input/joystick/twidjoy.c
index cd3a1e742a30..7f8b0093c5bc 100644
--- a/drivers/input/joystick/twidjoy.c
+++ b/drivers/input/joystick/twidjoy.c
@@ -265,13 +265,13 @@ static struct serio_driver twidjoy_drv = {
  * The functions for inserting/removing us as a module.
  */
 
-int __init twidjoy_init(void)
+static int __init twidjoy_init(void)
 {
 	serio_register_driver(&twidjoy_drv);
 	return 0;
 }
 
-void __exit twidjoy_exit(void)
+static void __exit twidjoy_exit(void)
 {
 	serio_unregister_driver(&twidjoy_drv);
 }

commit 17dd3f0f7aa729a042af5d3318ff9b3e7781b45b
Author: Dmitry Torokhov <dtor_core@ameritech.net>
Date:   Thu Sep 15 02:01:52 2005 -0500

    [PATCH] drivers/input/joystick: convert to dynamic input_dev allocation
    
    Input: convert drivers/input/joystick to dynamic input_dev allocation
    
    This is required for input_dev sysfs integration
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/input/joystick/twidjoy.c b/drivers/input/joystick/twidjoy.c
index 0379bc166525..cd3a1e742a30 100644
--- a/drivers/input/joystick/twidjoy.c
+++ b/drivers/input/joystick/twidjoy.c
@@ -69,8 +69,6 @@ MODULE_LICENSE("GPL");
 
 #define TWIDJOY_MAX_LENGTH 5
 
-static char *twidjoy_name = "Handykey Twiddler";
-
 static struct twidjoy_button_spec {
 	int bitshift;
 	int bitmask;
@@ -95,7 +93,7 @@ twidjoy_buttons[] = {
  */
 
 struct twidjoy {
-	struct input_dev dev;
+	struct input_dev *dev;
 	int idx;
 	unsigned char data[TWIDJOY_MAX_LENGTH];
 	char phys[32];
@@ -108,37 +106,33 @@ struct twidjoy {
 
 static void twidjoy_process_packet(struct twidjoy *twidjoy, struct pt_regs *regs)
 {
-	if (twidjoy->idx == TWIDJOY_MAX_LENGTH) {
-		struct input_dev *dev = &twidjoy->dev;
-		unsigned char *data = twidjoy->data;
-		struct twidjoy_button_spec *bp;
-		int button_bits, abs_x, abs_y;
-
-		button_bits = ((data[1] & 0x7f) << 7) | (data[0] & 0x7f);
+	struct input_dev *dev = twidjoy->dev;
+	unsigned char *data = twidjoy->data;
+	struct twidjoy_button_spec *bp;
+	int button_bits, abs_x, abs_y;
 
-		input_regs(dev, regs);
+	button_bits = ((data[1] & 0x7f) << 7) | (data[0] & 0x7f);
 
-		for (bp = twidjoy_buttons; bp->bitmask; bp++) {
-			int value = (button_bits & (bp->bitmask << bp->bitshift)) >> bp->bitshift;
-			int i;
+	input_regs(dev, regs);
 
-			for (i = 0; i < bp->bitmask; i++)
-				input_report_key(dev, bp->buttons[i], i+1 == value);
-		}
+	for (bp = twidjoy_buttons; bp->bitmask; bp++) {
+		int value = (button_bits & (bp->bitmask << bp->bitshift)) >> bp->bitshift;
+		int i;
 
-		abs_x = ((data[4] & 0x07) << 5) | ((data[3] & 0x7C) >> 2);
-		if (data[4] & 0x08) abs_x -= 256;
+		for (i = 0; i < bp->bitmask; i++)
+			input_report_key(dev, bp->buttons[i], i+1 == value);
+	}
 
-		abs_y = ((data[3] & 0x01) << 7) | ((data[2] & 0x7F) >> 0);
-		if (data[3] & 0x02) abs_y -= 256;
+	abs_x = ((data[4] & 0x07) << 5) | ((data[3] & 0x7C) >> 2);
+	if (data[4] & 0x08) abs_x -= 256;
 
-		input_report_abs(dev, ABS_X, -abs_x);
-		input_report_abs(dev, ABS_Y, +abs_y);
+	abs_y = ((data[3] & 0x01) << 7) | ((data[2] & 0x7F) >> 0);
+	if (data[3] & 0x02) abs_y -= 256;
 
-		input_sync(dev);
-	}
+	input_report_abs(dev, ABS_X, -abs_x);
+	input_report_abs(dev, ABS_Y, +abs_y);
 
-	return;
+	input_sync(dev);
 }
 
 /*
@@ -179,9 +173,9 @@ static void twidjoy_disconnect(struct serio *serio)
 {
 	struct twidjoy *twidjoy = serio_get_drvdata(serio);
 
-	input_unregister_device(&twidjoy->dev);
 	serio_close(serio);
 	serio_set_drvdata(serio, NULL);
+	input_unregister_device(twidjoy->dev);
 	kfree(twidjoy);
 }
 
@@ -195,59 +189,49 @@ static int twidjoy_connect(struct serio *serio, struct serio_driver *drv)
 {
 	struct twidjoy_button_spec *bp;
 	struct twidjoy *twidjoy;
+	struct input_dev *input_dev;
+	int err = -ENOMEM;
 	int i;
-	int err;
-
-	if (!(twidjoy = kmalloc(sizeof(struct twidjoy), GFP_KERNEL)))
-		return -ENOMEM;
 
-	memset(twidjoy, 0, sizeof(struct twidjoy));
+	twidjoy = kzalloc(sizeof(struct twidjoy), GFP_KERNEL);
+	input_dev = input_allocate_device();
+	if (!twidjoy || !input_dev)
+		goto fail;
 
+	twidjoy->dev = input_dev;
 	sprintf(twidjoy->phys, "%s/input0", serio->phys);
 
-	init_input_dev(&twidjoy->dev);
-	twidjoy->dev.name = twidjoy_name;
-	twidjoy->dev.phys = twidjoy->phys;
-	twidjoy->dev.id.bustype = BUS_RS232;
-	twidjoy->dev.id.vendor = SERIO_TWIDJOY;
-	twidjoy->dev.id.product = 0x0001;
-	twidjoy->dev.id.version = 0x0100;
-	twidjoy->dev.dev = &serio->dev;
-
-	twidjoy->dev.evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
-
-	for (bp = twidjoy_buttons; bp->bitmask; bp++) {
+	input_dev->name = "Handykey Twiddler";
+	input_dev->phys = twidjoy->phys;
+	input_dev->id.bustype = BUS_RS232;
+	input_dev->id.vendor = SERIO_TWIDJOY;
+	input_dev->id.product = 0x0001;
+	input_dev->id.version = 0x0100;
+	input_dev->cdev.dev = &serio->dev;
+	input_dev->private = twidjoy;
+
+	input_dev->evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
+	input_dev->absbit[0] = BIT(ABS_X) | BIT(ABS_Y);
+	input_set_abs_params(input_dev, ABS_X, -50, 50, 4, 4);
+	input_set_abs_params(input_dev, ABS_Y, -50, 50, 4, 4);
+
+	for (bp = twidjoy_buttons; bp->bitmask; bp++)
 		for (i = 0; i < bp->bitmask; i++)
-			set_bit(bp->buttons[i], twidjoy->dev.keybit);
-	}
-
-	twidjoy->dev.absbit[0] = BIT(ABS_X) | BIT(ABS_Y);
-
-	for (i = 0; i < 2; i++) {
-		twidjoy->dev.absmax[ABS_X+i] =  50;
-		twidjoy->dev.absmin[ABS_X+i] = -50;
-
-		/* TODO: arndt 20010708: Are these values appropriate? */
-		twidjoy->dev.absfuzz[ABS_X+i] = 4;
-		twidjoy->dev.absflat[ABS_X+i] = 4;
-	}
-
-	twidjoy->dev.private = twidjoy;
+			set_bit(bp->buttons[i], input_dev->keybit);
 
 	serio_set_drvdata(serio, twidjoy);
 
 	err = serio_open(serio, drv);
-	if (err) {
-		serio_set_drvdata(serio, NULL);
-		kfree(twidjoy);
-		return err;
-	}
-
-	input_register_device(&twidjoy->dev);
-
-	printk(KERN_INFO "input: %s on %s\n", twidjoy_name, serio->phys);
+	if (err)
+		goto fail;
 
+	input_register_device(twidjoy->dev);
 	return 0;
+
+ fail:	serio_set_drvdata(serio, NULL);
+	input_free_device(input_dev);
+	kfree(twidjoy);
+	return err;
 }
 
 /*

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/input/joystick/twidjoy.c b/drivers/input/joystick/twidjoy.c
new file mode 100644
index 000000000000..0379bc166525
--- /dev/null
+++ b/drivers/input/joystick/twidjoy.c
@@ -0,0 +1,296 @@
+/*
+ * $Id: twidjoy.c,v 1.5 2002/01/22 20:31:53 vojtech Exp $
+ *
+ *  derived from CVS-ID "stinger.c,v 1.5 2001/05/29 12:57:18 vojtech Exp"
+ *
+ *  Copyright (c) 2001 Arndt Schoenewald
+ *  Copyright (c) 2000-2001 Vojtech Pavlik
+ *  Copyright (c) 2000 Mark Fletcher
+ *
+ *  Sponsored by Quelltext AG (http://www.quelltext-ag.de), Dortmund, Germany
+ */
+
+/*
+ * Driver to use Handykey's Twiddler (the first edition, i.e. the one with
+ * the RS232 interface) as a joystick under Linux
+ *
+ * The Twiddler is a one-handed chording keyboard featuring twelve buttons on
+ * the front, six buttons on the top, and a built-in tilt sensor. The buttons
+ * on the front, which are grouped as four rows of three buttons, are pressed
+ * by the four fingers (this implies only one button per row can be held down
+ * at the same time) and the buttons on the top are for the thumb. The tilt
+ * sensor delivers X and Y axis data depending on how the Twiddler is held.
+ * Additional information can be found at http://www.handykey.com.
+ *
+ * This driver does not use the Twiddler for its intended purpose, i.e. as
+ * a chording keyboard, but as a joystick: pressing and releasing a button
+ * immediately sends a corresponding button event, and tilting it generates
+ * corresponding ABS_X and ABS_Y events. This turns the Twiddler into a game
+ * controller with amazing 18 buttons :-)
+ *
+ * Note: The Twiddler2 (the successor of the Twiddler that connects directly
+ * to the PS/2 keyboard and mouse ports) is NOT supported by this driver!
+ *
+ * For questions or feedback regarding this driver module please contact:
+ * Arndt Schoenewald <arndt@quelltext.com>
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/serio.h>
+#include <linux/init.h>
+
+#define DRIVER_DESC	"Handykey Twiddler keyboard as a joystick driver"
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
+
+/*
+ * Constants.
+ */
+
+#define TWIDJOY_MAX_LENGTH 5
+
+static char *twidjoy_name = "Handykey Twiddler";
+
+static struct twidjoy_button_spec {
+	int bitshift;
+	int bitmask;
+	int buttons[3];
+}
+twidjoy_buttons[] = {
+	{  0, 3, { BTN_A,      BTN_B,     BTN_C    } },
+	{  2, 3, { BTN_X,      BTN_Y,     BTN_Z    } },
+	{  4, 3, { BTN_TL,     BTN_TR,    BTN_TR2  } },
+	{  6, 3, { BTN_SELECT, BTN_START, BTN_MODE } },
+	{  8, 1, { BTN_BASE5                       } },
+	{  9, 1, { BTN_BASE                        } },
+	{ 10, 1, { BTN_BASE3                       } },
+	{ 11, 1, { BTN_BASE4                       } },
+	{ 12, 1, { BTN_BASE2                       } },
+	{ 13, 1, { BTN_BASE6                       } },
+	{ 0,  0, { 0                               } }
+};
+
+/*
+ * Per-Twiddler data.
+ */
+
+struct twidjoy {
+	struct input_dev dev;
+	int idx;
+	unsigned char data[TWIDJOY_MAX_LENGTH];
+	char phys[32];
+};
+
+/*
+ * twidjoy_process_packet() decodes packets the driver receives from the
+ * Twiddler. It updates the data accordingly.
+ */
+
+static void twidjoy_process_packet(struct twidjoy *twidjoy, struct pt_regs *regs)
+{
+	if (twidjoy->idx == TWIDJOY_MAX_LENGTH) {
+		struct input_dev *dev = &twidjoy->dev;
+		unsigned char *data = twidjoy->data;
+		struct twidjoy_button_spec *bp;
+		int button_bits, abs_x, abs_y;
+
+		button_bits = ((data[1] & 0x7f) << 7) | (data[0] & 0x7f);
+
+		input_regs(dev, regs);
+
+		for (bp = twidjoy_buttons; bp->bitmask; bp++) {
+			int value = (button_bits & (bp->bitmask << bp->bitshift)) >> bp->bitshift;
+			int i;
+
+			for (i = 0; i < bp->bitmask; i++)
+				input_report_key(dev, bp->buttons[i], i+1 == value);
+		}
+
+		abs_x = ((data[4] & 0x07) << 5) | ((data[3] & 0x7C) >> 2);
+		if (data[4] & 0x08) abs_x -= 256;
+
+		abs_y = ((data[3] & 0x01) << 7) | ((data[2] & 0x7F) >> 0);
+		if (data[3] & 0x02) abs_y -= 256;
+
+		input_report_abs(dev, ABS_X, -abs_x);
+		input_report_abs(dev, ABS_Y, +abs_y);
+
+		input_sync(dev);
+	}
+
+	return;
+}
+
+/*
+ * twidjoy_interrupt() is called by the low level driver when characters
+ * are ready for us. We then buffer them for further processing, or call the
+ * packet processing routine.
+ */
+
+static irqreturn_t twidjoy_interrupt(struct serio *serio, unsigned char data, unsigned int flags, struct pt_regs *regs)
+{
+	struct twidjoy *twidjoy = serio_get_drvdata(serio);
+
+	/* All Twiddler packets are 5 bytes. The fact that the first byte
+	 * has a MSB of 0 and all other bytes have a MSB of 1 can be used
+	 * to check and regain sync. */
+
+	if ((data & 0x80) == 0)
+		twidjoy->idx = 0;	/* this byte starts a new packet */
+	else if (twidjoy->idx == 0)
+		return IRQ_HANDLED;	/* wrong MSB -- ignore this byte */
+
+	if (twidjoy->idx < TWIDJOY_MAX_LENGTH)
+		twidjoy->data[twidjoy->idx++] = data;
+
+	if (twidjoy->idx == TWIDJOY_MAX_LENGTH) {
+		twidjoy_process_packet(twidjoy, regs);
+		twidjoy->idx = 0;
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * twidjoy_disconnect() is the opposite of twidjoy_connect()
+ */
+
+static void twidjoy_disconnect(struct serio *serio)
+{
+	struct twidjoy *twidjoy = serio_get_drvdata(serio);
+
+	input_unregister_device(&twidjoy->dev);
+	serio_close(serio);
+	serio_set_drvdata(serio, NULL);
+	kfree(twidjoy);
+}
+
+/*
+ * twidjoy_connect() is the routine that is called when someone adds a
+ * new serio device. It looks for the Twiddler, and if found, registers
+ * it as an input device.
+ */
+
+static int twidjoy_connect(struct serio *serio, struct serio_driver *drv)
+{
+	struct twidjoy_button_spec *bp;
+	struct twidjoy *twidjoy;
+	int i;
+	int err;
+
+	if (!(twidjoy = kmalloc(sizeof(struct twidjoy), GFP_KERNEL)))
+		return -ENOMEM;
+
+	memset(twidjoy, 0, sizeof(struct twidjoy));
+
+	sprintf(twidjoy->phys, "%s/input0", serio->phys);
+
+	init_input_dev(&twidjoy->dev);
+	twidjoy->dev.name = twidjoy_name;
+	twidjoy->dev.phys = twidjoy->phys;
+	twidjoy->dev.id.bustype = BUS_RS232;
+	twidjoy->dev.id.vendor = SERIO_TWIDJOY;
+	twidjoy->dev.id.product = 0x0001;
+	twidjoy->dev.id.version = 0x0100;
+	twidjoy->dev.dev = &serio->dev;
+
+	twidjoy->dev.evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
+
+	for (bp = twidjoy_buttons; bp->bitmask; bp++) {
+		for (i = 0; i < bp->bitmask; i++)
+			set_bit(bp->buttons[i], twidjoy->dev.keybit);
+	}
+
+	twidjoy->dev.absbit[0] = BIT(ABS_X) | BIT(ABS_Y);
+
+	for (i = 0; i < 2; i++) {
+		twidjoy->dev.absmax[ABS_X+i] =  50;
+		twidjoy->dev.absmin[ABS_X+i] = -50;
+
+		/* TODO: arndt 20010708: Are these values appropriate? */
+		twidjoy->dev.absfuzz[ABS_X+i] = 4;
+		twidjoy->dev.absflat[ABS_X+i] = 4;
+	}
+
+	twidjoy->dev.private = twidjoy;
+
+	serio_set_drvdata(serio, twidjoy);
+
+	err = serio_open(serio, drv);
+	if (err) {
+		serio_set_drvdata(serio, NULL);
+		kfree(twidjoy);
+		return err;
+	}
+
+	input_register_device(&twidjoy->dev);
+
+	printk(KERN_INFO "input: %s on %s\n", twidjoy_name, serio->phys);
+
+	return 0;
+}
+
+/*
+ * The serio driver structure.
+ */
+
+static struct serio_device_id twidjoy_serio_ids[] = {
+	{
+		.type	= SERIO_RS232,
+		.proto	= SERIO_TWIDJOY,
+		.id	= SERIO_ANY,
+		.extra	= SERIO_ANY,
+	},
+	{ 0 }
+};
+
+MODULE_DEVICE_TABLE(serio, twidjoy_serio_ids);
+
+static struct serio_driver twidjoy_drv = {
+	.driver		= {
+		.name	= "twidjoy",
+	},
+	.description	= DRIVER_DESC,
+	.id_table	= twidjoy_serio_ids,
+	.interrupt	= twidjoy_interrupt,
+	.connect	= twidjoy_connect,
+	.disconnect	= twidjoy_disconnect,
+};
+
+/*
+ * The functions for inserting/removing us as a module.
+ */
+
+int __init twidjoy_init(void)
+{
+	serio_register_driver(&twidjoy_drv);
+	return 0;
+}
+
+void __exit twidjoy_exit(void)
+{
+	serio_unregister_driver(&twidjoy_drv);
+}
+
+module_init(twidjoy_init);
+module_exit(twidjoy_exit);
