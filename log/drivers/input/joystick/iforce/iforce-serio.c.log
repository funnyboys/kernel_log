commit 6d45d3e08b7460d8ae4199a71a5ad271b0d98f83
Author: Tim Schumacher <timschumi@gmx.de>
Date:   Sun Jul 14 14:25:59 2019 -0700

    Input: iforce - remove empty multiline comments
    
    Those are remnants of the SPDX identifier migration, which haven't been
    removed properly.
    
    Signed-off-by: Tim Schumacher <timschumi@gmx.de>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/joystick/iforce/iforce-serio.c b/drivers/input/joystick/iforce/iforce-serio.c
index bbe31e0b759f..f95a81b9fac7 100644
--- a/drivers/input/joystick/iforce/iforce-serio.c
+++ b/drivers/input/joystick/iforce/iforce-serio.c
@@ -6,9 +6,6 @@
  *  USB/RS232 I-Force joysticks and wheels.
  */
 
-/*
- */
-
 #include <linux/serio.h>
 #include "iforce.h"
 

commit ecb41832bd2a7a3f8ac93527cec5e51e3827daed
Merge: d38b6cf50a6b 0ecfebd2b524
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Mon Jul 15 09:42:32 2019 -0700

    Merge tag 'v5.2' into next
    
    Sync up with mainline to resolve conflicts in iforce driver.

commit 8624dfd10a3bb3ea3d8a959e17f8951f1b03d68d
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Aug 10 13:52:31 2018 -0700

    Input: iforce - drop couple of temps from transport code
    
    Transport initialization code now deals mostly with transport-specific
    data, so we can drop couple of temporary variables.
    
    Tested-by: Tim Schumacher <timschumi@gmx.de>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/joystick/iforce/iforce-serio.c b/drivers/input/joystick/iforce/iforce-serio.c
index 277522d0f324..e7692a38591e 100644
--- a/drivers/input/joystick/iforce/iforce-serio.c
+++ b/drivers/input/joystick/iforce/iforce-serio.c
@@ -204,16 +204,13 @@ static irqreturn_t iforce_serio_irq(struct serio *serio,
 static int iforce_serio_connect(struct serio *serio, struct serio_driver *drv)
 {
 	struct iforce_serio *iforce_serio;
-	struct iforce *iforce;
 	int err;
 
 	iforce_serio = kzalloc(sizeof(*iforce_serio), GFP_KERNEL);
 	if (!iforce_serio)
 		return -ENOMEM;
 
-	iforce = &iforce_serio->iforce;
-
-	iforce->xport_ops = &iforce_serio_xport_ops;
+	iforce_serio->iforce.xport_ops = &iforce_serio_xport_ops;
 
 	iforce_serio->serio = serio;
 	serio_set_drvdata(serio, iforce_serio);
@@ -222,7 +219,7 @@ static int iforce_serio_connect(struct serio *serio, struct serio_driver *drv)
 	if (err)
 		goto fail1;
 
-	err = iforce_init_device(&serio->dev, BUS_RS232, iforce);
+	err = iforce_init_device(&serio->dev, BUS_RS232, &iforce_serio->iforce);
 	if (err)
 		goto fail2;
 

commit 2178db65cd9c81c790cbf7504e90650750c3b467
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Aug 10 13:48:16 2018 -0700

    Input: iforce - drop bus type from iforce structure
    
    It is not needed anymore as behavior is controlled by the transport
    operations set up for given device.
    
    Tested-by: Tim Schumacher <timschumi@gmx.de>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/joystick/iforce/iforce-serio.c b/drivers/input/joystick/iforce/iforce-serio.c
index c73d988cbc92..277522d0f324 100644
--- a/drivers/input/joystick/iforce/iforce-serio.c
+++ b/drivers/input/joystick/iforce/iforce-serio.c
@@ -214,7 +214,6 @@ static int iforce_serio_connect(struct serio *serio, struct serio_driver *drv)
 	iforce = &iforce_serio->iforce;
 
 	iforce->xport_ops = &iforce_serio_xport_ops;
-	iforce->bus = IFORCE_232;
 
 	iforce_serio->serio = serio;
 	serio_set_drvdata(serio, iforce_serio);

commit dfad2b17935d70d7dc3830c4986344b3f2669c62
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Aug 10 13:44:52 2018 -0700

    Input: iforce - use DMA-safe buffores for USB transfers
    
    USB transport has to use cache line-aligned buffers for transfers to avoid
    DMA issues; serio doe snot have such restrictions. Let's move "data_in"
    buffer from main driver structure into transport modules and make sure USB
    requirements are respected.
    
    Tested-by: Tim Schumacher <timschumi@gmx.de>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/joystick/iforce/iforce-serio.c b/drivers/input/joystick/iforce/iforce-serio.c
index be44aed551f7..c73d988cbc92 100644
--- a/drivers/input/joystick/iforce/iforce-serio.c
+++ b/drivers/input/joystick/iforce/iforce-serio.c
@@ -33,6 +33,7 @@ struct iforce_serio {
 	u8 expect_packet;
 	u8 cmd_response[IFORCE_MAX_LENGTH];
 	u8 cmd_response_len;
+	u8 data_in[IFORCE_MAX_LENGTH];
 };
 
 static void iforce_serio_xmit(struct iforce *iforce)
@@ -169,7 +170,7 @@ static irqreturn_t iforce_serio_irq(struct serio *serio,
 	}
 
 	if (iforce_serio->idx < iforce_serio->len) {
-		iforce->data[iforce_serio->idx++] = data;
+		iforce_serio->data_in[iforce_serio->idx++] = data;
 		iforce_serio->csum += data;
 		goto out;
 	}
@@ -178,15 +179,16 @@ static irqreturn_t iforce_serio_irq(struct serio *serio,
 		/* Handle command completion */
 		if (iforce_serio->expect_packet == iforce_serio->id) {
 			iforce_serio->expect_packet = 0;
-			memcpy(iforce_serio->cmd_response, iforce->data,
-			       IFORCE_MAX_LENGTH);
+			memcpy(iforce_serio->cmd_response,
+			       iforce_serio->data_in, IFORCE_MAX_LENGTH);
 			iforce_serio->cmd_response_len = iforce_serio->len;
 
 			/* Signal that command is done */
 			wake_up(&iforce->wait);
 		} else if (likely(iforce->type)) {
 			iforce_process_packet(iforce, iforce_serio->id,
-					      iforce->data, iforce_serio->len);
+					      iforce_serio->data_in,
+					      iforce_serio->len);
 		}
 
 		iforce_serio->pkt = 0;

commit 6ac0aec6b0a651d64eef759fddf17d9145b51033
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Thu Aug 9 17:28:35 2018 -0700

    Input: iforce - allow callers supply data buffer when fetching device IDs
    
    We want to move buffer handling into transport layers as the properties of
    buffers (DMA-safety, alignment, etc) are different for different
    transports. To allow this, let's allow caller to specify their own buffers
    for the results of iforce_get_id_packet() and let transport drivers to
    figure what buffers they need to use for transfers.
    
    Tested-by: Tim Schumacher <timschumi@gmx.de>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/joystick/iforce/iforce-serio.c b/drivers/input/joystick/iforce/iforce-serio.c
index 8d7eba9c9f0e..be44aed551f7 100644
--- a/drivers/input/joystick/iforce/iforce-serio.c
+++ b/drivers/input/joystick/iforce/iforce-serio.c
@@ -31,6 +31,8 @@ struct iforce_serio {
 	int idx, pkt, len, id;
 	u8 csum;
 	u8 expect_packet;
+	u8 cmd_response[IFORCE_MAX_LENGTH];
+	u8 cmd_response_len;
 };
 
 static void iforce_serio_xmit(struct iforce *iforce)
@@ -81,24 +83,34 @@ static void iforce_serio_xmit(struct iforce *iforce)
 	spin_unlock_irqrestore(&iforce->xmit_lock, flags);
 }
 
-static int iforce_serio_get_id(struct iforce *iforce, u8 *packet)
+static int iforce_serio_get_id(struct iforce *iforce, u8 id,
+			       u8 *response_data, size_t *response_len)
 {
 	struct iforce_serio *iforce_serio = container_of(iforce,
 							 struct iforce_serio,
 							 iforce);
 
 	iforce_serio->expect_packet = HI(FF_CMD_QUERY);
-	iforce_send_packet(iforce, FF_CMD_QUERY, packet);
+	iforce_serio->cmd_response_len = 0;
+
+	iforce_send_packet(iforce, FF_CMD_QUERY, &id);
 
 	wait_event_interruptible_timeout(iforce->wait,
 					 !iforce_serio->expect_packet, HZ);
 
 	if (iforce_serio->expect_packet) {
 		iforce_serio->expect_packet = 0;
-		return -EIO;
+		return -ETIMEDOUT;
 	}
 
-	return -(iforce->edata[0] != packet[0]);
+	if (iforce_serio->cmd_response[0] != id)
+		return -EIO;
+
+	memcpy(response_data, iforce_serio->cmd_response,
+	       iforce_serio->cmd_response_len);
+	*response_len = iforce_serio->cmd_response_len;
+
+	return 0;
 }
 
 static int iforce_serio_start_io(struct iforce *iforce)
@@ -127,7 +139,7 @@ static void iforce_serio_write_wakeup(struct serio *serio)
 }
 
 static irqreturn_t iforce_serio_irq(struct serio *serio,
-		unsigned char data, unsigned int flags)
+				    unsigned char data, unsigned int flags)
 {
 	struct iforce_serio *iforce_serio = serio_get_drvdata(serio);
 	struct iforce *iforce = &iforce_serio->iforce;
@@ -166,9 +178,9 @@ static irqreturn_t iforce_serio_irq(struct serio *serio,
 		/* Handle command completion */
 		if (iforce_serio->expect_packet == iforce_serio->id) {
 			iforce_serio->expect_packet = 0;
-			iforce->ecmd = (iforce_serio->id << 8) |
-					iforce_serio->idx;
-			memcpy(iforce->edata, iforce->data, IFORCE_MAX_LENGTH);
+			memcpy(iforce_serio->cmd_response, iforce->data,
+			       IFORCE_MAX_LENGTH);
+			iforce_serio->cmd_response_len = iforce_serio->len;
 
 			/* Signal that command is done */
 			wake_up(&iforce->wait);

commit 633354d1910262f2a3262797572ff72da461379e
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Aug 10 10:34:13 2018 -0700

    Input: iforce - only call iforce_process_packet() if initialized
    
    It is excessive to check if device is fully initialized in
    iforce_process_packet(), as for USB-conected devices we do not start
    collecting reports until the device is fully initialized.
    
    Let's change serio transport code to not call iforce_process_packet()
    until device initialization is done.
    
    Tested-by: Tim Schumacher <timschumi@gmx.de>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/joystick/iforce/iforce-serio.c b/drivers/input/joystick/iforce/iforce-serio.c
index 0dd95d145e85..8d7eba9c9f0e 100644
--- a/drivers/input/joystick/iforce/iforce-serio.c
+++ b/drivers/input/joystick/iforce/iforce-serio.c
@@ -172,7 +172,7 @@ static irqreturn_t iforce_serio_irq(struct serio *serio,
 
 			/* Signal that command is done */
 			wake_up(&iforce->wait);
-		} else {
+		} else if (likely(iforce->type)) {
 			iforce_process_packet(iforce, iforce_serio->id,
 					      iforce->data, iforce_serio->len);
 		}

commit 2880dcf9cfc28a3803aee4c964743adbb66b0f1a
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Aug 10 10:21:13 2018 -0700

    Input: iforce - signal command completion from transport code
    
    Signalling command completion from iforce_process_packet() does
    not make sense, as not all transport use the same data path for
    both commands and motion data form the device, that is why USB
    code already has to signal command completion iforce_usb_out().
    
    Let's move signalling completion into individual transport
    modules.
    
    Tested-by: Tim Schumacher <timschumi@gmx.de>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/joystick/iforce/iforce-serio.c b/drivers/input/joystick/iforce/iforce-serio.c
index f8bf7d2aa59f..0dd95d145e85 100644
--- a/drivers/input/joystick/iforce/iforce-serio.c
+++ b/drivers/input/joystick/iforce/iforce-serio.c
@@ -169,10 +169,13 @@ static irqreturn_t iforce_serio_irq(struct serio *serio,
 			iforce->ecmd = (iforce_serio->id << 8) |
 					iforce_serio->idx;
 			memcpy(iforce->edata, iforce->data, IFORCE_MAX_LENGTH);
-		}
 
-		iforce_process_packet(iforce, iforce_serio->id,
-				      iforce->data, iforce_serio->len);
+			/* Signal that command is done */
+			wake_up(&iforce->wait);
+		} else {
+			iforce_process_packet(iforce, iforce_serio->id,
+					      iforce->data, iforce_serio->len);
+		}
 
 		iforce_serio->pkt = 0;
 		iforce_serio->id  = 0;

commit d3cc100069f945a392d6cde5ea326bb686418193
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Thu Aug 9 17:50:39 2018 -0700

    Input: iforce - do not combine arguments for iforce_process_packet()
    
    Current code combines packet type and data length into single argument to
    iforce_process_packet() and then has to untangle it. It is much clearer to
    simply use separate arguments.
    
    Tested-by: Tim Schumacher <timschumi@gmx.de>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/joystick/iforce/iforce-serio.c b/drivers/input/joystick/iforce/iforce-serio.c
index 6c6411fbdc32..f8bf7d2aa59f 100644
--- a/drivers/input/joystick/iforce/iforce-serio.c
+++ b/drivers/input/joystick/iforce/iforce-serio.c
@@ -163,16 +163,16 @@ static irqreturn_t iforce_serio_irq(struct serio *serio,
 	}
 
 	if (iforce_serio->idx == iforce_serio->len) {
-		u16 cmd = (iforce_serio->id << 8) | iforce_serio->idx;
-
 		/* Handle command completion */
 		if (iforce_serio->expect_packet == iforce_serio->id) {
 			iforce_serio->expect_packet = 0;
-			iforce->ecmd = cmd;
+			iforce->ecmd = (iforce_serio->id << 8) |
+					iforce_serio->idx;
 			memcpy(iforce->edata, iforce->data, IFORCE_MAX_LENGTH);
 		}
 
-		iforce_process_packet(iforce, cmd, iforce->data);
+		iforce_process_packet(iforce, iforce_serio->id,
+				      iforce->data, iforce_serio->len);
 
 		iforce_serio->pkt = 0;
 		iforce_serio->id  = 0;

commit 4f99de6d9d57d29b10f132490034aa21b7ba184f
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Jul 24 17:32:24 2018 -0700

    Input: iforce - split into core and transport modules
    
    Now that we have moved enough transport details into separate source files
    we can change them into transport modules so that they are only loaded when
    needed.
    
    Tested-by: Tim Schumacher <timschumi@gmx.de>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/joystick/iforce/iforce-serio.c b/drivers/input/joystick/iforce/iforce-serio.c
index 6ff1bbeeb494..6c6411fbdc32 100644
--- a/drivers/input/joystick/iforce/iforce-serio.c
+++ b/drivers/input/joystick/iforce/iforce-serio.c
@@ -21,6 +21,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
 
+#include <linux/serio.h>
 #include "iforce.h"
 
 struct iforce_serio {
@@ -250,3 +251,9 @@ struct serio_driver iforce_serio_drv = {
 	.connect	= iforce_serio_connect,
 	.disconnect	= iforce_serio_disconnect,
 };
+
+module_serio_driver(iforce_serio_drv);
+
+MODULE_AUTHOR("Vojtech Pavlik <vojtech@ucw.cz>, Johann Deneux <johann.deneux@gmail.com>");
+MODULE_DESCRIPTION("RS232 I-Force joysticks and wheels driver");
+MODULE_LICENSE("GPL");

commit 81fd43132684605b21600fa5e27f23034e18dfd3
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Aug 3 16:27:45 2018 -0700

    Input: iforce - move transport data into transport modules
    
    This moves transport-specific data from main iforce structure into
    transport modules.
    
    Tested-by: Tim Schumacher <timschumi@gmx.de>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/joystick/iforce/iforce-serio.c b/drivers/input/joystick/iforce/iforce-serio.c
index b5dea273f98e..6ff1bbeeb494 100644
--- a/drivers/input/joystick/iforce/iforce-serio.c
+++ b/drivers/input/joystick/iforce/iforce-serio.c
@@ -23,8 +23,20 @@
 
 #include "iforce.h"
 
+struct iforce_serio {
+	struct iforce iforce;
+
+	struct serio *serio;
+	int idx, pkt, len, id;
+	u8 csum;
+	u8 expect_packet;
+};
+
 static void iforce_serio_xmit(struct iforce *iforce)
 {
+	struct iforce_serio *iforce_serio = container_of(iforce,
+							 struct iforce_serio,
+							 iforce);
 	unsigned char cs;
 	int i;
 	unsigned long flags;
@@ -45,19 +57,20 @@ static void iforce_serio_xmit(struct iforce *iforce)
 
 	cs = 0x2b;
 
-	serio_write(iforce->serio, 0x2b);
+	serio_write(iforce_serio->serio, 0x2b);
 
-	serio_write(iforce->serio, iforce->xmit.buf[iforce->xmit.tail]);
+	serio_write(iforce_serio->serio, iforce->xmit.buf[iforce->xmit.tail]);
 	cs ^= iforce->xmit.buf[iforce->xmit.tail];
 	XMIT_INC(iforce->xmit.tail, 1);
 
 	for (i=iforce->xmit.buf[iforce->xmit.tail]; i >= 0; --i) {
-		serio_write(iforce->serio, iforce->xmit.buf[iforce->xmit.tail]);
+		serio_write(iforce_serio->serio,
+			    iforce->xmit.buf[iforce->xmit.tail]);
 		cs ^= iforce->xmit.buf[iforce->xmit.tail];
 		XMIT_INC(iforce->xmit.tail, 1);
 	}
 
-	serio_write(iforce->serio, cs);
+	serio_write(iforce_serio->serio, cs);
 
 	if (test_and_clear_bit(IFORCE_XMIT_AGAIN, iforce->xmit_flags))
 		goto again;
@@ -69,14 +82,18 @@ static void iforce_serio_xmit(struct iforce *iforce)
 
 static int iforce_serio_get_id(struct iforce *iforce, u8 *packet)
 {
-	iforce->expect_packet = FF_CMD_QUERY;
+	struct iforce_serio *iforce_serio = container_of(iforce,
+							 struct iforce_serio,
+							 iforce);
+
+	iforce_serio->expect_packet = HI(FF_CMD_QUERY);
 	iforce_send_packet(iforce, FF_CMD_QUERY, packet);
 
 	wait_event_interruptible_timeout(iforce->wait,
-					 !iforce->expect_packet, HZ);
+					 !iforce_serio->expect_packet, HZ);
 
-	if (iforce->expect_packet) {
-		iforce->expect_packet = 0;
+	if (iforce_serio->expect_packet) {
+		iforce_serio->expect_packet = 0;
 		return -EIO;
 	}
 
@@ -111,54 +128,56 @@ static void iforce_serio_write_wakeup(struct serio *serio)
 static irqreturn_t iforce_serio_irq(struct serio *serio,
 		unsigned char data, unsigned int flags)
 {
-	struct iforce *iforce = serio_get_drvdata(serio);
+	struct iforce_serio *iforce_serio = serio_get_drvdata(serio);
+	struct iforce *iforce = &iforce_serio->iforce;
 
-	if (!iforce->pkt) {
+	if (!iforce_serio->pkt) {
 		if (data == 0x2b)
-			iforce->pkt = 1;
+			iforce_serio->pkt = 1;
 		goto out;
 	}
 
-	if (!iforce->id) {
+	if (!iforce_serio->id) {
 		if (data > 3 && data != 0xff)
-			iforce->pkt = 0;
+			iforce_serio->pkt = 0;
 		else
-			iforce->id = data;
+			iforce_serio->id = data;
 		goto out;
 	}
 
-	if (!iforce->len) {
+	if (!iforce_serio->len) {
 		if (data > IFORCE_MAX_LENGTH) {
-			iforce->pkt = 0;
-			iforce->id = 0;
+			iforce_serio->pkt = 0;
+			iforce_serio->id = 0;
 		} else {
-			iforce->len = data;
+			iforce_serio->len = data;
 		}
 		goto out;
 	}
 
-	if (iforce->idx < iforce->len) {
-		iforce->csum += iforce->data[iforce->idx++] = data;
+	if (iforce_serio->idx < iforce_serio->len) {
+		iforce->data[iforce_serio->idx++] = data;
+		iforce_serio->csum += data;
 		goto out;
 	}
 
-	if (iforce->idx == iforce->len) {
-		u16 cmd = (iforce->id << 8) | iforce->idx;
+	if (iforce_serio->idx == iforce_serio->len) {
+		u16 cmd = (iforce_serio->id << 8) | iforce_serio->idx;
 
 		/* Handle command completion */
-		if (HI(iforce->expect_packet) == HI(cmd)) {
-			iforce->expect_packet = 0;
+		if (iforce_serio->expect_packet == iforce_serio->id) {
+			iforce_serio->expect_packet = 0;
 			iforce->ecmd = cmd;
 			memcpy(iforce->edata, iforce->data, IFORCE_MAX_LENGTH);
 		}
 
 		iforce_process_packet(iforce, cmd, iforce->data);
 
-		iforce->pkt = 0;
-		iforce->id  = 0;
-		iforce->len = 0;
-		iforce->idx = 0;
-		iforce->csum = 0;
+		iforce_serio->pkt = 0;
+		iforce_serio->id  = 0;
+		iforce_serio->len = 0;
+		iforce_serio->idx = 0;
+		iforce_serio->csum = 0;
 	}
 out:
 	return IRQ_HANDLED;
@@ -166,18 +185,21 @@ static irqreturn_t iforce_serio_irq(struct serio *serio,
 
 static int iforce_serio_connect(struct serio *serio, struct serio_driver *drv)
 {
+	struct iforce_serio *iforce_serio;
 	struct iforce *iforce;
 	int err;
 
-	iforce = kzalloc(sizeof(struct iforce), GFP_KERNEL);
-	if (!iforce)
+	iforce_serio = kzalloc(sizeof(*iforce_serio), GFP_KERNEL);
+	if (!iforce_serio)
 		return -ENOMEM;
 
+	iforce = &iforce_serio->iforce;
+
 	iforce->xport_ops = &iforce_serio_xport_ops;
 	iforce->bus = IFORCE_232;
-	iforce->serio = serio;
 
-	serio_set_drvdata(serio, iforce);
+	iforce_serio->serio = serio;
+	serio_set_drvdata(serio, iforce_serio);
 
 	err = serio_open(serio, drv);
 	if (err)
@@ -191,18 +213,18 @@ static int iforce_serio_connect(struct serio *serio, struct serio_driver *drv)
 
  fail2:	serio_close(serio);
  fail1:	serio_set_drvdata(serio, NULL);
-	kfree(iforce);
+	kfree(iforce_serio);
 	return err;
 }
 
 static void iforce_serio_disconnect(struct serio *serio)
 {
-	struct iforce *iforce = serio_get_drvdata(serio);
+	struct iforce_serio *iforce_serio = serio_get_drvdata(serio);
 
-	input_unregister_device(iforce->dev);
+	input_unregister_device(iforce_serio->iforce.dev);
 	serio_close(serio);
 	serio_set_drvdata(serio, NULL);
-	kfree(iforce);
+	kfree(iforce_serio);
 }
 
 static const struct serio_device_id iforce_serio_ids[] = {

commit 501025df2e774ea840276e08d2a0aead606ffa52
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Aug 3 15:34:41 2018 -0700

    Input: iforce - add bus type and parent arguments to iforce_init_device()
    
    Note that the parent device for the USB-connected controllers is now
    USB interface instead of USB device.
    
    Tested-by: Tim Schumacher <timschumi@gmx.de>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/joystick/iforce/iforce-serio.c b/drivers/input/joystick/iforce/iforce-serio.c
index afc7521b430d..b5dea273f98e 100644
--- a/drivers/input/joystick/iforce/iforce-serio.c
+++ b/drivers/input/joystick/iforce/iforce-serio.c
@@ -183,7 +183,7 @@ static int iforce_serio_connect(struct serio *serio, struct serio_driver *drv)
 	if (err)
 		goto fail1;
 
-	err = iforce_init_device(iforce);
+	err = iforce_init_device(&serio->dev, BUS_RS232, iforce);
 	if (err)
 		goto fail2;
 

commit 05ca38283afa5ad11de88395cf0b28c192766bc1
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Aug 3 15:26:00 2018 -0700

    Input: iforce - introduce start and stop io transport ops
    
    Add start_io() and stop_io() transport methods so that core
    does not have to know the details.
    
    Tested-by: Tim Schumacher <timschumi@gmx.de>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/joystick/iforce/iforce-serio.c b/drivers/input/joystick/iforce/iforce-serio.c
index eca2f6eca7f0..afc7521b430d 100644
--- a/drivers/input/joystick/iforce/iforce-serio.c
+++ b/drivers/input/joystick/iforce/iforce-serio.c
@@ -83,9 +83,22 @@ static int iforce_serio_get_id(struct iforce *iforce, u8 *packet)
 	return -(iforce->edata[0] != packet[0]);
 }
 
+static int iforce_serio_start_io(struct iforce *iforce)
+{
+	/* No special handling required */
+	return 0;
+}
+
+static void iforce_serio_stop_io(struct iforce *iforce)
+{
+	//TODO: Wait for the last packets to be sent
+}
+
 static const struct iforce_xport_ops iforce_serio_xport_ops = {
 	.xmit		= iforce_serio_xmit,
 	.get_id		= iforce_serio_get_id,
+	.start_io	= iforce_serio_start_io,
+	.stop_io	= iforce_serio_stop_io,
 };
 
 static void iforce_serio_write_wakeup(struct serio *serio)

commit 9381758466f9939d84f6f70097c8883da9639379
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Aug 3 15:23:40 2018 -0700

    Input: iforce - move command completion handling to serio code
    
    Continue teasing apart protocol-specific bits from core into transport
    modules. This time move RS232-specific command completion handling
    from core to iforce-serio module.
    
    Tested-by: Tim Schumacher <timschumi@gmx.de>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/joystick/iforce/iforce-serio.c b/drivers/input/joystick/iforce/iforce-serio.c
index fa45ce425d47..eca2f6eca7f0 100644
--- a/drivers/input/joystick/iforce/iforce-serio.c
+++ b/drivers/input/joystick/iforce/iforce-serio.c
@@ -130,7 +130,17 @@ static irqreturn_t iforce_serio_irq(struct serio *serio,
 	}
 
 	if (iforce->idx == iforce->len) {
-		iforce_process_packet(iforce, (iforce->id << 8) | iforce->idx, iforce->data);
+		u16 cmd = (iforce->id << 8) | iforce->idx;
+
+		/* Handle command completion */
+		if (HI(iforce->expect_packet) == HI(cmd)) {
+			iforce->expect_packet = 0;
+			iforce->ecmd = cmd;
+			memcpy(iforce->edata, iforce->data, IFORCE_MAX_LENGTH);
+		}
+
+		iforce_process_packet(iforce, cmd, iforce->data);
+
 		iforce->pkt = 0;
 		iforce->id  = 0;
 		iforce->len = 0;

commit 2a1433ff08a1b23e3003483ee2883d327f78db9e
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Thu Jul 26 17:49:34 2018 -0700

    Input: iforce - move get_id to the transport operations
    
    To avoid #ifdef-ing out parts of the code and having conditionals in normal
    control flow, let's define "get_id" transport method and move
    implementation into respective transport modules.
    
    Tested-by: Tim Schumacher <timschumi@gmx.de>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/joystick/iforce/iforce-serio.c b/drivers/input/joystick/iforce/iforce-serio.c
index c9469209f994..fa45ce425d47 100644
--- a/drivers/input/joystick/iforce/iforce-serio.c
+++ b/drivers/input/joystick/iforce/iforce-serio.c
@@ -67,8 +67,25 @@ static void iforce_serio_xmit(struct iforce *iforce)
 	spin_unlock_irqrestore(&iforce->xmit_lock, flags);
 }
 
+static int iforce_serio_get_id(struct iforce *iforce, u8 *packet)
+{
+	iforce->expect_packet = FF_CMD_QUERY;
+	iforce_send_packet(iforce, FF_CMD_QUERY, packet);
+
+	wait_event_interruptible_timeout(iforce->wait,
+					 !iforce->expect_packet, HZ);
+
+	if (iforce->expect_packet) {
+		iforce->expect_packet = 0;
+		return -EIO;
+	}
+
+	return -(iforce->edata[0] != packet[0]);
+}
+
 static const struct iforce_xport_ops iforce_serio_xport_ops = {
 	.xmit		= iforce_serio_xmit,
+	.get_id		= iforce_serio_get_id,
 };
 
 static void iforce_serio_write_wakeup(struct serio *serio)

commit 38d107690df7f0826adb5b53f4e87676859ff0a6
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Thu Jul 26 17:36:36 2018 -0700

    Input: iforce - introduce transport ops
    
    In order to tease apart the driver into core and transport modules, let's
    introduce transport operations and make "xmit" the very first one such
    operation.
    
    Tested-by: Tim Schumacher <timschumi@gmx.de>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/joystick/iforce/iforce-serio.c b/drivers/input/joystick/iforce/iforce-serio.c
index f4ba4a751fe0..c9469209f994 100644
--- a/drivers/input/joystick/iforce/iforce-serio.c
+++ b/drivers/input/joystick/iforce/iforce-serio.c
@@ -23,7 +23,7 @@
 
 #include "iforce.h"
 
-void iforce_serial_xmit(struct iforce *iforce)
+static void iforce_serio_xmit(struct iforce *iforce)
 {
 	unsigned char cs;
 	int i;
@@ -67,11 +67,15 @@ void iforce_serial_xmit(struct iforce *iforce)
 	spin_unlock_irqrestore(&iforce->xmit_lock, flags);
 }
 
+static const struct iforce_xport_ops iforce_serio_xport_ops = {
+	.xmit		= iforce_serio_xmit,
+};
+
 static void iforce_serio_write_wakeup(struct serio *serio)
 {
 	struct iforce *iforce = serio_get_drvdata(serio);
 
-	iforce_serial_xmit(iforce);
+	iforce_serio_xmit(iforce);
 }
 
 static irqreturn_t iforce_serio_irq(struct serio *serio,
@@ -129,6 +133,7 @@ static int iforce_serio_connect(struct serio *serio, struct serio_driver *drv)
 	if (!iforce)
 		return -ENOMEM;
 
+	iforce->xport_ops = &iforce_serio_xport_ops;
 	iforce->bus = IFORCE_232;
 	iforce->serio = serio;
 

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/input/joystick/iforce/iforce-serio.c b/drivers/input/joystick/iforce/iforce-serio.c
index f4ba4a751fe0..65a4fe26324f 100644
--- a/drivers/input/joystick/iforce/iforce-serio.c
+++ b/drivers/input/joystick/iforce/iforce-serio.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Copyright (c) 2000-2001 Vojtech Pavlik <vojtech@ucw.cz>
  *  Copyright (c) 2001, 2007 Johann Deneux <johann.deneux@gmail.com>
@@ -6,19 +7,6 @@
  */
 
 /*
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
 
 #include "iforce.h"

commit 179909ecafc3bae1f34289e88bacd45e391f0554
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Jul 24 11:38:14 2018 -0700

    Input: stop telling users to snail-mail Vojtech
    
    I do not think Vojtech wants snail mail these days (and he mentioned that
    nobody has ever sent him snail mail), and the address is not even valid
    anymore, so let's remove snail-mail instructions from the sources.
    
    Acked-by: Vojtech Pavlik <vojtech@suse.cz>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/joystick/iforce/iforce-serio.c b/drivers/input/joystick/iforce/iforce-serio.c
index 154e827b559b..f4ba4a751fe0 100644
--- a/drivers/input/joystick/iforce/iforce-serio.c
+++ b/drivers/input/joystick/iforce/iforce-serio.c
@@ -19,10 +19,6 @@
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- * Should you need to contact me, the author, you can do so either by
- * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
- * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
  */
 
 #include "iforce.h"

commit b9e8cbc437103b30f3289b3fe174c678c725258e
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Fri Aug 18 17:07:32 2017 -0700

    Input: iforce - constify serio_device_id
    
    serio_device_id are not supposed to change at runtime. All functions
    working with serio_device_id provided by <linux/serio.h> work with
    const serio_device_id. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/joystick/iforce/iforce-serio.c b/drivers/input/joystick/iforce/iforce-serio.c
index 46d5041d2d9d..154e827b559b 100644
--- a/drivers/input/joystick/iforce/iforce-serio.c
+++ b/drivers/input/joystick/iforce/iforce-serio.c
@@ -164,7 +164,7 @@ static void iforce_serio_disconnect(struct serio *serio)
 	kfree(iforce);
 }
 
-static struct serio_device_id iforce_serio_ids[] = {
+static const struct serio_device_id iforce_serio_ids[] = {
 	{
 		.type	= SERIO_RS232,
 		.proto	= SERIO_IFORCE,

commit d1659fcc59b21ec442564fedb67a5ad371f82380
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue May 20 12:17:39 2008 -0400

    Input: remove CVS keywords
    
    This patch removes CVS keywords that weren't updated for a long time
    from comments.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/joystick/iforce/iforce-serio.c b/drivers/input/joystick/iforce/iforce-serio.c
index 7b4bc19cef27..46d5041d2d9d 100644
--- a/drivers/input/joystick/iforce/iforce-serio.c
+++ b/drivers/input/joystick/iforce/iforce-serio.c
@@ -1,6 +1,4 @@
 /*
- * $Id: iforce-serio.c,v 1.4 2002/01/28 22:45:00 jdeneux Exp $
- *
  *  Copyright (c) 2000-2001 Vojtech Pavlik <vojtech@ucw.cz>
  *  Copyright (c) 2001, 2007 Johann Deneux <johann.deneux@gmail.com>
  *

commit 598972d4fb39c8a0826b396e45dc2a8c1dbe4f11
Author: Johann Deneux <johann.deneux@gmail.com>
Date:   Thu Apr 12 01:30:24 2007 -0400

    Input: iforce - use usb_kill_urb instead of usb_unlink_urb
    
    Using usb_unlink_urb can cause iforce_open to fail when called
    soon after iforce_release. Also updated my email address and
    replaced calls to printk() by dbg(), warn(), info(), err()...
    
    Signed-off-by: Johann Deneux <johann.deneux@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/joystick/iforce/iforce-serio.c b/drivers/input/joystick/iforce/iforce-serio.c
index ec4be535f483..7b4bc19cef27 100644
--- a/drivers/input/joystick/iforce/iforce-serio.c
+++ b/drivers/input/joystick/iforce/iforce-serio.c
@@ -2,7 +2,7 @@
  * $Id: iforce-serio.c,v 1.4 2002/01/28 22:45:00 jdeneux Exp $
  *
  *  Copyright (c) 2000-2001 Vojtech Pavlik <vojtech@ucw.cz>
- *  Copyright (c) 2001 Johann Deneux <deneux@ifrance.com>
+ *  Copyright (c) 2001, 2007 Johann Deneux <johann.deneux@gmail.com>
  *
  *  USB/RS232 I-Force joysticks and wheels.
  */

commit 127278ce2254c61f1346500374d61e33f74a8729
Author: Dmitry Torokhov <dtor@insightbb.com>
Date:   Sun Nov 5 22:40:09 2006 -0500

    Input: joysticks - handle errors when registering input devices
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/joystick/iforce/iforce-serio.c b/drivers/input/joystick/iforce/iforce-serio.c
index ca08f45c2040..ec4be535f483 100644
--- a/drivers/input/joystick/iforce/iforce-serio.c
+++ b/drivers/input/joystick/iforce/iforce-serio.c
@@ -141,21 +141,19 @@ static int iforce_serio_connect(struct serio *serio, struct serio_driver *drv)
 	serio_set_drvdata(serio, iforce);
 
 	err = serio_open(serio, drv);
-	if (err) {
-		serio_set_drvdata(serio, NULL);
-		kfree(iforce);
-		return err;
-	}
+	if (err)
+		goto fail1;
 
 	err = iforce_init_device(iforce);
-	if (err) {
-		serio_close(serio);
-		serio_set_drvdata(serio, NULL);
-		kfree(iforce);
-		return -ENODEV;
-	}
+	if (err)
+		goto fail2;
 
 	return 0;
+
+ fail2:	serio_close(serio);
+ fail1:	serio_set_drvdata(serio, NULL);
+	kfree(iforce);
+	return err;
 }
 
 static void iforce_serio_disconnect(struct serio *serio)

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/input/joystick/iforce/iforce-serio.c b/drivers/input/joystick/iforce/iforce-serio.c
index 64a78c515484..ca08f45c2040 100644
--- a/drivers/input/joystick/iforce/iforce-serio.c
+++ b/drivers/input/joystick/iforce/iforce-serio.c
@@ -81,7 +81,7 @@ static void iforce_serio_write_wakeup(struct serio *serio)
 }
 
 static irqreturn_t iforce_serio_irq(struct serio *serio,
-		unsigned char data, unsigned int flags, struct pt_regs *regs)
+		unsigned char data, unsigned int flags)
 {
 	struct iforce *iforce = serio_get_drvdata(serio);
 
@@ -115,7 +115,7 @@ static irqreturn_t iforce_serio_irq(struct serio *serio,
 	}
 
 	if (iforce->idx == iforce->len) {
-		iforce_process_packet(iforce, (iforce->id << 8) | iforce->idx, iforce->data, regs);
+		iforce_process_packet(iforce, (iforce->id << 8) | iforce->idx, iforce->data);
 		iforce->pkt = 0;
 		iforce->id  = 0;
 		iforce->len = 0;

commit 17dd3f0f7aa729a042af5d3318ff9b3e7781b45b
Author: Dmitry Torokhov <dtor_core@ameritech.net>
Date:   Thu Sep 15 02:01:52 2005 -0500

    [PATCH] drivers/input/joystick: convert to dynamic input_dev allocation
    
    Input: convert drivers/input/joystick to dynamic input_dev allocation
    
    This is required for input_dev sysfs integration
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/input/joystick/iforce/iforce-serio.c b/drivers/input/joystick/iforce/iforce-serio.c
index 11f51905cba7..64a78c515484 100644
--- a/drivers/input/joystick/iforce/iforce-serio.c
+++ b/drivers/input/joystick/iforce/iforce-serio.c
@@ -131,11 +131,10 @@ static int iforce_serio_connect(struct serio *serio, struct serio_driver *drv)
 	struct iforce *iforce;
 	int err;
 
-	if (!(iforce = kmalloc(sizeof(struct iforce), GFP_KERNEL)))
+	iforce = kzalloc(sizeof(struct iforce), GFP_KERNEL);
+	if (!iforce)
 		return -ENOMEM;
 
-	memset(iforce, 0, sizeof(struct iforce));
-
 	iforce->bus = IFORCE_232;
 	iforce->serio = serio;
 
@@ -148,7 +147,8 @@ static int iforce_serio_connect(struct serio *serio, struct serio_driver *drv)
 		return err;
 	}
 
-	if (iforce_init_device(iforce)) {
+	err = iforce_init_device(iforce);
+	if (err) {
 		serio_close(serio);
 		serio_set_drvdata(serio, NULL);
 		kfree(iforce);
@@ -162,7 +162,7 @@ static void iforce_serio_disconnect(struct serio *serio)
 {
 	struct iforce *iforce = serio_get_drvdata(serio);
 
-	input_unregister_device(&iforce->dev);
+	input_unregister_device(iforce->dev);
 	serio_close(serio);
 	serio_set_drvdata(serio, NULL);
 	kfree(iforce);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/input/joystick/iforce/iforce-serio.c b/drivers/input/joystick/iforce/iforce-serio.c
new file mode 100644
index 000000000000..11f51905cba7
--- /dev/null
+++ b/drivers/input/joystick/iforce/iforce-serio.c
@@ -0,0 +1,193 @@
+/*
+ * $Id: iforce-serio.c,v 1.4 2002/01/28 22:45:00 jdeneux Exp $
+ *
+ *  Copyright (c) 2000-2001 Vojtech Pavlik <vojtech@ucw.cz>
+ *  Copyright (c) 2001 Johann Deneux <deneux@ifrance.com>
+ *
+ *  USB/RS232 I-Force joysticks and wheels.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
+ */
+
+#include "iforce.h"
+
+void iforce_serial_xmit(struct iforce *iforce)
+{
+	unsigned char cs;
+	int i;
+	unsigned long flags;
+
+	if (test_and_set_bit(IFORCE_XMIT_RUNNING, iforce->xmit_flags)) {
+		set_bit(IFORCE_XMIT_AGAIN, iforce->xmit_flags);
+		return;
+	}
+
+	spin_lock_irqsave(&iforce->xmit_lock, flags);
+
+again:
+	if (iforce->xmit.head == iforce->xmit.tail) {
+		clear_bit(IFORCE_XMIT_RUNNING, iforce->xmit_flags);
+		spin_unlock_irqrestore(&iforce->xmit_lock, flags);
+		return;
+	}
+
+	cs = 0x2b;
+
+	serio_write(iforce->serio, 0x2b);
+
+	serio_write(iforce->serio, iforce->xmit.buf[iforce->xmit.tail]);
+	cs ^= iforce->xmit.buf[iforce->xmit.tail];
+	XMIT_INC(iforce->xmit.tail, 1);
+
+	for (i=iforce->xmit.buf[iforce->xmit.tail]; i >= 0; --i) {
+		serio_write(iforce->serio, iforce->xmit.buf[iforce->xmit.tail]);
+		cs ^= iforce->xmit.buf[iforce->xmit.tail];
+		XMIT_INC(iforce->xmit.tail, 1);
+	}
+
+	serio_write(iforce->serio, cs);
+
+	if (test_and_clear_bit(IFORCE_XMIT_AGAIN, iforce->xmit_flags))
+		goto again;
+
+	clear_bit(IFORCE_XMIT_RUNNING, iforce->xmit_flags);
+
+	spin_unlock_irqrestore(&iforce->xmit_lock, flags);
+}
+
+static void iforce_serio_write_wakeup(struct serio *serio)
+{
+	struct iforce *iforce = serio_get_drvdata(serio);
+
+	iforce_serial_xmit(iforce);
+}
+
+static irqreturn_t iforce_serio_irq(struct serio *serio,
+		unsigned char data, unsigned int flags, struct pt_regs *regs)
+{
+	struct iforce *iforce = serio_get_drvdata(serio);
+
+	if (!iforce->pkt) {
+		if (data == 0x2b)
+			iforce->pkt = 1;
+		goto out;
+	}
+
+	if (!iforce->id) {
+		if (data > 3 && data != 0xff)
+			iforce->pkt = 0;
+		else
+			iforce->id = data;
+		goto out;
+	}
+
+	if (!iforce->len) {
+		if (data > IFORCE_MAX_LENGTH) {
+			iforce->pkt = 0;
+			iforce->id = 0;
+		} else {
+			iforce->len = data;
+		}
+		goto out;
+	}
+
+	if (iforce->idx < iforce->len) {
+		iforce->csum += iforce->data[iforce->idx++] = data;
+		goto out;
+	}
+
+	if (iforce->idx == iforce->len) {
+		iforce_process_packet(iforce, (iforce->id << 8) | iforce->idx, iforce->data, regs);
+		iforce->pkt = 0;
+		iforce->id  = 0;
+		iforce->len = 0;
+		iforce->idx = 0;
+		iforce->csum = 0;
+	}
+out:
+	return IRQ_HANDLED;
+}
+
+static int iforce_serio_connect(struct serio *serio, struct serio_driver *drv)
+{
+	struct iforce *iforce;
+	int err;
+
+	if (!(iforce = kmalloc(sizeof(struct iforce), GFP_KERNEL)))
+		return -ENOMEM;
+
+	memset(iforce, 0, sizeof(struct iforce));
+
+	iforce->bus = IFORCE_232;
+	iforce->serio = serio;
+
+	serio_set_drvdata(serio, iforce);
+
+	err = serio_open(serio, drv);
+	if (err) {
+		serio_set_drvdata(serio, NULL);
+		kfree(iforce);
+		return err;
+	}
+
+	if (iforce_init_device(iforce)) {
+		serio_close(serio);
+		serio_set_drvdata(serio, NULL);
+		kfree(iforce);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static void iforce_serio_disconnect(struct serio *serio)
+{
+	struct iforce *iforce = serio_get_drvdata(serio);
+
+	input_unregister_device(&iforce->dev);
+	serio_close(serio);
+	serio_set_drvdata(serio, NULL);
+	kfree(iforce);
+}
+
+static struct serio_device_id iforce_serio_ids[] = {
+	{
+		.type	= SERIO_RS232,
+		.proto	= SERIO_IFORCE,
+		.id	= SERIO_ANY,
+		.extra	= SERIO_ANY,
+	},
+	{ 0 }
+};
+
+MODULE_DEVICE_TABLE(serio, iforce_serio_ids);
+
+struct serio_driver iforce_serio_drv = {
+	.driver		= {
+		.name	= "iforce",
+	},
+	.description	= "RS232 I-Force joysticks and wheels driver",
+	.id_table	= iforce_serio_ids,
+	.write_wakeup	= iforce_serio_write_wakeup,
+	.interrupt	= iforce_serio_irq,
+	.connect	= iforce_serio_connect,
+	.disconnect	= iforce_serio_disconnect,
+};
