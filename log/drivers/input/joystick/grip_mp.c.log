commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/input/joystick/grip_mp.c b/drivers/input/joystick/grip_mp.c
index 573191dd78e8..056a89ac2bdf 100644
--- a/drivers/input/joystick/grip_mp.c
+++ b/drivers/input/joystick/grip_mp.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  Driver for the Gravis Grip Multiport, a gamepad "hub" that
  *  connects up to four 9-pin digital gamepads/joysticks.

commit bf9a9f8e5105b13cea954b254008f383ed0b4045
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jan 6 10:27:05 2014 -0800

    Input: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/drivers/input/joystick/grip_mp.c b/drivers/input/joystick/grip_mp.c
index c0f9c7b7eb4e..573191dd78e8 100644
--- a/drivers/input/joystick/grip_mp.c
+++ b/drivers/input/joystick/grip_mp.c
@@ -11,7 +11,6 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/gameport.h>
 #include <linux/input.h>

commit 98a84131926ebafe868c65631b69d4912922211e
Author: Axel Lin <axel.lin@gmail.com>
Date:   Tue Apr 3 23:52:27 2012 -0700

    Input: gameport - use module_gameport_driver
    
    This patch converts the drivers in drivers/input/* to use
    module_gameport_driver() macro which makes the code smaller
    and a bit simpler.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/joystick/grip_mp.c b/drivers/input/joystick/grip_mp.c
index 2d47baf47769..c0f9c7b7eb4e 100644
--- a/drivers/input/joystick/grip_mp.c
+++ b/drivers/input/joystick/grip_mp.c
@@ -687,15 +687,4 @@ static struct gameport_driver grip_drv = {
 	.disconnect	= grip_disconnect,
 };
 
-static int __init grip_init(void)
-{
-	return gameport_register_driver(&grip_drv);
-}
-
-static void __exit grip_exit(void)
-{
-	gameport_unregister_driver(&grip_drv);
-}
-
-module_init(grip_init);
-module_exit(grip_exit);
+module_gameport_driver(grip_drv);

commit 2547203d583cc267b98f518d5d93e3a0469d8f62
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Jun 6 01:33:37 2008 -0400

    Input: gameport - check return value of gameport_register_driver()
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/joystick/grip_mp.c b/drivers/input/joystick/grip_mp.c
index 8279481b16e7..2d47baf47769 100644
--- a/drivers/input/joystick/grip_mp.c
+++ b/drivers/input/joystick/grip_mp.c
@@ -689,8 +689,7 @@ static struct gameport_driver grip_drv = {
 
 static int __init grip_init(void)
 {
-	gameport_register_driver(&grip_drv);
-	return 0;
+	return gameport_register_driver(&grip_drv);
 }
 
 static void __exit grip_exit(void)

commit d1659fcc59b21ec442564fedb67a5ad371f82380
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue May 20 12:17:39 2008 -0400

    Input: remove CVS keywords
    
    This patch removes CVS keywords that weren't updated for a long time
    from comments.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/joystick/grip_mp.c b/drivers/input/joystick/grip_mp.c
index c57e21d68c00..8279481b16e7 100644
--- a/drivers/input/joystick/grip_mp.c
+++ b/drivers/input/joystick/grip_mp.c
@@ -1,6 +1,4 @@
 /*
- * $Id: grip_mp.c,v 1.9 2002/07/20 19:28:45 bonnland Exp $
- *
  *  Driver for the Gravis Grip Multiport, a gamepad "hub" that
  *  connects up to four 9-pin digital gamepads/joysticks.
  *  Driver tested on SMP and UP kernel versions 2.4.18-4 and 2.4.18-5.

commit 7b19ada2ed3c1eccb9fe94d74b05e1428224663d
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Oct 18 23:40:32 2007 -0700

    get rid of input BIT* duplicate defines
    
    get rid of input BIT* duplicate defines
    
    use newly global defined macros for input layer. Also remove includes of
    input.h from non-input sources only for BIT macro definiton. Define the
    macro temporarily in local manner, all those local definitons will be
    removed further in this patchset (to not break bisecting).
    BIT macro will be globally defined (1<<x)
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: <dtor@mail.ru>
    Acked-by: Jiri Kosina <jkosina@suse.cz>
    Cc: <lenb@kernel.org>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Cc: <perex@suse.cz>
    Acked-by: Mauro Carvalho Chehab <mchehab@infradead.org>
    Cc: <vernux@us.ibm.com>
    Cc: <malattia@linux.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/input/joystick/grip_mp.c b/drivers/input/joystick/grip_mp.c
index 4ed3a3eadf19..c57e21d68c00 100644
--- a/drivers/input/joystick/grip_mp.c
+++ b/drivers/input/joystick/grip_mp.c
@@ -606,7 +606,7 @@ static int register_slot(int slot, struct grip_mp *grip)
 	input_dev->open = grip_open;
 	input_dev->close = grip_close;
 
-	input_dev->evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
+	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
 
 	for (j = 0; (t = grip_abs[port->mode][j]) >= 0; j++)
 		input_set_abs_params(input_dev, t, -1, 1, 0, 0);

commit 5ec1f7f3e4a4896062dc6a64d38036588733bc23
Author: Andi Drebes <lists-receive@programmierforen.de>
Date:   Thu Jun 14 23:33:01 2007 -0400

    Input: grip-mp - use ARRAY_SIZE
    
    Signed-off-by: Andi Drebes <lists-receive@programmierforen.de>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/joystick/grip_mp.c b/drivers/input/joystick/grip_mp.c
index 555319e6378c..4ed3a3eadf19 100644
--- a/drivers/input/joystick/grip_mp.c
+++ b/drivers/input/joystick/grip_mp.c
@@ -320,10 +320,10 @@ static int multiport_io(struct gameport* gameport, int sendflags, int sendcode,
 
 static int dig_mode_start(struct gameport *gameport, u32 *packet)
 {
-	int i, seq_len = sizeof(init_seq)/sizeof(int);
+	int i;
 	int flags, tries = 0, bads = 0;
 
-	for (i = 0; i < seq_len; i++) {     /* Send magic sequence */
+	for (i = 0; i < ARRAY_SIZE(init_seq); i++) {     /* Send magic sequence */
 		if (init_seq[i])
 			gameport_trigger(gameport);
 		udelay(GRIP_INIT_DELAY);

commit 935e658e89678a7e3427b90cd7a1c86025d95bfe
Author: Dmitry Torokhov <dtor@insightbb.com>
Date:   Thu Apr 12 01:35:26 2007 -0400

    Input: joysticks - switch to using input_dev->dev.parent
    
    In preparation for struct class_device -> struct device input
    core conversion, switch to using input_dev->dev.parent when
    specifying device position in sysfs tree.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/joystick/grip_mp.c b/drivers/input/joystick/grip_mp.c
index 1771d5d86790..555319e6378c 100644
--- a/drivers/input/joystick/grip_mp.c
+++ b/drivers/input/joystick/grip_mp.c
@@ -599,7 +599,7 @@ static int register_slot(int slot, struct grip_mp *grip)
 	input_dev->id.vendor = GAMEPORT_ID_VENDOR_GRAVIS;
 	input_dev->id.product = 0x0100 + port->mode;
 	input_dev->id.version = 0x0100;
-	input_dev->cdev.dev = &grip->gameport->dev;
+	input_dev->dev.parent = &grip->gameport->dev;
 
 	input_set_drvdata(input_dev, grip);
 

commit 8715c1cfadf8cce24e79d254f95bd4a84c7741f0
Author: Dmitry Torokhov <dtor@insightbb.com>
Date:   Thu Apr 12 01:34:14 2007 -0400

    Input: drivers/input/joystick - don't access dev->private directly
    
    Use input_get_drvdata() and input_set_drvdata() instead.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/joystick/grip_mp.c b/drivers/input/joystick/grip_mp.c
index 8120a9c40773..1771d5d86790 100644
--- a/drivers/input/joystick/grip_mp.c
+++ b/drivers/input/joystick/grip_mp.c
@@ -562,7 +562,7 @@ static void grip_poll(struct gameport *gameport)
 
 static int grip_open(struct input_dev *dev)
 {
-	struct grip_mp *grip = dev->private;
+	struct grip_mp *grip = input_get_drvdata(dev);
 
 	gameport_start_polling(grip->gameport);
 	return 0;
@@ -574,9 +574,9 @@ static int grip_open(struct input_dev *dev)
 
 static void grip_close(struct input_dev *dev)
 {
-	struct grip_mp *grip = dev->private;
+	struct grip_mp *grip = input_get_drvdata(dev);
 
-	gameport_start_polling(grip->gameport);
+	gameport_stop_polling(grip->gameport);
 }
 
 /*
@@ -600,7 +600,8 @@ static int register_slot(int slot, struct grip_mp *grip)
 	input_dev->id.product = 0x0100 + port->mode;
 	input_dev->id.version = 0x0100;
 	input_dev->cdev.dev = &grip->gameport->dev;
-	input_dev->private = grip;
+
+	input_set_drvdata(input_dev, grip);
 
 	input_dev->open = grip_open;
 	input_dev->close = grip_close;

commit 127278ce2254c61f1346500374d61e33f74a8729
Author: Dmitry Torokhov <dtor@insightbb.com>
Date:   Sun Nov 5 22:40:09 2006 -0500

    Input: joysticks - handle errors when registering input devices
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/joystick/grip_mp.c b/drivers/input/joystick/grip_mp.c
index 62438944a69a..8120a9c40773 100644
--- a/drivers/input/joystick/grip_mp.c
+++ b/drivers/input/joystick/grip_mp.c
@@ -423,7 +423,10 @@ static int get_and_decode_packet(struct grip_mp *grip, int flags)
 
 		if (!port->registered) {
 			dbg("New Grip pad in multiport slot %d.\n", slot);
-			register_slot(slot, grip);
+			if (register_slot(slot, grip)) {
+				port->mode = GRIP_MODE_RESET;
+				port->dirty = 0;
+			}
 		}
 		return flags;
 	}
@@ -585,6 +588,7 @@ static int register_slot(int slot, struct grip_mp *grip)
 	struct grip_port *port = grip->port[slot];
 	struct input_dev *input_dev;
 	int j, t;
+	int err;
 
 	port->dev = input_dev = input_allocate_device();
 	if (!input_dev)
@@ -610,7 +614,12 @@ static int register_slot(int slot, struct grip_mp *grip)
 		if (t > 0)
 			set_bit(t, input_dev->keybit);
 
-	input_register_device(port->dev);
+	err = input_register_device(port->dev);
+	if (err) {
+		input_free_device(port->dev);
+		return err;
+	}
+
 	port->registered = 1;
 
 	if (port->dirty)	            /* report initial state, if any */

commit ebbac7dde2f5c6b4bd219573f840d4b3952e6220
Author: Dmitry Torokhov <dtor_core@ameritech.net>
Date:   Tue Jan 10 01:58:47 2006 -0500

    Input: grip_mp - kill commented out code
    
    Kill leftovers of dynalloc conversion.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/joystick/grip_mp.c b/drivers/input/joystick/grip_mp.c
index 51a912222e85..62438944a69a 100644
--- a/drivers/input/joystick/grip_mp.c
+++ b/drivers/input/joystick/grip_mp.c
@@ -53,17 +53,8 @@ struct grip_port {
 struct grip_mp {
 	struct gameport *gameport;
 	struct grip_port *port[GRIP_MAX_PORTS];
-//	struct input_dev *dev[4];
-//	int mode[4];
-//	int registered[4];
 	int reads;
 	int bads;
-
-	/* individual gamepad states */
-//	int buttons[4];
-//	int xaxes[4];
-//	int yaxes[4];
-//	int dirty[4];     /* has the state been updated? */
 };
 
 /*

commit 4e57b6817880946a3a78d5d8cad1ace363f7e449
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Sun Oct 30 15:03:48 2005 -0800

    [PATCH] fix missing includes
    
    I recently picked up my older work to remove unnecessary #includes of
    sched.h, starting from a patch by Dave Jones to not include sched.h
    from module.h. This reduces the number of indirect includes of sched.h
    by ~300. Another ~400 pointless direct includes can be removed after
    this disentangling (patch to follow later).
    However, quite a few indirect includes need to be fixed up for this.
    
    In order to feed the patches through -mm with as little disturbance as
    possible, I've split out the fixes I accumulated up to now (complete for
    i386 and x86_64, more archs to follow later) and post them before the real
    patch.  This way this large part of the patch is kept simple with only
    adding #includes, and all hunks are independent of each other.  So if any
    hunk rejects or gets in the way of other patches, just drop it.  My scripts
    will pick it up again in the next round.
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/input/joystick/grip_mp.c b/drivers/input/joystick/grip_mp.c
index a0ba93ccac72..51a912222e85 100644
--- a/drivers/input/joystick/grip_mp.c
+++ b/drivers/input/joystick/grip_mp.c
@@ -19,6 +19,7 @@
 #include <linux/input.h>
 #include <linux/delay.h>
 #include <linux/proc_fs.h>
+#include <linux/jiffies.h>
 
 #define DRIVER_DESC	"Gravis Grip Multiport driver"
 

commit 17dd3f0f7aa729a042af5d3318ff9b3e7781b45b
Author: Dmitry Torokhov <dtor_core@ameritech.net>
Date:   Thu Sep 15 02:01:52 2005 -0500

    [PATCH] drivers/input/joystick: convert to dynamic input_dev allocation
    
    Input: convert drivers/input/joystick to dynamic input_dev allocation
    
    This is required for input_dev sysfs integration
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/input/joystick/grip_mp.c b/drivers/input/joystick/grip_mp.c
index da17eee6f574..a0ba93ccac72 100644
--- a/drivers/input/joystick/grip_mp.c
+++ b/drivers/input/joystick/grip_mp.c
@@ -32,23 +32,37 @@ MODULE_LICENSE("GPL");
 #define dbg(format, arg...) do {} while (0)
 #endif
 
+#define GRIP_MAX_PORTS	4
 /*
  * Grip multiport state
  */
 
+struct grip_port {
+	struct input_dev *dev;
+	int mode;
+	int registered;
+
+	/* individual gamepad states */
+	int buttons;
+	int xaxes;
+	int yaxes;
+	int dirty;     /* has the state been updated? */
+};
+
 struct grip_mp {
 	struct gameport *gameport;
-	struct input_dev dev[4];
-	int mode[4];
-	int registered[4];
+	struct grip_port *port[GRIP_MAX_PORTS];
+//	struct input_dev *dev[4];
+//	int mode[4];
+//	int registered[4];
 	int reads;
 	int bads;
 
 	/* individual gamepad states */
-	int buttons[4];
-	int xaxes[4];
-	int yaxes[4];
-	int dirty[4];     /* has the state been updated? */
+//	int buttons[4];
+//	int xaxes[4];
+//	int yaxes[4];
+//	int dirty[4];     /* has the state been updated? */
 };
 
 /*
@@ -85,16 +99,16 @@ struct grip_mp {
 #define GRIP_MODE_GP		2
 #define GRIP_MODE_C64		3
 
-static int grip_btn_gp[]  = { BTN_TR, BTN_TL, BTN_A, BTN_B, BTN_C, BTN_X, BTN_Y, BTN_Z, -1 };
-static int grip_btn_c64[] = { BTN_JOYSTICK, -1 };
+static const int grip_btn_gp[]  = { BTN_TR, BTN_TL, BTN_A, BTN_B, BTN_C, BTN_X, BTN_Y, BTN_Z, -1 };
+static const int grip_btn_c64[] = { BTN_JOYSTICK, -1 };
 
-static int grip_abs_gp[]  = { ABS_X, ABS_Y, -1 };
-static int grip_abs_c64[] = { ABS_X, ABS_Y, -1 };
+static const int grip_abs_gp[]  = { ABS_X, ABS_Y, -1 };
+static const int grip_abs_c64[] = { ABS_X, ABS_Y, -1 };
 
-static int *grip_abs[] = { NULL, NULL, grip_abs_gp, grip_abs_c64 };
-static int *grip_btn[] = { NULL, NULL, grip_btn_gp, grip_btn_c64 };
+static const int *grip_abs[] = { NULL, NULL, grip_abs_gp, grip_abs_c64 };
+static const int *grip_btn[] = { NULL, NULL, grip_btn_gp, grip_btn_c64 };
 
-static char *grip_name[] = { NULL, NULL, "Gravis Grip Pad", "Commodore 64 Joystick" };
+static const char *grip_name[] = { NULL, NULL, "Gravis Grip Pad", "Commodore 64 Joystick" };
 
 static const int init_seq[] = {
 	1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1,
@@ -104,9 +118,9 @@ static const int init_seq[] = {
 
 /* Maps multiport directional values to X,Y axis values (each axis encoded in 3 bits) */
 
-static int axis_map[] = { 5, 9, 1, 5, 6, 10, 2, 6, 4, 8, 0, 4, 5, 9, 1, 5 };
+static const int axis_map[] = { 5, 9, 1, 5, 6, 10, 2, 6, 4, 8, 0, 4, 5, 9, 1, 5 };
 
-static void register_slot(int i, struct grip_mp *grip);
+static int register_slot(int i, struct grip_mp *grip);
 
 /*
  * Returns whether an odd or even number of bits are on in pkt.
@@ -353,9 +367,10 @@ static int dig_mode_start(struct gameport *gameport, u32 *packet)
 
 static int get_and_decode_packet(struct grip_mp *grip, int flags)
 {
+	struct grip_port *port;
 	u32 packet;
 	int joytype = 0;
-	int slot = 0;
+	int slot;
 
 	/* Get a packet and check for validity */
 
@@ -377,6 +392,8 @@ static int get_and_decode_packet(struct grip_mp *grip, int flags)
 	if ((slot < 0) || (slot > 3))
 		return flags;
 
+	port = grip->port[slot];
+
 	/*
 	 * Handle "reset" packets, which occur at startup, and when gamepads
 	 * are removed or plugged in.  May contain configuration of a new gamepad.
@@ -385,14 +402,14 @@ static int get_and_decode_packet(struct grip_mp *grip, int flags)
 	joytype = (packet >> 16) & 0x1f;
 	if (!joytype) {
 
-		if (grip->registered[slot]) {
+		if (port->registered) {
 			printk(KERN_INFO "grip_mp: removing %s, slot %d\n",
-			       grip_name[grip->mode[slot]], slot);
-			input_unregister_device(grip->dev + slot);
-			grip->registered[slot] = 0;
+			       grip_name[port->mode], slot);
+			input_unregister_device(port->dev);
+			port->registered = 0;
 		}
 		dbg("Reset: grip multiport slot %d\n", slot);
-		grip->mode[slot] = GRIP_MODE_RESET;
+		port->mode = GRIP_MODE_RESET;
 		flags |= IO_SLOT_CHANGE;
 		return flags;
 	}
@@ -402,17 +419,17 @@ static int get_and_decode_packet(struct grip_mp *grip, int flags)
 	if (joytype == 0x1f) {
 
 		int dir = (packet >> 8) & 0xf;          /* eight way directional value */
-		grip->buttons[slot] = (~packet) & 0xff;
-		grip->yaxes[slot] = ((axis_map[dir] >> 2) & 3) - 1;
-		grip->xaxes[slot] = (axis_map[dir] & 3) - 1;
-		grip->dirty[slot] = 1;
+		port->buttons = (~packet) & 0xff;
+		port->yaxes = ((axis_map[dir] >> 2) & 3) - 1;
+		port->xaxes = (axis_map[dir] & 3) - 1;
+		port->dirty = 1;
 
-		if (grip->mode[slot] == GRIP_MODE_RESET)
+		if (port->mode == GRIP_MODE_RESET)
 			flags |= IO_SLOT_CHANGE;
 
-		grip->mode[slot] = GRIP_MODE_GP;
+		port->mode = GRIP_MODE_GP;
 
-		if (!grip->registered[slot]) {
+		if (!port->registered) {
 			dbg("New Grip pad in multiport slot %d.\n", slot);
 			register_slot(slot, grip);
 		}
@@ -445,9 +462,9 @@ static int slots_valid(struct grip_mp *grip)
 		return 0;
 
 	for (slot = 0; slot < 4; slot++) {
-		if (grip->mode[slot] == GRIP_MODE_RESET)
+		if (grip->port[slot]->mode == GRIP_MODE_RESET)
 			invalid = 1;
-		if (grip->mode[slot] != GRIP_MODE_NONE)
+		if (grip->port[slot]->mode != GRIP_MODE_NONE)
 			active = 1;
 	}
 
@@ -484,7 +501,7 @@ static int multiport_init(struct grip_mp *grip)
 
 	/* Get packets, store multiport state, and check state's validity */
 	for (tries = 0; tries < 4096; tries++) {
-		if ( slots_valid(grip) ) {
+		if (slots_valid(grip)) {
 			initialized = 1;
 			break;
 		}
@@ -499,24 +516,24 @@ static int multiport_init(struct grip_mp *grip)
 
 static void report_slot(struct grip_mp *grip, int slot)
 {
-	struct input_dev *dev = &(grip->dev[slot]);
-	int i, buttons = grip->buttons[slot];
+	struct grip_port *port = grip->port[slot];
+	int i;
 
 	/* Store button states with linux input driver */
 
 	for (i = 0; i < 8; i++)
-		input_report_key(dev, grip_btn_gp[i], (buttons >> i) & 1);
+		input_report_key(port->dev, grip_btn_gp[i], (port->buttons >> i) & 1);
 
 	/* Store axis states with linux driver */
 
-	input_report_abs(dev, ABS_X, grip->xaxes[slot]);
-	input_report_abs(dev, ABS_Y, grip->yaxes[slot]);
+	input_report_abs(port->dev, ABS_X, port->xaxes);
+	input_report_abs(port->dev, ABS_Y, port->yaxes);
 
 	/* Tell the receiver of the events to process them */
 
-	input_sync(dev);
+	input_sync(port->dev);
 
-	grip->dirty[slot] = 0;
+	port->dirty = 0;
 }
 
 /*
@@ -540,7 +557,7 @@ static void grip_poll(struct gameport *gameport)
 	}
 
 	for (i = 0; i < 4; i++)
-		if (grip->dirty[i])
+		if (grip->port[i]->dirty)
 			report_slot(grip, i);
 }
 
@@ -571,35 +588,43 @@ static void grip_close(struct input_dev *dev)
  * Tell the linux input layer about a newly plugged-in gamepad.
  */
 
-static void register_slot(int slot, struct grip_mp *grip)
+static int register_slot(int slot, struct grip_mp *grip)
 {
+	struct grip_port *port = grip->port[slot];
+	struct input_dev *input_dev;
 	int j, t;
 
-	grip->dev[slot].private = grip;
-	grip->dev[slot].open = grip_open;
-	grip->dev[slot].close = grip_close;
-	grip->dev[slot].name = grip_name[grip->mode[slot]];
-	grip->dev[slot].id.bustype = BUS_GAMEPORT;
-	grip->dev[slot].id.vendor = GAMEPORT_ID_VENDOR_GRAVIS;
-	grip->dev[slot].id.product = 0x0100 + grip->mode[slot];
-	grip->dev[slot].id.version = 0x0100;
-	grip->dev[slot].evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
+	port->dev = input_dev = input_allocate_device();
+	if (!input_dev)
+		return -ENOMEM;
+
+	input_dev->name = grip_name[port->mode];
+	input_dev->id.bustype = BUS_GAMEPORT;
+	input_dev->id.vendor = GAMEPORT_ID_VENDOR_GRAVIS;
+	input_dev->id.product = 0x0100 + port->mode;
+	input_dev->id.version = 0x0100;
+	input_dev->cdev.dev = &grip->gameport->dev;
+	input_dev->private = grip;
+
+	input_dev->open = grip_open;
+	input_dev->close = grip_close;
 
-	for (j = 0; (t = grip_abs[grip->mode[slot]][j]) >= 0; j++)
-		input_set_abs_params(&grip->dev[slot], t, -1, 1, 0, 0);
+	input_dev->evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
 
-	for (j = 0; (t = grip_btn[grip->mode[slot]][j]) >= 0; j++)
+	for (j = 0; (t = grip_abs[port->mode][j]) >= 0; j++)
+		input_set_abs_params(input_dev, t, -1, 1, 0, 0);
+
+	for (j = 0; (t = grip_btn[port->mode][j]) >= 0; j++)
 		if (t > 0)
-			set_bit(t, grip->dev[slot].keybit);
+			set_bit(t, input_dev->keybit);
 
-	input_register_device(grip->dev + slot);
-	grip->registered[slot] = 1;
+	input_register_device(port->dev);
+	port->registered = 1;
 
-	if (grip->dirty[slot])	            /* report initial state, if any */
+	if (port->dirty)	            /* report initial state, if any */
 		report_slot(grip, slot);
 
-	printk(KERN_INFO "grip_mp: added %s, slot %d\n",
-	       grip_name[grip->mode[slot]], slot);
+	return 0;
 }
 
 static int grip_connect(struct gameport *gameport, struct gameport_driver *drv)
@@ -626,7 +651,7 @@ static int grip_connect(struct gameport *gameport, struct gameport_driver *drv)
 		goto fail2;
 	}
 
-	if (!grip->mode[0] && !grip->mode[1] && !grip->mode[2] && !grip->mode[3]) {
+	if (!grip->port[0]->mode && !grip->port[1]->mode && !grip->port[2]->mode && !grip->port[3]->mode) {
 		/* nothing plugged in */
 		err = -ENODEV;
 		goto fail2;
@@ -646,8 +671,8 @@ static void grip_disconnect(struct gameport *gameport)
 	int i;
 
 	for (i = 0; i < 4; i++)
-		if (grip->registered[i])
-			input_unregister_device(grip->dev + i);
+		if (grip->port[i]->registered)
+			input_unregister_device(grip->port[i]->dev);
 	gameport_close(gameport);
 	gameport_set_drvdata(gameport, NULL);
 	kfree(grip);

commit a97e148a8b8da8b04bc3e18ceb824a8f5f56d567
Author: Pekka Enberg <penberg@cs.helsinki.fi>
Date:   Tue Sep 6 15:18:33 2005 -0700

    [PATCH] input: convert kcalloc to kzalloc
    
    This patch converts kcalloc(1, ...) calls to use the new kzalloc() function.
    
    Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>
    Cc: Vojtech Pavlik <vojtech@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/input/joystick/grip_mp.c b/drivers/input/joystick/grip_mp.c
index 0da7bd133ccf..da17eee6f574 100644
--- a/drivers/input/joystick/grip_mp.c
+++ b/drivers/input/joystick/grip_mp.c
@@ -607,7 +607,7 @@ static int grip_connect(struct gameport *gameport, struct gameport_driver *drv)
 	struct grip_mp *grip;
 	int err;
 
-	if (!(grip = kcalloc(1, sizeof(struct grip_mp), GFP_KERNEL)))
+	if (!(grip = kzalloc(sizeof(struct grip_mp), GFP_KERNEL)))
 		return -ENOMEM;
 
 	grip->gameport = gameport;

commit ab0c3443ad2de03383f2549195badf64779d08a1
Author: Dmitry Torokhov <dtor_core@ameritech.net>
Date:   Sun May 29 02:28:55 2005 -0500

    Input: whitespace fixes in driver/input/joystick
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/input/joystick/grip_mp.c b/drivers/input/joystick/grip_mp.c
index 42e5005d621f..0da7bd133ccf 100644
--- a/drivers/input/joystick/grip_mp.c
+++ b/drivers/input/joystick/grip_mp.c
@@ -171,7 +171,7 @@ static int mp_io(struct gameport* gameport, int sendflags, int sendcode, u32 *pa
 	*packet = 0;
 	raw_data = gameport_read(gameport);
 	if (raw_data & 1)
- 		return IO_RETRY;
+		return IO_RETRY;
 
 	for (i = 0; i < 64; i++) {
 		raw_data = gameport_read(gameport);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/input/joystick/grip_mp.c b/drivers/input/joystick/grip_mp.c
new file mode 100644
index 000000000000..42e5005d621f
--- /dev/null
+++ b/drivers/input/joystick/grip_mp.c
@@ -0,0 +1,677 @@
+/*
+ * $Id: grip_mp.c,v 1.9 2002/07/20 19:28:45 bonnland Exp $
+ *
+ *  Driver for the Gravis Grip Multiport, a gamepad "hub" that
+ *  connects up to four 9-pin digital gamepads/joysticks.
+ *  Driver tested on SMP and UP kernel versions 2.4.18-4 and 2.4.18-5.
+ *
+ *  Thanks to Chris Gassib for helpful advice.
+ *
+ *  Copyright (c)      2002 Brian Bonnlander, Bill Soudan
+ *  Copyright (c) 1998-2000 Vojtech Pavlik
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/gameport.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+
+#define DRIVER_DESC	"Gravis Grip Multiport driver"
+
+MODULE_AUTHOR("Brian Bonnlander");
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
+
+#ifdef GRIP_DEBUG
+#define dbg(format, arg...) printk(KERN_ERR __FILE__ ": " format "\n" , ## arg)
+#else
+#define dbg(format, arg...) do {} while (0)
+#endif
+
+/*
+ * Grip multiport state
+ */
+
+struct grip_mp {
+	struct gameport *gameport;
+	struct input_dev dev[4];
+	int mode[4];
+	int registered[4];
+	int reads;
+	int bads;
+
+	/* individual gamepad states */
+	int buttons[4];
+	int xaxes[4];
+	int yaxes[4];
+	int dirty[4];     /* has the state been updated? */
+};
+
+/*
+ * Multiport packet interpretation
+ */
+
+#define PACKET_FULL          0x80000000       /* packet is full                        */
+#define PACKET_IO_FAST       0x40000000       /* 3 bits per gameport read              */
+#define PACKET_IO_SLOW       0x20000000       /* 1 bit per gameport read               */
+#define PACKET_MP_MORE       0x04000000       /* multiport wants to send more          */
+#define PACKET_MP_DONE       0x02000000       /* multiport done sending                */
+
+/*
+ * Packet status code interpretation
+ */
+
+#define IO_GOT_PACKET        0x0100           /* Got a packet                           */
+#define IO_MODE_FAST         0x0200           /* Used 3 data bits per gameport read     */
+#define IO_SLOT_CHANGE       0x0800           /* Multiport physical slot status changed */
+#define IO_DONE              0x1000           /* Multiport is done sending packets      */
+#define IO_RETRY             0x4000           /* Try again later to get packet          */
+#define IO_RESET             0x8000           /* Force multiport to resend all packets  */
+
+/*
+ * Gamepad configuration data.  Other 9-pin digital joystick devices
+ * may work with the multiport, so this may not be an exhaustive list!
+ * Commodore 64 joystick remains untested.
+ */
+
+#define GRIP_INIT_DELAY         2000          /*  2 ms */
+
+#define GRIP_MODE_NONE		0
+#define GRIP_MODE_RESET         1
+#define GRIP_MODE_GP		2
+#define GRIP_MODE_C64		3
+
+static int grip_btn_gp[]  = { BTN_TR, BTN_TL, BTN_A, BTN_B, BTN_C, BTN_X, BTN_Y, BTN_Z, -1 };
+static int grip_btn_c64[] = { BTN_JOYSTICK, -1 };
+
+static int grip_abs_gp[]  = { ABS_X, ABS_Y, -1 };
+static int grip_abs_c64[] = { ABS_X, ABS_Y, -1 };
+
+static int *grip_abs[] = { NULL, NULL, grip_abs_gp, grip_abs_c64 };
+static int *grip_btn[] = { NULL, NULL, grip_btn_gp, grip_btn_c64 };
+
+static char *grip_name[] = { NULL, NULL, "Gravis Grip Pad", "Commodore 64 Joystick" };
+
+static const int init_seq[] = {
+	1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1,
+	1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1,
+	1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1,
+	0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1 };
+
+/* Maps multiport directional values to X,Y axis values (each axis encoded in 3 bits) */
+
+static int axis_map[] = { 5, 9, 1, 5, 6, 10, 2, 6, 4, 8, 0, 4, 5, 9, 1, 5 };
+
+static void register_slot(int i, struct grip_mp *grip);
+
+/*
+ * Returns whether an odd or even number of bits are on in pkt.
+ */
+
+static int bit_parity(u32 pkt)
+{
+	int x = pkt ^ (pkt >> 16);
+	x ^= x >> 8;
+	x ^= x >> 4;
+	x ^= x >> 2;
+	x ^= x >> 1;
+	return x & 1;
+}
+
+/*
+ * Poll gameport; return true if all bits set in 'onbits' are on and
+ * all bits set in 'offbits' are off.
+ */
+
+static inline int poll_until(u8 onbits, u8 offbits, int u_sec, struct gameport* gp, u8 *data)
+{
+	int i, nloops;
+
+	nloops = gameport_time(gp, u_sec);
+	for (i = 0; i < nloops; i++) {
+		*data = gameport_read(gp);
+		if ((*data & onbits) == onbits &&
+		    (~(*data) & offbits) == offbits)
+			return 1;
+	}
+	dbg("gameport timed out after %d microseconds.\n", u_sec);
+	return 0;
+}
+
+/*
+ * Gets a 28-bit packet from the multiport.
+ *
+ * After getting a packet successfully, commands encoded by sendcode may
+ * be sent to the multiport.
+ *
+ * The multiport clock value is reflected in gameport bit B4.
+ *
+ * Returns a packet status code indicating whether packet is valid, the transfer
+ * mode, and any error conditions.
+ *
+ * sendflags:      current I/O status
+ * sendcode:   data to send to the multiport if sendflags is nonzero
+ */
+
+static int mp_io(struct gameport* gameport, int sendflags, int sendcode, u32 *packet)
+{
+	u8  raw_data;            /* raw data from gameport */
+	u8  data_mask;           /* packet data bits from raw_data */
+	u32 pkt;                 /* packet temporary storage */
+	int bits_per_read;       /* num packet bits per gameport read */
+	int portvals = 0;        /* used for port value sanity check */
+	int i;
+
+	/* Gameport bits B0, B4, B5 should first be off, then B4 should come on. */
+
+	*packet = 0;
+	raw_data = gameport_read(gameport);
+	if (raw_data & 1)
+ 		return IO_RETRY;
+
+	for (i = 0; i < 64; i++) {
+		raw_data = gameport_read(gameport);
+		portvals |= 1 << ((raw_data >> 4) & 3); /* Demux B4, B5 */
+	}
+
+	if (portvals == 1) {                            /* B4, B5 off */
+		raw_data = gameport_read(gameport);
+		portvals = raw_data & 0xf0;
+
+		if (raw_data & 0x31)
+			return IO_RESET;
+		gameport_trigger(gameport);
+
+		if (!poll_until(0x10, 0, 308, gameport, &raw_data))
+			return IO_RESET;
+	} else
+		return IO_RETRY;
+
+	/* Determine packet transfer mode and prepare for packet construction. */
+
+	if (raw_data & 0x20) {                 /* 3 data bits/read */
+		portvals |= raw_data >> 4;     /* Compare B4-B7 before & after trigger */
+
+		if (portvals != 0xb)
+			return 0;
+		data_mask = 7;
+		bits_per_read = 3;
+		pkt = (PACKET_FULL | PACKET_IO_FAST) >> 28;
+	} else {                                 /* 1 data bit/read */
+		data_mask = 1;
+		bits_per_read = 1;
+		pkt = (PACKET_FULL | PACKET_IO_SLOW) >> 28;
+	}
+
+	/* Construct a packet.  Final data bits must be zero. */
+
+	while (1) {
+		if (!poll_until(0, 0x10, 77, gameport, &raw_data))
+			return IO_RESET;
+		raw_data = (raw_data >> 5) & data_mask;
+
+		if (pkt & PACKET_FULL)
+			break;
+		pkt = (pkt << bits_per_read) | raw_data;
+
+		if (!poll_until(0x10, 0, 77, gameport, &raw_data))
+			return IO_RESET;
+	}
+
+	if (raw_data)
+		return IO_RESET;
+
+	/* If 3 bits/read used, drop from 30 bits to 28. */
+
+	if (bits_per_read == 3) {
+		pkt = (pkt & 0xffff0000) | ((pkt << 1) & 0xffff);
+		pkt = (pkt >> 2) | 0xf0000000;
+	}
+
+	if (bit_parity(pkt) == 1)
+		return IO_RESET;
+
+	/* Acknowledge packet receipt */
+
+	if (!poll_until(0x30, 0, 77, gameport, &raw_data))
+		return IO_RESET;
+
+	raw_data = gameport_read(gameport);
+
+	if (raw_data & 1)
+		return IO_RESET;
+
+	gameport_trigger(gameport);
+
+	if (!poll_until(0, 0x20, 77, gameport, &raw_data))
+		return IO_RESET;
+
+        /* Return if we just wanted the packet or multiport wants to send more */
+
+	*packet = pkt;
+	if ((sendflags == 0) || ((sendflags & IO_RETRY) && !(pkt & PACKET_MP_DONE)))
+		return IO_GOT_PACKET;
+
+	if (pkt & PACKET_MP_MORE)
+		return IO_GOT_PACKET | IO_RETRY;
+
+	/* Multiport is done sending packets and is ready to receive data */
+
+	if (!poll_until(0x20, 0, 77, gameport, &raw_data))
+		return IO_GOT_PACKET | IO_RESET;
+
+	raw_data = gameport_read(gameport);
+	if (raw_data & 1)
+		return IO_GOT_PACKET | IO_RESET;
+
+	/* Trigger gameport based on bits in sendcode */
+
+	gameport_trigger(gameport);
+	do {
+		if (!poll_until(0x20, 0x10, 116, gameport, &raw_data))
+			return IO_GOT_PACKET | IO_RESET;
+
+		if (!poll_until(0x30, 0, 193, gameport, &raw_data))
+			return IO_GOT_PACKET | IO_RESET;
+
+		if (raw_data & 1)
+			return IO_GOT_PACKET | IO_RESET;
+
+		if (sendcode & 1)
+			gameport_trigger(gameport);
+
+		sendcode >>= 1;
+	} while (sendcode);
+
+	return IO_GOT_PACKET | IO_MODE_FAST;
+}
+
+/*
+ * Disables and restores interrupts for mp_io(), which does the actual I/O.
+ */
+
+static int multiport_io(struct gameport* gameport, int sendflags, int sendcode, u32 *packet)
+{
+	int status;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	status = mp_io(gameport, sendflags, sendcode, packet);
+	local_irq_restore(flags);
+
+	return status;
+}
+
+/*
+ * Puts multiport into digital mode.  Multiport LED turns green.
+ *
+ * Returns true if a valid digital packet was received, false otherwise.
+ */
+
+static int dig_mode_start(struct gameport *gameport, u32 *packet)
+{
+	int i, seq_len = sizeof(init_seq)/sizeof(int);
+	int flags, tries = 0, bads = 0;
+
+	for (i = 0; i < seq_len; i++) {     /* Send magic sequence */
+		if (init_seq[i])
+			gameport_trigger(gameport);
+		udelay(GRIP_INIT_DELAY);
+	}
+
+	for (i = 0; i < 16; i++)            /* Wait for multiport to settle */
+		udelay(GRIP_INIT_DELAY);
+
+	while (tries < 64 && bads < 8) {    /* Reset multiport and try getting a packet */
+
+		flags = multiport_io(gameport, IO_RESET, 0x27, packet);
+
+		if (flags & IO_MODE_FAST)
+			return 1;
+
+		if (flags & IO_RETRY)
+			tries++;
+		else
+			bads++;
+	}
+	return 0;
+}
+
+/*
+ * Packet structure: B0-B15   => gamepad state
+ *                   B16-B20  => gamepad device type
+ *                   B21-B24  => multiport slot index (1-4)
+ *
+ * Known device types: 0x1f (grip pad), 0x0 (no device).  Others may exist.
+ *
+ * Returns the packet status.
+ */
+
+static int get_and_decode_packet(struct grip_mp *grip, int flags)
+{
+	u32 packet;
+	int joytype = 0;
+	int slot = 0;
+
+	/* Get a packet and check for validity */
+
+	flags &= IO_RESET | IO_RETRY;
+	flags = multiport_io(grip->gameport, flags, 0, &packet);
+	grip->reads++;
+
+	if (packet & PACKET_MP_DONE)
+		flags |= IO_DONE;
+
+	if (flags && !(flags & IO_GOT_PACKET)) {
+		grip->bads++;
+		return flags;
+	}
+
+	/* Ignore non-gamepad packets, e.g. multiport hardware version */
+
+	slot = ((packet >> 21) & 0xf) - 1;
+	if ((slot < 0) || (slot > 3))
+		return flags;
+
+	/*
+	 * Handle "reset" packets, which occur at startup, and when gamepads
+	 * are removed or plugged in.  May contain configuration of a new gamepad.
+	 */
+
+	joytype = (packet >> 16) & 0x1f;
+	if (!joytype) {
+
+		if (grip->registered[slot]) {
+			printk(KERN_INFO "grip_mp: removing %s, slot %d\n",
+			       grip_name[grip->mode[slot]], slot);
+			input_unregister_device(grip->dev + slot);
+			grip->registered[slot] = 0;
+		}
+		dbg("Reset: grip multiport slot %d\n", slot);
+		grip->mode[slot] = GRIP_MODE_RESET;
+		flags |= IO_SLOT_CHANGE;
+		return flags;
+	}
+
+	/* Interpret a grip pad packet */
+
+	if (joytype == 0x1f) {
+
+		int dir = (packet >> 8) & 0xf;          /* eight way directional value */
+		grip->buttons[slot] = (~packet) & 0xff;
+		grip->yaxes[slot] = ((axis_map[dir] >> 2) & 3) - 1;
+		grip->xaxes[slot] = (axis_map[dir] & 3) - 1;
+		grip->dirty[slot] = 1;
+
+		if (grip->mode[slot] == GRIP_MODE_RESET)
+			flags |= IO_SLOT_CHANGE;
+
+		grip->mode[slot] = GRIP_MODE_GP;
+
+		if (!grip->registered[slot]) {
+			dbg("New Grip pad in multiport slot %d.\n", slot);
+			register_slot(slot, grip);
+		}
+		return flags;
+	}
+
+	/* Handle non-grip device codes.  For now, just print diagnostics. */
+
+	{
+		static int strange_code = 0;
+		if (strange_code != joytype) {
+			printk(KERN_INFO "Possible non-grip pad/joystick detected.\n");
+			printk(KERN_INFO "Got joy type 0x%x and packet 0x%x.\n", joytype, packet);
+			strange_code = joytype;
+		}
+	}
+	return flags;
+}
+
+/*
+ * Returns true if all multiport slot states appear valid.
+ */
+
+static int slots_valid(struct grip_mp *grip)
+{
+	int flags, slot, invalid = 0, active = 0;
+
+	flags = get_and_decode_packet(grip, 0);
+	if (!(flags & IO_GOT_PACKET))
+		return 0;
+
+	for (slot = 0; slot < 4; slot++) {
+		if (grip->mode[slot] == GRIP_MODE_RESET)
+			invalid = 1;
+		if (grip->mode[slot] != GRIP_MODE_NONE)
+			active = 1;
+	}
+
+	/* Return true if no active slot but multiport sent all its data */
+	if (!active)
+		return (flags & IO_DONE) ? 1 : 0;
+
+	/* Return false if invalid device code received */
+	return invalid ? 0 : 1;
+}
+
+/*
+ * Returns whether the multiport was placed into digital mode and
+ * able to communicate its state successfully.
+ */
+
+static int multiport_init(struct grip_mp *grip)
+{
+	int dig_mode, initialized = 0, tries = 0;
+	u32 packet;
+
+	dig_mode = dig_mode_start(grip->gameport, &packet);
+	while (!dig_mode && tries < 4) {
+		dig_mode = dig_mode_start(grip->gameport, &packet);
+		tries++;
+	}
+
+	if (dig_mode)
+		dbg("multiport_init(): digital mode activated.\n");
+	else {
+		dbg("multiport_init(): unable to activate digital mode.\n");
+		return 0;
+	}
+
+	/* Get packets, store multiport state, and check state's validity */
+	for (tries = 0; tries < 4096; tries++) {
+		if ( slots_valid(grip) ) {
+			initialized = 1;
+			break;
+		}
+	}
+	dbg("multiport_init(): initialized == %d\n", initialized);
+	return initialized;
+}
+
+/*
+ * Reports joystick state to the linux input layer.
+ */
+
+static void report_slot(struct grip_mp *grip, int slot)
+{
+	struct input_dev *dev = &(grip->dev[slot]);
+	int i, buttons = grip->buttons[slot];
+
+	/* Store button states with linux input driver */
+
+	for (i = 0; i < 8; i++)
+		input_report_key(dev, grip_btn_gp[i], (buttons >> i) & 1);
+
+	/* Store axis states with linux driver */
+
+	input_report_abs(dev, ABS_X, grip->xaxes[slot]);
+	input_report_abs(dev, ABS_Y, grip->yaxes[slot]);
+
+	/* Tell the receiver of the events to process them */
+
+	input_sync(dev);
+
+	grip->dirty[slot] = 0;
+}
+
+/*
+ * Get the multiport state.
+ */
+
+static void grip_poll(struct gameport *gameport)
+{
+	struct grip_mp *grip = gameport_get_drvdata(gameport);
+	int i, npkts, flags;
+
+	for (npkts = 0; npkts < 4; npkts++) {
+		flags = IO_RETRY;
+		for (i = 0; i < 32; i++) {
+			flags = get_and_decode_packet(grip, flags);
+			if ((flags & IO_GOT_PACKET) || !(flags & IO_RETRY))
+				break;
+		}
+		if (flags & IO_DONE)
+			break;
+	}
+
+	for (i = 0; i < 4; i++)
+		if (grip->dirty[i])
+			report_slot(grip, i);
+}
+
+/*
+ * Called when a joystick device file is opened
+ */
+
+static int grip_open(struct input_dev *dev)
+{
+	struct grip_mp *grip = dev->private;
+
+	gameport_start_polling(grip->gameport);
+	return 0;
+}
+
+/*
+ * Called when a joystick device file is closed
+ */
+
+static void grip_close(struct input_dev *dev)
+{
+	struct grip_mp *grip = dev->private;
+
+	gameport_start_polling(grip->gameport);
+}
+
+/*
+ * Tell the linux input layer about a newly plugged-in gamepad.
+ */
+
+static void register_slot(int slot, struct grip_mp *grip)
+{
+	int j, t;
+
+	grip->dev[slot].private = grip;
+	grip->dev[slot].open = grip_open;
+	grip->dev[slot].close = grip_close;
+	grip->dev[slot].name = grip_name[grip->mode[slot]];
+	grip->dev[slot].id.bustype = BUS_GAMEPORT;
+	grip->dev[slot].id.vendor = GAMEPORT_ID_VENDOR_GRAVIS;
+	grip->dev[slot].id.product = 0x0100 + grip->mode[slot];
+	grip->dev[slot].id.version = 0x0100;
+	grip->dev[slot].evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
+
+	for (j = 0; (t = grip_abs[grip->mode[slot]][j]) >= 0; j++)
+		input_set_abs_params(&grip->dev[slot], t, -1, 1, 0, 0);
+
+	for (j = 0; (t = grip_btn[grip->mode[slot]][j]) >= 0; j++)
+		if (t > 0)
+			set_bit(t, grip->dev[slot].keybit);
+
+	input_register_device(grip->dev + slot);
+	grip->registered[slot] = 1;
+
+	if (grip->dirty[slot])	            /* report initial state, if any */
+		report_slot(grip, slot);
+
+	printk(KERN_INFO "grip_mp: added %s, slot %d\n",
+	       grip_name[grip->mode[slot]], slot);
+}
+
+static int grip_connect(struct gameport *gameport, struct gameport_driver *drv)
+{
+	struct grip_mp *grip;
+	int err;
+
+	if (!(grip = kcalloc(1, sizeof(struct grip_mp), GFP_KERNEL)))
+		return -ENOMEM;
+
+	grip->gameport = gameport;
+
+	gameport_set_drvdata(gameport, grip);
+
+	err = gameport_open(gameport, drv, GAMEPORT_MODE_RAW);
+	if (err)
+		goto fail1;
+
+	gameport_set_poll_handler(gameport, grip_poll);
+	gameport_set_poll_interval(gameport, 20);
+
+	if (!multiport_init(grip)) {
+		err = -ENODEV;
+		goto fail2;
+	}
+
+	if (!grip->mode[0] && !grip->mode[1] && !grip->mode[2] && !grip->mode[3]) {
+		/* nothing plugged in */
+		err = -ENODEV;
+		goto fail2;
+	}
+
+	return 0;
+
+fail2:	gameport_close(gameport);
+fail1:	gameport_set_drvdata(gameport, NULL);
+	kfree(grip);
+	return err;
+}
+
+static void grip_disconnect(struct gameport *gameport)
+{
+	struct grip_mp *grip = gameport_get_drvdata(gameport);
+	int i;
+
+	for (i = 0; i < 4; i++)
+		if (grip->registered[i])
+			input_unregister_device(grip->dev + i);
+	gameport_close(gameport);
+	gameport_set_drvdata(gameport, NULL);
+	kfree(grip);
+}
+
+static struct gameport_driver grip_drv = {
+	.driver		= {
+		.name	= "grip_mp",
+	},
+	.description	= DRIVER_DESC,
+	.connect	= grip_connect,
+	.disconnect	= grip_disconnect,
+};
+
+static int __init grip_init(void)
+{
+	gameport_register_driver(&grip_drv);
+	return 0;
+}
+
+static void __exit grip_exit(void)
+{
+	gameport_unregister_driver(&grip_drv);
+}
+
+module_init(grip_init);
+module_exit(grip_exit);
