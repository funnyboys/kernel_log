commit 1d3b9917df9725382f4e0005ecaddee114ebc847
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Apr 3 19:11:46 2018 +0200

    ide: kill ide_toggle_bounce
    
    ide_toggle_bounce did select various strange block bounce limits, including
    not bouncing at all as soon as an iommu is present in the system.  Given
    that the dma_map routines now handle any required bounce buffering except
    for ISA DMA, and the ide code already must handle either ISA DMA or highmem
    at least for iommu equipped systems we can get rid of the block layer
    bounce limit setting entirely.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 54d4d78ca46a..6f344654ef22 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -180,7 +180,6 @@ EXPORT_SYMBOL_GPL(ide_dma_unmap_sg);
 void ide_dma_off_quietly(ide_drive_t *drive)
 {
 	drive->dev_flags &= ~IDE_DFLAG_USING_DMA;
-	ide_toggle_bounce(drive, 0);
 
 	drive->hwif->dma_ops->dma_host_set(drive, 0);
 }
@@ -211,7 +210,6 @@ EXPORT_SYMBOL(ide_dma_off);
 void ide_dma_on(ide_drive_t *drive)
 {
 	drive->dev_flags |= IDE_DFLAG_USING_DMA;
-	ide_toggle_bounce(drive, 1);
 
 	drive->hwif->dma_ops->dma_host_set(drive, 1);
 }

commit 2a842acab109f40f0d7d10b38e9ca88390628996
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jun 3 09:38:04 2017 +0200

    block: introduce new block status code type
    
    Currently we use nornal Linux errno values in the block layer, and while
    we accept any error a few have overloaded magic meanings.  This patch
    instead introduces a new  blk_status_t value that holds block layer specific
    status codes and explicitly explains their meaning.  Helpers to convert from
    and to the previous special meanings are provided for now, but I suspect
    we want to get rid of them in the long run - those drivers that have a
    errno input (e.g. networking) usually get errnos that don't know about
    the special block layer overloads, and similarly returning them to userspace
    will usually return somethings that strictly speaking isn't correct
    for file system operations, but that's left as an exercise for later.
    
    For now the set of errors is a very limited set that closely corresponds
    to the previous overloaded errno values, but there is some low hanging
    fruite to improve it.
    
    blk_status_t (ab)uses the sparse __bitwise annotations to allow for sparse
    typechecking, so that we can easily catch places passing the wrong values.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 51c81223e56d..54d4d78ca46a 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -104,7 +104,7 @@ ide_startstop_t ide_dma_intr(ide_drive_t *drive)
 			if ((cmd->tf_flags & IDE_TFLAG_FS) == 0)
 				ide_finish_cmd(drive, cmd, stat);
 			else
-				ide_complete_rq(drive, 0,
+				ide_complete_rq(drive, BLK_STS_OK,
 						blk_rq_sectors(cmd->rq) << 9);
 			return ide_stopped;
 		}

commit 17d5363b83f8c73ef9109f75a4a9b578f31d842f
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Apr 20 16:03:01 2017 +0200

    scsi: introduce a result field in struct scsi_request
    
    This passes on the scsi_cmnd result field to users of passthrough
    requests.  Currently we abuse req->errors for this purpose, but that
    field will go away in its current form.
    
    Note that the old IDE code abuses the errors field in very creative
    ways and stores all kinds of different values in it.  I didn't dare
    to touch this magic, so the abuses are brought forward 1:1.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Bart Van Assche <Bart.VanAssche@sandisk.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 17a65ac56491..51c81223e56d 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -490,7 +490,7 @@ ide_startstop_t ide_dma_timeout_retry(ide_drive_t *drive, int error)
 	 * make sure request is sane
 	 */
 	if (hwif->rq)
-		hwif->rq->errors = 0;
+		scsi_req(hwif->rq)->result = 0;
 	return ret;
 }
 

commit 38789fda295689689d064c0157bc363b1837b5e6
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jul 17 15:33:58 2011 -0400

    ide/ata: Add export.h for EXPORT_SYMBOL/THIS_MODULE where needed
    
    They were getting this implicitly by an include of module.h
    from device.h -- but we are going to clean that up and break
    that include chain, so include export.h explicitly now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index d4136908f916..17a65ac56491 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -31,6 +31,7 @@
 #include <linux/types.h>
 #include <linux/gfp.h>
 #include <linux/kernel.h>
+#include <linux/export.h>
 #include <linux/ide.h>
 #include <linux/scatterlist.h>
 #include <linux/dma-mapping.h>

commit dd8717da6da9b0e745df49762be4573010f1013c
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Apr 8 01:45:46 2010 -0700

    ide: clean up timed out request handling
    
    8f6205cd572fece673da0255d74843680f67f879 introduced a bug where a
    timed out DMA request is never requeued and lost.
    6072f7491f5ef391a575e18a1165e72a3eef1601 fixed this by making
    ide_dma_timeout_retry() requeue the request itself.  While the fix is
    correct, it makes DMA and non-DMA paths asymmetric regarding how the
    in flight request is requeued.
    
    As long as hwif->rq is set, the IDE driver is assuming ownership of
    the request and the request should either be completed or requeued
    when clearing hwif->rq.  In the timeout path, the ide driver holds
    onto the request as long as the recovery action (ie. reset) is in
    progress and clears it after the state machine is stopped (ide_stopped
    return), so the existing requeueing logic is correct.  The bug
    occurred because ide_dma_timeout_retry() explicitly clears hwif->rq
    without requeueing it.
    
    ide_dma_timeout_retry() is called only by ide_timer_expiry() and
    returns ide_started only when ide_error() would return it - ie. after
    reset state machine has started in which case the state machine will
    eventually end up executing the ide_stopped path in ide_timer_expiry()
    after reset protocol is complete.  So, there is no need to clear
    hwif->rq from ide_dma_timeout_retry().  ide_timer_expiry() will handle
    it the same way as PIO timeout path.
    
    Kill hwif->rq clearing and requeueing from ide_dma_timeout_retry() and
    let ide_timer_expiry() deal with it.  The end result should remain the
    same.
    
    grepping shows ide_dma_timeout_retry() is the only site which clears
    hwif->rq without taking care of the request, so there shouldn't be
    similar fallouts.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 06b14bc9a1d4..d4136908f916 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -449,7 +449,6 @@ ide_startstop_t ide_dma_timeout_retry(ide_drive_t *drive, int error)
 	ide_hwif_t *hwif = drive->hwif;
 	const struct ide_dma_ops *dma_ops = hwif->dma_ops;
 	struct ide_cmd *cmd = &hwif->cmd;
-	struct request *rq;
 	ide_startstop_t ret = ide_stopped;
 
 	/*
@@ -487,14 +486,10 @@ ide_startstop_t ide_dma_timeout_retry(ide_drive_t *drive, int error)
 	ide_dma_off_quietly(drive);
 
 	/*
-	 * un-busy drive etc and make sure request is sane
+	 * make sure request is sane
 	 */
-	rq = hwif->rq;
-	if (rq) {
-		hwif->rq = NULL;
-		rq->errors = 0;
-		ide_requeue_and_plug(drive, rq);
-	}
+	if (hwif->rq)
+		hwif->rq->errors = 0;
 	return ret;
 }
 

commit cf90bfe2ebaf9d32f37acbebb7425c280fd6cd30
Merge: 0a2851b9a837 720fc22a7af7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 8 07:45:36 2010 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/ide-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/ide-2.6:
      ide: Fix IDE taskfile with cfq scheduler
      ide: Must hold queue lock when requeueing
      ide: Requeue request after DMA timeout

commit 6072f7491f5ef391a575e18a1165e72a3eef1601
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Wed Mar 31 20:11:59 2010 +0000

    ide: Requeue request after DMA timeout
    
    I noticed that my KVM virtual machines were experiencing IDE
    issues resulting in processes stuck on waiting for buffers to
    complete.
    
    The root cause is of course race conditions in the ancient qemu
    backend that I'm using.  However, the fact that the guest isn't
    recovering is a bug.
    
    I've tracked it down to the change made last year to dequeue
    requests at the start rather than at the end in the IDE layer.
    
    commit 8f6205cd572fece673da0255d74843680f67f879
    Author: Tejun Heo <tj@kernel.org>
    Date:   Fri May 8 11:53:59 2009 +0900
    
        ide: dequeue in-flight request
    
    The problem is that the function ide_dma_timeout_retry does not
    requeue the current request, causing one request to be lost for
    each DMA timeout.
    
    This patch fixes this by requeueing the request.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index ee58c88dee5a..fd40a8116574 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -492,6 +492,7 @@ ide_startstop_t ide_dma_timeout_retry(ide_drive_t *drive, int error)
 	if (rq) {
 		hwif->rq = NULL;
 		rq->errors = 0;
+		ide_requeue_and_plug(drive, rq);
 	}
 	return ret;
 }

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index ee58c88dee5a..2c17e3fb43e3 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -29,6 +29,7 @@
  */
 
 #include <linux/types.h>
+#include <linux/gfp.h>
 #include <linux/kernel.h>
 #include <linux/ide.h>
 #include <linux/scatterlist.h>

commit 346c17a6cf60375323adfaa4b8a9d841049f890e
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Jun 22 07:38:26 2009 +0000

    ide: relax DMA info validity checking
    
    There are some broken devices that report multiple DMA xfer modes
    enabled at once (ATA spec doesn't allow it) but otherwise work fine
    with DMA so just delete ide_id_dma_bug().
    
    [ As discovered by detective work by Frans and Bart, due to how
      handling of the ID block was handled before commit c419993
      ("ide-iops: only clear DMA words on setting DMA mode") this
      check was always seeing zeros in the fields or other similar
      garbage.  Therefore this check wasn't actually checking anything.
      Now that the tests actually check the real bits, all we see are
      devices that trigger the check yet work perfectly fine, therefore
      killing this useless check is the best thing to do. -DaveM ]
    
    Reported-by: Frans Pop <elendil@planet.nl>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 219e6fb78dc6..ee58c88dee5a 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -361,9 +361,6 @@ static int ide_tune_dma(ide_drive_t *drive)
 	if (__ide_dma_bad_drive(drive))
 		return 0;
 
-	if (ide_id_dma_bug(drive))
-		return 0;
-
 	if (hwif->host_flags & IDE_HFLAG_TRUST_BIOS_FOR_DMA)
 		return config_drive_for_dma(drive);
 
@@ -394,24 +391,6 @@ static int ide_dma_check(ide_drive_t *drive)
 	return -1;
 }
 
-int ide_id_dma_bug(ide_drive_t *drive)
-{
-	u16 *id = drive->id;
-
-	if (id[ATA_ID_FIELD_VALID] & 4) {
-		if ((id[ATA_ID_UDMA_MODES] >> 8) &&
-		    (id[ATA_ID_MWDMA_MODES] >> 8))
-			goto err_out;
-	} else if ((id[ATA_ID_MWDMA_MODES] >> 8) &&
-		   (id[ATA_ID_SWDMA_MODES] >> 8))
-		goto err_out;
-
-	return 0;
-err_out:
-	printk(KERN_ERR "%s: bad DMA info in identify block\n", drive->name);
-	return 1;
-}
-
 int ide_set_dma(ide_drive_t *drive)
 {
 	int rc;

commit d614aec4752f8c61b2e7cb77806b6bd59aa50836
Merge: db8e7f10ed67 ad7c52d0988a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 12 09:29:42 2009 -0700

    Merge branch 'for-2.6.31' of git://git.kernel.org/pub/scm/linux/kernel/git/bart/ide-2.6
    
    * 'for-2.6.31' of git://git.kernel.org/pub/scm/linux/kernel/git/bart/ide-2.6: (29 commits)
      ide: re-implement ide_pci_init_one() on top of ide_pci_init_two()
      ide: unexport ide_find_dma_mode()
      ide: fix PowerMac bootup oops
      ide: skip probe if there are no devices on the port (v2)
      sl82c105: add printk() logging facility
      ide-tape: fix proc warning
      ide: add IDE_DFLAG_NIEN_QUIRK device flag
      ide: respect quirk_drives[] list on all controllers
      hpt366: enable all quirks for devices on quirk_drives[] list
      hpt366: sync quirk_drives[] list with pdc202xx_{new,old}.c
      ide: remove superfluous SELECT_MASK() call from do_rw_taskfile()
      ide: remove superfluous SELECT_MASK() call from ide_driveid_update()
      icside: remove superfluous ->maskproc method
      ide-tape: fix IDE_AFLAG_* atomic accesses
      ide-tape: change IDE_AFLAG_IGNORE_DSC non-atomically
      pdc202xx_old: kill resetproc() method
      pdc202xx_old: don't call pdc202xx_reset() on IRQ timeout
      pdc202xx_old: use ide_dma_test_irq()
      ide: preserve Host Protected Area by default (v2)
      ide-gd: implement block device ->set_capacity method (v2)
      ...

commit 5df3bc2d35bd5cd08053f71679b27577b42676d6
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jun 10 14:37:21 2009 +0200

    ide: unexport ide_find_dma_mode()
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index d9123ecae4a9..0bbf71f8e499 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -347,7 +347,6 @@ u8 ide_find_dma_mode(ide_drive_t *drive, u8 req_mode)
 
 	return mode;
 }
-EXPORT_SYMBOL_GPL(ide_find_dma_mode);
 
 static int ide_tune_dma(ide_drive_t *drive)
 {

commit 9780e2dd8254351f6cbe11304849126b51dbd561
Author: Tejun Heo <tj@kernel.org>
Date:   Thu May 7 22:24:40 2009 +0900

    ide: convert to rq pos and nr_sectors accessors
    
    ide doesn't manipulate request fields anymore and thus all hard and
    their soft equivalents are always equal.  Convert all references to
    accessors.
    
    [ Impact: use pos and nr_sectors accessors ]
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Cc: Borislav Petkov <petkovbb@googlemail.com>
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index d9123ecae4a9..001f68f0bb28 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -103,7 +103,7 @@ ide_startstop_t ide_dma_intr(ide_drive_t *drive)
 				ide_finish_cmd(drive, cmd, stat);
 			else
 				ide_complete_rq(drive, 0,
-						cmd->rq->nr_sectors << 9);
+						blk_rq_sectors(cmd->rq) << 9);
 			return ide_stopped;
 		}
 		printk(KERN_ERR "%s: %s: bad DMA status (0x%02x)\n",

commit 586cf2681f527ce8b85b9bd57c8b9f7945fbe051
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Apr 21 12:16:56 2009 +0900

    ide-dma: don't reset request fields on dma_timeout_retry()
    
    Impact: drop unnecessary code
    
    Now that everything uses bio and block operations, there is no need to
    reset request fields manually when retrying a request.  Every field is
    guaranteed to be always valid.  Drop unnecessary request field
    resetting from ide_dma_timeout_retry().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index a0b8cab1d9a6..d9123ecae4a9 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -510,23 +510,11 @@ ide_startstop_t ide_dma_timeout_retry(ide_drive_t *drive, int error)
 	/*
 	 * un-busy drive etc and make sure request is sane
 	 */
-
 	rq = hwif->rq;
-	if (!rq)
-		goto out;
-
-	hwif->rq = NULL;
-
-	rq->errors = 0;
-
-	if (!rq->bio)
-		goto out;
-
-	rq->sector = rq->bio->bi_sector;
-	rq->current_nr_sectors = bio_iovec(rq->bio)->bv_len >> 9;
-	rq->hard_cur_sectors = rq->current_nr_sectors;
-	rq->buffer = bio_data(rq->bio);
-out:
+	if (rq) {
+		hwif->rq = NULL;
+		rq->errors = 0;
+	}
 	return ret;
 }
 

commit 2ecf0a57c60dcb588f310d94412118e15c510532
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Apr 21 12:16:56 2009 +0900

    ide-dma: don't reset request fields on dma_timeout_retry()
    
    Impact: drop unnecessary code
    
    Now that everything uses bio and block operations, there is no need to
    reset request fields manually when retrying a request.  Every field is
    guaranteed to be always valid.  Drop unnecessary request field
    resetting from ide_dma_timeout_retry().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index a0b8cab1d9a6..d9123ecae4a9 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -510,23 +510,11 @@ ide_startstop_t ide_dma_timeout_retry(ide_drive_t *drive, int error)
 	/*
 	 * un-busy drive etc and make sure request is sane
 	 */
-
 	rq = hwif->rq;
-	if (!rq)
-		goto out;
-
-	hwif->rq = NULL;
-
-	rq->errors = 0;
-
-	if (!rq->bio)
-		goto out;
-
-	rq->sector = rq->bio->bi_sector;
-	rq->current_nr_sectors = bio_iovec(rq->bio)->bv_len >> 9;
-	rq->hard_cur_sectors = rq->current_nr_sectors;
-	rq->buffer = bio_data(rq->bio);
-out:
+	if (rq) {
+		hwif->rq = NULL;
+		rq->errors = 0;
+	}
 	return ret;
 }
 

commit 74638c84821c066d02c158bc843c84499ddc9764
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Tue Mar 31 20:15:28 2009 +0200

    ide: add support for CFA specified transfer modes (take 3)
    
    Add support for the CompactFlash specific PIO modes 5/6 and MWDMA modes 3/4.
    
    Since there were no PIO5 capable hard drives produced and one would also need
    66 MHz IDE clock to actually get the difference WRT the address setup timings
    programmed, I decided to simply replace the old non-standard PIO mode 5 timings
    with the CFA specified ones.
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: stf_xl@wp.pl
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index f9c91752f275..a0b8cab1d9a6 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -261,6 +261,14 @@ static unsigned int ide_get_mode_mask(ide_drive_t *drive, u8 base, u8 req_mode)
 		break;
 	case XFER_MW_DMA_0:
 		mask = id[ATA_ID_MWDMA_MODES];
+
+		/* Also look for the CF specific MWDMA modes... */
+		if (ata_id_is_cfa(id) && (id[ATA_ID_CFA_MODES] & 0x38)) {
+			u8 mode = ((id[ATA_ID_CFA_MODES] & 0x38) >> 3) - 1;
+
+			mask |= ((2 << mode) - 1) << 3;
+		}
+
 		if (port_ops && port_ops->mdma_filter)
 			mask &= port_ops->mdma_filter(drive);
 		else

commit 8d64fcd9357798ad0d61f8877de13d5e1b1ab510
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Tue Mar 31 20:15:27 2009 +0200

    ide: identify data word 53 bit 1 doesn't cover words 62 and 63 (take 3)
    
    The IDE code assumed for years that the bit 1 of the identify data word 53 also
    covers the validity of the SW/MW DMA information in words 62 and 63, but it has
    always covered only words 64 thru 70, with words 62 and 63 being defined in the
    original ATA spec, not in ATA-2...
    
    This fix however should only concern *very* old hard disks and rather old CF
    cards...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index a5612eadc306..f9c91752f275 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -245,12 +245,11 @@ static unsigned int ide_get_mode_mask(ide_drive_t *drive, u8 base, u8 req_mode)
 	case XFER_UDMA_0:
 		if ((id[ATA_ID_FIELD_VALID] & 4) == 0)
 			break;
-
+		mask = id[ATA_ID_UDMA_MODES];
 		if (port_ops && port_ops->udma_filter)
-			mask = port_ops->udma_filter(drive);
+			mask &= port_ops->udma_filter(drive);
 		else
-			mask = hwif->ultra_mask;
-		mask &= id[ATA_ID_UDMA_MODES];
+			mask &= hwif->ultra_mask;
 
 		/*
 		 * avoid false cable warning from eighty_ninty_three()
@@ -261,18 +260,15 @@ static unsigned int ide_get_mode_mask(ide_drive_t *drive, u8 base, u8 req_mode)
 		}
 		break;
 	case XFER_MW_DMA_0:
-		if ((id[ATA_ID_FIELD_VALID] & 2) == 0)
-			break;
+		mask = id[ATA_ID_MWDMA_MODES];
 		if (port_ops && port_ops->mdma_filter)
-			mask = port_ops->mdma_filter(drive);
+			mask &= port_ops->mdma_filter(drive);
 		else
-			mask = hwif->mwdma_mask;
-		mask &= id[ATA_ID_MWDMA_MODES];
+			mask &= hwif->mwdma_mask;
 		break;
 	case XFER_SW_DMA_0:
-		if (id[ATA_ID_FIELD_VALID] & 2) {
-			mask = id[ATA_ID_SWDMA_MODES] & hwif->swdma_mask;
-		} else if (id[ATA_ID_OLD_DMA_MODES] >> 8) {
+		mask = id[ATA_ID_SWDMA_MODES];
+		if (!(mask & ATA_SWDMA2) && (id[ATA_ID_OLD_DMA_MODES] >> 8)) {
 			u8 mode = id[ATA_ID_OLD_DMA_MODES] >> 8;
 
 			/*
@@ -280,8 +276,9 @@ static unsigned int ide_get_mode_mask(ide_drive_t *drive, u8 base, u8 req_mode)
 			 * (the maximum allowed mode is XFER_SW_DMA_2)
 			 */
 			if (mode <= 2)
-				mask = ((2 << mode) - 1) & hwif->swdma_mask;
+				mask = (2 << mode) - 1;
 		}
+		mask &= hwif->swdma_mask;
 		break;
 	default:
 		BUG();
@@ -398,11 +395,10 @@ int ide_id_dma_bug(ide_drive_t *drive)
 		if ((id[ATA_ID_UDMA_MODES] >> 8) &&
 		    (id[ATA_ID_MWDMA_MODES] >> 8))
 			goto err_out;
-	} else if (id[ATA_ID_FIELD_VALID] & 2) {
-		if ((id[ATA_ID_MWDMA_MODES] >> 8) &&
-		    (id[ATA_ID_SWDMA_MODES] >> 8))
-			goto err_out;
-	}
+	} else if ((id[ATA_ID_MWDMA_MODES] >> 8) &&
+		   (id[ATA_ID_SWDMA_MODES] >> 8))
+		goto err_out;
+
 	return 0;
 err_out:
 	printk(KERN_ERR "%s: bad DMA info in identify block\n", drive->name);

commit f094d4d83bccee9277ddb6aadccf35747889426b
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Mar 31 20:15:24 2009 +0200

    ide: sanitize ide_build_sglist() and ide_destroy_dmatable()
    
    * Move ide_map_sg() calls out from ide_build_sglist()
      to ide_dma_prepare().
    
    * Pass command to ide_destroy_dmatable().
    
    * Rename ide_build_sglist() to ide_dma_map_sg()
      and ide_destroy_dmatable() to ide_dma_unmap_sg().
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 4d3102887d9c..a5612eadc306 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -89,17 +89,16 @@ static const struct drive_list_entry drive_blacklist[] = {
 ide_startstop_t ide_dma_intr(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = drive->hwif;
+	struct ide_cmd *cmd = &hwif->cmd;
 	u8 stat = 0, dma_stat = 0;
 
 	drive->waiting_for_dma = 0;
 	dma_stat = hwif->dma_ops->dma_end(drive);
-	ide_destroy_dmatable(drive);
+	ide_dma_unmap_sg(drive, cmd);
 	stat = hwif->tp_ops->read_status(hwif);
 
 	if (OK_STAT(stat, DRIVE_READY, drive->bad_wstat | ATA_DRQ)) {
 		if (!dma_stat) {
-			struct ide_cmd *cmd = &hwif->cmd;
-
 			if ((cmd->tf_flags & IDE_TFLAG_FS) == 0)
 				ide_finish_cmd(drive, cmd, stat);
 			else
@@ -119,8 +118,8 @@ int ide_dma_good_drive(ide_drive_t *drive)
 }
 
 /**
- *	ide_build_sglist	-	map IDE scatter gather for DMA I/O
- *	@drive: the drive to build the DMA table for
+ *	ide_dma_map_sg	-	map IDE scatter gather for DMA I/O
+ *	@drive: the drive to map the DMA table for
  *	@cmd: command
  *
  *	Perform the DMA mapping magic necessary to access the source or
@@ -129,23 +128,19 @@ int ide_dma_good_drive(ide_drive_t *drive)
  *	operate in a portable fashion.
  */
 
-static int ide_build_sglist(ide_drive_t *drive, struct ide_cmd *cmd)
+static int ide_dma_map_sg(ide_drive_t *drive, struct ide_cmd *cmd)
 {
 	ide_hwif_t *hwif = drive->hwif;
 	struct scatterlist *sg = hwif->sg_table;
 	int i;
 
-	ide_map_sg(drive, cmd);
-
 	if (cmd->tf_flags & IDE_TFLAG_WRITE)
 		cmd->sg_dma_direction = DMA_TO_DEVICE;
 	else
 		cmd->sg_dma_direction = DMA_FROM_DEVICE;
 
 	i = dma_map_sg(hwif->dev, sg, cmd->sg_nents, cmd->sg_dma_direction);
-	if (i == 0)
-		ide_map_sg(drive, cmd);
-	else {
+	if (i) {
 		cmd->orig_sg_nents = cmd->sg_nents;
 		cmd->sg_nents = i;
 	}
@@ -154,7 +149,7 @@ static int ide_build_sglist(ide_drive_t *drive, struct ide_cmd *cmd)
 }
 
 /**
- *	ide_destroy_dmatable	-	clean up DMA mapping
+ *	ide_dma_unmap_sg	-	clean up DMA mapping
  *	@drive: The drive to unmap
  *
  *	Teardown mappings after DMA has completed. This must be called
@@ -164,15 +159,14 @@ static int ide_build_sglist(ide_drive_t *drive, struct ide_cmd *cmd)
  *	time.
  */
 
-void ide_destroy_dmatable(ide_drive_t *drive)
+void ide_dma_unmap_sg(ide_drive_t *drive, struct ide_cmd *cmd)
 {
 	ide_hwif_t *hwif = drive->hwif;
-	struct ide_cmd *cmd = &hwif->cmd;
 
 	dma_unmap_sg(hwif->dev, hwif->sg_table, cmd->orig_sg_nents,
 		     cmd->sg_dma_direction);
 }
-EXPORT_SYMBOL_GPL(ide_destroy_dmatable);
+EXPORT_SYMBOL_GPL(ide_dma_unmap_sg);
 
 /**
  *	ide_dma_off_quietly	-	Generic DMA kill
@@ -471,6 +465,7 @@ ide_startstop_t ide_dma_timeout_retry(ide_drive_t *drive, int error)
 {
 	ide_hwif_t *hwif = drive->hwif;
 	const struct ide_dma_ops *dma_ops = hwif->dma_ops;
+	struct ide_cmd *cmd = &hwif->cmd;
 	struct request *rq;
 	ide_startstop_t ret = ide_stopped;
 
@@ -482,7 +477,7 @@ ide_startstop_t ide_dma_timeout_retry(ide_drive_t *drive, int error)
 		printk(KERN_WARNING "%s: DMA timeout error\n", drive->name);
 		drive->waiting_for_dma = 0;
 		(void)dma_ops->dma_end(drive);
-		ide_destroy_dmatable(drive);
+		ide_dma_unmap_sg(drive, cmd);
 		ret = ide_error(drive, "dma timeout error",
 				hwif->tp_ops->read_status(hwif));
 	} else {
@@ -495,7 +490,7 @@ ide_startstop_t ide_dma_timeout_retry(ide_drive_t *drive, int error)
 					hwif->tp_ops->read_status(hwif));
 			drive->waiting_for_dma = 0;
 			(void)dma_ops->dma_end(drive);
-			ide_destroy_dmatable(drive);
+			ide_dma_unmap_sg(drive, cmd);
 		}
 	}
 
@@ -572,14 +567,19 @@ int ide_dma_prepare(ide_drive_t *drive, struct ide_cmd *cmd)
 	const struct ide_dma_ops *dma_ops = drive->hwif->dma_ops;
 
 	if ((drive->dev_flags & IDE_DFLAG_USING_DMA) == 0 ||
-	    (dma_ops->dma_check && dma_ops->dma_check(drive, cmd)) ||
-	    ide_build_sglist(drive, cmd) == 0)
-		return 1;
-	if (dma_ops->dma_setup(drive, cmd)) {
-		ide_destroy_dmatable(drive);
-		ide_map_sg(drive, cmd);
-		return 1;
-	}
+	    (dma_ops->dma_check && dma_ops->dma_check(drive, cmd)))
+		goto out;
+	ide_map_sg(drive, cmd);
+	if (ide_dma_map_sg(drive, cmd) == 0)
+		goto out_map;
+	if (dma_ops->dma_setup(drive, cmd))
+		goto out_dma_unmap;
 	drive->waiting_for_dma = 1;
 	return 0;
+out_dma_unmap:
+	ide_dma_unmap_sg(drive, cmd);
+out_map:
+	ide_map_sg(drive, cmd);
+out:
+	return 1;
 }

commit 88b4132e101e60e8fa67996ae3072ab6b71e8500
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Mar 31 20:15:22 2009 +0200

    ide: set/clear drive->waiting_for_dma flag in the core code
    
    Set/clear drive->waiting_for_dma flag in the core code
    instead of in ->dma_setup and ->dma_end methods.
    
    There should be no functional changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index d61f9a8cc18a..4d3102887d9c 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -91,6 +91,7 @@ ide_startstop_t ide_dma_intr(ide_drive_t *drive)
 	ide_hwif_t *hwif = drive->hwif;
 	u8 stat = 0, dma_stat = 0;
 
+	drive->waiting_for_dma = 0;
 	dma_stat = hwif->dma_ops->dma_end(drive);
 	ide_destroy_dmatable(drive);
 	stat = hwif->tp_ops->read_status(hwif);
@@ -479,6 +480,7 @@ ide_startstop_t ide_dma_timeout_retry(ide_drive_t *drive, int error)
 
 	if (error < 0) {
 		printk(KERN_WARNING "%s: DMA timeout error\n", drive->name);
+		drive->waiting_for_dma = 0;
 		(void)dma_ops->dma_end(drive);
 		ide_destroy_dmatable(drive);
 		ret = ide_error(drive, "dma timeout error",
@@ -491,6 +493,7 @@ ide_startstop_t ide_dma_timeout_retry(ide_drive_t *drive, int error)
 		if (dma_ops->dma_test_irq(drive) == 0) {
 			ide_dump_status(drive, "DMA timeout",
 					hwif->tp_ops->read_status(hwif));
+			drive->waiting_for_dma = 0;
 			(void)dma_ops->dma_end(drive);
 			ide_destroy_dmatable(drive);
 		}
@@ -577,5 +580,6 @@ int ide_dma_prepare(ide_drive_t *drive, struct ide_cmd *cmd)
 		ide_map_sg(drive, cmd);
 		return 1;
 	}
+	drive->waiting_for_dma = 1;
 	return 0;
 }

commit 11998b316173f814698f9037ce9179d634d1f423
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Mar 31 20:15:21 2009 +0200

    ide: move ide_map_sg() call out of ->dma_setup method (take 2)
    
    Move ide_map_sg() call from ->dma_setup implementations and
    ide_destroy_dmatable() one from *_build_dmatable() to ide_dma_prepare().
    
    There should be no functional changes caused by this patch.
    
    Sergei:
    Removed 'use_pio_instead' labels and replaced 'goto' with 'return 0' --
    that required no changes to the follow-up patches...
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index c0505e2dfc2e..d61f9a8cc18a 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -570,8 +570,12 @@ int ide_dma_prepare(ide_drive_t *drive, struct ide_cmd *cmd)
 
 	if ((drive->dev_flags & IDE_DFLAG_USING_DMA) == 0 ||
 	    (dma_ops->dma_check && dma_ops->dma_check(drive, cmd)) ||
-	    ide_build_sglist(drive, cmd) == 0 ||
-	    dma_ops->dma_setup(drive, cmd))
+	    ide_build_sglist(drive, cmd) == 0)
 		return 1;
+	if (dma_ops->dma_setup(drive, cmd)) {
+		ide_destroy_dmatable(drive);
+		ide_map_sg(drive, cmd);
+		return 1;
+	}
 	return 0;
 }

commit 8a4a5738ba499083cf4c5668895efe220b1946d3
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Mar 31 20:15:21 2009 +0200

    ide: add ->dma_check method
    
    * Add (an optional) ->dma_check method for checking if DMA can be
      used for a given command and fail DMA setup in ide_dma_prepare()
      if necessary.
    
    * Convert alim15x3 and trm290 host drivers to use ->dma_check.
    
    * Rename ali15x3_dma_setup() to ali_dma_check() while at it.
    
    There should be no functional changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index cf5897f5533f..c0505e2dfc2e 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -566,9 +566,12 @@ EXPORT_SYMBOL_GPL(ide_allocate_dma_engine);
 
 int ide_dma_prepare(ide_drive_t *drive, struct ide_cmd *cmd)
 {
+	const struct ide_dma_ops *dma_ops = drive->hwif->dma_ops;
+
 	if ((drive->dev_flags & IDE_DFLAG_USING_DMA) == 0 ||
+	    (dma_ops->dma_check && dma_ops->dma_check(drive, cmd)) ||
 	    ide_build_sglist(drive, cmd) == 0 ||
-	    drive->hwif->dma_ops->dma_setup(drive, cmd))
+	    dma_ops->dma_setup(drive, cmd))
 		return 1;
 	return 0;
 }

commit 5ae5412d9a23b05ab08461b202bad21ad8f6b66d
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Mar 31 20:15:20 2009 +0200

    ide: add ide_dma_prepare() helper
    
    * Add ide_dma_prepare() helper.
    
    * Convert ide_issue_pc() and do_rw_taskfile() to use it.
    
    * Make ide_build_sglist() static.
    
    There should be no functional changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index b430898bbcd6..cf5897f5533f 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -128,7 +128,7 @@ int ide_dma_good_drive(ide_drive_t *drive)
  *	operate in a portable fashion.
  */
 
-int ide_build_sglist(ide_drive_t *drive, struct ide_cmd *cmd)
+static int ide_build_sglist(ide_drive_t *drive, struct ide_cmd *cmd)
 {
 	ide_hwif_t *hwif = drive->hwif;
 	struct scatterlist *sg = hwif->sg_table;
@@ -563,3 +563,12 @@ int ide_allocate_dma_engine(ide_hwif_t *hwif)
 	return 0;
 }
 EXPORT_SYMBOL_GPL(ide_allocate_dma_engine);
+
+int ide_dma_prepare(ide_drive_t *drive, struct ide_cmd *cmd)
+{
+	if ((drive->dev_flags & IDE_DFLAG_USING_DMA) == 0 ||
+	    ide_build_sglist(drive, cmd) == 0 ||
+	    drive->hwif->dma_ops->dma_setup(drive, cmd))
+		return 1;
+	return 0;
+}

commit 4453011f959a5f5c6c7a33aea54fe17f5e43a867
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Mar 31 20:15:20 2009 +0200

    ide: destroy DMA mappings after ending DMA (v2)
    
    Move ide_destroy_dmatable() call out from ->dma_end method to
    {ide_pc,cdrom_newpc,ide_dma}_intr(), ide_dma_timeout_retry()
    and sgiioc4_resetproc().
    
    This causes minor/safe behavior changes w.r.t.:
    * cmd64x.c::cmd64{8,x}_dma_end()
    * cs5536.c::cs5536_dma_end()
    * icside.c::icside_dma_end()
    * it821x.c::it821x_dma_end()
    * scc_pata.c::__scc_dma_end()
    * sl82c105.c::sl82c105_dma_end()
    * tx4939ide.c::tx4939ide_dma_end()
    
    v2:
    * Fix build for CONFIG_BLK_DEV_IDEDMA=n (reported by Randy Dunlap).
    
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 4e2005071113..b430898bbcd6 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -92,6 +92,7 @@ ide_startstop_t ide_dma_intr(ide_drive_t *drive)
 	u8 stat = 0, dma_stat = 0;
 
 	dma_stat = hwif->dma_ops->dma_end(drive);
+	ide_destroy_dmatable(drive);
 	stat = hwif->tp_ops->read_status(hwif);
 
 	if (OK_STAT(stat, DRIVE_READY, drive->bad_wstat | ATA_DRQ)) {
@@ -479,6 +480,7 @@ ide_startstop_t ide_dma_timeout_retry(ide_drive_t *drive, int error)
 	if (error < 0) {
 		printk(KERN_WARNING "%s: DMA timeout error\n", drive->name);
 		(void)dma_ops->dma_end(drive);
+		ide_destroy_dmatable(drive);
 		ret = ide_error(drive, "dma timeout error",
 				hwif->tp_ops->read_status(hwif));
 	} else {
@@ -490,6 +492,7 @@ ide_startstop_t ide_dma_timeout_retry(ide_drive_t *drive, int error)
 			ide_dump_status(drive, "DMA timeout",
 					hwif->tp_ops->read_status(hwif));
 			(void)dma_ops->dma_end(drive);
+			ide_destroy_dmatable(drive);
 		}
 	}
 

commit 1cee52de28aa687760ad262ad0834d1bf6c6d2ac
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Mar 31 20:15:19 2009 +0200

    ide: inline ide_dma_timeout() into ide_dma_timeout_retry()
    
    Since ide_dma_timeout() is only used by ide_dma_timeout_retry()
    inline it there.
    
    There should be no functional changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index dc5d9bc4ced0..4e2005071113 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -460,20 +460,6 @@ void ide_dma_lost_irq(ide_drive_t *drive)
 }
 EXPORT_SYMBOL_GPL(ide_dma_lost_irq);
 
-static void ide_dma_timeout(ide_drive_t *drive)
-{
-	ide_hwif_t *hwif = drive->hwif;
-
-	printk(KERN_ERR "%s: timeout waiting for DMA\n", drive->name);
-
-	if (hwif->dma_ops->dma_test_irq(drive))
-		return;
-
-	ide_dump_status(drive, "DMA timeout", hwif->tp_ops->read_status(hwif));
-
-	hwif->dma_ops->dma_end(drive);
-}
-
 /*
  * un-busy the port etc, and clear any pending DMA status. we want to
  * retry the current request in pio mode instead of risking tossing it
@@ -499,7 +485,12 @@ ide_startstop_t ide_dma_timeout_retry(ide_drive_t *drive, int error)
 		printk(KERN_WARNING "%s: DMA timeout retry\n", drive->name);
 		if (dma_ops->dma_clear)
 			dma_ops->dma_clear(drive);
-		ide_dma_timeout(drive);
+		printk(KERN_ERR "%s: timeout waiting for DMA\n", drive->name);
+		if (dma_ops->dma_test_irq(drive) == 0) {
+			ide_dump_status(drive, "DMA timeout",
+					hwif->tp_ops->read_status(hwif));
+			(void)dma_ops->dma_end(drive);
+		}
 	}
 
 	/*

commit 35c9b4daf4c94b30e5cede597d98016ebf31b5ad
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Mar 31 20:15:19 2009 +0200

    ide: add ->dma_clear method and remove ->dma_timeout one
    
    All custom ->dma_timeout implementations call the generic one thus it is
    possible to have only an optional method for resetting DMA engine instead:
    
    * Add ->dma_clear method and convert hpt366, pdc202xx_old and sl82c105
      host drivers to use it.
    
    * Always use ide_dma_timeout() in ide_dma_timeout_retry() and remove
     ->dma_timeout method.
    
    * Make ide_dma_timeout() static.
    
    There should be no functional changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 3dbf80c15491..dc5d9bc4ced0 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -460,7 +460,7 @@ void ide_dma_lost_irq(ide_drive_t *drive)
 }
 EXPORT_SYMBOL_GPL(ide_dma_lost_irq);
 
-void ide_dma_timeout(ide_drive_t *drive)
+static void ide_dma_timeout(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = drive->hwif;
 
@@ -473,7 +473,6 @@ void ide_dma_timeout(ide_drive_t *drive)
 
 	hwif->dma_ops->dma_end(drive);
 }
-EXPORT_SYMBOL_GPL(ide_dma_timeout);
 
 /*
  * un-busy the port etc, and clear any pending DMA status. we want to
@@ -483,6 +482,7 @@ EXPORT_SYMBOL_GPL(ide_dma_timeout);
 ide_startstop_t ide_dma_timeout_retry(ide_drive_t *drive, int error)
 {
 	ide_hwif_t *hwif = drive->hwif;
+	const struct ide_dma_ops *dma_ops = hwif->dma_ops;
 	struct request *rq;
 	ide_startstop_t ret = ide_stopped;
 
@@ -492,12 +492,14 @@ ide_startstop_t ide_dma_timeout_retry(ide_drive_t *drive, int error)
 
 	if (error < 0) {
 		printk(KERN_WARNING "%s: DMA timeout error\n", drive->name);
-		(void)hwif->dma_ops->dma_end(drive);
+		(void)dma_ops->dma_end(drive);
 		ret = ide_error(drive, "dma timeout error",
 				hwif->tp_ops->read_status(hwif));
 	} else {
 		printk(KERN_WARNING "%s: DMA timeout retry\n", drive->name);
-		hwif->dma_ops->dma_timeout(drive);
+		if (dma_ops->dma_clear)
+			dma_ops->dma_clear(drive);
+		ide_dma_timeout(drive);
 	}
 
 	/*

commit 22117d6eaac50d366d9013c88318a869ea4d8739
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Mar 27 12:46:47 2009 +0100

    ide: add ->dma_timer_expiry method and remove ->dma_exec_cmd one (v2)
    
    * Rename dma_timer_expiry() to ide_dma_sff_timer_expiry() and export it.
    
    * Add ->dma_timer_expiry method and use it to set hwif->expiry for
      ATA_PROT_DMA protocol in do_rw_taskfile().
    
    * Initialize ->dma_timer_expiry to ide_dma_sff_timer_expiry() for SFF hosts.
    
    * Move setting hwif->expiry from ide_execute_command() to its users and drop
      'expiry' argument.
    
    * Use ide_execute_command() instead of ->dma_exec_cmd in do_rw_taskfile().
    
    * Remove ->dma_exec_cmd method and its implementations.
    
    * Unexport ide_execute_command() and ide_dma_intr().
    
    v2:
    * Fix CONFIG_BLK_DEV_IDEDMA=n build (noticed by Randy Dunlap).
    
    * Fix *dma_expiry naming (suggested by Sergei Shtylyov).
    
    There should be no functional changes caused by this patch.
    
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index ad4edab9b0a9..3dbf80c15491 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -110,7 +110,6 @@ ide_startstop_t ide_dma_intr(ide_drive_t *drive)
 	}
 	return ide_error(drive, "dma_intr", stat);
 }
-EXPORT_SYMBOL_GPL(ide_dma_intr);
 
 int ide_dma_good_drive(ide_drive_t *drive)
 {

commit 2298169418f43ba5e0919762a4bab95a1227872a
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Mar 27 12:46:46 2009 +0100

    ide: pass command to ide_map_sg()
    
    * Set IDE_TFLAG_WRITE flag and ->rq also for ATA_CMD_PACKET
      commands.
    
    * Pass command to ->dma_setup method and update all its
      implementations accordingly.
    
    * Pass command instead of request to ide_build_sglist(),
      *_build_dmatable() and ide_map_sg().
    
    While at it:
    
    * Fix scc_dma_setup() documentation + use ATA_DMA_WR define.
    
    * Rename sgiioc4_build_dma_table() to sgiioc4_build_dmatable(),
      change return value type to 'int' and drop unused 'ddir'
      argument.
    
    * Do some minor cleanups in [tx4939]ide_dma_setup().
    
    There should be no functional changes caused by this patch.
    
    Acked-by: Borislav Petkov <petkovbb@gmail.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 8f5e32e692f0..ad4edab9b0a9 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -120,7 +120,7 @@ int ide_dma_good_drive(ide_drive_t *drive)
 /**
  *	ide_build_sglist	-	map IDE scatter gather for DMA I/O
  *	@drive: the drive to build the DMA table for
- *	@rq: the request holding the sg list
+ *	@cmd: command
  *
  *	Perform the DMA mapping magic necessary to access the source or
  *	target buffers of a request via DMA.  The lower layers of the
@@ -128,23 +128,22 @@ int ide_dma_good_drive(ide_drive_t *drive)
  *	operate in a portable fashion.
  */
 
-int ide_build_sglist(ide_drive_t *drive, struct request *rq)
+int ide_build_sglist(ide_drive_t *drive, struct ide_cmd *cmd)
 {
 	ide_hwif_t *hwif = drive->hwif;
 	struct scatterlist *sg = hwif->sg_table;
-	struct ide_cmd *cmd = &hwif->cmd;
 	int i;
 
-	ide_map_sg(drive, rq);
+	ide_map_sg(drive, cmd);
 
-	if (rq_data_dir(rq) == READ)
-		cmd->sg_dma_direction = DMA_FROM_DEVICE;
-	else
+	if (cmd->tf_flags & IDE_TFLAG_WRITE)
 		cmd->sg_dma_direction = DMA_TO_DEVICE;
+	else
+		cmd->sg_dma_direction = DMA_FROM_DEVICE;
 
 	i = dma_map_sg(hwif->dev, sg, cmd->sg_nents, cmd->sg_dma_direction);
 	if (i == 0)
-		ide_map_sg(drive, rq);
+		ide_map_sg(drive, cmd);
 	else {
 		cmd->orig_sg_nents = cmd->sg_nents;
 		cmd->sg_nents = i;

commit 130e886708d6e11f3d54e5d27c266578de56f343
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Mar 27 12:46:45 2009 +0100

    ide: remove ide_end_request()
    
    * Add ide_rq_bytes() helper.
    
    * Add blk_noretry_request() quirk to ide_complete_rq() (currently only fs
      requests can be marked as "noretry" so there is no change in behavior).
    
    * Switch current ide_end_request() users to use ide_complete_rq().
    
      [ No need to check for rq->nr_sectors == 0 in {ide_dma,task_pio}_intr(),
        nsectors == 0 in cdrom_end_request() and err == 0 in ide_do_devset(). ]
    
    * Remove no longer needed ide_end_request().
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 820e5104ba47..8f5e32e692f0 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -101,7 +101,8 @@ ide_startstop_t ide_dma_intr(ide_drive_t *drive)
 			if ((cmd->tf_flags & IDE_TFLAG_FS) == 0)
 				ide_finish_cmd(drive, cmd, stat);
 			else
-				ide_end_request(drive, 1, cmd->rq->nr_sectors);
+				ide_complete_rq(drive, 0,
+						cmd->rq->nr_sectors << 9);
 			return ide_stopped;
 		}
 		printk(KERN_ERR "%s: %s: bad DMA status (0x%02x)\n",

commit 2230d90dd889e35da2728b6f6ebf25fb5a6499bd
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Mar 27 12:46:42 2009 +0100

    ide: sanitize ide_finish_cmd()
    
    * Move ide_end_request() call out from ide_finish_cmd() to its users.
    
    * Use ide_finish_cmd() in task_no_data_intr().
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index cba9fe585d87..820e5104ba47 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -98,7 +98,10 @@ ide_startstop_t ide_dma_intr(ide_drive_t *drive)
 		if (!dma_stat) {
 			struct ide_cmd *cmd = &hwif->cmd;
 
-			ide_finish_cmd(drive, cmd, stat);
+			if ((cmd->tf_flags & IDE_TFLAG_FS) == 0)
+				ide_finish_cmd(drive, cmd, stat);
+			else
+				ide_end_request(drive, 1, cmd->rq->nr_sectors);
 			return ide_stopped;
 		}
 		printk(KERN_ERR "%s: %s: bad DMA status (0x%02x)\n",

commit b6308ee0c55acd2e943d849773c9f0a49c516317
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Mar 27 12:46:38 2009 +0100

    ide: move command related fields from ide_hwif_t to struct ide_cmd
    
    * Move command related fields from ide_hwif_t to struct ide_cmd.
    
    * Make ide_init_sg_cmd() take command and sectors number as arguments.
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 54f17ae9225d..cba9fe585d87 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -128,21 +128,22 @@ int ide_build_sglist(ide_drive_t *drive, struct request *rq)
 {
 	ide_hwif_t *hwif = drive->hwif;
 	struct scatterlist *sg = hwif->sg_table;
+	struct ide_cmd *cmd = &hwif->cmd;
 	int i;
 
 	ide_map_sg(drive, rq);
 
 	if (rq_data_dir(rq) == READ)
-		hwif->sg_dma_direction = DMA_FROM_DEVICE;
+		cmd->sg_dma_direction = DMA_FROM_DEVICE;
 	else
-		hwif->sg_dma_direction = DMA_TO_DEVICE;
+		cmd->sg_dma_direction = DMA_TO_DEVICE;
 
-	i = dma_map_sg(hwif->dev, sg, hwif->sg_nents, hwif->sg_dma_direction);
+	i = dma_map_sg(hwif->dev, sg, cmd->sg_nents, cmd->sg_dma_direction);
 	if (i == 0)
 		ide_map_sg(drive, rq);
 	else {
-		hwif->orig_sg_nents = hwif->sg_nents;
-		hwif->sg_nents = i;
+		cmd->orig_sg_nents = cmd->sg_nents;
+		cmd->sg_nents = i;
 	}
 
 	return i;
@@ -162,9 +163,10 @@ int ide_build_sglist(ide_drive_t *drive, struct request *rq)
 void ide_destroy_dmatable(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = drive->hwif;
+	struct ide_cmd *cmd = &hwif->cmd;
 
-	dma_unmap_sg(hwif->dev, hwif->sg_table, hwif->orig_sg_nents,
-		     hwif->sg_dma_direction);
+	dma_unmap_sg(hwif->dev, hwif->sg_table, cmd->orig_sg_nents,
+		     cmd->sg_dma_direction);
 }
 EXPORT_SYMBOL_GPL(ide_destroy_dmatable);
 

commit adb1af9803d167091c2cb4de14014185054bfe2c
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Mar 27 12:46:38 2009 +0100

    ide: pass command instead of request to ide_pio_datablock()
    
    * Add IDE_TFLAG_FS taskfile flag and set it for REQ_TYPE_FS requests.
    
    * Convert ->{in,out}put_data methods to take command instead of request
      as an argument.  Then convert pre_task_out_intr(), task_end_request(),
      task_error(), task_in_unexpected(), ide_pio_sector(), ide_pio_multi()
      and ide_pio_datablock() in similar way.
    
    * Rename task_end_request() to ide_finish_cmd().
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 12c11b71402e..54f17ae9225d 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -96,9 +96,9 @@ ide_startstop_t ide_dma_intr(ide_drive_t *drive)
 
 	if (OK_STAT(stat, DRIVE_READY, drive->bad_wstat | ATA_DRQ)) {
 		if (!dma_stat) {
-			struct request *rq = hwif->rq;
+			struct ide_cmd *cmd = &hwif->cmd;
 
-			task_end_request(drive, rq, stat);
+			ide_finish_cmd(drive, cmd, stat);
 			return ide_stopped;
 		}
 		printk(KERN_ERR "%s: %s: bad DMA status (0x%02x)\n",

commit e6830a86c260d73c6f370aa7ed17ee6c71e5ee05
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Mar 27 12:46:37 2009 +0100

    ide: call ide_build_sglist() prior to ->dma_setup (v2)
    
    * Re-map sg table if needed in ide_build_sglist().
    
    * Move ide_build_sglist() call from ->dma_setup to its users.
    
    * Un-export ide_build_sglist().
    
    v2:
    * Build fix for CONFIG_BLK_DEV_IDEDMA=n (noticed by Randy Dunlap).
    
    There should be no functional changes caused by this patch.
    
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index a878f4734f81..12c11b71402e 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -138,14 +138,15 @@ int ide_build_sglist(ide_drive_t *drive, struct request *rq)
 		hwif->sg_dma_direction = DMA_TO_DEVICE;
 
 	i = dma_map_sg(hwif->dev, sg, hwif->sg_nents, hwif->sg_dma_direction);
-	if (i) {
+	if (i == 0)
+		ide_map_sg(drive, rq);
+	else {
 		hwif->orig_sg_nents = hwif->sg_nents;
 		hwif->sg_nents = i;
 	}
 
 	return i;
 }
-EXPORT_SYMBOL_GPL(ide_build_sglist);
 
 /**
  *	ide_destroy_dmatable	-	clean up DMA mapping

commit 65ca5377322c7543163066f373ae9e6b0ad8de8a
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Mar 24 23:22:43 2009 +0100

    ide: move ide_dma_timeout_retry() to ide-dma.c
    
    Move ide_dma_timeout_retry() to ide-dma.c and add static inline
    version for CONFIG_BLK_DEV_IDEDMA=n.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 059c90bb5ad2..a878f4734f81 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -470,6 +470,63 @@ void ide_dma_timeout(ide_drive_t *drive)
 }
 EXPORT_SYMBOL_GPL(ide_dma_timeout);
 
+/*
+ * un-busy the port etc, and clear any pending DMA status. we want to
+ * retry the current request in pio mode instead of risking tossing it
+ * all away
+ */
+ide_startstop_t ide_dma_timeout_retry(ide_drive_t *drive, int error)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	struct request *rq;
+	ide_startstop_t ret = ide_stopped;
+
+	/*
+	 * end current dma transaction
+	 */
+
+	if (error < 0) {
+		printk(KERN_WARNING "%s: DMA timeout error\n", drive->name);
+		(void)hwif->dma_ops->dma_end(drive);
+		ret = ide_error(drive, "dma timeout error",
+				hwif->tp_ops->read_status(hwif));
+	} else {
+		printk(KERN_WARNING "%s: DMA timeout retry\n", drive->name);
+		hwif->dma_ops->dma_timeout(drive);
+	}
+
+	/*
+	 * disable dma for now, but remember that we did so because of
+	 * a timeout -- we'll reenable after we finish this next request
+	 * (or rather the first chunk of it) in pio.
+	 */
+	drive->dev_flags |= IDE_DFLAG_DMA_PIO_RETRY;
+	drive->retry_pio++;
+	ide_dma_off_quietly(drive);
+
+	/*
+	 * un-busy drive etc and make sure request is sane
+	 */
+
+	rq = hwif->rq;
+	if (!rq)
+		goto out;
+
+	hwif->rq = NULL;
+
+	rq->errors = 0;
+
+	if (!rq->bio)
+		goto out;
+
+	rq->sector = rq->bio->bi_sector;
+	rq->current_nr_sectors = bio_iovec(rq->bio)->bv_len >> 9;
+	rq->hard_cur_sectors = rq->current_nr_sectors;
+	rq->buffer = bio_data(rq->bio);
+out:
+	return ret;
+}
+
 void ide_release_dma_engine(ide_hwif_t *hwif)
 {
 	if (hwif->dmatable_cpu) {

commit 5d82720a7f41f0c877e026c7d17e3bf20ccdbae0
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Fri Mar 13 21:16:13 2009 +0100

    ide: save the returned value of dma_map_sg
    
    dma_map_sg could return a value different to 'nents' argument of
    dma_map_sg so the ide stack needs to save it for the later usage
    (e.g. for_each_sg).
    
    The ide stack also needs to save the original sg_nents value for
    pci_unmap_sg.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    [bart: backport to Linus' tree]
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 72ebab0bc755..059c90bb5ad2 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -128,6 +128,7 @@ int ide_build_sglist(ide_drive_t *drive, struct request *rq)
 {
 	ide_hwif_t *hwif = drive->hwif;
 	struct scatterlist *sg = hwif->sg_table;
+	int i;
 
 	ide_map_sg(drive, rq);
 
@@ -136,8 +137,13 @@ int ide_build_sglist(ide_drive_t *drive, struct request *rq)
 	else
 		hwif->sg_dma_direction = DMA_TO_DEVICE;
 
-	return dma_map_sg(hwif->dev, sg, hwif->sg_nents,
-			  hwif->sg_dma_direction);
+	i = dma_map_sg(hwif->dev, sg, hwif->sg_nents, hwif->sg_dma_direction);
+	if (i) {
+		hwif->orig_sg_nents = hwif->sg_nents;
+		hwif->sg_nents = i;
+	}
+
+	return i;
 }
 EXPORT_SYMBOL_GPL(ide_build_sglist);
 
@@ -156,7 +162,7 @@ void ide_destroy_dmatable(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = drive->hwif;
 
-	dma_unmap_sg(hwif->dev, hwif->sg_table, hwif->sg_nents,
+	dma_unmap_sg(hwif->dev, hwif->sg_table, hwif->orig_sg_nents,
 		     hwif->sg_dma_direction);
 }
 EXPORT_SYMBOL_GPL(ide_destroy_dmatable);

commit b65fac32cfe3b2f98cd472fef400bd1c1340de23
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jan 6 17:20:50 2009 +0100

    ide: merge ide_hwgroup_t with ide_hwif_t (v2)
    
    * Merge ide_hwgroup_t with ide_hwif_t.
    
    * Cleanup init_irq() accordingly, then remove no longer needed
      ide_remove_port_from_hwgroup() and ide_ports[].
    
    * Remove now unused HWGROUP() macro.
    
    While at it:
    
    * ide_dump_ata_error() fixups
    
    v2:
    * Fix ->quirk_list check in do_ide_request()
      (s/hwif->cur_dev/prev_port->cur_dev).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index fffd11717b2d..72ebab0bc755 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -96,7 +96,7 @@ ide_startstop_t ide_dma_intr(ide_drive_t *drive)
 
 	if (OK_STAT(stat, DRIVE_READY, drive->bad_wstat | ATA_DRQ)) {
 		if (!dma_stat) {
-			struct request *rq = hwif->hwgroup->rq;
+			struct request *rq = hwif->rq;
 
 			task_end_request(drive, rq, stat);
 			return ide_stopped;

commit 2dbe7e919eb696c86790797f8a814bef19a0d50a
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Oct 13 21:39:47 2008 +0200

    ide: move SFF DMA code to ide-dma-sff.c
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index d935a6ec022f..fffd11717b2d 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -33,7 +33,6 @@
 #include <linux/ide.h>
 #include <linux/scatterlist.h>
 #include <linux/dma-mapping.h>
-#include <linux/io.h>
 
 static const struct drive_list_entry drive_whitelist[] = {
 	{ "Micropolis 2112A"	,       NULL		},
@@ -109,7 +108,7 @@ ide_startstop_t ide_dma_intr(ide_drive_t *drive)
 }
 EXPORT_SYMBOL_GPL(ide_dma_intr);
 
-static int ide_dma_good_drive(ide_drive_t *drive)
+int ide_dma_good_drive(ide_drive_t *drive)
 {
 	return ide_in_drive_list(drive->id, drive_whitelist);
 }
@@ -142,90 +141,6 @@ int ide_build_sglist(ide_drive_t *drive, struct request *rq)
 }
 EXPORT_SYMBOL_GPL(ide_build_sglist);
 
-#ifdef CONFIG_BLK_DEV_IDEDMA_SFF
-/**
- *	ide_build_dmatable	-	build IDE DMA table
- *
- *	ide_build_dmatable() prepares a dma request. We map the command
- *	to get the pci bus addresses of the buffers and then build up
- *	the PRD table that the IDE layer wants to be fed.
- *
- *	Most chipsets correctly interpret a length of 0x0000 as 64KB,
- *	but at least one (e.g. CS5530) misinterprets it as zero (!).
- *	So we break the 64KB entry into two 32KB entries instead.
- *
- *	Returns the number of built PRD entries if all went okay,
- *	returns 0 otherwise.
- *
- *	May also be invoked from trm290.c
- */
-
-int ide_build_dmatable(ide_drive_t *drive, struct request *rq)
-{
-	ide_hwif_t *hwif = drive->hwif;
-	__le32 *table = (__le32 *)hwif->dmatable_cpu;
-	unsigned int is_trm290	= (hwif->chipset == ide_trm290) ? 1 : 0;
-	unsigned int count = 0;
-	int i;
-	struct scatterlist *sg;
-
-	hwif->sg_nents = ide_build_sglist(drive, rq);
-	if (hwif->sg_nents == 0)
-		return 0;
-
-	for_each_sg(hwif->sg_table, sg, hwif->sg_nents, i) {
-		u32 cur_addr, cur_len, xcount, bcount;
-
-		cur_addr = sg_dma_address(sg);
-		cur_len = sg_dma_len(sg);
-
-		/*
-		 * Fill in the dma table, without crossing any 64kB boundaries.
-		 * Most hardware requires 16-bit alignment of all blocks,
-		 * but the trm290 requires 32-bit alignment.
-		 */
-
-		while (cur_len) {
-			if (count++ >= PRD_ENTRIES)
-				goto use_pio_instead;
-
-			bcount = 0x10000 - (cur_addr & 0xffff);
-			if (bcount > cur_len)
-				bcount = cur_len;
-			*table++ = cpu_to_le32(cur_addr);
-			xcount = bcount & 0xffff;
-			if (is_trm290)
-				xcount = ((xcount >> 2) - 1) << 16;
-			if (xcount == 0x0000) {
-				if (count++ >= PRD_ENTRIES)
-					goto use_pio_instead;
-				*table++ = cpu_to_le32(0x8000);
-				*table++ = cpu_to_le32(cur_addr + 0x8000);
-				xcount = 0x8000;
-			}
-			*table++ = cpu_to_le32(xcount);
-			cur_addr += bcount;
-			cur_len -= bcount;
-		}
-	}
-
-	if (count) {
-		if (!is_trm290)
-			*--table |= cpu_to_le32(0x80000000);
-		return count;
-	}
-
-use_pio_instead:
-	printk(KERN_ERR "%s: %s\n", drive->name,
-		count ? "DMA table too small" : "empty DMA table?");
-
-	ide_destroy_dmatable(drive);
-
-	return 0; /* revert to PIO for this request */
-}
-EXPORT_SYMBOL_GPL(ide_build_dmatable);
-#endif
-
 /**
  *	ide_destroy_dmatable	-	clean up DMA mapping
  *	@drive: The drive to unmap
@@ -246,120 +161,6 @@ void ide_destroy_dmatable(ide_drive_t *drive)
 }
 EXPORT_SYMBOL_GPL(ide_destroy_dmatable);
 
-#ifdef CONFIG_BLK_DEV_IDEDMA_SFF
-/**
- *	config_drive_for_dma	-	attempt to activate IDE DMA
- *	@drive: the drive to place in DMA mode
- *
- *	If the drive supports at least mode 2 DMA or UDMA of any kind
- *	then attempt to place it into DMA mode. Drives that are known to
- *	support DMA but predate the DMA properties or that are known
- *	to have DMA handling bugs are also set up appropriately based
- *	on the good/bad drive lists.
- */
-
-static int config_drive_for_dma(ide_drive_t *drive)
-{
-	ide_hwif_t *hwif = drive->hwif;
-	u16 *id = drive->id;
-
-	if (drive->media != ide_disk) {
-		if (hwif->host_flags & IDE_HFLAG_NO_ATAPI_DMA)
-			return 0;
-	}
-
-	/*
-	 * Enable DMA on any drive that has
-	 * UltraDMA (mode 0/1/2/3/4/5/6) enabled
-	 */
-	if ((id[ATA_ID_FIELD_VALID] & 4) &&
-	    ((id[ATA_ID_UDMA_MODES] >> 8) & 0x7f))
-		return 1;
-
-	/*
-	 * Enable DMA on any drive that has mode2 DMA
-	 * (multi or single) enabled
-	 */
-	if (id[ATA_ID_FIELD_VALID] & 2)	/* regular DMA */
-		if ((id[ATA_ID_MWDMA_MODES] & 0x404) == 0x404 ||
-		    (id[ATA_ID_SWDMA_MODES] & 0x404) == 0x404)
-			return 1;
-
-	/* Consult the list of known "good" drives */
-	if (ide_dma_good_drive(drive))
-		return 1;
-
-	return 0;
-}
-
-/**
- *	dma_timer_expiry	-	handle a DMA timeout
- *	@drive: Drive that timed out
- *
- *	An IDE DMA transfer timed out. In the event of an error we ask
- *	the driver to resolve the problem, if a DMA transfer is still
- *	in progress we continue to wait (arguably we need to add a
- *	secondary 'I don't care what the drive thinks' timeout here)
- *	Finally if we have an interrupt we let it complete the I/O.
- *	But only one time - we clear expiry and if it's still not
- *	completed after WAIT_CMD, we error and retry in PIO.
- *	This can occur if an interrupt is lost or due to hang or bugs.
- */
-
-static int dma_timer_expiry(ide_drive_t *drive)
-{
-	ide_hwif_t *hwif = drive->hwif;
-	u8 dma_stat = hwif->tp_ops->read_sff_dma_status(hwif);
-
-	printk(KERN_WARNING "%s: %s: DMA status (0x%02x)\n",
-		drive->name, __func__, dma_stat);
-
-	if ((dma_stat & 0x18) == 0x18)	/* BUSY Stupid Early Timer !! */
-		return WAIT_CMD;
-
-	hwif->hwgroup->expiry = NULL;	/* one free ride for now */
-
-	/* 1 dmaing, 2 error, 4 intr */
-	if (dma_stat & 2)	/* ERROR */
-		return -1;
-
-	if (dma_stat & 1)	/* DMAing */
-		return WAIT_CMD;
-
-	if (dma_stat & 4)	/* Got an Interrupt */
-		return WAIT_CMD;
-
-	return 0;	/* Status is unknown -- reset the bus */
-}
-
-/**
- *	ide_dma_host_set	-	Enable/disable DMA on a host
- *	@drive: drive to control
- *
- *	Enable/disable DMA on an IDE controller following generic
- *	bus-mastering IDE controller behaviour.
- */
-
-void ide_dma_host_set(ide_drive_t *drive, int on)
-{
-	ide_hwif_t *hwif = drive->hwif;
-	u8 unit = drive->dn & 1;
-	u8 dma_stat = hwif->tp_ops->read_sff_dma_status(hwif);
-
-	if (on)
-		dma_stat |= (1 << (5 + unit));
-	else
-		dma_stat &= ~(1 << (5 + unit));
-
-	if (hwif->host_flags & IDE_HFLAG_MMIO)
-		writeb(dma_stat,
-		       (void __iomem *)(hwif->dma_base + ATA_DMA_STATUS));
-	else
-		outb(dma_stat, hwif->dma_base + ATA_DMA_STATUS);
-}
-EXPORT_SYMBOL_GPL(ide_dma_host_set);
-#endif /* CONFIG_BLK_DEV_IDEDMA_SFF  */
-
 /**
  *	ide_dma_off_quietly	-	Generic DMA kill
  *	@drive: drive to control
@@ -406,154 +207,6 @@ void ide_dma_on(ide_drive_t *drive)
 	drive->hwif->dma_ops->dma_host_set(drive, 1);
 }
 
-#ifdef CONFIG_BLK_DEV_IDEDMA_SFF
-/**
- *	ide_dma_setup	-	begin a DMA phase
- *	@drive: target device
- *
- *	Build an IDE DMA PRD (IDE speak for scatter gather table)
- *	and then set up the DMA transfer registers for a device
- *	that follows generic IDE PCI DMA behaviour. Controllers can
- *	override this function if they need to
- *
- *	Returns 0 on success. If a PIO fallback is required then 1
- *	is returned.
- */
-
-int ide_dma_setup(ide_drive_t *drive)
-{
-	ide_hwif_t *hwif = drive->hwif;
-	struct request *rq = hwif->hwgroup->rq;
-	unsigned int reading;
-	u8 mmio = (hwif->host_flags & IDE_HFLAG_MMIO) ? 1 : 0;
-	u8 dma_stat;
-
-	if (rq_data_dir(rq))
-		reading = 0;
-	else
-		reading = 1 << 3;
-
-	/* fall back to pio! */
-	if (!ide_build_dmatable(drive, rq)) {
-		ide_map_sg(drive, rq);
-		return 1;
-	}
-
-	/* PRD table */
-	if (hwif->host_flags & IDE_HFLAG_MMIO)
-		writel(hwif->dmatable_dma,
-		       (void __iomem *)(hwif->dma_base + ATA_DMA_TABLE_OFS));
-	else
-		outl(hwif->dmatable_dma, hwif->dma_base + ATA_DMA_TABLE_OFS);
-
-	/* specify r/w */
-	if (mmio)
-		writeb(reading, (void __iomem *)(hwif->dma_base + ATA_DMA_CMD));
-	else
-		outb(reading, hwif->dma_base + ATA_DMA_CMD);
-
-	/* read DMA status for INTR & ERROR flags */
-	dma_stat = hwif->tp_ops->read_sff_dma_status(hwif);
-
-	/* clear INTR & ERROR flags */
-	if (mmio)
-		writeb(dma_stat | 6,
-		       (void __iomem *)(hwif->dma_base + ATA_DMA_STATUS));
-	else
-		outb(dma_stat | 6, hwif->dma_base + ATA_DMA_STATUS);
-
-	drive->waiting_for_dma = 1;
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ide_dma_setup);
-
-void ide_dma_exec_cmd(ide_drive_t *drive, u8 command)
-{
-	/* issue cmd to drive */
-	ide_execute_command(drive, command, &ide_dma_intr, 2 * WAIT_CMD,
-			    dma_timer_expiry);
-}
-EXPORT_SYMBOL_GPL(ide_dma_exec_cmd);
-
-void ide_dma_start(ide_drive_t *drive)
-{
-	ide_hwif_t *hwif = drive->hwif;
-	u8 dma_cmd;
-
-	/* Note that this is done *after* the cmd has
-	 * been issued to the drive, as per the BM-IDE spec.
-	 * The Promise Ultra33 doesn't work correctly when
-	 * we do this part before issuing the drive cmd.
-	 */
-	if (hwif->host_flags & IDE_HFLAG_MMIO) {
-		dma_cmd = readb((void __iomem *)(hwif->dma_base + ATA_DMA_CMD));
-		/* start DMA */
-		writeb(dma_cmd | 1,
-		       (void __iomem *)(hwif->dma_base + ATA_DMA_CMD));
-	} else {
-		dma_cmd = inb(hwif->dma_base + ATA_DMA_CMD);
-		outb(dma_cmd | 1, hwif->dma_base + ATA_DMA_CMD);
-	}
-
-	wmb();
-}
-EXPORT_SYMBOL_GPL(ide_dma_start);
-
-/* returns 1 on error, 0 otherwise */
-int ide_dma_end(ide_drive_t *drive)
-{
-	ide_hwif_t *hwif = drive->hwif;
-	u8 mmio = (hwif->host_flags & IDE_HFLAG_MMIO) ? 1 : 0;
-	u8 dma_stat = 0, dma_cmd = 0;
-
-	drive->waiting_for_dma = 0;
-
-	if (mmio) {
-		/* get DMA command mode */
-		dma_cmd = readb((void __iomem *)(hwif->dma_base + ATA_DMA_CMD));
-		/* stop DMA */
-		writeb(dma_cmd & ~1,
-		       (void __iomem *)(hwif->dma_base + ATA_DMA_CMD));
-	} else {
-		dma_cmd = inb(hwif->dma_base + ATA_DMA_CMD);
-		outb(dma_cmd & ~1, hwif->dma_base + ATA_DMA_CMD);
-	}
-
-	/* get DMA status */
-	dma_stat = hwif->tp_ops->read_sff_dma_status(hwif);
-
-	if (mmio)
-		/* clear the INTR & ERROR bits */
-		writeb(dma_stat | 6,
-		       (void __iomem *)(hwif->dma_base + ATA_DMA_STATUS));
-	else
-		outb(dma_stat | 6, hwif->dma_base + ATA_DMA_STATUS);
-
-	/* purge DMA mappings */
-	ide_destroy_dmatable(drive);
-	/* verify good DMA status */
-	wmb();
-	return (dma_stat & 7) != 4 ? (0x10 | dma_stat) : 0;
-}
-EXPORT_SYMBOL_GPL(ide_dma_end);
-
-/* returns 1 if dma irq issued, 0 otherwise */
-int ide_dma_test_irq(ide_drive_t *drive)
-{
-	ide_hwif_t *hwif = drive->hwif;
-	u8 dma_stat = hwif->tp_ops->read_sff_dma_status(hwif);
-
-	/* return 1 if INTR asserted */
-	if ((dma_stat & 4) == 4)
-		return 1;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ide_dma_test_irq);
-#else
-static inline int config_drive_for_dma(ide_drive_t *drive) { return 0; }
-#endif /* CONFIG_BLK_DEV_IDEDMA_SFF */
-
 int __ide_dma_bad_drive(ide_drive_t *drive)
 {
 	u16 *id = drive->id;
@@ -846,17 +499,3 @@ int ide_allocate_dma_engine(ide_hwif_t *hwif)
 	return 0;
 }
 EXPORT_SYMBOL_GPL(ide_allocate_dma_engine);
-
-#ifdef CONFIG_BLK_DEV_IDEDMA_SFF
-const struct ide_dma_ops sff_dma_ops = {
-	.dma_host_set		= ide_dma_host_set,
-	.dma_setup		= ide_dma_setup,
-	.dma_exec_cmd		= ide_dma_exec_cmd,
-	.dma_start		= ide_dma_start,
-	.dma_end		= ide_dma_end,
-	.dma_test_irq		= ide_dma_test_irq,
-	.dma_timeout		= ide_dma_timeout,
-	.dma_lost_irq		= ide_dma_lost_irq,
-};
-EXPORT_SYMBOL_GPL(sff_dma_ops);
-#endif /* CONFIG_BLK_DEV_IDEDMA_SFF */

commit db3f99ef7c30d541e4a78931acf2c64abe3e26d1
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Oct 13 21:39:47 2008 +0200

    ide: cleanup ide-dma.c
    
    - s/HWIF(drive)/drive->hwif/
    - s/HWGROUP(drive)/[drive->]hwif->hwgroup/
    - fixup error messages in ide_dma_intr() & dma_timer_expiry()
    - fix checkpatch.pl errors/warnings
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 4d212b867c35..d935a6ec022f 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -33,11 +33,9 @@
 #include <linux/ide.h>
 #include <linux/scatterlist.h>
 #include <linux/dma-mapping.h>
+#include <linux/io.h>
 
-#include <asm/io.h>
-
-static const struct drive_list_entry drive_whitelist [] = {
-
+static const struct drive_list_entry drive_whitelist[] = {
 	{ "Micropolis 2112A"	,       NULL		},
 	{ "CONNER CTMA 4000"	,       NULL		},
 	{ "CONNER CTT8000-A"	,       NULL		},
@@ -45,8 +43,7 @@ static const struct drive_list_entry drive_whitelist [] = {
 	{ NULL			,	NULL		}
 };
 
-static const struct drive_list_entry drive_blacklist [] = {
-
+static const struct drive_list_entry drive_blacklist[] = {
 	{ "WDC AC11000H"	,	NULL 		},
 	{ "WDC AC22100H"	,	NULL 		},
 	{ "WDC AC32500H"	,	NULL 		},
@@ -86,11 +83,11 @@ static const struct drive_list_entry drive_blacklist [] = {
  *	ide_dma_intr	-	IDE DMA interrupt handler
  *	@drive: the drive the interrupt is for
  *
- *	Handle an interrupt completing a read/write DMA transfer on an 
+ *	Handle an interrupt completing a read/write DMA transfer on an
  *	IDE device
  */
- 
-ide_startstop_t ide_dma_intr (ide_drive_t *drive)
+
+ide_startstop_t ide_dma_intr(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = drive->hwif;
 	u8 stat = 0, dma_stat = 0;
@@ -100,17 +97,16 @@ ide_startstop_t ide_dma_intr (ide_drive_t *drive)
 
 	if (OK_STAT(stat, DRIVE_READY, drive->bad_wstat | ATA_DRQ)) {
 		if (!dma_stat) {
-			struct request *rq = HWGROUP(drive)->rq;
+			struct request *rq = hwif->hwgroup->rq;
 
 			task_end_request(drive, rq, stat);
 			return ide_stopped;
 		}
-		printk(KERN_ERR "%s: dma_intr: bad DMA status (dma_stat=%x)\n", 
-		       drive->name, dma_stat);
+		printk(KERN_ERR "%s: %s: bad DMA status (0x%02x)\n",
+			drive->name, __func__, dma_stat);
 	}
 	return ide_error(drive, "dma_intr", stat);
 }
-
 EXPORT_SYMBOL_GPL(ide_dma_intr);
 
 static int ide_dma_good_drive(ide_drive_t *drive)
@@ -131,7 +127,7 @@ static int ide_dma_good_drive(ide_drive_t *drive)
 
 int ide_build_sglist(ide_drive_t *drive, struct request *rq)
 {
-	ide_hwif_t *hwif = HWIF(drive);
+	ide_hwif_t *hwif = drive->hwif;
 	struct scatterlist *sg = hwif->sg_table;
 
 	ide_map_sg(drive, rq);
@@ -144,7 +140,6 @@ int ide_build_sglist(ide_drive_t *drive, struct request *rq)
 	return dma_map_sg(hwif->dev, sg, hwif->sg_nents,
 			  hwif->sg_dma_direction);
 }
-
 EXPORT_SYMBOL_GPL(ide_build_sglist);
 
 #ifdef CONFIG_BLK_DEV_IDEDMA_SFF
@@ -164,10 +159,10 @@ EXPORT_SYMBOL_GPL(ide_build_sglist);
  *
  *	May also be invoked from trm290.c
  */
- 
-int ide_build_dmatable (ide_drive_t *drive, struct request *rq)
+
+int ide_build_dmatable(ide_drive_t *drive, struct request *rq)
 {
-	ide_hwif_t *hwif	= HWIF(drive);
+	ide_hwif_t *hwif = drive->hwif;
 	__le32 *table = (__le32 *)hwif->dmatable_cpu;
 	unsigned int is_trm290	= (hwif->chipset == ide_trm290) ? 1 : 0;
 	unsigned int count = 0;
@@ -241,15 +236,14 @@ EXPORT_SYMBOL_GPL(ide_build_dmatable);
  *	an oops as only one mapping can be live for each target at a given
  *	time.
  */
- 
-void ide_destroy_dmatable (ide_drive_t *drive)
+
+void ide_destroy_dmatable(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = drive->hwif;
 
 	dma_unmap_sg(hwif->dev, hwif->sg_table, hwif->sg_nents,
 		     hwif->sg_dma_direction);
 }
-
 EXPORT_SYMBOL_GPL(ide_destroy_dmatable);
 
 #ifdef CONFIG_BLK_DEV_IDEDMA_SFF
@@ -263,8 +257,8 @@ EXPORT_SYMBOL_GPL(ide_destroy_dmatable);
  *	to have DMA handling bugs are also set up appropriately based
  *	on the good/bad drive lists.
  */
- 
-static int config_drive_for_dma (ide_drive_t *drive)
+
+static int config_drive_for_dma(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = drive->hwif;
 	u16 *id = drive->id;
@@ -304,26 +298,26 @@ static int config_drive_for_dma (ide_drive_t *drive)
  *
  *	An IDE DMA transfer timed out. In the event of an error we ask
  *	the driver to resolve the problem, if a DMA transfer is still
- *	in progress we continue to wait (arguably we need to add a 
+ *	in progress we continue to wait (arguably we need to add a
  *	secondary 'I don't care what the drive thinks' timeout here)
  *	Finally if we have an interrupt we let it complete the I/O.
  *	But only one time - we clear expiry and if it's still not
  *	completed after WAIT_CMD, we error and retry in PIO.
  *	This can occur if an interrupt is lost or due to hang or bugs.
  */
- 
-static int dma_timer_expiry (ide_drive_t *drive)
+
+static int dma_timer_expiry(ide_drive_t *drive)
 {
-	ide_hwif_t *hwif	= HWIF(drive);
-	u8 dma_stat		= hwif->tp_ops->read_sff_dma_status(hwif);
+	ide_hwif_t *hwif = drive->hwif;
+	u8 dma_stat = hwif->tp_ops->read_sff_dma_status(hwif);
 
-	printk(KERN_WARNING "%s: dma_timer_expiry: dma status == 0x%02x\n",
-		drive->name, dma_stat);
+	printk(KERN_WARNING "%s: %s: DMA status (0x%02x)\n",
+		drive->name, __func__, dma_stat);
 
 	if ((dma_stat & 0x18) == 0x18)	/* BUSY Stupid Early Timer !! */
 		return WAIT_CMD;
 
-	HWGROUP(drive)->expiry = NULL;	/* one free ride for now */
+	hwif->hwgroup->expiry = NULL;	/* one free ride for now */
 
 	/* 1 dmaing, 2 error, 4 intr */
 	if (dma_stat & 2)	/* ERROR */
@@ -348,9 +342,9 @@ static int dma_timer_expiry (ide_drive_t *drive)
 
 void ide_dma_host_set(ide_drive_t *drive, int on)
 {
-	ide_hwif_t *hwif	= HWIF(drive);
-	u8 unit			= drive->dn & 1;
-	u8 dma_stat		= hwif->tp_ops->read_sff_dma_status(hwif);
+	ide_hwif_t *hwif = drive->hwif;
+	u8 unit = drive->dn & 1;
+	u8 dma_stat = hwif->tp_ops->read_sff_dma_status(hwif);
 
 	if (on)
 		dma_stat |= (1 << (5 + unit));
@@ -363,7 +357,6 @@ void ide_dma_host_set(ide_drive_t *drive, int on)
 	else
 		outb(dma_stat, hwif->dma_base + ATA_DMA_STATUS);
 }
-
 EXPORT_SYMBOL_GPL(ide_dma_host_set);
 #endif /* CONFIG_BLK_DEV_IDEDMA_SFF  */
 
@@ -371,7 +364,7 @@ EXPORT_SYMBOL_GPL(ide_dma_host_set);
  *	ide_dma_off_quietly	-	Generic DMA kill
  *	@drive: drive to control
  *
- *	Turn off the current DMA on this IDE controller. 
+ *	Turn off the current DMA on this IDE controller.
  */
 
 void ide_dma_off_quietly(ide_drive_t *drive)
@@ -381,7 +374,6 @@ void ide_dma_off_quietly(ide_drive_t *drive)
 
 	drive->hwif->dma_ops->dma_host_set(drive, 0);
 }
-
 EXPORT_SYMBOL(ide_dma_off_quietly);
 
 /**
@@ -397,7 +389,6 @@ void ide_dma_off(ide_drive_t *drive)
 	printk(KERN_INFO "%s: DMA disabled\n", drive->name);
 	ide_dma_off_quietly(drive);
 }
-
 EXPORT_SYMBOL(ide_dma_off);
 
 /**
@@ -426,13 +417,13 @@ void ide_dma_on(ide_drive_t *drive)
  *	override this function if they need to
  *
  *	Returns 0 on success. If a PIO fallback is required then 1
- *	is returned. 
+ *	is returned.
  */
 
 int ide_dma_setup(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = drive->hwif;
-	struct request *rq = HWGROUP(drive)->rq;
+	struct request *rq = hwif->hwgroup->rq;
 	unsigned int reading;
 	u8 mmio = (hwif->host_flags & IDE_HFLAG_MMIO) ? 1 : 0;
 	u8 dma_stat;
@@ -474,13 +465,13 @@ int ide_dma_setup(ide_drive_t *drive)
 	drive->waiting_for_dma = 1;
 	return 0;
 }
-
 EXPORT_SYMBOL_GPL(ide_dma_setup);
 
 void ide_dma_exec_cmd(ide_drive_t *drive, u8 command)
 {
 	/* issue cmd to drive */
-	ide_execute_command(drive, command, &ide_dma_intr, 2*WAIT_CMD, dma_timer_expiry);
+	ide_execute_command(drive, command, &ide_dma_intr, 2 * WAIT_CMD,
+			    dma_timer_expiry);
 }
 EXPORT_SYMBOL_GPL(ide_dma_exec_cmd);
 
@@ -506,7 +497,6 @@ void ide_dma_start(ide_drive_t *drive)
 
 	wmb();
 }
-
 EXPORT_SYMBOL_GPL(ide_dma_start);
 
 /* returns 1 on error, 0 otherwise */
@@ -550,8 +540,8 @@ EXPORT_SYMBOL_GPL(ide_dma_end);
 /* returns 1 if dma irq issued, 0 otherwise */
 int ide_dma_test_irq(ide_drive_t *drive)
 {
-	ide_hwif_t *hwif	= HWIF(drive);
-	u8 dma_stat		= hwif->tp_ops->read_sff_dma_status(hwif);
+	ide_hwif_t *hwif = drive->hwif;
+	u8 dma_stat = hwif->tp_ops->read_sff_dma_status(hwif);
 
 	/* return 1 if INTR asserted */
 	if ((dma_stat & 4) == 4)
@@ -564,7 +554,7 @@ EXPORT_SYMBOL_GPL(ide_dma_test_irq);
 static inline int config_drive_for_dma(ide_drive_t *drive) { return 0; }
 #endif /* CONFIG_BLK_DEV_IDEDMA_SFF */
 
-int __ide_dma_bad_drive (ide_drive_t *drive)
+int __ide_dma_bad_drive(ide_drive_t *drive)
 {
 	u16 *id = drive->id;
 
@@ -576,7 +566,6 @@ int __ide_dma_bad_drive (ide_drive_t *drive)
 	}
 	return 0;
 }
-
 EXPORT_SYMBOL(__ide_dma_bad_drive);
 
 static const u8 xfer_mode_bases[] = {
@@ -592,7 +581,7 @@ static unsigned int ide_get_mode_mask(ide_drive_t *drive, u8 base, u8 req_mode)
 	const struct ide_port_ops *port_ops = hwif->port_ops;
 	unsigned int mask = 0;
 
-	switch(base) {
+	switch (base) {
 	case XFER_UDMA_0:
 		if ((id[ATA_ID_FIELD_VALID] & 4) == 0)
 			break;
@@ -693,7 +682,6 @@ u8 ide_find_dma_mode(ide_drive_t *drive, u8 req_mode)
 
 	return mode;
 }
-
 EXPORT_SYMBOL_GPL(ide_find_dma_mode);
 
 static int ide_tune_dma(ide_drive_t *drive)
@@ -810,7 +798,7 @@ EXPORT_SYMBOL_GPL(ide_dma_lost_irq);
 
 void ide_dma_timeout(ide_drive_t *drive)
 {
-	ide_hwif_t *hwif = HWIF(drive);
+	ide_hwif_t *hwif = drive->hwif;
 
 	printk(KERN_ERR "%s: timeout waiting for DMA\n", drive->name);
 

commit 14c123f37187aba0b4e0e893a969efc6820c4170
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Oct 13 21:39:47 2008 +0200

    ide: cleanup ide_build_dmatable()
    
    - use for_each_sg()
    - move printing 'DMA table too small' message below use_pio_instead label
    - merge '64KB bug' comment with function documentation
    - fix intendation
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 83885ba0496c..4d212b867c35 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -153,8 +153,11 @@ EXPORT_SYMBOL_GPL(ide_build_sglist);
  *
  *	ide_build_dmatable() prepares a dma request. We map the command
  *	to get the pci bus addresses of the buffers and then build up
- *	the PRD table that the IDE layer wants to be fed. The code
- *	knows about the 64K wrap bug in the CS5530.
+ *	the PRD table that the IDE layer wants to be fed.
+ *
+ *	Most chipsets correctly interpret a length of 0x0000 as 64KB,
+ *	but at least one (e.g. CS5530) misinterprets it as zero (!).
+ *	So we break the 64KB entry into two 32KB entries instead.
  *
  *	Returns the number of built PRD entries if all went okay,
  *	returns 0 otherwise.
@@ -171,15 +174,12 @@ int ide_build_dmatable (ide_drive_t *drive, struct request *rq)
 	int i;
 	struct scatterlist *sg;
 
-	hwif->sg_nents = i = ide_build_sglist(drive, rq);
-
-	if (!i)
+	hwif->sg_nents = ide_build_sglist(drive, rq);
+	if (hwif->sg_nents == 0)
 		return 0;
 
-	sg = hwif->sg_table;
-	while (i) {
-		u32 cur_addr;
-		u32 cur_len;
+	for_each_sg(hwif->sg_table, sg, hwif->sg_nents, i) {
+		u32 cur_addr, cur_len, xcount, bcount;
 
 		cur_addr = sg_dma_address(sg);
 		cur_len = sg_dma_len(sg);
@@ -191,40 +191,27 @@ int ide_build_dmatable (ide_drive_t *drive, struct request *rq)
 		 */
 
 		while (cur_len) {
-			if (count++ >= PRD_ENTRIES) {
-				printk(KERN_ERR "%s: DMA table too small\n", drive->name);
+			if (count++ >= PRD_ENTRIES)
 				goto use_pio_instead;
-			} else {
-				u32 xcount, bcount = 0x10000 - (cur_addr & 0xffff);
-
-				if (bcount > cur_len)
-					bcount = cur_len;
-				*table++ = cpu_to_le32(cur_addr);
-				xcount = bcount & 0xffff;
-				if (is_trm290)
-					xcount = ((xcount >> 2) - 1) << 16;
-				else if (xcount == 0x0000) {
-	/* 
-	 * Most chipsets correctly interpret a length of 0x0000 as 64KB,
-	 * but at least one (e.g. CS5530) misinterprets it as zero (!).
-	 * So here we break the 64KB entry into two 32KB entries instead.
-	 */
-					if (count++ >= PRD_ENTRIES) {
-						printk(KERN_ERR "%s: DMA table too small\n", drive->name);
-						goto use_pio_instead;
-					}
-					*table++ = cpu_to_le32(0x8000);
-					*table++ = cpu_to_le32(cur_addr + 0x8000);
-					xcount = 0x8000;
-				}
-				*table++ = cpu_to_le32(xcount);
-				cur_addr += bcount;
-				cur_len -= bcount;
+
+			bcount = 0x10000 - (cur_addr & 0xffff);
+			if (bcount > cur_len)
+				bcount = cur_len;
+			*table++ = cpu_to_le32(cur_addr);
+			xcount = bcount & 0xffff;
+			if (is_trm290)
+				xcount = ((xcount >> 2) - 1) << 16;
+			if (xcount == 0x0000) {
+				if (count++ >= PRD_ENTRIES)
+					goto use_pio_instead;
+				*table++ = cpu_to_le32(0x8000);
+				*table++ = cpu_to_le32(cur_addr + 0x8000);
+				xcount = 0x8000;
 			}
+			*table++ = cpu_to_le32(xcount);
+			cur_addr += bcount;
+			cur_len -= bcount;
 		}
-
-		sg = sg_next(sg);
-		i--;
 	}
 
 	if (count) {
@@ -233,14 +220,14 @@ int ide_build_dmatable (ide_drive_t *drive, struct request *rq)
 		return count;
 	}
 
-	printk(KERN_ERR "%s: empty DMA table?\n", drive->name);
-
 use_pio_instead:
+	printk(KERN_ERR "%s: %s\n", drive->name,
+		count ? "DMA table too small" : "empty DMA table?");
+
 	ide_destroy_dmatable(drive);
 
 	return 0; /* revert to PIO for this request */
 }
-
 EXPORT_SYMBOL_GPL(ide_build_dmatable);
 #endif
 

commit c19f7f226ba011843a31ee4f21a19c36fa5a3ead
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Oct 13 21:39:47 2008 +0200

    ide: remove needless includes from ide-dma.c
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 3f949b5db353..83885ba0496c 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -28,21 +28,13 @@
  * for supplying a Promise UDMA board & WD UDMA drive for this work!
  */
 
-#include <linux/module.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
-#include <linux/timer.h>
-#include <linux/mm.h>
-#include <linux/interrupt.h>
-#include <linux/pci.h>
-#include <linux/init.h>
 #include <linux/ide.h>
-#include <linux/delay.h>
 #include <linux/scatterlist.h>
 #include <linux/dma-mapping.h>
 
 #include <asm/io.h>
-#include <asm/irq.h>
 
 static const struct drive_list_entry drive_whitelist [] = {
 

commit 2bbd57cad3d72334c9fcc4e229a5a5b04dc6aebc
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Oct 13 21:39:47 2008 +0200

    ide: switch to DMA-mapping API part #2
    
    Follow-up to commit 5c05ff68b9a9b40a9be949497e0aa980185565cf
    ("ide: switch to DMA-mapping API"):
    
    * pci_{alloc,free}_consistent() -> dma_{alloc,free}_coherent()
      in ide_{allocate,release}_dma_engine().
    
    * Add ->prd_max_nents and ->prd_ent_size fields to ide_hwif_t
      (+ set default values in ide_allocate_dma_engine()).
    
    * Make ide_{allocate,release}_dma_engine() available also
      for CONFIG_BLK_DEV_IDEDMA_SFF=n.  Then convert au1xxx-ide.c,
      scc_pata.c and sgiioc4.c to use them.
    
    * Add missing ->init_dma method to scc_pata.
    
    This patch also fixes:
    - ->dmatable_cpu leak for au1xxx-ide
    - too early realease of ->dmatable_cpu for scc_pata
    - wrong amount of ->dmatable_cpu memory being freed for sgiioc4
    
    While at it:
    - remove superfluous ->dma_base check from ide_unregister()
    - return -ENOMEM on error in ide_release_dma_engine()
    - beautify error message in ide_release_dma_engine()
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 244b61b573ce..3f949b5db353 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -844,36 +844,43 @@ void ide_dma_timeout(ide_drive_t *drive)
 }
 EXPORT_SYMBOL_GPL(ide_dma_timeout);
 
-#ifdef CONFIG_BLK_DEV_IDEDMA_SFF
 void ide_release_dma_engine(ide_hwif_t *hwif)
 {
 	if (hwif->dmatable_cpu) {
-		struct pci_dev *pdev = to_pci_dev(hwif->dev);
+		int prd_size = hwif->prd_max_nents * hwif->prd_ent_size;
 
-		pci_free_consistent(pdev, PRD_ENTRIES * PRD_BYTES,
-				    hwif->dmatable_cpu, hwif->dmatable_dma);
+		dma_free_coherent(hwif->dev, prd_size,
+				  hwif->dmatable_cpu, hwif->dmatable_dma);
 		hwif->dmatable_cpu = NULL;
 	}
 }
+EXPORT_SYMBOL_GPL(ide_release_dma_engine);
 
 int ide_allocate_dma_engine(ide_hwif_t *hwif)
 {
-	struct pci_dev *pdev = to_pci_dev(hwif->dev);
+	int prd_size;
 
-	hwif->dmatable_cpu = pci_alloc_consistent(pdev,
-						  PRD_ENTRIES * PRD_BYTES,
-						  &hwif->dmatable_dma);
+	if (hwif->prd_max_nents == 0)
+		hwif->prd_max_nents = PRD_ENTRIES;
+	if (hwif->prd_ent_size == 0)
+		hwif->prd_ent_size = PRD_BYTES;
 
-	if (hwif->dmatable_cpu)
-		return 0;
+	prd_size = hwif->prd_max_nents * hwif->prd_ent_size;
 
-	printk(KERN_ERR "%s: -- Error, unable to allocate DMA table.\n",
+	hwif->dmatable_cpu = dma_alloc_coherent(hwif->dev, prd_size,
+						&hwif->dmatable_dma,
+						GFP_ATOMIC);
+	if (hwif->dmatable_cpu == NULL) {
+		printk(KERN_ERR "%s: unable to allocate PRD table\n",
 			hwif->name);
+		return -ENOMEM;
+	}
 
-	return 1;
+	return 0;
 }
 EXPORT_SYMBOL_GPL(ide_allocate_dma_engine);
 
+#ifdef CONFIG_BLK_DEV_IDEDMA_SFF
 const struct ide_dma_ops sff_dma_ops = {
 	.dma_host_set		= ide_dma_host_set,
 	.dma_setup		= ide_dma_setup,

commit ffa15a6915b7f6f6f69b4a66e1100a9c68d11250
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Oct 13 21:39:46 2008 +0200

    ide: make ide_dma_timeout() available also for CONFIG_BLK_DEV_IDEDMA_SFF=n
    
    Make ide_dma_timeout() available also for CONFIG_BLK_DEV_IDEDMA_SFF=n
    and convert {ics,au1xxx-}ide.c to use it.
    
    While at it:
    - dump ATA Status register content on error
    - use EXPORT_SYMBOL_GPL() to match the rest of SFF DMA functions
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 08cd878de50b..244b61b573ce 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -829,8 +829,7 @@ void ide_dma_lost_irq(ide_drive_t *drive)
 }
 EXPORT_SYMBOL_GPL(ide_dma_lost_irq);
 
-#ifdef CONFIG_BLK_DEV_IDEDMA_SFF
-void ide_dma_timeout (ide_drive_t *drive)
+void ide_dma_timeout(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = HWIF(drive);
 
@@ -839,11 +838,13 @@ void ide_dma_timeout (ide_drive_t *drive)
 	if (hwif->dma_ops->dma_test_irq(drive))
 		return;
 
+	ide_dump_status(drive, "DMA timeout", hwif->tp_ops->read_status(hwif));
+
 	hwif->dma_ops->dma_end(drive);
 }
+EXPORT_SYMBOL_GPL(ide_dma_timeout);
 
-EXPORT_SYMBOL(ide_dma_timeout);
-
+#ifdef CONFIG_BLK_DEV_IDEDMA_SFF
 void ide_release_dma_engine(ide_hwif_t *hwif)
 {
 	if (hwif->dmatable_cpu) {

commit de23ec9ca82357e6d337a2263befb1a65cf19c83
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Oct 13 21:39:46 2008 +0200

    ide: make ide_dma_lost_irq() available also for CONFIG_BLK_DEV_IDEDMA_SFF=n
    
    Make ide_dma_lost_irq() available also for CONFIG_BLK_DEV_IDEDMA_SFF=n
    and convert {ics,au1xxx-}ide.c to use it.
    
    While at it:
    - use EXPORT_SYMBOL_GPL() to match the rest of SFF DMA functions
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index f142d8f1349e..08cd878de50b 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -823,14 +823,13 @@ void ide_check_dma_crc(ide_drive_t *drive)
 		ide_dma_on(drive);
 }
 
-#ifdef CONFIG_BLK_DEV_IDEDMA_SFF
-void ide_dma_lost_irq (ide_drive_t *drive)
+void ide_dma_lost_irq(ide_drive_t *drive)
 {
-	printk("%s: DMA interrupt recovery\n", drive->name);
+	printk(KERN_ERR "%s: DMA interrupt recovery\n", drive->name);
 }
+EXPORT_SYMBOL_GPL(ide_dma_lost_irq);
 
-EXPORT_SYMBOL(ide_dma_lost_irq);
-
+#ifdef CONFIG_BLK_DEV_IDEDMA_SFF
 void ide_dma_timeout (ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = HWIF(drive);

commit 653bcf5292a9ac4ffc07315198f0ef995e0646a8
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Oct 13 21:39:46 2008 +0200

    ide: __ide_dma_end() -> ide_dma_end()
    
    While at it:
    - use EXPORT_SYMBOL_GPL() to match the rest of SFF DMA functions
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index d5934fc8f85f..f142d8f1349e 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -531,7 +531,7 @@ void ide_dma_start(ide_drive_t *drive)
 EXPORT_SYMBOL_GPL(ide_dma_start);
 
 /* returns 1 on error, 0 otherwise */
-int __ide_dma_end (ide_drive_t *drive)
+int ide_dma_end(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = drive->hwif;
 	u8 mmio = (hwif->host_flags & IDE_HFLAG_MMIO) ? 1 : 0;
@@ -566,8 +566,7 @@ int __ide_dma_end (ide_drive_t *drive)
 	wmb();
 	return (dma_stat & 7) != 4 ? (0x10 | dma_stat) : 0;
 }
-
-EXPORT_SYMBOL(__ide_dma_end);
+EXPORT_SYMBOL_GPL(ide_dma_end);
 
 /* returns 1 if dma irq issued, 0 otherwise */
 int ide_dma_test_irq(ide_drive_t *drive)
@@ -880,7 +879,7 @@ const struct ide_dma_ops sff_dma_ops = {
 	.dma_setup		= ide_dma_setup,
 	.dma_exec_cmd		= ide_dma_exec_cmd,
 	.dma_start		= ide_dma_start,
-	.dma_end		= __ide_dma_end,
+	.dma_end		= ide_dma_end,
 	.dma_test_irq		= ide_dma_test_irq,
 	.dma_timeout		= ide_dma_timeout,
 	.dma_lost_irq		= ide_dma_lost_irq,

commit 123995b97136cb41fa282f0ed2385f2c8066df96
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Oct 13 21:39:40 2008 +0200

    ide: use 'drive->dn & 1' instead of drive->select.b.unit
    
    * Call ide_port_init_devices() in ide_host_register()
      also if 'struct ide_port_info *d' is not available.
    
    * Init drive->dn in ide_port_init_devices() instead of
      ide_probe_port() so it is valid also in ->init_dev.
    
    * Pass device number to ide_dev_apply_params().
    
    * Use 'drive->dn & 1' instead of drive->select.b.unit.
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 82fa6107434b..d5934fc8f85f 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -370,7 +370,7 @@ static int dma_timer_expiry (ide_drive_t *drive)
 void ide_dma_host_set(ide_drive_t *drive, int on)
 {
 	ide_hwif_t *hwif	= HWIF(drive);
-	u8 unit			= (drive->select.b.unit & 0x01);
+	u8 unit			= drive->dn & 1;
 	u8 dma_stat		= hwif->tp_ops->read_sff_dma_status(hwif);
 
 	if (on)

commit c67c216d810a05fffdbdbdf1b81048f0d4759287
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Oct 13 21:39:38 2008 +0200

    ide: remove superfluous ->waiting_for_dma checks
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 1185f5a4c154..82fa6107434b 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -578,9 +578,7 @@ int ide_dma_test_irq(ide_drive_t *drive)
 	/* return 1 if INTR asserted */
 	if ((dma_stat & 4) == 4)
 		return 1;
-	if (!drive->waiting_for_dma)
-		printk(KERN_WARNING "%s: (%s) called while not waiting\n",
-			drive->name, __func__);
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(ide_dma_test_irq);

commit e4634d4ef04fe6d7b114b612e5b71a84187ce76a
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Oct 13 21:39:37 2008 +0200

    ide: remove superfluous ->dma field from ide_hwif_t
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 2dacd802c72c..1185f5a4c154 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -525,7 +525,6 @@ void ide_dma_start(ide_drive_t *drive)
 		outb(dma_cmd | 1, hwif->dma_base + ATA_DMA_CMD);
 	}
 
-	hwif->dma = 1;
 	wmb();
 }
 
@@ -564,7 +563,6 @@ int __ide_dma_end (ide_drive_t *drive)
 	/* purge DMA mappings */
 	ide_destroy_dmatable(drive);
 	/* verify good DMA status */
-	hwif->dma = 0;
 	wmb();
 	return (dma_stat & 7) != 4 ? (0x10 | dma_stat) : 0;
 }

commit 97100fc816badbbc162644cfde7ad39ae9211fb4
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Oct 13 21:39:36 2008 +0200

    ide: add device flags
    
    Add 'unsigned long dev_flags' to ide_drive_t and convert bitfields
    to IDE_DFLAG_* flags.
    
    While at it:
    - IDE_DFLAG_ADDRESSING -> IDE_DFLAG_LBA48
    - fixup some comments
    - remove needless g->flags zeroing from ide*_probe()
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index ef2f1504c0d5..2dacd802c72c 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -397,7 +397,7 @@ EXPORT_SYMBOL_GPL(ide_dma_host_set);
 
 void ide_dma_off_quietly(ide_drive_t *drive)
 {
-	drive->using_dma = 0;
+	drive->dev_flags &= ~IDE_DFLAG_USING_DMA;
 	ide_toggle_bounce(drive, 0);
 
 	drive->hwif->dma_ops->dma_host_set(drive, 0);
@@ -430,7 +430,7 @@ EXPORT_SYMBOL(ide_dma_off);
 
 void ide_dma_on(ide_drive_t *drive)
 {
-	drive->using_dma = 1;
+	drive->dev_flags |= IDE_DFLAG_USING_DMA;
 	ide_toggle_bounce(drive, 1);
 
 	drive->hwif->dma_ops->dma_host_set(drive, 1);
@@ -727,7 +727,8 @@ static int ide_tune_dma(ide_drive_t *drive)
 	ide_hwif_t *hwif = drive->hwif;
 	u8 speed;
 
-	if (drive->nodma || ata_id_has_dma(drive->id) == 0)
+	if (ata_id_has_dma(drive->id) == 0 ||
+	    (drive->dev_flags & IDE_DFLAG_NODMA))
 		return 0;
 
 	/* consult the list of known "bad" drives */

commit 3a7d24841ad794ae64c90d7d00d62a83741912aa
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:21 2008 +0200

    ide: use ATA_* defines instead of *_STAT and *_ERR ones
    
    * ERR_STAT   -> ATA_ERR
    * INDEX_STAT -> ATA_IDX
    * ECC_STAT   -> ATA_CORR
    * DRQ_STAT   -> ATA_DRQ
    * SEEK_STAT  -> ATA_DSC
    * WRERR_STAT -> ATA_DF
    * READY_STAT -> ATA_DRDY
    * BUSY_STAT  -> ATA_BUSY
    
    * MARK_ERR   -> ATA_AMNF
    * TRK0_ERR   -> ATA_TRK0NF
    * ABRT_ERR   -> ATA_ABORTED
    * MCR_ERR    -> ATA_MCR
    * ID_ERR     -> ATA_IDNF
    * MC_ERR     -> ATA_MC
    * ECC_ERR    -> ATA_UNC
    * ICRC_ERR   -> ATA_ICRC
    
    * BBD_ERR    -> ATA_BBK
    
    Also:
    
    * ILI_ERR    -> ATAPI_ILI
    * EOM_ERR    -> ATAPI_EOM
    * LFS_ERR    -> ATAPI_LFS
    
    * CD         -> ATAPI_COD
    * IO         -> ATAPI_IO
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 15e608f52eba..ef2f1504c0d5 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -106,7 +106,7 @@ ide_startstop_t ide_dma_intr (ide_drive_t *drive)
 	dma_stat = hwif->dma_ops->dma_end(drive);
 	stat = hwif->tp_ops->read_status(hwif);
 
-	if (OK_STAT(stat,DRIVE_READY,drive->bad_wstat|DRQ_STAT)) {
+	if (OK_STAT(stat, DRIVE_READY, drive->bad_wstat | ATA_DRQ)) {
 		if (!dma_stat) {
 			struct request *rq = HWGROUP(drive)->rq;
 

commit 48fb2688aa67baba373531cc4ed2d9e695983c3f
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:19 2008 +0200

    ide: remove drive->driveid
    
    * Factor out HDIO_[OBSOLETE,GET]_IDENTITY ioctls handling
      to ide_get_identity_ioctl().
    
    * Use temporary buffer in ide_get_identity_ioctl() instead
      of accessing drive->id directly.
    
    * Add ide_id_to_hd_driveid() inline to convert raw id into
      struct hd_driveid format (needed on big-endian).
    
    * Use ide_id_to_hd_driveid() in ide_get_identity_ioctl(),
      cleanup ide_fix_driveid() and switch ide to use use raw id.
    
    * Remove no longer needed drive->driveid.
    
      This leaves us with 3 users of struct hd_driveid in tree:
      - arch/um/drivers/ubd_kern.c
      - drivers/block/xsysace.c
      - drivers/usb/storage/isd200.c
    
    While at it:
    
    * Use ata_id_u{32,64}() and ata_id_has_{dma,lba,iordy}() macros.
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index abab26de7687..15e608f52eba 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -649,8 +649,8 @@ static unsigned int ide_get_mode_mask(ide_drive_t *drive, u8 base, u8 req_mode)
 	case XFER_SW_DMA_0:
 		if (id[ATA_ID_FIELD_VALID] & 2) {
 			mask = id[ATA_ID_SWDMA_MODES] & hwif->swdma_mask;
-		} else if (drive->driveid->tDMA) {
-			u8 mode = drive->driveid->tDMA;
+		} else if (id[ATA_ID_OLD_DMA_MODES] >> 8) {
+			u8 mode = id[ATA_ID_OLD_DMA_MODES] >> 8;
 
 			/*
 			 * if the mode is valid convert it to the mask
@@ -727,7 +727,7 @@ static int ide_tune_dma(ide_drive_t *drive)
 	ide_hwif_t *hwif = drive->hwif;
 	u8 speed;
 
-	if (drive->nodma || (drive->driveid->capability & 1) == 0)
+	if (drive->nodma || ata_id_has_dma(drive->id) == 0)
 		return 0;
 
 	/* consult the list of known "bad" drives */

commit 4dde4492d850a4c9bcaa92e5bd7f4eebe3e2f5ab
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:19 2008 +0200

    ide: make drive->id an union (take 2)
    
    Make drive->id an unnamed union so id can be accessed either by using
    'u16 *id' or 'struct hd_driveid *driveid'.  Then convert all existing
    drive->id users accordingly (using 'u16 *id' when possible).
    
    This is an intermediate step to make ide 'struct hd_driveid'-free.
    
    While at it:
    
    - Add missing KERN_CONTs in it821x.c.
    
    - Use ATA_ID_WORDS and ATA_ID_*_LEN defines.
    
    - Remove unnecessary checks for drive->id.
    
    - s/drive_table/table/ in ide_in_drive_list().
    
    - Cleanup ide_config_drive_speed() a bit.
    
    - s/drive1/dev1/ & s/drive0/dev0/ in ide_undecoded_slave().
    
    v2:
    Fix typo in drivers/ide/ppc/pmac.c. (From Stephen Rothwell)
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 3fa07c0aeaa4..abab26de7687 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -288,7 +288,7 @@ EXPORT_SYMBOL_GPL(ide_destroy_dmatable);
 static int config_drive_for_dma (ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = drive->hwif;
-	struct hd_driveid *id = drive->id;
+	u16 *id = drive->id;
 
 	if (drive->media != ide_disk) {
 		if (hwif->host_flags & IDE_HFLAG_NO_ATAPI_DMA)
@@ -299,16 +299,17 @@ static int config_drive_for_dma (ide_drive_t *drive)
 	 * Enable DMA on any drive that has
 	 * UltraDMA (mode 0/1/2/3/4/5/6) enabled
 	 */
-	if ((id->field_valid & 4) && ((id->dma_ultra >> 8) & 0x7f))
+	if ((id[ATA_ID_FIELD_VALID] & 4) &&
+	    ((id[ATA_ID_UDMA_MODES] >> 8) & 0x7f))
 		return 1;
 
 	/*
 	 * Enable DMA on any drive that has mode2 DMA
 	 * (multi or single) enabled
 	 */
-	if (id->field_valid & 2)	/* regular DMA */
-		if ((id->dma_mword & 0x404) == 0x404 ||
-		    (id->dma_1word & 0x404) == 0x404)
+	if (id[ATA_ID_FIELD_VALID] & 2)	/* regular DMA */
+		if ((id[ATA_ID_MWDMA_MODES] & 0x404) == 0x404 ||
+		    (id[ATA_ID_SWDMA_MODES] & 0x404) == 0x404)
 			return 1;
 
 	/* Consult the list of known "good" drives */
@@ -591,12 +592,12 @@ static inline int config_drive_for_dma(ide_drive_t *drive) { return 0; }
 
 int __ide_dma_bad_drive (ide_drive_t *drive)
 {
-	struct hd_driveid *id = drive->id;
+	u16 *id = drive->id;
 
 	int blacklist = ide_in_drive_list(id, drive_blacklist);
 	if (blacklist) {
 		printk(KERN_WARNING "%s: Disabling (U)DMA for %s (blacklisted)\n",
-				    drive->name, id->model);
+				    drive->name, (char *)&id[ATA_ID_PROD]);
 		return blacklist;
 	}
 	return 0;
@@ -612,21 +613,21 @@ static const u8 xfer_mode_bases[] = {
 
 static unsigned int ide_get_mode_mask(ide_drive_t *drive, u8 base, u8 req_mode)
 {
-	struct hd_driveid *id = drive->id;
+	u16 *id = drive->id;
 	ide_hwif_t *hwif = drive->hwif;
 	const struct ide_port_ops *port_ops = hwif->port_ops;
 	unsigned int mask = 0;
 
 	switch(base) {
 	case XFER_UDMA_0:
-		if ((id->field_valid & 4) == 0)
+		if ((id[ATA_ID_FIELD_VALID] & 4) == 0)
 			break;
 
 		if (port_ops && port_ops->udma_filter)
 			mask = port_ops->udma_filter(drive);
 		else
 			mask = hwif->ultra_mask;
-		mask &= id->dma_ultra;
+		mask &= id[ATA_ID_UDMA_MODES];
 
 		/*
 		 * avoid false cable warning from eighty_ninty_three()
@@ -637,19 +638,19 @@ static unsigned int ide_get_mode_mask(ide_drive_t *drive, u8 base, u8 req_mode)
 		}
 		break;
 	case XFER_MW_DMA_0:
-		if ((id->field_valid & 2) == 0)
+		if ((id[ATA_ID_FIELD_VALID] & 2) == 0)
 			break;
 		if (port_ops && port_ops->mdma_filter)
 			mask = port_ops->mdma_filter(drive);
 		else
 			mask = hwif->mwdma_mask;
-		mask &= id->dma_mword;
+		mask &= id[ATA_ID_MWDMA_MODES];
 		break;
 	case XFER_SW_DMA_0:
-		if (id->field_valid & 2) {
-			mask = id->dma_1word & hwif->swdma_mask;
-		} else if (id->tDMA) {
-			u8 mode = id->tDMA;
+		if (id[ATA_ID_FIELD_VALID] & 2) {
+			mask = id[ATA_ID_SWDMA_MODES] & hwif->swdma_mask;
+		} else if (drive->driveid->tDMA) {
+			u8 mode = drive->driveid->tDMA;
 
 			/*
 			 * if the mode is valid convert it to the mask
@@ -706,7 +707,8 @@ u8 ide_find_dma_mode(ide_drive_t *drive, u8 req_mode)
 		/*
 		 * is this correct?
 		 */
-		if (ide_dma_good_drive(drive) && drive->id->eide_dma_time < 150)
+		if (ide_dma_good_drive(drive) &&
+		    drive->id[ATA_ID_EIDE_DMA_TIME] < 150)
 			mode = XFER_MW_DMA_1;
 	}
 
@@ -725,7 +727,7 @@ static int ide_tune_dma(ide_drive_t *drive)
 	ide_hwif_t *hwif = drive->hwif;
 	u8 speed;
 
-	if (drive->nodma || (drive->id->capability & 1) == 0)
+	if (drive->nodma || (drive->driveid->capability & 1) == 0)
 		return 0;
 
 	/* consult the list of known "bad" drives */
@@ -767,13 +769,15 @@ static int ide_dma_check(ide_drive_t *drive)
 
 int ide_id_dma_bug(ide_drive_t *drive)
 {
-	struct hd_driveid *id = drive->id;
+	u16 *id = drive->id;
 
-	if (id->field_valid & 4) {
-		if ((id->dma_ultra >> 8) && (id->dma_mword >> 8))
+	if (id[ATA_ID_FIELD_VALID] & 4) {
+		if ((id[ATA_ID_UDMA_MODES] >> 8) &&
+		    (id[ATA_ID_MWDMA_MODES] >> 8))
 			goto err_out;
-	} else if (id->field_valid & 2) {
-		if ((id->dma_mword >> 8) && (id->dma_1word >> 8))
+	} else if (id[ATA_ID_FIELD_VALID] & 2) {
+		if ((id[ATA_ID_MWDMA_MODES] >> 8) &&
+		    (id[ATA_ID_SWDMA_MODES] >> 8))
 			goto err_out;
 	}
 	return 0;

commit 22e05b4549bf2405d6aca128540b20cd2dd33f1f
Author: Sergei Shtylylov <sshtylyov@ru.mvista.com>
Date:   Sun Oct 5 18:23:27 2008 +0200

    ide-dma: fix ide_build_dmatable() for TRM290
    
    Apparently, 'xcount' being 0 does not mean 0 bytes for TRM290; it means 4 bytes,
    judging from the code immediately preceding this check.  So, we must never try
    to "split" the PRD for TRM290.
    
    This is probably never hit anyway -- with the DMA buffers aligned to at least
    512 bytes and ATAPI DMA not being used for non block I/O commands...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index adc682755857..3fa07c0aeaa4 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -211,7 +211,7 @@ int ide_build_dmatable (ide_drive_t *drive, struct request *rq)
 				xcount = bcount & 0xffff;
 				if (is_trm290)
 					xcount = ((xcount >> 2) - 1) << 16;
-				if (xcount == 0x0000) {
+				else if (xcount == 0x0000) {
 	/* 
 	 * Most chipsets correctly interpret a length of 0x0000 as 64KB,
 	 * but at least one (e.g. CS5530) misinterprets it as zero (!).

commit 367fdcb4e401161e51aaee5d06b3f82098bafefc
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Aug 5 18:16:55 2008 +0200

    ide: fix pre-EIDE SWDMA support on big-endian
    
    id->tDMA is of 'unsigned char' type so endianness is already
    correct and calling le16_to_cpu() is wrong.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 71c377a7bcf2..adc682755857 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -649,11 +649,7 @@ static unsigned int ide_get_mode_mask(ide_drive_t *drive, u8 base, u8 req_mode)
 		if (id->field_valid & 2) {
 			mask = id->dma_1word & hwif->swdma_mask;
 		} else if (id->tDMA) {
-			/*
-			 * ide_fix_driveid() doesn't convert ->tDMA to the
-			 * CPU endianness so we need to do it here
-			 */
-			u8 mode = le16_to_cpu(id->tDMA);
+			u8 mode = id->tDMA;
 
 			/*
 			 * if the mode is valid convert it to the mask

commit 7fa897b91a3ea0f16c2873b869d7a0eef05acff4
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Thu Jul 24 22:53:34 2008 +0200

    ide: trivial sparse annotations
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index be99d463dcc7..71c377a7bcf2 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -173,7 +173,7 @@ EXPORT_SYMBOL_GPL(ide_build_sglist);
 int ide_build_dmatable (ide_drive_t *drive, struct request *rq)
 {
 	ide_hwif_t *hwif	= HWIF(drive);
-	unsigned int *table	= hwif->dmatable_cpu;
+	__le32 *table = (__le32 *)hwif->dmatable_cpu;
 	unsigned int is_trm290	= (hwif->chipset == ide_trm290) ? 1 : 0;
 	unsigned int count = 0;
 	int i;

commit 374e042c3e767ac2e5a40b78529220e0b3de793c
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 23 19:55:56 2008 +0200

    ide: add struct ide_tp_ops (take 2)
    
    * Add struct ide_tp_ops for transport methods.
    
    * Add 'const struct ide_tp_ops *tp_ops' to struct ide_port_info
      and ide_hwif_t.
    
    * Set the default hwif->tp_ops in ide_init_port_data().
    
    * Set host driver specific hwif->tp_ops in ide_init_port().
    
    * Export ide_exec_command(), ide_read_status(), ide_read_altstatus(),
      ide_read_sff_dma_status(), ide_set_irq(), ide_tf_{load,read}()
      and ata_{in,out}put_data().
    
    * Convert host drivers and core code to use struct ide_tp_ops.
    
    * Remove no longer needed default_hwif_transport().
    
    * Cleanup ide_hwif_t from methods that are now in struct ide_tp_ops.
    
    While at it:
    
    * Use struct ide_port_info in falconide.c and q40ide.c.
    
    * Rename ata_{in,out}put_data() to ide_{in,out}put_data().
    
    v2:
    
    * Fix missing convertion in ns87415.c.
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index e72112efab9a..be99d463dcc7 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -104,7 +104,7 @@ ide_startstop_t ide_dma_intr (ide_drive_t *drive)
 	u8 stat = 0, dma_stat = 0;
 
 	dma_stat = hwif->dma_ops->dma_end(drive);
-	stat = hwif->read_status(hwif);
+	stat = hwif->tp_ops->read_status(hwif);
 
 	if (OK_STAT(stat,DRIVE_READY,drive->bad_wstat|DRQ_STAT)) {
 		if (!dma_stat) {
@@ -335,7 +335,7 @@ static int config_drive_for_dma (ide_drive_t *drive)
 static int dma_timer_expiry (ide_drive_t *drive)
 {
 	ide_hwif_t *hwif	= HWIF(drive);
-	u8 dma_stat		= hwif->read_sff_dma_status(hwif);
+	u8 dma_stat		= hwif->tp_ops->read_sff_dma_status(hwif);
 
 	printk(KERN_WARNING "%s: dma_timer_expiry: dma status == 0x%02x\n",
 		drive->name, dma_stat);
@@ -370,7 +370,7 @@ void ide_dma_host_set(ide_drive_t *drive, int on)
 {
 	ide_hwif_t *hwif	= HWIF(drive);
 	u8 unit			= (drive->select.b.unit & 0x01);
-	u8 dma_stat		= hwif->read_sff_dma_status(hwif);
+	u8 dma_stat		= hwif->tp_ops->read_sff_dma_status(hwif);
 
 	if (on)
 		dma_stat |= (1 << (5 + unit));
@@ -482,7 +482,7 @@ int ide_dma_setup(ide_drive_t *drive)
 		outb(reading, hwif->dma_base + ATA_DMA_CMD);
 
 	/* read DMA status for INTR & ERROR flags */
-	dma_stat = hwif->read_sff_dma_status(hwif);
+	dma_stat = hwif->tp_ops->read_sff_dma_status(hwif);
 
 	/* clear INTR & ERROR flags */
 	if (mmio)
@@ -551,7 +551,7 @@ int __ide_dma_end (ide_drive_t *drive)
 	}
 
 	/* get DMA status */
-	dma_stat = hwif->read_sff_dma_status(hwif);
+	dma_stat = hwif->tp_ops->read_sff_dma_status(hwif);
 
 	if (mmio)
 		/* clear the INTR & ERROR bits */
@@ -574,7 +574,7 @@ EXPORT_SYMBOL(__ide_dma_end);
 int ide_dma_test_irq(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif	= HWIF(drive);
-	u8 dma_stat		= hwif->read_sff_dma_status(hwif);
+	u8 dma_stat		= hwif->tp_ops->read_sff_dma_status(hwif);
 
 	/* return 1 if INTR asserted */
 	if ((dma_stat & 4) == 4)

commit ba4b2e607e4e9eaa929935325dafd5c86d3b5262
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 23 19:55:55 2008 +0200

    ide: remove dead Virtual DMA support
    
    Lets remove dead Virtual DMA support for now so it doesn't clutter
    core IDE code (it can be bring back when there is a need for it):
    
    * Remove IDE_HFLAG_VDMA host flag.
    
    * Remove ide_drive_t.vdma flag.
    
    * cs5520.c: remove stale FIXMEs, cs5520_dma_host_set() and cs5520_dma_ops
      (also there is no longer a need to set IDE_HFLAG_NO_ATAPI_DMA).
    
    There should be no functional changes caused by this patch.
    
    Cc: TAKADA Yoshihito <takada@mbf.nifty.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index ecf60dbbe3e9..e72112efab9a 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -756,9 +756,8 @@ static int ide_tune_dma(ide_drive_t *drive)
 static int ide_dma_check(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = drive->hwif;
-	int vdma = (hwif->host_flags & IDE_HFLAG_VDMA)? 1 : 0;
 
-	if (!vdma && ide_tune_dma(drive))
+	if (ide_tune_dma(drive))
 		return 0;
 
 	/* TODO: always do PIO fallback */
@@ -767,7 +766,7 @@ static int ide_dma_check(ide_drive_t *drive)
 
 	ide_set_max_pio(drive);
 
-	return vdma ? 0 : -1;
+	return -1;
 }
 
 int ide_id_dma_bug(ide_drive_t *drive)

commit b73c7ee25da6133f97f47ffd3557288417da7c76
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 23 19:55:52 2008 +0200

    ide: add ->read_status method
    
    * Remove ide_read_status() inline helper.
    
    * Add ->read_status method for reading ATA Status register
      and use it instead of ->INB.
    
    While at it:
    
    * Don't use HWGROUP() macro.
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index ac342ebf6c54..ecf60dbbe3e9 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -100,10 +100,11 @@ static const struct drive_list_entry drive_blacklist [] = {
  
 ide_startstop_t ide_dma_intr (ide_drive_t *drive)
 {
+	ide_hwif_t *hwif = drive->hwif;
 	u8 stat = 0, dma_stat = 0;
 
-	dma_stat = drive->hwif->dma_ops->dma_end(drive);
-	stat = ide_read_status(drive);
+	dma_stat = hwif->dma_ops->dma_end(drive);
+	stat = hwif->read_status(hwif);
 
 	if (OK_STAT(stat,DRIVE_READY,drive->bad_wstat|DRQ_STAT)) {
 		if (!dma_stat) {

commit 81e8d5a34f7d2a2acbe309cfa5810a9699a63239
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 23 19:55:51 2008 +0200

    ide: remove ide_setup_dma()
    
    Export sff_dma_ops and then remove ide_setup_dma().
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index d98a9da2699c..ac342ebf6c54 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -878,7 +878,7 @@ int ide_allocate_dma_engine(ide_hwif_t *hwif)
 }
 EXPORT_SYMBOL_GPL(ide_allocate_dma_engine);
 
-static const struct ide_dma_ops sff_dma_ops = {
+const struct ide_dma_ops sff_dma_ops = {
 	.dma_host_set		= ide_dma_host_set,
 	.dma_setup		= ide_dma_setup,
 	.dma_exec_cmd		= ide_dma_exec_cmd,
@@ -888,13 +888,5 @@ static const struct ide_dma_ops sff_dma_ops = {
 	.dma_timeout		= ide_dma_timeout,
 	.dma_lost_irq		= ide_dma_lost_irq,
 };
-
-void ide_setup_dma(ide_hwif_t *hwif, unsigned long base)
-{
-	hwif->dma_base = base;
-
-	hwif->dma_ops = &sff_dma_ops;
-}
-
-EXPORT_SYMBOL_GPL(ide_setup_dma);
+EXPORT_SYMBOL_GPL(sff_dma_ops);
 #endif /* CONFIG_BLK_DEV_IDEDMA_SFF */

commit cab7f8eda40d3e3e16b137c67cdddc2cf893c5d7
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 23 19:55:51 2008 +0200

    ide: remove ->dma_{status,command} fields from ide_hwif_t
    
    * Use ->dma_base + offset instead of ->dma_{status,command}
      and remove no longer needed ->dma_{status,command}.
    
    While at it:
    
    * Use ATA_DMA_* defines.
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index f3229642c052..d98a9da2699c 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -377,9 +377,10 @@ void ide_dma_host_set(ide_drive_t *drive, int on)
 		dma_stat &= ~(1 << (5 + unit));
 
 	if (hwif->host_flags & IDE_HFLAG_MMIO)
-		writeb(dma_stat, (void __iomem *)hwif->dma_status);
+		writeb(dma_stat,
+		       (void __iomem *)(hwif->dma_base + ATA_DMA_STATUS));
 	else
-		outb(dma_stat, hwif->dma_status);
+		outb(dma_stat, hwif->dma_base + ATA_DMA_STATUS);
 }
 
 EXPORT_SYMBOL_GPL(ide_dma_host_set);
@@ -475,18 +476,19 @@ int ide_dma_setup(ide_drive_t *drive)
 
 	/* specify r/w */
 	if (mmio)
-		writeb(reading, (void __iomem *)hwif->dma_command);
+		writeb(reading, (void __iomem *)(hwif->dma_base + ATA_DMA_CMD));
 	else
-		outb(reading, hwif->dma_command);
+		outb(reading, hwif->dma_base + ATA_DMA_CMD);
 
 	/* read DMA status for INTR & ERROR flags */
 	dma_stat = hwif->read_sff_dma_status(hwif);
 
 	/* clear INTR & ERROR flags */
 	if (mmio)
-		writeb(dma_stat | 6, (void __iomem *)hwif->dma_status);
+		writeb(dma_stat | 6,
+		       (void __iomem *)(hwif->dma_base + ATA_DMA_STATUS));
 	else
-		outb(dma_stat | 6, hwif->dma_status);
+		outb(dma_stat | 6, hwif->dma_base + ATA_DMA_STATUS);
 
 	drive->waiting_for_dma = 1;
 	return 0;
@@ -512,12 +514,13 @@ void ide_dma_start(ide_drive_t *drive)
 	 * we do this part before issuing the drive cmd.
 	 */
 	if (hwif->host_flags & IDE_HFLAG_MMIO) {
-		dma_cmd = readb((void __iomem *)hwif->dma_command);
+		dma_cmd = readb((void __iomem *)(hwif->dma_base + ATA_DMA_CMD));
 		/* start DMA */
-		writeb(dma_cmd | 1, (void __iomem *)hwif->dma_command);
+		writeb(dma_cmd | 1,
+		       (void __iomem *)(hwif->dma_base + ATA_DMA_CMD));
 	} else {
-		dma_cmd = inb(hwif->dma_command);
-		outb(dma_cmd | 1, hwif->dma_command);
+		dma_cmd = inb(hwif->dma_base + ATA_DMA_CMD);
+		outb(dma_cmd | 1, hwif->dma_base + ATA_DMA_CMD);
 	}
 
 	hwif->dma = 1;
@@ -537,12 +540,13 @@ int __ide_dma_end (ide_drive_t *drive)
 
 	if (mmio) {
 		/* get DMA command mode */
-		dma_cmd = readb((void __iomem *)hwif->dma_command);
+		dma_cmd = readb((void __iomem *)(hwif->dma_base + ATA_DMA_CMD));
 		/* stop DMA */
-		writeb(dma_cmd & ~1, (void __iomem *)hwif->dma_command);
+		writeb(dma_cmd & ~1,
+		       (void __iomem *)(hwif->dma_base + ATA_DMA_CMD));
 	} else {
-		dma_cmd = inb(hwif->dma_command);
-		outb(dma_cmd & ~1, hwif->dma_command);
+		dma_cmd = inb(hwif->dma_base + ATA_DMA_CMD);
+		outb(dma_cmd & ~1, hwif->dma_base + ATA_DMA_CMD);
 	}
 
 	/* get DMA status */
@@ -550,9 +554,10 @@ int __ide_dma_end (ide_drive_t *drive)
 
 	if (mmio)
 		/* clear the INTR & ERROR bits */
-		writeb(dma_stat | 6, (void __iomem *)hwif->dma_status);
+		writeb(dma_stat | 6,
+		       (void __iomem *)(hwif->dma_base + ATA_DMA_STATUS));
 	else
-		outb(dma_stat | 6, hwif->dma_status);
+		outb(dma_stat | 6, hwif->dma_base + ATA_DMA_STATUS);
 
 	/* purge DMA mappings */
 	ide_destroy_dmatable(drive);
@@ -888,11 +893,6 @@ void ide_setup_dma(ide_hwif_t *hwif, unsigned long base)
 {
 	hwif->dma_base = base;
 
-	if (!hwif->dma_command)
-		hwif->dma_command	= hwif->dma_base + 0;
-	if (!hwif->dma_status)
-		hwif->dma_status	= hwif->dma_base + 2;
-
 	hwif->dma_ops = &sff_dma_ops;
 }
 

commit ab86f91e8739e0b1587a16e4792ab5e4bb11f1b5
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 23 19:55:50 2008 +0200

    ide: use I/O ops directly in ide-dma.c
    
    Use I/O ops directly in ide_dma_host_set(), ide_dma_setup(),
    ide_dma_start() and __ide_dma_end().
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index ebddedde24af..f3229642c052 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -376,7 +376,10 @@ void ide_dma_host_set(ide_drive_t *drive, int on)
 	else
 		dma_stat &= ~(1 << (5 + unit));
 
-	hwif->OUTB(dma_stat, hwif->dma_status);
+	if (hwif->host_flags & IDE_HFLAG_MMIO)
+		writeb(dma_stat, (void __iomem *)hwif->dma_status);
+	else
+		outb(dma_stat, hwif->dma_status);
 }
 
 EXPORT_SYMBOL_GPL(ide_dma_host_set);
@@ -449,6 +452,7 @@ int ide_dma_setup(ide_drive_t *drive)
 	ide_hwif_t *hwif = drive->hwif;
 	struct request *rq = HWGROUP(drive)->rq;
 	unsigned int reading;
+	u8 mmio = (hwif->host_flags & IDE_HFLAG_MMIO) ? 1 : 0;
 	u8 dma_stat;
 
 	if (rq_data_dir(rq))
@@ -470,13 +474,20 @@ int ide_dma_setup(ide_drive_t *drive)
 		outl(hwif->dmatable_dma, hwif->dma_base + ATA_DMA_TABLE_OFS);
 
 	/* specify r/w */
-	hwif->OUTB(reading, hwif->dma_command);
+	if (mmio)
+		writeb(reading, (void __iomem *)hwif->dma_command);
+	else
+		outb(reading, hwif->dma_command);
 
 	/* read DMA status for INTR & ERROR flags */
 	dma_stat = hwif->read_sff_dma_status(hwif);
 
 	/* clear INTR & ERROR flags */
-	hwif->OUTB(dma_stat|6, hwif->dma_status);
+	if (mmio)
+		writeb(dma_stat | 6, (void __iomem *)hwif->dma_status);
+	else
+		outb(dma_stat | 6, hwif->dma_status);
+
 	drive->waiting_for_dma = 1;
 	return 0;
 }
@@ -492,16 +503,23 @@ EXPORT_SYMBOL_GPL(ide_dma_exec_cmd);
 
 void ide_dma_start(ide_drive_t *drive)
 {
-	ide_hwif_t *hwif	= HWIF(drive);
-	u8 dma_cmd		= hwif->INB(hwif->dma_command);
+	ide_hwif_t *hwif = drive->hwif;
+	u8 dma_cmd;
 
 	/* Note that this is done *after* the cmd has
 	 * been issued to the drive, as per the BM-IDE spec.
 	 * The Promise Ultra33 doesn't work correctly when
 	 * we do this part before issuing the drive cmd.
 	 */
-	/* start DMA */
-	hwif->OUTB(dma_cmd|1, hwif->dma_command);
+	if (hwif->host_flags & IDE_HFLAG_MMIO) {
+		dma_cmd = readb((void __iomem *)hwif->dma_command);
+		/* start DMA */
+		writeb(dma_cmd | 1, (void __iomem *)hwif->dma_command);
+	} else {
+		dma_cmd = inb(hwif->dma_command);
+		outb(dma_cmd | 1, hwif->dma_command);
+	}
+
 	hwif->dma = 1;
 	wmb();
 }
@@ -511,18 +529,31 @@ EXPORT_SYMBOL_GPL(ide_dma_start);
 /* returns 1 on error, 0 otherwise */
 int __ide_dma_end (ide_drive_t *drive)
 {
-	ide_hwif_t *hwif	= HWIF(drive);
+	ide_hwif_t *hwif = drive->hwif;
+	u8 mmio = (hwif->host_flags & IDE_HFLAG_MMIO) ? 1 : 0;
 	u8 dma_stat = 0, dma_cmd = 0;
 
 	drive->waiting_for_dma = 0;
-	/* get dma_command mode */
-	dma_cmd = hwif->INB(hwif->dma_command);
-	/* stop DMA */
-	hwif->OUTB(dma_cmd&~1, hwif->dma_command);
+
+	if (mmio) {
+		/* get DMA command mode */
+		dma_cmd = readb((void __iomem *)hwif->dma_command);
+		/* stop DMA */
+		writeb(dma_cmd & ~1, (void __iomem *)hwif->dma_command);
+	} else {
+		dma_cmd = inb(hwif->dma_command);
+		outb(dma_cmd & ~1, hwif->dma_command);
+	}
+
 	/* get DMA status */
 	dma_stat = hwif->read_sff_dma_status(hwif);
-	/* clear the INTR & ERROR bits */
-	hwif->OUTB(dma_stat|6, hwif->dma_status);
+
+	if (mmio)
+		/* clear the INTR & ERROR bits */
+		writeb(dma_stat | 6, (void __iomem *)hwif->dma_status);
+	else
+		outb(dma_stat | 6, hwif->dma_status);
+
 	/* purge DMA mappings */
 	ide_destroy_dmatable(drive);
 	/* verify good DMA status */

commit b2f951aabc9cc7d5fb987aeec9aef96ccce618a5
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 23 19:55:50 2008 +0200

    ide: add ->read_sff_dma_status method
    
    Add ->read_sff_dma_status method for reading DMA Status register
    and use it instead of ->INB.
    
    While at it:
    
    * Use inb() directly in ns87415.c::ns87415_dma_end().
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 7ee44f86bc54..ebddedde24af 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -334,7 +334,7 @@ static int config_drive_for_dma (ide_drive_t *drive)
 static int dma_timer_expiry (ide_drive_t *drive)
 {
 	ide_hwif_t *hwif	= HWIF(drive);
-	u8 dma_stat		= hwif->INB(hwif->dma_status);
+	u8 dma_stat		= hwif->read_sff_dma_status(hwif);
 
 	printk(KERN_WARNING "%s: dma_timer_expiry: dma status == 0x%02x\n",
 		drive->name, dma_stat);
@@ -369,7 +369,7 @@ void ide_dma_host_set(ide_drive_t *drive, int on)
 {
 	ide_hwif_t *hwif	= HWIF(drive);
 	u8 unit			= (drive->select.b.unit & 0x01);
-	u8 dma_stat		= hwif->INB(hwif->dma_status);
+	u8 dma_stat		= hwif->read_sff_dma_status(hwif);
 
 	if (on)
 		dma_stat |= (1 << (5 + unit));
@@ -472,8 +472,8 @@ int ide_dma_setup(ide_drive_t *drive)
 	/* specify r/w */
 	hwif->OUTB(reading, hwif->dma_command);
 
-	/* read dma_status for INTR & ERROR flags */
-	dma_stat = hwif->INB(hwif->dma_status);
+	/* read DMA status for INTR & ERROR flags */
+	dma_stat = hwif->read_sff_dma_status(hwif);
 
 	/* clear INTR & ERROR flags */
 	hwif->OUTB(dma_stat|6, hwif->dma_status);
@@ -520,7 +520,7 @@ int __ide_dma_end (ide_drive_t *drive)
 	/* stop DMA */
 	hwif->OUTB(dma_cmd&~1, hwif->dma_command);
 	/* get DMA status */
-	dma_stat = hwif->INB(hwif->dma_status);
+	dma_stat = hwif->read_sff_dma_status(hwif);
 	/* clear the INTR & ERROR bits */
 	hwif->OUTB(dma_stat|6, hwif->dma_status);
 	/* purge DMA mappings */
@@ -537,7 +537,7 @@ EXPORT_SYMBOL(__ide_dma_end);
 int ide_dma_test_irq(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif	= HWIF(drive);
-	u8 dma_stat		= hwif->INB(hwif->dma_status);
+	u8 dma_stat		= hwif->read_sff_dma_status(hwif);
 
 	/* return 1 if INTR asserted */
 	if ((dma_stat & 4) == 4)

commit 135721446144af005109c25eeacca4fdddcd9a66
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jul 15 21:21:49 2008 +0200

    ide: remove ->mmio flag from ide_hwif_t
    
    Since scc_pata host driver no longer uses IDE PCI layer / ide_dma_setup()
    and all other ->mmio users set also IDE_HFLAG_MMIO host flag we can safely
    remove ->mmio flag.
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 174f4704614c..7ee44f86bc54 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -463,7 +463,7 @@ int ide_dma_setup(ide_drive_t *drive)
 	}
 
 	/* PRD table */
-	if (hwif->mmio)
+	if (hwif->host_flags & IDE_HFLAG_MMIO)
 		writel(hwif->dmatable_dma,
 		       (void __iomem *)(hwif->dma_base + ATA_DMA_TABLE_OFS));
 	else

commit 931ee0dc5c69e8113233d21942681ab8fecde7f9
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jul 15 21:21:47 2008 +0200

    ide: remove obsoleted "ide=" kernel parameters
    
    * Remove obsoleted "ide=" kernel parameters.
    
    * Remove no longer needed:
      - ide_setup()
      - parse_options()
      - __setup("", ...)
      - module_param(options, ...)
    
    * Use module_{init,exit}() for MODULE=y case and remove MODULE ifdef.
    
    * Make ide_*acpi* and ide_doubler variables static.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 653b1ade13d3..174f4704614c 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -692,7 +692,7 @@ static int ide_tune_dma(ide_drive_t *drive)
 	ide_hwif_t *hwif = drive->hwif;
 	u8 speed;
 
-	if (noautodma || drive->nodma || (drive->id->capability & 1) == 0)
+	if (drive->nodma || (drive->id->capability & 1) == 0)
 		return 0;
 
 	/* consult the list of known "bad" drives */

commit 55224bc86a39409d55e47fd45573642ac709bb8f
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Apr 28 23:44:42 2008 +0200

    ide: remove ->dma_prdtable field from ide_hwif_t
    
    * Use 'hwif->dma_base + {4,8}' instead of hwif->dma_prdtable in
      {ide,scc}_dma_setup().
    
    * Remove no longer needed ->dma_prdtable field from ide_hwif_t.
    
    While at it:
    
    * Use ATA_DMA_TABLE_OFS define.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 767820db7cae..653b1ade13d3 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -464,9 +464,10 @@ int ide_dma_setup(ide_drive_t *drive)
 
 	/* PRD table */
 	if (hwif->mmio)
-		writel(hwif->dmatable_dma, (void __iomem *)hwif->dma_prdtable);
+		writel(hwif->dmatable_dma,
+		       (void __iomem *)(hwif->dma_base + ATA_DMA_TABLE_OFS));
 	else
-		outl(hwif->dmatable_dma, hwif->dma_prdtable);
+		outl(hwif->dmatable_dma, hwif->dma_base + ATA_DMA_TABLE_OFS);
 
 	/* specify r/w */
 	hwif->OUTB(reading, hwif->dma_command);
@@ -860,8 +861,6 @@ void ide_setup_dma(ide_hwif_t *hwif, unsigned long base)
 		hwif->dma_command	= hwif->dma_base + 0;
 	if (!hwif->dma_status)
 		hwif->dma_status	= hwif->dma_base + 2;
-	if (!hwif->dma_prdtable)
-		hwif->dma_prdtable	= hwif->dma_base + 4;
 
 	hwif->dma_ops = &sff_dma_ops;
 }

commit 41051a141dcc67f4c5011a2ab2b547e80b9ac509
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Apr 28 23:44:42 2008 +0200

    ide: remove ->dma_vendor{1,3} fields from ide_hwif_t
    
    * Use 'hwif->dma_base + {1,3}' instead of hwif->dma_vendor{1,3} in
      pdc202xx_new host driver.
    
    * Remove no longer needed ->dma_vendor{1,3} fields from ide_hwif_t.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index c352cf27b6e7..767820db7cae 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -858,12 +858,8 @@ void ide_setup_dma(ide_hwif_t *hwif, unsigned long base)
 
 	if (!hwif->dma_command)
 		hwif->dma_command	= hwif->dma_base + 0;
-	if (!hwif->dma_vendor1)
-		hwif->dma_vendor1	= hwif->dma_base + 1;
 	if (!hwif->dma_status)
 		hwif->dma_status	= hwif->dma_base + 2;
-	if (!hwif->dma_vendor3)
-		hwif->dma_vendor3	= hwif->dma_base + 3;
 	if (!hwif->dma_prdtable)
 		hwif->dma_prdtable	= hwif->dma_base + 4;
 

commit f37afdaca711838b50ecd89b9c15fc745270d77c
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 22:25:24 2008 +0200

    ide: constify struct ide_dma_ops
    
    * Export ide_dma_exec_cmd() and __ide_dma_test_irq().
    
    * Constify struct ide_dma_ops.
    
    * Always set hwif->dma_ops to &sff_dma_ops in ide_setup_dma()
      (it is later overriden by ide_init_port() if needed) and drop
      'const struct ide_port_info *d' argument.
    
    While at it:
    
    * Rename __ide_dma_test_irq() to ide_dma_test_irq().
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index a00d2598ec7f..c352cf27b6e7 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -482,11 +482,12 @@ int ide_dma_setup(ide_drive_t *drive)
 
 EXPORT_SYMBOL_GPL(ide_dma_setup);
 
-static void ide_dma_exec_cmd(ide_drive_t *drive, u8 command)
+void ide_dma_exec_cmd(ide_drive_t *drive, u8 command)
 {
 	/* issue cmd to drive */
 	ide_execute_command(drive, command, &ide_dma_intr, 2*WAIT_CMD, dma_timer_expiry);
 }
+EXPORT_SYMBOL_GPL(ide_dma_exec_cmd);
 
 void ide_dma_start(ide_drive_t *drive)
 {
@@ -532,7 +533,7 @@ int __ide_dma_end (ide_drive_t *drive)
 EXPORT_SYMBOL(__ide_dma_end);
 
 /* returns 1 if dma irq issued, 0 otherwise */
-static int __ide_dma_test_irq(ide_drive_t *drive)
+int ide_dma_test_irq(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif	= HWIF(drive);
 	u8 dma_stat		= hwif->INB(hwif->dma_status);
@@ -545,6 +546,7 @@ static int __ide_dma_test_irq(ide_drive_t *drive)
 			drive->name, __func__);
 	return 0;
 }
+EXPORT_SYMBOL_GPL(ide_dma_test_irq);
 #else
 static inline int config_drive_for_dma(ide_drive_t *drive) { return 0; }
 #endif /* CONFIG_BLK_DEV_IDEDMA_SFF */
@@ -839,21 +841,19 @@ int ide_allocate_dma_engine(ide_hwif_t *hwif)
 }
 EXPORT_SYMBOL_GPL(ide_allocate_dma_engine);
 
-static struct ide_dma_ops sff_dma_ops = {
+static const struct ide_dma_ops sff_dma_ops = {
 	.dma_host_set		= ide_dma_host_set,
 	.dma_setup		= ide_dma_setup,
 	.dma_exec_cmd		= ide_dma_exec_cmd,
 	.dma_start		= ide_dma_start,
 	.dma_end		= __ide_dma_end,
-	.dma_test_irq		= __ide_dma_test_irq,
+	.dma_test_irq		= ide_dma_test_irq,
 	.dma_timeout		= ide_dma_timeout,
 	.dma_lost_irq		= ide_dma_lost_irq,
 };
 
-void ide_setup_dma(ide_hwif_t *hwif, unsigned long base,
-		   const struct ide_port_info *d)
+void ide_setup_dma(ide_hwif_t *hwif, unsigned long base)
 {
-	struct ide_dma_ops *dma_ops = d->dma_ops ? d->dma_ops : &sff_dma_ops;
 	hwif->dma_base = base;
 
 	if (!hwif->dma_command)
@@ -867,24 +867,7 @@ void ide_setup_dma(ide_hwif_t *hwif, unsigned long base,
 	if (!hwif->dma_prdtable)
 		hwif->dma_prdtable	= hwif->dma_base + 4;
 
-	hwif->dma_ops = dma_ops;
-
-	if (dma_ops->dma_host_set == NULL)
-		dma_ops->dma_host_set	= ide_dma_host_set;
-	if (dma_ops->dma_setup == NULL)
-		dma_ops->dma_setup	= ide_dma_setup;
-	if (dma_ops->dma_exec_cmd == NULL)
-		dma_ops->dma_exec_cmd	= ide_dma_exec_cmd;
-	if (dma_ops->dma_start == NULL)
-		dma_ops->dma_start	= ide_dma_start;
-	if (dma_ops->dma_end == NULL)
-		dma_ops->dma_end	= __ide_dma_end;
-	if (dma_ops->dma_test_irq == NULL)
-		dma_ops->dma_test_irq	= __ide_dma_test_irq;
-	if (dma_ops->dma_timeout == NULL)
-		dma_ops->dma_timeout	= ide_dma_timeout;
-	if (dma_ops->dma_lost_irq == NULL)
-		dma_ops->dma_lost_irq	= ide_dma_lost_irq;
+	hwif->dma_ops = &sff_dma_ops;
 }
 
 EXPORT_SYMBOL_GPL(ide_setup_dma);

commit 5e37bdc081a980dd0d669e6387bcf15ca9666f81
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 22:25:24 2008 +0200

    ide: add struct ide_dma_ops (take 3)
    
    Add struct ide_dma_ops and convert core code + drivers to use it.
    
    While at it:
    
    * Drop "ide_" prefix from ->ide_dma_end and ->ide_dma_test_irq methods.
    
    * Drop "ide_" "infixes" from DMA methods.
    
    * au1xxx-ide.c:
      - use auide_dma_{test_irq,end}() directly in auide_dma_timeout()
    
    * pdc202xx_old.c:
      - drop "old_" "infixes" from DMA methods
    
    * siimage.c:
      - add siimage_dma_test_irq() helper
      - print SATA warning in siimage_init_one()
    
    * Remove no longer needed ->init_hwif implementations.
    
    v2:
    * Changes based on review from Sergei:
      - s/siimage_ide_dma_test_irq/siimage_dma_test_irq/
      - s/drive->hwif/hwif/ in idefloppy_pc_intr().
      - fix patch description w.r.t. au1xxx-ide changes
      - fix au1xxx-ide build
      - fix naming for cmd64*_dma_ops
      - drop "ide_" and "old_" infixes
      - s/hpt3xxx_dma_ops/hpt37x_dma_ops/
      - s/hpt370x_dma_ops/hpt370_dma_ops/
      - use correct DMA ops for HPT302/N, HPT371/N and HPT374
      - s/it821x_smart_dma_ops/it821x_pass_through_dma_ops/
    
    v3:
    * Two bugs slipped in v2 (noticed by Sergei):
      - use correct DMA ops for HPT374 (for real this time)
      - handle HPT370/HPT370A properly
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 366bbc841fc9..a00d2598ec7f 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -102,7 +102,7 @@ ide_startstop_t ide_dma_intr (ide_drive_t *drive)
 {
 	u8 stat = 0, dma_stat = 0;
 
-	dma_stat = HWIF(drive)->ide_dma_end(drive);
+	dma_stat = drive->hwif->dma_ops->dma_end(drive);
 	stat = ide_read_status(drive);
 
 	if (OK_STAT(stat,DRIVE_READY,drive->bad_wstat|DRQ_STAT)) {
@@ -394,7 +394,7 @@ void ide_dma_off_quietly(ide_drive_t *drive)
 	drive->using_dma = 0;
 	ide_toggle_bounce(drive, 0);
 
-	drive->hwif->dma_host_set(drive, 0);
+	drive->hwif->dma_ops->dma_host_set(drive, 0);
 }
 
 EXPORT_SYMBOL(ide_dma_off_quietly);
@@ -427,7 +427,7 @@ void ide_dma_on(ide_drive_t *drive)
 	drive->using_dma = 1;
 	ide_toggle_bounce(drive, 1);
 
-	drive->hwif->dma_host_set(drive, 1);
+	drive->hwif->dma_ops->dma_host_set(drive, 1);
 }
 
 #ifdef CONFIG_BLK_DEV_IDEDMA_SFF
@@ -802,10 +802,10 @@ void ide_dma_timeout (ide_drive_t *drive)
 
 	printk(KERN_ERR "%s: timeout waiting for DMA\n", drive->name);
 
-	if (hwif->ide_dma_test_irq(drive))
+	if (hwif->dma_ops->dma_test_irq(drive))
 		return;
 
-	hwif->ide_dma_end(drive);
+	hwif->dma_ops->dma_end(drive);
 }
 
 EXPORT_SYMBOL(ide_dma_timeout);
@@ -839,8 +839,21 @@ int ide_allocate_dma_engine(ide_hwif_t *hwif)
 }
 EXPORT_SYMBOL_GPL(ide_allocate_dma_engine);
 
-void ide_setup_dma(ide_hwif_t *hwif, unsigned long base)
+static struct ide_dma_ops sff_dma_ops = {
+	.dma_host_set		= ide_dma_host_set,
+	.dma_setup		= ide_dma_setup,
+	.dma_exec_cmd		= ide_dma_exec_cmd,
+	.dma_start		= ide_dma_start,
+	.dma_end		= __ide_dma_end,
+	.dma_test_irq		= __ide_dma_test_irq,
+	.dma_timeout		= ide_dma_timeout,
+	.dma_lost_irq		= ide_dma_lost_irq,
+};
+
+void ide_setup_dma(ide_hwif_t *hwif, unsigned long base,
+		   const struct ide_port_info *d)
 {
+	struct ide_dma_ops *dma_ops = d->dma_ops ? d->dma_ops : &sff_dma_ops;
 	hwif->dma_base = base;
 
 	if (!hwif->dma_command)
@@ -854,22 +867,24 @@ void ide_setup_dma(ide_hwif_t *hwif, unsigned long base)
 	if (!hwif->dma_prdtable)
 		hwif->dma_prdtable	= hwif->dma_base + 4;
 
-	if (!hwif->dma_host_set)
-		hwif->dma_host_set = &ide_dma_host_set;
-	if (!hwif->dma_setup)
-		hwif->dma_setup = &ide_dma_setup;
-	if (!hwif->dma_exec_cmd)
-		hwif->dma_exec_cmd = &ide_dma_exec_cmd;
-	if (!hwif->dma_start)
-		hwif->dma_start = &ide_dma_start;
-	if (!hwif->ide_dma_end)
-		hwif->ide_dma_end = &__ide_dma_end;
-	if (!hwif->ide_dma_test_irq)
-		hwif->ide_dma_test_irq = &__ide_dma_test_irq;
-	if (!hwif->dma_timeout)
-		hwif->dma_timeout = &ide_dma_timeout;
-	if (!hwif->dma_lost_irq)
-		hwif->dma_lost_irq = &ide_dma_lost_irq;
+	hwif->dma_ops = dma_ops;
+
+	if (dma_ops->dma_host_set == NULL)
+		dma_ops->dma_host_set	= ide_dma_host_set;
+	if (dma_ops->dma_setup == NULL)
+		dma_ops->dma_setup	= ide_dma_setup;
+	if (dma_ops->dma_exec_cmd == NULL)
+		dma_ops->dma_exec_cmd	= ide_dma_exec_cmd;
+	if (dma_ops->dma_start == NULL)
+		dma_ops->dma_start	= ide_dma_start;
+	if (dma_ops->dma_end == NULL)
+		dma_ops->dma_end	= __ide_dma_end;
+	if (dma_ops->dma_test_irq == NULL)
+		dma_ops->dma_test_irq	= __ide_dma_test_irq;
+	if (dma_ops->dma_timeout == NULL)
+		dma_ops->dma_timeout	= ide_dma_timeout;
+	if (dma_ops->dma_lost_irq == NULL)
+		dma_ops->dma_lost_irq	= ide_dma_lost_irq;
 }
 
 EXPORT_SYMBOL_GPL(ide_setup_dma);

commit 63158d5c217e2e62665ae9b10d203bd7da817108
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 22:25:21 2008 +0200

    ide: cleanup ide_setup_dma()
    
    * There is no need to call ide_release_dma_engine().
    
    * Move the code up to (and including) ide_allocate_dma_engine()
      call to the callers of ide_setup_dma().
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index ca7f974a71f5..366bbc841fc9 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -841,19 +841,6 @@ EXPORT_SYMBOL_GPL(ide_allocate_dma_engine);
 
 void ide_setup_dma(ide_hwif_t *hwif, unsigned long base)
 {
-	if (hwif->mmio)
-		printk(KERN_INFO "    %s: MMIO-DMA\n", hwif->name);
-	else
-		printk(KERN_INFO "    %s: BM-DMA at 0x%04lx-0x%04lx\n",
-				 hwif->name, base, base + 7);
-
-	hwif->extra_base = base + (hwif->channel ? 8 : 16);
-
-	if (ide_allocate_dma_engine(hwif)) {
-		ide_release_dma_engine(hwif);
-		return;
-	}
-
 	hwif->dma_base = base;
 
 	if (!hwif->dma_command)

commit b8e73fba60414e161d8fd2429b6fb268e34502e2
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 22:25:21 2008 +0200

    ide: export ide_allocate_dma_engine()
    
    Export ide_allocate_dma_engine() and use it in trm290 host driver.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 1933254660a1..ca7f974a71f5 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -821,7 +821,7 @@ void ide_release_dma_engine(ide_hwif_t *hwif)
 	}
 }
 
-static int ide_allocate_dma_engine(ide_hwif_t *hwif)
+int ide_allocate_dma_engine(ide_hwif_t *hwif)
 {
 	struct pci_dev *pdev = to_pci_dev(hwif->dev);
 
@@ -837,6 +837,7 @@ static int ide_allocate_dma_engine(ide_hwif_t *hwif)
 
 	return 1;
 }
+EXPORT_SYMBOL_GPL(ide_allocate_dma_engine);
 
 void ide_setup_dma(ide_hwif_t *hwif, unsigned long base)
 {

commit 8d9f9a76ea09911f4aaf0d9e852fd25335080f53
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 22:25:20 2008 +0200

    ide: don't display "BIOS" settings in ide_setup_dma()
    
    Nowadays BIOS info is not very useful and only confuses users since:
    
    - IDE always tries to use DMA
    
    - BIOS info may not be accurate with modular IDE/libata
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index b38a9dfb3146..1933254660a1 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -840,12 +840,10 @@ static int ide_allocate_dma_engine(ide_hwif_t *hwif)
 
 void ide_setup_dma(ide_hwif_t *hwif, unsigned long base)
 {
-	u8 dma_stat;
-
 	if (hwif->mmio)
-		printk(KERN_INFO "    %s: MMIO-DMA ", hwif->name);
+		printk(KERN_INFO "    %s: MMIO-DMA\n", hwif->name);
 	else
-		printk(KERN_INFO "    %s: BM-DMA at 0x%04lx-0x%04lx",
+		printk(KERN_INFO "    %s: BM-DMA at 0x%04lx-0x%04lx\n",
 				 hwif->name, base, base + 7);
 
 	hwif->extra_base = base + (hwif->channel ? 8 : 16);
@@ -884,11 +882,6 @@ void ide_setup_dma(ide_hwif_t *hwif, unsigned long base)
 		hwif->dma_timeout = &ide_dma_timeout;
 	if (!hwif->dma_lost_irq)
 		hwif->dma_lost_irq = &ide_dma_lost_irq;
-
-	dma_stat = hwif->INB(hwif->dma_status);
-	printk(KERN_CONT ", BIOS settings: %s:%s, %s:%s\n",
-	       hwif->drives[0].name, (dma_stat & 0x20) ? "DMA" : "PIO",
-	       hwif->drives[1].name, (dma_stat & 0x40) ? "DMA" : "PIO");
 }
 
 EXPORT_SYMBOL_GPL(ide_setup_dma);

commit 5e59c236846df444860ffc8b852117f9ff65c101
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 22:25:20 2008 +0200

    ide: remove ->cds field from ide_hwif_t (take 2)
    
    * Use hwif->name instead of cds->name in ide_allocate_dma_engine().
    
    * Use pci_name(dev) instead of cds->name in init_dma_pdc202xx().
    
    * Remove no longer needed ->cds field from ide_hwif_t.
    
    v2:
    
    * scc_pata.c also needs to be updated now (noticed by Stephen Rothwell).
    
    There should be no functional changes caused by this patch.
    
    Cc: Kou Ishizaki <kou.ishizaki@toshiba.co.jp>
    Cc: Akira Iguchi <akira2.iguchi@toshiba.co.jp>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 31a71136bbae..b38a9dfb3146 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -833,7 +833,7 @@ static int ide_allocate_dma_engine(ide_hwif_t *hwif)
 		return 0;
 
 	printk(KERN_ERR "%s: -- Error, unable to allocate DMA table.\n",
-	       hwif->cds->name);
+			hwif->name);
 
 	return 1;
 }

commit 0a79acd40d1ee8b6bf217a519eee422ed7e6da6b
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 22:25:20 2008 +0200

    ide: remove ide_dma_iobase()
    
    * ide_mapped_mmio_dma() and ide_iomio_dma() are called only by
      ide_dma_iobase() so inline them there.
    
    * ide_dma_iobase() is called only by ide_setup_dma() so inline
      it there.
    
    * Setup hwif->extra_base also if hwif->mmio flag is set.
    
    There should be no functional changes casued by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 77506fec1fbd..31a71136bbae 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -838,37 +838,17 @@ static int ide_allocate_dma_engine(ide_hwif_t *hwif)
 	return 1;
 }
 
-static int ide_mapped_mmio_dma(ide_hwif_t *hwif, unsigned long base)
-{
-	printk(KERN_INFO "    %s: MMIO-DMA ", hwif->name);
-
-	return 0;
-}
-
-static int ide_iomio_dma(ide_hwif_t *hwif, unsigned long base)
-{
-	printk(KERN_INFO "    %s: BM-DMA at 0x%04lx-0x%04lx",
-	       hwif->name, base, base + 7);
-
-	hwif->extra_base = base + (hwif->channel ? 8 : 16);
-
-	return 0;
-}
-
-static int ide_dma_iobase(ide_hwif_t *hwif, unsigned long base)
-{
-	if (hwif->mmio)
-		return ide_mapped_mmio_dma(hwif, base);
-
-	return ide_iomio_dma(hwif, base);
-}
-
 void ide_setup_dma(ide_hwif_t *hwif, unsigned long base)
 {
 	u8 dma_stat;
 
-	if (ide_dma_iobase(hwif, base))
-		return;
+	if (hwif->mmio)
+		printk(KERN_INFO "    %s: MMIO-DMA ", hwif->name);
+	else
+		printk(KERN_INFO "    %s: BM-DMA at 0x%04lx-0x%04lx",
+				 hwif->name, base, base + 7);
+
+	hwif->extra_base = base + (hwif->channel ? 8 : 16);
 
 	if (ide_allocate_dma_engine(hwif)) {
 		ide_release_dma_engine(hwif);

commit 21a3387ddd9eedcf6d4f47e591ffa90128b9f560
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 22:25:20 2008 +0200

    ide: remove ->extra field from struct ide_port_info
    
    Always setup hwif->extra_base in ide_iomio_dma() and remove
    no longer needed ->extra field from struct ide_port_info.
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 3cdb0749ada4..77506fec1fbd 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -850,8 +850,7 @@ static int ide_iomio_dma(ide_hwif_t *hwif, unsigned long base)
 	printk(KERN_INFO "    %s: BM-DMA at 0x%04lx-0x%04lx",
 	       hwif->name, base, base + 7);
 
-	if (hwif->cds->extra)
-		hwif->extra_base = base + (hwif->channel ? 8 : 16);
+	hwif->extra_base = base + (hwif->channel ? 8 : 16);
 
 	return 0;
 }

commit eb63963a55f039f049d0dd1121f91f332af6ecc9
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Sat Apr 26 22:25:20 2008 +0200

    ide: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    [bart: fix checkpatch.pl errors in ide-lib.c and ppc/mpc8xx.c while at it]
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 986ec465cb77..3cdb0749ada4 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -542,7 +542,7 @@ static int __ide_dma_test_irq(ide_drive_t *drive)
 		return 1;
 	if (!drive->waiting_for_dma)
 		printk(KERN_WARNING "%s: (%s) called while not waiting\n",
-			drive->name, __FUNCTION__);
+			drive->name, __func__);
 	return 0;
 }
 #else

commit 0d1bad216c43bcee84cc24d1ed003c19134d2645
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 22:25:19 2008 +0200

    ide: manage resources for PCI devices in ide_pci_enable() (take 3)
    
    * Reserve PCI BARs 0-3 (0-1 for single port controllers) in
      ide_pci_enable() and remove ide_hwif_request_regions() call
      from ide_device_add_all() (also cleanup resource management
      in scc_pata host driver).
    
    * Fix handling of PCI BAR 4 in ide_pci_enable(), then cleanup
      ide_iomio_dma() (+ init_hwif_trm290() in trm290 host driver)
      and remove ide_release[_iomio]_dma().
    
    v2:
    * Fixup trm290 host driver.
    
    v3:
    * Because of scc_pata host driver changes we need to call
      pci_request_selected_regions() also in setup_mmio_scc().
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index dc4bc06f9871..986ec465cb77 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -810,7 +810,7 @@ void ide_dma_timeout (ide_drive_t *drive)
 
 EXPORT_SYMBOL(ide_dma_timeout);
 
-static void ide_release_dma_engine(ide_hwif_t *hwif)
+void ide_release_dma_engine(ide_hwif_t *hwif)
 {
 	if (hwif->dmatable_cpu) {
 		struct pci_dev *pdev = to_pci_dev(hwif->dev);
@@ -821,27 +821,6 @@ static void ide_release_dma_engine(ide_hwif_t *hwif)
 	}
 }
 
-static int ide_release_iomio_dma(ide_hwif_t *hwif)
-{
-	release_region(hwif->dma_base, 8);
-	if (hwif->extra_ports)
-		release_region(hwif->extra_base, hwif->extra_ports);
-	return 1;
-}
-
-/*
- * Needed for allowing full modular support of ide-driver
- */
-int ide_release_dma(ide_hwif_t *hwif)
-{
-	ide_release_dma_engine(hwif);
-
-	if (hwif->mmio)
-		return 1;
-	else
-		return ide_release_iomio_dma(hwif);
-}
-
 static int ide_allocate_dma_engine(ide_hwif_t *hwif)
 {
 	struct pci_dev *pdev = to_pci_dev(hwif->dev);
@@ -871,25 +850,9 @@ static int ide_iomio_dma(ide_hwif_t *hwif, unsigned long base)
 	printk(KERN_INFO "    %s: BM-DMA at 0x%04lx-0x%04lx",
 	       hwif->name, base, base + 7);
 
-	if (!request_region(base, 8, hwif->name)) {
-		printk(" -- Error, ports in use.\n");
-		return 1;
-	}
-
-	if (hwif->cds->extra) {
+	if (hwif->cds->extra)
 		hwif->extra_base = base + (hwif->channel ? 8 : 16);
 
-		if (!hwif->mate || !hwif->mate->extra_ports) {
-			if (!request_region(hwif->extra_base,
-					    hwif->cds->extra, hwif->cds->name)) {
-				printk(" -- Error, extra ports in use.\n");
-				release_region(base, 8);
-				return 1;
-			}
-			hwif->extra_ports = hwif->cds->extra;
-		}
-	}
-
 	return 0;
 }
 
@@ -909,7 +872,7 @@ void ide_setup_dma(ide_hwif_t *hwif, unsigned long base)
 		return;
 
 	if (ide_allocate_dma_engine(hwif)) {
-		ide_release_dma(hwif);
+		ide_release_dma_engine(hwif);
 		return;
 	}
 

commit ac95beedf8bc97b24f9540d4da9952f07221c023
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 22:25:14 2008 +0200

    ide: add struct ide_port_ops (take 2)
    
    * Move hooks for port/host specific methods from ide_hwif_t to
      'struct ide_port_ops'.
    
    * Add 'const struct ide_port_ops *port_ops' to 'struct ide_port_info'
      and ide_hwif_t.
    
    * Update host drivers and core code accordingly.
    
    While at it:
    
    * Rename ata66_*() cable detect functions to *_cable_detect() to match
      the standard naming. (Suggested by Sergei Shtylyov)
    
    v2:
    * Fix build for bast-ide. (Noticed by Andrew Morton)
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 8757e5ef6c95..dc4bc06f9871 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -574,6 +574,7 @@ static unsigned int ide_get_mode_mask(ide_drive_t *drive, u8 base, u8 req_mode)
 {
 	struct hd_driveid *id = drive->id;
 	ide_hwif_t *hwif = drive->hwif;
+	const struct ide_port_ops *port_ops = hwif->port_ops;
 	unsigned int mask = 0;
 
 	switch(base) {
@@ -581,8 +582,8 @@ static unsigned int ide_get_mode_mask(ide_drive_t *drive, u8 base, u8 req_mode)
 		if ((id->field_valid & 4) == 0)
 			break;
 
-		if (hwif->udma_filter)
-			mask = hwif->udma_filter(drive);
+		if (port_ops && port_ops->udma_filter)
+			mask = port_ops->udma_filter(drive);
 		else
 			mask = hwif->ultra_mask;
 		mask &= id->dma_ultra;
@@ -598,8 +599,8 @@ static unsigned int ide_get_mode_mask(ide_drive_t *drive, u8 base, u8 req_mode)
 	case XFER_MW_DMA_0:
 		if ((id->field_valid & 2) == 0)
 			break;
-		if (hwif->mdma_filter)
-			mask = hwif->mdma_filter(drive);
+		if (port_ops && port_ops->mdma_filter)
+			mask = port_ops->mdma_filter(drive);
 		else
 			mask = hwif->mwdma_mask;
 		mask &= id->dma_mword;

commit 784506cbddd17bcd5929f827df39b0c7014e3f1e
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 17:36:43 2008 +0200

    ide: sanitize handling of IDE_HFLAG_NO_SET_MODE host flag
    
    * Check for IDE_HFLAG_NO_SET_MODE host flag in ide_set_pio(),
      ide_set_[pio,dma]_mode(), ide_set_xfer_rate() and set_pio_mode().
    
    * Remove no longer needed IDE_HFLAG_NO_SET_MODE host flag checking
      from ide_tune_dma().
    
    * Remove superfluous ->set_pio_mode checking from do_special().
    
    This is a part of preparations for adding 'struct ide_port_ops'.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index aaece2c06c9d..8757e5ef6c95 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -706,9 +706,6 @@ static int ide_tune_dma(ide_drive_t *drive)
 	if (!speed)
 		return 0;
 
-	if (hwif->host_flags & IDE_HFLAG_NO_SET_MODE)
-		return 1;
-
 	if (ide_set_dma_mode(drive, speed))
 		return 0;
 

commit 951784b667d78dad52ffea0a958fdbe14da97972
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 17:36:38 2008 +0200

    ide: remove IDE_HFLAG_CY82C693 host flag
    
    Sergei suggested that it shouldn't be necessary + it had no effect
    anyway since ide_id_dma_bug() is called earlier in ide_tune_dma().
    
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index d61e5788d310..aaece2c06c9d 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -703,14 +703,8 @@ static int ide_tune_dma(ide_drive_t *drive)
 
 	speed = ide_max_dma_mode(drive);
 
-	if (!speed) {
-		 /* is this really correct/needed? */
-		if ((hwif->host_flags & IDE_HFLAG_CY82C693) &&
-		    ide_dma_good_drive(drive))
-			return 1;
-		else
-			return 0;
-	}
+	if (!speed)
+		return 0;
 
 	if (hwif->host_flags & IDE_HFLAG_NO_SET_MODE)
 		return 1;

commit ef4298d0f06c788d204caa9e395de6e9e2fd9fc9
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Mar 7 21:53:49 2008 +0100

    ide: fix enabling DMA on it821x in "smart" mode
    
    ide_tune_dma() should return '1' if IDE_HFLAG_NO_SET_MODE host flag is set.
    
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 2de99e4be5c9..d61e5788d310 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -713,7 +713,7 @@ static int ide_tune_dma(ide_drive_t *drive)
 	}
 
 	if (hwif->host_flags & IDE_HFLAG_NO_SET_MODE)
-		return 0;
+		return 1;
 
 	if (ide_set_dma_mode(drive, speed))
 		return 0;

commit 204f47c5a581630369d425b5a4afa48448c30359
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Feb 26 21:50:36 2008 +0100

    ide: remove stale comments from ide-dma.c (take 2)
    
    - ide-dma.c is not a separate module
    
    - ide-dma.c is not PCI specific anymore
    
    - DMA is enabled by default nowadays
    
    - link for Intel Zappa BIOS is dead
    
    etc.
    
    v2:
    * Some comments should be preserved. (Noticed by Mark Lord)
    
    Cc: Mark Lord <liml@rtr.ca>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index d0e7b537353e..2de99e4be5c9 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -1,9 +1,13 @@
 /*
+ *  IDE DMA support (including IDE PCI BM-DMA).
+ *
  *  Copyright (C) 1995-1998   Mark Lord
  *  Copyright (C) 1999-2000   Andre Hedrick <andre@linux-ide.org>
  *  Copyright (C) 2004, 2007  Bartlomiej Zolnierkiewicz
  *
  *  May be copied or modified under the terms of the GNU General Public License
+ *
+ *  DMA is supported for all IDE devices (disk drives, cdroms, tapes, floppies).
  */
 
 /*
@@ -11,49 +15,6 @@
  */
 
 /*
- * This module provides support for the bus-master IDE DMA functions
- * of various PCI chipsets, including the Intel PIIX (i82371FB for
- * the 430 FX chipset), the PIIX3 (i82371SB for the 430 HX/VX and 
- * 440 chipsets), and the PIIX4 (i82371AB for the 430 TX chipset)
- * ("PIIX" stands for "PCI ISA IDE Xcellerator").
- *
- * Pretty much the same code works for other IDE PCI bus-mastering chipsets.
- *
- * DMA is supported for all IDE devices (disk drives, cdroms, tapes, floppies).
- *
- * By default, DMA support is prepared for use, but is currently enabled only
- * for drives which already have DMA enabled (UltraDMA or mode 2 multi/single),
- * or which are recognized as "good" (see table below).  Drives with only mode0
- * or mode1 (multi/single) DMA should also work with this chipset/driver
- * (eg. MC2112A) but are not enabled by default.
- *
- * Use "hdparm -i" to view modes supported by a given drive.
- *
- * The hdparm-3.5 (or later) utility can be used for manually enabling/disabling
- * DMA support, but must be (re-)compiled against this kernel version or later.
- *
- * To enable DMA, use "hdparm -d1 /dev/hd?" on a per-drive basis after booting.
- * If problems arise, ide.c will disable DMA operation after a few retries.
- * This error recovery mechanism works and has been extremely well exercised.
- *
- * IDE drives, depending on their vintage, may support several different modes
- * of DMA operation.  The boot-time modes are indicated with a "*" in
- * the "hdparm -i" listing, and can be changed with *knowledgeable* use of
- * the "hdparm -X" feature.  There is seldom a need to do this, as drives
- * normally power-up with their "best" PIO/DMA modes enabled.
- *
- * Testing has been done with a rather extensive number of drives,
- * with Quantum & Western Digital models generally outperforming the pack,
- * and Fujitsu & Conner (and some Seagate which are really Conner) drives
- * showing more lackluster throughput.
- *
- * Keep an eye on /var/adm/messages for "DMA disabled" messages.
- *
- * Some people have reported trouble with Intel Zappa motherboards.
- * This can be fixed by upgrading the AMI BIOS to version 1.00.04.BS0,
- * available from ftp://ftp.intel.com/pub/bios/10004bs0.exe
- * (thanks to Glen Morrell <glen@spin.Stanford.edu> for researching this).
- *
  * Thanks to "Christopher J. Reimer" <reimer@doe.carleton.ca> for
  * fixing the problem with the BIOS on some Acer motherboards.
  *
@@ -65,11 +26,6 @@
  *
  * Most importantly, thanks to Robert Bringman <rob@mars.trion.com>
  * for supplying a Promise UDMA board & WD UDMA drive for this work!
- *
- * And, yes, Intel Zappa boards really *do* use both PIIX IDE ports.
- *
- * ATA-66/100 and recovery functions, I forgot the rest......
- *
  */
 
 #include <linux/module.h>

commit 8e882ba111bb52fbb42c34a265afb97ddd4fcea1
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Mon Feb 11 00:32:14 2008 +0100

    ide: introduce CONFIG_BLK_DEV_IDEDMA_SFF option
    
    Introduce new option CONFIG_BLK_DEV_IDEDMA_SFF for non-PCI SFF-8038i compatible
    bus mastering IDE controllers (which there are a few known), thus fixing a hack
    made for Palmchip BK3710 controller...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: Anton Salnikov <asalnikov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index a4bb32883c6b..d0e7b537353e 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -198,7 +198,7 @@ int ide_build_sglist(ide_drive_t *drive, struct request *rq)
 
 EXPORT_SYMBOL_GPL(ide_build_sglist);
 
-#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
+#ifdef CONFIG_BLK_DEV_IDEDMA_SFF
 /**
  *	ide_build_dmatable	-	build IDE DMA table
  *
@@ -316,7 +316,7 @@ void ide_destroy_dmatable (ide_drive_t *drive)
 
 EXPORT_SYMBOL_GPL(ide_destroy_dmatable);
 
-#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
+#ifdef CONFIG_BLK_DEV_IDEDMA_SFF
 /**
  *	config_drive_for_dma	-	attempt to activate IDE DMA
  *	@drive: the drive to place in DMA mode
@@ -424,7 +424,7 @@ void ide_dma_host_set(ide_drive_t *drive, int on)
 }
 
 EXPORT_SYMBOL_GPL(ide_dma_host_set);
-#endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
+#endif /* CONFIG_BLK_DEV_IDEDMA_SFF  */
 
 /**
  *	ide_dma_off_quietly	-	Generic DMA kill
@@ -474,7 +474,7 @@ void ide_dma_on(ide_drive_t *drive)
 	drive->hwif->dma_host_set(drive, 1);
 }
 
-#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
+#ifdef CONFIG_BLK_DEV_IDEDMA_SFF
 /**
  *	ide_dma_setup	-	begin a DMA phase
  *	@drive: target device
@@ -591,7 +591,7 @@ static int __ide_dma_test_irq(ide_drive_t *drive)
 }
 #else
 static inline int config_drive_for_dma(ide_drive_t *drive) { return 0; }
-#endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
+#endif /* CONFIG_BLK_DEV_IDEDMA_SFF */
 
 int __ide_dma_bad_drive (ide_drive_t *drive)
 {
@@ -840,7 +840,7 @@ void ide_check_dma_crc(ide_drive_t *drive)
 		ide_dma_on(drive);
 }
 
-#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
+#ifdef CONFIG_BLK_DEV_IDEDMA_SFF
 void ide_dma_lost_irq (ide_drive_t *drive)
 {
 	printk("%s: DMA interrupt recovery\n", drive->name);
@@ -1002,4 +1002,4 @@ void ide_setup_dma(ide_hwif_t *hwif, unsigned long base)
 }
 
 EXPORT_SYMBOL_GPL(ide_setup_dma);
-#endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
+#endif /* CONFIG_BLK_DEV_IDEDMA_SFF */

commit c47137a99c597330b69057158b26061a360c0e09
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Feb 6 02:57:51 2008 +0100

    ide: add ide_read_[alt]status() inline helpers
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 3cf59f2c3928..a4bb32883c6b 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -147,7 +147,8 @@ ide_startstop_t ide_dma_intr (ide_drive_t *drive)
 	u8 stat = 0, dma_stat = 0;
 
 	dma_stat = HWIF(drive)->ide_dma_end(drive);
-	stat = HWIF(drive)->INB(IDE_STATUS_REG);	/* get drive status */
+	stat = ide_read_status(drive);
+
 	if (OK_STAT(stat,DRIVE_READY,drive->bad_wstat|DRQ_STAT)) {
 		if (!dma_stat) {
 			struct request *rq = HWGROUP(drive)->rq;

commit 578cfa0d72f81526b2fcb1dd2463c47bbf633989
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Feb 2 19:56:47 2008 +0100

    ide: move check_dma_crc() to ide-dma.c
    
    * Move check_dma_crc() to ide-dma.c and add inline version for
      CONFIG_BLK_DEV_IDEDMA=n case.
    
    * Rename check_dma_crc() to ide_check_dma_crc().
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 7beaf1e9be12..3cf59f2c3928 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -819,6 +819,26 @@ int ide_set_dma(ide_drive_t *drive)
 	return 0;
 }
 
+void ide_check_dma_crc(ide_drive_t *drive)
+{
+	u8 mode;
+
+	ide_dma_off_quietly(drive);
+	drive->crc_count = 0;
+	mode = drive->current_speed;
+	/*
+	 * Don't try non Ultra-DMA modes without iCRC's.  Force the
+	 * device to PIO and make the user enable SWDMA/MWDMA modes.
+	 */
+	if (mode > XFER_UDMA_0 && mode <= XFER_UDMA_7)
+		mode--;
+	else
+		mode = XFER_PIO_4;
+	ide_set_xfer_rate(drive, mode);
+	if (drive->current_speed >= XFER_SW_DMA_0)
+		ide_dma_on(drive);
+}
+
 #ifdef CONFIG_BLK_DEV_IDEDMA_PCI
 void ide_dma_lost_irq (ide_drive_t *drive)
 {

commit 59bca8cc995428c34d8cdfadfa87c8e3f01c4340
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Feb 1 23:09:33 2008 +0100

    ide: update/add my Copyrights
    
    The last years stuff and a trip down memory lane...
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 79f795afba2a..7beaf1e9be12 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -1,14 +1,13 @@
 /*
- *  Copyright (c) 1999-2000	Andre Hedrick <andre@linux-ide.org>
+ *  Copyright (C) 1995-1998   Mark Lord
+ *  Copyright (C) 1999-2000   Andre Hedrick <andre@linux-ide.org>
+ *  Copyright (C) 2004, 2007  Bartlomiej Zolnierkiewicz
  *
  *  May be copied or modified under the terms of the GNU General Public License
  */
 
 /*
  *  Special Thanks to Mark for his Six years of work.
- *
- *  Copyright (c) 1995-1998  Mark Lord
- *  May be copied or modified under the terms of the GNU General Public License
  */
 
 /*

commit 58f189fccc72bb8a91de1854e519b47d64fbdbaa
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Feb 1 23:09:33 2008 +0100

    ide: delete filenames/versions from comments
    
    Delete filenames/versions from comments.
    
    I'm leaving decisions about adding DRV_VERSION defines and MODULE_VERSION()-s
    to maintainers of the respective drivers.
    
    While at it:
    
    * Remove unused VERSION define from ide.c.
    
    * Remove unused/stale DRV_VERSION define from au1xxx-ide.c.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 64fd78ba2810..79f795afba2a 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -1,7 +1,6 @@
 /*
- *  linux/drivers/ide/ide-dma.c		Version 4.10	June 9, 2000
- *
  *  Copyright (c) 1999-2000	Andre Hedrick <andre@linux-ide.org>
+ *
  *  May be copied or modified under the terms of the GNU General Public License
  */
 

commit 062f9f024dcdb927cfd35c9ee8a68f59cbb1136f
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Feb 1 23:09:32 2008 +0100

    ide: use ide_build_sglist() and ide_destroy_dmatable() in non-PCI host drivers
    
    * Make ide_build_sglist() and ide_destroy_dmatable() available also when
      CONFIG_BLK_DEV_IDEDMA_PCI=n.
    
    * Use ide_build_sglist() and ide_destroy_dmatable() in {ics,au1xxx-}ide.c
      and remove no longer needed {ics,au}ide_build_sglist().
    
    There should be no functionality changes caused by this patch.
    
    Cc: Russell King <rmk@arm.linux.org.uk>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index ec7c5c8dc698..64fd78ba2810 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -170,7 +170,6 @@ static int ide_dma_good_drive(ide_drive_t *drive)
 	return ide_in_drive_list(drive->id, drive_whitelist);
 }
 
-#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
 /**
  *	ide_build_sglist	-	map IDE scatter gather for DMA I/O
  *	@drive: the drive to build the DMA table for
@@ -200,6 +199,7 @@ int ide_build_sglist(ide_drive_t *drive, struct request *rq)
 
 EXPORT_SYMBOL_GPL(ide_build_sglist);
 
+#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
 /**
  *	ide_build_dmatable	-	build IDE DMA table
  *
@@ -294,6 +294,7 @@ int ide_build_dmatable (ide_drive_t *drive, struct request *rq)
 }
 
 EXPORT_SYMBOL_GPL(ide_build_dmatable);
+#endif
 
 /**
  *	ide_destroy_dmatable	-	clean up DMA mapping
@@ -316,6 +317,7 @@ void ide_destroy_dmatable (ide_drive_t *drive)
 
 EXPORT_SYMBOL_GPL(ide_destroy_dmatable);
 
+#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
 /**
  *	config_drive_for_dma	-	attempt to activate IDE DMA
  *	@drive: the drive to place in DMA mode

commit 5c05ff68b9a9b40a9be949497e0aa980185565cf
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Feb 1 23:09:32 2008 +0100

    ide: switch to DMA-mapping API
    
    * pci_map_sg() -> dma_map_sg() in ide_build_sglist().
    
    * pci_unmap_sg() -> dma_unmap_sg() in ide_destroy_dmatable().
    
    There should be no functionality changes caused by this patch except
    for blackfin arch whose dma_[un]map_sg() implementation differs from
    pci_[un]map_sg() one (on s390 arch there is no PCI, on avr32 and h8300
    archs PCI is currently unsupported, on m32r arch PCI support depends
    on BROKEN, on m68k arch PCI support depends on HADES which in turn
    depends on BROKEN, on all other archs dma_[un]map_sg() functionality
    matches with pci_[un]map_sg() one).
    
    blackfin behavior change was ack-ed by Bryan Wu.
    
    Cc: Bryan Wu <bryan.wu@analog.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 782e5da01578..ec7c5c8dc698 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -85,6 +85,7 @@
 #include <linux/ide.h>
 #include <linux/delay.h>
 #include <linux/scatterlist.h>
+#include <linux/dma-mapping.h>
 
 #include <asm/io.h>
 #include <asm/irq.h>
@@ -175,26 +176,26 @@ static int ide_dma_good_drive(ide_drive_t *drive)
  *	@drive: the drive to build the DMA table for
  *	@rq: the request holding the sg list
  *
- *	Perform the PCI mapping magic necessary to access the source or
- *	target buffers of a request via PCI DMA. The lower layers of the
+ *	Perform the DMA mapping magic necessary to access the source or
+ *	target buffers of a request via DMA.  The lower layers of the
  *	kernel provide the necessary cache management so that we can
- *	operate in a portable fashion
+ *	operate in a portable fashion.
  */
 
 int ide_build_sglist(ide_drive_t *drive, struct request *rq)
 {
 	ide_hwif_t *hwif = HWIF(drive);
-	struct pci_dev *pdev = to_pci_dev(hwif->dev);
 	struct scatterlist *sg = hwif->sg_table;
 
 	ide_map_sg(drive, rq);
 
 	if (rq_data_dir(rq) == READ)
-		hwif->sg_dma_direction = PCI_DMA_FROMDEVICE;
+		hwif->sg_dma_direction = DMA_FROM_DEVICE;
 	else
-		hwif->sg_dma_direction = PCI_DMA_TODEVICE;
+		hwif->sg_dma_direction = DMA_TO_DEVICE;
 
-	return pci_map_sg(pdev, sg, hwif->sg_nents, hwif->sg_dma_direction);
+	return dma_map_sg(hwif->dev, sg, hwif->sg_nents,
+			  hwif->sg_dma_direction);
 }
 
 EXPORT_SYMBOL_GPL(ide_build_sglist);
@@ -308,9 +309,8 @@ EXPORT_SYMBOL_GPL(ide_build_dmatable);
 void ide_destroy_dmatable (ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = drive->hwif;
-	struct pci_dev *pdev = to_pci_dev(hwif->dev);
 
-	pci_unmap_sg(pdev, hwif->sg_table, hwif->sg_nents,
+	dma_unmap_sg(hwif->dev, hwif->sg_table, hwif->sg_nents,
 		     hwif->sg_dma_direction);
 }
 

commit 36501650ec45b1db308c3b51886044863be2d762
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Feb 1 23:09:31 2008 +0100

    ide: keep pointer to struct device instead of struct pci_dev in ide_hwif_t
    
    Keep pointer to struct device instead of struct pci_dev in ide_hwif_t.
    
    While on it:
    * Use *dev->dma_mask instead of pci_dev->dma_mask in ide_toggle_bounce().
    
    There should be no functionality changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 1ca1210ec1c0..782e5da01578 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -184,6 +184,7 @@ static int ide_dma_good_drive(ide_drive_t *drive)
 int ide_build_sglist(ide_drive_t *drive, struct request *rq)
 {
 	ide_hwif_t *hwif = HWIF(drive);
+	struct pci_dev *pdev = to_pci_dev(hwif->dev);
 	struct scatterlist *sg = hwif->sg_table;
 
 	ide_map_sg(drive, rq);
@@ -193,7 +194,7 @@ int ide_build_sglist(ide_drive_t *drive, struct request *rq)
 	else
 		hwif->sg_dma_direction = PCI_DMA_TODEVICE;
 
-	return pci_map_sg(hwif->pci_dev, sg, hwif->sg_nents, hwif->sg_dma_direction);
+	return pci_map_sg(pdev, sg, hwif->sg_nents, hwif->sg_dma_direction);
 }
 
 EXPORT_SYMBOL_GPL(ide_build_sglist);
@@ -306,11 +307,11 @@ EXPORT_SYMBOL_GPL(ide_build_dmatable);
  
 void ide_destroy_dmatable (ide_drive_t *drive)
 {
-	struct pci_dev *dev = HWIF(drive)->pci_dev;
-	struct scatterlist *sg = HWIF(drive)->sg_table;
-	int nents = HWIF(drive)->sg_nents;
+	ide_hwif_t *hwif = drive->hwif;
+	struct pci_dev *pdev = to_pci_dev(hwif->dev);
 
-	pci_unmap_sg(dev, sg, nents, HWIF(drive)->sg_dma_direction);
+	pci_unmap_sg(pdev, hwif->sg_table, hwif->sg_nents,
+		     hwif->sg_dma_direction);
 }
 
 EXPORT_SYMBOL_GPL(ide_destroy_dmatable);
@@ -843,10 +844,10 @@ EXPORT_SYMBOL(ide_dma_timeout);
 static void ide_release_dma_engine(ide_hwif_t *hwif)
 {
 	if (hwif->dmatable_cpu) {
-		pci_free_consistent(hwif->pci_dev,
-				    PRD_ENTRIES * PRD_BYTES,
-				    hwif->dmatable_cpu,
-				    hwif->dmatable_dma);
+		struct pci_dev *pdev = to_pci_dev(hwif->dev);
+
+		pci_free_consistent(pdev, PRD_ENTRIES * PRD_BYTES,
+				    hwif->dmatable_cpu, hwif->dmatable_dma);
 		hwif->dmatable_cpu = NULL;
 	}
 }
@@ -874,7 +875,9 @@ int ide_release_dma(ide_hwif_t *hwif)
 
 static int ide_allocate_dma_engine(ide_hwif_t *hwif)
 {
-	hwif->dmatable_cpu = pci_alloc_consistent(hwif->pci_dev,
+	struct pci_dev *pdev = to_pci_dev(hwif->dev);
+
+	hwif->dmatable_cpu = pci_alloc_consistent(pdev,
 						  PRD_ENTRIES * PRD_BYTES,
 						  &hwif->dmatable_dma);
 

commit f6fb786d6dcdd7d730e4fba620b071796f487e1b
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Feb 1 23:09:31 2008 +0100

    ide: use ide_destroy_dmatable() instead of pci_unmap_sg() (take 2)
    
    Use ide_destroy_dmatable() in:
    * ide-dma.c::ide_build_dmatable()
    * sgiioc4.c::sgiioc4_build_dma_table()
    * pmac.c::pmac_ide_{build,destroy}_dmatable()
    
    There should be no functionality changes caused by this patch.
    
    v2:
    * pmac.c build fix from Andrew Morton.
    
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 7d361da8ceb2..1ca1210ec1c0 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -282,12 +282,12 @@ int ide_build_dmatable (ide_drive_t *drive, struct request *rq)
 			*--table |= cpu_to_le32(0x80000000);
 		return count;
 	}
+
 	printk(KERN_ERR "%s: empty DMA table?\n", drive->name);
+
 use_pio_instead:
-	pci_unmap_sg(hwif->pci_dev,
-		     hwif->sg_table,
-		     hwif->sg_nents,
-		     hwif->sg_dma_direction);
+	ide_destroy_dmatable(drive);
+
 	return 0; /* revert to PIO for this request */
 }
 

commit fcc1175947510d7d7dc82d5c1b8315cb8fcb96ca
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Feb 1 23:09:31 2008 +0100

    ide: remove BUG_ON() from ide_build_sglist()
    
    do_rw_taskfile() has been fixed to check the return value
    of ->dma_setup method so this BUG_ON() is no longer needed.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 51c86bc241ac..7d361da8ceb2 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -186,8 +186,6 @@ int ide_build_sglist(ide_drive_t *drive, struct request *rq)
 	ide_hwif_t *hwif = HWIF(drive);
 	struct scatterlist *sg = hwif->sg_table;
 
-	BUG_ON((rq->cmd_type == REQ_TYPE_ATA_TASKFILE) && rq->nr_sectors > 256);
-
 	ide_map_sg(drive, rq);
 
 	if (rq_data_dir(rq) == READ)

commit ecf32796395ed0e27667e7f735946d6dc60e1765
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Fri Feb 1 23:09:30 2008 +0100

    ide: ide_setup_dma() assumes 8 ports
    
    According to http://marc.info/?l=linux-ide&m=114346138611631, the drivers must
    always register 8 DMA ports with ide_setup_dma(), so its last argument is not
    needed. While at it, kill some useless parens in that function...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 8d668a80adb3..51c86bc241ac 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -889,19 +889,19 @@ static int ide_allocate_dma_engine(ide_hwif_t *hwif)
 	return 1;
 }
 
-static int ide_mapped_mmio_dma(ide_hwif_t *hwif, unsigned long base, unsigned int ports)
+static int ide_mapped_mmio_dma(ide_hwif_t *hwif, unsigned long base)
 {
 	printk(KERN_INFO "    %s: MMIO-DMA ", hwif->name);
 
 	return 0;
 }
 
-static int ide_iomio_dma(ide_hwif_t *hwif, unsigned long base, unsigned int ports)
+static int ide_iomio_dma(ide_hwif_t *hwif, unsigned long base)
 {
 	printk(KERN_INFO "    %s: BM-DMA at 0x%04lx-0x%04lx",
-	       hwif->name, base, base + ports - 1);
+	       hwif->name, base, base + 7);
 
-	if (!request_region(base, ports, hwif->name)) {
+	if (!request_region(base, 8, hwif->name)) {
 		printk(" -- Error, ports in use.\n");
 		return 1;
 	}
@@ -913,7 +913,7 @@ static int ide_iomio_dma(ide_hwif_t *hwif, unsigned long base, unsigned int port
 			if (!request_region(hwif->extra_base,
 					    hwif->cds->extra, hwif->cds->name)) {
 				printk(" -- Error, extra ports in use.\n");
-				release_region(base, ports);
+				release_region(base, 8);
 				return 1;
 			}
 			hwif->extra_ports = hwif->cds->extra;
@@ -923,19 +923,19 @@ static int ide_iomio_dma(ide_hwif_t *hwif, unsigned long base, unsigned int port
 	return 0;
 }
 
-static int ide_dma_iobase(ide_hwif_t *hwif, unsigned long base, unsigned int ports)
+static int ide_dma_iobase(ide_hwif_t *hwif, unsigned long base)
 {
 	if (hwif->mmio)
-		return ide_mapped_mmio_dma(hwif, base,ports);
+		return ide_mapped_mmio_dma(hwif, base);
 
-	return ide_iomio_dma(hwif, base, ports);
+	return ide_iomio_dma(hwif, base);
 }
 
-void ide_setup_dma(ide_hwif_t *hwif, unsigned long base, unsigned num_ports)
+void ide_setup_dma(ide_hwif_t *hwif, unsigned long base)
 {
 	u8 dma_stat;
 
-	if (ide_dma_iobase(hwif, base, num_ports))
+	if (ide_dma_iobase(hwif, base))
 		return;
 
 	if (ide_allocate_dma_engine(hwif)) {
@@ -945,16 +945,16 @@ void ide_setup_dma(ide_hwif_t *hwif, unsigned long base, unsigned num_ports)
 
 	hwif->dma_base = base;
 
-	if (!(hwif->dma_command))
-		hwif->dma_command	= hwif->dma_base;
-	if (!(hwif->dma_vendor1))
-		hwif->dma_vendor1	= (hwif->dma_base + 1);
-	if (!(hwif->dma_status))
-		hwif->dma_status	= (hwif->dma_base + 2);
-	if (!(hwif->dma_vendor3))
-		hwif->dma_vendor3	= (hwif->dma_base + 3);
-	if (!(hwif->dma_prdtable))
-		hwif->dma_prdtable	= (hwif->dma_base + 4);
+	if (!hwif->dma_command)
+		hwif->dma_command	= hwif->dma_base + 0;
+	if (!hwif->dma_vendor1)
+		hwif->dma_vendor1	= hwif->dma_base + 1;
+	if (!hwif->dma_status)
+		hwif->dma_status	= hwif->dma_base + 2;
+	if (!hwif->dma_vendor3)
+		hwif->dma_vendor3	= hwif->dma_base + 3;
+	if (!hwif->dma_prdtable)
+		hwif->dma_prdtable	= hwif->dma_base + 4;
 
 	if (!hwif->dma_host_set)
 		hwif->dma_host_set = &ide_dma_host_set;

commit 4e5a68aeb6b513ee0adda11642e10e528b7721c0
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Fri Feb 1 23:09:29 2008 +0100

    trm290: cannot call ide_setup_dma()
    
    The TRM-290 chip is *not* SFF-8038i compatible and therefore can *not* call
    ide_setup_dma() -- fix this and also cleanup the code a bit...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 15f8c6abe429..8d668a80adb3 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -933,6 +933,8 @@ static int ide_dma_iobase(ide_hwif_t *hwif, unsigned long base, unsigned int por
 
 void ide_setup_dma(ide_hwif_t *hwif, unsigned long base, unsigned num_ports)
 {
+	u8 dma_stat;
+
 	if (ide_dma_iobase(hwif, base, num_ports))
 		return;
 
@@ -971,13 +973,10 @@ void ide_setup_dma(ide_hwif_t *hwif, unsigned long base, unsigned num_ports)
 	if (!hwif->dma_lost_irq)
 		hwif->dma_lost_irq = &ide_dma_lost_irq;
 
-	if (hwif->chipset != ide_trm290) {
-		u8 dma_stat = hwif->INB(hwif->dma_status);
-		printk(", BIOS settings: %s:%s, %s:%s",
-		       hwif->drives[0].name, (dma_stat & 0x20) ? "DMA" : "pio",
-		       hwif->drives[1].name, (dma_stat & 0x40) ? "DMA" : "pio");
-	}
-	printk("\n");
+	dma_stat = hwif->INB(hwif->dma_status);
+	printk(KERN_CONT ", BIOS settings: %s:%s, %s:%s\n",
+	       hwif->drives[0].name, (dma_stat & 0x20) ? "DMA" : "PIO",
+	       hwif->drives[1].name, (dma_stat & 0x40) ? "DMA" : "PIO");
 }
 
 EXPORT_SYMBOL_GPL(ide_setup_dma);

commit a4b5a4d91d6555df56489094cd5846cd03fc9239
Author: Adrian Bunk <bunk@kernel.org>
Date:   Fri Feb 1 23:09:16 2008 +0100

    ide: unexport ide_dma_on
    
    ide_dma_on can be unexported.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 5bf32038dc43..15f8c6abe429 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -474,8 +474,6 @@ void ide_dma_on(ide_drive_t *drive)
 	drive->hwif->dma_host_set(drive, 1);
 }
 
-EXPORT_SYMBOL(ide_dma_on);
-
 #ifdef CONFIG_BLK_DEV_IDEDMA_PCI
 /**
  *	ide_dma_setup	-	begin a DMA phase

commit 4d7a984bdcbdda69fc6b2a4a655415140270aa7b
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Jan 26 20:13:11 2008 +0100

    ide: task_end_request() fix
    
    task_end_request() modified to always call ide_end_drive_cmd()
    for taskfile requests.  Previously, ide_end_drive_cmd() was
    called only when IDE_TFLAG_FLAGGED was set.  Also,
    ide_dma_intr() is modified to use task_end_request().
    
    Enables TASKFILE ioctls to get valid register outputs on
    successful completion.
    
    Bart:
    - ported it over recent IDE changes
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index c9648b1ef220..5bf32038dc43 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -153,13 +153,7 @@ ide_startstop_t ide_dma_intr (ide_drive_t *drive)
 		if (!dma_stat) {
 			struct request *rq = HWGROUP(drive)->rq;
 
-			if (rq->rq_disk) {
-				ide_driver_t *drv;
-
-				drv = *(ide_driver_t **)rq->rq_disk->private_data;
-				drv->end_request(drive, 1, rq->nr_sectors);
-			} else
-				ide_end_request(drive, 1, rq->nr_sectors);
+			task_end_request(drive, rq, stat);
 			return ide_stopped;
 		}
 		printk(KERN_ERR "%s: dma_intr: bad DMA status (dma_stat=%x)\n", 

commit 15ce926ada545cb078711bd9a18c083c93fa01d7
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Jan 26 20:13:03 2008 +0100

    ide: merge ->dma_host_{on,off} methods into ->dma_host_set method
    
    Merge ->dma_host_{on,off} methods into ->dma_host_set method
    which takes 'int on' argument.
    
    There should be no functionality changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 780911e0537e..c9648b1ef220 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -408,23 +408,28 @@ static int dma_timer_expiry (ide_drive_t *drive)
 }
 
 /**
- *	ide_dma_host_off	-	Generic DMA kill
+ *	ide_dma_host_set	-	Enable/disable DMA on a host
  *	@drive: drive to control
  *
- *	Perform the generic IDE controller DMA off operation. This
- *	works for most IDE bus mastering controllers
+ *	Enable/disable DMA on an IDE controller following generic
+ *	bus-mastering IDE controller behaviour.
  */
 
-void ide_dma_host_off(ide_drive_t *drive)
+void ide_dma_host_set(ide_drive_t *drive, int on)
 {
 	ide_hwif_t *hwif	= HWIF(drive);
 	u8 unit			= (drive->select.b.unit & 0x01);
 	u8 dma_stat		= hwif->INB(hwif->dma_status);
 
-	hwif->OUTB((dma_stat & ~(1<<(5+unit))), hwif->dma_status);
+	if (on)
+		dma_stat |= (1 << (5 + unit));
+	else
+		dma_stat &= ~(1 << (5 + unit));
+
+	hwif->OUTB(dma_stat, hwif->dma_status);
 }
 
-EXPORT_SYMBOL(ide_dma_host_off);
+EXPORT_SYMBOL_GPL(ide_dma_host_set);
 #endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
 
 /**
@@ -439,7 +444,7 @@ void ide_dma_off_quietly(ide_drive_t *drive)
 	drive->using_dma = 0;
 	ide_toggle_bounce(drive, 0);
 
-	drive->hwif->dma_host_off(drive);
+	drive->hwif->dma_host_set(drive, 0);
 }
 
 EXPORT_SYMBOL(ide_dma_off_quietly);
@@ -460,29 +465,6 @@ void ide_dma_off(ide_drive_t *drive)
 
 EXPORT_SYMBOL(ide_dma_off);
 
-#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
-/**
- *	ide_dma_host_on	-	Enable DMA on a host
- *	@drive: drive to enable for DMA
- *
- *	Enable DMA on an IDE controller following generic bus mastering
- *	IDE controller behaviour
- */
-
-void ide_dma_host_on(ide_drive_t *drive)
-{
-	if (1) {
-		ide_hwif_t *hwif	= HWIF(drive);
-		u8 unit			= (drive->select.b.unit & 0x01);
-		u8 dma_stat		= hwif->INB(hwif->dma_status);
-
-		hwif->OUTB((dma_stat|(1<<(5+unit))), hwif->dma_status);
-	}
-}
-
-EXPORT_SYMBOL(ide_dma_host_on);
-#endif
-
 /**
  *	ide_dma_on		-	Enable DMA on a device
  *	@drive: drive to enable DMA on
@@ -495,7 +477,7 @@ void ide_dma_on(ide_drive_t *drive)
 	drive->using_dma = 1;
 	ide_toggle_bounce(drive, 1);
 
-	drive->hwif->dma_host_on(drive);
+	drive->hwif->dma_host_set(drive, 1);
 }
 
 EXPORT_SYMBOL(ide_dma_on);
@@ -980,10 +962,8 @@ void ide_setup_dma(ide_hwif_t *hwif, unsigned long base, unsigned num_ports)
 	if (!(hwif->dma_prdtable))
 		hwif->dma_prdtable	= (hwif->dma_base + 4);
 
-	if (!hwif->dma_host_off)
-		hwif->dma_host_off = &ide_dma_host_off;
-	if (!hwif->dma_host_on)
-		hwif->dma_host_on = &ide_dma_host_on;
+	if (!hwif->dma_host_set)
+		hwif->dma_host_set = &ide_dma_host_set;
 	if (!hwif->dma_setup)
 		hwif->dma_setup = &ide_dma_setup;
 	if (!hwif->dma_exec_cmd)

commit f37aaf9edeba3f4ae10d22aefc09c06af9ea39b6
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Jan 26 20:13:02 2008 +0100

    ide: move drive->using_dma check to callers of ->dma_host_on method
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index edd0018c4988..780911e0537e 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -471,7 +471,7 @@ EXPORT_SYMBOL(ide_dma_off);
 
 void ide_dma_host_on(ide_drive_t *drive)
 {
-	if (drive->using_dma) {
+	if (1) {
 		ide_hwif_t *hwif	= HWIF(drive);
 		u8 unit			= (drive->select.b.unit & 0x01);
 		u8 dma_stat		= hwif->INB(hwif->dma_status);

commit 4a546e046d562bcd389149591fa5a534c8f832ca
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Jan 26 20:13:01 2008 +0100

    ide: remove ->ide_dma_on and ->dma_off_quietly methods from ide_hwif_t
    
    * Make ide_dma_off_quietly() and __ide_dma_on() always available.
    
    * Drop "__" prefix from __ide_dma_on().
    
    * Check for presence of ->dma_host_on instead of ->ide_dma_on.
    
    * Convert all users of ->ide_dma_on and ->dma_off_quietly methods
      to use ide_dma_on() and ide_dma_off_quietly() instead.
    
    * Remove no longer needed ->ide_dma_on and ->dma_off_quietly methods
      from ide_hwif_t.
    
    * Make ide_dma_on() void.
    
    There should be no functionality changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 9d6dabbbf809..edd0018c4988 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -425,6 +425,7 @@ void ide_dma_host_off(ide_drive_t *drive)
 }
 
 EXPORT_SYMBOL(ide_dma_host_off);
+#endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
 
 /**
  *	ide_dma_off_quietly	-	Generic DMA kill
@@ -442,7 +443,6 @@ void ide_dma_off_quietly(ide_drive_t *drive)
 }
 
 EXPORT_SYMBOL(ide_dma_off_quietly);
-#endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
 
 /**
  *	ide_dma_off	-	disable DMA on a device
@@ -455,7 +455,7 @@ EXPORT_SYMBOL(ide_dma_off_quietly);
 void ide_dma_off(ide_drive_t *drive)
 {
 	printk(KERN_INFO "%s: DMA disabled\n", drive->name);
-	drive->hwif->dma_off_quietly(drive);
+	ide_dma_off_quietly(drive);
 }
 
 EXPORT_SYMBOL(ide_dma_off);
@@ -481,26 +481,26 @@ void ide_dma_host_on(ide_drive_t *drive)
 }
 
 EXPORT_SYMBOL(ide_dma_host_on);
+#endif
 
 /**
- *	__ide_dma_on		-	Enable DMA on a device
+ *	ide_dma_on		-	Enable DMA on a device
  *	@drive: drive to enable DMA on
  *
  *	Enable IDE DMA for a device on this IDE controller.
  */
- 
-int __ide_dma_on (ide_drive_t *drive)
+
+void ide_dma_on(ide_drive_t *drive)
 {
 	drive->using_dma = 1;
 	ide_toggle_bounce(drive, 1);
 
 	drive->hwif->dma_host_on(drive);
-
-	return 0;
 }
 
-EXPORT_SYMBOL(__ide_dma_on);
+EXPORT_SYMBOL(ide_dma_on);
 
+#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
 /**
  *	ide_dma_setup	-	begin a DMA phase
  *	@drive: target device
@@ -827,7 +827,6 @@ int ide_id_dma_bug(ide_drive_t *drive)
 
 int ide_set_dma(ide_drive_t *drive)
 {
-	ide_hwif_t *hwif = drive->hwif;
 	int rc;
 
 	/*
@@ -836,13 +835,15 @@ int ide_set_dma(ide_drive_t *drive)
 	 * things, if not checked and cleared.
 	 *   PARANOIA!!!
 	 */
-	hwif->dma_off_quietly(drive);
+	ide_dma_off_quietly(drive);
 
 	rc = ide_dma_check(drive);
 	if (rc)
 		return rc;
 
-	return hwif->ide_dma_on(drive);
+	ide_dma_on(drive);
+
+	return 0;
 }
 
 #ifdef CONFIG_BLK_DEV_IDEDMA_PCI
@@ -979,12 +980,8 @@ void ide_setup_dma(ide_hwif_t *hwif, unsigned long base, unsigned num_ports)
 	if (!(hwif->dma_prdtable))
 		hwif->dma_prdtable	= (hwif->dma_base + 4);
 
-	if (!hwif->dma_off_quietly)
-		hwif->dma_off_quietly = &ide_dma_off_quietly;
 	if (!hwif->dma_host_off)
 		hwif->dma_host_off = &ide_dma_host_off;
-	if (!hwif->ide_dma_on)
-		hwif->ide_dma_on = &__ide_dma_on;
 	if (!hwif->dma_host_on)
 		hwif->dma_host_on = &ide_dma_host_on;
 	if (!hwif->dma_setup)

commit 8704de8f296fcf6a4b2ff6bfd9a63974ad909b3e
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Jan 26 20:13:00 2008 +0100

    cy82c693: add ->set_dma_mode method
    
    * Fix SWDMA/MWDMA masks in cy82c693_chipset.
    
    * Add IDE_HFLAG_CY82C693 host flag and use it in ide_tune_dma() to
      check whether the DMA should be enabled even if ide_max_dma_mode()
      fails.
    
    * Convert cy82c693_dma_enable() to become cy82c693_set_dma_mode()
      and remove no longer needed cy82c693_ide_dma_on().  Then set
      IDE_HFLAG_CY82C693 instead of IDE_HFLAG_TRUST_BIOS_FOR_DMA in
      cy82c693_chipset.
    
    * Bump driver version.
    
    As a result of this patch cy82c693 driver will configure and use DMA on
    all SWDMA0-2 and MWDMA0-2 capable ATA devices instead of relying on BIOS.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 18c78ad2b31e..9d6dabbbf809 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -755,6 +755,7 @@ EXPORT_SYMBOL_GPL(ide_find_dma_mode);
 
 static int ide_tune_dma(ide_drive_t *drive)
 {
+	ide_hwif_t *hwif = drive->hwif;
 	u8 speed;
 
 	if (noautodma || drive->nodma || (drive->id->capability & 1) == 0)
@@ -767,15 +768,21 @@ static int ide_tune_dma(ide_drive_t *drive)
 	if (ide_id_dma_bug(drive))
 		return 0;
 
-	if (drive->hwif->host_flags & IDE_HFLAG_TRUST_BIOS_FOR_DMA)
+	if (hwif->host_flags & IDE_HFLAG_TRUST_BIOS_FOR_DMA)
 		return config_drive_for_dma(drive);
 
 	speed = ide_max_dma_mode(drive);
 
-	if (!speed)
-		return 0;
+	if (!speed) {
+		 /* is this really correct/needed? */
+		if ((hwif->host_flags & IDE_HFLAG_CY82C693) &&
+		    ide_dma_good_drive(drive))
+			return 1;
+		else
+			return 0;
+	}
 
-	if (drive->hwif->host_flags & IDE_HFLAG_NO_SET_MODE)
+	if (hwif->host_flags & IDE_HFLAG_NO_SET_MODE)
 		return 0;
 
 	if (ide_set_dma_mode(drive, speed))

commit 61a368c216897aa3bbee35b3f2e6db76ec73fad0
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jan 25 22:17:19 2008 +0100

    ide: remove redundant DMA blacklist check from __ide_dma_on()
    
    ->ide_dma_on method is called only after successful ide_dma_check() call
    (ide_dma_check()->ide_tune_dma() checks DMA blacklist) or if drive->using_dma
    has been previously enabled for a given device (->ide_dma_on is the only place
    which sets drive->using_dma to '1').
    
    There should be no functionality changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 01036305d6fc..18c78ad2b31e 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -491,10 +491,6 @@ EXPORT_SYMBOL(ide_dma_host_on);
  
 int __ide_dma_on (ide_drive_t *drive)
 {
-	/* consult the list of known "bad" drives */
-	if (__ide_dma_bad_drive(drive))
-		return 1;
-
 	drive->using_dma = 1;
 	ide_toggle_bounce(drive, 1);
 

commit 7b905994ce0bd332afc5ebc30ce9afa60d23c6e2
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jan 25 22:17:19 2008 +0100

    ide: cleanup ide_set_dma()
    
    * ->dma_off_quietly is always called before ide_set_dma()
      so the call can be moved inside ide_set_dma().
    
    * ide_dma_check() doesn't touch hardware so ->dma_off_quietly
      call for 'rc == -1' case is redundant, remove it.
    
    * '0' and '-1' are the only values returned by ide_dma_check()
      so remove dead code for other cases.
    
    There should be no functionality changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 7568c3e81f2f..01036305d6fc 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -827,22 +827,19 @@ int ide_set_dma(ide_drive_t *drive)
 	ide_hwif_t *hwif = drive->hwif;
 	int rc;
 
-	rc = ide_dma_check(drive);
+	/*
+	 * Force DMAing for the beginning of the check.
+	 * Some chipsets appear to do interesting
+	 * things, if not checked and cleared.
+	 *   PARANOIA!!!
+	 */
+	hwif->dma_off_quietly(drive);
 
-	switch(rc) {
-	case -1: /* DMA needs to be disabled */
-		hwif->dma_off_quietly(drive);
-		return -1;
-	case  0: /* DMA needs to be enabled */
-		return hwif->ide_dma_on(drive);
-	case  1: /* DMA setting cannot be changed */
-		break;
-	default:
-		BUG();
-		break;
-	}
+	rc = ide_dma_check(drive);
+	if (rc)
+		return rc;
 
-	return rc;
+	return hwif->ide_dma_on(drive);
 }
 
 #ifdef CONFIG_BLK_DEV_IDEDMA_PCI

commit 1c029fd658baa2442e8e51dc9c819301cad95777
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jan 25 22:17:05 2008 +0100

    ide: remove ->dma_master field from ide_hwif_t (take 5)
    
    * Convert cmd64x, hpt366 and pdc202xx_old host drivers to use
      pci_resource_start(hwif->pci_dev, 4) instead of hwif->dma_master.
    
    * Remove no longer needed ->dma_master field from ide_hwif_t.
    
    v2:
    * Use the more readable 'hwif->dma_base - (hwif->channel * 8)' instead of
      pci_resource_start(hwif->pci_dev, 4).
    
    v3:
    * Use hwif->extra_base in hpt366/pdc20xx_old + some cosmetic fixups over v2
      (suggested by Sergei).
    
    v4:
    * Correct offsets in hpt3xxn_set_clock().
    
    v5:
    * Use hwif->extra_base in hpt366 for _real_ this time. (Noticed by Sergei)
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 4703837bf1fc..7568c3e81f2f 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -968,11 +968,6 @@ void ide_setup_dma(ide_hwif_t *hwif, unsigned long base, unsigned num_ports)
 
 	hwif->dma_base = base;
 
-	if (hwif->mate)
-		hwif->dma_master = hwif->channel ? hwif->mate->dma_base : base;
-	else
-		hwif->dma_master = base;
-
 	if (!(hwif->dma_command))
 		hwif->dma_command	= hwif->dma_base;
 	if (!(hwif->dma_vendor1))
@@ -1014,8 +1009,6 @@ void ide_setup_dma(ide_hwif_t *hwif, unsigned long base, unsigned num_ports)
 		       hwif->drives[1].name, (dma_stat & 0x40) ? "DMA" : "pio");
 	}
 	printk("\n");
-
-	BUG_ON(!hwif->dma_master);
 }
 
 EXPORT_SYMBOL_GPL(ide_setup_dma);

commit 3f3e6e21845259854d862bfa3c39f6a84356fc3d
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Dec 12 23:32:00 2007 +0100

    ide: remove dead code from __ide_dma_test_irq()
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 6879aaae544d..4703837bf1fc 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -611,12 +611,6 @@ static int __ide_dma_test_irq(ide_drive_t *drive)
 	ide_hwif_t *hwif	= HWIF(drive);
 	u8 dma_stat		= hwif->INB(hwif->dma_status);
 
-#if 0  /* do not set unless you know what you are doing */
-	if (dma_stat & 4) {
-		u8 stat = hwif->INB(IDE_STATUS_REG);
-		hwif->OUTB(hwif->dma_status, dma_stat & 0xE4);
-	}
-#endif
 	/* return 1 if INTR asserted */
 	if ((dma_stat & 4) == 4)
 		return 1;

commit 3ab7efe8e2cbcca2d401b43cfcc2fa9a7dac2299
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Dec 12 23:31:58 2007 +0100

    ide: DMA reporting and validity checking fixes (take 3)
    
    * ide_xfer_verbose() fixups:
      - beautify returned mode names
      - fix PIO5 reporting
      - make it return 'const char *'
    
    * Change printk() level from KERN_DEBUG to KERN_INFO in ide_find_dma_mode().
    
    * Add ide_id_dma_bug() helper based on ide_dma_verbose() to check for invalid
      DMA info in identify block.
    
    * Use ide_id_dma_bug() in ide_tune_dma() and ide_driveid_update().
    
      As a result DMA won't be tuned or will be disabled after tuning if device
      reports inconsistent info about enabled DMA mode (ide_dma_verbose() does the
      same checks while the IDE device is probed by ide-{cd,disk} device driver).
    
    * Remove no longer needed ide_dma_verbose().
    
    This patch should fix the following problem with out-of-sync IDE messages
    reported by Nick Warne:
    
           hdd: ATAPI 48X DVD-ROM DVD-R-RAM CD-R/RW drive, 2048kB Cache<7>hdd:
           skipping word 93 validity check
            , UDMA(66)
    
    and later debugged by Mark Lord to be caused by:
    
            ide_dma_verbose()
                    printk( ... "2048kB Cache");
            eighty_ninty_three()
                    printk(KERN_DEBUG "%s: skipping word 93 validity check\n");
            ide_dma_verbose()
                    printk(", UDMA(66)"
    
    Please note that as a result ide-{cd,disk} device drivers won't report the
    DMA speed used but this is intended since now DMA mode being used is always
    reported by IDE core code.
    
    v2:
    * fixes suggested by Randy:
      - use KERN_CONT for printk()-s in ide-{cd,disk}.c
      - don't remove argument name from ide_xfer_verbose() declaration
    
    v3:
    * Remove incorrect check for (id->field_valid & 1) from ide_id_dma_bug()
      (spotted by Sergei).
    
    * "XFER SLOW" -> "PIO SLOW" in ide_xfer_verbose() (suggested by Sergei).
    
    * Fix ide_find_dma_mode() to report the correct mode ('mode' after being
      limited by 'req_mode').
    
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: Nick Warne <nick@ukfsn.org>
    Cc: Mark Lord <lkml@rtr.ca>
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 0d795a1678c7..6879aaae544d 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -753,10 +753,12 @@ u8 ide_find_dma_mode(ide_drive_t *drive, u8 req_mode)
 			mode = XFER_MW_DMA_1;
 	}
 
-	printk(KERN_DEBUG "%s: %s mode selected\n", drive->name,
+	mode = min(mode, req_mode);
+
+	printk(KERN_INFO "%s: %s mode selected\n", drive->name,
 			  mode ? ide_xfer_verbose(mode) : "no DMA");
 
-	return min(mode, req_mode);
+	return mode;
 }
 
 EXPORT_SYMBOL_GPL(ide_find_dma_mode);
@@ -772,6 +774,9 @@ static int ide_tune_dma(ide_drive_t *drive)
 	if (__ide_dma_bad_drive(drive))
 		return 0;
 
+	if (ide_id_dma_bug(drive))
+		return 0;
+
 	if (drive->hwif->host_flags & IDE_HFLAG_TRUST_BIOS_FOR_DMA)
 		return config_drive_for_dma(drive);
 
@@ -806,58 +811,23 @@ static int ide_dma_check(ide_drive_t *drive)
 	return vdma ? 0 : -1;
 }
 
-void ide_dma_verbose(ide_drive_t *drive)
+int ide_id_dma_bug(ide_drive_t *drive)
 {
-	struct hd_driveid *id	= drive->id;
-	ide_hwif_t *hwif	= HWIF(drive);
+	struct hd_driveid *id = drive->id;
 
 	if (id->field_valid & 4) {
 		if ((id->dma_ultra >> 8) && (id->dma_mword >> 8))
-			goto bug_dma_off;
-		if (id->dma_ultra & ((id->dma_ultra >> 8) & hwif->ultra_mask)) {
-			if (((id->dma_ultra >> 11) & 0x1F) &&
-			    eighty_ninty_three(drive)) {
-				if ((id->dma_ultra >> 15) & 1) {
-					printk(", UDMA(mode 7)");
-				} else if ((id->dma_ultra >> 14) & 1) {
-					printk(", UDMA(133)");
-				} else if ((id->dma_ultra >> 13) & 1) {
-					printk(", UDMA(100)");
-				} else if ((id->dma_ultra >> 12) & 1) {
-					printk(", UDMA(66)");
-				} else if ((id->dma_ultra >> 11) & 1) {
-					printk(", UDMA(44)");
-				} else
-					goto mode_two;
-			} else {
-		mode_two:
-				if ((id->dma_ultra >> 10) & 1) {
-					printk(", UDMA(33)");
-				} else if ((id->dma_ultra >> 9) & 1) {
-					printk(", UDMA(25)");
-				} else if ((id->dma_ultra >> 8) & 1) {
-					printk(", UDMA(16)");
-				}
-			}
-		} else {
-			printk(", (U)DMA");	/* Can be BIOS-enabled! */
-		}
+			goto err_out;
 	} else if (id->field_valid & 2) {
 		if ((id->dma_mword >> 8) && (id->dma_1word >> 8))
-			goto bug_dma_off;
-		printk(", DMA");
-	} else if (id->field_valid & 1) {
-		goto bug_dma_off;
+			goto err_out;
 	}
-	return;
-bug_dma_off:
-	printk(", BUG DMA OFF");
-	hwif->dma_off_quietly(drive);
-	return;
+	return 0;
+err_out:
+	printk(KERN_ERR "%s: bad DMA info in identify block\n", drive->name);
+	return 1;
 }
 
-EXPORT_SYMBOL(ide_dma_verbose);
-
 int ide_set_dma(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = drive->hwif;

commit b0bc65b9aa7d9eb8af4895ed772ef7fe2c10687c
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Nov 27 21:35:56 2007 +0100

    ide: add TORiSAN model: CD-ROM CDR_U200 fw: 1.09 to DMA blacklist
    
    Based on the report from snowbat@gmail.com.
    
    Fixes kernel bugzilla bug #9195.
    
    Tested-by: snowbat@gmail.com
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index e3add70b9cd8..0d795a1678c7 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -130,6 +130,7 @@ static const struct drive_list_entry drive_blacklist [] = {
 	{ "_NEC DV5800A",               NULL            },
 	{ "SAMSUNG CD-ROM SN-124",	"N001" },
 	{ "Seagate STT20000A",		NULL  },
+	{ "CD-ROM CDR_U200",		"1.09" },
 	{ NULL			,	NULL		}
 
 };

commit bcbf6ee3eb5212ff774161cae15ce4f92f7edafb
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Nov 5 21:42:30 2007 +0100

    ide: fix IDE_HFLAG_NO_ATAPI_DMA handling in config_drive_for_dma()
    
    commit 33c1002ed912ac9dacedd5d5b166da3b72d18460 incorrectly changed return
    value from '0' to '-1', fix it (ns87415 was the only host driver affected
    since it uses both IDE_HFLAG_TRUST_BIOS_FOR_DMA and IDE_HFLAG_NO_ATAPI_DMA).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 202d56a8ead2..e3add70b9cd8 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -340,7 +340,7 @@ static int config_drive_for_dma (ide_drive_t *drive)
 
 	if (drive->media != ide_disk) {
 		if (hwif->host_flags & IDE_HFLAG_NO_ATAPI_DMA)
-			return -1;
+			return 0;
 	}
 
 	/*

commit d34887da6be91eaac1db168fa48d91eaa4504795
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Nov 5 21:42:27 2007 +0100

    ide: fix ide_find_dma_mode() to print human-readable info
    
    Problem reported by Mikael.
    
    Cc: Mikael Pettersson <mikpe@it.uu.se>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 428f7a8a00b6..202d56a8ead2 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -752,7 +752,8 @@ u8 ide_find_dma_mode(ide_drive_t *drive, u8 req_mode)
 			mode = XFER_MW_DMA_1;
 	}
 
-	printk(KERN_DEBUG "%s: selected mode 0x%x\n", drive->name, mode);
+	printk(KERN_DEBUG "%s: %s mode selected\n", drive->name,
+			  mode ? ide_xfer_verbose(mode) : "no DMA");
 
 	return min(mode, req_mode);
 }

commit a02bfd3ce9342453441202028df44dc58f90e225
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Oct 20 00:32:37 2007 +0200

    ide: PCI BMDMA initialization fixes (take 2)
    
    * Set hwif->dma_base only if allocation of extra ports succeeds.
    
    While at it:
    
    * Move setting of hwif->dma_{base,master} from ide_{mapped_mmio,iomio}_dma()
      to ide_setup_dma().
    
    * Rename 'dma_base' argument to 'base' in ide_setup_dma() (to make the code
      obey 80-columns limit and increase its readability).
    
    * Remove stale ide_setup_dma() comment.
    
    v2:
    * Change to allocate hwif->dmatable_cpu before reserving I/O ports missed
      teardown code (spotted by Sergei).  On the second thought this change is
      actually unnecessary so revert it in v2.
    
    * Make ide_release_dma_engine() void and remove needless comment.
    
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 80b4f17f3941..428f7a8a00b6 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -901,10 +901,7 @@ void ide_dma_timeout (ide_drive_t *drive)
 
 EXPORT_SYMBOL(ide_dma_timeout);
 
-/*
- * Needed for allowing full modular support of ide-driver
- */
-static int ide_release_dma_engine(ide_hwif_t *hwif)
+static void ide_release_dma_engine(ide_hwif_t *hwif)
 {
 	if (hwif->dmatable_cpu) {
 		pci_free_consistent(hwif->pci_dev,
@@ -913,7 +910,6 @@ static int ide_release_dma_engine(ide_hwif_t *hwif)
 				    hwif->dmatable_dma);
 		hwif->dmatable_cpu = NULL;
 	}
-	return 1;
 }
 
 static int ide_release_iomio_dma(ide_hwif_t *hwif)
@@ -956,12 +952,6 @@ static int ide_mapped_mmio_dma(ide_hwif_t *hwif, unsigned long base, unsigned in
 {
 	printk(KERN_INFO "    %s: MMIO-DMA ", hwif->name);
 
- 	hwif->dma_base = base;
-
-	if(hwif->mate)
-		hwif->dma_master = (hwif->channel) ? hwif->mate->dma_base : base;
-	else
-		hwif->dma_master = base;
 	return 0;
 }
 
@@ -975,8 +965,6 @@ static int ide_iomio_dma(ide_hwif_t *hwif, unsigned long base, unsigned int port
 		return 1;
 	}
 
-	hwif->dma_base = base;
-
 	if (hwif->cds->extra) {
 		hwif->extra_base = base + (hwif->channel ? 8 : 16);
 
@@ -991,10 +979,6 @@ static int ide_iomio_dma(ide_hwif_t *hwif, unsigned long base, unsigned int port
 		}
 	}
 
-	if(hwif->mate)
-		hwif->dma_master = (hwif->channel) ? hwif->mate->dma_base:base;
-	else
-		hwif->dma_master = base;
 	return 0;
 }
 
@@ -1006,12 +990,9 @@ static int ide_dma_iobase(ide_hwif_t *hwif, unsigned long base, unsigned int por
 	return ide_iomio_dma(hwif, base, ports);
 }
 
-/*
- * This can be called for a dynamically installed interface. Don't __init it
- */
-void ide_setup_dma (ide_hwif_t *hwif, unsigned long dma_base, unsigned int num_ports)
+void ide_setup_dma(ide_hwif_t *hwif, unsigned long base, unsigned num_ports)
 {
-	if (ide_dma_iobase(hwif, dma_base, num_ports))
+	if (ide_dma_iobase(hwif, base, num_ports))
 		return;
 
 	if (ide_allocate_dma_engine(hwif)) {
@@ -1019,6 +1000,13 @@ void ide_setup_dma (ide_hwif_t *hwif, unsigned long dma_base, unsigned int num_p
 		return;
 	}
 
+	hwif->dma_base = base;
+
+	if (hwif->mate)
+		hwif->dma_master = hwif->channel ? hwif->mate->dma_base : base;
+	else
+		hwif->dma_master = base;
+
 	if (!(hwif->dma_command))
 		hwif->dma_command	= hwif->dma_base;
 	if (!(hwif->dma_vendor1))

commit 33c1002ed912ac9dacedd5d5b166da3b72d18460
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 19 00:30:06 2007 +0200

    ide: add IDE_HFLAG_NO_ATAPI_DMA host flag
    
    Add IDE_HFLAG_NO_ATAPI_DMA host flag and set it in host drivers which
    don't support ATAPI DMA.  Then remove no longer needed hwif->atapi_dma.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index bc57ce6bf0b3..80b4f17f3941 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -338,8 +338,10 @@ static int config_drive_for_dma (ide_drive_t *drive)
 	ide_hwif_t *hwif = drive->hwif;
 	struct hd_driveid *id = drive->id;
 
-	if (drive->media != ide_disk && hwif->atapi_dma == 0)
-		return 0;
+	if (drive->media != ide_disk) {
+		if (hwif->host_flags & IDE_HFLAG_NO_ATAPI_DMA)
+			return -1;
+	}
 
 	/*
 	 * Enable DMA on any drive that has
@@ -726,8 +728,10 @@ u8 ide_find_dma_mode(ide_drive_t *drive, u8 req_mode)
 	int x, i;
 	u8 mode = 0;
 
-	if (drive->media != ide_disk && hwif->atapi_dma == 0)
-		return 0;
+	if (drive->media != ide_disk) {
+		if (hwif->host_flags & IDE_HFLAG_NO_ATAPI_DMA)
+			return 0;
+	}
 
 	for (i = 0; i < ARRAY_SIZE(xfer_mode_bases); i++) {
 		if (req_mode < xfer_mode_bases[i])

commit c223701cf6c706f42840631c1ca919a18e6e2800
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Oct 16 22:29:58 2007 +0200

    ide: add "hdx=nodma" kernel parameter
    
    * Add "hdx=nodma" option allowing user to disallow DMA for a given device.
    
    * Obsolete "ide=nodma" option.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 45fa1ef29d2c..bc57ce6bf0b3 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -759,7 +759,7 @@ static int ide_tune_dma(ide_drive_t *drive)
 {
 	u8 speed;
 
-	if (noautodma || (drive->id->capability & 1) == 0)
+	if (noautodma || drive->nodma || (drive->id->capability & 1) == 0)
 		return 0;
 
 	/* consult the list of known "bad" drives */

commit 9ff6f72f432364991d68e99cae72cb141c166e70
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Oct 16 22:29:58 2007 +0200

    ide: remove hwif->autodma and drive->autodma
    
    * hpt34x.c: disable DMA masks for HPT345
      (hwif->autodma is zero so DMA won't be enabled anyway).
    
    * trm290.c: disable IDE_HFLAG_TRUST_BIOS_FOR_DMA flag
      (hwif->autodma is zero so DMA won't be enabled anyway).
    
    * Check noautodma global variable instead of drive->autodma in ide_tune_dma().
    
      This fixes handling of "ide=nodma" kernel parameter for icside, ide-cris,
      au1xxx-ide, pmac, it821x, jmicron, sgiioc4 and siimage host drivers.
    
    * Remove hwif->autodma (it was not checked by IDE core code anyway) and
      drive->autodma (was set by all host drivers - except HPT345/TRM290 special
      cases - unless "ide=nodma" was used).
    
    While at it:
    - remove needless printk() from icside.c
    - remove stale FIXME/comment from ide-probe.c
    - don't force DMA off if PCI bus-mastering had to be enabled in setup-pci.c
      (this setting was always later over-ridden by host drivers anyway)
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 8ff9de599bf1..45fa1ef29d2c 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -759,7 +759,7 @@ static int ide_tune_dma(ide_drive_t *drive)
 {
 	u8 speed;
 
-	if ((drive->id->capability & 1) == 0 || drive->autodma == 0)
+	if (noautodma || (drive->id->capability & 1) == 0)
 		return 0;
 
 	/* consult the list of known "bad" drives */

commit 259c0632d30d75a5a7fccdac558cc128f03ce903
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Oct 16 22:29:55 2007 +0200

    ide: unexport ide_tune_dma
    
    static code mustn't be exported.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 716a4fdcc0b5..8ff9de599bf1 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -783,8 +783,6 @@ static int ide_tune_dma(ide_drive_t *drive)
 	return 1;
 }
 
-EXPORT_SYMBOL_GPL(ide_tune_dma);
-
 static int ide_dma_check(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = drive->hwif;

commit 0ae2e178652753ae1797d407755a3505f7c1d2a7
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Oct 16 22:29:55 2007 +0200

    ide: remove ->ide_dma_check (take 2)
    
    * Add IDE_HFLAG_TRUST_BIOS_FOR_DMA host flag for host drivers that depend
      on BIOS for programming device/controller for DMA.  Set it in cy82c693,
      generic, ns87415, opti621 and trm290 host drivers.
    
    * Add IDE_HFLAG_VDMA host flag for host drivers using VDMA.  Set it in cs5520
      host driver.
    
    * Teach ide_tune_dma() about IDE_HFLAG_TRUST_BIOS_FOR_DMA flag.
    
    * Add generic ide_dma_check() helper and remove all open coded ->ide_dma_check
      implementations.  Fix all places checking for presence of ->ide_dma_check
      hook to check for ->ide_dma_on instead.
    
    * Remove no longer needed code from config_drive_for_dma().
    
    * Make ide_tune_dma() static.
    
    v2:
    * Fix config_drive_for_dma() return values.
    
    * Fix ide-dma.c build for CONFIG_BLK_DEV_IDEDMA_PCI=n by adding
      dummy config_drive_for_dma() inline.
    
    * Fix IDE_HFLAG_TRUST_BIOS_FOR_DMA handling in ide_dma_check().
    
    * Fix init_hwif_it8213() comment.
    
    There should be no functionality changes caused by this patch.
    
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index a4cbbbaccde9..716a4fdcc0b5 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -338,35 +338,30 @@ static int config_drive_for_dma (ide_drive_t *drive)
 	ide_hwif_t *hwif = drive->hwif;
 	struct hd_driveid *id = drive->id;
 
-	/* consult the list of known "bad" drives */
-	if (__ide_dma_bad_drive(drive))
-		return -1;
-
 	if (drive->media != ide_disk && hwif->atapi_dma == 0)
-		return -1;
+		return 0;
 
-	if ((id->capability & 1) && drive->autodma) {
-		/*
-		 * Enable DMA on any drive that has
-		 * UltraDMA (mode 0/1/2/3/4/5/6) enabled
-		 */
-		if ((id->field_valid & 4) && ((id->dma_ultra >> 8) & 0x7f))
-			return 0;
-		/*
-		 * Enable DMA on any drive that has mode2 DMA
-		 * (multi or single) enabled
-		 */
-		if (id->field_valid & 2)	/* regular DMA */
-			if ((id->dma_mword & 0x404) == 0x404 ||
-			    (id->dma_1word & 0x404) == 0x404)
-				return 0;
-
-		/* Consult the list of known "good" drives */
-		if (ide_dma_good_drive(drive))
-			return 0;
-	}
+	/*
+	 * Enable DMA on any drive that has
+	 * UltraDMA (mode 0/1/2/3/4/5/6) enabled
+	 */
+	if ((id->field_valid & 4) && ((id->dma_ultra >> 8) & 0x7f))
+		return 1;
+
+	/*
+	 * Enable DMA on any drive that has mode2 DMA
+	 * (multi or single) enabled
+	 */
+	if (id->field_valid & 2)	/* regular DMA */
+		if ((id->dma_mword & 0x404) == 0x404 ||
+		    (id->dma_1word & 0x404) == 0x404)
+			return 1;
 
-	return -1;
+	/* Consult the list of known "good" drives */
+	if (ide_dma_good_drive(drive))
+		return 1;
+
+	return 0;
 }
 
 /**
@@ -627,6 +622,8 @@ static int __ide_dma_test_irq(ide_drive_t *drive)
 			drive->name, __FUNCTION__);
 	return 0;
 }
+#else
+static inline int config_drive_for_dma(ide_drive_t *drive) { return 0; }
 #endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
 
 int __ide_dma_bad_drive (ide_drive_t *drive)
@@ -758,7 +755,7 @@ u8 ide_find_dma_mode(ide_drive_t *drive, u8 req_mode)
 
 EXPORT_SYMBOL_GPL(ide_find_dma_mode);
 
-int ide_tune_dma(ide_drive_t *drive)
+static int ide_tune_dma(ide_drive_t *drive)
 {
 	u8 speed;
 
@@ -769,6 +766,9 @@ int ide_tune_dma(ide_drive_t *drive)
 	if (__ide_dma_bad_drive(drive))
 		return 0;
 
+	if (drive->hwif->host_flags & IDE_HFLAG_TRUST_BIOS_FOR_DMA)
+		return config_drive_for_dma(drive);
+
 	speed = ide_max_dma_mode(drive);
 
 	if (!speed)
@@ -785,6 +785,23 @@ int ide_tune_dma(ide_drive_t *drive)
 
 EXPORT_SYMBOL_GPL(ide_tune_dma);
 
+static int ide_dma_check(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	int vdma = (hwif->host_flags & IDE_HFLAG_VDMA)? 1 : 0;
+
+	if (!vdma && ide_tune_dma(drive))
+		return 0;
+
+	/* TODO: always do PIO fallback */
+	if (hwif->host_flags & IDE_HFLAG_TRUST_BIOS_FOR_DMA)
+		return -1;
+
+	ide_set_max_pio(drive);
+
+	return vdma ? 0 : -1;
+}
+
 void ide_dma_verbose(ide_drive_t *drive)
 {
 	struct hd_driveid *id	= drive->id;
@@ -842,7 +859,7 @@ int ide_set_dma(ide_drive_t *drive)
 	ide_hwif_t *hwif = drive->hwif;
 	int rc;
 
-	rc = hwif->ide_dma_check(drive);
+	rc = ide_dma_check(drive);
 
 	switch(rc) {
 	case -1: /* DMA needs to be disabled */
@@ -1019,8 +1036,6 @@ void ide_setup_dma (ide_hwif_t *hwif, unsigned long dma_base, unsigned int num_p
 		hwif->ide_dma_on = &__ide_dma_on;
 	if (!hwif->dma_host_on)
 		hwif->dma_host_on = &ide_dma_host_on;
-	if (!hwif->ide_dma_check)
-		hwif->ide_dma_check = &config_drive_for_dma;
 	if (!hwif->dma_setup)
 		hwif->dma_setup = &ide_dma_setup;
 	if (!hwif->dma_exec_cmd)

commit 55c16a70041ba55e235c5944dccb9c1de0dd3ca6
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Wed Jul 25 08:13:56 2007 +0200

    IDE: sg chaining support
    
    Acked-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index b453211ee0fc..a4cbbbaccde9 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -280,7 +280,7 @@ int ide_build_dmatable (ide_drive_t *drive, struct request *rq)
 			}
 		}
 
-		sg++;
+		sg = sg_next(sg);
 		i--;
 	}
 

commit 88b2b32babd46cd54d2de4d17eb869aea3383e11
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Oct 13 17:47:51 2007 +0200

    ide: move ide_config_drive_speed() calls to upper layers (take 2)
    
    * Convert {ide_hwif_t,ide_pci_device_t}->host_flag to be u16.
    
    * Add IDE_HFLAG_POST_SET_MODE host flag to indicate the need to program
      the host for the transfer mode after programming the device.  Set it
      in au1xxx-ide, amd74xx, cs5530, cs5535, pdc202xx_new, sc1200, pmac
      and via82cxxx host drivers.
    
    * Add IDE_HFLAG_NO_SET_MODE host flag to indicate the need to completely
      skip programming of host/device for the transfer mode ("smart" hosts).
      Set it in it821x host driver and check it in ide_tune_dma().
    
    * Add ide_set_pio_mode()/ide_set_dma_mode() helpers and convert all
      direct ->set_pio_mode/->speedproc users to use these helpers.
    
    * Move ide_config_drive_speed() calls from ->set_pio_mode/->speedproc
      methods to callers.
    
    * Rename ->speedproc method to ->set_dma_mode, make it void and update
      all implementations accordingly.
    
    * Update ide_set_xfer_rate() comments.
    
    * Unexport ide_config_drive_speed().
    
    v2:
    * Fix issues noticed by Sergei:
      - export ide_set_dma_mode() instead of moving ->set_pio_mode abuse wrt
        to setting DMA modes from sc1200_set_pio_mode() to do_special()
      - check IDE_HFLAG_NO_SET_MODE in ide_tune_dma()
      - check for (hwif->set_pio_mode) == NULL in ide_set_pio_mode()
      - check for (hwif->set_dma_mode) == NULL in ide_set_dma_mode()
      - return -1 from ide_set_{pio,dma}_mode() if ->set_{pio,dma}_mode == NULL
      - don't set ->set_{pio,dma}_mode on it821x in "smart" mode
      - fix build problem in pmac.c
      - minor fixes in au1xxx-ide.c/cs5530.c/siimage.c
      - improve patch description
    
    Changes in behavior caused by this patch:
    - HDIO_SET_PIO_MODE ioctl would now return -ENOSYS for attempts to change
      PIO mode if it821x controller is in "smart" mode
    - removal of two debugging printk-s (from cs5530.c and sc1200.c)
    - transfer modes 0x00-0x07 passed from user space may be programmed twice on
      the device (not really an issue since 0x00 is not supported correctly by
      any host driver ATM, 0x01 is not supported at all and 0x02-0x07 are invalid)
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 05781faaddd8..b453211ee0fc 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -774,7 +774,10 @@ int ide_tune_dma(ide_drive_t *drive)
 	if (!speed)
 		return 0;
 
-	if (drive->hwif->speedproc(drive, speed))
+	if (drive->hwif->host_flags & IDE_HFLAG_NO_SET_MODE)
+		return 0;
+
+	if (ide_set_dma_mode(drive, speed))
 		return 0;
 
 	return 1;

commit 75d7d963e3dcf8a1410000ab246921709e276cd9
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Oct 13 17:47:50 2007 +0200

    icside: use ide_tune_dma()
    
    * Add "good DMA drives" hack for icside to ide-dma.c::ide_find_dma_mode()
      (in the long-term it should be either removed or generalized for all hosts).
    
    * Use ide_tune_dma() in icside.c::icside_dma_check().
    
      This results in the following changes in behavior:
      - pre-EIDE SWDMA modes are now also respected
      - drive->autodma is checked instead of hwif->autodma
        (doesn't really matter as icside sets both to "1")
    
    * Make ide-dma.c::__ide_dma_good_drive() static and drop "__" prefix.
    
    Cc: Russell King <rmk@arm.linux.org.uk>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 6000c08f51ba..05781faaddd8 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -169,6 +169,11 @@ ide_startstop_t ide_dma_intr (ide_drive_t *drive)
 
 EXPORT_SYMBOL_GPL(ide_dma_intr);
 
+static int ide_dma_good_drive(ide_drive_t *drive)
+{
+	return ide_in_drive_list(drive->id, drive_whitelist);
+}
+
 #ifdef CONFIG_BLK_DEV_IDEDMA_PCI
 /**
  *	ide_build_sglist	-	map IDE scatter gather for DMA I/O
@@ -357,7 +362,7 @@ static int config_drive_for_dma (ide_drive_t *drive)
 				return 0;
 
 		/* Consult the list of known "good" drives */
-		if (__ide_dma_good_drive(drive))
+		if (ide_dma_good_drive(drive))
 			return 0;
 	}
 
@@ -639,14 +644,6 @@ int __ide_dma_bad_drive (ide_drive_t *drive)
 
 EXPORT_SYMBOL(__ide_dma_bad_drive);
 
-int __ide_dma_good_drive (ide_drive_t *drive)
-{
-	struct hd_driveid *id = drive->id;
-	return ide_in_drive_list(id, drive_whitelist);
-}
-
-EXPORT_SYMBOL(__ide_dma_good_drive);
-
 static const u8 xfer_mode_bases[] = {
 	XFER_UDMA_0,
 	XFER_MW_DMA_0,
@@ -746,6 +743,14 @@ u8 ide_find_dma_mode(ide_drive_t *drive, u8 req_mode)
 		}
 	}
 
+	if (hwif->chipset == ide_acorn && mode == 0) {
+		/*
+		 * is this correct?
+		 */
+		if (ide_dma_good_drive(drive) && drive->id->eide_dma_time < 150)
+			mode = XFER_MW_DMA_1;
+	}
+
 	printk(KERN_DEBUG "%s: selected mode 0x%x\n", drive->name, mode);
 
 	return min(mode, req_mode);

commit 7670df73fba373d19471a2ebedb3302ea0607be0
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu Oct 11 23:53:59 2007 +0200

    ide: mode limiting fixes for user requested speed changes
    
    * Add an extra argument to ide_max_dma_mode() for passing requested transfer
      mode.  Use it as an upper limit when finding the best DMA for device/host.
    
    * Rename ide_max_dma_mode() to ide_find_dma_mode() and at the same time add
      ide_max_dma_mode() wrapper which passes XFER_UDMA_6 as a requested mode to
      ide_find_dma_mode().  Also add inline ide_find_dma_mode() version for
      CONFIG_BLK_DEV_IDEDMA=n case.
    
    * Pass requested transfer mode from ide_find_dma_mode() to ide_get_mode_mask()
      to avoid false warning from eighty_ninty_three().
    
    * Use ide_find_dma_mode() to limit the user requested transfer mode in
      ide_rate_filter().  Also limit the requested mode by host max PIO mode.
    
    
    Above changes make ide_rate_filter() to:
    
    * Clip desired transfer mode down if it is invalid (values 0x0F, 0x13-0x19
      and 0x25-0x39, values > 0x46 were already clipped down, same for values
      0x25-0x39 but iff UDMA was not supported by the host).
    
    * Clip desired transfer mode down if it is currently unsupported by IDE core
      (PIO6 and MWDMA3-4, the latter were already clipped down but iff UDMA was
      not supported by the host).
    
    * Clip desired transfer mode down according to the host capabilities
      (UDMA modes were already clipped down but MWDMA/SWDMA/PIO weren't,
      also ->atapi_dma flag was not respected).
    
    * Clip desired transfer mode down according to the device capabilities
      (except PIO modes for now which require mode work) - shouldn't be a
      problem since ide_set_xfer_rate() is called _after_ device has accepted
      given transfer mode.
    
    and also result in a number of host driver specific bugfixes:
    
    * icside
      - clip unsupported PIO5 mode down
      - fix unsupported/invalid modes being set in drive->current_speed
    
    * ide-cris
      - clip unsupported PIO5 and SWDMA0-2 modes down
      - clip DMA modes down for ATAPI devices
      - fix BUG() on unsupported/invalid modes
    
    * au1xxx-ide
      - clip unsupported PIO5, SWDMA0-2 and MWDMA0-2
        (if BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA=n) modes down
    
    * aec62xx
      - clip unsupported PIO5 and SWDMA0-2 modes down
      - clip DMA modes down for ATAPI devices
      - fix 0x00 being programmed as PIO timing for unsupported/invalid modes
      - fix unsupported/invalid modes being set on the device
    
    * alim15x3
      - clip DMA modes down for ATAPI devices (chipset revision == 0x20 only)
      - fix theoretical OOPS for 0x0F mode
      - fix unsupported/invalid modes being set on the device
    
    * amd74xx
      - clip unsupported SWDMA0-2 (on COBRA_7401 revs <= 7) modes down
      - fix random PIO timings being set for unsupported/invalid modes
      - fix unsupported/invalid modes being set on the device
    
    * atiixp
      - clip unsupported PIO5 and SWDMA0-2 modes down
      - fix cached MWDMA mode being cleared for unsupported/invalid modes
      - fix PIO{0,2} timings being programmed for unsupported/invalid modes
      - fix theoretical OOPS for PIO5-6 and 0x0F modes
      - fix unsupported/invalid modes being set on the device
    
    * cmd64x
      - clip unsupported SWDMA0-2 modes down
    
    * cs5530
      - clip unsupported PIO5 and SWDMA0-2 modes down
      - fix unsupported/invalid modes being set on the device
      - fix BUG() on unsupported/invalid modes
        (which happened if the device accepted the setting)
    
    * cs5535
      - clip unsupported PIO5 and SWDMA0-2 modes down
      - fix unsupported/invalid modes being set on the device
      - fix theoretical OOPS for PIO5-6 and 0x0F modes
    
    * hpt34x
      - clip DMA modes down for ATAPI devices
      - fix invalid timings being programmed for unsupported/invalid modes
      - fix unsupported/invalid modes being set on the device
    
    * hpt366
      - clip unsupported PIO5 and SWDMA0-2 modes down
      - fix PIO0 timings being programmed for unsupported/invalid modes
      - fix DMA timings being cleared for MWDMA3-4 and 0x25-0x39 modes
      - fix unsupported/invalid modes being set on the device
    
    * it8213
      - clip unsupported PIO5, SWDMA0-1 and MWDMA0 modes down
    
    * it821x
      - clip unsupported PIO5 and SWDMA0-2 modes down
      - clip DMA modes down for ATAPI devices
        (chipset in smart mode and revision 0x10 in pass-through mode)
    
    * jmicron
      - clip unsupported SWDMA0-2 modes down
      - fix unsupported/invalid modes being set on the device
    
    * pdc202xx_new
      - clip unsupported PIO5 and SWDMA0-2 modes down
      - fix unsupported/invalid modes being set on the device
    
    * pdc202xx_old
      - clip unsupported PIO5 mode down
      - fix incorrect timings being set for unsupported/invalid modes
      - fix unsupported/invalid modes being set on the device
    
    * piix
      - clip unsupported PIO5, SWDMA0-1 and MWDMA0 modes down
    
    * sc1200
      - clip unsupported PIO5 and SWDMA0-2 modes down
      - fix unsupported/invalid modes being set on the device
      - fix BUG() on unsupported/invalid modes
        (which happened if the device accepted the setting)
    
    * scc_pata
      - clip unsupported PIO5, SWDMA0-2 and MWDMA0-2 modes down
    
    * serverworks
      - clip unsupported PIO5 and SWDMA0-2 modes down
      - fix DMA/UDMA timings/settings being cleared for unsupported/invalid modes
      - fix unsupported/invalid modes being set on the device
    
    * siimage
      - clip unsupported PIO5 and SWDMA0-2 modes down
      - clip DMA modes down for ATAPI devices (SATA chipsets)
    
    * sis5513
      - clip unsupported PIO5 mode down
      - fix BUG() on unsupported/invalid modes
    
    * sl82c105
      - clip unsupported SWDMA0-2 modes down
    
    * slc90e66
      - clip unsupported PIO5, SWDMA0-1 and MWDMA0 modes down
    
    * tc86c001
      - clip unsupported PIO5 and SWDMA0-2 modes down
      - fix PIO0 timings being programmed for PIO5/0x0F/SWDMA0-2/0x13-0x19 modes
      - fix invalid 0x00 DMA timing being programmed for MWDMA3-4/0x25-0x39 modes
      - fix unsupported/invalid modes being set on the device
    
    * triflex
      - clip unsupported PIO5 mode down
    
    * via82cxxx
      - fix random PIO timings being set for unsupported/invalid modes
      - fix unsupported/invalid modes being set on the device
    
    * pmac
      - clip unsupported PIO5 and SWDMA0-2 modes down
    
    * cmd640/ht6560b
      - clip DMA modes down (if CONFIG_BLK_DEV_IDEDMA=y)
      - fix PIO5 being clipped to PIO4 (if CONFIG_BLK_DEV_IDEDMA=n)
    
    * opti621
      - clip DMA modes down (if CONFIG_BLK_DEV_IDEDMA=y)
      - clip unsupported PIO4 to PIO3 (if CONFIG_BLK_DEV_IDEDMA=n)
    
    
    While at it:
    
    * Use ide_rate_filter() in cs5520.c::cs5520_tune_chipset().
    
    * Remove no longer needed checks from hpt366.c::hpt3{6,7}x_tune_chipset().
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index f073ea35da00..6000c08f51ba 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -653,7 +653,7 @@ static const u8 xfer_mode_bases[] = {
 	XFER_SW_DMA_0,
 };
 
-static unsigned int ide_get_mode_mask(ide_drive_t *drive, u8 base)
+static unsigned int ide_get_mode_mask(ide_drive_t *drive, u8 base, u8 req_mode)
 {
 	struct hd_driveid *id = drive->id;
 	ide_hwif_t *hwif = drive->hwif;
@@ -670,8 +670,13 @@ static unsigned int ide_get_mode_mask(ide_drive_t *drive, u8 base)
 			mask = hwif->ultra_mask;
 		mask &= id->dma_ultra;
 
-		if ((mask & 0x78) && (eighty_ninty_three(drive) == 0))
-			mask &= 0x07;
+		/*
+		 * avoid false cable warning from eighty_ninty_three()
+		 */
+		if (req_mode > XFER_UDMA_2) {
+			if ((mask & 0x78) && (eighty_ninty_three(drive) == 0))
+				mask &= 0x07;
+		}
 		break;
 	case XFER_MW_DMA_0:
 		if ((id->field_valid & 2) == 0)
@@ -709,15 +714,18 @@ static unsigned int ide_get_mode_mask(ide_drive_t *drive, u8 base)
 }
 
 /**
- *	ide_max_dma_mode	-	compute DMA speed
+ *	ide_find_dma_mode	-	compute DMA speed
  *	@drive: IDE device
+ *	@req_mode: requested mode
+ *
+ *	Checks the drive/host capabilities and finds the speed to use for
+ *	the DMA transfer.  The speed is then limited by the requested mode.
  *
- *	Checks the drive capabilities and returns the speed to use
- *	for the DMA transfer.  Returns 0 if the drive is incapable
- *	of DMA transfers.
+ *	Returns 0 if the drive/host combination is incapable of DMA transfers
+ *	or if the requested mode is not a DMA mode.
  */
 
-u8 ide_max_dma_mode(ide_drive_t *drive)
+u8 ide_find_dma_mode(ide_drive_t *drive, u8 req_mode)
 {
 	ide_hwif_t *hwif = drive->hwif;
 	unsigned int mask;
@@ -728,7 +736,9 @@ u8 ide_max_dma_mode(ide_drive_t *drive)
 		return 0;
 
 	for (i = 0; i < ARRAY_SIZE(xfer_mode_bases); i++) {
-		mask = ide_get_mode_mask(drive, xfer_mode_bases[i]);
+		if (req_mode < xfer_mode_bases[i])
+			continue;
+		mask = ide_get_mode_mask(drive, xfer_mode_bases[i], req_mode);
 		x = fls(mask) - 1;
 		if (x >= 0) {
 			mode = xfer_mode_bases[i] + x;
@@ -738,10 +748,10 @@ u8 ide_max_dma_mode(ide_drive_t *drive)
 
 	printk(KERN_DEBUG "%s: selected mode 0x%x\n", drive->name, mode);
 
-	return mode;
+	return min(mode, req_mode);
 }
 
-EXPORT_SYMBOL_GPL(ide_max_dma_mode);
+EXPORT_SYMBOL_GPL(ide_find_dma_mode);
 
 int ide_tune_dma(ide_drive_t *drive)
 {

commit 851dd33bcf23655eede62730c029e4f608f4084f
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Thu Oct 11 23:53:59 2007 +0200

    ide: call udma_filter() before resorting to the UltraDMA mask
    
    Give the udma_filter() method call precedence over using the mode masks.
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 097d6e9865bc..f073ea35da00 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -664,10 +664,11 @@ static unsigned int ide_get_mode_mask(ide_drive_t *drive, u8 base)
 		if ((id->field_valid & 4) == 0)
 			break;
 
-		mask = id->dma_ultra & hwif->ultra_mask;
-
 		if (hwif->udma_filter)
-			mask &= hwif->udma_filter(drive);
+			mask = hwif->udma_filter(drive);
+		else
+			mask = hwif->ultra_mask;
+		mask &= id->dma_ultra;
 
 		if ((mask & 0x78) && (eighty_ninty_three(drive) == 0))
 			mask &= 0x07;

commit b4e44369a380c1836d0983c2a5011099b7b26eb1
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Thu Oct 11 23:53:58 2007 +0200

    hpt366: MWDMA filter for SATA cards (take 2)
    
    The Marvell bridge chips used on HighPoint SATA cards do not seem to support
    the MWDMA modes (at least that could be seen in their so-called drivers :-),
    so the driver needs to account for this -- to achieve this:
    
    - add mdma_filter() method from the original patch by Bartlomiej Zolnierkiewicz
      with his consent;
    
    - install the method for all chips to only return empty mask if a SATA drive
      is detected on HPT372{AN]/374 chips...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index ff644a5e12cd..097d6e9865bc 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -673,8 +673,13 @@ static unsigned int ide_get_mode_mask(ide_drive_t *drive, u8 base)
 			mask &= 0x07;
 		break;
 	case XFER_MW_DMA_0:
-		if (id->field_valid & 2)
-			mask = id->dma_mword & hwif->mwdma_mask;
+		if ((id->field_valid & 2) == 0)
+			break;
+		if (hwif->mdma_filter)
+			mask = hwif->mdma_filter(drive);
+		else
+			mask = hwif->mwdma_mask;
+		mask &= id->dma_mword;
 		break;
 	case XFER_SW_DMA_0:
 		if (id->field_valid & 2) {

commit a5b7e70d787f528386eda025d3e38f545017f241
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Aug 20 22:42:56 2007 +0200

    ide: add cable detection for early UDMA66 devices (take 3)
    
    * Move ide_in_drive_list() from ide-dma.c to ide-iops.c.
    
    * Add ivb_list[] table for listening early UDMA66 devices which don't conform
      to ATA4 standard wrt cable detection (bit14 is zero, only bit13 is valid)
      and use only device side cable detection for them since host side cable
      detection may be unreliable.
    
    * Add model "QUANTUM FIREBALLlct10 05" with firwmare "A03.0900" to the list
      (from Craig's bugreport).
    
    v2:
    * Improve kernel message basing on suggestion from Sergei.
    
    v3:
    * Don't print kernel message when no device side cable detection is done,
      plus some minor fixes.  (Noticed by Sergei)
    
    Thanks to Craig for testing this patch.
    
    Cc: Craig Block <chblock3@yahoo.com>
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 865a2740a6e3..ff644a5e12cd 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -134,25 +134,6 @@ static const struct drive_list_entry drive_blacklist [] = {
 
 };
 
-/**
- *	ide_in_drive_list	-	look for drive in black/white list
- *	@id: drive identifier
- *	@drive_table: list to inspect
- *
- *	Look for a drive in the blacklist and the whitelist tables
- *	Returns 1 if the drive is found in the table.
- */
-
-int ide_in_drive_list(struct hd_driveid *id, const struct drive_list_entry *drive_table)
-{
-	for ( ; drive_table->id_model ; drive_table++)
-		if ((!strcmp(drive_table->id_model, id->model)) &&
-		    (!drive_table->id_firmware ||
-		     strstr(id->fw_rev, drive_table->id_firmware)))
-			return 1;
-	return 0;
-}
-
 /**
  *	ide_dma_intr	-	IDE DMA interrupt handler
  *	@drive: the drive the interrupt is for

commit 1116fae5fdfa80c6744a9b5d75fb3ef687a69b19
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Aug 20 22:42:55 2007 +0200

    ide: config_drive_for_dma() fixes
    
    * Add DMA blacklist checking (->ide_dma_on check probably can go now).
    
    * Add ->atapi_dma flag checking and remove no longer needed
      ns87415_ide_dma_check() from ns87415 host driver.
    
    * Remove now needless __ide_dma_check() wrapper and symbol export.
    
    * Check drive->autodma instead of hwif->autodma (there should be no changes in
      behavior as all users of config_drive_for_dma() set both ->autodma flags).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 5fe1d72ab451..865a2740a6e3 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -349,9 +349,17 @@ EXPORT_SYMBOL_GPL(ide_destroy_dmatable);
  
 static int config_drive_for_dma (ide_drive_t *drive)
 {
+	ide_hwif_t *hwif = drive->hwif;
 	struct hd_driveid *id = drive->id;
 
-	if ((id->capability & 1) && drive->hwif->autodma) {
+	/* consult the list of known "bad" drives */
+	if (__ide_dma_bad_drive(drive))
+		return -1;
+
+	if (drive->media != ide_disk && hwif->atapi_dma == 0)
+		return -1;
+
+	if ((id->capability & 1) && drive->autodma) {
 		/*
 		 * Enable DMA on any drive that has
 		 * UltraDMA (mode 0/1/2/3/4/5/6) enabled
@@ -513,20 +521,6 @@ int __ide_dma_on (ide_drive_t *drive)
 
 EXPORT_SYMBOL(__ide_dma_on);
 
-/**
- *	__ide_dma_check		-	check DMA setup
- *	@drive: drive to check
- *
- *	Don't use - due for extermination
- */
- 
-int __ide_dma_check (ide_drive_t *drive)
-{
-	return config_drive_for_dma(drive);
-}
-
-EXPORT_SYMBOL(__ide_dma_check);
-
 /**
  *	ide_dma_setup	-	begin a DMA phase
  *	@drive: target device
@@ -1021,7 +1015,7 @@ void ide_setup_dma (ide_hwif_t *hwif, unsigned long dma_base, unsigned int num_p
 	if (!hwif->dma_host_on)
 		hwif->dma_host_on = &ide_dma_host_on;
 	if (!hwif->ide_dma_check)
-		hwif->ide_dma_check = &__ide_dma_check;
+		hwif->ide_dma_check = &config_drive_for_dma;
 	if (!hwif->dma_setup)
 		hwif->dma_setup = &ide_dma_setup;
 	if (!hwif->dma_exec_cmd)

commit 27a278aa4309df244a2619f47031acce00ca1b7c
Author: Adrian Bunk <bunk@stusta.de>
Date:   Mon Jul 9 23:17:59 2007 +0200

    drivers/ide/ide-dma.c: unexport ide_set_dma
    
    ide_set_dma no longer has any modular user.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index e8c6e1ed497a..5fe1d72ab451 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -861,8 +861,6 @@ int ide_set_dma(ide_drive_t *drive)
 	return rc;
 }
 
-EXPORT_SYMBOL_GPL(ide_set_dma);
-
 #ifdef CONFIG_BLK_DEV_IDEDMA_PCI
 void ide_dma_lost_irq (ide_drive_t *drive)
 {

commit 15a4f943e729d8ba215ee551df6d7988ba14ac00
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Jul 9 23:17:57 2007 +0200

    ide: fix pre-EIDE SWDMA support
    
    If the word 62 is not defined use the word 52 to get SWDMA mask
    in ide_get_mode_mask().
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 85db8e85443a..e8c6e1ed497a 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -702,8 +702,22 @@ static unsigned int ide_get_mode_mask(ide_drive_t *drive, u8 base)
 			mask = id->dma_mword & hwif->mwdma_mask;
 		break;
 	case XFER_SW_DMA_0:
-		if (id->field_valid & 2)
+		if (id->field_valid & 2) {
 			mask = id->dma_1word & hwif->swdma_mask;
+		} else if (id->tDMA) {
+			/*
+			 * ide_fix_driveid() doesn't convert ->tDMA to the
+			 * CPU endianness so we need to do it here
+			 */
+			u8 mode = le16_to_cpu(id->tDMA);
+
+			/*
+			 * if the mode is valid convert it to the mask
+			 * (the maximum allowed mode is XFER_SW_DMA_2)
+			 */
+			if (mode <= 2)
+				mask = ((2 << mode) - 1) & hwif->swdma_mask;
+		}
 		break;
 	default:
 		BUG();

commit f3577db0c294ab4ce8460a8003312474b509e95f
Author: Junio C Hamano <junkio@cox.net>
Date:   Mon Jul 9 23:17:57 2007 +0200

    ide_in_drive_list(): "ALL" is not a wildcard anymore
    
    This removes the support to treat "ALL" as a wildcard for
    firmware revision.  This is made a separate patch, as it will
    break out-of-tree ide drivers that feed its own table that uses
    "ALL" as the wildcard to ide_in_drive_list().
    
    Signed-off-by: Junio C Hamano <junkio@cox.net>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Dave Jones <davej@redhat.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index e80f8e1a0b93..85db8e85443a 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -148,7 +148,6 @@ int ide_in_drive_list(struct hd_driveid *id, const struct drive_list_entry *driv
 	for ( ; drive_table->id_model ; drive_table++)
 		if ((!strcmp(drive_table->id_model, id->model)) &&
 		    (!drive_table->id_firmware ||
-		     !strcmp(drive_table->id_firmware, "ALL") || /* to be removed later */
 		     strstr(id->fw_rev, drive_table->id_firmware)))
 			return 1;
 	return 0;

commit c2d3ce8c39cb17dfc8d0426a98bd79f5d7b21e36
Author: Junio C Hamano <junkio@cox.net>
Date:   Mon Jul 9 23:17:56 2007 +0200

    ide_in_drive_list(): accept NULL as the wildcard for firmware revision
    
    Earlier, the matching of (model,rev) in ide-dma black/white list
    handling was to consider "ALL" in the table to match any
    revision.  This makes NULL to be also an accepted wildcard, and
    changes the entries of tables in ide-dma.c to use NULL.
    
    The code still accepts "ALL" as the wildcard, in order to keep
    any out-of-tree ide driver that feeds its own table that uses
    "ALL" as the wildcard to ide_in_drive_list() function from
    breaking.
    
    Signed-off-by: Junio C Hamano <junkio@cox.net>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Dave Jones <davej@redhat.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index ca55bfa4ac74..e80f8e1a0b93 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -91,45 +91,45 @@
 
 static const struct drive_list_entry drive_whitelist [] = {
 
-	{ "Micropolis 2112A"	,       "ALL"		},
-	{ "CONNER CTMA 4000"	,       "ALL"		},
-	{ "CONNER CTT8000-A"	,       "ALL"		},
-	{ "ST34342A"		,	"ALL"		},
+	{ "Micropolis 2112A"	,       NULL		},
+	{ "CONNER CTMA 4000"	,       NULL		},
+	{ "CONNER CTT8000-A"	,       NULL		},
+	{ "ST34342A"		,	NULL		},
 	{ NULL			,	NULL		}
 };
 
 static const struct drive_list_entry drive_blacklist [] = {
 
-	{ "WDC AC11000H"	,	"ALL"		},
-	{ "WDC AC22100H"	,	"ALL"		},
-	{ "WDC AC32500H"	,	"ALL"		},
-	{ "WDC AC33100H"	,	"ALL"		},
-	{ "WDC AC31600H"	,	"ALL"		},
+	{ "WDC AC11000H"	,	NULL 		},
+	{ "WDC AC22100H"	,	NULL 		},
+	{ "WDC AC32500H"	,	NULL 		},
+	{ "WDC AC33100H"	,	NULL 		},
+	{ "WDC AC31600H"	,	NULL 		},
 	{ "WDC AC32100H"	,	"24.09P07"	},
 	{ "WDC AC23200L"	,	"21.10N21"	},
-	{ "Compaq CRD-8241B"	,	"ALL"		},
-	{ "CRD-8400B"		,	"ALL"		},
-	{ "CRD-8480B",			"ALL"		},
-	{ "CRD-8482B",			"ALL"		},
- 	{ "CRD-84"		,	"ALL"		},
-	{ "SanDisk SDP3B"	,	"ALL"		},
-	{ "SanDisk SDP3B-64"	,	"ALL"		},
-	{ "SANYO CD-ROM CRD"	,	"ALL"		},
-	{ "HITACHI CDR-8"	,	"ALL"		},
-	{ "HITACHI CDR-8335"	,	"ALL"		},
-	{ "HITACHI CDR-8435"	,	"ALL"		},
-	{ "Toshiba CD-ROM XM-6202B"	,	"ALL"		},
-	{ "TOSHIBA CD-ROM XM-1702BC",	"ALL"		},
-	{ "CD-532E-A"		,	"ALL"		},
-	{ "E-IDE CD-ROM CR-840",	"ALL"		},
-	{ "CD-ROM Drive/F5A",	"ALL"		},
-	{ "WPI CDD-820",		"ALL"		},
-	{ "SAMSUNG CD-ROM SC-148C",	"ALL"		},
-	{ "SAMSUNG CD-ROM SC",	"ALL"		},
-	{ "ATAPI CD-ROM DRIVE 40X MAXIMUM",	"ALL"		},
-	{ "_NEC DV5800A",               "ALL"           },  
+	{ "Compaq CRD-8241B"	,	NULL 		},
+	{ "CRD-8400B"		,	NULL 		},
+	{ "CRD-8480B",			NULL 		},
+	{ "CRD-8482B",			NULL 		},
+	{ "CRD-84"		,	NULL 		},
+	{ "SanDisk SDP3B"	,	NULL 		},
+	{ "SanDisk SDP3B-64"	,	NULL 		},
+	{ "SANYO CD-ROM CRD"	,	NULL 		},
+	{ "HITACHI CDR-8"	,	NULL 		},
+	{ "HITACHI CDR-8335"	,	NULL 		},
+	{ "HITACHI CDR-8435"	,	NULL 		},
+	{ "Toshiba CD-ROM XM-6202B"	,	NULL 		},
+	{ "TOSHIBA CD-ROM XM-1702BC",	NULL 		},
+	{ "CD-532E-A"		,	NULL 		},
+	{ "E-IDE CD-ROM CR-840",	NULL 		},
+	{ "CD-ROM Drive/F5A",	NULL 		},
+	{ "WPI CDD-820",		NULL 		},
+	{ "SAMSUNG CD-ROM SC-148C",	NULL 		},
+	{ "SAMSUNG CD-ROM SC",	NULL 		},
+	{ "ATAPI CD-ROM DRIVE 40X MAXIMUM",	NULL 		},
+	{ "_NEC DV5800A",               NULL            },
 	{ "SAMSUNG CD-ROM SN-124",	"N001" },
-	{ "Seagate STT20000A",		"ALL" },
+	{ "Seagate STT20000A",		NULL  },
 	{ NULL			,	NULL		}
 
 };
@@ -147,8 +147,9 @@ int ide_in_drive_list(struct hd_driveid *id, const struct drive_list_entry *driv
 {
 	for ( ; drive_table->id_model ; drive_table++)
 		if ((!strcmp(drive_table->id_model, id->model)) &&
-		    ((strstr(id->fw_rev, drive_table->id_firmware)) ||
-		     (!strcmp(drive_table->id_firmware, "ALL"))))
+		    (!drive_table->id_firmware ||
+		     !strcmp(drive_table->id_firmware, "ALL") || /* to be removed later */
+		     strstr(id->fw_rev, drive_table->id_firmware)))
 			return 1;
 	return 0;
 }

commit c283f5dbe31920ca70b80a594a97bfaa2a28be13
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Mon Jul 9 23:17:54 2007 +0200

    ide: make void and rename ide_dma_timeout() method
    
    Since ide_dma_timeout() method's result is discarded, make it return 'void'.
    While at it, drop 'ide_' from the method's name, drop the '__' prefix from
    the default method's name, and do some cleanups in this method driver-wise:
    
    - in ide-dma.c, au1xxx-ide.c, and pdc202xx_old.c, define/use 'hwif' variable;
    
    - in au1xxx-ide.c, get rid of commented out printk();
    
    - in sl82c105.c, get rid of unnecessary variables.
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index ce322602982e..ca55bfa4ac74 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -857,16 +857,19 @@ void ide_dma_lost_irq (ide_drive_t *drive)
 
 EXPORT_SYMBOL(ide_dma_lost_irq);
 
-int __ide_dma_timeout (ide_drive_t *drive)
+void ide_dma_timeout (ide_drive_t *drive)
 {
+	ide_hwif_t *hwif = HWIF(drive);
+
 	printk(KERN_ERR "%s: timeout waiting for DMA\n", drive->name);
-	if (HWIF(drive)->ide_dma_test_irq(drive))
-		return 0;
 
-	return HWIF(drive)->ide_dma_end(drive);
+	if (hwif->ide_dma_test_irq(drive))
+		return;
+
+	hwif->ide_dma_end(drive);
 }
 
-EXPORT_SYMBOL(__ide_dma_timeout);
+EXPORT_SYMBOL(ide_dma_timeout);
 
 /*
  * Needed for allowing full modular support of ide-driver
@@ -1017,8 +1020,8 @@ void ide_setup_dma (ide_hwif_t *hwif, unsigned long dma_base, unsigned int num_p
 		hwif->ide_dma_end = &__ide_dma_end;
 	if (!hwif->ide_dma_test_irq)
 		hwif->ide_dma_test_irq = &__ide_dma_test_irq;
-	if (!hwif->ide_dma_timeout)
-		hwif->ide_dma_timeout = &__ide_dma_timeout;
+	if (!hwif->dma_timeout)
+		hwif->dma_timeout = &ide_dma_timeout;
 	if (!hwif->dma_lost_irq)
 		hwif->dma_lost_irq = &ide_dma_lost_irq;
 

commit 841d2a9bf16471716ba3a5172d24aa40a2ea9398
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Mon Jul 9 23:17:54 2007 +0200

    ide: make void and rename ide_dma_lostirq() method
    
    Since ide_dma_lostirq() method's result is discarded, make it return 'void'.
    While at it, rename the method to dma_lost_irq(), drop the '__' prefix from the
    default method's name, and do some cleanups in this method driver-wise:
    
    - in aec62xx.c, rename the method in accordance with other drivers, and get rid
      of unnecessary variables there;
    
    - in pdc202xx_old.c, define/use 'hwif' variable;
    
    - in sgiioc4.c, rearrange the code to call the resetproc() method directly.
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index ead141e2db9e..ce322602982e 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -850,13 +850,12 @@ int ide_set_dma(ide_drive_t *drive)
 EXPORT_SYMBOL_GPL(ide_set_dma);
 
 #ifdef CONFIG_BLK_DEV_IDEDMA_PCI
-int __ide_dma_lostirq (ide_drive_t *drive)
+void ide_dma_lost_irq (ide_drive_t *drive)
 {
 	printk("%s: DMA interrupt recovery\n", drive->name);
-	return 1;
 }
 
-EXPORT_SYMBOL(__ide_dma_lostirq);
+EXPORT_SYMBOL(ide_dma_lost_irq);
 
 int __ide_dma_timeout (ide_drive_t *drive)
 {
@@ -1020,8 +1019,8 @@ void ide_setup_dma (ide_hwif_t *hwif, unsigned long dma_base, unsigned int num_p
 		hwif->ide_dma_test_irq = &__ide_dma_test_irq;
 	if (!hwif->ide_dma_timeout)
 		hwif->ide_dma_timeout = &__ide_dma_timeout;
-	if (!hwif->ide_dma_lostirq)
-		hwif->ide_dma_lostirq = &__ide_dma_lostirq;
+	if (!hwif->dma_lost_irq)
+		hwif->dma_lost_irq = &ide_dma_lost_irq;
 
 	if (hwif->chipset != ide_trm290) {
 		u8 dma_stat = hwif->INB(hwif->dma_status);

commit 5a6248cac22a77588f81c7473cfd03d250cc5b56
Author: Junio C Hamano <junkio@cox.net>
Date:   Thu May 24 02:42:38 2007 +0200

    Match DMA blacklist entries between ide-dma.c and libata-core.c
    
    There are a few entries in ata_device_blacklist[] in libata-core.c
    marked with HORKAGE_NODMA but are missing from drive_blacklist[]
    in ide-dma.c.  This patch makes the lists in sync.
    
    Also remove a duplicated entry for "SanDisk SDP3B-64".
    
    Signed-off-by: Junio C Hamano <junkio@cox.net>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Dave Jones <davej@redhat.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index b77b7d138c49..ead141e2db9e 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -119,15 +119,17 @@ static const struct drive_list_entry drive_blacklist [] = {
 	{ "HITACHI CDR-8335"	,	"ALL"		},
 	{ "HITACHI CDR-8435"	,	"ALL"		},
 	{ "Toshiba CD-ROM XM-6202B"	,	"ALL"		},
+	{ "TOSHIBA CD-ROM XM-1702BC",	"ALL"		},
 	{ "CD-532E-A"		,	"ALL"		},
 	{ "E-IDE CD-ROM CR-840",	"ALL"		},
 	{ "CD-ROM Drive/F5A",	"ALL"		},
 	{ "WPI CDD-820",		"ALL"		},
 	{ "SAMSUNG CD-ROM SC-148C",	"ALL"		},
 	{ "SAMSUNG CD-ROM SC",	"ALL"		},
-	{ "SanDisk SDP3B-64"	,	"ALL"		},
 	{ "ATAPI CD-ROM DRIVE 40X MAXIMUM",	"ALL"		},
 	{ "_NEC DV5800A",               "ALL"           },  
+	{ "SAMSUNG CD-ROM SN-124",	"N001" },
+	{ "Seagate STT20000A",		"ALL" },
 	{ NULL			,	NULL		}
 
 };

commit 122ab0887c36247bd4508c25e4fccf9264546fe2
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed May 16 00:51:46 2007 +0200

    ide: remove ide_use_dma()
    
    ide_use_dma() duplicates a lot of ide_max_dma_mode() functionality
    and as all users of ide_use_dma() were converted to use ide_tune_dma()
    now it is possible to add missing checks to ide_tune_dma() and remove
    ide_use_dma() completely, so do it.
    
    There should be no functionality changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index ada2a3ea9430..b77b7d138c49 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -670,41 +670,6 @@ int __ide_dma_good_drive (ide_drive_t *drive)
 
 EXPORT_SYMBOL(__ide_dma_good_drive);
 
-int ide_use_dma(ide_drive_t *drive)
-{
-	struct hd_driveid *id = drive->id;
-	ide_hwif_t *hwif = drive->hwif;
-
-	if ((id->capability & 1) == 0 || drive->autodma == 0)
-		return 0;
-
-	/* consult the list of known "bad" drives */
-	if (__ide_dma_bad_drive(drive))
-		return 0;
-
-	/* capable of UltraDMA modes */
-	if (id->field_valid & 4) {
-		if (hwif->ultra_mask & id->dma_ultra)
-			return 1;
-	}
-
-	/* capable of regular DMA modes */
-	if (id->field_valid & 2) {
-		if (hwif->mwdma_mask & id->dma_mword)
-			return 1;
-		if (hwif->swdma_mask & id->dma_1word)
-			return 1;
-	}
-
-	/* consult the list of known "good" drives */
-	if (__ide_dma_good_drive(drive) && id->eide_dma_time < 150)
-		return 1;
-
-	return 0;
-}
-
-EXPORT_SYMBOL_GPL(ide_use_dma);
-
 static const u8 xfer_mode_bases[] = {
 	XFER_UDMA_0,
 	XFER_MW_DMA_0,
@@ -785,8 +750,11 @@ int ide_tune_dma(ide_drive_t *drive)
 {
 	u8 speed;
 
-	/* TODO: use only ide_max_dma_mode() */
-	if (!ide_use_dma(drive))
+	if ((drive->id->capability & 1) == 0 || drive->autodma == 0)
+		return 0;
+
+	/* consult the list of known "bad" drives */
+	if (__ide_dma_bad_drive(drive))
 		return 0;
 
 	speed = ide_max_dma_mode(drive);

commit 3649c06e66ad3589374e8765ed69eda65658735c
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed May 16 00:51:46 2007 +0200

    ide: add missing validity checks for identify words 62 and 63
    
    Check validity of identify words 62 and 63 before using them in
    ide_get_mode_mask().
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index de33e6f88f17..ada2a3ea9430 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -731,10 +731,12 @@ static unsigned int ide_get_mode_mask(ide_drive_t *drive, u8 base)
 			mask &= 0x07;
 		break;
 	case XFER_MW_DMA_0:
-		mask = id->dma_mword & hwif->mwdma_mask;
+		if (id->field_valid & 2)
+			mask = id->dma_mword & hwif->mwdma_mask;
 		break;
 	case XFER_SW_DMA_0:
-		mask = id->dma_1word & hwif->swdma_mask;
+		if (id->field_valid & 2)
+			mask = id->dma_1word & hwif->swdma_mask;
 		break;
 	default:
 		BUG();

commit 4728d546d7137ad5350cc2e53d4748fd26f61a60
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed May 16 00:51:46 2007 +0200

    ide: remove ide_dma_enable()
    
    * check ->speedproc return value in ide_tune_dma()
    * use ide_tune_dma() in cmd64x/cs5530/sc1200/siimage/sl82c105/scc_pata drivers
    * remove no longer needed ide_dma_enable()
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 5fe85191d49c..de33e6f88f17 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -792,9 +792,10 @@ int ide_tune_dma(ide_drive_t *drive)
 	if (!speed)
 		return 0;
 
-	drive->hwif->speedproc(drive, speed);
+	if (drive->hwif->speedproc(drive, speed))
+		return 0;
 
-	return ide_dma_enable(drive);
+	return 1;
 }
 
 EXPORT_SYMBOL_GPL(ide_tune_dma);

commit 29e744d088e3555f4efbdf390f01088dd66993b6
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu May 10 00:01:09 2007 +0200

    ide: add ide_tune_dma() helper
    
    After reworking the code responsible for selecting the best DMA
    transfer mode it is now possible to add generic ide_tune_dma() helper.
    
    Convert some IDE PCI host drivers to use it (the ones left need more work).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index f28fabb791fe..5fe85191d49c 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -779,6 +779,26 @@ u8 ide_max_dma_mode(ide_drive_t *drive)
 
 EXPORT_SYMBOL_GPL(ide_max_dma_mode);
 
+int ide_tune_dma(ide_drive_t *drive)
+{
+	u8 speed;
+
+	/* TODO: use only ide_max_dma_mode() */
+	if (!ide_use_dma(drive))
+		return 0;
+
+	speed = ide_max_dma_mode(drive);
+
+	if (!speed)
+		return 0;
+
+	drive->hwif->speedproc(drive, speed);
+
+	return ide_dma_enable(drive);
+}
+
+EXPORT_SYMBOL_GPL(ide_tune_dma);
+
 void ide_dma_verbose(ide_drive_t *drive)
 {
 	struct hd_driveid *id	= drive->id;

commit 2d5eaa6dd744a641e75503232a01f52d0768884c
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu May 10 00:01:08 2007 +0200

    ide: rework the code for selecting the best DMA transfer mode (v3)
    
    Depends on the "ide: fix UDMA/MWDMA/SWDMA masks" patch.
    
    * add ide_hwif_t.udma_filter hook for filtering UDMA mask
      (use it in alim15x3, hpt366, siimage and serverworks drivers)
    * add ide_max_dma_mode() for finding best DMA mode for the device
      (loosely based on some older libata-core.c code)
    * convert ide_dma_speed() users to use ide_max_dma_mode()
    * make ide_rate_filter() take "ide_drive_t *drive" as an argument instead
      of "u8 mode" and teach it to how to use UDMA mask to do filtering
    * use ide_rate_filter() in hpt366 driver
    * remove no longer needed ide_dma_speed() and *_ratemask()
    * unexport eighty_ninty_three()
    
    v2:
    * rename ->filter_udma_mask to ->udma_filter
      [ Suggested by Sergei Shtylyov <sshtylyov@ru.mvista.com>. ]
    
    v3:
    * updated for scc_pata driver (fixes XFER_UDMA_6 filtering for user-space
      originated transfer mode change requests when 100MHz clock is used)
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index fd213088b06b..f28fabb791fe 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -705,6 +705,80 @@ int ide_use_dma(ide_drive_t *drive)
 
 EXPORT_SYMBOL_GPL(ide_use_dma);
 
+static const u8 xfer_mode_bases[] = {
+	XFER_UDMA_0,
+	XFER_MW_DMA_0,
+	XFER_SW_DMA_0,
+};
+
+static unsigned int ide_get_mode_mask(ide_drive_t *drive, u8 base)
+{
+	struct hd_driveid *id = drive->id;
+	ide_hwif_t *hwif = drive->hwif;
+	unsigned int mask = 0;
+
+	switch(base) {
+	case XFER_UDMA_0:
+		if ((id->field_valid & 4) == 0)
+			break;
+
+		mask = id->dma_ultra & hwif->ultra_mask;
+
+		if (hwif->udma_filter)
+			mask &= hwif->udma_filter(drive);
+
+		if ((mask & 0x78) && (eighty_ninty_three(drive) == 0))
+			mask &= 0x07;
+		break;
+	case XFER_MW_DMA_0:
+		mask = id->dma_mword & hwif->mwdma_mask;
+		break;
+	case XFER_SW_DMA_0:
+		mask = id->dma_1word & hwif->swdma_mask;
+		break;
+	default:
+		BUG();
+		break;
+	}
+
+	return mask;
+}
+
+/**
+ *	ide_max_dma_mode	-	compute DMA speed
+ *	@drive: IDE device
+ *
+ *	Checks the drive capabilities and returns the speed to use
+ *	for the DMA transfer.  Returns 0 if the drive is incapable
+ *	of DMA transfers.
+ */
+
+u8 ide_max_dma_mode(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	unsigned int mask;
+	int x, i;
+	u8 mode = 0;
+
+	if (drive->media != ide_disk && hwif->atapi_dma == 0)
+		return 0;
+
+	for (i = 0; i < ARRAY_SIZE(xfer_mode_bases); i++) {
+		mask = ide_get_mode_mask(drive, xfer_mode_bases[i]);
+		x = fls(mask) - 1;
+		if (x >= 0) {
+			mode = xfer_mode_bases[i] + x;
+			break;
+		}
+	}
+
+	printk(KERN_DEBUG "%s: selected mode 0x%x\n", drive->name, mode);
+
+	return mode;
+}
+
+EXPORT_SYMBOL_GPL(ide_max_dma_mode);
+
 void ide_dma_verbose(ide_drive_t *drive)
 {
 	struct hd_driveid *id	= drive->id;

commit 6f5050a96c9e0521f42a3a1d676c7ad9815f62ad
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Mar 17 21:57:39 2007 +0100

    ide: don't allow DMA to be enabled if CONFIG_IDEDMA_{ICS,PCI}_AUTO=n
    
    For CONFIG_IDEDMA_{ICS,PCI}_AUTO=n and/or "ide=nodma" option the host/device
    are not programmed for DMA and it is also explicitly disabled by ide_set_dma()
    (->ide_dma_check returns "-1").  However the code responsible for manually
    enabling DMA ("hdparm -d 1") has a bug which results in DMA being erroneously
    enabled - ide_set_dma() incorrectly passes "0" return value to set_using_dma().
    This may work if BIOS/firmware configured the host/device for DMA and chipset
    allows independent configuration of DMA/PIO modes but won't work after suspend
    and is generally unsafe on many chipsets (possibly including data corruption
    if the same registers are used for DMA/PIO timings).
    
    This patch fixes kernel bugzilla bug #8169 (piix host driver fixes for
    setting PIO mode exposed the problem described above).  The side-effect of
    the fix is that some rare configuration may be forced to PIO mode when DMA
    mode was previously used - this is addressed by the next patch which removes
    CONFIG_IDEDMA_{PCI,ICS}_AUTO config option completely.
    
    Thanks goes out to Patrick Horn for reporting the issue, narrowing it down
    to the specific commit and testing the fix.  Also thanks to Sergei Shtylyov
    for help in debugging the problem.
    
    Cc: Patrick Horn <phrh@yahoo.com>
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: Russell King <rmk+lkml@arm.linux.org.uk>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 08e7cd043bcc..fd213088b06b 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -767,7 +767,7 @@ int ide_set_dma(ide_drive_t *drive)
 	switch(rc) {
 	case -1: /* DMA needs to be disabled */
 		hwif->dma_off_quietly(drive);
-		return 0;
+		return -1;
 	case  0: /* DMA needs to be enabled */
 		return hwif->ide_dma_on(drive);
 	case  1: /* DMA setting cannot be changed */

commit ccf352894ceef79d40d015e1deee4c46c3aa42ed
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Feb 17 02:40:26 2007 +0100

    ide: make ide_hwif_t.ide_dma_host_on void (v2)
    
    * since ide_hwif_t.ide_dma_host_on is called either when drive->using_dma == 1
      or when return value is discarded make it void, also drop "ide_" prefix
    * make __ide_dma_host_on() void and drop "__" prefix
    
    v2:
    * while at it rename atiixp_ide_dma_host_on() to atiixp_dma_host_on()
      and sgiioc4_ide_dma_host_on() to sgiioc4_dma_host_on().
      [ Noticed by Sergei Shtylyov <sshtylyov@ru.mvista.com>. ]
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index a15217b136f5..08e7cd043bcc 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -468,14 +468,14 @@ EXPORT_SYMBOL(ide_dma_off);
 
 #ifdef CONFIG_BLK_DEV_IDEDMA_PCI
 /**
- *	__ide_dma_host_on	-	Enable DMA on a host
+ *	ide_dma_host_on	-	Enable DMA on a host
  *	@drive: drive to enable for DMA
  *
  *	Enable DMA on an IDE controller following generic bus mastering
  *	IDE controller behaviour
  */
- 
-int __ide_dma_host_on (ide_drive_t *drive)
+
+void ide_dma_host_on(ide_drive_t *drive)
 {
 	if (drive->using_dma) {
 		ide_hwif_t *hwif	= HWIF(drive);
@@ -483,12 +483,10 @@ int __ide_dma_host_on (ide_drive_t *drive)
 		u8 dma_stat		= hwif->INB(hwif->dma_status);
 
 		hwif->OUTB((dma_stat|(1<<(5+unit))), hwif->dma_status);
-		return 0;
 	}
-	return 1;
 }
 
-EXPORT_SYMBOL(__ide_dma_host_on);
+EXPORT_SYMBOL(ide_dma_host_on);
 
 /**
  *	__ide_dma_on		-	Enable DMA on a device
@@ -506,8 +504,7 @@ int __ide_dma_on (ide_drive_t *drive)
 	drive->using_dma = 1;
 	ide_toggle_bounce(drive, 1);
 
-	if (HWIF(drive)->ide_dma_host_on(drive))
-		return 1;
+	drive->hwif->dma_host_on(drive);
 
 	return 0;
 }
@@ -940,8 +937,8 @@ void ide_setup_dma (ide_hwif_t *hwif, unsigned long dma_base, unsigned int num_p
 		hwif->dma_host_off = &ide_dma_host_off;
 	if (!hwif->ide_dma_on)
 		hwif->ide_dma_on = &__ide_dma_on;
-	if (!hwif->ide_dma_host_on)
-		hwif->ide_dma_host_on = &__ide_dma_host_on;
+	if (!hwif->dma_host_on)
+		hwif->dma_host_on = &ide_dma_host_on;
 	if (!hwif->ide_dma_check)
 		hwif->ide_dma_check = &__ide_dma_check;
 	if (!hwif->dma_setup)

commit 7469aaf6a30f4187ed6de7c0aed5c2dd2d1c2d31
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Feb 17 02:40:26 2007 +0100

    ide: make ide_hwif_t.ide_dma_{host_off,off_quietly} void (v2)
    
    * since ide_hwif_t.ide_dma_{host_off,off_quietly} always return '0'
      make these functions void and while at it drop "ide_" prefix
    * fix comment for __ide_dma_off_quietly()
    * make __ide_dma_{host_off,off_quietly,off}() void and drop "__" prefix
    
    v2:
    * while at it rename atiixp_ide_dma_host_off() to atiixp_dma_host_off(),
      sgiioc4_ide_dma_{host_off,off_quietly}() to sgiioc4_dma_{host_off,off_quietly}()
      and sl82c105_ide_dma_off_quietly() to sl82c105_dma_off_quietly()
      [ Noticed by Sergei Shtylyov <sshtylyov@ru.mvista.com>. ]
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 4fbcea4c1025..a15217b136f5 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -414,61 +414,57 @@ static int dma_timer_expiry (ide_drive_t *drive)
 }
 
 /**
- *	__ide_dma_host_off	-	Generic DMA kill
+ *	ide_dma_host_off	-	Generic DMA kill
  *	@drive: drive to control
  *
  *	Perform the generic IDE controller DMA off operation. This
  *	works for most IDE bus mastering controllers
  */
 
-int __ide_dma_host_off (ide_drive_t *drive)
+void ide_dma_host_off(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif	= HWIF(drive);
 	u8 unit			= (drive->select.b.unit & 0x01);
 	u8 dma_stat		= hwif->INB(hwif->dma_status);
 
 	hwif->OUTB((dma_stat & ~(1<<(5+unit))), hwif->dma_status);
-	return 0;
 }
 
-EXPORT_SYMBOL(__ide_dma_host_off);
+EXPORT_SYMBOL(ide_dma_host_off);
 
 /**
- *	__ide_dma_host_off_quietly	-	Generic DMA kill
+ *	ide_dma_off_quietly	-	Generic DMA kill
  *	@drive: drive to control
  *
  *	Turn off the current DMA on this IDE controller. 
  */
 
-int __ide_dma_off_quietly (ide_drive_t *drive)
+void ide_dma_off_quietly(ide_drive_t *drive)
 {
 	drive->using_dma = 0;
 	ide_toggle_bounce(drive, 0);
 
-	if (HWIF(drive)->ide_dma_host_off(drive))
-		return 1;
-
-	return 0;
+	drive->hwif->dma_host_off(drive);
 }
 
-EXPORT_SYMBOL(__ide_dma_off_quietly);
+EXPORT_SYMBOL(ide_dma_off_quietly);
 #endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
 
 /**
- *	__ide_dma_off	-	disable DMA on a device
+ *	ide_dma_off	-	disable DMA on a device
  *	@drive: drive to disable DMA on
  *
  *	Disable IDE DMA for a device on this IDE controller.
  *	Inform the user that DMA has been disabled.
  */
 
-int __ide_dma_off (ide_drive_t *drive)
+void ide_dma_off(ide_drive_t *drive)
 {
 	printk(KERN_INFO "%s: DMA disabled\n", drive->name);
-	return HWIF(drive)->ide_dma_off_quietly(drive);
+	drive->hwif->dma_off_quietly(drive);
 }
 
-EXPORT_SYMBOL(__ide_dma_off);
+EXPORT_SYMBOL(ide_dma_off);
 
 #ifdef CONFIG_BLK_DEV_IDEDMA_PCI
 /**
@@ -758,7 +754,7 @@ void ide_dma_verbose(ide_drive_t *drive)
 	return;
 bug_dma_off:
 	printk(", BUG DMA OFF");
-	hwif->ide_dma_off_quietly(drive);
+	hwif->dma_off_quietly(drive);
 	return;
 }
 
@@ -773,7 +769,8 @@ int ide_set_dma(ide_drive_t *drive)
 
 	switch(rc) {
 	case -1: /* DMA needs to be disabled */
-		return hwif->ide_dma_off_quietly(drive);
+		hwif->dma_off_quietly(drive);
+		return 0;
 	case  0: /* DMA needs to be enabled */
 		return hwif->ide_dma_on(drive);
 	case  1: /* DMA setting cannot be changed */
@@ -937,10 +934,10 @@ void ide_setup_dma (ide_hwif_t *hwif, unsigned long dma_base, unsigned int num_p
 	if (!(hwif->dma_prdtable))
 		hwif->dma_prdtable	= (hwif->dma_base + 4);
 
-	if (!hwif->ide_dma_off_quietly)
-		hwif->ide_dma_off_quietly = &__ide_dma_off_quietly;
-	if (!hwif->ide_dma_host_off)
-		hwif->ide_dma_host_off = &__ide_dma_host_off;
+	if (!hwif->dma_off_quietly)
+		hwif->dma_off_quietly = &ide_dma_off_quietly;
+	if (!hwif->dma_host_off)
+		hwif->dma_host_off = &ide_dma_host_off;
 	if (!hwif->ide_dma_on)
 		hwif->ide_dma_on = &__ide_dma_on;
 	if (!hwif->ide_dma_host_on)

commit 3608b5d71a52c053787dbad6af20c25f7e0b75a9
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Feb 17 02:40:26 2007 +0100

    ide: add ide_set_dma() helper (v2)
    
    * add ide_set_dma() helper and make ide_hwif_t.ide_dma_check return
      -1 when DMA needs to be disabled (== need to call ->ide_dma_off_quietly)
       0 when DMA needs to be enabled  (== need to call ->ide_dma_on)
       1 when DMA setting shouldn't be changed
    * fix IDE code to use ide_set_dma() instead if using ->ide_dma_check directly
    
    v2:
    * updated for scc_pata
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 1a288e5307d3..4fbcea4c1025 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -348,15 +348,14 @@ EXPORT_SYMBOL_GPL(ide_destroy_dmatable);
 static int config_drive_for_dma (ide_drive_t *drive)
 {
 	struct hd_driveid *id = drive->id;
-	ide_hwif_t *hwif = HWIF(drive);
 
-	if ((id->capability & 1) && hwif->autodma) {
+	if ((id->capability & 1) && drive->hwif->autodma) {
 		/*
 		 * Enable DMA on any drive that has
 		 * UltraDMA (mode 0/1/2/3/4/5/6) enabled
 		 */
 		if ((id->field_valid & 4) && ((id->dma_ultra >> 8) & 0x7f))
-			return hwif->ide_dma_on(drive);
+			return 0;
 		/*
 		 * Enable DMA on any drive that has mode2 DMA
 		 * (multi or single) enabled
@@ -364,14 +363,14 @@ static int config_drive_for_dma (ide_drive_t *drive)
 		if (id->field_valid & 2)	/* regular DMA */
 			if ((id->dma_mword & 0x404) == 0x404 ||
 			    (id->dma_1word & 0x404) == 0x404)
-				return hwif->ide_dma_on(drive);
+				return 0;
 
 		/* Consult the list of known "good" drives */
 		if (__ide_dma_good_drive(drive))
-			return hwif->ide_dma_on(drive);
+			return 0;
 	}
-//	if (hwif->tuneproc != NULL) hwif->tuneproc(drive, 255);
-	return hwif->ide_dma_off_quietly(drive);
+
+	return -1;
 }
 
 /**
@@ -765,6 +764,30 @@ void ide_dma_verbose(ide_drive_t *drive)
 
 EXPORT_SYMBOL(ide_dma_verbose);
 
+int ide_set_dma(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	int rc;
+
+	rc = hwif->ide_dma_check(drive);
+
+	switch(rc) {
+	case -1: /* DMA needs to be disabled */
+		return hwif->ide_dma_off_quietly(drive);
+	case  0: /* DMA needs to be enabled */
+		return hwif->ide_dma_on(drive);
+	case  1: /* DMA setting cannot be changed */
+		break;
+	default:
+		BUG();
+		break;
+	}
+
+	return rc;
+}
+
+EXPORT_SYMBOL_GPL(ide_set_dma);
+
 #ifdef CONFIG_BLK_DEV_IDEDMA_PCI
 int __ide_dma_lostirq (ide_drive_t *drive)
 {

commit 2ad1e558a2305c2b3d5099ee2f4a5929307c20ca
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Feb 17 02:40:25 2007 +0100

    ide: convert ide_hwif_t.mmio into flag (v2)
    
    All users of ->mmio == 1 are gone so convert ->mmio into flag.
    
    Noticed by Alan Cox.
    
    v2:
    * updated for scc_pata
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index b7b663ee7343..1a288e5307d3 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -565,7 +565,7 @@ int ide_dma_setup(ide_drive_t *drive)
 	}
 
 	/* PRD table */
-	if (hwif->mmio == 2)
+	if (hwif->mmio)
 		writel(hwif->dmatable_dma, (void __iomem *)hwif->dma_prdtable);
 	else
 		outl(hwif->dmatable_dma, hwif->dma_prdtable);
@@ -815,7 +815,7 @@ int ide_release_dma(ide_hwif_t *hwif)
 {
 	ide_release_dma_engine(hwif);
 
-	if (hwif->mmio == 2)
+	if (hwif->mmio)
 		return 1;
 	else
 		return ide_release_iomio_dma(hwif);
@@ -884,9 +884,9 @@ static int ide_iomio_dma(ide_hwif_t *hwif, unsigned long base, unsigned int port
 
 static int ide_dma_iobase(ide_hwif_t *hwif, unsigned long base, unsigned int ports)
 {
-	if (hwif->mmio == 2)
+	if (hwif->mmio)
 		return ide_mapped_mmio_dma(hwif, base,ports);
-	BUG_ON(hwif->mmio == 1);
+
 	return ide_iomio_dma(hwif, base, ports);
 }
 

commit 0ecdca26e556eae9668ce6de9554757dddb942ef
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Feb 17 02:40:25 2007 +0100

    ide: use PIO/MMIO operations directly where possible (v2)
    
    This results in smaller/faster/simpler code and allows future optimizations.
    Also remove no longer needed ide[_mm]_{inl,outl}() and ide_hwif_t.{INL,OUTL}.
    
    v2:
    * updated for scc_pata
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 941846c21624..b7b663ee7343 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -565,7 +565,10 @@ int ide_dma_setup(ide_drive_t *drive)
 	}
 
 	/* PRD table */
-	hwif->OUTL(hwif->dmatable_dma, hwif->dma_prdtable);
+	if (hwif->mmio == 2)
+		writel(hwif->dmatable_dma, (void __iomem *)hwif->dma_prdtable);
+	else
+		outl(hwif->dmatable_dma, hwif->dma_prdtable);
 
 	/* specify r/w */
 	hwif->OUTB(reading, hwif->dma_command);

commit 7569e8dc2213ecc47024ea5edbadc8736487d926
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Feb 17 02:40:25 2007 +0100

    ide: add ide_use_fast_pio() helper (v3)
    
    * add ide_use_fast_pio() helper for use by host drivers
    
    * add DMA capability and hwif->autodma checks to ide_use_dma()
    
      - au1xxx-ide/it8213/it821x drivers didn't check for (id->capability & 1)
    
        [ for the IT8211/2 in SMART mode this check shouldn't be made but since
          in it821x_fixups() we set DMA bit explicitly:
    
                   if(strstr(id->model, "Integrated Technology Express")) {
                           /* In raid mode the ident block is slightly buggy
                              We need to set the bits so that the IDE layer knows
                              LBA28. LBA48 and DMA ar valid */
                           id->capability |= 3;            /* LBA28, DMA */
    
           we are better off using generic helper if we can ]
    
      - ide-cris driver didn't set ->autodma
    
        [ before the patch hwif->autodma was only checked in the chipset specific
          hwif->ide_dma_check implementations, for ide-cris it is cris_dma_check()
          function so there no behavior change here ]
    
    v2:
    * updated patch description (thanks to Alan Cox for the feedback)
    
    v3:
    * updated for scc_pata driver
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 56efed6742d4..941846c21624 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -680,6 +680,9 @@ int ide_use_dma(ide_drive_t *drive)
 	struct hd_driveid *id = drive->id;
 	ide_hwif_t *hwif = drive->hwif;
 
+	if ((id->capability & 1) == 0 || drive->autodma == 0)
+		return 0;
+
 	/* consult the list of known "bad" drives */
 	if (__ide_dma_bad_drive(drive))
 		return 0;

commit 3f63c5e88a5ce45b423f3712293f1664115b09c0
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Tue Oct 3 01:14:25 2006 -0700

    [PATCH] ide: remove dma_base2 field from ide_hwif_t
    
    Remove dma_base2 field from ide_hwif_t as it's used only in 2 drivers and
    without great need.
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: John Keller <jpk@sgi.com>
    Signed-off-by: Jeremy Higdon <jeremy@sgi.com>
    Acked-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Bartlomiej Zolnierkiewicz <B.Zolnierkiewicz@elka.pw.edu.pl>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 9069766f236e..56efed6742d4 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -799,8 +799,6 @@ static int ide_release_iomio_dma(ide_hwif_t *hwif)
 	release_region(hwif->dma_base, 8);
 	if (hwif->extra_ports)
 		release_region(hwif->extra_base, hwif->extra_ports);
-	if (hwif->dma_base2)
-		release_region(hwif->dma_base, 8);
 	return 1;
 }
 
@@ -872,19 +870,9 @@ static int ide_iomio_dma(ide_hwif_t *hwif, unsigned long base, unsigned int port
 	}
 
 	if(hwif->mate)
-		hwif->dma_master = (hwif->channel) ? hwif->mate->dma_base : base;
+		hwif->dma_master = (hwif->channel) ? hwif->mate->dma_base:base;
 	else
 		hwif->dma_master = base;
-	if (hwif->dma_base2) {
-		if (!request_region(hwif->dma_base2, ports, hwif->name))
-		{
-			printk(" -- Error, secondary ports in use.\n");
-			release_region(base, ports);
-			if (hwif->extra_ports)
-				release_region(hwif->extra_base, hwif->extra_ports);
-			return 1;
-		}
-	}
 	return 0;
 }
 

commit 27ac6036f31dea8117ecc525e0dbfd17b23e8c09
Author: Adrian Bunk <bunk@stusta.de>
Date:   Tue Oct 3 01:14:24 2006 -0700

    [PATCH] drivers/ide/: cleanups
    
    - setup-pci.c: remove the unused ide_pci_unregister_driver()
    - ide-dma.c: remove the unused EXPORT_SYMBOL_GPL(ide_in_drive_list)
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Acked-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Bartlomiej Zolnierkiewicz <B.Zolnierkiewicz@elka.pw.edu.pl>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 53feaf82576e..9069766f236e 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -151,8 +151,6 @@ int ide_in_drive_list(struct hd_driveid *id, const struct drive_list_entry *driv
 	return 0;
 }
 
-EXPORT_SYMBOL_GPL(ide_in_drive_list);
-
 /**
  *	ide_dma_intr	-	IDE DMA interrupt handler
  *	@drive: the drive the interrupt is for

commit 14e0a193209aeea810ad3d66388f422dc79c5b40
Author: Kirill Smelkov <kirr@mns.spb.ru>
Date:   Tue Oct 3 01:14:18 2006 -0700

    [PATCH] ide: fix revision comparison in ide_in_drive_list
    
    Fix ide_in_drive_list: drive_table->id_firmware should be searched *in*
    id->fw_rev, not vice versa.
    
    Signed-off-by: Kirill Smelkov <kirr@mns.spb.ru>
    Cc: Bartlomiej Zolnierkiewicz <B.Zolnierkiewicz@elka.pw.edu.pl>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 22ef73eb1f68..53feaf82576e 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -145,7 +145,7 @@ int ide_in_drive_list(struct hd_driveid *id, const struct drive_list_entry *driv
 {
 	for ( ; drive_table->id_model ; drive_table++)
 		if ((!strcmp(drive_table->id_model, id->model)) &&
-		    ((strstr(drive_table->id_firmware, id->fw_rev)) ||
+		    ((strstr(id->fw_rev, drive_table->id_firmware)) ||
 		     (!strcmp(drive_table->id_firmware, "ALL"))))
 			return 1;
 	return 0;

commit dc844e05913b84d09e86d88c0f861ef0afbee2fd
Author: Sergei Shtylylov <sshtylyov@ru.mvista.com>
Date:   Tue Oct 3 01:14:14 2006 -0700

    [PATCH] IDE: always release DMA engine
    
    Release the DMA engine for the custom mapping IDE drivers also (for
    example, siimage.c does allocate it in both I/O-mapped and custom-mapped
    modes).  Remove useless code from the error path of
    ide_allocate_dma_engine().
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: Bartlomiej Zolnierkiewicz <B.Zolnierkiewicz@elka.pw.edu.pl>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 9937fa7da546..22ef73eb1f68 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -809,15 +809,14 @@ static int ide_release_iomio_dma(ide_hwif_t *hwif)
 /*
  * Needed for allowing full modular support of ide-driver
  */
-int ide_release_dma (ide_hwif_t *hwif)
+int ide_release_dma(ide_hwif_t *hwif)
 {
+	ide_release_dma_engine(hwif);
+
 	if (hwif->mmio == 2)
 		return 1;
-	if (hwif->chipset == ide_etrax100)
-		return 1;
-
-	ide_release_dma_engine(hwif);
-	return ide_release_iomio_dma(hwif);
+	else
+		return ide_release_iomio_dma(hwif);
 }
 
 static int ide_allocate_dma_engine(ide_hwif_t *hwif)
@@ -829,10 +828,9 @@ static int ide_allocate_dma_engine(ide_hwif_t *hwif)
 	if (hwif->dmatable_cpu)
 		return 0;
 
-	printk(KERN_ERR "%s: -- Error, unable to allocate%s DMA table(s).\n",
-			hwif->cds->name, !hwif->dmatable_cpu ? " CPU" : "");
+	printk(KERN_ERR "%s: -- Error, unable to allocate DMA table.\n",
+	       hwif->cds->name);
 
-	ide_release_dma_engine(hwif);
 	return 1;
 }
 

commit 020e322de3ff75d32daa58e431aad07071da27c6
Author: Sergei Shtylylov <sshtylyov@ru.mvista.com>
Date:   Tue Oct 3 01:14:13 2006 -0700

    [PATCH] IDE: claim extra DMA ports regardless of channel
    
    - Claim extra DMA I/O ports regardless of what IDE channels are
      present/enabled.
    
    - Remove extra ports handling from ide_mapped_mmio_dma() since it's not
      applicable to the custom-mapping IDE drivers.
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: Bartlomiej Zolnierkiewicz <B.Zolnierkiewicz@elka.pw.edu.pl>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index c3546fe9af63..9937fa7da546 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -798,9 +798,9 @@ static int ide_release_dma_engine(ide_hwif_t *hwif)
 
 static int ide_release_iomio_dma(ide_hwif_t *hwif)
 {
-	if ((hwif->dma_extra) && (hwif->channel == 0))
-		release_region((hwif->dma_base + 16), hwif->dma_extra);
 	release_region(hwif->dma_base, 8);
+	if (hwif->extra_ports)
+		release_region(hwif->extra_base, hwif->extra_ports);
 	if (hwif->dma_base2)
 		release_region(hwif->dma_base, 8);
 	return 1;
@@ -840,9 +840,7 @@ static int ide_mapped_mmio_dma(ide_hwif_t *hwif, unsigned long base, unsigned in
 {
 	printk(KERN_INFO "    %s: MMIO-DMA ", hwif->name);
 
-	hwif->dma_base = base;
-	if (hwif->cds->extra && hwif->channel == 0)
-		hwif->dma_extra = hwif->cds->extra;
+ 	hwif->dma_base = base;
 
 	if(hwif->mate)
 		hwif->dma_master = (hwif->channel) ? hwif->mate->dma_base : base;
@@ -854,17 +852,29 @@ static int ide_mapped_mmio_dma(ide_hwif_t *hwif, unsigned long base, unsigned in
 static int ide_iomio_dma(ide_hwif_t *hwif, unsigned long base, unsigned int ports)
 {
 	printk(KERN_INFO "    %s: BM-DMA at 0x%04lx-0x%04lx",
-		hwif->name, base, base + ports - 1);
+	       hwif->name, base, base + ports - 1);
+
 	if (!request_region(base, ports, hwif->name)) {
 		printk(" -- Error, ports in use.\n");
 		return 1;
 	}
+
 	hwif->dma_base = base;
-	if ((hwif->cds->extra) && (hwif->channel == 0)) {
-		request_region(base+16, hwif->cds->extra, hwif->cds->name);
-		hwif->dma_extra = hwif->cds->extra;
+
+	if (hwif->cds->extra) {
+		hwif->extra_base = base + (hwif->channel ? 8 : 16);
+
+		if (!hwif->mate || !hwif->mate->extra_ports) {
+			if (!request_region(hwif->extra_base,
+					    hwif->cds->extra, hwif->cds->name)) {
+				printk(" -- Error, extra ports in use.\n");
+				release_region(base, ports);
+				return 1;
+			}
+			hwif->extra_ports = hwif->cds->extra;
+		}
 	}
-	
+
 	if(hwif->mate)
 		hwif->dma_master = (hwif->channel) ? hwif->mate->dma_base : base;
 	else
@@ -874,6 +884,8 @@ static int ide_iomio_dma(ide_hwif_t *hwif, unsigned long base, unsigned int port
 		{
 			printk(" -- Error, secondary ports in use.\n");
 			release_region(base, ports);
+			if (hwif->extra_ports)
+				release_region(hwif->extra_base, hwif->extra_ports);
 			return 1;
 		}
 	}

commit 4aff5e2333c9a1609662f2091f55c3f6fffdad36
Author: Jens Axboe <axboe@suse.de>
Date:   Thu Aug 10 08:44:47 2006 +0200

    [PATCH] Split struct request ->flags into two parts
    
    Right now ->flags is a bit of a mess: some are request types, and
    others are just modifiers. Clean this up by splitting it into
    ->cmd_type and ->cmd_flags. This allows introduction of generic
    Linux block message types, useful for sending generic Linux commands
    to block devices.
    
    Signed-off-by: Jens Axboe <axboe@suse.de>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 7c3a13e1cf64..c3546fe9af63 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -205,7 +205,7 @@ int ide_build_sglist(ide_drive_t *drive, struct request *rq)
 	ide_hwif_t *hwif = HWIF(drive);
 	struct scatterlist *sg = hwif->sg_table;
 
-	BUG_ON((rq->flags & REQ_DRIVE_TASKFILE) && rq->nr_sectors > 256);
+	BUG_ON((rq->cmd_type == REQ_TYPE_ATA_TASKFILE) && rq->nr_sectors > 256);
 
 	ide_map_sg(drive, rq);
 

commit 0a8348d08677ad77ee353f96eb8745c693a05a13
Author: Jens Axboe <axboe@suse.de>
Date:   Fri Jul 28 08:58:26 2006 +0200

    [PATCH] ide: if the id fields looks screwy, disable DMA
    
    It's the safer choice. Originally due to a bug in itx821x, but a
    generally sound thing to do.
    
    Signed-off-by: Jens Axboe <axboe@suse.de>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 98918fb6b2ce..7c3a13e1cf64 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -750,7 +750,7 @@ void ide_dma_verbose(ide_drive_t *drive)
 			goto bug_dma_off;
 		printk(", DMA");
 	} else if (id->field_valid & 1) {
-		printk(", BUG");
+		goto bug_dma_off;
 	}
 	return;
 bug_dma_off:

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jrn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jrn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 783a2475ee8b..98918fb6b2ce 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -74,7 +74,6 @@
  *
  */
 
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/types.h>
 #include <linux/kernel.h>

commit 125e18745f16685f69a34fd6130d47598fc4bf54
Author: Eric Sesterhenn <snakebyte@gmx.de>
Date:   Fri Jun 23 02:06:06 2006 -0700

    [PATCH] More BUG_ON conversion
    
    Signed-off-by: Eric Sesterhenn <snakebyte@gmx.de>
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Bartlomiej Zolnierkiewicz <B.Zolnierkiewicz@elka.pw.edu.pl>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Acked-by: "Salyzyn, Mark" <mark_salyzyn@adaptec.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index c481be8b807f..783a2475ee8b 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -206,8 +206,7 @@ int ide_build_sglist(ide_drive_t *drive, struct request *rq)
 	ide_hwif_t *hwif = HWIF(drive);
 	struct scatterlist *sg = hwif->sg_table;
 
-	if ((rq->flags & REQ_DRIVE_TASKFILE) && rq->nr_sectors > 256)
-		BUG();
+	BUG_ON((rq->flags & REQ_DRIVE_TASKFILE) && rq->nr_sectors > 256);
 
 	ide_map_sg(drive, rq);
 
@@ -947,8 +946,7 @@ void ide_setup_dma (ide_hwif_t *hwif, unsigned long dma_base, unsigned int num_p
 	}
 	printk("\n");
 
-	if (!(hwif->dma_master))
-		BUG();
+	BUG_ON(!hwif->dma_master);
 }
 
 EXPORT_SYMBOL_GPL(ide_setup_dma);

commit 53b3531bbbf70ac7551b32d1acc229d94de52658
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Fri Mar 24 03:16:13 2006 -0800

    [PATCH] s/;;/;/g
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 0523da77425a..c481be8b807f 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -175,7 +175,7 @@ ide_startstop_t ide_dma_intr (ide_drive_t *drive)
 			if (rq->rq_disk) {
 				ide_driver_t *drv;
 
-				drv = *(ide_driver_t **)rq->rq_disk->private_data;;
+				drv = *(ide_driver_t **)rq->rq_disk->private_data;
 				drv->end_request(drive, 1, rq->nr_sectors);
 			} else
 				ide_end_request(drive, 1, rq->nr_sectors);

commit 65e5f2e3b457b6b20a5c4481312189d141a33d24
Author: Jordan Crouse <jordan.crouse@amd.com>
Date:   Thu Dec 15 02:16:18 2005 +0100

    [PATCH] ide: core modifications for AU1200
    
    bart: slightly modified by me
    
    Signed-off-by: Jordan Crouse <jordan.crouse@amd.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 1e1531334c25..0523da77425a 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -90,11 +90,6 @@
 #include <asm/io.h>
 #include <asm/irq.h>
 
-struct drive_list_entry {
-	const char *id_model;
-	const char *id_firmware;
-};
-
 static const struct drive_list_entry drive_whitelist [] = {
 
 	{ "Micropolis 2112A"	,       "ALL"		},
@@ -139,7 +134,7 @@ static const struct drive_list_entry drive_blacklist [] = {
 };
 
 /**
- *	in_drive_list	-	look for drive in black/white list
+ *	ide_in_drive_list	-	look for drive in black/white list
  *	@id: drive identifier
  *	@drive_table: list to inspect
  *
@@ -147,7 +142,7 @@ static const struct drive_list_entry drive_blacklist [] = {
  *	Returns 1 if the drive is found in the table.
  */
 
-static int in_drive_list(struct hd_driveid *id, const struct drive_list_entry *drive_table)
+int ide_in_drive_list(struct hd_driveid *id, const struct drive_list_entry *drive_table)
 {
 	for ( ; drive_table->id_model ; drive_table++)
 		if ((!strcmp(drive_table->id_model, id->model)) &&
@@ -157,6 +152,8 @@ static int in_drive_list(struct hd_driveid *id, const struct drive_list_entry *d
 	return 0;
 }
 
+EXPORT_SYMBOL_GPL(ide_in_drive_list);
+
 /**
  *	ide_dma_intr	-	IDE DMA interrupt handler
  *	@drive: the drive the interrupt is for
@@ -663,7 +660,7 @@ int __ide_dma_bad_drive (ide_drive_t *drive)
 {
 	struct hd_driveid *id = drive->id;
 
-	int blacklist = in_drive_list(id, drive_blacklist);
+	int blacklist = ide_in_drive_list(id, drive_blacklist);
 	if (blacklist) {
 		printk(KERN_WARNING "%s: Disabling (U)DMA for %s (blacklisted)\n",
 				    drive->name, id->model);
@@ -677,7 +674,7 @@ EXPORT_SYMBOL(__ide_dma_bad_drive);
 int __ide_dma_good_drive (ide_drive_t *drive)
 {
 	struct hd_driveid *id = drive->id;
-	return in_drive_list(id, drive_whitelist);
+	return ide_in_drive_list(id, drive_whitelist);
 }
 
 EXPORT_SYMBOL(__ide_dma_good_drive);

commit 58ecd15652979f2001dc296dcfd303cc1bd33ce7
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Jun 27 15:24:24 2005 -0700

    [PATCH] ide: samsung SN-124 works perfectly well with DMA
    
    Been in Red Hat products for ages
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Acked-by: Bartlomiej Zolnierkiewicz <B.Zolnierkiewicz@elka.pw.edu.pl>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 2d2eefb610dd..1e1531334c25 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -132,7 +132,6 @@ static const struct drive_list_entry drive_blacklist [] = {
 	{ "SAMSUNG CD-ROM SC-148C",	"ALL"		},
 	{ "SAMSUNG CD-ROM SC",	"ALL"		},
 	{ "SanDisk SDP3B-64"	,	"ALL"		},
-	{ "SAMSUNG CD-ROM SN-124",	"ALL"		},
 	{ "ATAPI CD-ROM DRIVE 40X MAXIMUM",	"ALL"		},
 	{ "_NEC DV5800A",               "ALL"           },  
 	{ NULL			,	NULL		}

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
new file mode 100644
index 000000000000..2d2eefb610dd
--- /dev/null
+++ b/drivers/ide/ide-dma.c
@@ -0,0 +1,959 @@
+/*
+ *  linux/drivers/ide/ide-dma.c		Version 4.10	June 9, 2000
+ *
+ *  Copyright (c) 1999-2000	Andre Hedrick <andre@linux-ide.org>
+ *  May be copied or modified under the terms of the GNU General Public License
+ */
+
+/*
+ *  Special Thanks to Mark for his Six years of work.
+ *
+ *  Copyright (c) 1995-1998  Mark Lord
+ *  May be copied or modified under the terms of the GNU General Public License
+ */
+
+/*
+ * This module provides support for the bus-master IDE DMA functions
+ * of various PCI chipsets, including the Intel PIIX (i82371FB for
+ * the 430 FX chipset), the PIIX3 (i82371SB for the 430 HX/VX and 
+ * 440 chipsets), and the PIIX4 (i82371AB for the 430 TX chipset)
+ * ("PIIX" stands for "PCI ISA IDE Xcellerator").
+ *
+ * Pretty much the same code works for other IDE PCI bus-mastering chipsets.
+ *
+ * DMA is supported for all IDE devices (disk drives, cdroms, tapes, floppies).
+ *
+ * By default, DMA support is prepared for use, but is currently enabled only
+ * for drives which already have DMA enabled (UltraDMA or mode 2 multi/single),
+ * or which are recognized as "good" (see table below).  Drives with only mode0
+ * or mode1 (multi/single) DMA should also work with this chipset/driver
+ * (eg. MC2112A) but are not enabled by default.
+ *
+ * Use "hdparm -i" to view modes supported by a given drive.
+ *
+ * The hdparm-3.5 (or later) utility can be used for manually enabling/disabling
+ * DMA support, but must be (re-)compiled against this kernel version or later.
+ *
+ * To enable DMA, use "hdparm -d1 /dev/hd?" on a per-drive basis after booting.
+ * If problems arise, ide.c will disable DMA operation after a few retries.
+ * This error recovery mechanism works and has been extremely well exercised.
+ *
+ * IDE drives, depending on their vintage, may support several different modes
+ * of DMA operation.  The boot-time modes are indicated with a "*" in
+ * the "hdparm -i" listing, and can be changed with *knowledgeable* use of
+ * the "hdparm -X" feature.  There is seldom a need to do this, as drives
+ * normally power-up with their "best" PIO/DMA modes enabled.
+ *
+ * Testing has been done with a rather extensive number of drives,
+ * with Quantum & Western Digital models generally outperforming the pack,
+ * and Fujitsu & Conner (and some Seagate which are really Conner) drives
+ * showing more lackluster throughput.
+ *
+ * Keep an eye on /var/adm/messages for "DMA disabled" messages.
+ *
+ * Some people have reported trouble with Intel Zappa motherboards.
+ * This can be fixed by upgrading the AMI BIOS to version 1.00.04.BS0,
+ * available from ftp://ftp.intel.com/pub/bios/10004bs0.exe
+ * (thanks to Glen Morrell <glen@spin.Stanford.edu> for researching this).
+ *
+ * Thanks to "Christopher J. Reimer" <reimer@doe.carleton.ca> for
+ * fixing the problem with the BIOS on some Acer motherboards.
+ *
+ * Thanks to "Benoit Poulot-Cazajous" <poulot@chorus.fr> for testing
+ * "TX" chipset compatibility and for providing patches for the "TX" chipset.
+ *
+ * Thanks to Christian Brunner <chb@muc.de> for taking a good first crack
+ * at generic DMA -- his patches were referred to when preparing this code.
+ *
+ * Most importantly, thanks to Robert Bringman <rob@mars.trion.com>
+ * for supplying a Promise UDMA board & WD UDMA drive for this work!
+ *
+ * And, yes, Intel Zappa boards really *do* use both PIIX IDE ports.
+ *
+ * ATA-66/100 and recovery functions, I forgot the rest......
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/timer.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/ide.h>
+#include <linux/delay.h>
+#include <linux/scatterlist.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+
+struct drive_list_entry {
+	const char *id_model;
+	const char *id_firmware;
+};
+
+static const struct drive_list_entry drive_whitelist [] = {
+
+	{ "Micropolis 2112A"	,       "ALL"		},
+	{ "CONNER CTMA 4000"	,       "ALL"		},
+	{ "CONNER CTT8000-A"	,       "ALL"		},
+	{ "ST34342A"		,	"ALL"		},
+	{ NULL			,	NULL		}
+};
+
+static const struct drive_list_entry drive_blacklist [] = {
+
+	{ "WDC AC11000H"	,	"ALL"		},
+	{ "WDC AC22100H"	,	"ALL"		},
+	{ "WDC AC32500H"	,	"ALL"		},
+	{ "WDC AC33100H"	,	"ALL"		},
+	{ "WDC AC31600H"	,	"ALL"		},
+	{ "WDC AC32100H"	,	"24.09P07"	},
+	{ "WDC AC23200L"	,	"21.10N21"	},
+	{ "Compaq CRD-8241B"	,	"ALL"		},
+	{ "CRD-8400B"		,	"ALL"		},
+	{ "CRD-8480B",			"ALL"		},
+	{ "CRD-8482B",			"ALL"		},
+ 	{ "CRD-84"		,	"ALL"		},
+	{ "SanDisk SDP3B"	,	"ALL"		},
+	{ "SanDisk SDP3B-64"	,	"ALL"		},
+	{ "SANYO CD-ROM CRD"	,	"ALL"		},
+	{ "HITACHI CDR-8"	,	"ALL"		},
+	{ "HITACHI CDR-8335"	,	"ALL"		},
+	{ "HITACHI CDR-8435"	,	"ALL"		},
+	{ "Toshiba CD-ROM XM-6202B"	,	"ALL"		},
+	{ "CD-532E-A"		,	"ALL"		},
+	{ "E-IDE CD-ROM CR-840",	"ALL"		},
+	{ "CD-ROM Drive/F5A",	"ALL"		},
+	{ "WPI CDD-820",		"ALL"		},
+	{ "SAMSUNG CD-ROM SC-148C",	"ALL"		},
+	{ "SAMSUNG CD-ROM SC",	"ALL"		},
+	{ "SanDisk SDP3B-64"	,	"ALL"		},
+	{ "SAMSUNG CD-ROM SN-124",	"ALL"		},
+	{ "ATAPI CD-ROM DRIVE 40X MAXIMUM",	"ALL"		},
+	{ "_NEC DV5800A",               "ALL"           },  
+	{ NULL			,	NULL		}
+
+};
+
+/**
+ *	in_drive_list	-	look for drive in black/white list
+ *	@id: drive identifier
+ *	@drive_table: list to inspect
+ *
+ *	Look for a drive in the blacklist and the whitelist tables
+ *	Returns 1 if the drive is found in the table.
+ */
+
+static int in_drive_list(struct hd_driveid *id, const struct drive_list_entry *drive_table)
+{
+	for ( ; drive_table->id_model ; drive_table++)
+		if ((!strcmp(drive_table->id_model, id->model)) &&
+		    ((strstr(drive_table->id_firmware, id->fw_rev)) ||
+		     (!strcmp(drive_table->id_firmware, "ALL"))))
+			return 1;
+	return 0;
+}
+
+/**
+ *	ide_dma_intr	-	IDE DMA interrupt handler
+ *	@drive: the drive the interrupt is for
+ *
+ *	Handle an interrupt completing a read/write DMA transfer on an 
+ *	IDE device
+ */
+ 
+ide_startstop_t ide_dma_intr (ide_drive_t *drive)
+{
+	u8 stat = 0, dma_stat = 0;
+
+	dma_stat = HWIF(drive)->ide_dma_end(drive);
+	stat = HWIF(drive)->INB(IDE_STATUS_REG);	/* get drive status */
+	if (OK_STAT(stat,DRIVE_READY,drive->bad_wstat|DRQ_STAT)) {
+		if (!dma_stat) {
+			struct request *rq = HWGROUP(drive)->rq;
+
+			if (rq->rq_disk) {
+				ide_driver_t *drv;
+
+				drv = *(ide_driver_t **)rq->rq_disk->private_data;;
+				drv->end_request(drive, 1, rq->nr_sectors);
+			} else
+				ide_end_request(drive, 1, rq->nr_sectors);
+			return ide_stopped;
+		}
+		printk(KERN_ERR "%s: dma_intr: bad DMA status (dma_stat=%x)\n", 
+		       drive->name, dma_stat);
+	}
+	return ide_error(drive, "dma_intr", stat);
+}
+
+EXPORT_SYMBOL_GPL(ide_dma_intr);
+
+#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
+/**
+ *	ide_build_sglist	-	map IDE scatter gather for DMA I/O
+ *	@drive: the drive to build the DMA table for
+ *	@rq: the request holding the sg list
+ *
+ *	Perform the PCI mapping magic necessary to access the source or
+ *	target buffers of a request via PCI DMA. The lower layers of the
+ *	kernel provide the necessary cache management so that we can
+ *	operate in a portable fashion
+ */
+
+int ide_build_sglist(ide_drive_t *drive, struct request *rq)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	struct scatterlist *sg = hwif->sg_table;
+
+	if ((rq->flags & REQ_DRIVE_TASKFILE) && rq->nr_sectors > 256)
+		BUG();
+
+	ide_map_sg(drive, rq);
+
+	if (rq_data_dir(rq) == READ)
+		hwif->sg_dma_direction = PCI_DMA_FROMDEVICE;
+	else
+		hwif->sg_dma_direction = PCI_DMA_TODEVICE;
+
+	return pci_map_sg(hwif->pci_dev, sg, hwif->sg_nents, hwif->sg_dma_direction);
+}
+
+EXPORT_SYMBOL_GPL(ide_build_sglist);
+
+/**
+ *	ide_build_dmatable	-	build IDE DMA table
+ *
+ *	ide_build_dmatable() prepares a dma request. We map the command
+ *	to get the pci bus addresses of the buffers and then build up
+ *	the PRD table that the IDE layer wants to be fed. The code
+ *	knows about the 64K wrap bug in the CS5530.
+ *
+ *	Returns the number of built PRD entries if all went okay,
+ *	returns 0 otherwise.
+ *
+ *	May also be invoked from trm290.c
+ */
+ 
+int ide_build_dmatable (ide_drive_t *drive, struct request *rq)
+{
+	ide_hwif_t *hwif	= HWIF(drive);
+	unsigned int *table	= hwif->dmatable_cpu;
+	unsigned int is_trm290	= (hwif->chipset == ide_trm290) ? 1 : 0;
+	unsigned int count = 0;
+	int i;
+	struct scatterlist *sg;
+
+	hwif->sg_nents = i = ide_build_sglist(drive, rq);
+
+	if (!i)
+		return 0;
+
+	sg = hwif->sg_table;
+	while (i) {
+		u32 cur_addr;
+		u32 cur_len;
+
+		cur_addr = sg_dma_address(sg);
+		cur_len = sg_dma_len(sg);
+
+		/*
+		 * Fill in the dma table, without crossing any 64kB boundaries.
+		 * Most hardware requires 16-bit alignment of all blocks,
+		 * but the trm290 requires 32-bit alignment.
+		 */
+
+		while (cur_len) {
+			if (count++ >= PRD_ENTRIES) {
+				printk(KERN_ERR "%s: DMA table too small\n", drive->name);
+				goto use_pio_instead;
+			} else {
+				u32 xcount, bcount = 0x10000 - (cur_addr & 0xffff);
+
+				if (bcount > cur_len)
+					bcount = cur_len;
+				*table++ = cpu_to_le32(cur_addr);
+				xcount = bcount & 0xffff;
+				if (is_trm290)
+					xcount = ((xcount >> 2) - 1) << 16;
+				if (xcount == 0x0000) {
+	/* 
+	 * Most chipsets correctly interpret a length of 0x0000 as 64KB,
+	 * but at least one (e.g. CS5530) misinterprets it as zero (!).
+	 * So here we break the 64KB entry into two 32KB entries instead.
+	 */
+					if (count++ >= PRD_ENTRIES) {
+						printk(KERN_ERR "%s: DMA table too small\n", drive->name);
+						goto use_pio_instead;
+					}
+					*table++ = cpu_to_le32(0x8000);
+					*table++ = cpu_to_le32(cur_addr + 0x8000);
+					xcount = 0x8000;
+				}
+				*table++ = cpu_to_le32(xcount);
+				cur_addr += bcount;
+				cur_len -= bcount;
+			}
+		}
+
+		sg++;
+		i--;
+	}
+
+	if (count) {
+		if (!is_trm290)
+			*--table |= cpu_to_le32(0x80000000);
+		return count;
+	}
+	printk(KERN_ERR "%s: empty DMA table?\n", drive->name);
+use_pio_instead:
+	pci_unmap_sg(hwif->pci_dev,
+		     hwif->sg_table,
+		     hwif->sg_nents,
+		     hwif->sg_dma_direction);
+	return 0; /* revert to PIO for this request */
+}
+
+EXPORT_SYMBOL_GPL(ide_build_dmatable);
+
+/**
+ *	ide_destroy_dmatable	-	clean up DMA mapping
+ *	@drive: The drive to unmap
+ *
+ *	Teardown mappings after DMA has completed. This must be called
+ *	after the completion of each use of ide_build_dmatable and before
+ *	the next use of ide_build_dmatable. Failure to do so will cause
+ *	an oops as only one mapping can be live for each target at a given
+ *	time.
+ */
+ 
+void ide_destroy_dmatable (ide_drive_t *drive)
+{
+	struct pci_dev *dev = HWIF(drive)->pci_dev;
+	struct scatterlist *sg = HWIF(drive)->sg_table;
+	int nents = HWIF(drive)->sg_nents;
+
+	pci_unmap_sg(dev, sg, nents, HWIF(drive)->sg_dma_direction);
+}
+
+EXPORT_SYMBOL_GPL(ide_destroy_dmatable);
+
+/**
+ *	config_drive_for_dma	-	attempt to activate IDE DMA
+ *	@drive: the drive to place in DMA mode
+ *
+ *	If the drive supports at least mode 2 DMA or UDMA of any kind
+ *	then attempt to place it into DMA mode. Drives that are known to
+ *	support DMA but predate the DMA properties or that are known
+ *	to have DMA handling bugs are also set up appropriately based
+ *	on the good/bad drive lists.
+ */
+ 
+static int config_drive_for_dma (ide_drive_t *drive)
+{
+	struct hd_driveid *id = drive->id;
+	ide_hwif_t *hwif = HWIF(drive);
+
+	if ((id->capability & 1) && hwif->autodma) {
+		/*
+		 * Enable DMA on any drive that has
+		 * UltraDMA (mode 0/1/2/3/4/5/6) enabled
+		 */
+		if ((id->field_valid & 4) && ((id->dma_ultra >> 8) & 0x7f))
+			return hwif->ide_dma_on(drive);
+		/*
+		 * Enable DMA on any drive that has mode2 DMA
+		 * (multi or single) enabled
+		 */
+		if (id->field_valid & 2)	/* regular DMA */
+			if ((id->dma_mword & 0x404) == 0x404 ||
+			    (id->dma_1word & 0x404) == 0x404)
+				return hwif->ide_dma_on(drive);
+
+		/* Consult the list of known "good" drives */
+		if (__ide_dma_good_drive(drive))
+			return hwif->ide_dma_on(drive);
+	}
+//	if (hwif->tuneproc != NULL) hwif->tuneproc(drive, 255);
+	return hwif->ide_dma_off_quietly(drive);
+}
+
+/**
+ *	dma_timer_expiry	-	handle a DMA timeout
+ *	@drive: Drive that timed out
+ *
+ *	An IDE DMA transfer timed out. In the event of an error we ask
+ *	the driver to resolve the problem, if a DMA transfer is still
+ *	in progress we continue to wait (arguably we need to add a 
+ *	secondary 'I don't care what the drive thinks' timeout here)
+ *	Finally if we have an interrupt we let it complete the I/O.
+ *	But only one time - we clear expiry and if it's still not
+ *	completed after WAIT_CMD, we error and retry in PIO.
+ *	This can occur if an interrupt is lost or due to hang or bugs.
+ */
+ 
+static int dma_timer_expiry (ide_drive_t *drive)
+{
+	ide_hwif_t *hwif	= HWIF(drive);
+	u8 dma_stat		= hwif->INB(hwif->dma_status);
+
+	printk(KERN_WARNING "%s: dma_timer_expiry: dma status == 0x%02x\n",
+		drive->name, dma_stat);
+
+	if ((dma_stat & 0x18) == 0x18)	/* BUSY Stupid Early Timer !! */
+		return WAIT_CMD;
+
+	HWGROUP(drive)->expiry = NULL;	/* one free ride for now */
+
+	/* 1 dmaing, 2 error, 4 intr */
+	if (dma_stat & 2)	/* ERROR */
+		return -1;
+
+	if (dma_stat & 1)	/* DMAing */
+		return WAIT_CMD;
+
+	if (dma_stat & 4)	/* Got an Interrupt */
+		return WAIT_CMD;
+
+	return 0;	/* Status is unknown -- reset the bus */
+}
+
+/**
+ *	__ide_dma_host_off	-	Generic DMA kill
+ *	@drive: drive to control
+ *
+ *	Perform the generic IDE controller DMA off operation. This
+ *	works for most IDE bus mastering controllers
+ */
+
+int __ide_dma_host_off (ide_drive_t *drive)
+{
+	ide_hwif_t *hwif	= HWIF(drive);
+	u8 unit			= (drive->select.b.unit & 0x01);
+	u8 dma_stat		= hwif->INB(hwif->dma_status);
+
+	hwif->OUTB((dma_stat & ~(1<<(5+unit))), hwif->dma_status);
+	return 0;
+}
+
+EXPORT_SYMBOL(__ide_dma_host_off);
+
+/**
+ *	__ide_dma_host_off_quietly	-	Generic DMA kill
+ *	@drive: drive to control
+ *
+ *	Turn off the current DMA on this IDE controller. 
+ */
+
+int __ide_dma_off_quietly (ide_drive_t *drive)
+{
+	drive->using_dma = 0;
+	ide_toggle_bounce(drive, 0);
+
+	if (HWIF(drive)->ide_dma_host_off(drive))
+		return 1;
+
+	return 0;
+}
+
+EXPORT_SYMBOL(__ide_dma_off_quietly);
+#endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
+
+/**
+ *	__ide_dma_off	-	disable DMA on a device
+ *	@drive: drive to disable DMA on
+ *
+ *	Disable IDE DMA for a device on this IDE controller.
+ *	Inform the user that DMA has been disabled.
+ */
+
+int __ide_dma_off (ide_drive_t *drive)
+{
+	printk(KERN_INFO "%s: DMA disabled\n", drive->name);
+	return HWIF(drive)->ide_dma_off_quietly(drive);
+}
+
+EXPORT_SYMBOL(__ide_dma_off);
+
+#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
+/**
+ *	__ide_dma_host_on	-	Enable DMA on a host
+ *	@drive: drive to enable for DMA
+ *
+ *	Enable DMA on an IDE controller following generic bus mastering
+ *	IDE controller behaviour
+ */
+ 
+int __ide_dma_host_on (ide_drive_t *drive)
+{
+	if (drive->using_dma) {
+		ide_hwif_t *hwif	= HWIF(drive);
+		u8 unit			= (drive->select.b.unit & 0x01);
+		u8 dma_stat		= hwif->INB(hwif->dma_status);
+
+		hwif->OUTB((dma_stat|(1<<(5+unit))), hwif->dma_status);
+		return 0;
+	}
+	return 1;
+}
+
+EXPORT_SYMBOL(__ide_dma_host_on);
+
+/**
+ *	__ide_dma_on		-	Enable DMA on a device
+ *	@drive: drive to enable DMA on
+ *
+ *	Enable IDE DMA for a device on this IDE controller.
+ */
+ 
+int __ide_dma_on (ide_drive_t *drive)
+{
+	/* consult the list of known "bad" drives */
+	if (__ide_dma_bad_drive(drive))
+		return 1;
+
+	drive->using_dma = 1;
+	ide_toggle_bounce(drive, 1);
+
+	if (HWIF(drive)->ide_dma_host_on(drive))
+		return 1;
+
+	return 0;
+}
+
+EXPORT_SYMBOL(__ide_dma_on);
+
+/**
+ *	__ide_dma_check		-	check DMA setup
+ *	@drive: drive to check
+ *
+ *	Don't use - due for extermination
+ */
+ 
+int __ide_dma_check (ide_drive_t *drive)
+{
+	return config_drive_for_dma(drive);
+}
+
+EXPORT_SYMBOL(__ide_dma_check);
+
+/**
+ *	ide_dma_setup	-	begin a DMA phase
+ *	@drive: target device
+ *
+ *	Build an IDE DMA PRD (IDE speak for scatter gather table)
+ *	and then set up the DMA transfer registers for a device
+ *	that follows generic IDE PCI DMA behaviour. Controllers can
+ *	override this function if they need to
+ *
+ *	Returns 0 on success. If a PIO fallback is required then 1
+ *	is returned. 
+ */
+
+int ide_dma_setup(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	struct request *rq = HWGROUP(drive)->rq;
+	unsigned int reading;
+	u8 dma_stat;
+
+	if (rq_data_dir(rq))
+		reading = 0;
+	else
+		reading = 1 << 3;
+
+	/* fall back to pio! */
+	if (!ide_build_dmatable(drive, rq)) {
+		ide_map_sg(drive, rq);
+		return 1;
+	}
+
+	/* PRD table */
+	hwif->OUTL(hwif->dmatable_dma, hwif->dma_prdtable);
+
+	/* specify r/w */
+	hwif->OUTB(reading, hwif->dma_command);
+
+	/* read dma_status for INTR & ERROR flags */
+	dma_stat = hwif->INB(hwif->dma_status);
+
+	/* clear INTR & ERROR flags */
+	hwif->OUTB(dma_stat|6, hwif->dma_status);
+	drive->waiting_for_dma = 1;
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(ide_dma_setup);
+
+static void ide_dma_exec_cmd(ide_drive_t *drive, u8 command)
+{
+	/* issue cmd to drive */
+	ide_execute_command(drive, command, &ide_dma_intr, 2*WAIT_CMD, dma_timer_expiry);
+}
+
+void ide_dma_start(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif	= HWIF(drive);
+	u8 dma_cmd		= hwif->INB(hwif->dma_command);
+
+	/* Note that this is done *after* the cmd has
+	 * been issued to the drive, as per the BM-IDE spec.
+	 * The Promise Ultra33 doesn't work correctly when
+	 * we do this part before issuing the drive cmd.
+	 */
+	/* start DMA */
+	hwif->OUTB(dma_cmd|1, hwif->dma_command);
+	hwif->dma = 1;
+	wmb();
+}
+
+EXPORT_SYMBOL_GPL(ide_dma_start);
+
+/* returns 1 on error, 0 otherwise */
+int __ide_dma_end (ide_drive_t *drive)
+{
+	ide_hwif_t *hwif	= HWIF(drive);
+	u8 dma_stat = 0, dma_cmd = 0;
+
+	drive->waiting_for_dma = 0;
+	/* get dma_command mode */
+	dma_cmd = hwif->INB(hwif->dma_command);
+	/* stop DMA */
+	hwif->OUTB(dma_cmd&~1, hwif->dma_command);
+	/* get DMA status */
+	dma_stat = hwif->INB(hwif->dma_status);
+	/* clear the INTR & ERROR bits */
+	hwif->OUTB(dma_stat|6, hwif->dma_status);
+	/* purge DMA mappings */
+	ide_destroy_dmatable(drive);
+	/* verify good DMA status */
+	hwif->dma = 0;
+	wmb();
+	return (dma_stat & 7) != 4 ? (0x10 | dma_stat) : 0;
+}
+
+EXPORT_SYMBOL(__ide_dma_end);
+
+/* returns 1 if dma irq issued, 0 otherwise */
+static int __ide_dma_test_irq(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif	= HWIF(drive);
+	u8 dma_stat		= hwif->INB(hwif->dma_status);
+
+#if 0  /* do not set unless you know what you are doing */
+	if (dma_stat & 4) {
+		u8 stat = hwif->INB(IDE_STATUS_REG);
+		hwif->OUTB(hwif->dma_status, dma_stat & 0xE4);
+	}
+#endif
+	/* return 1 if INTR asserted */
+	if ((dma_stat & 4) == 4)
+		return 1;
+	if (!drive->waiting_for_dma)
+		printk(KERN_WARNING "%s: (%s) called while not waiting\n",
+			drive->name, __FUNCTION__);
+	return 0;
+}
+#endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
+
+int __ide_dma_bad_drive (ide_drive_t *drive)
+{
+	struct hd_driveid *id = drive->id;
+
+	int blacklist = in_drive_list(id, drive_blacklist);
+	if (blacklist) {
+		printk(KERN_WARNING "%s: Disabling (U)DMA for %s (blacklisted)\n",
+				    drive->name, id->model);
+		return blacklist;
+	}
+	return 0;
+}
+
+EXPORT_SYMBOL(__ide_dma_bad_drive);
+
+int __ide_dma_good_drive (ide_drive_t *drive)
+{
+	struct hd_driveid *id = drive->id;
+	return in_drive_list(id, drive_whitelist);
+}
+
+EXPORT_SYMBOL(__ide_dma_good_drive);
+
+int ide_use_dma(ide_drive_t *drive)
+{
+	struct hd_driveid *id = drive->id;
+	ide_hwif_t *hwif = drive->hwif;
+
+	/* consult the list of known "bad" drives */
+	if (__ide_dma_bad_drive(drive))
+		return 0;
+
+	/* capable of UltraDMA modes */
+	if (id->field_valid & 4) {
+		if (hwif->ultra_mask & id->dma_ultra)
+			return 1;
+	}
+
+	/* capable of regular DMA modes */
+	if (id->field_valid & 2) {
+		if (hwif->mwdma_mask & id->dma_mword)
+			return 1;
+		if (hwif->swdma_mask & id->dma_1word)
+			return 1;
+	}
+
+	/* consult the list of known "good" drives */
+	if (__ide_dma_good_drive(drive) && id->eide_dma_time < 150)
+		return 1;
+
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(ide_use_dma);
+
+void ide_dma_verbose(ide_drive_t *drive)
+{
+	struct hd_driveid *id	= drive->id;
+	ide_hwif_t *hwif	= HWIF(drive);
+
+	if (id->field_valid & 4) {
+		if ((id->dma_ultra >> 8) && (id->dma_mword >> 8))
+			goto bug_dma_off;
+		if (id->dma_ultra & ((id->dma_ultra >> 8) & hwif->ultra_mask)) {
+			if (((id->dma_ultra >> 11) & 0x1F) &&
+			    eighty_ninty_three(drive)) {
+				if ((id->dma_ultra >> 15) & 1) {
+					printk(", UDMA(mode 7)");
+				} else if ((id->dma_ultra >> 14) & 1) {
+					printk(", UDMA(133)");
+				} else if ((id->dma_ultra >> 13) & 1) {
+					printk(", UDMA(100)");
+				} else if ((id->dma_ultra >> 12) & 1) {
+					printk(", UDMA(66)");
+				} else if ((id->dma_ultra >> 11) & 1) {
+					printk(", UDMA(44)");
+				} else
+					goto mode_two;
+			} else {
+		mode_two:
+				if ((id->dma_ultra >> 10) & 1) {
+					printk(", UDMA(33)");
+				} else if ((id->dma_ultra >> 9) & 1) {
+					printk(", UDMA(25)");
+				} else if ((id->dma_ultra >> 8) & 1) {
+					printk(", UDMA(16)");
+				}
+			}
+		} else {
+			printk(", (U)DMA");	/* Can be BIOS-enabled! */
+		}
+	} else if (id->field_valid & 2) {
+		if ((id->dma_mword >> 8) && (id->dma_1word >> 8))
+			goto bug_dma_off;
+		printk(", DMA");
+	} else if (id->field_valid & 1) {
+		printk(", BUG");
+	}
+	return;
+bug_dma_off:
+	printk(", BUG DMA OFF");
+	hwif->ide_dma_off_quietly(drive);
+	return;
+}
+
+EXPORT_SYMBOL(ide_dma_verbose);
+
+#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
+int __ide_dma_lostirq (ide_drive_t *drive)
+{
+	printk("%s: DMA interrupt recovery\n", drive->name);
+	return 1;
+}
+
+EXPORT_SYMBOL(__ide_dma_lostirq);
+
+int __ide_dma_timeout (ide_drive_t *drive)
+{
+	printk(KERN_ERR "%s: timeout waiting for DMA\n", drive->name);
+	if (HWIF(drive)->ide_dma_test_irq(drive))
+		return 0;
+
+	return HWIF(drive)->ide_dma_end(drive);
+}
+
+EXPORT_SYMBOL(__ide_dma_timeout);
+
+/*
+ * Needed for allowing full modular support of ide-driver
+ */
+static int ide_release_dma_engine(ide_hwif_t *hwif)
+{
+	if (hwif->dmatable_cpu) {
+		pci_free_consistent(hwif->pci_dev,
+				    PRD_ENTRIES * PRD_BYTES,
+				    hwif->dmatable_cpu,
+				    hwif->dmatable_dma);
+		hwif->dmatable_cpu = NULL;
+	}
+	return 1;
+}
+
+static int ide_release_iomio_dma(ide_hwif_t *hwif)
+{
+	if ((hwif->dma_extra) && (hwif->channel == 0))
+		release_region((hwif->dma_base + 16), hwif->dma_extra);
+	release_region(hwif->dma_base, 8);
+	if (hwif->dma_base2)
+		release_region(hwif->dma_base, 8);
+	return 1;
+}
+
+/*
+ * Needed for allowing full modular support of ide-driver
+ */
+int ide_release_dma (ide_hwif_t *hwif)
+{
+	if (hwif->mmio == 2)
+		return 1;
+	if (hwif->chipset == ide_etrax100)
+		return 1;
+
+	ide_release_dma_engine(hwif);
+	return ide_release_iomio_dma(hwif);
+}
+
+static int ide_allocate_dma_engine(ide_hwif_t *hwif)
+{
+	hwif->dmatable_cpu = pci_alloc_consistent(hwif->pci_dev,
+						  PRD_ENTRIES * PRD_BYTES,
+						  &hwif->dmatable_dma);
+
+	if (hwif->dmatable_cpu)
+		return 0;
+
+	printk(KERN_ERR "%s: -- Error, unable to allocate%s DMA table(s).\n",
+			hwif->cds->name, !hwif->dmatable_cpu ? " CPU" : "");
+
+	ide_release_dma_engine(hwif);
+	return 1;
+}
+
+static int ide_mapped_mmio_dma(ide_hwif_t *hwif, unsigned long base, unsigned int ports)
+{
+	printk(KERN_INFO "    %s: MMIO-DMA ", hwif->name);
+
+	hwif->dma_base = base;
+	if (hwif->cds->extra && hwif->channel == 0)
+		hwif->dma_extra = hwif->cds->extra;
+
+	if(hwif->mate)
+		hwif->dma_master = (hwif->channel) ? hwif->mate->dma_base : base;
+	else
+		hwif->dma_master = base;
+	return 0;
+}
+
+static int ide_iomio_dma(ide_hwif_t *hwif, unsigned long base, unsigned int ports)
+{
+	printk(KERN_INFO "    %s: BM-DMA at 0x%04lx-0x%04lx",
+		hwif->name, base, base + ports - 1);
+	if (!request_region(base, ports, hwif->name)) {
+		printk(" -- Error, ports in use.\n");
+		return 1;
+	}
+	hwif->dma_base = base;
+	if ((hwif->cds->extra) && (hwif->channel == 0)) {
+		request_region(base+16, hwif->cds->extra, hwif->cds->name);
+		hwif->dma_extra = hwif->cds->extra;
+	}
+	
+	if(hwif->mate)
+		hwif->dma_master = (hwif->channel) ? hwif->mate->dma_base : base;
+	else
+		hwif->dma_master = base;
+	if (hwif->dma_base2) {
+		if (!request_region(hwif->dma_base2, ports, hwif->name))
+		{
+			printk(" -- Error, secondary ports in use.\n");
+			release_region(base, ports);
+			return 1;
+		}
+	}
+	return 0;
+}
+
+static int ide_dma_iobase(ide_hwif_t *hwif, unsigned long base, unsigned int ports)
+{
+	if (hwif->mmio == 2)
+		return ide_mapped_mmio_dma(hwif, base,ports);
+	BUG_ON(hwif->mmio == 1);
+	return ide_iomio_dma(hwif, base, ports);
+}
+
+/*
+ * This can be called for a dynamically installed interface. Don't __init it
+ */
+void ide_setup_dma (ide_hwif_t *hwif, unsigned long dma_base, unsigned int num_ports)
+{
+	if (ide_dma_iobase(hwif, dma_base, num_ports))
+		return;
+
+	if (ide_allocate_dma_engine(hwif)) {
+		ide_release_dma(hwif);
+		return;
+	}
+
+	if (!(hwif->dma_command))
+		hwif->dma_command	= hwif->dma_base;
+	if (!(hwif->dma_vendor1))
+		hwif->dma_vendor1	= (hwif->dma_base + 1);
+	if (!(hwif->dma_status))
+		hwif->dma_status	= (hwif->dma_base + 2);
+	if (!(hwif->dma_vendor3))
+		hwif->dma_vendor3	= (hwif->dma_base + 3);
+	if (!(hwif->dma_prdtable))
+		hwif->dma_prdtable	= (hwif->dma_base + 4);
+
+	if (!hwif->ide_dma_off_quietly)
+		hwif->ide_dma_off_quietly = &__ide_dma_off_quietly;
+	if (!hwif->ide_dma_host_off)
+		hwif->ide_dma_host_off = &__ide_dma_host_off;
+	if (!hwif->ide_dma_on)
+		hwif->ide_dma_on = &__ide_dma_on;
+	if (!hwif->ide_dma_host_on)
+		hwif->ide_dma_host_on = &__ide_dma_host_on;
+	if (!hwif->ide_dma_check)
+		hwif->ide_dma_check = &__ide_dma_check;
+	if (!hwif->dma_setup)
+		hwif->dma_setup = &ide_dma_setup;
+	if (!hwif->dma_exec_cmd)
+		hwif->dma_exec_cmd = &ide_dma_exec_cmd;
+	if (!hwif->dma_start)
+		hwif->dma_start = &ide_dma_start;
+	if (!hwif->ide_dma_end)
+		hwif->ide_dma_end = &__ide_dma_end;
+	if (!hwif->ide_dma_test_irq)
+		hwif->ide_dma_test_irq = &__ide_dma_test_irq;
+	if (!hwif->ide_dma_timeout)
+		hwif->ide_dma_timeout = &__ide_dma_timeout;
+	if (!hwif->ide_dma_lostirq)
+		hwif->ide_dma_lostirq = &__ide_dma_lostirq;
+
+	if (hwif->chipset != ide_trm290) {
+		u8 dma_stat = hwif->INB(hwif->dma_status);
+		printk(", BIOS settings: %s:%s, %s:%s",
+		       hwif->drives[0].name, (dma_stat & 0x20) ? "DMA" : "pio",
+		       hwif->drives[1].name, (dma_stat & 0x40) ? "DMA" : "pio");
+	}
+	printk("\n");
+
+	if (!(hwif->dma_master))
+		BUG();
+}
+
+EXPORT_SYMBOL_GPL(ide_setup_dma);
+#endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
