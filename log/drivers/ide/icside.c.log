commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index 80e933b296f6..329c7e4bc9d0 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (c) 1996-2004 Russell King.
  *

commit eccf432f6542d9895d6c50edb5634c6147918ed2
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Feb 8 15:31:45 2016 +0100

    ide: icside: remove incorrect initconst annotation
    
    The icside_probe function can be called for hotplugged devices, so
    its reference to the __initconst icside_v6_port_info variable
    may be invalid, as Kbuild points out:
    
    WARNING: drivers/ide/icside.o(.text+0x338): Section mismatch in reference from the function icside_probe()
     to the (unknown reference) .init.rodata:(unknown)
    
    Interestingly, this problem only shows up with clang but not
    with gcc, which optimizes out the __initconst variable.
    
    This removes the incorrect annotation.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index 9f0a48e39b8a..80e933b296f6 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -451,7 +451,7 @@ static int icside_register_v5(struct icside_state *state,
 	return ret;
 }
 
-static const struct ide_port_info icside_v6_port_info __initconst = {
+static const struct ide_port_info icside_v6_port_info = {
 	.init_dma		= icside_dma_off_init,
 	.port_ops		= &icside_v6_no_dma_port_ops,
 	.host_flags		= IDE_HFLAG_SERIALIZE | IDE_HFLAG_MMIO,

commit fe31edc8a3b6081f3580c9ae4c5c61103f3412a5
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:21:03 2012 -0800

    Drivers: ide: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index e640d0ac3af6..9f0a48e39b8a 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -406,8 +406,8 @@ static const struct ide_port_info icside_v5_port_info = {
 	.chipset		= ide_acorn,
 };
 
-static int __devinit
-icside_register_v5(struct icside_state *state, struct expansion_card *ec)
+static int icside_register_v5(struct icside_state *state,
+			      struct expansion_card *ec)
 {
 	void __iomem *base;
 	struct ide_host *host;
@@ -460,8 +460,8 @@ static const struct ide_port_info icside_v6_port_info __initconst = {
 	.chipset		= ide_acorn,
 };
 
-static int __devinit
-icside_register_v6(struct icside_state *state, struct expansion_card *ec)
+static int icside_register_v6(struct icside_state *state,
+			      struct expansion_card *ec)
 {
 	void __iomem *ioc_base, *easi_base;
 	struct ide_host *host;
@@ -537,8 +537,7 @@ icside_register_v6(struct icside_state *state, struct expansion_card *ec)
 	return ret;
 }
 
-static int __devinit
-icside_probe(struct expansion_card *ec, const struct ecard_id *id)
+static int icside_probe(struct expansion_card *ec, const struct ecard_id *id)
 {
 	struct icside_state *state;
 	void __iomem *idmem;
@@ -604,7 +603,7 @@ icside_probe(struct expansion_card *ec, const struct ecard_id *id)
 	return ret;
 }
 
-static void __devexit icside_remove(struct expansion_card *ec)
+static void icside_remove(struct expansion_card *ec)
 {
 	struct icside_state *state = ecard_get_drvdata(ec);
 
@@ -666,7 +665,7 @@ static const struct ecard_id icside_ids[] = {
 
 static struct ecard_driver icside_driver = {
 	.probe		= icside_probe,
-	.remove		= __devexit_p(icside_remove),
+	.remove		= icside_remove,
 	.shutdown	= icside_shutdown,
 	.id_table	= icside_ids,
 	.drv = {

commit e6b53703b9966a3636be2bd4b7b8e0bfeb1b3f8d
Author: Andi Kleen <ak@linux.intel.com>
Date:   Thu Oct 4 17:11:48 2012 -0700

    sections: fix section conflicts in drivers/ide
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: David Miller <davem@davemloft.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index bcb507b0cfd4..e640d0ac3af6 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -451,7 +451,7 @@ icside_register_v5(struct icside_state *state, struct expansion_card *ec)
 	return ret;
 }
 
-static const struct ide_port_info icside_v6_port_info __initdata = {
+static const struct ide_port_info icside_v6_port_info __initconst = {
 	.init_dma		= icside_dma_off_init,
 	.port_ops		= &icside_v6_no_dma_port_ops,
 	.host_flags		= IDE_HFLAG_SERIALIZE | IDE_HFLAG_MMIO,

commit 027253c138a12b075e724f94b6cc43fd7071c14f
Author: Christian Dietrich <christian.dietrich@informatik.uni-erlangen.de>
Date:   Tue Jun 5 02:28:59 2012 +0000

    ide: icside.c: fix printk format string compile warning
    
    Use correct format string parameter for the peak datarate, and prevent
    uninitialized use of cycle_time.
    
    Signed-off-by: Christian Dietrich <christian.dietrich@informatik.uni-erlangen.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index 83e5100d73f6..bcb507b0cfd4 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -236,7 +236,7 @@ static const struct ide_port_ops icside_v6_no_dma_port_ops = {
  */
 static void icside_set_dma_mode(ide_hwif_t *hwif, ide_drive_t *drive)
 {
-	unsigned long cycle_time;
+	unsigned long cycle_time = 0;
 	int use_dma_info = 0;
 	const u8 xfer_mode = drive->dma_mode;
 
@@ -271,9 +271,9 @@ static void icside_set_dma_mode(ide_hwif_t *hwif, ide_drive_t *drive)
 
 	ide_set_drivedata(drive, (void *)cycle_time);
 
-	printk("%s: %s selected (peak %dMB/s)\n", drive->name,
-		ide_xfer_verbose(xfer_mode),
-		2000 / (unsigned long)ide_get_drivedata(drive));
+	printk(KERN_INFO "%s: %s selected (peak %luMB/s)\n",
+	       drive->name, ide_xfer_verbose(xfer_mode),
+	       2000 / (cycle_time ? cycle_time : (unsigned long) -1));
 }
 
 static const struct ide_port_ops icside_v6_port_ops = {

commit 32a527add871a51b3c06177849d18bf71e33b320
Author: Christian Dietrich <christian.dietrich@informatik.uni-erlangen.de>
Date:   Tue Jun 5 02:23:20 2012 +0000

    ide: icside.c: Fix compile with CONFIG_BLK_DEV_IDEDMA_ICS=n
    
    The icside driver can be configured without DMA support, but it
    doesn't compile then, because DMA operations are referenced.
    
    drivers/ide/icside.c:523: error: 'icside_v6_port_ops' undeclared
    drivers/ide/icside.c:522: error: 'icside_dma_init' undeclared
    
    Signed-off-by: Christian Dietrich<christian.dietrich@informatik.uni-erlangen.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index 8716066a2f2b..83e5100d73f6 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -375,8 +375,6 @@ static const struct ide_dma_ops icside_v6_dma_ops = {
 	.dma_test_irq		= icside_dma_test_irq,
 	.dma_lost_irq		= ide_dma_lost_irq,
 };
-#else
-#define icside_v6_dma_ops NULL
 #endif
 
 static int icside_dma_off_init(ide_hwif_t *hwif, const struct ide_port_info *d)
@@ -456,7 +454,6 @@ icside_register_v5(struct icside_state *state, struct expansion_card *ec)
 static const struct ide_port_info icside_v6_port_info __initdata = {
 	.init_dma		= icside_dma_off_init,
 	.port_ops		= &icside_v6_no_dma_port_ops,
-	.dma_ops		= &icside_v6_dma_ops,
 	.host_flags		= IDE_HFLAG_SERIALIZE | IDE_HFLAG_MMIO,
 	.mwdma_mask		= ATA_MWDMA2,
 	.swdma_mask		= ATA_SWDMA2,
@@ -518,11 +515,13 @@ icside_register_v6(struct icside_state *state, struct expansion_card *ec)
 
 	ecard_set_drvdata(ec, state);
 
+#ifdef CONFIG_BLK_DEV_IDEDMA_ICS
 	if (ec->dma != NO_DMA && !request_dma(ec->dma, DRV_NAME)) {
 		d.init_dma = icside_dma_init;
 		d.port_ops = &icside_v6_port_ops;
-	} else
-		d.dma_ops = NULL;
+		d.dma_ops  = &icside_v6_dma_ops;
+	}
+#endif
 
 	ret = ide_host_register(host, &d, hws);
 	if (ret)

commit acc8dbe7f44f1bab6fcf21f2d5efb32ea92e19fd
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Oct 12 04:45:34 2011 +0000

    icside: DMA support fix
    
    Fix problem introduced by commit 5e37bdc ("ide: add struct
    ide_dma_ops (take 3)"): d.dma_ops shouldn't be cleared if
    we are going to use DMA.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index 4a697a238e28..8716066a2f2b 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -521,8 +521,8 @@ icside_register_v6(struct icside_state *state, struct expansion_card *ec)
 	if (ec->dma != NO_DMA && !request_dma(ec->dma, DRV_NAME)) {
 		d.init_dma = icside_dma_init;
 		d.port_ops = &icside_v6_port_ops;
+	} else
 		d.dma_ops = NULL;
-	}
 
 	ret = ide_host_register(host, &d, hws);
 	if (ret)

commit 950f564b707ca1b1c5bb94cd1e7d2a0702bfcadc
Merge: b1681c56f5b6 8495fb1b8d01
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Mar 2 23:57:59 2010 -0800

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/davem/ide-2.6

commit 8776168ca2151850164af1de5565d01f7b8b2c53
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jan 19 01:45:29 2010 -0800

    ide: change ->set_dma_mode method parameters
    
    Change ->set_dma_mode method parameters to match ->set_dmamode method
    used in struct ata_port_operations.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index 0f67f1abbbd3..26b6c0a1f772 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -185,10 +185,11 @@ static const expansioncard_ops_t icside_ops_arcin_v6 = {
  *	MW1	80	50	50	150	C
  *	MW2	70	25	25	120	C
  */
-static void icside_set_dma_mode(ide_drive_t *drive, const u8 xfer_mode)
+static void icside_set_dma_mode(ide_hwif_t *hwif, ide_drive_t *drive)
 {
 	unsigned long cycle_time;
 	int use_dma_info = 0;
+	const u8 xfer_mode = drive->dma_mode;
 
 	switch (xfer_mode) {
 	case XFER_MW_DMA_2:

commit f75d4a238770d83d3a0475ce7f34e3fa37de161e
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jan 5 07:07:27 2010 +0000

    icside: bring back ->maskproc method
    
    Bring back ->maskproc method since it is still needed for proper operation,
    as noticed by Russell King:
    
    > This change is bogus.
    >
    >         writeb(0, base + ICS_ARCIN_V6_INTROFFSET_1);
    >         readb(base + ICS_ARCIN_V6_INTROFFSET_2);
    >
    >         writeb(0, base + ICS_ARCIN_V6_INTROFFSET_2);
    >         readb(base + ICS_ARCIN_V6_INTROFFSET_1);
    >
    > This sequence of code does:
    >
    > 1. enable interrupt 1
    > 2. disable interrupt 2
    > 3. enable interrupt 2
    > 4. disable interrupt 1
    >
    > which results in the interrupt for the second channel being enabled -
    > leaving channel 1 blocked.
    >
    > Firstly, icside shares its two IDE channels with one DMA engine - so it's
    > a simplex interface.  IDE supports those (or did when the code was written)
    > serializing requests between the two interfaces.  libata does not.
    >
    > Secondly, the interrupt lines on icside float when there's no drive connected
    > or when the drive has its NIEN bit set, which means that you get spurious
    > screaming interrupts which can kill off all expansion card interrupts on
    > the machine unless you disable the channel interrupt on the card.
    >
    > Since libata can not serialize the operation of the two channels like IDE
    > can, the libata version of the icside driver does not contain the interrupt
    > stearing logic.  Instead, it looks at the status after reset, and if
    > nothing was found on that channel, it masks the interrupt from that
    > channel.
    
    This patch reverts changes done in commit dff8817 (I became confused due to
    non-standard & undocumented ->maskproc method, anyway sorry about that).
    
    Noticed-by: Russell King <rmk@arm.linux.org.uk>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index 0f67f1abbbd3..d7e6f09aa86b 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -65,6 +65,8 @@ static struct cardinfo icside_cardinfo_v6_2 = {
 };
 
 struct icside_state {
+	unsigned int channel;
+	unsigned int enabled;
 	void __iomem *irq_port;
 	void __iomem *ioc_base;
 	unsigned int sel;
@@ -114,11 +116,18 @@ static void icside_irqenable_arcin_v6 (struct expansion_card *ec, int irqnr)
 	struct icside_state *state = ec->irq_data;
 	void __iomem *base = state->irq_port;
 
-	writeb(0, base + ICS_ARCIN_V6_INTROFFSET_1);
-	readb(base + ICS_ARCIN_V6_INTROFFSET_2);
+	state->enabled = 1;
 
-	writeb(0, base + ICS_ARCIN_V6_INTROFFSET_2);
-	readb(base + ICS_ARCIN_V6_INTROFFSET_1);
+	switch (state->channel) {
+	case 0:
+		writeb(0, base + ICS_ARCIN_V6_INTROFFSET_1);
+		readb(base + ICS_ARCIN_V6_INTROFFSET_2);
+		break;
+	case 1:
+		writeb(0, base + ICS_ARCIN_V6_INTROFFSET_2);
+		readb(base + ICS_ARCIN_V6_INTROFFSET_1);
+		break;
+	}
 }
 
 /* Prototype: icside_irqdisable_arcin_v6 (struct expansion_card *ec, int irqnr)
@@ -128,6 +137,8 @@ static void icside_irqdisable_arcin_v6 (struct expansion_card *ec, int irqnr)
 {
 	struct icside_state *state = ec->irq_data;
 
+	state->enabled = 0;
+
 	readb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);
 	readb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);
 }
@@ -149,6 +160,44 @@ static const expansioncard_ops_t icside_ops_arcin_v6 = {
 	.irqpending	= icside_irqpending_arcin_v6,
 };
 
+/*
+ * Handle routing of interrupts.  This is called before
+ * we write the command to the drive.
+ */
+static void icside_maskproc(ide_drive_t *drive, int mask)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	struct expansion_card *ec = ECARD_DEV(hwif->dev);
+	struct icside_state *state = ecard_get_drvdata(ec);
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	state->channel = hwif->channel;
+
+	if (state->enabled && !mask) {
+		switch (hwif->channel) {
+		case 0:
+			writeb(0, state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);
+			readb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);
+			break;
+		case 1:
+			writeb(0, state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);
+			readb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);
+			break;
+		}
+	} else {
+		readb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);
+		readb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);
+	}
+
+	local_irq_restore(flags);
+}
+
+static const struct ide_port_ops icside_v6_no_dma_port_ops = {
+	.maskproc		= icside_maskproc,
+};
+
 #ifdef CONFIG_BLK_DEV_IDEDMA_ICS
 /*
  * SG-DMA support.
@@ -228,6 +277,7 @@ static void icside_set_dma_mode(ide_drive_t *drive, const u8 xfer_mode)
 
 static const struct ide_port_ops icside_v6_port_ops = {
 	.set_dma_mode		= icside_set_dma_mode,
+	.maskproc		= icside_maskproc,
 };
 
 static void icside_dma_host_set(ide_drive_t *drive, int on)
@@ -271,6 +321,11 @@ static int icside_dma_setup(ide_drive_t *drive, struct ide_cmd *cmd)
 	 */
 	BUG_ON(dma_channel_active(ec->dma));
 
+	/*
+	 * Ensure that we have the right interrupt routed.
+	 */
+	icside_maskproc(drive, 0);
+
 	/*
 	 * Route the DMA signals to the correct interface.
 	 */
@@ -399,6 +454,7 @@ icside_register_v5(struct icside_state *state, struct expansion_card *ec)
 
 static const struct ide_port_info icside_v6_port_info __initdata = {
 	.init_dma		= icside_dma_off_init,
+	.port_ops		= &icside_v6_no_dma_port_ops,
 	.dma_ops		= &icside_v6_dma_ops,
 	.host_flags		= IDE_HFLAG_SERIALIZE | IDE_HFLAG_MMIO,
 	.mwdma_mask		= ATA_MWDMA2,

commit 5bfb151f1f565e6082304a30e8c81dfb6ed0b0c8
Author: Joao Ramos <joao.ramos@inov.pt>
Date:   Mon Jun 15 22:13:44 2009 +0200

    ide: do not access ide_drive_t 'drive_data' field directly
    
    Change ide_drive_t 'drive_data' field from 'unsigned int' type to 'void *'
    type, allowing a wider range of values/types to be stored in this field.
    
    Added 'ide_get_drivedata' and 'ide_set_drivedata' helpers to get and set
    the 'drive_data' field.
    
    Fixed all host drivers to maintain coherency with the change in the
    'drive_data' field type.
    
    Signed-off-by: Joao Ramos <joao.ramos@inov.pt>
    [bart: fix qd65xx build, cast to 'unsigned long', minor Coding Style fixups]
    Acked-by: Sergei Shtylyov <sshtylyov@ru.montavista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index 5af3d0ffaf0a..0f67f1abbbd3 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -187,7 +187,8 @@ static const expansioncard_ops_t icside_ops_arcin_v6 = {
  */
 static void icside_set_dma_mode(ide_drive_t *drive, const u8 xfer_mode)
 {
-	int cycle_time, use_dma_info = 0;
+	unsigned long cycle_time;
+	int use_dma_info = 0;
 
 	switch (xfer_mode) {
 	case XFER_MW_DMA_2:
@@ -218,10 +219,11 @@ static void icside_set_dma_mode(ide_drive_t *drive, const u8 xfer_mode)
 	if (use_dma_info && drive->id[ATA_ID_EIDE_DMA_TIME] > cycle_time)
 		cycle_time = drive->id[ATA_ID_EIDE_DMA_TIME];
 
-	drive->drive_data = cycle_time;
+	ide_set_drivedata(drive, (void *)cycle_time);
 
 	printk("%s: %s selected (peak %dMB/s)\n", drive->name,
-		ide_xfer_verbose(xfer_mode), 2000 / drive->drive_data);
+		ide_xfer_verbose(xfer_mode),
+		2000 / (unsigned long)ide_get_drivedata(drive));
 }
 
 static const struct ide_port_ops icside_v6_port_ops = {
@@ -277,7 +279,7 @@ static int icside_dma_setup(ide_drive_t *drive, struct ide_cmd *cmd)
 	/*
 	 * Select the correct timing for this drive.
 	 */
-	set_dma_speed(ec->dma, drive->drive_data);
+	set_dma_speed(ec->dma, (unsigned long)ide_get_drivedata(drive));
 
 	/*
 	 * Tell the DMA engine about the SG table and

commit dff8817b78e6e6a4913f2caf7637d62dcc49a03c
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sun Jun 7 15:37:06 2009 +0200

    icside: remove superfluous ->maskproc method
    
    [inspired by pata_icside]
    
    Enabling/disabling of card IRQs is handled fine by IRQ and IDE
    subsystems so there is no need for custom ->maskproc method.
    
    Moreover icside_maskproc() would enable IRQ only if it was already
    enabled [because of 'if (state->enabled && !mask)' check].
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index c5269fa1f733..5af3d0ffaf0a 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -65,8 +65,6 @@ static struct cardinfo icside_cardinfo_v6_2 = {
 };
 
 struct icside_state {
-	unsigned int channel;
-	unsigned int enabled;
 	void __iomem *irq_port;
 	void __iomem *ioc_base;
 	unsigned int sel;
@@ -116,18 +114,11 @@ static void icside_irqenable_arcin_v6 (struct expansion_card *ec, int irqnr)
 	struct icside_state *state = ec->irq_data;
 	void __iomem *base = state->irq_port;
 
-	state->enabled = 1;
+	writeb(0, base + ICS_ARCIN_V6_INTROFFSET_1);
+	readb(base + ICS_ARCIN_V6_INTROFFSET_2);
 
-	switch (state->channel) {
-	case 0:
-		writeb(0, base + ICS_ARCIN_V6_INTROFFSET_1);
-		readb(base + ICS_ARCIN_V6_INTROFFSET_2);
-		break;
-	case 1:
-		writeb(0, base + ICS_ARCIN_V6_INTROFFSET_2);
-		readb(base + ICS_ARCIN_V6_INTROFFSET_1);
-		break;
-	}
+	writeb(0, base + ICS_ARCIN_V6_INTROFFSET_2);
+	readb(base + ICS_ARCIN_V6_INTROFFSET_1);
 }
 
 /* Prototype: icside_irqdisable_arcin_v6 (struct expansion_card *ec, int irqnr)
@@ -137,8 +128,6 @@ static void icside_irqdisable_arcin_v6 (struct expansion_card *ec, int irqnr)
 {
 	struct icside_state *state = ec->irq_data;
 
-	state->enabled = 0;
-
 	readb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);
 	readb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);
 }
@@ -160,44 +149,6 @@ static const expansioncard_ops_t icside_ops_arcin_v6 = {
 	.irqpending	= icside_irqpending_arcin_v6,
 };
 
-/*
- * Handle routing of interrupts.  This is called before
- * we write the command to the drive.
- */
-static void icside_maskproc(ide_drive_t *drive, int mask)
-{
-	ide_hwif_t *hwif = drive->hwif;
-	struct expansion_card *ec = ECARD_DEV(hwif->dev);
-	struct icside_state *state = ecard_get_drvdata(ec);
-	unsigned long flags;
-
-	local_irq_save(flags);
-
-	state->channel = hwif->channel;
-
-	if (state->enabled && !mask) {
-		switch (hwif->channel) {
-		case 0:
-			writeb(0, state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);
-			readb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);
-			break;
-		case 1:
-			writeb(0, state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);
-			readb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);
-			break;
-		}
-	} else {
-		readb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);
-		readb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);
-	}
-
-	local_irq_restore(flags);
-}
-
-static const struct ide_port_ops icside_v6_no_dma_port_ops = {
-	.maskproc		= icside_maskproc,
-};
-
 #ifdef CONFIG_BLK_DEV_IDEDMA_ICS
 /*
  * SG-DMA support.
@@ -275,7 +226,6 @@ static void icside_set_dma_mode(ide_drive_t *drive, const u8 xfer_mode)
 
 static const struct ide_port_ops icside_v6_port_ops = {
 	.set_dma_mode		= icside_set_dma_mode,
-	.maskproc		= icside_maskproc,
 };
 
 static void icside_dma_host_set(ide_drive_t *drive, int on)
@@ -319,11 +269,6 @@ static int icside_dma_setup(ide_drive_t *drive, struct ide_cmd *cmd)
 	 */
 	BUG_ON(dma_channel_active(ec->dma));
 
-	/*
-	 * Ensure that we have the right interrupt routed.
-	 */
-	icside_maskproc(drive, 0);
-
 	/*
 	 * Route the DMA signals to the correct interface.
 	 */
@@ -452,7 +397,6 @@ icside_register_v5(struct icside_state *state, struct expansion_card *ec)
 
 static const struct ide_port_info icside_v6_port_info __initdata = {
 	.init_dma		= icside_dma_off_init,
-	.port_ops		= &icside_v6_no_dma_port_ops,
 	.dma_ops		= &icside_v6_dma_ops,
 	.host_flags		= IDE_HFLAG_SERIALIZE | IDE_HFLAG_MMIO,
 	.mwdma_mask		= ATA_MWDMA2,

commit 9f36d31437922354d104a2db407f397e79e4027e
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sun May 17 19:12:25 2009 +0200

    ide: remove hw_regs_t typedef
    
    Remove hw_regs_t typedef and rename struct hw_regs_s to struct ide_hw.
    
    There should be no functional changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index 6223b80beb35..c5269fa1f733 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -381,7 +381,7 @@ static int icside_dma_off_init(ide_hwif_t *hwif, const struct ide_port_info *d)
 	return -EOPNOTSUPP;
 }
 
-static void icside_setup_ports(hw_regs_t *hw, void __iomem *base,
+static void icside_setup_ports(struct ide_hw *hw, void __iomem *base,
 			       struct cardinfo *info, struct expansion_card *ec)
 {
 	unsigned long port = (unsigned long)base + info->dataoffset;
@@ -410,7 +410,7 @@ icside_register_v5(struct icside_state *state, struct expansion_card *ec)
 {
 	void __iomem *base;
 	struct ide_host *host;
-	hw_regs_t hw, *hws[] = { &hw };
+	struct ide_hw hw, *hws[] = { &hw };
 	int ret;
 
 	base = ecardm_iomap(ec, ECARD_RES_MEMC, 0, 0);
@@ -467,7 +467,7 @@ icside_register_v6(struct icside_state *state, struct expansion_card *ec)
 	struct ide_host *host;
 	unsigned int sel = 0;
 	int ret;
-	hw_regs_t hw[2], *hws[] = { &hw[0], &hw[1] };
+	struct ide_hw hw[2], *hws[] = { &hw[0], &hw[1] };
 	struct ide_port_info d = icside_v6_port_info;
 
 	ioc_base = ecardm_iomap(ec, ECARD_RES_IOCFAST, 0, 0);

commit dca3983059a4481e4ae97bbf0ac4b4c21429e1a5
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sun May 17 19:12:24 2009 +0200

    ide: pass number of ports to ide_host_{alloc,add}() (v2)
    
    Pass number of ports to ide_host_{alloc,add}() and then update
    all users accordingly.
    
    v2:
    - drop no longer needed NULL initializers in buddha.c, cmd640.c and gayle.c
      (noticed by Sergei)
    
    There should be no functional changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index 6352a44ed179..6223b80beb35 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -410,7 +410,7 @@ icside_register_v5(struct icside_state *state, struct expansion_card *ec)
 {
 	void __iomem *base;
 	struct ide_host *host;
-	hw_regs_t hw, *hws[] = { &hw, NULL, NULL, NULL };
+	hw_regs_t hw, *hws[] = { &hw };
 	int ret;
 
 	base = ecardm_iomap(ec, ECARD_RES_MEMC, 0, 0);
@@ -431,7 +431,7 @@ icside_register_v5(struct icside_state *state, struct expansion_card *ec)
 
 	icside_setup_ports(&hw, base, &icside_cardinfo_v5, ec);
 
-	host = ide_host_alloc(&icside_v5_port_info, hws);
+	host = ide_host_alloc(&icside_v5_port_info, hws, 1);
 	if (host == NULL)
 		return -ENODEV;
 
@@ -467,7 +467,7 @@ icside_register_v6(struct icside_state *state, struct expansion_card *ec)
 	struct ide_host *host;
 	unsigned int sel = 0;
 	int ret;
-	hw_regs_t hw[2], *hws[] = { &hw[0], &hw[1], NULL, NULL };
+	hw_regs_t hw[2], *hws[] = { &hw[0], &hw[1] };
 	struct ide_port_info d = icside_v6_port_info;
 
 	ioc_base = ecardm_iomap(ec, ECARD_RES_IOCFAST, 0, 0);
@@ -507,7 +507,7 @@ icside_register_v6(struct icside_state *state, struct expansion_card *ec)
 	icside_setup_ports(&hw[0], easi_base, &icside_cardinfo_v6_1, ec);
 	icside_setup_ports(&hw[1], easi_base, &icside_cardinfo_v6_2, ec);
 
-	host = ide_host_alloc(&d, hws);
+	host = ide_host_alloc(&d, hws, 2);
 	if (host == NULL)
 		return -ENODEV;
 

commit 29e52cf793ded6bece50de50e738596f94f07d9f
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sun May 17 19:12:22 2009 +0200

    ide: remove chipset field from hw_regs_t
    
    * Convert host drivers that still use hw_regs_t's chipset field to use
      the one in struct ide_port_info instead.
    
    * Move special handling of ide_pci chipset type from ide_hw_configure()
      to ide_init_port().
    
    * Remove chipset field from hw_regs_t.
    
    While at it:
    - remove stale comment in delkin_cb.c
    
    There should be no functional changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index 36da913cc553..6352a44ed179 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -398,11 +398,11 @@ static void icside_setup_ports(hw_regs_t *hw, void __iomem *base,
 
 	hw->irq = ec->irq;
 	hw->dev = &ec->dev;
-	hw->chipset = ide_acorn;
 }
 
 static const struct ide_port_info icside_v5_port_info = {
 	.host_flags		= IDE_HFLAG_NO_DMA,
+	.chipset		= ide_acorn,
 };
 
 static int __devinit
@@ -457,6 +457,7 @@ static const struct ide_port_info icside_v6_port_info __initdata = {
 	.host_flags		= IDE_HFLAG_SERIALIZE | IDE_HFLAG_MMIO,
 	.mwdma_mask		= ATA_MWDMA2,
 	.swdma_mask		= ATA_SWDMA2,
+	.chipset		= ide_acorn,
 };
 
 static int __devinit

commit b019447ce73513432af052f30fa239d6dc93e111
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Sat May 16 19:03:36 2009 +0200

    icside: register second channel of version 6 PCB
    
    The second IDE channel of version 6 PCB is not being registered anymore since
    the commit 48c3c1072651922ed153bcf0a33ea82cf20df390 (ide: add struct ide_host
    (take 3)).
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index 4e16ce68b063..36da913cc553 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -466,7 +466,7 @@ icside_register_v6(struct icside_state *state, struct expansion_card *ec)
 	struct ide_host *host;
 	unsigned int sel = 0;
 	int ret;
-	hw_regs_t hw[2], *hws[] = { &hw[0], NULL, NULL, NULL };
+	hw_regs_t hw[2], *hws[] = { &hw[0], &hw[1], NULL, NULL };
 	struct ide_port_info d = icside_v6_port_info;
 
 	ioc_base = ecardm_iomap(ec, ECARD_RES_IOCFAST, 0, 0);

commit 88b4132e101e60e8fa67996ae3072ab6b71e8500
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Mar 31 20:15:22 2009 +0200

    ide: set/clear drive->waiting_for_dma flag in the core code
    
    Set/clear drive->waiting_for_dma flag in the core code
    instead of in ->dma_setup and ->dma_end methods.
    
    There should be no functional changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index 9bf57d7c8e57..4e16ce68b063 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -287,8 +287,6 @@ static int icside_dma_end(ide_drive_t *drive)
 	ide_hwif_t *hwif = drive->hwif;
 	struct expansion_card *ec = ECARD_DEV(hwif->dev);
 
-	drive->waiting_for_dma = 0;
-
 	disable_dma(ec->dma);
 
 	return get_dma_residue(ec->dma) != 0;
@@ -343,8 +341,6 @@ static int icside_dma_setup(ide_drive_t *drive, struct ide_cmd *cmd)
 	set_dma_sg(ec->dma, hwif->sg_table, cmd->sg_nents);
 	set_dma_mode(ec->dma, dma_mode);
 
-	drive->waiting_for_dma = 1;
-
 	return 0;
 }
 

commit 4453011f959a5f5c6c7a33aea54fe17f5e43a867
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Mar 31 20:15:20 2009 +0200

    ide: destroy DMA mappings after ending DMA (v2)
    
    Move ide_destroy_dmatable() call out from ->dma_end method to
    {ide_pc,cdrom_newpc,ide_dma}_intr(), ide_dma_timeout_retry()
    and sgiioc4_resetproc().
    
    This causes minor/safe behavior changes w.r.t.:
    * cmd64x.c::cmd64{8,x}_dma_end()
    * cs5536.c::cs5536_dma_end()
    * icside.c::icside_dma_end()
    * it821x.c::it821x_dma_end()
    * scc_pata.c::__scc_dma_end()
    * sl82c105.c::sl82c105_dma_end()
    * tx4939ide.c::tx4939ide_dma_end()
    
    v2:
    * Fix build for CONFIG_BLK_DEV_IDEDMA=n (reported by Randy Dunlap).
    
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index f069f122ee6e..9bf57d7c8e57 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -291,9 +291,6 @@ static int icside_dma_end(ide_drive_t *drive)
 
 	disable_dma(ec->dma);
 
-	/* Teardown mappings after DMA has completed. */
-	ide_destroy_dmatable(drive);
-
 	return get_dma_residue(ec->dma) != 0;
 }
 

commit 35c9b4daf4c94b30e5cede597d98016ebf31b5ad
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Mar 31 20:15:19 2009 +0200

    ide: add ->dma_clear method and remove ->dma_timeout one
    
    All custom ->dma_timeout implementations call the generic one thus it is
    possible to have only an optional method for resetting DMA engine instead:
    
    * Add ->dma_clear method and convert hpt366, pdc202xx_old and sl82c105
      host drivers to use it.
    
    * Always use ide_dma_timeout() in ide_dma_timeout_retry() and remove
     ->dma_timeout method.
    
    * Make ide_dma_timeout() static.
    
    There should be no functional changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index 51ce404fe532..f069f122ee6e 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -377,7 +377,6 @@ static const struct ide_dma_ops icside_v6_dma_ops = {
 	.dma_start		= icside_dma_start,
 	.dma_end		= icside_dma_end,
 	.dma_test_irq		= icside_dma_test_irq,
-	.dma_timeout		= ide_dma_timeout,
 	.dma_lost_irq		= ide_dma_lost_irq,
 };
 #else

commit 22117d6eaac50d366d9013c88318a869ea4d8739
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Mar 27 12:46:47 2009 +0100

    ide: add ->dma_timer_expiry method and remove ->dma_exec_cmd one (v2)
    
    * Rename dma_timer_expiry() to ide_dma_sff_timer_expiry() and export it.
    
    * Add ->dma_timer_expiry method and use it to set hwif->expiry for
      ATA_PROT_DMA protocol in do_rw_taskfile().
    
    * Initialize ->dma_timer_expiry to ide_dma_sff_timer_expiry() for SFF hosts.
    
    * Move setting hwif->expiry from ide_execute_command() to its users and drop
      'expiry' argument.
    
    * Use ide_execute_command() instead of ->dma_exec_cmd in do_rw_taskfile().
    
    * Remove ->dma_exec_cmd method and its implementations.
    
    * Unexport ide_execute_command() and ide_dma_intr().
    
    v2:
    * Fix CONFIG_BLK_DEV_IDEDMA=n build (noticed by Randy Dunlap).
    
    * Fix *dma_expiry naming (suggested by Sergei Shtylyov).
    
    There should be no functional changes caused by this patch.
    
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index 3628b2147902..51ce404fe532 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -351,12 +351,6 @@ static int icside_dma_setup(ide_drive_t *drive, struct ide_cmd *cmd)
 	return 0;
 }
 
-static void icside_dma_exec_cmd(ide_drive_t *drive, u8 cmd)
-{
-	/* issue cmd to drive */
-	ide_execute_command(drive, cmd, ide_dma_intr, 2 * WAIT_CMD, NULL);
-}
-
 static int icside_dma_test_irq(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = drive->hwif;
@@ -380,7 +374,6 @@ static int icside_dma_init(ide_hwif_t *hwif, const struct ide_port_info *d)
 static const struct ide_dma_ops icside_v6_dma_ops = {
 	.dma_host_set		= icside_dma_host_set,
 	.dma_setup		= icside_dma_setup,
-	.dma_exec_cmd		= icside_dma_exec_cmd,
 	.dma_start		= icside_dma_start,
 	.dma_end		= icside_dma_end,
 	.dma_test_irq		= icside_dma_test_irq,

commit 2298169418f43ba5e0919762a4bab95a1227872a
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Mar 27 12:46:46 2009 +0100

    ide: pass command to ide_map_sg()
    
    * Set IDE_TFLAG_WRITE flag and ->rq also for ATA_CMD_PACKET
      commands.
    
    * Pass command to ->dma_setup method and update all its
      implementations accordingly.
    
    * Pass command instead of request to ide_build_sglist(),
      *_build_dmatable() and ide_map_sg().
    
    While at it:
    
    * Fix scc_dma_setup() documentation + use ATA_DMA_WR define.
    
    * Rename sgiioc4_build_dma_table() to sgiioc4_build_dmatable(),
      change return value type to 'int' and drop unused 'ddir'
      argument.
    
    * Do some minor cleanups in [tx4939]ide_dma_setup().
    
    There should be no functional changes caused by this patch.
    
    Acked-by: Borislav Petkov <petkovbb@gmail.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index bdfeb1222d52..3628b2147902 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -307,15 +307,14 @@ static void icside_dma_start(ide_drive_t *drive)
 	enable_dma(ec->dma);
 }
 
-static int icside_dma_setup(ide_drive_t *drive)
+static int icside_dma_setup(ide_drive_t *drive, struct ide_cmd *cmd)
 {
 	ide_hwif_t *hwif = drive->hwif;
 	struct expansion_card *ec = ECARD_DEV(hwif->dev);
 	struct icside_state *state = ecard_get_drvdata(ec);
-	struct request *rq = hwif->rq;
 	unsigned int dma_mode;
 
-	if (rq_data_dir(rq))
+	if (cmd->tf_flags & IDE_TFLAG_WRITE)
 		dma_mode = DMA_MODE_WRITE;
 	else
 		dma_mode = DMA_MODE_READ;
@@ -344,7 +343,7 @@ static int icside_dma_setup(ide_drive_t *drive)
 	 * Tell the DMA engine about the SG table and
 	 * data direction.
 	 */
-	set_dma_sg(ec->dma, hwif->sg_table, hwif->cmd.sg_nents);
+	set_dma_sg(ec->dma, hwif->sg_table, cmd->sg_nents);
 	set_dma_mode(ec->dma, dma_mode);
 
 	drive->waiting_for_dma = 1;

commit b6308ee0c55acd2e943d849773c9f0a49c516317
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Mar 27 12:46:38 2009 +0100

    ide: move command related fields from ide_hwif_t to struct ide_cmd
    
    * Move command related fields from ide_hwif_t to struct ide_cmd.
    
    * Make ide_init_sg_cmd() take command and sectors number as arguments.
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index 78fc36f98d29..bdfeb1222d52 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -344,7 +344,7 @@ static int icside_dma_setup(ide_drive_t *drive)
 	 * Tell the DMA engine about the SG table and
 	 * data direction.
 	 */
-	set_dma_sg(ec->dma, hwif->sg_table, hwif->sg_nents);
+	set_dma_sg(ec->dma, hwif->sg_table, hwif->cmd.sg_nents);
 	set_dma_mode(ec->dma, dma_mode);
 
 	drive->waiting_for_dma = 1;

commit e6830a86c260d73c6f370aa7ed17ee6c71e5ee05
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Mar 27 12:46:37 2009 +0100

    ide: call ide_build_sglist() prior to ->dma_setup (v2)
    
    * Re-map sg table if needed in ide_build_sglist().
    
    * Move ide_build_sglist() call from ->dma_setup to its users.
    
    * Un-export ide_build_sglist().
    
    v2:
    * Build fix for CONFIG_BLK_DEV_IDEDMA=n (noticed by Randy Dunlap).
    
    There should be no functional changes caused by this patch.
    
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index cf0522f937c1..78fc36f98d29 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -325,12 +325,6 @@ static int icside_dma_setup(ide_drive_t *drive)
 	 */
 	BUG_ON(dma_channel_active(ec->dma));
 
-	hwif->sg_nents = ide_build_sglist(drive, rq);
-	if (hwif->sg_nents == 0) {
-		ide_map_sg(drive, rq);
-		return 1;
-	}
-
 	/*
 	 * Ensure that we have the right interrupt routed.
 	 */

commit f7ef12482b17a015906cf74afe655e691b5fa2cb
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Mar 27 12:46:32 2009 +0100

    icside: icside_dma_setup() fixes
    
    Check for ide_build_sglist() return value and re-map sg table if necessary.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index 0cf47e6e9793..cf0522f937c1 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -326,6 +326,10 @@ static int icside_dma_setup(ide_drive_t *drive)
 	BUG_ON(dma_channel_active(ec->dma));
 
 	hwif->sg_nents = ide_build_sglist(drive, rq);
+	if (hwif->sg_nents == 0) {
+		ide_map_sg(drive, rq);
+		return 1;
+	}
 
 	/*
 	 * Ensure that we have the right interrupt routed.

commit 33050ec7a2b83bc048b2322c79af25df6fdcb879
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Mar 27 12:46:17 2009 +0100

    icside: use struct ide_port_info also for PCB version 5 (v2)
    
    This fixes hwif->channel and drive->dn assignments.
    
    v2:
    Fix v5/v6 mismatch noticed by Russell.
    
    Cc: Russell King <rmk@arm.linux.org.uk>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index 415d7e24f2b6..0cf47e6e9793 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -419,6 +419,10 @@ static void icside_setup_ports(hw_regs_t *hw, void __iomem *base,
 	hw->chipset = ide_acorn;
 }
 
+static const struct ide_port_info icside_v5_port_info = {
+	.host_flags		= IDE_HFLAG_NO_DMA,
+};
+
 static int __devinit
 icside_register_v5(struct icside_state *state, struct expansion_card *ec)
 {
@@ -445,7 +449,7 @@ icside_register_v5(struct icside_state *state, struct expansion_card *ec)
 
 	icside_setup_ports(&hw, base, &icside_cardinfo_v5, ec);
 
-	host = ide_host_alloc(NULL, hws);
+	host = ide_host_alloc(&icside_v5_port_info, hws);
 	if (host == NULL)
 		return -ENODEV;
 
@@ -453,7 +457,7 @@ icside_register_v5(struct icside_state *state, struct expansion_card *ec)
 
 	ecard_set_drvdata(ec, state);
 
-	ret = ide_host_register(host, NULL, hws);
+	ret = ide_host_register(host, &icside_v5_port_info, hws);
 	if (ret)
 		goto err_free;
 

commit d224b6269e4731a82f648bb0281ea1a4d8b3311d
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Feb 2 20:12:23 2009 +0100

    icside: fix PCB version 6 support (v2)
    
    We need to pass struct ide_port_info also to ide_host_register().
    
    v2:
    Fix v5/v6 mismatch noticed by Russell.
    
    Cc: Russell King <rmk@arm.linux.org.uk>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index 97a35c667aee..415d7e24f2b6 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -534,7 +534,7 @@ icside_register_v6(struct icside_state *state, struct expansion_card *ec)
 		d.dma_ops = NULL;
 	}
 
-	ret = ide_host_register(host, NULL, hws);
+	ret = ide_host_register(host, &d, hws);
 	if (ret)
 		goto err_free;
 

commit 898ec223fea2a2df88035e58dbf50f493577e225
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jan 6 17:20:52 2009 +0100

    ide: remove HWIF() macro
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index 72d95c99f147..97a35c667aee 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -166,7 +166,7 @@ static const expansioncard_ops_t icside_ops_arcin_v6 = {
  */
 static void icside_maskproc(ide_drive_t *drive, int mask)
 {
-	ide_hwif_t *hwif = HWIF(drive);
+	ide_hwif_t *hwif = drive->hwif;
 	struct expansion_card *ec = ECARD_DEV(hwif->dev);
 	struct icside_state *state = ecard_get_drvdata(ec);
 	unsigned long flags;
@@ -284,7 +284,7 @@ static void icside_dma_host_set(ide_drive_t *drive, int on)
 
 static int icside_dma_end(ide_drive_t *drive)
 {
-	ide_hwif_t *hwif = HWIF(drive);
+	ide_hwif_t *hwif = drive->hwif;
 	struct expansion_card *ec = ECARD_DEV(hwif->dev);
 
 	drive->waiting_for_dma = 0;
@@ -299,7 +299,7 @@ static int icside_dma_end(ide_drive_t *drive)
 
 static void icside_dma_start(ide_drive_t *drive)
 {
-	ide_hwif_t *hwif = HWIF(drive);
+	ide_hwif_t *hwif = drive->hwif;
 	struct expansion_card *ec = ECARD_DEV(hwif->dev);
 
 	/* We can not enable DMA on both channels simultaneously. */
@@ -309,7 +309,7 @@ static void icside_dma_start(ide_drive_t *drive)
 
 static int icside_dma_setup(ide_drive_t *drive)
 {
-	ide_hwif_t *hwif = HWIF(drive);
+	ide_hwif_t *hwif = drive->hwif;
 	struct expansion_card *ec = ECARD_DEV(hwif->dev);
 	struct icside_state *state = ecard_get_drvdata(ec);
 	struct request *rq = hwif->rq;
@@ -362,7 +362,7 @@ static void icside_dma_exec_cmd(ide_drive_t *drive, u8 cmd)
 
 static int icside_dma_test_irq(ide_drive_t *drive)
 {
-	ide_hwif_t *hwif = HWIF(drive);
+	ide_hwif_t *hwif = drive->hwif;
 	struct expansion_card *ec = ECARD_DEV(hwif->dev);
 	struct icside_state *state = ecard_get_drvdata(ec);
 

commit b65fac32cfe3b2f98cd472fef400bd1c1340de23
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jan 6 17:20:50 2009 +0100

    ide: merge ide_hwgroup_t with ide_hwif_t (v2)
    
    * Merge ide_hwgroup_t with ide_hwif_t.
    
    * Cleanup init_irq() accordingly, then remove no longer needed
      ide_remove_port_from_hwgroup() and ide_ports[].
    
    * Remove now unused HWGROUP() macro.
    
    While at it:
    
    * ide_dump_ata_error() fixups
    
    v2:
    * Fix ->quirk_list check in do_ide_request()
      (s/hwif->cur_dev/prev_port->cur_dev).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index 81f70caeb40f..72d95c99f147 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -312,7 +312,7 @@ static int icside_dma_setup(ide_drive_t *drive)
 	ide_hwif_t *hwif = HWIF(drive);
 	struct expansion_card *ec = ECARD_DEV(hwif->dev);
 	struct icside_state *state = ecard_get_drvdata(ec);
-	struct request *rq = hwif->hwgroup->rq;
+	struct request *rq = hwif->rq;
 	unsigned int dma_mode;
 
 	if (rq_data_dir(rq))

commit d16d7667f9c211e8d9b7e2365cc3d3a83fc6a8e2
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sat Nov 22 17:34:34 2008 +0000

    icside section warnings
    
    icside_register_v[56] is called from (__devinit) icside_probe
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index 2d848010499d..81f70caeb40f 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -419,7 +419,7 @@ static void icside_setup_ports(hw_regs_t *hw, void __iomem *base,
 	hw->chipset = ide_acorn;
 }
 
-static int __init
+static int __devinit
 icside_register_v5(struct icside_state *state, struct expansion_card *ec)
 {
 	void __iomem *base;
@@ -473,7 +473,7 @@ static const struct ide_port_info icside_v6_port_info __initdata = {
 	.swdma_mask		= ATA_SWDMA2,
 };
 
-static int __init
+static int __devinit
 icside_register_v6(struct icside_state *state, struct expansion_card *ec)
 {
 	void __iomem *ioc_base, *easi_base;

commit 1137fb670465b6b5d15b9db7d01707a5833ee3ae
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Sun Oct 26 05:40:26 2008 +0000

    arm ide breakage
    
    a) semicolon before the function body is a bad idea
    b) it's const struct foo, not struct const foo
    c) incidentally, it's ecard_remove_driver(), not ecard_unregister_driver()
    d) compiling is occasionally useful.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
index 76bdc9a27f6f..2d848010499d 100644
--- a/drivers/ide/icside.c
+++ b/drivers/ide/icside.c
@@ -690,9 +690,9 @@ static int __init icside_init(void)
 	return ecard_register_driver(&icside_driver);
 }
 
-static void __exit icside_exit(void);
+static void __exit icside_exit(void)
 {
-	ecard_unregister_driver(&icside_driver);
+	ecard_remove_driver(&icside_driver);
 }
 
 MODULE_AUTHOR("Russell King <rmk@arm.linux.org.uk>");

commit 2bfba3c444fe8b2ab1c38112a89d8f03b61136ca
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Oct 21 20:57:23 2008 +0200

    ide: remove useless subdirs from drivers/ide/
    
    Suggested-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/icside.c b/drivers/ide/icside.c
new file mode 100644
index 000000000000..76bdc9a27f6f
--- /dev/null
+++ b/drivers/ide/icside.c
@@ -0,0 +1,703 @@
+/*
+ * Copyright (c) 1996-2004 Russell King.
+ *
+ * Please note that this platform does not support 32-bit IDE IO.
+ */
+
+#include <linux/string.h>
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/blkdev.h>
+#include <linux/errno.h>
+#include <linux/ide.h>
+#include <linux/dma-mapping.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/scatterlist.h>
+#include <linux/io.h>
+
+#include <asm/dma.h>
+#include <asm/ecard.h>
+
+#define DRV_NAME "icside"
+
+#define ICS_IDENT_OFFSET		0x2280
+
+#define ICS_ARCIN_V5_INTRSTAT		0x0000
+#define ICS_ARCIN_V5_INTROFFSET		0x0004
+#define ICS_ARCIN_V5_IDEOFFSET		0x2800
+#define ICS_ARCIN_V5_IDEALTOFFSET	0x2b80
+#define ICS_ARCIN_V5_IDESTEPPING	6
+
+#define ICS_ARCIN_V6_IDEOFFSET_1	0x2000
+#define ICS_ARCIN_V6_INTROFFSET_1	0x2200
+#define ICS_ARCIN_V6_INTRSTAT_1		0x2290
+#define ICS_ARCIN_V6_IDEALTOFFSET_1	0x2380
+#define ICS_ARCIN_V6_IDEOFFSET_2	0x3000
+#define ICS_ARCIN_V6_INTROFFSET_2	0x3200
+#define ICS_ARCIN_V6_INTRSTAT_2		0x3290
+#define ICS_ARCIN_V6_IDEALTOFFSET_2	0x3380
+#define ICS_ARCIN_V6_IDESTEPPING	6
+
+struct cardinfo {
+	unsigned int dataoffset;
+	unsigned int ctrloffset;
+	unsigned int stepping;
+};
+
+static struct cardinfo icside_cardinfo_v5 = {
+	.dataoffset	= ICS_ARCIN_V5_IDEOFFSET,
+	.ctrloffset	= ICS_ARCIN_V5_IDEALTOFFSET,
+	.stepping	= ICS_ARCIN_V5_IDESTEPPING,
+};
+
+static struct cardinfo icside_cardinfo_v6_1 = {
+	.dataoffset	= ICS_ARCIN_V6_IDEOFFSET_1,
+	.ctrloffset	= ICS_ARCIN_V6_IDEALTOFFSET_1,
+	.stepping	= ICS_ARCIN_V6_IDESTEPPING,
+};
+
+static struct cardinfo icside_cardinfo_v6_2 = {
+	.dataoffset	= ICS_ARCIN_V6_IDEOFFSET_2,
+	.ctrloffset	= ICS_ARCIN_V6_IDEALTOFFSET_2,
+	.stepping	= ICS_ARCIN_V6_IDESTEPPING,
+};
+
+struct icside_state {
+	unsigned int channel;
+	unsigned int enabled;
+	void __iomem *irq_port;
+	void __iomem *ioc_base;
+	unsigned int sel;
+	unsigned int type;
+	struct ide_host *host;
+};
+
+#define ICS_TYPE_A3IN	0
+#define ICS_TYPE_A3USER	1
+#define ICS_TYPE_V6	3
+#define ICS_TYPE_V5	15
+#define ICS_TYPE_NOTYPE	((unsigned int)-1)
+
+/* ---------------- Version 5 PCB Support Functions --------------------- */
+/* Prototype: icside_irqenable_arcin_v5 (struct expansion_card *ec, int irqnr)
+ * Purpose  : enable interrupts from card
+ */
+static void icside_irqenable_arcin_v5 (struct expansion_card *ec, int irqnr)
+{
+	struct icside_state *state = ec->irq_data;
+
+	writeb(0, state->irq_port + ICS_ARCIN_V5_INTROFFSET);
+}
+
+/* Prototype: icside_irqdisable_arcin_v5 (struct expansion_card *ec, int irqnr)
+ * Purpose  : disable interrupts from card
+ */
+static void icside_irqdisable_arcin_v5 (struct expansion_card *ec, int irqnr)
+{
+	struct icside_state *state = ec->irq_data;
+
+	readb(state->irq_port + ICS_ARCIN_V5_INTROFFSET);
+}
+
+static const expansioncard_ops_t icside_ops_arcin_v5 = {
+	.irqenable	= icside_irqenable_arcin_v5,
+	.irqdisable	= icside_irqdisable_arcin_v5,
+};
+
+
+/* ---------------- Version 6 PCB Support Functions --------------------- */
+/* Prototype: icside_irqenable_arcin_v6 (struct expansion_card *ec, int irqnr)
+ * Purpose  : enable interrupts from card
+ */
+static void icside_irqenable_arcin_v6 (struct expansion_card *ec, int irqnr)
+{
+	struct icside_state *state = ec->irq_data;
+	void __iomem *base = state->irq_port;
+
+	state->enabled = 1;
+
+	switch (state->channel) {
+	case 0:
+		writeb(0, base + ICS_ARCIN_V6_INTROFFSET_1);
+		readb(base + ICS_ARCIN_V6_INTROFFSET_2);
+		break;
+	case 1:
+		writeb(0, base + ICS_ARCIN_V6_INTROFFSET_2);
+		readb(base + ICS_ARCIN_V6_INTROFFSET_1);
+		break;
+	}
+}
+
+/* Prototype: icside_irqdisable_arcin_v6 (struct expansion_card *ec, int irqnr)
+ * Purpose  : disable interrupts from card
+ */
+static void icside_irqdisable_arcin_v6 (struct expansion_card *ec, int irqnr)
+{
+	struct icside_state *state = ec->irq_data;
+
+	state->enabled = 0;
+
+	readb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);
+	readb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);
+}
+
+/* Prototype: icside_irqprobe(struct expansion_card *ec)
+ * Purpose  : detect an active interrupt from card
+ */
+static int icside_irqpending_arcin_v6(struct expansion_card *ec)
+{
+	struct icside_state *state = ec->irq_data;
+
+	return readb(state->irq_port + ICS_ARCIN_V6_INTRSTAT_1) & 1 ||
+	       readb(state->irq_port + ICS_ARCIN_V6_INTRSTAT_2) & 1;
+}
+
+static const expansioncard_ops_t icside_ops_arcin_v6 = {
+	.irqenable	= icside_irqenable_arcin_v6,
+	.irqdisable	= icside_irqdisable_arcin_v6,
+	.irqpending	= icside_irqpending_arcin_v6,
+};
+
+/*
+ * Handle routing of interrupts.  This is called before
+ * we write the command to the drive.
+ */
+static void icside_maskproc(ide_drive_t *drive, int mask)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	struct expansion_card *ec = ECARD_DEV(hwif->dev);
+	struct icside_state *state = ecard_get_drvdata(ec);
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	state->channel = hwif->channel;
+
+	if (state->enabled && !mask) {
+		switch (hwif->channel) {
+		case 0:
+			writeb(0, state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);
+			readb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);
+			break;
+		case 1:
+			writeb(0, state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);
+			readb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);
+			break;
+		}
+	} else {
+		readb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);
+		readb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);
+	}
+
+	local_irq_restore(flags);
+}
+
+static const struct ide_port_ops icside_v6_no_dma_port_ops = {
+	.maskproc		= icside_maskproc,
+};
+
+#ifdef CONFIG_BLK_DEV_IDEDMA_ICS
+/*
+ * SG-DMA support.
+ *
+ * Similar to the BM-DMA, but we use the RiscPCs IOMD DMA controllers.
+ * There is only one DMA controller per card, which means that only
+ * one drive can be accessed at one time.  NOTE! We do not enforce that
+ * here, but we rely on the main IDE driver spotting that both
+ * interfaces use the same IRQ, which should guarantee this.
+ */
+
+/*
+ * Configure the IOMD to give the appropriate timings for the transfer
+ * mode being requested.  We take the advice of the ATA standards, and
+ * calculate the cycle time based on the transfer mode, and the EIDE
+ * MW DMA specs that the drive provides in the IDENTIFY command.
+ *
+ * We have the following IOMD DMA modes to choose from:
+ *
+ *	Type	Active		Recovery	Cycle
+ *	A	250 (250)	312 (550)	562 (800)
+ *	B	187		250		437
+ *	C	125 (125)	125 (375)	250 (500)
+ *	D	62		125		187
+ *
+ * (figures in brackets are actual measured timings)
+ *
+ * However, we also need to take care of the read/write active and
+ * recovery timings:
+ *
+ *			Read	Write
+ *  	Mode	Active	-- Recovery --	Cycle	IOMD type
+ *	MW0	215	50	215	480	A
+ *	MW1	80	50	50	150	C
+ *	MW2	70	25	25	120	C
+ */
+static void icside_set_dma_mode(ide_drive_t *drive, const u8 xfer_mode)
+{
+	int cycle_time, use_dma_info = 0;
+
+	switch (xfer_mode) {
+	case XFER_MW_DMA_2:
+		cycle_time = 250;
+		use_dma_info = 1;
+		break;
+
+	case XFER_MW_DMA_1:
+		cycle_time = 250;
+		use_dma_info = 1;
+		break;
+
+	case XFER_MW_DMA_0:
+		cycle_time = 480;
+		break;
+
+	case XFER_SW_DMA_2:
+	case XFER_SW_DMA_1:
+	case XFER_SW_DMA_0:
+		cycle_time = 480;
+		break;
+	}
+
+	/*
+	 * If we're going to be doing MW_DMA_1 or MW_DMA_2, we should
+	 * take care to note the values in the ID...
+	 */
+	if (use_dma_info && drive->id[ATA_ID_EIDE_DMA_TIME] > cycle_time)
+		cycle_time = drive->id[ATA_ID_EIDE_DMA_TIME];
+
+	drive->drive_data = cycle_time;
+
+	printk("%s: %s selected (peak %dMB/s)\n", drive->name,
+		ide_xfer_verbose(xfer_mode), 2000 / drive->drive_data);
+}
+
+static const struct ide_port_ops icside_v6_port_ops = {
+	.set_dma_mode		= icside_set_dma_mode,
+	.maskproc		= icside_maskproc,
+};
+
+static void icside_dma_host_set(ide_drive_t *drive, int on)
+{
+}
+
+static int icside_dma_end(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	struct expansion_card *ec = ECARD_DEV(hwif->dev);
+
+	drive->waiting_for_dma = 0;
+
+	disable_dma(ec->dma);
+
+	/* Teardown mappings after DMA has completed. */
+	ide_destroy_dmatable(drive);
+
+	return get_dma_residue(ec->dma) != 0;
+}
+
+static void icside_dma_start(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	struct expansion_card *ec = ECARD_DEV(hwif->dev);
+
+	/* We can not enable DMA on both channels simultaneously. */
+	BUG_ON(dma_channel_active(ec->dma));
+	enable_dma(ec->dma);
+}
+
+static int icside_dma_setup(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	struct expansion_card *ec = ECARD_DEV(hwif->dev);
+	struct icside_state *state = ecard_get_drvdata(ec);
+	struct request *rq = hwif->hwgroup->rq;
+	unsigned int dma_mode;
+
+	if (rq_data_dir(rq))
+		dma_mode = DMA_MODE_WRITE;
+	else
+		dma_mode = DMA_MODE_READ;
+
+	/*
+	 * We can not enable DMA on both channels.
+	 */
+	BUG_ON(dma_channel_active(ec->dma));
+
+	hwif->sg_nents = ide_build_sglist(drive, rq);
+
+	/*
+	 * Ensure that we have the right interrupt routed.
+	 */
+	icside_maskproc(drive, 0);
+
+	/*
+	 * Route the DMA signals to the correct interface.
+	 */
+	writeb(state->sel | hwif->channel, state->ioc_base);
+
+	/*
+	 * Select the correct timing for this drive.
+	 */
+	set_dma_speed(ec->dma, drive->drive_data);
+
+	/*
+	 * Tell the DMA engine about the SG table and
+	 * data direction.
+	 */
+	set_dma_sg(ec->dma, hwif->sg_table, hwif->sg_nents);
+	set_dma_mode(ec->dma, dma_mode);
+
+	drive->waiting_for_dma = 1;
+
+	return 0;
+}
+
+static void icside_dma_exec_cmd(ide_drive_t *drive, u8 cmd)
+{
+	/* issue cmd to drive */
+	ide_execute_command(drive, cmd, ide_dma_intr, 2 * WAIT_CMD, NULL);
+}
+
+static int icside_dma_test_irq(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	struct expansion_card *ec = ECARD_DEV(hwif->dev);
+	struct icside_state *state = ecard_get_drvdata(ec);
+
+	return readb(state->irq_port +
+		     (hwif->channel ?
+			ICS_ARCIN_V6_INTRSTAT_2 :
+			ICS_ARCIN_V6_INTRSTAT_1)) & 1;
+}
+
+static int icside_dma_init(ide_hwif_t *hwif, const struct ide_port_info *d)
+{
+	hwif->dmatable_cpu	= NULL;
+	hwif->dmatable_dma	= 0;
+
+	return 0;
+}
+
+static const struct ide_dma_ops icside_v6_dma_ops = {
+	.dma_host_set		= icside_dma_host_set,
+	.dma_setup		= icside_dma_setup,
+	.dma_exec_cmd		= icside_dma_exec_cmd,
+	.dma_start		= icside_dma_start,
+	.dma_end		= icside_dma_end,
+	.dma_test_irq		= icside_dma_test_irq,
+	.dma_timeout		= ide_dma_timeout,
+	.dma_lost_irq		= ide_dma_lost_irq,
+};
+#else
+#define icside_v6_dma_ops NULL
+#endif
+
+static int icside_dma_off_init(ide_hwif_t *hwif, const struct ide_port_info *d)
+{
+	return -EOPNOTSUPP;
+}
+
+static void icside_setup_ports(hw_regs_t *hw, void __iomem *base,
+			       struct cardinfo *info, struct expansion_card *ec)
+{
+	unsigned long port = (unsigned long)base + info->dataoffset;
+
+	hw->io_ports.data_addr	 = port;
+	hw->io_ports.error_addr	 = port + (1 << info->stepping);
+	hw->io_ports.nsect_addr	 = port + (2 << info->stepping);
+	hw->io_ports.lbal_addr	 = port + (3 << info->stepping);
+	hw->io_ports.lbam_addr	 = port + (4 << info->stepping);
+	hw->io_ports.lbah_addr	 = port + (5 << info->stepping);
+	hw->io_ports.device_addr = port + (6 << info->stepping);
+	hw->io_ports.status_addr = port + (7 << info->stepping);
+	hw->io_ports.ctl_addr	 = (unsigned long)base + info->ctrloffset;
+
+	hw->irq = ec->irq;
+	hw->dev = &ec->dev;
+	hw->chipset = ide_acorn;
+}
+
+static int __init
+icside_register_v5(struct icside_state *state, struct expansion_card *ec)
+{
+	void __iomem *base;
+	struct ide_host *host;
+	hw_regs_t hw, *hws[] = { &hw, NULL, NULL, NULL };
+	int ret;
+
+	base = ecardm_iomap(ec, ECARD_RES_MEMC, 0, 0);
+	if (!base)
+		return -ENOMEM;
+
+	state->irq_port = base;
+
+	ec->irqaddr  = base + ICS_ARCIN_V5_INTRSTAT;
+	ec->irqmask  = 1;
+
+	ecard_setirq(ec, &icside_ops_arcin_v5, state);
+
+	/*
+	 * Be on the safe side - disable interrupts
+	 */
+	icside_irqdisable_arcin_v5(ec, 0);
+
+	icside_setup_ports(&hw, base, &icside_cardinfo_v5, ec);
+
+	host = ide_host_alloc(NULL, hws);
+	if (host == NULL)
+		return -ENODEV;
+
+	state->host = host;
+
+	ecard_set_drvdata(ec, state);
+
+	ret = ide_host_register(host, NULL, hws);
+	if (ret)
+		goto err_free;
+
+	return 0;
+err_free:
+	ide_host_free(host);
+	ecard_set_drvdata(ec, NULL);
+	return ret;
+}
+
+static const struct ide_port_info icside_v6_port_info __initdata = {
+	.init_dma		= icside_dma_off_init,
+	.port_ops		= &icside_v6_no_dma_port_ops,
+	.dma_ops		= &icside_v6_dma_ops,
+	.host_flags		= IDE_HFLAG_SERIALIZE | IDE_HFLAG_MMIO,
+	.mwdma_mask		= ATA_MWDMA2,
+	.swdma_mask		= ATA_SWDMA2,
+};
+
+static int __init
+icside_register_v6(struct icside_state *state, struct expansion_card *ec)
+{
+	void __iomem *ioc_base, *easi_base;
+	struct ide_host *host;
+	unsigned int sel = 0;
+	int ret;
+	hw_regs_t hw[2], *hws[] = { &hw[0], NULL, NULL, NULL };
+	struct ide_port_info d = icside_v6_port_info;
+
+	ioc_base = ecardm_iomap(ec, ECARD_RES_IOCFAST, 0, 0);
+	if (!ioc_base) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	easi_base = ioc_base;
+
+	if (ecard_resource_flags(ec, ECARD_RES_EASI)) {
+		easi_base = ecardm_iomap(ec, ECARD_RES_EASI, 0, 0);
+		if (!easi_base) {
+			ret = -ENOMEM;
+			goto out;
+		}
+
+		/*
+		 * Enable access to the EASI region.
+		 */
+		sel = 1 << 5;
+	}
+
+	writeb(sel, ioc_base);
+
+	ecard_setirq(ec, &icside_ops_arcin_v6, state);
+
+	state->irq_port   = easi_base;
+	state->ioc_base   = ioc_base;
+	state->sel	  = sel;
+
+	/*
+	 * Be on the safe side - disable interrupts
+	 */
+	icside_irqdisable_arcin_v6(ec, 0);
+
+	icside_setup_ports(&hw[0], easi_base, &icside_cardinfo_v6_1, ec);
+	icside_setup_ports(&hw[1], easi_base, &icside_cardinfo_v6_2, ec);
+
+	host = ide_host_alloc(&d, hws);
+	if (host == NULL)
+		return -ENODEV;
+
+	state->host = host;
+
+	ecard_set_drvdata(ec, state);
+
+	if (ec->dma != NO_DMA && !request_dma(ec->dma, DRV_NAME)) {
+		d.init_dma = icside_dma_init;
+		d.port_ops = &icside_v6_port_ops;
+		d.dma_ops = NULL;
+	}
+
+	ret = ide_host_register(host, NULL, hws);
+	if (ret)
+		goto err_free;
+
+	return 0;
+err_free:
+	ide_host_free(host);
+	if (d.dma_ops)
+		free_dma(ec->dma);
+	ecard_set_drvdata(ec, NULL);
+out:
+	return ret;
+}
+
+static int __devinit
+icside_probe(struct expansion_card *ec, const struct ecard_id *id)
+{
+	struct icside_state *state;
+	void __iomem *idmem;
+	int ret;
+
+	ret = ecard_request_resources(ec);
+	if (ret)
+		goto out;
+
+	state = kzalloc(sizeof(struct icside_state), GFP_KERNEL);
+	if (!state) {
+		ret = -ENOMEM;
+		goto release;
+	}
+
+	state->type	= ICS_TYPE_NOTYPE;
+
+	idmem = ecardm_iomap(ec, ECARD_RES_IOCFAST, 0, 0);
+	if (idmem) {
+		unsigned int type;
+
+		type = readb(idmem + ICS_IDENT_OFFSET) & 1;
+		type |= (readb(idmem + ICS_IDENT_OFFSET + 4) & 1) << 1;
+		type |= (readb(idmem + ICS_IDENT_OFFSET + 8) & 1) << 2;
+		type |= (readb(idmem + ICS_IDENT_OFFSET + 12) & 1) << 3;
+		ecardm_iounmap(ec, idmem);
+
+		state->type = type;
+	}
+
+	switch (state->type) {
+	case ICS_TYPE_A3IN:
+		dev_warn(&ec->dev, "A3IN unsupported\n");
+		ret = -ENODEV;
+		break;
+
+	case ICS_TYPE_A3USER:
+		dev_warn(&ec->dev, "A3USER unsupported\n");
+		ret = -ENODEV;
+		break;
+
+	case ICS_TYPE_V5:
+		ret = icside_register_v5(state, ec);
+		break;
+
+	case ICS_TYPE_V6:
+		ret = icside_register_v6(state, ec);
+		break;
+
+	default:
+		dev_warn(&ec->dev, "unknown interface type\n");
+		ret = -ENODEV;
+		break;
+	}
+
+	if (ret == 0)
+		goto out;
+
+	kfree(state);
+ release:
+	ecard_release_resources(ec);
+ out:
+	return ret;
+}
+
+static void __devexit icside_remove(struct expansion_card *ec)
+{
+	struct icside_state *state = ecard_get_drvdata(ec);
+
+	switch (state->type) {
+	case ICS_TYPE_V5:
+		/* FIXME: tell IDE to stop using the interface */
+
+		/* Disable interrupts */
+		icside_irqdisable_arcin_v5(ec, 0);
+		break;
+
+	case ICS_TYPE_V6:
+		/* FIXME: tell IDE to stop using the interface */
+		if (ec->dma != NO_DMA)
+			free_dma(ec->dma);
+
+		/* Disable interrupts */
+		icside_irqdisable_arcin_v6(ec, 0);
+
+		/* Reset the ROM pointer/EASI selection */
+		writeb(0, state->ioc_base);
+		break;
+	}
+
+	ecard_set_drvdata(ec, NULL);
+
+	kfree(state);
+	ecard_release_resources(ec);
+}
+
+static void icside_shutdown(struct expansion_card *ec)
+{
+	struct icside_state *state = ecard_get_drvdata(ec);
+	unsigned long flags;
+
+	/*
+	 * Disable interrupts from this card.  We need to do
+	 * this before disabling EASI since we may be accessing
+	 * this register via that region.
+	 */
+	local_irq_save(flags);
+	ec->ops->irqdisable(ec, 0);
+	local_irq_restore(flags);
+
+	/*
+	 * Reset the ROM pointer so that we can read the ROM
+	 * after a soft reboot.  This also disables access to
+	 * the IDE taskfile via the EASI region.
+	 */
+	if (state->ioc_base)
+		writeb(0, state->ioc_base);
+}
+
+static const struct ecard_id icside_ids[] = {
+	{ MANU_ICS,  PROD_ICS_IDE  },
+	{ MANU_ICS2, PROD_ICS2_IDE },
+	{ 0xffff, 0xffff }
+};
+
+static struct ecard_driver icside_driver = {
+	.probe		= icside_probe,
+	.remove		= __devexit_p(icside_remove),
+	.shutdown	= icside_shutdown,
+	.id_table	= icside_ids,
+	.drv = {
+		.name	= "icside",
+	},
+};
+
+static int __init icside_init(void)
+{
+	return ecard_register_driver(&icside_driver);
+}
+
+static void __exit icside_exit(void);
+{
+	ecard_unregister_driver(&icside_driver);
+}
+
+MODULE_AUTHOR("Russell King <rmk@arm.linux.org.uk>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("ICS IDE driver");
+
+module_init(icside_init);
+module_exit(icside_exit);
