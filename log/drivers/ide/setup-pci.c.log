commit a06876a766c27dcedf17a0f60be89609ee23d861
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Tue Oct 3 14:17:13 2017 +0200

    ide: pci: free PCI BARs on initialization failure
    
    Recent pci_assign_irq() changes uncovered a problem with missing freeing of
    PCI BARs on PCI IDE host initialization failure:
    
      ide0: disabled, no IRQ
      ide0: failed to initialize IDE interface
      ide0: disabling port
      cmd64x 0000:00:02.0: IDE controller (0x1095:0x0646 rev 0x07)
      CMD64x_IDE 0000:00:02.0: BAR 0: can't reserve [io  0x8050-0x8057]
      cmd64x 0000:00:02.0: can't reserve resources
      CMD64x_IDE: probe of 0000:00:02.0 failed with error -16
    
    Fix the problem by adding missing freeing of PCI BARs to
    ide_setup_pci_controller() and ide_pci_init_two().
    
    Fixes: 30fdfb929e82 ("PCI: Add a call to pci_assign_irq() in pci_device_probe()")
    Fixes: 0e4c2eeb758a ("alpha/PCI: Replace pci_fixup_irqs() call with host bridge IRQ mapping hooks")
    Link: http://lkml.kernel.org/r/32ec730f-c1b0-5584-cd35-f8a809122b96@roeck-us.net
    Reported-by: Guenter Roeck <linux@roeck-us.net>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    [bhelgaas: add Fixes:]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Matt Turner <mattst88@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 112d2fe1bcdb..fdc8e813170c 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -179,6 +179,7 @@ EXPORT_SYMBOL_GPL(ide_setup_pci_noise);
 /**
  *	ide_pci_enable	-	do PCI enables
  *	@dev: PCI device
+ *	@bars: PCI BARs mask
  *	@d: IDE port info
  *
  *	Enable the IDE PCI device. We attempt to enable the device in full
@@ -189,9 +190,10 @@ EXPORT_SYMBOL_GPL(ide_setup_pci_noise);
  *	Returns zero on success or an error code
  */
 
-static int ide_pci_enable(struct pci_dev *dev, const struct ide_port_info *d)
+static int ide_pci_enable(struct pci_dev *dev, int bars,
+			  const struct ide_port_info *d)
 {
-	int ret, bars;
+	int ret;
 
 	if (pci_enable_device(dev)) {
 		ret = pci_enable_device_io(dev);
@@ -216,18 +218,6 @@ static int ide_pci_enable(struct pci_dev *dev, const struct ide_port_info *d)
 		goto out;
 	}
 
-	if (d->host_flags & IDE_HFLAG_SINGLE)
-		bars = (1 << 2) - 1;
-	else
-		bars = (1 << 4) - 1;
-
-	if ((d->host_flags & IDE_HFLAG_NO_DMA) == 0) {
-		if (d->host_flags & IDE_HFLAG_CS5520)
-			bars |= (1 << 2);
-		else
-			bars |= (1 << 4);
-	}
-
 	ret = pci_request_selected_regions(dev, bars, d->name);
 	if (ret < 0)
 		printk(KERN_ERR "%s %s: can't reserve resources\n",
@@ -403,6 +393,7 @@ int ide_hwif_setup_dma(ide_hwif_t *hwif, const struct ide_port_info *d)
 /**
  *	ide_setup_pci_controller	-	set up IDE PCI
  *	@dev: PCI device
+ *	@bars: PCI BARs mask
  *	@d: IDE port info
  *	@noisy: verbose flag
  *
@@ -411,7 +402,7 @@ int ide_hwif_setup_dma(ide_hwif_t *hwif, const struct ide_port_info *d)
  *	and enables it if need be
  */
 
-static int ide_setup_pci_controller(struct pci_dev *dev,
+static int ide_setup_pci_controller(struct pci_dev *dev, int bars,
 				    const struct ide_port_info *d, int noisy)
 {
 	int ret;
@@ -420,7 +411,7 @@ static int ide_setup_pci_controller(struct pci_dev *dev,
 	if (noisy)
 		ide_setup_pci_noise(dev, d);
 
-	ret = ide_pci_enable(dev, d);
+	ret = ide_pci_enable(dev, bars, d);
 	if (ret < 0)
 		goto out;
 
@@ -428,16 +419,20 @@ static int ide_setup_pci_controller(struct pci_dev *dev,
 	if (ret < 0) {
 		printk(KERN_ERR "%s %s: error accessing PCI regs\n",
 			d->name, pci_name(dev));
-		goto out;
+		goto out_free_bars;
 	}
 	if (!(pcicmd & PCI_COMMAND_IO)) {	/* is device disabled? */
 		ret = ide_pci_configure(dev, d);
 		if (ret < 0)
-			goto out;
+			goto out_free_bars;
 		printk(KERN_INFO "%s %s: device enabled (Linux)\n",
 			d->name, pci_name(dev));
 	}
 
+	goto out;
+
+out_free_bars:
+	pci_release_selected_regions(dev, bars);
 out:
 	return ret;
 }
@@ -540,13 +535,28 @@ int ide_pci_init_two(struct pci_dev *dev1, struct pci_dev *dev2,
 {
 	struct pci_dev *pdev[] = { dev1, dev2 };
 	struct ide_host *host;
-	int ret, i, n_ports = dev2 ? 4 : 2;
+	int ret, i, n_ports = dev2 ? 4 : 2, bars;
 	struct ide_hw hw[4], *hws[] = { NULL, NULL, NULL, NULL };
 
+	if (d->host_flags & IDE_HFLAG_SINGLE)
+		bars = (1 << 2) - 1;
+	else
+		bars = (1 << 4) - 1;
+
+	if ((d->host_flags & IDE_HFLAG_NO_DMA) == 0) {
+		if (d->host_flags & IDE_HFLAG_CS5520)
+			bars |= (1 << 2);
+		else
+			bars |= (1 << 4);
+	}
+
 	for (i = 0; i < n_ports / 2; i++) {
-		ret = ide_setup_pci_controller(pdev[i], d, !i);
-		if (ret < 0)
+		ret = ide_setup_pci_controller(pdev[i], bars, d, !i);
+		if (ret < 0) {
+			if (i == 1)
+				pci_release_selected_regions(pdev[0], bars);
 			goto out;
+		}
 
 		ide_pci_setup_ports(pdev[i], d, &hw[i*2], &hws[i*2]);
 	}
@@ -554,7 +564,7 @@ int ide_pci_init_two(struct pci_dev *dev1, struct pci_dev *dev2,
 	host = ide_host_alloc(d, hws, n_ports);
 	if (host == NULL) {
 		ret = -ENOMEM;
-		goto out;
+		goto out_free_bars;
 	}
 
 	host->dev[0] = &dev1->dev;
@@ -576,7 +586,7 @@ int ide_pci_init_two(struct pci_dev *dev1, struct pci_dev *dev2,
 		 * do_ide_setup_pci_device() on the first device!
 		 */
 		if (ret < 0)
-			goto out;
+			goto out_free_bars;
 
 		/* fixup IRQ */
 		if (ide_pci_is_in_compatibility_mode(pdev[i])) {
@@ -589,6 +599,13 @@ int ide_pci_init_two(struct pci_dev *dev1, struct pci_dev *dev2,
 	ret = ide_host_register(host, d, hws);
 	if (ret)
 		ide_host_free(host);
+	else
+		goto out;
+
+out_free_bars:
+	i = n_ports / 2;
+	while (i--)
+		pci_release_selected_regions(pdev[i], bars);
 out:
 	return ret;
 }

commit d681f1166919d6829083c069a83edcd59bfd5e34
Author: Quentin Lambert <lambert.quentin@gmail.com>
Date:   Mon Apr 13 10:26:53 2015 +0200

    ide: remove deprecated use of pci api
    
    Replace occurences of the pci api by appropriate call to the dma api.
    
    A simplified version of the semantic patch that finds this problem is as
    follows: (http://coccinelle.lip6.fr)
    
    @deprecated@
    idexpression id;
    position p;
    @@
    
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @bad1@
    idexpression id;
    position deprecated.p;
    @@
    ...when != &id->dev
       when != pci_get_drvdata ( id )
       when != pci_enable_device ( id )
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @depends on !bad1@
    idexpression id;
    expression direction;
    position deprecated.p;
    @@
    
    (
    - pci_dma_supported@p ( id,
    + dma_supported ( &id->dev,
    ...
    + , GFP_ATOMIC
      )
    |
    - pci_alloc_consistent@p ( id,
    + dma_alloc_coherent ( &id->dev,
    ...
    + , GFP_ATOMIC
      )
    )
    
    Signed-off-by: Quentin Lambert <lambert.quentin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 34a5e5223d50..112d2fe1bcdb 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -209,7 +209,7 @@ static int ide_pci_enable(struct pci_dev *dev, const struct ide_port_info *d)
 	 * a DMA mask field to the struct ide_port_info if we need it
 	 * (or let lower level driver set the DMA mask)
 	 */
-	ret = pci_set_dma_mask(dev, DMA_BIT_MASK(32));
+	ret = dma_set_mask(&dev->dev, DMA_BIT_MASK(32));
 	if (ret < 0) {
 		printk(KERN_ERR "%s %s: can't set DMA mask\n",
 			d->name, pci_name(dev));

commit 38789fda295689689d064c0157bc363b1837b5e6
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jul 17 15:33:58 2011 -0400

    ide/ata: Add export.h for EXPORT_SYMBOL/THIS_MODULE where needed
    
    They were getting this implicitly by an include of module.h
    from device.h -- but we are going to clean that up and break
    that include chain, so include export.h explicitly now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index ab3db61d2ba0..34a5e5223d50 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -8,6 +8,7 @@
 
 #include <linux/types.h>
 #include <linux/kernel.h>
+#include <linux/export.h>
 #include <linux/pci.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>

commit ad7c52d0988a8965989dc06d630c52a5bde849d5
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jun 10 14:37:21 2009 +0200

    ide: re-implement ide_pci_init_one() on top of ide_pci_init_two()
    
    There should be no functional changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 5314edffc303..ab3db61d2ba0 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -1,7 +1,7 @@
 /*
  *  Copyright (C) 1998-2000  Andre Hedrick <andre@linux-ide.org>
  *  Copyright (C) 1995-1998  Mark Lord
- *  Copyright (C)      2007  Bartlomiej Zolnierkiewicz
+ *  Copyright (C) 2007-2009  Bartlomiej Zolnierkiewicz
  *
  *  May be copied or modified under the terms of the GNU General Public License
  */
@@ -534,61 +534,15 @@ static int do_ide_setup_pci_device(struct pci_dev *dev,
 	return ret;
 }
 
-int ide_pci_init_one(struct pci_dev *dev, const struct ide_port_info *d,
-		     void *priv)
-{
-	struct ide_host *host;
-	struct ide_hw hw[2], *hws[] = { NULL, NULL };
-	int ret;
-
-	ret = ide_setup_pci_controller(dev, d, 1);
-	if (ret < 0)
-		goto out;
-
-	ide_pci_setup_ports(dev, d, &hw[0], &hws[0]);
-
-	host = ide_host_alloc(d, hws, 2);
-	if (host == NULL) {
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	host->dev[0] = &dev->dev;
-
-	host->host_priv = priv;
-
-	host->irq_flags = IRQF_SHARED;
-
-	pci_set_drvdata(dev, host);
-
-	ret = do_ide_setup_pci_device(dev, d, 1);
-	if (ret < 0)
-		goto out;
-
-	/* fixup IRQ */
-	if (ide_pci_is_in_compatibility_mode(dev)) {
-		hw[0].irq = pci_get_legacy_ide_irq(dev, 0);
-		hw[1].irq = pci_get_legacy_ide_irq(dev, 1);
-	} else
-		hw[1].irq = hw[0].irq = ret;
-
-	ret = ide_host_register(host, d, hws);
-	if (ret)
-		ide_host_free(host);
-out:
-	return ret;
-}
-EXPORT_SYMBOL_GPL(ide_pci_init_one);
-
 int ide_pci_init_two(struct pci_dev *dev1, struct pci_dev *dev2,
 		     const struct ide_port_info *d, void *priv)
 {
 	struct pci_dev *pdev[] = { dev1, dev2 };
 	struct ide_host *host;
-	int ret, i;
+	int ret, i, n_ports = dev2 ? 4 : 2;
 	struct ide_hw hw[4], *hws[] = { NULL, NULL, NULL, NULL };
 
-	for (i = 0; i < 2; i++) {
+	for (i = 0; i < n_ports / 2; i++) {
 		ret = ide_setup_pci_controller(pdev[i], d, !i);
 		if (ret < 0)
 			goto out;
@@ -596,23 +550,24 @@ int ide_pci_init_two(struct pci_dev *dev1, struct pci_dev *dev2,
 		ide_pci_setup_ports(pdev[i], d, &hw[i*2], &hws[i*2]);
 	}
 
-	host = ide_host_alloc(d, hws, 4);
+	host = ide_host_alloc(d, hws, n_ports);
 	if (host == NULL) {
 		ret = -ENOMEM;
 		goto out;
 	}
 
 	host->dev[0] = &dev1->dev;
-	host->dev[1] = &dev2->dev;
+	if (dev2)
+		host->dev[1] = &dev2->dev;
 
 	host->host_priv = priv;
-
 	host->irq_flags = IRQF_SHARED;
 
 	pci_set_drvdata(pdev[0], host);
-	pci_set_drvdata(pdev[1], host);
+	if (dev2)
+		pci_set_drvdata(pdev[1], host);
 
-	for (i = 0; i < 2; i++) {
+	for (i = 0; i < n_ports / 2; i++) {
 		ret = do_ide_setup_pci_device(pdev[i], d, !i);
 
 		/*
@@ -638,6 +593,13 @@ int ide_pci_init_two(struct pci_dev *dev1, struct pci_dev *dev2,
 }
 EXPORT_SYMBOL_GPL(ide_pci_init_two);
 
+int ide_pci_init_one(struct pci_dev *dev, const struct ide_port_info *d,
+		     void *priv)
+{
+	return ide_pci_init_two(dev, NULL, d, priv);
+}
+EXPORT_SYMBOL_GPL(ide_pci_init_one);
+
 void ide_pci_remove(struct pci_dev *dev)
 {
 	struct ide_host *host = pci_get_drvdata(dev);

commit 9f36d31437922354d104a2db407f397e79e4027e
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sun May 17 19:12:25 2009 +0200

    ide: remove hw_regs_t typedef
    
    Remove hw_regs_t typedef and rename struct hw_regs_s to struct ide_hw.
    
    There should be no functional changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index d78f4c994517..5314edffc303 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -301,11 +301,11 @@ static int ide_pci_check_iomem(struct pci_dev *dev, const struct ide_port_info *
 }
 
 /**
- *	ide_hw_configure	-	configure a hw_regs_t instance
+ *	ide_hw_configure	-	configure a struct ide_hw instance
  *	@dev: PCI device holding interface
  *	@d: IDE port info
  *	@port: port number
- *	@hw: hw_regs_t instance corresponding to this port
+ *	@hw: struct ide_hw instance corresponding to this port
  *
  *	Perform the initial set up for the hardware interface structure. This
  *	is done per interface port rather than per PCI device. There may be
@@ -315,7 +315,7 @@ static int ide_pci_check_iomem(struct pci_dev *dev, const struct ide_port_info *
  */
 
 static int ide_hw_configure(struct pci_dev *dev, const struct ide_port_info *d,
-			    unsigned int port, hw_regs_t *hw)
+			    unsigned int port, struct ide_hw *hw)
 {
 	unsigned long ctl = 0, base = 0;
 
@@ -445,8 +445,8 @@ static int ide_setup_pci_controller(struct pci_dev *dev,
  *	ide_pci_setup_ports	-	configure ports/devices on PCI IDE
  *	@dev: PCI device
  *	@d: IDE port info
- *	@hw: hw_regs_t instances corresponding to this PCI IDE device
- *	@hws: hw_regs_t pointers table to update
+ *	@hw: struct ide_hw instances corresponding to this PCI IDE device
+ *	@hws: struct ide_hw pointers table to update
  *
  *	Scan the interfaces attached to this device and do any
  *	necessary per port setup. Attach the devices and ask the
@@ -458,7 +458,7 @@ static int ide_setup_pci_controller(struct pci_dev *dev,
  */
 
 void ide_pci_setup_ports(struct pci_dev *dev, const struct ide_port_info *d,
-			 hw_regs_t *hw, hw_regs_t **hws)
+			 struct ide_hw *hw, struct ide_hw **hws)
 {
 	int channels = (d->host_flags & IDE_HFLAG_SINGLE) ? 1 : 2, port;
 	u8 tmp;
@@ -538,7 +538,7 @@ int ide_pci_init_one(struct pci_dev *dev, const struct ide_port_info *d,
 		     void *priv)
 {
 	struct ide_host *host;
-	hw_regs_t hw[2], *hws[] = { NULL, NULL };
+	struct ide_hw hw[2], *hws[] = { NULL, NULL };
 	int ret;
 
 	ret = ide_setup_pci_controller(dev, d, 1);
@@ -586,7 +586,7 @@ int ide_pci_init_two(struct pci_dev *dev1, struct pci_dev *dev2,
 	struct pci_dev *pdev[] = { dev1, dev2 };
 	struct ide_host *host;
 	int ret, i;
-	hw_regs_t hw[4], *hws[] = { NULL, NULL, NULL, NULL };
+	struct ide_hw hw[4], *hws[] = { NULL, NULL, NULL, NULL };
 
 	for (i = 0; i < 2; i++) {
 		ret = ide_setup_pci_controller(pdev[i], d, !i);

commit dca3983059a4481e4ae97bbf0ac4b4c21429e1a5
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sun May 17 19:12:24 2009 +0200

    ide: pass number of ports to ide_host_{alloc,add}() (v2)
    
    Pass number of ports to ide_host_{alloc,add}() and then update
    all users accordingly.
    
    v2:
    - drop no longer needed NULL initializers in buddha.c, cmd640.c and gayle.c
      (noticed by Sergei)
    
    There should be no functional changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 82519ddc9108..d78f4c994517 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -538,7 +538,7 @@ int ide_pci_init_one(struct pci_dev *dev, const struct ide_port_info *d,
 		     void *priv)
 {
 	struct ide_host *host;
-	hw_regs_t hw[4], *hws[] = { NULL, NULL, NULL, NULL };
+	hw_regs_t hw[2], *hws[] = { NULL, NULL };
 	int ret;
 
 	ret = ide_setup_pci_controller(dev, d, 1);
@@ -547,7 +547,7 @@ int ide_pci_init_one(struct pci_dev *dev, const struct ide_port_info *d,
 
 	ide_pci_setup_ports(dev, d, &hw[0], &hws[0]);
 
-	host = ide_host_alloc(d, hws);
+	host = ide_host_alloc(d, hws, 2);
 	if (host == NULL) {
 		ret = -ENOMEM;
 		goto out;
@@ -596,7 +596,7 @@ int ide_pci_init_two(struct pci_dev *dev1, struct pci_dev *dev2,
 		ide_pci_setup_ports(pdev[i], d, &hw[i*2], &hws[i*2]);
 	}
 
-	host = ide_host_alloc(d, hws);
+	host = ide_host_alloc(d, hws, 4);
 	if (host == NULL) {
 		ret = -ENOMEM;
 		goto out;

commit 29e52cf793ded6bece50de50e738596f94f07d9f
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sun May 17 19:12:22 2009 +0200

    ide: remove chipset field from hw_regs_t
    
    * Convert host drivers that still use hw_regs_t's chipset field to use
      the one in struct ide_port_info instead.
    
    * Move special handling of ide_pci chipset type from ide_hw_configure()
      to ide_init_port().
    
    * Remove chipset field from hw_regs_t.
    
    While at it:
    - remove stale comment in delkin_cb.c
    
    There should be no functional changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 7a3a12d6e638..82519ddc9108 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -344,7 +344,6 @@ static int ide_hw_configure(struct pci_dev *dev, const struct ide_port_info *d,
 
 	memset(hw, 0, sizeof(*hw));
 	hw->dev = &dev->dev;
-	hw->chipset = d->chipset ? d->chipset : ide_pci;
 	ide_std_init_ports(hw, base, ctl | 2);
 
 	return 0;

commit 284901a90a9e0b812ca3f5f852cbbfb60d10249d
Author: Yang Hongyang <yanghy@cn.fujitsu.com>
Date:   Mon Apr 6 19:01:15 2009 -0700

    dma-mapping: replace all DMA_32BIT_MASK macro with DMA_BIT_MASK(32)
    
    Replace all DMA_32BIT_MASK macro with DMA_BIT_MASK(32)
    
    Signed-off-by: Yang Hongyang<yanghy@cn.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index a19dbccd7617..7a3a12d6e638 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -208,7 +208,7 @@ static int ide_pci_enable(struct pci_dev *dev, const struct ide_port_info *d)
 	 * a DMA mask field to the struct ide_port_info if we need it
 	 * (or let lower level driver set the DMA mask)
 	 */
-	ret = pci_set_dma_mask(dev, DMA_32BIT_MASK);
+	ret = pci_set_dma_mask(dev, DMA_BIT_MASK(32));
 	if (ret < 0) {
 		printk(KERN_ERR "%s %s: can't set DMA mask\n",
 			d->name, pci_name(dev));

commit 255115fb35f80735c21a1cbe9809e9795a3af26e
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Mar 27 12:46:27 2009 +0100

    ide: allow host drivers to specify IRQ flags
    
    * Add ->irq_flags field to struct ide_port_info and struct ide_host.
    
    * Update host drivers and IDE PCI code to use ->irq_flags field.
    
    * Convert init_irq() and ide_intr() to use host->irq_flags.
    
    This fixes handling of shared IRQs for non-PCI hosts
    and removes ugly ifdeffery from core IDE code.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 24bc884826fc..a19dbccd7617 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -558,6 +558,8 @@ int ide_pci_init_one(struct pci_dev *dev, const struct ide_port_info *d,
 
 	host->host_priv = priv;
 
+	host->irq_flags = IRQF_SHARED;
+
 	pci_set_drvdata(dev, host);
 
 	ret = do_ide_setup_pci_device(dev, d, 1);
@@ -606,6 +608,8 @@ int ide_pci_init_two(struct pci_dev *dev1, struct pci_dev *dev2,
 
 	host->host_priv = priv;
 
+	host->irq_flags = IRQF_SHARED;
+
 	pci_set_drvdata(pdev[0], host);
 	pci_set_drvdata(pdev[1], host);
 

commit 86ccf37c6acd74cf7e4b7751ee045de19943c5a0
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Mar 24 23:22:53 2009 +0100

    ide: remove pciirq argument from ide_pci_setup_ports()
    
    * Set ->irq explicitly in cs5520.c.
    
    * Remove irq argument from ide_hw_configure().
    
    * Remove pciirq argument from ide_pci_setup_ports().
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 75e3beca86f0..24bc884826fc 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -305,7 +305,6 @@ static int ide_pci_check_iomem(struct pci_dev *dev, const struct ide_port_info *
  *	@dev: PCI device holding interface
  *	@d: IDE port info
  *	@port: port number
- *	@irq: PCI IRQ
  *	@hw: hw_regs_t instance corresponding to this port
  *
  *	Perform the initial set up for the hardware interface structure. This
@@ -316,7 +315,7 @@ static int ide_pci_check_iomem(struct pci_dev *dev, const struct ide_port_info *
  */
 
 static int ide_hw_configure(struct pci_dev *dev, const struct ide_port_info *d,
-			    unsigned int port, int irq, hw_regs_t *hw)
+			    unsigned int port, hw_regs_t *hw)
 {
 	unsigned long ctl = 0, base = 0;
 
@@ -344,7 +343,6 @@ static int ide_hw_configure(struct pci_dev *dev, const struct ide_port_info *d,
 	}
 
 	memset(hw, 0, sizeof(*hw));
-	hw->irq = irq;
 	hw->dev = &dev->dev;
 	hw->chipset = d->chipset ? d->chipset : ide_pci;
 	ide_std_init_ports(hw, base, ctl | 2);
@@ -448,7 +446,6 @@ static int ide_setup_pci_controller(struct pci_dev *dev,
  *	ide_pci_setup_ports	-	configure ports/devices on PCI IDE
  *	@dev: PCI device
  *	@d: IDE port info
- *	@pciirq: IRQ line
  *	@hw: hw_regs_t instances corresponding to this PCI IDE device
  *	@hws: hw_regs_t pointers table to update
  *
@@ -462,7 +459,7 @@ static int ide_setup_pci_controller(struct pci_dev *dev,
  */
 
 void ide_pci_setup_ports(struct pci_dev *dev, const struct ide_port_info *d,
-			 int pciirq, hw_regs_t *hw, hw_regs_t **hws)
+			 hw_regs_t *hw, hw_regs_t **hws)
 {
 	int channels = (d->host_flags & IDE_HFLAG_SINGLE) ? 1 : 2, port;
 	u8 tmp;
@@ -481,7 +478,7 @@ void ide_pci_setup_ports(struct pci_dev *dev, const struct ide_port_info *d,
 			continue;	/* port not enabled */
 		}
 
-		if (ide_hw_configure(dev, d, port, pciirq, hw + port))
+		if (ide_hw_configure(dev, d, port, hw + port))
 			continue;
 
 		*(hws + port) = hw + port;
@@ -549,7 +546,7 @@ int ide_pci_init_one(struct pci_dev *dev, const struct ide_port_info *d,
 	if (ret < 0)
 		goto out;
 
-	ide_pci_setup_ports(dev, d, 0, &hw[0], &hws[0]);
+	ide_pci_setup_ports(dev, d, &hw[0], &hws[0]);
 
 	host = ide_host_alloc(d, hws);
 	if (host == NULL) {
@@ -595,7 +592,7 @@ int ide_pci_init_two(struct pci_dev *dev1, struct pci_dev *dev2,
 		if (ret < 0)
 			goto out;
 
-		ide_pci_setup_ports(pdev[i], d, 0, &hw[i*2], &hws[i*2]);
+		ide_pci_setup_ports(pdev[i], d, &hw[i*2], &hws[i*2]);
 	}
 
 	host = ide_host_alloc(d, hws);

commit 2ed0ef543ae3f3ea4f8bd0433fb1fed22625a309
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Mar 24 23:22:53 2009 +0100

    ide: fix ->init_chipset method to return 'int' value
    
    * Return 0 instead of dev->irq in ->init_chipset implementations.
    
    * Fix ->init_chipset method to return 'int' value instead of
      'unsigned int' one.
    
    This fixes ->init_chipset handling for host drivers (cs5530, hpt366
    and pdc202xx_new) for which it is possible for this method to fail.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 79e3244691ec..75e3beca86f0 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -524,7 +524,7 @@ static int do_ide_setup_pci_device(struct pci_dev *dev,
 		if (noisy)
 			printk(KERN_INFO "%s %s: not 100%% native mode: will "
 				"probe irqs later\n", d->name, pci_name(dev));
-		pciirq = ret;
+		pciirq = 0;
 	} else if (!pciirq && noisy) {
 		printk(KERN_WARNING "%s %s: bad irq (%d): will probe later\n",
 			d->name, pci_name(dev), pciirq);

commit f65dedfd7b75f19bde42bafbe84fddce18c42499
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Mar 24 23:22:51 2009 +0100

    ide: use ide_pci_is_in_compatibility_mode() in ide_pci_init_{one,two}()
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index fa645fc41b86..79e3244691ec 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -568,13 +568,11 @@ int ide_pci_init_one(struct pci_dev *dev, const struct ide_port_info *d,
 		goto out;
 
 	/* fixup IRQ */
-	hw[1].irq = hw[0].irq = ret;
-
-	if ((ret == 0 && (d->host_flags & IDE_HFLAG_LEGACY_IRQS)) ||
-	    (d->host_flags & IDE_HFLAG_FORCE_LEGACY_IRQS)) {
+	if (ide_pci_is_in_compatibility_mode(dev)) {
 		hw[0].irq = pci_get_legacy_ide_irq(dev, 0);
 		hw[1].irq = pci_get_legacy_ide_irq(dev, 1);
-	}
+	} else
+		hw[1].irq = hw[0].irq = ret;
 
 	ret = ide_host_register(host, d, hws);
 	if (ret)
@@ -625,13 +623,11 @@ int ide_pci_init_two(struct pci_dev *dev1, struct pci_dev *dev2,
 			goto out;
 
 		/* fixup IRQ */
-		hw[i*2 + 1].irq = hw[i*2].irq = ret;
-
-		if ((ret == 0 && (d->host_flags & IDE_HFLAG_LEGACY_IRQS)) ||
-		    (d->host_flags & IDE_HFLAG_FORCE_LEGACY_IRQS)) {
+		if (ide_pci_is_in_compatibility_mode(pdev[i])) {
 			hw[i*2].irq = pci_get_legacy_ide_irq(pdev[i], 0);
 			hw[i*2 + 1].irq = pci_get_legacy_ide_irq(pdev[i], 1);
-		}
+		} else
+			hw[i*2 + 1].irq = hw[i*2].irq = ret;
 	}
 
 	ret = ide_host_register(host, d, hws);

commit 5bae8bf4508004d46487b3a18769d0ccff01c532
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Mar 24 23:22:49 2009 +0100

    ide: use pci_get_legacy_ide_irq() in ide_pci_init_{one,two}()
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 9482288e8610..fa645fc41b86 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -572,8 +572,8 @@ int ide_pci_init_one(struct pci_dev *dev, const struct ide_port_info *d,
 
 	if ((ret == 0 && (d->host_flags & IDE_HFLAG_LEGACY_IRQS)) ||
 	    (d->host_flags & IDE_HFLAG_FORCE_LEGACY_IRQS)) {
-		hw[0].irq = 14;
-		hw[1].irq = 15;
+		hw[0].irq = pci_get_legacy_ide_irq(dev, 0);
+		hw[1].irq = pci_get_legacy_ide_irq(dev, 1);
 	}
 
 	ret = ide_host_register(host, d, hws);
@@ -629,8 +629,8 @@ int ide_pci_init_two(struct pci_dev *dev1, struct pci_dev *dev2,
 
 		if ((ret == 0 && (d->host_flags & IDE_HFLAG_LEGACY_IRQS)) ||
 		    (d->host_flags & IDE_HFLAG_FORCE_LEGACY_IRQS)) {
-			hw[i*2].irq = 14;
-			hw[i*2 + 1].irq = 15;
+			hw[i*2].irq = pci_get_legacy_ide_irq(pdev[i], 0);
+			hw[i*2 + 1].irq = pci_get_legacy_ide_irq(pdev[i], 1);
 		}
 	}
 

commit 80d15a607ae95dd0514ab1ab5ea1058a3a585f2b
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Mar 24 23:22:49 2009 +0100

    ide: handle IDE_HFLAG[_FORCE]_LEGACY_IRQS in ide_pci_init_{one,two}()
    
    Move handling of IDE_HFLAG[_FORCE]_LEGACY_IRQS from ide_init_port()
    to ide_pci_init_{one,two}().
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index e85d1ed29c2a..9482288e8610 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -570,6 +570,12 @@ int ide_pci_init_one(struct pci_dev *dev, const struct ide_port_info *d,
 	/* fixup IRQ */
 	hw[1].irq = hw[0].irq = ret;
 
+	if ((ret == 0 && (d->host_flags & IDE_HFLAG_LEGACY_IRQS)) ||
+	    (d->host_flags & IDE_HFLAG_FORCE_LEGACY_IRQS)) {
+		hw[0].irq = 14;
+		hw[1].irq = 15;
+	}
+
 	ret = ide_host_register(host, d, hws);
 	if (ret)
 		ide_host_free(host);
@@ -620,6 +626,12 @@ int ide_pci_init_two(struct pci_dev *dev1, struct pci_dev *dev2,
 
 		/* fixup IRQ */
 		hw[i*2 + 1].irq = hw[i*2].irq = ret;
+
+		if ((ret == 0 && (d->host_flags & IDE_HFLAG_LEGACY_IRQS)) ||
+		    (d->host_flags & IDE_HFLAG_FORCE_LEGACY_IRQS)) {
+			hw[i*2].irq = 14;
+			hw[i*2 + 1].irq = 15;
+		}
 	}
 
 	ret = ide_host_register(host, d, hws);

commit 592b5315219881c6c0af4785f96456ad2043193a
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Tue Jan 6 17:21:02 2009 +0100

    ide: move read_sff_dma_status() method to 'struct ide_dma_ops'
    
    Move apparently misplaced read_sff_dma_status() method from 'struct ide_tp_ops'
    to 'struct ide_dma_ops', renaming it to dma_sff_read_status() and making only
    required for SFF-8038i compatible IDE controller drivers (greatly cutting down
    the number of initializers) as its only user (outside ide-dma-sff.c and such
    drivers) appears to be ide_pci_check_simplex() which is only called for such
    controllers...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index bc37dff8c675..e85d1ed29c2a 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -130,7 +130,7 @@ int ide_pci_check_simplex(ide_hwif_t *hwif, const struct ide_port_info *d)
 	 * we tune the drive then try to grab DMA ownership if we want to be
 	 * the DMA end.  This has to be become dynamic to handle hot-plug.
 	 */
-	dma_stat = hwif->tp_ops->read_sff_dma_status(hwif);
+	dma_stat = hwif->dma_ops->dma_sff_read_status(hwif);
 	if ((dma_stat & 0x80) && hwif->mate && hwif->mate->dma_base) {
 		printk(KERN_INFO "%s %s: simplex device: DMA disabled\n",
 			d->name, pci_name(dev));
@@ -377,6 +377,9 @@ int ide_hwif_setup_dma(ide_hwif_t *hwif, const struct ide_port_info *d)
 
 		hwif->dma_base = base;
 
+		if (hwif->dma_ops == NULL)
+			hwif->dma_ops = &sff_dma_ops;
+
 		if (ide_pci_check_simplex(hwif, d) < 0)
 			return -1;
 
@@ -393,8 +396,6 @@ int ide_hwif_setup_dma(ide_hwif_t *hwif, const struct ide_port_info *d)
 
 		if (ide_allocate_dma_engine(hwif))
 			return -1;
-
-		hwif->dma_ops = &sff_dma_ops;
 	}
 
 	return 0;

commit 8c6de94cfa07cf9f4651edd7e541ed4841c9f201
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jan 6 17:20:58 2009 +0100

    ide: use ide_pci_is_in_compatibility_mode() helper in setup-pci.c
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 09f820af379d..bc37dff8c675 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -519,8 +519,7 @@ static int do_ide_setup_pci_device(struct pci_dev *dev,
 	if (ret < 0)
 		goto out;
 
-	/* Is it an "IDE storage" device in non-PCI mode? */
-	if ((dev->class >> 8) == PCI_CLASS_STORAGE_IDE && (dev->class & 5) != 5) {
+	if (ide_pci_is_in_compatibility_mode(dev)) {
 		if (noisy)
 			printk(KERN_INFO "%s %s: not 100%% native mode: will "
 				"probe irqs later\n", d->name, pci_name(dev));

commit c0ae50234771684ae0cbac5dfb70e1a09c22aa89
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jan 6 17:20:52 2009 +0100

    ide: remove ide_pci_enablebit_t typedef
    
    Remove needless parens while at it.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 9f1f9163a136..09f820af379d 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -471,7 +471,7 @@ void ide_pci_setup_ports(struct pci_dev *dev, const struct ide_port_info *d,
 	 */
 
 	for (port = 0; port < channels; ++port) {
-		const ide_pci_enablebit_t *e = &(d->enablebits[port]);
+		const struct ide_pci_enablebit *e = &d->enablebits[port];
 
 		if (e->reg && (pci_read_config_byte(dev, e->reg, &tmp) ||
 		    (tmp & e->mask) != e->val)) {

commit feb22b7f8e62b1b987a3a1dbad95af767a1df832
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:32 2008 +0200

    ide: add proper PCI PM support (v2)
    
    * Keep pointer to ->init_chipset method also in
      struct ide_host and set it in ide_host_alloc_all().
    
    * Add ide_pci_suspend() and ide_pci_resume() helpers
      (default ->suspend and ->resume implementations).
    
    * ->init_chipset can no longer be marked __devinit.
    
    * Add proper PCI PM support to IDE PCI host drivers
      (rz1000.c and tc86c001.c are skipped for now since
      they need to be converted from using ->init_hwif
      to use ->init_chipset instead).
    
    v2:
    * Cleanup CONFIG_PM #ifdef-s per akpm's suggestion.
    
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index a8e9e8a69a52..9f1f9163a136 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -659,3 +659,36 @@ void ide_pci_remove(struct pci_dev *dev)
 	pci_disable_device(dev);
 }
 EXPORT_SYMBOL_GPL(ide_pci_remove);
+
+#ifdef CONFIG_PM
+int ide_pci_suspend(struct pci_dev *dev, pm_message_t state)
+{
+	pci_save_state(dev);
+	pci_disable_device(dev);
+	pci_set_power_state(dev, pci_choose_state(dev, state));
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ide_pci_suspend);
+
+int ide_pci_resume(struct pci_dev *dev)
+{
+	struct ide_host *host = pci_get_drvdata(dev);
+	int rc;
+
+	pci_set_power_state(dev, PCI_D0);
+
+	rc = pci_enable_device(dev);
+	if (rc)
+		return rc;
+
+	pci_restore_state(dev);
+	pci_set_master(dev);
+
+	if (host->init_chipset)
+		host->init_chipset(dev);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ide_pci_resume);
+#endif

commit a326b02b0c576001353dbc489154959b0889c6bf
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu Jul 24 22:53:33 2008 +0200

    ide: drop 'name' parameter from ->init_chipset method
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index d9655aeb013b..a8e9e8a69a52 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -515,7 +515,7 @@ static int do_ide_setup_pci_device(struct pci_dev *dev,
 	 * space, place chipset into init-mode, and/or preserve
 	 * an interrupt if the card is not native ide support.
 	 */
-	ret = d->init_chipset ? d->init_chipset(dev, d->name) : 0;
+	ret = d->init_chipset ? d->init_chipset(dev) : 0;
 	if (ret < 0)
 		goto out;
 

commit 28cfd8af52a9ed4e5bd1751ea6bc0b8c870f68ec
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu Jul 24 22:53:31 2008 +0200

    ide: include PCI device name in messages from IDE PCI host drivers
    
    While at it:
    
    * Apply small fixes to messages (s/dma/DMA/, remove trailing '.', etc).
    
    * Fix printk() call in ide_setup_pci_baseregs() to use KERN_INFO.
    
    * Move printk() call from ide_pci_clear_simplex() to the caller.
    
    * Cleanup do_ide_setup_pci_device() a bit.
    
    * amd74xx.c: remove superfluous PCI device revision information.
    
    * hpt366.c: fix two printk() calls in ->init_chipset to use KERN_INFO.
    
    * pdc202xx_new.c: fix printk() call in ->init_chipset to use KERN_INFO.
    
    * pdc202xx_old.c: fix driver message in pdc202xx_init_one().
    
    * via82cxxx.c: fix driver warning message in via_init_one().
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 20f0ee004695..d9655aeb013b 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -39,17 +39,18 @@ static int ide_setup_pci_baseregs(struct pci_dev *dev, const char *name)
 	if (pci_read_config_byte(dev, PCI_CLASS_PROG, &progif) ||
 			 (progif & 5) != 5) {
 		if ((progif & 0xa) != 0xa) {
-			printk(KERN_INFO "%s: device not capable of full "
-				"native PCI mode\n", name);
+			printk(KERN_INFO "%s %s: device not capable of full "
+				"native PCI mode\n", name, pci_name(dev));
 			return -EOPNOTSUPP;
 		}
-		printk("%s: placing both ports into native PCI mode\n", name);
+		printk(KERN_INFO "%s %s: placing both ports into native PCI "
+			"mode\n", name, pci_name(dev));
 		(void) pci_write_config_byte(dev, PCI_CLASS_PROG, progif|5);
 		if (pci_read_config_byte(dev, PCI_CLASS_PROG, &progif) ||
 		    (progif & 5) != 5) {
-			printk(KERN_ERR "%s: rewrite of PROGIF failed, wanted "
-				"0x%04x, got 0x%04x\n",
-				name, progif|5, progif);
+			printk(KERN_ERR "%s %s: rewrite of PROGIF failed, "
+				"wanted 0x%04x, got 0x%04x\n",
+				name, pci_name(dev), progif | 5, progif);
 			return -EOPNOTSUPP;
 		}
 	}
@@ -57,14 +58,14 @@ static int ide_setup_pci_baseregs(struct pci_dev *dev, const char *name)
 }
 
 #ifdef CONFIG_BLK_DEV_IDEDMA_PCI
-static void ide_pci_clear_simplex(unsigned long dma_base, const char *name)
+static int ide_pci_clear_simplex(unsigned long dma_base, const char *name)
 {
 	u8 dma_stat = inb(dma_base + 2);
 
 	outb(dma_stat & 0x60, dma_base + 2);
 	dma_stat = inb(dma_base + 2);
-	if (dma_stat & 0x80)
-		printk(KERN_INFO "%s: simplex device: DMA forced\n", name);
+
+	return (dma_stat & 0x80) ? 1 : 0;
 }
 
 /**
@@ -91,7 +92,8 @@ unsigned long ide_pci_dma_base(ide_hwif_t *hwif, const struct ide_port_info *d)
 		dma_base = pci_resource_start(dev, baridx);
 
 		if (dma_base == 0) {
-			printk(KERN_ERR "%s: DMA base is invalid\n", d->name);
+			printk(KERN_ERR "%s %s: DMA base is invalid\n",
+				d->name, pci_name(dev));
 			return 0;
 		}
 	}
@@ -105,13 +107,16 @@ EXPORT_SYMBOL_GPL(ide_pci_dma_base);
 
 int ide_pci_check_simplex(ide_hwif_t *hwif, const struct ide_port_info *d)
 {
+	struct pci_dev *dev = to_pci_dev(hwif->dev);
 	u8 dma_stat;
 
 	if (d->host_flags & (IDE_HFLAG_MMIO | IDE_HFLAG_CS5520))
 		goto out;
 
 	if (d->host_flags & IDE_HFLAG_CLEAR_SIMPLEX) {
-		ide_pci_clear_simplex(hwif->dma_base, d->name);
+		if (ide_pci_clear_simplex(hwif->dma_base, d->name))
+			printk(KERN_INFO "%s %s: simplex device: DMA forced\n",
+				d->name, pci_name(dev));
 		goto out;
 	}
 
@@ -127,7 +132,8 @@ int ide_pci_check_simplex(ide_hwif_t *hwif, const struct ide_port_info *d)
 	 */
 	dma_stat = hwif->tp_ops->read_sff_dma_status(hwif);
 	if ((dma_stat & 0x80) && hwif->mate && hwif->mate->dma_base) {
-		printk(KERN_INFO "%s: simplex device: DMA disabled\n", d->name);
+		printk(KERN_INFO "%s %s: simplex device: DMA disabled\n",
+			d->name, pci_name(dev));
 		return -1;
 	}
 out:
@@ -149,8 +155,8 @@ int ide_pci_set_master(struct pci_dev *dev, const char *name)
 
 		if (pci_read_config_word(dev, PCI_COMMAND, &pcicmd) ||
 		    (pcicmd & PCI_COMMAND_MASTER) == 0) {
-			printk(KERN_ERR "%s: error updating PCICMD on %s\n",
-					name, pci_name(dev));
+			printk(KERN_ERR "%s %s: error updating PCICMD\n",
+				name, pci_name(dev));
 			return -EIO;
 		}
 	}
@@ -162,9 +168,9 @@ EXPORT_SYMBOL_GPL(ide_pci_set_master);
 
 void ide_setup_pci_noise(struct pci_dev *dev, const struct ide_port_info *d)
 {
-	printk(KERN_INFO "%s: IDE controller (0x%04x:0x%04x rev 0x%02x) at "
-			 " PCI slot %s\n", d->name, dev->vendor, dev->device,
-			 dev->revision, pci_name(dev));
+	printk(KERN_INFO "%s %s: IDE controller (0x%04x:0x%04x rev 0x%02x)\n",
+		d->name, pci_name(dev),
+		dev->vendor, dev->device, dev->revision);
 }
 EXPORT_SYMBOL_GPL(ide_setup_pci_noise);
 
@@ -189,11 +195,12 @@ static int ide_pci_enable(struct pci_dev *dev, const struct ide_port_info *d)
 	if (pci_enable_device(dev)) {
 		ret = pci_enable_device_io(dev);
 		if (ret < 0) {
-			printk(KERN_WARNING "%s: (ide_setup_pci_device:) "
-				"Could not enable device.\n", d->name);
+			printk(KERN_WARNING "%s %s: couldn't enable device\n",
+				d->name, pci_name(dev));
 			goto out;
 		}
-		printk(KERN_WARNING "%s: BIOS configuration fixed.\n", d->name);
+		printk(KERN_WARNING "%s %s: BIOS configuration fixed\n",
+			d->name, pci_name(dev));
 	}
 
 	/*
@@ -203,7 +210,8 @@ static int ide_pci_enable(struct pci_dev *dev, const struct ide_port_info *d)
 	 */
 	ret = pci_set_dma_mask(dev, DMA_32BIT_MASK);
 	if (ret < 0) {
-		printk(KERN_ERR "%s: can't set dma mask\n", d->name);
+		printk(KERN_ERR "%s %s: can't set DMA mask\n",
+			d->name, pci_name(dev));
 		goto out;
 	}
 
@@ -221,7 +229,8 @@ static int ide_pci_enable(struct pci_dev *dev, const struct ide_port_info *d)
 
 	ret = pci_request_selected_regions(dev, bars, d->name);
 	if (ret < 0)
-		printk(KERN_ERR "%s: can't reserve resources\n", d->name);
+		printk(KERN_ERR "%s %s: can't reserve resources\n",
+			d->name, pci_name(dev));
 out:
 	return ret;
 }
@@ -247,15 +256,18 @@ static int ide_pci_configure(struct pci_dev *dev, const struct ide_port_info *d)
 	 */
 	if (ide_setup_pci_baseregs(dev, d->name) ||
 	    pci_write_config_word(dev, PCI_COMMAND, pcicmd | PCI_COMMAND_IO)) {
-		printk(KERN_INFO "%s: device disabled (BIOS)\n", d->name);
+		printk(KERN_INFO "%s %s: device disabled (BIOS)\n",
+			d->name, pci_name(dev));
 		return -ENODEV;
 	}
 	if (pci_read_config_word(dev, PCI_COMMAND, &pcicmd)) {
-		printk(KERN_ERR "%s: error accessing PCI regs\n", d->name);
+		printk(KERN_ERR "%s %s: error accessing PCI regs\n",
+			d->name, pci_name(dev));
 		return -EIO;
 	}
 	if (!(pcicmd & PCI_COMMAND_IO)) {
-		printk(KERN_ERR "%s: unable to enable IDE controller\n", d->name);
+		printk(KERN_ERR "%s %s: unable to enable IDE controller\n",
+			d->name, pci_name(dev));
 		return -ENXIO;
 	}
 	return 0;
@@ -311,8 +323,9 @@ static int ide_hw_configure(struct pci_dev *dev, const struct ide_port_info *d,
 	if ((d->host_flags & IDE_HFLAG_ISA_PORTS) == 0) {
 		if (ide_pci_check_iomem(dev, d, 2 * port) ||
 		    ide_pci_check_iomem(dev, d, 2 * port + 1)) {
-			printk(KERN_ERR "%s: I/O baseregs (BIOS) are reported "
-					"as MEM for port %d!\n", d->name, port);
+			printk(KERN_ERR "%s %s: I/O baseregs (BIOS) are "
+				"reported as MEM for port %d!\n",
+				d->name, pci_name(dev), port);
 			return -EINVAL;
 		}
 
@@ -325,8 +338,8 @@ static int ide_hw_configure(struct pci_dev *dev, const struct ide_port_info *d,
 	}
 
 	if (!base || !ctl) {
-		printk(KERN_ERR "%s: bad PCI BARs for port %d, skipping\n",
-				d->name, port);
+		printk(KERN_ERR "%s %s: bad PCI BARs for port %d, skipping\n",
+			d->name, pci_name(dev), port);
 		return -EINVAL;
 	}
 
@@ -414,14 +427,16 @@ static int ide_setup_pci_controller(struct pci_dev *dev,
 
 	ret = pci_read_config_word(dev, PCI_COMMAND, &pcicmd);
 	if (ret < 0) {
-		printk(KERN_ERR "%s: error accessing PCI regs\n", d->name);
+		printk(KERN_ERR "%s %s: error accessing PCI regs\n",
+			d->name, pci_name(dev));
 		goto out;
 	}
 	if (!(pcicmd & PCI_COMMAND_IO)) {	/* is device disabled? */
 		ret = ide_pci_configure(dev, d);
 		if (ret < 0)
 			goto out;
-		printk(KERN_INFO "%s: device enabled (Linux)\n", d->name);
+		printk(KERN_INFO "%s %s: device enabled (Linux)\n",
+			d->name, pci_name(dev));
 	}
 
 out:
@@ -460,7 +475,8 @@ void ide_pci_setup_ports(struct pci_dev *dev, const struct ide_port_info *d,
 
 		if (e->reg && (pci_read_config_byte(dev, e->reg, &tmp) ||
 		    (tmp & e->mask) != e->val)) {
-			printk(KERN_INFO "%s: IDE port disabled\n", d->name);
+			printk(KERN_INFO "%s %s: IDE port disabled\n",
+				d->name, pci_name(dev));
 			continue;	/* port not enabled */
 		}
 
@@ -506,18 +522,15 @@ static int do_ide_setup_pci_device(struct pci_dev *dev,
 	/* Is it an "IDE storage" device in non-PCI mode? */
 	if ((dev->class >> 8) == PCI_CLASS_STORAGE_IDE && (dev->class & 5) != 5) {
 		if (noisy)
-			printk(KERN_INFO "%s: not 100%% native mode: "
-				"will probe irqs later\n", d->name);
+			printk(KERN_INFO "%s %s: not 100%% native mode: will "
+				"probe irqs later\n", d->name, pci_name(dev));
 		pciirq = ret;
-	} else if (!pciirq) {
-		if (noisy)
-			printk(KERN_WARNING "%s: bad irq (%d): will probe later\n",
-				d->name, pciirq);
-		pciirq = 0;
-	} else {
-		if (noisy)
-			printk(KERN_INFO "%s: 100%% native mode on irq %d\n",
-				d->name, pciirq);
+	} else if (!pciirq && noisy) {
+		printk(KERN_WARNING "%s %s: bad irq (%d): will probe later\n",
+			d->name, pci_name(dev), pciirq);
+	} else if (noisy) {
+		printk(KERN_INFO "%s %s: 100%% native mode on irq %d\n",
+			d->name, pci_name(dev), pciirq);
 	}
 
 	ret = pciirq;

commit ef0b04276d8f719d754c092434fbd62c2aeb5307
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu Jul 24 22:53:19 2008 +0200

    ide: add ide_pci_remove() helper
    
    * Add 'unsigned long host_flags' field to struct ide_host.
    
    * Set ->host_flags in ide_host_alloc_all().
    
    * Always set PCI dev's ->driver_data in ide_pci_init_{one,two}().
    
    * Add ide_pci_remove() helper (the default implementation for
      struct pci_driver's ->remove method).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index ca17bf8896df..20f0ee004695 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -548,8 +548,7 @@ int ide_pci_init_one(struct pci_dev *dev, const struct ide_port_info *d,
 
 	host->host_priv = priv;
 
-	if (priv)
-		pci_set_drvdata(dev, host);
+	pci_set_drvdata(dev, host);
 
 	ret = do_ide_setup_pci_device(dev, d, 1);
 	if (ret < 0)
@@ -593,10 +592,8 @@ int ide_pci_init_two(struct pci_dev *dev1, struct pci_dev *dev2,
 
 	host->host_priv = priv;
 
-	if (priv) {
-		pci_set_drvdata(pdev[0], host);
-		pci_set_drvdata(pdev[1], host);
-	}
+	pci_set_drvdata(pdev[0], host);
+	pci_set_drvdata(pdev[1], host);
 
 	for (i = 0; i < 2; i++) {
 		ret = do_ide_setup_pci_device(pdev[i], d, !i);
@@ -619,3 +616,33 @@ int ide_pci_init_two(struct pci_dev *dev1, struct pci_dev *dev2,
 	return ret;
 }
 EXPORT_SYMBOL_GPL(ide_pci_init_two);
+
+void ide_pci_remove(struct pci_dev *dev)
+{
+	struct ide_host *host = pci_get_drvdata(dev);
+	struct pci_dev *dev2 = host->dev[1] ? to_pci_dev(host->dev[1]) : NULL;
+	int bars;
+
+	if (host->host_flags & IDE_HFLAG_SINGLE)
+		bars = (1 << 2) - 1;
+	else
+		bars = (1 << 4) - 1;
+
+	if ((host->host_flags & IDE_HFLAG_NO_DMA) == 0) {
+		if (host->host_flags & IDE_HFLAG_CS5520)
+			bars |= (1 << 2);
+		else
+			bars |= (1 << 4);
+	}
+
+	ide_host_remove(host);
+
+	if (dev2)
+		pci_release_selected_regions(dev2, bars);
+	pci_release_selected_regions(dev, bars);
+
+	if (dev2)
+		pci_disable_device(dev2);
+	pci_disable_device(dev);
+}
+EXPORT_SYMBOL_GPL(ide_pci_remove);

commit 6cdf6eb357c2681596b7b1672b92396ba82333d4
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu Jul 24 22:53:14 2008 +0200

    ide: add ->dev and ->host_priv fields to struct ide_host
    
    * Add 'struct device *dev[2]' and 'void *host_priv' fields
      to struct ide_host.
    
    * Set ->dev[] in ide_host_alloc_all()/ide_setup_pci_device[s]().
    
    * Pass 'void *priv' argument to ide_setup_pci_device[s]()
      and use it to set ->host_priv.
    
    * Set PCI dev's ->driver_data to point to the struct ide_host
      instance if PCI host driver wants to use ->host_priv.
    
    * Rename ide_setup_pci_device[s]() to ide_pci_init_{one,two}().
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index b85de71fdc88..ca17bf8896df 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -525,8 +525,10 @@ static int do_ide_setup_pci_device(struct pci_dev *dev,
 	return ret;
 }
 
-int ide_setup_pci_device(struct pci_dev *dev, const struct ide_port_info *d)
+int ide_pci_init_one(struct pci_dev *dev, const struct ide_port_info *d,
+		     void *priv)
 {
+	struct ide_host *host;
 	hw_regs_t hw[4], *hws[] = { NULL, NULL, NULL, NULL };
 	int ret;
 
@@ -536,6 +538,19 @@ int ide_setup_pci_device(struct pci_dev *dev, const struct ide_port_info *d)
 
 	ide_pci_setup_ports(dev, d, 0, &hw[0], &hws[0]);
 
+	host = ide_host_alloc(d, hws);
+	if (host == NULL) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	host->dev[0] = &dev->dev;
+
+	host->host_priv = priv;
+
+	if (priv)
+		pci_set_drvdata(dev, host);
+
 	ret = do_ide_setup_pci_device(dev, d, 1);
 	if (ret < 0)
 		goto out;
@@ -543,16 +558,19 @@ int ide_setup_pci_device(struct pci_dev *dev, const struct ide_port_info *d)
 	/* fixup IRQ */
 	hw[1].irq = hw[0].irq = ret;
 
-	ret = ide_host_add(d, hws, NULL);
+	ret = ide_host_register(host, d, hws);
+	if (ret)
+		ide_host_free(host);
 out:
 	return ret;
 }
-EXPORT_SYMBOL_GPL(ide_setup_pci_device);
+EXPORT_SYMBOL_GPL(ide_pci_init_one);
 
-int ide_setup_pci_devices(struct pci_dev *dev1, struct pci_dev *dev2,
-			  const struct ide_port_info *d)
+int ide_pci_init_two(struct pci_dev *dev1, struct pci_dev *dev2,
+		     const struct ide_port_info *d, void *priv)
 {
 	struct pci_dev *pdev[] = { dev1, dev2 };
+	struct ide_host *host;
 	int ret, i;
 	hw_regs_t hw[4], *hws[] = { NULL, NULL, NULL, NULL };
 
@@ -562,7 +580,25 @@ int ide_setup_pci_devices(struct pci_dev *dev1, struct pci_dev *dev2,
 			goto out;
 
 		ide_pci_setup_ports(pdev[i], d, 0, &hw[i*2], &hws[i*2]);
+	}
 
+	host = ide_host_alloc(d, hws);
+	if (host == NULL) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	host->dev[0] = &dev1->dev;
+	host->dev[1] = &dev2->dev;
+
+	host->host_priv = priv;
+
+	if (priv) {
+		pci_set_drvdata(pdev[0], host);
+		pci_set_drvdata(pdev[1], host);
+	}
+
+	for (i = 0; i < 2; i++) {
 		ret = do_ide_setup_pci_device(pdev[i], d, !i);
 
 		/*
@@ -576,8 +612,10 @@ int ide_setup_pci_devices(struct pci_dev *dev1, struct pci_dev *dev2,
 		hw[i*2 + 1].irq = hw[i*2].irq = ret;
 	}
 
-	ret = ide_host_add(d, hws, NULL);
+	ret = ide_host_register(host, d, hws);
+	if (ret)
+		ide_host_free(host);
 out:
 	return ret;
 }
-EXPORT_SYMBOL_GPL(ide_setup_pci_devices);
+EXPORT_SYMBOL_GPL(ide_pci_init_two);

commit 8c2eece50a368c7986bae0b3e52739558dd71b51
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu Jul 24 22:53:12 2008 +0200

    ide: call ide_pci_setup_ports() before do_ide_setup_pci_device()
    
    * Call ide_pci_setup_ports() before do_ide_setup_pci_device()
      in ide_setup_pci_device[s]().
    
    While at it:
    
    * Remove stale FIXMEs.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 98c663d62b9f..b85de71fdc88 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -534,14 +534,16 @@ int ide_setup_pci_device(struct pci_dev *dev, const struct ide_port_info *d)
 	if (ret < 0)
 		goto out;
 
+	ide_pci_setup_ports(dev, d, 0, &hw[0], &hws[0]);
+
 	ret = do_ide_setup_pci_device(dev, d, 1);
+	if (ret < 0)
+		goto out;
 
-	if (ret >= 0) {
-		/* FIXME: silent failure can happen */
-		ide_pci_setup_ports(dev, d, ret, &hw[0], &hws[0]);
+	/* fixup IRQ */
+	hw[1].irq = hw[0].irq = ret;
 
-		ret = ide_host_add(d, hws, NULL);
-	}
+	ret = ide_host_add(d, hws, NULL);
 out:
 	return ret;
 }
@@ -559,6 +561,8 @@ int ide_setup_pci_devices(struct pci_dev *dev1, struct pci_dev *dev2,
 		if (ret < 0)
 			goto out;
 
+		ide_pci_setup_ports(pdev[i], d, 0, &hw[i*2], &hws[i*2]);
+
 		ret = do_ide_setup_pci_device(pdev[i], d, !i);
 
 		/*
@@ -568,8 +572,8 @@ int ide_setup_pci_devices(struct pci_dev *dev1, struct pci_dev *dev2,
 		if (ret < 0)
 			goto out;
 
-		/* FIXME: silent failure can happen */
-		ide_pci_setup_ports(pdev[i], d, ret, &hw[i*2], &hws[i*2]);
+		/* fixup IRQ */
+		hw[i*2 + 1].irq = hw[i*2].irq = ret;
 	}
 
 	ret = ide_host_add(d, hws, NULL);

commit a742d6cf0b37b1a96a1549b1fda0d6b19e0185c2
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu Jul 24 22:53:12 2008 +0200

    ide: move ide_setup_pci_controller() call to ide_setup_pci_device[s]()
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 58f4a95f6f5c..98c663d62b9f 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -488,10 +488,6 @@ static int do_ide_setup_pci_device(struct pci_dev *dev,
 {
 	int pciirq, ret;
 
-	ret = ide_setup_pci_controller(dev, d, noisy);
-	if (ret < 0)
-		goto out;
-
 	/*
 	 * Can we trust the reported IRQ?
 	 */
@@ -534,6 +530,10 @@ int ide_setup_pci_device(struct pci_dev *dev, const struct ide_port_info *d)
 	hw_regs_t hw[4], *hws[] = { NULL, NULL, NULL, NULL };
 	int ret;
 
+	ret = ide_setup_pci_controller(dev, d, 1);
+	if (ret < 0)
+		goto out;
+
 	ret = do_ide_setup_pci_device(dev, d, 1);
 
 	if (ret >= 0) {
@@ -542,7 +542,7 @@ int ide_setup_pci_device(struct pci_dev *dev, const struct ide_port_info *d)
 
 		ret = ide_host_add(d, hws, NULL);
 	}
-
+out:
 	return ret;
 }
 EXPORT_SYMBOL_GPL(ide_setup_pci_device);
@@ -555,6 +555,10 @@ int ide_setup_pci_devices(struct pci_dev *dev1, struct pci_dev *dev2,
 	hw_regs_t hw[4], *hws[] = { NULL, NULL, NULL, NULL };
 
 	for (i = 0; i < 2; i++) {
+		ret = ide_setup_pci_controller(pdev[i], d, !i);
+		if (ret < 0)
+			goto out;
+
 		ret = do_ide_setup_pci_device(pdev[i], d, !i);
 
 		/*

commit a95925a309cd9a2e7f5a5713fd70e0dadb09890c
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu Jul 24 22:53:11 2008 +0200

    ide: respect dev->irq in do_ide_setup_pci_device() also if 'tried_config'
    
    * If device is in the PCI native mode respect dev->irq regardless of
      'tried_config' in do_ide_setup_pci_device().
    
    * Drop no longer needed 'config' argument from ide_setup_pci_controller().
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index a95d51080237..58f4a95f6f5c 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -393,14 +393,14 @@ int ide_hwif_setup_dma(ide_hwif_t *hwif, const struct ide_port_info *d)
  *	@dev: PCI device
  *	@d: IDE port info
  *	@noisy: verbose flag
- *	@config: returned as 1 if we configured the hardware
  *
  *	Set up the PCI and controller side of the IDE interface. This brings
  *	up the PCI side of the device, checks that the device is enabled
  *	and enables it if need be
  */
 
-static int ide_setup_pci_controller(struct pci_dev *dev, const struct ide_port_info *d, int noisy, int *config)
+static int ide_setup_pci_controller(struct pci_dev *dev,
+				    const struct ide_port_info *d, int noisy)
 {
 	int ret;
 	u16 pcicmd;
@@ -421,7 +421,6 @@ static int ide_setup_pci_controller(struct pci_dev *dev, const struct ide_port_i
 		ret = ide_pci_configure(dev, d);
 		if (ret < 0)
 			goto out;
-		*config = 1;
 		printk(KERN_INFO "%s: device enabled (Linux)\n", d->name);
 	}
 
@@ -487,10 +486,9 @@ static int do_ide_setup_pci_device(struct pci_dev *dev,
 				   const struct ide_port_info *d,
 				   u8 noisy)
 {
-	int tried_config = 0;
 	int pciirq, ret;
 
-	ret = ide_setup_pci_controller(dev, d, noisy, &tried_config);
+	ret = ide_setup_pci_controller(dev, d, noisy);
 	if (ret < 0)
 		goto out;
 
@@ -515,10 +513,6 @@ static int do_ide_setup_pci_device(struct pci_dev *dev,
 			printk(KERN_INFO "%s: not 100%% native mode: "
 				"will probe irqs later\n", d->name);
 		pciirq = ret;
-	} else if (tried_config) {
-		if (noisy)
-			printk(KERN_INFO "%s: will probe irqs later\n", d->name);
-		pciirq = 0;
 	} else if (!pciirq) {
 		if (noisy)
 			printk(KERN_WARNING "%s: bad irq (%d): will probe later\n",

commit 708e5f9eb68589b87724af3f0fb4e681dfdfd69f
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu Jul 24 22:53:11 2008 +0200

    ide: always call ->init_chipset method in do_ide_setup_pci_device()
    
    Call ->init_chipset method also for 'tried_config' / '!pciirq' conditions.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index b15cad58dc81..a95d51080237 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -499,20 +499,21 @@ static int do_ide_setup_pci_device(struct pci_dev *dev,
 	 */
 	pciirq = dev->irq;
 
+	/*
+	 * This allows offboard ide-pci cards the enable a BIOS,
+	 * verify interrupt settings of split-mirror pci-config
+	 * space, place chipset into init-mode, and/or preserve
+	 * an interrupt if the card is not native ide support.
+	 */
+	ret = d->init_chipset ? d->init_chipset(dev, d->name) : 0;
+	if (ret < 0)
+		goto out;
+
 	/* Is it an "IDE storage" device in non-PCI mode? */
 	if ((dev->class >> 8) == PCI_CLASS_STORAGE_IDE && (dev->class & 5) != 5) {
 		if (noisy)
 			printk(KERN_INFO "%s: not 100%% native mode: "
 				"will probe irqs later\n", d->name);
-		/*
-		 * This allows offboard ide-pci cards the enable a BIOS,
-		 * verify interrupt settings of split-mirror pci-config
-		 * space, place chipset into init-mode, and/or preserve
-		 * an interrupt if the card is not native ide support.
-		 */
-		ret = d->init_chipset ? d->init_chipset(dev, d->name) : 0;
-		if (ret < 0)
-			goto out;
 		pciirq = ret;
 	} else if (tried_config) {
 		if (noisy)
@@ -524,11 +525,6 @@ static int do_ide_setup_pci_device(struct pci_dev *dev,
 				d->name, pciirq);
 		pciirq = 0;
 	} else {
-		if (d->init_chipset) {
-			ret = d->init_chipset(dev, d->name);
-			if (ret < 0)
-				goto out;
-		}
 		if (noisy)
 			printk(KERN_INFO "%s: 100%% native mode on irq %d\n",
 				d->name, pciirq);

commit 6f904d015262dfa43eb1cecc00b0998b4c3543f2
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 23 19:55:57 2008 +0200

    ide: add ide_host_add() helper
    
    Add ide_host_add() helper which does ide_host_alloc()+ide_host_register(),
    then convert ide_setup_pci_device[s](), ide_legacy_device_add() and some
    host drivers to use it.
    
    While at it:
    
    * Fix ide_setup_pci_device[s](), ide_arm.c, gayle.c, ide-4drives.c,
      macide.c, q40ide.c, cmd640.c and cs5520.c to return correct error value.
    
    * -ENOENT -> -ENOMEM in rapide.c, ide-h8300.c, ide-generic.c, au1xxx-ide.c
      and pmac.c
    
    * -ENODEV -> -ENOMEM in palm_bk3710.c, ide_platform.c and delkin_cb.c
    
    * -1 -> -ENOMEM in ide-pnp.c
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 1c0c5570dec8..b15cad58dc81 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -541,7 +541,6 @@ static int do_ide_setup_pci_device(struct pci_dev *dev,
 
 int ide_setup_pci_device(struct pci_dev *dev, const struct ide_port_info *d)
 {
-	struct ide_host *host;
 	hw_regs_t hw[4], *hws[] = { NULL, NULL, NULL, NULL };
 	int ret;
 
@@ -551,9 +550,7 @@ int ide_setup_pci_device(struct pci_dev *dev, const struct ide_port_info *d)
 		/* FIXME: silent failure can happen */
 		ide_pci_setup_ports(dev, d, ret, &hw[0], &hws[0]);
 
-		host = ide_host_alloc(d, hws);
-		if (host)
-			ide_host_register(host, d, hws);
+		ret = ide_host_add(d, hws, NULL);
 	}
 
 	return ret;
@@ -564,7 +561,6 @@ int ide_setup_pci_devices(struct pci_dev *dev1, struct pci_dev *dev2,
 			  const struct ide_port_info *d)
 {
 	struct pci_dev *pdev[] = { dev1, dev2 };
-	struct ide_host *host;
 	int ret, i;
 	hw_regs_t hw[4], *hws[] = { NULL, NULL, NULL, NULL };
 
@@ -582,9 +578,7 @@ int ide_setup_pci_devices(struct pci_dev *dev1, struct pci_dev *dev2,
 		ide_pci_setup_ports(pdev[i], d, ret, &hw[i*2], &hws[i*2]);
 	}
 
-	host = ide_host_alloc(d, hws);
-	if (host)
-		ide_host_register(host, d, hws);
+	ret = ide_host_add(d, hws, NULL);
 out:
 	return ret;
 }

commit 48c3c1072651922ed153bcf0a33ea82cf20df390
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 23 19:55:57 2008 +0200

    ide: add struct ide_host (take 3)
    
    * Add struct ide_host which keeps pointers to host's ports.
    
    * Add ide_host_alloc[_all]() and ide_host_remove() helpers.
    
    * Pass 'struct ide_host *host' instead of 'u8 *idx' to
      ide_device_add[_all]() and rename it to ide_host_register[_all]().
    
    * Convert host drivers and core code to use struct ide_host.
    
    * Remove no longer needed ide_find_port().
    
    * Make ide_find_port_slot() static.
    
    * Unexport ide_unregister().
    
    v2:
    * Add missing 'struct ide_host *host' to macide.c.
    
    v3:
    * Fix build problem in pmac.c (s/ide_alloc_host/ide_host_alloc/)
      (Noticed by Stephen Rothwell).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 804c3ef245f9..1c0c5570dec8 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -289,7 +289,7 @@ static int ide_pci_check_iomem(struct pci_dev *dev, const struct ide_port_info *
 }
 
 /**
- *	ide_hwif_configure	-	configure an IDE interface
+ *	ide_hw_configure	-	configure a hw_regs_t instance
  *	@dev: PCI device holding interface
  *	@d: IDE port info
  *	@port: port number
@@ -300,23 +300,20 @@ static int ide_pci_check_iomem(struct pci_dev *dev, const struct ide_port_info *
  *	is done per interface port rather than per PCI device. There may be
  *	more than one port per device.
  *
- *	Returns the new hardware interface structure, or NULL on a failure
+ *	Returns zero on success or an error code.
  */
 
-static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev,
-				      const struct ide_port_info *d,
-				      unsigned int port, int irq,
-				      hw_regs_t *hw)
+static int ide_hw_configure(struct pci_dev *dev, const struct ide_port_info *d,
+			    unsigned int port, int irq, hw_regs_t *hw)
 {
 	unsigned long ctl = 0, base = 0;
-	ide_hwif_t *hwif;
 
 	if ((d->host_flags & IDE_HFLAG_ISA_PORTS) == 0) {
 		if (ide_pci_check_iomem(dev, d, 2 * port) ||
 		    ide_pci_check_iomem(dev, d, 2 * port + 1)) {
 			printk(KERN_ERR "%s: I/O baseregs (BIOS) are reported "
 					"as MEM for port %d!\n", d->name, port);
-			return NULL;
+			return -EINVAL;
 		}
 
 		ctl  = pci_resource_start(dev, 2*port+1);
@@ -330,7 +327,7 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev,
 	if (!base || !ctl) {
 		printk(KERN_ERR "%s: bad PCI BARs for port %d, skipping\n",
 				d->name, port);
-		return NULL;
+		return -EINVAL;
 	}
 
 	memset(hw, 0, sizeof(*hw));
@@ -339,13 +336,7 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev,
 	hw->chipset = d->chipset ? d->chipset : ide_pci;
 	ide_std_init_ports(hw, base, ctl | 2);
 
-	hwif = ide_find_port_slot(d);
-	if (hwif == NULL)
-		return NULL;
-
-	hwif->chipset = hw->chipset;
-
-	return hwif;
+	return 0;
 }
 
 #ifdef CONFIG_BLK_DEV_IDEDMA_PCI
@@ -443,7 +434,6 @@ static int ide_setup_pci_controller(struct pci_dev *dev, const struct ide_port_i
  *	@dev: PCI device
  *	@d: IDE port info
  *	@pciirq: IRQ line
- *	@idx: ATA index table to update
  *	@hw: hw_regs_t instances corresponding to this PCI IDE device
  *	@hws: hw_regs_t pointers table to update
  *
@@ -457,10 +447,9 @@ static int ide_setup_pci_controller(struct pci_dev *dev, const struct ide_port_i
  */
 
 void ide_pci_setup_ports(struct pci_dev *dev, const struct ide_port_info *d,
-			 int pciirq, u8 *idx, hw_regs_t *hw, hw_regs_t **hws)
+			 int pciirq, hw_regs_t *hw, hw_regs_t **hws)
 {
 	int channels = (d->host_flags & IDE_HFLAG_SINGLE) ? 1 : 2, port;
-	ide_hwif_t *hwif;
 	u8 tmp;
 
 	/*
@@ -476,12 +465,10 @@ void ide_pci_setup_ports(struct pci_dev *dev, const struct ide_port_info *d,
 			continue;	/* port not enabled */
 		}
 
-		hwif = ide_hwif_configure(dev, d, port, pciirq, hw + port);
-		if (hwif == NULL)
+		if (ide_hw_configure(dev, d, port, pciirq, hw + port))
 			continue;
 
 		*(hws + port) = hw + port;
-		*(idx + port) = hwif->index;
 	}
 }
 EXPORT_SYMBOL_GPL(ide_pci_setup_ports);
@@ -554,7 +541,7 @@ static int do_ide_setup_pci_device(struct pci_dev *dev,
 
 int ide_setup_pci_device(struct pci_dev *dev, const struct ide_port_info *d)
 {
-	u8 idx[4] = { 0xff, 0xff, 0xff, 0xff };
+	struct ide_host *host;
 	hw_regs_t hw[4], *hws[] = { NULL, NULL, NULL, NULL };
 	int ret;
 
@@ -562,9 +549,11 @@ int ide_setup_pci_device(struct pci_dev *dev, const struct ide_port_info *d)
 
 	if (ret >= 0) {
 		/* FIXME: silent failure can happen */
-		ide_pci_setup_ports(dev, d, ret, &idx[0], &hw[0], &hws[0]);
+		ide_pci_setup_ports(dev, d, ret, &hw[0], &hws[0]);
 
-		ide_device_add(idx, d, hws);
+		host = ide_host_alloc(d, hws);
+		if (host)
+			ide_host_register(host, d, hws);
 	}
 
 	return ret;
@@ -575,9 +564,9 @@ int ide_setup_pci_devices(struct pci_dev *dev1, struct pci_dev *dev2,
 			  const struct ide_port_info *d)
 {
 	struct pci_dev *pdev[] = { dev1, dev2 };
+	struct ide_host *host;
 	int ret, i;
 	hw_regs_t hw[4], *hws[] = { NULL, NULL, NULL, NULL };
-	u8 idx[4] = { 0xff, 0xff, 0xff, 0xff };
 
 	for (i = 0; i < 2; i++) {
 		ret = do_ide_setup_pci_device(pdev[i], d, !i);
@@ -590,11 +579,12 @@ int ide_setup_pci_devices(struct pci_dev *dev1, struct pci_dev *dev2,
 			goto out;
 
 		/* FIXME: silent failure can happen */
-		ide_pci_setup_ports(pdev[i], d, ret, &idx[i*2], &hw[i*2],
-				    &hws[i*2]);
+		ide_pci_setup_ports(pdev[i], d, ret, &hw[i*2], &hws[i*2]);
 	}
 
-	ide_device_add(idx, d, hws);
+	host = ide_host_alloc(d, hws);
+	if (host)
+		ide_host_register(host, d, hws);
 out:
 	return ret;
 }

commit 374e042c3e767ac2e5a40b78529220e0b3de793c
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 23 19:55:56 2008 +0200

    ide: add struct ide_tp_ops (take 2)
    
    * Add struct ide_tp_ops for transport methods.
    
    * Add 'const struct ide_tp_ops *tp_ops' to struct ide_port_info
      and ide_hwif_t.
    
    * Set the default hwif->tp_ops in ide_init_port_data().
    
    * Set host driver specific hwif->tp_ops in ide_init_port().
    
    * Export ide_exec_command(), ide_read_status(), ide_read_altstatus(),
      ide_read_sff_dma_status(), ide_set_irq(), ide_tf_{load,read}()
      and ata_{in,out}put_data().
    
    * Convert host drivers and core code to use struct ide_tp_ops.
    
    * Remove no longer needed default_hwif_transport().
    
    * Cleanup ide_hwif_t from methods that are now in struct ide_tp_ops.
    
    While at it:
    
    * Use struct ide_port_info in falconide.c and q40ide.c.
    
    * Rename ata_{in,out}put_data() to ide_{in,out}put_data().
    
    v2:
    
    * Fix missing convertion in ns87415.c.
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index c1b609d9cb28..804c3ef245f9 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -125,7 +125,7 @@ int ide_pci_check_simplex(ide_hwif_t *hwif, const struct ide_port_info *d)
 	 * we tune the drive then try to grab DMA ownership if we want to be
 	 * the DMA end.  This has to be become dynamic to handle hot-plug.
 	 */
-	dma_stat = hwif->read_sff_dma_status(hwif);
+	dma_stat = hwif->tp_ops->read_sff_dma_status(hwif);
 	if ((dma_stat & 0x80) && hwif->mate && hwif->mate->dma_base) {
 		printk(KERN_INFO "%s: simplex device: DMA disabled\n", d->name);
 		return -1;

commit ebb00fb55d0566bb3e81518122a57b4b3bedf1e4
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 23 19:55:51 2008 +0200

    ide: factor out simplex handling from ide_pci_dma_base()
    
    * Factor out simplex handling from ide_pci_dma_base() to
      ide_pci_check_simplex().
    
    * Set hwif->dma_base early in ->init_dma method / ide_hwif_setup_dma()
      and reset it in ide_init_port() if DMA initialization fails.
    
    * Use ->read_sff_dma_status instead of ->INB in ide_pci_dma_base().
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index b047013f3652..c1b609d9cb28 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -73,15 +73,12 @@ static void ide_pci_clear_simplex(unsigned long dma_base, const char *name)
  *	@d: IDE port info
  *
  *	Fetch the DMA Bus-Master-I/O-Base-Address (BMIBA) from PCI space.
- *	Where a device has a partner that is already in DMA mode we check
- *	and enforce IDE simplex rules.
  */
 
 unsigned long ide_pci_dma_base(ide_hwif_t *hwif, const struct ide_port_info *d)
 {
 	struct pci_dev *dev = to_pci_dev(hwif->dev);
 	unsigned long dma_base = 0;
-	u8 dma_stat = 0;
 
 	if (hwif->host_flags & IDE_HFLAG_MMIO)
 		return hwif->dma_base;
@@ -102,11 +99,19 @@ unsigned long ide_pci_dma_base(ide_hwif_t *hwif, const struct ide_port_info *d)
 	if (hwif->channel)
 		dma_base += 8;
 
-	if (d->host_flags & IDE_HFLAG_CS5520)
+	return dma_base;
+}
+EXPORT_SYMBOL_GPL(ide_pci_dma_base);
+
+int ide_pci_check_simplex(ide_hwif_t *hwif, const struct ide_port_info *d)
+{
+	u8 dma_stat;
+
+	if (d->host_flags & (IDE_HFLAG_MMIO | IDE_HFLAG_CS5520))
 		goto out;
 
 	if (d->host_flags & IDE_HFLAG_CLEAR_SIMPLEX) {
-		ide_pci_clear_simplex(dma_base, d->name);
+		ide_pci_clear_simplex(hwif->dma_base, d->name);
 		goto out;
 	}
 
@@ -120,15 +125,15 @@ unsigned long ide_pci_dma_base(ide_hwif_t *hwif, const struct ide_port_info *d)
 	 * we tune the drive then try to grab DMA ownership if we want to be
 	 * the DMA end.  This has to be become dynamic to handle hot-plug.
 	 */
-	dma_stat = hwif->INB(dma_base + 2);
+	dma_stat = hwif->read_sff_dma_status(hwif);
 	if ((dma_stat & 0x80) && hwif->mate && hwif->mate->dma_base) {
 		printk(KERN_INFO "%s: simplex device: DMA disabled\n", d->name);
-		dma_base = 0;
+		return -1;
 	}
 out:
-	return dma_base;
+	return 0;
 }
-EXPORT_SYMBOL_GPL(ide_pci_dma_base);
+EXPORT_SYMBOL_GPL(ide_pci_check_simplex);
 
 /*
  * Set up BM-DMA capability (PnP BIOS should have done this)
@@ -363,7 +368,15 @@ int ide_hwif_setup_dma(ide_hwif_t *hwif, const struct ide_port_info *d)
 	     (dev->class & 0x80))) {
 		unsigned long base = ide_pci_dma_base(hwif, d);
 
-		if (base == 0 || ide_pci_set_master(dev, d->name) < 0)
+		if (base == 0)
+			return -1;
+
+		hwif->dma_base = base;
+
+		if (ide_pci_check_simplex(hwif, d) < 0)
+			return -1;
+
+		if (ide_pci_set_master(dev, d->name) < 0)
 			return -1;
 
 		if (hwif->host_flags & IDE_HFLAG_MMIO)
@@ -377,8 +390,6 @@ int ide_hwif_setup_dma(ide_hwif_t *hwif, const struct ide_port_info *d)
 		if (ide_allocate_dma_engine(hwif))
 			return -1;
 
-		hwif->dma_base = base;
-
 		hwif->dma_ops = &sff_dma_ops;
 	}
 

commit 81e8d5a34f7d2a2acbe309cfa5810a9699a63239
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 23 19:55:51 2008 +0200

    ide: remove ide_setup_dma()
    
    Export sff_dma_ops and then remove ide_setup_dma().
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index acb467c6f345..b047013f3652 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -377,7 +377,9 @@ int ide_hwif_setup_dma(ide_hwif_t *hwif, const struct ide_port_info *d)
 		if (ide_allocate_dma_engine(hwif))
 			return -1;
 
-		ide_setup_dma(hwif, base);
+		hwif->dma_base = base;
+
+		hwif->dma_ops = &sff_dma_ops;
 	}
 
 	return 0;

commit c97c6aca75fd5f718056fde7cff798b8cbdb07c0
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 23 19:55:50 2008 +0200

    ide: pass hw_regs_t-s to ide_device_add[_all]() (take 3)
    
    * Add 'hw_regs_t **hws' argument to ide_device_add[_all]() and convert
      host drivers + ide_legacy_init_one() + ide_setup_pci_device[s]() to use
      it instead of calling ide_init_port_hw() directly.
    
      [ However if host has > 1 port we must still set hwif->chipset to hint
        consecutive ide_find_port() call that the previous slot is occupied. ]
    
    * Unexport ide_init_port_hw().
    
    v2:
    * Use defines instead of hard-coded values in buddha.c, gayle.c and q40ide.c.
      (Suggested by Geert Uytterhoeven)
    
    * Better patch description.
    
    v3:
    * Fix build problem in ide-cs.c. (Noticed by Stephen Rothwell)
    
    There should be no functional changes caused by this patch.
    
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 7ae6ae45331f..acb467c6f345 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -289,6 +289,7 @@ static int ide_pci_check_iomem(struct pci_dev *dev, const struct ide_port_info *
  *	@d: IDE port info
  *	@port: port number
  *	@irq: PCI IRQ
+ *	@hw: hw_regs_t instance corresponding to this port
  *
  *	Perform the initial set up for the hardware interface structure. This
  *	is done per interface port rather than per PCI device. There may be
@@ -299,11 +300,11 @@ static int ide_pci_check_iomem(struct pci_dev *dev, const struct ide_port_info *
 
 static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev,
 				      const struct ide_port_info *d,
-				      unsigned int port, int irq)
+				      unsigned int port, int irq,
+				      hw_regs_t *hw)
 {
 	unsigned long ctl = 0, base = 0;
 	ide_hwif_t *hwif;
-	struct hw_regs_s hw;
 
 	if ((d->host_flags & IDE_HFLAG_ISA_PORTS) == 0) {
 		if (ide_pci_check_iomem(dev, d, 2 * port) ||
@@ -327,17 +328,17 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev,
 		return NULL;
 	}
 
+	memset(hw, 0, sizeof(*hw));
+	hw->irq = irq;
+	hw->dev = &dev->dev;
+	hw->chipset = d->chipset ? d->chipset : ide_pci;
+	ide_std_init_ports(hw, base, ctl | 2);
+
 	hwif = ide_find_port_slot(d);
 	if (hwif == NULL)
 		return NULL;
 
-	memset(&hw, 0, sizeof(hw));
-	hw.irq = irq;
-	hw.dev = &dev->dev;
-	hw.chipset = d->chipset ? d->chipset : ide_pci;
-	ide_std_init_ports(&hw, base, ctl | 2);
-
-	ide_init_port_hw(hwif, &hw);
+	hwif->chipset = hw->chipset;
 
 	return hwif;
 }
@@ -430,6 +431,8 @@ static int ide_setup_pci_controller(struct pci_dev *dev, const struct ide_port_i
  *	@d: IDE port info
  *	@pciirq: IRQ line
  *	@idx: ATA index table to update
+ *	@hw: hw_regs_t instances corresponding to this PCI IDE device
+ *	@hws: hw_regs_t pointers table to update
  *
  *	Scan the interfaces attached to this device and do any
  *	necessary per port setup. Attach the devices and ask the
@@ -440,7 +443,8 @@ static int ide_setup_pci_controller(struct pci_dev *dev, const struct ide_port_i
  *	where the chipset setup is not the default PCI IDE one.
  */
 
-void ide_pci_setup_ports(struct pci_dev *dev, const struct ide_port_info *d, int pciirq, u8 *idx)
+void ide_pci_setup_ports(struct pci_dev *dev, const struct ide_port_info *d,
+			 int pciirq, u8 *idx, hw_regs_t *hw, hw_regs_t **hws)
 {
 	int channels = (d->host_flags & IDE_HFLAG_SINGLE) ? 1 : 2, port;
 	ide_hwif_t *hwif;
@@ -459,10 +463,11 @@ void ide_pci_setup_ports(struct pci_dev *dev, const struct ide_port_info *d, int
 			continue;	/* port not enabled */
 		}
 
-		hwif = ide_hwif_configure(dev, d, port, pciirq);
+		hwif = ide_hwif_configure(dev, d, port, pciirq, hw + port);
 		if (hwif == NULL)
 			continue;
 
+		*(hws + port) = hw + port;
 		*(idx + port) = hwif->index;
 	}
 }
@@ -537,15 +542,16 @@ static int do_ide_setup_pci_device(struct pci_dev *dev,
 int ide_setup_pci_device(struct pci_dev *dev, const struct ide_port_info *d)
 {
 	u8 idx[4] = { 0xff, 0xff, 0xff, 0xff };
+	hw_regs_t hw[4], *hws[] = { NULL, NULL, NULL, NULL };
 	int ret;
 
 	ret = do_ide_setup_pci_device(dev, d, 1);
 
 	if (ret >= 0) {
 		/* FIXME: silent failure can happen */
-		ide_pci_setup_ports(dev, d, ret, &idx[0]);
+		ide_pci_setup_ports(dev, d, ret, &idx[0], &hw[0], &hws[0]);
 
-		ide_device_add(idx, d);
+		ide_device_add(idx, d, hws);
 	}
 
 	return ret;
@@ -557,6 +563,7 @@ int ide_setup_pci_devices(struct pci_dev *dev1, struct pci_dev *dev2,
 {
 	struct pci_dev *pdev[] = { dev1, dev2 };
 	int ret, i;
+	hw_regs_t hw[4], *hws[] = { NULL, NULL, NULL, NULL };
 	u8 idx[4] = { 0xff, 0xff, 0xff, 0xff };
 
 	for (i = 0; i < 2; i++) {
@@ -570,10 +577,11 @@ int ide_setup_pci_devices(struct pci_dev *dev1, struct pci_dev *dev2,
 			goto out;
 
 		/* FIXME: silent failure can happen */
-		ide_pci_setup_ports(pdev[i], d, ret, &idx[i*2]);
+		ide_pci_setup_ports(pdev[i], d, ret, &idx[i*2], &hw[i*2],
+				    &hws[i*2]);
 	}
 
-	ide_device_add(idx, d);
+	ide_device_add(idx, d, hws);
 out:
 	return ret;
 }

commit 51d87ed0aab98999bebaf891b99730e15502a592
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 23 19:55:49 2008 +0200

    ide: move ide_pci_setup_ports() call out from do_ide_setup_pci_device()
    
    * Move ide_pci_setup_ports() call out from do_ide_setup_pci_device()
      to ide_setup_pci_device[s]().
    
    * Drop no longer needed idx argument from do_ide_setup_pci_device().
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 65fc08b6b6d0..7ae6ae45331f 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -480,7 +480,7 @@ EXPORT_SYMBOL_GPL(ide_pci_setup_ports);
  */
 static int do_ide_setup_pci_device(struct pci_dev *dev,
 				   const struct ide_port_info *d,
-				   u8 *idx, u8 noisy)
+				   u8 noisy)
 {
 	int tried_config = 0;
 	int pciirq, ret;
@@ -529,9 +529,7 @@ static int do_ide_setup_pci_device(struct pci_dev *dev,
 				d->name, pciirq);
 	}
 
-	/* FIXME: silent failure can happen */
-
-	ide_pci_setup_ports(dev, d, pciirq, idx);
+	ret = pciirq;
 out:
 	return ret;
 }
@@ -541,10 +539,14 @@ int ide_setup_pci_device(struct pci_dev *dev, const struct ide_port_info *d)
 	u8 idx[4] = { 0xff, 0xff, 0xff, 0xff };
 	int ret;
 
-	ret = do_ide_setup_pci_device(dev, d, &idx[0], 1);
+	ret = do_ide_setup_pci_device(dev, d, 1);
+
+	if (ret >= 0) {
+		/* FIXME: silent failure can happen */
+		ide_pci_setup_ports(dev, d, ret, &idx[0]);
 
-	if (ret >= 0)
 		ide_device_add(idx, d);
+	}
 
 	return ret;
 }
@@ -558,13 +560,17 @@ int ide_setup_pci_devices(struct pci_dev *dev1, struct pci_dev *dev2,
 	u8 idx[4] = { 0xff, 0xff, 0xff, 0xff };
 
 	for (i = 0; i < 2; i++) {
-		ret = do_ide_setup_pci_device(pdev[i], d, &idx[i*2], !i);
+		ret = do_ide_setup_pci_device(pdev[i], d, !i);
+
 		/*
 		 * FIXME: Mom, mom, they stole me the helper function to undo
 		 * do_ide_setup_pci_device() on the first device!
 		 */
 		if (ret < 0)
 			goto out;
+
+		/* FIXME: silent failure can happen */
+		ide_pci_setup_ports(pdev[i], d, ret, &idx[i*2]);
 	}
 
 	ide_device_add(idx, d);

commit ff23712e791fd80f3b088d5e1c5733c0944cfe64
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 16 20:33:44 2008 +0200

    ide: remove needless includes from setup-pci.c (take 2)
    
    v2:
    * sparc build fix. (From Stephen Rothwell)
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 4321d20fe874..65fc08b6b6d0 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -6,19 +6,15 @@
  *  May be copied or modified under the terms of the GNU General Public License
  */
 
-#include <linux/module.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/pci.h>
 #include <linux/init.h>
-#include <linux/timer.h>
-#include <linux/mm.h>
 #include <linux/interrupt.h>
 #include <linux/ide.h>
 #include <linux/dma-mapping.h>
 
 #include <asm/io.h>
-#include <asm/irq.h>
 
 /**
  *	ide_setup_pci_baseregs	-	place a PCI IDE controller native

commit eb3aff5530d22eb4be0a99c9d39c9ffde7b9891a
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 16 20:33:42 2008 +0200

    ide: print message on error in ide_find_port_slot()
    
    * Add DRV_NAME define to ide-h8300.c.
    
    * Fix ide-h8300.c, swarm.c and sgiioc4.c to set .name field in
      struct ide_port_info to DRV_NAME, then convert these host drivers
      to use ide_find_port_slot() instead of ide_find_port().
    
    * Print message on error in ide_find_port_slot().
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 166211f53f17..4321d20fe874 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -332,11 +332,8 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev,
 	}
 
 	hwif = ide_find_port_slot(d);
-	if (hwif == NULL) {
-		printk(KERN_ERR "%s: too many IDE interfaces, no room in "
-				"table\n", d->name);
+	if (hwif == NULL)
 		return NULL;
-	}
 
 	memset(&hw, 0, sizeof(hw));
 	hw.irq = irq;

commit c1da678b5b4d8ce7836ed1ded80109d1db37efe0
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 16 20:33:41 2008 +0200

    ide: tighten checks on PCI BARs in ide_hwif_configure()
    
    Alan has fixed PCI layer handling of PCI IDE in Compatibility mode so
    PCI BAR 0/1 (and/or 2/3) content reported by kernel should never be zero.
    
    Tighten checks on PCI BARs and also fix printk() message while on it.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 3dea5a59626e..166211f53f17 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -319,18 +319,18 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev,
 
 		ctl  = pci_resource_start(dev, 2*port+1);
 		base = pci_resource_start(dev, 2*port);
-		if ((ctl && !base) || (base && !ctl)) {
-			printk(KERN_ERR "%s: inconsistent baseregs (BIOS) "
-				"for port %d, skipping\n", d->name, port);
-			return NULL;
-		}
-	}
-	if (!ctl) {
+	} else {
 		/* Use default values */
 		ctl = port ? 0x374 : 0x3f4;
 		base = port ? 0x170 : 0x1f0;
 	}
 
+	if (!base || !ctl) {
+		printk(KERN_ERR "%s: bad PCI BARs for port %d, skipping\n",
+				d->name, port);
+		return NULL;
+	}
+
 	hwif = ide_find_port_slot(d);
 	if (hwif == NULL) {
 		printk(KERN_ERR "%s: too many IDE interfaces, no room in "

commit c56c5648a3bd15ff14c50f284b261140cd5b5472
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 16 20:33:40 2008 +0200

    ide: set hwif->dev in ide_init_port_hw() (take 2)
    
    * Add 'parent' field to hw_regs_t for optional parent device pointer (needed
      by macio PMAC IDE controllers) and set hwif->dev in ide_init_port_hw().
    
    * Update au1xxx-ide.c, sgiioc4.c, pmac.c and setup-pci.c accordingly.
    
    v2:
    
    * Update scc_pata.c.
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index abcfb1739d4d..3dea5a59626e 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -346,8 +346,6 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev,
 
 	ide_init_port_hw(hwif, &hw);
 
-	hwif->dev = &dev->dev;
-
 	return hwif;
 }
 

commit 135721446144af005109c25eeacca4fdddcd9a66
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jul 15 21:21:49 2008 +0200

    ide: remove ->mmio flag from ide_hwif_t
    
    Since scc_pata host driver no longer uses IDE PCI layer / ide_dma_setup()
    and all other ->mmio users set also IDE_HFLAG_MMIO host flag we can safely
    remove ->mmio flag.
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 5171601fb255..abcfb1739d4d 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -87,7 +87,7 @@ unsigned long ide_pci_dma_base(ide_hwif_t *hwif, const struct ide_port_info *d)
 	unsigned long dma_base = 0;
 	u8 dma_stat = 0;
 
-	if (hwif->mmio)
+	if (hwif->host_flags & IDE_HFLAG_MMIO)
 		return hwif->dma_base;
 
 	if (hwif->mate && hwif->mate->dma_base) {
@@ -374,7 +374,7 @@ int ide_hwif_setup_dma(ide_hwif_t *hwif, const struct ide_port_info *d)
 		if (base == 0 || ide_pci_set_master(dev, d->name) < 0)
 			return -1;
 
-		if (hwif->mmio)
+		if (hwif->host_flags & IDE_HFLAG_MMIO)
 			printk(KERN_INFO "    %s: MMIO-DMA\n", hwif->name);
 		else
 			printk(KERN_INFO "    %s: BM-DMA at 0x%04lx-0x%04lx\n",

commit f37afdaca711838b50ecd89b9c15fc745270d77c
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 22:25:24 2008 +0200

    ide: constify struct ide_dma_ops
    
    * Export ide_dma_exec_cmd() and __ide_dma_test_irq().
    
    * Constify struct ide_dma_ops.
    
    * Always set hwif->dma_ops to &sff_dma_ops in ide_setup_dma()
      (it is later overriden by ide_init_port() if needed) and drop
      'const struct ide_port_info *d' argument.
    
    While at it:
    
    * Rename __ide_dma_test_irq() to ide_dma_test_irq().
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 9a1e01e176f0..5171601fb255 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -385,7 +385,7 @@ int ide_hwif_setup_dma(ide_hwif_t *hwif, const struct ide_port_info *d)
 		if (ide_allocate_dma_engine(hwif))
 			return -1;
 
-		ide_setup_dma(hwif, base, d);
+		ide_setup_dma(hwif, base);
 	}
 
 	return 0;

commit 5e37bdc081a980dd0d669e6387bcf15ca9666f81
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 22:25:24 2008 +0200

    ide: add struct ide_dma_ops (take 3)
    
    Add struct ide_dma_ops and convert core code + drivers to use it.
    
    While at it:
    
    * Drop "ide_" prefix from ->ide_dma_end and ->ide_dma_test_irq methods.
    
    * Drop "ide_" "infixes" from DMA methods.
    
    * au1xxx-ide.c:
      - use auide_dma_{test_irq,end}() directly in auide_dma_timeout()
    
    * pdc202xx_old.c:
      - drop "old_" "infixes" from DMA methods
    
    * siimage.c:
      - add siimage_dma_test_irq() helper
      - print SATA warning in siimage_init_one()
    
    * Remove no longer needed ->init_hwif implementations.
    
    v2:
    * Changes based on review from Sergei:
      - s/siimage_ide_dma_test_irq/siimage_dma_test_irq/
      - s/drive->hwif/hwif/ in idefloppy_pc_intr().
      - fix patch description w.r.t. au1xxx-ide changes
      - fix au1xxx-ide build
      - fix naming for cmd64*_dma_ops
      - drop "ide_" and "old_" infixes
      - s/hpt3xxx_dma_ops/hpt37x_dma_ops/
      - s/hpt370x_dma_ops/hpt370_dma_ops/
      - use correct DMA ops for HPT302/N, HPT371/N and HPT374
      - s/it821x_smart_dma_ops/it821x_pass_through_dma_ops/
    
    v3:
    * Two bugs slipped in v2 (noticed by Sergei):
      - use correct DMA ops for HPT374 (for real this time)
      - handle HPT370/HPT370A properly
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 5171601fb255..9a1e01e176f0 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -385,7 +385,7 @@ int ide_hwif_setup_dma(ide_hwif_t *hwif, const struct ide_port_info *d)
 		if (ide_allocate_dma_engine(hwif))
 			return -1;
 
-		ide_setup_dma(hwif, base);
+		ide_setup_dma(hwif, base, d);
 	}
 
 	return 0;

commit b123f56e04c7c112f754f948198d1ea5a80e649d
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 22:25:22 2008 +0200

    ide: do complete DMA setup in ->init_dma method (take 2)
    
    * Make ide_hwif_setup_dma() return an error value.
    
    * Pass 'const struct ide_port_info *d' instead of 'unsigned long dmabase'
      to ->init_dma method and make it return an error value.
    
    * Rename ide_get_or_set_dma_base() to ide_pci_dma_base(),
      change ordering of its arguments and then export it.
    
    * Export ide_pci_set_master().
    
    * Do complete DMA setup inside ->init_dma method and update ->init_dma
      users accordingly.
    
    * Sanitize code for DMA setup in ide_init_port().
    
    v2:
    * Fix for CONFIG_BLK_DEV_IDEDMA_PCI=n configs
      (from Jiri Slaby <jirislaby@gmail.com>):
    
      Fix following compiler warning by returning EINVAL:
    
      In file included from ANYTHING-INCLUDING-IDE.H:45:
      include/linux/ide.h: In function ‘ide_hwif_setup_dma’:
      include/linux/ide.h:1022: warning: no return statement in function returning non-void
    
    Cc: Jiri Slaby <jirislaby@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 5006ea98733b..5171601fb255 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -72,16 +72,16 @@ static void ide_pci_clear_simplex(unsigned long dma_base, const char *name)
 }
 
 /**
- *	ide_get_or_set_dma_base		-	setup BMIBA
- *	@d: IDE port info
+ *	ide_pci_dma_base	-	setup BMIBA
  *	@hwif: IDE interface
+ *	@d: IDE port info
  *
  *	Fetch the DMA Bus-Master-I/O-Base-Address (BMIBA) from PCI space.
  *	Where a device has a partner that is already in DMA mode we check
  *	and enforce IDE simplex rules.
  */
 
-static unsigned long ide_get_or_set_dma_base(const struct ide_port_info *d, ide_hwif_t *hwif)
+unsigned long ide_pci_dma_base(ide_hwif_t *hwif, const struct ide_port_info *d)
 {
 	struct pci_dev *dev = to_pci_dev(hwif->dev);
 	unsigned long dma_base = 0;
@@ -132,11 +132,12 @@ static unsigned long ide_get_or_set_dma_base(const struct ide_port_info *d, ide_
 out:
 	return dma_base;
 }
+EXPORT_SYMBOL_GPL(ide_pci_dma_base);
 
 /*
  * Set up BM-DMA capability (PnP BIOS should have done this)
  */
-static int ide_pci_set_master(struct pci_dev *dev, const char *name)
+int ide_pci_set_master(struct pci_dev *dev, const char *name)
 {
 	u16 pcicmd;
 
@@ -155,6 +156,7 @@ static int ide_pci_set_master(struct pci_dev *dev, const char *name)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(ide_pci_set_master);
 #endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
 
 void ide_setup_pci_noise(struct pci_dev *dev, const struct ide_port_info *d)
@@ -360,20 +362,17 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev,
  *	state
  */
 
-void ide_hwif_setup_dma(ide_hwif_t *hwif, const struct ide_port_info *d)
+int ide_hwif_setup_dma(ide_hwif_t *hwif, const struct ide_port_info *d)
 {
 	struct pci_dev *dev = to_pci_dev(hwif->dev);
 
 	if ((d->host_flags & IDE_HFLAG_NO_AUTODMA) == 0 ||
 	    ((dev->class >> 8) == PCI_CLASS_STORAGE_IDE &&
 	     (dev->class & 0x80))) {
-		unsigned long base = ide_get_or_set_dma_base(d, hwif);
+		unsigned long base = ide_pci_dma_base(hwif, d);
 
 		if (base == 0 || ide_pci_set_master(dev, d->name) < 0)
-			goto out_disabled;
-
-		if (d->init_dma)
-			d->init_dma(hwif, base);
+			return -1;
 
 		if (hwif->mmio)
 			printk(KERN_INFO "    %s: MMIO-DMA\n", hwif->name);
@@ -383,15 +382,13 @@ void ide_hwif_setup_dma(ide_hwif_t *hwif, const struct ide_port_info *d)
 
 		hwif->extra_base = base + (hwif->channel ? 8 : 16);
 
-		if (ide_allocate_dma_engine(hwif) == 0)
-			ide_setup_dma(hwif, base);
-	}
+		if (ide_allocate_dma_engine(hwif))
+			return -1;
 
-	return;
+		ide_setup_dma(hwif, base);
+	}
 
-out_disabled:
-	printk(KERN_INFO "%s: Bus-Master DMA disabled (BIOS) on %s\n",
-			 d->name, pci_name(dev));
+	return 0;
 }
 #endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
 

commit 63158d5c217e2e62665ae9b10d203bd7da817108
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 22:25:21 2008 +0200

    ide: cleanup ide_setup_dma()
    
    * There is no need to call ide_release_dma_engine().
    
    * Move the code up to (and including) ide_allocate_dma_engine()
      call to the callers of ide_setup_dma().
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index bf28970b0278..5006ea98733b 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -367,15 +367,24 @@ void ide_hwif_setup_dma(ide_hwif_t *hwif, const struct ide_port_info *d)
 	if ((d->host_flags & IDE_HFLAG_NO_AUTODMA) == 0 ||
 	    ((dev->class >> 8) == PCI_CLASS_STORAGE_IDE &&
 	     (dev->class & 0x80))) {
-		unsigned long dma_base = ide_get_or_set_dma_base(d, hwif);
+		unsigned long base = ide_get_or_set_dma_base(d, hwif);
 
-		if (dma_base == 0 || ide_pci_set_master(dev, d->name) < 0)
+		if (base == 0 || ide_pci_set_master(dev, d->name) < 0)
 			goto out_disabled;
 
 		if (d->init_dma)
-			d->init_dma(hwif, dma_base);
+			d->init_dma(hwif, base);
 
-		ide_setup_dma(hwif, dma_base);
+		if (hwif->mmio)
+			printk(KERN_INFO "    %s: MMIO-DMA\n", hwif->name);
+		else
+			printk(KERN_INFO "    %s: BM-DMA at 0x%04lx-0x%04lx\n",
+					 hwif->name, base, base + 7);
+
+		hwif->extra_base = base + (hwif->channel ? 8 : 16);
+
+		if (ide_allocate_dma_engine(hwif) == 0)
+			ide_setup_dma(hwif, base);
 	}
 
 	return;

commit d54452fbf84500eff77a55a2061f4669441d2cc3
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 22:25:21 2008 +0200

    ide: factor out setting PCI bus-mastering from ide_hwif_setup_dma()
    
    Factor out setting PCI bus-mastering from ide_hwif_setup_dma()
    to ide_pci_set_master() helper.
    
    While at it:
    
    * don't read PCI Command register if not necessary
    
    * use PCI device name instead of hwif->name
    
    * cleanup ide_hwif_setup_dma() a bit
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index f8fc9727da07..bf28970b0278 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -132,6 +132,29 @@ static unsigned long ide_get_or_set_dma_base(const struct ide_port_info *d, ide_
 out:
 	return dma_base;
 }
+
+/*
+ * Set up BM-DMA capability (PnP BIOS should have done this)
+ */
+static int ide_pci_set_master(struct pci_dev *dev, const char *name)
+{
+	u16 pcicmd;
+
+	pci_read_config_word(dev, PCI_COMMAND, &pcicmd);
+
+	if ((pcicmd & PCI_COMMAND_MASTER) == 0) {
+		pci_set_master(dev);
+
+		if (pci_read_config_word(dev, PCI_COMMAND, &pcicmd) ||
+		    (pcicmd & PCI_COMMAND_MASTER) == 0) {
+			printk(KERN_ERR "%s: error updating PCICMD on %s\n",
+					name, pci_name(dev));
+			return -EIO;
+		}
+	}
+
+	return 0;
+}
 #endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
 
 void ide_setup_pci_noise(struct pci_dev *dev, const struct ide_port_info *d)
@@ -340,36 +363,26 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev,
 void ide_hwif_setup_dma(ide_hwif_t *hwif, const struct ide_port_info *d)
 {
 	struct pci_dev *dev = to_pci_dev(hwif->dev);
-	u16 pcicmd;
-
-	pci_read_config_word(dev, PCI_COMMAND, &pcicmd);
 
 	if ((d->host_flags & IDE_HFLAG_NO_AUTODMA) == 0 ||
 	    ((dev->class >> 8) == PCI_CLASS_STORAGE_IDE &&
 	     (dev->class & 0x80))) {
 		unsigned long dma_base = ide_get_or_set_dma_base(d, hwif);
-		if (dma_base && !(pcicmd & PCI_COMMAND_MASTER)) {
-			/*
-			 * Set up BM-DMA capability
-			 * (PnP BIOS should have done this)
-			 */
-			pci_set_master(dev);
-			if (pci_read_config_word(dev, PCI_COMMAND, &pcicmd) || !(pcicmd & PCI_COMMAND_MASTER)) {
-				printk(KERN_ERR "%s: %s error updating PCICMD\n",
-					hwif->name, d->name);
-				dma_base = 0;
-			}
-		}
-		if (dma_base) {
-			if (d->init_dma)
-				d->init_dma(hwif, dma_base);
-
-			ide_setup_dma(hwif, dma_base);
-		} else {
-			printk(KERN_INFO "%s: %s Bus-Master DMA disabled "
-				"(BIOS)\n", hwif->name, d->name);
-		}
+
+		if (dma_base == 0 || ide_pci_set_master(dev, d->name) < 0)
+			goto out_disabled;
+
+		if (d->init_dma)
+			d->init_dma(hwif, dma_base);
+
+		ide_setup_dma(hwif, dma_base);
 	}
+
+	return;
+
+out_disabled:
+	printk(KERN_INFO "%s: Bus-Master DMA disabled (BIOS) on %s\n",
+			 d->name, pci_name(dev));
 }
 #endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
 

commit 23658f8af3dbba53ae9796e4c37c2fdd0272662e
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 22:25:21 2008 +0200

    ide: move ide_setup_dma() call out from ->init_dma method
    
    There should be no functional changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 26997648bf00..f8fc9727da07 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -361,11 +361,10 @@ void ide_hwif_setup_dma(ide_hwif_t *hwif, const struct ide_port_info *d)
 			}
 		}
 		if (dma_base) {
-			if (d->init_dma) {
+			if (d->init_dma)
 				d->init_dma(hwif, dma_base);
-			} else {
-				ide_setup_dma(hwif, dma_base);
-			}
+
+			ide_setup_dma(hwif, dma_base);
 		} else {
 			printk(KERN_INFO "%s: %s Bus-Master DMA disabled "
 				"(BIOS)\n", hwif->name, d->name);

commit 5e59c236846df444860ffc8b852117f9ff65c101
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 22:25:20 2008 +0200

    ide: remove ->cds field from ide_hwif_t (take 2)
    
    * Use hwif->name instead of cds->name in ide_allocate_dma_engine().
    
    * Use pci_name(dev) instead of cds->name in init_dma_pdc202xx().
    
    * Remove no longer needed ->cds field from ide_hwif_t.
    
    v2:
    
    * scc_pata.c also needs to be updated now (noticed by Stephen Rothwell).
    
    There should be no functional changes caused by this patch.
    
    Cc: Kou Ishizaki <kou.ishizaki@toshiba.co.jp>
    Cc: Akira Iguchi <akira2.iguchi@toshiba.co.jp>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 8812eaa7f169..26997648bf00 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -322,7 +322,6 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev,
 	ide_init_port_hw(hwif, &hw);
 
 	hwif->dev = &dev->dev;
-	hwif->cds = d;
 
 	return hwif;
 }

commit 0d1bad216c43bcee84cc24d1ed003c19134d2645
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 22:25:19 2008 +0200

    ide: manage resources for PCI devices in ide_pci_enable() (take 3)
    
    * Reserve PCI BARs 0-3 (0-1 for single port controllers) in
      ide_pci_enable() and remove ide_hwif_request_regions() call
      from ide_device_add_all() (also cleanup resource management
      in scc_pata host driver).
    
    * Fix handling of PCI BAR 4 in ide_pci_enable(), then cleanup
      ide_iomio_dma() (+ init_hwif_trm290() in trm290 host driver)
      and remove ide_release[_iomio]_dma().
    
    v2:
    * Fixup trm290 host driver.
    
    v3:
    * Because of scc_pata host driver changes we need to call
      pci_request_selected_regions() also in setup_mmio_scc().
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 6302010fd8e2..8812eaa7f169 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -158,7 +158,7 @@ EXPORT_SYMBOL_GPL(ide_setup_pci_noise);
 
 static int ide_pci_enable(struct pci_dev *dev, const struct ide_port_info *d)
 {
-	int ret;
+	int ret, bars;
 
 	if (pci_enable_device(dev)) {
 		ret = pci_enable_device_io(dev);
@@ -181,13 +181,21 @@ static int ide_pci_enable(struct pci_dev *dev, const struct ide_port_info *d)
 		goto out;
 	}
 
-	/* FIXME: Temporary - until we put in the hotplug interface logic
-	   Check that the bits we want are not in use by someone else. */
-	ret = pci_request_region(dev, 4, "ide_tmp");
-	if (ret < 0)
-		goto out;
+	if (d->host_flags & IDE_HFLAG_SINGLE)
+		bars = (1 << 2) - 1;
+	else
+		bars = (1 << 4) - 1;
 
-	pci_release_region(dev, 4);
+	if ((d->host_flags & IDE_HFLAG_NO_DMA) == 0) {
+		if (d->host_flags & IDE_HFLAG_CS5520)
+			bars |= (1 << 2);
+		else
+			bars |= (1 << 4);
+	}
+
+	ret = pci_request_selected_regions(dev, bars, d->name);
+	if (ret < 0)
+		printk(KERN_ERR "%s: can't reserve resources\n", d->name);
 out:
 	return ret;
 }

commit 846bb88ae8980b98b11e0298c7ab8cfc9539c3f6
Author: Paolo Ciarrocchi <paolo.ciarrocchi@gmail.com>
Date:   Sat Apr 26 17:36:39 2008 +0200

    IDE: Coding Style fixes to drivers/ide/setup-pci.c
    
    File is now error free.
    Compile tested.
    
    [bart: minor fixes, md5sum checked]
    
    Signed-off-by: Paolo Ciarrocchi <paolo.ciarrocchi@gmail.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 699c72947967..6302010fd8e2 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -27,13 +27,13 @@
  *
  *	We attempt to place the PCI interface into PCI native mode. If
  *	we succeed the BARs are ok and the controller is in PCI mode.
- *	Returns 0 on success or an errno code. 
+ *	Returns 0 on success or an errno code.
  *
  *	FIXME: if we program the interface and then fail to set the BARS
  *	we don't switch it back to legacy mode. Do we actually care ??
  */
- 
-static int ide_setup_pci_baseregs (struct pci_dev *dev, const char *name)
+
+static int ide_setup_pci_baseregs(struct pci_dev *dev, const char *name)
 {
 	u8 progif = 0;
 
@@ -140,7 +140,6 @@ void ide_setup_pci_noise(struct pci_dev *dev, const struct ide_port_info *d)
 			 " PCI slot %s\n", d->name, dev->vendor, dev->device,
 			 dev->revision, pci_name(dev));
 }
-
 EXPORT_SYMBOL_GPL(ide_setup_pci_noise);
 
 
@@ -153,7 +152,7 @@ EXPORT_SYMBOL_GPL(ide_setup_pci_noise);
  *	but if that fails then we only need IO space. The PCI code should
  *	have setup the proper resources for us already for controllers in
  *	legacy mode.
- *	
+ *
  *	Returns zero on success or an error code
  */
 
@@ -212,8 +211,8 @@ static int ide_pci_configure(struct pci_dev *dev, const struct ide_port_info *d)
 	 * Maybe the user deliberately *disabled* the device,
 	 * but we'll eventually ignore it again if no drives respond.
 	 */
-	if (ide_setup_pci_baseregs(dev, d->name) || pci_write_config_word(dev, PCI_COMMAND, pcicmd|PCI_COMMAND_IO)) 
-	{
+	if (ide_setup_pci_baseregs(dev, d->name) ||
+	    pci_write_config_word(dev, PCI_COMMAND, pcicmd | PCI_COMMAND_IO)) {
 		printk(KERN_INFO "%s: device disabled (BIOS)\n", d->name);
 		return -ENODEV;
 	}
@@ -242,7 +241,7 @@ static int ide_pci_check_iomem(struct pci_dev *dev, const struct ide_port_info *
 			       int bar)
 {
 	ulong flags = pci_resource_flags(dev, bar);
-	
+
 	/* Unconfigured ? */
 	if (!flags || pci_resource_len(dev, bar) == 0)
 		return 0;
@@ -250,7 +249,7 @@ static int ide_pci_check_iomem(struct pci_dev *dev, const struct ide_port_info *
 	/* I/O space */
 	if (flags & IORESOURCE_IO)
 		return 0;
-		
+
 	/* Bad */
 	return -EINVAL;
 }
@@ -284,7 +283,7 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev,
 					"as MEM for port %d!\n", d->name, port);
 			return NULL;
 		}
- 
+
 		ctl  = pci_resource_start(dev, 2*port+1);
 		base = pci_resource_start(dev, 2*port);
 		if ((ctl && !base) || (base && !ctl)) {
@@ -293,8 +292,7 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev,
 			return NULL;
 		}
 	}
-	if (!ctl)
-	{
+	if (!ctl) {
 		/* Use default values */
 		ctl = port ? 0x374 : 0x3f4;
 		base = port ? 0x170 : 0x1f0;
@@ -345,9 +343,9 @@ void ide_hwif_setup_dma(ide_hwif_t *hwif, const struct ide_port_info *d)
 		unsigned long dma_base = ide_get_or_set_dma_base(d, hwif);
 		if (dma_base && !(pcicmd & PCI_COMMAND_MASTER)) {
 			/*
- 			 * Set up BM-DMA capability
+			 * Set up BM-DMA capability
 			 * (PnP BIOS should have done this)
- 			 */
+			 */
 			pci_set_master(dev);
 			if (pci_read_config_word(dev, PCI_COMMAND, &pcicmd) || !(pcicmd & PCI_COMMAND_MASTER)) {
 				printk(KERN_ERR "%s: %s error updating PCICMD\n",
@@ -452,7 +450,6 @@ void ide_pci_setup_ports(struct pci_dev *dev, const struct ide_port_info *d, int
 		*(idx + port) = hwif->index;
 	}
 }
-
 EXPORT_SYMBOL_GPL(ide_pci_setup_ports);
 
 /*
@@ -535,7 +532,6 @@ int ide_setup_pci_device(struct pci_dev *dev, const struct ide_port_info *d)
 
 	return ret;
 }
-
 EXPORT_SYMBOL_GPL(ide_setup_pci_device);
 
 int ide_setup_pci_devices(struct pci_dev *dev1, struct pci_dev *dev2,
@@ -559,5 +555,4 @@ int ide_setup_pci_devices(struct pci_dev *dev1, struct pci_dev *dev2,
 out:
 	return ret;
 }
-
 EXPORT_SYMBOL_GPL(ide_setup_pci_devices);

commit fe80b937c9917887e4fbfaaf52f498b5ac3a6999
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 17:36:36 2008 +0200

    ide: merge ide_match_hwif() and ide_find_port()
    
    * Change ide_match_hwif() argument from 'u8 bootable' to
      'struct ide_port_info *d'.
    
    * Move ide_match_hwif() to ide-probe.c from setup-pci.c and rename
      it to ide_find_port_slot().  Update some comments while at it.
    
    * ide_find_port() can be now just a wrapper for ide_find_port_slot().
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 8947597e6bec..699c72947967 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -20,51 +20,6 @@
 #include <asm/io.h>
 #include <asm/irq.h>
 
-
-/**
- *	ide_match_hwif	-	find free ide_hwifs[] slot
- *	@bootable: bootable flag
- *
- *	Return the new hwif.  If we are out of free slots return NULL.
- */
-
-static ide_hwif_t *ide_match_hwif(u8 bootable)
-{
-	ide_hwif_t *hwif;
-	int h;
-
-	/*
-	 * Claim an unassigned slot.
-	 *
-	 * Give preference to claiming other slots before claiming ide0/ide1,
-	 * just in case there's another interface yet-to-be-scanned
-	 * which uses ports 1f0/170 (the ide0/ide1 defaults).
-	 *
-	 * Unless there is a bootable card that does not use the standard
-	 * ports 1f0/170 (the ide0/ide1 defaults). The (bootable) flag.
-	 */
-	if (bootable) {
-		for (h = 0; h < MAX_HWIFS; ++h) {
-			hwif = &ide_hwifs[h];
-			if (hwif->chipset == ide_unknown)
-				return hwif;	/* pick an unused entry */
-		}
-	} else {
-		for (h = 2; h < MAX_HWIFS; ++h) {
-			hwif = ide_hwifs + h;
-			if (hwif->chipset == ide_unknown)
-				return hwif;	/* pick an unused entry */
-		}
-	}
-	for (h = 0; h < 2 && h < MAX_HWIFS; ++h) {
-		hwif = ide_hwifs + h;
-		if (hwif->chipset == ide_unknown)
-			return hwif;	/* pick an unused entry */
-	}
-
-	return NULL;
-}
-
 /**
  *	ide_setup_pci_baseregs	-	place a PCI IDE controller native
  *	@dev: PCI device of interface to switch native
@@ -320,7 +275,6 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev,
 {
 	unsigned long ctl = 0, base = 0;
 	ide_hwif_t *hwif;
-	u8 bootable = (d->host_flags & IDE_HFLAG_NON_BOOTABLE) ? 0 : 1;
 	struct hw_regs_s hw;
 
 	if ((d->host_flags & IDE_HFLAG_ISA_PORTS) == 0) {
@@ -346,7 +300,7 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev,
 		base = port ? 0x170 : 0x1f0;
 	}
 
-	hwif = ide_match_hwif(bootable);
+	hwif = ide_find_port_slot(d);
 	if (hwif == NULL) {
 		printk(KERN_ERR "%s: too many IDE interfaces, no room in "
 				"table\n", d->name);

commit 5e71d9c5a50b92b33d35061d42ac39166db9578e
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 17:36:35 2008 +0200

    ide: IDE_HFLAG_BOOTABLE -> IDE_HFLAG_NON_BOOTABLE
    
    "bootable" should be the default behavior so replace
    IDE_HFLAG_BOOTABLE host flag with IDE_HFLAG_NON_BOOTABLE.
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 7347faf8bc41..8947597e6bec 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -320,7 +320,7 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev,
 {
 	unsigned long ctl = 0, base = 0;
 	ide_hwif_t *hwif;
-	u8 bootable = (d->host_flags & IDE_HFLAG_BOOTABLE) ? 1 : 0;
+	u8 bootable = (d->host_flags & IDE_HFLAG_NON_BOOTABLE) ? 0 : 1;
 	struct hw_regs_s hw;
 
 	if ((d->host_flags & IDE_HFLAG_ISA_PORTS) == 0) {

commit bad7c825cb27377faf1c926953aa15c980c62620
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 17:36:31 2008 +0200

    ide: cleanup ide_match_hwif()
    
    * Remove no longer needed matching against I/O base and 'io_base' argument.
    
    * Move printk() to the caller and remove 'name' argument.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 2dc3835478ec..7347faf8bc41 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -22,42 +22,20 @@
 
 
 /**
- *	ide_match_hwif	-	match a PCI IDE against an ide_hwif
- *	@io_base: I/O base of device
- *	@bootable: set if its bootable
- *	@name: name of device
+ *	ide_match_hwif	-	find free ide_hwifs[] slot
+ *	@bootable: bootable flag
  *
- *	Match a PCI IDE port against an entry in ide_hwifs[],
- *	based on io_base port if possible. Return the matching hwif,
- *	or a new hwif. If we find an error (clashing, out of devices, etc)
- *	return NULL
- *
- *	FIXME: we need to handle mmio matches here too
+ *	Return the new hwif.  If we are out of free slots return NULL.
  */
 
-static ide_hwif_t *ide_match_hwif(unsigned long io_base, u8 bootable, const char *name)
+static ide_hwif_t *ide_match_hwif(u8 bootable)
 {
-	int h;
 	ide_hwif_t *hwif;
+	int h;
 
 	/*
-	 * Look for a hwif with matching io_base default value.
-	 * If chipset is "ide_unknown", then claim that hwif slot.
-	 * Otherwise, some other chipset has already claimed it..  :(
-	 */
-	for (h = 0; h < MAX_HWIFS; ++h) {
-		hwif = &ide_hwifs[h];
-		if (hwif->io_ports[IDE_DATA_OFFSET] == io_base) {
-			if (hwif->chipset == ide_unknown)
-				return hwif; /* match */
-			printk(KERN_ERR "%s: port 0x%04lx already claimed by %s\n",
-				name, io_base, hwif->name);
-			return NULL;	/* already claimed */
-		}
-	}
-	/*
-	 * Okay, there is no hwif matching our io_base,
-	 * so we'll just claim an unassigned slot.
+	 * Claim an unassigned slot.
+	 *
 	 * Give preference to claiming other slots before claiming ide0/ide1,
 	 * just in case there's another interface yet-to-be-scanned
 	 * which uses ports 1f0/170 (the ide0/ide1 defaults).
@@ -83,7 +61,7 @@ static ide_hwif_t *ide_match_hwif(unsigned long io_base, u8 bootable, const char
 		if (hwif->chipset == ide_unknown)
 			return hwif;	/* pick an unused entry */
 	}
-	printk(KERN_ERR "%s: too many IDE interfaces, no room in table\n", name);
+
 	return NULL;
 }
 
@@ -367,8 +345,13 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev,
 		ctl = port ? 0x374 : 0x3f4;
 		base = port ? 0x170 : 0x1f0;
 	}
-	if ((hwif = ide_match_hwif(base, bootable, d->name)) == NULL)
-		return NULL;	/* no room in ide_hwifs[] */
+
+	hwif = ide_match_hwif(bootable);
+	if (hwif == NULL) {
+		printk(KERN_ERR "%s: too many IDE interfaces, no room in "
+				"table\n", d->name);
+		return NULL;
+	}
 
 	memset(&hw, 0, sizeof(hw));
 	hw.irq = irq;

commit 1baccff8a5823b51d7bf2740ef3ef17e06bfa7e2
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Sat Apr 26 17:36:31 2008 +0200

    ide: make ide_pci_check_iomem() actually work
    
    This function didn't actually check if a given BAR is in I/O space because of
    using the bogus PCI_BASE_ADDRESS_IO_MASK (which equals ~3) to test the resource
    flags instead of IORESOURCE_IO -- fix this, make ide_hwif_configure() check the
    results failing if necessary, and move the printk() call to the failure path.
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index f7ede0e42881..2dc3835478ec 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -301,11 +301,12 @@ static int ide_pci_configure(struct pci_dev *dev, const struct ide_port_info *d)
  *	@d: IDE port info
  *	@bar: BAR number
  *
- *	Checks if a BAR is configured and points to MMIO space. If so
- *	print an error and return an error code. Otherwise return 0
+ *	Checks if a BAR is configured and points to MMIO space. If so,
+ *	return an error code. Otherwise return 0
  */
 
-static int ide_pci_check_iomem(struct pci_dev *dev, const struct ide_port_info *d, int bar)
+static int ide_pci_check_iomem(struct pci_dev *dev, const struct ide_port_info *d,
+			       int bar)
 {
 	ulong flags = pci_resource_flags(dev, bar);
 	
@@ -313,14 +314,11 @@ static int ide_pci_check_iomem(struct pci_dev *dev, const struct ide_port_info *
 	if (!flags || pci_resource_len(dev, bar) == 0)
 		return 0;
 
-	/* I/O space */		
-	if(flags & PCI_BASE_ADDRESS_IO_MASK)
+	/* I/O space */
+	if (flags & IORESOURCE_IO)
 		return 0;
 		
 	/* Bad */
-	printk(KERN_ERR "%s: IO baseregs (BIOS) are reported "
-			"as MEM, report to "
-			"<andre@linux-ide.org>.\n", d->name);
 	return -EINVAL;
 }
 
@@ -348,9 +346,12 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev,
 	struct hw_regs_s hw;
 
 	if ((d->host_flags & IDE_HFLAG_ISA_PORTS) == 0) {
-		/*  Possibly we should fail if these checks report true */
-		ide_pci_check_iomem(dev, d, 2*port);
-		ide_pci_check_iomem(dev, d, 2*port+1);
+		if (ide_pci_check_iomem(dev, d, 2 * port) ||
+		    ide_pci_check_iomem(dev, d, 2 * port + 1)) {
+			printk(KERN_ERR "%s: I/O baseregs (BIOS) are reported "
+					"as MEM for port %d!\n", d->name, port);
+			return NULL;
+		}
  
 		ctl  = pci_resource_start(dev, 2*port+1);
 		base = pci_resource_start(dev, 2*port);

commit f01674e459923c6df540e6c983d37e5fc94d43b8
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Apr 18 00:46:35 2008 +0200

    ide: remove obsoleted "idex=noprobe" kernel parameter (take 2)
    
    * Remove obsoleted "idex=noprobe" kernel parameter.
    
    * Remove no longer needed hwif->noprobe quirk from ide_hwif_configure()
      and hwif->noprobe checking from cmd640.c.
    
    v2:
    * "ide?=noprobe" -> "ide?=ata66" in Documentation/kernel-parameters.txt.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index ee4a34b49062..f7ede0e42881 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -345,7 +345,6 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev,
 	unsigned long ctl = 0, base = 0;
 	ide_hwif_t *hwif;
 	u8 bootable = (d->host_flags & IDE_HFLAG_BOOTABLE) ? 1 : 0;
-	u8 oldnoprobe = 0;
 	struct hw_regs_s hw;
 
 	if ((d->host_flags & IDE_HFLAG_ISA_PORTS) == 0) {
@@ -376,14 +375,8 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev,
 	hw.chipset = d->chipset ? d->chipset : ide_pci;
 	ide_std_init_ports(&hw, base, ctl | 2);
 
-	if (hwif->io_ports[IDE_DATA_OFFSET] == base &&
-	    hwif->io_ports[IDE_CONTROL_OFFSET] == (ctl | 2))
-		oldnoprobe = hwif->noprobe;
-
 	ide_init_port_hw(hwif, &hw);
 
-	hwif->noprobe = oldnoprobe;
-
 	hwif->dev = &dev->dev;
 	hwif->cds = d;
 

commit aab8ad9ec81255ee08825bed36b57484052b94ea
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Apr 18 00:46:35 2008 +0200

    ide: remove needless hwif->irq check from ide_hwif_configure()
    
    ide_init_default_irq() is always zero for CONFIG_PCI=y so hwif->irq
    check in ide_hwif_configure() can be safely removed.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index ea66c996e4ec..ee4a34b49062 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -371,7 +371,7 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev,
 		return NULL;	/* no room in ide_hwifs[] */
 
 	memset(&hw, 0, sizeof(hw));
-	hw.irq = hwif->irq ? hwif->irq : irq;
+	hw.irq = irq;
 	hw.dev = &dev->dev;
 	hw.chipset = d->chipset ? d->chipset : ide_pci;
 	ide_std_init_ports(&hw, base, ctl | 2);

commit 9a0e77f28b50128df0c9e26ae489e44e29a7270a
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Apr 18 00:46:24 2008 +0200

    ide: remove obsoleted "idex=base[,ctl[,irq]]" kernel parameters (take 2)
    
    * Remove obsoleted "idex=base[,ctl[,irq]]" kernel parameters
      and update Documentation/ide/ide.txt.
    
    * Remove no longer needed ide_forced chipset type.
    
    v2:
    * is_chipset_set[] -> is_chipset_set in ide.c.
    
    * Documentation/ide/ide.txt fix.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 634e3f6a9608..ea66c996e4ec 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -40,17 +40,6 @@ static ide_hwif_t *ide_match_hwif(unsigned long io_base, u8 bootable, const char
 	int h;
 	ide_hwif_t *hwif;
 
-	/*
-	 * Look for a hwif with matching io_base specified using
-	 * parameters to ide_setup().
-	 */
-	for (h = 0; h < MAX_HWIFS; ++h) {
-		hwif = &ide_hwifs[h];
-		if (hwif->io_ports[IDE_DATA_OFFSET] == io_base) {
-			if (hwif->chipset == ide_forced)
-				return hwif; /* a perfect match */
-		}
-	}
 	/*
 	 * Look for a hwif with matching io_base default value.
 	 * If chipset is "ide_unknown", then claim that hwif slot.

commit c413b9b94d9a8e7548cc4b2e04b7df0439ce76fd
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Feb 2 19:56:31 2008 +0100

    ide: add struct ide_port_info instances to legacy host drivers
    
    * Remove 'struct pci_dev *dev' argument from ide_hwif_setup_dma().
    
    * Un-static ide_hwif_setup_dma() and add CONFIG_BLK_DEV_IDEDMA_PCI=n version.
    
    * Add 'const struct ide_port_info *d' argument to ide_device_add[_all]().
    
    * Factor out generic ports init from ide_pci_setup_ports() to ide_init_port(),
      move it to ide-probe.c and call it in in ide_device_add_all() instead of
      ide_pci_setup_ports().
    
    * Move ->mate setup to ide_device_add_all() from ide_port_init().
    
    * Add IDE_HFLAG_NO_AUTOTUNE host flag for host drivers that don't enable
      ->autotune currently.
    
    * Setup hwif->chipset in ide_init_port() but iff pi->chipset is set
      (to not override setup done by ide_hwif_configure()).
    
    * Add ETRAX host handling to ide_device_add_all().
    
    * cmd640.c: set IDE_HFLAG_ABUSE_* also for CONFIG_BLK_DEV_CMD640_ENHANCED=n.
    
    * pmac.c: make pmac_ide_setup_dma() return an error value and move DMA masks
      setup to pmac_ide_setup_device().
    
    * Add 'struct ide_port_info' instances to legacy host drivers, pass them to
      ide_device_add() calls and then remove open-coded ports initialization.
    
    Reviewed-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 53d9979edc72..634e3f6a9608 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -401,20 +401,20 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev,
 	return hwif;
 }
 
+#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
 /**
  *	ide_hwif_setup_dma	-	configure DMA interface
- *	@dev: PCI device
- *	@d: IDE port info
  *	@hwif: IDE interface
+ *	@d: IDE port info
  *
  *	Set up the DMA base for the interface. Enable the master bits as
  *	necessary and attempt to bring the device DMA into a ready to use
  *	state
  */
 
-static void ide_hwif_setup_dma(struct pci_dev *dev, const struct ide_port_info *d, ide_hwif_t *hwif)
+void ide_hwif_setup_dma(ide_hwif_t *hwif, const struct ide_port_info *d)
 {
-#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
+	struct pci_dev *dev = to_pci_dev(hwif->dev);
 	u16 pcicmd;
 
 	pci_read_config_word(dev, PCI_COMMAND, &pcicmd);
@@ -446,8 +446,8 @@ static void ide_hwif_setup_dma(struct pci_dev *dev, const struct ide_port_info *
 				"(BIOS)\n", hwif->name, d->name);
 		}
 	}
-#endif /* CONFIG_BLK_DEV_IDEDMA_PCI*/
 }
+#endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
 
 /**
  *	ide_setup_pci_controller	-	set up IDE PCI
@@ -509,7 +509,7 @@ static int ide_setup_pci_controller(struct pci_dev *dev, const struct ide_port_i
 void ide_pci_setup_ports(struct pci_dev *dev, const struct ide_port_info *d, int pciirq, u8 *idx)
 {
 	int channels = (d->host_flags & IDE_HFLAG_SINGLE) ? 1 : 2, port;
-	ide_hwif_t *hwif, *mate = NULL;
+	ide_hwif_t *hwif;
 	u8 tmp;
 
 	/*
@@ -531,71 +531,6 @@ void ide_pci_setup_ports(struct pci_dev *dev, const struct ide_port_info *d, int
 
 		*(idx + port) = hwif->index;
 	}
-
-	for (port = 0; port < channels; ++port) {
-		if (*(idx + port) == 0xff)
-			continue;
-
-		hwif = &ide_hwifs[*(idx + port)];
-
-		if (mate) {
-			hwif->mate = mate;
-			mate->mate = hwif;
-		}
-
-		hwif->channel = port;
-
-		if (d->init_iops)
-			d->init_iops(hwif);
-
-		if ((d->host_flags & IDE_HFLAG_NO_DMA) == 0)
-			ide_hwif_setup_dma(dev, d, hwif);
-
-		if ((!hwif->irq && (d->host_flags & IDE_HFLAG_LEGACY_IRQS)) ||
-		    (d->host_flags & IDE_HFLAG_FORCE_LEGACY_IRQS))
-			hwif->irq = port ? 15 : 14;
-
-		hwif->host_flags = d->host_flags;
-		hwif->pio_mask = d->pio_mask;
-
-		if ((d->host_flags & IDE_HFLAG_SERIALIZE) && hwif->mate)
-			hwif->mate->serialized = hwif->serialized = 1;
-
-		if (d->host_flags & IDE_HFLAG_IO_32BIT) {
-			hwif->drives[0].io_32bit = 1;
-			hwif->drives[1].io_32bit = 1;
-		}
-
-		if (d->host_flags & IDE_HFLAG_UNMASK_IRQS) {
-			hwif->drives[0].unmask = 1;
-			hwif->drives[1].unmask = 1;
-		}
-
-		hwif->swdma_mask = d->swdma_mask;
-		hwif->mwdma_mask = d->mwdma_mask;
-		hwif->ultra_mask = d->udma_mask;
-
-		if ((d->host_flags && IDE_HFLAG_NO_DMA) == 0 &&
-		    hwif->dma_base == 0) {
-			hwif->swdma_mask = 0;
-			hwif->mwdma_mask = 0;
-			hwif->ultra_mask = 0;
-		}
-
-		hwif->drives[0].autotune = 1;
-		hwif->drives[1].autotune = 1;
-
-		if (d->host_flags & IDE_HFLAG_RQSIZE_256)
-			hwif->rqsize = 256;
-
-		if (d->init_hwif)
-			/* Call chipset-specific routine
-			 * for each enabled hwif
-			 */
-			d->init_hwif(hwif);
-
-		mate = hwif;
-	}
 }
 
 EXPORT_SYMBOL_GPL(ide_pci_setup_ports);
@@ -676,7 +611,7 @@ int ide_setup_pci_device(struct pci_dev *dev, const struct ide_port_info *d)
 	ret = do_ide_setup_pci_device(dev, d, &idx[0], 1);
 
 	if (ret >= 0)
-		ide_device_add(idx);
+		ide_device_add(idx, d);
 
 	return ret;
 }
@@ -700,7 +635,7 @@ int ide_setup_pci_devices(struct pci_dev *dev1, struct pci_dev *dev2,
 			goto out;
 	}
 
-	ide_device_add(idx);
+	ide_device_add(idx, d);
 out:
 	return ret;
 }

commit 1ebf74936b1fccb5b65940f99ccddd74ec4d1fef
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Feb 2 19:56:30 2008 +0100

    ide: separate PCI specific init from generic init in ide_pci_setup_ports()
    
    * Setup ->mate and ->channel in ide_pci_setup_ports() instead of
      in ide_hwif_configure().
    
    * Make 'port' parameter for ide_hwif_configure() 'unsigned int'.
    
    * Separate PCI specific init from generic init in ide_pci_setup_ports().
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index acef85d1c581..53d9979edc72 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -339,7 +339,8 @@ static int ide_pci_check_iomem(struct pci_dev *dev, const struct ide_port_info *
  *	ide_hwif_configure	-	configure an IDE interface
  *	@dev: PCI device holding interface
  *	@d: IDE port info
- *	@mate: Paired interface if any
+ *	@port: port number
+ *	@irq: PCI IRQ
  *
  *	Perform the initial set up for the hardware interface structure. This
  *	is done per interface port rather than per PCI device. There may be
@@ -348,7 +349,9 @@ static int ide_pci_check_iomem(struct pci_dev *dev, const struct ide_port_info *
  *	Returns the new hardware interface structure, or NULL on a failure
  */
 
-static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev, const struct ide_port_info *d, ide_hwif_t *mate, int port, int irq)
+static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev,
+				      const struct ide_port_info *d,
+				      unsigned int port, int irq)
 {
 	unsigned long ctl = 0, base = 0;
 	ide_hwif_t *hwif;
@@ -394,12 +397,7 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev, const struct ide_port
 
 	hwif->dev = &dev->dev;
 	hwif->cds = d;
-	hwif->channel = port;
 
-	if (mate) {
-		hwif->mate = mate;
-		mate->mate = hwif;
-	}
 	return hwif;
 }
 
@@ -527,10 +525,25 @@ void ide_pci_setup_ports(struct pci_dev *dev, const struct ide_port_info *d, int
 			continue;	/* port not enabled */
 		}
 
-		if ((hwif = ide_hwif_configure(dev, d, mate, port, pciirq)) == NULL)
+		hwif = ide_hwif_configure(dev, d, port, pciirq);
+		if (hwif == NULL)
 			continue;
 
 		*(idx + port) = hwif->index;
+	}
+
+	for (port = 0; port < channels; ++port) {
+		if (*(idx + port) == 0xff)
+			continue;
+
+		hwif = &ide_hwifs[*(idx + port)];
+
+		if (mate) {
+			hwif->mate = mate;
+			mate->mate = hwif;
+		}
+
+		hwif->channel = port;
 
 		if (d->init_iops)
 			d->init_iops(hwif);

commit bf77c5317168eb73894bcc9a455429c4589a179d
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Feb 2 19:56:30 2008 +0100

    ide: always set DMA masks in ide_pci_setup_ports()
    
    Always set DMA masks in ide_pci_setup_ports() to make sure that the valid
    masks for a host are set.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 05db429a7da8..acef85d1c581 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -558,10 +558,15 @@ void ide_pci_setup_ports(struct pci_dev *dev, const struct ide_port_info *d, int
 			hwif->drives[1].unmask = 1;
 		}
 
-		if (hwif->dma_base) {
-			hwif->swdma_mask = d->swdma_mask;
-			hwif->mwdma_mask = d->mwdma_mask;
-			hwif->ultra_mask = d->udma_mask;
+		hwif->swdma_mask = d->swdma_mask;
+		hwif->mwdma_mask = d->mwdma_mask;
+		hwif->ultra_mask = d->udma_mask;
+
+		if ((d->host_flags && IDE_HFLAG_NO_DMA) == 0 &&
+		    hwif->dma_base == 0) {
+			hwif->swdma_mask = 0;
+			hwif->mwdma_mask = 0;
+			hwif->ultra_mask = 0;
 		}
 
 		hwif->drives[0].autotune = 1;

commit 215e871aaa3d94540121a3809d80d0c5e5686e4f
Merge: b6cf160c4b78 fd7d1ced29e5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Feb 2 14:29:33 2008 +1100

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/pci-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/pci-2.6: (64 commits)
      PCI: make pci_bus a struct device
      PCI: fix codingstyle issues in include/linux/pci.h
      PCI: fix codingstyle issues in drivers/pci/pci.h
      PCI: PCIE ASPM support
      PCI: Fix fakephp deadlock
      PCI: modify SB700 SATA MSI quirk
      PCI: Run ACPI _OSC method on root bridges only
      PCI ACPI: AER driver should only register PCIe devices with _OSC
      PCI ACPI: Added a function to register _OSC with only PCIe devices.
      PCI: constify function pointer tables
      PCI: Convert drivers/pci/proc.c to use unlocked_ioctl
      pciehp: block new requests from the device before power off
      pciehp: workaround against Bad DLLP during power off
      pciehp: wait for 1000ms before LED operation after power off
      PCI: Remove pci_enable_device_bars() from documentation
      PCI: Remove pci_enable_device_bars()
      PCI: Remove users of pci_enable_device_bars()
      PCI: Add pci_enable_device_{io,mem} intefaces
      PCI: avoid save the same type of cap multiple times
      PCI: correctly initialize a structure for pcie_save_pcix_state()
      ...

commit 0948391641918b95d8d96c15089eb5ac156850b3
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Thu Dec 20 15:28:09 2007 +1100

    PCI: Remove users of pci_enable_device_bars()
    
    This patch converts users of pci_enable_device_bars() to the new
    pci_enable_device_{io,mem} interface.
    
    The new API fits nicely, except maybe for the QLA case where a bit of
    code re-organization might be a good idea but I prefer sticking to the
    simple patch as I don't have hardware to test on.
    
    I'll also need some feedback on the cs5520 change.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 676c66e72881..cf79470a932d 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -240,7 +240,9 @@ EXPORT_SYMBOL_GPL(ide_setup_pci_noise);
  *	@d: IDE port info
  *
  *	Enable the IDE PCI device. We attempt to enable the device in full
- *	but if that fails then we only need BAR4 so we will enable that.
+ *	but if that fails then we only need IO space. The PCI code should
+ *	have setup the proper resources for us already for controllers in
+ *	legacy mode.
  *	
  *	Returns zero on success or an error code
  */
@@ -250,7 +252,7 @@ static int ide_pci_enable(struct pci_dev *dev, const struct ide_port_info *d)
 	int ret;
 
 	if (pci_enable_device(dev)) {
-		ret = pci_enable_device_bars(dev, 1 << 4);
+		ret = pci_enable_device_io(dev);
 		if (ret < 0) {
 			printk(KERN_WARNING "%s: (ide_setup_pci_device:) "
 				"Could not enable device.\n", d->name);

commit 59bca8cc995428c34d8cdfadfa87c8e3f01c4340
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Feb 1 23:09:33 2008 +0100

    ide: update/add my Copyrights
    
    The last years stuff and a trip down memory lane...
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 0886dcea54ab..8ff5a0ef10ad 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -1,6 +1,7 @@
 /*
- *  Copyright (c) 1998-2000  Andre Hedrick <andre@linux-ide.org>
- *  Copyright (c) 1995-1998  Mark Lord
+ *  Copyright (C) 1998-2000  Andre Hedrick <andre@linux-ide.org>
+ *  Copyright (C) 1995-1998  Mark Lord
+ *  Copyright (C)      2007  Bartlomiej Zolnierkiewicz
  *
  *  May be copied or modified under the terms of the GNU General Public License
  */

commit 58f189fccc72bb8a91de1854e519b47d64fbdbaa
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Feb 1 23:09:33 2008 +0100

    ide: delete filenames/versions from comments
    
    Delete filenames/versions from comments.
    
    I'm leaving decisions about adding DRV_VERSION defines and MODULE_VERSION()-s
    to maintainers of the respective drivers.
    
    While at it:
    
    * Remove unused VERSION define from ide.c.
    
    * Remove unused/stale DRV_VERSION define from au1xxx-ide.c.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 6b41d6c2433e..0886dcea54ab 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -1,9 +1,7 @@
 /*
- *  linux/drivers/ide/setup-pci.c		Version 1.10	2002/08/19
- *
  *  Copyright (c) 1998-2000  Andre Hedrick <andre@linux-ide.org>
- *
  *  Copyright (c) 1995-1998  Mark Lord
+ *
  *  May be copied or modified under the terms of the GNU General Public License
  */
 

commit 36501650ec45b1db308c3b51886044863be2d762
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Feb 1 23:09:31 2008 +0100

    ide: keep pointer to struct device instead of struct pci_dev in ide_hwif_t
    
    Keep pointer to struct device instead of struct pci_dev in ide_hwif_t.
    
    While on it:
    * Use *dev->dma_mask instead of pci_dev->dma_mask in ide_toggle_bounce().
    
    There should be no functionality changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 0a4b3a6857e1..6b41d6c2433e 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -162,8 +162,8 @@ static void ide_pci_clear_simplex(unsigned long dma_base, const char *name)
 
 static unsigned long ide_get_or_set_dma_base(const struct ide_port_info *d, ide_hwif_t *hwif)
 {
-	unsigned long	dma_base = 0;
-	struct pci_dev	*dev = hwif->pci_dev;
+	struct pci_dev *dev = to_pci_dev(hwif->dev);
+	unsigned long dma_base = 0;
 	u8 dma_stat = 0;
 
 	if (hwif->mmio)
@@ -391,7 +391,7 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev, const struct ide_port
 
 	hwif->noprobe = oldnoprobe;
 
-	hwif->pci_dev = dev;
+	hwif->dev = &dev->dev;
 	hwif->cds = d;
 	hwif->channel = port;
 

commit 8ac2b42a45896641ed292deaf038a1d2703d85a6
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Feb 1 23:09:30 2008 +0100

    ide: add IDE_HFLAG_CLEAR_SIMPLEX host flag
    
    * Rename 'simplex_stat' variable to 'dma_stat' in ide_get_or_set_dma_base().
    
    * Factor out code for forcing host out of "simplex" mode from
      ide_get_or_set_dma_base() to ide_pci_clear_simplex() helper.
    
    * Add IDE_HFLAG_CLEAR_SIMPLEX host flag and set it in alim15x3 (for M5229),
      amd74xx (for AMD 7409), cmd64x (for CMD643), generic (for Netcell) and
      serverworks (for CSB5) host drivers.
    
    * Make ide_get_or_set_dma_base() test for IDE_HFLAG_CLEAR_SIMPLEX host flag
      instead of checking dev->device (BTW the code was buggy because it didn't
      check for dev->vendor, luckily none of these PCI Device IDs was used by
      some other vendor for PCI IDE controller).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index c473f45abd33..0a4b3a6857e1 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -140,6 +140,16 @@ static int ide_setup_pci_baseregs (struct pci_dev *dev, const char *name)
 }
 
 #ifdef CONFIG_BLK_DEV_IDEDMA_PCI
+static void ide_pci_clear_simplex(unsigned long dma_base, const char *name)
+{
+	u8 dma_stat = inb(dma_base + 2);
+
+	outb(dma_stat & 0x60, dma_base + 2);
+	dma_stat = inb(dma_base + 2);
+	if (dma_stat & 0x80)
+		printk(KERN_INFO "%s: simplex device: DMA forced\n", name);
+}
+
 /**
  *	ide_get_or_set_dma_base		-	setup BMIBA
  *	@d: IDE port info
@@ -154,6 +164,7 @@ static unsigned long ide_get_or_set_dma_base(const struct ide_port_info *d, ide_
 {
 	unsigned long	dma_base = 0;
 	struct pci_dev	*dev = hwif->pci_dev;
+	u8 dma_stat = 0;
 
 	if (hwif->mmio)
 		return hwif->dma_base;
@@ -174,52 +185,30 @@ static unsigned long ide_get_or_set_dma_base(const struct ide_port_info *d, ide_
 	if (hwif->channel)
 		dma_base += 8;
 
-	if ((d->host_flags & IDE_HFLAG_CS5520) == 0) {
-		u8 simplex_stat = 0;
-
-		switch(dev->device) {
-			case PCI_DEVICE_ID_AL_M5219:
-			case PCI_DEVICE_ID_AL_M5229:
-			case PCI_DEVICE_ID_AMD_VIPER_7409:
-			case PCI_DEVICE_ID_CMD_643:
-			case PCI_DEVICE_ID_SERVERWORKS_CSB5IDE:
-			case PCI_DEVICE_ID_REVOLUTION:
-				simplex_stat = inb(dma_base + 2);
-				outb(simplex_stat & 0x60, dma_base + 2);
-				simplex_stat = inb(dma_base + 2);
-				if (simplex_stat & 0x80) {
-					printk(KERN_INFO "%s: simplex device: "
-							 "DMA forced\n",
-							 d->name);
-				}
-				break;
-			default:
-				/*
-				 * If the device claims "simplex" DMA,
-				 * this means only one of the two interfaces
-				 * can be trusted with DMA at any point in time.
-				 * So we should enable DMA only on one of the
-				 * two interfaces.
-				 */
-				simplex_stat = hwif->INB(dma_base + 2);
-				if (simplex_stat & 0x80) {
-					/* simplex device? */
-/*
- *	At this point we haven't probed the drives so we can't make the
- *	appropriate decision. Really we should defer this problem
- *	until we tune the drive then try to grab DMA ownership if we want
- *	to be the DMA end. This has to be become dynamic to handle hot
- *	plug.
- */
-					if (hwif->mate && hwif->mate->dma_base) {
-						printk(KERN_INFO "%s: simplex device: "
-								 "DMA disabled\n",
-								 d->name);
-						dma_base = 0;
-					}
-				}
-		}
+	if (d->host_flags & IDE_HFLAG_CS5520)
+		goto out;
+
+	if (d->host_flags & IDE_HFLAG_CLEAR_SIMPLEX) {
+		ide_pci_clear_simplex(dma_base, d->name);
+		goto out;
+	}
+
+	/*
+	 * If the device claims "simplex" DMA, this means that only one of
+	 * the two interfaces can be trusted with DMA at any point in time
+	 * (so we should enable DMA only on one of the two interfaces).
+	 *
+	 * FIXME: At this point we haven't probed the drives so we can't make
+	 * the appropriate decision.  Really we should defer this problem until
+	 * we tune the drive then try to grab DMA ownership if we want to be
+	 * the DMA end.  This has to be become dynamic to handle hot-plug.
+	 */
+	dma_stat = hwif->INB(dma_base + 2);
+	if ((dma_stat & 0x80) && hwif->mate && hwif->mate->dma_base) {
+		printk(KERN_INFO "%s: simplex device: DMA disabled\n", d->name);
+		dma_base = 0;
 	}
+out:
 	return dma_base;
 }
 #endif /* CONFIG_BLK_DEV_IDEDMA_PCI */

commit ecf32796395ed0e27667e7f735946d6dc60e1765
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Fri Feb 1 23:09:30 2008 +0100

    ide: ide_setup_dma() assumes 8 ports
    
    According to http://marc.info/?l=linux-ide&m=114346138611631, the drivers must
    always register 8 DMA ports with ide_setup_dma(), so its last argument is not
    needed. While at it, kill some useless parens in that function...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 676c66e72881..c473f45abd33 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -451,7 +451,7 @@ static void ide_hwif_setup_dma(struct pci_dev *dev, const struct ide_port_info *
 			if (d->init_dma) {
 				d->init_dma(hwif, dma_base);
 			} else {
-				ide_setup_dma(hwif, dma_base, 8);
+				ide_setup_dma(hwif, dma_base);
 			}
 		} else {
 			printk(KERN_INFO "%s: %s Bus-Master DMA disabled "

commit 9ac59226ca95889ad620b0e63c0f700679fee5dd
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Jan 26 20:13:09 2008 +0100

    ide: move CONFIG_IDEPCI_PCIBUS_ORDER code to ide-scan-pci.c
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index be9ae5a38cc7..676c66e72881 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -698,106 +698,3 @@ int ide_setup_pci_devices(struct pci_dev *dev1, struct pci_dev *dev2,
 }
 
 EXPORT_SYMBOL_GPL(ide_setup_pci_devices);
-
-#ifdef CONFIG_IDEPCI_PCIBUS_ORDER
-/*
- *	Module interfaces
- */
-
-static int pre_init = 1;		/* Before first ordered IDE scan */
-static LIST_HEAD(ide_pci_drivers);
-
-/*
- *	__ide_pci_register_driver	-	attach IDE driver
- *	@driver: pci driver
- *	@module: owner module of the driver
- *
- *	Registers a driver with the IDE layer. The IDE layer arranges that
- *	boot time setup is done in the expected device order and then
- *	hands the controllers off to the core PCI code to do the rest of
- *	the work.
- *
- *	Returns are the same as for pci_register_driver
- */
-
-int __ide_pci_register_driver(struct pci_driver *driver, struct module *module,
-			      const char *mod_name)
-{
-	if (!pre_init)
-		return __pci_register_driver(driver, module, mod_name);
-	driver->driver.owner = module;
-	list_add_tail(&driver->node, &ide_pci_drivers);
-	return 0;
-}
-EXPORT_SYMBOL_GPL(__ide_pci_register_driver);
-
-/**
- *	ide_scan_pcidev		-	find an IDE driver for a device
- *	@dev: PCI device to check
- *
- *	Look for an IDE driver to handle the device we are considering.
- *	This is only used during boot up to get the ordering correct. After
- *	boot up the pci layer takes over the job.
- */
-
-static int __init ide_scan_pcidev(struct pci_dev *dev)
-{
-	struct list_head *l;
-	struct pci_driver *d;
-
-	list_for_each(l, &ide_pci_drivers) {
-		d = list_entry(l, struct pci_driver, node);
-		if (d->id_table) {
-			const struct pci_device_id *id =
-				pci_match_id(d->id_table, dev);
-
-			if (id != NULL && d->probe(dev, id) >= 0) {
-				dev->driver = d;
-				pci_dev_get(dev);
-				return 1;
-			}
-		}
-	}
-	return 0;
-}
-
-/**
- *	ide_scan_pcibus		-	perform the initial IDE driver scan
- *
- *	Perform the initial bus rather than driver ordered scan of the
- *	PCI drivers. After this all IDE pci handling becomes standard
- *	module ordering not traditionally ordered.
- */
-
-int __init ide_scan_pcibus(void)
-{
-	struct pci_dev *dev = NULL;
-	struct pci_driver *d;
-	struct list_head *l, *n;
-
-	pre_init = 0;
-	if (!ide_scan_direction)
-		while ((dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, dev)))
-			ide_scan_pcidev(dev);
-	else
-		while ((dev = pci_get_device_reverse(PCI_ANY_ID, PCI_ANY_ID,
-						     dev)))
-			ide_scan_pcidev(dev);
-
-	/*
-	 *	Hand the drivers over to the PCI layer now we
-	 *	are post init.
-	 */
-
-	list_for_each_safe(l, n, &ide_pci_drivers) {
-		list_del(l);
-		d = list_entry(l, struct pci_driver, node);
-		if (__pci_register_driver(d, d->driver.owner,
-					  d->driver.mod_name))
-			printk(KERN_ERR "%s: failed to register %s driver\n",
-					__FUNCTION__, d->driver.mod_name);
-	}
-
-	return 0;
-}
-#endif

commit 79127c37aa5d959c9ace40a869386f712b55ac6d
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Jan 26 20:13:08 2008 +0100

    ide: use ide_init_port_hw() in setup-pci.c
    
    * Move setting hwif->gendev.parent from ide_pci_setup_ports()
      to ide_hwif_configure().
    
    * Always set hwif->io_ports in ide_hwif_configure().
    
    * Use ide_init_port_hw() in ide_hwif_configure().
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index caa4a6a32711..be9ae5a38cc7 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -363,6 +363,8 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev, const struct ide_port
 	unsigned long ctl = 0, base = 0;
 	ide_hwif_t *hwif;
 	u8 bootable = (d->host_flags & IDE_HFLAG_BOOTABLE) ? 1 : 0;
+	u8 oldnoprobe = 0;
+	struct hw_regs_s hw;
 
 	if ((d->host_flags & IDE_HFLAG_ISA_PORTS) == 0) {
 		/*  Possibly we should fail if these checks report true */
@@ -385,22 +387,25 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev, const struct ide_port
 	}
 	if ((hwif = ide_match_hwif(base, bootable, d->name)) == NULL)
 		return NULL;	/* no room in ide_hwifs[] */
-	if (hwif->io_ports[IDE_DATA_OFFSET] != base ||
-	    hwif->io_ports[IDE_CONTROL_OFFSET] != (ctl | 2)) {
-		hw_regs_t hw;
-
-		memset(&hw, 0, sizeof(hw));
-		ide_std_init_ports(&hw, base, ctl | 2);
-		memcpy(hwif->io_ports, hw.io_ports, sizeof(hwif->io_ports));
-		hwif->noprobe = 0;
-	}
-	hwif->chipset = d->chipset ? d->chipset : ide_pci;
+
+	memset(&hw, 0, sizeof(hw));
+	hw.irq = hwif->irq ? hwif->irq : irq;
+	hw.dev = &dev->dev;
+	hw.chipset = d->chipset ? d->chipset : ide_pci;
+	ide_std_init_ports(&hw, base, ctl | 2);
+
+	if (hwif->io_ports[IDE_DATA_OFFSET] == base &&
+	    hwif->io_ports[IDE_CONTROL_OFFSET] == (ctl | 2))
+		oldnoprobe = hwif->noprobe;
+
+	ide_init_port_hw(hwif, &hw);
+
+	hwif->noprobe = oldnoprobe;
+
 	hwif->pci_dev = dev;
 	hwif->cds = d;
 	hwif->channel = port;
 
-	if (!hwif->irq)
-		hwif->irq = irq;
 	if (mate) {
 		hwif->mate = mate;
 		mate->mate = hwif;
@@ -535,12 +540,8 @@ void ide_pci_setup_ports(struct pci_dev *dev, const struct ide_port_info *d, int
 		if ((hwif = ide_hwif_configure(dev, d, mate, port, pciirq)) == NULL)
 			continue;
 
-		/* setup proper ancestral information */
-		hwif->gendev.parent = &dev->dev;
-
 		*(idx + port) = hwif->index;
 
-		
 		if (d->init_iops)
 			d->init_iops(hwif);
 

commit 6828fc9a919b06723599192300053ddf6f638c95
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Jan 26 20:13:08 2008 +0100

    ide: always use ide_std_init_ports() in setup-pci.c
    
    * ide_init_hwif_ports() call in setup-pci.c::ide_hwif_configure()
      doesn't depend on the default cotrol register offset, default IRQ
      or ppc_ide_md.ide_init_hwif implementations so ide_std_init_ports()
      can always be used.
    
    * Since 'base' is always non-zero and thus hwif->io_ports[IDE_DATA_OFFSET]
      is also non-zero always clear hwif->noprobe.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 63ef8aaa7b90..caa4a6a32711 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -390,13 +390,9 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev, const struct ide_port
 		hw_regs_t hw;
 
 		memset(&hw, 0, sizeof(hw));
-#ifndef CONFIG_IDE_ARCH_OBSOLETE_INIT
 		ide_std_init_ports(&hw, base, ctl | 2);
-#else
-		ide_init_hwif_ports(&hw, base, ctl | 2, NULL);
-#endif
 		memcpy(hwif->io_ports, hw.io_ports, sizeof(hwif->io_ports));
-		hwif->noprobe = !hwif->io_ports[IDE_DATA_OFFSET];
+		hwif->noprobe = 0;
 	}
 	hwif->chipset = d->chipset ? d->chipset : ide_pci;
 	hwif->pci_dev = dev;

commit ade2daf9c6e57845fe83a24e0a9fa1c03c6e91b1
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Jan 26 20:13:07 2008 +0100

    ide: make remaining built-in only IDE host drivers modular (take 2)
    
    * Make remaining built-in only IDE host drivers modular, add ide-scan-pci.c
      file for probing PCI host drivers registered with IDE core (special case
      for built-in IDE and CONFIG_IDEPCI_PCIBUS_ORDER=y) and then take care of
      the ordering in which all IDE host drivers are probed when IDE is built-in
      during link time.
    
    * Move probing of gayle, falconide, macide, q40ide and buddha (m68k arch
      specific) host drivers, before PCI ones (no PCI on m68k), ide-cris (cris
      arch specific), cmd640 (x86 arch specific) and pmac (ppc arch specific).
    
    * Move probing of ide-cris (cris arch specific) host driver before cmd640
      (x86 arch specific).
    
    * Move probing of mpc8xx (ppc specific) host driver before ide-pnp (depends
      on ISA and none of ppc platform that use mpc8xx supports ISA) and ide-h8300
      (h8300 arch specific).
    
    * Add "probe_vlb" kernel parameter to cmd640 host driver and update
      Documentation/ide.txt accordingly.
    
    * Make IDE_ARM config option visible so it can also be disabled if needed.
    
    * Remove bogus comment from ide.c while at it.
    
    v2:
    * Fix two issues spotted by Sergei:
      - replace ENOMEM error value by ENOENT in ide-h8300 host driver
      - fix MODULE_PARM_DESC() in cmd640 host driver
    
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index d89f84d41b08..63ef8aaa7b90 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -766,21 +766,20 @@ static int __init ide_scan_pcidev(struct pci_dev *dev)
 
 /**
  *	ide_scan_pcibus		-	perform the initial IDE driver scan
- *	@scan_direction: set for reverse order scanning
  *
  *	Perform the initial bus rather than driver ordered scan of the
  *	PCI drivers. After this all IDE pci handling becomes standard
  *	module ordering not traditionally ordered.
  */
- 	
-void __init ide_scan_pcibus (int scan_direction)
+
+int __init ide_scan_pcibus(void)
 {
 	struct pci_dev *dev = NULL;
 	struct pci_driver *d;
 	struct list_head *l, *n;
 
 	pre_init = 0;
-	if (!scan_direction)
+	if (!ide_scan_direction)
 		while ((dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, dev)))
 			ide_scan_pcidev(dev);
 	else
@@ -801,5 +800,7 @@ void __init ide_scan_pcibus (int scan_direction)
 			printk(KERN_ERR "%s: failed to register %s driver\n",
 					__FUNCTION__, d->driver.mod_name);
 	}
+
+	return 0;
 }
 #endif

commit f01393e48c44e30f7c9a36c8b98a07b0232580fe
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Jan 26 20:13:03 2008 +0100

    ide: merge ->fixup and ->quirkproc methods
    
    * Assign drive->quirk_list in ->quirkproc implementations:
      - hpt366.c::hpt3xx_quirkproc()
      - pdc202xx_new.c::pdcnew_quirkproc()
      - pdc202xx_old.c::pdc202xx_quirkproc()
    
    * Make ->quirkproc void.
    
    * Move calling ->quirkproc from do_identify() to probe_hwif().
    
    * Convert it821x_fixups() to it821x_quirkproc() in it821x.c.
    
    * Convert siimage_fixup() to sil_quirkproc() in siimage.c, also remove
      no longer needed drive->present check from is_dev_seagate_sata().
    
    * Convert ide_undecoded_slave() to accept 'drive' instead of 'hwif'
      as an argument.  Then convert ide_register_hw() to accept 'quirkproc'
      argument instead of 'fixup' one.
    
    * Remove no longer needed ->fixup method.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index bbfdf7e0f182..d89f84d41b08 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -555,8 +555,6 @@ void ide_pci_setup_ports(struct pci_dev *dev, const struct ide_port_info *d, int
 		    (d->host_flags & IDE_HFLAG_FORCE_LEGACY_IRQS))
 			hwif->irq = port ? 15 : 14;
 
-		hwif->fixup = d->fixup;
-
 		hwif->host_flags = d->host_flags;
 		hwif->pio_mask = d->pio_mask;
 

commit aea5d375600f132537adf45942c0fbdcd25eb995
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Jan 26 20:12:59 2008 +0100

    ide: (hopefully) fix VDMA for CS5520
    
    * Set the correct hwif->dma_base for the second channel in
      ide_get_or_set_dma_base().
    
    * Remove DMA enable code from cs5520_set_pio_mode(), this can
      be handled by the generic ->dma_host_on method now.
    
    * Add VDMA check to ide_config_drive_speed().
    
    * drive->using_dma was never enabled since cs5520 host driver's
      ->ide_dma_on method overrided the generic ->ide_dma_on (so
      __ide_dma_on() was never called, drive->using_dma was never set
      and VDMA was never used since it depends on drive->using_dma).
    
      Fix it by using ->dma_host_on method instead of ->ide_dma_on
      (also add matching ->dma_host_off method).
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index d2cd5a3d38f8..bbfdf7e0f182 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -165,13 +165,17 @@ static unsigned long ide_get_or_set_dma_base(const struct ide_port_info *d, ide_
 
 		dma_base = pci_resource_start(dev, baridx);
 
-		if (dma_base == 0)
+		if (dma_base == 0) {
 			printk(KERN_ERR "%s: DMA base is invalid\n", d->name);
+			return 0;
+		}
 	}
 
-	if ((d->host_flags & IDE_HFLAG_CS5520) == 0 && dma_base) {
+	if (hwif->channel)
+		dma_base += 8;
+
+	if ((d->host_flags & IDE_HFLAG_CS5520) == 0) {
 		u8 simplex_stat = 0;
-		dma_base += hwif->channel ? 8 : 0;
 
 		switch(dev->device) {
 			case PCI_DEVICE_ID_AL_M5219:

commit 1b7d3477a7b0d52406d68b01bc8931f43112677f
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Dec 12 23:31:57 2007 +0100

    ide: coding style fixes for drivers/ide/setup-pci.c
    
    * remove trailing whitespaces
    * 'if()' -> 'if ()'
    * remove extra new-line before EXPORT_SYMBOL_GPL()
    * add extra new-line after 'id' definition
    * respect 80-columns limit
    
    There should be no functionality changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 708e01d8a9de..d2cd5a3d38f8 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -704,7 +704,7 @@ EXPORT_SYMBOL_GPL(ide_setup_pci_devices);
 /*
  *	Module interfaces
  */
- 
+
 static int pre_init = 1;		/* Before first ordered IDE scan */
 static LIST_HEAD(ide_pci_drivers);
 
@@ -714,7 +714,7 @@ static LIST_HEAD(ide_pci_drivers);
  *	@module: owner module of the driver
  *
  *	Registers a driver with the IDE layer. The IDE layer arranges that
- *	boot time setup is done in the expected device order and then 
+ *	boot time setup is done in the expected device order and then
  *	hands the controllers off to the core PCI code to do the rest of
  *	the work.
  *
@@ -724,13 +724,12 @@ static LIST_HEAD(ide_pci_drivers);
 int __ide_pci_register_driver(struct pci_driver *driver, struct module *module,
 			      const char *mod_name)
 {
-	if(!pre_init)
+	if (!pre_init)
 		return __pci_register_driver(driver, module, mod_name);
 	driver->driver.owner = module;
 	list_add_tail(&driver->node, &ide_pci_drivers);
 	return 0;
 }
-
 EXPORT_SYMBOL_GPL(__ide_pci_register_driver);
 
 /**
@@ -741,17 +740,18 @@ EXPORT_SYMBOL_GPL(__ide_pci_register_driver);
  *	This is only used during boot up to get the ordering correct. After
  *	boot up the pci layer takes over the job.
  */
- 
+
 static int __init ide_scan_pcidev(struct pci_dev *dev)
 {
 	struct list_head *l;
 	struct pci_driver *d;
-	
+
 	list_for_each(l, &ide_pci_drivers) {
 		d = list_entry(l, struct pci_driver, node);
 		if (d->id_table) {
-			const struct pci_device_id *id = pci_match_id(d->id_table,
-								      dev);
+			const struct pci_device_id *id =
+				pci_match_id(d->id_table, dev);
+
 			if (id != NULL && d->probe(dev, id) >= 0) {
 				dev->driver = d;
 				pci_dev_get(dev);
@@ -779,13 +779,13 @@ void __init ide_scan_pcibus (int scan_direction)
 
 	pre_init = 0;
 	if (!scan_direction)
-		while ((dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL)
+		while ((dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, dev)))
 			ide_scan_pcidev(dev);
 	else
-		while ((dev = pci_get_device_reverse(PCI_ANY_ID, PCI_ANY_ID, dev))
-		       != NULL)
+		while ((dev = pci_get_device_reverse(PCI_ANY_ID, PCI_ANY_ID,
+						     dev)))
 			ide_scan_pcidev(dev);
-	
+
 	/*
 	 *	Hand the drivers over to the PCI layer now we
 	 *	are post init.

commit 125a8191dcbc927441263a332826989cc2925681
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Dec 12 23:31:57 2007 +0100

    ide: fix ide_scan_pcibus() error message
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 25fd09053220..708e01d8a9de 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -794,9 +794,10 @@ void __init ide_scan_pcibus (int scan_direction)
 	list_for_each_safe(l, n, &ide_pci_drivers) {
 		list_del(l);
 		d = list_entry(l, struct pci_driver, node);
-		if (__pci_register_driver(d, d->driver.owner, d->driver.mod_name))
-			printk(KERN_ERR "%s: failed to register driver for %s\n",
-			       __FUNCTION__, d->driver.mod_name);
+		if (__pci_register_driver(d, d->driver.owner,
+					  d->driver.mod_name))
+			printk(KERN_ERR "%s: failed to register %s driver\n",
+					__FUNCTION__, d->driver.mod_name);
 	}
 }
 #endif

commit 0fd4980fa75acc78c747b1f43d1204f6572a4845
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Nov 13 22:09:16 2007 +0100

    ide: remove stale/incorrect comment from setup-pci.c
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 02d14bf85ab2..25fd09053220 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -7,11 +7,6 @@
  *  May be copied or modified under the terms of the GNU General Public License
  */
 
-/*
- *  This module provides support for automatic detection and
- *  configuration of all PCI IDE interfaces present in a system.  
- */
-
 #include <linux/module.h>
 #include <linux/types.h>
 #include <linux/kernel.h>

commit bde07e5eab1351109007bf375349f295977e7f53
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Oct 20 00:32:36 2007 +0200

    ide: enhance ide_setup_pci_noise()
    
    * Print PCI device Vendor ID, Device ID and revision in
      ide_setup_pci_noise().
    
    * Remove no longer needed PCI device revision printing from
      ide_setup_pci_controller().
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 727544c205b9..02d14bf85ab2 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -227,8 +227,9 @@ static unsigned long ide_get_or_set_dma_base(const struct ide_port_info *d, ide_
 
 void ide_setup_pci_noise(struct pci_dev *dev, const struct ide_port_info *d)
 {
-	printk(KERN_INFO "%s: IDE controller at PCI slot %s\n",
-			 d->name, pci_name(dev));
+	printk(KERN_INFO "%s: IDE controller (0x%04x:0x%04x rev 0x%02x) at "
+			 " PCI slot %s\n", d->name, dev->vendor, dev->device,
+			 dev->revision, pci_name(dev));
 }
 
 EXPORT_SYMBOL_GPL(ide_setup_pci_noise);
@@ -497,9 +498,6 @@ static int ide_setup_pci_controller(struct pci_dev *dev, const struct ide_port_i
 		printk(KERN_INFO "%s: device enabled (Linux)\n", d->name);
 	}
 
-	if (noisy)
-		printk(KERN_INFO "%s: chipset revision %d\n",
-				 d->name, dev->revision);
 out:
 	return ret;
 }

commit 8562043606430185cad26d085d46adcc7ad67fd1
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Oct 20 00:32:34 2007 +0200

    ide: constify struct ide_port_info
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 3517eb0eddbd..727544c205b9 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -155,7 +155,7 @@ static int ide_setup_pci_baseregs (struct pci_dev *dev, const char *name)
  *	and enforce IDE simplex rules.
  */
 
-static unsigned long ide_get_or_set_dma_base(struct ide_port_info *d, ide_hwif_t *hwif)
+static unsigned long ide_get_or_set_dma_base(const struct ide_port_info *d, ide_hwif_t *hwif)
 {
 	unsigned long	dma_base = 0;
 	struct pci_dev	*dev = hwif->pci_dev;
@@ -225,7 +225,7 @@ static unsigned long ide_get_or_set_dma_base(struct ide_port_info *d, ide_hwif_t
 }
 #endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
 
-void ide_setup_pci_noise(struct pci_dev *dev, struct ide_port_info *d)
+void ide_setup_pci_noise(struct pci_dev *dev, const struct ide_port_info *d)
 {
 	printk(KERN_INFO "%s: IDE controller at PCI slot %s\n",
 			 d->name, pci_name(dev));
@@ -245,7 +245,7 @@ EXPORT_SYMBOL_GPL(ide_setup_pci_noise);
  *	Returns zero on success or an error code
  */
 
-static int ide_pci_enable(struct pci_dev *dev, struct ide_port_info *d)
+static int ide_pci_enable(struct pci_dev *dev, const struct ide_port_info *d)
 {
 	int ret;
 
@@ -290,7 +290,7 @@ static int ide_pci_enable(struct pci_dev *dev, struct ide_port_info *d)
  *	Returns zero on success or an error code.
  */
 
-static int ide_pci_configure(struct pci_dev *dev, struct ide_port_info *d)
+static int ide_pci_configure(struct pci_dev *dev, const struct ide_port_info *d)
 {
 	u16 pcicmd = 0;
 	/*
@@ -326,7 +326,7 @@ static int ide_pci_configure(struct pci_dev *dev, struct ide_port_info *d)
  *	print an error and return an error code. Otherwise return 0
  */
 
-static int ide_pci_check_iomem(struct pci_dev *dev, struct ide_port_info *d, int bar)
+static int ide_pci_check_iomem(struct pci_dev *dev, const struct ide_port_info *d, int bar)
 {
 	ulong flags = pci_resource_flags(dev, bar);
 	
@@ -358,7 +358,7 @@ static int ide_pci_check_iomem(struct pci_dev *dev, struct ide_port_info *d, int
  *	Returns the new hardware interface structure, or NULL on a failure
  */
 
-static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev, struct ide_port_info *d, ide_hwif_t *mate, int port, int irq)
+static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev, const struct ide_port_info *d, ide_hwif_t *mate, int port, int irq)
 {
 	unsigned long ctl = 0, base = 0;
 	ide_hwif_t *hwif;
@@ -423,7 +423,7 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev, struct ide_port_info
  *	state
  */
 
-static void ide_hwif_setup_dma(struct pci_dev *dev, struct ide_port_info *d, ide_hwif_t *hwif)
+static void ide_hwif_setup_dma(struct pci_dev *dev, const struct ide_port_info *d, ide_hwif_t *hwif)
 {
 #ifdef CONFIG_BLK_DEV_IDEDMA_PCI
 	u16 pcicmd;
@@ -472,7 +472,7 @@ static void ide_hwif_setup_dma(struct pci_dev *dev, struct ide_port_info *d, ide
  *	and enables it if need be
  */
 
-static int ide_setup_pci_controller(struct pci_dev *dev, struct ide_port_info *d, int noisy, int *config)
+static int ide_setup_pci_controller(struct pci_dev *dev, const struct ide_port_info *d, int noisy, int *config)
 {
 	int ret;
 	u16 pcicmd;
@@ -520,7 +520,7 @@ static int ide_setup_pci_controller(struct pci_dev *dev, struct ide_port_info *d
  *	where the chipset setup is not the default PCI IDE one.
  */
 
-void ide_pci_setup_ports(struct pci_dev *dev, struct ide_port_info *d, int pciirq, u8 *idx)
+void ide_pci_setup_ports(struct pci_dev *dev, const struct ide_port_info *d, int pciirq, u8 *idx)
 {
 	int channels = (d->host_flags & IDE_HFLAG_SINGLE) ? 1 : 2, port;
 	ide_hwif_t *hwif, *mate = NULL;
@@ -531,8 +531,8 @@ void ide_pci_setup_ports(struct pci_dev *dev, struct ide_port_info *d, int pciir
 	 */
 
 	for (port = 0; port < channels; ++port) {
-		ide_pci_enablebit_t *e = &(d->enablebits[port]);
-	
+		const ide_pci_enablebit_t *e = &(d->enablebits[port]);
+
 		if (e->reg && (pci_read_config_byte(dev, e->reg, &tmp) ||
 		    (tmp & e->mask) != e->val)) {
 			printk(KERN_INFO "%s: IDE port disabled\n", d->name);
@@ -611,7 +611,7 @@ EXPORT_SYMBOL_GPL(ide_pci_setup_ports);
  * for all other chipsets, we just assume both interfaces are enabled.
  */
 static int do_ide_setup_pci_device(struct pci_dev *dev,
-				   struct ide_port_info *d,
+				   const struct ide_port_info *d,
 				   u8 *idx, u8 noisy)
 {
 	int tried_config = 0;
@@ -668,7 +668,7 @@ static int do_ide_setup_pci_device(struct pci_dev *dev,
 	return ret;
 }
 
-int ide_setup_pci_device(struct pci_dev *dev, struct ide_port_info *d)
+int ide_setup_pci_device(struct pci_dev *dev, const struct ide_port_info *d)
 {
 	u8 idx[4] = { 0xff, 0xff, 0xff, 0xff };
 	int ret;
@@ -684,7 +684,7 @@ int ide_setup_pci_device(struct pci_dev *dev, struct ide_port_info *d)
 EXPORT_SYMBOL_GPL(ide_setup_pci_device);
 
 int ide_setup_pci_devices(struct pci_dev *dev1, struct pci_dev *dev2,
-			  struct ide_port_info *d)
+			  const struct ide_port_info *d)
 {
 	struct pci_dev *pdev[] = { dev1, dev2 };
 	int ret, i;

commit 039788e1532368eeca1071a873c14e03920cdf38
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Oct 20 00:32:34 2007 +0200

    ide: replace ide_pci_device_t by struct ide_port_info
    
    * Rename struct ide_pci_device_s to struct ide_port_info.
    
    * Remove ide_pci_device_t typedef.
    
    While at it:
    
    * Fix __ide_pci_register_driver() comment.
    
    * Fix aec62xx_init_one() comment.
    
    * Remove unused 'cds' field from ide_hwgroup_t.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 71be6999f967..3517eb0eddbd 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -147,15 +147,15 @@ static int ide_setup_pci_baseregs (struct pci_dev *dev, const char *name)
 #ifdef CONFIG_BLK_DEV_IDEDMA_PCI
 /**
  *	ide_get_or_set_dma_base		-	setup BMIBA
- *	@d: IDE pci device data
- *	@hwif: Interface
+ *	@d: IDE port info
+ *	@hwif: IDE interface
  *
  *	Fetch the DMA Bus-Master-I/O-Base-Address (BMIBA) from PCI space.
  *	Where a device has a partner that is already in DMA mode we check
  *	and enforce IDE simplex rules.
  */
 
-static unsigned long ide_get_or_set_dma_base(ide_pci_device_t *d, ide_hwif_t *hwif)
+static unsigned long ide_get_or_set_dma_base(struct ide_port_info *d, ide_hwif_t *hwif)
 {
 	unsigned long	dma_base = 0;
 	struct pci_dev	*dev = hwif->pci_dev;
@@ -225,7 +225,7 @@ static unsigned long ide_get_or_set_dma_base(ide_pci_device_t *d, ide_hwif_t *hw
 }
 #endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
 
-void ide_setup_pci_noise (struct pci_dev *dev, ide_pci_device_t *d)
+void ide_setup_pci_noise(struct pci_dev *dev, struct ide_port_info *d)
 {
 	printk(KERN_INFO "%s: IDE controller at PCI slot %s\n",
 			 d->name, pci_name(dev));
@@ -237,15 +237,15 @@ EXPORT_SYMBOL_GPL(ide_setup_pci_noise);
 /**
  *	ide_pci_enable	-	do PCI enables
  *	@dev: PCI device
- *	@d: IDE pci device data
+ *	@d: IDE port info
  *
  *	Enable the IDE PCI device. We attempt to enable the device in full
  *	but if that fails then we only need BAR4 so we will enable that.
  *	
  *	Returns zero on success or an error code
  */
- 
-static int ide_pci_enable(struct pci_dev *dev, ide_pci_device_t *d)
+
+static int ide_pci_enable(struct pci_dev *dev, struct ide_port_info *d)
 {
 	int ret;
 
@@ -260,9 +260,9 @@ static int ide_pci_enable(struct pci_dev *dev, ide_pci_device_t *d)
 	}
 
 	/*
-	 * assume all devices can do 32-bit dma for now. we can add a
-	 * dma mask field to the ide_pci_device_t if we need it (or let
-	 * lower level driver set the dma mask)
+	 * assume all devices can do 32-bit DMA for now, we can add
+	 * a DMA mask field to the struct ide_port_info if we need it
+	 * (or let lower level driver set the DMA mask)
 	 */
 	ret = pci_set_dma_mask(dev, DMA_32BIT_MASK);
 	if (ret < 0) {
@@ -284,13 +284,13 @@ static int ide_pci_enable(struct pci_dev *dev, ide_pci_device_t *d)
 /**
  *	ide_pci_configure	-	configure an unconfigured device
  *	@dev: PCI device
- *	@d: IDE pci device data
+ *	@d: IDE port info
  *
  *	Enable and configure the PCI device we have been passed.
  *	Returns zero on success or an error code.
  */
- 
-static int ide_pci_configure(struct pci_dev *dev, ide_pci_device_t *d)
+
+static int ide_pci_configure(struct pci_dev *dev, struct ide_port_info *d)
 {
 	u16 pcicmd = 0;
 	/*
@@ -318,15 +318,15 @@ static int ide_pci_configure(struct pci_dev *dev, ide_pci_device_t *d)
 
 /**
  *	ide_pci_check_iomem	-	check a register is I/O
- *	@dev: pci device
- *	@d: ide_pci_device
- *	@bar: bar number
+ *	@dev: PCI device
+ *	@d: IDE port info
+ *	@bar: BAR number
  *
  *	Checks if a BAR is configured and points to MMIO space. If so
  *	print an error and return an error code. Otherwise return 0
  */
- 
-static int ide_pci_check_iomem(struct pci_dev *dev, ide_pci_device_t *d, int bar)
+
+static int ide_pci_check_iomem(struct pci_dev *dev, struct ide_port_info *d, int bar)
 {
 	ulong flags = pci_resource_flags(dev, bar);
 	
@@ -348,7 +348,7 @@ static int ide_pci_check_iomem(struct pci_dev *dev, ide_pci_device_t *d, int bar
 /**
  *	ide_hwif_configure	-	configure an IDE interface
  *	@dev: PCI device holding interface
- *	@d: IDE pci data
+ *	@d: IDE port info
  *	@mate: Paired interface if any
  *
  *	Perform the initial set up for the hardware interface structure. This
@@ -357,8 +357,8 @@ static int ide_pci_check_iomem(struct pci_dev *dev, ide_pci_device_t *d, int bar
  *
  *	Returns the new hardware interface structure, or NULL on a failure
  */
- 
-static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev, ide_pci_device_t *d, ide_hwif_t *mate, int port, int irq)
+
+static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev, struct ide_port_info *d, ide_hwif_t *mate, int port, int irq)
 {
 	unsigned long ctl = 0, base = 0;
 	ide_hwif_t *hwif;
@@ -400,7 +400,7 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev, ide_pci_device_t *d,
 	}
 	hwif->chipset = d->chipset ? d->chipset : ide_pci;
 	hwif->pci_dev = dev;
-	hwif->cds = (struct ide_pci_device_s *) d;
+	hwif->cds = d;
 	hwif->channel = port;
 
 	if (!hwif->irq)
@@ -415,21 +415,17 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev, ide_pci_device_t *d,
 /**
  *	ide_hwif_setup_dma	-	configure DMA interface
  *	@dev: PCI device
- *	@d: IDE pci data
- *	@hwif: Hardware interface we are configuring
+ *	@d: IDE port info
+ *	@hwif: IDE interface
  *
  *	Set up the DMA base for the interface. Enable the master bits as
  *	necessary and attempt to bring the device DMA into a ready to use
  *	state
  */
- 
-#ifndef CONFIG_BLK_DEV_IDEDMA_PCI
-static void ide_hwif_setup_dma(struct pci_dev *dev, ide_pci_device_t *d, ide_hwif_t *hwif)
-{
-}
-#else
-static void ide_hwif_setup_dma(struct pci_dev *dev, ide_pci_device_t *d, ide_hwif_t *hwif)
+
+static void ide_hwif_setup_dma(struct pci_dev *dev, struct ide_port_info *d, ide_hwif_t *hwif)
 {
+#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
 	u16 pcicmd;
 
 	pci_read_config_word(dev, PCI_COMMAND, &pcicmd);
@@ -461,13 +457,13 @@ static void ide_hwif_setup_dma(struct pci_dev *dev, ide_pci_device_t *d, ide_hwi
 				"(BIOS)\n", hwif->name, d->name);
 		}
 	}
-}
 #endif /* CONFIG_BLK_DEV_IDEDMA_PCI*/
+}
 
 /**
  *	ide_setup_pci_controller	-	set up IDE PCI
  *	@dev: PCI device
- *	@d: IDE PCI data
+ *	@d: IDE port info
  *	@noisy: verbose flag
  *	@config: returned as 1 if we configured the hardware
  *
@@ -475,8 +471,8 @@ static void ide_hwif_setup_dma(struct pci_dev *dev, ide_pci_device_t *d, ide_hwi
  *	up the PCI side of the device, checks that the device is enabled
  *	and enables it if need be
  */
- 
-static int ide_setup_pci_controller(struct pci_dev *dev, ide_pci_device_t *d, int noisy, int *config)
+
+static int ide_setup_pci_controller(struct pci_dev *dev, struct ide_port_info *d, int noisy, int *config)
 {
 	int ret;
 	u16 pcicmd;
@@ -511,7 +507,7 @@ static int ide_setup_pci_controller(struct pci_dev *dev, ide_pci_device_t *d, in
 /**
  *	ide_pci_setup_ports	-	configure ports/devices on PCI IDE
  *	@dev: PCI device
- *	@d: IDE pci device info
+ *	@d: IDE port info
  *	@pciirq: IRQ line
  *	@idx: ATA index table to update
  *
@@ -524,7 +520,7 @@ static int ide_setup_pci_controller(struct pci_dev *dev, ide_pci_device_t *d, in
  *	where the chipset setup is not the default PCI IDE one.
  */
 
-void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int pciirq, u8 *idx)
+void ide_pci_setup_ports(struct pci_dev *dev, struct ide_port_info *d, int pciirq, u8 *idx)
 {
 	int channels = (d->host_flags & IDE_HFLAG_SINGLE) ? 1 : 2, port;
 	ide_hwif_t *hwif, *mate = NULL;
@@ -611,10 +607,11 @@ EXPORT_SYMBOL_GPL(ide_pci_setup_ports);
  *
  * One thing that is not standardized is the location of the
  * primary/secondary interface "enable/disable" bits.  For chipsets that
- * we "know" about, this information is in the ide_pci_device_t struct;
+ * we "know" about, this information is in the struct ide_port_info;
  * for all other chipsets, we just assume both interfaces are enabled.
  */
-static int do_ide_setup_pci_device(struct pci_dev *dev, ide_pci_device_t *d,
+static int do_ide_setup_pci_device(struct pci_dev *dev,
+				   struct ide_port_info *d,
 				   u8 *idx, u8 noisy)
 {
 	int tried_config = 0;
@@ -671,7 +668,7 @@ static int do_ide_setup_pci_device(struct pci_dev *dev, ide_pci_device_t *d,
 	return ret;
 }
 
-int ide_setup_pci_device(struct pci_dev *dev, ide_pci_device_t *d)
+int ide_setup_pci_device(struct pci_dev *dev, struct ide_port_info *d)
 {
 	u8 idx[4] = { 0xff, 0xff, 0xff, 0xff };
 	int ret;
@@ -687,7 +684,7 @@ int ide_setup_pci_device(struct pci_dev *dev, ide_pci_device_t *d)
 EXPORT_SYMBOL_GPL(ide_setup_pci_device);
 
 int ide_setup_pci_devices(struct pci_dev *dev1, struct pci_dev *dev2,
-			  ide_pci_device_t *d)
+			  struct ide_port_info *d)
 {
 	struct pci_dev *pdev[] = { dev1, dev2 };
 	int ret, i;
@@ -728,9 +725,6 @@ static LIST_HEAD(ide_pci_drivers);
  *	hands the controllers off to the core PCI code to do the rest of
  *	the work.
  *
- *	The driver_data of the driver table must point to an ide_pci_device_t
- *	describing the interface.
- *
  *	Returns are the same as for pci_register_driver
  */
 

commit 9239b333939dd1e5b1a9f033a1c136273d58efe8
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Oct 20 00:32:33 2007 +0200

    ide: remove write-only hwif->hw
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 875167e11cd1..71be6999f967 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -387,14 +387,15 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev, ide_pci_device_t *d,
 		return NULL;	/* no room in ide_hwifs[] */
 	if (hwif->io_ports[IDE_DATA_OFFSET] != base ||
 	    hwif->io_ports[IDE_CONTROL_OFFSET] != (ctl | 2)) {
-		memset(&hwif->hw, 0, sizeof(hwif->hw));
+		hw_regs_t hw;
+
+		memset(&hw, 0, sizeof(hw));
 #ifndef CONFIG_IDE_ARCH_OBSOLETE_INIT
-		ide_std_init_ports(&hwif->hw, base, (ctl | 2));
-		hwif->hw.io_ports[IDE_IRQ_OFFSET] = 0;
+		ide_std_init_ports(&hw, base, ctl | 2);
 #else
-		ide_init_hwif_ports(&hwif->hw, base, (ctl | 2), NULL);
+		ide_init_hwif_ports(&hw, base, ctl | 2, NULL);
 #endif
-		memcpy(hwif->io_ports, hwif->hw.io_ports, sizeof(hwif->io_ports));
+		memcpy(hwif->io_ports, hw.io_ports, sizeof(hwif->io_ports));
 		hwif->noprobe = !hwif->io_ports[IDE_DATA_OFFSET];
 	}
 	hwif->chipset = d->chipset ? d->chipset : ide_pci;

commit 847ddd2bbe15c6e452606503b5d073826aaaddb7
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Oct 20 00:32:32 2007 +0200

    ide: add CONFIG_IDE_ARCH_OBSOLETE_INIT
    
    Add CONFIG_IDE_ARCH_OBSOLETE_INIT to drivers/ide/Kconfig and use it instead
    of defining IDE_ARCH_OBSOLETE_INIT in <arch/ide.h>.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 252cb8c5931a..875167e11cd1 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -388,7 +388,7 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev, ide_pci_device_t *d,
 	if (hwif->io_ports[IDE_DATA_OFFSET] != base ||
 	    hwif->io_ports[IDE_CONTROL_OFFSET] != (ctl | 2)) {
 		memset(&hwif->hw, 0, sizeof(hwif->hw));
-#ifndef IDE_ARCH_OBSOLETE_INIT
+#ifndef CONFIG_IDE_ARCH_OBSOLETE_INIT
 		ide_std_init_ports(&hwif->hw, base, (ctl | 2));
 		hwif->hw.io_ports[IDE_IRQ_OFFSET] = 0;
 #else

commit 8447d9d52adbe4c653482bd0d5ccb9b5d26f9c9d
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Oct 20 00:32:31 2007 +0200

    ide: add ide_device_add()
    
    * Add ide_device_add() helper and convert host drivers to use it
      instead of open-coded variants.
    
    * Make ide_pci_setup_ports() and do_ide_setup_pci_device()
      take 'u8 *idx' argument instead of 'ata_index_t *index'.
    
    * Remove no longer needed ata_index_t.
    
    * Unexport probe_hwif_init() and make it static.
    
    * Unexport ide_proc_register_port().
    
    There should be no functionality changes caused by this patch
    (sgiioc4.c: ide_proc_register_port() requires hwif->present
     to be set and it won't be set if probe_hwif_init() fails).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 4e9de2043113..252cb8c5931a 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -512,7 +512,7 @@ static int ide_setup_pci_controller(struct pci_dev *dev, ide_pci_device_t *d, in
  *	@dev: PCI device
  *	@d: IDE pci device info
  *	@pciirq: IRQ line
- *	@index: ata index to update
+ *	@idx: ATA index table to update
  *
  *	Scan the interfaces attached to this device and do any
  *	necessary per port setup. Attach the devices and ask the
@@ -522,15 +522,13 @@ static int ide_setup_pci_controller(struct pci_dev *dev, ide_pci_device_t *d, in
  *	but is also used directly as a helper function by some controllers
  *	where the chipset setup is not the default PCI IDE one.
  */
- 
-void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int pciirq, ata_index_t *index)
+
+void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int pciirq, u8 *idx)
 {
 	int channels = (d->host_flags & IDE_HFLAG_SINGLE) ? 1 : 2, port;
 	ide_hwif_t *hwif, *mate = NULL;
 	u8 tmp;
 
-	index->all = 0xf0f0;
-
 	/*
 	 * Set up the IDE ports
 	 */
@@ -550,11 +548,7 @@ void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int pciirq, a
 		/* setup proper ancestral information */
 		hwif->gendev.parent = &dev->dev;
 
-		if (hwif->channel) {
-			index->b.high = hwif->index;
-		} else {
-			index->b.low = hwif->index;
-		}
+		*(idx + port) = hwif->index;
 
 		
 		if (d->init_iops)
@@ -620,9 +614,8 @@ EXPORT_SYMBOL_GPL(ide_pci_setup_ports);
  * for all other chipsets, we just assume both interfaces are enabled.
  */
 static int do_ide_setup_pci_device(struct pci_dev *dev, ide_pci_device_t *d,
-				   ata_index_t *index, u8 noisy)
+				   u8 *idx, u8 noisy)
 {
-	static ata_index_t ata_index = { .b = { .low = 0xff, .high = 0xff } };
 	int tried_config = 0;
 	int pciirq, ret;
 
@@ -672,37 +665,21 @@ static int do_ide_setup_pci_device(struct pci_dev *dev, ide_pci_device_t *d,
 
 	/* FIXME: silent failure can happen */
 
-	*index = ata_index;
-	ide_pci_setup_ports(dev, d, pciirq, index);
+	ide_pci_setup_ports(dev, d, pciirq, idx);
 out:
 	return ret;
 }
 
 int ide_setup_pci_device(struct pci_dev *dev, ide_pci_device_t *d)
 {
-	ide_hwif_t *hwif = NULL, *mate = NULL;
-	ata_index_t index_list;
+	u8 idx[4] = { 0xff, 0xff, 0xff, 0xff };
 	int ret;
 
-	ret = do_ide_setup_pci_device(dev, d, &index_list, 1);
-	if (ret < 0)
-		goto out;
+	ret = do_ide_setup_pci_device(dev, d, &idx[0], 1);
 
-	if ((index_list.b.low & 0xf0) != 0xf0)
-		hwif = &ide_hwifs[index_list.b.low];
-	if ((index_list.b.high & 0xf0) != 0xf0)
-		mate = &ide_hwifs[index_list.b.high];
+	if (ret >= 0)
+		ide_device_add(idx);
 
-	if (hwif)
-		probe_hwif_init(hwif);
-	if (mate)
-		probe_hwif_init(mate);
-
-	if (hwif)
-		ide_proc_register_port(hwif);
-	if (mate)
-		ide_proc_register_port(mate);
-out:
 	return ret;
 }
 
@@ -712,11 +689,11 @@ int ide_setup_pci_devices(struct pci_dev *dev1, struct pci_dev *dev2,
 			  ide_pci_device_t *d)
 {
 	struct pci_dev *pdev[] = { dev1, dev2 };
-	ata_index_t index_list[2];
 	int ret, i;
+	u8 idx[4] = { 0xff, 0xff, 0xff, 0xff };
 
 	for (i = 0; i < 2; i++) {
-		ret = do_ide_setup_pci_device(pdev[i], d, index_list + i, !i);
+		ret = do_ide_setup_pci_device(pdev[i], d, &idx[i*2], !i);
 		/*
 		 * FIXME: Mom, mom, they stole me the helper function to undo
 		 * do_ide_setup_pci_device() on the first device!
@@ -725,25 +702,7 @@ int ide_setup_pci_devices(struct pci_dev *dev1, struct pci_dev *dev2,
 			goto out;
 	}
 
-	for (i = 0; i < 2; i++) {
-		u8 idx[2] = { index_list[i].b.low, index_list[i].b.high };
-		int j;
-
-		for (j = 0; j < 2; j++) {
-			if ((idx[j] & 0xf0) != 0xf0)
-				probe_hwif_init(ide_hwifs + idx[j]);
-		}
-	}
-
-	for (i = 0; i < 2; i++) {
-		u8 idx[2] = { index_list[i].b.low, index_list[i].b.high };
-		int j;
-
-		for (j = 0; j < 2; j++) {
-			if ((idx[j] & 0xf0) != 0xf0)
-				ide_proc_register_port(ide_hwifs + idx[j]);
-		}
-	}
+	ide_device_add(idx);
 out:
 	return ret;
 }

commit fd9bb53942a7ca3398a63f2c238afd8fbed3ec0e
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Oct 20 00:32:31 2007 +0200

    ide: add ->fixup method to ide_hwif_t
    
    * Add ->fixup method to ide_hwif_t.
    
    * Set hwif->fixup in ide_pci_setup_ports() to d->fixup.
    
    * Use hwif->fixup in probe_hwif().
    
    * Use probe_hwif_init() instead of probe_hwif_init_with_fixup() in
      ide_setup_pci_device().
    
    * Add 'fixup' argument to ide_register_hw() and use it to set hwif->fixup,
      update all ide_register_hw() users accordingly.
    
    * Convert ide-cs/delkin_cb host drivers to use ide_register_hw().
    
    * Restore hwif->fixup in ide_hwif_restore().
    
    * Remove ide_register_hw_with_fixup(), probe_hwif_init_with_fixup()
      and 'fixup' argument from probe_hwif().
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index d62b225f569f..4e9de2043113 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -567,6 +567,8 @@ void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int pciirq, a
 		    (d->host_flags & IDE_HFLAG_FORCE_LEGACY_IRQS))
 			hwif->irq = port ? 15 : 14;
 
+		hwif->fixup = d->fixup;
+
 		hwif->host_flags = d->host_flags;
 		hwif->pio_mask = d->pio_mask;
 
@@ -692,9 +694,9 @@ int ide_setup_pci_device(struct pci_dev *dev, ide_pci_device_t *d)
 		mate = &ide_hwifs[index_list.b.high];
 
 	if (hwif)
-		probe_hwif_init_with_fixup(hwif, d->fixup);
+		probe_hwif_init(hwif);
 	if (mate)
-		probe_hwif_init_with_fixup(mate, d->fixup);
+		probe_hwif_init(mate);
 
 	if (hwif)
 		ide_proc_register_port(hwif);

commit caea7602f309cbd55ba609800fd3c3e5d19ab684
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Oct 20 00:32:30 2007 +0200

    ide: add IDE_HFLAG_{IO_32BIT,UNMASK_IRQS} host flags
    
    Add IDE_HFLAG_{IO_32BIT,UNMASK_IRQS} host flag to tell ide_pci_setup_ports()
    to set drive->{io_32bit,unmask} for both drives on the interface.  Convert
    amd74xx, sl82c105 and via82cxxx host drivers to use these new host flags.
    
    While at it:
    
    * Add IDE_HFLAGS_AMD define (amd74xx host driver).
    
    * Add IDE_HFLAGS_VIA define (via82cxxx host driver).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index a1d7efc9eaaf..d62b225f569f 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -573,6 +573,16 @@ void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int pciirq, a
 		if ((d->host_flags & IDE_HFLAG_SERIALIZE) && hwif->mate)
 			hwif->mate->serialized = hwif->serialized = 1;
 
+		if (d->host_flags & IDE_HFLAG_IO_32BIT) {
+			hwif->drives[0].io_32bit = 1;
+			hwif->drives[1].io_32bit = 1;
+		}
+
+		if (d->host_flags & IDE_HFLAG_UNMASK_IRQS) {
+			hwif->drives[0].unmask = 1;
+			hwif->drives[1].unmask = 1;
+		}
+
 		if (hwif->dma_base) {
 			hwif->swdma_mask = d->swdma_mask;
 			hwif->mwdma_mask = d->mwdma_mask;

commit 272a370900e5d2ae84662338397bb7b2375ff5cf
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Oct 20 00:32:30 2007 +0200

    ide: add IDE_HFLAG_RQSIZE_256 host flag
    
    Add IDE_HFLAG_RQSIZE_256 host flag to tell ide_pci_setup_ports() to set
    hwif->rqsize to 256 sectors.  Convert pdc202xx_old host driver to use it.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 4fa813b96e72..a1d7efc9eaaf 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -582,6 +582,9 @@ void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int pciirq, a
 		hwif->drives[0].autotune = 1;
 		hwif->drives[1].autotune = 1;
 
+		if (d->host_flags & IDE_HFLAG_RQSIZE_256)
+			hwif->rqsize = 256;
+
 		if (d->init_hwif)
 			/* Call chipset-specific routine
 			 * for each enabled hwif

commit 8acf28c090f0e5e049f56b27bdd7cf1fb40c6b98
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Oct 20 00:32:30 2007 +0200

    ide: add IDE_HFLAG_FORCE_LEGACY_IRQS host flag
    
    Add IDE_HFLAG_FORCE_LEGACY_IRQS host flag to tell ide_pci_setup_ports()
    to always set hwif->irq to legacy IRQ 14/15 and convert generic IDE PCI
    and via82cxxx host drivers to use it.
    
    While at it:
    
    * Add IDE_HFLAGS_UMC define (generic IDE PCI host driver).
    
    * Remove no longer needed init_hwif_generic() (generic IDE PCI host driver).
    
    * Set d->udma_mask instead of hwif->ultra_mask (via82cxxx host driver).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 30c0741c5e5c..4fa813b96e72 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -563,7 +563,8 @@ void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int pciirq, a
 		if ((d->host_flags & IDE_HFLAG_NO_DMA) == 0)
 			ide_hwif_setup_dma(dev, d, hwif);
 
-		if ((d->host_flags & IDE_HFLAG_LEGACY_IRQS) && hwif->irq == 0)
+		if ((!hwif->irq && (d->host_flags & IDE_HFLAG_LEGACY_IRQS)) ||
+		    (d->host_flags & IDE_HFLAG_FORCE_LEGACY_IRQS))
 			hwif->irq = port ? 15 : 14;
 
 		hwif->host_flags = d->host_flags;

commit 528a572daea90aa41db92683e5a8756acef514c4
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Oct 20 00:32:30 2007 +0200

    ide: add ->chipset field to ide_pci_device_t
    
    Add ->chipset field to ide_pci_device_t and use it in ide_hwif_configure()
    to set hwif->chipset.  Convert cmd64x, cy82c693, rz1000 and trm290 host
    drivers to use this new ability.
    
    While at it define hwif_chipset_t as u8 to save some space in hw_regs_t,
    ide_hwif_t and ide_pci_device_t instances.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 6903100e3c83..30c0741c5e5c 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -397,7 +397,7 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev, ide_pci_device_t *d,
 		memcpy(hwif->io_ports, hwif->hw.io_ports, sizeof(hwif->io_ports));
 		hwif->noprobe = !hwif->io_ports[IDE_DATA_OFFSET];
 	}
-	hwif->chipset = ide_pci;
+	hwif->chipset = d->chipset ? d->chipset : ide_pci;
 	hwif->pci_dev = dev;
 	hwif->cds = (struct ide_pci_device_s *) d;
 	hwif->channel = port;

commit cf6e854efb3682322351a21e64058ffc13250914
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Oct 20 00:32:29 2007 +0200

    ide: fix disabled ports reporting for PCI controllers
    
    Report all disabled ports in ide_pci_setup_ports() (prevents the bogus
    warning when ide_hwif_configure()->ide_match_hwif() fails to find free
    ide_hwifs[] slots).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index fff567bcedbe..6903100e3c83 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -526,7 +526,6 @@ static int ide_setup_pci_controller(struct pci_dev *dev, ide_pci_device_t *d, in
 void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int pciirq, ata_index_t *index)
 {
 	int channels = (d->host_flags & IDE_HFLAG_SINGLE) ? 1 : 2, port;
-	int at_least_one_hwif_enabled = 0;
 	ide_hwif_t *hwif, *mate = NULL;
 	u8 tmp;
 
@@ -535,13 +534,15 @@ void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int pciirq, a
 	/*
 	 * Set up the IDE ports
 	 */
-	 
+
 	for (port = 0; port < channels; ++port) {
 		ide_pci_enablebit_t *e = &(d->enablebits[port]);
 	
 		if (e->reg && (pci_read_config_byte(dev, e->reg, &tmp) ||
-		    (tmp & e->mask) != e->val))
+		    (tmp & e->mask) != e->val)) {
+			printk(KERN_INFO "%s: IDE port disabled\n", d->name);
 			continue;	/* port not enabled */
+		}
 
 		if ((hwif = ide_hwif_configure(dev, d, mate, port, pciirq)) == NULL)
 			continue;
@@ -587,10 +588,7 @@ void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int pciirq, a
 			d->init_hwif(hwif);
 
 		mate = hwif;
-		at_least_one_hwif_enabled = 1;
 	}
-	if (!at_least_one_hwif_enabled)
-		printk(KERN_INFO "%s: neither IDE port enabled (BIOS)\n", d->name);
 }
 
 EXPORT_SYMBOL_GPL(ide_pci_setup_ports);

commit 85ad93ad56f4baf52e7c40f2e01c4df8e14d4c9c
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 19 00:30:12 2007 +0200

    ide: set drive->autotune in ide_pci_setup_ports()
    
    Majority of host drivers using IDE PCI layer set drive->autotune, the only
    exceptions are:
    
    generic.c
    ns87415.c
    rz1000.c
    trm290.c
    * no ->set_pio_mode method
    
    it821x.c:
    * if memory allocation fails drive->autotune won't be set
      (but there also won't be ->set_pio_mode method in such case)
    
    piix.c:
    * MPIIX controller (no ->init_hwif method so also no ->set_pio_mode method)
    
    However if there is no ->set_pio_mode method there are no changes in behavior
    w.r.t. PIO tuning so always set drive->autotune in ide_pci_setup_ports().
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 7989f521b801..fff567bcedbe 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -577,6 +577,9 @@ void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int pciirq, a
 			hwif->ultra_mask = d->udma_mask;
 		}
 
+		hwif->drives[0].autotune = 1;
+		hwif->drives[1].autotune = 1;
+
 		if (d->init_hwif)
 			/* Call chipset-specific routine
 			 * for each enabled hwif

commit 3985ee3b4c5f9e1d73623b92715375b089c54353
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 19 00:30:11 2007 +0200

    ide: add IDE_HFLAG_LEGACY_IRQS host flag
    
    Add IDE_HFLAG_LEGACY_IRQS host flag to tell ide_pci_setup_ports() to set
    hwif->irq to legacy IRQ 14/15 (iff hwif->irq is not already set) and convert
    atiixp, piix, serverworks, sis5513 and slc90e66 host drivers to use it.
    
    While at it:
    
    * In piix.c add IDE_HFLAGS_PIIX define and don't use ->init_hwif for MPIIX.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index aae4806f0603..7989f521b801 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -562,6 +562,9 @@ void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int pciirq, a
 		if ((d->host_flags & IDE_HFLAG_NO_DMA) == 0)
 			ide_hwif_setup_dma(dev, d, hwif);
 
+		if ((d->host_flags & IDE_HFLAG_LEGACY_IRQS) && hwif->irq == 0)
+			hwif->irq = port ? 15 : 14;
+
 		hwif->host_flags = d->host_flags;
 		hwif->pio_mask = d->pio_mask;
 

commit 1c51361a9867021dd7444b56d87834003d4ca67d
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 19 00:30:10 2007 +0200

    ide: add IDE_HFLAG_SERIALIZE host flag
    
    Add IDE_HFLAG_SERIALIZE host flag to tell ide_pci_setup_ports() to set
    hwif/mate->serialized and convert aec62xx, cs5530 and sc1200 host drivers
    to use it.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 1da9935ba948..aae4806f0603 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -565,6 +565,9 @@ void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int pciirq, a
 		hwif->host_flags = d->host_flags;
 		hwif->pio_mask = d->pio_mask;
 
+		if ((d->host_flags & IDE_HFLAG_SERIALIZE) && hwif->mate)
+			hwif->mate->serialized = hwif->serialized = 1;
+
 		if (hwif->dma_base) {
 			hwif->swdma_mask = d->swdma_mask;
 			hwif->mwdma_mask = d->mwdma_mask;

commit 31e8a465a265886a207427e5652aafb9a591c3fa
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 19 00:30:08 2007 +0200

    ide: use I/O ops directly part #2 (take 2)
    
    v2:
    - bump host driver versions (as suggested by Sergei)
    - use I/O ops directly in drivers/ide/setup-pci.c
    
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index f187889de70f..1da9935ba948 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -185,9 +185,9 @@ static unsigned long ide_get_or_set_dma_base(ide_pci_device_t *d, ide_hwif_t *hw
 			case PCI_DEVICE_ID_CMD_643:
 			case PCI_DEVICE_ID_SERVERWORKS_CSB5IDE:
 			case PCI_DEVICE_ID_REVOLUTION:
-				simplex_stat = hwif->INB(dma_base + 2);
-				hwif->OUTB((simplex_stat&0x60),(dma_base + 2));
-				simplex_stat = hwif->INB(dma_base + 2);
+				simplex_stat = inb(dma_base + 2);
+				outb(simplex_stat & 0x60, dma_base + 2);
+				simplex_stat = inb(dma_base + 2);
 				if (simplex_stat & 0x80) {
 					printk(KERN_INFO "%s: simplex device: "
 							 "DMA forced\n",

commit fc212bb1fb538f9453d9ea2cca09749e602055a6
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 19 00:30:08 2007 +0200

    ide: use pci_dev->revision
    
    Some places were using PCI_CLASS_REVISION instead of PCI_REVISION_ID so
    they were not converted by commit 44c10138fd4bbc4b6d6bff0873c24902f2a9da65.
    
    Cc: Auke Kok <auke-jan.h.kok@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 51b1a9b23a22..f187889de70f 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -478,7 +478,6 @@ static void ide_hwif_setup_dma(struct pci_dev *dev, ide_pci_device_t *d, ide_hwi
 static int ide_setup_pci_controller(struct pci_dev *dev, ide_pci_device_t *d, int noisy, int *config)
 {
 	int ret;
-	u32 class_rev;
 	u16 pcicmd;
 
 	if (noisy)
@@ -501,10 +500,9 @@ static int ide_setup_pci_controller(struct pci_dev *dev, ide_pci_device_t *d, in
 		printk(KERN_INFO "%s: device enabled (Linux)\n", d->name);
 	}
 
-	pci_read_config_dword(dev, PCI_CLASS_REVISION, &class_rev);
-	class_rev &= 0xff;
 	if (noisy)
-		printk(KERN_INFO "%s: chipset revision %d\n", d->name, class_rev);
+		printk(KERN_INFO "%s: chipset revision %d\n",
+				 d->name, dev->revision);
 out:
 	return ret;
 }

commit 5f8b6c34854a966fe5eb7241fde0419d47d5d408
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 19 00:30:07 2007 +0200

    ide: add ->mwdma_mask and ->swdma_mask to ide_pci_device_t (take 2)
    
    * Add ->mwdma_mask and ->swdma_mask to ide_pci_device_t.
    
    * Set ide_hwif_t DMA masks using DMA masks from ide_pci_device_t in
      setup-pci.c::ide_pci_setup_ports() (iff DMA base is valid and ->init_hwif
      method may still override them).
    
    * Convert IDE PCI host drivers to use ide_pci_device_t DMA masks.
    
    While at it:
    
    * Use ATA_{UDMA,MWDMA,SWDMA}* defines.
    
    * hpt34x.c: add separate ide_pci_device_t instances for HPT343 and HPT345.
    
    * serverworks.c: fix DMA masks being set before checking DMA base.
    
    v2:
    * Add missing masks to DECLARE_GENERIC_PCI_DEV() macro.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 479add4af499..51b1a9b23a22 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -567,6 +567,12 @@ void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int pciirq, a
 		hwif->host_flags = d->host_flags;
 		hwif->pio_mask = d->pio_mask;
 
+		if (hwif->dma_base) {
+			hwif->swdma_mask = d->swdma_mask;
+			hwif->mwdma_mask = d->mwdma_mask;
+			hwif->ultra_mask = d->udma_mask;
+		}
+
 		if (d->init_hwif)
 			/* Call chipset-specific routine
 			 * for each enabled hwif

commit 9ffcf364f9d0aca3ea79e9987c368eb75925460e
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 19 00:30:07 2007 +0200

    ide: remove ->init_setup_dma from ide_pci_device_t (take 2)
    
    * Make ide_pci_device_t.host_flags u32 and add IDE_HFLAG_CS5520 host flag.
    
    * Pass ide_pci_device_t *d to setup-pci.c::ide_get_or_set_dma_base()
      and use d->name instead of hwif->cds->name.
    
    * Set IDE_HFLAG_CS5520 host flag in cs5520 host driver and use it in
      ide_get_or_set_dma_base() to find out which PCI BAR to use, remove no longer
      needed cs5520.c::cs5520_init_setup_dma() and ide_pci_device_t.init_setup_dma.
    
      This fixes PCI bus-mastering not being checked for CS5510/CS5520 hosts.
    
    v2:
    * It is wrong to check simplex bits on CS5510/CS5520 as v1 did.
      (Noticed by Alan).
    
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 26061fe1b712..479add4af499 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -147,6 +147,7 @@ static int ide_setup_pci_baseregs (struct pci_dev *dev, const char *name)
 #ifdef CONFIG_BLK_DEV_IDEDMA_PCI
 /**
  *	ide_get_or_set_dma_base		-	setup BMIBA
+ *	@d: IDE pci device data
  *	@hwif: Interface
  *
  *	Fetch the DMA Bus-Master-I/O-Base-Address (BMIBA) from PCI space.
@@ -154,7 +155,7 @@ static int ide_setup_pci_baseregs (struct pci_dev *dev, const char *name)
  *	and enforce IDE simplex rules.
  */
 
-static unsigned long ide_get_or_set_dma_base (ide_hwif_t *hwif)
+static unsigned long ide_get_or_set_dma_base(ide_pci_device_t *d, ide_hwif_t *hwif)
 {
 	unsigned long	dma_base = 0;
 	struct pci_dev	*dev = hwif->pci_dev;
@@ -165,14 +166,15 @@ static unsigned long ide_get_or_set_dma_base (ide_hwif_t *hwif)
 	if (hwif->mate && hwif->mate->dma_base) {
 		dma_base = hwif->mate->dma_base - (hwif->channel ? 0 : 8);
 	} else {
-		dma_base = pci_resource_start(dev, 4);
-		if (!dma_base) {
-			printk(KERN_ERR "%s: dma_base is invalid\n",
-					hwif->cds->name);
-		}
+		u8 baridx = (d->host_flags & IDE_HFLAG_CS5520) ? 2 : 4;
+
+		dma_base = pci_resource_start(dev, baridx);
+
+		if (dma_base == 0)
+			printk(KERN_ERR "%s: DMA base is invalid\n", d->name);
 	}
 
-	if (dma_base) {
+	if ((d->host_flags & IDE_HFLAG_CS5520) == 0 && dma_base) {
 		u8 simplex_stat = 0;
 		dma_base += hwif->channel ? 8 : 0;
 
@@ -188,8 +190,8 @@ static unsigned long ide_get_or_set_dma_base (ide_hwif_t *hwif)
 				simplex_stat = hwif->INB(dma_base + 2);
 				if (simplex_stat & 0x80) {
 					printk(KERN_INFO "%s: simplex device: "
-						"DMA forced\n",
-						hwif->cds->name);
+							 "DMA forced\n",
+							 d->name);
 				}
 				break;
 			default:
@@ -212,8 +214,8 @@ static unsigned long ide_get_or_set_dma_base (ide_hwif_t *hwif)
  */
 					if (hwif->mate && hwif->mate->dma_base) {
 						printk(KERN_INFO "%s: simplex device: "
-							"DMA disabled\n",
-							hwif->cds->name);
+								 "DMA disabled\n",
+								 d->name);
 						dma_base = 0;
 					}
 				}
@@ -434,7 +436,7 @@ static void ide_hwif_setup_dma(struct pci_dev *dev, ide_pci_device_t *d, ide_hwi
 	if ((d->host_flags & IDE_HFLAG_NO_AUTODMA) == 0 ||
 	    ((dev->class >> 8) == PCI_CLASS_STORAGE_IDE &&
 	     (dev->class & 0x80))) {
-		unsigned long dma_base = ide_get_or_set_dma_base(hwif);
+		unsigned long dma_base = ide_get_or_set_dma_base(d, hwif);
 		if (dma_base && !(pcicmd & PCI_COMMAND_MASTER)) {
 			/*
  			 * Set up BM-DMA capability
@@ -559,14 +561,9 @@ void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int pciirq, a
 		if (d->init_iops)
 			d->init_iops(hwif);
 
-		if (d->host_flags & IDE_HFLAG_NO_DMA)
-			goto bypass_legacy_dma;
-
-		if(d->init_setup_dma)
-			d->init_setup_dma(dev, d, hwif);
-		else
+		if ((d->host_flags & IDE_HFLAG_NO_DMA) == 0)
 			ide_hwif_setup_dma(dev, d, hwif);
-bypass_legacy_dma:
+
 		hwif->host_flags = d->host_flags;
 		hwif->pio_mask = d->pio_mask;
 

commit 47b687882c02f802dd5bbe1227effe006820246e
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 19 00:30:06 2007 +0200

    ide: add IDE_HFLAG_NO_{DMA,AUTODMA} host flags
    
    Add IDE_HFLAG_NO_{DMA,AUTODMA} host flags.  Convert all host drivers using
    ide_pci_device_t to use these flags instead of d->autodma and then remove no
    longer needed d->autodma.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index d5901ec9e8cc..26061fe1b712 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -428,9 +428,10 @@ static void ide_hwif_setup_dma(struct pci_dev *dev, ide_pci_device_t *d, ide_hwi
 static void ide_hwif_setup_dma(struct pci_dev *dev, ide_pci_device_t *d, ide_hwif_t *hwif)
 {
 	u16 pcicmd;
+
 	pci_read_config_word(dev, PCI_COMMAND, &pcicmd);
 
-	if ((d->autodma == AUTODMA) ||
+	if ((d->host_flags & IDE_HFLAG_NO_AUTODMA) == 0 ||
 	    ((dev->class >> 8) == PCI_CLASS_STORAGE_IDE &&
 	     (dev->class & 0x80))) {
 		unsigned long dma_base = ide_get_or_set_dma_base(hwif);
@@ -558,7 +559,7 @@ void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int pciirq, a
 		if (d->init_iops)
 			d->init_iops(hwif);
 
-		if (d->autodma == NODMA)
+		if (d->host_flags & IDE_HFLAG_NO_DMA)
 			goto bypass_legacy_dma;
 
 		if(d->init_setup_dma)

commit 7cab14a79973893392111b8f887856a54621f759
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 19 00:30:06 2007 +0200

    ide: add IDE_HFLAG_BOOTABLE host flag
    
    Add IDE_HFLAG_BOOTABLE host flag and IDE_HFLAG_OFF_BOARD define.  Convert
    all host drivers using ide_pci_device_t to use IDE_HFLAG_{BOOTABLE,OFF_BOARD}
    instead of d->bootable and then remove no longer needed d->bootable.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 3d101f73f910..d5901ec9e8cc 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -360,6 +360,7 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev, ide_pci_device_t *d,
 {
 	unsigned long ctl = 0, base = 0;
 	ide_hwif_t *hwif;
+	u8 bootable = (d->host_flags & IDE_HFLAG_BOOTABLE) ? 1 : 0;
 
 	if ((d->host_flags & IDE_HFLAG_ISA_PORTS) == 0) {
 		/*  Possibly we should fail if these checks report true */
@@ -380,7 +381,7 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev, ide_pci_device_t *d,
 		ctl = port ? 0x374 : 0x3f4;
 		base = port ? 0x170 : 0x1f0;
 	}
-	if ((hwif = ide_match_hwif(base, d->bootable, d->name)) == NULL)
+	if ((hwif = ide_match_hwif(base, bootable, d->name)) == NULL)
 		return NULL;	/* no room in ide_hwifs[] */
 	if (hwif->io_ports[IDE_DATA_OFFSET] != base ||
 	    hwif->io_ports[IDE_CONTROL_OFFSET] != (ctl | 2)) {

commit 9ff6f72f432364991d68e99cae72cb141c166e70
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Oct 16 22:29:58 2007 +0200

    ide: remove hwif->autodma and drive->autodma
    
    * hpt34x.c: disable DMA masks for HPT345
      (hwif->autodma is zero so DMA won't be enabled anyway).
    
    * trm290.c: disable IDE_HFLAG_TRUST_BIOS_FOR_DMA flag
      (hwif->autodma is zero so DMA won't be enabled anyway).
    
    * Check noautodma global variable instead of drive->autodma in ide_tune_dma().
    
      This fixes handling of "ide=nodma" kernel parameter for icside, ide-cris,
      au1xxx-ide, pmac, it821x, jmicron, sgiioc4 and siimage host drivers.
    
    * Remove hwif->autodma (it was not checked by IDE core code anyway) and
      drive->autodma (was set by all host drivers - except HPT345/TRM290 special
      cases - unless "ide=nodma" was used).
    
    While at it:
    - remove needless printk() from icside.c
    - remove stale FIXME/comment from ide-probe.c
    - don't force DMA off if PCI bus-mastering had to be enabled in setup-pci.c
      (this setting was always later over-ridden by host drivers anyway)
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index f620da42e157..3d101f73f910 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -438,8 +438,6 @@ static void ide_hwif_setup_dma(struct pci_dev *dev, ide_pci_device_t *d, ide_hwi
  			 * Set up BM-DMA capability
 			 * (PnP BIOS should have done this)
  			 */
-			/* default DMA off if we had to configure it here */
-			hwif->autodma = 0;
 			pci_set_master(dev);
 			if (pci_read_config_word(dev, PCI_COMMAND, &pcicmd) || !(pcicmd & PCI_COMMAND_MASTER)) {
 				printk(KERN_ERR "%s: %s error updating PCICMD\n",

commit c58e79dd44243ec919d789193ffb35a220c54695
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Oct 16 22:29:56 2007 +0200

    ide: remove CONFIG_BLK_DEV_IDEDMA_FORCED
    
    This code doesn't use pci_assign_resource() and ide_get_or_set_dma_base() uses
    pci_resource_start() to get DMA base address so it has no chance of working.
    Moreover this belongs to PCI quirks (in case somebody would like to fix it).
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 1129f8c30840..f620da42e157 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -145,27 +145,13 @@ static int ide_setup_pci_baseregs (struct pci_dev *dev, const char *name)
 }
 
 #ifdef CONFIG_BLK_DEV_IDEDMA_PCI
-
-#ifdef CONFIG_BLK_DEV_IDEDMA_FORCED
-/*
- * Long lost data from 2.0.34 that is now in 2.0.39
- *
- * This was used in ./drivers/block/triton.c to do DMA Base address setup
- * when PnP failed.  Oh the things we forget.  I believe this was part
- * of SFF-8038i that has been withdrawn from public access... :-((
- */
-#define DEFAULT_BMIBA	0xe800	/* in case BIOS did not init it */
-#define DEFAULT_BMCRBA	0xcc00	/* VIA's default value */
-#define DEFAULT_BMALIBA	0xd400	/* ALI's default value */
-#endif /* CONFIG_BLK_DEV_IDEDMA_FORCED */
-
 /**
  *	ide_get_or_set_dma_base		-	setup BMIBA
  *	@hwif: Interface
  *
- *	Fetch the DMA Bus-Master-I/O-Base-Address (BMIBA) from PCI space:
- *	If need be we set up the DMA base. Where a device has a partner that
- *	is already in DMA mode we check and enforce IDE simplex rules.
+ *	Fetch the DMA Bus-Master-I/O-Base-Address (BMIBA) from PCI space.
+ *	Where a device has a partner that is already in DMA mode we check
+ *	and enforce IDE simplex rules.
  */
 
 static unsigned long ide_get_or_set_dma_base (ide_hwif_t *hwif)
@@ -173,12 +159,6 @@ static unsigned long ide_get_or_set_dma_base (ide_hwif_t *hwif)
 	unsigned long	dma_base = 0;
 	struct pci_dev	*dev = hwif->pci_dev;
 
-#ifdef CONFIG_BLK_DEV_IDEDMA_FORCED
-	int second_chance = 0;
-
-second_chance_to_dma:
-#endif /* CONFIG_BLK_DEV_IDEDMA_FORCED */
-
 	if (hwif->mmio)
 		return hwif->dma_base;
 
@@ -192,26 +172,6 @@ static unsigned long ide_get_or_set_dma_base (ide_hwif_t *hwif)
 		}
 	}
 
-#ifdef CONFIG_BLK_DEV_IDEDMA_FORCED
-	/* FIXME - should use pci_assign_resource surely */
-	if ((!dma_base) && (!second_chance)) {
-		unsigned long set_bmiba = 0;
-		second_chance++;
-		switch(dev->vendor) {
-			case PCI_VENDOR_ID_AL:
-				set_bmiba = DEFAULT_BMALIBA; break;
-			case PCI_VENDOR_ID_VIA:
-				set_bmiba = DEFAULT_BMCRBA; break;
-			case PCI_VENDOR_ID_INTEL:
-				set_bmiba = DEFAULT_BMIBA; break;
-			default:
-				return dma_base;
-		}
-		pci_write_config_dword(dev, 0x20, set_bmiba|1);
-		goto second_chance_to_dma;
-	}
-#endif /* CONFIG_BLK_DEV_IDEDMA_FORCED */
-
 	if (dma_base) {
 		u8 simplex_stat = 0;
 		dma_base += hwif->channel ? 8 : 0;

commit 0505b55fb51fa289027f33ae793995c191277536
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Tue Sep 11 22:28:34 2007 +0200

    ide: fix PCI refcounting
    
    The IDE core never marked the PCI IDE devices as being in use after succesfull
    driver probe call (the devices were marked in use only while being probed), and
    so was susceptible to issues caused by unsolicited PCI hotplug device removal.
    So, add pci_dev_get() call to ide_scan_pcidev() and convert this function to
    the kernel style, also dropping a bunch of useless curly braces from its caller,
    ide_scan_pcibus() and somewhat beautifying printk() call there, while at it...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 30e596c0f120..1129f8c30840 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -816,19 +816,15 @@ static int __init ide_scan_pcidev(struct pci_dev *dev)
 	struct list_head *l;
 	struct pci_driver *d;
 	
-	list_for_each(l, &ide_pci_drivers)
-	{
+	list_for_each(l, &ide_pci_drivers) {
 		d = list_entry(l, struct pci_driver, node);
-		if(d->id_table)
-		{
-			const struct pci_device_id *id = pci_match_id(d->id_table, dev);
-			if(id != NULL)
-			{
-				if(d->probe(dev, id) >= 0)
-				{
-					dev->driver = d;
-					return 1;
-				}
+		if (d->id_table) {
+			const struct pci_device_id *id = pci_match_id(d->id_table,
+								      dev);
+			if (id != NULL && d->probe(dev, id) >= 0) {
+				dev->driver = d;
+				pci_dev_get(dev);
+				return 1;
 			}
 		}
 	}
@@ -851,15 +847,13 @@ void __init ide_scan_pcibus (int scan_direction)
 	struct list_head *l, *n;
 
 	pre_init = 0;
-	if (!scan_direction) {
-		while ((dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL) {
+	if (!scan_direction)
+		while ((dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL)
 			ide_scan_pcidev(dev);
-		}
-	} else {
-		while ((dev = pci_get_device_reverse(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL) {
+	else
+		while ((dev = pci_get_device_reverse(PCI_ANY_ID, PCI_ANY_ID, dev))
+		       != NULL)
 			ide_scan_pcidev(dev);
-		}
-	}
 	
 	/*
 	 *	Hand the drivers over to the PCI layer now we
@@ -869,12 +863,9 @@ void __init ide_scan_pcibus (int scan_direction)
 	list_for_each_safe(l, n, &ide_pci_drivers) {
 		list_del(l);
 		d = list_entry(l, struct pci_driver, node);
-		if (__pci_register_driver(d, d->driver.owner,
-					d->driver.mod_name)) {
-			printk(KERN_ERR "%s: failed to register driver "
-					"for %s\n", __FUNCTION__,
-					 d->driver.mod_name);
-		}
+		if (__pci_register_driver(d, d->driver.owner, d->driver.mod_name))
+			printk(KERN_ERR "%s: failed to register driver for %s\n",
+			       __FUNCTION__, d->driver.mod_name);
 	}
 }
 #endif

commit 4bf9fdf7f21f118e2c5052ec8e46faf00eb5a4ea
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jul 20 01:11:59 2007 +0200

    ide: remove stale changelog from setup-pci.c
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index f9e455cc8092..30e596c0f120 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -5,12 +5,6 @@
  *
  *  Copyright (c) 1995-1998  Mark Lord
  *  May be copied or modified under the terms of the GNU General Public License
- *
- *  Recent Changes
- *	Split the set up function into multiple functions
- *	Use pci_set_master
- *	Fix misreporting of I/O v MMIO problems
- *	Initial fixups for simplex devices
  */
 
 /*

commit 4099d14322149c7a467e4997b87be4ba8eb78697
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jul 20 01:11:59 2007 +0200

    ide: add PIO masks
    
    * Add ATA_PIO[0-6] defines to <linux/ata.h>.
    
    * Add ->pio_mask field to ide_pci_device_t and ide_hwif_t.
    
    * Add PIO masks to host drivers.
    
    <linux/ata.h> change ACK-ed by Jeff Garzik <jeff@garzik.org>.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index e9f3267456e2..f9e455cc8092 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -614,6 +614,7 @@ void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int pciirq, a
 			ide_hwif_setup_dma(dev, d, hwif);
 bypass_legacy_dma:
 		hwif->host_flags = d->host_flags;
+		hwif->pio_mask = d->pio_mask;
 
 		if (d->init_hwif)
 			/* Call chipset-specific routine

commit 6a824c92db4d606c324272c4eed366fb71672440
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jul 20 01:11:58 2007 +0200

    ide: remove ide_find_best_pio_mode()
    
    * Add ->host_flags to ide_hwif_t to store ide_pci_device_t.host_flags,
      assign it in setup-pci.c:ide_pci_setup_ports().
    
    * Add IDE_HFLAG_PIO_NO_{BLACKLIST,DOWNGRADE} to ide_pci_device_t.host_flags
      and teach ide_get_best_pio_mode() about them.  Also remove needless
      !drive->id check while at it (drive->id is always present).
    
    * Convert amd74xx, via82cxxx and ide-timing.h to use ide_get_best_pio_mode()
      and then remove no longer needed ide_find_best_pio_mode().
    
    There should be no functionality changes caused by this patch.
    
    Acked-by: Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index bfe1f4e59597..e9f3267456e2 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -613,6 +613,8 @@ void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int pciirq, a
 		else
 			ide_hwif_setup_dma(dev, d, hwif);
 bypass_legacy_dma:
+		hwif->host_flags = d->host_flags;
+
 		if (d->init_hwif)
 			/* Call chipset-specific routine
 			 * for each enabled hwif

commit a5d8c5c834d3cabf4b7b477c3f6ee923c25026fc
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jul 20 01:11:55 2007 +0200

    ide: add ide_pci_device_t.host_flags (take 2)
    
    * Rename ide_pci_device_t.flags to ide_pci_device_t.host_flags
      and IDEPCI_FLAG_ISA_PORTS flag to IDE_HFLAG_ISA_PORTS.
    
    * Add IDE_HFLAG_SINGLE flag for single channel devices.
    
    * Convert core code and all IDE PCI drivers to use IDE_HFLAG_SINGLE
      and remove no longer needed ide_pci_device_t.channels field.
    
    v2:
    * Fix issues noticed by Sergei:
      - correct code alignment in scc_pata.c
      - s/IDE_HFLAG_SINGLE/~IDE_HFLAG_SINGLE/ in serverworks.c
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index c88d33225cf9..bfe1f4e59597 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -407,7 +407,7 @@ static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev, ide_pci_device_t *d,
 	unsigned long ctl = 0, base = 0;
 	ide_hwif_t *hwif;
 
-	if ((d->flags & IDEPCI_FLAG_ISA_PORTS) == 0) {
+	if ((d->host_flags & IDE_HFLAG_ISA_PORTS) == 0) {
 		/*  Possibly we should fail if these checks report true */
 		ide_pci_check_iomem(dev, d, 2*port);
 		ide_pci_check_iomem(dev, d, 2*port+1);
@@ -571,7 +571,7 @@ static int ide_setup_pci_controller(struct pci_dev *dev, ide_pci_device_t *d, in
  
 void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int pciirq, ata_index_t *index)
 {
-	int port;
+	int channels = (d->host_flags & IDE_HFLAG_SINGLE) ? 1 : 2, port;
 	int at_least_one_hwif_enabled = 0;
 	ide_hwif_t *hwif, *mate = NULL;
 	u8 tmp;
@@ -582,16 +582,13 @@ void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int pciirq, a
 	 * Set up the IDE ports
 	 */
 	 
-	for (port = 0; port <= 1; ++port) {
+	for (port = 0; port < channels; ++port) {
 		ide_pci_enablebit_t *e = &(d->enablebits[port]);
 	
 		if (e->reg && (pci_read_config_byte(dev, e->reg, &tmp) ||
 		    (tmp & e->mask) != e->val))
 			continue;	/* port not enabled */
 
-		if (d->channels	<= port)
-			break;
-	
 		if ((hwif = ide_hwif_configure(dev, d, mate, port, pciirq)) == NULL)
 			continue;
 

commit d61bcce9c1aa2c9f8a768d73c4c517f81d226725
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Tue Jul 3 22:28:36 2007 +0200

    ide: ide_scan_pcibus(): check __pci_register_driver return value
    
    drivers/ide/setup-pci.c: In function 'ide_scan_pcibus':
    drivers/ide/setup-pci.c:879: warning: ignoring return value of '__pci_register_driver', declared with attribute warn_unused_result
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 67035ba4bf5e..c88d33225cf9 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -872,11 +872,15 @@ void __init ide_scan_pcibus (int scan_direction)
 	 *	are post init.
 	 */
 
-	list_for_each_safe(l, n, &ide_pci_drivers)
-	{
+	list_for_each_safe(l, n, &ide_pci_drivers) {
 		list_del(l);
 		d = list_entry(l, struct pci_driver, node);
-		__pci_register_driver(d, d->driver.owner, d->driver.mod_name);
+		if (__pci_register_driver(d, d->driver.owner,
+					d->driver.mod_name)) {
+			printk(KERN_ERR "%s: failed to register driver "
+					"for %s\n", __FUNCTION__,
+					 d->driver.mod_name);
+		}
 	}
 }
 #endif

commit 6d208b39c45edee5def6c201fcd51561c5a39828
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu May 10 00:01:11 2007 +0200

    ide: legacy PCI bus order probing fixes
    
    IDE PCI host drivers should register themselves with IDE core only when
    IDE driver is built-in, otherwise (IDE driver is modular and thus IDE PCI
    host drivers are also modular) the code has no effect and just complicates
    the probing.
    
    Fix it by adding new config option CONFIG_IDEPCI_PCIBUS (defined only when
    needed and invisible to the user) and covering by #ifdef/#endif the code
    in question.  It turned out that "ide=reverse" was silently accepted but did
    nothing in case when IDE driver was modular, this is fixed now.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 892cda755782..67035ba4bf5e 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -772,6 +772,7 @@ int ide_setup_pci_devices(struct pci_dev *dev1, struct pci_dev *dev2,
 
 EXPORT_SYMBOL_GPL(ide_setup_pci_devices);
 
+#ifdef CONFIG_IDEPCI_PCIBUS_ORDER
 /*
  *	Module interfaces
  */
@@ -878,3 +879,4 @@ void __init ide_scan_pcibus (int scan_direction)
 		__pci_register_driver(d, d->driver.owner, d->driver.mod_name);
 	}
 }
+#endif

commit 5cbf79cdb37be2aa2a1b4fa94144526b14557060
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu May 10 00:01:11 2007 +0200

    ide: add ide_proc_register_port()
    
    * create_proc_ide_interfaces() tries to add /proc entries for every probed
      and initialized IDE port, replace it by ide_proc_register_port() which does
      it only for the given port (also rename destroy_proc_ide_interface() to
      ide_proc_unregister_port() for consistency)
    
    * convert {create,destroy}_proc_ide_interface[s]() users to use new functions
    
    * pmac driver depended on proc_ide_create() to add /proc port entries, fix it
    
    * au1xxx-ide, swarm and cs5520 drivers depended indirectly on ide-generic
      driver (CONFIG_IDE_GENERIC=y) to add port /proc entries, fix them
    
    * there is now no need to add /proc entries for IDE ports in proc_ide_create()
      so don't do it
    
    * proc_ide_create() needs now to be called before drivers are probed - fix it,
      while at it make proc_ide_create() create /proc "ide" directory
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 118fb3205ca8..892cda755782 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -702,6 +702,7 @@ static int do_ide_setup_pci_device(struct pci_dev *dev, ide_pci_device_t *d,
 
 int ide_setup_pci_device(struct pci_dev *dev, ide_pci_device_t *d)
 {
+	ide_hwif_t *hwif = NULL, *mate = NULL;
 	ata_index_t index_list;
 	int ret;
 
@@ -710,11 +711,19 @@ int ide_setup_pci_device(struct pci_dev *dev, ide_pci_device_t *d)
 		goto out;
 
 	if ((index_list.b.low & 0xf0) != 0xf0)
-		probe_hwif_init_with_fixup(&ide_hwifs[index_list.b.low], d->fixup);
+		hwif = &ide_hwifs[index_list.b.low];
 	if ((index_list.b.high & 0xf0) != 0xf0)
-		probe_hwif_init_with_fixup(&ide_hwifs[index_list.b.high], d->fixup);
+		mate = &ide_hwifs[index_list.b.high];
 
-	create_proc_ide_interfaces();
+	if (hwif)
+		probe_hwif_init_with_fixup(hwif, d->fixup);
+	if (mate)
+		probe_hwif_init_with_fixup(mate, d->fixup);
+
+	if (hwif)
+		ide_proc_register_port(hwif);
+	if (mate)
+		ide_proc_register_port(mate);
 out:
 	return ret;
 }
@@ -748,7 +757,15 @@ int ide_setup_pci_devices(struct pci_dev *dev1, struct pci_dev *dev2,
 		}
 	}
 
-	create_proc_ide_interfaces();
+	for (i = 0; i < 2; i++) {
+		u8 idx[2] = { index_list[i].b.low, index_list[i].b.high };
+		int j;
+
+		for (j = 0; j < 2; j++) {
+			if ((idx[j] & 0xf0) != 0xf0)
+				ide_proc_register_port(ide_hwifs + idx[j]);
+		}
+	}
 out:
 	return ret;
 }

commit 120b9cfddff2e398fece07c5e127f3fdbb660441
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Mar 17 21:57:41 2007 +0100

    ide: remove CONFIG_IDEDMA_{ICS,PCI}_AUTO config options
    
    All modern distributions have been setting these options to "y" for ages.
    (additionally "n" cases have been obsoleted for few years).  Therefore use
    DMA by default and remove CONFIG_IDEDMA_{ICS,PCI}_AUTO (also remove no longer
    needed CONFIG_IDEDMA_AUTO).  This fixes DMA support for rare configurations
    where CONFIG_IDEDMA_{ICS,PCI}_AUTO was set to "n" but "hdparm -d 1" was used
    to enable DMA support and which were forced to PIO mode by "ide: don't allow
    DMA to be enabled if CONFIG_IDEDMA_{ICS,PCI}_AUTO=n" patch.  There is no
    functionality loss because "ide=nodma" kernel option is still available.
    
    Cc: Patrick Horn <phrh@yahoo.com>
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: Russell King <rmk+lkml@arm.linux.org.uk>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index a52c80fe7d3e..118fb3205ca8 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -505,11 +505,6 @@ static void ide_hwif_setup_dma(struct pci_dev *dev, ide_pci_device_t *d, ide_hwi
 		}
 	}
 }
-
-#ifndef CONFIG_IDEDMA_PCI_AUTO
-#warning CONFIG_IDEDMA_PCI_AUTO=n support is obsolete, and will be removed soon.
-#endif
-
 #endif /* CONFIG_BLK_DEV_IDEDMA_PCI*/
 
 /**

commit 725522b5453dd680412f2b6463a988e4fd148757
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jan 15 11:50:02 2007 -0800

    PCI: add the sysfs driver name to all modules
    
    This adds the module name to all PCI drivers, if they are built into the
    kernel or not.  It will show up in /sys/modules/MODULE_NAME/drivers/
    
    It also fixes up the IDE core, which was calling __pci_register_driver()
    directly.
    
    Cc: Kay Sievers <kay.sievers@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 695e23904d30..a52c80fe7d3e 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -783,10 +783,11 @@ static LIST_HEAD(ide_pci_drivers);
  *	Returns are the same as for pci_register_driver
  */
 
-int __ide_pci_register_driver(struct pci_driver *driver, struct module *module)
+int __ide_pci_register_driver(struct pci_driver *driver, struct module *module,
+			      const char *mod_name)
 {
 	if(!pre_init)
-		return __pci_register_driver(driver, module);
+		return __pci_register_driver(driver, module, mod_name);
 	driver->driver.owner = module;
 	list_add_tail(&driver->node, &ide_pci_drivers);
 	return 0;
@@ -862,6 +863,6 @@ void __init ide_scan_pcibus (int scan_direction)
 	{
 		list_del(l);
 		d = list_entry(l, struct pci_driver, node);
-		__pci_register_driver(d, d->driver.owner);
+		__pci_register_driver(d, d->driver.owner, d->driver.mod_name);
 	}
 }

commit 6451956a24963d3eb1655fd039762ae42ac48da7
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Sun Dec 10 02:18:53 2006 -0800

    [PATCH] ide: complete switch to pci_get
    
    The reverse get function allows the final piece of the switching for the old
    IDE layer
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 0719b6484824..695e23904d30 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -844,11 +844,11 @@ void __init ide_scan_pcibus (int scan_direction)
 
 	pre_init = 0;
 	if (!scan_direction) {
-		while ((dev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL) {
+		while ((dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL) {
 			ide_scan_pcidev(dev);
 		}
 	} else {
-		while ((dev = pci_find_device_reverse(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL) {
+		while ((dev = pci_get_device_reverse(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL) {
 			ide_scan_pcidev(dev);
 		}
 	}

commit 27ac6036f31dea8117ecc525e0dbfd17b23e8c09
Author: Adrian Bunk <bunk@stusta.de>
Date:   Tue Oct 3 01:14:24 2006 -0700

    [PATCH] drivers/ide/: cleanups
    
    - setup-pci.c: remove the unused ide_pci_unregister_driver()
    - ide-dma.c: remove the unused EXPORT_SYMBOL_GPL(ide_in_drive_list)
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Acked-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Bartlomiej Zolnierkiewicz <B.Zolnierkiewicz@elka.pw.edu.pl>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 157fe93ea342..0719b6484824 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -794,24 +794,6 @@ int __ide_pci_register_driver(struct pci_driver *driver, struct module *module)
 
 EXPORT_SYMBOL_GPL(__ide_pci_register_driver);
 
-/**
- *	ide_unregister_pci_driver	-	unregister an IDE driver
- *	@driver: driver to remove
- *
- *	Unregister a currently installed IDE driver. Returns are the same
- *	as for pci_unregister_driver
- */
- 
-void ide_pci_unregister_driver(struct pci_driver *driver)
-{
-	if(!pre_init)
-		pci_unregister_driver(driver);
-	else
-		list_del(&driver->node);
-}
-
-EXPORT_SYMBOL_GPL(ide_pci_unregister_driver);
-
 /**
  *	ide_scan_pcidev		-	find an IDE driver for a device
  *	@dev: PCI device to check

commit 83d7dbc4095a0c314b191c573be5fb4fa6ce0897
Author: Matt Mackall <mpm@selenic.com>
Date:   Tue Oct 3 01:14:16 2006 -0700

    [PATCH] Make number of IDE interfaces configurable
    
    Make IDE_HWIFS configurable if EMBEDDED
    
    This lets us lop as much as 16k off an x86 build.  It's a little ugly, but
    it's dead simple.  Note the fix for HWIFS < 2.
    
    Sizing interfaces dynamically unfortunately turns out to be pretty
    major surgery.
    
    add/remove: 0/1 grow/shrink: 0/11 up/down: 0/-16182 (-16182)
    function                                     old     new   delta
    ide_hwifs                                  16920    1692  -15228
    init_irq                                    1113     750    -363
    ideprobe_init                                283     138    -145
    ide_pci_setup_ports                         1329    1193    -136
    save_match                                    85       -     -85
    ide_register_hw_with_fixup                   367     287     -80
    ide_setup                                   1364    1308     -56
    is_chipset_set                                40       4     -36
    create_proc_ide_interfaces                   225     205     -20
    init_ide_data                                 84      67     -17
    ide_probe_for_cmd640x                       1198    1183     -15
    ide_unregister                              1452    1451      -1
    
    Signed-off-by: Matt Mackall <mpm@selenic.com>
    Cc: Bartlomiej Zolnierkiewicz <B.Zolnierkiewicz@elka.pw.edu.pl>
    Acked-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index eb0945284acc..157fe93ea342 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -101,7 +101,7 @@ static ide_hwif_t *ide_match_hwif(unsigned long io_base, u8 bootable, const char
 				return hwif;	/* pick an unused entry */
 		}
 	}
-	for (h = 0; h < 2; ++h) {
+	for (h = 0; h < 2 && h < MAX_HWIFS; ++h) {
 		hwif = ide_hwifs + h;
 		if (hwif->chipset == ide_unknown)
 			return hwif;	/* pick an unused entry */

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index c11e3b2e67a6..eb0945284acc 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -18,7 +18,6 @@
  *  configuration of all PCI IDE interfaces present in a system.  
  */
 
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/types.h>
 #include <linux/kernel.h>

commit c6387a48cf5958e43c201fc27a158c328927531a
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jun 20 01:21:29 2006 -0700

    [SPARC]: Kill __irq_itoa().
    
    This ugly hack was long overdue to die.
    
    It was a way to print out Sparc interrupts in a more freindly format,
    since IRQ numbers were arbitrary opaque 32-bit integers which vectored
    into PIL levels.  These 32-bit integers were not necessarily in the
    0-->NR_IRQS range, but the PILs they vectored to were.
    
    The idea now is that we will increase NR_IRQS a little bit and use a
    virtual<-->real IRQ number mapping scheme similar to PowerPC.
    
    That makes this IRQ printing hack irrelevant, and furthermore only a
    handful of drivers actually used __irq_itoa() making it even less
    useful.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 462ed3006c30..c11e3b2e67a6 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -694,13 +694,8 @@ static int do_ide_setup_pci_device(struct pci_dev *dev, ide_pci_device_t *d,
 				goto out;
 		}
 		if (noisy)
-#ifdef __sparc__
-			printk(KERN_INFO "%s: 100%% native mode on irq %s\n",
-			       d->name, __irq_itoa(pciirq));
-#else
 			printk(KERN_INFO "%s: 100%% native mode on irq %d\n",
 				d->name, pciirq);
-#endif
 	}
 
 	/* FIXME: silent failure can happen */

commit d3a7b202995421631f486313aacf9ab2ad48b2c8
Author: Adrian Bunk <bunk@stusta.de>
Date:   Tue Apr 18 22:22:07 2006 -0700

    [PATCH] remove the obsolete IDEPCI_FLAG_FORCE_PDC
    
    Noted by Sergei Shtylylov <sshtylyov@ru.mvista.com>
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Acked-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 7ebf992e8c2f..462ed3006c30 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -580,7 +580,6 @@ void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int pciirq, a
 	int port;
 	int at_least_one_hwif_enabled = 0;
 	ide_hwif_t *hwif, *mate = NULL;
-	static int secondpdc = 0;
 	u8 tmp;
 
 	index->all = 0xf0f0;
@@ -592,21 +591,9 @@ void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int pciirq, a
 	for (port = 0; port <= 1; ++port) {
 		ide_pci_enablebit_t *e = &(d->enablebits[port]);
 	
-		/* 
-		 * If this is a Promise FakeRaid controller,
-		 * the 2nd controller will be marked as 
-		 * disabled while it is actually there and enabled
-		 * by the bios for raid purposes. 
-		 * Skip the normal "is it enabled" test for those.
-		 */
-		if ((d->flags & IDEPCI_FLAG_FORCE_PDC) &&
-		    (secondpdc++==1) && (port==1))
-			goto controller_ok;
-			
 		if (e->reg && (pci_read_config_byte(dev, e->reg, &tmp) ||
 		    (tmp & e->mask) != e->val))
 			continue;	/* port not enabled */
-controller_ok:
 
 		if (d->channels	<= port)
 			break;

commit c37ea218cb43c67bf1578f5e535fcc3a751018ef
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Fri Nov 18 23:11:24 2005 +0100

    [PATCH] ide: make comment match reality
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index d4f2111d4364..7ebf992e8c2f 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -787,7 +787,7 @@ static int pre_init = 1;		/* Before first ordered IDE scan */
 static LIST_HEAD(ide_pci_drivers);
 
 /*
- *	__ide_register_pci_driver	-	attach IDE driver
+ *	__ide_pci_register_driver	-	attach IDE driver
  *	@driver: pci driver
  *	@module: owner module of the driver
  *

commit 863b18f4b5e7d9e6903b353328cf6fa084dbb619
Author: Laurent riffard <laurent.riffard@free.fr>
Date:   Thu Oct 27 23:12:54 2005 +0200

    [PATCH] PCI: automatically set device_driver.owner
    
    A nice feature of sysfs is that it can create the symlink from the
    driver to the module that is contained in it.
    
    It requires that the device_driver.owner is set, what is not the
    case for many PCI drivers.
    
    This patch allows pci_register_driver to set automatically the
    device_driver.owner for any PCI driver.
    
    Credits to Al Viro who suggested the method.
    
    Signed-off-by: Laurent Riffard <laurent.riffard@free.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    --
    
     drivers/ide/setup-pci.c  |   12 +++++++-----
     drivers/pci/pci-driver.c |    9 +++++----
     include/linux/ide.h      |    3 ++-
     include/linux/pci.h      |   10 ++++++++--
     4 files changed, 22 insertions(+), 12 deletions(-)

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 18ed7765417c..d4f2111d4364 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -787,8 +787,9 @@ static int pre_init = 1;		/* Before first ordered IDE scan */
 static LIST_HEAD(ide_pci_drivers);
 
 /*
- *	ide_register_pci_driver		-	attach IDE driver
+ *	__ide_register_pci_driver	-	attach IDE driver
  *	@driver: pci driver
+ *	@module: owner module of the driver
  *
  *	Registers a driver with the IDE layer. The IDE layer arranges that
  *	boot time setup is done in the expected device order and then 
@@ -801,15 +802,16 @@ static LIST_HEAD(ide_pci_drivers);
  *	Returns are the same as for pci_register_driver
  */
 
-int ide_pci_register_driver(struct pci_driver *driver)
+int __ide_pci_register_driver(struct pci_driver *driver, struct module *module)
 {
 	if(!pre_init)
-		return pci_module_init(driver);
+		return __pci_register_driver(driver, module);
+	driver->driver.owner = module;
 	list_add_tail(&driver->node, &ide_pci_drivers);
 	return 0;
 }
 
-EXPORT_SYMBOL_GPL(ide_pci_register_driver);
+EXPORT_SYMBOL_GPL(__ide_pci_register_driver);
 
 /**
  *	ide_unregister_pci_driver	-	unregister an IDE driver
@@ -897,6 +899,6 @@ void __init ide_scan_pcibus (int scan_direction)
 	{
 		list_del(l);
 		d = list_entry(l, struct pci_driver, node);
-		pci_register_driver(d);
+		__pci_register_driver(d, d->driver.owner);
 	}
 }

commit 2f09a7f4af131bf23c013ead89373deba1c7593c
Author: Matt Gillette <matt.gillette@netcell.com>
Date:   Thu Aug 18 22:27:07 2005 +0200

    [PATCH] ide: add support for Netcell Revolution to pci-ide generic driver
    
    Adds support for Netcell Revolution to pci-ide generic driver by including
    it in the list of devices matched.  Includes the Revolution in the list of
    simplex devices forced into DMA mode.
    
    Signed-off-by: Matt Gillette <matt.gillette@netcell.com>
    Cc: Bartlomiej Zolnierkiewicz <B.Zolnierkiewicz@elka.pw.edu.pl>
    Cc: Jeff Garzik <jgarzik@pobox.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index 77da827b2898..18ed7765417c 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -229,6 +229,7 @@ static unsigned long ide_get_or_set_dma_base (ide_hwif_t *hwif)
 			case PCI_DEVICE_ID_AMD_VIPER_7409:
 			case PCI_DEVICE_ID_CMD_643:
 			case PCI_DEVICE_ID_SERVERWORKS_CSB5IDE:
+			case PCI_DEVICE_ID_REVOLUTION:
 				simplex_stat = hwif->INB(dma_base + 2);
 				hwif->OUTB((simplex_stat&0x60),(dma_base + 2));
 				simplex_stat = hwif->INB(dma_base + 2);

commit 75865858971add95809c5c9cd35dc4cfba08e33b
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jun 30 02:18:12 2005 -0700

    [PATCH] PCI: clean up dynamic pci id logic
    
    The dynamic pci id logic has been bothering me for a while, and now that
    I started to look into how to move some of this to the driver core, I
    thought it was time to clean it all up.
    
    It ends up making the code smaller, and easier to follow, and fixes a
    few bugs at the same time (dynamic ids were not being matched
    everywhere, and so could be missed on some call paths for new devices,
    semaphore not needed to be grabbed when adding a new id and calling the
    driver core, etc.)
    
    I also renamed the function pci_match_device() to pci_match_id() as
    that's what it really does.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
index e501675ad72e..77da827b2898 100644
--- a/drivers/ide/setup-pci.c
+++ b/drivers/ide/setup-pci.c
@@ -847,7 +847,7 @@ static int __init ide_scan_pcidev(struct pci_dev *dev)
 		d = list_entry(l, struct pci_driver, node);
 		if(d->id_table)
 		{
-			const struct pci_device_id *id = pci_match_device(d->id_table, dev);
+			const struct pci_device_id *id = pci_match_id(d->id_table, dev);
 			if(id != NULL)
 			{
 				if(d->probe(dev, id) >= 0)

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
new file mode 100644
index 000000000000..e501675ad72e
--- /dev/null
+++ b/drivers/ide/setup-pci.c
@@ -0,0 +1,901 @@
+/*
+ *  linux/drivers/ide/setup-pci.c		Version 1.10	2002/08/19
+ *
+ *  Copyright (c) 1998-2000  Andre Hedrick <andre@linux-ide.org>
+ *
+ *  Copyright (c) 1995-1998  Mark Lord
+ *  May be copied or modified under the terms of the GNU General Public License
+ *
+ *  Recent Changes
+ *	Split the set up function into multiple functions
+ *	Use pci_set_master
+ *	Fix misreporting of I/O v MMIO problems
+ *	Initial fixups for simplex devices
+ */
+
+/*
+ *  This module provides support for automatic detection and
+ *  configuration of all PCI IDE interfaces present in a system.  
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/ide.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+
+
+/**
+ *	ide_match_hwif	-	match a PCI IDE against an ide_hwif
+ *	@io_base: I/O base of device
+ *	@bootable: set if its bootable
+ *	@name: name of device
+ *
+ *	Match a PCI IDE port against an entry in ide_hwifs[],
+ *	based on io_base port if possible. Return the matching hwif,
+ *	or a new hwif. If we find an error (clashing, out of devices, etc)
+ *	return NULL
+ *
+ *	FIXME: we need to handle mmio matches here too
+ */
+
+static ide_hwif_t *ide_match_hwif(unsigned long io_base, u8 bootable, const char *name)
+{
+	int h;
+	ide_hwif_t *hwif;
+
+	/*
+	 * Look for a hwif with matching io_base specified using
+	 * parameters to ide_setup().
+	 */
+	for (h = 0; h < MAX_HWIFS; ++h) {
+		hwif = &ide_hwifs[h];
+		if (hwif->io_ports[IDE_DATA_OFFSET] == io_base) {
+			if (hwif->chipset == ide_forced)
+				return hwif; /* a perfect match */
+		}
+	}
+	/*
+	 * Look for a hwif with matching io_base default value.
+	 * If chipset is "ide_unknown", then claim that hwif slot.
+	 * Otherwise, some other chipset has already claimed it..  :(
+	 */
+	for (h = 0; h < MAX_HWIFS; ++h) {
+		hwif = &ide_hwifs[h];
+		if (hwif->io_ports[IDE_DATA_OFFSET] == io_base) {
+			if (hwif->chipset == ide_unknown)
+				return hwif; /* match */
+			printk(KERN_ERR "%s: port 0x%04lx already claimed by %s\n",
+				name, io_base, hwif->name);
+			return NULL;	/* already claimed */
+		}
+	}
+	/*
+	 * Okay, there is no hwif matching our io_base,
+	 * so we'll just claim an unassigned slot.
+	 * Give preference to claiming other slots before claiming ide0/ide1,
+	 * just in case there's another interface yet-to-be-scanned
+	 * which uses ports 1f0/170 (the ide0/ide1 defaults).
+	 *
+	 * Unless there is a bootable card that does not use the standard
+	 * ports 1f0/170 (the ide0/ide1 defaults). The (bootable) flag.
+	 */
+	if (bootable) {
+		for (h = 0; h < MAX_HWIFS; ++h) {
+			hwif = &ide_hwifs[h];
+			if (hwif->chipset == ide_unknown)
+				return hwif;	/* pick an unused entry */
+		}
+	} else {
+		for (h = 2; h < MAX_HWIFS; ++h) {
+			hwif = ide_hwifs + h;
+			if (hwif->chipset == ide_unknown)
+				return hwif;	/* pick an unused entry */
+		}
+	}
+	for (h = 0; h < 2; ++h) {
+		hwif = ide_hwifs + h;
+		if (hwif->chipset == ide_unknown)
+			return hwif;	/* pick an unused entry */
+	}
+	printk(KERN_ERR "%s: too many IDE interfaces, no room in table\n", name);
+	return NULL;
+}
+
+/**
+ *	ide_setup_pci_baseregs	-	place a PCI IDE controller native
+ *	@dev: PCI device of interface to switch native
+ *	@name: Name of interface
+ *
+ *	We attempt to place the PCI interface into PCI native mode. If
+ *	we succeed the BARs are ok and the controller is in PCI mode.
+ *	Returns 0 on success or an errno code. 
+ *
+ *	FIXME: if we program the interface and then fail to set the BARS
+ *	we don't switch it back to legacy mode. Do we actually care ??
+ */
+ 
+static int ide_setup_pci_baseregs (struct pci_dev *dev, const char *name)
+{
+	u8 progif = 0;
+
+	/*
+	 * Place both IDE interfaces into PCI "native" mode:
+	 */
+	if (pci_read_config_byte(dev, PCI_CLASS_PROG, &progif) ||
+			 (progif & 5) != 5) {
+		if ((progif & 0xa) != 0xa) {
+			printk(KERN_INFO "%s: device not capable of full "
+				"native PCI mode\n", name);
+			return -EOPNOTSUPP;
+		}
+		printk("%s: placing both ports into native PCI mode\n", name);
+		(void) pci_write_config_byte(dev, PCI_CLASS_PROG, progif|5);
+		if (pci_read_config_byte(dev, PCI_CLASS_PROG, &progif) ||
+		    (progif & 5) != 5) {
+			printk(KERN_ERR "%s: rewrite of PROGIF failed, wanted "
+				"0x%04x, got 0x%04x\n",
+				name, progif|5, progif);
+			return -EOPNOTSUPP;
+		}
+	}
+	return 0;
+}
+
+#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
+
+#ifdef CONFIG_BLK_DEV_IDEDMA_FORCED
+/*
+ * Long lost data from 2.0.34 that is now in 2.0.39
+ *
+ * This was used in ./drivers/block/triton.c to do DMA Base address setup
+ * when PnP failed.  Oh the things we forget.  I believe this was part
+ * of SFF-8038i that has been withdrawn from public access... :-((
+ */
+#define DEFAULT_BMIBA	0xe800	/* in case BIOS did not init it */
+#define DEFAULT_BMCRBA	0xcc00	/* VIA's default value */
+#define DEFAULT_BMALIBA	0xd400	/* ALI's default value */
+#endif /* CONFIG_BLK_DEV_IDEDMA_FORCED */
+
+/**
+ *	ide_get_or_set_dma_base		-	setup BMIBA
+ *	@hwif: Interface
+ *
+ *	Fetch the DMA Bus-Master-I/O-Base-Address (BMIBA) from PCI space:
+ *	If need be we set up the DMA base. Where a device has a partner that
+ *	is already in DMA mode we check and enforce IDE simplex rules.
+ */
+
+static unsigned long ide_get_or_set_dma_base (ide_hwif_t *hwif)
+{
+	unsigned long	dma_base = 0;
+	struct pci_dev	*dev = hwif->pci_dev;
+
+#ifdef CONFIG_BLK_DEV_IDEDMA_FORCED
+	int second_chance = 0;
+
+second_chance_to_dma:
+#endif /* CONFIG_BLK_DEV_IDEDMA_FORCED */
+
+	if (hwif->mmio)
+		return hwif->dma_base;
+
+	if (hwif->mate && hwif->mate->dma_base) {
+		dma_base = hwif->mate->dma_base - (hwif->channel ? 0 : 8);
+	} else {
+		dma_base = pci_resource_start(dev, 4);
+		if (!dma_base) {
+			printk(KERN_ERR "%s: dma_base is invalid\n",
+					hwif->cds->name);
+		}
+	}
+
+#ifdef CONFIG_BLK_DEV_IDEDMA_FORCED
+	/* FIXME - should use pci_assign_resource surely */
+	if ((!dma_base) && (!second_chance)) {
+		unsigned long set_bmiba = 0;
+		second_chance++;
+		switch(dev->vendor) {
+			case PCI_VENDOR_ID_AL:
+				set_bmiba = DEFAULT_BMALIBA; break;
+			case PCI_VENDOR_ID_VIA:
+				set_bmiba = DEFAULT_BMCRBA; break;
+			case PCI_VENDOR_ID_INTEL:
+				set_bmiba = DEFAULT_BMIBA; break;
+			default:
+				return dma_base;
+		}
+		pci_write_config_dword(dev, 0x20, set_bmiba|1);
+		goto second_chance_to_dma;
+	}
+#endif /* CONFIG_BLK_DEV_IDEDMA_FORCED */
+
+	if (dma_base) {
+		u8 simplex_stat = 0;
+		dma_base += hwif->channel ? 8 : 0;
+
+		switch(dev->device) {
+			case PCI_DEVICE_ID_AL_M5219:
+			case PCI_DEVICE_ID_AL_M5229:
+			case PCI_DEVICE_ID_AMD_VIPER_7409:
+			case PCI_DEVICE_ID_CMD_643:
+			case PCI_DEVICE_ID_SERVERWORKS_CSB5IDE:
+				simplex_stat = hwif->INB(dma_base + 2);
+				hwif->OUTB((simplex_stat&0x60),(dma_base + 2));
+				simplex_stat = hwif->INB(dma_base + 2);
+				if (simplex_stat & 0x80) {
+					printk(KERN_INFO "%s: simplex device: "
+						"DMA forced\n",
+						hwif->cds->name);
+				}
+				break;
+			default:
+				/*
+				 * If the device claims "simplex" DMA,
+				 * this means only one of the two interfaces
+				 * can be trusted with DMA at any point in time.
+				 * So we should enable DMA only on one of the
+				 * two interfaces.
+				 */
+				simplex_stat = hwif->INB(dma_base + 2);
+				if (simplex_stat & 0x80) {
+					/* simplex device? */
+/*
+ *	At this point we haven't probed the drives so we can't make the
+ *	appropriate decision. Really we should defer this problem
+ *	until we tune the drive then try to grab DMA ownership if we want
+ *	to be the DMA end. This has to be become dynamic to handle hot
+ *	plug.
+ */
+					if (hwif->mate && hwif->mate->dma_base) {
+						printk(KERN_INFO "%s: simplex device: "
+							"DMA disabled\n",
+							hwif->cds->name);
+						dma_base = 0;
+					}
+				}
+		}
+	}
+	return dma_base;
+}
+#endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
+
+void ide_setup_pci_noise (struct pci_dev *dev, ide_pci_device_t *d)
+{
+	printk(KERN_INFO "%s: IDE controller at PCI slot %s\n",
+			 d->name, pci_name(dev));
+}
+
+EXPORT_SYMBOL_GPL(ide_setup_pci_noise);
+
+
+/**
+ *	ide_pci_enable	-	do PCI enables
+ *	@dev: PCI device
+ *	@d: IDE pci device data
+ *
+ *	Enable the IDE PCI device. We attempt to enable the device in full
+ *	but if that fails then we only need BAR4 so we will enable that.
+ *	
+ *	Returns zero on success or an error code
+ */
+ 
+static int ide_pci_enable(struct pci_dev *dev, ide_pci_device_t *d)
+{
+	int ret;
+
+	if (pci_enable_device(dev)) {
+		ret = pci_enable_device_bars(dev, 1 << 4);
+		if (ret < 0) {
+			printk(KERN_WARNING "%s: (ide_setup_pci_device:) "
+				"Could not enable device.\n", d->name);
+			goto out;
+		}
+		printk(KERN_WARNING "%s: BIOS configuration fixed.\n", d->name);
+	}
+
+	/*
+	 * assume all devices can do 32-bit dma for now. we can add a
+	 * dma mask field to the ide_pci_device_t if we need it (or let
+	 * lower level driver set the dma mask)
+	 */
+	ret = pci_set_dma_mask(dev, DMA_32BIT_MASK);
+	if (ret < 0) {
+		printk(KERN_ERR "%s: can't set dma mask\n", d->name);
+		goto out;
+	}
+
+	/* FIXME: Temporary - until we put in the hotplug interface logic
+	   Check that the bits we want are not in use by someone else. */
+	ret = pci_request_region(dev, 4, "ide_tmp");
+	if (ret < 0)
+		goto out;
+
+	pci_release_region(dev, 4);
+out:
+	return ret;
+}
+
+/**
+ *	ide_pci_configure	-	configure an unconfigured device
+ *	@dev: PCI device
+ *	@d: IDE pci device data
+ *
+ *	Enable and configure the PCI device we have been passed.
+ *	Returns zero on success or an error code.
+ */
+ 
+static int ide_pci_configure(struct pci_dev *dev, ide_pci_device_t *d)
+{
+	u16 pcicmd = 0;
+	/*
+	 * PnP BIOS was *supposed* to have setup this device, but we
+	 * can do it ourselves, so long as the BIOS has assigned an IRQ
+	 * (or possibly the device is using a "legacy header" for IRQs).
+	 * Maybe the user deliberately *disabled* the device,
+	 * but we'll eventually ignore it again if no drives respond.
+	 */
+	if (ide_setup_pci_baseregs(dev, d->name) || pci_write_config_word(dev, PCI_COMMAND, pcicmd|PCI_COMMAND_IO)) 
+	{
+		printk(KERN_INFO "%s: device disabled (BIOS)\n", d->name);
+		return -ENODEV;
+	}
+	if (pci_read_config_word(dev, PCI_COMMAND, &pcicmd)) {
+		printk(KERN_ERR "%s: error accessing PCI regs\n", d->name);
+		return -EIO;
+	}
+	if (!(pcicmd & PCI_COMMAND_IO)) {
+		printk(KERN_ERR "%s: unable to enable IDE controller\n", d->name);
+		return -ENXIO;
+	}
+	return 0;
+}
+
+/**
+ *	ide_pci_check_iomem	-	check a register is I/O
+ *	@dev: pci device
+ *	@d: ide_pci_device
+ *	@bar: bar number
+ *
+ *	Checks if a BAR is configured and points to MMIO space. If so
+ *	print an error and return an error code. Otherwise return 0
+ */
+ 
+static int ide_pci_check_iomem(struct pci_dev *dev, ide_pci_device_t *d, int bar)
+{
+	ulong flags = pci_resource_flags(dev, bar);
+	
+	/* Unconfigured ? */
+	if (!flags || pci_resource_len(dev, bar) == 0)
+		return 0;
+
+	/* I/O space */		
+	if(flags & PCI_BASE_ADDRESS_IO_MASK)
+		return 0;
+		
+	/* Bad */
+	printk(KERN_ERR "%s: IO baseregs (BIOS) are reported "
+			"as MEM, report to "
+			"<andre@linux-ide.org>.\n", d->name);
+	return -EINVAL;
+}
+
+/**
+ *	ide_hwif_configure	-	configure an IDE interface
+ *	@dev: PCI device holding interface
+ *	@d: IDE pci data
+ *	@mate: Paired interface if any
+ *
+ *	Perform the initial set up for the hardware interface structure. This
+ *	is done per interface port rather than per PCI device. There may be
+ *	more than one port per device.
+ *
+ *	Returns the new hardware interface structure, or NULL on a failure
+ */
+ 
+static ide_hwif_t *ide_hwif_configure(struct pci_dev *dev, ide_pci_device_t *d, ide_hwif_t *mate, int port, int irq)
+{
+	unsigned long ctl = 0, base = 0;
+	ide_hwif_t *hwif;
+
+	if ((d->flags & IDEPCI_FLAG_ISA_PORTS) == 0) {
+		/*  Possibly we should fail if these checks report true */
+		ide_pci_check_iomem(dev, d, 2*port);
+		ide_pci_check_iomem(dev, d, 2*port+1);
+ 
+		ctl  = pci_resource_start(dev, 2*port+1);
+		base = pci_resource_start(dev, 2*port);
+		if ((ctl && !base) || (base && !ctl)) {
+			printk(KERN_ERR "%s: inconsistent baseregs (BIOS) "
+				"for port %d, skipping\n", d->name, port);
+			return NULL;
+		}
+	}
+	if (!ctl)
+	{
+		/* Use default values */
+		ctl = port ? 0x374 : 0x3f4;
+		base = port ? 0x170 : 0x1f0;
+	}
+	if ((hwif = ide_match_hwif(base, d->bootable, d->name)) == NULL)
+		return NULL;	/* no room in ide_hwifs[] */
+	if (hwif->io_ports[IDE_DATA_OFFSET] != base ||
+	    hwif->io_ports[IDE_CONTROL_OFFSET] != (ctl | 2)) {
+		memset(&hwif->hw, 0, sizeof(hwif->hw));
+#ifndef IDE_ARCH_OBSOLETE_INIT
+		ide_std_init_ports(&hwif->hw, base, (ctl | 2));
+		hwif->hw.io_ports[IDE_IRQ_OFFSET] = 0;
+#else
+		ide_init_hwif_ports(&hwif->hw, base, (ctl | 2), NULL);
+#endif
+		memcpy(hwif->io_ports, hwif->hw.io_ports, sizeof(hwif->io_ports));
+		hwif->noprobe = !hwif->io_ports[IDE_DATA_OFFSET];
+	}
+	hwif->chipset = ide_pci;
+	hwif->pci_dev = dev;
+	hwif->cds = (struct ide_pci_device_s *) d;
+	hwif->channel = port;
+
+	if (!hwif->irq)
+		hwif->irq = irq;
+	if (mate) {
+		hwif->mate = mate;
+		mate->mate = hwif;
+	}
+	return hwif;
+}
+
+/**
+ *	ide_hwif_setup_dma	-	configure DMA interface
+ *	@dev: PCI device
+ *	@d: IDE pci data
+ *	@hwif: Hardware interface we are configuring
+ *
+ *	Set up the DMA base for the interface. Enable the master bits as
+ *	necessary and attempt to bring the device DMA into a ready to use
+ *	state
+ */
+ 
+#ifndef CONFIG_BLK_DEV_IDEDMA_PCI
+static void ide_hwif_setup_dma(struct pci_dev *dev, ide_pci_device_t *d, ide_hwif_t *hwif)
+{
+}
+#else
+static void ide_hwif_setup_dma(struct pci_dev *dev, ide_pci_device_t *d, ide_hwif_t *hwif)
+{
+	u16 pcicmd;
+	pci_read_config_word(dev, PCI_COMMAND, &pcicmd);
+
+	if ((d->autodma == AUTODMA) ||
+	    ((dev->class >> 8) == PCI_CLASS_STORAGE_IDE &&
+	     (dev->class & 0x80))) {
+		unsigned long dma_base = ide_get_or_set_dma_base(hwif);
+		if (dma_base && !(pcicmd & PCI_COMMAND_MASTER)) {
+			/*
+ 			 * Set up BM-DMA capability
+			 * (PnP BIOS should have done this)
+ 			 */
+			/* default DMA off if we had to configure it here */
+			hwif->autodma = 0;
+			pci_set_master(dev);
+			if (pci_read_config_word(dev, PCI_COMMAND, &pcicmd) || !(pcicmd & PCI_COMMAND_MASTER)) {
+				printk(KERN_ERR "%s: %s error updating PCICMD\n",
+					hwif->name, d->name);
+				dma_base = 0;
+			}
+		}
+		if (dma_base) {
+			if (d->init_dma) {
+				d->init_dma(hwif, dma_base);
+			} else {
+				ide_setup_dma(hwif, dma_base, 8);
+			}
+		} else {
+			printk(KERN_INFO "%s: %s Bus-Master DMA disabled "
+				"(BIOS)\n", hwif->name, d->name);
+		}
+	}
+}
+
+#ifndef CONFIG_IDEDMA_PCI_AUTO
+#warning CONFIG_IDEDMA_PCI_AUTO=n support is obsolete, and will be removed soon.
+#endif
+
+#endif /* CONFIG_BLK_DEV_IDEDMA_PCI*/
+
+/**
+ *	ide_setup_pci_controller	-	set up IDE PCI
+ *	@dev: PCI device
+ *	@d: IDE PCI data
+ *	@noisy: verbose flag
+ *	@config: returned as 1 if we configured the hardware
+ *
+ *	Set up the PCI and controller side of the IDE interface. This brings
+ *	up the PCI side of the device, checks that the device is enabled
+ *	and enables it if need be
+ */
+ 
+static int ide_setup_pci_controller(struct pci_dev *dev, ide_pci_device_t *d, int noisy, int *config)
+{
+	int ret;
+	u32 class_rev;
+	u16 pcicmd;
+
+	if (noisy)
+		ide_setup_pci_noise(dev, d);
+
+	ret = ide_pci_enable(dev, d);
+	if (ret < 0)
+		goto out;
+
+	ret = pci_read_config_word(dev, PCI_COMMAND, &pcicmd);
+	if (ret < 0) {
+		printk(KERN_ERR "%s: error accessing PCI regs\n", d->name);
+		goto out;
+	}
+	if (!(pcicmd & PCI_COMMAND_IO)) {	/* is device disabled? */
+		ret = ide_pci_configure(dev, d);
+		if (ret < 0)
+			goto out;
+		*config = 1;
+		printk(KERN_INFO "%s: device enabled (Linux)\n", d->name);
+	}
+
+	pci_read_config_dword(dev, PCI_CLASS_REVISION, &class_rev);
+	class_rev &= 0xff;
+	if (noisy)
+		printk(KERN_INFO "%s: chipset revision %d\n", d->name, class_rev);
+out:
+	return ret;
+}
+
+/**
+ *	ide_pci_setup_ports	-	configure ports/devices on PCI IDE
+ *	@dev: PCI device
+ *	@d: IDE pci device info
+ *	@pciirq: IRQ line
+ *	@index: ata index to update
+ *
+ *	Scan the interfaces attached to this device and do any
+ *	necessary per port setup. Attach the devices and ask the
+ *	generic DMA layer to do its work for us.
+ *
+ *	Normally called automaticall from do_ide_pci_setup_device,
+ *	but is also used directly as a helper function by some controllers
+ *	where the chipset setup is not the default PCI IDE one.
+ */
+ 
+void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int pciirq, ata_index_t *index)
+{
+	int port;
+	int at_least_one_hwif_enabled = 0;
+	ide_hwif_t *hwif, *mate = NULL;
+	static int secondpdc = 0;
+	u8 tmp;
+
+	index->all = 0xf0f0;
+
+	/*
+	 * Set up the IDE ports
+	 */
+	 
+	for (port = 0; port <= 1; ++port) {
+		ide_pci_enablebit_t *e = &(d->enablebits[port]);
+	
+		/* 
+		 * If this is a Promise FakeRaid controller,
+		 * the 2nd controller will be marked as 
+		 * disabled while it is actually there and enabled
+		 * by the bios for raid purposes. 
+		 * Skip the normal "is it enabled" test for those.
+		 */
+		if ((d->flags & IDEPCI_FLAG_FORCE_PDC) &&
+		    (secondpdc++==1) && (port==1))
+			goto controller_ok;
+			
+		if (e->reg && (pci_read_config_byte(dev, e->reg, &tmp) ||
+		    (tmp & e->mask) != e->val))
+			continue;	/* port not enabled */
+controller_ok:
+
+		if (d->channels	<= port)
+			break;
+	
+		if ((hwif = ide_hwif_configure(dev, d, mate, port, pciirq)) == NULL)
+			continue;
+
+		/* setup proper ancestral information */
+		hwif->gendev.parent = &dev->dev;
+
+		if (hwif->channel) {
+			index->b.high = hwif->index;
+		} else {
+			index->b.low = hwif->index;
+		}
+
+		
+		if (d->init_iops)
+			d->init_iops(hwif);
+
+		if (d->autodma == NODMA)
+			goto bypass_legacy_dma;
+
+		if(d->init_setup_dma)
+			d->init_setup_dma(dev, d, hwif);
+		else
+			ide_hwif_setup_dma(dev, d, hwif);
+bypass_legacy_dma:
+		if (d->init_hwif)
+			/* Call chipset-specific routine
+			 * for each enabled hwif
+			 */
+			d->init_hwif(hwif);
+
+		mate = hwif;
+		at_least_one_hwif_enabled = 1;
+	}
+	if (!at_least_one_hwif_enabled)
+		printk(KERN_INFO "%s: neither IDE port enabled (BIOS)\n", d->name);
+}
+
+EXPORT_SYMBOL_GPL(ide_pci_setup_ports);
+
+/*
+ * ide_setup_pci_device() looks at the primary/secondary interfaces
+ * on a PCI IDE device and, if they are enabled, prepares the IDE driver
+ * for use with them.  This generic code works for most PCI chipsets.
+ *
+ * One thing that is not standardized is the location of the
+ * primary/secondary interface "enable/disable" bits.  For chipsets that
+ * we "know" about, this information is in the ide_pci_device_t struct;
+ * for all other chipsets, we just assume both interfaces are enabled.
+ */
+static int do_ide_setup_pci_device(struct pci_dev *dev, ide_pci_device_t *d,
+				   ata_index_t *index, u8 noisy)
+{
+	static ata_index_t ata_index = { .b = { .low = 0xff, .high = 0xff } };
+	int tried_config = 0;
+	int pciirq, ret;
+
+	ret = ide_setup_pci_controller(dev, d, noisy, &tried_config);
+	if (ret < 0)
+		goto out;
+
+	/*
+	 * Can we trust the reported IRQ?
+	 */
+	pciirq = dev->irq;
+
+	/* Is it an "IDE storage" device in non-PCI mode? */
+	if ((dev->class >> 8) == PCI_CLASS_STORAGE_IDE && (dev->class & 5) != 5) {
+		if (noisy)
+			printk(KERN_INFO "%s: not 100%% native mode: "
+				"will probe irqs later\n", d->name);
+		/*
+		 * This allows offboard ide-pci cards the enable a BIOS,
+		 * verify interrupt settings of split-mirror pci-config
+		 * space, place chipset into init-mode, and/or preserve
+		 * an interrupt if the card is not native ide support.
+		 */
+		ret = d->init_chipset ? d->init_chipset(dev, d->name) : 0;
+		if (ret < 0)
+			goto out;
+		pciirq = ret;
+	} else if (tried_config) {
+		if (noisy)
+			printk(KERN_INFO "%s: will probe irqs later\n", d->name);
+		pciirq = 0;
+	} else if (!pciirq) {
+		if (noisy)
+			printk(KERN_WARNING "%s: bad irq (%d): will probe later\n",
+				d->name, pciirq);
+		pciirq = 0;
+	} else {
+		if (d->init_chipset) {
+			ret = d->init_chipset(dev, d->name);
+			if (ret < 0)
+				goto out;
+		}
+		if (noisy)
+#ifdef __sparc__
+			printk(KERN_INFO "%s: 100%% native mode on irq %s\n",
+			       d->name, __irq_itoa(pciirq));
+#else
+			printk(KERN_INFO "%s: 100%% native mode on irq %d\n",
+				d->name, pciirq);
+#endif
+	}
+
+	/* FIXME: silent failure can happen */
+
+	*index = ata_index;
+	ide_pci_setup_ports(dev, d, pciirq, index);
+out:
+	return ret;
+}
+
+int ide_setup_pci_device(struct pci_dev *dev, ide_pci_device_t *d)
+{
+	ata_index_t index_list;
+	int ret;
+
+	ret = do_ide_setup_pci_device(dev, d, &index_list, 1);
+	if (ret < 0)
+		goto out;
+
+	if ((index_list.b.low & 0xf0) != 0xf0)
+		probe_hwif_init_with_fixup(&ide_hwifs[index_list.b.low], d->fixup);
+	if ((index_list.b.high & 0xf0) != 0xf0)
+		probe_hwif_init_with_fixup(&ide_hwifs[index_list.b.high], d->fixup);
+
+	create_proc_ide_interfaces();
+out:
+	return ret;
+}
+
+EXPORT_SYMBOL_GPL(ide_setup_pci_device);
+
+int ide_setup_pci_devices(struct pci_dev *dev1, struct pci_dev *dev2,
+			  ide_pci_device_t *d)
+{
+	struct pci_dev *pdev[] = { dev1, dev2 };
+	ata_index_t index_list[2];
+	int ret, i;
+
+	for (i = 0; i < 2; i++) {
+		ret = do_ide_setup_pci_device(pdev[i], d, index_list + i, !i);
+		/*
+		 * FIXME: Mom, mom, they stole me the helper function to undo
+		 * do_ide_setup_pci_device() on the first device!
+		 */
+		if (ret < 0)
+			goto out;
+	}
+
+	for (i = 0; i < 2; i++) {
+		u8 idx[2] = { index_list[i].b.low, index_list[i].b.high };
+		int j;
+
+		for (j = 0; j < 2; j++) {
+			if ((idx[j] & 0xf0) != 0xf0)
+				probe_hwif_init(ide_hwifs + idx[j]);
+		}
+	}
+
+	create_proc_ide_interfaces();
+out:
+	return ret;
+}
+
+EXPORT_SYMBOL_GPL(ide_setup_pci_devices);
+
+/*
+ *	Module interfaces
+ */
+ 
+static int pre_init = 1;		/* Before first ordered IDE scan */
+static LIST_HEAD(ide_pci_drivers);
+
+/*
+ *	ide_register_pci_driver		-	attach IDE driver
+ *	@driver: pci driver
+ *
+ *	Registers a driver with the IDE layer. The IDE layer arranges that
+ *	boot time setup is done in the expected device order and then 
+ *	hands the controllers off to the core PCI code to do the rest of
+ *	the work.
+ *
+ *	The driver_data of the driver table must point to an ide_pci_device_t
+ *	describing the interface.
+ *
+ *	Returns are the same as for pci_register_driver
+ */
+
+int ide_pci_register_driver(struct pci_driver *driver)
+{
+	if(!pre_init)
+		return pci_module_init(driver);
+	list_add_tail(&driver->node, &ide_pci_drivers);
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(ide_pci_register_driver);
+
+/**
+ *	ide_unregister_pci_driver	-	unregister an IDE driver
+ *	@driver: driver to remove
+ *
+ *	Unregister a currently installed IDE driver. Returns are the same
+ *	as for pci_unregister_driver
+ */
+ 
+void ide_pci_unregister_driver(struct pci_driver *driver)
+{
+	if(!pre_init)
+		pci_unregister_driver(driver);
+	else
+		list_del(&driver->node);
+}
+
+EXPORT_SYMBOL_GPL(ide_pci_unregister_driver);
+
+/**
+ *	ide_scan_pcidev		-	find an IDE driver for a device
+ *	@dev: PCI device to check
+ *
+ *	Look for an IDE driver to handle the device we are considering.
+ *	This is only used during boot up to get the ordering correct. After
+ *	boot up the pci layer takes over the job.
+ */
+ 
+static int __init ide_scan_pcidev(struct pci_dev *dev)
+{
+	struct list_head *l;
+	struct pci_driver *d;
+	
+	list_for_each(l, &ide_pci_drivers)
+	{
+		d = list_entry(l, struct pci_driver, node);
+		if(d->id_table)
+		{
+			const struct pci_device_id *id = pci_match_device(d->id_table, dev);
+			if(id != NULL)
+			{
+				if(d->probe(dev, id) >= 0)
+				{
+					dev->driver = d;
+					return 1;
+				}
+			}
+		}
+	}
+	return 0;
+}
+
+/**
+ *	ide_scan_pcibus		-	perform the initial IDE driver scan
+ *	@scan_direction: set for reverse order scanning
+ *
+ *	Perform the initial bus rather than driver ordered scan of the
+ *	PCI drivers. After this all IDE pci handling becomes standard
+ *	module ordering not traditionally ordered.
+ */
+ 	
+void __init ide_scan_pcibus (int scan_direction)
+{
+	struct pci_dev *dev = NULL;
+	struct pci_driver *d;
+	struct list_head *l, *n;
+
+	pre_init = 0;
+	if (!scan_direction) {
+		while ((dev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL) {
+			ide_scan_pcidev(dev);
+		}
+	} else {
+		while ((dev = pci_find_device_reverse(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL) {
+			ide_scan_pcidev(dev);
+		}
+	}
+	
+	/*
+	 *	Hand the drivers over to the PCI layer now we
+	 *	are post init.
+	 */
+
+	list_for_each_safe(l, n, &ide_pci_drivers)
+	{
+		list_del(l);
+		d = list_entry(l, struct pci_driver, node);
+		pci_register_driver(d);
+	}
+}
