commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/ide/pdc202xx_old.c b/drivers/ide/pdc202xx_old.c
index 224ad46d6cb2..5248ac064e6e 100644
--- a/drivers/ide/pdc202xx_old.c
+++ b/drivers/ide/pdc202xx_old.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  Copyright (C) 1998-2002		Andre Hedrick <andre@linux-ide.org>
  *  Copyright (C) 2006-2007, 2009	MontaVista Software, Inc.

commit fe31edc8a3b6081f3580c9ae4c5c61103f3412a5
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:21:03 2012 -0800

    Drivers: ide: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/ide/pdc202xx_old.c b/drivers/ide/pdc202xx_old.c
index 563451096812..224ad46d6cb2 100644
--- a/drivers/ide/pdc202xx_old.c
+++ b/drivers/ide/pdc202xx_old.c
@@ -211,8 +211,7 @@ static int init_chipset_pdc202xx(struct pci_dev *dev)
 	return 0;
 }
 
-static void __devinit pdc202ata4_fixup_irq(struct pci_dev *dev,
-					   const char *name)
+static void pdc202ata4_fixup_irq(struct pci_dev *dev, const char *name)
 {
 	if ((dev->class >> 8) != PCI_CLASS_STORAGE_IDE) {
 		u8 irq = 0, irq2 = 0;
@@ -270,7 +269,7 @@ static const struct ide_dma_ops pdc2026x_dma_ops = {
 		.max_sectors	= sectors, \
 	}
 
-static const struct ide_port_info pdc202xx_chipsets[] __devinitconst = {
+static const struct ide_port_info pdc202xx_chipsets[] = {
 	{	/* 0: PDC20246 */
 		.name		= DRV_NAME,
 		.init_chipset	= init_chipset_pdc202xx,
@@ -297,7 +296,8 @@ static const struct ide_port_info pdc202xx_chipsets[] __devinitconst = {
  *	finds a device matching our IDE device tables.
  */
  
-static int __devinit pdc202xx_init_one(struct pci_dev *dev, const struct pci_device_id *id)
+static int pdc202xx_init_one(struct pci_dev *dev,
+			     const struct pci_device_id *id)
 {
 	const struct ide_port_info *d;
 	u8 idx = id->driver_data;

commit e6b53703b9966a3636be2bd4b7b8e0bfeb1b3f8d
Author: Andi Kleen <ak@linux.intel.com>
Date:   Thu Oct 4 17:11:48 2012 -0700

    sections: fix section conflicts in drivers/ide
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: David Miller <davem@davemloft.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/ide/pdc202xx_old.c b/drivers/ide/pdc202xx_old.c
index 3a35ec6193d2..563451096812 100644
--- a/drivers/ide/pdc202xx_old.c
+++ b/drivers/ide/pdc202xx_old.c
@@ -270,7 +270,7 @@ static const struct ide_dma_ops pdc2026x_dma_ops = {
 		.max_sectors	= sectors, \
 	}
 
-static const struct ide_port_info pdc202xx_chipsets[] __devinitdata = {
+static const struct ide_port_info pdc202xx_chipsets[] __devinitconst = {
 	{	/* 0: PDC20246 */
 		.name		= DRV_NAME,
 		.init_chipset	= init_chipset_pdc202xx,

commit f693be4d8a00431b53a59d74aefdb3f7ae92f662
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Wed Apr 14 05:52:59 2010 +0000

    pdc202xx_old: ignore "FIFO empty" bit in test_irq() method
    
    The driver takes into account not only the interrupt status bit but
    also "FIFO empty" bit in its test_irq() method. This actually is a
    superfluous check since for the DMA commands calling the
    dma_test_irq() method further in the interrupt handler makes sure FIFO
    is emptied.
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/ide/pdc202xx_old.c b/drivers/ide/pdc202xx_old.c
index 42ad794dfaae..3a35ec6193d2 100644
--- a/drivers/ide/pdc202xx_old.c
+++ b/drivers/ide/pdc202xx_old.c
@@ -93,13 +93,13 @@ static int pdc202xx_test_irq(ide_hwif_t *hwif)
 		 * bit 7: error, bit 6: interrupting,
 		 * bit 5: FIFO full, bit 4: FIFO empty
 		 */
-		return ((sc1d & 0x50) == 0x50) ? 1 : 0;
+		return (sc1d & 0x40) ? 1 : 0;
 	} else	{
 		/*
 		 * bit 3: error, bit 2: interrupting,
 		 * bit 1: FIFO full, bit 0: FIFO empty
 		 */
-		return ((sc1d & 0x05) == 0x05) ? 1 : 0;
+		return (sc1d & 0x04) ? 1 : 0;
 	}
 }
 

commit 63e7cf910542383591318941cb62a246ac191cfe
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Wed Apr 14 05:50:26 2010 +0000

    pdc202xx_old: wire test_irq() method for PDC2026x
    
    In the commit e0321fbe6d34b4bb514fb6daff9e0859e5d76001 (pdc202xx_old:
    implement test_irq() method (take 2)) I forgot to modify
    'pdc2026x_port_ops'... :-/
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/ide/pdc202xx_old.c b/drivers/ide/pdc202xx_old.c
index c5f3841af360..42ad794dfaae 100644
--- a/drivers/ide/pdc202xx_old.c
+++ b/drivers/ide/pdc202xx_old.c
@@ -241,6 +241,7 @@ static const struct ide_port_ops pdc20246_port_ops = {
 static const struct ide_port_ops pdc2026x_port_ops = {
 	.set_pio_mode		= pdc202xx_set_pio_mode,
 	.set_dma_mode		= pdc202xx_set_mode,
+	.test_irq		= pdc202xx_test_irq,
 	.cable_detect		= pdc2026x_cable_detect,
 };
 

commit 950f564b707ca1b1c5bb94cd1e7d2a0702bfcadc
Merge: b1681c56f5b6 8495fb1b8d01
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Mar 2 23:57:59 2010 -0800

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/davem/ide-2.6

commit 8776168ca2151850164af1de5565d01f7b8b2c53
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jan 19 01:45:29 2010 -0800

    ide: change ->set_dma_mode method parameters
    
    Change ->set_dma_mode method parameters to match ->set_dmamode method
    used in struct ata_port_operations.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/pdc202xx_old.c b/drivers/ide/pdc202xx_old.c
index 402aab7f3baa..07cd37516ba6 100644
--- a/drivers/ide/pdc202xx_old.c
+++ b/drivers/ide/pdc202xx_old.c
@@ -21,11 +21,11 @@
 
 #define DRV_NAME "pdc202xx_old"
 
-static void pdc202xx_set_mode(ide_drive_t *drive, const u8 speed)
+static void pdc202xx_set_mode(ide_hwif_t *hwif, ide_drive_t *drive)
 {
-	ide_hwif_t *hwif	= drive->hwif;
 	struct pci_dev *dev	= to_pci_dev(hwif->dev);
 	u8 drive_pci		= 0x60 + (drive->dn << 2);
+	const u8 speed		= drive->dma_mode;
 
 	u8			AP = 0, BP = 0, CP = 0;
 	u8			TA = 0, TB = 0, TC = 0;
@@ -78,7 +78,8 @@ static void pdc202xx_set_mode(ide_drive_t *drive, const u8 speed)
 
 static void pdc202xx_set_pio_mode(ide_hwif_t *hwif, ide_drive_t *drive)
 {
-	pdc202xx_set_mode(drive, drive->pio_mode);
+	drive->dma_mode = drive->pio_mode;
+	pdc202xx_set_mode(hwif, drive);
 }
 
 static int pdc202xx_test_irq(ide_hwif_t *hwif)

commit e085b3cae85af47eb0a3eda3186bd898310fb322
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jan 19 01:44:41 2010 -0800

    ide: change ->set_pio_mode method parameters
    
    Change ->set_pio_mode method parameters to match ->set_piomode method
    used in struct ata_port_operations.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/ide/pdc202xx_old.c b/drivers/ide/pdc202xx_old.c
index 1d20594ee420..402aab7f3baa 100644
--- a/drivers/ide/pdc202xx_old.c
+++ b/drivers/ide/pdc202xx_old.c
@@ -76,9 +76,9 @@ static void pdc202xx_set_mode(ide_drive_t *drive, const u8 speed)
 	}
 }
 
-static void pdc202xx_set_pio_mode(ide_drive_t *drive, const u8 pio)
+static void pdc202xx_set_pio_mode(ide_hwif_t *hwif, ide_drive_t *drive)
 {
-	pdc202xx_set_mode(drive, XFER_PIO_0 + pio);
+	pdc202xx_set_mode(drive, drive->pio_mode);
 }
 
 static int pdc202xx_test_irq(ide_hwif_t *hwif)

commit a337c2272731d538827153b32f547ef7c131a4cb
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Jan 18 07:19:14 2010 +0000

    pdc202xx_old: add ->init_hwif method
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/ide/pdc202xx_old.c b/drivers/ide/pdc202xx_old.c
index 35161dd840a0..1d20594ee420 100644
--- a/drivers/ide/pdc202xx_old.c
+++ b/drivers/ide/pdc202xx_old.c
@@ -1,7 +1,7 @@
 /*
  *  Copyright (C) 1998-2002		Andre Hedrick <andre@linux-ide.org>
  *  Copyright (C) 2006-2007, 2009	MontaVista Software, Inc.
- *  Copyright (C) 2007			Bartlomiej Zolnierkiewicz
+ *  Copyright (C) 2007-2010		Bartlomiej Zolnierkiewicz
  *
  *  Portions Copyright (C) 1999 Promise Technology, Inc.
  *  Author: Frank Tiernan (frankt@promise.com)
@@ -21,8 +21,6 @@
 
 #define DRV_NAME "pdc202xx_old"
 
-static void pdc_old_disable_66MHz_clock(ide_hwif_t *);
-
 static void pdc202xx_set_mode(ide_drive_t *drive, const u8 speed)
 {
 	ide_hwif_t *hwif	= drive->hwif;
@@ -32,12 +30,6 @@ static void pdc202xx_set_mode(ide_drive_t *drive, const u8 speed)
 	u8			AP = 0, BP = 0, CP = 0;
 	u8			TA = 0, TB = 0, TC = 0;
 
-	/*
-	 * TODO: do this once per channel
-	 */
-	if (dev->device != PCI_DEVICE_ID_PROMISE_20246)
-		pdc_old_disable_66MHz_clock(hwif);
-
 	pci_read_config_byte(dev, drive_pci,     &AP);
 	pci_read_config_byte(dev, drive_pci + 1, &BP);
 	pci_read_config_byte(dev, drive_pci + 2, &CP);
@@ -145,6 +137,11 @@ static void pdc_old_disable_66MHz_clock(ide_hwif_t *hwif)
 	outb(clock & ~(hwif->channel ? 0x08 : 0x02), clock_reg);
 }
 
+static void pdc2026x_init_hwif(ide_hwif_t *hwif)
+{
+	pdc_old_disable_66MHz_clock(hwif);
+}
+
 static void pdc202xx_dma_start(ide_drive_t *drive)
 {
 	if (drive->current_speed > XFER_UDMA_2)
@@ -261,6 +258,7 @@ static const struct ide_dma_ops pdc2026x_dma_ops = {
 	{ \
 		.name		= DRV_NAME, \
 		.init_chipset	= init_chipset_pdc202xx, \
+		.init_hwif	= pdc2026x_init_hwif, \
 		.port_ops	= &pdc2026x_port_ops, \
 		.dma_ops	= &pdc2026x_dma_ops, \
 		.host_flags	= IDE_HFLAGS_PDC202XX, \
@@ -356,6 +354,6 @@ static void __exit pdc202xx_ide_exit(void)
 module_init(pdc202xx_ide_init);
 module_exit(pdc202xx_ide_exit);
 
-MODULE_AUTHOR("Andre Hedrick, Frank Tiernan");
+MODULE_AUTHOR("Andre Hedrick, Frank Tiernan, Bartlomiej Zolnierkiewicz");
 MODULE_DESCRIPTION("PCI driver module for older Promise IDE");
 MODULE_LICENSE("GPL");

commit c3be57b6f35ef96a980ce84e59d6a5a8ca6184ad
Author: Russell King <rmk@arm.linux.org.uk>
Date:   Sun Jan 3 12:35:42 2010 +0000

    ide: Fix Promise UDMA33 IDE driver (pdc202xx_old)
    
    On Sun, Jan 03, 2010 at 12:23:14AM +0000, Russell King wrote:
    > - with IDE
    >   - locks the interrupt line, and makes the machine extremely painful -
    >     about an hour to get to the point of being able to unload the
    >     pdc202xx_old module.
    
    Having manually bisected kernel versions, I've narrowed it down to some
    change between 2.6.30 and 2.6.31.  There's not much which has changed
    between the two kernels, but one change stands out like a sore thumb:
    
    +static int pdc202xx_test_irq(ide_hwif_t *hwif)
    +{
    +       struct pci_dev *dev     = to_pci_dev(hwif->dev);
    +       unsigned long high_16   = pci_resource_start(dev, 4);
    +       u8 sc1d                 = inb(high_16 + 0x1d);
    +
    +       if (hwif->channel) {
    +               /*
    +                * bit 7: error, bit 6: interrupting,
    +                * bit 5: FIFO full, bit 4: FIFO empty
    +                */
    +               return ((sc1d & 0x50) == 0x40) ? 1 : 0;
    +       } else  {
    +               /*
    +                * bit 3: error, bit 2: interrupting,
    +                * bit 1: FIFO full, bit 0: FIFO empty
    +                */
    +               return ((sc1d & 0x05) == 0x04) ? 1 : 0;
    +       }
    +}
    
    Reading the (documented as a 32-bit) system control register when the
    interface is idle gives: 0x01da110c
    
    So, the byte at 0x1d is 0x11, which is documented as meaning that the
    primary and secondary FIFOs are empty.
    
    The code above, which is trying to see whether an IRQ is pending, checks
    for the IRQ bit to be one, and the FIFO bit to be zero - or in English,
    to be non-empty.
    
    Since during a BM-DMA read, the FIFOs will naturally be drained to the
    PCI bus, the chance of us getting to the interface before this happens
    are extremely small - and if we don't, it means we decide not to service
    the interrupt.  Hence, the screaming interrupt problem with drivers/ide.
    
    Fix this by only indicating an interrupt is ready if both the interrupt
    and FIFO empty bits are at '1'.
    
    This bug only affects PDC20246/PDC20247 (Promise Ultra33) based cards,
    and has been tested on 2.6.31 and 2.6.33-rc2.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Tested-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/ide/pdc202xx_old.c b/drivers/ide/pdc202xx_old.c
index 35161dd840a0..e3bca38a03f2 100644
--- a/drivers/ide/pdc202xx_old.c
+++ b/drivers/ide/pdc202xx_old.c
@@ -100,13 +100,13 @@ static int pdc202xx_test_irq(ide_hwif_t *hwif)
 		 * bit 7: error, bit 6: interrupting,
 		 * bit 5: FIFO full, bit 4: FIFO empty
 		 */
-		return ((sc1d & 0x50) == 0x40) ? 1 : 0;
+		return ((sc1d & 0x50) == 0x50) ? 1 : 0;
 	} else	{
 		/*
 		 * bit 3: error, bit 2: interrupting,
 		 * bit 1: FIFO full, bit 0: FIFO empty
 		 */
-		return ((sc1d & 0x05) == 0x04) ? 1 : 0;
+		return ((sc1d & 0x05) == 0x05) ? 1 : 0;
 	}
 }
 

commit 58dcf8dcb5ebca4a5b1d2c0874efba744dd4552c
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu Dec 3 17:25:57 2009 +0100

    pdc202xx_old: remove no longer needed debugging code
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/pdc202xx_old.c b/drivers/ide/pdc202xx_old.c
index cb812f3700e8..35161dd840a0 100644
--- a/drivers/ide/pdc202xx_old.c
+++ b/drivers/ide/pdc202xx_old.c
@@ -21,8 +21,6 @@
 
 #define DRV_NAME "pdc202xx_old"
 
-#define PDC202XX_DEBUG_DRIVE_INFO	0
-
 static void pdc_old_disable_66MHz_clock(ide_hwif_t *);
 
 static void pdc202xx_set_mode(ide_drive_t *drive, const u8 speed)
@@ -34,11 +32,6 @@ static void pdc202xx_set_mode(ide_drive_t *drive, const u8 speed)
 	u8			AP = 0, BP = 0, CP = 0;
 	u8			TA = 0, TB = 0, TC = 0;
 
-#if PDC202XX_DEBUG_DRIVE_INFO
-	u32			drive_conf = 0;
-	pci_read_config_dword(dev, drive_pci, &drive_conf);
-#endif
-
 	/*
 	 * TODO: do this once per channel
 	 */
@@ -89,14 +82,6 @@ static void pdc202xx_set_mode(ide_drive_t *drive, const u8 speed)
 		pci_write_config_byte(dev, drive_pci + 1, BP | TB);
 		pci_write_config_byte(dev, drive_pci + 2, CP | TC);
 	}
-
-#if PDC202XX_DEBUG_DRIVE_INFO
-	printk(KERN_DEBUG "%s: %s drive%d 0x%08x ",
-		drive->name, ide_xfer_verbose(speed),
-		drive->dn, drive_conf);
-	pci_read_config_dword(dev, drive_pci, &drive_conf);
-	printk("0x%08x\n", drive_conf);
-#endif
 }
 
 static void pdc202xx_set_pio_mode(ide_drive_t *drive, const u8 pio)

commit e0321fbe6d34b4bb514fb6daff9e0859e5d76001
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Mon Jun 15 18:52:59 2009 +0200

    pdc202xx_old: implement test_irq() method (take 2)
    
    Implement test_irq() method based on the driver's former dma_test_irq() method.
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/pdc202xx_old.c b/drivers/ide/pdc202xx_old.c
index 4f5b536282af..cb812f3700e8 100644
--- a/drivers/ide/pdc202xx_old.c
+++ b/drivers/ide/pdc202xx_old.c
@@ -104,6 +104,27 @@ static void pdc202xx_set_pio_mode(ide_drive_t *drive, const u8 pio)
 	pdc202xx_set_mode(drive, XFER_PIO_0 + pio);
 }
 
+static int pdc202xx_test_irq(ide_hwif_t *hwif)
+{
+	struct pci_dev *dev	= to_pci_dev(hwif->dev);
+	unsigned long high_16	= pci_resource_start(dev, 4);
+	u8 sc1d			= inb(high_16 + 0x1d);
+
+	if (hwif->channel) {
+		/*
+		 * bit 7: error, bit 6: interrupting,
+		 * bit 5: FIFO full, bit 4: FIFO empty
+		 */
+		return ((sc1d & 0x50) == 0x40) ? 1 : 0;
+	} else	{
+		/*
+		 * bit 3: error, bit 2: interrupting,
+		 * bit 1: FIFO full, bit 0: FIFO empty
+		 */
+		return ((sc1d & 0x05) == 0x04) ? 1 : 0;
+	}
+}
+
 static u8 pdc2026x_cable_detect(ide_hwif_t *hwif)
 {
 	struct pci_dev *dev = to_pci_dev(hwif->dev);
@@ -231,6 +252,7 @@ static void __devinit pdc202ata4_fixup_irq(struct pci_dev *dev,
 static const struct ide_port_ops pdc20246_port_ops = {
 	.set_pio_mode		= pdc202xx_set_pio_mode,
 	.set_dma_mode		= pdc202xx_set_mode,
+	.test_irq		= pdc202xx_test_irq,
 };
 
 static const struct ide_port_ops pdc2026x_port_ops = {

commit c9ef59ff01b6bd1c7360a64fcc8556a1193c2ed0
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Jun 15 18:52:53 2009 +0200

    ide: IORDY handling fixes
    
    Add ide_pio_need_iordy() helper and convert host drivers to use it.
    
    This fixes it8172, it8213, pdc202xx_old, piix, slc90e66 and siimage
    host drivers to handle IORDY correctly.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/pdc202xx_old.c b/drivers/ide/pdc202xx_old.c
index b6abf7e52cac..4f5b536282af 100644
--- a/drivers/ide/pdc202xx_old.c
+++ b/drivers/ide/pdc202xx_old.c
@@ -73,7 +73,7 @@ static void pdc202xx_set_mode(ide_drive_t *drive, const u8 speed)
 		 * Prefetch_EN / IORDY_EN / PA[3:0] bits of register A
 		 */
 		AP &= ~0x3f;
-		if (ata_id_iordy_disable(drive->id))
+		if (ide_pio_need_iordy(drive, speed - XFER_PIO_0))
 			AP |= 0x20;	/* set IORDY_EN bit */
 		if (drive->media == ide_disk)
 			AP |= 0x10;	/* set Prefetch_EN bit */

commit d614aec4752f8c61b2e7cb77806b6bd59aa50836
Merge: db8e7f10ed67 ad7c52d0988a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 12 09:29:42 2009 -0700

    Merge branch 'for-2.6.31' of git://git.kernel.org/pub/scm/linux/kernel/git/bart/ide-2.6
    
    * 'for-2.6.31' of git://git.kernel.org/pub/scm/linux/kernel/git/bart/ide-2.6: (29 commits)
      ide: re-implement ide_pci_init_one() on top of ide_pci_init_two()
      ide: unexport ide_find_dma_mode()
      ide: fix PowerMac bootup oops
      ide: skip probe if there are no devices on the port (v2)
      sl82c105: add printk() logging facility
      ide-tape: fix proc warning
      ide: add IDE_DFLAG_NIEN_QUIRK device flag
      ide: respect quirk_drives[] list on all controllers
      hpt366: enable all quirks for devices on quirk_drives[] list
      hpt366: sync quirk_drives[] list with pdc202xx_{new,old}.c
      ide: remove superfluous SELECT_MASK() call from do_rw_taskfile()
      ide: remove superfluous SELECT_MASK() call from ide_driveid_update()
      icside: remove superfluous ->maskproc method
      ide-tape: fix IDE_AFLAG_* atomic accesses
      ide-tape: change IDE_AFLAG_IGNORE_DSC non-atomically
      pdc202xx_old: kill resetproc() method
      pdc202xx_old: don't call pdc202xx_reset() on IRQ timeout
      pdc202xx_old: use ide_dma_test_irq()
      ide: preserve Host Protected Area by default (v2)
      ide-gd: implement block device ->set_capacity method (v2)
      ...

commit c9059598ea8981d02356eead3188bf7fa4d717b8
Merge: 0a33f80a8373 b0fd271d5fba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 11 10:52:27 2009 -0700

    Merge branch 'for-2.6.31' of git://git.kernel.dk/linux-2.6-block
    
    * 'for-2.6.31' of git://git.kernel.dk/linux-2.6-block: (153 commits)
      block: add request clone interface (v2)
      floppy: fix hibernation
      ramdisk: remove long-deprecated "ramdisk=" boot-time parameter
      fs/bio.c: add missing __user annotation
      block: prevent possible io_context->refcount overflow
      Add serial number support for virtio_blk, V4a
      block: Add missing bounce_pfn stacking and fix comments
      Revert "block: Fix bounce limit setting in DM"
      cciss: decode unit attention in SCSI error handling code
      cciss: Remove no longer needed sendcmd reject processing code
      cciss: change SCSI error handling routines to work with interrupts enabled.
      cciss: separate error processing and command retrying code in sendcmd_withirq_core()
      cciss: factor out fix target status processing code from sendcmd functions
      cciss: simplify interface of sendcmd() and sendcmd_withirq()
      cciss: factor out core of sendcmd_withirq() for use by SCSI error handling code
      cciss: Use schedule_timeout_uninterruptible in SCSI error handling code
      block: needs to set the residual length of a bidi request
      Revert "block: implement blkdev_readpages"
      block: Fix bounce limit setting in DM
      Removed reference to non-existing file Documentation/PCI/PCI-DMA-mapping.txt
      ...
    
    Manually fix conflicts with tracing updates in:
            block/blk-sysfs.c
            drivers/ide/ide-atapi.c
            drivers/ide/ide-cd.c
            drivers/ide/ide-floppy.c
            drivers/ide/ide-tape.c
            include/trace/events/block.h
            kernel/trace/blktrace.c

commit 8bc1e5aa06a2a9a425c4a6795fc564cba1521487
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sun Jun 7 15:37:09 2009 +0200

    ide: respect quirk_drives[] list on all controllers
    
    * Add ide_check_nien_quirk_list() helper to the core code
      and then use it in ide_port_tune_devices().
    
    * Remove no longer needed ->quirkproc methods from hpt366.c
      and pdc202xx_{new,old}.c.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/pdc202xx_old.c b/drivers/ide/pdc202xx_old.c
index 4980dd7b2e28..fe01db679a39 100644
--- a/drivers/ide/pdc202xx_old.c
+++ b/drivers/ide/pdc202xx_old.c
@@ -23,18 +23,6 @@
 
 #define PDC202XX_DEBUG_DRIVE_INFO	0
 
-static const char *pdc_quirk_drives[] = {
-	"QUANTUM FIREBALLlct08 08",
-	"QUANTUM FIREBALLP KA6.4",
-	"QUANTUM FIREBALLP KA9.1",
-	"QUANTUM FIREBALLP LM20.4",
-	"QUANTUM FIREBALLP KX13.6",
-	"QUANTUM FIREBALLP KX20.5",
-	"QUANTUM FIREBALLP KX27.3",
-	"QUANTUM FIREBALLP LM20.5",
-	NULL
-};
-
 static void pdc_old_disable_66MHz_clock(ide_hwif_t *);
 
 static void pdc202xx_set_mode(ide_drive_t *drive, const u8 speed)
@@ -151,19 +139,6 @@ static void pdc_old_disable_66MHz_clock(ide_hwif_t *hwif)
 	outb(clock & ~(hwif->channel ? 0x08 : 0x02), clock_reg);
 }
 
-static void pdc202xx_quirkproc(ide_drive_t *drive)
-{
-	const char **list, *m = (char *)&drive->id[ATA_ID_PROD];
-
-	for (list = pdc_quirk_drives; *list != NULL; list++)
-		if (strstr(m, *list) != NULL) {
-			drive->quirk_list = 2;
-			return;
-		}
-
-	drive->quirk_list = 0;
-}
-
 static void pdc202xx_dma_start(ide_drive_t *drive)
 {
 	if (drive->current_speed > XFER_UDMA_2)
@@ -256,13 +231,11 @@ static void __devinit pdc202ata4_fixup_irq(struct pci_dev *dev,
 static const struct ide_port_ops pdc20246_port_ops = {
 	.set_pio_mode		= pdc202xx_set_pio_mode,
 	.set_dma_mode		= pdc202xx_set_mode,
-	.quirkproc		= pdc202xx_quirkproc,
 };
 
 static const struct ide_port_ops pdc2026x_port_ops = {
 	.set_pio_mode		= pdc202xx_set_pio_mode,
 	.set_dma_mode		= pdc202xx_set_mode,
-	.quirkproc		= pdc202xx_quirkproc,
 	.cable_detect		= pdc2026x_cable_detect,
 };
 

commit ffddf1717b0d388879c646eaf6261a2b393c06ad
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Sun Jun 7 15:37:05 2009 +0200

    pdc202xx_old: kill resetproc() method
    
    The driver's resetproc() method resets both channels at once -- most probably
    by driving RESET- on them.  Not only such reset can severely disturb concurrent
    operations on another channel, it also ensues 2-second delay, while there's no
    apparent reason why SRST reset being performed prior to resetproc() call needs
    to be followed up by another reset.
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/pdc202xx_old.c b/drivers/ide/pdc202xx_old.c
index 494b5404f277..4980dd7b2e28 100644
--- a/drivers/ide/pdc202xx_old.c
+++ b/drivers/ide/pdc202xx_old.c
@@ -203,22 +203,6 @@ static int pdc202xx_dma_end(ide_drive_t *drive)
 	return ide_dma_end(drive);
 }
 
-static void pdc202xx_reset(ide_drive_t *drive)
-{
-	ide_hwif_t *hwif	= drive->hwif;
-	unsigned long high_16	= hwif->extra_base - 16;
-	u8 udma_speed_flag	= inb(high_16 | 0x001f);
-
-	printk(KERN_WARNING "PDC202xx: software reset...\n");
-
-	outb(udma_speed_flag | 0x10, high_16 | 0x001f);
-	mdelay(100);
-	outb(udma_speed_flag & ~0x10, high_16 | 0x001f);
-	mdelay(2000);	/* 2 seconds ?! */
-
-	ide_set_max_pio(drive);
-}
-
 static int init_chipset_pdc202xx(struct pci_dev *dev)
 {
 	unsigned long dmabase = pci_resource_start(dev, 4);
@@ -279,7 +263,6 @@ static const struct ide_port_ops pdc2026x_port_ops = {
 	.set_pio_mode		= pdc202xx_set_pio_mode,
 	.set_dma_mode		= pdc202xx_set_mode,
 	.quirkproc		= pdc202xx_quirkproc,
-	.resetproc		= pdc202xx_reset,
 	.cable_detect		= pdc2026x_cable_detect,
 };
 

commit 1221e241e3a6f1ff5b0de03d58d871f7c995781b
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Sun Jun 7 15:37:04 2009 +0200

    pdc202xx_old: don't call pdc202xx_reset() on IRQ timeout
    
    The driver's dma_lost_irq() and dma_clear() methods call pdc202xx_reset()
    which resets both channels at once -- most probably by driving RESET- on them.
    Not only such reset can severely disturb concurrent operations on another
    channel, it is also a clear overkill (especially in the first case) and is
    completely unexpected and thus not properly handled by the IDE core in this
    context (in the second case the usual SRST reset would most probably ensue
    anyway though); it also causes quite arbitrary 2-second delay. Hence, use the
    standard ide_dma_lost_irq() method and don't install the optional dma_clear()
    method at all -- the driver should do well without this age-old cruft...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/pdc202xx_old.c b/drivers/ide/pdc202xx_old.c
index 668f452d74e9..494b5404f277 100644
--- a/drivers/ide/pdc202xx_old.c
+++ b/drivers/ide/pdc202xx_old.c
@@ -219,12 +219,6 @@ static void pdc202xx_reset(ide_drive_t *drive)
 	ide_set_max_pio(drive);
 }
 
-static void pdc202xx_dma_lost_irq(ide_drive_t *drive)
-{
-	pdc202xx_reset(drive);
-	ide_dma_lost_irq(drive);
-}
-
 static int init_chipset_pdc202xx(struct pci_dev *dev)
 {
 	unsigned long dmabase = pci_resource_start(dev, 4);
@@ -295,9 +289,8 @@ static const struct ide_dma_ops pdc2026x_dma_ops = {
 	.dma_start		= pdc202xx_dma_start,
 	.dma_end		= pdc202xx_dma_end,
 	.dma_test_irq		= ide_dma_test_irq,
-	.dma_lost_irq		= pdc202xx_dma_lost_irq,
+	.dma_lost_irq		= ide_dma_lost_irq,
 	.dma_timer_expiry	= ide_dma_sff_timer_expiry,
-	.dma_clear		= pdc202xx_reset,
 	.dma_sff_read_status	= ide_dma_sff_read_status,
 };
 

commit 72b9304f04d0724a25251e9e9041aa95f89c15dd
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Sun Jun 7 15:37:03 2009 +0200

    pdc202xx_old: use ide_dma_test_irq()
    
    The driver's dma_test_irq() method, although tests some chip specific interrupt
    bits, finally always relies on the SFF-8038i standard interrupt bit.  I see no
    point in testing the bits that are not trusted anyway -- the driver should be
    fully able to use the standard method implemetation, ide_dma_test_irq().
    
    With this change 'pdc202xx_dma_ops' finally becomes identical to 'sff_dma_ops',
    and we can get rid of it...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/pdc202xx_old.c b/drivers/ide/pdc202xx_old.c
index b3bc96f930a6..668f452d74e9 100644
--- a/drivers/ide/pdc202xx_old.c
+++ b/drivers/ide/pdc202xx_old.c
@@ -203,30 +203,6 @@ static int pdc202xx_dma_end(ide_drive_t *drive)
 	return ide_dma_end(drive);
 }
 
-static int pdc202xx_dma_test_irq(ide_drive_t *drive)
-{
-	ide_hwif_t *hwif	= drive->hwif;
-	unsigned long high_16	= hwif->extra_base - 16;
-	u8 dma_stat		= inb(hwif->dma_base + ATA_DMA_STATUS);
-	u8 sc1d			= inb(high_16 + 0x001d);
-
-	if (hwif->channel) {
-		/* bit7: Error, bit6: Interrupting, bit5: FIFO Full, bit4: FIFO Empty */
-		if ((sc1d & 0x50) == 0x50)
-			goto somebody_else;
-		else if ((sc1d & 0x40) == 0x40)
-			return (dma_stat & 4) == 4;
-	} else {
-		/* bit3: Error, bit2: Interrupting, bit1: FIFO Full, bit0: FIFO Empty */
-		if ((sc1d & 0x05) == 0x05)
-			goto somebody_else;
-		else if ((sc1d & 0x04) == 0x04)
-			return (dma_stat & 4) == 4;
-	}
-somebody_else:
-	return (dma_stat & 4) == 4;	/* return 1 if INTR asserted */
-}
-
 static void pdc202xx_reset(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif	= drive->hwif;
@@ -313,23 +289,12 @@ static const struct ide_port_ops pdc2026x_port_ops = {
 	.cable_detect		= pdc2026x_cable_detect,
 };
 
-static const struct ide_dma_ops pdc20246_dma_ops = {
-	.dma_host_set		= ide_dma_host_set,
-	.dma_setup		= ide_dma_setup,
-	.dma_start		= ide_dma_start,
-	.dma_end		= ide_dma_end,
-	.dma_test_irq		= pdc202xx_dma_test_irq,
-	.dma_lost_irq		= ide_dma_lost_irq,
-	.dma_timer_expiry	= ide_dma_sff_timer_expiry,
-	.dma_sff_read_status	= ide_dma_sff_read_status,
-};
-
 static const struct ide_dma_ops pdc2026x_dma_ops = {
 	.dma_host_set		= ide_dma_host_set,
 	.dma_setup		= ide_dma_setup,
 	.dma_start		= pdc202xx_dma_start,
 	.dma_end		= pdc202xx_dma_end,
-	.dma_test_irq		= pdc202xx_dma_test_irq,
+	.dma_test_irq		= ide_dma_test_irq,
 	.dma_lost_irq		= pdc202xx_dma_lost_irq,
 	.dma_timer_expiry	= ide_dma_sff_timer_expiry,
 	.dma_clear		= pdc202xx_reset,
@@ -354,7 +319,7 @@ static const struct ide_port_info pdc202xx_chipsets[] __devinitdata = {
 		.name		= DRV_NAME,
 		.init_chipset	= init_chipset_pdc202xx,
 		.port_ops	= &pdc20246_port_ops,
-		.dma_ops	= &pdc20246_dma_ops,
+		.dma_ops	= &sff_dma_ops,
 		.host_flags	= IDE_HFLAGS_PDC202XX,
 		.pio_mask	= ATA_PIO4,
 		.mwdma_mask	= ATA_MWDMA2,

commit 669165daad2ec839df85b8c5f7bc155e76a2f404
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Sun Jun 7 13:52:50 2009 +0200

    pdc202xx_old: fix resetproc() method
    
    pdc202xx_reset() calls pdc202xx_reset_host() twice, for both channels, while
    that function actually twiddles the single, shared software reset bit -- the
    net effect is a duplicated reset and horrendous 4 second delay happening not
    only on a channel reset but also when dma_lost_irq() and dma_clear() methods
    are called.  Fold pdc202xx_reset_host() into pdc202xx_reset(), fix printk(),
    and move it before the actual reset...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/pdc202xx_old.c b/drivers/ide/pdc202xx_old.c
index 8df26302a0b5..b3bc96f930a6 100644
--- a/drivers/ide/pdc202xx_old.c
+++ b/drivers/ide/pdc202xx_old.c
@@ -1,6 +1,6 @@
 /*
  *  Copyright (C) 1998-2002		Andre Hedrick <andre@linux-ide.org>
- *  Copyright (C) 2006-2007		MontaVista Software, Inc.
+ *  Copyright (C) 2006-2007, 2009	MontaVista Software, Inc.
  *  Copyright (C) 2007			Bartlomiej Zolnierkiewicz
  *
  *  Portions Copyright (C) 1999 Promise Technology, Inc.
@@ -227,28 +227,19 @@ static int pdc202xx_dma_test_irq(ide_drive_t *drive)
 	return (dma_stat & 4) == 4;	/* return 1 if INTR asserted */
 }
 
-static void pdc202xx_reset_host (ide_hwif_t *hwif)
+static void pdc202xx_reset(ide_drive_t *drive)
 {
+	ide_hwif_t *hwif	= drive->hwif;
 	unsigned long high_16	= hwif->extra_base - 16;
 	u8 udma_speed_flag	= inb(high_16 | 0x001f);
 
+	printk(KERN_WARNING "PDC202xx: software reset...\n");
+
 	outb(udma_speed_flag | 0x10, high_16 | 0x001f);
 	mdelay(100);
 	outb(udma_speed_flag & ~0x10, high_16 | 0x001f);
 	mdelay(2000);	/* 2 seconds ?! */
 
-	printk(KERN_WARNING "PDC202XX: %s channel reset.\n",
-		hwif->channel ? "Secondary" : "Primary");
-}
-
-static void pdc202xx_reset (ide_drive_t *drive)
-{
-	ide_hwif_t *hwif	= drive->hwif;
-	ide_hwif_t *mate	= hwif->mate;
-
-	pdc202xx_reset_host(hwif);
-	pdc202xx_reset_host(mate);
-
 	ide_set_max_pio(drive);
 }
 

commit 521a415c9f6d4e5463807ce6d36598acabcd204f
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Sun Jun 7 13:52:50 2009 +0200

    pdc202xx_old: fix 'pdc20246_dma_ops'
    
    Commit ac95beedf8bc97b24f9540d4da9952f07221c023 (ide: add struct ide_port_ops
    (take 2)) erroneously converted the driver's dma_timeout() and dma_lost_irq()
    methods to call the driver's resetproc() method regardless of whether it was
    defined for this specific controller while it hadn't been defined and hence
    called for PDC20246. So the dma_clear() method, the successor of dma_timeout(),
    shouldn't exist and the dma_lost_irq() method should be standard for PDC20246.
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/pdc202xx_old.c b/drivers/ide/pdc202xx_old.c
index 248a54bd2386..8df26302a0b5 100644
--- a/drivers/ide/pdc202xx_old.c
+++ b/drivers/ide/pdc202xx_old.c
@@ -328,9 +328,8 @@ static const struct ide_dma_ops pdc20246_dma_ops = {
 	.dma_start		= ide_dma_start,
 	.dma_end		= ide_dma_end,
 	.dma_test_irq		= pdc202xx_dma_test_irq,
-	.dma_lost_irq		= pdc202xx_dma_lost_irq,
+	.dma_lost_irq		= ide_dma_lost_irq,
 	.dma_timer_expiry	= ide_dma_sff_timer_expiry,
-	.dma_clear		= pdc202xx_reset,
 	.dma_sff_read_status	= ide_dma_sff_read_status,
 };
 

commit 9780e2dd8254351f6cbe11304849126b51dbd561
Author: Tejun Heo <tj@kernel.org>
Date:   Thu May 7 22:24:40 2009 +0900

    ide: convert to rq pos and nr_sectors accessors
    
    ide doesn't manipulate request fields anymore and thus all hard and
    their soft equivalents are always equal.  Convert all references to
    accessors.
    
    [ Impact: use pos and nr_sectors accessors ]
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Cc: Borislav Petkov <petkovbb@googlemail.com>
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/ide/pdc202xx_old.c b/drivers/ide/pdc202xx_old.c
index 248a54bd2386..c2a16a8f486d 100644
--- a/drivers/ide/pdc202xx_old.c
+++ b/drivers/ide/pdc202xx_old.c
@@ -177,7 +177,7 @@ static void pdc202xx_dma_start(ide_drive_t *drive)
 		u8 clock = inb(high_16 + 0x11);
 
 		outb(clock | (hwif->channel ? 0x08 : 0x02), high_16 + 0x11);
-		word_count = (rq->nr_sectors << 8);
+		word_count = (blk_rq_sectors(rq) << 8);
 		word_count = (rq_data_dir(rq) == READ) ?
 					word_count | 0x05000000 :
 					word_count | 0x06000000;

commit 35c9b4daf4c94b30e5cede597d98016ebf31b5ad
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Mar 31 20:15:19 2009 +0200

    ide: add ->dma_clear method and remove ->dma_timeout one
    
    All custom ->dma_timeout implementations call the generic one thus it is
    possible to have only an optional method for resetting DMA engine instead:
    
    * Add ->dma_clear method and convert hpt366, pdc202xx_old and sl82c105
      host drivers to use it.
    
    * Always use ide_dma_timeout() in ide_dma_timeout_retry() and remove
     ->dma_timeout method.
    
    * Make ide_dma_timeout() static.
    
    There should be no functional changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/pdc202xx_old.c b/drivers/ide/pdc202xx_old.c
index f7536d1943f7..248a54bd2386 100644
--- a/drivers/ide/pdc202xx_old.c
+++ b/drivers/ide/pdc202xx_old.c
@@ -258,12 +258,6 @@ static void pdc202xx_dma_lost_irq(ide_drive_t *drive)
 	ide_dma_lost_irq(drive);
 }
 
-static void pdc202xx_dma_timeout(ide_drive_t *drive)
-{
-	pdc202xx_reset(drive);
-	ide_dma_timeout(drive);
-}
-
 static int init_chipset_pdc202xx(struct pci_dev *dev)
 {
 	unsigned long dmabase = pci_resource_start(dev, 4);
@@ -336,7 +330,7 @@ static const struct ide_dma_ops pdc20246_dma_ops = {
 	.dma_test_irq		= pdc202xx_dma_test_irq,
 	.dma_lost_irq		= pdc202xx_dma_lost_irq,
 	.dma_timer_expiry	= ide_dma_sff_timer_expiry,
-	.dma_timeout		= pdc202xx_dma_timeout,
+	.dma_clear		= pdc202xx_reset,
 	.dma_sff_read_status	= ide_dma_sff_read_status,
 };
 
@@ -348,7 +342,7 @@ static const struct ide_dma_ops pdc2026x_dma_ops = {
 	.dma_test_irq		= pdc202xx_dma_test_irq,
 	.dma_lost_irq		= pdc202xx_dma_lost_irq,
 	.dma_timer_expiry	= ide_dma_sff_timer_expiry,
-	.dma_timeout		= pdc202xx_dma_timeout,
+	.dma_clear		= pdc202xx_reset,
 	.dma_sff_read_status	= ide_dma_sff_read_status,
 };
 

commit 22117d6eaac50d366d9013c88318a869ea4d8739
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Mar 27 12:46:47 2009 +0100

    ide: add ->dma_timer_expiry method and remove ->dma_exec_cmd one (v2)
    
    * Rename dma_timer_expiry() to ide_dma_sff_timer_expiry() and export it.
    
    * Add ->dma_timer_expiry method and use it to set hwif->expiry for
      ATA_PROT_DMA protocol in do_rw_taskfile().
    
    * Initialize ->dma_timer_expiry to ide_dma_sff_timer_expiry() for SFF hosts.
    
    * Move setting hwif->expiry from ide_execute_command() to its users and drop
      'expiry' argument.
    
    * Use ide_execute_command() instead of ->dma_exec_cmd in do_rw_taskfile().
    
    * Remove ->dma_exec_cmd method and its implementations.
    
    * Unexport ide_execute_command() and ide_dma_intr().
    
    v2:
    * Fix CONFIG_BLK_DEV_IDEDMA=n build (noticed by Randy Dunlap).
    
    * Fix *dma_expiry naming (suggested by Sergei Shtylyov).
    
    There should be no functional changes caused by this patch.
    
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/pdc202xx_old.c b/drivers/ide/pdc202xx_old.c
index cba66ebce4e3..f7536d1943f7 100644
--- a/drivers/ide/pdc202xx_old.c
+++ b/drivers/ide/pdc202xx_old.c
@@ -331,11 +331,11 @@ static const struct ide_port_ops pdc2026x_port_ops = {
 static const struct ide_dma_ops pdc20246_dma_ops = {
 	.dma_host_set		= ide_dma_host_set,
 	.dma_setup		= ide_dma_setup,
-	.dma_exec_cmd		= ide_dma_exec_cmd,
 	.dma_start		= ide_dma_start,
 	.dma_end		= ide_dma_end,
 	.dma_test_irq		= pdc202xx_dma_test_irq,
 	.dma_lost_irq		= pdc202xx_dma_lost_irq,
+	.dma_timer_expiry	= ide_dma_sff_timer_expiry,
 	.dma_timeout		= pdc202xx_dma_timeout,
 	.dma_sff_read_status	= ide_dma_sff_read_status,
 };
@@ -343,11 +343,11 @@ static const struct ide_dma_ops pdc20246_dma_ops = {
 static const struct ide_dma_ops pdc2026x_dma_ops = {
 	.dma_host_set		= ide_dma_host_set,
 	.dma_setup		= ide_dma_setup,
-	.dma_exec_cmd		= ide_dma_exec_cmd,
 	.dma_start		= pdc202xx_dma_start,
 	.dma_end		= pdc202xx_dma_end,
 	.dma_test_irq		= pdc202xx_dma_test_irq,
 	.dma_lost_irq		= pdc202xx_dma_lost_irq,
+	.dma_timer_expiry	= ide_dma_sff_timer_expiry,
 	.dma_timeout		= pdc202xx_dma_timeout,
 	.dma_sff_read_status	= ide_dma_sff_read_status,
 };

commit 2ed0ef543ae3f3ea4f8bd0433fb1fed22625a309
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Mar 24 23:22:53 2009 +0100

    ide: fix ->init_chipset method to return 'int' value
    
    * Return 0 instead of dev->irq in ->init_chipset implementations.
    
    * Fix ->init_chipset method to return 'int' value instead of
      'unsigned int' one.
    
    This fixes ->init_chipset handling for host drivers (cs5530, hpt366
    and pdc202xx_new) for which it is possible for this method to fail.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/pdc202xx_old.c b/drivers/ide/pdc202xx_old.c
index 97193323aebf..cba66ebce4e3 100644
--- a/drivers/ide/pdc202xx_old.c
+++ b/drivers/ide/pdc202xx_old.c
@@ -264,7 +264,7 @@ static void pdc202xx_dma_timeout(ide_drive_t *drive)
 	ide_dma_timeout(drive);
 }
 
-static unsigned int init_chipset_pdc202xx(struct pci_dev *dev)
+static int init_chipset_pdc202xx(struct pci_dev *dev)
 {
 	unsigned long dmabase = pci_resource_start(dev, 4);
 	u8 udma_speed_flag = 0, primary_mode = 0, secondary_mode = 0;
@@ -290,7 +290,7 @@ static unsigned int init_chipset_pdc202xx(struct pci_dev *dev)
 		printk("%sACTIVE\n", (inb(dmabase | 0x1f) & 1) ? "" : "IN");
 	}
 out:
-	return dev->irq;
+	return 0;
 }
 
 static void __devinit pdc202ata4_fixup_irq(struct pci_dev *dev,

commit 592b5315219881c6c0af4785f96456ad2043193a
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Tue Jan 6 17:21:02 2009 +0100

    ide: move read_sff_dma_status() method to 'struct ide_dma_ops'
    
    Move apparently misplaced read_sff_dma_status() method from 'struct ide_tp_ops'
    to 'struct ide_dma_ops', renaming it to dma_sff_read_status() and making only
    required for SFF-8038i compatible IDE controller drivers (greatly cutting down
    the number of initializers) as its only user (outside ide-dma-sff.c and such
    drivers) appears to be ide_pci_check_simplex() which is only called for such
    controllers...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/pdc202xx_old.c b/drivers/ide/pdc202xx_old.c
index e8e6b29d9e41..97193323aebf 100644
--- a/drivers/ide/pdc202xx_old.c
+++ b/drivers/ide/pdc202xx_old.c
@@ -337,6 +337,7 @@ static const struct ide_dma_ops pdc20246_dma_ops = {
 	.dma_test_irq		= pdc202xx_dma_test_irq,
 	.dma_lost_irq		= pdc202xx_dma_lost_irq,
 	.dma_timeout		= pdc202xx_dma_timeout,
+	.dma_sff_read_status	= ide_dma_sff_read_status,
 };
 
 static const struct ide_dma_ops pdc2026x_dma_ops = {
@@ -348,6 +349,7 @@ static const struct ide_dma_ops pdc2026x_dma_ops = {
 	.dma_test_irq		= pdc202xx_dma_test_irq,
 	.dma_lost_irq		= pdc202xx_dma_lost_irq,
 	.dma_timeout		= pdc202xx_dma_timeout,
+	.dma_sff_read_status	= ide_dma_sff_read_status,
 };
 
 #define DECLARE_PDC2026X_DEV(udma, sectors) \

commit 898ec223fea2a2df88035e58dbf50f493577e225
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jan 6 17:20:52 2009 +0100

    ide: remove HWIF() macro
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/pdc202xx_old.c b/drivers/ide/pdc202xx_old.c
index 072ef70bf061..e8e6b29d9e41 100644
--- a/drivers/ide/pdc202xx_old.c
+++ b/drivers/ide/pdc202xx_old.c
@@ -39,7 +39,7 @@ static void pdc_old_disable_66MHz_clock(ide_hwif_t *);
 
 static void pdc202xx_set_mode(ide_drive_t *drive, const u8 speed)
 {
-	ide_hwif_t *hwif	= HWIF(drive);
+	ide_hwif_t *hwif	= drive->hwif;
 	struct pci_dev *dev	= to_pci_dev(hwif->dev);
 	u8 drive_pci		= 0x60 + (drive->dn << 2);
 
@@ -169,7 +169,7 @@ static void pdc202xx_dma_start(ide_drive_t *drive)
 	if (drive->current_speed > XFER_UDMA_2)
 		pdc_old_enable_66MHz_clock(drive->hwif);
 	if (drive->media != ide_disk || (drive->dev_flags & IDE_DFLAG_LBA48)) {
-		ide_hwif_t *hwif	= HWIF(drive);
+		ide_hwif_t *hwif	= drive->hwif;
 		struct request *rq	= hwif->rq;
 		unsigned long high_16	= hwif->extra_base - 16;
 		unsigned long atapi_reg	= high_16 + (hwif->channel ? 0x24 : 0x20);
@@ -189,7 +189,7 @@ static void pdc202xx_dma_start(ide_drive_t *drive)
 static int pdc202xx_dma_end(ide_drive_t *drive)
 {
 	if (drive->media != ide_disk || (drive->dev_flags & IDE_DFLAG_LBA48)) {
-		ide_hwif_t *hwif	= HWIF(drive);
+		ide_hwif_t *hwif	= drive->hwif;
 		unsigned long high_16	= hwif->extra_base - 16;
 		unsigned long atapi_reg	= high_16 + (hwif->channel ? 0x24 : 0x20);
 		u8 clock		= 0;
@@ -205,7 +205,7 @@ static int pdc202xx_dma_end(ide_drive_t *drive)
 
 static int pdc202xx_dma_test_irq(ide_drive_t *drive)
 {
-	ide_hwif_t *hwif	= HWIF(drive);
+	ide_hwif_t *hwif	= drive->hwif;
 	unsigned long high_16	= hwif->extra_base - 16;
 	u8 dma_stat		= inb(hwif->dma_base + ATA_DMA_STATUS);
 	u8 sc1d			= inb(high_16 + 0x001d);
@@ -243,7 +243,7 @@ static void pdc202xx_reset_host (ide_hwif_t *hwif)
 
 static void pdc202xx_reset (ide_drive_t *drive)
 {
-	ide_hwif_t *hwif	= HWIF(drive);
+	ide_hwif_t *hwif	= drive->hwif;
 	ide_hwif_t *mate	= hwif->mate;
 
 	pdc202xx_reset_host(hwif);

commit b65fac32cfe3b2f98cd472fef400bd1c1340de23
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jan 6 17:20:50 2009 +0100

    ide: merge ide_hwgroup_t with ide_hwif_t (v2)
    
    * Merge ide_hwgroup_t with ide_hwif_t.
    
    * Cleanup init_irq() accordingly, then remove no longer needed
      ide_remove_port_from_hwgroup() and ide_ports[].
    
    * Remove now unused HWGROUP() macro.
    
    While at it:
    
    * ide_dump_ata_error() fixups
    
    v2:
    * Fix ->quirk_list check in do_ide_request()
      (s/hwif->cur_dev/prev_port->cur_dev).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/pdc202xx_old.c b/drivers/ide/pdc202xx_old.c
index 624e62e5cc9a..072ef70bf061 100644
--- a/drivers/ide/pdc202xx_old.c
+++ b/drivers/ide/pdc202xx_old.c
@@ -169,8 +169,8 @@ static void pdc202xx_dma_start(ide_drive_t *drive)
 	if (drive->current_speed > XFER_UDMA_2)
 		pdc_old_enable_66MHz_clock(drive->hwif);
 	if (drive->media != ide_disk || (drive->dev_flags & IDE_DFLAG_LBA48)) {
-		struct request *rq	= HWGROUP(drive)->rq;
 		ide_hwif_t *hwif	= HWIF(drive);
+		struct request *rq	= hwif->rq;
 		unsigned long high_16	= hwif->extra_base - 16;
 		unsigned long atapi_reg	= high_16 + (hwif->channel ? 0x24 : 0x20);
 		u32 word_count	= 0;

commit 6b4924962c49655494d2c8e9d3faab0e349a3062
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Dec 29 20:27:34 2008 +0100

    ide: add ->max_sectors field to struct ide_port_info
    
    * Add ->max_sectors field to struct ide_port_info to allow host drivers
      to specify value used for hwif->rqsize (if smaller than the default).
    
    * Convert pdc202xx_old to use ->max_sectors and remove no longer needed
      IDE_HFLAG_RQSIZE_256 flag.
    
    There should be no functional changes caused by this patch.
    
    Acked-by: Sergei Shtyltov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/pdc202xx_old.c b/drivers/ide/pdc202xx_old.c
index 799557c25eef..624e62e5cc9a 100644
--- a/drivers/ide/pdc202xx_old.c
+++ b/drivers/ide/pdc202xx_old.c
@@ -350,16 +350,17 @@ static const struct ide_dma_ops pdc2026x_dma_ops = {
 	.dma_timeout		= pdc202xx_dma_timeout,
 };
 
-#define DECLARE_PDC2026X_DEV(udma, extra_flags) \
+#define DECLARE_PDC2026X_DEV(udma, sectors) \
 	{ \
 		.name		= DRV_NAME, \
 		.init_chipset	= init_chipset_pdc202xx, \
 		.port_ops	= &pdc2026x_port_ops, \
 		.dma_ops	= &pdc2026x_dma_ops, \
-		.host_flags	= IDE_HFLAGS_PDC202XX | extra_flags, \
+		.host_flags	= IDE_HFLAGS_PDC202XX, \
 		.pio_mask	= ATA_PIO4, \
 		.mwdma_mask	= ATA_MWDMA2, \
 		.udma_mask	= udma, \
+		.max_sectors	= sectors, \
 	}
 
 static const struct ide_port_info pdc202xx_chipsets[] __devinitdata = {
@@ -376,8 +377,8 @@ static const struct ide_port_info pdc202xx_chipsets[] __devinitdata = {
 
 	/* 1: PDC2026{2,3} */
 	DECLARE_PDC2026X_DEV(ATA_UDMA4, 0),
-	/* 2: PDC2026{5,7} */
-	DECLARE_PDC2026X_DEV(ATA_UDMA5, IDE_HFLAG_RQSIZE_256),
+	/* 2: PDC2026{5,7}: UDMA5, limit LBA48 requests to 256 sectors */
+	DECLARE_PDC2026X_DEV(ATA_UDMA5, 256),
 };
 
 /**

commit 2bfba3c444fe8b2ab1c38112a89d8f03b61136ca
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Oct 21 20:57:23 2008 +0200

    ide: remove useless subdirs from drivers/ide/
    
    Suggested-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/pdc202xx_old.c b/drivers/ide/pdc202xx_old.c
new file mode 100644
index 000000000000..799557c25eef
--- /dev/null
+++ b/drivers/ide/pdc202xx_old.c
@@ -0,0 +1,453 @@
+/*
+ *  Copyright (C) 1998-2002		Andre Hedrick <andre@linux-ide.org>
+ *  Copyright (C) 2006-2007		MontaVista Software, Inc.
+ *  Copyright (C) 2007			Bartlomiej Zolnierkiewicz
+ *
+ *  Portions Copyright (C) 1999 Promise Technology, Inc.
+ *  Author: Frank Tiernan (frankt@promise.com)
+ *  Released under terms of General Public License
+ */
+
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/blkdev.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/ide.h>
+
+#include <asm/io.h>
+
+#define DRV_NAME "pdc202xx_old"
+
+#define PDC202XX_DEBUG_DRIVE_INFO	0
+
+static const char *pdc_quirk_drives[] = {
+	"QUANTUM FIREBALLlct08 08",
+	"QUANTUM FIREBALLP KA6.4",
+	"QUANTUM FIREBALLP KA9.1",
+	"QUANTUM FIREBALLP LM20.4",
+	"QUANTUM FIREBALLP KX13.6",
+	"QUANTUM FIREBALLP KX20.5",
+	"QUANTUM FIREBALLP KX27.3",
+	"QUANTUM FIREBALLP LM20.5",
+	NULL
+};
+
+static void pdc_old_disable_66MHz_clock(ide_hwif_t *);
+
+static void pdc202xx_set_mode(ide_drive_t *drive, const u8 speed)
+{
+	ide_hwif_t *hwif	= HWIF(drive);
+	struct pci_dev *dev	= to_pci_dev(hwif->dev);
+	u8 drive_pci		= 0x60 + (drive->dn << 2);
+
+	u8			AP = 0, BP = 0, CP = 0;
+	u8			TA = 0, TB = 0, TC = 0;
+
+#if PDC202XX_DEBUG_DRIVE_INFO
+	u32			drive_conf = 0;
+	pci_read_config_dword(dev, drive_pci, &drive_conf);
+#endif
+
+	/*
+	 * TODO: do this once per channel
+	 */
+	if (dev->device != PCI_DEVICE_ID_PROMISE_20246)
+		pdc_old_disable_66MHz_clock(hwif);
+
+	pci_read_config_byte(dev, drive_pci,     &AP);
+	pci_read_config_byte(dev, drive_pci + 1, &BP);
+	pci_read_config_byte(dev, drive_pci + 2, &CP);
+
+	switch(speed) {
+		case XFER_UDMA_5:
+		case XFER_UDMA_4:	TB = 0x20; TC = 0x01; break;
+		case XFER_UDMA_2:	TB = 0x20; TC = 0x01; break;
+		case XFER_UDMA_3:
+		case XFER_UDMA_1:	TB = 0x40; TC = 0x02; break;
+		case XFER_UDMA_0:
+		case XFER_MW_DMA_2:	TB = 0x60; TC = 0x03; break;
+		case XFER_MW_DMA_1:	TB = 0x60; TC = 0x04; break;
+		case XFER_MW_DMA_0:	TB = 0xE0; TC = 0x0F; break;
+		case XFER_PIO_4:	TA = 0x01; TB = 0x04; break;
+		case XFER_PIO_3:	TA = 0x02; TB = 0x06; break;
+		case XFER_PIO_2:	TA = 0x03; TB = 0x08; break;
+		case XFER_PIO_1:	TA = 0x05; TB = 0x0C; break;
+		case XFER_PIO_0:
+		default:		TA = 0x09; TB = 0x13; break;
+	}
+
+	if (speed < XFER_SW_DMA_0) {
+		/*
+		 * preserve SYNC_INT / ERDDY_EN bits while clearing
+		 * Prefetch_EN / IORDY_EN / PA[3:0] bits of register A
+		 */
+		AP &= ~0x3f;
+		if (ata_id_iordy_disable(drive->id))
+			AP |= 0x20;	/* set IORDY_EN bit */
+		if (drive->media == ide_disk)
+			AP |= 0x10;	/* set Prefetch_EN bit */
+		/* clear PB[4:0] bits of register B */
+		BP &= ~0x1f;
+		pci_write_config_byte(dev, drive_pci,     AP | TA);
+		pci_write_config_byte(dev, drive_pci + 1, BP | TB);
+	} else {
+		/* clear MB[2:0] bits of register B */
+		BP &= ~0xe0;
+		/* clear MC[3:0] bits of register C */
+		CP &= ~0x0f;
+		pci_write_config_byte(dev, drive_pci + 1, BP | TB);
+		pci_write_config_byte(dev, drive_pci + 2, CP | TC);
+	}
+
+#if PDC202XX_DEBUG_DRIVE_INFO
+	printk(KERN_DEBUG "%s: %s drive%d 0x%08x ",
+		drive->name, ide_xfer_verbose(speed),
+		drive->dn, drive_conf);
+	pci_read_config_dword(dev, drive_pci, &drive_conf);
+	printk("0x%08x\n", drive_conf);
+#endif
+}
+
+static void pdc202xx_set_pio_mode(ide_drive_t *drive, const u8 pio)
+{
+	pdc202xx_set_mode(drive, XFER_PIO_0 + pio);
+}
+
+static u8 pdc2026x_cable_detect(ide_hwif_t *hwif)
+{
+	struct pci_dev *dev = to_pci_dev(hwif->dev);
+	u16 CIS, mask = hwif->channel ? (1 << 11) : (1 << 10);
+
+	pci_read_config_word(dev, 0x50, &CIS);
+
+	return (CIS & mask) ? ATA_CBL_PATA40 : ATA_CBL_PATA80;
+}
+
+/*
+ * Set the control register to use the 66MHz system
+ * clock for UDMA 3/4/5 mode operation when necessary.
+ *
+ * FIXME: this register is shared by both channels, some locking is needed
+ *
+ * It may also be possible to leave the 66MHz clock on
+ * and readjust the timing parameters.
+ */
+static void pdc_old_enable_66MHz_clock(ide_hwif_t *hwif)
+{
+	unsigned long clock_reg = hwif->extra_base + 0x01;
+	u8 clock = inb(clock_reg);
+
+	outb(clock | (hwif->channel ? 0x08 : 0x02), clock_reg);
+}
+
+static void pdc_old_disable_66MHz_clock(ide_hwif_t *hwif)
+{
+	unsigned long clock_reg = hwif->extra_base + 0x01;
+	u8 clock = inb(clock_reg);
+
+	outb(clock & ~(hwif->channel ? 0x08 : 0x02), clock_reg);
+}
+
+static void pdc202xx_quirkproc(ide_drive_t *drive)
+{
+	const char **list, *m = (char *)&drive->id[ATA_ID_PROD];
+
+	for (list = pdc_quirk_drives; *list != NULL; list++)
+		if (strstr(m, *list) != NULL) {
+			drive->quirk_list = 2;
+			return;
+		}
+
+	drive->quirk_list = 0;
+}
+
+static void pdc202xx_dma_start(ide_drive_t *drive)
+{
+	if (drive->current_speed > XFER_UDMA_2)
+		pdc_old_enable_66MHz_clock(drive->hwif);
+	if (drive->media != ide_disk || (drive->dev_flags & IDE_DFLAG_LBA48)) {
+		struct request *rq	= HWGROUP(drive)->rq;
+		ide_hwif_t *hwif	= HWIF(drive);
+		unsigned long high_16	= hwif->extra_base - 16;
+		unsigned long atapi_reg	= high_16 + (hwif->channel ? 0x24 : 0x20);
+		u32 word_count	= 0;
+		u8 clock = inb(high_16 + 0x11);
+
+		outb(clock | (hwif->channel ? 0x08 : 0x02), high_16 + 0x11);
+		word_count = (rq->nr_sectors << 8);
+		word_count = (rq_data_dir(rq) == READ) ?
+					word_count | 0x05000000 :
+					word_count | 0x06000000;
+		outl(word_count, atapi_reg);
+	}
+	ide_dma_start(drive);
+}
+
+static int pdc202xx_dma_end(ide_drive_t *drive)
+{
+	if (drive->media != ide_disk || (drive->dev_flags & IDE_DFLAG_LBA48)) {
+		ide_hwif_t *hwif	= HWIF(drive);
+		unsigned long high_16	= hwif->extra_base - 16;
+		unsigned long atapi_reg	= high_16 + (hwif->channel ? 0x24 : 0x20);
+		u8 clock		= 0;
+
+		outl(0, atapi_reg); /* zero out extra */
+		clock = inb(high_16 + 0x11);
+		outb(clock & ~(hwif->channel ? 0x08:0x02), high_16 + 0x11);
+	}
+	if (drive->current_speed > XFER_UDMA_2)
+		pdc_old_disable_66MHz_clock(drive->hwif);
+	return ide_dma_end(drive);
+}
+
+static int pdc202xx_dma_test_irq(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif	= HWIF(drive);
+	unsigned long high_16	= hwif->extra_base - 16;
+	u8 dma_stat		= inb(hwif->dma_base + ATA_DMA_STATUS);
+	u8 sc1d			= inb(high_16 + 0x001d);
+
+	if (hwif->channel) {
+		/* bit7: Error, bit6: Interrupting, bit5: FIFO Full, bit4: FIFO Empty */
+		if ((sc1d & 0x50) == 0x50)
+			goto somebody_else;
+		else if ((sc1d & 0x40) == 0x40)
+			return (dma_stat & 4) == 4;
+	} else {
+		/* bit3: Error, bit2: Interrupting, bit1: FIFO Full, bit0: FIFO Empty */
+		if ((sc1d & 0x05) == 0x05)
+			goto somebody_else;
+		else if ((sc1d & 0x04) == 0x04)
+			return (dma_stat & 4) == 4;
+	}
+somebody_else:
+	return (dma_stat & 4) == 4;	/* return 1 if INTR asserted */
+}
+
+static void pdc202xx_reset_host (ide_hwif_t *hwif)
+{
+	unsigned long high_16	= hwif->extra_base - 16;
+	u8 udma_speed_flag	= inb(high_16 | 0x001f);
+
+	outb(udma_speed_flag | 0x10, high_16 | 0x001f);
+	mdelay(100);
+	outb(udma_speed_flag & ~0x10, high_16 | 0x001f);
+	mdelay(2000);	/* 2 seconds ?! */
+
+	printk(KERN_WARNING "PDC202XX: %s channel reset.\n",
+		hwif->channel ? "Secondary" : "Primary");
+}
+
+static void pdc202xx_reset (ide_drive_t *drive)
+{
+	ide_hwif_t *hwif	= HWIF(drive);
+	ide_hwif_t *mate	= hwif->mate;
+
+	pdc202xx_reset_host(hwif);
+	pdc202xx_reset_host(mate);
+
+	ide_set_max_pio(drive);
+}
+
+static void pdc202xx_dma_lost_irq(ide_drive_t *drive)
+{
+	pdc202xx_reset(drive);
+	ide_dma_lost_irq(drive);
+}
+
+static void pdc202xx_dma_timeout(ide_drive_t *drive)
+{
+	pdc202xx_reset(drive);
+	ide_dma_timeout(drive);
+}
+
+static unsigned int init_chipset_pdc202xx(struct pci_dev *dev)
+{
+	unsigned long dmabase = pci_resource_start(dev, 4);
+	u8 udma_speed_flag = 0, primary_mode = 0, secondary_mode = 0;
+
+	if (dmabase == 0)
+		goto out;
+
+	udma_speed_flag	= inb(dmabase | 0x1f);
+	primary_mode	= inb(dmabase | 0x1a);
+	secondary_mode	= inb(dmabase | 0x1b);
+	printk(KERN_INFO "%s: (U)DMA Burst Bit %sABLED " \
+		"Primary %s Mode " \
+		"Secondary %s Mode.\n", pci_name(dev),
+		(udma_speed_flag & 1) ? "EN" : "DIS",
+		(primary_mode & 1) ? "MASTER" : "PCI",
+		(secondary_mode & 1) ? "MASTER" : "PCI" );
+
+	if (!(udma_speed_flag & 1)) {
+		printk(KERN_INFO "%s: FORCING BURST BIT 0x%02x->0x%02x ",
+			pci_name(dev), udma_speed_flag,
+			(udma_speed_flag|1));
+		outb(udma_speed_flag | 1, dmabase | 0x1f);
+		printk("%sACTIVE\n", (inb(dmabase | 0x1f) & 1) ? "" : "IN");
+	}
+out:
+	return dev->irq;
+}
+
+static void __devinit pdc202ata4_fixup_irq(struct pci_dev *dev,
+					   const char *name)
+{
+	if ((dev->class >> 8) != PCI_CLASS_STORAGE_IDE) {
+		u8 irq = 0, irq2 = 0;
+		pci_read_config_byte(dev, PCI_INTERRUPT_LINE, &irq);
+		/* 0xbc */
+		pci_read_config_byte(dev, (PCI_INTERRUPT_LINE)|0x80, &irq2);
+		if (irq != irq2) {
+			pci_write_config_byte(dev,
+				(PCI_INTERRUPT_LINE)|0x80, irq);     /* 0xbc */
+			printk(KERN_INFO "%s %s: PCI config space interrupt "
+				"mirror fixed\n", name, pci_name(dev));
+		}
+	}
+}
+
+#define IDE_HFLAGS_PDC202XX \
+	(IDE_HFLAG_ERROR_STOPS_FIFO | \
+	 IDE_HFLAG_OFF_BOARD)
+
+static const struct ide_port_ops pdc20246_port_ops = {
+	.set_pio_mode		= pdc202xx_set_pio_mode,
+	.set_dma_mode		= pdc202xx_set_mode,
+	.quirkproc		= pdc202xx_quirkproc,
+};
+
+static const struct ide_port_ops pdc2026x_port_ops = {
+	.set_pio_mode		= pdc202xx_set_pio_mode,
+	.set_dma_mode		= pdc202xx_set_mode,
+	.quirkproc		= pdc202xx_quirkproc,
+	.resetproc		= pdc202xx_reset,
+	.cable_detect		= pdc2026x_cable_detect,
+};
+
+static const struct ide_dma_ops pdc20246_dma_ops = {
+	.dma_host_set		= ide_dma_host_set,
+	.dma_setup		= ide_dma_setup,
+	.dma_exec_cmd		= ide_dma_exec_cmd,
+	.dma_start		= ide_dma_start,
+	.dma_end		= ide_dma_end,
+	.dma_test_irq		= pdc202xx_dma_test_irq,
+	.dma_lost_irq		= pdc202xx_dma_lost_irq,
+	.dma_timeout		= pdc202xx_dma_timeout,
+};
+
+static const struct ide_dma_ops pdc2026x_dma_ops = {
+	.dma_host_set		= ide_dma_host_set,
+	.dma_setup		= ide_dma_setup,
+	.dma_exec_cmd		= ide_dma_exec_cmd,
+	.dma_start		= pdc202xx_dma_start,
+	.dma_end		= pdc202xx_dma_end,
+	.dma_test_irq		= pdc202xx_dma_test_irq,
+	.dma_lost_irq		= pdc202xx_dma_lost_irq,
+	.dma_timeout		= pdc202xx_dma_timeout,
+};
+
+#define DECLARE_PDC2026X_DEV(udma, extra_flags) \
+	{ \
+		.name		= DRV_NAME, \
+		.init_chipset	= init_chipset_pdc202xx, \
+		.port_ops	= &pdc2026x_port_ops, \
+		.dma_ops	= &pdc2026x_dma_ops, \
+		.host_flags	= IDE_HFLAGS_PDC202XX | extra_flags, \
+		.pio_mask	= ATA_PIO4, \
+		.mwdma_mask	= ATA_MWDMA2, \
+		.udma_mask	= udma, \
+	}
+
+static const struct ide_port_info pdc202xx_chipsets[] __devinitdata = {
+	{	/* 0: PDC20246 */
+		.name		= DRV_NAME,
+		.init_chipset	= init_chipset_pdc202xx,
+		.port_ops	= &pdc20246_port_ops,
+		.dma_ops	= &pdc20246_dma_ops,
+		.host_flags	= IDE_HFLAGS_PDC202XX,
+		.pio_mask	= ATA_PIO4,
+		.mwdma_mask	= ATA_MWDMA2,
+		.udma_mask	= ATA_UDMA2,
+	},
+
+	/* 1: PDC2026{2,3} */
+	DECLARE_PDC2026X_DEV(ATA_UDMA4, 0),
+	/* 2: PDC2026{5,7} */
+	DECLARE_PDC2026X_DEV(ATA_UDMA5, IDE_HFLAG_RQSIZE_256),
+};
+
+/**
+ *	pdc202xx_init_one	-	called when a PDC202xx is found
+ *	@dev: the pdc202xx device
+ *	@id: the matching pci id
+ *
+ *	Called when the PCI registration layer (or the IDE initialization)
+ *	finds a device matching our IDE device tables.
+ */
+ 
+static int __devinit pdc202xx_init_one(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	const struct ide_port_info *d;
+	u8 idx = id->driver_data;
+
+	d = &pdc202xx_chipsets[idx];
+
+	if (idx < 2)
+		pdc202ata4_fixup_irq(dev, d->name);
+
+	if (dev->vendor == PCI_DEVICE_ID_PROMISE_20265) {
+		struct pci_dev *bridge = dev->bus->self;
+
+		if (bridge &&
+		    bridge->vendor == PCI_VENDOR_ID_INTEL &&
+		    (bridge->device == PCI_DEVICE_ID_INTEL_I960 ||
+		     bridge->device == PCI_DEVICE_ID_INTEL_I960RM)) {
+			printk(KERN_INFO DRV_NAME " %s: skipping Promise "
+				"PDC20265 attached to I2O RAID controller\n",
+				pci_name(dev));
+			return -ENODEV;
+		}
+	}
+
+	return ide_pci_init_one(dev, d, NULL);
+}
+
+static const struct pci_device_id pdc202xx_pci_tbl[] = {
+	{ PCI_VDEVICE(PROMISE, PCI_DEVICE_ID_PROMISE_20246), 0 },
+	{ PCI_VDEVICE(PROMISE, PCI_DEVICE_ID_PROMISE_20262), 1 },
+	{ PCI_VDEVICE(PROMISE, PCI_DEVICE_ID_PROMISE_20263), 1 },
+	{ PCI_VDEVICE(PROMISE, PCI_DEVICE_ID_PROMISE_20265), 2 },
+	{ PCI_VDEVICE(PROMISE, PCI_DEVICE_ID_PROMISE_20267), 2 },
+	{ 0, },
+};
+MODULE_DEVICE_TABLE(pci, pdc202xx_pci_tbl);
+
+static struct pci_driver pdc202xx_pci_driver = {
+	.name		= "Promise_Old_IDE",
+	.id_table	= pdc202xx_pci_tbl,
+	.probe		= pdc202xx_init_one,
+	.remove		= ide_pci_remove,
+	.suspend	= ide_pci_suspend,
+	.resume		= ide_pci_resume,
+};
+
+static int __init pdc202xx_ide_init(void)
+{
+	return ide_pci_register_driver(&pdc202xx_pci_driver);
+}
+
+static void __exit pdc202xx_ide_exit(void)
+{
+	pci_unregister_driver(&pdc202xx_pci_driver);
+}
+
+module_init(pdc202xx_ide_init);
+module_exit(pdc202xx_ide_exit);
+
+MODULE_AUTHOR("Andre Hedrick, Frank Tiernan");
+MODULE_DESCRIPTION("PCI driver module for older Promise IDE");
+MODULE_LICENSE("GPL");
