commit 457c89965399115e5cd8bf38f9c597293405703d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:55 2019 +0100

    treewide: Add SPDX license identifier for missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have EXPORT_.*_SYMBOL_GPL inside which was used in the
       initial scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 78cb79eddc8b..7b9f655adbc2 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 #include <linux/types.h>
 #include <linux/string.h>
 #include <linux/kernel.h>

commit 1d3b9917df9725382f4e0005ecaddee114ebc847
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Apr 3 19:11:46 2018 +0200

    ide: kill ide_toggle_bounce
    
    ide_toggle_bounce did select various strange block bounce limits, including
    not bouncing at all as soon as an iommu is present in the system.  Given
    that the dma_map routines now handle any required bounce buffering except
    for ISA DMA, and the ide code already must handle either ISA DMA or highmem
    at least for iommu equipped systems we can get rid of the block layer
    bounce limit setting entirely.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index e1180fa46196..78cb79eddc8b 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -6,32 +6,6 @@
 #include <linux/ide.h>
 #include <linux/bitops.h>
 
-/**
- *	ide_toggle_bounce	-	handle bounce buffering
- *	@drive: drive to update
- *	@on: on/off boolean
- *
- *	Enable or disable bounce buffering for the device. Drives move
- *	between PIO and DMA and that changes the rules we need.
- */
-
-void ide_toggle_bounce(ide_drive_t *drive, int on)
-{
-	u64 addr = BLK_BOUNCE_HIGH;	/* dma64_addr_t */
-
-	if (!PCI_DMA_BUS_IS_PHYS) {
-		addr = BLK_BOUNCE_ANY;
-	} else if (on && drive->media == ide_disk) {
-		struct device *dev = drive->hwif->dev;
-
-		if (dev && dev->dma_mask)
-			addr = *dev->dma_mask;
-	}
-
-	if (drive->queue)
-		blk_queue_bounce_limit(drive->queue, addr);
-}
-
 u64 ide_get_lba_addr(struct ide_cmd *cmd, int lba48)
 {
 	struct ide_taskfile *tf = &cmd->tf;

commit 27f00e53af72702d3a9e6f75590e66fe04914149
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Mar 27 16:46:33 2015 +0100

    ide,ata: Rename ATA_IDX to ATA_SENSE
    
    ATA-8 defines bit 1 as 'ATA_SENSE', not 'ATA_IDX'.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index d9c9829c8b20..e1180fa46196 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -148,8 +148,8 @@ u8 ide_dump_status(ide_drive_t *drive, const char *msg, u8 stat)
 			printk(KERN_CONT "DataRequest ");
 		if (stat & ATA_CORR)
 			printk(KERN_CONT "CorrectedError ");
-		if (stat & ATA_IDX)
-			printk(KERN_CONT "Index ");
+		if (stat & ATA_SENSE)
+			printk(KERN_CONT "Sense ");
 		if (stat & ATA_ERR)
 			printk(KERN_CONT "Error ");
 	}

commit 38789fda295689689d064c0157bc363b1837b5e6
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jul 17 15:33:58 2011 -0400

    ide/ata: Add export.h for EXPORT_SYMBOL/THIS_MODULE where needed
    
    They were getting this implicitly by an include of module.h
    from device.h -- but we are going to clean that up and break
    that include chain, so include export.h explicitly now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index e386a32dc9ba..d9c9829c8b20 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -1,6 +1,7 @@
 #include <linux/types.h>
 #include <linux/string.h>
 #include <linux/kernel.h>
+#include <linux/export.h>
 #include <linux/interrupt.h>
 #include <linux/ide.h>
 #include <linux/bitops.h>

commit 9bd7de51ee8537094656149eaf45338cadb7d7d4
Merge: e4b636366c00 6a44587ee716
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Fri May 22 20:28:35 2009 +0200

    Merge branch 'master' into for-2.6.31
    
    Conflicts:
            drivers/ide/ide-io.c
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

commit cc30137a221372c67a943ad9ea68121a2bd57a6e
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri May 22 16:23:38 2009 +0200

    ide: improve failed opcode reporting
    
    Nowadays we (almost) always store the currently executing command
    in hwif->cmd so we can use it for the failed opcode reporting.
    
    Cc: Martin Lottermoser <Martin.Lottermoser@t-online.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 85b9bae111f6..2148df836ce7 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -31,24 +31,6 @@ void ide_toggle_bounce(ide_drive_t *drive, int on)
 		blk_queue_bounce_limit(drive->queue, addr);
 }
 
-static void ide_dump_opcode(ide_drive_t *drive)
-{
-	struct request *rq = drive->hwif->rq;
-	struct ide_cmd *cmd = NULL;
-
-	if (!rq)
-		return;
-
-	if (rq->cmd_type == REQ_TYPE_ATA_TASKFILE)
-		cmd = rq->special;
-
-	printk(KERN_ERR "ide: failed opcode was: ");
-	if (cmd == NULL)
-		printk(KERN_CONT "unknown\n");
-	else
-		printk(KERN_CONT "0x%02x\n", cmd->tf.command);
-}
-
 u64 ide_get_lba_addr(struct ide_cmd *cmd, int lba48)
 {
 	struct ide_taskfile *tf = &cmd->tf;
@@ -179,7 +161,10 @@ u8 ide_dump_status(ide_drive_t *drive, const char *msg, u8 stat)
 		else
 			ide_dump_atapi_error(drive, err);
 	}
-	ide_dump_opcode(drive);
+
+	printk(KERN_ERR "%s: possibly failed opcode: 0x%02x\n",
+		drive->name, drive->hwif->cmd.tf.command);
+
 	return err;
 }
 EXPORT_SYMBOL(ide_dump_status);

commit 26bfcf21e25fa090f099fa0ccf201424989cbd7b
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri May 22 16:23:37 2009 +0200

    ide: fix printk() levels in ide_dump_ata[pi]_error()
    
    Fixes "<3>" in error messages like this one:
    
    hdc: cdrom_decode_status: error=0x40 <3>{ LastFailedSense=0x04 }
    
    Reported-by: Martin Lottermoser <Martin.Lottermoser@t-online.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 56ff8c46c7d1..85b9bae111f6 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -91,7 +91,7 @@ static void ide_dump_sector(ide_drive_t *drive)
 
 static void ide_dump_ata_error(ide_drive_t *drive, u8 err)
 {
-	printk(KERN_ERR "{ ");
+	printk(KERN_CONT "{ ");
 	if (err & ATA_ABORTED)
 		printk(KERN_CONT "DriveStatusError ");
 	if (err & ATA_ICRC)
@@ -121,7 +121,7 @@ static void ide_dump_ata_error(ide_drive_t *drive, u8 err)
 
 static void ide_dump_atapi_error(ide_drive_t *drive, u8 err)
 {
-	printk(KERN_ERR "{ ");
+	printk(KERN_CONT "{ ");
 	if (err & ATAPI_ILI)
 		printk(KERN_CONT "IllegalLengthIndication ");
 	if (err & ATAPI_EOM)

commit 9780e2dd8254351f6cbe11304849126b51dbd561
Author: Tejun Heo <tj@kernel.org>
Date:   Thu May 7 22:24:40 2009 +0900

    ide: convert to rq pos and nr_sectors accessors
    
    ide doesn't manipulate request fields anymore and thus all hard and
    their soft equivalents are always equal.  Convert all references to
    accessors.
    
    [ Impact: use pos and nr_sectors accessors ]
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Cc: Borislav Petkov <petkovbb@googlemail.com>
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 56ff8c46c7d1..05b7fbc7ead5 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -114,7 +114,7 @@ static void ide_dump_ata_error(ide_drive_t *drive, u8 err)
 
 		if (rq)
 			printk(KERN_CONT ", sector=%llu",
-			       (unsigned long long)rq->sector);
+			       (unsigned long long)blk_rq_pos(rq));
 	}
 	printk(KERN_CONT "\n");
 }

commit 3153c26b54230d025c6d536e8d3015def4524906
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Wed Apr 8 14:13:03 2009 +0200

    ide: refactor tf_read() method
    
    Simplify tf_read() method, making it deal only with 'struct ide_taskfile' and
    the validity flags that the upper layer passes, and factoring out the code that
    deals with the high order bytes into ide_tf_readback() to be called from the
    only two functions interested, ide_complete_cmd() and ide_dump_sector().
    
    This should stop the needless code duplication in this method and so make
    it about twice smaller than it was; along with simplifying the setup for
    the method call, this should save both time and space...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 6857e6aaf20d..56ff8c46c7d1 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -79,7 +79,7 @@ static void ide_dump_sector(ide_drive_t *drive)
 	} else
 		cmd.valid.in.tf  = IDE_VALID_LBA | IDE_VALID_DEVICE;
 
-	drive->hwif->tp_ops->tf_read(drive, &cmd);
+	ide_tf_readback(drive, &cmd);
 
 	if (lba48 || (tf->device & ATA_LBA))
 		printk(KERN_CONT ", LBAsect=%llu",

commit 745483f10c6cefb303007c6873e2bfce54efa8ed
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Wed Apr 8 14:13:02 2009 +0200

    ide: simplify 'struct ide_taskfile'
    
    Make 'struct ide_taskfile' cover only 8 register values and thus put two such
    fields ('tf' and 'hob') into 'struct ide_cmd', dropping unnecessary 'tf_array'
    field from it.
    
    This required changing the prototype of ide_get_lba_addr() and ide_tf_dump().
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    [bart: fix setting of ATA_LBA bit for LBA48 commands in __ide_do_rw_disk()]
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index c9ef77c5d62e..6857e6aaf20d 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -49,16 +49,17 @@ static void ide_dump_opcode(ide_drive_t *drive)
 		printk(KERN_CONT "0x%02x\n", cmd->tf.command);
 }
 
-u64 ide_get_lba_addr(struct ide_taskfile *tf, int lba48)
+u64 ide_get_lba_addr(struct ide_cmd *cmd, int lba48)
 {
+	struct ide_taskfile *tf = &cmd->tf;
 	u32 high, low;
 
-	if (lba48)
-		high = (tf->hob_lbah << 16) | (tf->hob_lbam << 8) |
-			tf->hob_lbal;
-	else
-		high = tf->device & 0xf;
 	low  = (tf->lbah << 16) | (tf->lbam << 8) | tf->lbal;
+	if (lba48) {
+		tf = &cmd->hob;
+		high = (tf->lbah << 16) | (tf->lbam << 8) | tf->lbal;
+	} else
+		high = tf->device & 0xf;
 
 	return ((u64)high << 24) | low;
 }
@@ -82,7 +83,7 @@ static void ide_dump_sector(ide_drive_t *drive)
 
 	if (lba48 || (tf->device & ATA_LBA))
 		printk(KERN_CONT ", LBAsect=%llu",
-			(unsigned long long)ide_get_lba_addr(tf, lba48));
+			(unsigned long long)ide_get_lba_addr(&cmd, lba48));
 	else
 		printk(KERN_CONT ", CHS=%d/%d/%d", (tf->lbah << 8) + tf->lbam,
 			tf->device & 0xf, tf->lbal);

commit 60f85019c6c8c1aebf3485a313e0da094bc95d07
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Wed Apr 8 14:13:01 2009 +0200

    ide: replace IDE_TFLAG_* flags by IDE_VALID_*
    
    Replace IDE_TFLAG_{IN|OUT}_* flags meaning to the taskfile register validity on
    input/output by the IDE_VALID_* flags and introduce 4 symmetric 8-bit register
    validity indicator subfields, 'valid.{input/output}.{tf|hob}', into the 'struct
    ide_cmd' instead of using the 'tf_flags' field for that purpose (this field can
    then be turned from 32-bit into 8-bit one).
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 217b7fdf2b17..c9ef77c5d62e 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -71,11 +71,12 @@ static void ide_dump_sector(ide_drive_t *drive)
 	u8 lba48 = !!(drive->dev_flags & IDE_DFLAG_LBA48);
 
 	memset(&cmd, 0, sizeof(cmd));
-	if (lba48)
-		cmd.tf_flags = IDE_TFLAG_IN_LBA | IDE_TFLAG_IN_HOB_LBA |
-				IDE_TFLAG_LBA48;
-	else
-		cmd.tf_flags = IDE_TFLAG_IN_LBA | IDE_TFLAG_IN_DEVICE;
+	if (lba48) {
+		cmd.valid.in.tf  = IDE_VALID_LBA;
+		cmd.valid.in.hob = IDE_VALID_LBA;
+		cmd.tf_flags = IDE_TFLAG_LBA48;
+	} else
+		cmd.valid.in.tf  = IDE_VALID_LBA | IDE_VALID_DEVICE;
 
 	drive->hwif->tp_ops->tf_read(drive, &cmd);
 

commit 22aa4b32a19b1f231d4ce7e9af6354b577a22a35
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Mar 27 12:46:37 2009 +0100

    ide: remove ide_task_t typedef
    
    While at it:
    - rename struct ide_task_s to struct ide_cmd
    - remove stale comments from idedisk_{read_native,set}_max_address()
    - drop unused 'cmd' argument from ide_{cmd,task}_ioctl()
    - drop unused 'task' argument from tx4939ide_tf_load_fixup()
    - rename ide_complete_task() to ide_complete_cmd()
    - use consistent naming for struct ide_cmd variables
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index f6c683dd2987..217b7fdf2b17 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -34,19 +34,19 @@ void ide_toggle_bounce(ide_drive_t *drive, int on)
 static void ide_dump_opcode(ide_drive_t *drive)
 {
 	struct request *rq = drive->hwif->rq;
-	ide_task_t *task = NULL;
+	struct ide_cmd *cmd = NULL;
 
 	if (!rq)
 		return;
 
 	if (rq->cmd_type == REQ_TYPE_ATA_TASKFILE)
-		task = rq->special;
+		cmd = rq->special;
 
 	printk(KERN_ERR "ide: failed opcode was: ");
-	if (task == NULL)
+	if (cmd == NULL)
 		printk(KERN_CONT "unknown\n");
 	else
-		printk(KERN_CONT "0x%02x\n", task->tf.command);
+		printk(KERN_CONT "0x%02x\n", cmd->tf.command);
 }
 
 u64 ide_get_lba_addr(struct ide_taskfile *tf, int lba48)
@@ -66,18 +66,18 @@ EXPORT_SYMBOL_GPL(ide_get_lba_addr);
 
 static void ide_dump_sector(ide_drive_t *drive)
 {
-	ide_task_t task;
-	struct ide_taskfile *tf = &task.tf;
+	struct ide_cmd cmd;
+	struct ide_taskfile *tf = &cmd.tf;
 	u8 lba48 = !!(drive->dev_flags & IDE_DFLAG_LBA48);
 
-	memset(&task, 0, sizeof(task));
+	memset(&cmd, 0, sizeof(cmd));
 	if (lba48)
-		task.tf_flags = IDE_TFLAG_IN_LBA | IDE_TFLAG_IN_HOB_LBA |
+		cmd.tf_flags = IDE_TFLAG_IN_LBA | IDE_TFLAG_IN_HOB_LBA |
 				IDE_TFLAG_LBA48;
 	else
-		task.tf_flags = IDE_TFLAG_IN_LBA | IDE_TFLAG_IN_DEVICE;
+		cmd.tf_flags = IDE_TFLAG_IN_LBA | IDE_TFLAG_IN_DEVICE;
 
-	drive->hwif->tp_ops->tf_read(drive, &task);
+	drive->hwif->tp_ops->tf_read(drive, &cmd);
 
 	if (lba48 || (tf->device & ATA_LBA))
 		printk(KERN_CONT ", LBAsect=%llu",

commit 7eeaaaa52285d5e6cb79f515e99c591dcb9d04fe
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Mar 24 23:22:46 2009 +0100

    ide: move xfer mode tuning code to ide-xfer-mode.c
    
    * Move xfer mode tuning code to ide-xfer-mode.c.
    
    * Add CONFIG_IDE_XFER_MODE config option to be selected by host drivers
      that support xfer mode tuning.
    
    * Add CONFIG_IDE_XFER_MODE=n static inline versions of ide_set_pio()
      and ide_set_xfer_rate().
    
    * Make IDE_TIMINGS and BLK_DEV_IDEDMA config options select IDE_XFER_MODE,
      also add explicit selects for few host drivers that need it.
    
    * Build/link ide-xfer-mode.o and ide-pio-blacklist.o (it is needed only
      by ide-xfer-mode.o) only if CONFIG_IDE_XFER_MODE=y.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 09526a0de734..f6c683dd2987 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -5,163 +5,6 @@
 #include <linux/ide.h>
 #include <linux/bitops.h>
 
-static const char *udma_str[] =
-	 { "UDMA/16", "UDMA/25",  "UDMA/33",  "UDMA/44",
-	   "UDMA/66", "UDMA/100", "UDMA/133", "UDMA7" };
-static const char *mwdma_str[] =
-	{ "MWDMA0", "MWDMA1", "MWDMA2" };
-static const char *swdma_str[] =
-	{ "SWDMA0", "SWDMA1", "SWDMA2" };
-static const char *pio_str[] =
-	{ "PIO0", "PIO1", "PIO2", "PIO3", "PIO4", "PIO5" };
-
-/**
- *	ide_xfer_verbose	-	return IDE mode names
- *	@mode: transfer mode
- *
- *	Returns a constant string giving the name of the mode
- *	requested.
- */
-
-const char *ide_xfer_verbose(u8 mode)
-{
-	const char *s;
-	u8 i = mode & 0xf;
-
-	if (mode >= XFER_UDMA_0 && mode <= XFER_UDMA_7)
-		s = udma_str[i];
-	else if (mode >= XFER_MW_DMA_0 && mode <= XFER_MW_DMA_2)
-		s = mwdma_str[i];
-	else if (mode >= XFER_SW_DMA_0 && mode <= XFER_SW_DMA_2)
-		s = swdma_str[i];
-	else if (mode >= XFER_PIO_0 && mode <= XFER_PIO_5)
-		s = pio_str[i & 0x7];
-	else if (mode == XFER_PIO_SLOW)
-		s = "PIO SLOW";
-	else
-		s = "XFER ERROR";
-
-	return s;
-}
-EXPORT_SYMBOL(ide_xfer_verbose);
-
-/**
- *	ide_rate_filter		-	filter transfer mode
- *	@drive: IDE device
- *	@speed: desired speed
- *
- *	Given the available transfer modes this function returns
- *	the best available speed at or below the speed requested.
- *
- *	TODO: check device PIO capabilities
- */
-
-static u8 ide_rate_filter(ide_drive_t *drive, u8 speed)
-{
-	ide_hwif_t *hwif = drive->hwif;
-	u8 mode = ide_find_dma_mode(drive, speed);
-
-	if (mode == 0) {
-		if (hwif->pio_mask)
-			mode = fls(hwif->pio_mask) - 1 + XFER_PIO_0;
-		else
-			mode = XFER_PIO_4;
-	}
-
-/*	printk("%s: mode 0x%02x, speed 0x%02x\n", __func__, mode, speed); */
-
-	return min(speed, mode);
-}
-
-/**
- *	ide_get_best_pio_mode	-	get PIO mode from drive
- *	@drive: drive to consider
- *	@mode_wanted: preferred mode
- *	@max_mode: highest allowed mode
- *
- *	This routine returns the recommended PIO settings for a given drive,
- *	based on the drive->id information and the ide_pio_blacklist[].
- *
- *	Drive PIO mode is auto-selected if 255 is passed as mode_wanted.
- *	This is used by most chipset support modules when "auto-tuning".
- */
-
-u8 ide_get_best_pio_mode(ide_drive_t *drive, u8 mode_wanted, u8 max_mode)
-{
-	u16 *id = drive->id;
-	int pio_mode = -1, overridden = 0;
-
-	if (mode_wanted != 255)
-		return min_t(u8, mode_wanted, max_mode);
-
-	if ((drive->hwif->host_flags & IDE_HFLAG_PIO_NO_BLACKLIST) == 0)
-		pio_mode = ide_scan_pio_blacklist((char *)&id[ATA_ID_PROD]);
-
-	if (pio_mode != -1) {
-		printk(KERN_INFO "%s: is on PIO blacklist\n", drive->name);
-	} else {
-		pio_mode = id[ATA_ID_OLD_PIO_MODES] >> 8;
-		if (pio_mode > 2) {	/* 2 is maximum allowed tPIO value */
-			pio_mode = 2;
-			overridden = 1;
-		}
-
-		if (id[ATA_ID_FIELD_VALID] & 2) {	      /* ATA2? */
-			if (ata_id_has_iordy(id)) {
-				if (id[ATA_ID_PIO_MODES] & 7) {
-					overridden = 0;
-					if (id[ATA_ID_PIO_MODES] & 4)
-						pio_mode = 5;
-					else if (id[ATA_ID_PIO_MODES] & 2)
-						pio_mode = 4;
-					else
-						pio_mode = 3;
-				}
-			}
-		}
-
-		if (overridden)
-			printk(KERN_INFO "%s: tPIO > 2, assuming tPIO = 2\n",
-					 drive->name);
-	}
-
-	if (pio_mode > max_mode)
-		pio_mode = max_mode;
-
-	return pio_mode;
-}
-EXPORT_SYMBOL_GPL(ide_get_best_pio_mode);
-
-/* req_pio == "255" for auto-tune */
-void ide_set_pio(ide_drive_t *drive, u8 req_pio)
-{
-	ide_hwif_t *hwif = drive->hwif;
-	const struct ide_port_ops *port_ops = hwif->port_ops;
-	u8 host_pio, pio;
-
-	if (port_ops == NULL || port_ops->set_pio_mode == NULL ||
-	    (hwif->host_flags & IDE_HFLAG_NO_SET_MODE))
-		return;
-
-	BUG_ON(hwif->pio_mask == 0x00);
-
-	host_pio = fls(hwif->pio_mask) - 1;
-
-	pio = ide_get_best_pio_mode(drive, req_pio, host_pio);
-
-	/*
-	 * TODO:
-	 * - report device max PIO mode
-	 * - check req_pio != 255 against device max PIO mode
-	 */
-	printk(KERN_DEBUG "%s: host max PIO%d wanted PIO%d%s selected PIO%d\n",
-			  drive->name, host_pio, req_pio,
-			  req_pio == 255 ? "(auto-tune)" : "", pio);
-
-	(void)ide_set_pio_mode(drive, XFER_PIO_0 + pio);
-}
-EXPORT_SYMBOL_GPL(ide_set_pio);
-
 /**
  *	ide_toggle_bounce	-	handle bounce buffering
  *	@drive: drive to update
@@ -188,89 +31,6 @@ void ide_toggle_bounce(ide_drive_t *drive, int on)
 		blk_queue_bounce_limit(drive->queue, addr);
 }
 
-int ide_set_pio_mode(ide_drive_t *drive, const u8 mode)
-{
-	ide_hwif_t *hwif = drive->hwif;
-	const struct ide_port_ops *port_ops = hwif->port_ops;
-
-	if (hwif->host_flags & IDE_HFLAG_NO_SET_MODE)
-		return 0;
-
-	if (port_ops == NULL || port_ops->set_pio_mode == NULL)
-		return -1;
-
-	/*
-	 * TODO: temporary hack for some legacy host drivers that didn't
-	 * set transfer mode on the device in ->set_pio_mode method...
-	 */
-	if (port_ops->set_dma_mode == NULL) {
-		port_ops->set_pio_mode(drive, mode - XFER_PIO_0);
-		return 0;
-	}
-
-	if (hwif->host_flags & IDE_HFLAG_POST_SET_MODE) {
-		if (ide_config_drive_speed(drive, mode))
-			return -1;
-		port_ops->set_pio_mode(drive, mode - XFER_PIO_0);
-		return 0;
-	} else {
-		port_ops->set_pio_mode(drive, mode - XFER_PIO_0);
-		return ide_config_drive_speed(drive, mode);
-	}
-}
-
-int ide_set_dma_mode(ide_drive_t *drive, const u8 mode)
-{
-	ide_hwif_t *hwif = drive->hwif;
-	const struct ide_port_ops *port_ops = hwif->port_ops;
-
-	if (hwif->host_flags & IDE_HFLAG_NO_SET_MODE)
-		return 0;
-
-	if (port_ops == NULL || port_ops->set_dma_mode == NULL)
-		return -1;
-
-	if (hwif->host_flags & IDE_HFLAG_POST_SET_MODE) {
-		if (ide_config_drive_speed(drive, mode))
-			return -1;
-		port_ops->set_dma_mode(drive, mode);
-		return 0;
-	} else {
-		port_ops->set_dma_mode(drive, mode);
-		return ide_config_drive_speed(drive, mode);
-	}
-}
-EXPORT_SYMBOL_GPL(ide_set_dma_mode);
-
-/**
- *	ide_set_xfer_rate	-	set transfer rate
- *	@drive: drive to set
- *	@rate: speed to attempt to set
- *
- *	General helper for setting the speed of an IDE device. This
- *	function knows about user enforced limits from the configuration
- *	which ->set_pio_mode/->set_dma_mode does not.
- */
-
-int ide_set_xfer_rate(ide_drive_t *drive, u8 rate)
-{
-	ide_hwif_t *hwif = drive->hwif;
-	const struct ide_port_ops *port_ops = hwif->port_ops;
-
-	if (port_ops == NULL || port_ops->set_dma_mode == NULL ||
-	    (hwif->host_flags & IDE_HFLAG_NO_SET_MODE))
-		return -1;
-
-	rate = ide_rate_filter(drive, rate);
-
-	BUG_ON(rate < XFER_PIO_0);
-
-	if (rate >= XFER_PIO_0 && rate <= XFER_PIO_5)
-		return ide_set_pio_mode(drive, rate);
-
-	return ide_set_dma_mode(drive, rate);
-}
-
 static void ide_dump_opcode(ide_drive_t *drive)
 {
 	struct request *rq = drive->hwif->rq;

commit b65fac32cfe3b2f98cd472fef400bd1c1340de23
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jan 6 17:20:50 2009 +0100

    ide: merge ide_hwgroup_t with ide_hwif_t (v2)
    
    * Merge ide_hwgroup_t with ide_hwif_t.
    
    * Cleanup init_irq() accordingly, then remove no longer needed
      ide_remove_port_from_hwgroup() and ide_ports[].
    
    * Remove now unused HWGROUP() macro.
    
    While at it:
    
    * ide_dump_ata_error() fixups
    
    v2:
    * Fix ->quirk_list check in do_ide_request()
      (s/hwif->cur_dev/prev_port->cur_dev).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 9f6e33d8a8b2..09526a0de734 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -273,7 +273,7 @@ int ide_set_xfer_rate(ide_drive_t *drive, u8 rate)
 
 static void ide_dump_opcode(ide_drive_t *drive)
 {
-	struct request *rq = drive->hwif->hwgroup->rq;
+	struct request *rq = drive->hwif->rq;
 	ide_task_t *task = NULL;
 
 	if (!rq)
@@ -346,10 +346,13 @@ static void ide_dump_ata_error(ide_drive_t *drive, u8 err)
 	printk(KERN_CONT "}");
 	if ((err & (ATA_BBK | ATA_ABORTED)) == ATA_BBK ||
 	    (err & (ATA_UNC | ATA_IDNF | ATA_AMNF))) {
+		struct request *rq = drive->hwif->rq;
+
 		ide_dump_sector(drive);
-		if (HWGROUP(drive) && HWGROUP(drive)->rq)
+
+		if (rq)
 			printk(KERN_CONT ", sector=%llu",
-			       (unsigned long long)HWGROUP(drive)->rq->sector);
+			       (unsigned long long)rq->sector);
 	}
 	printk(KERN_CONT "\n");
 }

commit d688b72c90a7faf13c070d4ebb63cacdf481de32
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Dec 29 20:27:37 2008 +0100

    ide: remove superfluous local_irq_{save,restore}() from ide_dump_status()
    
    No reason to run this function with local IRQs off.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 7913ad5d4979..9f6e33d8a8b2 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -384,10 +384,8 @@ static void ide_dump_atapi_error(ide_drive_t *drive, u8 err)
 
 u8 ide_dump_status(ide_drive_t *drive, const char *msg, u8 stat)
 {
-	unsigned long flags;
 	u8 err = 0;
 
-	local_irq_save(flags);
 	printk(KERN_ERR "%s: %s: status=0x%02x { ", drive->name, msg, stat);
 	if (stat & ATA_BUSY)
 		printk(KERN_CONT "Busy ");
@@ -417,7 +415,6 @@ u8 ide_dump_status(ide_drive_t *drive, const char *msg, u8 stat)
 			ide_dump_atapi_error(drive, err);
 	}
 	ide_dump_opcode(drive);
-	local_irq_restore(flags);
 	return err;
 }
 EXPORT_SYMBOL(ide_dump_status);

commit 2f996acb6191b6b5f188eca1d1ad76cf1d8ecf76
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Dec 29 20:27:36 2008 +0100

    ide: checkpatch.pl fixes for ide-lib.c
    
    Fix following errors/warnings detected by checkpatch.pl:
    
    - WARNING: EXPORT_SYMBOL(foo); should immediately follow its function/variable
    - WARNING: space prohibited between function name and open parenthesis '('
    - ERROR: trailing whitespace
    - ERROR: trailing statements should be on next line
    - WARNING: printk() should include KERN_ facility level
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 1932119dfa00..7913ad5d4979 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -43,7 +43,6 @@ const char *ide_xfer_verbose(u8 mode)
 
 	return s;
 }
-
 EXPORT_SYMBOL(ide_xfer_verbose);
 
 /**
@@ -87,7 +86,7 @@ static u8 ide_rate_filter(ide_drive_t *drive, u8 speed)
  *	This is used by most chipset support modules when "auto-tuning".
  */
 
-u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode)
+u8 ide_get_best_pio_mode(ide_drive_t *drive, u8 mode_wanted, u8 max_mode)
 {
 	u16 *id = drive->id;
 	int pio_mode = -1, overridden = 0;
@@ -131,7 +130,6 @@ u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode)
 
 	return pio_mode;
 }
-
 EXPORT_SYMBOL_GPL(ide_get_best_pio_mode);
 
 /* req_pio == "255" for auto-tune */
@@ -162,7 +160,6 @@ void ide_set_pio(ide_drive_t *drive, u8 req_pio)
 
 	(void)ide_set_pio_mode(drive, XFER_PIO_0 + pio);
 }
-
 EXPORT_SYMBOL_GPL(ide_set_pio);
 
 /**
@@ -173,7 +170,7 @@ EXPORT_SYMBOL_GPL(ide_set_pio);
  *	Enable or disable bounce buffering for the device. Drives move
  *	between PIO and DMA and that changes the rules we need.
  */
- 
+
 void ide_toggle_bounce(ide_drive_t *drive, int on)
 {
 	u64 addr = BLK_BOUNCE_HIGH;	/* dma64_addr_t */
@@ -243,14 +240,13 @@ int ide_set_dma_mode(ide_drive_t *drive, const u8 mode)
 		return ide_config_drive_speed(drive, mode);
 	}
 }
-
 EXPORT_SYMBOL_GPL(ide_set_dma_mode);
 
 /**
  *	ide_set_xfer_rate	-	set transfer rate
  *	@drive: drive to set
  *	@rate: speed to attempt to set
- *	
+ *
  *	General helper for setting the speed of an IDE device. This
  *	function knows about user enforced limits from the configuration
  *	which ->set_pio_mode/->set_dma_mode does not.
@@ -286,7 +282,7 @@ static void ide_dump_opcode(ide_drive_t *drive)
 	if (rq->cmd_type == REQ_TYPE_ATA_TASKFILE)
 		task = rq->special;
 
-	printk("ide: failed opcode was: ");
+	printk(KERN_ERR "ide: failed opcode was: ");
 	if (task == NULL)
 		printk(KERN_CONT "unknown\n");
 	else
@@ -324,44 +320,55 @@ static void ide_dump_sector(ide_drive_t *drive)
 	drive->hwif->tp_ops->tf_read(drive, &task);
 
 	if (lba48 || (tf->device & ATA_LBA))
-		printk(", LBAsect=%llu",
+		printk(KERN_CONT ", LBAsect=%llu",
 			(unsigned long long)ide_get_lba_addr(tf, lba48));
 	else
-		printk(", CHS=%d/%d/%d", (tf->lbah << 8) + tf->lbam,
-					 tf->device & 0xf, tf->lbal);
+		printk(KERN_CONT ", CHS=%d/%d/%d", (tf->lbah << 8) + tf->lbam,
+			tf->device & 0xf, tf->lbal);
 }
 
 static void ide_dump_ata_error(ide_drive_t *drive, u8 err)
 {
-	printk("{ ");
-	if (err & ATA_ABORTED)	printk("DriveStatusError ");
+	printk(KERN_ERR "{ ");
+	if (err & ATA_ABORTED)
+		printk(KERN_CONT "DriveStatusError ");
 	if (err & ATA_ICRC)
-		printk((err & ATA_ABORTED) ? "BadCRC " : "BadSector ");
-	if (err & ATA_UNC)	printk("UncorrectableError ");
-	if (err & ATA_IDNF)	printk("SectorIdNotFound ");
-	if (err & ATA_TRK0NF)	printk("TrackZeroNotFound ");
-	if (err & ATA_AMNF)	printk("AddrMarkNotFound ");
-	printk("}");
+		printk(KERN_CONT "%s",
+			(err & ATA_ABORTED) ? "BadCRC " : "BadSector ");
+	if (err & ATA_UNC)
+		printk(KERN_CONT "UncorrectableError ");
+	if (err & ATA_IDNF)
+		printk(KERN_CONT "SectorIdNotFound ");
+	if (err & ATA_TRK0NF)
+		printk(KERN_CONT "TrackZeroNotFound ");
+	if (err & ATA_AMNF)
+		printk(KERN_CONT "AddrMarkNotFound ");
+	printk(KERN_CONT "}");
 	if ((err & (ATA_BBK | ATA_ABORTED)) == ATA_BBK ||
 	    (err & (ATA_UNC | ATA_IDNF | ATA_AMNF))) {
 		ide_dump_sector(drive);
 		if (HWGROUP(drive) && HWGROUP(drive)->rq)
-			printk(", sector=%llu",
+			printk(KERN_CONT ", sector=%llu",
 			       (unsigned long long)HWGROUP(drive)->rq->sector);
 	}
-	printk("\n");
+	printk(KERN_CONT "\n");
 }
 
 static void ide_dump_atapi_error(ide_drive_t *drive, u8 err)
 {
-	printk("{ ");
-	if (err & ATAPI_ILI)	printk("IllegalLengthIndication ");
-	if (err & ATAPI_EOM)	printk("EndOfMedia ");
-	if (err & ATA_ABORTED)	printk("AbortedCommand ");
-	if (err & ATA_MCR)	printk("MediaChangeRequested ");
-	if (err & ATAPI_LFS)	printk("LastFailedSense=0x%02x ",
-				       (err & ATAPI_LFS) >> 4);
-	printk("}\n");
+	printk(KERN_ERR "{ ");
+	if (err & ATAPI_ILI)
+		printk(KERN_CONT "IllegalLengthIndication ");
+	if (err & ATAPI_EOM)
+		printk(KERN_CONT "EndOfMedia ");
+	if (err & ATA_ABORTED)
+		printk(KERN_CONT "AbortedCommand ");
+	if (err & ATA_MCR)
+		printk(KERN_CONT "MediaChangeRequested ");
+	if (err & ATAPI_LFS)
+		printk(KERN_CONT "LastFailedSense=0x%02x ",
+			(err & ATAPI_LFS) >> 4);
+	printk(KERN_CONT "}\n");
 }
 
 /**
@@ -381,22 +388,29 @@ u8 ide_dump_status(ide_drive_t *drive, const char *msg, u8 stat)
 	u8 err = 0;
 
 	local_irq_save(flags);
-	printk("%s: %s: status=0x%02x { ", drive->name, msg, stat);
+	printk(KERN_ERR "%s: %s: status=0x%02x { ", drive->name, msg, stat);
 	if (stat & ATA_BUSY)
-		printk("Busy ");
+		printk(KERN_CONT "Busy ");
 	else {
-		if (stat & ATA_DRDY)	printk("DriveReady ");
-		if (stat & ATA_DF)	printk("DeviceFault ");
-		if (stat & ATA_DSC)	printk("SeekComplete ");
-		if (stat & ATA_DRQ)	printk("DataRequest ");
-		if (stat & ATA_CORR)	printk("CorrectedError ");
-		if (stat & ATA_IDX)	printk("Index ");
-		if (stat & ATA_ERR)	printk("Error ");
+		if (stat & ATA_DRDY)
+			printk(KERN_CONT "DriveReady ");
+		if (stat & ATA_DF)
+			printk(KERN_CONT "DeviceFault ");
+		if (stat & ATA_DSC)
+			printk(KERN_CONT "SeekComplete ");
+		if (stat & ATA_DRQ)
+			printk(KERN_CONT "DataRequest ");
+		if (stat & ATA_CORR)
+			printk(KERN_CONT "CorrectedError ");
+		if (stat & ATA_IDX)
+			printk(KERN_CONT "Index ");
+		if (stat & ATA_ERR)
+			printk(KERN_CONT "Error ");
 	}
-	printk("}\n");
+	printk(KERN_CONT "}\n");
 	if ((stat & (ATA_BUSY | ATA_ERR)) == ATA_ERR) {
 		err = ide_read_error(drive);
-		printk("%s: %s: error=0x%02x ", drive->name, msg, err);
+		printk(KERN_ERR "%s: %s: error=0x%02x ", drive->name, msg, err);
 		if (drive->media == ide_disk)
 			ide_dump_ata_error(drive, err);
 		else
@@ -406,5 +420,4 @@ u8 ide_dump_status(ide_drive_t *drive, const char *msg, u8 stat)
 	local_irq_restore(flags);
 	return err;
 }
-
 EXPORT_SYMBOL(ide_dump_status);

commit 1d0bf587df5b17bb93b32d760171417883ca907f
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Dec 29 20:27:30 2008 +0100

    ide: ide_hwgroup_t.rq doesn't need an ide_lock held
    
    While at it:
    - no need to check for hwgroup presence in ide_dump_opcode()
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 9fc4cfb2a272..1932119dfa00 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -277,14 +277,9 @@ int ide_set_xfer_rate(ide_drive_t *drive, u8 rate)
 
 static void ide_dump_opcode(ide_drive_t *drive)
 {
-	struct request *rq;
+	struct request *rq = drive->hwif->hwgroup->rq;
 	ide_task_t *task = NULL;
 
-	spin_lock(&ide_lock);
-	rq = NULL;
-	if (HWGROUP(drive))
-		rq = HWGROUP(drive)->rq;
-	spin_unlock(&ide_lock);
 	if (!rq)
 		return;
 

commit 97100fc816badbbc162644cfde7ad39ae9211fb4
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Oct 13 21:39:36 2008 +0200

    ide: add device flags
    
    Add 'unsigned long dev_flags' to ide_drive_t and convert bitfields
    to IDE_DFLAG_* flags.
    
    While at it:
    - IDE_DFLAG_ADDRESSING -> IDE_DFLAG_LBA48
    - fixup some comments
    - remove needless g->flags zeroing from ide*_probe()
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index ed426dd0fdd8..9fc4cfb2a272 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -317,7 +317,7 @@ static void ide_dump_sector(ide_drive_t *drive)
 {
 	ide_task_t task;
 	struct ide_taskfile *tf = &task.tf;
-	int lba48 = (drive->addressing == 1) ? 1 : 0;
+	u8 lba48 = !!(drive->dev_flags & IDE_DFLAG_LBA48);
 
 	memset(&task, 0, sizeof(task));
 	if (lba48)

commit 3ceca727fe3a38dd8d7a3adf938fefda83eee8af
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:27 2008 +0200

    ide: include <linux/hdreg.h> only when needed
    
    * Include <linux/ata.h> directly in <linux/ide.h>
      instead of through <linux/hdreg.h>.
    
    * Include <linux/hdreg.h> only when needed.
    
    Cc: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index c5c37bfd8b09..ed426dd0fdd8 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -2,7 +2,6 @@
 #include <linux/string.h>
 #include <linux/kernel.h>
 #include <linux/interrupt.h>
-#include <linux/hdreg.h>
 #include <linux/ide.h>
 #include <linux/bitops.h>
 

commit 3a7d24841ad794ae64c90d7d00d62a83741912aa
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:21 2008 +0200

    ide: use ATA_* defines instead of *_STAT and *_ERR ones
    
    * ERR_STAT   -> ATA_ERR
    * INDEX_STAT -> ATA_IDX
    * ECC_STAT   -> ATA_CORR
    * DRQ_STAT   -> ATA_DRQ
    * SEEK_STAT  -> ATA_DSC
    * WRERR_STAT -> ATA_DF
    * READY_STAT -> ATA_DRDY
    * BUSY_STAT  -> ATA_BUSY
    
    * MARK_ERR   -> ATA_AMNF
    * TRK0_ERR   -> ATA_TRK0NF
    * ABRT_ERR   -> ATA_ABORTED
    * MCR_ERR    -> ATA_MCR
    * ID_ERR     -> ATA_IDNF
    * MC_ERR     -> ATA_MC
    * ECC_ERR    -> ATA_UNC
    * ICRC_ERR   -> ATA_ICRC
    
    * BBD_ERR    -> ATA_BBK
    
    Also:
    
    * ILI_ERR    -> ATAPI_ILI
    * EOM_ERR    -> ATAPI_EOM
    * LFS_ERR    -> ATAPI_LFS
    
    * CD         -> ATAPI_COD
    * IO         -> ATAPI_IO
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 738c007a04d3..c5c37bfd8b09 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -340,16 +340,16 @@ static void ide_dump_sector(ide_drive_t *drive)
 static void ide_dump_ata_error(ide_drive_t *drive, u8 err)
 {
 	printk("{ ");
-	if (err & ABRT_ERR)	printk("DriveStatusError ");
-	if (err & ICRC_ERR)
-		printk((err & ABRT_ERR) ? "BadCRC " : "BadSector ");
-	if (err & ECC_ERR)	printk("UncorrectableError ");
-	if (err & ID_ERR)	printk("SectorIdNotFound ");
-	if (err & TRK0_ERR)	printk("TrackZeroNotFound ");
-	if (err & MARK_ERR)	printk("AddrMarkNotFound ");
+	if (err & ATA_ABORTED)	printk("DriveStatusError ");
+	if (err & ATA_ICRC)
+		printk((err & ATA_ABORTED) ? "BadCRC " : "BadSector ");
+	if (err & ATA_UNC)	printk("UncorrectableError ");
+	if (err & ATA_IDNF)	printk("SectorIdNotFound ");
+	if (err & ATA_TRK0NF)	printk("TrackZeroNotFound ");
+	if (err & ATA_AMNF)	printk("AddrMarkNotFound ");
 	printk("}");
-	if ((err & (BBD_ERR | ABRT_ERR)) == BBD_ERR ||
-	    (err & (ECC_ERR|ID_ERR|MARK_ERR))) {
+	if ((err & (ATA_BBK | ATA_ABORTED)) == ATA_BBK ||
+	    (err & (ATA_UNC | ATA_IDNF | ATA_AMNF))) {
 		ide_dump_sector(drive);
 		if (HWGROUP(drive) && HWGROUP(drive)->rq)
 			printk(", sector=%llu",
@@ -361,12 +361,12 @@ static void ide_dump_ata_error(ide_drive_t *drive, u8 err)
 static void ide_dump_atapi_error(ide_drive_t *drive, u8 err)
 {
 	printk("{ ");
-	if (err & ILI_ERR)	printk("IllegalLengthIndication ");
-	if (err & EOM_ERR)	printk("EndOfMedia ");
-	if (err & ABRT_ERR)	printk("AbortedCommand ");
-	if (err & MCR_ERR)	printk("MediaChangeRequested ");
-	if (err & LFS_ERR)	printk("LastFailedSense=0x%02x ",
-				       (err & LFS_ERR) >> 4);
+	if (err & ATAPI_ILI)	printk("IllegalLengthIndication ");
+	if (err & ATAPI_EOM)	printk("EndOfMedia ");
+	if (err & ATA_ABORTED)	printk("AbortedCommand ");
+	if (err & ATA_MCR)	printk("MediaChangeRequested ");
+	if (err & ATAPI_LFS)	printk("LastFailedSense=0x%02x ",
+				       (err & ATAPI_LFS) >> 4);
 	printk("}\n");
 }
 
@@ -388,19 +388,19 @@ u8 ide_dump_status(ide_drive_t *drive, const char *msg, u8 stat)
 
 	local_irq_save(flags);
 	printk("%s: %s: status=0x%02x { ", drive->name, msg, stat);
-	if (stat & BUSY_STAT)
+	if (stat & ATA_BUSY)
 		printk("Busy ");
 	else {
-		if (stat & READY_STAT)	printk("DriveReady ");
-		if (stat & WRERR_STAT)	printk("DeviceFault ");
-		if (stat & SEEK_STAT)	printk("SeekComplete ");
-		if (stat & DRQ_STAT)	printk("DataRequest ");
-		if (stat & ECC_STAT)	printk("CorrectedError ");
-		if (stat & INDEX_STAT)	printk("Index ");
-		if (stat & ERR_STAT)	printk("Error ");
+		if (stat & ATA_DRDY)	printk("DriveReady ");
+		if (stat & ATA_DF)	printk("DeviceFault ");
+		if (stat & ATA_DSC)	printk("SeekComplete ");
+		if (stat & ATA_DRQ)	printk("DataRequest ");
+		if (stat & ATA_CORR)	printk("CorrectedError ");
+		if (stat & ATA_IDX)	printk("Index ");
+		if (stat & ATA_ERR)	printk("Error ");
 	}
 	printk("}\n");
-	if ((stat & (BUSY_STAT|ERR_STAT)) == ERR_STAT) {
+	if ((stat & (ATA_BUSY | ATA_ERR)) == ATA_ERR) {
 		err = ide_read_error(drive);
 		printk("%s: %s: error=0x%02x ", drive->name, msg, err);
 		if (drive->media == ide_disk)

commit 48fb2688aa67baba373531cc4ed2d9e695983c3f
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:19 2008 +0200

    ide: remove drive->driveid
    
    * Factor out HDIO_[OBSOLETE,GET]_IDENTITY ioctls handling
      to ide_get_identity_ioctl().
    
    * Use temporary buffer in ide_get_identity_ioctl() instead
      of accessing drive->id directly.
    
    * Add ide_id_to_hd_driveid() inline to convert raw id into
      struct hd_driveid format (needed on big-endian).
    
    * Use ide_id_to_hd_driveid() in ide_get_identity_ioctl(),
      cleanup ide_fix_driveid() and switch ide to use use raw id.
    
    * Remove no longer needed drive->driveid.
    
      This leaves us with 3 users of struct hd_driveid in tree:
      - arch/um/drivers/ubd_kern.c
      - drivers/block/xsysace.c
      - drivers/usb/storage/isd200.c
    
    While at it:
    
    * Use ata_id_u{32,64}() and ata_id_has_{dma,lba,iordy}() macros.
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 3066d7e75c73..738c007a04d3 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -102,14 +102,14 @@ u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode)
 	if (pio_mode != -1) {
 		printk(KERN_INFO "%s: is on PIO blacklist\n", drive->name);
 	} else {
-		pio_mode = drive->driveid->tPIO;
+		pio_mode = id[ATA_ID_OLD_PIO_MODES] >> 8;
 		if (pio_mode > 2) {	/* 2 is maximum allowed tPIO value */
 			pio_mode = 2;
 			overridden = 1;
 		}
 
 		if (id[ATA_ID_FIELD_VALID] & 2) {	      /* ATA2? */
-			if (drive->driveid->capability & 8) { /* IORDY sup? */
+			if (ata_id_has_iordy(id)) {
 				if (id[ATA_ID_PIO_MODES] & 7) {
 					overridden = 0;
 					if (id[ATA_ID_PIO_MODES] & 4)

commit 4dde4492d850a4c9bcaa92e5bd7f4eebe3e2f5ab
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:19 2008 +0200

    ide: make drive->id an union (take 2)
    
    Make drive->id an unnamed union so id can be accessed either by using
    'u16 *id' or 'struct hd_driveid *driveid'.  Then convert all existing
    drive->id users accordingly (using 'u16 *id' when possible).
    
    This is an intermediate step to make ide 'struct hd_driveid'-free.
    
    While at it:
    
    - Add missing KERN_CONTs in it821x.c.
    
    - Use ATA_ID_WORDS and ATA_ID_*_LEN defines.
    
    - Remove unnecessary checks for drive->id.
    
    - s/drive_table/table/ in ide_in_drive_list().
    
    - Cleanup ide_config_drive_speed() a bit.
    
    - s/drive1/dev1/ & s/drive0/dev0/ in ide_undecoded_slave().
    
    v2:
    Fix typo in drivers/ide/ppc/pmac.c. (From Stephen Rothwell)
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 97fefabea8b8..3066d7e75c73 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -90,29 +90,31 @@ static u8 ide_rate_filter(ide_drive_t *drive, u8 speed)
 
 u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode)
 {
-	int pio_mode;
-	struct hd_driveid* id = drive->id;
-	int overridden  = 0;
+	u16 *id = drive->id;
+	int pio_mode = -1, overridden = 0;
 
 	if (mode_wanted != 255)
 		return min_t(u8, mode_wanted, max_mode);
 
-	if ((drive->hwif->host_flags & IDE_HFLAG_PIO_NO_BLACKLIST) == 0 &&
-	    (pio_mode = ide_scan_pio_blacklist(id->model)) != -1) {
+	if ((drive->hwif->host_flags & IDE_HFLAG_PIO_NO_BLACKLIST) == 0)
+		pio_mode = ide_scan_pio_blacklist((char *)&id[ATA_ID_PROD]);
+
+	if (pio_mode != -1) {
 		printk(KERN_INFO "%s: is on PIO blacklist\n", drive->name);
 	} else {
-		pio_mode = id->tPIO;
+		pio_mode = drive->driveid->tPIO;
 		if (pio_mode > 2) {	/* 2 is maximum allowed tPIO value */
 			pio_mode = 2;
 			overridden = 1;
 		}
-		if (id->field_valid & 2) {	  /* drive implements ATA2? */
-			if (id->capability & 8) { /* IORDY supported? */
-				if (id->eide_pio_modes & 7) {
+
+		if (id[ATA_ID_FIELD_VALID] & 2) {	      /* ATA2? */
+			if (drive->driveid->capability & 8) { /* IORDY sup? */
+				if (id[ATA_ID_PIO_MODES] & 7) {
 					overridden = 0;
-					if (id->eide_pio_modes & 4)
+					if (id[ATA_ID_PIO_MODES] & 4)
 						pio_mode = 5;
-					else if (id->eide_pio_modes & 2)
+					else if (id[ATA_ID_PIO_MODES] & 2)
 						pio_mode = 4;
 					else
 						pio_mode = 3;

commit 374e042c3e767ac2e5a40b78529220e0b3de793c
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 23 19:55:56 2008 +0200

    ide: add struct ide_tp_ops (take 2)
    
    * Add struct ide_tp_ops for transport methods.
    
    * Add 'const struct ide_tp_ops *tp_ops' to struct ide_port_info
      and ide_hwif_t.
    
    * Set the default hwif->tp_ops in ide_init_port_data().
    
    * Set host driver specific hwif->tp_ops in ide_init_port().
    
    * Export ide_exec_command(), ide_read_status(), ide_read_altstatus(),
      ide_read_sff_dma_status(), ide_set_irq(), ide_tf_{load,read}()
      and ata_{in,out}put_data().
    
    * Convert host drivers and core code to use struct ide_tp_ops.
    
    * Remove no longer needed default_hwif_transport().
    
    * Cleanup ide_hwif_t from methods that are now in struct ide_tp_ops.
    
    While at it:
    
    * Use struct ide_port_info in falconide.c and q40ide.c.
    
    * Rename ata_{in,out}put_data() to ide_{in,out}put_data().
    
    v2:
    
    * Fix missing convertion in ns87415.c.
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 7ac44d515470..97fefabea8b8 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -325,7 +325,7 @@ static void ide_dump_sector(ide_drive_t *drive)
 	else
 		task.tf_flags = IDE_TFLAG_IN_LBA | IDE_TFLAG_IN_DEVICE;
 
-	drive->hwif->tf_read(drive, &task);
+	drive->hwif->tp_ops->tf_read(drive, &task);
 
 	if (lba48 || (tf->device & ATA_LBA))
 		printk(", LBAsect=%llu",

commit 3b2a5c7149ee4af4aff8fee953f66fc846d92cea
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 23 19:55:56 2008 +0200

    ide: filter out "default" transfer mode values in set_xfer_rate()
    
    * Filter out "default" transfer mode values (0x00 - default PIO mode,
      0x01 - default PIO mode w/ IORDY disabled) in write handler for obsoleted
      /proc/ide/hd?/settings:current_speed setting.
    
      Allowing "default" transfer mode values is a dangerous thing to do as
      we don't support programming controller to the "default" transfer mode
      and devices often use different values for the default and maximum PIO
      mode (i.e. PIO2 default and PIO4 maximum) so the controller will stay
      programmed for higher PIO mode while device will use the lower PIO mode.
    
      There is no functionality loss as by using special IOCTLs device can
      still be programmed to "default" transfer modes (it is only useful for
      debugging/testing purposes anyway).
    
    * Remove no longer needed IDE_HFLAG_ABUSE_SET_DMA_MODE host flag, it was
      previously used by few host drivers to program the controller to PIO0
      timings for "default" transfer mode == 0x01 (although some host drivers
      would program invalid PIO timings instead).
    
    * Cleanup ide_set_xfer_rate() and add BUG_ON().
    
    Suggested-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 13af72f09ec4..7ac44d515470 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -266,22 +266,11 @@ int ide_set_xfer_rate(ide_drive_t *drive, u8 rate)
 
 	rate = ide_rate_filter(drive, rate);
 
+	BUG_ON(rate < XFER_PIO_0);
+
 	if (rate >= XFER_PIO_0 && rate <= XFER_PIO_5)
 		return ide_set_pio_mode(drive, rate);
 
-	/*
-	 * TODO: transfer modes 0x00-0x07 passed from the user-space are
-	 * currently handled here which needs fixing (please note that such
-	 * case could happen iff the transfer mode has already been set on
-	 * the device by ide-proc.c::set_xfer_rate()).
-	 */
-	if (rate < XFER_PIO_0) {
-		if (hwif->host_flags & IDE_HFLAG_ABUSE_SET_DMA_MODE)
-			return ide_set_dma_mode(drive, rate);
-		else
-			return ide_config_drive_speed(drive, rate);
-	}
-
 	return ide_set_dma_mode(drive, rate);
 }
 

commit 9ad540937554a3779c5fe7af13aa390b1d2aeb3e
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 16 20:33:39 2008 +0200

    ide: move PIO blacklist to ide-pio-blacklist.c
    
    Move PIO blacklist to ide-pio-blacklist.c.
    
    While at it:
    
    - fix comment
    
    - fix whitespace damage
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 3e12f229bd5f..13af72f09ec4 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -75,102 +75,6 @@ static u8 ide_rate_filter(ide_drive_t *drive, u8 speed)
 	return min(speed, mode);
 }
 
-/*
- * Shared data/functions for determining best PIO mode for an IDE drive.
- * Most of this stuff originally lived in cmd640.c, and changes to the
- * ide_pio_blacklist[] table should be made with EXTREME CAUTION to avoid
- * breaking the fragile cmd640.c support.
- */
-
-/*
- * Black list. Some drives incorrectly report their maximal PIO mode,
- * at least in respect to CMD640. Here we keep info on some known drives.
- */
-static struct ide_pio_info {
-	const char	*name;
-	int		pio;
-} ide_pio_blacklist [] = {
-	{ "Conner Peripherals 540MB - CFS540A", 3 },
-
-	{ "WDC AC2700",  3 },
-	{ "WDC AC2540",  3 },
-	{ "WDC AC2420",  3 },
-	{ "WDC AC2340",  3 },
-	{ "WDC AC2250",  0 },
-	{ "WDC AC2200",  0 },
-	{ "WDC AC21200", 4 },
-	{ "WDC AC2120",  0 },
-	{ "WDC AC2850",  3 },
-	{ "WDC AC1270",  3 },
-	{ "WDC AC1170",  1 },
-	{ "WDC AC1210",  1 },
-	{ "WDC AC280",   0 },
-	{ "WDC AC31000", 3 },
-	{ "WDC AC31200", 3 },
-
-	{ "Maxtor 7131 AT", 1 },
-	{ "Maxtor 7171 AT", 1 },
-	{ "Maxtor 7213 AT", 1 },
-	{ "Maxtor 7245 AT", 1 },
-	{ "Maxtor 7345 AT", 1 },
-	{ "Maxtor 7546 AT", 3 },
-	{ "Maxtor 7540 AV", 3 },
-
-	{ "SAMSUNG SHD-3121A", 1 },
-	{ "SAMSUNG SHD-3122A", 1 },
-	{ "SAMSUNG SHD-3172A", 1 },
-
-	{ "ST5660A",  3 },
-	{ "ST3660A",  3 },
-	{ "ST3630A",  3 },
-	{ "ST3655A",  3 },
-	{ "ST3391A",  3 },
-	{ "ST3390A",  1 },
-	{ "ST3600A",  1 },
-	{ "ST3290A",  0 },
-	{ "ST3144A",  0 },
-	{ "ST3491A",  1 },	/* reports 3, should be 1 or 2 (depending on */	
-				/* drive) according to Seagates FIND-ATA program */
-
-	{ "QUANTUM ELS127A", 0 },
-	{ "QUANTUM ELS170A", 0 },
-	{ "QUANTUM LPS240A", 0 },
-	{ "QUANTUM LPS210A", 3 },
-	{ "QUANTUM LPS270A", 3 },
-	{ "QUANTUM LPS365A", 3 },
-	{ "QUANTUM LPS540A", 3 },
-	{ "QUANTUM LIGHTNING 540A", 3 },
-	{ "QUANTUM LIGHTNING 730A", 3 },
-
-        { "QUANTUM FIREBALL_540", 3 }, /* Older Quantum Fireballs don't work */
-        { "QUANTUM FIREBALL_640", 3 }, 
-        { "QUANTUM FIREBALL_1080", 3 },
-        { "QUANTUM FIREBALL_1280", 3 },
-	{ NULL,	0 }
-};
-
-/**
- *	ide_scan_pio_blacklist 	-	check for a blacklisted drive
- *	@model: Drive model string
- *
- *	This routine searches the ide_pio_blacklist for an entry
- *	matching the start/whole of the supplied model name.
- *
- *	Returns -1 if no match found.
- *	Otherwise returns the recommended PIO mode from ide_pio_blacklist[].
- */
-
-static int ide_scan_pio_blacklist (char *model)
-{
-	struct ide_pio_info *p;
-
-	for (p = ide_pio_blacklist; p->name != NULL; p++) {
-		if (strncmp(p->name, model, strlen(p->name)) == 0)
-			return p->pio;
-	}
-	return -1;
-}
-
 /**
  *	ide_get_best_pio_mode	-	get PIO mode from drive
  *	@drive: drive to consider

commit 3e153cfb5e38ae237ff27a10a833946ac95db8a4
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 16 20:33:39 2008 +0200

    ide: remove no longer used ide_pio_timings[]
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index efa5bfa64d01..3e12f229bd5f 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -75,23 +75,6 @@ static u8 ide_rate_filter(ide_drive_t *drive, u8 speed)
 	return min(speed, mode);
 }
 
-/*
- * Standard (generic) timings for PIO modes, from ATA2 specification.
- * These timings are for access to the IDE data port register *only*.
- * Some drives may specify a mode, while also specifying a different
- * value for cycle_time (from drive identification data).
- */
-const ide_pio_timings_t ide_pio_timings[6] = {
-	{ 70,	165,	600 },	/* PIO Mode 0 */
-	{ 50,	125,	383 },	/* PIO Mode 1 */
-	{ 30,	100,	240 },	/* PIO Mode 2 */
-	{ 30,	80,	180 },	/* PIO Mode 3 with IORDY */
-	{ 25,	70,	120 },	/* PIO Mode 4 with IORDY */
-	{ 20,	50,	100 }	/* PIO Mode 5 with IORDY (nonstandard) */
-};
-
-EXPORT_SYMBOL_GPL(ide_pio_timings);
-
 /*
  * Shared data/functions for determining best PIO mode for an IDE drive.
  * Most of this stuff originally lived in cmd640.c, and changes to the

commit c9d6c1a2379373219bb3271bdcbdc0ab2edf349d
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 16 20:33:39 2008 +0200

    ide: move ide_pio_cycle_time() to ide-timings.c
    
    All ide_pio_cycle_time() users already select CONFIG_IDE_TIMINGS
    so move the function from ide-lib.c to ide-timings.c.
    
    While at it:
    
    - convert ide_pio_cycle_time() to use ide_timing_find_mode()
    
    - cleanup ide_pio_cycle_time() a bit
    
    There should be no functional changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 7e053d217732..efa5bfa64d01 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -188,29 +188,6 @@ static int ide_scan_pio_blacklist (char *model)
 	return -1;
 }
 
-unsigned int ide_pio_cycle_time(ide_drive_t *drive, u8 pio)
-{
-	struct hd_driveid *id = drive->id;
-	int cycle_time = 0;
-
-	if (id->field_valid & 2) {
-		if (id->capability & 8)
-			cycle_time = id->eide_pio_iordy;
-		else
-			cycle_time = id->eide_pio;
-	}
-
-	/* conservative "downgrade" for all pre-ATA2 drives */
-	if (pio < 3) {
-		if (cycle_time && cycle_time < ide_pio_timings[pio].cycle_time)
-			cycle_time = 0; /* use standard timing */
-	}
-
-	return cycle_time ? cycle_time : ide_pio_timings[pio].cycle_time;
-}
-
-EXPORT_SYMBOL_GPL(ide_pio_cycle_time);
-
 /**
  *	ide_get_best_pio_mode	-	get PIO mode from drive
  *	@drive: drive to consider

commit e4e8d02f56f5c0cefc6713384629e068193d706a
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 16 20:33:35 2008 +0200

    ide: remove needless includes from ide-lib.c
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 47af80df6872..7e053d217732 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -1,26 +1,11 @@
-#include <linux/module.h>
 #include <linux/types.h>
 #include <linux/string.h>
 #include <linux/kernel.h>
-#include <linux/timer.h>
-#include <linux/mm.h>
 #include <linux/interrupt.h>
-#include <linux/major.h>
-#include <linux/errno.h>
-#include <linux/genhd.h>
-#include <linux/blkpg.h>
-#include <linux/slab.h>
-#include <linux/pci.h>
-#include <linux/delay.h>
 #include <linux/hdreg.h>
 #include <linux/ide.h>
 #include <linux/bitops.h>
 
-#include <asm/byteorder.h>
-#include <asm/irq.h>
-#include <asm/uaccess.h>
-#include <asm/io.h>
-
 static const char *udma_str[] =
 	 { "UDMA/16", "UDMA/25",  "UDMA/33",  "UDMA/44",
 	   "UDMA/66", "UDMA/100", "UDMA/133", "UDMA7" };

commit 94cd5b62ff9bb07ef065333eb97438f115a75890
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Apr 28 23:44:40 2008 +0200

    ide: add ->tf_load and ->tf_read methods
    
    * Add ->tf_load and ->tf_read methods to ide_hwif_t and set the default
      methods in default_hwif_transport().
    
    * Use ->tf_{load,read} instead o calling ide_tf_{load,read}() directly.
    
    * Make ide_tf_{load,read}() static.
    
    There should be no functional changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 6f04ea3e93a8..47af80df6872 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -487,7 +487,7 @@ static void ide_dump_sector(ide_drive_t *drive)
 	else
 		task.tf_flags = IDE_TFLAG_IN_LBA | IDE_TFLAG_IN_DEVICE;
 
-	ide_tf_read(drive, &task);
+	drive->hwif->tf_read(drive, &task);
 
 	if (lba48 || (tf->device & ATA_LBA))
 		printk(", LBAsect=%llu",

commit eb63963a55f039f049d0dd1121f91f332af6ecc9
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Sat Apr 26 22:25:20 2008 +0200

    ide: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    [bart: fix checkpatch.pl errors in ide-lib.c and ppc/mpc8xx.c while at it]
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 46443f163154..6f04ea3e93a8 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -85,7 +85,7 @@ static u8 ide_rate_filter(ide_drive_t *drive, u8 speed)
 			mode = XFER_PIO_4;
 	}
 
-//	printk("%s: mode 0x%02x, speed 0x%02x\n", __FUNCTION__, mode, speed);
+/*	printk("%s: mode 0x%02x, speed 0x%02x\n", __func__, mode, speed); */
 
 	return min(speed, mode);
 }

commit ac95beedf8bc97b24f9540d4da9952f07221c023
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 22:25:14 2008 +0200

    ide: add struct ide_port_ops (take 2)
    
    * Move hooks for port/host specific methods from ide_hwif_t to
      'struct ide_port_ops'.
    
    * Add 'const struct ide_port_ops *port_ops' to 'struct ide_port_info'
      and ide_hwif_t.
    
    * Update host drivers and core code accordingly.
    
    While at it:
    
    * Rename ata66_*() cable detect functions to *_cable_detect() to match
      the standard naming. (Suggested by Sergei Shtylyov)
    
    v2:
    * Fix build for bast-ide. (Noticed by Andrew Morton)
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index c859de77aa8f..46443f163154 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -288,9 +288,10 @@ EXPORT_SYMBOL_GPL(ide_get_best_pio_mode);
 void ide_set_pio(ide_drive_t *drive, u8 req_pio)
 {
 	ide_hwif_t *hwif = drive->hwif;
+	const struct ide_port_ops *port_ops = hwif->port_ops;
 	u8 host_pio, pio;
 
-	if (hwif->set_pio_mode == NULL ||
+	if (port_ops == NULL || port_ops->set_pio_mode == NULL ||
 	    (hwif->host_flags & IDE_HFLAG_NO_SET_MODE))
 		return;
 
@@ -343,29 +344,30 @@ void ide_toggle_bounce(ide_drive_t *drive, int on)
 int ide_set_pio_mode(ide_drive_t *drive, const u8 mode)
 {
 	ide_hwif_t *hwif = drive->hwif;
+	const struct ide_port_ops *port_ops = hwif->port_ops;
 
 	if (hwif->host_flags & IDE_HFLAG_NO_SET_MODE)
 		return 0;
 
-	if (hwif->set_pio_mode == NULL)
+	if (port_ops == NULL || port_ops->set_pio_mode == NULL)
 		return -1;
 
 	/*
 	 * TODO: temporary hack for some legacy host drivers that didn't
 	 * set transfer mode on the device in ->set_pio_mode method...
 	 */
-	if (hwif->set_dma_mode == NULL) {
-		hwif->set_pio_mode(drive, mode - XFER_PIO_0);
+	if (port_ops->set_dma_mode == NULL) {
+		port_ops->set_pio_mode(drive, mode - XFER_PIO_0);
 		return 0;
 	}
 
 	if (hwif->host_flags & IDE_HFLAG_POST_SET_MODE) {
 		if (ide_config_drive_speed(drive, mode))
 			return -1;
-		hwif->set_pio_mode(drive, mode - XFER_PIO_0);
+		port_ops->set_pio_mode(drive, mode - XFER_PIO_0);
 		return 0;
 	} else {
-		hwif->set_pio_mode(drive, mode - XFER_PIO_0);
+		port_ops->set_pio_mode(drive, mode - XFER_PIO_0);
 		return ide_config_drive_speed(drive, mode);
 	}
 }
@@ -373,20 +375,21 @@ int ide_set_pio_mode(ide_drive_t *drive, const u8 mode)
 int ide_set_dma_mode(ide_drive_t *drive, const u8 mode)
 {
 	ide_hwif_t *hwif = drive->hwif;
+	const struct ide_port_ops *port_ops = hwif->port_ops;
 
 	if (hwif->host_flags & IDE_HFLAG_NO_SET_MODE)
 		return 0;
 
-	if (hwif->set_dma_mode == NULL)
+	if (port_ops == NULL || port_ops->set_dma_mode == NULL)
 		return -1;
 
 	if (hwif->host_flags & IDE_HFLAG_POST_SET_MODE) {
 		if (ide_config_drive_speed(drive, mode))
 			return -1;
-		hwif->set_dma_mode(drive, mode);
+		port_ops->set_dma_mode(drive, mode);
 		return 0;
 	} else {
-		hwif->set_dma_mode(drive, mode);
+		port_ops->set_dma_mode(drive, mode);
 		return ide_config_drive_speed(drive, mode);
 	}
 }
@@ -406,8 +409,9 @@ EXPORT_SYMBOL_GPL(ide_set_dma_mode);
 int ide_set_xfer_rate(ide_drive_t *drive, u8 rate)
 {
 	ide_hwif_t *hwif = drive->hwif;
+	const struct ide_port_ops *port_ops = hwif->port_ops;
 
-	if (hwif->set_dma_mode == NULL ||
+	if (port_ops == NULL || port_ops->set_dma_mode == NULL ||
 	    (hwif->host_flags & IDE_HFLAG_NO_SET_MODE))
 		return -1;
 

commit 784506cbddd17bcd5929f827df39b0c7014e3f1e
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 17:36:43 2008 +0200

    ide: sanitize handling of IDE_HFLAG_NO_SET_MODE host flag
    
    * Check for IDE_HFLAG_NO_SET_MODE host flag in ide_set_pio(),
      ide_set_[pio,dma]_mode(), ide_set_xfer_rate() and set_pio_mode().
    
    * Remove no longer needed IDE_HFLAG_NO_SET_MODE host flag checking
      from ide_tune_dma().
    
    * Remove superfluous ->set_pio_mode checking from do_special().
    
    This is a part of preparations for adding 'struct ide_port_ops'.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index fa4c194b5ede..c859de77aa8f 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -290,7 +290,8 @@ void ide_set_pio(ide_drive_t *drive, u8 req_pio)
 	ide_hwif_t *hwif = drive->hwif;
 	u8 host_pio, pio;
 
-	if (hwif->set_pio_mode == NULL)
+	if (hwif->set_pio_mode == NULL ||
+	    (hwif->host_flags & IDE_HFLAG_NO_SET_MODE))
 		return;
 
 	BUG_ON(hwif->pio_mask == 0x00);
@@ -343,6 +344,9 @@ int ide_set_pio_mode(ide_drive_t *drive, const u8 mode)
 {
 	ide_hwif_t *hwif = drive->hwif;
 
+	if (hwif->host_flags & IDE_HFLAG_NO_SET_MODE)
+		return 0;
+
 	if (hwif->set_pio_mode == NULL)
 		return -1;
 
@@ -370,6 +374,9 @@ int ide_set_dma_mode(ide_drive_t *drive, const u8 mode)
 {
 	ide_hwif_t *hwif = drive->hwif;
 
+	if (hwif->host_flags & IDE_HFLAG_NO_SET_MODE)
+		return 0;
+
 	if (hwif->set_dma_mode == NULL)
 		return -1;
 
@@ -400,7 +407,8 @@ int ide_set_xfer_rate(ide_drive_t *drive, u8 rate)
 {
 	ide_hwif_t *hwif = drive->hwif;
 
-	if (hwif->set_dma_mode == NULL)
+	if (hwif->set_dma_mode == NULL ||
+	    (hwif->host_flags & IDE_HFLAG_NO_SET_MODE))
 		return -1;
 
 	rate = ide_rate_filter(drive, rate);

commit 078fdf789c4ef13dcb7b5651ff330e325d764c0e
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 17:36:36 2008 +0200

    ide: remove PIO "downgrade" quirk
    
    No need for it nowadays so remove quirk code from ide_get_best_pio_mode()
    and IDE_HFLAG_PIO_DOWNGRADE host flag.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 7031a8dcf692..fa4c194b5ede 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -274,16 +274,6 @@ u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode)
 		if (overridden)
 			printk(KERN_INFO "%s: tPIO > 2, assuming tPIO = 2\n",
 					 drive->name);
-
-		/*
-		 * Conservative "downgrade" for all pre-ATA2 drives
-		 */
-		if ((drive->hwif->host_flags & IDE_HFLAG_PIO_NO_DOWNGRADE) == 0 &&
-		    pio_mode && pio_mode < 4) {
-			pio_mode--;
-			printk(KERN_INFO "%s: applying conservative "
-					 "PIO \"downgrade\"\n", drive->name);
-		}
 	}
 
 	if (pio_mode > max_mode)

commit 37ff9f3953dfa7262be091e431cd0eb368c38080
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Mar 22 16:40:20 2008 +0100

    ide: remove commented out entries from ide_pio_blacklist[]
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 29e2c9719c30..7031a8dcf692 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -122,7 +122,6 @@ static struct ide_pio_info {
 	const char	*name;
 	int		pio;
 } ide_pio_blacklist [] = {
-/*	{ "Conner Peripherals 1275MB - CFS1275A", 4 }, */
 	{ "Conner Peripherals 540MB - CFS540A", 3 },
 
 	{ "WDC AC2700",  3 },
@@ -138,10 +137,8 @@ static struct ide_pio_info {
 	{ "WDC AC1170",  1 },
 	{ "WDC AC1210",  1 },
 	{ "WDC AC280",   0 },
-/*	{ "WDC AC21000", 4 }, */
 	{ "WDC AC31000", 3 },
 	{ "WDC AC31200", 3 },
-/*	{ "WDC AC31600", 4 }, */
 
 	{ "Maxtor 7131 AT", 1 },
 	{ "Maxtor 7171 AT", 1 },
@@ -155,13 +152,6 @@ static struct ide_pio_info {
 	{ "SAMSUNG SHD-3122A", 1 },
 	{ "SAMSUNG SHD-3172A", 1 },
 
-/*	{ "ST51080A", 4 },
- *	{ "ST51270A", 4 },
- *	{ "ST31220A", 4 },
- *	{ "ST31640A", 4 },
- *	{ "ST32140A", 4 },
- *	{ "ST3780A",  4 },
- */
 	{ "ST5660A",  3 },
 	{ "ST3660A",  3 },
 	{ "ST3630A",  3 },

commit 467390a2a50493332ddc21eb806094b1829c1161
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Feb 11 00:32:15 2008 +0100

    ide: remove stale comment from ide-lib.c
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 1ff676cc6473..29e2c9719c30 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -21,15 +21,6 @@
 #include <asm/uaccess.h>
 #include <asm/io.h>
 
-/*
- *	IDE library routines. These are plug in code that most 
- *	drivers can use but occasionally may be weird enough
- *	to want to do their own thing with
- *
- *	Add common non I/O op stuff here. Make sure it has proper
- *	kernel-doc function headers or your patch will be rejected
- */
-
 static const char *udma_str[] =
 	 { "UDMA/16", "UDMA/25",  "UDMA/33",  "UDMA/44",
 	   "UDMA/66", "UDMA/100", "UDMA/133", "UDMA7" };

commit 64a57fe4393bae920d03c253173f59d8a7ec8e25
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Feb 6 02:57:51 2008 +0100

    ide: add ide_read_error() inline helper
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index b42940d8bf70..1ff676cc6473 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -578,7 +578,7 @@ u8 ide_dump_status(ide_drive_t *drive, const char *msg, u8 stat)
 	}
 	printk("}\n");
 	if ((stat & (BUSY_STAT|ERR_STAT)) == ERR_STAT) {
-		err = drive->hwif->INB(IDE_ERROR_REG);
+		err = ide_read_error(drive);
 		printk("%s: %s: error=0x%02x ", drive->name, msg, err);
 		if (drive->media == ide_disk)
 			ide_dump_ata_error(drive, err);

commit 36501650ec45b1db308c3b51886044863be2d762
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Feb 1 23:09:31 2008 +0100

    ide: keep pointer to struct device instead of struct pci_dev in ide_hwif_t
    
    Keep pointer to struct device instead of struct pci_dev in ide_hwif_t.
    
    While on it:
    * Use *dev->dma_mask instead of pci_dev->dma_mask in ide_toggle_bounce().
    
    There should be no functionality changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 9b44fbdfe41f..b42940d8bf70 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -358,8 +358,10 @@ void ide_toggle_bounce(ide_drive_t *drive, int on)
 	if (!PCI_DMA_BUS_IS_PHYS) {
 		addr = BLK_BOUNCE_ANY;
 	} else if (on && drive->media == ide_disk) {
-		if (HWIF(drive)->pci_dev)
-			addr = HWIF(drive)->pci_dev->dma_mask;
+		struct device *dev = drive->hwif->dev;
+
+		if (dev && dev->dma_mask)
+			addr = *dev->dma_mask;
 	}
 
 	if (drive->queue)

commit 7267c3377443322588cddaf457cf106839a60463
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Jan 26 20:13:13 2008 +0100

    ide: remove REQ_TYPE_ATA_CMD
    
    Based on the earlier work by Tejun Heo.
    
    All users are gone so we can finally remove it.
    
    Cc: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index a3bd8e8ed6b0..9b44fbdfe41f 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -454,8 +454,7 @@ int ide_set_xfer_rate(ide_drive_t *drive, u8 rate)
 static void ide_dump_opcode(ide_drive_t *drive)
 {
 	struct request *rq;
-	u8 opcode = 0;
-	int found = 0;
+	ide_task_t *task = NULL;
 
 	spin_lock(&ide_lock);
 	rq = NULL;
@@ -464,25 +463,15 @@ static void ide_dump_opcode(ide_drive_t *drive)
 	spin_unlock(&ide_lock);
 	if (!rq)
 		return;
-	if (rq->cmd_type == REQ_TYPE_ATA_CMD) {
-		char *args = rq->buffer;
-		if (args) {
-			opcode = args[0];
-			found = 1;
-		}
-	} else if (rq->cmd_type == REQ_TYPE_ATA_TASKFILE) {
-		ide_task_t *args = rq->special;
-		if (args) {
-			opcode = args->tf.command;
-			found = 1;
-		}
-	}
+
+	if (rq->cmd_type == REQ_TYPE_ATA_TASKFILE)
+		task = rq->special;
 
 	printk("ide: failed opcode was: ");
-	if (!found)
-		printk("unknown\n");
+	if (task == NULL)
+		printk(KERN_CONT "unknown\n");
 	else
-		printk("0x%02x\n", opcode);
+		printk(KERN_CONT "0x%02x\n", task->tf.command);
 }
 
 u64 ide_get_lba_addr(struct ide_taskfile *tf, int lba48)

commit 4db90a145292327b95b03f6dcd3352327235cc36
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jan 25 22:17:18 2008 +0100

    ide: add IDE_HFLAG_ABUSE_SET_DMA_MODE host flag
    
    * Add IDE_HFLAG_ABUSE_SET_DMA_MODE host flag and use it to decide
      what to do with transfer modes < XFER_PIO_0 in ide_set_xfer_rate().
    
    * Set IDE_HFLAG_ABUSE_SET_DMA_MODE in host drivers that need it
      (aec62xx, amd74xx, cs5520, cs5535, hpt34x, hpt366, pdc202xx_old,
      serverworks, tc86c001 and via82cxxx) and cleanup ->set_dma_mode
      methods in host drivers that don't (IDE core code guarantees that
      ->set_dma_mode will be called only for modes which are present
      in SWDMA/MWDMA/UDMA masks).
    
    While at it:
    
    * Add IDE_HFLAGS_HPT34X/HPT3XX/PDC202XX/SVWKS define in
      hpt34x/hpt366/pdc202xx_old/serverworks host driver.
    
    There should be no functionality changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 8649db33f67d..a3bd8e8ed6b0 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -441,6 +441,12 @@ int ide_set_xfer_rate(ide_drive_t *drive, u8 rate)
 	 * case could happen iff the transfer mode has already been set on
 	 * the device by ide-proc.c::set_xfer_rate()).
 	 */
+	if (rate < XFER_PIO_0) {
+		if (hwif->host_flags & IDE_HFLAG_ABUSE_SET_DMA_MODE)
+			return ide_set_dma_mode(drive, rate);
+		else
+			return ide_config_drive_speed(drive, rate);
+	}
 
 	return ide_set_dma_mode(drive, rate);
 }

commit e62925dd26ef9594b8e4b9380b3211f6dae4ab96
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jan 25 22:17:17 2008 +0100

    ide: kill duplicate code in ide_dump_{ata,atapi}_status()
    
    * Move the common code from ide_dump_{ata,atapi}_status() to
      ide_dump_status().
    
    * ide_dump_{ata,atapi}_status() -> ide_dump_{ata,atapi}_error().
    
    There should be no functionality changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 6b2e810cb9e0..8649db33f67d 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -517,61 +517,51 @@ static void ide_dump_sector(ide_drive_t *drive)
 					 tf->device & 0xf, tf->lbal);
 }
 
-static u8 ide_dump_ata_status(ide_drive_t *drive, const char *msg, u8 stat)
+static void ide_dump_ata_error(ide_drive_t *drive, u8 err)
 {
-	ide_hwif_t *hwif = HWIF(drive);
-	unsigned long flags;
-	u8 err = 0;
-
-	local_irq_save(flags);
-	printk("%s: %s: status=0x%02x { ", drive->name, msg, stat);
-	if (stat & BUSY_STAT)
-		printk("Busy ");
-	else {
-		if (stat & READY_STAT)	printk("DriveReady ");
-		if (stat & WRERR_STAT)	printk("DeviceFault ");
-		if (stat & SEEK_STAT)	printk("SeekComplete ");
-		if (stat & DRQ_STAT)	printk("DataRequest ");
-		if (stat & ECC_STAT)	printk("CorrectedError ");
-		if (stat & INDEX_STAT)	printk("Index ");
-		if (stat & ERR_STAT)	printk("Error ");
+	printk("{ ");
+	if (err & ABRT_ERR)	printk("DriveStatusError ");
+	if (err & ICRC_ERR)
+		printk((err & ABRT_ERR) ? "BadCRC " : "BadSector ");
+	if (err & ECC_ERR)	printk("UncorrectableError ");
+	if (err & ID_ERR)	printk("SectorIdNotFound ");
+	if (err & TRK0_ERR)	printk("TrackZeroNotFound ");
+	if (err & MARK_ERR)	printk("AddrMarkNotFound ");
+	printk("}");
+	if ((err & (BBD_ERR | ABRT_ERR)) == BBD_ERR ||
+	    (err & (ECC_ERR|ID_ERR|MARK_ERR))) {
+		ide_dump_sector(drive);
+		if (HWGROUP(drive) && HWGROUP(drive)->rq)
+			printk(", sector=%llu",
+			       (unsigned long long)HWGROUP(drive)->rq->sector);
 	}
+	printk("\n");
+}
+
+static void ide_dump_atapi_error(ide_drive_t *drive, u8 err)
+{
+	printk("{ ");
+	if (err & ILI_ERR)	printk("IllegalLengthIndication ");
+	if (err & EOM_ERR)	printk("EndOfMedia ");
+	if (err & ABRT_ERR)	printk("AbortedCommand ");
+	if (err & MCR_ERR)	printk("MediaChangeRequested ");
+	if (err & LFS_ERR)	printk("LastFailedSense=0x%02x ",
+				       (err & LFS_ERR) >> 4);
 	printk("}\n");
-	if ((stat & (BUSY_STAT|ERR_STAT)) == ERR_STAT) {
-		err = hwif->INB(IDE_ERROR_REG);
-		printk("%s: %s: error=0x%02x { ", drive->name, msg, err);
-		if (err & ABRT_ERR)	printk("DriveStatusError ");
-		if (err & ICRC_ERR)
-			printk((err & ABRT_ERR) ? "BadCRC " : "BadSector ");
-		if (err & ECC_ERR)	printk("UncorrectableError ");
-		if (err & ID_ERR)	printk("SectorIdNotFound ");
-		if (err & TRK0_ERR)	printk("TrackZeroNotFound ");
-		if (err & MARK_ERR)	printk("AddrMarkNotFound ");
-		printk("}");
-		if ((err & (BBD_ERR | ABRT_ERR)) == BBD_ERR ||
-		    (err & (ECC_ERR|ID_ERR|MARK_ERR))) {
-			ide_dump_sector(drive);
-			if (HWGROUP(drive) && HWGROUP(drive)->rq)
-				printk(", sector=%llu",
-					(unsigned long long)HWGROUP(drive)->rq->sector);
-		}
-		printk("\n");
-	}
-	ide_dump_opcode(drive);
-	local_irq_restore(flags);
-	return err;
 }
 
 /**
- *	ide_dump_atapi_status       -       print human readable atapi status
+ *	ide_dump_status		-	translate ATA/ATAPI error
  *	@drive: drive that status applies to
  *	@msg: text message to print
  *	@stat: status byte to decode
  *
  *	Error reporting, in human readable form (luxurious, but a memory hog).
+ *	Combines the drive name, message and status byte to provide a
+ *	user understandable explanation of the device error.
  */
 
-static u8 ide_dump_atapi_status(ide_drive_t *drive, const char *msg, u8 stat)
+u8 ide_dump_status(ide_drive_t *drive, const char *msg, u8 stat)
 {
 	unsigned long flags;
 	u8 err = 0;
@@ -592,36 +582,15 @@ static u8 ide_dump_atapi_status(ide_drive_t *drive, const char *msg, u8 stat)
 	printk("}\n");
 	if ((stat & (BUSY_STAT|ERR_STAT)) == ERR_STAT) {
 		err = drive->hwif->INB(IDE_ERROR_REG);
-		printk("%s: %s: error=0x%02x { ", drive->name, msg, err);
-		if (err & ILI_ERR)	printk("IllegalLengthIndication ");
-		if (err & EOM_ERR)	printk("EndOfMedia ");
-		if (err & ABRT_ERR)	printk("AbortedCommand ");
-		if (err & MCR_ERR)	printk("MediaChangeRequested ");
-		if (err & LFS_ERR)	printk("LastFailedSense=0x%02x ",
-						(err & LFS_ERR) >> 4);
-		printk("}\n");
+		printk("%s: %s: error=0x%02x ", drive->name, msg, err);
+		if (drive->media == ide_disk)
+			ide_dump_ata_error(drive, err);
+		else
+			ide_dump_atapi_error(drive, err);
 	}
 	ide_dump_opcode(drive);
 	local_irq_restore(flags);
 	return err;
 }
 
-/**
- *	ide_dump_status		-	translate ATA/ATAPI error
- *	@drive: drive the error occured on
- *	@msg: information string
- *	@stat: status byte
- *
- *	Error reporting, in human readable form (luxurious, but a memory hog).
- *	Combines the drive name, message and status byte to provide a
- *	user understandable explanation of the device error.
- */
-
-u8 ide_dump_status(ide_drive_t *drive, const char *msg, u8 stat)
-{
-	if (drive->media == ide_disk)
-		return ide_dump_ata_status(drive, msg, stat);
-	return ide_dump_atapi_status(drive, msg, stat);
-}
-
 EXPORT_SYMBOL(ide_dump_status);

commit a501633c7d44087e806597d3a213d735346edd51
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jan 25 22:17:17 2008 +0100

    ide-disk: use ide_get_lba_addr()
    
    * Export ide_get_lba_addr().
    
    * Convert idedisk_{read_native,set}_max_address() to use ide_get_lba_addr().
    
    * Remove incorrect comment from idedisk_read_native_max_address()
      (noticed by Sergei).
    
    There should be no functionality changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index d7503c489e99..6b2e810cb9e0 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -479,7 +479,7 @@ static void ide_dump_opcode(ide_drive_t *drive)
 		printk("0x%02x\n", opcode);
 }
 
-static u64 ide_get_lba_addr(struct ide_taskfile *tf, int lba48)
+u64 ide_get_lba_addr(struct ide_taskfile *tf, int lba48)
 {
 	u32 high, low;
 
@@ -492,6 +492,7 @@ static u64 ide_get_lba_addr(struct ide_taskfile *tf, int lba48)
 
 	return ((u64)high << 24) | low;
 }
+EXPORT_SYMBOL_GPL(ide_get_lba_addr);
 
 static void ide_dump_sector(ide_drive_t *drive)
 {

commit 1c904fcfbb0d8eef92ef42b1da378b4714143e46
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Fri Jan 25 22:17:17 2008 +0100

    ide: printk fix
    
    power4:
    
    drivers/ide/ide-lib.c: In function `ide_dump_sector':
    drivers/ide/ide-lib.c:516: warning: long long unsigned int format, u64 arg (arg 2)
    
    We don't know what type is used to implement u64 hence it must always be cast
    when printed.
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 15736d4ce9b4..d7503c489e99 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -509,7 +509,8 @@ static void ide_dump_sector(ide_drive_t *drive)
 	ide_tf_read(drive, &task);
 
 	if (lba48 || (tf->device & ATA_LBA))
-		printk(", LBAsect=%llu", ide_get_lba_addr(tf, lba48));
+		printk(", LBAsect=%llu",
+			(unsigned long long)ide_get_lba_addr(tf, lba48));
 	else
 		printk(", CHS=%d/%d/%d", (tf->lbah << 8) + tf->lbam,
 					 tf->device & 0xf, tf->lbal);

commit c2b57cdc1d2976444d451a2a2e43e11b61ed0638
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jan 25 22:17:17 2008 +0100

    ide: add ide_tf_read() helper
    
    * Factor out code reading taskfile registers from ide_end_drive_cmd()
      to the new ide_tf_read() helper.
    
    * Add IDE_TFLAG_IN_* taskfile flags to indicate the need to load
      particular IDE taskfile register in ide_tf_read().
    
    * Update ide_end_drive_cmd() to set respective IDE_TFLAG_IN_* taksfile flags.
    
    * Add ide_get_lba_addr() for getting LBA sector address from taskfile struct.
    
    * Factor out code getting sector address from ide_dump_ata_status()
      to the new ide_dump_sector() function.
    
    * Convert ide_dump_sector() to use ide_tf_read() and ide_get_lba_addr().
    
    * Remove no longer needed ide_read_24().
    
    The only change in functionality caused by this patch is that
    ide_dump_ata_status() no longer prints "high"/"low" parts of LBA48
    sector address (of course LBA48 sector address is still printed).
    
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 001085845a79..15736d4ce9b4 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -479,6 +479,42 @@ static void ide_dump_opcode(ide_drive_t *drive)
 		printk("0x%02x\n", opcode);
 }
 
+static u64 ide_get_lba_addr(struct ide_taskfile *tf, int lba48)
+{
+	u32 high, low;
+
+	if (lba48)
+		high = (tf->hob_lbah << 16) | (tf->hob_lbam << 8) |
+			tf->hob_lbal;
+	else
+		high = tf->device & 0xf;
+	low  = (tf->lbah << 16) | (tf->lbam << 8) | tf->lbal;
+
+	return ((u64)high << 24) | low;
+}
+
+static void ide_dump_sector(ide_drive_t *drive)
+{
+	ide_task_t task;
+	struct ide_taskfile *tf = &task.tf;
+	int lba48 = (drive->addressing == 1) ? 1 : 0;
+
+	memset(&task, 0, sizeof(task));
+	if (lba48)
+		task.tf_flags = IDE_TFLAG_IN_LBA | IDE_TFLAG_IN_HOB_LBA |
+				IDE_TFLAG_LBA48;
+	else
+		task.tf_flags = IDE_TFLAG_IN_LBA | IDE_TFLAG_IN_DEVICE;
+
+	ide_tf_read(drive, &task);
+
+	if (lba48 || (tf->device & ATA_LBA))
+		printk(", LBAsect=%llu", ide_get_lba_addr(tf, lba48));
+	else
+		printk(", CHS=%d/%d/%d", (tf->lbah << 8) + tf->lbam,
+					 tf->device & 0xf, tf->lbal);
+}
+
 static u8 ide_dump_ata_status(ide_drive_t *drive, const char *msg, u8 stat)
 {
 	ide_hwif_t *hwif = HWIF(drive);
@@ -512,38 +548,7 @@ static u8 ide_dump_ata_status(ide_drive_t *drive, const char *msg, u8 stat)
 		printk("}");
 		if ((err & (BBD_ERR | ABRT_ERR)) == BBD_ERR ||
 		    (err & (ECC_ERR|ID_ERR|MARK_ERR))) {
-			if (drive->addressing == 1) {
-				__u64 sectors = 0;
-				u32 low = 0, high = 0;
-				hwif->OUTB(drive->ctl&~0x80, IDE_CONTROL_REG);
-				low = ide_read_24(drive);
-				hwif->OUTB(drive->ctl|0x80, IDE_CONTROL_REG);
-				high = ide_read_24(drive);
-				sectors = ((__u64)high << 24) | low;
-				printk(", LBAsect=%llu, high=%d, low=%d",
-				       (unsigned long long) sectors,
-				       high, low);
-			} else {
-				u8 sector, lcyl, hcyl, cur;
-
-				sector = hwif->INB(IDE_SECTOR_REG);
-				lcyl   = hwif->INB(IDE_LCYL_REG);
-				hcyl   = hwif->INB(IDE_HCYL_REG);
-				cur    = hwif->INB(IDE_SELECT_REG);
-
-				if (cur & 0x40) {	/* using LBA? */
-					printk(", LBAsect=%ld", (unsigned long)
-						((cur & 0xf) << 24) |
-						(hcyl << 16) |
-						(lcyl <<  8) |
-						sector);
-				} else {
-					printk(", CHS=%d/%d/%d",
-						(hcyl << 8) + lcyl,
-						cur & 0xf,
-						sector);
-				}
-			}
+			ide_dump_sector(drive);
 			if (HWGROUP(drive) && HWGROUP(drive)->rq)
 				printk(", sector=%llu",
 					(unsigned long long)HWGROUP(drive)->rq->sector);

commit d32444771b154c3ec37ebf6439004653560c2411
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jan 25 22:17:17 2008 +0100

    ide: fix registers loading order in ide_dump_ata_status()
    
    Fix registers loading order in ide_dump_ata_status()/ide_read_24().
    
    Load registers in this order:
    * IDE_SECTOR_REG
    * IDE_LCYL_REG
    * IDE_HCYL_REG
    * IDE_SELECT_REG
    
    It shouldn't affect anything (just a usual paranoia to separate changes
    which change the way in which hardware is accessed from code cleanups).
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 562f5efae9c6..001085845a79 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -524,19 +524,24 @@ static u8 ide_dump_ata_status(ide_drive_t *drive, const char *msg, u8 stat)
 				       (unsigned long long) sectors,
 				       high, low);
 			} else {
-				u8 cur = hwif->INB(IDE_SELECT_REG);
+				u8 sector, lcyl, hcyl, cur;
+
+				sector = hwif->INB(IDE_SECTOR_REG);
+				lcyl   = hwif->INB(IDE_LCYL_REG);
+				hcyl   = hwif->INB(IDE_HCYL_REG);
+				cur    = hwif->INB(IDE_SELECT_REG);
+
 				if (cur & 0x40) {	/* using LBA? */
 					printk(", LBAsect=%ld", (unsigned long)
-					 ((cur&0xf)<<24)
-					 |(hwif->INB(IDE_HCYL_REG)<<16)
-					 |(hwif->INB(IDE_LCYL_REG)<<8)
-					 | hwif->INB(IDE_SECTOR_REG));
+						((cur & 0xf) << 24) |
+						(hcyl << 16) |
+						(lcyl <<  8) |
+						sector);
 				} else {
 					printk(", CHS=%d/%d/%d",
-					 (hwif->INB(IDE_HCYL_REG)<<8) +
-					  hwif->INB(IDE_LCYL_REG),
-					  cur & 0xf,
-					  hwif->INB(IDE_SECTOR_REG));
+						(hcyl << 8) + lcyl,
+						cur & 0xf,
+						sector);
 				}
 			}
 			if (HWGROUP(drive) && HWGROUP(drive)->rq)

commit 0e38a66a1e69821ab57a06d5a7b11f0df9275bf4
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jan 25 22:17:12 2008 +0100

    ide: remove atapi_error_t (take 2)
    
    Remove atapi_error_t.
    
    While at it:
    * replace 'HWIF(drive)' by 'drive->hwif'
    
    v2:
    * Add {ILI,EOM,LFS}_ERR defines to <linux/hdreg.h>.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index dc7e539b4d0b..562f5efae9c6 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -562,9 +562,8 @@ static u8 ide_dump_ata_status(ide_drive_t *drive, const char *msg, u8 stat)
 static u8 ide_dump_atapi_status(ide_drive_t *drive, const char *msg, u8 stat)
 {
 	unsigned long flags;
-	atapi_error_t error;
+	u8 err = 0;
 
-	error.all = 0;
 	local_irq_save(flags);
 	printk("%s: %s: status=0x%02x { ", drive->name, msg, stat);
 	if (stat & BUSY_STAT)
@@ -580,19 +579,19 @@ static u8 ide_dump_atapi_status(ide_drive_t *drive, const char *msg, u8 stat)
 	}
 	printk("}\n");
 	if ((stat & (BUSY_STAT|ERR_STAT)) == ERR_STAT) {
-		error.all = HWIF(drive)->INB(IDE_ERROR_REG);
-		printk("%s: %s: error=0x%02x { ", drive->name, msg, error.all);
-		if (error.b.ili)	printk("IllegalLengthIndication ");
-		if (error.b.eom)	printk("EndOfMedia ");
-		if (error.b.abrt)	printk("AbortedCommand ");
-		if (error.b.mcr)	printk("MediaChangeRequested ");
-		if (error.b.sense_key)	printk("LastFailedSense=0x%02x ",
-						error.b.sense_key);
+		err = drive->hwif->INB(IDE_ERROR_REG);
+		printk("%s: %s: error=0x%02x { ", drive->name, msg, err);
+		if (err & ILI_ERR)	printk("IllegalLengthIndication ");
+		if (err & EOM_ERR)	printk("EndOfMedia ");
+		if (err & ABRT_ERR)	printk("AbortedCommand ");
+		if (err & MCR_ERR)	printk("MediaChangeRequested ");
+		if (err & LFS_ERR)	printk("LastFailedSense=0x%02x ",
+						(err & LFS_ERR) >> 4);
 		printk("}\n");
 	}
 	ide_dump_opcode(drive);
 	local_irq_restore(flags);
-	return error.all;
+	return err;
 }
 
 /**

commit 22c525b976778cce5bb6f8fdcc70046168c54b1a
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jan 25 22:17:11 2008 +0100

    ide: remove ata_status_t and atapi_status_t
    
    Remove ata_status_t (unused) and atapi_status_t.
    
    While at it:
    * replace 'HWIF(drive)' by 'drive->hwif' (or just 'hwif' where possible)
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 3bae2c46924f..dc7e539b4d0b 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -562,27 +562,24 @@ static u8 ide_dump_ata_status(ide_drive_t *drive, const char *msg, u8 stat)
 static u8 ide_dump_atapi_status(ide_drive_t *drive, const char *msg, u8 stat)
 {
 	unsigned long flags;
-
-	atapi_status_t status;
 	atapi_error_t error;
 
-	status.all = stat;
 	error.all = 0;
 	local_irq_save(flags);
 	printk("%s: %s: status=0x%02x { ", drive->name, msg, stat);
-	if (status.b.bsy)
+	if (stat & BUSY_STAT)
 		printk("Busy ");
 	else {
-		if (status.b.drdy)	printk("DriveReady ");
-		if (status.b.df)	printk("DeviceFault ");
-		if (status.b.dsc)	printk("SeekComplete ");
-		if (status.b.drq)	printk("DataRequest ");
-		if (status.b.corr)	printk("CorrectedError ");
-		if (status.b.idx)	printk("Index ");
-		if (status.b.check)	printk("Error ");
+		if (stat & READY_STAT)	printk("DriveReady ");
+		if (stat & WRERR_STAT)	printk("DeviceFault ");
+		if (stat & SEEK_STAT)	printk("SeekComplete ");
+		if (stat & DRQ_STAT)	printk("DataRequest ");
+		if (stat & ECC_STAT)	printk("CorrectedError ");
+		if (stat & INDEX_STAT)	printk("Index ");
+		if (stat & ERR_STAT)	printk("Error ");
 	}
 	printk("}\n");
-	if (status.b.check && !status.b.bsy) {
+	if ((stat & (BUSY_STAT|ERR_STAT)) == ERR_STAT) {
 		error.all = HWIF(drive)->INB(IDE_ERROR_REG);
 		printk("%s: %s: error=0x%02x { ", drive->name, msg, error.all);
 		if (error.b.ili)	printk("IllegalLengthIndication ");

commit 29ed2a5f8c4380959f18e9cbaff13bc61e09889c
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jan 25 22:17:11 2008 +0100

    ide: remove REQ_TYPE_ATA_TASK
    
    Based on the earlier work by Tejun Heo.
    
    All users are gone so we can finally remove it.
    
    Cc: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 6dbf2af0d215..3bae2c46924f 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -458,8 +458,7 @@ static void ide_dump_opcode(ide_drive_t *drive)
 	spin_unlock(&ide_lock);
 	if (!rq)
 		return;
-	if (rq->cmd_type == REQ_TYPE_ATA_CMD ||
-	    rq->cmd_type == REQ_TYPE_ATA_TASK) {
+	if (rq->cmd_type == REQ_TYPE_ATA_CMD) {
 		char *args = rq->buffer;
 		if (args) {
 			opcode = args[0];

commit 650d841d9e053a618dd8ce753422f91b493cf2f6
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jan 25 22:17:06 2008 +0100

    ide: add struct ide_taskfile (take 2)
    
    * Don't set write-only ide_task_t.hobRegister[6] and ide_task_t.hobRegister[7]
      in idedisk_set_max_address_ext().
    
    * Add struct ide_taskfile and use it in ide_task_t instead of tfRegister[]
      and hobRegister[].
    
    * Remove no longer needed IDE_CONTROL_OFFSET_HOB define.
    
    * Add #ifndef/#endif __KERNEL__ around definitions of {task,hob}_struct_t.
    
    While at it:
    
    * Use ATA_LBA define for LBA bit (0x40) as suggested by Tejun Heo.
    
    v2:
    * Add missing newlines. (Noticed by Sergei)
    
    * Use ~ATA_LBA instead of 0xBF. (Noticed by Sergei)
    
    * Use unnamed unions for error/feature and status/command.
      (Suggested by Sergei).
    
    There should be no functionality changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 062d3bcb2471..6dbf2af0d215 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -468,8 +468,7 @@ static void ide_dump_opcode(ide_drive_t *drive)
 	} else if (rq->cmd_type == REQ_TYPE_ATA_TASKFILE) {
 		ide_task_t *args = rq->special;
 		if (args) {
-			task_struct_t *tf = (task_struct_t *) args->tfRegister;
-			opcode = tf->command;
+			opcode = args->tf.command;
 			found = 1;
 		}
 	}

commit 3ab7efe8e2cbcca2d401b43cfcc2fa9a7dac2299
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Dec 12 23:31:58 2007 +0100

    ide: DMA reporting and validity checking fixes (take 3)
    
    * ide_xfer_verbose() fixups:
      - beautify returned mode names
      - fix PIO5 reporting
      - make it return 'const char *'
    
    * Change printk() level from KERN_DEBUG to KERN_INFO in ide_find_dma_mode().
    
    * Add ide_id_dma_bug() helper based on ide_dma_verbose() to check for invalid
      DMA info in identify block.
    
    * Use ide_id_dma_bug() in ide_tune_dma() and ide_driveid_update().
    
      As a result DMA won't be tuned or will be disabled after tuning if device
      reports inconsistent info about enabled DMA mode (ide_dma_verbose() does the
      same checks while the IDE device is probed by ide-{cd,disk} device driver).
    
    * Remove no longer needed ide_dma_verbose().
    
    This patch should fix the following problem with out-of-sync IDE messages
    reported by Nick Warne:
    
           hdd: ATAPI 48X DVD-ROM DVD-R-RAM CD-R/RW drive, 2048kB Cache<7>hdd:
           skipping word 93 validity check
            , UDMA(66)
    
    and later debugged by Mark Lord to be caused by:
    
            ide_dma_verbose()
                    printk( ... "2048kB Cache");
            eighty_ninty_three()
                    printk(KERN_DEBUG "%s: skipping word 93 validity check\n");
            ide_dma_verbose()
                    printk(", UDMA(66)"
    
    Please note that as a result ide-{cd,disk} device drivers won't report the
    DMA speed used but this is intended since now DMA mode being used is always
    reported by IDE core code.
    
    v2:
    * fixes suggested by Randy:
      - use KERN_CONT for printk()-s in ide-{cd,disk}.c
      - don't remove argument name from ide_xfer_verbose() declaration
    
    v3:
    * Remove incorrect check for (id->field_valid & 1) from ide_id_dma_bug()
      (spotted by Sergei).
    
    * "XFER SLOW" -> "PIO SLOW" in ide_xfer_verbose() (suggested by Sergei).
    
    * Fix ide_find_dma_mode() to report the correct mode ('mode' after being
      limited by 'req_mode').
    
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: Nick Warne <nick@ukfsn.org>
    Cc: Mark Lord <lkml@rtr.ca>
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 1609b8604f56..062d3bcb2471 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -29,41 +29,44 @@
  *	Add common non I/O op stuff here. Make sure it has proper
  *	kernel-doc function headers or your patch will be rejected
  */
- 
+
+static const char *udma_str[] =
+	 { "UDMA/16", "UDMA/25",  "UDMA/33",  "UDMA/44",
+	   "UDMA/66", "UDMA/100", "UDMA/133", "UDMA7" };
+static const char *mwdma_str[] =
+	{ "MWDMA0", "MWDMA1", "MWDMA2" };
+static const char *swdma_str[] =
+	{ "SWDMA0", "SWDMA1", "SWDMA2" };
+static const char *pio_str[] =
+	{ "PIO0", "PIO1", "PIO2", "PIO3", "PIO4", "PIO5" };
 
 /**
  *	ide_xfer_verbose	-	return IDE mode names
- *	@xfer_rate: rate to name
+ *	@mode: transfer mode
  *
  *	Returns a constant string giving the name of the mode
  *	requested.
  */
 
-char *ide_xfer_verbose (u8 xfer_rate)
+const char *ide_xfer_verbose(u8 mode)
 {
-        switch(xfer_rate) {
-                case XFER_UDMA_7:	return("UDMA 7");
-                case XFER_UDMA_6:	return("UDMA 6");
-                case XFER_UDMA_5:	return("UDMA 5");
-                case XFER_UDMA_4:	return("UDMA 4");
-                case XFER_UDMA_3:	return("UDMA 3");
-                case XFER_UDMA_2:	return("UDMA 2");
-                case XFER_UDMA_1:	return("UDMA 1");
-                case XFER_UDMA_0:	return("UDMA 0");
-                case XFER_MW_DMA_2:	return("MW DMA 2");
-                case XFER_MW_DMA_1:	return("MW DMA 1");
-                case XFER_MW_DMA_0:	return("MW DMA 0");
-                case XFER_SW_DMA_2:	return("SW DMA 2");
-                case XFER_SW_DMA_1:	return("SW DMA 1");
-                case XFER_SW_DMA_0:	return("SW DMA 0");
-                case XFER_PIO_4:	return("PIO 4");
-                case XFER_PIO_3:	return("PIO 3");
-                case XFER_PIO_2:	return("PIO 2");
-                case XFER_PIO_1:	return("PIO 1");
-                case XFER_PIO_0:	return("PIO 0");
-                case XFER_PIO_SLOW:	return("PIO SLOW");
-                default:		return("XFER ERROR");
-        }
+	const char *s;
+	u8 i = mode & 0xf;
+
+	if (mode >= XFER_UDMA_0 && mode <= XFER_UDMA_7)
+		s = udma_str[i];
+	else if (mode >= XFER_MW_DMA_0 && mode <= XFER_MW_DMA_2)
+		s = mwdma_str[i];
+	else if (mode >= XFER_SW_DMA_0 && mode <= XFER_SW_DMA_2)
+		s = swdma_str[i];
+	else if (mode >= XFER_PIO_0 && mode <= XFER_PIO_5)
+		s = pio_str[i & 0x7];
+	else if (mode == XFER_PIO_SLOW)
+		s = "PIO SLOW";
+	else
+		s = "XFER ERROR";
+
+	return s;
 }
 
 EXPORT_SYMBOL(ide_xfer_verbose);

commit 12eda14f8930ccad0d8b75fecab87b90eecba5fb
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Nov 13 22:09:15 2007 +0100

    ide: add missing HOB bit clearing to ide_dump_ata_status()
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index af86433baede..1609b8604f56 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -514,6 +514,7 @@ static u8 ide_dump_ata_status(ide_drive_t *drive, const char *msg, u8 stat)
 			if (drive->addressing == 1) {
 				__u64 sectors = 0;
 				u32 low = 0, high = 0;
+				hwif->OUTB(drive->ctl&~0x80, IDE_CONTROL_REG);
 				low = ide_read_24(drive);
 				hwif->OUTB(drive->ctl|0x80, IDE_CONTROL_REG);
 				high = ide_read_24(drive);

commit 65c9cd23cab821c165a70ddd0447eb6362ebbb0c
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Oct 16 22:29:54 2007 +0200

    ide: remove ide_use_fast_pio()
    
    Remove ide_use_fast_pio() and just re-tune PIO unconditionally if DMA tuning
    has failed in ->ide_dma_check.  All host drivers using ide_use_fast_pio() set
    drive->autotune so PIO is always tuned anyway and in some cases we _really_
    need to re-tune PIO because PIO and DMA timings are shared.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 0e2562f0f74e..af86433baede 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -96,21 +96,6 @@ static u8 ide_rate_filter(ide_drive_t *drive, u8 speed)
 	return min(speed, mode);
 }
 
-int ide_use_fast_pio(ide_drive_t *drive)
-{
-	struct hd_driveid *id = drive->id;
-
-	if ((id->capability & 1) && drive->autodma)
-		return 1;
-
-	if ((id->capability & 8) || (id->field_valid & 2))
-		return 1;
-
-	return 0;
-}
-
-EXPORT_SYMBOL_GPL(ide_use_fast_pio);
-
 /*
  * Standard (generic) timings for PIO modes, from ATA2 specification.
  * These timings are for access to the IDE data port register *only*.

commit 88b2b32babd46cd54d2de4d17eb869aea3383e11
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Oct 13 17:47:51 2007 +0200

    ide: move ide_config_drive_speed() calls to upper layers (take 2)
    
    * Convert {ide_hwif_t,ide_pci_device_t}->host_flag to be u16.
    
    * Add IDE_HFLAG_POST_SET_MODE host flag to indicate the need to program
      the host for the transfer mode after programming the device.  Set it
      in au1xxx-ide, amd74xx, cs5530, cs5535, pdc202xx_new, sc1200, pmac
      and via82cxxx host drivers.
    
    * Add IDE_HFLAG_NO_SET_MODE host flag to indicate the need to completely
      skip programming of host/device for the transfer mode ("smart" hosts).
      Set it in it821x host driver and check it in ide_tune_dma().
    
    * Add ide_set_pio_mode()/ide_set_dma_mode() helpers and convert all
      direct ->set_pio_mode/->speedproc users to use these helpers.
    
    * Move ide_config_drive_speed() calls from ->set_pio_mode/->speedproc
      methods to callers.
    
    * Rename ->speedproc method to ->set_dma_mode, make it void and update
      all implementations accordingly.
    
    * Update ide_set_xfer_rate() comments.
    
    * Unexport ide_config_drive_speed().
    
    v2:
    * Fix issues noticed by Sergei:
      - export ide_set_dma_mode() instead of moving ->set_pio_mode abuse wrt
        to setting DMA modes from sc1200_set_pio_mode() to do_special()
      - check IDE_HFLAG_NO_SET_MODE in ide_tune_dma()
      - check for (hwif->set_pio_mode) == NULL in ide_set_pio_mode()
      - check for (hwif->set_dma_mode) == NULL in ide_set_dma_mode()
      - return -1 from ide_set_{pio,dma}_mode() if ->set_{pio,dma}_mode == NULL
      - don't set ->set_{pio,dma}_mode on it821x in "smart" mode
      - fix build problem in pmac.c
      - minor fixes in au1xxx-ide.c/cs5530.c/siimage.c
      - improve patch description
    
    Changes in behavior caused by this patch:
    - HDIO_SET_PIO_MODE ioctl would now return -ENOSYS for attempts to change
      PIO mode if it821x controller is in "smart" mode
    - removal of two debugging printk-s (from cs5530.c and sc1200.c)
    - transfer modes 0x00-0x07 passed from user space may be programmed twice on
      the device (not really an issue since 0x00 is not supported correctly by
      any host driver ATM, 0x01 is not supported at all and 0x02-0x07 are invalid)
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index d97390c0543b..0e2562f0f74e 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -349,7 +349,7 @@ void ide_set_pio(ide_drive_t *drive, u8 req_pio)
 			  drive->name, host_pio, req_pio,
 			  req_pio == 255 ? "(auto-tune)" : "", pio);
 
-	hwif->set_pio_mode(drive, pio);
+	(void)ide_set_pio_mode(drive, XFER_PIO_0 + pio);
 }
 
 EXPORT_SYMBOL_GPL(ide_set_pio);
@@ -378,39 +378,83 @@ void ide_toggle_bounce(ide_drive_t *drive, int on)
 		blk_queue_bounce_limit(drive->queue, addr);
 }
 
+int ide_set_pio_mode(ide_drive_t *drive, const u8 mode)
+{
+	ide_hwif_t *hwif = drive->hwif;
+
+	if (hwif->set_pio_mode == NULL)
+		return -1;
+
+	/*
+	 * TODO: temporary hack for some legacy host drivers that didn't
+	 * set transfer mode on the device in ->set_pio_mode method...
+	 */
+	if (hwif->set_dma_mode == NULL) {
+		hwif->set_pio_mode(drive, mode - XFER_PIO_0);
+		return 0;
+	}
+
+	if (hwif->host_flags & IDE_HFLAG_POST_SET_MODE) {
+		if (ide_config_drive_speed(drive, mode))
+			return -1;
+		hwif->set_pio_mode(drive, mode - XFER_PIO_0);
+		return 0;
+	} else {
+		hwif->set_pio_mode(drive, mode - XFER_PIO_0);
+		return ide_config_drive_speed(drive, mode);
+	}
+}
+
+int ide_set_dma_mode(ide_drive_t *drive, const u8 mode)
+{
+	ide_hwif_t *hwif = drive->hwif;
+
+	if (hwif->set_dma_mode == NULL)
+		return -1;
+
+	if (hwif->host_flags & IDE_HFLAG_POST_SET_MODE) {
+		if (ide_config_drive_speed(drive, mode))
+			return -1;
+		hwif->set_dma_mode(drive, mode);
+		return 0;
+	} else {
+		hwif->set_dma_mode(drive, mode);
+		return ide_config_drive_speed(drive, mode);
+	}
+}
+
+EXPORT_SYMBOL_GPL(ide_set_dma_mode);
+
 /**
  *	ide_set_xfer_rate	-	set transfer rate
  *	@drive: drive to set
- *	@speed: speed to attempt to set
+ *	@rate: speed to attempt to set
  *	
  *	General helper for setting the speed of an IDE device. This
  *	function knows about user enforced limits from the configuration
- *	which speedproc() does not.  High level drivers should never
- *	invoke speedproc() directly.
+ *	which ->set_pio_mode/->set_dma_mode does not.
  */
- 
+
 int ide_set_xfer_rate(ide_drive_t *drive, u8 rate)
 {
 	ide_hwif_t *hwif = drive->hwif;
 
-	if (hwif->speedproc == NULL)
+	if (hwif->set_dma_mode == NULL)
 		return -1;
 
 	rate = ide_rate_filter(drive, rate);
 
-	if (rate >= XFER_PIO_0 && rate <= XFER_PIO_5) {
-		if (hwif->set_pio_mode)
-			hwif->set_pio_mode(drive, rate - XFER_PIO_0);
+	if (rate >= XFER_PIO_0 && rate <= XFER_PIO_5)
+		return ide_set_pio_mode(drive, rate);
 
-		/*
-		 * FIXME: this is incorrect to return zero here but
-		 * since all users of ide_set_xfer_rate() ignore
-		 * the return value it is not a problem currently
-		 */
-		return 0;
-	}
+	/*
+	 * TODO: transfer modes 0x00-0x07 passed from the user-space are
+	 * currently handled here which needs fixing (please note that such
+	 * case could happen iff the transfer mode has already been set on
+	 * the device by ide-proc.c::set_xfer_rate()).
+	 */
 
-	return hwif->speedproc(drive, rate);
+	return ide_set_dma_mode(drive, rate);
 }
 
 static void ide_dump_opcode(ide_drive_t *drive)

commit 8f4dd2e42637fd61a6366d2cace69091926eaa15
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu Oct 11 23:54:02 2007 +0200

    ide: use only ->set_pio_mode method for programming PIO modes (take 2)
    
    Use ->set_pio_mode method to program PIO modes in ide_set_xfer_rate()
    (the only place which used ->speedproc to program PIO modes) and remove
    handling of PIO modes from all ->speedproc implementations.
    
    v2:
    * Fix pmac_ide_tune_chipset() comment.
    
    There should be no functionality changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 8400b1b4aa1b..d97390c0543b 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -398,6 +398,18 @@ int ide_set_xfer_rate(ide_drive_t *drive, u8 rate)
 
 	rate = ide_rate_filter(drive, rate);
 
+	if (rate >= XFER_PIO_0 && rate <= XFER_PIO_5) {
+		if (hwif->set_pio_mode)
+			hwif->set_pio_mode(drive, rate - XFER_PIO_0);
+
+		/*
+		 * FIXME: this is incorrect to return zero here but
+		 * since all users of ide_set_xfer_rate() ignore
+		 * the return value it is not a problem currently
+		 */
+		return 0;
+	}
+
 	return hwif->speedproc(drive, rate);
 }
 

commit 26bcb879c03254545a19c6700fe5bcef6f21e7b1
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu Oct 11 23:54:00 2007 +0200

    ide: add ide_set{_max}_pio() (take 4)
    
    * Add IDE_HFLAG_ABUSE_{PREFETCH,FAST_DEVSEL,DMA_MODES} flags
      and set them in ht6560, cmd640, cmd64x and sc1200 host drivers.
    
    * Add set_pio_mode_abuse() for checking if host driver has a non-standard
      ->tuneproc() implementation and use it in do_special().
    
    * Add ide_set_pio() for setting PIO mode (it uses hwif->pio_mask to find
      the maximum PIO mode supported by the host), also add ide_set_max_pio()
      wrapper for ide_set_pio() to use for auto-tuning.  Convert users of
      ->tuneproc to use ide_set{_max}_pio() where possible.  This leaves only
      do_special(), set_using_pio(), ide_hwif_restore() and ide_set_pio() as
      a direct users of ->tuneproc.
    
    * Remove no longer needed ide_get_best_pio_mode() calls and printk-s
      reporting PIO mode selected from ->tuneproc implementations.
    
    * Rename ->tuneproc hook to ->set_pio_mode and make 'pio' argument const.
    
    * Remove stale comment from ide_config_drive_speed().
    
    v2:
    * Fix "ata_" prefix (Noticed by Jeff).
    
    v3:
    * Minor cleanups/fixups per Sergei's suggestions.
    
    v4:
    * Fix compile problem in drivers/ide/pci/cmd640.c
      (Noticed by Andrew Morton).
    
    * Improve some ->set_pio_mode comments.
    
    Reviewed-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 957618849540..8400b1b4aa1b 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -325,6 +325,35 @@ u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode)
 
 EXPORT_SYMBOL_GPL(ide_get_best_pio_mode);
 
+/* req_pio == "255" for auto-tune */
+void ide_set_pio(ide_drive_t *drive, u8 req_pio)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	u8 host_pio, pio;
+
+	if (hwif->set_pio_mode == NULL)
+		return;
+
+	BUG_ON(hwif->pio_mask == 0x00);
+
+	host_pio = fls(hwif->pio_mask) - 1;
+
+	pio = ide_get_best_pio_mode(drive, req_pio, host_pio);
+
+	/*
+	 * TODO:
+	 * - report device max PIO mode
+	 * - check req_pio != 255 against device max PIO mode
+	 */
+	printk(KERN_DEBUG "%s: host max PIO%d wanted PIO%d%s selected PIO%d\n",
+			  drive->name, host_pio, req_pio,
+			  req_pio == 255 ? "(auto-tune)" : "", pio);
+
+	hwif->set_pio_mode(drive, pio);
+}
+
+EXPORT_SYMBOL_GPL(ide_set_pio);
+
 /**
  *	ide_toggle_bounce	-	handle bounce buffering
  *	@drive: drive to update

commit f212ff28f08e4ddcef9f25b13463c45cc4204a0c
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu Oct 11 23:53:59 2007 +0200

    ide: move ide_rate_filter() calls to the upper layer (take 2)
    
    * Move ide_rate_filter() calls from host drivers to IDE core.
    
    * Make ide_rate_filter() static.
    
    * Make 'speed' argument of ->speedproc const.
    
    v2:
    * Fix it8213_tune_chipset() comment.
    
    There should be no functionality changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 41a128f52112..957618849540 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -79,7 +79,7 @@ EXPORT_SYMBOL(ide_xfer_verbose);
  *	TODO: check device PIO capabilities
  */
 
-u8 ide_rate_filter(ide_drive_t *drive, u8 speed)
+static u8 ide_rate_filter(ide_drive_t *drive, u8 speed)
 {
 	ide_hwif_t *hwif = drive->hwif;
 	u8 mode = ide_find_dma_mode(drive, speed);
@@ -96,8 +96,6 @@ u8 ide_rate_filter(ide_drive_t *drive, u8 speed)
 	return min(speed, mode);
 }
 
-EXPORT_SYMBOL(ide_rate_filter);
-
 int ide_use_fast_pio(ide_drive_t *drive)
 {
 	struct hd_driveid *id = drive->id;
@@ -364,13 +362,14 @@ void ide_toggle_bounce(ide_drive_t *drive, int on)
  
 int ide_set_xfer_rate(ide_drive_t *drive, u8 rate)
 {
-#ifndef CONFIG_BLK_DEV_IDEDMA
-	rate = min(rate, (u8) XFER_PIO_4);
-#endif
-	if(HWIF(drive)->speedproc)
-		return HWIF(drive)->speedproc(drive, rate);
-	else
+	ide_hwif_t *hwif = drive->hwif;
+
+	if (hwif->speedproc == NULL)
 		return -1;
+
+	rate = ide_rate_filter(drive, rate);
+
+	return hwif->speedproc(drive, rate);
 }
 
 static void ide_dump_opcode(ide_drive_t *drive)

commit 7670df73fba373d19471a2ebedb3302ea0607be0
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu Oct 11 23:53:59 2007 +0200

    ide: mode limiting fixes for user requested speed changes
    
    * Add an extra argument to ide_max_dma_mode() for passing requested transfer
      mode.  Use it as an upper limit when finding the best DMA for device/host.
    
    * Rename ide_max_dma_mode() to ide_find_dma_mode() and at the same time add
      ide_max_dma_mode() wrapper which passes XFER_UDMA_6 as a requested mode to
      ide_find_dma_mode().  Also add inline ide_find_dma_mode() version for
      CONFIG_BLK_DEV_IDEDMA=n case.
    
    * Pass requested transfer mode from ide_find_dma_mode() to ide_get_mode_mask()
      to avoid false warning from eighty_ninty_three().
    
    * Use ide_find_dma_mode() to limit the user requested transfer mode in
      ide_rate_filter().  Also limit the requested mode by host max PIO mode.
    
    
    Above changes make ide_rate_filter() to:
    
    * Clip desired transfer mode down if it is invalid (values 0x0F, 0x13-0x19
      and 0x25-0x39, values > 0x46 were already clipped down, same for values
      0x25-0x39 but iff UDMA was not supported by the host).
    
    * Clip desired transfer mode down if it is currently unsupported by IDE core
      (PIO6 and MWDMA3-4, the latter were already clipped down but iff UDMA was
      not supported by the host).
    
    * Clip desired transfer mode down according to the host capabilities
      (UDMA modes were already clipped down but MWDMA/SWDMA/PIO weren't,
      also ->atapi_dma flag was not respected).
    
    * Clip desired transfer mode down according to the device capabilities
      (except PIO modes for now which require mode work) - shouldn't be a
      problem since ide_set_xfer_rate() is called _after_ device has accepted
      given transfer mode.
    
    and also result in a number of host driver specific bugfixes:
    
    * icside
      - clip unsupported PIO5 mode down
      - fix unsupported/invalid modes being set in drive->current_speed
    
    * ide-cris
      - clip unsupported PIO5 and SWDMA0-2 modes down
      - clip DMA modes down for ATAPI devices
      - fix BUG() on unsupported/invalid modes
    
    * au1xxx-ide
      - clip unsupported PIO5, SWDMA0-2 and MWDMA0-2
        (if BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA=n) modes down
    
    * aec62xx
      - clip unsupported PIO5 and SWDMA0-2 modes down
      - clip DMA modes down for ATAPI devices
      - fix 0x00 being programmed as PIO timing for unsupported/invalid modes
      - fix unsupported/invalid modes being set on the device
    
    * alim15x3
      - clip DMA modes down for ATAPI devices (chipset revision == 0x20 only)
      - fix theoretical OOPS for 0x0F mode
      - fix unsupported/invalid modes being set on the device
    
    * amd74xx
      - clip unsupported SWDMA0-2 (on COBRA_7401 revs <= 7) modes down
      - fix random PIO timings being set for unsupported/invalid modes
      - fix unsupported/invalid modes being set on the device
    
    * atiixp
      - clip unsupported PIO5 and SWDMA0-2 modes down
      - fix cached MWDMA mode being cleared for unsupported/invalid modes
      - fix PIO{0,2} timings being programmed for unsupported/invalid modes
      - fix theoretical OOPS for PIO5-6 and 0x0F modes
      - fix unsupported/invalid modes being set on the device
    
    * cmd64x
      - clip unsupported SWDMA0-2 modes down
    
    * cs5530
      - clip unsupported PIO5 and SWDMA0-2 modes down
      - fix unsupported/invalid modes being set on the device
      - fix BUG() on unsupported/invalid modes
        (which happened if the device accepted the setting)
    
    * cs5535
      - clip unsupported PIO5 and SWDMA0-2 modes down
      - fix unsupported/invalid modes being set on the device
      - fix theoretical OOPS for PIO5-6 and 0x0F modes
    
    * hpt34x
      - clip DMA modes down for ATAPI devices
      - fix invalid timings being programmed for unsupported/invalid modes
      - fix unsupported/invalid modes being set on the device
    
    * hpt366
      - clip unsupported PIO5 and SWDMA0-2 modes down
      - fix PIO0 timings being programmed for unsupported/invalid modes
      - fix DMA timings being cleared for MWDMA3-4 and 0x25-0x39 modes
      - fix unsupported/invalid modes being set on the device
    
    * it8213
      - clip unsupported PIO5, SWDMA0-1 and MWDMA0 modes down
    
    * it821x
      - clip unsupported PIO5 and SWDMA0-2 modes down
      - clip DMA modes down for ATAPI devices
        (chipset in smart mode and revision 0x10 in pass-through mode)
    
    * jmicron
      - clip unsupported SWDMA0-2 modes down
      - fix unsupported/invalid modes being set on the device
    
    * pdc202xx_new
      - clip unsupported PIO5 and SWDMA0-2 modes down
      - fix unsupported/invalid modes being set on the device
    
    * pdc202xx_old
      - clip unsupported PIO5 mode down
      - fix incorrect timings being set for unsupported/invalid modes
      - fix unsupported/invalid modes being set on the device
    
    * piix
      - clip unsupported PIO5, SWDMA0-1 and MWDMA0 modes down
    
    * sc1200
      - clip unsupported PIO5 and SWDMA0-2 modes down
      - fix unsupported/invalid modes being set on the device
      - fix BUG() on unsupported/invalid modes
        (which happened if the device accepted the setting)
    
    * scc_pata
      - clip unsupported PIO5, SWDMA0-2 and MWDMA0-2 modes down
    
    * serverworks
      - clip unsupported PIO5 and SWDMA0-2 modes down
      - fix DMA/UDMA timings/settings being cleared for unsupported/invalid modes
      - fix unsupported/invalid modes being set on the device
    
    * siimage
      - clip unsupported PIO5 and SWDMA0-2 modes down
      - clip DMA modes down for ATAPI devices (SATA chipsets)
    
    * sis5513
      - clip unsupported PIO5 mode down
      - fix BUG() on unsupported/invalid modes
    
    * sl82c105
      - clip unsupported SWDMA0-2 modes down
    
    * slc90e66
      - clip unsupported PIO5, SWDMA0-1 and MWDMA0 modes down
    
    * tc86c001
      - clip unsupported PIO5 and SWDMA0-2 modes down
      - fix PIO0 timings being programmed for PIO5/0x0F/SWDMA0-2/0x13-0x19 modes
      - fix invalid 0x00 DMA timing being programmed for MWDMA3-4/0x25-0x39 modes
      - fix unsupported/invalid modes being set on the device
    
    * triflex
      - clip unsupported PIO5 mode down
    
    * via82cxxx
      - fix random PIO timings being set for unsupported/invalid modes
      - fix unsupported/invalid modes being set on the device
    
    * pmac
      - clip unsupported PIO5 and SWDMA0-2 modes down
    
    * cmd640/ht6560b
      - clip DMA modes down (if CONFIG_BLK_DEV_IDEDMA=y)
      - fix PIO5 being clipped to PIO4 (if CONFIG_BLK_DEV_IDEDMA=n)
    
    * opti621
      - clip DMA modes down (if CONFIG_BLK_DEV_IDEDMA=y)
      - clip unsupported PIO4 to PIO3 (if CONFIG_BLK_DEV_IDEDMA=n)
    
    
    While at it:
    
    * Use ide_rate_filter() in cs5520.c::cs5520_tune_chipset().
    
    * Remove no longer needed checks from hpt366.c::hpt3{6,7}x_tune_chipset().
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 92a6c7bcf527..41a128f52112 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -76,37 +76,24 @@ EXPORT_SYMBOL(ide_xfer_verbose);
  *	Given the available transfer modes this function returns
  *	the best available speed at or below the speed requested.
  *
- *	FIXME: filter also PIO/SWDMA/MWDMA modes
+ *	TODO: check device PIO capabilities
  */
 
 u8 ide_rate_filter(ide_drive_t *drive, u8 speed)
 {
-#ifdef CONFIG_BLK_DEV_IDEDMA
 	ide_hwif_t *hwif = drive->hwif;
-	u8 mask = hwif->ultra_mask, mode = XFER_MW_DMA_2;
-
-	if (hwif->udma_filter)
-		mask = hwif->udma_filter(drive);
-
-	/*
-	 * TODO: speed > XFER_UDMA_2 extra check is needed to avoid false
-	 * cable warning from eighty_ninty_three(), moving ide_rate_filter()
-	 * calls from ->speedproc to core code will make this hack go away
-	 */
-	if (speed > XFER_UDMA_2) {
-		if ((mask & 0x78) && (eighty_ninty_three(drive) == 0))
-			mask &= 0x07;
-	}
+	u8 mode = ide_find_dma_mode(drive, speed);
 
-	if (mask)
-		mode = fls(mask) - 1 + XFER_UDMA_0;
+	if (mode == 0) {
+		if (hwif->pio_mask)
+			mode = fls(hwif->pio_mask) - 1 + XFER_PIO_0;
+		else
+			mode = XFER_PIO_4;
+	}
 
 //	printk("%s: mode 0x%02x, speed 0x%02x\n", __FUNCTION__, mode, speed);
 
 	return min(speed, mode);
-#else /* !CONFIG_BLK_DEV_IDEDMA */
-	return min(speed, (u8)XFER_PIO_4);
-#endif /* CONFIG_BLK_DEV_IDEDMA */
 }
 
 EXPORT_SYMBOL(ide_rate_filter);

commit 6a824c92db4d606c324272c4eed366fb71672440
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jul 20 01:11:58 2007 +0200

    ide: remove ide_find_best_pio_mode()
    
    * Add ->host_flags to ide_hwif_t to store ide_pci_device_t.host_flags,
      assign it in setup-pci.c:ide_pci_setup_ports().
    
    * Add IDE_HFLAG_PIO_NO_{BLACKLIST,DOWNGRADE} to ide_pci_device_t.host_flags
      and teach ide_get_best_pio_mode() about them.  Also remove needless
      !drive->id check while at it (drive->id is always present).
    
    * Convert amd74xx, via82cxxx and ide-timing.h to use ide_get_best_pio_mode()
      and then remove no longer needed ide_find_best_pio_mode().
    
    There should be no functionality changes caused by this patch.
    
    Acked-by: Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index df29868209f3..92a6c7bcf527 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -291,11 +291,11 @@ u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode)
 	struct hd_driveid* id = drive->id;
 	int overridden  = 0;
 
-	if (mode_wanted != 255) {
-		pio_mode = mode_wanted;
-	} else if (!drive->id) {
-		pio_mode = 0;
-	} else if ((pio_mode = ide_scan_pio_blacklist(id->model)) != -1) {
+	if (mode_wanted != 255)
+		return min_t(u8, mode_wanted, max_mode);
+
+	if ((drive->hwif->host_flags & IDE_HFLAG_PIO_NO_BLACKLIST) == 0 &&
+	    (pio_mode = ide_scan_pio_blacklist(id->model)) != -1) {
 		printk(KERN_INFO "%s: is on PIO blacklist\n", drive->name);
 	} else {
 		pio_mode = id->tPIO;
@@ -324,7 +324,8 @@ u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode)
 		/*
 		 * Conservative "downgrade" for all pre-ATA2 drives
 		 */
-		if (pio_mode && pio_mode < 4) {
+		if ((drive->hwif->host_flags & IDE_HFLAG_PIO_NO_DOWNGRADE) == 0 &&
+		    pio_mode && pio_mode < 4) {
 			pio_mode--;
 			printk(KERN_INFO "%s: applying conservative "
 					 "PIO \"downgrade\"\n", drive->name);

commit 2134758d2a5429325cee4d4ce8959af5314eeba1
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jul 20 01:11:58 2007 +0200

    ide: drop "PIO data" argument from ide_get_best_pio_mode()
    
    * Drop no longer needed "PIO data" argument from ide_get_best_pio_mode()
      and convert all users accordingly.
    
    * Remove no longer needed ide_pio_data_t.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 6e85bee0bef7..df29868209f3 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -277,7 +277,6 @@ EXPORT_SYMBOL_GPL(ide_pio_cycle_time);
  *	@drive: drive to consider
  *	@mode_wanted: preferred mode
  *	@max_mode: highest allowed mode
- *	@d: PIO data
  *
  *	This routine returns the recommended PIO settings for a given drive,
  *	based on the drive->id information and the ide_pio_blacklist[].
@@ -286,7 +285,7 @@ EXPORT_SYMBOL_GPL(ide_pio_cycle_time);
  *	This is used by most chipset support modules when "auto-tuning".
  */
 
-u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode, ide_pio_data_t *d)
+u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode)
 {
 	int pio_mode;
 	struct hd_driveid* id = drive->id;
@@ -335,9 +334,6 @@ u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode, ide_p
 	if (pio_mode > max_mode)
 		pio_mode = max_mode;
 
-	if (d)
-		d->pio_mode = pio_mode;
-
 	return pio_mode;
 }
 

commit 7dd00083b1160b560fa2a0a486799b57baa5d035
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jul 20 01:11:56 2007 +0200

    ide: add ide_pio_cycle_time() helper (take 2)
    
    * Add ide_pio_cycle_time() helper.
    
    * Use it in ali14xx/ht6560b/qd65xx/cmd64{0,x}/sl82c105 and pmac host drivers
      (previously cycle time given by the device was only used for "pio" == 255).
    
    * Remove no longer needed ide_pio_data_t.cycle_time field.
    
    v2:
    * Fix "ata_" prefix (Noticed by Jeff).
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index d5cc96bb4298..6e85bee0bef7 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -249,6 +249,29 @@ static int ide_scan_pio_blacklist (char *model)
 	return -1;
 }
 
+unsigned int ide_pio_cycle_time(ide_drive_t *drive, u8 pio)
+{
+	struct hd_driveid *id = drive->id;
+	int cycle_time = 0;
+
+	if (id->field_valid & 2) {
+		if (id->capability & 8)
+			cycle_time = id->eide_pio_iordy;
+		else
+			cycle_time = id->eide_pio;
+	}
+
+	/* conservative "downgrade" for all pre-ATA2 drives */
+	if (pio < 3) {
+		if (cycle_time && cycle_time < ide_pio_timings[pio].cycle_time)
+			cycle_time = 0; /* use standard timing */
+	}
+
+	return cycle_time ? cycle_time : ide_pio_timings[pio].cycle_time;
+}
+
+EXPORT_SYMBOL_GPL(ide_pio_cycle_time);
+
 /**
  *	ide_get_best_pio_mode	-	get PIO mode from drive
  *	@drive: drive to consider
@@ -266,7 +289,6 @@ static int ide_scan_pio_blacklist (char *model)
 u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode, ide_pio_data_t *d)
 {
 	int pio_mode;
-	int cycle_time = 0;
 	struct hd_driveid* id = drive->id;
 	int overridden  = 0;
 
@@ -284,7 +306,6 @@ u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode, ide_p
 		}
 		if (id->field_valid & 2) {	  /* drive implements ATA2? */
 			if (id->capability & 8) { /* IORDY supported? */
-				cycle_time = id->eide_pio_iordy;
 				if (id->eide_pio_modes & 7) {
 					overridden = 0;
 					if (id->eide_pio_modes & 4)
@@ -294,8 +315,6 @@ u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode, ide_p
 					else
 						pio_mode = 3;
 				}
-			} else {
-				cycle_time = id->eide_pio;
 			}
 		}
 
@@ -310,18 +329,15 @@ u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode, ide_p
 			pio_mode--;
 			printk(KERN_INFO "%s: applying conservative "
 					 "PIO \"downgrade\"\n", drive->name);
-			if (cycle_time && cycle_time < ide_pio_timings[pio_mode].cycle_time)
-				cycle_time = 0; /* use standard timing */
 		}
 	}
-	if (pio_mode > max_mode) {
+
+	if (pio_mode > max_mode)
 		pio_mode = max_mode;
-		cycle_time = 0;
-	}
-	if (d) {
+
+	if (d)
 		d->pio_mode = pio_mode;
-		d->cycle_time = cycle_time ? cycle_time : ide_pio_timings[pio_mode].cycle_time;
-	}
+
 	return pio_mode;
 }
 

commit 2229833c1365346b64357a9263fa724f74f5e376
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jul 20 01:11:55 2007 +0200

    ide: add ide_dev_has_iordy() helper (take 4)
    
    * Add ide_dev_has_iordy() helper and use it sl82c105 host driver.
    
    * Remove no longer needed ide_pio_data_t.use_iordy field.
    
    v2/v3:
    * Fix issues noticed by Sergei:
      - correct patch description
      - fix comment in ide_get_best_pio_mode()
    
    v4:
    * Fix "ata_" prefix (Noticed by Jeff).
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index d45bbad9ffe7..d5cc96bb4298 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -267,18 +267,15 @@ u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode, ide_p
 {
 	int pio_mode;
 	int cycle_time = 0;
-	int use_iordy = 0;
 	struct hd_driveid* id = drive->id;
 	int overridden  = 0;
 
 	if (mode_wanted != 255) {
 		pio_mode = mode_wanted;
-		use_iordy = (pio_mode > 2);
 	} else if (!drive->id) {
 		pio_mode = 0;
 	} else if ((pio_mode = ide_scan_pio_blacklist(id->model)) != -1) {
 		printk(KERN_INFO "%s: is on PIO blacklist\n", drive->name);
-		use_iordy = (pio_mode > 2);
 	} else {
 		pio_mode = id->tPIO;
 		if (pio_mode > 2) {	/* 2 is maximum allowed tPIO value */
@@ -286,8 +283,7 @@ u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode, ide_p
 			overridden = 1;
 		}
 		if (id->field_valid & 2) {	  /* drive implements ATA2? */
-			if (id->capability & 8) { /* drive supports use_iordy? */
-				use_iordy = 1;
+			if (id->capability & 8) { /* IORDY supported? */
 				cycle_time = id->eide_pio_iordy;
 				if (id->eide_pio_modes & 7) {
 					overridden = 0;
@@ -325,7 +321,6 @@ u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode, ide_p
 	if (d) {
 		d->pio_mode = pio_mode;
 		d->cycle_time = cycle_time ? cycle_time : ide_pio_timings[pio_mode].cycle_time;
-		d->use_iordy = use_iordy;
 	}
 	return pio_mode;
 }

commit 342cdb6d4739cee430efc3eafcacd1605db66036
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jul 20 01:11:55 2007 +0200

    ide: make ide_get_best_pio_mode() print info if overriding PIO mode
    
    * Print info about overriding PIO mode in ide_get_best_pio_mode().
    
    * Remove info about overriding PIO mode from cmd64{0,x} host drivers.
    
    * Remove no longer needed ide_pio_data_t.overridden field.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 074bb32a4a40..d45bbad9ffe7 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -277,7 +277,7 @@ u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode, ide_p
 	} else if (!drive->id) {
 		pio_mode = 0;
 	} else if ((pio_mode = ide_scan_pio_blacklist(id->model)) != -1) {
-		overridden = 1;
+		printk(KERN_INFO "%s: is on PIO blacklist\n", drive->name);
 		use_iordy = (pio_mode > 2);
 	} else {
 		pio_mode = id->tPIO;
@@ -303,12 +303,17 @@ u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode, ide_p
 			}
 		}
 
+		if (overridden)
+			printk(KERN_INFO "%s: tPIO > 2, assuming tPIO = 2\n",
+					 drive->name);
+
 		/*
 		 * Conservative "downgrade" for all pre-ATA2 drives
 		 */
 		if (pio_mode && pio_mode < 4) {
 			pio_mode--;
-			overridden = 1;
+			printk(KERN_INFO "%s: applying conservative "
+					 "PIO \"downgrade\"\n", drive->name);
 			if (cycle_time && cycle_time < ide_pio_timings[pio_mode].cycle_time)
 				cycle_time = 0; /* use standard timing */
 		}
@@ -321,7 +326,6 @@ u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode, ide_p
 		d->pio_mode = pio_mode;
 		d->cycle_time = cycle_time ? cycle_time : ide_pio_timings[pio_mode].cycle_time;
 		d->use_iordy = use_iordy;
-		d->overridden = overridden;
 	}
 	return pio_mode;
 }

commit 4728d546d7137ad5350cc2e53d4748fd26f61a60
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed May 16 00:51:46 2007 +0200

    ide: remove ide_dma_enable()
    
    * check ->speedproc return value in ide_tune_dma()
    * use ide_tune_dma() in cmd64x/cs5530/sc1200/siimage/sl82c105/scc_pata drivers
    * remove no longer needed ide_dma_enable()
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 3be3c69383f2..074bb32a4a40 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -111,18 +111,6 @@ u8 ide_rate_filter(ide_drive_t *drive, u8 speed)
 
 EXPORT_SYMBOL(ide_rate_filter);
 
-int ide_dma_enable (ide_drive_t *drive)
-{
-	ide_hwif_t *hwif	= HWIF(drive);
-	struct hd_driveid *id	= drive->id;
-
-	return ((int)	((((id->dma_ultra >> 8) & hwif->ultra_mask) ||
-			  ((id->dma_mword >> 8) & hwif->mwdma_mask) ||
-			  ((id->dma_1word >> 8) & hwif->swdma_mask)) ? 1 : 0));
-}
-
-EXPORT_SYMBOL(ide_dma_enable);
-
 int ide_use_fast_pio(ide_drive_t *drive)
 {
 	struct hd_driveid *id = drive->id;

commit 7f8f48af0861c38c28d4abd550102643e0ea9e6a
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu May 10 00:01:10 2007 +0200

    ide: cable detection fixes (take 2)
    
    Tejun's recent eighty_ninty_three() fix has inspired me to do more thorough
    review of the cable detection code...
    
    * print user-friendly warning about limiting the maximum transfer speed
      to UDMA33 (and the reason behind it) when 80-wire cable is not detected,
      also while at it cleanup eighty_ninty_three() a bit
    
    * use eighty_ninty_three() in ide_ata66_check(), this actually fixes 3 bugs:
      - bit 14 (word 93 validity check) == 1 && bit 13 (80-wire cable test) == 1
        were used as 80-wire cable present test for CONFIG_IDEDMA_IVB=n case
        (please see FIXME comment in eighty_ninty_three() for more details)
      - CONFIG_IDEDMA_IVB=y/n cases were interchanged
      - check for SATA devices was missing
    
    * remove private cable warnings from pdc_202xx{old,new} drivers now that core
      code provides this functionality (plus, in pdc202xx_new case the test could
      give false warnings for ATAPI devices because pdc202xx_new driver doesn't
      even support ATAPI DMA)
    
    Cc: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 4557fc5a3ea3..3be3c69383f2 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -88,8 +88,15 @@ u8 ide_rate_filter(ide_drive_t *drive, u8 speed)
 	if (hwif->udma_filter)
 		mask = hwif->udma_filter(drive);
 
-	if ((mask & 0x78) && (eighty_ninty_three(drive) == 0))
-		mask &= 0x07;
+	/*
+	 * TODO: speed > XFER_UDMA_2 extra check is needed to avoid false
+	 * cable warning from eighty_ninty_three(), moving ide_rate_filter()
+	 * calls from ->speedproc to core code will make this hack go away
+	 */
+	if (speed > XFER_UDMA_2) {
+		if ((mask & 0x78) && (eighty_ninty_three(drive) == 0))
+			mask &= 0x07;
+	}
 
 	if (mask)
 		mode = fls(mask) - 1 + XFER_UDMA_0;

commit 2d5eaa6dd744a641e75503232a01f52d0768884c
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu May 10 00:01:08 2007 +0200

    ide: rework the code for selecting the best DMA transfer mode (v3)
    
    Depends on the "ide: fix UDMA/MWDMA/SWDMA masks" patch.
    
    * add ide_hwif_t.udma_filter hook for filtering UDMA mask
      (use it in alim15x3, hpt366, siimage and serverworks drivers)
    * add ide_max_dma_mode() for finding best DMA mode for the device
      (loosely based on some older libata-core.c code)
    * convert ide_dma_speed() users to use ide_max_dma_mode()
    * make ide_rate_filter() take "ide_drive_t *drive" as an argument instead
      of "u8 mode" and teach it to how to use UDMA mask to do filtering
    * use ide_rate_filter() in hpt366 driver
    * remove no longer needed ide_dma_speed() and *_ratemask()
    * unexport eighty_ninty_three()
    
    v2:
    * rename ->filter_udma_mask to ->udma_filter
      [ Suggested by Sergei Shtylyov <sshtylyov@ru.mvista.com>. ]
    
    v3:
    * updated for scc_pata driver (fixes XFER_UDMA_6 filtering for user-space
      originated transfer mode change requests when 100MHz clock is used)
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 68719314df3f..4557fc5a3ea3 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -69,123 +69,34 @@ char *ide_xfer_verbose (u8 xfer_rate)
 EXPORT_SYMBOL(ide_xfer_verbose);
 
 /**
- *	ide_dma_speed	-	compute DMA speed
- *	@drive: drive
- *	@mode:	modes available
- *
- *	Checks the drive capabilities and returns the speed to use
- *	for the DMA transfer.  Returns 0 if the drive is incapable
- *	of DMA transfers.
- */
- 
-u8 ide_dma_speed(ide_drive_t *drive, u8 mode)
-{
-	struct hd_driveid *id   = drive->id;
-	ide_hwif_t *hwif	= HWIF(drive);
-	u8 ultra_mask, mwdma_mask, swdma_mask;
-	u8 speed = 0;
-
-	if (drive->media != ide_disk && hwif->atapi_dma == 0)
-		return 0;
-
-	/* Capable of UltraDMA modes? */
-	ultra_mask = id->dma_ultra & hwif->ultra_mask;
-
-	if (!(id->field_valid & 4))
-		mode = 0;	/* fallback to MW/SW DMA if no UltraDMA */
-
-	switch (mode) {
-	case 4:
-		if (ultra_mask & 0x40) {
-			speed = XFER_UDMA_6;
-			break;
-		}
-	case 3:
-		if (ultra_mask & 0x20) {
-			speed = XFER_UDMA_5;
-			break;
-		}
-	case 2:
-		if (ultra_mask & 0x10) {
-			speed = XFER_UDMA_4;
-			break;
-		}
-		if (ultra_mask & 0x08) {
-			speed = XFER_UDMA_3;
-			break;
-		}
-	case 1:
-		if (ultra_mask & 0x04) {
-			speed = XFER_UDMA_2;
-			break;
-		}
-		if (ultra_mask & 0x02) {
-			speed = XFER_UDMA_1;
-			break;
-		}
-		if (ultra_mask & 0x01) {
-			speed = XFER_UDMA_0;
-			break;
-		}
-	case 0:
-		mwdma_mask = id->dma_mword & hwif->mwdma_mask;
-
-		if (mwdma_mask & 0x04) {
-			speed = XFER_MW_DMA_2;
-			break;
-		}
-		if (mwdma_mask & 0x02) {
-			speed = XFER_MW_DMA_1;
-			break;
-		}
-		if (mwdma_mask & 0x01) {
-			speed = XFER_MW_DMA_0;
-			break;
-		}
-
-		swdma_mask = id->dma_1word & hwif->swdma_mask;
-
-		if (swdma_mask & 0x04) {
-			speed = XFER_SW_DMA_2;
-			break;
-		}
-		if (swdma_mask & 0x02) {
-			speed = XFER_SW_DMA_1;
-			break;
-		}
-		if (swdma_mask & 0x01) {
-			speed = XFER_SW_DMA_0;
-			break;
-		}
-	}
-
-	return speed;
-}
-EXPORT_SYMBOL(ide_dma_speed);
-
-
-/**
- *	ide_rate_filter		-	return best speed for mode
- *	@mode: modes available
+ *	ide_rate_filter		-	filter transfer mode
+ *	@drive: IDE device
  *	@speed: desired speed
  *
- *	Given the available DMA/UDMA mode this function returns
+ *	Given the available transfer modes this function returns
  *	the best available speed at or below the speed requested.
+ *
+ *	FIXME: filter also PIO/SWDMA/MWDMA modes
  */
 
-u8 ide_rate_filter (u8 mode, u8 speed) 
+u8 ide_rate_filter(ide_drive_t *drive, u8 speed)
 {
 #ifdef CONFIG_BLK_DEV_IDEDMA
-	static u8 speed_max[] = {
-		XFER_MW_DMA_2, XFER_UDMA_2, XFER_UDMA_4,
-		XFER_UDMA_5, XFER_UDMA_6
-	};
+	ide_hwif_t *hwif = drive->hwif;
+	u8 mask = hwif->ultra_mask, mode = XFER_MW_DMA_2;
+
+	if (hwif->udma_filter)
+		mask = hwif->udma_filter(drive);
+
+	if ((mask & 0x78) && (eighty_ninty_three(drive) == 0))
+		mask &= 0x07;
+
+	if (mask)
+		mode = fls(mask) - 1 + XFER_UDMA_0;
 
 //	printk("%s: mode 0x%02x, speed 0x%02x\n", __FUNCTION__, mode, speed);
 
-	/* So that we remember to update this if new modes appear */
-	BUG_ON(mode > 4);
-	return min(speed, speed_max[mode]);
+	return min(speed, mode);
 #else /* !CONFIG_BLK_DEV_IDEDMA */
 	return min(speed, (u8)XFER_PIO_4);
 #endif /* CONFIG_BLK_DEV_IDEDMA */

commit 81d368e0e2591497106b2543918c79dd6d78277b
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Sat Mar 3 17:48:53 2007 +0100

    ide: ide_get_best_pio_mode() returns incorrect IORDY setting (take 2)
    
    The function ide_get_best_pio_mode() fails to return the correct IORDY setting
    for the explicitly specified modes -- fix this along with the heading comment,
    and also remove the long commented out code.
    
    Also, while at it, correct the misliading comment about the PIO cycle time in
    <linux/ide.h> -- it actually consists of only the active and recovery periods,
    with only some chips also including the address setup time into equation...
    
    [ bart: sl82c105 seems to be currently the only driver affected by this fix ]
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 8afce4ceea31..68719314df3f 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -345,16 +345,16 @@ static int ide_scan_pio_blacklist (char *model)
 
 /**
  *	ide_get_best_pio_mode	-	get PIO mode from drive
- *	@driver: drive to consider
+ *	@drive: drive to consider
  *	@mode_wanted: preferred mode
- *	@max_mode: highest allowed
- *	@d: pio data
+ *	@max_mode: highest allowed mode
+ *	@d: PIO data
  *
  *	This routine returns the recommended PIO settings for a given drive,
  *	based on the drive->id information and the ide_pio_blacklist[].
- *	This is used by most chipset support modules when "auto-tuning".
  *
- *	Drive PIO mode auto selection
+ *	Drive PIO mode is auto-selected if 255 is passed as mode_wanted.
+ *	This is used by most chipset support modules when "auto-tuning".
  */
 
 u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode, ide_pio_data_t *d)
@@ -367,6 +367,7 @@ u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode, ide_p
 
 	if (mode_wanted != 255) {
 		pio_mode = mode_wanted;
+		use_iordy = (pio_mode > 2);
 	} else if (!drive->id) {
 		pio_mode = 0;
 	} else if ((pio_mode = ide_scan_pio_blacklist(id->model)) != -1) {
@@ -396,19 +397,12 @@ u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode, ide_p
 			}
 		}
 
-#if 0
-		if (drive->id->major_rev_num & 0x0004) printk("ATA-2 ");
-#endif
-
 		/*
 		 * Conservative "downgrade" for all pre-ATA2 drives
 		 */
 		if (pio_mode && pio_mode < 4) {
 			pio_mode--;
 			overridden = 1;
-#if 0
-			use_iordy = (pio_mode > 2);
-#endif
 			if (cycle_time && cycle_time < ide_pio_timings[pio_mode].cycle_time)
 				cycle_time = 0; /* use standard timing */
 		}

commit 7569e8dc2213ecc47024ea5edbadc8736487d926
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Feb 17 02:40:25 2007 +0100

    ide: add ide_use_fast_pio() helper (v3)
    
    * add ide_use_fast_pio() helper for use by host drivers
    
    * add DMA capability and hwif->autodma checks to ide_use_dma()
    
      - au1xxx-ide/it8213/it821x drivers didn't check for (id->capability & 1)
    
        [ for the IT8211/2 in SMART mode this check shouldn't be made but since
          in it821x_fixups() we set DMA bit explicitly:
    
                   if(strstr(id->model, "Integrated Technology Express")) {
                           /* In raid mode the ident block is slightly buggy
                              We need to set the bits so that the IDE layer knows
                              LBA28. LBA48 and DMA ar valid */
                           id->capability |= 3;            /* LBA28, DMA */
    
           we are better off using generic helper if we can ]
    
      - ide-cris driver didn't set ->autodma
    
        [ before the patch hwif->autodma was only checked in the chipset specific
          hwif->ide_dma_check implementations, for ide-cris it is cris_dma_check()
          function so there no behavior change here ]
    
    v2:
    * updated patch description (thanks to Alan Cox for the feedback)
    
    v3:
    * updated for scc_pata driver
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index bea5e13ee361..8afce4ceea31 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -205,6 +205,21 @@ int ide_dma_enable (ide_drive_t *drive)
 
 EXPORT_SYMBOL(ide_dma_enable);
 
+int ide_use_fast_pio(ide_drive_t *drive)
+{
+	struct hd_driveid *id = drive->id;
+
+	if ((id->capability & 1) && drive->autodma)
+		return 1;
+
+	if ((id->capability & 8) || (id->field_valid & 2))
+		return 1;
+
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(ide_use_fast_pio);
+
 /*
  * Standard (generic) timings for PIO modes, from ATA2 specification.
  * These timings are for access to the IDE data port register *only*.

commit 056a697b7388844a1341e92e277bff8e5bf61ec9
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Feb 17 02:40:24 2007 +0100

    ide: unexport ide_set_xfer_rate() (v2)
    
    In cmd64x, siimage and scc_pata drivers:
    * don't set drive->init_speed as it should be already
      set by successful execution of ide_set_xfer_rate()
    * use hwif->speedproc functions directly
    
    Above changes allows removal of EXPORT_SYMBOL_GPL(ide_set_xfer_rate).
    
    v2:
    * updated for scc_pata driver
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 345456f4c002..bea5e13ee361 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -459,8 +459,6 @@ int ide_set_xfer_rate(ide_drive_t *drive, u8 rate)
 		return -1;
 }
 
-EXPORT_SYMBOL_GPL(ide_set_xfer_rate);
-
 static void ide_dump_opcode(ide_drive_t *drive)
 {
 	struct request *rq;

commit 6679054895f9b1dc676d14637306b297451f1ac0
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Feb 17 02:40:24 2007 +0100

    ide: remove write-only ide_pio_data_t.blacklisted
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 8237d89eec6e..345456f4c002 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -349,7 +349,6 @@ u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode, ide_p
 	int use_iordy = 0;
 	struct hd_driveid* id = drive->id;
 	int overridden  = 0;
-	int blacklisted = 0;
 
 	if (mode_wanted != 255) {
 		pio_mode = mode_wanted;
@@ -357,7 +356,6 @@ u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode, ide_p
 		pio_mode = 0;
 	} else if ((pio_mode = ide_scan_pio_blacklist(id->model)) != -1) {
 		overridden = 1;
-		blacklisted = 1;
 		use_iordy = (pio_mode > 2);
 	} else {
 		pio_mode = id->tPIO;
@@ -409,7 +407,6 @@ u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode, ide_p
 		d->cycle_time = cycle_time ? cycle_time : ide_pio_timings[pio_mode].cycle_time;
 		d->use_iordy = use_iordy;
 		d->overridden = overridden;
-		d->blacklisted = blacklisted;
 	}
 	return pio_mode;
 }

commit 0750508ae6479d4ac6154b35c5b82929f31efb03
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Tue Oct 3 01:14:17 2006 -0700

    [PATCH] ide_dma_speed() fixes
    
    ide_dma_speed() fails to actually honor the IDE drivers' mode support
    masks) because of the bogus checks -- thus, selecting the DMA transfer mode
    that the driver explicitly refuses to support is possible.  Additionally,
    there is no check for validity of the UltraDMA mode data in the drive ID,
    and the function is misdocumented.
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: Bartlomiej Zolnierkiewicz <B.Zolnierkiewicz@elka.pw.edu.pl>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 850ef63cc986..8237d89eec6e 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -71,75 +71,96 @@ EXPORT_SYMBOL(ide_xfer_verbose);
 /**
  *	ide_dma_speed	-	compute DMA speed
  *	@drive: drive
- *	@mode; intended mode
+ *	@mode:	modes available
  *
  *	Checks the drive capabilities and returns the speed to use
- *	for the transfer. Returns -1 if the requested mode is unknown
- *	(eg PIO)
+ *	for the DMA transfer.  Returns 0 if the drive is incapable
+ *	of DMA transfers.
  */
  
 u8 ide_dma_speed(ide_drive_t *drive, u8 mode)
 {
 	struct hd_driveid *id   = drive->id;
 	ide_hwif_t *hwif	= HWIF(drive);
+	u8 ultra_mask, mwdma_mask, swdma_mask;
 	u8 speed = 0;
 
 	if (drive->media != ide_disk && hwif->atapi_dma == 0)
 		return 0;
 
-	switch(mode) {
-		case 0x04:
-			if ((id->dma_ultra & 0x0040) &&
-			    (id->dma_ultra & hwif->ultra_mask))
-				{ speed = XFER_UDMA_6; break; }
-		case 0x03:
-			if ((id->dma_ultra & 0x0020) &&
-			    (id->dma_ultra & hwif->ultra_mask))
-				{ speed = XFER_UDMA_5; break; }
-		case 0x02:
-			if ((id->dma_ultra & 0x0010) &&
-			    (id->dma_ultra & hwif->ultra_mask))
-				{ speed = XFER_UDMA_4; break; }
-			if ((id->dma_ultra & 0x0008) &&
-			    (id->dma_ultra & hwif->ultra_mask))
-				{ speed = XFER_UDMA_3; break; }
-		case 0x01:
-			if ((id->dma_ultra & 0x0004) &&
-			    (id->dma_ultra & hwif->ultra_mask))
-				{ speed = XFER_UDMA_2; break; }
-			if ((id->dma_ultra & 0x0002) &&
-			    (id->dma_ultra & hwif->ultra_mask))
-				{ speed = XFER_UDMA_1; break; }
-			if ((id->dma_ultra & 0x0001) &&
-			    (id->dma_ultra & hwif->ultra_mask))
-				{ speed = XFER_UDMA_0; break; }
-		case 0x00:
-			if ((id->dma_mword & 0x0004) &&
-			    (id->dma_mword & hwif->mwdma_mask))
-				{ speed = XFER_MW_DMA_2; break; }
-			if ((id->dma_mword & 0x0002) &&
-			    (id->dma_mword & hwif->mwdma_mask))
-				{ speed = XFER_MW_DMA_1; break; }
-			if ((id->dma_mword & 0x0001) &&
-			    (id->dma_mword & hwif->mwdma_mask))
-				{ speed = XFER_MW_DMA_0; break; }
-			if ((id->dma_1word & 0x0004) &&
-			    (id->dma_1word & hwif->swdma_mask))
-				{ speed = XFER_SW_DMA_2; break; }
-			if ((id->dma_1word & 0x0002) &&
-			    (id->dma_1word & hwif->swdma_mask))
-				{ speed = XFER_SW_DMA_1; break; }
-			if ((id->dma_1word & 0x0001) &&
-			    (id->dma_1word & hwif->swdma_mask))
-				{ speed = XFER_SW_DMA_0; break; }
-	}
+	/* Capable of UltraDMA modes? */
+	ultra_mask = id->dma_ultra & hwif->ultra_mask;
+
+	if (!(id->field_valid & 4))
+		mode = 0;	/* fallback to MW/SW DMA if no UltraDMA */
+
+	switch (mode) {
+	case 4:
+		if (ultra_mask & 0x40) {
+			speed = XFER_UDMA_6;
+			break;
+		}
+	case 3:
+		if (ultra_mask & 0x20) {
+			speed = XFER_UDMA_5;
+			break;
+		}
+	case 2:
+		if (ultra_mask & 0x10) {
+			speed = XFER_UDMA_4;
+			break;
+		}
+		if (ultra_mask & 0x08) {
+			speed = XFER_UDMA_3;
+			break;
+		}
+	case 1:
+		if (ultra_mask & 0x04) {
+			speed = XFER_UDMA_2;
+			break;
+		}
+		if (ultra_mask & 0x02) {
+			speed = XFER_UDMA_1;
+			break;
+		}
+		if (ultra_mask & 0x01) {
+			speed = XFER_UDMA_0;
+			break;
+		}
+	case 0:
+		mwdma_mask = id->dma_mword & hwif->mwdma_mask;
 
-//	printk("%s: %s: mode 0x%02x, speed 0x%02x\n",
-//		__FUNCTION__, drive->name, mode, speed);
+		if (mwdma_mask & 0x04) {
+			speed = XFER_MW_DMA_2;
+			break;
+		}
+		if (mwdma_mask & 0x02) {
+			speed = XFER_MW_DMA_1;
+			break;
+		}
+		if (mwdma_mask & 0x01) {
+			speed = XFER_MW_DMA_0;
+			break;
+		}
+
+		swdma_mask = id->dma_1word & hwif->swdma_mask;
+
+		if (swdma_mask & 0x04) {
+			speed = XFER_SW_DMA_2;
+			break;
+		}
+		if (swdma_mask & 0x02) {
+			speed = XFER_SW_DMA_1;
+			break;
+		}
+		if (swdma_mask & 0x01) {
+			speed = XFER_SW_DMA_0;
+			break;
+		}
+	}
 
 	return speed;
 }
-
 EXPORT_SYMBOL(ide_dma_speed);
 
 

commit 4aff5e2333c9a1609662f2091f55c3f6fffdad36
Author: Jens Axboe <axboe@suse.de>
Date:   Thu Aug 10 08:44:47 2006 +0200

    [PATCH] Split struct request ->flags into two parts
    
    Right now ->flags is a bit of a mess: some are request types, and
    others are just modifiers. Clean this up by splitting it into
    ->cmd_type and ->cmd_flags. This allows introduction of generic
    Linux block message types, useful for sending generic Linux commands
    to block devices.
    
    Signed-off-by: Jens Axboe <axboe@suse.de>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 1feff23487d4..850ef63cc986 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -456,13 +456,14 @@ static void ide_dump_opcode(ide_drive_t *drive)
 	spin_unlock(&ide_lock);
 	if (!rq)
 		return;
-	if (rq->flags & (REQ_DRIVE_CMD | REQ_DRIVE_TASK)) {
+	if (rq->cmd_type == REQ_TYPE_ATA_CMD ||
+	    rq->cmd_type == REQ_TYPE_ATA_TASK) {
 		char *args = rq->buffer;
 		if (args) {
 			opcode = args[0];
 			found = 1;
 		}
-	} else if (rq->flags & REQ_DRIVE_TASKFILE) {
+	} else if (rq->cmd_type == REQ_TYPE_ATA_TASKFILE) {
 		ide_task_t *args = rq->special;
 		if (args) {
 			task_struct_t *tf = (task_struct_t *) args->tfRegister;

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 7ddb11828731..1feff23487d4 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -1,4 +1,3 @@
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/types.h>
 #include <linux/string.h>

commit 3d1c1cc962cebaae6a70fd89a0adb29ad10a2a12
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jun 26 00:26:17 2006 -0700

    [PATCH] fix IDE deadlock in error reporting code
    
    Michal Piotrowski reported the following validator assert:
    
     hdd: set_drive_speed_status: status=0x51 { DriveReady SeekComplete Error }
     hdd: set_drive_speed_status: error=0xb4 { AbortedCommand LastFailedSense=0x0b }
    
     ============================
     [ BUG: illegal lock usage! ]
     ----------------------------
     illegal {in-hardirq-W} -> {hardirq-on-W} usage.
     hdparm/1821 [HC0[0]:SC0[0]:HE1:SE1] takes:
      (ide_lock){++..}, at: [<c0268388>] ide_dump_opcode+0x13/0x9b
    
     [...]
    
     stack backtrace:
      [<c0104513>] show_trace+0x1b/0x20
      [<c01045f1>] dump_stack+0x1f/0x24
      [<c013976c>] print_usage_bug+0x1a5/0x1b1
      [<c0139e90>] mark_lock+0x2ca/0x4f7
      [<c013aa96>] __lockdep_acquire+0x47e/0xaa4
      [<c013b536>] lockdep_acquire+0x67/0x7f
      [<c030552d>] _spin_lock+0x24/0x32
      [<c0268388>] ide_dump_opcode+0x13/0x9b
      [<c02688b6>] ide_dump_status+0x4a6/0x4cc
      [<c0267ae6>] ide_config_drive_speed+0x32a/0x33a
      [<c0262dc5>] piix_tune_chipset+0x2ed/0x2f8
      [<c0262e31>] piix_config_drive_xfer_rate+0x61/0xb5
      [<c0263a82>] set_using_dma+0x2f/0x60
      [<c0263bee>] ide_write_setting+0x4a/0xc3
      [<c02647ca>] generic_ide_ioctl+0x8a/0x47f
      [<f886003a>] idecd_ioctl+0xfd/0x133 [ide_cd]
      [<c01f1fff>] blkdev_driver_ioctl+0x4b/0x5f
      [<c01f2783>] blkdev_ioctl+0x770/0x7bd
      [<c017dc0d>] block_ioctl+0x1f/0x21
      [<c0189353>] do_ioctl+0x27/0x6e
      [<c0189604>] vfs_ioctl+0x26a/0x280
      [<c0189667>] sys_ioctl+0x4d/0x7e
      [<c0305ed2>] sysenter_past_esp+0x63/0xa1
    
    in ide_dump_opcode() takes the ide_lock in an irq-unsafe manner, i.e.  this
    function expects to be called with irqs disabled.  But
    ide_dump_ata[pi]_status() doesnt do that - it enables interrupts specifically.
     That is a no-no - what guarantees that another IDE port couldnt generate an
    IDE interrupt while we are dumping this error?  The fix is to turn the
    irq-enabling in these functions into irq-disabling.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: Michal Piotrowski <michal.k.k.piotrowski@gmail.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Bartlomiej Zolnierkiewicz <B.Zolnierkiewicz@elka.pw.edu.pl>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 16a143133f93..7ddb11828731 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -485,7 +485,7 @@ static u8 ide_dump_ata_status(ide_drive_t *drive, const char *msg, u8 stat)
 	unsigned long flags;
 	u8 err = 0;
 
-	local_irq_set(flags);
+	local_irq_save(flags);
 	printk("%s: %s: status=0x%02x { ", drive->name, msg, stat);
 	if (stat & BUSY_STAT)
 		printk("Busy ");
@@ -567,7 +567,7 @@ static u8 ide_dump_atapi_status(ide_drive_t *drive, const char *msg, u8 stat)
 
 	status.all = stat;
 	error.all = 0;
-	local_irq_set(flags);
+	local_irq_save(flags);
 	printk("%s: %s: status=0x%02x { ", drive->name, msg, stat);
 	if (status.b.bsy)
 		printk("Busy ");

commit 125e18745f16685f69a34fd6130d47598fc4bf54
Author: Eric Sesterhenn <snakebyte@gmx.de>
Date:   Fri Jun 23 02:06:06 2006 -0700

    [PATCH] More BUG_ON conversion
    
    Signed-off-by: Eric Sesterhenn <snakebyte@gmx.de>
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Bartlomiej Zolnierkiewicz <B.Zolnierkiewicz@elka.pw.edu.pl>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Acked-by: "Salyzyn, Mark" <mark_salyzyn@adaptec.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 41d46dbe6c24..16a143133f93 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -164,8 +164,7 @@ u8 ide_rate_filter (u8 mode, u8 speed)
 //	printk("%s: mode 0x%02x, speed 0x%02x\n", __FUNCTION__, mode, speed);
 
 	/* So that we remember to update this if new modes appear */
-	if (mode > 4)
-		BUG();
+	BUG_ON(mode > 4);
 	return min(speed, speed_max[mode]);
 #else /* !CONFIG_BLK_DEV_IDEDMA */
 	return min(speed, (u8)XFER_PIO_4);

commit 6593178dd46d64a5bcb0402a4f3acd95b0687abd
Author: James Bottomley <jejb@parisc-linux.org>
Date:   Fri Nov 18 23:13:33 2005 +0100

    [PATCH] ide: fix ide_toggle_bounce() to not try to bounce if we have an IOMMU
    
    The following patch fixes a crash caused by attempting to bounce buffer
    when an IDE CD-ROM is used on a machine with an IO-MMU. [At least, this
    patch fixes things so I can use my IDE CD-ROM behind an ns87415 on a
    HP PA-RISC workstation.]
    
    Signed-off-by: James Bottomley <jejb@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index b09a6537c7a8..41d46dbe6c24 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -410,10 +410,10 @@ void ide_toggle_bounce(ide_drive_t *drive, int on)
 {
 	u64 addr = BLK_BOUNCE_HIGH;	/* dma64_addr_t */
 
-	if (on && drive->media == ide_disk) {
-		if (!PCI_DMA_BUS_IS_PHYS)
-			addr = BLK_BOUNCE_ANY;
-		else if (HWIF(drive)->pci_dev)
+	if (!PCI_DMA_BUS_IS_PHYS) {
+		addr = BLK_BOUNCE_ANY;
+	} else if (on && drive->media == ide_disk) {
+		if (HWIF(drive)->pci_dev)
 			addr = HWIF(drive)->pci_dev->dma_mask;
 	}
 

commit 13bbbf28fb914da6707aad44a073651f5c9d13a5
Author: Denis Vlasenko <vda@ilport.com.ua>
Date:   Sun Jul 3 17:09:13 2005 +0200

    [PATCH] ide: fix line break in ide messages
    
    From: Denis Vlasenko <vda@ilport.com.ua>
    
    * printk("\n") is misplaced, resulting in stray empty line in kernel log
    * cleanups nerby: some back-to-back printks are combined, etc
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
index 6806d407e9c1..b09a6537c7a8 100644
--- a/drivers/ide/ide-lib.c
+++ b/drivers/ide/ide-lib.c
@@ -487,8 +487,7 @@ static u8 ide_dump_ata_status(ide_drive_t *drive, const char *msg, u8 stat)
 	u8 err = 0;
 
 	local_irq_set(flags);
-	printk("%s: %s: status=0x%02x", drive->name, msg, stat);
-	printk(" { ");
+	printk("%s: %s: status=0x%02x { ", drive->name, msg, stat);
 	if (stat & BUSY_STAT)
 		printk("Busy ");
 	else {
@@ -500,15 +499,13 @@ static u8 ide_dump_ata_status(ide_drive_t *drive, const char *msg, u8 stat)
 		if (stat & INDEX_STAT)	printk("Index ");
 		if (stat & ERR_STAT)	printk("Error ");
 	}
-	printk("}");
-	printk("\n");
+	printk("}\n");
 	if ((stat & (BUSY_STAT|ERR_STAT)) == ERR_STAT) {
 		err = hwif->INB(IDE_ERROR_REG);
-		printk("%s: %s: error=0x%02x", drive->name, msg, err);
-		printk(" { ");
+		printk("%s: %s: error=0x%02x { ", drive->name, msg, err);
 		if (err & ABRT_ERR)	printk("DriveStatusError ");
 		if (err & ICRC_ERR)
-			printk("Bad%s ", (err & ABRT_ERR) ? "CRC" : "Sector");
+			printk((err & ABRT_ERR) ? "BadCRC " : "BadSector ");
 		if (err & ECC_ERR)	printk("UncorrectableError ");
 		if (err & ID_ERR)	printk("SectorIdNotFound ");
 		if (err & TRK0_ERR)	printk("TrackZeroNotFound ");
@@ -546,8 +543,8 @@ static u8 ide_dump_ata_status(ide_drive_t *drive, const char *msg, u8 stat)
 				printk(", sector=%llu",
 					(unsigned long long)HWGROUP(drive)->rq->sector);
 		}
+		printk("\n");
 	}
-	printk("\n");
 	ide_dump_opcode(drive);
 	local_irq_restore(flags);
 	return err;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
new file mode 100644
index 000000000000..6806d407e9c1
--- /dev/null
+++ b/drivers/ide/ide-lib.c
@@ -0,0 +1,622 @@
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/timer.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/major.h>
+#include <linux/errno.h>
+#include <linux/genhd.h>
+#include <linux/blkpg.h>
+#include <linux/slab.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/hdreg.h>
+#include <linux/ide.h>
+#include <linux/bitops.h>
+
+#include <asm/byteorder.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+/*
+ *	IDE library routines. These are plug in code that most 
+ *	drivers can use but occasionally may be weird enough
+ *	to want to do their own thing with
+ *
+ *	Add common non I/O op stuff here. Make sure it has proper
+ *	kernel-doc function headers or your patch will be rejected
+ */
+ 
+
+/**
+ *	ide_xfer_verbose	-	return IDE mode names
+ *	@xfer_rate: rate to name
+ *
+ *	Returns a constant string giving the name of the mode
+ *	requested.
+ */
+
+char *ide_xfer_verbose (u8 xfer_rate)
+{
+        switch(xfer_rate) {
+                case XFER_UDMA_7:	return("UDMA 7");
+                case XFER_UDMA_6:	return("UDMA 6");
+                case XFER_UDMA_5:	return("UDMA 5");
+                case XFER_UDMA_4:	return("UDMA 4");
+                case XFER_UDMA_3:	return("UDMA 3");
+                case XFER_UDMA_2:	return("UDMA 2");
+                case XFER_UDMA_1:	return("UDMA 1");
+                case XFER_UDMA_0:	return("UDMA 0");
+                case XFER_MW_DMA_2:	return("MW DMA 2");
+                case XFER_MW_DMA_1:	return("MW DMA 1");
+                case XFER_MW_DMA_0:	return("MW DMA 0");
+                case XFER_SW_DMA_2:	return("SW DMA 2");
+                case XFER_SW_DMA_1:	return("SW DMA 1");
+                case XFER_SW_DMA_0:	return("SW DMA 0");
+                case XFER_PIO_4:	return("PIO 4");
+                case XFER_PIO_3:	return("PIO 3");
+                case XFER_PIO_2:	return("PIO 2");
+                case XFER_PIO_1:	return("PIO 1");
+                case XFER_PIO_0:	return("PIO 0");
+                case XFER_PIO_SLOW:	return("PIO SLOW");
+                default:		return("XFER ERROR");
+        }
+}
+
+EXPORT_SYMBOL(ide_xfer_verbose);
+
+/**
+ *	ide_dma_speed	-	compute DMA speed
+ *	@drive: drive
+ *	@mode; intended mode
+ *
+ *	Checks the drive capabilities and returns the speed to use
+ *	for the transfer. Returns -1 if the requested mode is unknown
+ *	(eg PIO)
+ */
+ 
+u8 ide_dma_speed(ide_drive_t *drive, u8 mode)
+{
+	struct hd_driveid *id   = drive->id;
+	ide_hwif_t *hwif	= HWIF(drive);
+	u8 speed = 0;
+
+	if (drive->media != ide_disk && hwif->atapi_dma == 0)
+		return 0;
+
+	switch(mode) {
+		case 0x04:
+			if ((id->dma_ultra & 0x0040) &&
+			    (id->dma_ultra & hwif->ultra_mask))
+				{ speed = XFER_UDMA_6; break; }
+		case 0x03:
+			if ((id->dma_ultra & 0x0020) &&
+			    (id->dma_ultra & hwif->ultra_mask))
+				{ speed = XFER_UDMA_5; break; }
+		case 0x02:
+			if ((id->dma_ultra & 0x0010) &&
+			    (id->dma_ultra & hwif->ultra_mask))
+				{ speed = XFER_UDMA_4; break; }
+			if ((id->dma_ultra & 0x0008) &&
+			    (id->dma_ultra & hwif->ultra_mask))
+				{ speed = XFER_UDMA_3; break; }
+		case 0x01:
+			if ((id->dma_ultra & 0x0004) &&
+			    (id->dma_ultra & hwif->ultra_mask))
+				{ speed = XFER_UDMA_2; break; }
+			if ((id->dma_ultra & 0x0002) &&
+			    (id->dma_ultra & hwif->ultra_mask))
+				{ speed = XFER_UDMA_1; break; }
+			if ((id->dma_ultra & 0x0001) &&
+			    (id->dma_ultra & hwif->ultra_mask))
+				{ speed = XFER_UDMA_0; break; }
+		case 0x00:
+			if ((id->dma_mword & 0x0004) &&
+			    (id->dma_mword & hwif->mwdma_mask))
+				{ speed = XFER_MW_DMA_2; break; }
+			if ((id->dma_mword & 0x0002) &&
+			    (id->dma_mword & hwif->mwdma_mask))
+				{ speed = XFER_MW_DMA_1; break; }
+			if ((id->dma_mword & 0x0001) &&
+			    (id->dma_mword & hwif->mwdma_mask))
+				{ speed = XFER_MW_DMA_0; break; }
+			if ((id->dma_1word & 0x0004) &&
+			    (id->dma_1word & hwif->swdma_mask))
+				{ speed = XFER_SW_DMA_2; break; }
+			if ((id->dma_1word & 0x0002) &&
+			    (id->dma_1word & hwif->swdma_mask))
+				{ speed = XFER_SW_DMA_1; break; }
+			if ((id->dma_1word & 0x0001) &&
+			    (id->dma_1word & hwif->swdma_mask))
+				{ speed = XFER_SW_DMA_0; break; }
+	}
+
+//	printk("%s: %s: mode 0x%02x, speed 0x%02x\n",
+//		__FUNCTION__, drive->name, mode, speed);
+
+	return speed;
+}
+
+EXPORT_SYMBOL(ide_dma_speed);
+
+
+/**
+ *	ide_rate_filter		-	return best speed for mode
+ *	@mode: modes available
+ *	@speed: desired speed
+ *
+ *	Given the available DMA/UDMA mode this function returns
+ *	the best available speed at or below the speed requested.
+ */
+
+u8 ide_rate_filter (u8 mode, u8 speed) 
+{
+#ifdef CONFIG_BLK_DEV_IDEDMA
+	static u8 speed_max[] = {
+		XFER_MW_DMA_2, XFER_UDMA_2, XFER_UDMA_4,
+		XFER_UDMA_5, XFER_UDMA_6
+	};
+
+//	printk("%s: mode 0x%02x, speed 0x%02x\n", __FUNCTION__, mode, speed);
+
+	/* So that we remember to update this if new modes appear */
+	if (mode > 4)
+		BUG();
+	return min(speed, speed_max[mode]);
+#else /* !CONFIG_BLK_DEV_IDEDMA */
+	return min(speed, (u8)XFER_PIO_4);
+#endif /* CONFIG_BLK_DEV_IDEDMA */
+}
+
+EXPORT_SYMBOL(ide_rate_filter);
+
+int ide_dma_enable (ide_drive_t *drive)
+{
+	ide_hwif_t *hwif	= HWIF(drive);
+	struct hd_driveid *id	= drive->id;
+
+	return ((int)	((((id->dma_ultra >> 8) & hwif->ultra_mask) ||
+			  ((id->dma_mword >> 8) & hwif->mwdma_mask) ||
+			  ((id->dma_1word >> 8) & hwif->swdma_mask)) ? 1 : 0));
+}
+
+EXPORT_SYMBOL(ide_dma_enable);
+
+/*
+ * Standard (generic) timings for PIO modes, from ATA2 specification.
+ * These timings are for access to the IDE data port register *only*.
+ * Some drives may specify a mode, while also specifying a different
+ * value for cycle_time (from drive identification data).
+ */
+const ide_pio_timings_t ide_pio_timings[6] = {
+	{ 70,	165,	600 },	/* PIO Mode 0 */
+	{ 50,	125,	383 },	/* PIO Mode 1 */
+	{ 30,	100,	240 },	/* PIO Mode 2 */
+	{ 30,	80,	180 },	/* PIO Mode 3 with IORDY */
+	{ 25,	70,	120 },	/* PIO Mode 4 with IORDY */
+	{ 20,	50,	100 }	/* PIO Mode 5 with IORDY (nonstandard) */
+};
+
+EXPORT_SYMBOL_GPL(ide_pio_timings);
+
+/*
+ * Shared data/functions for determining best PIO mode for an IDE drive.
+ * Most of this stuff originally lived in cmd640.c, and changes to the
+ * ide_pio_blacklist[] table should be made with EXTREME CAUTION to avoid
+ * breaking the fragile cmd640.c support.
+ */
+
+/*
+ * Black list. Some drives incorrectly report their maximal PIO mode,
+ * at least in respect to CMD640. Here we keep info on some known drives.
+ */
+static struct ide_pio_info {
+	const char	*name;
+	int		pio;
+} ide_pio_blacklist [] = {
+/*	{ "Conner Peripherals 1275MB - CFS1275A", 4 }, */
+	{ "Conner Peripherals 540MB - CFS540A", 3 },
+
+	{ "WDC AC2700",  3 },
+	{ "WDC AC2540",  3 },
+	{ "WDC AC2420",  3 },
+	{ "WDC AC2340",  3 },
+	{ "WDC AC2250",  0 },
+	{ "WDC AC2200",  0 },
+	{ "WDC AC21200", 4 },
+	{ "WDC AC2120",  0 },
+	{ "WDC AC2850",  3 },
+	{ "WDC AC1270",  3 },
+	{ "WDC AC1170",  1 },
+	{ "WDC AC1210",  1 },
+	{ "WDC AC280",   0 },
+/*	{ "WDC AC21000", 4 }, */
+	{ "WDC AC31000", 3 },
+	{ "WDC AC31200", 3 },
+/*	{ "WDC AC31600", 4 }, */
+
+	{ "Maxtor 7131 AT", 1 },
+	{ "Maxtor 7171 AT", 1 },
+	{ "Maxtor 7213 AT", 1 },
+	{ "Maxtor 7245 AT", 1 },
+	{ "Maxtor 7345 AT", 1 },
+	{ "Maxtor 7546 AT", 3 },
+	{ "Maxtor 7540 AV", 3 },
+
+	{ "SAMSUNG SHD-3121A", 1 },
+	{ "SAMSUNG SHD-3122A", 1 },
+	{ "SAMSUNG SHD-3172A", 1 },
+
+/*	{ "ST51080A", 4 },
+ *	{ "ST51270A", 4 },
+ *	{ "ST31220A", 4 },
+ *	{ "ST31640A", 4 },
+ *	{ "ST32140A", 4 },
+ *	{ "ST3780A",  4 },
+ */
+	{ "ST5660A",  3 },
+	{ "ST3660A",  3 },
+	{ "ST3630A",  3 },
+	{ "ST3655A",  3 },
+	{ "ST3391A",  3 },
+	{ "ST3390A",  1 },
+	{ "ST3600A",  1 },
+	{ "ST3290A",  0 },
+	{ "ST3144A",  0 },
+	{ "ST3491A",  1 },	/* reports 3, should be 1 or 2 (depending on */	
+				/* drive) according to Seagates FIND-ATA program */
+
+	{ "QUANTUM ELS127A", 0 },
+	{ "QUANTUM ELS170A", 0 },
+	{ "QUANTUM LPS240A", 0 },
+	{ "QUANTUM LPS210A", 3 },
+	{ "QUANTUM LPS270A", 3 },
+	{ "QUANTUM LPS365A", 3 },
+	{ "QUANTUM LPS540A", 3 },
+	{ "QUANTUM LIGHTNING 540A", 3 },
+	{ "QUANTUM LIGHTNING 730A", 3 },
+
+        { "QUANTUM FIREBALL_540", 3 }, /* Older Quantum Fireballs don't work */
+        { "QUANTUM FIREBALL_640", 3 }, 
+        { "QUANTUM FIREBALL_1080", 3 },
+        { "QUANTUM FIREBALL_1280", 3 },
+	{ NULL,	0 }
+};
+
+/**
+ *	ide_scan_pio_blacklist 	-	check for a blacklisted drive
+ *	@model: Drive model string
+ *
+ *	This routine searches the ide_pio_blacklist for an entry
+ *	matching the start/whole of the supplied model name.
+ *
+ *	Returns -1 if no match found.
+ *	Otherwise returns the recommended PIO mode from ide_pio_blacklist[].
+ */
+
+static int ide_scan_pio_blacklist (char *model)
+{
+	struct ide_pio_info *p;
+
+	for (p = ide_pio_blacklist; p->name != NULL; p++) {
+		if (strncmp(p->name, model, strlen(p->name)) == 0)
+			return p->pio;
+	}
+	return -1;
+}
+
+/**
+ *	ide_get_best_pio_mode	-	get PIO mode from drive
+ *	@driver: drive to consider
+ *	@mode_wanted: preferred mode
+ *	@max_mode: highest allowed
+ *	@d: pio data
+ *
+ *	This routine returns the recommended PIO settings for a given drive,
+ *	based on the drive->id information and the ide_pio_blacklist[].
+ *	This is used by most chipset support modules when "auto-tuning".
+ *
+ *	Drive PIO mode auto selection
+ */
+
+u8 ide_get_best_pio_mode (ide_drive_t *drive, u8 mode_wanted, u8 max_mode, ide_pio_data_t *d)
+{
+	int pio_mode;
+	int cycle_time = 0;
+	int use_iordy = 0;
+	struct hd_driveid* id = drive->id;
+	int overridden  = 0;
+	int blacklisted = 0;
+
+	if (mode_wanted != 255) {
+		pio_mode = mode_wanted;
+	} else if (!drive->id) {
+		pio_mode = 0;
+	} else if ((pio_mode = ide_scan_pio_blacklist(id->model)) != -1) {
+		overridden = 1;
+		blacklisted = 1;
+		use_iordy = (pio_mode > 2);
+	} else {
+		pio_mode = id->tPIO;
+		if (pio_mode > 2) {	/* 2 is maximum allowed tPIO value */
+			pio_mode = 2;
+			overridden = 1;
+		}
+		if (id->field_valid & 2) {	  /* drive implements ATA2? */
+			if (id->capability & 8) { /* drive supports use_iordy? */
+				use_iordy = 1;
+				cycle_time = id->eide_pio_iordy;
+				if (id->eide_pio_modes & 7) {
+					overridden = 0;
+					if (id->eide_pio_modes & 4)
+						pio_mode = 5;
+					else if (id->eide_pio_modes & 2)
+						pio_mode = 4;
+					else
+						pio_mode = 3;
+				}
+			} else {
+				cycle_time = id->eide_pio;
+			}
+		}
+
+#if 0
+		if (drive->id->major_rev_num & 0x0004) printk("ATA-2 ");
+#endif
+
+		/*
+		 * Conservative "downgrade" for all pre-ATA2 drives
+		 */
+		if (pio_mode && pio_mode < 4) {
+			pio_mode--;
+			overridden = 1;
+#if 0
+			use_iordy = (pio_mode > 2);
+#endif
+			if (cycle_time && cycle_time < ide_pio_timings[pio_mode].cycle_time)
+				cycle_time = 0; /* use standard timing */
+		}
+	}
+	if (pio_mode > max_mode) {
+		pio_mode = max_mode;
+		cycle_time = 0;
+	}
+	if (d) {
+		d->pio_mode = pio_mode;
+		d->cycle_time = cycle_time ? cycle_time : ide_pio_timings[pio_mode].cycle_time;
+		d->use_iordy = use_iordy;
+		d->overridden = overridden;
+		d->blacklisted = blacklisted;
+	}
+	return pio_mode;
+}
+
+EXPORT_SYMBOL_GPL(ide_get_best_pio_mode);
+
+/**
+ *	ide_toggle_bounce	-	handle bounce buffering
+ *	@drive: drive to update
+ *	@on: on/off boolean
+ *
+ *	Enable or disable bounce buffering for the device. Drives move
+ *	between PIO and DMA and that changes the rules we need.
+ */
+ 
+void ide_toggle_bounce(ide_drive_t *drive, int on)
+{
+	u64 addr = BLK_BOUNCE_HIGH;	/* dma64_addr_t */
+
+	if (on && drive->media == ide_disk) {
+		if (!PCI_DMA_BUS_IS_PHYS)
+			addr = BLK_BOUNCE_ANY;
+		else if (HWIF(drive)->pci_dev)
+			addr = HWIF(drive)->pci_dev->dma_mask;
+	}
+
+	if (drive->queue)
+		blk_queue_bounce_limit(drive->queue, addr);
+}
+
+/**
+ *	ide_set_xfer_rate	-	set transfer rate
+ *	@drive: drive to set
+ *	@speed: speed to attempt to set
+ *	
+ *	General helper for setting the speed of an IDE device. This
+ *	function knows about user enforced limits from the configuration
+ *	which speedproc() does not.  High level drivers should never
+ *	invoke speedproc() directly.
+ */
+ 
+int ide_set_xfer_rate(ide_drive_t *drive, u8 rate)
+{
+#ifndef CONFIG_BLK_DEV_IDEDMA
+	rate = min(rate, (u8) XFER_PIO_4);
+#endif
+	if(HWIF(drive)->speedproc)
+		return HWIF(drive)->speedproc(drive, rate);
+	else
+		return -1;
+}
+
+EXPORT_SYMBOL_GPL(ide_set_xfer_rate);
+
+static void ide_dump_opcode(ide_drive_t *drive)
+{
+	struct request *rq;
+	u8 opcode = 0;
+	int found = 0;
+
+	spin_lock(&ide_lock);
+	rq = NULL;
+	if (HWGROUP(drive))
+		rq = HWGROUP(drive)->rq;
+	spin_unlock(&ide_lock);
+	if (!rq)
+		return;
+	if (rq->flags & (REQ_DRIVE_CMD | REQ_DRIVE_TASK)) {
+		char *args = rq->buffer;
+		if (args) {
+			opcode = args[0];
+			found = 1;
+		}
+	} else if (rq->flags & REQ_DRIVE_TASKFILE) {
+		ide_task_t *args = rq->special;
+		if (args) {
+			task_struct_t *tf = (task_struct_t *) args->tfRegister;
+			opcode = tf->command;
+			found = 1;
+		}
+	}
+
+	printk("ide: failed opcode was: ");
+	if (!found)
+		printk("unknown\n");
+	else
+		printk("0x%02x\n", opcode);
+}
+
+static u8 ide_dump_ata_status(ide_drive_t *drive, const char *msg, u8 stat)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	unsigned long flags;
+	u8 err = 0;
+
+	local_irq_set(flags);
+	printk("%s: %s: status=0x%02x", drive->name, msg, stat);
+	printk(" { ");
+	if (stat & BUSY_STAT)
+		printk("Busy ");
+	else {
+		if (stat & READY_STAT)	printk("DriveReady ");
+		if (stat & WRERR_STAT)	printk("DeviceFault ");
+		if (stat & SEEK_STAT)	printk("SeekComplete ");
+		if (stat & DRQ_STAT)	printk("DataRequest ");
+		if (stat & ECC_STAT)	printk("CorrectedError ");
+		if (stat & INDEX_STAT)	printk("Index ");
+		if (stat & ERR_STAT)	printk("Error ");
+	}
+	printk("}");
+	printk("\n");
+	if ((stat & (BUSY_STAT|ERR_STAT)) == ERR_STAT) {
+		err = hwif->INB(IDE_ERROR_REG);
+		printk("%s: %s: error=0x%02x", drive->name, msg, err);
+		printk(" { ");
+		if (err & ABRT_ERR)	printk("DriveStatusError ");
+		if (err & ICRC_ERR)
+			printk("Bad%s ", (err & ABRT_ERR) ? "CRC" : "Sector");
+		if (err & ECC_ERR)	printk("UncorrectableError ");
+		if (err & ID_ERR)	printk("SectorIdNotFound ");
+		if (err & TRK0_ERR)	printk("TrackZeroNotFound ");
+		if (err & MARK_ERR)	printk("AddrMarkNotFound ");
+		printk("}");
+		if ((err & (BBD_ERR | ABRT_ERR)) == BBD_ERR ||
+		    (err & (ECC_ERR|ID_ERR|MARK_ERR))) {
+			if (drive->addressing == 1) {
+				__u64 sectors = 0;
+				u32 low = 0, high = 0;
+				low = ide_read_24(drive);
+				hwif->OUTB(drive->ctl|0x80, IDE_CONTROL_REG);
+				high = ide_read_24(drive);
+				sectors = ((__u64)high << 24) | low;
+				printk(", LBAsect=%llu, high=%d, low=%d",
+				       (unsigned long long) sectors,
+				       high, low);
+			} else {
+				u8 cur = hwif->INB(IDE_SELECT_REG);
+				if (cur & 0x40) {	/* using LBA? */
+					printk(", LBAsect=%ld", (unsigned long)
+					 ((cur&0xf)<<24)
+					 |(hwif->INB(IDE_HCYL_REG)<<16)
+					 |(hwif->INB(IDE_LCYL_REG)<<8)
+					 | hwif->INB(IDE_SECTOR_REG));
+				} else {
+					printk(", CHS=%d/%d/%d",
+					 (hwif->INB(IDE_HCYL_REG)<<8) +
+					  hwif->INB(IDE_LCYL_REG),
+					  cur & 0xf,
+					  hwif->INB(IDE_SECTOR_REG));
+				}
+			}
+			if (HWGROUP(drive) && HWGROUP(drive)->rq)
+				printk(", sector=%llu",
+					(unsigned long long)HWGROUP(drive)->rq->sector);
+		}
+	}
+	printk("\n");
+	ide_dump_opcode(drive);
+	local_irq_restore(flags);
+	return err;
+}
+
+/**
+ *	ide_dump_atapi_status       -       print human readable atapi status
+ *	@drive: drive that status applies to
+ *	@msg: text message to print
+ *	@stat: status byte to decode
+ *
+ *	Error reporting, in human readable form (luxurious, but a memory hog).
+ */
+
+static u8 ide_dump_atapi_status(ide_drive_t *drive, const char *msg, u8 stat)
+{
+	unsigned long flags;
+
+	atapi_status_t status;
+	atapi_error_t error;
+
+	status.all = stat;
+	error.all = 0;
+	local_irq_set(flags);
+	printk("%s: %s: status=0x%02x { ", drive->name, msg, stat);
+	if (status.b.bsy)
+		printk("Busy ");
+	else {
+		if (status.b.drdy)	printk("DriveReady ");
+		if (status.b.df)	printk("DeviceFault ");
+		if (status.b.dsc)	printk("SeekComplete ");
+		if (status.b.drq)	printk("DataRequest ");
+		if (status.b.corr)	printk("CorrectedError ");
+		if (status.b.idx)	printk("Index ");
+		if (status.b.check)	printk("Error ");
+	}
+	printk("}\n");
+	if (status.b.check && !status.b.bsy) {
+		error.all = HWIF(drive)->INB(IDE_ERROR_REG);
+		printk("%s: %s: error=0x%02x { ", drive->name, msg, error.all);
+		if (error.b.ili)	printk("IllegalLengthIndication ");
+		if (error.b.eom)	printk("EndOfMedia ");
+		if (error.b.abrt)	printk("AbortedCommand ");
+		if (error.b.mcr)	printk("MediaChangeRequested ");
+		if (error.b.sense_key)	printk("LastFailedSense=0x%02x ",
+						error.b.sense_key);
+		printk("}\n");
+	}
+	ide_dump_opcode(drive);
+	local_irq_restore(flags);
+	return error.all;
+}
+
+/**
+ *	ide_dump_status		-	translate ATA/ATAPI error
+ *	@drive: drive the error occured on
+ *	@msg: information string
+ *	@stat: status byte
+ *
+ *	Error reporting, in human readable form (luxurious, but a memory hog).
+ *	Combines the drive name, message and status byte to provide a
+ *	user understandable explanation of the device error.
+ */
+
+u8 ide_dump_status(ide_drive_t *drive, const char *msg, u8 stat)
+{
+	if (drive->media == ide_disk)
+		return ide_dump_ata_status(drive, msg, stat);
+	return ide_dump_atapi_status(drive, msg, stat);
+}
+
+EXPORT_SYMBOL(ide_dump_status);
