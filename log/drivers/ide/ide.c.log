commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 6ee866fcc5dd..9a9c64fd1032 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  Copyright (C) 1994-1998	    Linus Torvalds & authors (see below)
  *  Copyright (C) 2003-2005, 2007   Bartlomiej Zolnierkiewicz

commit e4dca7b7aa08b22893c45485d222b5807c1375ae
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Oct 17 19:04:42 2017 -0700

    treewide: Fix function prototypes for module_param_call()
    
    Several function prototypes for the set/get functions defined by
    module_param_call() have a slightly wrong argument types. This fixes
    those in an effort to clean up the calls when running under type-enforced
    compiler instrumentation for CFI. This is the result of running the
    following semantic patch:
    
    @match_module_param_call_function@
    declarer name module_param_call;
    identifier _name, _set_func, _get_func;
    expression _arg, _mode;
    @@
    
     module_param_call(_name, _set_func, _get_func, _arg, _mode);
    
    @fix_set_prototype
     depends on match_module_param_call_function@
    identifier match_module_param_call_function._set_func;
    identifier _val, _param;
    type _val_type, _param_type;
    @@
    
     int _set_func(
    -_val_type _val
    +const char * _val
     ,
    -_param_type _param
    +const struct kernel_param * _param
     ) { ... }
    
    @fix_get_prototype
     depends on match_module_param_call_function@
    identifier match_module_param_call_function._get_func;
    identifier _val, _param;
    type _val_type, _param_type;
    @@
    
     int _get_func(
    -_val_type _val
    +char * _val
     ,
    -_param_type _param
    +const struct kernel_param * _param
     ) { ... }
    
    Two additional by-hand changes are included for places where the above
    Coccinelle script didn't notice them:
    
            drivers/platform/x86/thinkpad_acpi.c
            fs/lockd/svc.c
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index d127ace6aa57..6ee866fcc5dd 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -244,7 +244,7 @@ struct chs_geom {
 static unsigned int ide_disks;
 static struct chs_geom ide_disks_chs[MAX_HWIFS * MAX_DRIVES];
 
-static int ide_set_disk_chs(const char *str, struct kernel_param *kp)
+static int ide_set_disk_chs(const char *str, const struct kernel_param *kp)
 {
 	unsigned int a, b, c = 0, h = 0, s = 0, i, j = 1;
 
@@ -328,7 +328,7 @@ static void ide_dev_apply_params(ide_drive_t *drive, u8 unit)
 
 static unsigned int ide_ignore_cable;
 
-static int ide_set_ignore_cable(const char *s, struct kernel_param *kp)
+static int ide_set_ignore_cable(const char *s, const struct kernel_param *kp)
 {
 	int i, j = 1;
 

commit 0860bf94712f34f5920193004dfed25408f078b1
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Nov 13 17:34:01 2015 +0300

    ide: silence some underflow warnings
    
    Back in the day we used to just say this code was root only so it was
    ok that the bounds checking was sloppy.  These days it annoys static
    checkers so we fix it.
    
    In the original code "c > INT_MAX" was never true since "c" was an int.
    I am not sure what was intended so I left it alone.  But because I made
    "c" unsigned it means we don't have a warning any more.
    
    The second warning is that we cap "i" but allow negatives leading to an
    underflow of the ide_disks_chs[] array.  The third set of warnings is
    because these values come from the user and we cap most of the upper
    bounds but allow negative values.  Negative cylinders doesn't make
    sense.
    
    drivers/ide/ide.c:262 ide_set_disk_chs() warn: impossible condition '(c > ((~0 >> 1))) => (s32min-s32max > s32max)'
    drivers/ide/ide.c:270 ide_set_disk_chs() warn: check 'ide_disks_chs[i]' for negative offsets 'i' = s32min.  extra = 's32min-19'
    drivers/ide/ide.c:271 ide_set_disk_chs() warn: no lower bound on 'h'
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index f086ef387475..d127ace6aa57 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -178,17 +178,17 @@ MODULE_PARM_DESC(pci_clock, "PCI bus clock frequency (in MHz)");
 
 static int ide_set_dev_param_mask(const char *s, const struct kernel_param *kp)
 {
-	int a, b, i, j = 1;
+	unsigned int a, b, i, j = 1;
 	unsigned int *dev_param_mask = (unsigned int *)kp->arg;
 
 	/* controller . device (0 or 1) [ : 1 (set) | 0 (clear) ] */
-	if (sscanf(s, "%d.%d:%d", &a, &b, &j) != 3 &&
-	    sscanf(s, "%d.%d", &a, &b) != 2)
+	if (sscanf(s, "%u.%u:%u", &a, &b, &j) != 3 &&
+	    sscanf(s, "%u.%u", &a, &b) != 2)
 		return -EINVAL;
 
 	i = a * MAX_DRIVES + b;
 
-	if (i >= MAX_HWIFS * MAX_DRIVES || j < 0 || j > 1)
+	if (i >= MAX_HWIFS * MAX_DRIVES || j > 1)
 		return -EINVAL;
 
 	if (j)
@@ -246,17 +246,17 @@ static struct chs_geom ide_disks_chs[MAX_HWIFS * MAX_DRIVES];
 
 static int ide_set_disk_chs(const char *str, struct kernel_param *kp)
 {
-	int a, b, c = 0, h = 0, s = 0, i, j = 1;
+	unsigned int a, b, c = 0, h = 0, s = 0, i, j = 1;
 
 	/* controller . device (0 or 1) : Cylinders , Heads , Sectors */
 	/* controller . device (0 or 1) : 1 (use CHS) | 0 (ignore CHS) */
-	if (sscanf(str, "%d.%d:%d,%d,%d", &a, &b, &c, &h, &s) != 5 &&
-	    sscanf(str, "%d.%d:%d", &a, &b, &j) != 3)
+	if (sscanf(str, "%u.%u:%u,%u,%u", &a, &b, &c, &h, &s) != 5 &&
+	    sscanf(str, "%u.%u:%u", &a, &b, &j) != 3)
 		return -EINVAL;
 
 	i = a * MAX_DRIVES + b;
 
-	if (i >= MAX_HWIFS * MAX_DRIVES || j < 0 || j > 1)
+	if (i >= MAX_HWIFS * MAX_DRIVES || j > 1)
 		return -EINVAL;
 
 	if (c > INT_MAX || h > 255 || s > 255)

commit 9c27847dda9cfae7c273cde62becf364f9fa9ea3
Author: Luis R. Rodriguez <mcgrof@suse.com>
Date:   Wed May 27 11:09:38 2015 +0930

    kernel/params: constify struct kernel_param_ops uses
    
    Most code already uses consts for the struct kernel_param_ops,
    sweep the kernel for the last offending stragglers. Other than
    include/linux/moduleparam.h and kernel/params.c all other changes
    were generated with the following Coccinelle SmPL patch. Merge
    conflicts between trees can be handled with Coccinelle.
    
    In the future git could get Coccinelle merge support to deal with
    patch --> fail --> grammar --> Coccinelle --> new patch conflicts
    automatically for us on patches where the grammar is available and
    the patch is of high confidence. Consider this a feature request.
    
    Test compiled on x86_64 against:
    
            * allnoconfig
            * allmodconfig
            * allyesconfig
    
    @ const_found @
    identifier ops;
    @@
    
    const struct kernel_param_ops ops = {
    };
    
    @ const_not_found depends on !const_found @
    identifier ops;
    @@
    
    -struct kernel_param_ops ops = {
    +const struct kernel_param_ops ops = {
    };
    
    Generated-by: Coccinelle SmPL
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Junio C Hamano <gitster@pobox.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: cocci@systeme.lip6.fr
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Luis R. Rodriguez <mcgrof@suse.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index e29b02ca9e91..f086ef387475 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -199,7 +199,7 @@ static int ide_set_dev_param_mask(const char *s, const struct kernel_param *kp)
 	return 0;
 }
 
-static struct kernel_param_ops param_ops_ide_dev_mask = {
+static const struct kernel_param_ops param_ops_ide_dev_mask = {
 	.set = ide_set_dev_param_mask
 };
 

commit 1746fbe5656b1b10064913b9293a4590ec0b7f27
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Fri Nov 21 20:22:32 2014 +0100

    IDE: Deletion of an unnecessary check before the function call "module_put"
    
    The module_put() function tests whether its argument is NULL and then
    returns immediately. Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 2ce6268a2734..e29b02ca9e91 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -101,8 +101,7 @@ void ide_device_put(ide_drive_t *drive)
 	struct device *host_dev = drive->hwif->host->dev[0];
 	struct module *module = host_dev ? host_dev->driver->owner : NULL;
 
-	if (module)
-		module_put(module);
+	module_put(module);
 #endif
 	put_device(&drive->gendev);
 }

commit fb3fed7926545e44ce36574e1b1c5cdeb018db5c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Oct 7 18:27:35 2013 -0700

    ide: convert bus code to use dev_groups
    
    The dev_attrs field of struct bus_type is going away soon, dev_groups
    should be used instead.  This converts the ide bus code to use the
    correct field.
    
    Acked-by: David S. Miller <davem@davemloft.net>
    Cc: <linux-ide@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index fa896210ed7b..2ce6268a2734 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -158,7 +158,7 @@ struct bus_type ide_bus_type = {
 	.probe		= generic_ide_probe,
 	.remove		= generic_ide_remove,
 	.shutdown	= generic_ide_shutdown,
-	.dev_attrs	= ide_dev_attrs,
+	.dev_groups	= ide_dev_groups,
 	.suspend	= generic_ide_suspend,
 	.resume		= generic_ide_resume,
 };

commit 1a8bff5b404909436fcf03cac167a76ceaaa5547
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Wed Aug 11 23:04:38 2010 -0600

    ide: use module_param_named rather than module_param_call
    
    It has the additional benefit of typechecking (in this case, an unsigned int).
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 3cb9c4e056ff..fa896210ed7b 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -177,7 +177,7 @@ EXPORT_SYMBOL_GPL(ide_pci_clk);
 module_param_named(pci_clock, ide_pci_clk, int, 0);
 MODULE_PARM_DESC(pci_clock, "PCI bus clock frequency (in MHz)");
 
-static int ide_set_dev_param_mask(const char *s, struct kernel_param *kp)
+static int ide_set_dev_param_mask(const char *s, const struct kernel_param *kp)
 {
 	int a, b, i, j = 1;
 	unsigned int *dev_param_mask = (unsigned int *)kp->arg;
@@ -200,34 +200,40 @@ static int ide_set_dev_param_mask(const char *s, struct kernel_param *kp)
 	return 0;
 }
 
+static struct kernel_param_ops param_ops_ide_dev_mask = {
+	.set = ide_set_dev_param_mask
+};
+
+#define param_check_ide_dev_mask(name, p) param_check_uint(name, p)
+
 static unsigned int ide_nodma;
 
-module_param_call(nodma, ide_set_dev_param_mask, NULL, &ide_nodma, 0);
+module_param_named(nodma, ide_nodma, ide_dev_mask, 0);
 MODULE_PARM_DESC(nodma, "disallow DMA for a device");
 
 static unsigned int ide_noflush;
 
-module_param_call(noflush, ide_set_dev_param_mask, NULL, &ide_noflush, 0);
+module_param_named(noflush, ide_noflush, ide_dev_mask, 0);
 MODULE_PARM_DESC(noflush, "disable flush requests for a device");
 
 static unsigned int ide_nohpa;
 
-module_param_call(nohpa, ide_set_dev_param_mask, NULL, &ide_nohpa, 0);
+module_param_named(nohpa, ide_nohpa, ide_dev_mask, 0);
 MODULE_PARM_DESC(nohpa, "disable Host Protected Area for a device");
 
 static unsigned int ide_noprobe;
 
-module_param_call(noprobe, ide_set_dev_param_mask, NULL, &ide_noprobe, 0);
+module_param_named(noprobe, ide_noprobe, ide_dev_mask, 0);
 MODULE_PARM_DESC(noprobe, "skip probing for a device");
 
 static unsigned int ide_nowerr;
 
-module_param_call(nowerr, ide_set_dev_param_mask, NULL, &ide_nowerr, 0);
+module_param_named(nowerr, ide_nowerr, ide_dev_mask, 0);
 MODULE_PARM_DESC(nowerr, "ignore the ATA_DF bit for a device");
 
 static unsigned int ide_cdroms;
 
-module_param_call(cdrom, ide_set_dev_param_mask, NULL, &ide_cdroms, 0);
+module_param_named(cdrom, ide_cdroms, ide_dev_mask, 0);
 MODULE_PARM_DESC(cdrom, "force device as a CD-ROM");
 
 struct chs_geom {

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 16d056939f9f..3cb9c4e056ff 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -52,7 +52,6 @@
 #include <linux/major.h>
 #include <linux/errno.h>
 #include <linux/genhd.h>
-#include <linux/slab.h>
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/ide.h>

commit 075affcbe01d4d7cefcd0e30a98df1253bcf8d92
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sun Jun 7 13:52:52 2009 +0200

    ide: preserve Host Protected Area by default (v2)
    
    From the perspective of most users of recent systems, disabling Host
    Protected Area (HPA) can break vendor RAID formats, GPT partitions and
    risks corrupting firmware or overwriting vendor system recovery tools.
    
    Unfortunately the original (kernels < 2.6.30) behavior (unconditionally
    disabling HPA and using full disk capacity) was introduced at the time
    when the main use of HPA was to make the drive look small enough for the
    BIOS to allow the system to boot with large capacity drives.
    
    Thus to allow the maximum compatibility with the existing setups (using
    HPA and partitioned with HPA disabled) we automically disable HPA if
    any partitions overlapping HPA are detected.  Additionally HPA can also
    be disabled using the "nohpa" module parameter (i.e. "ide_core.nohpa=0.0"
    to disable HPA on /dev/hda).
    
    v2:
    Fix ->resume HPA support.
    
    While at it:
    - remove stale "idebus=" entry from Documentation/kernel-parameters.txt
    
    Cc: Robert Hancock <hancockrwd@gmail.com>
    Cc: Frans Pop <elendil@planet.nl>
    Cc: "Andries E. Brouwer" <Andries.Brouwer@cwi.nl>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    [patch description was based on input from Alan Cox and Frans Pop]
    Emphatically-Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 92c9b90931e7..16d056939f9f 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -211,6 +211,11 @@ static unsigned int ide_noflush;
 module_param_call(noflush, ide_set_dev_param_mask, NULL, &ide_noflush, 0);
 MODULE_PARM_DESC(noflush, "disable flush requests for a device");
 
+static unsigned int ide_nohpa;
+
+module_param_call(nohpa, ide_set_dev_param_mask, NULL, &ide_nohpa, 0);
+MODULE_PARM_DESC(nohpa, "disable Host Protected Area for a device");
+
 static unsigned int ide_noprobe;
 
 module_param_call(noprobe, ide_set_dev_param_mask, NULL, &ide_noprobe, 0);
@@ -281,6 +286,11 @@ static void ide_dev_apply_params(ide_drive_t *drive, u8 unit)
 				 drive->name);
 		drive->dev_flags |= IDE_DFLAG_NOFLUSH;
 	}
+	if (ide_nohpa & (1 << i)) {
+		printk(KERN_INFO "ide: disabling Host Protected Area for %s\n",
+				 drive->name);
+		drive->dev_flags |= IDE_DFLAG_NOHPA;
+	}
 	if (ide_noprobe & (1 << i)) {
 		printk(KERN_INFO "ide: skipping probe for %s\n", drive->name);
 		drive->dev_flags |= IDE_DFLAG_NOPROBE;

commit 11938c929022bb92b1a42f5e1289524a1e465dc0
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Mar 24 23:22:44 2009 +0100

    ide: move device settings code to ide-devsets.c
    
    Remove stale comment from ide.c while at it.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index c779aa24dbe6..92c9b90931e7 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -62,160 +62,6 @@
 
 struct class *ide_port_class;
 
-/*
- *	Locks for IDE setting functionality
- */
-
-DEFINE_MUTEX(ide_setting_mtx);
-
-ide_devset_get(io_32bit, io_32bit);
-
-static int set_io_32bit(ide_drive_t *drive, int arg)
-{
-	if (drive->dev_flags & IDE_DFLAG_NO_IO_32BIT)
-		return -EPERM;
-
-	if (arg < 0 || arg > 1 + (SUPPORT_VLB_SYNC << 1))
-		return -EINVAL;
-
-	drive->io_32bit = arg;
-
-	return 0;
-}
-
-ide_devset_get_flag(ksettings, IDE_DFLAG_KEEP_SETTINGS);
-
-static int set_ksettings(ide_drive_t *drive, int arg)
-{
-	if (arg < 0 || arg > 1)
-		return -EINVAL;
-
-	if (arg)
-		drive->dev_flags |= IDE_DFLAG_KEEP_SETTINGS;
-	else
-		drive->dev_flags &= ~IDE_DFLAG_KEEP_SETTINGS;
-
-	return 0;
-}
-
-ide_devset_get_flag(using_dma, IDE_DFLAG_USING_DMA);
-
-static int set_using_dma(ide_drive_t *drive, int arg)
-{
-#ifdef CONFIG_BLK_DEV_IDEDMA
-	int err = -EPERM;
-
-	if (arg < 0 || arg > 1)
-		return -EINVAL;
-
-	if (ata_id_has_dma(drive->id) == 0)
-		goto out;
-
-	if (drive->hwif->dma_ops == NULL)
-		goto out;
-
-	err = 0;
-
-	if (arg) {
-		if (ide_set_dma(drive))
-			err = -EIO;
-	} else
-		ide_dma_off(drive);
-
-out:
-	return err;
-#else
-	if (arg < 0 || arg > 1)
-		return -EINVAL;
-
-	return -EPERM;
-#endif
-}
-
-/*
- * handle HDIO_SET_PIO_MODE ioctl abusers here, eventually it will go away
- */
-static int set_pio_mode_abuse(ide_hwif_t *hwif, u8 req_pio)
-{
-	switch (req_pio) {
-	case 202:
-	case 201:
-	case 200:
-	case 102:
-	case 101:
-	case 100:
-		return (hwif->host_flags & IDE_HFLAG_ABUSE_DMA_MODES) ? 1 : 0;
-	case 9:
-	case 8:
-		return (hwif->host_flags & IDE_HFLAG_ABUSE_PREFETCH) ? 1 : 0;
-	case 7:
-	case 6:
-		return (hwif->host_flags & IDE_HFLAG_ABUSE_FAST_DEVSEL) ? 1 : 0;
-	default:
-		return 0;
-	}
-}
-
-static int set_pio_mode(ide_drive_t *drive, int arg)
-{
-	ide_hwif_t *hwif = drive->hwif;
-	const struct ide_port_ops *port_ops = hwif->port_ops;
-
-	if (arg < 0 || arg > 255)
-		return -EINVAL;
-
-	if (port_ops == NULL || port_ops->set_pio_mode == NULL ||
-	    (hwif->host_flags & IDE_HFLAG_NO_SET_MODE))
-		return -ENOSYS;
-
-	if (set_pio_mode_abuse(drive->hwif, arg)) {
-		if (arg == 8 || arg == 9) {
-			unsigned long flags;
-
-			/* take lock for IDE_DFLAG_[NO_]UNMASK/[NO_]IO_32BIT */
-			spin_lock_irqsave(&hwif->lock, flags);
-			port_ops->set_pio_mode(drive, arg);
-			spin_unlock_irqrestore(&hwif->lock, flags);
-		} else
-			port_ops->set_pio_mode(drive, arg);
-	} else {
-		int keep_dma = !!(drive->dev_flags & IDE_DFLAG_USING_DMA);
-
-		ide_set_pio(drive, arg);
-
-		if (hwif->host_flags & IDE_HFLAG_SET_PIO_MODE_KEEP_DMA) {
-			if (keep_dma)
-				ide_dma_on(drive);
-		}
-	}
-
-	return 0;
-}
-
-ide_devset_get_flag(unmaskirq, IDE_DFLAG_UNMASK);
-
-static int set_unmaskirq(ide_drive_t *drive, int arg)
-{
-	if (drive->dev_flags & IDE_DFLAG_NO_UNMASK)
-		return -EPERM;
-
-	if (arg < 0 || arg > 1)
-		return -EINVAL;
-
-	if (arg)
-		drive->dev_flags |= IDE_DFLAG_UNMASK;
-	else
-		drive->dev_flags &= ~IDE_DFLAG_UNMASK;
-
-	return 0;
-}
-
-ide_ext_devset_rw_sync(io_32bit, io_32bit);
-ide_ext_devset_rw_sync(keepsettings, ksettings);
-ide_ext_devset_rw_sync(unmaskirq, unmaskirq);
-ide_ext_devset_rw_sync(using_dma, using_dma);
-__IDE_DEVSET(pio_mode, DS_SYNC, NULL, set_pio_mode);
-
 /**
  * ide_device_get	-	get an additional reference to a ide_drive_t
  * @drive:	device to get a reference to

commit 8b803bd184e3f6892284d4b50801b9ec85cd9b96
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Mar 24 23:22:41 2009 +0100

    ide: sanitize ACPI initialization
    
    * ide_acpi_init() -> ide_acpi_init_port()
    
    * ide_acpi_blacklist() -> ide_acpi_init()
    
    * Call ide_acpi_init() only once (do it during IDE core
      initialization) and cleanup the function accordingly.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 0920e3b0c962..c779aa24dbe6 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -527,6 +527,8 @@ static int __init ide_init(void)
 		goto out_port_class;
 	}
 
+	ide_acpi_init();
+
 	proc_ide_create();
 
 	return 0;

commit 0af80c04e2f2e45ae09fceb17df8050f828a5c40
Author: David Fries <david@fries.net>
Date:   Wed Feb 25 20:28:21 2009 +0100

    ide: ide.c 'clear' fix, update "ide=nodma" documentation
    
    Documentation/kernel-parameters.txt
    - ide=nodma is no longer valid.
    
    drivers/ide/Kconfig
    - The module is ide-core.ko not ide.
    
    drivers/ide/ide.c
    - It took me a while to figure out what the arguments %d.%d:%d to nodma
      module parameter ment, so I added a comment to each.
    - Added a comment to each of the sscanf lines.
    - There is a bug, if j is 0 it would previously clear all the other bits
      except the current device, changed in three different places.
      mask &= (1 << i) should be mask &= ~(1 << i).
    
    Signed-off-by: David Fries <david@fries.net>
    [bart: s/disk/device/ in ide.c, beautify patch description]
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 258805da15c3..0920e3b0c962 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -337,6 +337,7 @@ static int ide_set_dev_param_mask(const char *s, struct kernel_param *kp)
 	int a, b, i, j = 1;
 	unsigned int *dev_param_mask = (unsigned int *)kp->arg;
 
+	/* controller . device (0 or 1) [ : 1 (set) | 0 (clear) ] */
 	if (sscanf(s, "%d.%d:%d", &a, &b, &j) != 3 &&
 	    sscanf(s, "%d.%d", &a, &b) != 2)
 		return -EINVAL;
@@ -349,7 +350,7 @@ static int ide_set_dev_param_mask(const char *s, struct kernel_param *kp)
 	if (j)
 		*dev_param_mask |= (1 << i);
 	else
-		*dev_param_mask &= (1 << i);
+		*dev_param_mask &= ~(1 << i);
 
 	return 0;
 }
@@ -392,6 +393,8 @@ static int ide_set_disk_chs(const char *str, struct kernel_param *kp)
 {
 	int a, b, c = 0, h = 0, s = 0, i, j = 1;
 
+	/* controller . device (0 or 1) : Cylinders , Heads , Sectors */
+	/* controller . device (0 or 1) : 1 (use CHS) | 0 (ignore CHS) */
 	if (sscanf(str, "%d.%d:%d,%d,%d", &a, &b, &c, &h, &s) != 5 &&
 	    sscanf(str, "%d.%d:%d", &a, &b, &j) != 3)
 		return -EINVAL;
@@ -407,7 +410,7 @@ static int ide_set_disk_chs(const char *str, struct kernel_param *kp)
 	if (j)
 		ide_disks |= (1 << i);
 	else
-		ide_disks &= (1 << i);
+		ide_disks &= ~(1 << i);
 
 	ide_disks_chs[i].cyl  = c;
 	ide_disks_chs[i].head = h;
@@ -469,6 +472,8 @@ static int ide_set_ignore_cable(const char *s, struct kernel_param *kp)
 {
 	int i, j = 1;
 
+	/* controller (ignore) */
+	/* controller : 1 (ignore) | 0 (use) */
 	if (sscanf(s, "%d:%d", &i, &j) != 2 && sscanf(s, "%d", &i) != 1)
 		return -EINVAL;
 
@@ -478,7 +483,7 @@ static int ide_set_ignore_cable(const char *s, struct kernel_param *kp)
 	if (j)
 		ide_ignore_cable |= (1 << i);
 	else
-		ide_ignore_cable &= (1 << i);
+		ide_ignore_cable &= ~(1 << i);
 
 	return 0;
 }

commit 2bd24a1cfc99d242c2cff9a6b74ca49fcaac3fb6
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jan 6 17:20:56 2009 +0100

    ide: add port and host iterators
    
    Add ide_port_for_each_dev() / ide_host_for_each_port() iterators
    and update IDE code to use them.
    
    While at it:
    - s/unit/i/ variable in ide_port_wait_ready(), ide_probe_port(),
      ide_port_tune_devices(), ide_port_init_devices_data(), do_reset1(),
      ide_acpi_set_state() and scc_dma_end()
    - s/d/i/ variable in ide_proc_port_register_devices()
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 8a6f893d127e..258805da15c3 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -488,6 +488,7 @@ MODULE_PARM_DESC(ignore_cable, "ignore cable detection");
 
 void ide_port_apply_params(ide_hwif_t *hwif)
 {
+	ide_drive_t *drive;
 	int i;
 
 	if (ide_ignore_cable & (1 << hwif->index)) {
@@ -496,8 +497,8 @@ void ide_port_apply_params(ide_hwif_t *hwif)
 		hwif->cbl = ATA_CBL_PATA40_SHORT;
 	}
 
-	for (i = 0; i < MAX_DRIVES; i++)
-		ide_dev_apply_params(hwif->devices[i], i);
+	ide_port_for_each_dev(i, drive, hwif)
+		ide_dev_apply_params(drive, i);
 }
 
 /*

commit 5e7f3a46690f7f6c9f2781c700ab4370874aa0e8
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jan 6 17:20:56 2009 +0100

    ide: dynamic allocation of device structures
    
    Allocate device structures dynamically instead of having them embedded
    in ide_hwif_t:
    
    * Remove needless zeroing of port structure from ide_init_port_data().
    
    * Add ide_hwif_t.devices[MAX_DRIVES] (table of pointers to the devices).
    
    * Add ide_port_{alloc,free}_devices() helpers and use them respectively
      in ide_{host,free}_alloc().
    
    * Convert all users of ->drives[] to use ->devices[] instead.
    
    While at it:
    
    * Use drive->dn for the slave device check in scc_pata.c.
    
    As a nice side-effect this patch cuts ~1kB (x86-32) from the resulting
    code size:
    
       text    data     bss     dec     hex filename
      53963    1244     237   55444    d894 drivers/ide/ide-core.o.before
      52981    1244     237   54462    d4be drivers/ide/ide-core.o.after
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 6971c285a212..8a6f893d127e 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -497,7 +497,7 @@ void ide_port_apply_params(ide_hwif_t *hwif)
 	}
 
 	for (i = 0; i < MAX_DRIVES; i++)
-		ide_dev_apply_params(&hwif->drives[i], i);
+		ide_dev_apply_params(hwif->devices[i], i);
 }
 
 /*

commit 7f3c868ba78e486bd9d7569f884dd46d8f59bb18
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jan 6 17:20:53 2009 +0100

    ide: remove ide_driver_t typedef
    
    While at it:
    - s/struct ide_driver_s/struct ide_driver/
    - use to_ide_driver() macro in ide-proc.c
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index c1bb0f6784a9..6971c285a212 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -281,7 +281,7 @@ static int ide_uevent(struct device *dev, struct kobj_uevent_env *env)
 static int generic_ide_probe(struct device *dev)
 {
 	ide_drive_t *drive = to_ide_device(dev);
-	ide_driver_t *drv = to_ide_driver(dev->driver);
+	struct ide_driver *drv = to_ide_driver(dev->driver);
 
 	return drv->probe ? drv->probe(drive) : -ENODEV;
 }
@@ -289,7 +289,7 @@ static int generic_ide_probe(struct device *dev)
 static int generic_ide_remove(struct device *dev)
 {
 	ide_drive_t *drive = to_ide_device(dev);
-	ide_driver_t *drv = to_ide_driver(dev->driver);
+	struct ide_driver *drv = to_ide_driver(dev->driver);
 
 	if (drv->remove)
 		drv->remove(drive);
@@ -300,7 +300,7 @@ static int generic_ide_remove(struct device *dev)
 static void generic_ide_shutdown(struct device *dev)
 {
 	ide_drive_t *drive = to_ide_device(dev);
-	ide_driver_t *drv = to_ide_driver(dev->driver);
+	struct ide_driver *drv = to_ide_driver(dev->driver);
 
 	if (dev->driver && drv->shutdown)
 		drv->shutdown(drive);

commit b40d1b88f1001f0224c63fa2c008914514bcef33
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jan 6 17:20:51 2009 +0100

    ide: move ide_init_port_data() and friends to ide-probe.c
    
    * Move IDE_DEFAULT_MAX_FAILURES to <linux/ide.h>.
    
    * Move ide_cfg_mtx, ide_hwif_to_major[], ide_port_init_devices_data(),
      ide_init_port_data(), ide_init_port_hw() and ide_unregister() to
      ide-probe.c from ide.c.
    
    * Make ide_unregister(), ide_init_port_data(), ide_init_port_hw()
      and ide_cfg_mtx static.
    
    While at it:
    
    * Remove stale ide_init_port_data() documentation and ide_lock extern.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 6538b63158bf..c1bb0f6784a9 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -60,154 +60,8 @@
 #include <linux/completion.h>
 #include <linux/device.h>
 
-
-/* default maximum number of failures */
-#define IDE_DEFAULT_MAX_FAILURES 	1
-
 struct class *ide_port_class;
 
-static const u8 ide_hwif_to_major[] = { IDE0_MAJOR, IDE1_MAJOR,
-					IDE2_MAJOR, IDE3_MAJOR,
-					IDE4_MAJOR, IDE5_MAJOR,
-					IDE6_MAJOR, IDE7_MAJOR,
-					IDE8_MAJOR, IDE9_MAJOR };
-
-DEFINE_MUTEX(ide_cfg_mtx);
-
-static void ide_port_init_devices_data(ide_hwif_t *);
-
-/*
- * Do not even *think* about calling this!
- */
-void ide_init_port_data(ide_hwif_t *hwif, unsigned int index)
-{
-	/* bulk initialize hwif & drive info with zeros */
-	memset(hwif, 0, sizeof(ide_hwif_t));
-
-	/* fill in any non-zero initial values */
-	hwif->index	= index;
-	hwif->major	= ide_hwif_to_major[index];
-
-	hwif->name[0]	= 'i';
-	hwif->name[1]	= 'd';
-	hwif->name[2]	= 'e';
-	hwif->name[3]	= '0' + index;
-
-	init_completion(&hwif->gendev_rel_comp);
-
-	hwif->tp_ops = &default_tp_ops;
-
-	ide_port_init_devices_data(hwif);
-}
-
-static void ide_port_init_devices_data(ide_hwif_t *hwif)
-{
-	int unit;
-
-	for (unit = 0; unit < MAX_DRIVES; ++unit) {
-		ide_drive_t *drive = &hwif->drives[unit];
-		u8 j = (hwif->index * MAX_DRIVES) + unit;
-
-		memset(drive, 0, sizeof(*drive));
-
-		drive->media			= ide_disk;
-		drive->select			= (unit << 4) | ATA_DEVICE_OBS;
-		drive->hwif			= hwif;
-		drive->ready_stat		= ATA_DRDY;
-		drive->bad_wstat		= BAD_W_STAT;
-		drive->special.b.recalibrate	= 1;
-		drive->special.b.set_geometry	= 1;
-		drive->name[0]			= 'h';
-		drive->name[1]			= 'd';
-		drive->name[2]			= 'a' + j;
-		drive->max_failures		= IDE_DEFAULT_MAX_FAILURES;
-
-		INIT_LIST_HEAD(&drive->list);
-		init_completion(&drive->gendev_rel_comp);
-	}
-}
-
-static void __ide_port_unregister_devices(ide_hwif_t *hwif)
-{
-	int i;
-
-	for (i = 0; i < MAX_DRIVES; i++) {
-		ide_drive_t *drive = &hwif->drives[i];
-
-		if (drive->dev_flags & IDE_DFLAG_PRESENT) {
-			device_unregister(&drive->gendev);
-			wait_for_completion(&drive->gendev_rel_comp);
-		}
-	}
-}
-
-void ide_port_unregister_devices(ide_hwif_t *hwif)
-{
-	mutex_lock(&ide_cfg_mtx);
-	__ide_port_unregister_devices(hwif);
-	hwif->present = 0;
-	ide_port_init_devices_data(hwif);
-	mutex_unlock(&ide_cfg_mtx);
-}
-EXPORT_SYMBOL_GPL(ide_port_unregister_devices);
-
-/**
- *	ide_unregister		-	free an IDE interface
- *	@hwif: IDE interface
- *
- *	Perform the final unregister of an IDE interface.
- *
- *	Locking:
- *	The caller must not hold the IDE locks.
- *
- *	It is up to the caller to be sure there is no pending I/O here,
- *	and that the interface will not be reopened (present/vanishing
- *	locking isn't yet done BTW).
- */
-
-void ide_unregister(ide_hwif_t *hwif)
-{
-	BUG_ON(in_interrupt());
-	BUG_ON(irqs_disabled());
-
-	mutex_lock(&ide_cfg_mtx);
-
-	if (hwif->present) {
-		__ide_port_unregister_devices(hwif);
-		hwif->present = 0;
-	}
-
-	ide_proc_unregister_port(hwif);
-
-	free_irq(hwif->irq, hwif);
-
-	device_unregister(hwif->portdev);
-	device_unregister(&hwif->gendev);
-	wait_for_completion(&hwif->gendev_rel_comp);
-
-	/*
-	 * Remove us from the kernel's knowledge
-	 */
-	blk_unregister_region(MKDEV(hwif->major, 0), MAX_DRIVES<<PARTN_BITS);
-	kfree(hwif->sg_table);
-	unregister_blkdev(hwif->major, hwif->name);
-
-	ide_release_dma_engine(hwif);
-
-	mutex_unlock(&ide_cfg_mtx);
-}
-
-void ide_init_port_hw(ide_hwif_t *hwif, hw_regs_t *hw)
-{
-	memcpy(&hwif->io_ports, &hw->io_ports, sizeof(hwif->io_ports));
-	hwif->irq = hw->irq;
-	hwif->chipset = hw->chipset;
-	hwif->dev = hw->dev;
-	hwif->gendev.parent = hw->parent ? hw->parent : hw->dev;
-	hwif->ack_intr = hw->ack_intr;
-	hwif->config_data = hw->config;
-}
-
 /*
  *	Locks for IDE setting functionality
  */

commit ff670e632e818535950d9e31d9d0dcfc7d5b4090
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jan 6 17:20:51 2009 +0100

    ide: update ide_unregister() documentation
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 9e403282dfa7..6538b63158bf 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -155,22 +155,14 @@ EXPORT_SYMBOL_GPL(ide_port_unregister_devices);
  *	ide_unregister		-	free an IDE interface
  *	@hwif: IDE interface
  *
- *	Perform the final unregister of an IDE interface. At the moment
- *	we don't refcount interfaces so this will also get split up.
+ *	Perform the final unregister of an IDE interface.
  *
  *	Locking:
- *	The caller must not hold the IDE locks
- *	The drive present/vanishing is not yet properly locked
- *	Take care with the callbacks. These have been split to avoid
- *	deadlocking the IDE layer. The shutdown callback is called
- *	before we take the lock and free resources. It is up to the
- *	caller to be sure there is no pending I/O here, and that
- *	the interface will not be reopened (present/vanishing locking
- *	isn't yet done BTW). After we commit to the final kill we
- *	call the cleanup callback with the ide locks held.
+ *	The caller must not hold the IDE locks.
  *
- *	Unregister restores the hwif structures to the default state.
- *	This is raving bonkers.
+ *	It is up to the caller to be sure there is no pending I/O here,
+ *	and that the interface will not be reopened (present/vanishing
+ *	locking isn't yet done BTW).
  */
 
 void ide_unregister(ide_hwif_t *hwif)

commit b65fac32cfe3b2f98cd472fef400bd1c1340de23
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jan 6 17:20:50 2009 +0100

    ide: merge ide_hwgroup_t with ide_hwif_t (v2)
    
    * Merge ide_hwgroup_t with ide_hwif_t.
    
    * Cleanup init_irq() accordingly, then remove no longer needed
      ide_remove_port_from_hwgroup() and ide_ports[].
    
    * Remove now unused HWGROUP() macro.
    
    While at it:
    
    * ide_dump_ata_error() fixups
    
    v2:
    * Fix ->quirk_list check in do_ide_request()
      (s/hwif->cur_dev/prev_port->cur_dev).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 5bc2e4782a55..9e403282dfa7 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -189,8 +189,6 @@ void ide_unregister(ide_hwif_t *hwif)
 
 	free_irq(hwif->irq, hwif);
 
-	ide_remove_port_from_hwgroup(hwif);
-
 	device_unregister(hwif->portdev);
 	device_unregister(&hwif->gendev);
 	wait_for_completion(&hwif->gendev_rel_comp);
@@ -315,7 +313,6 @@ static int set_pio_mode_abuse(ide_hwif_t *hwif, u8 req_pio)
 static int set_pio_mode(ide_drive_t *drive, int arg)
 {
 	ide_hwif_t *hwif = drive->hwif;
-	ide_hwgroup_t *hwgroup = hwif->hwgroup;
 	const struct ide_port_ops *port_ops = hwif->port_ops;
 
 	if (arg < 0 || arg > 255)
@@ -330,9 +327,9 @@ static int set_pio_mode(ide_drive_t *drive, int arg)
 			unsigned long flags;
 
 			/* take lock for IDE_DFLAG_[NO_]UNMASK/[NO_]IO_32BIT */
-			spin_lock_irqsave(&hwgroup->lock, flags);
+			spin_lock_irqsave(&hwif->lock, flags);
 			port_ops->set_pio_mode(drive, arg);
-			spin_unlock_irqrestore(&hwgroup->lock, flags);
+			spin_unlock_irqrestore(&hwif->lock, flags);
 		} else
 			port_ops->set_pio_mode(drive, arg);
 	} else {

commit ae86afaee6a1c77c7a06d81dcc3bf872204d3bec
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jan 6 17:20:48 2009 +0100

    ide: use per-port IRQ handlers
    
    Use hwif instead of hwgroup as {request,free}_irq()'s cookie,
    teach ide_intr() to return early for non-active serialized ports,
    modify unexpected_intr() accordingly and then use per-port IRQ
    handlers instead of per-hwgroup ones.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 46a2d4ca812b..5bc2e4782a55 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -175,10 +175,6 @@ EXPORT_SYMBOL_GPL(ide_port_unregister_devices);
 
 void ide_unregister(ide_hwif_t *hwif)
 {
-	ide_hwif_t *g;
-	ide_hwgroup_t *hwgroup;
-	int irq_count = 0;
-
 	BUG_ON(in_interrupt());
 	BUG_ON(irqs_disabled());
 
@@ -191,18 +187,7 @@ void ide_unregister(ide_hwif_t *hwif)
 
 	ide_proc_unregister_port(hwif);
 
-	hwgroup = hwif->hwgroup;
-	/*
-	 * free the irq if we were the only hwif using it
-	 */
-	g = hwgroup->hwif;
-	do {
-		if (g->irq == hwif->irq)
-			++irq_count;
-		g = g->next;
-	} while (g != hwgroup->hwif);
-	if (irq_count == 1)
-		free_irq(hwif->irq, hwgroup);
+	free_irq(hwif->irq, hwif);
 
 	ide_remove_port_from_hwgroup(hwif);
 

commit ebdab07dad3d3a008e519b0a028e1e1ad5ecaef0
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jan 2 16:12:48 2009 +0100

    ide: move sysfs support to ide-sysfs.c
    
    While at it:
    - media_string() -> ide_media_string()
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index f0f09f702e9c..46a2d4ca812b 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -440,81 +440,13 @@ static int ide_bus_match(struct device *dev, struct device_driver *drv)
 	return 1;
 }
 
-static char *media_string(ide_drive_t *drive)
-{
-	switch (drive->media) {
-	case ide_disk:
-		return "disk";
-	case ide_cdrom:
-		return "cdrom";
-	case ide_tape:
-		return "tape";
-	case ide_floppy:
-		return "floppy";
-	case ide_optical:
-		return "optical";
-	default:
-		return "UNKNOWN";
-	}
-}
-
-static ssize_t media_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	ide_drive_t *drive = to_ide_device(dev);
-	return sprintf(buf, "%s\n", media_string(drive));
-}
-
-static ssize_t drivename_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	ide_drive_t *drive = to_ide_device(dev);
-	return sprintf(buf, "%s\n", drive->name);
-}
-
-static ssize_t modalias_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	ide_drive_t *drive = to_ide_device(dev);
-	return sprintf(buf, "ide:m-%s\n", media_string(drive));
-}
-
-static ssize_t model_show(struct device *dev, struct device_attribute *attr,
-			  char *buf)
-{
-	ide_drive_t *drive = to_ide_device(dev);
-	return sprintf(buf, "%s\n", (char *)&drive->id[ATA_ID_PROD]);
-}
-
-static ssize_t firmware_show(struct device *dev, struct device_attribute *attr,
-			     char *buf)
-{
-	ide_drive_t *drive = to_ide_device(dev);
-	return sprintf(buf, "%s\n", (char *)&drive->id[ATA_ID_FW_REV]);
-}
-
-static ssize_t serial_show(struct device *dev, struct device_attribute *attr,
-			   char *buf)
-{
-	ide_drive_t *drive = to_ide_device(dev);
-	return sprintf(buf, "%s\n", (char *)&drive->id[ATA_ID_SERNO]);
-}
-
-static struct device_attribute ide_dev_attrs[] = {
-	__ATTR_RO(media),
-	__ATTR_RO(drivename),
-	__ATTR_RO(modalias),
-	__ATTR_RO(model),
-	__ATTR_RO(firmware),
-	__ATTR(serial, 0400, serial_show, NULL),
-	__ATTR(unload_heads, 0644, ide_park_show, ide_park_store),
-	__ATTR_NULL
-};
-
 static int ide_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
 	ide_drive_t *drive = to_ide_device(dev);
 
-	add_uevent_var(env, "MEDIA=%s", media_string(drive));
+	add_uevent_var(env, "MEDIA=%s", ide_media_string(drive));
 	add_uevent_var(env, "DRIVENAME=%s", drive->name);
-	add_uevent_var(env, "MODALIAS=ide:m-%s", media_string(drive));
+	add_uevent_var(env, "MODALIAS=ide:m-%s", ide_media_string(drive));
 	return 0;
 }
 

commit e2984c628c924442132304ae662da433f41c05c9
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Dec 29 20:27:37 2008 +0100

    ide: move Power Management support to ide-pm.c
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 41d042053548..f0f09f702e9c 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -388,80 +388,6 @@ ide_ext_devset_rw_sync(unmaskirq, unmaskirq);
 ide_ext_devset_rw_sync(using_dma, using_dma);
 __IDE_DEVSET(pio_mode, DS_SYNC, NULL, set_pio_mode);
 
-static int generic_ide_suspend(struct device *dev, pm_message_t mesg)
-{
-	ide_drive_t *drive = dev->driver_data, *pair = ide_get_pair_dev(drive);
-	ide_hwif_t *hwif = HWIF(drive);
-	struct request *rq;
-	struct request_pm_state rqpm;
-	ide_task_t args;
-	int ret;
-
-	/* call ACPI _GTM only once */
-	if ((drive->dn & 1) == 0 || pair == NULL)
-		ide_acpi_get_timing(hwif);
-
-	memset(&rqpm, 0, sizeof(rqpm));
-	memset(&args, 0, sizeof(args));
-	rq = blk_get_request(drive->queue, READ, __GFP_WAIT);
-	rq->cmd_type = REQ_TYPE_PM_SUSPEND;
-	rq->special = &args;
-	rq->data = &rqpm;
-	rqpm.pm_step = IDE_PM_START_SUSPEND;
-	if (mesg.event == PM_EVENT_PRETHAW)
-		mesg.event = PM_EVENT_FREEZE;
-	rqpm.pm_state = mesg.event;
-
-	ret = blk_execute_rq(drive->queue, NULL, rq, 0);
-	blk_put_request(rq);
-
-	/* call ACPI _PS3 only after both devices are suspended */
-	if (ret == 0 && ((drive->dn & 1) || pair == NULL))
-		ide_acpi_set_state(hwif, 0);
-
-	return ret;
-}
-
-static int generic_ide_resume(struct device *dev)
-{
-	ide_drive_t *drive = dev->driver_data, *pair = ide_get_pair_dev(drive);
-	ide_hwif_t *hwif = HWIF(drive);
-	struct request *rq;
-	struct request_pm_state rqpm;
-	ide_task_t args;
-	int err;
-
-	/* call ACPI _PS0 / _STM only once */
-	if ((drive->dn & 1) == 0 || pair == NULL) {
-		ide_acpi_set_state(hwif, 1);
-		ide_acpi_push_timing(hwif);
-	}
-
-	ide_acpi_exec_tfs(drive);
-
-	memset(&rqpm, 0, sizeof(rqpm));
-	memset(&args, 0, sizeof(args));
-	rq = blk_get_request(drive->queue, READ, __GFP_WAIT);
-	rq->cmd_type = REQ_TYPE_PM_RESUME;
-	rq->cmd_flags |= REQ_PREEMPT;
-	rq->special = &args;
-	rq->data = &rqpm;
-	rqpm.pm_step = IDE_PM_START_RESUME;
-	rqpm.pm_state = PM_EVENT_ON;
-
-	err = blk_execute_rq(drive->queue, NULL, rq, 1);
-	blk_put_request(rq);
-
-	if (err == 0 && dev->driver) {
-		ide_driver_t *drv = to_ide_driver(dev->driver);
-
-		if (drv->resume)
-			drv->resume(drive);
-	}
-
-	return err;
-}
-
 /**
  * ide_device_get	-	get an additional reference to a ide_drive_t
  * @drive:	device to get a reference to

commit 2a2ca6a96194c4744a2adeefbc09ce881f3c5abe
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Dec 29 20:27:31 2008 +0100

    ide: replace the global ide_lock spinlock by per-hwgroup spinlocks (v2)
    
    Now that (almost) all host drivers have been fixed not to abuse ide_lock
    and core code usage of ide_lock has been sanitized we may safely replace
    ide_lock by per-hwgroup locks.
    
    This patch is partially based on earlier patch from Ravikiran G Thirumalai.
    
    While at it:
    - don't use deprecated HWIF() and HWGROUP() macros
    - update locking documentation in ide.h
    
    v2:
    Add missing spin_lock_init(&hwgroup->lock).  (Noticed by Elias Oltmanns)
    
    Cc: Vaibhav V. Nivargi <vaibhav.nivargi@gmail.com>
    Cc: Alok N. Kataria <alokk@calsoftinc.com>
    Cc: Shai Fultheim <shai@scalex86.org>
    Signed-off-by: Ravikiran Thirumalai <kiran@scalex86.org>
    Cc: Elias Oltmanns <eo@nebensachen.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index bca6877ee6a5..41d042053548 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -74,9 +74,6 @@ static const u8 ide_hwif_to_major[] = { IDE0_MAJOR, IDE1_MAJOR,
 
 DEFINE_MUTEX(ide_cfg_mtx);
 
-__cacheline_aligned_in_smp DEFINE_SPINLOCK(ide_lock);
-EXPORT_SYMBOL(ide_lock);
-
 static void ide_port_init_devices_data(ide_hwif_t *);
 
 /*
@@ -333,6 +330,7 @@ static int set_pio_mode_abuse(ide_hwif_t *hwif, u8 req_pio)
 static int set_pio_mode(ide_drive_t *drive, int arg)
 {
 	ide_hwif_t *hwif = drive->hwif;
+	ide_hwgroup_t *hwgroup = hwif->hwgroup;
 	const struct ide_port_ops *port_ops = hwif->port_ops;
 
 	if (arg < 0 || arg > 255)
@@ -347,9 +345,9 @@ static int set_pio_mode(ide_drive_t *drive, int arg)
 			unsigned long flags;
 
 			/* take lock for IDE_DFLAG_[NO_]UNMASK/[NO_]IO_32BIT */
-			spin_lock_irqsave(&ide_lock, flags);
+			spin_lock_irqsave(&hwgroup->lock, flags);
 			port_ops->set_pio_mode(drive, arg);
-			spin_unlock_irqrestore(&ide_lock, flags);
+			spin_unlock_irqrestore(&hwgroup->lock, flags);
 		} else
 			port_ops->set_pio_mode(drive, arg);
 	} else {

commit 44e312310889145b47311a311d3faf2488349116
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Dec 29 20:27:30 2008 +0100

    ide: __ide_port_unregister_devices() doesn't need an ide_lock held
    
    [ and ide_cfg_mtx mutex provides a sufficient protection for callers ]
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 04f8f13cb9d7..bca6877ee6a5 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -130,7 +130,6 @@ static void ide_port_init_devices_data(ide_hwif_t *hwif)
 	}
 }
 
-/* Called with ide_lock held. */
 static void __ide_port_unregister_devices(ide_hwif_t *hwif)
 {
 	int i;
@@ -139,10 +138,8 @@ static void __ide_port_unregister_devices(ide_hwif_t *hwif)
 		ide_drive_t *drive = &hwif->drives[i];
 
 		if (drive->dev_flags & IDE_DFLAG_PRESENT) {
-			spin_unlock_irq(&ide_lock);
 			device_unregister(&drive->gendev);
 			wait_for_completion(&drive->gendev_rel_comp);
-			spin_lock_irq(&ide_lock);
 		}
 	}
 }
@@ -150,11 +147,9 @@ static void __ide_port_unregister_devices(ide_hwif_t *hwif)
 void ide_port_unregister_devices(ide_hwif_t *hwif)
 {
 	mutex_lock(&ide_cfg_mtx);
-	spin_lock_irq(&ide_lock);
 	__ide_port_unregister_devices(hwif);
 	hwif->present = 0;
 	ide_port_init_devices_data(hwif);
-	spin_unlock_irq(&ide_lock);
 	mutex_unlock(&ide_cfg_mtx);
 }
 EXPORT_SYMBOL_GPL(ide_port_unregister_devices);
@@ -192,12 +187,10 @@ void ide_unregister(ide_hwif_t *hwif)
 
 	mutex_lock(&ide_cfg_mtx);
 
-	spin_lock_irq(&ide_lock);
 	if (hwif->present) {
 		__ide_port_unregister_devices(hwif);
 		hwif->present = 0;
 	}
-	spin_unlock_irq(&ide_lock);
 
 	ide_proc_unregister_port(hwif);
 

commit 4abdc6ee7c47a1a6e12f95717e461baeebee5df7
Author: Elias Oltmanns <eo@nebensachen.de>
Date:   Mon Oct 13 21:39:50 2008 +0200

    ide: Implement disk shock protection support (v4)
    
    On user request (through sysfs), the IDLE IMMEDIATE command with UNLOAD
    FEATURE as specified in ATA-7 is issued to the device and processing of
    the request queue is stopped thereafter until the specified timeout
    expires or user space asks to resume normal operation. This is supposed
    to prevent the heads of a hard drive from accidentally crashing onto the
    platter when a heavy shock is anticipated (like a falling laptop expected
    to hit the floor). Port resets are deferred whenever a device on that
    port is in the parked state.
    
    v3:
    Elias Oltmanns <eo@nebensachen.de> wrote:
    [...]
    > >> 1. Make sure that no negative value is being passed to
    > >>    jiffies_to_msecs() in ide_park_show().
    > >> 2. Drop the superfluous variable hwif in ide_special_rq().
    > >> 3. Skip initialisation of task and tf in ide_special_rq() if we are not
    > >>    handling a (un)park request.
    > >
    > > Well, #3 should have been done differently because we donn't want to
    > > check for REQ_(UN)?PARK_HEADS more often than is necessary.
    >
    > While preparing the backport to 2.6.27, it has just occurred to me that
    > we need to clear the IDE_DFLAG_PARKED flag in ide_disk_pre_reset()
    > because this flag must not be set after *any* sort of access to the
    > device.
    
    v4:
    Fix a memory leak due to a missing blk_put_request() in
    issue_park_cmd(). Additionally, we should plug the queue when enqueueing
    the unpark request because there is no guarantee that the park timeout
    has not expired by then. Even though the chance for that to happen is
    very slim, the request might end up hanging in the queue until the next
    I/O operation is queued up. While at it, clean up the code a little:
    - make issue_park_cmd() a function of type void since nobody cares for
      the return value anyway;
    - use blk_start_queueing() instead of __blk_run_queue() since we don't
      have to worry about recursion;
    - remove a superfluous pointer deference in task_no_data_intr().
    
    Signed-off-by: Elias Oltmanns <eo@nebensachen.de>
    Cc: Jeff Garzik <jeff@garzik.org>,
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 083783e851d1..04f8f13cb9d7 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -587,6 +587,7 @@ static struct device_attribute ide_dev_attrs[] = {
 	__ATTR_RO(model),
 	__ATTR_RO(firmware),
 	__ATTR(serial, 0400, serial_show, NULL),
+	__ATTR(unload_heads, 0644, ide_park_show, ide_park_store),
 	__ATTR_NULL
 };
 

commit 2bbd57cad3d72334c9fcc4e229a5a5b04dc6aebc
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Oct 13 21:39:47 2008 +0200

    ide: switch to DMA-mapping API part #2
    
    Follow-up to commit 5c05ff68b9a9b40a9be949497e0aa980185565cf
    ("ide: switch to DMA-mapping API"):
    
    * pci_{alloc,free}_consistent() -> dma_{alloc,free}_coherent()
      in ide_{allocate,release}_dma_engine().
    
    * Add ->prd_max_nents and ->prd_ent_size fields to ide_hwif_t
      (+ set default values in ide_allocate_dma_engine()).
    
    * Make ide_{allocate,release}_dma_engine() available also
      for CONFIG_BLK_DEV_IDEDMA_SFF=n.  Then convert au1xxx-ide.c,
      scc_pata.c and sgiioc4.c to use them.
    
    * Add missing ->init_dma method to scc_pata.
    
    This patch also fixes:
    - ->dmatable_cpu leak for au1xxx-ide
    - too early realease of ->dmatable_cpu for scc_pata
    - wrong amount of ->dmatable_cpu memory being freed for sgiioc4
    
    While at it:
    - remove superfluous ->dma_base check from ide_unregister()
    - return -ENOMEM on error in ide_release_dma_engine()
    - beautify error message in ide_release_dma_engine()
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index a498245dc213..083783e851d1 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -227,8 +227,7 @@ void ide_unregister(ide_hwif_t *hwif)
 	kfree(hwif->sg_table);
 	unregister_blkdev(hwif->major, hwif->name);
 
-	if (hwif->dma_base)
-		ide_release_dma_engine(hwif);
+	ide_release_dma_engine(hwif);
 
 	mutex_unlock(&ide_cfg_mtx);
 }

commit f87904898e91923a91b925078ac933f05076c7fd
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Oct 13 21:39:45 2008 +0200

    ide-disk: move all ioctl handling to ide-disk_ioctl.c
    
    While at it:
    - idedisk_ioctl() -> ide_disk_ioctl()
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 73e1cc5839d3..a498245dc213 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -392,13 +392,10 @@ static int set_unmaskirq(ide_drive_t *drive, int arg)
 	return 0;
 }
 
-#define ide_gen_devset_rw(_name, _func) \
-__IDE_DEVSET(_name, DS_SYNC, get_##_func, set_##_func)
-
-ide_gen_devset_rw(io_32bit, io_32bit);
-ide_gen_devset_rw(keepsettings, ksettings);
-ide_gen_devset_rw(unmaskirq, unmaskirq);
-ide_gen_devset_rw(using_dma, using_dma);
+ide_ext_devset_rw_sync(io_32bit, io_32bit);
+ide_ext_devset_rw_sync(keepsettings, ksettings);
+ide_ext_devset_rw_sync(unmaskirq, unmaskirq);
+ide_ext_devset_rw_sync(using_dma, using_dma);
 __IDE_DEVSET(pio_mode, DS_SYNC, NULL, set_pio_mode);
 
 static int generic_ide_suspend(struct device *dev, pm_message_t mesg)

commit 6982daf71ca9a0b0c36043315e1968b3cb709b7c
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Oct 13 21:39:40 2008 +0200

    ide: convert 'pio_mode' device setting to use DS_SYNC flag
    
    * Convert 'pio_mode' device setting to use DS_SYNC flag.
    
    * Remove unused special_t.b.{set_tune,serviced} and ide_drive_t.tune_req.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 9d3482d907c9..73e1cc5839d3 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -314,9 +314,32 @@ static int set_using_dma(ide_drive_t *drive, int arg)
 #endif
 }
 
+/*
+ * handle HDIO_SET_PIO_MODE ioctl abusers here, eventually it will go away
+ */
+static int set_pio_mode_abuse(ide_hwif_t *hwif, u8 req_pio)
+{
+	switch (req_pio) {
+	case 202:
+	case 201:
+	case 200:
+	case 102:
+	case 101:
+	case 100:
+		return (hwif->host_flags & IDE_HFLAG_ABUSE_DMA_MODES) ? 1 : 0;
+	case 9:
+	case 8:
+		return (hwif->host_flags & IDE_HFLAG_ABUSE_PREFETCH) ? 1 : 0;
+	case 7:
+	case 6:
+		return (hwif->host_flags & IDE_HFLAG_ABUSE_FAST_DEVSEL) ? 1 : 0;
+	default:
+		return 0;
+	}
+}
+
 static int set_pio_mode(ide_drive_t *drive, int arg)
 {
-	struct request *rq;
 	ide_hwif_t *hwif = drive->hwif;
 	const struct ide_port_ops *port_ops = hwif->port_ops;
 
@@ -327,17 +350,26 @@ static int set_pio_mode(ide_drive_t *drive, int arg)
 	    (hwif->host_flags & IDE_HFLAG_NO_SET_MODE))
 		return -ENOSYS;
 
-	if (drive->special.b.set_tune)
-		return -EBUSY;
+	if (set_pio_mode_abuse(drive->hwif, arg)) {
+		if (arg == 8 || arg == 9) {
+			unsigned long flags;
 
-	rq = blk_get_request(drive->queue, READ, __GFP_WAIT);
-	rq->cmd_type = REQ_TYPE_ATA_TASKFILE;
+			/* take lock for IDE_DFLAG_[NO_]UNMASK/[NO_]IO_32BIT */
+			spin_lock_irqsave(&ide_lock, flags);
+			port_ops->set_pio_mode(drive, arg);
+			spin_unlock_irqrestore(&ide_lock, flags);
+		} else
+			port_ops->set_pio_mode(drive, arg);
+	} else {
+		int keep_dma = !!(drive->dev_flags & IDE_DFLAG_USING_DMA);
 
-	drive->tune_req = (u8) arg;
-	drive->special.b.set_tune = 1;
+		ide_set_pio(drive, arg);
 
-	blk_execute_rq(drive->queue, NULL, rq, 0);
-	blk_put_request(rq);
+		if (hwif->host_flags & IDE_HFLAG_SET_PIO_MODE_KEEP_DMA) {
+			if (keep_dma)
+				ide_dma_on(drive);
+		}
+	}
 
 	return 0;
 }
@@ -367,7 +399,7 @@ ide_gen_devset_rw(io_32bit, io_32bit);
 ide_gen_devset_rw(keepsettings, ksettings);
 ide_gen_devset_rw(unmaskirq, unmaskirq);
 ide_gen_devset_rw(using_dma, using_dma);
-__IDE_DEVSET(pio_mode, 0, NULL, set_pio_mode);
+__IDE_DEVSET(pio_mode, DS_SYNC, NULL, set_pio_mode);
 
 static int generic_ide_suspend(struct device *dev, pm_message_t mesg)
 {

commit 7f612f272ad8abe82411f368bfacf793b466e1b3
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Oct 13 21:39:40 2008 +0200

    ide: remove [ata_]select_t
    
    * Use 'drive->dn & 1' in ide_init_disk().
    
    * remove [ata_]select_t.
    
    While at it:
    
    * Use ATA_DEVICE_OBS define in ide_port_init_devices_data().
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 7624b937398a..9d3482d907c9 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -114,7 +114,7 @@ static void ide_port_init_devices_data(ide_hwif_t *hwif)
 		memset(drive, 0, sizeof(*drive));
 
 		drive->media			= ide_disk;
-		drive->select.all		= (unit<<4)|0xa0;
+		drive->select			= (unit << 4) | ATA_DEVICE_OBS;
 		drive->hwif			= hwif;
 		drive->ready_stat		= ATA_DRDY;
 		drive->bad_wstat		= BAD_W_STAT;

commit 123995b97136cb41fa282f0ed2385f2c8066df96
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Oct 13 21:39:40 2008 +0200

    ide: use 'drive->dn & 1' instead of drive->select.b.unit
    
    * Call ide_port_init_devices() in ide_host_register()
      also if 'struct ide_port_info *d' is not available.
    
    * Init drive->dn in ide_port_init_devices() instead of
      ide_probe_port() so it is valid also in ->init_dev.
    
    * Pass device number to ide_dev_apply_params().
    
    * Use 'drive->dn & 1' instead of drive->select.b.unit.
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 40b5a4614340..7624b937398a 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -713,9 +713,9 @@ static int ide_set_disk_chs(const char *str, struct kernel_param *kp)
 module_param_call(chs, ide_set_disk_chs, NULL, NULL, 0);
 MODULE_PARM_DESC(chs, "force device as a disk (using CHS)");
 
-static void ide_dev_apply_params(ide_drive_t *drive)
+static void ide_dev_apply_params(ide_drive_t *drive, u8 unit)
 {
-	int i = drive->hwif->index * MAX_DRIVES + drive->select.b.unit;
+	int i = drive->hwif->index * MAX_DRIVES + unit;
 
 	if (ide_nodma & (1 << i)) {
 		printk(KERN_INFO "ide: disallowing DMA for %s\n", drive->name);
@@ -791,7 +791,7 @@ void ide_port_apply_params(ide_hwif_t *hwif)
 	}
 
 	for (i = 0; i < MAX_DRIVES; i++)
-		ide_dev_apply_params(&hwif->drives[i]);
+		ide_dev_apply_params(&hwif->drives[i], i);
 }
 
 /*

commit 0d346ba0730d84f04022f9f984d3f606f69cef37
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Oct 13 21:39:38 2008 +0200

    ide: sanitize ide*_pm_* enums
    
    * Move ide*_pm_* enums from ide-io.c to <linux/ide.h>.
    
    * idedisk_pm_* -> ide_pm_*
    
    * ide_pm_state_* -> ide_pm_*
    
    * No need to set ide_pm_* enums to the fixed values.
    
    * Uppercase ide_pm_* enums.
    
    * Fix/update comments.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 78776bbb537e..40b5a4614340 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -388,7 +388,7 @@ static int generic_ide_suspend(struct device *dev, pm_message_t mesg)
 	rq->cmd_type = REQ_TYPE_PM_SUSPEND;
 	rq->special = &args;
 	rq->data = &rqpm;
-	rqpm.pm_step = ide_pm_state_start_suspend;
+	rqpm.pm_step = IDE_PM_START_SUSPEND;
 	if (mesg.event == PM_EVENT_PRETHAW)
 		mesg.event = PM_EVENT_FREEZE;
 	rqpm.pm_state = mesg.event;
@@ -427,7 +427,7 @@ static int generic_ide_resume(struct device *dev)
 	rq->cmd_flags |= REQ_PREEMPT;
 	rq->special = &args;
 	rq->data = &rqpm;
-	rqpm.pm_step = ide_pm_state_start_resume;
+	rqpm.pm_step = IDE_PM_START_RESUME;
 	rqpm.pm_state = PM_EVENT_ON;
 
 	err = blk_execute_rq(drive->queue, NULL, rq, 1);

commit 97100fc816badbbc162644cfde7ad39ae9211fb4
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Oct 13 21:39:36 2008 +0200

    ide: add device flags
    
    Add 'unsigned long dev_flags' to ide_drive_t and convert bitfields
    to IDE_DFLAG_* flags.
    
    While at it:
    - IDE_DFLAG_ADDRESSING -> IDE_DFLAG_LBA48
    - fixup some comments
    - remove needless g->flags zeroing from ide*_probe()
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 64997873b6d7..78776bbb537e 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -138,7 +138,7 @@ static void __ide_port_unregister_devices(ide_hwif_t *hwif)
 	for (i = 0; i < MAX_DRIVES; i++) {
 		ide_drive_t *drive = &hwif->drives[i];
 
-		if (drive->present) {
+		if (drive->dev_flags & IDE_DFLAG_PRESENT) {
 			spin_unlock_irq(&ide_lock);
 			device_unregister(&drive->gendev);
 			wait_for_completion(&drive->gendev_rel_comp);
@@ -254,7 +254,7 @@ ide_devset_get(io_32bit, io_32bit);
 
 static int set_io_32bit(ide_drive_t *drive, int arg)
 {
-	if (drive->no_io_32bit)
+	if (drive->dev_flags & IDE_DFLAG_NO_IO_32BIT)
 		return -EPERM;
 
 	if (arg < 0 || arg > 1 + (SUPPORT_VLB_SYNC << 1))
@@ -265,19 +265,22 @@ static int set_io_32bit(ide_drive_t *drive, int arg)
 	return 0;
 }
 
-ide_devset_get(ksettings, keep_settings);
+ide_devset_get_flag(ksettings, IDE_DFLAG_KEEP_SETTINGS);
 
 static int set_ksettings(ide_drive_t *drive, int arg)
 {
 	if (arg < 0 || arg > 1)
 		return -EINVAL;
 
-	drive->keep_settings = arg;
+	if (arg)
+		drive->dev_flags |= IDE_DFLAG_KEEP_SETTINGS;
+	else
+		drive->dev_flags &= ~IDE_DFLAG_KEEP_SETTINGS;
 
 	return 0;
 }
 
-ide_devset_get(using_dma, using_dma);
+ide_devset_get_flag(using_dma, IDE_DFLAG_USING_DMA);
 
 static int set_using_dma(ide_drive_t *drive, int arg)
 {
@@ -339,17 +342,20 @@ static int set_pio_mode(ide_drive_t *drive, int arg)
 	return 0;
 }
 
-ide_devset_get(unmaskirq, unmask);
+ide_devset_get_flag(unmaskirq, IDE_DFLAG_UNMASK);
 
 static int set_unmaskirq(ide_drive_t *drive, int arg)
 {
-	if (drive->no_unmask)
+	if (drive->dev_flags & IDE_DFLAG_NO_UNMASK)
 		return -EPERM;
 
 	if (arg < 0 || arg > 1)
 		return -EINVAL;
 
-	drive->unmask = arg;
+	if (arg)
+		drive->dev_flags |= IDE_DFLAG_UNMASK;
+	else
+		drive->dev_flags &= ~IDE_DFLAG_UNMASK;
 
 	return 0;
 }
@@ -713,16 +719,16 @@ static void ide_dev_apply_params(ide_drive_t *drive)
 
 	if (ide_nodma & (1 << i)) {
 		printk(KERN_INFO "ide: disallowing DMA for %s\n", drive->name);
-		drive->nodma = 1;
+		drive->dev_flags |= IDE_DFLAG_NODMA;
 	}
 	if (ide_noflush & (1 << i)) {
 		printk(KERN_INFO "ide: disabling flush requests for %s\n",
 				 drive->name);
-		drive->noflush = 1;
+		drive->dev_flags |= IDE_DFLAG_NOFLUSH;
 	}
 	if (ide_noprobe & (1 << i)) {
 		printk(KERN_INFO "ide: skipping probe for %s\n", drive->name);
-		drive->noprobe = 1;
+		drive->dev_flags |= IDE_DFLAG_NOPROBE;
 	}
 	if (ide_nowerr & (1 << i)) {
 		printk(KERN_INFO "ide: ignoring the ATA_DF bit for %s\n",
@@ -731,7 +737,7 @@ static void ide_dev_apply_params(ide_drive_t *drive)
 	}
 	if (ide_cdroms & (1 << i)) {
 		printk(KERN_INFO "ide: forcing %s as a CD-ROM\n", drive->name);
-		drive->present = 1;
+		drive->dev_flags |= IDE_DFLAG_PRESENT;
 		drive->media = ide_cdrom;
 		/* an ATAPI device ignores DRDY */
 		drive->ready_stat = 0;
@@ -740,11 +746,12 @@ static void ide_dev_apply_params(ide_drive_t *drive)
 		drive->cyl  = drive->bios_cyl  = ide_disks_chs[i].cyl;
 		drive->head = drive->bios_head = ide_disks_chs[i].head;
 		drive->sect = drive->bios_sect = ide_disks_chs[i].sect;
-		drive->forced_geom = 1;
+
 		printk(KERN_INFO "ide: forcing %s as a disk (%d/%d/%d)\n",
 				 drive->name,
 				 drive->cyl, drive->head, drive->sect);
-		drive->present = 1;
+
+		drive->dev_flags |= IDE_DFLAG_FORCED_GEOM | IDE_DFLAG_PRESENT;
 		drive->media = ide_disk;
 		drive->ready_stat = ATA_DRDY;
 	}

commit 1ea1031cf92b8b8bfbe796d8e8d38b68300475d2
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Oct 13 21:39:35 2008 +0200

    ide: fix IDE ACPI for slave device-only configurations
    
    ACPI _GTM / _PS0 / _STM were not called if only slave device was present.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 9dcf5aed92cb..64997873b6d7 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -365,15 +365,15 @@ __IDE_DEVSET(pio_mode, 0, NULL, set_pio_mode);
 
 static int generic_ide_suspend(struct device *dev, pm_message_t mesg)
 {
-	ide_drive_t *drive = dev->driver_data;
+	ide_drive_t *drive = dev->driver_data, *pair = ide_get_pair_dev(drive);
 	ide_hwif_t *hwif = HWIF(drive);
 	struct request *rq;
 	struct request_pm_state rqpm;
 	ide_task_t args;
 	int ret;
 
-	/* Call ACPI _GTM only once */
-	if (!(drive->dn % 2))
+	/* call ACPI _GTM only once */
+	if ((drive->dn & 1) == 0 || pair == NULL)
 		ide_acpi_get_timing(hwif);
 
 	memset(&rqpm, 0, sizeof(rqpm));
@@ -389,26 +389,25 @@ static int generic_ide_suspend(struct device *dev, pm_message_t mesg)
 
 	ret = blk_execute_rq(drive->queue, NULL, rq, 0);
 	blk_put_request(rq);
-	/* only call ACPI _PS3 after both drivers are suspended */
-	if (!ret && (((drive->dn % 2) && hwif->drives[0].present
-		 && hwif->drives[1].present)
-		 || !hwif->drives[0].present
-		 || !hwif->drives[1].present))
+
+	/* call ACPI _PS3 only after both devices are suspended */
+	if (ret == 0 && ((drive->dn & 1) || pair == NULL))
 		ide_acpi_set_state(hwif, 0);
+
 	return ret;
 }
 
 static int generic_ide_resume(struct device *dev)
 {
-	ide_drive_t *drive = dev->driver_data;
+	ide_drive_t *drive = dev->driver_data, *pair = ide_get_pair_dev(drive);
 	ide_hwif_t *hwif = HWIF(drive);
 	struct request *rq;
 	struct request_pm_state rqpm;
 	ide_task_t args;
 	int err;
 
-	/* Call ACPI _STM only once */
-	if (!(drive->dn % 2)) {
+	/* call ACPI _PS0 / _STM only once */
+	if ((drive->dn & 1) == 0 || pair == NULL) {
 		ide_acpi_set_state(hwif, 1);
 		ide_acpi_push_timing(hwif);
 	}

commit 92f1f8fd8040e7b50a67a850a935509bb01201bb
Author: Elias Oltmanns <eo@nebensachen.de>
Date:   Fri Oct 10 22:39:40 2008 +0200

    ide: Remove ide_spin_wait_hwgroup() and use special requests instead
    
    Use a special request for serialisation purposes and get rid of the
    awkward ide_spin_wait_hwgroup(). This also involves converting the
    ide_devset structure so it can be shared by the /proc and the ioctl code.
    
    Signed-off-by: Elias Oltmanns <eo@nebensachen.de>
    [bart: use rq->cmd[] directly]
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 349d7fa75585..9dcf5aed92cb 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -250,42 +250,9 @@ void ide_init_port_hw(ide_hwif_t *hwif, hw_regs_t *hw)
 
 DEFINE_MUTEX(ide_setting_mtx);
 
-/**
- *	ide_spin_wait_hwgroup	-	wait for group
- *	@drive: drive in the group
- *
- *	Wait for an IDE device group to go non busy and then return
- *	holding the ide_lock which guards the hwgroup->busy status
- *	and right to use it.
- */
-
-int ide_spin_wait_hwgroup (ide_drive_t *drive)
-{
-	ide_hwgroup_t *hwgroup = HWGROUP(drive);
-	unsigned long timeout = jiffies + (3 * HZ);
-
-	spin_lock_irq(&ide_lock);
-
-	while (hwgroup->busy) {
-		unsigned long lflags;
-		spin_unlock_irq(&ide_lock);
-		local_irq_set(lflags);
-		if (time_after(jiffies, timeout)) {
-			local_irq_restore(lflags);
-			printk(KERN_ERR "%s: channel busy\n", drive->name);
-			return -EBUSY;
-		}
-		local_irq_restore(lflags);
-		spin_lock_irq(&ide_lock);
-	}
-	return 0;
-}
-
-EXPORT_SYMBOL(ide_spin_wait_hwgroup);
-
 ide_devset_get(io_32bit, io_32bit);
 
-int set_io_32bit(ide_drive_t *drive, int arg)
+static int set_io_32bit(ide_drive_t *drive, int arg)
 {
 	if (drive->no_io_32bit)
 		return -EPERM;
@@ -293,37 +260,28 @@ int set_io_32bit(ide_drive_t *drive, int arg)
 	if (arg < 0 || arg > 1 + (SUPPORT_VLB_SYNC << 1))
 		return -EINVAL;
 
-	if (ide_spin_wait_hwgroup(drive))
-		return -EBUSY;
-
 	drive->io_32bit = arg;
 
-	spin_unlock_irq(&ide_lock);
-
 	return 0;
 }
 
 ide_devset_get(ksettings, keep_settings);
 
-int set_ksettings(ide_drive_t *drive, int arg)
+static int set_ksettings(ide_drive_t *drive, int arg)
 {
 	if (arg < 0 || arg > 1)
 		return -EINVAL;
 
-	if (ide_spin_wait_hwgroup(drive))
-		return -EBUSY;
 	drive->keep_settings = arg;
-	spin_unlock_irq(&ide_lock);
 
 	return 0;
 }
 
 ide_devset_get(using_dma, using_dma);
 
-int set_using_dma(ide_drive_t *drive, int arg)
+static int set_using_dma(ide_drive_t *drive, int arg)
 {
 #ifdef CONFIG_BLK_DEV_IDEDMA
-	ide_hwif_t *hwif = drive->hwif;
 	int err = -EPERM;
 
 	if (arg < 0 || arg > 1)
@@ -332,18 +290,9 @@ int set_using_dma(ide_drive_t *drive, int arg)
 	if (ata_id_has_dma(drive->id) == 0)
 		goto out;
 
-	if (hwif->dma_ops == NULL)
+	if (drive->hwif->dma_ops == NULL)
 		goto out;
 
-	err = -EBUSY;
-	if (ide_spin_wait_hwgroup(drive))
-		goto out;
-	/*
-	 * set ->busy flag, unlock and let it ride
-	 */
-	hwif->hwgroup->busy = 1;
-	spin_unlock_irq(&ide_lock);
-
 	err = 0;
 
 	if (arg) {
@@ -352,12 +301,6 @@ int set_using_dma(ide_drive_t *drive, int arg)
 	} else
 		ide_dma_off(drive);
 
-	/*
-	 * lock, clear ->busy flag and unlock before leaving
-	 */
-	spin_lock_irq(&ide_lock);
-	hwif->hwgroup->busy = 0;
-	spin_unlock_irq(&ide_lock);
 out:
 	return err;
 #else
@@ -368,7 +311,7 @@ int set_using_dma(ide_drive_t *drive, int arg)
 #endif
 }
 
-int set_pio_mode(ide_drive_t *drive, int arg)
+static int set_pio_mode(ide_drive_t *drive, int arg)
 {
 	struct request *rq;
 	ide_hwif_t *hwif = drive->hwif;
@@ -398,7 +341,7 @@ int set_pio_mode(ide_drive_t *drive, int arg)
 
 ide_devset_get(unmaskirq, unmask);
 
-int set_unmaskirq(ide_drive_t *drive, int arg)
+static int set_unmaskirq(ide_drive_t *drive, int arg)
 {
 	if (drive->no_unmask)
 		return -EPERM;
@@ -406,14 +349,20 @@ int set_unmaskirq(ide_drive_t *drive, int arg)
 	if (arg < 0 || arg > 1)
 		return -EINVAL;
 
-	if (ide_spin_wait_hwgroup(drive))
-		return -EBUSY;
 	drive->unmask = arg;
-	spin_unlock_irq(&ide_lock);
 
 	return 0;
 }
 
+#define ide_gen_devset_rw(_name, _func) \
+__IDE_DEVSET(_name, DS_SYNC, get_##_func, set_##_func)
+
+ide_gen_devset_rw(io_32bit, io_32bit);
+ide_gen_devset_rw(keepsettings, ksettings);
+ide_gen_devset_rw(unmaskirq, unmaskirq);
+ide_gen_devset_rw(using_dma, using_dma);
+__IDE_DEVSET(pio_mode, 0, NULL, set_pio_mode);
+
 static int generic_ide_suspend(struct device *dev, pm_message_t mesg)
 {
 	ide_drive_t *drive = dev->driver_data;

commit 05236ea6df7419f0f37cf9603cfee265cfce5832
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:33 2008 +0200

    ide: move ioctls handling to ide-ioctls.c
    
    * Move ioctls handling to ide-ioctls.c
      (except HDIO_DRIVE_TASKFILE for now).
    
    * Make ide_{cmd,task}() static.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 19181493e722..349d7fa75585 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -489,180 +489,6 @@ static int generic_ide_resume(struct device *dev)
 	return err;
 }
 
-static int generic_drive_reset(ide_drive_t *drive)
-{
-	struct request *rq;
-	int ret = 0;
-
-	rq = blk_get_request(drive->queue, READ, __GFP_WAIT);
-	rq->cmd_type = REQ_TYPE_SPECIAL;
-	rq->cmd_len = 1;
-	rq->cmd[0] = REQ_DRIVE_RESET;
-	rq->cmd_flags |= REQ_SOFTBARRIER;
-	if (blk_execute_rq(drive->queue, NULL, rq, 1))
-		ret = rq->errors;
-	blk_put_request(rq);
-	return ret;
-}
-
-static int ide_get_identity_ioctl(ide_drive_t *drive, unsigned int cmd,
-				  unsigned long arg)
-{
-	u16 *id = NULL;
-	int size = (cmd == HDIO_GET_IDENTITY) ? (ATA_ID_WORDS * 2) : 142;
-	int rc = 0;
-
-	if (drive->id_read == 0) {
-		rc = -ENOMSG;
-		goto out;
-	}
-
-	id = kmalloc(size, GFP_KERNEL);
-	if (id == NULL) {
-		rc = -ENOMEM;
-		goto out;
-	}
-
-	memcpy(id, drive->id, size);
-	ata_id_to_hd_driveid(id);
-
-	if (copy_to_user((void __user *)arg, id, size))
-		rc = -EFAULT;
-
-	kfree(id);
-out:
-	return rc;
-}
-
-static int ide_get_nice_ioctl(ide_drive_t *drive, unsigned long arg)
-{
-	return put_user((drive->dsc_overlap << IDE_NICE_DSC_OVERLAP) |
-			(drive->nice1 << IDE_NICE_1), (long __user *)arg);
-}
-
-static int ide_set_nice_ioctl(ide_drive_t *drive, unsigned long arg)
-{
-	if (arg != (arg & ((1 << IDE_NICE_DSC_OVERLAP) | (1 << IDE_NICE_1))))
-		return -EPERM;
-
-	if (((arg >> IDE_NICE_DSC_OVERLAP) & 1) &&
-	    (drive->media == ide_disk || drive->media == ide_floppy ||
-	     drive->scsi))
-		return -EPERM;
-
-	drive->dsc_overlap = (arg >> IDE_NICE_DSC_OVERLAP) & 1;
-	drive->nice1 = (arg >> IDE_NICE_1) & 1;
-
-	return 0;
-}
-
-static const struct ide_ioctl_devset ide_ioctl_settings[] = {
-{ HDIO_GET_32BIT,	 HDIO_SET_32BIT,	get_io_32bit,  set_io_32bit  },
-{ HDIO_GET_KEEPSETTINGS, HDIO_SET_KEEPSETTINGS,	get_ksettings, set_ksettings },
-{ HDIO_GET_UNMASKINTR,	 HDIO_SET_UNMASKINTR,	get_unmaskirq, set_unmaskirq },
-{ HDIO_GET_DMA,		 HDIO_SET_DMA,		get_using_dma, set_using_dma },
-{ -1,			 HDIO_SET_PIO_MODE,	NULL,	       set_pio_mode  },
-{ 0 }
-};
-
-int generic_ide_ioctl(ide_drive_t *drive, struct file *file,
-		      struct block_device *bdev,
-		      unsigned int cmd, unsigned long arg)
-{
-	int err;
-
-	err = ide_setting_ioctl(drive, bdev, cmd, arg, ide_ioctl_settings);
-	if (err != -EOPNOTSUPP)
-		return err;
-
-	switch (cmd) {
-	case HDIO_OBSOLETE_IDENTITY:
-	case HDIO_GET_IDENTITY:
-		if (bdev != bdev->bd_contains)
-			return -EINVAL;
-		return ide_get_identity_ioctl(drive, cmd, arg);
-	case HDIO_GET_NICE:
-		return ide_get_nice_ioctl(drive, arg);
-	case HDIO_SET_NICE:
-		if (!capable(CAP_SYS_ADMIN))
-			return -EACCES;
-		return ide_set_nice_ioctl(drive, arg);
-#ifdef CONFIG_IDE_TASK_IOCTL
-	case HDIO_DRIVE_TASKFILE:
-		if (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))
-			return -EACCES;
-		if (drive->media == ide_disk)
-			return ide_taskfile_ioctl(drive, cmd, arg);
-		return -ENOMSG;
-#endif
-	case HDIO_DRIVE_CMD:
-		if (!capable(CAP_SYS_RAWIO))
-			return -EACCES;
-		return ide_cmd_ioctl(drive, cmd, arg);
-	case HDIO_DRIVE_TASK:
-		if (!capable(CAP_SYS_RAWIO))
-			return -EACCES;
-		return ide_task_ioctl(drive, cmd, arg);
-	case HDIO_DRIVE_RESET:
-		if (!capable(CAP_SYS_ADMIN))
-			return -EACCES;
-		return generic_drive_reset(drive);
-	case HDIO_GET_BUSSTATE:
-		if (!capable(CAP_SYS_ADMIN))
-			return -EACCES;
-		if (put_user(BUSSTATE_ON, (long __user *)arg))
-			return -EFAULT;
-		return 0;
-	case HDIO_SET_BUSSTATE:
-		if (!capable(CAP_SYS_ADMIN))
-			return -EACCES;
-		return -EOPNOTSUPP;
-	default:
-		return -EINVAL;
-	}
-}
-EXPORT_SYMBOL(generic_ide_ioctl);
-
-int ide_setting_ioctl(ide_drive_t *drive, struct block_device *bdev,
-		      unsigned int cmd, unsigned long arg,
-		      const struct ide_ioctl_devset *s)
-{
-	unsigned long flags;
-	int err = -EOPNOTSUPP;
-
-	for (; s->get_ioctl; s++) {
-		if (s->get && s->get_ioctl == cmd)
-			goto read_val;
-		else if (s->set && s->set_ioctl == cmd)
-			goto set_val;
-	}
-
-	return err;
-
-read_val:
-	mutex_lock(&ide_setting_mtx);
-	spin_lock_irqsave(&ide_lock, flags);
-	err = s->get(drive);
-	spin_unlock_irqrestore(&ide_lock, flags);
-	mutex_unlock(&ide_setting_mtx);
-	return err >= 0 ? put_user(err, (long __user *)arg) : err;
-
-set_val:
-	if (bdev != bdev->bd_contains)
-		err = -EINVAL;
-	else {
-		if (!capable(CAP_SYS_ADMIN))
-			err = -EACCES;
-		else {
-			mutex_lock(&ide_setting_mtx);
-			err = s->set(drive, arg);
-			mutex_unlock(&ide_setting_mtx);
-		}
-	}
-	return err;
-}
-EXPORT_SYMBOL_GPL(ide_setting_ioctl);
-
 /**
  * ide_device_get	-	get an additional reference to a ide_drive_t
  * @drive:	device to get a reference to

commit 170dc5b085e688639aa2b7acd1b907e2e1c7a48a
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:33 2008 +0200

    ide: cleanup generic_ide_ioctl()
    
    * Fix intendation for the main 'switch ()'.
    
    * 'switch ()' -> 'if ()' for HDIO_DRIVE_TASKFILE case.
    
    * Move HDIO_SET_NICE case under HDIO_GET_NICE one.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 4910924abeb7..19181493e722 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -565,8 +565,9 @@ static const struct ide_ioctl_devset ide_ioctl_settings[] = {
 { 0 }
 };
 
-int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device *bdev,
-			unsigned int cmd, unsigned long arg)
+int generic_ide_ioctl(ide_drive_t *drive, struct file *file,
+		      struct block_device *bdev,
+		      unsigned int cmd, unsigned long arg)
 {
 	int err;
 
@@ -575,57 +576,49 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 		return err;
 
 	switch (cmd) {
-		case HDIO_OBSOLETE_IDENTITY:
-		case HDIO_GET_IDENTITY:
-			if (bdev != bdev->bd_contains)
-				return -EINVAL;
-			return ide_get_identity_ioctl(drive, cmd, arg);
-		case HDIO_GET_NICE:
-			return ide_get_nice_ioctl(drive, arg);
-#ifdef CONFIG_IDE_TASK_IOCTL
-		case HDIO_DRIVE_TASKFILE:
-		        if (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))
-				return -EACCES;
-			switch(drive->media) {
-				case ide_disk:
-					return ide_taskfile_ioctl(drive, cmd, arg);
-				default:
-					return -ENOMSG;
-			}
-#endif /* CONFIG_IDE_TASK_IOCTL */
-
-		case HDIO_DRIVE_CMD:
-			if (!capable(CAP_SYS_RAWIO))
-				return -EACCES;
-			return ide_cmd_ioctl(drive, cmd, arg);
-
-		case HDIO_DRIVE_TASK:
-			if (!capable(CAP_SYS_RAWIO))
-				return -EACCES;
-			return ide_task_ioctl(drive, cmd, arg);
-		case HDIO_SET_NICE:
-			if (!capable(CAP_SYS_ADMIN))
-				return -EACCES;
-			return ide_set_nice_ioctl(drive, arg);
-		case HDIO_DRIVE_RESET:
-			if (!capable(CAP_SYS_ADMIN))
-				return -EACCES;
-
-			return generic_drive_reset(drive);
-
-		case HDIO_GET_BUSSTATE:
-			if (!capable(CAP_SYS_ADMIN))
-				return -EACCES;
-			if (put_user(BUSSTATE_ON, (long __user *)arg))
-				return -EFAULT;
-			return 0;
-
-		case HDIO_SET_BUSSTATE:
-			if (!capable(CAP_SYS_ADMIN))
-				return -EACCES;
-			return -EOPNOTSUPP;
-		default:
+	case HDIO_OBSOLETE_IDENTITY:
+	case HDIO_GET_IDENTITY:
+		if (bdev != bdev->bd_contains)
 			return -EINVAL;
+		return ide_get_identity_ioctl(drive, cmd, arg);
+	case HDIO_GET_NICE:
+		return ide_get_nice_ioctl(drive, arg);
+	case HDIO_SET_NICE:
+		if (!capable(CAP_SYS_ADMIN))
+			return -EACCES;
+		return ide_set_nice_ioctl(drive, arg);
+#ifdef CONFIG_IDE_TASK_IOCTL
+	case HDIO_DRIVE_TASKFILE:
+		if (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))
+			return -EACCES;
+		if (drive->media == ide_disk)
+			return ide_taskfile_ioctl(drive, cmd, arg);
+		return -ENOMSG;
+#endif
+	case HDIO_DRIVE_CMD:
+		if (!capable(CAP_SYS_RAWIO))
+			return -EACCES;
+		return ide_cmd_ioctl(drive, cmd, arg);
+	case HDIO_DRIVE_TASK:
+		if (!capable(CAP_SYS_RAWIO))
+			return -EACCES;
+		return ide_task_ioctl(drive, cmd, arg);
+	case HDIO_DRIVE_RESET:
+		if (!capable(CAP_SYS_ADMIN))
+			return -EACCES;
+		return generic_drive_reset(drive);
+	case HDIO_GET_BUSSTATE:
+		if (!capable(CAP_SYS_ADMIN))
+			return -EACCES;
+		if (put_user(BUSSTATE_ON, (long __user *)arg))
+			return -EFAULT;
+		return 0;
+	case HDIO_SET_BUSSTATE:
+		if (!capable(CAP_SYS_ADMIN))
+			return -EACCES;
+		return -EOPNOTSUPP;
+	default:
+		return -EINVAL;
 	}
 }
 EXPORT_SYMBOL(generic_ide_ioctl);

commit aa7687738af3332470e02ac1060f6c046d83c9a3
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:33 2008 +0200

    ide: add ide_setting_ioctl() helper
    
    * Add struct ide_ioctl_devset representing ioctl device setting.
    
    * Add ide_setting_ioctl() helper for matching given ioctl
      and its parameters against table of ioctl device settings.
    
    * Convert ide_setting_ioctl() and idedisk_ioctl() to use
      ide_setting_ioctl().
    
    * Un-export ide_setting_mtx.
    
    While at it:
    
    * {get,set}_lba_addressing() -> {get,set}_addressing()
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index f78e789ea5f7..4910924abeb7 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -250,8 +250,6 @@ void ide_init_port_hw(ide_hwif_t *hwif, hw_regs_t *hw)
 
 DEFINE_MUTEX(ide_setting_mtx);
 
-EXPORT_SYMBOL_GPL(ide_setting_mtx);
-
 /**
  *	ide_spin_wait_hwgroup	-	wait for group
  *	@drive: drive in the group
@@ -558,23 +556,23 @@ static int ide_set_nice_ioctl(ide_drive_t *drive, unsigned long arg)
 	return 0;
 }
 
+static const struct ide_ioctl_devset ide_ioctl_settings[] = {
+{ HDIO_GET_32BIT,	 HDIO_SET_32BIT,	get_io_32bit,  set_io_32bit  },
+{ HDIO_GET_KEEPSETTINGS, HDIO_SET_KEEPSETTINGS,	get_ksettings, set_ksettings },
+{ HDIO_GET_UNMASKINTR,	 HDIO_SET_UNMASKINTR,	get_unmaskirq, set_unmaskirq },
+{ HDIO_GET_DMA,		 HDIO_SET_DMA,		get_using_dma, set_using_dma },
+{ -1,			 HDIO_SET_PIO_MODE,	NULL,	       set_pio_mode  },
+{ 0 }
+};
+
 int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device *bdev,
 			unsigned int cmd, unsigned long arg)
 {
-	unsigned long flags;
-	int err = 0, (*getfunc)(ide_drive_t *), (*setfunc)(ide_drive_t *, int);
+	int err;
 
-	switch (cmd) {
-	case HDIO_GET_32BIT:	    getfunc = get_io_32bit;	 goto read_val;
-	case HDIO_GET_KEEPSETTINGS: getfunc = get_ksettings;	 goto read_val;
-	case HDIO_GET_UNMASKINTR:   getfunc = get_unmaskirq;	 goto read_val;
-	case HDIO_GET_DMA:	    getfunc = get_using_dma;	 goto read_val;
-	case HDIO_SET_32BIT:	    setfunc = set_io_32bit;	 goto set_val;
-	case HDIO_SET_KEEPSETTINGS: setfunc = set_ksettings;	 goto set_val;
-	case HDIO_SET_PIO_MODE:	    setfunc = set_pio_mode;	 goto set_val;
-	case HDIO_SET_UNMASKINTR:   setfunc = set_unmaskirq;	 goto set_val;
-	case HDIO_SET_DMA:	    setfunc = set_using_dma;	 goto set_val;
-	}
+	err = ide_setting_ioctl(drive, bdev, cmd, arg, ide_ioctl_settings);
+	if (err != -EOPNOTSUPP)
+		return err;
 
 	switch (cmd) {
 		case HDIO_OBSOLETE_IDENTITY:
@@ -629,11 +627,29 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 		default:
 			return -EINVAL;
 	}
+}
+EXPORT_SYMBOL(generic_ide_ioctl);
+
+int ide_setting_ioctl(ide_drive_t *drive, struct block_device *bdev,
+		      unsigned int cmd, unsigned long arg,
+		      const struct ide_ioctl_devset *s)
+{
+	unsigned long flags;
+	int err = -EOPNOTSUPP;
+
+	for (; s->get_ioctl; s++) {
+		if (s->get && s->get_ioctl == cmd)
+			goto read_val;
+		else if (s->set && s->set_ioctl == cmd)
+			goto set_val;
+	}
+
+	return err;
 
 read_val:
 	mutex_lock(&ide_setting_mtx);
 	spin_lock_irqsave(&ide_lock, flags);
-	err = getfunc(drive);
+	err = s->get(drive);
 	spin_unlock_irqrestore(&ide_lock, flags);
 	mutex_unlock(&ide_setting_mtx);
 	return err >= 0 ? put_user(err, (long __user *)arg) : err;
@@ -646,14 +662,13 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 			err = -EACCES;
 		else {
 			mutex_lock(&ide_setting_mtx);
-			err = setfunc(drive, arg);
+			err = s->set(drive, arg);
 			mutex_unlock(&ide_setting_mtx);
 		}
 	}
 	return err;
 }
-
-EXPORT_SYMBOL(generic_ide_ioctl);
+EXPORT_SYMBOL_GPL(ide_setting_ioctl);
 
 /**
  * ide_device_get	-	get an additional reference to a ide_drive_t

commit 9232c14bff36d65de254f34386c00b732c5b6099
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:33 2008 +0200

    ide: remove ->bus_state field from ide_hwif_t
    
    It is always set to BUSSTATE_ON.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index f42de5fe9bc2..f78e789ea5f7 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -96,8 +96,6 @@ void ide_init_port_data(ide_hwif_t *hwif, unsigned int index)
 	hwif->name[2]	= 'e';
 	hwif->name[3]	= '0' + index;
 
-	hwif->bus_state	= BUSSTATE_ON;
-
 	init_completion(&hwif->gendev_rel_comp);
 
 	hwif->tp_ops = &default_tp_ops;
@@ -620,7 +618,7 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 		case HDIO_GET_BUSSTATE:
 			if (!capable(CAP_SYS_ADMIN))
 				return -EACCES;
-			if (put_user(HWIF(drive)->bus_state, (long __user *)arg))
+			if (put_user(BUSSTATE_ON, (long __user *)arg))
 				return -EFAULT;
 			return 0;
 

commit 93734a234447a3c091f76d76f7351af9d4dde518
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:31 2008 +0200

    ide: ide_id_to_hd_driveid() -> ata_id_to_hd_driveid()
    
    Rename ide_id_to_hd_driveid() to ata_id_to_hd_driveid()
    and move it to <linux/ata.h>.
    
    Cc: Jeff Garzik <jgarzik@pobox.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 12618d2aed2c..f42de5fe9bc2 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -509,26 +509,6 @@ static int generic_drive_reset(ide_drive_t *drive)
 	return ret;
 }
 
-static inline void ide_id_to_hd_driveid(u16 *id)
-{
-#ifdef __BIG_ENDIAN
-	/* accessed in struct hd_driveid as 8-bit values */
-	id[ATA_ID_MAX_MULTSECT]	 = __cpu_to_le16(id[ATA_ID_MAX_MULTSECT]);
-	id[ATA_ID_CAPABILITY]	 = __cpu_to_le16(id[ATA_ID_CAPABILITY]);
-	id[ATA_ID_OLD_PIO_MODES] = __cpu_to_le16(id[ATA_ID_OLD_PIO_MODES]);
-	id[ATA_ID_OLD_DMA_MODES] = __cpu_to_le16(id[ATA_ID_OLD_DMA_MODES]);
-	id[ATA_ID_MULTSECT]	 = __cpu_to_le16(id[ATA_ID_MULTSECT]);
-
-	/* as 32-bit values */
-	*(u32 *)&id[ATA_ID_LBA_CAPACITY] = ata_id_u32(id, ATA_ID_LBA_CAPACITY);
-	*(u32 *)&id[ATA_ID_SPG]		 = ata_id_u32(id, ATA_ID_SPG);
-
-	/* as 64-bit value */
-	*(u64 *)&id[ATA_ID_LBA_CAPACITY_2] =
-		ata_id_u64(id, ATA_ID_LBA_CAPACITY_2);
-#endif
-}
-
 static int ide_get_identity_ioctl(ide_drive_t *drive, unsigned int cmd,
 				  unsigned long arg)
 {
@@ -548,7 +528,7 @@ static int ide_get_identity_ioctl(ide_drive_t *drive, unsigned int cmd,
 	}
 
 	memcpy(id, drive->id, size);
-	ide_id_to_hd_driveid(id);
+	ata_id_to_hd_driveid(id);
 
 	if (copy_to_user((void __user *)arg, id, size))
 		rc = -EFAULT;

commit 9fa295e12d490fd571c614b221defaa9212c20dc
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:29 2008 +0200

    ide: factor out HDIO_*_NICE ioctl handling to ide_*_nice_ioctl()
    
    Factor out HDIO_{GET,SET}_NICE ioctl handling from
    generic_ide_ioctl() to ide_{get,set}_nice_ioctl().
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 4d0c661e78a5..12618d2aed2c 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -558,6 +558,28 @@ static int ide_get_identity_ioctl(ide_drive_t *drive, unsigned int cmd,
 	return rc;
 }
 
+static int ide_get_nice_ioctl(ide_drive_t *drive, unsigned long arg)
+{
+	return put_user((drive->dsc_overlap << IDE_NICE_DSC_OVERLAP) |
+			(drive->nice1 << IDE_NICE_1), (long __user *)arg);
+}
+
+static int ide_set_nice_ioctl(ide_drive_t *drive, unsigned long arg)
+{
+	if (arg != (arg & ((1 << IDE_NICE_DSC_OVERLAP) | (1 << IDE_NICE_1))))
+		return -EPERM;
+
+	if (((arg >> IDE_NICE_DSC_OVERLAP) & 1) &&
+	    (drive->media == ide_disk || drive->media == ide_floppy ||
+	     drive->scsi))
+		return -EPERM;
+
+	drive->dsc_overlap = (arg >> IDE_NICE_DSC_OVERLAP) & 1;
+	drive->nice1 = (arg >> IDE_NICE_1) & 1;
+
+	return 0;
+}
+
 int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device *bdev,
 			unsigned int cmd, unsigned long arg)
 {
@@ -583,9 +605,7 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 				return -EINVAL;
 			return ide_get_identity_ioctl(drive, cmd, arg);
 		case HDIO_GET_NICE:
-			return put_user(drive->dsc_overlap	<<	IDE_NICE_DSC_OVERLAP	|
-					drive->nice1 << IDE_NICE_1,
-					(long __user *) arg);
+			return ide_get_nice_ioctl(drive, arg);
 #ifdef CONFIG_IDE_TASK_IOCTL
 		case HDIO_DRIVE_TASKFILE:
 		        if (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))
@@ -608,17 +628,9 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 				return -EACCES;
 			return ide_task_ioctl(drive, cmd, arg);
 		case HDIO_SET_NICE:
-			if (!capable(CAP_SYS_ADMIN)) return -EACCES;
-			if (arg != (arg & ((1 << IDE_NICE_DSC_OVERLAP) | (1 << IDE_NICE_1))))
-				return -EPERM;
-			if (((arg >> IDE_NICE_DSC_OVERLAP) & 1) &&
-			    (drive->media == ide_disk ||
-			     drive->media == ide_floppy ||
-			     drive->scsi))
-				return -EPERM;
-			drive->dsc_overlap = (arg >> IDE_NICE_DSC_OVERLAP) & 1;
-			drive->nice1 = (arg >> IDE_NICE_1) & 1;
-			return 0;
+			if (!capable(CAP_SYS_ADMIN))
+				return -EACCES;
+			return ide_set_nice_ioctl(drive, arg);
 		case HDIO_DRIVE_RESET:
 			if (!capable(CAP_SYS_ADMIN))
 				return -EACCES;

commit 02d599a365d04658bc9ea71762ed17c895079927
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:29 2008 +0200

    ide: remove ->supports_dsc_overlap field from ide_driver_t
    
    * Use drive->media and drive->scsi to check if ->dsc_overlap
      can be set by HDIO_SET_NICE ioctl in generic_ide_ioctl().
    
    * Remove unused ->supports_dsc_overlap field from ide_driver_t.
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 5b3bfc78dcdd..4d0c661e78a5 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -562,7 +562,6 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 			unsigned int cmd, unsigned long arg)
 {
 	unsigned long flags;
-	ide_driver_t *drv;
 	int err = 0, (*getfunc)(ide_drive_t *), (*setfunc)(ide_drive_t *, int);
 
 	switch (cmd) {
@@ -612,12 +611,12 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 			if (!capable(CAP_SYS_ADMIN)) return -EACCES;
 			if (arg != (arg & ((1 << IDE_NICE_DSC_OVERLAP) | (1 << IDE_NICE_1))))
 				return -EPERM;
-			drive->dsc_overlap = (arg >> IDE_NICE_DSC_OVERLAP) & 1;
-			drv = *(ide_driver_t **)bdev->bd_disk->private_data;
-			if (drive->dsc_overlap && !drv->supports_dsc_overlap) {
-				drive->dsc_overlap = 0;
+			if (((arg >> IDE_NICE_DSC_OVERLAP) & 1) &&
+			    (drive->media == ide_disk ||
+			     drive->media == ide_floppy ||
+			     drive->scsi))
 				return -EPERM;
-			}
+			drive->dsc_overlap = (arg >> IDE_NICE_DSC_OVERLAP) & 1;
 			drive->nice1 = (arg >> IDE_NICE_1) & 1;
 			return 0;
 		case HDIO_DRIVE_RESET:

commit ebc6be520673f65aef188abde43972f9cd2162e9
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:29 2008 +0200

    ide: remove read-only ->atapi_overlap field from ide_drive_t
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index eb64e942f58b..5b3bfc78dcdd 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -585,7 +585,6 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 			return ide_get_identity_ioctl(drive, cmd, arg);
 		case HDIO_GET_NICE:
 			return put_user(drive->dsc_overlap	<<	IDE_NICE_DSC_OVERLAP	|
-					drive->atapi_overlap	<<	IDE_NICE_ATAPI_OVERLAP	|
 					drive->nice1 << IDE_NICE_1,
 					(long __user *) arg);
 #ifdef CONFIG_IDE_TASK_IOCTL

commit 8185d5aa93e0a5c111adc4952a5b87193a68ae5b
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:28 2008 +0200

    ide: /proc/ide/hd*/settings rework
    
    * Add struct ide_devset, S_* flags, *DEVSET() & ide*_devset_*() macros.
    
    * Add 'const struct ide_devset **settings' to ide_driver_t.
    
    * Use 'const struct ide_devset **settings' in ide_drive_t instead of
      'struct ide_settings_s *settings'.  Then convert core code and device
      drivers to use struct ide_devset and co.:
    
      - device settings are no longer allocated dynamically for each device
        but instead there is an unique struct ide_devset instance per setting
    
      - device driver keeps the pointer to the table of pointers to its
        settings in ide_driver_t.settings
    
      - generic settings are kept in ide_generic_setting[]
    
      - ide_proc_[un]register_driver(), ide_find_setting_by_name(),
        ide_{read,write}_setting() and proc_ide_{read,write}_settings()
        are updated accordingly
    
      - ide*_add_settings() are removed
    
    * Remove no longer used __ide_add_setting(), ide_add_setting(),
      __ide_remove_setting() and auto_remove_settings().
    
    * Remove no longer used TYPE_*, SETTING_*, ide_procset_t
      and ide_settings_t.
    
    * ->keep_settings, ->using_dma, ->unmask, ->noflush, ->dsc_overlap,
      ->nice1, ->addressing, ->wcache and ->nowerr ide_drive_t fields
      can now be bitfield flags.
    
    While at it:
    
    * Rename ide_find_setting_by_name() to ide_find_setting().
    
    * Rename write_wcache() to set_wcache().
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 8e0c9f27ae4a..eb64e942f58b 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -287,6 +287,8 @@ int ide_spin_wait_hwgroup (ide_drive_t *drive)
 
 EXPORT_SYMBOL(ide_spin_wait_hwgroup);
 
+ide_devset_get(io_32bit, io_32bit);
+
 int set_io_32bit(ide_drive_t *drive, int arg)
 {
 	if (drive->no_io_32bit)
@@ -305,6 +307,8 @@ int set_io_32bit(ide_drive_t *drive, int arg)
 	return 0;
 }
 
+ide_devset_get(ksettings, keep_settings);
+
 int set_ksettings(ide_drive_t *drive, int arg)
 {
 	if (arg < 0 || arg > 1)
@@ -318,6 +322,8 @@ int set_ksettings(ide_drive_t *drive, int arg)
 	return 0;
 }
 
+ide_devset_get(using_dma, using_dma);
+
 int set_using_dma(ide_drive_t *drive, int arg)
 {
 #ifdef CONFIG_BLK_DEV_IDEDMA
@@ -394,6 +400,8 @@ int set_pio_mode(ide_drive_t *drive, int arg)
 	return 0;
 }
 
+ide_devset_get(unmaskirq, unmask);
+
 int set_unmaskirq(ide_drive_t *drive, int arg)
 {
 	if (drive->no_unmask)
@@ -555,14 +563,13 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 {
 	unsigned long flags;
 	ide_driver_t *drv;
-	int err = 0, (*setfunc)(ide_drive_t *, int);
-	u8 *val;
+	int err = 0, (*getfunc)(ide_drive_t *), (*setfunc)(ide_drive_t *, int);
 
 	switch (cmd) {
-	case HDIO_GET_32BIT:	    val = &drive->io_32bit;	 goto read_val;
-	case HDIO_GET_KEEPSETTINGS: val = &drive->keep_settings; goto read_val;
-	case HDIO_GET_UNMASKINTR:   val = &drive->unmask;	 goto read_val;
-	case HDIO_GET_DMA:	    val = &drive->using_dma;	 goto read_val;
+	case HDIO_GET_32BIT:	    getfunc = get_io_32bit;	 goto read_val;
+	case HDIO_GET_KEEPSETTINGS: getfunc = get_ksettings;	 goto read_val;
+	case HDIO_GET_UNMASKINTR:   getfunc = get_unmaskirq;	 goto read_val;
+	case HDIO_GET_DMA:	    getfunc = get_using_dma;	 goto read_val;
 	case HDIO_SET_32BIT:	    setfunc = set_io_32bit;	 goto set_val;
 	case HDIO_SET_KEEPSETTINGS: setfunc = set_ksettings;	 goto set_val;
 	case HDIO_SET_PIO_MODE:	    setfunc = set_pio_mode;	 goto set_val;
@@ -638,7 +645,7 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 read_val:
 	mutex_lock(&ide_setting_mtx);
 	spin_lock_irqsave(&ide_lock, flags);
-	err = *val;
+	err = getfunc(drive);
 	spin_unlock_irqrestore(&ide_lock, flags);
 	mutex_unlock(&ide_setting_mtx);
 	return err >= 0 ? put_user(err, (long __user *)arg) : err;

commit 263138a0ad6e38de7f6526b7de037ed4511308ef
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:27 2008 +0200

    ide: preparations for /proc/ide/hd*/settings rework
    
    After rework settings will be no longer created dynamically
    for each device so we need to make some fixups first.
    
    * Use set_[ksettings,unmaskirq]() as a set function for
      ["keepsettings","unmaskirq"] setting.
    
    * Allow writes to ["io_32bit","unmaskirq"] settings also when
      drive->no_[io_32bit,unmask] is set (this is checked later inside
      set_[io_32bit,unmaskirq]() anywyay and keeps consistency with
      the corresponding HDIO_SET_[32BIT,UNMASKINTR] ioctls).
    
    * Use max possible multi sectors value (16) as an allowed max for
      "multcount" setting.  set_multcount() set function checks against
      device's max possbile value anyway and it makes the proc setting
      consistent with the corresponding HDIO_SET_MULTCOUNT ioctl.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 080314e3d6b7..8e0c9f27ae4a 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -305,7 +305,7 @@ int set_io_32bit(ide_drive_t *drive, int arg)
 	return 0;
 }
 
-static int set_ksettings(ide_drive_t *drive, int arg)
+int set_ksettings(ide_drive_t *drive, int arg)
 {
 	if (arg < 0 || arg > 1)
 		return -EINVAL;
@@ -394,7 +394,7 @@ int set_pio_mode(ide_drive_t *drive, int arg)
 	return 0;
 }
 
-static int set_unmaskirq(ide_drive_t *drive, int arg)
+int set_unmaskirq(ide_drive_t *drive, int arg)
 {
 	if (drive->no_unmask)
 		return -EPERM;

commit 3ceca727fe3a38dd8d7a3adf938fefda83eee8af
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:27 2008 +0200

    ide: include <linux/hdreg.h> only when needed
    
    * Include <linux/ata.h> directly in <linux/ide.h>
      instead of through <linux/hdreg.h>.
    
    * Include <linux/hdreg.h> only when needed.
    
    Cc: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 27d5d6a1625f..080314e3d6b7 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -56,6 +56,7 @@
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/ide.h>
+#include <linux/hdreg.h>
 #include <linux/completion.h>
 #include <linux/device.h>
 

commit 3cd5f1eae093a7d6ff8a63c746eba9d6f689ba91
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:24 2008 +0200

    ide: remove unused _IDE_C and _IDE_DISK defines
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 7fddfe161795..27d5d6a1625f 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -44,8 +44,6 @@
  *  inspiration from lots of linux users, esp.  hamish@zot.apana.org.au
  */
 
-#define _IDE_C			/* Tell ide.h it's really us */
-
 #include <linux/module.h>
 #include <linux/types.h>
 #include <linux/string.h>

commit 3a7d24841ad794ae64c90d7d00d62a83741912aa
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:21 2008 +0200

    ide: use ATA_* defines instead of *_STAT and *_ERR ones
    
    * ERR_STAT   -> ATA_ERR
    * INDEX_STAT -> ATA_IDX
    * ECC_STAT   -> ATA_CORR
    * DRQ_STAT   -> ATA_DRQ
    * SEEK_STAT  -> ATA_DSC
    * WRERR_STAT -> ATA_DF
    * READY_STAT -> ATA_DRDY
    * BUSY_STAT  -> ATA_BUSY
    
    * MARK_ERR   -> ATA_AMNF
    * TRK0_ERR   -> ATA_TRK0NF
    * ABRT_ERR   -> ATA_ABORTED
    * MCR_ERR    -> ATA_MCR
    * ID_ERR     -> ATA_IDNF
    * MC_ERR     -> ATA_MC
    * ECC_ERR    -> ATA_UNC
    * ICRC_ERR   -> ATA_ICRC
    
    * BBD_ERR    -> ATA_BBK
    
    Also:
    
    * ILI_ERR    -> ATAPI_ILI
    * EOM_ERR    -> ATAPI_EOM
    * LFS_ERR    -> ATAPI_LFS
    
    * CD         -> ATAPI_COD
    * IO         -> ATAPI_IO
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 21b3a767e7d7..7fddfe161795 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -119,7 +119,7 @@ static void ide_port_init_devices_data(ide_hwif_t *hwif)
 		drive->media			= ide_disk;
 		drive->select.all		= (unit<<4)|0xa0;
 		drive->hwif			= hwif;
-		drive->ready_stat		= READY_STAT;
+		drive->ready_stat		= ATA_DRDY;
 		drive->bad_wstat		= BAD_W_STAT;
 		drive->special.b.recalibrate	= 1;
 		drive->special.b.set_geometry	= 1;
@@ -884,7 +884,7 @@ MODULE_PARM_DESC(noprobe, "skip probing for a device");
 static unsigned int ide_nowerr;
 
 module_param_call(nowerr, ide_set_dev_param_mask, NULL, &ide_nowerr, 0);
-MODULE_PARM_DESC(nowerr, "ignore the WRERR_STAT bit for a device");
+MODULE_PARM_DESC(nowerr, "ignore the ATA_DF bit for a device");
 
 static unsigned int ide_cdroms;
 
@@ -949,7 +949,7 @@ static void ide_dev_apply_params(ide_drive_t *drive)
 		drive->noprobe = 1;
 	}
 	if (ide_nowerr & (1 << i)) {
-		printk(KERN_INFO "ide: ignoring the WRERR_STAT bit for %s\n",
+		printk(KERN_INFO "ide: ignoring the ATA_DF bit for %s\n",
 				 drive->name);
 		drive->bad_wstat = BAD_R_STAT;
 	}
@@ -970,7 +970,7 @@ static void ide_dev_apply_params(ide_drive_t *drive)
 				 drive->cyl, drive->head, drive->sect);
 		drive->present = 1;
 		drive->media = ide_disk;
-		drive->ready_stat = READY_STAT;
+		drive->ready_stat = ATA_DRDY;
 	}
 }
 

commit 48fb2688aa67baba373531cc4ed2d9e695983c3f
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:19 2008 +0200

    ide: remove drive->driveid
    
    * Factor out HDIO_[OBSOLETE,GET]_IDENTITY ioctls handling
      to ide_get_identity_ioctl().
    
    * Use temporary buffer in ide_get_identity_ioctl() instead
      of accessing drive->id directly.
    
    * Add ide_id_to_hd_driveid() inline to convert raw id into
      struct hd_driveid format (needed on big-endian).
    
    * Use ide_id_to_hd_driveid() in ide_get_identity_ioctl(),
      cleanup ide_fix_driveid() and switch ide to use use raw id.
    
    * Remove no longer needed drive->driveid.
    
      This leaves us with 3 users of struct hd_driveid in tree:
      - arch/um/drivers/ubd_kern.c
      - drivers/block/xsysace.c
      - drivers/usb/storage/isd200.c
    
    While at it:
    
    * Use ata_id_u{32,64}() and ata_id_has_{dma,lba,iordy}() macros.
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 8d3fab33a3c7..21b3a767e7d7 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -328,7 +328,7 @@ int set_using_dma(ide_drive_t *drive, int arg)
 	if (arg < 0 || arg > 1)
 		return -EINVAL;
 
-	if ((drive->driveid->capability & 1) == 0)
+	if (ata_id_has_dma(drive->id) == 0)
 		goto out;
 
 	if (hwif->dma_ops == NULL)
@@ -502,12 +502,60 @@ static int generic_drive_reset(ide_drive_t *drive)
 	return ret;
 }
 
+static inline void ide_id_to_hd_driveid(u16 *id)
+{
+#ifdef __BIG_ENDIAN
+	/* accessed in struct hd_driveid as 8-bit values */
+	id[ATA_ID_MAX_MULTSECT]	 = __cpu_to_le16(id[ATA_ID_MAX_MULTSECT]);
+	id[ATA_ID_CAPABILITY]	 = __cpu_to_le16(id[ATA_ID_CAPABILITY]);
+	id[ATA_ID_OLD_PIO_MODES] = __cpu_to_le16(id[ATA_ID_OLD_PIO_MODES]);
+	id[ATA_ID_OLD_DMA_MODES] = __cpu_to_le16(id[ATA_ID_OLD_DMA_MODES]);
+	id[ATA_ID_MULTSECT]	 = __cpu_to_le16(id[ATA_ID_MULTSECT]);
+
+	/* as 32-bit values */
+	*(u32 *)&id[ATA_ID_LBA_CAPACITY] = ata_id_u32(id, ATA_ID_LBA_CAPACITY);
+	*(u32 *)&id[ATA_ID_SPG]		 = ata_id_u32(id, ATA_ID_SPG);
+
+	/* as 64-bit value */
+	*(u64 *)&id[ATA_ID_LBA_CAPACITY_2] =
+		ata_id_u64(id, ATA_ID_LBA_CAPACITY_2);
+#endif
+}
+
+static int ide_get_identity_ioctl(ide_drive_t *drive, unsigned int cmd,
+				  unsigned long arg)
+{
+	u16 *id = NULL;
+	int size = (cmd == HDIO_GET_IDENTITY) ? (ATA_ID_WORDS * 2) : 142;
+	int rc = 0;
+
+	if (drive->id_read == 0) {
+		rc = -ENOMSG;
+		goto out;
+	}
+
+	id = kmalloc(size, GFP_KERNEL);
+	if (id == NULL) {
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	memcpy(id, drive->id, size);
+	ide_id_to_hd_driveid(id);
+
+	if (copy_to_user((void __user *)arg, id, size))
+		rc = -EFAULT;
+
+	kfree(id);
+out:
+	return rc;
+}
+
 int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device *bdev,
 			unsigned int cmd, unsigned long arg)
 {
 	unsigned long flags;
 	ide_driver_t *drv;
-	void __user *p = (void __user *)arg;
 	int err = 0, (*setfunc)(ide_drive_t *, int);
 	u8 *val;
 
@@ -528,12 +576,7 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 		case HDIO_GET_IDENTITY:
 			if (bdev != bdev->bd_contains)
 				return -EINVAL;
-			if (drive->id_read == 0)
-				return -ENOMSG;
-			if (copy_to_user(p, drive->id, (cmd == HDIO_GET_IDENTITY) ? sizeof(*drive->id) : 142))
-				return -EFAULT;
-			return 0;
-
+			return ide_get_identity_ioctl(drive, cmd, arg);
 		case HDIO_GET_NICE:
 			return put_user(drive->dsc_overlap	<<	IDE_NICE_DSC_OVERLAP	|
 					drive->atapi_overlap	<<	IDE_NICE_ATAPI_OVERLAP	|

commit 4dde4492d850a4c9bcaa92e5bd7f4eebe3e2f5ab
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:19 2008 +0200

    ide: make drive->id an union (take 2)
    
    Make drive->id an unnamed union so id can be accessed either by using
    'u16 *id' or 'struct hd_driveid *driveid'.  Then convert all existing
    drive->id users accordingly (using 'u16 *id' when possible).
    
    This is an intermediate step to make ide 'struct hd_driveid'-free.
    
    While at it:
    
    - Add missing KERN_CONTs in it821x.c.
    
    - Use ATA_ID_WORDS and ATA_ID_*_LEN defines.
    
    - Remove unnecessary checks for drive->id.
    
    - s/drive_table/table/ in ide_in_drive_list().
    
    - Cleanup ide_config_drive_speed() a bit.
    
    - s/drive1/dev1/ & s/drive0/dev0/ in ide_undecoded_slave().
    
    v2:
    Fix typo in drivers/ide/ppc/pmac.c. (From Stephen Rothwell)
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 772451600e4d..8d3fab33a3c7 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -328,7 +328,7 @@ int set_using_dma(ide_drive_t *drive, int arg)
 	if (arg < 0 || arg > 1)
 		return -EINVAL;
 
-	if (!drive->id || !(drive->id->capability & 1))
+	if ((drive->driveid->capability & 1) == 0)
 		goto out;
 
 	if (hwif->dma_ops == NULL)
@@ -710,21 +710,21 @@ static ssize_t model_show(struct device *dev, struct device_attribute *attr,
 			  char *buf)
 {
 	ide_drive_t *drive = to_ide_device(dev);
-	return sprintf(buf, "%s\n", drive->id->model);
+	return sprintf(buf, "%s\n", (char *)&drive->id[ATA_ID_PROD]);
 }
 
 static ssize_t firmware_show(struct device *dev, struct device_attribute *attr,
 			     char *buf)
 {
 	ide_drive_t *drive = to_ide_device(dev);
-	return sprintf(buf, "%s\n", drive->id->fw_rev);
+	return sprintf(buf, "%s\n", (char *)&drive->id[ATA_ID_FW_REV]);
 }
 
 static ssize_t serial_show(struct device *dev, struct device_attribute *attr,
 			   char *buf)
 {
 	ide_drive_t *drive = to_ide_device(dev);
-	return sprintf(buf, "%s\n", drive->id->serial_no);
+	return sprintf(buf, "%s\n", (char *)&drive->id[ATA_ID_SERNO]);
 }
 
 static struct device_attribute ide_dev_attrs[] = {

commit 08da591e14cf87247ec09b17c350235157a92fc3
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu Jul 24 22:53:15 2008 +0200

    ide: add ide_device_{get,put}() helpers
    
    * Add 'struct ide_host *host' field to ide_hwif_t and set it
      in ide_host_alloc_all().
    
    * Add ide_device_{get,put}() helpers loosely based on SCSI's
      scsi_device_{get,put}() ones.
    
    * Convert IDE device drivers to use ide_device_{get,put}().
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 60f0ca66aa93..772451600e4d 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -618,6 +618,53 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 
 EXPORT_SYMBOL(generic_ide_ioctl);
 
+/**
+ * ide_device_get	-	get an additional reference to a ide_drive_t
+ * @drive:	device to get a reference to
+ *
+ * Gets a reference to the ide_drive_t and increments the use count of the
+ * underlying LLDD module.
+ */
+int ide_device_get(ide_drive_t *drive)
+{
+	struct device *host_dev;
+	struct module *module;
+
+	if (!get_device(&drive->gendev))
+		return -ENXIO;
+
+	host_dev = drive->hwif->host->dev[0];
+	module = host_dev ? host_dev->driver->owner : NULL;
+
+	if (module && !try_module_get(module)) {
+		put_device(&drive->gendev);
+		return -ENXIO;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ide_device_get);
+
+/**
+ * ide_device_put	-	release a reference to a ide_drive_t
+ * @drive:	device to release a reference on
+ *
+ * Release a reference to the ide_drive_t and decrements the use count of
+ * the underlying LLDD module.
+ */
+void ide_device_put(ide_drive_t *drive)
+{
+#ifdef CONFIG_MODULE_UNLOAD
+	struct device *host_dev = drive->hwif->host->dev[0];
+	struct module *module = host_dev ? host_dev->driver->owner : NULL;
+
+	if (module)
+		module_put(module);
+#endif
+	put_device(&drive->gendev);
+}
+EXPORT_SYMBOL_GPL(ide_device_put);
+
 static int ide_bus_match(struct device *dev, struct device_driver *drv)
 {
 	return 1;

commit fc410698ebf7abfb64f0e2337b871298557f0575
Author: Pavel Machek <pavel@suse.cz>
Date:   Wed Jul 23 19:56:02 2008 +0200

    ide: small whitespace fixes
    
    Small whitespace fixes for drivers/ide.
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 914942a766db..60f0ca66aa93 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1,6 +1,6 @@
 /*
  *  Copyright (C) 1994-1998	    Linus Torvalds & authors (see below)
- *  Copyrifht (C) 2003-2005, 2007   Bartlomiej Zolnierkiewicz
+ *  Copyright (C) 2003-2005, 2007   Bartlomiej Zolnierkiewicz
  */
 
 /*

commit 18de10170df31d34b342612f1c896a16a52f0a5c
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 23 19:55:58 2008 +0200

    ide: allocate ide_hwif_t instances dynamically
    
    * Allocate ide_hwif_t instances dynamically and remove ide_hwifs[].
    
      This cuts almost ~14kB from ide-probe.o (x86-32, MAX_HWIFS == 10):
    
       text    data     bss     dec     hex filename
       9140      40   14084   23264    5ae0 drivers/ide/ide-probe.o.before
       9169      40      44    9253    2425 drivers/ide/ide-probe.o.after
    
    * Remove no longer needed ide_init_port_data() call from ide_unregister().
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 60c5db1c59e5..914942a766db 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -233,11 +233,6 @@ void ide_unregister(ide_hwif_t *hwif)
 	if (hwif->dma_base)
 		ide_release_dma_engine(hwif);
 
-	spin_lock_irq(&ide_lock);
-	/* restore hwif data to pristine status */
-	ide_init_port_data(hwif, hwif->index);
-	spin_unlock_irq(&ide_lock);
-
 	mutex_unlock(&ide_cfg_mtx);
 }
 

commit 6059143ae34f30bb49ec8733468315284f78e2da
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 23 19:55:58 2008 +0200

    ide: move ide_remove_port_from_hwgroup() to ide-probe.c
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 7e9575d1aee3..60c5db1c59e5 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -133,41 +133,6 @@ static void ide_port_init_devices_data(ide_hwif_t *hwif)
 	}
 }
 
-void ide_remove_port_from_hwgroup(ide_hwif_t *hwif)
-{
-	ide_hwgroup_t *hwgroup = hwif->hwgroup;
-
-	spin_lock_irq(&ide_lock);
-	/*
-	 * Remove us from the hwgroup, and free
-	 * the hwgroup if we were the only member
-	 */
-	if (hwif->next == hwif) {
-		BUG_ON(hwgroup->hwif != hwif);
-		kfree(hwgroup);
-	} else {
-		/* There is another interface in hwgroup.
-		 * Unlink us, and set hwgroup->drive and ->hwif to
-		 * something sane.
-		 */
-		ide_hwif_t *g = hwgroup->hwif;
-
-		while (g->next != hwif)
-			g = g->next;
-		g->next = hwif->next;
-		if (hwgroup->hwif == hwif) {
-			/* Chose a random hwif for hwgroup->hwif.
-			 * It's guaranteed that there are no drives
-			 * left in the hwgroup.
-			 */
-			BUG_ON(hwgroup->drive != NULL);
-			hwgroup->hwif = g;
-		}
-		BUG_ON(hwgroup->hwif == hwif);
-	}
-	spin_unlock_irq(&ide_lock);
-}
-
 /* Called with ide_lock held. */
 static void __ide_port_unregister_devices(ide_hwif_t *hwif)
 {

commit 48c3c1072651922ed153bcf0a33ea82cf20df390
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 23 19:55:57 2008 +0200

    ide: add struct ide_host (take 3)
    
    * Add struct ide_host which keeps pointers to host's ports.
    
    * Add ide_host_alloc[_all]() and ide_host_remove() helpers.
    
    * Pass 'struct ide_host *host' instead of 'u8 *idx' to
      ide_device_add[_all]() and rename it to ide_host_register[_all]().
    
    * Convert host drivers and core code to use struct ide_host.
    
    * Remove no longer needed ide_find_port().
    
    * Make ide_find_port_slot() static.
    
    * Unexport ide_unregister().
    
    v2:
    * Add missing 'struct ide_host *host' to macide.c.
    
    v3:
    * Fix build problem in pmac.c (s/ide_alloc_host/ide_host_alloc/)
      (Noticed by Stephen Rothwell).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 132b504168e9..7e9575d1aee3 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -276,8 +276,6 @@ void ide_unregister(ide_hwif_t *hwif)
 	mutex_unlock(&ide_cfg_mtx);
 }
 
-EXPORT_SYMBOL(ide_unregister);
-
 void ide_init_port_hw(ide_hwif_t *hwif, hw_regs_t *hw)
 {
 	memcpy(&hwif->io_ports, &hw->io_ports, sizeof(hwif->io_ports));

commit 374e042c3e767ac2e5a40b78529220e0b3de793c
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 23 19:55:56 2008 +0200

    ide: add struct ide_tp_ops (take 2)
    
    * Add struct ide_tp_ops for transport methods.
    
    * Add 'const struct ide_tp_ops *tp_ops' to struct ide_port_info
      and ide_hwif_t.
    
    * Set the default hwif->tp_ops in ide_init_port_data().
    
    * Set host driver specific hwif->tp_ops in ide_init_port().
    
    * Export ide_exec_command(), ide_read_status(), ide_read_altstatus(),
      ide_read_sff_dma_status(), ide_set_irq(), ide_tf_{load,read}()
      and ata_{in,out}put_data().
    
    * Convert host drivers and core code to use struct ide_tp_ops.
    
    * Remove no longer needed default_hwif_transport().
    
    * Cleanup ide_hwif_t from methods that are now in struct ide_tp_ops.
    
    While at it:
    
    * Use struct ide_port_info in falconide.c and q40ide.c.
    
    * Rename ata_{in,out}put_data() to ide_{in,out}put_data().
    
    v2:
    
    * Fix missing convertion in ns87415.c.
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 961f31c648c9..132b504168e9 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -101,7 +101,7 @@ void ide_init_port_data(ide_hwif_t *hwif, unsigned int index)
 
 	init_completion(&hwif->gendev_rel_comp);
 
-	default_hwif_transport(hwif);
+	hwif->tp_ops = &default_tp_ops;
 
 	ide_port_init_devices_data(hwif);
 }

commit d6276b5f5cc7508124de291f3ed59c6945c17ae7
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 23 19:55:56 2008 +0200

    ide: add 'config' field to hw_regs_t
    
    Add 'config' field to hw_regs_t and use it to set hwif->config_data in
    ide_init_port_hw(), then convert ide_legacy_init_one() to use hw->config.
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 434dd02a4bdc..961f31c648c9 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -286,6 +286,7 @@ void ide_init_port_hw(ide_hwif_t *hwif, hw_regs_t *hw)
 	hwif->dev = hw->dev;
 	hwif->gendev.parent = hw->parent ? hw->parent : hw->dev;
 	hwif->ack_intr = hw->ack_intr;
+	hwif->config_data = hw->config;
 }
 
 /*

commit 761052e676372465fdeb97c148d5a4b0790fa8a0
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 23 19:55:54 2008 +0200

    ide: remove ->INB, ->OUTB and ->OUTBSYNC methods
    
    * Remove no longer needed ->INB, ->OUTB and ->OUTBSYNC methods.
    
    Then:
    
    * Remove no longer used default_hwif_[mm]iops() and ide_[mm_]outbsync().
    
    * Cleanup SuperIO handling in ns87415.c.
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index b6018f7b0907..434dd02a4bdc 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -101,7 +101,6 @@ void ide_init_port_data(ide_hwif_t *hwif, unsigned int index)
 
 	init_completion(&hwif->gendev_rel_comp);
 
-	default_hwif_iops(hwif);
 	default_hwif_transport(hwif);
 
 	ide_port_init_devices_data(hwif);

commit c97c6aca75fd5f718056fde7cff798b8cbdb07c0
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 23 19:55:50 2008 +0200

    ide: pass hw_regs_t-s to ide_device_add[_all]() (take 3)
    
    * Add 'hw_regs_t **hws' argument to ide_device_add[_all]() and convert
      host drivers + ide_legacy_init_one() + ide_setup_pci_device[s]() to use
      it instead of calling ide_init_port_hw() directly.
    
      [ However if host has > 1 port we must still set hwif->chipset to hint
        consecutive ide_find_port() call that the previous slot is occupied. ]
    
    * Unexport ide_init_port_hw().
    
    v2:
    * Use defines instead of hard-coded values in buddha.c, gayle.c and q40ide.c.
      (Suggested by Geert Uytterhoeven)
    
    * Better patch description.
    
    v3:
    * Fix build problem in ide-cs.c. (Noticed by Stephen Rothwell)
    
    There should be no functional changes caused by this patch.
    
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index d4a6b102a772..b6018f7b0907 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -288,7 +288,6 @@ void ide_init_port_hw(ide_hwif_t *hwif, hw_regs_t *hw)
 	hwif->gendev.parent = hw->parent ? hw->parent : hw->dev;
 	hwif->ack_intr = hw->ack_intr;
 }
-EXPORT_SYMBOL_GPL(ide_init_port_hw);
 
 /*
  *	Locks for IDE setting functionality

commit 64a8f00ff19508b3962c8a932375dbae88bee4d6
Author: Elias Oltmanns <eo@nebensachen.de>
Date:   Wed Jul 16 20:33:48 2008 +0200

    IDE: Report errors during drive reset back to user space
    
    Make sure that each error condition during the execution of an
    HDIO_DRIVE_RESET ioctl is actually reported to the calling process.
    Also, unify the exit path of reset_pollfunc() when returning ide_stopped
    since the need of ->port_ops->reset_poll() to be treated specially has
    vanished (way back, it seems).
    
    Signed-off-by: Elias Oltmanns <eo@nebensachen.de>
    Cc: "Alan Cox" <alan@lxorguk.ukuu.org.uk>
    Cc: "Randy Dunlap" <randy.dunlap@oracle.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 1ec983b00511..d4a6b102a772 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -529,17 +529,20 @@ static int generic_ide_resume(struct device *dev)
 	return err;
 }
 
-static void generic_drive_reset(ide_drive_t *drive)
+static int generic_drive_reset(ide_drive_t *drive)
 {
 	struct request *rq;
+	int ret = 0;
 
 	rq = blk_get_request(drive->queue, READ, __GFP_WAIT);
 	rq->cmd_type = REQ_TYPE_SPECIAL;
 	rq->cmd_len = 1;
 	rq->cmd[0] = REQ_DRIVE_RESET;
 	rq->cmd_flags |= REQ_SOFTBARRIER;
-	blk_execute_rq(drive->queue, NULL, rq, 1);
+	if (blk_execute_rq(drive->queue, NULL, rq, 1))
+		ret = rq->errors;
 	blk_put_request(rq);
+	return ret;
 }
 
 int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device *bdev,
@@ -616,8 +619,7 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 			if (!capable(CAP_SYS_ADMIN))
 				return -EACCES;
 
-			generic_drive_reset(drive);
-			return 0;
+			return generic_drive_reset(drive);
 
 		case HDIO_GET_BUSSTATE:
 			if (!capable(CAP_SYS_ADMIN))

commit 79e36a9f54aaf4a52eb2d9520953aa3960e99294
Author: Elias Oltmanns <eo@nebensachen.de>
Date:   Wed Jul 16 20:33:48 2008 +0200

    IDE: Fix HDIO_DRIVE_RESET handling
    
    Currently, the code path executing an HDIO_DRIVE_RESET ioctl is broken
    in various ways.  Most importantly, it is treated as an out of band
    request in an illegal way which may very likely lead to system lock ups.
    Use the drive's request queue to avoid this problem (and fix a locking
    issue for free along the way).
    
    Signed-off-by: Elias Oltmanns <eo@nebensachen.de>
    Cc: "Alan Cox" <alan@lxorguk.ukuu.org.uk>
    Cc: "Randy Dunlap" <randy.dunlap@oracle.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 90ae00d4aaf5..1ec983b00511 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -529,6 +529,19 @@ static int generic_ide_resume(struct device *dev)
 	return err;
 }
 
+static void generic_drive_reset(ide_drive_t *drive)
+{
+	struct request *rq;
+
+	rq = blk_get_request(drive->queue, READ, __GFP_WAIT);
+	rq->cmd_type = REQ_TYPE_SPECIAL;
+	rq->cmd_len = 1;
+	rq->cmd[0] = REQ_DRIVE_RESET;
+	rq->cmd_flags |= REQ_SOFTBARRIER;
+	blk_execute_rq(drive->queue, NULL, rq, 1);
+	blk_put_request(rq);
+}
+
 int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device *bdev,
 			unsigned int cmd, unsigned long arg)
 {
@@ -603,33 +616,9 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 			if (!capable(CAP_SYS_ADMIN))
 				return -EACCES;
 
-			/*
-			 *	Abort the current command on the
-			 *	group if there is one, taking
-			 *	care not to allow anything else
-			 *	to be queued and to die on the
-			 *	spot if we miss one somehow
-			 */
-
-			spin_lock_irqsave(&ide_lock, flags);
-
-			if (HWGROUP(drive)->resetting) {
-				spin_unlock_irqrestore(&ide_lock, flags);
-				return -EBUSY;
-			}
-
-			ide_abort(drive, "drive reset");
-
-			BUG_ON(HWGROUP(drive)->handler);
-
-			/* Ensure nothing gets queued after we
-			   drop the lock. Reset will clear the busy */
-
-			HWGROUP(drive)->busy = 1;
-			spin_unlock_irqrestore(&ide_lock, flags);
-			(void) ide_do_reset(drive);
-
+			generic_drive_reset(drive);
 			return 0;
+
 		case HDIO_GET_BUSSTATE:
 			if (!capable(CAP_SYS_ADMIN))
 				return -EACCES;

commit 61729415e64a1149d4eb36c3fac26a28728ad1d7
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 16 20:33:43 2008 +0200

    ide: remove needless includes from ide.c
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 9240888e5efd..90ae00d4aaf5 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -50,29 +50,16 @@
 #include <linux/types.h>
 #include <linux/string.h>
 #include <linux/kernel.h>
-#include <linux/timer.h>
-#include <linux/mm.h>
 #include <linux/interrupt.h>
 #include <linux/major.h>
 #include <linux/errno.h>
 #include <linux/genhd.h>
-#include <linux/blkpg.h>
 #include <linux/slab.h>
 #include <linux/init.h>
 #include <linux/pci.h>
-#include <linux/delay.h>
 #include <linux/ide.h>
 #include <linux/completion.h>
-#include <linux/reboot.h>
-#include <linux/cdrom.h>
-#include <linux/seq_file.h>
 #include <linux/device.h>
-#include <linux/bitops.h>
-
-#include <asm/byteorder.h>
-#include <asm/irq.h>
-#include <asm/uaccess.h>
-#include <asm/io.h>
 
 
 /* default maximum number of failures */

commit c56c5648a3bd15ff14c50f284b261140cd5b5472
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 16 20:33:40 2008 +0200

    ide: set hwif->dev in ide_init_port_hw() (take 2)
    
    * Add 'parent' field to hw_regs_t for optional parent device pointer (needed
      by macio PMAC IDE controllers) and set hwif->dev in ide_init_port_hw().
    
    * Update au1xxx-ide.c, sgiioc4.c, pmac.c and setup-pci.c accordingly.
    
    v2:
    
    * Update scc_pata.c.
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index b7855a13f0ef..9240888e5efd 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -297,7 +297,8 @@ void ide_init_port_hw(ide_hwif_t *hwif, hw_regs_t *hw)
 	memcpy(&hwif->io_ports, &hw->io_ports, sizeof(hwif->io_ports));
 	hwif->irq = hw->irq;
 	hwif->chipset = hw->chipset;
-	hwif->gendev.parent = hw->dev;
+	hwif->dev = hw->dev;
+	hwif->gendev.parent = hw->parent ? hw->parent : hw->dev;
 	hwif->ack_intr = hw->ack_intr;
 }
 EXPORT_SYMBOL_GPL(ide_init_port_hw);

commit 63b51c6d1d63276fd320615c042f1ff5d94ebab8
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 16 20:33:40 2008 +0200

    ide: make ide_hwifs[] static
    
    Move ide_hwifs[] from ide.c to ide-probe.c and make it static.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 32d8ee281d56..b7855a13f0ef 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -91,8 +91,6 @@ DEFINE_MUTEX(ide_cfg_mtx);
 __cacheline_aligned_in_smp DEFINE_SPINLOCK(ide_lock);
 EXPORT_SYMBOL(ide_lock);
 
-ide_hwif_t ide_hwifs[MAX_HWIFS];	/* master data repository */
-
 static void ide_port_init_devices_data(ide_hwif_t *);
 
 /*

commit 256c5f8eef7b9a8c8a85c15c58cda9df455f947e
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Jul 16 20:33:39 2008 +0200

    ide: fix hwif-s initialization
    
    * Add ide_hwifs[] entry initialization to ide_find_port_slot()
      and remove ide_init_port_data() calls from host drivers.
    
    * Unexport ide_init_port_data().
    
    * Remove no longer needed init_ide_data().
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 2b8453510e09..32d8ee281d56 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -121,7 +121,6 @@ void ide_init_port_data(ide_hwif_t *hwif, unsigned int index)
 
 	ide_port_init_devices_data(hwif);
 }
-EXPORT_SYMBOL_GPL(ide_init_port_data);
 
 static void ide_port_init_devices_data(ide_hwif_t *hwif)
 {
@@ -150,18 +149,6 @@ static void ide_port_init_devices_data(ide_hwif_t *hwif)
 	}
 }
 
-static void __init init_ide_data (void)
-{
-	unsigned int index;
-
-	/* Initialise all interface structures */
-	for (index = 0; index < MAX_HWIFS; ++index) {
-		ide_hwif_t *hwif = &ide_hwifs[index];
-
-		ide_init_port_data(hwif, index);
-	}
-}
-
 void ide_remove_port_from_hwgroup(ide_hwif_t *hwif)
 {
 	ide_hwgroup_t *hwgroup = hwif->hwgroup;
@@ -1021,8 +1008,6 @@ static int __init ide_init(void)
 		goto out_port_class;
 	}
 
-	init_ide_data();
-
 	proc_ide_create();
 
 	return 0;

commit ff07488346702f554aaeb6aae982540aa0302373
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jul 15 21:21:50 2008 +0200

    ide: remove drive->ctl
    
    Remove drive->ctl (it is always equal to 0x08 after init time).
    
    While at it:
    
    * Use ATA_DEVCTL_OBS define.
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 1defba3eefe7..2b8453510e09 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -136,7 +136,6 @@ static void ide_port_init_devices_data(ide_hwif_t *hwif)
 		drive->media			= ide_disk;
 		drive->select.all		= (unit<<4)|0xa0;
 		drive->hwif			= hwif;
-		drive->ctl			= 0x08;
 		drive->ready_stat		= READY_STAT;
 		drive->bad_wstat		= BAD_W_STAT;
 		drive->special.b.recalibrate	= 1;

commit 931ee0dc5c69e8113233d21942681ab8fecde7f9
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jul 15 21:21:47 2008 +0200

    ide: remove obsoleted "ide=" kernel parameters
    
    * Remove obsoleted "ide=" kernel parameters.
    
    * Remove no longer needed:
      - ide_setup()
      - parse_options()
      - __setup("", ...)
      - module_param(options, ...)
    
    * Use module_{init,exit}() for MODULE=y case and remove MODULE ifdef.
    
    * Make ide_*acpi* and ide_doubler variables static.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index e8c88ff2f6b6..1defba3eefe7 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -87,9 +87,9 @@ static const u8 ide_hwif_to_major[] = { IDE0_MAJOR, IDE1_MAJOR,
 					IDE8_MAJOR, IDE9_MAJOR };
 
 DEFINE_MUTEX(ide_cfg_mtx);
- __cacheline_aligned_in_smp DEFINE_SPINLOCK(ide_lock);
 
-int noautodma = 0;
+__cacheline_aligned_in_smp DEFINE_SPINLOCK(ide_lock);
+EXPORT_SYMBOL(ide_lock);
 
 ide_hwif_t ide_hwifs[MAX_HWIFS];	/* master data repository */
 
@@ -698,59 +698,6 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 
 EXPORT_SYMBOL(generic_ide_ioctl);
 
-/*
- * ide_setup() gets called VERY EARLY during initialization,
- * to handle kernel "command line" strings beginning with "ide".
- *
- * Remember to update Documentation/ide/ide.txt if you change something here.
- */
-static int __init ide_setup(char *s)
-{
-	printk(KERN_INFO "ide_setup: %s", s);
-
-#ifdef CONFIG_BLK_DEV_IDEDOUBLER
-	if (!strcmp(s, "ide=doubler")) {
-		extern int ide_doubler;
-
-		printk(" : Enabled support for IDE doublers\n");
-		ide_doubler = 1;
-		goto obsolete_option;
-	}
-#endif /* CONFIG_BLK_DEV_IDEDOUBLER */
-
-	if (!strcmp(s, "ide=nodma")) {
-		printk(" : Prevented DMA\n");
-		noautodma = 1;
-		goto obsolete_option;
-	}
-
-#ifdef CONFIG_BLK_DEV_IDEACPI
-	if (!strcmp(s, "ide=noacpi")) {
-		//printk(" : Disable IDE ACPI support.\n");
-		ide_noacpi = 1;
-		goto obsolete_option;
-	}
-	if (!strcmp(s, "ide=acpigtf")) {
-		//printk(" : Enable IDE ACPI _GTF support.\n");
-		ide_acpigtf = 1;
-		goto obsolete_option;
-	}
-	if (!strcmp(s, "ide=acpionboot")) {
-		//printk(" : Call IDE ACPI methods on boot.\n");
-		ide_acpionboot = 1;
-		goto obsolete_option;
-	}
-#endif /* CONFIG_BLK_DEV_IDEACPI */
-
-	printk(" -- BAD OPTION\n");
-	return 1;
-obsolete_option:
-	printk(" -- OBSOLETE OPTION, WILL BE REMOVED SOON!\n");
-	return 1;
-}
-
-EXPORT_SYMBOL(ide_lock);
-
 static int ide_bus_match(struct device *dev, struct device_driver *drv)
 {
 	return 1;
@@ -1087,32 +1034,7 @@ static int __init ide_init(void)
 	return ret;
 }
 
-#ifdef MODULE
-static char *options = NULL;
-module_param(options, charp, 0);
-MODULE_LICENSE("GPL");
-
-static void __init parse_options (char *line)
-{
-	char *next = line;
-
-	if (line == NULL || !*line)
-		return;
-	while ((line = next) != NULL) {
- 		if ((next = strchr(line,' ')) != NULL)
-			*next++ = 0;
-		if (!ide_setup(line))
-			printk (KERN_INFO "Unknown option '%s'\n", line);
-	}
-}
-
-int __init init_module (void)
-{
-	parse_options(options);
-	return ide_init();
-}
-
-void __exit cleanup_module (void)
+static void __exit ide_exit(void)
 {
 	proc_ide_destroy();
 
@@ -1121,10 +1043,7 @@ void __exit cleanup_module (void)
 	bus_unregister(&ide_bus_type);
 }
 
-#else /* !MODULE */
-
-__setup("", ide_setup);
-
 module_init(ide_init);
+module_exit(ide_exit);
 
-#endif /* MODULE */
+MODULE_LICENSE("GPL");

commit dbac9f895f628deebc99dee86dfd21c1823013c3
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jul 15 21:21:46 2008 +0200

    ide: cleanup init_ide_data()
    
    * Remove no longer need init_ide_data() call from ide_setup().
    
    * Cleanup init_ide_data().
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 6f600d81a972..e8c88ff2f6b6 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -151,32 +151,9 @@ static void ide_port_init_devices_data(ide_hwif_t *hwif)
 	}
 }
 
-/*
- * init_ide_data() sets reasonable default values into all fields
- * of all instances of the hwifs and drives, but only on the first call.
- * Subsequent calls have no effect (they don't wipe out anything).
- *
- * This routine is normally called at driver initialization time,
- * but may also be called MUCH earlier during kernel "command-line"
- * parameter processing.  As such, we cannot depend on any other parts
- * of the kernel (such as memory allocation) to be functioning yet.
- *
- * This is too bad, as otherwise we could dynamically allocate the
- * ide_drive_t structs as needed, rather than always consuming memory
- * for the max possible number (MAX_HWIFS * MAX_DRIVES) of them.
- *
- * FIXME: We should stuff the setup data into __init and copy the
- * relevant hwifs/allocate them properly during boot.
- */
-#define MAGIC_COOKIE 0x12345678
 static void __init init_ide_data (void)
 {
 	unsigned int index;
-	static unsigned long magic_cookie = MAGIC_COOKIE;
-
-	if (magic_cookie != MAGIC_COOKIE)
-		return;		/* already initialized */
-	magic_cookie = 0;
 
 	/* Initialise all interface structures */
 	for (index = 0; index < MAX_HWIFS; ++index) {
@@ -730,7 +707,6 @@ EXPORT_SYMBOL(generic_ide_ioctl);
 static int __init ide_setup(char *s)
 {
 	printk(KERN_INFO "ide_setup: %s", s);
-	init_ide_data ();
 
 #ifdef CONFIG_BLK_DEV_IDEDOUBLER
 	if (!strcmp(s, "ide=doubler")) {

commit 232595eaff951e96cabe5e85fed35f66b72ff51e
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jul 15 21:21:46 2008 +0200

    ide: remove obsoleted "hdx=" kernel parameters
    
    * Remove obsoleted "hdx=" kernel parameters.
    
    * Remove no longer used stridx() and match_parm().
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index f65be738b16a..6f600d81a972 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -721,90 +721,14 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 
 EXPORT_SYMBOL(generic_ide_ioctl);
 
-/*
- * stridx() returns the offset of c within s,
- * or -1 if c is '\0' or not found within s.
- */
-static int __init stridx (const char *s, char c)
-{
-	char *i = strchr(s, c);
-	return (i && c) ? i - s : -1;
-}
-
-/*
- * match_parm() does parsing for ide_setup():
- *
- * 1. the first char of s must be '='.
- * 2. if the remainder matches one of the supplied keywords,
- *     the index (1 based) of the keyword is negated and returned.
- * 3. if the remainder is a series of no more than max_vals numbers
- *     separated by commas, the numbers are saved in vals[] and a
- *     count of how many were saved is returned.  Base10 is assumed,
- *     and base16 is allowed when prefixed with "0x".
- * 4. otherwise, zero is returned.
- */
-static int __init match_parm (char *s, const char *keywords[], int vals[], int max_vals)
-{
-	static const char *decimal = "0123456789";
-	static const char *hex = "0123456789abcdef";
-	int i, n;
-
-	if (*s++ == '=') {
-		/*
-		 * Try matching against the supplied keywords,
-		 * and return -(index+1) if we match one
-		 */
-		if (keywords != NULL) {
-			for (i = 0; *keywords != NULL; ++i) {
-				if (!strcmp(s, *keywords++))
-					return -(i+1);
-			}
-		}
-		/*
-		 * Look for a series of no more than "max_vals"
-		 * numeric values separated by commas, in base10,
-		 * or base16 when prefixed with "0x".
-		 * Return a count of how many were found.
-		 */
-		for (n = 0; (i = stridx(decimal, *s)) >= 0;) {
-			vals[n] = i;
-			while ((i = stridx(decimal, *++s)) >= 0)
-				vals[n] = (vals[n] * 10) + i;
-			if (*s == 'x' && !vals[n]) {
-				while ((i = stridx(hex, *++s)) >= 0)
-					vals[n] = (vals[n] * 0x10) + i;
-			}
-			if (++n == max_vals)
-				break;
-			if (*s == ',' || *s == ';')
-				++s;
-		}
-		if (!*s)
-			return n;
-	}
-	return 0;	/* zero = nothing matched */
-}
-
 /*
  * ide_setup() gets called VERY EARLY during initialization,
- * to handle kernel "command line" strings beginning with "hdx=" or "ide".
+ * to handle kernel "command line" strings beginning with "ide".
  *
  * Remember to update Documentation/ide/ide.txt if you change something here.
  */
 static int __init ide_setup(char *s)
 {
-	ide_hwif_t *hwif;
-	ide_drive_t *drive;
-	unsigned int hw, unit;
-	int vals[3];
-	const char max_drive = 'a' + ((MAX_HWIFS * MAX_DRIVES) - 1);
-
-	if (strncmp(s,"hd",2) == 0 && s[2] == '=')	/* hd= is for hd.c   */
-		return 0;				/* driver and not us */
-
-	if (strncmp(s, "ide", 3) && strncmp(s, "hd", 2))
-		return 0;
-
 	printk(KERN_INFO "ide_setup: %s", s);
 	init_ide_data ();
 
@@ -842,67 +766,6 @@ static int __init ide_setup(char *s)
 	}
 #endif /* CONFIG_BLK_DEV_IDEACPI */
 
-	/*
-	 * Look for drive options:  "hdx="
-	 */
-	if (s[0] == 'h' && s[1] == 'd' && s[2] >= 'a' && s[2] <= max_drive) {
-		const char *hd_words[] = {
-			"none", "noprobe", "nowerr", "cdrom", "nodma",
-			"-6", "-7", "-8", "-9", "-10",
-			"noflush", "remap", "remap63", "scsi", NULL };
-		unit = s[2] - 'a';
-		hw   = unit / MAX_DRIVES;
-		unit = unit % MAX_DRIVES;
-		hwif = &ide_hwifs[hw];
-		drive = &hwif->drives[unit];
-		if (strncmp(s + 4, "ide-", 4) == 0) {
-			strlcpy(drive->driver_req, s + 4, sizeof(drive->driver_req));
-			goto obsolete_option;
-		}
-		switch (match_parm(&s[3], hd_words, vals, 3)) {
-			case -1: /* "none" */
-			case -2: /* "noprobe" */
-				drive->noprobe = 1;
-				goto obsolete_option;
-			case -3: /* "nowerr" */
-				drive->bad_wstat = BAD_R_STAT;
-				goto obsolete_option;
-			case -4: /* "cdrom" */
-				drive->present = 1;
-				drive->media = ide_cdrom;
-				/* an ATAPI device ignores DRDY */
-				drive->ready_stat = 0;
-				goto obsolete_option;
-			case -5: /* nodma */
-				drive->nodma = 1;
-				goto obsolete_option;
-			case -11: /* noflush */
-				drive->noflush = 1;
-				goto obsolete_option;
-			case -12: /* "remap" */
-				drive->remap_0_to_1 = 1;
-				goto obsolete_option;
-			case -13: /* "remap63" */
-				drive->sect0 = 63;
-				goto obsolete_option;
-			case -14: /* "scsi" */
-				drive->scsi = 1;
-				goto obsolete_option;
-			case 3: /* cyl,head,sect */
-				drive->media	= ide_disk;
-				drive->ready_stat = READY_STAT;
-				drive->cyl	= drive->bios_cyl  = vals[0];
-				drive->head	= drive->bios_head = vals[1];
-				drive->sect	= drive->bios_sect = vals[2];
-				drive->present	= 1;
-				drive->forced_geom = 1;
-				goto obsolete_option;
-			default:
-				goto bad_option;
-		}
-	}
-
-bad_option:
 	printk(" -- BAD OPTION\n");
 	return 1;
 obsolete_option:

commit 30e5ee4d1a651a0c66e86c6612c003034bd20ba2
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jul 15 21:21:46 2008 +0200

    ide: remove obsoleted "idebus=" kernel parameter
    
    * Remove obsoleted "idebus=" kernel parameter.
    
    * Remove no longer needed ide_system_bus_speed() and system_bus_clock()
      (together with idebus_parameter and system_bus_speed variables).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 8823df1b8716..f65be738b16a 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -86,9 +86,6 @@ static const u8 ide_hwif_to_major[] = { IDE0_MAJOR, IDE1_MAJOR,
 					IDE6_MAJOR, IDE7_MAJOR,
 					IDE8_MAJOR, IDE9_MAJOR };
 
-static int idebus_parameter;	/* holds the "idebus=" parameter */
-static int system_bus_speed;	/* holds what we think is VESA/PCI bus speed */
-
 DEFINE_MUTEX(ide_cfg_mtx);
  __cacheline_aligned_in_smp DEFINE_SPINLOCK(ide_lock);
 
@@ -189,38 +186,6 @@ static void __init init_ide_data (void)
 	}
 }
 
-/**
- *	ide_system_bus_speed	-	guess bus speed
- *
- *	ide_system_bus_speed() returns what we think is the system VESA/PCI
- *	bus speed (in MHz). This is used for calculating interface PIO timings.
- *	The default is 40 for known PCI systems, 50 otherwise.
- *	The "idebus=xx" parameter can be used to override this value.
- *	The actual value to be used is computed/displayed the first time
- *	through. Drivers should only use this as a last resort.
- *
- *	Returns a guessed speed in MHz.
- */
-
-static int ide_system_bus_speed(void)
-{
-#ifdef CONFIG_PCI
-	static struct pci_device_id pci_default[] = {
-		{ PCI_DEVICE(PCI_ANY_ID, PCI_ANY_ID) },
-		{ }
-	};
-#else
-#define pci_default 0
-#endif /* CONFIG_PCI */
-
-	/* user supplied value */
-	if (idebus_parameter)
-		return idebus_parameter;
-
-	/* safe default value for PCI or VESA and PCI*/
-	return pci_dev_present(pci_default) ? 33 : 50;
-}
-
 void ide_remove_port_from_hwgroup(ide_hwif_t *hwif)
 {
 	ide_hwgroup_t *hwgroup = hwif->hwgroup;
@@ -540,20 +505,6 @@ static int set_unmaskirq(ide_drive_t *drive, int arg)
 	return 0;
 }
 
-/**
- *	system_bus_clock	-	clock guess
- *
- *	External version of the bus clock guess used by very old IDE drivers
- *	for things like VLB timings. Should not be used.
- */
-
-int system_bus_clock (void)
-{
-	return system_bus_speed;
-}
-
-EXPORT_SYMBOL(system_bus_clock);
-
 static int generic_ide_suspend(struct device *dev, pm_message_t mesg)
 {
 	ide_drive_t *drive = dev->driver_data;
@@ -851,7 +802,7 @@ static int __init ide_setup(char *s)
 	if (strncmp(s,"hd",2) == 0 && s[2] == '=')	/* hd= is for hd.c   */
 		return 0;				/* driver and not us */
 
-	if (strncmp(s,"ide",3) && strncmp(s,"idebus",6) && strncmp(s,"hd",2))
+	if (strncmp(s, "ide", 3) && strncmp(s, "hd", 2))
 		return 0;
 
 	printk(KERN_INFO "ide_setup: %s", s);
@@ -951,21 +902,6 @@ static int __init ide_setup(char *s)
 		}
 	}
 
-	if (s[0] != 'i' || s[1] != 'd' || s[2] != 'e')
-		goto bad_option;
-	/*
-	 * Look for bus speed option:  "idebus="
-	 */
-	if (s[3] == 'b' && s[4] == 'u' && s[5] == 's') {
-		if (match_parm(&s[6], NULL, vals, 1) != 1)
-			goto bad_option;
-		if (vals[0] >= 20 && vals[0] <= 66) {
-			idebus_parameter = vals[0];
-		} else
-			printk(" -- BAD BUS SPEED! Expected value from 20 to 66");
-		goto obsolete_option;
-	}
-
 bad_option:
 	printk(" -- BAD OPTION\n");
 	return 1;
@@ -1287,11 +1223,6 @@ static int __init ide_init(void)
 	int ret;
 
 	printk(KERN_INFO "Uniform Multi-Platform E-IDE driver\n");
-	system_bus_speed = ide_system_bus_speed();
-
-	printk(KERN_INFO "ide: Assuming %dMHz system bus speed "
-			 "for PIO modes%s\n", system_bus_speed,
-			idebus_parameter ? "" : "; override with idebus=xx");
 
 	ret = bus_register(&ide_bus_type);
 	if (ret < 0) {

commit 5b114715ed63f3a4fdf790f5df61364fc4adadf1
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Tue Jul 15 21:21:44 2008 +0200

    ide: convert ide_do_drive_cmd path to use blk_execute_rq
    
    This converts the ide_do_drive_cmd path using ide_[head_]wait to use
    blk_execute_rq.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Cc: Borislav Petkov <petkovbb@gmail.com>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index c9a05721360e..8823df1b8716 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -498,7 +498,7 @@ int set_using_dma(ide_drive_t *drive, int arg)
 
 int set_pio_mode(ide_drive_t *drive, int arg)
 {
-	struct request rq;
+	struct request *rq;
 	ide_hwif_t *hwif = drive->hwif;
 	const struct ide_port_ops *port_ops = hwif->port_ops;
 
@@ -512,12 +512,15 @@ int set_pio_mode(ide_drive_t *drive, int arg)
 	if (drive->special.b.set_tune)
 		return -EBUSY;
 
-	ide_init_drive_cmd(&rq);
-	rq.cmd_type = REQ_TYPE_ATA_TASKFILE;
+	rq = blk_get_request(drive->queue, READ, __GFP_WAIT);
+	rq->cmd_type = REQ_TYPE_ATA_TASKFILE;
 
 	drive->tune_req = (u8) arg;
 	drive->special.b.set_tune = 1;
-	(void) ide_do_drive_cmd(drive, &rq, ide_wait);
+
+	blk_execute_rq(drive->queue, NULL, rq, 0);
+	blk_put_request(rq);
+
 	return 0;
 }
 
@@ -555,7 +558,7 @@ static int generic_ide_suspend(struct device *dev, pm_message_t mesg)
 {
 	ide_drive_t *drive = dev->driver_data;
 	ide_hwif_t *hwif = HWIF(drive);
-	struct request rq;
+	struct request *rq;
 	struct request_pm_state rqpm;
 	ide_task_t args;
 	int ret;
@@ -564,18 +567,19 @@ static int generic_ide_suspend(struct device *dev, pm_message_t mesg)
 	if (!(drive->dn % 2))
 		ide_acpi_get_timing(hwif);
 
-	blk_rq_init(NULL, &rq);
 	memset(&rqpm, 0, sizeof(rqpm));
 	memset(&args, 0, sizeof(args));
-	rq.cmd_type = REQ_TYPE_PM_SUSPEND;
-	rq.special = &args;
-	rq.data = &rqpm;
+	rq = blk_get_request(drive->queue, READ, __GFP_WAIT);
+	rq->cmd_type = REQ_TYPE_PM_SUSPEND;
+	rq->special = &args;
+	rq->data = &rqpm;
 	rqpm.pm_step = ide_pm_state_start_suspend;
 	if (mesg.event == PM_EVENT_PRETHAW)
 		mesg.event = PM_EVENT_FREEZE;
 	rqpm.pm_state = mesg.event;
 
-	ret = ide_do_drive_cmd(drive, &rq, ide_wait);
+	ret = blk_execute_rq(drive->queue, NULL, rq, 0);
+	blk_put_request(rq);
 	/* only call ACPI _PS3 after both drivers are suspended */
 	if (!ret && (((drive->dn % 2) && hwif->drives[0].present
 		 && hwif->drives[1].present)
@@ -589,7 +593,7 @@ static int generic_ide_resume(struct device *dev)
 {
 	ide_drive_t *drive = dev->driver_data;
 	ide_hwif_t *hwif = HWIF(drive);
-	struct request rq;
+	struct request *rq;
 	struct request_pm_state rqpm;
 	ide_task_t args;
 	int err;
@@ -602,17 +606,18 @@ static int generic_ide_resume(struct device *dev)
 
 	ide_acpi_exec_tfs(drive);
 
-	blk_rq_init(NULL, &rq);
 	memset(&rqpm, 0, sizeof(rqpm));
 	memset(&args, 0, sizeof(args));
-	rq.cmd_type = REQ_TYPE_PM_RESUME;
-	rq.cmd_flags |= REQ_PREEMPT;
-	rq.special = &args;
-	rq.data = &rqpm;
+	rq = blk_get_request(drive->queue, READ, __GFP_WAIT);
+	rq->cmd_type = REQ_TYPE_PM_RESUME;
+	rq->cmd_flags |= REQ_PREEMPT;
+	rq->special = &args;
+	rq->data = &rqpm;
 	rqpm.pm_step = ide_pm_state_start_resume;
 	rqpm.pm_state = PM_EVENT_ON;
 
-	err = ide_do_drive_cmd(drive, &rq, ide_head_wait);
+	err = blk_execute_rq(drive->queue, NULL, rq, 1);
+	blk_put_request(rq);
 
 	if (err == 0 && dev->driver) {
 		ide_driver_t *drv = to_ide_driver(dev->driver);

commit e8a96aa71355edef9f40ce01459acf25c50cb78c
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Jul 15 21:21:41 2008 +0200

    ide: set REQ_PREEMPT request flag in ide_do_drive_cmd() users
    
    * Set REQ_PREEMPT request flag in ide_do_drive_cmd() users
      for ide_preempt and ide_head_wait action types.
    
    * Remove setting REQ_PREEMPT from ide_do_drive_cmd().
    
    While at it:
    
    * Set 'where' variable outside ide_lock.
    
    This is a preparation for converting IDE to use blk_execute_rq().
    
    There should be no functional changes caused by this patch.
    
    Cc: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Cc: Borislav Petkov <petkovbb@gmail.com>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 300431d080a9..c9a05721360e 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -606,6 +606,7 @@ static int generic_ide_resume(struct device *dev)
 	memset(&rqpm, 0, sizeof(rqpm));
 	memset(&args, 0, sizeof(args));
 	rq.cmd_type = REQ_TYPE_PM_RESUME;
+	rq.cmd_flags |= REQ_PREEMPT;
 	rq.special = &args;
 	rq.data = &rqpm;
 	rqpm.pm_step = ide_pm_state_start_resume;

commit 2b54ed9467697b0ce2d60d89e5e4253c9e322c26
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Jul 5 20:30:51 2008 +0200

    ide: ide_unregister() locking bugfix
    
    Holding ide_lock for ide_release_dma_engine() call is unnecessary
    and triggers WARN_ON(irqs_disabled()) in dma_free_coherent().
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index b31359c9fa58..300431d080a9 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -352,15 +352,15 @@ void ide_unregister(ide_hwif_t *hwif)
 	blk_unregister_region(MKDEV(hwif->major, 0), MAX_DRIVES<<PARTN_BITS);
 	kfree(hwif->sg_table);
 	unregister_blkdev(hwif->major, hwif->name);
-	spin_lock_irq(&ide_lock);
 
 	if (hwif->dma_base)
 		ide_release_dma_engine(hwif);
 
+	spin_lock_irq(&ide_lock);
 	/* restore hwif data to pristine status */
 	ide_init_port_data(hwif, hwif->index);
-
 	spin_unlock_irq(&ide_lock);
+
 	mutex_unlock(&ide_cfg_mtx);
 }
 

commit bd8a59e29726b2a5ff7baefe995febdc63044a61
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Jul 5 20:30:51 2008 +0200

    ide: ide_unregister() warm-plug bugfix
    
    Fix ide_unregister() to work for ports with no devices attached to them.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 246077792e21..b31359c9fa58 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -315,13 +315,14 @@ void ide_unregister(ide_hwif_t *hwif)
 
 	BUG_ON(in_interrupt());
 	BUG_ON(irqs_disabled());
+
 	mutex_lock(&ide_cfg_mtx);
-	spin_lock_irq(&ide_lock);
-	if (!hwif->present)
-		goto abort;
-	__ide_port_unregister_devices(hwif);
-	hwif->present = 0;
 
+	spin_lock_irq(&ide_lock);
+	if (hwif->present) {
+		__ide_port_unregister_devices(hwif);
+		hwif->present = 0;
+	}
 	spin_unlock_irq(&ide_lock);
 
 	ide_proc_unregister_port(hwif);
@@ -359,7 +360,6 @@ void ide_unregister(ide_hwif_t *hwif)
 	/* restore hwif data to pristine status */
 	ide_init_port_data(hwif, hwif->index);
 
-abort:
 	spin_unlock_irq(&ide_lock);
 	mutex_unlock(&ide_cfg_mtx);
 }

commit 7cd95f56cb61f5348d062527c9d3653196f6e629
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Jul 5 20:30:51 2008 +0200

    ide: fix hwif->gendev refcounting
    
    class->dev_release is called by device_release() iff dev->release
    is not present so ide_port_class_release() is never called and the
    last hwif->gendev reference is not dropped.
    
    Fix it by removing ide_port_class_release() and get_device() call
    from ide_register_port() (device_create_drvdata() takes a hwif->gendev
    reference anyway).
    
    This patch fixes hang on wait_for_completion(&hwif->gendev_rel_comp)
    in ide_unregister() reported by Pavel Machek.
    
    Cc: Pavel Machek <pavel@suse.cz>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index c758dcb13b14..246077792e21 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1094,13 +1094,6 @@ struct bus_type ide_bus_type = {
 
 EXPORT_SYMBOL_GPL(ide_bus_type);
 
-static void ide_port_class_release(struct device *portdev)
-{
-	ide_hwif_t *hwif = dev_get_drvdata(portdev);
-
-	put_device(&hwif->gendev);
-}
-
 int ide_vlb_clk;
 EXPORT_SYMBOL_GPL(ide_vlb_clk);
 
@@ -1305,7 +1298,6 @@ static int __init ide_init(void)
 		ret = PTR_ERR(ide_port_class);
 		goto out_port_class;
 	}
-	ide_port_class->dev_release = ide_port_class_release;
 
 	init_ide_data();
 

commit e7b241a7715d2a0885f779f5baa63711d71b1d75
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Tue Apr 29 09:54:38 2008 +0200

    ide: use blk_rq_init() to initialize the request
    
    This converts ide to use blk_rq_init to initialize the request.
    
    This is a preparation for large command support, which needs to
    initialize the request in a proper way (that is, just doing a memset()
    will not work).
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Cc: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 999584c03d97..c758dcb13b14 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -564,7 +564,7 @@ static int generic_ide_suspend(struct device *dev, pm_message_t mesg)
 	if (!(drive->dn % 2))
 		ide_acpi_get_timing(hwif);
 
-	memset(&rq, 0, sizeof(rq));
+	blk_rq_init(NULL, &rq);
 	memset(&rqpm, 0, sizeof(rqpm));
 	memset(&args, 0, sizeof(args));
 	rq.cmd_type = REQ_TYPE_PM_SUSPEND;
@@ -602,7 +602,7 @@ static int generic_ide_resume(struct device *dev)
 
 	ide_acpi_exec_tfs(drive);
 
-	memset(&rq, 0, sizeof(rq));
+	blk_rq_init(NULL, &rq);
 	memset(&rqpm, 0, sizeof(rqpm));
 	memset(&args, 0, sizeof(args));
 	rq.cmd_type = REQ_TYPE_PM_RESUME;

commit 4c3032d8a4d6c97bd6e02bcab524ef2428d89561
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sun Apr 27 15:38:32 2008 +0200

    ide: add struct ide_io_ports (take 3)
    
    * Add struct ide_io_ports and use it instead of `unsigned long io_ports[]`
      in ide_hwif_t.
    
    * Rename io_ports[] in hw_regs_t to io_ports_array[].
    
    * Use un-named union for 'unsigned long io_ports_array[]' and 'struct
      ide_io_ports io_ports' in hw_regs_t.
    
    * Remove IDE_*_OFFSET defines.
    
    v2:
    * scc_pata.c build fix from Stephen Rothwell.
    
    v3:
    * Fix ctl_adrr typo in Sparc-specific part of ns87415.c.
      (Noticed by Andrew Morton)
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 7bcc4c452255..999584c03d97 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -368,7 +368,7 @@ EXPORT_SYMBOL(ide_unregister);
 
 void ide_init_port_hw(ide_hwif_t *hwif, hw_regs_t *hw)
 {
-	memcpy(hwif->io_ports, hw->io_ports, sizeof(hwif->io_ports));
+	memcpy(&hwif->io_ports, &hw->io_ports, sizeof(hwif->io_ports));
 	hwif->irq = hw->irq;
 	hwif->chipset = hw->chipset;
 	hwif->gendev.parent = hw->dev;

commit 387750c3bf49c22f6189436032145e2131985076
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sun Apr 27 15:38:31 2008 +0200

    ide: make ide_unregister() take 'ide_hwif_t *' as an argument (take 2)
    
    * Make ide_unregister() take 'ide_hwif_t *hwif' instead of 'unsigned int
      index' (hwif->index) as an argument and update all users accordingly.
    
    While at it:
    
    * Remove unnecessary checks for hwif != NULL from ide-pnp.c::idepnp_remove()
      and delkin_cb.c::delkin_cb_remove().
    
    * Remove needless hwif->chipset assignment from scc_pata.c::scc_remove().
    
    v2:
    * Fixup ide_unregister() documentation.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 53c6a038e179..7bcc4c452255 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -287,7 +287,7 @@ EXPORT_SYMBOL_GPL(ide_port_unregister_devices);
 
 /**
  *	ide_unregister		-	free an IDE interface
- *	@index: index of interface (will change soon to a pointer)
+ *	@hwif: IDE interface
  *
  *	Perform the final unregister of an IDE interface. At the moment
  *	we don't refcount interfaces so this will also get split up.
@@ -307,19 +307,16 @@ EXPORT_SYMBOL_GPL(ide_port_unregister_devices);
  *	This is raving bonkers.
  */
 
-void ide_unregister(unsigned int index)
+void ide_unregister(ide_hwif_t *hwif)
 {
-	ide_hwif_t *hwif, *g;
+	ide_hwif_t *g;
 	ide_hwgroup_t *hwgroup;
 	int irq_count = 0;
 
-	BUG_ON(index >= MAX_HWIFS);
-
 	BUG_ON(in_interrupt());
 	BUG_ON(irqs_disabled());
 	mutex_lock(&ide_cfg_mtx);
 	spin_lock_irq(&ide_lock);
-	hwif = &ide_hwifs[index];
 	if (!hwif->present)
 		goto abort;
 	__ide_port_unregister_devices(hwif);
@@ -360,7 +357,7 @@ void ide_unregister(unsigned int index)
 		ide_release_dma_engine(hwif);
 
 	/* restore hwif data to pristine status */
-	ide_init_port_data(hwif, index);
+	ide_init_port_data(hwif, hwif->index);
 
 abort:
 	spin_unlock_irq(&ide_lock);

commit bf64b7a9ddc604883a1f41535d3d7a62bca9ee81
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sun Apr 27 15:38:31 2008 +0200

    ide: sanitize ide_unregister() usage
    
    * Remove ide_unregister() call from ide_exit()
      (host drivers take care of unregistering hwif-s themselves).
    
    * Remove ide_unregister() call from probe methods of
      bast-ide, palm_bk3710, ide-cs and delkin_cb host drivers
      (ide_find_port() returns only free ide_hwifs[] entries).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 78e49e8461a2..53c6a038e179 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1349,11 +1349,6 @@ int __init init_module (void)
 
 void __exit cleanup_module (void)
 {
-	int index;
-
-	for (index = 0; index < MAX_HWIFS; ++index)
-		ide_unregister(index);
-
 	proc_ide_destroy();
 
 	class_destroy(ide_port_class);

commit 1dbfeb4bc8fd0276750e5d1d454420f6c2da80e3
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sun Apr 27 15:38:30 2008 +0200

    ide: add "noacpi" / "acpigtf" / "acpionboot" parameters
    
    * Rename ide_noacpi{tfs,onboot} to ide_acpi{gtf,onboot} (+ reverse logic).
    
    * Move ide_*acpi* variables to ide-acpi.c and remove unnecessary initializers.
    
    * Add "noacpi" / "acpigtf" / "acpionboot" parameters.
    
    * Obsolete "ide=noacpi" / "ide=acpigtf" / "ide=acpionboot" kernel parameters.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index a017eb242604..78e49e8461a2 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -94,12 +94,6 @@ DEFINE_MUTEX(ide_cfg_mtx);
 
 int noautodma = 0;
 
-#ifdef CONFIG_BLK_DEV_IDEACPI
-int ide_noacpi = 0;
-int ide_noacpitfs = 1;
-int ide_noacpionboot = 1;
-#endif
-
 ide_hwif_t ide_hwifs[MAX_HWIFS];	/* master data repository */
 
 static void ide_port_init_devices_data(ide_hwif_t *);
@@ -880,17 +874,17 @@ static int __init ide_setup(char *s)
 	if (!strcmp(s, "ide=noacpi")) {
 		//printk(" : Disable IDE ACPI support.\n");
 		ide_noacpi = 1;
-		return 1;
+		goto obsolete_option;
 	}
 	if (!strcmp(s, "ide=acpigtf")) {
 		//printk(" : Enable IDE ACPI _GTF support.\n");
-		ide_noacpitfs = 0;
-		return 1;
+		ide_acpigtf = 1;
+		goto obsolete_option;
 	}
 	if (!strcmp(s, "ide=acpionboot")) {
 		//printk(" : Call IDE ACPI methods on boot.\n");
-		ide_noacpionboot = 0;
-		return 1;
+		ide_acpionboot = 1;
+		goto obsolete_option;
 	}
 #endif /* CONFIG_BLK_DEV_IDEACPI */
 

commit 9dcba7f2b7697db787741cf6698bf5c95130ffce
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sun Apr 27 15:38:30 2008 +0200

    gayle: add "doubler" parameter
    
    * Add "doubler" parameter to enable support for IDE doublers.
    
    * Obsolete "ide=doubler" kernel parameter.
    
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index a4bceeecde70..a017eb242604 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -866,7 +866,7 @@ static int __init ide_setup(char *s)
 
 		printk(" : Enabled support for IDE doublers\n");
 		ide_doubler = 1;
-		return 1;
+		goto obsolete_option;
 	}
 #endif /* CONFIG_BLK_DEV_IDEDOUBLER */
 

commit 4706a7e03a03d6d206a93a49a0c723dd612cf8e9
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sun Apr 27 15:38:30 2008 +0200

    ide: add "cdrom=" and "chs=" parameters
    
    * Add "cdrom=" and "chs=" parameters.
    
    * Obsolete "hdx=cdrom" and "hdx=cyls,heads,sects" kernel parameters.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index d8f40ee74ce8..a4bceeecde70 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -924,7 +924,7 @@ static int __init ide_setup(char *s)
 				drive->media = ide_cdrom;
 				/* an ATAPI device ignores DRDY */
 				drive->ready_stat = 0;
-				goto done;
+				goto obsolete_option;
 			case -5: /* nodma */
 				drive->nodma = 1;
 				goto obsolete_option;
@@ -948,7 +948,7 @@ static int __init ide_setup(char *s)
 				drive->sect	= drive->bios_sect = vals[2];
 				drive->present	= 1;
 				drive->forced_geom = 1;
-				goto done;
+				goto obsolete_option;
 			default:
 				goto bad_option;
 		}
@@ -975,9 +975,6 @@ static int __init ide_setup(char *s)
 obsolete_option:
 	printk(" -- OBSOLETE OPTION, WILL BE REMOVED SOON!\n");
 	return 1;
-done:
-	printk("\n");
-	return 1;
 }
 
 EXPORT_SYMBOL(ide_lock);
@@ -1167,6 +1164,51 @@ static unsigned int ide_nowerr;
 module_param_call(nowerr, ide_set_dev_param_mask, NULL, &ide_nowerr, 0);
 MODULE_PARM_DESC(nowerr, "ignore the WRERR_STAT bit for a device");
 
+static unsigned int ide_cdroms;
+
+module_param_call(cdrom, ide_set_dev_param_mask, NULL, &ide_cdroms, 0);
+MODULE_PARM_DESC(cdrom, "force device as a CD-ROM");
+
+struct chs_geom {
+	unsigned int	cyl;
+	u8		head;
+	u8		sect;
+};
+
+static unsigned int ide_disks;
+static struct chs_geom ide_disks_chs[MAX_HWIFS * MAX_DRIVES];
+
+static int ide_set_disk_chs(const char *str, struct kernel_param *kp)
+{
+	int a, b, c = 0, h = 0, s = 0, i, j = 1;
+
+	if (sscanf(str, "%d.%d:%d,%d,%d", &a, &b, &c, &h, &s) != 5 &&
+	    sscanf(str, "%d.%d:%d", &a, &b, &j) != 3)
+		return -EINVAL;
+
+	i = a * MAX_DRIVES + b;
+
+	if (i >= MAX_HWIFS * MAX_DRIVES || j < 0 || j > 1)
+		return -EINVAL;
+
+	if (c > INT_MAX || h > 255 || s > 255)
+		return -EINVAL;
+
+	if (j)
+		ide_disks |= (1 << i);
+	else
+		ide_disks &= (1 << i);
+
+	ide_disks_chs[i].cyl  = c;
+	ide_disks_chs[i].head = h;
+	ide_disks_chs[i].sect = s;
+
+	return 0;
+}
+
+module_param_call(chs, ide_set_disk_chs, NULL, NULL, 0);
+MODULE_PARM_DESC(chs, "force device as a disk (using CHS)");
+
 static void ide_dev_apply_params(ide_drive_t *drive)
 {
 	int i = drive->hwif->index * MAX_DRIVES + drive->select.b.unit;
@@ -1189,6 +1231,25 @@ static void ide_dev_apply_params(ide_drive_t *drive)
 				 drive->name);
 		drive->bad_wstat = BAD_R_STAT;
 	}
+	if (ide_cdroms & (1 << i)) {
+		printk(KERN_INFO "ide: forcing %s as a CD-ROM\n", drive->name);
+		drive->present = 1;
+		drive->media = ide_cdrom;
+		/* an ATAPI device ignores DRDY */
+		drive->ready_stat = 0;
+	}
+	if (ide_disks & (1 << i)) {
+		drive->cyl  = drive->bios_cyl  = ide_disks_chs[i].cyl;
+		drive->head = drive->bios_head = ide_disks_chs[i].head;
+		drive->sect = drive->bios_sect = ide_disks_chs[i].sect;
+		drive->forced_geom = 1;
+		printk(KERN_INFO "ide: forcing %s as a disk (%d/%d/%d)\n",
+				 drive->name,
+				 drive->cyl, drive->head, drive->sect);
+		drive->present = 1;
+		drive->media = ide_disk;
+		drive->ready_stat = READY_STAT;
+	}
 }
 
 static unsigned int ide_ignore_cable;

commit 6e87543a94fb2a966c81a61fc91246592f9719da
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sun Apr 27 15:38:30 2008 +0200

    ide: add "nodma|noflush|noprobe|nowerr=" parameters
    
    * Add "nodma|noflush|noprobe|nowerr=" parameters.
    
    * Obsolete "hdx=noprobe|none|nowerr|nodma|noflush" kernel parameters.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 71fa37979215..d8f40ee74ce8 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -915,10 +915,10 @@ static int __init ide_setup(char *s)
 			case -1: /* "none" */
 			case -2: /* "noprobe" */
 				drive->noprobe = 1;
-				goto done;
+				goto obsolete_option;
 			case -3: /* "nowerr" */
 				drive->bad_wstat = BAD_R_STAT;
-				goto done;
+				goto obsolete_option;
 			case -4: /* "cdrom" */
 				drive->present = 1;
 				drive->media = ide_cdrom;
@@ -927,10 +927,10 @@ static int __init ide_setup(char *s)
 				goto done;
 			case -5: /* nodma */
 				drive->nodma = 1;
-				goto done;
+				goto obsolete_option;
 			case -11: /* noflush */
 				drive->noflush = 1;
-				goto done;
+				goto obsolete_option;
 			case -12: /* "remap" */
 				drive->remap_0_to_1 = 1;
 				goto obsolete_option;
@@ -1125,6 +1125,72 @@ EXPORT_SYMBOL_GPL(ide_pci_clk);
 module_param_named(pci_clock, ide_pci_clk, int, 0);
 MODULE_PARM_DESC(pci_clock, "PCI bus clock frequency (in MHz)");
 
+static int ide_set_dev_param_mask(const char *s, struct kernel_param *kp)
+{
+	int a, b, i, j = 1;
+	unsigned int *dev_param_mask = (unsigned int *)kp->arg;
+
+	if (sscanf(s, "%d.%d:%d", &a, &b, &j) != 3 &&
+	    sscanf(s, "%d.%d", &a, &b) != 2)
+		return -EINVAL;
+
+	i = a * MAX_DRIVES + b;
+
+	if (i >= MAX_HWIFS * MAX_DRIVES || j < 0 || j > 1)
+		return -EINVAL;
+
+	if (j)
+		*dev_param_mask |= (1 << i);
+	else
+		*dev_param_mask &= (1 << i);
+
+	return 0;
+}
+
+static unsigned int ide_nodma;
+
+module_param_call(nodma, ide_set_dev_param_mask, NULL, &ide_nodma, 0);
+MODULE_PARM_DESC(nodma, "disallow DMA for a device");
+
+static unsigned int ide_noflush;
+
+module_param_call(noflush, ide_set_dev_param_mask, NULL, &ide_noflush, 0);
+MODULE_PARM_DESC(noflush, "disable flush requests for a device");
+
+static unsigned int ide_noprobe;
+
+module_param_call(noprobe, ide_set_dev_param_mask, NULL, &ide_noprobe, 0);
+MODULE_PARM_DESC(noprobe, "skip probing for a device");
+
+static unsigned int ide_nowerr;
+
+module_param_call(nowerr, ide_set_dev_param_mask, NULL, &ide_nowerr, 0);
+MODULE_PARM_DESC(nowerr, "ignore the WRERR_STAT bit for a device");
+
+static void ide_dev_apply_params(ide_drive_t *drive)
+{
+	int i = drive->hwif->index * MAX_DRIVES + drive->select.b.unit;
+
+	if (ide_nodma & (1 << i)) {
+		printk(KERN_INFO "ide: disallowing DMA for %s\n", drive->name);
+		drive->nodma = 1;
+	}
+	if (ide_noflush & (1 << i)) {
+		printk(KERN_INFO "ide: disabling flush requests for %s\n",
+				 drive->name);
+		drive->noflush = 1;
+	}
+	if (ide_noprobe & (1 << i)) {
+		printk(KERN_INFO "ide: skipping probe for %s\n", drive->name);
+		drive->noprobe = 1;
+	}
+	if (ide_nowerr & (1 << i)) {
+		printk(KERN_INFO "ide: ignoring the WRERR_STAT bit for %s\n",
+				 drive->name);
+		drive->bad_wstat = BAD_R_STAT;
+	}
+}
+
 static unsigned int ide_ignore_cable;
 
 static int ide_set_ignore_cable(const char *s, struct kernel_param *kp)
@@ -1150,11 +1216,16 @@ MODULE_PARM_DESC(ignore_cable, "ignore cable detection");
 
 void ide_port_apply_params(ide_hwif_t *hwif)
 {
+	int i;
+
 	if (ide_ignore_cable & (1 << hwif->index)) {
 		printk(KERN_INFO "ide: ignoring cable detection for %s\n",
 				 hwif->name);
 		hwif->cbl = ATA_CBL_PATA40_SHORT;
 	}
+
+	for (i = 0; i < MAX_DRIVES; i++)
+		ide_dev_apply_params(&hwif->drives[i]);
 }
 
 /*

commit 207daeaabb5396995ebac63415fab71476b64ca3
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sun Apr 27 15:38:29 2008 +0200

    ide: remove obsoleted "hdx=autotune" kernel parameter
    
    * Remove obsoleted "hdx=autotune" kernel parameter
      (we always auto-tune PIO if possible nowadays).
    
    * Remove no longer needed ide_drive_t.autotune flag.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index ad34fe98a23c..71fa37979215 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -900,7 +900,7 @@ static int __init ide_setup(char *s)
 	if (s[0] == 'h' && s[1] == 'd' && s[2] >= 'a' && s[2] <= max_drive) {
 		const char *hd_words[] = {
 			"none", "noprobe", "nowerr", "cdrom", "nodma",
-			"autotune", "-7", "-8", "-9", "-10",
+			"-6", "-7", "-8", "-9", "-10",
 			"noflush", "remap", "remap63", "scsi", NULL };
 		unit = s[2] - 'a';
 		hw   = unit / MAX_DRIVES;
@@ -928,9 +928,6 @@ static int __init ide_setup(char *s)
 			case -5: /* nodma */
 				drive->nodma = 1;
 				goto done;
-			case -6: /* "autotune" */
-				drive->autotune = 1;
-				goto obsolete_option;
 			case -11: /* noflush */
 				drive->noflush = 1;
 				goto done;

commit 73f1ad8670effa9849c3d42457fa2b58f139e013
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sun Apr 27 15:38:29 2008 +0200

    ide: mark "idebus=" kernel parameter as obsoleted (take 2)
    
    We have "vlb|pci_clock=" parameters now.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 3d1fc5fdc2b2..ad34fe98a23c 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -969,7 +969,7 @@ static int __init ide_setup(char *s)
 			idebus_parameter = vals[0];
 		} else
 			printk(" -- BAD BUS SPEED! Expected value from 20 to 66");
-		goto done;
+		goto obsolete_option;
 	}
 
 bad_option:

commit ebae41a5a0583fb732c41445df4ac2c41016df74
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sun Apr 27 15:38:29 2008 +0200

    ide: add "vlb|pci_clock=" parameter
    
    * Add "vlb_clock=" parameter for specifying VLB clock frequency (in MHz).
    
    * Add "pci_clock=" parameter for specifying PCI bus clock frequency (in MHz).
    
    While at it:
    
    * qd65xx.c: rename {active,recovery}_cycle variables to {act,rec}_cyc.
    
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 8eb7f83b0dda..3d1fc5fdc2b2 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1116,6 +1116,18 @@ static void ide_port_class_release(struct device *portdev)
 	put_device(&hwif->gendev);
 }
 
+int ide_vlb_clk;
+EXPORT_SYMBOL_GPL(ide_vlb_clk);
+
+module_param_named(vlb_clock, ide_vlb_clk, int, 0);
+MODULE_PARM_DESC(vlb_clock, "VLB clock frequency (in MHz)");
+
+int ide_pci_clk;
+EXPORT_SYMBOL_GPL(ide_pci_clk);
+
+module_param_named(pci_clock, ide_pci_clk, int, 0);
+MODULE_PARM_DESC(pci_clock, "PCI bus clock frequency (in MHz)");
+
 static unsigned int ide_ignore_cable;
 
 static int ide_set_ignore_cable(const char *s, struct kernel_param *kp)

commit cc12175ff2eadb0918d573169af88429440a21ae
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sun Apr 27 15:38:24 2008 +0200

    ide: remove obsoleted "hdx=noautotune" kernel parameter
    
    Remove obsoleted "hdx=noautotune" kernel parameter
    (it has been obsoleted since 1 Nov 2004).
    
    Then make ide_hwif_t.autotune a single bit flag
    and remove no longer needed IDE_TUNE_* defines.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index a33840d11770..8eb7f83b0dda 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -900,7 +900,7 @@ static int __init ide_setup(char *s)
 	if (s[0] == 'h' && s[1] == 'd' && s[2] >= 'a' && s[2] <= max_drive) {
 		const char *hd_words[] = {
 			"none", "noprobe", "nowerr", "cdrom", "nodma",
-			"autotune", "noautotune", "-8", "-9", "-10",
+			"autotune", "-7", "-8", "-9", "-10",
 			"noflush", "remap", "remap63", "scsi", NULL };
 		unit = s[2] - 'a';
 		hw   = unit / MAX_DRIVES;
@@ -929,10 +929,7 @@ static int __init ide_setup(char *s)
 				drive->nodma = 1;
 				goto done;
 			case -6: /* "autotune" */
-				drive->autotune = IDE_TUNE_AUTO;
-				goto obsolete_option;
-			case -7: /* "noautotune" */
-				drive->autotune = IDE_TUNE_NOAUTO;
+				drive->autotune = 1;
 				goto obsolete_option;
 			case -11: /* noflush */
 				drive->noflush = 1;

commit ef87f8d09639cbe22201c7dfe07586c43b255108
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sun Apr 27 15:38:24 2008 +0200

    ide: remove obsoleted "idex=" kernel parameters
    
    * Remove obsoleted "idex=" kernel parameters.
    
    * Make probe_* and cmd640_vlb variables static.
    
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 7ccf99a11fb6..a33840d11770 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -837,16 +837,6 @@ static int __init match_parm (char *s, const char *keywords[], int vals[], int m
 	return 0;	/* zero = nothing matched */
 }
 
-extern int probe_ali14xx;
-extern int probe_umc8672;
-extern int probe_dtc2278;
-extern int probe_ht6560b;
-extern int probe_qd65xx;
-extern int cmd640_vlb;
-extern int probe_4drives;
-
-static int __initdata is_chipset_set;
-
 /*
  * ide_setup() gets called VERY EARLY during initialization,
  * to handle kernel "command line" strings beginning with "hdx=" or "ide".
@@ -855,14 +845,12 @@ static int __initdata is_chipset_set;
  */
 static int __init ide_setup(char *s)
 {
-	int i, vals[3];
 	ide_hwif_t *hwif;
 	ide_drive_t *drive;
 	unsigned int hw, unit;
+	int vals[3];
 	const char max_drive = 'a' + ((MAX_HWIFS * MAX_DRIVES) - 1);
-	const char max_hwif  = '0' + (MAX_HWIFS - 1);
 
-	
 	if (strncmp(s,"hd",2) == 0 && s[2] == '=')	/* hd= is for hd.c   */
 		return 0;				/* driver and not us */
 
@@ -986,114 +974,13 @@ static int __init ide_setup(char *s)
 			printk(" -- BAD BUS SPEED! Expected value from 20 to 66");
 		goto done;
 	}
-	/*
-	 * Look for interface options:  "idex="
-	 */
-	if (s[3] >= '0' && s[3] <= max_hwif) {
-		/*
-		 * Be VERY CAREFUL changing this: note hardcoded indexes below
-		 * (-8, -9, -10) are reserved to ease the hardcoding.
-		 */
-		static const char *ide_words[] = {
-			"minus1", "minus2", "minus3", "minus4",
-			"minus5", "minus6", "ata66", "minus8", "minus9",
-			"minus10", "four", "qd65xx", "ht6560b", "cmd640_vlb",
-			"dtc2278", "umc8672", "ali14xx", NULL };
-
-		hw = s[3] - '0';
-		hwif = &ide_hwifs[hw];
-		i = match_parm(&s[4], ide_words, vals, 3);
-
-		/*
-		 * Cryptic check to ensure chipset not already set for hwif.
-		 * Note: we can't depend on hwif->chipset here.
-		 */
-		if (i >= -18 && i <= -11) {
-			/* chipset already specified */
-			if (is_chipset_set)
-				goto bad_option;
-			/* these drivers are for "ide0=" only */
-			if (hw != 0)
-				goto bad_hwif;
-			is_chipset_set = 1;
-			printk("\n");
-		}
 
-		switch (i) {
-#ifdef CONFIG_BLK_DEV_ALI14XX
-			case -17: /* "ali14xx" */
-				probe_ali14xx = 1;
-				goto obsolete_option;
-#endif
-#ifdef CONFIG_BLK_DEV_UMC8672
-			case -16: /* "umc8672" */
-				probe_umc8672 = 1;
-				goto obsolete_option;
-#endif
-#ifdef CONFIG_BLK_DEV_DTC2278
-			case -15: /* "dtc2278" */
-				probe_dtc2278 = 1;
-				goto obsolete_option;
-#endif
-#ifdef CONFIG_BLK_DEV_CMD640
-			case -14: /* "cmd640_vlb" */
-				cmd640_vlb = 1;
-				goto obsolete_option;
-#endif
-#ifdef CONFIG_BLK_DEV_HT6560B
-			case -13: /* "ht6560b" */
-				probe_ht6560b = 1;
-				goto obsolete_option;
-#endif
-#ifdef CONFIG_BLK_DEV_QD65XX
-			case -12: /* "qd65xx" */
-				probe_qd65xx = 1;
-				goto obsolete_option;
-#endif
-#ifdef CONFIG_BLK_DEV_4DRIVES
-			case -11: /* "four" drives on one set of ports */
-				probe_4drives = 1;
-				goto obsolete_option;
-#endif
-			case -10: /* minus10 */
-			case -9: /* minus9 */
-			case -8: /* minus8 */
-			case -6:
-			case -4:
-			case -3:
-				goto bad_option;
-			case -7: /* ata66 */
-#ifdef CONFIG_BLK_DEV_IDEPCI
-				/*
-				 * Use ATA_CBL_PATA40_SHORT so drive side
-				 * cable detection is also overriden.
-				 */
-				hwif->cbl = ATA_CBL_PATA40_SHORT;
-				goto obsolete_option;
-#else
-				goto bad_hwif;
-#endif
-			case -5:
-			case -2:
-			case -1:
-			case 0:
-			case 1:
-			case 2:
-			case 3:
-				goto bad_option;
-			default:
-				printk(" -- SUPPORT NOT CONFIGURED IN THIS KERNEL\n");
-				return 1;
-		}
-	}
 bad_option:
 	printk(" -- BAD OPTION\n");
 	return 1;
 obsolete_option:
 	printk(" -- OBSOLETE OPTION, WILL BE REMOVED SOON!\n");
 	return 1;
-bad_hwif:
-	printk("-- NOT SUPPORTED ON ide%d", hw);
 done:
 	printk("\n");
 	return 1;

commit e460a59751a7e53b549c63d4d308ba73582c8def
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sun Apr 27 15:38:24 2008 +0200

    ide: remove obsoleted "idex=reset" kernel parameter
    
    Remove obsoleted "idex=reset" kernel parameter
    (it has been obsoleted since 1 Nov 2004).
    
    Then remove corresponding code from ide_probe_port()
    and no longer used ->reset field from ide_hwif_t.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 3cac96f3b0aa..7ccf99a11fb6 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -996,7 +996,7 @@ static int __init ide_setup(char *s)
 		 */
 		static const char *ide_words[] = {
 			"minus1", "minus2", "minus3", "minus4",
-			"reset", "minus6", "ata66", "minus8", "minus9",
+			"minus5", "minus6", "ata66", "minus8", "minus9",
 			"minus10", "four", "qd65xx", "ht6560b", "cmd640_vlb",
 			"dtc2278", "umc8672", "ali14xx", NULL };
 
@@ -1073,9 +1073,7 @@ static int __init ide_setup(char *s)
 #else
 				goto bad_hwif;
 #endif
-			case -5: /* "reset" */
-				hwif->reset = 1;
-				goto obsolete_option;
+			case -5:
 			case -2:
 			case -1:
 			case 0:

commit 9dd4cf1fb949f6ba56b67078c09ef1b78f3c9421
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sun Apr 27 15:38:24 2008 +0200

    ide: remove obsoleted "idex=serialize" kernel parameter
    
    Remove obsoleted "idex=serialize" kernel parameter
    (it has been obsoleted since 1 Nov 2004).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 6cd112cc4af3..3cac96f3b0aa 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -995,7 +995,7 @@ static int __init ide_setup(char *s)
 		 * (-8, -9, -10) are reserved to ease the hardcoding.
 		 */
 		static const char *ide_words[] = {
-			"minus1", "serialize", "minus3", "minus4",
+			"minus1", "minus2", "minus3", "minus4",
 			"reset", "minus6", "ata66", "minus8", "minus9",
 			"minus10", "four", "qd65xx", "ht6560b", "cmd640_vlb",
 			"dtc2278", "umc8672", "ali14xx", NULL };
@@ -1076,12 +1076,7 @@ static int __init ide_setup(char *s)
 			case -5: /* "reset" */
 				hwif->reset = 1;
 				goto obsolete_option;
-			case -2: /* "serialize" */
-				hwif->mate = &ide_hwifs[hw^1];
-				hwif->mate->mate = hwif;
-				hwif->serialized = hwif->mate->serialized = 1;
-				goto obsolete_option;
-
+			case -2:
 			case -1:
 			case 0:
 			case 1:

commit 9fd91d959f1a19d1bfa46d97cbbbb55641ce26a6
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sun Apr 27 15:38:23 2008 +0200

    ide: add "ignore_cable" parameter (take 2)
    
    Add "ignore_cable" parameter:
    
    * "ide_core.ignore_cable=[interface_number]" boot option if IDE is built-in
      (i.e. "ide_core.ignore_cable=1" to force ignoring cable for "ide1")
    
    * "ignore_cable=[interface_number]" module parameter (for ide_core module)
      if IDE is compiled as module
    
    v2:
    * Add ide_port_apply_params() helper
      - use it in ide_device_add_all() and ide_scan_port().
    
    * Make it possible to later disable ignoring cable detection by passing
      "[interface_number]:0" to /sys/module/ide_core/parameters/ignore_cable
      (however sysfs interface is not enabled yet since it needs some other
       IDE changes to make it work reliable).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index bced02f9f2c3..6cd112cc4af3 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1239,6 +1239,38 @@ static void ide_port_class_release(struct device *portdev)
 	put_device(&hwif->gendev);
 }
 
+static unsigned int ide_ignore_cable;
+
+static int ide_set_ignore_cable(const char *s, struct kernel_param *kp)
+{
+	int i, j = 1;
+
+	if (sscanf(s, "%d:%d", &i, &j) != 2 && sscanf(s, "%d", &i) != 1)
+		return -EINVAL;
+
+	if (i >= MAX_HWIFS || j < 0 || j > 1)
+		return -EINVAL;
+
+	if (j)
+		ide_ignore_cable |= (1 << i);
+	else
+		ide_ignore_cable &= (1 << i);
+
+	return 0;
+}
+
+module_param_call(ignore_cable, ide_set_ignore_cable, NULL, NULL, 0);
+MODULE_PARM_DESC(ignore_cable, "ignore cable detection");
+
+void ide_port_apply_params(ide_hwif_t *hwif)
+{
+	if (ide_ignore_cable & (1 << hwif->index)) {
+		printk(KERN_INFO "ide: ignoring cable detection for %s\n",
+				 hwif->name);
+		hwif->cbl = ATA_CBL_PATA40_SHORT;
+	}
+}
+
 /*
  * This is gets invoked once during initialization, to set *everything* up
  */

commit 5e37bdc081a980dd0d669e6387bcf15ca9666f81
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 22:25:24 2008 +0200

    ide: add struct ide_dma_ops (take 3)
    
    Add struct ide_dma_ops and convert core code + drivers to use it.
    
    While at it:
    
    * Drop "ide_" prefix from ->ide_dma_end and ->ide_dma_test_irq methods.
    
    * Drop "ide_" "infixes" from DMA methods.
    
    * au1xxx-ide.c:
      - use auide_dma_{test_irq,end}() directly in auide_dma_timeout()
    
    * pdc202xx_old.c:
      - drop "old_" "infixes" from DMA methods
    
    * siimage.c:
      - add siimage_dma_test_irq() helper
      - print SATA warning in siimage_init_one()
    
    * Remove no longer needed ->init_hwif implementations.
    
    v2:
    * Changes based on review from Sergei:
      - s/siimage_ide_dma_test_irq/siimage_dma_test_irq/
      - s/drive->hwif/hwif/ in idefloppy_pc_intr().
      - fix patch description w.r.t. au1xxx-ide changes
      - fix au1xxx-ide build
      - fix naming for cmd64*_dma_ops
      - drop "ide_" and "old_" infixes
      - s/hpt3xxx_dma_ops/hpt37x_dma_ops/
      - s/hpt370x_dma_ops/hpt370_dma_ops/
      - use correct DMA ops for HPT302/N, HPT371/N and HPT374
      - s/it821x_smart_dma_ops/it821x_pass_through_dma_ops/
    
    v3:
    * Two bugs slipped in v2 (noticed by Sergei):
      - use correct DMA ops for HPT374 (for real this time)
      - handle HPT370/HPT370A properly
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 3d989c298ff4..bced02f9f2c3 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -469,7 +469,7 @@ int set_using_dma(ide_drive_t *drive, int arg)
 	if (!drive->id || !(drive->id->capability & 1))
 		goto out;
 
-	if (hwif->dma_host_set == NULL)
+	if (hwif->dma_ops == NULL)
 		goto out;
 
 	err = -EBUSY;

commit 5add22241752a3c689bea2a9d0e71c2a5909ed8a
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 22:25:19 2008 +0200

    ide: remove ide_hwif_request_regions()
    
    Remove no longer used ide_hwif_request_regions() and hwif_request_region().
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 694d997ce50f..3d989c298ff4 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -227,56 +227,6 @@ static int ide_system_bus_speed(void)
 	return pci_dev_present(pci_default) ? 33 : 50;
 }
 
-static struct resource* hwif_request_region(ide_hwif_t *hwif,
-					    unsigned long addr, int num)
-{
-	struct resource *res = request_region(addr, num, hwif->name);
-
-	if (!res)
-		printk(KERN_ERR "%s: I/O resource 0x%lX-0x%lX not free.\n",
-				hwif->name, addr, addr+num-1);
-	return res;
-}
-
-/**
- *	ide_hwif_request_regions - request resources for IDE
- *	@hwif: interface to use
- *
- *	Requests all the needed resources for an interface.
- *	Right now core IDE code does this work which is deeply wrong.
- *	MMIO leaves it to the controller driver,
- *	PIO will migrate this way over time.
- */
-
-int ide_hwif_request_regions(ide_hwif_t *hwif)
-{
-	unsigned long addr;
-
-	if (hwif->mmio)
-		return 0;
-
-	addr = hwif->io_ports[IDE_CONTROL_OFFSET];
-
-	if (addr && !hwif_request_region(hwif, addr, 1))
-		goto control_region_busy;
-
-	addr = hwif->io_ports[IDE_DATA_OFFSET];
-	BUG_ON((addr | 7) != hwif->io_ports[IDE_STATUS_OFFSET]);
-
-	if (!hwif_request_region(hwif, addr, 8))
-		goto data_region_busy;
-
-	return 0;
-
-data_region_busy:
-	addr = hwif->io_ports[IDE_CONTROL_OFFSET];
-	if (addr)
-		release_region(addr, 1);
-control_region_busy:
-	/* If any errors are return, we drop the hwif interface. */
-	return -EBUSY;
-}
-
 void ide_remove_port_from_hwgroup(ide_hwif_t *hwif)
 {
 	ide_hwgroup_t *hwgroup = hwif->hwgroup;

commit 0d1bad216c43bcee84cc24d1ed003c19134d2645
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 22:25:19 2008 +0200

    ide: manage resources for PCI devices in ide_pci_enable() (take 3)
    
    * Reserve PCI BARs 0-3 (0-1 for single port controllers) in
      ide_pci_enable() and remove ide_hwif_request_regions() call
      from ide_device_add_all() (also cleanup resource management
      in scc_pata host driver).
    
    * Fix handling of PCI BAR 4 in ide_pci_enable(), then cleanup
      ide_iomio_dma() (+ init_hwif_trm290() in trm290 host driver)
      and remove ide_release[_iomio]_dma().
    
    v2:
    * Fixup trm290 host driver.
    
    v3:
    * Because of scc_pata host driver changes we need to call
      pci_request_selected_regions() also in setup_mmio_scc().
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 629383dd37db..694d997ce50f 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -413,7 +413,7 @@ void ide_unregister(unsigned int index)
 	spin_lock_irq(&ide_lock);
 
 	if (hwif->dma_base)
-		(void)ide_release_dma(hwif);
+		ide_release_dma_engine(hwif);
 
 	/* restore hwif data to pristine status */
 	ide_init_port_data(hwif, index);

commit d083c03f2524af699a6b85cf4d2f8090242b1b84
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 22:25:17 2008 +0200

    ide: remove ide_hwif_release_regions()
    
    All host drivers using ide_unregister()/module_exit() have been fixed
    to manage resources themselves so this function can be removed now.
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 3be049067520..629383dd37db 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -277,29 +277,6 @@ int ide_hwif_request_regions(ide_hwif_t *hwif)
 	return -EBUSY;
 }
 
-/**
- *	ide_hwif_release_regions - free IDE resources
- *
- *	Note that we only release the standard ports,
- *	and do not even try to handle any extra ports
- *	allocated for weird IDE interface chipsets.
- *
- *	Note also that we don't yet handle mmio resources here. More
- *	importantly our caller should be doing this so we need to 
- *	restructure this as a helper function for drivers.
- */
-
-void ide_hwif_release_regions(ide_hwif_t *hwif)
-{
-	if (hwif->mmio)
-		return;
-
-	if (hwif->io_ports[IDE_CONTROL_OFFSET])
-		release_region(hwif->io_ports[IDE_CONTROL_OFFSET], 1);
-
-	release_region(hwif->io_ports[IDE_DATA_OFFSET], 8);
-}
-
 void ide_remove_port_from_hwgroup(ide_hwif_t *hwif)
 {
 	ide_hwgroup_t *hwgroup = hwif->hwgroup;
@@ -438,8 +415,6 @@ void ide_unregister(unsigned int index)
 	if (hwif->dma_base)
 		(void)ide_release_dma(hwif);
 
-	ide_hwif_release_regions(hwif);
-
 	/* restore hwif data to pristine status */
 	ide_init_port_data(hwif, index);
 

commit e53cd458d593c88247b8a7b2754d0e8055869670
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 22:25:16 2008 +0200

    ide: remove ->noprobe field from ide_hwif_t
    
    Update IDE PMAC host driver to use drive->noprobe instead of hwif->noprobe
    and remove hwif->noprobe completely (it is always set to zero now).
    
    There should be no functional changes caused by this patch.
    
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 91a3c8aff1e2..3be049067520 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -454,7 +454,6 @@ void ide_init_port_hw(ide_hwif_t *hwif, hw_regs_t *hw)
 {
 	memcpy(hwif->io_ports, hw->io_ports, sizeof(hwif->io_ports));
 	hwif->irq = hw->irq;
-	hwif->noprobe = 0;
 	hwif->chipset = hw->chipset;
 	hwif->gendev.parent = hw->dev;
 	hwif->ack_intr = hw->ack_intr;
@@ -1006,14 +1005,12 @@ static int __init ide_setup(char *s)
 				goto done;
 			case -3: /* "nowerr" */
 				drive->bad_wstat = BAD_R_STAT;
-				hwif->noprobe = 0;
 				goto done;
 			case -4: /* "cdrom" */
 				drive->present = 1;
 				drive->media = ide_cdrom;
 				/* an ATAPI device ignores DRDY */
 				drive->ready_stat = 0;
-				hwif->noprobe = 0;
 				goto done;
 			case -5: /* nodma */
 				drive->nodma = 1;
@@ -1044,7 +1041,6 @@ static int __init ide_setup(char *s)
 				drive->sect	= drive->bios_sect = vals[2];
 				drive->present	= 1;
 				drive->forced_geom = 1;
-				hwif->noprobe = 0;
 				goto done;
 			default:
 				goto bad_option;

commit ac95beedf8bc97b24f9540d4da9952f07221c023
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 22:25:14 2008 +0200

    ide: add struct ide_port_ops (take 2)
    
    * Move hooks for port/host specific methods from ide_hwif_t to
      'struct ide_port_ops'.
    
    * Add 'const struct ide_port_ops *port_ops' to 'struct ide_port_info'
      and ide_hwif_t.
    
    * Update host drivers and core code accordingly.
    
    While at it:
    
    * Rename ata66_*() cable detect functions to *_cable_detect() to match
      the standard naming. (Suggested by Sergei Shtylyov)
    
    v2:
    * Fix build for bast-ide. (Noticed by Andrew Morton)
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index d868ca44d033..91a3c8aff1e2 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -585,11 +585,12 @@ int set_pio_mode(ide_drive_t *drive, int arg)
 {
 	struct request rq;
 	ide_hwif_t *hwif = drive->hwif;
+	const struct ide_port_ops *port_ops = hwif->port_ops;
 
 	if (arg < 0 || arg > 255)
 		return -EINVAL;
 
-	if (hwif->set_pio_mode == NULL ||
+	if (port_ops == NULL || port_ops->set_pio_mode == NULL ||
 	    (hwif->host_flags & IDE_HFLAG_NO_SET_MODE))
 		return -ENOSYS;
 

commit 784506cbddd17bcd5929f827df39b0c7014e3f1e
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 17:36:43 2008 +0200

    ide: sanitize handling of IDE_HFLAG_NO_SET_MODE host flag
    
    * Check for IDE_HFLAG_NO_SET_MODE host flag in ide_set_pio(),
      ide_set_[pio,dma]_mode(), ide_set_xfer_rate() and set_pio_mode().
    
    * Remove no longer needed IDE_HFLAG_NO_SET_MODE host flag checking
      from ide_tune_dma().
    
    * Remove superfluous ->set_pio_mode checking from do_special().
    
    This is a part of preparations for adding 'struct ide_port_ops'.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index f04b53cb023f..d868ca44d033 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -584,11 +584,13 @@ int set_using_dma(ide_drive_t *drive, int arg)
 int set_pio_mode(ide_drive_t *drive, int arg)
 {
 	struct request rq;
+	ide_hwif_t *hwif = drive->hwif;
 
 	if (arg < 0 || arg > 255)
 		return -EINVAL;
 
-	if (drive->hwif->set_pio_mode == NULL)
+	if (hwif->set_pio_mode == NULL ||
+	    (hwif->host_flags & IDE_HFLAG_NO_SET_MODE))
 		return -ENOSYS;
 
 	if (drive->special.b.set_tune)

commit 05230e23cf02d939865a902f6ec4c1b2c82faf33
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 17:36:39 2008 +0200

    ide: remove hwif->straight8 flag
    
    All host drivers now either set hwif->mmio or reserve continuous
    I/O resources so remove no longer needed hwif->straight8 flag
    and never reached code for 'hwif->straight8 == 0' case.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index b7a040ef12fa..f04b53cb023f 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -251,29 +251,21 @@ static struct resource* hwif_request_region(ide_hwif_t *hwif,
 int ide_hwif_request_regions(ide_hwif_t *hwif)
 {
 	unsigned long addr;
-	unsigned int i;
 
 	if (hwif->mmio)
 		return 0;
+
 	addr = hwif->io_ports[IDE_CONTROL_OFFSET];
+
 	if (addr && !hwif_request_region(hwif, addr, 1))
 		goto control_region_busy;
-	hwif->straight8 = 0;
+
 	addr = hwif->io_ports[IDE_DATA_OFFSET];
-	if ((addr | 7) == hwif->io_ports[IDE_STATUS_OFFSET]) {
-		if (!hwif_request_region(hwif, addr, 8))
-			goto data_region_busy;
-		hwif->straight8 = 1;
-		return 0;
-	}
-	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++) {
-		addr = hwif->io_ports[i];
-		if (!hwif_request_region(hwif, addr, 1)) {
-			while (--i)
-				release_region(addr, 1);
-			goto data_region_busy;
-		}
-	}
+	BUG_ON((addr | 7) != hwif->io_ports[IDE_STATUS_OFFSET]);
+
+	if (!hwif_request_region(hwif, addr, 8))
+		goto data_region_busy;
+
 	return 0;
 
 data_region_busy:
@@ -299,19 +291,13 @@ int ide_hwif_request_regions(ide_hwif_t *hwif)
 
 void ide_hwif_release_regions(ide_hwif_t *hwif)
 {
-	u32 i = 0;
-
 	if (hwif->mmio)
 		return;
+
 	if (hwif->io_ports[IDE_CONTROL_OFFSET])
 		release_region(hwif->io_ports[IDE_CONTROL_OFFSET], 1);
-	if (hwif->straight8) {
-		release_region(hwif->io_ports[IDE_DATA_OFFSET], 8);
-		return;
-	}
-	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++)
-		if (hwif->io_ports[i])
-			release_region(hwif->io_ports[i], 1);
+
+	release_region(hwif->io_ports[IDE_DATA_OFFSET], 8);
 }
 
 void ide_remove_port_from_hwgroup(ide_hwif_t *hwif)

commit 1a2f84ea3e5110872b9aa86763360609b4b04e1b
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 17:36:36 2008 +0200

    ide: unexport ide_hwifs[]
    
    All modular users have been fixed to not reference ide_hwifs[] directly.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index f338fe96ff6d..b7a040ef12fa 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -100,13 +100,8 @@ int ide_noacpitfs = 1;
 int ide_noacpionboot = 1;
 #endif
 
-/*
- * This is declared extern in ide.h, for access by other IDE modules:
- */
 ide_hwif_t ide_hwifs[MAX_HWIFS];	/* master data repository */
 
-EXPORT_SYMBOL(ide_hwifs);
-
 static void ide_port_init_devices_data(ide_hwif_t *);
 
 /*

commit fe80b937c9917887e4fbfaaf52f498b5ac3a6999
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 17:36:36 2008 +0200

    ide: merge ide_match_hwif() and ide_find_port()
    
    * Change ide_match_hwif() argument from 'u8 bootable' to
      'struct ide_port_info *d'.
    
    * Move ide_match_hwif() to ide-probe.c from setup-pci.c and rename
      it to ide_find_port_slot().  Update some comments while at it.
    
    * ide_find_port() can be now just a wrapper for ide_find_port_slot().
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 4ca511156a11..f338fe96ff6d 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -232,21 +232,6 @@ static int ide_system_bus_speed(void)
 	return pci_dev_present(pci_default) ? 33 : 50;
 }
 
-ide_hwif_t *ide_find_port(void)
-{
-	ide_hwif_t *hwif;
-	int i;
-
-	for (i = 0; i < MAX_HWIFS; i++) {
-		hwif = &ide_hwifs[i];
-		if (hwif->chipset == ide_unknown)
-			return hwif;
-	}
-
-	return NULL;
-}
-EXPORT_SYMBOL_GPL(ide_find_port);
-
 static struct resource* hwif_request_region(ide_hwif_t *hwif,
 					    unsigned long addr, int num)
 {

commit 59bff5ba5529feac3a0214d897b1920cbe4e2278
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Apr 26 17:36:32 2008 +0200

    ide: cleanup ide_find_port()
    
    Remove no longer needed matching against I/O base and 'base' argument.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 917c72dcd33d..4ca511156a11 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -232,28 +232,19 @@ static int ide_system_bus_speed(void)
 	return pci_dev_present(pci_default) ? 33 : 50;
 }
 
-ide_hwif_t * ide_find_port(unsigned long base)
+ide_hwif_t *ide_find_port(void)
 {
 	ide_hwif_t *hwif;
 	int i;
 
-	for (i = 0; i < MAX_HWIFS; i++) {
-		hwif = &ide_hwifs[i];
-		if (hwif->io_ports[IDE_DATA_OFFSET] == base)
-			goto found;
-	}
-
 	for (i = 0; i < MAX_HWIFS; i++) {
 		hwif = &ide_hwifs[i];
 		if (hwif->chipset == ide_unknown)
-			goto found;
+			return hwif;
 	}
 
-	hwif = NULL;
-found:
-	return hwif;
+	return NULL;
 }
-
 EXPORT_SYMBOL_GPL(ide_find_port);
 
 static struct resource* hwif_request_region(ide_hwif_t *hwif,

commit 486c92e2900d618c650a7099536310651aa6cf1b
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Apr 18 00:46:35 2008 +0200

    ide: move default IDE ports setup to ide_generic host driver
    
    * Make CONFIG_IDE_GENERIC depended on CONFIG_IDE_ARCH_OBSOLETE_DEFAULTS.
    
    * Move default IDE ports setup from init_ide_data() to ide_generic.
    
    * Use ide_init_port_hw() in ide_generic.
    
    * Remove no longer needed CONFIG_IDE_ARCH_OBSOLETE_DEFAULTS.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index aa809aded87f..917c72dcd33d 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -165,11 +165,6 @@ static void ide_port_init_devices_data(ide_hwif_t *hwif)
 	}
 }
 
-#ifndef CONFIG_IDE_ARCH_OBSOLETE_DEFAULTS
-# define ide_default_io_base(index)	(0)
-# define ide_init_default_irq(base)	(0)
-#endif
-
 /*
  * init_ide_data() sets reasonable default values into all fields
  * of all instances of the hwifs and drives, but only on the first call.
@@ -192,7 +187,6 @@ static void __init init_ide_data (void)
 {
 	unsigned int index;
 	static unsigned long magic_cookie = MAGIC_COOKIE;
-	hw_regs_t hw;
 
 	if (magic_cookie != MAGIC_COOKIE)
 		return;		/* already initialized */
@@ -201,19 +195,8 @@ static void __init init_ide_data (void)
 	/* Initialise all interface structures */
 	for (index = 0; index < MAX_HWIFS; ++index) {
 		ide_hwif_t *hwif = &ide_hwifs[index];
-		unsigned long io_addr = ide_default_io_base(index);
-		unsigned long ctl_addr = io_addr + 0x206;
 
 		ide_init_port_data(hwif, index);
-
-#ifdef CONFIG_IDE_ARCH_OBSOLETE_DEFAULTS
-		memset(&hw, 0, sizeof(hw));
-		ide_std_init_ports(&hw, io_addr, ctl_addr);
-		memcpy(hwif->io_ports, hw.io_ports, sizeof(hw.io_ports));
-		hwif->noprobe = !hwif->io_ports[IDE_DATA_OFFSET];
-		hwif->irq =
-			ide_init_default_irq(hwif->io_ports[IDE_DATA_OFFSET]);
-#endif
 	}
 }
 

commit f01674e459923c6df540e6c983d37e5fc94d43b8
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Apr 18 00:46:35 2008 +0200

    ide: remove obsoleted "idex=noprobe" kernel parameter (take 2)
    
    * Remove obsoleted "idex=noprobe" kernel parameter.
    
    * Remove no longer needed hwif->noprobe quirk from ide_hwif_configure()
      and hwif->noprobe checking from cmd640.c.
    
    v2:
    * "ide?=noprobe" -> "ide?=ata66" in Documentation/kernel-parameters.txt.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 690b5ff4d88f..aa809aded87f 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1131,7 +1131,7 @@ static int __init ide_setup(char *s)
 		 * (-8, -9, -10) are reserved to ease the hardcoding.
 		 */
 		static const char *ide_words[] = {
-			"noprobe", "serialize", "minus3", "minus4",
+			"minus1", "serialize", "minus3", "minus4",
 			"reset", "minus6", "ata66", "minus8", "minus9",
 			"minus10", "four", "qd65xx", "ht6560b", "cmd640_vlb",
 			"dtc2278", "umc8672", "ali14xx", NULL };
@@ -1218,9 +1218,7 @@ static int __init ide_setup(char *s)
 				hwif->serialized = hwif->mate->serialized = 1;
 				goto obsolete_option;
 
-			case -1: /* "noprobe" */
-				hwif->noprobe = 1;
-				goto obsolete_option;
+			case -1:
 			case 0:
 			case 1:
 			case 2:

commit ffd4f6f0eed0423652826f3775077d11918b4180
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Apr 18 00:46:34 2008 +0200

    ide: add ide-4drives host driver (take 3)
    
    CONFIG_BLK_DEV_4DRIVES deserves its own host driver:
    
    * Add drivers/ide/legacy/ide-4drives.c and move "4drives" support there.
    
    * Add ide-4drives.o in the link order after all other legacy host
      drivers enabled by "ide0=" options (they all are mutually exclusive).
    
    * Make ide-4drives host driver probe itself for IDE devices instead of
      indirectly depending on ide_generic host driver.
    
    * Add "probe" module parameter to ide-4drives and update documentation.
    
    v2:
    * s/paramater/parameter/ in ide.txt. (Noticed by Randy Dunlap)
    
    v3:
    * s/ide_4drives.probe/ide-4drives.probe/ in help entry.
      (Noticed by Sergei Shtylyov)
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index adecf45a0849..690b5ff4d88f 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -976,6 +976,7 @@ extern int probe_dtc2278;
 extern int probe_ht6560b;
 extern int probe_qd65xx;
 extern int cmd640_vlb;
+extern int probe_4drives;
 
 static int __initdata is_chipset_set;
 
@@ -1187,19 +1188,9 @@ static int __init ide_setup(char *s)
 #endif
 #ifdef CONFIG_BLK_DEV_4DRIVES
 			case -11: /* "four" drives on one set of ports */
-			{
-				ide_hwif_t *mate = &ide_hwifs[hw^1];
-				mate->drives[0].select.all ^= 0x20;
-				mate->drives[1].select.all ^= 0x20;
-				hwif->chipset = mate->chipset = ide_4drives;
-				mate->irq = hwif->irq;
-				memcpy(mate->io_ports, hwif->io_ports, sizeof(hwif->io_ports));
-				hwif->mate = mate;
-				mate->mate = hwif;
-				hwif->serialized = mate->serialized = 1;
+				probe_4drives = 1;
 				goto obsolete_option;
-			}
-#endif /* CONFIG_BLK_DEV_4DRIVES */
+#endif
 			case -10: /* minus10 */
 			case -9: /* minus9 */
 			case -8: /* minus8 */

commit 26d799b729003220c0f3e5d9e046e1588c011897
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Apr 18 00:46:34 2008 +0200

    ide: remove ppc ifdef from init_ide_data()
    
    On PPC32 ide_init_default_irq() is non-zero only for PPLUS and PPC_PREP
    (the latter marked as BROKEN currently) so this ifdef can be removed.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index a93f127b8bf2..adecf45a0849 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -211,10 +211,8 @@ static void __init init_ide_data (void)
 		ide_std_init_ports(&hw, io_addr, ctl_addr);
 		memcpy(hwif->io_ports, hw.io_ports, sizeof(hw.io_ports));
 		hwif->noprobe = !hwif->io_ports[IDE_DATA_OFFSET];
-#if !defined(CONFIG_PPC32) || defined(CONFIG_PPLUS) || !defined(CONFIG_PCI)
 		hwif->irq =
 			ide_init_default_irq(hwif->io_ports[IDE_DATA_OFFSET]);
-#endif
 #endif
 	}
 }

commit 9dfcd15a6dc1ef81307295e08b797fa9212be71a
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Apr 18 00:46:34 2008 +0200

    ide: remove ide_default_io_ctl() macro
    
    It is always == '((base) + 0x206)' if CONFIG_IDE_ARCH_OBSOLETE_DEFAULTS=y
    and it is not needed otherwise (arm, blackfin, parisc, ppc64, sh, sparc[64]).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 9b9b686fbacb..a93f127b8bf2 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -202,7 +202,7 @@ static void __init init_ide_data (void)
 	for (index = 0; index < MAX_HWIFS; ++index) {
 		ide_hwif_t *hwif = &ide_hwifs[index];
 		unsigned long io_addr = ide_default_io_base(index);
-		unsigned long ctl_addr = ide_default_io_ctl(io_addr);
+		unsigned long ctl_addr = io_addr + 0x206;
 
 		ide_init_port_data(hwif, index);
 

commit 5c50427090303a6552949c14128200154ff69594
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Apr 18 00:46:33 2008 +0200

    ide: remove CONFIG_IDE_ARCH_OBSOLETE_INIT
    
    * Use CONFIG_IDE_ARCH_OBSOLETE_DEFAULTS instead of
      CONFIG_IDE_ARCH_OBSOLETE_INIT in init_ide_data().
    
    * Remove no longer needed CONFIG_IDE_ARCH_OBSOLETE_INIT.
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index a1a02c74d77f..9b9b686fbacb 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -206,15 +206,15 @@ static void __init init_ide_data (void)
 
 		ide_init_port_data(hwif, index);
 
-#ifdef CONFIG_IDE_ARCH_OBSOLETE_INIT
+#ifdef CONFIG_IDE_ARCH_OBSOLETE_DEFAULTS
 		memset(&hw, 0, sizeof(hw));
 		ide_std_init_ports(&hw, io_addr, ctl_addr);
 		memcpy(hwif->io_ports, hw.io_ports, sizeof(hw.io_ports));
-#endif
 		hwif->noprobe = !hwif->io_ports[IDE_DATA_OFFSET];
 #if !defined(CONFIG_PPC32) || defined(CONFIG_PPLUS) || !defined(CONFIG_PCI)
 		hwif->irq =
 			ide_init_default_irq(hwif->io_ports[IDE_DATA_OFFSET]);
+#endif
 #endif
 	}
 }

commit 0e33555fffdc8490630d98070e76e5fe031bcac2
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Apr 18 00:46:33 2008 +0200

    ide: add CONFIG_IDE_ARCH_OBSOLETE_DEFAULTS (take 2)
    
    * Add CONFIG_IDE_ARCH_OBSOLETE_DEFAULTS to drivers/ide/Kconfig and use
      it instead of defining IDE_ARCH_OBSOLETE_DEFAULTS in <arch/ide.h>.
    
    v2:
    * Define ide_default_irq() in ide-probe.c/ns87415.c if not already defined
      and drop defining ide_default_irq() for CONFIG_IDE_ARCH_OBSOLETE_DEFAULTS=n.
    
      [ Thanks to Stephen Rothwell and David Miller for noticing the problem. ]
    
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: David Miller <davem@davemloft.net>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index c2fb5c964a51..a1a02c74d77f 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -165,6 +165,10 @@ static void ide_port_init_devices_data(ide_hwif_t *hwif)
 	}
 }
 
+#ifndef CONFIG_IDE_ARCH_OBSOLETE_DEFAULTS
+# define ide_default_io_base(index)	(0)
+# define ide_init_default_irq(base)	(0)
+#endif
 
 /*
  * init_ide_data() sets reasonable default values into all fields

commit 1d850bd0b291efd1740b8d87ce025363436eb6dc
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Apr 18 00:46:32 2008 +0200

    ppc: remove ppc_ide_md
    
    * Add special cases for pplus and prep to ide_default_{irq,io_base}()
      (+ FIXMEs about the need to use IDE platform host driver instead).
    
    * Remove no longer needed ppc_ide_md and struct ide_machdep_calls.
    
    * Then remove <linux/ide.h> include from:
      - arch/powerpc/kernel/setup_32.c
      - arch/ppc/kernel/ppc_ksyms.c
      - arch/ppc/kernel/setup.c
      - arch/ppc/platforms/pplus.c
      - arch/ppc/platforms/prep_setup.c
    
    There should be no functional changes caused by this patch.
    
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 7e6418fe3a84..c2fb5c964a51 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -205,10 +205,6 @@ static void __init init_ide_data (void)
 #ifdef CONFIG_IDE_ARCH_OBSOLETE_INIT
 		memset(&hw, 0, sizeof(hw));
 		ide_std_init_ports(&hw, io_addr, ctl_addr);
-# ifdef CONFIG_PPC32
-		if (ppc_ide_md.ide_init_hwif)
-			ppc_ide_md.ide_init_hwif(&hw, io_addr, 0, &hwif->irq);
-# endif
 		memcpy(hwif->io_ports, hw.io_ports, sizeof(hw.io_ports));
 #endif
 		hwif->noprobe = !hwif->io_ports[IDE_DATA_OFFSET];

commit 5d682e4407d8364c286650baafcccae54d4b7c89
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Apr 18 00:46:31 2008 +0200

    ppc/pplus: remove ppc_ide_md.ide_init_hwif hook
    
    * Call ide_init_default_irq() for pplus in init_ide_data().
    
    * Remove no longer needed pplus_ide_init_hwif_ports().
    
    There should be no functional changes caused by this patch.
    
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 9e4d503bc716..7e6418fe3a84 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -212,7 +212,7 @@ static void __init init_ide_data (void)
 		memcpy(hwif->io_ports, hw.io_ports, sizeof(hw.io_ports));
 #endif
 		hwif->noprobe = !hwif->io_ports[IDE_DATA_OFFSET];
-#if !defined(CONFIG_PPC32) || !defined(CONFIG_PCI)
+#if !defined(CONFIG_PPC32) || defined(CONFIG_PPLUS) || !defined(CONFIG_PCI)
 		hwif->irq =
 			ide_init_default_irq(hwif->io_ports[IDE_DATA_OFFSET]);
 #endif

commit e6bfa38a4803646e212ef542b957344e790c3733
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Apr 18 00:46:25 2008 +0200

    ide: remove ide_init_hwif_ports()
    
    ide_init_hwif_ports() is only used by init_ide_data() now, inline it there.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index a60b956db519..9e4d503bc716 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -197,13 +197,20 @@ static void __init init_ide_data (void)
 	/* Initialise all interface structures */
 	for (index = 0; index < MAX_HWIFS; ++index) {
 		ide_hwif_t *hwif = &ide_hwifs[index];
+		unsigned long io_addr = ide_default_io_base(index);
+		unsigned long ctl_addr = ide_default_io_ctl(io_addr);
 
 		ide_init_port_data(hwif, index);
 
+#ifdef CONFIG_IDE_ARCH_OBSOLETE_INIT
 		memset(&hw, 0, sizeof(hw));
-		ide_init_hwif_ports(&hw, ide_default_io_base(index), 0,
-				    &hwif->irq);
+		ide_std_init_ports(&hw, io_addr, ctl_addr);
+# ifdef CONFIG_PPC32
+		if (ppc_ide_md.ide_init_hwif)
+			ppc_ide_md.ide_init_hwif(&hw, io_addr, 0, &hwif->irq);
+# endif
 		memcpy(hwif->io_ports, hw.io_ports, sizeof(hw.io_ports));
+#endif
 		hwif->noprobe = !hwif->io_ports[IDE_DATA_OFFSET];
 #if !defined(CONFIG_PPC32) || !defined(CONFIG_PCI)
 		hwif->irq =

commit 05734266c07ac588d1773bd9ae51a0ff20456443
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Apr 18 00:46:25 2008 +0200

    ide: remove init_hwif_default()
    
    init_hwif_default() is only used by init_ide_data() now, inline it there.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 1121d9cb2a9b..a60b956db519 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -166,19 +166,6 @@ static void ide_port_init_devices_data(ide_hwif_t *hwif)
 }
 
 
-static void init_hwif_default(ide_hwif_t *hwif, unsigned int index)
-{
-	hw_regs_t hw;
-
-	memset(&hw, 0, sizeof(hw_regs_t));
-
-	ide_init_hwif_ports(&hw, ide_default_io_base(index), 0, &hwif->irq);
-
-	memcpy(hwif->io_ports, hw.io_ports, sizeof(hw.io_ports));
-
-	hwif->noprobe = !hwif->io_ports[IDE_DATA_OFFSET];
-}
-
 /*
  * init_ide_data() sets reasonable default values into all fields
  * of all instances of the hwifs and drives, but only on the first call.
@@ -199,9 +186,9 @@ static void init_hwif_default(ide_hwif_t *hwif, unsigned int index)
 #define MAGIC_COOKIE 0x12345678
 static void __init init_ide_data (void)
 {
-	ide_hwif_t *hwif;
 	unsigned int index;
 	static unsigned long magic_cookie = MAGIC_COOKIE;
+	hw_regs_t hw;
 
 	if (magic_cookie != MAGIC_COOKIE)
 		return;		/* already initialized */
@@ -209,9 +196,15 @@ static void __init init_ide_data (void)
 
 	/* Initialise all interface structures */
 	for (index = 0; index < MAX_HWIFS; ++index) {
-		hwif = &ide_hwifs[index];
+		ide_hwif_t *hwif = &ide_hwifs[index];
+
 		ide_init_port_data(hwif, index);
-		init_hwif_default(hwif, index);
+
+		memset(&hw, 0, sizeof(hw));
+		ide_init_hwif_ports(&hw, ide_default_io_base(index), 0,
+				    &hwif->irq);
+		memcpy(hwif->io_ports, hw.io_ports, sizeof(hw.io_ports));
+		hwif->noprobe = !hwif->io_ports[IDE_DATA_OFFSET];
 #if !defined(CONFIG_PPC32) || !defined(CONFIG_PCI)
 		hwif->irq =
 			ide_init_default_irq(hwif->io_ports[IDE_DATA_OFFSET]);

commit 93de00fd1c70e1a23a73a865e0f9abfe74a7a719
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Apr 18 00:46:24 2008 +0200

    ide: remove broken/dangerous HDIO_[UNREGISTER,SCAN]_HWIF ioctls (take 3)
    
    hdparm explicitely marks HDIO_[UNREGISTER,SCAN]_HWIF ioctls as DANGEROUS
    and given the number of bugs we can assume that there are no real users:
    
    * DMA has no chance of working because DMA resources are released by
      ide_unregister() and they are never allocated again.
    
    * Since ide_init_hwif_ports() is used for ->io_ports[] setup the ioctls
      don't work for almost all hosts with "non-standard" (== non ISA-like)
      layout of IDE taskfile registers (there is a lot of such host drivers).
    
    * ide_port_init_devices() is not called when probing IDE devices so:
      - drive->autotune is never set and IDE host/devices are not programmed
        for the correct PIO/DMA transfer modes (=> possible data corruption)
      - host specific I/O 32-bit and IRQ unmasking settings are not applied
        (=> possible data corruption)
      - host specific ->port_init_devs method is not called (=> no luck with
        ht6560b, qd65xx and opti621 host drivers)
    
    * ->rw_disk method is not preserved (=> no HPT3xxN chipsets support).
    
    * ->serialized flag is not preserved (=> possible data corruption when
       using icside, aec62xx (ATP850UF chipset), cmd640, cs5530, hpt366
       (HPT3xxN chipsets), rz1000, sc1200, dtc2278 and ht6560b host drivers).
    
    * ->ack_intr method is not preserved (=> needed by ide-cris, buddha,
      gayle and macide host drivers).
    
    * ->sata_scr[] and sata_misc[] is cleared by ide_unregister() and it
      isn't initialized again (SiI3112 support needs them).
    
    * To issue an ioctl() there need to be at least one IDE device present
      in the system.
    
    * ->cable_detect method is not preserved + it is not called when probing
      IDE devices so cable detection is broken (however since DMA support is
      also broken it doesn't really matter ;-).
    
    * Some objects which may have already been freed in ide_unregister()
      are restored by ide_hwif_restore() (i.e. ->hwgroup).
    
    * ide_register_hw() may unregister unrelated IDE ports if free ide_hwifs[]
      slot cannot be found.
    
    * When IDE host drivers are modular unregistered port may be re-used by
      different host driver that owned it first causing subtle bugs.
    
    Since we now have a proper warm-plug support remove these ioctls,
    then remove no longer needed:
    - ide_register_hw() and ide_hwif_restore() functions
    - 'init_default' and 'restore' arguments of ide_unregister()
    - zeroeing of hwif->{dma,extra}_* fields in ide_unregister()
    
    As an added bonus IDE core code size shrinks by ~3kB (x86-32).
    
    v2:
    * fix ide_unregister() arguments in cleanup_module() (Andrew Morton).
    
    v3:
    * fix ide_unregister() arguments in palm_bk3710.c.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 7e789c97a8b8..1121d9cb2a9b 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -362,107 +362,6 @@ void ide_hwif_release_regions(ide_hwif_t *hwif)
 			release_region(hwif->io_ports[i], 1);
 }
 
-/**
- *	ide_hwif_restore	-	restore hwif to template
- *	@hwif: hwif to update
- *	@tmp_hwif: template
- *
- *	Restore hwif to a previous state by copying most settings
- *	from the template.
- */
-
-static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
-{
-	hwif->hwgroup			= tmp_hwif->hwgroup;
-
-	hwif->gendev.parent		= tmp_hwif->gendev.parent;
-
-	hwif->proc			= tmp_hwif->proc;
-
-	hwif->major			= tmp_hwif->major;
-	hwif->straight8			= tmp_hwif->straight8;
-	hwif->bus_state			= tmp_hwif->bus_state;
-
-	hwif->host_flags		= tmp_hwif->host_flags;
-
-	hwif->pio_mask			= tmp_hwif->pio_mask;
-
-	hwif->ultra_mask		= tmp_hwif->ultra_mask;
-	hwif->mwdma_mask		= tmp_hwif->mwdma_mask;
-	hwif->swdma_mask		= tmp_hwif->swdma_mask;
-
-	hwif->cbl			= tmp_hwif->cbl;
-
-	hwif->chipset			= tmp_hwif->chipset;
-	hwif->hold			= tmp_hwif->hold;
-
-	hwif->dev			= tmp_hwif->dev;
-
-#ifdef CONFIG_BLK_DEV_IDEPCI
-	hwif->cds			= tmp_hwif->cds;
-#endif
-
-	hwif->set_pio_mode		= tmp_hwif->set_pio_mode;
-	hwif->set_dma_mode		= tmp_hwif->set_dma_mode;
-	hwif->mdma_filter		= tmp_hwif->mdma_filter;
-	hwif->udma_filter		= tmp_hwif->udma_filter;
-	hwif->selectproc		= tmp_hwif->selectproc;
-	hwif->reset_poll		= tmp_hwif->reset_poll;
-	hwif->pre_reset			= tmp_hwif->pre_reset;
-	hwif->resetproc			= tmp_hwif->resetproc;
-	hwif->maskproc			= tmp_hwif->maskproc;
-	hwif->quirkproc			= tmp_hwif->quirkproc;
-
-	hwif->ata_input_data		= tmp_hwif->ata_input_data;
-	hwif->ata_output_data		= tmp_hwif->ata_output_data;
-	hwif->atapi_input_bytes		= tmp_hwif->atapi_input_bytes;
-	hwif->atapi_output_bytes	= tmp_hwif->atapi_output_bytes;
-
-	hwif->dma_host_set		= tmp_hwif->dma_host_set;
-	hwif->dma_setup			= tmp_hwif->dma_setup;
-	hwif->dma_exec_cmd		= tmp_hwif->dma_exec_cmd;
-	hwif->dma_start			= tmp_hwif->dma_start;
-	hwif->ide_dma_end		= tmp_hwif->ide_dma_end;
-	hwif->ide_dma_test_irq		= tmp_hwif->ide_dma_test_irq;
-	hwif->ide_dma_clear_irq		= tmp_hwif->ide_dma_clear_irq;
-	hwif->dma_lost_irq		= tmp_hwif->dma_lost_irq;
-	hwif->dma_timeout		= tmp_hwif->dma_timeout;
-
-	hwif->OUTB			= tmp_hwif->OUTB;
-	hwif->OUTBSYNC			= tmp_hwif->OUTBSYNC;
-	hwif->OUTW			= tmp_hwif->OUTW;
-	hwif->OUTSW			= tmp_hwif->OUTSW;
-	hwif->OUTSL			= tmp_hwif->OUTSL;
-
-	hwif->INB			= tmp_hwif->INB;
-	hwif->INW			= tmp_hwif->INW;
-	hwif->INSW			= tmp_hwif->INSW;
-	hwif->INSL			= tmp_hwif->INSL;
-
-	hwif->sg_max_nents		= tmp_hwif->sg_max_nents;
-
-	hwif->mmio			= tmp_hwif->mmio;
-	hwif->rqsize			= tmp_hwif->rqsize;
-
-#ifndef CONFIG_BLK_DEV_IDECS
-	hwif->irq			= tmp_hwif->irq;
-#endif
-
-	hwif->dma_base			= tmp_hwif->dma_base;
-	hwif->dma_command		= tmp_hwif->dma_command;
-	hwif->dma_vendor1		= tmp_hwif->dma_vendor1;
-	hwif->dma_status		= tmp_hwif->dma_status;
-	hwif->dma_vendor3		= tmp_hwif->dma_vendor3;
-	hwif->dma_prdtable		= tmp_hwif->dma_prdtable;
-
-	hwif->config_data		= tmp_hwif->config_data;
-	hwif->select_data		= tmp_hwif->select_data;
-	hwif->extra_base		= tmp_hwif->extra_base;
-	hwif->extra_ports		= tmp_hwif->extra_ports;
-
-	hwif->hwif_data			= tmp_hwif->hwif_data;
-}
-
 void ide_remove_port_from_hwgroup(ide_hwif_t *hwif)
 {
 	ide_hwgroup_t *hwgroup = hwif->hwgroup;
@@ -530,8 +429,6 @@ EXPORT_SYMBOL_GPL(ide_port_unregister_devices);
 /**
  *	ide_unregister		-	free an IDE interface
  *	@index: index of interface (will change soon to a pointer)
- *	@init_default: init default hwif flag
- *	@restore: restore hwif flag
  *
  *	Perform the final unregister of an IDE interface. At the moment
  *	we don't refcount interfaces so this will also get split up.
@@ -551,10 +448,9 @@ EXPORT_SYMBOL_GPL(ide_port_unregister_devices);
  *	This is raving bonkers.
  */
 
-void ide_unregister(unsigned int index, int init_default, int restore)
+void ide_unregister(unsigned int index)
 {
 	ide_hwif_t *hwif, *g;
-	static ide_hwif_t tmp_hwif; /* protected by ide_cfg_mtx */
 	ide_hwgroup_t *hwgroup;
 	int irq_count = 0;
 
@@ -601,34 +497,14 @@ void ide_unregister(unsigned int index, int init_default, int restore)
 	unregister_blkdev(hwif->major, hwif->name);
 	spin_lock_irq(&ide_lock);
 
-	if (hwif->dma_base) {
-		(void) ide_release_dma(hwif);
-
-		hwif->dma_base = 0;
-		hwif->dma_command = 0;
-		hwif->dma_vendor1 = 0;
-		hwif->dma_status = 0;
-		hwif->dma_vendor3 = 0;
-		hwif->dma_prdtable = 0;
-
-		hwif->extra_base  = 0;
-		hwif->extra_ports = 0;
-	}
+	if (hwif->dma_base)
+		(void)ide_release_dma(hwif);
 
 	ide_hwif_release_regions(hwif);
 
-	/* copy original settings */
-	tmp_hwif = *hwif;
-
 	/* restore hwif data to pristine status */
 	ide_init_port_data(hwif, index);
 
-	if (init_default)
-		init_hwif_default(hwif, index);
-
-	if (restore)
-		ide_hwif_restore(hwif, &tmp_hwif);
-
 abort:
 	spin_unlock_irq(&ide_lock);
 	mutex_unlock(&ide_cfg_mtx);
@@ -647,52 +523,6 @@ void ide_init_port_hw(ide_hwif_t *hwif, hw_regs_t *hw)
 }
 EXPORT_SYMBOL_GPL(ide_init_port_hw);
 
-/**
- *	ide_register_hw		-	register IDE interface
- *	@hw: hardware registers
- *	@quirkproc: quirkproc function
- *	@hwifp: pointer to returned hwif
- *
- *	Register an IDE interface, specifying exactly the registers etc.
- *
- *	Returns -1 on error.
- */
-
-static int ide_register_hw(hw_regs_t *hw, void (*quirkproc)(ide_drive_t *),
-			   ide_hwif_t **hwifp)
-{
-	int index, retry = 1;
-	ide_hwif_t *hwif;
-	u8 idx[4] = { 0xff, 0xff, 0xff, 0xff };
-
-	do {
-		hwif = ide_find_port(hw->io_ports[IDE_DATA_OFFSET]);
-		if (hwif)
-			goto found;
-		for (index = 0; index < MAX_HWIFS; index++)
-			ide_unregister(index, 1, 1);
-	} while (retry--);
-	return -1;
-found:
-	index = hwif->index;
-	if (hwif->present)
-		ide_unregister(index, 0, 1);
-	else if (!hwif->hold)
-		ide_init_port_data(hwif, index);
-
-	ide_init_port_hw(hwif, hw);
-	hwif->quirkproc = quirkproc;
-
-	idx[0] = index;
-
-	ide_device_add(idx, NULL);
-
-	if (hwifp)
-		*hwifp = hwif;
-
-	return hwif->present ? index : -1;
-}
-
 /*
  *	Locks for IDE setting functionality
  */
@@ -995,27 +825,6 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 			if (!capable(CAP_SYS_RAWIO))
 				return -EACCES;
 			return ide_task_ioctl(drive, cmd, arg);
-
-		case HDIO_SCAN_HWIF:
-		{
-			hw_regs_t hw;
-			int args[3];
-			if (!capable(CAP_SYS_RAWIO)) return -EACCES;
-			if (copy_from_user(args, p, 3 * sizeof(int)))
-				return -EFAULT;
-			memset(&hw, 0, sizeof(hw));
-			ide_init_hwif_ports(&hw, (unsigned long) args[0],
-					    (unsigned long) args[1], NULL);
-			hw.irq = args[2];
-			if (ide_register_hw(&hw, NULL, NULL) == -1)
-				return -EIO;
-			return 0;
-		}
-	        case HDIO_UNREGISTER_HWIF:
-			if (!capable(CAP_SYS_RAWIO)) return -EACCES;
-			/* (arg > MAX_HWIFS) checked in function */
-			ide_unregister(arg, 1, 1);
-			return 0;
 		case HDIO_SET_NICE:
 			if (!capable(CAP_SYS_ADMIN)) return -EACCES;
 			if (arg != (arg & ((1 << IDE_NICE_DSC_OVERLAP) | (1 << IDE_NICE_1))))
@@ -1648,7 +1457,7 @@ void __exit cleanup_module (void)
 	int index;
 
 	for (index = 0; index < MAX_HWIFS; ++index)
-		ide_unregister(index, 0, 0);
+		ide_unregister(index);
 
 	proc_ide_destroy();
 

commit 9a0e77f28b50128df0c9e26ae489e44e29a7270a
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Apr 18 00:46:24 2008 +0200

    ide: remove obsoleted "idex=base[,ctl[,irq]]" kernel parameters (take 2)
    
    * Remove obsoleted "idex=base[,ctl[,irq]]" kernel parameters
      and update Documentation/ide/ide.txt.
    
    * Remove no longer needed ide_forced chipset type.
    
    v2:
    * is_chipset_set[] -> is_chipset_set in ide.c.
    
    * Documentation/ide/ide.txt fix.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 96126b3b12e9..7e789c97a8b8 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1170,7 +1170,7 @@ extern int probe_ht6560b;
 extern int probe_qd65xx;
 extern int cmd640_vlb;
 
-static int __initdata is_chipset_set[MAX_HWIFS];
+static int __initdata is_chipset_set;
 
 /*
  * ide_setup() gets called VERY EARLY during initialization,
@@ -1328,8 +1328,6 @@ static int __init ide_setup(char *s)
 			"minus10", "four", "qd65xx", "ht6560b", "cmd640_vlb",
 			"dtc2278", "umc8672", "ali14xx", NULL };
 
-		hw_regs_t hwregs;
-
 		hw = s[3] - '0';
 		hwif = &ide_hwifs[hw];
 		i = match_parm(&s[4], ide_words, vals, 3);
@@ -1338,19 +1336,14 @@ static int __init ide_setup(char *s)
 		 * Cryptic check to ensure chipset not already set for hwif.
 		 * Note: we can't depend on hwif->chipset here.
 		 */
-		if ((i >= -18 && i <= -11) || (i > 0 && i <= 3)) {
+		if (i >= -18 && i <= -11) {
 			/* chipset already specified */
-			if (is_chipset_set[hw])
+			if (is_chipset_set)
 				goto bad_option;
-			if (i > -18 && i <= -11) {
-				/* these drivers are for "ide0=" only */
-				if (hw != 0)
-					goto bad_hwif;
-				/* chipset already specified for 2nd port */
-				if (is_chipset_set[hw+1])
-					goto bad_option;
-			}
-			is_chipset_set[hw] = 1;
+			/* these drivers are for "ide0=" only */
+			if (hw != 0)
+				goto bad_hwif;
+			is_chipset_set = 1;
 			printk("\n");
 		}
 
@@ -1430,21 +1423,11 @@ static int __init ide_setup(char *s)
 			case -1: /* "noprobe" */
 				hwif->noprobe = 1;
 				goto obsolete_option;
-
-			case 1:	/* base */
-				vals[1] = vals[0] + 0x206; /* default ctl */
-			case 2: /* base,ctl */
-				vals[2] = 0;	/* default irq = probe for it */
-			case 3: /* base,ctl,irq */
-				memset(&hwregs, 0, sizeof(hwregs));
-				ide_init_hwif_ports(&hwregs, vals[0], vals[1], &hwif->irq);
-				memcpy(hwif->io_ports, hwregs.io_ports, sizeof(hwif->io_ports));
-				hwif->irq      = vals[2];
-				hwif->noprobe  = 0;
-				hwif->chipset  = ide_forced;
-				goto obsolete_option;
-
-			case 0: goto bad_option;
+			case 0:
+			case 1:
+			case 2:
+			case 3:
+				goto bad_option;
 			default:
 				printk(" -- SUPPORT NOT CONFIGURED IN THIS KERNEL\n");
 				return 1;

commit 80aa31cb460d12c1e02327b43eceb3eebc6e7090
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Apr 18 00:46:24 2008 +0200

    ide: remove CONFIG_BLK_DEV_HD_IDE config option (take 2)
    
    * Remove CONFIG_BLK_DEV_HD hack from init_hwif_default()
      ("hda=noprobe hdb=noprobe" kernel parameters should be used
      instead if somebody wishes to use the old "hd" driver).
    
    * Make CONFIG_BLK_DEV_HD_ONLY config option available also when
      IDE subsystem is used and update help entry.
    
    * Remove no longer needed CONFIG_BLK_DEV_HD_IDE config option.
    
    v2:
    * Update documentation to suggest "hda=noprobe hdb=noprobe"
      instead of obsoleted "ide0=noprobe".
    
    * Update Documentation/ide/ide.txt.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index d791b1ffb586..96126b3b12e9 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -177,10 +177,6 @@ static void init_hwif_default(ide_hwif_t *hwif, unsigned int index)
 	memcpy(hwif->io_ports, hw.io_ports, sizeof(hw.io_ports));
 
 	hwif->noprobe = !hwif->io_ports[IDE_DATA_OFFSET];
-#ifdef CONFIG_BLK_DEV_HD
-	if (hwif->io_ports[IDE_DATA_OFFSET] == HD_DATA)
-		hwif->noprobe = 1;	/* may be overridden by ide_setup() */
-#endif
 }
 
 /*

commit f74c91413ec6140ee0553180c5f56fdd27c22a2e
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Apr 18 00:46:23 2008 +0200

    ide: add warm-plug support for IDE devices (take 2)
    
    * Add 'struct class ide_port_class' ('ide_port' class) and a 'struct
      device *portdev' ('ide_port' class device) in ide_hwif_t.
    
    * Register 'ide_port' class in ide_init() and unregister it in
      cleanup_module().
    
    * Create ->portdev in ide_register_port () and unregister it in
      ide_unregister().
    
    * Add "delete_devices" class device attribute for unregistering IDE devices
      on a port and "scan" one for probing+registering IDE devices on a port.
    
    * Add ide_sysfs_register_port() helper for registering "delete_devices"
      and "scan" attributes with ->portdev.  Call it in ide_device_add_all().
    
    * Document IDE warm-plug support in Documentation/ide/warm-plug-howto.txt.
    
    v2:
    * Convert patch from using 'struct class_device' to use 'struct device'.
      (thanks to Kay Sievers for doing it)
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index cb18ba8de22d..d791b1ffb586 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -78,6 +78,8 @@
 /* default maximum number of failures */
 #define IDE_DEFAULT_MAX_FAILURES 	1
 
+struct class *ide_port_class;
+
 static const u8 ide_hwif_to_major[] = { IDE0_MAJOR, IDE1_MAJOR,
 					IDE2_MAJOR, IDE3_MAJOR,
 					IDE4_MAJOR, IDE5_MAJOR,
@@ -591,6 +593,7 @@ void ide_unregister(unsigned int index, int init_default, int restore)
 
 	ide_remove_port_from_hwgroup(hwif);
 
+	device_unregister(hwif->portdev);
 	device_unregister(&hwif->gendev);
 	wait_for_completion(&hwif->gendev_rel_comp);
 
@@ -1590,6 +1593,13 @@ struct bus_type ide_bus_type = {
 
 EXPORT_SYMBOL_GPL(ide_bus_type);
 
+static void ide_port_class_release(struct device *portdev)
+{
+	ide_hwif_t *hwif = dev_get_drvdata(portdev);
+
+	put_device(&hwif->gendev);
+}
+
 /*
  * This is gets invoked once during initialization, to set *everything* up
  */
@@ -1610,11 +1620,23 @@ static int __init ide_init(void)
 		return ret;
 	}
 
+	ide_port_class = class_create(THIS_MODULE, "ide_port");
+	if (IS_ERR(ide_port_class)) {
+		ret = PTR_ERR(ide_port_class);
+		goto out_port_class;
+	}
+	ide_port_class->dev_release = ide_port_class_release;
+
 	init_ide_data();
 
 	proc_ide_create();
 
 	return 0;
+
+out_port_class:
+	bus_unregister(&ide_bus_type);
+
+	return ret;
 }
 
 #ifdef MODULE
@@ -1651,6 +1673,8 @@ void __exit cleanup_module (void)
 
 	proc_ide_destroy();
 
+	class_destroy(ide_port_class);
+
 	bus_unregister(&ide_bus_type);
 }
 

commit 50672e5d7486c9ab312432cbe180ac071f1de8e0
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Apr 18 00:46:23 2008 +0200

    ide: remove dead/obsolete ->busproc method
    
    ->busproc method is used by HDIO_SET_BUSSTATE ioctl but it has no chance
    of working as intended (in 2.4.x days) because to issue an ioctl there
    is a device node needed and:
    
    - for BUSSTATE_TRISTATE+OFF it is too late (devices are already gone)
    
    - for BUSSTATE_TRISTATE+ON it is too early (devices are not registered yet)
    
    Just remove ->busproc method for now (it was only implemented by hpt366,
    siimage and tc86c001 host drivers).
    
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index a8b5b08dd6e2..cb18ba8de22d 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -414,7 +414,6 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 	hwif->resetproc			= tmp_hwif->resetproc;
 	hwif->maskproc			= tmp_hwif->maskproc;
 	hwif->quirkproc			= tmp_hwif->quirkproc;
-	hwif->busproc			= tmp_hwif->busproc;
 
 	hwif->ata_input_data		= tmp_hwif->ata_input_data;
 	hwif->ata_output_data		= tmp_hwif->ata_output_data;
@@ -1071,8 +1070,6 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 		case HDIO_SET_BUSSTATE:
 			if (!capable(CAP_SYS_ADMIN))
 				return -EACCES;
-			if (HWIF(drive)->busproc)
-				return HWIF(drive)->busproc(drive, (int)arg);
 			return -EOPNOTSUPP;
 		default:
 			return -EINVAL;

commit 2dde7861afa23cd59db83515cb0b810b92b220aa
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Apr 18 00:46:23 2008 +0200

    ide: rework PowerMac media-bay support (take 2)
    
    Rework PowerMac media-bay support in such way that instead of
    un/registering the IDE interface we un/register IDE devices:
    
    * Add ide_port_scan() helper for probing+registerering devices on a port.
    
    * Rename ide_port_unregister_devices() to __ide_port_unregister_devices().
    
    * Add ide_port_unregister_devices() helper for unregistering devices on a port.
    
    * Add 'ide_hwif_t *cd_port' to 'struct media_bay_info', pass 'hwif' instead
      of hwif->index to media_bay_set_ide_infos() and use it to setup 'cd_port'.
    
    * Use ide_port_unregister_devices() instead of ide_unregister()
      and ide_port_scan() instead of ide_register_hw() in media_bay_step().
    
    * Unexport ide_register_hw() and make it static.
    
    v2:
    * Fix build by adding <linux/ide.h> include to <asm-powerpc/mediabay.h>.
      (Reported by Michael/Kamalesh/Andrew).
    
    Cc: Kamalesh Babulal <kamalesh@linux.vnet.ibm.com>
    Cc: Michael Ellerman <michael@ellerman.id.au>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 47c44d15ad4a..a8b5b08dd6e2 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -502,7 +502,7 @@ void ide_remove_port_from_hwgroup(ide_hwif_t *hwif)
 }
 
 /* Called with ide_lock held. */
-static void ide_port_unregister_devices(ide_hwif_t *hwif)
+static void __ide_port_unregister_devices(ide_hwif_t *hwif)
 {
 	int i;
 
@@ -518,6 +518,18 @@ static void ide_port_unregister_devices(ide_hwif_t *hwif)
 	}
 }
 
+void ide_port_unregister_devices(ide_hwif_t *hwif)
+{
+	mutex_lock(&ide_cfg_mtx);
+	spin_lock_irq(&ide_lock);
+	__ide_port_unregister_devices(hwif);
+	hwif->present = 0;
+	ide_port_init_devices_data(hwif);
+	spin_unlock_irq(&ide_lock);
+	mutex_unlock(&ide_cfg_mtx);
+}
+EXPORT_SYMBOL_GPL(ide_port_unregister_devices);
+
 /**
  *	ide_unregister		-	free an IDE interface
  *	@index: index of interface (will change soon to a pointer)
@@ -558,7 +570,7 @@ void ide_unregister(unsigned int index, int init_default, int restore)
 	hwif = &ide_hwifs[index];
 	if (!hwif->present)
 		goto abort;
-	ide_port_unregister_devices(hwif);
+	__ide_port_unregister_devices(hwif);
 	hwif->present = 0;
 
 	spin_unlock_irq(&ide_lock);
@@ -648,8 +660,8 @@ EXPORT_SYMBOL_GPL(ide_init_port_hw);
  *	Returns -1 on error.
  */
 
-int ide_register_hw(hw_regs_t *hw, void (*quirkproc)(ide_drive_t *),
-		    ide_hwif_t **hwifp)
+static int ide_register_hw(hw_regs_t *hw, void (*quirkproc)(ide_drive_t *),
+			   ide_hwif_t **hwifp)
 {
 	int index, retry = 1;
 	ide_hwif_t *hwif;
@@ -683,8 +695,6 @@ int ide_register_hw(hw_regs_t *hw, void (*quirkproc)(ide_drive_t *),
 	return hwif->present ? index : -1;
 }
 
-EXPORT_SYMBOL(ide_register_hw);
-
 /*
  *	Locks for IDE setting functionality
  */

commit 43514ed1ee6a2325692e173ea4eb41068bf72de0
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Apr 18 00:46:22 2008 +0200

    ide: factor out devices init from ide_init_port_data()
    
    * Factor out devices init from ide_init_port_data() to
      ide_port_init_devices_data().
    
    While at it:
    
    * Add explicit clearing of IDE device structure.
    
    There should be no functionality changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 31bc28aacdc9..47c44d15ad4a 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -105,13 +105,13 @@ ide_hwif_t ide_hwifs[MAX_HWIFS];	/* master data repository */
 
 EXPORT_SYMBOL(ide_hwifs);
 
+static void ide_port_init_devices_data(ide_hwif_t *);
+
 /*
  * Do not even *think* about calling this!
  */
 void ide_init_port_data(ide_hwif_t *hwif, unsigned int index)
 {
-	unsigned int unit;
-
 	/* bulk initialize hwif & drive info with zeros */
 	memset(hwif, 0, sizeof(ide_hwif_t));
 
@@ -130,8 +130,20 @@ void ide_init_port_data(ide_hwif_t *hwif, unsigned int index)
 
 	default_hwif_iops(hwif);
 	default_hwif_transport(hwif);
+
+	ide_port_init_devices_data(hwif);
+}
+EXPORT_SYMBOL_GPL(ide_init_port_data);
+
+static void ide_port_init_devices_data(ide_hwif_t *hwif)
+{
+	int unit;
+
 	for (unit = 0; unit < MAX_DRIVES; ++unit) {
 		ide_drive_t *drive = &hwif->drives[unit];
+		u8 j = (hwif->index * MAX_DRIVES) + unit;
+
+		memset(drive, 0, sizeof(*drive));
 
 		drive->media			= ide_disk;
 		drive->select.all		= (unit<<4)|0xa0;
@@ -143,15 +155,14 @@ void ide_init_port_data(ide_hwif_t *hwif, unsigned int index)
 		drive->special.b.set_geometry	= 1;
 		drive->name[0]			= 'h';
 		drive->name[1]			= 'd';
-		drive->name[2]			= 'a' + (index * MAX_DRIVES) + unit;
+		drive->name[2]			= 'a' + j;
 		drive->max_failures		= IDE_DEFAULT_MAX_FAILURES;
-		drive->using_dma		= 0;
-		drive->vdma			= 0;
+
 		INIT_LIST_HEAD(&drive->list);
 		init_completion(&drive->gendev_rel_comp);
 	}
 }
-EXPORT_SYMBOL_GPL(ide_init_port_data);
+
 
 static void init_hwif_default(ide_hwif_t *hwif, unsigned int index)
 {

commit 71bf9f6fe822397e2cce781a2408c658a776fd68
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Apr 18 00:46:22 2008 +0200

    ide: factor out code unregistering devices from ide_unregister()
    
    Factor out code unregistering devices from ide_unregister() to
    ide_port_unregister_devices().
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index bd5ff7d987d0..31bc28aacdc9 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -490,6 +490,23 @@ void ide_remove_port_from_hwgroup(ide_hwif_t *hwif)
 	spin_unlock_irq(&ide_lock);
 }
 
+/* Called with ide_lock held. */
+static void ide_port_unregister_devices(ide_hwif_t *hwif)
+{
+	int i;
+
+	for (i = 0; i < MAX_DRIVES; i++) {
+		ide_drive_t *drive = &hwif->drives[i];
+
+		if (drive->present) {
+			spin_unlock_irq(&ide_lock);
+			device_unregister(&drive->gendev);
+			wait_for_completion(&drive->gendev_rel_comp);
+			spin_lock_irq(&ide_lock);
+		}
+	}
+}
+
 /**
  *	ide_unregister		-	free an IDE interface
  *	@index: index of interface (will change soon to a pointer)
@@ -516,11 +533,10 @@ void ide_remove_port_from_hwgroup(ide_hwif_t *hwif)
 
 void ide_unregister(unsigned int index, int init_default, int restore)
 {
-	ide_drive_t *drive;
 	ide_hwif_t *hwif, *g;
 	static ide_hwif_t tmp_hwif; /* protected by ide_cfg_mtx */
 	ide_hwgroup_t *hwgroup;
-	int irq_count = 0, unit;
+	int irq_count = 0;
 
 	BUG_ON(index >= MAX_HWIFS);
 
@@ -531,15 +547,7 @@ void ide_unregister(unsigned int index, int init_default, int restore)
 	hwif = &ide_hwifs[index];
 	if (!hwif->present)
 		goto abort;
-	for (unit = 0; unit < MAX_DRIVES; ++unit) {
-		drive = &hwif->drives[unit];
-		if (!drive->present)
-			continue;
-		spin_unlock_irq(&ide_lock);
-		device_unregister(&drive->gendev);
-		wait_for_completion(&drive->gendev_rel_comp);
-		spin_lock_irq(&ide_lock);
-	}
+	ide_port_unregister_devices(hwif);
 	hwif->present = 0;
 
 	spin_unlock_irq(&ide_lock);

commit 4f0eee4d877e3b617b6a22d209d52b3dfca2b2a7
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Apr 18 00:46:21 2008 +0200

    ide: use ide_find_port() instead of ide_deprecated_find_port()
    
    * Use ide_find_port() instead of ide_deprecated_find_port() in bast-ide/
      palm_bk3710/ide-cs/delkin_cb host drivers and in ide_register_hw().
    
    * Remove no longer needed ide_deprecated_find_port().
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 67ce697a9d51..bd5ff7d987d0 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -618,31 +618,6 @@ void ide_init_port_hw(ide_hwif_t *hwif, hw_regs_t *hw)
 }
 EXPORT_SYMBOL_GPL(ide_init_port_hw);
 
-ide_hwif_t *ide_deprecated_find_port(unsigned long base)
-{
-	ide_hwif_t *hwif;
-	int i;
-
-	for (i = 0; i < MAX_HWIFS; i++) {
-		hwif = &ide_hwifs[i];
-		if (hwif->io_ports[IDE_DATA_OFFSET] == base)
-			goto found;
-	}
-
-	for (i = 0; i < MAX_HWIFS; i++) {
-		hwif = &ide_hwifs[i];
-		if (hwif->hold)
-			continue;
-		if (!hwif->present && hwif->mate == NULL)
-			goto found;
-	}
-
-	hwif = NULL;
-found:
-	return hwif;
-}
-EXPORT_SYMBOL_GPL(ide_deprecated_find_port);
-
 /**
  *	ide_register_hw		-	register IDE interface
  *	@hw: hardware registers
@@ -662,7 +637,7 @@ int ide_register_hw(hw_regs_t *hw, void (*quirkproc)(ide_drive_t *),
 	u8 idx[4] = { 0xff, 0xff, 0xff, 0xff };
 
 	do {
-		hwif = ide_deprecated_find_port(hw->io_ports[IDE_DATA_OFFSET]);
+		hwif = ide_find_port(hw->io_ports[IDE_DATA_OFFSET]);
 		if (hwif)
 			goto found;
 		for (index = 0; index < MAX_HWIFS; index++)

commit 2625cd52b6eafb63b72f2e53f933f41ba9e34dff
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Apr 18 00:46:21 2008 +0200

    ide: fix ide_find_port()
    
    * Instead of checking for '->io_ports[IDE_DATA_OFFSET] == 0' check for
      '->chipset == ide_unknown' when looking for an empty ide_hwifs[] slot.
    
    * Do ide-pnp initialization after ide-generic when IDE is built-in
      (ide-pnp is the only user of ide_find_port() which needs such fixup).
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 5f545153391a..67ce697a9d51 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -255,7 +255,7 @@ ide_hwif_t * ide_find_port(unsigned long base)
 
 	for (i = 0; i < MAX_HWIFS; i++) {
 		hwif = &ide_hwifs[i];
-		if (hwif->io_ports[IDE_DATA_OFFSET] == 0)
+		if (hwif->chipset == ide_unknown)
 			goto found;
 	}
 

commit a594eeb1a1d320981fccc29584b6f21fcebd765f
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Apr 18 00:46:20 2008 +0200

    IDE: remove ide=reverse IDE core
    
    This option is obsolete and can be removed safely.
    
    It allows us to remove the pci_get_device_reverse() function from the
    PCI core.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index fc69fe2e3ec0..5f545153391a 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -90,10 +90,6 @@ static int system_bus_speed;	/* holds what we think is VESA/PCI bus speed */
 DEFINE_MUTEX(ide_cfg_mtx);
  __cacheline_aligned_in_smp DEFINE_SPINLOCK(ide_lock);
 
-#ifdef CONFIG_IDEPCI_PCIBUS_ORDER
-int ide_scan_direction; /* THIS was formerly 2.2.x pci=reverse */
-#endif
-
 int noautodma = 0;
 
 #ifdef CONFIG_BLK_DEV_IDEACPI
@@ -1217,14 +1213,6 @@ static int __init ide_setup(char *s)
 		goto obsolete_option;
 	}
 
-#ifdef CONFIG_IDEPCI_PCIBUS_ORDER
-	if (!strcmp(s, "ide=reverse")) {
-		ide_scan_direction = 1;
-		printk(" : Enabled support for IDE inverse scan order.\n");
-		goto obsolete_option;
-	}
-#endif
-
 #ifdef CONFIG_BLK_DEV_IDEACPI
 	if (!strcmp(s, "ide=noacpi")) {
 		//printk(" : Disable IDE ACPI support.\n");

commit d708c40da83a86551556999e924e27fdc43dad71
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Mar 22 16:40:22 2008 +0100

    ide: mark "hdx=remap" and "hdx=remap63" kernel parameters as obsoleted
    
    Mark "hdx=remap" and "hdx=remap63" kernel parameters as obsoleted
    (they are layering violation and should be dealt with in the same
     way as done by libata - device-mapper should be used instead).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index df410e0357d8..fc69fe2e3ec0 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1290,10 +1290,10 @@ static int __init ide_setup(char *s)
 				goto done;
 			case -12: /* "remap" */
 				drive->remap_0_to_1 = 1;
-				goto done;
+				goto obsolete_option;
 			case -13: /* "remap63" */
 				drive->sect0 = 63;
-				goto done;
+				goto obsolete_option;
 			case -14: /* "scsi" */
 				drive->scsi = 1;
 				goto obsolete_option;

commit 15220d9b5a7e6f4ff251350b285674ed676e0d3d
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Mar 22 16:40:21 2008 +0100

    ide: mark "hdx=[driver_name]" and "hdx=scsi" kernel parameters as obsoleted
    
    Mark "hdx=[driver_name]" and "hdx=scsi" kernel parameters as obsoleted
    (nowadays device-driver binding can be changed at runtime through sysfs
     and it can also be dealt with using per device driver parameters).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 373bdd4e5ef8..df410e0357d8 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1258,7 +1258,7 @@ static int __init ide_setup(char *s)
 		drive = &hwif->drives[unit];
 		if (strncmp(s + 4, "ide-", 4) == 0) {
 			strlcpy(drive->driver_req, s + 4, sizeof(drive->driver_req));
-			goto done;
+			goto obsolete_option;
 		}
 		switch (match_parm(&s[3], hd_words, vals, 3)) {
 			case -1: /* "none" */
@@ -1296,7 +1296,7 @@ static int __init ide_setup(char *s)
 				goto done;
 			case -14: /* "scsi" */
 				drive->scsi = 1;
-				goto done;
+				goto obsolete_option;
 			case 3: /* cyl,head,sect */
 				drive->media	= ide_disk;
 				drive->ready_stat = READY_STAT;

commit 9c027c684bd01b91a7aecc63161b56071685ce7d
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Mar 22 16:40:21 2008 +0100

    ide: mark special "ide0=" kernel parameters as obsoleted
    
    Mark "ide0=ali14xx|cmd640_vlb|dtc2278|ht6560b|qd65xx|umc8672" kernel
    parameters as obsoleted (per host driver replacements have been available
    for a long time).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 9976f9d627d4..373bdd4e5ef8 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1370,32 +1370,32 @@ static int __init ide_setup(char *s)
 #ifdef CONFIG_BLK_DEV_ALI14XX
 			case -17: /* "ali14xx" */
 				probe_ali14xx = 1;
-				goto done;
+				goto obsolete_option;
 #endif
 #ifdef CONFIG_BLK_DEV_UMC8672
 			case -16: /* "umc8672" */
 				probe_umc8672 = 1;
-				goto done;
+				goto obsolete_option;
 #endif
 #ifdef CONFIG_BLK_DEV_DTC2278
 			case -15: /* "dtc2278" */
 				probe_dtc2278 = 1;
-				goto done;
+				goto obsolete_option;
 #endif
 #ifdef CONFIG_BLK_DEV_CMD640
 			case -14: /* "cmd640_vlb" */
 				cmd640_vlb = 1;
-				goto done;
+				goto obsolete_option;
 #endif
 #ifdef CONFIG_BLK_DEV_HT6560B
 			case -13: /* "ht6560b" */
 				probe_ht6560b = 1;
-				goto done;
+				goto obsolete_option;
 #endif
 #ifdef CONFIG_BLK_DEV_QD65XX
 			case -12: /* "qd65xx" */
 				probe_qd65xx = 1;
-				goto done;
+				goto obsolete_option;
 #endif
 #ifdef CONFIG_BLK_DEV_4DRIVES
 			case -11: /* "four" drives on one set of ports */

commit 1c10e93828f8861c3f58d647e259de0e2c63b930
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Fri Mar 7 21:53:50 2008 +0100

    ide: update references to Documentation/ide/ide.txt (v2)
    
    Fix all references to Documentation/ide/ide.txt.
    Add/update ide/00-INDEX file.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index c2b791224097..9976f9d627d4 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1180,7 +1180,7 @@ static int __initdata is_chipset_set[MAX_HWIFS];
  * ide_setup() gets called VERY EARLY during initialization,
  * to handle kernel "command line" strings beginning with "hdx=" or "ide".
  *
- * Remember to update Documentation/ide.txt if you change something here.
+ * Remember to update Documentation/ide/ide.txt if you change something here.
  */
 static int __init ide_setup(char *s)
 {

commit 0c6025d44448bd688dfd351a09bc620aafa4d1ff
Author: Peter Teoh <htmldeveloper@gmail.com>
Date:   Fri Mar 7 21:53:49 2008 +0100

    ide: fix buggy code in ide_register_hw()
    
    Relocating the index to come after finding the hwif pointer.
    
    Signed-off-by: Peter Teoh <htmldeveloper@gmail.com>
    Reported-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index fa16bc30bbc9..c2b791224097 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -667,7 +667,6 @@ int ide_register_hw(hw_regs_t *hw, void (*quirkproc)(ide_drive_t *),
 
 	do {
 		hwif = ide_deprecated_find_port(hw->io_ports[IDE_DATA_OFFSET]);
-		index = hwif->index;
 		if (hwif)
 			goto found;
 		for (index = 0; index < MAX_HWIFS; index++)
@@ -675,6 +674,7 @@ int ide_register_hw(hw_regs_t *hw, void (*quirkproc)(ide_drive_t *),
 	} while (retry--);
 	return -1;
 found:
+	index = hwif->index;
 	if (hwif->present)
 		ide_unregister(index, 0, 1);
 	else if (!hwif->hold)

commit dbecebca1914f414008553b57aefde95b70f9142
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Feb 26 21:50:35 2008 +0100

    ide: fix sparse warning about shadowing 'flags' symbol
    
    drivers/ide/ide.c:801:18: warning: symbol 'flags' shadows an earlier one
    drivers/ide/ide.c:732:16: originally declared here
    
    Also fix some whitespace damage while at it.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 300536697622..fa16bc30bbc9 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1031,10 +1031,9 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 			drive->nice1 = (arg >> IDE_NICE_1) & 1;
 			return 0;
 		case HDIO_DRIVE_RESET:
-		{
-			unsigned long flags;
-			if (!capable(CAP_SYS_ADMIN)) return -EACCES;
-			
+			if (!capable(CAP_SYS_ADMIN))
+				return -EACCES;
+
 			/*
 			 *	Abort the current command on the
 			 *	group if there is one, taking
@@ -1053,17 +1052,15 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 			ide_abort(drive, "drive reset");
 
 			BUG_ON(HWGROUP(drive)->handler);
-				
+
 			/* Ensure nothing gets queued after we
 			   drop the lock. Reset will clear the busy */
-		   
+
 			HWGROUP(drive)->busy = 1;
 			spin_unlock_irqrestore(&ide_lock, flags);
 			(void) ide_do_reset(drive);
 
 			return 0;
-		}
-
 		case HDIO_GET_BUSSTATE:
 			if (!capable(CAP_SYS_ADMIN))
 				return -EACCES;

commit c53ea18dc29a1ac075119f651d6ac4386a549a34
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Feb 26 21:50:34 2008 +0100

    ide: skip probing port if "hdx=noprobe" was used for both devices on it
    
    * Skip probing port if "hdx=noprobe" parameter was used for both devices on it.
    
    * Obsolete "idex=noprobe" parameter - it only works for ide_generic, cmd640
      and PCI hosts in Compatibility mode (on alpha/x86/ia64/m32r/mips/ppc32).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 784d60e376ee..300536697622 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1444,7 +1444,7 @@ static int __init ide_setup(char *s)
 
 			case -1: /* "noprobe" */
 				hwif->noprobe = 1;
-				goto done;
+				goto obsolete_option;
 
 			case 1:	/* base */
 				vals[1] = vals[0] + 0x206; /* default ctl */

commit cbd34d00af2960097ebd46a31dabc8bb9f16ea4e
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Feb 26 21:50:33 2008 +0100

    ide: remove redundant comment from ide_unregister()
    
    Identical comment is present in ide_hwif_release_regions() documentation.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 477833f0daf5..784d60e376ee 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -590,11 +590,6 @@ void ide_unregister(unsigned int index, int init_default, int restore)
 		hwif->extra_ports = 0;
 	}
 
-	/*
-	 * Note that we only release the standard ports,
-	 * and do not even try to handle any extra ports
-	 * allocated for weird IDE interface chipsets.
-	 */
 	ide_hwif_release_regions(hwif);
 
 	/* copy original settings */

commit 2952755ce364b81f904b49397f6b0004dead2c9f
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Feb 13 23:20:36 2008 +0100

    ide: mark "ide=reverse" option as obsolete
    
    - it is valid only if "Probe IDE PCI devices in the PCI bus order
      (DEPRECATED)" config option is used
    
    - Greg needs to remove pci_get_device_reverse() for PCI core changes
    
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 4a8952a6c3da..477833f0daf5 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1229,7 +1229,7 @@ static int __init ide_setup(char *s)
 	if (!strcmp(s, "ide=reverse")) {
 		ide_scan_direction = 1;
 		printk(" : Enabled support for IDE inverse scan order.\n");
-		return 1;
+		goto obsolete_option;
 	}
 #endif
 

commit eba8ff946177ca38dfde0bf1d8ce0703c45c49b9
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Feb 11 00:32:13 2008 +0100

    ide: remove stale version number
    
    On Thursday 03 January 2008, Robert Hancock wrote:
    
    [...]
    
    > How about getting rid of this stupid thing in drivers/ide/ide.c:
    >
    > #defineREVISION"Revision: 7.00alpha2"
    >
    > which is used in:
    >
    > printk(KERN_INFO "Uniform Multi-Platform E-IDE driver " REVISION "\n");
    >
    > It's been 7.00alpha2 for god knows how long, so clearly this version
    > number is not useful..
    
    Cc: Robert Hancock <hancockr@shaw.ca>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index ad0e9955f73c..4a8952a6c3da 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -44,8 +44,6 @@
  *  inspiration from lots of linux users, esp.  hamish@zot.apana.org.au
  */
 
-#define	REVISION	"Revision: 7.00alpha2"
-
 #define _IDE_C			/* Tell ide.h it's really us */
 
 #include <linux/module.h>
@@ -1618,7 +1616,7 @@ static int __init ide_init(void)
 {
 	int ret;
 
-	printk(KERN_INFO "Uniform Multi-Platform E-IDE driver " REVISION "\n");
+	printk(KERN_INFO "Uniform Multi-Platform E-IDE driver\n");
 	system_bus_speed = ide_system_bus_speed();
 
 	printk(KERN_INFO "ide: Assuming %dMHz system bus speed "

commit 29dd59755a849cc6475faa6a75f3b804e23a6fc2
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Feb 6 02:57:50 2008 +0100

    ide: remove ide_setup_ports()
    
    ide-cris.c:
    * Add cris_setup_ports() helper and use it instead of ide_setup_ports()
      (fixes random value being set in ->io_ports[IDE_IRQ_OFFSET]).
    
    buddha.c:
    * Add buddha_setup_ports() helper and use it instead of ide_setup_ports().
    
    falconide.c:
    * Add falconide_setup_ports() helper and use it instead of ide_setup_ports(),
      also fix return value of falconide_init() while at it.
    
    gayle.c:
    * Add gayle_setup_ports() helper and use it instead of ide_setup_ports().
    
    macide.c:
    * Add macide_setup_ports() helper and use it instead of ide_setup_ports()
      (fixes incorrect value being set in ->io_ports[IDE_IRQ_OFFSET]).
    
    q40ide.c:
    * Fix q40_ide_setup_ports() comments.
    
    ide.c:
    * Remove no longer needed ide_setup_ports().
    
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index ac6136001615..ad0e9955f73c 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -618,60 +618,6 @@ void ide_unregister(unsigned int index, int init_default, int restore)
 
 EXPORT_SYMBOL(ide_unregister);
 
-
-/**
- *	ide_setup_ports 	-	set up IDE interface ports
- *	@hw: register descriptions
- *	@base: base register
- *	@offsets: table of register offsets
- *	@ctrl: control register
- *	@ack_irq: IRQ ack
- *	@irq: interrupt lie
- *
- *	Setup hw_regs_t structure described by parameters.  You
- *	may set up the hw structure yourself OR use this routine to
- *	do it for you. This is basically a helper
- *
- */
- 
-void ide_setup_ports (	hw_regs_t *hw,
-			unsigned long base, int *offsets,
-			unsigned long ctrl, unsigned long intr,
-			ide_ack_intr_t *ack_intr,
-/*
- *			ide_io_ops_t *iops,
- */
-			int irq)
-{
-	int i;
-
-	memset(hw, 0, sizeof(hw_regs_t));
-	for (i = 0; i < IDE_NR_PORTS; i++) {
-		if (offsets[i] == -1) {
-			switch(i) {
-				case IDE_CONTROL_OFFSET:
-					hw->io_ports[i] = ctrl;
-					break;
-#if defined(CONFIG_AMIGA) || defined(CONFIG_MAC)
-				case IDE_IRQ_OFFSET:
-					hw->io_ports[i] = intr;
-					break;
-#endif /* (CONFIG_AMIGA) || (CONFIG_MAC) */
-				default:
-					hw->io_ports[i] = 0;
-					break;
-			}
-		} else {
-			hw->io_ports[i] = base + offsets[i];
-		}
-	}
-	hw->irq = irq;
-	hw->ack_intr = ack_intr;
-/*
- *	hw->iops = iops;
- */
-}
-
 void ide_init_port_hw(ide_hwif_t *hwif, hw_regs_t *hw)
 {
 	memcpy(hwif->io_ports, hw->io_ports, sizeof(hwif->io_ports));

commit 92b83c8f3219c36d61a6600ceb422e65c409be59
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Feb 2 19:56:45 2008 +0100

    ide: remove ->nice0 and ->nice2 fields from ide_drive_t
    
    * ->nice0 and ->nice2 ide_drive_t fields are always zero so remove them.
    
    * IDE_NICE_0 and IDE_NICE_2 defines from <linux/hdreg.h> are no longer
      used by any kernel code so cover them with #ifndef/#endif __KERNEL__.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index d42216b52a7b..ac6136001615 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1035,11 +1035,8 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 		case HDIO_GET_NICE:
 			return put_user(drive->dsc_overlap	<<	IDE_NICE_DSC_OVERLAP	|
 					drive->atapi_overlap	<<	IDE_NICE_ATAPI_OVERLAP	|
-					drive->nice0		<< 	IDE_NICE_0		|
-					drive->nice1		<<	IDE_NICE_1		|
-					drive->nice2		<<	IDE_NICE_2,
+					drive->nice1 << IDE_NICE_1,
 					(long __user *) arg);
-
 #ifdef CONFIG_IDE_TASK_IOCTL
 		case HDIO_DRIVE_TASKFILE:
 		        if (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))

commit 9e016a719209d95338e314b46c3012cc7feaaeec
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Feb 2 19:56:39 2008 +0100

    ide: add ide_deprecated_find_port() helper
    
    * Factor out code for finding ide_hwifs[] slot from ide_register_hw()
      to ide_deprecated_find_port().
    
    * Convert bast-ide, ide-cs and delkin_cb host drivers to use ide_device_add()
      instead of ide_register_hw() (while at it drop doing "ide_unregister()" loop
      which tries to unregister _all_ IDE interfaces if useable ide_hwifs[] slot
      cannot be find).
    
    This patch leaves us with only two ide_register_hw() users:
    - drivers/macintosh/mediabay.c
    - drivers/ide/ide.c
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 166acd513d5b..d42216b52a7b 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -683,6 +683,31 @@ void ide_init_port_hw(ide_hwif_t *hwif, hw_regs_t *hw)
 }
 EXPORT_SYMBOL_GPL(ide_init_port_hw);
 
+ide_hwif_t *ide_deprecated_find_port(unsigned long base)
+{
+	ide_hwif_t *hwif;
+	int i;
+
+	for (i = 0; i < MAX_HWIFS; i++) {
+		hwif = &ide_hwifs[i];
+		if (hwif->io_ports[IDE_DATA_OFFSET] == base)
+			goto found;
+	}
+
+	for (i = 0; i < MAX_HWIFS; i++) {
+		hwif = &ide_hwifs[i];
+		if (hwif->hold)
+			continue;
+		if (!hwif->present && hwif->mate == NULL)
+			goto found;
+	}
+
+	hwif = NULL;
+found:
+	return hwif;
+}
+EXPORT_SYMBOL_GPL(ide_deprecated_find_port);
+
 /**
  *	ide_register_hw		-	register IDE interface
  *	@hw: hardware registers
@@ -702,18 +727,10 @@ int ide_register_hw(hw_regs_t *hw, void (*quirkproc)(ide_drive_t *),
 	u8 idx[4] = { 0xff, 0xff, 0xff, 0xff };
 
 	do {
-		for (index = 0; index < MAX_HWIFS; ++index) {
-			hwif = &ide_hwifs[index];
-			if (hwif->io_ports[IDE_DATA_OFFSET] == hw->io_ports[IDE_DATA_OFFSET])
-				goto found;
-		}
-		for (index = 0; index < MAX_HWIFS; ++index) {
-			hwif = &ide_hwifs[index];
-			if (hwif->hold)
-				continue;
-			if (!hwif->present && hwif->mate == NULL)
-				goto found;
-		}
+		hwif = ide_deprecated_find_port(hw->io_ports[IDE_DATA_OFFSET]);
+		index = hwif->index;
+		if (hwif)
+			goto found;
 		for (index = 0; index < MAX_HWIFS; index++)
 			ide_unregister(index, 1, 1);
 	} while (retry--);

commit f82c2b171905b6d5af92395d8159546351ab602f
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Feb 2 19:56:39 2008 +0100

    ide: add 'init_default' and 'restore' arguments to ide_unregister()
    
    * Add 'init_default' (flag for calling init_hwif_default()) and 'restore'
      (flag for calling ide_hwif_restore()) arguments to ide_unregister().
    
    * Update ide_unregister() users to set 'init_default' and 'restore' flags.
    
    * No need to set 'init_default' flag in ide_register_hw() if the setup done
      by init_hwif_default() is going to be overridden by ide_init_port_hw().
    
    * No need to set 'init_default' and 'restore' flags in cleanup_module().
    
    There should be no functionality changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 4b130e7102eb..166acd513d5b 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -499,6 +499,8 @@ void ide_remove_port_from_hwgroup(ide_hwif_t *hwif)
 /**
  *	ide_unregister		-	free an IDE interface
  *	@index: index of interface (will change soon to a pointer)
+ *	@init_default: init default hwif flag
+ *	@restore: restore hwif flag
  *
  *	Perform the final unregister of an IDE interface. At the moment
  *	we don't refcount interfaces so this will also get split up.
@@ -518,7 +520,7 @@ void ide_remove_port_from_hwgroup(ide_hwif_t *hwif)
  *	This is raving bonkers.
  */
 
-void ide_unregister(unsigned int index)
+void ide_unregister(unsigned int index, int init_default, int restore)
 {
 	ide_drive_t *drive;
 	ide_hwif_t *hwif, *g;
@@ -602,9 +604,12 @@ void ide_unregister(unsigned int index)
 
 	/* restore hwif data to pristine status */
 	ide_init_port_data(hwif, index);
-	init_hwif_default(hwif, index);
 
-	ide_hwif_restore(hwif, &tmp_hwif);
+	if (init_default)
+		init_hwif_default(hwif, index);
+
+	if (restore)
+		ide_hwif_restore(hwif, &tmp_hwif);
 
 abort:
 	spin_unlock_irq(&ide_lock);
@@ -710,12 +715,12 @@ int ide_register_hw(hw_regs_t *hw, void (*quirkproc)(ide_drive_t *),
 				goto found;
 		}
 		for (index = 0; index < MAX_HWIFS; index++)
-			ide_unregister(index);
+			ide_unregister(index, 1, 1);
 	} while (retry--);
 	return -1;
 found:
 	if (hwif->present)
-		ide_unregister(index);
+		ide_unregister(index, 0, 1);
 	else if (!hwif->hold)
 		ide_init_port_data(hwif, index);
 
@@ -1058,7 +1063,7 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 	        case HDIO_UNREGISTER_HWIF:
 			if (!capable(CAP_SYS_RAWIO)) return -EACCES;
 			/* (arg > MAX_HWIFS) checked in function */
-			ide_unregister(arg);
+			ide_unregister(arg, 1, 1);
 			return 0;
 		case HDIO_SET_NICE:
 			if (!capable(CAP_SYS_ADMIN)) return -EACCES;
@@ -1703,7 +1708,7 @@ void __exit cleanup_module (void)
 	int index;
 
 	for (index = 0; index < MAX_HWIFS; ++index)
-		ide_unregister(index);
+		ide_unregister(index, 0, 0);
 
 	proc_ide_destroy();
 

commit ead741df385607ab74876afdb05fd8ac27da9906
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Feb 2 19:56:38 2008 +0100

    ide: remove redundant init_hwif_default() call from ide_register_hw()
    
    ide_init_port_hw() call overrides setup done by init_hwif_default().
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index a71591ab0c5f..4b130e7102eb 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -716,10 +716,8 @@ int ide_register_hw(hw_regs_t *hw, void (*quirkproc)(ide_drive_t *),
 found:
 	if (hwif->present)
 		ide_unregister(index);
-	else if (!hwif->hold) {
+	else if (!hwif->hold)
 		ide_init_port_data(hwif, index);
-		init_hwif_default(hwif, index);
-	}
 
 	ide_init_port_hw(hwif, hw);
 	hwif->quirkproc = quirkproc;

commit 2244e850632f82466d7c041546326c7055fc7159
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Feb 2 19:56:38 2008 +0100

    ide: remove redundant hwif->present check from ide_register_hw()
    
    We check earlier for hwif->present and call ide_unregister() if necessary
    (after ide_unregister() hwif->present will be always cleared).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index eeb0e6a77f5b..a71591ab0c5f 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -720,8 +720,6 @@ int ide_register_hw(hw_regs_t *hw, void (*quirkproc)(ide_drive_t *),
 		ide_init_port_data(hwif, index);
 		init_hwif_default(hwif, index);
 	}
-	if (hwif->present)
-		return -1;
 
 	ide_init_port_hw(hwif, hw);
 	hwif->quirkproc = quirkproc;

commit c413b9b94d9a8e7548cc4b2e04b7df0439ce76fd
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Feb 2 19:56:31 2008 +0100

    ide: add struct ide_port_info instances to legacy host drivers
    
    * Remove 'struct pci_dev *dev' argument from ide_hwif_setup_dma().
    
    * Un-static ide_hwif_setup_dma() and add CONFIG_BLK_DEV_IDEDMA_PCI=n version.
    
    * Add 'const struct ide_port_info *d' argument to ide_device_add[_all]().
    
    * Factor out generic ports init from ide_pci_setup_ports() to ide_init_port(),
      move it to ide-probe.c and call it in in ide_device_add_all() instead of
      ide_pci_setup_ports().
    
    * Move ->mate setup to ide_device_add_all() from ide_port_init().
    
    * Add IDE_HFLAG_NO_AUTOTUNE host flag for host drivers that don't enable
      ->autotune currently.
    
    * Setup hwif->chipset in ide_init_port() but iff pi->chipset is set
      (to not override setup done by ide_hwif_configure()).
    
    * Add ETRAX host handling to ide_device_add_all().
    
    * cmd640.c: set IDE_HFLAG_ABUSE_* also for CONFIG_BLK_DEV_CMD640_ENHANCED=n.
    
    * pmac.c: make pmac_ide_setup_dma() return an error value and move DMA masks
      setup to pmac_ide_setup_device().
    
    * Add 'struct ide_port_info' instances to legacy host drivers, pass them to
      ide_device_add() calls and then remove open-coded ports initialization.
    
    Reviewed-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index fb0c47c8819d..eeb0e6a77f5b 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -728,7 +728,7 @@ int ide_register_hw(hw_regs_t *hw, void (*quirkproc)(ide_drive_t *),
 
 	idx[0] = index;
 
-	ide_device_add(idx);
+	ide_device_add(idx, NULL);
 
 	if (hwifp)
 		*hwifp = hwif;

commit 36e9dc469b1300d8bec6f2ab48b4556e2c4241ba
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Feb 2 19:56:28 2008 +0100

    dtc2278: fix ->io_32bit handling
    
    On DTC2278 32-bit I/O has to be enabled for both devices on the port
    so always enable it during init time and disallow further changes.
    
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index ab9ca2b5b66c..fb0c47c8819d 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -791,10 +791,6 @@ int set_io_32bit(ide_drive_t *drive, int arg)
 		return -EBUSY;
 
 	drive->io_32bit = arg;
-#ifdef CONFIG_BLK_DEV_DTC2278
-	if (HWIF(drive)->chipset == ide_dtc2278)
-		HWIF(drive)->drives[!drive->select.b.unit].io_32bit = arg;
-#endif /* CONFIG_BLK_DEV_DTC2278 */
 
 	spin_unlock_irq(&ide_lock);
 

commit fbd130887a45341259cde02e134581fb3dac6e14
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Feb 1 23:09:36 2008 +0100

    ide: use ide_remove_port_from_hwgroup in init_irq()
    
    There should be no functionality changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 1a3c89471175..ab9ca2b5b66c 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -461,7 +461,7 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 	hwif->hwif_data			= tmp_hwif->hwif_data;
 }
 
-static void ide_remove_port_from_hwgroup(ide_hwif_t *hwif)
+void ide_remove_port_from_hwgroup(ide_hwif_t *hwif)
 {
 	ide_hwgroup_t *hwgroup = hwif->hwgroup;
 

commit 96e5ad309c423bc0793e746337d5632ee5a49769
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Feb 1 23:09:35 2008 +0100

    ide: factor out code removing port from hwgroup from ide_unregister()
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index ea7512d99dec..1a3c89471175 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -461,6 +461,41 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 	hwif->hwif_data			= tmp_hwif->hwif_data;
 }
 
+static void ide_remove_port_from_hwgroup(ide_hwif_t *hwif)
+{
+	ide_hwgroup_t *hwgroup = hwif->hwgroup;
+
+	spin_lock_irq(&ide_lock);
+	/*
+	 * Remove us from the hwgroup, and free
+	 * the hwgroup if we were the only member
+	 */
+	if (hwif->next == hwif) {
+		BUG_ON(hwgroup->hwif != hwif);
+		kfree(hwgroup);
+	} else {
+		/* There is another interface in hwgroup.
+		 * Unlink us, and set hwgroup->drive and ->hwif to
+		 * something sane.
+		 */
+		ide_hwif_t *g = hwgroup->hwif;
+
+		while (g->next != hwif)
+			g = g->next;
+		g->next = hwif->next;
+		if (hwgroup->hwif == hwif) {
+			/* Chose a random hwif for hwgroup->hwif.
+			 * It's guaranteed that there are no drives
+			 * left in the hwgroup.
+			 */
+			BUG_ON(hwgroup->drive != NULL);
+			hwgroup->hwif = g;
+		}
+		BUG_ON(hwgroup->hwif == hwif);
+	}
+	spin_unlock_irq(&ide_lock);
+}
+
 /**
  *	ide_unregister		-	free an IDE interface
  *	@index: index of interface (will change soon to a pointer)
@@ -528,36 +563,8 @@ void ide_unregister(unsigned int index)
 	if (irq_count == 1)
 		free_irq(hwif->irq, hwgroup);
 
-	spin_lock_irq(&ide_lock);
-	/*
-	 * Remove us from the hwgroup, and free
-	 * the hwgroup if we were the only member
-	 */
-	if (hwif->next == hwif) {
-		BUG_ON(hwgroup->hwif != hwif);
-		kfree(hwgroup);
-	} else {
-		/* There is another interface in hwgroup.
-		 * Unlink us, and set hwgroup->drive and ->hwif to
-		 * something sane.
-		 */
-		g = hwgroup->hwif;
-		while (g->next != hwif)
-			g = g->next;
-		g->next = hwif->next;
-		if (hwgroup->hwif == hwif) {
-			/* Chose a random hwif for hwgroup->hwif.
-			 * It's guaranteed that there are no drives
-			 * left in the hwgroup.
-			 */
-			BUG_ON(hwgroup->drive != NULL);
-			hwgroup->hwif = g;
-		}
-		BUG_ON(hwgroup->hwif == hwif);
-	}
+	ide_remove_port_from_hwgroup(hwif);
 
-	/* More messed up locking ... */
-	spin_unlock_irq(&ide_lock);
 	device_unregister(&hwif->gendev);
 	wait_for_completion(&hwif->gendev_rel_comp);
 

commit 7cba97f12963721eca648d6901b294750a1fa3bd
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Feb 1 23:09:35 2008 +0100

    ide: I/O resources are released too early in ide_unregister()
    
    Release I/O resources after releasing DMA.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 7fa30acf0fc5..ea7512d99dec 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -529,13 +529,6 @@ void ide_unregister(unsigned int index)
 		free_irq(hwif->irq, hwgroup);
 
 	spin_lock_irq(&ide_lock);
-	/*
-	 * Note that we only release the standard ports,
-	 * and do not even try to handle any extra ports
-	 * allocated for weird IDE interface chipsets.
-	 */
-	ide_hwif_release_regions(hwif);
-
 	/*
 	 * Remove us from the hwgroup, and free
 	 * the hwgroup if we were the only member
@@ -590,6 +583,13 @@ void ide_unregister(unsigned int index)
 		hwif->extra_ports = 0;
 	}
 
+	/*
+	 * Note that we only release the standard ports,
+	 * and do not even try to handle any extra ports
+	 * allocated for weird IDE interface chipsets.
+	 */
+	ide_hwif_release_regions(hwif);
+
 	/* copy original settings */
 	tmp_hwif = *hwif;
 

commit 537f06c5deaffbbe155bcc898369f889e7f3e647
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Feb 1 23:09:35 2008 +0100

    ide: cleanup ide_system_bus_speed()
    
    Use the facts that:
    
    * When ide_init() is called 'system_bus_speed' always equals zero.
    
    * system_bus_clock() is never called before ide_init().
    
    and:
    
    * Move printk() from ide_system_bus_speed() to ide_init().
    
    * Don't assign 'system_bus_speed' in ide_system_bus_speed().
    
    * Don't call ide_system_bus_speed() in system_bus_clock().
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 725187bc6003..7fa30acf0fc5 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -240,22 +240,12 @@ static int ide_system_bus_speed(void)
 #define pci_default 0
 #endif /* CONFIG_PCI */
 
-	if (!system_bus_speed) {
-		if (idebus_parameter) {
-			/* user supplied value */
-			system_bus_speed = idebus_parameter;
-		} else if (pci_dev_present(pci_default)) {
-			/* safe default value for PCI */
-			system_bus_speed = 33;
-		} else {
-			/* safe default value for VESA and PCI */
-			system_bus_speed = 50;
-		}
-		printk(KERN_INFO "ide: Assuming %dMHz system bus speed "
-			"for PIO modes%s\n", system_bus_speed,
-			idebus_parameter ? "" : "; override with idebus=xx");
-	}
-	return system_bus_speed;
+	/* user supplied value */
+	if (idebus_parameter)
+		return idebus_parameter;
+
+	/* safe default value for PCI or VESA and PCI*/
+	return pci_dev_present(pci_default) ? 33 : 50;
 }
 
 ide_hwif_t * ide_find_port(unsigned long base)
@@ -912,7 +902,7 @@ static int set_unmaskirq(ide_drive_t *drive, int arg)
 
 int system_bus_clock (void)
 {
-	return((int) ((!system_bus_speed) ? ide_system_bus_speed() : system_bus_speed ));
+	return system_bus_speed;
 }
 
 EXPORT_SYMBOL(system_bus_clock);
@@ -1667,6 +1657,10 @@ static int __init ide_init(void)
 	printk(KERN_INFO "Uniform Multi-Platform E-IDE driver " REVISION "\n");
 	system_bus_speed = ide_system_bus_speed();
 
+	printk(KERN_INFO "ide: Assuming %dMHz system bus speed "
+			 "for PIO modes%s\n", system_bus_speed,
+			idebus_parameter ? "" : "; override with idebus=xx");
+
 	ret = bus_register(&ide_bus_type);
 	if (ret < 0) {
 		printk(KERN_WARNING "IDE: bus_register error: %d\n", ret);

commit 59bca8cc995428c34d8cdfadfa87c8e3f01c4340
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Feb 1 23:09:33 2008 +0100

    ide: update/add my Copyrights
    
    The last years stuff and a trip down memory lane...
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index baf84cd9eb06..725187bc6003 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1,5 +1,6 @@
 /*
- *  Copyright (C) 1994-1998  Linus Torvalds & authors (see below)
+ *  Copyright (C) 1994-1998	    Linus Torvalds & authors (see below)
+ *  Copyrifht (C) 2003-2005, 2007   Bartlomiej Zolnierkiewicz
  */
 
 /*

commit 58f189fccc72bb8a91de1854e519b47d64fbdbaa
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Feb 1 23:09:33 2008 +0100

    ide: delete filenames/versions from comments
    
    Delete filenames/versions from comments.
    
    I'm leaving decisions about adding DRV_VERSION defines and MODULE_VERSION()-s
    to maintainers of the respective drivers.
    
    While at it:
    
    * Remove unused VERSION define from ide.c.
    
    * Remove unused/stale DRV_VERSION define from au1xxx-ide.c.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 9805c43dfd8a..baf84cd9eb06 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1,6 +1,4 @@
 /*
- *  linux/drivers/ide/ide.c		Version 7.00beta2	Mar 05 2003
- *
  *  Copyright (C) 1994-1998  Linus Torvalds & authors (see below)
  */
 
@@ -46,7 +44,6 @@
  */
 
 #define	REVISION	"Revision: 7.00alpha2"
-#define	VERSION		"Id: ide.c 7.00a2 20020906"
 
 #define _IDE_C			/* Tell ide.h it's really us */
 

commit 36501650ec45b1db308c3b51886044863be2d762
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Feb 1 23:09:31 2008 +0100

    ide: keep pointer to struct device instead of struct pci_dev in ide_hwif_t
    
    Keep pointer to struct device instead of struct pci_dev in ide_hwif_t.
    
    While on it:
    * Use *dev->dma_mask instead of pci_dev->dma_mask in ide_toggle_bounce().
    
    There should be no functionality changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 97894abd9ebc..9805c43dfd8a 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -405,8 +405,9 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 	hwif->chipset			= tmp_hwif->chipset;
 	hwif->hold			= tmp_hwif->hold;
 
+	hwif->dev			= tmp_hwif->dev;
+
 #ifdef CONFIG_BLK_DEV_IDEPCI
-	hwif->pci_dev			= tmp_hwif->pci_dev;
 	hwif->cds			= tmp_hwif->cds;
 #endif
 

commit 852738f39258deafb3d89c187cb1a4050820d555
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Jan 26 20:13:12 2008 +0100

    ide: convert "empty" REQ_TYPE_ATA_CMD requests to use REQ_TYPE_ATA_TASKFILE
    
    Based on the previous work by Tejun Heo.
    
    There should be no functionality changes caused by this patch.
    
    Cc: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 446b12850155..97894abd9ebc 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -880,7 +880,7 @@ int set_pio_mode(ide_drive_t *drive, int arg)
 		return -EBUSY;
 
 	ide_init_drive_cmd(&rq);
-	rq.cmd_type = REQ_TYPE_ATA_CMD;
+	rq.cmd_type = REQ_TYPE_ATA_TASKFILE;
 
 	drive->tune_req = (u8) arg;
 	drive->special.b.set_tune = 1;

commit 145b75e9aedbe36c55e45da8564dcd0814bdd89e
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Jan 26 20:13:11 2008 +0100

    ide: initialize rq->cmd_type in ide_init_drive_cmd() callers
    
    * Initialize rq->cmd_type in ide_wait_cmd(), ide_cmd_ioctl() and
      set_pio_mode() (other callers were aleady over-riding rq->cmd_type).
    
    * Remove no longer needed rq->cmd_type setup from ide_init_drive_cmd().
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 52115ef1f01a..446b12850155 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -878,7 +878,10 @@ int set_pio_mode(ide_drive_t *drive, int arg)
 
 	if (drive->special.b.set_tune)
 		return -EBUSY;
+
 	ide_init_drive_cmd(&rq);
+	rq.cmd_type = REQ_TYPE_ATA_CMD;
+
 	drive->tune_req = (u8) arg;
 	drive->special.b.set_tune = 1;
 	(void) ide_do_drive_cmd(drive, &rq, ide_wait);

commit 9e47be0c97f7357b80e91dc0632e9cce2eb025e0
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Jan 26 20:13:09 2008 +0100

    ide: remove broken disk byte-swapping support
    
    Remove broken disk byte-swapping support:
    - it can cause a data corruption on SMP (or if using PREEMPT on UP)
    - all data coming from disk are byte-swapped by taskfile_*_data() which
      results in incorrect identify data being reported by /proc/ide/ and IOCTLs
    - "hdx=bswap/byteswap" kernel parameter has been broken on m68k host drivers
      (including Atari/Q40 ones) since 2.5.x days (because of 'hwif' zero-ing)
    - byte-swapping is limited to PIO transfers (for working with TiVo disks on
      x86 machines using user-space solutions or dm-byteswap should result in
      much better performance because DMA can be used)
    
    For previous discussions please see:
    
    http://www.ussg.iu.edu/hypermail/linux/kernel/0201.0/0768.html
    http://lkml.org/lkml/2004/2/28/111
    
    [ I have dm-byteswap device mapper target if somebody is interested
      (patch is for 2.6.4 though but I'll dust it off if needed). ]
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 5f3e53ec5838..52115ef1f01a 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1303,7 +1303,7 @@ static int __init ide_setup(char *s)
 	if (s[0] == 'h' && s[1] == 'd' && s[2] >= 'a' && s[2] <= max_drive) {
 		const char *hd_words[] = {
 			"none", "noprobe", "nowerr", "cdrom", "nodma",
-			"autotune", "noautotune", "minus8", "swapdata", "bswap",
+			"autotune", "noautotune", "-8", "-9", "-10",
 			"noflush", "remap", "remap63", "scsi", NULL };
 		unit = s[2] - 'a';
 		hw   = unit / MAX_DRIVES;
@@ -1339,10 +1339,6 @@ static int __init ide_setup(char *s)
 			case -7: /* "noautotune" */
 				drive->autotune = IDE_TUNE_NOAUTO;
 				goto obsolete_option;
-			case -9: /* "swapdata" */
-			case -10: /* "bswap" */
-				drive->bswap = 1;
-				goto done;
 			case -11: /* noflush */
 				drive->noflush = 1;
 				goto done;

commit ade2daf9c6e57845fe83a24e0a9fa1c03c6e91b1
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Jan 26 20:13:07 2008 +0100

    ide: make remaining built-in only IDE host drivers modular (take 2)
    
    * Make remaining built-in only IDE host drivers modular, add ide-scan-pci.c
      file for probing PCI host drivers registered with IDE core (special case
      for built-in IDE and CONFIG_IDEPCI_PCIBUS_ORDER=y) and then take care of
      the ordering in which all IDE host drivers are probed when IDE is built-in
      during link time.
    
    * Move probing of gayle, falconide, macide, q40ide and buddha (m68k arch
      specific) host drivers, before PCI ones (no PCI on m68k), ide-cris (cris
      arch specific), cmd640 (x86 arch specific) and pmac (ppc arch specific).
    
    * Move probing of ide-cris (cris arch specific) host driver before cmd640
      (x86 arch specific).
    
    * Move probing of mpc8xx (ppc specific) host driver before ide-pnp (depends
      on ISA and none of ppc platform that use mpc8xx supports ISA) and ide-h8300
      (h8300 arch specific).
    
    * Add "probe_vlb" kernel parameter to cmd640 host driver and update
      Documentation/ide.txt accordingly.
    
    * Make IDE_ARM config option visible so it can also be disabled if needed.
    
    * Remove bogus comment from ide.c while at it.
    
    v2:
    * Fix two issues spotted by Sergei:
      - replace ENOMEM error value by ENOENT in ide-h8300 host driver
      - fix MODULE_PARM_DESC() in cmd640 host driver
    
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 6f99f5c90062..5f3e53ec5838 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -95,7 +95,7 @@ DEFINE_MUTEX(ide_cfg_mtx);
  __cacheline_aligned_in_smp DEFINE_SPINLOCK(ide_lock);
 
 #ifdef CONFIG_IDEPCI_PCIBUS_ORDER
-static int ide_scan_direction; /* THIS was formerly 2.2.x pci=reverse */
+int ide_scan_direction; /* THIS was formerly 2.2.x pci=reverse */
 #endif
 
 int noautodma = 0;
@@ -178,8 +178,6 @@ static void init_hwif_default(ide_hwif_t *hwif, unsigned int index)
 #endif
 }
 
-extern void ide_arm_init(void);
-
 /*
  * init_ide_data() sets reasonable default values into all fields
  * of all instances of the hwifs and drives, but only on the first call.
@@ -1223,26 +1221,12 @@ static int __init match_parm (char *s, const char *keywords[], int vals[], int m
 	return 0;	/* zero = nothing matched */
 }
 
-#ifdef CONFIG_BLK_DEV_ALI14XX
 extern int probe_ali14xx;
-extern int ali14xx_init(void);
-#endif
-#ifdef CONFIG_BLK_DEV_UMC8672
 extern int probe_umc8672;
-extern int umc8672_init(void);
-#endif
-#ifdef CONFIG_BLK_DEV_DTC2278
 extern int probe_dtc2278;
-extern int dtc2278_init(void);
-#endif
-#ifdef CONFIG_BLK_DEV_HT6560B
 extern int probe_ht6560b;
-extern int ht6560b_init(void);
-#endif
-#ifdef CONFIG_BLK_DEV_QD65XX
 extern int probe_qd65xx;
-extern int qd65xx_init(void);
-#endif
+extern int cmd640_vlb;
 
 static int __initdata is_chipset_set[MAX_HWIFS];
 
@@ -1458,11 +1442,8 @@ static int __init ide_setup(char *s)
 #endif
 #ifdef CONFIG_BLK_DEV_CMD640
 			case -14: /* "cmd640_vlb" */
-			{
-				extern int cmd640_vlb; /* flag for cmd640.c */
 				cmd640_vlb = 1;
 				goto done;
-			}
 #endif
 #ifdef CONFIG_BLK_DEV_HT6560B
 			case -13: /* "ht6560b" */
@@ -1552,83 +1533,6 @@ static int __init ide_setup(char *s)
 	return 1;
 }
 
-extern void __init pnpide_init(void);
-extern void __exit pnpide_exit(void);
-extern void __init h8300_ide_init(void);
-extern void __init mpc8xx_ide_probe(void);
-
-/*
- * probe_for_hwifs() finds/initializes "known" IDE interfaces
- */
-static void __init probe_for_hwifs (void)
-{
-#ifdef CONFIG_IDEPCI_PCIBUS_ORDER
-	ide_scan_pcibus(ide_scan_direction);
-#endif
-
-#ifdef CONFIG_ETRAX_IDE
-	{
-		extern void init_e100_ide(void);
-		init_e100_ide();
-	}
-#endif /* CONFIG_ETRAX_IDE */
-#ifdef CONFIG_BLK_DEV_CMD640
-	{
-		extern void ide_probe_for_cmd640x(void);
-		ide_probe_for_cmd640x();
-	}
-#endif /* CONFIG_BLK_DEV_CMD640 */
-#ifdef CONFIG_BLK_DEV_IDE_PMAC
-	{
-		extern int pmac_ide_probe(void);
-		(void)pmac_ide_probe();
-	}
-#endif /* CONFIG_BLK_DEV_IDE_PMAC */
-#ifdef CONFIG_BLK_DEV_GAYLE
-	{
-		extern void gayle_init(void);
-		gayle_init();
-	}
-#endif /* CONFIG_BLK_DEV_GAYLE */
-#ifdef CONFIG_BLK_DEV_FALCON_IDE
-	{
-		extern void falconide_init(void);
-		falconide_init();
-	}
-#endif /* CONFIG_BLK_DEV_FALCON_IDE */
-#ifdef CONFIG_BLK_DEV_MAC_IDE
-	{
-		extern void macide_init(void);
-		macide_init();
-	}
-#endif /* CONFIG_BLK_DEV_MAC_IDE */
-#ifdef CONFIG_BLK_DEV_Q40IDE
-	{
-		extern void q40ide_init(void);
-		q40ide_init();
-	}
-#endif /* CONFIG_BLK_DEV_Q40IDE */
-#ifdef CONFIG_BLK_DEV_BUDDHA
-	{
-		extern void buddha_init(void);
-		buddha_init();
-	}
-#endif /* CONFIG_BLK_DEV_BUDDHA */
-#ifdef CONFIG_BLK_DEV_IDEPNP
-	pnpide_init();
-#endif
-#ifdef CONFIG_H8300
-	h8300_ide_init();
-#endif
-#ifdef BLK_DEV_MPC8xx_IDE
-	mpc8xx_ide_probe();
-#endif
-}
-
-/*
- * Probe module
- */
-
 EXPORT_SYMBOL(ide_lock);
 
 static int ide_bus_match(struct device *dev, struct device_driver *drv)
@@ -1775,33 +1679,6 @@ static int __init ide_init(void)
 
 	proc_ide_create();
 
-#ifdef CONFIG_IDE_ARM
-	ide_arm_init();
-#endif
-#ifdef CONFIG_BLK_DEV_ALI14XX
-	if (probe_ali14xx)
-		(void)ali14xx_init();
-#endif
-#ifdef CONFIG_BLK_DEV_UMC8672
-	if (probe_umc8672)
-		(void)umc8672_init();
-#endif
-#ifdef CONFIG_BLK_DEV_DTC2278
-	if (probe_dtc2278)
-		(void)dtc2278_init();
-#endif
-#ifdef CONFIG_BLK_DEV_HT6560B
-	if (probe_ht6560b)
-		(void)ht6560b_init();
-#endif
-#ifdef CONFIG_BLK_DEV_QD65XX
-	if (probe_qd65xx)
-		(void)qd65xx_init();
-#endif
-
-	/* Probe for special PCI and other "known" interface chipsets. */
-	probe_for_hwifs();
-
 	return 0;
 }
 
@@ -1837,10 +1714,6 @@ void __exit cleanup_module (void)
 	for (index = 0; index < MAX_HWIFS; ++index)
 		ide_unregister(index);
 
-#ifdef CONFIG_BLK_DEV_IDEPNP
-	pnpide_exit();
-#endif
-
 	proc_ide_destroy();
 
 	bus_unregister(&ide_bus_type);

commit 8ac4ce742c66100931b6f2d7a36b0df08bc721fe
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Jan 26 20:13:06 2008 +0100

    ide: fix host drivers depending on ide_generic to probe for interfaces (take 2)
    
    * Add mpc8xx_ide_probe() to mpc8xx.c and call it from probe_for_hwifs().
    
    * Convert ide_arm, ide-cris, ide-h8300, ide-pnp, buddha, falconide, gayle,
      macide, q40ide, cmd640 and mpc8xx host drivers to use ide_device_add().
    
      This removes dependency on ide_generic for these drivers so update
      ide/Kconfig accordingly.
    
    v2:
    * ide_arm build fix (s/ide_device_idx/ide_device_add/)
      (Thanks to Christoph Lameter <clameter@sgi.com> for reporting the problem).
    
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 77af743425e8..6f99f5c90062 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1555,6 +1555,7 @@ static int __init ide_setup(char *s)
 extern void __init pnpide_init(void);
 extern void __exit pnpide_exit(void);
 extern void __init h8300_ide_init(void);
+extern void __init mpc8xx_ide_probe(void);
 
 /*
  * probe_for_hwifs() finds/initializes "known" IDE interfaces
@@ -1619,6 +1620,9 @@ static void __init probe_for_hwifs (void)
 #ifdef CONFIG_H8300
 	h8300_ide_init();
 #endif
+#ifdef BLK_DEV_MPC8xx_IDE
+	mpc8xx_ide_probe();
+#endif
 }
 
 /*

commit 944000921d41c5aacfda6515ad3a0bbde52f8fa3
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Jan 26 20:13:06 2008 +0100

    ide: move ide_arm_init() call from init_ide_data() to ide_init()
    
    * Remove ide_init_port_data() call from ide_arm_init() and move
      ide_arm_init() call from init_ide_data() to ide_init().
    
    This patch is a preparation for the future changes (and as a side-effect
    makes obsolete "idex=io[,ctl[,irq]]" kernel parameters work for ide_arm).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 3ec220b64d0b..77af743425e8 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -218,9 +218,6 @@ static void __init init_ide_data (void)
 			ide_init_default_irq(hwif->io_ports[IDE_DATA_OFFSET]);
 #endif
 	}
-#ifdef CONFIG_IDE_ARM
-	ide_arm_init();
-#endif
 }
 
 /**
@@ -1774,6 +1771,9 @@ static int __init ide_init(void)
 
 	proc_ide_create();
 
+#ifdef CONFIG_IDE_ARM
+	ide_arm_init();
+#endif
 #ifdef CONFIG_BLK_DEV_ALI14XX
 	if (probe_ali14xx)
 		(void)ali14xx_init();

commit cbb010c180294a5242a7681555c28737d9dd26ab
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Jan 26 20:13:06 2008 +0100

    ide: drop 'initializing' argument from ide_register_hw()
    
    * Rename init_hwif_data() to ide_init_port_data() and export it.
    
    * For all users of ide_register_hw() with 'initializing' argument set
      hwif->present and hwif->hold are always zero so convert these host
      drivers to use ide_find_port()+ide_init_port_data()+ide_init_port_hw()
      instead (also no need for init_hwif_default() call since the setup
      done by it gets over-ridden by ide_init_port_hw() call).
    
    * Drop 'initializing' argument from ide_register_hw().
    
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 98bd45e8c175..3ec220b64d0b 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -116,7 +116,7 @@ EXPORT_SYMBOL(ide_hwifs);
 /*
  * Do not even *think* about calling this!
  */
-static void init_hwif_data(ide_hwif_t *hwif, unsigned int index)
+void ide_init_port_data(ide_hwif_t *hwif, unsigned int index)
 {
 	unsigned int unit;
 
@@ -159,6 +159,7 @@ static void init_hwif_data(ide_hwif_t *hwif, unsigned int index)
 		init_completion(&drive->gendev_rel_comp);
 	}
 }
+EXPORT_SYMBOL_GPL(ide_init_port_data);
 
 static void init_hwif_default(ide_hwif_t *hwif, unsigned int index)
 {
@@ -210,7 +211,7 @@ static void __init init_ide_data (void)
 	/* Initialise all interface structures */
 	for (index = 0; index < MAX_HWIFS; ++index) {
 		hwif = &ide_hwifs[index];
-		init_hwif_data(hwif, index);
+		ide_init_port_data(hwif, index);
 		init_hwif_default(hwif, index);
 #if !defined(CONFIG_PPC32) || !defined(CONFIG_PCI)
 		hwif->irq =
@@ -609,7 +610,7 @@ void ide_unregister(unsigned int index)
 	tmp_hwif = *hwif;
 
 	/* restore hwif data to pristine status */
-	init_hwif_data(hwif, index);
+	ide_init_port_data(hwif, index);
 	init_hwif_default(hwif, index);
 
 	ide_hwif_restore(hwif, &tmp_hwif);
@@ -690,29 +691,19 @@ EXPORT_SYMBOL_GPL(ide_init_port_hw);
  *	ide_register_hw		-	register IDE interface
  *	@hw: hardware registers
  *	@quirkproc: quirkproc function
- *	@initializing: set while initializing built-in drivers
  *	@hwifp: pointer to returned hwif
  *
  *	Register an IDE interface, specifying exactly the registers etc.
- *	Set init=1 iff calling before probes have taken place.
  *
  *	Returns -1 on error.
  */
 
 int ide_register_hw(hw_regs_t *hw, void (*quirkproc)(ide_drive_t *),
-		    int initializing, ide_hwif_t **hwifp)
+		    ide_hwif_t **hwifp)
 {
 	int index, retry = 1;
 	ide_hwif_t *hwif;
-
-	if (initializing) {
-		hwif = ide_find_port(hw->io_ports[IDE_DATA_OFFSET]);
-		if (hwif) {
-			index = hwif->index;
-			goto found;
-		}
-		return -1;
-	}
+	u8 idx[4] = { 0xff, 0xff, 0xff, 0xff };
 
 	do {
 		for (index = 0; index < MAX_HWIFS; ++index) {
@@ -735,7 +726,7 @@ int ide_register_hw(hw_regs_t *hw, void (*quirkproc)(ide_drive_t *),
 	if (hwif->present)
 		ide_unregister(index);
 	else if (!hwif->hold) {
-		init_hwif_data(hwif, index);
+		ide_init_port_data(hwif, index);
 		init_hwif_default(hwif, index);
 	}
 	if (hwif->present)
@@ -744,16 +735,14 @@ int ide_register_hw(hw_regs_t *hw, void (*quirkproc)(ide_drive_t *),
 	ide_init_port_hw(hwif, hw);
 	hwif->quirkproc = quirkproc;
 
-	if (initializing == 0) {
-		u8 idx[4] = { index, 0xff, 0xff, 0xff };
+	idx[0] = index;
 
-		ide_device_add(idx);
-	}
+	ide_device_add(idx);
 
 	if (hwifp)
 		*hwifp = hwif;
 
-	return (initializing || hwif->present) ? index : -1;
+	return hwif->present ? index : -1;
 }
 
 EXPORT_SYMBOL(ide_register_hw);
@@ -1076,7 +1065,7 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 			ide_init_hwif_ports(&hw, (unsigned long) args[0],
 					    (unsigned long) args[1], NULL);
 			hw.irq = args[2];
-			if (ide_register_hw(&hw, NULL, 0, NULL) == -1)
+			if (ide_register_hw(&hw, NULL, NULL) == -1)
 				return -EIO;
 			return 0;
 		}

commit 57c802e84f9c759c3d1794a9dbe81bc10444df62
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Jan 26 20:13:05 2008 +0100

    ide: add ide_init_port_hw() helper
    
    * Add ide_init_port_hw() helper.
    
    * rapide.c: convert rapide_locate_hwif() to rapide_setup_ports()
      and use ide_init_port_hw().
    
    * ide_platform.c: convert plat_ide_locate_hwif() to plat_ide_setup_ports()
      and use ide_init_port_hw().
    
    * sgiioc4.c: use ide_init_port_hw().
    
    * pmac.c: add 'hw_regs_t *hw' argument to pmac_ide_setup_device(),
      setup 'hw' in pmac_ide_{macio,pci}_attach() and use ide_init_port_hw()
      in pmac_ide_setup_device().
    
    This patch is a preparation for the future changes in the IDE probing code.
    
    There should be no functionality changes caused by this patch.
    
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Anton Vorontsov <avorontsov@ru.mvista.com>
    Cc: Jeremy Higdon <jeremy@sgi.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 8ef521f66f87..98bd45e8c175 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -675,6 +675,17 @@ void ide_setup_ports (	hw_regs_t *hw,
  */
 }
 
+void ide_init_port_hw(ide_hwif_t *hwif, hw_regs_t *hw)
+{
+	memcpy(hwif->io_ports, hw->io_ports, sizeof(hwif->io_ports));
+	hwif->irq = hw->irq;
+	hwif->noprobe = 0;
+	hwif->chipset = hw->chipset;
+	hwif->gendev.parent = hw->dev;
+	hwif->ack_intr = hw->ack_intr;
+}
+EXPORT_SYMBOL_GPL(ide_init_port_hw);
+
 /**
  *	ide_register_hw		-	register IDE interface
  *	@hw: hardware registers
@@ -729,13 +740,9 @@ int ide_register_hw(hw_regs_t *hw, void (*quirkproc)(ide_drive_t *),
 	}
 	if (hwif->present)
 		return -1;
-	memcpy(hwif->io_ports, hw->io_ports, sizeof(hwif->io_ports));
-	hwif->irq = hw->irq;
-	hwif->noprobe = 0;
+
+	ide_init_port_hw(hwif, hw);
 	hwif->quirkproc = quirkproc;
-	hwif->chipset = hw->chipset;
-	hwif->gendev.parent = hw->dev;
-	hwif->ack_intr = hw->ack_intr;
 
 	if (initializing == 0) {
 		u8 idx[4] = { index, 0xff, 0xff, 0xff };

commit 795d74b51a853e1f5f2c81baf6666836a3866f08
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Jan 26 20:13:03 2008 +0100

    ide: don't try to unregister interfaces if 'initializing' in ide_register_hw()
    
    Host drivers using ide_register_hw() and 'initializing == 1':
    
    * ide-pnp
      - depends on ISA
    
    * ide_arm
      - ARM arch specific
      - initialized before all other host drivers
    
    * ide-cris
      - CRIS arch specific => IDE_ARCH_OBSOLETE_INIT is not defined
      - broken
    
    * ide-h8300
      - H8300 arch specific => IDE_ARCH_OBSOLETE_INIT is not defined, no PCI
    
    * buddha/q40/gayle/macide/falconide
      - M68K arch specific => IDE_ARCH_OBSOLETE_INIT is not defined, no PCI
    
    Since the only host drivers which probe interfaces before the above ones are:
    
    * ali14xx/dtc2278/ht6560b/qd65xx/umc8672
      - depend on ISA
      - require IDE_ARCH_OBSOLETE_INIT=y to work
    
    * PCI ones
      - depend on PCI
    
    don't try to unregister interfaces if 'initializing == 1' in ide_register_hw()
    (it is possible that built-in host drivers will claim all IDE interfaces but
    later ide-pnp host driver will try to unregister them - this change fixes it).
    
    Also skip hwif->hold check if 'initializing == 1' since it is set only by:
    
    * pmac
      - PPC && PMAC specific => no ISA
    
    * au1xxx-ide
      - MIPS && SOC_AU1200 specific => no ISA
    
    and use ide_find_port() helper to find free ide_hwifs[] slot.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 0d7328e0fb96..8ef521f66f87 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -694,6 +694,15 @@ int ide_register_hw(hw_regs_t *hw, void (*quirkproc)(ide_drive_t *),
 	int index, retry = 1;
 	ide_hwif_t *hwif;
 
+	if (initializing) {
+		hwif = ide_find_port(hw->io_ports[IDE_DATA_OFFSET]);
+		if (hwif) {
+			index = hwif->index;
+			goto found;
+		}
+		return -1;
+	}
+
 	do {
 		for (index = 0; index < MAX_HWIFS; ++index) {
 			hwif = &ide_hwifs[index];
@@ -704,8 +713,7 @@ int ide_register_hw(hw_regs_t *hw, void (*quirkproc)(ide_drive_t *),
 			hwif = &ide_hwifs[index];
 			if (hwif->hold)
 				continue;
-			if ((!hwif->present && !hwif->mate && !initializing) ||
-			    (!hwif->io_ports[IDE_DATA_OFFSET] && initializing))
+			if (!hwif->present && hwif->mate == NULL)
 				goto found;
 		}
 		for (index = 0; index < MAX_HWIFS; index++)

commit f01393e48c44e30f7c9a36c8b98a07b0232580fe
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Jan 26 20:13:03 2008 +0100

    ide: merge ->fixup and ->quirkproc methods
    
    * Assign drive->quirk_list in ->quirkproc implementations:
      - hpt366.c::hpt3xx_quirkproc()
      - pdc202xx_new.c::pdcnew_quirkproc()
      - pdc202xx_old.c::pdc202xx_quirkproc()
    
    * Make ->quirkproc void.
    
    * Move calling ->quirkproc from do_identify() to probe_hwif().
    
    * Convert it821x_fixups() to it821x_quirkproc() in it821x.c.
    
    * Convert siimage_fixup() to sil_quirkproc() in siimage.c, also remove
      no longer needed drive->present check from is_dev_seagate_sata().
    
    * Convert ide_undecoded_slave() to accept 'drive' instead of 'hwif'
      as an argument.  Then convert ide_register_hw() to accept 'quirkproc'
      argument instead of 'fixup' one.
    
    * Remove no longer needed ->fixup method.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 7819fbd4d5fd..0d7328e0fb96 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -414,8 +414,6 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 	hwif->cds			= tmp_hwif->cds;
 #endif
 
-	hwif->fixup			= tmp_hwif->fixup;
-
 	hwif->set_pio_mode		= tmp_hwif->set_pio_mode;
 	hwif->set_dma_mode		= tmp_hwif->set_dma_mode;
 	hwif->mdma_filter		= tmp_hwif->mdma_filter;
@@ -680,7 +678,7 @@ void ide_setup_ports (	hw_regs_t *hw,
 /**
  *	ide_register_hw		-	register IDE interface
  *	@hw: hardware registers
- *	@fixup: fixup function
+ *	@quirkproc: quirkproc function
  *	@initializing: set while initializing built-in drivers
  *	@hwifp: pointer to returned hwif
  *
@@ -690,7 +688,7 @@ void ide_setup_ports (	hw_regs_t *hw,
  *	Returns -1 on error.
  */
 
-int ide_register_hw(hw_regs_t *hw, void (*fixup)(ide_hwif_t *),
+int ide_register_hw(hw_regs_t *hw, void (*quirkproc)(ide_drive_t *),
 		    int initializing, ide_hwif_t **hwifp)
 {
 	int index, retry = 1;
@@ -726,7 +724,7 @@ int ide_register_hw(hw_regs_t *hw, void (*fixup)(ide_hwif_t *),
 	memcpy(hwif->io_ports, hw->io_ports, sizeof(hwif->io_ports));
 	hwif->irq = hw->irq;
 	hwif->noprobe = 0;
-	hwif->fixup = fixup;
+	hwif->quirkproc = quirkproc;
 	hwif->chipset = hw->chipset;
 	hwif->gendev.parent = hw->dev;
 	hwif->ack_intr = hw->ack_intr;

commit 15ce926ada545cb078711bd9a18c083c93fa01d7
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Jan 26 20:13:03 2008 +0100

    ide: merge ->dma_host_{on,off} methods into ->dma_host_set method
    
    Merge ->dma_host_{on,off} methods into ->dma_host_set method
    which takes 'int on' argument.
    
    There should be no functionality changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 095ff34870da..7819fbd4d5fd 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -433,14 +433,13 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 	hwif->atapi_input_bytes		= tmp_hwif->atapi_input_bytes;
 	hwif->atapi_output_bytes	= tmp_hwif->atapi_output_bytes;
 
+	hwif->dma_host_set		= tmp_hwif->dma_host_set;
 	hwif->dma_setup			= tmp_hwif->dma_setup;
 	hwif->dma_exec_cmd		= tmp_hwif->dma_exec_cmd;
 	hwif->dma_start			= tmp_hwif->dma_start;
 	hwif->ide_dma_end		= tmp_hwif->ide_dma_end;
 	hwif->ide_dma_test_irq		= tmp_hwif->ide_dma_test_irq;
 	hwif->ide_dma_clear_irq		= tmp_hwif->ide_dma_clear_irq;
-	hwif->dma_host_on		= tmp_hwif->dma_host_on;
-	hwif->dma_host_off		= tmp_hwif->dma_host_off;
 	hwif->dma_lost_irq		= tmp_hwif->dma_lost_irq;
 	hwif->dma_timeout		= tmp_hwif->dma_timeout;
 
@@ -834,7 +833,7 @@ int set_using_dma(ide_drive_t *drive, int arg)
 	if (!drive->id || !(drive->id->capability & 1))
 		goto out;
 
-	if (hwif->dma_host_on == NULL)
+	if (hwif->dma_host_set == NULL)
 		goto out;
 
 	err = -EBUSY;

commit 4a546e046d562bcd389149591fa5a534c8f832ca
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Jan 26 20:13:01 2008 +0100

    ide: remove ->ide_dma_on and ->dma_off_quietly methods from ide_hwif_t
    
    * Make ide_dma_off_quietly() and __ide_dma_on() always available.
    
    * Drop "__" prefix from __ide_dma_on().
    
    * Check for presence of ->dma_host_on instead of ->ide_dma_on.
    
    * Convert all users of ->ide_dma_on and ->dma_off_quietly methods
      to use ide_dma_on() and ide_dma_off_quietly() instead.
    
    * Remove no longer needed ->ide_dma_on and ->dma_off_quietly methods
      from ide_hwif_t.
    
    * Make ide_dma_on() void.
    
    There should be no functionality changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index c6d4f630e18a..095ff34870da 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -437,8 +437,6 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 	hwif->dma_exec_cmd		= tmp_hwif->dma_exec_cmd;
 	hwif->dma_start			= tmp_hwif->dma_start;
 	hwif->ide_dma_end		= tmp_hwif->ide_dma_end;
-	hwif->ide_dma_on		= tmp_hwif->ide_dma_on;
-	hwif->dma_off_quietly		= tmp_hwif->dma_off_quietly;
 	hwif->ide_dma_test_irq		= tmp_hwif->ide_dma_test_irq;
 	hwif->ide_dma_clear_irq		= tmp_hwif->ide_dma_clear_irq;
 	hwif->dma_host_on		= tmp_hwif->dma_host_on;
@@ -836,7 +834,7 @@ int set_using_dma(ide_drive_t *drive, int arg)
 	if (!drive->id || !(drive->id->capability & 1))
 		goto out;
 
-	if (hwif->ide_dma_on == NULL)
+	if (hwif->dma_host_on == NULL)
 		goto out;
 
 	err = -EBUSY;

commit 7b905994ce0bd332afc5ebc30ce9afa60d23c6e2
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jan 25 22:17:19 2008 +0100

    ide: cleanup ide_set_dma()
    
    * ->dma_off_quietly is always called before ide_set_dma()
      so the call can be moved inside ide_set_dma().
    
    * ide_dma_check() doesn't touch hardware so ->dma_off_quietly
      call for 'rc == -1' case is redundant, remove it.
    
    * '0' and '-1' are the only values returned by ide_dma_check()
      so remove dead code for other cases.
    
    There should be no functionality changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 00ef6ec2c273..c6d4f630e18a 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -851,7 +851,6 @@ int set_using_dma(ide_drive_t *drive, int arg)
 	err = 0;
 
 	if (arg) {
-		hwif->dma_off_quietly(drive);
 		if (ide_set_dma(drive))
 			err = -EIO;
 	} else

commit 23b1bd459c9e8a925381960f0b69ac85468c3af1
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jan 25 22:17:19 2008 +0100

    ide: remove redundant ->ide_dma_on call from set_using_dma()
    
    ide_set_dma() calls ->ide_dma_on method itself and returns zero
    only if ->ide_dma_on call succeeded.
    
    There should be no functionality changes caused by this patch.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 4acd87e92cca..00ef6ec2c273 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -852,7 +852,7 @@ int set_using_dma(ide_drive_t *drive, int arg)
 
 	if (arg) {
 		hwif->dma_off_quietly(drive);
-		if (ide_set_dma(drive) || hwif->ide_dma_on(drive))
+		if (ide_set_dma(drive))
 			err = -EIO;
 	} else
 		ide_dma_off(drive);

commit 7299a3918442dc9a5abb71b9f65b1dd17637c8c0
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jan 25 22:17:14 2008 +0100

    ide: remove hwif->intrproc
    
    Given that:
    
    * hpt366.c::hpt3xx_intrproc() is the only user of hwif->intrproc
    
    * hpt366.c::hpt3xx_quirkproc() sets drive->quirk_list to 1 for quirky drives
      which is a value unique to hpt366 host driver
    
    we can remove hwif->intproc and just check for drive->quirk_list == 1
    in ide_do_request().
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 9ab5458fe950..4acd87e92cca 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -424,7 +424,6 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 	hwif->reset_poll		= tmp_hwif->reset_poll;
 	hwif->pre_reset			= tmp_hwif->pre_reset;
 	hwif->resetproc			= tmp_hwif->resetproc;
-	hwif->intrproc			= tmp_hwif->intrproc;
 	hwif->maskproc			= tmp_hwif->maskproc;
 	hwif->quirkproc			= tmp_hwif->quirkproc;
 	hwif->busproc			= tmp_hwif->busproc;

commit 1c029fd658baa2442e8e51dc9c819301cad95777
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jan 25 22:17:05 2008 +0100

    ide: remove ->dma_master field from ide_hwif_t (take 5)
    
    * Convert cmd64x, hpt366 and pdc202xx_old host drivers to use
      pci_resource_start(hwif->pci_dev, 4) instead of hwif->dma_master.
    
    * Remove no longer needed ->dma_master field from ide_hwif_t.
    
    v2:
    * Use the more readable 'hwif->dma_base - (hwif->channel * 8)' instead of
      pci_resource_start(hwif->pci_dev, 4).
    
    v3:
    * Use hwif->extra_base in hpt366/pdc20xx_old + some cosmetic fixups over v2
      (suggested by Sergei).
    
    v4:
    * Correct offsets in hpt3xxn_set_clock().
    
    v5:
    * Use hwif->extra_base in hpt366 for _real_ this time. (Noticed by Sergei)
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 54943da6e4e5..9ab5458fe950 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -468,7 +468,6 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 #endif
 
 	hwif->dma_base			= tmp_hwif->dma_base;
-	hwif->dma_master		= tmp_hwif->dma_master;
 	hwif->dma_command		= tmp_hwif->dma_command;
 	hwif->dma_vendor1		= tmp_hwif->dma_vendor1;
 	hwif->dma_status		= tmp_hwif->dma_status;
@@ -602,7 +601,6 @@ void ide_unregister(unsigned int index)
 		(void) ide_release_dma(hwif);
 
 		hwif->dma_base = 0;
-		hwif->dma_master = 0;
 		hwif->dma_command = 0;
 		hwif->dma_vendor1 = 0;
 		hwif->dma_status = 0;

commit 644a9d764b4747af057b3db73ccba28a168b1f4f
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Dec 12 23:32:00 2007 +0100

    ide: fix ->io_32bit race in set_io_32bit()
    
    set_io_32bit() (ide_procset_t function) can race against running
    PIO transfers.  Fix it by using ide_spin_wait_hwgroup().
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 85740ae5d689..54943da6e4e5 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -800,11 +800,17 @@ int set_io_32bit(ide_drive_t *drive, int arg)
 	if (arg < 0 || arg > 1 + (SUPPORT_VLB_SYNC << 1))
 		return -EINVAL;
 
+	if (ide_spin_wait_hwgroup(drive))
+		return -EBUSY;
+
 	drive->io_32bit = arg;
 #ifdef CONFIG_BLK_DEV_DTC2278
 	if (HWIF(drive)->chipset == ide_dtc2278)
 		HWIF(drive)->drives[!drive->select.b.unit].io_32bit = arg;
 #endif /* CONFIG_BLK_DEV_DTC2278 */
+
+	spin_unlock_irq(&ide_lock);
+
 	return 0;
 }
 

commit e11b9035a47da66fcd4bafd3a5f6b14f51ca667e
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed Dec 12 23:31:58 2007 +0100

    ide: add /sys/bus/ide/devices/*/{model,firmware,serial} sysfs entries
    
    Cc: Dan Kegel <dank@kegel.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Xavier Bestel <xavier.bestel@free.fr>
    Cc: Andrey Borzenkov <arvidjaar@mail.ru>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 674a65c1a130..85740ae5d689 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1670,10 +1670,34 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *attr,
 	return sprintf(buf, "ide:m-%s\n", media_string(drive));
 }
 
+static ssize_t model_show(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	ide_drive_t *drive = to_ide_device(dev);
+	return sprintf(buf, "%s\n", drive->id->model);
+}
+
+static ssize_t firmware_show(struct device *dev, struct device_attribute *attr,
+			     char *buf)
+{
+	ide_drive_t *drive = to_ide_device(dev);
+	return sprintf(buf, "%s\n", drive->id->fw_rev);
+}
+
+static ssize_t serial_show(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	ide_drive_t *drive = to_ide_device(dev);
+	return sprintf(buf, "%s\n", drive->id->serial_no);
+}
+
 static struct device_attribute ide_dev_attrs[] = {
 	__ATTR_RO(media),
 	__ATTR_RO(drivename),
 	__ATTR_RO(modalias),
+	__ATTR_RO(model),
+	__ATTR_RO(firmware),
+	__ATTR(serial, 0400, serial_show, NULL),
 	__ATTR_NULL
 };
 

commit 9239b333939dd1e5b1a9f033a1c136273d58efe8
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Oct 20 00:32:33 2007 +0200

    ide: remove write-only hwif->hw
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index b7e872e29f9c..674a65c1a130 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -168,7 +168,6 @@ static void init_hwif_default(ide_hwif_t *hwif, unsigned int index)
 
 	ide_init_hwif_ports(&hw, ide_default_io_base(index), 0, &hwif->irq);
 
-	memcpy(&hwif->hw, &hw, sizeof(hw));
 	memcpy(hwif->io_ports, hw.io_ports, sizeof(hw.io_ports));
 
 	hwif->noprobe = !hwif->io_ports[IDE_DATA_OFFSET];
@@ -214,7 +213,7 @@ static void __init init_ide_data (void)
 		init_hwif_data(hwif, index);
 		init_hwif_default(hwif, index);
 #if !defined(CONFIG_PPC32) || !defined(CONFIG_PCI)
-		hwif->irq = hwif->hw.irq =
+		hwif->irq =
 			ide_init_default_irq(hwif->io_ports[IDE_DATA_OFFSET]);
 #endif
 	}
@@ -730,8 +729,7 @@ int ide_register_hw(hw_regs_t *hw, void (*fixup)(ide_hwif_t *),
 	}
 	if (hwif->present)
 		return -1;
-	memcpy(&hwif->hw, hw, sizeof(*hw));
-	memcpy(hwif->io_ports, hwif->hw.io_ports, sizeof(hwif->hw.io_ports));
+	memcpy(hwif->io_ports, hw->io_ports, sizeof(hwif->io_ports));
 	hwif->irq = hw->irq;
 	hwif->noprobe = 0;
 	hwif->fixup = fixup;
@@ -1417,6 +1415,9 @@ static int __init ide_setup(char *s)
 			"reset", "minus6", "ata66", "minus8", "minus9",
 			"minus10", "four", "qd65xx", "ht6560b", "cmd640_vlb",
 			"dtc2278", "umc8672", "ali14xx", NULL };
+
+		hw_regs_t hwregs;
+
 		hw = s[3] - '0';
 		hwif = &ide_hwifs[hw];
 		i = match_parm(&s[4], ide_words, vals, 3);
@@ -1526,9 +1527,9 @@ static int __init ide_setup(char *s)
 			case 2: /* base,ctl */
 				vals[2] = 0;	/* default irq = probe for it */
 			case 3: /* base,ctl,irq */
-				hwif->hw.irq = vals[2];
-				ide_init_hwif_ports(&hwif->hw, (unsigned long) vals[0], (unsigned long) vals[1], &hwif->irq);
-				memcpy(hwif->io_ports, hwif->hw.io_ports, sizeof(hwif->io_ports));
+				memset(&hwregs, 0, sizeof(hwregs));
+				ide_init_hwif_ports(&hwregs, vals[0], vals[1], &hwif->irq);
+				memcpy(hwif->io_ports, hwregs.io_ports, sizeof(hwif->io_ports));
 				hwif->irq      = vals[2];
 				hwif->noprobe  = 0;
 				hwif->chipset  = ide_forced;

commit 18e181fe13b7340194d09e6dd7f571a5f96f0367
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Oct 20 00:32:32 2007 +0200

    ide: add hwif->ack_intr hook
    
    * Add hwif->ack_intr hook and use it instead of hwif->hw.ack_intr.
    
    * Add missing brackets to cris-v32 and powerpc ide_ack_intr() macros.
    
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 4a668d51965d..b7e872e29f9c 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -737,6 +737,7 @@ int ide_register_hw(hw_regs_t *hw, void (*fixup)(ide_hwif_t *),
 	hwif->fixup = fixup;
 	hwif->chipset = hw->chipset;
 	hwif->gendev.parent = hw->dev;
+	hwif->ack_intr = hw->ack_intr;
 
 	if (initializing == 0) {
 		u8 idx[4] = { index, 0xff, 0xff, 0xff };

commit 86f3a492bb09eee5745b93af35f2212179c251fd
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Oct 20 00:32:32 2007 +0200

    icside: use ec->dma directly
    
    * hwif->hwif_data contains pointer to struct expansion_card so use ec->dma
      directly instead of caching it in hwif->hw.dma.
    
    * Remove no longer needed hw_regs_t.dma and NO_DMA define.
    
    Cc: Russell King <rmk@arm.linux.org.uk>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 9284f64bc2ee..4a668d51965d 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -678,7 +678,6 @@ void ide_setup_ports (	hw_regs_t *hw,
 		}
 	}
 	hw->irq = irq;
-	hw->dma = NO_DMA;
 	hw->ack_intr = ack_intr;
 /*
  *	hw->iops = iops;

commit 8f173b5bf460a85791c131e774dc992f8cd578c1
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Oct 20 00:32:32 2007 +0200

    ide: fix ide_register_hw() to check hwif->io_ports[]
    
    hwif->hw.io_ports[] and hwif->io_ports[] should be the same but "4drives"
    support and scc_pata host driver set only hwif->io_ports[].
    
    To compensate for this check hwif->io_ports[] instead of hwif->hw.io_ports[]
    in ide_register_hw() (instead of fixing "4drives" and scc_pata because hwif->hw
    is to be removed).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index ce6644f41b21..9284f64bc2ee 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -707,7 +707,7 @@ int ide_register_hw(hw_regs_t *hw, void (*fixup)(ide_hwif_t *),
 	do {
 		for (index = 0; index < MAX_HWIFS; ++index) {
 			hwif = &ide_hwifs[index];
-			if (hwif->hw.io_ports[IDE_DATA_OFFSET] == hw->io_ports[IDE_DATA_OFFSET])
+			if (hwif->io_ports[IDE_DATA_OFFSET] == hw->io_ports[IDE_DATA_OFFSET])
 				goto found;
 		}
 		for (index = 0; index < MAX_HWIFS; ++index) {
@@ -715,7 +715,7 @@ int ide_register_hw(hw_regs_t *hw, void (*fixup)(ide_hwif_t *),
 			if (hwif->hold)
 				continue;
 			if ((!hwif->present && !hwif->mate && !initializing) ||
-			    (!hwif->hw.io_ports[IDE_DATA_OFFSET] && initializing))
+			    (!hwif->io_ports[IDE_DATA_OFFSET] && initializing))
 				goto found;
 		}
 		for (index = 0; index < MAX_HWIFS; index++)

commit baa8f3e94bc7a7ba3650d80b67d54c3e08365dee
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Oct 20 00:32:31 2007 +0200

    ide: add ide_find_port() helper
    
    * Add ide_find_port() helper.
    
    * Convert icside, rapide and ide_platform host drivers to use it.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 15741367eb35..ce6644f41b21 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -265,6 +265,30 @@ static int ide_system_bus_speed(void)
 	return system_bus_speed;
 }
 
+ide_hwif_t * ide_find_port(unsigned long base)
+{
+	ide_hwif_t *hwif;
+	int i;
+
+	for (i = 0; i < MAX_HWIFS; i++) {
+		hwif = &ide_hwifs[i];
+		if (hwif->io_ports[IDE_DATA_OFFSET] == base)
+			goto found;
+	}
+
+	for (i = 0; i < MAX_HWIFS; i++) {
+		hwif = &ide_hwifs[i];
+		if (hwif->io_ports[IDE_DATA_OFFSET] == 0)
+			goto found;
+	}
+
+	hwif = NULL;
+found:
+	return hwif;
+}
+
+EXPORT_SYMBOL_GPL(ide_find_port);
+
 static struct resource* hwif_request_region(ide_hwif_t *hwif,
 					    unsigned long addr, int num)
 {

commit 8447d9d52adbe4c653482bd0d5ccb9b5d26f9c9d
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Oct 20 00:32:31 2007 +0200

    ide: add ide_device_add()
    
    * Add ide_device_add() helper and convert host drivers to use it
      instead of open-coded variants.
    
    * Make ide_pci_setup_ports() and do_ide_setup_pci_device()
      take 'u8 *idx' argument instead of 'ata_index_t *index'.
    
    * Remove no longer needed ata_index_t.
    
    * Unexport probe_hwif_init() and make it static.
    
    * Unexport ide_proc_register_port().
    
    There should be no functionality changes caused by this patch
    (sgiioc4.c: ide_proc_register_port() requires hwif->present
     to be set and it won't be set if probe_hwif_init() fails).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 35f24b9b8219..15741367eb35 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -715,9 +715,10 @@ int ide_register_hw(hw_regs_t *hw, void (*fixup)(ide_hwif_t *),
 	hwif->chipset = hw->chipset;
 	hwif->gendev.parent = hw->dev;
 
-	if (!initializing) {
-		probe_hwif_init(hwif);
-		ide_proc_register_port(hwif);
+	if (initializing == 0) {
+		u8 idx[4] = { index, 0xff, 0xff, 0xff };
+
+		ide_device_add(idx);
 	}
 
 	if (hwifp)

commit fd9bb53942a7ca3398a63f2c238afd8fbed3ec0e
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Oct 20 00:32:31 2007 +0200

    ide: add ->fixup method to ide_hwif_t
    
    * Add ->fixup method to ide_hwif_t.
    
    * Set hwif->fixup in ide_pci_setup_ports() to d->fixup.
    
    * Use hwif->fixup in probe_hwif().
    
    * Use probe_hwif_init() instead of probe_hwif_init_with_fixup() in
      ide_setup_pci_device().
    
    * Add 'fixup' argument to ide_register_hw() and use it to set hwif->fixup,
      update all ide_register_hw() users accordingly.
    
    * Convert ide-cs/delkin_cb host drivers to use ide_register_hw().
    
    * Restore hwif->fixup in ide_hwif_restore().
    
    * Remove ide_register_hw_with_fixup(), probe_hwif_init_with_fixup()
      and 'fixup' argument from probe_hwif().
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 961e6c897286..35f24b9b8219 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -391,6 +391,8 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 	hwif->cds			= tmp_hwif->cds;
 #endif
 
+	hwif->fixup			= tmp_hwif->fixup;
+
 	hwif->set_pio_mode		= tmp_hwif->set_pio_mode;
 	hwif->set_dma_mode		= tmp_hwif->set_dma_mode;
 	hwif->mdma_filter		= tmp_hwif->mdma_filter;
@@ -660,11 +662,11 @@ void ide_setup_ports (	hw_regs_t *hw,
 }
 
 /**
- *	ide_register_hw_with_fixup	-	register IDE interface
+ *	ide_register_hw		-	register IDE interface
  *	@hw: hardware registers
+ *	@fixup: fixup function
  *	@initializing: set while initializing built-in drivers
  *	@hwifp: pointer to returned hwif
- *	@fixup: fixup function
  *
  *	Register an IDE interface, specifying exactly the registers etc.
  *	Set init=1 iff calling before probes have taken place.
@@ -672,9 +674,8 @@ void ide_setup_ports (	hw_regs_t *hw,
  *	Returns -1 on error.
  */
 
-int ide_register_hw_with_fixup(hw_regs_t *hw, int initializing,
-			       ide_hwif_t **hwifp,
-			       void(*fixup)(ide_hwif_t *hwif))
+int ide_register_hw(hw_regs_t *hw, void (*fixup)(ide_hwif_t *),
+		    int initializing, ide_hwif_t **hwifp)
 {
 	int index, retry = 1;
 	ide_hwif_t *hwif;
@@ -710,11 +711,12 @@ int ide_register_hw_with_fixup(hw_regs_t *hw, int initializing,
 	memcpy(hwif->io_ports, hwif->hw.io_ports, sizeof(hwif->hw.io_ports));
 	hwif->irq = hw->irq;
 	hwif->noprobe = 0;
+	hwif->fixup = fixup;
 	hwif->chipset = hw->chipset;
 	hwif->gendev.parent = hw->dev;
 
 	if (!initializing) {
-		probe_hwif_init_with_fixup(hwif, fixup);
+		probe_hwif_init(hwif);
 		ide_proc_register_port(hwif);
 	}
 
@@ -724,13 +726,6 @@ int ide_register_hw_with_fixup(hw_regs_t *hw, int initializing,
 	return (initializing || hwif->present) ? index : -1;
 }
 
-EXPORT_SYMBOL(ide_register_hw_with_fixup);
-
-int ide_register_hw(hw_regs_t *hw, int initializing, ide_hwif_t **hwifp)
-{
-	return ide_register_hw_with_fixup(hw, initializing, hwifp, NULL);
-}
-
 EXPORT_SYMBOL(ide_register_hw);
 
 /*
@@ -1046,7 +1041,7 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 			ide_init_hwif_ports(&hw, (unsigned long) args[0],
 					    (unsigned long) args[1], NULL);
 			hw.irq = args[2];
-			if (ide_register_hw(&hw, 0, NULL) == -1)
+			if (ide_register_hw(&hw, NULL, 0, NULL) == -1)
 				return -EIO;
 			return 0;
 		}

commit 238e4f142c33bb34440cc64029dde7b9fbc4e65f
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 19 00:30:07 2007 +0200

    ide: add IDE_HFLAG_NO_LBA48 and IDE_HFLAG_NO_LBA48_DMA host flags
    
    Add IDE_HFLAG_NO_LBA48[_DMA] host flags, use it instead of hwif->no_lba48[_dma]
    and then remove no longer needed hwif->no_lba48[_dma].  As a side-effect
    this change fixes hwif->no_lba48_dma not being restored by ide_hwif_restore().
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index f78943f86314..961e6c897286 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -437,7 +437,6 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 
 	hwif->mmio			= tmp_hwif->mmio;
 	hwif->rqsize			= tmp_hwif->rqsize;
-	hwif->no_lba48			= tmp_hwif->no_lba48;
 
 #ifndef CONFIG_BLK_DEV_IDECS
 	hwif->irq			= tmp_hwif->irq;

commit 33c1002ed912ac9dacedd5d5b166da3b72d18460
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 19 00:30:06 2007 +0200

    ide: add IDE_HFLAG_NO_ATAPI_DMA host flag
    
    Add IDE_HFLAG_NO_ATAPI_DMA host flag and set it in host drivers which
    don't support ATAPI DMA.  Then remove no longer needed hwif->atapi_dma.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 5b090662683e..f78943f86314 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -134,8 +134,6 @@ static void init_hwif_data(ide_hwif_t *hwif, unsigned int index)
 
 	hwif->bus_state	= BUSSTATE_ON;
 
-	hwif->atapi_dma = 0;		/* disable all atapi dma */ 
-
 	init_completion(&hwif->gendev_rel_comp);
 
 	default_hwif_iops(hwif);
@@ -379,7 +377,6 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 
 	hwif->pio_mask			= tmp_hwif->pio_mask;
 
-	hwif->atapi_dma			= tmp_hwif->atapi_dma;
 	hwif->ultra_mask		= tmp_hwif->ultra_mask;
 	hwif->mwdma_mask		= tmp_hwif->mwdma_mask;
 	hwif->swdma_mask		= tmp_hwif->swdma_mask;

commit c223701cf6c706f42840631c1ca919a18e6e2800
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Oct 16 22:29:58 2007 +0200

    ide: add "hdx=nodma" kernel parameter
    
    * Add "hdx=nodma" option allowing user to disallow DMA for a given device.
    
    * Obsolete "ide=nodma" option.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 27c4fe250701..5b090662683e 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1272,7 +1272,7 @@ static int __init ide_setup(char *s)
 	if (!strcmp(s, "ide=nodma")) {
 		printk(" : Prevented DMA\n");
 		noautodma = 1;
-		return 1;
+		goto obsolete_option;
 	}
 
 #ifdef CONFIG_IDEPCI_PCIBUS_ORDER
@@ -1306,7 +1306,7 @@ static int __init ide_setup(char *s)
 	 */
 	if (s[0] == 'h' && s[1] == 'd' && s[2] >= 'a' && s[2] <= max_drive) {
 		const char *hd_words[] = {
-			"none", "noprobe", "nowerr", "cdrom", "minus5",
+			"none", "noprobe", "nowerr", "cdrom", "nodma",
 			"autotune", "noautotune", "minus8", "swapdata", "bswap",
 			"noflush", "remap", "remap63", "scsi", NULL };
 		unit = s[2] - 'a';
@@ -1334,6 +1334,9 @@ static int __init ide_setup(char *s)
 				drive->ready_stat = 0;
 				hwif->noprobe = 0;
 				goto done;
+			case -5: /* nodma */
+				drive->nodma = 1;
+				goto done;
 			case -6: /* "autotune" */
 				drive->autotune = IDE_TUNE_AUTO;
 				goto obsolete_option;

commit 9ff6f72f432364991d68e99cae72cb141c166e70
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Oct 16 22:29:58 2007 +0200

    ide: remove hwif->autodma and drive->autodma
    
    * hpt34x.c: disable DMA masks for HPT345
      (hwif->autodma is zero so DMA won't be enabled anyway).
    
    * trm290.c: disable IDE_HFLAG_TRUST_BIOS_FOR_DMA flag
      (hwif->autodma is zero so DMA won't be enabled anyway).
    
    * Check noautodma global variable instead of drive->autodma in ide_tune_dma().
    
      This fixes handling of "ide=nodma" kernel parameter for icside, ide-cris,
      au1xxx-ide, pmac, it821x, jmicron, sgiioc4 and siimage host drivers.
    
    * Remove hwif->autodma (it was not checked by IDE core code anyway) and
      drive->autodma (was set by all host drivers - except HPT345/TRM290 special
      cases - unless "ide=nodma" was used).
    
    While at it:
    - remove needless printk() from icside.c
    - remove stale FIXME/comment from ide-probe.c
    - don't force DMA off if PCI bus-mastering had to be enabled in setup-pci.c
      (this setting was always later over-ridden by host drivers anyway)
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 02336595144a..27c4fe250701 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -458,7 +458,6 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 	hwif->select_data		= tmp_hwif->select_data;
 	hwif->extra_base		= tmp_hwif->extra_base;
 	hwif->extra_ports		= tmp_hwif->extra_ports;
-	hwif->autodma			= tmp_hwif->autodma;
 
 	hwif->hwif_data			= tmp_hwif->hwif_data;
 }

commit 1b5169405e50b98b2bd1e4f86c7706ea24a59193
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Oct 16 22:29:57 2007 +0200

    ide: remove "idex=dma" kernel parameter
    
    It has been obsoleted since 1 Nov 2004, is valid only when used together with
    "ide=nodma" kernel parameter (which makes no sense) and only for aec62xx,
    cmd64x, cs5220, generic, hpt366, sl82c105, tc86c001 and triflex host drivers.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 837822ab6cb1..02336595144a 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1396,7 +1396,7 @@ static int __init ide_setup(char *s)
 		 */
 		static const char *ide_words[] = {
 			"noprobe", "serialize", "minus3", "minus4",
-			"reset", "dma", "ata66", "minus8", "minus9",
+			"reset", "minus6", "ata66", "minus8", "minus9",
 			"minus10", "four", "qd65xx", "ht6560b", "cmd640_vlb",
 			"dtc2278", "umc8672", "ali14xx", NULL };
 		hw = s[3] - '0';
@@ -1475,6 +1475,7 @@ static int __init ide_setup(char *s)
 			case -10: /* minus10 */
 			case -9: /* minus9 */
 			case -8: /* minus8 */
+			case -6:
 			case -4:
 			case -3:
 				goto bad_option;
@@ -1489,9 +1490,6 @@ static int __init ide_setup(char *s)
 #else
 				goto bad_hwif;
 #endif
-			case -6: /* dma */
-				hwif->autodma = 1;
-				goto obsolete_option;
 			case -5: /* "reset" */
 				hwif->reset = 1;
 				goto obsolete_option;

commit 3135469e1f679b1728fa047ed43b0c63cdf50c84
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Oct 16 22:29:55 2007 +0200

    ide: unexport noautodma
    
    noautodma can now be unexported.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 4834cca5cb31..837822ab6cb1 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -100,8 +100,6 @@ static int ide_scan_direction; /* THIS was formerly 2.2.x pci=reverse */
 
 int noautodma = 0;
 
-EXPORT_SYMBOL(noautodma);
-
 #ifdef CONFIG_BLK_DEV_IDEACPI
 int ide_noacpi = 0;
 int ide_noacpitfs = 1;

commit 0ae2e178652753ae1797d407755a3505f7c1d2a7
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Oct 16 22:29:55 2007 +0200

    ide: remove ->ide_dma_check (take 2)
    
    * Add IDE_HFLAG_TRUST_BIOS_FOR_DMA host flag for host drivers that depend
      on BIOS for programming device/controller for DMA.  Set it in cy82c693,
      generic, ns87415, opti621 and trm290 host drivers.
    
    * Add IDE_HFLAG_VDMA host flag for host drivers using VDMA.  Set it in cs5520
      host driver.
    
    * Teach ide_tune_dma() about IDE_HFLAG_TRUST_BIOS_FOR_DMA flag.
    
    * Add generic ide_dma_check() helper and remove all open coded ->ide_dma_check
      implementations.  Fix all places checking for presence of ->ide_dma_check
      hook to check for ->ide_dma_on instead.
    
    * Remove no longer needed code from config_drive_for_dma().
    
    * Make ide_tune_dma() static.
    
    v2:
    * Fix config_drive_for_dma() return values.
    
    * Fix ide-dma.c build for CONFIG_BLK_DEV_IDEDMA_PCI=n by adding
      dummy config_drive_for_dma() inline.
    
    * Fix IDE_HFLAG_TRUST_BIOS_FOR_DMA handling in ide_dma_check().
    
    * Fix init_hwif_it8213() comment.
    
    There should be no functionality changes caused by this patch.
    
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 5c0e4078b5cb..4834cca5cb31 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -418,7 +418,6 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 	hwif->dma_exec_cmd		= tmp_hwif->dma_exec_cmd;
 	hwif->dma_start			= tmp_hwif->dma_start;
 	hwif->ide_dma_end		= tmp_hwif->ide_dma_end;
-	hwif->ide_dma_check		= tmp_hwif->ide_dma_check;
 	hwif->ide_dma_on		= tmp_hwif->ide_dma_on;
 	hwif->dma_off_quietly		= tmp_hwif->dma_off_quietly;
 	hwif->ide_dma_test_irq		= tmp_hwif->ide_dma_test_irq;
@@ -823,7 +822,7 @@ int set_using_dma(ide_drive_t *drive, int arg)
 	if (!drive->id || !(drive->id->capability & 1))
 		goto out;
 
-	if (hwif->ide_dma_check == NULL)
+	if (hwif->ide_dma_on == NULL)
 		goto out;
 
 	err = -EBUSY;

commit 88b2b32babd46cd54d2de4d17eb869aea3383e11
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Oct 13 17:47:51 2007 +0200

    ide: move ide_config_drive_speed() calls to upper layers (take 2)
    
    * Convert {ide_hwif_t,ide_pci_device_t}->host_flag to be u16.
    
    * Add IDE_HFLAG_POST_SET_MODE host flag to indicate the need to program
      the host for the transfer mode after programming the device.  Set it
      in au1xxx-ide, amd74xx, cs5530, cs5535, pdc202xx_new, sc1200, pmac
      and via82cxxx host drivers.
    
    * Add IDE_HFLAG_NO_SET_MODE host flag to indicate the need to completely
      skip programming of host/device for the transfer mode ("smart" hosts).
      Set it in it821x host driver and check it in ide_tune_dma().
    
    * Add ide_set_pio_mode()/ide_set_dma_mode() helpers and convert all
      direct ->set_pio_mode/->speedproc users to use these helpers.
    
    * Move ide_config_drive_speed() calls from ->set_pio_mode/->speedproc
      methods to callers.
    
    * Rename ->speedproc method to ->set_dma_mode, make it void and update
      all implementations accordingly.
    
    * Update ide_set_xfer_rate() comments.
    
    * Unexport ide_config_drive_speed().
    
    v2:
    * Fix issues noticed by Sergei:
      - export ide_set_dma_mode() instead of moving ->set_pio_mode abuse wrt
        to setting DMA modes from sc1200_set_pio_mode() to do_special()
      - check IDE_HFLAG_NO_SET_MODE in ide_tune_dma()
      - check for (hwif->set_pio_mode) == NULL in ide_set_pio_mode()
      - check for (hwif->set_dma_mode) == NULL in ide_set_dma_mode()
      - return -1 from ide_set_{pio,dma}_mode() if ->set_{pio,dma}_mode == NULL
      - don't set ->set_{pio,dma}_mode on it821x in "smart" mode
      - fix build problem in pmac.c
      - minor fixes in au1xxx-ide.c/cs5530.c/siimage.c
      - improve patch description
    
    Changes in behavior caused by this patch:
    - HDIO_SET_PIO_MODE ioctl would now return -ENOSYS for attempts to change
      PIO mode if it821x controller is in "smart" mode
    - removal of two debugging printk-s (from cs5530.c and sc1200.c)
    - transfer modes 0x00-0x07 passed from user space may be programmed twice on
      the device (not really an issue since 0x00 is not supported correctly by
      any host driver ATM, 0x01 is not supported at all and 0x02-0x07 are invalid)
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index a96a8b1b3539..5c0e4078b5cb 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -397,7 +397,7 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 #endif
 
 	hwif->set_pio_mode		= tmp_hwif->set_pio_mode;
-	hwif->speedproc			= tmp_hwif->speedproc;
+	hwif->set_dma_mode		= tmp_hwif->set_dma_mode;
 	hwif->mdma_filter		= tmp_hwif->mdma_filter;
 	hwif->udma_filter		= tmp_hwif->udma_filter;
 	hwif->selectproc		= tmp_hwif->selectproc;

commit 7eff2e7a8b65c25920207324e56611150eb1cd9a
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Tue Aug 14 15:15:12 2007 +0200

    Driver core: change add_uevent_var to use a struct
    
    This changes the uevent buffer functions to use a struct instead of a
    long list of parameters. It does no longer require the caller to do the
    proper buffer termination and size accounting, which is currently wrong
    in some places. It fixes a known bug where parts of the uevent
    environment are overwritten because of wrong index calculations.
    
    Many thanks to Mathieu Desnoyers for finding bugs and improving the
    error handling.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Cc: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index e96212ce5729..a96a8b1b3539 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1663,20 +1663,13 @@ static struct device_attribute ide_dev_attrs[] = {
 	__ATTR_NULL
 };
 
-static int ide_uevent(struct device *dev, char **envp, int num_envp,
-		      char *buffer, int buffer_size)
+static int ide_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
 	ide_drive_t *drive = to_ide_device(dev);
-	int i = 0;
-	int length = 0;
-
-	add_uevent_var(envp, num_envp, &i, buffer, buffer_size, &length,
-		       "MEDIA=%s", media_string(drive));
-	add_uevent_var(envp, num_envp, &i, buffer, buffer_size, &length,
-		       "DRIVENAME=%s", drive->name);
-	add_uevent_var(envp, num_envp, &i, buffer, buffer_size, &length,
-		       "MODALIAS=ide:m-%s", media_string(drive));
-	envp[i] = NULL;
+
+	add_uevent_var(env, "MEDIA=%s", media_string(drive));
+	add_uevent_var(env, "DRIVENAME=%s", drive->name);
+	add_uevent_var(env, "MODALIAS=ide:m-%s", media_string(drive));
 	return 0;
 }
 

commit 26bcb879c03254545a19c6700fe5bcef6f21e7b1
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu Oct 11 23:54:00 2007 +0200

    ide: add ide_set{_max}_pio() (take 4)
    
    * Add IDE_HFLAG_ABUSE_{PREFETCH,FAST_DEVSEL,DMA_MODES} flags
      and set them in ht6560, cmd640, cmd64x and sc1200 host drivers.
    
    * Add set_pio_mode_abuse() for checking if host driver has a non-standard
      ->tuneproc() implementation and use it in do_special().
    
    * Add ide_set_pio() for setting PIO mode (it uses hwif->pio_mask to find
      the maximum PIO mode supported by the host), also add ide_set_max_pio()
      wrapper for ide_set_pio() to use for auto-tuning.  Convert users of
      ->tuneproc to use ide_set{_max}_pio() where possible.  This leaves only
      do_special(), set_using_pio(), ide_hwif_restore() and ide_set_pio() as
      a direct users of ->tuneproc.
    
    * Remove no longer needed ide_get_best_pio_mode() calls and printk-s
      reporting PIO mode selected from ->tuneproc implementations.
    
    * Rename ->tuneproc hook to ->set_pio_mode and make 'pio' argument const.
    
    * Remove stale comment from ide_config_drive_speed().
    
    v2:
    * Fix "ata_" prefix (Noticed by Jeff).
    
    v3:
    * Minor cleanups/fixups per Sergei's suggestions.
    
    v4:
    * Fix compile problem in drivers/ide/pci/cmd640.c
      (Noticed by Andrew Morton).
    
    * Improve some ->set_pio_mode comments.
    
    Reviewed-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 9fdc1fe1b299..e96212ce5729 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -396,7 +396,7 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 	hwif->cds			= tmp_hwif->cds;
 #endif
 
-	hwif->tuneproc			= tmp_hwif->tuneproc;
+	hwif->set_pio_mode		= tmp_hwif->set_pio_mode;
 	hwif->speedproc			= tmp_hwif->speedproc;
 	hwif->mdma_filter		= tmp_hwif->mdma_filter;
 	hwif->udma_filter		= tmp_hwif->udma_filter;
@@ -867,8 +867,9 @@ int set_pio_mode(ide_drive_t *drive, int arg)
 	if (arg < 0 || arg > 255)
 		return -EINVAL;
 
-	if (!HWIF(drive)->tuneproc)
+	if (drive->hwif->set_pio_mode == NULL)
 		return -ENOSYS;
+
 	if (drive->special.b.set_tune)
 		return -EBUSY;
 	ide_init_drive_cmd(&rq);

commit 5e32132befa5d2cefadf3141fee0bbb40cd11f0e
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Thu Oct 11 23:53:58 2007 +0200

    ide: hook ACPI _PSx method to IDE power on/off
    
    ACPI spec defines the sequence of IDE power on/off:
    Powering down:
            Call _GTM.
            Power down drive (calls _PS3 method and turns off power planes).
    Powering up:
            Power up drive (calls _PS0 method if present and turns on power planes).
            Call _STM passing info from _GTM (possibly modified), with ID data from
            each drive.
            Initialize the channel.
            May modify the results of _GTF.
            For each drive:
                    Call _GTF.
                    Execute task file (possibly modified).
    This patch adds the missed _PS0/_PS3 methods call.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Acked-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index de54306789a1..9fdc1fe1b299 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -915,6 +915,7 @@ static int generic_ide_suspend(struct device *dev, pm_message_t mesg)
 	struct request rq;
 	struct request_pm_state rqpm;
 	ide_task_t args;
+	int ret;
 
 	/* Call ACPI _GTM only once */
 	if (!(drive->dn % 2))
@@ -931,7 +932,14 @@ static int generic_ide_suspend(struct device *dev, pm_message_t mesg)
 		mesg.event = PM_EVENT_FREEZE;
 	rqpm.pm_state = mesg.event;
 
-	return ide_do_drive_cmd(drive, &rq, ide_wait);
+	ret = ide_do_drive_cmd(drive, &rq, ide_wait);
+	/* only call ACPI _PS3 after both drivers are suspended */
+	if (!ret && (((drive->dn % 2) && hwif->drives[0].present
+		 && hwif->drives[1].present)
+		 || !hwif->drives[0].present
+		 || !hwif->drives[1].present))
+		ide_acpi_set_state(hwif, 0);
+	return ret;
 }
 
 static int generic_ide_resume(struct device *dev)
@@ -944,8 +952,10 @@ static int generic_ide_resume(struct device *dev)
 	int err;
 
 	/* Call ACPI _STM only once */
-	if (!(drive->dn % 2))
+	if (!(drive->dn % 2)) {
+		ide_acpi_set_state(hwif, 1);
 		ide_acpi_push_timing(hwif);
+	}
 
 	ide_acpi_exec_tfs(drive);
 

commit b4e44369a380c1836d0983c2a5011099b7b26eb1
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Thu Oct 11 23:53:58 2007 +0200

    hpt366: MWDMA filter for SATA cards (take 2)
    
    The Marvell bridge chips used on HighPoint SATA cards do not seem to support
    the MWDMA modes (at least that could be seen in their so-called drivers :-),
    so the driver needs to account for this -- to achieve this:
    
    - add mdma_filter() method from the original patch by Bartlomiej Zolnierkiewicz
      with his consent;
    
    - install the method for all chips to only return empty mask if a SATA drive
      is detected on HPT372{AN]/374 chips...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 5e88a060df06..de54306789a1 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -398,6 +398,7 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 
 	hwif->tuneproc			= tmp_hwif->tuneproc;
 	hwif->speedproc			= tmp_hwif->speedproc;
+	hwif->mdma_filter		= tmp_hwif->mdma_filter;
 	hwif->udma_filter		= tmp_hwif->udma_filter;
 	hwif->selectproc		= tmp_hwif->selectproc;
 	hwif->reset_poll		= tmp_hwif->reset_poll;

commit 89636af25d75d8672aea05d258be357d0dc4bd70
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jul 20 01:11:59 2007 +0200

    ide: add support for SCSI ioctls to ide-floppy
    
    Now that ide-floppy supports SG_IO we can add support for SCSI ioctls
    (except deprecated SCSI_IOCTL_SEND_COMMAND and legacy CDROM_SEND_PACKET
    ones - we can add them later iff really needed).
    
    While at it remove handling of CDROMEJECT and CDROMCLOSETRAY ioctls from
    generic_ide_ioctl():
    
    - This prevents ide-{disk,tape,scsi} device drivers from obtaining
      REQ_TYPE_BLOCK_PC type requests which are currently unsupported by
      these drivers and which are potentially harmful (as reported by Andrew).
    
    - There is no functionality loss since aforementioned ioctls will now be
      handled by idefloppy_ioctl()->scsi_cmd_ioctl() (for devices using
      ide-floppy driver) and by idecd_ioctl->cdrom_ioctl()->scsi_cmd_ioctl()
      (for devices using ide-cd driver).
    
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Cc: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index c438cc314238..5e88a060df06 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1097,10 +1097,6 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 			return 0;
 		}
 
-		case CDROMEJECT:
-		case CDROMCLOSETRAY:
-			return scsi_cmd_ioctl(file, bdev->bd_disk->queue, bdev->bd_disk, cmd, p);
-
 		case HDIO_GET_BUSSTATE:
 			if (!capable(CAP_SYS_ADMIN))
 				return -EACCES;

commit 74565073cbf6b3c1746ee623e97b2ba0fcd3fbb6
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jul 20 01:11:59 2007 +0200

    ide: remove stale changelog/comments/TODO from ide.c
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index f3ea5ea41fd4..c438cc314238 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -16,10 +16,6 @@
  *   (usually 14 & 15).
  * There can be up to two drives per interface, as per the ATA-2 spec.
  *
- * Primary:    ide0, port 0x1f0; major=3;  hda is minor=0; hdb is minor=64
- * Secondary:  ide1, port 0x170; major=22; hdc is minor=0; hdd is minor=64
- * Tertiary:   ide2, port 0x???; major=33; hde is minor=0; hdf is minor=64
- * Quaternary: ide3, port 0x???; major=34; hdg is minor=0; hdh is minor=64
  * ...
  *
  *  From hd.c:
@@ -47,80 +43,6 @@
  *  This was a rewrite of just about everything from hd.c, though some original
  *  code is still sprinkled about.  Think of it as a major evolution, with
  *  inspiration from lots of linux users, esp.  hamish@zot.apana.org.au
- *
- *  Version 1.0 ALPHA	initial code, primary i/f working okay
- *  Version 1.3 BETA	dual i/f on shared irq tested & working!
- *  Version 1.4 BETA	added auto probing for irq(s)
- *  Version 1.5 BETA	added ALPHA (untested) support for IDE cd-roms,
- *  ...
- * Version 5.50		allow values as small as 20 for idebus=
- * Version 5.51		force non io_32bit in drive_cmd_intr()
- *			change delay_10ms() to delay_50ms() to fix problems
- * Version 5.52		fix incorrect invalidation of removable devices
- *			add "hdx=slow" command line option
- * Version 5.60		start to modularize the driver; the disk and ATAPI
- *			 drivers can be compiled as loadable modules.
- *			move IDE probe code to ide-probe.c
- *			move IDE disk code to ide-disk.c
- *			add support for generic IDE device subdrivers
- *			add m68k code from Geert Uytterhoeven
- *			probe all interfaces by default
- *			add ioctl to (re)probe an interface
- * Version 6.00		use per device request queues
- *			attempt to optimize shared hwgroup performance
- *			add ioctl to manually adjust bandwidth algorithms
- *			add kerneld support for the probe module
- *			fix bug in ide_error()
- *			fix bug in the first ide_get_lock() call for Atari
- *			don't flush leftover data for ATAPI devices
- * Version 6.01		clear hwgroup->active while the hwgroup sleeps
- *			support HDIO_GETGEO for floppies
- * Version 6.02		fix ide_ack_intr() call
- *			check partition table on floppies
- * Version 6.03		handle bad status bit sequencing in ide_wait_stat()
- * Version 6.10		deleted old entries from this list of updates
- *			replaced triton.c with ide-dma.c generic PCI DMA
- *			added support for BIOS-enabled UltraDMA
- *			rename all "promise" things to "pdc4030"
- *			fix EZ-DRIVE handling on small disks
- * Version 6.11		fix probe error in ide_scan_devices()
- *			fix ancient "jiffies" polling bugs
- *			mask all hwgroup interrupts on each irq entry
- * Version 6.12		integrate ioctl and proc interfaces
- *			fix parsing of "idex=" command line parameter
- * Version 6.13		add support for ide4/ide5 courtesy rjones@orchestream.com
- * Version 6.14		fixed IRQ sharing among PCI devices
- * Version 6.15		added SMP awareness to IDE drivers
- * Version 6.16		fixed various bugs; even more SMP friendly
- * Version 6.17		fix for newest EZ-Drive problem
- * Version 6.18		default unpartitioned-disk translation now "BIOS LBA"
- * Version 6.19		Re-design for a UNIFORM driver for all platforms,
- *			  model based on suggestions from Russell King and
- *			  Geert Uytterhoeven
- *			Promise DC4030VL now supported.
- *			add support for ide6/ide7
- *			delay_50ms() changed to ide_delay_50ms() and exported.
- * Version 6.20		Added/Fixed Generic ATA-66 support and hwif detection.
- *			Added hdx=flash to allow for second flash disk
- *			  detection w/o the hang loop.
- *			Added support for ide8/ide9
- *			Added idex=ata66 for the quirky chipsets that are
- *			  ATA-66 compliant, but have yet to determine a method
- *			  of verification of the 80c cable presence.
- *			  Specifically Promise's PDC20262 chipset.
- * Version 6.21		Fixing/Fixed SMP spinlock issue with insight from an old
- *			  hat that clarified original low level driver design.
- * Version 6.30		Added SMP support; fixed multmode issues.  -ml
- * Version 6.31		Debug Share INTR's and request queue streaming
- *			Native ATA-100 support
- *			Prep for Cascades Project
- * Version 7.00alpha	First named revision of ide rearrange
- *
- *  Some additional driver compile-time options are in ./include/linux/ide.h
- *
- *  To do, in likely order of completion:
- *	- modify kernel to obtain BIOS geometry for drives on 2nd/3rd/4th i/f
- *
  */
 
 #define	REVISION	"Revision: 7.00alpha2"

commit 4099d14322149c7a467e4997b87be4ba8eb78697
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jul 20 01:11:59 2007 +0200

    ide: add PIO masks
    
    * Add ATA_PIO[0-6] defines to <linux/ata.h>.
    
    * Add ->pio_mask field to ide_pci_device_t and ide_hwif_t.
    
    * Add PIO masks to host drivers.
    
    <linux/ata.h> change ACK-ed by Jeff Garzik <jeff@garzik.org>.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index b442b341d52e..f3ea5ea41fd4 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -457,6 +457,8 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 
 	hwif->host_flags		= tmp_hwif->host_flags;
 
+	hwif->pio_mask			= tmp_hwif->pio_mask;
+
 	hwif->atapi_dma			= tmp_hwif->atapi_dma;
 	hwif->ultra_mask		= tmp_hwif->ultra_mask;
 	hwif->mwdma_mask		= tmp_hwif->mwdma_mask;

commit 6a824c92db4d606c324272c4eed366fb71672440
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jul 20 01:11:58 2007 +0200

    ide: remove ide_find_best_pio_mode()
    
    * Add ->host_flags to ide_hwif_t to store ide_pci_device_t.host_flags,
      assign it in setup-pci.c:ide_pci_setup_ports().
    
    * Add IDE_HFLAG_PIO_NO_{BLACKLIST,DOWNGRADE} to ide_pci_device_t.host_flags
      and teach ide_get_best_pio_mode() about them.  Also remove needless
      !drive->id check while at it (drive->id is always present).
    
    * Convert amd74xx, via82cxxx and ide-timing.h to use ide_get_best_pio_mode()
      and then remove no longer needed ide_find_best_pio_mode().
    
    There should be no functionality changes caused by this patch.
    
    Acked-by: Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 077fb674a96d..b442b341d52e 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -455,6 +455,8 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 	hwif->straight8			= tmp_hwif->straight8;
 	hwif->bus_state			= tmp_hwif->bus_state;
 
+	hwif->host_flags		= tmp_hwif->host_flags;
+
 	hwif->atapi_dma			= tmp_hwif->atapi_dma;
 	hwif->ultra_mask		= tmp_hwif->ultra_mask;
 	hwif->mwdma_mask		= tmp_hwif->mwdma_mask;

commit 1985026d32e69ed6dac3ba0ef8ff10366f060ed3
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Tue Jul 17 15:57:42 2007 -0700

    Revert drivers/ide/ide.c scsi_cmd_ioctl() usage changes
    
    The old IDE driver is not ready to take generic SCSI commands, even if
    it uses them for some specific issues (ie the tray open/close ioctls for
    IDE CD-ROM's). Pointed out by Bartlomiej.
    
    I'm sure we'll have it fixed properly soon enough, but for now we should
    not allow it to cause problems.
    
    Cc: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 8cd7694593c9..077fb674a96d 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1049,13 +1049,9 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 	unsigned long flags;
 	ide_driver_t *drv;
 	void __user *p = (void __user *)arg;
-	int err, (*setfunc)(ide_drive_t *, int);
+	int err = 0, (*setfunc)(ide_drive_t *, int);
 	u8 *val;
 
-	err = scsi_cmd_ioctl(file, bdev->bd_disk->queue, bdev->bd_disk, cmd, p);
-	if (err != -ENOTTY)
-		return err;
-
 	switch (cmd) {
 	case HDIO_GET_32BIT:	    val = &drive->io_32bit;	 goto read_val;
 	case HDIO_GET_KEEPSETTINGS: val = &drive->keep_settings; goto read_val;
@@ -1175,6 +1171,10 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 			return 0;
 		}
 
+		case CDROMEJECT:
+		case CDROMCLOSETRAY:
+			return scsi_cmd_ioctl(file, bdev->bd_disk->queue, bdev->bd_disk, cmd, p);
+
 		case HDIO_GET_BUSSTATE:
 			if (!capable(CAP_SYS_ADMIN))
 				return -EACCES;

commit 45e79a3acdcf54113b3d7b23e9e64e6541dbfeb5
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Mon Jul 9 12:39:20 2007 +0200

    bsg: add a request_queue argument to scsi_cmd_ioctl()
    
    bsg uses scsi_cmd_ioctl() for some SCSI/sg ioctl
    commands. scsi_cmd_ioctl() gets a request queue from a gendisk
    arguement. This prevents bsg being bound to SCSI devices that don't
    have a gendisk (like OSD). This adds a request_queue argument to
    scsi_cmd_ioctl(). The SCSI/sg ioctl commands doesn't use a gendisk so
    it's safe for any SCSI devices to use scsi_cmd_ioctl().
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 9ae60a7400a2..8cd7694593c9 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1052,7 +1052,7 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 	int err, (*setfunc)(ide_drive_t *, int);
 	u8 *val;
 
-	err = scsi_cmd_ioctl(file, bdev->bd_disk, cmd, p);
+	err = scsi_cmd_ioctl(file, bdev->bd_disk->queue, bdev->bd_disk, cmd, p);
 	if (err != -ENOTTY)
 		return err;
 

commit 3d6392cfbd7dc11f23058e3493683afab4ac13a3
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Mon Jul 9 12:38:05 2007 +0200

    bsg: support for full generic block layer SG v3
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index c948a5c17a5d..9ae60a7400a2 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1049,9 +1049,13 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 	unsigned long flags;
 	ide_driver_t *drv;
 	void __user *p = (void __user *)arg;
-	int err = 0, (*setfunc)(ide_drive_t *, int);
+	int err, (*setfunc)(ide_drive_t *, int);
 	u8 *val;
 
+	err = scsi_cmd_ioctl(file, bdev->bd_disk, cmd, p);
+	if (err != -ENOTTY)
+		return err;
+
 	switch (cmd) {
 	case HDIO_GET_32BIT:	    val = &drive->io_32bit;	 goto read_val;
 	case HDIO_GET_KEEPSETTINGS: val = &drive->keep_settings; goto read_val;
@@ -1171,10 +1175,6 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 			return 0;
 		}
 
-		case CDROMEJECT:
-		case CDROMCLOSETRAY:
-			return scsi_cmd_ioctl(file, bdev->bd_disk, cmd, p);
-
 		case HDIO_GET_BUSSTATE:
 			if (!capable(CAP_SYS_ADMIN))
 				return -EACCES;

commit 49521f97ccd3c2bf6e71a91cea8fe65d170fa4fb
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Jul 9 23:17:58 2007 +0200

    ide: add short cables support
    
    This patch allows users to override both host and device side cable detection
    with "ideX=ata66" kernel parameter.  Thanks to this it should be now possible
    to use UDMA > 2 modes on systems (laptops mainly) which use short 40-pin cable
    instead of 80-pin one.
    
    Next patches add automatic detection of some systems using short cables.
    
    Changes:
    
    * Rename hwif->udma_four to hwif->cbl and make it u8.
    
    * Convert all existing users accordingly (use ATA_CBL_* defines while at it).
    
    * Add ATA_CBL_PATA40_SHORT support to ide-iops.c:eighty_ninty_three().
    
    * Use ATA_CBL_PATA40_SHORT for "ideX=ata66" kernel parameter.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Reviewed-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 574414689253..c948a5c17a5d 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -460,6 +460,8 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 	hwif->mwdma_mask		= tmp_hwif->mwdma_mask;
 	hwif->swdma_mask		= tmp_hwif->swdma_mask;
 
+	hwif->cbl			= tmp_hwif->cbl;
+
 	hwif->chipset			= tmp_hwif->chipset;
 	hwif->hold			= tmp_hwif->hold;
 
@@ -533,7 +535,6 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 	hwif->extra_base		= tmp_hwif->extra_base;
 	hwif->extra_ports		= tmp_hwif->extra_ports;
 	hwif->autodma			= tmp_hwif->autodma;
-	hwif->udma_four			= tmp_hwif->udma_four;
 
 	hwif->hwif_data			= tmp_hwif->hwif_data;
 }
@@ -1548,7 +1549,11 @@ static int __init ide_setup(char *s)
 				goto bad_option;
 			case -7: /* ata66 */
 #ifdef CONFIG_BLK_DEV_IDEPCI
-				hwif->udma_four = 1;
+				/*
+				 * Use ATA_CBL_PATA40_SHORT so drive side
+				 * cable detection is also overriden.
+				 */
+				hwif->cbl = ATA_CBL_PATA40_SHORT;
 				goto obsolete_option;
 #else
 				goto bad_hwif;

commit f9383c4269d264c3cf563bd2de365891f6592ebd
Author: Matthias Kaehlcke <matthias.kaehlcke@gmail.com>
Date:   Mon Jul 9 23:17:56 2007 +0200

    ide: use mutex instead of ide_setting_sem semaphore in IDE driver
    
    The IDE driver uses a semaphore as mutex.
    Use the mutex API instead of the (binary) semaphore.
    
    Signed-off-by: Matthias Kaehlcke <matthias.kaehlcke@gmail.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    
    --

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 14ac7c2049e9..574414689253 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -817,9 +817,9 @@ EXPORT_SYMBOL(ide_register_hw);
  *	Locks for IDE setting functionality
  */
 
-DECLARE_MUTEX(ide_setting_sem);
+DEFINE_MUTEX(ide_setting_mtx);
 
-EXPORT_SYMBOL_GPL(ide_setting_sem);
+EXPORT_SYMBOL_GPL(ide_setting_mtx);
 
 /**
  *	ide_spin_wait_hwgroup	-	wait for group
@@ -1192,11 +1192,11 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 	}
 
 read_val:
-	down(&ide_setting_sem);
+	mutex_lock(&ide_setting_mtx);
 	spin_lock_irqsave(&ide_lock, flags);
 	err = *val;
 	spin_unlock_irqrestore(&ide_lock, flags);
-	up(&ide_setting_sem);
+	mutex_unlock(&ide_setting_mtx);
 	return err >= 0 ? put_user(err, (long __user *)arg) : err;
 
 set_val:
@@ -1206,9 +1206,9 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 		if (!capable(CAP_SYS_ADMIN))
 			err = -EACCES;
 		else {
-			down(&ide_setting_sem);
+			mutex_lock(&ide_setting_mtx);
 			err = setfunc(drive, arg);
-			up(&ide_setting_sem);
+			mutex_unlock(&ide_setting_mtx);
 		}
 	}
 	return err;

commit ef29888ea8e1fdc499e995260195b66fc91d2728
Author: Matthias Kaehlcke <matthias.kaehlcke@gmail.com>
Date:   Mon Jul 9 23:17:55 2007 +0200

    ide: use mutex instead of ide_cfg_sem semaphore in IDE driver
    
    The IDE driver uses a semaphore as mutex.
    Use the mutex API instead of the (binary) semaphore.
    
    Signed-off-by: Matthias Kaehlcke <matthias.kaehlcke@gmail.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 3717a329b43b..14ac7c2049e9 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -169,7 +169,7 @@ static const u8 ide_hwif_to_major[] = { IDE0_MAJOR, IDE1_MAJOR,
 static int idebus_parameter;	/* holds the "idebus=" parameter */
 static int system_bus_speed;	/* holds what we think is VESA/PCI bus speed */
 
-DECLARE_MUTEX(ide_cfg_sem);
+DEFINE_MUTEX(ide_cfg_mtx);
  __cacheline_aligned_in_smp DEFINE_SPINLOCK(ide_lock);
 
 #ifdef CONFIG_IDEPCI_PCIBUS_ORDER
@@ -564,7 +564,7 @@ void ide_unregister(unsigned int index)
 {
 	ide_drive_t *drive;
 	ide_hwif_t *hwif, *g;
-	static ide_hwif_t tmp_hwif; /* protected by ide_cfg_sem */
+	static ide_hwif_t tmp_hwif; /* protected by ide_cfg_mtx */
 	ide_hwgroup_t *hwgroup;
 	int irq_count = 0, unit;
 
@@ -572,7 +572,7 @@ void ide_unregister(unsigned int index)
 
 	BUG_ON(in_interrupt());
 	BUG_ON(irqs_disabled());
-	down(&ide_cfg_sem);
+	mutex_lock(&ide_cfg_mtx);
 	spin_lock_irq(&ide_lock);
 	hwif = &ide_hwifs[index];
 	if (!hwif->present)
@@ -679,7 +679,7 @@ void ide_unregister(unsigned int index)
 
 abort:
 	spin_unlock_irq(&ide_lock);
-	up(&ide_cfg_sem);
+	mutex_unlock(&ide_cfg_mtx);
 }
 
 EXPORT_SYMBOL(ide_unregister);

commit c283f5dbe31920ca70b80a594a97bfaa2a28be13
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Mon Jul 9 23:17:54 2007 +0200

    ide: make void and rename ide_dma_timeout() method
    
    Since ide_dma_timeout() method's result is discarded, make it return 'void'.
    While at it, drop 'ide_' from the method's name, drop the '__' prefix from
    the default method's name, and do some cleanups in this method driver-wise:
    
    - in ide-dma.c, au1xxx-ide.c, and pdc202xx_old.c, define/use 'hwif' variable;
    
    - in au1xxx-ide.c, get rid of commented out printk();
    
    - in sl82c105.c, get rid of unnecessary variables.
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 8a8674d3223f..3717a329b43b 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -497,7 +497,7 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 	hwif->dma_host_on		= tmp_hwif->dma_host_on;
 	hwif->dma_host_off		= tmp_hwif->dma_host_off;
 	hwif->dma_lost_irq		= tmp_hwif->dma_lost_irq;
-	hwif->ide_dma_timeout		= tmp_hwif->ide_dma_timeout;
+	hwif->dma_timeout		= tmp_hwif->dma_timeout;
 
 	hwif->OUTB			= tmp_hwif->OUTB;
 	hwif->OUTBSYNC			= tmp_hwif->OUTBSYNC;

commit 841d2a9bf16471716ba3a5172d24aa40a2ea9398
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Mon Jul 9 23:17:54 2007 +0200

    ide: make void and rename ide_dma_lostirq() method
    
    Since ide_dma_lostirq() method's result is discarded, make it return 'void'.
    While at it, rename the method to dma_lost_irq(), drop the '__' prefix from the
    default method's name, and do some cleanups in this method driver-wise:
    
    - in aec62xx.c, rename the method in accordance with other drivers, and get rid
      of unnecessary variables there;
    
    - in pdc202xx_old.c, define/use 'hwif' variable;
    
    - in sgiioc4.c, rearrange the code to call the resetproc() method directly.
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 0cd76bf66833..8a8674d3223f 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -496,7 +496,7 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 	hwif->ide_dma_clear_irq		= tmp_hwif->ide_dma_clear_irq;
 	hwif->dma_host_on		= tmp_hwif->dma_host_on;
 	hwif->dma_host_off		= tmp_hwif->dma_host_off;
-	hwif->ide_dma_lostirq		= tmp_hwif->ide_dma_lostirq;
+	hwif->dma_lost_irq		= tmp_hwif->dma_lost_irq;
 	hwif->ide_dma_timeout		= tmp_hwif->ide_dma_timeout;
 
 	hwif->OUTB			= tmp_hwif->OUTB;

commit ce9b2b0abbf019d5259eb089a1cc256852930f67
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Jun 16 02:24:43 2007 +0200

    Resume from RAM on HPC nx6325 broken
    
    generic_ide_resume() should check if dev->driver is not NULL before applying
    to_ide_driver() to it.  Fix that.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 0af0d1614f75..0cd76bf66833 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1010,7 +1010,6 @@ static int generic_ide_resume(struct device *dev)
 {
 	ide_drive_t *drive = dev->driver_data;
 	ide_hwif_t *hwif = HWIF(drive);
-	ide_driver_t *drv = to_ide_driver(dev->driver);
 	struct request rq;
 	struct request_pm_state rqpm;
 	ide_task_t args;
@@ -1033,8 +1032,12 @@ static int generic_ide_resume(struct device *dev)
 
 	err = ide_do_drive_cmd(drive, &rq, ide_head_wait);
 
-	if (err == 0 && drv && drv->resume)
-		drv->resume(drive);
+	if (err == 0 && dev->driver) {
+		ide_driver_t *drv = to_ide_driver(dev->driver);
+
+		if (drv->resume)
+			drv->resume(drive);
+	}
 
 	return err;
 }

commit 0d2157f78d17fcee17791f54959e67cc0af0da74
Author: Lee Trager <lt73@cs.drexel.edu>
Date:   Fri Jun 8 15:14:30 2007 +0200

    ide: HPA detect from resume
    
    Currently when system which have HPA require HPA to be detected and
    disabled upon resume from RAM or disk. The current IDE drivers do not do
    this nor does libata (obviously it since it doesn't support HPA yet).
    
    I have implemented this into the current IDE drivers and it has been
    tested by many others since 7/15/2006 in bug number 6840:
    
            http://bugzilla.kernel.org/show_bug.cgi?id=6840
    
    and it has been confirmed to work fine with no problems.
    
    bart: added drv != NULL check to generic_ide_suspend()
    
    From: Lee Trager <lt73@cs.drexel.edu>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 6002713a20a1..0af0d1614f75 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1010,9 +1010,11 @@ static int generic_ide_resume(struct device *dev)
 {
 	ide_drive_t *drive = dev->driver_data;
 	ide_hwif_t *hwif = HWIF(drive);
+	ide_driver_t *drv = to_ide_driver(dev->driver);
 	struct request rq;
 	struct request_pm_state rqpm;
 	ide_task_t args;
+	int err;
 
 	/* Call ACPI _STM only once */
 	if (!(drive->dn % 2))
@@ -1029,7 +1031,12 @@ static int generic_ide_resume(struct device *dev)
 	rqpm.pm_step = ide_pm_state_start_resume;
 	rqpm.pm_state = PM_EVENT_ON;
 
-	return ide_do_drive_cmd(drive, &rq, ide_head_wait);
+	err = ide_do_drive_cmd(drive, &rq, ide_head_wait);
+
+	if (err == 0 && drv && drv->resume)
+		drv->resume(drive);
+
+	return err;
 }
 
 int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device *bdev,

commit 793a97228d3da876f42b7fb4d4a52cc8cc86dc81
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Wed May 16 00:51:43 2007 +0200

    ide: always disable DMA before tuning it
    
    ide_start_power_step() and set_using_dma() were missing ->dma_off_quietly
    call (comment in probe_hwif() states that DMA should be always cleared before
    tuning is attempted).  Fix it.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index f2b547ff7722..6002713a20a1 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -910,6 +910,7 @@ int set_using_dma(ide_drive_t *drive, int arg)
 	err = 0;
 
 	if (arg) {
+		hwif->dma_off_quietly(drive);
 		if (ide_set_dma(drive) || hwif->ide_dma_on(drive))
 			err = -EIO;
 	} else

commit 6d208b39c45edee5def6c201fcd51561c5a39828
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu May 10 00:01:11 2007 +0200

    ide: legacy PCI bus order probing fixes
    
    IDE PCI host drivers should register themselves with IDE core only when
    IDE driver is built-in, otherwise (IDE driver is modular and thus IDE PCI
    host drivers are also modular) the code has no effect and just complicates
    the probing.
    
    Fix it by adding new config option CONFIG_IDEPCI_PCIBUS (defined only when
    needed and invisible to the user) and covering by #ifdef/#endif the code
    in question.  It turned out that "ide=reverse" was silently accepted but did
    nothing in case when IDE driver was modular, this is fixed now.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 038f2610e734..f2b547ff7722 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -172,7 +172,7 @@ static int system_bus_speed;	/* holds what we think is VESA/PCI bus speed */
 DECLARE_MUTEX(ide_cfg_sem);
  __cacheline_aligned_in_smp DEFINE_SPINLOCK(ide_lock);
 
-#ifdef CONFIG_BLK_DEV_IDEPCI
+#ifdef CONFIG_IDEPCI_PCIBUS_ORDER
 static int ide_scan_direction; /* THIS was formerly 2.2.x pci=reverse */
 #endif
 
@@ -1333,13 +1333,13 @@ static int __init ide_setup(char *s)
 		return 1;
 	}
 
-#ifdef CONFIG_BLK_DEV_IDEPCI
+#ifdef CONFIG_IDEPCI_PCIBUS_ORDER
 	if (!strcmp(s, "ide=reverse")) {
 		ide_scan_direction = 1;
 		printk(" : Enabled support for IDE inverse scan order.\n");
 		return 1;
 	}
-#endif /* CONFIG_BLK_DEV_IDEPCI */
+#endif
 
 #ifdef CONFIG_BLK_DEV_IDEACPI
 	if (!strcmp(s, "ide=noacpi")) {
@@ -1599,9 +1599,9 @@ extern void __init h8300_ide_init(void);
  */
 static void __init probe_for_hwifs (void)
 {
-#ifdef CONFIG_BLK_DEV_IDEPCI
+#ifdef CONFIG_IDEPCI_PCIBUS_ORDER
 	ide_scan_pcibus(ide_scan_direction);
-#endif /* CONFIG_BLK_DEV_IDEPCI */
+#endif
 
 #ifdef CONFIG_ETRAX_IDE
 	{

commit 5cbf79cdb37be2aa2a1b4fa94144526b14557060
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu May 10 00:01:11 2007 +0200

    ide: add ide_proc_register_port()
    
    * create_proc_ide_interfaces() tries to add /proc entries for every probed
      and initialized IDE port, replace it by ide_proc_register_port() which does
      it only for the given port (also rename destroy_proc_ide_interface() to
      ide_proc_unregister_port() for consistency)
    
    * convert {create,destroy}_proc_ide_interface[s]() users to use new functions
    
    * pmac driver depended on proc_ide_create() to add /proc port entries, fix it
    
    * au1xxx-ide, swarm and cs5520 drivers depended indirectly on ide-generic
      driver (CONFIG_IDE_GENERIC=y) to add port /proc entries, fix them
    
    * there is now no need to add /proc entries for IDE ports in proc_ide_create()
      so don't do it
    
    * proc_ide_create() needs now to be called before drivers are probed - fix it,
      while at it make proc_ide_create() create /proc "ide" directory
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 0fc532850bbe..038f2610e734 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -347,10 +347,6 @@ static int ide_system_bus_speed(void)
 	return system_bus_speed;
 }
 
-#ifdef CONFIG_IDE_PROC_FS
-struct proc_dir_entry *proc_ide_root;
-#endif
-
 static struct resource* hwif_request_region(ide_hwif_t *hwif,
 					    unsigned long addr, int num)
 {
@@ -594,7 +590,7 @@ void ide_unregister(unsigned int index)
 
 	spin_unlock_irq(&ide_lock);
 
-	destroy_proc_ide_interface(hwif);
+	ide_proc_unregister_port(hwif);
 
 	hwgroup = hwif->hwgroup;
 	/*
@@ -799,7 +795,7 @@ int ide_register_hw_with_fixup(hw_regs_t *hw, int initializing,
 
 	if (!initializing) {
 		probe_hwif_init_with_fixup(hwif, fixup);
-		create_proc_ide_interfaces();
+		ide_proc_register_port(hwif);
 	}
 
 	if (hwifp)
@@ -1794,9 +1790,7 @@ static int __init ide_init(void)
 
 	init_ide_data();
 
-#ifdef CONFIG_IDE_PROC_FS
-	proc_ide_root = proc_mkdir("ide", NULL);
-#endif
+	proc_ide_create();
 
 #ifdef CONFIG_BLK_DEV_ALI14XX
 	if (probe_ali14xx)
@@ -1822,8 +1816,6 @@ static int __init ide_init(void)
 	/* Probe for special PCI and other "known" interface chipsets. */
 	probe_for_hwifs();
 
-	proc_ide_create();
-
 	return 0;
 }
 

commit 869c56ee9de1b72cd3f8ab9cdfbd3601e55c61f2
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu May 10 00:01:10 2007 +0200

    ide: add "initializing" argument to ide_register_hw()
    
    Add "initializing" argument to ide_register_hw() and use it instead of ide.c
    wide variable of the same name.  Update all users of ide_register_hw()
    accordingly.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 614c5fd43cd2..0fc532850bbe 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -168,7 +168,6 @@ static const u8 ide_hwif_to_major[] = { IDE0_MAJOR, IDE1_MAJOR,
 
 static int idebus_parameter;	/* holds the "idebus=" parameter */
 static int system_bus_speed;	/* holds what we think is VESA/PCI bus speed */
-static int initializing;	/* set while initializing built-in drivers */
 
 DECLARE_MUTEX(ide_cfg_sem);
  __cacheline_aligned_in_smp DEFINE_SPINLOCK(ide_lock);
@@ -302,9 +301,7 @@ static void __init init_ide_data (void)
 #endif
 	}
 #ifdef CONFIG_IDE_ARM
-	initializing = 1;
 	ide_arm_init();
-	initializing = 0;
 #endif
 }
 
@@ -749,6 +746,7 @@ void ide_setup_ports (	hw_regs_t *hw,
 /**
  *	ide_register_hw_with_fixup	-	register IDE interface
  *	@hw: hardware registers
+ *	@initializing: set while initializing built-in drivers
  *	@hwifp: pointer to returned hwif
  *	@fixup: fixup function
  *
@@ -758,7 +756,9 @@ void ide_setup_ports (	hw_regs_t *hw,
  *	Returns -1 on error.
  */
 
-int ide_register_hw_with_fixup(hw_regs_t *hw, ide_hwif_t **hwifp, void(*fixup)(ide_hwif_t *hwif))
+int ide_register_hw_with_fixup(hw_regs_t *hw, int initializing,
+			       ide_hwif_t **hwifp,
+			       void(*fixup)(ide_hwif_t *hwif))
 {
 	int index, retry = 1;
 	ide_hwif_t *hwif;
@@ -810,9 +810,9 @@ int ide_register_hw_with_fixup(hw_regs_t *hw, ide_hwif_t **hwifp, void(*fixup)(i
 
 EXPORT_SYMBOL(ide_register_hw_with_fixup);
 
-int ide_register_hw(hw_regs_t *hw, ide_hwif_t **hwifp)
+int ide_register_hw(hw_regs_t *hw, int initializing, ide_hwif_t **hwifp)
 {
-	return ide_register_hw_with_fixup(hw, hwifp, NULL);
+	return ide_register_hw_with_fixup(hw, initializing, hwifp, NULL);
 }
 
 EXPORT_SYMBOL(ide_register_hw);
@@ -1108,7 +1108,7 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 			ide_init_hwif_ports(&hw, (unsigned long) args[0],
 					    (unsigned long) args[1], NULL);
 			hw.irq = args[2];
-			if (ide_register_hw(&hw, NULL) == -1)
+			if (ide_register_hw(&hw, 0, NULL) == -1)
 				return -EIO;
 			return 0;
 		}
@@ -1819,10 +1819,8 @@ static int __init ide_init(void)
 		(void)qd65xx_init();
 #endif
 
-	initializing = 1;
 	/* Probe for special PCI and other "known" interface chipsets. */
 	probe_for_hwifs();
-	initializing = 0;
 
 	proc_ide_create();
 

commit 7662d046df09e80680b77b68de896beab45e675e
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu May 10 00:01:10 2007 +0200

    ide: move IDE settings handling to ide-proc.c
    
    * move
            __ide_add_setting()
            ide_add_setting()
            __ide_remove_setting()
            auto_remove_settings()
            ide_find_setting_by_name()
            ide_read_setting()
            ide_write_setting()
            set_xfer_rate()
            ide_add_generic_settings()
            ide_register_subdriver()
            ide_unregister_subdriver()
    
      from ide.c to ide-proc.c
    
    * set_{io_32bit,pio_mode,using_dma}() cannot be marked static now, fix it
    
    * rename ide_[un]register_subdriver() to ide_proc_[un]register_driver(),
      update device drivers to use new names
    
    * add CONFIG_IDE_PROC_FS=n versions of ide_proc_[un]register_driver()
      and ide_add_generic_settings()
    
    * make ide_find_setting_by_name(), ide_{read,write}_setting()
      and ide_{add,remove}_proc_entries() static
    
    * cover IDE settings code in device drivers with CONFIG_IDE_PROC_FS #ifdef,
      also while at it cover with CONFIG_IDE_PROC_FS #ifdef ide_driver_t.proc
    
    * remove bogus comment from ide.h
    
    * cover with CONFIG_IDE_PROC_FS #ifdef .proc and .settings in ide_drive_t
    
    Besides saner code this patch results in the IDE core smaller by ~2 kB
    (on x86-32) and IDE disk driver by ~1 kB (ditto) when CONFIG_IDE_PROC_FS=n.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 8793a960210c..614c5fd43cd2 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -825,178 +825,6 @@ DECLARE_MUTEX(ide_setting_sem);
 
 EXPORT_SYMBOL_GPL(ide_setting_sem);
 
-/**
- *	__ide_add_setting	-	add an ide setting option
- *	@drive: drive to use
- *	@name: setting name
- *	@rw: true if the function is read write
- *	@data_type: type of data
- *	@min: range minimum
- *	@max: range maximum
- *	@mul_factor: multiplication scale
- *	@div_factor: divison scale
- *	@data: private data field
- *	@set: setting
- *	@auto_remove: setting auto removal flag
- *
- *	Removes the setting named from the device if it is present.
- *	The function takes the settings_lock to protect against 
- *	parallel changes. This function must not be called from IRQ
- *	context. Returns 0 on success or -1 on failure.
- *
- *	BUGS: This code is seriously over-engineered. There is also
- *	magic about how the driver specific features are setup. If
- *	a driver is attached we assume the driver settings are auto
- *	remove.
- */
-
-static int __ide_add_setting(ide_drive_t *drive, const char *name, int rw, int data_type, int min, int max, int mul_factor, int div_factor, void *data, ide_procset_t *set, int auto_remove)
-{
-	ide_settings_t **p = (ide_settings_t **) &drive->settings, *setting = NULL;
-
-	down(&ide_setting_sem);
-	while ((*p) && strcmp((*p)->name, name) < 0)
-		p = &((*p)->next);
-	if ((setting = kzalloc(sizeof(*setting), GFP_KERNEL)) == NULL)
-		goto abort;
-	if ((setting->name = kmalloc(strlen(name) + 1, GFP_KERNEL)) == NULL)
-		goto abort;
-	strcpy(setting->name, name);
-	setting->rw = rw;
-	setting->data_type = data_type;
-	setting->min = min;
-	setting->max = max;
-	setting->mul_factor = mul_factor;
-	setting->div_factor = div_factor;
-	setting->data = data;
-	setting->set = set;
-	
-	setting->next = *p;
-	if (auto_remove)
-		setting->auto_remove = 1;
-	*p = setting;
-	up(&ide_setting_sem);
-	return 0;
-abort:
-	up(&ide_setting_sem);
-	kfree(setting);
-	return -1;
-}
-
-int ide_add_setting(ide_drive_t *drive, const char *name, int rw, int data_type, int min, int max, int mul_factor, int div_factor, void *data, ide_procset_t *set)
-{
-	return __ide_add_setting(drive, name, rw, data_type, min, max, mul_factor, div_factor, data, set, 1);
-}
-
-EXPORT_SYMBOL(ide_add_setting);
-
-/**
- *	__ide_remove_setting	-	remove an ide setting option
- *	@drive: drive to use
- *	@name: setting name
- *
- *	Removes the setting named from the device if it is present.
- *	The caller must hold the setting semaphore.
- */
- 
-static void __ide_remove_setting (ide_drive_t *drive, char *name)
-{
-	ide_settings_t **p, *setting;
-
-	p = (ide_settings_t **) &drive->settings;
-
-	while ((*p) && strcmp((*p)->name, name))
-		p = &((*p)->next);
-	if ((setting = (*p)) == NULL)
-		return;
-
-	(*p) = setting->next;
-	
-	kfree(setting->name);
-	kfree(setting);
-}
-
-/**
- *	ide_find_setting_by_name	-	find a drive specific setting
- *	@drive: drive to scan
- *	@name: setting name
- *
- *	Scan's the device setting table for a matching entry and returns
- *	this or NULL if no entry is found. The caller must hold the
- *	setting semaphore
- */
- 
-ide_settings_t *ide_find_setting_by_name (ide_drive_t *drive, char *name)
-{
-	ide_settings_t *setting = drive->settings;
-
-	while (setting) {
-		if (strcmp(setting->name, name) == 0)
-			break;
-		setting = setting->next;
-	}
-	return setting;
-}
-
-/**
- *	auto_remove_settings	-	remove driver specific settings
- *	@drive: drive
- *
- *	Automatically remove all the driver specific settings for this
- *	drive. This function may not be called from IRQ context. The
- *	caller must hold ide_setting_sem.
- */
- 
-static void auto_remove_settings (ide_drive_t *drive)
-{
-	ide_settings_t *setting;
-repeat:
-	setting = drive->settings;
-	while (setting) {
-		if (setting->auto_remove) {
-			__ide_remove_setting(drive, setting->name);
-			goto repeat;
-		}
-		setting = setting->next;
-	}
-}
-
-/**
- *	ide_read_setting	-	read an IDE setting
- *	@drive: drive to read from
- *	@setting: drive setting
- *
- *	Read a drive setting and return the value. The caller
- *	must hold the ide_setting_sem when making this call.
- *
- *	BUGS: the data return and error are the same return value
- *	so an error -EINVAL and true return of the same value cannot
- *	be told apart
- */
- 
-int ide_read_setting (ide_drive_t *drive, ide_settings_t *setting)
-{
-	int		val = -EINVAL;
-	unsigned long	flags;
-
-	if ((setting->rw & SETTING_READ)) {
-		spin_lock_irqsave(&ide_lock, flags);
-		switch(setting->data_type) {
-			case TYPE_BYTE:
-				val = *((u8 *) setting->data);
-				break;
-			case TYPE_SHORT:
-				val = *((u16 *) setting->data);
-				break;
-			case TYPE_INT:
-				val = *((u32 *) setting->data);
-				break;
-		}
-		spin_unlock_irqrestore(&ide_lock, flags);
-	}
-	return val;
-}
-
 /**
  *	ide_spin_wait_hwgroup	-	wait for group
  *	@drive: drive in the group
@@ -1030,52 +858,7 @@ int ide_spin_wait_hwgroup (ide_drive_t *drive)
 
 EXPORT_SYMBOL(ide_spin_wait_hwgroup);
 
-/**
- *	ide_write_setting	-	read an IDE setting
- *	@drive: drive to read from
- *	@setting: drive setting
- *	@val: value
- *
- *	Write a drive setting if it is possible. The caller
- *	must hold the ide_setting_sem when making this call.
- *
- *	BUGS: the data return and error are the same return value
- *	so an error -EINVAL and true return of the same value cannot
- *	be told apart
- *
- *	FIXME:  This should be changed to enqueue a special request
- *	to the driver to change settings, and then wait on a sema for completion.
- *	The current scheme of polling is kludgy, though safe enough.
- */
-
-int ide_write_setting (ide_drive_t *drive, ide_settings_t *setting, int val)
-{
-	if (!capable(CAP_SYS_ADMIN))
-		return -EACCES;
-	if (setting->set)
-		return setting->set(drive, val);
-	if (!(setting->rw & SETTING_WRITE))
-		return -EPERM;
-	if (val < setting->min || val > setting->max)
-		return -EINVAL;
-	if (ide_spin_wait_hwgroup(drive))
-		return -EBUSY;
-	switch (setting->data_type) {
-		case TYPE_BYTE:
-			*((u8 *) setting->data) = val;
-			break;
-		case TYPE_SHORT:
-			*((u16 *) setting->data) = val;
-			break;
-		case TYPE_INT:
-			*((u32 *) setting->data) = val;
-			break;
-	}
-	spin_unlock_irq(&ide_lock);
-	return 0;
-}
-
-static int set_io_32bit(ide_drive_t *drive, int arg)
+int set_io_32bit(ide_drive_t *drive, int arg)
 {
 	if (drive->no_io_32bit)
 		return -EPERM;
@@ -1104,7 +887,7 @@ static int set_ksettings(ide_drive_t *drive, int arg)
 	return 0;
 }
 
-static int set_using_dma (ide_drive_t *drive, int arg)
+int set_using_dma(ide_drive_t *drive, int arg)
 {
 #ifdef CONFIG_BLK_DEV_IDEDMA
 	ide_hwif_t *hwif = drive->hwif;
@@ -1152,7 +935,7 @@ static int set_using_dma (ide_drive_t *drive, int arg)
 #endif
 }
 
-static int set_pio_mode (ide_drive_t *drive, int arg)
+int set_pio_mode(ide_drive_t *drive, int arg)
 {
 	struct request rq;
 
@@ -1186,48 +969,6 @@ static int set_unmaskirq(ide_drive_t *drive, int arg)
 	return 0;
 }
 
-static int set_xfer_rate (ide_drive_t *drive, int arg)
-{
-	int err;
-
-	if (arg < 0 || arg > 70)
-		return -EINVAL;
-
-	err = ide_wait_cmd(drive,
-			WIN_SETFEATURES, (u8) arg,
-			SETFEATURES_XFER, 0, NULL);
-
-	if (!err && arg) {
-		ide_set_xfer_rate(drive, (u8) arg);
-		ide_driveid_update(drive);
-	}
-	return err;
-}
-
-/**
- *	ide_add_generic_settings	-	generic ide settings
- *	@drive: drive being configured
- *
- *	Add the generic parts of the system settings to the /proc files.
- *	The caller must not be holding the ide_setting_sem.
- */
-
-void ide_add_generic_settings (ide_drive_t *drive)
-{
-/*
- *			  drive		setting name		read/write access				data type	min	max				mul_factor	div_factor	data pointer			set function
- */
-	__ide_add_setting(drive,	"io_32bit",		drive->no_io_32bit ? SETTING_READ : SETTING_RW,	TYPE_BYTE,	0,	1 + (SUPPORT_VLB_SYNC << 1),	1,		1,		&drive->io_32bit,		set_io_32bit,	0);
-	__ide_add_setting(drive,	"keepsettings",		SETTING_RW,					TYPE_BYTE,	0,	1,				1,		1,		&drive->keep_settings,		NULL,		0);
-	__ide_add_setting(drive,	"nice1",		SETTING_RW,					TYPE_BYTE,	0,	1,				1,		1,		&drive->nice1,			NULL,		0);
-	__ide_add_setting(drive,	"pio_mode",		SETTING_WRITE,					TYPE_BYTE,	0,	255,				1,		1,		NULL,				set_pio_mode,	0);
-	__ide_add_setting(drive,	"unmaskirq",		drive->no_unmask ? SETTING_READ : SETTING_RW,	TYPE_BYTE,	0,	1,				1,		1,		&drive->unmask,			NULL,		0);
-	__ide_add_setting(drive,	"using_dma",		SETTING_RW,					TYPE_BYTE,	0,	1,				1,		1,		&drive->using_dma,		set_using_dma,	0);
-	__ide_add_setting(drive,	"init_speed",		SETTING_RW,					TYPE_BYTE,	0,	70,				1,		1,		&drive->init_speed,		NULL,		0);
-	__ide_add_setting(drive,	"current_speed",	SETTING_RW,					TYPE_BYTE,	0,	70,				1,		1,		&drive->current_speed,		set_xfer_rate,	0);
-	__ide_add_setting(drive,	"number",		SETTING_RW,					TYPE_BYTE,	0,	3,				1,		1,		&drive->dn,			NULL,		0);
-}
-
 /**
  *	system_bus_clock	-	clock guess
  *
@@ -1922,54 +1663,6 @@ static void __init probe_for_hwifs (void)
 #endif
 }
 
-void ide_register_subdriver(ide_drive_t *drive, ide_driver_t *driver)
-{
-#ifdef CONFIG_IDE_PROC_FS
-	ide_add_proc_entries(drive->proc, driver->proc, drive);
-#endif
-}
-
-EXPORT_SYMBOL(ide_register_subdriver);
-
-/**
- *	ide_unregister_subdriver	-	disconnect drive from driver
- *	@drive: drive to unplug
- *	@driver: driver
- *
- *	Disconnect a drive from the driver it was attached to and then
- *	clean up the various proc files and other objects attached to it.
- *
- *	Takes ide_setting_sem and ide_lock.
- *	Caller must hold none of the locks.
- */
-
-void ide_unregister_subdriver(ide_drive_t *drive, ide_driver_t *driver)
-{
-	unsigned long flags;
-
-#ifdef CONFIG_IDE_PROC_FS
-	ide_remove_proc_entries(drive->proc, driver->proc);
-#endif
-	down(&ide_setting_sem);
-	spin_lock_irqsave(&ide_lock, flags);
-	/*
-	 * ide_setting_sem protects the settings list
-	 * ide_lock protects the use of settings
-	 *
-	 * so we need to hold both, ide_settings_sem because we want to
-	 * modify the settings list, and ide_lock because we cannot take
-	 * a setting out that is being used.
-	 *
-	 * OTOH both ide_{read,write}_setting are only ever used under
-	 * ide_setting_sem.
-	 */
-	auto_remove_settings(drive);
-	spin_unlock_irqrestore(&ide_lock, flags);
-	up(&ide_setting_sem);
-}
-
-EXPORT_SYMBOL(ide_unregister_subdriver);
-
 /*
  * Probe module
  */

commit 1497943ee692aa7519fa972d0e3a339649bf3a96
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu May 10 00:01:10 2007 +0200

    ide: split off ioctl handling from IDE settings (v2)
    
    * do write permission and min/max checks in ide_procset_t functions
    
    * ide-disk.c: drive->id is always available so cleanup "multcount" setting
      accordingly
    
    * ide-disk.c: "address" setting was incorrectly defined as type TYPE_INTA,
      fix it by using type TYPE_BYTE and updating ide_drive_t->adressing field,
      the bug didn't trigger because this IDE setting uses custom ->set function
    
    * ide.c: add set_ksettings() for handling HDIO_SET_KEEPSETTINGS ioctl
    
    * ide.c: add set_unmaskirq() for handling HDIO_SET_UNMASKINTR ioctl
    
    * handle ioctls directly in generic_ide_ioclt() and idedisk_ioctl()
      instead of using IDE settings to deal with them
    
    * remove no longer needed ide_find_setting_by_ioctl() and {read,write}_ioctl
      fields from ide_settings_t, also remove now unused TYPE_INTA handling
    
    v2:
    * add missing EXPORT_SYMBOL_GPL(ide_setting_sem) needed now for ide-disk
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 7a96f6f07494..8793a960210c 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -823,13 +823,13 @@ EXPORT_SYMBOL(ide_register_hw);
 
 DECLARE_MUTEX(ide_setting_sem);
 
+EXPORT_SYMBOL_GPL(ide_setting_sem);
+
 /**
  *	__ide_add_setting	-	add an ide setting option
  *	@drive: drive to use
  *	@name: setting name
  *	@rw: true if the function is read write
- *	@read_ioctl: function to call on read
- *	@write_ioctl: function to call on write
  *	@data_type: type of data
  *	@min: range minimum
  *	@max: range maximum
@@ -850,7 +850,7 @@ DECLARE_MUTEX(ide_setting_sem);
  *	remove.
  */
 
-static int __ide_add_setting(ide_drive_t *drive, const char *name, int rw, int read_ioctl, int write_ioctl, int data_type, int min, int max, int mul_factor, int div_factor, void *data, ide_procset_t *set, int auto_remove)
+static int __ide_add_setting(ide_drive_t *drive, const char *name, int rw, int data_type, int min, int max, int mul_factor, int div_factor, void *data, ide_procset_t *set, int auto_remove)
 {
 	ide_settings_t **p = (ide_settings_t **) &drive->settings, *setting = NULL;
 
@@ -863,8 +863,6 @@ static int __ide_add_setting(ide_drive_t *drive, const char *name, int rw, int r
 		goto abort;
 	strcpy(setting->name, name);
 	setting->rw = rw;
-	setting->read_ioctl = read_ioctl;
-	setting->write_ioctl = write_ioctl;
 	setting->data_type = data_type;
 	setting->min = min;
 	setting->max = max;
@@ -885,9 +883,9 @@ static int __ide_add_setting(ide_drive_t *drive, const char *name, int rw, int r
 	return -1;
 }
 
-int ide_add_setting(ide_drive_t *drive, const char *name, int rw, int read_ioctl, int write_ioctl, int data_type, int min, int max, int mul_factor, int div_factor, void *data, ide_procset_t *set)
+int ide_add_setting(ide_drive_t *drive, const char *name, int rw, int data_type, int min, int max, int mul_factor, int div_factor, void *data, ide_procset_t *set)
 {
-	return __ide_add_setting(drive, name, rw, read_ioctl, write_ioctl, data_type, min, max, mul_factor, div_factor, data, set, 1);
+	return __ide_add_setting(drive, name, rw, data_type, min, max, mul_factor, div_factor, data, set, 1);
 }
 
 EXPORT_SYMBOL(ide_add_setting);
@@ -918,29 +916,6 @@ static void __ide_remove_setting (ide_drive_t *drive, char *name)
 	kfree(setting);
 }
 
-/**
- *	ide_find_setting_by_ioctl	-	find a drive specific ioctl
- *	@drive: drive to scan
- *	@cmd: ioctl command to handle
- *
- *	Scan's the device setting table for a matching entry and returns
- *	this or NULL if no entry is found. The caller must hold the
- *	setting semaphore
- */
- 
-static ide_settings_t *ide_find_setting_by_ioctl (ide_drive_t *drive, int cmd)
-{
-	ide_settings_t *setting = drive->settings;
-
-	while (setting) {
-		if (setting->read_ioctl == cmd || setting->write_ioctl == cmd)
-			break;
-		setting = setting->next;
-	}
-	
-	return setting;
-}
-
 /**
  *	ide_find_setting_by_name	-	find a drive specific setting
  *	@drive: drive to scan
@@ -1014,7 +989,6 @@ int ide_read_setting (ide_drive_t *drive, ide_settings_t *setting)
 				val = *((u16 *) setting->data);
 				break;
 			case TYPE_INT:
-			case TYPE_INTA:
 				val = *((u32 *) setting->data);
 				break;
 		}
@@ -1076,17 +1050,14 @@ EXPORT_SYMBOL(ide_spin_wait_hwgroup);
 
 int ide_write_setting (ide_drive_t *drive, ide_settings_t *setting, int val)
 {
-	int i;
-	u32 *p;
-
 	if (!capable(CAP_SYS_ADMIN))
 		return -EACCES;
+	if (setting->set)
+		return setting->set(drive, val);
 	if (!(setting->rw & SETTING_WRITE))
 		return -EPERM;
 	if (val < setting->min || val > setting->max)
 		return -EINVAL;
-	if (setting->set)
-		return setting->set(drive, val);
 	if (ide_spin_wait_hwgroup(drive))
 		return -EBUSY;
 	switch (setting->data_type) {
@@ -1099,11 +1070,6 @@ int ide_write_setting (ide_drive_t *drive, ide_settings_t *setting, int val)
 		case TYPE_INT:
 			*((u32 *) setting->data) = val;
 			break;
-		case TYPE_INTA:
-			p = (u32 *) setting->data;
-			for (i = 0; i < 1 << PARTN_BITS; i++, p++)
-				*p = val;
-			break;
 	}
 	spin_unlock_irq(&ide_lock);
 	return 0;
@@ -1111,6 +1077,12 @@ int ide_write_setting (ide_drive_t *drive, ide_settings_t *setting, int val)
 
 static int set_io_32bit(ide_drive_t *drive, int arg)
 {
+	if (drive->no_io_32bit)
+		return -EPERM;
+
+	if (arg < 0 || arg > 1 + (SUPPORT_VLB_SYNC << 1))
+		return -EINVAL;
+
 	drive->io_32bit = arg;
 #ifdef CONFIG_BLK_DEV_DTC2278
 	if (HWIF(drive)->chipset == ide_dtc2278)
@@ -1119,12 +1091,28 @@ static int set_io_32bit(ide_drive_t *drive, int arg)
 	return 0;
 }
 
+static int set_ksettings(ide_drive_t *drive, int arg)
+{
+	if (arg < 0 || arg > 1)
+		return -EINVAL;
+
+	if (ide_spin_wait_hwgroup(drive))
+		return -EBUSY;
+	drive->keep_settings = arg;
+	spin_unlock_irq(&ide_lock);
+
+	return 0;
+}
+
 static int set_using_dma (ide_drive_t *drive, int arg)
 {
 #ifdef CONFIG_BLK_DEV_IDEDMA
 	ide_hwif_t *hwif = drive->hwif;
 	int err = -EPERM;
 
+	if (arg < 0 || arg > 1)
+		return -EINVAL;
+
 	if (!drive->id || !(drive->id->capability & 1))
 		goto out;
 
@@ -1157,6 +1145,9 @@ static int set_using_dma (ide_drive_t *drive, int arg)
 out:
 	return err;
 #else
+	if (arg < 0 || arg > 1)
+		return -EINVAL;
+
 	return -EPERM;
 #endif
 }
@@ -1165,6 +1156,9 @@ static int set_pio_mode (ide_drive_t *drive, int arg)
 {
 	struct request rq;
 
+	if (arg < 0 || arg > 255)
+		return -EINVAL;
+
 	if (!HWIF(drive)->tuneproc)
 		return -ENOSYS;
 	if (drive->special.b.set_tune)
@@ -1176,9 +1170,30 @@ static int set_pio_mode (ide_drive_t *drive, int arg)
 	return 0;
 }
 
+static int set_unmaskirq(ide_drive_t *drive, int arg)
+{
+	if (drive->no_unmask)
+		return -EPERM;
+
+	if (arg < 0 || arg > 1)
+		return -EINVAL;
+
+	if (ide_spin_wait_hwgroup(drive))
+		return -EBUSY;
+	drive->unmask = arg;
+	spin_unlock_irq(&ide_lock);
+
+	return 0;
+}
+
 static int set_xfer_rate (ide_drive_t *drive, int arg)
 {
-	int err = ide_wait_cmd(drive,
+	int err;
+
+	if (arg < 0 || arg > 70)
+		return -EINVAL;
+
+	err = ide_wait_cmd(drive,
 			WIN_SETFEATURES, (u8) arg,
 			SETFEATURES_XFER, 0, NULL);
 
@@ -1193,25 +1208,24 @@ static int set_xfer_rate (ide_drive_t *drive, int arg)
  *	ide_add_generic_settings	-	generic ide settings
  *	@drive: drive being configured
  *
- *	Add the generic parts of the system settings to the /proc files and
- *	ioctls for this IDE device. The caller must not be holding the
- *	ide_setting_sem.
+ *	Add the generic parts of the system settings to the /proc files.
+ *	The caller must not be holding the ide_setting_sem.
  */
 
 void ide_add_generic_settings (ide_drive_t *drive)
 {
 /*
- *			  drive		setting name		read/write access				read ioctl		write ioctl		data type	min	max				mul_factor	div_factor	data pointer			set function
+ *			  drive		setting name		read/write access				data type	min	max				mul_factor	div_factor	data pointer			set function
  */
-	__ide_add_setting(drive,	"io_32bit",		drive->no_io_32bit ? SETTING_READ : SETTING_RW,	HDIO_GET_32BIT,		HDIO_SET_32BIT,		TYPE_BYTE,	0,	1 + (SUPPORT_VLB_SYNC << 1),	1,		1,		&drive->io_32bit,		set_io_32bit,	0);
-	__ide_add_setting(drive,	"keepsettings",		SETTING_RW,					HDIO_GET_KEEPSETTINGS,	HDIO_SET_KEEPSETTINGS,	TYPE_BYTE,	0,	1,				1,		1,		&drive->keep_settings,		NULL,		0);
-	__ide_add_setting(drive,	"nice1",		SETTING_RW,					-1,			-1,			TYPE_BYTE,	0,	1,				1,		1,		&drive->nice1,			NULL,		0);
-	__ide_add_setting(drive,	"pio_mode",		SETTING_WRITE,					-1,			HDIO_SET_PIO_MODE,	TYPE_BYTE,	0,	255,				1,		1,		NULL,				set_pio_mode,	0);
-	__ide_add_setting(drive,	"unmaskirq",		drive->no_unmask ? SETTING_READ : SETTING_RW,	HDIO_GET_UNMASKINTR,	HDIO_SET_UNMASKINTR,	TYPE_BYTE,	0,	1,				1,		1,		&drive->unmask,			NULL,		0);
-	__ide_add_setting(drive,	"using_dma",		SETTING_RW,					HDIO_GET_DMA,		HDIO_SET_DMA,		TYPE_BYTE,	0,	1,				1,		1,		&drive->using_dma,		set_using_dma,	0);
-	__ide_add_setting(drive,	"init_speed",		SETTING_RW,					-1,			-1,			TYPE_BYTE,	0,	70,				1,		1,		&drive->init_speed,		NULL,		0);
-	__ide_add_setting(drive,	"current_speed",	SETTING_RW,					-1,			-1,			TYPE_BYTE,	0,	70,				1,		1,		&drive->current_speed,		set_xfer_rate,	0);
-	__ide_add_setting(drive,	"number",		SETTING_RW,					-1,			-1,			TYPE_BYTE,	0,	3,				1,		1,		&drive->dn,			NULL,		0);
+	__ide_add_setting(drive,	"io_32bit",		drive->no_io_32bit ? SETTING_READ : SETTING_RW,	TYPE_BYTE,	0,	1 + (SUPPORT_VLB_SYNC << 1),	1,		1,		&drive->io_32bit,		set_io_32bit,	0);
+	__ide_add_setting(drive,	"keepsettings",		SETTING_RW,					TYPE_BYTE,	0,	1,				1,		1,		&drive->keep_settings,		NULL,		0);
+	__ide_add_setting(drive,	"nice1",		SETTING_RW,					TYPE_BYTE,	0,	1,				1,		1,		&drive->nice1,			NULL,		0);
+	__ide_add_setting(drive,	"pio_mode",		SETTING_WRITE,					TYPE_BYTE,	0,	255,				1,		1,		NULL,				set_pio_mode,	0);
+	__ide_add_setting(drive,	"unmaskirq",		drive->no_unmask ? SETTING_READ : SETTING_RW,	TYPE_BYTE,	0,	1,				1,		1,		&drive->unmask,			NULL,		0);
+	__ide_add_setting(drive,	"using_dma",		SETTING_RW,					TYPE_BYTE,	0,	1,				1,		1,		&drive->using_dma,		set_using_dma,	0);
+	__ide_add_setting(drive,	"init_speed",		SETTING_RW,					TYPE_BYTE,	0,	70,				1,		1,		&drive->init_speed,		NULL,		0);
+	__ide_add_setting(drive,	"current_speed",	SETTING_RW,					TYPE_BYTE,	0,	70,				1,		1,		&drive->current_speed,		set_xfer_rate,	0);
+	__ide_add_setting(drive,	"number",		SETTING_RW,					TYPE_BYTE,	0,	3,				1,		1,		&drive->dn,			NULL,		0);
 }
 
 /**
@@ -1283,27 +1297,23 @@ static int generic_ide_resume(struct device *dev)
 int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device *bdev,
 			unsigned int cmd, unsigned long arg)
 {
-	ide_settings_t *setting;
+	unsigned long flags;
 	ide_driver_t *drv;
-	int err = 0;
 	void __user *p = (void __user *)arg;
+	int err = 0, (*setfunc)(ide_drive_t *, int);
+	u8 *val;
 
-	down(&ide_setting_sem);
-	if ((setting = ide_find_setting_by_ioctl(drive, cmd)) != NULL) {
-		if (cmd == setting->read_ioctl) {
-			err = ide_read_setting(drive, setting);
-			up(&ide_setting_sem);
-			return err >= 0 ? put_user(err, (long __user *)arg) : err;
-		} else {
-			if (bdev != bdev->bd_contains)
-				err = -EINVAL;
-			else
-				err = ide_write_setting(drive, setting, arg);
-			up(&ide_setting_sem);
-			return err;
-		}
+	switch (cmd) {
+	case HDIO_GET_32BIT:	    val = &drive->io_32bit;	 goto read_val;
+	case HDIO_GET_KEEPSETTINGS: val = &drive->keep_settings; goto read_val;
+	case HDIO_GET_UNMASKINTR:   val = &drive->unmask;	 goto read_val;
+	case HDIO_GET_DMA:	    val = &drive->using_dma;	 goto read_val;
+	case HDIO_SET_32BIT:	    setfunc = set_io_32bit;	 goto set_val;
+	case HDIO_SET_KEEPSETTINGS: setfunc = set_ksettings;	 goto set_val;
+	case HDIO_SET_PIO_MODE:	    setfunc = set_pio_mode;	 goto set_val;
+	case HDIO_SET_UNMASKINTR:   setfunc = set_unmaskirq;	 goto set_val;
+	case HDIO_SET_DMA:	    setfunc = set_using_dma;	 goto set_val;
 	}
-	up(&ide_setting_sem);
 
 	switch (cmd) {
 		case HDIO_OBSOLETE_IDENTITY:
@@ -1432,6 +1442,28 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 		default:
 			return -EINVAL;
 	}
+
+read_val:
+	down(&ide_setting_sem);
+	spin_lock_irqsave(&ide_lock, flags);
+	err = *val;
+	spin_unlock_irqrestore(&ide_lock, flags);
+	up(&ide_setting_sem);
+	return err >= 0 ? put_user(err, (long __user *)arg) : err;
+
+set_val:
+	if (bdev != bdev->bd_contains)
+		err = -EINVAL;
+	else {
+		if (!capable(CAP_SYS_ADMIN))
+			err = -EACCES;
+		else {
+			down(&ide_setting_sem);
+			err = setfunc(drive, arg);
+			up(&ide_setting_sem);
+		}
+	}
+	return err;
 }
 
 EXPORT_SYMBOL(generic_ide_ioctl);

commit ecfd80e4a514123070b4cfb674b817ba75055df2
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu May 10 00:01:09 2007 +0200

    ide: make /proc/ide/ optional
    
    All important information/features should be already available through
    sysfs and ioctl interfaces.
    
    Add CONFIG_IDE_PROC_FS (CONFIG_SCSI_PROC_FS rip-off) config option,
    disabling it makes IDE driver ~5 kB smaller (on x86-32).
    
    While at it add CONFIG_PROC_FS=n versions of proc_ide_{create,destroy}()
    and remove no longer needed #ifdefs.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 73f752142f9e..7a96f6f07494 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -350,7 +350,7 @@ static int ide_system_bus_speed(void)
 	return system_bus_speed;
 }
 
-#ifdef CONFIG_PROC_FS
+#ifdef CONFIG_IDE_PROC_FS
 struct proc_dir_entry *proc_ide_root;
 #endif
 
@@ -1892,7 +1892,7 @@ static void __init probe_for_hwifs (void)
 
 void ide_register_subdriver(ide_drive_t *drive, ide_driver_t *driver)
 {
-#ifdef CONFIG_PROC_FS
+#ifdef CONFIG_IDE_PROC_FS
 	ide_add_proc_entries(drive->proc, driver->proc, drive);
 #endif
 }
@@ -1914,8 +1914,8 @@ EXPORT_SYMBOL(ide_register_subdriver);
 void ide_unregister_subdriver(ide_drive_t *drive, ide_driver_t *driver)
 {
 	unsigned long flags;
-	
-#ifdef CONFIG_PROC_FS
+
+#ifdef CONFIG_IDE_PROC_FS
 	ide_remove_proc_entries(drive->proc, driver->proc);
 #endif
 	down(&ide_setting_sem);
@@ -2069,7 +2069,7 @@ static int __init ide_init(void)
 
 	init_ide_data();
 
-#ifdef CONFIG_PROC_FS
+#ifdef CONFIG_IDE_PROC_FS
 	proc_ide_root = proc_mkdir("ide", NULL);
 #endif
 
@@ -2099,9 +2099,8 @@ static int __init ide_init(void)
 	probe_for_hwifs();
 	initializing = 0;
 
-#ifdef CONFIG_PROC_FS
 	proc_ide_create();
-#endif
+
 	return 0;
 }
 
@@ -2141,9 +2140,7 @@ void __exit cleanup_module (void)
 	pnpide_exit();
 #endif
 
-#ifdef CONFIG_PROC_FS
 	proc_ide_destroy();
-#endif
 
 	bus_unregister(&ide_bus_type);
 }

commit 2d5eaa6dd744a641e75503232a01f52d0768884c
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu May 10 00:01:08 2007 +0200

    ide: rework the code for selecting the best DMA transfer mode (v3)
    
    Depends on the "ide: fix UDMA/MWDMA/SWDMA masks" patch.
    
    * add ide_hwif_t.udma_filter hook for filtering UDMA mask
      (use it in alim15x3, hpt366, siimage and serverworks drivers)
    * add ide_max_dma_mode() for finding best DMA mode for the device
      (loosely based on some older libata-core.c code)
    * convert ide_dma_speed() users to use ide_max_dma_mode()
    * make ide_rate_filter() take "ide_drive_t *drive" as an argument instead
      of "u8 mode" and teach it to how to use UDMA mask to do filtering
    * use ide_rate_filter() in hpt366 driver
    * remove no longer needed ide_dma_speed() and *_ratemask()
    * unexport eighty_ninty_three()
    
    v2:
    * rename ->filter_udma_mask to ->udma_filter
      [ Suggested by Sergei Shtylyov <sshtylyov@ru.mvista.com>. ]
    
    v3:
    * updated for scc_pata driver (fixes XFER_UDMA_6 filtering for user-space
      originated transfer mode change requests when 100MHz clock is used)
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index c06424fe647b..73f752142f9e 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -477,6 +477,7 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 
 	hwif->tuneproc			= tmp_hwif->tuneproc;
 	hwif->speedproc			= tmp_hwif->speedproc;
+	hwif->udma_filter		= tmp_hwif->udma_filter;
 	hwif->selectproc		= tmp_hwif->selectproc;
 	hwif->reset_poll		= tmp_hwif->reset_poll;
 	hwif->pre_reset			= tmp_hwif->pre_reset;

commit 18137207236285989dfc0ee7f929b954199228f3
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu May 10 00:01:07 2007 +0200

    ide: fix UDMA/MWDMA/SWDMA masks (v3)
    
    * use 0x00 instead of 0x80 to disable ->{ultra,mwdma,swdma}_mask
    * add udma_mask field to ide_pci_device_t and use it to initialize
      ->ultra_mask in aec62xx, cmd64x, pdc202xx_{new,old} and piix drivers
    * fix UDMA masks to match with chipset specific *_ratemask()
      (alim15x3, hpt366, serverworks and siimage drivers need UDMA mask
       filtering method - done in the next patch)
    
    v2:
    * piix: fix cable detection for 82801AA_1 and 82372FB_1
      [ Noticed by Sergei Shtylyov <sshtylyov@ru.mvista.com>. ]
    * cmd64x: use hwif->cds->udma_mask
      [ Suggested by Sergei Shtylyov <sshtylyov@ru.mvista.com>. ]
    * aec62xx: fix newly introduced bug - check DMA status not command register
      [ Noticed by Sergei Shtylyov <sshtylyov@ru.mvista.com>. ]
    
    v3:
    * piix: use hwif->cds->udma_mask
      [ Suggested by Sergei Shtylyov <sshtylyov@ru.mvista.com>. ]
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index ae5bf2be6f52..c06424fe647b 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -216,9 +216,6 @@ static void init_hwif_data(ide_hwif_t *hwif, unsigned int index)
 	hwif->bus_state	= BUSSTATE_ON;
 
 	hwif->atapi_dma = 0;		/* disable all atapi dma */ 
-	hwif->ultra_mask = 0x80;	/* disable all ultra */
-	hwif->mwdma_mask = 0x80;	/* disable all mwdma */
-	hwif->swdma_mask = 0x80;	/* disable all swdma */
 
 	init_completion(&hwif->gendev_rel_comp);
 

commit a7a832de9e9624bcf069a5369c3c38ba2f44d460
Author: Danny Kukawka <dkukawka@suse.de>
Date:   Tue Apr 10 22:39:14 2007 +0200

    ide: add "optical" to sysfs "media" attribute
    
    Add "optical" to sysfs "media" attribute as already in /proc
    
    Signed-off-by: Danny Kukawka <dkukawka@suse.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index a6f098fda884..ae5bf2be6f52 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1962,6 +1962,8 @@ static char *media_string(ide_drive_t *drive)
 		return "tape";
 	case ide_floppy:
 		return "floppy";
+	case ide_optical:
+		return "optical";
 	default:
 		return "UNKNOWN";
 	}

commit 8799620400b0b1a4729d8be828b5bfb3d2a8db1a
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Mar 26 23:03:19 2007 +0200

    ide: fix locking for manual DMA enable/disable ("hdparm -d")
    
    Since hwif->ide_dma_check and hwif->ide_dma_on never queue any commands
    (ide_config_drive_speed() sets transfer mode using polling and has no error
    recovery) we are safe with setting hwgroup->busy for the time while DMA
    setting for a drive is changed (so it won't race against I/O commands in fly).
    
    I audited briefly all ->ide_dma_check/->ide_dma_on/->tuneproc/->speedproc
    implementations and they all look OK wrt to this change.
    
    This patch finally allowed me to close kernel bugzilla bug #8169
    (once again thanks to Patrick Horn for reporting the issue & testing patches).
    
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 695610f0e3e4..a6f098fda884 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1124,17 +1124,40 @@ static int set_io_32bit(ide_drive_t *drive, int arg)
 static int set_using_dma (ide_drive_t *drive, int arg)
 {
 #ifdef CONFIG_BLK_DEV_IDEDMA
+	ide_hwif_t *hwif = drive->hwif;
+	int err = -EPERM;
+
 	if (!drive->id || !(drive->id->capability & 1))
-		return -EPERM;
-	if (HWIF(drive)->ide_dma_check == NULL)
-		return -EPERM;
+		goto out;
+
+	if (hwif->ide_dma_check == NULL)
+		goto out;
+
+	err = -EBUSY;
+	if (ide_spin_wait_hwgroup(drive))
+		goto out;
+	/*
+	 * set ->busy flag, unlock and let it ride
+	 */
+	hwif->hwgroup->busy = 1;
+	spin_unlock_irq(&ide_lock);
+
+	err = 0;
+
 	if (arg) {
-		if (ide_set_dma(drive))
-			return -EIO;
-		if (HWIF(drive)->ide_dma_on(drive)) return -EIO;
+		if (ide_set_dma(drive) || hwif->ide_dma_on(drive))
+			err = -EIO;
 	} else
 		ide_dma_off(drive);
-	return 0;
+
+	/*
+	 * lock, clear ->busy flag and unlock before leaving
+	 */
+	spin_lock_irq(&ide_lock);
+	hwif->hwgroup->busy = 0;
+	spin_unlock_irq(&ide_lock);
+out:
+	return err;
 #else
 	return -EPERM;
 #endif

commit 120b9cfddff2e398fece07c5e127f3fdbb660441
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Mar 17 21:57:41 2007 +0100

    ide: remove CONFIG_IDEDMA_{ICS,PCI}_AUTO config options
    
    All modern distributions have been setting these options to "y" for ages.
    (additionally "n" cases have been obsoleted for few years).  Therefore use
    DMA by default and remove CONFIG_IDEDMA_{ICS,PCI}_AUTO (also remove no longer
    needed CONFIG_IDEDMA_AUTO).  This fixes DMA support for rare configurations
    where CONFIG_IDEDMA_{ICS,PCI}_AUTO was set to "n" but "hdparm -d 1" was used
    to enable DMA support and which were forced to PIO mode by "ide: don't allow
    DMA to be enabled if CONFIG_IDEDMA_{ICS,PCI}_AUTO=n" patch.  There is no
    functionality loss because "ide=nodma" kernel option is still available.
    
    Cc: Patrick Horn <phrh@yahoo.com>
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: Russell King <rmk+lkml@arm.linux.org.uk>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index dfbd74458522..695610f0e3e4 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -177,11 +177,7 @@ DECLARE_MUTEX(ide_cfg_sem);
 static int ide_scan_direction; /* THIS was formerly 2.2.x pci=reverse */
 #endif
 
-#ifdef CONFIG_IDEDMA_AUTO
 int noautodma = 0;
-#else
-int noautodma = 1;
-#endif
 
 EXPORT_SYMBOL(noautodma);
 

commit 849138827c962589ac50496fa7feeb2a2d51b467
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Mar 3 17:48:55 2007 +0100

    ide: make legacy IDE VLB modules check for the "probe" kernel params (v2)
    
    Legacy IDE VLB host drivers didn't check for "probe" options when compiled
    as modules, which was obviously wrong as we don't want module to poke at
    random I/O ports by simply loading it.  Fix it by adding "probe" module param
    to legacy IDE VLB host drivers.
    
    v2:
    * don't obsolete old "ide0=dtc2278/ht6560b/qd65xx/ali14xx/umc8672"
      IDE driver options yet (per Alan Cox's request) and enhance documentation
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index ac1a720f182a..dfbd74458522 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1484,23 +1484,23 @@ static int __init match_parm (char *s, const char *keywords[], int vals[], int m
 }
 
 #ifdef CONFIG_BLK_DEV_ALI14XX
-static int __initdata probe_ali14xx;
+extern int probe_ali14xx;
 extern int ali14xx_init(void);
 #endif
 #ifdef CONFIG_BLK_DEV_UMC8672
-static int __initdata probe_umc8672;
+extern int probe_umc8672;
 extern int umc8672_init(void);
 #endif
 #ifdef CONFIG_BLK_DEV_DTC2278
-static int __initdata probe_dtc2278;
+extern int probe_dtc2278;
 extern int dtc2278_init(void);
 #endif
 #ifdef CONFIG_BLK_DEV_HT6560B
-static int __initdata probe_ht6560b;
+extern int probe_ht6560b;
 extern int ht6560b_init(void);
 #endif
 #ifdef CONFIG_BLK_DEV_QD65XX
-static int __initdata probe_qd65xx;
+extern int probe_qd65xx;
 extern int qd65xx_init(void);
 #endif
 

commit b6209a90eca8c9a464bf9c5b91741fb125185619
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Mar 3 17:48:55 2007 +0100

    ide: remove some obsoleted kernel params (v2)
    
    Remove
    
    * "hdx=serialize"
    * "idex=noautotune"
    * "idex=autotune"
    
    kernel params, they have been obsoleted for ages.
    
    "idex=serialize", "hdx=noautotune" and "hdx=autotune" are still available
    so there is no funcionality loss caused by this patch.
    
    v2:
    
    * fix CONFIG_BLK_DEV_4DRIVES=y build broken by version 1 of the patch
      [ /me wearing brown paper bag ]
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 48a087dfc592..ac1a720f182a 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1578,7 +1578,7 @@ static int __init ide_setup(char *s)
 	 */
 	if (s[0] == 'h' && s[1] == 'd' && s[2] >= 'a' && s[2] <= max_drive) {
 		const char *hd_words[] = {
-			"none", "noprobe", "nowerr", "cdrom", "serialize",
+			"none", "noprobe", "nowerr", "cdrom", "minus5",
 			"autotune", "noautotune", "minus8", "swapdata", "bswap",
 			"noflush", "remap", "remap63", "scsi", NULL };
 		unit = s[2] - 'a';
@@ -1606,9 +1606,6 @@ static int __init ide_setup(char *s)
 				drive->ready_stat = 0;
 				hwif->noprobe = 0;
 				goto done;
-			case -5: /* "serialize" */
-				printk(" -- USE \"ide%d=serialize\" INSTEAD", hw);
-				goto do_serialize;
 			case -6: /* "autotune" */
 				drive->autotune = IDE_TUNE_AUTO;
 				goto obsolete_option;
@@ -1669,7 +1666,7 @@ static int __init ide_setup(char *s)
 		 * (-8, -9, -10) are reserved to ease the hardcoding.
 		 */
 		static const char *ide_words[] = {
-			"noprobe", "serialize", "autotune", "noautotune", 
+			"noprobe", "serialize", "minus3", "minus4",
 			"reset", "dma", "ata66", "minus8", "minus9",
 			"minus10", "four", "qd65xx", "ht6560b", "cmd640_vlb",
 			"dtc2278", "umc8672", "ali14xx", NULL };
@@ -1740,12 +1737,17 @@ static int __init ide_setup(char *s)
 				hwif->chipset = mate->chipset = ide_4drives;
 				mate->irq = hwif->irq;
 				memcpy(mate->io_ports, hwif->io_ports, sizeof(hwif->io_ports));
-				goto do_serialize;
+				hwif->mate = mate;
+				mate->mate = hwif;
+				hwif->serialized = mate->serialized = 1;
+				goto obsolete_option;
 			}
 #endif /* CONFIG_BLK_DEV_4DRIVES */
 			case -10: /* minus10 */
 			case -9: /* minus9 */
 			case -8: /* minus8 */
+			case -4:
+			case -3:
 				goto bad_option;
 			case -7: /* ata66 */
 #ifdef CONFIG_BLK_DEV_IDEPCI
@@ -1760,16 +1762,7 @@ static int __init ide_setup(char *s)
 			case -5: /* "reset" */
 				hwif->reset = 1;
 				goto obsolete_option;
-			case -4: /* "noautotune" */
-				hwif->drives[0].autotune = IDE_TUNE_NOAUTO;
-				hwif->drives[1].autotune = IDE_TUNE_NOAUTO;
-				goto obsolete_option;
-			case -3: /* "autotune" */
-				hwif->drives[0].autotune = IDE_TUNE_AUTO;
-				hwif->drives[1].autotune = IDE_TUNE_AUTO;
-				goto obsolete_option;
 			case -2: /* "serialize" */
-			do_serialize:
 				hwif->mate = &ide_hwifs[hw^1];
 				hwif->mate->mate = hwif;
 				hwif->serialized = hwif->mate->serialized = 1;

commit 846c11abc7934a523a665a3b702358e6f2998e3e
Author: Alan Cox <alan@redhat.com>
Date:   Sat Mar 3 17:48:54 2007 +0100

    ide: remove a ton of pointless #undef REALLY_SLOW_IO
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 25487691c9f1..48a087dfc592 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -126,8 +126,6 @@
 #define	REVISION	"Revision: 7.00alpha2"
 #define	VERSION		"Id: ide.c 7.00a2 20020906"
 
-#undef REALLY_SLOW_IO		/* most systems can safely undef this */
-
 #define _IDE_C			/* Tell ide.h it's really us */
 
 #include <linux/module.h>

commit 9e5755bce00bb563739aeb0f09932a1907521167
Author: Andrew Morton <akpm@osdl.org>
Date:   Sat Mar 3 17:48:54 2007 +0100

    ide: fix pmac breakage
    
    Fix breakage added in the IDE devel tree.
    
    Add header, then fix
    
    drivers/ide/ppc/pmac.c: In function `pmac_ide_setup_dma':
    drivers/ide/ppc/pmac.c:2044: warning: assignment from incompatible pointer type
    drivers/ide/ppc/pmac.c: In function `pmac_ide_dma_host_on':
    drivers/ide/ppc/pmac.c:1989: warning: control reaches end of non-void function
    include/linux/pci.h: In function `pmac_ide_init':
    drivers/ide/ppc/pmac.c:1563: warning: ignoring return value of `pci_register_driver', declared with attribute warn_unused_result
    
    Then add some apparently-long-missing error handling.
    
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index b3c0818c5c6c..25487691c9f1 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1840,8 +1840,8 @@ static void __init probe_for_hwifs (void)
 #endif /* CONFIG_BLK_DEV_CMD640 */
 #ifdef CONFIG_BLK_DEV_IDE_PMAC
 	{
-		extern void pmac_ide_probe(void);
-		pmac_ide_probe();
+		extern int pmac_ide_probe(void);
+		(void)pmac_ide_probe();
 	}
 #endif /* CONFIG_BLK_DEV_IDE_PMAC */
 #ifdef CONFIG_BLK_DEV_GAYLE

commit ccf352894ceef79d40d015e1deee4c46c3aa42ed
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Feb 17 02:40:26 2007 +0100

    ide: make ide_hwif_t.ide_dma_host_on void (v2)
    
    * since ide_hwif_t.ide_dma_host_on is called either when drive->using_dma == 1
      or when return value is discarded make it void, also drop "ide_" prefix
    * make __ide_dma_host_on() void and drop "__" prefix
    
    v2:
    * while at it rename atiixp_ide_dma_host_on() to atiixp_dma_host_on()
      and sgiioc4_ide_dma_host_on() to sgiioc4_dma_host_on().
      [ Noticed by Sergei Shtylyov <sshtylyov@ru.mvista.com>. ]
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 6e146b54257d..b3c0818c5c6c 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -509,7 +509,7 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 	hwif->dma_off_quietly		= tmp_hwif->dma_off_quietly;
 	hwif->ide_dma_test_irq		= tmp_hwif->ide_dma_test_irq;
 	hwif->ide_dma_clear_irq		= tmp_hwif->ide_dma_clear_irq;
-	hwif->ide_dma_host_on		= tmp_hwif->ide_dma_host_on;
+	hwif->dma_host_on		= tmp_hwif->dma_host_on;
 	hwif->dma_host_off		= tmp_hwif->dma_host_off;
 	hwif->ide_dma_lostirq		= tmp_hwif->ide_dma_lostirq;
 	hwif->ide_dma_timeout		= tmp_hwif->ide_dma_timeout;

commit 7469aaf6a30f4187ed6de7c0aed5c2dd2d1c2d31
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Feb 17 02:40:26 2007 +0100

    ide: make ide_hwif_t.ide_dma_{host_off,off_quietly} void (v2)
    
    * since ide_hwif_t.ide_dma_{host_off,off_quietly} always return '0'
      make these functions void and while at it drop "ide_" prefix
    * fix comment for __ide_dma_off_quietly()
    * make __ide_dma_{host_off,off_quietly,off}() void and drop "__" prefix
    
    v2:
    * while at it rename atiixp_ide_dma_host_off() to atiixp_dma_host_off(),
      sgiioc4_ide_dma_{host_off,off_quietly}() to sgiioc4_dma_{host_off,off_quietly}()
      and sl82c105_ide_dma_off_quietly() to sl82c105_dma_off_quietly()
      [ Noticed by Sergei Shtylyov <sshtylyov@ru.mvista.com>. ]
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 5585c01a9b7f..6e146b54257d 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -506,11 +506,11 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 	hwif->ide_dma_end		= tmp_hwif->ide_dma_end;
 	hwif->ide_dma_check		= tmp_hwif->ide_dma_check;
 	hwif->ide_dma_on		= tmp_hwif->ide_dma_on;
-	hwif->ide_dma_off_quietly	= tmp_hwif->ide_dma_off_quietly;
+	hwif->dma_off_quietly		= tmp_hwif->dma_off_quietly;
 	hwif->ide_dma_test_irq		= tmp_hwif->ide_dma_test_irq;
 	hwif->ide_dma_clear_irq		= tmp_hwif->ide_dma_clear_irq;
 	hwif->ide_dma_host_on		= tmp_hwif->ide_dma_host_on;
-	hwif->ide_dma_host_off		= tmp_hwif->ide_dma_host_off;
+	hwif->dma_host_off		= tmp_hwif->dma_host_off;
 	hwif->ide_dma_lostirq		= tmp_hwif->ide_dma_lostirq;
 	hwif->ide_dma_timeout		= tmp_hwif->ide_dma_timeout;
 
@@ -1138,10 +1138,8 @@ static int set_using_dma (ide_drive_t *drive, int arg)
 		if (ide_set_dma(drive))
 			return -EIO;
 		if (HWIF(drive)->ide_dma_on(drive)) return -EIO;
-	} else {
-		if (__ide_dma_off(drive))
-			return -EIO;
-	}
+	} else
+		ide_dma_off(drive);
 	return 0;
 #else
 	return -EPERM;

commit 3608b5d71a52c053787dbad6af20c25f7e0b75a9
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Feb 17 02:40:26 2007 +0100

    ide: add ide_set_dma() helper (v2)
    
    * add ide_set_dma() helper and make ide_hwif_t.ide_dma_check return
      -1 when DMA needs to be disabled (== need to call ->ide_dma_off_quietly)
       0 when DMA needs to be enabled  (== need to call ->ide_dma_on)
       1 when DMA setting shouldn't be changed
    * fix IDE code to use ide_set_dma() instead if using ->ide_dma_check directly
    
    v2:
    * updated for scc_pata
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index fbc6d39ace68..5585c01a9b7f 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1135,7 +1135,8 @@ static int set_using_dma (ide_drive_t *drive, int arg)
 	if (HWIF(drive)->ide_dma_check == NULL)
 		return -EPERM;
 	if (arg) {
-		if (HWIF(drive)->ide_dma_check(drive)) return -EIO;
+		if (ide_set_dma(drive))
+			return -EIO;
 		if (HWIF(drive)->ide_dma_on(drive)) return -EIO;
 	} else {
 		if (__ide_dma_off(drive))

commit 2ad1e558a2305c2b3d5099ee2f4a5929307c20ca
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Feb 17 02:40:25 2007 +0100

    ide: convert ide_hwif_t.mmio into flag (v2)
    
    All users of ->mmio == 1 are gone so convert ->mmio into flag.
    
    Noticed by Alan Cox.
    
    v2:
    * updated for scc_pata
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 92ab39d5bc25..fbc6d39ace68 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -389,9 +389,8 @@ int ide_hwif_request_regions(ide_hwif_t *hwif)
 	unsigned long addr;
 	unsigned int i;
 
-	if (hwif->mmio == 2)
+	if (hwif->mmio)
 		return 0;
-	BUG_ON(hwif->mmio == 1);
 	addr = hwif->io_ports[IDE_CONTROL_OFFSET];
 	if (addr && !hwif_request_region(hwif, addr, 1))
 		goto control_region_busy;
@@ -438,7 +437,7 @@ void ide_hwif_release_regions(ide_hwif_t *hwif)
 {
 	u32 i = 0;
 
-	if (hwif->mmio == 2)
+	if (hwif->mmio)
 		return;
 	if (hwif->io_ports[IDE_CONTROL_OFFSET])
 		release_region(hwif->io_ports[IDE_CONTROL_OFFSET], 1);

commit 0ecdca26e556eae9668ce6de9554757dddb942ef
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Feb 17 02:40:25 2007 +0100

    ide: use PIO/MMIO operations directly where possible (v2)
    
    This results in smaller/faster/simpler code and allows future optimizations.
    Also remove no longer needed ide[_mm]_{inl,outl}() and ide_hwif_t.{INL,OUTL}.
    
    v2:
    * updated for scc_pata
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 15b13831ee14..92ab39d5bc25 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -518,13 +518,11 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 	hwif->OUTB			= tmp_hwif->OUTB;
 	hwif->OUTBSYNC			= tmp_hwif->OUTBSYNC;
 	hwif->OUTW			= tmp_hwif->OUTW;
-	hwif->OUTL			= tmp_hwif->OUTL;
 	hwif->OUTSW			= tmp_hwif->OUTSW;
 	hwif->OUTSL			= tmp_hwif->OUTSL;
 
 	hwif->INB			= tmp_hwif->INB;
 	hwif->INW			= tmp_hwif->INW;
-	hwif->INL			= tmp_hwif->INL;
 	hwif->INSW			= tmp_hwif->INSW;
 	hwif->INSL			= tmp_hwif->INSL;
 

commit c1607e1af238b823a2158a18ff6c89144ce38c6c
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Sat Feb 17 02:40:24 2007 +0100

    ide: remove write-only ide_hwif_t.no_dsc flag
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 65eb095469b5..15b13831ee14 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -552,7 +552,6 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 	hwif->extra_ports		= tmp_hwif->extra_ports;
 	hwif->autodma			= tmp_hwif->autodma;
 	hwif->udma_four			= tmp_hwif->udma_four;
-	hwif->no_dsc			= tmp_hwif->no_dsc;
 
 	hwif->hwif_data			= tmp_hwif->hwif_data;
 }

commit f0dd8712eb8cc5687b4582fbc41cfbcd55bba0d2
Author: Albert Lee <albertcc@tw.ibm.com>
Date:   Sat Feb 17 02:40:21 2007 +0100

    ide: clear bmdma status in ide_intr() for ICHx controllers (revised #4)
    
    patch 1/2 (revised):
    - Fix drive->waiting_for_dma to work with CDB-intr devices.
    - Do the dma status clearing in ide_intr() and add a new
      hwif->ide_dma_clear_irq for Intel ICHx controllers.
    
    Revised per Alan, Sergei and Bart's advice.
    
    Patch against 2.6.20-rc6. Tested ok on my ICH4 and pdc20275 adapters.
    Please review/apply, thanks.
    
    Signed-off-by: Albert Lee <albertcc@tw.ibm.com>
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: "Adam W. Hawks" <awhawks@us.ibm.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index c750f6ce770a..65eb095469b5 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -509,6 +509,7 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 	hwif->ide_dma_on		= tmp_hwif->ide_dma_on;
 	hwif->ide_dma_off_quietly	= tmp_hwif->ide_dma_off_quietly;
 	hwif->ide_dma_test_irq		= tmp_hwif->ide_dma_test_irq;
+	hwif->ide_dma_clear_irq		= tmp_hwif->ide_dma_clear_irq;
 	hwif->ide_dma_host_on		= tmp_hwif->ide_dma_host_on;
 	hwif->ide_dma_host_off		= tmp_hwif->ide_dma_host_off;
 	hwif->ide_dma_lostirq		= tmp_hwif->ide_dma_lostirq;

commit e3a59b4d9378522479609042836ae930305a67fe
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Feb 7 18:19:37 2007 +0100

    ACPI support for IDE devices
    
    This patch implements ACPI integration for generic IDE devices.
    The ACPI spec mandates that some methods are called during suspend and
    resume. And consequently there most modern Laptops cannot resume
    properly without it.
    
    According to the spec, we should call '_GTM' (Get Timing) upon suspend
    to store the current IDE adapter settings.
    Upon resume we should call '_STM' (Set Timing) to initialize the
    adapter with the stored settings; afterwards '_GTF' (Get Taskfile)
    should be called which returns a buffer with some IDE initialisation
    commands. Those commands should be passed to the drive.
    
    There are two module params which control the behaviour of this patch:
    
    'ide=noacpi'
            Do not call any ACPI methods (Disables any ACPI method calls)
    'ide=acpigtf'
            Enable execution of _GTF methods upon resume.
            Has no effect if 'ide=noacpi' is set.
    'ide=acpionboot'
            Enable execution of ACPI methods during boot.
            This might be required on some machines if 'ide=acpigtf' is
            selected as some machines modify the _GTF information
            depending on the drive identification passed down with _STM.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 6c9bd5165bdb..c750f6ce770a 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -187,6 +187,12 @@ int noautodma = 1;
 
 EXPORT_SYMBOL(noautodma);
 
+#ifdef CONFIG_BLK_DEV_IDEACPI
+int ide_noacpi = 0;
+int ide_noacpitfs = 1;
+int ide_noacpionboot = 1;
+#endif
+
 /*
  * This is declared extern in ide.h, for access by other IDE modules:
  */
@@ -1214,10 +1220,15 @@ EXPORT_SYMBOL(system_bus_clock);
 static int generic_ide_suspend(struct device *dev, pm_message_t mesg)
 {
 	ide_drive_t *drive = dev->driver_data;
+	ide_hwif_t *hwif = HWIF(drive);
 	struct request rq;
 	struct request_pm_state rqpm;
 	ide_task_t args;
 
+	/* Call ACPI _GTM only once */
+	if (!(drive->dn % 2))
+		ide_acpi_get_timing(hwif);
+
 	memset(&rq, 0, sizeof(rq));
 	memset(&rqpm, 0, sizeof(rqpm));
 	memset(&args, 0, sizeof(args));
@@ -1235,10 +1246,17 @@ static int generic_ide_suspend(struct device *dev, pm_message_t mesg)
 static int generic_ide_resume(struct device *dev)
 {
 	ide_drive_t *drive = dev->driver_data;
+	ide_hwif_t *hwif = HWIF(drive);
 	struct request rq;
 	struct request_pm_state rqpm;
 	ide_task_t args;
 
+	/* Call ACPI _STM only once */
+	if (!(drive->dn % 2))
+		ide_acpi_push_timing(hwif);
+
+	ide_acpi_exec_tfs(drive);
+
 	memset(&rq, 0, sizeof(rq));
 	memset(&rqpm, 0, sizeof(rqpm));
 	memset(&args, 0, sizeof(args));
@@ -1543,6 +1561,24 @@ static int __init ide_setup(char *s)
 	}
 #endif /* CONFIG_BLK_DEV_IDEPCI */
 
+#ifdef CONFIG_BLK_DEV_IDEACPI
+	if (!strcmp(s, "ide=noacpi")) {
+		//printk(" : Disable IDE ACPI support.\n");
+		ide_noacpi = 1;
+		return 1;
+	}
+	if (!strcmp(s, "ide=acpigtf")) {
+		//printk(" : Enable IDE ACPI _GTF support.\n");
+		ide_noacpitfs = 0;
+		return 1;
+	}
+	if (!strcmp(s, "ide=acpionboot")) {
+		//printk(" : Call IDE ACPI methods on boot.\n");
+		ide_noacpionboot = 0;
+		return 1;
+	}
+#endif /* CONFIG_BLK_DEV_IDEACPI */
+
 	/*
 	 * Look for drive options:  "hdx="
 	 */

commit eb7972271720bfc64dc8bacc5b15f874c0bcc859
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Feb 1 13:52:38 2007 +0000

    [PATCH] ide section fixes
    
    a) cleanup_module() should be __exit
    b) externs should match reality
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 3b334af0c7b9..6c9bd5165bdb 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1781,9 +1781,9 @@ static int __init ide_setup(char *s)
 	return 1;
 }
 
-extern void pnpide_init(void);
-extern void pnpide_exit(void);
-extern void h8300_ide_init(void);
+extern void __init pnpide_init(void);
+extern void __exit pnpide_exit(void);
+extern void __init h8300_ide_init(void);
 
 /*
  * probe_for_hwifs() finds/initializes "known" IDE interfaces
@@ -2088,7 +2088,7 @@ int __init init_module (void)
 	return ide_init();
 }
 
-void cleanup_module (void)
+void __exit cleanup_module (void)
 {
 	int index;
 

commit 6855036aa035913bc2bfb31c41576a49f42ecd5f
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Jan 27 13:47:02 2007 +0100

    ide: unregister idepnp driver on unload
    
    idepnp driver is registered as a pnp driver on ide init but doesn't
    get unregistered on ide unload causing driver list corruption and
    eventually oops.  Fix it.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 16890769dca6..3b334af0c7b9 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1782,6 +1782,7 @@ static int __init ide_setup(char *s)
 }
 
 extern void pnpide_init(void);
+extern void pnpide_exit(void);
 extern void h8300_ide_init(void);
 
 /*
@@ -2094,6 +2095,10 @@ void cleanup_module (void)
 	for (index = 0; index < MAX_HWIFS; ++index)
 		ide_unregister(index);
 
+#ifdef CONFIG_BLK_DEV_IDEPNP
+	pnpide_exit();
+#endif
+
 #ifdef CONFIG_PROC_FS
 	proc_ide_destroy();
 #endif

commit 9a2239b1174bdf0952a21ed328cd74240d2dd173
Author: Peter Zijlstra <a.p.zijlstra@chello.nl>
Date:   Wed Dec 6 20:36:13 2006 -0800

    [PATCH] lockdep: fix ide/proc interaction
    
      rmmod/3080 [HC0[0]:SC0[0]:HE0:SE1] is trying to acquire:
       (proc_subdir_lock){--..}, at: [<c04a33b0>] remove_proc_entry+0x40/0x191
    
      and this task is already holding:
       (ide_lock){++..}, at: [<c05651a2>] ide_unregister_subdriver+0x39/0xc8
      which would create a new lock dependency:
       (ide_lock){++..} -> (proc_subdir_lock){--..}
    
      but this new dependency connects a hard-irq-safe lock:
       (ide_lock){++..}
      ... which became hard-irq-safe at:
        [<c043c458>] lock_acquire+0x4b/0x6b
        [<c06129d7>] _spin_lock_irqsave+0x22/0x32
        [<c0567870>] ide_intr+0x17/0x1a9
        [<c044eb31>] handle_IRQ_event+0x20/0x4d
        [<c044ebf2>] __do_IRQ+0x94/0xef
        [<c0406771>] do_IRQ+0x9e/0xbd
    
      to a hard-irq-unsafe lock:
       (proc_subdir_lock){--..}
      ... which became hard-irq-unsafe at:
      ...  [<c043c458>] lock_acquire+0x4b/0x6b
        [<c06126ab>] _spin_lock+0x19/0x28
        [<c04a32f2>] xlate_proc_name+0x1b/0x99
        [<c04a3547>] proc_create+0x46/0xdf
        [<c04a3642>] create_proc_entry+0x62/0xa5
        [<c07c1972>] proc_misc_init+0x1c/0x1d2
        [<c07c1844>] proc_root_init+0x4c/0xe9
        [<c07ad703>] start_kernel+0x294/0x3b3
    
    Move ide_remove_proc_entries() out from under ide_lock; there is nothing
    that indicates that this is needed.
    
    In specific, the call to ide_add_proc_entries() is unprotected, and there
    is nothing else in the file using the respective ->proc fields. Also the
    lock order around destroy_proc_ide_interface() suggests this.
    
    Alan sayeth:
    
      proc_ide_write_settings walks the setting list under ide_setting_sem, read
      ditto.  remove_proc_entry is doing proc side housekeeping.
    
      Looks fine to me, although that old code is such a mess anything could be
      going on.
    
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 287a66201150..16890769dca6 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -973,8 +973,8 @@ ide_settings_t *ide_find_setting_by_name (ide_drive_t *drive, char *name)
  *	@drive: drive
  *
  *	Automatically remove all the driver specific settings for this
- *	drive. This function may sleep and must not be called from IRQ
- *	context. The caller must hold ide_setting_sem.
+ *	drive. This function may not be called from IRQ context. The
+ *	caller must hold ide_setting_sem.
  */
  
 static void auto_remove_settings (ide_drive_t *drive)
@@ -1874,11 +1874,22 @@ void ide_unregister_subdriver(ide_drive_t *drive, ide_driver_t *driver)
 {
 	unsigned long flags;
 	
-	down(&ide_setting_sem);
-	spin_lock_irqsave(&ide_lock, flags);
 #ifdef CONFIG_PROC_FS
 	ide_remove_proc_entries(drive->proc, driver->proc);
 #endif
+	down(&ide_setting_sem);
+	spin_lock_irqsave(&ide_lock, flags);
+	/*
+	 * ide_setting_sem protects the settings list
+	 * ide_lock protects the use of settings
+	 *
+	 * so we need to hold both, ide_settings_sem because we want to
+	 * modify the settings list, and ide_lock because we cannot take
+	 * a setting out that is being used.
+	 *
+	 * OTOH both ide_{read,write}_setting are only ever used under
+	 * ide_setting_sem.
+	 */
 	auto_remove_settings(drive);
 	spin_unlock_irqrestore(&ide_lock, flags);
 	up(&ide_setting_sem);

commit 913759ac90a727b86da72efcfb70931f497d1cb7
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Tue Oct 3 01:14:33 2006 -0700

    [PATCH] ide: Fix crash on repeated reset
    
    Michal Miroslaw reported a problem (bugzilla #7023) where a user initiated
    reset while the IDE layer was already resetting the channel caused a crash,
    and provided a rough fix.
    
    This is a slightly cleaner version of the fix which tracks the reset state
    and blocks further reset requests while a reset is in progress.
    
    Note this is not a security issue - random end users can't access the
    ioctl in question anyway.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Cc: Michal Miroslaw <mirq-linux@rere.qmqm.pl>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 97b162ca9885..287a66201150 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1364,6 +1364,11 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 
 			spin_lock_irqsave(&ide_lock, flags);
 
+			if (HWGROUP(drive)->resetting) {
+				spin_unlock_irqrestore(&ide_lock, flags);
+				return -EBUSY;
+			}
+
 			ide_abort(drive, "drive reset");
 
 			BUG_ON(HWGROUP(drive)->handler);

commit 349ae23fe7379a42973bcb1c85f7d43ec583c17d
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Tue Oct 3 01:14:23 2006 -0700

    [PATCH] IDE core: driver layer error checking
    
    Check driver layer return values in IDE core.
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 8c3f06242280..97b162ca9885 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1997,10 +1997,16 @@ EXPORT_SYMBOL_GPL(ide_bus_type);
  */
 static int __init ide_init(void)
 {
+	int ret;
+
 	printk(KERN_INFO "Uniform Multi-Platform E-IDE driver " REVISION "\n");
 	system_bus_speed = ide_system_bus_speed();
 
-	bus_register(&ide_bus_type);
+	ret = bus_register(&ide_bus_type);
+	if (ret < 0) {
+		printk(KERN_WARNING "IDE: bus_register error: %d\n", ret);
+		return ret;
+	}
 
 	init_ide_data();
 

commit 020e322de3ff75d32daa58e431aad07071da27c6
Author: Sergei Shtylylov <sshtylyov@ru.mvista.com>
Date:   Tue Oct 3 01:14:13 2006 -0700

    [PATCH] IDE: claim extra DMA ports regardless of channel
    
    - Claim extra DMA I/O ports regardless of what IDE channels are
      present/enabled.
    
    - Remove extra ports handling from ide_mapped_mmio_dma() since it's not
      applicable to the custom-mapping IDE drivers.
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: Bartlomiej Zolnierkiewicz <B.Zolnierkiewicz@elka.pw.edu.pl>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 2b1a1389c318..8c3f06242280 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -450,7 +450,7 @@ void ide_hwif_release_regions(ide_hwif_t *hwif)
  *	@hwif: hwif to update
  *	@tmp_hwif: template
  *
- *	Restore hwif to a previous state by copying most settngs
+ *	Restore hwif to a previous state by copying most settings
  *	from the template.
  */
 
@@ -539,9 +539,10 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 	hwif->dma_vendor3		= tmp_hwif->dma_vendor3;
 	hwif->dma_prdtable		= tmp_hwif->dma_prdtable;
 
-	hwif->dma_extra			= tmp_hwif->dma_extra;
 	hwif->config_data		= tmp_hwif->config_data;
 	hwif->select_data		= tmp_hwif->select_data;
+	hwif->extra_base		= tmp_hwif->extra_base;
+	hwif->extra_ports		= tmp_hwif->extra_ports;
 	hwif->autodma			= tmp_hwif->autodma;
 	hwif->udma_four			= tmp_hwif->udma_four;
 	hwif->no_dsc			= tmp_hwif->no_dsc;
@@ -550,7 +551,7 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
 }
 
 /**
- *	ide_unregister		-	free an ide interface
+ *	ide_unregister		-	free an IDE interface
  *	@index: index of interface (will change soon to a pointer)
  *
  *	Perform the final unregister of an IDE interface. At the moment
@@ -563,8 +564,8 @@ static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
  *	deadlocking the IDE layer. The shutdown callback is called
  *	before we take the lock and free resources. It is up to the
  *	caller to be sure there is no pending I/O here, and that
- *	the interfce will not be reopened (present/vanishing locking
- *	isnt yet done btw). After we commit to the final kill we
+ *	the interface will not be reopened (present/vanishing locking
+ *	isn't yet done BTW). After we commit to the final kill we
  *	call the cleanup callback with the ide locks held.
  *
  *	Unregister restores the hwif structures to the default state.
@@ -674,6 +675,9 @@ void ide_unregister(unsigned int index)
 		hwif->dma_status = 0;
 		hwif->dma_vendor3 = 0;
 		hwif->dma_prdtable = 0;
+
+		hwif->extra_base  = 0;
+		hwif->extra_ports = 0;
 	}
 
 	/* copy original settings */

commit c00895ab2f08df7044e58ee01c38bf0a661ea0eb
Author: Jens Axboe <axboe@kernel.dk>
Date:   Sat Sep 30 20:29:12 2006 +0200

    [PATCH] Remove ->waiting member from struct request
    
    As the comments indicates in blkdev.h, we can fold it into ->end_io_data
    usage as that is really what ->waiting is. Fixup the users of
    blk_end_sync_rq().
    
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 9384a3fdde6c..2b1a1389c318 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1219,7 +1219,7 @@ static int generic_ide_suspend(struct device *dev, pm_message_t mesg)
 	memset(&args, 0, sizeof(args));
 	rq.cmd_type = REQ_TYPE_PM_SUSPEND;
 	rq.special = &args;
-	rq.end_io_data = &rqpm;
+	rq.data = &rqpm;
 	rqpm.pm_step = ide_pm_state_start_suspend;
 	if (mesg.event == PM_EVENT_PRETHAW)
 		mesg.event = PM_EVENT_FREEZE;
@@ -1240,7 +1240,7 @@ static int generic_ide_resume(struct device *dev)
 	memset(&args, 0, sizeof(args));
 	rq.cmd_type = REQ_TYPE_PM_RESUME;
 	rq.special = &args;
-	rq.end_io_data = &rqpm;
+	rq.data = &rqpm;
 	rqpm.pm_step = ide_pm_state_start_resume;
 	rqpm.pm_state = PM_EVENT_ON;
 

commit 4aff5e2333c9a1609662f2091f55c3f6fffdad36
Author: Jens Axboe <axboe@suse.de>
Date:   Thu Aug 10 08:44:47 2006 +0200

    [PATCH] Split struct request ->flags into two parts
    
    Right now ->flags is a bit of a mess: some are request types, and
    others are just modifiers. Clean this up by splitting it into
    ->cmd_type and ->cmd_flags. This allows introduction of generic
    Linux block message types, useful for sending generic Linux commands
    to block devices.
    
    Signed-off-by: Jens Axboe <axboe@suse.de>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 9c8468de1a75..9384a3fdde6c 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1217,7 +1217,7 @@ static int generic_ide_suspend(struct device *dev, pm_message_t mesg)
 	memset(&rq, 0, sizeof(rq));
 	memset(&rqpm, 0, sizeof(rqpm));
 	memset(&args, 0, sizeof(args));
-	rq.flags = REQ_PM_SUSPEND;
+	rq.cmd_type = REQ_TYPE_PM_SUSPEND;
 	rq.special = &args;
 	rq.end_io_data = &rqpm;
 	rqpm.pm_step = ide_pm_state_start_suspend;
@@ -1238,7 +1238,7 @@ static int generic_ide_resume(struct device *dev)
 	memset(&rq, 0, sizeof(rq));
 	memset(&rqpm, 0, sizeof(rqpm));
 	memset(&args, 0, sizeof(args));
-	rq.flags = REQ_PM_RESUME;
+	rq.cmd_type = REQ_TYPE_PM_RESUME;
 	rq.special = &args;
 	rq.end_io_data = &rqpm;
 	rqpm.pm_step = ide_pm_state_start_resume;

commit b887d2e63c8857149ef59eb6e05adfaa018b8ebf
Author: David Brownell <david-b@pacbell.net>
Date:   Mon Aug 14 23:11:05 2006 -0700

    PM: PCI and IDE handle PM_EVENT_PRETHAW
    
    Convert some framework code to handle the new PRETHAW message.
    
      - IDE just treats it like a FREEZE.
    
      - The pci_choose_state() thingie still doesn't use PCI_D0 when it gets a
        FREEZE (and now PRETHAW) event, which seems rather buglike but wasn't
        something to change with this patch.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index defd4b4bd374..9c8468de1a75 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1207,7 +1207,7 @@ int system_bus_clock (void)
 
 EXPORT_SYMBOL(system_bus_clock);
 
-static int generic_ide_suspend(struct device *dev, pm_message_t state)
+static int generic_ide_suspend(struct device *dev, pm_message_t mesg)
 {
 	ide_drive_t *drive = dev->driver_data;
 	struct request rq;
@@ -1221,7 +1221,9 @@ static int generic_ide_suspend(struct device *dev, pm_message_t state)
 	rq.special = &args;
 	rq.end_io_data = &rqpm;
 	rqpm.pm_step = ide_pm_state_start_suspend;
-	rqpm.pm_state = state.event;
+	if (mesg.event == PM_EVENT_PRETHAW)
+		mesg.event = PM_EVENT_FREEZE;
+	rqpm.pm_state = mesg.event;
 
 	return ide_do_drive_cmd(drive, &rq, ide_wait);
 }

commit 361934849e9c0418950bedf667732f36337d88b9
Author: Jens Axboe <axboe@suse.de>
Date:   Fri Jul 28 08:54:59 2006 +0200

    [PATCH] ide: option to disable cache flushes for buggy drives
    
    Some drives claim they support cache flushing, but get seriously
    confused if you try. Add this option to be able to boot with
    barriers enabled by default.
    
    Signed-off-by: Jens Axboe <axboe@suse.de>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 05fbd9298db7..defd4b4bd374 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1539,7 +1539,7 @@ static int __init ide_setup(char *s)
 		const char *hd_words[] = {
 			"none", "noprobe", "nowerr", "cdrom", "serialize",
 			"autotune", "noautotune", "minus8", "swapdata", "bswap",
-			"minus11", "remap", "remap63", "scsi", NULL };
+			"noflush", "remap", "remap63", "scsi", NULL };
 		unit = s[2] - 'a';
 		hw   = unit / MAX_DRIVES;
 		unit = unit % MAX_DRIVES;
@@ -1578,6 +1578,9 @@ static int __init ide_setup(char *s)
 			case -10: /* "bswap" */
 				drive->bswap = 1;
 				goto done;
+			case -11: /* noflush */
+				drive->noflush = 1;
+				goto done;
 			case -12: /* "remap" */
 				drive->remap_0_to_1 = 1;
 				goto done;

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jrn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jrn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 1cdf44205162..05fbd9298db7 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -130,7 +130,6 @@
 
 #define _IDE_C			/* Tell ide.h it's really us */
 
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/types.h>
 #include <linux/string.h>

commit 94f6c59dcf16f10a20fbe3d1f098b159433f94bd
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] devfs: Remove devfs support from the ide subsystem.
    
    Also removes the ide drive devfs_name field as it's no longer needed
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 59fe358048b3..1cdf44205162 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -147,7 +147,6 @@
 #include <linux/pci.h>
 #include <linux/delay.h>
 #include <linux/ide.h>
-#include <linux/devfs_fs_kernel.h>
 #include <linux/completion.h>
 #include <linux/reboot.h>
 #include <linux/cdrom.h>
@@ -592,13 +591,8 @@ void ide_unregister(unsigned int index)
 		goto abort;
 	for (unit = 0; unit < MAX_DRIVES; ++unit) {
 		drive = &hwif->drives[unit];
-		if (!drive->present) {
-			if (drive->devfs_name[0] != '\0') {
-				devfs_remove(drive->devfs_name);
-				drive->devfs_name[0] = '\0';
-			}
+		if (!drive->present)
 			continue;
-		}
 		spin_unlock_irq(&ide_lock);
 		device_unregister(&drive->gendev);
 		wait_for_completion(&drive->gendev_rel_comp);
@@ -1996,7 +1990,6 @@ EXPORT_SYMBOL_GPL(ide_bus_type);
 static int __init ide_init(void)
 {
 	printk(KERN_INFO "Uniform Multi-Platform E-IDE driver " REVISION "\n");
-	devfs_mk_dir("ide");
 	system_bus_speed = ide_system_bus_speed();
 
 	bus_register(&ide_bus_type);
@@ -2074,7 +2067,6 @@ void cleanup_module (void)
 #ifdef CONFIG_PROC_FS
 	proc_ide_destroy();
 #endif
-	devfs_remove("ide");
 
 	bus_unregister(&ide_bus_type);
 }

commit ad3caddaa1708e506f20b8e25a4a8ae586fc7d5b
Author: Jens Axboe <axboe@suse.de>
Date:   Tue Jun 13 08:46:57 2006 +0200

    [PATCH] Get rid of struct request request_pm_state member
    
    The IDE power management can just use the ->end_io_data member to store
    it's data.
    
    Signed-off-by: Jens Axboe <axboe@suse.de>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 9799aed772e1..59fe358048b3 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1226,7 +1226,7 @@ static int generic_ide_suspend(struct device *dev, pm_message_t state)
 	memset(&args, 0, sizeof(args));
 	rq.flags = REQ_PM_SUSPEND;
 	rq.special = &args;
-	rq.pm = &rqpm;
+	rq.end_io_data = &rqpm;
 	rqpm.pm_step = ide_pm_state_start_suspend;
 	rqpm.pm_state = state.event;
 
@@ -1245,7 +1245,7 @@ static int generic_ide_resume(struct device *dev)
 	memset(&args, 0, sizeof(args));
 	rq.flags = REQ_PM_RESUME;
 	rq.special = &args;
-	rq.pm = &rqpm;
+	rq.end_io_data = &rqpm;
 	rqpm.pm_step = ide_pm_state_start_resume;
 	rqpm.pm_state = PM_EVENT_ON;
 

commit 125e18745f16685f69a34fd6130d47598fc4bf54
Author: Eric Sesterhenn <snakebyte@gmx.de>
Date:   Fri Jun 23 02:06:06 2006 -0700

    [PATCH] More BUG_ON conversion
    
    Signed-off-by: Eric Sesterhenn <snakebyte@gmx.de>
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Bartlomiej Zolnierkiewicz <B.Zolnierkiewicz@elka.pw.edu.pl>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Acked-by: "Salyzyn, Mark" <mark_salyzyn@adaptec.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index f5a60912c271..9799aed772e1 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1367,8 +1367,7 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 
 			ide_abort(drive, "drive reset");
 
-			if(HWGROUP(drive)->handler)
-				BUG();
+			BUG_ON(HWGROUP(drive)->handler);
 				
 			/* Ensure nothing gets queued after we
 			   drop the lock. Reset will clear the busy */

commit 2c3e0262e0cb5395fe02cdf27c229ee7414ab0c0
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Fri Jun 23 02:04:51 2006 -0700

    [PATCH] m68k: completely initialize hw_regs_t in ide_setup_ports
    
    ide_setup_ports does not completely initialize the hw_regs_t structure which
    can cause random failures, as the structure is often on the stack.  None of
    the callers expect a partially initialized structure, i.e.  none of them do
    any setup of their own before calling ide_setup_ports().
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: Bartlomiej Zolnierkiewicz <B.Zolnierkiewicz@elka.pw.edu.pl>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 3fdab563fec2..f5a60912c271 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -726,6 +726,7 @@ void ide_setup_ports (	hw_regs_t *hw,
 {
 	int i;
 
+	memset(hw, 0, sizeof(hw_regs_t));
 	for (i = 0; i < IDE_NR_PORTS; i++) {
 		if (offsets[i] == -1) {
 			switch(i) {

commit fbd8ad30596409070801832335d3ea8cf1513ded
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Mar 25 03:07:11 2006 -0800

    [PATCH] ide: fix section mismatch warning
    
    In latest -mm ide-code.o gave a number of warnings like the following:
    
    WARNING: drivers/ide/ide-core.o - Section mismatch: reference to    \
    .init.text: from .text between 'init_module' (at offset 0x1f97) and \
    'cleanup_module'
    
    The warning was caused by init_module() calling parse_option() and
    ide_init() both declared __init.
    
    Declaring init_module() __init fixes the warnings.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Bartlomiej Zolnierkiewicz <B.Zolnierkiewicz@elka.pw.edu.pl>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index b2cc43702f65..3fdab563fec2 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -2058,7 +2058,7 @@ static void __init parse_options (char *line)
 	}
 }
 
-int init_module (void)
+int __init init_module (void)
 {
 	parse_options(options);
 	return ide_init();

commit 9810933701a09f9c4dd0ad963d5ec2efb7df07b7
Author: Richard Purdie <rpurdie@rpsys.net>
Date:   Fri Feb 3 03:04:55 2006 -0800

    [PATCH] stop CompactFlash devices being marked as removable
    
    This patch stops CompactFlash devices being marked as removable.  They are
    not removable (as defined by Linux) as the media and device are
    inseparable.  When a card is removed, the whole device is removed from the
    system and never sits in a media-less state.
    
    This stops some nasty udev device creation/destruction loops.
    
    Further, once this change is made, there is no need for ide to can be
    removed from ide_drive_t.
    
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>
    Acked-by: Bartlomiej Zolnierkiewicz <B.Zolnierkiewicz@elka.pw.edu.pl>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index afeb02bbb722..b2cc43702f65 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -242,7 +242,6 @@ static void init_hwif_data(ide_hwif_t *hwif, unsigned int index)
 		drive->name[2]			= 'a' + (index * MAX_DRIVES) + unit;
 		drive->max_failures		= IDE_DEFAULT_MAX_FAILURES;
 		drive->using_dma		= 0;
-		drive->is_flash			= 0;
 		drive->vdma			= 0;
 		INIT_LIST_HEAD(&drive->list);
 		init_completion(&drive->gendev_rel_comp);

commit 4031bbe4bbec6c0fe50412ef7fb43a270b0f29f1
Author: Russell King <rmk@arm.linux.org.uk>
Date:   Fri Jan 6 11:41:00 2006 +0000

    [PATCH] Add ide_bus_type probe and remove methods
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index ec5a4cb173b0..afeb02bbb722 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1949,10 +1949,41 @@ static int ide_uevent(struct device *dev, char **envp, int num_envp,
 	return 0;
 }
 
+static int generic_ide_probe(struct device *dev)
+{
+	ide_drive_t *drive = to_ide_device(dev);
+	ide_driver_t *drv = to_ide_driver(dev->driver);
+
+	return drv->probe ? drv->probe(drive) : -ENODEV;
+}
+
+static int generic_ide_remove(struct device *dev)
+{
+	ide_drive_t *drive = to_ide_device(dev);
+	ide_driver_t *drv = to_ide_driver(dev->driver);
+
+	if (drv->remove)
+		drv->remove(drive);
+
+	return 0;
+}
+
+static void generic_ide_shutdown(struct device *dev)
+{
+	ide_drive_t *drive = to_ide_device(dev);
+	ide_driver_t *drv = to_ide_driver(dev->driver);
+
+	if (dev->driver && drv->shutdown)
+		drv->shutdown(drive);
+}
+
 struct bus_type ide_bus_type = {
 	.name		= "ide",
 	.match		= ide_bus_match,
 	.uevent		= ide_uevent,
+	.probe		= generic_ide_probe,
+	.remove		= generic_ide_remove,
+	.shutdown	= generic_ide_shutdown,
 	.dev_attrs	= ide_dev_attrs,
 	.suspend	= generic_ide_suspend,
 	.resume		= generic_ide_resume,

commit f36d4024caa3790606e43228a574157c45b73b22
Author: Aleksey Makarov <amakarov@ru.mvista.com>
Date:   Mon Jan 9 15:59:27 2006 -0800

    [PATCH] mutex subsystem, semaphore to completion: IDE ->gendev_rel_sem
    
    The patch changes semaphores that are initialized as
    locked to complete().
    
    Source: MontaVista Software, Inc.
    
    Modified-by: Steven Rostedt <rostedt@goodmis.org>
    
    The following patch is from Montavista.  I modified it slightly.
    Semaphores are currently being used where it makes more sense for
    completions.  This patch corrects that.
    
    Signed-off-by: Aleksey Makarov <amakarov@ru.mvista.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index b069b13b75a7..ec5a4cb173b0 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -222,7 +222,7 @@ static void init_hwif_data(ide_hwif_t *hwif, unsigned int index)
 	hwif->mwdma_mask = 0x80;	/* disable all mwdma */
 	hwif->swdma_mask = 0x80;	/* disable all swdma */
 
-	sema_init(&hwif->gendev_rel_sem, 0);
+	init_completion(&hwif->gendev_rel_comp);
 
 	default_hwif_iops(hwif);
 	default_hwif_transport(hwif);
@@ -245,7 +245,7 @@ static void init_hwif_data(ide_hwif_t *hwif, unsigned int index)
 		drive->is_flash			= 0;
 		drive->vdma			= 0;
 		INIT_LIST_HEAD(&drive->list);
-		sema_init(&drive->gendev_rel_sem, 0);
+		init_completion(&drive->gendev_rel_comp);
 	}
 }
 
@@ -602,7 +602,7 @@ void ide_unregister(unsigned int index)
 		}
 		spin_unlock_irq(&ide_lock);
 		device_unregister(&drive->gendev);
-		down(&drive->gendev_rel_sem);
+		wait_for_completion(&drive->gendev_rel_comp);
 		spin_lock_irq(&ide_lock);
 	}
 	hwif->present = 0;
@@ -662,7 +662,7 @@ void ide_unregister(unsigned int index)
 	/* More messed up locking ... */
 	spin_unlock_irq(&ide_lock);
 	device_unregister(&hwif->gendev);
-	down(&hwif->gendev_rel_sem);
+	wait_for_completion(&hwif->gendev_rel_comp);
 
 	/*
 	 * Remove us from the kernel's knowledge

commit a885c8c4316e1c1d2d2c8755da3f3d14f852528d
Author: Christoph Hellwig <hch@lst.de>
Date:   Sun Jan 8 01:02:50 2006 -0800

    [PATCH] Add block_device_operations.getgeo block device method
    
    HDIO_GETGEO is implemented in most block drivers, and all of them have to
    duplicate the code to copy the structure to userspace, as well as getting
    the start sector.  This patch moves that to common code [1] and adds a
    ->getgeo method to fill out the raw kernel hd_geometry structure.  For many
    drivers this means ->ioctl can go away now.
    
    [1] the s390 block drivers are odd in this respect.  xpram sets ->start
        to 4 always which seems more than odd, and the dasd driver shifts
        the start offset around, probably because of it's non-standard
        sector size.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: Jens Axboe <axboe@suse.de>
    Cc: <mike.miller@hp.com>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo Giarrusso <blaisorblade@yahoo.it>
    Cc: Bartlomiej Zolnierkiewicz <B.Zolnierkiewicz@elka.pw.edu.pl>
    Cc: Neil Brown <neilb@cse.unsw.edu.au>
    Cc: Markus Lidel <Markus.Lidel@shadowconnect.com>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 4b524f6b3ecd..b069b13b75a7 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1278,19 +1278,6 @@ int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device
 	up(&ide_setting_sem);
 
 	switch (cmd) {
-		case HDIO_GETGEO:
-		{
-			struct hd_geometry geom;
-			if (!p || (drive->media != ide_disk && drive->media != ide_floppy)) return -EINVAL;
-			geom.heads = drive->bios_head;
-			geom.sectors = drive->bios_sect;
-			geom.cylinders = (u16)drive->bios_cyl; /* truncate */
-			geom.start = get_start_sect(bdev);
-			if (copy_to_user(p, &geom, sizeof(struct hd_geometry)))
-				return -EFAULT;
-			return 0;
-		}
-
 		case HDIO_OBSOLETE_IDENTITY:
 		case HDIO_GET_IDENTITY:
 			if (bdev != bdev->bd_contains)

commit 263756ec228f1cdd49fc50b1f87001a4cebdfe12
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Mon Dec 12 18:03:44 2005 +0100

    [PATCH] ide: MODALIAS support for autoloading of ide-cd, ide-disk, ...
    
    IDE: MODALIAS support for autoloading of ide-cd, ide-disk, ...
    
    Add MODULE_ALIAS to IDE midlayer modules: ide-disk, ide-cd, ide-floppy and
    ide-tape, to autoload these modules depending on the probed media type of
    the IDE device.
    
    It is used by udev and replaces the former agent shell script of the hotplug
    package, which was required to lookup the media type in the proc filesystem.
    Using proc was racy, cause the media file is created after the hotplug event
    is sent out.
    
    The module autoloading does not take any effect, until something like the
    following udev rule is configured:
      SUBSYSTEM=="ide",  ACTION=="add", ENV{MODALIAS}=="?*", RUN+="/sbin/modprobe $env{MODALIAS}"
    
    The module ide-scsi will not be autoloaded, cause it requires manual
    configuration. It can't be, and never was supported for automatic setup in
    the hotplug package. Adding a MODULE_ALIAS to ide-scsi for all supported
    media types, would just lead to a default blacklist entry anyway.
    
      $ modinfo ide-disk
      filename:       /lib/modules/2.6.15-rc4-g1b0997f5/kernel/drivers/ide/ide-disk.ko
      description:    ATA DISK Driver
      alias:          ide:*m-disk*
      license:        GPL
      ...
    
      $ modprobe -vn ide:m-disk
      insmod /lib/modules/2.6.15-rc4-g1b0997f5/kernel/drivers/ide/ide-disk.ko
    
      $ cat /sys/bus/ide/devices/0.0/modalias
      ide:m-disk
    
    It also adds attributes to the IDE device:
      $ tree /sys/bus/ide/devices/0.0/
      /sys/bus/ide/devices/0.0/
      |-- bus -> ../../../../../../../bus/ide
      |-- drivename
      |-- media
      |-- modalias
      |-- power
      |   |-- state
      |   `-- wakeup
      `-- uevent
    
      $ cat /sys/bus/ide/devices/0.0/{modalias,drivename,media}
      ide:m-disk
      hda
      disk
    
    Signed-off-by: Kay Sievers <kay.sievers@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 8af179b531c3..4b524f6b3ecd 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1904,9 +1904,69 @@ static int ide_bus_match(struct device *dev, struct device_driver *drv)
 	return 1;
 }
 
+static char *media_string(ide_drive_t *drive)
+{
+	switch (drive->media) {
+	case ide_disk:
+		return "disk";
+	case ide_cdrom:
+		return "cdrom";
+	case ide_tape:
+		return "tape";
+	case ide_floppy:
+		return "floppy";
+	default:
+		return "UNKNOWN";
+	}
+}
+
+static ssize_t media_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ide_drive_t *drive = to_ide_device(dev);
+	return sprintf(buf, "%s\n", media_string(drive));
+}
+
+static ssize_t drivename_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ide_drive_t *drive = to_ide_device(dev);
+	return sprintf(buf, "%s\n", drive->name);
+}
+
+static ssize_t modalias_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ide_drive_t *drive = to_ide_device(dev);
+	return sprintf(buf, "ide:m-%s\n", media_string(drive));
+}
+
+static struct device_attribute ide_dev_attrs[] = {
+	__ATTR_RO(media),
+	__ATTR_RO(drivename),
+	__ATTR_RO(modalias),
+	__ATTR_NULL
+};
+
+static int ide_uevent(struct device *dev, char **envp, int num_envp,
+		      char *buffer, int buffer_size)
+{
+	ide_drive_t *drive = to_ide_device(dev);
+	int i = 0;
+	int length = 0;
+
+	add_uevent_var(envp, num_envp, &i, buffer, buffer_size, &length,
+		       "MEDIA=%s", media_string(drive));
+	add_uevent_var(envp, num_envp, &i, buffer, buffer_size, &length,
+		       "DRIVENAME=%s", drive->name);
+	add_uevent_var(envp, num_envp, &i, buffer, buffer_size, &length,
+		       "MODALIAS=ide:m-%s", media_string(drive));
+	envp[i] = NULL;
+	return 0;
+}
+
 struct bus_type ide_bus_type = {
 	.name		= "ide",
 	.match		= ide_bus_match,
+	.uevent		= ide_uevent,
+	.dev_attrs	= ide_dev_attrs,
 	.suspend	= generic_ide_suspend,
 	.resume		= generic_ide_resume,
 };

commit 4349d5cdf28d46c22d467079e80ee9695dcec0ad
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Nov 9 22:47:18 2005 +0100

    [PATCH] ide: incorrect device link for ide-cs
    
    Devices driven by ide-cs will appear under /sys/devices instead of the
    appropriate PCMCIA device. To fix this I had to extend the hw_regs_t
    structure with a 'struct device' field, which allows us to set the
    parent link for the appropriate hwif.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Jens Axboe <axboe@suse.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 9fe19808d815..8af179b531c3 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -803,6 +803,7 @@ int ide_register_hw_with_fixup(hw_regs_t *hw, ide_hwif_t **hwifp, void(*fixup)(i
 	hwif->irq = hw->irq;
 	hwif->noprobe = 0;
 	hwif->chipset = hw->chipset;
+	hwif->gendev.parent = hw->dev;
 
 	if (!initializing) {
 		probe_hwif_init_with_fixup(hwif, fixup);

commit 6044ec8882c726e325017bd948aa0cd94ad33abc
Author: Jesper Juhl <jesper.juhl@gmail.com>
Date:   Mon Nov 7 01:01:32 2005 -0800

    [PATCH] kfree cleanup: misc remaining drivers
    
    This is the remaining misc drivers/ part of the big kfree cleanup patch.
    
    Remove pointless checks for NULL prior to calling kfree() in misc files in
    drivers/.
    
    Signed-off-by: Jesper Juhl <jesper.juhl@gmail.com>
    Acked-by: Aristeu Sergio Rozanski Filho <aris@cathedrallabs.org>
    Acked-by: Roland Dreier <rolandd@cisco.com>
    Acked-by: Pierre Ossman <drzeus@drzeus.cx>
    Acked-by: Jean Delvare <khali@linux-fr.org>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: Len Brown <len.brown@intel.com>
    Acked-by: "Antonino A. Daplas" <adaplas@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 1bbf67882ae5..9fe19808d815 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -888,8 +888,7 @@ static int __ide_add_setting(ide_drive_t *drive, const char *name, int rw, int r
 	return 0;
 abort:
 	up(&ide_setting_sem);
-	if (setting)
-		kfree(setting);
+	kfree(setting);
 	return -1;
 }
 

commit f5e3c2faa20615e900ab26bd957f898400435924
Author: Deepak Saxena <dsaxena@plexity.net>
Date:   Mon Nov 7 01:01:25 2005 -0800

    [PATCH] ide: kmalloc + memset -> kzalloc conversion
    
    Signed-off-by: Deepak Saxena <dsaxena@plexity.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 73ca8f73917d..1bbf67882ae5 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -864,9 +864,8 @@ static int __ide_add_setting(ide_drive_t *drive, const char *name, int rw, int r
 	down(&ide_setting_sem);
 	while ((*p) && strcmp((*p)->name, name) < 0)
 		p = &((*p)->next);
-	if ((setting = kmalloc(sizeof(*setting), GFP_KERNEL)) == NULL)
+	if ((setting = kzalloc(sizeof(*setting), GFP_KERNEL)) == NULL)
 		goto abort;
-	memset(setting, 0, sizeof(*setting));
 	if ((setting->name = kmalloc(strlen(name) + 1, GFP_KERNEL)) == NULL)
 		goto abort;
 	strcpy(setting->name, name);

commit ca078bae813dd46c0f9b102fdfb4a3384641ff48
Author: Pavel Machek <pavel@ucw.cz>
Date:   Sat Sep 3 15:56:57 2005 -0700

    [PATCH] swsusp: switch pm_message_t to struct
    
    This adds type-checking to pm_message_t, so that people can't confuse it
    with int or u32.  It also allows us to fix "disk yoyo" during suspend (disk
    spinning down/up/down).
    
    [We've tried that before; since that cpufreq problems were fixed and I've
    tried make allyes config and fixed resulting damage.]
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Alexander Nyberg <alexn@telia.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index dae1bd5b8c3e..73ca8f73917d 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -1229,7 +1229,7 @@ static int generic_ide_suspend(struct device *dev, pm_message_t state)
 	rq.special = &args;
 	rq.pm = &rqpm;
 	rqpm.pm_step = ide_pm_state_start_suspend;
-	rqpm.pm_state = state;
+	rqpm.pm_state = state.event;
 
 	return ide_do_drive_cmd(drive, &rq, ide_wait);
 }
@@ -1248,7 +1248,7 @@ static int generic_ide_resume(struct device *dev)
 	rq.special = &args;
 	rq.pm = &rqpm;
 	rqpm.pm_step = ide_pm_state_start_resume;
-	rqpm.pm_state = 0;
+	rqpm.pm_state = PM_EVENT_ON;
 
 	return ide_do_drive_cmd(drive, &rq, ide_head_wait);
 }

commit 8604affde9d4f52f04342d6a37c77d95fa167e7a
Author: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
Date:   Thu May 26 14:55:34 2005 +0200

    [PATCH] convert IDE device drivers to driver-model
    
    * add ide_bus_match() and export ide_bus_type
    * split ide_remove_driver_from_hwgroup() out of ide_unregister()
    * move device cleanup from ide_unregister() to drive_release_dev()
    * convert ide_driver_t->name to driver->name
    * convert ide_driver_t->{attach,cleanup} to driver->{probe,remove}
    * remove ide_driver_t->busy as ide_bus_type->subsys.rwsem
      protects against concurrent ->{probe,remove} calls
    * make ide_{un}register_driver() void as it cannot fail now
    * use driver_{un}register() directly, remove ide_{un}register_driver()
    * use device_register() instead of ata_attach(), remove ata_attach()
    * add proc_print_driver() and ide_drivers_show(), remove ide_drivers_op
    * fix ide_replace_subdriver() and move it to ide-proc.c
    * remove ide_driver_t->drives, ide_drives and drives_lock
    * remove ide_driver_t->drivers, drivers and drivers_lock
    * remove ide_drive_t->driver and DRIVER() macro
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 973dec799b5c..dae1bd5b8c3e 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -196,8 +196,6 @@ ide_hwif_t ide_hwifs[MAX_HWIFS];	/* master data repository */
 
 EXPORT_SYMBOL(ide_hwifs);
 
-static struct list_head ide_drives = LIST_HEAD_INIT(ide_drives);
-
 /*
  * Do not even *think* about calling this!
  */
@@ -358,54 +356,6 @@ static int ide_system_bus_speed(void)
 	return system_bus_speed;
 }
 
-/*
- *	drives_lock protects the list of drives, drivers_lock the
- *	list of drivers.  Currently nobody takes both at once.
- */
-
-static DEFINE_SPINLOCK(drives_lock);
-static DEFINE_SPINLOCK(drivers_lock);
-static LIST_HEAD(drivers);
-
-/* Iterator for the driver list. */
-
-static void *m_start(struct seq_file *m, loff_t *pos)
-{
-	struct list_head *p;
-	loff_t l = *pos;
-	spin_lock(&drivers_lock);
-	list_for_each(p, &drivers)
-		if (!l--)
-			return list_entry(p, ide_driver_t, drivers);
-	return NULL;
-}
-
-static void *m_next(struct seq_file *m, void *v, loff_t *pos)
-{
-	struct list_head *p = ((ide_driver_t *)v)->drivers.next;
-	(*pos)++;
-	return p==&drivers ? NULL : list_entry(p, ide_driver_t, drivers);
-}
-
-static void m_stop(struct seq_file *m, void *v)
-{
-	spin_unlock(&drivers_lock);
-}
-
-static int show_driver(struct seq_file *m, void *v)
-{
-	ide_driver_t *driver = v;
-	seq_printf(m, "%s version %s\n", driver->name, driver->version);
-	return 0;
-}
-
-struct seq_operations ide_drivers_op = {
-	.start	= m_start,
-	.next	= m_next,
-	.stop	= m_stop,
-	.show	= show_driver
-};
-
 #ifdef CONFIG_PROC_FS
 struct proc_dir_entry *proc_ide_root;
 #endif
@@ -630,7 +580,7 @@ void ide_unregister(unsigned int index)
 	ide_hwif_t *hwif, *g;
 	static ide_hwif_t tmp_hwif; /* protected by ide_cfg_sem */
 	ide_hwgroup_t *hwgroup;
-	int irq_count = 0, unit, i;
+	int irq_count = 0, unit;
 
 	BUG_ON(index >= MAX_HWIFS);
 
@@ -643,23 +593,22 @@ void ide_unregister(unsigned int index)
 		goto abort;
 	for (unit = 0; unit < MAX_DRIVES; ++unit) {
 		drive = &hwif->drives[unit];
-		if (!drive->present)
+		if (!drive->present) {
+			if (drive->devfs_name[0] != '\0') {
+				devfs_remove(drive->devfs_name);
+				drive->devfs_name[0] = '\0';
+			}
 			continue;
-		if (drive->usage || DRIVER(drive)->busy)
-			goto abort;
-		drive->dead = 1;
+		}
+		spin_unlock_irq(&ide_lock);
+		device_unregister(&drive->gendev);
+		down(&drive->gendev_rel_sem);
+		spin_lock_irq(&ide_lock);
 	}
 	hwif->present = 0;
 
 	spin_unlock_irq(&ide_lock);
 
-	for (unit = 0; unit < MAX_DRIVES; ++unit) {
-		drive = &hwif->drives[unit];
-		if (!drive->present)
-			continue;
-		DRIVER(drive)->cleanup(drive);
-	}
-
 	destroy_proc_ide_interface(hwif);
 
 	hwgroup = hwif->hwgroup;
@@ -687,44 +636,6 @@ void ide_unregister(unsigned int index)
 	 * Remove us from the hwgroup, and free
 	 * the hwgroup if we were the only member
 	 */
-	for (i = 0; i < MAX_DRIVES; ++i) {
-		drive = &hwif->drives[i];
-		if (drive->devfs_name[0] != '\0') {
-			devfs_remove(drive->devfs_name);
-			drive->devfs_name[0] = '\0';
-		}
-		if (!drive->present)
-			continue;
-		if (drive == drive->next) {
-			/* special case: last drive from hwgroup. */
-			BUG_ON(hwgroup->drive != drive);
-			hwgroup->drive = NULL;
-		} else {
-			ide_drive_t *walk;
-
-			walk = hwgroup->drive;
-			while (walk->next != drive)
-				walk = walk->next;
-			walk->next = drive->next;
-			if (hwgroup->drive == drive) {
-				hwgroup->drive = drive->next;
-				hwgroup->hwif = HWIF(hwgroup->drive);
-			}
-		}
-		BUG_ON(hwgroup->drive == drive);
-		if (drive->id != NULL) {
-			kfree(drive->id);
-			drive->id = NULL;
-		}
-		drive->present = 0;
-		/* Messed up locking ... */
-		spin_unlock_irq(&ide_lock);
-		blk_cleanup_queue(drive->queue);
-		device_unregister(&drive->gendev);
-		down(&drive->gendev_rel_sem);
-		spin_lock_irq(&ide_lock);
-		drive->queue = NULL;
-	}
 	if (hwif->next == hwif) {
 		BUG_ON(hwgroup->hwif != hwif);
 		kfree(hwgroup);
@@ -1304,73 +1215,6 @@ int system_bus_clock (void)
 
 EXPORT_SYMBOL(system_bus_clock);
 
-/*
- *	Locking is badly broken here - since way back.  That sucker is
- * root-only, but that's not an excuse...  The real question is what
- * exclusion rules do we want here.
- */
-int ide_replace_subdriver (ide_drive_t *drive, const char *driver)
-{
-	if (!drive->present || drive->usage || drive->dead)
-		goto abort;
-	if (DRIVER(drive)->cleanup(drive))
-		goto abort;
-	strlcpy(drive->driver_req, driver, sizeof(drive->driver_req));
-	if (ata_attach(drive)) {
-		spin_lock(&drives_lock);
-		list_del_init(&drive->list);
-		spin_unlock(&drives_lock);
-		drive->driver_req[0] = 0;
-		ata_attach(drive);
-	} else {
-		drive->driver_req[0] = 0;
-	}
-	if (drive->driver && !strcmp(drive->driver->name, driver))
-		return 0;
-abort:
-	return 1;
-}
-
-/**
- *	ata_attach		-	attach an ATA/ATAPI device
- *	@drive: drive to attach
- *
- *	Takes a drive that is as yet not assigned to any midlayer IDE
- *	driver (or is assigned to the default driver) and figures out
- *	which driver would like to own it. If nobody claims the drive
- *	then it is automatically attached to the default driver used for
- *	unclaimed objects.
- *
- *	A return of zero indicates attachment to a driver, of one
- *	attachment to the default driver.
- *
- *	Takes drivers_lock.
- */
-
-int ata_attach(ide_drive_t *drive)
-{
-	struct list_head *p;
-	spin_lock(&drivers_lock);
-	list_for_each(p, &drivers) {
-		ide_driver_t *driver = list_entry(p, ide_driver_t, drivers);
-		if (!try_module_get(driver->owner))
-			continue;
-		spin_unlock(&drivers_lock);
-		if (driver->attach(drive) == 0) {
-			module_put(driver->owner);
-			drive->gendev.driver = &driver->gen_driver;
-			return 0;
-		}
-		spin_lock(&drivers_lock);
-		module_put(driver->owner);
-	}
-	drive->gendev.driver = NULL;
-	spin_unlock(&drivers_lock);
-	if (ide_register_subdriver(drive, NULL))
-		panic("ide: default attach failed");
-	return 1;
-}
-
 static int generic_ide_suspend(struct device *dev, pm_message_t state)
 {
 	ide_drive_t *drive = dev->driver_data;
@@ -2013,27 +1857,11 @@ static void __init probe_for_hwifs (void)
 #endif
 }
 
-int ide_register_subdriver(ide_drive_t *drive, ide_driver_t *driver)
+void ide_register_subdriver(ide_drive_t *drive, ide_driver_t *driver)
 {
-	unsigned long flags;
-
-	spin_lock_irqsave(&ide_lock, flags);
-	if (!drive->present || drive->driver != NULL ||
-	    drive->usage || drive->dead) {
-		spin_unlock_irqrestore(&ide_lock, flags);
-		return 1;
-	}
-	drive->driver = driver;
-	spin_unlock_irqrestore(&ide_lock, flags);
-	spin_lock(&drives_lock);
-	list_add_tail(&drive->list, driver ? &driver->drives : &ide_drives);
-	spin_unlock(&drives_lock);
-//	printk(KERN_INFO "%s: attached %s driver.\n", drive->name, driver->name);
 #ifdef CONFIG_PROC_FS
-	if (driver)
-		ide_add_proc_entries(drive->proc, driver->proc, drive);
+	ide_add_proc_entries(drive->proc, driver->proc, drive);
 #endif
-	return 0;
 }
 
 EXPORT_SYMBOL(ide_register_subdriver);
@@ -2041,136 +1869,51 @@ EXPORT_SYMBOL(ide_register_subdriver);
 /**
  *	ide_unregister_subdriver	-	disconnect drive from driver
  *	@drive: drive to unplug
+ *	@driver: driver
  *
  *	Disconnect a drive from the driver it was attached to and then
  *	clean up the various proc files and other objects attached to it.
  *
- *	Takes ide_setting_sem, ide_lock and drives_lock.
+ *	Takes ide_setting_sem and ide_lock.
  *	Caller must hold none of the locks.
- *
- *	No locking versus subdriver unload because we are moving to the
- *	default driver anyway. Wants double checking.
  */
 
-int ide_unregister_subdriver (ide_drive_t *drive)
+void ide_unregister_subdriver(ide_drive_t *drive, ide_driver_t *driver)
 {
 	unsigned long flags;
 	
 	down(&ide_setting_sem);
 	spin_lock_irqsave(&ide_lock, flags);
-	if (drive->usage || drive->driver == NULL || DRIVER(drive)->busy) {
-		spin_unlock_irqrestore(&ide_lock, flags);
-		up(&ide_setting_sem);
-		return 1;
-	}
 #ifdef CONFIG_PROC_FS
-	ide_remove_proc_entries(drive->proc, DRIVER(drive)->proc);
+	ide_remove_proc_entries(drive->proc, driver->proc);
 #endif
 	auto_remove_settings(drive);
-	drive->driver = NULL;
 	spin_unlock_irqrestore(&ide_lock, flags);
 	up(&ide_setting_sem);
-	spin_lock(&drives_lock);
-	list_del_init(&drive->list);
-	spin_unlock(&drives_lock);
-	/* drive will be added to &ide_drives in ata_attach() */
-	return 0;
 }
 
 EXPORT_SYMBOL(ide_unregister_subdriver);
 
-static int ide_drive_remove(struct device * dev)
-{
-	ide_drive_t * drive = container_of(dev,ide_drive_t,gendev);
-	DRIVER(drive)->cleanup(drive);
-	return 0;
-}
-
-/**
- *	ide_register_driver	-	register IDE device driver
- *	@driver: the IDE device driver
- *
- *	Register a new device driver and then scan the devices
- *	on the IDE bus in case any should be attached to the
- *	driver we have just registered.  If so attach them.
- *
- *	Takes drivers_lock and drives_lock.
- */
-
-int ide_register_driver(ide_driver_t *driver)
-{
-	struct list_head list;
-	struct list_head *list_loop;
-	struct list_head *tmp_storage;
-
-	spin_lock(&drivers_lock);
-	list_add(&driver->drivers, &drivers);
-	spin_unlock(&drivers_lock);
-
-	INIT_LIST_HEAD(&list);
-	spin_lock(&drives_lock);
-	list_splice_init(&ide_drives, &list);
-	spin_unlock(&drives_lock);
-
-	list_for_each_safe(list_loop, tmp_storage, &list) {
-		ide_drive_t *drive = container_of(list_loop, ide_drive_t, list);
-		list_del_init(&drive->list);
-		if (drive->present)
-			ata_attach(drive);
-	}
-	driver->gen_driver.name = (char *) driver->name;
-	driver->gen_driver.bus = &ide_bus_type;
-	driver->gen_driver.remove = ide_drive_remove;
-	return driver_register(&driver->gen_driver);
-}
-
-EXPORT_SYMBOL(ide_register_driver);
-
-/**
- *	ide_unregister_driver	-	unregister IDE device driver
- *	@driver: the IDE device driver
- *
- *	Called when a driver module is being unloaded. We reattach any
- *	devices to whatever driver claims them next (typically the default
- *	driver).
- *
- *	Takes drivers_lock and called functions will take ide_setting_sem.
- */
-
-void ide_unregister_driver(ide_driver_t *driver)
-{
-	ide_drive_t *drive;
-
-	spin_lock(&drivers_lock);
-	list_del(&driver->drivers);
-	spin_unlock(&drivers_lock);
-
-	driver_unregister(&driver->gen_driver);
-
-	while(!list_empty(&driver->drives)) {
-		drive = list_entry(driver->drives.next, ide_drive_t, list);
-		if (driver->cleanup(drive)) {
-			printk(KERN_ERR "%s: cleanup_module() called while still busy\n", drive->name);
-			BUG();
-		}
-		ata_attach(drive);
-	}
-}
-
-EXPORT_SYMBOL(ide_unregister_driver);
-
 /*
  * Probe module
  */
 
 EXPORT_SYMBOL(ide_lock);
 
+static int ide_bus_match(struct device *dev, struct device_driver *drv)
+{
+	return 1;
+}
+
 struct bus_type ide_bus_type = {
 	.name		= "ide",
+	.match		= ide_bus_match,
 	.suspend	= generic_ide_suspend,
 	.resume		= generic_ide_resume,
 };
 
+EXPORT_SYMBOL_GPL(ide_bus_type);
+
 /*
  * This is gets invoked once during initialization, to set *everything* up
  */

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
new file mode 100644
index 000000000000..973dec799b5c
--- /dev/null
+++ b/drivers/ide/ide.c
@@ -0,0 +1,2269 @@
+/*
+ *  linux/drivers/ide/ide.c		Version 7.00beta2	Mar 05 2003
+ *
+ *  Copyright (C) 1994-1998  Linus Torvalds & authors (see below)
+ */
+
+/*
+ *  Mostly written by Mark Lord  <mlord@pobox.com>
+ *                and Gadi Oxman <gadio@netvision.net.il>
+ *                and Andre Hedrick <andre@linux-ide.org>
+ *
+ *  See linux/MAINTAINERS for address of current maintainer.
+ *
+ * This is the multiple IDE interface driver, as evolved from hd.c.
+ * It supports up to MAX_HWIFS IDE interfaces, on one or more IRQs
+ *   (usually 14 & 15).
+ * There can be up to two drives per interface, as per the ATA-2 spec.
+ *
+ * Primary:    ide0, port 0x1f0; major=3;  hda is minor=0; hdb is minor=64
+ * Secondary:  ide1, port 0x170; major=22; hdc is minor=0; hdd is minor=64
+ * Tertiary:   ide2, port 0x???; major=33; hde is minor=0; hdf is minor=64
+ * Quaternary: ide3, port 0x???; major=34; hdg is minor=0; hdh is minor=64
+ * ...
+ *
+ *  From hd.c:
+ *  |
+ *  | It traverses the request-list, using interrupts to jump between functions.
+ *  | As nearly all functions can be called within interrupts, we may not sleep.
+ *  | Special care is recommended.  Have Fun!
+ *  |
+ *  | modified by Drew Eckhardt to check nr of hd's from the CMOS.
+ *  |
+ *  | Thanks to Branko Lankester, lankeste@fwi.uva.nl, who found a bug
+ *  | in the early extended-partition checks and added DM partitions.
+ *  |
+ *  | Early work on error handling by Mika Liljeberg (liljeber@cs.Helsinki.FI).
+ *  |
+ *  | IRQ-unmask, drive-id, multiple-mode, support for ">16 heads",
+ *  | and general streamlining by Mark Lord (mlord@pobox.com).
+ *
+ *  October, 1994 -- Complete line-by-line overhaul for linux 1.1.x, by:
+ *
+ *	Mark Lord	(mlord@pobox.com)		(IDE Perf.Pkg)
+ *	Delman Lee	(delman@ieee.org)		("Mr. atdisk2")
+ *	Scott Snyder	(snyder@fnald0.fnal.gov)	(ATAPI IDE cd-rom)
+ *
+ *  This was a rewrite of just about everything from hd.c, though some original
+ *  code is still sprinkled about.  Think of it as a major evolution, with
+ *  inspiration from lots of linux users, esp.  hamish@zot.apana.org.au
+ *
+ *  Version 1.0 ALPHA	initial code, primary i/f working okay
+ *  Version 1.3 BETA	dual i/f on shared irq tested & working!
+ *  Version 1.4 BETA	added auto probing for irq(s)
+ *  Version 1.5 BETA	added ALPHA (untested) support for IDE cd-roms,
+ *  ...
+ * Version 5.50		allow values as small as 20 for idebus=
+ * Version 5.51		force non io_32bit in drive_cmd_intr()
+ *			change delay_10ms() to delay_50ms() to fix problems
+ * Version 5.52		fix incorrect invalidation of removable devices
+ *			add "hdx=slow" command line option
+ * Version 5.60		start to modularize the driver; the disk and ATAPI
+ *			 drivers can be compiled as loadable modules.
+ *			move IDE probe code to ide-probe.c
+ *			move IDE disk code to ide-disk.c
+ *			add support for generic IDE device subdrivers
+ *			add m68k code from Geert Uytterhoeven
+ *			probe all interfaces by default
+ *			add ioctl to (re)probe an interface
+ * Version 6.00		use per device request queues
+ *			attempt to optimize shared hwgroup performance
+ *			add ioctl to manually adjust bandwidth algorithms
+ *			add kerneld support for the probe module
+ *			fix bug in ide_error()
+ *			fix bug in the first ide_get_lock() call for Atari
+ *			don't flush leftover data for ATAPI devices
+ * Version 6.01		clear hwgroup->active while the hwgroup sleeps
+ *			support HDIO_GETGEO for floppies
+ * Version 6.02		fix ide_ack_intr() call
+ *			check partition table on floppies
+ * Version 6.03		handle bad status bit sequencing in ide_wait_stat()
+ * Version 6.10		deleted old entries from this list of updates
+ *			replaced triton.c with ide-dma.c generic PCI DMA
+ *			added support for BIOS-enabled UltraDMA
+ *			rename all "promise" things to "pdc4030"
+ *			fix EZ-DRIVE handling on small disks
+ * Version 6.11		fix probe error in ide_scan_devices()
+ *			fix ancient "jiffies" polling bugs
+ *			mask all hwgroup interrupts on each irq entry
+ * Version 6.12		integrate ioctl and proc interfaces
+ *			fix parsing of "idex=" command line parameter
+ * Version 6.13		add support for ide4/ide5 courtesy rjones@orchestream.com
+ * Version 6.14		fixed IRQ sharing among PCI devices
+ * Version 6.15		added SMP awareness to IDE drivers
+ * Version 6.16		fixed various bugs; even more SMP friendly
+ * Version 6.17		fix for newest EZ-Drive problem
+ * Version 6.18		default unpartitioned-disk translation now "BIOS LBA"
+ * Version 6.19		Re-design for a UNIFORM driver for all platforms,
+ *			  model based on suggestions from Russell King and
+ *			  Geert Uytterhoeven
+ *			Promise DC4030VL now supported.
+ *			add support for ide6/ide7
+ *			delay_50ms() changed to ide_delay_50ms() and exported.
+ * Version 6.20		Added/Fixed Generic ATA-66 support and hwif detection.
+ *			Added hdx=flash to allow for second flash disk
+ *			  detection w/o the hang loop.
+ *			Added support for ide8/ide9
+ *			Added idex=ata66 for the quirky chipsets that are
+ *			  ATA-66 compliant, but have yet to determine a method
+ *			  of verification of the 80c cable presence.
+ *			  Specifically Promise's PDC20262 chipset.
+ * Version 6.21		Fixing/Fixed SMP spinlock issue with insight from an old
+ *			  hat that clarified original low level driver design.
+ * Version 6.30		Added SMP support; fixed multmode issues.  -ml
+ * Version 6.31		Debug Share INTR's and request queue streaming
+ *			Native ATA-100 support
+ *			Prep for Cascades Project
+ * Version 7.00alpha	First named revision of ide rearrange
+ *
+ *  Some additional driver compile-time options are in ./include/linux/ide.h
+ *
+ *  To do, in likely order of completion:
+ *	- modify kernel to obtain BIOS geometry for drives on 2nd/3rd/4th i/f
+ *
+ */
+
+#define	REVISION	"Revision: 7.00alpha2"
+#define	VERSION		"Id: ide.c 7.00a2 20020906"
+
+#undef REALLY_SLOW_IO		/* most systems can safely undef this */
+
+#define _IDE_C			/* Tell ide.h it's really us */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/timer.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/major.h>
+#include <linux/errno.h>
+#include <linux/genhd.h>
+#include <linux/blkpg.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/ide.h>
+#include <linux/devfs_fs_kernel.h>
+#include <linux/completion.h>
+#include <linux/reboot.h>
+#include <linux/cdrom.h>
+#include <linux/seq_file.h>
+#include <linux/device.h>
+#include <linux/bitops.h>
+
+#include <asm/byteorder.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+
+/* default maximum number of failures */
+#define IDE_DEFAULT_MAX_FAILURES 	1
+
+static const u8 ide_hwif_to_major[] = { IDE0_MAJOR, IDE1_MAJOR,
+					IDE2_MAJOR, IDE3_MAJOR,
+					IDE4_MAJOR, IDE5_MAJOR,
+					IDE6_MAJOR, IDE7_MAJOR,
+					IDE8_MAJOR, IDE9_MAJOR };
+
+static int idebus_parameter;	/* holds the "idebus=" parameter */
+static int system_bus_speed;	/* holds what we think is VESA/PCI bus speed */
+static int initializing;	/* set while initializing built-in drivers */
+
+DECLARE_MUTEX(ide_cfg_sem);
+ __cacheline_aligned_in_smp DEFINE_SPINLOCK(ide_lock);
+
+#ifdef CONFIG_BLK_DEV_IDEPCI
+static int ide_scan_direction; /* THIS was formerly 2.2.x pci=reverse */
+#endif
+
+#ifdef CONFIG_IDEDMA_AUTO
+int noautodma = 0;
+#else
+int noautodma = 1;
+#endif
+
+EXPORT_SYMBOL(noautodma);
+
+/*
+ * This is declared extern in ide.h, for access by other IDE modules:
+ */
+ide_hwif_t ide_hwifs[MAX_HWIFS];	/* master data repository */
+
+EXPORT_SYMBOL(ide_hwifs);
+
+static struct list_head ide_drives = LIST_HEAD_INIT(ide_drives);
+
+/*
+ * Do not even *think* about calling this!
+ */
+static void init_hwif_data(ide_hwif_t *hwif, unsigned int index)
+{
+	unsigned int unit;
+
+	/* bulk initialize hwif & drive info with zeros */
+	memset(hwif, 0, sizeof(ide_hwif_t));
+
+	/* fill in any non-zero initial values */
+	hwif->index	= index;
+	hwif->major	= ide_hwif_to_major[index];
+
+	hwif->name[0]	= 'i';
+	hwif->name[1]	= 'd';
+	hwif->name[2]	= 'e';
+	hwif->name[3]	= '0' + index;
+
+	hwif->bus_state	= BUSSTATE_ON;
+
+	hwif->atapi_dma = 0;		/* disable all atapi dma */ 
+	hwif->ultra_mask = 0x80;	/* disable all ultra */
+	hwif->mwdma_mask = 0x80;	/* disable all mwdma */
+	hwif->swdma_mask = 0x80;	/* disable all swdma */
+
+	sema_init(&hwif->gendev_rel_sem, 0);
+
+	default_hwif_iops(hwif);
+	default_hwif_transport(hwif);
+	for (unit = 0; unit < MAX_DRIVES; ++unit) {
+		ide_drive_t *drive = &hwif->drives[unit];
+
+		drive->media			= ide_disk;
+		drive->select.all		= (unit<<4)|0xa0;
+		drive->hwif			= hwif;
+		drive->ctl			= 0x08;
+		drive->ready_stat		= READY_STAT;
+		drive->bad_wstat		= BAD_W_STAT;
+		drive->special.b.recalibrate	= 1;
+		drive->special.b.set_geometry	= 1;
+		drive->name[0]			= 'h';
+		drive->name[1]			= 'd';
+		drive->name[2]			= 'a' + (index * MAX_DRIVES) + unit;
+		drive->max_failures		= IDE_DEFAULT_MAX_FAILURES;
+		drive->using_dma		= 0;
+		drive->is_flash			= 0;
+		drive->vdma			= 0;
+		INIT_LIST_HEAD(&drive->list);
+		sema_init(&drive->gendev_rel_sem, 0);
+	}
+}
+
+static void init_hwif_default(ide_hwif_t *hwif, unsigned int index)
+{
+	hw_regs_t hw;
+
+	memset(&hw, 0, sizeof(hw_regs_t));
+
+	ide_init_hwif_ports(&hw, ide_default_io_base(index), 0, &hwif->irq);
+
+	memcpy(&hwif->hw, &hw, sizeof(hw));
+	memcpy(hwif->io_ports, hw.io_ports, sizeof(hw.io_ports));
+
+	hwif->noprobe = !hwif->io_ports[IDE_DATA_OFFSET];
+#ifdef CONFIG_BLK_DEV_HD
+	if (hwif->io_ports[IDE_DATA_OFFSET] == HD_DATA)
+		hwif->noprobe = 1;	/* may be overridden by ide_setup() */
+#endif
+}
+
+extern void ide_arm_init(void);
+
+/*
+ * init_ide_data() sets reasonable default values into all fields
+ * of all instances of the hwifs and drives, but only on the first call.
+ * Subsequent calls have no effect (they don't wipe out anything).
+ *
+ * This routine is normally called at driver initialization time,
+ * but may also be called MUCH earlier during kernel "command-line"
+ * parameter processing.  As such, we cannot depend on any other parts
+ * of the kernel (such as memory allocation) to be functioning yet.
+ *
+ * This is too bad, as otherwise we could dynamically allocate the
+ * ide_drive_t structs as needed, rather than always consuming memory
+ * for the max possible number (MAX_HWIFS * MAX_DRIVES) of them.
+ *
+ * FIXME: We should stuff the setup data into __init and copy the
+ * relevant hwifs/allocate them properly during boot.
+ */
+#define MAGIC_COOKIE 0x12345678
+static void __init init_ide_data (void)
+{
+	ide_hwif_t *hwif;
+	unsigned int index;
+	static unsigned long magic_cookie = MAGIC_COOKIE;
+
+	if (magic_cookie != MAGIC_COOKIE)
+		return;		/* already initialized */
+	magic_cookie = 0;
+
+	/* Initialise all interface structures */
+	for (index = 0; index < MAX_HWIFS; ++index) {
+		hwif = &ide_hwifs[index];
+		init_hwif_data(hwif, index);
+		init_hwif_default(hwif, index);
+#if !defined(CONFIG_PPC32) || !defined(CONFIG_PCI)
+		hwif->irq = hwif->hw.irq =
+			ide_init_default_irq(hwif->io_ports[IDE_DATA_OFFSET]);
+#endif
+	}
+#ifdef CONFIG_IDE_ARM
+	initializing = 1;
+	ide_arm_init();
+	initializing = 0;
+#endif
+}
+
+/**
+ *	ide_system_bus_speed	-	guess bus speed
+ *
+ *	ide_system_bus_speed() returns what we think is the system VESA/PCI
+ *	bus speed (in MHz). This is used for calculating interface PIO timings.
+ *	The default is 40 for known PCI systems, 50 otherwise.
+ *	The "idebus=xx" parameter can be used to override this value.
+ *	The actual value to be used is computed/displayed the first time
+ *	through. Drivers should only use this as a last resort.
+ *
+ *	Returns a guessed speed in MHz.
+ */
+
+static int ide_system_bus_speed(void)
+{
+#ifdef CONFIG_PCI
+	static struct pci_device_id pci_default[] = {
+		{ PCI_DEVICE(PCI_ANY_ID, PCI_ANY_ID) },
+		{ }
+	};
+#else
+#define pci_default 0
+#endif /* CONFIG_PCI */
+
+	if (!system_bus_speed) {
+		if (idebus_parameter) {
+			/* user supplied value */
+			system_bus_speed = idebus_parameter;
+		} else if (pci_dev_present(pci_default)) {
+			/* safe default value for PCI */
+			system_bus_speed = 33;
+		} else {
+			/* safe default value for VESA and PCI */
+			system_bus_speed = 50;
+		}
+		printk(KERN_INFO "ide: Assuming %dMHz system bus speed "
+			"for PIO modes%s\n", system_bus_speed,
+			idebus_parameter ? "" : "; override with idebus=xx");
+	}
+	return system_bus_speed;
+}
+
+/*
+ *	drives_lock protects the list of drives, drivers_lock the
+ *	list of drivers.  Currently nobody takes both at once.
+ */
+
+static DEFINE_SPINLOCK(drives_lock);
+static DEFINE_SPINLOCK(drivers_lock);
+static LIST_HEAD(drivers);
+
+/* Iterator for the driver list. */
+
+static void *m_start(struct seq_file *m, loff_t *pos)
+{
+	struct list_head *p;
+	loff_t l = *pos;
+	spin_lock(&drivers_lock);
+	list_for_each(p, &drivers)
+		if (!l--)
+			return list_entry(p, ide_driver_t, drivers);
+	return NULL;
+}
+
+static void *m_next(struct seq_file *m, void *v, loff_t *pos)
+{
+	struct list_head *p = ((ide_driver_t *)v)->drivers.next;
+	(*pos)++;
+	return p==&drivers ? NULL : list_entry(p, ide_driver_t, drivers);
+}
+
+static void m_stop(struct seq_file *m, void *v)
+{
+	spin_unlock(&drivers_lock);
+}
+
+static int show_driver(struct seq_file *m, void *v)
+{
+	ide_driver_t *driver = v;
+	seq_printf(m, "%s version %s\n", driver->name, driver->version);
+	return 0;
+}
+
+struct seq_operations ide_drivers_op = {
+	.start	= m_start,
+	.next	= m_next,
+	.stop	= m_stop,
+	.show	= show_driver
+};
+
+#ifdef CONFIG_PROC_FS
+struct proc_dir_entry *proc_ide_root;
+#endif
+
+static struct resource* hwif_request_region(ide_hwif_t *hwif,
+					    unsigned long addr, int num)
+{
+	struct resource *res = request_region(addr, num, hwif->name);
+
+	if (!res)
+		printk(KERN_ERR "%s: I/O resource 0x%lX-0x%lX not free.\n",
+				hwif->name, addr, addr+num-1);
+	return res;
+}
+
+/**
+ *	ide_hwif_request_regions - request resources for IDE
+ *	@hwif: interface to use
+ *
+ *	Requests all the needed resources for an interface.
+ *	Right now core IDE code does this work which is deeply wrong.
+ *	MMIO leaves it to the controller driver,
+ *	PIO will migrate this way over time.
+ */
+
+int ide_hwif_request_regions(ide_hwif_t *hwif)
+{
+	unsigned long addr;
+	unsigned int i;
+
+	if (hwif->mmio == 2)
+		return 0;
+	BUG_ON(hwif->mmio == 1);
+	addr = hwif->io_ports[IDE_CONTROL_OFFSET];
+	if (addr && !hwif_request_region(hwif, addr, 1))
+		goto control_region_busy;
+	hwif->straight8 = 0;
+	addr = hwif->io_ports[IDE_DATA_OFFSET];
+	if ((addr | 7) == hwif->io_ports[IDE_STATUS_OFFSET]) {
+		if (!hwif_request_region(hwif, addr, 8))
+			goto data_region_busy;
+		hwif->straight8 = 1;
+		return 0;
+	}
+	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++) {
+		addr = hwif->io_ports[i];
+		if (!hwif_request_region(hwif, addr, 1)) {
+			while (--i)
+				release_region(addr, 1);
+			goto data_region_busy;
+		}
+	}
+	return 0;
+
+data_region_busy:
+	addr = hwif->io_ports[IDE_CONTROL_OFFSET];
+	if (addr)
+		release_region(addr, 1);
+control_region_busy:
+	/* If any errors are return, we drop the hwif interface. */
+	return -EBUSY;
+}
+
+/**
+ *	ide_hwif_release_regions - free IDE resources
+ *
+ *	Note that we only release the standard ports,
+ *	and do not even try to handle any extra ports
+ *	allocated for weird IDE interface chipsets.
+ *
+ *	Note also that we don't yet handle mmio resources here. More
+ *	importantly our caller should be doing this so we need to 
+ *	restructure this as a helper function for drivers.
+ */
+
+void ide_hwif_release_regions(ide_hwif_t *hwif)
+{
+	u32 i = 0;
+
+	if (hwif->mmio == 2)
+		return;
+	if (hwif->io_ports[IDE_CONTROL_OFFSET])
+		release_region(hwif->io_ports[IDE_CONTROL_OFFSET], 1);
+	if (hwif->straight8) {
+		release_region(hwif->io_ports[IDE_DATA_OFFSET], 8);
+		return;
+	}
+	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++)
+		if (hwif->io_ports[i])
+			release_region(hwif->io_ports[i], 1);
+}
+
+/**
+ *	ide_hwif_restore	-	restore hwif to template
+ *	@hwif: hwif to update
+ *	@tmp_hwif: template
+ *
+ *	Restore hwif to a previous state by copying most settngs
+ *	from the template.
+ */
+
+static void ide_hwif_restore(ide_hwif_t *hwif, ide_hwif_t *tmp_hwif)
+{
+	hwif->hwgroup			= tmp_hwif->hwgroup;
+
+	hwif->gendev.parent		= tmp_hwif->gendev.parent;
+
+	hwif->proc			= tmp_hwif->proc;
+
+	hwif->major			= tmp_hwif->major;
+	hwif->straight8			= tmp_hwif->straight8;
+	hwif->bus_state			= tmp_hwif->bus_state;
+
+	hwif->atapi_dma			= tmp_hwif->atapi_dma;
+	hwif->ultra_mask		= tmp_hwif->ultra_mask;
+	hwif->mwdma_mask		= tmp_hwif->mwdma_mask;
+	hwif->swdma_mask		= tmp_hwif->swdma_mask;
+
+	hwif->chipset			= tmp_hwif->chipset;
+	hwif->hold			= tmp_hwif->hold;
+
+#ifdef CONFIG_BLK_DEV_IDEPCI
+	hwif->pci_dev			= tmp_hwif->pci_dev;
+	hwif->cds			= tmp_hwif->cds;
+#endif
+
+	hwif->tuneproc			= tmp_hwif->tuneproc;
+	hwif->speedproc			= tmp_hwif->speedproc;
+	hwif->selectproc		= tmp_hwif->selectproc;
+	hwif->reset_poll		= tmp_hwif->reset_poll;
+	hwif->pre_reset			= tmp_hwif->pre_reset;
+	hwif->resetproc			= tmp_hwif->resetproc;
+	hwif->intrproc			= tmp_hwif->intrproc;
+	hwif->maskproc			= tmp_hwif->maskproc;
+	hwif->quirkproc			= tmp_hwif->quirkproc;
+	hwif->busproc			= tmp_hwif->busproc;
+
+	hwif->ata_input_data		= tmp_hwif->ata_input_data;
+	hwif->ata_output_data		= tmp_hwif->ata_output_data;
+	hwif->atapi_input_bytes		= tmp_hwif->atapi_input_bytes;
+	hwif->atapi_output_bytes	= tmp_hwif->atapi_output_bytes;
+
+	hwif->dma_setup			= tmp_hwif->dma_setup;
+	hwif->dma_exec_cmd		= tmp_hwif->dma_exec_cmd;
+	hwif->dma_start			= tmp_hwif->dma_start;
+	hwif->ide_dma_end		= tmp_hwif->ide_dma_end;
+	hwif->ide_dma_check		= tmp_hwif->ide_dma_check;
+	hwif->ide_dma_on		= tmp_hwif->ide_dma_on;
+	hwif->ide_dma_off_quietly	= tmp_hwif->ide_dma_off_quietly;
+	hwif->ide_dma_test_irq		= tmp_hwif->ide_dma_test_irq;
+	hwif->ide_dma_host_on		= tmp_hwif->ide_dma_host_on;
+	hwif->ide_dma_host_off		= tmp_hwif->ide_dma_host_off;
+	hwif->ide_dma_lostirq		= tmp_hwif->ide_dma_lostirq;
+	hwif->ide_dma_timeout		= tmp_hwif->ide_dma_timeout;
+
+	hwif->OUTB			= tmp_hwif->OUTB;
+	hwif->OUTBSYNC			= tmp_hwif->OUTBSYNC;
+	hwif->OUTW			= tmp_hwif->OUTW;
+	hwif->OUTL			= tmp_hwif->OUTL;
+	hwif->OUTSW			= tmp_hwif->OUTSW;
+	hwif->OUTSL			= tmp_hwif->OUTSL;
+
+	hwif->INB			= tmp_hwif->INB;
+	hwif->INW			= tmp_hwif->INW;
+	hwif->INL			= tmp_hwif->INL;
+	hwif->INSW			= tmp_hwif->INSW;
+	hwif->INSL			= tmp_hwif->INSL;
+
+	hwif->sg_max_nents		= tmp_hwif->sg_max_nents;
+
+	hwif->mmio			= tmp_hwif->mmio;
+	hwif->rqsize			= tmp_hwif->rqsize;
+	hwif->no_lba48			= tmp_hwif->no_lba48;
+
+#ifndef CONFIG_BLK_DEV_IDECS
+	hwif->irq			= tmp_hwif->irq;
+#endif
+
+	hwif->dma_base			= tmp_hwif->dma_base;
+	hwif->dma_master		= tmp_hwif->dma_master;
+	hwif->dma_command		= tmp_hwif->dma_command;
+	hwif->dma_vendor1		= tmp_hwif->dma_vendor1;
+	hwif->dma_status		= tmp_hwif->dma_status;
+	hwif->dma_vendor3		= tmp_hwif->dma_vendor3;
+	hwif->dma_prdtable		= tmp_hwif->dma_prdtable;
+
+	hwif->dma_extra			= tmp_hwif->dma_extra;
+	hwif->config_data		= tmp_hwif->config_data;
+	hwif->select_data		= tmp_hwif->select_data;
+	hwif->autodma			= tmp_hwif->autodma;
+	hwif->udma_four			= tmp_hwif->udma_four;
+	hwif->no_dsc			= tmp_hwif->no_dsc;
+
+	hwif->hwif_data			= tmp_hwif->hwif_data;
+}
+
+/**
+ *	ide_unregister		-	free an ide interface
+ *	@index: index of interface (will change soon to a pointer)
+ *
+ *	Perform the final unregister of an IDE interface. At the moment
+ *	we don't refcount interfaces so this will also get split up.
+ *
+ *	Locking:
+ *	The caller must not hold the IDE locks
+ *	The drive present/vanishing is not yet properly locked
+ *	Take care with the callbacks. These have been split to avoid
+ *	deadlocking the IDE layer. The shutdown callback is called
+ *	before we take the lock and free resources. It is up to the
+ *	caller to be sure there is no pending I/O here, and that
+ *	the interfce will not be reopened (present/vanishing locking
+ *	isnt yet done btw). After we commit to the final kill we
+ *	call the cleanup callback with the ide locks held.
+ *
+ *	Unregister restores the hwif structures to the default state.
+ *	This is raving bonkers.
+ */
+
+void ide_unregister(unsigned int index)
+{
+	ide_drive_t *drive;
+	ide_hwif_t *hwif, *g;
+	static ide_hwif_t tmp_hwif; /* protected by ide_cfg_sem */
+	ide_hwgroup_t *hwgroup;
+	int irq_count = 0, unit, i;
+
+	BUG_ON(index >= MAX_HWIFS);
+
+	BUG_ON(in_interrupt());
+	BUG_ON(irqs_disabled());
+	down(&ide_cfg_sem);
+	spin_lock_irq(&ide_lock);
+	hwif = &ide_hwifs[index];
+	if (!hwif->present)
+		goto abort;
+	for (unit = 0; unit < MAX_DRIVES; ++unit) {
+		drive = &hwif->drives[unit];
+		if (!drive->present)
+			continue;
+		if (drive->usage || DRIVER(drive)->busy)
+			goto abort;
+		drive->dead = 1;
+	}
+	hwif->present = 0;
+
+	spin_unlock_irq(&ide_lock);
+
+	for (unit = 0; unit < MAX_DRIVES; ++unit) {
+		drive = &hwif->drives[unit];
+		if (!drive->present)
+			continue;
+		DRIVER(drive)->cleanup(drive);
+	}
+
+	destroy_proc_ide_interface(hwif);
+
+	hwgroup = hwif->hwgroup;
+	/*
+	 * free the irq if we were the only hwif using it
+	 */
+	g = hwgroup->hwif;
+	do {
+		if (g->irq == hwif->irq)
+			++irq_count;
+		g = g->next;
+	} while (g != hwgroup->hwif);
+	if (irq_count == 1)
+		free_irq(hwif->irq, hwgroup);
+
+	spin_lock_irq(&ide_lock);
+	/*
+	 * Note that we only release the standard ports,
+	 * and do not even try to handle any extra ports
+	 * allocated for weird IDE interface chipsets.
+	 */
+	ide_hwif_release_regions(hwif);
+
+	/*
+	 * Remove us from the hwgroup, and free
+	 * the hwgroup if we were the only member
+	 */
+	for (i = 0; i < MAX_DRIVES; ++i) {
+		drive = &hwif->drives[i];
+		if (drive->devfs_name[0] != '\0') {
+			devfs_remove(drive->devfs_name);
+			drive->devfs_name[0] = '\0';
+		}
+		if (!drive->present)
+			continue;
+		if (drive == drive->next) {
+			/* special case: last drive from hwgroup. */
+			BUG_ON(hwgroup->drive != drive);
+			hwgroup->drive = NULL;
+		} else {
+			ide_drive_t *walk;
+
+			walk = hwgroup->drive;
+			while (walk->next != drive)
+				walk = walk->next;
+			walk->next = drive->next;
+			if (hwgroup->drive == drive) {
+				hwgroup->drive = drive->next;
+				hwgroup->hwif = HWIF(hwgroup->drive);
+			}
+		}
+		BUG_ON(hwgroup->drive == drive);
+		if (drive->id != NULL) {
+			kfree(drive->id);
+			drive->id = NULL;
+		}
+		drive->present = 0;
+		/* Messed up locking ... */
+		spin_unlock_irq(&ide_lock);
+		blk_cleanup_queue(drive->queue);
+		device_unregister(&drive->gendev);
+		down(&drive->gendev_rel_sem);
+		spin_lock_irq(&ide_lock);
+		drive->queue = NULL;
+	}
+	if (hwif->next == hwif) {
+		BUG_ON(hwgroup->hwif != hwif);
+		kfree(hwgroup);
+	} else {
+		/* There is another interface in hwgroup.
+		 * Unlink us, and set hwgroup->drive and ->hwif to
+		 * something sane.
+		 */
+		g = hwgroup->hwif;
+		while (g->next != hwif)
+			g = g->next;
+		g->next = hwif->next;
+		if (hwgroup->hwif == hwif) {
+			/* Chose a random hwif for hwgroup->hwif.
+			 * It's guaranteed that there are no drives
+			 * left in the hwgroup.
+			 */
+			BUG_ON(hwgroup->drive != NULL);
+			hwgroup->hwif = g;
+		}
+		BUG_ON(hwgroup->hwif == hwif);
+	}
+
+	/* More messed up locking ... */
+	spin_unlock_irq(&ide_lock);
+	device_unregister(&hwif->gendev);
+	down(&hwif->gendev_rel_sem);
+
+	/*
+	 * Remove us from the kernel's knowledge
+	 */
+	blk_unregister_region(MKDEV(hwif->major, 0), MAX_DRIVES<<PARTN_BITS);
+	kfree(hwif->sg_table);
+	unregister_blkdev(hwif->major, hwif->name);
+	spin_lock_irq(&ide_lock);
+
+	if (hwif->dma_base) {
+		(void) ide_release_dma(hwif);
+
+		hwif->dma_base = 0;
+		hwif->dma_master = 0;
+		hwif->dma_command = 0;
+		hwif->dma_vendor1 = 0;
+		hwif->dma_status = 0;
+		hwif->dma_vendor3 = 0;
+		hwif->dma_prdtable = 0;
+	}
+
+	/* copy original settings */
+	tmp_hwif = *hwif;
+
+	/* restore hwif data to pristine status */
+	init_hwif_data(hwif, index);
+	init_hwif_default(hwif, index);
+
+	ide_hwif_restore(hwif, &tmp_hwif);
+
+abort:
+	spin_unlock_irq(&ide_lock);
+	up(&ide_cfg_sem);
+}
+
+EXPORT_SYMBOL(ide_unregister);
+
+
+/**
+ *	ide_setup_ports 	-	set up IDE interface ports
+ *	@hw: register descriptions
+ *	@base: base register
+ *	@offsets: table of register offsets
+ *	@ctrl: control register
+ *	@ack_irq: IRQ ack
+ *	@irq: interrupt lie
+ *
+ *	Setup hw_regs_t structure described by parameters.  You
+ *	may set up the hw structure yourself OR use this routine to
+ *	do it for you. This is basically a helper
+ *
+ */
+ 
+void ide_setup_ports (	hw_regs_t *hw,
+			unsigned long base, int *offsets,
+			unsigned long ctrl, unsigned long intr,
+			ide_ack_intr_t *ack_intr,
+/*
+ *			ide_io_ops_t *iops,
+ */
+			int irq)
+{
+	int i;
+
+	for (i = 0; i < IDE_NR_PORTS; i++) {
+		if (offsets[i] == -1) {
+			switch(i) {
+				case IDE_CONTROL_OFFSET:
+					hw->io_ports[i] = ctrl;
+					break;
+#if defined(CONFIG_AMIGA) || defined(CONFIG_MAC)
+				case IDE_IRQ_OFFSET:
+					hw->io_ports[i] = intr;
+					break;
+#endif /* (CONFIG_AMIGA) || (CONFIG_MAC) */
+				default:
+					hw->io_ports[i] = 0;
+					break;
+			}
+		} else {
+			hw->io_ports[i] = base + offsets[i];
+		}
+	}
+	hw->irq = irq;
+	hw->dma = NO_DMA;
+	hw->ack_intr = ack_intr;
+/*
+ *	hw->iops = iops;
+ */
+}
+
+/**
+ *	ide_register_hw_with_fixup	-	register IDE interface
+ *	@hw: hardware registers
+ *	@hwifp: pointer to returned hwif
+ *	@fixup: fixup function
+ *
+ *	Register an IDE interface, specifying exactly the registers etc.
+ *	Set init=1 iff calling before probes have taken place.
+ *
+ *	Returns -1 on error.
+ */
+
+int ide_register_hw_with_fixup(hw_regs_t *hw, ide_hwif_t **hwifp, void(*fixup)(ide_hwif_t *hwif))
+{
+	int index, retry = 1;
+	ide_hwif_t *hwif;
+
+	do {
+		for (index = 0; index < MAX_HWIFS; ++index) {
+			hwif = &ide_hwifs[index];
+			if (hwif->hw.io_ports[IDE_DATA_OFFSET] == hw->io_ports[IDE_DATA_OFFSET])
+				goto found;
+		}
+		for (index = 0; index < MAX_HWIFS; ++index) {
+			hwif = &ide_hwifs[index];
+			if (hwif->hold)
+				continue;
+			if ((!hwif->present && !hwif->mate && !initializing) ||
+			    (!hwif->hw.io_ports[IDE_DATA_OFFSET] && initializing))
+				goto found;
+		}
+		for (index = 0; index < MAX_HWIFS; index++)
+			ide_unregister(index);
+	} while (retry--);
+	return -1;
+found:
+	if (hwif->present)
+		ide_unregister(index);
+	else if (!hwif->hold) {
+		init_hwif_data(hwif, index);
+		init_hwif_default(hwif, index);
+	}
+	if (hwif->present)
+		return -1;
+	memcpy(&hwif->hw, hw, sizeof(*hw));
+	memcpy(hwif->io_ports, hwif->hw.io_ports, sizeof(hwif->hw.io_ports));
+	hwif->irq = hw->irq;
+	hwif->noprobe = 0;
+	hwif->chipset = hw->chipset;
+
+	if (!initializing) {
+		probe_hwif_init_with_fixup(hwif, fixup);
+		create_proc_ide_interfaces();
+	}
+
+	if (hwifp)
+		*hwifp = hwif;
+
+	return (initializing || hwif->present) ? index : -1;
+}
+
+EXPORT_SYMBOL(ide_register_hw_with_fixup);
+
+int ide_register_hw(hw_regs_t *hw, ide_hwif_t **hwifp)
+{
+	return ide_register_hw_with_fixup(hw, hwifp, NULL);
+}
+
+EXPORT_SYMBOL(ide_register_hw);
+
+/*
+ *	Locks for IDE setting functionality
+ */
+
+DECLARE_MUTEX(ide_setting_sem);
+
+/**
+ *	__ide_add_setting	-	add an ide setting option
+ *	@drive: drive to use
+ *	@name: setting name
+ *	@rw: true if the function is read write
+ *	@read_ioctl: function to call on read
+ *	@write_ioctl: function to call on write
+ *	@data_type: type of data
+ *	@min: range minimum
+ *	@max: range maximum
+ *	@mul_factor: multiplication scale
+ *	@div_factor: divison scale
+ *	@data: private data field
+ *	@set: setting
+ *	@auto_remove: setting auto removal flag
+ *
+ *	Removes the setting named from the device if it is present.
+ *	The function takes the settings_lock to protect against 
+ *	parallel changes. This function must not be called from IRQ
+ *	context. Returns 0 on success or -1 on failure.
+ *
+ *	BUGS: This code is seriously over-engineered. There is also
+ *	magic about how the driver specific features are setup. If
+ *	a driver is attached we assume the driver settings are auto
+ *	remove.
+ */
+
+static int __ide_add_setting(ide_drive_t *drive, const char *name, int rw, int read_ioctl, int write_ioctl, int data_type, int min, int max, int mul_factor, int div_factor, void *data, ide_procset_t *set, int auto_remove)
+{
+	ide_settings_t **p = (ide_settings_t **) &drive->settings, *setting = NULL;
+
+	down(&ide_setting_sem);
+	while ((*p) && strcmp((*p)->name, name) < 0)
+		p = &((*p)->next);
+	if ((setting = kmalloc(sizeof(*setting), GFP_KERNEL)) == NULL)
+		goto abort;
+	memset(setting, 0, sizeof(*setting));
+	if ((setting->name = kmalloc(strlen(name) + 1, GFP_KERNEL)) == NULL)
+		goto abort;
+	strcpy(setting->name, name);
+	setting->rw = rw;
+	setting->read_ioctl = read_ioctl;
+	setting->write_ioctl = write_ioctl;
+	setting->data_type = data_type;
+	setting->min = min;
+	setting->max = max;
+	setting->mul_factor = mul_factor;
+	setting->div_factor = div_factor;
+	setting->data = data;
+	setting->set = set;
+	
+	setting->next = *p;
+	if (auto_remove)
+		setting->auto_remove = 1;
+	*p = setting;
+	up(&ide_setting_sem);
+	return 0;
+abort:
+	up(&ide_setting_sem);
+	if (setting)
+		kfree(setting);
+	return -1;
+}
+
+int ide_add_setting(ide_drive_t *drive, const char *name, int rw, int read_ioctl, int write_ioctl, int data_type, int min, int max, int mul_factor, int div_factor, void *data, ide_procset_t *set)
+{
+	return __ide_add_setting(drive, name, rw, read_ioctl, write_ioctl, data_type, min, max, mul_factor, div_factor, data, set, 1);
+}
+
+EXPORT_SYMBOL(ide_add_setting);
+
+/**
+ *	__ide_remove_setting	-	remove an ide setting option
+ *	@drive: drive to use
+ *	@name: setting name
+ *
+ *	Removes the setting named from the device if it is present.
+ *	The caller must hold the setting semaphore.
+ */
+ 
+static void __ide_remove_setting (ide_drive_t *drive, char *name)
+{
+	ide_settings_t **p, *setting;
+
+	p = (ide_settings_t **) &drive->settings;
+
+	while ((*p) && strcmp((*p)->name, name))
+		p = &((*p)->next);
+	if ((setting = (*p)) == NULL)
+		return;
+
+	(*p) = setting->next;
+	
+	kfree(setting->name);
+	kfree(setting);
+}
+
+/**
+ *	ide_find_setting_by_ioctl	-	find a drive specific ioctl
+ *	@drive: drive to scan
+ *	@cmd: ioctl command to handle
+ *
+ *	Scan's the device setting table for a matching entry and returns
+ *	this or NULL if no entry is found. The caller must hold the
+ *	setting semaphore
+ */
+ 
+static ide_settings_t *ide_find_setting_by_ioctl (ide_drive_t *drive, int cmd)
+{
+	ide_settings_t *setting = drive->settings;
+
+	while (setting) {
+		if (setting->read_ioctl == cmd || setting->write_ioctl == cmd)
+			break;
+		setting = setting->next;
+	}
+	
+	return setting;
+}
+
+/**
+ *	ide_find_setting_by_name	-	find a drive specific setting
+ *	@drive: drive to scan
+ *	@name: setting name
+ *
+ *	Scan's the device setting table for a matching entry and returns
+ *	this or NULL if no entry is found. The caller must hold the
+ *	setting semaphore
+ */
+ 
+ide_settings_t *ide_find_setting_by_name (ide_drive_t *drive, char *name)
+{
+	ide_settings_t *setting = drive->settings;
+
+	while (setting) {
+		if (strcmp(setting->name, name) == 0)
+			break;
+		setting = setting->next;
+	}
+	return setting;
+}
+
+/**
+ *	auto_remove_settings	-	remove driver specific settings
+ *	@drive: drive
+ *
+ *	Automatically remove all the driver specific settings for this
+ *	drive. This function may sleep and must not be called from IRQ
+ *	context. The caller must hold ide_setting_sem.
+ */
+ 
+static void auto_remove_settings (ide_drive_t *drive)
+{
+	ide_settings_t *setting;
+repeat:
+	setting = drive->settings;
+	while (setting) {
+		if (setting->auto_remove) {
+			__ide_remove_setting(drive, setting->name);
+			goto repeat;
+		}
+		setting = setting->next;
+	}
+}
+
+/**
+ *	ide_read_setting	-	read an IDE setting
+ *	@drive: drive to read from
+ *	@setting: drive setting
+ *
+ *	Read a drive setting and return the value. The caller
+ *	must hold the ide_setting_sem when making this call.
+ *
+ *	BUGS: the data return and error are the same return value
+ *	so an error -EINVAL and true return of the same value cannot
+ *	be told apart
+ */
+ 
+int ide_read_setting (ide_drive_t *drive, ide_settings_t *setting)
+{
+	int		val = -EINVAL;
+	unsigned long	flags;
+
+	if ((setting->rw & SETTING_READ)) {
+		spin_lock_irqsave(&ide_lock, flags);
+		switch(setting->data_type) {
+			case TYPE_BYTE:
+				val = *((u8 *) setting->data);
+				break;
+			case TYPE_SHORT:
+				val = *((u16 *) setting->data);
+				break;
+			case TYPE_INT:
+			case TYPE_INTA:
+				val = *((u32 *) setting->data);
+				break;
+		}
+		spin_unlock_irqrestore(&ide_lock, flags);
+	}
+	return val;
+}
+
+/**
+ *	ide_spin_wait_hwgroup	-	wait for group
+ *	@drive: drive in the group
+ *
+ *	Wait for an IDE device group to go non busy and then return
+ *	holding the ide_lock which guards the hwgroup->busy status
+ *	and right to use it.
+ */
+
+int ide_spin_wait_hwgroup (ide_drive_t *drive)
+{
+	ide_hwgroup_t *hwgroup = HWGROUP(drive);
+	unsigned long timeout = jiffies + (3 * HZ);
+
+	spin_lock_irq(&ide_lock);
+
+	while (hwgroup->busy) {
+		unsigned long lflags;
+		spin_unlock_irq(&ide_lock);
+		local_irq_set(lflags);
+		if (time_after(jiffies, timeout)) {
+			local_irq_restore(lflags);
+			printk(KERN_ERR "%s: channel busy\n", drive->name);
+			return -EBUSY;
+		}
+		local_irq_restore(lflags);
+		spin_lock_irq(&ide_lock);
+	}
+	return 0;
+}
+
+EXPORT_SYMBOL(ide_spin_wait_hwgroup);
+
+/**
+ *	ide_write_setting	-	read an IDE setting
+ *	@drive: drive to read from
+ *	@setting: drive setting
+ *	@val: value
+ *
+ *	Write a drive setting if it is possible. The caller
+ *	must hold the ide_setting_sem when making this call.
+ *
+ *	BUGS: the data return and error are the same return value
+ *	so an error -EINVAL and true return of the same value cannot
+ *	be told apart
+ *
+ *	FIXME:  This should be changed to enqueue a special request
+ *	to the driver to change settings, and then wait on a sema for completion.
+ *	The current scheme of polling is kludgy, though safe enough.
+ */
+
+int ide_write_setting (ide_drive_t *drive, ide_settings_t *setting, int val)
+{
+	int i;
+	u32 *p;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EACCES;
+	if (!(setting->rw & SETTING_WRITE))
+		return -EPERM;
+	if (val < setting->min || val > setting->max)
+		return -EINVAL;
+	if (setting->set)
+		return setting->set(drive, val);
+	if (ide_spin_wait_hwgroup(drive))
+		return -EBUSY;
+	switch (setting->data_type) {
+		case TYPE_BYTE:
+			*((u8 *) setting->data) = val;
+			break;
+		case TYPE_SHORT:
+			*((u16 *) setting->data) = val;
+			break;
+		case TYPE_INT:
+			*((u32 *) setting->data) = val;
+			break;
+		case TYPE_INTA:
+			p = (u32 *) setting->data;
+			for (i = 0; i < 1 << PARTN_BITS; i++, p++)
+				*p = val;
+			break;
+	}
+	spin_unlock_irq(&ide_lock);
+	return 0;
+}
+
+static int set_io_32bit(ide_drive_t *drive, int arg)
+{
+	drive->io_32bit = arg;
+#ifdef CONFIG_BLK_DEV_DTC2278
+	if (HWIF(drive)->chipset == ide_dtc2278)
+		HWIF(drive)->drives[!drive->select.b.unit].io_32bit = arg;
+#endif /* CONFIG_BLK_DEV_DTC2278 */
+	return 0;
+}
+
+static int set_using_dma (ide_drive_t *drive, int arg)
+{
+#ifdef CONFIG_BLK_DEV_IDEDMA
+	if (!drive->id || !(drive->id->capability & 1))
+		return -EPERM;
+	if (HWIF(drive)->ide_dma_check == NULL)
+		return -EPERM;
+	if (arg) {
+		if (HWIF(drive)->ide_dma_check(drive)) return -EIO;
+		if (HWIF(drive)->ide_dma_on(drive)) return -EIO;
+	} else {
+		if (__ide_dma_off(drive))
+			return -EIO;
+	}
+	return 0;
+#else
+	return -EPERM;
+#endif
+}
+
+static int set_pio_mode (ide_drive_t *drive, int arg)
+{
+	struct request rq;
+
+	if (!HWIF(drive)->tuneproc)
+		return -ENOSYS;
+	if (drive->special.b.set_tune)
+		return -EBUSY;
+	ide_init_drive_cmd(&rq);
+	drive->tune_req = (u8) arg;
+	drive->special.b.set_tune = 1;
+	(void) ide_do_drive_cmd(drive, &rq, ide_wait);
+	return 0;
+}
+
+static int set_xfer_rate (ide_drive_t *drive, int arg)
+{
+	int err = ide_wait_cmd(drive,
+			WIN_SETFEATURES, (u8) arg,
+			SETFEATURES_XFER, 0, NULL);
+
+	if (!err && arg) {
+		ide_set_xfer_rate(drive, (u8) arg);
+		ide_driveid_update(drive);
+	}
+	return err;
+}
+
+/**
+ *	ide_add_generic_settings	-	generic ide settings
+ *	@drive: drive being configured
+ *
+ *	Add the generic parts of the system settings to the /proc files and
+ *	ioctls for this IDE device. The caller must not be holding the
+ *	ide_setting_sem.
+ */
+
+void ide_add_generic_settings (ide_drive_t *drive)
+{
+/*
+ *			  drive		setting name		read/write access				read ioctl		write ioctl		data type	min	max				mul_factor	div_factor	data pointer			set function
+ */
+	__ide_add_setting(drive,	"io_32bit",		drive->no_io_32bit ? SETTING_READ : SETTING_RW,	HDIO_GET_32BIT,		HDIO_SET_32BIT,		TYPE_BYTE,	0,	1 + (SUPPORT_VLB_SYNC << 1),	1,		1,		&drive->io_32bit,		set_io_32bit,	0);
+	__ide_add_setting(drive,	"keepsettings",		SETTING_RW,					HDIO_GET_KEEPSETTINGS,	HDIO_SET_KEEPSETTINGS,	TYPE_BYTE,	0,	1,				1,		1,		&drive->keep_settings,		NULL,		0);
+	__ide_add_setting(drive,	"nice1",		SETTING_RW,					-1,			-1,			TYPE_BYTE,	0,	1,				1,		1,		&drive->nice1,			NULL,		0);
+	__ide_add_setting(drive,	"pio_mode",		SETTING_WRITE,					-1,			HDIO_SET_PIO_MODE,	TYPE_BYTE,	0,	255,				1,		1,		NULL,				set_pio_mode,	0);
+	__ide_add_setting(drive,	"unmaskirq",		drive->no_unmask ? SETTING_READ : SETTING_RW,	HDIO_GET_UNMASKINTR,	HDIO_SET_UNMASKINTR,	TYPE_BYTE,	0,	1,				1,		1,		&drive->unmask,			NULL,		0);
+	__ide_add_setting(drive,	"using_dma",		SETTING_RW,					HDIO_GET_DMA,		HDIO_SET_DMA,		TYPE_BYTE,	0,	1,				1,		1,		&drive->using_dma,		set_using_dma,	0);
+	__ide_add_setting(drive,	"init_speed",		SETTING_RW,					-1,			-1,			TYPE_BYTE,	0,	70,				1,		1,		&drive->init_speed,		NULL,		0);
+	__ide_add_setting(drive,	"current_speed",	SETTING_RW,					-1,			-1,			TYPE_BYTE,	0,	70,				1,		1,		&drive->current_speed,		set_xfer_rate,	0);
+	__ide_add_setting(drive,	"number",		SETTING_RW,					-1,			-1,			TYPE_BYTE,	0,	3,				1,		1,		&drive->dn,			NULL,		0);
+}
+
+/**
+ *	system_bus_clock	-	clock guess
+ *
+ *	External version of the bus clock guess used by very old IDE drivers
+ *	for things like VLB timings. Should not be used.
+ */
+
+int system_bus_clock (void)
+{
+	return((int) ((!system_bus_speed) ? ide_system_bus_speed() : system_bus_speed ));
+}
+
+EXPORT_SYMBOL(system_bus_clock);
+
+/*
+ *	Locking is badly broken here - since way back.  That sucker is
+ * root-only, but that's not an excuse...  The real question is what
+ * exclusion rules do we want here.
+ */
+int ide_replace_subdriver (ide_drive_t *drive, const char *driver)
+{
+	if (!drive->present || drive->usage || drive->dead)
+		goto abort;
+	if (DRIVER(drive)->cleanup(drive))
+		goto abort;
+	strlcpy(drive->driver_req, driver, sizeof(drive->driver_req));
+	if (ata_attach(drive)) {
+		spin_lock(&drives_lock);
+		list_del_init(&drive->list);
+		spin_unlock(&drives_lock);
+		drive->driver_req[0] = 0;
+		ata_attach(drive);
+	} else {
+		drive->driver_req[0] = 0;
+	}
+	if (drive->driver && !strcmp(drive->driver->name, driver))
+		return 0;
+abort:
+	return 1;
+}
+
+/**
+ *	ata_attach		-	attach an ATA/ATAPI device
+ *	@drive: drive to attach
+ *
+ *	Takes a drive that is as yet not assigned to any midlayer IDE
+ *	driver (or is assigned to the default driver) and figures out
+ *	which driver would like to own it. If nobody claims the drive
+ *	then it is automatically attached to the default driver used for
+ *	unclaimed objects.
+ *
+ *	A return of zero indicates attachment to a driver, of one
+ *	attachment to the default driver.
+ *
+ *	Takes drivers_lock.
+ */
+
+int ata_attach(ide_drive_t *drive)
+{
+	struct list_head *p;
+	spin_lock(&drivers_lock);
+	list_for_each(p, &drivers) {
+		ide_driver_t *driver = list_entry(p, ide_driver_t, drivers);
+		if (!try_module_get(driver->owner))
+			continue;
+		spin_unlock(&drivers_lock);
+		if (driver->attach(drive) == 0) {
+			module_put(driver->owner);
+			drive->gendev.driver = &driver->gen_driver;
+			return 0;
+		}
+		spin_lock(&drivers_lock);
+		module_put(driver->owner);
+	}
+	drive->gendev.driver = NULL;
+	spin_unlock(&drivers_lock);
+	if (ide_register_subdriver(drive, NULL))
+		panic("ide: default attach failed");
+	return 1;
+}
+
+static int generic_ide_suspend(struct device *dev, pm_message_t state)
+{
+	ide_drive_t *drive = dev->driver_data;
+	struct request rq;
+	struct request_pm_state rqpm;
+	ide_task_t args;
+
+	memset(&rq, 0, sizeof(rq));
+	memset(&rqpm, 0, sizeof(rqpm));
+	memset(&args, 0, sizeof(args));
+	rq.flags = REQ_PM_SUSPEND;
+	rq.special = &args;
+	rq.pm = &rqpm;
+	rqpm.pm_step = ide_pm_state_start_suspend;
+	rqpm.pm_state = state;
+
+	return ide_do_drive_cmd(drive, &rq, ide_wait);
+}
+
+static int generic_ide_resume(struct device *dev)
+{
+	ide_drive_t *drive = dev->driver_data;
+	struct request rq;
+	struct request_pm_state rqpm;
+	ide_task_t args;
+
+	memset(&rq, 0, sizeof(rq));
+	memset(&rqpm, 0, sizeof(rqpm));
+	memset(&args, 0, sizeof(args));
+	rq.flags = REQ_PM_RESUME;
+	rq.special = &args;
+	rq.pm = &rqpm;
+	rqpm.pm_step = ide_pm_state_start_resume;
+	rqpm.pm_state = 0;
+
+	return ide_do_drive_cmd(drive, &rq, ide_head_wait);
+}
+
+int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device *bdev,
+			unsigned int cmd, unsigned long arg)
+{
+	ide_settings_t *setting;
+	ide_driver_t *drv;
+	int err = 0;
+	void __user *p = (void __user *)arg;
+
+	down(&ide_setting_sem);
+	if ((setting = ide_find_setting_by_ioctl(drive, cmd)) != NULL) {
+		if (cmd == setting->read_ioctl) {
+			err = ide_read_setting(drive, setting);
+			up(&ide_setting_sem);
+			return err >= 0 ? put_user(err, (long __user *)arg) : err;
+		} else {
+			if (bdev != bdev->bd_contains)
+				err = -EINVAL;
+			else
+				err = ide_write_setting(drive, setting, arg);
+			up(&ide_setting_sem);
+			return err;
+		}
+	}
+	up(&ide_setting_sem);
+
+	switch (cmd) {
+		case HDIO_GETGEO:
+		{
+			struct hd_geometry geom;
+			if (!p || (drive->media != ide_disk && drive->media != ide_floppy)) return -EINVAL;
+			geom.heads = drive->bios_head;
+			geom.sectors = drive->bios_sect;
+			geom.cylinders = (u16)drive->bios_cyl; /* truncate */
+			geom.start = get_start_sect(bdev);
+			if (copy_to_user(p, &geom, sizeof(struct hd_geometry)))
+				return -EFAULT;
+			return 0;
+		}
+
+		case HDIO_OBSOLETE_IDENTITY:
+		case HDIO_GET_IDENTITY:
+			if (bdev != bdev->bd_contains)
+				return -EINVAL;
+			if (drive->id_read == 0)
+				return -ENOMSG;
+			if (copy_to_user(p, drive->id, (cmd == HDIO_GET_IDENTITY) ? sizeof(*drive->id) : 142))
+				return -EFAULT;
+			return 0;
+
+		case HDIO_GET_NICE:
+			return put_user(drive->dsc_overlap	<<	IDE_NICE_DSC_OVERLAP	|
+					drive->atapi_overlap	<<	IDE_NICE_ATAPI_OVERLAP	|
+					drive->nice0		<< 	IDE_NICE_0		|
+					drive->nice1		<<	IDE_NICE_1		|
+					drive->nice2		<<	IDE_NICE_2,
+					(long __user *) arg);
+
+#ifdef CONFIG_IDE_TASK_IOCTL
+		case HDIO_DRIVE_TASKFILE:
+		        if (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))
+				return -EACCES;
+			switch(drive->media) {
+				case ide_disk:
+					return ide_taskfile_ioctl(drive, cmd, arg);
+				default:
+					return -ENOMSG;
+			}
+#endif /* CONFIG_IDE_TASK_IOCTL */
+
+		case HDIO_DRIVE_CMD:
+			if (!capable(CAP_SYS_RAWIO))
+				return -EACCES;
+			return ide_cmd_ioctl(drive, cmd, arg);
+
+		case HDIO_DRIVE_TASK:
+			if (!capable(CAP_SYS_RAWIO))
+				return -EACCES;
+			return ide_task_ioctl(drive, cmd, arg);
+
+		case HDIO_SCAN_HWIF:
+		{
+			hw_regs_t hw;
+			int args[3];
+			if (!capable(CAP_SYS_RAWIO)) return -EACCES;
+			if (copy_from_user(args, p, 3 * sizeof(int)))
+				return -EFAULT;
+			memset(&hw, 0, sizeof(hw));
+			ide_init_hwif_ports(&hw, (unsigned long) args[0],
+					    (unsigned long) args[1], NULL);
+			hw.irq = args[2];
+			if (ide_register_hw(&hw, NULL) == -1)
+				return -EIO;
+			return 0;
+		}
+	        case HDIO_UNREGISTER_HWIF:
+			if (!capable(CAP_SYS_RAWIO)) return -EACCES;
+			/* (arg > MAX_HWIFS) checked in function */
+			ide_unregister(arg);
+			return 0;
+		case HDIO_SET_NICE:
+			if (!capable(CAP_SYS_ADMIN)) return -EACCES;
+			if (arg != (arg & ((1 << IDE_NICE_DSC_OVERLAP) | (1 << IDE_NICE_1))))
+				return -EPERM;
+			drive->dsc_overlap = (arg >> IDE_NICE_DSC_OVERLAP) & 1;
+			drv = *(ide_driver_t **)bdev->bd_disk->private_data;
+			if (drive->dsc_overlap && !drv->supports_dsc_overlap) {
+				drive->dsc_overlap = 0;
+				return -EPERM;
+			}
+			drive->nice1 = (arg >> IDE_NICE_1) & 1;
+			return 0;
+		case HDIO_DRIVE_RESET:
+		{
+			unsigned long flags;
+			if (!capable(CAP_SYS_ADMIN)) return -EACCES;
+			
+			/*
+			 *	Abort the current command on the
+			 *	group if there is one, taking
+			 *	care not to allow anything else
+			 *	to be queued and to die on the
+			 *	spot if we miss one somehow
+			 */
+
+			spin_lock_irqsave(&ide_lock, flags);
+
+			ide_abort(drive, "drive reset");
+
+			if(HWGROUP(drive)->handler)
+				BUG();
+				
+			/* Ensure nothing gets queued after we
+			   drop the lock. Reset will clear the busy */
+		   
+			HWGROUP(drive)->busy = 1;
+			spin_unlock_irqrestore(&ide_lock, flags);
+			(void) ide_do_reset(drive);
+
+			return 0;
+		}
+
+		case CDROMEJECT:
+		case CDROMCLOSETRAY:
+			return scsi_cmd_ioctl(file, bdev->bd_disk, cmd, p);
+
+		case HDIO_GET_BUSSTATE:
+			if (!capable(CAP_SYS_ADMIN))
+				return -EACCES;
+			if (put_user(HWIF(drive)->bus_state, (long __user *)arg))
+				return -EFAULT;
+			return 0;
+
+		case HDIO_SET_BUSSTATE:
+			if (!capable(CAP_SYS_ADMIN))
+				return -EACCES;
+			if (HWIF(drive)->busproc)
+				return HWIF(drive)->busproc(drive, (int)arg);
+			return -EOPNOTSUPP;
+		default:
+			return -EINVAL;
+	}
+}
+
+EXPORT_SYMBOL(generic_ide_ioctl);
+
+/*
+ * stridx() returns the offset of c within s,
+ * or -1 if c is '\0' or not found within s.
+ */
+static int __init stridx (const char *s, char c)
+{
+	char *i = strchr(s, c);
+	return (i && c) ? i - s : -1;
+}
+
+/*
+ * match_parm() does parsing for ide_setup():
+ *
+ * 1. the first char of s must be '='.
+ * 2. if the remainder matches one of the supplied keywords,
+ *     the index (1 based) of the keyword is negated and returned.
+ * 3. if the remainder is a series of no more than max_vals numbers
+ *     separated by commas, the numbers are saved in vals[] and a
+ *     count of how many were saved is returned.  Base10 is assumed,
+ *     and base16 is allowed when prefixed with "0x".
+ * 4. otherwise, zero is returned.
+ */
+static int __init match_parm (char *s, const char *keywords[], int vals[], int max_vals)
+{
+	static const char *decimal = "0123456789";
+	static const char *hex = "0123456789abcdef";
+	int i, n;
+
+	if (*s++ == '=') {
+		/*
+		 * Try matching against the supplied keywords,
+		 * and return -(index+1) if we match one
+		 */
+		if (keywords != NULL) {
+			for (i = 0; *keywords != NULL; ++i) {
+				if (!strcmp(s, *keywords++))
+					return -(i+1);
+			}
+		}
+		/*
+		 * Look for a series of no more than "max_vals"
+		 * numeric values separated by commas, in base10,
+		 * or base16 when prefixed with "0x".
+		 * Return a count of how many were found.
+		 */
+		for (n = 0; (i = stridx(decimal, *s)) >= 0;) {
+			vals[n] = i;
+			while ((i = stridx(decimal, *++s)) >= 0)
+				vals[n] = (vals[n] * 10) + i;
+			if (*s == 'x' && !vals[n]) {
+				while ((i = stridx(hex, *++s)) >= 0)
+					vals[n] = (vals[n] * 0x10) + i;
+			}
+			if (++n == max_vals)
+				break;
+			if (*s == ',' || *s == ';')
+				++s;
+		}
+		if (!*s)
+			return n;
+	}
+	return 0;	/* zero = nothing matched */
+}
+
+#ifdef CONFIG_BLK_DEV_ALI14XX
+static int __initdata probe_ali14xx;
+extern int ali14xx_init(void);
+#endif
+#ifdef CONFIG_BLK_DEV_UMC8672
+static int __initdata probe_umc8672;
+extern int umc8672_init(void);
+#endif
+#ifdef CONFIG_BLK_DEV_DTC2278
+static int __initdata probe_dtc2278;
+extern int dtc2278_init(void);
+#endif
+#ifdef CONFIG_BLK_DEV_HT6560B
+static int __initdata probe_ht6560b;
+extern int ht6560b_init(void);
+#endif
+#ifdef CONFIG_BLK_DEV_QD65XX
+static int __initdata probe_qd65xx;
+extern int qd65xx_init(void);
+#endif
+
+static int __initdata is_chipset_set[MAX_HWIFS];
+
+/*
+ * ide_setup() gets called VERY EARLY during initialization,
+ * to handle kernel "command line" strings beginning with "hdx=" or "ide".
+ *
+ * Remember to update Documentation/ide.txt if you change something here.
+ */
+static int __init ide_setup(char *s)
+{
+	int i, vals[3];
+	ide_hwif_t *hwif;
+	ide_drive_t *drive;
+	unsigned int hw, unit;
+	const char max_drive = 'a' + ((MAX_HWIFS * MAX_DRIVES) - 1);
+	const char max_hwif  = '0' + (MAX_HWIFS - 1);
+
+	
+	if (strncmp(s,"hd",2) == 0 && s[2] == '=')	/* hd= is for hd.c   */
+		return 0;				/* driver and not us */
+
+	if (strncmp(s,"ide",3) && strncmp(s,"idebus",6) && strncmp(s,"hd",2))
+		return 0;
+
+	printk(KERN_INFO "ide_setup: %s", s);
+	init_ide_data ();
+
+#ifdef CONFIG_BLK_DEV_IDEDOUBLER
+	if (!strcmp(s, "ide=doubler")) {
+		extern int ide_doubler;
+
+		printk(" : Enabled support for IDE doublers\n");
+		ide_doubler = 1;
+		return 1;
+	}
+#endif /* CONFIG_BLK_DEV_IDEDOUBLER */
+
+	if (!strcmp(s, "ide=nodma")) {
+		printk(" : Prevented DMA\n");
+		noautodma = 1;
+		return 1;
+	}
+
+#ifdef CONFIG_BLK_DEV_IDEPCI
+	if (!strcmp(s, "ide=reverse")) {
+		ide_scan_direction = 1;
+		printk(" : Enabled support for IDE inverse scan order.\n");
+		return 1;
+	}
+#endif /* CONFIG_BLK_DEV_IDEPCI */
+
+	/*
+	 * Look for drive options:  "hdx="
+	 */
+	if (s[0] == 'h' && s[1] == 'd' && s[2] >= 'a' && s[2] <= max_drive) {
+		const char *hd_words[] = {
+			"none", "noprobe", "nowerr", "cdrom", "serialize",
+			"autotune", "noautotune", "minus8", "swapdata", "bswap",
+			"minus11", "remap", "remap63", "scsi", NULL };
+		unit = s[2] - 'a';
+		hw   = unit / MAX_DRIVES;
+		unit = unit % MAX_DRIVES;
+		hwif = &ide_hwifs[hw];
+		drive = &hwif->drives[unit];
+		if (strncmp(s + 4, "ide-", 4) == 0) {
+			strlcpy(drive->driver_req, s + 4, sizeof(drive->driver_req));
+			goto done;
+		}
+		switch (match_parm(&s[3], hd_words, vals, 3)) {
+			case -1: /* "none" */
+			case -2: /* "noprobe" */
+				drive->noprobe = 1;
+				goto done;
+			case -3: /* "nowerr" */
+				drive->bad_wstat = BAD_R_STAT;
+				hwif->noprobe = 0;
+				goto done;
+			case -4: /* "cdrom" */
+				drive->present = 1;
+				drive->media = ide_cdrom;
+				/* an ATAPI device ignores DRDY */
+				drive->ready_stat = 0;
+				hwif->noprobe = 0;
+				goto done;
+			case -5: /* "serialize" */
+				printk(" -- USE \"ide%d=serialize\" INSTEAD", hw);
+				goto do_serialize;
+			case -6: /* "autotune" */
+				drive->autotune = IDE_TUNE_AUTO;
+				goto obsolete_option;
+			case -7: /* "noautotune" */
+				drive->autotune = IDE_TUNE_NOAUTO;
+				goto obsolete_option;
+			case -9: /* "swapdata" */
+			case -10: /* "bswap" */
+				drive->bswap = 1;
+				goto done;
+			case -12: /* "remap" */
+				drive->remap_0_to_1 = 1;
+				goto done;
+			case -13: /* "remap63" */
+				drive->sect0 = 63;
+				goto done;
+			case -14: /* "scsi" */
+				drive->scsi = 1;
+				goto done;
+			case 3: /* cyl,head,sect */
+				drive->media	= ide_disk;
+				drive->ready_stat = READY_STAT;
+				drive->cyl	= drive->bios_cyl  = vals[0];
+				drive->head	= drive->bios_head = vals[1];
+				drive->sect	= drive->bios_sect = vals[2];
+				drive->present	= 1;
+				drive->forced_geom = 1;
+				hwif->noprobe = 0;
+				goto done;
+			default:
+				goto bad_option;
+		}
+	}
+
+	if (s[0] != 'i' || s[1] != 'd' || s[2] != 'e')
+		goto bad_option;
+	/*
+	 * Look for bus speed option:  "idebus="
+	 */
+	if (s[3] == 'b' && s[4] == 'u' && s[5] == 's') {
+		if (match_parm(&s[6], NULL, vals, 1) != 1)
+			goto bad_option;
+		if (vals[0] >= 20 && vals[0] <= 66) {
+			idebus_parameter = vals[0];
+		} else
+			printk(" -- BAD BUS SPEED! Expected value from 20 to 66");
+		goto done;
+	}
+	/*
+	 * Look for interface options:  "idex="
+	 */
+	if (s[3] >= '0' && s[3] <= max_hwif) {
+		/*
+		 * Be VERY CAREFUL changing this: note hardcoded indexes below
+		 * (-8, -9, -10) are reserved to ease the hardcoding.
+		 */
+		static const char *ide_words[] = {
+			"noprobe", "serialize", "autotune", "noautotune", 
+			"reset", "dma", "ata66", "minus8", "minus9",
+			"minus10", "four", "qd65xx", "ht6560b", "cmd640_vlb",
+			"dtc2278", "umc8672", "ali14xx", NULL };
+		hw = s[3] - '0';
+		hwif = &ide_hwifs[hw];
+		i = match_parm(&s[4], ide_words, vals, 3);
+
+		/*
+		 * Cryptic check to ensure chipset not already set for hwif.
+		 * Note: we can't depend on hwif->chipset here.
+		 */
+		if ((i >= -18 && i <= -11) || (i > 0 && i <= 3)) {
+			/* chipset already specified */
+			if (is_chipset_set[hw])
+				goto bad_option;
+			if (i > -18 && i <= -11) {
+				/* these drivers are for "ide0=" only */
+				if (hw != 0)
+					goto bad_hwif;
+				/* chipset already specified for 2nd port */
+				if (is_chipset_set[hw+1])
+					goto bad_option;
+			}
+			is_chipset_set[hw] = 1;
+			printk("\n");
+		}
+
+		switch (i) {
+#ifdef CONFIG_BLK_DEV_ALI14XX
+			case -17: /* "ali14xx" */
+				probe_ali14xx = 1;
+				goto done;
+#endif
+#ifdef CONFIG_BLK_DEV_UMC8672
+			case -16: /* "umc8672" */
+				probe_umc8672 = 1;
+				goto done;
+#endif
+#ifdef CONFIG_BLK_DEV_DTC2278
+			case -15: /* "dtc2278" */
+				probe_dtc2278 = 1;
+				goto done;
+#endif
+#ifdef CONFIG_BLK_DEV_CMD640
+			case -14: /* "cmd640_vlb" */
+			{
+				extern int cmd640_vlb; /* flag for cmd640.c */
+				cmd640_vlb = 1;
+				goto done;
+			}
+#endif
+#ifdef CONFIG_BLK_DEV_HT6560B
+			case -13: /* "ht6560b" */
+				probe_ht6560b = 1;
+				goto done;
+#endif
+#ifdef CONFIG_BLK_DEV_QD65XX
+			case -12: /* "qd65xx" */
+				probe_qd65xx = 1;
+				goto done;
+#endif
+#ifdef CONFIG_BLK_DEV_4DRIVES
+			case -11: /* "four" drives on one set of ports */
+			{
+				ide_hwif_t *mate = &ide_hwifs[hw^1];
+				mate->drives[0].select.all ^= 0x20;
+				mate->drives[1].select.all ^= 0x20;
+				hwif->chipset = mate->chipset = ide_4drives;
+				mate->irq = hwif->irq;
+				memcpy(mate->io_ports, hwif->io_ports, sizeof(hwif->io_ports));
+				goto do_serialize;
+			}
+#endif /* CONFIG_BLK_DEV_4DRIVES */
+			case -10: /* minus10 */
+			case -9: /* minus9 */
+			case -8: /* minus8 */
+				goto bad_option;
+			case -7: /* ata66 */
+#ifdef CONFIG_BLK_DEV_IDEPCI
+				hwif->udma_four = 1;
+				goto obsolete_option;
+#else
+				goto bad_hwif;
+#endif
+			case -6: /* dma */
+				hwif->autodma = 1;
+				goto obsolete_option;
+			case -5: /* "reset" */
+				hwif->reset = 1;
+				goto obsolete_option;
+			case -4: /* "noautotune" */
+				hwif->drives[0].autotune = IDE_TUNE_NOAUTO;
+				hwif->drives[1].autotune = IDE_TUNE_NOAUTO;
+				goto obsolete_option;
+			case -3: /* "autotune" */
+				hwif->drives[0].autotune = IDE_TUNE_AUTO;
+				hwif->drives[1].autotune = IDE_TUNE_AUTO;
+				goto obsolete_option;
+			case -2: /* "serialize" */
+			do_serialize:
+				hwif->mate = &ide_hwifs[hw^1];
+				hwif->mate->mate = hwif;
+				hwif->serialized = hwif->mate->serialized = 1;
+				goto obsolete_option;
+
+			case -1: /* "noprobe" */
+				hwif->noprobe = 1;
+				goto done;
+
+			case 1:	/* base */
+				vals[1] = vals[0] + 0x206; /* default ctl */
+			case 2: /* base,ctl */
+				vals[2] = 0;	/* default irq = probe for it */
+			case 3: /* base,ctl,irq */
+				hwif->hw.irq = vals[2];
+				ide_init_hwif_ports(&hwif->hw, (unsigned long) vals[0], (unsigned long) vals[1], &hwif->irq);
+				memcpy(hwif->io_ports, hwif->hw.io_ports, sizeof(hwif->io_ports));
+				hwif->irq      = vals[2];
+				hwif->noprobe  = 0;
+				hwif->chipset  = ide_forced;
+				goto obsolete_option;
+
+			case 0: goto bad_option;
+			default:
+				printk(" -- SUPPORT NOT CONFIGURED IN THIS KERNEL\n");
+				return 1;
+		}
+	}
+bad_option:
+	printk(" -- BAD OPTION\n");
+	return 1;
+obsolete_option:
+	printk(" -- OBSOLETE OPTION, WILL BE REMOVED SOON!\n");
+	return 1;
+bad_hwif:
+	printk("-- NOT SUPPORTED ON ide%d", hw);
+done:
+	printk("\n");
+	return 1;
+}
+
+extern void pnpide_init(void);
+extern void h8300_ide_init(void);
+
+/*
+ * probe_for_hwifs() finds/initializes "known" IDE interfaces
+ */
+static void __init probe_for_hwifs (void)
+{
+#ifdef CONFIG_BLK_DEV_IDEPCI
+	ide_scan_pcibus(ide_scan_direction);
+#endif /* CONFIG_BLK_DEV_IDEPCI */
+
+#ifdef CONFIG_ETRAX_IDE
+	{
+		extern void init_e100_ide(void);
+		init_e100_ide();
+	}
+#endif /* CONFIG_ETRAX_IDE */
+#ifdef CONFIG_BLK_DEV_CMD640
+	{
+		extern void ide_probe_for_cmd640x(void);
+		ide_probe_for_cmd640x();
+	}
+#endif /* CONFIG_BLK_DEV_CMD640 */
+#ifdef CONFIG_BLK_DEV_IDE_PMAC
+	{
+		extern void pmac_ide_probe(void);
+		pmac_ide_probe();
+	}
+#endif /* CONFIG_BLK_DEV_IDE_PMAC */
+#ifdef CONFIG_BLK_DEV_GAYLE
+	{
+		extern void gayle_init(void);
+		gayle_init();
+	}
+#endif /* CONFIG_BLK_DEV_GAYLE */
+#ifdef CONFIG_BLK_DEV_FALCON_IDE
+	{
+		extern void falconide_init(void);
+		falconide_init();
+	}
+#endif /* CONFIG_BLK_DEV_FALCON_IDE */
+#ifdef CONFIG_BLK_DEV_MAC_IDE
+	{
+		extern void macide_init(void);
+		macide_init();
+	}
+#endif /* CONFIG_BLK_DEV_MAC_IDE */
+#ifdef CONFIG_BLK_DEV_Q40IDE
+	{
+		extern void q40ide_init(void);
+		q40ide_init();
+	}
+#endif /* CONFIG_BLK_DEV_Q40IDE */
+#ifdef CONFIG_BLK_DEV_BUDDHA
+	{
+		extern void buddha_init(void);
+		buddha_init();
+	}
+#endif /* CONFIG_BLK_DEV_BUDDHA */
+#ifdef CONFIG_BLK_DEV_IDEPNP
+	pnpide_init();
+#endif
+#ifdef CONFIG_H8300
+	h8300_ide_init();
+#endif
+}
+
+int ide_register_subdriver(ide_drive_t *drive, ide_driver_t *driver)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ide_lock, flags);
+	if (!drive->present || drive->driver != NULL ||
+	    drive->usage || drive->dead) {
+		spin_unlock_irqrestore(&ide_lock, flags);
+		return 1;
+	}
+	drive->driver = driver;
+	spin_unlock_irqrestore(&ide_lock, flags);
+	spin_lock(&drives_lock);
+	list_add_tail(&drive->list, driver ? &driver->drives : &ide_drives);
+	spin_unlock(&drives_lock);
+//	printk(KERN_INFO "%s: attached %s driver.\n", drive->name, driver->name);
+#ifdef CONFIG_PROC_FS
+	if (driver)
+		ide_add_proc_entries(drive->proc, driver->proc, drive);
+#endif
+	return 0;
+}
+
+EXPORT_SYMBOL(ide_register_subdriver);
+
+/**
+ *	ide_unregister_subdriver	-	disconnect drive from driver
+ *	@drive: drive to unplug
+ *
+ *	Disconnect a drive from the driver it was attached to and then
+ *	clean up the various proc files and other objects attached to it.
+ *
+ *	Takes ide_setting_sem, ide_lock and drives_lock.
+ *	Caller must hold none of the locks.
+ *
+ *	No locking versus subdriver unload because we are moving to the
+ *	default driver anyway. Wants double checking.
+ */
+
+int ide_unregister_subdriver (ide_drive_t *drive)
+{
+	unsigned long flags;
+	
+	down(&ide_setting_sem);
+	spin_lock_irqsave(&ide_lock, flags);
+	if (drive->usage || drive->driver == NULL || DRIVER(drive)->busy) {
+		spin_unlock_irqrestore(&ide_lock, flags);
+		up(&ide_setting_sem);
+		return 1;
+	}
+#ifdef CONFIG_PROC_FS
+	ide_remove_proc_entries(drive->proc, DRIVER(drive)->proc);
+#endif
+	auto_remove_settings(drive);
+	drive->driver = NULL;
+	spin_unlock_irqrestore(&ide_lock, flags);
+	up(&ide_setting_sem);
+	spin_lock(&drives_lock);
+	list_del_init(&drive->list);
+	spin_unlock(&drives_lock);
+	/* drive will be added to &ide_drives in ata_attach() */
+	return 0;
+}
+
+EXPORT_SYMBOL(ide_unregister_subdriver);
+
+static int ide_drive_remove(struct device * dev)
+{
+	ide_drive_t * drive = container_of(dev,ide_drive_t,gendev);
+	DRIVER(drive)->cleanup(drive);
+	return 0;
+}
+
+/**
+ *	ide_register_driver	-	register IDE device driver
+ *	@driver: the IDE device driver
+ *
+ *	Register a new device driver and then scan the devices
+ *	on the IDE bus in case any should be attached to the
+ *	driver we have just registered.  If so attach them.
+ *
+ *	Takes drivers_lock and drives_lock.
+ */
+
+int ide_register_driver(ide_driver_t *driver)
+{
+	struct list_head list;
+	struct list_head *list_loop;
+	struct list_head *tmp_storage;
+
+	spin_lock(&drivers_lock);
+	list_add(&driver->drivers, &drivers);
+	spin_unlock(&drivers_lock);
+
+	INIT_LIST_HEAD(&list);
+	spin_lock(&drives_lock);
+	list_splice_init(&ide_drives, &list);
+	spin_unlock(&drives_lock);
+
+	list_for_each_safe(list_loop, tmp_storage, &list) {
+		ide_drive_t *drive = container_of(list_loop, ide_drive_t, list);
+		list_del_init(&drive->list);
+		if (drive->present)
+			ata_attach(drive);
+	}
+	driver->gen_driver.name = (char *) driver->name;
+	driver->gen_driver.bus = &ide_bus_type;
+	driver->gen_driver.remove = ide_drive_remove;
+	return driver_register(&driver->gen_driver);
+}
+
+EXPORT_SYMBOL(ide_register_driver);
+
+/**
+ *	ide_unregister_driver	-	unregister IDE device driver
+ *	@driver: the IDE device driver
+ *
+ *	Called when a driver module is being unloaded. We reattach any
+ *	devices to whatever driver claims them next (typically the default
+ *	driver).
+ *
+ *	Takes drivers_lock and called functions will take ide_setting_sem.
+ */
+
+void ide_unregister_driver(ide_driver_t *driver)
+{
+	ide_drive_t *drive;
+
+	spin_lock(&drivers_lock);
+	list_del(&driver->drivers);
+	spin_unlock(&drivers_lock);
+
+	driver_unregister(&driver->gen_driver);
+
+	while(!list_empty(&driver->drives)) {
+		drive = list_entry(driver->drives.next, ide_drive_t, list);
+		if (driver->cleanup(drive)) {
+			printk(KERN_ERR "%s: cleanup_module() called while still busy\n", drive->name);
+			BUG();
+		}
+		ata_attach(drive);
+	}
+}
+
+EXPORT_SYMBOL(ide_unregister_driver);
+
+/*
+ * Probe module
+ */
+
+EXPORT_SYMBOL(ide_lock);
+
+struct bus_type ide_bus_type = {
+	.name		= "ide",
+	.suspend	= generic_ide_suspend,
+	.resume		= generic_ide_resume,
+};
+
+/*
+ * This is gets invoked once during initialization, to set *everything* up
+ */
+static int __init ide_init(void)
+{
+	printk(KERN_INFO "Uniform Multi-Platform E-IDE driver " REVISION "\n");
+	devfs_mk_dir("ide");
+	system_bus_speed = ide_system_bus_speed();
+
+	bus_register(&ide_bus_type);
+
+	init_ide_data();
+
+#ifdef CONFIG_PROC_FS
+	proc_ide_root = proc_mkdir("ide", NULL);
+#endif
+
+#ifdef CONFIG_BLK_DEV_ALI14XX
+	if (probe_ali14xx)
+		(void)ali14xx_init();
+#endif
+#ifdef CONFIG_BLK_DEV_UMC8672
+	if (probe_umc8672)
+		(void)umc8672_init();
+#endif
+#ifdef CONFIG_BLK_DEV_DTC2278
+	if (probe_dtc2278)
+		(void)dtc2278_init();
+#endif
+#ifdef CONFIG_BLK_DEV_HT6560B
+	if (probe_ht6560b)
+		(void)ht6560b_init();
+#endif
+#ifdef CONFIG_BLK_DEV_QD65XX
+	if (probe_qd65xx)
+		(void)qd65xx_init();
+#endif
+
+	initializing = 1;
+	/* Probe for special PCI and other "known" interface chipsets. */
+	probe_for_hwifs();
+	initializing = 0;
+
+#ifdef CONFIG_PROC_FS
+	proc_ide_create();
+#endif
+	return 0;
+}
+
+#ifdef MODULE
+static char *options = NULL;
+module_param(options, charp, 0);
+MODULE_LICENSE("GPL");
+
+static void __init parse_options (char *line)
+{
+	char *next = line;
+
+	if (line == NULL || !*line)
+		return;
+	while ((line = next) != NULL) {
+ 		if ((next = strchr(line,' ')) != NULL)
+			*next++ = 0;
+		if (!ide_setup(line))
+			printk (KERN_INFO "Unknown option '%s'\n", line);
+	}
+}
+
+int init_module (void)
+{
+	parse_options(options);
+	return ide_init();
+}
+
+void cleanup_module (void)
+{
+	int index;
+
+	for (index = 0; index < MAX_HWIFS; ++index)
+		ide_unregister(index);
+
+#ifdef CONFIG_PROC_FS
+	proc_ide_destroy();
+#endif
+	devfs_remove("ide");
+
+	bus_unregister(&ide_bus_type);
+}
+
+#else /* !MODULE */
+
+__setup("", ide_setup);
+
+module_init(ide_init);
+
+#endif /* MODULE */
