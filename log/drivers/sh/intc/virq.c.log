commit c509e05fc175a1ebafd7e1ee445dbe32c403a9ba
Author: SF Markus Elfring <elfring@users.sourceforge.net>
Date:   Thu Jul 6 15:36:04 2017 -0700

    drivers/sh/intc/virq.c: delete an error message for a failed memory allocation in add_virq_to_pirq()
    
    This issue was detected by using the Coccinelle software.
    
    Link: http://events.linuxfoundation.org/sites/events/files/slides/LCJ16-Refactor_Strings-WSang_0.pdf
    Link: http://lkml.kernel.org/r/54e30d61-5183-9911-cf35-1410fb78da5a@users.sourceforge.net
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/sh/intc/virq.c b/drivers/sh/intc/virq.c
index 35bbe288ddb4..a638c3048207 100644
--- a/drivers/sh/intc/virq.c
+++ b/drivers/sh/intc/virq.c
@@ -94,10 +94,8 @@ static int add_virq_to_pirq(unsigned int irq, unsigned int virq)
 	}
 
 	entry = kzalloc(sizeof(struct intc_virq_list), GFP_ATOMIC);
-	if (!entry) {
-		pr_err("can't allocate VIRQ mapping for %d\n", virq);
+	if (!entry)
 		return -ENOMEM;
-	}
 
 	entry->irq = virq;
 

commit 6d75f366b9242f9b17ed7d0b0604d7460f818f21
Author: Johannes Weiner <hannes@cmpxchg.org>
Date:   Mon Dec 12 16:43:43 2016 -0800

    lib: radix-tree: check accounting of existing slot replacement users
    
    The bug in khugepaged fixed earlier in this series shows that radix tree
    slot replacement is fragile; and it will become more so when not only
    NULL<->!NULL transitions need to be caught but transitions from and to
    exceptional entries as well.  We need checks.
    
    Re-implement radix_tree_replace_slot() on top of the sanity-checked
    __radix_tree_replace().  This requires existing callers to also pass the
    radix tree root, but it'll warn us when somebody replaces slots with
    contents that need proper accounting (transitions between NULL entries,
    real entries, exceptional entries) and where a replacement through the
    slot pointer would corrupt the radix tree node counts.
    
    Link: http://lkml.kernel.org/r/20161117193021.GB23430@cmpxchg.org
    Signed-off-by: Johannes Weiner <hannes@cmpxchg.org>
    Suggested-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Matthew Wilcox <mawilcox@linuxonhyperv.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/sh/intc/virq.c b/drivers/sh/intc/virq.c
index e7899624aa0b..35bbe288ddb4 100644
--- a/drivers/sh/intc/virq.c
+++ b/drivers/sh/intc/virq.c
@@ -254,7 +254,7 @@ static void __init intc_subgroup_map(struct intc_desc_int *d)
 
 		radix_tree_tag_clear(&d->tree, entry->enum_id,
 				     INTC_TAG_VIRQ_NEEDS_ALLOC);
-		radix_tree_replace_slot((void **)entries[i],
+		radix_tree_replace_slot(&d->tree, (void **)entries[i],
 					&intc_irq_xlate[irq]);
 	}
 

commit bd0b9ac405e1794d72533c3d487aa65b6b955a0c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 14 10:42:37 2015 +0200

    genirq: Remove irq argument from irq flow handlers
    
    Most interrupt flow handlers do not use the irq argument. Those few
    which use it can retrieve the irq number from the irq descriptor.
    
    Remove the argument.
    
    Search and replace was done with coccinelle and some extra helper
    scripts around it. Thanks to Julia for her help!
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>

diff --git a/drivers/sh/intc/virq.c b/drivers/sh/intc/virq.c
index bafc51c6f0ba..e7899624aa0b 100644
--- a/drivers/sh/intc/virq.c
+++ b/drivers/sh/intc/virq.c
@@ -109,7 +109,7 @@ static int add_virq_to_pirq(unsigned int irq, unsigned int virq)
 	return 0;
 }
 
-static void intc_virq_handler(unsigned int __irq, struct irq_desc *desc)
+static void intc_virq_handler(struct irq_desc *desc)
 {
 	unsigned int irq = irq_desc_get_irq(desc);
 	struct irq_data *data = irq_desc_get_irq_data(desc);
@@ -127,7 +127,7 @@ static void intc_virq_handler(unsigned int __irq, struct irq_desc *desc)
 			handle = (unsigned long)irq_desc_get_handler_data(vdesc);
 			addr = INTC_REG(d, _INTC_ADDR_E(handle), 0);
 			if (intc_reg_fns[_INTC_FN(handle)](addr, handle, 0))
-				generic_handle_irq_desc(entry->irq, vdesc);
+				generic_handle_irq_desc(vdesc);
 		}
 	}
 

commit c497615c0cb62ba0b06db9580911dcf6d612bdb9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jul 13 20:51:26 2015 +0000

    sh/intc: Prepare irq flow handlers for irq argument removal
    
    The irq argument of most interrupt flow handlers is unused or merily
    used instead of a local variable. The handlers which need the irq
    argument can retrieve the irq number from the irq descriptor.
    
    Search and update was done with coccinelle and the invaluable help of
    Julia Lawall.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Simon Horman <horms@verge.net.au>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Link: http://lkml.kernel.org/r/20150713151626.872605327@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/sh/intc/virq.c b/drivers/sh/intc/virq.c
index 503d95a48d13..bafc51c6f0ba 100644
--- a/drivers/sh/intc/virq.c
+++ b/drivers/sh/intc/virq.c
@@ -109,8 +109,9 @@ static int add_virq_to_pirq(unsigned int irq, unsigned int virq)
 	return 0;
 }
 
-static void intc_virq_handler(unsigned int irq, struct irq_desc *desc)
+static void intc_virq_handler(unsigned int __irq, struct irq_desc *desc)
 {
+	unsigned int irq = irq_desc_get_irq(desc);
 	struct irq_data *data = irq_desc_get_irq_data(desc);
 	struct irq_chip *chip = irq_data_get_irq_chip(data);
 	struct intc_virq_list *entry, *vlist = irq_data_get_irq_handler_data(data);

commit 8228a048961a93e871779c658eaa801f747e6c1d
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Jul 13 20:51:25 2015 +0000

    sh/intc: Use irq_desc_get_xxx() to avoid redundant lookup of irq_desc
    
    Use irq_desc_get_xxx() to avoid redundant lookup of irq_desc while we
    already have a pointer to corresponding irq_desc.
    
    Also replace generic_handle_irq with generic_handle_irq_desc() to avoid
    looking up irq_desc again.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Simon Horman <horms@verge.net.au>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Link: http://lkml.kernel.org/r/20150713151626.792845830@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/sh/intc/virq.c b/drivers/sh/intc/virq.c
index 0f735301d3ec..503d95a48d13 100644
--- a/drivers/sh/intc/virq.c
+++ b/drivers/sh/intc/virq.c
@@ -111,7 +111,7 @@ static int add_virq_to_pirq(unsigned int irq, unsigned int virq)
 
 static void intc_virq_handler(unsigned int irq, struct irq_desc *desc)
 {
-	struct irq_data *data = irq_get_irq_data(irq);
+	struct irq_data *data = irq_desc_get_irq_data(desc);
 	struct irq_chip *chip = irq_data_get_irq_chip(data);
 	struct intc_virq_list *entry, *vlist = irq_data_get_irq_handler_data(data);
 	struct intc_desc_int *d = get_intc_desc(irq);
@@ -120,12 +120,14 @@ static void intc_virq_handler(unsigned int irq, struct irq_desc *desc)
 
 	for_each_virq(entry, vlist) {
 		unsigned long addr, handle;
+		struct irq_desc *vdesc = irq_to_desc(entry->irq);
 
-		handle = (unsigned long)irq_get_handler_data(entry->irq);
-		addr = INTC_REG(d, _INTC_ADDR_E(handle), 0);
-
-		if (intc_reg_fns[_INTC_FN(handle)](addr, handle, 0))
-			generic_handle_irq(entry->irq);
+		if (vdesc) {
+			handle = (unsigned long)irq_desc_get_handler_data(vdesc);
+			addr = INTC_REG(d, _INTC_ADDR_E(handle), 0);
+			if (intc_reg_fns[_INTC_FN(handle)](addr, handle, 0))
+				generic_handle_irq_desc(entry->irq, vdesc);
+		}
 	}
 
 	chip->irq_unmask(data);

commit d0abe2f3a9a541ded2e30ef7275f057fb7f0335a
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Jul 13 20:51:22 2015 +0000

    sh/irq: Use irq accessor functions instead of open coded access
    
    This is a preparatory patch for refactoring the internals if irq_data.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Simon Horman <horms@verge.net.au>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Link: http://lkml.kernel.org/r/20150713151626.616384365@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/sh/intc/virq.c b/drivers/sh/intc/virq.c
index f5f1b821241a..0f735301d3ec 100644
--- a/drivers/sh/intc/virq.c
+++ b/drivers/sh/intc/virq.c
@@ -83,12 +83,11 @@ EXPORT_SYMBOL_GPL(intc_irq_lookup);
 
 static int add_virq_to_pirq(unsigned int irq, unsigned int virq)
 {
-	struct intc_virq_list **last, *entry;
-	struct irq_data *data = irq_get_irq_data(irq);
+	struct intc_virq_list *entry;
+	struct intc_virq_list **last = NULL;
 
 	/* scan for duplicates */
-	last = (struct intc_virq_list **)&data->handler_data;
-	for_each_virq(entry, data->handler_data) {
+	for_each_virq(entry, irq_get_handler_data(irq)) {
 		if (entry->irq == virq)
 			return 0;
 		last = &entry->next;
@@ -102,7 +101,10 @@ static int add_virq_to_pirq(unsigned int irq, unsigned int virq)
 
 	entry->irq = virq;
 
-	*last = entry;
+	if (last)
+		*last = entry;
+	else
+		irq_set_handler_data(irq, entry);
 
 	return 0;
 }

commit beab99fe835be1d9ef1112dabdae3aa417126430
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jun 22 11:31:34 2015 +0200

    sh/intc: Fix potential race in installing chained IRQ handler
    
    Fix a race where a pending interrupt could be received and the handler
    called before the handler's data has been setup, by moving the call to
    irq_set_chained_handler() after the function which sets up the handler
    data.
    
    Found by code inspection.
    
    Reported-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Simon Horman <horms@verge.net.au>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: linux-sh@vger.kernel.org

diff --git a/drivers/sh/intc/virq.c b/drivers/sh/intc/virq.c
index f30ac9354ff2..f5f1b821241a 100644
--- a/drivers/sh/intc/virq.c
+++ b/drivers/sh/intc/virq.c
@@ -243,8 +243,9 @@ static void __init intc_subgroup_map(struct intc_desc_int *d)
 		 */
 		irq_set_nothread(irq);
 
-		irq_set_chained_handler(entry->pirq, intc_virq_handler);
+		/* Set handler data before installing the handler */
 		add_virq_to_pirq(entry->pirq, irq);
+		irq_set_chained_handler(entry->pirq, intc_virq_handler);
 
 		radix_tree_tag_clear(&d->tree, entry->enum_id,
 				     INTC_TAG_VIRQ_NEEDS_ALLOC);

commit 123df01e8e046d6065089e1bff29aa3fc48d4420
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu May 24 19:24:18 2012 +0900

    sh: intc: Allocate subgroup virq backing desc directly.
    
    This switches to using irq_alloc_desc() directly for subgroup IRQs.
    We still need to call activate_irq() on these in order to make them
    requestable, at least up until these get moved in to their own irq
    domain..
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/drivers/sh/intc/virq.c b/drivers/sh/intc/virq.c
index 93cec21e788b..f30ac9354ff2 100644
--- a/drivers/sh/intc/virq.c
+++ b/drivers/sh/intc/virq.c
@@ -219,12 +219,14 @@ static void __init intc_subgroup_map(struct intc_desc_int *d)
 		if (radix_tree_deref_retry(entry))
 			goto restart;
 
-		irq = create_irq();
+		irq = irq_alloc_desc(numa_node_id());
 		if (unlikely(irq < 0)) {
 			pr_err("no more free IRQs, bailing..\n");
 			break;
 		}
 
+		activate_irq(irq);
+
 		pr_info("Setting up a chained VIRQ from %d -> %d\n",
 			irq, entry->pirq);
 

commit 0f55239348aa85021d8bf8b63d84a796fcc142a4
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Tue Jan 17 13:10:25 2012 -0600

    sh: intc: remove dependency on NR_IRQS
    
    SH intc has a compile time dependency on NR_IRQS. Make this dependency a
    local define so that shmobile (and ARM in general) can have run-time
    NR_IRQS setting.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/sh/intc/virq.c b/drivers/sh/intc/virq.c
index c7ec49ffd9f6..93cec21e788b 100644
--- a/drivers/sh/intc/virq.c
+++ b/drivers/sh/intc/virq.c
@@ -17,7 +17,7 @@
 #include <linux/export.h>
 #include "internals.h"
 
-static struct intc_map_entry intc_irq_xlate[NR_IRQS];
+static struct intc_map_entry intc_irq_xlate[INTC_NR_IRQS];
 
 struct intc_virq_list {
 	unsigned int irq;

commit 07c92739455520541c22f6529683467aa3058b7c
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jul 10 12:57:12 2011 -0400

    drivers/sh: Add export.h for EXPORT_SYMBOL to intc/virq.c
    
    This is exporting symbols and will fail to build once we remove
    the implicit presence of module.h
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/sh/intc/virq.c b/drivers/sh/intc/virq.c
index 1e6e2d0353ea..c7ec49ffd9f6 100644
--- a/drivers/sh/intc/virq.c
+++ b/drivers/sh/intc/virq.c
@@ -14,6 +14,7 @@
 #include <linux/list.h>
 #include <linux/radix-tree.h>
 #include <linux/spinlock.h>
+#include <linux/export.h>
 #include "internals.h"
 
 static struct intc_map_entry intc_irq_xlate[NR_IRQS];

commit 442f56d917959cbc3fd7a56c5eb43b0d728cad26
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Apr 18 11:45:08 2011 +0900

    sh: intc: Set virtual IRQs as nothread.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/drivers/sh/intc/virq.c b/drivers/sh/intc/virq.c
index ce5f81d7cc6b..1e6e2d0353ea 100644
--- a/drivers/sh/intc/virq.c
+++ b/drivers/sh/intc/virq.c
@@ -235,6 +235,11 @@ static void __init intc_subgroup_map(struct intc_desc_int *d)
 
 		irq_set_handler_data(irq, (void *)entry->handle);
 
+		/*
+		 * Set the virtual IRQ as non-threadable.
+		 */
+		irq_set_nothread(irq);
+
 		irq_set_chained_handler(entry->pirq, intc_virq_handler);
 		add_virq_to_pirq(entry->pirq, irq);
 

commit fcb8918fd242f39496090dbbd6789ab24098295b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 24 16:31:17 2011 +0100

    sh: Convert to new function names
    
    Scripted with coccinelle.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/sh/intc/virq.c b/drivers/sh/intc/virq.c
index 4e0ff7181164..ce5f81d7cc6b 100644
--- a/drivers/sh/intc/virq.c
+++ b/drivers/sh/intc/virq.c
@@ -110,7 +110,7 @@ static void intc_virq_handler(unsigned int irq, struct irq_desc *desc)
 {
 	struct irq_data *data = irq_get_irq_data(irq);
 	struct irq_chip *chip = irq_data_get_irq_chip(data);
-	struct intc_virq_list *entry, *vlist = irq_data_get_irq_data(data);
+	struct intc_virq_list *entry, *vlist = irq_data_get_irq_handler_data(data);
 	struct intc_desc_int *d = get_intc_desc(irq);
 
 	chip->irq_mask_ack(data);
@@ -118,7 +118,7 @@ static void intc_virq_handler(unsigned int irq, struct irq_desc *desc)
 	for_each_virq(entry, vlist) {
 		unsigned long addr, handle;
 
-		handle = (unsigned long)get_irq_data(entry->irq);
+		handle = (unsigned long)irq_get_handler_data(entry->irq);
 		addr = INTC_REG(d, _INTC_ADDR_E(handle), 0);
 
 		if (intc_reg_fns[_INTC_FN(handle)](addr, handle, 0))
@@ -229,13 +229,13 @@ static void __init intc_subgroup_map(struct intc_desc_int *d)
 
 		intc_irq_xlate_set(irq, entry->enum_id, d);
 
-		set_irq_chip_and_handler_name(irq, get_irq_chip(entry->pirq),
+		irq_set_chip_and_handler_name(irq, irq_get_chip(entry->pirq),
 					      handle_simple_irq, "virq");
-		set_irq_chip_data(irq, get_irq_chip_data(entry->pirq));
+		irq_set_chip_data(irq, irq_get_chip_data(entry->pirq));
 
-		set_irq_data(irq, (void *)entry->handle);
+		irq_set_handler_data(irq, (void *)entry->handle);
 
-		set_irq_chained_handler(entry->pirq, intc_virq_handler);
+		irq_set_chained_handler(entry->pirq, intc_virq_handler);
 		add_virq_to_pirq(entry->pirq, irq);
 
 		radix_tree_tag_clear(&d->tree, entry->enum_id,

commit 6318af900ca7cb2c94b27d3c358762e6ac187e25
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Nov 15 14:30:30 2010 +0900

    sh: intc: Fix up build failure introduced by radix tree changes.
    
    The radix tree retry logic got a bit of an overhaul and subsequently
    broke the virtual IRQ subgroup build. Simply switch over to
    radix_tree_deref_retry() as per the filemap changes, which the virq
    lookup logic was modelled after in the first place.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/drivers/sh/intc/virq.c b/drivers/sh/intc/virq.c
index e5bf5d3c698e..4e0ff7181164 100644
--- a/drivers/sh/intc/virq.c
+++ b/drivers/sh/intc/virq.c
@@ -215,7 +215,7 @@ static void __init intc_subgroup_map(struct intc_desc_int *d)
 		entry = radix_tree_deref_slot((void **)entries[i]);
 		if (unlikely(!entry))
 			continue;
-		if (unlikely(entry == RADIX_TREE_RETRY))
+		if (radix_tree_deref_retry(entry))
 			goto restart;
 
 		irq = create_irq();

commit 26599a94dcadbed528a3e32a4f482a9766332f5b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Oct 27 15:42:10 2010 +0900

    sh: intc: irq_data conversion.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/drivers/sh/intc/virq.c b/drivers/sh/intc/virq.c
index 643dfd4d2057..e5bf5d3c698e 100644
--- a/drivers/sh/intc/virq.c
+++ b/drivers/sh/intc/virq.c
@@ -83,11 +83,11 @@ EXPORT_SYMBOL_GPL(intc_irq_lookup);
 static int add_virq_to_pirq(unsigned int irq, unsigned int virq)
 {
 	struct intc_virq_list **last, *entry;
-	struct irq_desc *desc = irq_to_desc(irq);
+	struct irq_data *data = irq_get_irq_data(irq);
 
 	/* scan for duplicates */
-	last = (struct intc_virq_list **)&desc->handler_data;
-	for_each_virq(entry, desc->handler_data) {
+	last = (struct intc_virq_list **)&data->handler_data;
+	for_each_virq(entry, data->handler_data) {
 		if (entry->irq == virq)
 			return 0;
 		last = &entry->next;
@@ -108,10 +108,12 @@ static int add_virq_to_pirq(unsigned int irq, unsigned int virq)
 
 static void intc_virq_handler(unsigned int irq, struct irq_desc *desc)
 {
-	struct intc_virq_list *entry, *vlist = get_irq_data(irq);
+	struct irq_data *data = irq_get_irq_data(irq);
+	struct irq_chip *chip = irq_data_get_irq_chip(data);
+	struct intc_virq_list *entry, *vlist = irq_data_get_irq_data(data);
 	struct intc_desc_int *d = get_intc_desc(irq);
 
-	desc->chip->mask_ack(irq);
+	chip->irq_mask_ack(data);
 
 	for_each_virq(entry, vlist) {
 		unsigned long addr, handle;
@@ -123,7 +125,7 @@ static void intc_virq_handler(unsigned int irq, struct irq_desc *desc)
 			generic_handle_irq(entry->irq);
 	}
 
-	desc->chip->unmask(irq);
+	chip->irq_unmask(data);
 }
 
 static unsigned long __init intc_subgroup_data(struct intc_subgroup *subgroup,

commit 2be6bb0c79c7fbda3425b65ee51c558bbaf4cf91
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Oct 5 22:10:30 2010 +0900

    sh: intc: Split up the INTC code.
    
    This splits up the sh intc core in to something more vaguely resembling
    a subsystem. Most of the functionality was alread fairly well
    compartmentalized, and there were only a handful of interdependencies
    that needed to be resolved in the process.
    
    This also serves as future-proofing for the genirq and sparseirq rework,
    which will make some of the split out functionality wholly generic,
    allowing things to be killed off in place with minimal migration pain.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/drivers/sh/intc/virq.c b/drivers/sh/intc/virq.c
new file mode 100644
index 000000000000..643dfd4d2057
--- /dev/null
+++ b/drivers/sh/intc/virq.c
@@ -0,0 +1,255 @@
+/*
+ * Support for virtual IRQ subgroups.
+ *
+ * Copyright (C) 2010  Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#define pr_fmt(fmt) "intc: " fmt
+
+#include <linux/slab.h>
+#include <linux/irq.h>
+#include <linux/list.h>
+#include <linux/radix-tree.h>
+#include <linux/spinlock.h>
+#include "internals.h"
+
+static struct intc_map_entry intc_irq_xlate[NR_IRQS];
+
+struct intc_virq_list {
+	unsigned int irq;
+	struct intc_virq_list *next;
+};
+
+#define for_each_virq(entry, head) \
+	for (entry = head; entry; entry = entry->next)
+
+/*
+ * Tags for the radix tree
+ */
+#define INTC_TAG_VIRQ_NEEDS_ALLOC	0
+
+void intc_irq_xlate_set(unsigned int irq, intc_enum id, struct intc_desc_int *d)
+{
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&intc_big_lock, flags);
+	intc_irq_xlate[irq].enum_id = id;
+	intc_irq_xlate[irq].desc = d;
+	raw_spin_unlock_irqrestore(&intc_big_lock, flags);
+}
+
+struct intc_map_entry *intc_irq_xlate_get(unsigned int irq)
+{
+	return intc_irq_xlate + irq;
+}
+
+int intc_irq_lookup(const char *chipname, intc_enum enum_id)
+{
+	struct intc_map_entry *ptr;
+	struct intc_desc_int *d;
+	int irq = -1;
+
+	list_for_each_entry(d, &intc_list, list) {
+		int tagged;
+
+		if (strcmp(d->chip.name, chipname) != 0)
+			continue;
+
+		/*
+		 * Catch early lookups for subgroup VIRQs that have not
+		 * yet been allocated an IRQ. This already includes a
+		 * fast-path out if the tree is untagged, so there is no
+		 * need to explicitly test the root tree.
+		 */
+		tagged = radix_tree_tag_get(&d->tree, enum_id,
+					    INTC_TAG_VIRQ_NEEDS_ALLOC);
+		if (unlikely(tagged))
+			break;
+
+		ptr = radix_tree_lookup(&d->tree, enum_id);
+		if (ptr) {
+			irq = ptr - intc_irq_xlate;
+			break;
+		}
+	}
+
+	return irq;
+}
+EXPORT_SYMBOL_GPL(intc_irq_lookup);
+
+static int add_virq_to_pirq(unsigned int irq, unsigned int virq)
+{
+	struct intc_virq_list **last, *entry;
+	struct irq_desc *desc = irq_to_desc(irq);
+
+	/* scan for duplicates */
+	last = (struct intc_virq_list **)&desc->handler_data;
+	for_each_virq(entry, desc->handler_data) {
+		if (entry->irq == virq)
+			return 0;
+		last = &entry->next;
+	}
+
+	entry = kzalloc(sizeof(struct intc_virq_list), GFP_ATOMIC);
+	if (!entry) {
+		pr_err("can't allocate VIRQ mapping for %d\n", virq);
+		return -ENOMEM;
+	}
+
+	entry->irq = virq;
+
+	*last = entry;
+
+	return 0;
+}
+
+static void intc_virq_handler(unsigned int irq, struct irq_desc *desc)
+{
+	struct intc_virq_list *entry, *vlist = get_irq_data(irq);
+	struct intc_desc_int *d = get_intc_desc(irq);
+
+	desc->chip->mask_ack(irq);
+
+	for_each_virq(entry, vlist) {
+		unsigned long addr, handle;
+
+		handle = (unsigned long)get_irq_data(entry->irq);
+		addr = INTC_REG(d, _INTC_ADDR_E(handle), 0);
+
+		if (intc_reg_fns[_INTC_FN(handle)](addr, handle, 0))
+			generic_handle_irq(entry->irq);
+	}
+
+	desc->chip->unmask(irq);
+}
+
+static unsigned long __init intc_subgroup_data(struct intc_subgroup *subgroup,
+					       struct intc_desc_int *d,
+					       unsigned int index)
+{
+	unsigned int fn = REG_FN_TEST_BASE + (subgroup->reg_width >> 3) - 1;
+
+	return _INTC_MK(fn, MODE_ENABLE_REG, intc_get_reg(d, subgroup->reg),
+			0, 1, (subgroup->reg_width - 1) - index);
+}
+
+static void __init intc_subgroup_init_one(struct intc_desc *desc,
+					  struct intc_desc_int *d,
+					  struct intc_subgroup *subgroup)
+{
+	struct intc_map_entry *mapped;
+	unsigned int pirq;
+	unsigned long flags;
+	int i;
+
+	mapped = radix_tree_lookup(&d->tree, subgroup->parent_id);
+	if (!mapped) {
+		WARN_ON(1);
+		return;
+	}
+
+	pirq = mapped - intc_irq_xlate;
+
+	raw_spin_lock_irqsave(&d->lock, flags);
+
+	for (i = 0; i < ARRAY_SIZE(subgroup->enum_ids); i++) {
+		struct intc_subgroup_entry *entry;
+		int err;
+
+		if (!subgroup->enum_ids[i])
+			continue;
+
+		entry = kmalloc(sizeof(*entry), GFP_NOWAIT);
+		if (!entry)
+			break;
+
+		entry->pirq = pirq;
+		entry->enum_id = subgroup->enum_ids[i];
+		entry->handle = intc_subgroup_data(subgroup, d, i);
+
+		err = radix_tree_insert(&d->tree, entry->enum_id, entry);
+		if (unlikely(err < 0))
+			break;
+
+		radix_tree_tag_set(&d->tree, entry->enum_id,
+				   INTC_TAG_VIRQ_NEEDS_ALLOC);
+	}
+
+	raw_spin_unlock_irqrestore(&d->lock, flags);
+}
+
+void __init intc_subgroup_init(struct intc_desc *desc, struct intc_desc_int *d)
+{
+	int i;
+
+	if (!desc->hw.subgroups)
+		return;
+
+	for (i = 0; i < desc->hw.nr_subgroups; i++)
+		intc_subgroup_init_one(desc, d, desc->hw.subgroups + i);
+}
+
+static void __init intc_subgroup_map(struct intc_desc_int *d)
+{
+	struct intc_subgroup_entry *entries[32];
+	unsigned long flags;
+	unsigned int nr_found;
+	int i;
+
+	raw_spin_lock_irqsave(&d->lock, flags);
+
+restart:
+	nr_found = radix_tree_gang_lookup_tag_slot(&d->tree,
+			(void ***)entries, 0, ARRAY_SIZE(entries),
+			INTC_TAG_VIRQ_NEEDS_ALLOC);
+
+	for (i = 0; i < nr_found; i++) {
+		struct intc_subgroup_entry *entry;
+		int irq;
+
+		entry = radix_tree_deref_slot((void **)entries[i]);
+		if (unlikely(!entry))
+			continue;
+		if (unlikely(entry == RADIX_TREE_RETRY))
+			goto restart;
+
+		irq = create_irq();
+		if (unlikely(irq < 0)) {
+			pr_err("no more free IRQs, bailing..\n");
+			break;
+		}
+
+		pr_info("Setting up a chained VIRQ from %d -> %d\n",
+			irq, entry->pirq);
+
+		intc_irq_xlate_set(irq, entry->enum_id, d);
+
+		set_irq_chip_and_handler_name(irq, get_irq_chip(entry->pirq),
+					      handle_simple_irq, "virq");
+		set_irq_chip_data(irq, get_irq_chip_data(entry->pirq));
+
+		set_irq_data(irq, (void *)entry->handle);
+
+		set_irq_chained_handler(entry->pirq, intc_virq_handler);
+		add_virq_to_pirq(entry->pirq, irq);
+
+		radix_tree_tag_clear(&d->tree, entry->enum_id,
+				     INTC_TAG_VIRQ_NEEDS_ALLOC);
+		radix_tree_replace_slot((void **)entries[i],
+					&intc_irq_xlate[irq]);
+	}
+
+	raw_spin_unlock_irqrestore(&d->lock, flags);
+}
+
+void __init intc_finalize(void)
+{
+	struct intc_desc_int *d;
+
+	list_for_each_entry(d, &intc_list, list)
+		if (radix_tree_tagged(&d->tree, INTC_TAG_VIRQ_NEEDS_ALLOC))
+			intc_subgroup_map(d);
+}
