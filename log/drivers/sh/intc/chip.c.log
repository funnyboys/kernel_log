commit 8b8149df9ce99e02cb2b4655bf20d0ce459b9076
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jul 13 20:51:23 2015 +0000

    sh/irq: Use access helper irq_data_get_affinity_mask()
    
    This is a preparatory patch for moving irq_data struct members.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Simon Horman <horms@verge.net.au>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Link: http://lkml.kernel.org/r/20150713151626.713278346@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/sh/intc/chip.c b/drivers/sh/intc/chip.c
index 46427b48e2f1..358df7510186 100644
--- a/drivers/sh/intc/chip.c
+++ b/drivers/sh/intc/chip.c
@@ -22,7 +22,7 @@ void _intc_enable(struct irq_data *data, unsigned long handle)
 
 	for (cpu = 0; cpu < SMP_NR(d, _INTC_ADDR_E(handle)); cpu++) {
 #ifdef CONFIG_SMP
-		if (!cpumask_test_cpu(cpu, data->affinity))
+		if (!cpumask_test_cpu(cpu, irq_data_get_affinity_mask(data)))
 			continue;
 #endif
 		addr = INTC_REG(d, _INTC_ADDR_E(handle), cpu);
@@ -50,7 +50,7 @@ static void intc_disable(struct irq_data *data)
 
 	for (cpu = 0; cpu < SMP_NR(d, _INTC_ADDR_D(handle)); cpu++) {
 #ifdef CONFIG_SMP
-		if (!cpumask_test_cpu(cpu, data->affinity))
+		if (!cpumask_test_cpu(cpu, irq_data_get_affinity_mask(data)))
 			continue;
 #endif
 		addr = INTC_REG(d, _INTC_ADDR_D(handle), cpu);
@@ -72,7 +72,7 @@ static int intc_set_affinity(struct irq_data *data,
 	if (!cpumask_intersects(cpumask, cpu_online_mask))
 		return -1;
 
-	cpumask_copy(data->affinity, cpumask);
+	cpumask_copy(irq_data_get_affinity_mask(data), cpumask);
 
 	return IRQ_SET_MASK_OK_NOCOPY;
 }

commit 0dd4d5cbe4c38165dc9b3ad329ebb23f24d74fdb
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Oct 15 14:08:48 2012 +0900

    sh: Fix up more fallout from pointless ARM __iomem churn.
    
    It was already pointed out how to fix these cases before the offending
    patches were merged, but unsurprisingly, that didn't happen. As this
    change is entirely superfluous to begin with, simply shut things up by
    casting everything away.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/drivers/sh/intc/chip.c b/drivers/sh/intc/chip.c
index 012df2676a26..46427b48e2f1 100644
--- a/drivers/sh/intc/chip.c
+++ b/drivers/sh/intc/chip.c
@@ -83,7 +83,7 @@ static void intc_mask_ack(struct irq_data *data)
 	unsigned int irq = data->irq;
 	struct intc_desc_int *d = get_intc_desc(irq);
 	unsigned long handle = intc_get_ack_handle(irq);
-	unsigned long addr;
+	void __iomem *addr;
 
 	intc_disable(data);
 
@@ -91,7 +91,7 @@ static void intc_mask_ack(struct irq_data *data)
 	if (handle) {
 		unsigned int value;
 
-		addr = INTC_REG(d, _INTC_ADDR_D(handle), 0);
+		addr = (void __iomem *)INTC_REG(d, _INTC_ADDR_D(handle), 0);
 		value = intc_set_field_from_handle(0, 1, handle);
 
 		switch (_INTC_FN(handle)) {

commit b59f9f9775e643435bba76e30e59e47c19c56dee
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Jan 24 17:41:55 2012 +0900

    sh: intc: optimize intc IRQ lookup
    
    This ensures that the sense/prio lists are sorted at registration time,
    enabling us to use a simple binary search for an optimized lookup
    (something that had been on the TODO for some time).
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/drivers/sh/intc/chip.c b/drivers/sh/intc/chip.c
index db10adf63dd7..012df2676a26 100644
--- a/drivers/sh/intc/chip.c
+++ b/drivers/sh/intc/chip.c
@@ -2,13 +2,14 @@
  * IRQ chip definitions for INTC IRQs.
  *
  * Copyright (C) 2007, 2008 Magnus Damm
- * Copyright (C) 2009, 2010 Paul Mundt
+ * Copyright (C) 2009 - 2012 Paul Mundt
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  */
 #include <linux/cpumask.h>
+#include <linux/bsearch.h>
 #include <linux/io.h>
 #include "internals.h"
 
@@ -117,28 +118,12 @@ static struct intc_handle_int *intc_find_irq(struct intc_handle_int *hp,
 					     unsigned int nr_hp,
 					     unsigned int irq)
 {
-	int i;
-
-	/*
-	 * this doesn't scale well, but...
-	 *
-	 * this function should only be used for cerain uncommon
-	 * operations such as intc_set_priority() and intc_set_type()
-	 * and in those rare cases performance doesn't matter that much.
-	 * keeping the memory footprint low is more important.
-	 *
-	 * one rather simple way to speed this up and still keep the
-	 * memory footprint down is to make sure the array is sorted
-	 * and then perform a bisect to lookup the irq.
-	 */
-	for (i = 0; i < nr_hp; i++) {
-		if ((hp + i)->irq != irq)
-			continue;
+	struct intc_handle_int key;
 
-		return hp + i;
-	}
+	key.irq = irq;
+	key.handle = 0;
 
-	return NULL;
+	return bsearch(&key, hp, nr_hp, sizeof(*hp), intc_handle_int_cmp);
 }
 
 int intc_set_priority(unsigned int irq, unsigned int prio)

commit 30377642138aadeef35a31c2f90dba0b6fa7b91a
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Jan 24 16:55:57 2012 +0900

    sh: intc: Use IRQ_SET_MASK_OK_NOCOPY for intc_set_affinity.
    
    intc_set_affinity() updates the cpumask in place, so there's no need for
    the upper layer to do this itself.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/drivers/sh/intc/chip.c b/drivers/sh/intc/chip.c
index d90cb7e43920..db10adf63dd7 100644
--- a/drivers/sh/intc/chip.c
+++ b/drivers/sh/intc/chip.c
@@ -73,7 +73,7 @@ static int intc_set_affinity(struct irq_data *data,
 
 	cpumask_copy(data->affinity, cpumask);
 
-	return 0;
+	return IRQ_SET_MASK_OK_NOCOPY;
 }
 #endif
 

commit 29775df10f02f614db870ff4acaf0b07dbed1547
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Jan 24 15:38:57 2012 +0900

    sh: intc: Kill off superfluous irq_shutdown hooking.
    
    This already gets handled via disable, as per the notes in linux/irq.h.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/drivers/sh/intc/chip.c b/drivers/sh/intc/chip.c
index 3679645427c1..d90cb7e43920 100644
--- a/drivers/sh/intc/chip.c
+++ b/drivers/sh/intc/chip.c
@@ -218,7 +218,6 @@ struct irq_chip intc_irq_chip	= {
 	.irq_mask_ack		= intc_mask_ack,
 	.irq_enable		= intc_enable,
 	.irq_disable		= intc_disable,
-	.irq_shutdown		= intc_disable,
 	.irq_set_type		= intc_set_type,
 #ifdef CONFIG_SMP
 	.irq_set_affinity	= intc_set_affinity,

commit 5bbda4e4aca4591c85ee53dea157ca5fc9a23306
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Jan 24 14:54:10 2012 +0900

    sh: intc: Prefer IRQCHIP_SKIP_SET_WAKE over a dummy set_wake callback.
    
    It's possible to use IRQCHIP_SKIP_SET_WAKE to get the behaviour that
    we're after, without having to bother with a dummy ->set_wake() callback
    for the IRQ chip.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/drivers/sh/intc/chip.c b/drivers/sh/intc/chip.c
index 7b246efa94ea..3679645427c1 100644
--- a/drivers/sh/intc/chip.c
+++ b/drivers/sh/intc/chip.c
@@ -58,11 +58,6 @@ static void intc_disable(struct irq_data *data)
 	}
 }
 
-static int intc_set_wake(struct irq_data *data, unsigned int on)
-{
-	return 0; /* allow wakeup, but setup hardware in intc_suspend() */
-}
-
 #ifdef CONFIG_SMP
 /*
  * This is held with the irq desc lock held, so we don't require any
@@ -225,8 +220,8 @@ struct irq_chip intc_irq_chip	= {
 	.irq_disable		= intc_disable,
 	.irq_shutdown		= intc_disable,
 	.irq_set_type		= intc_set_type,
-	.irq_set_wake		= intc_set_wake,
 #ifdef CONFIG_SMP
 	.irq_set_affinity	= intc_set_affinity,
 #endif
+	.flags			= IRQCHIP_SKIP_SET_WAKE,
 };

commit 7d377b170ae0d4df7692f50c9609bea385fe87cc
Author: Magnus Damm <damm@opensource.se>
Date:   Wed Oct 12 16:21:08 2011 +0900

    sh: intc: Allow triggering on both edges for ARM SoCs
    
    Enable IRQ_TYPE_EDGE_BOTH on all R/SH-Mobile ARM SoCs.
    This hardware feature is supported by sh7367, sh7377,
    sh7372 and sh73a0.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/drivers/sh/intc/chip.c b/drivers/sh/intc/chip.c
index e0ada3773786..7b246efa94ea 100644
--- a/drivers/sh/intc/chip.c
+++ b/drivers/sh/intc/chip.c
@@ -186,7 +186,7 @@ static unsigned char intc_irq_sense_table[IRQ_TYPE_SENSE_MASK + 1] = {
     !defined(CONFIG_CPU_SUBTYPE_SH7709)
 	[IRQ_TYPE_LEVEL_HIGH] = VALID(3),
 #endif
-#if defined(CONFIG_ARCH_SH7372)
+#if defined(CONFIG_ARM) /* all recent SH-Mobile / R-Mobile ARM support this */
 	[IRQ_TYPE_EDGE_BOTH] = VALID(4),
 #endif
 };

commit 52e3124f248e9ada990cd2aeafe250a53713c6f0
Author: Magnus Damm <damm@opensource.se>
Date:   Mon Oct 17 17:59:54 2011 +0900

    sh: intc: Add IRQ trigger bit field check
    
    R-Mobile SoCs such as sh73a0 include PINT blocks in INTC
    that come with 2-bit IRQ trigger support. Add code to make
    sure the bit width is checked so 4-bit only modes like for
    instance EDGE_BOTH will fail for PINT.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/drivers/sh/intc/chip.c b/drivers/sh/intc/chip.c
index 33b2ed451e09..e0ada3773786 100644
--- a/drivers/sh/intc/chip.c
+++ b/drivers/sh/intc/chip.c
@@ -202,11 +202,16 @@ static int intc_set_type(struct irq_data *data, unsigned int type)
 	if (!value)
 		return -EINVAL;
 
+	value &= ~SENSE_VALID_FLAG;
+
 	ihp = intc_find_irq(d->sense, d->nr_sense, irq);
 	if (ihp) {
+		/* PINT has 2-bit sense registers, should fail on EDGE_BOTH */
+		if (value >= (1 << _INTC_WIDTH(ihp->handle)))
+			return -EINVAL;
+
 		addr = INTC_REG(d, _INTC_ADDR_E(ihp->handle), 0);
-		intc_reg_fns[_INTC_FN(ihp->handle)](addr, ihp->handle,
-						    value & ~SENSE_VALID_FLAG);
+		intc_reg_fns[_INTC_FN(ihp->handle)](addr, ihp->handle, value);
 	}
 
 	return 0;

commit 9a14a92c939aea1aaf27f5ad37b26b235acc2a65
Author: Magnus Damm <damm@opensource.se>
Date:   Fri Jul 15 10:58:55 2011 +0000

    sh: intc: enable both edges GPIO interrupts on sh7372
    
    IRQ-capable GPIOs on sh7372 can be configured to produce interrupts on
    both edges.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Acked-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/drivers/sh/intc/chip.c b/drivers/sh/intc/chip.c
index f33e2dd97934..33b2ed451e09 100644
--- a/drivers/sh/intc/chip.c
+++ b/drivers/sh/intc/chip.c
@@ -186,6 +186,9 @@ static unsigned char intc_irq_sense_table[IRQ_TYPE_SENSE_MASK + 1] = {
     !defined(CONFIG_CPU_SUBTYPE_SH7709)
 	[IRQ_TYPE_LEVEL_HIGH] = VALID(3),
 #endif
+#if defined(CONFIG_ARCH_SH7372)
+	[IRQ_TYPE_EDGE_BOTH] = VALID(4),
+#endif
 };
 
 static int intc_set_type(struct irq_data *data, unsigned int type)

commit 8a5a778665efb3a5f16ebb6fbc13356907e45775
Author: Magnus Damm <damm@opensource.se>
Date:   Wed Jan 19 08:16:29 2011 +0000

    sh: update INTC to clear IRQ sense valid flag
    
    Clear the valid flag is in the INTC code.
    Without this fix bit 7 of the sense register
    is mistakenly set.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/drivers/sh/intc/chip.c b/drivers/sh/intc/chip.c
index de885a0f917a..f33e2dd97934 100644
--- a/drivers/sh/intc/chip.c
+++ b/drivers/sh/intc/chip.c
@@ -173,7 +173,8 @@ int intc_set_priority(unsigned int irq, unsigned int prio)
 	return 0;
 }
 
-#define VALID(x) (x | 0x80)
+#define SENSE_VALID_FLAG 0x80
+#define VALID(x) (x | SENSE_VALID_FLAG)
 
 static unsigned char intc_irq_sense_table[IRQ_TYPE_SENSE_MASK + 1] = {
 	[IRQ_TYPE_EDGE_FALLING] = VALID(0),
@@ -201,7 +202,8 @@ static int intc_set_type(struct irq_data *data, unsigned int type)
 	ihp = intc_find_irq(d->sense, d->nr_sense, irq);
 	if (ihp) {
 		addr = INTC_REG(d, _INTC_ADDR_E(ihp->handle), 0);
-		intc_reg_fns[_INTC_FN(ihp->handle)](addr, ihp->handle, value);
+		intc_reg_fns[_INTC_FN(ihp->handle)](addr, ihp->handle,
+						    value & ~SENSE_VALID_FLAG);
 	}
 
 	return 0;

commit 26599a94dcadbed528a3e32a4f482a9766332f5b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Oct 27 15:42:10 2010 +0900

    sh: intc: irq_data conversion.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/drivers/sh/intc/chip.c b/drivers/sh/intc/chip.c
index 35c03706cc21..de885a0f917a 100644
--- a/drivers/sh/intc/chip.c
+++ b/drivers/sh/intc/chip.c
@@ -12,15 +12,16 @@
 #include <linux/io.h>
 #include "internals.h"
 
-void _intc_enable(unsigned int irq, unsigned long handle)
+void _intc_enable(struct irq_data *data, unsigned long handle)
 {
+	unsigned int irq = data->irq;
 	struct intc_desc_int *d = get_intc_desc(irq);
 	unsigned long addr;
 	unsigned int cpu;
 
 	for (cpu = 0; cpu < SMP_NR(d, _INTC_ADDR_E(handle)); cpu++) {
 #ifdef CONFIG_SMP
-		if (!cpumask_test_cpu(cpu, irq_to_desc(irq)->affinity))
+		if (!cpumask_test_cpu(cpu, data->affinity))
 			continue;
 #endif
 		addr = INTC_REG(d, _INTC_ADDR_E(handle), cpu);
@@ -31,15 +32,16 @@ void _intc_enable(unsigned int irq, unsigned long handle)
 	intc_balancing_enable(irq);
 }
 
-static void intc_enable(unsigned int irq)
+static void intc_enable(struct irq_data *data)
 {
-	_intc_enable(irq, (unsigned long)get_irq_chip_data(irq));
+	_intc_enable(data, (unsigned long)irq_data_get_irq_chip_data(data));
 }
 
-static void intc_disable(unsigned int irq)
+static void intc_disable(struct irq_data *data)
 {
+	unsigned int irq = data->irq;
 	struct intc_desc_int *d = get_intc_desc(irq);
-	unsigned long handle = (unsigned long)get_irq_chip_data(irq);
+	unsigned long handle = (unsigned long)irq_data_get_irq_chip_data(data);
 	unsigned long addr;
 	unsigned int cpu;
 
@@ -47,7 +49,7 @@ static void intc_disable(unsigned int irq)
 
 	for (cpu = 0; cpu < SMP_NR(d, _INTC_ADDR_D(handle)); cpu++) {
 #ifdef CONFIG_SMP
-		if (!cpumask_test_cpu(cpu, irq_to_desc(irq)->affinity))
+		if (!cpumask_test_cpu(cpu, data->affinity))
 			continue;
 #endif
 		addr = INTC_REG(d, _INTC_ADDR_D(handle), cpu);
@@ -56,7 +58,7 @@ static void intc_disable(unsigned int irq)
 	}
 }
 
-static int intc_set_wake(unsigned int irq, unsigned int on)
+static int intc_set_wake(struct irq_data *data, unsigned int on)
 {
 	return 0; /* allow wakeup, but setup hardware in intc_suspend() */
 }
@@ -67,24 +69,27 @@ static int intc_set_wake(unsigned int irq, unsigned int on)
  * additional locking here at the intc desc level. The affinity mask is
  * later tested in the enable/disable paths.
  */
-static int intc_set_affinity(unsigned int irq, const struct cpumask *cpumask)
+static int intc_set_affinity(struct irq_data *data,
+			     const struct cpumask *cpumask,
+			     bool force)
 {
 	if (!cpumask_intersects(cpumask, cpu_online_mask))
 		return -1;
 
-	cpumask_copy(irq_to_desc(irq)->affinity, cpumask);
+	cpumask_copy(data->affinity, cpumask);
 
 	return 0;
 }
 #endif
 
-static void intc_mask_ack(unsigned int irq)
+static void intc_mask_ack(struct irq_data *data)
 {
+	unsigned int irq = data->irq;
 	struct intc_desc_int *d = get_intc_desc(irq);
 	unsigned long handle = intc_get_ack_handle(irq);
 	unsigned long addr;
 
-	intc_disable(irq);
+	intc_disable(data);
 
 	/* read register and write zero only to the associated bit */
 	if (handle) {
@@ -144,6 +149,7 @@ static struct intc_handle_int *intc_find_irq(struct intc_handle_int *hp,
 int intc_set_priority(unsigned int irq, unsigned int prio)
 {
 	struct intc_desc_int *d = get_intc_desc(irq);
+	struct irq_data *data = irq_get_irq_data(irq);
 	struct intc_handle_int *ihp;
 
 	if (!intc_get_prio_level(irq) || prio <= 1)
@@ -162,7 +168,7 @@ int intc_set_priority(unsigned int irq, unsigned int prio)
 		 * priority level will be set during next enable()
 		 */
 		if (_INTC_FN(ihp->handle) != REG_FN_ERR)
-			_intc_enable(irq, ihp->handle);
+			_intc_enable(data, ihp->handle);
 	}
 	return 0;
 }
@@ -181,8 +187,9 @@ static unsigned char intc_irq_sense_table[IRQ_TYPE_SENSE_MASK + 1] = {
 #endif
 };
 
-static int intc_set_type(unsigned int irq, unsigned int type)
+static int intc_set_type(struct irq_data *data, unsigned int type)
 {
+	unsigned int irq = data->irq;
 	struct intc_desc_int *d = get_intc_desc(irq);
 	unsigned char value = intc_irq_sense_table[type & IRQ_TYPE_SENSE_MASK];
 	struct intc_handle_int *ihp;
@@ -201,15 +208,15 @@ static int intc_set_type(unsigned int irq, unsigned int type)
 }
 
 struct irq_chip intc_irq_chip	= {
-	.mask		= intc_disable,
-	.unmask		= intc_enable,
-	.mask_ack	= intc_mask_ack,
-	.enable		= intc_enable,
-	.disable	= intc_disable,
-	.shutdown	= intc_disable,
-	.set_type	= intc_set_type,
-	.set_wake	= intc_set_wake,
+	.irq_mask		= intc_disable,
+	.irq_unmask		= intc_enable,
+	.irq_mask_ack		= intc_mask_ack,
+	.irq_enable		= intc_enable,
+	.irq_disable		= intc_disable,
+	.irq_shutdown		= intc_disable,
+	.irq_set_type		= intc_set_type,
+	.irq_set_wake		= intc_set_wake,
 #ifdef CONFIG_SMP
-	.set_affinity	= intc_set_affinity,
+	.irq_set_affinity	= intc_set_affinity,
 #endif
 };

commit 2be6bb0c79c7fbda3425b65ee51c558bbaf4cf91
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Oct 5 22:10:30 2010 +0900

    sh: intc: Split up the INTC code.
    
    This splits up the sh intc core in to something more vaguely resembling
    a subsystem. Most of the functionality was alread fairly well
    compartmentalized, and there were only a handful of interdependencies
    that needed to be resolved in the process.
    
    This also serves as future-proofing for the genirq and sparseirq rework,
    which will make some of the split out functionality wholly generic,
    allowing things to be killed off in place with minimal migration pain.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/drivers/sh/intc/chip.c b/drivers/sh/intc/chip.c
new file mode 100644
index 000000000000..35c03706cc21
--- /dev/null
+++ b/drivers/sh/intc/chip.c
@@ -0,0 +1,215 @@
+/*
+ * IRQ chip definitions for INTC IRQs.
+ *
+ * Copyright (C) 2007, 2008 Magnus Damm
+ * Copyright (C) 2009, 2010 Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/cpumask.h>
+#include <linux/io.h>
+#include "internals.h"
+
+void _intc_enable(unsigned int irq, unsigned long handle)
+{
+	struct intc_desc_int *d = get_intc_desc(irq);
+	unsigned long addr;
+	unsigned int cpu;
+
+	for (cpu = 0; cpu < SMP_NR(d, _INTC_ADDR_E(handle)); cpu++) {
+#ifdef CONFIG_SMP
+		if (!cpumask_test_cpu(cpu, irq_to_desc(irq)->affinity))
+			continue;
+#endif
+		addr = INTC_REG(d, _INTC_ADDR_E(handle), cpu);
+		intc_enable_fns[_INTC_MODE(handle)](addr, handle, intc_reg_fns\
+						    [_INTC_FN(handle)], irq);
+	}
+
+	intc_balancing_enable(irq);
+}
+
+static void intc_enable(unsigned int irq)
+{
+	_intc_enable(irq, (unsigned long)get_irq_chip_data(irq));
+}
+
+static void intc_disable(unsigned int irq)
+{
+	struct intc_desc_int *d = get_intc_desc(irq);
+	unsigned long handle = (unsigned long)get_irq_chip_data(irq);
+	unsigned long addr;
+	unsigned int cpu;
+
+	intc_balancing_disable(irq);
+
+	for (cpu = 0; cpu < SMP_NR(d, _INTC_ADDR_D(handle)); cpu++) {
+#ifdef CONFIG_SMP
+		if (!cpumask_test_cpu(cpu, irq_to_desc(irq)->affinity))
+			continue;
+#endif
+		addr = INTC_REG(d, _INTC_ADDR_D(handle), cpu);
+		intc_disable_fns[_INTC_MODE(handle)](addr, handle,intc_reg_fns\
+						     [_INTC_FN(handle)], irq);
+	}
+}
+
+static int intc_set_wake(unsigned int irq, unsigned int on)
+{
+	return 0; /* allow wakeup, but setup hardware in intc_suspend() */
+}
+
+#ifdef CONFIG_SMP
+/*
+ * This is held with the irq desc lock held, so we don't require any
+ * additional locking here at the intc desc level. The affinity mask is
+ * later tested in the enable/disable paths.
+ */
+static int intc_set_affinity(unsigned int irq, const struct cpumask *cpumask)
+{
+	if (!cpumask_intersects(cpumask, cpu_online_mask))
+		return -1;
+
+	cpumask_copy(irq_to_desc(irq)->affinity, cpumask);
+
+	return 0;
+}
+#endif
+
+static void intc_mask_ack(unsigned int irq)
+{
+	struct intc_desc_int *d = get_intc_desc(irq);
+	unsigned long handle = intc_get_ack_handle(irq);
+	unsigned long addr;
+
+	intc_disable(irq);
+
+	/* read register and write zero only to the associated bit */
+	if (handle) {
+		unsigned int value;
+
+		addr = INTC_REG(d, _INTC_ADDR_D(handle), 0);
+		value = intc_set_field_from_handle(0, 1, handle);
+
+		switch (_INTC_FN(handle)) {
+		case REG_FN_MODIFY_BASE + 0:	/* 8bit */
+			__raw_readb(addr);
+			__raw_writeb(0xff ^ value, addr);
+			break;
+		case REG_FN_MODIFY_BASE + 1:	/* 16bit */
+			__raw_readw(addr);
+			__raw_writew(0xffff ^ value, addr);
+			break;
+		case REG_FN_MODIFY_BASE + 3:	/* 32bit */
+			__raw_readl(addr);
+			__raw_writel(0xffffffff ^ value, addr);
+			break;
+		default:
+			BUG();
+			break;
+		}
+	}
+}
+
+static struct intc_handle_int *intc_find_irq(struct intc_handle_int *hp,
+					     unsigned int nr_hp,
+					     unsigned int irq)
+{
+	int i;
+
+	/*
+	 * this doesn't scale well, but...
+	 *
+	 * this function should only be used for cerain uncommon
+	 * operations such as intc_set_priority() and intc_set_type()
+	 * and in those rare cases performance doesn't matter that much.
+	 * keeping the memory footprint low is more important.
+	 *
+	 * one rather simple way to speed this up and still keep the
+	 * memory footprint down is to make sure the array is sorted
+	 * and then perform a bisect to lookup the irq.
+	 */
+	for (i = 0; i < nr_hp; i++) {
+		if ((hp + i)->irq != irq)
+			continue;
+
+		return hp + i;
+	}
+
+	return NULL;
+}
+
+int intc_set_priority(unsigned int irq, unsigned int prio)
+{
+	struct intc_desc_int *d = get_intc_desc(irq);
+	struct intc_handle_int *ihp;
+
+	if (!intc_get_prio_level(irq) || prio <= 1)
+		return -EINVAL;
+
+	ihp = intc_find_irq(d->prio, d->nr_prio, irq);
+	if (ihp) {
+		if (prio >= (1 << _INTC_WIDTH(ihp->handle)))
+			return -EINVAL;
+
+		intc_set_prio_level(irq, prio);
+
+		/*
+		 * only set secondary masking method directly
+		 * primary masking method is using intc_prio_level[irq]
+		 * priority level will be set during next enable()
+		 */
+		if (_INTC_FN(ihp->handle) != REG_FN_ERR)
+			_intc_enable(irq, ihp->handle);
+	}
+	return 0;
+}
+
+#define VALID(x) (x | 0x80)
+
+static unsigned char intc_irq_sense_table[IRQ_TYPE_SENSE_MASK + 1] = {
+	[IRQ_TYPE_EDGE_FALLING] = VALID(0),
+	[IRQ_TYPE_EDGE_RISING] = VALID(1),
+	[IRQ_TYPE_LEVEL_LOW] = VALID(2),
+	/* SH7706, SH7707 and SH7709 do not support high level triggered */
+#if !defined(CONFIG_CPU_SUBTYPE_SH7706) && \
+    !defined(CONFIG_CPU_SUBTYPE_SH7707) && \
+    !defined(CONFIG_CPU_SUBTYPE_SH7709)
+	[IRQ_TYPE_LEVEL_HIGH] = VALID(3),
+#endif
+};
+
+static int intc_set_type(unsigned int irq, unsigned int type)
+{
+	struct intc_desc_int *d = get_intc_desc(irq);
+	unsigned char value = intc_irq_sense_table[type & IRQ_TYPE_SENSE_MASK];
+	struct intc_handle_int *ihp;
+	unsigned long addr;
+
+	if (!value)
+		return -EINVAL;
+
+	ihp = intc_find_irq(d->sense, d->nr_sense, irq);
+	if (ihp) {
+		addr = INTC_REG(d, _INTC_ADDR_E(ihp->handle), 0);
+		intc_reg_fns[_INTC_FN(ihp->handle)](addr, ihp->handle, value);
+	}
+
+	return 0;
+}
+
+struct irq_chip intc_irq_chip	= {
+	.mask		= intc_disable,
+	.unmask		= intc_enable,
+	.mask_ack	= intc_mask_ack,
+	.enable		= intc_enable,
+	.disable	= intc_disable,
+	.shutdown	= intc_disable,
+	.set_type	= intc_set_type,
+	.set_wake	= intc_set_wake,
+#ifdef CONFIG_SMP
+	.set_affinity	= intc_set_affinity,
+#endif
+};
