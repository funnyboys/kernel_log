commit 57c8a661d95dff48dd9c2f2496139082bbaf241a
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:49 2018 -0700

    mm: remove include/linux/bootmem.h
    
    Move remaining definitions and declarations from include/linux/bootmem.h
    into include/linux/memblock.h and remove the redundant header.
    
    The includes were replaced with the semantic patch below and then
    semi-automated removal of duplicated '#include <linux/memblock.h>
    
    @@
    @@
    - #include <linux/bootmem.h>
    + #include <linux/memblock.h>
    
    [sfr@canb.auug.org.au: dma-direct: fix up for the removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181002185342.133d1680@canb.auug.org.au
    [sfr@canb.auug.org.au: powerpc: fix up for removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181005161406.73ef8727@canb.auug.org.au
    [sfr@canb.auug.org.au: x86/kaslr, ACPI/NUMA: fix for linux/bootmem.h removal]
      Link: http://lkml.kernel.org/r/20181008190341.5e396491@canb.auug.org.au
    Link: http://lkml.kernel.org/r/1536927045-23536-30-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/sfi/sfi_core.c b/drivers/sfi/sfi_core.c
index 153b3f3cc795..a5136901dd8a 100644
--- a/drivers/sfi/sfi_core.c
+++ b/drivers/sfi/sfi_core.c
@@ -59,7 +59,7 @@
 #define KMSG_COMPONENT "SFI"
 #define pr_fmt(fmt) KMSG_COMPONENT ": " fmt
 
-#include <linux/bootmem.h>
+#include <linux/memblock.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/errno.h>

commit 693bf0aa01b7f9a1b24b2b932d555c6667f17a1a
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Jul 20 11:23:07 2017 +0200

    x86/boot: Fix memremap() related build failure
    
    The following commit:
    
      5997efb96756 ("x86/boot: Use memremap() to map the MPF and MPC data")
    
    causes new build failures on certain randconfigs:
    
      drivers/sfi/sfi_core.c: In function ‘sfi_map_memory’:
      drivers/sfi/sfi_core.c:104:10: error: implicit declaration of function ‘memremap’ [-Werror=implicit-function-declaration]
      drivers/sfi/sfi_core.c:104:31: error: ‘MEMREMAP_WB’ undeclared (first use in this function)
    
    This is a case of parasitic header dependencies: the sfi_core.c file indirectly
    includes <linux/io.h> for typical - but not all configs.
    
    Including <linux/io.h> explicitly solves the build failure.
    
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: arnd@arndb.de
    Cc: aryabinin@virtuozzo.com
    Cc: bp@alien8.de
    Cc: bp@suse.de
    Cc: brijesh.singh@amd.com
    Cc: corbet@lwn.net
    Cc: dvyukov@google.com
    Cc: dyoung@redhat.com
    Cc: glider@google.com
    Cc: konrad.wilk@oracle.com
    Cc: linux-tip-commits@vger.kernel.org
    Cc: luto@kernel.org
    Cc: lwoodman@redhat.com
    Cc: matt@codeblueprint.co.uk
    Cc: mst@redhat.com
    Cc: pbonzini@redhat.com
    Cc: riel@redhat.com
    Cc: rkrcmar@redhat.com
    Cc: thomas.lendacky@amd.com
    Cc: toshi.kani@hpe.com
    Link: http://lkml.kernel.org/r/20170720092307.6xslahuaclmsiffe@gmail.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/sfi/sfi_core.c b/drivers/sfi/sfi_core.c
index d5ce53491efb..153b3f3cc795 100644
--- a/drivers/sfi/sfi_core.c
+++ b/drivers/sfi/sfi_core.c
@@ -68,6 +68,7 @@
 #include <linux/init.h>
 #include <linux/sfi.h>
 #include <linux/slab.h>
+#include <linux/io.h>
 
 #include "sfi_core.h"
 

commit f7750a79568788473c5e8092ee58a52248f34329
Author: Tom Lendacky <thomas.lendacky@amd.com>
Date:   Mon Jul 17 16:10:00 2017 -0500

    x86, mpparse, x86/acpi, x86/PCI, x86/dmi, SFI: Use memremap() for RAM mappings
    
    The ioremap() function is intended for mapping MMIO. For RAM, the
    memremap() function should be used. Convert calls from ioremap() to
    memremap() when re-mapping RAM.
    
    This will be used later by SME to control how the encryption mask is
    applied to memory mappings, with certain memory locations being mapped
    decrypted vs encrypted.
    
    Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Borislav Petkov <bp@suse.de>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brijesh Singh <brijesh.singh@amd.com>
    Cc: Dave Young <dyoung@redhat.com>
    Cc: Dmitry Vyukov <dvyukov@google.com>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Larry Woodman <lwoodman@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Michael S. Tsirkin <mst@redhat.com>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Radim Krčmář <rkrcmar@redhat.com>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Toshimitsu Kani <toshi.kani@hpe.com>
    Cc: kasan-dev@googlegroups.com
    Cc: kvm@vger.kernel.org
    Cc: linux-arch@vger.kernel.org
    Cc: linux-doc@vger.kernel.org
    Cc: linux-efi@vger.kernel.org
    Cc: linux-mm@kvack.org
    Link: http://lkml.kernel.org/r/b13fccb9abbd547a7eef7b1fdfc223431b211c88.1500319216.git.thomas.lendacky@amd.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/sfi/sfi_core.c b/drivers/sfi/sfi_core.c
index 296db7a69c27..d5ce53491efb 100644
--- a/drivers/sfi/sfi_core.c
+++ b/drivers/sfi/sfi_core.c
@@ -86,13 +86,13 @@ static struct sfi_table_simple *syst_va __read_mostly;
 /*
  * FW creates and saves the SFI tables in memory. When these tables get
  * used, they may need to be mapped to virtual address space, and the mapping
- * can happen before or after the ioremap() is ready, so a flag is needed
+ * can happen before or after the memremap() is ready, so a flag is needed
  * to indicating this
  */
-static u32 sfi_use_ioremap __read_mostly;
+static u32 sfi_use_memremap __read_mostly;
 
 /*
- * sfi_un/map_memory calls early_ioremap/iounmap which is a __init function
+ * sfi_un/map_memory calls early_memremap/memunmap which is a __init function
  * and introduces section mismatch. So use __ref to make it calm.
  */
 static void __iomem * __ref sfi_map_memory(u64 phys, u32 size)
@@ -100,10 +100,10 @@ static void __iomem * __ref sfi_map_memory(u64 phys, u32 size)
 	if (!phys || !size)
 		return NULL;
 
-	if (sfi_use_ioremap)
-		return ioremap_cache(phys, size);
+	if (sfi_use_memremap)
+		return memremap(phys, size, MEMREMAP_WB);
 	else
-		return early_ioremap(phys, size);
+		return early_memremap(phys, size);
 }
 
 static void __ref sfi_unmap_memory(void __iomem *virt, u32 size)
@@ -111,10 +111,10 @@ static void __ref sfi_unmap_memory(void __iomem *virt, u32 size)
 	if (!virt || !size)
 		return;
 
-	if (sfi_use_ioremap)
-		iounmap(virt);
+	if (sfi_use_memremap)
+		memunmap(virt);
 	else
-		early_iounmap(virt, size);
+		early_memunmap(virt, size);
 }
 
 static void sfi_print_table_header(unsigned long long pa,
@@ -507,8 +507,8 @@ void __init sfi_init_late(void)
 	length = syst_va->header.len;
 	sfi_unmap_memory(syst_va, sizeof(struct sfi_table_simple));
 
-	/* Use ioremap now after it is ready */
-	sfi_use_ioremap = 1;
+	/* Use memremap now after it is ready */
+	sfi_use_memremap = 1;
 	syst_va = sfi_map_memory(syst_pa, length);
 
 	sfi_acpi_init();

commit 108cc2e7d212c7d52694fb400423da807e1e5fe4
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Apr 30 12:42:50 2013 +0300

    SFI: fix compiler warnings
    
    drivers/sfi/sfi_core.c:164:26: warning: no previous prototype for ‘sfi_map_table’ [-Wmissing-prototypes]
    drivers/sfi/sfi_core.c:192:6: warning: no previous prototype for ‘sfi_unmap_table’ [-Wmissing-prototypes]
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/sfi/sfi_core.c b/drivers/sfi/sfi_core.c
index 1e824fb1649b..296db7a69c27 100644
--- a/drivers/sfi/sfi_core.c
+++ b/drivers/sfi/sfi_core.c
@@ -161,7 +161,7 @@ static int sfi_verify_table(struct sfi_table_header *table)
  * Check for common case that we can re-use mapping to SYST,
  * which requires syst_pa, syst_va to be initialized.
  */
-struct sfi_table_header *sfi_map_table(u64 pa)
+static struct sfi_table_header *sfi_map_table(u64 pa)
 {
 	struct sfi_table_header *th;
 	u32 length;
@@ -189,7 +189,7 @@ struct sfi_table_header *sfi_map_table(u64 pa)
  * Undoes effect of sfi_map_table() by unmapping table
  * if it did not completely fit on same page as SYST.
  */
-void sfi_unmap_table(struct sfi_table_header *th)
+static void sfi_unmap_table(struct sfi_table_header *th)
 {
 	if (!TABLE_ON_PAGE(syst_va, th, th->len))
 		sfi_unmap_memory(th, TABLE_ON_PAGE(th, th, th->len) ?

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/sfi/sfi_core.c b/drivers/sfi/sfi_core.c
index 04113e5304a0..1e824fb1649b 100644
--- a/drivers/sfi/sfi_core.c
+++ b/drivers/sfi/sfi_core.c
@@ -515,7 +515,7 @@ void __init sfi_init_late(void)
 }
 
 /*
- * The reason we put it here becasue we need wait till the /sys/firmware
+ * The reason we put it here because we need wait till the /sys/firmware
  * is setup, then our interface can be registered in /sys/firmware/sfi
  */
 core_initcall(sfi_sysfs_init);

commit 5b026c4e3af52fda22c9313a3388344f82f3ba15
Author: Len Brown <len.brown@intel.com>
Date:   Tue Jan 11 23:25:30 2011 -0500

    SFI: use ioremap_cache() instead of ioremap()
    
    We copied ACPI's oversight of using ioremap() and creating
    non-cached table mappings when we should have been using
    ioremap_cache().
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/sfi/sfi_core.c b/drivers/sfi/sfi_core.c
index ceba593dc84f..04113e5304a0 100644
--- a/drivers/sfi/sfi_core.c
+++ b/drivers/sfi/sfi_core.c
@@ -101,7 +101,7 @@ static void __iomem * __ref sfi_map_memory(u64 phys, u32 size)
 		return NULL;
 
 	if (sfi_use_ioremap)
-		return ioremap(phys, size);
+		return ioremap_cache(phys, size);
 	else
 		return early_ioremap(phys, size);
 }

commit e29df91e67428c1a651d18df6ec047fcb30282d3
Author: Dan Carpenter <error27@gmail.com>
Date:   Fri May 28 12:33:15 2010 +0200

    SFI: do not return freed pointer
    
    We never actually use the return value of sfi_sysfs_install_table() but
    it still seems wrong to return a freed pointer.
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/sfi/sfi_core.c b/drivers/sfi/sfi_core.c
index 005195958647..ceba593dc84f 100644
--- a/drivers/sfi/sfi_core.c
+++ b/drivers/sfi/sfi_core.c
@@ -441,8 +441,10 @@ struct sfi_table_attr __init *sfi_sysfs_install_table(u64 pa)
 
 	ret = sysfs_create_bin_file(tables_kobj,
 				  &tbl_attr->attr);
-	if (ret)
+	if (ret) {
 		kfree(tbl_attr);
+		tbl_attr = NULL;
+	}
 
 	sfi_unmap_table(th);
 	return tbl_attr;

commit dce80a56268fffd6b5ea57b3f6ba3d027a68f05e
Author: Feng Tang <feng.tang@intel.com>
Date:   Wed May 26 11:28:08 2010 +0800

    SFI: add sysfs interface for SFI tables.
    
    Analogous to ACPI's /sys/firmware/acpi/tables/...
    
    create /sys/firmware/sfi/tables/
    
    The tables are primariy for the kernel,
    but sometimes it is useful for user-space to be
    able to read them.
    
    Signed-off-by: Feng Tang <feng.tang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/sfi/sfi_core.c b/drivers/sfi/sfi_core.c
index aba6a461365b..005195958647 100644
--- a/drivers/sfi/sfi_core.c
+++ b/drivers/sfi/sfi_core.c
@@ -67,6 +67,7 @@
 #include <linux/acpi.h>
 #include <linux/init.h>
 #include <linux/sfi.h>
+#include <linux/slab.h>
 
 #include "sfi_core.h"
 
@@ -382,6 +383,102 @@ static __init int sfi_find_syst(void)
 	return -1;
 }
 
+static struct kobject *sfi_kobj;
+static struct kobject *tables_kobj;
+
+static ssize_t sfi_table_show(struct file *filp, struct kobject *kobj,
+			       struct bin_attribute *bin_attr, char *buf,
+			       loff_t offset, size_t count)
+{
+	struct sfi_table_attr *tbl_attr =
+	    container_of(bin_attr, struct sfi_table_attr, attr);
+	struct sfi_table_header *th = NULL;
+	struct sfi_table_key key;
+	ssize_t cnt;
+
+	key.sig = tbl_attr->name;
+	key.oem_id = NULL;
+	key.oem_table_id = NULL;
+
+	if (strncmp(SFI_SIG_SYST, tbl_attr->name, SFI_SIGNATURE_SIZE)) {
+		th = sfi_get_table(&key);
+		if (!th)
+			return 0;
+
+		cnt =  memory_read_from_buffer(buf, count, &offset,
+						th, th->len);
+		sfi_put_table(th);
+	} else
+		cnt =  memory_read_from_buffer(buf, count, &offset,
+					syst_va, syst_va->header.len);
+
+	return cnt;
+}
+
+struct sfi_table_attr __init *sfi_sysfs_install_table(u64 pa)
+{
+	struct sfi_table_attr *tbl_attr;
+	struct sfi_table_header *th;
+	int ret;
+
+	tbl_attr = kzalloc(sizeof(struct sfi_table_attr), GFP_KERNEL);
+	if (!tbl_attr)
+		return NULL;
+
+	th = sfi_map_table(pa);
+	if (!th || !th->sig[0]) {
+		kfree(tbl_attr);
+		return NULL;
+	}
+
+	sysfs_attr_init(&tbl_attr->attr.attr);
+	memcpy(tbl_attr->name, th->sig, SFI_SIGNATURE_SIZE);
+
+	tbl_attr->attr.size = 0;
+	tbl_attr->attr.read = sfi_table_show;
+	tbl_attr->attr.attr.name = tbl_attr->name;
+	tbl_attr->attr.attr.mode = 0400;
+
+	ret = sysfs_create_bin_file(tables_kobj,
+				  &tbl_attr->attr);
+	if (ret)
+		kfree(tbl_attr);
+
+	sfi_unmap_table(th);
+	return tbl_attr;
+}
+
+static int __init sfi_sysfs_init(void)
+{
+	int tbl_cnt, i;
+
+	if (sfi_disabled)
+		return 0;
+
+	sfi_kobj = kobject_create_and_add("sfi", firmware_kobj);
+	if (!sfi_kobj)
+		return 0;
+
+	tables_kobj = kobject_create_and_add("tables", sfi_kobj);
+	if (!tables_kobj) {
+		kobject_put(sfi_kobj);
+		return 0;
+	}
+
+	sfi_sysfs_install_table(syst_pa);
+
+	tbl_cnt = SFI_GET_NUM_ENTRIES(syst_va, u64);
+
+	for (i = 0; i < tbl_cnt; i++)
+		sfi_sysfs_install_table(syst_va->pentry[i]);
+
+	sfi_acpi_sysfs_init();
+	kobject_uevent(sfi_kobj, KOBJ_ADD);
+	kobject_uevent(tables_kobj, KOBJ_ADD);
+	pr_info("SFI sysfs interfaces init success\n");
+	return 0;
+}
+
 void __init sfi_init(void)
 {
 	if (!acpi_disabled)
@@ -414,3 +511,9 @@ void __init sfi_init_late(void)
 
 	sfi_acpi_init();
 }
+
+/*
+ * The reason we put it here becasue we need wait till the /sys/firmware
+ * is setup, then our interface can be registered in /sys/firmware/sfi
+ */
+core_initcall(sfi_sysfs_init);

commit 5487ab4a5a71e955fef7094a0624df0542da91ef
Author: Feng Tang <feng.tang@intel.com>
Date:   Tue May 25 16:40:47 2010 +0800

    SFI: add support for v0.81 spec
    
    There are 2 major changes from v0.81 to v0.7:
    1. Consolidating the SPIB/I2CB tables into a new DEVS table,
       which is more expandable and can support other bus types
       than spi/i2c.
    2. Creating a new GPIO table, which list all the GPIO pins
       used in the platform.
    
    However, to avoid breaking current platforms who use SFI v0.7
    version firmware, the definitions for SPIB/I2CB will still
    be kept for a while
    
    Signed-off-by: Feng Tang <feng.tang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/sfi/sfi_core.c b/drivers/sfi/sfi_core.c
index b204a0929139..aba6a461365b 100644
--- a/drivers/sfi/sfi_core.c
+++ b/drivers/sfi/sfi_core.c
@@ -390,7 +390,7 @@ void __init sfi_init(void)
 	if (sfi_disabled)
 		return;
 
-	pr_info("Simple Firmware Interface v0.7 http://simplefirmware.org\n");
+	pr_info("Simple Firmware Interface v0.81 http://simplefirmware.org\n");
 
 	if (sfi_find_syst() || sfi_parse_syst() || sfi_platform_init())
 		disable_sfi();

commit 011a606d0670196c17110b6770e39cc0865aa614
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Fri Oct 2 07:29:47 2009 -0700

    SFI: remove __init from sfi_verify_table
    
    sfi_verify_table() is called at runtime, and thus cannot be __init
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/sfi/sfi_core.c b/drivers/sfi/sfi_core.c
index 251da2298b69..b204a0929139 100644
--- a/drivers/sfi/sfi_core.c
+++ b/drivers/sfi/sfi_core.c
@@ -129,7 +129,7 @@ static void sfi_print_table_header(unsigned long long pa,
  * sfi_verify_table()
  * Sanity check table lengh, calculate checksum
  */
-static __init int sfi_verify_table(struct sfi_table_header *table)
+static int sfi_verify_table(struct sfi_table_header *table)
 {
 
 	u8 checksum = 0;

commit 01674da6f587a3f3940eedf2c1e97d51c35b994e
Author: Rakib Mullick <rakib.mullick@gmail.com>
Date:   Wed Sep 30 16:09:55 2009 -0700

    SFI: fix section mismatch warnings in sfi_core.c
    
    The function sfi_map_memory/sfi_unmap_memory uses
    early_ioremap/early_iounmap respectively, which refers to a __init
    function.  And function sfi_check_table also refers to a __init function
    sfi_verify_table.  Since the references are valid, so use __ref to get rid
    of the warnings.
    
     We were warned by the following warnings:
    
      LD      vmlinux.o
      MODPOST vmlinux.o
    WARNING: vmlinux.o(.text+0xb6ba3a): Section mismatch in reference from
    the function sfi_map_memory() to the function
    .init.text:early_ioremap()
    The function sfi_map_memory() references
    the function __init early_ioremap().
    This is often because sfi_map_memory lacks a __init
    annotation or the annotation of early_ioremap is wrong.
    
    WARNING: vmlinux.o(.text+0xb6bab6): Section mismatch in reference from
    the function sfi_unmap_memory() to the function
    .init.text:early_iounmap()
    The function sfi_unmap_memory() references
    the function __init early_iounmap().
    This is often because sfi_unmap_memory lacks a __init
    annotation or the annotation of early_iounmap is wrong.
    
    WARNING: vmlinux.o(.text+0xb6be30): Section mismatch in reference from
    the function sfi_check_table() to the function
    .init.text:sfi_verify_table()
    The function sfi_check_table() references
    the function __init sfi_verify_table().
    This is often because sfi_check_table lacks a __init
    annotation or the annotation of sfi_verify_table is wrong.
    
    Signed-off-by: Rakib Mullick <rakib.mullick@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/sfi/sfi_core.c b/drivers/sfi/sfi_core.c
index d3b496800477..251da2298b69 100644
--- a/drivers/sfi/sfi_core.c
+++ b/drivers/sfi/sfi_core.c
@@ -90,7 +90,11 @@ static struct sfi_table_simple *syst_va __read_mostly;
  */
 static u32 sfi_use_ioremap __read_mostly;
 
-static void __iomem *sfi_map_memory(u64 phys, u32 size)
+/*
+ * sfi_un/map_memory calls early_ioremap/iounmap which is a __init function
+ * and introduces section mismatch. So use __ref to make it calm.
+ */
+static void __iomem * __ref sfi_map_memory(u64 phys, u32 size)
 {
 	if (!phys || !size)
 		return NULL;
@@ -101,7 +105,7 @@ static void __iomem *sfi_map_memory(u64 phys, u32 size)
 		return early_ioremap(phys, size);
 }
 
-static void sfi_unmap_memory(void __iomem *virt, u32 size)
+static void __ref sfi_unmap_memory(void __iomem *virt, u32 size)
 {
 	if (!virt || !size)
 		return;
@@ -213,12 +217,17 @@ static int sfi_table_check_key(struct sfi_table_header *th,
  *    the mapped virt address will be returned, and the virt space
  *    will be released by call sfi_put_table() later
  *
+ * This two cases are from two different functions with two different
+ * sections and causes section mismatch warning. So use __ref to tell
+ * modpost not to make any noise.
+ *
  * Return value:
  *	NULL:			when can't find a table matching the key
  *	ERR_PTR(error):		error value
  *	virt table address:	when a matched table is found
  */
-struct sfi_table_header *sfi_check_table(u64 pa, struct sfi_table_key *key)
+struct sfi_table_header *
+ __ref sfi_check_table(u64 pa, struct sfi_table_key *key)
 {
 	struct sfi_table_header *th;
 	void *ret = NULL;

commit 3834f47291df475be3f0f0fb7ccaa098967cc054
Author: Feng Tang <feng.tang@intel.com>
Date:   Mon Sep 14 13:01:53 2009 +0800

    SFI: remove unneeded includes
    
    Signed-off-by: Feng Tang <feng.tang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/sfi/sfi_core.c b/drivers/sfi/sfi_core.c
index 7bd6b18fdd27..d3b496800477 100644
--- a/drivers/sfi/sfi_core.c
+++ b/drivers/sfi/sfi_core.c
@@ -62,16 +62,11 @@
 #include <linux/bootmem.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/string.h>
 #include <linux/errno.h>
 #include <linux/types.h>
 #include <linux/acpi.h>
 #include <linux/init.h>
-#include <linux/irq.h>
 #include <linux/sfi.h>
-#include <linux/smp.h>
-
-#include <asm/pgtable.h>
 
 #include "sfi_core.h"
 

commit 6ae6996a466e14bcf41618cde641a74ae03dc285
Author: Feng Tang <feng.tang@intel.com>
Date:   Fri Aug 14 15:13:46 2009 -0400

    SFI: add platform-independent core support
    
    drivers/sfi/sfi_core.c contains the generic SFI implementation.
    It has a private header, sfi_core.h, for its own use and the
    private use of future files in drivers/sfi/
    
    Signed-off-by: Feng Tang <feng.tang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/sfi/sfi_core.c b/drivers/sfi/sfi_core.c
new file mode 100644
index 000000000000..7bd6b18fdd27
--- /dev/null
+++ b/drivers/sfi/sfi_core.c
@@ -0,0 +1,412 @@
+/* sfi_core.c Simple Firmware Interface - core internals */
+
+/*
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2009 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  BSD LICENSE
+
+  Copyright(c) 2009 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#define KMSG_COMPONENT "SFI"
+#define pr_fmt(fmt) KMSG_COMPONENT ": " fmt
+
+#include <linux/bootmem.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/acpi.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/sfi.h>
+#include <linux/smp.h>
+
+#include <asm/pgtable.h>
+
+#include "sfi_core.h"
+
+#define ON_SAME_PAGE(addr1, addr2) \
+	(((unsigned long)(addr1) & PAGE_MASK) == \
+	((unsigned long)(addr2) & PAGE_MASK))
+#define TABLE_ON_PAGE(page, table, size) (ON_SAME_PAGE(page, table) && \
+				ON_SAME_PAGE(page, table + size))
+
+int sfi_disabled __read_mostly;
+EXPORT_SYMBOL(sfi_disabled);
+
+static u64 syst_pa __read_mostly;
+static struct sfi_table_simple *syst_va __read_mostly;
+
+/*
+ * FW creates and saves the SFI tables in memory. When these tables get
+ * used, they may need to be mapped to virtual address space, and the mapping
+ * can happen before or after the ioremap() is ready, so a flag is needed
+ * to indicating this
+ */
+static u32 sfi_use_ioremap __read_mostly;
+
+static void __iomem *sfi_map_memory(u64 phys, u32 size)
+{
+	if (!phys || !size)
+		return NULL;
+
+	if (sfi_use_ioremap)
+		return ioremap(phys, size);
+	else
+		return early_ioremap(phys, size);
+}
+
+static void sfi_unmap_memory(void __iomem *virt, u32 size)
+{
+	if (!virt || !size)
+		return;
+
+	if (sfi_use_ioremap)
+		iounmap(virt);
+	else
+		early_iounmap(virt, size);
+}
+
+static void sfi_print_table_header(unsigned long long pa,
+				struct sfi_table_header *header)
+{
+	pr_info("%4.4s %llX, %04X (v%d %6.6s %8.8s)\n",
+		header->sig, pa,
+		header->len, header->rev, header->oem_id,
+		header->oem_table_id);
+}
+
+/*
+ * sfi_verify_table()
+ * Sanity check table lengh, calculate checksum
+ */
+static __init int sfi_verify_table(struct sfi_table_header *table)
+{
+
+	u8 checksum = 0;
+	u8 *puchar = (u8 *)table;
+	u32 length = table->len;
+
+	/* Sanity check table length against arbitrary 1MB limit */
+	if (length > 0x100000) {
+		pr_err("Invalid table length 0x%x\n", length);
+		return -1;
+	}
+
+	while (length--)
+		checksum += *puchar++;
+
+	if (checksum) {
+		pr_err("Checksum %2.2X should be %2.2X\n",
+			table->csum, table->csum - checksum);
+		return -1;
+	}
+	return 0;
+}
+
+/*
+ * sfi_map_table()
+ *
+ * Return address of mapped table
+ * Check for common case that we can re-use mapping to SYST,
+ * which requires syst_pa, syst_va to be initialized.
+ */
+struct sfi_table_header *sfi_map_table(u64 pa)
+{
+	struct sfi_table_header *th;
+	u32 length;
+
+	if (!TABLE_ON_PAGE(syst_pa, pa, sizeof(struct sfi_table_header)))
+		th = sfi_map_memory(pa, sizeof(struct sfi_table_header));
+	else
+		th = (void *)syst_va + (pa - syst_pa);
+
+	 /* If table fits on same page as its header, we are done */
+	if (TABLE_ON_PAGE(th, th, th->len))
+		return th;
+
+	/* Entire table does not fit on same page as SYST */
+	length = th->len;
+	if (!TABLE_ON_PAGE(syst_pa, pa, sizeof(struct sfi_table_header)))
+		sfi_unmap_memory(th, sizeof(struct sfi_table_header));
+
+	return sfi_map_memory(pa, length);
+}
+
+/*
+ * sfi_unmap_table()
+ *
+ * Undoes effect of sfi_map_table() by unmapping table
+ * if it did not completely fit on same page as SYST.
+ */
+void sfi_unmap_table(struct sfi_table_header *th)
+{
+	if (!TABLE_ON_PAGE(syst_va, th, th->len))
+		sfi_unmap_memory(th, TABLE_ON_PAGE(th, th, th->len) ?
+					sizeof(*th) : th->len);
+}
+
+static int sfi_table_check_key(struct sfi_table_header *th,
+				struct sfi_table_key *key)
+{
+
+	if (strncmp(th->sig, key->sig, SFI_SIGNATURE_SIZE)
+		|| (key->oem_id && strncmp(th->oem_id,
+				key->oem_id, SFI_OEM_ID_SIZE))
+		|| (key->oem_table_id && strncmp(th->oem_table_id,
+				key->oem_table_id, SFI_OEM_TABLE_ID_SIZE)))
+		return -1;
+
+	return 0;
+}
+
+/*
+ * This function will be used in 2 cases:
+ * 1. used to enumerate and verify the tables addressed by SYST/XSDT,
+ *    thus no signature will be given (in kernel boot phase)
+ * 2. used to parse one specific table, signature must exist, and
+ *    the mapped virt address will be returned, and the virt space
+ *    will be released by call sfi_put_table() later
+ *
+ * Return value:
+ *	NULL:			when can't find a table matching the key
+ *	ERR_PTR(error):		error value
+ *	virt table address:	when a matched table is found
+ */
+struct sfi_table_header *sfi_check_table(u64 pa, struct sfi_table_key *key)
+{
+	struct sfi_table_header *th;
+	void *ret = NULL;
+
+	th = sfi_map_table(pa);
+	if (!th)
+		return ERR_PTR(-ENOMEM);
+
+	if (!key->sig) {
+		sfi_print_table_header(pa, th);
+		if (sfi_verify_table(th))
+			ret = ERR_PTR(-EINVAL);
+	} else {
+		if (!sfi_table_check_key(th, key))
+			return th;	/* Success */
+	}
+
+	sfi_unmap_table(th);
+	return ret;
+}
+
+/*
+ * sfi_get_table()
+ *
+ * Search SYST for the specified table with the signature in
+ * the key, and return the mapped table
+ */
+struct sfi_table_header *sfi_get_table(struct sfi_table_key *key)
+{
+	struct sfi_table_header *th;
+	u32 tbl_cnt, i;
+
+	tbl_cnt = SFI_GET_NUM_ENTRIES(syst_va, u64);
+	for (i = 0; i < tbl_cnt; i++) {
+		th = sfi_check_table(syst_va->pentry[i], key);
+		if (!IS_ERR(th) && th)
+			return th;
+	}
+
+	return NULL;
+}
+
+void sfi_put_table(struct sfi_table_header *th)
+{
+	sfi_unmap_table(th);
+}
+
+/* Find table with signature, run handler on it */
+int sfi_table_parse(char *signature, char *oem_id, char *oem_table_id,
+			sfi_table_handler handler)
+{
+	struct sfi_table_header *table = NULL;
+	struct sfi_table_key key;
+	int ret = -EINVAL;
+
+	if (sfi_disabled || !handler || !signature)
+		goto exit;
+
+	key.sig = signature;
+	key.oem_id = oem_id;
+	key.oem_table_id = oem_table_id;
+
+	table = sfi_get_table(&key);
+	if (!table)
+		goto exit;
+
+	ret = handler(table);
+	sfi_put_table(table);
+exit:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(sfi_table_parse);
+
+/*
+ * sfi_parse_syst()
+ * Checksum all the tables in SYST and print their headers
+ *
+ * success: set syst_va, return 0
+ */
+static int __init sfi_parse_syst(void)
+{
+	struct sfi_table_key key = SFI_ANY_KEY;
+	int tbl_cnt, i;
+	void *ret;
+
+	syst_va = sfi_map_memory(syst_pa, sizeof(struct sfi_table_simple));
+	if (!syst_va)
+		return -ENOMEM;
+
+	tbl_cnt = SFI_GET_NUM_ENTRIES(syst_va, u64);
+	for (i = 0; i < tbl_cnt; i++) {
+		ret = sfi_check_table(syst_va->pentry[i], &key);
+		if (IS_ERR(ret))
+			return PTR_ERR(ret);
+	}
+
+	return 0;
+}
+
+/*
+ * The OS finds the System Table by searching 16-byte boundaries between
+ * physical address 0x000E0000 and 0x000FFFFF. The OS shall search this region
+ * starting at the low address and shall stop searching when the 1st valid SFI
+ * System Table is found.
+ *
+ * success: set syst_pa, return 0
+ * fail: return -1
+ */
+static __init int sfi_find_syst(void)
+{
+	unsigned long offset, len;
+	void *start;
+
+	len = SFI_SYST_SEARCH_END - SFI_SYST_SEARCH_BEGIN;
+	start = sfi_map_memory(SFI_SYST_SEARCH_BEGIN, len);
+	if (!start)
+		return -1;
+
+	for (offset = 0; offset < len; offset += 16) {
+		struct sfi_table_header *syst_hdr;
+
+		syst_hdr = start + offset;
+		if (strncmp(syst_hdr->sig, SFI_SIG_SYST,
+				SFI_SIGNATURE_SIZE))
+			continue;
+
+		if (syst_hdr->len > PAGE_SIZE)
+			continue;
+
+		sfi_print_table_header(SFI_SYST_SEARCH_BEGIN + offset,
+					syst_hdr);
+
+		if (sfi_verify_table(syst_hdr))
+			continue;
+
+		/*
+		 * Enforce SFI spec mandate that SYST reside within a page.
+		 */
+		if (!ON_SAME_PAGE(syst_pa, syst_pa + syst_hdr->len)) {
+			pr_info("SYST 0x%llx + 0x%x crosses page\n",
+					syst_pa, syst_hdr->len);
+			continue;
+		}
+
+		/* Success */
+		syst_pa = SFI_SYST_SEARCH_BEGIN + offset;
+		sfi_unmap_memory(start, len);
+		return 0;
+	}
+
+	sfi_unmap_memory(start, len);
+	return -1;
+}
+
+void __init sfi_init(void)
+{
+	if (!acpi_disabled)
+		disable_sfi();
+
+	if (sfi_disabled)
+		return;
+
+	pr_info("Simple Firmware Interface v0.7 http://simplefirmware.org\n");
+
+	if (sfi_find_syst() || sfi_parse_syst() || sfi_platform_init())
+		disable_sfi();
+
+	return;
+}
+
+void __init sfi_init_late(void)
+{
+	int length;
+
+	if (sfi_disabled)
+		return;
+
+	length = syst_va->header.len;
+	sfi_unmap_memory(syst_va, sizeof(struct sfi_table_simple));
+
+	/* Use ioremap now after it is ready */
+	sfi_use_ioremap = 1;
+	syst_va = sfi_map_memory(syst_pa, length);
+
+	sfi_acpi_init();
+}
