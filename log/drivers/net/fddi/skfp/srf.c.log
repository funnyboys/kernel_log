commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/fddi/skfp/srf.c b/drivers/net/fddi/skfp/srf.c
index 4e286c1ba9cd..f98d060b0f5b 100644
--- a/drivers/net/fddi/skfp/srf.c
+++ b/drivers/net/fddi/skfp/srf.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /******************************************************************************
  *
  *	(C)Copyright 1998,1999 SysKonnect,
@@ -5,11 +6,6 @@
  *
  *	See the file "skfddi.c" for further information.
  *
- *	This program is free software; you can redistribute it and/or modify
- *	it under the terms of the GNU General Public License as published by
- *	the Free Software Foundation; either version 2 of the License, or
- *	(at your option) any later version.
- *
  *	The information in this file is provided "AS IS" without warranty.
  *
  ******************************************************************************/

commit 5671e8c19c8cb4dd432e54f5bc5e2e9a9bac894b
Author: Joe Perches <joe@perches.com>
Date:   Wed Dec 21 19:54:53 2016 -0800

    fddi: skfp: Use more common logging styles
    
    Several macros use non-standard styles where format and arguments
    are not verified.  Convert these to a more typical fmt, ##__VA_ARGS__
    use so format and arguments match as appropriate.
    
    Miscellanea:
    
    o Fix format and argument mismatches
    o Realign and reindent misindented block
    o Strip newlines from formats and add to macro defines
    o Coalesce a few consecutive logging uses to more simple single uses
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/fddi/skfp/srf.c b/drivers/net/fddi/skfp/srf.c
index 9956680402de..4e286c1ba9cd 100644
--- a/drivers/net/fddi/skfp/srf.c
+++ b/drivers/net/fddi/skfp/srf.c
@@ -173,7 +173,6 @@ static struct s_srf_evc *smt_get_evc(struct s_smc *smc, int code, int index)
 #define THRESHOLD_2	(2*TICKS_PER_SECOND)
 #define THRESHOLD_32	(32*TICKS_PER_SECOND)
 
-#ifdef	DEBUG
 static const char * const srf_names[] = {
 	"None","MACPathChangeEvent",	"MACNeighborChangeEvent",
 	"PORTPathChangeEvent",		"PORTUndesiredConnectionAttemptEvent",
@@ -182,7 +181,6 @@ static const char * const srf_names[] = {
 	"MACNotCopiedCondition",	"PORTEBErrorCondition",
 	"PORTLerCondition"
 } ;
-#endif
 
 void smt_srf_event(struct s_smc *smc, int code, int index, int cond)
 {
@@ -198,10 +196,10 @@ void smt_srf_event(struct s_smc *smc, int code, int index, int cond)
 	}
 
 	if (code) {
-		DB_SMT("SRF: %s index %d\n",srf_names[code],index) ;
+		DB_SMT("SRF: %s index %d", srf_names[code], index);
 
 		if (!(evc = smt_get_evc(smc,code,index))) {
-			DB_SMT("SRF : smt_get_evc() failed\n",0,0) ;
+			DB_SMT("SRF : smt_get_evc() failed");
 			return ;
 		}
 		/*
@@ -217,7 +215,7 @@ void smt_srf_event(struct s_smc *smc, int code, int index, int cond)
 		 */
 		smt_set_timestamp(smc,smc->mib.fddiSMTTransitionTimeStamp) ;
 		if (SMT_IS_CONDITION(code)) {
-			DB_SMT("SRF: condition is %s\n",cond ? "ON":"OFF",0) ;
+			DB_SMT("SRF: condition is %s", cond ? "ON" : "OFF");
 			if (cond) {
 				*evc->evc_cond_state = TRUE ;
 				evc->evc_rep_required = TRUE ;
@@ -414,9 +412,9 @@ static void smt_send_srf(struct s_smc *smc)
 	smt->smt_len = SMT_MAX_INFO_LEN - pcon.pc_len ;
 	mb->sm_len = smt->smt_len + sizeof(struct smt_header) ;
 
-	DB_SMT("SRF: sending SRF at %p, len %d\n",smt,mb->sm_len) ;
-	DB_SMT("SRF: state SR%d Threshold %d\n",
-		smc->srf.sr_state,smc->srf.SRThreshold/TICKS_PER_SECOND) ;
+	DB_SMT("SRF: sending SRF at %p, len %d", smt, mb->sm_len);
+	DB_SMT("SRF: state SR%d Threshold %lu",
+	       smc->srf.sr_state, smc->srf.SRThreshold / TICKS_PER_SECOND);
 #ifdef	DEBUG
 	dump_smt(smc,smt,"SRF Send") ;
 #endif

commit 908e80d6546813aaf8b546b4b4483fcec24190b6
Author: Colin Ian King <colin.king@canonical.com>
Date:   Fri Jun 5 19:19:11 2015 +0100

    fddi: print an address with %p format specifier rather than %x
    
    The debug is printing the struct smt_header * address using
    the %x format specifier. Fix it to use %p instead.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/fddi/skfp/srf.c b/drivers/net/fddi/skfp/srf.c
index cc27dea3414e..9956680402de 100644
--- a/drivers/net/fddi/skfp/srf.c
+++ b/drivers/net/fddi/skfp/srf.c
@@ -414,7 +414,7 @@ static void smt_send_srf(struct s_smc *smc)
 	smt->smt_len = SMT_MAX_INFO_LEN - pcon.pc_len ;
 	mb->sm_len = smt->smt_len + sizeof(struct smt_header) ;
 
-	DB_SMT("SRF: sending SRF at %x, len %d\n",smt,mb->sm_len) ;
+	DB_SMT("SRF: sending SRF at %p, len %d\n",smt,mb->sm_len) ;
 	DB_SMT("SRF: state SR%d Threshold %d\n",
 		smc->srf.sr_state,smc->srf.SRThreshold/TICKS_PER_SECOND) ;
 #ifdef	DEBUG

commit 89e47d3b8a273b0eac21e4bf6d7fdb86b654fa16
Author: tanxiaojun <tanxiaojun@huawei.com>
Date:   Fri Dec 13 14:49:56 2013 +0800

    fddi: cleanup unsigned to unsigned int/short
    
    Use "unsigned int/short" instead of "unsigned", and change the type of
    iteration variable "i" to "unsigned int".
    
    Signed-off-by: Tan Xiaojun <tanxiaojun@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/fddi/skfp/srf.c b/drivers/net/fddi/skfp/srf.c
index f6f7baf9f27a..cc27dea3414e 100644
--- a/drivers/net/fddi/skfp/srf.c
+++ b/drivers/net/fddi/skfp/srf.c
@@ -73,7 +73,7 @@ void smt_init_evc(struct s_smc *smc)
 {
 	struct s_srf_evc	*evc ;
 	const struct evc_init 	*init ;
-	int			i ;
+	unsigned int		i ;
 	int			index ;
 	int			offset ;
 
@@ -84,7 +84,7 @@ void smt_init_evc(struct s_smc *smc)
 	evc = smc->evcs ;
 	init = evc_inits ;
 
-	for (i = 0 ; (unsigned) i < MAX_INIT_EVC ; i++) {
+	for (i = 0 ; i < MAX_INIT_EVC ; i++) {
 		for (index = 0 ; index < init->n ; index++) {
 			evc->evc_code = init->code ;
 			evc->evc_para = init->para ;
@@ -98,7 +98,7 @@ void smt_init_evc(struct s_smc *smc)
 		init++ ;
 	}
 
-	if ((unsigned) (evc - smc->evcs) > MAX_EVCS) {
+	if ((unsigned int) (evc - smc->evcs) > MAX_EVCS) {
 		SMT_PANIC(smc,SMT_E0127, SMT_E0127_MSG) ;
 	}
 
@@ -139,7 +139,7 @@ void smt_init_evc(struct s_smc *smc)
 		offset++ ;
 	}
 #ifdef	DEBUG
-	for (i = 0, evc = smc->evcs ; (unsigned) i < MAX_EVCS ; i++, evc++) {
+	for (i = 0, evc = smc->evcs ; i < MAX_EVCS ; i++, evc++) {
 		if (SMT_IS_CONDITION(evc->evc_code)) {
 			if (!evc->evc_cond_state) {
 				SMT_PANIC(smc,SMT_E0128, SMT_E0128_MSG) ;
@@ -160,10 +160,10 @@ void smt_init_evc(struct s_smc *smc)
 
 static struct s_srf_evc *smt_get_evc(struct s_smc *smc, int code, int index)
 {
-	int			i ;
+	unsigned int		i ;
 	struct s_srf_evc	*evc ;
 
-	for (i = 0, evc = smc->evcs ; (unsigned) i < MAX_EVCS ; i++, evc++) {
+	for (i = 0, evc = smc->evcs ; i < MAX_EVCS ; i++, evc++) {
 		if (evc->evc_code == code && evc->evc_index == index)
 			return evc;
 	}
@@ -335,9 +335,9 @@ void smt_srf_event(struct s_smc *smc, int code, int index, int cond)
 static void clear_all_rep(struct s_smc *smc)
 {
 	struct s_srf_evc	*evc ;
-	int			i ;
+	unsigned int		i ;
 
-	for (i = 0, evc = smc->evcs ; (unsigned) i < MAX_EVCS ; i++, evc++) {
+	for (i = 0, evc = smc->evcs ; i < MAX_EVCS ; i++, evc++) {
 		evc->evc_rep_required = FALSE ;
 		if (SMT_IS_CONDITION(evc->evc_code))
 			*evc->evc_cond_state = FALSE ;
@@ -348,10 +348,10 @@ static void clear_all_rep(struct s_smc *smc)
 static void clear_reported(struct s_smc *smc)
 {
 	struct s_srf_evc	*evc ;
-	int			i ;
+	unsigned int		i ;
 
 	smc->srf.any_report = FALSE ;
-	for (i = 0, evc = smc->evcs ; (unsigned) i < MAX_EVCS ; i++, evc++) {
+	for (i = 0, evc = smc->evcs ; i < MAX_EVCS ; i++, evc++) {
 		if (SMT_IS_CONDITION(evc->evc_code)) {
 			if (*evc->evc_cond_state == FALSE)
 				evc->evc_rep_required = FALSE ;
@@ -375,7 +375,7 @@ static void smt_send_srf(struct s_smc *smc)
 	struct s_srf_evc	*evc ;
 	SK_LOC_DECL(struct s_pcon,pcon) ;
 	SMbuf			*mb ;
-	int			i ;
+	unsigned int		i ;
 
 	static const struct fddi_addr SMT_SRF_DA = {
 		{ 0x80, 0x01, 0x43, 0x00, 0x80, 0x08 }
@@ -405,7 +405,7 @@ static void smt_send_srf(struct s_smc *smc)
 	smt_add_para(smc,&pcon,(u_short) SMT_P1033,0,0) ;
 	smt_add_para(smc,&pcon,(u_short) SMT_P1034,0,0) ;
 
-	for (i = 0, evc = smc->evcs ; (unsigned) i < MAX_EVCS ; i++, evc++) {
+	for (i = 0, evc = smc->evcs ; i < MAX_EVCS ; i++, evc++) {
 		if (evc->evc_rep_required) {
 			smt_add_para(smc,&pcon,evc->evc_para,
 				(int)evc->evc_index,0) ;

commit 33f810b2036f13f1b123062a9e5c1794d400ce81
Author: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Date:   Sun Jul 31 00:06:29 2011 -0700

    fddi: Move the FDDI drivers
    
    Move the FDDI drivers into drivers/net/fddi/ and make the
    necessary Kconfig and Makefile changes.
    
    CC: "Maciej W. Rozycki" <macro@linux-mips.org>
    CC: Christoph Goos <cgoos@syskonnect.de>
    CC: <linux@syskonnect.de>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/fddi/skfp/srf.c b/drivers/net/fddi/skfp/srf.c
new file mode 100644
index 000000000000..f6f7baf9f27a
--- /dev/null
+++ b/drivers/net/fddi/skfp/srf.c
@@ -0,0 +1,429 @@
+/******************************************************************************
+ *
+ *	(C)Copyright 1998,1999 SysKonnect,
+ *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
+ *
+ *	See the file "skfddi.c" for further information.
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	The information in this file is provided "AS IS" without warranty.
+ *
+ ******************************************************************************/
+
+/*
+	SMT 7.2 Status Response Frame Implementation
+	SRF state machine and frame generation
+*/
+
+#include "h/types.h"
+#include "h/fddi.h"
+#include "h/smc.h"
+#include "h/smt_p.h"
+
+#define KERNEL
+#include "h/smtstate.h"
+
+#ifndef	SLIM_SMT
+#ifndef	BOOT
+
+#ifndef	lint
+static const char ID_sccs[] = "@(#)srf.c	1.18 97/08/04 (C) SK " ;
+#endif
+
+
+/*
+ * function declarations
+ */
+static void clear_all_rep(struct s_smc *smc);
+static void clear_reported(struct s_smc *smc);
+static void smt_send_srf(struct s_smc *smc);
+static struct s_srf_evc *smt_get_evc(struct s_smc *smc, int code, int index);
+
+#define MAX_EVCS	ARRAY_SIZE(smc->evcs)
+
+struct evc_init {
+	u_char code ;
+	u_char index ;
+	u_char n ;
+	u_short	para ;
+}  ;
+
+static const struct evc_init evc_inits[] = {
+	{ SMT_COND_SMT_PEER_WRAP,		0,1,SMT_P1048	} ,
+
+	{ SMT_COND_MAC_DUP_ADDR,		INDEX_MAC, NUMMACS,SMT_P208C } ,
+	{ SMT_COND_MAC_FRAME_ERROR,		INDEX_MAC, NUMMACS,SMT_P208D } ,
+	{ SMT_COND_MAC_NOT_COPIED,		INDEX_MAC, NUMMACS,SMT_P208E } ,
+	{ SMT_EVENT_MAC_NEIGHBOR_CHANGE,	INDEX_MAC, NUMMACS,SMT_P208F } ,
+	{ SMT_EVENT_MAC_PATH_CHANGE,		INDEX_MAC, NUMMACS,SMT_P2090 } ,
+
+	{ SMT_COND_PORT_LER,			INDEX_PORT,NUMPHYS,SMT_P4050 } ,
+	{ SMT_COND_PORT_EB_ERROR,		INDEX_PORT,NUMPHYS,SMT_P4052 } ,
+	{ SMT_EVENT_PORT_CONNECTION,		INDEX_PORT,NUMPHYS,SMT_P4051 } ,
+	{ SMT_EVENT_PORT_PATH_CHANGE,		INDEX_PORT,NUMPHYS,SMT_P4053 } ,
+} ;
+
+#define MAX_INIT_EVC	ARRAY_SIZE(evc_inits)
+
+void smt_init_evc(struct s_smc *smc)
+{
+	struct s_srf_evc	*evc ;
+	const struct evc_init 	*init ;
+	int			i ;
+	int			index ;
+	int			offset ;
+
+	static u_char		fail_safe = FALSE ;
+
+	memset((char *)smc->evcs,0,sizeof(smc->evcs)) ;
+
+	evc = smc->evcs ;
+	init = evc_inits ;
+
+	for (i = 0 ; (unsigned) i < MAX_INIT_EVC ; i++) {
+		for (index = 0 ; index < init->n ; index++) {
+			evc->evc_code = init->code ;
+			evc->evc_para = init->para ;
+			evc->evc_index = init->index + index ;
+#ifndef	DEBUG
+			evc->evc_multiple = &fail_safe ;
+			evc->evc_cond_state = &fail_safe ;
+#endif
+			evc++ ;
+		}
+		init++ ;
+	}
+
+	if ((unsigned) (evc - smc->evcs) > MAX_EVCS) {
+		SMT_PANIC(smc,SMT_E0127, SMT_E0127_MSG) ;
+	}
+
+	/*
+	 * conditions
+	 */
+	smc->evcs[0].evc_cond_state = &smc->mib.fddiSMTPeerWrapFlag ;
+	smc->evcs[1].evc_cond_state =
+		&smc->mib.m[MAC0].fddiMACDuplicateAddressCond ;
+	smc->evcs[2].evc_cond_state =
+		&smc->mib.m[MAC0].fddiMACFrameErrorFlag ;
+	smc->evcs[3].evc_cond_state =
+		&smc->mib.m[MAC0].fddiMACNotCopiedFlag ;
+
+	/*
+	 * events
+	 */
+	smc->evcs[4].evc_multiple = &smc->mib.m[MAC0].fddiMACMultiple_N ;
+	smc->evcs[5].evc_multiple = &smc->mib.m[MAC0].fddiMACMultiple_P ;
+
+	offset = 6 ;
+	for (i = 0 ; i < NUMPHYS ; i++) {
+		/*
+		 * conditions
+		 */
+		smc->evcs[offset + 0*NUMPHYS].evc_cond_state =
+			&smc->mib.p[i].fddiPORTLerFlag ;
+		smc->evcs[offset + 1*NUMPHYS].evc_cond_state =
+			&smc->mib.p[i].fddiPORTEB_Condition ;
+
+		/*
+		 * events
+		 */
+		smc->evcs[offset + 2*NUMPHYS].evc_multiple =
+			&smc->mib.p[i].fddiPORTMultiple_U ;
+		smc->evcs[offset + 3*NUMPHYS].evc_multiple =
+			&smc->mib.p[i].fddiPORTMultiple_P ;
+		offset++ ;
+	}
+#ifdef	DEBUG
+	for (i = 0, evc = smc->evcs ; (unsigned) i < MAX_EVCS ; i++, evc++) {
+		if (SMT_IS_CONDITION(evc->evc_code)) {
+			if (!evc->evc_cond_state) {
+				SMT_PANIC(smc,SMT_E0128, SMT_E0128_MSG) ;
+			}
+			evc->evc_multiple = &fail_safe ;
+		}
+		else {
+			if (!evc->evc_multiple) {
+				SMT_PANIC(smc,SMT_E0129, SMT_E0129_MSG) ;
+			}
+			evc->evc_cond_state = &fail_safe ;
+		}
+	}
+#endif
+	smc->srf.TSR = smt_get_time() ;
+	smc->srf.sr_state = SR0_WAIT ;
+}
+
+static struct s_srf_evc *smt_get_evc(struct s_smc *smc, int code, int index)
+{
+	int			i ;
+	struct s_srf_evc	*evc ;
+
+	for (i = 0, evc = smc->evcs ; (unsigned) i < MAX_EVCS ; i++, evc++) {
+		if (evc->evc_code == code && evc->evc_index == index)
+			return evc;
+	}
+	return NULL;
+}
+
+#define THRESHOLD_2	(2*TICKS_PER_SECOND)
+#define THRESHOLD_32	(32*TICKS_PER_SECOND)
+
+#ifdef	DEBUG
+static const char * const srf_names[] = {
+	"None","MACPathChangeEvent",	"MACNeighborChangeEvent",
+	"PORTPathChangeEvent",		"PORTUndesiredConnectionAttemptEvent",
+	"SMTPeerWrapCondition",		"SMTHoldCondition",
+	"MACFrameErrorCondition",	"MACDuplicateAddressCondition",
+	"MACNotCopiedCondition",	"PORTEBErrorCondition",
+	"PORTLerCondition"
+} ;
+#endif
+
+void smt_srf_event(struct s_smc *smc, int code, int index, int cond)
+{
+	struct s_srf_evc	*evc ;
+	int			cond_asserted = 0 ;
+	int			cond_deasserted = 0 ;
+	int			event_occurred = 0 ;
+	int			tsr ;
+	int			T_Limit = 2*TICKS_PER_SECOND ;
+
+	if (code == SMT_COND_MAC_DUP_ADDR && cond) {
+		RS_SET(smc,RS_DUPADDR) ;
+	}
+
+	if (code) {
+		DB_SMT("SRF: %s index %d\n",srf_names[code],index) ;
+
+		if (!(evc = smt_get_evc(smc,code,index))) {
+			DB_SMT("SRF : smt_get_evc() failed\n",0,0) ;
+			return ;
+		}
+		/*
+		 * ignore condition if no change
+		 */
+		if (SMT_IS_CONDITION(code)) {
+			if (*evc->evc_cond_state == cond)
+				return ;
+		}
+
+		/*
+		 * set transition time stamp
+		 */
+		smt_set_timestamp(smc,smc->mib.fddiSMTTransitionTimeStamp) ;
+		if (SMT_IS_CONDITION(code)) {
+			DB_SMT("SRF: condition is %s\n",cond ? "ON":"OFF",0) ;
+			if (cond) {
+				*evc->evc_cond_state = TRUE ;
+				evc->evc_rep_required = TRUE ;
+				smc->srf.any_report = TRUE ;
+				cond_asserted = TRUE ;
+			}
+			else {
+				*evc->evc_cond_state = FALSE ;
+				cond_deasserted = TRUE ;
+			}
+		}
+		else {
+			if (evc->evc_rep_required) {
+				*evc->evc_multiple  = TRUE ;
+			}
+			else {
+				evc->evc_rep_required = TRUE ;
+				*evc->evc_multiple  = FALSE ;
+			}
+			smc->srf.any_report = TRUE ;
+			event_occurred = TRUE ;
+		}
+#ifdef	FDDI_MIB
+		snmp_srf_event(smc,evc) ;
+#endif	/* FDDI_MIB */
+	}
+	tsr = smt_get_time() - smc->srf.TSR ;
+
+	switch (smc->srf.sr_state) {
+	case SR0_WAIT :
+		/* SR01a */
+		if (cond_asserted && tsr < T_Limit) {
+			smc->srf.SRThreshold = THRESHOLD_2 ;
+			smc->srf.sr_state = SR1_HOLDOFF ;
+			break ;
+		}
+		/* SR01b */
+		if (cond_deasserted && tsr < T_Limit) {
+			smc->srf.sr_state = SR1_HOLDOFF ;
+			break ;
+		}
+		/* SR01c */
+		if (event_occurred && tsr < T_Limit) {
+			smc->srf.sr_state = SR1_HOLDOFF ;
+			break ;
+		}
+		/* SR00b */
+		if (cond_asserted && tsr >= T_Limit) {
+			smc->srf.SRThreshold = THRESHOLD_2 ;
+			smc->srf.TSR = smt_get_time() ;
+			smt_send_srf(smc) ;
+			break ;
+		}
+		/* SR00c */
+		if (cond_deasserted && tsr >= T_Limit) {
+			smc->srf.TSR = smt_get_time() ;
+			smt_send_srf(smc) ;
+			break ;
+		}
+		/* SR00d */
+		if (event_occurred && tsr >= T_Limit) {
+			smc->srf.TSR = smt_get_time() ;
+			smt_send_srf(smc) ;
+			break ;
+		}
+		/* SR00e */
+		if (smc->srf.any_report && (u_long) tsr >=
+			smc->srf.SRThreshold) {
+			smc->srf.SRThreshold *= 2 ;
+			if (smc->srf.SRThreshold > THRESHOLD_32)
+				smc->srf.SRThreshold = THRESHOLD_32 ;
+			smc->srf.TSR = smt_get_time() ;
+			smt_send_srf(smc) ;
+			break ;
+		}
+		/* SR02 */
+		if (!smc->mib.fddiSMTStatRptPolicy) {
+			smc->srf.sr_state = SR2_DISABLED ;
+			break ;
+		}
+		break ;
+	case SR1_HOLDOFF :
+		/* SR10b */
+		if (tsr >= T_Limit) {
+			smc->srf.sr_state = SR0_WAIT ;
+			smc->srf.TSR = smt_get_time() ;
+			smt_send_srf(smc) ;
+			break ;
+		}
+		/* SR11a */
+		if (cond_asserted) {
+			smc->srf.SRThreshold = THRESHOLD_2 ;
+		}
+		/* SR11b */
+		/* SR11c */
+		/* handled above */
+		/* SR12 */
+		if (!smc->mib.fddiSMTStatRptPolicy) {
+			smc->srf.sr_state = SR2_DISABLED ;
+			break ;
+		}
+		break ;
+	case SR2_DISABLED :
+		if (smc->mib.fddiSMTStatRptPolicy) {
+			smc->srf.sr_state = SR0_WAIT ;
+			smc->srf.TSR = smt_get_time() ;
+			smc->srf.SRThreshold = THRESHOLD_2 ;
+			clear_all_rep(smc) ;
+			break ;
+		}
+		break ;
+	}
+}
+
+static void clear_all_rep(struct s_smc *smc)
+{
+	struct s_srf_evc	*evc ;
+	int			i ;
+
+	for (i = 0, evc = smc->evcs ; (unsigned) i < MAX_EVCS ; i++, evc++) {
+		evc->evc_rep_required = FALSE ;
+		if (SMT_IS_CONDITION(evc->evc_code))
+			*evc->evc_cond_state = FALSE ;
+	}
+	smc->srf.any_report = FALSE ;
+}
+
+static void clear_reported(struct s_smc *smc)
+{
+	struct s_srf_evc	*evc ;
+	int			i ;
+
+	smc->srf.any_report = FALSE ;
+	for (i = 0, evc = smc->evcs ; (unsigned) i < MAX_EVCS ; i++, evc++) {
+		if (SMT_IS_CONDITION(evc->evc_code)) {
+			if (*evc->evc_cond_state == FALSE)
+				evc->evc_rep_required = FALSE ;
+			else
+				smc->srf.any_report = TRUE ;
+		}
+		else {
+			evc->evc_rep_required = FALSE ;
+			*evc->evc_multiple = FALSE ;
+		}
+	}
+}
+
+/*
+ * build and send SMT SRF frame
+ */
+static void smt_send_srf(struct s_smc *smc)
+{
+
+	struct smt_header	*smt ;
+	struct s_srf_evc	*evc ;
+	SK_LOC_DECL(struct s_pcon,pcon) ;
+	SMbuf			*mb ;
+	int			i ;
+
+	static const struct fddi_addr SMT_SRF_DA = {
+		{ 0x80, 0x01, 0x43, 0x00, 0x80, 0x08 }
+	} ;
+
+	/*
+	 * build SMT header
+	 */
+	if (!smc->r.sm_ma_avail)
+		return ;
+	if (!(mb = smt_build_frame(smc,SMT_SRF,SMT_ANNOUNCE,0)))
+		return ;
+
+	RS_SET(smc,RS_SOFTERROR) ;
+
+	smt = smtod(mb, struct smt_header *) ;
+	smt->smt_dest = SMT_SRF_DA ;		/* DA == SRF multicast */
+
+	/*
+	 * setup parameter status
+	 */
+	pcon.pc_len = SMT_MAX_INFO_LEN ;	/* max para length */
+	pcon.pc_err = 0 ;			/* no error */
+	pcon.pc_badset = 0 ;			/* no bad set count */
+	pcon.pc_p = (void *) (smt + 1) ;	/* paras start here */
+
+	smt_add_para(smc,&pcon,(u_short) SMT_P1033,0,0) ;
+	smt_add_para(smc,&pcon,(u_short) SMT_P1034,0,0) ;
+
+	for (i = 0, evc = smc->evcs ; (unsigned) i < MAX_EVCS ; i++, evc++) {
+		if (evc->evc_rep_required) {
+			smt_add_para(smc,&pcon,evc->evc_para,
+				(int)evc->evc_index,0) ;
+		}
+	}
+	smt->smt_len = SMT_MAX_INFO_LEN - pcon.pc_len ;
+	mb->sm_len = smt->smt_len + sizeof(struct smt_header) ;
+
+	DB_SMT("SRF: sending SRF at %x, len %d\n",smt,mb->sm_len) ;
+	DB_SMT("SRF: state SR%d Threshold %d\n",
+		smc->srf.sr_state,smc->srf.SRThreshold/TICKS_PER_SECOND) ;
+#ifdef	DEBUG
+	dump_smt(smc,smt,"SRF Send") ;
+#endif
+	smt_send_frame(smc,mb,FC_SMT_INFO,0) ;
+	clear_reported(smc) ;
+}
+
+#endif	/* no BOOT */
+#endif	/* no SLIM_SMT */
+
