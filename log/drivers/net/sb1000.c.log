commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
index 627b3a4405ad..e88af978f63c 100644
--- a/drivers/net/sb1000.c
+++ b/drivers/net/sb1000.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /* sb1000.c: A General Instruments SB1000 driver for linux. */
 /*
 	Written 1998 by Franco Venturi.
@@ -11,11 +12,6 @@
 
 	The author may be reached as fventuri@mediaone.net
 
-	This program is free software; you can redistribute it
-	and/or  modify it under  the terms of  the GNU General
-	Public  License as  published  by  the  Free  Software
-	Foundation;  either  version 2 of the License, or  (at
-	your option) any later version.
 
 	Changes:
 

commit ce6bf4c141cab2919b0f1b914c93676e37a70ec1
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Wed Apr 17 13:51:56 2019 -0700

    sb1000: fix variable set but not used warnings
    
    GCC 8 complains:
    
    drivers/net/sb1000.c: In function ‘card_send_command’:
    drivers/net/sb1000.c:319:14: warning: variable ‘x’ set but not used [-Wunused-but-set-variable]
      int status, x;
                  ^
    drivers/net/sb1000.c: In function ‘sb1000_check_CRC’:
    drivers/net/sb1000.c:493:6: warning: variable ‘crc’ set but not used [-Wunused-but-set-variable]
      int crc, status;
          ^~~
    
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Reviewed-by: Dirk van der Merwe <dirk.vandermerwe@netronome.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
index 941cfa8f1c2a..627b3a4405ad 100644
--- a/drivers/net/sb1000.c
+++ b/drivers/net/sb1000.c
@@ -316,7 +316,7 @@ static int
 card_send_command(const int ioaddr[], const char* name,
 	const unsigned char out[], unsigned char in[])
 {
-	int status, x;
+	int status;
 
 	if ((status = card_wait_for_busy_clear(ioaddr, name)))
 		return status;
@@ -345,9 +345,7 @@ card_send_command(const int ioaddr[], const char* name,
 				out[0], out[1], out[2], out[3], out[4], out[5]);
 	}
 
-	if (out[1] == 0x1b) {
-		x = (out[2] == 0x02);
-	} else {
+	if (out[1] != 0x1b) {
 		if (out[0] >= 0x80 && in[0] != (out[1] | 0x80))
 			return -EIO;
 	}
@@ -490,14 +488,13 @@ sb1000_check_CRC(const int ioaddr[], const char* name)
 	static const unsigned char Command0[6] = {0x80, 0x1f, 0x00, 0x00, 0x00, 0x00};
 
 	unsigned char st[7];
-	int crc, status;
+	int status;
 
 	/* check CRC */
 	if ((status = card_send_command(ioaddr, name, Command0, st)))
 		return status;
 	if (st[1] != st[3] || st[2] != st[4])
 		return -EIO;
-	crc = st[1] << 8 | st[2];
 	return 0;
 }
 

commit 6394d98df6b47a4fe28715536bd6c8e003847071
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Jan 17 00:35:43 2019 +0000

    sb1000: fix a couple of indentation issues and remove assignment in if statements
    
    There is an if statement and a return statement that are incorrectly
    indented. Fix these.  Also replace the assignment-in-if statements
    to assignment followed by an if to keep to the coding style.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
index 7820fced33f6..941cfa8f1c2a 100644
--- a/drivers/net/sb1000.c
+++ b/drivers/net/sb1000.c
@@ -535,17 +535,20 @@ sb1000_activate(const int ioaddr[], const char* name)
 	int status;
 
 	ssleep(1);
-	if ((status = card_send_command(ioaddr, name, Command0, st)))
+	status = card_send_command(ioaddr, name, Command0, st);
+	if (status)
 		return status;
-	if ((status = card_send_command(ioaddr, name, Command1, st)))
+	status = card_send_command(ioaddr, name, Command1, st);
+	if (status)
 		return status;
 	if (st[3] != 0xf1) {
-    	if ((status = sb1000_start_get_set_command(ioaddr, name)))
+		status = sb1000_start_get_set_command(ioaddr, name);
+		if (status)
 			return status;
 		return -EIO;
 	}
 	udelay(1000);
-    return sb1000_start_get_set_command(ioaddr, name);
+	return sb1000_start_get_set_command(ioaddr, name);
 }
 
 /* get SB1000 firmware version */

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
index 8b8b53259783..7820fced33f6 100644
--- a/drivers/net/sb1000.c
+++ b/drivers/net/sb1000.c
@@ -55,7 +55,7 @@ static char version[] = "sb1000.c:v1.1.2 6/01/98 (fventuri@mediaone.net)\n";
 
 #include <asm/io.h>
 #include <asm/processor.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 
 #ifdef SB1000_DEBUG
 static int sb1000_debug = SB1000_DEBUG;

commit a52ad514fdf3b8a57ca4322c92d2d8d5c6182485
Author: Jarod Wilson <jarod@redhat.com>
Date:   Fri Oct 7 22:04:34 2016 -0400

    net: deprecate eth_change_mtu, remove usage
    
    With centralized MTU checking, there's nothing productive done by
    eth_change_mtu that isn't already done in dev_set_mtu, so mark it as
    deprecated and remove all usage of it in the kernel. All callers have been
    audited for calls to alloc_etherdev* or ether_setup directly, which means
    they all have a valid dev->min_mtu and dev->max_mtu. Now eth_change_mtu
    prints out a netdev_warn about being deprecated, for the benefit of
    out-of-tree drivers that might be utilizing it.
    
    Of note, dvb_net.c actually had dev->mtu = 4096, while using
    eth_change_mtu, meaning that if you ever tried changing it's mtu, you
    couldn't set it above 1500 anymore. It's now getting dev->max_mtu also set
    to 4096 to remedy that.
    
    v2: fix up lantiq_etop, missed breakage due to drive not compiling on x86
    
    CC: netdev@vger.kernel.org
    Signed-off-by: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
index aad0b59d41e3..8b8b53259783 100644
--- a/drivers/net/sb1000.c
+++ b/drivers/net/sb1000.c
@@ -141,7 +141,6 @@ static const struct net_device_ops sb1000_netdev_ops = {
 	.ndo_start_xmit		= sb1000_start_xmit,
 	.ndo_do_ioctl		= sb1000_dev_ioctl,
 	.ndo_stop		= sb1000_close,
-	.ndo_change_mtu		= eth_change_mtu,
 	.ndo_set_mac_address 	= eth_mac_addr,
 	.ndo_validate_addr	= eth_validate_addr,
 };

commit ed03538aa8d5f03432ddd5ed73fc0ba2725af93d
Author: Peter Huewe <PeterHuewe@gmx.de>
Date:   Mon Mar 16 21:46:35 2015 +0100

    PNP: net/sb1000: Use module_pnp_driver to register driver
    
    Removing some boilerplate by using module_pnp_driver instead of calling
    register and unregister in the otherwise empty init/exit functions
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
index 66c2f1a01963..aad0b59d41e3 100644
--- a/drivers/net/sb1000.c
+++ b/drivers/net/sb1000.c
@@ -1175,17 +1175,4 @@ MODULE_AUTHOR("Franco Venturi <fventuri@mediaone.net>");
 MODULE_DESCRIPTION("General Instruments SB1000 driver");
 MODULE_LICENSE("GPL");
 
-static int __init
-sb1000_init(void)
-{
-	return pnp_register_driver(&sb1000_driver);
-}
-
-static void __exit
-sb1000_exit(void)
-{
-	pnp_unregister_driver(&sb1000_driver);
-}
-
-module_init(sb1000_init);
-module_exit(sb1000_exit);
+module_pnp_driver(sb1000_driver);

commit d58c0e95622c0de271ae57c083ad25ff4eb032c8
Author: Julia Lawall <julia@diku.dk>
Date:   Tue Oct 26 00:25:34 2010 +0000

    drivers/net/sb1000.c: delete double assignment
    
    The other code around these duplicated assignments initializes the 0 1 2
    and 3 elements of an array, so change the initialization of the
    rx_session_id array to do the same.
    
    A simplified version of the semantic match that finds this problem is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@
    expression i;
    @@
    
    *i = ...;
     i = ...;
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
index a9ae505e1baf..66c2f1a01963 100644
--- a/drivers/net/sb1000.c
+++ b/drivers/net/sb1000.c
@@ -961,9 +961,9 @@ sb1000_open(struct net_device *dev)
 	lp->rx_error_count = 0;
 	lp->rx_error_dpc_count = 0;
 	lp->rx_session_id[0] = 0x50;
-	lp->rx_session_id[0] = 0x48;
-	lp->rx_session_id[0] = 0x44;
-	lp->rx_session_id[0] = 0x42;
+	lp->rx_session_id[1] = 0x48;
+	lp->rx_session_id[2] = 0x44;
+	lp->rx_session_id[3] = 0x42;
 	lp->rx_frame_id[0] = 0;
 	lp->rx_frame_id[1] = 0;
 	lp->rx_frame_id[2] = 0;

commit a4b770972b8f819e408d7cc3ae9637e15bff62f6
Author: Joe Perches <joe@perches.com>
Date:   Fri May 14 00:19:28 2010 -0700

    drivers/net: Remove unnecessary returns from void function()s
    
    This patch removes from drivers/net/ all the unnecessary
    return; statements that precede the last closing brace of
    void functions.
    
    It does not remove the returns that are immediately
    preceded by a label as gcc doesn't like that.
    
    It also does not remove null void functions with return.
    
    Done via:
    $ grep -rP --include=*.[ch] -l "return;\n}" net/ | \
      xargs perl -i -e 'local $/ ; while (<>) { s/\n[ \t\n]+return;\n}/\n}/g; print; }'
    
    with some cleanups by hand.
    
    Compile tested x86 allmodconfig only.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
index abc8eefdd4b6..a9ae505e1baf 100644
--- a/drivers/net/sb1000.c
+++ b/drivers/net/sb1000.c
@@ -426,7 +426,6 @@ sb1000_send_command(const int ioaddr[], const char* name,
 	if (sb1000_debug > 3)
 		printk(KERN_DEBUG "%s: sb1000_send_command out: %02x%02x%02x%02x"
 			"%02x%02x\n", name, out[0], out[1], out[2], out[3], out[4], out[5]);
-	return;
 }
 
 /* Card Read Status (to be used during frame rx) */
@@ -438,7 +437,6 @@ sb1000_read_status(const int ioaddr[], unsigned char in[])
 	in[3] = inb(ioaddr[0] + 3);
 	in[4] = inb(ioaddr[0] + 4);
 	in[0] = inb(ioaddr[0] + 5);
-	return;
 }
 
 /* Issue Read Command (to be used during frame rx) */
@@ -450,7 +448,6 @@ sb1000_issue_read_command(const int ioaddr[], const char* name)
 	sb1000_wait_for_ready_clear(ioaddr, name);
 	outb(0xa0, ioaddr[0] + 6);
 	sb1000_send_command(ioaddr, name, Command0);
-	return;
 }
 
 
@@ -733,7 +730,6 @@ sb1000_print_status_buffer(const char* name, unsigned char st[],
 			printk("\n");
 		}
 	}
-	return;
 }
 
 /*
@@ -926,7 +922,6 @@ sb1000_error_dpc(struct net_device *dev)
 	sb1000_read_status(ioaddr, st);
 	if (st[1] & 0x10)
 		lp->rx_error_dpc_count = ErrorDpcCounterInitialize;
-	return;
 }
 
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
index 9f83a1197375..abc8eefdd4b6 100644
--- a/drivers/net/sb1000.c
+++ b/drivers/net/sb1000.c
@@ -42,7 +42,6 @@ static char version[] = "sb1000.c:v1.1.2 6/01/98 (fventuri@mediaone.net)\n";
 #include <linux/errno.h>
 #include <linux/if_cablemodem.h> /* for SIOGCM/SIOSCM stuff */
 #include <linux/in.h>
-#include <linux/slab.h>
 #include <linux/ioport.h>
 #include <linux/netdevice.h>
 #include <linux/if_arp.h>
@@ -52,6 +51,7 @@ static char version[] = "sb1000.c:v1.1.2 6/01/98 (fventuri@mediaone.net)\n";
 #include <linux/pnp.h>
 #include <linux/init.h>
 #include <linux/bitops.h>
+#include <linux/gfp.h>
 
 #include <asm/io.h>
 #include <asm/processor.h>

commit a0607fd3a25ba1848a63a0d925e36d914735ab47
Author: Joe Perches <joe@perches.com>
Date:   Wed Nov 18 23:29:17 2009 -0800

    drivers/net: request_irq - Remove unnecessary leading & from second arg
    
    Not as fancy as coccinelle.  Checkpatch errors ignored.
    Compile tested allyesconfig x86, not all files compiled.
    
    grep -rPl --include=*.[ch] "\brequest_irq\s*\([^,\)]+,\s*\&" drivers/net | while read file ; do \
            perl -i -e 'local $/; while (<>) { s@(\brequest_irq\s*\([^,\)]+,\s*)\&@\1@g ; print ; }' $file ;\
    done
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
index c9c70ab0cce0..9f83a1197375 100644
--- a/drivers/net/sb1000.c
+++ b/drivers/net/sb1000.c
@@ -973,7 +973,7 @@ sb1000_open(struct net_device *dev)
 	lp->rx_frame_id[1] = 0;
 	lp->rx_frame_id[2] = 0;
 	lp->rx_frame_id[3] = 0;
-	if (request_irq(dev->irq, &sb1000_interrupt, 0, "sb1000", dev)) {
+	if (request_irq(dev->irq, sb1000_interrupt, 0, "sb1000", dev)) {
 		return -EAGAIN;
 	}
 

commit d43c36dc6b357fa1806800f18aa30123c747a6d1
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Oct 7 17:09:06 2009 +0400

    headers: remove sched.h from interrupt.h
    
    After m68k's task_thread_info() doesn't refer to current,
    it's possible to remove sched.h from interrupt.h and not break m68k!
    Many thanks to Heiko Carstens for allowing this.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>

diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
index ee366c5a8fa3..c9c70ab0cce0 100644
--- a/drivers/net/sb1000.c
+++ b/drivers/net/sb1000.c
@@ -36,6 +36,7 @@ static char version[] = "sb1000.c:v1.1.2 6/01/98 (fventuri@mediaone.net)\n";
 
 #include <linux/module.h>
 #include <linux/kernel.h>
+#include <linux/sched.h>
 #include <linux/string.h>
 #include <linux/interrupt.h>
 #include <linux/errno.h>

commit 61357325f377889a1daffa14962d705dc814dd0e
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Mon Aug 31 19:50:58 2009 +0000

    netdev: convert bulk of drivers to netdev_tx_t
    
    In a couple of cases collapse some extra code like:
       int retval = NETDEV_TX_OK;
       ...
       return retval;
    into
       return NETDEV_TX_OK;
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
index 6a81aec645d9..ee366c5a8fa3 100644
--- a/drivers/net/sb1000.c
+++ b/drivers/net/sb1000.c
@@ -82,7 +82,8 @@ struct sb1000_private {
 extern int sb1000_probe(struct net_device *dev);
 static int sb1000_open(struct net_device *dev);
 static int sb1000_dev_ioctl (struct net_device *dev, struct ifreq *ifr, int cmd);
-static int sb1000_start_xmit(struct sk_buff *skb, struct net_device *dev);
+static netdev_tx_t sb1000_start_xmit(struct sk_buff *skb,
+				     struct net_device *dev);
 static irqreturn_t sb1000_interrupt(int irq, void *dev_id);
 static int sb1000_close(struct net_device *dev);
 
@@ -1080,7 +1081,7 @@ static int sb1000_dev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 }
 
 /* transmit function: do nothing since SB1000 can't send anything out */
-static int
+static netdev_tx_t
 sb1000_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	printk(KERN_WARNING "%s: trying to transmit!!!\n", dev->name);

commit 6ed106549d17474ca17a16057f4c0ed4eba5a7ca
Author: Patrick McHardy <kaber@trash.net>
Date:   Tue Jun 23 06:03:08 2009 +0000

    net: use NETDEV_TX_OK instead of 0 in ndo_start_xmit() functions
    
    This patch is the result of an automatic spatch transformation to convert
    all ndo_start_xmit() return values of 0 to NETDEV_TX_OK.
    
    Some occurences are missed by the automatic conversion, those will be
    handled in a seperate patch.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
index fc0e38bddeeb..6a81aec645d9 100644
--- a/drivers/net/sb1000.c
+++ b/drivers/net/sb1000.c
@@ -1086,7 +1086,7 @@ sb1000_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	printk(KERN_WARNING "%s: trying to transmit!!!\n", dev->name);
 	/* sb1000 can't xmit datagrams */
 	dev_kfree_skb(skb);
-	return 0;
+	return NETDEV_TX_OK;
 }
 
 /* SB1000 interrupt handler. */

commit d49d19c962c5f409a7dc771f185afd22cdb49edf
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Wed Jan 7 17:56:54 2009 -0800

    sb1000: update to net_device_ops
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
index be3025310e90..fc0e38bddeeb 100644
--- a/drivers/net/sb1000.c
+++ b/drivers/net/sb1000.c
@@ -134,6 +134,16 @@ static const struct pnp_device_id sb1000_pnp_ids[] = {
 };
 MODULE_DEVICE_TABLE(pnp, sb1000_pnp_ids);
 
+static const struct net_device_ops sb1000_netdev_ops = {
+	.ndo_open		= sb1000_open,
+	.ndo_start_xmit		= sb1000_start_xmit,
+	.ndo_do_ioctl		= sb1000_dev_ioctl,
+	.ndo_stop		= sb1000_close,
+	.ndo_change_mtu		= eth_change_mtu,
+	.ndo_set_mac_address 	= eth_mac_addr,
+	.ndo_validate_addr	= eth_validate_addr,
+};
+
 static int
 sb1000_probe_one(struct pnp_dev *pdev, const struct pnp_device_id *id)
 {
@@ -192,11 +202,7 @@ sb1000_probe_one(struct pnp_dev *pdev, const struct pnp_device_id *id)
 	if (sb1000_debug > 0)
 		printk(KERN_NOTICE "%s", version);
 
-	/* The SB1000-specific entries in the device structure. */
-	dev->open		= sb1000_open;
-	dev->do_ioctl		= sb1000_dev_ioctl;
-	dev->hard_start_xmit	= sb1000_start_xmit;
-	dev->stop		= sb1000_close;
+	dev->netdev_ops	= &sb1000_netdev_ops;
 
 	/* hardware address is 0:0:serial_number */
 	dev->dev_addr[2]	= serial_number >> 24 & 0xff;

commit babcda74e9d96bb58fd9c6c5112dbdbff169e695
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Nov 3 21:11:17 2008 -0800

    drivers/net: Kill now superfluous ->last_rx stores.
    
    The generic packet receive code takes care of setting
    netdev->last_rx when necessary, for the sake of the
    bonding ARP monitor.
    
    Drivers need not do it any more.
    
    Some cases had to be skipped over because the drivers
    were making use of the ->last_rx value themselves.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
index 5986cec17f19..be3025310e90 100644
--- a/drivers/net/sb1000.c
+++ b/drivers/net/sb1000.c
@@ -869,7 +869,6 @@ printk("cm0: IP identification: %02x%02x  fragment offset: %02x%02x\n", buffer[3
 	/* datagram completed: send to upper level */
 	skb_trim(skb, dlen);
 	netif_rx(skb);
-	dev->last_rx = jiffies;
 	stats->rx_bytes+=dlen;
 	stats->rx_packets++;
 	lp->rx_skb[ns] = NULL;

commit 7dd73bbcc99b755436d8dc4b412d23e92a685f4d
Author: Denys Vlasenko <vda.linux@googlemail.com>
Date:   Mon Mar 31 01:13:00 2008 +0200

    sb1000.c: make const arrays static
    
    This patch replaces automatic constant arrays a-la
    
        const unsigned char Command0[6] = {0x80, 0x16, 0x00, 0x00, 0x00, 0x00};
    
    with static ones. Size difference for 32bit x86:
    
    text  data   bss     dec     hex filename
    5418   129     0    5547    15ab linux-2.6.inline-ALLYES/drivers/net/sb1000.o
    5396   129     0    5525    1595 linux-2.6.followup-ALLYES/drivers/net/sb1000.o
    
    Signed-off-by: Denys Vlasenko <vda.linux@googlemail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
index 829d0ea2709d..5986cec17f19 100644
--- a/drivers/net/sb1000.c
+++ b/drivers/net/sb1000.c
@@ -437,7 +437,7 @@ sb1000_read_status(const int ioaddr[], unsigned char in[])
 static void
 sb1000_issue_read_command(const int ioaddr[], const char* name)
 {
-	const unsigned char Command0[6] = {0x20, 0x00, 0x00, 0x01, 0x00, 0x00};
+	static const unsigned char Command0[6] = {0x20, 0x00, 0x00, 0x01, 0x00, 0x00};
 
 	sb1000_wait_for_ready_clear(ioaddr, name);
 	outb(0xa0, ioaddr[0] + 6);
@@ -453,9 +453,10 @@ sb1000_issue_read_command(const int ioaddr[], const char* name)
 static int
 sb1000_reset(const int ioaddr[], const char* name)
 {
+	static const unsigned char Command0[6] = {0x80, 0x16, 0x00, 0x00, 0x00, 0x00};
+
 	unsigned char st[7];
 	int port, status;
-	const unsigned char Command0[6] = {0x80, 0x16, 0x00, 0x00, 0x00, 0x00};
 
 	port = ioaddr[1] + 6;
 	outb(0x4, port);
@@ -482,9 +483,10 @@ sb1000_reset(const int ioaddr[], const char* name)
 static int
 sb1000_check_CRC(const int ioaddr[], const char* name)
 {
+	static const unsigned char Command0[6] = {0x80, 0x1f, 0x00, 0x00, 0x00, 0x00};
+
 	unsigned char st[7];
 	int crc, status;
-	const unsigned char Command0[6] = {0x80, 0x1f, 0x00, 0x00, 0x00, 0x00};
 
 	/* check CRC */
 	if ((status = card_send_command(ioaddr, name, Command0, st)))
@@ -498,8 +500,9 @@ sb1000_check_CRC(const int ioaddr[], const char* name)
 static inline int
 sb1000_start_get_set_command(const int ioaddr[], const char* name)
 {
+	static const unsigned char Command0[6] = {0x80, 0x1b, 0x00, 0x00, 0x00, 0x00};
+
 	unsigned char st[7];
-	const unsigned char Command0[6] = {0x80, 0x1b, 0x00, 0x00, 0x00, 0x00};
 
 	return card_send_command(ioaddr, name, Command0, st);
 }
@@ -507,10 +510,11 @@ sb1000_start_get_set_command(const int ioaddr[], const char* name)
 static int
 sb1000_end_get_set_command(const int ioaddr[], const char* name)
 {
+	static const unsigned char Command0[6] = {0x80, 0x1b, 0x02, 0x00, 0x00, 0x00};
+	static const unsigned char Command1[6] = {0x20, 0x00, 0x00, 0x00, 0x00, 0x00};
+
 	unsigned char st[7];
 	int status;
-	const unsigned char Command0[6] = {0x80, 0x1b, 0x02, 0x00, 0x00, 0x00};
-	const unsigned char Command1[6] = {0x20, 0x00, 0x00, 0x00, 0x00, 0x00};
 
 	if ((status = card_send_command(ioaddr, name, Command0, st)))
 		return status;
@@ -520,10 +524,11 @@ sb1000_end_get_set_command(const int ioaddr[], const char* name)
 static int
 sb1000_activate(const int ioaddr[], const char* name)
 {
+	static const unsigned char Command0[6] = {0x80, 0x11, 0x00, 0x00, 0x00, 0x00};
+	static const unsigned char Command1[6] = {0x80, 0x16, 0x00, 0x00, 0x00, 0x00};
+
 	unsigned char st[7];
 	int status;
-	const unsigned char Command0[6] = {0x80, 0x11, 0x00, 0x00, 0x00, 0x00};
-	const unsigned char Command1[6] = {0x80, 0x16, 0x00, 0x00, 0x00, 0x00};
 
 	ssleep(1);
 	if ((status = card_send_command(ioaddr, name, Command0, st)))
@@ -544,9 +549,10 @@ static int
 sb1000_get_firmware_version(const int ioaddr[], const char* name,
 	unsigned char version[], int do_end)
 {
+	static const unsigned char Command0[6] = {0x80, 0x23, 0x00, 0x00, 0x00, 0x00};
+
 	unsigned char st[7];
 	int status;
-	const unsigned char Command0[6] = {0x80, 0x23, 0x00, 0x00, 0x00, 0x00};
 
 	if ((status = sb1000_start_get_set_command(ioaddr, name)))
 		return status;
@@ -566,9 +572,10 @@ sb1000_get_firmware_version(const int ioaddr[], const char* name,
 static int
 sb1000_get_frequency(const int ioaddr[], const char* name, int* frequency)
 {
+	static const unsigned char Command0[6] = {0x80, 0x44, 0x00, 0x00, 0x00, 0x00};
+
 	unsigned char st[7];
 	int status;
-	const unsigned char Command0[6] = {0x80, 0x44, 0x00, 0x00, 0x00, 0x00};
 
 	udelay(1000);
 	if ((status = sb1000_start_get_set_command(ioaddr, name)))
@@ -613,12 +620,13 @@ sb1000_set_frequency(const int ioaddr[], const char* name, int frequency)
 static int
 sb1000_get_PIDs(const int ioaddr[], const char* name, short PID[])
 {
+	static const unsigned char Command0[6] = {0x80, 0x40, 0x00, 0x00, 0x00, 0x00};
+	static const unsigned char Command1[6] = {0x80, 0x41, 0x00, 0x00, 0x00, 0x00};
+	static const unsigned char Command2[6] = {0x80, 0x42, 0x00, 0x00, 0x00, 0x00};
+	static const unsigned char Command3[6] = {0x80, 0x43, 0x00, 0x00, 0x00, 0x00};
+
 	unsigned char st[7];
 	int status;
-	const unsigned char Command0[6] = {0x80, 0x40, 0x00, 0x00, 0x00, 0x00};
-	const unsigned char Command1[6] = {0x80, 0x41, 0x00, 0x00, 0x00, 0x00};
-	const unsigned char Command2[6] = {0x80, 0x42, 0x00, 0x00, 0x00, 0x00};
-	const unsigned char Command3[6] = {0x80, 0x43, 0x00, 0x00, 0x00, 0x00};
 
 	udelay(1000);
 	if ((status = sb1000_start_get_set_command(ioaddr, name)))
@@ -647,6 +655,8 @@ sb1000_get_PIDs(const int ioaddr[], const char* name, short PID[])
 static int
 sb1000_set_PIDs(const int ioaddr[], const char* name, const short PID[])
 {
+	static const unsigned char Command4[6] = {0x80, 0x2e, 0x00, 0x00, 0x00, 0x00};
+
 	unsigned char st[7];
 	short p;
 	int status;
@@ -654,7 +664,6 @@ sb1000_set_PIDs(const int ioaddr[], const char* name, const short PID[])
 	unsigned char Command1[6] = {0x80, 0x32, 0x00, 0x00, 0x00, 0x00};
 	unsigned char Command2[6] = {0x80, 0x33, 0x00, 0x00, 0x00, 0x00};
 	unsigned char Command3[6] = {0x80, 0x34, 0x00, 0x00, 0x00, 0x00};
-	const unsigned char Command4[6] = {0x80, 0x2e, 0x00, 0x00, 0x00, 0x00};
 
 	udelay(1000);
 	if ((status = sb1000_start_get_set_command(ioaddr, name)))
@@ -891,11 +900,12 @@ printk("cm0: IP identification: %02x%02x  fragment offset: %02x%02x\n", buffer[3
 static void
 sb1000_error_dpc(struct net_device *dev)
 {
+	static const unsigned char Command0[6] = {0x80, 0x26, 0x00, 0x00, 0x00, 0x00};
+
 	char *name;
 	unsigned char st[5];
 	int ioaddr[2];
 	struct sb1000_private *lp = netdev_priv(dev);
-	const unsigned char Command0[6] = {0x80, 0x26, 0x00, 0x00, 0x00, 0x00};
 	const int ErrorDpcCounterInitialize = 200;
 
 	ioaddr[0] = dev->base_addr;
@@ -1077,14 +1087,15 @@ sb1000_start_xmit(struct sk_buff *skb, struct net_device *dev)
 /* SB1000 interrupt handler. */
 static irqreturn_t sb1000_interrupt(int irq, void *dev_id)
 {
+	static const unsigned char Command0[6] = {0x80, 0x2c, 0x00, 0x00, 0x00, 0x00};
+	static const unsigned char Command1[6] = {0x80, 0x2e, 0x00, 0x00, 0x00, 0x00};
+
 	char *name;
 	unsigned char st;
 	int ioaddr[2];
 	struct net_device *dev = dev_id;
 	struct sb1000_private *lp = netdev_priv(dev);
 
-	const unsigned char Command0[6] = {0x80, 0x2c, 0x00, 0x00, 0x00, 0x00};
-	const unsigned char Command1[6] = {0x80, 0x2e, 0x00, 0x00, 0x00, 0x00};
 	const int MaxRxErrorCount = 6;
 
 	ioaddr[0] = dev->base_addr;

commit a8d06342baab56901bfd70c4f66be382d4b9967d
Author: Denys Vlasenko <vda.linux@googlemail.com>
Date:   Mon Mar 31 01:02:43 2008 +0200

    sb1000.c: stop inlining largish static functions
    
    drivers/net/sb1000.c has lots of inlined static functions.
    
    Mst of them are used at initialization, wait for some
    hardware register to change (wait using yield, sleep etc),
    or do slow port-based I/O. Inlining thse "for speed" makes no sense.
    
    This patch removes "inline" from biggest static function
    (regardless of number of callsites - gcc nowadays auto-inlines
    statics with one callsite).
    
    Size difference for 32bit x86:
    
    text   data    bss    dec    hex filename
    6299    129      0   6428   191c linux-2.6-ALLYES/drivers/net/sb1000.o
    5418    129      0   5547   15ab linux-2.6.inline-ALLYES/drivers/net/sb1000.o
    
    Signed-off-by: Denys Vlasenko <vda.linux@googlemail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
index 487f9d2ac5b4..829d0ea2709d 100644
--- a/drivers/net/sb1000.c
+++ b/drivers/net/sb1000.c
@@ -88,31 +88,31 @@ static int sb1000_close(struct net_device *dev);
 
 
 /* SB1000 hardware routines to be used during open/configuration phases */
-static inline int card_wait_for_busy_clear(const int ioaddr[],
+static int card_wait_for_busy_clear(const int ioaddr[],
 	const char* name);
-static inline int card_wait_for_ready(const int ioaddr[], const char* name,
+static int card_wait_for_ready(const int ioaddr[], const char* name,
 	unsigned char in[]);
 static int card_send_command(const int ioaddr[], const char* name,
 	const unsigned char out[], unsigned char in[]);
 
 /* SB1000 hardware routines to be used during frame rx interrupt */
-static inline int sb1000_wait_for_ready(const int ioaddr[], const char* name);
-static inline int sb1000_wait_for_ready_clear(const int ioaddr[],
+static int sb1000_wait_for_ready(const int ioaddr[], const char* name);
+static int sb1000_wait_for_ready_clear(const int ioaddr[],
 	const char* name);
-static inline void sb1000_send_command(const int ioaddr[], const char* name,
+static void sb1000_send_command(const int ioaddr[], const char* name,
 	const unsigned char out[]);
-static inline void sb1000_read_status(const int ioaddr[], unsigned char in[]);
-static inline void sb1000_issue_read_command(const int ioaddr[],
+static void sb1000_read_status(const int ioaddr[], unsigned char in[]);
+static void sb1000_issue_read_command(const int ioaddr[],
 	const char* name);
 
 /* SB1000 commands for open/configuration */
-static inline int sb1000_reset(const int ioaddr[], const char* name);
-static inline int sb1000_check_CRC(const int ioaddr[], const char* name);
+static int sb1000_reset(const int ioaddr[], const char* name);
+static int sb1000_check_CRC(const int ioaddr[], const char* name);
 static inline int sb1000_start_get_set_command(const int ioaddr[],
 	const char* name);
-static inline int sb1000_end_get_set_command(const int ioaddr[],
+static int sb1000_end_get_set_command(const int ioaddr[],
 	const char* name);
-static inline int sb1000_activate(const int ioaddr[], const char* name);
+static int sb1000_activate(const int ioaddr[], const char* name);
 static int sb1000_get_firmware_version(const int ioaddr[],
 	const char* name, unsigned char version[], int do_end);
 static int sb1000_get_frequency(const int ioaddr[], const char* name,
@@ -125,8 +125,8 @@ static int sb1000_set_PIDs(const int ioaddr[], const char* name,
 	const short PID[]);
 
 /* SB1000 commands for frame rx interrupt */
-static inline int sb1000_rx(struct net_device *dev);
-static inline void sb1000_error_dpc(struct net_device *dev);
+static int sb1000_rx(struct net_device *dev);
+static void sb1000_error_dpc(struct net_device *dev);
 
 static const struct pnp_device_id sb1000_pnp_ids[] = {
 	{ "GIC1000", 0 },
@@ -250,7 +250,7 @@ static struct pnp_driver sb1000_driver = {
 static const int TimeOutJiffies = (875 * HZ) / 100;
 
 /* Card Wait For Busy Clear (cannot be used during an interrupt) */
-static inline int
+static int
 card_wait_for_busy_clear(const int ioaddr[], const char* name)
 {
 	unsigned char a;
@@ -274,7 +274,7 @@ card_wait_for_busy_clear(const int ioaddr[], const char* name)
 }
 
 /* Card Wait For Ready (cannot be used during an interrupt) */
-static inline int
+static int
 card_wait_for_ready(const int ioaddr[], const char* name, unsigned char in[])
 {
 	unsigned char a;
@@ -354,7 +354,7 @@ card_send_command(const int ioaddr[], const char* name,
 static const int Sb1000TimeOutJiffies = 7 * HZ;
 
 /* Card Wait For Ready (to be used during frame rx) */
-static inline int
+static int
 sb1000_wait_for_ready(const int ioaddr[], const char* name)
 {
 	unsigned long timeout;
@@ -380,7 +380,7 @@ sb1000_wait_for_ready(const int ioaddr[], const char* name)
 }
 
 /* Card Wait For Ready Clear (to be used during frame rx) */
-static inline int
+static int
 sb1000_wait_for_ready_clear(const int ioaddr[], const char* name)
 {
 	unsigned long timeout;
@@ -405,7 +405,7 @@ sb1000_wait_for_ready_clear(const int ioaddr[], const char* name)
 }
 
 /* Card Send Command (to be used during frame rx) */
-static inline void
+static void
 sb1000_send_command(const int ioaddr[], const char* name,
 	const unsigned char out[])
 {
@@ -422,7 +422,7 @@ sb1000_send_command(const int ioaddr[], const char* name,
 }
 
 /* Card Read Status (to be used during frame rx) */
-static inline void
+static void
 sb1000_read_status(const int ioaddr[], unsigned char in[])
 {
 	in[1] = inb(ioaddr[0] + 1);
@@ -434,7 +434,7 @@ sb1000_read_status(const int ioaddr[], unsigned char in[])
 }
 
 /* Issue Read Command (to be used during frame rx) */
-static inline void
+static void
 sb1000_issue_read_command(const int ioaddr[], const char* name)
 {
 	const unsigned char Command0[6] = {0x20, 0x00, 0x00, 0x01, 0x00, 0x00};
@@ -450,7 +450,7 @@ sb1000_issue_read_command(const int ioaddr[], const char* name)
  * SB1000 commands for open/configuration
  */
 /* reset SB1000 card */
-static inline int
+static int
 sb1000_reset(const int ioaddr[], const char* name)
 {
 	unsigned char st[7];
@@ -479,7 +479,7 @@ sb1000_reset(const int ioaddr[], const char* name)
 }
 
 /* check SB1000 firmware CRC */
-static inline int
+static int
 sb1000_check_CRC(const int ioaddr[], const char* name)
 {
 	unsigned char st[7];
@@ -504,7 +504,7 @@ sb1000_start_get_set_command(const int ioaddr[], const char* name)
 	return card_send_command(ioaddr, name, Command0, st);
 }
 
-static inline int
+static int
 sb1000_end_get_set_command(const int ioaddr[], const char* name)
 {
 	unsigned char st[7];
@@ -517,7 +517,7 @@ sb1000_end_get_set_command(const int ioaddr[], const char* name)
 	return card_send_command(ioaddr, name, Command1, st);
 }
 
-static inline int
+static int
 sb1000_activate(const int ioaddr[], const char* name)
 {
 	unsigned char st[7];
@@ -694,7 +694,7 @@ sb1000_set_PIDs(const int ioaddr[], const char* name, const short PID[])
 }
 
 
-static inline void
+static void
 sb1000_print_status_buffer(const char* name, unsigned char st[],
 	unsigned char buffer[], int size)
 {
@@ -725,7 +725,7 @@ sb1000_print_status_buffer(const char* name, unsigned char st[],
 /* receive a single frame and assemble datagram
  * (this is the heart of the interrupt routine)
  */
-static inline int
+static int
 sb1000_rx(struct net_device *dev)
 {
 
@@ -888,7 +888,7 @@ printk("cm0: IP identification: %02x%02x  fragment offset: %02x%02x\n", buffer[3
 	return -1;
 }
 
-static inline void
+static void
 sb1000_error_dpc(struct net_device *dev)
 {
 	char *name;

commit 09f75cd7bf13720738e6a196cc0107ce9a5bd5a0
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Oct 3 17:41:50 2007 -0700

    [NET] drivers/net: statistics cleanup #1 -- save memory and shrink code
    
    We now have struct net_device_stats embedded in struct net_device,
    and the default ->get_stats() hook does the obvious thing for us.
    
    Run through drivers/net/* and remove the driver-local storage of
    statistics, and driver-local ->get_stats() hook where applicable.
    
    This was just the low-hanging fruit in drivers/net; plenty more drivers
    remain to be updated.
    
    [ Resolved conflicts with napi_struct changes and fix sunqe build
      regression... -DaveM ]
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
index aeaa75f549e6..487f9d2ac5b4 100644
--- a/drivers/net/sb1000.c
+++ b/drivers/net/sb1000.c
@@ -76,7 +76,6 @@ struct sb1000_private {
 	unsigned char rx_session_id[NPIDS];
 	unsigned char rx_frame_id[NPIDS];
 	unsigned char rx_pkt_type[NPIDS];
-	struct net_device_stats stats;
 };
 
 /* prototypes for Linux interface */
@@ -85,7 +84,6 @@ static int sb1000_open(struct net_device *dev);
 static int sb1000_dev_ioctl (struct net_device *dev, struct ifreq *ifr, int cmd);
 static int sb1000_start_xmit(struct sk_buff *skb, struct net_device *dev);
 static irqreturn_t sb1000_interrupt(int irq, void *dev_id);
-static struct net_device_stats *sb1000_stats(struct net_device *dev);
 static int sb1000_close(struct net_device *dev);
 
 
@@ -199,7 +197,6 @@ sb1000_probe_one(struct pnp_dev *pdev, const struct pnp_device_id *id)
 	dev->do_ioctl		= sb1000_dev_ioctl;
 	dev->hard_start_xmit	= sb1000_start_xmit;
 	dev->stop		= sb1000_close;
-	dev->get_stats		= sb1000_stats;
 
 	/* hardware address is 0:0:serial_number */
 	dev->dev_addr[2]	= serial_number >> 24 & 0xff;
@@ -739,7 +736,7 @@ sb1000_rx(struct net_device *dev)
 	unsigned int skbsize;
 	struct sk_buff *skb;
 	struct sb1000_private *lp = netdev_priv(dev);
-	struct net_device_stats *stats = &lp->stats;
+	struct net_device_stats *stats = &dev->stats;
 
 	/* SB1000 frame constants */
 	const int FrameSize = FRAMESIZE;
@@ -1002,11 +999,11 @@ static int sb1000_dev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 
 	switch (cmd) {
 	case SIOCGCMSTATS:		/* get statistics */
-		stats[0] = lp->stats.rx_bytes;
+		stats[0] = dev->stats.rx_bytes;
 		stats[1] = lp->rx_frames;
-		stats[2] = lp->stats.rx_packets;
-		stats[3] = lp->stats.rx_errors;
-		stats[4] = lp->stats.rx_dropped;
+		stats[2] = dev->stats.rx_packets;
+		stats[3] = dev->stats.rx_errors;
+		stats[4] = dev->stats.rx_dropped;
 		if(copy_to_user(ifr->ifr_data, stats, sizeof(stats)))
 			return -EFAULT;
 		status = 0;
@@ -1132,12 +1129,6 @@ static irqreturn_t sb1000_interrupt(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static struct net_device_stats *sb1000_stats(struct net_device *dev)
-{
-	struct sb1000_private *lp = netdev_priv(dev);
-	return &lp->stats;
-}
-
 static int sb1000_close(struct net_device *dev)
 {
 	int i;

commit 10d024c1b2fd58af8362670d7d6e5ae52fc33353
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Sep 17 13:11:17 2007 -0700

    [NET]: Nuke SET_MODULE_OWNER macro.
    
    It's been a useless no-op for long enough in 2.6 so I figured it's time to
    remove it.  The number of people that could object because they're
    maintaining unified 2.4 and 2.6 drivers is probably rather small.
    
    [ Handled drivers added by netdev tree and some missed IRDA cases... -DaveM ]
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
index 1de3eec1a792..aeaa75f549e6 100644
--- a/drivers/net/sb1000.c
+++ b/drivers/net/sb1000.c
@@ -189,7 +189,6 @@ sb1000_probe_one(struct pnp_dev *pdev, const struct pnp_device_id *id)
 	 */
 	dev->flags = IFF_POINTOPOINT|IFF_NOARP;
 
-	SET_MODULE_OWNER(dev);
 	SET_NETDEV_DEV(dev, &pdev->dev);
 
 	if (sb1000_debug > 0)

commit 459a98ed881802dee55897441bc7f77af614368e
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 19 15:30:44 2007 -0700

    [SK_BUFF]: Introduce skb_reset_mac_header(skb)
    
    For the common, open coded 'skb->mac.raw = skb->data' operation, so that we can
    later turn skb->mac.raw into a offset, reducing the size of struct sk_buff in
    64bit land while possibly keeping it as a pointer on 32bit.
    
    This one touches just the most simple case, next will handle the slightly more
    "complex" cases.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
index b9fa4fbb1398..1de3eec1a792 100644
--- a/drivers/net/sb1000.c
+++ b/drivers/net/sb1000.c
@@ -834,7 +834,7 @@ printk("cm0: IP identification: %02x%02x  fragment offset: %02x%02x\n", buffer[3
 			goto dropped_frame;
 		}
 		skb->dev = dev;
-		skb->mac.raw = skb->data;
+		skb_reset_mac_header(skb);
 		skb->protocol = (unsigned short) buffer[NewDatagramHeaderSkip + 16];
 		insw(ioaddr, skb_put(skb, NewDatagramDataSize),
 			NewDatagramDataSize / 2);

commit c31f28e778ab299a5035ea2bda64f245b8915d7c
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri Oct 6 14:56:04 2006 -0400

    drivers/net: eliminate irq handler impossible checks, needless casts
    
    - Eliminate check for irq handler 'dev_id==NULL' where the
      condition never occurs.
    
    - Eliminate needless casts to/from void*
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
index dc30dee5537f..b9fa4fbb1398 100644
--- a/drivers/net/sb1000.c
+++ b/drivers/net/sb1000.c
@@ -1084,19 +1084,13 @@ static irqreturn_t sb1000_interrupt(int irq, void *dev_id)
 	char *name;
 	unsigned char st;
 	int ioaddr[2];
-	struct net_device *dev = (struct net_device *) dev_id;
+	struct net_device *dev = dev_id;
 	struct sb1000_private *lp = netdev_priv(dev);
 
 	const unsigned char Command0[6] = {0x80, 0x2c, 0x00, 0x00, 0x00, 0x00};
 	const unsigned char Command1[6] = {0x80, 0x2e, 0x00, 0x00, 0x00, 0x00};
 	const int MaxRxErrorCount = 6;
 
-	if (dev == NULL) {
-		printk(KERN_ERR "sb1000_interrupt(): irq %d for unknown device.\n",
-			irq);
-		return IRQ_NONE;
-	}
-
 	ioaddr[0] = dev->base_addr;
 	/* mem_start holds the second I/O address */
 	ioaddr[1] = dev->mem_start;

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
index a1789ae59278..dc30dee5537f 100644
--- a/drivers/net/sb1000.c
+++ b/drivers/net/sb1000.c
@@ -84,7 +84,7 @@ extern int sb1000_probe(struct net_device *dev);
 static int sb1000_open(struct net_device *dev);
 static int sb1000_dev_ioctl (struct net_device *dev, struct ifreq *ifr, int cmd);
 static int sb1000_start_xmit(struct sk_buff *skb, struct net_device *dev);
-static irqreturn_t sb1000_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+static irqreturn_t sb1000_interrupt(int irq, void *dev_id);
 static struct net_device_stats *sb1000_stats(struct net_device *dev);
 static int sb1000_close(struct net_device *dev);
 
@@ -1079,7 +1079,7 @@ sb1000_start_xmit(struct sk_buff *skb, struct net_device *dev)
 }
 
 /* SB1000 interrupt handler. */
-static irqreturn_t sb1000_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t sb1000_interrupt(int irq, void *dev_id)
 {
 	char *name;
 	unsigned char st;

commit 6aa20a2235535605db6d6d2bd850298b2fe7f31e
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Sep 13 13:24:59 2006 -0400

    drivers/net: Trim trailing whitespace
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
index 66cf226c4ee3..a1789ae59278 100644
--- a/drivers/net/sb1000.c
+++ b/drivers/net/sb1000.c
@@ -28,7 +28,7 @@
 
 	Small changes to make it work with 2.1.x kernels. Hopefully,
 	nothing major will change before official release of Linux 2.2.
-	
+
 	Merged with 2.2 - Alan Cox
 */
 
@@ -143,7 +143,7 @@ sb1000_probe_one(struct pnp_dev *pdev, const struct pnp_device_id *id)
 	unsigned short ioaddr[2], irq;
 	unsigned int serial_number;
 	int error = -ENODEV;
-	
+
 	if (pnp_device_attach(pdev) < 0)
 		return -ENODEV;
 	if (pnp_activate_dev(pdev) < 0)
@@ -153,12 +153,12 @@ sb1000_probe_one(struct pnp_dev *pdev, const struct pnp_device_id *id)
 		goto out_disable;
 	if (!pnp_irq_valid(pdev, 0))
 		goto out_disable;
-		
+
 	serial_number = pdev->card->serial;
-		
+
 	ioaddr[0] = pnp_port_start(pdev, 0);
 	ioaddr[1] = pnp_port_start(pdev, 0);
-		
+
 	irq = pnp_irq(pdev, 0);
 
 	if (!request_region(ioaddr[0], 16, "sb1000"))
@@ -172,7 +172,7 @@ sb1000_probe_one(struct pnp_dev *pdev, const struct pnp_device_id *id)
 		goto out_release_regions;
 	}
 
-		 
+
 	dev->base_addr = ioaddr[0];
 	/* mem_start holds the second I/O address */
 	dev->mem_start = ioaddr[1];
@@ -246,7 +246,7 @@ static struct pnp_driver sb1000_driver = {
 	.remove		= sb1000_remove_one,
 };
 
-
+
 /*
  * SB1000 hardware routines to be used during open/configuration phases
  */
@@ -351,7 +351,7 @@ card_send_command(const int ioaddr[], const char* name,
 	return 0;
 }
 
-
+
 /*
  * SB1000 hardware routines to be used during frame rx interrupt
  */
@@ -449,7 +449,7 @@ sb1000_issue_read_command(const int ioaddr[], const char* name)
 	return;
 }
 
-
+
 /*
  * SB1000 commands for open/configuration
  */
@@ -697,7 +697,7 @@ sb1000_set_PIDs(const int ioaddr[], const char* name, const short PID[])
 	return sb1000_end_get_set_command(ioaddr, name);
 }
 
-
+
 static inline void
 sb1000_print_status_buffer(const char* name, unsigned char st[],
 	unsigned char buffer[], int size)
@@ -916,7 +916,7 @@ sb1000_error_dpc(struct net_device *dev)
 	return;
 }
 
-
+
 /*
  * Linux interface functions
  */
@@ -1155,7 +1155,7 @@ static int sb1000_close(struct net_device *dev)
 		printk(KERN_DEBUG "%s: Shutting down sb1000.\n", dev->name);
 
 	netif_stop_queue(dev);
-	
+
 	ioaddr[0] = dev->base_addr;
 	/* mem_start holds the second I/O address */
 	ioaddr[1] = dev->mem_start;

commit f71e130966ba429dbd24be08ddbcdf263df9a5ad
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Fri Mar 3 21:33:57 2006 -0500

    Massive net driver const-ification.

diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
index 76139478c3df..66cf226c4ee3 100644
--- a/drivers/net/sb1000.c
+++ b/drivers/net/sb1000.c
@@ -59,7 +59,7 @@ static char version[] = "sb1000.c:v1.1.2 6/01/98 (fventuri@mediaone.net)\n";
 #ifdef SB1000_DEBUG
 static int sb1000_debug = SB1000_DEBUG;
 #else
-static int sb1000_debug = 1;
+static const int sb1000_debug = 1;
 #endif
 
 static const int SB1000_IO_EXTENT = 8;

commit 858119e159384308a5dde67776691a2ebf70df0f
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Sat Jan 14 13:20:43 2006 -0800

    [PATCH] Unlinline a bunch of other functions
    
    Remove the "inline" keyword from a bunch of big functions in the kernel with
    the goal of shrinking it by 30kb to 40kb
    
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Jeff Garzik <jgarzik@pobox.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
index d6388e1533f0..76139478c3df 100644
--- a/drivers/net/sb1000.c
+++ b/drivers/net/sb1000.c
@@ -94,7 +94,7 @@ static inline int card_wait_for_busy_clear(const int ioaddr[],
 	const char* name);
 static inline int card_wait_for_ready(const int ioaddr[], const char* name,
 	unsigned char in[]);
-static inline int card_send_command(const int ioaddr[], const char* name,
+static int card_send_command(const int ioaddr[], const char* name,
 	const unsigned char out[], unsigned char in[]);
 
 /* SB1000 hardware routines to be used during frame rx interrupt */
@@ -309,7 +309,7 @@ card_wait_for_ready(const int ioaddr[], const char* name, unsigned char in[])
 }
 
 /* Card Send Command (cannot be used during an interrupt) */
-static inline int
+static int
 card_send_command(const int ioaddr[], const char* name,
 	const unsigned char out[], unsigned char in[])
 {

commit a26c074c1cf130df95e9c297ef98fdd98348acf0
Author: Nishanth Aravamudan <nacc@us.ibm.com>
Date:   Mon Jun 20 23:54:27 2005 +0200

    [PATCH] net/sb1000: replace nicedelay() with ssleep()
    
    Use ssleep() instead of nicedelay()
    to guarantee the task delays as expected. Remove the prototype and
    definition of nicedelay(). This is a very weird function, because it is
    called to sleep in terms of usecs, but always sleeps for 1 second,
    completely ignoring the parameter. I have gone ahead and followed suit,
    just sleeping for a second in all cases, but maybe someone with the
    hardware could tell me if perhaps the paramter *should* matter. Additionally,
    nicedelay() is called in TASK_INTERRUPTIBLE state, but doesn't deal with signals
    in case these longer delays do not complete, so I believe ssleep() is more
    appropriate.
    
    Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
    Signed-off-by: Domen Puncer <domen@coderock.org>

diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
index e15369c8d165..d6388e1533f0 100644
--- a/drivers/net/sb1000.c
+++ b/drivers/net/sb1000.c
@@ -90,7 +90,6 @@ static int sb1000_close(struct net_device *dev);
 
 
 /* SB1000 hardware routines to be used during open/configuration phases */
-static inline void nicedelay(unsigned long usecs);
 static inline int card_wait_for_busy_clear(const int ioaddr[],
 	const char* name);
 static inline int card_wait_for_ready(const int ioaddr[], const char* name,
@@ -254,13 +253,6 @@ static struct pnp_driver sb1000_driver = {
 
 static const int TimeOutJiffies = (875 * HZ) / 100;
 
-static inline void nicedelay(unsigned long usecs)
-{
-	current->state = TASK_INTERRUPTIBLE;
-	schedule_timeout(HZ);
-	return;
-}
-
 /* Card Wait For Busy Clear (cannot be used during an interrupt) */
 static inline int
 card_wait_for_busy_clear(const int ioaddr[], const char* name)
@@ -475,7 +467,7 @@ sb1000_reset(const int ioaddr[], const char* name)
 	udelay(1000);
 	outb(0x0, port);
 	inb(port);
-	nicedelay(60000);
+	ssleep(1);
 	outb(0x4, port);
 	inb(port);
 	udelay(1000);
@@ -537,7 +529,7 @@ sb1000_activate(const int ioaddr[], const char* name)
 	const unsigned char Command0[6] = {0x80, 0x11, 0x00, 0x00, 0x00, 0x00};
 	const unsigned char Command1[6] = {0x80, 0x16, 0x00, 0x00, 0x00, 0x00};
 
-	nicedelay(50000);
+	ssleep(1);
 	if ((status = card_send_command(ioaddr, name, Command0, st)))
 		return status;
 	if ((status = card_send_command(ioaddr, name, Command1, st)))
@@ -944,7 +936,7 @@ sb1000_open(struct net_device *dev)
 	/* initialize sb1000 */
 	if ((status = sb1000_reset(ioaddr, name)))
 		return status;
-	nicedelay(200000);
+	ssleep(1);
 	if ((status = sb1000_check_CRC(ioaddr, name)))
 		return status;
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
new file mode 100644
index 000000000000..e15369c8d165
--- /dev/null
+++ b/drivers/net/sb1000.c
@@ -0,0 +1,1202 @@
+/* sb1000.c: A General Instruments SB1000 driver for linux. */
+/*
+	Written 1998 by Franco Venturi.
+
+	Copyright 1998 by Franco Venturi.
+	Copyright 1994,1995 by Donald Becker.
+	Copyright 1993 United States Government as represented by the
+	Director, National Security Agency.
+
+	This driver is for the General Instruments SB1000 (internal SURFboard)
+
+	The author may be reached as fventuri@mediaone.net
+
+	This program is free software; you can redistribute it
+	and/or  modify it under  the terms of  the GNU General
+	Public  License as  published  by  the  Free  Software
+	Foundation;  either  version 2 of the License, or  (at
+	your option) any later version.
+
+	Changes:
+
+	981115 Steven Hirsch <shirsch@adelphia.net>
+
+	Linus changed the timer interface.  Should work on all recent
+	development kernels.
+
+	980608 Steven Hirsch <shirsch@adelphia.net>
+
+	Small changes to make it work with 2.1.x kernels. Hopefully,
+	nothing major will change before official release of Linux 2.2.
+	
+	Merged with 2.2 - Alan Cox
+*/
+
+static char version[] = "sb1000.c:v1.1.2 6/01/98 (fventuri@mediaone.net)\n";
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/if_cablemodem.h> /* for SIOGCM/SIOSCM stuff */
+#include <linux/in.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/skbuff.h>
+#include <linux/delay.h>	/* for udelay() */
+#include <linux/etherdevice.h>
+#include <linux/pnp.h>
+#include <linux/init.h>
+#include <linux/bitops.h>
+
+#include <asm/io.h>
+#include <asm/processor.h>
+#include <asm/uaccess.h>
+
+#ifdef SB1000_DEBUG
+static int sb1000_debug = SB1000_DEBUG;
+#else
+static int sb1000_debug = 1;
+#endif
+
+static const int SB1000_IO_EXTENT = 8;
+/* SB1000 Maximum Receive Unit */
+static const int SB1000_MRU = 1500; /* octects */
+
+#define NPIDS 4
+struct sb1000_private {
+	struct sk_buff *rx_skb[NPIDS];
+	short rx_dlen[NPIDS];
+	unsigned int rx_frames;
+	short rx_error_count;
+	short rx_error_dpc_count;
+	unsigned char rx_session_id[NPIDS];
+	unsigned char rx_frame_id[NPIDS];
+	unsigned char rx_pkt_type[NPIDS];
+	struct net_device_stats stats;
+};
+
+/* prototypes for Linux interface */
+extern int sb1000_probe(struct net_device *dev);
+static int sb1000_open(struct net_device *dev);
+static int sb1000_dev_ioctl (struct net_device *dev, struct ifreq *ifr, int cmd);
+static int sb1000_start_xmit(struct sk_buff *skb, struct net_device *dev);
+static irqreturn_t sb1000_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+static struct net_device_stats *sb1000_stats(struct net_device *dev);
+static int sb1000_close(struct net_device *dev);
+
+
+/* SB1000 hardware routines to be used during open/configuration phases */
+static inline void nicedelay(unsigned long usecs);
+static inline int card_wait_for_busy_clear(const int ioaddr[],
+	const char* name);
+static inline int card_wait_for_ready(const int ioaddr[], const char* name,
+	unsigned char in[]);
+static inline int card_send_command(const int ioaddr[], const char* name,
+	const unsigned char out[], unsigned char in[]);
+
+/* SB1000 hardware routines to be used during frame rx interrupt */
+static inline int sb1000_wait_for_ready(const int ioaddr[], const char* name);
+static inline int sb1000_wait_for_ready_clear(const int ioaddr[],
+	const char* name);
+static inline void sb1000_send_command(const int ioaddr[], const char* name,
+	const unsigned char out[]);
+static inline void sb1000_read_status(const int ioaddr[], unsigned char in[]);
+static inline void sb1000_issue_read_command(const int ioaddr[],
+	const char* name);
+
+/* SB1000 commands for open/configuration */
+static inline int sb1000_reset(const int ioaddr[], const char* name);
+static inline int sb1000_check_CRC(const int ioaddr[], const char* name);
+static inline int sb1000_start_get_set_command(const int ioaddr[],
+	const char* name);
+static inline int sb1000_end_get_set_command(const int ioaddr[],
+	const char* name);
+static inline int sb1000_activate(const int ioaddr[], const char* name);
+static int sb1000_get_firmware_version(const int ioaddr[],
+	const char* name, unsigned char version[], int do_end);
+static int sb1000_get_frequency(const int ioaddr[], const char* name,
+	int* frequency);
+static int sb1000_set_frequency(const int ioaddr[], const char* name,
+	int frequency);
+static int sb1000_get_PIDs(const int ioaddr[], const char* name,
+	short PID[]);
+static int sb1000_set_PIDs(const int ioaddr[], const char* name,
+	const short PID[]);
+
+/* SB1000 commands for frame rx interrupt */
+static inline int sb1000_rx(struct net_device *dev);
+static inline void sb1000_error_dpc(struct net_device *dev);
+
+static const struct pnp_device_id sb1000_pnp_ids[] = {
+	{ "GIC1000", 0 },
+	{ "", 0 }
+};
+MODULE_DEVICE_TABLE(pnp, sb1000_pnp_ids);
+
+static int
+sb1000_probe_one(struct pnp_dev *pdev, const struct pnp_device_id *id)
+{
+	struct net_device *dev;
+	unsigned short ioaddr[2], irq;
+	unsigned int serial_number;
+	int error = -ENODEV;
+	
+	if (pnp_device_attach(pdev) < 0)
+		return -ENODEV;
+	if (pnp_activate_dev(pdev) < 0)
+		goto out_detach;
+
+	if (!pnp_port_valid(pdev, 0) || !pnp_port_valid(pdev, 1))
+		goto out_disable;
+	if (!pnp_irq_valid(pdev, 0))
+		goto out_disable;
+		
+	serial_number = pdev->card->serial;
+		
+	ioaddr[0] = pnp_port_start(pdev, 0);
+	ioaddr[1] = pnp_port_start(pdev, 0);
+		
+	irq = pnp_irq(pdev, 0);
+
+	if (!request_region(ioaddr[0], 16, "sb1000"))
+		goto out_disable;
+	if (!request_region(ioaddr[1], 16, "sb1000"))
+		goto out_release_region0;
+
+	dev = alloc_etherdev(sizeof(struct sb1000_private));
+	if (!dev) {
+		error = -ENOMEM;
+		goto out_release_regions;
+	}
+
+		 
+	dev->base_addr = ioaddr[0];
+	/* mem_start holds the second I/O address */
+	dev->mem_start = ioaddr[1];
+	dev->irq = irq;
+
+	if (sb1000_debug > 0)
+		printk(KERN_NOTICE "%s: sb1000 at (%#3.3lx,%#3.3lx), "
+			"S/N %#8.8x, IRQ %d.\n", dev->name, dev->base_addr,
+			dev->mem_start, serial_number, dev->irq);
+
+	/*
+	 * The SB1000 is an rx-only cable modem device.  The uplink is a modem
+	 * and we do not want to arp on it.
+	 */
+	dev->flags = IFF_POINTOPOINT|IFF_NOARP;
+
+	SET_MODULE_OWNER(dev);
+	SET_NETDEV_DEV(dev, &pdev->dev);
+
+	if (sb1000_debug > 0)
+		printk(KERN_NOTICE "%s", version);
+
+	/* The SB1000-specific entries in the device structure. */
+	dev->open		= sb1000_open;
+	dev->do_ioctl		= sb1000_dev_ioctl;
+	dev->hard_start_xmit	= sb1000_start_xmit;
+	dev->stop		= sb1000_close;
+	dev->get_stats		= sb1000_stats;
+
+	/* hardware address is 0:0:serial_number */
+	dev->dev_addr[2]	= serial_number >> 24 & 0xff;
+	dev->dev_addr[3]	= serial_number >> 16 & 0xff;
+	dev->dev_addr[4]	= serial_number >>  8 & 0xff;
+	dev->dev_addr[5]	= serial_number >>  0 & 0xff;
+
+	pnp_set_drvdata(pdev, dev);
+
+	error = register_netdev(dev);
+	if (error)
+		goto out_free_netdev;
+	return 0;
+
+ out_free_netdev:
+	free_netdev(dev);
+ out_release_regions:
+	release_region(ioaddr[1], 16);
+ out_release_region0:
+	release_region(ioaddr[0], 16);
+ out_disable:
+	pnp_disable_dev(pdev);
+ out_detach:
+	pnp_device_detach(pdev);
+	return error;
+}
+
+static void
+sb1000_remove_one(struct pnp_dev *pdev)
+{
+	struct net_device *dev = pnp_get_drvdata(pdev);
+
+	unregister_netdev(dev);
+	release_region(dev->base_addr, 16);
+	release_region(dev->mem_start, 16);
+	free_netdev(dev);
+}
+
+static struct pnp_driver sb1000_driver = {
+	.name		= "sb1000",
+	.id_table	= sb1000_pnp_ids,
+	.probe		= sb1000_probe_one,
+	.remove		= sb1000_remove_one,
+};
+
+
+/*
+ * SB1000 hardware routines to be used during open/configuration phases
+ */
+
+static const int TimeOutJiffies = (875 * HZ) / 100;
+
+static inline void nicedelay(unsigned long usecs)
+{
+	current->state = TASK_INTERRUPTIBLE;
+	schedule_timeout(HZ);
+	return;
+}
+
+/* Card Wait For Busy Clear (cannot be used during an interrupt) */
+static inline int
+card_wait_for_busy_clear(const int ioaddr[], const char* name)
+{
+	unsigned char a;
+	unsigned long timeout;
+
+	a = inb(ioaddr[0] + 7);
+	timeout = jiffies + TimeOutJiffies;
+	while (a & 0x80 || a & 0x40) {
+		/* a little sleep */
+		yield();
+
+		a = inb(ioaddr[0] + 7);
+		if (time_after_eq(jiffies, timeout)) {
+			printk(KERN_WARNING "%s: card_wait_for_busy_clear timeout\n",
+				name);
+			return -ETIME;
+		}
+	}
+
+	return 0;
+}
+
+/* Card Wait For Ready (cannot be used during an interrupt) */
+static inline int
+card_wait_for_ready(const int ioaddr[], const char* name, unsigned char in[])
+{
+	unsigned char a;
+	unsigned long timeout;
+
+	a = inb(ioaddr[1] + 6);
+	timeout = jiffies + TimeOutJiffies;
+	while (a & 0x80 || !(a & 0x40)) {
+		/* a little sleep */
+		yield();
+
+		a = inb(ioaddr[1] + 6);
+		if (time_after_eq(jiffies, timeout)) {
+			printk(KERN_WARNING "%s: card_wait_for_ready timeout\n",
+				name);
+			return -ETIME;
+		}
+	}
+
+	in[1] = inb(ioaddr[0] + 1);
+	in[2] = inb(ioaddr[0] + 2);
+	in[3] = inb(ioaddr[0] + 3);
+	in[4] = inb(ioaddr[0] + 4);
+	in[0] = inb(ioaddr[0] + 5);
+	in[6] = inb(ioaddr[0] + 6);
+	in[5] = inb(ioaddr[1] + 6);
+	return 0;
+}
+
+/* Card Send Command (cannot be used during an interrupt) */
+static inline int
+card_send_command(const int ioaddr[], const char* name,
+	const unsigned char out[], unsigned char in[])
+{
+	int status, x;
+
+	if ((status = card_wait_for_busy_clear(ioaddr, name)))
+		return status;
+	outb(0xa0, ioaddr[0] + 6);
+	outb(out[2], ioaddr[0] + 1);
+	outb(out[3], ioaddr[0] + 2);
+	outb(out[4], ioaddr[0] + 3);
+	outb(out[5], ioaddr[0] + 4);
+	outb(out[1], ioaddr[0] + 5);
+	outb(0xa0, ioaddr[0] + 6);
+	outb(out[0], ioaddr[0] + 7);
+	if (out[0] != 0x20 && out[0] != 0x30) {
+		if ((status = card_wait_for_ready(ioaddr, name, in)))
+			return status;
+		inb(ioaddr[0] + 7);
+		if (sb1000_debug > 3)
+			printk(KERN_DEBUG "%s: card_send_command "
+				"out: %02x%02x%02x%02x%02x%02x  "
+				"in: %02x%02x%02x%02x%02x%02x%02x\n", name,
+				out[0], out[1], out[2], out[3], out[4], out[5],
+				in[0], in[1], in[2], in[3], in[4], in[5], in[6]);
+	} else {
+		if (sb1000_debug > 3)
+			printk(KERN_DEBUG "%s: card_send_command "
+				"out: %02x%02x%02x%02x%02x%02x\n", name,
+				out[0], out[1], out[2], out[3], out[4], out[5]);
+	}
+
+	if (out[1] == 0x1b) {
+		x = (out[2] == 0x02);
+	} else {
+		if (out[0] >= 0x80 && in[0] != (out[1] | 0x80))
+			return -EIO;
+	}
+	return 0;
+}
+
+
+/*
+ * SB1000 hardware routines to be used during frame rx interrupt
+ */
+static const int Sb1000TimeOutJiffies = 7 * HZ;
+
+/* Card Wait For Ready (to be used during frame rx) */
+static inline int
+sb1000_wait_for_ready(const int ioaddr[], const char* name)
+{
+	unsigned long timeout;
+
+	timeout = jiffies + Sb1000TimeOutJiffies;
+	while (inb(ioaddr[1] + 6) & 0x80) {
+		if (time_after_eq(jiffies, timeout)) {
+			printk(KERN_WARNING "%s: sb1000_wait_for_ready timeout\n",
+				name);
+			return -ETIME;
+		}
+	}
+	timeout = jiffies + Sb1000TimeOutJiffies;
+	while (!(inb(ioaddr[1] + 6) & 0x40)) {
+		if (time_after_eq(jiffies, timeout)) {
+			printk(KERN_WARNING "%s: sb1000_wait_for_ready timeout\n",
+				name);
+			return -ETIME;
+		}
+	}
+	inb(ioaddr[0] + 7);
+	return 0;
+}
+
+/* Card Wait For Ready Clear (to be used during frame rx) */
+static inline int
+sb1000_wait_for_ready_clear(const int ioaddr[], const char* name)
+{
+	unsigned long timeout;
+
+	timeout = jiffies + Sb1000TimeOutJiffies;
+	while (inb(ioaddr[1] + 6) & 0x80) {
+		if (time_after_eq(jiffies, timeout)) {
+			printk(KERN_WARNING "%s: sb1000_wait_for_ready_clear timeout\n",
+				name);
+			return -ETIME;
+		}
+	}
+	timeout = jiffies + Sb1000TimeOutJiffies;
+	while (inb(ioaddr[1] + 6) & 0x40) {
+		if (time_after_eq(jiffies, timeout)) {
+			printk(KERN_WARNING "%s: sb1000_wait_for_ready_clear timeout\n",
+				name);
+			return -ETIME;
+		}
+	}
+	return 0;
+}
+
+/* Card Send Command (to be used during frame rx) */
+static inline void
+sb1000_send_command(const int ioaddr[], const char* name,
+	const unsigned char out[])
+{
+	outb(out[2], ioaddr[0] + 1);
+	outb(out[3], ioaddr[0] + 2);
+	outb(out[4], ioaddr[0] + 3);
+	outb(out[5], ioaddr[0] + 4);
+	outb(out[1], ioaddr[0] + 5);
+	outb(out[0], ioaddr[0] + 7);
+	if (sb1000_debug > 3)
+		printk(KERN_DEBUG "%s: sb1000_send_command out: %02x%02x%02x%02x"
+			"%02x%02x\n", name, out[0], out[1], out[2], out[3], out[4], out[5]);
+	return;
+}
+
+/* Card Read Status (to be used during frame rx) */
+static inline void
+sb1000_read_status(const int ioaddr[], unsigned char in[])
+{
+	in[1] = inb(ioaddr[0] + 1);
+	in[2] = inb(ioaddr[0] + 2);
+	in[3] = inb(ioaddr[0] + 3);
+	in[4] = inb(ioaddr[0] + 4);
+	in[0] = inb(ioaddr[0] + 5);
+	return;
+}
+
+/* Issue Read Command (to be used during frame rx) */
+static inline void
+sb1000_issue_read_command(const int ioaddr[], const char* name)
+{
+	const unsigned char Command0[6] = {0x20, 0x00, 0x00, 0x01, 0x00, 0x00};
+
+	sb1000_wait_for_ready_clear(ioaddr, name);
+	outb(0xa0, ioaddr[0] + 6);
+	sb1000_send_command(ioaddr, name, Command0);
+	return;
+}
+
+
+/*
+ * SB1000 commands for open/configuration
+ */
+/* reset SB1000 card */
+static inline int
+sb1000_reset(const int ioaddr[], const char* name)
+{
+	unsigned char st[7];
+	int port, status;
+	const unsigned char Command0[6] = {0x80, 0x16, 0x00, 0x00, 0x00, 0x00};
+
+	port = ioaddr[1] + 6;
+	outb(0x4, port);
+	inb(port);
+	udelay(1000);
+	outb(0x0, port);
+	inb(port);
+	nicedelay(60000);
+	outb(0x4, port);
+	inb(port);
+	udelay(1000);
+	outb(0x0, port);
+	inb(port);
+	udelay(0);
+
+	if ((status = card_send_command(ioaddr, name, Command0, st)))
+		return status;
+	if (st[3] != 0xf0)
+		return -EIO;
+	return 0;
+}
+
+/* check SB1000 firmware CRC */
+static inline int
+sb1000_check_CRC(const int ioaddr[], const char* name)
+{
+	unsigned char st[7];
+	int crc, status;
+	const unsigned char Command0[6] = {0x80, 0x1f, 0x00, 0x00, 0x00, 0x00};
+
+	/* check CRC */
+	if ((status = card_send_command(ioaddr, name, Command0, st)))
+		return status;
+	if (st[1] != st[3] || st[2] != st[4])
+		return -EIO;
+	crc = st[1] << 8 | st[2];
+	return 0;
+}
+
+static inline int
+sb1000_start_get_set_command(const int ioaddr[], const char* name)
+{
+	unsigned char st[7];
+	const unsigned char Command0[6] = {0x80, 0x1b, 0x00, 0x00, 0x00, 0x00};
+
+	return card_send_command(ioaddr, name, Command0, st);
+}
+
+static inline int
+sb1000_end_get_set_command(const int ioaddr[], const char* name)
+{
+	unsigned char st[7];
+	int status;
+	const unsigned char Command0[6] = {0x80, 0x1b, 0x02, 0x00, 0x00, 0x00};
+	const unsigned char Command1[6] = {0x20, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+	if ((status = card_send_command(ioaddr, name, Command0, st)))
+		return status;
+	return card_send_command(ioaddr, name, Command1, st);
+}
+
+static inline int
+sb1000_activate(const int ioaddr[], const char* name)
+{
+	unsigned char st[7];
+	int status;
+	const unsigned char Command0[6] = {0x80, 0x11, 0x00, 0x00, 0x00, 0x00};
+	const unsigned char Command1[6] = {0x80, 0x16, 0x00, 0x00, 0x00, 0x00};
+
+	nicedelay(50000);
+	if ((status = card_send_command(ioaddr, name, Command0, st)))
+		return status;
+	if ((status = card_send_command(ioaddr, name, Command1, st)))
+		return status;
+	if (st[3] != 0xf1) {
+    	if ((status = sb1000_start_get_set_command(ioaddr, name)))
+			return status;
+		return -EIO;
+	}
+	udelay(1000);
+    return sb1000_start_get_set_command(ioaddr, name);
+}
+
+/* get SB1000 firmware version */
+static int
+sb1000_get_firmware_version(const int ioaddr[], const char* name,
+	unsigned char version[], int do_end)
+{
+	unsigned char st[7];
+	int status;
+	const unsigned char Command0[6] = {0x80, 0x23, 0x00, 0x00, 0x00, 0x00};
+
+	if ((status = sb1000_start_get_set_command(ioaddr, name)))
+		return status;
+	if ((status = card_send_command(ioaddr, name, Command0, st)))
+		return status;
+	if (st[0] != 0xa3)
+		return -EIO;
+	version[0] = st[1];
+	version[1] = st[2];
+	if (do_end)
+		return sb1000_end_get_set_command(ioaddr, name);
+	else
+		return 0;
+}
+
+/* get SB1000 frequency */
+static int
+sb1000_get_frequency(const int ioaddr[], const char* name, int* frequency)
+{
+	unsigned char st[7];
+	int status;
+	const unsigned char Command0[6] = {0x80, 0x44, 0x00, 0x00, 0x00, 0x00};
+
+	udelay(1000);
+	if ((status = sb1000_start_get_set_command(ioaddr, name)))
+		return status;
+	if ((status = card_send_command(ioaddr, name, Command0, st)))
+		return status;
+	*frequency = ((st[1] << 8 | st[2]) << 8 | st[3]) << 8 | st[4];
+	return sb1000_end_get_set_command(ioaddr, name);
+}
+
+/* set SB1000 frequency */
+static int
+sb1000_set_frequency(const int ioaddr[], const char* name, int frequency)
+{
+	unsigned char st[7];
+	int status;
+	unsigned char Command0[6] = {0x80, 0x29, 0x00, 0x00, 0x00, 0x00};
+
+	const int FrequencyLowerLimit = 57000;
+	const int FrequencyUpperLimit = 804000;
+
+	if (frequency < FrequencyLowerLimit || frequency > FrequencyUpperLimit) {
+		printk(KERN_ERR "%s: frequency chosen (%d kHz) is not in the range "
+			"[%d,%d] kHz\n", name, frequency, FrequencyLowerLimit,
+			FrequencyUpperLimit);
+		return -EINVAL;
+	}
+	udelay(1000);
+	if ((status = sb1000_start_get_set_command(ioaddr, name)))
+		return status;
+	Command0[5] = frequency & 0xff;
+	frequency >>= 8;
+	Command0[4] = frequency & 0xff;
+	frequency >>= 8;
+	Command0[3] = frequency & 0xff;
+	frequency >>= 8;
+	Command0[2] = frequency & 0xff;
+	return card_send_command(ioaddr, name, Command0, st);
+}
+
+/* get SB1000 PIDs */
+static int
+sb1000_get_PIDs(const int ioaddr[], const char* name, short PID[])
+{
+	unsigned char st[7];
+	int status;
+	const unsigned char Command0[6] = {0x80, 0x40, 0x00, 0x00, 0x00, 0x00};
+	const unsigned char Command1[6] = {0x80, 0x41, 0x00, 0x00, 0x00, 0x00};
+	const unsigned char Command2[6] = {0x80, 0x42, 0x00, 0x00, 0x00, 0x00};
+	const unsigned char Command3[6] = {0x80, 0x43, 0x00, 0x00, 0x00, 0x00};
+
+	udelay(1000);
+	if ((status = sb1000_start_get_set_command(ioaddr, name)))
+		return status;
+
+	if ((status = card_send_command(ioaddr, name, Command0, st)))
+		return status;
+	PID[0] = st[1] << 8 | st[2];
+
+	if ((status = card_send_command(ioaddr, name, Command1, st)))
+		return status;
+	PID[1] = st[1] << 8 | st[2];
+
+	if ((status = card_send_command(ioaddr, name, Command2, st)))
+		return status;
+	PID[2] = st[1] << 8 | st[2];
+
+	if ((status = card_send_command(ioaddr, name, Command3, st)))
+		return status;
+	PID[3] = st[1] << 8 | st[2];
+
+	return sb1000_end_get_set_command(ioaddr, name);
+}
+
+/* set SB1000 PIDs */
+static int
+sb1000_set_PIDs(const int ioaddr[], const char* name, const short PID[])
+{
+	unsigned char st[7];
+	short p;
+	int status;
+	unsigned char Command0[6] = {0x80, 0x31, 0x00, 0x00, 0x00, 0x00};
+	unsigned char Command1[6] = {0x80, 0x32, 0x00, 0x00, 0x00, 0x00};
+	unsigned char Command2[6] = {0x80, 0x33, 0x00, 0x00, 0x00, 0x00};
+	unsigned char Command3[6] = {0x80, 0x34, 0x00, 0x00, 0x00, 0x00};
+	const unsigned char Command4[6] = {0x80, 0x2e, 0x00, 0x00, 0x00, 0x00};
+
+	udelay(1000);
+	if ((status = sb1000_start_get_set_command(ioaddr, name)))
+		return status;
+
+	p = PID[0];
+	Command0[3] = p & 0xff;
+	p >>= 8;
+	Command0[2] = p & 0xff;
+	if ((status = card_send_command(ioaddr, name, Command0, st)))
+		return status;
+
+	p = PID[1];
+	Command1[3] = p & 0xff;
+	p >>= 8;
+	Command1[2] = p & 0xff;
+	if ((status = card_send_command(ioaddr, name, Command1, st)))
+		return status;
+
+	p = PID[2];
+	Command2[3] = p & 0xff;
+	p >>= 8;
+	Command2[2] = p & 0xff;
+	if ((status = card_send_command(ioaddr, name, Command2, st)))
+		return status;
+
+	p = PID[3];
+	Command3[3] = p & 0xff;
+	p >>= 8;
+	Command3[2] = p & 0xff;
+	if ((status = card_send_command(ioaddr, name, Command3, st)))
+		return status;
+
+	if ((status = card_send_command(ioaddr, name, Command4, st)))
+		return status;
+	return sb1000_end_get_set_command(ioaddr, name);
+}
+
+
+static inline void
+sb1000_print_status_buffer(const char* name, unsigned char st[],
+	unsigned char buffer[], int size)
+{
+	int i, j, k;
+
+	printk(KERN_DEBUG "%s: status: %02x %02x\n", name, st[0], st[1]);
+	if (buffer[24] == 0x08 && buffer[25] == 0x00 && buffer[26] == 0x45) {
+		printk(KERN_DEBUG "%s: length: %d protocol: %d from: %d.%d.%d.%d:%d "
+			"to %d.%d.%d.%d:%d\n", name, buffer[28] << 8 | buffer[29],
+			buffer[35], buffer[38], buffer[39], buffer[40], buffer[41],
+            buffer[46] << 8 | buffer[47],
+			buffer[42], buffer[43], buffer[44], buffer[45],
+            buffer[48] << 8 | buffer[49]);
+	} else {
+		for (i = 0, k = 0; i < (size + 7) / 8; i++) {
+			printk(KERN_DEBUG "%s: %s", name, i ? "       " : "buffer:");
+			for (j = 0; j < 8 && k < size; j++, k++)
+				printk(" %02x", buffer[k]);
+			printk("\n");
+		}
+	}
+	return;
+}
+
+/*
+ * SB1000 commands for frame rx interrupt
+ */
+/* receive a single frame and assemble datagram
+ * (this is the heart of the interrupt routine)
+ */
+static inline int
+sb1000_rx(struct net_device *dev)
+{
+
+#define FRAMESIZE 184
+	unsigned char st[2], buffer[FRAMESIZE], session_id, frame_id;
+	short dlen;
+	int ioaddr, ns;
+	unsigned int skbsize;
+	struct sk_buff *skb;
+	struct sb1000_private *lp = netdev_priv(dev);
+	struct net_device_stats *stats = &lp->stats;
+
+	/* SB1000 frame constants */
+	const int FrameSize = FRAMESIZE;
+	const int NewDatagramHeaderSkip = 8;
+	const int NewDatagramHeaderSize = NewDatagramHeaderSkip + 18;
+	const int NewDatagramDataSize = FrameSize - NewDatagramHeaderSize;
+	const int ContDatagramHeaderSkip = 7;
+	const int ContDatagramHeaderSize = ContDatagramHeaderSkip + 1;
+	const int ContDatagramDataSize = FrameSize - ContDatagramHeaderSize;
+	const int TrailerSize = 4;
+
+	ioaddr = dev->base_addr;
+
+	insw(ioaddr, (unsigned short*) st, 1);
+#ifdef XXXDEBUG
+printk("cm0: received: %02x %02x\n", st[0], st[1]);
+#endif /* XXXDEBUG */
+	lp->rx_frames++;
+
+	/* decide if it is a good or bad frame */
+	for (ns = 0; ns < NPIDS; ns++) {
+		session_id = lp->rx_session_id[ns];
+		frame_id = lp->rx_frame_id[ns];
+		if (st[0] == session_id) {
+			if (st[1] == frame_id || (!frame_id && (st[1] & 0xf0) == 0x30)) {
+				goto good_frame;
+			} else if ((st[1] & 0xf0) == 0x30 && (st[0] & 0x40)) {
+				goto skipped_frame;
+			} else {
+				goto bad_frame;
+			}
+		} else if (st[0] == (session_id | 0x40)) {
+			if ((st[1] & 0xf0) == 0x30) {
+				goto skipped_frame;
+			} else {
+				goto bad_frame;
+			}
+		}
+	}
+	goto bad_frame;
+
+skipped_frame:
+	stats->rx_frame_errors++;
+	skb = lp->rx_skb[ns];
+	if (sb1000_debug > 1)
+		printk(KERN_WARNING "%s: missing frame(s): got %02x %02x "
+			"expecting %02x %02x\n", dev->name, st[0], st[1],
+			skb ? session_id : session_id | 0x40, frame_id);
+	if (skb) {
+		dev_kfree_skb(skb);
+		skb = NULL;
+	}
+
+good_frame:
+	lp->rx_frame_id[ns] = 0x30 | ((st[1] + 1) & 0x0f);
+	/* new datagram */
+	if (st[0] & 0x40) {
+		/* get data length */
+		insw(ioaddr, buffer, NewDatagramHeaderSize / 2);
+#ifdef XXXDEBUG
+printk("cm0: IP identification: %02x%02x  fragment offset: %02x%02x\n", buffer[30], buffer[31], buffer[32], buffer[33]);
+#endif /* XXXDEBUG */
+		if (buffer[0] != NewDatagramHeaderSkip) {
+			if (sb1000_debug > 1)
+				printk(KERN_WARNING "%s: new datagram header skip error: "
+					"got %02x expecting %02x\n", dev->name, buffer[0],
+					NewDatagramHeaderSkip);
+			stats->rx_length_errors++;
+			insw(ioaddr, buffer, NewDatagramDataSize / 2);
+			goto bad_frame_next;
+		}
+		dlen = ((buffer[NewDatagramHeaderSkip + 3] & 0x0f) << 8 |
+			buffer[NewDatagramHeaderSkip + 4]) - 17;
+		if (dlen > SB1000_MRU) {
+			if (sb1000_debug > 1)
+				printk(KERN_WARNING "%s: datagram length (%d) greater "
+					"than MRU (%d)\n", dev->name, dlen, SB1000_MRU);
+			stats->rx_length_errors++;
+			insw(ioaddr, buffer, NewDatagramDataSize / 2);
+			goto bad_frame_next;
+		}
+		lp->rx_dlen[ns] = dlen;
+		/* compute size to allocate for datagram */
+		skbsize = dlen + FrameSize;
+		if ((skb = alloc_skb(skbsize, GFP_ATOMIC)) == NULL) {
+			if (sb1000_debug > 1)
+				printk(KERN_WARNING "%s: can't allocate %d bytes long "
+					"skbuff\n", dev->name, skbsize);
+			stats->rx_dropped++;
+			insw(ioaddr, buffer, NewDatagramDataSize / 2);
+			goto dropped_frame;
+		}
+		skb->dev = dev;
+		skb->mac.raw = skb->data;
+		skb->protocol = (unsigned short) buffer[NewDatagramHeaderSkip + 16];
+		insw(ioaddr, skb_put(skb, NewDatagramDataSize),
+			NewDatagramDataSize / 2);
+		lp->rx_skb[ns] = skb;
+	} else {
+		/* continuation of previous datagram */
+		insw(ioaddr, buffer, ContDatagramHeaderSize / 2);
+		if (buffer[0] != ContDatagramHeaderSkip) {
+			if (sb1000_debug > 1)
+				printk(KERN_WARNING "%s: cont datagram header skip error: "
+					"got %02x expecting %02x\n", dev->name, buffer[0],
+					ContDatagramHeaderSkip);
+			stats->rx_length_errors++;
+			insw(ioaddr, buffer, ContDatagramDataSize / 2);
+			goto bad_frame_next;
+		}
+		skb = lp->rx_skb[ns];
+		insw(ioaddr, skb_put(skb, ContDatagramDataSize),
+			ContDatagramDataSize / 2);
+		dlen = lp->rx_dlen[ns];
+	}
+	if (skb->len < dlen + TrailerSize) {
+		lp->rx_session_id[ns] &= ~0x40;
+		return 0;
+	}
+
+	/* datagram completed: send to upper level */
+	skb_trim(skb, dlen);
+	netif_rx(skb);
+	dev->last_rx = jiffies;
+	stats->rx_bytes+=dlen;
+	stats->rx_packets++;
+	lp->rx_skb[ns] = NULL;
+	lp->rx_session_id[ns] |= 0x40;
+	return 0;
+
+bad_frame:
+	insw(ioaddr, buffer, FrameSize / 2);
+	if (sb1000_debug > 1)
+		printk(KERN_WARNING "%s: frame error: got %02x %02x\n",
+			dev->name, st[0], st[1]);
+	stats->rx_frame_errors++;
+bad_frame_next:
+	if (sb1000_debug > 2)
+		sb1000_print_status_buffer(dev->name, st, buffer, FrameSize);
+dropped_frame:
+	stats->rx_errors++;
+	if (ns < NPIDS) {
+		if ((skb = lp->rx_skb[ns])) {
+			dev_kfree_skb(skb);
+			lp->rx_skb[ns] = NULL;
+		}
+		lp->rx_session_id[ns] |= 0x40;
+	}
+	return -1;
+}
+
+static inline void
+sb1000_error_dpc(struct net_device *dev)
+{
+	char *name;
+	unsigned char st[5];
+	int ioaddr[2];
+	struct sb1000_private *lp = netdev_priv(dev);
+	const unsigned char Command0[6] = {0x80, 0x26, 0x00, 0x00, 0x00, 0x00};
+	const int ErrorDpcCounterInitialize = 200;
+
+	ioaddr[0] = dev->base_addr;
+	/* mem_start holds the second I/O address */
+	ioaddr[1] = dev->mem_start;
+	name = dev->name;
+
+	sb1000_wait_for_ready_clear(ioaddr, name);
+	sb1000_send_command(ioaddr, name, Command0);
+	sb1000_wait_for_ready(ioaddr, name);
+	sb1000_read_status(ioaddr, st);
+	if (st[1] & 0x10)
+		lp->rx_error_dpc_count = ErrorDpcCounterInitialize;
+	return;
+}
+
+
+/*
+ * Linux interface functions
+ */
+static int
+sb1000_open(struct net_device *dev)
+{
+	char *name;
+	int ioaddr[2], status;
+	struct sb1000_private *lp = netdev_priv(dev);
+	const unsigned short FirmwareVersion[] = {0x01, 0x01};
+
+	ioaddr[0] = dev->base_addr;
+	/* mem_start holds the second I/O address */
+	ioaddr[1] = dev->mem_start;
+	name = dev->name;
+
+	/* initialize sb1000 */
+	if ((status = sb1000_reset(ioaddr, name)))
+		return status;
+	nicedelay(200000);
+	if ((status = sb1000_check_CRC(ioaddr, name)))
+		return status;
+
+	/* initialize private data before board can catch interrupts */
+	lp->rx_skb[0] = NULL;
+	lp->rx_skb[1] = NULL;
+	lp->rx_skb[2] = NULL;
+	lp->rx_skb[3] = NULL;
+	lp->rx_dlen[0] = 0;
+	lp->rx_dlen[1] = 0;
+	lp->rx_dlen[2] = 0;
+	lp->rx_dlen[3] = 0;
+	lp->rx_frames = 0;
+	lp->rx_error_count = 0;
+	lp->rx_error_dpc_count = 0;
+	lp->rx_session_id[0] = 0x50;
+	lp->rx_session_id[0] = 0x48;
+	lp->rx_session_id[0] = 0x44;
+	lp->rx_session_id[0] = 0x42;
+	lp->rx_frame_id[0] = 0;
+	lp->rx_frame_id[1] = 0;
+	lp->rx_frame_id[2] = 0;
+	lp->rx_frame_id[3] = 0;
+	if (request_irq(dev->irq, &sb1000_interrupt, 0, "sb1000", dev)) {
+		return -EAGAIN;
+	}
+
+	if (sb1000_debug > 2)
+		printk(KERN_DEBUG "%s: Opening, IRQ %d\n", name, dev->irq);
+
+	/* Activate board and check firmware version */
+	udelay(1000);
+	if ((status = sb1000_activate(ioaddr, name)))
+		return status;
+	udelay(0);
+	if ((status = sb1000_get_firmware_version(ioaddr, name, version, 0)))
+		return status;
+	if (version[0] != FirmwareVersion[0] || version[1] != FirmwareVersion[1])
+		printk(KERN_WARNING "%s: found firmware version %x.%02x "
+			"(should be %x.%02x)\n", name, version[0], version[1],
+			FirmwareVersion[0], FirmwareVersion[1]);
+
+
+	netif_start_queue(dev);
+	return 0;					/* Always succeed */
+}
+
+static int sb1000_dev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	char* name;
+	unsigned char version[2];
+	short PID[4];
+	int ioaddr[2], status, frequency;
+	unsigned int stats[5];
+	struct sb1000_private *lp = netdev_priv(dev);
+
+	if (!(dev && dev->flags & IFF_UP))
+		return -ENODEV;
+
+	ioaddr[0] = dev->base_addr;
+	/* mem_start holds the second I/O address */
+	ioaddr[1] = dev->mem_start;
+	name = dev->name;
+
+	switch (cmd) {
+	case SIOCGCMSTATS:		/* get statistics */
+		stats[0] = lp->stats.rx_bytes;
+		stats[1] = lp->rx_frames;
+		stats[2] = lp->stats.rx_packets;
+		stats[3] = lp->stats.rx_errors;
+		stats[4] = lp->stats.rx_dropped;
+		if(copy_to_user(ifr->ifr_data, stats, sizeof(stats)))
+			return -EFAULT;
+		status = 0;
+		break;
+
+	case SIOCGCMFIRMWARE:		/* get firmware version */
+		if ((status = sb1000_get_firmware_version(ioaddr, name, version, 1)))
+			return status;
+		if(copy_to_user(ifr->ifr_data, version, sizeof(version)))
+			return -EFAULT;
+		break;
+
+	case SIOCGCMFREQUENCY:		/* get frequency */
+		if ((status = sb1000_get_frequency(ioaddr, name, &frequency)))
+			return status;
+		if(put_user(frequency, (int __user *) ifr->ifr_data))
+			return -EFAULT;
+		break;
+
+	case SIOCSCMFREQUENCY:		/* set frequency */
+		if (!capable(CAP_NET_ADMIN))
+			return -EPERM;
+		if(get_user(frequency, (int __user *) ifr->ifr_data))
+			return -EFAULT;
+		if ((status = sb1000_set_frequency(ioaddr, name, frequency)))
+			return status;
+		break;
+
+	case SIOCGCMPIDS:			/* get PIDs */
+		if ((status = sb1000_get_PIDs(ioaddr, name, PID)))
+			return status;
+		if(copy_to_user(ifr->ifr_data, PID, sizeof(PID)))
+			return -EFAULT;
+		break;
+
+	case SIOCSCMPIDS:			/* set PIDs */
+		if (!capable(CAP_NET_ADMIN))
+			return -EPERM;
+		if(copy_from_user(PID, ifr->ifr_data, sizeof(PID)))
+			return -EFAULT;
+		if ((status = sb1000_set_PIDs(ioaddr, name, PID)))
+			return status;
+		/* set session_id, frame_id and pkt_type too */
+		lp->rx_session_id[0] = 0x50 | (PID[0] & 0x0f);
+		lp->rx_session_id[1] = 0x48;
+		lp->rx_session_id[2] = 0x44;
+		lp->rx_session_id[3] = 0x42;
+		lp->rx_frame_id[0] = 0;
+		lp->rx_frame_id[1] = 0;
+		lp->rx_frame_id[2] = 0;
+		lp->rx_frame_id[3] = 0;
+		break;
+
+	default:
+		status = -EINVAL;
+		break;
+	}
+	return status;
+}
+
+/* transmit function: do nothing since SB1000 can't send anything out */
+static int
+sb1000_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	printk(KERN_WARNING "%s: trying to transmit!!!\n", dev->name);
+	/* sb1000 can't xmit datagrams */
+	dev_kfree_skb(skb);
+	return 0;
+}
+
+/* SB1000 interrupt handler. */
+static irqreturn_t sb1000_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	char *name;
+	unsigned char st;
+	int ioaddr[2];
+	struct net_device *dev = (struct net_device *) dev_id;
+	struct sb1000_private *lp = netdev_priv(dev);
+
+	const unsigned char Command0[6] = {0x80, 0x2c, 0x00, 0x00, 0x00, 0x00};
+	const unsigned char Command1[6] = {0x80, 0x2e, 0x00, 0x00, 0x00, 0x00};
+	const int MaxRxErrorCount = 6;
+
+	if (dev == NULL) {
+		printk(KERN_ERR "sb1000_interrupt(): irq %d for unknown device.\n",
+			irq);
+		return IRQ_NONE;
+	}
+
+	ioaddr[0] = dev->base_addr;
+	/* mem_start holds the second I/O address */
+	ioaddr[1] = dev->mem_start;
+	name = dev->name;
+
+	/* is it a good interrupt? */
+	st = inb(ioaddr[1] + 6);
+	if (!(st & 0x08 && st & 0x20)) {
+		return IRQ_NONE;
+	}
+
+	if (sb1000_debug > 3)
+		printk(KERN_DEBUG "%s: entering interrupt\n", dev->name);
+
+	st = inb(ioaddr[0] + 7);
+	if (sb1000_rx(dev))
+		lp->rx_error_count++;
+#ifdef SB1000_DELAY
+	udelay(SB1000_DELAY);
+#endif /* SB1000_DELAY */
+	sb1000_issue_read_command(ioaddr, name);
+	if (st & 0x01) {
+		sb1000_error_dpc(dev);
+		sb1000_issue_read_command(ioaddr, name);
+	}
+	if (lp->rx_error_dpc_count && !(--lp->rx_error_dpc_count)) {
+		sb1000_wait_for_ready_clear(ioaddr, name);
+		sb1000_send_command(ioaddr, name, Command0);
+		sb1000_wait_for_ready(ioaddr, name);
+		sb1000_issue_read_command(ioaddr, name);
+	}
+	if (lp->rx_error_count >= MaxRxErrorCount) {
+		sb1000_wait_for_ready_clear(ioaddr, name);
+		sb1000_send_command(ioaddr, name, Command1);
+		sb1000_wait_for_ready(ioaddr, name);
+		sb1000_issue_read_command(ioaddr, name);
+		lp->rx_error_count = 0;
+	}
+
+	return IRQ_HANDLED;
+}
+
+static struct net_device_stats *sb1000_stats(struct net_device *dev)
+{
+	struct sb1000_private *lp = netdev_priv(dev);
+	return &lp->stats;
+}
+
+static int sb1000_close(struct net_device *dev)
+{
+	int i;
+	int ioaddr[2];
+	struct sb1000_private *lp = netdev_priv(dev);
+
+	if (sb1000_debug > 2)
+		printk(KERN_DEBUG "%s: Shutting down sb1000.\n", dev->name);
+
+	netif_stop_queue(dev);
+	
+	ioaddr[0] = dev->base_addr;
+	/* mem_start holds the second I/O address */
+	ioaddr[1] = dev->mem_start;
+
+	free_irq(dev->irq, dev);
+	/* If we don't do this, we can't re-insmod it later. */
+	release_region(ioaddr[1], SB1000_IO_EXTENT);
+	release_region(ioaddr[0], SB1000_IO_EXTENT);
+
+	/* free rx_skb's if needed */
+	for (i=0; i<4; i++) {
+		if (lp->rx_skb[i]) {
+			dev_kfree_skb(lp->rx_skb[i]);
+		}
+	}
+	return 0;
+}
+
+MODULE_AUTHOR("Franco Venturi <fventuri@mediaone.net>");
+MODULE_DESCRIPTION("General Instruments SB1000 driver");
+MODULE_LICENSE("GPL");
+
+static int __init
+sb1000_init(void)
+{
+	return pnp_register_driver(&sb1000_driver);
+}
+
+static void __exit
+sb1000_exit(void)
+{
+	pnp_unregister_driver(&sb1000_driver);
+}
+
+module_init(sb1000_init);
+module_exit(sb1000_exit);
