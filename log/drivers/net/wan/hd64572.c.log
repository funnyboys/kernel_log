commit 25763b3c864cf517d686661012d184ee47a49b4c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 10:10:09 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 206
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of version 2 of the gnu general public license as
      published by the free software foundation
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 107 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528171438.615055994@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/wan/hd64572.c b/drivers/net/wan/hd64572.c
index cff0cfadd650..9f60e3969bf8 100644
--- a/drivers/net/wan/hd64572.c
+++ b/drivers/net/wan/hd64572.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Hitachi (now Renesas) SCA-II HD64572 driver for Linux
  *
  * Copyright (C) 1998-2008 Krzysztof Halasa <khc@pm.waw.pl>
  *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License
- * as published by the Free Software Foundation.
- *
  * Source of information: HD64572 SCA-II User's Manual
  *
  * We use the following SCA memory map:

commit 6ad20165d376fa07919a70e4f43dfae564601829
Author: Eric Dumazet <edumazet@google.com>
Date:   Mon Jan 30 08:22:01 2017 -0800

    drivers: net: generalize napi_complete_done()
    
    napi_complete_done() allows to opt-in for gro_flush_timeout,
    added back in linux-3.19, commit 3b47d30396ba
    ("net: gro: add a per device gro flush timer")
    
    This allows for more efficient GRO aggregation without
    sacrifying latencies.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wan/hd64572.c b/drivers/net/wan/hd64572.c
index 7ef49dab6855..cff0cfadd650 100644
--- a/drivers/net/wan/hd64572.c
+++ b/drivers/net/wan/hd64572.c
@@ -341,7 +341,7 @@ static int sca_poll(struct napi_struct *napi, int budget)
 		received = sca_rx_done(port, budget);
 
 	if (received < budget) {
-		napi_complete(napi);
+		napi_complete_done(napi, received);
 		enable_intr(port);
 	}
 

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/net/wan/hd64572.c b/drivers/net/wan/hd64572.c
index e92ecf1d3314..7ef49dab6855 100644
--- a/drivers/net/wan/hd64572.c
+++ b/drivers/net/wan/hd64572.c
@@ -39,7 +39,7 @@
 #include <linux/string.h>
 #include <linux/types.h>
 #include <asm/io.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include "hd64572.h"
 
 #define NAPI_WEIGHT		16

commit a81ab36bf52d0ca3a32251a923be1dbced726141
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Jan 8 15:32:47 2014 -0500

    drivers/net: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.   Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    This covers everything under drivers/net except for wireless, which
    has been submitted separately.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wan/hd64572.c b/drivers/net/wan/hd64572.c
index 6269a09c7369..e92ecf1d3314 100644
--- a/drivers/net/wan/hd64572.c
+++ b/drivers/net/wan/hd64572.c
@@ -29,7 +29,6 @@
 #include <linux/fcntl.h>
 #include <linux/hdlc.h>
 #include <linux/in.h>
-#include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/ioport.h>
 #include <linux/jiffies.h>

commit 1dd06ae8db716e17ec7e06244b858606edf378c0
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Dec 6 14:30:56 2012 +0000

    drivers/net: fix up function prototypes after __dev* removals
    
    The __dev* removal patches for the network drivers ended up messing up
    the function prototypes for a bunch of drivers.  This patch fixes all of
    them back up to be properly aligned.
    
    Bonus is that this almost removes 100 lines of code, always a nice
    surprise.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wan/hd64572.c b/drivers/net/wan/hd64572.c
index f1685d9624c8..6269a09c7369 100644
--- a/drivers/net/wan/hd64572.c
+++ b/drivers/net/wan/hd64572.c
@@ -605,8 +605,7 @@ static netdev_tx_t sca_xmit(struct sk_buff *skb, struct net_device *dev)
 }
 
 
-static u32 sca_detect_ram(card_t *card, u8 __iomem *rambase,
-				    u32 ramsize)
+static u32 sca_detect_ram(card_t *card, u8 __iomem *rambase, u32 ramsize)
 {
 	/* Round RAM size to 32 bits, fill from end to start */
 	u32 i = ramsize &= ~3;

commit aeea6bbfa3f185dcd6f812ece8bed778ec0da3be
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Dec 3 09:24:19 2012 -0500

    net/hdlc: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Krzysztof Halasa <khc@pm.waw.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/wan/hd64572.c b/drivers/net/wan/hd64572.c
index e2779faa6c4f..f1685d9624c8 100644
--- a/drivers/net/wan/hd64572.c
+++ b/drivers/net/wan/hd64572.c
@@ -605,7 +605,7 @@ static netdev_tx_t sca_xmit(struct sk_buff *skb, struct net_device *dev)
 }
 
 
-static u32 __devinit sca_detect_ram(card_t *card, u8 __iomem *rambase,
+static u32 sca_detect_ram(card_t *card, u8 __iomem *rambase,
 				    u32 ramsize)
 {
 	/* Round RAM size to 32 bits, fill from end to start */
@@ -625,7 +625,7 @@ static u32 __devinit sca_detect_ram(card_t *card, u8 __iomem *rambase,
 }
 
 
-static void __devinit sca_init(card_t *card, int wait_states)
+static void sca_init(card_t *card, int wait_states)
 {
 	sca_out(wait_states, WCRL, card); /* Wait Control */
 	sca_out(wait_states, WCRM, card);

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/net/wan/hd64572.c b/drivers/net/wan/hd64572.c
index efc0db101183..e2779faa6c4f 100644
--- a/drivers/net/wan/hd64572.c
+++ b/drivers/net/wan/hd64572.c
@@ -40,7 +40,6 @@
 #include <linux/string.h>
 #include <linux/types.h>
 #include <asm/io.h>
-#include <asm/system.h>
 #include <asm/uaccess.h>
 #include "hd64572.h"
 

commit 12a3bfefc8c1e43ddb50950cb74f8a11d680567a
Author: Joe Perches <joe@perches.com>
Date:   Sun Jun 26 19:01:28 2011 +0000

    generic_hdlc: Update to current logging forms
    
    Use pr_fmt, pr_<level> and netdev_<level> as appropriate.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wan/hd64572.c b/drivers/net/wan/hd64572.c
index e305274f83fb..efc0db101183 100644
--- a/drivers/net/wan/hd64572.c
+++ b/drivers/net/wan/hd64572.c
@@ -530,8 +530,8 @@ static void sca_dump_rings(struct net_device *dev)
 	       sca_in(DSR_RX(port->chan), card), port->rxin,
 	       sca_in(DSR_RX(port->chan), card) & DSR_DE ? "" : "in");
 	for (cnt = 0; cnt < port->card->rx_ring_buffers; cnt++)
-		printk(" %02X", readb(&(desc_address(port, cnt, 0)->stat)));
-	printk(KERN_CONT "\n");
+		pr_cont(" %02X", readb(&(desc_address(port, cnt, 0)->stat)));
+	pr_cont("\n");
 
 	printk(KERN_DEBUG "TX ring: CDA=%u EDA=%u DSR=%02X in=%u "
 	       "last=%u %sactive",
@@ -541,8 +541,8 @@ static void sca_dump_rings(struct net_device *dev)
 	       sca_in(DSR_TX(port->chan), card) & DSR_DE ? "" : "in");
 
 	for (cnt = 0; cnt < port->card->tx_ring_buffers; cnt++)
-		printk(" %02X", readb(&(desc_address(port, cnt, 1)->stat)));
-	printk("\n");
+		pr_cont(" %02X", readb(&(desc_address(port, cnt, 1)->stat)));
+	pr_cont("\n");
 
 	printk(KERN_DEBUG "MSCI: MD: %02x %02x %02x,"
 	       " ST: %02x %02x %02x %02x %02x, FST: %02x CST: %02x %02x\n",

commit eaff9453d3e2b63969af93e9d42a85e803060121
Author: Krzysztof Halasa <khc@pm.waw.pl>
Date:   Sun Dec 12 12:06:47 2010 +0000

    WAN: Fix a TX IRQ causing BUG() in PC300 and PCI200SYN drivers.
    
    We must not wake the TX queue without free TX descriptors.
    sca_xmit() expects at least one free descriptor and BUGs otherwise.
    
    Problem reported and fix tested by Bernie Innocenti and Ward Vandewege.
    
    Signed-off-by: Krzysztof Hałasa <khc@pm.waw.pl>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wan/hd64572.c b/drivers/net/wan/hd64572.c
index ea476cbd38b5..e305274f83fb 100644
--- a/drivers/net/wan/hd64572.c
+++ b/drivers/net/wan/hd64572.c
@@ -293,6 +293,7 @@ static inline void sca_tx_done(port_t *port)
 	struct net_device *dev = port->netdev;
 	card_t* card = port->card;
 	u8 stat;
+	unsigned count = 0;
 
 	spin_lock(&port->lock);
 
@@ -316,10 +317,12 @@ static inline void sca_tx_done(port_t *port)
 			dev->stats.tx_bytes += readw(&desc->len);
 		}
 		writeb(0, &desc->stat);	/* Free descriptor */
+		count++;
 		port->txlast = (port->txlast + 1) % card->tx_ring_buffers;
 	}
 
-	netif_wake_queue(dev);
+	if (count)
+		netif_wake_queue(dev);
 	spin_unlock(&port->lock);
 }
 

commit 1ae5dc342ac78d7a42965fd1f323815f6f5ef2c1
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Mon May 10 05:01:31 2010 -0700

    net: trans_start cleanups
    
    Now that core network takes care of trans_start updates, dont do it
    in drivers themselves, if possible. Drivers can avoid one cache miss
    (on dev->trans_start) in their start_xmit() handler.
    
    Exceptions are NETIF_F_LLTX drivers
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wan/hd64572.c b/drivers/net/wan/hd64572.c
index aad9ed45c254..ea476cbd38b5 100644
--- a/drivers/net/wan/hd64572.c
+++ b/drivers/net/wan/hd64572.c
@@ -585,7 +585,6 @@ static netdev_tx_t sca_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	writew(len, &desc->len);
 	writeb(ST_TX_EOM, &desc->stat);
-	dev->trans_start = jiffies;
 
 	port->txin = (port->txin + 1) % card->tx_ring_buffers;
 	sca_outl(desc_offset(port, port->txin, 1),

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/net/wan/hd64572.c b/drivers/net/wan/hd64572.c
index 84f01373e11f..aad9ed45c254 100644
--- a/drivers/net/wan/hd64572.c
+++ b/drivers/net/wan/hd64572.c
@@ -37,7 +37,6 @@
 #include <linux/module.h>
 #include <linux/netdevice.h>
 #include <linux/skbuff.h>
-#include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/types.h>
 #include <asm/io.h>

commit d71a674922e7519edb477ecb585e7d29d69c7aa7
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Mon Aug 31 19:50:47 2009 +0000

    wan: convert drivers to netdev_tx_t
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wan/hd64572.c b/drivers/net/wan/hd64572.c
index f099c34a3ae2..84f01373e11f 100644
--- a/drivers/net/wan/hd64572.c
+++ b/drivers/net/wan/hd64572.c
@@ -562,7 +562,7 @@ static void sca_dump_rings(struct net_device *dev)
 #endif /* DEBUG_RINGS */
 
 
-static int sca_xmit(struct sk_buff *skb, struct net_device *dev)
+static netdev_tx_t sca_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	port_t *port = dev_to_port(dev);
 	card_t *card = port->card;
@@ -601,7 +601,7 @@ static int sca_xmit(struct sk_buff *skb, struct net_device *dev)
 	spin_unlock_irq(&port->lock);
 
 	dev_kfree_skb(skb);
-	return 0;
+	return NETDEV_TX_OK;
 }
 
 

commit ad361c9884e809340f6daca80d56a9e9c871690a
Author: Joe Perches <joe@perches.com>
Date:   Mon Jul 6 13:05:40 2009 -0700

    Remove multiple KERN_ prefixes from printk formats
    
    Commit 5fd29d6ccbc98884569d6f3105aeca70858b3e0f ("printk: clean up
    handling of log-levels and newlines") changed printk semantics.  printk
    lines with multiple KERN_<level> prefixes are no longer emitted as
    before the patch.
    
    <level> is now included in the output on each additional use.
    
    Remove all uses of multiple KERN_<level>s in formats.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/net/wan/hd64572.c b/drivers/net/wan/hd64572.c
index 497b003d7239..f099c34a3ae2 100644
--- a/drivers/net/wan/hd64572.c
+++ b/drivers/net/wan/hd64572.c
@@ -529,8 +529,9 @@ static void sca_dump_rings(struct net_device *dev)
 	       sca_in(DSR_RX(port->chan), card) & DSR_DE ? "" : "in");
 	for (cnt = 0; cnt < port->card->rx_ring_buffers; cnt++)
 		printk(" %02X", readb(&(desc_address(port, cnt, 0)->stat)));
+	printk(KERN_CONT "\n");
 
-	printk("\n" KERN_DEBUG "TX ring: CDA=%u EDA=%u DSR=%02X in=%u "
+	printk(KERN_DEBUG "TX ring: CDA=%u EDA=%u DSR=%02X in=%u "
 	       "last=%u %sactive",
 	       sca_inl(get_dmac_tx(port) + CDAL, card),
 	       sca_inl(get_dmac_tx(port) + EDAL, card),

commit 288379f050284087578b77e04f040b57db3db3f8
Author: Ben Hutchings <bhutchings@solarflare.com>
Date:   Mon Jan 19 16:43:59 2009 -0800

    net: Remove redundant NAPI functions
    
    Following the removal of the unused struct net_device * parameter from
    the NAPI functions named *netif_rx_* in commit 908a7a1, they are
    exactly equivalent to the corresponding *napi_* functions and are
    therefore redundant.
    
    Signed-off-by: Ben Hutchings <bhutchings@solarflare.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wan/hd64572.c b/drivers/net/wan/hd64572.c
index 08b3536944fe..497b003d7239 100644
--- a/drivers/net/wan/hd64572.c
+++ b/drivers/net/wan/hd64572.c
@@ -341,7 +341,7 @@ static int sca_poll(struct napi_struct *napi, int budget)
 		received = sca_rx_done(port, budget);
 
 	if (received < budget) {
-		netif_rx_complete(napi);
+		napi_complete(napi);
 		enable_intr(port);
 	}
 
@@ -359,7 +359,7 @@ static irqreturn_t sca_intr(int irq, void *dev_id)
 		if (port && (isr0 & (i ? 0x08002200 : 0x00080022))) {
 			handled = 1;
 			disable_intr(port);
-			netif_rx_schedule(&port->napi);
+			napi_schedule(&port->napi);
 		}
 	}
 

commit 908a7a16b852ffd618a9127be8d62432182d81b4
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Mon Dec 22 20:43:12 2008 -0800

    net: Remove unused netdev arg from some NAPI interfaces.
    
    When the napi api was changed to separate its 1:1 binding to the net_device
    struct, the netif_rx_[prep|schedule|complete] api failed to remove the now
    vestigual net_device structure parameter.  This patch cleans up that api by
    properly removing it..
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wan/hd64572.c b/drivers/net/wan/hd64572.c
index 0bcc0b5f22d7..08b3536944fe 100644
--- a/drivers/net/wan/hd64572.c
+++ b/drivers/net/wan/hd64572.c
@@ -341,7 +341,7 @@ static int sca_poll(struct napi_struct *napi, int budget)
 		received = sca_rx_done(port, budget);
 
 	if (received < budget) {
-		netif_rx_complete(port->netdev, napi);
+		netif_rx_complete(napi);
 		enable_intr(port);
 	}
 
@@ -359,7 +359,7 @@ static irqreturn_t sca_intr(int irq, void *dev_id)
 		if (port && (isr0 & (i ? 0x08002200 : 0x00080022))) {
 			handled = 1;
 			disable_intr(port);
-			netif_rx_schedule(port->netdev, &port->napi);
+			netif_rx_schedule(&port->napi);
 		}
 	}
 

commit e1f024eb5d88e5b4f8e58e99c95082c342f70a1a
Author: Krzysztof Hałasa <khc@pm.waw.pl>
Date:   Fri Jul 11 00:13:09 2008 +0200

    WAN: Simplify sca_init_port() in HD64572 driver.
    
    Signed-off-by: Krzysztof Hałasa <khc@pm.waw.pl>

diff --git a/drivers/net/wan/hd64572.c b/drivers/net/wan/hd64572.c
index 1de3cb7371a7..0bcc0b5f22d7 100644
--- a/drivers/net/wan/hd64572.c
+++ b/drivers/net/wan/hd64572.c
@@ -131,6 +131,7 @@ static inline void sca_set_carrier(port_t *port)
 static void sca_init_port(port_t *port)
 {
 	card_t *card = port->card;
+	u16 dmac_rx = get_dmac_rx(port), dmac_tx = get_dmac_tx(port);
 	int transmit, i;
 
 	port->rxin = 0;
@@ -138,7 +139,6 @@ static void sca_init_port(port_t *port)
 	port->txlast = 0;
 
 	for (transmit = 0; transmit < 2; transmit++) {
-		u16 dmac = transmit ? get_dmac_tx(port) : get_dmac_rx(port);
 		u16 buffs = transmit ? card->tx_ring_buffers
 			: card->rx_ring_buffers;
 
@@ -152,42 +152,37 @@ static void sca_init_port(port_t *port)
 			writew(0, &desc->len);
 			writeb(0, &desc->stat);
 		}
-
-		/* DMA disable - to halt state */
-		sca_out(0, transmit ? DSR_TX(port->chan) :
-			DSR_RX(port->chan), card);
-		/* software ABORT - to initial state */
-		sca_out(DCR_ABORT, transmit ? DCR_TX(port->chan) :
-			DCR_RX(port->chan), card);
-
-		/* current desc addr */
-		sca_outl(desc_offset(port, 0, transmit), dmac + CDAL, card);
-		if (!transmit)
-			sca_outl(desc_offset(port, buffs - 1, transmit),
-				 dmac + EDAL, card);
-		else
-			sca_outl(desc_offset(port, 0, transmit), dmac + EDAL,
-				 card);
-
-		/* clear frame end interrupt counter */
-		sca_out(DCR_CLEAR_EOF, transmit ? DCR_TX(port->chan) :
-			DCR_RX(port->chan), card);
-
-		if (!transmit) { /* Receive */
-			/* set buffer length */
-			sca_outw(HDLC_MAX_MRU, dmac + BFLL, card);
-			/* Chain mode, Multi-frame */
-			sca_out(0x14, DMR_RX(port->chan), card);
-			sca_out(DIR_EOME, DIR_RX(port->chan), card);
-			/* DMA enable */
-			sca_out(DSR_DE, DSR_RX(port->chan), card);
-		} else {	/* Transmit */
-			/* Chain mode, Multi-frame */
-			sca_out(0x14, DMR_TX(port->chan), card);
-			/* enable underflow interrupts */
-			sca_out(DIR_EOME, DIR_TX(port->chan), card);
-		}
 	}
+
+	/* DMA disable - to halt state */
+	sca_out(0, DSR_RX(port->chan), card);
+	sca_out(0, DSR_TX(port->chan), card);
+
+	/* software ABORT - to initial state */
+	sca_out(DCR_ABORT, DCR_RX(port->chan), card);
+	sca_out(DCR_ABORT, DCR_TX(port->chan), card);
+
+	/* current desc addr */
+	sca_outl(desc_offset(port, 0, 0), dmac_rx + CDAL, card);
+	sca_outl(desc_offset(port, card->tx_ring_buffers - 1, 0),
+		 dmac_rx + EDAL, card);
+	sca_outl(desc_offset(port, 0, 1), dmac_tx + CDAL, card);
+	sca_outl(desc_offset(port, 0, 1), dmac_tx + EDAL, card);
+
+	/* clear frame end interrupt counter */
+	sca_out(DCR_CLEAR_EOF, DCR_RX(port->chan), card);
+	sca_out(DCR_CLEAR_EOF, DCR_TX(port->chan), card);
+
+	/* Receive */
+	sca_outw(HDLC_MAX_MRU, dmac_rx + BFLL, card); /* set buffer length */
+	sca_out(0x14, DMR_RX(port->chan), card); /* Chain mode, Multi-frame */
+	sca_out(DIR_EOME, DIR_RX(port->chan), card); /* enable interrupts */
+	sca_out(DSR_DE, DSR_RX(port->chan), card); /* DMA enable */
+
+	/* Transmit */
+	sca_out(0x14, DMR_TX(port->chan), card); /* Chain mode, Multi-frame */
+	sca_out(DIR_EOME, DIR_TX(port->chan), card); /* enable interrupts */
+
 	sca_set_carrier(port);
 	netif_napi_add(port->netdev, &port->napi, sca_poll, NAPI_WEIGHT);
 }

commit fcfe9ff3e2fb2b9606e2e375f34c157271b4555c
Author: Krzysztof Hałasa <khc@pm.waw.pl>
Date:   Thu Jul 10 00:30:51 2008 +0200

    WAN: Correct comments in hd6457[02].c
    
    Signed-off-by: Krzysztof Hałasa <khc@pm.waw.pl>

diff --git a/drivers/net/wan/hd64572.c b/drivers/net/wan/hd64572.c
index 6a6fe6a7c44b..1de3cb7371a7 100644
--- a/drivers/net/wan/hd64572.c
+++ b/drivers/net/wan/hd64572.c
@@ -90,7 +90,7 @@ static inline u16 desc_abs_number(port_t *port, u16 desc, int transmit)
 
 static inline u16 desc_offset(port_t *port, u16 desc, int transmit)
 {
-	/* Descriptor offset always fits in 16 bytes */
+	/* Descriptor offset always fits in 16 bits */
 	return desc_abs_number(port, desc, transmit) * sizeof(pkt_desc);
 }
 

commit 0b59cef885f7d451acad02f70c9712f1ef3638b1
Author: Krzysztof Hałasa <khc@pm.waw.pl>
Date:   Wed Jul 9 23:39:12 2008 +0200

    WAN: HD64572 drivers don't use next_desc() anymore.
    
    Signed-off-by: Krzysztof Hałasa <khc@pm.waw.pl>

diff --git a/drivers/net/wan/hd64572.c b/drivers/net/wan/hd64572.c
index c7eff0a66a8e..6a6fe6a7c44b 100644
--- a/drivers/net/wan/hd64572.c
+++ b/drivers/net/wan/hd64572.c
@@ -78,13 +78,6 @@ static inline void disable_intr(port_t *port)
 		 (port->chan ? 0x00FF00FF : 0xFF00FF00), IER0, port->card);
 }
 
-static inline u16 next_desc(port_t *port, u16 desc, int transmit)
-{
-	return (desc + 1) % (transmit ? port->card->tx_ring_buffers
-			     : port->card->rx_ring_buffers);
-}
-
-
 static inline u16 desc_abs_number(port_t *port, u16 desc, int transmit)
 {
 	u16 rx_buffs = port->card->rx_ring_buffers;
@@ -291,7 +284,7 @@ static inline int sca_rx_done(port_t *port, int budget)
 
 		/* Set new error descriptor address */
 		sca_outl(desc_off, dmac + EDAL, card);
-		port->rxin = next_desc(port, port->rxin, 0);
+		port->rxin = (port->rxin + 1) % card->rx_ring_buffers;
 	}
 
 	/* make sure RX DMA is enabled */
@@ -329,7 +322,7 @@ static inline void sca_tx_done(port_t *port)
 			dev->stats.tx_bytes += readw(&desc->len);
 		}
 		writeb(0, &desc->stat);	/* Free descriptor */
-		port->txlast = next_desc(port, port->txlast, 1);
+		port->txlast = (port->txlast + 1) % card->tx_ring_buffers;
 	}
 
 	netif_wake_queue(dev);
@@ -599,7 +592,7 @@ static int sca_xmit(struct sk_buff *skb, struct net_device *dev)
 	writeb(ST_TX_EOM, &desc->stat);
 	dev->trans_start = jiffies;
 
-	port->txin = next_desc(port, port->txin, 1);
+	port->txin = (port->txin + 1) % card->tx_ring_buffers;
 	sca_outl(desc_offset(port, port->txin, 1),
 		 get_dmac_tx(port) + EDAL, card);
 

commit 61e0a6a268947f7385282c6841f3e3d64b4c5cb9
Author: Krzysztof Hałasa <khc@pm.waw.pl>
Date:   Wed Jul 9 23:13:49 2008 +0200

    WAN: Simplify HD64572 drivers.
    
    Signed-off-by: Krzysztof Hałasa <khc@pm.waw.pl>

diff --git a/drivers/net/wan/hd64572.c b/drivers/net/wan/hd64572.c
index 46a99a668e41..c7eff0a66a8e 100644
--- a/drivers/net/wan/hd64572.c
+++ b/drivers/net/wan/hd64572.c
@@ -11,13 +11,13 @@
  *
  * We use the following SCA memory map:
  *
- * Packet buffer descriptor rings - starting from winbase or win0base:
+ * Packet buffer descriptor rings - starting from card->rambase:
  * rx_ring_buffers * sizeof(pkt_desc) = logical channel #0 RX ring
  * tx_ring_buffers * sizeof(pkt_desc) = logical channel #0 TX ring
  * rx_ring_buffers * sizeof(pkt_desc) = logical channel #1 RX ring (if used)
  * tx_ring_buffers * sizeof(pkt_desc) = logical channel #1 TX ring (if used)
  *
- * Packet data buffers - starting from winbase + buff_offset:
+ * Packet data buffers - starting from card->rambase + buff_offset:
  * rx_ring_buffers * HDLC_MAX_MRU     = logical channel #0 RX buffers
  * tx_ring_buffers * HDLC_MAX_MRU     = logical channel #0 TX buffers
  * rx_ring_buffers * HDLC_MAX_MRU     = logical channel #0 RX buffers (if used)
@@ -47,16 +47,18 @@
 
 #define NAPI_WEIGHT		16
 
-#define get_msci(port)	  (phy_node(port) ?   MSCI1_OFFSET :   MSCI0_OFFSET)
-#define get_dmac_rx(port) (phy_node(port) ? DMAC1RX_OFFSET : DMAC0RX_OFFSET)
-#define get_dmac_tx(port) (phy_node(port) ? DMAC1TX_OFFSET : DMAC0TX_OFFSET)
+#define get_msci(port)	  (port->chan ?   MSCI1_OFFSET :   MSCI0_OFFSET)
+#define get_dmac_rx(port) (port->chan ? DMAC1RX_OFFSET : DMAC0RX_OFFSET)
+#define get_dmac_tx(port) (port->chan ? DMAC1TX_OFFSET : DMAC0TX_OFFSET)
 
-static int sca_poll(struct napi_struct *napi, int budget);
+#define sca_in(reg, card)	     readb(card->scabase + (reg))
+#define sca_out(value, reg, card)    writeb(value, card->scabase + (reg))
+#define sca_inw(reg, card)	     readw(card->scabase + (reg))
+#define sca_outw(value, reg, card)   writew(value, card->scabase + (reg))
+#define sca_inl(reg, card)	     readl(card->scabase + (reg))
+#define sca_outl(value, reg, card)   writel(value, card->scabase + (reg))
 
-static inline struct net_device *port_to_dev(port_t *port)
-{
-	return port->dev;
-}
+static int sca_poll(struct napi_struct *napi, int budget);
 
 static inline port_t* dev_to_port(struct net_device *dev)
 {
@@ -67,30 +69,29 @@ static inline void enable_intr(port_t *port)
 {
 	/* enable DMIB and MSCI RXINTA interrupts */
 	sca_outl(sca_inl(IER0, port->card) |
-		 (phy_node(port) ? 0x08002200 : 0x00080022), IER0, port->card);
+		 (port->chan ? 0x08002200 : 0x00080022), IER0, port->card);
 }
 
 static inline void disable_intr(port_t *port)
 {
 	sca_outl(sca_inl(IER0, port->card) &
-		 (phy_node(port) ? 0x00FF00FF : 0xFF00FF00), IER0, port->card);
+		 (port->chan ? 0x00FF00FF : 0xFF00FF00), IER0, port->card);
 }
 
 static inline u16 next_desc(port_t *port, u16 desc, int transmit)
 {
-	return (desc + 1) % (transmit ? port_to_card(port)->tx_ring_buffers
-			     : port_to_card(port)->rx_ring_buffers);
+	return (desc + 1) % (transmit ? port->card->tx_ring_buffers
+			     : port->card->rx_ring_buffers);
 }
 
 
 static inline u16 desc_abs_number(port_t *port, u16 desc, int transmit)
 {
-	u16 rx_buffs = port_to_card(port)->rx_ring_buffers;
-	u16 tx_buffs = port_to_card(port)->tx_ring_buffers;
+	u16 rx_buffs = port->card->rx_ring_buffers;
+	u16 tx_buffs = port->card->tx_ring_buffers;
 
 	desc %= (transmit ? tx_buffs : rx_buffs); // called with "X + 1" etc.
-	return log_node(port) * (rx_buffs + tx_buffs) +
-		transmit * rx_buffs + desc;
+	return port->chan * (rx_buffs + tx_buffs) + transmit * rx_buffs + desc;
 }
 
 
@@ -104,39 +105,39 @@ static inline u16 desc_offset(port_t *port, u16 desc, int transmit)
 static inline pkt_desc __iomem *desc_address(port_t *port, u16 desc,
 					     int transmit)
 {
-	return (pkt_desc __iomem *)(winbase(port_to_card(port))
-				    + desc_offset(port, desc, transmit));
+	return (pkt_desc __iomem *)(port->card->rambase +
+				    desc_offset(port, desc, transmit));
 }
 
 
 static inline u32 buffer_offset(port_t *port, u16 desc, int transmit)
 {
-	return port_to_card(port)->buff_offset +
+	return port->card->buff_offset +
 		desc_abs_number(port, desc, transmit) * (u32)HDLC_MAX_MRU;
 }
 
 
 static inline void sca_set_carrier(port_t *port)
 {
-	if (!(sca_in(get_msci(port) + ST3, port_to_card(port)) & ST3_DCD)) {
+	if (!(sca_in(get_msci(port) + ST3, port->card) & ST3_DCD)) {
 #ifdef DEBUG_LINK
 		printk(KERN_DEBUG "%s: sca_set_carrier on\n",
-		       port_to_dev(port)->name);
+		       port->netdev.name);
 #endif
-		netif_carrier_on(port_to_dev(port));
+		netif_carrier_on(port->netdev);
 	} else {
 #ifdef DEBUG_LINK
 		printk(KERN_DEBUG "%s: sca_set_carrier off\n",
-		       port_to_dev(port)->name);
+		       port->netdev.name);
 #endif
-		netif_carrier_off(port_to_dev(port));
+		netif_carrier_off(port->netdev);
 	}
 }
 
 
 static void sca_init_port(port_t *port)
 {
-	card_t *card = port_to_card(port);
+	card_t *card = port->card;
 	int transmit, i;
 
 	port->rxin = 0;
@@ -160,11 +161,11 @@ static void sca_init_port(port_t *port)
 		}
 
 		/* DMA disable - to halt state */
-		sca_out(0, transmit ? DSR_TX(phy_node(port)) :
-			DSR_RX(phy_node(port)), card);
+		sca_out(0, transmit ? DSR_TX(port->chan) :
+			DSR_RX(port->chan), card);
 		/* software ABORT - to initial state */
-		sca_out(DCR_ABORT, transmit ? DCR_TX(phy_node(port)) :
-			DCR_RX(phy_node(port)), card);
+		sca_out(DCR_ABORT, transmit ? DCR_TX(port->chan) :
+			DCR_RX(port->chan), card);
 
 		/* current desc addr */
 		sca_outl(desc_offset(port, 0, transmit), dmac + CDAL, card);
@@ -176,26 +177,26 @@ static void sca_init_port(port_t *port)
 				 card);
 
 		/* clear frame end interrupt counter */
-		sca_out(DCR_CLEAR_EOF, transmit ? DCR_TX(phy_node(port)) :
-			DCR_RX(phy_node(port)), card);
+		sca_out(DCR_CLEAR_EOF, transmit ? DCR_TX(port->chan) :
+			DCR_RX(port->chan), card);
 
 		if (!transmit) { /* Receive */
 			/* set buffer length */
 			sca_outw(HDLC_MAX_MRU, dmac + BFLL, card);
 			/* Chain mode, Multi-frame */
-			sca_out(0x14, DMR_RX(phy_node(port)), card);
-			sca_out(DIR_EOME, DIR_RX(phy_node(port)), card);
+			sca_out(0x14, DMR_RX(port->chan), card);
+			sca_out(DIR_EOME, DIR_RX(port->chan), card);
 			/* DMA enable */
-			sca_out(DSR_DE, DSR_RX(phy_node(port)), card);
+			sca_out(DSR_DE, DSR_RX(port->chan), card);
 		} else {	/* Transmit */
 			/* Chain mode, Multi-frame */
-			sca_out(0x14, DMR_TX(phy_node(port)), card);
+			sca_out(0x14, DMR_TX(port->chan), card);
 			/* enable underflow interrupts */
-			sca_out(DIR_EOME, DIR_TX(phy_node(port)), card);
+			sca_out(DIR_EOME, DIR_TX(port->chan), card);
 		}
 	}
 	sca_set_carrier(port);
-	netif_napi_add(port_to_dev(port), &port->napi, sca_poll, NAPI_WEIGHT);
+	netif_napi_add(port->netdev, &port->napi, sca_poll, NAPI_WEIGHT);
 }
 
 
@@ -203,7 +204,7 @@ static void sca_init_port(port_t *port)
 static inline void sca_msci_intr(port_t *port)
 {
 	u16 msci = get_msci(port);
-	card_t* card = port_to_card(port);
+	card_t* card = port->card;
 
 	if (sca_in(msci + ST1, card) & ST1_CDCD) {
 		/* Reset MSCI CDCD status bit */
@@ -216,7 +217,7 @@ static inline void sca_msci_intr(port_t *port)
 static inline void sca_rx(card_t *card, port_t *port, pkt_desc __iomem *desc,
 			  u16 rxin)
 {
-	struct net_device *dev = port_to_dev(port);
+	struct net_device *dev = port->netdev;
 	struct sk_buff *skb;
 	u16 len;
 	u32 buff;
@@ -229,7 +230,7 @@ static inline void sca_rx(card_t *card, port_t *port, pkt_desc __iomem *desc,
 	}
 
 	buff = buffer_offset(port, rxin, 0);
-	memcpy_fromio(skb->data, winbase(card) + buff, len);
+	memcpy_fromio(skb->data, card->rambase + buff, len);
 
 	skb_put(skb, len);
 #ifdef DEBUG_PKT
@@ -246,15 +247,15 @@ static inline void sca_rx(card_t *card, port_t *port, pkt_desc __iomem *desc,
 /* Receive DMA service */
 static inline int sca_rx_done(port_t *port, int budget)
 {
-	struct net_device *dev = port_to_dev(port);
+	struct net_device *dev = port->netdev;
 	u16 dmac = get_dmac_rx(port);
-	card_t *card = port_to_card(port);
-	u8 stat = sca_in(DSR_RX(phy_node(port)), card); /* read DMA Status */
+	card_t *card = port->card;
+	u8 stat = sca_in(DSR_RX(port->chan), card); /* read DMA Status */
 	int received = 0;
 
 	/* Reset DSR status bits */
 	sca_out((stat & (DSR_EOT | DSR_EOM | DSR_BOF | DSR_COF)) | DSR_DWE,
-		DSR_RX(phy_node(port)), card);
+		DSR_RX(port->chan), card);
 
 	if (stat & DSR_BOF)
 		/* Dropped one or more frames */
@@ -294,7 +295,7 @@ static inline int sca_rx_done(port_t *port, int budget)
 	}
 
 	/* make sure RX DMA is enabled */
-	sca_out(DSR_DE, DSR_RX(phy_node(port)), card);
+	sca_out(DSR_DE, DSR_RX(port->chan), card);
 	return received;
 }
 
@@ -302,17 +303,17 @@ static inline int sca_rx_done(port_t *port, int budget)
 /* Transmit DMA service */
 static inline void sca_tx_done(port_t *port)
 {
-	struct net_device *dev = port_to_dev(port);
-	card_t* card = port_to_card(port);
+	struct net_device *dev = port->netdev;
+	card_t* card = port->card;
 	u8 stat;
 
 	spin_lock(&port->lock);
 
-	stat = sca_in(DSR_TX(phy_node(port)), card); /* read DMA Status */
+	stat = sca_in(DSR_TX(port->chan), card); /* read DMA Status */
 
 	/* Reset DSR status bits */
 	sca_out((stat & (DSR_EOT | DSR_EOM | DSR_BOF | DSR_COF)) | DSR_DWE,
-		DSR_TX(phy_node(port)), card);
+		DSR_TX(port->chan), card);
 
 	while (1) {
 		pkt_desc __iomem *desc = desc_address(port, port->txlast, 1);
@@ -342,17 +343,17 @@ static int sca_poll(struct napi_struct *napi, int budget)
 	u32 isr0 = sca_inl(ISR0, port->card);
 	int received = 0;
 
-	if (isr0 & (port->phy_node ? 0x08000000 : 0x00080000))
+	if (isr0 & (port->chan ? 0x08000000 : 0x00080000))
 		sca_msci_intr(port);
 
-	if (isr0 & (port->phy_node ? 0x00002000 : 0x00000020))
+	if (isr0 & (port->chan ? 0x00002000 : 0x00000020))
 		sca_tx_done(port);
 
-	if (isr0 & (port->phy_node ? 0x00000200 : 0x00000002))
+	if (isr0 & (port->chan ? 0x00000200 : 0x00000002))
 		received = sca_rx_done(port, budget);
 
 	if (received < budget) {
-		netif_rx_complete(port->dev, napi);
+		netif_rx_complete(port->netdev, napi);
 		enable_intr(port);
 	}
 
@@ -370,7 +371,7 @@ static irqreturn_t sca_intr(int irq, void *dev_id)
 		if (port && (isr0 & (i ? 0x08002200 : 0x00080022))) {
 			handled = 1;
 			disable_intr(port);
-			netif_rx_schedule(port->dev, &port->napi);
+			netif_rx_schedule(port->netdev, &port->napi);
 		}
 	}
 
@@ -380,7 +381,7 @@ static irqreturn_t sca_intr(int irq, void *dev_id)
 
 static void sca_set_port(port_t *port)
 {
-	card_t* card = port_to_card(port);
+	card_t* card = port->card;
 	u16 msci = get_msci(port);
 	u8 md2 = sca_in(msci + MD2, card);
 	unsigned int tmc, br = 10, brv = 1024;
@@ -435,7 +436,7 @@ static void sca_set_port(port_t *port)
 static void sca_open(struct net_device *dev)
 {
 	port_t *port = dev_to_port(dev);
-	card_t* card = port_to_card(port);
+	card_t* card = port->card;
 	u16 msci = get_msci(port);
 	u8 md0, md2;
 
@@ -496,7 +497,7 @@ static void sca_close(struct net_device *dev)
 	port_t *port = dev_to_port(dev);
 
 	/* reset channel */
-	sca_out(CMD_RESET, get_msci(port) + CMD, port_to_card(port));
+	sca_out(CMD_RESET, get_msci(port) + CMD, port->card);
 	disable_intr(port);
 	napi_disable(&port->napi);
 	netif_stop_queue(dev);
@@ -530,25 +531,25 @@ static int sca_attach(struct net_device *dev, unsigned short encoding,
 static void sca_dump_rings(struct net_device *dev)
 {
 	port_t *port = dev_to_port(dev);
-	card_t *card = port_to_card(port);
+	card_t *card = port->card;
 	u16 cnt;
 
 	printk(KERN_DEBUG "RX ring: CDA=%u EDA=%u DSR=%02X in=%u %sactive",
 	       sca_inl(get_dmac_rx(port) + CDAL, card),
 	       sca_inl(get_dmac_rx(port) + EDAL, card),
-	       sca_in(DSR_RX(phy_node(port)), card), port->rxin,
-	       sca_in(DSR_RX(phy_node(port)), card) & DSR_DE ? "" : "in");
-	for (cnt = 0; cnt < port_to_card(port)->rx_ring_buffers; cnt++)
+	       sca_in(DSR_RX(port->chan), card), port->rxin,
+	       sca_in(DSR_RX(port->chan), card) & DSR_DE ? "" : "in");
+	for (cnt = 0; cnt < port->card->rx_ring_buffers; cnt++)
 		printk(" %02X", readb(&(desc_address(port, cnt, 0)->stat)));
 
 	printk("\n" KERN_DEBUG "TX ring: CDA=%u EDA=%u DSR=%02X in=%u "
 	       "last=%u %sactive",
 	       sca_inl(get_dmac_tx(port) + CDAL, card),
 	       sca_inl(get_dmac_tx(port) + EDAL, card),
-	       sca_in(DSR_TX(phy_node(port)), card), port->txin, port->txlast,
-	       sca_in(DSR_TX(phy_node(port)), card) & DSR_DE ? "" : "in");
+	       sca_in(DSR_TX(port->chan), card), port->txin, port->txlast,
+	       sca_in(DSR_TX(port->chan), card) & DSR_DE ? "" : "in");
 
-	for (cnt = 0; cnt < port_to_card(port)->tx_ring_buffers; cnt++)
+	for (cnt = 0; cnt < port->card->tx_ring_buffers; cnt++)
 		printk(" %02X", readb(&(desc_address(port, cnt, 1)->stat)));
 	printk("\n");
 
@@ -575,7 +576,7 @@ static void sca_dump_rings(struct net_device *dev)
 static int sca_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	port_t *port = dev_to_port(dev);
-	card_t *card = port_to_card(port);
+	card_t *card = port->card;
 	pkt_desc __iomem *desc;
 	u32 buff, len;
 
@@ -592,7 +593,7 @@ static int sca_xmit(struct sk_buff *skb, struct net_device *dev)
 	desc = desc_address(port, port->txin, 1);
 	buff = buffer_offset(port, port->txin, 1);
 	len = skb->len;
-	memcpy_toio(winbase(card) + buff, skb->data, len);
+	memcpy_toio(card->rambase + buff, skb->data, len);
 
 	writew(len, &desc->len);
 	writeb(ST_TX_EOM, &desc->stat);
@@ -602,7 +603,7 @@ static int sca_xmit(struct sk_buff *skb, struct net_device *dev)
 	sca_outl(desc_offset(port, port->txin, 1),
 		 get_dmac_tx(port) + EDAL, card);
 
-	sca_out(DSR_DE, DSR_TX(phy_node(port)), card); /* Enable TX DMA */
+	sca_out(DSR_DE, DSR_TX(port->chan), card); /* Enable TX DMA */
 
 	desc = desc_address(port, port->txin + 1, 1);
 	if (readb(&desc->stat)) /* allow 1 packet gap */

commit 0954ed826921bcf11352e05a58d598c493e6bdfb
Author: Krzysztof Hałasa <khc@pm.waw.pl>
Date:   Wed Jul 9 21:24:42 2008 +0200

    WAN: Simplify HD64572 status handling.
    
    Signed-off-by: Krzysztof Hałasa <khc@pm.waw.pl>

diff --git a/drivers/net/wan/hd64572.c b/drivers/net/wan/hd64572.c
index 0952e228c2c3..46a99a668e41 100644
--- a/drivers/net/wan/hd64572.c
+++ b/drivers/net/wan/hd64572.c
@@ -51,10 +51,6 @@
 #define get_dmac_rx(port) (phy_node(port) ? DMAC1RX_OFFSET : DMAC0RX_OFFSET)
 #define get_dmac_tx(port) (phy_node(port) ? DMAC1TX_OFFSET : DMAC0TX_OFFSET)
 
-#define SCA_INTR_MSCI(node)    (node ? 0x10 : 0x01)
-#define SCA_INTR_DMAC_RX(node) (node ? 0x20 : 0x02)
-#define SCA_INTR_DMAC_TX(node) (node ? 0x40 : 0x04)
-
 static int sca_poll(struct napi_struct *napi, int budget);
 
 static inline struct net_device *port_to_dev(port_t *port)
@@ -62,21 +58,6 @@ static inline struct net_device *port_to_dev(port_t *port)
 	return port->dev;
 }
 
-static inline int sca_intr_status(card_t *card)
-{
-	u8 result = 0;
-	u32 isr0 = sca_inl(ISR0, card);
-
-	if (isr0 & 0x00000002) result |= SCA_INTR_DMAC_RX(0);
-	if (isr0 & 0x00000020) result |= SCA_INTR_DMAC_TX(0);
-	if (isr0 & 0x00000200) result |= SCA_INTR_DMAC_RX(1);
-	if (isr0 & 0x00002000) result |= SCA_INTR_DMAC_TX(1);
-	if (isr0 & 0x00080000) result |= SCA_INTR_MSCI(0);
-	if (isr0 & 0x08000000) result |= SCA_INTR_MSCI(1);
-
-	return result;
-}
-
 static inline port_t* dev_to_port(struct net_device *dev)
 {
 	return dev_to_hdlc(dev)->priv;
@@ -358,16 +339,16 @@ static inline void sca_tx_done(port_t *port)
 static int sca_poll(struct napi_struct *napi, int budget)
 {
 	port_t *port = container_of(napi, port_t, napi);
-	u8 stat = sca_intr_status(port->card);
+	u32 isr0 = sca_inl(ISR0, port->card);
 	int received = 0;
 
-	if (stat & SCA_INTR_MSCI(port->phy_node))
+	if (isr0 & (port->phy_node ? 0x08000000 : 0x00080000))
 		sca_msci_intr(port);
 
-	if (stat & SCA_INTR_DMAC_TX(port->phy_node))
+	if (isr0 & (port->phy_node ? 0x00002000 : 0x00000020))
 		sca_tx_done(port);
 
-	if (stat & SCA_INTR_DMAC_RX(port->phy_node))
+	if (isr0 & (port->phy_node ? 0x00000200 : 0x00000002))
 		received = sca_rx_done(port, budget);
 
 	if (received < budget) {
@@ -378,17 +359,15 @@ static int sca_poll(struct napi_struct *napi, int budget)
 	return received;
 }
 
-static irqreturn_t sca_intr(int irq, void* dev_id)
+static irqreturn_t sca_intr(int irq, void *dev_id)
 {
 	card_t *card = dev_id;
-	int i;
-	u8 stat = sca_intr_status(card);
-	int handled = 0;
+	u32 isr0 = sca_inl(ISR0, card);
+	int i, handled = 0;
 
 	for (i = 0; i < 2; i++) {
 		port_t *port = get_port(card, i);
-		if (port && (stat & (SCA_INTR_MSCI(i) | SCA_INTR_DMAC_RX(i) |
-				     SCA_INTR_DMAC_TX(i)))) {
+		if (port && (isr0 & (i ? 0x08002200 : 0x00080022))) {
 			handled = 1;
 			disable_intr(port);
 			netif_rx_schedule(port->dev, &port->napi);

commit 0446c3b1e6208c6563ff9a0b22fb3b5e5e3e775c
Author: Krzysztof Hałasa <khc@pm.waw.pl>
Date:   Wed Jul 9 19:28:45 2008 +0200

    WAN: rework HD64572 interrupts a bit.
    Signed-off-by: Krzysztof Hałasa <khc@pm.waw.pl>

diff --git a/drivers/net/wan/hd64572.c b/drivers/net/wan/hd64572.c
index bdb625080a16..0952e228c2c3 100644
--- a/drivers/net/wan/hd64572.c
+++ b/drivers/net/wan/hd64572.c
@@ -67,19 +67,12 @@ static inline int sca_intr_status(card_t *card)
 	u8 result = 0;
 	u32 isr0 = sca_inl(ISR0, card);
 
-	if (isr0 & 0x0000000F) result |= SCA_INTR_DMAC_RX(0);
-	if (isr0 & 0x000000F0) result |= SCA_INTR_DMAC_TX(0);
-	if (isr0 & 0x00000F00) result |= SCA_INTR_DMAC_RX(1);
-	if (isr0 & 0x0000F000) result |= SCA_INTR_DMAC_TX(1);
-	if (isr0 & 0x003E0000) result |= SCA_INTR_MSCI(0);
-	if (isr0 & 0x3E000000) result |= SCA_INTR_MSCI(1);
-
-	if (!(result & SCA_INTR_DMAC_TX(0)))
-		if (sca_in(DSR_TX(0), card) & DSR_EOM)
-			result |= SCA_INTR_DMAC_TX(0);
-	if (!(result & SCA_INTR_DMAC_TX(1)))
-		if (sca_in(DSR_TX(1), card) & DSR_EOM)
-			result |= SCA_INTR_DMAC_TX(1);
+	if (isr0 & 0x00000002) result |= SCA_INTR_DMAC_RX(0);
+	if (isr0 & 0x00000020) result |= SCA_INTR_DMAC_TX(0);
+	if (isr0 & 0x00000200) result |= SCA_INTR_DMAC_RX(1);
+	if (isr0 & 0x00002000) result |= SCA_INTR_DMAC_TX(1);
+	if (isr0 & 0x00080000) result |= SCA_INTR_MSCI(0);
+	if (isr0 & 0x08000000) result |= SCA_INTR_MSCI(1);
 
 	return result;
 }
@@ -91,10 +84,9 @@ static inline port_t* dev_to_port(struct net_device *dev)
 
 static inline void enable_intr(port_t *port)
 {
-	/* DMA & MSCI IRQ enable */
-	/* IR0_TXINT | IR0_RXINTA | IR0_DMIB* | IR0_DMIA* */
+	/* enable DMIB and MSCI RXINTA interrupts */
 	sca_outl(sca_inl(IER0, port->card) |
-		 (phy_node(port) ? 0x0A006600 : 0x000A0066), IER0, port->card);
+		 (phy_node(port) ? 0x08002200 : 0x00080022), IER0, port->card);
 }
 
 static inline void disable_intr(port_t *port)
@@ -211,15 +203,14 @@ static void sca_init_port(port_t *port)
 			sca_outw(HDLC_MAX_MRU, dmac + BFLL, card);
 			/* Chain mode, Multi-frame */
 			sca_out(0x14, DMR_RX(phy_node(port)), card);
-			sca_out(DIR_EOME | DIR_BOFE, DIR_RX(phy_node(port)),
-				card);
+			sca_out(DIR_EOME, DIR_RX(phy_node(port)), card);
 			/* DMA enable */
 			sca_out(DSR_DE, DSR_RX(phy_node(port)), card);
 		} else {	/* Transmit */
 			/* Chain mode, Multi-frame */
 			sca_out(0x14, DMR_TX(phy_node(port)), card);
 			/* enable underflow interrupts */
-			sca_out(DIR_BOFE, DIR_TX(phy_node(port)), card);
+			sca_out(DIR_EOME, DIR_TX(phy_node(port)), card);
 		}
 	}
 	sca_set_carrier(port);
@@ -502,11 +493,10 @@ static void sca_open(struct net_device *dev)
 	sca_out(0x3F, msci + TNR1, card); /* +1=TX DMA deactivation condition*/
 
 /* We're using the following interrupts:
-   - TXINT (DMAC completed all transmissions and DCD changes)
-   - all DMA interrupts
+   - RXINTA (DCD changes only)
+   - DMIB (EOM - single frame transfer complete)
 */
-	/* MSCI TXINT and RXINTA interrupt enable */
-	sca_outl(IE0_TXINT | IE0_RXINTA | IE0_CDCD, msci + IE0, card);
+	sca_outl(IE0_RXINTA | IE0_CDCD, msci + IE0, card);
 
 	sca_out(port->tmc, msci + TMCR, card);
 	sca_out(port->tmc, msci + TMCT, card);

commit b0942f78dd6493c5590cc80fedd5e3b357a15334
Author: Krzysztof Hałasa <khc@pm.waw.pl>
Date:   Wed Jul 9 20:01:23 2008 +0200

    WAN: HD64572 already handles TX underruns with DMAC.
    
    Signed-off-by: Krzysztof Hałasa <khc@pm.waw.pl>

diff --git a/drivers/net/wan/hd64572.c b/drivers/net/wan/hd64572.c
index e332fe906aba..bdb625080a16 100644
--- a/drivers/net/wan/hd64572.c
+++ b/drivers/net/wan/hd64572.c
@@ -232,19 +232,12 @@ static inline void sca_msci_intr(port_t *port)
 {
 	u16 msci = get_msci(port);
 	card_t* card = port_to_card(port);
-	u8 stat = sca_in(msci + ST1, card); /* read MSCI ST1 status */
 
-	/* Reset MSCI TX underrun and CDCD status bit */
-	sca_out(stat & (ST1_UDRN | ST1_CDCD), msci + ST1, card);
-
-	if (stat & ST1_UDRN) {
-		/* TX Underrun error detected */
-		port_to_dev(port)->stats.tx_errors++;
-		port_to_dev(port)->stats.tx_fifo_errors++;
-	}
-
-	if (stat & ST1_CDCD)
+	if (sca_in(msci + ST1, card) & ST1_CDCD) {
+		/* Reset MSCI CDCD status bit */
+		sca_out(ST1_CDCD, msci + ST1, card);
 		sca_set_carrier(port);
+	}
 }
 
 
@@ -351,11 +344,17 @@ static inline void sca_tx_done(port_t *port)
 
 	while (1) {
 		pkt_desc __iomem *desc = desc_address(port, port->txlast, 1);
+		u8 stat = readb(&desc->stat);
 
-		if (!(readb(&desc->stat) & ST_TX_OWNRSHP))
+		if (!(stat & ST_TX_OWNRSHP))
 			break; /* not yet transmitted */
-		dev->stats.tx_packets++;
-		dev->stats.tx_bytes += readw(&desc->len);
+		if (stat & ST_TX_UNDRRUN) {
+			dev->stats.tx_errors++;
+			dev->stats.tx_fifo_errors++;
+		} else {
+			dev->stats.tx_packets++;
+			dev->stats.tx_bytes += readw(&desc->len);
+		}
 		writeb(0, &desc->stat);	/* Free descriptor */
 		port->txlast = next_desc(port, port->txlast, 1);
 	}
@@ -503,12 +502,11 @@ static void sca_open(struct net_device *dev)
 	sca_out(0x3F, msci + TNR1, card); /* +1=TX DMA deactivation condition*/
 
 /* We're using the following interrupts:
-   - TXINT (DMAC completed all transmissions, underrun or DCD change)
+   - TXINT (DMAC completed all transmissions and DCD changes)
    - all DMA interrupts
 */
 	/* MSCI TXINT and RXINTA interrupt enable */
-	sca_outl(IE0_TXINT | IE0_RXINTA | IE0_UDRN | IE0_CDCD, msci + IE0,
-		 card);
+	sca_outl(IE0_TXINT | IE0_RXINTA | IE0_CDCD, msci + IE0, card);
 
 	sca_out(port->tmc, msci + TMCR, card);
 	sca_out(port->tmc, msci + TMCT, card);

commit 09fd65aa8ac934ea4ce7e55945a687292731e9c9
Author: Krzysztof Hałasa <khc@pm.waw.pl>
Date:   Wed Jul 9 19:47:05 2008 +0200

    WAN: TX-done handler now uses the ownership bit in HD64572 drivers.
    
    Signed-off-by: Krzysztof Hałasa <khc@pm.waw.pl>

diff --git a/drivers/net/wan/hd64572.c b/drivers/net/wan/hd64572.c
index 22adec06d93a..e332fe906aba 100644
--- a/drivers/net/wan/hd64572.c
+++ b/drivers/net/wan/hd64572.c
@@ -338,7 +338,6 @@ static inline int sca_rx_done(port_t *port, int budget)
 static inline void sca_tx_done(port_t *port)
 {
 	struct net_device *dev = port_to_dev(port);
-	u16 dmac = get_dmac_tx(port);
 	card_t* card = port_to_card(port);
 	u8 stat;
 
@@ -351,14 +350,10 @@ static inline void sca_tx_done(port_t *port)
 		DSR_TX(phy_node(port)), card);
 
 	while (1) {
-		pkt_desc __iomem *desc;
-
-		u32 desc_off = desc_offset(port, port->txlast, 1);
-		u32 cda = sca_inl(dmac + CDAL, card);
-		if ((cda >= desc_off) && (cda < desc_off + sizeof(pkt_desc)))
-			break;	/* Transmitter is/will_be sending this frame */
+		pkt_desc __iomem *desc = desc_address(port, port->txlast, 1);
 
-		desc = desc_address(port, port->txlast, 1);
+		if (!(readb(&desc->stat) & ST_TX_OWNRSHP))
+			break; /* not yet transmitted */
 		dev->stats.tx_packets++;
 		dev->stats.tx_bytes += readw(&desc->len);
 		writeb(0, &desc->stat);	/* Free descriptor */

commit abc9d91a35a924c8db0e949cd443471672e37cdb
Author: Krzysztof Hałasa <khc@pm.waw.pl>
Date:   Wed Jul 9 16:49:37 2008 +0200

    WAN: convert HD64572-based drivers to NAPI.
    
    Signed-off-by: Krzysztof Hałasa <khc@pm.waw.pl>

diff --git a/drivers/net/wan/hd64572.c b/drivers/net/wan/hd64572.c
index aa82e8f9d333..22adec06d93a 100644
--- a/drivers/net/wan/hd64572.c
+++ b/drivers/net/wan/hd64572.c
@@ -1,7 +1,7 @@
 /*
  * Hitachi (now Renesas) SCA-II HD64572 driver for Linux
  *
- * Copyright (C) 1998-2003 Krzysztof Halasa <khc@pm.waw.pl>
+ * Copyright (C) 1998-2008 Krzysztof Halasa <khc@pm.waw.pl>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License
@@ -45,6 +45,8 @@
 #include <asm/uaccess.h>
 #include "hd64572.h"
 
+#define NAPI_WEIGHT		16
+
 #define get_msci(port)	  (phy_node(port) ?   MSCI1_OFFSET :   MSCI0_OFFSET)
 #define get_dmac_rx(port) (phy_node(port) ? DMAC1RX_OFFSET : DMAC0RX_OFFSET)
 #define get_dmac_tx(port) (phy_node(port) ? DMAC1TX_OFFSET : DMAC0TX_OFFSET)
@@ -53,6 +55,7 @@
 #define SCA_INTR_DMAC_RX(node) (node ? 0x20 : 0x02)
 #define SCA_INTR_DMAC_TX(node) (node ? 0x40 : 0x04)
 
+static int sca_poll(struct napi_struct *napi, int budget);
 
 static inline struct net_device *port_to_dev(port_t *port)
 {
@@ -86,6 +89,20 @@ static inline port_t* dev_to_port(struct net_device *dev)
 	return dev_to_hdlc(dev)->priv;
 }
 
+static inline void enable_intr(port_t *port)
+{
+	/* DMA & MSCI IRQ enable */
+	/* IR0_TXINT | IR0_RXINTA | IR0_DMIB* | IR0_DMIA* */
+	sca_outl(sca_inl(IER0, port->card) |
+		 (phy_node(port) ? 0x0A006600 : 0x000A0066), IER0, port->card);
+}
+
+static inline void disable_intr(port_t *port)
+{
+	sca_outl(sca_inl(IER0, port->card) &
+		 (phy_node(port) ? 0x00FF00FF : 0xFF00FF00), IER0, port->card);
+}
+
 static inline u16 next_desc(port_t *port, u16 desc, int transmit)
 {
 	return (desc + 1) % (transmit ? port_to_card(port)->tx_ring_buffers
@@ -206,6 +223,7 @@ static void sca_init_port(port_t *port)
 		}
 	}
 	sca_set_carrier(port);
+	netif_napi_add(port_to_dev(port), &port->napi, sca_poll, NAPI_WEIGHT);
 }
 
 
@@ -256,17 +274,18 @@ static inline void sca_rx(card_t *card, port_t *port, pkt_desc __iomem *desc,
 	dev->stats.rx_packets++;
 	dev->stats.rx_bytes += skb->len;
 	skb->protocol = hdlc_type_trans(skb, dev);
-	netif_rx(skb);
+	netif_receive_skb(skb);
 }
 
 
-/* Receive DMA interrupt service */
-static inline void sca_rx_intr(port_t *port)
+/* Receive DMA service */
+static inline int sca_rx_done(port_t *port, int budget)
 {
 	struct net_device *dev = port_to_dev(port);
 	u16 dmac = get_dmac_rx(port);
 	card_t *card = port_to_card(port);
 	u8 stat = sca_in(DSR_RX(phy_node(port)), card); /* read DMA Status */
+	int received = 0;
 
 	/* Reset DSR status bits */
 	sca_out((stat & (DSR_EOT | DSR_EOM | DSR_BOF | DSR_COF)) | DSR_DWE,
@@ -276,7 +295,7 @@ static inline void sca_rx_intr(port_t *port)
 		/* Dropped one or more frames */
 		dev->stats.rx_over_errors++;
 
-	while (1) {
+	while (received < budget) {
 		u32 desc_off = desc_offset(port, port->rxin, 0);
 		pkt_desc __iomem *desc;
 		u32 cda = sca_inl(dmac + CDAL, card);
@@ -299,8 +318,10 @@ static inline void sca_rx_intr(port_t *port)
 				dev->stats.rx_crc_errors++;
 			if (stat & ST_RX_EOM)
 				port->rxpart = 0; /* received last fragment */
-		} else
+		} else {
 			sca_rx(card, port, desc, port->rxin);
+			received++;
+		}
 
 		/* Set new error descriptor address */
 		sca_outl(desc_off, dmac + EDAL, card);
@@ -309,11 +330,12 @@ static inline void sca_rx_intr(port_t *port)
 
 	/* make sure RX DMA is enabled */
 	sca_out(DSR_DE, DSR_RX(phy_node(port)), card);
+	return received;
 }
 
 
-/* Transmit DMA interrupt service */
-static inline void sca_tx_intr(port_t *port)
+/* Transmit DMA service */
+static inline void sca_tx_done(port_t *port)
 {
 	struct net_device *dev = port_to_dev(port);
 	u16 dmac = get_dmac_tx(port);
@@ -348,27 +370,43 @@ static inline void sca_tx_intr(port_t *port)
 }
 
 
+static int sca_poll(struct napi_struct *napi, int budget)
+{
+	port_t *port = container_of(napi, port_t, napi);
+	u8 stat = sca_intr_status(port->card);
+	int received = 0;
+
+	if (stat & SCA_INTR_MSCI(port->phy_node))
+		sca_msci_intr(port);
+
+	if (stat & SCA_INTR_DMAC_TX(port->phy_node))
+		sca_tx_done(port);
+
+	if (stat & SCA_INTR_DMAC_RX(port->phy_node))
+		received = sca_rx_done(port, budget);
+
+	if (received < budget) {
+		netif_rx_complete(port->dev, napi);
+		enable_intr(port);
+	}
+
+	return received;
+}
+
 static irqreturn_t sca_intr(int irq, void* dev_id)
 {
 	card_t *card = dev_id;
 	int i;
-	u8 stat;
+	u8 stat = sca_intr_status(card);
 	int handled = 0;
 
-	while((stat = sca_intr_status(card)) != 0) {
-		handled = 1;
-		for (i = 0; i < 2; i++) {
-			port_t *port = get_port(card, i);
-			if (port) {
-				if (stat & SCA_INTR_MSCI(i))
-					sca_msci_intr(port);
-
-				if (stat & SCA_INTR_DMAC_RX(i))
-					sca_rx_intr(port);
-
-				if (stat & SCA_INTR_DMAC_TX(i))
-					sca_tx_intr(port);
-			}
+	for (i = 0; i < 2; i++) {
+		port_t *port = get_port(card, i);
+		if (port && (stat & (SCA_INTR_MSCI(i) | SCA_INTR_DMAC_RX(i) |
+				     SCA_INTR_DMAC_TX(i)))) {
+			handled = 1;
+			disable_intr(port);
+			netif_rx_schedule(port->dev, &port->napi);
 		}
 	}
 
@@ -470,18 +508,12 @@ static void sca_open(struct net_device *dev)
 	sca_out(0x3F, msci + TNR1, card); /* +1=TX DMA deactivation condition*/
 
 /* We're using the following interrupts:
-   - TXINT (DMAC completed all transmisions, underrun or DCD change)
+   - TXINT (DMAC completed all transmissions, underrun or DCD change)
    - all DMA interrupts
 */
-
-	sca_set_carrier(port);
-
 	/* MSCI TXINT and RXINTA interrupt enable */
 	sca_outl(IE0_TXINT | IE0_RXINTA | IE0_UDRN | IE0_CDCD, msci + IE0,
 		 card);
-	/* DMA & MSCI IRQ enable */
-	sca_outl(sca_inl(IER0, card) |
-		 (phy_node(port) ? 0x0A006600 : 0x000A0066), IER0, card);
 
 	sca_out(port->tmc, msci + TMCR, card);
 	sca_out(port->tmc, msci + TMCT, card);
@@ -490,6 +522,9 @@ static void sca_open(struct net_device *dev)
 	sca_out(CMD_TX_ENABLE, msci + CMD, card);
 	sca_out(CMD_RX_ENABLE, msci + CMD, card);
 
+	sca_set_carrier(port);
+	enable_intr(port);
+	napi_enable(&port->napi);
 	netif_start_queue(dev);
 }
 
@@ -497,14 +532,11 @@ static void sca_open(struct net_device *dev)
 static void sca_close(struct net_device *dev)
 {
 	port_t *port = dev_to_port(dev);
-	card_t* card = port_to_card(port);
 
 	/* reset channel */
 	sca_out(CMD_RESET, get_msci(port) + CMD, port_to_card(port));
-	/* disable DMA & MSCI IRQ */
-	sca_outl(sca_inl(IER0, card) &
-		 (phy_node(port) ? 0x00FF00FF : 0xFF00FF00), IER0, card);
-
+	disable_intr(port);
+	napi_disable(&port->napi);
 	netif_stop_queue(dev);
 }
 

commit 302243922b374b147380f61774b44612eb2040fd
Author: Krzysztof Hałasa <khc@pm.waw.pl>
Date:   Mon Mar 24 20:24:23 2008 +0100

    WAN: remove SCA support from SCA-II drivers
    
    Signed-off-by: Krzysztof Hałasa <khc@pm.waw.pl>

diff --git a/drivers/net/wan/hd64572.c b/drivers/net/wan/hd64572.c
index 434583a94b32..aa82e8f9d333 100644
--- a/drivers/net/wan/hd64572.c
+++ b/drivers/net/wan/hd64572.c
@@ -1,5 +1,5 @@
 /*
- * Hitachi SCA HD64570 and HD64572 common driver for Linux
+ * Hitachi (now Renesas) SCA-II HD64572 driver for Linux
  *
  * Copyright (C) 1998-2003 Krzysztof Halasa <khc@pm.waw.pl>
  *
@@ -7,9 +7,7 @@
  * under the terms of version 2 of the GNU General Public License
  * as published by the Free Software Foundation.
  *
- * Sources of information:
- *    Hitachi HD64570 SCA User's Manual
- *    Hitachi HD64572 SCA-II User's Manual
+ * Source of information: HD64572 SCA-II User's Manual
  *
  * We use the following SCA memory map:
  *
@@ -26,33 +24,26 @@
  * tx_ring_buffers * HDLC_MAX_MRU     = logical channel #0 TX buffers (if used)
  */
 
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/jiffies.h>
-#include <linux/types.h>
+#include <linux/bitops.h>
+#include <linux/errno.h>
 #include <linux/fcntl.h>
-#include <linux/interrupt.h>
+#include <linux/hdlc.h>
 #include <linux/in.h>
-#include <linux/string.h>
-#include <linux/errno.h>
 #include <linux/init.h>
+#include <linux/interrupt.h>
 #include <linux/ioport.h>
-#include <linux/bitops.h>
-
-#include <asm/system.h>
-#include <asm/uaccess.h>
-#include <asm/io.h>
-
+#include <linux/jiffies.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/netdevice.h>
 #include <linux/skbuff.h>
-
-#include <linux/hdlc.h>
-
-#if (!defined (__HD64570_H) && !defined (__HD64572_H)) || \
-    (defined (__HD64570_H) && defined (__HD64572_H))
-#error Either hd64570.h or hd64572.h must be included
-#endif
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+#include "hd64572.h"
 
 #define get_msci(port)	  (phy_node(port) ?   MSCI1_OFFSET :   MSCI0_OFFSET)
 #define get_dmac_rx(port) (phy_node(port) ? DMAC1RX_OFFSET : DMAC0RX_OFFSET)
@@ -62,16 +53,6 @@
 #define SCA_INTR_DMAC_RX(node) (node ? 0x20 : 0x02)
 #define SCA_INTR_DMAC_TX(node) (node ? 0x40 : 0x04)
 
-#ifdef __HD64570_H /* HD64570 */
-#define sca_outa(value, reg, card)	sca_outw(value, reg, card)
-#define sca_ina(reg, card)		sca_inw(reg, card)
-#define writea(value, ptr)		writew(value, ptr)
-
-#else /* HD64572 */
-#define sca_outa(value, reg, card)	sca_outl(value, reg, card)
-#define sca_ina(reg, card)		sca_inl(reg, card)
-#define writea(value, ptr)		writel(value, ptr)
-#endif
 
 static inline struct net_device *port_to_dev(port_t *port)
 {
@@ -81,19 +62,6 @@ static inline struct net_device *port_to_dev(port_t *port)
 static inline int sca_intr_status(card_t *card)
 {
 	u8 result = 0;
-
-#ifdef __HD64570_H /* HD64570 */
-	u8 isr0 = sca_in(ISR0, card);
-	u8 isr1 = sca_in(ISR1, card);
-
-	if (isr1 & 0x03) result |= SCA_INTR_DMAC_RX(0);
-	if (isr1 & 0x0C) result |= SCA_INTR_DMAC_TX(0);
-	if (isr1 & 0x30) result |= SCA_INTR_DMAC_RX(1);
-	if (isr1 & 0xC0) result |= SCA_INTR_DMAC_TX(1);
-	if (isr0 & 0x0F) result |= SCA_INTR_MSCI(0);
-	if (isr0 & 0xF0) result |= SCA_INTR_MSCI(1);
-
-#else /* HD64572 */
 	u32 isr0 = sca_inl(ISR0, card);
 
 	if (isr0 & 0x0000000F) result |= SCA_INTR_DMAC_RX(0);
@@ -103,8 +71,6 @@ static inline int sca_intr_status(card_t *card)
 	if (isr0 & 0x003E0000) result |= SCA_INTR_MSCI(0);
 	if (isr0 & 0x3E000000) result |= SCA_INTR_MSCI(1);
 
-#endif /* HD64570 vs HD64572 */
-
 	if (!(result & SCA_INTR_DMAC_TX(0)))
 		if (sca_in(DSR_TX(0), card) & DSR_EOM)
 			result |= SCA_INTR_DMAC_TX(0);
@@ -127,7 +93,6 @@ static inline u16 next_desc(port_t *port, u16 desc, int transmit)
 }
 
 
-
 static inline u16 desc_abs_number(port_t *port, u16 desc, int transmit)
 {
 	u16 rx_buffs = port_to_card(port)->rx_ring_buffers;
@@ -139,7 +104,6 @@ static inline u16 desc_abs_number(port_t *port, u16 desc, int transmit)
 }
 
 
-
 static inline u16 desc_offset(port_t *port, u16 desc, int transmit)
 {
 	/* Descriptor offset always fits in 16 bytes */
@@ -147,20 +111,14 @@ static inline u16 desc_offset(port_t *port, u16 desc, int transmit)
 }
 
 
-
-static inline pkt_desc __iomem *desc_address(port_t *port, u16 desc, int transmit)
+static inline pkt_desc __iomem *desc_address(port_t *port, u16 desc,
+					     int transmit)
 {
-#ifdef PAGE0_ALWAYS_MAPPED
-	return (pkt_desc __iomem *)(win0base(port_to_card(port))
-			   + desc_offset(port, desc, transmit));
-#else
 	return (pkt_desc __iomem *)(winbase(port_to_card(port))
-			   + desc_offset(port, desc, transmit));
-#endif
+				    + desc_offset(port, desc, transmit));
 }
 
 
-
 static inline u32 buffer_offset(port_t *port, u16 desc, int transmit)
 {
 	return port_to_card(port)->buff_offset +
@@ -186,7 +144,7 @@ static inline void sca_set_carrier(port_t *port)
 }
 
 
-static void sca_init_sync_port(port_t *port)
+static void sca_init_port(port_t *port)
 {
 	card_t *card = port_to_card(port);
 	int transmit, i;
@@ -195,10 +153,6 @@ static void sca_init_sync_port(port_t *port)
 	port->txin = 0;
 	port->txlast = 0;
 
-#if !defined(PAGE0_ALWAYS_MAPPED) && !defined(ALL_PAGES_ALWAYS_MAPPED)
-	openwin(card, 0);
-#endif
-
 	for (transmit = 0; transmit < 2; transmit++) {
 		u16 dmac = transmit ? get_dmac_tx(port) : get_dmac_rx(port);
 		u16 buffs = transmit ? card->tx_ring_buffers
@@ -209,7 +163,7 @@ static void sca_init_sync_port(port_t *port)
 			u16 chain_off = desc_offset(port, i + 1, transmit);
 			u32 buff_off = buffer_offset(port, i, transmit);
 
-			writea(chain_off, &desc->cp);
+			writel(chain_off, &desc->cp);
 			writel(buff_off, &desc->bp);
 			writew(0, &desc->len);
 			writeb(0, &desc->stat);
@@ -222,16 +176,13 @@ static void sca_init_sync_port(port_t *port)
 		sca_out(DCR_ABORT, transmit ? DCR_TX(phy_node(port)) :
 			DCR_RX(phy_node(port)), card);
 
-#ifdef __HD64570_H
-		sca_out(0, dmac + CPB, card); /* pointer base */
-#endif
 		/* current desc addr */
-		sca_outa(desc_offset(port, 0, transmit), dmac + CDAL, card);
+		sca_outl(desc_offset(port, 0, transmit), dmac + CDAL, card);
 		if (!transmit)
-			sca_outa(desc_offset(port, buffs - 1, transmit),
+			sca_outl(desc_offset(port, buffs - 1, transmit),
 				 dmac + EDAL, card);
 		else
-			sca_outa(desc_offset(port, 0, transmit), dmac + EDAL,
+			sca_outl(desc_offset(port, 0, transmit), dmac + EDAL,
 				 card);
 
 		/* clear frame end interrupt counter */
@@ -258,8 +209,6 @@ static void sca_init_sync_port(port_t *port)
 }
 
 
-
-#ifdef NEED_SCA_MSCI_INTR
 /* MSCI interrupt service */
 static inline void sca_msci_intr(port_t *port)
 {
@@ -279,20 +228,15 @@ static inline void sca_msci_intr(port_t *port)
 	if (stat & ST1_CDCD)
 		sca_set_carrier(port);
 }
-#endif
-
 
 
-static inline void sca_rx(card_t *card, port_t *port, pkt_desc __iomem *desc, u16 rxin)
+static inline void sca_rx(card_t *card, port_t *port, pkt_desc __iomem *desc,
+			  u16 rxin)
 {
 	struct net_device *dev = port_to_dev(port);
 	struct sk_buff *skb;
 	u16 len;
 	u32 buff;
-#ifndef ALL_PAGES_ALWAYS_MAPPED
-	u32 maxlen;
-	u8 page;
-#endif
 
 	len = readw(&desc->len);
 	skb = dev_alloc_skb(len);
@@ -302,25 +246,8 @@ static inline void sca_rx(card_t *card, port_t *port, pkt_desc __iomem *desc, u1
 	}
 
 	buff = buffer_offset(port, rxin, 0);
-#ifndef ALL_PAGES_ALWAYS_MAPPED
-	page = buff / winsize(card);
-	buff = buff % winsize(card);
-	maxlen = winsize(card) - buff;
-
-	openwin(card, page);
-
-	if (len > maxlen) {
-		memcpy_fromio(skb->data, winbase(card) + buff, maxlen);
-		openwin(card, page + 1);
-		memcpy_fromio(skb->data + maxlen, winbase(card), len - maxlen);
-	} else
-#endif
 	memcpy_fromio(skb->data, winbase(card) + buff, len);
 
-#if !defined(PAGE0_ALWAYS_MAPPED) && !defined(ALL_PAGES_ALWAYS_MAPPED)
-	/* select pkt_desc table page back */
-	openwin(card, 0);
-#endif
 	skb_put(skb, len);
 #ifdef DEBUG_PKT
 	printk(KERN_DEBUG "%s RX(%i):", dev->name, skb->len);
@@ -333,7 +260,6 @@ static inline void sca_rx(card_t *card, port_t *port, pkt_desc __iomem *desc, u1
 }
 
 
-
 /* Receive DMA interrupt service */
 static inline void sca_rx_intr(port_t *port)
 {
@@ -353,7 +279,7 @@ static inline void sca_rx_intr(port_t *port)
 	while (1) {
 		u32 desc_off = desc_offset(port, port->rxin, 0);
 		pkt_desc __iomem *desc;
-		u32 cda = sca_ina(dmac + CDAL, card);
+		u32 cda = sca_inl(dmac + CDAL, card);
 
 		if ((cda >= desc_off) && (cda < desc_off + sizeof(pkt_desc)))
 			break;	/* No frame received */
@@ -377,7 +303,7 @@ static inline void sca_rx_intr(port_t *port)
 			sca_rx(card, port, desc, port->rxin);
 
 		/* Set new error descriptor address */
-		sca_outa(desc_off, dmac + EDAL, card);
+		sca_outl(desc_off, dmac + EDAL, card);
 		port->rxin = next_desc(port, port->rxin, 0);
 	}
 
@@ -386,7 +312,6 @@ static inline void sca_rx_intr(port_t *port)
 }
 
 
-
 /* Transmit DMA interrupt service */
 static inline void sca_tx_intr(port_t *port)
 {
@@ -407,7 +332,7 @@ static inline void sca_tx_intr(port_t *port)
 		pkt_desc __iomem *desc;
 
 		u32 desc_off = desc_offset(port, port->txlast, 1);
-		u32 cda = sca_ina(dmac + CDAL, card);
+		u32 cda = sca_inl(dmac + CDAL, card);
 		if ((cda >= desc_off) && (cda < desc_off + sizeof(pkt_desc)))
 			break;	/* Transmitter is/will_be sending this frame */
 
@@ -423,7 +348,6 @@ static inline void sca_tx_intr(port_t *port)
 }
 
 
-
 static irqreturn_t sca_intr(int irq, void* dev_id)
 {
 	card_t *card = dev_id;
@@ -431,10 +355,6 @@ static irqreturn_t sca_intr(int irq, void* dev_id)
 	u8 stat;
 	int handled = 0;
 
-#ifndef ALL_PAGES_ALWAYS_MAPPED
-	u8 page = sca_get_page(card);
-#endif
-
 	while((stat = sca_intr_status(card)) != 0) {
 		handled = 1;
 		for (i = 0; i < 2; i++) {
@@ -452,14 +372,10 @@ static irqreturn_t sca_intr(int irq, void* dev_id)
 		}
 	}
 
-#ifndef ALL_PAGES_ALWAYS_MAPPED
-	openwin(card, page);		/* Restore original page */
-#endif
 	return IRQ_RETVAL(handled);
 }
 
 
-
 static void sca_set_port(port_t *port)
 {
 	card_t* card = port_to_card(port);
@@ -497,12 +413,8 @@ static void sca_set_port(port_t *port)
 	port->tmc = tmc;
 
 	/* baud divisor - time constant*/
-#ifdef __HD64570_H
-	sca_out(port->tmc, msci + TMC, card);
-#else
 	sca_out(port->tmc, msci + TMCR, card);
 	sca_out(port->tmc, msci + TMCT, card);
-#endif
 
 	/* Set BRG bits */
 	sca_out(port->rxs, msci + RXS, card);
@@ -518,7 +430,6 @@ static void sca_set_port(port_t *port)
 }
 
 
-
 static void sca_open(struct net_device *dev)
 {
 	port_t *port = dev_to_port(dev);
@@ -540,11 +451,7 @@ static void sca_open(struct net_device *dev)
 	switch(port->parity) {
 	case PARITY_CRC16_PR0:	     md0 = MD0_HDLC | MD0_CRC_16_0;  break;
 	case PARITY_CRC16_PR1:	     md0 = MD0_HDLC | MD0_CRC_16;    break;
-#ifdef __HD64570_H
-	case PARITY_CRC16_PR0_CCITT: md0 = MD0_HDLC | MD0_CRC_ITU_0; break;
-#else
 	case PARITY_CRC32_PR1_CCITT: md0 = MD0_HDLC | MD0_CRC_ITU32; break;
-#endif
 	case PARITY_CRC16_PR1_CCITT: md0 = MD0_HDLC | MD0_CRC_ITU;   break;
 	default:		     md0 = MD0_HDLC | MD0_CRC_NONE;
 	}
@@ -554,26 +461,13 @@ static void sca_open(struct net_device *dev)
 	sca_out(0x00, msci + MD1, card); /* no address field check */
 	sca_out(md2, msci + MD2, card);
 	sca_out(0x7E, msci + IDL, card); /* flag character 0x7E */
-#ifdef __HD64570_H
-	sca_out(CTL_IDLE, msci + CTL, card);
-#else
 	/* Skip the rest of underrun frame */
 	sca_out(CTL_IDLE | CTL_URCT | CTL_URSKP, msci + CTL, card);
-#endif
-
-#ifdef __HD64570_H
-	/* Allow at least 8 bytes before requesting RX DMA operation */
-	/* TX with higher priority and possibly with shorter transfers */
-	sca_out(0x07, msci + RRC, card); /* +1=RXRDY/DMA activation condition*/
-	sca_out(0x10, msci + TRC0, card); /* = TXRDY/DMA activation condition*/
-	sca_out(0x14, msci + TRC1, card); /* +1=TXRDY/DMA deactiv condition */
-#else
 	sca_out(0x0F, msci + RNR, card); /* +1=RX DMA activation condition */
 	sca_out(0x3C, msci + TFS, card); /* +1 = TX start */
 	sca_out(0x38, msci + TCR, card); /* =Critical TX DMA activ condition */
 	sca_out(0x38, msci + TNR0, card); /* =TX DMA activation condition */
 	sca_out(0x3F, msci + TNR1, card); /* +1=TX DMA deactivation condition*/
-#endif
 
 /* We're using the following interrupts:
    - TXINT (DMAC completed all transmisions, underrun or DCD change)
@@ -582,30 +476,15 @@ static void sca_open(struct net_device *dev)
 
 	sca_set_carrier(port);
 
-#ifdef __HD64570_H
-	/* MSCI TX INT and RX INT A IRQ enable */
-	sca_out(IE0_TXINT | IE0_RXINTA, msci + IE0, card);
-	sca_out(IE1_UDRN | IE1_CDCD, msci + IE1, card);
-	sca_out(sca_in(IER0, card) | (phy_node(port) ? 0xC0 : 0x0C),
-		IER0, card); /* TXINT and RXINT */
-	/* enable DMA IRQ */
-	sca_out(sca_in(IER1, card) | (phy_node(port) ? 0xF0 : 0x0F),
-		IER1, card);
-#else
 	/* MSCI TXINT and RXINTA interrupt enable */
 	sca_outl(IE0_TXINT | IE0_RXINTA | IE0_UDRN | IE0_CDCD, msci + IE0,
 		 card);
 	/* DMA & MSCI IRQ enable */
 	sca_outl(sca_inl(IER0, card) |
 		 (phy_node(port) ? 0x0A006600 : 0x000A0066), IER0, card);
-#endif
 
-#ifdef __HD64570_H
-	sca_out(port->tmc, msci + TMC, card); /* Restore registers */
-#else
 	sca_out(port->tmc, msci + TMCR, card);
 	sca_out(port->tmc, msci + TMCT, card);
-#endif
 	sca_out(port->rxs, msci + RXS, card);
 	sca_out(port->txs, msci + TXS, card);
 	sca_out(CMD_TX_ENABLE, msci + CMD, card);
@@ -615,7 +494,6 @@ static void sca_open(struct net_device *dev)
 }
 
 
-
 static void sca_close(struct net_device *dev)
 {
 	port_t *port = dev_to_port(dev);
@@ -623,23 +501,14 @@ static void sca_close(struct net_device *dev)
 
 	/* reset channel */
 	sca_out(CMD_RESET, get_msci(port) + CMD, port_to_card(port));
-#ifdef __HD64570_H
-	/* disable MSCI interrupts */
-	sca_out(sca_in(IER0, card) & (phy_node(port) ? 0x0F : 0xF0),
-		IER0, card);
-	/* disable DMA interrupts */
-	sca_out(sca_in(IER1, card) & (phy_node(port) ? 0x0F : 0xF0),
-		IER1, card);
-#else
 	/* disable DMA & MSCI IRQ */
 	sca_outl(sca_inl(IER0, card) &
 		 (phy_node(port) ? 0x00FF00FF : 0xFF00FF00), IER0, card);
-#endif
+
 	netif_stop_queue(dev);
 }
 
 
-
 static int sca_attach(struct net_device *dev, unsigned short encoding,
 		      unsigned short parity)
 {
@@ -653,11 +522,7 @@ static int sca_attach(struct net_device *dev, unsigned short encoding,
 	if (parity != PARITY_NONE &&
 	    parity != PARITY_CRC16_PR0 &&
 	    parity != PARITY_CRC16_PR1 &&
-#ifdef __HD64570_H
-	    parity != PARITY_CRC16_PR0_CCITT &&
-#else
 	    parity != PARITY_CRC32_PR1_CCITT &&
-#endif
 	    parity != PARITY_CRC16_PR1_CCITT)
 		return -EINVAL;
 
@@ -667,34 +532,25 @@ static int sca_attach(struct net_device *dev, unsigned short encoding,
 }
 
 
-
 #ifdef DEBUG_RINGS
 static void sca_dump_rings(struct net_device *dev)
 {
 	port_t *port = dev_to_port(dev);
 	card_t *card = port_to_card(port);
 	u16 cnt;
-#if !defined(PAGE0_ALWAYS_MAPPED) && !defined(ALL_PAGES_ALWAYS_MAPPED)
-	u8 page;
-#endif
-
-#if !defined(PAGE0_ALWAYS_MAPPED) && !defined(ALL_PAGES_ALWAYS_MAPPED)
-	page = sca_get_page(card);
-	openwin(card, 0);
-#endif
 
 	printk(KERN_DEBUG "RX ring: CDA=%u EDA=%u DSR=%02X in=%u %sactive",
-	       sca_ina(get_dmac_rx(port) + CDAL, card),
-	       sca_ina(get_dmac_rx(port) + EDAL, card),
+	       sca_inl(get_dmac_rx(port) + CDAL, card),
+	       sca_inl(get_dmac_rx(port) + EDAL, card),
 	       sca_in(DSR_RX(phy_node(port)), card), port->rxin,
-	       sca_in(DSR_RX(phy_node(port)), card) & DSR_DE?"":"in");
+	       sca_in(DSR_RX(phy_node(port)), card) & DSR_DE ? "" : "in");
 	for (cnt = 0; cnt < port_to_card(port)->rx_ring_buffers; cnt++)
 		printk(" %02X", readb(&(desc_address(port, cnt, 0)->stat)));
 
 	printk("\n" KERN_DEBUG "TX ring: CDA=%u EDA=%u DSR=%02X in=%u "
 	       "last=%u %sactive",
-	       sca_ina(get_dmac_tx(port) + CDAL, card),
-	       sca_ina(get_dmac_tx(port) + EDAL, card),
+	       sca_inl(get_dmac_tx(port) + CDAL, card),
+	       sca_inl(get_dmac_tx(port) + EDAL, card),
 	       sca_in(DSR_TX(phy_node(port)), card), port->txin, port->txlast,
 	       sca_in(DSR_TX(phy_node(port)), card) & DSR_DE ? "" : "in");
 
@@ -702,12 +558,8 @@ static void sca_dump_rings(struct net_device *dev)
 		printk(" %02X", readb(&(desc_address(port, cnt, 1)->stat)));
 	printk("\n");
 
-	printk(KERN_DEBUG "MSCI: MD: %02x %02x %02x, "
-	       "ST: %02x %02x %02x %02x"
-#ifdef __HD64572_H
-	       " %02x"
-#endif
-	       ", FST: %02x CST: %02x %02x\n",
+	printk(KERN_DEBUG "MSCI: MD: %02x %02x %02x,"
+	       " ST: %02x %02x %02x %02x %02x, FST: %02x CST: %02x %02x\n",
 	       sca_in(get_msci(port) + MD0, card),
 	       sca_in(get_msci(port) + MD1, card),
 	       sca_in(get_msci(port) + MD2, card),
@@ -715,52 +567,28 @@ static void sca_dump_rings(struct net_device *dev)
 	       sca_in(get_msci(port) + ST1, card),
 	       sca_in(get_msci(port) + ST2, card),
 	       sca_in(get_msci(port) + ST3, card),
-#ifdef __HD64572_H
 	       sca_in(get_msci(port) + ST4, card),
-#endif
 	       sca_in(get_msci(port) + FST, card),
 	       sca_in(get_msci(port) + CST0, card),
 	       sca_in(get_msci(port) + CST1, card));
 
-#ifdef __HD64572_H
 	printk(KERN_DEBUG "ILAR: %02x ISR: %08x %08x\n", sca_in(ILAR, card),
 	       sca_inl(ISR0, card), sca_inl(ISR1, card));
-#else
-	printk(KERN_DEBUG "ISR: %02x %02x %02x\n", sca_in(ISR0, card),
-	       sca_in(ISR1, card), sca_in(ISR2, card));
-#endif
-
-#if !defined(PAGE0_ALWAYS_MAPPED) && !defined(ALL_PAGES_ALWAYS_MAPPED)
-	openwin(card, page); /* Restore original page */
-#endif
 }
 #endif /* DEBUG_RINGS */
 
 
-
 static int sca_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	port_t *port = dev_to_port(dev);
 	card_t *card = port_to_card(port);
 	pkt_desc __iomem *desc;
 	u32 buff, len;
-#ifndef ALL_PAGES_ALWAYS_MAPPED
-	u8 page;
-	u32 maxlen;
-#endif
 
 	spin_lock_irq(&port->lock);
 
 	desc = desc_address(port, port->txin + 1, 1);
-	if (readb(&desc->stat)) { /* allow 1 packet gap */
-		/* should never happen - previous xmit should stop queue */
-#ifdef DEBUG_PKT
-		printk(KERN_DEBUG "%s: transmitter buffer full\n", dev->name);
-#endif
-		netif_stop_queue(dev);
-		spin_unlock_irq(&port->lock);
-		return 1;	/* request packet to be queued */
-	}
+	BUG_ON(readb(&desc->stat)); /* previous xmit should stop queue */
 
 #ifdef DEBUG_PKT
 	printk(KERN_DEBUG "%s TX(%i):", dev->name, skb->len);
@@ -770,30 +598,14 @@ static int sca_xmit(struct sk_buff *skb, struct net_device *dev)
 	desc = desc_address(port, port->txin, 1);
 	buff = buffer_offset(port, port->txin, 1);
 	len = skb->len;
-#ifndef ALL_PAGES_ALWAYS_MAPPED
-	page = buff / winsize(card);
-	buff = buff % winsize(card);
-	maxlen = winsize(card) - buff;
-
-	openwin(card, page);
-	if (len > maxlen) {
-		memcpy_toio(winbase(card) + buff, skb->data, maxlen);
-		openwin(card, page + 1);
-		memcpy_toio(winbase(card), skb->data + maxlen, len - maxlen);
-	}
-	else
-#endif
-		memcpy_toio(winbase(card) + buff, skb->data, len);
+	memcpy_toio(winbase(card) + buff, skb->data, len);
 
-#if !defined(PAGE0_ALWAYS_MAPPED) && !defined(ALL_PAGES_ALWAYS_MAPPED)
-	openwin(card, 0);	/* select pkt_desc table page back */
-#endif
 	writew(len, &desc->len);
 	writeb(ST_TX_EOM, &desc->stat);
 	dev->trans_start = jiffies;
 
 	port->txin = next_desc(port, port->txin, 1);
-	sca_outa(desc_offset(port, port->txin, 1),
+	sca_outl(desc_offset(port, port->txin, 1),
 		 get_dmac_tx(port) + EDAL, card);
 
 	sca_out(DSR_DE, DSR_TX(phy_node(port)), card); /* Enable TX DMA */
@@ -809,46 +621,24 @@ static int sca_xmit(struct sk_buff *skb, struct net_device *dev)
 }
 
 
-
-#ifdef NEED_DETECT_RAM
-static u32 __devinit sca_detect_ram(card_t *card, u8 __iomem *rambase, u32 ramsize)
+static u32 __devinit sca_detect_ram(card_t *card, u8 __iomem *rambase,
+				    u32 ramsize)
 {
 	/* Round RAM size to 32 bits, fill from end to start */
 	u32 i = ramsize &= ~3;
 
-#ifndef ALL_PAGES_ALWAYS_MAPPED
-	u32 size = winsize(card);
-
-	openwin(card, (i - 4) / size); /* select last window */
-#endif
 	do {
 		i -= 4;
-#ifndef ALL_PAGES_ALWAYS_MAPPED
-		if ((i + 4) % size == 0)
-			openwin(card, i / size);
-		writel(i ^ 0x12345678, rambase + i % size);
-#else
 		writel(i ^ 0x12345678, rambase + i);
-#endif
-	}while (i > 0);
+	} while (i > 0);
 
 	for (i = 0; i < ramsize ; i += 4) {
-#ifndef ALL_PAGES_ALWAYS_MAPPED
-		if (i % size == 0)
-			openwin(card, i / size);
-
-		if (readl(rambase + i % size) != (i ^ 0x12345678))
-			break;
-#else
 		if (readl(rambase + i) != (i ^ 0x12345678))
 			break;
-#endif
 	}
 
 	return i;
 }
-#endif /* NEED_DETECT_RAM */
-
 
 
 static void __devinit sca_init(card_t *card, int wait_states)

commit 6b40aba304e6f94c747ad9559e03ea03a49e8008
Author: Krzysztof Hałasa <khc@pm.waw.pl>
Date:   Mon Mar 24 16:39:02 2008 +0100

    WAN: split hd6457x.c into hd64570.c and hd64572.c
    
    Supporting both original SCA and SCA-II in one file was nice at some
    point but now it's increasingly painful.
    
    Signed-off-by: Krzysztof Hałasa <khc@pm.waw.pl>

diff --git a/drivers/net/wan/hd64572.c b/drivers/net/wan/hd64572.c
new file mode 100644
index 000000000000..434583a94b32
--- /dev/null
+++ b/drivers/net/wan/hd64572.c
@@ -0,0 +1,867 @@
+/*
+ * Hitachi SCA HD64570 and HD64572 common driver for Linux
+ *
+ * Copyright (C) 1998-2003 Krzysztof Halasa <khc@pm.waw.pl>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License
+ * as published by the Free Software Foundation.
+ *
+ * Sources of information:
+ *    Hitachi HD64570 SCA User's Manual
+ *    Hitachi HD64572 SCA-II User's Manual
+ *
+ * We use the following SCA memory map:
+ *
+ * Packet buffer descriptor rings - starting from winbase or win0base:
+ * rx_ring_buffers * sizeof(pkt_desc) = logical channel #0 RX ring
+ * tx_ring_buffers * sizeof(pkt_desc) = logical channel #0 TX ring
+ * rx_ring_buffers * sizeof(pkt_desc) = logical channel #1 RX ring (if used)
+ * tx_ring_buffers * sizeof(pkt_desc) = logical channel #1 TX ring (if used)
+ *
+ * Packet data buffers - starting from winbase + buff_offset:
+ * rx_ring_buffers * HDLC_MAX_MRU     = logical channel #0 RX buffers
+ * tx_ring_buffers * HDLC_MAX_MRU     = logical channel #0 TX buffers
+ * rx_ring_buffers * HDLC_MAX_MRU     = logical channel #0 RX buffers (if used)
+ * tx_ring_buffers * HDLC_MAX_MRU     = logical channel #0 TX buffers (if used)
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/in.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/bitops.h>
+
+#include <asm/system.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+
+#include <linux/hdlc.h>
+
+#if (!defined (__HD64570_H) && !defined (__HD64572_H)) || \
+    (defined (__HD64570_H) && defined (__HD64572_H))
+#error Either hd64570.h or hd64572.h must be included
+#endif
+
+#define get_msci(port)	  (phy_node(port) ?   MSCI1_OFFSET :   MSCI0_OFFSET)
+#define get_dmac_rx(port) (phy_node(port) ? DMAC1RX_OFFSET : DMAC0RX_OFFSET)
+#define get_dmac_tx(port) (phy_node(port) ? DMAC1TX_OFFSET : DMAC0TX_OFFSET)
+
+#define SCA_INTR_MSCI(node)    (node ? 0x10 : 0x01)
+#define SCA_INTR_DMAC_RX(node) (node ? 0x20 : 0x02)
+#define SCA_INTR_DMAC_TX(node) (node ? 0x40 : 0x04)
+
+#ifdef __HD64570_H /* HD64570 */
+#define sca_outa(value, reg, card)	sca_outw(value, reg, card)
+#define sca_ina(reg, card)		sca_inw(reg, card)
+#define writea(value, ptr)		writew(value, ptr)
+
+#else /* HD64572 */
+#define sca_outa(value, reg, card)	sca_outl(value, reg, card)
+#define sca_ina(reg, card)		sca_inl(reg, card)
+#define writea(value, ptr)		writel(value, ptr)
+#endif
+
+static inline struct net_device *port_to_dev(port_t *port)
+{
+	return port->dev;
+}
+
+static inline int sca_intr_status(card_t *card)
+{
+	u8 result = 0;
+
+#ifdef __HD64570_H /* HD64570 */
+	u8 isr0 = sca_in(ISR0, card);
+	u8 isr1 = sca_in(ISR1, card);
+
+	if (isr1 & 0x03) result |= SCA_INTR_DMAC_RX(0);
+	if (isr1 & 0x0C) result |= SCA_INTR_DMAC_TX(0);
+	if (isr1 & 0x30) result |= SCA_INTR_DMAC_RX(1);
+	if (isr1 & 0xC0) result |= SCA_INTR_DMAC_TX(1);
+	if (isr0 & 0x0F) result |= SCA_INTR_MSCI(0);
+	if (isr0 & 0xF0) result |= SCA_INTR_MSCI(1);
+
+#else /* HD64572 */
+	u32 isr0 = sca_inl(ISR0, card);
+
+	if (isr0 & 0x0000000F) result |= SCA_INTR_DMAC_RX(0);
+	if (isr0 & 0x000000F0) result |= SCA_INTR_DMAC_TX(0);
+	if (isr0 & 0x00000F00) result |= SCA_INTR_DMAC_RX(1);
+	if (isr0 & 0x0000F000) result |= SCA_INTR_DMAC_TX(1);
+	if (isr0 & 0x003E0000) result |= SCA_INTR_MSCI(0);
+	if (isr0 & 0x3E000000) result |= SCA_INTR_MSCI(1);
+
+#endif /* HD64570 vs HD64572 */
+
+	if (!(result & SCA_INTR_DMAC_TX(0)))
+		if (sca_in(DSR_TX(0), card) & DSR_EOM)
+			result |= SCA_INTR_DMAC_TX(0);
+	if (!(result & SCA_INTR_DMAC_TX(1)))
+		if (sca_in(DSR_TX(1), card) & DSR_EOM)
+			result |= SCA_INTR_DMAC_TX(1);
+
+	return result;
+}
+
+static inline port_t* dev_to_port(struct net_device *dev)
+{
+	return dev_to_hdlc(dev)->priv;
+}
+
+static inline u16 next_desc(port_t *port, u16 desc, int transmit)
+{
+	return (desc + 1) % (transmit ? port_to_card(port)->tx_ring_buffers
+			     : port_to_card(port)->rx_ring_buffers);
+}
+
+
+
+static inline u16 desc_abs_number(port_t *port, u16 desc, int transmit)
+{
+	u16 rx_buffs = port_to_card(port)->rx_ring_buffers;
+	u16 tx_buffs = port_to_card(port)->tx_ring_buffers;
+
+	desc %= (transmit ? tx_buffs : rx_buffs); // called with "X + 1" etc.
+	return log_node(port) * (rx_buffs + tx_buffs) +
+		transmit * rx_buffs + desc;
+}
+
+
+
+static inline u16 desc_offset(port_t *port, u16 desc, int transmit)
+{
+	/* Descriptor offset always fits in 16 bytes */
+	return desc_abs_number(port, desc, transmit) * sizeof(pkt_desc);
+}
+
+
+
+static inline pkt_desc __iomem *desc_address(port_t *port, u16 desc, int transmit)
+{
+#ifdef PAGE0_ALWAYS_MAPPED
+	return (pkt_desc __iomem *)(win0base(port_to_card(port))
+			   + desc_offset(port, desc, transmit));
+#else
+	return (pkt_desc __iomem *)(winbase(port_to_card(port))
+			   + desc_offset(port, desc, transmit));
+#endif
+}
+
+
+
+static inline u32 buffer_offset(port_t *port, u16 desc, int transmit)
+{
+	return port_to_card(port)->buff_offset +
+		desc_abs_number(port, desc, transmit) * (u32)HDLC_MAX_MRU;
+}
+
+
+static inline void sca_set_carrier(port_t *port)
+{
+	if (!(sca_in(get_msci(port) + ST3, port_to_card(port)) & ST3_DCD)) {
+#ifdef DEBUG_LINK
+		printk(KERN_DEBUG "%s: sca_set_carrier on\n",
+		       port_to_dev(port)->name);
+#endif
+		netif_carrier_on(port_to_dev(port));
+	} else {
+#ifdef DEBUG_LINK
+		printk(KERN_DEBUG "%s: sca_set_carrier off\n",
+		       port_to_dev(port)->name);
+#endif
+		netif_carrier_off(port_to_dev(port));
+	}
+}
+
+
+static void sca_init_sync_port(port_t *port)
+{
+	card_t *card = port_to_card(port);
+	int transmit, i;
+
+	port->rxin = 0;
+	port->txin = 0;
+	port->txlast = 0;
+
+#if !defined(PAGE0_ALWAYS_MAPPED) && !defined(ALL_PAGES_ALWAYS_MAPPED)
+	openwin(card, 0);
+#endif
+
+	for (transmit = 0; transmit < 2; transmit++) {
+		u16 dmac = transmit ? get_dmac_tx(port) : get_dmac_rx(port);
+		u16 buffs = transmit ? card->tx_ring_buffers
+			: card->rx_ring_buffers;
+
+		for (i = 0; i < buffs; i++) {
+			pkt_desc __iomem *desc = desc_address(port, i, transmit);
+			u16 chain_off = desc_offset(port, i + 1, transmit);
+			u32 buff_off = buffer_offset(port, i, transmit);
+
+			writea(chain_off, &desc->cp);
+			writel(buff_off, &desc->bp);
+			writew(0, &desc->len);
+			writeb(0, &desc->stat);
+		}
+
+		/* DMA disable - to halt state */
+		sca_out(0, transmit ? DSR_TX(phy_node(port)) :
+			DSR_RX(phy_node(port)), card);
+		/* software ABORT - to initial state */
+		sca_out(DCR_ABORT, transmit ? DCR_TX(phy_node(port)) :
+			DCR_RX(phy_node(port)), card);
+
+#ifdef __HD64570_H
+		sca_out(0, dmac + CPB, card); /* pointer base */
+#endif
+		/* current desc addr */
+		sca_outa(desc_offset(port, 0, transmit), dmac + CDAL, card);
+		if (!transmit)
+			sca_outa(desc_offset(port, buffs - 1, transmit),
+				 dmac + EDAL, card);
+		else
+			sca_outa(desc_offset(port, 0, transmit), dmac + EDAL,
+				 card);
+
+		/* clear frame end interrupt counter */
+		sca_out(DCR_CLEAR_EOF, transmit ? DCR_TX(phy_node(port)) :
+			DCR_RX(phy_node(port)), card);
+
+		if (!transmit) { /* Receive */
+			/* set buffer length */
+			sca_outw(HDLC_MAX_MRU, dmac + BFLL, card);
+			/* Chain mode, Multi-frame */
+			sca_out(0x14, DMR_RX(phy_node(port)), card);
+			sca_out(DIR_EOME | DIR_BOFE, DIR_RX(phy_node(port)),
+				card);
+			/* DMA enable */
+			sca_out(DSR_DE, DSR_RX(phy_node(port)), card);
+		} else {	/* Transmit */
+			/* Chain mode, Multi-frame */
+			sca_out(0x14, DMR_TX(phy_node(port)), card);
+			/* enable underflow interrupts */
+			sca_out(DIR_BOFE, DIR_TX(phy_node(port)), card);
+		}
+	}
+	sca_set_carrier(port);
+}
+
+
+
+#ifdef NEED_SCA_MSCI_INTR
+/* MSCI interrupt service */
+static inline void sca_msci_intr(port_t *port)
+{
+	u16 msci = get_msci(port);
+	card_t* card = port_to_card(port);
+	u8 stat = sca_in(msci + ST1, card); /* read MSCI ST1 status */
+
+	/* Reset MSCI TX underrun and CDCD status bit */
+	sca_out(stat & (ST1_UDRN | ST1_CDCD), msci + ST1, card);
+
+	if (stat & ST1_UDRN) {
+		/* TX Underrun error detected */
+		port_to_dev(port)->stats.tx_errors++;
+		port_to_dev(port)->stats.tx_fifo_errors++;
+	}
+
+	if (stat & ST1_CDCD)
+		sca_set_carrier(port);
+}
+#endif
+
+
+
+static inline void sca_rx(card_t *card, port_t *port, pkt_desc __iomem *desc, u16 rxin)
+{
+	struct net_device *dev = port_to_dev(port);
+	struct sk_buff *skb;
+	u16 len;
+	u32 buff;
+#ifndef ALL_PAGES_ALWAYS_MAPPED
+	u32 maxlen;
+	u8 page;
+#endif
+
+	len = readw(&desc->len);
+	skb = dev_alloc_skb(len);
+	if (!skb) {
+		dev->stats.rx_dropped++;
+		return;
+	}
+
+	buff = buffer_offset(port, rxin, 0);
+#ifndef ALL_PAGES_ALWAYS_MAPPED
+	page = buff / winsize(card);
+	buff = buff % winsize(card);
+	maxlen = winsize(card) - buff;
+
+	openwin(card, page);
+
+	if (len > maxlen) {
+		memcpy_fromio(skb->data, winbase(card) + buff, maxlen);
+		openwin(card, page + 1);
+		memcpy_fromio(skb->data + maxlen, winbase(card), len - maxlen);
+	} else
+#endif
+	memcpy_fromio(skb->data, winbase(card) + buff, len);
+
+#if !defined(PAGE0_ALWAYS_MAPPED) && !defined(ALL_PAGES_ALWAYS_MAPPED)
+	/* select pkt_desc table page back */
+	openwin(card, 0);
+#endif
+	skb_put(skb, len);
+#ifdef DEBUG_PKT
+	printk(KERN_DEBUG "%s RX(%i):", dev->name, skb->len);
+	debug_frame(skb);
+#endif
+	dev->stats.rx_packets++;
+	dev->stats.rx_bytes += skb->len;
+	skb->protocol = hdlc_type_trans(skb, dev);
+	netif_rx(skb);
+}
+
+
+
+/* Receive DMA interrupt service */
+static inline void sca_rx_intr(port_t *port)
+{
+	struct net_device *dev = port_to_dev(port);
+	u16 dmac = get_dmac_rx(port);
+	card_t *card = port_to_card(port);
+	u8 stat = sca_in(DSR_RX(phy_node(port)), card); /* read DMA Status */
+
+	/* Reset DSR status bits */
+	sca_out((stat & (DSR_EOT | DSR_EOM | DSR_BOF | DSR_COF)) | DSR_DWE,
+		DSR_RX(phy_node(port)), card);
+
+	if (stat & DSR_BOF)
+		/* Dropped one or more frames */
+		dev->stats.rx_over_errors++;
+
+	while (1) {
+		u32 desc_off = desc_offset(port, port->rxin, 0);
+		pkt_desc __iomem *desc;
+		u32 cda = sca_ina(dmac + CDAL, card);
+
+		if ((cda >= desc_off) && (cda < desc_off + sizeof(pkt_desc)))
+			break;	/* No frame received */
+
+		desc = desc_address(port, port->rxin, 0);
+		stat = readb(&desc->stat);
+		if (!(stat & ST_RX_EOM))
+			port->rxpart = 1; /* partial frame received */
+		else if ((stat & ST_ERROR_MASK) || port->rxpart) {
+			dev->stats.rx_errors++;
+			if (stat & ST_RX_OVERRUN)
+				dev->stats.rx_fifo_errors++;
+			else if ((stat & (ST_RX_SHORT | ST_RX_ABORT |
+					  ST_RX_RESBIT)) || port->rxpart)
+				dev->stats.rx_frame_errors++;
+			else if (stat & ST_RX_CRC)
+				dev->stats.rx_crc_errors++;
+			if (stat & ST_RX_EOM)
+				port->rxpart = 0; /* received last fragment */
+		} else
+			sca_rx(card, port, desc, port->rxin);
+
+		/* Set new error descriptor address */
+		sca_outa(desc_off, dmac + EDAL, card);
+		port->rxin = next_desc(port, port->rxin, 0);
+	}
+
+	/* make sure RX DMA is enabled */
+	sca_out(DSR_DE, DSR_RX(phy_node(port)), card);
+}
+
+
+
+/* Transmit DMA interrupt service */
+static inline void sca_tx_intr(port_t *port)
+{
+	struct net_device *dev = port_to_dev(port);
+	u16 dmac = get_dmac_tx(port);
+	card_t* card = port_to_card(port);
+	u8 stat;
+
+	spin_lock(&port->lock);
+
+	stat = sca_in(DSR_TX(phy_node(port)), card); /* read DMA Status */
+
+	/* Reset DSR status bits */
+	sca_out((stat & (DSR_EOT | DSR_EOM | DSR_BOF | DSR_COF)) | DSR_DWE,
+		DSR_TX(phy_node(port)), card);
+
+	while (1) {
+		pkt_desc __iomem *desc;
+
+		u32 desc_off = desc_offset(port, port->txlast, 1);
+		u32 cda = sca_ina(dmac + CDAL, card);
+		if ((cda >= desc_off) && (cda < desc_off + sizeof(pkt_desc)))
+			break;	/* Transmitter is/will_be sending this frame */
+
+		desc = desc_address(port, port->txlast, 1);
+		dev->stats.tx_packets++;
+		dev->stats.tx_bytes += readw(&desc->len);
+		writeb(0, &desc->stat);	/* Free descriptor */
+		port->txlast = next_desc(port, port->txlast, 1);
+	}
+
+	netif_wake_queue(dev);
+	spin_unlock(&port->lock);
+}
+
+
+
+static irqreturn_t sca_intr(int irq, void* dev_id)
+{
+	card_t *card = dev_id;
+	int i;
+	u8 stat;
+	int handled = 0;
+
+#ifndef ALL_PAGES_ALWAYS_MAPPED
+	u8 page = sca_get_page(card);
+#endif
+
+	while((stat = sca_intr_status(card)) != 0) {
+		handled = 1;
+		for (i = 0; i < 2; i++) {
+			port_t *port = get_port(card, i);
+			if (port) {
+				if (stat & SCA_INTR_MSCI(i))
+					sca_msci_intr(port);
+
+				if (stat & SCA_INTR_DMAC_RX(i))
+					sca_rx_intr(port);
+
+				if (stat & SCA_INTR_DMAC_TX(i))
+					sca_tx_intr(port);
+			}
+		}
+	}
+
+#ifndef ALL_PAGES_ALWAYS_MAPPED
+	openwin(card, page);		/* Restore original page */
+#endif
+	return IRQ_RETVAL(handled);
+}
+
+
+
+static void sca_set_port(port_t *port)
+{
+	card_t* card = port_to_card(port);
+	u16 msci = get_msci(port);
+	u8 md2 = sca_in(msci + MD2, card);
+	unsigned int tmc, br = 10, brv = 1024;
+
+
+	if (port->settings.clock_rate > 0) {
+		/* Try lower br for better accuracy*/
+		do {
+			br--;
+			brv >>= 1; /* brv = 2^9 = 512 max in specs */
+
+			/* Baud Rate = CLOCK_BASE / TMC / 2^BR */
+			tmc = CLOCK_BASE / brv / port->settings.clock_rate;
+		}while (br > 1 && tmc <= 128);
+
+		if (tmc < 1) {
+			tmc = 1;
+			br = 0;	/* For baud=CLOCK_BASE we use tmc=1 br=0 */
+			brv = 1;
+		} else if (tmc > 255)
+			tmc = 256; /* tmc=0 means 256 - low baud rates */
+
+		port->settings.clock_rate = CLOCK_BASE / brv / tmc;
+	} else {
+		br = 9; /* Minimum clock rate */
+		tmc = 256;	/* 8bit = 0 */
+		port->settings.clock_rate = CLOCK_BASE / (256 * 512);
+	}
+
+	port->rxs = (port->rxs & ~CLK_BRG_MASK) | br;
+	port->txs = (port->txs & ~CLK_BRG_MASK) | br;
+	port->tmc = tmc;
+
+	/* baud divisor - time constant*/
+#ifdef __HD64570_H
+	sca_out(port->tmc, msci + TMC, card);
+#else
+	sca_out(port->tmc, msci + TMCR, card);
+	sca_out(port->tmc, msci + TMCT, card);
+#endif
+
+	/* Set BRG bits */
+	sca_out(port->rxs, msci + RXS, card);
+	sca_out(port->txs, msci + TXS, card);
+
+	if (port->settings.loopback)
+		md2 |= MD2_LOOPBACK;
+	else
+		md2 &= ~MD2_LOOPBACK;
+
+	sca_out(md2, msci + MD2, card);
+
+}
+
+
+
+static void sca_open(struct net_device *dev)
+{
+	port_t *port = dev_to_port(dev);
+	card_t* card = port_to_card(port);
+	u16 msci = get_msci(port);
+	u8 md0, md2;
+
+	switch(port->encoding) {
+	case ENCODING_NRZ:	md2 = MD2_NRZ;		break;
+	case ENCODING_NRZI:	md2 = MD2_NRZI;		break;
+	case ENCODING_FM_MARK:	md2 = MD2_FM_MARK;	break;
+	case ENCODING_FM_SPACE:	md2 = MD2_FM_SPACE;	break;
+	default:		md2 = MD2_MANCHESTER;
+	}
+
+	if (port->settings.loopback)
+		md2 |= MD2_LOOPBACK;
+
+	switch(port->parity) {
+	case PARITY_CRC16_PR0:	     md0 = MD0_HDLC | MD0_CRC_16_0;  break;
+	case PARITY_CRC16_PR1:	     md0 = MD0_HDLC | MD0_CRC_16;    break;
+#ifdef __HD64570_H
+	case PARITY_CRC16_PR0_CCITT: md0 = MD0_HDLC | MD0_CRC_ITU_0; break;
+#else
+	case PARITY_CRC32_PR1_CCITT: md0 = MD0_HDLC | MD0_CRC_ITU32; break;
+#endif
+	case PARITY_CRC16_PR1_CCITT: md0 = MD0_HDLC | MD0_CRC_ITU;   break;
+	default:		     md0 = MD0_HDLC | MD0_CRC_NONE;
+	}
+
+	sca_out(CMD_RESET, msci + CMD, card);
+	sca_out(md0, msci + MD0, card);
+	sca_out(0x00, msci + MD1, card); /* no address field check */
+	sca_out(md2, msci + MD2, card);
+	sca_out(0x7E, msci + IDL, card); /* flag character 0x7E */
+#ifdef __HD64570_H
+	sca_out(CTL_IDLE, msci + CTL, card);
+#else
+	/* Skip the rest of underrun frame */
+	sca_out(CTL_IDLE | CTL_URCT | CTL_URSKP, msci + CTL, card);
+#endif
+
+#ifdef __HD64570_H
+	/* Allow at least 8 bytes before requesting RX DMA operation */
+	/* TX with higher priority and possibly with shorter transfers */
+	sca_out(0x07, msci + RRC, card); /* +1=RXRDY/DMA activation condition*/
+	sca_out(0x10, msci + TRC0, card); /* = TXRDY/DMA activation condition*/
+	sca_out(0x14, msci + TRC1, card); /* +1=TXRDY/DMA deactiv condition */
+#else
+	sca_out(0x0F, msci + RNR, card); /* +1=RX DMA activation condition */
+	sca_out(0x3C, msci + TFS, card); /* +1 = TX start */
+	sca_out(0x38, msci + TCR, card); /* =Critical TX DMA activ condition */
+	sca_out(0x38, msci + TNR0, card); /* =TX DMA activation condition */
+	sca_out(0x3F, msci + TNR1, card); /* +1=TX DMA deactivation condition*/
+#endif
+
+/* We're using the following interrupts:
+   - TXINT (DMAC completed all transmisions, underrun or DCD change)
+   - all DMA interrupts
+*/
+
+	sca_set_carrier(port);
+
+#ifdef __HD64570_H
+	/* MSCI TX INT and RX INT A IRQ enable */
+	sca_out(IE0_TXINT | IE0_RXINTA, msci + IE0, card);
+	sca_out(IE1_UDRN | IE1_CDCD, msci + IE1, card);
+	sca_out(sca_in(IER0, card) | (phy_node(port) ? 0xC0 : 0x0C),
+		IER0, card); /* TXINT and RXINT */
+	/* enable DMA IRQ */
+	sca_out(sca_in(IER1, card) | (phy_node(port) ? 0xF0 : 0x0F),
+		IER1, card);
+#else
+	/* MSCI TXINT and RXINTA interrupt enable */
+	sca_outl(IE0_TXINT | IE0_RXINTA | IE0_UDRN | IE0_CDCD, msci + IE0,
+		 card);
+	/* DMA & MSCI IRQ enable */
+	sca_outl(sca_inl(IER0, card) |
+		 (phy_node(port) ? 0x0A006600 : 0x000A0066), IER0, card);
+#endif
+
+#ifdef __HD64570_H
+	sca_out(port->tmc, msci + TMC, card); /* Restore registers */
+#else
+	sca_out(port->tmc, msci + TMCR, card);
+	sca_out(port->tmc, msci + TMCT, card);
+#endif
+	sca_out(port->rxs, msci + RXS, card);
+	sca_out(port->txs, msci + TXS, card);
+	sca_out(CMD_TX_ENABLE, msci + CMD, card);
+	sca_out(CMD_RX_ENABLE, msci + CMD, card);
+
+	netif_start_queue(dev);
+}
+
+
+
+static void sca_close(struct net_device *dev)
+{
+	port_t *port = dev_to_port(dev);
+	card_t* card = port_to_card(port);
+
+	/* reset channel */
+	sca_out(CMD_RESET, get_msci(port) + CMD, port_to_card(port));
+#ifdef __HD64570_H
+	/* disable MSCI interrupts */
+	sca_out(sca_in(IER0, card) & (phy_node(port) ? 0x0F : 0xF0),
+		IER0, card);
+	/* disable DMA interrupts */
+	sca_out(sca_in(IER1, card) & (phy_node(port) ? 0x0F : 0xF0),
+		IER1, card);
+#else
+	/* disable DMA & MSCI IRQ */
+	sca_outl(sca_inl(IER0, card) &
+		 (phy_node(port) ? 0x00FF00FF : 0xFF00FF00), IER0, card);
+#endif
+	netif_stop_queue(dev);
+}
+
+
+
+static int sca_attach(struct net_device *dev, unsigned short encoding,
+		      unsigned short parity)
+{
+	if (encoding != ENCODING_NRZ &&
+	    encoding != ENCODING_NRZI &&
+	    encoding != ENCODING_FM_MARK &&
+	    encoding != ENCODING_FM_SPACE &&
+	    encoding != ENCODING_MANCHESTER)
+		return -EINVAL;
+
+	if (parity != PARITY_NONE &&
+	    parity != PARITY_CRC16_PR0 &&
+	    parity != PARITY_CRC16_PR1 &&
+#ifdef __HD64570_H
+	    parity != PARITY_CRC16_PR0_CCITT &&
+#else
+	    parity != PARITY_CRC32_PR1_CCITT &&
+#endif
+	    parity != PARITY_CRC16_PR1_CCITT)
+		return -EINVAL;
+
+	dev_to_port(dev)->encoding = encoding;
+	dev_to_port(dev)->parity = parity;
+	return 0;
+}
+
+
+
+#ifdef DEBUG_RINGS
+static void sca_dump_rings(struct net_device *dev)
+{
+	port_t *port = dev_to_port(dev);
+	card_t *card = port_to_card(port);
+	u16 cnt;
+#if !defined(PAGE0_ALWAYS_MAPPED) && !defined(ALL_PAGES_ALWAYS_MAPPED)
+	u8 page;
+#endif
+
+#if !defined(PAGE0_ALWAYS_MAPPED) && !defined(ALL_PAGES_ALWAYS_MAPPED)
+	page = sca_get_page(card);
+	openwin(card, 0);
+#endif
+
+	printk(KERN_DEBUG "RX ring: CDA=%u EDA=%u DSR=%02X in=%u %sactive",
+	       sca_ina(get_dmac_rx(port) + CDAL, card),
+	       sca_ina(get_dmac_rx(port) + EDAL, card),
+	       sca_in(DSR_RX(phy_node(port)), card), port->rxin,
+	       sca_in(DSR_RX(phy_node(port)), card) & DSR_DE?"":"in");
+	for (cnt = 0; cnt < port_to_card(port)->rx_ring_buffers; cnt++)
+		printk(" %02X", readb(&(desc_address(port, cnt, 0)->stat)));
+
+	printk("\n" KERN_DEBUG "TX ring: CDA=%u EDA=%u DSR=%02X in=%u "
+	       "last=%u %sactive",
+	       sca_ina(get_dmac_tx(port) + CDAL, card),
+	       sca_ina(get_dmac_tx(port) + EDAL, card),
+	       sca_in(DSR_TX(phy_node(port)), card), port->txin, port->txlast,
+	       sca_in(DSR_TX(phy_node(port)), card) & DSR_DE ? "" : "in");
+
+	for (cnt = 0; cnt < port_to_card(port)->tx_ring_buffers; cnt++)
+		printk(" %02X", readb(&(desc_address(port, cnt, 1)->stat)));
+	printk("\n");
+
+	printk(KERN_DEBUG "MSCI: MD: %02x %02x %02x, "
+	       "ST: %02x %02x %02x %02x"
+#ifdef __HD64572_H
+	       " %02x"
+#endif
+	       ", FST: %02x CST: %02x %02x\n",
+	       sca_in(get_msci(port) + MD0, card),
+	       sca_in(get_msci(port) + MD1, card),
+	       sca_in(get_msci(port) + MD2, card),
+	       sca_in(get_msci(port) + ST0, card),
+	       sca_in(get_msci(port) + ST1, card),
+	       sca_in(get_msci(port) + ST2, card),
+	       sca_in(get_msci(port) + ST3, card),
+#ifdef __HD64572_H
+	       sca_in(get_msci(port) + ST4, card),
+#endif
+	       sca_in(get_msci(port) + FST, card),
+	       sca_in(get_msci(port) + CST0, card),
+	       sca_in(get_msci(port) + CST1, card));
+
+#ifdef __HD64572_H
+	printk(KERN_DEBUG "ILAR: %02x ISR: %08x %08x\n", sca_in(ILAR, card),
+	       sca_inl(ISR0, card), sca_inl(ISR1, card));
+#else
+	printk(KERN_DEBUG "ISR: %02x %02x %02x\n", sca_in(ISR0, card),
+	       sca_in(ISR1, card), sca_in(ISR2, card));
+#endif
+
+#if !defined(PAGE0_ALWAYS_MAPPED) && !defined(ALL_PAGES_ALWAYS_MAPPED)
+	openwin(card, page); /* Restore original page */
+#endif
+}
+#endif /* DEBUG_RINGS */
+
+
+
+static int sca_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	port_t *port = dev_to_port(dev);
+	card_t *card = port_to_card(port);
+	pkt_desc __iomem *desc;
+	u32 buff, len;
+#ifndef ALL_PAGES_ALWAYS_MAPPED
+	u8 page;
+	u32 maxlen;
+#endif
+
+	spin_lock_irq(&port->lock);
+
+	desc = desc_address(port, port->txin + 1, 1);
+	if (readb(&desc->stat)) { /* allow 1 packet gap */
+		/* should never happen - previous xmit should stop queue */
+#ifdef DEBUG_PKT
+		printk(KERN_DEBUG "%s: transmitter buffer full\n", dev->name);
+#endif
+		netif_stop_queue(dev);
+		spin_unlock_irq(&port->lock);
+		return 1;	/* request packet to be queued */
+	}
+
+#ifdef DEBUG_PKT
+	printk(KERN_DEBUG "%s TX(%i):", dev->name, skb->len);
+	debug_frame(skb);
+#endif
+
+	desc = desc_address(port, port->txin, 1);
+	buff = buffer_offset(port, port->txin, 1);
+	len = skb->len;
+#ifndef ALL_PAGES_ALWAYS_MAPPED
+	page = buff / winsize(card);
+	buff = buff % winsize(card);
+	maxlen = winsize(card) - buff;
+
+	openwin(card, page);
+	if (len > maxlen) {
+		memcpy_toio(winbase(card) + buff, skb->data, maxlen);
+		openwin(card, page + 1);
+		memcpy_toio(winbase(card), skb->data + maxlen, len - maxlen);
+	}
+	else
+#endif
+		memcpy_toio(winbase(card) + buff, skb->data, len);
+
+#if !defined(PAGE0_ALWAYS_MAPPED) && !defined(ALL_PAGES_ALWAYS_MAPPED)
+	openwin(card, 0);	/* select pkt_desc table page back */
+#endif
+	writew(len, &desc->len);
+	writeb(ST_TX_EOM, &desc->stat);
+	dev->trans_start = jiffies;
+
+	port->txin = next_desc(port, port->txin, 1);
+	sca_outa(desc_offset(port, port->txin, 1),
+		 get_dmac_tx(port) + EDAL, card);
+
+	sca_out(DSR_DE, DSR_TX(phy_node(port)), card); /* Enable TX DMA */
+
+	desc = desc_address(port, port->txin + 1, 1);
+	if (readb(&desc->stat)) /* allow 1 packet gap */
+		netif_stop_queue(dev);
+
+	spin_unlock_irq(&port->lock);
+
+	dev_kfree_skb(skb);
+	return 0;
+}
+
+
+
+#ifdef NEED_DETECT_RAM
+static u32 __devinit sca_detect_ram(card_t *card, u8 __iomem *rambase, u32 ramsize)
+{
+	/* Round RAM size to 32 bits, fill from end to start */
+	u32 i = ramsize &= ~3;
+
+#ifndef ALL_PAGES_ALWAYS_MAPPED
+	u32 size = winsize(card);
+
+	openwin(card, (i - 4) / size); /* select last window */
+#endif
+	do {
+		i -= 4;
+#ifndef ALL_PAGES_ALWAYS_MAPPED
+		if ((i + 4) % size == 0)
+			openwin(card, i / size);
+		writel(i ^ 0x12345678, rambase + i % size);
+#else
+		writel(i ^ 0x12345678, rambase + i);
+#endif
+	}while (i > 0);
+
+	for (i = 0; i < ramsize ; i += 4) {
+#ifndef ALL_PAGES_ALWAYS_MAPPED
+		if (i % size == 0)
+			openwin(card, i / size);
+
+		if (readl(rambase + i % size) != (i ^ 0x12345678))
+			break;
+#else
+		if (readl(rambase + i) != (i ^ 0x12345678))
+			break;
+#endif
+	}
+
+	return i;
+}
+#endif /* NEED_DETECT_RAM */
+
+
+
+static void __devinit sca_init(card_t *card, int wait_states)
+{
+	sca_out(wait_states, WCRL, card); /* Wait Control */
+	sca_out(wait_states, WCRM, card);
+	sca_out(wait_states, WCRH, card);
+
+	sca_out(0, DMER, card);	/* DMA Master disable */
+	sca_out(0x03, PCR, card); /* DMA priority */
+	sca_out(0, DSR_RX(0), card); /* DMA disable - to halt state */
+	sca_out(0, DSR_TX(0), card);
+	sca_out(0, DSR_RX(1), card);
+	sca_out(0, DSR_TX(1), card);
+	sca_out(DMER_DME, DMER, card); /* DMA Master enable */
+}
