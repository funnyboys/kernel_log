commit 83cf4213bafc4e3c747f0a25ad22cfbf55af7e84
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Sat Feb 1 16:43:39 2020 +0000

    netdevsim: use __GFP_NOWARN to avoid memalloc warning
    
    vfnum buffer size and binary_len buffer size is received by user-space.
    So, this buffer size could be too large. If so, kmalloc will internally
    print a warning message.
    This warning message is actually not necessary for the netdevsim module.
    So, this patch adds __GFP_NOWARN.
    
    Test commands:
        modprobe netdevsim
        echo 1 > /sys/bus/netdevsim/new_device
        echo 1000000000 > /sys/devices/netdevsim1/sriov_numvfs
    
    Splat looks like:
    [  357.847266][ T1000] WARNING: CPU: 0 PID: 1000 at mm/page_alloc.c:4738 __alloc_pages_nodemask+0x2f3/0x740
    [  357.850273][ T1000] Modules linked in: netdevsim veth openvswitch nsh nf_conncount nf_nat nf_conntrack nf_defrx
    [  357.852989][ T1000] CPU: 0 PID: 1000 Comm: bash Tainted: G    B             5.5.0-rc5+ #270
    [  357.854334][ T1000] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [  357.855703][ T1000] RIP: 0010:__alloc_pages_nodemask+0x2f3/0x740
    [  357.856669][ T1000] Code: 64 fe ff ff 65 48 8b 04 25 c0 0f 02 00 48 05 f0 12 00 00 41 be 01 00 00 00 49 89 47 0
    [  357.860272][ T1000] RSP: 0018:ffff8880b7f47bd8 EFLAGS: 00010246
    [  357.861009][ T1000] RAX: ffffed1016fe8f80 RBX: 1ffff11016fe8fae RCX: 0000000000000000
    [  357.861843][ T1000] RDX: 0000000000000000 RSI: 0000000000000017 RDI: 0000000000000000
    [  357.862661][ T1000] RBP: 0000000000040dc0 R08: 1ffff11016fe8f67 R09: dffffc0000000000
    [  357.863509][ T1000] R10: ffff8880b7f47d68 R11: fffffbfff2798180 R12: 1ffff11016fe8f80
    [  357.864355][ T1000] R13: 0000000000000017 R14: 0000000000000017 R15: ffff8880c2038d68
    [  357.865178][ T1000] FS:  00007fd9a5b8c740(0000) GS:ffff8880d9c00000(0000) knlGS:0000000000000000
    [  357.866248][ T1000] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  357.867531][ T1000] CR2: 000055ce01ba8100 CR3: 00000000b7dbe005 CR4: 00000000000606f0
    [  357.868972][ T1000] Call Trace:
    [  357.869423][ T1000]  ? lock_contended+0xcd0/0xcd0
    [  357.870001][ T1000]  ? __alloc_pages_slowpath+0x21d0/0x21d0
    [  357.870673][ T1000]  ? _kstrtoull+0x76/0x160
    [  357.871148][ T1000]  ? alloc_pages_current+0xc1/0x1a0
    [  357.871704][ T1000]  kmalloc_order+0x22/0x80
    [  357.872184][ T1000]  kmalloc_order_trace+0x1d/0x140
    [  357.872733][ T1000]  __kmalloc+0x302/0x3a0
    [  357.873204][ T1000]  nsim_bus_dev_numvfs_store+0x1ab/0x260 [netdevsim]
    [  357.873919][ T1000]  ? kernfs_get_active+0x12c/0x180
    [  357.874459][ T1000]  ? new_device_store+0x450/0x450 [netdevsim]
    [  357.875111][ T1000]  ? kernfs_get_parent+0x70/0x70
    [  357.875632][ T1000]  ? sysfs_file_ops+0x160/0x160
    [  357.876152][ T1000]  kernfs_fop_write+0x276/0x410
    [  357.876680][ T1000]  ? __sb_start_write+0x1ba/0x2e0
    [  357.877225][ T1000]  vfs_write+0x197/0x4a0
    [  357.877671][ T1000]  ksys_write+0x141/0x1d0
    [ ... ]
    
    Reviewed-by: Jakub Kicinski <kuba@kernel.org>
    Fixes: 79579220566c ("netdevsim: add SR-IOV functionality")
    Fixes: 82c93a87bf8b ("netdevsim: implement couple of testing devlink health reporters")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

diff --git a/drivers/net/netdevsim/bus.c b/drivers/net/netdevsim/bus.c
index e455dd1cf4d0..7971dc4f54f1 100644
--- a/drivers/net/netdevsim/bus.c
+++ b/drivers/net/netdevsim/bus.c
@@ -29,7 +29,7 @@ static int nsim_bus_dev_vfs_enable(struct nsim_bus_dev *nsim_bus_dev,
 {
 	nsim_bus_dev->vfconfigs = kcalloc(num_vfs,
 					  sizeof(struct nsim_vf_config),
-					  GFP_KERNEL);
+					  GFP_KERNEL | __GFP_NOWARN);
 	if (!nsim_bus_dev->vfconfigs)
 		return -ENOMEM;
 	nsim_bus_dev->num_vfs = num_vfs;

commit 6ab63366e1ec4ec1900f253aa64727b4b5f4ee73
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Sat Feb 1 16:43:04 2020 +0000

    netdevsim: disable devlink reload when resources are being used
    
    devlink reload destroys resources and allocates resources again.
    So, when devices and ports resources are being used, devlink reload
    function should not be executed. In order to avoid this race, a new
    lock is added and new_port() and del_port() call devlink_reload_disable()
    and devlink_reload_enable().
    
    Thread0                      Thread1
    {new/del}_port()             {new/del}_port()
    devlink_reload_disable()
                                 devlink_reload_disable()
    devlink_reload_enable()
                                 //here
                                 devlink_reload_enable()
    
    Before Thread1's devlink_reload_enable(), the devlink is already allowed
    to execute reload because Thread0 allows it. devlink reload disable/enable
    variable type is bool. So the above case would exist.
    So, disable/enable should be executed atomically.
    In order to do that, a new lock is used.
    
    Test commands:
        modprobe netdevsim
        echo 1 > /sys/bus/netdevsim/new_device
        while :
        do
            echo 1 > /sys/devices/netdevsim1/new_port &
            echo 1 > /sys/devices/netdevsim1/del_port &
            devlink dev reload netdevsim/netdevsim1 &
        done
    
    Splat looks like:
    [   23.342145][  T932] DEBUG_LOCKS_WARN_ON(mutex_is_locked(lock))
    [   23.342159][  T932] WARNING: CPU: 0 PID: 932 at kernel/locking/mutex-debug.c:103 mutex_destroy+0xc7/0xf0
    [   23.344182][  T932] Modules linked in: netdevsim openvswitch nsh nf_conncount nf_nat nf_conntrack nf_defrag_ipv6 nf_dx
    [   23.346485][  T932] CPU: 0 PID: 932 Comm: devlink Not tainted 5.5.0+ #322
    [   23.347696][  T932] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [   23.348893][  T932] RIP: 0010:mutex_destroy+0xc7/0xf0
    [   23.349505][  T932] Code: e0 07 83 c0 03 38 d0 7c 04 84 d2 75 2e 8b 05 00 ac b0 02 85 c0 75 8b 48 c7 c6 00 5e 07 96 40
    [   23.351887][  T932] RSP: 0018:ffff88806208f810 EFLAGS: 00010286
    [   23.353963][  T932] RAX: dffffc0000000008 RBX: ffff888067f6f2c0 RCX: ffffffff942c4bd4
    [   23.355222][  T932] RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffffffff96dac5b4
    [   23.356169][  T932] RBP: ffff888067f6f000 R08: fffffbfff2d235a5 R09: fffffbfff2d235a5
    [   23.357160][  T932] R10: 0000000000000001 R11: fffffbfff2d235a4 R12: ffff888067f6f208
    [   23.358288][  T932] R13: ffff88806208fa70 R14: ffff888067f6f000 R15: ffff888069ce3800
    [   23.359307][  T932] FS:  00007fe2a3876740(0000) GS:ffff88806c000000(0000) knlGS:0000000000000000
    [   23.360473][  T932] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   23.361319][  T932] CR2: 00005561357aa000 CR3: 000000005227a006 CR4: 00000000000606f0
    [   23.362323][  T932] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [   23.363417][  T932] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    [   23.364414][  T932] Call Trace:
    [   23.364828][  T932]  nsim_dev_reload_destroy+0x77/0xb0 [netdevsim]
    [   23.365655][  T932]  nsim_dev_reload_down+0x84/0xb0 [netdevsim]
    [   23.366433][  T932]  devlink_reload+0xb1/0x350
    [   23.367010][  T932]  genl_rcv_msg+0x580/0xe90
    
    [ ...]
    
    [   23.531729][ T1305] kernel BUG at lib/list_debug.c:53!
    [   23.532523][ T1305] invalid opcode: 0000 [#1] SMP DEBUG_PAGEALLOC KASAN PTI
    [   23.533467][ T1305] CPU: 2 PID: 1305 Comm: bash Tainted: G        W         5.5.0+ #322
    [   23.534962][ T1305] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [   23.536503][ T1305] RIP: 0010:__list_del_entry_valid+0xe6/0x150
    [   23.538346][ T1305] Code: 89 ea 48 c7 c7 00 73 1e 96 e8 df f7 4c ff 0f 0b 48 c7 c7 60 73 1e 96 e8 d1 f7 4c ff 0f 0b 44
    [   23.541068][ T1305] RSP: 0018:ffff888047c27b58 EFLAGS: 00010282
    [   23.542001][ T1305] RAX: 0000000000000054 RBX: ffff888067f6f318 RCX: 0000000000000000
    [   23.543051][ T1305] RDX: 0000000000000054 RSI: 0000000000000008 RDI: ffffed1008f84f61
    [   23.544072][ T1305] RBP: ffff88804aa0fca0 R08: ffffed100d940539 R09: ffffed100d940539
    [   23.545085][ T1305] R10: 0000000000000001 R11: ffffed100d940538 R12: ffff888047c27cb0
    [   23.546422][ T1305] R13: ffff88806208b840 R14: ffffffff981976c0 R15: ffff888067f6f2c0
    [   23.547406][ T1305] FS:  00007f76c0431740(0000) GS:ffff88806c800000(0000) knlGS:0000000000000000
    [   23.548527][ T1305] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   23.549389][ T1305] CR2: 00007f5048f1a2f8 CR3: 000000004b310006 CR4: 00000000000606e0
    [   23.550636][ T1305] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [   23.551578][ T1305] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    [   23.552597][ T1305] Call Trace:
    [   23.553004][ T1305]  mutex_remove_waiter+0x101/0x520
    [   23.553646][ T1305]  __mutex_lock+0xac7/0x14b0
    [   23.554218][ T1305]  ? nsim_dev_port_del+0x4e/0x140 [netdevsim]
    [   23.554908][ T1305]  ? mutex_lock_io_nested+0x1380/0x1380
    [   23.555570][ T1305]  ? _parse_integer+0xf0/0xf0
    [   23.556043][ T1305]  ? kstrtouint+0x86/0x110
    [   23.556504][ T1305]  ? nsim_dev_port_del+0x4e/0x140 [netdevsim]
    [   23.557133][ T1305]  nsim_dev_port_del+0x4e/0x140 [netdevsim]
    [   23.558024][ T1305]  del_port_store+0xcc/0xf0 [netdevsim]
    [ ... ]
    
    Fixes: 75ba029f3c07 ("netdevsim: implement proper devlink reload")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

diff --git a/drivers/net/netdevsim/bus.c b/drivers/net/netdevsim/bus.c
index c086d1e522dc..e455dd1cf4d0 100644
--- a/drivers/net/netdevsim/bus.c
+++ b/drivers/net/netdevsim/bus.c
@@ -97,6 +97,8 @@ new_port_store(struct device *dev, struct device_attribute *attr,
 	       const char *buf, size_t count)
 {
 	struct nsim_bus_dev *nsim_bus_dev = to_nsim_bus_dev(dev);
+	struct nsim_dev *nsim_dev = dev_get_drvdata(dev);
+	struct devlink *devlink;
 	unsigned int port_index;
 	int ret;
 
@@ -106,7 +108,14 @@ new_port_store(struct device *dev, struct device_attribute *attr,
 	ret = kstrtouint(buf, 0, &port_index);
 	if (ret)
 		return ret;
+
+	devlink = priv_to_devlink(nsim_dev);
+
+	mutex_lock(&nsim_bus_dev->nsim_bus_reload_lock);
+	devlink_reload_disable(devlink);
 	ret = nsim_dev_port_add(nsim_bus_dev, port_index);
+	devlink_reload_enable(devlink);
+	mutex_unlock(&nsim_bus_dev->nsim_bus_reload_lock);
 	return ret ? ret : count;
 }
 
@@ -117,6 +126,8 @@ del_port_store(struct device *dev, struct device_attribute *attr,
 	       const char *buf, size_t count)
 {
 	struct nsim_bus_dev *nsim_bus_dev = to_nsim_bus_dev(dev);
+	struct nsim_dev *nsim_dev = dev_get_drvdata(dev);
+	struct devlink *devlink;
 	unsigned int port_index;
 	int ret;
 
@@ -126,7 +137,14 @@ del_port_store(struct device *dev, struct device_attribute *attr,
 	ret = kstrtouint(buf, 0, &port_index);
 	if (ret)
 		return ret;
+
+	devlink = priv_to_devlink(nsim_dev);
+
+	mutex_lock(&nsim_bus_dev->nsim_bus_reload_lock);
+	devlink_reload_disable(devlink);
 	ret = nsim_dev_port_del(nsim_bus_dev, port_index);
+	devlink_reload_enable(devlink);
+	mutex_unlock(&nsim_bus_dev->nsim_bus_reload_lock);
 	return ret ? ret : count;
 }
 
@@ -311,6 +329,7 @@ nsim_bus_dev_new(unsigned int id, unsigned int port_count)
 	nsim_bus_dev->dev.type = &nsim_bus_dev_type;
 	nsim_bus_dev->port_count = port_count;
 	nsim_bus_dev->initial_net = current->nsproxy->net_ns;
+	mutex_init(&nsim_bus_dev->nsim_bus_reload_lock);
 	/* Disallow using nsim_bus_dev */
 	smp_store_release(&nsim_bus_dev->init, false);
 

commit f5cd21605ecd249e5fc715411df22cc1bc877b32
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Sat Feb 1 16:42:54 2020 +0000

    netdevsim: fix using uninitialized resources
    
    When module is being initialized, __init() calls bus_register() and
    driver_register().
    These functions internally create various resources and sysfs files.
    The sysfs files are used for basic operations(add/del device).
    /sys/bus/netdevsim/new_device
    /sys/bus/netdevsim/del_device
    
    These sysfs files use netdevsim resources, they are mostly allocated
    and initialized in ->probe() function, which is nsim_dev_probe().
    But, sysfs files could be executed before ->probe() is finished.
    So, accessing uninitialized data would occur.
    
    Another problem is very similar.
    /sys/bus/netdevsim/new_device internally creates sysfs files.
    /sys/devices/netdevsim<id>/new_port
    /sys/devices/netdevsim<id>/del_port
    
    These sysfs files also use netdevsim resources, they are mostly allocated
    and initialized in creating device routine, which is nsim_bus_dev_new().
    But they also could be executed before nsim_bus_dev_new() is finished.
    So, accessing uninitialized data would occur.
    
    To fix these problems, this patch adds flags, which means whether the
    operation is finished or not.
    The flag variable 'nsim_bus_enable' means whether netdevsim bus was
    initialized or not.
    This is protected by nsim_bus_dev_list_lock.
    The flag variable 'nsim_bus_dev->init' means whether nsim_bus_dev was
    initialized or not.
    This could be used in {new/del}_port_store() with no lock.
    
    Test commands:
        #SHELL1
        modprobe netdevsim
        while :
        do
            echo "1 1" > /sys/bus/netdevsim/new_device
            echo "1 1" > /sys/bus/netdevsim/del_device
        done
    
        #SHELL2
        while :
        do
            echo 1 > /sys/devices/netdevsim1/new_port
            echo 1 > /sys/devices/netdevsim1/del_port
        done
    
    Splat looks like:
    [   47.508954][ T1008] general protection fault, probably for non-canonical address 0xdffffc0000000021: 0000 I
    [   47.510793][ T1008] KASAN: null-ptr-deref in range [0x0000000000000108-0x000000000000010f]
    [   47.511963][ T1008] CPU: 2 PID: 1008 Comm: bash Not tainted 5.5.0+ #322
    [   47.512823][ T1008] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [   47.514041][ T1008] RIP: 0010:__mutex_lock+0x10a/0x14b0
    [   47.514699][ T1008] Code: 08 84 d2 0f 85 7f 12 00 00 44 8b 0d 10 23 65 02 45 85 c9 75 29 49 8d 7f 68 48 b8 00 00 00 0f
    [   47.517163][ T1008] RSP: 0018:ffff888059b4fbb0 EFLAGS: 00010206
    [   47.517802][ T1008] RAX: dffffc0000000000 RBX: 0000000000000000 RCX: 0000000000000000
    [   47.518941][ T1008] RDX: 0000000000000021 RSI: ffffffff85926440 RDI: 0000000000000108
    [   47.519732][ T1008] RBP: ffff888059b4fd30 R08: ffffffffc073fad0 R09: 0000000000000000
    [   47.520729][ T1008] R10: ffff888059b4fd50 R11: ffff88804bb38040 R12: 0000000000000000
    [   47.521702][ T1008] R13: dffffc0000000000 R14: ffffffff871976c0 R15: 00000000000000a0
    [   47.522760][ T1008] FS:  00007fd4be05a740(0000) GS:ffff88806c800000(0000) knlGS:0000000000000000
    [   47.523877][ T1008] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   47.524627][ T1008] CR2: 0000561c82b69cf0 CR3: 0000000065dd6004 CR4: 00000000000606e0
    [   47.527662][ T1008] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [   47.528604][ T1008] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    [   47.529531][ T1008] Call Trace:
    [   47.529874][ T1008]  ? nsim_dev_port_add+0x50/0x150 [netdevsim]
    [   47.530470][ T1008]  ? mutex_lock_io_nested+0x1380/0x1380
    [   47.531018][ T1008]  ? _kstrtoull+0x76/0x160
    [   47.531449][ T1008]  ? _parse_integer+0xf0/0xf0
    [   47.531874][ T1008]  ? kernfs_fop_write+0x1cf/0x410
    [   47.532330][ T1008]  ? sysfs_file_ops+0x160/0x160
    [   47.532773][ T1008]  ? kstrtouint+0x86/0x110
    [   47.533168][ T1008]  ? nsim_dev_port_add+0x50/0x150 [netdevsim]
    [   47.533721][ T1008]  nsim_dev_port_add+0x50/0x150 [netdevsim]
    [   47.534336][ T1008]  ? sysfs_file_ops+0x160/0x160
    [   47.534858][ T1008]  new_port_store+0x99/0xb0 [netdevsim]
    [   47.535439][ T1008]  ? del_port_store+0xb0/0xb0 [netdevsim]
    [   47.536035][ T1008]  ? sysfs_file_ops+0x112/0x160
    [   47.536544][ T1008]  ? sysfs_kf_write+0x3b/0x180
    [   47.537029][ T1008]  kernfs_fop_write+0x276/0x410
    [   47.537548][ T1008]  ? __sb_start_write+0x215/0x2e0
    [   47.538110][ T1008]  vfs_write+0x197/0x4a0
    [ ... ]
    
    Fixes: f9d9db47d3ba ("netdevsim: add bus attributes to add new and delete devices")
    Fixes: 794b2c05ca1c ("netdevsim: extend device attrs to support port addition and deletion")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

diff --git a/drivers/net/netdevsim/bus.c b/drivers/net/netdevsim/bus.c
index 6aeed0c600f8..c086d1e522dc 100644
--- a/drivers/net/netdevsim/bus.c
+++ b/drivers/net/netdevsim/bus.c
@@ -17,6 +17,7 @@
 static DEFINE_IDA(nsim_bus_dev_ids);
 static LIST_HEAD(nsim_bus_dev_list);
 static DEFINE_MUTEX(nsim_bus_dev_list_lock);
+static bool nsim_bus_enable;
 
 static struct nsim_bus_dev *to_nsim_bus_dev(struct device *dev)
 {
@@ -99,6 +100,9 @@ new_port_store(struct device *dev, struct device_attribute *attr,
 	unsigned int port_index;
 	int ret;
 
+	/* Prevent to use nsim_bus_dev before initialization. */
+	if (!smp_load_acquire(&nsim_bus_dev->init))
+		return -EBUSY;
 	ret = kstrtouint(buf, 0, &port_index);
 	if (ret)
 		return ret;
@@ -116,6 +120,9 @@ del_port_store(struct device *dev, struct device_attribute *attr,
 	unsigned int port_index;
 	int ret;
 
+	/* Prevent to use nsim_bus_dev before initialization. */
+	if (!smp_load_acquire(&nsim_bus_dev->init))
+		return -EBUSY;
 	ret = kstrtouint(buf, 0, &port_index);
 	if (ret)
 		return ret;
@@ -179,15 +186,30 @@ new_device_store(struct bus_type *bus, const char *buf, size_t count)
 		pr_err("Format for adding new device is \"id port_count\" (uint uint).\n");
 		return -EINVAL;
 	}
-	nsim_bus_dev = nsim_bus_dev_new(id, port_count);
-	if (IS_ERR(nsim_bus_dev))
-		return PTR_ERR(nsim_bus_dev);
 
 	mutex_lock(&nsim_bus_dev_list_lock);
+	/* Prevent to use resource before initialization. */
+	if (!smp_load_acquire(&nsim_bus_enable)) {
+		err = -EBUSY;
+		goto err;
+	}
+
+	nsim_bus_dev = nsim_bus_dev_new(id, port_count);
+	if (IS_ERR(nsim_bus_dev)) {
+		err = PTR_ERR(nsim_bus_dev);
+		goto err;
+	}
+
+	/* Allow using nsim_bus_dev */
+	smp_store_release(&nsim_bus_dev->init, true);
+
 	list_add_tail(&nsim_bus_dev->list, &nsim_bus_dev_list);
 	mutex_unlock(&nsim_bus_dev_list_lock);
 
 	return count;
+err:
+	mutex_unlock(&nsim_bus_dev_list_lock);
+	return err;
 }
 static BUS_ATTR_WO(new_device);
 
@@ -215,6 +237,11 @@ del_device_store(struct bus_type *bus, const char *buf, size_t count)
 
 	err = -ENOENT;
 	mutex_lock(&nsim_bus_dev_list_lock);
+	/* Prevent to use resource before initialization. */
+	if (!smp_load_acquire(&nsim_bus_enable)) {
+		mutex_unlock(&nsim_bus_dev_list_lock);
+		return -EBUSY;
+	}
 	list_for_each_entry_safe(nsim_bus_dev, tmp, &nsim_bus_dev_list, list) {
 		if (nsim_bus_dev->dev.id != id)
 			continue;
@@ -284,6 +311,8 @@ nsim_bus_dev_new(unsigned int id, unsigned int port_count)
 	nsim_bus_dev->dev.type = &nsim_bus_dev_type;
 	nsim_bus_dev->port_count = port_count;
 	nsim_bus_dev->initial_net = current->nsproxy->net_ns;
+	/* Disallow using nsim_bus_dev */
+	smp_store_release(&nsim_bus_dev->init, false);
 
 	err = device_register(&nsim_bus_dev->dev);
 	if (err)
@@ -299,6 +328,8 @@ nsim_bus_dev_new(unsigned int id, unsigned int port_count)
 
 static void nsim_bus_dev_del(struct nsim_bus_dev *nsim_bus_dev)
 {
+	/* Disallow using nsim_bus_dev */
+	smp_store_release(&nsim_bus_dev->init, false);
 	device_unregister(&nsim_bus_dev->dev);
 	ida_free(&nsim_bus_dev_ids, nsim_bus_dev->dev.id);
 	kfree(nsim_bus_dev);
@@ -320,6 +351,8 @@ int nsim_bus_init(void)
 	err = driver_register(&nsim_driver);
 	if (err)
 		goto err_bus_unregister;
+	/* Allow using resources */
+	smp_store_release(&nsim_bus_enable, true);
 	return 0;
 
 err_bus_unregister:
@@ -331,12 +364,16 @@ void nsim_bus_exit(void)
 {
 	struct nsim_bus_dev *nsim_bus_dev, *tmp;
 
+	/* Disallow using resources */
+	smp_store_release(&nsim_bus_enable, false);
+
 	mutex_lock(&nsim_bus_dev_list_lock);
 	list_for_each_entry_safe(nsim_bus_dev, tmp, &nsim_bus_dev_list, list) {
 		list_del(&nsim_bus_dev->list);
 		nsim_bus_dev_del(nsim_bus_dev);
 	}
 	mutex_unlock(&nsim_bus_dev_list_lock);
+
 	driver_unregister(&nsim_driver);
 	bus_unregister(&nsim_bus);
 }

commit 7b60027bbc6738b067bb9ed732a8c56b0ac430b2
Author: Jiri Pirko <jiri@mellanox.com>
Date:   Sat Oct 5 08:10:32 2019 +0200

    netdevsim: create devlink and netdev instances in namespace
    
    When user does create new netdevsim instance using sysfs bus file,
    create the devlink instance and related netdev instance in the namespace
    of the caller.
    
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/netdevsim/bus.c b/drivers/net/netdevsim/bus.c
index 1a0ff3d7747b..6aeed0c600f8 100644
--- a/drivers/net/netdevsim/bus.c
+++ b/drivers/net/netdevsim/bus.c
@@ -283,6 +283,7 @@ nsim_bus_dev_new(unsigned int id, unsigned int port_count)
 	nsim_bus_dev->dev.bus = &nsim_bus;
 	nsim_bus_dev->dev.type = &nsim_bus_dev_type;
 	nsim_bus_dev->port_count = port_count;
+	nsim_bus_dev->initial_net = current->nsproxy->net_ns;
 
 	err = device_register(&nsim_bus_dev->dev);
 	if (err)

commit 69bbbdc5e1aa0f8e9e5cbc510479cae6dd030621
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Sat May 4 16:12:07 2019 +0800

    netdevsim: Make nsim_num_vf static
    
    Fix sparse warning:
    
    drivers/net/netdevsim/bus.c:253:5: warning:
     symbol 'nsim_num_vf' was not declared. Should it be static?
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Acked-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/netdevsim/bus.c b/drivers/net/netdevsim/bus.c
index fd68eeac574c..1a0ff3d7747b 100644
--- a/drivers/net/netdevsim/bus.c
+++ b/drivers/net/netdevsim/bus.c
@@ -250,7 +250,7 @@ static int nsim_bus_remove(struct device *dev)
 	return 0;
 }
 
-int nsim_num_vf(struct device *dev)
+static int nsim_num_vf(struct device *dev)
 {
 	struct nsim_bus_dev *nsim_bus_dev = to_nsim_bus_dev(dev);
 

commit 6d1474a94ea2641f56c7893eb1e30558fd92f55d
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Mon Apr 29 12:38:07 2019 -0500

    netdevsim: fix fall-through annotation
    
    Replace "pass through" with a proper "fall through" annotation
    in order to fix the following warning:
    
    drivers/net/netdevsim/bus.c: In function ‘new_device_store’:
    drivers/net/netdevsim/bus.c:170:14: warning: this statement may fall through [-Wimplicit-fallthrough=]
       port_count = 1;
       ~~~~~~~~~~~^~~
    drivers/net/netdevsim/bus.c:172:2: note: here
      case 2:
      ^~~~
    
    Warning level 3 was used: -Wimplicit-fallthrough=3
    
    This fix is part of the ongoing efforts to enable
    -Wimplicit-fallthrough
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Acked-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/netdevsim/bus.c b/drivers/net/netdevsim/bus.c
index ae482347b67b..fd68eeac574c 100644
--- a/drivers/net/netdevsim/bus.c
+++ b/drivers/net/netdevsim/bus.c
@@ -168,7 +168,7 @@ new_device_store(struct bus_type *bus, const char *buf, size_t count)
 	switch (err) {
 	case 1:
 		port_count = 1;
-		/* pass through */
+		/* fall through */
 	case 2:
 		if (id > INT_MAX) {
 			pr_err("Value of \"id\" is too big.\n");

commit e05b2d141fef22cfac1928cf0eb6890e5dae4216
Author: Jiri Pirko <jiri@mellanox.com>
Date:   Thu Apr 25 15:59:55 2019 +0200

    netdevsim: move netdev creation/destruction to dev probe
    
    Remove the existing way to create netdevsim over rtnetlink and move the
    netdev creation/destruction to dev probe, so for every probed port,
    a netdevsim-netdev instance is created.
    
    Adjust selftests to work with new interface.
    
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/netdevsim/bus.c b/drivers/net/netdevsim/bus.c
index 549c399f29da..ae482347b67b 100644
--- a/drivers/net/netdevsim/bus.c
+++ b/drivers/net/netdevsim/bus.c
@@ -153,6 +153,9 @@ static struct device_type nsim_bus_dev_type = {
 	.release = nsim_bus_dev_release,
 };
 
+static struct nsim_bus_dev *
+nsim_bus_dev_new(unsigned int id, unsigned int port_count);
+
 static ssize_t
 new_device_store(struct bus_type *bus, const char *buf, size_t count)
 {
@@ -188,6 +191,8 @@ new_device_store(struct bus_type *bus, const char *buf, size_t count)
 }
 static BUS_ATTR_WO(new_device);
 
+static void nsim_bus_dev_del(struct nsim_bus_dev *nsim_bus_dev);
+
 static ssize_t
 del_device_store(struct bus_type *bus, const char *buf, size_t count)
 {
@@ -261,7 +266,8 @@ static struct bus_type nsim_bus = {
 	.num_vf		= nsim_num_vf,
 };
 
-struct nsim_bus_dev *nsim_bus_dev_new(unsigned int id, unsigned int port_count)
+static struct nsim_bus_dev *
+nsim_bus_dev_new(unsigned int id, unsigned int port_count)
 {
 	struct nsim_bus_dev *nsim_bus_dev;
 	int err;
@@ -270,8 +276,7 @@ struct nsim_bus_dev *nsim_bus_dev_new(unsigned int id, unsigned int port_count)
 	if (!nsim_bus_dev)
 		return ERR_PTR(-ENOMEM);
 
-	err = ida_alloc_range(&nsim_bus_dev_ids,
-			      id == ~0 ? 0 : id, id, GFP_KERNEL);
+	err = ida_alloc_range(&nsim_bus_dev_ids, id, id, GFP_KERNEL);
 	if (err < 0)
 		goto err_nsim_bus_dev_free;
 	nsim_bus_dev->dev.id = err;
@@ -291,19 +296,7 @@ struct nsim_bus_dev *nsim_bus_dev_new(unsigned int id, unsigned int port_count)
 	return ERR_PTR(err);
 }
 
-struct nsim_bus_dev *nsim_bus_dev_new_with_ns(struct netdevsim *ns)
-{
-	struct nsim_bus_dev *nsim_bus_dev;
-
-	dev_hold(ns->netdev);
-	rtnl_unlock();
-	nsim_bus_dev = nsim_bus_dev_new(~0, 0);
-	rtnl_lock();
-	dev_put(ns->netdev);
-	return nsim_bus_dev;
-}
-
-void nsim_bus_dev_del(struct nsim_bus_dev *nsim_bus_dev)
+static void nsim_bus_dev_del(struct nsim_bus_dev *nsim_bus_dev)
 {
 	device_unregister(&nsim_bus_dev->dev);
 	ida_free(&nsim_bus_dev_ids, nsim_bus_dev->dev.id);

commit 794b2c05ca1c4ded4a023d11833e3855a0ed6ea8
Author: Jiri Pirko <jiri@mellanox.com>
Date:   Thu Apr 25 15:59:54 2019 +0200

    netdevsim: extend device attrs to support port addition and deletion
    
    In order to test flows in core, it is beneficial to maintain previously
    supported possibility to add and delete ports during netdevsim lifetime.
    Do it by extending device sysfs attrs by "new_port" and "del_port".
    
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/netdevsim/bus.c b/drivers/net/netdevsim/bus.c
index 1ee14e1bb12d..549c399f29da 100644
--- a/drivers/net/netdevsim/bus.c
+++ b/drivers/net/netdevsim/bus.c
@@ -91,8 +91,44 @@ static struct device_attribute nsim_bus_dev_numvfs_attr =
 	__ATTR(sriov_numvfs, 0664, nsim_bus_dev_numvfs_show,
 	       nsim_bus_dev_numvfs_store);
 
+static ssize_t
+new_port_store(struct device *dev, struct device_attribute *attr,
+	       const char *buf, size_t count)
+{
+	struct nsim_bus_dev *nsim_bus_dev = to_nsim_bus_dev(dev);
+	unsigned int port_index;
+	int ret;
+
+	ret = kstrtouint(buf, 0, &port_index);
+	if (ret)
+		return ret;
+	ret = nsim_dev_port_add(nsim_bus_dev, port_index);
+	return ret ? ret : count;
+}
+
+static struct device_attribute nsim_bus_dev_new_port_attr = __ATTR_WO(new_port);
+
+static ssize_t
+del_port_store(struct device *dev, struct device_attribute *attr,
+	       const char *buf, size_t count)
+{
+	struct nsim_bus_dev *nsim_bus_dev = to_nsim_bus_dev(dev);
+	unsigned int port_index;
+	int ret;
+
+	ret = kstrtouint(buf, 0, &port_index);
+	if (ret)
+		return ret;
+	ret = nsim_dev_port_del(nsim_bus_dev, port_index);
+	return ret ? ret : count;
+}
+
+static struct device_attribute nsim_bus_dev_del_port_attr = __ATTR_WO(del_port);
+
 static struct attribute *nsim_bus_dev_attrs[] = {
 	&nsim_bus_dev_numvfs_attr.attr,
+	&nsim_bus_dev_new_port_attr.attr,
+	&nsim_bus_dev_del_port_attr.attr,
 	NULL,
 };
 

commit 8320d145912738655cf631d27aa1829d8b17804e
Author: Jiri Pirko <jiri@mellanox.com>
Date:   Thu Apr 25 15:59:53 2019 +0200

    netdevsim: implement dev probe/remove skeleton with port initialization
    
    Implement netdevsim bus probing of netdevsim devices. For every probed
    device create a devlink instance. According to the user-passed value,
    create a number of ports represented by devlink port instances.
    
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/netdevsim/bus.c b/drivers/net/netdevsim/bus.c
index c30692f17374..1ee14e1bb12d 100644
--- a/drivers/net/netdevsim/bus.c
+++ b/drivers/net/netdevsim/bus.c
@@ -194,6 +194,21 @@ static struct attribute *nsim_bus_attrs[] = {
 };
 ATTRIBUTE_GROUPS(nsim_bus);
 
+static int nsim_bus_probe(struct device *dev)
+{
+	struct nsim_bus_dev *nsim_bus_dev = to_nsim_bus_dev(dev);
+
+	return nsim_dev_probe(nsim_bus_dev);
+}
+
+static int nsim_bus_remove(struct device *dev)
+{
+	struct nsim_bus_dev *nsim_bus_dev = to_nsim_bus_dev(dev);
+
+	nsim_dev_remove(nsim_bus_dev);
+	return 0;
+}
+
 int nsim_num_vf(struct device *dev)
 {
 	struct nsim_bus_dev *nsim_bus_dev = to_nsim_bus_dev(dev);
@@ -205,6 +220,8 @@ static struct bus_type nsim_bus = {
 	.name		= DRV_NAME,
 	.dev_name	= DRV_NAME,
 	.bus_groups	= nsim_bus_groups,
+	.probe		= nsim_bus_probe,
+	.remove		= nsim_bus_remove,
 	.num_vf		= nsim_num_vf,
 };
 
@@ -238,6 +255,18 @@ struct nsim_bus_dev *nsim_bus_dev_new(unsigned int id, unsigned int port_count)
 	return ERR_PTR(err);
 }
 
+struct nsim_bus_dev *nsim_bus_dev_new_with_ns(struct netdevsim *ns)
+{
+	struct nsim_bus_dev *nsim_bus_dev;
+
+	dev_hold(ns->netdev);
+	rtnl_unlock();
+	nsim_bus_dev = nsim_bus_dev_new(~0, 0);
+	rtnl_lock();
+	dev_put(ns->netdev);
+	return nsim_bus_dev;
+}
+
 void nsim_bus_dev_del(struct nsim_bus_dev *nsim_bus_dev)
 {
 	device_unregister(&nsim_bus_dev->dev);

commit f9d9db47d3ba87309e022efa33b438e5ef329411
Author: Jiri Pirko <jiri@mellanox.com>
Date:   Thu Apr 25 15:59:48 2019 +0200

    netdevsim: add bus attributes to add new and delete devices
    
    Add a way to add new netdevsim device on netdevsim bus and also to
    delete existing netdevsim device from the bus. Track the bus devices
    in using a list.
    
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/netdevsim/bus.c b/drivers/net/netdevsim/bus.c
index c50c5ea90555..c30692f17374 100644
--- a/drivers/net/netdevsim/bus.c
+++ b/drivers/net/netdevsim/bus.c
@@ -6,6 +6,8 @@
 #include <linux/device.h>
 #include <linux/idr.h>
 #include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/mutex.h>
 #include <linux/rtnetlink.h>
 #include <linux/slab.h>
 #include <linux/sysfs.h>
@@ -13,6 +15,8 @@
 #include "netdevsim.h"
 
 static DEFINE_IDA(nsim_bus_dev_ids);
+static LIST_HEAD(nsim_bus_dev_list);
+static DEFINE_MUTEX(nsim_bus_dev_list_lock);
 
 static struct nsim_bus_dev *to_nsim_bus_dev(struct device *dev)
 {
@@ -113,6 +117,83 @@ static struct device_type nsim_bus_dev_type = {
 	.release = nsim_bus_dev_release,
 };
 
+static ssize_t
+new_device_store(struct bus_type *bus, const char *buf, size_t count)
+{
+	struct nsim_bus_dev *nsim_bus_dev;
+	unsigned int port_count;
+	unsigned int id;
+	int err;
+
+	err = sscanf(buf, "%u %u", &id, &port_count);
+	switch (err) {
+	case 1:
+		port_count = 1;
+		/* pass through */
+	case 2:
+		if (id > INT_MAX) {
+			pr_err("Value of \"id\" is too big.\n");
+			return -EINVAL;
+		}
+		break;
+	default:
+		pr_err("Format for adding new device is \"id port_count\" (uint uint).\n");
+		return -EINVAL;
+	}
+	nsim_bus_dev = nsim_bus_dev_new(id, port_count);
+	if (IS_ERR(nsim_bus_dev))
+		return PTR_ERR(nsim_bus_dev);
+
+	mutex_lock(&nsim_bus_dev_list_lock);
+	list_add_tail(&nsim_bus_dev->list, &nsim_bus_dev_list);
+	mutex_unlock(&nsim_bus_dev_list_lock);
+
+	return count;
+}
+static BUS_ATTR_WO(new_device);
+
+static ssize_t
+del_device_store(struct bus_type *bus, const char *buf, size_t count)
+{
+	struct nsim_bus_dev *nsim_bus_dev, *tmp;
+	unsigned int id;
+	int err;
+
+	err = sscanf(buf, "%u", &id);
+	switch (err) {
+	case 1:
+		if (id > INT_MAX) {
+			pr_err("Value of \"id\" is too big.\n");
+			return -EINVAL;
+		}
+		break;
+	default:
+		pr_err("Format for deleting device is \"id\" (uint).\n");
+		return -EINVAL;
+	}
+
+	err = -ENOENT;
+	mutex_lock(&nsim_bus_dev_list_lock);
+	list_for_each_entry_safe(nsim_bus_dev, tmp, &nsim_bus_dev_list, list) {
+		if (nsim_bus_dev->dev.id != id)
+			continue;
+		list_del(&nsim_bus_dev->list);
+		nsim_bus_dev_del(nsim_bus_dev);
+		err = 0;
+		break;
+	}
+	mutex_unlock(&nsim_bus_dev_list_lock);
+	return !err ? count : err;
+}
+static BUS_ATTR_WO(del_device);
+
+static struct attribute *nsim_bus_attrs[] = {
+	&bus_attr_new_device.attr,
+	&bus_attr_del_device.attr,
+	NULL
+};
+ATTRIBUTE_GROUPS(nsim_bus);
+
 int nsim_num_vf(struct device *dev)
 {
 	struct nsim_bus_dev *nsim_bus_dev = to_nsim_bus_dev(dev);
@@ -123,10 +204,11 @@ int nsim_num_vf(struct device *dev)
 static struct bus_type nsim_bus = {
 	.name		= DRV_NAME,
 	.dev_name	= DRV_NAME,
+	.bus_groups	= nsim_bus_groups,
 	.num_vf		= nsim_num_vf,
 };
 
-struct nsim_bus_dev *nsim_bus_dev_new(void)
+struct nsim_bus_dev *nsim_bus_dev_new(unsigned int id, unsigned int port_count)
 {
 	struct nsim_bus_dev *nsim_bus_dev;
 	int err;
@@ -135,12 +217,15 @@ struct nsim_bus_dev *nsim_bus_dev_new(void)
 	if (!nsim_bus_dev)
 		return ERR_PTR(-ENOMEM);
 
-	err = ida_alloc(&nsim_bus_dev_ids, GFP_KERNEL);
+	err = ida_alloc_range(&nsim_bus_dev_ids,
+			      id == ~0 ? 0 : id, id, GFP_KERNEL);
 	if (err < 0)
 		goto err_nsim_bus_dev_free;
 	nsim_bus_dev->dev.id = err;
 	nsim_bus_dev->dev.bus = &nsim_bus;
 	nsim_bus_dev->dev.type = &nsim_bus_dev_type;
+	nsim_bus_dev->port_count = port_count;
+
 	err = device_register(&nsim_bus_dev->dev);
 	if (err)
 		goto err_nsim_bus_dev_id_free;
@@ -185,6 +270,14 @@ int nsim_bus_init(void)
 
 void nsim_bus_exit(void)
 {
+	struct nsim_bus_dev *nsim_bus_dev, *tmp;
+
+	mutex_lock(&nsim_bus_dev_list_lock);
+	list_for_each_entry_safe(nsim_bus_dev, tmp, &nsim_bus_dev_list, list) {
+		list_del(&nsim_bus_dev->list);
+		nsim_bus_dev_del(nsim_bus_dev);
+	}
+	mutex_unlock(&nsim_bus_dev_list_lock);
 	driver_unregister(&nsim_driver);
 	bus_unregister(&nsim_bus);
 }

commit 57ce9774951360aad66c48b1b30683ffb1b23f61
Author: Jiri Pirko <jiri@mellanox.com>
Date:   Thu Apr 25 15:59:47 2019 +0200

    netdevsim: use ida for bus device ids
    
    Instead of increments of u32 value, use ida to manage bus device ids.
    
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/netdevsim/bus.c b/drivers/net/netdevsim/bus.c
index 5b5a9b0831a9..c50c5ea90555 100644
--- a/drivers/net/netdevsim/bus.c
+++ b/drivers/net/netdevsim/bus.c
@@ -4,6 +4,7 @@
  */
 
 #include <linux/device.h>
+#include <linux/idr.h>
 #include <linux/kernel.h>
 #include <linux/rtnetlink.h>
 #include <linux/slab.h>
@@ -11,7 +12,7 @@
 
 #include "netdevsim.h"
 
-static u32 nsim_bus_dev_id;
+static DEFINE_IDA(nsim_bus_dev_ids);
 
 static struct nsim_bus_dev *to_nsim_bus_dev(struct device *dev)
 {
@@ -134,14 +135,19 @@ struct nsim_bus_dev *nsim_bus_dev_new(void)
 	if (!nsim_bus_dev)
 		return ERR_PTR(-ENOMEM);
 
-	nsim_bus_dev->dev.id = nsim_bus_dev_id++;
+	err = ida_alloc(&nsim_bus_dev_ids, GFP_KERNEL);
+	if (err < 0)
+		goto err_nsim_bus_dev_free;
+	nsim_bus_dev->dev.id = err;
 	nsim_bus_dev->dev.bus = &nsim_bus;
 	nsim_bus_dev->dev.type = &nsim_bus_dev_type;
 	err = device_register(&nsim_bus_dev->dev);
 	if (err)
-		goto err_nsim_bus_dev_free;
+		goto err_nsim_bus_dev_id_free;
 	return nsim_bus_dev;
 
+err_nsim_bus_dev_id_free:
+	ida_free(&nsim_bus_dev_ids, nsim_bus_dev->dev.id);
 err_nsim_bus_dev_free:
 	kfree(nsim_bus_dev);
 	return ERR_PTR(err);
@@ -150,6 +156,7 @@ struct nsim_bus_dev *nsim_bus_dev_new(void)
 void nsim_bus_dev_del(struct nsim_bus_dev *nsim_bus_dev)
 {
 	device_unregister(&nsim_bus_dev->dev);
+	ida_free(&nsim_bus_dev_ids, nsim_bus_dev->dev.id);
 	kfree(nsim_bus_dev);
 }
 

commit 23d415dae924498dcd26acf2850715dd1f419550
Author: Jiri Pirko <jiri@mellanox.com>
Date:   Thu Apr 25 15:59:46 2019 +0200

    netdevsim: add stub netdevsim driver implementation
    
    In order to bus probing to work correctly, register a simple  netdevsim
    driver implementation.
    
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/netdevsim/bus.c b/drivers/net/netdevsim/bus.c
index 7e83a2e856d3..5b5a9b0831a9 100644
--- a/drivers/net/netdevsim/bus.c
+++ b/drivers/net/netdevsim/bus.c
@@ -153,12 +153,31 @@ void nsim_bus_dev_del(struct nsim_bus_dev *nsim_bus_dev)
 	kfree(nsim_bus_dev);
 }
 
+static struct device_driver nsim_driver = {
+	.name		= DRV_NAME,
+	.bus		= &nsim_bus,
+	.owner		= THIS_MODULE,
+};
+
 int nsim_bus_init(void)
 {
-	return bus_register(&nsim_bus);
+	int err;
+
+	err = bus_register(&nsim_bus);
+	if (err)
+		return err;
+	err = driver_register(&nsim_driver);
+	if (err)
+		goto err_bus_unregister;
+	return 0;
+
+err_bus_unregister:
+	bus_unregister(&nsim_bus);
+	return err;
 }
 
 void nsim_bus_exit(void)
 {
+	driver_unregister(&nsim_driver);
 	bus_unregister(&nsim_bus);
 }

commit 40e4fe4ce115c409c3e2fbb247085103ef1cc755
Author: Jiri Pirko <jiri@mellanox.com>
Date:   Thu Apr 25 15:59:45 2019 +0200

    netdevsim: move device registration and related code to bus.c
    
    Move netdevsim device registration into bus.c and alongside with that
    the related sysfs attributes. Introduce new struct nsim_bus_dev to
    represent a netdevsim device on netdevsim bus.
    
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/netdevsim/bus.c b/drivers/net/netdevsim/bus.c
index 26b866b72afc..7e83a2e856d3 100644
--- a/drivers/net/netdevsim/bus.c
+++ b/drivers/net/netdevsim/bus.c
@@ -4,15 +4,155 @@
  */
 
 #include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/rtnetlink.h>
+#include <linux/slab.h>
+#include <linux/sysfs.h>
 
 #include "netdevsim.h"
 
-struct bus_type nsim_bus = {
+static u32 nsim_bus_dev_id;
+
+static struct nsim_bus_dev *to_nsim_bus_dev(struct device *dev)
+{
+	return container_of(dev, struct nsim_bus_dev, dev);
+}
+
+static int nsim_bus_dev_vfs_enable(struct nsim_bus_dev *nsim_bus_dev,
+				   unsigned int num_vfs)
+{
+	nsim_bus_dev->vfconfigs = kcalloc(num_vfs,
+					  sizeof(struct nsim_vf_config),
+					  GFP_KERNEL);
+	if (!nsim_bus_dev->vfconfigs)
+		return -ENOMEM;
+	nsim_bus_dev->num_vfs = num_vfs;
+
+	return 0;
+}
+
+static void nsim_bus_dev_vfs_disable(struct nsim_bus_dev *nsim_bus_dev)
+{
+	kfree(nsim_bus_dev->vfconfigs);
+	nsim_bus_dev->vfconfigs = NULL;
+	nsim_bus_dev->num_vfs = 0;
+}
+
+static ssize_t
+nsim_bus_dev_numvfs_store(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct nsim_bus_dev *nsim_bus_dev = to_nsim_bus_dev(dev);
+	unsigned int num_vfs;
+	int ret;
+
+	ret = kstrtouint(buf, 0, &num_vfs);
+	if (ret)
+		return ret;
+
+	rtnl_lock();
+	if (nsim_bus_dev->num_vfs == num_vfs)
+		goto exit_good;
+	if (nsim_bus_dev->num_vfs && num_vfs) {
+		ret = -EBUSY;
+		goto exit_unlock;
+	}
+
+	if (num_vfs) {
+		ret = nsim_bus_dev_vfs_enable(nsim_bus_dev, num_vfs);
+		if (ret)
+			goto exit_unlock;
+	} else {
+		nsim_bus_dev_vfs_disable(nsim_bus_dev);
+	}
+exit_good:
+	ret = count;
+exit_unlock:
+	rtnl_unlock();
+
+	return ret;
+}
+
+static ssize_t
+nsim_bus_dev_numvfs_show(struct device *dev,
+			 struct device_attribute *attr, char *buf)
+{
+	struct nsim_bus_dev *nsim_bus_dev = to_nsim_bus_dev(dev);
+
+	return sprintf(buf, "%u\n", nsim_bus_dev->num_vfs);
+}
+
+static struct device_attribute nsim_bus_dev_numvfs_attr =
+	__ATTR(sriov_numvfs, 0664, nsim_bus_dev_numvfs_show,
+	       nsim_bus_dev_numvfs_store);
+
+static struct attribute *nsim_bus_dev_attrs[] = {
+	&nsim_bus_dev_numvfs_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group nsim_bus_dev_attr_group = {
+	.attrs = nsim_bus_dev_attrs,
+};
+
+static const struct attribute_group *nsim_bus_dev_attr_groups[] = {
+	&nsim_bus_dev_attr_group,
+	NULL,
+};
+
+static void nsim_bus_dev_release(struct device *dev)
+{
+	struct nsim_bus_dev *nsim_bus_dev = to_nsim_bus_dev(dev);
+
+	nsim_bus_dev_vfs_disable(nsim_bus_dev);
+}
+
+static struct device_type nsim_bus_dev_type = {
+	.groups = nsim_bus_dev_attr_groups,
+	.release = nsim_bus_dev_release,
+};
+
+int nsim_num_vf(struct device *dev)
+{
+	struct nsim_bus_dev *nsim_bus_dev = to_nsim_bus_dev(dev);
+
+	return nsim_bus_dev->num_vfs;
+}
+
+static struct bus_type nsim_bus = {
 	.name		= DRV_NAME,
 	.dev_name	= DRV_NAME,
 	.num_vf		= nsim_num_vf,
 };
 
+struct nsim_bus_dev *nsim_bus_dev_new(void)
+{
+	struct nsim_bus_dev *nsim_bus_dev;
+	int err;
+
+	nsim_bus_dev = kzalloc(sizeof(*nsim_bus_dev), GFP_KERNEL);
+	if (!nsim_bus_dev)
+		return ERR_PTR(-ENOMEM);
+
+	nsim_bus_dev->dev.id = nsim_bus_dev_id++;
+	nsim_bus_dev->dev.bus = &nsim_bus;
+	nsim_bus_dev->dev.type = &nsim_bus_dev_type;
+	err = device_register(&nsim_bus_dev->dev);
+	if (err)
+		goto err_nsim_bus_dev_free;
+	return nsim_bus_dev;
+
+err_nsim_bus_dev_free:
+	kfree(nsim_bus_dev);
+	return ERR_PTR(err);
+}
+
+void nsim_bus_dev_del(struct nsim_bus_dev *nsim_bus_dev)
+{
+	device_unregister(&nsim_bus_dev->dev);
+	kfree(nsim_bus_dev);
+}
+
 int nsim_bus_init(void)
 {
 	return bus_register(&nsim_bus);

commit 925f5afedb93f7c80958c6bf7ce6cc31542076dc
Author: Jiri Pirko <jiri@mellanox.com>
Date:   Thu Apr 25 15:59:44 2019 +0200

    netdevsim: put netdevsim bus code into separate file
    
    As the code related to netdevsim bus is going to get bigger, move the
    existing code to a separate file.
    
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/netdevsim/bus.c b/drivers/net/netdevsim/bus.c
new file mode 100644
index 000000000000..26b866b72afc
--- /dev/null
+++ b/drivers/net/netdevsim/bus.c
@@ -0,0 +1,24 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (C) 2017 Netronome Systems, Inc.
+ * Copyright (C) 2019 Mellanox Technologies. All rights reserved
+ */
+
+#include <linux/device.h>
+
+#include "netdevsim.h"
+
+struct bus_type nsim_bus = {
+	.name		= DRV_NAME,
+	.dev_name	= DRV_NAME,
+	.num_vf		= nsim_num_vf,
+};
+
+int nsim_bus_init(void)
+{
+	return bus_register(&nsim_bus);
+}
+
+void nsim_bus_exit(void)
+{
+	bus_unregister(&nsim_bus);
+}
