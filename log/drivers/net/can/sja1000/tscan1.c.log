commit 1ccea77e2a2687cae171b7987eb44730ec8c6d5f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 15:51:43 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 13
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not see http www gnu org licenses
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details [based]
      [from] [clk] [highbank] [c] you should have received a copy of the
      gnu general public license along with this program if not see http
      www gnu org licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 355 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Jilayne Lovejoy <opensource@jilayne.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190519154041.837383322@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/can/sja1000/tscan1.c b/drivers/net/can/sja1000/tscan1.c
index 79572457a2d6..6ea802c66124 100644
--- a/drivers/net/can/sja1000/tscan1.c
+++ b/drivers/net/can/sja1000/tscan1.c
@@ -1,20 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * tscan1.c: driver for Technologic Systems TS-CAN1 PC104 boards
  *
  * Copyright 2010 Andre B. Oliveira
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 /*

commit ae5ac9b3b8a942724da578dd5a4112b6d2f7d1bb
Author: William Breathitt Gray <vilhelm.gray@gmail.com>
Date:   Wed Jun 1 08:59:51 2016 -0400

    can: tscan1: Utilize the module_isa_driver macro
    
    This driver does not do anything special in module init/exit. This patch
    eliminates the module init/exit boilerplate code by utilizing the
    module_isa_driver macro.
    
    Signed-off-by: William Breathitt Gray <vilhelm.gray@gmail.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/sja1000/tscan1.c b/drivers/net/can/sja1000/tscan1.c
index 76513dd780c7..79572457a2d6 100644
--- a/drivers/net/can/sja1000/tscan1.c
+++ b/drivers/net/can/sja1000/tscan1.c
@@ -203,14 +203,4 @@ static struct isa_driver tscan1_isa_driver = {
 	},
 };
 
-static int __init tscan1_init(void)
-{
-	return isa_register_driver(&tscan1_isa_driver, TSCAN1_MAXDEV);
-}
-module_init(tscan1_init);
-
-static void __exit tscan1_exit(void)
-{
-	isa_unregister_driver(&tscan1_isa_driver);
-}
-module_exit(tscan1_exit);
+module_isa_driver(tscan1_isa_driver, TSCAN1_MAXDEV);

commit 3c8ac0f2ad53a96ac58efe7c98fac2986d081dfc
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Dec 3 09:22:44 2012 -0500

    can: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Wolfgang Grandegger <wg@grandegger.com>
    Cc: Marc Kleine-Budde <mkl@pengutronix.de>
    Cc: linux-can@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/can/sja1000/tscan1.c b/drivers/net/can/sja1000/tscan1.c
index 9756099a883a..76513dd780c7 100644
--- a/drivers/net/can/sja1000/tscan1.c
+++ b/drivers/net/can/sja1000/tscan1.c
@@ -71,7 +71,7 @@ MODULE_LICENSE("GPL");
 #define TSCAN1_SJA1000_XTAL 16000000
 
 /* SJA1000 IO base addresses */
-static const unsigned short tscan1_sja1000_addresses[] __devinitconst = {
+static const unsigned short tscan1_sja1000_addresses[] = {
 	0x100, 0x120, 0x180, 0x1a0, 0x200, 0x240, 0x280, 0x320
 };
 
@@ -88,7 +88,7 @@ static void tscan1_write(const struct sja1000_priv *priv, int reg, u8 val)
 }
 
 /* Probe for a TS-CAN1 board with JP2:JP1 jumper setting ID */
-static int __devinit tscan1_probe(struct device *dev, unsigned id)
+static int tscan1_probe(struct device *dev, unsigned id)
 {
 	struct net_device *netdev;
 	struct sja1000_priv *priv;
@@ -171,7 +171,7 @@ static int __devinit tscan1_probe(struct device *dev, unsigned id)
 	return -ENXIO;
 }
 
-static int __devexit tscan1_remove(struct device *dev, unsigned id /*unused*/)
+static int tscan1_remove(struct device *dev, unsigned id /*unused*/)
 {
 	struct net_device *netdev;
 	struct sja1000_priv *priv;
@@ -197,7 +197,7 @@ static int __devexit tscan1_remove(struct device *dev, unsigned id /*unused*/)
 
 static struct isa_driver tscan1_isa_driver = {
 	.probe = tscan1_probe,
-	.remove = __devexit_p(tscan1_remove),
+	.remove = tscan1_remove,
 	.driver = {
 		.name = "tscan1",
 	},

commit 2d3359f8b9e6b3d6339b7e72f8e82275058eb13c
Author: Andre B. Oliveira <anbadeol@gmail.com>
Date:   Mon Oct 18 21:47:27 2010 +0000

    can: tscan1: add driver for TS-CAN1 boards
    
    Add driver for Technologic Systems TS-CAN1 PC104 peripheral boards.
    
    Signed-off-by: Andre B. Oliveira <anbadeol@gmail.com>
    Acked-by: Wolfgang Grandegger <wg@grandegger.com>
    Reviewed-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/sja1000/tscan1.c b/drivers/net/can/sja1000/tscan1.c
new file mode 100644
index 000000000000..9756099a883a
--- /dev/null
+++ b/drivers/net/can/sja1000/tscan1.c
@@ -0,0 +1,216 @@
+/*
+ * tscan1.c: driver for Technologic Systems TS-CAN1 PC104 boards
+ *
+ * Copyright 2010 Andre B. Oliveira
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * References:
+ * - Getting started with TS-CAN1, Technologic Systems, Jun 2009
+ *	http://www.embeddedarm.com/documentation/ts-can1-manual.pdf
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/isa.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include "sja1000.h"
+
+MODULE_DESCRIPTION("Driver for Technologic Systems TS-CAN1 PC104 boards");
+MODULE_AUTHOR("Andre B. Oliveira <anbadeol@gmail.com>");
+MODULE_LICENSE("GPL");
+
+/* Maximum number of boards (one in each JP1:JP2 setting of IO address) */
+#define TSCAN1_MAXDEV 4
+
+/* PLD registers address offsets */
+#define TSCAN1_ID1	0
+#define TSCAN1_ID2	1
+#define TSCAN1_VERSION	2
+#define TSCAN1_LED	3
+#define TSCAN1_PAGE	4
+#define TSCAN1_MODE	5
+#define TSCAN1_JUMPERS	6
+
+/* PLD board identifier registers magic values */
+#define TSCAN1_ID1_VALUE 0xf6
+#define TSCAN1_ID2_VALUE 0xb9
+
+/* PLD mode register SJA1000 IO enable bit */
+#define TSCAN1_MODE_ENABLE 0x40
+
+/* PLD jumpers register bits */
+#define TSCAN1_JP4 0x10
+#define TSCAN1_JP5 0x20
+
+/* PLD IO base addresses start */
+#define TSCAN1_PLD_ADDRESS 0x150
+
+/* PLD register space size */
+#define TSCAN1_PLD_SIZE 8
+
+/* SJA1000 register space size */
+#define TSCAN1_SJA1000_SIZE 32
+
+/* SJA1000 crystal frequency (16MHz) */
+#define TSCAN1_SJA1000_XTAL 16000000
+
+/* SJA1000 IO base addresses */
+static const unsigned short tscan1_sja1000_addresses[] __devinitconst = {
+	0x100, 0x120, 0x180, 0x1a0, 0x200, 0x240, 0x280, 0x320
+};
+
+/* Read SJA1000 register */
+static u8 tscan1_read(const struct sja1000_priv *priv, int reg)
+{
+	return inb((unsigned long)priv->reg_base + reg);
+}
+
+/* Write SJA1000 register */
+static void tscan1_write(const struct sja1000_priv *priv, int reg, u8 val)
+{
+	outb(val, (unsigned long)priv->reg_base + reg);
+}
+
+/* Probe for a TS-CAN1 board with JP2:JP1 jumper setting ID */
+static int __devinit tscan1_probe(struct device *dev, unsigned id)
+{
+	struct net_device *netdev;
+	struct sja1000_priv *priv;
+	unsigned long pld_base, sja1000_base;
+	int irq, i;
+
+	pld_base = TSCAN1_PLD_ADDRESS + id * TSCAN1_PLD_SIZE;
+	if (!request_region(pld_base, TSCAN1_PLD_SIZE, dev_name(dev)))
+		return -EBUSY;
+
+	if (inb(pld_base + TSCAN1_ID1) != TSCAN1_ID1_VALUE ||
+	    inb(pld_base + TSCAN1_ID2) != TSCAN1_ID2_VALUE) {
+		release_region(pld_base, TSCAN1_PLD_SIZE);
+		return -ENODEV;
+	}
+
+	switch (inb(pld_base + TSCAN1_JUMPERS) & (TSCAN1_JP4 | TSCAN1_JP5)) {
+	case TSCAN1_JP4:
+		irq = 6;
+		break;
+	case TSCAN1_JP5:
+		irq = 7;
+		break;
+	case TSCAN1_JP4 | TSCAN1_JP5:
+		irq = 5;
+		break;
+	default:
+		dev_err(dev, "invalid JP4:JP5 setting (no IRQ)\n");
+		release_region(pld_base, TSCAN1_PLD_SIZE);
+		return -EINVAL;
+	}
+
+	netdev = alloc_sja1000dev(0);
+	if (!netdev) {
+		release_region(pld_base, TSCAN1_PLD_SIZE);
+		return -ENOMEM;
+	}
+
+	dev_set_drvdata(dev, netdev);
+	SET_NETDEV_DEV(netdev, dev);
+
+	netdev->base_addr = pld_base;
+	netdev->irq = irq;
+
+	priv = netdev_priv(netdev);
+	priv->read_reg = tscan1_read;
+	priv->write_reg = tscan1_write;
+	priv->can.clock.freq = TSCAN1_SJA1000_XTAL / 2;
+	priv->cdr = CDR_CBP | CDR_CLK_OFF;
+	priv->ocr = OCR_TX0_PUSHPULL;
+
+	/* Select the first SJA1000 IO address that is free and that works */
+	for (i = 0; i < ARRAY_SIZE(tscan1_sja1000_addresses); i++) {
+		sja1000_base = tscan1_sja1000_addresses[i];
+		if (!request_region(sja1000_base, TSCAN1_SJA1000_SIZE,
+								dev_name(dev)))
+			continue;
+
+		/* Set SJA1000 IO base address and enable it */
+		outb(TSCAN1_MODE_ENABLE | i, pld_base + TSCAN1_MODE);
+
+		priv->reg_base = (void __iomem *)sja1000_base;
+		if (!register_sja1000dev(netdev)) {
+			/* SJA1000 probe succeeded; turn LED off and return */
+			outb(0, pld_base + TSCAN1_LED);
+			netdev_info(netdev, "TS-CAN1 at 0x%lx 0x%lx irq %d\n",
+						pld_base, sja1000_base, irq);
+			return 0;
+		}
+
+		/* SJA1000 probe failed; release and try next address */
+		outb(0, pld_base + TSCAN1_MODE);
+		release_region(sja1000_base, TSCAN1_SJA1000_SIZE);
+	}
+
+	dev_err(dev, "failed to assign SJA1000 IO address\n");
+	dev_set_drvdata(dev, NULL);
+	free_sja1000dev(netdev);
+	release_region(pld_base, TSCAN1_PLD_SIZE);
+	return -ENXIO;
+}
+
+static int __devexit tscan1_remove(struct device *dev, unsigned id /*unused*/)
+{
+	struct net_device *netdev;
+	struct sja1000_priv *priv;
+	unsigned long pld_base, sja1000_base;
+
+	netdev = dev_get_drvdata(dev);
+	unregister_sja1000dev(netdev);
+	dev_set_drvdata(dev, NULL);
+
+	priv = netdev_priv(netdev);
+	pld_base = netdev->base_addr;
+	sja1000_base = (unsigned long)priv->reg_base;
+
+	outb(0, pld_base + TSCAN1_MODE);	/* disable SJA1000 IO space */
+
+	release_region(sja1000_base, TSCAN1_SJA1000_SIZE);
+	release_region(pld_base, TSCAN1_PLD_SIZE);
+
+	free_sja1000dev(netdev);
+
+	return 0;
+}
+
+static struct isa_driver tscan1_isa_driver = {
+	.probe = tscan1_probe,
+	.remove = __devexit_p(tscan1_remove),
+	.driver = {
+		.name = "tscan1",
+	},
+};
+
+static int __init tscan1_init(void)
+{
+	return isa_register_driver(&tscan1_isa_driver, TSCAN1_MAXDEV);
+}
+module_init(tscan1_init);
+
+static void __exit tscan1_exit(void)
+{
+	isa_unregister_driver(&tscan1_isa_driver);
+}
+module_exit(tscan1_exit);
