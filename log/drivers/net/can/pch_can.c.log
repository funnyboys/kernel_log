commit 2b72c9e36c286abc78605e08d2985ee967986b89
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:54 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 340
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2 of the license this program
      is distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 15 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000437.052642892@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index c1317889d3d8..db41dddd5771 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -1,18 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 1999 - 2010 Intel Corporation.
  * Copyright (C) 2010 LAPIS SEMICONDUCTOR CO., LTD.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 #include <linux/interrupt.h>

commit ffd461f80d536336811d573f197f3e6d9872d054
Author: Oliver Hartkopp <socketcan@hartkopp.net>
Date:   Sat Nov 21 18:41:20 2015 +0100

    can: fix assignment of error location in CAN error messages
    
    As Dan Carpenter reported in http://marc.info/?l=linux-can&m=144793696016187
    the assignment of the error location in CAN error messages had some bit wise
    overlaps. Indeed the value to be assigned in data[3] is no bitfield but defines
    a single value which points to a location inside the CAN frame on the wire.
    
    This patch fixes the assignments for the error locations in error messages.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index e187ca783da0..c1317889d3d8 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -559,8 +559,7 @@ static void pch_can_error(struct net_device *ndev, u32 status)
 		stats->rx_errors++;
 		break;
 	case PCH_CRC_ERR:
-		cf->data[3] |= CAN_ERR_PROT_LOC_CRC_SEQ |
-			       CAN_ERR_PROT_LOC_CRC_DEL;
+		cf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;
 		priv->can.can_stats.bus_error++;
 		stats->rx_errors++;
 		break;

commit be38a6f9f4093b0f1fa9e7d8cb47d588bc117c21
Author: Andri Yngvason <andri.yngvason@marel.com>
Date:   Fri Jan 16 14:30:28 2015 +0000

    can: move can_stats.bus_off++ from can_bus_off into can_change_state
    
    In order to be able to move the stats increment from can_bus_off() into
    can_change_state(), the increment had to be moved back into code that was using
    can_bus_off() but not can_change_state().
    
    As a side-effect, this patch fixes the following bugs:
     * Redundant call to can_bus_off() in c_can.
     * Bus-off counted twice in xilinx_can.
    
    Signed-off-by: Andri Yngvason <andri.yngvason@marel.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index a67eb01f3028..e187ca783da0 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -505,6 +505,7 @@ static void pch_can_error(struct net_device *ndev, u32 status)
 		pch_can_set_rx_all(priv, 0);
 		state = CAN_STATE_BUS_OFF;
 		cf->can_id |= CAN_ERR_BUSOFF;
+		priv->can.can_stats.bus_off++;
 		can_bus_off(ndev);
 	}
 

commit 9baa3c34ac4e27f7e062f266f50cc5dbea26a6c1
Author: Benoit Taine <benoit.taine@lip6.fr>
Date:   Fri Aug 8 15:56:03 2014 +0200

    PCI: Remove DEFINE_PCI_DEVICE_TABLE macro use
    
    We should prefer `struct pci_device_id` over `DEFINE_PCI_DEVICE_TABLE` to
    meet kernel coding style guidelines.  This issue was reported by checkpatch.
    
    A simplified version of the semantic patch that makes this change is as
    follows (http://coccinelle.lip6.fr/):
    
    // <smpl>
    
    @@
    identifier i;
    declarer name DEFINE_PCI_DEVICE_TABLE;
    initializer z;
    @@
    
    - DEFINE_PCI_DEVICE_TABLE(i)
    + const struct pci_device_id i[]
    = z;
    
    // </smpl>
    
    [bhelgaas: add semantic patch]
    Signed-off-by: Benoit Taine <benoit.taine@lip6.fr>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 6472562efedc..a67eb01f3028 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -194,7 +194,7 @@ static const struct can_bittiming_const pch_can_bittiming_const = {
 	.brp_inc = 1,
 };
 
-static DEFINE_PCI_DEVICE_TABLE(pch_pci_tbl) = {
+static const struct pci_device_id pch_pci_tbl[] = {
 	{PCI_VENDOR_ID_INTEL, 0x8818, PCI_ANY_ID, PCI_ANY_ID,},
 	{0,}
 };

commit c971fa2ae42e73e9ccc2f5e93f268c8742da4c5d
Author: Oliver Hartkopp <socketcan@hartkopp.net>
Date:   Fri Mar 7 09:23:41 2014 +0100

    can: Unify MTU settings for CAN interfaces
    
    CAN interfaces only support MTU values of 16 (CAN 2.0) and 72 (CAN FD).
    Setting the MTU to other values is pointless but it does not really hurt.
    With the introduction of the CAN FD support in drivers/net/can a new
    function to switch the MTU for CAN FD has been introduced.
    
    This patch makes use of this can_change_mtu() function to check for correct
    MTU settings also in legacy CAN (2.0) devices.
    
    Signed-off-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 6c077eb87b5e..6472562efedc 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -950,6 +950,7 @@ static const struct net_device_ops pch_can_netdev_ops = {
 	.ndo_open		= pch_can_open,
 	.ndo_stop		= pch_close,
 	.ndo_start_xmit		= pch_xmit,
+	.ndo_change_mtu		= can_change_mtu,
 };
 
 static void pch_can_remove(struct pci_dev *pdev)

commit a81ab36bf52d0ca3a32251a923be1dbced726141
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Jan 8 15:32:47 2014 -0500

    drivers/net: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.   Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    This covers everything under drivers/net except for wireless, which
    has been submitted separately.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 79e8699fd35a..6c077eb87b5e 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -21,7 +21,6 @@
 #include <linux/module.h>
 #include <linux/sched.h>
 #include <linux/pci.h>
-#include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/errno.h>

commit 05780d9808f72dc28a5c3602e11a7c53aef972ad
Author: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Date:   Fri Dec 6 06:28:45 2013 -0800

    can: Fix FSF address in file headers
    
    Several files refer to an old address for the Free Software Foundation
    in the file header comment.  Resolve by replacing the address with
    the URL <http://www.gnu.org/licenses/> so that we do not have to keep
    updating the header comments anytime the address changes.
    
    CC: Wolfgang Grandegger <wg@grandegger.com>
    CC: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 5f0e9b3bfa7b..79e8699fd35a 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -12,8 +12,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 #include <linux/interrupt.h>

commit aa86858c356beb72af86107612ac854c0150d6db
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Sep 10 20:10:35 2013 +0900

    can: pch_can: remove unnecessary pci_set_drvdata()
    
    The driver core clears the driver data to NULL after device_release
    or on probe failure. Thus, it is not needed to manually clear the
    device driver data to NULL.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 5c314a961970..5f0e9b3bfa7b 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -964,7 +964,6 @@ static void pch_can_remove(struct pci_dev *pdev)
 		pci_disable_msi(priv->dev);
 	pci_release_regions(pdev);
 	pci_disable_device(pdev);
-	pci_set_drvdata(pdev, NULL);
 	pch_can_reset(priv);
 	pci_iounmap(pdev, priv->regs);
 	free_candev(priv->ndev);

commit ee50e135aeb048b90fab662e661c58b67341830b
Author: Olivier Sobrie <olivier@sobrie.be>
Date:   Fri Jan 18 09:32:41 2013 +0100

    can: pch_can: fix invalid error codes
    
    Errors in CAN protocol (location) are reported in data[3] of the can
    frame instead of data[2].
    
    Cc: linux-stable <stable@vger.kernel.org>
    Signed-off-by: Olivier Sobrie <olivier@sobrie.be>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 7d1748575b1f..5c314a961970 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -560,7 +560,7 @@ static void pch_can_error(struct net_device *ndev, u32 status)
 		stats->rx_errors++;
 		break;
 	case PCH_CRC_ERR:
-		cf->data[2] |= CAN_ERR_PROT_LOC_CRC_SEQ |
+		cf->data[3] |= CAN_ERR_PROT_LOC_CRC_SEQ |
 			       CAN_ERR_PROT_LOC_CRC_DEL;
 		priv->can.can_stats.bus_error++;
 		stats->rx_errors++;

commit 3c8ac0f2ad53a96ac58efe7c98fac2986d081dfc
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Dec 3 09:22:44 2012 -0500

    can: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Wolfgang Grandegger <wg@grandegger.com>
    Cc: Marc Kleine-Budde <mkl@pengutronix.de>
    Cc: linux-can@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 48b3d62b34cb..7d1748575b1f 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -954,7 +954,7 @@ static const struct net_device_ops pch_can_netdev_ops = {
 	.ndo_start_xmit		= pch_xmit,
 };
 
-static void __devexit pch_can_remove(struct pci_dev *pdev)
+static void pch_can_remove(struct pci_dev *pdev)
 {
 	struct net_device *ndev = pci_get_drvdata(pdev);
 	struct pch_can_priv *priv = netdev_priv(ndev);
@@ -1178,7 +1178,7 @@ static int pch_can_get_berr_counter(const struct net_device *dev,
 	return 0;
 }
 
-static int __devinit pch_can_probe(struct pci_dev *pdev,
+static int pch_can_probe(struct pci_dev *pdev,
 				   const struct pci_device_id *id)
 {
 	struct net_device *ndev;
@@ -1269,7 +1269,7 @@ static struct pci_driver pch_can_pci_driver = {
 	.name = "pch_can",
 	.id_table = pch_pci_tbl,
 	.probe = pch_can_probe,
-	.remove = __devexit_p(pch_can_remove),
+	.remove = pch_can_remove,
 	.suspend = pch_can_suspend,
 	.resume = pch_can_resume,
 };

commit 194b9a4cb91713ddb60c9f98f7212f6d8cb8e05f
Author: Marc Kleine-Budde <mkl@pengutronix.de>
Date:   Mon Jul 16 12:58:31 2012 +0200

    can: mark bittiming_const pointer in struct can_priv as const
    
    This patch marks the bittiming_const pointer as in the struct can_pric as
    "const". This allows us to mark the struct can_bittiming_const in the CAN
    drivers as "const", too.
    
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 1226297e7676..48b3d62b34cb 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -184,7 +184,7 @@ struct pch_can_priv {
 	int use_msi;
 };
 
-static struct can_bittiming_const pch_can_bittiming_const = {
+static const struct can_bittiming_const pch_can_bittiming_const = {
 	.name = KBUILD_MODNAME,
 	.tseg1_min = 2,
 	.tseg1_max = 16,

commit fb7944b36931d77ea2cde061ff714415ef6e4cef
Author: Axel Lin <axel.lin@gmail.com>
Date:   Sat Apr 14 12:38:43 2012 +0800

    net/can: use module_pci_driver
    
    This patch converts the drivers in drivers/net/can/* to use
    module_pci_driver() macro which makes the code smaller and a bit simpler.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Cc: Wolfgang Grandegger <wg@grandegger.com>
    Cc: Marc Kleine-Budde <mkl@pengutronix.de>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: linux-can@vger.kernel.org
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 2bb215e00eb1..1226297e7676 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -1274,17 +1274,7 @@ static struct pci_driver pch_can_pci_driver = {
 	.resume = pch_can_resume,
 };
 
-static int __init pch_can_pci_init(void)
-{
-	return pci_register_driver(&pch_can_pci_driver);
-}
-module_init(pch_can_pci_init);
-
-static void __exit pch_can_pci_exit(void)
-{
-	pci_unregister_driver(&pch_can_pci_driver);
-}
-module_exit(pch_can_pci_exit);
+module_pci_driver(pch_can_pci_driver);
 
 MODULE_DESCRIPTION("Intel EG20T PCH CAN(Controller Area Network) Driver");
 MODULE_LICENSE("GPL v2");

commit d07d4c239bbf428db5581ccd5ca3770bbd15bfbd
Merge: dd48dc34fe76 aabdfd6adb80
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Feb 4 16:42:19 2012 -0500

    Merge branch 'master' of git://gitorious.org/linux-can/linux-can-next
    
    Conflicts:
            drivers/net/can/usb/ems_usb.c
    
    Minor dev_warn --> netdev_warn conversion conflicts.

commit 74b5127884d76ccbf4f445f650f9e969ccb4a374
Author: Tomoya MORINAGA <tomoya.rohm@gmail.com>
Date:   Fri Jan 27 20:05:21 2012 +0900

    can: pch_can: Change company name OKI SEMICONDUCTOR to LAPIS Semiconductor
    
    On October 1 in 2011,
        OKI SEMICONDUCTOR Co., Ltd. changed the company name in to LAPIS Semiconductor
    
    Signed-off-by: Tomoya MORINAGA <tomoya.rohm@gmail.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index d11fbb2b95ff..cc3ed57b6b15 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 1999 - 2010 Intel Corporation.
- * Copyright (C) 2010 OKI SEMICONDUCTOR CO., LTD.
+ * Copyright (C) 2010 LAPIS SEMICONDUCTOR CO., LTD.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by

commit 44b0052c5cb4e75389ed3eb9e98c29295a7dadfb
Author: Xi Wang <xi.wang@gmail.com>
Date:   Mon Dec 12 02:16:20 2011 -0500

    can: pch_can: fix error passive level test
    
    The test (((errc & PCH_REC) >> 8) > 127) would always be false because
    the receive error counter ((errc & PCH_REC) >> 8) is at most 127, where
    PCH_REC is defined as 0x7f00.  To test whether the receive error counter
    has reached the error passive level, the RP bit (15) should be used.
    
    Signed-off-by: Xi Wang <xi.wang@gmail.com>
    Acked-by: Wolfgang Grandegger <wg@grandegger.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index d11fbb2b95ff..6edc25e0dd15 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -66,6 +66,7 @@
 #define PCH_IF_CREQ_BUSY	BIT(15)
 
 #define PCH_STATUS_INT		0x8000
+#define PCH_RP			0x00008000
 #define PCH_REC			0x00007f00
 #define PCH_TEC			0x000000ff
 
@@ -527,7 +528,7 @@ static void pch_can_error(struct net_device *ndev, u32 status)
 		priv->can.can_stats.error_passive++;
 		state = CAN_STATE_ERROR_PASSIVE;
 		cf->can_id |= CAN_ERR_CRTL;
-		if (((errc & PCH_REC) >> 8) > 127)
+		if (errc & PCH_RP)
 			cf->data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
 		if ((errc & PCH_TEC) > 127)
 			cf->data[1] |= CAN_ERR_CRTL_TX_PASSIVE;

commit 70f23fd66bc821a0e99647f70a809e277cc93c4c
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Tue May 10 10:16:21 2011 +0200

    treewide: fix a few typos in comments
    
    - kenrel -> kernel
    - whetehr -> whether
    - ttt -> tt
    - sss -> ss
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index e54712b22c27..d11fbb2b95ff 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -653,7 +653,7 @@ static int pch_can_rx_normal(struct net_device *ndev, u32 obj_num, int quota)
 	u16 data_reg;
 
 	do {
-		/* Reading the messsage object from the Message RAM */
+		/* Reading the message object from the Message RAM */
 		iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[0].cmask);
 		pch_can_rw_msg_obj(&priv->regs->ifregs[0].creq, obj_num);
 

commit ebc02e9c524e9ff377dd8a3820522d381adf19c8
Author: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
Date:   Wed Feb 9 16:46:21 2011 -0800

    pch_can: fix tseg1/tseg2 setting issue
    
    Previous patch "[PATCH 1/3] pch_can: fix 800k comms issue" is wrong.
    I should have modified tseg1_min not tseg2_min.
    This patch reverts tseg2_min to 1 and set tseg1_min to 2.
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 7d8bc128044c..e54712b22c27 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -185,9 +185,9 @@ struct pch_can_priv {
 
 static struct can_bittiming_const pch_can_bittiming_const = {
 	.name = KBUILD_MODNAME,
-	.tseg1_min = 1,
+	.tseg1_min = 2,
 	.tseg1_max = 16,
-	.tseg2_min = 2,
+	.tseg2_min = 1,
 	.tseg2_max = 8,
 	.sjw_max = 4,
 	.brp_min = 1,

commit c69b90920a36b88ab0d649963d81355d865eeb05
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Mon Feb 7 23:29:03 2011 +0000

    pch_can: fix module reload issue with MSI
    
    Currently, in case reload pch_can,
    pch_can not to be able to catch interrupt.
    
    The cause is bus-master is not set in pch_can.
    Thus, add enabling bus-master processing.
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 342d514c5e84..7d8bc128044c 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -1238,6 +1238,7 @@ static int __devinit pch_can_probe(struct pci_dev *pdev,
 		priv->use_msi = 0;
 	} else {
 		netdev_err(ndev, "PCH CAN opened with MSI\n");
+		pci_set_master(pdev);
 		priv->use_msi = 1;
 	}
 

commit ce9736d4fb48beed370e22ac156779746dda7b92
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Mon Feb 7 23:29:02 2011 +0000

    pch_can: fix rmmod issue
    
    Currently, when rmmod pch_can, kernel failure occurs.
    The cause is pci_iounmap executed before pch_can_reset.
    Thus pci_iounmap moves after pch_can_reset.
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 9b171d12f793..342d514c5e84 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -959,13 +959,13 @@ static void __devexit pch_can_remove(struct pci_dev *pdev)
 	struct pch_can_priv *priv = netdev_priv(ndev);
 
 	unregister_candev(priv->ndev);
-	pci_iounmap(pdev, priv->regs);
 	if (priv->use_msi)
 		pci_disable_msi(priv->dev);
 	pci_release_regions(pdev);
 	pci_disable_device(pdev);
 	pci_set_drvdata(pdev, NULL);
 	pch_can_reset(priv);
+	pci_iounmap(pdev, priv->regs);
 	free_candev(priv->ndev);
 }
 

commit eab743ede8c4a5e88533d022e9c5374ed08df4cb
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Mon Feb 7 23:29:01 2011 +0000

    pch_can: fix 800k comms issue
    
    Currently, 800k comms fails since prop_seg set zero.
    (EG20T PCH CAN register of prop_seg must be set more than 1)
    To prevent prop_seg set to zero, change tseg2_min 1 to 2.
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index c42e97268248..9b171d12f793 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -187,7 +187,7 @@ static struct can_bittiming_const pch_can_bittiming_const = {
 	.name = KBUILD_MODNAME,
 	.tseg1_min = 1,
 	.tseg1_max = 16,
-	.tseg2_min = 1,
+	.tseg2_min = 2,
 	.tseg2_max = 8,
 	.sjw_max = 4,
 	.brp_min = 1,

commit f622691c91cd1bb27d03a5caa8a43822572c62bc
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Wed Dec 22 03:00:39 2010 +0000

    pch_can: Fix array miss-pointing issue
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 8d45fdd0180d..c42e97268248 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -1078,15 +1078,17 @@ static int pch_can_suspend(struct pci_dev *pdev, pm_message_t state)
 
 	/* Save Tx buffer enable state */
 	for (i = PCH_TX_OBJ_START; i <= PCH_TX_OBJ_END; i++)
-		priv->tx_enable[i] = pch_can_get_rxtx_ir(priv, i, PCH_TX_IFREG);
+		priv->tx_enable[i - 1] = pch_can_get_rxtx_ir(priv, i,
+							     PCH_TX_IFREG);
 
 	/* Disable all Transmit buffers */
 	pch_can_set_tx_all(priv, 0);
 
 	/* Save Rx buffer enable state */
 	for (i = PCH_RX_OBJ_START; i <= PCH_RX_OBJ_END; i++) {
-		priv->rx_enable[i] = pch_can_get_rxtx_ir(priv, i, PCH_RX_IFREG);
-		priv->rx_link[i] = pch_can_get_rx_buffer_link(priv, i);
+		priv->rx_enable[i - 1] = pch_can_get_rxtx_ir(priv, i,
+							     PCH_RX_IFREG);
+		priv->rx_link[i - 1] = pch_can_get_rx_buffer_link(priv, i);
 	}
 
 	/* Disable all Receive buffers */
@@ -1139,15 +1141,15 @@ static int pch_can_resume(struct pci_dev *pdev)
 
 	/* Enabling the transmit buffer. */
 	for (i = PCH_TX_OBJ_START; i <= PCH_TX_OBJ_END; i++)
-		pch_can_set_rxtx(priv, i, priv->tx_enable[i], PCH_TX_IFREG);
+		pch_can_set_rxtx(priv, i, priv->tx_enable[i - 1], PCH_TX_IFREG);
 
 	/* Configuring the receive buffer and enabling them. */
 	for (i = PCH_RX_OBJ_START; i <= PCH_RX_OBJ_END; i++) {
 		/* Restore buffer link */
-		pch_can_set_rx_buffer_link(priv, i, priv->rx_link[i]);
+		pch_can_set_rx_buffer_link(priv, i, priv->rx_link[i - 1]);
 
 		/* Restore buffer enables */
-		pch_can_set_rxtx(priv, i, priv->rx_enable[i], PCH_RX_IFREG);
+		pch_can_set_rxtx(priv, i, priv->rx_enable[i - 1], PCH_RX_IFREG);
 	}
 
 	/* Enable CAN Interrupts */

commit cfb7e5f187e787bb1430decea339fdea6a669f92
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Sun Dec 12 20:24:26 2010 +0000

    pch_can: Replace netif_rx to netif_receive_skb
    
    Since this driver is implemented as NAPI,
    netif_receive_skb must be used not netif_rx.
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Acked-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 4697b1cf94e8..8d45fdd0180d 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -572,7 +572,7 @@ static void pch_can_error(struct net_device *ndev, u32 status)
 	cf->data[7] = (errc & PCH_REC) >> 8;
 
 	priv->can.state = state;
-	netif_rx(skb);
+	netif_receive_skb(skb);
 
 	stats->rx_packets++;
 	stats->rx_bytes += cf->can_dlc;

commit 0c78ab76a05cd788af0383354ffe819e0617f6a0
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Sun Dec 12 20:24:25 2010 +0000

    pch_can: Add setting TEC/REC statistics processing
    
    Add setting TEC/REC statistics processing.
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index dcd8f0032fd1..4697b1cf94e8 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -568,6 +568,9 @@ static void pch_can_error(struct net_device *ndev, u32 status)
 		break;
 	}
 
+	cf->data[6] = errc & PCH_TEC;
+	cf->data[7] = (errc & PCH_REC) >> 8;
+
 	priv->can.state = state;
 	netif_rx(skb);
 

commit fea9294c5f2902c45613681ad995ca27899d2016
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Sun Dec 12 20:24:24 2010 +0000

    pch_can: Optimize "if" condition in rx/tx processing
    
    For reduce "if" condition, easy to read/understand the code,
    optimize "if" condition in rx/tx processing.
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Acked-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 8efbe359ba2a..dcd8f0032fd1 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -746,19 +746,16 @@ static int pch_can_poll(struct napi_struct *napi, int quota)
 
 	if (int_stat == PCH_STATUS_INT) {
 		reg_stat = ioread32(&priv->regs->stat);
-		if (reg_stat & (PCH_BUS_OFF | PCH_LEC_ALL)) {
-			if (reg_stat & PCH_BUS_OFF ||
-			   (reg_stat & PCH_LEC_ALL) != PCH_LEC_ALL) {
-				pch_can_error(ndev, reg_stat);
-				quota--;
-			}
-		}
 
-		if (reg_stat & PCH_TX_OK)
-			pch_can_bit_clear(&priv->regs->stat, PCH_TX_OK);
+		if ((reg_stat & (PCH_BUS_OFF | PCH_LEC_ALL)) &&
+		   ((reg_stat & PCH_LEC_ALL) != PCH_LEC_ALL)) {
+			pch_can_error(ndev, reg_stat);
+			quota--;
+		}
 
-		if (reg_stat & PCH_RX_OK)
-			pch_can_bit_clear(&priv->regs->stat, PCH_RX_OK);
+		if (reg_stat & (PCH_TX_OK | PCH_RX_OK))
+			pch_can_bit_clear(&priv->regs->stat,
+					  reg_stat & (PCH_TX_OK | PCH_RX_OK));
 
 		int_stat = pch_can_int_pending(priv);
 	}
@@ -900,14 +897,13 @@ static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
 	if (can_dropped_invalid_skb(ndev, skb))
 		return NETDEV_TX_OK;
 
+	tx_obj_no = priv->tx_obj;
 	if (priv->tx_obj == PCH_TX_OBJ_END) {
 		if (ioread32(&priv->regs->treq2) & PCH_TREQ2_TX_MASK)
 			netif_stop_queue(ndev);
 
-		tx_obj_no = priv->tx_obj;
 		priv->tx_obj = PCH_TX_OBJ_START;
 	} else {
-		tx_obj_no = priv->tx_obj;
 		priv->tx_obj++;
 	}
 
@@ -926,9 +922,7 @@ static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
 	id2 |= PCH_ID_MSGVAL;
 
 	/* If remote frame has to be transmitted.. */
-	if (cf->can_id & CAN_RTR_FLAG)
-		id2 &= ~PCH_ID2_DIR;
-	else
+	if (!(cf->can_id & CAN_RTR_FLAG))
 		id2 |= PCH_ID2_DIR;
 
 	iowrite32(id2, &priv->regs->ifregs[1].id2);

commit 3332bc5446e034566e8a56bf7a7cd479ca35bd6d
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Sun Dec 12 20:24:23 2010 +0000

    pch_can: Fix incorrect return processing
    
    Fix incorrect return processing.
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index ace1fe790ce0..8efbe359ba2a 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -580,9 +580,11 @@ static irqreturn_t pch_can_interrupt(int irq, void *dev_id)
 	struct net_device *ndev = (struct net_device *)dev_id;
 	struct pch_can_priv *priv = netdev_priv(ndev);
 
+	if (!pch_can_int_pending(priv))
+		return IRQ_NONE;
+
 	pch_can_set_int_enables(priv, PCH_CAN_NONE);
 	napi_schedule(&priv->napi);
-
 	return IRQ_HANDLED;
 }
 
@@ -671,8 +673,10 @@ static int pch_can_rx_normal(struct net_device *ndev, u32 obj_num, int quota)
 		}
 
 		skb = alloc_can_skb(priv->ndev, &cf);
-		if (!skb)
-			return -ENOMEM;
+		if (!skb) {
+			netdev_err(ndev, "alloc_can_skb Failed\n");
+			return rcv_pkts;
+		}
 
 		/* Get Received data */
 		id2 = ioread32(&priv->regs->ifregs[0].id2);
@@ -733,8 +737,8 @@ static int pch_can_poll(struct napi_struct *napi, int quota)
 	struct net_device *ndev = napi->dev;
 	struct pch_can_priv *priv = netdev_priv(ndev);
 	u32 int_stat;
-	int rcv_pkts = 0;
 	u32 reg_stat;
+	int quota_save = quota;
 
 	int_stat = pch_can_int_pending(priv);
 	if (!int_stat)
@@ -763,10 +767,7 @@ static int pch_can_poll(struct napi_struct *napi, int quota)
 		goto end;
 
 	if ((int_stat >= PCH_RX_OBJ_START) && (int_stat <= PCH_RX_OBJ_END)) {
-		rcv_pkts += pch_can_rx_normal(ndev, int_stat, quota);
-		quota -= rcv_pkts;
-		if (quota < 0)
-			goto end;
+		quota -= pch_can_rx_normal(ndev, int_stat, quota);
 	} else if ((int_stat >= PCH_TX_OBJ_START) &&
 		   (int_stat <= PCH_TX_OBJ_END)) {
 		/* Handle transmission interrupt */
@@ -777,7 +778,7 @@ static int pch_can_poll(struct napi_struct *napi, int quota)
 	napi_complete(napi);
 	pch_can_set_int_enables(priv, PCH_CAN_ALL);
 
-	return rcv_pkts;
+	return quota_save - quota;
 }
 
 static int pch_set_bittiming(struct net_device *ndev)

commit a6f6d6b51b110e661ae5f862d60c27da4970bec6
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Sun Dec 12 20:24:22 2010 +0000

    pch_can: Move MSI processing to probe/remove processing
    
    Currently, in case this driver is integrated as module, and when this
    module is re-installed, no interrupts is to be occurred.
    For the above issue, move MSI processing to open/release processing.
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index a1fd3be69a81..ace1fe790ce0 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -845,15 +845,6 @@ static int pch_can_open(struct net_device *ndev)
 	struct pch_can_priv *priv = netdev_priv(ndev);
 	int retval;
 
-	retval = pci_enable_msi(priv->dev);
-	if (retval) {
-		netdev_err(ndev, "PCH CAN opened without MSI\n");
-		priv->use_msi = 0;
-	} else {
-		netdev_err(ndev, "PCH CAN opened with MSI\n");
-		priv->use_msi = 1;
-	}
-
 	/* Regstering the interrupt. */
 	retval = request_irq(priv->dev->irq, pch_can_interrupt, IRQF_SHARED,
 			     ndev->name, ndev);
@@ -879,9 +870,6 @@ static int pch_can_open(struct net_device *ndev)
 err_open_candev:
 	free_irq(priv->dev->irq, ndev);
 req_irq_err:
-	if (priv->use_msi)
-		pci_disable_msi(priv->dev);
-
 	pch_can_release(priv);
 
 	return retval;
@@ -895,8 +883,6 @@ static int pch_close(struct net_device *ndev)
 	napi_disable(&priv->napi);
 	pch_can_release(priv);
 	free_irq(priv->dev->irq, ndev);
-	if (priv->use_msi)
-		pci_disable_msi(priv->dev);
 	close_candev(ndev);
 	priv->can.state = CAN_STATE_STOPPED;
 	return 0;
@@ -975,12 +961,14 @@ static void __devexit pch_can_remove(struct pci_dev *pdev)
 	struct pch_can_priv *priv = netdev_priv(ndev);
 
 	unregister_candev(priv->ndev);
-	free_candev(priv->ndev);
 	pci_iounmap(pdev, priv->regs);
+	if (priv->use_msi)
+		pci_disable_msi(priv->dev);
 	pci_release_regions(pdev);
 	pci_disable_device(pdev);
 	pci_set_drvdata(pdev, NULL);
 	pch_can_reset(priv);
+	free_candev(priv->ndev);
 }
 
 #ifdef CONFIG_PM
@@ -1244,6 +1232,15 @@ static int __devinit pch_can_probe(struct pci_dev *pdev,
 
 	netif_napi_add(ndev, &priv->napi, pch_can_poll, PCH_RX_OBJ_END);
 
+	rc = pci_enable_msi(priv->dev);
+	if (rc) {
+		netdev_err(ndev, "PCH CAN opened without MSI\n");
+		priv->use_msi = 0;
+	} else {
+		netdev_err(ndev, "PCH CAN opened with MSI\n");
+		priv->use_msi = 1;
+	}
+
 	rc = register_candev(ndev);
 	if (rc) {
 		dev_err(&pdev->dev, "Failed register_candev %d\n", rc);
@@ -1253,6 +1250,8 @@ static int __devinit pch_can_probe(struct pci_dev *pdev,
 	return 0;
 
 probe_exit_reg_candev:
+	if (priv->use_msi)
+		pci_disable_msi(priv->dev);
 	free_candev(ndev);
 probe_exit_alloc_candev:
 	pci_iounmap(pdev, addr);

commit c755145649fa73bd197ac1a73d141047c61b543a
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Sun Dec 12 20:24:21 2010 +0000

    pch_can: Comment optimization
    
    Comment optimization
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index c500b6d65084..a1fd3be69a81 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -292,7 +292,7 @@ static void pch_can_set_rxtx(struct pch_can_priv *priv, u32 buff_num,
 	else
 		ie = PCH_IF_MCONT_RXIE;
 
-	/* Reading the receive buffer data from RAM to Interface1/2 registers */
+	/* Reading the Msg buffer from Message RAM to IF1/2 registers. */
 	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[dir].cmask);
 	pch_can_rw_msg_obj(&priv->regs->ifregs[dir].creq, buff_num);
 
@@ -854,7 +854,7 @@ static int pch_can_open(struct net_device *ndev)
 		priv->use_msi = 1;
 	}
 
-	/* Regsitering the interrupt. */
+	/* Regstering the interrupt. */
 	retval = request_irq(priv->dev->irq, pch_can_interrupt, IRQF_SHARED,
 			     ndev->name, ndev);
 	if (retval) {
@@ -954,7 +954,7 @@ static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
 
 	can_put_echo_skb(skb, ndev, tx_obj_no - PCH_RX_OBJ_END - 1);
 
-	/* Updating the size of the data. */
+	/* Set the size of the data. Update if2_mcont */
 	iowrite32(cf->can_dlc | PCH_IF_MCONT_NEWDAT | PCH_IF_MCONT_TXRQXT |
 		  PCH_IF_MCONT_TXIE, &priv->regs->ifregs[1].mcont);
 
@@ -1061,8 +1061,8 @@ static int pch_can_get_buffer_status(struct pch_can_priv *priv)
 
 static int pch_can_suspend(struct pci_dev *pdev, pm_message_t state)
 {
-	int i;			/* Counter variable. */
-	int retval;		/* Return value. */
+	int i;
+	int retval;
 	u32 buf_stat;	/* Variable for reading the transmit buffer status. */
 	int counter = PCH_COUNTER_LIMIT;
 
@@ -1119,8 +1119,8 @@ static int pch_can_suspend(struct pci_dev *pdev, pm_message_t state)
 
 static int pch_can_resume(struct pci_dev *pdev)
 {
-	int i;			/* Counter variable. */
-	int retval;		/* Return variable. */
+	int i;
+	int retval;
 	struct net_device *dev = pci_get_drvdata(pdev);
 	struct pch_can_priv *priv = netdev_priv(dev);
 

commit d06848be64e13d5d1d73e581fb185e815893d8b7
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Sun Dec 12 20:24:20 2010 +0000

    pch_can: Fix miss-setting status issue
    
    Modify miss-setting status issue at suspend.
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 5a6a0df5141e..c500b6d65084 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -1073,7 +1073,7 @@ static int pch_can_suspend(struct pci_dev *pdev, pm_message_t state)
 	pch_can_set_run_mode(priv, PCH_CAN_STOP);
 
 	/* Indicate that we are aboutto/in suspend */
-	priv->can.state = CAN_STATE_SLEEPING;
+	priv->can.state = CAN_STATE_STOPPED;
 
 	/* Waiting for all transmission to complete. */
 	while (counter) {

commit 0e0805c4063d0611e282bb7fdebe2e223bfe7220
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Sun Dec 12 20:24:19 2010 +0000

    pch_can: Fix bit timing calculation issue
    
    Modify like use calculated value directly passed by CAN core module.
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Acked-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 354097872cbe..5a6a0df5141e 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -786,17 +786,15 @@ static int pch_set_bittiming(struct net_device *ndev)
 	const struct can_bittiming *bt = &priv->can.bittiming;
 	u32 canbit;
 	u32 bepe;
-	u32 brp;
 
 	/* Setting the CCE bit for accessing the Can Timing register. */
 	pch_can_bit_set(&priv->regs->cont, PCH_CTRL_CCE);
 
-	brp = (bt->tq) / (1000000000/PCH_CAN_CLK) - 1;
-	canbit = brp & PCH_MSK_BITT_BRP;
+	canbit = (bt->brp - 1) & PCH_MSK_BITT_BRP;
 	canbit |= (bt->sjw - 1) << PCH_BIT_SJW_SHIFT;
 	canbit |= (bt->phase_seg1 + bt->prop_seg - 1) << PCH_BIT_TSEG1_SHIFT;
 	canbit |= (bt->phase_seg2 - 1) << PCH_BIT_TSEG2_SHIFT;
-	bepe = (brp & PCH_MSK_BRPE_BRPE) >> PCH_BIT_BRPE_BRPE_SHIFT;
+	bepe = ((bt->brp - 1) & PCH_MSK_BRPE_BRPE) >> PCH_BIT_BRPE_BRPE_SHIFT;
 	iowrite32(canbit, &priv->regs->bitt);
 	iowrite32(bepe, &priv->regs->brpe);
 	pch_can_bit_clear(&priv->regs->cont, PCH_CTRL_CCE);

commit 8714fcaca63203fe10331fe530ff48d3dd31de4e
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Sun Dec 12 20:24:18 2010 +0000

    pch_can: Delete unnecessary/redundant code
    
    Delete unnecessary/redundant code
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index da8d37bd02b1..354097872cbe 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -447,11 +447,6 @@ static void pch_can_release(struct pch_can_priv *priv)
 /* This function clears interrupt(s) from the CAN device. */
 static void pch_can_int_clr(struct pch_can_priv *priv, u32 mask)
 {
-	if (mask == PCH_STATUS_INT) {
-		ioread32(&priv->regs->stat);
-		return;
-	}
-
 	/* Clear interrupt for transmit object */
 	if ((mask >= PCH_RX_OBJ_START) && (mask <= PCH_RX_OBJ_END)) {
 		/* Setting CMASK for clearing the reception interrupts. */
@@ -512,8 +507,6 @@ static void pch_can_error(struct net_device *ndev, u32 status)
 		state = CAN_STATE_BUS_OFF;
 		cf->can_id |= CAN_ERR_BUSOFF;
 		can_bus_off(ndev);
-		pch_can_set_run_mode(priv, PCH_CAN_RUN);
-		dev_err(&ndev->dev, "%s -> Bus Off occurres.\n", __func__);
 	}
 
 	errc = ioread32(&priv->regs->errc);
@@ -747,7 +740,7 @@ static int pch_can_poll(struct napi_struct *napi, int quota)
 	if (!int_stat)
 		goto end;
 
-	if ((int_stat == PCH_STATUS_INT) && (quota > 0)) {
+	if (int_stat == PCH_STATUS_INT) {
 		reg_stat = ioread32(&priv->regs->stat);
 		if (reg_stat & (PCH_BUS_OFF | PCH_LEC_ALL)) {
 			if (reg_stat & PCH_BUS_OFF ||
@@ -933,10 +926,6 @@ static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
 		priv->tx_obj++;
 	}
 
-	/* Reading the Msg Obj from the Msg RAM to the Interface register. */
-	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[1].cmask);
-	pch_can_rw_msg_obj(&priv->regs->ifregs[1].creq, tx_obj_no);
-
 	/* Setting the CMASK register. */
 	pch_can_bit_set(&priv->regs->ifregs[1].cmask, PCH_CMASK_ALL);
 

commit 9388b166a323f8f7e35eb7a0d17b297ca695fa91
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Sun Dec 12 20:24:17 2010 +0000

    pch_can: Fix coding rule violation
    
    Fix coding rule violation.
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Acked-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 0093a01fefda..da8d37bd02b1 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -89,9 +89,11 @@
 
 #define PCH_CAN_CLK		50000000	/* 50MHz */
 
-/* Define the number of message object.
+/*
+ * Define the number of message object.
  * PCH CAN communications are done via Message RAM.
- * The Message RAM consists of 32 message objects. */
+ * The Message RAM consists of 32 message objects.
+ */
 #define PCH_RX_OBJ_NUM		26
 #define PCH_TX_OBJ_NUM		6
 #define PCH_RX_OBJ_START	1
@@ -126,7 +128,7 @@ enum pch_can_mode {
 	PCH_CAN_ALL,
 	PCH_CAN_NONE,
 	PCH_CAN_STOP,
-	PCH_CAN_RUN
+	PCH_CAN_RUN,
 };
 
 struct pch_can_if_regs {
@@ -290,21 +292,20 @@ static void pch_can_set_rxtx(struct pch_can_priv *priv, u32 buff_num,
 	else
 		ie = PCH_IF_MCONT_RXIE;
 
-	/* Reading the receive buffer data from RAM to Interface1 registers */
+	/* Reading the receive buffer data from RAM to Interface1/2 registers */
 	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[dir].cmask);
 	pch_can_rw_msg_obj(&priv->regs->ifregs[dir].creq, buff_num);
 
-	/* Setting the IF1MASK1 register to access MsgVal and RxIE bits */
+	/* Setting the IF1/2MASK1 register to access MsgVal and RxIE bits */
 	iowrite32(PCH_CMASK_RDWR | PCH_CMASK_ARB | PCH_CMASK_CTRL,
 		  &priv->regs->ifregs[dir].cmask);
 
 	if (set) {
-		/* Setting the MsgVal and RxIE bits */
+		/* Setting the MsgVal and RxIE/TxIE bits */
 		pch_can_bit_set(&priv->regs->ifregs[dir].mcont, ie);
 		pch_can_bit_set(&priv->regs->ifregs[dir].id2, PCH_ID_MSGVAL);
-
 	} else {
-		/* Resetting the MsgVal and RxIE bits */
+		/* Clearing the MsgVal and RxIE/TxIE bits */
 		pch_can_bit_clear(&priv->regs->ifregs[dir].mcont, ie);
 		pch_can_bit_clear(&priv->regs->ifregs[dir].id2, PCH_ID_MSGVAL);
 	}
@@ -362,8 +363,7 @@ static void pch_can_config_rx_tx_buffers(struct pch_can_priv *priv)
 	int i;
 
 	for (i = PCH_RX_OBJ_START; i <= PCH_RX_OBJ_END; i++) {
-		iowrite32(PCH_CMASK_RX_TX_GET,
-			&priv->regs->ifregs[0].cmask);
+		iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[0].cmask);
 		pch_can_rw_msg_obj(&priv->regs->ifregs[0].creq, i);
 
 		iowrite32(0x0, &priv->regs->ifregs[0].id1);
@@ -385,16 +385,14 @@ static void pch_can_config_rx_tx_buffers(struct pch_can_priv *priv)
 				  0x1fff | PCH_MASK2_MDIR_MXTD);
 
 		/* Setting CMASK for writing */
-		iowrite32(PCH_CMASK_RDWR | PCH_CMASK_MASK |
-			  PCH_CMASK_ARB | PCH_CMASK_CTRL,
-			  &priv->regs->ifregs[0].cmask);
+		iowrite32(PCH_CMASK_RDWR | PCH_CMASK_MASK | PCH_CMASK_ARB |
+			  PCH_CMASK_CTRL, &priv->regs->ifregs[0].cmask);
 
 		pch_can_rw_msg_obj(&priv->regs->ifregs[0].creq, i);
 	}
 
 	for (i = PCH_TX_OBJ_START; i <= PCH_TX_OBJ_END; i++) {
-		iowrite32(PCH_CMASK_RX_TX_GET,
-			&priv->regs->ifregs[1].cmask);
+		iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[1].cmask);
 		pch_can_rw_msg_obj(&priv->regs->ifregs[1].creq, i);
 
 		/* Resetting DIR bit for reception */
@@ -409,9 +407,8 @@ static void pch_can_config_rx_tx_buffers(struct pch_can_priv *priv)
 		pch_can_bit_clear(&priv->regs->ifregs[1].mask2, 0x1fff);
 
 		/* Setting CMASK for writing */
-		iowrite32(PCH_CMASK_RDWR | PCH_CMASK_MASK |
-			  PCH_CMASK_ARB | PCH_CMASK_CTRL,
-			  &priv->regs->ifregs[1].cmask);
+		iowrite32(PCH_CMASK_RDWR | PCH_CMASK_MASK | PCH_CMASK_ARB |
+			  PCH_CMASK_CTRL, &priv->regs->ifregs[1].cmask);
 
 		pch_can_rw_msg_obj(&priv->regs->ifregs[1].creq, i);
 	}
@@ -470,8 +467,9 @@ static void pch_can_int_clr(struct pch_can_priv *priv, u32 mask)
 
 		pch_can_rw_msg_obj(&priv->regs->ifregs[0].creq, mask);
 	} else if ((mask >= PCH_TX_OBJ_START) && (mask <= PCH_TX_OBJ_END)) {
-		/* Setting CMASK for clearing interrupts for
-					 frame transmission. */
+		/*
+		 * Setting CMASK for clearing interrupts for frame transmission.
+		 */
 		iowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL | PCH_CMASK_ARB,
 			  &priv->regs->ifregs[1].cmask);
 
@@ -590,7 +588,6 @@ static irqreturn_t pch_can_interrupt(int irq, void *dev_id)
 	struct pch_can_priv *priv = netdev_priv(ndev);
 
 	pch_can_set_int_enables(priv, PCH_CAN_NONE);
-
 	napi_schedule(&priv->napi);
 
 	return IRQ_HANDLED;
@@ -1031,11 +1028,11 @@ static u32 pch_can_get_rxtx_ir(struct pch_can_priv *priv, u32 buff_num,
 	pch_can_rw_msg_obj(&priv->regs->ifregs[dir].creq, buff_num);
 
 	if (((ioread32(&priv->regs->ifregs[dir].id2)) & PCH_ID_MSGVAL) &&
-			((ioread32(&priv->regs->ifregs[dir].mcont)) & ie)) {
+			((ioread32(&priv->regs->ifregs[dir].mcont)) & ie))
 		enable = 1;
-	} else {
+	else
 		enable = 0;
-	}
+
 	return enable;
 }
 

commit 435b4efe93d4cec3aa0b36e8707df8d292d3641b
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Sun Dec 12 20:24:16 2010 +0000

    pch_can: Replace netdev_dbg instead of dev_dbg partly
    
    For easy to readable, use netdev_dbg instead of dev_dbg partly
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 293be5151f05..0093a01fefda 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -222,7 +222,7 @@ static void pch_can_set_run_mode(struct pch_can_priv *priv,
 		break;
 
 	default:
-		dev_err(&priv->ndev->dev, "%s -> Invalid Mode.\n", __func__);
+		netdev_err(priv->ndev, "%s -> Invalid Mode.\n", __func__);
 		break;
 	}
 }
@@ -275,7 +275,7 @@ static void pch_can_set_int_enables(struct pch_can_priv *priv,
 		break;
 
 	default:
-		dev_err(&priv->ndev->dev, "Invalid interrupt number.\n");
+		netdev_err(priv->ndev, "Invalid interrupt number.\n");
 		break;
 	}
 }
@@ -528,7 +528,7 @@ static void pch_can_error(struct net_device *ndev, u32 status)
 			cf->data[1] |= CAN_ERR_CRTL_RX_WARNING;
 		if ((errc & PCH_TEC) > 96)
 			cf->data[1] |= CAN_ERR_CRTL_TX_WARNING;
-		dev_warn(&ndev->dev,
+		netdev_dbg(ndev,
 			"%s -> Error Counter is more than 96.\n", __func__);
 	}
 	/* Error passive interrupt. */
@@ -540,7 +540,7 @@ static void pch_can_error(struct net_device *ndev, u32 status)
 			cf->data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
 		if ((errc & PCH_TEC) > 127)
 			cf->data[1] |= CAN_ERR_CRTL_TX_PASSIVE;
-		dev_err(&ndev->dev,
+		netdev_dbg(ndev,
 			"%s -> CAN controller is ERROR PASSIVE .\n", __func__);
 	}
 
@@ -859,10 +859,10 @@ static int pch_can_open(struct net_device *ndev)
 
 	retval = pci_enable_msi(priv->dev);
 	if (retval) {
-		dev_info(&ndev->dev, "PCH CAN opened without MSI\n");
+		netdev_err(ndev, "PCH CAN opened without MSI\n");
 		priv->use_msi = 0;
 	} else {
-		dev_info(&ndev->dev, "PCH CAN opened with MSI\n");
+		netdev_err(ndev, "PCH CAN opened with MSI\n");
 		priv->use_msi = 1;
 	}
 
@@ -870,14 +870,14 @@ static int pch_can_open(struct net_device *ndev)
 	retval = request_irq(priv->dev->irq, pch_can_interrupt, IRQF_SHARED,
 			     ndev->name, ndev);
 	if (retval) {
-		dev_err(&ndev->dev, "request_irq failed.\n");
+		netdev_err(ndev, "request_irq failed.\n");
 		goto req_irq_err;
 	}
 
 	/* Open common can device */
 	retval = open_candev(ndev);
 	if (retval) {
-		dev_err(ndev->dev.parent, "open_candev() failed %d\n", retval);
+		netdev_err(ndev, "open_candev() failed %d\n", retval);
 		goto err_open_candev;
 	}
 

commit e91530ea959295a31911488c62088d5c372032ea
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Sun Dec 12 20:24:15 2010 +0000

    pch_can: Change Copyright and module description
    
    Currently, Copyright and module description are not formal.
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 0acc87755b24..293be5151f05 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 1999 - 2010 Intel Corporation.
- * Copyright (C) 2010 OKI SEMICONDUCTOR Co., LTD.
+ * Copyright (C) 2010 OKI SEMICONDUCTOR CO., LTD.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -1301,6 +1301,6 @@ static void __exit pch_can_pci_exit(void)
 }
 module_exit(pch_can_pci_exit);
 
-MODULE_DESCRIPTION("Controller Area Network Driver");
+MODULE_DESCRIPTION("Intel EG20T PCH CAN(Controller Area Network) Driver");
 MODULE_LICENSE("GPL v2");
 MODULE_VERSION("0.94");

commit 44c9aa890a2587f48920485b7487bc6d516dbbdf
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Sun Dec 12 20:24:14 2010 +0000

    pch_can: Reduce register access
    
    For improve tx/rx speed, reduce register access.
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index c6c0842aeb75..0acc87755b24 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -372,9 +372,6 @@ static void pch_can_config_rx_tx_buffers(struct pch_can_priv *priv)
 		pch_can_bit_set(&priv->regs->ifregs[0].mcont,
 				PCH_IF_MCONT_UMASK);
 
-		/* Set FIFO mode set to 0 except last Rx Obj*/
-		pch_can_bit_clear(&priv->regs->ifregs[0].mcont,
-				  PCH_IF_MCONT_EOB);
 		/* In case FIFO mode, Last EoB of Rx Obj must be 1 */
 		if (i == PCH_RX_OBJ_END)
 			pch_can_bit_set(&priv->regs->ifregs[0].mcont,
@@ -402,14 +399,11 @@ static void pch_can_config_rx_tx_buffers(struct pch_can_priv *priv)
 
 		/* Resetting DIR bit for reception */
 		iowrite32(0x0, &priv->regs->ifregs[1].id1);
-		iowrite32(0x0, &priv->regs->ifregs[1].id2);
-		pch_can_bit_set(&priv->regs->ifregs[1].id2, PCH_ID2_DIR);
+		iowrite32(PCH_ID2_DIR, &priv->regs->ifregs[1].id2);
 
 		/* Setting EOB bit for transmitter */
-		iowrite32(PCH_IF_MCONT_EOB, &priv->regs->ifregs[1].mcont);
-
-		pch_can_bit_set(&priv->regs->ifregs[1].mcont,
-				PCH_IF_MCONT_UMASK);
+		iowrite32(PCH_IF_MCONT_EOB | PCH_IF_MCONT_UMASK,
+			  &priv->regs->ifregs[1].mcont);
 
 		iowrite32(0, &priv->regs->ifregs[1].mask1);
 		pch_can_bit_clear(&priv->regs->ifregs[1].mask2, 0x1fff);
@@ -524,12 +518,12 @@ static void pch_can_error(struct net_device *ndev, u32 status)
 		dev_err(&ndev->dev, "%s -> Bus Off occurres.\n", __func__);
 	}
 
+	errc = ioread32(&priv->regs->errc);
 	/* Warning interrupt. */
 	if (status & PCH_EWARN) {
 		state = CAN_STATE_ERROR_WARNING;
 		priv->can.can_stats.error_warning++;
 		cf->can_id |= CAN_ERR_CRTL;
-		errc = ioread32(&priv->regs->errc);
 		if (((errc & PCH_REC) >> 8) > 96)
 			cf->data[1] |= CAN_ERR_CRTL_RX_WARNING;
 		if ((errc & PCH_TEC) > 96)
@@ -542,7 +536,6 @@ static void pch_can_error(struct net_device *ndev, u32 status)
 		priv->can.can_stats.error_passive++;
 		state = CAN_STATE_ERROR_PASSIVE;
 		cf->can_id |= CAN_ERR_CRTL;
-		errc = ioread32(&priv->regs->errc);
 		if (((errc & PCH_REC) >> 8) > 127)
 			cf->data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
 		if ((errc & PCH_TEC) > 127)
@@ -927,6 +920,7 @@ static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
 	struct can_frame *cf = (struct can_frame *)skb->data;
 	int tx_obj_no;
 	int i;
+	u32 id2;
 
 	if (can_dropped_invalid_skb(ndev, skb))
 		return NETDEV_TX_OK;
@@ -950,22 +944,23 @@ static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
 	pch_can_bit_set(&priv->regs->ifregs[1].cmask, PCH_CMASK_ALL);
 
 	/* If ID extended is set. */
-	pch_can_bit_clear(&priv->regs->ifregs[1].id1, 0xffff);
-	pch_can_bit_clear(&priv->regs->ifregs[1].id2, 0x1fff | PCH_ID2_XTD);
 	if (cf->can_id & CAN_EFF_FLAG) {
-		pch_can_bit_set(&priv->regs->ifregs[1].id1,
-				cf->can_id & 0xffff);
-		pch_can_bit_set(&priv->regs->ifregs[1].id2,
-				((cf->can_id >> 16) & 0x1fff) | PCH_ID2_XTD);
+		iowrite32(cf->can_id & 0xffff, &priv->regs->ifregs[1].id1);
+		id2 = ((cf->can_id >> 16) & 0x1fff) | PCH_ID2_XTD;
 	} else {
-		pch_can_bit_set(&priv->regs->ifregs[1].id1, 0);
-		pch_can_bit_set(&priv->regs->ifregs[1].id2,
-				(cf->can_id & CAN_SFF_MASK) << 2);
+		iowrite32(0, &priv->regs->ifregs[1].id1);
+		id2 = (cf->can_id & CAN_SFF_MASK) << 2;
 	}
 
+	id2 |= PCH_ID_MSGVAL;
+
 	/* If remote frame has to be transmitted.. */
 	if (cf->can_id & CAN_RTR_FLAG)
-		pch_can_bit_clear(&priv->regs->ifregs[1].id2, PCH_ID2_DIR);
+		id2 &= ~PCH_ID2_DIR;
+	else
+		id2 |= PCH_ID2_DIR;
+
+	iowrite32(id2, &priv->regs->ifregs[1].id2);
 
 	/* Copy data to register */
 	for (i = 0; i < cf->can_dlc; i += 2) {
@@ -976,17 +971,8 @@ static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
 	can_put_echo_skb(skb, ndev, tx_obj_no - PCH_RX_OBJ_END - 1);
 
 	/* Updating the size of the data. */
-	pch_can_bit_clear(&priv->regs->ifregs[1].mcont, 0x0f);
-	pch_can_bit_set(&priv->regs->ifregs[1].mcont, cf->can_dlc);
-
-	/* Clearing IntPend, NewDat & TxRqst */
-	pch_can_bit_clear(&priv->regs->ifregs[1].mcont,
-			  PCH_IF_MCONT_NEWDAT | PCH_IF_MCONT_INTPND |
-			  PCH_IF_MCONT_TXRQXT);
-
-	/* Setting NewDat, TxRqst bits */
-	pch_can_bit_set(&priv->regs->ifregs[1].mcont,
-			PCH_IF_MCONT_NEWDAT | PCH_IF_MCONT_TXRQXT);
+	iowrite32(cf->can_dlc | PCH_IF_MCONT_NEWDAT | PCH_IF_MCONT_TXRQXT |
+		  PCH_IF_MCONT_TXIE, &priv->regs->ifregs[1].mcont);
 
 	pch_can_rw_msg_obj(&priv->regs->ifregs[1].creq, tx_obj_no);
 
@@ -1211,9 +1197,10 @@ static int pch_can_get_berr_counter(const struct net_device *dev,
 				    struct can_berr_counter *bec)
 {
 	struct pch_can_priv *priv = netdev_priv(dev);
+	u32 errc = ioread32(&priv->regs->errc);
 
-	bec->txerr = ioread32(&priv->regs->errc) & PCH_TEC;
-	bec->rxerr = (ioread32(&priv->regs->errc) & PCH_REC) >> 8;
+	bec->txerr = errc & PCH_TEC;
+	bec->rxerr = (errc & PCH_REC) >> 8;
 
 	return 0;
 }

commit ca2b004e89484e89b1815157fae2d7f933c5af9e
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Sun Dec 12 20:24:13 2010 +0000

    pch_can: Change functions type
    
    Currently, these two functions spec(returned value) is unnatural.
    Thus, change the return value's spec
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index dd9ce16635b3..c6c0842aeb75 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -1025,10 +1025,10 @@ static void pch_can_set_int_custom(struct pch_can_priv *priv)
 }
 
 /* This function retrieves interrupt enabled for the CAN device. */
-static void pch_can_get_int_enables(struct pch_can_priv *priv, u32 *enables)
+static u32 pch_can_get_int_enables(struct pch_can_priv *priv)
 {
 	/* Obtaining the status of IE, SIE and EIE interrupt bits. */
-	*enables = ((ioread32(&priv->regs->cont) & PCH_CTRL_IE_SIE_EIE) >> 1);
+	return (ioread32(&priv->regs->cont) & PCH_CTRL_IE_SIE_EIE) >> 1;
 }
 
 static u32 pch_can_get_rxtx_ir(struct pch_can_priv *priv, u32 buff_num,
@@ -1069,16 +1069,18 @@ static void pch_can_set_rx_buffer_link(struct pch_can_priv *priv,
 	pch_can_rw_msg_obj(&priv->regs->ifregs[0].creq, buffer_num);
 }
 
-static void pch_can_get_rx_buffer_link(struct pch_can_priv *priv,
-				       u32 buffer_num, u32 *link)
+static u32 pch_can_get_rx_buffer_link(struct pch_can_priv *priv, u32 buffer_num)
 {
+	u32 link;
+
 	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[0].cmask);
 	pch_can_rw_msg_obj(&priv->regs->ifregs[0].creq, buffer_num);
 
 	if (ioread32(&priv->regs->ifregs[0].mcont) & PCH_IF_MCONT_EOB)
-		*link = 0;
+		link = 0;
 	else
-		*link = 1;
+		link = 1;
+	return link;
 }
 
 static int pch_can_get_buffer_status(struct pch_can_priv *priv)
@@ -1115,7 +1117,7 @@ static int pch_can_suspend(struct pci_dev *pdev, pm_message_t state)
 		dev_err(&pdev->dev, "%s -> Transmission time out.\n", __func__);
 
 	/* Save interrupt configuration and then disable them */
-	pch_can_get_int_enables(priv, &(priv->int_enables));
+	priv->int_enables = pch_can_get_int_enables(priv);
 	pch_can_set_int_enables(priv, PCH_CAN_DISABLE);
 
 	/* Save Tx buffer enable state */
@@ -1128,7 +1130,7 @@ static int pch_can_suspend(struct pci_dev *pdev, pm_message_t state)
 	/* Save Rx buffer enable state */
 	for (i = PCH_RX_OBJ_START; i <= PCH_RX_OBJ_END; i++) {
 		priv->rx_enable[i] = pch_can_get_rxtx_ir(priv, i, PCH_RX_IFREG);
-		pch_can_get_rx_buffer_link(priv, i, &priv->rx_link[i]);
+		priv->rx_link[i] = pch_can_get_rx_buffer_link(priv, i);
 	}
 
 	/* Disable all Receive buffers */

commit bd58cbc322e97550af5e12584324b7117180435d
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Sun Dec 12 20:24:12 2010 +0000

    pch_can: Rename function/macro name
    
    For easy to read/understand, Rename function/macro name.
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 5fc99cb10df0..dd9ce16635b3 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -32,8 +32,6 @@
 #include <linux/can/dev.h>
 #include <linux/can/error.h>
 
-#define PCH_ENABLE		1 /* The enable flag */
-#define PCH_DISABLE		0 /* The disable flag */
 #define PCH_CTRL_INIT		BIT(0) /* The INIT bit of CANCONT register. */
 #define PCH_CTRL_IE		BIT(1) /* The IE bit of CAN control register */
 #define PCH_CTRL_IE_SIE_EIE	(BIT(3) | BIT(2) | BIT(1))
@@ -78,11 +76,12 @@
 #define PCH_BUS_OFF		BIT(7)
 
 /* bit position of certain controller bits. */
-#define PCH_BIT_BRP		0
-#define PCH_BIT_SJW		6
-#define PCH_BIT_TSEG1		8
-#define PCH_BIT_TSEG2		12
-#define PCH_BIT_BRPE_BRPE	6
+#define PCH_BIT_BRP_SHIFT	0
+#define PCH_BIT_SJW_SHIFT	6
+#define PCH_BIT_TSEG1_SHIFT	8
+#define PCH_BIT_TSEG2_SHIFT	12
+#define PCH_BIT_BRPE_BRPE_SHIFT	6
+
 #define PCH_MSK_BITT_BRP	0x3f
 #define PCH_MSK_BRPE_BRPE	0x3c0
 #define PCH_MSK_CTRL_IE_SIE_EIE	0x07
@@ -170,19 +169,16 @@ struct pch_can_regs {
 
 struct pch_can_priv {
 	struct can_priv can;
-	unsigned int can_num;
 	struct pci_dev *dev;
-	int tx_enable[PCH_TX_OBJ_END];
-	int rx_enable[PCH_TX_OBJ_END];
-	int rx_link[PCH_TX_OBJ_END];
-	unsigned int int_enables;
-	unsigned int int_stat;
+	u32 tx_enable[PCH_TX_OBJ_END];
+	u32 rx_enable[PCH_TX_OBJ_END];
+	u32 rx_link[PCH_TX_OBJ_END];
+	u32 int_enables;
 	struct net_device *ndev;
-	unsigned int msg_obj[PCH_TX_OBJ_END];
 	struct pch_can_regs __iomem *regs;
 	struct napi_struct napi;
-	unsigned int tx_obj;	/* Point next Tx Obj index */
-	unsigned int use_msi;
+	int tx_obj;	/* Point next Tx Obj index */
+	int use_msi;
 };
 
 static struct can_bittiming_const pch_can_bittiming_const = {
@@ -245,14 +241,27 @@ static void pch_can_set_optmode(struct pch_can_priv *priv)
 	iowrite32(reg_val, &priv->regs->opt);
 }
 
+static void pch_can_rw_msg_obj(void __iomem *creq_addr, u32 num)
+{
+	int counter = PCH_COUNTER_LIMIT;
+	u32 ifx_creq;
+
+	iowrite32(num, creq_addr);
+	while (counter) {
+		ifx_creq = ioread32(creq_addr) & PCH_IF_CREQ_BUSY;
+		if (!ifx_creq)
+			break;
+		counter--;
+		udelay(1);
+	}
+	if (!counter)
+		pr_err("%s:IF1 BUSY Flag is set forever.\n", __func__);
+}
+
 static void pch_can_set_int_enables(struct pch_can_priv *priv,
 				    enum pch_can_mode interrupt_no)
 {
 	switch (interrupt_no) {
-	case PCH_CAN_ENABLE:
-		pch_can_bit_set(&priv->regs->cont, PCH_CTRL_IE);
-		break;
-
 	case PCH_CAN_DISABLE:
 		pch_can_bit_clear(&priv->regs->cont, PCH_CTRL_IE);
 		break;
@@ -271,25 +280,8 @@ static void pch_can_set_int_enables(struct pch_can_priv *priv,
 	}
 }
 
-static void pch_can_check_if_busy(u32 __iomem *creq_addr, u32 num)
-{
-	u32 counter = PCH_COUNTER_LIMIT;
-	u32 ifx_creq;
-
-	iowrite32(num, creq_addr);
-	while (counter) {
-		ifx_creq = ioread32(creq_addr) & PCH_IF_CREQ_BUSY;
-		if (!ifx_creq)
-			break;
-		counter--;
-		udelay(1);
-	}
-	if (!counter)
-		pr_err("%s:IF1 BUSY Flag is set forever.\n", __func__);
-}
-
 static void pch_can_set_rxtx(struct pch_can_priv *priv, u32 buff_num,
-			     u32 set, enum pch_ifreg dir)
+			     int set, enum pch_ifreg dir)
 {
 	u32 ie;
 
@@ -300,27 +292,27 @@ static void pch_can_set_rxtx(struct pch_can_priv *priv, u32 buff_num,
 
 	/* Reading the receive buffer data from RAM to Interface1 registers */
 	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[dir].cmask);
-	pch_can_check_if_busy(&priv->regs->ifregs[dir].creq, buff_num);
+	pch_can_rw_msg_obj(&priv->regs->ifregs[dir].creq, buff_num);
 
 	/* Setting the IF1MASK1 register to access MsgVal and RxIE bits */
 	iowrite32(PCH_CMASK_RDWR | PCH_CMASK_ARB | PCH_CMASK_CTRL,
 		  &priv->regs->ifregs[dir].cmask);
 
-	if (set == PCH_ENABLE) {
+	if (set) {
 		/* Setting the MsgVal and RxIE bits */
 		pch_can_bit_set(&priv->regs->ifregs[dir].mcont, ie);
 		pch_can_bit_set(&priv->regs->ifregs[dir].id2, PCH_ID_MSGVAL);
 
-	} else if (set == PCH_DISABLE) {
+	} else {
 		/* Resetting the MsgVal and RxIE bits */
 		pch_can_bit_clear(&priv->regs->ifregs[dir].mcont, ie);
 		pch_can_bit_clear(&priv->regs->ifregs[dir].id2, PCH_ID_MSGVAL);
 	}
 
-	pch_can_check_if_busy(&priv->regs->ifregs[dir].creq, buff_num);
+	pch_can_rw_msg_obj(&priv->regs->ifregs[dir].creq, buff_num);
 }
 
-static void pch_can_set_rx_all(struct pch_can_priv *priv, u32 set)
+static void pch_can_set_rx_all(struct pch_can_priv *priv, int set)
 {
 	int i;
 
@@ -329,7 +321,7 @@ static void pch_can_set_rx_all(struct pch_can_priv *priv, u32 set)
 		pch_can_set_rxtx(priv, i, set, PCH_RX_IFREG);
 }
 
-static void pch_can_set_tx_all(struct pch_can_priv *priv, u32 set)
+static void pch_can_set_tx_all(struct pch_can_priv *priv, int set)
 {
 	int i;
 
@@ -338,16 +330,16 @@ static void pch_can_set_tx_all(struct pch_can_priv *priv, u32 set)
 		pch_can_set_rxtx(priv, i, set, PCH_TX_IFREG);
 }
 
-static int pch_can_int_pending(struct pch_can_priv *priv)
+static u32 pch_can_int_pending(struct pch_can_priv *priv)
 {
 	return ioread32(&priv->regs->intr) & 0xffff;
 }
 
-static void pch_can_clear_buffers(struct pch_can_priv *priv)
+static void pch_can_clear_if_buffers(struct pch_can_priv *priv)
 {
-	int i;
+	int i; /* Msg Obj ID (1~32) */
 
-	for (i = PCH_RX_OBJ_START; i <= PCH_RX_OBJ_END; i++) {
+	for (i = PCH_RX_OBJ_START; i <= PCH_TX_OBJ_END; i++) {
 		iowrite32(PCH_CMASK_RX_TX_SET, &priv->regs->ifregs[0].cmask);
 		iowrite32(0xffff, &priv->regs->ifregs[0].mask1);
 		iowrite32(0xffff, &priv->regs->ifregs[0].mask2);
@@ -361,24 +353,7 @@ static void pch_can_clear_buffers(struct pch_can_priv *priv)
 		iowrite32(PCH_CMASK_RDWR | PCH_CMASK_MASK |
 			  PCH_CMASK_ARB | PCH_CMASK_CTRL,
 			  &priv->regs->ifregs[0].cmask);
-		pch_can_check_if_busy(&priv->regs->ifregs[0].creq, i);
-	}
-
-	for (i = PCH_TX_OBJ_START;  i <= PCH_TX_OBJ_END; i++) {
-		iowrite32(PCH_CMASK_RX_TX_SET, &priv->regs->ifregs[1].cmask);
-		iowrite32(0xffff, &priv->regs->ifregs[1].mask1);
-		iowrite32(0xffff, &priv->regs->ifregs[1].mask2);
-		iowrite32(0x0, &priv->regs->ifregs[1].id1);
-		iowrite32(0x0, &priv->regs->ifregs[1].id2);
-		iowrite32(0x0, &priv->regs->ifregs[1].mcont);
-		iowrite32(0x0, &priv->regs->ifregs[1].data[0]);
-		iowrite32(0x0, &priv->regs->ifregs[1].data[1]);
-		iowrite32(0x0, &priv->regs->ifregs[1].data[2]);
-		iowrite32(0x0, &priv->regs->ifregs[1].data[3]);
-		iowrite32(PCH_CMASK_RDWR | PCH_CMASK_MASK |
-			  PCH_CMASK_ARB | PCH_CMASK_CTRL,
-			  &priv->regs->ifregs[1].cmask);
-		pch_can_check_if_busy(&priv->regs->ifregs[1].creq, i);
+		pch_can_rw_msg_obj(&priv->regs->ifregs[0].creq, i);
 	}
 }
 
@@ -389,7 +364,7 @@ static void pch_can_config_rx_tx_buffers(struct pch_can_priv *priv)
 	for (i = PCH_RX_OBJ_START; i <= PCH_RX_OBJ_END; i++) {
 		iowrite32(PCH_CMASK_RX_TX_GET,
 			&priv->regs->ifregs[0].cmask);
-		pch_can_check_if_busy(&priv->regs->ifregs[0].creq, i);
+		pch_can_rw_msg_obj(&priv->regs->ifregs[0].creq, i);
 
 		iowrite32(0x0, &priv->regs->ifregs[0].id1);
 		iowrite32(0x0, &priv->regs->ifregs[0].id2);
@@ -403,6 +378,9 @@ static void pch_can_config_rx_tx_buffers(struct pch_can_priv *priv)
 		/* In case FIFO mode, Last EoB of Rx Obj must be 1 */
 		if (i == PCH_RX_OBJ_END)
 			pch_can_bit_set(&priv->regs->ifregs[0].mcont,
+					PCH_IF_MCONT_EOB);
+		else
+			pch_can_bit_clear(&priv->regs->ifregs[0].mcont,
 					  PCH_IF_MCONT_EOB);
 
 		iowrite32(0, &priv->regs->ifregs[0].mask1);
@@ -414,13 +392,13 @@ static void pch_can_config_rx_tx_buffers(struct pch_can_priv *priv)
 			  PCH_CMASK_ARB | PCH_CMASK_CTRL,
 			  &priv->regs->ifregs[0].cmask);
 
-		pch_can_check_if_busy(&priv->regs->ifregs[0].creq, i);
+		pch_can_rw_msg_obj(&priv->regs->ifregs[0].creq, i);
 	}
 
 	for (i = PCH_TX_OBJ_START; i <= PCH_TX_OBJ_END; i++) {
 		iowrite32(PCH_CMASK_RX_TX_GET,
 			&priv->regs->ifregs[1].cmask);
-		pch_can_check_if_busy(&priv->regs->ifregs[1].creq, i);
+		pch_can_rw_msg_obj(&priv->regs->ifregs[1].creq, i);
 
 		/* Resetting DIR bit for reception */
 		iowrite32(0x0, &priv->regs->ifregs[1].id1);
@@ -441,7 +419,7 @@ static void pch_can_config_rx_tx_buffers(struct pch_can_priv *priv)
 			  PCH_CMASK_ARB | PCH_CMASK_CTRL,
 			  &priv->regs->ifregs[1].cmask);
 
-		pch_can_check_if_busy(&priv->regs->ifregs[1].creq, i);
+		pch_can_rw_msg_obj(&priv->regs->ifregs[1].creq, i);
 	}
 }
 
@@ -451,7 +429,7 @@ static void pch_can_init(struct pch_can_priv *priv)
 	pch_can_set_run_mode(priv, PCH_CAN_STOP);
 
 	/* Clearing all the message object buffers. */
-	pch_can_clear_buffers(priv);
+	pch_can_clear_if_buffers(priv);
 
 	/* Configuring the respective message object as either rx/tx object. */
 	pch_can_config_rx_tx_buffers(priv);
@@ -496,7 +474,7 @@ static void pch_can_int_clr(struct pch_can_priv *priv, u32 mask)
 		pch_can_bit_clear(&priv->regs->ifregs[0].mcont,
 				  PCH_IF_MCONT_NEWDAT | PCH_IF_MCONT_INTPND);
 
-		pch_can_check_if_busy(&priv->regs->ifregs[0].creq, mask);
+		pch_can_rw_msg_obj(&priv->regs->ifregs[0].creq, mask);
 	} else if ((mask >= PCH_TX_OBJ_START) && (mask <= PCH_TX_OBJ_END)) {
 		/* Setting CMASK for clearing interrupts for
 					 frame transmission. */
@@ -512,7 +490,7 @@ static void pch_can_int_clr(struct pch_can_priv *priv, u32 mask)
 		pch_can_bit_clear(&priv->regs->ifregs[1].mcont,
 				  PCH_IF_MCONT_NEWDAT | PCH_IF_MCONT_INTPND |
 				  PCH_IF_MCONT_TXRQXT);
-		pch_can_check_if_busy(&priv->regs->ifregs[1].creq, mask);
+		pch_can_rw_msg_obj(&priv->regs->ifregs[1].creq, mask);
 	}
 }
 
@@ -637,7 +615,7 @@ static void pch_fifo_thresh(struct pch_can_priv *priv, int obj_id)
 		/* Clearing NewDat & IntPnd */
 		pch_can_bit_clear(&priv->regs->ifregs[0].mcont,
 				  PCH_IF_MCONT_INTPND);
-		pch_can_check_if_busy(&priv->regs->ifregs[0].creq, obj_id);
+		pch_can_rw_msg_obj(&priv->regs->ifregs[0].creq, obj_id);
 	} else if (obj_id > PCH_FIFO_THRESH) {
 		pch_can_int_clr(priv, obj_id);
 	} else if (obj_id == PCH_FIFO_THRESH) {
@@ -659,7 +637,7 @@ static void pch_can_rx_msg_lost(struct net_device *ndev, int obj_id)
 			  PCH_IF_MCONT_MSGLOST);
 	iowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL,
 		  &priv->regs->ifregs[0].cmask);
-	pch_can_check_if_busy(&priv->regs->ifregs[0].creq, obj_id);
+	pch_can_rw_msg_obj(&priv->regs->ifregs[0].creq, obj_id);
 
 	skb = alloc_can_err_skb(ndev, &cf);
 	if (!skb)
@@ -689,7 +667,7 @@ static int pch_can_rx_normal(struct net_device *ndev, u32 obj_num, int quota)
 	do {
 		/* Reading the messsage object from the Message RAM */
 		iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[0].cmask);
-		pch_can_check_if_busy(&priv->regs->ifregs[0].creq, obj_num);
+		pch_can_rw_msg_obj(&priv->regs->ifregs[0].creq, obj_num);
 
 		/* Reading the MCONT register. */
 		reg = ioread32(&priv->regs->ifregs[0].mcont);
@@ -758,7 +736,7 @@ static void pch_can_tx_complete(struct net_device *ndev, u32 int_stat)
 	can_get_echo_skb(ndev, int_stat - PCH_RX_OBJ_END - 1);
 	iowrite32(PCH_CMASK_RX_TX_GET | PCH_CMASK_CLRINTPND,
 		  &priv->regs->ifregs[1].cmask);
-	pch_can_check_if_busy(&priv->regs->ifregs[1].creq, int_stat);
+	pch_can_rw_msg_obj(&priv->regs->ifregs[1].creq, int_stat);
 	dlc = get_can_dlc(ioread32(&priv->regs->ifregs[1].mcont) &
 			  PCH_IF_MCONT_DLC);
 	stats->tx_bytes += dlc;
@@ -767,7 +745,7 @@ static void pch_can_tx_complete(struct net_device *ndev, u32 int_stat)
 		netif_wake_queue(ndev);
 }
 
-static int pch_can_rx_poll(struct napi_struct *napi, int quota)
+static int pch_can_poll(struct napi_struct *napi, int quota)
 {
 	struct net_device *ndev = napi->dev;
 	struct pch_can_priv *priv = netdev_priv(ndev);
@@ -832,10 +810,10 @@ static int pch_set_bittiming(struct net_device *ndev)
 
 	brp = (bt->tq) / (1000000000/PCH_CAN_CLK) - 1;
 	canbit = brp & PCH_MSK_BITT_BRP;
-	canbit |= (bt->sjw - 1) << PCH_BIT_SJW;
-	canbit |= (bt->phase_seg1 + bt->prop_seg - 1) << PCH_BIT_TSEG1;
-	canbit |= (bt->phase_seg2 - 1) << PCH_BIT_TSEG2;
-	bepe = (brp & PCH_MSK_BRPE_BRPE) >> PCH_BIT_BRPE_BRPE;
+	canbit |= (bt->sjw - 1) << PCH_BIT_SJW_SHIFT;
+	canbit |= (bt->phase_seg1 + bt->prop_seg - 1) << PCH_BIT_TSEG1_SHIFT;
+	canbit |= (bt->phase_seg2 - 1) << PCH_BIT_TSEG2_SHIFT;
+	bepe = (brp & PCH_MSK_BRPE_BRPE) >> PCH_BIT_BRPE_BRPE_SHIFT;
 	iowrite32(canbit, &priv->regs->bitt);
 	iowrite32(bepe, &priv->regs->brpe);
 	pch_can_bit_clear(&priv->regs->cont, PCH_CTRL_CCE);
@@ -947,7 +925,7 @@ static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
 {
 	struct pch_can_priv *priv = netdev_priv(ndev);
 	struct can_frame *cf = (struct can_frame *)skb->data;
-	int tx_buffer_avail = 0;
+	int tx_obj_no;
 	int i;
 
 	if (can_dropped_invalid_skb(ndev, skb))
@@ -957,16 +935,16 @@ static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
 		if (ioread32(&priv->regs->treq2) & PCH_TREQ2_TX_MASK)
 			netif_stop_queue(ndev);
 
-		tx_buffer_avail = priv->tx_obj;
+		tx_obj_no = priv->tx_obj;
 		priv->tx_obj = PCH_TX_OBJ_START;
 	} else {
-		tx_buffer_avail = priv->tx_obj;
+		tx_obj_no = priv->tx_obj;
 		priv->tx_obj++;
 	}
 
 	/* Reading the Msg Obj from the Msg RAM to the Interface register. */
 	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[1].cmask);
-	pch_can_check_if_busy(&priv->regs->ifregs[1].creq, tx_buffer_avail);
+	pch_can_rw_msg_obj(&priv->regs->ifregs[1].creq, tx_obj_no);
 
 	/* Setting the CMASK register. */
 	pch_can_bit_set(&priv->regs->ifregs[1].cmask, PCH_CMASK_ALL);
@@ -995,7 +973,7 @@ static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
 			  &priv->regs->ifregs[1].data[i / 2]);
 	}
 
-	can_put_echo_skb(skb, ndev, tx_buffer_avail - PCH_RX_OBJ_END - 1);
+	can_put_echo_skb(skb, ndev, tx_obj_no - PCH_RX_OBJ_END - 1);
 
 	/* Updating the size of the data. */
 	pch_can_bit_clear(&priv->regs->ifregs[1].mcont, 0x0f);
@@ -1010,7 +988,7 @@ static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
 	pch_can_bit_set(&priv->regs->ifregs[1].mcont,
 			PCH_IF_MCONT_NEWDAT | PCH_IF_MCONT_TXRQXT);
 
-	pch_can_check_if_busy(&priv->regs->ifregs[1].creq, tx_buffer_avail);
+	pch_can_rw_msg_obj(&priv->regs->ifregs[1].creq, tx_obj_no);
 
 	return NETDEV_TX_OK;
 }
@@ -1064,7 +1042,7 @@ static u32 pch_can_get_rxtx_ir(struct pch_can_priv *priv, u32 buff_num,
 		ie = PCH_IF_MCONT_TXIE;
 
 	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[dir].cmask);
-	pch_can_check_if_busy(&priv->regs->ifregs[dir].creq, buff_num);
+	pch_can_rw_msg_obj(&priv->regs->ifregs[dir].creq, buff_num);
 
 	if (((ioread32(&priv->regs->ifregs[dir].id2)) & PCH_ID_MSGVAL) &&
 			((ioread32(&priv->regs->ifregs[dir].mcont)) & ie)) {
@@ -1076,37 +1054,37 @@ static u32 pch_can_get_rxtx_ir(struct pch_can_priv *priv, u32 buff_num,
 }
 
 static void pch_can_set_rx_buffer_link(struct pch_can_priv *priv,
-				       u32 buffer_num, u32 set)
+				       u32 buffer_num, int set)
 {
 	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[0].cmask);
-	pch_can_check_if_busy(&priv->regs->ifregs[0].creq, buffer_num);
+	pch_can_rw_msg_obj(&priv->regs->ifregs[0].creq, buffer_num);
 	iowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL,
 		  &priv->regs->ifregs[0].cmask);
-	if (set == PCH_ENABLE)
+	if (set)
 		pch_can_bit_clear(&priv->regs->ifregs[0].mcont,
 				  PCH_IF_MCONT_EOB);
 	else
 		pch_can_bit_set(&priv->regs->ifregs[0].mcont, PCH_IF_MCONT_EOB);
 
-	pch_can_check_if_busy(&priv->regs->ifregs[0].creq, buffer_num);
+	pch_can_rw_msg_obj(&priv->regs->ifregs[0].creq, buffer_num);
 }
 
 static void pch_can_get_rx_buffer_link(struct pch_can_priv *priv,
 				       u32 buffer_num, u32 *link)
 {
 	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[0].cmask);
-	pch_can_check_if_busy(&priv->regs->ifregs[0].creq, buffer_num);
+	pch_can_rw_msg_obj(&priv->regs->ifregs[0].creq, buffer_num);
 
 	if (ioread32(&priv->regs->ifregs[0].mcont) & PCH_IF_MCONT_EOB)
-		*link = PCH_DISABLE;
+		*link = 0;
 	else
-		*link = PCH_ENABLE;
+		*link = 1;
 }
 
 static int pch_can_get_buffer_status(struct pch_can_priv *priv)
 {
 	return (ioread32(&priv->regs->treq1) & 0xffff) |
-	       ((ioread32(&priv->regs->treq2) & 0xffff) << 16);
+	       (ioread32(&priv->regs->treq2) << 16);
 }
 
 static int pch_can_suspend(struct pci_dev *pdev, pm_message_t state)
@@ -1114,7 +1092,7 @@ static int pch_can_suspend(struct pci_dev *pdev, pm_message_t state)
 	int i;			/* Counter variable. */
 	int retval;		/* Return value. */
 	u32 buf_stat;	/* Variable for reading the transmit buffer status. */
-	u32 counter = 0xFFFFFF;
+	int counter = PCH_COUNTER_LIMIT;
 
 	struct net_device *dev = pci_get_drvdata(pdev);
 	struct pch_can_priv *priv = netdev_priv(dev);
@@ -1291,7 +1269,7 @@ static int __devinit pch_can_probe(struct pci_dev *pdev,
 	ndev->netdev_ops = &pch_can_netdev_ops;
 	priv->can.clock.freq = PCH_CAN_CLK; /* Hz */
 
-	netif_napi_add(ndev, &priv->napi, pch_can_rx_poll, PCH_RX_OBJ_END);
+	netif_napi_add(ndev, &priv->napi, pch_can_poll, PCH_RX_OBJ_END);
 
 	rc = register_candev(ndev);
 	if (rc) {

commit 7f2bc50efeaeb1dff62ef7e128ae36499fbcf35d
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Sun Dec 12 20:24:11 2010 +0000

    pch_can: Fix warnings
    
    Currently, in case CONFIG_PM is disabled, compiler outputs warnings.
    Move six functions which are used only CONFIG_PM is enabled,
    into "#ifdef CONFIG_PM" area.
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index d646fbcd546a..5fc99cb10df0 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -245,23 +245,6 @@ static void pch_can_set_optmode(struct pch_can_priv *priv)
 	iowrite32(reg_val, &priv->regs->opt);
 }
 
-static void pch_can_set_int_custom(struct pch_can_priv *priv)
-{
-	/* Clearing the IE, SIE and EIE bits of Can control register. */
-	pch_can_bit_clear(&priv->regs->cont, PCH_CTRL_IE_SIE_EIE);
-
-	/* Appropriately setting them. */
-	pch_can_bit_set(&priv->regs->cont,
-			((priv->int_enables & PCH_MSK_CTRL_IE_SIE_EIE) << 1));
-}
-
-/* This function retrieves interrupt enabled for the CAN device. */
-static void pch_can_get_int_enables(struct pch_can_priv *priv, u32 *enables)
-{
-	/* Obtaining the status of IE, SIE and EIE interrupt bits. */
-	*enables = ((ioread32(&priv->regs->cont) & PCH_CTRL_IE_SIE_EIE) >> 1);
-}
-
 static void pch_can_set_int_enables(struct pch_can_priv *priv,
 				    enum pch_can_mode interrupt_no)
 {
@@ -355,61 +338,11 @@ static void pch_can_set_tx_all(struct pch_can_priv *priv, u32 set)
 		pch_can_set_rxtx(priv, i, set, PCH_TX_IFREG);
 }
 
-static u32 pch_can_get_rxtx_ir(struct pch_can_priv *priv, u32 buff_num,
-			       enum pch_ifreg dir)
-{
-	u32 ie, enable;
-
-	if (dir)
-		ie = PCH_IF_MCONT_RXIE;
-	else
-		ie = PCH_IF_MCONT_TXIE;
-
-	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[dir].cmask);
-	pch_can_check_if_busy(&priv->regs->ifregs[dir].creq, buff_num);
-
-	if (((ioread32(&priv->regs->ifregs[dir].id2)) & PCH_ID_MSGVAL) &&
-			((ioread32(&priv->regs->ifregs[dir].mcont)) & ie)) {
-		enable = 1;
-	} else {
-		enable = 0;
-	}
-	return enable;
-}
-
 static int pch_can_int_pending(struct pch_can_priv *priv)
 {
 	return ioread32(&priv->regs->intr) & 0xffff;
 }
 
-static void pch_can_set_rx_buffer_link(struct pch_can_priv *priv,
-				       u32 buffer_num, u32 set)
-{
-	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[0].cmask);
-	pch_can_check_if_busy(&priv->regs->ifregs[0].creq, buffer_num);
-	iowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL,
-		  &priv->regs->ifregs[0].cmask);
-	if (set == PCH_ENABLE)
-		pch_can_bit_clear(&priv->regs->ifregs[0].mcont,
-				  PCH_IF_MCONT_EOB);
-	else
-		pch_can_bit_set(&priv->regs->ifregs[0].mcont, PCH_IF_MCONT_EOB);
-
-	pch_can_check_if_busy(&priv->regs->ifregs[0].creq, buffer_num);
-}
-
-static void pch_can_get_rx_buffer_link(struct pch_can_priv *priv,
-				       u32 buffer_num, u32 *link)
-{
-	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[0].cmask);
-	pch_can_check_if_busy(&priv->regs->ifregs[0].creq, buffer_num);
-
-	if (ioread32(&priv->regs->ifregs[0].mcont) & PCH_IF_MCONT_EOB)
-		*link = PCH_DISABLE;
-	else
-		*link = PCH_ENABLE;
-}
-
 static void pch_can_clear_buffers(struct pch_can_priv *priv)
 {
 	int i;
@@ -583,12 +516,6 @@ static void pch_can_int_clr(struct pch_can_priv *priv, u32 mask)
 	}
 }
 
-static int pch_can_get_buffer_status(struct pch_can_priv *priv)
-{
-	return (ioread32(&priv->regs->treq1) & 0xffff) |
-	       ((ioread32(&priv->regs->treq2) & 0xffff) << 16);
-}
-
 static void pch_can_reset(struct pch_can_priv *priv)
 {
 	/* write to sw reset register */
@@ -1109,6 +1036,79 @@ static void __devexit pch_can_remove(struct pci_dev *pdev)
 }
 
 #ifdef CONFIG_PM
+static void pch_can_set_int_custom(struct pch_can_priv *priv)
+{
+	/* Clearing the IE, SIE and EIE bits of Can control register. */
+	pch_can_bit_clear(&priv->regs->cont, PCH_CTRL_IE_SIE_EIE);
+
+	/* Appropriately setting them. */
+	pch_can_bit_set(&priv->regs->cont,
+			((priv->int_enables & PCH_MSK_CTRL_IE_SIE_EIE) << 1));
+}
+
+/* This function retrieves interrupt enabled for the CAN device. */
+static void pch_can_get_int_enables(struct pch_can_priv *priv, u32 *enables)
+{
+	/* Obtaining the status of IE, SIE and EIE interrupt bits. */
+	*enables = ((ioread32(&priv->regs->cont) & PCH_CTRL_IE_SIE_EIE) >> 1);
+}
+
+static u32 pch_can_get_rxtx_ir(struct pch_can_priv *priv, u32 buff_num,
+			       enum pch_ifreg dir)
+{
+	u32 ie, enable;
+
+	if (dir)
+		ie = PCH_IF_MCONT_RXIE;
+	else
+		ie = PCH_IF_MCONT_TXIE;
+
+	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[dir].cmask);
+	pch_can_check_if_busy(&priv->regs->ifregs[dir].creq, buff_num);
+
+	if (((ioread32(&priv->regs->ifregs[dir].id2)) & PCH_ID_MSGVAL) &&
+			((ioread32(&priv->regs->ifregs[dir].mcont)) & ie)) {
+		enable = 1;
+	} else {
+		enable = 0;
+	}
+	return enable;
+}
+
+static void pch_can_set_rx_buffer_link(struct pch_can_priv *priv,
+				       u32 buffer_num, u32 set)
+{
+	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[0].cmask);
+	pch_can_check_if_busy(&priv->regs->ifregs[0].creq, buffer_num);
+	iowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL,
+		  &priv->regs->ifregs[0].cmask);
+	if (set == PCH_ENABLE)
+		pch_can_bit_clear(&priv->regs->ifregs[0].mcont,
+				  PCH_IF_MCONT_EOB);
+	else
+		pch_can_bit_set(&priv->regs->ifregs[0].mcont, PCH_IF_MCONT_EOB);
+
+	pch_can_check_if_busy(&priv->regs->ifregs[0].creq, buffer_num);
+}
+
+static void pch_can_get_rx_buffer_link(struct pch_can_priv *priv,
+				       u32 buffer_num, u32 *link)
+{
+	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[0].cmask);
+	pch_can_check_if_busy(&priv->regs->ifregs[0].creq, buffer_num);
+
+	if (ioread32(&priv->regs->ifregs[0].mcont) & PCH_IF_MCONT_EOB)
+		*link = PCH_DISABLE;
+	else
+		*link = PCH_ENABLE;
+}
+
+static int pch_can_get_buffer_status(struct pch_can_priv *priv)
+{
+	return (ioread32(&priv->regs->treq1) & 0xffff) |
+	       ((ioread32(&priv->regs->treq2) & 0xffff) << 16);
+}
+
 static int pch_can_suspend(struct pci_dev *pdev, pm_message_t state)
 {
 	int i;			/* Counter variable. */

commit 1d5b4b2778e8e40f42ae5d9556777583f3556d81
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Sun Dec 12 20:24:10 2010 +0000

    pch_can: Improve rx processing
    
    Replace complex "goto" to "do~while".
    For easy to read/understand, it divides a rx function into some functions.
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 210957f093bb..d646fbcd546a 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -698,83 +698,110 @@ static irqreturn_t pch_can_interrupt(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static int pch_can_rx_normal(struct net_device *ndev, u32 int_stat)
+static void pch_fifo_thresh(struct pch_can_priv *priv, int obj_id)
+{
+	if (obj_id < PCH_FIFO_THRESH) {
+		iowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL |
+			  PCH_CMASK_ARB, &priv->regs->ifregs[0].cmask);
+
+		/* Clearing the Dir bit. */
+		pch_can_bit_clear(&priv->regs->ifregs[0].id2, PCH_ID2_DIR);
+
+		/* Clearing NewDat & IntPnd */
+		pch_can_bit_clear(&priv->regs->ifregs[0].mcont,
+				  PCH_IF_MCONT_INTPND);
+		pch_can_check_if_busy(&priv->regs->ifregs[0].creq, obj_id);
+	} else if (obj_id > PCH_FIFO_THRESH) {
+		pch_can_int_clr(priv, obj_id);
+	} else if (obj_id == PCH_FIFO_THRESH) {
+		int cnt;
+		for (cnt = 0; cnt < PCH_FIFO_THRESH; cnt++)
+			pch_can_int_clr(priv, cnt + 1);
+	}
+}
+
+static void pch_can_rx_msg_lost(struct net_device *ndev, int obj_id)
+{
+	struct pch_can_priv *priv = netdev_priv(ndev);
+	struct net_device_stats *stats = &(priv->ndev->stats);
+	struct sk_buff *skb;
+	struct can_frame *cf;
+
+	netdev_dbg(priv->ndev, "Msg Obj is overwritten.\n");
+	pch_can_bit_clear(&priv->regs->ifregs[0].mcont,
+			  PCH_IF_MCONT_MSGLOST);
+	iowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL,
+		  &priv->regs->ifregs[0].cmask);
+	pch_can_check_if_busy(&priv->regs->ifregs[0].creq, obj_id);
+
+	skb = alloc_can_err_skb(ndev, &cf);
+	if (!skb)
+		return;
+
+	cf->can_id |= CAN_ERR_CRTL;
+	cf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
+	stats->rx_over_errors++;
+	stats->rx_errors++;
+
+	netif_receive_skb(skb);
+}
+
+static int pch_can_rx_normal(struct net_device *ndev, u32 obj_num, int quota)
 {
 	u32 reg;
 	canid_t id;
-	u32 ide;
-	u32 rtr;
-	int i, k;
 	int rcv_pkts = 0;
 	struct sk_buff *skb;
 	struct can_frame *cf;
 	struct pch_can_priv *priv = netdev_priv(ndev);
 	struct net_device_stats *stats = &(priv->ndev->stats);
+	int i;
+	u32 id2;
 	u16 data_reg;
 
-	/* Reading the messsage object from the Message RAM */
-	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[0].cmask);
-	pch_can_check_if_busy(&priv->regs->ifregs[0].creq, int_stat);
+	do {
+		/* Reading the messsage object from the Message RAM */
+		iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[0].cmask);
+		pch_can_check_if_busy(&priv->regs->ifregs[0].creq, obj_num);
 
-	/* Reading the MCONT register. */
-	reg = ioread32(&priv->regs->ifregs[0].mcont);
-	reg &= 0xffff;
+		/* Reading the MCONT register. */
+		reg = ioread32(&priv->regs->ifregs[0].mcont);
+
+		if (reg & PCH_IF_MCONT_EOB)
+			break;
 
-	for (k = int_stat; !(reg & PCH_IF_MCONT_EOB); k++) {
 		/* If MsgLost bit set. */
 		if (reg & PCH_IF_MCONT_MSGLOST) {
-			dev_err(&priv->ndev->dev, "Msg Obj is overwritten.\n");
-			pch_can_bit_clear(&priv->regs->ifregs[0].mcont,
-					  PCH_IF_MCONT_MSGLOST);
-			iowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL,
-				  &priv->regs->ifregs[0].cmask);
-			pch_can_check_if_busy(&priv->regs->ifregs[0].creq, k);
-
-			skb = alloc_can_err_skb(ndev, &cf);
-			if (!skb)
-				return -ENOMEM;
-
-			priv->can.can_stats.error_passive++;
-			priv->can.state = CAN_STATE_ERROR_PASSIVE;
-			cf->can_id |= CAN_ERR_CRTL;
-			cf->data[1] |= CAN_ERR_CRTL_RX_OVERFLOW;
-			cf->data[2] |= CAN_ERR_PROT_OVERLOAD;
-			stats->rx_packets++;
-			stats->rx_bytes += cf->can_dlc;
-
-			netif_receive_skb(skb);
+			pch_can_rx_msg_lost(ndev, obj_num);
 			rcv_pkts++;
-			goto RX_NEXT;
+			quota--;
+			obj_num++;
+			continue;
+		} else if (!(reg & PCH_IF_MCONT_NEWDAT)) {
+			obj_num++;
+			continue;
 		}
-		if (!(reg & PCH_IF_MCONT_NEWDAT))
-			goto RX_NEXT;
 
 		skb = alloc_can_skb(priv->ndev, &cf);
 		if (!skb)
 			return -ENOMEM;
 
 		/* Get Received data */
-		ide = ((ioread32(&priv->regs->ifregs[0].id2)) & PCH_ID2_XTD) >>
-									     14;
-		if (ide) {
+		id2 = ioread32(&priv->regs->ifregs[0].id2);
+		if (id2 & PCH_ID2_XTD) {
 			id = (ioread32(&priv->regs->ifregs[0].id1) & 0xffff);
-			id |= (((ioread32(&priv->regs->ifregs[0].id2)) &
-					    0x1fff) << 16);
-			cf->can_id = (id & CAN_EFF_MASK) | CAN_EFF_FLAG;
+			id |= (((id2) & 0x1fff) << 16);
+			cf->can_id = id | CAN_EFF_FLAG;
 		} else {
-			id = (((ioread32(&priv->regs->ifregs[0].id2)) &
-						     (CAN_SFF_MASK << 2)) >> 2);
-			cf->can_id = (id & CAN_SFF_MASK);
+			id = (id2 >> 2) & CAN_SFF_MASK;
+			cf->can_id = id;
 		}
 
-		rtr = (ioread32(&priv->regs->ifregs[0].id2) &  PCH_ID2_DIR);
-		if (rtr) {
-			cf->can_dlc = 0;
+		if (id2 & PCH_ID2_DIR)
 			cf->can_id |= CAN_RTR_FLAG;
-		} else {
-			cf->can_dlc =
-			      ((ioread32(&priv->regs->ifregs[0].mcont)) & 0x0f);
-		}
+
+		cf->can_dlc = get_can_dlc((ioread32(&priv->regs->
+						    ifregs[0].mcont)) & 0xF);
 
 		for (i = 0; i < cf->can_dlc; i += 2) {
 			data_reg = ioread16(&priv->regs->ifregs[0].data[i / 2]);
@@ -785,33 +812,12 @@ static int pch_can_rx_normal(struct net_device *ndev, u32 int_stat)
 		netif_receive_skb(skb);
 		rcv_pkts++;
 		stats->rx_packets++;
+		quota--;
 		stats->rx_bytes += cf->can_dlc;
 
-		if (k < PCH_FIFO_THRESH) {
-			iowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL |
-				  PCH_CMASK_ARB, &priv->regs->ifregs[0].cmask);
-
-			/* Clearing the Dir bit. */
-			pch_can_bit_clear(&priv->regs->ifregs[0].id2,
-					  PCH_ID2_DIR);
-
-			/* Clearing NewDat & IntPnd */
-			pch_can_bit_clear(&priv->regs->ifregs[0].mcont,
-					  PCH_IF_MCONT_INTPND);
-			pch_can_check_if_busy(&priv->regs->ifregs[0].creq, k);
-		} else if (k > PCH_FIFO_THRESH) {
-			pch_can_int_clr(priv, k);
-		} else if (k == PCH_FIFO_THRESH) {
-			int cnt;
-			for (cnt = 0; cnt < PCH_FIFO_THRESH; cnt++)
-				pch_can_int_clr(priv, cnt+1);
-		}
-RX_NEXT:
-		/* Reading the messsage object from the Message RAM */
-		iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[0].cmask);
-		pch_can_check_if_busy(&priv->regs->ifregs[0].creq, k);
-		reg = ioread32(&priv->regs->ifregs[0].mcont);
-	}
+		pch_fifo_thresh(priv, obj_num);
+		obj_num++;
+	} while (quota > 0);
 
 	return rcv_pkts;
 }
@@ -869,7 +875,7 @@ static int pch_can_rx_poll(struct napi_struct *napi, int quota)
 		goto end;
 
 	if ((int_stat >= PCH_RX_OBJ_START) && (int_stat <= PCH_RX_OBJ_END)) {
-		rcv_pkts += pch_can_rx_normal(ndev, int_stat);
+		rcv_pkts += pch_can_rx_normal(ndev, int_stat, quota);
 		quota -= rcv_pkts;
 		if (quota < 0)
 			goto end;

commit 8ac9702b9d5d81b819fc7d6b4f6abad22af01f3c
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Sun Dec 12 20:24:09 2010 +0000

    pch_can: Fix endianness issue
    
    there is endianness issue both Tx and Rx.
    Currently, data is set like below.
    Register:
    MSB--LSB
    x x D0 D1
    x x D2 D3
    x x D4 D5
    x x D6 D7
    
    But Data to be sent must be set like below.
    Register:
    MSB--LSB
    x x D1 D0
    x x D3 D2
    x x D5 D4
    x x D7 D6  (x means reserved area.)
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 0b6d4f490296..210957f093bb 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -138,10 +138,7 @@ struct pch_can_if_regs {
 	u32 id1;
 	u32 id2;
 	u32 mcont;
-	u32 dataa1;
-	u32 dataa2;
-	u32 datab1;
-	u32 datab2;
+	u32 data[4];
 	u32 rsv[13];
 };
 
@@ -424,10 +421,10 @@ static void pch_can_clear_buffers(struct pch_can_priv *priv)
 		iowrite32(0x0, &priv->regs->ifregs[0].id1);
 		iowrite32(0x0, &priv->regs->ifregs[0].id2);
 		iowrite32(0x0, &priv->regs->ifregs[0].mcont);
-		iowrite32(0x0, &priv->regs->ifregs[0].dataa1);
-		iowrite32(0x0, &priv->regs->ifregs[0].dataa2);
-		iowrite32(0x0, &priv->regs->ifregs[0].datab1);
-		iowrite32(0x0, &priv->regs->ifregs[0].datab2);
+		iowrite32(0x0, &priv->regs->ifregs[0].data[0]);
+		iowrite32(0x0, &priv->regs->ifregs[0].data[1]);
+		iowrite32(0x0, &priv->regs->ifregs[0].data[2]);
+		iowrite32(0x0, &priv->regs->ifregs[0].data[3]);
 		iowrite32(PCH_CMASK_RDWR | PCH_CMASK_MASK |
 			  PCH_CMASK_ARB | PCH_CMASK_CTRL,
 			  &priv->regs->ifregs[0].cmask);
@@ -441,10 +438,10 @@ static void pch_can_clear_buffers(struct pch_can_priv *priv)
 		iowrite32(0x0, &priv->regs->ifregs[1].id1);
 		iowrite32(0x0, &priv->regs->ifregs[1].id2);
 		iowrite32(0x0, &priv->regs->ifregs[1].mcont);
-		iowrite32(0x0, &priv->regs->ifregs[1].dataa1);
-		iowrite32(0x0, &priv->regs->ifregs[1].dataa2);
-		iowrite32(0x0, &priv->regs->ifregs[1].datab1);
-		iowrite32(0x0, &priv->regs->ifregs[1].datab2);
+		iowrite32(0x0, &priv->regs->ifregs[1].data[0]);
+		iowrite32(0x0, &priv->regs->ifregs[1].data[1]);
+		iowrite32(0x0, &priv->regs->ifregs[1].data[2]);
+		iowrite32(0x0, &priv->regs->ifregs[1].data[3]);
 		iowrite32(PCH_CMASK_RDWR | PCH_CMASK_MASK |
 			  PCH_CMASK_ARB | PCH_CMASK_CTRL,
 			  &priv->regs->ifregs[1].cmask);
@@ -707,12 +704,13 @@ static int pch_can_rx_normal(struct net_device *ndev, u32 int_stat)
 	canid_t id;
 	u32 ide;
 	u32 rtr;
-	int i, j, k;
+	int i, k;
 	int rcv_pkts = 0;
 	struct sk_buff *skb;
 	struct can_frame *cf;
 	struct pch_can_priv *priv = netdev_priv(ndev);
 	struct net_device_stats *stats = &(priv->ndev->stats);
+	u16 data_reg;
 
 	/* Reading the messsage object from the Message RAM */
 	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[0].cmask);
@@ -778,12 +776,10 @@ static int pch_can_rx_normal(struct net_device *ndev, u32 int_stat)
 			      ((ioread32(&priv->regs->ifregs[0].mcont)) & 0x0f);
 		}
 
-		for (i = 0, j = 0; i < cf->can_dlc; j++) {
-			reg = ioread32(&priv->regs->ifregs[0].dataa1 + j*4);
-			cf->data[i++] = cpu_to_le32(reg & 0xff);
-			if (i == cf->can_dlc)
-				break;
-			cf->data[i++] = cpu_to_le32((reg >> 8) & 0xff);
+		for (i = 0; i < cf->can_dlc; i += 2) {
+			data_reg = ioread16(&priv->regs->ifregs[0].data[i / 2]);
+			cf->data[i] = data_reg;
+			cf->data[i + 1] = data_reg >> 8;
 		}
 
 		netif_receive_skb(skb);
@@ -1016,10 +1012,10 @@ static int pch_close(struct net_device *ndev)
 
 static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
 {
-	int i, j;
 	struct pch_can_priv *priv = netdev_priv(ndev);
 	struct can_frame *cf = (struct can_frame *)skb->data;
 	int tx_buffer_avail = 0;
+	int i;
 
 	if (can_dropped_invalid_skb(ndev, skb))
 		return NETDEV_TX_OK;
@@ -1060,13 +1056,10 @@ static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
 	if (cf->can_id & CAN_RTR_FLAG)
 		pch_can_bit_clear(&priv->regs->ifregs[1].id2, PCH_ID2_DIR);
 
-	for (i = 0, j = 0; i < cf->can_dlc; j++) {
-		iowrite32(le32_to_cpu(cf->data[i++]),
-			 (&priv->regs->ifregs[1].dataa1) + j*4);
-		if (i == cf->can_dlc)
-			break;
-		iowrite32(le32_to_cpu(cf->data[i++] << 8),
-			 (&priv->regs->ifregs[1].dataa1) + j*4);
+	/* Copy data to register */
+	for (i = 0; i < cf->can_dlc; i += 2) {
+		iowrite16(cf->data[i] | (cf->data[i + 1] << 8),
+			  &priv->regs->ifregs[1].data[i / 2]);
 	}
 
 	can_put_echo_skb(skb, ndev, tx_buffer_avail - PCH_RX_OBJ_END - 1);

commit e489ccebf14657774fd877dc841b458703730586
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Sun Dec 12 20:24:08 2010 +0000

    pch_can: Divide poll function
    
    To easy to read/understand, divide poll function into two sub-functions.
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index f0f140492c07..0b6d4f490296 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -819,72 +819,71 @@ static int pch_can_rx_normal(struct net_device *ndev, u32 int_stat)
 
 	return rcv_pkts;
 }
-static int pch_can_rx_poll(struct napi_struct *napi, int quota)
+
+static void pch_can_tx_complete(struct net_device *ndev, u32 int_stat)
 {
-	struct net_device *ndev = napi->dev;
 	struct pch_can_priv *priv = netdev_priv(ndev);
 	struct net_device_stats *stats = &(priv->ndev->stats);
 	u32 dlc;
+
+	can_get_echo_skb(ndev, int_stat - PCH_RX_OBJ_END - 1);
+	iowrite32(PCH_CMASK_RX_TX_GET | PCH_CMASK_CLRINTPND,
+		  &priv->regs->ifregs[1].cmask);
+	pch_can_check_if_busy(&priv->regs->ifregs[1].creq, int_stat);
+	dlc = get_can_dlc(ioread32(&priv->regs->ifregs[1].mcont) &
+			  PCH_IF_MCONT_DLC);
+	stats->tx_bytes += dlc;
+	stats->tx_packets++;
+	if (int_stat == PCH_TX_OBJ_END)
+		netif_wake_queue(ndev);
+}
+
+static int pch_can_rx_poll(struct napi_struct *napi, int quota)
+{
+	struct net_device *ndev = napi->dev;
+	struct pch_can_priv *priv = netdev_priv(ndev);
 	u32 int_stat;
 	int rcv_pkts = 0;
 	u32 reg_stat;
 
 	int_stat = pch_can_int_pending(priv);
 	if (!int_stat)
-		return 0;
+		goto end;
 
-INT_STAT:
-	if (int_stat == PCH_STATUS_INT) {
+	if ((int_stat == PCH_STATUS_INT) && (quota > 0)) {
 		reg_stat = ioread32(&priv->regs->stat);
 		if (reg_stat & (PCH_BUS_OFF | PCH_LEC_ALL)) {
-			if ((reg_stat & PCH_LEC_ALL) != PCH_LEC_ALL)
+			if (reg_stat & PCH_BUS_OFF ||
+			   (reg_stat & PCH_LEC_ALL) != PCH_LEC_ALL) {
 				pch_can_error(ndev, reg_stat);
+				quota--;
+			}
 		}
 
-		if (reg_stat & PCH_TX_OK) {
-			iowrite32(PCH_CMASK_RX_TX_GET,
-				  &priv->regs->ifregs[1].cmask);
-			pch_can_check_if_busy(&priv->regs->ifregs[1].creq,
-					       ioread32(&priv->regs->intr));
+		if (reg_stat & PCH_TX_OK)
 			pch_can_bit_clear(&priv->regs->stat, PCH_TX_OK);
-		}
 
 		if (reg_stat & PCH_RX_OK)
 			pch_can_bit_clear(&priv->regs->stat, PCH_RX_OK);
 
 		int_stat = pch_can_int_pending(priv);
-		if (int_stat == PCH_STATUS_INT)
-			goto INT_STAT;
 	}
 
-MSG_OBJ:
+	if (quota == 0)
+		goto end;
+
 	if ((int_stat >= PCH_RX_OBJ_START) && (int_stat <= PCH_RX_OBJ_END)) {
-		rcv_pkts = pch_can_rx_normal(ndev, int_stat);
-		if (rcv_pkts < 0)
-			return 0;
+		rcv_pkts += pch_can_rx_normal(ndev, int_stat);
+		quota -= rcv_pkts;
+		if (quota < 0)
+			goto end;
 	} else if ((int_stat >= PCH_TX_OBJ_START) &&
 		   (int_stat <= PCH_TX_OBJ_END)) {
 		/* Handle transmission interrupt */
-		can_get_echo_skb(ndev, int_stat - PCH_RX_OBJ_END - 1);
-		iowrite32(PCH_CMASK_RX_TX_GET | PCH_CMASK_CLRINTPND,
-			  &priv->regs->ifregs[1].cmask);
-		dlc = ioread32(&priv->regs->ifregs[1].mcont) &
-			       PCH_IF_MCONT_DLC;
-		pch_can_check_if_busy(&priv->regs->ifregs[1].creq, int_stat);
-		if (dlc > 8)
-			dlc = 8;
-		stats->tx_bytes += dlc;
-		stats->tx_packets++;
-		if (int_stat == PCH_TX_OBJ_END)
-			netif_wake_queue(ndev);
+		pch_can_tx_complete(ndev, int_stat);
 	}
 
-	int_stat = pch_can_int_pending(priv);
-	if (int_stat == PCH_STATUS_INT)
-		goto INT_STAT;
-	else if (int_stat >= 1 && int_stat <= 32)
-		goto MSG_OBJ;
-
+end:
 	napi_complete(napi);
 	pch_can_set_int_enables(priv, PCH_CAN_ALL);
 

commit 76d94b232940ca91e9b26c590cb7312ab88ff722
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Sun Dec 12 20:24:07 2010 +0000

    pch_can: Add flow control processing
    
    Currently, there is no flow control processing.
    Thus, Add flow control processing as
    when there is no empty of tx buffer,
    netif_stop_queue is called.
    When there is empty buffer, netif_wake_queue is called.
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index a9b6a6525a65..f0f140492c07 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -102,6 +102,10 @@
 
 #define PCH_FIFO_THRESH		16
 
+/* TxRqst2 show status of MsgObjNo.17~32 */
+#define PCH_TREQ2_TX_MASK	(((1 << PCH_TX_OBJ_NUM) - 1) <<\
+							(PCH_RX_OBJ_END - 16))
+
 enum pch_ifreg {
 	PCH_RX_IFREG,
 	PCH_TX_IFREG,
@@ -871,6 +875,8 @@ static int pch_can_rx_poll(struct napi_struct *napi, int quota)
 			dlc = 8;
 		stats->tx_bytes += dlc;
 		stats->tx_packets++;
+		if (int_stat == PCH_TX_OBJ_END)
+			netif_wake_queue(ndev);
 	}
 
 	int_stat = pch_can_int_pending(priv);
@@ -1009,18 +1015,6 @@ static int pch_close(struct net_device *ndev)
 	return 0;
 }
 
-static int pch_get_msg_obj_sts(struct net_device *ndev, u32 obj_id)
-{
-	u32 buffer_status = 0;
-	struct pch_can_priv *priv = netdev_priv(ndev);
-
-	/* Getting the message object status. */
-	buffer_status = (u32) pch_can_get_buffer_status(priv);
-
-	return buffer_status & obj_id;
-}
-
-
 static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
 {
 	int i, j;
@@ -1031,17 +1025,16 @@ static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
 	if (can_dropped_invalid_skb(ndev, skb))
 		return NETDEV_TX_OK;
 
-	if (priv->tx_obj == PCH_TX_OBJ_END) { /* Point tail Obj */
-		while (pch_get_msg_obj_sts(ndev, (((1 << PCH_TX_OBJ_NUM)-1) <<
-					   PCH_RX_OBJ_NUM)))
-			udelay(500);
+	if (priv->tx_obj == PCH_TX_OBJ_END) {
+		if (ioread32(&priv->regs->treq2) & PCH_TREQ2_TX_MASK)
+			netif_stop_queue(ndev);
 
-		priv->tx_obj = PCH_TX_OBJ_START; /* Point head of Tx Obj ID */
-		tx_buffer_avail = priv->tx_obj; /* Point Tail of Tx Obj */
+		tx_buffer_avail = priv->tx_obj;
+		priv->tx_obj = PCH_TX_OBJ_START;
 	} else {
 		tx_buffer_avail = priv->tx_obj;
+		priv->tx_obj++;
 	}
-	priv->tx_obj++;
 
 	/* Reading the Msg Obj from the Msg RAM to the Interface register. */
 	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[1].cmask);

commit 2989042ca86b94bf4ffa9486921bb300ad44225f
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Mon Nov 29 18:19:52 2010 +0000

    can: EG20T PCH: Delete unnecessary spin_lock
    
    Delete unnecessary spin_lock for accessing Message Object.
    Since all message objects are divided into tx/rx area completely,
    spin_lock processing is unnecessary.
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Acked-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 2d4ab0fc9184..a9b6a6525a65 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -71,7 +71,6 @@
 #define PCH_REC			0x00007f00
 #define PCH_TEC			0x000000ff
 
-
 #define PCH_TX_OK		BIT(3)
 #define PCH_RX_OK		BIT(4)
 #define PCH_EPASSIV		BIT(5)
@@ -178,7 +177,6 @@ struct pch_can_priv {
 	unsigned int int_enables;
 	unsigned int int_stat;
 	struct net_device *ndev;
-	spinlock_t msgif_reg_lock; /* Message Interface Registers Access Lock*/
 	unsigned int msg_obj[PCH_TX_OBJ_END];
 	struct pch_can_regs __iomem *regs;
 	struct napi_struct napi;
@@ -309,7 +307,6 @@ static void pch_can_check_if_busy(u32 __iomem *creq_addr, u32 num)
 static void pch_can_set_rxtx(struct pch_can_priv *priv, u32 buff_num,
 			     u32 set, enum pch_ifreg dir)
 {
-	unsigned long flags;
 	u32 ie;
 
 	if (dir)
@@ -317,7 +314,6 @@ static void pch_can_set_rxtx(struct pch_can_priv *priv, u32 buff_num,
 	else
 		ie = PCH_IF_MCONT_RXIE;
 
-	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
 	/* Reading the receive buffer data from RAM to Interface1 registers */
 	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[dir].cmask);
 	pch_can_check_if_busy(&priv->regs->ifregs[dir].creq, buff_num);
@@ -338,10 +334,8 @@ static void pch_can_set_rxtx(struct pch_can_priv *priv, u32 buff_num,
 	}
 
 	pch_can_check_if_busy(&priv->regs->ifregs[dir].creq, buff_num);
-	spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
 }
 
-
 static void pch_can_set_rx_all(struct pch_can_priv *priv, u32 set)
 {
 	int i;
@@ -363,7 +357,6 @@ static void pch_can_set_tx_all(struct pch_can_priv *priv, u32 set)
 static u32 pch_can_get_rxtx_ir(struct pch_can_priv *priv, u32 buff_num,
 			       enum pch_ifreg dir)
 {
-	unsigned long flags;
 	u32 ie, enable;
 
 	if (dir)
@@ -371,7 +364,6 @@ static u32 pch_can_get_rxtx_ir(struct pch_can_priv *priv, u32 buff_num,
 	else
 		ie = PCH_IF_MCONT_TXIE;
 
-	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
 	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[dir].cmask);
 	pch_can_check_if_busy(&priv->regs->ifregs[dir].creq, buff_num);
 
@@ -381,7 +373,6 @@ static u32 pch_can_get_rxtx_ir(struct pch_can_priv *priv, u32 buff_num,
 	} else {
 		enable = 0;
 	}
-	spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
 	return enable;
 }
 
@@ -393,9 +384,6 @@ static int pch_can_int_pending(struct pch_can_priv *priv)
 static void pch_can_set_rx_buffer_link(struct pch_can_priv *priv,
 				       u32 buffer_num, u32 set)
 {
-	unsigned long flags;
-
-	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
 	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[0].cmask);
 	pch_can_check_if_busy(&priv->regs->ifregs[0].creq, buffer_num);
 	iowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL,
@@ -407,15 +395,11 @@ static void pch_can_set_rx_buffer_link(struct pch_can_priv *priv,
 		pch_can_bit_set(&priv->regs->ifregs[0].mcont, PCH_IF_MCONT_EOB);
 
 	pch_can_check_if_busy(&priv->regs->ifregs[0].creq, buffer_num);
-	spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
 }
 
 static void pch_can_get_rx_buffer_link(struct pch_can_priv *priv,
 				       u32 buffer_num, u32 *link)
 {
-	unsigned long flags;
-
-	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
 	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[0].cmask);
 	pch_can_check_if_busy(&priv->regs->ifregs[0].creq, buffer_num);
 
@@ -423,7 +407,6 @@ static void pch_can_get_rx_buffer_link(struct pch_can_priv *priv,
 		*link = PCH_DISABLE;
 	else
 		*link = PCH_ENABLE;
-	spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
 }
 
 static void pch_can_clear_buffers(struct pch_can_priv *priv)
@@ -468,9 +451,6 @@ static void pch_can_clear_buffers(struct pch_can_priv *priv)
 static void pch_can_config_rx_tx_buffers(struct pch_can_priv *priv)
 {
 	int i;
-	unsigned long flags;
-
-	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
 
 	for (i = PCH_RX_OBJ_START; i <= PCH_RX_OBJ_END; i++) {
 		iowrite32(PCH_CMASK_RX_TX_GET,
@@ -529,7 +509,6 @@ static void pch_can_config_rx_tx_buffers(struct pch_can_priv *priv)
 
 		pch_can_check_if_busy(&priv->regs->ifregs[1].creq, i);
 	}
-	spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
 }
 
 static void pch_can_init(struct pch_can_priv *priv)
@@ -845,7 +824,6 @@ static int pch_can_rx_poll(struct napi_struct *napi, int quota)
 	u32 int_stat;
 	int rcv_pkts = 0;
 	u32 reg_stat;
-	unsigned long flags;
 
 	int_stat = pch_can_int_pending(priv);
 	if (!int_stat)
@@ -860,12 +838,10 @@ static int pch_can_rx_poll(struct napi_struct *napi, int quota)
 		}
 
 		if (reg_stat & PCH_TX_OK) {
-			spin_lock_irqsave(&priv->msgif_reg_lock, flags);
 			iowrite32(PCH_CMASK_RX_TX_GET,
 				  &priv->regs->ifregs[1].cmask);
 			pch_can_check_if_busy(&priv->regs->ifregs[1].creq,
 					       ioread32(&priv->regs->intr));
-			spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
 			pch_can_bit_clear(&priv->regs->stat, PCH_TX_OK);
 		}
 
@@ -879,22 +855,18 @@ static int pch_can_rx_poll(struct napi_struct *napi, int quota)
 
 MSG_OBJ:
 	if ((int_stat >= PCH_RX_OBJ_START) && (int_stat <= PCH_RX_OBJ_END)) {
-		spin_lock_irqsave(&priv->msgif_reg_lock, flags);
 		rcv_pkts = pch_can_rx_normal(ndev, int_stat);
-		spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
 		if (rcv_pkts < 0)
 			return 0;
 	} else if ((int_stat >= PCH_TX_OBJ_START) &&
 		   (int_stat <= PCH_TX_OBJ_END)) {
 		/* Handle transmission interrupt */
 		can_get_echo_skb(ndev, int_stat - PCH_RX_OBJ_END - 1);
-		spin_lock_irqsave(&priv->msgif_reg_lock, flags);
 		iowrite32(PCH_CMASK_RX_TX_GET | PCH_CMASK_CLRINTPND,
 			  &priv->regs->ifregs[1].cmask);
 		dlc = ioread32(&priv->regs->ifregs[1].mcont) &
 			       PCH_IF_MCONT_DLC;
 		pch_can_check_if_busy(&priv->regs->ifregs[1].creq, int_stat);
-		spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
 		if (dlc > 8)
 			dlc = 8;
 		stats->tx_bytes += dlc;
@@ -1052,7 +1024,6 @@ static int pch_get_msg_obj_sts(struct net_device *ndev, u32 obj_id)
 static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
 {
 	int i, j;
-	unsigned long flags;
 	struct pch_can_priv *priv = netdev_priv(ndev);
 	struct can_frame *cf = (struct can_frame *)skb->data;
 	int tx_buffer_avail = 0;
@@ -1072,9 +1043,6 @@ static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
 	}
 	priv->tx_obj++;
 
-	/* Attaining the lock. */
-	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
-
 	/* Reading the Msg Obj from the Msg RAM to the Interface register. */
 	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[1].cmask);
 	pch_can_check_if_busy(&priv->regs->ifregs[1].creq, tx_buffer_avail);
@@ -1126,8 +1094,6 @@ static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
 
 	pch_can_check_if_busy(&priv->regs->ifregs[1].creq, tx_buffer_avail);
 
-	spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
-
 	return NETDEV_TX_OK;
 }
 

commit d68f6837c4972b0433e41f8bee4b2b8205610f31
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Mon Nov 29 18:16:15 2010 +0000

    can: EG20T PCH: Enumerate LEC macros
    
    For easy to readable, LEC #define macros are replaced to enums.
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 982ff2d757a8..2d4ab0fc9184 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -71,21 +71,12 @@
 #define PCH_REC			0x00007f00
 #define PCH_TEC			0x000000ff
 
+
 #define PCH_TX_OK		BIT(3)
 #define PCH_RX_OK		BIT(4)
 #define PCH_EPASSIV		BIT(5)
 #define PCH_EWARN		BIT(6)
 #define PCH_BUS_OFF		BIT(7)
-#define PCH_LEC0		BIT(0)
-#define PCH_LEC1		BIT(1)
-#define PCH_LEC2		BIT(2)
-#define PCH_LEC_ALL		(PCH_LEC0 | PCH_LEC1 | PCH_LEC2)
-#define PCH_STUF_ERR		PCH_LEC0
-#define PCH_FORM_ERR		PCH_LEC1
-#define PCH_ACK_ERR		(PCH_LEC0 | PCH_LEC1)
-#define PCH_BIT1_ERR		PCH_LEC2
-#define PCH_BIT0_ERR		(PCH_LEC0 | PCH_LEC2)
-#define PCH_CRC_ERR		(PCH_LEC1 | PCH_LEC2)
 
 /* bit position of certain controller bits. */
 #define PCH_BIT_BRP		0
@@ -117,6 +108,16 @@ enum pch_ifreg {
 	PCH_TX_IFREG,
 };
 
+enum pch_can_err {
+	PCH_STUF_ERR = 1,
+	PCH_FORM_ERR,
+	PCH_ACK_ERR,
+	PCH_BIT1_ERR,
+	PCH_BIT0_ERR,
+	PCH_CRC_ERR,
+	PCH_LEC_ALL,
+};
+
 enum pch_can_mode {
 	PCH_CAN_ENABLE,
 	PCH_CAN_DISABLE,
@@ -620,7 +621,7 @@ static void pch_can_error(struct net_device *ndev, u32 status)
 	struct sk_buff *skb;
 	struct pch_can_priv *priv = netdev_priv(ndev);
 	struct can_frame *cf;
-	u32 errc;
+	u32 errc, lec;
 	struct net_device_stats *stats = &(priv->ndev->stats);
 	enum can_state state = priv->can.state;
 
@@ -665,33 +666,37 @@ static void pch_can_error(struct net_device *ndev, u32 status)
 			"%s -> CAN controller is ERROR PASSIVE .\n", __func__);
 	}
 
-	if (status & PCH_LEC_ALL) {
+	lec = status & PCH_LEC_ALL;
+	switch (lec) {
+	case PCH_STUF_ERR:
+		cf->data[2] |= CAN_ERR_PROT_STUFF;
 		priv->can.can_stats.bus_error++;
 		stats->rx_errors++;
-		switch (status & PCH_LEC_ALL) {
-		case PCH_STUF_ERR:
-			cf->data[2] |= CAN_ERR_PROT_STUFF;
-			break;
-		case PCH_FORM_ERR:
-			cf->data[2] |= CAN_ERR_PROT_FORM;
-			break;
-		case PCH_ACK_ERR:
-			cf->data[2] |= CAN_ERR_PROT_LOC_ACK |
-				       CAN_ERR_PROT_LOC_ACK_DEL;
-			break;
-		case PCH_BIT1_ERR:
-		case PCH_BIT0_ERR:
-			cf->data[2] |= CAN_ERR_PROT_BIT;
-			break;
-		case PCH_CRC_ERR:
-			cf->data[2] |= CAN_ERR_PROT_LOC_CRC_SEQ |
-				       CAN_ERR_PROT_LOC_CRC_DEL;
-			break;
-		default:
-			iowrite32(status | PCH_LEC_ALL, &priv->regs->stat);
-			break;
-		}
-
+		break;
+	case PCH_FORM_ERR:
+		cf->data[2] |= CAN_ERR_PROT_FORM;
+		priv->can.can_stats.bus_error++;
+		stats->rx_errors++;
+		break;
+	case PCH_ACK_ERR:
+		cf->can_id |= CAN_ERR_ACK;
+		priv->can.can_stats.bus_error++;
+		stats->rx_errors++;
+		break;
+	case PCH_BIT1_ERR:
+	case PCH_BIT0_ERR:
+		cf->data[2] |= CAN_ERR_PROT_BIT;
+		priv->can.can_stats.bus_error++;
+		stats->rx_errors++;
+		break;
+	case PCH_CRC_ERR:
+		cf->data[2] |= CAN_ERR_PROT_LOC_CRC_SEQ |
+			       CAN_ERR_PROT_LOC_CRC_DEL;
+		priv->can.can_stats.bus_error++;
+		stats->rx_errors++;
+		break;
+	case PCH_LEC_ALL: /* Written by CPU. No error status */
+		break;
 	}
 
 	priv->can.state = state;

commit 15ffc8fddf72712cc45d51c64bd500760ec63c80
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Mon Nov 29 18:15:02 2010 +0000

    can: EG20T PCH: Change Message Object Index
    
    For easy to readable, add Message Object index like below.
    PCH_RX_OBJ_START
    PCH_RX_OBJ_END
    PCH_TX_OBJ_START
    PCH_TX_OBJ_END
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index dae8ed19630e..982ff2d757a8 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -32,10 +32,6 @@
 #include <linux/can/dev.h>
 #include <linux/can/error.h>
 
-#define PCH_MAX_MSG_OBJ		32
-#define PCH_MSG_OBJ_RX		0 /* The receive message object flag. */
-#define PCH_MSG_OBJ_TX		1 /* The transmit message object flag. */
-
 #define PCH_ENABLE		1 /* The enable flag */
 #define PCH_DISABLE		0 /* The disable flag */
 #define PCH_CTRL_INIT		BIT(0) /* The INIT bit of CANCONT register. */
@@ -107,9 +103,12 @@
 /* Define the number of message object.
  * PCH CAN communications are done via Message RAM.
  * The Message RAM consists of 32 message objects. */
-#define PCH_RX_OBJ_NUM		26  /* 1~ PCH_RX_OBJ_NUM is Rx*/
-#define PCH_TX_OBJ_NUM		6  /* PCH_RX_OBJ_NUM is RX ~ Tx*/
-#define PCH_OBJ_NUM		(PCH_TX_OBJ_NUM + PCH_RX_OBJ_NUM)
+#define PCH_RX_OBJ_NUM		26
+#define PCH_TX_OBJ_NUM		6
+#define PCH_RX_OBJ_START	1
+#define PCH_RX_OBJ_END		PCH_RX_OBJ_NUM
+#define PCH_TX_OBJ_START	(PCH_RX_OBJ_END + 1)
+#define PCH_TX_OBJ_END		(PCH_RX_OBJ_NUM + PCH_TX_OBJ_NUM)
 
 #define PCH_FIFO_THRESH		16
 
@@ -172,14 +171,14 @@ struct pch_can_priv {
 	struct can_priv can;
 	unsigned int can_num;
 	struct pci_dev *dev;
-	unsigned int tx_enable[PCH_MAX_MSG_OBJ];
-	unsigned int rx_enable[PCH_MAX_MSG_OBJ];
-	unsigned int rx_link[PCH_MAX_MSG_OBJ];
+	int tx_enable[PCH_TX_OBJ_END];
+	int rx_enable[PCH_TX_OBJ_END];
+	int rx_link[PCH_TX_OBJ_END];
 	unsigned int int_enables;
 	unsigned int int_stat;
 	struct net_device *ndev;
 	spinlock_t msgif_reg_lock; /* Message Interface Registers Access Lock*/
-	unsigned int msg_obj[PCH_MAX_MSG_OBJ];
+	unsigned int msg_obj[PCH_TX_OBJ_END];
 	struct pch_can_regs __iomem *regs;
 	struct napi_struct napi;
 	unsigned int tx_obj;	/* Point next Tx Obj index */
@@ -347,10 +346,8 @@ static void pch_can_set_rx_all(struct pch_can_priv *priv, u32 set)
 	int i;
 
 	/* Traversing to obtain the object configured as receivers. */
-	for (i = 0; i < PCH_OBJ_NUM; i++) {
-		if (priv->msg_obj[i] == PCH_MSG_OBJ_RX)
-			pch_can_set_rxtx(priv, i + 1, set, PCH_RX_IFREG);
-	}
+	for (i = PCH_RX_OBJ_START; i <= PCH_RX_OBJ_END; i++)
+		pch_can_set_rxtx(priv, i, set, PCH_RX_IFREG);
 }
 
 static void pch_can_set_tx_all(struct pch_can_priv *priv, u32 set)
@@ -358,10 +355,8 @@ static void pch_can_set_tx_all(struct pch_can_priv *priv, u32 set)
 	int i;
 
 	/* Traversing to obtain the object configured as transmit object. */
-	for (i = 0; i < PCH_OBJ_NUM; i++) {
-		if (priv->msg_obj[i] == PCH_MSG_OBJ_TX)
-			pch_can_set_rxtx(priv, i + 1, set, PCH_TX_IFREG);
-	}
+	for (i = PCH_TX_OBJ_START; i <= PCH_TX_OBJ_END; i++)
+		pch_can_set_rxtx(priv, i, set, PCH_TX_IFREG);
 }
 
 static u32 pch_can_get_rxtx_ir(struct pch_can_priv *priv, u32 buff_num,
@@ -381,9 +376,9 @@ static u32 pch_can_get_rxtx_ir(struct pch_can_priv *priv, u32 buff_num,
 
 	if (((ioread32(&priv->regs->ifregs[dir].id2)) & PCH_ID_MSGVAL) &&
 			((ioread32(&priv->regs->ifregs[dir].mcont)) & ie)) {
-		enable = PCH_ENABLE;
+		enable = 1;
 	} else {
-		enable = PCH_DISABLE;
+		enable = 0;
 	}
 	spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
 	return enable;
@@ -434,7 +429,7 @@ static void pch_can_clear_buffers(struct pch_can_priv *priv)
 {
 	int i;
 
-	for (i = 0; i < PCH_RX_OBJ_NUM; i++) {
+	for (i = PCH_RX_OBJ_START; i <= PCH_RX_OBJ_END; i++) {
 		iowrite32(PCH_CMASK_RX_TX_SET, &priv->regs->ifregs[0].cmask);
 		iowrite32(0xffff, &priv->regs->ifregs[0].mask1);
 		iowrite32(0xffff, &priv->regs->ifregs[0].mask2);
@@ -448,10 +443,10 @@ static void pch_can_clear_buffers(struct pch_can_priv *priv)
 		iowrite32(PCH_CMASK_RDWR | PCH_CMASK_MASK |
 			  PCH_CMASK_ARB | PCH_CMASK_CTRL,
 			  &priv->regs->ifregs[0].cmask);
-		pch_can_check_if_busy(&priv->regs->ifregs[0].creq, i+1);
+		pch_can_check_if_busy(&priv->regs->ifregs[0].creq, i);
 	}
 
-	for (i = i;  i < PCH_OBJ_NUM; i++) {
+	for (i = PCH_TX_OBJ_START;  i <= PCH_TX_OBJ_END; i++) {
 		iowrite32(PCH_CMASK_RX_TX_SET, &priv->regs->ifregs[1].cmask);
 		iowrite32(0xffff, &priv->regs->ifregs[1].mask1);
 		iowrite32(0xffff, &priv->regs->ifregs[1].mask2);
@@ -465,7 +460,7 @@ static void pch_can_clear_buffers(struct pch_can_priv *priv)
 		iowrite32(PCH_CMASK_RDWR | PCH_CMASK_MASK |
 			  PCH_CMASK_ARB | PCH_CMASK_CTRL,
 			  &priv->regs->ifregs[1].cmask);
-		pch_can_check_if_busy(&priv->regs->ifregs[1].creq, i+1);
+		pch_can_check_if_busy(&priv->regs->ifregs[1].creq, i);
 	}
 }
 
@@ -476,64 +471,62 @@ static void pch_can_config_rx_tx_buffers(struct pch_can_priv *priv)
 
 	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
 
-	for (i = 0; i < PCH_OBJ_NUM; i++) {
-		if (priv->msg_obj[i] == PCH_MSG_OBJ_RX) {
-			iowrite32(PCH_CMASK_RX_TX_GET,
-				&priv->regs->ifregs[0].cmask);
-			pch_can_check_if_busy(&priv->regs->ifregs[0].creq, i+1);
+	for (i = PCH_RX_OBJ_START; i <= PCH_RX_OBJ_END; i++) {
+		iowrite32(PCH_CMASK_RX_TX_GET,
+			&priv->regs->ifregs[0].cmask);
+		pch_can_check_if_busy(&priv->regs->ifregs[0].creq, i);
 
-			iowrite32(0x0, &priv->regs->ifregs[0].id1);
-			iowrite32(0x0, &priv->regs->ifregs[0].id2);
+		iowrite32(0x0, &priv->regs->ifregs[0].id1);
+		iowrite32(0x0, &priv->regs->ifregs[0].id2);
 
-			pch_can_bit_set(&priv->regs->ifregs[0].mcont,
-					PCH_IF_MCONT_UMASK);
+		pch_can_bit_set(&priv->regs->ifregs[0].mcont,
+				PCH_IF_MCONT_UMASK);
 
-			/* Set FIFO mode set to 0 except last Rx Obj*/
-			pch_can_bit_clear(&priv->regs->ifregs[0].mcont,
+		/* Set FIFO mode set to 0 except last Rx Obj*/
+		pch_can_bit_clear(&priv->regs->ifregs[0].mcont,
+				  PCH_IF_MCONT_EOB);
+		/* In case FIFO mode, Last EoB of Rx Obj must be 1 */
+		if (i == PCH_RX_OBJ_END)
+			pch_can_bit_set(&priv->regs->ifregs[0].mcont,
 					  PCH_IF_MCONT_EOB);
-			/* In case FIFO mode, Last EoB of Rx Obj must be 1 */
-			if (i == (PCH_RX_OBJ_NUM - 1))
-				pch_can_bit_set(&priv->regs->ifregs[0].mcont,
-						  PCH_IF_MCONT_EOB);
-
-			iowrite32(0, &priv->regs->ifregs[0].mask1);
-			pch_can_bit_clear(&priv->regs->ifregs[0].mask2,
-					  0x1fff | PCH_MASK2_MDIR_MXTD);
-
-			/* Setting CMASK for writing */
-			iowrite32(PCH_CMASK_RDWR | PCH_CMASK_MASK |
-				  PCH_CMASK_ARB | PCH_CMASK_CTRL,
-				  &priv->regs->ifregs[0].cmask);
 
-			pch_can_check_if_busy(&priv->regs->ifregs[0].creq, i+1);
-		} else if (priv->msg_obj[i] == PCH_MSG_OBJ_TX) {
-			iowrite32(PCH_CMASK_RX_TX_GET,
-				&priv->regs->ifregs[1].cmask);
-			pch_can_check_if_busy(&priv->regs->ifregs[1].creq, i+1);
+		iowrite32(0, &priv->regs->ifregs[0].mask1);
+		pch_can_bit_clear(&priv->regs->ifregs[0].mask2,
+				  0x1fff | PCH_MASK2_MDIR_MXTD);
 
-			/* Resetting DIR bit for reception */
-			iowrite32(0x0, &priv->regs->ifregs[1].id1);
-			iowrite32(0x0, &priv->regs->ifregs[1].id2);
-			pch_can_bit_set(&priv->regs->ifregs[1].id2,
-					PCH_ID2_DIR);
+		/* Setting CMASK for writing */
+		iowrite32(PCH_CMASK_RDWR | PCH_CMASK_MASK |
+			  PCH_CMASK_ARB | PCH_CMASK_CTRL,
+			  &priv->regs->ifregs[0].cmask);
 
-			/* Setting EOB bit for transmitter */
-			iowrite32(PCH_IF_MCONT_EOB,
-				  &priv->regs->ifregs[1].mcont);
+		pch_can_check_if_busy(&priv->regs->ifregs[0].creq, i);
+	}
 
-			pch_can_bit_set(&priv->regs->ifregs[1].mcont,
-					PCH_IF_MCONT_UMASK);
+	for (i = PCH_TX_OBJ_START; i <= PCH_TX_OBJ_END; i++) {
+		iowrite32(PCH_CMASK_RX_TX_GET,
+			&priv->regs->ifregs[1].cmask);
+		pch_can_check_if_busy(&priv->regs->ifregs[1].creq, i);
 
-			iowrite32(0, &priv->regs->ifregs[1].mask1);
-			pch_can_bit_clear(&priv->regs->ifregs[1].mask2, 0x1fff);
+		/* Resetting DIR bit for reception */
+		iowrite32(0x0, &priv->regs->ifregs[1].id1);
+		iowrite32(0x0, &priv->regs->ifregs[1].id2);
+		pch_can_bit_set(&priv->regs->ifregs[1].id2, PCH_ID2_DIR);
 
-			/* Setting CMASK for writing */
-			iowrite32(PCH_CMASK_RDWR | PCH_CMASK_MASK |
-				  PCH_CMASK_ARB | PCH_CMASK_CTRL,
-				  &priv->regs->ifregs[1].cmask);
+		/* Setting EOB bit for transmitter */
+		iowrite32(PCH_IF_MCONT_EOB, &priv->regs->ifregs[1].mcont);
 
-			pch_can_check_if_busy(&priv->regs->ifregs[1].creq, i+1);
-		}
+		pch_can_bit_set(&priv->regs->ifregs[1].mcont,
+				PCH_IF_MCONT_UMASK);
+
+		iowrite32(0, &priv->regs->ifregs[1].mask1);
+		pch_can_bit_clear(&priv->regs->ifregs[1].mask2, 0x1fff);
+
+		/* Setting CMASK for writing */
+		iowrite32(PCH_CMASK_RDWR | PCH_CMASK_MASK |
+			  PCH_CMASK_ARB | PCH_CMASK_CTRL,
+			  &priv->regs->ifregs[1].cmask);
+
+		pch_can_check_if_busy(&priv->regs->ifregs[1].creq, i);
 	}
 	spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
 }
@@ -577,7 +570,20 @@ static void pch_can_int_clr(struct pch_can_priv *priv, u32 mask)
 	}
 
 	/* Clear interrupt for transmit object */
-	if (priv->msg_obj[mask - 1] == PCH_MSG_OBJ_TX) {
+	if ((mask >= PCH_RX_OBJ_START) && (mask <= PCH_RX_OBJ_END)) {
+		/* Setting CMASK for clearing the reception interrupts. */
+		iowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL | PCH_CMASK_ARB,
+			  &priv->regs->ifregs[0].cmask);
+
+		/* Clearing the Dir bit. */
+		pch_can_bit_clear(&priv->regs->ifregs[0].id2, PCH_ID2_DIR);
+
+		/* Clearing NewDat & IntPnd */
+		pch_can_bit_clear(&priv->regs->ifregs[0].mcont,
+				  PCH_IF_MCONT_NEWDAT | PCH_IF_MCONT_INTPND);
+
+		pch_can_check_if_busy(&priv->regs->ifregs[0].creq, mask);
+	} else if ((mask >= PCH_TX_OBJ_START) && (mask <= PCH_TX_OBJ_END)) {
 		/* Setting CMASK for clearing interrupts for
 					 frame transmission. */
 		iowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL | PCH_CMASK_ARB,
@@ -593,19 +599,6 @@ static void pch_can_int_clr(struct pch_can_priv *priv, u32 mask)
 				  PCH_IF_MCONT_NEWDAT | PCH_IF_MCONT_INTPND |
 				  PCH_IF_MCONT_TXRQXT);
 		pch_can_check_if_busy(&priv->regs->ifregs[1].creq, mask);
-	} else if (priv->msg_obj[mask - 1] == PCH_MSG_OBJ_RX) {
-		/* Setting CMASK for clearing the reception interrupts. */
-		iowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL | PCH_CMASK_ARB,
-			  &priv->regs->ifregs[0].cmask);
-
-		/* Clearing the Dir bit. */
-		pch_can_bit_clear(&priv->regs->ifregs[0].id2, PCH_ID2_DIR);
-
-		/* Clearing NewDat & IntPnd */
-		pch_can_bit_clear(&priv->regs->ifregs[0].mcont,
-				  PCH_IF_MCONT_NEWDAT | PCH_IF_MCONT_INTPND);
-
-		pch_can_check_if_busy(&priv->regs->ifregs[0].creq, mask);
 	}
 }
 
@@ -793,8 +786,8 @@ static int pch_can_rx_normal(struct net_device *ndev, u32 int_stat)
 			cf->can_dlc = 0;
 			cf->can_id |= CAN_RTR_FLAG;
 		} else {
-			cf->can_dlc = ((ioread32(&priv->regs->ifregs[0].mcont))
-						 & 0x0f);
+			cf->can_dlc =
+			      ((ioread32(&priv->regs->ifregs[0].mcont)) & 0x0f);
 		}
 
 		for (i = 0, j = 0; i < cf->can_dlc; j++) {
@@ -832,7 +825,7 @@ static int pch_can_rx_normal(struct net_device *ndev, u32 int_stat)
 RX_NEXT:
 		/* Reading the messsage object from the Message RAM */
 		iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[0].cmask);
-		pch_can_check_if_busy(&priv->regs->ifregs[0].creq, k + 1);
+		pch_can_check_if_busy(&priv->regs->ifregs[0].creq, k);
 		reg = ioread32(&priv->regs->ifregs[0].mcont);
 	}
 
@@ -880,29 +873,27 @@ static int pch_can_rx_poll(struct napi_struct *napi, int quota)
 	}
 
 MSG_OBJ:
-	if ((int_stat >= 1) && (int_stat <= PCH_RX_OBJ_NUM)) {
+	if ((int_stat >= PCH_RX_OBJ_START) && (int_stat <= PCH_RX_OBJ_END)) {
 		spin_lock_irqsave(&priv->msgif_reg_lock, flags);
 		rcv_pkts = pch_can_rx_normal(ndev, int_stat);
 		spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
 		if (rcv_pkts < 0)
 			return 0;
-	} else if ((int_stat > PCH_RX_OBJ_NUM) && (int_stat <= PCH_OBJ_NUM)) {
-		if (priv->msg_obj[int_stat - 1] == PCH_MSG_OBJ_TX) {
-			/* Handle transmission interrupt */
-			can_get_echo_skb(ndev, int_stat - PCH_RX_OBJ_NUM - 1);
-			spin_lock_irqsave(&priv->msgif_reg_lock, flags);
-			iowrite32(PCH_CMASK_RX_TX_GET | PCH_CMASK_CLRINTPND,
-				  &priv->regs->ifregs[1].cmask);
-			dlc = ioread32(&priv->regs->ifregs[1].mcont) &
-				       PCH_IF_MCONT_DLC;
-			pch_can_check_if_busy(&priv->regs->ifregs[1].creq,
-					      int_stat);
-			spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
-			if (dlc > 8)
-				dlc = 8;
-			stats->tx_bytes += dlc;
-			stats->tx_packets++;
-		}
+	} else if ((int_stat >= PCH_TX_OBJ_START) &&
+		   (int_stat <= PCH_TX_OBJ_END)) {
+		/* Handle transmission interrupt */
+		can_get_echo_skb(ndev, int_stat - PCH_RX_OBJ_END - 1);
+		spin_lock_irqsave(&priv->msgif_reg_lock, flags);
+		iowrite32(PCH_CMASK_RX_TX_GET | PCH_CMASK_CLRINTPND,
+			  &priv->regs->ifregs[1].cmask);
+		dlc = ioread32(&priv->regs->ifregs[1].mcont) &
+			       PCH_IF_MCONT_DLC;
+		pch_can_check_if_busy(&priv->regs->ifregs[1].creq, int_stat);
+		spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
+		if (dlc > 8)
+			dlc = 8;
+		stats->tx_bytes += dlc;
+		stats->tx_packets++;
 	}
 
 	int_stat = pch_can_int_pending(priv);
@@ -1064,12 +1055,12 @@ static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
 	if (can_dropped_invalid_skb(ndev, skb))
 		return NETDEV_TX_OK;
 
-	if (priv->tx_obj == (PCH_OBJ_NUM + 1)) { /* Point tail Obj */
+	if (priv->tx_obj == PCH_TX_OBJ_END) { /* Point tail Obj */
 		while (pch_get_msg_obj_sts(ndev, (((1 << PCH_TX_OBJ_NUM)-1) <<
 					   PCH_RX_OBJ_NUM)))
 			udelay(500);
 
-		priv->tx_obj = PCH_RX_OBJ_NUM + 1; /* Point head of Tx Obj ID */
+		priv->tx_obj = PCH_TX_OBJ_START; /* Point head of Tx Obj ID */
 		tx_buffer_avail = priv->tx_obj; /* Point Tail of Tx Obj */
 	} else {
 		tx_buffer_avail = priv->tx_obj;
@@ -1113,7 +1104,7 @@ static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
 			 (&priv->regs->ifregs[1].dataa1) + j*4);
 	}
 
-	can_put_echo_skb(skb, ndev, tx_buffer_avail - PCH_RX_OBJ_NUM - 1);
+	can_put_echo_skb(skb, ndev, tx_buffer_avail - PCH_RX_OBJ_END - 1);
 
 	/* Updating the size of the data. */
 	pch_can_bit_clear(&priv->regs->ifregs[1].mcont, 0x0f);
@@ -1188,23 +1179,16 @@ static int pch_can_suspend(struct pci_dev *pdev, pm_message_t state)
 	pch_can_set_int_enables(priv, PCH_CAN_DISABLE);
 
 	/* Save Tx buffer enable state */
-	for (i = 0; i < PCH_OBJ_NUM; i++) {
-		if (priv->msg_obj[i] == PCH_MSG_OBJ_TX)
-			priv->tx_enable[i] = pch_can_get_rxtx_ir(priv, i + 1,
-								 PCH_TX_IFREG);
-	}
+	for (i = PCH_TX_OBJ_START; i <= PCH_TX_OBJ_END; i++)
+		priv->tx_enable[i] = pch_can_get_rxtx_ir(priv, i, PCH_TX_IFREG);
 
 	/* Disable all Transmit buffers */
 	pch_can_set_tx_all(priv, 0);
 
 	/* Save Rx buffer enable state */
-	for (i = 0; i < PCH_OBJ_NUM; i++) {
-		if (priv->msg_obj[i] == PCH_MSG_OBJ_RX) {
-			priv->rx_enable[i] = pch_can_get_rxtx_ir(priv, i + 1,
-						PCH_RX_IFREG);
-			pch_can_get_rx_buffer_link(priv, i + 1,
-						&(priv->rx_link[i]));
-		}
+	for (i = PCH_RX_OBJ_START; i <= PCH_RX_OBJ_END; i++) {
+		priv->rx_enable[i] = pch_can_get_rxtx_ir(priv, i, PCH_RX_IFREG);
+		pch_can_get_rx_buffer_link(priv, i, &priv->rx_link[i]);
 	}
 
 	/* Disable all Receive buffers */
@@ -1256,24 +1240,16 @@ static int pch_can_resume(struct pci_dev *pdev)
 	pch_can_set_optmode(priv);
 
 	/* Enabling the transmit buffer. */
-	for (i = 0; i < PCH_OBJ_NUM; i++) {
-		if (priv->msg_obj[i] == PCH_MSG_OBJ_TX)
-			pch_can_set_rxtx(priv, i, priv->tx_enable[i],
-					 PCH_TX_IFREG);
-	}
+	for (i = PCH_TX_OBJ_START; i <= PCH_TX_OBJ_END; i++)
+		pch_can_set_rxtx(priv, i, priv->tx_enable[i], PCH_TX_IFREG);
 
 	/* Configuring the receive buffer and enabling them. */
-	for (i = 0; i < PCH_OBJ_NUM; i++) {
-		if (priv->msg_obj[i] == PCH_MSG_OBJ_RX) {
-			/* Restore buffer link */
-			pch_can_set_rx_buffer_link(priv, i + 1,
-						   priv->rx_link[i]);
+	for (i = PCH_RX_OBJ_START; i <= PCH_RX_OBJ_END; i++) {
+		/* Restore buffer link */
+		pch_can_set_rx_buffer_link(priv, i, priv->rx_link[i]);
 
-			/* Restore buffer enables */
-			pch_can_set_rxtx(priv, i, priv->rx_enable[i],
-					 PCH_RX_IFREG);
-
-		}
+		/* Restore buffer enables */
+		pch_can_set_rxtx(priv, i, priv->rx_enable[i], PCH_RX_IFREG);
 	}
 
 	/* Enable CAN Interrupts */
@@ -1306,7 +1282,6 @@ static int __devinit pch_can_probe(struct pci_dev *pdev,
 	struct net_device *ndev;
 	struct pch_can_priv *priv;
 	int rc;
-	int index;
 	void __iomem *addr;
 
 	rc = pci_enable_device(pdev);
@@ -1328,7 +1303,7 @@ static int __devinit pch_can_probe(struct pci_dev *pdev,
 		goto probe_exit_ipmap;
 	}
 
-	ndev = alloc_candev(sizeof(struct pch_can_priv), PCH_TX_OBJ_NUM);
+	ndev = alloc_candev(sizeof(struct pch_can_priv), PCH_TX_OBJ_END);
 	if (!ndev) {
 		rc = -ENOMEM;
 		dev_err(&pdev->dev, "Failed alloc_candev\n");
@@ -1344,7 +1319,7 @@ static int __devinit pch_can_probe(struct pci_dev *pdev,
 	priv->can.do_get_berr_counter = pch_can_get_berr_counter;
 	priv->can.ctrlmode_supported = CAN_CTRLMODE_LISTENONLY |
 				       CAN_CTRLMODE_LOOPBACK;
-	priv->tx_obj = PCH_RX_OBJ_NUM + 1; /* Point head of Tx Obj */
+	priv->tx_obj = PCH_TX_OBJ_START; /* Point head of Tx Obj */
 
 	ndev->irq = pdev->irq;
 	ndev->flags |= IFF_ECHO;
@@ -1352,15 +1327,9 @@ static int __devinit pch_can_probe(struct pci_dev *pdev,
 	pci_set_drvdata(pdev, ndev);
 	SET_NETDEV_DEV(ndev, &pdev->dev);
 	ndev->netdev_ops = &pch_can_netdev_ops;
-
 	priv->can.clock.freq = PCH_CAN_CLK; /* Hz */
-	for (index = 0; index < PCH_RX_OBJ_NUM;)
-		priv->msg_obj[index++] = PCH_MSG_OBJ_RX;
-
-	for (index = index;  index < PCH_OBJ_NUM;)
-		priv->msg_obj[index++] = PCH_MSG_OBJ_TX;
 
-	netif_napi_add(ndev, &priv->napi, pch_can_rx_poll, PCH_RX_OBJ_NUM);
+	netif_napi_add(ndev, &priv->napi, pch_can_rx_poll, PCH_RX_OBJ_END);
 
 	rc = register_candev(ndev);
 	if (rc) {

commit 8339a7ed562719e040ca783bf59fa2d614d10ac9
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Mon Nov 29 18:11:52 2010 +0000

    can: EG20T PCH: Separate Interface Register(IF1/IF2)
    
    CAN register of Intel PCH EG20T has 2 sets of interface register.
    To reduce whole of code size, separate interface register.
    As a result, the number of function also can be reduced.
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Acked-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 238622a04bc1..dae8ed19630e 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -113,6 +113,11 @@
 
 #define PCH_FIFO_THRESH		16
 
+enum pch_ifreg {
+	PCH_RX_IFREG,
+	PCH_TX_IFREG,
+};
+
 enum pch_can_mode {
 	PCH_CAN_ENABLE,
 	PCH_CAN_DISABLE,
@@ -122,6 +127,21 @@ enum pch_can_mode {
 	PCH_CAN_RUN
 };
 
+struct pch_can_if_regs {
+	u32 creq;
+	u32 cmask;
+	u32 mask1;
+	u32 mask2;
+	u32 id1;
+	u32 id2;
+	u32 mcont;
+	u32 dataa1;
+	u32 dataa2;
+	u32 datab1;
+	u32 datab2;
+	u32 rsv[13];
+};
+
 struct pch_can_regs {
 	u32 cont;
 	u32 stat;
@@ -130,38 +150,21 @@ struct pch_can_regs {
 	u32 intr;
 	u32 opt;
 	u32 brpe;
-	u32 reserve1;
-	u32 if1_creq;
-	u32 if1_cmask;
-	u32 if1_mask1;
-	u32 if1_mask2;
-	u32 if1_id1;
-	u32 if1_id2;
-	u32 if1_mcont;
-	u32 if1_dataa1;
-	u32 if1_dataa2;
-	u32 if1_datab1;
-	u32 if1_datab2;
-	u32 reserve2;
-	u32 reserve3[12];
-	u32 if2_creq;
-	u32 if2_cmask;
-	u32 if2_mask1;
-	u32 if2_mask2;
-	u32 if2_id1;
-	u32 if2_id2;
-	u32 if2_mcont;
-	u32 if2_dataa1;
-	u32 if2_dataa2;
-	u32 if2_datab1;
-	u32 if2_datab2;
-	u32 reserve4;
-	u32 reserve5[20];
+	u32 reserve;
+	struct pch_can_if_regs ifregs[2]; /* [0]=if1  [1]=if2 */
+	u32 reserve1[8];
 	u32 treq1;
 	u32 treq2;
-	u32 reserve6[2];
-	u32 reserve7[56];
-	u32 reserve8[3];
+	u32 reserve2[6];
+	u32 data1;
+	u32 data2;
+	u32 reserve3[6];
+	u32 canipend1;
+	u32 canipend2;
+	u32 reserve4[6];
+	u32 canmval1;
+	u32 canmval2;
+	u32 reserve5[37];
 	u32 srst;
 };
 
@@ -303,143 +306,87 @@ static void pch_can_check_if_busy(u32 __iomem *creq_addr, u32 num)
 		pr_err("%s:IF1 BUSY Flag is set forever.\n", __func__);
 }
 
-static void pch_can_set_rx_enable(struct pch_can_priv *priv, u32 buff_num,
-				  u32 set)
+static void pch_can_set_rxtx(struct pch_can_priv *priv, u32 buff_num,
+			     u32 set, enum pch_ifreg dir)
 {
 	unsigned long flags;
+	u32 ie;
+
+	if (dir)
+		ie = PCH_IF_MCONT_TXIE;
+	else
+		ie = PCH_IF_MCONT_RXIE;
 
 	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
 	/* Reading the receive buffer data from RAM to Interface1 registers */
-	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->if1_cmask);
-	pch_can_check_if_busy(&priv->regs->if1_creq, buff_num);
+	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[dir].cmask);
+	pch_can_check_if_busy(&priv->regs->ifregs[dir].creq, buff_num);
 
 	/* Setting the IF1MASK1 register to access MsgVal and RxIE bits */
 	iowrite32(PCH_CMASK_RDWR | PCH_CMASK_ARB | PCH_CMASK_CTRL,
-		  &priv->regs->if1_cmask);
+		  &priv->regs->ifregs[dir].cmask);
 
 	if (set == PCH_ENABLE) {
 		/* Setting the MsgVal and RxIE bits */
-		pch_can_bit_set(&priv->regs->if1_mcont, PCH_IF_MCONT_RXIE);
-		pch_can_bit_set(&priv->regs->if1_id2, PCH_ID_MSGVAL);
+		pch_can_bit_set(&priv->regs->ifregs[dir].mcont, ie);
+		pch_can_bit_set(&priv->regs->ifregs[dir].id2, PCH_ID_MSGVAL);
 
 	} else if (set == PCH_DISABLE) {
 		/* Resetting the MsgVal and RxIE bits */
-		pch_can_bit_clear(&priv->regs->if1_mcont, PCH_IF_MCONT_RXIE);
-		pch_can_bit_clear(&priv->regs->if1_id2, PCH_ID_MSGVAL);
+		pch_can_bit_clear(&priv->regs->ifregs[dir].mcont, ie);
+		pch_can_bit_clear(&priv->regs->ifregs[dir].id2, PCH_ID_MSGVAL);
 	}
 
-	pch_can_check_if_busy(&priv->regs->if1_creq, buff_num);
+	pch_can_check_if_busy(&priv->regs->ifregs[dir].creq, buff_num);
 	spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
 }
 
-static void pch_can_rx_enable_all(struct pch_can_priv *priv)
-{
-	int i;
-
-	/* Traversing to obtain the object configured as receivers. */
-	for (i = 0; i < PCH_OBJ_NUM; i++) {
-		if (priv->msg_obj[i] == PCH_MSG_OBJ_RX)
-			pch_can_set_rx_enable(priv, i + 1, PCH_ENABLE);
-	}
-}
 
-static void pch_can_rx_disable_all(struct pch_can_priv *priv)
+static void pch_can_set_rx_all(struct pch_can_priv *priv, u32 set)
 {
 	int i;
 
 	/* Traversing to obtain the object configured as receivers. */
 	for (i = 0; i < PCH_OBJ_NUM; i++) {
 		if (priv->msg_obj[i] == PCH_MSG_OBJ_RX)
-			pch_can_set_rx_enable(priv, i + 1, PCH_DISABLE);
-	}
-}
-
-static void pch_can_set_tx_enable(struct pch_can_priv *priv, u32 buff_num,
-				 u32 set)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
-	/* Reading the Msg buffer from Message RAM to Interface2 registers. */
-	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->if2_cmask);
-	pch_can_check_if_busy(&priv->regs->if2_creq, buff_num);
-
-	/* Setting the IF2CMASK register for accessing the
-		MsgVal and TxIE bits */
-	iowrite32(PCH_CMASK_RDWR | PCH_CMASK_ARB | PCH_CMASK_CTRL,
-		 &priv->regs->if2_cmask);
-
-	if (set == PCH_ENABLE) {
-		/* Setting the MsgVal and TxIE bits */
-		pch_can_bit_set(&priv->regs->if2_mcont, PCH_IF_MCONT_TXIE);
-		pch_can_bit_set(&priv->regs->if2_id2, PCH_ID_MSGVAL);
-	} else if (set == PCH_DISABLE) {
-		/* Resetting the MsgVal and TxIE bits. */
-		pch_can_bit_clear(&priv->regs->if2_mcont, PCH_IF_MCONT_TXIE);
-		pch_can_bit_clear(&priv->regs->if2_id2, PCH_ID_MSGVAL);
-	}
-
-	pch_can_check_if_busy(&priv->regs->if2_creq, buff_num);
-	spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
-}
-
-static void pch_can_tx_enable_all(struct pch_can_priv *priv)
-{
-	int i;
-
-	/* Traversing to obtain the object configured as transmit object. */
-	for (i = 0; i < PCH_OBJ_NUM; i++) {
-		if (priv->msg_obj[i] == PCH_MSG_OBJ_TX)
-			pch_can_set_tx_enable(priv, i + 1, PCH_ENABLE);
+			pch_can_set_rxtx(priv, i + 1, set, PCH_RX_IFREG);
 	}
 }
 
-static void pch_can_tx_disable_all(struct pch_can_priv *priv)
+static void pch_can_set_tx_all(struct pch_can_priv *priv, u32 set)
 {
 	int i;
 
 	/* Traversing to obtain the object configured as transmit object. */
 	for (i = 0; i < PCH_OBJ_NUM; i++) {
 		if (priv->msg_obj[i] == PCH_MSG_OBJ_TX)
-			pch_can_set_tx_enable(priv, i + 1, PCH_DISABLE);
+			pch_can_set_rxtx(priv, i + 1, set, PCH_TX_IFREG);
 	}
 }
 
-static void pch_can_get_rx_enable(struct pch_can_priv *priv, u32 buff_num,
-				 u32 *enable)
+static u32 pch_can_get_rxtx_ir(struct pch_can_priv *priv, u32 buff_num,
+			       enum pch_ifreg dir)
 {
 	unsigned long flags;
+	u32 ie, enable;
 
-	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
-	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->if1_cmask);
-	pch_can_check_if_busy(&priv->regs->if1_creq, buff_num);
-
-	if (((ioread32(&priv->regs->if1_id2)) & PCH_ID_MSGVAL) &&
-			((ioread32(&priv->regs->if1_mcont)) &
-			PCH_IF_MCONT_RXIE))
-		*enable = PCH_ENABLE;
+	if (dir)
+		ie = PCH_IF_MCONT_RXIE;
 	else
-		*enable = PCH_DISABLE;
-	spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
-}
-
-static void pch_can_get_tx_enable(struct pch_can_priv *priv, u32 buff_num,
-				 u32 *enable)
-{
-	unsigned long flags;
+		ie = PCH_IF_MCONT_TXIE;
 
 	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
-	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->if2_cmask);
-	pch_can_check_if_busy(&priv->regs->if2_creq, buff_num);
+	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[dir].cmask);
+	pch_can_check_if_busy(&priv->regs->ifregs[dir].creq, buff_num);
 
-	if (((ioread32(&priv->regs->if2_id2)) & PCH_ID_MSGVAL) &&
-			((ioread32(&priv->regs->if2_mcont)) &
-			PCH_IF_MCONT_TXIE)) {
-		*enable = PCH_ENABLE;
+	if (((ioread32(&priv->regs->ifregs[dir].id2)) & PCH_ID_MSGVAL) &&
+			((ioread32(&priv->regs->ifregs[dir].mcont)) & ie)) {
+		enable = PCH_ENABLE;
 	} else {
-		*enable = PCH_DISABLE;
+		enable = PCH_DISABLE;
 	}
 	spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
+	return enable;
 }
 
 static int pch_can_int_pending(struct pch_can_priv *priv)
@@ -453,15 +400,17 @@ static void pch_can_set_rx_buffer_link(struct pch_can_priv *priv,
 	unsigned long flags;
 
 	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
-	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->if1_cmask);
-	pch_can_check_if_busy(&priv->regs->if1_creq, buffer_num);
-	iowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL, &priv->regs->if1_cmask);
+	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[0].cmask);
+	pch_can_check_if_busy(&priv->regs->ifregs[0].creq, buffer_num);
+	iowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL,
+		  &priv->regs->ifregs[0].cmask);
 	if (set == PCH_ENABLE)
-		pch_can_bit_clear(&priv->regs->if1_mcont, PCH_IF_MCONT_EOB);
+		pch_can_bit_clear(&priv->regs->ifregs[0].mcont,
+				  PCH_IF_MCONT_EOB);
 	else
-		pch_can_bit_set(&priv->regs->if1_mcont, PCH_IF_MCONT_EOB);
+		pch_can_bit_set(&priv->regs->ifregs[0].mcont, PCH_IF_MCONT_EOB);
 
-	pch_can_check_if_busy(&priv->regs->if1_creq, buffer_num);
+	pch_can_check_if_busy(&priv->regs->ifregs[0].creq, buffer_num);
 	spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
 }
 
@@ -471,10 +420,10 @@ static void pch_can_get_rx_buffer_link(struct pch_can_priv *priv,
 	unsigned long flags;
 
 	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
-	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->if1_cmask);
-	pch_can_check_if_busy(&priv->regs->if1_creq, buffer_num);
+	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[0].cmask);
+	pch_can_check_if_busy(&priv->regs->ifregs[0].creq, buffer_num);
 
-	if (ioread32(&priv->regs->if1_mcont) & PCH_IF_MCONT_EOB)
+	if (ioread32(&priv->regs->ifregs[0].mcont) & PCH_IF_MCONT_EOB)
 		*link = PCH_DISABLE;
 	else
 		*link = PCH_ENABLE;
@@ -486,37 +435,37 @@ static void pch_can_clear_buffers(struct pch_can_priv *priv)
 	int i;
 
 	for (i = 0; i < PCH_RX_OBJ_NUM; i++) {
-		iowrite32(PCH_CMASK_RX_TX_SET, &priv->regs->if1_cmask);
-		iowrite32(0xffff, &priv->regs->if1_mask1);
-		iowrite32(0xffff, &priv->regs->if1_mask2);
-		iowrite32(0x0, &priv->regs->if1_id1);
-		iowrite32(0x0, &priv->regs->if1_id2);
-		iowrite32(0x0, &priv->regs->if1_mcont);
-		iowrite32(0x0, &priv->regs->if1_dataa1);
-		iowrite32(0x0, &priv->regs->if1_dataa2);
-		iowrite32(0x0, &priv->regs->if1_datab1);
-		iowrite32(0x0, &priv->regs->if1_datab2);
+		iowrite32(PCH_CMASK_RX_TX_SET, &priv->regs->ifregs[0].cmask);
+		iowrite32(0xffff, &priv->regs->ifregs[0].mask1);
+		iowrite32(0xffff, &priv->regs->ifregs[0].mask2);
+		iowrite32(0x0, &priv->regs->ifregs[0].id1);
+		iowrite32(0x0, &priv->regs->ifregs[0].id2);
+		iowrite32(0x0, &priv->regs->ifregs[0].mcont);
+		iowrite32(0x0, &priv->regs->ifregs[0].dataa1);
+		iowrite32(0x0, &priv->regs->ifregs[0].dataa2);
+		iowrite32(0x0, &priv->regs->ifregs[0].datab1);
+		iowrite32(0x0, &priv->regs->ifregs[0].datab2);
 		iowrite32(PCH_CMASK_RDWR | PCH_CMASK_MASK |
 			  PCH_CMASK_ARB | PCH_CMASK_CTRL,
-			  &priv->regs->if1_cmask);
-		pch_can_check_if_busy(&priv->regs->if1_creq, i+1);
+			  &priv->regs->ifregs[0].cmask);
+		pch_can_check_if_busy(&priv->regs->ifregs[0].creq, i+1);
 	}
 
 	for (i = i;  i < PCH_OBJ_NUM; i++) {
-		iowrite32(PCH_CMASK_RX_TX_SET, &priv->regs->if2_cmask);
-		iowrite32(0xffff, &priv->regs->if2_mask1);
-		iowrite32(0xffff, &priv->regs->if2_mask2);
-		iowrite32(0x0, &priv->regs->if2_id1);
-		iowrite32(0x0, &priv->regs->if2_id2);
-		iowrite32(0x0, &priv->regs->if2_mcont);
-		iowrite32(0x0, &priv->regs->if2_dataa1);
-		iowrite32(0x0, &priv->regs->if2_dataa2);
-		iowrite32(0x0, &priv->regs->if2_datab1);
-		iowrite32(0x0, &priv->regs->if2_datab2);
+		iowrite32(PCH_CMASK_RX_TX_SET, &priv->regs->ifregs[1].cmask);
+		iowrite32(0xffff, &priv->regs->ifregs[1].mask1);
+		iowrite32(0xffff, &priv->regs->ifregs[1].mask2);
+		iowrite32(0x0, &priv->regs->ifregs[1].id1);
+		iowrite32(0x0, &priv->regs->ifregs[1].id2);
+		iowrite32(0x0, &priv->regs->ifregs[1].mcont);
+		iowrite32(0x0, &priv->regs->ifregs[1].dataa1);
+		iowrite32(0x0, &priv->regs->ifregs[1].dataa2);
+		iowrite32(0x0, &priv->regs->ifregs[1].datab1);
+		iowrite32(0x0, &priv->regs->ifregs[1].datab2);
 		iowrite32(PCH_CMASK_RDWR | PCH_CMASK_MASK |
 			  PCH_CMASK_ARB | PCH_CMASK_CTRL,
-			  &priv->regs->if2_cmask);
-		pch_can_check_if_busy(&priv->regs->if2_creq, i+1);
+			  &priv->regs->ifregs[1].cmask);
+		pch_can_check_if_busy(&priv->regs->ifregs[1].creq, i+1);
 	}
 }
 
@@ -530,58 +479,60 @@ static void pch_can_config_rx_tx_buffers(struct pch_can_priv *priv)
 	for (i = 0; i < PCH_OBJ_NUM; i++) {
 		if (priv->msg_obj[i] == PCH_MSG_OBJ_RX) {
 			iowrite32(PCH_CMASK_RX_TX_GET,
-				&priv->regs->if1_cmask);
-			pch_can_check_if_busy(&priv->regs->if1_creq, i+1);
+				&priv->regs->ifregs[0].cmask);
+			pch_can_check_if_busy(&priv->regs->ifregs[0].creq, i+1);
 
-			iowrite32(0x0, &priv->regs->if1_id1);
-			iowrite32(0x0, &priv->regs->if1_id2);
+			iowrite32(0x0, &priv->regs->ifregs[0].id1);
+			iowrite32(0x0, &priv->regs->ifregs[0].id2);
 
-			pch_can_bit_set(&priv->regs->if1_mcont,
+			pch_can_bit_set(&priv->regs->ifregs[0].mcont,
 					PCH_IF_MCONT_UMASK);
 
 			/* Set FIFO mode set to 0 except last Rx Obj*/
-			pch_can_bit_clear(&priv->regs->if1_mcont,
+			pch_can_bit_clear(&priv->regs->ifregs[0].mcont,
 					  PCH_IF_MCONT_EOB);
 			/* In case FIFO mode, Last EoB of Rx Obj must be 1 */
 			if (i == (PCH_RX_OBJ_NUM - 1))
-				pch_can_bit_set(&priv->regs->if1_mcont,
+				pch_can_bit_set(&priv->regs->ifregs[0].mcont,
 						  PCH_IF_MCONT_EOB);
 
-			iowrite32(0, &priv->regs->if1_mask1);
-			pch_can_bit_clear(&priv->regs->if1_mask2,
+			iowrite32(0, &priv->regs->ifregs[0].mask1);
+			pch_can_bit_clear(&priv->regs->ifregs[0].mask2,
 					  0x1fff | PCH_MASK2_MDIR_MXTD);
 
 			/* Setting CMASK for writing */
 			iowrite32(PCH_CMASK_RDWR | PCH_CMASK_MASK |
 				  PCH_CMASK_ARB | PCH_CMASK_CTRL,
-				  &priv->regs->if1_cmask);
+				  &priv->regs->ifregs[0].cmask);
 
-			pch_can_check_if_busy(&priv->regs->if1_creq, i+1);
+			pch_can_check_if_busy(&priv->regs->ifregs[0].creq, i+1);
 		} else if (priv->msg_obj[i] == PCH_MSG_OBJ_TX) {
 			iowrite32(PCH_CMASK_RX_TX_GET,
-				&priv->regs->if2_cmask);
-			pch_can_check_if_busy(&priv->regs->if2_creq, i+1);
+				&priv->regs->ifregs[1].cmask);
+			pch_can_check_if_busy(&priv->regs->ifregs[1].creq, i+1);
 
 			/* Resetting DIR bit for reception */
-			iowrite32(0x0, &priv->regs->if2_id1);
-			iowrite32(0x0, &priv->regs->if2_id2);
-			pch_can_bit_set(&priv->regs->if2_id2, PCH_ID2_DIR);
+			iowrite32(0x0, &priv->regs->ifregs[1].id1);
+			iowrite32(0x0, &priv->regs->ifregs[1].id2);
+			pch_can_bit_set(&priv->regs->ifregs[1].id2,
+					PCH_ID2_DIR);
 
 			/* Setting EOB bit for transmitter */
-			iowrite32(PCH_IF_MCONT_EOB, &priv->regs->if2_mcont);
+			iowrite32(PCH_IF_MCONT_EOB,
+				  &priv->regs->ifregs[1].mcont);
 
-			pch_can_bit_set(&priv->regs->if2_mcont,
+			pch_can_bit_set(&priv->regs->ifregs[1].mcont,
 					PCH_IF_MCONT_UMASK);
 
-			iowrite32(0, &priv->regs->if2_mask1);
-			pch_can_bit_clear(&priv->regs->if2_mask2, 0x1fff);
+			iowrite32(0, &priv->regs->ifregs[1].mask1);
+			pch_can_bit_clear(&priv->regs->ifregs[1].mask2, 0x1fff);
 
 			/* Setting CMASK for writing */
 			iowrite32(PCH_CMASK_RDWR | PCH_CMASK_MASK |
 				  PCH_CMASK_ARB | PCH_CMASK_CTRL,
-				  &priv->regs->if2_cmask);
+				  &priv->regs->ifregs[1].cmask);
 
-			pch_can_check_if_busy(&priv->regs->if2_creq, i+1);
+			pch_can_check_if_busy(&priv->regs->ifregs[1].creq, i+1);
 		}
 	}
 	spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
@@ -611,10 +562,10 @@ static void pch_can_release(struct pch_can_priv *priv)
 	pch_can_set_int_enables(priv, PCH_CAN_NONE);
 
 	/* Disabling all the receive object. */
-	pch_can_rx_disable_all(priv);
+	pch_can_set_rx_all(priv, 0);
 
 	/* Disabling all the transmit object. */
-	pch_can_tx_disable_all(priv);
+	pch_can_set_tx_all(priv, 0);
 }
 
 /* This function clears interrupt(s) from the CAN device. */
@@ -630,31 +581,31 @@ static void pch_can_int_clr(struct pch_can_priv *priv, u32 mask)
 		/* Setting CMASK for clearing interrupts for
 					 frame transmission. */
 		iowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL | PCH_CMASK_ARB,
-			  &priv->regs->if2_cmask);
+			  &priv->regs->ifregs[1].cmask);
 
 		/* Resetting the ID registers. */
-		pch_can_bit_set(&priv->regs->if2_id2,
+		pch_can_bit_set(&priv->regs->ifregs[1].id2,
 			       PCH_ID2_DIR | (0x7ff << 2));
-		iowrite32(0x0, &priv->regs->if2_id1);
+		iowrite32(0x0, &priv->regs->ifregs[1].id1);
 
 		/* Claring NewDat, TxRqst & IntPnd */
-		pch_can_bit_clear(&priv->regs->if2_mcont,
+		pch_can_bit_clear(&priv->regs->ifregs[1].mcont,
 				  PCH_IF_MCONT_NEWDAT | PCH_IF_MCONT_INTPND |
 				  PCH_IF_MCONT_TXRQXT);
-		pch_can_check_if_busy(&priv->regs->if2_creq, mask);
+		pch_can_check_if_busy(&priv->regs->ifregs[1].creq, mask);
 	} else if (priv->msg_obj[mask - 1] == PCH_MSG_OBJ_RX) {
 		/* Setting CMASK for clearing the reception interrupts. */
 		iowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL | PCH_CMASK_ARB,
-			  &priv->regs->if1_cmask);
+			  &priv->regs->ifregs[0].cmask);
 
 		/* Clearing the Dir bit. */
-		pch_can_bit_clear(&priv->regs->if1_id2, PCH_ID2_DIR);
+		pch_can_bit_clear(&priv->regs->ifregs[0].id2, PCH_ID2_DIR);
 
 		/* Clearing NewDat & IntPnd */
-		pch_can_bit_clear(&priv->regs->if1_mcont,
+		pch_can_bit_clear(&priv->regs->ifregs[0].mcont,
 				  PCH_IF_MCONT_NEWDAT | PCH_IF_MCONT_INTPND);
 
-		pch_can_check_if_busy(&priv->regs->if1_creq, mask);
+		pch_can_check_if_busy(&priv->regs->ifregs[0].creq, mask);
 	}
 }
 
@@ -685,8 +636,8 @@ static void pch_can_error(struct net_device *ndev, u32 status)
 		return;
 
 	if (status & PCH_BUS_OFF) {
-		pch_can_tx_disable_all(priv);
-		pch_can_rx_disable_all(priv);
+		pch_can_set_tx_all(priv, 0);
+		pch_can_set_rx_all(priv, 0);
 		state = CAN_STATE_BUS_OFF;
 		cf->can_id |= CAN_ERR_BUSOFF;
 		can_bus_off(ndev);
@@ -783,22 +734,22 @@ static int pch_can_rx_normal(struct net_device *ndev, u32 int_stat)
 	struct net_device_stats *stats = &(priv->ndev->stats);
 
 	/* Reading the messsage object from the Message RAM */
-	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->if1_cmask);
-	pch_can_check_if_busy(&priv->regs->if1_creq, int_stat);
+	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[0].cmask);
+	pch_can_check_if_busy(&priv->regs->ifregs[0].creq, int_stat);
 
 	/* Reading the MCONT register. */
-	reg = ioread32(&priv->regs->if1_mcont);
+	reg = ioread32(&priv->regs->ifregs[0].mcont);
 	reg &= 0xffff;
 
 	for (k = int_stat; !(reg & PCH_IF_MCONT_EOB); k++) {
 		/* If MsgLost bit set. */
 		if (reg & PCH_IF_MCONT_MSGLOST) {
 			dev_err(&priv->ndev->dev, "Msg Obj is overwritten.\n");
-			pch_can_bit_clear(&priv->regs->if1_mcont,
+			pch_can_bit_clear(&priv->regs->ifregs[0].mcont,
 					  PCH_IF_MCONT_MSGLOST);
 			iowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL,
-				  &priv->regs->if1_cmask);
-			pch_can_check_if_busy(&priv->regs->if1_creq, k);
+				  &priv->regs->ifregs[0].cmask);
+			pch_can_check_if_busy(&priv->regs->ifregs[0].creq, k);
 
 			skb = alloc_can_err_skb(ndev, &cf);
 			if (!skb)
@@ -824,29 +775,30 @@ static int pch_can_rx_normal(struct net_device *ndev, u32 int_stat)
 			return -ENOMEM;
 
 		/* Get Received data */
-		ide = ((ioread32(&priv->regs->if1_id2)) & PCH_ID2_XTD) >> 14;
+		ide = ((ioread32(&priv->regs->ifregs[0].id2)) & PCH_ID2_XTD) >>
+									     14;
 		if (ide) {
-			id = (ioread32(&priv->regs->if1_id1) & 0xffff);
-			id |= (((ioread32(&priv->regs->if1_id2)) &
+			id = (ioread32(&priv->regs->ifregs[0].id1) & 0xffff);
+			id |= (((ioread32(&priv->regs->ifregs[0].id2)) &
 					    0x1fff) << 16);
 			cf->can_id = (id & CAN_EFF_MASK) | CAN_EFF_FLAG;
 		} else {
-			id = (((ioread32(&priv->regs->if1_id2)) &
-					  (CAN_SFF_MASK << 2)) >> 2);
+			id = (((ioread32(&priv->regs->ifregs[0].id2)) &
+						     (CAN_SFF_MASK << 2)) >> 2);
 			cf->can_id = (id & CAN_SFF_MASK);
 		}
 
-		rtr = (ioread32(&priv->regs->if1_id2) &  PCH_ID2_DIR);
+		rtr = (ioread32(&priv->regs->ifregs[0].id2) &  PCH_ID2_DIR);
 		if (rtr) {
 			cf->can_dlc = 0;
 			cf->can_id |= CAN_RTR_FLAG;
 		} else {
-			cf->can_dlc = ((ioread32(&priv->regs->if1_mcont)) &
-						   0x0f);
+			cf->can_dlc = ((ioread32(&priv->regs->ifregs[0].mcont))
+						 & 0x0f);
 		}
 
 		for (i = 0, j = 0; i < cf->can_dlc; j++) {
-			reg = ioread32(&priv->regs->if1_dataa1 + j*4);
+			reg = ioread32(&priv->regs->ifregs[0].dataa1 + j*4);
 			cf->data[i++] = cpu_to_le32(reg & 0xff);
 			if (i == cf->can_dlc)
 				break;
@@ -860,15 +812,16 @@ static int pch_can_rx_normal(struct net_device *ndev, u32 int_stat)
 
 		if (k < PCH_FIFO_THRESH) {
 			iowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL |
-				  PCH_CMASK_ARB, &priv->regs->if1_cmask);
+				  PCH_CMASK_ARB, &priv->regs->ifregs[0].cmask);
 
 			/* Clearing the Dir bit. */
-			pch_can_bit_clear(&priv->regs->if1_id2, PCH_ID2_DIR);
+			pch_can_bit_clear(&priv->regs->ifregs[0].id2,
+					  PCH_ID2_DIR);
 
 			/* Clearing NewDat & IntPnd */
-			pch_can_bit_clear(&priv->regs->if1_mcont,
+			pch_can_bit_clear(&priv->regs->ifregs[0].mcont,
 					  PCH_IF_MCONT_INTPND);
-			pch_can_check_if_busy(&priv->regs->if1_creq, k);
+			pch_can_check_if_busy(&priv->regs->ifregs[0].creq, k);
 		} else if (k > PCH_FIFO_THRESH) {
 			pch_can_int_clr(priv, k);
 		} else if (k == PCH_FIFO_THRESH) {
@@ -878,9 +831,9 @@ static int pch_can_rx_normal(struct net_device *ndev, u32 int_stat)
 		}
 RX_NEXT:
 		/* Reading the messsage object from the Message RAM */
-		iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->if1_cmask);
-		pch_can_check_if_busy(&priv->regs->if1_creq, k + 1);
-		reg = ioread32(&priv->regs->if1_mcont);
+		iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[0].cmask);
+		pch_can_check_if_busy(&priv->regs->ifregs[0].creq, k + 1);
+		reg = ioread32(&priv->regs->ifregs[0].mcont);
 	}
 
 	return rcv_pkts;
@@ -910,8 +863,9 @@ static int pch_can_rx_poll(struct napi_struct *napi, int quota)
 
 		if (reg_stat & PCH_TX_OK) {
 			spin_lock_irqsave(&priv->msgif_reg_lock, flags);
-			iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->if2_cmask);
-			pch_can_check_if_busy(&priv->regs->if2_creq,
+			iowrite32(PCH_CMASK_RX_TX_GET,
+				  &priv->regs->ifregs[1].cmask);
+			pch_can_check_if_busy(&priv->regs->ifregs[1].creq,
 					       ioread32(&priv->regs->intr));
 			spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
 			pch_can_bit_clear(&priv->regs->stat, PCH_TX_OK);
@@ -938,10 +892,11 @@ static int pch_can_rx_poll(struct napi_struct *napi, int quota)
 			can_get_echo_skb(ndev, int_stat - PCH_RX_OBJ_NUM - 1);
 			spin_lock_irqsave(&priv->msgif_reg_lock, flags);
 			iowrite32(PCH_CMASK_RX_TX_GET | PCH_CMASK_CLRINTPND,
-				  &priv->regs->if2_cmask);
-			dlc = ioread32(&priv->regs->if2_mcont) &
+				  &priv->regs->ifregs[1].cmask);
+			dlc = ioread32(&priv->regs->ifregs[1].mcont) &
 				       PCH_IF_MCONT_DLC;
-			pch_can_check_if_busy(&priv->regs->if2_creq, int_stat);
+			pch_can_check_if_busy(&priv->regs->ifregs[1].creq,
+					      int_stat);
 			spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
 			if (dlc > 8)
 				dlc = 8;
@@ -996,8 +951,8 @@ static void pch_can_start(struct net_device *ndev)
 	pch_set_bittiming(ndev);
 	pch_can_set_optmode(priv);
 
-	pch_can_tx_enable_all(priv);
-	pch_can_rx_enable_all(priv);
+	pch_can_set_tx_all(priv, 1);
+	pch_can_set_rx_all(priv, 1);
 
 	/* Setting the CAN to run mode. */
 	pch_can_set_run_mode(priv, PCH_CAN_RUN);
@@ -1125,54 +1080,55 @@ static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
 	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
 
 	/* Reading the Msg Obj from the Msg RAM to the Interface register. */
-	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->if2_cmask);
-	pch_can_check_if_busy(&priv->regs->if2_creq, tx_buffer_avail);
+	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[1].cmask);
+	pch_can_check_if_busy(&priv->regs->ifregs[1].creq, tx_buffer_avail);
 
 	/* Setting the CMASK register. */
-	pch_can_bit_set(&priv->regs->if2_cmask, PCH_CMASK_ALL);
+	pch_can_bit_set(&priv->regs->ifregs[1].cmask, PCH_CMASK_ALL);
 
 	/* If ID extended is set. */
-	pch_can_bit_clear(&priv->regs->if2_id1, 0xffff);
-	pch_can_bit_clear(&priv->regs->if2_id2, 0x1fff | PCH_ID2_XTD);
+	pch_can_bit_clear(&priv->regs->ifregs[1].id1, 0xffff);
+	pch_can_bit_clear(&priv->regs->ifregs[1].id2, 0x1fff | PCH_ID2_XTD);
 	if (cf->can_id & CAN_EFF_FLAG) {
-		pch_can_bit_set(&priv->regs->if2_id1, cf->can_id & 0xffff);
-		pch_can_bit_set(&priv->regs->if2_id2,
+		pch_can_bit_set(&priv->regs->ifregs[1].id1,
+				cf->can_id & 0xffff);
+		pch_can_bit_set(&priv->regs->ifregs[1].id2,
 				((cf->can_id >> 16) & 0x1fff) | PCH_ID2_XTD);
 	} else {
-		pch_can_bit_set(&priv->regs->if2_id1, 0);
-		pch_can_bit_set(&priv->regs->if2_id2,
+		pch_can_bit_set(&priv->regs->ifregs[1].id1, 0);
+		pch_can_bit_set(&priv->regs->ifregs[1].id2,
 				(cf->can_id & CAN_SFF_MASK) << 2);
 	}
 
 	/* If remote frame has to be transmitted.. */
 	if (cf->can_id & CAN_RTR_FLAG)
-		pch_can_bit_clear(&priv->regs->if2_id2, PCH_ID2_DIR);
+		pch_can_bit_clear(&priv->regs->ifregs[1].id2, PCH_ID2_DIR);
 
 	for (i = 0, j = 0; i < cf->can_dlc; j++) {
 		iowrite32(le32_to_cpu(cf->data[i++]),
-			 (&priv->regs->if2_dataa1) + j*4);
+			 (&priv->regs->ifregs[1].dataa1) + j*4);
 		if (i == cf->can_dlc)
 			break;
 		iowrite32(le32_to_cpu(cf->data[i++] << 8),
-			 (&priv->regs->if2_dataa1) + j*4);
+			 (&priv->regs->ifregs[1].dataa1) + j*4);
 	}
 
 	can_put_echo_skb(skb, ndev, tx_buffer_avail - PCH_RX_OBJ_NUM - 1);
 
 	/* Updating the size of the data. */
-	pch_can_bit_clear(&priv->regs->if2_mcont, 0x0f);
-	pch_can_bit_set(&priv->regs->if2_mcont, cf->can_dlc);
+	pch_can_bit_clear(&priv->regs->ifregs[1].mcont, 0x0f);
+	pch_can_bit_set(&priv->regs->ifregs[1].mcont, cf->can_dlc);
 
 	/* Clearing IntPend, NewDat & TxRqst */
-	pch_can_bit_clear(&priv->regs->if2_mcont,
+	pch_can_bit_clear(&priv->regs->ifregs[1].mcont,
 			  PCH_IF_MCONT_NEWDAT | PCH_IF_MCONT_INTPND |
 			  PCH_IF_MCONT_TXRQXT);
 
 	/* Setting NewDat, TxRqst bits */
-	pch_can_bit_set(&priv->regs->if2_mcont,
+	pch_can_bit_set(&priv->regs->ifregs[1].mcont,
 			PCH_IF_MCONT_NEWDAT | PCH_IF_MCONT_TXRQXT);
 
-	pch_can_check_if_busy(&priv->regs->if2_creq, tx_buffer_avail);
+	pch_can_check_if_busy(&priv->regs->ifregs[1].creq, tx_buffer_avail);
 
 	spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
 
@@ -1234,25 +1190,25 @@ static int pch_can_suspend(struct pci_dev *pdev, pm_message_t state)
 	/* Save Tx buffer enable state */
 	for (i = 0; i < PCH_OBJ_NUM; i++) {
 		if (priv->msg_obj[i] == PCH_MSG_OBJ_TX)
-			pch_can_get_tx_enable(priv, i + 1,
-					      &(priv->tx_enable[i]));
+			priv->tx_enable[i] = pch_can_get_rxtx_ir(priv, i + 1,
+								 PCH_TX_IFREG);
 	}
 
 	/* Disable all Transmit buffers */
-	pch_can_tx_disable_all(priv);
+	pch_can_set_tx_all(priv, 0);
 
 	/* Save Rx buffer enable state */
 	for (i = 0; i < PCH_OBJ_NUM; i++) {
 		if (priv->msg_obj[i] == PCH_MSG_OBJ_RX) {
-			pch_can_get_rx_enable(priv, i + 1,
-						&(priv->rx_enable[i]));
+			priv->rx_enable[i] = pch_can_get_rxtx_ir(priv, i + 1,
+						PCH_RX_IFREG);
 			pch_can_get_rx_buffer_link(priv, i + 1,
 						&(priv->rx_link[i]));
 		}
 	}
 
 	/* Disable all Receive buffers */
-	pch_can_rx_disable_all(priv);
+	pch_can_set_rx_all(priv, 0);
 	retval = pci_save_state(pdev);
 	if (retval) {
 		dev_err(&pdev->dev, "pci_save_state failed.\n");
@@ -1301,10 +1257,9 @@ static int pch_can_resume(struct pci_dev *pdev)
 
 	/* Enabling the transmit buffer. */
 	for (i = 0; i < PCH_OBJ_NUM; i++) {
-		if (priv->msg_obj[i] == PCH_MSG_OBJ_TX) {
-			pch_can_set_tx_enable(priv, i + 1,
-					      priv->tx_enable[i]);
-		}
+		if (priv->msg_obj[i] == PCH_MSG_OBJ_TX)
+			pch_can_set_rxtx(priv, i, priv->tx_enable[i],
+					 PCH_TX_IFREG);
 	}
 
 	/* Configuring the receive buffer and enabling them. */
@@ -1315,7 +1270,9 @@ static int pch_can_resume(struct pci_dev *pdev)
 						   priv->rx_link[i]);
 
 			/* Restore buffer enables */
-			pch_can_set_rx_enable(priv, i + 1, priv->rx_enable[i]);
+			pch_can_set_rxtx(priv, i, priv->rx_enable[i],
+					 PCH_RX_IFREG);
+
 		}
 	}
 

commit 0a80410dc53cf68e56456bef1ca66949b87412f9
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Wed Nov 17 14:06:25 2010 +0000

    can: EG20T PCH: use BIT(X)
    
    Replace bit assignment value to BIT(X).
    For easy to readable/identifiable, replace all bit assigned macros to BIT(X)
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Acked-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index c523e3dd5d10..238622a04bc1 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -38,50 +38,51 @@
 
 #define PCH_ENABLE		1 /* The enable flag */
 #define PCH_DISABLE		0 /* The disable flag */
-#define PCH_CTRL_INIT		0x0001 /* The INIT bit of CANCONT register. */
-#define PCH_CTRL_IE		0x0002 /* The IE bit of CAN control register */
-#define PCH_CTRL_IE_SIE_EIE	0x000e
-#define PCH_CTRL_CCE		0x0040
-#define PCH_CTRL_OPT		0x0080 /* The OPT bit of CANCONT register. */
-#define PCH_OPT_SILENT		0x0008 /* The Silent bit of CANOPT reg. */
-#define PCH_OPT_LBACK		0x0010 /* The LoopBack bit of CANOPT reg. */
+#define PCH_CTRL_INIT		BIT(0) /* The INIT bit of CANCONT register. */
+#define PCH_CTRL_IE		BIT(1) /* The IE bit of CAN control register */
+#define PCH_CTRL_IE_SIE_EIE	(BIT(3) | BIT(2) | BIT(1))
+#define PCH_CTRL_CCE		BIT(6)
+#define PCH_CTRL_OPT		BIT(7) /* The OPT bit of CANCONT register. */
+#define PCH_OPT_SILENT		BIT(3) /* The Silent bit of CANOPT reg. */
+#define PCH_OPT_LBACK		BIT(4) /* The LoopBack bit of CANOPT reg. */
+
 #define PCH_CMASK_RX_TX_SET	0x00f3
 #define PCH_CMASK_RX_TX_GET	0x0073
 #define PCH_CMASK_ALL		0xff
-#define PCH_CMASK_RDWR		0x80
-#define PCH_CMASK_ARB		0x20
-#define PCH_CMASK_CTRL		0x10
-#define PCH_CMASK_MASK		0x40
-#define PCH_CMASK_NEWDAT	0x04
-#define PCH_CMASK_CLRINTPND	0x08
-#define PCH_IF_MCONT_NEWDAT	0x8000
-#define PCH_IF_MCONT_INTPND	0x2000
-#define PCH_IF_MCONT_UMASK	0x1000
-#define PCH_IF_MCONT_TXIE	0x0800
-#define PCH_IF_MCONT_RXIE	0x0400
-#define PCH_IF_MCONT_RMTEN	0x0200
-#define PCH_IF_MCONT_TXRQXT	0x0100
-#define PCH_IF_MCONT_EOB	0x0080
-#define PCH_IF_MCONT_DLC	0x000f
-#define PCH_IF_MCONT_MSGLOST	0x4000
-#define PCH_MASK2_MDIR_MXTD	0xc000
-#define PCH_ID2_DIR		0x2000
-#define PCH_ID2_XTD		0x4000
-#define PCH_ID_MSGVAL		0x8000
-#define PCH_IF_CREQ_BUSY	0x8000
+#define PCH_CMASK_NEWDAT	BIT(2)
+#define PCH_CMASK_CLRINTPND	BIT(3)
+#define PCH_CMASK_CTRL		BIT(4)
+#define PCH_CMASK_ARB		BIT(5)
+#define PCH_CMASK_MASK		BIT(6)
+#define PCH_CMASK_RDWR		BIT(7)
+#define PCH_IF_MCONT_NEWDAT	BIT(15)
+#define PCH_IF_MCONT_MSGLOST	BIT(14)
+#define PCH_IF_MCONT_INTPND	BIT(13)
+#define PCH_IF_MCONT_UMASK	BIT(12)
+#define PCH_IF_MCONT_TXIE	BIT(11)
+#define PCH_IF_MCONT_RXIE	BIT(10)
+#define PCH_IF_MCONT_RMTEN	BIT(9)
+#define PCH_IF_MCONT_TXRQXT	BIT(8)
+#define PCH_IF_MCONT_EOB	BIT(7)
+#define PCH_IF_MCONT_DLC	(BIT(0) | BIT(1) | BIT(2) | BIT(3))
+#define PCH_MASK2_MDIR_MXTD	(BIT(14) | BIT(15))
+#define PCH_ID2_DIR		BIT(13)
+#define PCH_ID2_XTD		BIT(14)
+#define PCH_ID_MSGVAL		BIT(15)
+#define PCH_IF_CREQ_BUSY	BIT(15)
 
 #define PCH_STATUS_INT		0x8000
 #define PCH_REC			0x00007f00
 #define PCH_TEC			0x000000ff
 
-#define PCH_RX_OK		0x00000010
-#define PCH_TX_OK		0x00000008
-#define PCH_BUS_OFF		0x00000080
-#define PCH_EWARN		0x00000040
-#define PCH_EPASSIV		0x00000020
-#define PCH_LEC0		0x00000001
-#define PCH_LEC1		0x00000002
-#define PCH_LEC2		0x00000004
+#define PCH_TX_OK		BIT(3)
+#define PCH_RX_OK		BIT(4)
+#define PCH_EPASSIV		BIT(5)
+#define PCH_EWARN		BIT(6)
+#define PCH_BUS_OFF		BIT(7)
+#define PCH_LEC0		BIT(0)
+#define PCH_LEC1		BIT(1)
+#define PCH_LEC2		BIT(2)
 #define PCH_LEC_ALL		(PCH_LEC0 | PCH_LEC1 | PCH_LEC2)
 #define PCH_STUF_ERR		PCH_LEC0
 #define PCH_FORM_ERR		PCH_LEC1

commit 086b5650dcdaae7c4aa60a5d0724f775e733610e
Author: Tomoya <tomoya-linux@dsn.okisemi.com>
Date:   Wed Nov 17 01:13:16 2010 +0000

    can: EG20T PCH: add prefix to macro
    
    For easy to readable/identifiable, add prefix "PCH_" to all of #define macros.
    
    Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>
    Acked-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 672718261c68..c523e3dd5d10 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -32,49 +32,47 @@
 #include <linux/can/dev.h>
 #include <linux/can/error.h>
 
-#define MAX_MSG_OBJ		32
-#define MSG_OBJ_RX		0 /* The receive message object flag. */
-#define MSG_OBJ_TX		1 /* The transmit message object flag. */
-
-#define ENABLE			1 /* The enable flag */
-#define DISABLE			0 /* The disable flag */
-#define CAN_CTRL_INIT		0x0001 /* The INIT bit of CANCONT register. */
-#define CAN_CTRL_IE		0x0002 /* The IE bit of CAN control register */
-#define CAN_CTRL_IE_SIE_EIE	0x000e
-#define CAN_CTRL_CCE		0x0040
-#define CAN_CTRL_OPT		0x0080 /* The OPT bit of CANCONT register. */
-#define CAN_OPT_SILENT		0x0008 /* The Silent bit of CANOPT reg. */
-#define CAN_OPT_LBACK		0x0010 /* The LoopBack bit of CANOPT reg. */
-#define CAN_CMASK_RX_TX_SET	0x00f3
-#define CAN_CMASK_RX_TX_GET	0x0073
-#define CAN_CMASK_ALL		0xff
-#define CAN_CMASK_RDWR		0x80
-#define CAN_CMASK_ARB		0x20
-#define CAN_CMASK_CTRL		0x10
-#define CAN_CMASK_MASK		0x40
-#define CAN_CMASK_NEWDAT	0x04
-#define CAN_CMASK_CLRINTPND	0x08
-
-#define CAN_IF_MCONT_NEWDAT	0x8000
-#define CAN_IF_MCONT_INTPND	0x2000
-#define CAN_IF_MCONT_UMASK	0x1000
-#define CAN_IF_MCONT_TXIE	0x0800
-#define CAN_IF_MCONT_RXIE	0x0400
-#define CAN_IF_MCONT_RMTEN	0x0200
-#define CAN_IF_MCONT_TXRQXT	0x0100
-#define CAN_IF_MCONT_EOB	0x0080
-#define CAN_IF_MCONT_DLC	0x000f
-#define CAN_IF_MCONT_MSGLOST	0x4000
-#define CAN_MASK2_MDIR_MXTD	0xc000
-#define CAN_ID2_DIR		0x2000
-#define CAN_ID_MSGVAL		0x8000
-
-#define CAN_STATUS_INT		0x8000
-#define CAN_IF_CREQ_BUSY	0x8000
-#define CAN_ID2_XTD		0x4000
-
-#define CAN_REC			0x00007f00
-#define CAN_TEC			0x000000ff
+#define PCH_MAX_MSG_OBJ		32
+#define PCH_MSG_OBJ_RX		0 /* The receive message object flag. */
+#define PCH_MSG_OBJ_TX		1 /* The transmit message object flag. */
+
+#define PCH_ENABLE		1 /* The enable flag */
+#define PCH_DISABLE		0 /* The disable flag */
+#define PCH_CTRL_INIT		0x0001 /* The INIT bit of CANCONT register. */
+#define PCH_CTRL_IE		0x0002 /* The IE bit of CAN control register */
+#define PCH_CTRL_IE_SIE_EIE	0x000e
+#define PCH_CTRL_CCE		0x0040
+#define PCH_CTRL_OPT		0x0080 /* The OPT bit of CANCONT register. */
+#define PCH_OPT_SILENT		0x0008 /* The Silent bit of CANOPT reg. */
+#define PCH_OPT_LBACK		0x0010 /* The LoopBack bit of CANOPT reg. */
+#define PCH_CMASK_RX_TX_SET	0x00f3
+#define PCH_CMASK_RX_TX_GET	0x0073
+#define PCH_CMASK_ALL		0xff
+#define PCH_CMASK_RDWR		0x80
+#define PCH_CMASK_ARB		0x20
+#define PCH_CMASK_CTRL		0x10
+#define PCH_CMASK_MASK		0x40
+#define PCH_CMASK_NEWDAT	0x04
+#define PCH_CMASK_CLRINTPND	0x08
+#define PCH_IF_MCONT_NEWDAT	0x8000
+#define PCH_IF_MCONT_INTPND	0x2000
+#define PCH_IF_MCONT_UMASK	0x1000
+#define PCH_IF_MCONT_TXIE	0x0800
+#define PCH_IF_MCONT_RXIE	0x0400
+#define PCH_IF_MCONT_RMTEN	0x0200
+#define PCH_IF_MCONT_TXRQXT	0x0100
+#define PCH_IF_MCONT_EOB	0x0080
+#define PCH_IF_MCONT_DLC	0x000f
+#define PCH_IF_MCONT_MSGLOST	0x4000
+#define PCH_MASK2_MDIR_MXTD	0xc000
+#define PCH_ID2_DIR		0x2000
+#define PCH_ID2_XTD		0x4000
+#define PCH_ID_MSGVAL		0x8000
+#define PCH_IF_CREQ_BUSY	0x8000
+
+#define PCH_STATUS_INT		0x8000
+#define PCH_REC			0x00007f00
+#define PCH_TEC			0x000000ff
 
 #define PCH_RX_OK		0x00000010
 #define PCH_TX_OK		0x00000008
@@ -93,26 +91,15 @@
 #define PCH_CRC_ERR		(PCH_LEC1 | PCH_LEC2)
 
 /* bit position of certain controller bits. */
-#define BIT_BITT_BRP		0
-#define BIT_BITT_SJW		6
-#define BIT_BITT_TSEG1		8
-#define BIT_BITT_TSEG2		12
-#define BIT_IF1_MCONT_RXIE	10
-#define BIT_IF2_MCONT_TXIE	11
-#define BIT_BRPE_BRPE		6
-#define BIT_ES_TXERRCNT		0
-#define BIT_ES_RXERRCNT		8
-#define MSK_BITT_BRP		0x3f
-#define MSK_BITT_SJW		0xc0
-#define MSK_BITT_TSEG1		0xf00
-#define MSK_BITT_TSEG2		0x7000
-#define MSK_BRPE_BRPE		0x3c0
-#define MSK_BRPE_GET		0x0f
-#define MSK_CTRL_IE_SIE_EIE	0x07
-#define MSK_MCONT_TXIE		0x08
-#define MSK_MCONT_RXIE		0x10
-#define PCH_CAN_NO_TX_BUFF	1
-#define COUNTER_LIMIT		10
+#define PCH_BIT_BRP		0
+#define PCH_BIT_SJW		6
+#define PCH_BIT_TSEG1		8
+#define PCH_BIT_TSEG2		12
+#define PCH_BIT_BRPE_BRPE	6
+#define PCH_MSK_BITT_BRP	0x3f
+#define PCH_MSK_BRPE_BRPE	0x3c0
+#define PCH_MSK_CTRL_IE_SIE_EIE	0x07
+#define PCH_COUNTER_LIMIT	10
 
 #define PCH_CAN_CLK		50000000	/* 50MHz */
 
@@ -181,14 +168,14 @@ struct pch_can_priv {
 	struct can_priv can;
 	unsigned int can_num;
 	struct pci_dev *dev;
-	unsigned int tx_enable[MAX_MSG_OBJ];
-	unsigned int rx_enable[MAX_MSG_OBJ];
-	unsigned int rx_link[MAX_MSG_OBJ];
+	unsigned int tx_enable[PCH_MAX_MSG_OBJ];
+	unsigned int rx_enable[PCH_MAX_MSG_OBJ];
+	unsigned int rx_link[PCH_MAX_MSG_OBJ];
 	unsigned int int_enables;
 	unsigned int int_stat;
 	struct net_device *ndev;
 	spinlock_t msgif_reg_lock; /* Message Interface Registers Access Lock*/
-	unsigned int msg_obj[MAX_MSG_OBJ];
+	unsigned int msg_obj[PCH_MAX_MSG_OBJ];
 	struct pch_can_regs __iomem *regs;
 	struct napi_struct napi;
 	unsigned int tx_obj;	/* Point next Tx Obj index */
@@ -228,11 +215,11 @@ static void pch_can_set_run_mode(struct pch_can_priv *priv,
 {
 	switch (mode) {
 	case PCH_CAN_RUN:
-		pch_can_bit_clear(&priv->regs->cont, CAN_CTRL_INIT);
+		pch_can_bit_clear(&priv->regs->cont, PCH_CTRL_INIT);
 		break;
 
 	case PCH_CAN_STOP:
-		pch_can_bit_set(&priv->regs->cont, CAN_CTRL_INIT);
+		pch_can_bit_set(&priv->regs->cont, PCH_CTRL_INIT);
 		break;
 
 	default:
@@ -246,30 +233,30 @@ static void pch_can_set_optmode(struct pch_can_priv *priv)
 	u32 reg_val = ioread32(&priv->regs->opt);
 
 	if (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)
-		reg_val |= CAN_OPT_SILENT;
+		reg_val |= PCH_OPT_SILENT;
 
 	if (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)
-		reg_val |= CAN_OPT_LBACK;
+		reg_val |= PCH_OPT_LBACK;
 
-	pch_can_bit_set(&priv->regs->cont, CAN_CTRL_OPT);
+	pch_can_bit_set(&priv->regs->cont, PCH_CTRL_OPT);
 	iowrite32(reg_val, &priv->regs->opt);
 }
 
 static void pch_can_set_int_custom(struct pch_can_priv *priv)
 {
 	/* Clearing the IE, SIE and EIE bits of Can control register. */
-	pch_can_bit_clear(&priv->regs->cont, CAN_CTRL_IE_SIE_EIE);
+	pch_can_bit_clear(&priv->regs->cont, PCH_CTRL_IE_SIE_EIE);
 
 	/* Appropriately setting them. */
 	pch_can_bit_set(&priv->regs->cont,
-			((priv->int_enables & MSK_CTRL_IE_SIE_EIE) << 1));
+			((priv->int_enables & PCH_MSK_CTRL_IE_SIE_EIE) << 1));
 }
 
 /* This function retrieves interrupt enabled for the CAN device. */
 static void pch_can_get_int_enables(struct pch_can_priv *priv, u32 *enables)
 {
 	/* Obtaining the status of IE, SIE and EIE interrupt bits. */
-	*enables = ((ioread32(&priv->regs->cont) & CAN_CTRL_IE_SIE_EIE) >> 1);
+	*enables = ((ioread32(&priv->regs->cont) & PCH_CTRL_IE_SIE_EIE) >> 1);
 }
 
 static void pch_can_set_int_enables(struct pch_can_priv *priv,
@@ -277,19 +264,19 @@ static void pch_can_set_int_enables(struct pch_can_priv *priv,
 {
 	switch (interrupt_no) {
 	case PCH_CAN_ENABLE:
-		pch_can_bit_set(&priv->regs->cont, CAN_CTRL_IE);
+		pch_can_bit_set(&priv->regs->cont, PCH_CTRL_IE);
 		break;
 
 	case PCH_CAN_DISABLE:
-		pch_can_bit_clear(&priv->regs->cont, CAN_CTRL_IE);
+		pch_can_bit_clear(&priv->regs->cont, PCH_CTRL_IE);
 		break;
 
 	case PCH_CAN_ALL:
-		pch_can_bit_set(&priv->regs->cont, CAN_CTRL_IE_SIE_EIE);
+		pch_can_bit_set(&priv->regs->cont, PCH_CTRL_IE_SIE_EIE);
 		break;
 
 	case PCH_CAN_NONE:
-		pch_can_bit_clear(&priv->regs->cont, CAN_CTRL_IE_SIE_EIE);
+		pch_can_bit_clear(&priv->regs->cont, PCH_CTRL_IE_SIE_EIE);
 		break;
 
 	default:
@@ -300,12 +287,12 @@ static void pch_can_set_int_enables(struct pch_can_priv *priv,
 
 static void pch_can_check_if_busy(u32 __iomem *creq_addr, u32 num)
 {
-	u32 counter = COUNTER_LIMIT;
+	u32 counter = PCH_COUNTER_LIMIT;
 	u32 ifx_creq;
 
 	iowrite32(num, creq_addr);
 	while (counter) {
-		ifx_creq = ioread32(creq_addr) & CAN_IF_CREQ_BUSY;
+		ifx_creq = ioread32(creq_addr) & PCH_IF_CREQ_BUSY;
 		if (!ifx_creq)
 			break;
 		counter--;
@@ -322,22 +309,22 @@ static void pch_can_set_rx_enable(struct pch_can_priv *priv, u32 buff_num,
 
 	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
 	/* Reading the receive buffer data from RAM to Interface1 registers */
-	iowrite32(CAN_CMASK_RX_TX_GET, &priv->regs->if1_cmask);
+	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->if1_cmask);
 	pch_can_check_if_busy(&priv->regs->if1_creq, buff_num);
 
 	/* Setting the IF1MASK1 register to access MsgVal and RxIE bits */
-	iowrite32(CAN_CMASK_RDWR | CAN_CMASK_ARB | CAN_CMASK_CTRL,
+	iowrite32(PCH_CMASK_RDWR | PCH_CMASK_ARB | PCH_CMASK_CTRL,
 		  &priv->regs->if1_cmask);
 
-	if (set == ENABLE) {
+	if (set == PCH_ENABLE) {
 		/* Setting the MsgVal and RxIE bits */
-		pch_can_bit_set(&priv->regs->if1_mcont, CAN_IF_MCONT_RXIE);
-		pch_can_bit_set(&priv->regs->if1_id2, CAN_ID_MSGVAL);
+		pch_can_bit_set(&priv->regs->if1_mcont, PCH_IF_MCONT_RXIE);
+		pch_can_bit_set(&priv->regs->if1_id2, PCH_ID_MSGVAL);
 
-	} else if (set == DISABLE) {
+	} else if (set == PCH_DISABLE) {
 		/* Resetting the MsgVal and RxIE bits */
-		pch_can_bit_clear(&priv->regs->if1_mcont, CAN_IF_MCONT_RXIE);
-		pch_can_bit_clear(&priv->regs->if1_id2, CAN_ID_MSGVAL);
+		pch_can_bit_clear(&priv->regs->if1_mcont, PCH_IF_MCONT_RXIE);
+		pch_can_bit_clear(&priv->regs->if1_id2, PCH_ID_MSGVAL);
 	}
 
 	pch_can_check_if_busy(&priv->regs->if1_creq, buff_num);
@@ -350,8 +337,8 @@ static void pch_can_rx_enable_all(struct pch_can_priv *priv)
 
 	/* Traversing to obtain the object configured as receivers. */
 	for (i = 0; i < PCH_OBJ_NUM; i++) {
-		if (priv->msg_obj[i] == MSG_OBJ_RX)
-			pch_can_set_rx_enable(priv, i + 1, ENABLE);
+		if (priv->msg_obj[i] == PCH_MSG_OBJ_RX)
+			pch_can_set_rx_enable(priv, i + 1, PCH_ENABLE);
 	}
 }
 
@@ -361,8 +348,8 @@ static void pch_can_rx_disable_all(struct pch_can_priv *priv)
 
 	/* Traversing to obtain the object configured as receivers. */
 	for (i = 0; i < PCH_OBJ_NUM; i++) {
-		if (priv->msg_obj[i] == MSG_OBJ_RX)
-			pch_can_set_rx_enable(priv, i + 1, DISABLE);
+		if (priv->msg_obj[i] == PCH_MSG_OBJ_RX)
+			pch_can_set_rx_enable(priv, i + 1, PCH_DISABLE);
 	}
 }
 
@@ -373,22 +360,22 @@ static void pch_can_set_tx_enable(struct pch_can_priv *priv, u32 buff_num,
 
 	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
 	/* Reading the Msg buffer from Message RAM to Interface2 registers. */
-	iowrite32(CAN_CMASK_RX_TX_GET, &priv->regs->if2_cmask);
+	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->if2_cmask);
 	pch_can_check_if_busy(&priv->regs->if2_creq, buff_num);
 
 	/* Setting the IF2CMASK register for accessing the
 		MsgVal and TxIE bits */
-	iowrite32(CAN_CMASK_RDWR | CAN_CMASK_ARB | CAN_CMASK_CTRL,
+	iowrite32(PCH_CMASK_RDWR | PCH_CMASK_ARB | PCH_CMASK_CTRL,
 		 &priv->regs->if2_cmask);
 
-	if (set == ENABLE) {
+	if (set == PCH_ENABLE) {
 		/* Setting the MsgVal and TxIE bits */
-		pch_can_bit_set(&priv->regs->if2_mcont, CAN_IF_MCONT_TXIE);
-		pch_can_bit_set(&priv->regs->if2_id2, CAN_ID_MSGVAL);
-	} else if (set == DISABLE) {
+		pch_can_bit_set(&priv->regs->if2_mcont, PCH_IF_MCONT_TXIE);
+		pch_can_bit_set(&priv->regs->if2_id2, PCH_ID_MSGVAL);
+	} else if (set == PCH_DISABLE) {
 		/* Resetting the MsgVal and TxIE bits. */
-		pch_can_bit_clear(&priv->regs->if2_mcont, CAN_IF_MCONT_TXIE);
-		pch_can_bit_clear(&priv->regs->if2_id2, CAN_ID_MSGVAL);
+		pch_can_bit_clear(&priv->regs->if2_mcont, PCH_IF_MCONT_TXIE);
+		pch_can_bit_clear(&priv->regs->if2_id2, PCH_ID_MSGVAL);
 	}
 
 	pch_can_check_if_busy(&priv->regs->if2_creq, buff_num);
@@ -401,8 +388,8 @@ static void pch_can_tx_enable_all(struct pch_can_priv *priv)
 
 	/* Traversing to obtain the object configured as transmit object. */
 	for (i = 0; i < PCH_OBJ_NUM; i++) {
-		if (priv->msg_obj[i] == MSG_OBJ_TX)
-			pch_can_set_tx_enable(priv, i + 1, ENABLE);
+		if (priv->msg_obj[i] == PCH_MSG_OBJ_TX)
+			pch_can_set_tx_enable(priv, i + 1, PCH_ENABLE);
 	}
 }
 
@@ -412,8 +399,8 @@ static void pch_can_tx_disable_all(struct pch_can_priv *priv)
 
 	/* Traversing to obtain the object configured as transmit object. */
 	for (i = 0; i < PCH_OBJ_NUM; i++) {
-		if (priv->msg_obj[i] == MSG_OBJ_TX)
-			pch_can_set_tx_enable(priv, i + 1, DISABLE);
+		if (priv->msg_obj[i] == PCH_MSG_OBJ_TX)
+			pch_can_set_tx_enable(priv, i + 1, PCH_DISABLE);
 	}
 }
 
@@ -423,15 +410,15 @@ static void pch_can_get_rx_enable(struct pch_can_priv *priv, u32 buff_num,
 	unsigned long flags;
 
 	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
-	iowrite32(CAN_CMASK_RX_TX_GET, &priv->regs->if1_cmask);
+	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->if1_cmask);
 	pch_can_check_if_busy(&priv->regs->if1_creq, buff_num);
 
-	if (((ioread32(&priv->regs->if1_id2)) & CAN_ID_MSGVAL) &&
+	if (((ioread32(&priv->regs->if1_id2)) & PCH_ID_MSGVAL) &&
 			((ioread32(&priv->regs->if1_mcont)) &
-			CAN_IF_MCONT_RXIE))
-		*enable = ENABLE;
+			PCH_IF_MCONT_RXIE))
+		*enable = PCH_ENABLE;
 	else
-		*enable = DISABLE;
+		*enable = PCH_DISABLE;
 	spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
 }
 
@@ -441,15 +428,15 @@ static void pch_can_get_tx_enable(struct pch_can_priv *priv, u32 buff_num,
 	unsigned long flags;
 
 	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
-	iowrite32(CAN_CMASK_RX_TX_GET, &priv->regs->if2_cmask);
+	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->if2_cmask);
 	pch_can_check_if_busy(&priv->regs->if2_creq, buff_num);
 
-	if (((ioread32(&priv->regs->if2_id2)) & CAN_ID_MSGVAL) &&
+	if (((ioread32(&priv->regs->if2_id2)) & PCH_ID_MSGVAL) &&
 			((ioread32(&priv->regs->if2_mcont)) &
-			CAN_IF_MCONT_TXIE)) {
-		*enable = ENABLE;
+			PCH_IF_MCONT_TXIE)) {
+		*enable = PCH_ENABLE;
 	} else {
-		*enable = DISABLE;
+		*enable = PCH_DISABLE;
 	}
 	spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
 }
@@ -465,13 +452,13 @@ static void pch_can_set_rx_buffer_link(struct pch_can_priv *priv,
 	unsigned long flags;
 
 	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
-	iowrite32(CAN_CMASK_RX_TX_GET, &priv->regs->if1_cmask);
+	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->if1_cmask);
 	pch_can_check_if_busy(&priv->regs->if1_creq, buffer_num);
-	iowrite32(CAN_CMASK_RDWR | CAN_CMASK_CTRL, &priv->regs->if1_cmask);
-	if (set == ENABLE)
-		pch_can_bit_clear(&priv->regs->if1_mcont, CAN_IF_MCONT_EOB);
+	iowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL, &priv->regs->if1_cmask);
+	if (set == PCH_ENABLE)
+		pch_can_bit_clear(&priv->regs->if1_mcont, PCH_IF_MCONT_EOB);
 	else
-		pch_can_bit_set(&priv->regs->if1_mcont, CAN_IF_MCONT_EOB);
+		pch_can_bit_set(&priv->regs->if1_mcont, PCH_IF_MCONT_EOB);
 
 	pch_can_check_if_busy(&priv->regs->if1_creq, buffer_num);
 	spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
@@ -483,13 +470,13 @@ static void pch_can_get_rx_buffer_link(struct pch_can_priv *priv,
 	unsigned long flags;
 
 	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
-	iowrite32(CAN_CMASK_RX_TX_GET, &priv->regs->if1_cmask);
+	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->if1_cmask);
 	pch_can_check_if_busy(&priv->regs->if1_creq, buffer_num);
 
-	if (ioread32(&priv->regs->if1_mcont) & CAN_IF_MCONT_EOB)
-		*link = DISABLE;
+	if (ioread32(&priv->regs->if1_mcont) & PCH_IF_MCONT_EOB)
+		*link = PCH_DISABLE;
 	else
-		*link = ENABLE;
+		*link = PCH_ENABLE;
 	spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
 }
 
@@ -498,7 +485,7 @@ static void pch_can_clear_buffers(struct pch_can_priv *priv)
 	int i;
 
 	for (i = 0; i < PCH_RX_OBJ_NUM; i++) {
-		iowrite32(CAN_CMASK_RX_TX_SET, &priv->regs->if1_cmask);
+		iowrite32(PCH_CMASK_RX_TX_SET, &priv->regs->if1_cmask);
 		iowrite32(0xffff, &priv->regs->if1_mask1);
 		iowrite32(0xffff, &priv->regs->if1_mask2);
 		iowrite32(0x0, &priv->regs->if1_id1);
@@ -508,14 +495,14 @@ static void pch_can_clear_buffers(struct pch_can_priv *priv)
 		iowrite32(0x0, &priv->regs->if1_dataa2);
 		iowrite32(0x0, &priv->regs->if1_datab1);
 		iowrite32(0x0, &priv->regs->if1_datab2);
-		iowrite32(CAN_CMASK_RDWR | CAN_CMASK_MASK |
-			  CAN_CMASK_ARB | CAN_CMASK_CTRL,
+		iowrite32(PCH_CMASK_RDWR | PCH_CMASK_MASK |
+			  PCH_CMASK_ARB | PCH_CMASK_CTRL,
 			  &priv->regs->if1_cmask);
 		pch_can_check_if_busy(&priv->regs->if1_creq, i+1);
 	}
 
 	for (i = i;  i < PCH_OBJ_NUM; i++) {
-		iowrite32(CAN_CMASK_RX_TX_SET, &priv->regs->if2_cmask);
+		iowrite32(PCH_CMASK_RX_TX_SET, &priv->regs->if2_cmask);
 		iowrite32(0xffff, &priv->regs->if2_mask1);
 		iowrite32(0xffff, &priv->regs->if2_mask2);
 		iowrite32(0x0, &priv->regs->if2_id1);
@@ -525,8 +512,8 @@ static void pch_can_clear_buffers(struct pch_can_priv *priv)
 		iowrite32(0x0, &priv->regs->if2_dataa2);
 		iowrite32(0x0, &priv->regs->if2_datab1);
 		iowrite32(0x0, &priv->regs->if2_datab2);
-		iowrite32(CAN_CMASK_RDWR | CAN_CMASK_MASK |
-			  CAN_CMASK_ARB | CAN_CMASK_CTRL,
+		iowrite32(PCH_CMASK_RDWR | PCH_CMASK_MASK |
+			  PCH_CMASK_ARB | PCH_CMASK_CTRL,
 			  &priv->regs->if2_cmask);
 		pch_can_check_if_busy(&priv->regs->if2_creq, i+1);
 	}
@@ -540,8 +527,8 @@ static void pch_can_config_rx_tx_buffers(struct pch_can_priv *priv)
 	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
 
 	for (i = 0; i < PCH_OBJ_NUM; i++) {
-		if (priv->msg_obj[i] == MSG_OBJ_RX) {
-			iowrite32(CAN_CMASK_RX_TX_GET,
+		if (priv->msg_obj[i] == PCH_MSG_OBJ_RX) {
+			iowrite32(PCH_CMASK_RX_TX_GET,
 				&priv->regs->if1_cmask);
 			pch_can_check_if_busy(&priv->regs->if1_creq, i+1);
 
@@ -549,48 +536,48 @@ static void pch_can_config_rx_tx_buffers(struct pch_can_priv *priv)
 			iowrite32(0x0, &priv->regs->if1_id2);
 
 			pch_can_bit_set(&priv->regs->if1_mcont,
-					CAN_IF_MCONT_UMASK);
+					PCH_IF_MCONT_UMASK);
 
 			/* Set FIFO mode set to 0 except last Rx Obj*/
 			pch_can_bit_clear(&priv->regs->if1_mcont,
-					  CAN_IF_MCONT_EOB);
+					  PCH_IF_MCONT_EOB);
 			/* In case FIFO mode, Last EoB of Rx Obj must be 1 */
 			if (i == (PCH_RX_OBJ_NUM - 1))
 				pch_can_bit_set(&priv->regs->if1_mcont,
-						  CAN_IF_MCONT_EOB);
+						  PCH_IF_MCONT_EOB);
 
 			iowrite32(0, &priv->regs->if1_mask1);
 			pch_can_bit_clear(&priv->regs->if1_mask2,
-					  0x1fff | CAN_MASK2_MDIR_MXTD);
+					  0x1fff | PCH_MASK2_MDIR_MXTD);
 
 			/* Setting CMASK for writing */
-			iowrite32(CAN_CMASK_RDWR | CAN_CMASK_MASK |
-				  CAN_CMASK_ARB | CAN_CMASK_CTRL,
+			iowrite32(PCH_CMASK_RDWR | PCH_CMASK_MASK |
+				  PCH_CMASK_ARB | PCH_CMASK_CTRL,
 				  &priv->regs->if1_cmask);
 
 			pch_can_check_if_busy(&priv->regs->if1_creq, i+1);
-		} else if (priv->msg_obj[i] == MSG_OBJ_TX) {
-			iowrite32(CAN_CMASK_RX_TX_GET,
+		} else if (priv->msg_obj[i] == PCH_MSG_OBJ_TX) {
+			iowrite32(PCH_CMASK_RX_TX_GET,
 				&priv->regs->if2_cmask);
 			pch_can_check_if_busy(&priv->regs->if2_creq, i+1);
 
 			/* Resetting DIR bit for reception */
 			iowrite32(0x0, &priv->regs->if2_id1);
 			iowrite32(0x0, &priv->regs->if2_id2);
-			pch_can_bit_set(&priv->regs->if2_id2, CAN_ID2_DIR);
+			pch_can_bit_set(&priv->regs->if2_id2, PCH_ID2_DIR);
 
 			/* Setting EOB bit for transmitter */
-			iowrite32(CAN_IF_MCONT_EOB, &priv->regs->if2_mcont);
+			iowrite32(PCH_IF_MCONT_EOB, &priv->regs->if2_mcont);
 
 			pch_can_bit_set(&priv->regs->if2_mcont,
-					CAN_IF_MCONT_UMASK);
+					PCH_IF_MCONT_UMASK);
 
 			iowrite32(0, &priv->regs->if2_mask1);
 			pch_can_bit_clear(&priv->regs->if2_mask2, 0x1fff);
 
 			/* Setting CMASK for writing */
-			iowrite32(CAN_CMASK_RDWR | CAN_CMASK_MASK |
-				  CAN_CMASK_ARB | CAN_CMASK_CTRL,
+			iowrite32(PCH_CMASK_RDWR | PCH_CMASK_MASK |
+				  PCH_CMASK_ARB | PCH_CMASK_CTRL,
 				  &priv->regs->if2_cmask);
 
 			pch_can_check_if_busy(&priv->regs->if2_creq, i+1);
@@ -632,39 +619,39 @@ static void pch_can_release(struct pch_can_priv *priv)
 /* This function clears interrupt(s) from the CAN device. */
 static void pch_can_int_clr(struct pch_can_priv *priv, u32 mask)
 {
-	if (mask == CAN_STATUS_INT) {
+	if (mask == PCH_STATUS_INT) {
 		ioread32(&priv->regs->stat);
 		return;
 	}
 
 	/* Clear interrupt for transmit object */
-	if (priv->msg_obj[mask - 1] == MSG_OBJ_TX) {
+	if (priv->msg_obj[mask - 1] == PCH_MSG_OBJ_TX) {
 		/* Setting CMASK for clearing interrupts for
 					 frame transmission. */
-		iowrite32(CAN_CMASK_RDWR | CAN_CMASK_CTRL | CAN_CMASK_ARB,
+		iowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL | PCH_CMASK_ARB,
 			  &priv->regs->if2_cmask);
 
 		/* Resetting the ID registers. */
 		pch_can_bit_set(&priv->regs->if2_id2,
-			       CAN_ID2_DIR | (0x7ff << 2));
+			       PCH_ID2_DIR | (0x7ff << 2));
 		iowrite32(0x0, &priv->regs->if2_id1);
 
 		/* Claring NewDat, TxRqst & IntPnd */
 		pch_can_bit_clear(&priv->regs->if2_mcont,
-				  CAN_IF_MCONT_NEWDAT | CAN_IF_MCONT_INTPND |
-				  CAN_IF_MCONT_TXRQXT);
+				  PCH_IF_MCONT_NEWDAT | PCH_IF_MCONT_INTPND |
+				  PCH_IF_MCONT_TXRQXT);
 		pch_can_check_if_busy(&priv->regs->if2_creq, mask);
-	} else if (priv->msg_obj[mask - 1] == MSG_OBJ_RX) {
+	} else if (priv->msg_obj[mask - 1] == PCH_MSG_OBJ_RX) {
 		/* Setting CMASK for clearing the reception interrupts. */
-		iowrite32(CAN_CMASK_RDWR | CAN_CMASK_CTRL | CAN_CMASK_ARB,
+		iowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL | PCH_CMASK_ARB,
 			  &priv->regs->if1_cmask);
 
 		/* Clearing the Dir bit. */
-		pch_can_bit_clear(&priv->regs->if1_id2, CAN_ID2_DIR);
+		pch_can_bit_clear(&priv->regs->if1_id2, PCH_ID2_DIR);
 
 		/* Clearing NewDat & IntPnd */
 		pch_can_bit_clear(&priv->regs->if1_mcont,
-				  CAN_IF_MCONT_NEWDAT | CAN_IF_MCONT_INTPND);
+				  PCH_IF_MCONT_NEWDAT | PCH_IF_MCONT_INTPND);
 
 		pch_can_check_if_busy(&priv->regs->if1_creq, mask);
 	}
@@ -712,9 +699,9 @@ static void pch_can_error(struct net_device *ndev, u32 status)
 		priv->can.can_stats.error_warning++;
 		cf->can_id |= CAN_ERR_CRTL;
 		errc = ioread32(&priv->regs->errc);
-		if (((errc & CAN_REC) >> 8) > 96)
+		if (((errc & PCH_REC) >> 8) > 96)
 			cf->data[1] |= CAN_ERR_CRTL_RX_WARNING;
-		if ((errc & CAN_TEC) > 96)
+		if ((errc & PCH_TEC) > 96)
 			cf->data[1] |= CAN_ERR_CRTL_TX_WARNING;
 		dev_warn(&ndev->dev,
 			"%s -> Error Counter is more than 96.\n", __func__);
@@ -725,9 +712,9 @@ static void pch_can_error(struct net_device *ndev, u32 status)
 		state = CAN_STATE_ERROR_PASSIVE;
 		cf->can_id |= CAN_ERR_CRTL;
 		errc = ioread32(&priv->regs->errc);
-		if (((errc & CAN_REC) >> 8) > 127)
+		if (((errc & PCH_REC) >> 8) > 127)
 			cf->data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
-		if ((errc & CAN_TEC) > 127)
+		if ((errc & PCH_TEC) > 127)
 			cf->data[1] |= CAN_ERR_CRTL_TX_PASSIVE;
 		dev_err(&ndev->dev,
 			"%s -> CAN controller is ERROR PASSIVE .\n", __func__);
@@ -795,20 +782,20 @@ static int pch_can_rx_normal(struct net_device *ndev, u32 int_stat)
 	struct net_device_stats *stats = &(priv->ndev->stats);
 
 	/* Reading the messsage object from the Message RAM */
-	iowrite32(CAN_CMASK_RX_TX_GET, &priv->regs->if1_cmask);
+	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->if1_cmask);
 	pch_can_check_if_busy(&priv->regs->if1_creq, int_stat);
 
 	/* Reading the MCONT register. */
 	reg = ioread32(&priv->regs->if1_mcont);
 	reg &= 0xffff;
 
-	for (k = int_stat; !(reg & CAN_IF_MCONT_EOB); k++) {
+	for (k = int_stat; !(reg & PCH_IF_MCONT_EOB); k++) {
 		/* If MsgLost bit set. */
-		if (reg & CAN_IF_MCONT_MSGLOST) {
+		if (reg & PCH_IF_MCONT_MSGLOST) {
 			dev_err(&priv->ndev->dev, "Msg Obj is overwritten.\n");
 			pch_can_bit_clear(&priv->regs->if1_mcont,
-					  CAN_IF_MCONT_MSGLOST);
-			iowrite32(CAN_CMASK_RDWR | CAN_CMASK_CTRL,
+					  PCH_IF_MCONT_MSGLOST);
+			iowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL,
 				  &priv->regs->if1_cmask);
 			pch_can_check_if_busy(&priv->regs->if1_creq, k);
 
@@ -828,7 +815,7 @@ static int pch_can_rx_normal(struct net_device *ndev, u32 int_stat)
 			rcv_pkts++;
 			goto RX_NEXT;
 		}
-		if (!(reg & CAN_IF_MCONT_NEWDAT))
+		if (!(reg & PCH_IF_MCONT_NEWDAT))
 			goto RX_NEXT;
 
 		skb = alloc_can_skb(priv->ndev, &cf);
@@ -836,7 +823,7 @@ static int pch_can_rx_normal(struct net_device *ndev, u32 int_stat)
 			return -ENOMEM;
 
 		/* Get Received data */
-		ide = ((ioread32(&priv->regs->if1_id2)) & CAN_ID2_XTD) >> 14;
+		ide = ((ioread32(&priv->regs->if1_id2)) & PCH_ID2_XTD) >> 14;
 		if (ide) {
 			id = (ioread32(&priv->regs->if1_id1) & 0xffff);
 			id |= (((ioread32(&priv->regs->if1_id2)) &
@@ -848,7 +835,7 @@ static int pch_can_rx_normal(struct net_device *ndev, u32 int_stat)
 			cf->can_id = (id & CAN_SFF_MASK);
 		}
 
-		rtr = (ioread32(&priv->regs->if1_id2) &  CAN_ID2_DIR);
+		rtr = (ioread32(&priv->regs->if1_id2) &  PCH_ID2_DIR);
 		if (rtr) {
 			cf->can_dlc = 0;
 			cf->can_id |= CAN_RTR_FLAG;
@@ -871,15 +858,15 @@ static int pch_can_rx_normal(struct net_device *ndev, u32 int_stat)
 		stats->rx_bytes += cf->can_dlc;
 
 		if (k < PCH_FIFO_THRESH) {
-			iowrite32(CAN_CMASK_RDWR | CAN_CMASK_CTRL |
-				  CAN_CMASK_ARB, &priv->regs->if1_cmask);
+			iowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL |
+				  PCH_CMASK_ARB, &priv->regs->if1_cmask);
 
 			/* Clearing the Dir bit. */
-			pch_can_bit_clear(&priv->regs->if1_id2, CAN_ID2_DIR);
+			pch_can_bit_clear(&priv->regs->if1_id2, PCH_ID2_DIR);
 
 			/* Clearing NewDat & IntPnd */
 			pch_can_bit_clear(&priv->regs->if1_mcont,
-					  CAN_IF_MCONT_INTPND);
+					  PCH_IF_MCONT_INTPND);
 			pch_can_check_if_busy(&priv->regs->if1_creq, k);
 		} else if (k > PCH_FIFO_THRESH) {
 			pch_can_int_clr(priv, k);
@@ -890,7 +877,7 @@ static int pch_can_rx_normal(struct net_device *ndev, u32 int_stat)
 		}
 RX_NEXT:
 		/* Reading the messsage object from the Message RAM */
-		iowrite32(CAN_CMASK_RX_TX_GET, &priv->regs->if1_cmask);
+		iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->if1_cmask);
 		pch_can_check_if_busy(&priv->regs->if1_creq, k + 1);
 		reg = ioread32(&priv->regs->if1_mcont);
 	}
@@ -913,7 +900,7 @@ static int pch_can_rx_poll(struct napi_struct *napi, int quota)
 		return 0;
 
 INT_STAT:
-	if (int_stat == CAN_STATUS_INT) {
+	if (int_stat == PCH_STATUS_INT) {
 		reg_stat = ioread32(&priv->regs->stat);
 		if (reg_stat & (PCH_BUS_OFF | PCH_LEC_ALL)) {
 			if ((reg_stat & PCH_LEC_ALL) != PCH_LEC_ALL)
@@ -922,7 +909,7 @@ static int pch_can_rx_poll(struct napi_struct *napi, int quota)
 
 		if (reg_stat & PCH_TX_OK) {
 			spin_lock_irqsave(&priv->msgif_reg_lock, flags);
-			iowrite32(CAN_CMASK_RX_TX_GET, &priv->regs->if2_cmask);
+			iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->if2_cmask);
 			pch_can_check_if_busy(&priv->regs->if2_creq,
 					       ioread32(&priv->regs->intr));
 			spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
@@ -933,7 +920,7 @@ static int pch_can_rx_poll(struct napi_struct *napi, int quota)
 			pch_can_bit_clear(&priv->regs->stat, PCH_RX_OK);
 
 		int_stat = pch_can_int_pending(priv);
-		if (int_stat == CAN_STATUS_INT)
+		if (int_stat == PCH_STATUS_INT)
 			goto INT_STAT;
 	}
 
@@ -945,14 +932,14 @@ static int pch_can_rx_poll(struct napi_struct *napi, int quota)
 		if (rcv_pkts < 0)
 			return 0;
 	} else if ((int_stat > PCH_RX_OBJ_NUM) && (int_stat <= PCH_OBJ_NUM)) {
-		if (priv->msg_obj[int_stat - 1] == MSG_OBJ_TX) {
+		if (priv->msg_obj[int_stat - 1] == PCH_MSG_OBJ_TX) {
 			/* Handle transmission interrupt */
 			can_get_echo_skb(ndev, int_stat - PCH_RX_OBJ_NUM - 1);
 			spin_lock_irqsave(&priv->msgif_reg_lock, flags);
-			iowrite32(CAN_CMASK_RX_TX_GET | CAN_CMASK_CLRINTPND,
+			iowrite32(PCH_CMASK_RX_TX_GET | PCH_CMASK_CLRINTPND,
 				  &priv->regs->if2_cmask);
 			dlc = ioread32(&priv->regs->if2_mcont) &
-				       CAN_IF_MCONT_DLC;
+				       PCH_IF_MCONT_DLC;
 			pch_can_check_if_busy(&priv->regs->if2_creq, int_stat);
 			spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
 			if (dlc > 8)
@@ -963,7 +950,7 @@ static int pch_can_rx_poll(struct napi_struct *napi, int quota)
 	}
 
 	int_stat = pch_can_int_pending(priv);
-	if (int_stat == CAN_STATUS_INT)
+	if (int_stat == PCH_STATUS_INT)
 		goto INT_STAT;
 	else if (int_stat >= 1 && int_stat <= 32)
 		goto MSG_OBJ;
@@ -983,17 +970,17 @@ static int pch_set_bittiming(struct net_device *ndev)
 	u32 brp;
 
 	/* Setting the CCE bit for accessing the Can Timing register. */
-	pch_can_bit_set(&priv->regs->cont, CAN_CTRL_CCE);
+	pch_can_bit_set(&priv->regs->cont, PCH_CTRL_CCE);
 
 	brp = (bt->tq) / (1000000000/PCH_CAN_CLK) - 1;
-	canbit = brp & MSK_BITT_BRP;
-	canbit |= (bt->sjw - 1) << BIT_BITT_SJW;
-	canbit |= (bt->phase_seg1 + bt->prop_seg - 1) << BIT_BITT_TSEG1;
-	canbit |= (bt->phase_seg2 - 1) << BIT_BITT_TSEG2;
-	bepe = (brp & MSK_BRPE_BRPE) >> BIT_BRPE_BRPE;
+	canbit = brp & PCH_MSK_BITT_BRP;
+	canbit |= (bt->sjw - 1) << PCH_BIT_SJW;
+	canbit |= (bt->phase_seg1 + bt->prop_seg - 1) << PCH_BIT_TSEG1;
+	canbit |= (bt->phase_seg2 - 1) << PCH_BIT_TSEG2;
+	bepe = (brp & PCH_MSK_BRPE_BRPE) >> PCH_BIT_BRPE_BRPE;
 	iowrite32(canbit, &priv->regs->bitt);
 	iowrite32(bepe, &priv->regs->brpe);
-	pch_can_bit_clear(&priv->regs->cont, CAN_CTRL_CCE);
+	pch_can_bit_clear(&priv->regs->cont, PCH_CTRL_CCE);
 
 	return 0;
 }
@@ -1137,19 +1124,19 @@ static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
 	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
 
 	/* Reading the Msg Obj from the Msg RAM to the Interface register. */
-	iowrite32(CAN_CMASK_RX_TX_GET, &priv->regs->if2_cmask);
+	iowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->if2_cmask);
 	pch_can_check_if_busy(&priv->regs->if2_creq, tx_buffer_avail);
 
 	/* Setting the CMASK register. */
-	pch_can_bit_set(&priv->regs->if2_cmask, CAN_CMASK_ALL);
+	pch_can_bit_set(&priv->regs->if2_cmask, PCH_CMASK_ALL);
 
 	/* If ID extended is set. */
 	pch_can_bit_clear(&priv->regs->if2_id1, 0xffff);
-	pch_can_bit_clear(&priv->regs->if2_id2, 0x1fff | CAN_ID2_XTD);
+	pch_can_bit_clear(&priv->regs->if2_id2, 0x1fff | PCH_ID2_XTD);
 	if (cf->can_id & CAN_EFF_FLAG) {
 		pch_can_bit_set(&priv->regs->if2_id1, cf->can_id & 0xffff);
 		pch_can_bit_set(&priv->regs->if2_id2,
-				((cf->can_id >> 16) & 0x1fff) | CAN_ID2_XTD);
+				((cf->can_id >> 16) & 0x1fff) | PCH_ID2_XTD);
 	} else {
 		pch_can_bit_set(&priv->regs->if2_id1, 0);
 		pch_can_bit_set(&priv->regs->if2_id2,
@@ -1158,7 +1145,7 @@ static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
 
 	/* If remote frame has to be transmitted.. */
 	if (cf->can_id & CAN_RTR_FLAG)
-		pch_can_bit_clear(&priv->regs->if2_id2, CAN_ID2_DIR);
+		pch_can_bit_clear(&priv->regs->if2_id2, PCH_ID2_DIR);
 
 	for (i = 0, j = 0; i < cf->can_dlc; j++) {
 		iowrite32(le32_to_cpu(cf->data[i++]),
@@ -1177,12 +1164,12 @@ static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
 
 	/* Clearing IntPend, NewDat & TxRqst */
 	pch_can_bit_clear(&priv->regs->if2_mcont,
-			  CAN_IF_MCONT_NEWDAT | CAN_IF_MCONT_INTPND |
-			  CAN_IF_MCONT_TXRQXT);
+			  PCH_IF_MCONT_NEWDAT | PCH_IF_MCONT_INTPND |
+			  PCH_IF_MCONT_TXRQXT);
 
 	/* Setting NewDat, TxRqst bits */
 	pch_can_bit_set(&priv->regs->if2_mcont,
-			CAN_IF_MCONT_NEWDAT | CAN_IF_MCONT_TXRQXT);
+			PCH_IF_MCONT_NEWDAT | PCH_IF_MCONT_TXRQXT);
 
 	pch_can_check_if_busy(&priv->regs->if2_creq, tx_buffer_avail);
 
@@ -1245,7 +1232,7 @@ static int pch_can_suspend(struct pci_dev *pdev, pm_message_t state)
 
 	/* Save Tx buffer enable state */
 	for (i = 0; i < PCH_OBJ_NUM; i++) {
-		if (priv->msg_obj[i] == MSG_OBJ_TX)
+		if (priv->msg_obj[i] == PCH_MSG_OBJ_TX)
 			pch_can_get_tx_enable(priv, i + 1,
 					      &(priv->tx_enable[i]));
 	}
@@ -1255,7 +1242,7 @@ static int pch_can_suspend(struct pci_dev *pdev, pm_message_t state)
 
 	/* Save Rx buffer enable state */
 	for (i = 0; i < PCH_OBJ_NUM; i++) {
-		if (priv->msg_obj[i] == MSG_OBJ_RX) {
+		if (priv->msg_obj[i] == PCH_MSG_OBJ_RX) {
 			pch_can_get_rx_enable(priv, i + 1,
 						&(priv->rx_enable[i]));
 			pch_can_get_rx_buffer_link(priv, i + 1,
@@ -1313,7 +1300,7 @@ static int pch_can_resume(struct pci_dev *pdev)
 
 	/* Enabling the transmit buffer. */
 	for (i = 0; i < PCH_OBJ_NUM; i++) {
-		if (priv->msg_obj[i] == MSG_OBJ_TX) {
+		if (priv->msg_obj[i] == PCH_MSG_OBJ_TX) {
 			pch_can_set_tx_enable(priv, i + 1,
 					      priv->tx_enable[i]);
 		}
@@ -1321,7 +1308,7 @@ static int pch_can_resume(struct pci_dev *pdev)
 
 	/* Configuring the receive buffer and enabling them. */
 	for (i = 0; i < PCH_OBJ_NUM; i++) {
-		if (priv->msg_obj[i] == MSG_OBJ_RX) {
+		if (priv->msg_obj[i] == PCH_MSG_OBJ_RX) {
 			/* Restore buffer link */
 			pch_can_set_rx_buffer_link(priv, i + 1,
 						   priv->rx_link[i]);
@@ -1349,8 +1336,8 @@ static int pch_can_get_berr_counter(const struct net_device *dev,
 {
 	struct pch_can_priv *priv = netdev_priv(dev);
 
-	bec->txerr = ioread32(&priv->regs->errc) & CAN_TEC;
-	bec->rxerr = (ioread32(&priv->regs->errc) & CAN_REC) >> 8;
+	bec->txerr = ioread32(&priv->regs->errc) & PCH_TEC;
+	bec->rxerr = (ioread32(&priv->regs->errc) & PCH_REC) >> 8;
 
 	return 0;
 }
@@ -1410,10 +1397,10 @@ static int __devinit pch_can_probe(struct pci_dev *pdev,
 
 	priv->can.clock.freq = PCH_CAN_CLK; /* Hz */
 	for (index = 0; index < PCH_RX_OBJ_NUM;)
-		priv->msg_obj[index++] = MSG_OBJ_RX;
+		priv->msg_obj[index++] = PCH_MSG_OBJ_RX;
 
 	for (index = index;  index < PCH_OBJ_NUM;)
-		priv->msg_obj[index++] = MSG_OBJ_TX;
+		priv->msg_obj[index++] = PCH_MSG_OBJ_TX;
 
 	netif_napi_add(ndev, &priv->napi, pch_can_rx_poll, PCH_RX_OBJ_NUM);
 

commit bdfa3d8fe123a940be121daf374581727b3b6547
Author: Marc Kleine-Budde <mkl@pengutronix.de>
Date:   Sat Oct 30 16:28:16 2010 -0700

    can: pch_can: fix section mismatch warning by using a whitelisted name
    
    This patch fixes the following section mismatch warning:
    
    WARNING: drivers/net/can/pch_can.o(.data+0x18):
    Section mismatch in reference from the variable pch_can_pcidev
    to the variable .devinit.rodata:pch_pci_tbl
    The variable pch_can_pcidev references
    the variable __devinitconst pch_pci_tbl
    
    This is actually a false positive which is fixed by giving the offending
    variable a whitelisted name, it's renamed to "pch_can_pci_driver".
    This makes sense because the variable is of the type "struct pci_driver".
    
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Acked-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index c63209f4e73c..672718261c68 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -1437,7 +1437,7 @@ static int __devinit pch_can_probe(struct pci_dev *pdev,
 	return rc;
 }
 
-static struct pci_driver pch_can_pcidev = {
+static struct pci_driver pch_can_pci_driver = {
 	.name = "pch_can",
 	.id_table = pch_pci_tbl,
 	.probe = pch_can_probe,
@@ -1448,13 +1448,13 @@ static struct pci_driver pch_can_pcidev = {
 
 static int __init pch_can_pci_init(void)
 {
-	return pci_register_driver(&pch_can_pcidev);
+	return pci_register_driver(&pch_can_pci_driver);
 }
 module_init(pch_can_pci_init);
 
 static void __exit pch_can_pci_exit(void)
 {
-	pci_unregister_driver(&pch_can_pcidev);
+	pci_unregister_driver(&pch_can_pci_driver);
 }
 module_exit(pch_can_pci_exit);
 

commit 526de53cf78d325351904eefb9624f933924df75
Author: Marc Kleine-Budde <mkl@pengutronix.de>
Date:   Sat Oct 30 16:27:48 2010 -0700

    can: pch_can: fix sparse warning
    
    This patch fixes the following sparse warning:
    
    drivers/net/can/pch_can.c:231:26: warning: incorrect type in argument 1 (different address spaces)
    drivers/net/can/pch_can.c:231:26:    expected unsigned int [usertype] *addr
    drivers/net/can/pch_can.c:231:26:    got unsigned int [noderef] <asn:2>*<noident>
    
    Let pch_can_bit_{set,clear} first parameter be a void __iomem pointer.
    
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
index 55ec324caaf4..c63209f4e73c 100644
--- a/drivers/net/can/pch_can.c
+++ b/drivers/net/can/pch_can.c
@@ -213,12 +213,12 @@ static DEFINE_PCI_DEVICE_TABLE(pch_pci_tbl) = {
 };
 MODULE_DEVICE_TABLE(pci, pch_pci_tbl);
 
-static inline void pch_can_bit_set(u32 *addr, u32 mask)
+static inline void pch_can_bit_set(void __iomem *addr, u32 mask)
 {
 	iowrite32(ioread32(addr) | mask, addr);
 }
 
-static inline void pch_can_bit_clear(u32 *addr, u32 mask)
+static inline void pch_can_bit_clear(void __iomem *addr, u32 mask)
 {
 	iowrite32(ioread32(addr) & ~mask, addr);
 }

commit b21d18b51b31a24d17f883b678432fbdee3d5675
Author: Masayuki Ohtake <masa-korg@dsn.okisemi.com>
Date:   Fri Oct 15 03:00:28 2010 +0000

    can: Topcliff: Add PCH_CAN driver.
    
    CAN driver of Topcliff PCH
    
    Topcliff PCH is the platform controller hub that is going to be used in
    Intel's upcoming general embedded platform. All IO peripherals in
    Topcliff PCH are actually devices sitting on AMBA bus.
    Topcliff PCH has CAN I/F. This driver enables CAN function.
    
    Signed-off-by: Masayuki Ohtake <masa-korg@dsn.okisemi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
new file mode 100644
index 000000000000..55ec324caaf4
--- /dev/null
+++ b/drivers/net/can/pch_can.c
@@ -0,0 +1,1463 @@
+/*
+ * Copyright (C) 1999 - 2010 Intel Corporation.
+ * Copyright (C) 2010 OKI SEMICONDUCTOR Co., LTD.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/can.h>
+#include <linux/can/dev.h>
+#include <linux/can/error.h>
+
+#define MAX_MSG_OBJ		32
+#define MSG_OBJ_RX		0 /* The receive message object flag. */
+#define MSG_OBJ_TX		1 /* The transmit message object flag. */
+
+#define ENABLE			1 /* The enable flag */
+#define DISABLE			0 /* The disable flag */
+#define CAN_CTRL_INIT		0x0001 /* The INIT bit of CANCONT register. */
+#define CAN_CTRL_IE		0x0002 /* The IE bit of CAN control register */
+#define CAN_CTRL_IE_SIE_EIE	0x000e
+#define CAN_CTRL_CCE		0x0040
+#define CAN_CTRL_OPT		0x0080 /* The OPT bit of CANCONT register. */
+#define CAN_OPT_SILENT		0x0008 /* The Silent bit of CANOPT reg. */
+#define CAN_OPT_LBACK		0x0010 /* The LoopBack bit of CANOPT reg. */
+#define CAN_CMASK_RX_TX_SET	0x00f3
+#define CAN_CMASK_RX_TX_GET	0x0073
+#define CAN_CMASK_ALL		0xff
+#define CAN_CMASK_RDWR		0x80
+#define CAN_CMASK_ARB		0x20
+#define CAN_CMASK_CTRL		0x10
+#define CAN_CMASK_MASK		0x40
+#define CAN_CMASK_NEWDAT	0x04
+#define CAN_CMASK_CLRINTPND	0x08
+
+#define CAN_IF_MCONT_NEWDAT	0x8000
+#define CAN_IF_MCONT_INTPND	0x2000
+#define CAN_IF_MCONT_UMASK	0x1000
+#define CAN_IF_MCONT_TXIE	0x0800
+#define CAN_IF_MCONT_RXIE	0x0400
+#define CAN_IF_MCONT_RMTEN	0x0200
+#define CAN_IF_MCONT_TXRQXT	0x0100
+#define CAN_IF_MCONT_EOB	0x0080
+#define CAN_IF_MCONT_DLC	0x000f
+#define CAN_IF_MCONT_MSGLOST	0x4000
+#define CAN_MASK2_MDIR_MXTD	0xc000
+#define CAN_ID2_DIR		0x2000
+#define CAN_ID_MSGVAL		0x8000
+
+#define CAN_STATUS_INT		0x8000
+#define CAN_IF_CREQ_BUSY	0x8000
+#define CAN_ID2_XTD		0x4000
+
+#define CAN_REC			0x00007f00
+#define CAN_TEC			0x000000ff
+
+#define PCH_RX_OK		0x00000010
+#define PCH_TX_OK		0x00000008
+#define PCH_BUS_OFF		0x00000080
+#define PCH_EWARN		0x00000040
+#define PCH_EPASSIV		0x00000020
+#define PCH_LEC0		0x00000001
+#define PCH_LEC1		0x00000002
+#define PCH_LEC2		0x00000004
+#define PCH_LEC_ALL		(PCH_LEC0 | PCH_LEC1 | PCH_LEC2)
+#define PCH_STUF_ERR		PCH_LEC0
+#define PCH_FORM_ERR		PCH_LEC1
+#define PCH_ACK_ERR		(PCH_LEC0 | PCH_LEC1)
+#define PCH_BIT1_ERR		PCH_LEC2
+#define PCH_BIT0_ERR		(PCH_LEC0 | PCH_LEC2)
+#define PCH_CRC_ERR		(PCH_LEC1 | PCH_LEC2)
+
+/* bit position of certain controller bits. */
+#define BIT_BITT_BRP		0
+#define BIT_BITT_SJW		6
+#define BIT_BITT_TSEG1		8
+#define BIT_BITT_TSEG2		12
+#define BIT_IF1_MCONT_RXIE	10
+#define BIT_IF2_MCONT_TXIE	11
+#define BIT_BRPE_BRPE		6
+#define BIT_ES_TXERRCNT		0
+#define BIT_ES_RXERRCNT		8
+#define MSK_BITT_BRP		0x3f
+#define MSK_BITT_SJW		0xc0
+#define MSK_BITT_TSEG1		0xf00
+#define MSK_BITT_TSEG2		0x7000
+#define MSK_BRPE_BRPE		0x3c0
+#define MSK_BRPE_GET		0x0f
+#define MSK_CTRL_IE_SIE_EIE	0x07
+#define MSK_MCONT_TXIE		0x08
+#define MSK_MCONT_RXIE		0x10
+#define PCH_CAN_NO_TX_BUFF	1
+#define COUNTER_LIMIT		10
+
+#define PCH_CAN_CLK		50000000	/* 50MHz */
+
+/* Define the number of message object.
+ * PCH CAN communications are done via Message RAM.
+ * The Message RAM consists of 32 message objects. */
+#define PCH_RX_OBJ_NUM		26  /* 1~ PCH_RX_OBJ_NUM is Rx*/
+#define PCH_TX_OBJ_NUM		6  /* PCH_RX_OBJ_NUM is RX ~ Tx*/
+#define PCH_OBJ_NUM		(PCH_TX_OBJ_NUM + PCH_RX_OBJ_NUM)
+
+#define PCH_FIFO_THRESH		16
+
+enum pch_can_mode {
+	PCH_CAN_ENABLE,
+	PCH_CAN_DISABLE,
+	PCH_CAN_ALL,
+	PCH_CAN_NONE,
+	PCH_CAN_STOP,
+	PCH_CAN_RUN
+};
+
+struct pch_can_regs {
+	u32 cont;
+	u32 stat;
+	u32 errc;
+	u32 bitt;
+	u32 intr;
+	u32 opt;
+	u32 brpe;
+	u32 reserve1;
+	u32 if1_creq;
+	u32 if1_cmask;
+	u32 if1_mask1;
+	u32 if1_mask2;
+	u32 if1_id1;
+	u32 if1_id2;
+	u32 if1_mcont;
+	u32 if1_dataa1;
+	u32 if1_dataa2;
+	u32 if1_datab1;
+	u32 if1_datab2;
+	u32 reserve2;
+	u32 reserve3[12];
+	u32 if2_creq;
+	u32 if2_cmask;
+	u32 if2_mask1;
+	u32 if2_mask2;
+	u32 if2_id1;
+	u32 if2_id2;
+	u32 if2_mcont;
+	u32 if2_dataa1;
+	u32 if2_dataa2;
+	u32 if2_datab1;
+	u32 if2_datab2;
+	u32 reserve4;
+	u32 reserve5[20];
+	u32 treq1;
+	u32 treq2;
+	u32 reserve6[2];
+	u32 reserve7[56];
+	u32 reserve8[3];
+	u32 srst;
+};
+
+struct pch_can_priv {
+	struct can_priv can;
+	unsigned int can_num;
+	struct pci_dev *dev;
+	unsigned int tx_enable[MAX_MSG_OBJ];
+	unsigned int rx_enable[MAX_MSG_OBJ];
+	unsigned int rx_link[MAX_MSG_OBJ];
+	unsigned int int_enables;
+	unsigned int int_stat;
+	struct net_device *ndev;
+	spinlock_t msgif_reg_lock; /* Message Interface Registers Access Lock*/
+	unsigned int msg_obj[MAX_MSG_OBJ];
+	struct pch_can_regs __iomem *regs;
+	struct napi_struct napi;
+	unsigned int tx_obj;	/* Point next Tx Obj index */
+	unsigned int use_msi;
+};
+
+static struct can_bittiming_const pch_can_bittiming_const = {
+	.name = KBUILD_MODNAME,
+	.tseg1_min = 1,
+	.tseg1_max = 16,
+	.tseg2_min = 1,
+	.tseg2_max = 8,
+	.sjw_max = 4,
+	.brp_min = 1,
+	.brp_max = 1024, /* 6bit + extended 4bit */
+	.brp_inc = 1,
+};
+
+static DEFINE_PCI_DEVICE_TABLE(pch_pci_tbl) = {
+	{PCI_VENDOR_ID_INTEL, 0x8818, PCI_ANY_ID, PCI_ANY_ID,},
+	{0,}
+};
+MODULE_DEVICE_TABLE(pci, pch_pci_tbl);
+
+static inline void pch_can_bit_set(u32 *addr, u32 mask)
+{
+	iowrite32(ioread32(addr) | mask, addr);
+}
+
+static inline void pch_can_bit_clear(u32 *addr, u32 mask)
+{
+	iowrite32(ioread32(addr) & ~mask, addr);
+}
+
+static void pch_can_set_run_mode(struct pch_can_priv *priv,
+				 enum pch_can_mode mode)
+{
+	switch (mode) {
+	case PCH_CAN_RUN:
+		pch_can_bit_clear(&priv->regs->cont, CAN_CTRL_INIT);
+		break;
+
+	case PCH_CAN_STOP:
+		pch_can_bit_set(&priv->regs->cont, CAN_CTRL_INIT);
+		break;
+
+	default:
+		dev_err(&priv->ndev->dev, "%s -> Invalid Mode.\n", __func__);
+		break;
+	}
+}
+
+static void pch_can_set_optmode(struct pch_can_priv *priv)
+{
+	u32 reg_val = ioread32(&priv->regs->opt);
+
+	if (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)
+		reg_val |= CAN_OPT_SILENT;
+
+	if (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)
+		reg_val |= CAN_OPT_LBACK;
+
+	pch_can_bit_set(&priv->regs->cont, CAN_CTRL_OPT);
+	iowrite32(reg_val, &priv->regs->opt);
+}
+
+static void pch_can_set_int_custom(struct pch_can_priv *priv)
+{
+	/* Clearing the IE, SIE and EIE bits of Can control register. */
+	pch_can_bit_clear(&priv->regs->cont, CAN_CTRL_IE_SIE_EIE);
+
+	/* Appropriately setting them. */
+	pch_can_bit_set(&priv->regs->cont,
+			((priv->int_enables & MSK_CTRL_IE_SIE_EIE) << 1));
+}
+
+/* This function retrieves interrupt enabled for the CAN device. */
+static void pch_can_get_int_enables(struct pch_can_priv *priv, u32 *enables)
+{
+	/* Obtaining the status of IE, SIE and EIE interrupt bits. */
+	*enables = ((ioread32(&priv->regs->cont) & CAN_CTRL_IE_SIE_EIE) >> 1);
+}
+
+static void pch_can_set_int_enables(struct pch_can_priv *priv,
+				    enum pch_can_mode interrupt_no)
+{
+	switch (interrupt_no) {
+	case PCH_CAN_ENABLE:
+		pch_can_bit_set(&priv->regs->cont, CAN_CTRL_IE);
+		break;
+
+	case PCH_CAN_DISABLE:
+		pch_can_bit_clear(&priv->regs->cont, CAN_CTRL_IE);
+		break;
+
+	case PCH_CAN_ALL:
+		pch_can_bit_set(&priv->regs->cont, CAN_CTRL_IE_SIE_EIE);
+		break;
+
+	case PCH_CAN_NONE:
+		pch_can_bit_clear(&priv->regs->cont, CAN_CTRL_IE_SIE_EIE);
+		break;
+
+	default:
+		dev_err(&priv->ndev->dev, "Invalid interrupt number.\n");
+		break;
+	}
+}
+
+static void pch_can_check_if_busy(u32 __iomem *creq_addr, u32 num)
+{
+	u32 counter = COUNTER_LIMIT;
+	u32 ifx_creq;
+
+	iowrite32(num, creq_addr);
+	while (counter) {
+		ifx_creq = ioread32(creq_addr) & CAN_IF_CREQ_BUSY;
+		if (!ifx_creq)
+			break;
+		counter--;
+		udelay(1);
+	}
+	if (!counter)
+		pr_err("%s:IF1 BUSY Flag is set forever.\n", __func__);
+}
+
+static void pch_can_set_rx_enable(struct pch_can_priv *priv, u32 buff_num,
+				  u32 set)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
+	/* Reading the receive buffer data from RAM to Interface1 registers */
+	iowrite32(CAN_CMASK_RX_TX_GET, &priv->regs->if1_cmask);
+	pch_can_check_if_busy(&priv->regs->if1_creq, buff_num);
+
+	/* Setting the IF1MASK1 register to access MsgVal and RxIE bits */
+	iowrite32(CAN_CMASK_RDWR | CAN_CMASK_ARB | CAN_CMASK_CTRL,
+		  &priv->regs->if1_cmask);
+
+	if (set == ENABLE) {
+		/* Setting the MsgVal and RxIE bits */
+		pch_can_bit_set(&priv->regs->if1_mcont, CAN_IF_MCONT_RXIE);
+		pch_can_bit_set(&priv->regs->if1_id2, CAN_ID_MSGVAL);
+
+	} else if (set == DISABLE) {
+		/* Resetting the MsgVal and RxIE bits */
+		pch_can_bit_clear(&priv->regs->if1_mcont, CAN_IF_MCONT_RXIE);
+		pch_can_bit_clear(&priv->regs->if1_id2, CAN_ID_MSGVAL);
+	}
+
+	pch_can_check_if_busy(&priv->regs->if1_creq, buff_num);
+	spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
+}
+
+static void pch_can_rx_enable_all(struct pch_can_priv *priv)
+{
+	int i;
+
+	/* Traversing to obtain the object configured as receivers. */
+	for (i = 0; i < PCH_OBJ_NUM; i++) {
+		if (priv->msg_obj[i] == MSG_OBJ_RX)
+			pch_can_set_rx_enable(priv, i + 1, ENABLE);
+	}
+}
+
+static void pch_can_rx_disable_all(struct pch_can_priv *priv)
+{
+	int i;
+
+	/* Traversing to obtain the object configured as receivers. */
+	for (i = 0; i < PCH_OBJ_NUM; i++) {
+		if (priv->msg_obj[i] == MSG_OBJ_RX)
+			pch_can_set_rx_enable(priv, i + 1, DISABLE);
+	}
+}
+
+static void pch_can_set_tx_enable(struct pch_can_priv *priv, u32 buff_num,
+				 u32 set)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
+	/* Reading the Msg buffer from Message RAM to Interface2 registers. */
+	iowrite32(CAN_CMASK_RX_TX_GET, &priv->regs->if2_cmask);
+	pch_can_check_if_busy(&priv->regs->if2_creq, buff_num);
+
+	/* Setting the IF2CMASK register for accessing the
+		MsgVal and TxIE bits */
+	iowrite32(CAN_CMASK_RDWR | CAN_CMASK_ARB | CAN_CMASK_CTRL,
+		 &priv->regs->if2_cmask);
+
+	if (set == ENABLE) {
+		/* Setting the MsgVal and TxIE bits */
+		pch_can_bit_set(&priv->regs->if2_mcont, CAN_IF_MCONT_TXIE);
+		pch_can_bit_set(&priv->regs->if2_id2, CAN_ID_MSGVAL);
+	} else if (set == DISABLE) {
+		/* Resetting the MsgVal and TxIE bits. */
+		pch_can_bit_clear(&priv->regs->if2_mcont, CAN_IF_MCONT_TXIE);
+		pch_can_bit_clear(&priv->regs->if2_id2, CAN_ID_MSGVAL);
+	}
+
+	pch_can_check_if_busy(&priv->regs->if2_creq, buff_num);
+	spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
+}
+
+static void pch_can_tx_enable_all(struct pch_can_priv *priv)
+{
+	int i;
+
+	/* Traversing to obtain the object configured as transmit object. */
+	for (i = 0; i < PCH_OBJ_NUM; i++) {
+		if (priv->msg_obj[i] == MSG_OBJ_TX)
+			pch_can_set_tx_enable(priv, i + 1, ENABLE);
+	}
+}
+
+static void pch_can_tx_disable_all(struct pch_can_priv *priv)
+{
+	int i;
+
+	/* Traversing to obtain the object configured as transmit object. */
+	for (i = 0; i < PCH_OBJ_NUM; i++) {
+		if (priv->msg_obj[i] == MSG_OBJ_TX)
+			pch_can_set_tx_enable(priv, i + 1, DISABLE);
+	}
+}
+
+static void pch_can_get_rx_enable(struct pch_can_priv *priv, u32 buff_num,
+				 u32 *enable)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
+	iowrite32(CAN_CMASK_RX_TX_GET, &priv->regs->if1_cmask);
+	pch_can_check_if_busy(&priv->regs->if1_creq, buff_num);
+
+	if (((ioread32(&priv->regs->if1_id2)) & CAN_ID_MSGVAL) &&
+			((ioread32(&priv->regs->if1_mcont)) &
+			CAN_IF_MCONT_RXIE))
+		*enable = ENABLE;
+	else
+		*enable = DISABLE;
+	spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
+}
+
+static void pch_can_get_tx_enable(struct pch_can_priv *priv, u32 buff_num,
+				 u32 *enable)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
+	iowrite32(CAN_CMASK_RX_TX_GET, &priv->regs->if2_cmask);
+	pch_can_check_if_busy(&priv->regs->if2_creq, buff_num);
+
+	if (((ioread32(&priv->regs->if2_id2)) & CAN_ID_MSGVAL) &&
+			((ioread32(&priv->regs->if2_mcont)) &
+			CAN_IF_MCONT_TXIE)) {
+		*enable = ENABLE;
+	} else {
+		*enable = DISABLE;
+	}
+	spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
+}
+
+static int pch_can_int_pending(struct pch_can_priv *priv)
+{
+	return ioread32(&priv->regs->intr) & 0xffff;
+}
+
+static void pch_can_set_rx_buffer_link(struct pch_can_priv *priv,
+				       u32 buffer_num, u32 set)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
+	iowrite32(CAN_CMASK_RX_TX_GET, &priv->regs->if1_cmask);
+	pch_can_check_if_busy(&priv->regs->if1_creq, buffer_num);
+	iowrite32(CAN_CMASK_RDWR | CAN_CMASK_CTRL, &priv->regs->if1_cmask);
+	if (set == ENABLE)
+		pch_can_bit_clear(&priv->regs->if1_mcont, CAN_IF_MCONT_EOB);
+	else
+		pch_can_bit_set(&priv->regs->if1_mcont, CAN_IF_MCONT_EOB);
+
+	pch_can_check_if_busy(&priv->regs->if1_creq, buffer_num);
+	spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
+}
+
+static void pch_can_get_rx_buffer_link(struct pch_can_priv *priv,
+				       u32 buffer_num, u32 *link)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
+	iowrite32(CAN_CMASK_RX_TX_GET, &priv->regs->if1_cmask);
+	pch_can_check_if_busy(&priv->regs->if1_creq, buffer_num);
+
+	if (ioread32(&priv->regs->if1_mcont) & CAN_IF_MCONT_EOB)
+		*link = DISABLE;
+	else
+		*link = ENABLE;
+	spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
+}
+
+static void pch_can_clear_buffers(struct pch_can_priv *priv)
+{
+	int i;
+
+	for (i = 0; i < PCH_RX_OBJ_NUM; i++) {
+		iowrite32(CAN_CMASK_RX_TX_SET, &priv->regs->if1_cmask);
+		iowrite32(0xffff, &priv->regs->if1_mask1);
+		iowrite32(0xffff, &priv->regs->if1_mask2);
+		iowrite32(0x0, &priv->regs->if1_id1);
+		iowrite32(0x0, &priv->regs->if1_id2);
+		iowrite32(0x0, &priv->regs->if1_mcont);
+		iowrite32(0x0, &priv->regs->if1_dataa1);
+		iowrite32(0x0, &priv->regs->if1_dataa2);
+		iowrite32(0x0, &priv->regs->if1_datab1);
+		iowrite32(0x0, &priv->regs->if1_datab2);
+		iowrite32(CAN_CMASK_RDWR | CAN_CMASK_MASK |
+			  CAN_CMASK_ARB | CAN_CMASK_CTRL,
+			  &priv->regs->if1_cmask);
+		pch_can_check_if_busy(&priv->regs->if1_creq, i+1);
+	}
+
+	for (i = i;  i < PCH_OBJ_NUM; i++) {
+		iowrite32(CAN_CMASK_RX_TX_SET, &priv->regs->if2_cmask);
+		iowrite32(0xffff, &priv->regs->if2_mask1);
+		iowrite32(0xffff, &priv->regs->if2_mask2);
+		iowrite32(0x0, &priv->regs->if2_id1);
+		iowrite32(0x0, &priv->regs->if2_id2);
+		iowrite32(0x0, &priv->regs->if2_mcont);
+		iowrite32(0x0, &priv->regs->if2_dataa1);
+		iowrite32(0x0, &priv->regs->if2_dataa2);
+		iowrite32(0x0, &priv->regs->if2_datab1);
+		iowrite32(0x0, &priv->regs->if2_datab2);
+		iowrite32(CAN_CMASK_RDWR | CAN_CMASK_MASK |
+			  CAN_CMASK_ARB | CAN_CMASK_CTRL,
+			  &priv->regs->if2_cmask);
+		pch_can_check_if_busy(&priv->regs->if2_creq, i+1);
+	}
+}
+
+static void pch_can_config_rx_tx_buffers(struct pch_can_priv *priv)
+{
+	int i;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
+
+	for (i = 0; i < PCH_OBJ_NUM; i++) {
+		if (priv->msg_obj[i] == MSG_OBJ_RX) {
+			iowrite32(CAN_CMASK_RX_TX_GET,
+				&priv->regs->if1_cmask);
+			pch_can_check_if_busy(&priv->regs->if1_creq, i+1);
+
+			iowrite32(0x0, &priv->regs->if1_id1);
+			iowrite32(0x0, &priv->regs->if1_id2);
+
+			pch_can_bit_set(&priv->regs->if1_mcont,
+					CAN_IF_MCONT_UMASK);
+
+			/* Set FIFO mode set to 0 except last Rx Obj*/
+			pch_can_bit_clear(&priv->regs->if1_mcont,
+					  CAN_IF_MCONT_EOB);
+			/* In case FIFO mode, Last EoB of Rx Obj must be 1 */
+			if (i == (PCH_RX_OBJ_NUM - 1))
+				pch_can_bit_set(&priv->regs->if1_mcont,
+						  CAN_IF_MCONT_EOB);
+
+			iowrite32(0, &priv->regs->if1_mask1);
+			pch_can_bit_clear(&priv->regs->if1_mask2,
+					  0x1fff | CAN_MASK2_MDIR_MXTD);
+
+			/* Setting CMASK for writing */
+			iowrite32(CAN_CMASK_RDWR | CAN_CMASK_MASK |
+				  CAN_CMASK_ARB | CAN_CMASK_CTRL,
+				  &priv->regs->if1_cmask);
+
+			pch_can_check_if_busy(&priv->regs->if1_creq, i+1);
+		} else if (priv->msg_obj[i] == MSG_OBJ_TX) {
+			iowrite32(CAN_CMASK_RX_TX_GET,
+				&priv->regs->if2_cmask);
+			pch_can_check_if_busy(&priv->regs->if2_creq, i+1);
+
+			/* Resetting DIR bit for reception */
+			iowrite32(0x0, &priv->regs->if2_id1);
+			iowrite32(0x0, &priv->regs->if2_id2);
+			pch_can_bit_set(&priv->regs->if2_id2, CAN_ID2_DIR);
+
+			/* Setting EOB bit for transmitter */
+			iowrite32(CAN_IF_MCONT_EOB, &priv->regs->if2_mcont);
+
+			pch_can_bit_set(&priv->regs->if2_mcont,
+					CAN_IF_MCONT_UMASK);
+
+			iowrite32(0, &priv->regs->if2_mask1);
+			pch_can_bit_clear(&priv->regs->if2_mask2, 0x1fff);
+
+			/* Setting CMASK for writing */
+			iowrite32(CAN_CMASK_RDWR | CAN_CMASK_MASK |
+				  CAN_CMASK_ARB | CAN_CMASK_CTRL,
+				  &priv->regs->if2_cmask);
+
+			pch_can_check_if_busy(&priv->regs->if2_creq, i+1);
+		}
+	}
+	spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
+}
+
+static void pch_can_init(struct pch_can_priv *priv)
+{
+	/* Stopping the Can device. */
+	pch_can_set_run_mode(priv, PCH_CAN_STOP);
+
+	/* Clearing all the message object buffers. */
+	pch_can_clear_buffers(priv);
+
+	/* Configuring the respective message object as either rx/tx object. */
+	pch_can_config_rx_tx_buffers(priv);
+
+	/* Enabling the interrupts. */
+	pch_can_set_int_enables(priv, PCH_CAN_ALL);
+}
+
+static void pch_can_release(struct pch_can_priv *priv)
+{
+	/* Stooping the CAN device. */
+	pch_can_set_run_mode(priv, PCH_CAN_STOP);
+
+	/* Disabling the interrupts. */
+	pch_can_set_int_enables(priv, PCH_CAN_NONE);
+
+	/* Disabling all the receive object. */
+	pch_can_rx_disable_all(priv);
+
+	/* Disabling all the transmit object. */
+	pch_can_tx_disable_all(priv);
+}
+
+/* This function clears interrupt(s) from the CAN device. */
+static void pch_can_int_clr(struct pch_can_priv *priv, u32 mask)
+{
+	if (mask == CAN_STATUS_INT) {
+		ioread32(&priv->regs->stat);
+		return;
+	}
+
+	/* Clear interrupt for transmit object */
+	if (priv->msg_obj[mask - 1] == MSG_OBJ_TX) {
+		/* Setting CMASK for clearing interrupts for
+					 frame transmission. */
+		iowrite32(CAN_CMASK_RDWR | CAN_CMASK_CTRL | CAN_CMASK_ARB,
+			  &priv->regs->if2_cmask);
+
+		/* Resetting the ID registers. */
+		pch_can_bit_set(&priv->regs->if2_id2,
+			       CAN_ID2_DIR | (0x7ff << 2));
+		iowrite32(0x0, &priv->regs->if2_id1);
+
+		/* Claring NewDat, TxRqst & IntPnd */
+		pch_can_bit_clear(&priv->regs->if2_mcont,
+				  CAN_IF_MCONT_NEWDAT | CAN_IF_MCONT_INTPND |
+				  CAN_IF_MCONT_TXRQXT);
+		pch_can_check_if_busy(&priv->regs->if2_creq, mask);
+	} else if (priv->msg_obj[mask - 1] == MSG_OBJ_RX) {
+		/* Setting CMASK for clearing the reception interrupts. */
+		iowrite32(CAN_CMASK_RDWR | CAN_CMASK_CTRL | CAN_CMASK_ARB,
+			  &priv->regs->if1_cmask);
+
+		/* Clearing the Dir bit. */
+		pch_can_bit_clear(&priv->regs->if1_id2, CAN_ID2_DIR);
+
+		/* Clearing NewDat & IntPnd */
+		pch_can_bit_clear(&priv->regs->if1_mcont,
+				  CAN_IF_MCONT_NEWDAT | CAN_IF_MCONT_INTPND);
+
+		pch_can_check_if_busy(&priv->regs->if1_creq, mask);
+	}
+}
+
+static int pch_can_get_buffer_status(struct pch_can_priv *priv)
+{
+	return (ioread32(&priv->regs->treq1) & 0xffff) |
+	       ((ioread32(&priv->regs->treq2) & 0xffff) << 16);
+}
+
+static void pch_can_reset(struct pch_can_priv *priv)
+{
+	/* write to sw reset register */
+	iowrite32(1, &priv->regs->srst);
+	iowrite32(0, &priv->regs->srst);
+}
+
+static void pch_can_error(struct net_device *ndev, u32 status)
+{
+	struct sk_buff *skb;
+	struct pch_can_priv *priv = netdev_priv(ndev);
+	struct can_frame *cf;
+	u32 errc;
+	struct net_device_stats *stats = &(priv->ndev->stats);
+	enum can_state state = priv->can.state;
+
+	skb = alloc_can_err_skb(ndev, &cf);
+	if (!skb)
+		return;
+
+	if (status & PCH_BUS_OFF) {
+		pch_can_tx_disable_all(priv);
+		pch_can_rx_disable_all(priv);
+		state = CAN_STATE_BUS_OFF;
+		cf->can_id |= CAN_ERR_BUSOFF;
+		can_bus_off(ndev);
+		pch_can_set_run_mode(priv, PCH_CAN_RUN);
+		dev_err(&ndev->dev, "%s -> Bus Off occurres.\n", __func__);
+	}
+
+	/* Warning interrupt. */
+	if (status & PCH_EWARN) {
+		state = CAN_STATE_ERROR_WARNING;
+		priv->can.can_stats.error_warning++;
+		cf->can_id |= CAN_ERR_CRTL;
+		errc = ioread32(&priv->regs->errc);
+		if (((errc & CAN_REC) >> 8) > 96)
+			cf->data[1] |= CAN_ERR_CRTL_RX_WARNING;
+		if ((errc & CAN_TEC) > 96)
+			cf->data[1] |= CAN_ERR_CRTL_TX_WARNING;
+		dev_warn(&ndev->dev,
+			"%s -> Error Counter is more than 96.\n", __func__);
+	}
+	/* Error passive interrupt. */
+	if (status & PCH_EPASSIV) {
+		priv->can.can_stats.error_passive++;
+		state = CAN_STATE_ERROR_PASSIVE;
+		cf->can_id |= CAN_ERR_CRTL;
+		errc = ioread32(&priv->regs->errc);
+		if (((errc & CAN_REC) >> 8) > 127)
+			cf->data[1] |= CAN_ERR_CRTL_RX_PASSIVE;
+		if ((errc & CAN_TEC) > 127)
+			cf->data[1] |= CAN_ERR_CRTL_TX_PASSIVE;
+		dev_err(&ndev->dev,
+			"%s -> CAN controller is ERROR PASSIVE .\n", __func__);
+	}
+
+	if (status & PCH_LEC_ALL) {
+		priv->can.can_stats.bus_error++;
+		stats->rx_errors++;
+		switch (status & PCH_LEC_ALL) {
+		case PCH_STUF_ERR:
+			cf->data[2] |= CAN_ERR_PROT_STUFF;
+			break;
+		case PCH_FORM_ERR:
+			cf->data[2] |= CAN_ERR_PROT_FORM;
+			break;
+		case PCH_ACK_ERR:
+			cf->data[2] |= CAN_ERR_PROT_LOC_ACK |
+				       CAN_ERR_PROT_LOC_ACK_DEL;
+			break;
+		case PCH_BIT1_ERR:
+		case PCH_BIT0_ERR:
+			cf->data[2] |= CAN_ERR_PROT_BIT;
+			break;
+		case PCH_CRC_ERR:
+			cf->data[2] |= CAN_ERR_PROT_LOC_CRC_SEQ |
+				       CAN_ERR_PROT_LOC_CRC_DEL;
+			break;
+		default:
+			iowrite32(status | PCH_LEC_ALL, &priv->regs->stat);
+			break;
+		}
+
+	}
+
+	priv->can.state = state;
+	netif_rx(skb);
+
+	stats->rx_packets++;
+	stats->rx_bytes += cf->can_dlc;
+}
+
+static irqreturn_t pch_can_interrupt(int irq, void *dev_id)
+{
+	struct net_device *ndev = (struct net_device *)dev_id;
+	struct pch_can_priv *priv = netdev_priv(ndev);
+
+	pch_can_set_int_enables(priv, PCH_CAN_NONE);
+
+	napi_schedule(&priv->napi);
+
+	return IRQ_HANDLED;
+}
+
+static int pch_can_rx_normal(struct net_device *ndev, u32 int_stat)
+{
+	u32 reg;
+	canid_t id;
+	u32 ide;
+	u32 rtr;
+	int i, j, k;
+	int rcv_pkts = 0;
+	struct sk_buff *skb;
+	struct can_frame *cf;
+	struct pch_can_priv *priv = netdev_priv(ndev);
+	struct net_device_stats *stats = &(priv->ndev->stats);
+
+	/* Reading the messsage object from the Message RAM */
+	iowrite32(CAN_CMASK_RX_TX_GET, &priv->regs->if1_cmask);
+	pch_can_check_if_busy(&priv->regs->if1_creq, int_stat);
+
+	/* Reading the MCONT register. */
+	reg = ioread32(&priv->regs->if1_mcont);
+	reg &= 0xffff;
+
+	for (k = int_stat; !(reg & CAN_IF_MCONT_EOB); k++) {
+		/* If MsgLost bit set. */
+		if (reg & CAN_IF_MCONT_MSGLOST) {
+			dev_err(&priv->ndev->dev, "Msg Obj is overwritten.\n");
+			pch_can_bit_clear(&priv->regs->if1_mcont,
+					  CAN_IF_MCONT_MSGLOST);
+			iowrite32(CAN_CMASK_RDWR | CAN_CMASK_CTRL,
+				  &priv->regs->if1_cmask);
+			pch_can_check_if_busy(&priv->regs->if1_creq, k);
+
+			skb = alloc_can_err_skb(ndev, &cf);
+			if (!skb)
+				return -ENOMEM;
+
+			priv->can.can_stats.error_passive++;
+			priv->can.state = CAN_STATE_ERROR_PASSIVE;
+			cf->can_id |= CAN_ERR_CRTL;
+			cf->data[1] |= CAN_ERR_CRTL_RX_OVERFLOW;
+			cf->data[2] |= CAN_ERR_PROT_OVERLOAD;
+			stats->rx_packets++;
+			stats->rx_bytes += cf->can_dlc;
+
+			netif_receive_skb(skb);
+			rcv_pkts++;
+			goto RX_NEXT;
+		}
+		if (!(reg & CAN_IF_MCONT_NEWDAT))
+			goto RX_NEXT;
+
+		skb = alloc_can_skb(priv->ndev, &cf);
+		if (!skb)
+			return -ENOMEM;
+
+		/* Get Received data */
+		ide = ((ioread32(&priv->regs->if1_id2)) & CAN_ID2_XTD) >> 14;
+		if (ide) {
+			id = (ioread32(&priv->regs->if1_id1) & 0xffff);
+			id |= (((ioread32(&priv->regs->if1_id2)) &
+					    0x1fff) << 16);
+			cf->can_id = (id & CAN_EFF_MASK) | CAN_EFF_FLAG;
+		} else {
+			id = (((ioread32(&priv->regs->if1_id2)) &
+					  (CAN_SFF_MASK << 2)) >> 2);
+			cf->can_id = (id & CAN_SFF_MASK);
+		}
+
+		rtr = (ioread32(&priv->regs->if1_id2) &  CAN_ID2_DIR);
+		if (rtr) {
+			cf->can_dlc = 0;
+			cf->can_id |= CAN_RTR_FLAG;
+		} else {
+			cf->can_dlc = ((ioread32(&priv->regs->if1_mcont)) &
+						   0x0f);
+		}
+
+		for (i = 0, j = 0; i < cf->can_dlc; j++) {
+			reg = ioread32(&priv->regs->if1_dataa1 + j*4);
+			cf->data[i++] = cpu_to_le32(reg & 0xff);
+			if (i == cf->can_dlc)
+				break;
+			cf->data[i++] = cpu_to_le32((reg >> 8) & 0xff);
+		}
+
+		netif_receive_skb(skb);
+		rcv_pkts++;
+		stats->rx_packets++;
+		stats->rx_bytes += cf->can_dlc;
+
+		if (k < PCH_FIFO_THRESH) {
+			iowrite32(CAN_CMASK_RDWR | CAN_CMASK_CTRL |
+				  CAN_CMASK_ARB, &priv->regs->if1_cmask);
+
+			/* Clearing the Dir bit. */
+			pch_can_bit_clear(&priv->regs->if1_id2, CAN_ID2_DIR);
+
+			/* Clearing NewDat & IntPnd */
+			pch_can_bit_clear(&priv->regs->if1_mcont,
+					  CAN_IF_MCONT_INTPND);
+			pch_can_check_if_busy(&priv->regs->if1_creq, k);
+		} else if (k > PCH_FIFO_THRESH) {
+			pch_can_int_clr(priv, k);
+		} else if (k == PCH_FIFO_THRESH) {
+			int cnt;
+			for (cnt = 0; cnt < PCH_FIFO_THRESH; cnt++)
+				pch_can_int_clr(priv, cnt+1);
+		}
+RX_NEXT:
+		/* Reading the messsage object from the Message RAM */
+		iowrite32(CAN_CMASK_RX_TX_GET, &priv->regs->if1_cmask);
+		pch_can_check_if_busy(&priv->regs->if1_creq, k + 1);
+		reg = ioread32(&priv->regs->if1_mcont);
+	}
+
+	return rcv_pkts;
+}
+static int pch_can_rx_poll(struct napi_struct *napi, int quota)
+{
+	struct net_device *ndev = napi->dev;
+	struct pch_can_priv *priv = netdev_priv(ndev);
+	struct net_device_stats *stats = &(priv->ndev->stats);
+	u32 dlc;
+	u32 int_stat;
+	int rcv_pkts = 0;
+	u32 reg_stat;
+	unsigned long flags;
+
+	int_stat = pch_can_int_pending(priv);
+	if (!int_stat)
+		return 0;
+
+INT_STAT:
+	if (int_stat == CAN_STATUS_INT) {
+		reg_stat = ioread32(&priv->regs->stat);
+		if (reg_stat & (PCH_BUS_OFF | PCH_LEC_ALL)) {
+			if ((reg_stat & PCH_LEC_ALL) != PCH_LEC_ALL)
+				pch_can_error(ndev, reg_stat);
+		}
+
+		if (reg_stat & PCH_TX_OK) {
+			spin_lock_irqsave(&priv->msgif_reg_lock, flags);
+			iowrite32(CAN_CMASK_RX_TX_GET, &priv->regs->if2_cmask);
+			pch_can_check_if_busy(&priv->regs->if2_creq,
+					       ioread32(&priv->regs->intr));
+			spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
+			pch_can_bit_clear(&priv->regs->stat, PCH_TX_OK);
+		}
+
+		if (reg_stat & PCH_RX_OK)
+			pch_can_bit_clear(&priv->regs->stat, PCH_RX_OK);
+
+		int_stat = pch_can_int_pending(priv);
+		if (int_stat == CAN_STATUS_INT)
+			goto INT_STAT;
+	}
+
+MSG_OBJ:
+	if ((int_stat >= 1) && (int_stat <= PCH_RX_OBJ_NUM)) {
+		spin_lock_irqsave(&priv->msgif_reg_lock, flags);
+		rcv_pkts = pch_can_rx_normal(ndev, int_stat);
+		spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
+		if (rcv_pkts < 0)
+			return 0;
+	} else if ((int_stat > PCH_RX_OBJ_NUM) && (int_stat <= PCH_OBJ_NUM)) {
+		if (priv->msg_obj[int_stat - 1] == MSG_OBJ_TX) {
+			/* Handle transmission interrupt */
+			can_get_echo_skb(ndev, int_stat - PCH_RX_OBJ_NUM - 1);
+			spin_lock_irqsave(&priv->msgif_reg_lock, flags);
+			iowrite32(CAN_CMASK_RX_TX_GET | CAN_CMASK_CLRINTPND,
+				  &priv->regs->if2_cmask);
+			dlc = ioread32(&priv->regs->if2_mcont) &
+				       CAN_IF_MCONT_DLC;
+			pch_can_check_if_busy(&priv->regs->if2_creq, int_stat);
+			spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
+			if (dlc > 8)
+				dlc = 8;
+			stats->tx_bytes += dlc;
+			stats->tx_packets++;
+		}
+	}
+
+	int_stat = pch_can_int_pending(priv);
+	if (int_stat == CAN_STATUS_INT)
+		goto INT_STAT;
+	else if (int_stat >= 1 && int_stat <= 32)
+		goto MSG_OBJ;
+
+	napi_complete(napi);
+	pch_can_set_int_enables(priv, PCH_CAN_ALL);
+
+	return rcv_pkts;
+}
+
+static int pch_set_bittiming(struct net_device *ndev)
+{
+	struct pch_can_priv *priv = netdev_priv(ndev);
+	const struct can_bittiming *bt = &priv->can.bittiming;
+	u32 canbit;
+	u32 bepe;
+	u32 brp;
+
+	/* Setting the CCE bit for accessing the Can Timing register. */
+	pch_can_bit_set(&priv->regs->cont, CAN_CTRL_CCE);
+
+	brp = (bt->tq) / (1000000000/PCH_CAN_CLK) - 1;
+	canbit = brp & MSK_BITT_BRP;
+	canbit |= (bt->sjw - 1) << BIT_BITT_SJW;
+	canbit |= (bt->phase_seg1 + bt->prop_seg - 1) << BIT_BITT_TSEG1;
+	canbit |= (bt->phase_seg2 - 1) << BIT_BITT_TSEG2;
+	bepe = (brp & MSK_BRPE_BRPE) >> BIT_BRPE_BRPE;
+	iowrite32(canbit, &priv->regs->bitt);
+	iowrite32(bepe, &priv->regs->brpe);
+	pch_can_bit_clear(&priv->regs->cont, CAN_CTRL_CCE);
+
+	return 0;
+}
+
+static void pch_can_start(struct net_device *ndev)
+{
+	struct pch_can_priv *priv = netdev_priv(ndev);
+
+	if (priv->can.state != CAN_STATE_STOPPED)
+		pch_can_reset(priv);
+
+	pch_set_bittiming(ndev);
+	pch_can_set_optmode(priv);
+
+	pch_can_tx_enable_all(priv);
+	pch_can_rx_enable_all(priv);
+
+	/* Setting the CAN to run mode. */
+	pch_can_set_run_mode(priv, PCH_CAN_RUN);
+
+	priv->can.state = CAN_STATE_ERROR_ACTIVE;
+
+	return;
+}
+
+static int pch_can_do_set_mode(struct net_device *ndev, enum can_mode mode)
+{
+	int ret = 0;
+
+	switch (mode) {
+	case CAN_MODE_START:
+		pch_can_start(ndev);
+		netif_wake_queue(ndev);
+		break;
+	default:
+		ret = -EOPNOTSUPP;
+		break;
+	}
+
+	return ret;
+}
+
+static int pch_can_open(struct net_device *ndev)
+{
+	struct pch_can_priv *priv = netdev_priv(ndev);
+	int retval;
+
+	retval = pci_enable_msi(priv->dev);
+	if (retval) {
+		dev_info(&ndev->dev, "PCH CAN opened without MSI\n");
+		priv->use_msi = 0;
+	} else {
+		dev_info(&ndev->dev, "PCH CAN opened with MSI\n");
+		priv->use_msi = 1;
+	}
+
+	/* Regsitering the interrupt. */
+	retval = request_irq(priv->dev->irq, pch_can_interrupt, IRQF_SHARED,
+			     ndev->name, ndev);
+	if (retval) {
+		dev_err(&ndev->dev, "request_irq failed.\n");
+		goto req_irq_err;
+	}
+
+	/* Open common can device */
+	retval = open_candev(ndev);
+	if (retval) {
+		dev_err(ndev->dev.parent, "open_candev() failed %d\n", retval);
+		goto err_open_candev;
+	}
+
+	pch_can_init(priv);
+	pch_can_start(ndev);
+	napi_enable(&priv->napi);
+	netif_start_queue(ndev);
+
+	return 0;
+
+err_open_candev:
+	free_irq(priv->dev->irq, ndev);
+req_irq_err:
+	if (priv->use_msi)
+		pci_disable_msi(priv->dev);
+
+	pch_can_release(priv);
+
+	return retval;
+}
+
+static int pch_close(struct net_device *ndev)
+{
+	struct pch_can_priv *priv = netdev_priv(ndev);
+
+	netif_stop_queue(ndev);
+	napi_disable(&priv->napi);
+	pch_can_release(priv);
+	free_irq(priv->dev->irq, ndev);
+	if (priv->use_msi)
+		pci_disable_msi(priv->dev);
+	close_candev(ndev);
+	priv->can.state = CAN_STATE_STOPPED;
+	return 0;
+}
+
+static int pch_get_msg_obj_sts(struct net_device *ndev, u32 obj_id)
+{
+	u32 buffer_status = 0;
+	struct pch_can_priv *priv = netdev_priv(ndev);
+
+	/* Getting the message object status. */
+	buffer_status = (u32) pch_can_get_buffer_status(priv);
+
+	return buffer_status & obj_id;
+}
+
+
+static netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	int i, j;
+	unsigned long flags;
+	struct pch_can_priv *priv = netdev_priv(ndev);
+	struct can_frame *cf = (struct can_frame *)skb->data;
+	int tx_buffer_avail = 0;
+
+	if (can_dropped_invalid_skb(ndev, skb))
+		return NETDEV_TX_OK;
+
+	if (priv->tx_obj == (PCH_OBJ_NUM + 1)) { /* Point tail Obj */
+		while (pch_get_msg_obj_sts(ndev, (((1 << PCH_TX_OBJ_NUM)-1) <<
+					   PCH_RX_OBJ_NUM)))
+			udelay(500);
+
+		priv->tx_obj = PCH_RX_OBJ_NUM + 1; /* Point head of Tx Obj ID */
+		tx_buffer_avail = priv->tx_obj; /* Point Tail of Tx Obj */
+	} else {
+		tx_buffer_avail = priv->tx_obj;
+	}
+	priv->tx_obj++;
+
+	/* Attaining the lock. */
+	spin_lock_irqsave(&priv->msgif_reg_lock, flags);
+
+	/* Reading the Msg Obj from the Msg RAM to the Interface register. */
+	iowrite32(CAN_CMASK_RX_TX_GET, &priv->regs->if2_cmask);
+	pch_can_check_if_busy(&priv->regs->if2_creq, tx_buffer_avail);
+
+	/* Setting the CMASK register. */
+	pch_can_bit_set(&priv->regs->if2_cmask, CAN_CMASK_ALL);
+
+	/* If ID extended is set. */
+	pch_can_bit_clear(&priv->regs->if2_id1, 0xffff);
+	pch_can_bit_clear(&priv->regs->if2_id2, 0x1fff | CAN_ID2_XTD);
+	if (cf->can_id & CAN_EFF_FLAG) {
+		pch_can_bit_set(&priv->regs->if2_id1, cf->can_id & 0xffff);
+		pch_can_bit_set(&priv->regs->if2_id2,
+				((cf->can_id >> 16) & 0x1fff) | CAN_ID2_XTD);
+	} else {
+		pch_can_bit_set(&priv->regs->if2_id1, 0);
+		pch_can_bit_set(&priv->regs->if2_id2,
+				(cf->can_id & CAN_SFF_MASK) << 2);
+	}
+
+	/* If remote frame has to be transmitted.. */
+	if (cf->can_id & CAN_RTR_FLAG)
+		pch_can_bit_clear(&priv->regs->if2_id2, CAN_ID2_DIR);
+
+	for (i = 0, j = 0; i < cf->can_dlc; j++) {
+		iowrite32(le32_to_cpu(cf->data[i++]),
+			 (&priv->regs->if2_dataa1) + j*4);
+		if (i == cf->can_dlc)
+			break;
+		iowrite32(le32_to_cpu(cf->data[i++] << 8),
+			 (&priv->regs->if2_dataa1) + j*4);
+	}
+
+	can_put_echo_skb(skb, ndev, tx_buffer_avail - PCH_RX_OBJ_NUM - 1);
+
+	/* Updating the size of the data. */
+	pch_can_bit_clear(&priv->regs->if2_mcont, 0x0f);
+	pch_can_bit_set(&priv->regs->if2_mcont, cf->can_dlc);
+
+	/* Clearing IntPend, NewDat & TxRqst */
+	pch_can_bit_clear(&priv->regs->if2_mcont,
+			  CAN_IF_MCONT_NEWDAT | CAN_IF_MCONT_INTPND |
+			  CAN_IF_MCONT_TXRQXT);
+
+	/* Setting NewDat, TxRqst bits */
+	pch_can_bit_set(&priv->regs->if2_mcont,
+			CAN_IF_MCONT_NEWDAT | CAN_IF_MCONT_TXRQXT);
+
+	pch_can_check_if_busy(&priv->regs->if2_creq, tx_buffer_avail);
+
+	spin_unlock_irqrestore(&priv->msgif_reg_lock, flags);
+
+	return NETDEV_TX_OK;
+}
+
+static const struct net_device_ops pch_can_netdev_ops = {
+	.ndo_open		= pch_can_open,
+	.ndo_stop		= pch_close,
+	.ndo_start_xmit		= pch_xmit,
+};
+
+static void __devexit pch_can_remove(struct pci_dev *pdev)
+{
+	struct net_device *ndev = pci_get_drvdata(pdev);
+	struct pch_can_priv *priv = netdev_priv(ndev);
+
+	unregister_candev(priv->ndev);
+	free_candev(priv->ndev);
+	pci_iounmap(pdev, priv->regs);
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+	pci_set_drvdata(pdev, NULL);
+	pch_can_reset(priv);
+}
+
+#ifdef CONFIG_PM
+static int pch_can_suspend(struct pci_dev *pdev, pm_message_t state)
+{
+	int i;			/* Counter variable. */
+	int retval;		/* Return value. */
+	u32 buf_stat;	/* Variable for reading the transmit buffer status. */
+	u32 counter = 0xFFFFFF;
+
+	struct net_device *dev = pci_get_drvdata(pdev);
+	struct pch_can_priv *priv = netdev_priv(dev);
+
+	/* Stop the CAN controller */
+	pch_can_set_run_mode(priv, PCH_CAN_STOP);
+
+	/* Indicate that we are aboutto/in suspend */
+	priv->can.state = CAN_STATE_SLEEPING;
+
+	/* Waiting for all transmission to complete. */
+	while (counter) {
+		buf_stat = pch_can_get_buffer_status(priv);
+		if (!buf_stat)
+			break;
+		counter--;
+		udelay(1);
+	}
+	if (!counter)
+		dev_err(&pdev->dev, "%s -> Transmission time out.\n", __func__);
+
+	/* Save interrupt configuration and then disable them */
+	pch_can_get_int_enables(priv, &(priv->int_enables));
+	pch_can_set_int_enables(priv, PCH_CAN_DISABLE);
+
+	/* Save Tx buffer enable state */
+	for (i = 0; i < PCH_OBJ_NUM; i++) {
+		if (priv->msg_obj[i] == MSG_OBJ_TX)
+			pch_can_get_tx_enable(priv, i + 1,
+					      &(priv->tx_enable[i]));
+	}
+
+	/* Disable all Transmit buffers */
+	pch_can_tx_disable_all(priv);
+
+	/* Save Rx buffer enable state */
+	for (i = 0; i < PCH_OBJ_NUM; i++) {
+		if (priv->msg_obj[i] == MSG_OBJ_RX) {
+			pch_can_get_rx_enable(priv, i + 1,
+						&(priv->rx_enable[i]));
+			pch_can_get_rx_buffer_link(priv, i + 1,
+						&(priv->rx_link[i]));
+		}
+	}
+
+	/* Disable all Receive buffers */
+	pch_can_rx_disable_all(priv);
+	retval = pci_save_state(pdev);
+	if (retval) {
+		dev_err(&pdev->dev, "pci_save_state failed.\n");
+	} else {
+		pci_enable_wake(pdev, PCI_D3hot, 0);
+		pci_disable_device(pdev);
+		pci_set_power_state(pdev, pci_choose_state(pdev, state));
+	}
+
+	return retval;
+}
+
+static int pch_can_resume(struct pci_dev *pdev)
+{
+	int i;			/* Counter variable. */
+	int retval;		/* Return variable. */
+	struct net_device *dev = pci_get_drvdata(pdev);
+	struct pch_can_priv *priv = netdev_priv(dev);
+
+	pci_set_power_state(pdev, PCI_D0);
+	pci_restore_state(pdev);
+	retval = pci_enable_device(pdev);
+	if (retval) {
+		dev_err(&pdev->dev, "pci_enable_device failed.\n");
+		return retval;
+	}
+
+	pci_enable_wake(pdev, PCI_D3hot, 0);
+
+	priv->can.state = CAN_STATE_ERROR_ACTIVE;
+
+	/* Disabling all interrupts. */
+	pch_can_set_int_enables(priv, PCH_CAN_DISABLE);
+
+	/* Setting the CAN device in Stop Mode. */
+	pch_can_set_run_mode(priv, PCH_CAN_STOP);
+
+	/* Configuring the transmit and receive buffers. */
+	pch_can_config_rx_tx_buffers(priv);
+
+	/* Restore the CAN state */
+	pch_set_bittiming(dev);
+
+	/* Listen/Active */
+	pch_can_set_optmode(priv);
+
+	/* Enabling the transmit buffer. */
+	for (i = 0; i < PCH_OBJ_NUM; i++) {
+		if (priv->msg_obj[i] == MSG_OBJ_TX) {
+			pch_can_set_tx_enable(priv, i + 1,
+					      priv->tx_enable[i]);
+		}
+	}
+
+	/* Configuring the receive buffer and enabling them. */
+	for (i = 0; i < PCH_OBJ_NUM; i++) {
+		if (priv->msg_obj[i] == MSG_OBJ_RX) {
+			/* Restore buffer link */
+			pch_can_set_rx_buffer_link(priv, i + 1,
+						   priv->rx_link[i]);
+
+			/* Restore buffer enables */
+			pch_can_set_rx_enable(priv, i + 1, priv->rx_enable[i]);
+		}
+	}
+
+	/* Enable CAN Interrupts */
+	pch_can_set_int_custom(priv);
+
+	/* Restore Run Mode */
+	pch_can_set_run_mode(priv, PCH_CAN_RUN);
+
+	return retval;
+}
+#else
+#define pch_can_suspend NULL
+#define pch_can_resume NULL
+#endif
+
+static int pch_can_get_berr_counter(const struct net_device *dev,
+				    struct can_berr_counter *bec)
+{
+	struct pch_can_priv *priv = netdev_priv(dev);
+
+	bec->txerr = ioread32(&priv->regs->errc) & CAN_TEC;
+	bec->rxerr = (ioread32(&priv->regs->errc) & CAN_REC) >> 8;
+
+	return 0;
+}
+
+static int __devinit pch_can_probe(struct pci_dev *pdev,
+				   const struct pci_device_id *id)
+{
+	struct net_device *ndev;
+	struct pch_can_priv *priv;
+	int rc;
+	int index;
+	void __iomem *addr;
+
+	rc = pci_enable_device(pdev);
+	if (rc) {
+		dev_err(&pdev->dev, "Failed pci_enable_device %d\n", rc);
+		goto probe_exit_endev;
+	}
+
+	rc = pci_request_regions(pdev, KBUILD_MODNAME);
+	if (rc) {
+		dev_err(&pdev->dev, "Failed pci_request_regions %d\n", rc);
+		goto probe_exit_pcireq;
+	}
+
+	addr = pci_iomap(pdev, 1, 0);
+	if (!addr) {
+		rc = -EIO;
+		dev_err(&pdev->dev, "Failed pci_iomap\n");
+		goto probe_exit_ipmap;
+	}
+
+	ndev = alloc_candev(sizeof(struct pch_can_priv), PCH_TX_OBJ_NUM);
+	if (!ndev) {
+		rc = -ENOMEM;
+		dev_err(&pdev->dev, "Failed alloc_candev\n");
+		goto probe_exit_alloc_candev;
+	}
+
+	priv = netdev_priv(ndev);
+	priv->ndev = ndev;
+	priv->regs = addr;
+	priv->dev = pdev;
+	priv->can.bittiming_const = &pch_can_bittiming_const;
+	priv->can.do_set_mode = pch_can_do_set_mode;
+	priv->can.do_get_berr_counter = pch_can_get_berr_counter;
+	priv->can.ctrlmode_supported = CAN_CTRLMODE_LISTENONLY |
+				       CAN_CTRLMODE_LOOPBACK;
+	priv->tx_obj = PCH_RX_OBJ_NUM + 1; /* Point head of Tx Obj */
+
+	ndev->irq = pdev->irq;
+	ndev->flags |= IFF_ECHO;
+
+	pci_set_drvdata(pdev, ndev);
+	SET_NETDEV_DEV(ndev, &pdev->dev);
+	ndev->netdev_ops = &pch_can_netdev_ops;
+
+	priv->can.clock.freq = PCH_CAN_CLK; /* Hz */
+	for (index = 0; index < PCH_RX_OBJ_NUM;)
+		priv->msg_obj[index++] = MSG_OBJ_RX;
+
+	for (index = index;  index < PCH_OBJ_NUM;)
+		priv->msg_obj[index++] = MSG_OBJ_TX;
+
+	netif_napi_add(ndev, &priv->napi, pch_can_rx_poll, PCH_RX_OBJ_NUM);
+
+	rc = register_candev(ndev);
+	if (rc) {
+		dev_err(&pdev->dev, "Failed register_candev %d\n", rc);
+		goto probe_exit_reg_candev;
+	}
+
+	return 0;
+
+probe_exit_reg_candev:
+	free_candev(ndev);
+probe_exit_alloc_candev:
+	pci_iounmap(pdev, addr);
+probe_exit_ipmap:
+	pci_release_regions(pdev);
+probe_exit_pcireq:
+	pci_disable_device(pdev);
+probe_exit_endev:
+	return rc;
+}
+
+static struct pci_driver pch_can_pcidev = {
+	.name = "pch_can",
+	.id_table = pch_pci_tbl,
+	.probe = pch_can_probe,
+	.remove = __devexit_p(pch_can_remove),
+	.suspend = pch_can_suspend,
+	.resume = pch_can_resume,
+};
+
+static int __init pch_can_pci_init(void)
+{
+	return pci_register_driver(&pch_can_pcidev);
+}
+module_init(pch_can_pci_init);
+
+static void __exit pch_can_pci_exit(void)
+{
+	pci_unregister_driver(&pch_can_pcidev);
+}
+module_exit(pch_can_pci_exit);
+
+MODULE_DESCRIPTION("Controller Area Network Driver");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("0.94");
