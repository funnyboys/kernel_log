commit 0704c57436947c9f9f6472fd1a5ade41fc4c19d8
Author: Pankaj Sharma <pankj.sharma@samsung.com>
Date:   Tue Nov 19 15:50:38 2019 +0530

    can: m_can_platform: remove unnecessary m_can_class_resume() call
    
    The function m_can_runtime_resume() is getting recursively called from
    m_can_class_resume(). This results in a lock up.
    
    We need not call m_can_class_resume() during m_can_runtime_resume().
    
    Fixes: f524f829b75a ("can: m_can: Create a m_can platform framework")
    Signed-off-by: Pankaj Sharma <pankj.sharma@samsung.com>
    Signed-off-by: Sriram Dash <sriram.dash@samsung.com>
    Acked-by: Dan Murphy <dmurphy@ti.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/m_can/m_can_platform.c b/drivers/net/can/m_can/m_can_platform.c
index 2eaa3543d233..38ea5e600fb8 100644
--- a/drivers/net/can/m_can/m_can_platform.c
+++ b/drivers/net/can/m_can/m_can_platform.c
@@ -166,8 +166,6 @@ static int __maybe_unused m_can_runtime_resume(struct device *dev)
 	if (err)
 		clk_disable_unprepare(mcan_class->hclk);
 
-	m_can_class_resume(dev);
-
 	return err;
 }
 

commit 2ea872490e18cb0d6558de518d8fc35f5671567d
Author: Pankaj Sharma <pankj.sharma@samsung.com>
Date:   Tue Nov 19 15:50:37 2019 +0530

    can: m_can_platform: set net_device structure as driver data
    
    The current code is failing during clock prepare enable because of not
    getting proper clock from platform device.
    
    [    0.852089] Call trace:
    [    0.854516]  0xffff0000fa22a668
    [    0.857638]  clk_prepare+0x20/0x34
    [    0.861019]  m_can_runtime_resume+0x2c/0xe4
    [    0.865180]  pm_generic_runtime_resume+0x28/0x38
    [    0.869770]  __rpm_callback+0x16c/0x1bc
    [    0.873583]  rpm_callback+0x24/0x78
    [    0.877050]  rpm_resume+0x428/0x560
    [    0.880517]  __pm_runtime_resume+0x7c/0xa8
    [    0.884593]  m_can_clk_start.isra.9.part.10+0x1c/0xa8
    [    0.889618]  m_can_class_register+0x138/0x370
    [    0.893950]  m_can_plat_probe+0x120/0x170
    [    0.897939]  platform_drv_probe+0x4c/0xa0
    [    0.901924]  really_probe+0xd8/0x31c
    [    0.905477]  driver_probe_device+0x58/0xe8
    [    0.909551]  device_driver_attach+0x68/0x70
    [    0.913711]  __driver_attach+0x9c/0xf8
    [    0.917437]  bus_for_each_dev+0x50/0xa0
    [    0.921251]  driver_attach+0x20/0x28
    [    0.924804]  bus_add_driver+0x148/0x1fc
    [    0.928617]  driver_register+0x6c/0x124
    [    0.932431]  __platform_driver_register+0x48/0x50
    [    0.937113]  m_can_plat_driver_init+0x18/0x20
    [    0.941446]  do_one_initcall+0x4c/0x19c
    [    0.945259]  kernel_init_freeable+0x1d0/0x280
    [    0.949591]  kernel_init+0x10/0x100
    [    0.953057]  ret_from_fork+0x10/0x18
    [    0.956614] Code: 00000000 00000000 00000000 00000000 (fa22a668)
    [    0.962681] ---[ end trace 881f71bd609de763 ]---
    [    0.967301] Kernel panic - not syncing: Attempted to kill init!
    
    A device driver for CAN controller hardware registers itself with the
    Linux network layer as a network device. So, the driver data for m_can
    should ideally be of type net_device.
    
    Fixes: f524f829b75a ("can: m_can: Create a m_can platform framework")
    Signed-off-by: Pankaj Sharma <pankj.sharma@samsung.com>
    Signed-off-by: Sriram Dash <sriram.dash@samsung.com>
    Acked-by: Dan Murphy <dmurphy@ti.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/m_can/m_can_platform.c b/drivers/net/can/m_can/m_can_platform.c
index 6ac4c35f247a..2eaa3543d233 100644
--- a/drivers/net/can/m_can/m_can_platform.c
+++ b/drivers/net/can/m_can/m_can_platform.c
@@ -107,7 +107,7 @@ static int m_can_plat_probe(struct platform_device *pdev)
 
 	mcan_class->is_peripheral = false;
 
-	platform_set_drvdata(pdev, mcan_class->dev);
+	platform_set_drvdata(pdev, mcan_class->net);
 
 	m_can_init_ram(mcan_class);
 

commit b3402c405747c4b6a9fe2d0a225835d95abd8496
Author: Marc Kleine-Budde <mkl@pengutronix.de>
Date:   Mon Aug 19 19:34:28 2019 +0200

    can: m_can_platform: m_can_plat_probe(): add missing error handling if mcan_class is NULL
    
    This patch adds the missing error handling in m_can_plat_probe() if
    mcan_class is NULL.
    
    Fixes: f524f829b75a ("can: m_can: Create a m_can platform framework")
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/m_can/m_can_platform.c b/drivers/net/can/m_can/m_can_platform.c
index 2c6ef861d4a2..6ac4c35f247a 100644
--- a/drivers/net/can/m_can/m_can_platform.c
+++ b/drivers/net/can/m_can/m_can_platform.c
@@ -63,6 +63,9 @@ static int m_can_plat_probe(struct platform_device *pdev)
 	int irq, ret = 0;
 
 	mcan_class = m_can_class_allocate_dev(&pdev->dev);
+	if (!mcan_class)
+		return -ENOMEM;
+
 	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;

commit 28b0ffe98b53cf1f3e58023699886f813fb26144
Author: Marc Kleine-Budde <mkl@pengutronix.de>
Date:   Mon Aug 19 19:17:13 2019 +0200

    can: m_can_platform: remove not needed casts to struct m_can_plat_priv *
    
    The struct m_can_classdev::device_data is a void pointer, so there's no
    need to cast it to struct m_can_plat_priv *, when assigning the struct
    m_can_plat_priv pointer.
    
    This patch removes the not needed casts from the m_can_platform driver.
    
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/m_can/m_can_platform.c b/drivers/net/can/m_can/m_can_platform.c
index c2989e0431f2..2c6ef861d4a2 100644
--- a/drivers/net/can/m_can/m_can_platform.c
+++ b/drivers/net/can/m_can/m_can_platform.c
@@ -16,24 +16,21 @@ struct m_can_plat_priv {
 
 static u32 iomap_read_reg(struct m_can_classdev *cdev, int reg)
 {
-	struct m_can_plat_priv *priv =
-			(struct m_can_plat_priv *)cdev->device_data;
+	struct m_can_plat_priv *priv = cdev->device_data;
 
 	return readl(priv->base + reg);
 }
 
 static u32 iomap_read_fifo(struct m_can_classdev *cdev, int offset)
 {
-	struct m_can_plat_priv *priv =
-			(struct m_can_plat_priv *)cdev->device_data;
+	struct m_can_plat_priv *priv = cdev->device_data;
 
 	return readl(priv->mram_base + offset);
 }
 
 static int iomap_write_reg(struct m_can_classdev *cdev, int reg, int val)
 {
-	struct m_can_plat_priv *priv =
-			(struct m_can_plat_priv *)cdev->device_data;
+	struct m_can_plat_priv *priv = cdev->device_data;
 
 	writel(val, priv->base + reg);
 
@@ -42,8 +39,7 @@ static int iomap_write_reg(struct m_can_classdev *cdev, int reg, int val)
 
 static int iomap_write_fifo(struct m_can_classdev *cdev, int offset, int val)
 {
-	struct m_can_plat_priv *priv =
-			(struct m_can_plat_priv *)cdev->device_data;
+	struct m_can_plat_priv *priv = cdev->device_data;
 
 	writel(val, priv->mram_base + offset);
 

commit 441ac340169b792bf3df274f062e4939abb93ce8
Author: Dan Murphy <dmurphy@ti.com>
Date:   Thu May 9 11:11:06 2019 -0500

    can: m_can: Rename m_can_priv to m_can_classdev
    
    Rename the common m_can_priv class structure to m_can_classdev as this
    is more descriptive.
    
    Acked-by: Wolfgang Grandegger <wg@grandegger.com>
    Signed-off-by: Dan Murphy <dmurphy@ti.com>
    Acked-by: Faiz Abbas <faiz_abbas@ti.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/m_can/m_can_platform.c b/drivers/net/can/m_can/m_can_platform.c
index 026053f62f77..c2989e0431f2 100644
--- a/drivers/net/can/m_can/m_can_platform.c
+++ b/drivers/net/can/m_can/m_can_platform.c
@@ -14,7 +14,7 @@ struct m_can_plat_priv {
 	void __iomem *mram_base;
 };
 
-static u32 iomap_read_reg(struct m_can_priv *cdev, int reg)
+static u32 iomap_read_reg(struct m_can_classdev *cdev, int reg)
 {
 	struct m_can_plat_priv *priv =
 			(struct m_can_plat_priv *)cdev->device_data;
@@ -22,7 +22,7 @@ static u32 iomap_read_reg(struct m_can_priv *cdev, int reg)
 	return readl(priv->base + reg);
 }
 
-static u32 iomap_read_fifo(struct m_can_priv *cdev, int offset)
+static u32 iomap_read_fifo(struct m_can_classdev *cdev, int offset)
 {
 	struct m_can_plat_priv *priv =
 			(struct m_can_plat_priv *)cdev->device_data;
@@ -30,7 +30,7 @@ static u32 iomap_read_fifo(struct m_can_priv *cdev, int offset)
 	return readl(priv->mram_base + offset);
 }
 
-static int iomap_write_reg(struct m_can_priv *cdev, int reg, int val)
+static int iomap_write_reg(struct m_can_classdev *cdev, int reg, int val)
 {
 	struct m_can_plat_priv *priv =
 			(struct m_can_plat_priv *)cdev->device_data;
@@ -40,7 +40,7 @@ static int iomap_write_reg(struct m_can_priv *cdev, int reg, int val)
 	return 0;
 }
 
-static int iomap_write_fifo(struct m_can_priv *cdev, int offset, int val)
+static int iomap_write_fifo(struct m_can_classdev *cdev, int offset, int val)
 {
 	struct m_can_plat_priv *priv =
 			(struct m_can_plat_priv *)cdev->device_data;
@@ -59,7 +59,7 @@ static struct m_can_ops m_can_plat_ops = {
 
 static int m_can_plat_probe(struct platform_device *pdev)
 {
-	struct m_can_priv *mcan_class;
+	struct m_can_classdev *mcan_class;
 	struct m_can_plat_priv *priv;
 	struct resource *res;
 	void __iomem *addr;
@@ -131,7 +131,7 @@ static __maybe_unused int m_can_resume(struct device *dev)
 static int m_can_plat_remove(struct platform_device *pdev)
 {
 	struct net_device *dev = platform_get_drvdata(pdev);
-	struct m_can_priv *mcan_class = netdev_priv(dev);
+	struct m_can_classdev *mcan_class = netdev_priv(dev);
 
 	m_can_class_unregister(mcan_class);
 
@@ -143,7 +143,7 @@ static int m_can_plat_remove(struct platform_device *pdev)
 static int __maybe_unused m_can_runtime_suspend(struct device *dev)
 {
 	struct net_device *ndev = dev_get_drvdata(dev);
-	struct m_can_priv *mcan_class = netdev_priv(ndev);
+	struct m_can_classdev *mcan_class = netdev_priv(ndev);
 
 	m_can_class_suspend(dev);
 
@@ -156,7 +156,7 @@ static int __maybe_unused m_can_runtime_suspend(struct device *dev)
 static int __maybe_unused m_can_runtime_resume(struct device *dev)
 {
 	struct net_device *ndev = dev_get_drvdata(dev);
-	struct m_can_priv *mcan_class = netdev_priv(ndev);
+	struct m_can_classdev *mcan_class = netdev_priv(ndev);
 	int err;
 
 	err = clk_prepare_enable(mcan_class->hclk);

commit f524f829b75a7d934f56f63f2ed4d42f4e1d06d9
Author: Dan Murphy <dmurphy@ti.com>
Date:   Thu May 9 11:11:05 2019 -0500

    can: m_can: Create a m_can platform framework
    
    Create a m_can platform framework that peripheral
    devices can register to and use common code and register sets.
    The peripheral devices may provide read/write and configuration
    support of the IP.
    
    Acked-by: Wolfgang Grandegger <wg@grandegger.com>
    Signed-off-by: Dan Murphy <dmurphy@ti.com>
    Acked-by: Faiz Abbas <faiz_abbas@ti.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/m_can/m_can_platform.c b/drivers/net/can/m_can/m_can_platform.c
new file mode 100644
index 000000000000..026053f62f77
--- /dev/null
+++ b/drivers/net/can/m_can/m_can_platform.c
@@ -0,0 +1,202 @@
+// SPDX-License-Identifier: GPL-2.0
+// IOMapped CAN bus driver for Bosch M_CAN controller
+// Copyright (C) 2014 Freescale Semiconductor, Inc.
+//	Dong Aisheng <b29396@freescale.com>
+//
+// Copyright (C) 2018-19 Texas Instruments Incorporated - http://www.ti.com/
+
+#include <linux/platform_device.h>
+
+#include "m_can.h"
+
+struct m_can_plat_priv {
+	void __iomem *base;
+	void __iomem *mram_base;
+};
+
+static u32 iomap_read_reg(struct m_can_priv *cdev, int reg)
+{
+	struct m_can_plat_priv *priv =
+			(struct m_can_plat_priv *)cdev->device_data;
+
+	return readl(priv->base + reg);
+}
+
+static u32 iomap_read_fifo(struct m_can_priv *cdev, int offset)
+{
+	struct m_can_plat_priv *priv =
+			(struct m_can_plat_priv *)cdev->device_data;
+
+	return readl(priv->mram_base + offset);
+}
+
+static int iomap_write_reg(struct m_can_priv *cdev, int reg, int val)
+{
+	struct m_can_plat_priv *priv =
+			(struct m_can_plat_priv *)cdev->device_data;
+
+	writel(val, priv->base + reg);
+
+	return 0;
+}
+
+static int iomap_write_fifo(struct m_can_priv *cdev, int offset, int val)
+{
+	struct m_can_plat_priv *priv =
+			(struct m_can_plat_priv *)cdev->device_data;
+
+	writel(val, priv->mram_base + offset);
+
+	return 0;
+}
+
+static struct m_can_ops m_can_plat_ops = {
+	.read_reg = iomap_read_reg,
+	.write_reg = iomap_write_reg,
+	.write_fifo = iomap_write_fifo,
+	.read_fifo = iomap_read_fifo,
+};
+
+static int m_can_plat_probe(struct platform_device *pdev)
+{
+	struct m_can_priv *mcan_class;
+	struct m_can_plat_priv *priv;
+	struct resource *res;
+	void __iomem *addr;
+	void __iomem *mram_addr;
+	int irq, ret = 0;
+
+	mcan_class = m_can_class_allocate_dev(&pdev->dev);
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	mcan_class->device_data = priv;
+
+	m_can_class_get_clocks(mcan_class);
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "m_can");
+	addr = devm_ioremap_resource(&pdev->dev, res);
+	irq = platform_get_irq_byname(pdev, "int0");
+	if (IS_ERR(addr) || irq < 0) {
+		ret = -EINVAL;
+		goto failed_ret;
+	}
+
+	/* message ram could be shared */
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "message_ram");
+	if (!res) {
+		ret = -ENODEV;
+		goto failed_ret;
+	}
+
+	mram_addr = devm_ioremap(&pdev->dev, res->start, resource_size(res));
+	if (!mram_addr) {
+		ret = -ENOMEM;
+		goto failed_ret;
+	}
+
+	priv->base = addr;
+	priv->mram_base = mram_addr;
+
+	mcan_class->net->irq = irq;
+	mcan_class->pm_clock_support = 1;
+	mcan_class->can.clock.freq = clk_get_rate(mcan_class->cclk);
+	mcan_class->dev = &pdev->dev;
+
+	mcan_class->ops = &m_can_plat_ops;
+
+	mcan_class->is_peripheral = false;
+
+	platform_set_drvdata(pdev, mcan_class->dev);
+
+	m_can_init_ram(mcan_class);
+
+	ret = m_can_class_register(mcan_class);
+
+failed_ret:
+	return ret;
+}
+
+static __maybe_unused int m_can_suspend(struct device *dev)
+{
+	return m_can_class_suspend(dev);
+}
+
+static __maybe_unused int m_can_resume(struct device *dev)
+{
+	return m_can_class_resume(dev);
+}
+
+static int m_can_plat_remove(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct m_can_priv *mcan_class = netdev_priv(dev);
+
+	m_can_class_unregister(mcan_class);
+
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static int __maybe_unused m_can_runtime_suspend(struct device *dev)
+{
+	struct net_device *ndev = dev_get_drvdata(dev);
+	struct m_can_priv *mcan_class = netdev_priv(ndev);
+
+	m_can_class_suspend(dev);
+
+	clk_disable_unprepare(mcan_class->cclk);
+	clk_disable_unprepare(mcan_class->hclk);
+
+	return 0;
+}
+
+static int __maybe_unused m_can_runtime_resume(struct device *dev)
+{
+	struct net_device *ndev = dev_get_drvdata(dev);
+	struct m_can_priv *mcan_class = netdev_priv(ndev);
+	int err;
+
+	err = clk_prepare_enable(mcan_class->hclk);
+	if (err)
+		return err;
+
+	err = clk_prepare_enable(mcan_class->cclk);
+	if (err)
+		clk_disable_unprepare(mcan_class->hclk);
+
+	m_can_class_resume(dev);
+
+	return err;
+}
+
+static const struct dev_pm_ops m_can_pmops = {
+	SET_RUNTIME_PM_OPS(m_can_runtime_suspend,
+			   m_can_runtime_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(m_can_suspend, m_can_resume)
+};
+
+static const struct of_device_id m_can_of_table[] = {
+	{ .compatible = "bosch,m_can", .data = NULL },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, m_can_of_table);
+
+static struct platform_driver m_can_plat_driver = {
+	.driver = {
+		.name = KBUILD_MODNAME,
+		.of_match_table = m_can_of_table,
+		.pm     = &m_can_pmops,
+	},
+	.probe = m_can_plat_probe,
+	.remove = m_can_plat_remove,
+};
+
+module_platform_driver(m_can_plat_driver);
+
+MODULE_AUTHOR("Dong Aisheng <b29396@freescale.com>");
+MODULE_AUTHOR("Dan Murphy <dmurphy@ti.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("M_CAN driver for IO Mapped Bosch controllers");
