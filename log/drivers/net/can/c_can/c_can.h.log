commit 3cb3eaac52c0f145d895f4b6c22834d5f02b8569
Author: Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
Date:   Tue Oct 1 09:40:36 2019 +0200

    can: c_can: c_can_poll(): only read status register after status IRQ
    
    When the status register is read without the status IRQ pending, the
    chip may not raise the interrupt line for an upcoming status interrupt
    and the driver may miss a status interrupt.
    
    It is critical that the BUSOFF status interrupt is forwarded to the
    higher layers, since no more interrupts will follow without
    intervention.
    
    Thanks to Wolfgang and Joe for bringing up the first idea.
    
    Signed-off-by: Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
    Cc: Wolfgang Grandegger <wg@grandegger.com>
    Cc: Joe Burmeister <joe.burmeister@devtank.co.uk>
    Fixes: fa39b54ccf28 ("can: c_can: Get rid of pointless interrupts")
    Cc: linux-stable <stable@vger.kernel.org>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
index 8acdc7fa4792..d5567a7c1c6d 100644
--- a/drivers/net/can/c_can/c_can.h
+++ b/drivers/net/can/c_can/c_can.h
@@ -198,6 +198,7 @@ struct c_can_priv {
 	struct net_device *dev;
 	struct device *device;
 	atomic_t tx_active;
+	atomic_t sie_pending;
 	unsigned long tx_dir;
 	int last_status;
 	u16 (*read_reg) (const struct c_can_priv *priv, enum reg index);

commit 0741bfb9395ad176be91f66d2ef3f6f669e27890
Author: Roger Quadros <rogerq@ti.com>
Date:   Fri Nov 7 16:49:19 2014 +0200

    can: c_can: Add support for START pulse in RAMINIT sequence
    
    Some SoCs e.g. (TI DRA7xx) need a START pulse to start the
    RAMINIT sequence i.e. START bit must be set and cleared before
    checking for the DONE bit status.
    
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
index 28a73d14ea8d..8acdc7fa4792 100644
--- a/drivers/net/can/c_can/c_can.h
+++ b/drivers/net/can/c_can/c_can.h
@@ -188,6 +188,7 @@ struct c_can_raminit {
 	struct regmap *syscon;	/* for raminit ctrl. reg. access */
 	unsigned int reg;	/* register index within syscon */
 	struct raminit_bits bits;
+	bool needs_pulse;
 };
 
 /* c_can private data structure */

commit 3ff9027ca6b00e194d2eae353febf7233cfcc1ea
Author: Roger Quadros <rogerq@ti.com>
Date:   Fri Nov 14 17:37:39 2014 +0200

    can: c_can: Add syscon/regmap RAMINIT mechanism
    
    Some TI SoCs like DRA7 have a RAMINIT register specification
    different from the other AMxx SoCs and as expected by the
    existing driver.
    
    To add more insanity, this register is shared with other
    IPs like DSS, PCIe and PWM.
    
    Provides a more generic mechanism to specify the RAMINIT
    register location and START/DONE bit position and use the
    syscon/regmap framework to access the register.
    
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
index 3f111f4f0f6e..28a73d14ea8d 100644
--- a/drivers/net/can/c_can/c_can.h
+++ b/drivers/net/can/c_can/c_can.h
@@ -183,6 +183,13 @@ struct c_can_driver_data {
 	bool raminit_pulse;	/* If set, sets and clears START bit (pulse) */
 };
 
+/* Out of band RAMINIT register access via syscon regmap */
+struct c_can_raminit {
+	struct regmap *syscon;	/* for raminit ctrl. reg. access */
+	unsigned int reg;	/* register index within syscon */
+	struct raminit_bits bits;
+};
+
 /* c_can private data structure */
 struct c_can_priv {
 	struct can_priv can;	/* must be the first member */
@@ -200,8 +207,7 @@ struct c_can_priv {
 	const u16 *regs;
 	void *priv;		/* for board-specific data */
 	enum c_can_dev_id type;
-	u32 __iomem *raminit_ctrlreg;
-	int instance;
+	struct c_can_raminit raminit_sys;	/* RAMINIT via syscon regmap */
 	void (*raminit) (const struct c_can_priv *priv, bool enable);
 	u32 comm_rcv_high;
 	u32 rxmasked;

commit bbf914300509f038c807360d755bd606785be6c9
Author: Roger Quadros <rogerq@ti.com>
Date:   Fri Nov 7 16:49:17 2014 +0200

    can: c_can: Add RAMINIT register information to driver data
    
    Some platforms (e.g. TI) need special RAMINIT register handling.
    Provide a way to store RAMINIT register description in driver data.
    
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
index 26c975d914e3..3f111f4f0f6e 100644
--- a/drivers/net/can/c_can/c_can.h
+++ b/drivers/net/can/c_can/c_can.h
@@ -169,8 +169,18 @@ enum c_can_dev_id {
 	BOSCH_D_CAN,
 };
 
+struct raminit_bits {
+	u8 start;
+	u8 done;
+};
+
 struct c_can_driver_data {
 	enum c_can_dev_id id;
+
+	/* RAMINIT register description. Optional. */
+	const struct raminit_bits *raminit_bits; /* Array of START/DONE bit positions */
+	u8 raminit_num;		/* Number of CAN instances on the SoC */
+	bool raminit_pulse;	/* If set, sets and clears START bit (pulse) */
 };
 
 /* c_can private data structure */

commit 15151090579cab7c49d8af54a52f798ce8bda001
Author: Roger Quadros <rogerq@ti.com>
Date:   Fri Nov 7 16:49:16 2014 +0200

    can: c_can: Introduce c_can_driver_data structure
    
    We want to have more data than just can_dev_id to be present
    in the driver data e.g. TI platforms need RAMINIT register
    description. Introduce the c_can_driver_data structure and move
    the can_dev_id into it.
    
    Tidy up the way it is used on probe().
    
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
index 99ad1aa576b0..26c975d914e3 100644
--- a/drivers/net/can/c_can/c_can.h
+++ b/drivers/net/can/c_can/c_can.h
@@ -169,6 +169,10 @@ enum c_can_dev_id {
 	BOSCH_D_CAN,
 };
 
+struct c_can_driver_data {
+	enum c_can_dev_id id;
+};
+
 /* c_can private data structure */
 struct c_can_priv {
 	struct can_priv can;	/* must be the first member */

commit a9c692099e2c6f85d2213be75095593311074ce1
Author: Pavel Machek <pavel@denx.de>
Date:   Tue May 13 15:09:14 2014 +0200

    can: c_can: add hwinit support for non-TI devices
    
    Non-TI chips (including socfpga) needs different raminit sequence. Implement
    it.
    
    Tested-by: Thor Thayer <tthayer@altera.com>
    Signed-off-by: Thor Thayer <tthayer@altera.com>
    Signed-off-by: Pavel Machek <pavel@denx.de>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
index 44433e1ebe00..99ad1aa576b0 100644
--- a/drivers/net/can/c_can/c_can.h
+++ b/drivers/net/can/c_can/c_can.h
@@ -78,6 +78,7 @@ enum reg {
 	C_CAN_INTPND2_REG,
 	C_CAN_MSGVAL1_REG,
 	C_CAN_MSGVAL2_REG,
+	C_CAN_FUNCTION_REG,
 };
 
 static const u16 reg_map_c_can[] = {
@@ -129,6 +130,7 @@ static const u16 reg_map_d_can[] = {
 	[C_CAN_BRPEXT_REG]	= 0x0E,
 	[C_CAN_INT_REG]		= 0x10,
 	[C_CAN_TEST_REG]	= 0x14,
+	[C_CAN_FUNCTION_REG]	= 0x18,
 	[C_CAN_TXRQST1_REG]	= 0x88,
 	[C_CAN_TXRQST2_REG]	= 0x8A,
 	[C_CAN_NEWDAT1_REG]	= 0x9C,

commit ccbc5357db3098c57176945f677b0af37f5e87e6
Author: Pavel Machek <pavel@denx.de>
Date:   Tue May 6 15:57:02 2014 +0200

    can: c_can: Add and make use of 32-bit accesses functions
    
    Add helpers for 32-bit accesses and replace open-coded 32-bit access
    with calls to helpers. Minimum changes are done to the pci case, as I
    don't have access to that hardware.
    
    Tested-by: Thor Thayer <tthayer@altera.com>
    Signed-off-by: Thor Thayer <tthayer@altera.com>
    Signed-off-by: Pavel Machek <pavel@denx.de>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
index b948b552a210..44433e1ebe00 100644
--- a/drivers/net/can/c_can/c_can.h
+++ b/drivers/net/can/c_can/c_can.h
@@ -178,6 +178,8 @@ struct c_can_priv {
 	int last_status;
 	u16 (*read_reg) (const struct c_can_priv *priv, enum reg index);
 	void (*write_reg) (const struct c_can_priv *priv, enum reg index, u16 val);
+	u32 (*read_reg32) (const struct c_can_priv *priv, enum reg index);
+	void (*write_reg32) (const struct c_can_priv *priv, enum reg index, u32 val);
 	void __iomem *base;
 	const u16 *regs;
 	void *priv;		/* for board-specific data */

commit e07e83ae600ea51b857e02132220eb7b7e52e928
Author: Pavel Machek <pavel@denx.de>
Date:   Tue May 13 15:09:14 2014 +0200

    can: c_can: make {read,write}_reg functions const
    
    This patch makes the {read,write}_reg functions const, this is a preparation to
    make use of {read,write}_reg in the hwinit callback.
    
    Signed-off-by: Thor Thayer <tthayer@altera.com>
    Signed-off-by: Pavel Machek <pavel@denx.de>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
index c56f1b1c11ca..b948b552a210 100644
--- a/drivers/net/can/c_can/c_can.h
+++ b/drivers/net/can/c_can/c_can.h
@@ -176,8 +176,8 @@ struct c_can_priv {
 	atomic_t tx_active;
 	unsigned long tx_dir;
 	int last_status;
-	u16 (*read_reg) (struct c_can_priv *priv, enum reg index);
-	void (*write_reg) (struct c_can_priv *priv, enum reg index, u16 val);
+	u16 (*read_reg) (const struct c_can_priv *priv, enum reg index);
+	void (*write_reg) (const struct c_can_priv *priv, enum reg index, u16 val);
 	void __iomem *base;
 	const u16 *regs;
 	void *priv;		/* for board-specific data */

commit f323d7a1d2868c00b2604dca36ad82e8ecbe4270
Author: Wolfram Sang <wsa@sang-engineering.com>
Date:   Thu Apr 17 10:57:18 2014 +0200

    can: c_can: use proper type for 'instance'
    
    Commit 6439fbce1075 (can: c_can: fix error checking of priv->instance in
    probe()) found the warning but applied a suboptimal solution. Since, both
    pdev->id and of_alias_get_id() return integers, it makes sense to convert the
    variable to an integer and avoid the cast.
    
    Signed-off-by: Wolfram Sang <wsa@sang-engineering.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
index e7de2b9f26bb..c56f1b1c11ca 100644
--- a/drivers/net/can/c_can/c_can.h
+++ b/drivers/net/can/c_can/c_can.h
@@ -183,7 +183,7 @@ struct c_can_priv {
 	void *priv;		/* for board-specific data */
 	enum c_can_dev_id type;
 	u32 __iomem *raminit_ctrlreg;
-	unsigned int instance;
+	int instance;
 	void (*raminit) (const struct c_can_priv *priv, bool enable);
 	u32 comm_rcv_high;
 	u32 rxmasked;

commit 939415973fdfb2c16a474e2575ba2581b828ccac
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 11 08:13:22 2014 +0000

    can: c_can: Speed up tx buffer invalidation
    
    It's suffcient to kill the TXIE bit in the message control register
    even if the documentation of C and D CAN says that it's not allowed to
    do that while MSGVAL is set. Reality tells a different story and this
    change gives us another 2% of CPU back for not waiting on I/O.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Alexander Stein <alexander.stein@systec-electronic.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
index a5f10a01e49f..e7de2b9f26bb 100644
--- a/drivers/net/can/c_can/c_can.h
+++ b/drivers/net/can/c_can/c_can.h
@@ -174,6 +174,7 @@ struct c_can_priv {
 	struct net_device *dev;
 	struct device *device;
 	atomic_t tx_active;
+	unsigned long tx_dir;
 	int last_status;
 	u16 (*read_reg) (struct c_can_priv *priv, enum reg index);
 	void (*write_reg) (struct c_can_priv *priv, enum reg index, u16 val);

commit 35bdafb576c5c0a06815e7a681571c3ab950ff7e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 11 08:13:22 2014 +0000

    can: c_can: Remove tx locking
    
    Mark suggested to use one IF for the softirq and the other for the
    xmit function to avoid the xmit lock.
    
    That requires to write the frame into the interface first, then handle
    the echo skb and store the dlc before committing the TX request to the
    message ram.
    
    We use an atomic to handle the active buffers instead of reading the
    MSGVAL register as thats way faster especially on PCH/x86.
    
    Suggested-by: Mark <mark5@del-llc.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Alexander Stein <alexander.stein@systec-electronic.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
index d9f59cc4fcb5..a5f10a01e49f 100644
--- a/drivers/net/can/c_can/c_can.h
+++ b/drivers/net/can/c_can/c_can.h
@@ -37,8 +37,6 @@
 
 #define C_CAN_MSG_OBJ_RX_SPLIT	9
 #define C_CAN_MSG_RX_LOW_LAST	(C_CAN_MSG_OBJ_RX_SPLIT - 1)
-
-#define C_CAN_NEXT_MSG_OBJ_MASK	(C_CAN_MSG_OBJ_TX_NUM - 1)
 #define RECEIVE_OBJECT_BITS	0x0000ffff
 
 enum reg {
@@ -175,16 +173,12 @@ struct c_can_priv {
 	struct napi_struct napi;
 	struct net_device *dev;
 	struct device *device;
-	spinlock_t xmit_lock;
-	int tx_object;
+	atomic_t tx_active;
 	int last_status;
 	u16 (*read_reg) (struct c_can_priv *priv, enum reg index);
 	void (*write_reg) (struct c_can_priv *priv, enum reg index, u16 val);
 	void __iomem *base;
 	const u16 *regs;
-	unsigned long irq_flags; /* for request_irq() */
-	unsigned int tx_next;
-	unsigned int tx_echo;
 	void *priv;		/* for board-specific data */
 	enum c_can_dev_id type;
 	u32 __iomem *raminit_ctrlreg;

commit 23ef0a895dd3f115909ca70958aeb3d04f374b0d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 11 08:13:21 2014 +0000

    can: c_can: Cleanup c_can_write_msg_object()
    
    Remove the MASK from the TX transfer side.
    
    Make the code readable and get rid of the annoying IFX_WRITE_XXX_16BIT
    macros which are just obfuscating the code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Alexander Stein <alexander.stein@systec-electronic.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
index 792944c74b94..d9f59cc4fcb5 100644
--- a/drivers/net/can/c_can/c_can.h
+++ b/drivers/net/can/c_can/c_can.h
@@ -22,14 +22,6 @@
 #ifndef C_CAN_H
 #define C_CAN_H
 
-/*
- * IFx register masks:
- * allow easy operation on 16-bit registers when the
- * argument is 32-bit instead
- */
-#define IFX_WRITE_LOW_16BIT(x)	((x) & 0xFFFF)
-#define IFX_WRITE_HIGH_16BIT(x)	(((x) & 0xFFFF0000) >> 16)
-
 /* message object split */
 #define C_CAN_NO_OF_OBJECTS	32
 #define C_CAN_MSG_OBJ_RX_NUM	16

commit d61d09de023320b95a536eb4d31941e67002a93c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 11 08:13:17 2014 +0000

    can: c_can: Work around C_CAN RX wreckage
    
    Alexander reported that the new optimized handling of the RX fifo
    causes random packet loss on Intel PCH C_CAN hardware.
    
    After a few fruitless debugging sessions I got hold of a PCH (eg20t)
    afflicted system. That machine does not have the CAN interface wired
    up, but it was possible to reproduce the issue with the HW loopback
    mode.
    
    As Alexander observed correctly, clearing the NewDat flag along with
    reading out the message buffer causes that issue on C_CAN, while D_CAN
    handles that correctly.
    
    Instead of restoring the original message buffer handling horror the
    following workaround solves the issue:
    
        transfer buffer to IF without clearing the NewDat
        handle the message
        clear NewDat bit
    
    That's similar to the original code but conditional for C_CAN.
    
    I really wonder why all user manuals (C_CAN, Intel PCH and some more)
    recommend to clear the NewDat bit right away. The knows it all Oracle
    operated by Gurgle does not unearth any useful information either. I
    simply cannot believe that we are the first to uncover that HW issue.
    
    Reported-and-tested-by: Alexander Stein <alexander.stein@systec-electronic.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
index cd91960ce92c..792944c74b94 100644
--- a/drivers/net/can/c_can/c_can.h
+++ b/drivers/net/can/c_can/c_can.h
@@ -198,6 +198,7 @@ struct c_can_priv {
 	u32 __iomem *raminit_ctrlreg;
 	unsigned int instance;
 	void (*raminit) (const struct c_can_priv *priv, bool enable);
+	u32 comm_rcv_high;
 	u32 rxmasked;
 	u32 dlc[C_CAN_MSG_OBJ_TX_NUM];
 };

commit fa39b54ccf28a0a85256f04881297cd75b8ef204
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 11 08:13:15 2014 +0000

    can: c_can: Get rid of pointless interrupts
    
    The driver handles pointlessly TWO interrupts per packet. The reason
    is that it enables the status interrupt which fires for each rx and tx
    packet and it enables the per message object interrupts as well.
    
    The status interrupt merily acks or in case of D_CAN ignores the TX/RX
    state and then the message object interrupt fires.
    
    The message objects interrupts are only useful if all message objects
    have hardware filters activated.
    
    But we don't have that and its not simple to implement in that driver
    without rewriting it completely.
    
    So we can ditch the message object interrupts and handle the RX/TX
    right away from the status interrupt. Instead of TWO we handle ONE.
    
    Note: We must keep the TXIE/RXIE bits in the message buffers because
    the status interrupt alone is not reliable enough in corner cases.
    
    If we ever have the need for HW filtering, then this code needs a
    complete overhaul and we can think about it then. For now we prefer a
    lower interrupt load.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Alexander Stein <alexander.stein@systec-electronic.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
index faa8404162b3..cd91960ce92c 100644
--- a/drivers/net/can/c_can/c_can.h
+++ b/drivers/net/can/c_can/c_can.h
@@ -185,7 +185,6 @@ struct c_can_priv {
 	struct device *device;
 	spinlock_t xmit_lock;
 	int tx_object;
-	int current_status;
 	int last_status;
 	u16 (*read_reg) (struct c_can_priv *priv, enum reg index);
 	void (*write_reg) (struct c_can_priv *priv, enum reg index, u16 val);
@@ -195,11 +194,11 @@ struct c_can_priv {
 	unsigned int tx_next;
 	unsigned int tx_echo;
 	void *priv;		/* for board-specific data */
-	u16 irqstatus;
 	enum c_can_dev_id type;
 	u32 __iomem *raminit_ctrlreg;
 	unsigned int instance;
 	void (*raminit) (const struct c_can_priv *priv, bool enable);
+	u32 rxmasked;
 	u32 dlc[C_CAN_MSG_OBJ_TX_NUM];
 };
 

commit 902470085406934d3f20c4af02de7d79c01b6b93
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Mar 18 17:19:14 2014 +0000

    can: c_can: Store dlc private
    
    We can avoid the HW access in TX cleanup path for retrieving the DLC
    of the sent package if we store the DLC in a private array.
    
    Ideally this should be handled in the can_echo_skb functions, but I
    leave that exercise to the CAN folks.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
index 5097c802a61e..faa8404162b3 100644
--- a/drivers/net/can/c_can/c_can.h
+++ b/drivers/net/can/c_can/c_can.h
@@ -22,6 +22,33 @@
 #ifndef C_CAN_H
 #define C_CAN_H
 
+/*
+ * IFx register masks:
+ * allow easy operation on 16-bit registers when the
+ * argument is 32-bit instead
+ */
+#define IFX_WRITE_LOW_16BIT(x)	((x) & 0xFFFF)
+#define IFX_WRITE_HIGH_16BIT(x)	(((x) & 0xFFFF0000) >> 16)
+
+/* message object split */
+#define C_CAN_NO_OF_OBJECTS	32
+#define C_CAN_MSG_OBJ_RX_NUM	16
+#define C_CAN_MSG_OBJ_TX_NUM	16
+
+#define C_CAN_MSG_OBJ_RX_FIRST	1
+#define C_CAN_MSG_OBJ_RX_LAST	(C_CAN_MSG_OBJ_RX_FIRST + \
+				C_CAN_MSG_OBJ_RX_NUM - 1)
+
+#define C_CAN_MSG_OBJ_TX_FIRST	(C_CAN_MSG_OBJ_RX_LAST + 1)
+#define C_CAN_MSG_OBJ_TX_LAST	(C_CAN_MSG_OBJ_TX_FIRST + \
+				C_CAN_MSG_OBJ_TX_NUM - 1)
+
+#define C_CAN_MSG_OBJ_RX_SPLIT	9
+#define C_CAN_MSG_RX_LOW_LAST	(C_CAN_MSG_OBJ_RX_SPLIT - 1)
+
+#define C_CAN_NEXT_MSG_OBJ_MASK	(C_CAN_MSG_OBJ_TX_NUM - 1)
+#define RECEIVE_OBJECT_BITS	0x0000ffff
+
 enum reg {
 	C_CAN_CTRL_REG = 0,
 	C_CAN_CTRL_EX_REG,
@@ -173,6 +200,7 @@ struct c_can_priv {
 	u32 __iomem *raminit_ctrlreg;
 	unsigned int instance;
 	void (*raminit) (const struct c_can_priv *priv, bool enable);
+	u32 dlc[C_CAN_MSG_OBJ_TX_NUM];
 };
 
 struct net_device *alloc_c_can_dev(void);

commit bf88a20611d5a62119a02da4eba95b461ec692c8
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Mar 18 17:19:12 2014 +0000

    can: c_can: Provide protection in the xmit path
    
    The network core does not serialize the access to the hardware. The
    xmit related code lets the following happen:
    
    CPU0                   CPU1
    interrupt()
     do_poll()
       c_can_do_tx()
        Fiddle with HW and  xmit()
        internal data         Fiddle with HW and
                              internal data
    
    due the complete lack of serialization.
    
    Add proper locking.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
index d2e1c21b143f..5097c802a61e 100644
--- a/drivers/net/can/c_can/c_can.h
+++ b/drivers/net/can/c_can/c_can.h
@@ -156,6 +156,7 @@ struct c_can_priv {
 	struct napi_struct napi;
 	struct net_device *dev;
 	struct device *device;
+	spinlock_t xmit_lock;
 	int tx_object;
 	int current_status;
 	int last_status;

commit 52cde85acc23f61b09dd0376c61eb891125c6990
Author: AnilKumar Ch <anilkumar@ti.com>
Date:   Wed Nov 21 11:14:10 2012 +0530

    can: c_can: Add d_can raminit support
    
    Add D_CAN raminit support to C_CAN driver to enable D_CAN RAM,
    which holds all the message objects during transmission or
    receiving of data. This initialization/de-initialization should
    be done in synchronous with D_CAN clock.
    
    In case of AM335X-EVM (current user of D_CAN driver) message RAM is
    controlled through control module register for both instances. So
    control module register details is required to initialization or
    de-initialization of message RAM according to instance number.
    
    Control module memory resource is obtained from D_CAN dt node and
    instance number obtained from device tree aliases node.
    
    This patch was tested on AM335x-EVM along with pinctrl data addition
    patch, d_can dt aliases addition and control module data addition.
    pinctrl data addition is not added to am335x-evm.dts (only supports
    CPLD profile#0) because d_can1 is supported under CPLD profile#1.
    
    Signed-off-by: AnilKumar Ch <anilkumar@ti.com>
    [mkl: fix instance for non DT in probe, cleaned up raminit]
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
index e5ed41dafa1b..d2e1c21b143f 100644
--- a/drivers/net/can/c_can/c_can.h
+++ b/drivers/net/can/c_can/c_can.h
@@ -169,6 +169,9 @@ struct c_can_priv {
 	void *priv;		/* for board-specific data */
 	u16 irqstatus;
 	enum c_can_dev_id type;
+	u32 __iomem *raminit_ctrlreg;
+	unsigned int instance;
+	void (*raminit) (const struct c_can_priv *priv, bool enable);
 };
 
 struct net_device *alloc_c_can_dev(void);

commit 8212003260c600b9b55a79634fb29d0f7ec813d9
Author: AnilKumar Ch <anilkumar@ti.com>
Date:   Fri Sep 21 15:29:01 2012 +0530

    can: c_can: Add d_can suspend resume support
    
    Adds suspend resume support to DCAN driver which enables
    DCAN power down mode bit (PDR). Then DCAN will ack the local
    power-down mode by setting PDA bit in STATUS register.
    
    Signed-off-by: AnilKumar Ch <anilkumar@ti.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
index 1437a6dbdca5..e5ed41dafa1b 100644
--- a/drivers/net/can/c_can/c_can.h
+++ b/drivers/net/can/c_can/c_can.h
@@ -24,6 +24,7 @@
 
 enum reg {
 	C_CAN_CTRL_REG = 0,
+	C_CAN_CTRL_EX_REG,
 	C_CAN_STS_REG,
 	C_CAN_ERR_CNT_REG,
 	C_CAN_BTR_REG,
@@ -104,6 +105,7 @@ static const u16 reg_map_c_can[] = {
 
 static const u16 reg_map_d_can[] = {
 	[C_CAN_CTRL_REG]	= 0x00,
+	[C_CAN_CTRL_EX_REG]	= 0x02,
 	[C_CAN_STS_REG]		= 0x04,
 	[C_CAN_ERR_CNT_REG]	= 0x08,
 	[C_CAN_BTR_REG]		= 0x0C,
@@ -166,6 +168,7 @@ struct c_can_priv {
 	unsigned int tx_echo;
 	void *priv;		/* for board-specific data */
 	u16 irqstatus;
+	enum c_can_dev_id type;
 };
 
 struct net_device *alloc_c_can_dev(void);
@@ -173,4 +176,9 @@ void free_c_can_dev(struct net_device *dev);
 int register_c_can_dev(struct net_device *dev);
 void unregister_c_can_dev(struct net_device *dev);
 
+#ifdef CONFIG_PM
+int c_can_power_up(struct net_device *dev);
+int c_can_power_down(struct net_device *dev);
+#endif
+
 #endif /* C_CAN_H */

commit 4cdd34b26826e89972c03043987b83f76e7ad510
Author: AnilKumar Ch <anilkumar@ti.com>
Date:   Mon Aug 20 16:50:54 2012 +0530

    can: c_can: Add runtime PM support to Bosch C_CAN/D_CAN controller
    
    Add Runtime PM support to C_CAN/D_CAN controller. The runtime PM
    APIs control clocks for C_CAN/D_CAN IP and prevent access to the
    register of C_CAN/D_CAN IP when clock is turned off.
    
    Signed-off-by: AnilKumar Ch <anilkumar@ti.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
index 4e56baa9c2da..1437a6dbdca5 100644
--- a/drivers/net/can/c_can/c_can.h
+++ b/drivers/net/can/c_can/c_can.h
@@ -153,6 +153,7 @@ struct c_can_priv {
 	struct can_priv can;	/* must be the first member */
 	struct napi_struct napi;
 	struct net_device *dev;
+	struct device *device;
 	int tx_object;
 	int current_status;
 	int last_status;

commit f27b1db95d047d05e8d4dd22813b1078267892f2
Author: AnilKumar Ch <anilkumar@ti.com>
Date:   Thu Aug 2 18:43:09 2012 +0530

    can: c_can: Modify c_can device names
    
    Modify c_can device names from *_CAN_DEVTYPE to BOSCH_*_CAN to make
    use of same names for array indexes in c_can_id_table[] as well as
    device names.
    
    This patch also add indexes to c_can_id_table array.
    
    Signed-off-by: AnilKumar Ch <anilkumar@ti.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
index 01a7049ab990..4e56baa9c2da 100644
--- a/drivers/net/can/c_can/c_can.h
+++ b/drivers/net/can/c_can/c_can.h
@@ -143,8 +143,9 @@ static const u16 reg_map_d_can[] = {
 };
 
 enum c_can_dev_id {
-	C_CAN_DEVTYPE,
-	D_CAN_DEVTYPE,
+	BOSCH_C_CAN_PLATFORM,
+	BOSCH_C_CAN,
+	BOSCH_D_CAN,
 };
 
 /* c_can private data structure */

commit 69927fccd96b15bd228bb82d356a7a2a0cfaeefb
Author: AnilKumar Ch <anilkumar@ti.com>
Date:   Tue May 29 11:13:16 2012 +0530

    can: c_can: Add support for Bosch D_CAN controller
    
    This patch adds the support for D_CAN controller driver to the existing
    C_CAN driver.
    
    Bosch D_CAN controller is a full-CAN implementation which is compliant
    to CAN protocol version 2.0 part A and B. Bosch D_CAN user manual can be
    obtained from: http://www.semiconductors.bosch.de/media/en/pdf/
    ipmodules_1/can/d_can_users_manual_111.pdf
    
    A new array is added for accessing the d_can registers, according to d_can
    controller register space.
    
    Current D_CAN implementation has following limitations, this is done
    to avoid large changes to the C_CAN driver.
    1. Message objects are limited to 32, 16 for RX and 16 for TX. C_CAN IP
       supports upto 32 message objects but in case of D_CAN we can configure
       upto 128 message objects.
    2. Using two 16bit reads/writes for accessing the 32bit D_CAN registers.
    3. These patches have been tested on little endian machine, there might
       be some hidden endian-related issues due to the nature of the accesses
       (32-bit registers accessed as 2 16-bit registers). However, I do not
       have a big-endian D_CAN implementation to confirm.
    
    Signed-off-by: AnilKumar Ch <anilkumar@ti.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
index d1e141e3b99c..01a7049ab990 100644
--- a/drivers/net/can/c_can/c_can.h
+++ b/drivers/net/can/c_can/c_can.h
@@ -102,6 +102,51 @@ static const u16 reg_map_c_can[] = {
 	[C_CAN_MSGVAL2_REG]	= 0xB2,
 };
 
+static const u16 reg_map_d_can[] = {
+	[C_CAN_CTRL_REG]	= 0x00,
+	[C_CAN_STS_REG]		= 0x04,
+	[C_CAN_ERR_CNT_REG]	= 0x08,
+	[C_CAN_BTR_REG]		= 0x0C,
+	[C_CAN_BRPEXT_REG]	= 0x0E,
+	[C_CAN_INT_REG]		= 0x10,
+	[C_CAN_TEST_REG]	= 0x14,
+	[C_CAN_TXRQST1_REG]	= 0x88,
+	[C_CAN_TXRQST2_REG]	= 0x8A,
+	[C_CAN_NEWDAT1_REG]	= 0x9C,
+	[C_CAN_NEWDAT2_REG]	= 0x9E,
+	[C_CAN_INTPND1_REG]	= 0xB0,
+	[C_CAN_INTPND2_REG]	= 0xB2,
+	[C_CAN_MSGVAL1_REG]	= 0xC4,
+	[C_CAN_MSGVAL2_REG]	= 0xC6,
+	[C_CAN_IF1_COMREQ_REG]	= 0x100,
+	[C_CAN_IF1_COMMSK_REG]	= 0x102,
+	[C_CAN_IF1_MASK1_REG]	= 0x104,
+	[C_CAN_IF1_MASK2_REG]	= 0x106,
+	[C_CAN_IF1_ARB1_REG]	= 0x108,
+	[C_CAN_IF1_ARB2_REG]	= 0x10A,
+	[C_CAN_IF1_MSGCTRL_REG]	= 0x10C,
+	[C_CAN_IF1_DATA1_REG]	= 0x110,
+	[C_CAN_IF1_DATA2_REG]	= 0x112,
+	[C_CAN_IF1_DATA3_REG]	= 0x114,
+	[C_CAN_IF1_DATA4_REG]	= 0x116,
+	[C_CAN_IF2_COMREQ_REG]	= 0x120,
+	[C_CAN_IF2_COMMSK_REG]	= 0x122,
+	[C_CAN_IF2_MASK1_REG]	= 0x124,
+	[C_CAN_IF2_MASK2_REG]	= 0x126,
+	[C_CAN_IF2_ARB1_REG]	= 0x128,
+	[C_CAN_IF2_ARB2_REG]	= 0x12A,
+	[C_CAN_IF2_MSGCTRL_REG]	= 0x12C,
+	[C_CAN_IF2_DATA1_REG]	= 0x130,
+	[C_CAN_IF2_DATA2_REG]	= 0x132,
+	[C_CAN_IF2_DATA3_REG]	= 0x134,
+	[C_CAN_IF2_DATA4_REG]	= 0x136,
+};
+
+enum c_can_dev_id {
+	C_CAN_DEVTYPE,
+	D_CAN_DEVTYPE,
+};
+
 /* c_can private data structure */
 struct c_can_priv {
 	struct can_priv can;	/* must be the first member */

commit 33f8100977693fa09c2a32b1ca6dbf4d6eabdd0c
Author: AnilKumar Ch <anilkumar@ti.com>
Date:   Tue May 29 11:13:15 2012 +0530

    can: c_can: Move overlay structure to array with offset as index
    
    c_can uses overlay structure for accessing c_can module registers.
    With this kind of implementation it is difficult to add one more ip
    which is similar to c_can in functionality but different register
    offsets.
    
    This patch changes the overlay structure implementation to an array
    with register offset as index. This way we can overcome the above
    limitation.
    
    Signed-off-by: AnilKumar Ch <anilkumar@ti.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
index 5f32d34af507..d1e141e3b99c 100644
--- a/drivers/net/can/c_can/c_can.h
+++ b/drivers/net/can/c_can/c_can.h
@@ -22,43 +22,84 @@
 #ifndef C_CAN_H
 #define C_CAN_H
 
-/* c_can IF registers */
-struct c_can_if_regs {
-	u16 com_req;
-	u16 com_mask;
-	u16 mask1;
-	u16 mask2;
-	u16 arb1;
-	u16 arb2;
-	u16 msg_cntrl;
-	u16 data[4];
-	u16 _reserved[13];
+enum reg {
+	C_CAN_CTRL_REG = 0,
+	C_CAN_STS_REG,
+	C_CAN_ERR_CNT_REG,
+	C_CAN_BTR_REG,
+	C_CAN_INT_REG,
+	C_CAN_TEST_REG,
+	C_CAN_BRPEXT_REG,
+	C_CAN_IF1_COMREQ_REG,
+	C_CAN_IF1_COMMSK_REG,
+	C_CAN_IF1_MASK1_REG,
+	C_CAN_IF1_MASK2_REG,
+	C_CAN_IF1_ARB1_REG,
+	C_CAN_IF1_ARB2_REG,
+	C_CAN_IF1_MSGCTRL_REG,
+	C_CAN_IF1_DATA1_REG,
+	C_CAN_IF1_DATA2_REG,
+	C_CAN_IF1_DATA3_REG,
+	C_CAN_IF1_DATA4_REG,
+	C_CAN_IF2_COMREQ_REG,
+	C_CAN_IF2_COMMSK_REG,
+	C_CAN_IF2_MASK1_REG,
+	C_CAN_IF2_MASK2_REG,
+	C_CAN_IF2_ARB1_REG,
+	C_CAN_IF2_ARB2_REG,
+	C_CAN_IF2_MSGCTRL_REG,
+	C_CAN_IF2_DATA1_REG,
+	C_CAN_IF2_DATA2_REG,
+	C_CAN_IF2_DATA3_REG,
+	C_CAN_IF2_DATA4_REG,
+	C_CAN_TXRQST1_REG,
+	C_CAN_TXRQST2_REG,
+	C_CAN_NEWDAT1_REG,
+	C_CAN_NEWDAT2_REG,
+	C_CAN_INTPND1_REG,
+	C_CAN_INTPND2_REG,
+	C_CAN_MSGVAL1_REG,
+	C_CAN_MSGVAL2_REG,
 };
 
-/* c_can hardware registers */
-struct c_can_regs {
-	u16 control;
-	u16 status;
-	u16 err_cnt;
-	u16 btr;
-	u16 interrupt;
-	u16 test;
-	u16 brp_ext;
-	u16 _reserved1;
-	struct c_can_if_regs ifregs[2]; /* [0] = IF1 and [1] = IF2 */
-	u16 _reserved2[8];
-	u16 txrqst1;
-	u16 txrqst2;
-	u16 _reserved3[6];
-	u16 newdat1;
-	u16 newdat2;
-	u16 _reserved4[6];
-	u16 intpnd1;
-	u16 intpnd2;
-	u16 _reserved5[6];
-	u16 msgval1;
-	u16 msgval2;
-	u16 _reserved6[6];
+static const u16 reg_map_c_can[] = {
+	[C_CAN_CTRL_REG]	= 0x00,
+	[C_CAN_STS_REG]		= 0x02,
+	[C_CAN_ERR_CNT_REG]	= 0x04,
+	[C_CAN_BTR_REG]		= 0x06,
+	[C_CAN_INT_REG]		= 0x08,
+	[C_CAN_TEST_REG]	= 0x0A,
+	[C_CAN_BRPEXT_REG]	= 0x0C,
+	[C_CAN_IF1_COMREQ_REG]	= 0x10,
+	[C_CAN_IF1_COMMSK_REG]	= 0x12,
+	[C_CAN_IF1_MASK1_REG]	= 0x14,
+	[C_CAN_IF1_MASK2_REG]	= 0x16,
+	[C_CAN_IF1_ARB1_REG]	= 0x18,
+	[C_CAN_IF1_ARB2_REG]	= 0x1A,
+	[C_CAN_IF1_MSGCTRL_REG]	= 0x1C,
+	[C_CAN_IF1_DATA1_REG]	= 0x1E,
+	[C_CAN_IF1_DATA2_REG]	= 0x20,
+	[C_CAN_IF1_DATA3_REG]	= 0x22,
+	[C_CAN_IF1_DATA4_REG]	= 0x24,
+	[C_CAN_IF2_COMREQ_REG]	= 0x40,
+	[C_CAN_IF2_COMMSK_REG]	= 0x42,
+	[C_CAN_IF2_MASK1_REG]	= 0x44,
+	[C_CAN_IF2_MASK2_REG]	= 0x46,
+	[C_CAN_IF2_ARB1_REG]	= 0x48,
+	[C_CAN_IF2_ARB2_REG]	= 0x4A,
+	[C_CAN_IF2_MSGCTRL_REG]	= 0x4C,
+	[C_CAN_IF2_DATA1_REG]	= 0x4E,
+	[C_CAN_IF2_DATA2_REG]	= 0x50,
+	[C_CAN_IF2_DATA3_REG]	= 0x52,
+	[C_CAN_IF2_DATA4_REG]	= 0x54,
+	[C_CAN_TXRQST1_REG]	= 0x80,
+	[C_CAN_TXRQST2_REG]	= 0x82,
+	[C_CAN_NEWDAT1_REG]	= 0x90,
+	[C_CAN_NEWDAT2_REG]	= 0x92,
+	[C_CAN_INTPND1_REG]	= 0xA0,
+	[C_CAN_INTPND2_REG]	= 0xA2,
+	[C_CAN_MSGVAL1_REG]	= 0xB0,
+	[C_CAN_MSGVAL2_REG]	= 0xB2,
 };
 
 /* c_can private data structure */
@@ -69,9 +110,10 @@ struct c_can_priv {
 	int tx_object;
 	int current_status;
 	int last_status;
-	u16 (*read_reg) (struct c_can_priv *priv, void *reg);
-	void (*write_reg) (struct c_can_priv *priv, void *reg, u16 val);
-	struct c_can_regs __iomem *regs;
+	u16 (*read_reg) (struct c_can_priv *priv, enum reg index);
+	void (*write_reg) (struct c_can_priv *priv, enum reg index, u16 val);
+	void __iomem *base;
+	const u16 *regs;
 	unsigned long irq_flags; /* for request_irq() */
 	unsigned int tx_next;
 	unsigned int tx_echo;

commit 148c87c89e1a8863d3d965179f3ab1a06490569e
Author: AnilKumar Ch <anilkumar@ti.com>
Date:   Wed May 23 17:45:10 2012 +0530

    can: c_can: fix an interrupt thrash issue with c_can driver
    
    This patch fixes an interrupt thrash issue with c_can driver.
    
    In c_can_isr() function interrupts are disabled and enabled only in
    c_can_poll() function. c_can_isr() & c_can_poll() both read the
    irqstatus flag. However, irqstatus is always read as 0 in c_can_poll()
    because all C_CAN interrupts are disabled in c_can_isr(). This causes
    all interrupts to be re-enabled in c_can_poll() which in turn causes
    another interrupt since the event is not really handled. This keeps
    happening causing a flood of interrupts.
    
    To fix this, read the irqstatus register in isr and use the same cached
    value in the poll function.
    
    Cc: stable@kernel.org # 2.6.39+
    Signed-off-by: AnilKumar Ch <anilkumar@ti.com>
    Acked-by: Wolfgang Grandegger <wg@grandegger.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
index 9b7fbef3d09a..5f32d34af507 100644
--- a/drivers/net/can/c_can/c_can.h
+++ b/drivers/net/can/c_can/c_can.h
@@ -76,6 +76,7 @@ struct c_can_priv {
 	unsigned int tx_next;
 	unsigned int tx_echo;
 	void *priv;		/* for board-specific data */
+	u16 irqstatus;
 };
 
 struct net_device *alloc_c_can_dev(void);

commit 881ff67ad45041f6ff08441aa17302aea77bd054
Author: Bhupesh Sharma <bhupesh.sharma@st.com>
Date:   Sun Feb 13 22:51:44 2011 -0800

    can: c_can: Added support for Bosch C_CAN controller
    
    Bosch C_CAN controller is a full-CAN implementation which is compliant
    to CAN protocol version 2.0 part A and B. Bosch C_CAN user manual can be
    obtained from:
    
    http://www.semiconductors.bosch.de/media/en/pdf/ipmodules_1/c_can/users_manual_c_can.pdf
    
    This patch adds the support for this controller.
    The following are the design choices made while writing the controller
    driver:
    1. Interface Register set IF1 has be used only in the current design.
    2. Out of the 32 Message objects available, 16 are kept aside for RX
       purposes and the rest for TX purposes.
    3. NAPI implementation is such that both the TX and RX paths function
       in polling mode.
    
    Signed-off-by: Bhupesh Sharma <bhupesh.sharma@st.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
new file mode 100644
index 000000000000..9b7fbef3d09a
--- /dev/null
+++ b/drivers/net/can/c_can/c_can.h
@@ -0,0 +1,86 @@
+/*
+ * CAN bus driver for Bosch C_CAN controller
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Bhupesh Sharma <bhupesh.sharma@st.com>
+ *
+ * Borrowed heavily from the C_CAN driver originally written by:
+ * Copyright (C) 2007
+ * - Sascha Hauer, Marc Kleine-Budde, Pengutronix <s.hauer@pengutronix.de>
+ * - Simon Kallweit, intefo AG <simon.kallweit@intefo.ch>
+ *
+ * Bosch C_CAN controller is compliant to CAN protocol version 2.0 part A and B.
+ * Bosch C_CAN user manual can be obtained from:
+ * http://www.semiconductors.bosch.de/media/en/pdf/ipmodules_1/c_can/
+ * users_manual_c_can.pdf
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef C_CAN_H
+#define C_CAN_H
+
+/* c_can IF registers */
+struct c_can_if_regs {
+	u16 com_req;
+	u16 com_mask;
+	u16 mask1;
+	u16 mask2;
+	u16 arb1;
+	u16 arb2;
+	u16 msg_cntrl;
+	u16 data[4];
+	u16 _reserved[13];
+};
+
+/* c_can hardware registers */
+struct c_can_regs {
+	u16 control;
+	u16 status;
+	u16 err_cnt;
+	u16 btr;
+	u16 interrupt;
+	u16 test;
+	u16 brp_ext;
+	u16 _reserved1;
+	struct c_can_if_regs ifregs[2]; /* [0] = IF1 and [1] = IF2 */
+	u16 _reserved2[8];
+	u16 txrqst1;
+	u16 txrqst2;
+	u16 _reserved3[6];
+	u16 newdat1;
+	u16 newdat2;
+	u16 _reserved4[6];
+	u16 intpnd1;
+	u16 intpnd2;
+	u16 _reserved5[6];
+	u16 msgval1;
+	u16 msgval2;
+	u16 _reserved6[6];
+};
+
+/* c_can private data structure */
+struct c_can_priv {
+	struct can_priv can;	/* must be the first member */
+	struct napi_struct napi;
+	struct net_device *dev;
+	int tx_object;
+	int current_status;
+	int last_status;
+	u16 (*read_reg) (struct c_can_priv *priv, void *reg);
+	void (*write_reg) (struct c_can_priv *priv, void *reg, u16 val);
+	struct c_can_regs __iomem *regs;
+	unsigned long irq_flags; /* for request_irq() */
+	unsigned int tx_next;
+	unsigned int tx_echo;
+	void *priv;		/* for board-specific data */
+};
+
+struct net_device *alloc_c_can_dev(void);
+void free_c_can_dev(struct net_device *dev);
+int register_c_can_dev(struct net_device *dev);
+void unregister_c_can_dev(struct net_device *dev);
+
+#endif /* C_CAN_H */
