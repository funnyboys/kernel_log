commit 1bcdfb53acab2961d39dd0e56e4ec9f162afaaa2
Author: Leon Romanovsky <leonro@mellanox.com>
Date:   Sun Mar 1 16:44:43 2020 +0200

    net/cirrus: Delete driver version
    
    There is no need in static driver version, use global
    linux kernel version instead.
    
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/cirrus/ep93xx_eth.c b/drivers/net/ethernet/cirrus/ep93xx_eth.c
index f37c9a08c4cf..9f5e5ec69991 100644
--- a/drivers/net/ethernet/cirrus/ep93xx_eth.c
+++ b/drivers/net/ethernet/cirrus/ep93xx_eth.c
@@ -24,7 +24,6 @@
 #include <linux/platform_data/eth-ep93xx.h>
 
 #define DRV_MODULE_NAME		"ep93xx-eth"
-#define DRV_MODULE_VERSION	"0.1"
 
 #define RX_QUEUE_ENTRIES	64
 #define TX_QUEUE_ENTRIES	8
@@ -691,7 +690,6 @@ static int ep93xx_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 static void ep93xx_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
 {
 	strlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));
-	strlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));
 }
 
 static int ep93xx_get_link_ksettings(struct net_device *dev,

commit 3df70afe8d33f4977d0e0891bdcfb639320b5257
Author: Chuhong Yuan <hslester96@gmail.com>
Date:   Thu Nov 14 23:43:24 2019 +0800

    net: ep93xx_eth: fix mismatch of request_mem_region in remove
    
    The driver calls release_resource in remove to match request_mem_region
    in probe, which is incorrect.
    Fix it by using the right one, release_mem_region.
    
    Signed-off-by: Chuhong Yuan <hslester96@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/cirrus/ep93xx_eth.c b/drivers/net/ethernet/cirrus/ep93xx_eth.c
index f1a0c4dceda0..f37c9a08c4cf 100644
--- a/drivers/net/ethernet/cirrus/ep93xx_eth.c
+++ b/drivers/net/ethernet/cirrus/ep93xx_eth.c
@@ -763,6 +763,7 @@ static int ep93xx_eth_remove(struct platform_device *pdev)
 {
 	struct net_device *dev;
 	struct ep93xx_priv *ep;
+	struct resource *mem;
 
 	dev = platform_get_drvdata(pdev);
 	if (dev == NULL)
@@ -778,8 +779,8 @@ static int ep93xx_eth_remove(struct platform_device *pdev)
 		iounmap(ep->base_addr);
 
 	if (ep->res != NULL) {
-		release_resource(ep->res);
-		kfree(ep->res);
+		mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		release_mem_region(mem->start, resource_size(mem));
 	}
 
 	free_netdev(dev);

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/ethernet/cirrus/ep93xx_eth.c b/drivers/net/ethernet/cirrus/ep93xx_eth.c
index a6da9873570b..f1a0c4dceda0 100644
--- a/drivers/net/ethernet/cirrus/ep93xx_eth.c
+++ b/drivers/net/ethernet/cirrus/ep93xx_eth.c
@@ -1,12 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * EP93xx ethernet network device driver
  * Copyright (C) 2006 Lennert Buytenhek <buytenh@wantstofly.org>
  * Dedicated to Marija Kulikova.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
  */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ":%s: " fmt, __func__

commit 1b8c813695dcff87b58ad1916bff2299dcf01c7f
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Apr 15 22:17:09 2019 +0200

    ARM: ep93xx: move network platform data to separate header
    
    The header file is the only thing preventing us from building the
    driver in a cross-platform configuration, so move the structure
    we are interested in to the global platform_data location
    and enable compile testing.
    
    Acked-by: Alexander Sverdlin <alexander.sverdlin@gmail.com>
    Acked-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/drivers/net/ethernet/cirrus/ep93xx_eth.c b/drivers/net/ethernet/cirrus/ep93xx_eth.c
index 13dfdfca49fc..a6da9873570b 100644
--- a/drivers/net/ethernet/cirrus/ep93xx_eth.c
+++ b/drivers/net/ethernet/cirrus/ep93xx_eth.c
@@ -25,7 +25,7 @@
 #include <linux/io.h>
 #include <linux/slab.h>
 
-#include <mach/hardware.h>
+#include <linux/platform_data/eth-ep93xx.h>
 
 #define DRV_MODULE_NAME		"ep93xx-eth"
 #define DRV_MODULE_VERSION	"0.1"

commit f3bf939f3d4552becb115d76e17b3e5957bab4a2
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Fri Sep 21 11:02:37 2018 +0800

    net: cirrus: fix return type of ndo_start_xmit function
    
    The method ndo_start_xmit() is defined as returning an 'netdev_tx_t',
    which is a typedef for an enum type, so make sure the implementation in
    this driver has returns 'netdev_tx_t' value, and change the function
    return type to netdev_tx_t.
    
    Found by coccinelle.
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/cirrus/ep93xx_eth.c b/drivers/net/ethernet/cirrus/ep93xx_eth.c
index e2a702996db4..13dfdfca49fc 100644
--- a/drivers/net/ethernet/cirrus/ep93xx_eth.c
+++ b/drivers/net/ethernet/cirrus/ep93xx_eth.c
@@ -332,7 +332,7 @@ static int ep93xx_poll(struct napi_struct *napi, int budget)
 	return rx;
 }
 
-static int ep93xx_xmit(struct sk_buff *skb, struct net_device *dev)
+static netdev_tx_t ep93xx_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct ep93xx_priv *ep = netdev_priv(dev);
 	struct ep93xx_tdesc *txd;

commit 82c01a84d5a9bd3b9347bb03eed2f05bbccef933
Author: yuval.shaia@oracle.com <yuval.shaia@oracle.com>
Date:   Sun Jun 4 20:22:00 2017 +0300

    net/{mii, smsc}: Make mii_ethtool_get_link_ksettings and smc_netdev_get_ecmd return void
    
    Make return value void since functions never returns meaningfull value.
    
    Signed-off-by: Yuval Shaia <yuval.shaia@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/cirrus/ep93xx_eth.c b/drivers/net/ethernet/cirrus/ep93xx_eth.c
index 7a7c02f1f8b9..e2a702996db4 100644
--- a/drivers/net/ethernet/cirrus/ep93xx_eth.c
+++ b/drivers/net/ethernet/cirrus/ep93xx_eth.c
@@ -702,7 +702,10 @@ static int ep93xx_get_link_ksettings(struct net_device *dev,
 				     struct ethtool_link_ksettings *cmd)
 {
 	struct ep93xx_priv *ep = netdev_priv(dev);
-	return mii_ethtool_get_link_ksettings(&ep->mii, cmd);
+
+	mii_ethtool_get_link_ksettings(&ep->mii, cmd);
+
+	return 0;
 }
 
 static int ep93xx_set_link_ksettings(struct net_device *dev,

commit a3961789727c3b7cc3ae5f83c5e41005c6e2d1ec
Author: Eric Dumazet <edumazet@google.com>
Date:   Sat Feb 4 15:24:56 2017 -0800

    ep93xx_eth: add GRO support
    
    Use napi_complete_done() instead of __napi_complete() to :
    
    1) Get support of gro_flush_timeout if opt-in
    2) Not rearm interrupts for busy-polling users.
    3) use standard NAPI API.
    4) get rid of baroque code and ease maintenance.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/cirrus/ep93xx_eth.c b/drivers/net/ethernet/cirrus/ep93xx_eth.c
index 396c88678eab..7a7c02f1f8b9 100644
--- a/drivers/net/ethernet/cirrus/ep93xx_eth.c
+++ b/drivers/net/ethernet/cirrus/ep93xx_eth.c
@@ -228,9 +228,10 @@ static void ep93xx_mdio_write(struct net_device *dev, int phy_id, int reg, int d
 		pr_info("mdio write timed out\n");
 }
 
-static int ep93xx_rx(struct net_device *dev, int processed, int budget)
+static int ep93xx_rx(struct net_device *dev, int budget)
 {
 	struct ep93xx_priv *ep = netdev_priv(dev);
+	int processed = 0;
 
 	while (processed < budget) {
 		int entry;
@@ -294,7 +295,7 @@ static int ep93xx_rx(struct net_device *dev, int processed, int budget)
 			skb_put(skb, length);
 			skb->protocol = eth_type_trans(skb, dev);
 
-			netif_receive_skb(skb);
+			napi_gro_receive(&ep->napi, skb);
 
 			dev->stats.rx_packets++;
 			dev->stats.rx_bytes += length;
@@ -310,35 +311,17 @@ static int ep93xx_rx(struct net_device *dev, int processed, int budget)
 	return processed;
 }
 
-static int ep93xx_have_more_rx(struct ep93xx_priv *ep)
-{
-	struct ep93xx_rstat *rstat = ep->descs->rstat + ep->rx_pointer;
-	return !!((rstat->rstat0 & RSTAT0_RFP) && (rstat->rstat1 & RSTAT1_RFP));
-}
-
 static int ep93xx_poll(struct napi_struct *napi, int budget)
 {
 	struct ep93xx_priv *ep = container_of(napi, struct ep93xx_priv, napi);
 	struct net_device *dev = ep->dev;
-	int rx = 0;
-
-poll_some_more:
-	rx = ep93xx_rx(dev, rx, budget);
-	if (rx < budget) {
-		int more = 0;
+	int rx;
 
+	rx = ep93xx_rx(dev, budget);
+	if (rx < budget && napi_complete_done(napi, rx)) {
 		spin_lock_irq(&ep->rx_lock);
-		__napi_complete(napi);
 		wrl(ep, REG_INTEN, REG_INTEN_TX | REG_INTEN_RX);
-		if (ep93xx_have_more_rx(ep)) {
-			wrl(ep, REG_INTEN, REG_INTEN_TX);
-			wrl(ep, REG_INTSTSP, REG_INTSTS_RX);
-			more = 1;
-		}
 		spin_unlock_irq(&ep->rx_lock);
-
-		if (more && napi_reschedule(napi))
-			goto poll_some_more;
 	}
 
 	if (rx) {

commit 93dfe6c290123f1059828001678e6f8b1a102d9a
Author: Philippe Reynes <tremyfr@gmail.com>
Date:   Mon Dec 12 23:28:33 2016 +0100

    net: cirrus: ep93xx: use new api ethtool_{get|set}_link_ksettings
    
    The ethtool api {get|set}_settings is deprecated.
    We move this driver to new api {get|set}_link_ksettings.
    
    Signed-off-by: Philippe Reynes <tremyfr@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/cirrus/ep93xx_eth.c b/drivers/net/ethernet/cirrus/ep93xx_eth.c
index a1de0d12927d..396c88678eab 100644
--- a/drivers/net/ethernet/cirrus/ep93xx_eth.c
+++ b/drivers/net/ethernet/cirrus/ep93xx_eth.c
@@ -715,16 +715,18 @@ static void ep93xx_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *i
 	strlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));
 }
 
-static int ep93xx_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+static int ep93xx_get_link_ksettings(struct net_device *dev,
+				     struct ethtool_link_ksettings *cmd)
 {
 	struct ep93xx_priv *ep = netdev_priv(dev);
-	return mii_ethtool_gset(&ep->mii, cmd);
+	return mii_ethtool_get_link_ksettings(&ep->mii, cmd);
 }
 
-static int ep93xx_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+static int ep93xx_set_link_ksettings(struct net_device *dev,
+				     const struct ethtool_link_ksettings *cmd)
 {
 	struct ep93xx_priv *ep = netdev_priv(dev);
-	return mii_ethtool_sset(&ep->mii, cmd);
+	return mii_ethtool_set_link_ksettings(&ep->mii, cmd);
 }
 
 static int ep93xx_nway_reset(struct net_device *dev)
@@ -741,10 +743,10 @@ static u32 ep93xx_get_link(struct net_device *dev)
 
 static const struct ethtool_ops ep93xx_ethtool_ops = {
 	.get_drvinfo		= ep93xx_get_drvinfo,
-	.get_settings		= ep93xx_get_settings,
-	.set_settings		= ep93xx_set_settings,
 	.nway_reset		= ep93xx_nway_reset,
 	.get_link		= ep93xx_get_link,
+	.get_link_ksettings	= ep93xx_get_link_ksettings,
+	.set_link_ksettings	= ep93xx_set_link_ksettings,
 };
 
 static const struct net_device_ops ep93xx_netdev_ops = {

commit c63d352f053a788281eb90df0a71cd3a6b2c4040
Merge: 862b3d2090ae bc3913a5378c
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Dec 6 21:33:19 2016 -0500

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net

commit c823abac17926767fb50175e098f087a6ac684c3
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sun Dec 4 19:22:05 2016 -0800

    net: ep93xx_eth: Do not crash unloading module
    
    When we unload the ep93xx_eth, whether we have opened the network
    interface or not, we will either hit a kernel paging request error, or a
    simple NULL pointer de-reference because:
    
    - if ep93xx_open has been called, we have created a valid DMA mapping
      for ep->descs, when we call ep93xx_stop, we also call
      ep93xx_free_buffers, ep->descs now has a stale value
    
    - if ep93xx_open has not been called, we have a NULL pointer for
      ep->descs, so performing any operation against that address just won't
      work
    
    Fix this by adding a NULL pointer check for ep->descs which means that
    ep93xx_free_buffers() was able to successfully tear down the descriptors
    and free the DMA cookie as well.
    
    Fixes: 1d22e05df818 ("[PATCH] Cirrus Logic ep93xx ethernet driver")
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/cirrus/ep93xx_eth.c b/drivers/net/ethernet/cirrus/ep93xx_eth.c
index de9f7c97d916..9a161e981529 100644
--- a/drivers/net/ethernet/cirrus/ep93xx_eth.c
+++ b/drivers/net/ethernet/cirrus/ep93xx_eth.c
@@ -468,6 +468,9 @@ static void ep93xx_free_buffers(struct ep93xx_priv *ep)
 	struct device *dev = ep->dev->dev.parent;
 	int i;
 
+	if (!ep->descs)
+		return;
+
 	for (i = 0; i < RX_QUEUE_ENTRIES; i++) {
 		dma_addr_t d;
 
@@ -490,6 +493,7 @@ static void ep93xx_free_buffers(struct ep93xx_priv *ep)
 
 	dma_free_coherent(dev, sizeof(struct ep93xx_descs), ep->descs,
 							ep->descs_dma_addr);
+	ep->descs = NULL;
 }
 
 static int ep93xx_alloc_buffers(struct ep93xx_priv *ep)

commit a52ad514fdf3b8a57ca4322c92d2d8d5c6182485
Author: Jarod Wilson <jarod@redhat.com>
Date:   Fri Oct 7 22:04:34 2016 -0400

    net: deprecate eth_change_mtu, remove usage
    
    With centralized MTU checking, there's nothing productive done by
    eth_change_mtu that isn't already done in dev_set_mtu, so mark it as
    deprecated and remove all usage of it in the kernel. All callers have been
    audited for calls to alloc_etherdev* or ether_setup directly, which means
    they all have a valid dev->min_mtu and dev->max_mtu. Now eth_change_mtu
    prints out a netdev_warn about being deprecated, for the benefit of
    out-of-tree drivers that might be utilizing it.
    
    Of note, dvb_net.c actually had dev->mtu = 4096, while using
    eth_change_mtu, meaning that if you ever tried changing it's mtu, you
    couldn't set it above 1500 anymore. It's now getting dev->max_mtu also set
    to 4096 to remedy that.
    
    v2: fix up lantiq_etop, missed breakage due to drive not compiling on x86
    
    CC: netdev@vger.kernel.org
    Signed-off-by: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/cirrus/ep93xx_eth.c b/drivers/net/ethernet/cirrus/ep93xx_eth.c
index de9f7c97d916..9119af088821 100644
--- a/drivers/net/ethernet/cirrus/ep93xx_eth.c
+++ b/drivers/net/ethernet/cirrus/ep93xx_eth.c
@@ -749,7 +749,6 @@ static const struct net_device_ops ep93xx_netdev_ops = {
 	.ndo_start_xmit		= ep93xx_xmit,
 	.ndo_do_ioctl		= ep93xx_ioctl,
 	.ndo_validate_addr	= eth_validate_addr,
-	.ndo_change_mtu		= eth_change_mtu,
 	.ndo_set_mac_address	= eth_mac_addr,
 };
 

commit 7af348be47fd2df5d276add2167b5838d48ba044
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Wed Feb 4 15:56:58 2015 +0100

    net: ep93xx_eth: Delete unnecessary checks before the function call "kfree"
    
    The kfree() function tests whether its argument is NULL and then
    returns immediately. Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/cirrus/ep93xx_eth.c b/drivers/net/ethernet/cirrus/ep93xx_eth.c
index 3a12c096ea1c..de9f7c97d916 100644
--- a/drivers/net/ethernet/cirrus/ep93xx_eth.c
+++ b/drivers/net/ethernet/cirrus/ep93xx_eth.c
@@ -475,8 +475,7 @@ static void ep93xx_free_buffers(struct ep93xx_priv *ep)
 		if (d)
 			dma_unmap_single(dev, d, PKT_BUF_SIZE, DMA_FROM_DEVICE);
 
-		if (ep->rx_buf[i] != NULL)
-			kfree(ep->rx_buf[i]);
+		kfree(ep->rx_buf[i]);
 	}
 
 	for (i = 0; i < TX_QUEUE_ENTRIES; i++) {
@@ -486,8 +485,7 @@ static void ep93xx_free_buffers(struct ep93xx_priv *ep)
 		if (d)
 			dma_unmap_single(dev, d, PKT_BUF_SIZE, DMA_TO_DEVICE);
 
-		if (ep->tx_buf[i] != NULL)
-			kfree(ep->tx_buf[i]);
+		kfree(ep->tx_buf[i]);
 	}
 
 	dma_free_coherent(dev, sizeof(struct ep93xx_descs), ep->descs,

commit bfe68b1423afc27cbc41733799ab170b6a876fa8
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:06 2014 +0200

    net: ethernet: cirrus: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/net/ethernet/cirrus/ep93xx_eth.c b/drivers/net/ethernet/cirrus/ep93xx_eth.c
index 2be2a99c5ea3..3a12c096ea1c 100644
--- a/drivers/net/ethernet/cirrus/ep93xx_eth.c
+++ b/drivers/net/ethernet/cirrus/ep93xx_eth.c
@@ -881,7 +881,6 @@ static struct platform_driver ep93xx_eth_driver = {
 	.remove		= ep93xx_eth_remove,
 	.driver		= {
 		.name	= "ep93xx-eth",
-		.owner	= THIS_MODULE,
 	},
 };
 

commit a81ab36bf52d0ca3a32251a923be1dbced726141
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Jan 8 15:32:47 2014 -0500

    drivers/net: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.   Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    This covers everything under drivers/net except for wireless, which
    has been submitted separately.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/cirrus/ep93xx_eth.c b/drivers/net/ethernet/cirrus/ep93xx_eth.c
index ec88de4ac162..2be2a99c5ea3 100644
--- a/drivers/net/ethernet/cirrus/ep93xx_eth.c
+++ b/drivers/net/ethernet/cirrus/ep93xx_eth.c
@@ -18,7 +18,6 @@
 #include <linux/mii.h>
 #include <linux/etherdevice.h>
 #include <linux/ethtool.h>
-#include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/moduleparam.h>
 #include <linux/platform_device.h>

commit b96f64dd473416d877cfc0bdf5efeeb705c68734
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Fri Aug 30 13:54:37 2013 +0900

    net: ep93xx_eth: use dev_get_platdata()
    
    Use the wrapper function for retrieving the platform data instead of
    accessing dev->platform_data directly. This is a cosmetic change
    to make the code simpler and enhance the readability.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/cirrus/ep93xx_eth.c b/drivers/net/ethernet/cirrus/ep93xx_eth.c
index e3d4ec836f8b..ec88de4ac162 100644
--- a/drivers/net/ethernet/cirrus/ep93xx_eth.c
+++ b/drivers/net/ethernet/cirrus/ep93xx_eth.c
@@ -814,7 +814,7 @@ static int ep93xx_eth_probe(struct platform_device *pdev)
 
 	if (pdev == NULL)
 		return -ENODEV;
-	data = pdev->dev.platform_data;
+	data = dev_get_platdata(&pdev->dev);
 
 	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	irq = platform_get_irq(pdev, 0);

commit dfd93c977d84fef77404b689ef95bc716b313533
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Mon May 27 19:01:12 2013 +0000

    net: ethernet: remove unnecessary platform_set_drvdata()
    
    The driver core clears the driver data to NULL after device_release
    or on probe failure, since commit 0998d0631001288a5974afc0b2a5f568bcdecb4d
    (device-core: Ensure drvdata = NULL when no driver is bound).
    Thus, it is not needed to manually clear the device driver data to NULL.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Acked-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Roland Stigge <stigge@antcom.de>
    Acked-by: Mugunthan V N <mugunthanvnm@ti.com>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Tested-by: Roland Stigge <stigge@antcom.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/cirrus/ep93xx_eth.c b/drivers/net/ethernet/cirrus/ep93xx_eth.c
index 67b0388b6e68..e3d4ec836f8b 100644
--- a/drivers/net/ethernet/cirrus/ep93xx_eth.c
+++ b/drivers/net/ethernet/cirrus/ep93xx_eth.c
@@ -783,7 +783,6 @@ static int ep93xx_eth_remove(struct platform_device *pdev)
 	dev = platform_get_drvdata(pdev);
 	if (dev == NULL)
 		return 0;
-	platform_set_drvdata(pdev, NULL);
 
 	ep = netdev_priv(dev);
 

commit e827c122992127de6bc8de34d5d113fe34c382fb
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Mon Mar 18 01:50:47 2013 +0000

    net: ep93xx_eth: Use module_platform_driver()
    
    module_platform_driver macro removes some boilerplate and makes
    the code simpler.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/cirrus/ep93xx_eth.c b/drivers/net/ethernet/cirrus/ep93xx_eth.c
index 354cbb78ed50..67b0388b6e68 100644
--- a/drivers/net/ethernet/cirrus/ep93xx_eth.c
+++ b/drivers/net/ethernet/cirrus/ep93xx_eth.c
@@ -887,18 +887,7 @@ static struct platform_driver ep93xx_eth_driver = {
 	},
 };
 
-static int __init ep93xx_eth_init_module(void)
-{
-	printk(KERN_INFO DRV_MODULE_NAME " version " DRV_MODULE_VERSION " loading\n");
-	return platform_driver_register(&ep93xx_eth_driver);
-}
-
-static void __exit ep93xx_eth_cleanup_module(void)
-{
-	platform_driver_unregister(&ep93xx_eth_driver);
-}
+module_platform_driver(ep93xx_eth_driver);
 
-module_init(ep93xx_eth_init_module);
-module_exit(ep93xx_eth_cleanup_module);
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("platform:ep93xx-eth");

commit 7826d43f2db45c9305a6e0ba165650e1a203f517
Author: Jiri Pirko <jiri@resnulli.us>
Date:   Sun Jan 6 00:44:26 2013 +0000

    ethtool: fix drvinfo strings set in drivers
    
    Use strlcpy where possible to ensure the string is \0 terminated.
    Use always sizeof(string) instead of 32, ETHTOOL_BUSINFO_LEN
    and custom defines.
    Use snprintf instead of sprint.
    Remove unnecessary inits of ->fw_version
    Remove unnecessary inits of drvinfo struct.
    
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/cirrus/ep93xx_eth.c b/drivers/net/ethernet/cirrus/ep93xx_eth.c
index 78c55213eaf7..354cbb78ed50 100644
--- a/drivers/net/ethernet/cirrus/ep93xx_eth.c
+++ b/drivers/net/ethernet/cirrus/ep93xx_eth.c
@@ -710,8 +710,8 @@ static int ep93xx_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 
 static void ep93xx_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
 {
-	strcpy(info->driver, DRV_MODULE_NAME);
-	strcpy(info->version, DRV_MODULE_VERSION);
+	strlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));
+	strlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));
 }
 
 static int ep93xx_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)

commit f2cedb63df14342ad40a8b5b324fc5d94a60b665
Author: Danny Kukawka <danny.kukawka@bisect.de>
Date:   Wed Feb 15 06:45:39 2012 +0000

    net: replace random_ether_addr() with eth_hw_addr_random()
    
    Replace usage of random_ether_addr() with eth_hw_addr_random()
    to set addr_assign_type correctly to NET_ADDR_RANDOM.
    
    Change the trivial cases.
    
    v2: adapt to renamed eth_hw_addr_random()
    
    Signed-off-by: Danny Kukawka <danny.kukawka@bisect.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/cirrus/ep93xx_eth.c b/drivers/net/ethernet/cirrus/ep93xx_eth.c
index c21e5ab8d1ef..78c55213eaf7 100644
--- a/drivers/net/ethernet/cirrus/ep93xx_eth.c
+++ b/drivers/net/ethernet/cirrus/ep93xx_eth.c
@@ -859,7 +859,7 @@ static int ep93xx_eth_probe(struct platform_device *pdev)
 	ep->mdc_divisor = 40;	/* Max HCLK 100 MHz, min MDIO clk 2.5 MHz.  */
 
 	if (is_zero_ether_addr(dev->dev_addr))
-		random_ether_addr(dev->dev_addr);
+		eth_hw_addr_random(dev);
 
 	err = register_netdev(dev);
 	if (err) {

commit 21a4e46995fa1a76281ac0281ff837f706231a37
Author: Pradeep A Dalvi <netdev@pradeepdalvi.com>
Date:   Sun Feb 5 02:50:10 2012 +0000

    netdev: ethernet dev_alloc_skb to netdev_alloc_skb
    
    Replaced deprecating dev_alloc_skb with netdev_alloc_skb in drivers/net/ethernet
      - Removed extra skb->dev = dev after netdev_alloc_skb
    
    Signed-off-by: Pradeep A Dalvi <netdev@pradeepdalvi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/cirrus/ep93xx_eth.c b/drivers/net/ethernet/cirrus/ep93xx_eth.c
index 4317af8d2f0a..c21e5ab8d1ef 100644
--- a/drivers/net/ethernet/cirrus/ep93xx_eth.c
+++ b/drivers/net/ethernet/cirrus/ep93xx_eth.c
@@ -282,7 +282,7 @@ static int ep93xx_rx(struct net_device *dev, int processed, int budget)
 		if (rstat0 & RSTAT0_CRCI)
 			length -= 4;
 
-		skb = dev_alloc_skb(length + 2);
+		skb = netdev_alloc_skb(dev, length + 2);
 		if (likely(skb != NULL)) {
 			struct ep93xx_rdesc *rxd = &ep->descs->rdesc[entry];
 			skb_reserve(skb, 2);

commit 57d0b7a0d77d0b770682e425ff3fa270c65a4eb5
Author: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Date:   Sat Jul 16 23:50:52 2011 -0700

    cirrus: Move the Cirrus network driver
    
    Move the Cirrus Ethernet driver into drivers/net/ethernet/cirrus/
    and make the necessary Kconfig and Makefile changes
    
    CC: Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/cirrus/ep93xx_eth.c b/drivers/net/ethernet/cirrus/ep93xx_eth.c
new file mode 100644
index 000000000000..4317af8d2f0a
--- /dev/null
+++ b/drivers/net/ethernet/cirrus/ep93xx_eth.c
@@ -0,0 +1,904 @@
+/*
+ * EP93xx ethernet network device driver
+ * Copyright (C) 2006 Lennert Buytenhek <buytenh@wantstofly.org>
+ * Dedicated to Marija Kulikova.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ":%s: " fmt, __func__
+
+#include <linux/dma-mapping.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/mii.h>
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+
+#include <mach/hardware.h>
+
+#define DRV_MODULE_NAME		"ep93xx-eth"
+#define DRV_MODULE_VERSION	"0.1"
+
+#define RX_QUEUE_ENTRIES	64
+#define TX_QUEUE_ENTRIES	8
+
+#define MAX_PKT_SIZE		2044
+#define PKT_BUF_SIZE		2048
+
+#define REG_RXCTL		0x0000
+#define  REG_RXCTL_DEFAULT	0x00073800
+#define REG_TXCTL		0x0004
+#define  REG_TXCTL_ENABLE	0x00000001
+#define REG_MIICMD		0x0010
+#define  REG_MIICMD_READ	0x00008000
+#define  REG_MIICMD_WRITE	0x00004000
+#define REG_MIIDATA		0x0014
+#define REG_MIISTS		0x0018
+#define  REG_MIISTS_BUSY	0x00000001
+#define REG_SELFCTL		0x0020
+#define  REG_SELFCTL_RESET	0x00000001
+#define REG_INTEN		0x0024
+#define  REG_INTEN_TX		0x00000008
+#define  REG_INTEN_RX		0x00000007
+#define REG_INTSTSP		0x0028
+#define  REG_INTSTS_TX		0x00000008
+#define  REG_INTSTS_RX		0x00000004
+#define REG_INTSTSC		0x002c
+#define REG_AFP			0x004c
+#define REG_INDAD0		0x0050
+#define REG_INDAD1		0x0051
+#define REG_INDAD2		0x0052
+#define REG_INDAD3		0x0053
+#define REG_INDAD4		0x0054
+#define REG_INDAD5		0x0055
+#define REG_GIINTMSK		0x0064
+#define  REG_GIINTMSK_ENABLE	0x00008000
+#define REG_BMCTL		0x0080
+#define  REG_BMCTL_ENABLE_TX	0x00000100
+#define  REG_BMCTL_ENABLE_RX	0x00000001
+#define REG_BMSTS		0x0084
+#define  REG_BMSTS_RX_ACTIVE	0x00000008
+#define REG_RXDQBADD		0x0090
+#define REG_RXDQBLEN		0x0094
+#define REG_RXDCURADD		0x0098
+#define REG_RXDENQ		0x009c
+#define REG_RXSTSQBADD		0x00a0
+#define REG_RXSTSQBLEN		0x00a4
+#define REG_RXSTSQCURADD	0x00a8
+#define REG_RXSTSENQ		0x00ac
+#define REG_TXDQBADD		0x00b0
+#define REG_TXDQBLEN		0x00b4
+#define REG_TXDQCURADD		0x00b8
+#define REG_TXDENQ		0x00bc
+#define REG_TXSTSQBADD		0x00c0
+#define REG_TXSTSQBLEN		0x00c4
+#define REG_TXSTSQCURADD	0x00c8
+#define REG_MAXFRMLEN		0x00e8
+
+struct ep93xx_rdesc
+{
+	u32	buf_addr;
+	u32	rdesc1;
+};
+
+#define RDESC1_NSOF		0x80000000
+#define RDESC1_BUFFER_INDEX	0x7fff0000
+#define RDESC1_BUFFER_LENGTH	0x0000ffff
+
+struct ep93xx_rstat
+{
+	u32	rstat0;
+	u32	rstat1;
+};
+
+#define RSTAT0_RFP		0x80000000
+#define RSTAT0_RWE		0x40000000
+#define RSTAT0_EOF		0x20000000
+#define RSTAT0_EOB		0x10000000
+#define RSTAT0_AM		0x00c00000
+#define RSTAT0_RX_ERR		0x00200000
+#define RSTAT0_OE		0x00100000
+#define RSTAT0_FE		0x00080000
+#define RSTAT0_RUNT		0x00040000
+#define RSTAT0_EDATA		0x00020000
+#define RSTAT0_CRCE		0x00010000
+#define RSTAT0_CRCI		0x00008000
+#define RSTAT0_HTI		0x00003f00
+#define RSTAT1_RFP		0x80000000
+#define RSTAT1_BUFFER_INDEX	0x7fff0000
+#define RSTAT1_FRAME_LENGTH	0x0000ffff
+
+struct ep93xx_tdesc
+{
+	u32	buf_addr;
+	u32	tdesc1;
+};
+
+#define TDESC1_EOF		0x80000000
+#define TDESC1_BUFFER_INDEX	0x7fff0000
+#define TDESC1_BUFFER_ABORT	0x00008000
+#define TDESC1_BUFFER_LENGTH	0x00000fff
+
+struct ep93xx_tstat
+{
+	u32	tstat0;
+};
+
+#define TSTAT0_TXFP		0x80000000
+#define TSTAT0_TXWE		0x40000000
+#define TSTAT0_FA		0x20000000
+#define TSTAT0_LCRS		0x10000000
+#define TSTAT0_OW		0x04000000
+#define TSTAT0_TXU		0x02000000
+#define TSTAT0_ECOLL		0x01000000
+#define TSTAT0_NCOLL		0x001f0000
+#define TSTAT0_BUFFER_INDEX	0x00007fff
+
+struct ep93xx_descs
+{
+	struct ep93xx_rdesc	rdesc[RX_QUEUE_ENTRIES];
+	struct ep93xx_tdesc	tdesc[TX_QUEUE_ENTRIES];
+	struct ep93xx_rstat	rstat[RX_QUEUE_ENTRIES];
+	struct ep93xx_tstat	tstat[TX_QUEUE_ENTRIES];
+};
+
+struct ep93xx_priv
+{
+	struct resource		*res;
+	void __iomem		*base_addr;
+	int			irq;
+
+	struct ep93xx_descs	*descs;
+	dma_addr_t		descs_dma_addr;
+
+	void			*rx_buf[RX_QUEUE_ENTRIES];
+	void			*tx_buf[TX_QUEUE_ENTRIES];
+
+	spinlock_t		rx_lock;
+	unsigned int		rx_pointer;
+	unsigned int		tx_clean_pointer;
+	unsigned int		tx_pointer;
+	spinlock_t		tx_pending_lock;
+	unsigned int		tx_pending;
+
+	struct net_device	*dev;
+	struct napi_struct	napi;
+
+	struct mii_if_info	mii;
+	u8			mdc_divisor;
+};
+
+#define rdb(ep, off)		__raw_readb((ep)->base_addr + (off))
+#define rdw(ep, off)		__raw_readw((ep)->base_addr + (off))
+#define rdl(ep, off)		__raw_readl((ep)->base_addr + (off))
+#define wrb(ep, off, val)	__raw_writeb((val), (ep)->base_addr + (off))
+#define wrw(ep, off, val)	__raw_writew((val), (ep)->base_addr + (off))
+#define wrl(ep, off, val)	__raw_writel((val), (ep)->base_addr + (off))
+
+static int ep93xx_mdio_read(struct net_device *dev, int phy_id, int reg)
+{
+	struct ep93xx_priv *ep = netdev_priv(dev);
+	int data;
+	int i;
+
+	wrl(ep, REG_MIICMD, REG_MIICMD_READ | (phy_id << 5) | reg);
+
+	for (i = 0; i < 10; i++) {
+		if ((rdl(ep, REG_MIISTS) & REG_MIISTS_BUSY) == 0)
+			break;
+		msleep(1);
+	}
+
+	if (i == 10) {
+		pr_info("mdio read timed out\n");
+		data = 0xffff;
+	} else {
+		data = rdl(ep, REG_MIIDATA);
+	}
+
+	return data;
+}
+
+static void ep93xx_mdio_write(struct net_device *dev, int phy_id, int reg, int data)
+{
+	struct ep93xx_priv *ep = netdev_priv(dev);
+	int i;
+
+	wrl(ep, REG_MIIDATA, data);
+	wrl(ep, REG_MIICMD, REG_MIICMD_WRITE | (phy_id << 5) | reg);
+
+	for (i = 0; i < 10; i++) {
+		if ((rdl(ep, REG_MIISTS) & REG_MIISTS_BUSY) == 0)
+			break;
+		msleep(1);
+	}
+
+	if (i == 10)
+		pr_info("mdio write timed out\n");
+}
+
+static int ep93xx_rx(struct net_device *dev, int processed, int budget)
+{
+	struct ep93xx_priv *ep = netdev_priv(dev);
+
+	while (processed < budget) {
+		int entry;
+		struct ep93xx_rstat *rstat;
+		u32 rstat0;
+		u32 rstat1;
+		int length;
+		struct sk_buff *skb;
+
+		entry = ep->rx_pointer;
+		rstat = ep->descs->rstat + entry;
+
+		rstat0 = rstat->rstat0;
+		rstat1 = rstat->rstat1;
+		if (!(rstat0 & RSTAT0_RFP) || !(rstat1 & RSTAT1_RFP))
+			break;
+
+		rstat->rstat0 = 0;
+		rstat->rstat1 = 0;
+
+		if (!(rstat0 & RSTAT0_EOF))
+			pr_crit("not end-of-frame %.8x %.8x\n", rstat0, rstat1);
+		if (!(rstat0 & RSTAT0_EOB))
+			pr_crit("not end-of-buffer %.8x %.8x\n", rstat0, rstat1);
+		if ((rstat1 & RSTAT1_BUFFER_INDEX) >> 16 != entry)
+			pr_crit("entry mismatch %.8x %.8x\n", rstat0, rstat1);
+
+		if (!(rstat0 & RSTAT0_RWE)) {
+			dev->stats.rx_errors++;
+			if (rstat0 & RSTAT0_OE)
+				dev->stats.rx_fifo_errors++;
+			if (rstat0 & RSTAT0_FE)
+				dev->stats.rx_frame_errors++;
+			if (rstat0 & (RSTAT0_RUNT | RSTAT0_EDATA))
+				dev->stats.rx_length_errors++;
+			if (rstat0 & RSTAT0_CRCE)
+				dev->stats.rx_crc_errors++;
+			goto err;
+		}
+
+		length = rstat1 & RSTAT1_FRAME_LENGTH;
+		if (length > MAX_PKT_SIZE) {
+			pr_notice("invalid length %.8x %.8x\n", rstat0, rstat1);
+			goto err;
+		}
+
+		/* Strip FCS.  */
+		if (rstat0 & RSTAT0_CRCI)
+			length -= 4;
+
+		skb = dev_alloc_skb(length + 2);
+		if (likely(skb != NULL)) {
+			struct ep93xx_rdesc *rxd = &ep->descs->rdesc[entry];
+			skb_reserve(skb, 2);
+			dma_sync_single_for_cpu(dev->dev.parent, rxd->buf_addr,
+						length, DMA_FROM_DEVICE);
+			skb_copy_to_linear_data(skb, ep->rx_buf[entry], length);
+			dma_sync_single_for_device(dev->dev.parent,
+						   rxd->buf_addr, length,
+						   DMA_FROM_DEVICE);
+			skb_put(skb, length);
+			skb->protocol = eth_type_trans(skb, dev);
+
+			netif_receive_skb(skb);
+
+			dev->stats.rx_packets++;
+			dev->stats.rx_bytes += length;
+		} else {
+			dev->stats.rx_dropped++;
+		}
+
+err:
+		ep->rx_pointer = (entry + 1) & (RX_QUEUE_ENTRIES - 1);
+		processed++;
+	}
+
+	return processed;
+}
+
+static int ep93xx_have_more_rx(struct ep93xx_priv *ep)
+{
+	struct ep93xx_rstat *rstat = ep->descs->rstat + ep->rx_pointer;
+	return !!((rstat->rstat0 & RSTAT0_RFP) && (rstat->rstat1 & RSTAT1_RFP));
+}
+
+static int ep93xx_poll(struct napi_struct *napi, int budget)
+{
+	struct ep93xx_priv *ep = container_of(napi, struct ep93xx_priv, napi);
+	struct net_device *dev = ep->dev;
+	int rx = 0;
+
+poll_some_more:
+	rx = ep93xx_rx(dev, rx, budget);
+	if (rx < budget) {
+		int more = 0;
+
+		spin_lock_irq(&ep->rx_lock);
+		__napi_complete(napi);
+		wrl(ep, REG_INTEN, REG_INTEN_TX | REG_INTEN_RX);
+		if (ep93xx_have_more_rx(ep)) {
+			wrl(ep, REG_INTEN, REG_INTEN_TX);
+			wrl(ep, REG_INTSTSP, REG_INTSTS_RX);
+			more = 1;
+		}
+		spin_unlock_irq(&ep->rx_lock);
+
+		if (more && napi_reschedule(napi))
+			goto poll_some_more;
+	}
+
+	if (rx) {
+		wrw(ep, REG_RXDENQ, rx);
+		wrw(ep, REG_RXSTSENQ, rx);
+	}
+
+	return rx;
+}
+
+static int ep93xx_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct ep93xx_priv *ep = netdev_priv(dev);
+	struct ep93xx_tdesc *txd;
+	int entry;
+
+	if (unlikely(skb->len > MAX_PKT_SIZE)) {
+		dev->stats.tx_dropped++;
+		dev_kfree_skb(skb);
+		return NETDEV_TX_OK;
+	}
+
+	entry = ep->tx_pointer;
+	ep->tx_pointer = (ep->tx_pointer + 1) & (TX_QUEUE_ENTRIES - 1);
+
+	txd = &ep->descs->tdesc[entry];
+
+	txd->tdesc1 = TDESC1_EOF | (entry << 16) | (skb->len & 0xfff);
+	dma_sync_single_for_cpu(dev->dev.parent, txd->buf_addr, skb->len,
+				DMA_TO_DEVICE);
+	skb_copy_and_csum_dev(skb, ep->tx_buf[entry]);
+	dma_sync_single_for_device(dev->dev.parent, txd->buf_addr, skb->len,
+				   DMA_TO_DEVICE);
+	dev_kfree_skb(skb);
+
+	spin_lock_irq(&ep->tx_pending_lock);
+	ep->tx_pending++;
+	if (ep->tx_pending == TX_QUEUE_ENTRIES)
+		netif_stop_queue(dev);
+	spin_unlock_irq(&ep->tx_pending_lock);
+
+	wrl(ep, REG_TXDENQ, 1);
+
+	return NETDEV_TX_OK;
+}
+
+static void ep93xx_tx_complete(struct net_device *dev)
+{
+	struct ep93xx_priv *ep = netdev_priv(dev);
+	int wake;
+
+	wake = 0;
+
+	spin_lock(&ep->tx_pending_lock);
+	while (1) {
+		int entry;
+		struct ep93xx_tstat *tstat;
+		u32 tstat0;
+
+		entry = ep->tx_clean_pointer;
+		tstat = ep->descs->tstat + entry;
+
+		tstat0 = tstat->tstat0;
+		if (!(tstat0 & TSTAT0_TXFP))
+			break;
+
+		tstat->tstat0 = 0;
+
+		if (tstat0 & TSTAT0_FA)
+			pr_crit("frame aborted %.8x\n", tstat0);
+		if ((tstat0 & TSTAT0_BUFFER_INDEX) != entry)
+			pr_crit("entry mismatch %.8x\n", tstat0);
+
+		if (tstat0 & TSTAT0_TXWE) {
+			int length = ep->descs->tdesc[entry].tdesc1 & 0xfff;
+
+			dev->stats.tx_packets++;
+			dev->stats.tx_bytes += length;
+		} else {
+			dev->stats.tx_errors++;
+		}
+
+		if (tstat0 & TSTAT0_OW)
+			dev->stats.tx_window_errors++;
+		if (tstat0 & TSTAT0_TXU)
+			dev->stats.tx_fifo_errors++;
+		dev->stats.collisions += (tstat0 >> 16) & 0x1f;
+
+		ep->tx_clean_pointer = (entry + 1) & (TX_QUEUE_ENTRIES - 1);
+		if (ep->tx_pending == TX_QUEUE_ENTRIES)
+			wake = 1;
+		ep->tx_pending--;
+	}
+	spin_unlock(&ep->tx_pending_lock);
+
+	if (wake)
+		netif_wake_queue(dev);
+}
+
+static irqreturn_t ep93xx_irq(int irq, void *dev_id)
+{
+	struct net_device *dev = dev_id;
+	struct ep93xx_priv *ep = netdev_priv(dev);
+	u32 status;
+
+	status = rdl(ep, REG_INTSTSC);
+	if (status == 0)
+		return IRQ_NONE;
+
+	if (status & REG_INTSTS_RX) {
+		spin_lock(&ep->rx_lock);
+		if (likely(napi_schedule_prep(&ep->napi))) {
+			wrl(ep, REG_INTEN, REG_INTEN_TX);
+			__napi_schedule(&ep->napi);
+		}
+		spin_unlock(&ep->rx_lock);
+	}
+
+	if (status & REG_INTSTS_TX)
+		ep93xx_tx_complete(dev);
+
+	return IRQ_HANDLED;
+}
+
+static void ep93xx_free_buffers(struct ep93xx_priv *ep)
+{
+	struct device *dev = ep->dev->dev.parent;
+	int i;
+
+	for (i = 0; i < RX_QUEUE_ENTRIES; i++) {
+		dma_addr_t d;
+
+		d = ep->descs->rdesc[i].buf_addr;
+		if (d)
+			dma_unmap_single(dev, d, PKT_BUF_SIZE, DMA_FROM_DEVICE);
+
+		if (ep->rx_buf[i] != NULL)
+			kfree(ep->rx_buf[i]);
+	}
+
+	for (i = 0; i < TX_QUEUE_ENTRIES; i++) {
+		dma_addr_t d;
+
+		d = ep->descs->tdesc[i].buf_addr;
+		if (d)
+			dma_unmap_single(dev, d, PKT_BUF_SIZE, DMA_TO_DEVICE);
+
+		if (ep->tx_buf[i] != NULL)
+			kfree(ep->tx_buf[i]);
+	}
+
+	dma_free_coherent(dev, sizeof(struct ep93xx_descs), ep->descs,
+							ep->descs_dma_addr);
+}
+
+static int ep93xx_alloc_buffers(struct ep93xx_priv *ep)
+{
+	struct device *dev = ep->dev->dev.parent;
+	int i;
+
+	ep->descs = dma_alloc_coherent(dev, sizeof(struct ep93xx_descs),
+				&ep->descs_dma_addr, GFP_KERNEL);
+	if (ep->descs == NULL)
+		return 1;
+
+	for (i = 0; i < RX_QUEUE_ENTRIES; i++) {
+		void *buf;
+		dma_addr_t d;
+
+		buf = kmalloc(PKT_BUF_SIZE, GFP_KERNEL);
+		if (buf == NULL)
+			goto err;
+
+		d = dma_map_single(dev, buf, PKT_BUF_SIZE, DMA_FROM_DEVICE);
+		if (dma_mapping_error(dev, d)) {
+			kfree(buf);
+			goto err;
+		}
+
+		ep->rx_buf[i] = buf;
+		ep->descs->rdesc[i].buf_addr = d;
+		ep->descs->rdesc[i].rdesc1 = (i << 16) | PKT_BUF_SIZE;
+	}
+
+	for (i = 0; i < TX_QUEUE_ENTRIES; i++) {
+		void *buf;
+		dma_addr_t d;
+
+		buf = kmalloc(PKT_BUF_SIZE, GFP_KERNEL);
+		if (buf == NULL)
+			goto err;
+
+		d = dma_map_single(dev, buf, PKT_BUF_SIZE, DMA_TO_DEVICE);
+		if (dma_mapping_error(dev, d)) {
+			kfree(buf);
+			goto err;
+		}
+
+		ep->tx_buf[i] = buf;
+		ep->descs->tdesc[i].buf_addr = d;
+	}
+
+	return 0;
+
+err:
+	ep93xx_free_buffers(ep);
+	return 1;
+}
+
+static int ep93xx_start_hw(struct net_device *dev)
+{
+	struct ep93xx_priv *ep = netdev_priv(dev);
+	unsigned long addr;
+	int i;
+
+	wrl(ep, REG_SELFCTL, REG_SELFCTL_RESET);
+	for (i = 0; i < 10; i++) {
+		if ((rdl(ep, REG_SELFCTL) & REG_SELFCTL_RESET) == 0)
+			break;
+		msleep(1);
+	}
+
+	if (i == 10) {
+		pr_crit("hw failed to reset\n");
+		return 1;
+	}
+
+	wrl(ep, REG_SELFCTL, ((ep->mdc_divisor - 1) << 9));
+
+	/* Does the PHY support preamble suppress?  */
+	if ((ep93xx_mdio_read(dev, ep->mii.phy_id, MII_BMSR) & 0x0040) != 0)
+		wrl(ep, REG_SELFCTL, ((ep->mdc_divisor - 1) << 9) | (1 << 8));
+
+	/* Receive descriptor ring.  */
+	addr = ep->descs_dma_addr + offsetof(struct ep93xx_descs, rdesc);
+	wrl(ep, REG_RXDQBADD, addr);
+	wrl(ep, REG_RXDCURADD, addr);
+	wrw(ep, REG_RXDQBLEN, RX_QUEUE_ENTRIES * sizeof(struct ep93xx_rdesc));
+
+	/* Receive status ring.  */
+	addr = ep->descs_dma_addr + offsetof(struct ep93xx_descs, rstat);
+	wrl(ep, REG_RXSTSQBADD, addr);
+	wrl(ep, REG_RXSTSQCURADD, addr);
+	wrw(ep, REG_RXSTSQBLEN, RX_QUEUE_ENTRIES * sizeof(struct ep93xx_rstat));
+
+	/* Transmit descriptor ring.  */
+	addr = ep->descs_dma_addr + offsetof(struct ep93xx_descs, tdesc);
+	wrl(ep, REG_TXDQBADD, addr);
+	wrl(ep, REG_TXDQCURADD, addr);
+	wrw(ep, REG_TXDQBLEN, TX_QUEUE_ENTRIES * sizeof(struct ep93xx_tdesc));
+
+	/* Transmit status ring.  */
+	addr = ep->descs_dma_addr + offsetof(struct ep93xx_descs, tstat);
+	wrl(ep, REG_TXSTSQBADD, addr);
+	wrl(ep, REG_TXSTSQCURADD, addr);
+	wrw(ep, REG_TXSTSQBLEN, TX_QUEUE_ENTRIES * sizeof(struct ep93xx_tstat));
+
+	wrl(ep, REG_BMCTL, REG_BMCTL_ENABLE_TX | REG_BMCTL_ENABLE_RX);
+	wrl(ep, REG_INTEN, REG_INTEN_TX | REG_INTEN_RX);
+	wrl(ep, REG_GIINTMSK, 0);
+
+	for (i = 0; i < 10; i++) {
+		if ((rdl(ep, REG_BMSTS) & REG_BMSTS_RX_ACTIVE) != 0)
+			break;
+		msleep(1);
+	}
+
+	if (i == 10) {
+		pr_crit("hw failed to start\n");
+		return 1;
+	}
+
+	wrl(ep, REG_RXDENQ, RX_QUEUE_ENTRIES);
+	wrl(ep, REG_RXSTSENQ, RX_QUEUE_ENTRIES);
+
+	wrb(ep, REG_INDAD0, dev->dev_addr[0]);
+	wrb(ep, REG_INDAD1, dev->dev_addr[1]);
+	wrb(ep, REG_INDAD2, dev->dev_addr[2]);
+	wrb(ep, REG_INDAD3, dev->dev_addr[3]);
+	wrb(ep, REG_INDAD4, dev->dev_addr[4]);
+	wrb(ep, REG_INDAD5, dev->dev_addr[5]);
+	wrl(ep, REG_AFP, 0);
+
+	wrl(ep, REG_MAXFRMLEN, (MAX_PKT_SIZE << 16) | MAX_PKT_SIZE);
+
+	wrl(ep, REG_RXCTL, REG_RXCTL_DEFAULT);
+	wrl(ep, REG_TXCTL, REG_TXCTL_ENABLE);
+
+	return 0;
+}
+
+static void ep93xx_stop_hw(struct net_device *dev)
+{
+	struct ep93xx_priv *ep = netdev_priv(dev);
+	int i;
+
+	wrl(ep, REG_SELFCTL, REG_SELFCTL_RESET);
+	for (i = 0; i < 10; i++) {
+		if ((rdl(ep, REG_SELFCTL) & REG_SELFCTL_RESET) == 0)
+			break;
+		msleep(1);
+	}
+
+	if (i == 10)
+		pr_crit("hw failed to reset\n");
+}
+
+static int ep93xx_open(struct net_device *dev)
+{
+	struct ep93xx_priv *ep = netdev_priv(dev);
+	int err;
+
+	if (ep93xx_alloc_buffers(ep))
+		return -ENOMEM;
+
+	napi_enable(&ep->napi);
+
+	if (ep93xx_start_hw(dev)) {
+		napi_disable(&ep->napi);
+		ep93xx_free_buffers(ep);
+		return -EIO;
+	}
+
+	spin_lock_init(&ep->rx_lock);
+	ep->rx_pointer = 0;
+	ep->tx_clean_pointer = 0;
+	ep->tx_pointer = 0;
+	spin_lock_init(&ep->tx_pending_lock);
+	ep->tx_pending = 0;
+
+	err = request_irq(ep->irq, ep93xx_irq, IRQF_SHARED, dev->name, dev);
+	if (err) {
+		napi_disable(&ep->napi);
+		ep93xx_stop_hw(dev);
+		ep93xx_free_buffers(ep);
+		return err;
+	}
+
+	wrl(ep, REG_GIINTMSK, REG_GIINTMSK_ENABLE);
+
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+static int ep93xx_close(struct net_device *dev)
+{
+	struct ep93xx_priv *ep = netdev_priv(dev);
+
+	napi_disable(&ep->napi);
+	netif_stop_queue(dev);
+
+	wrl(ep, REG_GIINTMSK, 0);
+	free_irq(ep->irq, dev);
+	ep93xx_stop_hw(dev);
+	ep93xx_free_buffers(ep);
+
+	return 0;
+}
+
+static int ep93xx_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	struct ep93xx_priv *ep = netdev_priv(dev);
+	struct mii_ioctl_data *data = if_mii(ifr);
+
+	return generic_mii_ioctl(&ep->mii, data, cmd, NULL);
+}
+
+static void ep93xx_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
+{
+	strcpy(info->driver, DRV_MODULE_NAME);
+	strcpy(info->version, DRV_MODULE_VERSION);
+}
+
+static int ep93xx_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct ep93xx_priv *ep = netdev_priv(dev);
+	return mii_ethtool_gset(&ep->mii, cmd);
+}
+
+static int ep93xx_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct ep93xx_priv *ep = netdev_priv(dev);
+	return mii_ethtool_sset(&ep->mii, cmd);
+}
+
+static int ep93xx_nway_reset(struct net_device *dev)
+{
+	struct ep93xx_priv *ep = netdev_priv(dev);
+	return mii_nway_restart(&ep->mii);
+}
+
+static u32 ep93xx_get_link(struct net_device *dev)
+{
+	struct ep93xx_priv *ep = netdev_priv(dev);
+	return mii_link_ok(&ep->mii);
+}
+
+static const struct ethtool_ops ep93xx_ethtool_ops = {
+	.get_drvinfo		= ep93xx_get_drvinfo,
+	.get_settings		= ep93xx_get_settings,
+	.set_settings		= ep93xx_set_settings,
+	.nway_reset		= ep93xx_nway_reset,
+	.get_link		= ep93xx_get_link,
+};
+
+static const struct net_device_ops ep93xx_netdev_ops = {
+	.ndo_open		= ep93xx_open,
+	.ndo_stop		= ep93xx_close,
+	.ndo_start_xmit		= ep93xx_xmit,
+	.ndo_do_ioctl		= ep93xx_ioctl,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+	.ndo_set_mac_address	= eth_mac_addr,
+};
+
+static struct net_device *ep93xx_dev_alloc(struct ep93xx_eth_data *data)
+{
+	struct net_device *dev;
+
+	dev = alloc_etherdev(sizeof(struct ep93xx_priv));
+	if (dev == NULL)
+		return NULL;
+
+	memcpy(dev->dev_addr, data->dev_addr, ETH_ALEN);
+
+	dev->ethtool_ops = &ep93xx_ethtool_ops;
+	dev->netdev_ops = &ep93xx_netdev_ops;
+
+	dev->features |= NETIF_F_SG | NETIF_F_HW_CSUM;
+
+	return dev;
+}
+
+
+static int ep93xx_eth_remove(struct platform_device *pdev)
+{
+	struct net_device *dev;
+	struct ep93xx_priv *ep;
+
+	dev = platform_get_drvdata(pdev);
+	if (dev == NULL)
+		return 0;
+	platform_set_drvdata(pdev, NULL);
+
+	ep = netdev_priv(dev);
+
+	/* @@@ Force down.  */
+	unregister_netdev(dev);
+	ep93xx_free_buffers(ep);
+
+	if (ep->base_addr != NULL)
+		iounmap(ep->base_addr);
+
+	if (ep->res != NULL) {
+		release_resource(ep->res);
+		kfree(ep->res);
+	}
+
+	free_netdev(dev);
+
+	return 0;
+}
+
+static int ep93xx_eth_probe(struct platform_device *pdev)
+{
+	struct ep93xx_eth_data *data;
+	struct net_device *dev;
+	struct ep93xx_priv *ep;
+	struct resource *mem;
+	int irq;
+	int err;
+
+	if (pdev == NULL)
+		return -ENODEV;
+	data = pdev->dev.platform_data;
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	irq = platform_get_irq(pdev, 0);
+	if (!mem || irq < 0)
+		return -ENXIO;
+
+	dev = ep93xx_dev_alloc(data);
+	if (dev == NULL) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+	ep = netdev_priv(dev);
+	ep->dev = dev;
+	SET_NETDEV_DEV(dev, &pdev->dev);
+	netif_napi_add(dev, &ep->napi, ep93xx_poll, 64);
+
+	platform_set_drvdata(pdev, dev);
+
+	ep->res = request_mem_region(mem->start, resource_size(mem),
+				     dev_name(&pdev->dev));
+	if (ep->res == NULL) {
+		dev_err(&pdev->dev, "Could not reserve memory region\n");
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	ep->base_addr = ioremap(mem->start, resource_size(mem));
+	if (ep->base_addr == NULL) {
+		dev_err(&pdev->dev, "Failed to ioremap ethernet registers\n");
+		err = -EIO;
+		goto err_out;
+	}
+	ep->irq = irq;
+
+	ep->mii.phy_id = data->phy_id;
+	ep->mii.phy_id_mask = 0x1f;
+	ep->mii.reg_num_mask = 0x1f;
+	ep->mii.dev = dev;
+	ep->mii.mdio_read = ep93xx_mdio_read;
+	ep->mii.mdio_write = ep93xx_mdio_write;
+	ep->mdc_divisor = 40;	/* Max HCLK 100 MHz, min MDIO clk 2.5 MHz.  */
+
+	if (is_zero_ether_addr(dev->dev_addr))
+		random_ether_addr(dev->dev_addr);
+
+	err = register_netdev(dev);
+	if (err) {
+		dev_err(&pdev->dev, "Failed to register netdev\n");
+		goto err_out;
+	}
+
+	printk(KERN_INFO "%s: ep93xx on-chip ethernet, IRQ %d, %pM\n",
+			dev->name, ep->irq, dev->dev_addr);
+
+	return 0;
+
+err_out:
+	ep93xx_eth_remove(pdev);
+	return err;
+}
+
+
+static struct platform_driver ep93xx_eth_driver = {
+	.probe		= ep93xx_eth_probe,
+	.remove		= ep93xx_eth_remove,
+	.driver		= {
+		.name	= "ep93xx-eth",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init ep93xx_eth_init_module(void)
+{
+	printk(KERN_INFO DRV_MODULE_NAME " version " DRV_MODULE_VERSION " loading\n");
+	return platform_driver_register(&ep93xx_eth_driver);
+}
+
+static void __exit ep93xx_eth_cleanup_module(void)
+{
+	platform_driver_unregister(&ep93xx_eth_driver);
+}
+
+module_init(ep93xx_eth_init_module);
+module_exit(ep93xx_eth_cleanup_module);
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:ep93xx-eth");
