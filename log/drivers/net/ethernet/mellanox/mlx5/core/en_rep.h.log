commit 9eabd188716b2c53d8b9d23e969c6c17049f0fcc
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Fri May 29 02:25:38 2020 +0200

    mlx5: update indirect block support
    
    Register ndo callback via flow_indr_dev_register() and
    flow_indr_dev_unregister().
    
    No need for mlx5e_rep_indr_clean_block_privs() since flow_block_cb_free()
    already releases the internal mapping via ->release callback, which in
    this case is mlx5e_rep_indr_tc_block_unbind().
    
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index da9f1686d525..1d5669801484 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -69,13 +69,8 @@ struct mlx5_rep_uplink_priv {
 	 * tc_indr_block_cb_priv_list is used to lookup indirect callback
 	 * private data
 	 *
-	 * netdevice_nb is the netdev events notifier - used to register
-	 * tunnel devices for block events
-	 *
 	 */
 	struct list_head	    tc_indr_block_priv_list;
-	struct notifier_block	    netdevice_nb;
-	struct netdev_net_notifier  netdevice_nn;
 
 	struct mlx5_tun_entropy tun_entropy;
 

commit 88e96e533cfa11e996c59a44bbb6b0e0b9891970
Author: Vu Pham <vuhuong@mellanox.com>
Date:   Mon Mar 2 10:33:49 2020 -0800

    net/mlx5e: Slave representors sharing unique metadata for match
    
    Bonded slave representors' vports must share a unique metadata
    for match.
    
    On enslaving event of slave representor to lag device, allocate
    new unique "bond_metadata" for match if this is the first slave.
    The subsequent enslaved representors will share the same unique
    "bond_metadata".
    
    On unslaving event of slave representor, reset the slave
    representor's vport to use its own default metadata.
    
    Replace ingress acl and rx rules of the slave representors' vports
    using new vport->bond_metadata.
    
    Signed-off-by: Vu Pham <vuhuong@mellanox.com>
    Reviewed-by: Parav Pandit <parav@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index ed741b6e6af2..da9f1686d525 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -222,6 +222,7 @@ int mlx5e_rep_bond_enslave(struct mlx5_eswitch *esw, struct net_device *netdev,
 void mlx5e_rep_bond_unslave(struct mlx5_eswitch *esw,
 			    const struct net_device *netdev,
 			    const struct net_device *lag_dev);
+int mlx5e_rep_bond_update(struct mlx5e_priv *priv, bool cleanup);
 
 bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv);
 int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv);

commit d97555e1452943264295cd3c1f066474bc3660dd
Author: Vu Pham <vuhuong@mellanox.com>
Date:   Fri Feb 28 14:28:27 2020 -0800

    net/mlx5e: Add bond_metadata and its slave entries
    
    Adding bond_metadata and its slave entries to represent a lag device
    and its slaves VF representors. Bond_metadata structure includes a
    unique metadata shared by slaves VF respresentors, and a list of slaves
    representors slave entries.
    
    On enslaving event, create a bond_metadata structure representing
    the upper lag device of this slave representor if it has not been
    created yet. Create and add entry for the slave representor to the
    slaves list.
    
    On unslaving event, free the slave entry of the slave representor.
    On the last unslave event, free the bond_metadata structure and its
    resources.
    
    Introduce APIs to create and remove bond_metadata and its resources,
    enslave and unslave VF representor slave entries.
    
    Signed-off-by: Vu Pham <vuhuong@mellanox.com>
    Reviewed-by: Parav Pandit <parav@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 7e56787aa224..ed741b6e6af2 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -217,6 +217,11 @@ void mlx5e_rep_register_vport_reps(struct mlx5_core_dev *mdev);
 void mlx5e_rep_unregister_vport_reps(struct mlx5_core_dev *mdev);
 int mlx5e_rep_bond_init(struct mlx5e_rep_priv *rpriv);
 void mlx5e_rep_bond_cleanup(struct mlx5e_rep_priv *rpriv);
+int mlx5e_rep_bond_enslave(struct mlx5_eswitch *esw, struct net_device *netdev,
+			   struct net_device *lag_dev);
+void mlx5e_rep_bond_unslave(struct mlx5_eswitch *esw,
+			    const struct net_device *netdev,
+			    const struct net_device *lag_dev);
 
 bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv);
 int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv);

commit 7e51891a237f9ea319f53f9beb83afb0077d88e6
Author: Or Gerlitz <ogerlitz@mellanox.com>
Date:   Fri Jun 21 13:23:44 2019 -0700

    net/mlx5e: Use netdev events to set/del egress acl forward-to-vport rule
    
    Register a notifier block to handle netdev events for bond device
    of non-uplink representors to support eswitch vports bonding.
    
    When a non-uplink representor is a lower dev (slave) of bond and
    becomes active, adding egress acl forward-to-vport rule of all slave
    netdevs (active + standby) to forward to this representor's vport. Use
    change lower netdev event to do this.
    
    Use change upper event to detect slave representor unslaved from lag
    device to delete its vport egress acl forward rule if any.
    
    Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Vu Pham <vuhuong@mellanox.com>
    Reviewed-by: Parav Pandit <parav@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 1c4af8522467..7e56787aa224 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -56,6 +56,7 @@ struct mlx5e_neigh_update_table {
 };
 
 struct mlx5_tc_ct_priv;
+struct mlx5e_rep_bond;
 struct mlx5_rep_uplink_priv {
 	/* Filters DB - instantiated by the uplink representor and shared by
 	 * the uplink's VFs
@@ -89,6 +90,9 @@ struct mlx5_rep_uplink_priv {
 	struct mapping_ctx *tunnel_enc_opts_mapping;
 
 	struct mlx5_tc_ct_priv *ct_priv;
+
+	/* support eswitch vports bonding */
+	struct mlx5e_rep_bond *bond;
 };
 
 struct mlx5e_rep_priv {
@@ -211,6 +215,9 @@ struct mlx5e_rep_sq {
 
 void mlx5e_rep_register_vport_reps(struct mlx5_core_dev *mdev);
 void mlx5e_rep_unregister_vport_reps(struct mlx5_core_dev *mdev);
+int mlx5e_rep_bond_init(struct mlx5e_rep_priv *rpriv);
+void mlx5e_rep_bond_cleanup(struct mlx5e_rep_priv *rpriv);
+
 bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv);
 int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv);
 void mlx5e_remove_sqs_fwd_rules(struct mlx5e_priv *priv);

commit 13209a8f7304a34158f4366e8ea07a1965c05ac7
Merge: 316107119f47 98790bbac4db
Author: David S. Miller <davem@davemloft.net>
Date:   Sun May 24 13:47:27 2020 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net
    
    The MSCC bug fix in 'net' had to be slightly adjusted because the
    register accesses are done slightly differently in net-next.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 321348475d544aa6705dcfac2135deeccb8dc0bb
Author: Maor Dickman <maord@mellanox.com>
Date:   Thu Apr 23 15:16:17 2020 +0300

    net/mlx5e: Fix allowed tc redirect merged eswitch offload cases
    
    After changing the parent_id to be the same for both NICs of same
    The cited commit wrongly allow offload of tc redirect flows from
    VF to uplink and vice versa when devcies are on different eswitch,
    these cases aren't supported by HW.
    
    Disallow the above offloads when devcies are on different eswitch
    and VF LAG is not configured.
    
    Fixes: f6dc1264f1c0 ("net/mlx5e: Disallow tc redirect offload cases we don't support")
    Signed-off-by: Maor Dickman <maord@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 6a2337900420..612b5cf0673d 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -210,8 +210,13 @@ void mlx5e_rep_encap_entry_detach(struct mlx5e_priv *priv,
 
 void mlx5e_rep_queue_neigh_stats_work(struct mlx5e_priv *priv);
 
-bool mlx5e_eswitch_rep(struct net_device *netdev);
+bool mlx5e_eswitch_vf_rep(struct net_device *netdev);
 bool mlx5e_eswitch_uplink_rep(struct net_device *netdev);
+static inline bool mlx5e_eswitch_rep(struct net_device *netdev)
+{
+	return mlx5e_eswitch_vf_rep(netdev) ||
+	       mlx5e_eswitch_uplink_rep(netdev);
+}
 
 #else /* CONFIG_MLX5_ESWITCH */
 static inline bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv) { return false; }

commit 14e6b038afa014ac2288a2f3d692697f708ba344
Author: Eli Cohen <eli@mellanox.com>
Date:   Mon Feb 3 13:44:14 2020 +0200

    net/mlx5e: Add support for hw decapsulation of MPLS over UDP
    
    MPLS over UDP is supported in hardware by using a packet reformat object
    with reformat type equal L3_TUNNEL_TO_L2 which both decapsulates the
    outer L3, L4 and MPLS headers, and allows for setting the L2 headers of
    the resulting decapsulated packet. For the hardware to operate
    correctly, the configuration of the firmware must have
    FLEX_PARSER_PROFILE_ENABLE = 1.
    
    Example tc rule:
      tc filter add dev bareudp0 protocol all prio 1 root flower enc_dst_port \
          6635 enc_src_ip 8.8.8.23 action mpls pop protocol ip pipe \
          action pedit ex munge eth dst set 00:11:22:33:44:21 pipe action \
          mirred egress redirect dev enp59s0f0_0
    
    We use pedit to set the correct destination MAC.
    
    For MPLS over UDP decapsulation to take place, the driver logic requires
    the following:
    
    1. flower filter added on bareudp device.
    2. action mpls pop
    3. zero or more pedit munge actions
    4. one redirect action
    
    Current implementation supports only IPv4 and no VLAN.
    
    tc filter show output looks like this:
       filter protocol all pref 1 flower chain 0
       filter protocol all pref 1 flower chain 0 handle 0x1
         enc_src_ip 8.8.8.24
         enc_dst_port 6635
         in_hw in_hw_count 1
                action order 1: mpls  pop protocol ip pipe
                 index 2 ref 1 bind 1
    
                action order 2:  pedit action pipe keys 2
                 index 1 ref 1 bind 1
                 key #0  at eth+0: val 00112233 mask 00000000
                 key #1  at eth+4: val 44210000 mask 0000ffff
    
                action order 3: mirred (Egress Redirect to device enp59s0f0_0) stolen
                index 2 ref 1 bind 1
    
    Signed-off-by: Eli Cohen <eli@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Reviewed-by: Eli Britstein <elibr@mellanox.com>
    Reviewed-by: Vlad Buslov <vladbu@mellanox.com>
    Reviewed-by: Paul Blakey <paulb@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 81ed06e58fea..93e911baacad 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -158,6 +158,22 @@ struct mlx5e_neigh_hash_entry {
 enum {
 	/* set when the encap entry is successfully offloaded into HW */
 	MLX5_ENCAP_ENTRY_VALID     = BIT(0),
+	MLX5_REFORMAT_DECAP        = BIT(1),
+};
+
+struct mlx5e_decap_key {
+	struct ethhdr key;
+};
+
+struct mlx5e_decap_entry {
+	struct mlx5e_decap_key key;
+	struct list_head flows;
+	struct hlist_node hlist;
+	refcount_t refcnt;
+	struct completion res_ready;
+	int compl_result;
+	struct mlx5_pkt_reformat *pkt_reformat;
+	struct rcu_head rcu;
 };
 
 struct mlx5e_encap_entry {

commit 549c243e4e010067a075e248f4d72e8dda844e12
Author: Vlad Buslov <vladbu@mellanox.com>
Date:   Tue May 12 17:29:22 2020 +0300

    net/mlx5e: Extract neigh-specific code from en_rep.c to rep/neigh.c
    
    As a preparation for introducing new kconfig option that controls
    compilation of all TC offloads code in mlx5, extract neigh-specific code
    from en_rep.c to standalone file. This allows easily compiling out the code
    by only including new source in make file when corresponding kconfig is
    enabled instead of adding multiple ifdef blocks to en_rep.
    
    Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 74d46e9a201a..81ed06e58fea 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -208,14 +208,6 @@ void mlx5e_rep_queue_neigh_stats_work(struct mlx5e_priv *priv);
 bool mlx5e_eswitch_rep(struct net_device *netdev);
 bool mlx5e_eswitch_uplink_rep(struct net_device *netdev);
 
-struct mlx5e_neigh_hash_entry *
-mlx5e_rep_neigh_entry_lookup(struct mlx5e_priv *priv,
-			     struct mlx5e_neigh *m_neigh);
-int mlx5e_rep_neigh_entry_create(struct mlx5e_priv *priv,
-				 struct mlx5e_encap_entry *e,
-				 struct mlx5e_neigh_hash_entry **nhe);
-void mlx5e_rep_neigh_entry_release(struct mlx5e_neigh_hash_entry *nhe);
-
 #else /* CONFIG_MLX5_ESWITCH */
 static inline bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv) { return false; }
 static inline int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv) { return 0; }

commit 768c3667e6f36bc9db0dac854aa198651b27412f
Author: Vlad Buslov <vladbu@mellanox.com>
Date:   Tue May 12 16:41:41 2020 +0300

    net/mlx5e: Extract TC-specific code from en_rep.c to rep/tc.c
    
    As a preparation for introducing new kconfig option that controls
    compilation of all TC offloads code in mlx5, extract TC-specific code from
    en_rep.c to standalone file. This allows easily compiling out the code by
    only including new source in make file when corresponding kconfig is
    enabled instead of adding multiple ifdef blocks to en_rep.
    
    Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 6a2337900420..74d46e9a201a 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -203,16 +203,19 @@ void mlx5e_handle_rx_cqe_rep(struct mlx5e_rq *rq, struct mlx5_cqe64 *cqe);
 void mlx5e_handle_rx_cqe_mpwrq_rep(struct mlx5e_rq *rq,
 				   struct mlx5_cqe64 *cqe);
 
-int mlx5e_rep_encap_entry_attach(struct mlx5e_priv *priv,
-				 struct mlx5e_encap_entry *e);
-void mlx5e_rep_encap_entry_detach(struct mlx5e_priv *priv,
-				  struct mlx5e_encap_entry *e);
-
 void mlx5e_rep_queue_neigh_stats_work(struct mlx5e_priv *priv);
 
 bool mlx5e_eswitch_rep(struct net_device *netdev);
 bool mlx5e_eswitch_uplink_rep(struct net_device *netdev);
 
+struct mlx5e_neigh_hash_entry *
+mlx5e_rep_neigh_entry_lookup(struct mlx5e_priv *priv,
+			     struct mlx5e_neigh *m_neigh);
+int mlx5e_rep_neigh_entry_create(struct mlx5e_priv *priv,
+				 struct mlx5e_encap_entry *e,
+				 struct mlx5e_neigh_hash_entry **nhe);
+void mlx5e_rep_neigh_entry_release(struct mlx5e_neigh_hash_entry *nhe);
+
 #else /* CONFIG_MLX5_ESWITCH */
 static inline bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv) { return false; }
 static inline int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv) { return 0; }

commit 4c3844d9e97e10f0cf024fe7f24dcefa133fe9e2
Author: Paul Blakey <paulb@mellanox.com>
Date:   Thu Mar 12 12:23:14 2020 +0200

    net/mlx5e: CT: Introduce connection tracking
    
    Add support for offloading tc ct action and ct matches.
    We translate the tc filter with CT action the following HW model:
    
    +-------------------+      +--------------------+    +--------------+
    + pre_ct (tc chain) +----->+ CT (nat or no nat) +--->+ post_ct      +----->
    + original match    +  |   + tuple + zone match + |  + fte_id match +  |
    +-------------------+  |   +--------------------+ |  +--------------+  |
                           v                          v                    v
                          set chain miss mapping  set mark             original
                          set fte_id              set label            filter
                          set zone                set established      actions
                          set tunnel_id           do nat (if needed)
                          do decap
    
    Signed-off-by: Paul Blakey <paulb@mellanox.com>
    Reviewed-by: Oz Shlomo <ozsh@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 2bbdbdc8ea7e..6a2337900420 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -55,6 +55,7 @@ struct mlx5e_neigh_update_table {
 	unsigned long           min_interval; /* jiffies */
 };
 
+struct mlx5_tc_ct_priv;
 struct mlx5_rep_uplink_priv {
 	/* Filters DB - instantiated by the uplink representor and shared by
 	 * the uplink's VFs
@@ -86,6 +87,8 @@ struct mlx5_rep_uplink_priv {
 	struct mapping_ctx *tunnel_mapping;
 	/* maps tun_enc_opts to a unique id*/
 	struct mapping_ctx *tunnel_enc_opts_mapping;
+
+	struct mlx5_tc_ct_priv *ct_priv;
 };
 
 struct mlx5e_rep_priv {

commit bf3347c4d15e26ab17fce3aa4041345198f4280c
Merge: 93e616131a38 b8ce90370977
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Mar 12 12:34:23 2020 -0700

    Merge branch 'ct-offload' of git://git.kernel.org/pub/scm/linux/kernel/git/saeed/linux

commit 20f7b37ffc7da5beb9c98382ca70b918f2282060
Author: Saeed Mahameed <saeedm@mellanox.com>
Date:   Wed May 15 02:21:35 2019 -0700

    net/mlx5e: Introduce root ft concept for representors netdevs
    
    Uplink representor traffic will be redirected to an empty root ft rather
    than directly to a direct tir or ttc table, this root ft will be empty and
    will be used as a link for auto-chaining with ttc table or ethtool tables
    in downstream patches.
    
    On load, fs core will connect uplink rep root_ft with ttc table.  In case
    ethtool steering will be used, fs core will auto connect root_ft with
    the ethtool bypass tables, which will be connected with the ttc table.
    
    vport_rx_rule[uplink_rep]->root_ft->ethtool->ttc.
    
    For non-uplink representors, for simplicity root_ft will always point at
    ttc table, hence the replace vport_rx rule logic is removed.
    
    vport_rx_rule[non_uplink_rep]->root_ft(ttc).
    
    For now ethtool steering support can only be available on uplink rep.
    
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 8336301476a9..3d9c72eee9fa 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -87,6 +87,7 @@ struct mlx5e_rep_priv {
 	struct mlx5_eswitch_rep *rep;
 	struct mlx5e_neigh_update_table neigh_update;
 	struct net_device      *netdev;
+	struct mlx5_flow_table *root_ft;
 	struct mlx5_flow_handle *vport_rx_rule;
 	struct list_head       vport_sqs_list;
 	struct mlx5_rep_uplink_priv uplink_priv; /* valid for uplink rep */

commit ffec97020f841fefa508db038bad58bc6def9431
Author: Tonghao Zhang <xiangxia.m.yue@gmail.com>
Date:   Mon Feb 17 22:08:50 2020 +0800

    net/mlx5e: Don't allow forwarding between uplink
    
    We can install forwarding packets rule between uplink
    in switchdev mode, as show below. But the hardware does
    not do that as expected (mlnx_perf -i $PF1, we can't get
    the counter of the PF1). By the way, if we add the uplink
    PF0, PF1 to Open vSwitch and enable hw-offload, the rules
    can be offloaded but not work fine too. This patch add a
    check and if so return -EOPNOTSUPP.
    
    $ tc filter add dev $PF0 protocol all parent ffff: prio 1 handle 1 \
        flower skip_sw action mirred egress redirect dev $PF1
    
    $ tc -d -s filter show dev $PF0 ingress
        skip_sw
        in_hw in_hw_count 1
        action order 1: mirred (Egress Redirect to device enp130s0f1) stolen
        ...
        Sent hardware 408954 bytes 4173 pkt
        ...
    
    Signed-off-by: Tonghao Zhang <xiangxia.m.yue@gmail.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 3f756d51435f..8336301476a9 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -200,6 +200,7 @@ void mlx5e_rep_encap_entry_detach(struct mlx5e_priv *priv,
 void mlx5e_rep_queue_neigh_stats_work(struct mlx5e_priv *priv);
 
 bool mlx5e_eswitch_rep(struct net_device *netdev);
+bool mlx5e_eswitch_uplink_rep(struct net_device *netdev);
 
 #else /* CONFIG_MLX5_ESWITCH */
 static inline bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv) { return false; }

commit 0a7fcb78cc21d339c4eba2827df846e69cec1d07
Author: Paul Blakey <paulb@mellanox.com>
Date:   Sun Feb 16 12:01:34 2020 +0200

    net/mlx5e: Support inner header rewrite with goto action
    
    The hardware supports header rewrite of outer headers only.
    To perform header rewrite on inner headers, we must first
    decapsulate the packet.
    
    Currently, the hardware decap action is explicitly set by the tc
    tunnel_key unset action. However, with goto action the user won't
    use the tunnel_key unset action. In addition, header rewrites actions
    will not apply to the inner header as done by the software model.
    
    To support this, we will map each tunnel matches seen on a tc rule to
    a unique tunnel id, implicity add a decap action on tc chain 0 flows,
    and mark the packets with this unique tunnel id. Tunnel matches on
    the decapsulated tunnel on later chains will match on this unique id
    instead of the actual packet.
    
    We will also use this mapping to restore the tunnel info metadata
    on miss.
    
    Signed-off-by: Paul Blakey <paulb@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Reviewed-by: Oz Shlomo <ozsh@mellanox.com>
    Reviewed-by: Mark Bloch <markb@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 6ff7d901d708..4cdb36e59c43 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -81,6 +81,11 @@ struct mlx5_rep_uplink_priv {
 	struct mutex                unready_flows_lock;
 	struct list_head            unready_flows;
 	struct work_struct          reoffload_flows_work;
+
+	/* maps tun_info to a unique id*/
+	struct mapping_ctx *tunnel_mapping;
+	/* maps tun_enc_opts to a unique id*/
+	struct mapping_ctx *tunnel_enc_opts_mapping;
 };
 
 struct mlx5e_rep_priv {

commit dfd9e7500cd4b21b61d65907e02880b20de929aa
Author: Paul Blakey <paulb@mellanox.com>
Date:   Sun Feb 16 12:01:29 2020 +0200

    net/mlx5e: Rx, Split rep rx mpwqe handler from nic
    
    Copy the current rep mpwqe rx handler which is also used by nic
    profile. In the next patch, we will add rep specific logic, just
    for the rep profile rx handler.
    
    Signed-off-by: Paul Blakey <paulb@mellanox.com>
    Reviewed-by: Oz Shlomo <ozsh@mellanox.com>
    Reviewed-by: Mark Bloch <markb@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 3f756d51435f..6ff7d901d708 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -191,6 +191,8 @@ int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv);
 void mlx5e_remove_sqs_fwd_rules(struct mlx5e_priv *priv);
 
 void mlx5e_handle_rx_cqe_rep(struct mlx5e_rq *rq, struct mlx5_cqe64 *cqe);
+void mlx5e_handle_rx_cqe_mpwrq_rep(struct mlx5e_rq *rq,
+				   struct mlx5_cqe64 *cqe);
 
 int mlx5e_rep_encap_entry_attach(struct mlx5e_priv *priv,
 				 struct mlx5e_encap_entry *e);

commit d48834f9d4b4e7611cc84ac2c5018f1b420d59c2
Author: Jiri Pirko <jiri@mellanox.com>
Date:   Sat Jan 25 12:17:09 2020 +0100

    mlx5: Use dev_net netdevice notifier registrations
    
    Register the dev_net notifier and allow the per-net notifier to follow
    the device into different namespace.
    
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 31f83c8adcc9..3f756d51435f 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -73,6 +73,7 @@ struct mlx5_rep_uplink_priv {
 	 */
 	struct list_head	    tc_indr_block_priv_list;
 	struct notifier_block	    netdevice_nb;
+	struct netdev_net_notifier  netdevice_nn;
 
 	struct mlx5_tun_entropy tun_entropy;
 

commit a6d35fb47a3f9943f792f660655dae3505db96e9
Author: Roi Dayan <roid@mellanox.com>
Date:   Mon Sep 2 14:56:19 2019 +0300

    net/mlx5e: Remove leftover declaration
    
    This function was removed in the cited commit below.
    
    Fixes: 13e509a4c194 ("net/mlx5e: Remove leftover code from the PF netdev being uplink rep")
    Signed-off-by: Roi Dayan <roid@mellanox.com>
    Reviewed-by: Vlad Buslov <vladbu@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 8e512216deb8..31f83c8adcc9 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -183,7 +183,6 @@ struct mlx5e_rep_sq {
 	struct list_head	 list;
 };
 
-void *mlx5e_alloc_nic_rep_priv(struct mlx5_core_dev *mdev);
 void mlx5e_rep_register_vport_reps(struct mlx5_core_dev *mdev);
 void mlx5e_rep_unregister_vport_reps(struct mlx5_core_dev *mdev);
 bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv);

commit 2b688ea5efdee2868ed23eddfdbe27dbd232edac
Author: Maor Gottlieb <maorg@mellanox.com>
Date:   Thu Aug 15 13:54:17 2019 +0300

    net/mlx5: Add flow steering actions to fs_cmd shim layer
    
    Add flow steering actions: modify header and packet reformat
    to the fs_cmd shim layer. This allows each namespace to define
    possibly different functionality for alloc/dealloc action commands.
    
    Signed-off-by: Maor Gottlieb <maorg@mellanox.com>
    Reviewed-by: Mark Bloch <markb@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index a0ae5069d8c3..8e512216deb8 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -161,7 +161,7 @@ struct mlx5e_encap_entry {
 	 */
 	struct hlist_node encap_hlist;
 	struct list_head flows;
-	u32 encap_id;
+	struct mlx5_pkt_reformat *pkt_reformat;
 	const struct ip_tunnel_info *tun_info;
 	unsigned char h_dest[ETH_ALEN];	/* destination eth addr	*/
 

commit ac0d917632cf7fbbe953f2ec82c2c979ab1b4a06
Author: Vlad Buslov <vladbu@mellanox.com>
Date:   Mon Jun 11 14:16:14 2018 +0300

    net/mlx5e: Protect neigh hash encap list with spinlock and rcu
    
    Rcu-ify mlx5e_neigh_hash_entry->encap_list by changing operations on encap
    list to their rcu counterparts and extending encap structure with rcu_head
    to free the encap instances after rcu grace period. Use rcu read lock when
    traversing encap list. Implement helper mlx5e_get_next_valid_encap()
    function that is used by mlx5e_tc_update_neigh_used_value() to safely
    iterate over valid entries of nhe->encap_list.
    
    Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
    Reviewed-by: Jianbo Liu <jianbol@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 8fa27832bd81..a0ae5069d8c3 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -119,6 +119,8 @@ struct mlx5e_neigh_hash_entry {
 	 */
 	struct list_head neigh_list;
 
+	/* protects encap list */
+	spinlock_t encap_list_lock;
 	/* encap list sharing the same neigh */
 	struct list_head encap_list;
 
@@ -173,6 +175,7 @@ struct mlx5e_encap_entry {
 	refcount_t refcnt;
 	struct completion res_ready;
 	int compl_result;
+	struct rcu_head rcu;
 };
 
 struct mlx5e_rep_sq {

commit 70e83bd3b0e434ee9fa8e0010f76080aa4320725
Author: Vlad Buslov <vladbu@mellanox.com>
Date:   Tue Jun 12 11:59:43 2018 +0300

    net/mlx5e: Refactor mlx5e_neigh_update_table->encap_lock
    
    To remove dependency on rtnl lock, always take neigh update encap lock when
    modifying neigh update hash table and list. Originally, this lock was only
    used to synchronize with netevent handler function, which is called from bh
    context and cannot use rtnl lock for synchronization. Take lock in encap
    entry attach function to prevent concurrent modifications of neigh update
    hash table and list.
    
    Taking the encap lock when creating new nhe introduces a problem that we
    need to allocate new entry with sleeping GFP_KERNEL flag while holding a
    spinlock. However, since previous patch in this series has already
    converted lookup in netevent handler function to user rcu read lock instead
    of encap lock, we can safely convert the lock type to mutex.
    
    Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
    Reviewed-by: Jianbo Liu <jianbol@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index d057e401b0de..8fa27832bd81 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -35,6 +35,7 @@
 
 #include <net/ip_tunnels.h>
 #include <linux/rhashtable.h>
+#include <linux/mutex.h>
 #include "eswitch.h"
 #include "en.h"
 #include "lib/port_tun.h"
@@ -48,7 +49,7 @@ struct mlx5e_neigh_update_table {
 	 */
 	struct list_head	neigh_list;
 	/* protect lookup/remove operations */
-	spinlock_t              encap_lock;
+	struct mutex		encap_lock;
 	struct notifier_block   netevent_nb;
 	struct delayed_work     neigh_stats_work;
 	unsigned long           min_interval; /* jiffies */

commit 1216ce9d4a740bed88393177174fef275069a560
Author: Vlad Buslov <vladbu@mellanox.com>
Date:   Fri Jun 8 11:49:28 2018 +0300

    net/mlx5e: Extend neigh hash entry with rcu
    
    To remove dependency on rtnl lock and to allow unlocked iteration over list
    of neigh hash entries, extend nhe with rcu. Change operations on neigh list
    to their rcu counterparts and free neigh hash entry with rcu timeout.
    
    Introduce mlx5e_get_next_nhe() helper that is used to iterate over rcu
    neigh list with reference to nhe taken.
    
    Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
    Reviewed-by: Jianbo Liu <jianbol@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index f5bc9772be98..d057e401b0de 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -138,6 +138,8 @@ struct mlx5e_neigh_hash_entry {
 	 * 'used' value and avoid neigh deleting by the kernel.
 	 */
 	unsigned long reported_lastuse;
+
+	struct rcu_head rcu;
 };
 
 enum {

commit 61081f9c09df33fe0123d234e840e3b4d3c17269
Author: Vlad Buslov <vladbu@mellanox.com>
Date:   Fri Jun 8 11:31:28 2018 +0300

    net/mlx5e: Always take reference to neigh entry
    
    Neigh entry has reference counter, however it is only used when scheduling
    neigh update event. In all other cases reference to neigh entry is not
    taken while working with it. Neigh code relies on synchronization provided
    by rtnl lock and uses encap list size as implicit reference counter.
    
    To remove dependency on rtnl lock, always take reference to neigh entry
    while using it. Remove neigh entry from hash table and delete it only when
    reference counter reaches zero. This can result spurious neigh update
    events, when there is an event on entry that has zero encaps attached.
    However, such events are rare and properly handled by neigh update handler.
    
    Extend encap entry with reference to neigh hash entry in order to be able
    to directly release it when encap is detached, instead of lookup nhe by key
    through hash table. Extend nhe with reference to device priv structure to
    guarantee correctness when nhe is used with stack devices, bond setup, in
    which case it is non-trivial to determine correct device when releasing the
    nhe.
    
    Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
    Reviewed-by: Jianbo Liu <jianbol@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 8ac96727cad8..f5bc9772be98 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -110,6 +110,7 @@ struct mlx5e_neigh {
 struct mlx5e_neigh_hash_entry {
 	struct rhash_head rhash_node;
 	struct mlx5e_neigh m_neigh;
+	struct mlx5e_priv *priv;
 
 	/* Save the neigh hash entry in a list on the representor in
 	 * addition to the hash table. In order to iterate easily over the
@@ -145,6 +146,8 @@ enum {
 };
 
 struct mlx5e_encap_entry {
+	/* attached neigh hash entry */
+	struct mlx5e_neigh_hash_entry *nhe;
 	/* neigh hash entry list of encaps sharing the same neigh */
 	struct list_head encap_list;
 	struct mlx5e_neigh m_neigh;

commit d589e785baf5e48ee80a4fbfed96661a4c7c8c8d
Author: Vlad Buslov <vladbu@mellanox.com>
Date:   Thu Aug 8 17:01:33 2019 +0300

    net/mlx5e: Allow concurrent creation of encap entries
    
    Encap entries creation is fully synchronized by encap_tbl_lock. In order to
    allow concurrent allocation of hardware resources used to offload
    encapsulation, extend mlx5e_encap_entry with 'res_ready' completion. Move
    call to mlx5e_tc_tun_create_header_ipv{4|6}() out of encap_tbl_lock
    critical section. Modify code that attaches new flows to existing encap to
    wait for 'res_ready' completion before using the entry. Insert encap entry
    to table before provisioning it to hardware and modify all users of the
    encap table to verify that encap was fully initialized by checking
    completion result for non-zero value (and to wait for 'res_ready'
    completion, if necessary).
    
    Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 2e970d0729be..8ac96727cad8 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -165,6 +165,8 @@ struct mlx5e_encap_entry {
 	char *encap_header;
 	int encap_size;
 	refcount_t refcnt;
+	struct completion res_ready;
+	int compl_result;
 };
 
 struct mlx5e_rep_sq {

commit 948993f2beebbdc1c9d926cfdad9827cf6bb67c0
Author: Vlad Buslov <vladbu@mellanox.com>
Date:   Sun Jun 3 20:31:47 2018 +0300

    net/mlx5e: Extend encap entry with reference counter
    
    List of flows attached to encap entry is used as implicit reference
    counter (encap entry is deallocated when list becomes free) and as a
    mechanism to obtain encap entry that flow is attached to (through list
    head). This is not safe when concurrent modification of list of flows
    attached to encap entry is possible. Proper atomic reference counter is
    required to support concurrent access.
    
    As a preparation for extending encap with reference counting, extract code
    that lookups and deletes encap entry into standalone put/get helpers. In
    order to remove this dependency on external locking, extend encap entry
    with reference counter to manage its lifetime and extend flow structure
    with direct pointer to encap entry that flow is attached to.
    
    Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
    Reviewed-by: Jianbo Liu <jianbol@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 43eeebe9c8d2..2e970d0729be 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -164,6 +164,7 @@ struct mlx5e_encap_entry {
 	u8 flags;
 	char *encap_header;
 	int encap_size;
+	refcount_t refcnt;
 };
 
 struct mlx5e_rep_sq {

commit fcb64c0f5640e629bd77c2cb088f9fd70ff5bde7
Author: Eli Cohen <eli@mellanox.com>
Date:   Wed May 8 11:44:56 2019 +0300

    net/mlx5: E-Switch, add ingress rate support
    
    Use the scheduling elements to implement ingress rate limiter on an
    eswitch ports ingress traffic. Since the ingress of eswitch port is the
    egress of VF port, we control eswitch ingress by controlling VF egress.
    
    Configuration is done using the ports' representor net devices.
    
    Please note that burst size configuration is not supported by devices
    ConnectX-5 and earlier generations.
    
    Configuration examples:
    tc:
    tc filter add dev enp59s0f0_0 root protocol ip matchall action police rate 1mbit burst 20k
    
    ovs:
    ovs-vsctl set interface eth0 ingress_policing_rate=1000
    
    Signed-off-by: Eli Cohen <eli@mellanox.com>
    Reviewed-by: Paul Blakey <paulb@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 10fafd5fa17b..43eeebe9c8d2 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -88,6 +88,7 @@ struct mlx5e_rep_priv {
 	struct mlx5_flow_handle *vport_rx_rule;
 	struct list_head       vport_sqs_list;
 	struct mlx5_rep_uplink_priv uplink_priv; /* valid for uplink rep */
+	struct rtnl_link_stats64 prev_vf_vport_stats;
 	struct devlink_port dl_port;
 };
 

commit ad86755b18d5edf1956f6d25c844f27289216877
Author: Vlad Buslov <vladbu@mellanox.com>
Date:   Wed Mar 13 19:50:24 2019 +0200

    net/mlx5e: Protect unready flows with dedicated lock
    
    In order to remove dependency on rtnl lock for protecting unready_flows
    list when reoffloading unready flows on workqueue, extend representor
    uplink private structure with dedicated 'unready_flows_lock' mutex. Take
    the lock in all users of unready_flows list before accessing it. Implement
    helper functions to add and delete unready flow.
    
    Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
    Reviewed-by: Jianbo Liu <jianbol@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index c56e6ee4350c..10fafd5fa17b 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -75,6 +75,8 @@ struct mlx5_rep_uplink_priv {
 
 	struct mlx5_tun_entropy tun_entropy;
 
+	/* protects unready_flows */
+	struct mutex                unready_flows_lock;
 	struct list_head            unready_flows;
 	struct work_struct          reoffload_flows_work;
 };

commit f60f315d339e14633a51cd2d468500d08055b84b
Author: Parav Pandit <parav@mellanox.com>
Date:   Mon Jul 8 23:17:39 2019 -0500

    net/mlx5e: Register devlink ports for physical link, PCI PF, VFs
    
    Register devlink port of physical port, PCI PF and PCI VF flavour
    for each PF, VF when a given devlink instance is in switchdev mode.
    
    Implement ndo_get_devlink_port callback API to make use of registered
    devlink ports.
    This eliminates ndo_get_phys_port_name() and ndo_get_port_parent_id()
    callbacks. Hence, remove them.
    
    An example output with 2 VFs, without a PF and single uplink port is
    below.
    
    $devlink port show
    pci/0000:06:00.0/65535: type eth netdev ens2f0 flavour physical
    pci/0000:05:00.0/1: type eth netdev eth1 flavour pcivf pfnum 0 vfnum 0
    pci/0000:05:00.0/2: type eth netdev eth2 flavour pcivf pfnum 0 vfnum 1
    
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Acked-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: Parav Pandit <parav@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index d4585f3b8cb2..c56e6ee4350c 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -86,6 +86,7 @@ struct mlx5e_rep_priv {
 	struct mlx5_flow_handle *vport_rx_rule;
 	struct list_head       vport_sqs_list;
 	struct mlx5_rep_uplink_priv uplink_priv; /* valid for uplink rep */
+	struct devlink_port dl_port;
 };
 
 static inline

commit d386939a327d2f1c9e918ee843087124eee0efda
Author: Yevgeny Kliteynik <kliteyn@mellanox.com>
Date:   Sun Apr 14 17:50:01 2019 +0300

    net/mlx5e: Rearrange tc tunnel code in a modular way
    
    Rearrange tc tunnel code so that it would be easy to add future tunnels:
     - Define tc tunnel object with the fields and callbacks that any
       tunnel must implement.
     - Define tc UDP tunnel object for UDP tunnels, such as VXLAN
     - Move each tunnel code (GRE, VXLAN) to its own separate file
     - Rewrite tc tunnel implementation in a general way - using only
       the objects and their callbacks.
    
    Reviewed-by: Oz Shlomo <ozsh@mellanox.com>
    Signed-off-by: Yevgeny Kliteynik <kliteyn@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 5472bb4a0b51..d4585f3b8cb2 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -155,8 +155,7 @@ struct mlx5e_encap_entry {
 
 	struct net_device *out_dev;
 	struct net_device *route_dev;
-	int tunnel_type;
-	int tunnel_hlen;
+	struct mlx5e_tc_tunnel *tunnel;
 	int reformat_type;
 	u8 flags;
 	char *encap_header;

commit 1f6da30697d0e102f5ed983a2a4942df9875195a
Author: Yevgeny Kliteynik <kliteyn@mellanox.com>
Date:   Tue Feb 12 13:31:00 2019 +0200

    net/mlx5e: Geneve, Keep tunnel info as pointer to the original struct
    
    In mlx5e encap entry structure, IP tunnel info data structure is copied
    by value. This approach worked till now, but it breaks when there are
    encapsulation options, such as in case of Geneve.
    
    These options are stored in the structure that is allocated adjacent to
    the IP tunnel info struct, and not pointed at by any field in that struct.
    Therefore, when copying the struct by value, we loose the address of the
    original struct and can't get to the encapsulation options.
    
    Fix the problem by storing the pointer to the tunnel info data instead.
    
    Reviewed-by: Oz Shlomo <ozsh@mellanox.com>
    Signed-off-by: Yevgeny Kliteynik <kliteyn@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index e34573fd88c1..5472bb4a0b51 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -150,7 +150,7 @@ struct mlx5e_encap_entry {
 	struct hlist_node encap_hlist;
 	struct list_head flows;
 	u32 encap_id;
-	struct ip_tunnel_info tun_info;
+	const struct ip_tunnel_info *tun_info;
 	unsigned char h_dest[ETH_ALEN];	/* destination eth addr	*/
 
 	struct net_device *out_dev;

commit 8693115af4c24d92b971ad895c5f329761ed5d38
Author: Parav Pandit <parav@mellanox.com>
Date:   Wed May 29 22:50:41 2019 +0000

    {IB,net}/mlx5: Constify rep ops functions pointers
    
    Currently for every representor type and for every single vport,
    representer function pointers copy is stored even though they don't
    change from one to other vport.
    
    Additionally priv data entry for the rep is not passed during
    registration, but its copied. It is used (set and cleared) by the user
    of the reps.
    
    As we want to scale vports, to simplify and also to split constants
    from data,
    
    1. Rename mlx5_eswitch_rep_if to mlx5_eswitch_rep_ops as to match _ops
    prefix with other standard netdev, ibdev ops.
    2. Constify the IB and Ethernet rep ops structure.
    3. Instead of storing copy of all rep function pointers, store copy
    per eswitch rep type.
    4. Split data and function pointers to mlx5_eswitch_rep_ops and
    mlx5_eswitch_rep_data.
    
    Signed-off-by: Parav Pandit <parav@mellanox.com>
    Reviewed-by: Mark Bloch <markb@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index c40c025afd99..e34573fd88c1 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -91,7 +91,7 @@ struct mlx5e_rep_priv {
 static inline
 struct mlx5e_rep_priv *mlx5e_rep_to_rep_priv(struct mlx5_eswitch_rep *rep)
 {
-	return rep->rep_if[REP_ETH].priv;
+	return rep->rep_data[REP_ETH].priv;
 }
 
 struct mlx5e_neigh {

commit c94ff7487754dd23159a8dc47466c0cc82121ebd
Author: Parav Pandit <parav@mellanox.com>
Date:   Wed May 29 22:50:39 2019 +0000

    {IB, net}/mlx5: No need to typecast from void* to mlx5_ib_dev*
    
    Avoid typecasting from void* to mlx5_ib_dev* or mlx5e_rep_priv*
    as it is not needed.
    
    Signed-off-by: Parav Pandit <parav@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 83b573b1abac..c40c025afd99 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -91,7 +91,7 @@ struct mlx5e_rep_priv {
 static inline
 struct mlx5e_rep_priv *mlx5e_rep_to_rep_priv(struct mlx5_eswitch_rep *rep)
 {
-	return (struct mlx5e_rep_priv *)rep->rep_if[REP_ETH].priv;
+	return rep->rep_if[REP_ETH].priv;
 }
 
 struct mlx5e_neigh {

commit b4a23329e2e940cdec3b5eae781c1f7d4c669533
Author: Roi Dayan <roid@mellanox.com>
Date:   Wed Feb 6 15:43:51 2019 +0200

    net/mlx5e: Re-attempt to offload flows on multipath port affinity events
    
    Under multipath it's possible for us to offload the flow only through
    the e-switch for which proper route through the uplink exists.
    When the port is up and the next-hop route is set again we want to
    offload through it as well.
    
    We generate SW event from the FIB event handler when multipath port
    affinity changes. The tc offloads code gets this event, goes over the
    flows which were marked as of having missing route and attempts to
    offload them.
    
    Signed-off-by: Roi Dayan <roid@mellanox.com>
    Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 1aa3e110bb97..83b573b1abac 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -74,6 +74,9 @@ struct mlx5_rep_uplink_priv {
 	struct notifier_block	    netdevice_nb;
 
 	struct mlx5_tun_entropy tun_entropy;
+
+	struct list_head            unready_flows;
+	struct work_struct          reoffload_flows_work;
 };
 
 struct mlx5e_rep_priv {

commit 97417f6182f80a80c9b4443f282ef707be74dade
Author: Eli Britstein <elibr@mellanox.com>
Date:   Mon Jan 14 10:07:44 2019 +0200

    net/mlx5e: Fix GRE key by controlling port tunnel entropy calculation
    
    Flow entropy is calculated on the inner packet headers and used for
    flow distribution in processing, routing etc. For GRE-type
    encapsulations the entropy value is placed in the eight LSB of the key
    field in the GRE header as defined in NVGRE RFC 7637. For UDP based
    encapsulations the entropy value is placed in the source port of the
    UDP header.
    The hardware may support entropy calculation specifically for GRE and
    for all tunneling protocols. With commit df2ef3bff193 ("net/mlx5e: Add
    GRE protocol offloading") GRE is offloaded, but the hardware is
    configured by default to calculate flow entropy so packets transmitted
    on the wire have a wrong key. To support UDP based tunnels (i.e VXLAN),
    GRE (i.e. no flow entropy) and NVGRE (i.e. with flow entropy) the
    hardware behaviour must be controlled by the driver.
    
    Ensure port entropy calculation is enabled for offloaded VXLAN tunnels
    and disable port entropy calculation in the presence of offloaded GRE
    tunnels by monitoring the presence of entropy enabling tunnels (i.e
    VXLAN) and entropy disabing tunnels (i.e GRE).
    
    Fixes: df2ef3bff193 ("net/mlx5e: Add GRE protocol offloading")
    Signed-off-by: Eli Britstein <elibr@mellanox.com>
    Reviewed-by: Oz Shlomo <ozsh@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 36eafc877e6b..1aa3e110bb97 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -37,6 +37,7 @@
 #include <linux/rhashtable.h>
 #include "eswitch.h"
 #include "en.h"
+#include "lib/port_tun.h"
 
 #ifdef CONFIG_MLX5_ESWITCH
 struct mlx5e_neigh_update_table {
@@ -71,6 +72,8 @@ struct mlx5_rep_uplink_priv {
 	 */
 	struct list_head	    tc_indr_block_priv_list;
 	struct notifier_block	    netdevice_nb;
+
+	struct mlx5_tun_entropy tun_entropy;
 };
 
 struct mlx5e_rep_priv {

commit 6707f74be8621ae067d2cf1c4485900e2742c20f
Author: Tonghao Zhang <xiangxia.m.yue@gmail.com>
Date:   Mon Jan 28 15:28:05 2019 -0800

    net/mlx5e: Update hw flows when encap source mac changed
    
    When we offload tc filters to hardware, hardware flows can
    be updated when mac of encap destination ip is changed.
    But we ignore one case, that the mac of local encap ip can
    be changed too, so we should also update them.
    
    To fix it, add route_dev in mlx5e_encap_entry struct to save
    the local encap netdevice, and when mac changed, kernel will
    flush all the neighbour on the netdevice and send NETEVENT_NEIGH_UPDATE
    event. The mlx5 driver will delete the flows and add them when neighbour
    available again.
    
    Fixes: 232c001398ae ("net/mlx5e: Add support to neighbour update flow")
    Cc: Hadar Hen Zion <hadarh@mellanox.com>
    Signed-off-by: Tonghao Zhang <xiangxia.m.yue@gmail.com>
    Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
    Acked-by: Saeed Mahameed <saeedm@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index edd722824697..36eafc877e6b 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -148,6 +148,7 @@ struct mlx5e_encap_entry {
 	unsigned char h_dest[ETH_ALEN];	/* destination eth addr	*/
 
 	struct net_device *out_dev;
+	struct net_device *route_dev;
 	int tunnel_type;
 	int tunnel_hlen;
 	int reformat_type;

commit a0646c88ed3ac527b71cf365b03ff4fc729d35b6
Author: Eli Britstein <elibr@mellanox.com>
Date:   Wed Dec 19 09:24:58 2018 +0200

    net/mlx5e: Fail attempt to offload e-switch TC flows with egress upper devices
    
    We use the switchdev parent HW id helper to identify if the mirred device
    shares the same ASIC/port with the ingress device. This can get us wrong
    in the presence of upper devices such as vlan or bridge set over the HW
    devices (VF or uplink representors), b/c the switchdev ID is retrieved
    recursively.
    
    To fail offload attempts in such cases, we condition the check on the
    egress device to have not only the same switchdev ID but also the relevant
    mlx5 netdev ops.
    
    Fixes: 03a9d11e6eeb ('net/mlx5e: Add TC drop and mirred/redirect action parsing for SRIOV offloads')
    Signed-off-by: Eli Britstein <elibr@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Acked-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 5645d3cef1bb..edd722824697 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -176,6 +176,9 @@ void mlx5e_rep_encap_entry_detach(struct mlx5e_priv *priv,
 				  struct mlx5e_encap_entry *e);
 
 void mlx5e_rep_queue_neigh_stats_work(struct mlx5e_priv *priv);
+
+bool mlx5e_eswitch_rep(struct net_device *netdev);
+
 #else /* CONFIG_MLX5_ESWITCH */
 static inline bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv) { return false; }
 static inline int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv) { return 0; }

commit aec002f6f82cbfb39f92605614a88dd7a200a766
Author: Or Gerlitz <ogerlitz@mellanox.com>
Date:   Wed Nov 7 16:34:52 2018 +0200

    net/mlx5e: Uninstantiate esw manager vport netdev on switchdev mode
    
    Now, when we have a dedicated uplink representor, the netdev instance
    set over the esw manager vport (PF) is of no-use. As such, remove it
    once we're on switchdev mode and get it back to life when off switchdev.
    
    This is done by reloading the Ethernet interface as well (we already
    do that for the IB interface) from the eswitch code while going in/out
    of switchdev mode.
    
    The Eth add/remove entries are modified to act differently when called in
    switchdev mode. In this case we only deal with registration of the eth
    vport representors. The rep netdevices are created from the eswitch call
    to load the registered eth representors.
    
    Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index bb2d2484eb64..5645d3cef1bb 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -162,8 +162,8 @@ struct mlx5e_rep_sq {
 };
 
 void *mlx5e_alloc_nic_rep_priv(struct mlx5_core_dev *mdev);
-void mlx5e_rep_register_vport_reps(struct mlx5e_priv *priv);
-void mlx5e_rep_unregister_vport_reps(struct mlx5e_priv *priv);
+void mlx5e_rep_register_vport_reps(struct mlx5_core_dev *mdev);
+void mlx5e_rep_unregister_vport_reps(struct mlx5_core_dev *mdev);
 bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv);
 int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv);
 void mlx5e_remove_sqs_fwd_rules(struct mlx5e_priv *priv);
@@ -177,8 +177,6 @@ void mlx5e_rep_encap_entry_detach(struct mlx5e_priv *priv,
 
 void mlx5e_rep_queue_neigh_stats_work(struct mlx5e_priv *priv);
 #else /* CONFIG_MLX5_ESWITCH */
-static inline void mlx5e_rep_register_vport_reps(struct mlx5e_priv *priv) {}
-static inline void mlx5e_rep_unregister_vport_reps(struct mlx5e_priv *priv) {}
 static inline bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv) { return false; }
 static inline int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv) { return 0; }
 static inline void mlx5e_remove_sqs_fwd_rules(struct mlx5e_priv *priv) {}

commit 13e509a4c1949855ddd5ef2e23bafdfb27b8337a
Author: Or Gerlitz <ogerlitz@mellanox.com>
Date:   Tue Feb 13 18:14:42 2018 +0200

    net/mlx5e: Remove leftover code from the PF netdev being uplink rep
    
    Remove some last leftovers from using the PF netdev as
    the e-switch uplink representor.
    
    Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 07d5964356f1..bb2d2484eb64 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -168,9 +168,6 @@ bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv);
 int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv);
 void mlx5e_remove_sqs_fwd_rules(struct mlx5e_priv *priv);
 
-int mlx5e_get_offload_stats(int attr_id, const struct net_device *dev, void *sp);
-bool mlx5e_has_offload_stats(const struct net_device *dev, int attr_id);
-
 void mlx5e_handle_rx_cqe_rep(struct mlx5e_rq *rq, struct mlx5_cqe64 *cqe);
 
 int mlx5e_rep_encap_entry_attach(struct mlx5e_priv *priv,

commit d9ee0491c2ffbb5bc8bc418dd857a045d0d0130f
Author: Or Gerlitz <ogerlitz@mellanox.com>
Date:   Tue Feb 13 15:48:30 2018 +0200

    net/mlx5e: Use dedicated uplink vport netdev representor
    
    Currently, when running in sriov switchdev mode, we are using the PF
    netdevice as the uplink representor, this is problematic from few aspects:
    
    - will break when the PF isn't eswitch manager (e.g smart NIC env)
    - misalignment with other NIC switchdev drivers
    - makes us have and maintain special code, hurts the driver quality/robustness
    - which in turn opens the door for future bugs
    
    As of each and all of the above, we move to have a dedicated netdev representor
    for the uplink vport in a similar manner done for for the VF vports.
    
    This includes the following:
    
    1. have an uplink rep netdev as we have for VF reps
    2. all reps use same load/unload functions
    3. HW stats for uplink based on physical port counters and not vport counters
    4. link state for the uplink managed through PAOS and not vport state
    5. the uplink rep has sysfs link to the PF PCI function && uses the PF MAC address
    
    Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 2c8798332c32..07d5964356f1 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -162,8 +162,8 @@ struct mlx5e_rep_sq {
 };
 
 void *mlx5e_alloc_nic_rep_priv(struct mlx5_core_dev *mdev);
-void mlx5e_register_vport_reps(struct mlx5e_priv *priv);
-void mlx5e_unregister_vport_reps(struct mlx5e_priv *priv);
+void mlx5e_rep_register_vport_reps(struct mlx5e_priv *priv);
+void mlx5e_rep_unregister_vport_reps(struct mlx5e_priv *priv);
 bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv);
 int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv);
 void mlx5e_remove_sqs_fwd_rules(struct mlx5e_priv *priv);
@@ -171,7 +171,6 @@ void mlx5e_remove_sqs_fwd_rules(struct mlx5e_priv *priv);
 int mlx5e_get_offload_stats(int attr_id, const struct net_device *dev, void *sp);
 bool mlx5e_has_offload_stats(const struct net_device *dev, int attr_id);
 
-int mlx5e_attr_get(struct net_device *dev, struct switchdev_attr *attr);
 void mlx5e_handle_rx_cqe_rep(struct mlx5e_rq *rq, struct mlx5_cqe64 *cqe);
 
 int mlx5e_rep_encap_entry_attach(struct mlx5e_priv *priv,
@@ -181,11 +180,15 @@ void mlx5e_rep_encap_entry_detach(struct mlx5e_priv *priv,
 
 void mlx5e_rep_queue_neigh_stats_work(struct mlx5e_priv *priv);
 #else /* CONFIG_MLX5_ESWITCH */
-static inline void mlx5e_register_vport_reps(struct mlx5e_priv *priv) {}
-static inline void mlx5e_unregister_vport_reps(struct mlx5e_priv *priv) {}
+static inline void mlx5e_rep_register_vport_reps(struct mlx5e_priv *priv) {}
+static inline void mlx5e_rep_unregister_vport_reps(struct mlx5e_priv *priv) {}
 static inline bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv) { return false; }
 static inline int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv) { return 0; }
 static inline void mlx5e_remove_sqs_fwd_rules(struct mlx5e_priv *priv) {}
 #endif
 
+static inline bool mlx5e_is_vport_rep(struct mlx5e_priv *priv)
+{
+	return (MLX5_ESWITCH_MANAGER(priv->mdev) && priv->ppriv);
+}
 #endif /* __MLX5E_REP_H__ */

commit 54c177ca9c6efe5df516eefb886761b89a82eaf0
Author: Oz Shlomo <ozsh@mellanox.com>
Date:   Wed Nov 14 15:21:27 2018 +0200

    net/mlx5e: Branch according to classified tunnel type
    
    Currently the tunnel offloading encap/decap methods assumes that VXLAN
    is the sole tunneling protocol. Lay the infrastructure for supporting
    multiple tunneling protocols by branching according to the tunnel
    net device kind.
    
    Encap filters tunnel type is determined according to the egress/mirred
    net device. Decap filters classify the tunnel type according to the
    filter's ingress net device kind.
    
    Distinguish between the tunnel type as defined by the SW model and
    the FW reformat type that specifies the HW operation being made.
    
    Signed-off-by: Oz Shlomo <ozsh@mellanox.com>
    Reviewed-by: Eli Britstein <elibr@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index c078c6703dc7..2c8798332c32 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -149,6 +149,8 @@ struct mlx5e_encap_entry {
 
 	struct net_device *out_dev;
 	int tunnel_type;
+	int tunnel_hlen;
+	int reformat_type;
 	u8 flags;
 	char *encap_header;
 	int encap_size;

commit f5bc2c5de1015caf7e49b0bf9e7e97077736045a
Author: Oz Shlomo <ozsh@mellanox.com>
Date:   Sun Oct 28 08:34:51 2018 +0200

    net/mlx5e: Support TC indirect block notifications for eswitch uplink reprs
    
    Towards using this mechanism as the means to offload tunnel decap rules
    set on SW tunnel devices instead of egdev, add the supporting structures
    and functions.
    
    Signed-off-by: Oz Shlomo <ozsh@mellanox.com>
    Reviewed-by: Eli Britstein <elibr@mellanox.com>
    Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 8d39c5c59aeb..c078c6703dc7 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -58,6 +58,19 @@ struct mlx5_rep_uplink_priv {
 	 * the uplink's VFs
 	 */
 	struct rhashtable  tc_ht;
+
+	/* indirect block callbacks are invoked on bind/unbind events
+	 * on registered higher level devices (e.g. tunnel devices)
+	 *
+	 * tc_indr_block_cb_priv_list is used to lookup indirect callback
+	 * private data
+	 *
+	 * netdevice_nb is the netdev events notifier - used to register
+	 * tunnel devices for block events
+	 *
+	 */
+	struct list_head	    tc_indr_block_priv_list;
+	struct notifier_block	    netdevice_nb;
 };
 
 struct mlx5e_rep_priv {

commit ec1366c20721157cc2d077e84d2a062f93175ce5
Author: Oz Shlomo <ozsh@mellanox.com>
Date:   Thu Oct 25 21:51:11 2018 +0300

    net/mlx5e: Store eswitch uplink representor state on a dedicated struct
    
    Currently only a single field in the representor private structure
    is relevant for uplink representors.  As a pre-step to allow adding
    additional uplink representor fields, introduce uplink representor
    private structure.
    
    This is prepration step towards replacing egdev logic with the
    indirect block notification mechanism. This patch doesn't change
    any functionality.
    
    Signed-off-by: Oz Shlomo <ozsh@mellanox.com>
    Reviewed-by: Eli Britstein <elibr@mellanox.com>
    Acked-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 844d32d5c29f..8d39c5c59aeb 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -53,13 +53,20 @@ struct mlx5e_neigh_update_table {
 	unsigned long           min_interval; /* jiffies */
 };
 
+struct mlx5_rep_uplink_priv {
+	/* Filters DB - instantiated by the uplink representor and shared by
+	 * the uplink's VFs
+	 */
+	struct rhashtable  tc_ht;
+};
+
 struct mlx5e_rep_priv {
 	struct mlx5_eswitch_rep *rep;
 	struct mlx5e_neigh_update_table neigh_update;
 	struct net_device      *netdev;
 	struct mlx5_flow_handle *vport_rx_rule;
 	struct list_head       vport_sqs_list;
-	struct rhashtable      tc_ht; /* valid for uplink rep */
+	struct mlx5_rep_uplink_priv uplink_priv; /* valid for uplink rep */
 };
 
 static inline

commit 655dc3d2b91bf241f5baca5eb2bc2b1e22a561ff
Author: Or Gerlitz <ogerlitz@mellanox.com>
Date:   Tue Apr 10 18:34:36 2018 +0300

    net/mlx5e: Use shared table for offloaded TC eswitch flows
    
    Currently, each representor netdev use their own hash table to keep
    the mapping from TC flow (f->cookie) to the driver offloaded instance.
    The table is the one which originally was added for offloading TC NIC
    (not eswitch) rules.
    
    This scheme breaks when the core TC code calls us to add the same flow
    twice, (e.g under egdev use case) since we don't spot that and offload
    a 2nd flow into the HW with the wrong source vport.
    
    As a pre-step to solve that, we move to use a single table which keeps
    all offloaded TC eswitch flows. The table is located at the eswitch
    uplink representor object.
    
    Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Reviewed-by: Paul Blakey <paulb@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index b9b481f2833a..844d32d5c29f 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -59,6 +59,7 @@ struct mlx5e_rep_priv {
 	struct net_device      *netdev;
 	struct mlx5_flow_handle *vport_rx_rule;
 	struct list_head       vport_sqs_list;
+	struct rhashtable      tc_ht; /* valid for uplink rep */
 };
 
 static inline

commit 2c47bf80e8b70a284b6926f3379109eed7d03ac7
Author: Mark Bloch <markb@mellanox.com>
Date:   Thu Dec 7 21:39:52 2017 +0000

    net/mlx5e: E-Switch, Move send-to-vport rule struct to en_rep
    
    Move struct mlx5_esw_sq which keeps send-to-vport rule to from the eswitch
    code to mlx5e and rename it to better reflect where it belongs
    
    Signed-off-by: Mark Bloch <markb@mellanox.com>
    Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index e4473a9ebd50..b9b481f2833a 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -133,6 +133,11 @@ struct mlx5e_encap_entry {
 	int encap_size;
 };
 
+struct mlx5e_rep_sq {
+	struct mlx5_flow_handle	*send_to_vport_rule;
+	struct list_head	 list;
+};
+
 void *mlx5e_alloc_nic_rep_priv(struct mlx5_core_dev *mdev);
 void mlx5e_register_vport_reps(struct mlx5e_priv *priv);
 void mlx5e_unregister_vport_reps(struct mlx5e_priv *priv);

commit a4b97ab4211fd0cf1011623c79fe2204dc023b96
Author: Mark Bloch <markb@mellanox.com>
Date:   Thu Dec 7 21:25:57 2017 +0000

    net/mlx5: E-Switch, Create generic header struct to be used by representors
    
    Now that we don't store type dependent data in struct mlx5_eswitch_rep
    we can create a generic interface, and representor type.
    
    struct mlx5_eswitch_rep will store an array of interfaces, each
    interface is used by a different representor type.
    
    Once we moved to a more generic interface, rdma driver representors can
    be added and utilize the same mechanism as the Ethernet driver
    representors use.
    
    Signed-off-by: Mark Bloch <markb@mellanox.com>
    Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 8db68369367e..e4473a9ebd50 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -64,7 +64,7 @@ struct mlx5e_rep_priv {
 static inline
 struct mlx5e_rep_priv *mlx5e_rep_to_rep_priv(struct mlx5_eswitch_rep *rep)
 {
-	return (struct mlx5e_rep_priv *)rep->priv;
+	return (struct mlx5e_rep_priv *)rep->rep_if[REP_ETH].priv;
 }
 
 struct mlx5e_neigh {

commit 5ed99fb421d4d5cd4cba613c1ab115585aa277d2
Author: Mark Bloch <markb@mellanox.com>
Date:   Thu Dec 7 20:55:10 2017 +0000

    net/mlx5e: Move ethernet representors data into separate struct
    
    Ethernet representors have a need to store data which is applicable
    only for them. Create a priv void pointer in struct mlx5_eswitch_rep
    and move mlx5e to store the relevant data there. As part of this change
    we also initialize rep_if in mlx5e_rep_register_vf_vports() as otherwise the
    E-Switch code will copy a priv value which is garbage.
    
    We also rename mlx5_eswitch_get_uplink_netdev() to
    mlx5_eswitch_get_uplink_priv() and make it return void *.
    This way E-Switch code doesn't need to deal with net devices and
    we leave the task of getting it to mlx5e.
    
    Signed-off-by: Mark Bloch <markb@mellanox.com>
    Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 5659ed9f51e6..8db68369367e 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -56,8 +56,17 @@ struct mlx5e_neigh_update_table {
 struct mlx5e_rep_priv {
 	struct mlx5_eswitch_rep *rep;
 	struct mlx5e_neigh_update_table neigh_update;
+	struct net_device      *netdev;
+	struct mlx5_flow_handle *vport_rx_rule;
+	struct list_head       vport_sqs_list;
 };
 
+static inline
+struct mlx5e_rep_priv *mlx5e_rep_to_rep_priv(struct mlx5_eswitch_rep *rep)
+{
+	return (struct mlx5e_rep_priv *)rep->priv;
+}
+
 struct mlx5e_neigh {
 	struct net_device *dev;
 	union {

commit e80541ecabd57b69726232b89242e28d8123cccc
Author: Saeed Mahameed <saeedm@mellanox.com>
Date:   Mon Jun 5 15:17:12 2017 +0300

    net/mlx5: Add CONFIG_MLX5_ESWITCH Kconfig
    
    Allow to selectively build the driver with or without sriov eswitch, VF
    representors and TC offloads.
    
    Also remove the need of two ndo ops structures (sriov & basic)
    and keep only one unified ndo ops, compile out VF SRIOV ndos when not
    needed (MLX5_ESWITCH=n), and for VF netdev calling those ndos will result
    in returning -EPERM.
    
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
    Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
    Cc: Jes Sorensen <jsorensen@fb.com>
    Cc: kernel-team@fb.com

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 23e43bbf928d..5659ed9f51e6 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -38,6 +38,7 @@
 #include "eswitch.h"
 #include "en.h"
 
+#ifdef CONFIG_MLX5_ESWITCH
 struct mlx5e_neigh_update_table {
 	struct rhashtable       neigh_ht;
 	/* Save the neigh hash entries in a list in addition to the hash table
@@ -142,5 +143,12 @@ void mlx5e_rep_encap_entry_detach(struct mlx5e_priv *priv,
 				  struct mlx5e_encap_entry *e);
 
 void mlx5e_rep_queue_neigh_stats_work(struct mlx5e_priv *priv);
+#else /* CONFIG_MLX5_ESWITCH */
+static inline void mlx5e_register_vport_reps(struct mlx5e_priv *priv) {}
+static inline void mlx5e_unregister_vport_reps(struct mlx5e_priv *priv) {}
+static inline bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv) { return false; }
+static inline int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv) { return 0; }
+static inline void mlx5e_remove_sqs_fwd_rules(struct mlx5e_priv *priv) {}
+#endif
 
 #endif /* __MLX5E_REP_H__ */

commit 07c9f1e57839c678c867b89aa9dcb2220e579b13
Author: Saeed Mahameed <saeedm@mellanox.com>
Date:   Tue Jun 6 09:12:04 2017 +0300

    net/mlx5e: NIC netdev init flow cleanup
    
    Remove redundant call to unregister vport representor in mlx5e_add error
    flow.
    
    Hide the representor priv and eswitch internal structures from en_main.c
    as preparation step for downstream patches which would allow building
    the driver without support for  representors and eswitch.
    
    Fixes: 6f08a22c5fb2 ("net/mlx5e: Register/unregister vport representors on interface attach/detach")
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
    Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index a0a1a7a1d6c0..23e43bbf928d 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -123,6 +123,7 @@ struct mlx5e_encap_entry {
 	int encap_size;
 };
 
+void *mlx5e_alloc_nic_rep_priv(struct mlx5_core_dev *mdev);
 void mlx5e_register_vport_reps(struct mlx5e_priv *priv);
 void mlx5e_unregister_vport_reps(struct mlx5e_priv *priv);
 bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv);

commit f6dfb4c3f2161c23ab2939dd1b5f133dcdf147c6
Author: Hadar Hen Zion <hadarh@mellanox.com>
Date:   Fri Feb 24 12:16:33 2017 +0200

    net/mlx5e: Update neighbour 'used' state using HW flow rules counters
    
    When IP tunnel encapsulation rules are offloaded, the kernel can't see
    the traffic of the offloaded flow. The neighbour for the IP tunnel
    destination of the offloaded flow can mistakenly become STALE and
    deleted by the kernel since its 'used' value wasn't changed.
    
    To make sure that a neighbour which is used by the HW won't become
    STALE, we proactively update the neighbour 'used' value every
    DELAY_PROBE_TIME period, when packets were matched and counted by the HW
    for one of the tunnel encap flows related to this neighbour.
    
    The periodic task that updates the used neighbours is scheduled when a
    tunnel encap rule is successfully offloaded into HW and keeps re-scheduling
    itself as long as the representor's neighbours list isn't empty.
    
    Add, remove, lookup and status change operations done over the
    representor's neighbours list or the neighbour hash entry encaps list
    are all serialized by RTNL lock.
    
    Signed-off-by: Hadar Hen Zion <hadarh@mellanox.com>
    Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index e4d0ea5246fd..a0a1a7a1d6c0 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -48,6 +48,8 @@ struct mlx5e_neigh_update_table {
 	/* protect lookup/remove operations */
 	spinlock_t              encap_lock;
 	struct notifier_block   netevent_nb;
+	struct delayed_work     neigh_stats_work;
+	unsigned long           min_interval; /* jiffies */
 };
 
 struct mlx5e_rep_priv {
@@ -61,6 +63,7 @@ struct mlx5e_neigh {
 		__be32	v4;
 		struct in6_addr v6;
 	} dst_ip;
+	int family;
 };
 
 struct mlx5e_neigh_hash_entry {
@@ -87,6 +90,12 @@ struct mlx5e_neigh_hash_entry {
 	 * it's used by the neigh notification call.
 	 */
 	refcount_t refcnt;
+
+	/* Save the last reported time offloaded trafic pass over one of the
+	 * neigh hash entry flows. Use it to periodically update the neigh
+	 * 'used' value and avoid neigh deleting by the kernel.
+	 */
+	unsigned long reported_lastuse;
 };
 
 enum {
@@ -131,4 +140,6 @@ int mlx5e_rep_encap_entry_attach(struct mlx5e_priv *priv,
 void mlx5e_rep_encap_entry_detach(struct mlx5e_priv *priv,
 				  struct mlx5e_encap_entry *e);
 
+void mlx5e_rep_queue_neigh_stats_work(struct mlx5e_priv *priv);
+
 #endif /* __MLX5E_REP_H__ */

commit 232c001398ae8406dc0daf07b14e6ec9a5562719
Author: Hadar Hen Zion <hadarh@mellanox.com>
Date:   Mon Mar 20 12:56:47 2017 +0200

    net/mlx5e: Add support to neighbour update flow
    
    In order to offload TC encap rules, the driver does a lookup for the IP
    tunnel neighbour according to the output device and the destination IP
    given by the user.
    
    To keep tracking after the validity state of such neighbours, we keep
    the neighbours information (pair of device pointer and destination IP)
    in a hash table maintained at the relevant egress representor and
    register to get NETEVENT_NEIGH_UPDATE events. When getting neighbour update
    netevent, we search for a match among the cached neighbours entries used for
    encapsulation.
    
    In case the neighbour isn't valid, we can't offload the flow into the
    HW. We cache the flow (requested matching and actions) in the driver and
    offload the rule later, when the neighbour is resolved and becomes
    valid.
    
    When a flow is only cached in the driver and not offloaded into HW
    yet, we use EAGAIN return value to mark it internally, the TC ndo still
    returns success.
    
    Listen to kernel neighbour update netevents to trace relevant neighbours
    validity state:
    
    1. If a neighbour becomes valid, offload the related rules to HW.
    
    2. If the neighbour becomes invalid, remove the related rules from HW.
    
    3. If the neighbour mac address was changed, update the encap header.
       Remove all the offloaded rules using the old encap header from the HW
       and insert new rules to HW with updated encap header.
    
    Access to the neighbors hash table is protected by RTNL lock of its
    caller or by the table's spinlock.
    
    Details of the locking/synchronization among the different actions
    applied on the neighbour table:
    
    Add/remove operations - protected by RTNL lock of its caller (all TC
    commands are protected by RTNL lock). Add and remove operations are
    initiated only when the user inserts/removes a TC rule into/from the driver.
    
    Lookup/remove operations - since the lookup operation is done from
    netevent notifier block, RTNL lock can't be used (atomic context).
    Use the table's spin lock to protect lookups from TC user removal operation.
    bh is used since netevent can be called from a softirq context.
    
    Lookup/add operations - The hash table access functions are taking
    care of the protection between lookup and add operations.
    
    When adding/removing encap headers and rules to/from the HW, RTNL lock
    is used. It can happen when:
    
    1. The user inserts/removes a TC rule into/from the driver (TC commands
    are protected by RTNL lock of it's caller).
    
    2. The driver gets neighbour notification event, which reports about
    neighbour validity status change. Before adding/removing encap headers
    and rules to/from the HW, RTNL lock is taken.
    
    A neighbour hash table entry should be freed when its encap list is empty.
    Since The neighbour update netevent notification schedules a neighbour
    update work that uses the neighbour hash entry, it can't be freed
    unconditionally when the encap list becomes empty during TC delete rule flow.
    Use reference count to protect from freeing neighbour hash table entry
    while it's still in use.
    
    When the user asks to unregister a netdvice used by one of the neigbours,
    neighbour removal notification is received. Then we take a reference on the
    neighbour and don't free it until the relevant encap entries (and flows) are
    marked as invalid (not offloaded) and removed from HW.
    As long as the encap entry is still valid (checked under RTNL lock) we
    can safely access the neighbour device saved on mlx5e_neigh struct.
    
    Signed-off-by: Hadar Hen Zion <hadarh@mellanox.com>
    Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 99f6b5f41070..e4d0ea5246fd 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -45,6 +45,9 @@ struct mlx5e_neigh_update_table {
 	 * Used for stats query.
 	 */
 	struct list_head	neigh_list;
+	/* protect lookup/remove operations */
+	spinlock_t              encap_lock;
+	struct notifier_block   netevent_nb;
 };
 
 struct mlx5e_rep_priv {
@@ -69,18 +72,46 @@ struct mlx5e_neigh_hash_entry {
 	 * neighbour entries. Used for stats query.
 	 */
 	struct list_head neigh_list;
+
+	/* encap list sharing the same neigh */
+	struct list_head encap_list;
+
+	/* valid only when the neigh reference is taken during
+	 * neigh_update_work workqueue callback.
+	 */
+	struct neighbour *n;
+	struct work_struct neigh_update_work;
+
+	/* neigh hash entry can be deleted only when the refcount is zero.
+	 * refcount is needed to avoid neigh hash entry removal by TC, while
+	 * it's used by the neigh notification call.
+	 */
+	refcount_t refcnt;
+};
+
+enum {
+	/* set when the encap entry is successfully offloaded into HW */
+	MLX5_ENCAP_ENTRY_VALID     = BIT(0),
 };
 
 struct mlx5e_encap_entry {
+	/* neigh hash entry list of encaps sharing the same neigh */
+	struct list_head encap_list;
+	struct mlx5e_neigh m_neigh;
+	/* a node of the eswitch encap hash table which keeping all the encap
+	 * entries
+	 */
 	struct hlist_node encap_hlist;
 	struct list_head flows;
 	u32 encap_id;
-	struct neighbour *n;
 	struct ip_tunnel_info tun_info;
 	unsigned char h_dest[ETH_ALEN];	/* destination eth addr	*/
 
 	struct net_device *out_dev;
 	int tunnel_type;
+	u8 flags;
+	char *encap_header;
+	int encap_size;
 };
 
 void mlx5e_register_vport_reps(struct mlx5e_priv *priv);
@@ -95,4 +126,9 @@ bool mlx5e_has_offload_stats(const struct net_device *dev, int attr_id);
 int mlx5e_attr_get(struct net_device *dev, struct switchdev_attr *attr);
 void mlx5e_handle_rx_cqe_rep(struct mlx5e_rq *rq, struct mlx5_cqe64 *cqe);
 
+int mlx5e_rep_encap_entry_attach(struct mlx5e_priv *priv,
+				 struct mlx5e_encap_entry *e);
+void mlx5e_rep_encap_entry_detach(struct mlx5e_priv *priv,
+				  struct mlx5e_encap_entry *e);
+
 #endif /* __MLX5E_REP_H__ */

commit 37b498ff238549b30c9e70d4e45f522fd53b8994
Author: Hadar Hen Zion <hadarh@mellanox.com>
Date:   Thu Feb 2 16:43:35 2017 +0200

    net/mlx5e: Add neighbour hash table to the representors
    
    Add hash table to the representors which is to be used by the next patch
    to save neighbours information in the driver.
    
    In order to offload IP tunnel encapsulation rules, the driver must find
    the tunnel dst neighbour according to the output device and the
    destination address given by the user. The next patch will cache the
    neighbors information in the driver to allow support in neigh update
    flow for tunnel encap rules.
    
    The neighbour entries are also saved in a list so we easily iterate over
    them when querying statistics in order to provide 'used' feedback to the
    kernel neighbour NUD core.
    
    Signed-off-by: Hadar Hen Zion <hadarh@mellanox.com>
    Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 425cb1b0bf02..99f6b5f41070 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -34,11 +34,41 @@
 #define __MLX5E_REP_H__
 
 #include <net/ip_tunnels.h>
+#include <linux/rhashtable.h>
 #include "eswitch.h"
 #include "en.h"
 
+struct mlx5e_neigh_update_table {
+	struct rhashtable       neigh_ht;
+	/* Save the neigh hash entries in a list in addition to the hash table
+	 * (neigh_ht). In order to iterate easily over the neigh entries.
+	 * Used for stats query.
+	 */
+	struct list_head	neigh_list;
+};
+
 struct mlx5e_rep_priv {
 	struct mlx5_eswitch_rep *rep;
+	struct mlx5e_neigh_update_table neigh_update;
+};
+
+struct mlx5e_neigh {
+	struct net_device *dev;
+	union {
+		__be32	v4;
+		struct in6_addr v6;
+	} dst_ip;
+};
+
+struct mlx5e_neigh_hash_entry {
+	struct rhash_head rhash_node;
+	struct mlx5e_neigh m_neigh;
+
+	/* Save the neigh hash entry in a list on the representor in
+	 * addition to the hash table. In order to iterate easily over the
+	 * neighbour entries. Used for stats query.
+	 */
+	struct list_head neigh_list;
 };
 
 struct mlx5e_encap_entry {

commit c1ae11521b1e87523553ddd3c1aa88be3d710c96
Author: Or Gerlitz <ogerlitz@mellanox.com>
Date:   Tue Apr 25 16:19:26 2017 +0300

    net/mlx5e: Move the encap entry structure from the eswitch header
    
    The encap entry structure isn't manipulated by the eswitch code,
    hence it can/needs to be removed from the eswitch header.
    
    Do that, and change it to have mlx5e_ prefix.
    
    This patch doesn't change any functionality.
    
    Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index b6595a699dc1..425cb1b0bf02 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -33,6 +33,7 @@
 #ifndef __MLX5E_REP_H__
 #define __MLX5E_REP_H__
 
+#include <net/ip_tunnels.h>
 #include "eswitch.h"
 #include "en.h"
 
@@ -40,6 +41,18 @@ struct mlx5e_rep_priv {
 	struct mlx5_eswitch_rep *rep;
 };
 
+struct mlx5e_encap_entry {
+	struct hlist_node encap_hlist;
+	struct list_head flows;
+	u32 encap_id;
+	struct neighbour *n;
+	struct ip_tunnel_info tun_info;
+	unsigned char h_dest[ETH_ALEN];	/* destination eth addr	*/
+
+	struct net_device *out_dev;
+	int tunnel_type;
+};
+
 void mlx5e_register_vport_reps(struct mlx5e_priv *priv);
 void mlx5e_unregister_vport_reps(struct mlx5e_priv *priv);
 bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv);

commit 1d447a39142e0eaf8526fcb37699e6b8cce5eaa8
Author: Saeed Mahameed <saeedm@mellanox.com>
Date:   Mon Apr 24 12:36:42 2017 +0300

    net/mlx5e: Extendable vport representor netdev private data
    
    Make representor netdev private data extendable by adding new struct
    "mlx5e_rep_priv" and use it as the rep netdev private data struct
    instead of directly pointing to mlx5_eswitch_rep.
    
    Added new en_rep.h header file to contain all representor related
    definitions and prototypes, and moved all representor specific logic
    into en_rep.c.
    
    Needed for downstream patches to extend representor functionality to
    support neighbour update.
    
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
    Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
new file mode 100644
index 000000000000..b6595a699dc1
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2017, Mellanox Technologies. All rights reserved.
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifndef __MLX5E_REP_H__
+#define __MLX5E_REP_H__
+
+#include "eswitch.h"
+#include "en.h"
+
+struct mlx5e_rep_priv {
+	struct mlx5_eswitch_rep *rep;
+};
+
+void mlx5e_register_vport_reps(struct mlx5e_priv *priv);
+void mlx5e_unregister_vport_reps(struct mlx5e_priv *priv);
+bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv);
+int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv);
+void mlx5e_remove_sqs_fwd_rules(struct mlx5e_priv *priv);
+
+int mlx5e_get_offload_stats(int attr_id, const struct net_device *dev, void *sp);
+bool mlx5e_has_offload_stats(const struct net_device *dev, int attr_id);
+
+int mlx5e_attr_get(struct net_device *dev, struct switchdev_attr *attr);
+void mlx5e_handle_rx_cqe_rep(struct mlx5e_rq *rq, struct mlx5_cqe64 *cqe);
+
+#endif /* __MLX5E_REP_H__ */
