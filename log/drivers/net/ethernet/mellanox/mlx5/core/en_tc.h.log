commit fca533041aac0426f5b5618a564aeb588fc125e9
Author: Eli Britstein <elibr@mellanox.com>
Date:   Tue May 19 05:55:59 2020 +0000

    net/mlx5e: Optimize performance for IPv4/IPv6 ethertype
    
    The HW is optimized for IPv4/IPv6. For such cases, pending capability,
    avoid matching on ethertype, and use ip_version field instead.
    
    Signed-off-by: Eli Britstein <elibr@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 144b71f571ea..5c330b0cae21 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -170,8 +170,9 @@ void dealloc_mod_hdr_actions(struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts);
 struct mlx5e_tc_flow;
 u32 mlx5e_tc_get_flow_tun_id(struct mlx5e_tc_flow *flow);
 
-void mlx5e_tc_set_ethertype(void *headers_c, void *headers_v,
-			    struct flow_match_basic *match);
+void mlx5e_tc_set_ethertype(struct mlx5_core_dev *mdev,
+			    struct flow_match_basic *match, bool outer,
+			    void *headers_c, void *headers_v);
 
 #if IS_ENABLED(CONFIG_MLX5_CLS_ACT)
 

commit 4a5d5d7392106a48c7db345a3843e854b66ea0ff
Author: Eli Britstein <elibr@mellanox.com>
Date:   Mon May 11 19:20:29 2020 +0000

    net/mlx5e: Helper function to set ethertype
    
    Set ethertype match in a helper function as a pre-step towards
    optimizing it.
    
    Signed-off-by: Eli Britstein <elibr@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 037aa73bf9ab..144b71f571ea 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -170,6 +170,9 @@ void dealloc_mod_hdr_actions(struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts);
 struct mlx5e_tc_flow;
 u32 mlx5e_tc_get_flow_tun_id(struct mlx5e_tc_flow *flow);
 
+void mlx5e_tc_set_ethertype(void *headers_c, void *headers_v,
+			    struct flow_match_basic *match);
+
 #if IS_ENABLED(CONFIG_MLX5_CLS_ACT)
 
 int mlx5e_tc_nic_init(struct mlx5e_priv *priv);

commit d956873f908cff46dd55976dbd9442a027e9d9d1
Author: Vlad Buslov <vladbu@mellanox.com>
Date:   Tue May 12 18:24:11 2020 +0300

    net/mlx5e: Introduce kconfig var for TC support
    
    In order to improve code maintainability and readability, introduce new
    CONFIG_MLX5_CLS_ACT kconfig variable to control compilation of TC hardware
    offloads implementation. This allows distinguishing between features that
    require TC support (MPLSoUDP, etc.) and features that just rely on
    representor functionality (rep_bond for live migration, etc.).
    
    Modify rep_tc.h, rep_neigh.h, en_tc.h and chains.h files to provide stubs
    for functions that are called from generic code.
    
    Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 9c59b7fe258a..037aa73bf9ab 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -80,9 +80,6 @@ enum {
 
 #define MLX5_TC_FLAG(flag) BIT(MLX5E_TC_FLAG_##flag##_BIT)
 
-int mlx5e_tc_nic_init(struct mlx5e_priv *priv);
-void mlx5e_tc_nic_cleanup(struct mlx5e_priv *priv);
-
 int mlx5e_tc_esw_init(struct rhashtable *tc_ht);
 void mlx5e_tc_esw_cleanup(struct rhashtable *tc_ht);
 
@@ -173,9 +170,22 @@ void dealloc_mod_hdr_actions(struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts);
 struct mlx5e_tc_flow;
 u32 mlx5e_tc_get_flow_tun_id(struct mlx5e_tc_flow *flow);
 
+#if IS_ENABLED(CONFIG_MLX5_CLS_ACT)
+
+int mlx5e_tc_nic_init(struct mlx5e_priv *priv);
+void mlx5e_tc_nic_cleanup(struct mlx5e_priv *priv);
+
 int mlx5e_setup_tc_block_cb(enum tc_setup_type type, void *type_data,
 			    void *cb_priv);
 
+#else /* CONFIG_MLX5_CLS_ACT */
+static inline int  mlx5e_tc_nic_init(struct mlx5e_priv *priv) { return 0; }
+static inline void mlx5e_tc_nic_cleanup(struct mlx5e_priv *priv) {}
+static inline int
+mlx5e_setup_tc_block_cb(enum tc_setup_type type, void *type_data, void *cb_priv)
+{ return -EOPNOTSUPP; }
+#endif /* CONFIG_MLX5_CLS_ACT */
+
 #else /* CONFIG_MLX5_ESWITCH */
 static inline int  mlx5e_tc_nic_init(struct mlx5e_priv *priv) { return 0; }
 static inline void mlx5e_tc_nic_cleanup(struct mlx5e_priv *priv) {}

commit e2394a61d243d74ec7d0bfd4c6e25171fba54caa
Author: Vlad Buslov <vladbu@mellanox.com>
Date:   Tue May 12 18:08:41 2020 +0300

    net/mlx5e: Move TC-specific code from en_main.c to en_tc.c
    
    As a preparation for introducing new kconfig option that controls
    compilation of all TC offloads code in mlx5, extract TC-specific code from
    en_main.c to en_tc.c. This allows easily compiling out the code by
    only including new source in make file when corresponding kconfig is
    enabled instead of adding multiple ifdef blocks to en_main.
    
    Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 1d8d85b842fe..9c59b7fe258a 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -173,6 +173,9 @@ void dealloc_mod_hdr_actions(struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts);
 struct mlx5e_tc_flow;
 u32 mlx5e_tc_get_flow_tun_id(struct mlx5e_tc_flow *flow);
 
+int mlx5e_setup_tc_block_cb(enum tc_setup_type type, void *type_data,
+			    void *cb_priv);
+
 #else /* CONFIG_MLX5_ESWITCH */
 static inline int  mlx5e_tc_nic_init(struct mlx5e_priv *priv) { return 0; }
 static inline void mlx5e_tc_nic_cleanup(struct mlx5e_priv *priv) {}
@@ -181,6 +184,10 @@ static inline int  mlx5e_tc_num_filters(struct mlx5e_priv *priv,
 {
 	return 0;
 }
+
+static inline int
+mlx5e_setup_tc_block_cb(enum tc_setup_type type, void *type_data, void *cb_priv)
+{ return -EOPNOTSUPP; }
 #endif
 
 #endif /* __MLX5_EN_TC_H__ */

commit 768c3667e6f36bc9db0dac854aa198651b27412f
Author: Vlad Buslov <vladbu@mellanox.com>
Date:   Tue May 12 16:41:41 2020 +0300

    net/mlx5e: Extract TC-specific code from en_rep.c to rep/tc.c
    
    As a preparation for introducing new kconfig option that controls
    compilation of all TC offloads code in mlx5, extract TC-specific code from
    en_rep.c to standalone file. This allows easily compiling out the code by
    only including new source in make file when corresponding kconfig is
    enabled instead of adding multiple ifdef blocks to en_rep.
    
    Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index abdcfa4c4e0e..1d8d85b842fe 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -34,11 +34,41 @@
 #define __MLX5_EN_TC_H__
 
 #include <net/pkt_cls.h>
+#include "en.h"
 
 #define MLX5E_TC_FLOW_ID_MASK 0x0000ffff
 
 #ifdef CONFIG_MLX5_ESWITCH
 
+struct tunnel_match_key {
+	struct flow_dissector_key_control enc_control;
+	struct flow_dissector_key_keyid enc_key_id;
+	struct flow_dissector_key_ports enc_tp;
+	struct flow_dissector_key_ip enc_ip;
+	union {
+		struct flow_dissector_key_ipv4_addrs enc_ipv4;
+		struct flow_dissector_key_ipv6_addrs enc_ipv6;
+	};
+
+	int filter_ifindex;
+};
+
+struct tunnel_match_enc_opts {
+	struct flow_dissector_key_enc_opts key;
+	struct flow_dissector_key_enc_opts mask;
+};
+
+/* Tunnel_id mapping is TUNNEL_INFO_BITS + ENC_OPTS_BITS.
+ * Upper TUNNEL_INFO_BITS for general tunnel info.
+ * Lower ENC_OPTS_BITS bits for enc_opts.
+ */
+#define TUNNEL_INFO_BITS 6
+#define TUNNEL_INFO_BITS_MASK GENMASK(TUNNEL_INFO_BITS - 1, 0)
+#define ENC_OPTS_BITS 2
+#define ENC_OPTS_BITS_MASK GENMASK(ENC_OPTS_BITS - 1, 0)
+#define TUNNEL_ID_BITS (TUNNEL_INFO_BITS + ENC_OPTS_BITS)
+#define TUNNEL_ID_MASK GENMASK(TUNNEL_ID_BITS - 1, 0)
+
 enum {
 	MLX5E_TC_FLAG_INGRESS_BIT,
 	MLX5E_TC_FLAG_EGRESS_BIT,
@@ -119,11 +149,6 @@ struct mlx5e_tc_update_priv {
 	struct net_device *tun_dev;
 };
 
-bool mlx5e_tc_rep_update_skb(struct mlx5_cqe64 *cqe, struct sk_buff *skb,
-			     struct mlx5e_tc_update_priv *tc_priv);
-
-void mlx5_tc_rep_post_napi_receive(struct mlx5e_tc_update_priv *tc_priv);
-
 struct mlx5e_tc_mod_hdr_acts {
 	int num_actions;
 	int max_actions;

commit 5c6b9460474464c37c2d56df9e4c7044a042888b
Author: Paul Blakey <paulb@mellanox.com>
Date:   Thu Mar 12 12:23:16 2020 +0200

    net/mlx5e: CT: Handle misses after executing CT action
    
    Mark packets with a unique tupleid, and on miss use that id to get
    the act ct restore_cookie. Using that restore cookie, we ask CT to
    restore the relevant info on the SKB.
    
    Signed-off-by: Paul Blakey <paulb@mellanox.com>
    Reviewed-by: Oz Shlomo <ozsh@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 31c9e81b9287..abdcfa4c4e0e 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -99,6 +99,7 @@ enum mlx5e_tc_attr_to_reg {
 	MARK_TO_REG,
 	LABELS_TO_REG,
 	FTEID_TO_REG,
+	TUPLEID_TO_REG,
 };
 
 struct mlx5e_tc_attr_to_reg_mapping {

commit 4c3844d9e97e10f0cf024fe7f24dcefa133fe9e2
Author: Paul Blakey <paulb@mellanox.com>
Date:   Thu Mar 12 12:23:14 2020 +0200

    net/mlx5e: CT: Introduce connection tracking
    
    Add support for offloading tc ct action and ct matches.
    We translate the tc filter with CT action the following HW model:
    
    +-------------------+      +--------------------+    +--------------+
    + pre_ct (tc chain) +----->+ CT (nat or no nat) +--->+ post_ct      +----->
    + original match    +  |   + tuple + zone match + |  + fte_id match +  |
    +-------------------+  |   +--------------------+ |  +--------------+  |
                           v                          v                    v
                          set chain miss mapping  set mark             original
                          set fte_id              set label            filter
                          set zone                set established      actions
                          set tunnel_id           do nat (if needed)
                          do decap
    
    Signed-off-by: Paul Blakey <paulb@mellanox.com>
    Reviewed-by: Oz Shlomo <ozsh@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 21cbde472b64..31c9e81b9287 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -94,6 +94,11 @@ void mlx5e_tc_reoffload_flows_work(struct work_struct *work);
 enum mlx5e_tc_attr_to_reg {
 	CHAIN_TO_REG,
 	TUNNEL_TO_REG,
+	CTSTATE_TO_REG,
+	ZONE_TO_REG,
+	MARK_TO_REG,
+	LABELS_TO_REG,
+	FTEID_TO_REG,
 };
 
 struct mlx5e_tc_attr_to_reg_mapping {
@@ -139,6 +144,9 @@ int alloc_mod_hdr_actions(struct mlx5_core_dev *mdev,
 			  struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts);
 void dealloc_mod_hdr_actions(struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts);
 
+struct mlx5e_tc_flow;
+u32 mlx5e_tc_get_flow_tun_id(struct mlx5e_tc_flow *flow);
+
 #else /* CONFIG_MLX5_ESWITCH */
 static inline int  mlx5e_tc_nic_init(struct mlx5e_priv *priv) { return 0; }
 static inline void mlx5e_tc_nic_cleanup(struct mlx5e_priv *priv) {}

commit b8ce90370977dbe24d2ed7271b65710ec9c40166
Author: Paul Blakey <paulb@mellanox.com>
Date:   Sun Feb 16 12:01:36 2020 +0200

    net/mlx5e: Restore tunnel metadata on miss
    
    In tunnel and chains setup, we decapsulate the packets on first chain hop,
    if we miss on later chains, the packet will comes up without tunnel header,
    so it won't be taken by the tunnel device automatically, which fills the
    tunnel metadata, and further tc tunnel matches won't work.
    
    On miss, we get the tunnel mapping id, which was set on the chain 0 rule
    that decapsulated the packet. This rule matched the tunnel outer
    headers. From the tunnel mapping id, we get to this tunnel matches
    and restore the equivalent tunnel info metadata dst on the skb.
    We also set the skb->dev to the relevant device (tunnel device).
    Now further tc processing can be done on the relevant device.
    
    Signed-off-by: Paul Blakey <paulb@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Reviewed-by: Oz Shlomo <ozsh@mellanox.com>
    Reviewed-by: Mark Bloch <markb@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 2fab76b0bec5..21cbde472b64 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -109,7 +109,14 @@ extern struct mlx5e_tc_attr_to_reg_mapping mlx5e_tc_attr_to_reg_mappings[];
 bool mlx5e_is_valid_eswitch_fwd_dev(struct mlx5e_priv *priv,
 				    struct net_device *out_dev);
 
-bool mlx5e_tc_rep_update_skb(struct mlx5_cqe64 *cqe, struct sk_buff *skb);
+struct mlx5e_tc_update_priv {
+	struct net_device *tun_dev;
+};
+
+bool mlx5e_tc_rep_update_skb(struct mlx5_cqe64 *cqe, struct sk_buff *skb,
+			     struct mlx5e_tc_update_priv *tc_priv);
+
+void mlx5_tc_rep_post_napi_receive(struct mlx5e_tc_update_priv *tc_priv);
 
 struct mlx5e_tc_mod_hdr_acts {
 	int num_actions;

commit 0a7fcb78cc21d339c4eba2827df846e69cec1d07
Author: Paul Blakey <paulb@mellanox.com>
Date:   Sun Feb 16 12:01:34 2020 +0200

    net/mlx5e: Support inner header rewrite with goto action
    
    The hardware supports header rewrite of outer headers only.
    To perform header rewrite on inner headers, we must first
    decapsulate the packet.
    
    Currently, the hardware decap action is explicitly set by the tc
    tunnel_key unset action. However, with goto action the user won't
    use the tunnel_key unset action. In addition, header rewrites actions
    will not apply to the inner header as done by the software model.
    
    To support this, we will map each tunnel matches seen on a tc rule to
    a unique tunnel id, implicity add a decap action on tc chain 0 flows,
    and mark the packets with this unique tunnel id. Tunnel matches on
    the decapsulated tunnel on later chains will match on this unique id
    instead of the actual packet.
    
    We will also use this mapping to restore the tunnel info metadata
    on miss.
    
    Signed-off-by: Paul Blakey <paulb@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Reviewed-by: Oz Shlomo <ozsh@mellanox.com>
    Reviewed-by: Mark Bloch <markb@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 3848ec7b6c1e..2fab76b0bec5 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -93,12 +93,15 @@ void mlx5e_tc_reoffload_flows_work(struct work_struct *work);
 
 enum mlx5e_tc_attr_to_reg {
 	CHAIN_TO_REG,
+	TUNNEL_TO_REG,
 };
 
 struct mlx5e_tc_attr_to_reg_mapping {
 	int mfield; /* rewrite field */
 	int moffset; /* offset of mfield */
 	int mlen; /* bytes to rewrite/match */
+
+	int soffset; /* offset of spec for match */
 };
 
 extern struct mlx5e_tc_attr_to_reg_mapping mlx5e_tc_attr_to_reg_mappings[];
@@ -114,6 +117,16 @@ struct mlx5e_tc_mod_hdr_acts {
 	void *actions;
 };
 
+int mlx5e_tc_match_to_reg_set(struct mlx5_core_dev *mdev,
+			      struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts,
+			      enum mlx5e_tc_attr_to_reg type,
+			      u32 data);
+
+void mlx5e_tc_match_to_reg_match(struct mlx5_flow_spec *spec,
+				 enum mlx5e_tc_attr_to_reg type,
+				 u32 data,
+				 u32 mask);
+
 int alloc_mod_hdr_actions(struct mlx5_core_dev *mdev,
 			  int namespace,
 			  struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts);

commit 6ae4a6a594b8f642906922b86d4c920c68e09404
Author: Paul Blakey <paulb@mellanox.com>
Date:   Sun Feb 16 12:01:31 2020 +0200

    net/mlx5e: Allow re-allocating mod header actions
    
    Currently the size of the mod header actions array is deduced from the
    number of parsed TC header rewrite actions. However, mod header actions
    are also used for setting HW register values. Support the dynamic
    reallocation of the mod header array as a pre-step for adding HW
    registers mod actions.
    
    Signed-off-by: Paul Blakey <paulb@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Reviewed-by: Oz Shlomo <ozsh@mellanox.com>
    Reviewed-by: Mark Bloch <markb@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 9d5fcf61650c..3848ec7b6c1e 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -108,6 +108,17 @@ bool mlx5e_is_valid_eswitch_fwd_dev(struct mlx5e_priv *priv,
 
 bool mlx5e_tc_rep_update_skb(struct mlx5_cqe64 *cqe, struct sk_buff *skb);
 
+struct mlx5e_tc_mod_hdr_acts {
+	int num_actions;
+	int max_actions;
+	void *actions;
+};
+
+int alloc_mod_hdr_actions(struct mlx5_core_dev *mdev,
+			  int namespace,
+			  struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts);
+void dealloc_mod_hdr_actions(struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts);
+
 #else /* CONFIG_MLX5_ESWITCH */
 static inline int  mlx5e_tc_nic_init(struct mlx5e_priv *priv) { return 0; }
 static inline void mlx5e_tc_nic_cleanup(struct mlx5e_priv *priv) {}

commit d6d27782864f7dd5584fefe050c030283cc40d71
Author: Paul Blakey <paulb@mellanox.com>
Date:   Sun Feb 16 12:01:30 2020 +0200

    net/mlx5: E-Switch, Restore chain id on miss
    
    Chain ids are mapped to the lower part of reg C, and after loopback
    are copied to to CQE via a restore rule's flow_tag.
    
    To let tc continue in the correct chain, we find the corresponding
    chain id in the eswitch chain id <-> reg C mapping, and set the SKB's
    tc extension chain to it.
    
    That tells tc to continue processing from this set chain.
    
    Signed-off-by: Paul Blakey <paulb@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Reviewed-by: Oz Shlomo <ozsh@mellanox.com>
    Reviewed-by: Mark Bloch <markb@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index e2dbbae6d4d7..9d5fcf61650c 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -106,6 +106,8 @@ extern struct mlx5e_tc_attr_to_reg_mapping mlx5e_tc_attr_to_reg_mappings[];
 bool mlx5e_is_valid_eswitch_fwd_dev(struct mlx5e_priv *priv,
 				    struct net_device *out_dev);
 
+bool mlx5e_tc_rep_update_skb(struct mlx5_cqe64 *cqe, struct sk_buff *skb);
+
 #else /* CONFIG_MLX5_ESWITCH */
 static inline int  mlx5e_tc_nic_init(struct mlx5e_priv *priv) { return 0; }
 static inline void mlx5e_tc_nic_cleanup(struct mlx5e_priv *priv) {}

commit 8f1e0b97cc708aa6a4d84b0431afc410feba00b6
Author: Paul Blakey <paulb@mellanox.com>
Date:   Sun Feb 16 12:01:28 2020 +0200

    net/mlx5: E-Switch, Mark miss packets with new chain id mapping
    
    Currently, if we miss in hardware after jumping to some chain,
    we continue in chain 0 in software. This is wrong, and with the new
    tc skb extension we can now restore the chain id on the skb, so
    tc can continue with in the correct chain.
    
    To restore the chain id in software after a miss in hardware, we create
    a register mapping from 32bit chain ids to 16bit of reg_c0 (that
    survives loopback), to 32bit chain ids. We then mark packets that
    miss on some chain with the current chain id mapping on their reg_c0
    field. Using this mapping, we will support up to 64K concurrent
    chains.
    
    This register survives loopback and gets to the CQE on flow_tag
    via the eswitch restore rules.
    
    In next commit, we will reverse the mapping we got on the CQE
    to a chain id and tell tc to continue in the sw chain where we
    left off via the tc skb extension.
    
    Signed-off-by: Paul Blakey <paulb@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Reviewed-by: Oz Shlomo <ozsh@mellanox.com>
    Reviewed-by: Mark Bloch <markb@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 262cdb7b69b1..e2dbbae6d4d7 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -91,6 +91,18 @@ int mlx5e_tc_num_filters(struct mlx5e_priv *priv, unsigned long flags);
 
 void mlx5e_tc_reoffload_flows_work(struct work_struct *work);
 
+enum mlx5e_tc_attr_to_reg {
+	CHAIN_TO_REG,
+};
+
+struct mlx5e_tc_attr_to_reg_mapping {
+	int mfield; /* rewrite field */
+	int moffset; /* offset of mfield */
+	int mlen; /* bytes to rewrite/match */
+};
+
+extern struct mlx5e_tc_attr_to_reg_mapping mlx5e_tc_attr_to_reg_mappings[];
+
 bool mlx5e_is_valid_eswitch_fwd_dev(struct mlx5e_priv *priv,
 				    struct net_device *out_dev);
 

commit 84179981317fb4fb3e9df5acd42ea33cf6037793
Author: Paul Blakey <paulb@mellanox.com>
Date:   Tue Nov 12 00:34:30 2019 +0100

    net/mlx5: TC: Offload flow table rules
    
    Since both tc rules and flow table rules are of the same format,
    we can re-use tc parsing for that, and move the flow table rules
    to their steering domain - In this case, the next chain after
    max tc chain.
    
    Signed-off-by: Paul Blakey <paulb@mellanox.com>
    Reviewed-by: Mark Bloch <markb@mellanox.com>
    Acked-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 924c6ef86a14..262cdb7b69b1 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -44,7 +44,8 @@ enum {
 	MLX5E_TC_FLAG_EGRESS_BIT,
 	MLX5E_TC_FLAG_NIC_OFFLOAD_BIT,
 	MLX5E_TC_FLAG_ESW_OFFLOAD_BIT,
-	MLX5E_TC_FLAG_LAST_EXPORTED_BIT = MLX5E_TC_FLAG_ESW_OFFLOAD_BIT,
+	MLX5E_TC_FLAG_FT_OFFLOAD_BIT,
+	MLX5E_TC_FLAG_LAST_EXPORTED_BIT = MLX5E_TC_FLAG_FT_OFFLOAD_BIT,
 };
 
 #define MLX5_TC_FLAG(flag) BIT(MLX5E_TC_FLAG_##flag##_BIT)

commit 2a1f1768fa17805ca2e937e2e034a7c3433d3bdc
Author: Vlad Buslov <vladbu@mellanox.com>
Date:   Sun Aug 4 12:25:57 2019 +0300

    net/mlx5e: Refactor neigh update for concurrent execution
    
    In order to remove dependency on rtnl lock and allow neigh update workqueue
    task to execute concurrently with tc, refactor mlx5e_rep_neigh_update() for
    concurrent execution:
    
    - Lock encap table when accessing encap entry to prevent concurrent
      changes. To do this properly, the initial encap state check is moved from
      mlx5e_rep_neigh_update() into mlx5e_rep_update_flows() to be performed
      under encap_tbl_lock protection.
    
    - Wait for encap to be fully initialized before accessing it by means of
      'res_ready' completion.
    
    - Add mlx5e_take_all_encap_flows() helper which is used to construct a
      temporary list of flows and efi indexes that is used to access current
      encap data in flow which can be attached to multiple encaps
      simultaneously. Release the flows from temporary list after
      encap_tbl_lock critical section. This is necessary because
      mlx5e_flow_put() can't be called while holding encap_tbl_lock.
    
    - Modify mlx5e_tc_encap_flows_add() and mlx5e_tc_encap_flows_del() to work
      with user-provided list of flows built by mlx5e_take_all_encap_flows(),
      instead of traversing encap flow list directly.
    
    This is first step in complex neigh update refactoring, which is finished
    by following commit in this series.
    
    Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index ea2072e2fe84..924c6ef86a14 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -72,12 +72,17 @@ void mlx5e_tc_stats_matchall(struct mlx5e_priv *priv,
 
 struct mlx5e_encap_entry;
 void mlx5e_tc_encap_flows_add(struct mlx5e_priv *priv,
-			      struct mlx5e_encap_entry *e);
+			      struct mlx5e_encap_entry *e,
+			      struct list_head *flow_list);
 void mlx5e_tc_encap_flows_del(struct mlx5e_priv *priv,
-			      struct mlx5e_encap_entry *e);
+			      struct mlx5e_encap_entry *e,
+			      struct list_head *flow_list);
 bool mlx5e_encap_take(struct mlx5e_encap_entry *e);
 void mlx5e_encap_put(struct mlx5e_priv *priv, struct mlx5e_encap_entry *e);
 
+void mlx5e_take_all_encap_flows(struct mlx5e_encap_entry *e, struct list_head *flow_list);
+void mlx5e_put_encap_flow_list(struct mlx5e_priv *priv, struct list_head *flow_list);
+
 struct mlx5e_neigh_hash_entry;
 void mlx5e_tc_update_neigh_used_value(struct mlx5e_neigh_hash_entry *nhe);
 

commit 948993f2beebbdc1c9d926cfdad9827cf6bb67c0
Author: Vlad Buslov <vladbu@mellanox.com>
Date:   Sun Jun 3 20:31:47 2018 +0300

    net/mlx5e: Extend encap entry with reference counter
    
    List of flows attached to encap entry is used as implicit reference
    counter (encap entry is deallocated when list becomes free) and as a
    mechanism to obtain encap entry that flow is attached to (through list
    head). This is not safe when concurrent modification of list of flows
    attached to encap entry is possible. Proper atomic reference counter is
    required to support concurrent access.
    
    As a preparation for extending encap with reference counting, extract code
    that lookups and deletes encap entry into standalone put/get helpers. In
    order to remove this dependency on external locking, extend encap entry
    with reference counter to manage its lifetime and extend flow structure
    with direct pointer to encap entry that flow is attached to.
    
    Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
    Reviewed-by: Jianbo Liu <jianbol@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 20f045e96c92..ea2072e2fe84 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -75,6 +75,8 @@ void mlx5e_tc_encap_flows_add(struct mlx5e_priv *priv,
 			      struct mlx5e_encap_entry *e);
 void mlx5e_tc_encap_flows_del(struct mlx5e_priv *priv,
 			      struct mlx5e_encap_entry *e);
+bool mlx5e_encap_take(struct mlx5e_encap_entry *e);
+void mlx5e_encap_put(struct mlx5e_priv *priv, struct mlx5e_encap_entry *e);
 
 struct mlx5e_neigh_hash_entry;
 void mlx5e_tc_update_neigh_used_value(struct mlx5e_neigh_hash_entry *nhe);

commit fcb64c0f5640e629bd77c2cb088f9fd70ff5bde7
Author: Eli Cohen <eli@mellanox.com>
Date:   Wed May 8 11:44:56 2019 +0300

    net/mlx5: E-Switch, add ingress rate support
    
    Use the scheduling elements to implement ingress rate limiter on an
    eswitch ports ingress traffic. Since the ingress of eswitch port is the
    egress of VF port, we control eswitch ingress by controlling VF egress.
    
    Configuration is done using the ports' representor net devices.
    
    Please note that burst size configuration is not supported by devices
    ConnectX-5 and earlier generations.
    
    Configuration examples:
    tc:
    tc filter add dev enp59s0f0_0 root protocol ip matchall action police rate 1mbit burst 20k
    
    ovs:
    ovs-vsctl set interface eth0 ingress_policing_rate=1000
    
    Signed-off-by: Eli Cohen <eli@mellanox.com>
    Reviewed-by: Paul Blakey <paulb@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 1cb66bf76997..20f045e96c92 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -63,6 +63,13 @@ int mlx5e_delete_flower(struct net_device *dev, struct mlx5e_priv *priv,
 int mlx5e_stats_flower(struct net_device *dev, struct mlx5e_priv *priv,
 		       struct flow_cls_offload *f, unsigned long flags);
 
+int mlx5e_tc_configure_matchall(struct mlx5e_priv *priv,
+				struct tc_cls_matchall_offload *f);
+int mlx5e_tc_delete_matchall(struct mlx5e_priv *priv,
+			     struct tc_cls_matchall_offload *f);
+void mlx5e_tc_stats_matchall(struct mlx5e_priv *priv,
+			     struct tc_cls_matchall_offload *ma);
+
 struct mlx5e_encap_entry;
 void mlx5e_tc_encap_flows_add(struct mlx5e_priv *priv,
 			      struct mlx5e_encap_entry *e);

commit 226f2ca3075ab20abf69c68235e8ba9ac2dab596
Author: Vlad Buslov <vladbu@mellanox.com>
Date:   Thu Nov 8 20:01:35 2018 +0200

    net/mlx5e: Change flow flags type to unsigned long
    
    To remove dependency on rtnl lock and allow concurrent modification of
    'flags' field of tc flow structure, change flow flag type to unsigned long
    and use atomic bit ops for reading and changing the flags. Implement
    auxiliary functions for setting, resetting and getting specific flag, and
    for checking most often used flag values.
    
    Always set flags with smp_mb__before_atomic() to ensure that all
    mlx5e_tc_flow are updated before concurrent readers can read new flags
    value. Rearrange all code paths to actually set flow->rule[] pointers
    before setting the OFFLOADED flag. On read side, use smp_mb__after_atomic()
    when accessing flags to ensure that offload-related flow fields are only
    read after the flags.
    
    Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
    Reviewed-by: Jianbo Liu <jianbol@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 3ab39275ca7d..1cb66bf76997 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -40,13 +40,15 @@
 #ifdef CONFIG_MLX5_ESWITCH
 
 enum {
-	MLX5E_TC_INGRESS = BIT(0),
-	MLX5E_TC_EGRESS  = BIT(1),
-	MLX5E_TC_NIC_OFFLOAD = BIT(2),
-	MLX5E_TC_ESW_OFFLOAD = BIT(3),
-	MLX5E_TC_LAST_EXPORTED_BIT = 3,
+	MLX5E_TC_FLAG_INGRESS_BIT,
+	MLX5E_TC_FLAG_EGRESS_BIT,
+	MLX5E_TC_FLAG_NIC_OFFLOAD_BIT,
+	MLX5E_TC_FLAG_ESW_OFFLOAD_BIT,
+	MLX5E_TC_FLAG_LAST_EXPORTED_BIT = MLX5E_TC_FLAG_ESW_OFFLOAD_BIT,
 };
 
+#define MLX5_TC_FLAG(flag) BIT(MLX5E_TC_FLAG_##flag##_BIT)
+
 int mlx5e_tc_nic_init(struct mlx5e_priv *priv);
 void mlx5e_tc_nic_cleanup(struct mlx5e_priv *priv);
 
@@ -54,12 +56,12 @@ int mlx5e_tc_esw_init(struct rhashtable *tc_ht);
 void mlx5e_tc_esw_cleanup(struct rhashtable *tc_ht);
 
 int mlx5e_configure_flower(struct net_device *dev, struct mlx5e_priv *priv,
-			   struct flow_cls_offload *f, int flags);
+			   struct flow_cls_offload *f, unsigned long flags);
 int mlx5e_delete_flower(struct net_device *dev, struct mlx5e_priv *priv,
-			struct flow_cls_offload *f, int flags);
+			struct flow_cls_offload *f, unsigned long flags);
 
 int mlx5e_stats_flower(struct net_device *dev, struct mlx5e_priv *priv,
-		       struct flow_cls_offload *f, int flags);
+		       struct flow_cls_offload *f, unsigned long flags);
 
 struct mlx5e_encap_entry;
 void mlx5e_tc_encap_flows_add(struct mlx5e_priv *priv,
@@ -70,7 +72,7 @@ void mlx5e_tc_encap_flows_del(struct mlx5e_priv *priv,
 struct mlx5e_neigh_hash_entry;
 void mlx5e_tc_update_neigh_used_value(struct mlx5e_neigh_hash_entry *nhe);
 
-int mlx5e_tc_num_filters(struct mlx5e_priv *priv, int flags);
+int mlx5e_tc_num_filters(struct mlx5e_priv *priv, unsigned long flags);
 
 void mlx5e_tc_reoffload_flows_work(struct work_struct *work);
 
@@ -80,7 +82,11 @@ bool mlx5e_is_valid_eswitch_fwd_dev(struct mlx5e_priv *priv,
 #else /* CONFIG_MLX5_ESWITCH */
 static inline int  mlx5e_tc_nic_init(struct mlx5e_priv *priv) { return 0; }
 static inline void mlx5e_tc_nic_cleanup(struct mlx5e_priv *priv) {}
-static inline int  mlx5e_tc_num_filters(struct mlx5e_priv *priv, int flags) { return 0; }
+static inline int  mlx5e_tc_num_filters(struct mlx5e_priv *priv,
+					unsigned long flags)
+{
+	return 0;
+}
 #endif
 
 #endif /* __MLX5_EN_TC_H__ */

commit f9e30088d20016a224d8110d45356da253eaa26a
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Tue Jul 9 22:55:49 2019 +0200

    net: flow_offload: rename tc_cls_flower_offload to flow_cls_offload
    
    And any other existing fields in this structure that refer to tc.
    Specifically:
    
    * tc_cls_flower_offload_flow_rule() to flow_cls_offload_flow_rule().
    * TC_CLSFLOWER_* to FLOW_CLS_*.
    * tc_cls_common_offload to tc_cls_common_offload.
    
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 8f288cc53cee..3ab39275ca7d 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -54,12 +54,12 @@ int mlx5e_tc_esw_init(struct rhashtable *tc_ht);
 void mlx5e_tc_esw_cleanup(struct rhashtable *tc_ht);
 
 int mlx5e_configure_flower(struct net_device *dev, struct mlx5e_priv *priv,
-			   struct tc_cls_flower_offload *f, int flags);
+			   struct flow_cls_offload *f, int flags);
 int mlx5e_delete_flower(struct net_device *dev, struct mlx5e_priv *priv,
-			struct tc_cls_flower_offload *f, int flags);
+			struct flow_cls_offload *f, int flags);
 
 int mlx5e_stats_flower(struct net_device *dev, struct mlx5e_priv *priv,
-		       struct tc_cls_flower_offload *f, int flags);
+		       struct flow_cls_offload *f, int flags);
 
 struct mlx5e_encap_entry;
 void mlx5e_tc_encap_flows_add(struct mlx5e_priv *priv,

commit f6dc1264f1c01976a84239d1038359604ee42001
Author: Paul Blakey <paulb@mellanox.com>
Date:   Mon Jun 24 15:04:58 2019 +0300

    net/mlx5e: Disallow tc redirect offload cases we don't support
    
    After changing the parent_id to be the same for both NICs of same
    the hardware device, netdev_port_same_parent_id now returns true for
    more cases (all the lower devices in the hierarchy are on the same
    hardware device).
    
    If merged eswitch isn't enabled, these cases aren't supported, so disallow
    them.
    
    Signed-off-by: Paul Blakey <paulb@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index f62e81902d27..8f288cc53cee 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -74,6 +74,9 @@ int mlx5e_tc_num_filters(struct mlx5e_priv *priv, int flags);
 
 void mlx5e_tc_reoffload_flows_work(struct work_struct *work);
 
+bool mlx5e_is_valid_eswitch_fwd_dev(struct mlx5e_priv *priv,
+				    struct net_device *out_dev);
+
 #else /* CONFIG_MLX5_ESWITCH */
 static inline int  mlx5e_tc_nic_init(struct mlx5e_priv *priv) { return 0; }
 static inline void mlx5e_tc_nic_cleanup(struct mlx5e_priv *priv) {}

commit b4a23329e2e940cdec3b5eae781c1f7d4c669533
Author: Roi Dayan <roid@mellanox.com>
Date:   Wed Feb 6 15:43:51 2019 +0200

    net/mlx5e: Re-attempt to offload flows on multipath port affinity events
    
    Under multipath it's possible for us to offload the flow only through
    the e-switch for which proper route through the uplink exists.
    When the port is up and the next-hop route is set again we want to
    offload through it as well.
    
    We generate SW event from the FIB event handler when multipath port
    affinity changes. The tc offloads code gets this event, goes over the
    flows which were marked as of having missing route and attempts to
    offload them.
    
    Signed-off-by: Roi Dayan <roid@mellanox.com>
    Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index d2d87f978c06..f62e81902d27 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -72,6 +72,7 @@ void mlx5e_tc_update_neigh_used_value(struct mlx5e_neigh_hash_entry *nhe);
 
 int mlx5e_tc_num_filters(struct mlx5e_priv *priv, int flags);
 
+void mlx5e_tc_reoffload_flows_work(struct work_struct *work);
 
 #else /* CONFIG_MLX5_ESWITCH */
 static inline int  mlx5e_tc_nic_init(struct mlx5e_priv *priv) { return 0; }

commit d9ee0491c2ffbb5bc8bc418dd857a045d0d0130f
Author: Or Gerlitz <ogerlitz@mellanox.com>
Date:   Tue Feb 13 15:48:30 2018 +0200

    net/mlx5e: Use dedicated uplink vport netdev representor
    
    Currently, when running in sriov switchdev mode, we are using the PF
    netdevice as the uplink representor, this is problematic from few aspects:
    
    - will break when the PF isn't eswitch manager (e.g smart NIC env)
    - misalignment with other NIC switchdev drivers
    - makes us have and maintain special code, hurts the driver quality/robustness
    - which in turn opens the door for future bugs
    
    As of each and all of the above, we move to have a dedicated netdev representor
    for the uplink vport in a similar manner done for for the VF vports.
    
    This includes the following:
    
    1. have an uplink rep netdev as we have for VF reps
    2. all reps use same load/unload functions
    3. HW stats for uplink based on physical port counters and not vport counters
    4. link state for the uplink managed through PAOS and not vport state
    5. the uplink rep has sysfs link to the PF PCI function && uses the PF MAC address
    
    Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index a15c08a35054..d2d87f978c06 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -42,7 +42,9 @@
 enum {
 	MLX5E_TC_INGRESS = BIT(0),
 	MLX5E_TC_EGRESS  = BIT(1),
-	MLX5E_TC_LAST_EXPORTED_BIT = 1,
+	MLX5E_TC_NIC_OFFLOAD = BIT(2),
+	MLX5E_TC_ESW_OFFLOAD = BIT(3),
+	MLX5E_TC_LAST_EXPORTED_BIT = 3,
 };
 
 int mlx5e_tc_nic_init(struct mlx5e_priv *priv);
@@ -68,13 +70,13 @@ void mlx5e_tc_encap_flows_del(struct mlx5e_priv *priv,
 struct mlx5e_neigh_hash_entry;
 void mlx5e_tc_update_neigh_used_value(struct mlx5e_neigh_hash_entry *nhe);
 
-int mlx5e_tc_num_filters(struct mlx5e_priv *priv);
+int mlx5e_tc_num_filters(struct mlx5e_priv *priv, int flags);
 
 
 #else /* CONFIG_MLX5_ESWITCH */
 static inline int  mlx5e_tc_nic_init(struct mlx5e_priv *priv) { return 0; }
 static inline void mlx5e_tc_nic_cleanup(struct mlx5e_priv *priv) {}
-static inline int  mlx5e_tc_num_filters(struct mlx5e_priv *priv) { return 0; }
+static inline int  mlx5e_tc_num_filters(struct mlx5e_priv *priv, int flags) { return 0; }
 #endif
 
 #endif /* __MLX5_EN_TC_H__ */

commit 101f4de9dd521c6d06dfdacaa35e506a8db8494b
Author: Oz Shlomo <ozsh@mellanox.com>
Date:   Sun Dec 2 14:43:27 2018 +0200

    net/mlx5e: Move TC tunnel offloading code to separate source file
    
    Move tunnel offloading related code to a separate source file for better
    code maintainability.
    
    Code refactoring with no functional change.
    
    Signed-off-by: Oz Shlomo <ozsh@mellanox.com>
    Reviewed-by: Eli Britstein <elibr@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 004e679a4f53..a15c08a35054 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -70,8 +70,6 @@ void mlx5e_tc_update_neigh_used_value(struct mlx5e_neigh_hash_entry *nhe);
 
 int mlx5e_tc_num_filters(struct mlx5e_priv *priv);
 
-bool mlx5e_tc_tun_device_to_offload(struct mlx5e_priv *priv,
-				    struct net_device *netdev);
 
 #else /* CONFIG_MLX5_ESWITCH */
 static inline int  mlx5e_tc_nic_init(struct mlx5e_priv *priv) { return 0; }

commit 71d82d2a90327c9c816e65471b7859b601993f89
Author: Oz Shlomo <ozsh@mellanox.com>
Date:   Sun Oct 28 09:14:50 2018 +0200

    net/mlx5e: Provide the TC filter netdev as parameter to flower callbacks
    
    Currently the driver controls flower filters that are installed on its
    devices. However, with the introduction of the indirect block
    notifications platform the driver may receive control events for filters
    that are installed on higher level net devices (e.g. tunnel devices).
    Therefore, the driver filter control API will not be able to implicitly
    assume the filter's net device.
    
    Explicitly specify the filter's net device, no functional change
    
    Signed-off-by: Oz Shlomo <ozsh@mellanox.com>
    Reviewed-by: Eli Britstein <elibr@mellanox.com>
    Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 378507988a32..004e679a4f53 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -51,12 +51,12 @@ void mlx5e_tc_nic_cleanup(struct mlx5e_priv *priv);
 int mlx5e_tc_esw_init(struct rhashtable *tc_ht);
 void mlx5e_tc_esw_cleanup(struct rhashtable *tc_ht);
 
-int mlx5e_configure_flower(struct mlx5e_priv *priv,
+int mlx5e_configure_flower(struct net_device *dev, struct mlx5e_priv *priv,
 			   struct tc_cls_flower_offload *f, int flags);
-int mlx5e_delete_flower(struct mlx5e_priv *priv,
+int mlx5e_delete_flower(struct net_device *dev, struct mlx5e_priv *priv,
 			struct tc_cls_flower_offload *f, int flags);
 
-int mlx5e_stats_flower(struct mlx5e_priv *priv,
+int mlx5e_stats_flower(struct net_device *dev, struct mlx5e_priv *priv,
 		       struct tc_cls_flower_offload *f, int flags);
 
 struct mlx5e_encap_entry;

commit f5bc2c5de1015caf7e49b0bf9e7e97077736045a
Author: Oz Shlomo <ozsh@mellanox.com>
Date:   Sun Oct 28 08:34:51 2018 +0200

    net/mlx5e: Support TC indirect block notifications for eswitch uplink reprs
    
    Towards using this mechanism as the means to offload tunnel decap rules
    set on SW tunnel devices instead of egdev, add the supporting structures
    and functions.
    
    Signed-off-by: Oz Shlomo <ozsh@mellanox.com>
    Reviewed-by: Eli Britstein <elibr@mellanox.com>
    Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 49436bf3b80a..378507988a32 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -70,6 +70,9 @@ void mlx5e_tc_update_neigh_used_value(struct mlx5e_neigh_hash_entry *nhe);
 
 int mlx5e_tc_num_filters(struct mlx5e_priv *priv);
 
+bool mlx5e_tc_tun_device_to_offload(struct mlx5e_priv *priv,
+				    struct net_device *netdev);
+
 #else /* CONFIG_MLX5_ESWITCH */
 static inline int  mlx5e_tc_nic_init(struct mlx5e_priv *priv) { return 0; }
 static inline void mlx5e_tc_nic_cleanup(struct mlx5e_priv *priv) {}

commit 01252a27837a9dd099a6e8cfa3adc4772033a5bf
Author: Or Gerlitz <ogerlitz@mellanox.com>
Date:   Tue May 22 20:18:36 2018 +0300

    net/mlx5e: Get the number of offloaded TC rules from the correct table
    
    As we keep the offloaded TC rules for NIC and e-switch in two different
    places, make sure to return the number of offloaded flows according
    to the use-case and not blindly from the priv.
    
    Fixes: 655dc3d2b91b ('net/mlx5e: Use shared table for offloaded TC eswitch flows')
    Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
    Reported-by: Paul Blakey <paulb@mellanox.com>
    Reviewed-by: Paul Blakey <paulb@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 59e52b845beb..49436bf3b80a 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -68,10 +68,7 @@ void mlx5e_tc_encap_flows_del(struct mlx5e_priv *priv,
 struct mlx5e_neigh_hash_entry;
 void mlx5e_tc_update_neigh_used_value(struct mlx5e_neigh_hash_entry *nhe);
 
-static inline int mlx5e_tc_num_filters(struct mlx5e_priv *priv)
-{
-	return atomic_read(&priv->fs.tc.ht.nelems);
-}
+int mlx5e_tc_num_filters(struct mlx5e_priv *priv);
 
 #else /* CONFIG_MLX5_ESWITCH */
 static inline int  mlx5e_tc_nic_init(struct mlx5e_priv *priv) { return 0; }

commit 655dc3d2b91bf241f5baca5eb2bc2b1e22a561ff
Author: Or Gerlitz <ogerlitz@mellanox.com>
Date:   Tue Apr 10 18:34:36 2018 +0300

    net/mlx5e: Use shared table for offloaded TC eswitch flows
    
    Currently, each representor netdev use their own hash table to keep
    the mapping from TC flow (f->cookie) to the driver offloaded instance.
    The table is the one which originally was added for offloading TC NIC
    (not eswitch) rules.
    
    This scheme breaks when the core TC code calls us to add the same flow
    twice, (e.g under egdev use case) since we don't spot that and offload
    a 2nd flow into the HW with the wrong source vport.
    
    As a pre-step to solve that, we move to use a single table which keeps
    all offloaded TC eswitch flows. The table is located at the eswitch
    uplink representor object.
    
    Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Reviewed-by: Paul Blakey <paulb@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 2255345c2e18..59e52b845beb 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -45,8 +45,11 @@ enum {
 	MLX5E_TC_LAST_EXPORTED_BIT = 1,
 };
 
-int mlx5e_tc_init(struct mlx5e_priv *priv);
-void mlx5e_tc_cleanup(struct mlx5e_priv *priv);
+int mlx5e_tc_nic_init(struct mlx5e_priv *priv);
+void mlx5e_tc_nic_cleanup(struct mlx5e_priv *priv);
+
+int mlx5e_tc_esw_init(struct rhashtable *tc_ht);
+void mlx5e_tc_esw_cleanup(struct rhashtable *tc_ht);
 
 int mlx5e_configure_flower(struct mlx5e_priv *priv,
 			   struct tc_cls_flower_offload *f, int flags);
@@ -71,8 +74,8 @@ static inline int mlx5e_tc_num_filters(struct mlx5e_priv *priv)
 }
 
 #else /* CONFIG_MLX5_ESWITCH */
-static inline int  mlx5e_tc_init(struct mlx5e_priv *priv) { return 0; }
-static inline void mlx5e_tc_cleanup(struct mlx5e_priv *priv) {}
+static inline int  mlx5e_tc_nic_init(struct mlx5e_priv *priv) { return 0; }
+static inline void mlx5e_tc_nic_cleanup(struct mlx5e_priv *priv) {}
 static inline int  mlx5e_tc_num_filters(struct mlx5e_priv *priv) { return 0; }
 #endif
 

commit 60bd4af814fec164c42bdd2efd7984b85d6b1e1e
Author: Or Gerlitz <ogerlitz@mellanox.com>
Date:   Wed Apr 18 13:45:11 2018 +0300

    net/mlx5e: Add ingress/egress indication for offloaded TC flows
    
    When an e-switch TC rule is offloaded through the egdev (egress
    device) mechanism, we treat this as egress, all other cases (NIC
    and e-switch) are considred ingress.
    
    This is preparation step that will allow us to  identify "wrong"
    stat/del offload calls made by the TC core on egdev based flows and
    ignore them.
    
    Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Reviewed-by: Paul Blakey <paulb@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index c14c263a739b..2255345c2e18 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -38,16 +38,23 @@
 #define MLX5E_TC_FLOW_ID_MASK 0x0000ffff
 
 #ifdef CONFIG_MLX5_ESWITCH
+
+enum {
+	MLX5E_TC_INGRESS = BIT(0),
+	MLX5E_TC_EGRESS  = BIT(1),
+	MLX5E_TC_LAST_EXPORTED_BIT = 1,
+};
+
 int mlx5e_tc_init(struct mlx5e_priv *priv);
 void mlx5e_tc_cleanup(struct mlx5e_priv *priv);
 
 int mlx5e_configure_flower(struct mlx5e_priv *priv,
-			   struct tc_cls_flower_offload *f);
+			   struct tc_cls_flower_offload *f, int flags);
 int mlx5e_delete_flower(struct mlx5e_priv *priv,
-			struct tc_cls_flower_offload *f);
+			struct tc_cls_flower_offload *f, int flags);
 
 int mlx5e_stats_flower(struct mlx5e_priv *priv,
-		       struct tc_cls_flower_offload *f);
+		       struct tc_cls_flower_offload *f, int flags);
 
 struct mlx5e_encap_entry;
 void mlx5e_tc_encap_flows_add(struct mlx5e_priv *priv,

commit fde6af4729b005dc9dc936b0ed9f1b27b5b2d0f4
Merge: 71feeef67805 a8ffcc741acb
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Aug 7 10:42:09 2017 -0700

    Merge tag 'mlx5-shared-2017-08-07' of git://git.kernel.org/pub/scm/linux/kernel/git/mellanox/linux
    
    Saeed Mahameed says:
    
    ====================
    mlx5-shared-2017-08-07
    
    This series includes some mlx5 updates for both net-next and rdma trees.
    
    From Saeed,
    Core driver updates to allow selectively building the driver with
    or without some large driver components, such as
            - E-Switch (Ethernet SRIOV support).
            - Multi-Physical Function Switch (MPFs) support.
    For that we split E-Switch and MPFs functionalities into separate files.
    
    From Erez,
    Delay mlx5_core events when mlx5 interfaces, namely mlx5_ib, registration
    is taking place and until it completes.
    
    From Rabie,
    Increase the maximum supported flow counters.
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit de4784ca030fed17d527dbb2bb4e21328b12de94
Author: Jiri Pirko <jiri@mellanox.com>
Date:   Mon Aug 7 10:15:32 2017 +0200

    net: sched: get rid of struct tc_to_netdev
    
    Get rid of struct tc_to_netdev which is now just unnecessary container
    and rather pass per-type structures down to drivers directly.
    Along with that, consolidate the naming of per-type structure variables
    in cls_*.
    
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 5a0f4a487855..2917d964ffc3 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -33,6 +33,8 @@
 #ifndef __MLX5_EN_TC_H__
 #define __MLX5_EN_TC_H__
 
+#include <net/pkt_cls.h>
+
 #define MLX5E_TC_FLOW_ID_MASK 0x0000ffff
 
 int mlx5e_tc_init(struct mlx5e_priv *priv);

commit 5fd9fc4e207dba0c05cafe78417952b4c4ca02dc
Author: Jiri Pirko <jiri@mellanox.com>
Date:   Mon Aug 7 10:15:29 2017 +0200

    net: sched: push cls related args into cls_common structure
    
    As ndo_setup_tc is generic offload op for whole tc subsystem, does not
    really make sense to have cls-specific args. So move them under
    cls_common structurure which is embedded in all cls structs.
    
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index ecbe30d808ae..5a0f4a487855 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -38,7 +38,7 @@
 int mlx5e_tc_init(struct mlx5e_priv *priv);
 void mlx5e_tc_cleanup(struct mlx5e_priv *priv);
 
-int mlx5e_configure_flower(struct mlx5e_priv *priv, __be16 protocol,
+int mlx5e_configure_flower(struct mlx5e_priv *priv,
 			   struct tc_cls_flower_offload *f);
 int mlx5e_delete_flower(struct mlx5e_priv *priv,
 			struct tc_cls_flower_offload *f);

commit e80541ecabd57b69726232b89242e28d8123cccc
Author: Saeed Mahameed <saeedm@mellanox.com>
Date:   Mon Jun 5 15:17:12 2017 +0300

    net/mlx5: Add CONFIG_MLX5_ESWITCH Kconfig
    
    Allow to selectively build the driver with or without sriov eswitch, VF
    representors and TC offloads.
    
    Also remove the need of two ndo ops structures (sriov & basic)
    and keep only one unified ndo ops, compile out VF SRIOV ndos when not
    needed (MLX5_ESWITCH=n), and for VF netdev calling those ndos will result
    in returning -EPERM.
    
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
    Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
    Cc: Jes Sorensen <jsorensen@fb.com>
    Cc: kernel-team@fb.com

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index ecbe30d808ae..36473ec65ce8 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -35,6 +35,7 @@
 
 #define MLX5E_TC_FLOW_ID_MASK 0x0000ffff
 
+#ifdef CONFIG_MLX5_ESWITCH
 int mlx5e_tc_init(struct mlx5e_priv *priv);
 void mlx5e_tc_cleanup(struct mlx5e_priv *priv);
 
@@ -60,4 +61,10 @@ static inline int mlx5e_tc_num_filters(struct mlx5e_priv *priv)
 	return atomic_read(&priv->fs.tc.ht.nelems);
 }
 
+#else /* CONFIG_MLX5_ESWITCH */
+static inline int  mlx5e_tc_init(struct mlx5e_priv *priv) { return 0; }
+static inline void mlx5e_tc_cleanup(struct mlx5e_priv *priv) {}
+static inline int  mlx5e_tc_num_filters(struct mlx5e_priv *priv) { return 0; }
+#endif
+
 #endif /* __MLX5_EN_TC_H__ */

commit f6dfb4c3f2161c23ab2939dd1b5f133dcdf147c6
Author: Hadar Hen Zion <hadarh@mellanox.com>
Date:   Fri Feb 24 12:16:33 2017 +0200

    net/mlx5e: Update neighbour 'used' state using HW flow rules counters
    
    When IP tunnel encapsulation rules are offloaded, the kernel can't see
    the traffic of the offloaded flow. The neighbour for the IP tunnel
    destination of the offloaded flow can mistakenly become STALE and
    deleted by the kernel since its 'used' value wasn't changed.
    
    To make sure that a neighbour which is used by the HW won't become
    STALE, we proactively update the neighbour 'used' value every
    DELAY_PROBE_TIME period, when packets were matched and counted by the HW
    for one of the tunnel encap flows related to this neighbour.
    
    The periodic task that updates the used neighbours is scheduled when a
    tunnel encap rule is successfully offloaded into HW and keeps re-scheduling
    itself as long as the representor's neighbours list isn't empty.
    
    Add, remove, lookup and status change operations done over the
    representor's neighbours list or the neighbour hash entry encaps list
    are all serialized by RTNL lock.
    
    Signed-off-by: Hadar Hen Zion <hadarh@mellanox.com>
    Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 278c7a646a55..ecbe30d808ae 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -52,6 +52,9 @@ void mlx5e_tc_encap_flows_add(struct mlx5e_priv *priv,
 void mlx5e_tc_encap_flows_del(struct mlx5e_priv *priv,
 			      struct mlx5e_encap_entry *e);
 
+struct mlx5e_neigh_hash_entry;
+void mlx5e_tc_update_neigh_used_value(struct mlx5e_neigh_hash_entry *nhe);
+
 static inline int mlx5e_tc_num_filters(struct mlx5e_priv *priv)
 {
 	return atomic_read(&priv->fs.tc.ht.nelems);

commit 232c001398ae8406dc0daf07b14e6ec9a5562719
Author: Hadar Hen Zion <hadarh@mellanox.com>
Date:   Mon Mar 20 12:56:47 2017 +0200

    net/mlx5e: Add support to neighbour update flow
    
    In order to offload TC encap rules, the driver does a lookup for the IP
    tunnel neighbour according to the output device and the destination IP
    given by the user.
    
    To keep tracking after the validity state of such neighbours, we keep
    the neighbours information (pair of device pointer and destination IP)
    in a hash table maintained at the relevant egress representor and
    register to get NETEVENT_NEIGH_UPDATE events. When getting neighbour update
    netevent, we search for a match among the cached neighbours entries used for
    encapsulation.
    
    In case the neighbour isn't valid, we can't offload the flow into the
    HW. We cache the flow (requested matching and actions) in the driver and
    offload the rule later, when the neighbour is resolved and becomes
    valid.
    
    When a flow is only cached in the driver and not offloaded into HW
    yet, we use EAGAIN return value to mark it internally, the TC ndo still
    returns success.
    
    Listen to kernel neighbour update netevents to trace relevant neighbours
    validity state:
    
    1. If a neighbour becomes valid, offload the related rules to HW.
    
    2. If the neighbour becomes invalid, remove the related rules from HW.
    
    3. If the neighbour mac address was changed, update the encap header.
       Remove all the offloaded rules using the old encap header from the HW
       and insert new rules to HW with updated encap header.
    
    Access to the neighbors hash table is protected by RTNL lock of its
    caller or by the table's spinlock.
    
    Details of the locking/synchronization among the different actions
    applied on the neighbour table:
    
    Add/remove operations - protected by RTNL lock of its caller (all TC
    commands are protected by RTNL lock). Add and remove operations are
    initiated only when the user inserts/removes a TC rule into/from the driver.
    
    Lookup/remove operations - since the lookup operation is done from
    netevent notifier block, RTNL lock can't be used (atomic context).
    Use the table's spin lock to protect lookups from TC user removal operation.
    bh is used since netevent can be called from a softirq context.
    
    Lookup/add operations - The hash table access functions are taking
    care of the protection between lookup and add operations.
    
    When adding/removing encap headers and rules to/from the HW, RTNL lock
    is used. It can happen when:
    
    1. The user inserts/removes a TC rule into/from the driver (TC commands
    are protected by RTNL lock of it's caller).
    
    2. The driver gets neighbour notification event, which reports about
    neighbour validity status change. Before adding/removing encap headers
    and rules to/from the HW, RTNL lock is taken.
    
    A neighbour hash table entry should be freed when its encap list is empty.
    Since The neighbour update netevent notification schedules a neighbour
    update work that uses the neighbour hash entry, it can't be freed
    unconditionally when the encap list becomes empty during TC delete rule flow.
    Use reference count to protect from freeing neighbour hash table entry
    while it's still in use.
    
    When the user asks to unregister a netdvice used by one of the neigbours,
    neighbour removal notification is received. Then we take a reference on the
    neighbour and don't free it until the relevant encap entries (and flows) are
    marked as invalid (not offloaded) and removed from HW.
    As long as the encap entry is still valid (checked under RTNL lock) we
    can safely access the neighbour device saved on mlx5e_neigh struct.
    
    Signed-off-by: Hadar Hen Zion <hadarh@mellanox.com>
    Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 34bf903fc886..278c7a646a55 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -46,6 +46,12 @@ int mlx5e_delete_flower(struct mlx5e_priv *priv,
 int mlx5e_stats_flower(struct mlx5e_priv *priv,
 		       struct tc_cls_flower_offload *f);
 
+struct mlx5e_encap_entry;
+void mlx5e_tc_encap_flows_add(struct mlx5e_priv *priv,
+			      struct mlx5e_encap_entry *e);
+void mlx5e_tc_encap_flows_del(struct mlx5e_priv *priv,
+			      struct mlx5e_encap_entry *e);
+
 static inline int mlx5e_tc_num_filters(struct mlx5e_priv *priv)
 {
 	return atomic_read(&priv->fs.tc.ht.nelems);

commit aad7e08d39bda94aedc594a82576980941306fc9
Author: Amir Vadai <amirva@mellanox.com>
Date:   Fri May 13 12:55:42 2016 +0000

    net/mlx5e: Hardware offloaded flower filter statistics support
    
    Introduce support in updating statistics of offloaded TC flower
    classifiers. Currently only the DROP action is supported.
    
    Signed-off-by: Amir Vadai <amirva@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index a4f17b974d62..34bf903fc886 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -43,6 +43,9 @@ int mlx5e_configure_flower(struct mlx5e_priv *priv, __be16 protocol,
 int mlx5e_delete_flower(struct mlx5e_priv *priv,
 			struct tc_cls_flower_offload *f);
 
+int mlx5e_stats_flower(struct mlx5e_priv *priv,
+		       struct tc_cls_flower_offload *f);
+
 static inline int mlx5e_tc_num_filters(struct mlx5e_priv *priv)
 {
 	return atomic_read(&priv->fs.tc.ht.nelems);

commit acff797cd187402d73cf9f290531a41250613294
Author: Maor Gottlieb <maorg@mellanox.com>
Date:   Fri Apr 29 01:36:37 2016 +0300

    net/mlx5e: Refactor mlx5e flow steering structs
    
    Slightly refactor and re-order the flow steering structs,
    tables and data-bases for better self-containment and
    flexibility to add more future steering phases
    (tables/rules/data bases) e.g: aRFS.
    
    Changes:
    1. Move the vlan DB and address DB into their table structs.
    2. Rename steering table structs to unique format: mlx5e_*_table,
    e.g: mlx5e_vlan_table.
    
    Signed-off-by: Maor Gottlieb <maorg@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index d677428dc10f..a4f17b974d62 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -45,7 +45,7 @@ int mlx5e_delete_flower(struct mlx5e_priv *priv,
 
 static inline int mlx5e_tc_num_filters(struct mlx5e_priv *priv)
 {
-	return atomic_read(&priv->fts.tc.ht.nelems);
+	return atomic_read(&priv->fs.tc.ht.nelems);
 }
 
 #endif /* __MLX5_EN_TC_H__ */

commit 12185a9fafa9cf39b73588c92aa49300ff3bf191
Author: Amir Vadai <amir@vadai.me>
Date:   Tue Mar 8 12:42:38 2016 +0200

    net/mlx5e: Support offload cls_flower with skbedit mark action
    
    Introduce offloading of skbedit mark action.
    
    For example, to mark with 0x1234, all TCP (ip_proto 6) packets arriving
    to interface ens9:
    
     # tc qdisc add dev ens9 ingress
     # tc filter add dev ens9 protocol ip parent ffff: \
         flower ip_proto 6 \
         indev ens9 \
         action skbedit mark 0x1234
    
    Signed-off-by: Amir Vadai <amir@vadai.me>
    Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 70642f4f78f0..d677428dc10f 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -33,6 +33,8 @@
 #ifndef __MLX5_EN_TC_H__
 #define __MLX5_EN_TC_H__
 
+#define MLX5E_TC_FLOW_ID_MASK 0x0000ffff
+
 int mlx5e_tc_init(struct mlx5e_priv *priv);
 void mlx5e_tc_cleanup(struct mlx5e_priv *priv);
 

commit e3a2b7ed018e885721a1b664ed7bf0f3fe29c81c
Author: Amir Vadai <amir@vadai.me>
Date:   Tue Mar 8 12:42:37 2016 +0200

    net/mlx5e: Support offload cls_flower with drop action
    
    Parse tc_cls_flower_offload into device specific commands and program
    the hardware to classify and act accordingly.
    
    For example, to drop ICMP (ip_proto 1) packets from specific smac, dmac,
    src_ip, src_ip, arriving to interface ens9:
    
     # tc qdisc add dev ens9 ingress
    
     # tc filter add dev ens9 protocol ip parent ffff: \
         flower ip_proto 1 \
         dst_mac 7c:fe:90:69:81:62 src_mac 7c:fe:90:69:81:56 \
         dst_ip 11.11.11.11 src_ip 11.11.11.12 indev ens9 \
         action drop
    
    Signed-off-by: Amir Vadai <amir@vadai.me>
    Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 46eacc582f13..70642f4f78f0 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -36,6 +36,11 @@
 int mlx5e_tc_init(struct mlx5e_priv *priv);
 void mlx5e_tc_cleanup(struct mlx5e_priv *priv);
 
+int mlx5e_configure_flower(struct mlx5e_priv *priv, __be16 protocol,
+			   struct tc_cls_flower_offload *f);
+int mlx5e_delete_flower(struct mlx5e_priv *priv,
+			struct tc_cls_flower_offload *f);
+
 static inline int mlx5e_tc_num_filters(struct mlx5e_priv *priv)
 {
 	return atomic_read(&priv->fts.tc.ht.nelems);

commit e8f887ac6a45ecb7f881f278a3fed1fbf002ef0b
Author: Amir Vadai <amir@vadai.me>
Date:   Tue Mar 8 12:42:36 2016 +0200

    net/mlx5e: Introduce tc offload support
    
    Extend ndo_setup_tc() to support ingress tc offloading. Will be used by
    later patches to offload tc flower filter.
    
    Feature is off by default and could be enabled by issuing:
     # ethtool  -K eth0 hw-tc-offload on
    
    Offloads flow table is dynamically created when first filter is
    added.
    Rules are saved in a hash table that is maintained by the consumer (for
    example - the flower offload in the next patch).
    When last filter is removed and no filters exist in the hash table, the
    offload flow table is destroyed.
    
    Signed-off-by: Amir Vadai <amir@vadai.me>
    Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
new file mode 100644
index 000000000000..46eacc582f13
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2016, Mellanox Technologies. All rights reserved.
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifndef __MLX5_EN_TC_H__
+#define __MLX5_EN_TC_H__
+
+int mlx5e_tc_init(struct mlx5e_priv *priv);
+void mlx5e_tc_cleanup(struct mlx5e_priv *priv);
+
+static inline int mlx5e_tc_num_filters(struct mlx5e_priv *priv)
+{
+	return atomic_read(&priv->fts.tc.ht.nelems);
+}
+
+#endif /* __MLX5_EN_TC_H__ */
