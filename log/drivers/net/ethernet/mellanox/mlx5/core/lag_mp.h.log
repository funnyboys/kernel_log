commit 6838a35a4567de7ddefd5c2d09ccfa41d754e4ee
Author: Mark Zhang <markz@mellanox.com>
Date:   Tue Mar 17 11:28:28 2020 +0200

    net/mlx5: Use a separate work queue for fib event handling
    
    In VF lag mode when remove the bonding module without bring down the
    bond device first, we could potentially have circular dependency when we
    unload IB devices and also handle fib events:
    1. The bond work starts first;
    2. The "modprobe -rv bonding" process tries to release the bond device,
       with the "pernet_ops_rwsem" lock hold;
    3. The bond work blocks in unregister_netdevice_notifier() and waits for
    the lock because fib event came right before;
    4. The kernel fib module tries to free all the fib entries by broadcasting
       the "FIB_EVENT_NH_DEL" event;
    5. Upon the fib event this lag_mp module holds the fib lock and queue a
       fib work.
    So:
       bond work -> modprobe task -> kernel fib module -> lag_mp -> bond work
    
    Today we either reload IB devices in roce lag in nic mode or either handle
    fib events in switchdev mode, but a new feature could change that we'll
    need to reload IB devices also in switchdev mode so this is a future proof
    fix as one may not notice this later.
    
    Signed-off-by: Mark Zhang <markz@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/lag_mp.h b/drivers/net/ethernet/mellanox/mlx5/core/lag_mp.h
index 79be89e9c7a4..258ac7b2964e 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/lag_mp.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lag_mp.h
@@ -16,6 +16,7 @@ enum mlx5_lag_port_affinity {
 struct lag_mp {
 	struct notifier_block     fib_nb;
 	struct fib_info           *mfi; /* used in tracking fib events */
+	struct workqueue_struct   *wq;
 };
 
 #ifdef CONFIG_MLX5_ESWITCH

commit 1cdc14e9d134a48d86673fd75a6abcbe0e58a29c
Author: Erez Alfasi <ereza@mellanox.com>
Date:   Mon Sep 16 14:34:55 2019 +0300

    net/mlx5: LAG, Use affinity type enumerators
    
    Instead of using explicit indexes, simply use affinity
    type enumerators to make the code more readable.
    
    Fixes: 544fe7c2e654 ("net/mlx5e: Activate HW multipath and handle port affinity based on FIB events")
    Signed-off-by: Erez Alfasi <ereza@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/lag_mp.h b/drivers/net/ethernet/mellanox/mlx5/core/lag_mp.h
index 6d14b1100be9..79be89e9c7a4 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/lag_mp.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lag_mp.h
@@ -7,6 +7,12 @@
 #include "lag.h"
 #include "mlx5_core.h"
 
+enum mlx5_lag_port_affinity {
+	MLX5_LAG_NORMAL_AFFINITY,
+	MLX5_LAG_P1_AFFINITY,
+	MLX5_LAG_P2_AFFINITY,
+};
+
 struct lag_mp {
 	struct notifier_block     fib_nb;
 	struct fib_info           *mfi; /* used in tracking fib events */

commit 544fe7c2e654124870e774157d99da357dce22dc
Author: Roi Dayan <roid@mellanox.com>
Date:   Sun Feb 17 11:54:06 2019 +0200

    net/mlx5e: Activate HW multipath and handle port affinity based on FIB events
    
    To support multipath offload we are going to track SW multipath route
    and related nexthops. To do that we register to FIB notifier and handle
    the route and next-hops events and reflect that as port affinity to HW.
    
    When there is a new multipath route entry that all next-hops are the
    ports of an HCA we will activate LAG in HW.
    
    Egress wise, we use HW LAG as the means to emulate multipath on current
    HW which doesn't support port selection based on xmit hash. In the
    presence of multiple VFs which use multiple SQs (send queues) this
    yields fairly good distribution.
    
    HA wise, HW LAG buys us the ability for a given RQ (receive queue) to
    receive traffic from both ports and for SQs to migrate xmitting over
    the active port if their base port fails.
    
    When the route entry is being updated to single path we will update
    the HW port affinity to use that port only.
    
    If a next-hop becomes dead we update the HW port affinity to the living
    port.
    
    When all next-hops are alive again we reset the affinity to default.
    
    Due to FW/HW limitations, when a route is deleted we are not disabling
    the HW LAG since doing so will not allow us to enable it again while
    VFs are bounded. Typically this is just a temporary state when a
    routing daemon removes dead routes and later adds them back as needed.
    
    This patch only handles events for AF_INET.
    
    Signed-off-by: Roi Dayan <roid@mellanox.com>
    Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/lag_mp.h b/drivers/net/ethernet/mellanox/mlx5/core/lag_mp.h
new file mode 100644
index 000000000000..6d14b1100be9
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lag_mp.h
@@ -0,0 +1,26 @@
+/* SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB */
+/* Copyright (c) 2019 Mellanox Technologies. */
+
+#ifndef __MLX5_LAG_MP_H__
+#define __MLX5_LAG_MP_H__
+
+#include "lag.h"
+#include "mlx5_core.h"
+
+struct lag_mp {
+	struct notifier_block     fib_nb;
+	struct fib_info           *mfi; /* used in tracking fib events */
+};
+
+#ifdef CONFIG_MLX5_ESWITCH
+
+int mlx5_lag_mp_init(struct mlx5_lag *ldev);
+void mlx5_lag_mp_cleanup(struct mlx5_lag *ldev);
+
+#else /* CONFIG_MLX5_ESWITCH */
+
+static inline int mlx5_lag_mp_init(struct mlx5_lag *ldev) { return 0; }
+static inline void mlx5_lag_mp_cleanup(struct mlx5_lag *ldev) {}
+
+#endif /* CONFIG_MLX5_ESWITCH */
+#endif /* __MLX5_LAG_MP_H__ */
