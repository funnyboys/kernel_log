commit cef35af34d6dc3792333075115c7deb7062b6e18
Author: Eran Ben Elisha <eranbe@mellanox.com>
Date:   Thu Aug 22 05:06:00 2019 +0000

    net/mlx5e: Add mlx5e HV VHCA stats agent
    
    HV VHCA stats agent is responsible on running a preiodic rx/tx
    packets/bytes stats update. Currently the supported format is version
    MLX5_HV_VHCA_STATS_VERSION. Block ID 1 is dedicated for statistics data
    transfer from the VF to the PF.
    
    The reporter fetch the statistics data from all opened channels, fill it
    in a buffer and send it to mlx5_hv_vhca_write_agent.
    
    As the stats layer should include some metadata per block (sequence and
    offset), the HV VHCA layer shall modify the buffer before actually send it
    over block 1.
    
    Signed-off-by: Eran Ben Elisha <eranbe@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
    Signed-off-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/lib/hv_vhca.h b/drivers/net/ethernet/mellanox/mlx5/core/lib/hv_vhca.h
index 984e7ad7cde4..4bad6a5fde56 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/lib/hv_vhca.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lib/hv_vhca.h
@@ -13,6 +13,7 @@ struct mlx5_hv_vhca_control_block;
 
 enum mlx5_hv_vhca_agent_type {
 	MLX5_HV_VHCA_AGENT_CONTROL = 0,
+	MLX5_HV_VHCA_AGENT_STATS   = 1,
 	MLX5_HV_VHCA_AGENT_MAX = 32,
 };
 

commit 29ddad43166db232955e686758e6fc23d97e3a6a
Author: Eran Ben Elisha <eranbe@mellanox.com>
Date:   Thu Aug 22 05:05:56 2019 +0000

    net/mlx5: Add HV VHCA control agent
    
    Control agent is responsible over of the control block (ID 0). It should
    update the PF via this block about every capability change. In addition,
    upon block 0 invalidate, it should activate all other supported agents
    with data requests from the PF.
    
    Upon agent create/destroy, the invalidate callback of the control agent
    is being called in order to update the PF driver about this change.
    
    The control agent is an integral part of HV VHCA and will be created
    and destroy as part of the HV VHCA init/cleanup flow.
    
    Signed-off-by: Eran Ben Elisha <eranbe@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
    Signed-off-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/lib/hv_vhca.h b/drivers/net/ethernet/mellanox/mlx5/core/lib/hv_vhca.h
index cdf13039489c..984e7ad7cde4 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/lib/hv_vhca.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lib/hv_vhca.h
@@ -12,6 +12,7 @@ struct mlx5_hv_vhca;
 struct mlx5_hv_vhca_control_block;
 
 enum mlx5_hv_vhca_agent_type {
+	MLX5_HV_VHCA_AGENT_CONTROL = 0,
 	MLX5_HV_VHCA_AGENT_MAX = 32,
 };
 

commit 87175120defd2907d42592653c35feea9de0437a
Author: Eran Ben Elisha <eranbe@mellanox.com>
Date:   Thu Aug 22 05:05:51 2019 +0000

    net/mlx5: Add HV VHCA infrastructure
    
    HV VHCA is a layer which provides PF to VF communication channel based on
    HyperV PCI config channel. It implements Mellanox's Inter VHCA control
    communication protocol. The protocol contains control block in order to
    pass messages between the PF and VF drivers, and data blocks in order to
    pass actual data.
    
    The infrastructure is agent based. Each agent will be responsible of
    contiguous buffer blocks in the VHCA config space. This infrastructure will
    bind agents to their blocks, and those agents can only access read/write
    the buffer blocks assigned to them. Each agent will provide three
    callbacks (control, invalidate, cleanup). Control will be invoked when
    block-0 is invalidated with a command that concerns this agent. Invalidate
    callback will be invoked if one of the blocks assigned to this agent was
    invalidated. Cleanup will be invoked before the agent is being freed in
    order to clean all of its open resources or deferred works.
    
    Block-0 serves as the control block. All execution commands from the PF
    will be written by the PF over this block. VF will ack on those by
    writing on block-0 as well. Its format is described by struct
    mlx5_hv_vhca_control_block layout.
    
    Signed-off-by: Eran Ben Elisha <eranbe@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
    Signed-off-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/lib/hv_vhca.h b/drivers/net/ethernet/mellanox/mlx5/core/lib/hv_vhca.h
new file mode 100644
index 000000000000..cdf13039489c
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lib/hv_vhca.h
@@ -0,0 +1,102 @@
+/* SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB */
+/* Copyright (c) 2019 Mellanox Technologies. */
+
+#ifndef __LIB_HV_VHCA_H__
+#define __LIB_HV_VHCA_H__
+
+#include "en.h"
+#include "lib/hv.h"
+
+struct mlx5_hv_vhca_agent;
+struct mlx5_hv_vhca;
+struct mlx5_hv_vhca_control_block;
+
+enum mlx5_hv_vhca_agent_type {
+	MLX5_HV_VHCA_AGENT_MAX = 32,
+};
+
+#if IS_ENABLED(CONFIG_PCI_HYPERV_INTERFACE)
+
+struct mlx5_hv_vhca_control_block {
+	u32     capabilities;
+	u32     control;
+	u16     command;
+	u16     command_ack;
+	u16     version;
+	u16     rings;
+	u32     reserved1[28];
+};
+
+struct mlx5_hv_vhca *mlx5_hv_vhca_create(struct mlx5_core_dev *dev);
+void mlx5_hv_vhca_destroy(struct mlx5_hv_vhca *hv_vhca);
+int mlx5_hv_vhca_init(struct mlx5_hv_vhca *hv_vhca);
+void mlx5_hv_vhca_cleanup(struct mlx5_hv_vhca *hv_vhca);
+void mlx5_hv_vhca_invalidate(void *context, u64 block_mask);
+
+struct mlx5_hv_vhca_agent *
+mlx5_hv_vhca_agent_create(struct mlx5_hv_vhca *hv_vhca,
+			  enum mlx5_hv_vhca_agent_type type,
+			  void (*control)(struct mlx5_hv_vhca_agent*,
+					  struct mlx5_hv_vhca_control_block *block),
+			  void (*invalidate)(struct mlx5_hv_vhca_agent*,
+					     u64 block_mask),
+			  void (*cleanup)(struct mlx5_hv_vhca_agent *agent),
+			  void *context);
+
+void mlx5_hv_vhca_agent_destroy(struct mlx5_hv_vhca_agent *agent);
+int mlx5_hv_vhca_agent_write(struct mlx5_hv_vhca_agent *agent,
+			     void *buf, int len);
+void *mlx5_hv_vhca_agent_priv(struct mlx5_hv_vhca_agent *agent);
+
+#else
+
+static inline struct mlx5_hv_vhca *
+mlx5_hv_vhca_create(struct mlx5_core_dev *dev)
+{
+	return NULL;
+}
+
+static inline void mlx5_hv_vhca_destroy(struct mlx5_hv_vhca *hv_vhca)
+{
+}
+
+static inline int mlx5_hv_vhca_init(struct mlx5_hv_vhca *hv_vhca)
+{
+	return 0;
+}
+
+static inline void mlx5_hv_vhca_cleanup(struct mlx5_hv_vhca *hv_vhca)
+{
+}
+
+static inline void mlx5_hv_vhca_invalidate(void *context,
+					   u64 block_mask)
+{
+}
+
+static inline struct mlx5_hv_vhca_agent *
+mlx5_hv_vhca_agent_create(struct mlx5_hv_vhca *hv_vhca,
+			  enum mlx5_hv_vhca_agent_type type,
+			  void (*control)(struct mlx5_hv_vhca_agent*,
+					  struct mlx5_hv_vhca_control_block *block),
+			  void (*invalidate)(struct mlx5_hv_vhca_agent*,
+					     u64 block_mask),
+			  void (*cleanup)(struct mlx5_hv_vhca_agent *agent),
+			  void *context)
+{
+	return NULL;
+}
+
+static inline void mlx5_hv_vhca_agent_destroy(struct mlx5_hv_vhca_agent *agent)
+{
+}
+
+static inline int
+mlx5_hv_vhca_write_agent(struct mlx5_hv_vhca_agent *agent,
+			 void *buf, int len)
+{
+	return 0;
+}
+#endif
+
+#endif /* __LIB_HV_VHCA_H__ */
