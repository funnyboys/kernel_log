commit 17f54a3bf540690ac4b6f9e9e6d69fc9baf465d9
Author: Igor Russkikh <Igor.Russkikh@aquantia.com>
Date:   Wed Jun 26 12:35:40 2019 +0000

    net: aquantia: make all files GPL-2.0-only
    
    It was noticed some files had -or-later, however overall driver has
    -only license. Clean this up.
    
    Signed-off-by: Igor Russkikh <igor.russkikh@aquantia.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_drvinfo.c b/drivers/net/ethernet/aquantia/atlantic/aq_drvinfo.c
index adad6a7acabe..6da65099047d 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_drvinfo.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_drvinfo.c
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
+// SPDX-License-Identifier: GPL-2.0-only
 /* Copyright (C) 2014-2019 aQuantia Corporation. */
 
 /* File aq_drvinfo.c: Definition of common code for firmware info in sys.*/

commit 70610c922bae2f3f974eef955ef254defb7755ce
Author: Kefeng Wang <wangkefeng.wang@huawei.com>
Date:   Thu May 9 23:32:35 2019 +0800

    net: aquantia: fix undefined devm_hwmon_device_register_with_info reference
    
    drivers/net/ethernet/aquantia/atlantic/aq_drvinfo.o: In function `aq_drvinfo_init':
    aq_drvinfo.c:(.text+0xe8): undefined reference to `devm_hwmon_device_register_with_info'
    
    Fix it by using #if IS_REACHABLE(CONFIG_HWMON).
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_drvinfo.c b/drivers/net/ethernet/aquantia/atlantic/aq_drvinfo.c
index f5a92b2a5cd6..adad6a7acabe 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_drvinfo.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_drvinfo.c
@@ -13,6 +13,7 @@
 
 #include "aq_drvinfo.h"
 
+#if IS_REACHABLE(CONFIG_HWMON)
 static int aq_hwmon_read(struct device *dev, enum hwmon_sensor_types type,
 			 u32 attr, int channel, long *value)
 {
@@ -123,3 +124,7 @@ int aq_drvinfo_init(struct net_device *ndev)
 
 	return err;
 }
+
+#else
+int aq_drvinfo_init(struct net_device *ndev) { return 0; }
+#endif

commit 4c0131539fc0addeb2f44e9ebe4920dbc4ad408c
Author: Yana Esina <yana.esina@aquantia.com>
Date:   Mon Apr 29 10:04:38 2019 +0000

    net: aquantia: implement hwmon api for chip temperature
    
    Added support for hwmon api to fetch out chip temperature
    
    Signed-off-by: Yana Esina <yana.esina@aquantia.com>
    Signed-off-by: Nikita Danilov <nikita.danilov@aquantia.com>
    Signed-off-by: Igor Russkikh <igor.russkikh@aquantia.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_drvinfo.c b/drivers/net/ethernet/aquantia/atlantic/aq_drvinfo.c
new file mode 100644
index 000000000000..f5a92b2a5cd6
--- /dev/null
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_drvinfo.c
@@ -0,0 +1,125 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/* Copyright (C) 2014-2019 aQuantia Corporation. */
+
+/* File aq_drvinfo.c: Definition of common code for firmware info in sys.*/
+
+#include <linux/init.h>
+#include <linux/kobject.h>
+#include <linux/module.h>
+#include <linux/stat.h>
+#include <linux/string.h>
+#include <linux/hwmon.h>
+#include <linux/uaccess.h>
+
+#include "aq_drvinfo.h"
+
+static int aq_hwmon_read(struct device *dev, enum hwmon_sensor_types type,
+			 u32 attr, int channel, long *value)
+{
+	struct aq_nic_s *aq_nic = dev_get_drvdata(dev);
+	int temp;
+	int err;
+
+	if (!aq_nic)
+		return -EIO;
+
+	if (type != hwmon_temp)
+		return -EOPNOTSUPP;
+
+	if (!aq_nic->aq_fw_ops->get_phy_temp)
+		return -EOPNOTSUPP;
+
+	switch (attr) {
+	case hwmon_temp_input:
+		err = aq_nic->aq_fw_ops->get_phy_temp(aq_nic->aq_hw, &temp);
+		*value = temp;
+		return err;
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+static int aq_hwmon_read_string(struct device *dev,
+				enum hwmon_sensor_types type,
+				u32 attr, int channel, const char **str)
+{
+	struct aq_nic_s *aq_nic = dev_get_drvdata(dev);
+
+	if (!aq_nic)
+		return -EIO;
+
+	if (type != hwmon_temp)
+		return -EOPNOTSUPP;
+
+	if (!aq_nic->aq_fw_ops->get_phy_temp)
+		return -EOPNOTSUPP;
+
+	switch (attr) {
+	case hwmon_temp_label:
+		*str = "PHY Temperature";
+		return 0;
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+static umode_t aq_hwmon_is_visible(const void *data,
+				   enum hwmon_sensor_types type,
+				   u32 attr, int channel)
+{
+	if (type != hwmon_temp)
+		return 0;
+
+	switch (attr) {
+	case hwmon_temp_input:
+	case hwmon_temp_label:
+		return 0444;
+	default:
+		return 0;
+	}
+}
+
+static const struct hwmon_ops aq_hwmon_ops = {
+	.is_visible = aq_hwmon_is_visible,
+	.read = aq_hwmon_read,
+	.read_string = aq_hwmon_read_string,
+};
+
+static u32 aq_hwmon_temp_config[] = {
+	HWMON_T_INPUT | HWMON_T_LABEL,
+	0,
+};
+
+static const struct hwmon_channel_info aq_hwmon_temp = {
+	.type = hwmon_temp,
+	.config = aq_hwmon_temp_config,
+};
+
+static const struct hwmon_channel_info *aq_hwmon_info[] = {
+	&aq_hwmon_temp,
+	NULL,
+};
+
+static const struct hwmon_chip_info aq_hwmon_chip_info = {
+	.ops = &aq_hwmon_ops,
+	.info = aq_hwmon_info,
+};
+
+int aq_drvinfo_init(struct net_device *ndev)
+{
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+	struct device *dev = &aq_nic->pdev->dev;
+	struct device *hwmon_dev;
+	int err = 0;
+
+	hwmon_dev = devm_hwmon_device_register_with_info(dev,
+							 ndev->name,
+							 aq_nic,
+							 &aq_hwmon_chip_info,
+							 NULL);
+
+	if (IS_ERR(hwmon_dev))
+		err = PTR_ERR(hwmon_dev);
+
+	return err;
+}
