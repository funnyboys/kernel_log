commit 7f4d2537f0b9630dbe1a7d7c4ea1b9479f4451e9
Author: Leon Romanovsky <leonro@mellanox.com>
Date:   Mon Feb 24 10:53:06 2020 +0200

    net/amd: Remove useless driver version
    
    Convert AMD drivers to respect universal linux kernel version.
    
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 0f3b743425e8..7a1286f8e983 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -84,9 +84,8 @@ Revision History:
 
 #include "amd8111e.h"
 #define MODULE_NAME	"amd8111e"
-#define MODULE_VERS	"3.0.7"
 MODULE_AUTHOR("Advanced Micro Devices, Inc.");
-MODULE_DESCRIPTION ("AMD8111 based 10/100 Ethernet Controller. Driver Version "MODULE_VERS);
+MODULE_DESCRIPTION("AMD8111 based 10/100 Ethernet Controller.");
 MODULE_LICENSE("GPL");
 module_param_array(speed_duplex, int, NULL, 0);
 MODULE_PARM_DESC(speed_duplex, "Set device speed and duplex modes, 0: Auto Negotiate, 1: 10Mbps Half Duplex, 2: 10Mbps Full Duplex, 3: 100Mbps Half Duplex, 4: 100Mbps Full Duplex");
@@ -1366,7 +1365,6 @@ static void amd8111e_get_drvinfo(struct net_device *dev,
 	struct amd8111e_priv *lp = netdev_priv(dev);
 	struct pci_dev *pci_dev = lp->pci_dev;
 	strlcpy(info->driver, MODULE_NAME, sizeof(info->driver));
-	strlcpy(info->version, MODULE_VERS, sizeof(info->version));
 	snprintf(info->fw_version, sizeof(info->fw_version),
 		"%u", chip_version);
 	strlcpy(info->bus_info, pci_name(pci_dev), sizeof(info->bus_info));
@@ -1875,7 +1873,6 @@ static int amd8111e_probe_one(struct pci_dev *pdev,
 
 	/*  display driver and device information */
     	chip_version = (readl(lp->mmio + CHIPID) & 0xf0000000)>>28;
-	dev_info(&pdev->dev, "AMD-8111e Driver Version: %s\n", MODULE_VERS);
 	dev_info(&pdev->dev, "[ Rev %x ] PCI 10/100BaseT Ethernet %pM\n",
 		 chip_version, dev->dev_addr);
 	if (lp->ext_phy_id)

commit 0290bd291cc0e0488e35e66bf39efcd7d9d9122b
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Tue Dec 10 09:23:51 2019 -0500

    netdev: pass the stuck queue to the timeout handler
    
    This allows incrementing the correct timeout statistic without any mess.
    Down the road, devices can learn to reset just the specific queue.
    
    The patch was generated with the following script:
    
    use strict;
    use warnings;
    
    our $^I = '.bak';
    
    my @work = (
    ["arch/m68k/emu/nfeth.c", "nfeth_tx_timeout"],
    ["arch/um/drivers/net_kern.c", "uml_net_tx_timeout"],
    ["arch/um/drivers/vector_kern.c", "vector_net_tx_timeout"],
    ["arch/xtensa/platforms/iss/network.c", "iss_net_tx_timeout"],
    ["drivers/char/pcmcia/synclink_cs.c", "hdlcdev_tx_timeout"],
    ["drivers/infiniband/ulp/ipoib/ipoib_main.c", "ipoib_timeout"],
    ["drivers/infiniband/ulp/ipoib/ipoib_main.c", "ipoib_timeout"],
    ["drivers/message/fusion/mptlan.c", "mpt_lan_tx_timeout"],
    ["drivers/misc/sgi-xp/xpnet.c", "xpnet_dev_tx_timeout"],
    ["drivers/net/appletalk/cops.c", "cops_timeout"],
    ["drivers/net/arcnet/arcdevice.h", "arcnet_timeout"],
    ["drivers/net/arcnet/arcnet.c", "arcnet_timeout"],
    ["drivers/net/arcnet/com20020.c", "arcnet_timeout"],
    ["drivers/net/ethernet/3com/3c509.c", "el3_tx_timeout"],
    ["drivers/net/ethernet/3com/3c515.c", "corkscrew_timeout"],
    ["drivers/net/ethernet/3com/3c574_cs.c", "el3_tx_timeout"],
    ["drivers/net/ethernet/3com/3c589_cs.c", "el3_tx_timeout"],
    ["drivers/net/ethernet/3com/3c59x.c", "vortex_tx_timeout"],
    ["drivers/net/ethernet/3com/3c59x.c", "vortex_tx_timeout"],
    ["drivers/net/ethernet/3com/typhoon.c", "typhoon_tx_timeout"],
    ["drivers/net/ethernet/8390/8390.h", "ei_tx_timeout"],
    ["drivers/net/ethernet/8390/8390.h", "eip_tx_timeout"],
    ["drivers/net/ethernet/8390/8390.c", "ei_tx_timeout"],
    ["drivers/net/ethernet/8390/8390p.c", "eip_tx_timeout"],
    ["drivers/net/ethernet/8390/ax88796.c", "ax_ei_tx_timeout"],
    ["drivers/net/ethernet/8390/axnet_cs.c", "axnet_tx_timeout"],
    ["drivers/net/ethernet/8390/etherh.c", "__ei_tx_timeout"],
    ["drivers/net/ethernet/8390/hydra.c", "__ei_tx_timeout"],
    ["drivers/net/ethernet/8390/mac8390.c", "__ei_tx_timeout"],
    ["drivers/net/ethernet/8390/mcf8390.c", "__ei_tx_timeout"],
    ["drivers/net/ethernet/8390/lib8390.c", "__ei_tx_timeout"],
    ["drivers/net/ethernet/8390/ne2k-pci.c", "ei_tx_timeout"],
    ["drivers/net/ethernet/8390/pcnet_cs.c", "ei_tx_timeout"],
    ["drivers/net/ethernet/8390/smc-ultra.c", "ei_tx_timeout"],
    ["drivers/net/ethernet/8390/wd.c", "ei_tx_timeout"],
    ["drivers/net/ethernet/8390/zorro8390.c", "__ei_tx_timeout"],
    ["drivers/net/ethernet/adaptec/starfire.c", "tx_timeout"],
    ["drivers/net/ethernet/agere/et131x.c", "et131x_tx_timeout"],
    ["drivers/net/ethernet/allwinner/sun4i-emac.c", "emac_timeout"],
    ["drivers/net/ethernet/alteon/acenic.c", "ace_watchdog"],
    ["drivers/net/ethernet/amazon/ena/ena_netdev.c", "ena_tx_timeout"],
    ["drivers/net/ethernet/amd/7990.h", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/7990.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/a2065.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/am79c961a.c", "am79c961_timeout"],
    ["drivers/net/ethernet/amd/amd8111e.c", "amd8111e_tx_timeout"],
    ["drivers/net/ethernet/amd/ariadne.c", "ariadne_tx_timeout"],
    ["drivers/net/ethernet/amd/atarilance.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/au1000_eth.c", "au1000_tx_timeout"],
    ["drivers/net/ethernet/amd/declance.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/lance.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/mvme147.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/ni65.c", "ni65_timeout"],
    ["drivers/net/ethernet/amd/nmclan_cs.c", "mace_tx_timeout"],
    ["drivers/net/ethernet/amd/pcnet32.c", "pcnet32_tx_timeout"],
    ["drivers/net/ethernet/amd/sunlance.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/xgbe/xgbe-drv.c", "xgbe_tx_timeout"],
    ["drivers/net/ethernet/apm/xgene-v2/main.c", "xge_timeout"],
    ["drivers/net/ethernet/apm/xgene/xgene_enet_main.c", "xgene_enet_timeout"],
    ["drivers/net/ethernet/apple/macmace.c", "mace_tx_timeout"],
    ["drivers/net/ethernet/atheros/ag71xx.c", "ag71xx_tx_timeout"],
    ["drivers/net/ethernet/atheros/alx/main.c", "alx_tx_timeout"],
    ["drivers/net/ethernet/atheros/atl1c/atl1c_main.c", "atl1c_tx_timeout"],
    ["drivers/net/ethernet/atheros/atl1e/atl1e_main.c", "atl1e_tx_timeout"],
    ["drivers/net/ethernet/atheros/atlx/atl.c", "atlx_tx_timeout"],
    ["drivers/net/ethernet/atheros/atlx/atl1.c", "atlx_tx_timeout"],
    ["drivers/net/ethernet/atheros/atlx/atl2.c", "atl2_tx_timeout"],
    ["drivers/net/ethernet/broadcom/b44.c", "b44_tx_timeout"],
    ["drivers/net/ethernet/broadcom/bcmsysport.c", "bcm_sysport_tx_timeout"],
    ["drivers/net/ethernet/broadcom/bnx2.c", "bnx2_tx_timeout"],
    ["drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h", "bnx2x_tx_timeout"],
    ["drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c", "bnx2x_tx_timeout"],
    ["drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c", "bnx2x_tx_timeout"],
    ["drivers/net/ethernet/broadcom/bnxt/bnxt.c", "bnxt_tx_timeout"],
    ["drivers/net/ethernet/broadcom/genet/bcmgenet.c", "bcmgenet_timeout"],
    ["drivers/net/ethernet/broadcom/sb1250-mac.c", "sbmac_tx_timeout"],
    ["drivers/net/ethernet/broadcom/tg3.c", "tg3_tx_timeout"],
    ["drivers/net/ethernet/calxeda/xgmac.c", "xgmac_tx_timeout"],
    ["drivers/net/ethernet/cavium/liquidio/lio_main.c", "liquidio_tx_timeout"],
    ["drivers/net/ethernet/cavium/liquidio/lio_vf_main.c", "liquidio_tx_timeout"],
    ["drivers/net/ethernet/cavium/liquidio/lio_vf_rep.c", "lio_vf_rep_tx_timeout"],
    ["drivers/net/ethernet/cavium/thunder/nicvf_main.c", "nicvf_tx_timeout"],
    ["drivers/net/ethernet/cirrus/cs89x0.c", "net_timeout"],
    ["drivers/net/ethernet/cisco/enic/enic_main.c", "enic_tx_timeout"],
    ["drivers/net/ethernet/cisco/enic/enic_main.c", "enic_tx_timeout"],
    ["drivers/net/ethernet/cortina/gemini.c", "gmac_tx_timeout"],
    ["drivers/net/ethernet/davicom/dm9000.c", "dm9000_timeout"],
    ["drivers/net/ethernet/dec/tulip/de2104x.c", "de_tx_timeout"],
    ["drivers/net/ethernet/dec/tulip/tulip_core.c", "tulip_tx_timeout"],
    ["drivers/net/ethernet/dec/tulip/winbond-840.c", "tx_timeout"],
    ["drivers/net/ethernet/dlink/dl2k.c", "rio_tx_timeout"],
    ["drivers/net/ethernet/dlink/sundance.c", "tx_timeout"],
    ["drivers/net/ethernet/emulex/benet/be_main.c", "be_tx_timeout"],
    ["drivers/net/ethernet/ethoc.c", "ethoc_tx_timeout"],
    ["drivers/net/ethernet/faraday/ftgmac100.c", "ftgmac100_tx_timeout"],
    ["drivers/net/ethernet/fealnx.c", "fealnx_tx_timeout"],
    ["drivers/net/ethernet/freescale/dpaa/dpaa_eth.c", "dpaa_tx_timeout"],
    ["drivers/net/ethernet/freescale/fec_main.c", "fec_timeout"],
    ["drivers/net/ethernet/freescale/fec_mpc52xx.c", "mpc52xx_fec_tx_timeout"],
    ["drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c", "fs_timeout"],
    ["drivers/net/ethernet/freescale/gianfar.c", "gfar_timeout"],
    ["drivers/net/ethernet/freescale/ucc_geth.c", "ucc_geth_timeout"],
    ["drivers/net/ethernet/fujitsu/fmvj18x_cs.c", "fjn_tx_timeout"],
    ["drivers/net/ethernet/google/gve/gve_main.c", "gve_tx_timeout"],
    ["drivers/net/ethernet/hisilicon/hip04_eth.c", "hip04_timeout"],
    ["drivers/net/ethernet/hisilicon/hix5hd2_gmac.c", "hix5hd2_net_timeout"],
    ["drivers/net/ethernet/hisilicon/hns/hns_enet.c", "hns_nic_net_timeout"],
    ["drivers/net/ethernet/hisilicon/hns3/hns3_enet.c", "hns3_nic_net_timeout"],
    ["drivers/net/ethernet/huawei/hinic/hinic_main.c", "hinic_tx_timeout"],
    ["drivers/net/ethernet/i825xx/82596.c", "i596_tx_timeout"],
    ["drivers/net/ethernet/i825xx/ether1.c", "ether1_timeout"],
    ["drivers/net/ethernet/i825xx/lib82596.c", "i596_tx_timeout"],
    ["drivers/net/ethernet/i825xx/sun3_82586.c", "sun3_82586_timeout"],
    ["drivers/net/ethernet/ibm/ehea/ehea_main.c", "ehea_tx_watchdog"],
    ["drivers/net/ethernet/ibm/emac/core.c", "emac_tx_timeout"],
    ["drivers/net/ethernet/ibm/emac/core.c", "emac_tx_timeout"],
    ["drivers/net/ethernet/ibm/ibmvnic.c", "ibmvnic_tx_timeout"],
    ["drivers/net/ethernet/intel/e100.c", "e100_tx_timeout"],
    ["drivers/net/ethernet/intel/e1000/e1000_main.c", "e1000_tx_timeout"],
    ["drivers/net/ethernet/intel/e1000e/netdev.c", "e1000_tx_timeout"],
    ["drivers/net/ethernet/intel/fm10k/fm10k_netdev.c", "fm10k_tx_timeout"],
    ["drivers/net/ethernet/intel/i40e/i40e_main.c", "i40e_tx_timeout"],
    ["drivers/net/ethernet/intel/iavf/iavf_main.c", "iavf_tx_timeout"],
    ["drivers/net/ethernet/intel/ice/ice_main.c", "ice_tx_timeout"],
    ["drivers/net/ethernet/intel/ice/ice_main.c", "ice_tx_timeout"],
    ["drivers/net/ethernet/intel/igb/igb_main.c", "igb_tx_timeout"],
    ["drivers/net/ethernet/intel/igbvf/netdev.c", "igbvf_tx_timeout"],
    ["drivers/net/ethernet/intel/ixgb/ixgb_main.c", "ixgb_tx_timeout"],
    ["drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c", "adapter->netdev->netdev_ops->ndo_tx_timeout(adapter->netdev);"],
    ["drivers/net/ethernet/intel/ixgbe/ixgbe_main.c", "ixgbe_tx_timeout"],
    ["drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c", "ixgbevf_tx_timeout"],
    ["drivers/net/ethernet/jme.c", "jme_tx_timeout"],
    ["drivers/net/ethernet/korina.c", "korina_tx_timeout"],
    ["drivers/net/ethernet/lantiq_etop.c", "ltq_etop_tx_timeout"],
    ["drivers/net/ethernet/marvell/mv643xx_eth.c", "mv643xx_eth_tx_timeout"],
    ["drivers/net/ethernet/marvell/pxa168_eth.c", "pxa168_eth_tx_timeout"],
    ["drivers/net/ethernet/marvell/skge.c", "skge_tx_timeout"],
    ["drivers/net/ethernet/marvell/sky2.c", "sky2_tx_timeout"],
    ["drivers/net/ethernet/marvell/sky2.c", "sky2_tx_timeout"],
    ["drivers/net/ethernet/mediatek/mtk_eth_soc.c", "mtk_tx_timeout"],
    ["drivers/net/ethernet/mellanox/mlx4/en_netdev.c", "mlx4_en_tx_timeout"],
    ["drivers/net/ethernet/mellanox/mlx4/en_netdev.c", "mlx4_en_tx_timeout"],
    ["drivers/net/ethernet/mellanox/mlx5/core/en_main.c", "mlx5e_tx_timeout"],
    ["drivers/net/ethernet/micrel/ks8842.c", "ks8842_tx_timeout"],
    ["drivers/net/ethernet/micrel/ksz884x.c", "netdev_tx_timeout"],
    ["drivers/net/ethernet/microchip/enc28j60.c", "enc28j60_tx_timeout"],
    ["drivers/net/ethernet/microchip/encx24j600.c", "encx24j600_tx_timeout"],
    ["drivers/net/ethernet/natsemi/sonic.h", "sonic_tx_timeout"],
    ["drivers/net/ethernet/natsemi/sonic.c", "sonic_tx_timeout"],
    ["drivers/net/ethernet/natsemi/jazzsonic.c", "sonic_tx_timeout"],
    ["drivers/net/ethernet/natsemi/macsonic.c", "sonic_tx_timeout"],
    ["drivers/net/ethernet/natsemi/natsemi.c", "ns_tx_timeout"],
    ["drivers/net/ethernet/natsemi/ns83820.c", "ns83820_tx_timeout"],
    ["drivers/net/ethernet/natsemi/xtsonic.c", "sonic_tx_timeout"],
    ["drivers/net/ethernet/neterion/s2io.h", "s2io_tx_watchdog"],
    ["drivers/net/ethernet/neterion/s2io.c", "s2io_tx_watchdog"],
    ["drivers/net/ethernet/neterion/vxge/vxge-main.c", "vxge_tx_watchdog"],
    ["drivers/net/ethernet/netronome/nfp/nfp_net_common.c", "nfp_net_tx_timeout"],
    ["drivers/net/ethernet/nvidia/forcedeth.c", "nv_tx_timeout"],
    ["drivers/net/ethernet/nvidia/forcedeth.c", "nv_tx_timeout"],
    ["drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c", "pch_gbe_tx_timeout"],
    ["drivers/net/ethernet/packetengines/hamachi.c", "hamachi_tx_timeout"],
    ["drivers/net/ethernet/packetengines/yellowfin.c", "yellowfin_tx_timeout"],
    ["drivers/net/ethernet/pensando/ionic/ionic_lif.c", "ionic_tx_timeout"],
    ["drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c", "netxen_tx_timeout"],
    ["drivers/net/ethernet/qlogic/qla3xxx.c", "ql3xxx_tx_timeout"],
    ["drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c", "qlcnic_tx_timeout"],
    ["drivers/net/ethernet/qualcomm/emac/emac.c", "emac_tx_timeout"],
    ["drivers/net/ethernet/qualcomm/qca_spi.c", "qcaspi_netdev_tx_timeout"],
    ["drivers/net/ethernet/qualcomm/qca_uart.c", "qcauart_netdev_tx_timeout"],
    ["drivers/net/ethernet/rdc/r6040.c", "r6040_tx_timeout"],
    ["drivers/net/ethernet/realtek/8139cp.c", "cp_tx_timeout"],
    ["drivers/net/ethernet/realtek/8139too.c", "rtl8139_tx_timeout"],
    ["drivers/net/ethernet/realtek/atp.c", "tx_timeout"],
    ["drivers/net/ethernet/realtek/r8169_main.c", "rtl8169_tx_timeout"],
    ["drivers/net/ethernet/renesas/ravb_main.c", "ravb_tx_timeout"],
    ["drivers/net/ethernet/renesas/sh_eth.c", "sh_eth_tx_timeout"],
    ["drivers/net/ethernet/renesas/sh_eth.c", "sh_eth_tx_timeout"],
    ["drivers/net/ethernet/samsung/sxgbe/sxgbe_main.c", "sxgbe_tx_timeout"],
    ["drivers/net/ethernet/seeq/ether3.c", "ether3_timeout"],
    ["drivers/net/ethernet/seeq/sgiseeq.c", "timeout"],
    ["drivers/net/ethernet/sfc/efx.c", "efx_watchdog"],
    ["drivers/net/ethernet/sfc/falcon/efx.c", "ef4_watchdog"],
    ["drivers/net/ethernet/sgi/ioc3-eth.c", "ioc3_timeout"],
    ["drivers/net/ethernet/sgi/meth.c", "meth_tx_timeout"],
    ["drivers/net/ethernet/silan/sc92031.c", "sc92031_tx_timeout"],
    ["drivers/net/ethernet/sis/sis190.c", "sis190_tx_timeout"],
    ["drivers/net/ethernet/sis/sis900.c", "sis900_tx_timeout"],
    ["drivers/net/ethernet/smsc/epic100.c", "epic_tx_timeout"],
    ["drivers/net/ethernet/smsc/smc911x.c", "smc911x_timeout"],
    ["drivers/net/ethernet/smsc/smc9194.c", "smc_timeout"],
    ["drivers/net/ethernet/smsc/smc91c92_cs.c", "smc_tx_timeout"],
    ["drivers/net/ethernet/smsc/smc91x.c", "smc_timeout"],
    ["drivers/net/ethernet/stmicro/stmmac/stmmac_main.c", "stmmac_tx_timeout"],
    ["drivers/net/ethernet/sun/cassini.c", "cas_tx_timeout"],
    ["drivers/net/ethernet/sun/ldmvsw.c", "sunvnet_tx_timeout_common"],
    ["drivers/net/ethernet/sun/niu.c", "niu_tx_timeout"],
    ["drivers/net/ethernet/sun/sunbmac.c", "bigmac_tx_timeout"],
    ["drivers/net/ethernet/sun/sungem.c", "gem_tx_timeout"],
    ["drivers/net/ethernet/sun/sunhme.c", "happy_meal_tx_timeout"],
    ["drivers/net/ethernet/sun/sunqe.c", "qe_tx_timeout"],
    ["drivers/net/ethernet/sun/sunvnet.c", "sunvnet_tx_timeout_common"],
    ["drivers/net/ethernet/sun/sunvnet_common.c", "sunvnet_tx_timeout_common"],
    ["drivers/net/ethernet/sun/sunvnet_common.h", "sunvnet_tx_timeout_common"],
    ["drivers/net/ethernet/synopsys/dwc-xlgmac-net.c", "xlgmac_tx_timeout"],
    ["drivers/net/ethernet/ti/cpmac.c", "cpmac_tx_timeout"],
    ["drivers/net/ethernet/ti/cpsw.c", "cpsw_ndo_tx_timeout"],
    ["drivers/net/ethernet/ti/cpsw_priv.c", "cpsw_ndo_tx_timeout"],
    ["drivers/net/ethernet/ti/cpsw_priv.h", "cpsw_ndo_tx_timeout"],
    ["drivers/net/ethernet/ti/davinci_emac.c", "emac_dev_tx_timeout"],
    ["drivers/net/ethernet/ti/netcp_core.c", "netcp_ndo_tx_timeout"],
    ["drivers/net/ethernet/ti/tlan.c", "tlan_tx_timeout"],
    ["drivers/net/ethernet/toshiba/ps3_gelic_net.h", "gelic_net_tx_timeout"],
    ["drivers/net/ethernet/toshiba/ps3_gelic_net.c", "gelic_net_tx_timeout"],
    ["drivers/net/ethernet/toshiba/ps3_gelic_wireless.c", "gelic_net_tx_timeout"],
    ["drivers/net/ethernet/toshiba/spider_net.c", "spider_net_tx_timeout"],
    ["drivers/net/ethernet/toshiba/tc35815.c", "tc35815_tx_timeout"],
    ["drivers/net/ethernet/via/via-rhine.c", "rhine_tx_timeout"],
    ["drivers/net/ethernet/wiznet/w5100.c", "w5100_tx_timeout"],
    ["drivers/net/ethernet/wiznet/w5300.c", "w5300_tx_timeout"],
    ["drivers/net/ethernet/xilinx/xilinx_emaclite.c", "xemaclite_tx_timeout"],
    ["drivers/net/ethernet/xircom/xirc2ps_cs.c", "xirc_tx_timeout"],
    ["drivers/net/fjes/fjes_main.c", "fjes_tx_retry"],
    ["drivers/net/slip/slip.c", "sl_tx_timeout"],
    ["include/linux/usb/usbnet.h", "usbnet_tx_timeout"],
    ["drivers/net/usb/aqc111.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/asix_devices.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/asix_devices.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/asix_devices.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/ax88172a.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/ax88179_178a.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/catc.c", "catc_tx_timeout"],
    ["drivers/net/usb/cdc_mbim.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/cdc_ncm.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/dm9601.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/hso.c", "hso_net_tx_timeout"],
    ["drivers/net/usb/int51x1.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/ipheth.c", "ipheth_tx_timeout"],
    ["drivers/net/usb/kaweth.c", "kaweth_tx_timeout"],
    ["drivers/net/usb/lan78xx.c", "lan78xx_tx_timeout"],
    ["drivers/net/usb/mcs7830.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/pegasus.c", "pegasus_tx_timeout"],
    ["drivers/net/usb/qmi_wwan.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/r8152.c", "rtl8152_tx_timeout"],
    ["drivers/net/usb/rndis_host.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/rtl8150.c", "rtl8150_tx_timeout"],
    ["drivers/net/usb/sierra_net.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/smsc75xx.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/smsc95xx.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/sr9700.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/sr9800.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/usbnet.c", "usbnet_tx_timeout"],
    ["drivers/net/vmxnet3/vmxnet3_drv.c", "vmxnet3_tx_timeout"],
    ["drivers/net/wan/cosa.c", "cosa_net_timeout"],
    ["drivers/net/wan/farsync.c", "fst_tx_timeout"],
    ["drivers/net/wan/fsl_ucc_hdlc.c", "uhdlc_tx_timeout"],
    ["drivers/net/wan/lmc/lmc_main.c", "lmc_driver_timeout"],
    ["drivers/net/wan/x25_asy.c", "x25_asy_timeout"],
    ["drivers/net/wimax/i2400m/netdev.c", "i2400m_tx_timeout"],
    ["drivers/net/wireless/intel/ipw2x00/ipw2100.c", "ipw2100_tx_timeout"],
    ["drivers/net/wireless/intersil/hostap/hostap_main.c", "prism2_tx_timeout"],
    ["drivers/net/wireless/intersil/hostap/hostap_main.c", "prism2_tx_timeout"],
    ["drivers/net/wireless/intersil/hostap/hostap_main.c", "prism2_tx_timeout"],
    ["drivers/net/wireless/intersil/orinoco/main.c", "orinoco_tx_timeout"],
    ["drivers/net/wireless/intersil/orinoco/orinoco_usb.c", "orinoco_tx_timeout"],
    ["drivers/net/wireless/intersil/orinoco/orinoco.h", "orinoco_tx_timeout"],
    ["drivers/net/wireless/intersil/prism54/islpci_dev.c", "islpci_eth_tx_timeout"],
    ["drivers/net/wireless/intersil/prism54/islpci_eth.c", "islpci_eth_tx_timeout"],
    ["drivers/net/wireless/intersil/prism54/islpci_eth.h", "islpci_eth_tx_timeout"],
    ["drivers/net/wireless/marvell/mwifiex/main.c", "mwifiex_tx_timeout"],
    ["drivers/net/wireless/quantenna/qtnfmac/core.c", "qtnf_netdev_tx_timeout"],
    ["drivers/net/wireless/quantenna/qtnfmac/core.h", "qtnf_netdev_tx_timeout"],
    ["drivers/net/wireless/rndis_wlan.c", "usbnet_tx_timeout"],
    ["drivers/net/wireless/wl3501_cs.c", "wl3501_tx_timeout"],
    ["drivers/net/wireless/zydas/zd1201.c", "zd1201_tx_timeout"],
    ["drivers/s390/net/qeth_core.h", "qeth_tx_timeout"],
    ["drivers/s390/net/qeth_core_main.c", "qeth_tx_timeout"],
    ["drivers/s390/net/qeth_l2_main.c", "qeth_tx_timeout"],
    ["drivers/s390/net/qeth_l2_main.c", "qeth_tx_timeout"],
    ["drivers/s390/net/qeth_l3_main.c", "qeth_tx_timeout"],
    ["drivers/s390/net/qeth_l3_main.c", "qeth_tx_timeout"],
    ["drivers/staging/ks7010/ks_wlan_net.c", "ks_wlan_tx_timeout"],
    ["drivers/staging/qlge/qlge_main.c", "qlge_tx_timeout"],
    ["drivers/staging/rtl8192e/rtl8192e/rtl_core.c", "_rtl92e_tx_timeout"],
    ["drivers/staging/rtl8192u/r8192U_core.c", "tx_timeout"],
    ["drivers/staging/unisys/visornic/visornic_main.c", "visornic_xmit_timeout"],
    ["drivers/staging/wlan-ng/p80211netdev.c", "p80211knetdev_tx_timeout"],
    ["drivers/tty/n_gsm.c", "gsm_mux_net_tx_timeout"],
    ["drivers/tty/synclink.c", "hdlcdev_tx_timeout"],
    ["drivers/tty/synclink_gt.c", "hdlcdev_tx_timeout"],
    ["drivers/tty/synclinkmp.c", "hdlcdev_tx_timeout"],
    ["net/atm/lec.c", "lec_tx_timeout"],
    ["net/bluetooth/bnep/netdev.c", "bnep_net_timeout"]
    );
    
    for my $p (@work) {
            my @pair = @$p;
            my $file = $pair[0];
            my $func = $pair[1];
            print STDERR $file , ": ", $func,"\n";
            our @ARGV = ($file);
            while (<ARGV>) {
                    if (m/($func\s*\(struct\s+net_device\s+\*[A-Za-z_]?[A-Za-z-0-9_]*)(\))/) {
                            print STDERR "found $1+$2 in $file\n";
                    }
                    if (s/($func\s*\(struct\s+net_device\s+\*[A-Za-z_]?[A-Za-z-0-9_]*)(\))/$1, unsigned int txqueue$2/) {
                            print STDERR "$func found in $file\n";
                    }
                    print;
            }
    }
    
    where the list of files and functions is simply from:
    
    git grep ndo_tx_timeout, with manual addition of headers
    in the rare cases where the function is from a header,
    then manually changing the few places which actually
    call ndo_tx_timeout.
    
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Acked-by: Heiner Kallweit <hkallweit1@gmail.com>
    Acked-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Acked-by: Shannon Nelson <snelson@pensando.io>
    Reviewed-by: Martin Habets <mhabets@solarflare.com>
    
    changes from v9:
            fixup a forward declaration
    changes from v9:
            more leftovers from v3 change
    changes from v8:
            fix up a missing direct call to timeout
            rebased on net-next
    changes from v7:
            fixup leftovers from v3 change
    changes from v6:
            fix typo in rtl driver
    changes from v5:
            add missing files (allow any net device argument name)
    changes from v4:
            add a missing driver header
    changes from v3:
            change queue # to unsigned
    Changes from v2:
            added headers
    Changes from v1:
            Fix errors found by kbuild:
            generalize the pattern a bit, to pick up
            a couple of instances missed by the previous
            version.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 573e88fc8ede..0f3b743425e8 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -1569,7 +1569,7 @@ static int amd8111e_enable_link_change(struct amd8111e_priv *lp)
  * failed or the interface is locked up. This function will reinitialize
  * the hardware.
  */
-static void amd8111e_tx_timeout(struct net_device *dev)
+static void amd8111e_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct amd8111e_priv *lp = netdev_priv(dev);
 	int err;

commit 1ccea77e2a2687cae171b7987eb44730ec8c6d5f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 15:51:43 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 13
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not see http www gnu org licenses
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details [based]
      [from] [clk] [highbank] [c] you should have received a copy of the
      gnu general public license along with this program if not see http
      www gnu org licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 355 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Jilayne Lovejoy <opensource@jilayne.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190519154041.837383322@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 145fe71fd155..573e88fc8ede 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -1,8 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 
 /* Advanced  Micro Devices Inc. AMD8111E Linux Network Driver
  * Copyright (C) 2004 Advanced Micro Devices
  *
- *
  * Copyright 2001,2002 Jeff Garzik <jgarzik@mandrakesoft.com> [ 8139cp.c,tg3.c ]
  * Copyright (C) 2001, 2002 David S. Miller (davem@redhat.com)[ tg3.c]
  * Copyright 1996-1999 Thomas Bogendoerfer [ pcnet32.c ]
@@ -12,19 +12,6 @@
  * Carsten Langgaard, carstenl@mips.com [ pcnet32.c ]
  * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
  *
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
 
 Module Name:
 

commit eaf2a47f40f01ef793d2fc50cf03d199846013ca
Merge: c829f5f52db9 62967898789d
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jan 29 21:18:54 2019 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net

commit 3afa73dd7c8b586d9d01a96063d537e1550d1287
Author: Yang Wei <albin_yang@163.com>
Date:   Sun Jan 27 23:58:25 2019 +0800

    net: amd8111e: replace dev_kfree_skb_irq by dev_consume_skb_irq
    
    dev_consume_skb_irq() should be called in amd8111e_tx() when xmit
    done. It makes drop profiles more friendly.
    
    Signed-off-by: Yang Wei <yang.wei9@zte.com.cn>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index a90080f12e67..e548c0ae2e00 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -666,7 +666,7 @@ static int amd8111e_tx(struct net_device *dev)
 			pci_unmap_single(lp->pci_dev, lp->tx_dma_addr[tx_index],
 				  	lp->tx_skbuff[tx_index]->len,
 					PCI_DMA_TODEVICE);
-			dev_kfree_skb_irq (lp->tx_skbuff[tx_index]);
+			dev_consume_skb_irq(lp->tx_skbuff[tx_index]);
 			lp->tx_skbuff[tx_index] = NULL;
 			lp->tx_dma_addr[tx_index] = 0;
 		}

commit 843ef94e3374b8c2afdff3a68270d4b09964e165
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue Jan 22 14:37:55 2019 +0000

    net: amd8111e: clean up two minor indentation issues
    
    Two statements are incorrecly indented, fix these by removing a space.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index a90080f12e67..b9632928496e 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -435,7 +435,7 @@ static int amd8111e_restart(struct net_device *dev)
 	int i,reg_val;
 
 	/* stop the chip */
-	 writel(RUN, mmio + CMD0);
+	writel(RUN, mmio + CMD0);
 
 	if(amd8111e_init_ring(dev))
 		return -ENOMEM;
@@ -1720,7 +1720,7 @@ static void amd8111e_config_ipg(struct timer_list *t)
 		writew((u32)tmp_ipg, mmio + IPG);
 		writew((u32)(tmp_ipg - IFS1_DELTA), mmio + IFS1);
 	}
-	 mod_timer(&lp->ipg_data.ipg_timer, jiffies + IPG_CONVERGE_JIFFIES);
+	mod_timer(&lp->ipg_data.ipg_timer, jiffies + IPG_CONVERGE_JIFFIES);
 	return;
 
 }

commit 4d7b44833e9a129d3220152727a19cceea3a2ac4
Author: Colin Ian King <colin.king@canonical.com>
Date:   Wed Apr 25 11:31:13 2018 +0100

    net: amd8111e: remove redundant duplicated if statement
    
    There are two identical nested if statements, the second is redundant
    and can be removed. Also clean up white space formatting.
    
    Cleans up cppcheck warning:
    drivers/net/ethernet/amd/amd8111e.c:1080: (warning) Identical inner 'if'
    condition is always true.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index c99e3e845ac0..a90080f12e67 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -1074,16 +1074,12 @@ static int amd8111e_calc_coalesce(struct net_device *dev)
 				amd8111e_set_coalesce(dev,TX_INTR_COAL);
 				coal_conf->tx_coal_type = MEDIUM_COALESCE;
 			}
-
-		}
-		else if(tx_pkt_size >= 1024){
-			if (tx_pkt_size >= 1024){
-				if(coal_conf->tx_coal_type !=  HIGH_COALESCE){
-					coal_conf->tx_timeout = 4;
-					coal_conf->tx_event_count = 8;
-					amd8111e_set_coalesce(dev,TX_INTR_COAL);
-					coal_conf->tx_coal_type = HIGH_COALESCE;
-				}
+		} else if (tx_pkt_size >= 1024) {
+			if (coal_conf->tx_coal_type != HIGH_COALESCE) {
+				coal_conf->tx_timeout = 4;
+				coal_conf->tx_event_count = 8;
+				amd8111e_set_coalesce(dev, TX_INTR_COAL);
+				coal_conf->tx_coal_type = HIGH_COALESCE;
 			}
 		}
 	}

commit 129fbeecbccdeaa4f89aaea5d1698aae44ae4b4b
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Mar 1 16:42:40 2018 +0000

    net: amd8111e: remove redundant assignment to 'tx_index'
    
    The variable tx_index is being initialized with a value that is never
    read and re-assigned a little later, hence the initialization is redundant
    and can be removed.
    
    Cleans up clang warning:
    drivers/net/ethernet/amd/amd8111e.c:652:6: warning: Value stored to
    'tx_index' during its initialization is never read
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 358f7ab77c70..c99e3e845ac0 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -649,7 +649,7 @@ static void amd8111e_free_ring(struct amd8111e_priv *lp)
 static int amd8111e_tx(struct net_device *dev)
 {
 	struct amd8111e_priv *lp = netdev_priv(dev);
-	int tx_index = lp->tx_complete_idx & TX_RING_DR_MOD_MASK;
+	int tx_index;
 	int status;
 	/* Complete all the transmit packet */
 	while (lp->tx_complete_idx != lp->tx_idx){

commit 495ad9864f17bb2f4e085f9398328d14bfdb4d88
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Oct 16 17:29:09 2017 -0700

    net: amd8111e: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Jarod Wilson <jarod@redhat.com>
    Cc: Philippe Reynes <tremyfr@gmail.com>
    Cc: netdev@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 7f22af6e37e0..358f7ab77c70 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -1669,9 +1669,9 @@ static int amd8111e_resume(struct pci_dev *pci_dev)
 	return 0;
 }
 
-static void amd8111e_config_ipg(struct net_device *dev)
+static void amd8111e_config_ipg(struct timer_list *t)
 {
-	struct amd8111e_priv *lp = netdev_priv(dev);
+	struct amd8111e_priv *lp = from_timer(lp, t, ipg_data.ipg_timer);
 	struct ipg_info *ipg_data = &lp->ipg_data;
 	void __iomem *mmio = lp->mmio;
 	unsigned int prev_col_cnt = ipg_data->col_cnt;
@@ -1883,8 +1883,7 @@ static int amd8111e_probe_one(struct pci_dev *pdev,
 
 	/* Initialize software ipg timer */
 	if(lp->options & OPTION_DYN_IPG_ENABLE){
-		setup_timer(&lp->ipg_data.ipg_timer,
-			    (void *)&amd8111e_config_ipg, (unsigned long)dev);
+		timer_setup(&lp->ipg_data.ipg_timer, amd8111e_config_ipg, 0);
 		lp->ipg_data.ipg_timer.expires = jiffies +
 						 IPG_CONVERGE_JIFFIES;
 		lp->ipg_data.ipg = DEFAULT_IPG;

commit cec55a92a98fb3205cc4f127d9b70b5a965f3bd7
Author: Allen Pais <allen.lkml@gmail.com>
Date:   Thu Sep 21 22:34:54 2017 +0530

    drivers: net: amd8111e: use setup_timer() helper.
    
    Use setup_timer function instead of initializing timer with the
        function and data fields.
    
    Signed-off-by: Allen Pais <allen.lkml@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 7b5df562f30f..7f22af6e37e0 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -1883,9 +1883,8 @@ static int amd8111e_probe_one(struct pci_dev *pdev,
 
 	/* Initialize software ipg timer */
 	if(lp->options & OPTION_DYN_IPG_ENABLE){
-		init_timer(&lp->ipg_data.ipg_timer);
-		lp->ipg_data.ipg_timer.data = (unsigned long) dev;
-		lp->ipg_data.ipg_timer.function = (void *)&amd8111e_config_ipg;
+		setup_timer(&lp->ipg_data.ipg_timer,
+			    (void *)&amd8111e_config_ipg, (unsigned long)dev);
 		lp->ipg_data.ipg_timer.expires = jiffies +
 						 IPG_CONVERGE_JIFFIES;
 		lp->ipg_data.ipg = DEFAULT_IPG;

commit c46e9907d4dcc2062f742d4e37e41a81a162fe7b
Author: Eric Dumazet <edumazet@google.com>
Date:   Sat Feb 4 15:24:54 2017 -0800

    amd8111e: add GRO support
    
    Use napi_complete_done() instead of __napi_complete() to :
    
    1) Get support of gro_flush_timeout if opt-in
    2) Not rearm interrupts for busy-polling users.
    3) use standard NAPI API.
    4) get rid of baroque code and ease maintenance.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 9595f1bc535b..7b5df562f30f 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -695,125 +695,105 @@ static int amd8111e_rx_poll(struct napi_struct *napi, int budget)
 	void __iomem *mmio = lp->mmio;
 	struct sk_buff *skb,*new_skb;
 	int min_pkt_len, status;
-	unsigned int intr0;
 	int num_rx_pkt = 0;
 	short pkt_len;
 #if AMD8111E_VLAN_TAG_USED
 	short vtag;
 #endif
-	int rx_pkt_limit = budget;
-	unsigned long flags;
 
-	if (rx_pkt_limit <= 0)
-		goto rx_not_empty;
+	while (num_rx_pkt < budget) {
+		status = le16_to_cpu(lp->rx_ring[rx_index].rx_flags);
+		if (status & OWN_BIT)
+			break;
 
-	do{
-		/* process receive packets until we use the quota.
-		 * If we own the next entry, it's a new packet. Send it up.
+		/* There is a tricky error noted by John Murphy,
+		 * <murf@perftech.com> to Russ Nelson: Even with
+		 * full-sized * buffers it's possible for a
+		 * jabber packet to use two buffers, with only
+		 * the last correctly noting the error.
 		 */
-		while(1) {
-			status = le16_to_cpu(lp->rx_ring[rx_index].rx_flags);
-			if (status & OWN_BIT)
-				break;
-
-			/* There is a tricky error noted by John Murphy,
-			 * <murf@perftech.com> to Russ Nelson: Even with
-			 * full-sized * buffers it's possible for a
-			 * jabber packet to use two buffers, with only
-			 * the last correctly noting the error.
-			 */
-			if(status & ERR_BIT) {
-				/* resetting flags */
-				lp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;
-				goto err_next_pkt;
-			}
-			/* check for STP and ENP */
-			if(!((status & STP_BIT) && (status & ENP_BIT))){
-				/* resetting flags */
-				lp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;
-				goto err_next_pkt;
-			}
-			pkt_len = le16_to_cpu(lp->rx_ring[rx_index].msg_count) - 4;
+		if (status & ERR_BIT) {
+			/* resetting flags */
+			lp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;
+			goto err_next_pkt;
+		}
+		/* check for STP and ENP */
+		if (!((status & STP_BIT) && (status & ENP_BIT))){
+			/* resetting flags */
+			lp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;
+			goto err_next_pkt;
+		}
+		pkt_len = le16_to_cpu(lp->rx_ring[rx_index].msg_count) - 4;
 
 #if AMD8111E_VLAN_TAG_USED
-			vtag = status & TT_MASK;
-			/*MAC will strip vlan tag*/
-			if (vtag != 0)
-				min_pkt_len =MIN_PKT_LEN - 4;
+		vtag = status & TT_MASK;
+		/* MAC will strip vlan tag */
+		if (vtag != 0)
+			min_pkt_len = MIN_PKT_LEN - 4;
 			else
 #endif
-				min_pkt_len =MIN_PKT_LEN;
+			min_pkt_len = MIN_PKT_LEN;
 
-			if (pkt_len < min_pkt_len) {
-				lp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;
-				lp->drv_rx_errors++;
-				goto err_next_pkt;
-			}
-			if(--rx_pkt_limit < 0)
-				goto rx_not_empty;
-			new_skb = netdev_alloc_skb(dev, lp->rx_buff_len);
-			if (!new_skb) {
-				/* if allocation fail,
-				 * ignore that pkt and go to next one
-				 */
-				lp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;
-				lp->drv_rx_errors++;
-				goto err_next_pkt;
-			}
+		if (pkt_len < min_pkt_len) {
+			lp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;
+			lp->drv_rx_errors++;
+			goto err_next_pkt;
+		}
+		new_skb = netdev_alloc_skb(dev, lp->rx_buff_len);
+		if (!new_skb) {
+			/* if allocation fail,
+			 * ignore that pkt and go to next one
+			 */
+			lp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;
+			lp->drv_rx_errors++;
+			goto err_next_pkt;
+		}
 
-			skb_reserve(new_skb, 2);
-			skb = lp->rx_skbuff[rx_index];
-			pci_unmap_single(lp->pci_dev,lp->rx_dma_addr[rx_index],
-					 lp->rx_buff_len-2, PCI_DMA_FROMDEVICE);
-			skb_put(skb, pkt_len);
-			lp->rx_skbuff[rx_index] = new_skb;
-			lp->rx_dma_addr[rx_index] = pci_map_single(lp->pci_dev,
-								   new_skb->data,
-								   lp->rx_buff_len-2,
-								   PCI_DMA_FROMDEVICE);
+		skb_reserve(new_skb, 2);
+		skb = lp->rx_skbuff[rx_index];
+		pci_unmap_single(lp->pci_dev,lp->rx_dma_addr[rx_index],
+				 lp->rx_buff_len-2, PCI_DMA_FROMDEVICE);
+		skb_put(skb, pkt_len);
+		lp->rx_skbuff[rx_index] = new_skb;
+		lp->rx_dma_addr[rx_index] = pci_map_single(lp->pci_dev,
+							   new_skb->data,
+							   lp->rx_buff_len-2,
+							   PCI_DMA_FROMDEVICE);
 
-			skb->protocol = eth_type_trans(skb, dev);
+		skb->protocol = eth_type_trans(skb, dev);
 
 #if AMD8111E_VLAN_TAG_USED
-			if (vtag == TT_VLAN_TAGGED){
-				u16 vlan_tag = le16_to_cpu(lp->rx_ring[rx_index].tag_ctrl_info);
-				__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan_tag);
-			}
-#endif
-			netif_receive_skb(skb);
-			/*COAL update rx coalescing parameters*/
-			lp->coal_conf.rx_packets++;
-			lp->coal_conf.rx_bytes += pkt_len;
-			num_rx_pkt++;
-
-		err_next_pkt:
-			lp->rx_ring[rx_index].buff_phy_addr
-				= cpu_to_le32(lp->rx_dma_addr[rx_index]);
-			lp->rx_ring[rx_index].buff_count =
-				cpu_to_le16(lp->rx_buff_len-2);
-			wmb();
-			lp->rx_ring[rx_index].rx_flags |= cpu_to_le16(OWN_BIT);
-			rx_index = (++lp->rx_idx) & RX_RING_DR_MOD_MASK;
+		if (vtag == TT_VLAN_TAGGED){
+			u16 vlan_tag = le16_to_cpu(lp->rx_ring[rx_index].tag_ctrl_info);
+			__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan_tag);
 		}
-		/* Check the interrupt status register for more packets in the
-		 * mean time. Process them since we have not used up our quota.
-		 */
-		intr0 = readl(mmio + INT0);
-		/*Ack receive packets */
-		writel(intr0 & RINT0,mmio + INT0);
+#endif
+		napi_gro_receive(napi, skb);
+		/* COAL update rx coalescing parameters */
+		lp->coal_conf.rx_packets++;
+		lp->coal_conf.rx_bytes += pkt_len;
+		num_rx_pkt++;
+
+err_next_pkt:
+		lp->rx_ring[rx_index].buff_phy_addr
+			= cpu_to_le32(lp->rx_dma_addr[rx_index]);
+		lp->rx_ring[rx_index].buff_count =
+			cpu_to_le16(lp->rx_buff_len-2);
+		wmb();
+		lp->rx_ring[rx_index].rx_flags |= cpu_to_le16(OWN_BIT);
+		rx_index = (++lp->rx_idx) & RX_RING_DR_MOD_MASK;
+	}
 
-	} while(intr0 & RINT0);
+	if (num_rx_pkt < budget && napi_complete_done(napi, num_rx_pkt)) {
+		unsigned long flags;
 
-	if (rx_pkt_limit > 0) {
 		/* Receive descriptor is empty now */
 		spin_lock_irqsave(&lp->lock, flags);
-		__napi_complete(napi);
 		writel(VAL0|RINTEN0, mmio + INTEN0);
 		writel(VAL2 | RDMD0, mmio + CMD0);
 		spin_unlock_irqrestore(&lp->lock, flags);
 	}
 
-rx_not_empty:
 	return num_rx_pkt;
 }
 

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 11cf1e3e0295..9595f1bc535b 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -87,7 +87,7 @@ Revision History:
 
 #include <asm/io.h>
 #include <asm/byteorder.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 
 #if IS_ENABLED(CONFIG_VLAN_8021Q)
 #define AMD8111E_VLAN_TAG_USED 1

commit 1435003c2c2dccad015c8b76199bc39d60343e3b
Author: Philippe Reynes <tremyfr@gmail.com>
Date:   Sat Nov 5 20:17:03 2016 +0100

    net: amd8111e: use new api ethtool_{get|set}_link_ksettings
    
    The ethtool api {get|set}_settings is deprecated.
    We move this driver to new api {get|set}_link_ksettings.
    
    Signed-off-by: Philippe Reynes <tremyfr@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 84b4ffbd084a..11cf1e3e0295 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -1421,21 +1421,23 @@ static void amd8111e_get_regs(struct net_device *dev, struct ethtool_regs *regs,
 	amd8111e_read_regs(lp, buf);
 }
 
-static int amd8111e_get_settings(struct net_device *dev, struct ethtool_cmd *ecmd)
+static int amd8111e_get_link_ksettings(struct net_device *dev,
+				       struct ethtool_link_ksettings *cmd)
 {
 	struct amd8111e_priv *lp = netdev_priv(dev);
 	spin_lock_irq(&lp->lock);
-	mii_ethtool_gset(&lp->mii_if, ecmd);
+	mii_ethtool_get_link_ksettings(&lp->mii_if, cmd);
 	spin_unlock_irq(&lp->lock);
 	return 0;
 }
 
-static int amd8111e_set_settings(struct net_device *dev, struct ethtool_cmd *ecmd)
+static int amd8111e_set_link_ksettings(struct net_device *dev,
+				       const struct ethtool_link_ksettings *cmd)
 {
 	struct amd8111e_priv *lp = netdev_priv(dev);
 	int res;
 	spin_lock_irq(&lp->lock);
-	res = mii_ethtool_sset(&lp->mii_if, ecmd);
+	res = mii_ethtool_set_link_ksettings(&lp->mii_if, cmd);
 	spin_unlock_irq(&lp->lock);
 	return res;
 }
@@ -1482,12 +1484,12 @@ static const struct ethtool_ops ops = {
 	.get_drvinfo = amd8111e_get_drvinfo,
 	.get_regs_len = amd8111e_get_regs_len,
 	.get_regs = amd8111e_get_regs,
-	.get_settings = amd8111e_get_settings,
-	.set_settings = amd8111e_set_settings,
 	.nway_reset = amd8111e_nway_reset,
 	.get_link = amd8111e_get_link,
 	.get_wol = amd8111e_get_wol,
 	.set_wol = amd8111e_set_wol,
+	.get_link_ksettings = amd8111e_get_link_ksettings,
+	.set_link_ksettings = amd8111e_set_link_ksettings,
 };
 
 /* This function handles all the  ethtool ioctls. It gives driver info,

commit 44770e1180decf9b483d9b537fdad385a4fbf462
Author: Jarod Wilson <jarod@redhat.com>
Date:   Mon Oct 17 15:54:17 2016 -0400

    ethernet: use core min/max MTU checking
    
    et131x: min_mtu 64, max_mtu 9216
    
    altera_tse: min_mtu 64, max_mtu 1500
    
    amd8111e: min_mtu 60, max_mtu 9000
    
    bnad: min_mtu 46, max_mtu 9000
    
    macb: min_mtu 68, max_mtu 1500 or 10240 depending on hardware capability
    
    xgmac: min_mtu 46, max_mtu 9000
    
    cxgb2: min_mtu 68, max_mtu 9582 (pm3393) or 9600 (vsc7326)
    
    enic: min_mtu 68, max_mtu 9000
    
    gianfar: min_mtu 50, max_mu 9586
    
    hns_enet: min_mtu 68, max_mtu 9578 (v1) or 9706 (v2)
    
    ksz884x: min_mtu 60, max_mtu 1894
    
    myri10ge: min_mtu 68, max_mtu 9000
    
    natsemi: min_mtu 64, max_mtu 2024
    
    nfp: min_mtu 68, max_mtu hardware-specific
    
    forcedeth: min_mtu 64, max_mtu 1500 or 9100, depending on hardware
    
    pch_gbe: min_mtu 46, max_mtu 10300
    
    pasemi_mac: min_mtu 64, max_mtu 9000
    
    qcaspi: min_mtu 46, max_mtu 1500
    - remove qcaspi_netdev_change_mtu as it is now redundant
    
    rocker: min_mtu 68, max_mtu 9000
    
    sxgbe: min_mtu 68, max_mtu 9000
    
    stmmac: min_mtu 46, max_mtu depends on hardware
    
    tehuti: min_mtu 60, max_mtu 16384
    - driver had no max mtu checking, but product docs say 16k jumbo packets
      are supported by the hardware
    
    netcp: min_mtu 68, max_mtu 9486
    - remove netcp_ndo_change_mtu as it is now redundant
    
    via-velocity: min_mtu 64, max_mtu 9000
    
    octeon: min_mtu 46, max_mtu 65370
    
    CC: netdev@vger.kernel.org
    CC: Mark Einon <mark.einon@gmail.com>
    CC: Vince Bridgers <vbridger@opensource.altera.com>
    CC: Rasesh Mody <rasesh.mody@qlogic.com>
    CC: Nicolas Ferre <nicolas.ferre@atmel.com>
    CC: Santosh Raspatur <santosh@chelsio.com>
    CC: Hariprasad S <hariprasad@chelsio.com>
    CC:  Christian Benvenuti <benve@cisco.com>
    CC: Sujith Sankar <ssujith@cisco.com>
    CC: Govindarajulu Varadarajan <_govind@gmx.com>
    CC: Neel Patel <neepatel@cisco.com>
    CC: Claudiu Manoil <claudiu.manoil@freescale.com>
    CC: Yisen Zhuang <yisen.zhuang@huawei.com>
    CC: Salil Mehta <salil.mehta@huawei.com>
    CC: Hyong-Youb Kim <hykim@myri.com>
    CC: Jakub Kicinski <jakub.kicinski@netronome.com>
    CC: Olof Johansson <olof@lixom.net>
    CC: Jiri Pirko <jiri@resnulli.us>
    CC: Byungho An <bh74.an@samsung.com>
    CC: Girish K S <ks.giri@samsung.com>
    CC: Vipul Pandya <vipul.pandya@samsung.com>
    CC: Giuseppe Cavallaro <peppe.cavallaro@st.com>
    CC: Alexandre Torgue <alexandre.torgue@st.com>
    CC: Andy Gospodarek <andy@greyhouse.net>
    CC: Wingman Kwok <w-kwok2@ti.com>
    CC: Murali Karicheri <m-karicheri2@ti.com>
    CC: Francois Romieu <romieu@fr.zoreil.com>
    Signed-off-by: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index f92cc97151ec..84b4ffbd084a 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -1556,9 +1556,6 @@ static int amd8111e_change_mtu(struct net_device *dev, int new_mtu)
 	struct amd8111e_priv *lp = netdev_priv(dev);
 	int err;
 
-	if ((new_mtu < AMD8111E_MIN_MTU) || (new_mtu > AMD8111E_MAX_MTU))
-		return -EINVAL;
-
 	if (!netif_running(dev)) {
 		/* new_mtu will be used
 		 * when device starts netxt time
@@ -1874,6 +1871,8 @@ static int amd8111e_probe_one(struct pci_dev *pdev,
 	dev->ethtool_ops = &ops;
 	dev->irq =pdev->irq;
 	dev->watchdog_timeo = AMD8111E_TX_TIMEOUT;
+	dev->min_mtu = AMD8111E_MIN_MTU;
+	dev->max_mtu = AMD8111E_MAX_MTU;
 	netif_napi_add(dev, &lp->napi, amd8111e_rx_poll, 32);
 
 #if AMD8111E_VLAN_TAG_USED

commit 941992d2944789641470626e9336d663236b1d28
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Mon Sep 12 10:03:34 2016 -0400

    ethernet: amd: use IS_ENABLED() instead of checking for built-in or module
    
    The IS_ENABLED() macro checks if a Kconfig symbol has been enabled either
    built-in or as a module, use that macro instead of open coding the same.
    
    Using the macro makes the code more readable by helping abstract away some
    of the Kconfig built-in and module enable details.
    
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Reviewed-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 94960055fa1f..f92cc97151ec 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -89,7 +89,7 @@ Revision History:
 #include <asm/byteorder.h>
 #include <asm/uaccess.h>
 
-#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+#if IS_ENABLED(CONFIG_VLAN_8021Q)
 #define AMD8111E_VLAN_TAG_USED 1
 #else
 #define AMD8111E_VLAN_TAG_USED 0

commit dbedd44e982d61c156337b1a3fb252b24085f8e3
Author: Joe Perches <joe@perches.com>
Date:   Fri Mar 6 20:49:12 2015 -0800

    ethernet: codespell comment spelling fixes
    
    To test a checkpatch spelling patch, I ran codespell against
    drivers/net/ethernet/.
    
    $ git ls-files drivers/net/ethernet/ | \
      while read file ; do \
        codespell -w $file; \
      done
    
    I removed a false positive in e1000_hw.h
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 4c2ae2221780..94960055fa1f 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -723,13 +723,13 @@ static int amd8111e_rx_poll(struct napi_struct *napi, int budget)
 			 * the last correctly noting the error.
 			 */
 			if(status & ERR_BIT) {
-				/* reseting flags */
+				/* resetting flags */
 				lp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;
 				goto err_next_pkt;
 			}
 			/* check for STP and ENP */
 			if(!((status & STP_BIT) && (status & ENP_BIT))){
-				/* reseting flags */
+				/* resetting flags */
 				lp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;
 				goto err_next_pkt;
 			}

commit df8a39defad46b83694ea6dd868d332976d62cc0
Author: Jiri Pirko <jiri@resnulli.us>
Date:   Tue Jan 13 17:13:44 2015 +0100

    net: rename vlan_tx_* helpers since "tx" is misleading there
    
    The same macros are used for rx as well. So rename it.
    
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 841e6558db68..4c2ae2221780 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -1299,11 +1299,11 @@ static netdev_tx_t amd8111e_start_xmit(struct sk_buff *skb,
 	lp->tx_ring[tx_index].tx_flags = 0;
 
 #if AMD8111E_VLAN_TAG_USED
-	if (vlan_tx_tag_present(skb)) {
+	if (skb_vlan_tag_present(skb)) {
 		lp->tx_ring[tx_index].tag_ctrl_cmd |=
 				cpu_to_le16(TCC_VLAN_INSERT);
 		lp->tx_ring[tx_index].tag_ctrl_info =
-				cpu_to_le16(vlan_tx_tag_get(skb));
+				cpu_to_le16(skb_vlan_tag_get(skb));
 
 	}
 #endif

commit 46c73ecc6168586c7628b87ac1d0436eca9574dd
Author: Varka Bhadram <varkab@cdac.in>
Date:   Mon Jul 14 14:09:09 2014 +0530

    ethernet: amd: fix 'foo* bar'
    
    This patch fix the 'foo*' bar with 'foo *bar' and (foo*) with (foo *).
    
    Signed-off-by: Varka Bhadram <varkab@cdac.in>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 9f8a15e3b8bb..841e6558db68 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -109,7 +109,8 @@ module_param_array(dynamic_ipg, bool, NULL, 0);
 MODULE_PARM_DESC(dynamic_ipg, "Enable or Disable dynamic IPG, 1: Enable, 0: Disable");
 
 /* This function will read the PHY registers. */
-static int amd8111e_read_phy(struct amd8111e_priv* lp, int phy_id, int reg, u32* val)
+static int amd8111e_read_phy(struct amd8111e_priv *lp,
+			     int phy_id, int reg, u32 *val)
 {
 	void __iomem *mmio = lp->mmio;
 	unsigned int reg_val;
@@ -137,7 +138,8 @@ static int amd8111e_read_phy(struct amd8111e_priv* lp, int phy_id, int reg, u32*
 }
 
 /* This function will write into PHY registers. */
-static int amd8111e_write_phy(struct amd8111e_priv* lp,int phy_id, int reg, u32 val)
+static int amd8111e_write_phy(struct amd8111e_priv *lp,
+			      int phy_id, int reg, u32 val)
 {
 	unsigned int repeat = REPEAT_CNT;
 	void __iomem *mmio = lp->mmio;
@@ -166,9 +168,9 @@ static int amd8111e_write_phy(struct amd8111e_priv* lp,int phy_id, int reg, u32
 }
 
 /* This is the mii register read function provided to the mii interface. */
-static int amd8111e_mdio_read(struct net_device * dev, int phy_id, int reg_num)
+static int amd8111e_mdio_read(struct net_device *dev, int phy_id, int reg_num)
 {
-	struct amd8111e_priv* lp = netdev_priv(dev);
+	struct amd8111e_priv *lp = netdev_priv(dev);
 	unsigned int reg_val;
 
 	amd8111e_read_phy(lp,phy_id,reg_num,&reg_val);
@@ -177,9 +179,10 @@ static int amd8111e_mdio_read(struct net_device * dev, int phy_id, int reg_num)
 }
 
 /* This is the mii register write function provided to the mii interface. */
-static void amd8111e_mdio_write(struct net_device * dev, int phy_id, int reg_num, int val)
+static void amd8111e_mdio_write(struct net_device *dev,
+				int phy_id, int reg_num, int val)
 {
-	struct amd8111e_priv* lp = netdev_priv(dev);
+	struct amd8111e_priv *lp = netdev_priv(dev);
 
 	amd8111e_write_phy(lp, phy_id, reg_num, val);
 }
@@ -231,7 +234,7 @@ static void amd8111e_set_ext_phy(struct net_device *dev)
 static int amd8111e_free_skbs(struct net_device *dev)
 {
 	struct amd8111e_priv *lp = netdev_priv(dev);
-	struct sk_buff* rx_skbuff;
+	struct sk_buff *rx_skbuff;
 	int i;
 
 	/* Freeing transmit skbs */
@@ -261,9 +264,9 @@ static int amd8111e_free_skbs(struct net_device *dev)
 /* This will set the receive buffer length corresponding
  * to the mtu size of networkinterface.
  */
-static inline void amd8111e_set_rx_buff_len(struct net_device* dev)
+static inline void amd8111e_set_rx_buff_len(struct net_device *dev)
 {
-	struct amd8111e_priv* lp = netdev_priv(dev);
+	struct amd8111e_priv *lp = netdev_priv(dev);
 	unsigned int mtu = dev->mtu;
 
 	if (mtu > ETH_DATA_LEN){
@@ -366,14 +369,14 @@ static int amd8111e_init_ring(struct net_device *dev)
 /* This function will set the interrupt coalescing according
  * to the input arguments
  */
-static int amd8111e_set_coalesce(struct net_device * dev, enum coal_mode cmod)
+static int amd8111e_set_coalesce(struct net_device *dev, enum coal_mode cmod)
 {
 	unsigned int timeout;
 	unsigned int event_count;
 
 	struct amd8111e_priv *lp = netdev_priv(dev);
 	void __iomem *mmio = lp->mmio;
-	struct amd8111e_coalesce_conf * coal_conf = &lp->coal_conf;
+	struct amd8111e_coalesce_conf *coal_conf = &lp->coal_conf;
 
 
 	switch(cmod)
@@ -502,7 +505,7 @@ static int amd8111e_restart(struct net_device *dev)
 }
 
 /* This function clears necessary the device registers. */
-static void amd8111e_init_hw_default( struct amd8111e_priv* lp)
+static void amd8111e_init_hw_default(struct amd8111e_priv *lp)
 {
 	unsigned int reg_val;
 	unsigned int logic_filter[2] ={0,};
@@ -572,7 +575,7 @@ static void amd8111e_init_hw_default( struct amd8111e_priv* lp)
 	writew(MIB_CLEAR, mmio + MIB_ADDR);
 
 	/* Clear LARF */
-	amd8111e_writeq(*(u64*)logic_filter,mmio+LADRF);
+	amd8111e_writeq(*(u64 *)logic_filter, mmio + LADRF);
 
 	/* SRAM_SIZE register */
 	reg_val = readl(mmio + SRAM_SIZE);
@@ -593,7 +596,7 @@ static void amd8111e_init_hw_default( struct amd8111e_priv* lp)
 /* This function disables the interrupt and clears all the pending
  * interrupts in INT0
  */
-static void amd8111e_disable_interrupt(struct amd8111e_priv* lp)
+static void amd8111e_disable_interrupt(struct amd8111e_priv *lp)
 {
 	u32 intr0;
 
@@ -610,7 +613,7 @@ static void amd8111e_disable_interrupt(struct amd8111e_priv* lp)
 }
 
 /* This function stops the chip. */
-static void amd8111e_stop_chip(struct amd8111e_priv* lp)
+static void amd8111e_stop_chip(struct amd8111e_priv *lp)
 {
 	writel(RUN, lp->mmio + CMD0);
 
@@ -619,7 +622,7 @@ static void amd8111e_stop_chip(struct amd8111e_priv* lp)
 }
 
 /* This function frees the  transmiter and receiver descriptor rings. */
-static void amd8111e_free_ring(struct amd8111e_priv* lp)
+static void amd8111e_free_ring(struct amd8111e_priv *lp)
 {
 	/* Free transmit and receive descriptor rings */
 	if(lp->rx_ring){
@@ -645,7 +648,7 @@ static void amd8111e_free_ring(struct amd8111e_priv* lp)
  */
 static int amd8111e_tx(struct net_device *dev)
 {
-	struct amd8111e_priv* lp = netdev_priv(dev);
+	struct amd8111e_priv *lp = netdev_priv(dev);
 	int tx_index = lp->tx_complete_idx & TX_RING_DR_MOD_MASK;
 	int status;
 	/* Complete all the transmit packet */
@@ -815,7 +818,7 @@ static int amd8111e_rx_poll(struct napi_struct *napi, int budget)
 }
 
 /* This function will indicate the link status to the kernel. */
-static int amd8111e_link_change(struct net_device* dev)
+static int amd8111e_link_change(struct net_device *dev)
 {
 	struct amd8111e_priv *lp = netdev_priv(dev);
 	int status0,speed;
@@ -979,7 +982,7 @@ static struct net_device_stats *amd8111e_get_stats(struct net_device *dev)
 static int amd8111e_calc_coalesce(struct net_device *dev)
 {
 	struct amd8111e_priv *lp = netdev_priv(dev);
-	struct amd8111e_coalesce_conf * coal_conf = &lp->coal_conf;
+	struct amd8111e_coalesce_conf *coal_conf = &lp->coal_conf;
 	int tx_pkt_rate;
 	int rx_pkt_rate;
 	int tx_data_rate;
@@ -1114,7 +1117,7 @@ static int amd8111e_calc_coalesce(struct net_device *dev)
 static irqreturn_t amd8111e_interrupt(int irq, void *dev_id)
 {
 
-	struct net_device * dev = (struct net_device *) dev_id;
+	struct net_device *dev = (struct net_device *)dev_id;
 	struct amd8111e_priv *lp = netdev_priv(dev);
 	void __iomem *mmio = lp->mmio;
 	unsigned int intr0, intren0;
@@ -1191,7 +1194,7 @@ static void amd8111e_poll(struct net_device *dev)
  * the statistics so that most recent statistics will be
  * available after the interface is down.
  */
-static int amd8111e_close(struct net_device * dev)
+static int amd8111e_close(struct net_device *dev)
 {
 	struct amd8111e_priv *lp = netdev_priv(dev);
 	netif_stop_queue(dev);
@@ -1225,7 +1228,7 @@ static int amd8111e_close(struct net_device * dev)
 /* This function opens new interface.It requests irq for the device,
  * initializes the device,buffers and descriptors, and starts the device.
  */
-static int amd8111e_open(struct net_device * dev )
+static int amd8111e_open(struct net_device *dev)
 {
 	struct amd8111e_priv *lp = netdev_priv(dev);
 
@@ -1264,7 +1267,7 @@ static int amd8111e_open(struct net_device * dev )
 /* This function checks if there is any transmit  descriptors
  * available to queue more packet.
  */
-static int amd8111e_tx_queue_avail(struct amd8111e_priv* lp )
+static int amd8111e_tx_queue_avail(struct amd8111e_priv *lp)
 {
 	int tx_index = lp->tx_idx & TX_BUFF_MOD_MASK;
 	if (lp->tx_skbuff[tx_index])
@@ -1280,7 +1283,7 @@ static int amd8111e_tx_queue_avail(struct amd8111e_priv* lp )
  * byte count, ownership to hardware etc.
  */
 static netdev_tx_t amd8111e_start_xmit(struct sk_buff *skb,
-				       struct net_device * dev)
+				       struct net_device *dev)
 {
 	struct amd8111e_priv *lp = netdev_priv(dev);
 	int tx_index;
@@ -1368,14 +1371,14 @@ static void amd8111e_set_multicast_list(struct net_device *dev)
 		/* get all multicast packet */
 		mc_filter[1] = mc_filter[0] = 0xffffffff;
 		lp->options |= OPTION_MULTICAST_ENABLE;
-		amd8111e_writeq(*(u64*)mc_filter,lp->mmio + LADRF);
+		amd8111e_writeq(*(u64 *)mc_filter, lp->mmio + LADRF);
 		return;
 	}
 	if (netdev_mc_empty(dev)) {
 		/* get only own packets */
 		mc_filter[1] = mc_filter[0] = 0;
 		lp->options &= ~OPTION_MULTICAST_ENABLE;
-		amd8111e_writeq(*(u64*)mc_filter,lp->mmio + LADRF);
+		amd8111e_writeq(*(u64 *)mc_filter, lp->mmio + LADRF);
 		/* disable promiscuous mode */
 		writel(PROM, lp->mmio + CMD2);
 		return;
@@ -1387,14 +1390,15 @@ static void amd8111e_set_multicast_list(struct net_device *dev)
 		bit_num = (ether_crc_le(ETH_ALEN, ha->addr) >> 26) & 0x3f;
 		mc_filter[bit_num >> 5] |= 1 << (bit_num & 31);
 	}
-	amd8111e_writeq(*(u64*)mc_filter,lp->mmio+ LADRF);
+	amd8111e_writeq(*(u64 *)mc_filter, lp->mmio + LADRF);
 
 	/* To eliminate PCI posting bug */
 	readl(lp->mmio + CMD2);
 
 }
 
-static void amd8111e_get_drvinfo(struct net_device* dev, struct ethtool_drvinfo *info)
+static void amd8111e_get_drvinfo(struct net_device *dev,
+				 struct ethtool_drvinfo *info)
 {
 	struct amd8111e_priv *lp = netdev_priv(dev);
 	struct pci_dev *pci_dev = lp->pci_dev;
@@ -1490,7 +1494,7 @@ static const struct ethtool_ops ops = {
  * gets/sets driver speed, gets memory mapped register values, forces
  * auto negotiation, sets/gets WOL options for ethtool application.
  */
-static int amd8111e_ioctl(struct net_device * dev , struct ifreq *ifr, int cmd)
+static int amd8111e_ioctl(struct net_device *dev , struct ifreq *ifr, int cmd)
 {
 	struct mii_ioctl_data *data = if_mii(ifr);
 	struct amd8111e_priv *lp = netdev_priv(dev);
@@ -1577,7 +1581,7 @@ static int amd8111e_change_mtu(struct net_device *dev, int new_mtu)
 	return err;
 }
 
-static int amd8111e_enable_magicpkt(struct amd8111e_priv* lp)
+static int amd8111e_enable_magicpkt(struct amd8111e_priv *lp)
 {
 	writel( VAL1|MPPLBA, lp->mmio + CMD3);
 	writel( VAL0|MPEN_SW, lp->mmio + CMD7);
@@ -1587,7 +1591,7 @@ static int amd8111e_enable_magicpkt(struct amd8111e_priv* lp)
 	return 0;
 }
 
-static int amd8111e_enable_link_change(struct amd8111e_priv* lp)
+static int amd8111e_enable_link_change(struct amd8111e_priv *lp)
 {
 
 	/* Adapter is already stoped/suspended/interrupt-disabled */
@@ -1605,7 +1609,7 @@ static int amd8111e_enable_link_change(struct amd8111e_priv* lp)
  */
 static void amd8111e_tx_timeout(struct net_device *dev)
 {
-	struct amd8111e_priv* lp = netdev_priv(dev);
+	struct amd8111e_priv *lp = netdev_priv(dev);
 	int err;
 
 	netdev_err(dev, "transmit timed out, resetting\n");
@@ -1686,10 +1690,10 @@ static int amd8111e_resume(struct pci_dev *pci_dev)
 	return 0;
 }
 
-static void amd8111e_config_ipg(struct net_device* dev)
+static void amd8111e_config_ipg(struct net_device *dev)
 {
 	struct amd8111e_priv *lp = netdev_priv(dev);
-	struct ipg_info* ipg_data = &lp->ipg_data;
+	struct ipg_info *ipg_data = &lp->ipg_data;
 	void __iomem *mmio = lp->mmio;
 	unsigned int prev_col_cnt = ipg_data->col_cnt;
 	unsigned int total_col_cnt;
@@ -1787,8 +1791,8 @@ static int amd8111e_probe_one(struct pci_dev *pdev,
 {
 	int err, i;
 	unsigned long reg_addr,reg_len;
-	struct amd8111e_priv* lp;
-	struct net_device* dev;
+	struct amd8111e_priv *lp;
+	struct net_device *dev;
 
 	err = pci_enable_device(pdev);
 	if(err){

commit ba69a3d78e4f51e65933a86b8b107c86709bb2f5
Author: Varka Bhadram <varkab@cdac.in>
Date:   Mon Jul 14 14:09:08 2014 +0530

    ethernet: amd: fix pci device ids
    
    Normally any device ids will be above the corresponding device driver
    structure. This patch moves the pci device ids and MODULE_DEVICE_TABLE()
    above the pci driver structure.
    
    Signed-off-by: Varka Bhadram <varkab@cdac.in>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index a8f5c496c6cf..9f8a15e3b8bb 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -101,7 +101,6 @@ Revision History:
 MODULE_AUTHOR("Advanced Micro Devices, Inc.");
 MODULE_DESCRIPTION ("AMD8111 based 10/100 Ethernet Controller. Driver Version "MODULE_VERS);
 MODULE_LICENSE("GPL");
-MODULE_DEVICE_TABLE(pci, amd8111e_pci_tbl);
 module_param_array(speed_duplex, int, NULL, 0);
 MODULE_PARM_DESC(speed_duplex, "Set device speed and duplex modes, 0: Auto Negotiate, 1: 10Mbps Half Duplex, 2: 10Mbps Full Duplex, 3: 100Mbps Half Duplex, 4: 100Mbps Full Duplex");
 module_param_array(coalesce, bool, NULL, 0);
@@ -109,14 +108,6 @@ MODULE_PARM_DESC(coalesce, "Enable or Disable interrupt coalescing, 1: Enable, 0
 module_param_array(dynamic_ipg, bool, NULL, 0);
 MODULE_PARM_DESC(dynamic_ipg, "Enable or Disable dynamic IPG, 1: Enable, 0: Disable");
 
-static DEFINE_PCI_DEVICE_TABLE(amd8111e_pci_tbl) = {
-
-	{ PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD8111E_7462,
-	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
-	{ 0, }
-
-};
-
 /* This function will read the PHY registers. */
 static int amd8111e_read_phy(struct amd8111e_priv* lp, int phy_id, int reg, u32* val)
 {
@@ -1953,6 +1944,17 @@ static void amd8111e_remove_one(struct pci_dev *pdev)
 	}
 }
 
+static const struct pci_device_id amd8111e_pci_tbl[] = {
+	{
+	 .vendor = PCI_VENDOR_ID_AMD,
+	 .device = PCI_DEVICE_ID_AMD8111E_7462,
+	},
+	{
+	 .vendor = 0,
+	}
+};
+MODULE_DEVICE_TABLE(pci, amd8111e_pci_tbl);
+
 static struct pci_driver amd8111e_driver = {
 	.name   	= MODULE_NAME,
 	.id_table	= amd8111e_pci_tbl,

commit 13a4fa43bff03b745904fb1c6baaca42dd0fbf2c
Author: Varka Bhadram <varkab@cdac.in>
Date:   Mon Jul 14 14:09:07 2014 +0530

    ethernet: amd: fix comment styles
    
    This patch fixes the comment style issues
    
    Signed-off-by: Varka Bhadram <varkab@cdac.in>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index c322aa77ad1c..a8f5c496c6cf 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -116,9 +116,8 @@ static DEFINE_PCI_DEVICE_TABLE(amd8111e_pci_tbl) = {
 	{ 0, }
 
 };
-/*
-This function will read the PHY registers.
-*/
+
+/* This function will read the PHY registers. */
 static int amd8111e_read_phy(struct amd8111e_priv* lp, int phy_id, int reg, u32* val)
 {
 	void __iomem *mmio = lp->mmio;
@@ -146,9 +145,7 @@ static int amd8111e_read_phy(struct amd8111e_priv* lp, int phy_id, int reg, u32*
 
 }
 
-/*
-This function will write into PHY registers.
-*/
+/* This function will write into PHY registers. */
 static int amd8111e_write_phy(struct amd8111e_priv* lp,int phy_id, int reg, u32 val)
 {
 	unsigned int repeat = REPEAT_CNT;
@@ -176,9 +173,8 @@ static int amd8111e_write_phy(struct amd8111e_priv* lp,int phy_id, int reg, u32
 	return -EINVAL;
 
 }
-/*
-This is the mii register read function provided to the mii interface.
-*/
+
+/* This is the mii register read function provided to the mii interface. */
 static int amd8111e_mdio_read(struct net_device * dev, int phy_id, int reg_num)
 {
 	struct amd8111e_priv* lp = netdev_priv(dev);
@@ -189,9 +185,7 @@ static int amd8111e_mdio_read(struct net_device * dev, int phy_id, int reg_num)
 
 }
 
-/*
-This is the mii register write function provided to the mii interface.
-*/
+/* This is the mii register write function provided to the mii interface. */
 static void amd8111e_mdio_write(struct net_device * dev, int phy_id, int reg_num, int val)
 {
 	struct amd8111e_priv* lp = netdev_priv(dev);
@@ -199,9 +193,9 @@ static void amd8111e_mdio_write(struct net_device * dev, int phy_id, int reg_num
 	amd8111e_write_phy(lp, phy_id, reg_num, val);
 }
 
-/*
-This function will set PHY speed. During initialization sets the original speed to 100 full.
-*/
+/* This function will set PHY speed. During initialization sets
+ * the original speed to 100 full
+ */
 static void amd8111e_set_ext_phy(struct net_device *dev)
 {
 	struct amd8111e_priv *lp = netdev_priv(dev);
@@ -240,10 +234,9 @@ static void amd8111e_set_ext_phy(struct net_device *dev)
 
 }
 
-/*
-This function will unmap skb->data space and will free
-all transmit and receive skbuffs.
-*/
+/* This function will unmap skb->data space and will free
+ * all transmit and receive skbuffs.
+ */
 static int amd8111e_free_skbs(struct net_device *dev)
 {
 	struct amd8111e_priv *lp = netdev_priv(dev);
@@ -274,9 +267,9 @@ static int amd8111e_free_skbs(struct net_device *dev)
 	return 0;
 }
 
-/*
-This will set the receive buffer length corresponding to the mtu size of networkinterface.
-*/
+/* This will set the receive buffer length corresponding
+ * to the mtu size of networkinterface.
+ */
 static inline void amd8111e_set_rx_buff_len(struct net_device* dev)
 {
 	struct amd8111e_priv* lp = netdev_priv(dev);
@@ -284,8 +277,8 @@ static inline void amd8111e_set_rx_buff_len(struct net_device* dev)
 
 	if (mtu > ETH_DATA_LEN){
 		/* MTU + ethernet header + FCS
-		+ optional VLAN tag + skb reserve space 2 */
-
+		 * + optional VLAN tag + skb reserve space 2
+		 */
 		lp->rx_buff_len = mtu + ETH_HLEN + 10;
 		lp->options |= OPTION_JUMBO_ENABLE;
 	} else{
@@ -294,8 +287,10 @@ static inline void amd8111e_set_rx_buff_len(struct net_device* dev)
 	}
 }
 
-/*
-This function will free all the previously allocated buffers, determine new receive buffer length  and will allocate new receive buffers. This function also allocates and initializes both the transmitter and receive hardware descriptors.
+/* This function will free all the previously allocated buffers,
+ * determine new receive buffer length  and will allocate new receive buffers.
+ * This function also allocates and initializes both the transmitter
+ * and receive hardware descriptors.
  */
 static int amd8111e_init_ring(struct net_device *dev)
 {
@@ -376,7 +371,10 @@ static int amd8111e_init_ring(struct net_device *dev)
 err_no_mem:
 	return -ENOMEM;
 }
-/* This function will set the interrupt coalescing according to the input arguments */
+
+/* This function will set the interrupt coalescing according
+ * to the input arguments
+ */
 static int amd8111e_set_coalesce(struct net_device * dev, enum coal_mode cmod)
 {
 	unsigned int timeout;
@@ -435,9 +433,7 @@ static int amd8111e_set_coalesce(struct net_device * dev, enum coal_mode cmod)
 
 }
 
-/*
-This function initializes the device registers  and starts the device.
-*/
+/* This function initializes the device registers  and starts the device. */
 static int amd8111e_restart(struct net_device *dev)
 {
 	struct amd8111e_priv *lp = netdev_priv(dev);
@@ -513,9 +509,8 @@ static int amd8111e_restart(struct net_device *dev)
 	readl(mmio+CMD0);
 	return 0;
 }
-/*
-This function clears necessary the device registers.
-*/
+
+/* This function clears necessary the device registers. */
 static void amd8111e_init_hw_default( struct amd8111e_priv* lp)
 {
 	unsigned int reg_val;
@@ -604,9 +599,8 @@ static void amd8111e_init_hw_default( struct amd8111e_priv* lp)
 
 }
 
-/*
-This function disables the interrupt and clears all the pending
-interrupts in INT0
+/* This function disables the interrupt and clears all the pending
+ * interrupts in INT0
  */
 static void amd8111e_disable_interrupt(struct amd8111e_priv* lp)
 {
@@ -624,9 +618,7 @@ static void amd8111e_disable_interrupt(struct amd8111e_priv* lp)
 
 }
 
-/*
-This function stops the chip.
-*/
+/* This function stops the chip. */
 static void amd8111e_stop_chip(struct amd8111e_priv* lp)
 {
 	writel(RUN, lp->mmio + CMD0);
@@ -635,9 +627,7 @@ static void amd8111e_stop_chip(struct amd8111e_priv* lp)
 	readl(lp->mmio + CMD0);
 }
 
-/*
-This function frees the  transmiter and receiver descriptor rings.
-*/
+/* This function frees the  transmiter and receiver descriptor rings. */
 static void amd8111e_free_ring(struct amd8111e_priv* lp)
 {
 	/* Free transmit and receive descriptor rings */
@@ -658,9 +648,10 @@ static void amd8111e_free_ring(struct amd8111e_priv* lp)
 
 }
 
-/*
-This function will free all the transmit skbs that are actually transmitted by the device. It will check the ownership of the skb before freeing the skb.
-*/
+/* This function will free all the transmit skbs that are actually
+ * transmitted by the device. It will check the ownership of the
+ * skb before freeing the skb.
+ */
 static int amd8111e_tx(struct net_device *dev)
 {
 	struct amd8111e_priv* lp = netdev_priv(dev);
@@ -723,21 +714,20 @@ static int amd8111e_rx_poll(struct napi_struct *napi, int budget)
 		goto rx_not_empty;
 
 	do{
-		/* process receive packets until we use the quota*/
-		/* If we own the next entry, it's a new packet. Send it up. */
+		/* process receive packets until we use the quota.
+		 * If we own the next entry, it's a new packet. Send it up.
+		 */
 		while(1) {
 			status = le16_to_cpu(lp->rx_ring[rx_index].rx_flags);
 			if (status & OWN_BIT)
 				break;
 
-			/*
-			 * There is a tricky error noted by John Murphy,
+			/* There is a tricky error noted by John Murphy,
 			 * <murf@perftech.com> to Russ Nelson: Even with
 			 * full-sized * buffers it's possible for a
 			 * jabber packet to use two buffers, with only
 			 * the last correctly noting the error.
 			 */
-
 			if(status & ERR_BIT) {
 				/* reseting flags */
 				lp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;
@@ -770,7 +760,8 @@ static int amd8111e_rx_poll(struct napi_struct *napi, int budget)
 			new_skb = netdev_alloc_skb(dev, lp->rx_buff_len);
 			if (!new_skb) {
 				/* if allocation fail,
-				   ignore that pkt and go to next one */
+				 * ignore that pkt and go to next one
+				 */
 				lp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;
 				lp->drv_rx_errors++;
 				goto err_next_pkt;
@@ -811,8 +802,8 @@ static int amd8111e_rx_poll(struct napi_struct *napi, int budget)
 			rx_index = (++lp->rx_idx) & RX_RING_DR_MOD_MASK;
 		}
 		/* Check the interrupt status register for more packets in the
-		   mean time. Process them since we have not used up our quota.*/
-
+		 * mean time. Process them since we have not used up our quota.
+		 */
 		intr0 = readl(mmio + INT0);
 		/*Ack receive packets */
 		writel(intr0 & RINT0,mmio + INT0);
@@ -832,9 +823,7 @@ static int amd8111e_rx_poll(struct napi_struct *napi, int budget)
 	return num_rx_pkt;
 }
 
-/*
-This function will indicate the link status to the kernel.
-*/
+/* This function will indicate the link status to the kernel. */
 static int amd8111e_link_change(struct net_device* dev)
 {
 	struct amd8111e_priv *lp = netdev_priv(dev);
@@ -877,9 +866,8 @@ static int amd8111e_link_change(struct net_device* dev)
 
 	return 0;
 }
-/*
-This function reads the mib counters.
-*/
+
+/* This function reads the mib counters. */
 static int amd8111e_read_mib(void __iomem *mmio, u8 MIB_COUNTER)
 {
 	unsigned int  status;
@@ -897,8 +885,7 @@ static int amd8111e_read_mib(void __iomem *mmio, u8 MIB_COUNTER)
 	return data;
 }
 
-/*
- * This function reads the mib registers and returns the hardware statistics.
+/* This function reads the mib registers and returns the hardware statistics.
  * It updates previous internal driver statistics with new values.
  */
 static struct net_device_stats *amd8111e_get_stats(struct net_device *dev)
@@ -994,9 +981,10 @@ static struct net_device_stats *amd8111e_get_stats(struct net_device *dev)
 
 	return new_stats;
 }
+
 /* This function recalculate the interrupt coalescing  mode on every interrupt
-according to the datarate and the packet rate.
-*/
+ * according to the datarate and the packet rate.
+ */
 static int amd8111e_calc_coalesce(struct net_device *dev)
 {
 	struct amd8111e_priv *lp = netdev_priv(dev);
@@ -1128,9 +1116,10 @@ static int amd8111e_calc_coalesce(struct net_device *dev)
 	return 0;
 
 }
-/*
-This is device interrupt function. It handles transmit, receive,link change and hardware timer interrupts.
-*/
+
+/* This is device interrupt function. It handles transmit,
+ * receive,link change and hardware timer interrupts.
+ */
 static irqreturn_t amd8111e_interrupt(int irq, void *dev_id)
 {
 
@@ -1207,9 +1196,10 @@ static void amd8111e_poll(struct net_device *dev)
 #endif
 
 
-/*
-This function closes the network interface and updates the statistics so that most recent statistics will be available after the interface is down.
-*/
+/* This function closes the network interface and updates
+ * the statistics so that most recent statistics will be
+ * available after the interface is down.
+ */
 static int amd8111e_close(struct net_device * dev)
 {
 	struct amd8111e_priv *lp = netdev_priv(dev);
@@ -1240,8 +1230,10 @@ static int amd8111e_close(struct net_device * dev)
 	lp->opened = 0;
 	return 0;
 }
-/* This function opens new interface.It requests irq for the device, initializes the device,buffers and descriptors, and starts the device.
-*/
+
+/* This function opens new interface.It requests irq for the device,
+ * initializes the device,buffers and descriptors, and starts the device.
+ */
 static int amd8111e_open(struct net_device * dev )
 {
 	struct amd8111e_priv *lp = netdev_priv(dev);
@@ -1277,9 +1269,10 @@ static int amd8111e_open(struct net_device * dev )
 
 	return 0;
 }
-/*
-This function checks if there is any transmit  descriptors available to queue more packet.
-*/
+
+/* This function checks if there is any transmit  descriptors
+ * available to queue more packet.
+ */
 static int amd8111e_tx_queue_avail(struct amd8111e_priv* lp )
 {
 	int tx_index = lp->tx_idx & TX_BUFF_MOD_MASK;
@@ -1289,10 +1282,12 @@ static int amd8111e_tx_queue_avail(struct amd8111e_priv* lp )
 		return 0;
 
 }
-/*
-This function will queue the transmit packets to the descriptors and will trigger the send operation. It also initializes the transmit descriptors with buffer physical address, byte count, ownership to hardware etc.
-*/
 
+/* This function will queue the transmit packets to the
+ * descriptors and will trigger the send operation. It also
+ * initializes the transmit descriptors with buffer physical address,
+ * byte count, ownership to hardware etc.
+ */
 static netdev_tx_t amd8111e_start_xmit(struct sk_buff *skb,
 				       struct net_device * dev)
 {
@@ -1340,9 +1335,7 @@ static netdev_tx_t amd8111e_start_xmit(struct sk_buff *skb,
 	spin_unlock_irqrestore(&lp->lock, flags);
 	return NETDEV_TX_OK;
 }
-/*
-This function returns all the memory mapped registers of the device.
-*/
+/* This function returns all the memory mapped registers of the device. */
 static void amd8111e_read_regs(struct amd8111e_priv *lp, u32 *buf)
 {
 	void __iomem *mmio = lp->mmio;
@@ -1363,10 +1356,9 @@ static void amd8111e_read_regs(struct amd8111e_priv *lp, u32 *buf)
 }
 
 
-/*
-This function sets promiscuos mode, all-multi mode or the multicast address
-list to the device.
-*/
+/* This function sets promiscuos mode, all-multi mode or the multicast address
+ * list to the device.
+ */
 static void amd8111e_set_multicast_list(struct net_device *dev)
 {
 	struct netdev_hw_addr *ha;
@@ -1503,10 +1495,10 @@ static const struct ethtool_ops ops = {
 	.set_wol = amd8111e_set_wol,
 };
 
-/*
-This function handles all the  ethtool ioctls. It gives driver info, gets/sets driver speed, gets memory mapped register values, forces auto negotiation, sets/gets WOL options for ethtool application.
-*/
-
+/* This function handles all the  ethtool ioctls. It gives driver info,
+ * gets/sets driver speed, gets memory mapped register values, forces
+ * auto negotiation, sets/gets WOL options for ethtool application.
+ */
 static int amd8111e_ioctl(struct net_device * dev , struct ifreq *ifr, int cmd)
 {
 	struct mii_ioctl_data *data = if_mii(ifr);
@@ -1561,9 +1553,9 @@ static int amd8111e_set_mac_address(struct net_device *dev, void *p)
 	return 0;
 }
 
-/*
-This function changes the mtu of the device. It restarts the device  to initialize the descriptor with new receive buffers.
-*/
+/* This function changes the mtu of the device. It restarts the device  to
+ * initialize the descriptor with new receive buffers.
+ */
 static int amd8111e_change_mtu(struct net_device *dev, int new_mtu)
 {
 	struct amd8111e_priv *lp = netdev_priv(dev);
@@ -1574,7 +1566,8 @@ static int amd8111e_change_mtu(struct net_device *dev, int new_mtu)
 
 	if (!netif_running(dev)) {
 		/* new_mtu will be used
-		   when device starts netxt time */
+		 * when device starts netxt time
+		 */
 		dev->mtu = new_mtu;
 		return 0;
 	}
@@ -1614,8 +1607,7 @@ static int amd8111e_enable_link_change(struct amd8111e_priv* lp)
 	return 0;
 }
 
-/*
- * This function is called when a packet transmission fails to complete
+/* This function is called when a packet transmission fails to complete
  * within a reasonable period, on the assumption that an interrupt have
  * failed or the interface is locked up. This function will reinitialize
  * the hardware.
@@ -1925,7 +1917,6 @@ static int amd8111e_probe_one(struct pci_dev *pdev,
 	}
 
 	/*  display driver and device information */
-
     	chip_version = (readl(lp->mmio + CHIPID) & 0xf0000000)>>28;
 	dev_info(&pdev->dev, "AMD-8111e Driver Version: %s\n", MODULE_VERS);
 	dev_info(&pdev->dev, "[ Rev %x ] PCI 10/100BaseT Ethernet %pM\n",

commit f7afbaa557337d059603ef8c3519831c9e0d1591
Author: Varka Bhadram <varkab@cdac.in>
Date:   Mon Jul 14 14:09:06 2014 +0530

    ethernet: amd: dynamic debug fixes
    
    This patch convert printk() to netdev_dbg/info/err or dev_info/err/dbg
    
    Signed-off-by: Varka Bhadram <varkab@cdac.in>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 433107c3cd2b..c322aa77ad1c 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -501,8 +501,7 @@ static int amd8111e_restart(struct net_device *dev)
 
 	/* Enable interrupt coalesce */
 	if(lp->options & OPTION_INTR_COAL_ENABLE){
-		printk(KERN_INFO "%s: Interrupt Coalescing Enabled.\n",
-								dev->name);
+		netdev_info(dev, "Interrupt Coalescing Enabled.\n");
 		amd8111e_set_coalesce(dev,ENABLE_COAL);
 	}
 
@@ -860,16 +859,19 @@ static int amd8111e_link_change(struct net_device* dev)
 		else if(speed == PHY_SPEED_100)
 			lp->link_config.speed = SPEED_100;
 
-		printk(KERN_INFO "%s: Link is Up. Speed is %s Mbps %s Duplex\n",			dev->name,
-		       (lp->link_config.speed == SPEED_100) ? "100": "10",
-		       (lp->link_config.duplex == DUPLEX_FULL)? "Full": "Half");
+		netdev_info(dev, "Link is Up. Speed is %s Mbps %s Duplex\n",
+			    (lp->link_config.speed == SPEED_100) ?
+							"100" : "10",
+			    (lp->link_config.duplex == DUPLEX_FULL) ?
+							"Full" : "Half");
+
 		netif_carrier_on(dev);
 	}
 	else{
 		lp->link_config.speed = SPEED_INVALID;
 		lp->link_config.duplex = DUPLEX_INVALID;
 		lp->link_config.autoneg = AUTONEG_INVALID;
-		printk(KERN_INFO "%s: Link is Down.\n",dev->name);
+		netdev_info(dev, "Link is Down.\n");
 		netif_carrier_off(dev);
 	}
 
@@ -1168,7 +1170,7 @@ static irqreturn_t amd8111e_interrupt(int irq, void *dev_id)
 			/* Schedule a polling routine */
 			__napi_schedule(&lp->napi);
 		} else if (intren0 & RINTEN0) {
-			printk("************Driver bug! interrupt while in poll\n");
+			netdev_dbg(dev, "************Driver bug! interrupt while in poll\n");
 			/* Fix by disable receive interrupts */
 			writel(RINTEN0, mmio + INTEN0);
 		}
@@ -1264,7 +1266,7 @@ static int amd8111e_open(struct net_device * dev )
 	/* Start ipg timer */
 	if(lp->options & OPTION_DYN_IPG_ENABLE){
 		add_timer(&lp->ipg_data.ipg_timer);
-		printk(KERN_INFO "%s: Dynamic IPG Enabled.\n",dev->name);
+		netdev_info(dev, "Dynamic IPG Enabled\n");
 	}
 
 	lp->opened = 1;
@@ -1623,8 +1625,8 @@ static void amd8111e_tx_timeout(struct net_device *dev)
 	struct amd8111e_priv* lp = netdev_priv(dev);
 	int err;
 
-	printk(KERN_ERR "%s: transmit timed out, resetting\n",
-	 					      dev->name);
+	netdev_err(dev, "transmit timed out, resetting\n");
+
 	spin_lock_irq(&lp->lock);
 	err = amd8111e_restart(dev);
 	spin_unlock_irq(&lp->lock);
@@ -1807,22 +1809,19 @@ static int amd8111e_probe_one(struct pci_dev *pdev,
 
 	err = pci_enable_device(pdev);
 	if(err){
-		printk(KERN_ERR "amd8111e: Cannot enable new PCI device, "
-			"exiting.\n");
+		dev_err(&pdev->dev, "Cannot enable new PCI device\n");
 		return err;
 	}
 
 	if(!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)){
-		printk(KERN_ERR "amd8111e: Cannot find PCI base address, "
-		       "exiting.\n");
+		dev_err(&pdev->dev, "Cannot find PCI base address\n");
 		err = -ENODEV;
 		goto err_disable_pdev;
 	}
 
 	err = pci_request_regions(pdev, MODULE_NAME);
 	if(err){
-		printk(KERN_ERR "amd8111e: Cannot obtain PCI resources, "
-		       "exiting.\n");
+		dev_err(&pdev->dev, "Cannot obtain PCI resources\n");
 		goto err_disable_pdev;
 	}
 
@@ -1830,16 +1829,14 @@ static int amd8111e_probe_one(struct pci_dev *pdev,
 
 	/* Find power-management capability. */
 	if (!pdev->pm_cap) {
-		printk(KERN_ERR "amd8111e: No Power Management capability, "
-		       "exiting.\n");
+		dev_err(&pdev->dev, "No Power Management capability\n");
 		err = -ENODEV;
 		goto err_free_reg;
 	}
 
 	/* Initialize DMA */
 	if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) < 0) {
-		printk(KERN_ERR "amd8111e: DMA not supported,"
-			"exiting.\n");
+		dev_err(&pdev->dev, "DMA not supported\n");
 		err = -ENODEV;
 		goto err_free_reg;
 	}
@@ -1868,8 +1865,7 @@ static int amd8111e_probe_one(struct pci_dev *pdev,
 
 	lp->mmio = devm_ioremap(&pdev->dev, reg_addr, reg_len);
 	if (!lp->mmio) {
-		printk(KERN_ERR "amd8111e: Cannot map device registers, "
-		       "exiting\n");
+		dev_err(&pdev->dev, "Cannot map device registers\n");
 		err = -ENOMEM;
 		goto err_free_dev;
 	}
@@ -1911,8 +1907,7 @@ static int amd8111e_probe_one(struct pci_dev *pdev,
 
 	err = register_netdev(dev);
 	if (err) {
-		printk(KERN_ERR "amd8111e: Cannot register net device, "
-		       "exiting.\n");
+		dev_err(&pdev->dev, "Cannot register net device\n");
 		goto err_free_dev;
 	}
 
@@ -1932,16 +1927,15 @@ static int amd8111e_probe_one(struct pci_dev *pdev,
 	/*  display driver and device information */
 
     	chip_version = (readl(lp->mmio + CHIPID) & 0xf0000000)>>28;
-	printk(KERN_INFO "%s: AMD-8111e Driver Version: %s\n",
-	       dev->name,MODULE_VERS);
-	printk(KERN_INFO "%s: [ Rev %x ] PCI 10/100BaseT Ethernet %pM\n",
-	       dev->name, chip_version, dev->dev_addr);
+	dev_info(&pdev->dev, "AMD-8111e Driver Version: %s\n", MODULE_VERS);
+	dev_info(&pdev->dev, "[ Rev %x ] PCI 10/100BaseT Ethernet %pM\n",
+		 chip_version, dev->dev_addr);
 	if (lp->ext_phy_id)
-		printk(KERN_INFO "%s: Found MII PHY ID 0x%08x at address 0x%02x\n",
-		       dev->name, lp->ext_phy_id, lp->ext_phy_addr);
+		dev_info(&pdev->dev, "Found MII PHY ID 0x%08x at address 0x%02x\n",
+			 lp->ext_phy_id, lp->ext_phy_addr);
 	else
-		printk(KERN_INFO "%s: Couldn't detect MII PHY, assuming address 0x01\n",
-		       dev->name);
+		dev_info(&pdev->dev, "Couldn't detect MII PHY, assuming address 0x01\n");
+
     	return 0;
 
 err_free_dev:

commit 711fec5d22e15f24b11b6c7f79cc39cb96f52b13
Author: Varka Bhadram <varkab@cdac.in>
Date:   Mon Jul 14 14:09:05 2014 +0530

    ethernet: amd: use devm_ioremap()
    
    This patch replace ioremap() with the devm_ioremap() so that
    the resource will be freed automatically with the probe failed.
    
    Signed-off-by: Varka Bhadram <varkab@cdac.in>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index ddd09e830527..433107c3cd2b 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -1866,7 +1866,7 @@ static int amd8111e_probe_one(struct pci_dev *pdev,
 
 	spin_lock_init(&lp->lock);
 
-	lp->mmio = ioremap(reg_addr, reg_len);
+	lp->mmio = devm_ioremap(&pdev->dev, reg_addr, reg_len);
 	if (!lp->mmio) {
 		printk(KERN_ERR "amd8111e: Cannot map device registers, "
 		       "exiting\n");
@@ -1913,7 +1913,7 @@ static int amd8111e_probe_one(struct pci_dev *pdev,
 	if (err) {
 		printk(KERN_ERR "amd8111e: Cannot register net device, "
 		       "exiting.\n");
-		goto err_iounmap;
+		goto err_free_dev;
 	}
 
 	pci_set_drvdata(pdev, dev);
@@ -1943,8 +1943,6 @@ static int amd8111e_probe_one(struct pci_dev *pdev,
 		printk(KERN_INFO "%s: Couldn't detect MII PHY, assuming address 0x01\n",
 		       dev->name);
     	return 0;
-err_iounmap:
-	iounmap(lp->mmio);
 
 err_free_dev:
 	free_netdev(dev);
@@ -1964,7 +1962,6 @@ static void amd8111e_remove_one(struct pci_dev *pdev)
 
 	if (dev) {
 		unregister_netdev(dev);
-		iounmap(((struct amd8111e_priv *)netdev_priv(dev))->mmio);
 		free_netdev(dev);
 		pci_release_regions(pdev);
 		pci_disable_device(pdev);

commit 43519e60ef8020e7b4f99d20b6663fab50af21dc
Author: Varka Bhadram <varkab@cdac.in>
Date:   Mon Jul 14 14:09:04 2014 +0530

    ethernet: amd: move amd111e_remove_one after probe
    
    This patch moves the remove functionalities after the probe
    so that we can see the registered and released resources properly.
    Every driver follows the same concept.
    
    Signed-off-by: Varka Bhadram <varkab@cdac.in>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 068dc7cad5fa..ddd09e830527 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -1701,18 +1701,6 @@ static int amd8111e_resume(struct pci_dev *pci_dev)
 	return 0;
 }
 
-
-static void amd8111e_remove_one(struct pci_dev *pdev)
-{
-	struct net_device *dev = pci_get_drvdata(pdev);
-	if (dev) {
-		unregister_netdev(dev);
-		iounmap(((struct amd8111e_priv *)netdev_priv(dev))->mmio);
-		free_netdev(dev);
-		pci_release_regions(pdev);
-		pci_disable_device(pdev);
-	}
-}
 static void amd8111e_config_ipg(struct net_device* dev)
 {
 	struct amd8111e_priv *lp = netdev_priv(dev);
@@ -1970,6 +1958,19 @@ static int amd8111e_probe_one(struct pci_dev *pdev,
 
 }
 
+static void amd8111e_remove_one(struct pci_dev *pdev)
+{
+	struct net_device *dev = pci_get_drvdata(pdev);
+
+	if (dev) {
+		unregister_netdev(dev);
+		iounmap(((struct amd8111e_priv *)netdev_priv(dev))->mmio);
+		free_netdev(dev);
+		pci_release_regions(pdev);
+		pci_disable_device(pdev);
+	}
+}
+
 static struct pci_driver amd8111e_driver = {
 	.name   	= MODULE_NAME,
 	.id_table	= amd8111e_pci_tbl,

commit 7ad24ea4bf620a32631d7b3069c3e30c078b0c3e
Author: Wilfried Klaebe <w-lkml@lebenslange-mailadresse.de>
Date:   Sun May 11 00:12:32 2014 +0000

    net: get rid of SET_ETHTOOL_OPS
    
    net: get rid of SET_ETHTOOL_OPS
    
    Dave Miller mentioned he'd like to see SET_ETHTOOL_OPS gone.
    This does that.
    
    Mostly done via coccinelle script:
    @@
    struct ethtool_ops *ops;
    struct net_device *dev;
    @@
    -       SET_ETHTOOL_OPS(dev, ops);
    +       dev->ethtool_ops = ops;
    
    Compile tested only, but I'd seriously wonder if this broke anything.
    
    Suggested-by: Dave Miller <davem@davemloft.net>
    Signed-off-by: Wilfried Klaebe <w-lkml@lebenslange-mailadresse.de>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 26efaaa5e73f..068dc7cad5fa 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -1900,7 +1900,7 @@ static int amd8111e_probe_one(struct pci_dev *pdev,
 
 	/* Initialize driver entry points */
 	dev->netdev_ops = &amd8111e_netdev_ops;
-	SET_ETHTOOL_OPS(dev, &ops);
+	dev->ethtool_ops = &ops;
 	dev->irq =pdev->irq;
 	dev->watchdog_timeo = AMD8111E_TX_TIMEOUT;
 	netif_napi_add(dev, &lp->napi, amd8111e_rx_poll, 32);

commit 278d5385b148c87d3652886af3c17ea65e1f26da
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Mar 14 18:01:11 2014 -0700

    amd8111e: Don't receive packets when the napi budget == 0
    
    Processing any incoming packets with a with a napi budget of 0
    is incorrect driver behavior.
    
    This matters as netpoll will shortly call drivers with a budget of 0
    to avoid receive packet processing happening in hard irq context.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 2061b471fd16..26efaaa5e73f 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -720,6 +720,9 @@ static int amd8111e_rx_poll(struct napi_struct *napi, int budget)
 	int rx_pkt_limit = budget;
 	unsigned long flags;
 
+	if (rx_pkt_limit <= 0)
+		goto rx_not_empty;
+
 	do{
 		/* process receive packets until we use the quota*/
 		/* If we own the next entry, it's a new packet. Send it up. */

commit a81ab36bf52d0ca3a32251a923be1dbced726141
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Jan 8 15:32:47 2014 -0500

    drivers/net: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.   Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    This covers everything under drivers/net except for wireless, which
    has been submitted separately.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index d6beba0bc01f..2061b471fd16 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -72,7 +72,6 @@ Revision History:
 #include <linux/types.h>
 #include <linux/compiler.h>
 #include <linux/delay.h>
-#include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/ioport.h>
 #include <linux/pci.h>

commit 0ab75ae81da249988bf3c7a38e0a48d4b9be1e0c
Author: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Date:   Fri Dec 6 06:28:43 2013 -0800

    ethernet: Fix FSF address in file headers
    
    Several files refer to an old address for the Free Software Foundation
    in the file header comment.  Resolve by replacing the address with
    the URL <http://www.gnu.org/licenses/> so that we do not have to keep
    updating the header comments anytime the address changes.
    
    CC: Santosh Raspatur <santosh@chelsio.com>
    CC: Dimitris Michailidis <dm@chelsio.com>
    CC: Michael Chan <mchan@broadcom.com>
    CC: Santiago Leon <santil@linux.vnet.ibm.com>
    CC: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    CC: Olof Johansson <olof@lixom.net>
    CC: Manish Chopra <manish.chopra@qlogic.com>
    CC: Sony Chacko <sony.chacko@qlogic.com>
    CC: Rajesh Borundia <rajesh.borundia@qlogic.com>
    CC: Nicolas Pitre <nico@fluxnic.net>
    CC: Steve Glendinning <steve.glendinning@shawell.net>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index d042511bdc13..d6beba0bc01f 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -24,9 +24,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
- * USA
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
 
 Module Name:
 

commit 94ee39fe773d55a305b0a069ce7a93b64375a89a
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Fri Oct 18 09:19:54 2013 +0900

    net: amd8111e: remove unnecessary pci_set_drvdata()
    
    The driver core clears the driver data to NULL after device_release
    or on probe failure. Thus, it is not needed to manually clear the
    device driver data to NULL.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 1b1429d5d5c2..d042511bdc13 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -1711,7 +1711,6 @@ static void amd8111e_remove_one(struct pci_dev *pdev)
 		free_netdev(dev);
 		pci_release_regions(pdev);
 		pci_disable_device(pdev);
-		pci_set_drvdata(pdev, NULL);
 	}
 }
 static void amd8111e_config_ipg(struct net_device* dev)
@@ -1967,7 +1966,6 @@ static int amd8111e_probe_one(struct pci_dev *pdev,
 
 err_disable_pdev:
 	pci_disable_device(pdev);
-	pci_set_drvdata(pdev, NULL);
 	return err;
 
 }

commit f9c7da5eaf10fa1d7a91b83aefc6fb8e3a4ad39c
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Tue Jun 18 16:06:37 2013 +0800

    amd8111e: use pdev->pm_cap instead of pci_find_capability(.., PCI_CAP_ID_PM)
    
    Pci core has been saved pm cap register offset by pdev->pm_cap in pci_pm_init()
    in init path. So we can use pdev->pm_cap instead of using
    pci_find_capability(pdev, PCI_CAP_ID_PM) for better performance and simplified code.
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Patrick McHardy <kaber@trash.net>
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: netdev@vger.kernel.org (open list:NETWORKING DRIVERS)
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index bc71aec1159d..1b1429d5d5c2 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -1813,7 +1813,7 @@ static const struct net_device_ops amd8111e_netdev_ops = {
 static int amd8111e_probe_one(struct pci_dev *pdev,
 				  const struct pci_device_id *ent)
 {
-	int err,i,pm_cap;
+	int err, i;
 	unsigned long reg_addr,reg_len;
 	struct amd8111e_priv* lp;
 	struct net_device* dev;
@@ -1842,7 +1842,7 @@ static int amd8111e_probe_one(struct pci_dev *pdev,
 	pci_set_master(pdev);
 
 	/* Find power-management capability. */
-	if((pm_cap = pci_find_capability(pdev, PCI_CAP_ID_PM))==0){
+	if (!pdev->pm_cap) {
 		printk(KERN_ERR "amd8111e: No Power Management capability, "
 		       "exiting.\n");
 		err = -ENODEV;
@@ -1875,7 +1875,7 @@ static int amd8111e_probe_one(struct pci_dev *pdev,
 	lp = netdev_priv(dev);
 	lp->pci_dev = pdev;
 	lp->amd8111e_net_dev = dev;
-	lp->pm_cap = pm_cap;
+	lp->pm_cap = pdev->pm_cap;
 
 	spin_lock_init(&lp->lock);
 

commit a46e6ccdd1cd557cbb9a24022ee027d09a4bd625
Author: Peter Hwe <PeterHuewe@gmx.de>
Date:   Tue May 21 12:58:10 2013 +0000

    net/ethernet/amd/amd8111e: Use module_pci_driver to register driver
    
    Removing some boilerplate by using module_pci_driver instead of calling
    register and unregister in the otherwise empty init/exit functions.
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 8e6b665a6726..bc71aec1159d 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -1981,15 +1981,4 @@ static struct pci_driver amd8111e_driver = {
 	.resume		= amd8111e_resume
 };
 
-static int __init amd8111e_init(void)
-{
-	return pci_register_driver(&amd8111e_driver);
-}
-
-static void __exit amd8111e_cleanup(void)
-{
-	pci_unregister_driver(&amd8111e_driver);
-}
-
-module_init(amd8111e_init);
-module_exit(amd8111e_cleanup);
+module_pci_driver(amd8111e_driver);

commit 86a9bad3ab6b6f858fd4443b48738cabbb6d094c
Author: Patrick McHardy <kaber@trash.net>
Date:   Fri Apr 19 02:04:30 2013 +0000

    net: vlan: add protocol argument to packet tagging functions
    
    Add a protocol argument to the VLAN packet tagging functions. In case of HW
    tagging, we need that protocol available in the ndo_start_xmit functions,
    so it is stored in a new field in the skb. The new field fits into a hole
    (on 64 bit) and doesn't increase the sks's size.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 6bad84d6e2c4..8e6b665a6726 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -793,7 +793,7 @@ static int amd8111e_rx_poll(struct napi_struct *napi, int budget)
 #if AMD8111E_VLAN_TAG_USED
 			if (vtag == TT_VLAN_TAGGED){
 				u16 vlan_tag = le16_to_cpu(lp->rx_ring[rx_index].tag_ctrl_info);
-				__vlan_hwaccel_put_tag(skb, vlan_tag);
+				__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan_tag);
 			}
 #endif
 			netif_receive_skb(skb);

commit f646968f8f7c624587de729115d802372b9063dd
Author: Patrick McHardy <kaber@trash.net>
Date:   Fri Apr 19 02:04:27 2013 +0000

    net: vlan: rename NETIF_F_HW_VLAN_* feature flags to NETIF_F_HW_VLAN_CTAG_*
    
    Rename the hardware VLAN acceleration features to include "CTAG" to indicate
    that they only support CTAGs. Follow up patches will introduce 802.1ad
    server provider tagging (STAGs) and require the distinction for hardware not
    supporting acclerating both.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 42d4e6ad58a5..6bad84d6e2c4 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -1869,7 +1869,7 @@ static int amd8111e_probe_one(struct pci_dev *pdev,
 	SET_NETDEV_DEV(dev, &pdev->dev);
 
 #if AMD8111E_VLAN_TAG_USED
-	dev->features |= NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX ;
+	dev->features |= NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX ;
 #endif
 
 	lp = netdev_priv(dev);
@@ -1907,7 +1907,7 @@ static int amd8111e_probe_one(struct pci_dev *pdev,
 	netif_napi_add(dev, &lp->napi, amd8111e_rx_poll, 32);
 
 #if AMD8111E_VLAN_TAG_USED
-	dev->features |= NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX;
+	dev->features |= NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX;
 #endif
 	/* Probe the external PHY */
 	amd8111e_probe_ext_phy(dev);

commit 0cb0568dfea6b51a39362c484c9caddfc94a78b0
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Dec 3 09:23:54 2012 -0500

    net/amd: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 3491d4312fc9..42d4e6ad58a5 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -1702,7 +1702,7 @@ static int amd8111e_resume(struct pci_dev *pci_dev)
 }
 
 
-static void __devexit amd8111e_remove_one(struct pci_dev *pdev)
+static void amd8111e_remove_one(struct pci_dev *pdev)
 {
 	struct net_device *dev = pci_get_drvdata(pdev);
 	if (dev) {
@@ -1774,7 +1774,7 @@ static void amd8111e_config_ipg(struct net_device* dev)
 
 }
 
-static void __devinit amd8111e_probe_ext_phy(struct net_device* dev)
+static void amd8111e_probe_ext_phy(struct net_device *dev)
 {
 	struct amd8111e_priv *lp = netdev_priv(dev);
 	int i;
@@ -1810,7 +1810,7 @@ static const struct net_device_ops amd8111e_netdev_ops = {
 #endif
 };
 
-static int __devinit amd8111e_probe_one(struct pci_dev *pdev,
+static int amd8111e_probe_one(struct pci_dev *pdev,
 				  const struct pci_device_id *ent)
 {
 	int err,i,pm_cap;
@@ -1976,7 +1976,7 @@ static struct pci_driver amd8111e_driver = {
 	.name   	= MODULE_NAME,
 	.id_table	= amd8111e_pci_tbl,
 	.probe		= amd8111e_probe_one,
-	.remove		= __devexit_p(amd8111e_remove_one),
+	.remove		= amd8111e_remove_one,
 	.suspend	= amd8111e_suspend,
 	.resume		= amd8111e_resume
 };

commit 86e506e39909d356ca1c76c00022f3c64f5b7665
Author: Peter Senna Tschudin <peter.senna@gmail.com>
Date:   Fri Oct 5 12:10:51 2012 +0000

    drivers/net/ethernet/amd/amd8111e.c: fix error return code
    
    The function amd8111e_probe_one() return 0 for success and negative
    value for most of its internal tests failures. There are two exceptions
    that are error cases going to err_free_reg:. For this two cases, the
    function abort its success execution path, but returns non negative
    value, making it dificult for a caller function to notice the error.
    
    This patch fixes the error cases that do not return negative values.
    
    This was found by Coccinelle, but the code change was made by hand.
    This patch is not robot generated.
    
    A simplified version of the semantic match that finds this problem is
    as follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    (
    if@p1 (\(ret < 0\|ret != 0\))
     { ... return ret; }
    |
    ret@p1 = 0
    )
    ... when != ret = e1
        when != &ret
    *if(...)
    {
      ... when != ret = e2
          when forall
     return ret;
    }
    // </smpl>
    
    Signed-off-by: Peter Senna Tschudin <peter.senna@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 64d0d9c1afa2..3491d4312fc9 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -1845,6 +1845,7 @@ static int __devinit amd8111e_probe_one(struct pci_dev *pdev,
 	if((pm_cap = pci_find_capability(pdev, PCI_CAP_ID_PM))==0){
 		printk(KERN_ERR "amd8111e: No Power Management capability, "
 		       "exiting.\n");
+		err = -ENODEV;
 		goto err_free_reg;
 	}
 
@@ -1852,6 +1853,7 @@ static int __devinit amd8111e_probe_one(struct pci_dev *pdev,
 	if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) < 0) {
 		printk(KERN_ERR "amd8111e: DMA not supported,"
 			"exiting.\n");
+		err = -ENODEV;
 		goto err_free_reg;
 	}
 

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 9f62504d0086..64d0d9c1afa2 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -88,7 +88,6 @@ Revision History:
 #include <linux/crc32.h>
 #include <linux/dma-mapping.h>
 
-#include <asm/system.h>
 #include <asm/io.h>
 #include <asm/byteorder.h>
 #include <asm/uaccess.h>

commit 1d266430546acf01438ae42d0a7370db4817e2ad
Author: Pradeep A Dalvi <netdev@pradeepdalvi.com>
Date:   Sun Feb 5 02:49:09 2012 +0000

    netdev: ethernet dev_alloc_skb to netdev_alloc_skb
    
    Replaced deprecating dev_alloc_skb with netdev_alloc_skb in drivers/net/ethernet
      - Removed extra skb->dev = dev after netdev_alloc_skb
    
    Signed-off-by: Pradeep A Dalvi <netdev@pradeepdalvi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index b8306a589558..9f62504d0086 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -336,7 +336,8 @@ static int amd8111e_init_ring(struct net_device *dev)
 	/* Allocating receive  skbs */
 	for (i = 0; i < NUM_RX_BUFFERS; i++) {
 
-		if (!(lp->rx_skbuff[i] = dev_alloc_skb(lp->rx_buff_len))) {
+		lp->rx_skbuff[i] = netdev_alloc_skb(dev, lp->rx_buff_len);
+		if (!lp->rx_skbuff[i]) {
 				/* Release previos allocated skbs */
 				for(--i; i >= 0 ;i--)
 					dev_kfree_skb(lp->rx_skbuff[i]);
@@ -768,7 +769,8 @@ static int amd8111e_rx_poll(struct napi_struct *napi, int budget)
 			}
 			if(--rx_pkt_limit < 0)
 				goto rx_not_empty;
-			if(!(new_skb = dev_alloc_skb(lp->rx_buff_len))){
+			new_skb = netdev_alloc_skb(dev, lp->rx_buff_len);
+			if (!new_skb) {
 				/* if allocation fail,
 				   ignore that pkt and go to next one */
 				lp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;

commit 41de8d4cff21a2e81e3d9ff66f5f7c903f9c3ab1
Author: Joe Perches <joe@perches.com>
Date:   Sun Jan 29 13:47:52 2012 +0000

    drivers/net: Remove alloc_etherdev error messages
    
    alloc_etherdev has a generic OOM/unable to alloc message.
    Remove the duplicative messages after alloc_etherdev calls.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 33e0a8c20f6b..b8306a589558 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -1859,7 +1859,6 @@ static int __devinit amd8111e_probe_one(struct pci_dev *pdev,
 
 	dev = alloc_etherdev(sizeof(struct amd8111e_priv));
 	if (!dev) {
-		printk(KERN_ERR "amd8111e: Etherdev alloc failed, exiting.\n");
 		err = -ENOMEM;
 		goto err_free_reg;
 	}

commit c857ff6ecef1c7a1eb10c97c72d7230683392e9c
Author: Joe Perches <joe@perches.com>
Date:   Wed Nov 16 09:38:05 2011 +0000

    amd8111e: Convert ETH_ADDR_LEN uses to ETH_ALEN
    
    Reduce the number of #defines, use the normal #define from if_ether.h
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index a388118ee8e6..33e0a8c20f6b 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -499,7 +499,7 @@ static int amd8111e_restart(struct net_device *dev)
 	writel( VAL0 | APAD_XMT | REX_RTRY, mmio + CMD2 );
 
 	/* Setting the MAC address to the device */
-	for(i = 0; i < ETH_ADDR_LEN; i++)
+	for (i = 0; i < ETH_ALEN; i++)
 		writeb( dev->dev_addr[i], mmio + PADR + i );
 
 	/* Enable interrupt coalesce */
@@ -1550,7 +1550,7 @@ static int amd8111e_set_mac_address(struct net_device *dev, void *p)
 	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
 	spin_lock_irq(&lp->lock);
 	/* Setting the MAC address to the device */
-	for(i = 0; i < ETH_ADDR_LEN; i++)
+	for (i = 0; i < ETH_ALEN; i++)
 		writeb( dev->dev_addr[i], lp->mmio + PADR + i );
 
 	spin_unlock_irq(&lp->lock);
@@ -1886,7 +1886,7 @@ static int __devinit amd8111e_probe_one(struct pci_dev *pdev,
 	}
 
 	/* Initializing MAC address */
-	for(i = 0; i < ETH_ADDR_LEN; i++)
+	for (i = 0; i < ETH_ALEN; i++)
 		dev->dev_addr[i] = readb(lp->mmio + PADR + i);
 
 	/* Setting user defined parametrs */

commit 23020ab35364f2c91133b099c2b1f7458e29aa96
Author: Rick Jones <rick.jones2@hp.com>
Date:   Wed Nov 9 09:58:07 2011 +0000

    Sweep additional floors of strcpy in .get_drvinfo routines
    
    Perform another round of floor sweeping, converting the .get_drvinfo
    routines of additional drivers from strcpy to strlcpy along with
    some conversion of sprintf to snprintf.
    
    Signed-off-by: Rick Jones <rick.jones2@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index a9745f4ddbfe..a388118ee8e6 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -1412,10 +1412,11 @@ static void amd8111e_get_drvinfo(struct net_device* dev, struct ethtool_drvinfo
 {
 	struct amd8111e_priv *lp = netdev_priv(dev);
 	struct pci_dev *pci_dev = lp->pci_dev;
-	strcpy (info->driver, MODULE_NAME);
-	strcpy (info->version, MODULE_VERS);
-	sprintf(info->fw_version,"%u",chip_version);
-	strcpy (info->bus_info, pci_name(pci_dev));
+	strlcpy(info->driver, MODULE_NAME, sizeof(info->driver));
+	strlcpy(info->version, MODULE_VERS, sizeof(info->version));
+	snprintf(info->fw_version, sizeof(info->fw_version),
+		"%u", chip_version);
+	strlcpy(info->bus_info, pci_name(pci_dev), sizeof(info->bus_info));
 }
 
 static int amd8111e_get_regs_len(struct net_device *dev)

commit afc4b13df143122f99a0eb10bfefb216c2806de0
Author: Jiri Pirko <jpirko@redhat.com>
Date:   Tue Aug 16 06:29:01 2011 +0000

    net: remove use of ndo_set_multicast_list in drivers
    
    replace it by ndo_set_rx_mode
    
    Signed-off-by: Jiri Pirko <jpirko@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 78002ef9c0e5..a9745f4ddbfe 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -1798,7 +1798,7 @@ static const struct net_device_ops amd8111e_netdev_ops = {
 	.ndo_start_xmit		= amd8111e_start_xmit,
 	.ndo_tx_timeout		= amd8111e_tx_timeout,
 	.ndo_get_stats		= amd8111e_get_stats,
-	.ndo_set_multicast_list = amd8111e_set_multicast_list,
+	.ndo_set_rx_mode	= amd8111e_set_multicast_list,
 	.ndo_validate_addr	= eth_validate_addr,
 	.ndo_set_mac_address	= amd8111e_set_mac_address,
 	.ndo_do_ioctl		= amd8111e_ioctl,

commit b955f6ca776f3bab3d1e2c5fb1d247b203cbda14
Author: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Date:   Wed Mar 30 07:46:36 2011 -0700

    amd: Move AMD (Lance) chipset drivers
    
    Moves the drivers for the AMD chipsets into drivers/net/ethernet/amd/
    and the necessary Kconfig and Makfile changes.
    
    The au1000 (Alchemy) driver was also moved into the same directory
    even though it is not a "Lance" driver.
    
    CC: Peter Maydell <pmaydell@chiark.greenend.org.uk>
    CC: Roman Hodek <Roman.Hodek@informatik.uni-erlangen.de>
    CC: "Maciej W. Rozycki" <macro@linux-mips.org>
    CC: Donald Becker <becker@scyld.com>
    CC: Sam Creasey <sammy@users.qual.net>
    CC: Miguel de Icaza <miguel@nuclecu.unam.mx>
    CC: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    CC: Don Fry <pcnet32@frontier.com>
    CC: Geert Uytterhoeven <geert@linux-m68k.org>
    CC: Russell King <linux@arm.linux.org.uk>
    CC: David Davies <davies@maniac.ultranet.com>
    CC: "M.Hipp" <hippm@informatik.uni-tuebingen.de>
    CC: Pete Popov <ppopov@embeddedalley.com>
    CC: David Hinds <dahinds@users.sourceforge.net>
    CC: "Roger C. Pao" <rpao@paonet.org>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
new file mode 100644
index 000000000000..78002ef9c0e5
--- /dev/null
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -0,0 +1,1992 @@
+
+/* Advanced  Micro Devices Inc. AMD8111E Linux Network Driver
+ * Copyright (C) 2004 Advanced Micro Devices
+ *
+ *
+ * Copyright 2001,2002 Jeff Garzik <jgarzik@mandrakesoft.com> [ 8139cp.c,tg3.c ]
+ * Copyright (C) 2001, 2002 David S. Miller (davem@redhat.com)[ tg3.c]
+ * Copyright 1996-1999 Thomas Bogendoerfer [ pcnet32.c ]
+ * Derived from the lance driver written 1993,1994,1995 by Donald Becker.
+ * Copyright 1993 United States Government as represented by the
+ *	Director, National Security Agency.[ pcnet32.c ]
+ * Carsten Langgaard, carstenl@mips.com [ pcnet32.c ]
+ * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ * USA
+
+Module Name:
+
+	amd8111e.c
+
+Abstract:
+
+ 	 AMD8111 based 10/100 Ethernet Controller Driver.
+
+Environment:
+
+	Kernel Mode
+
+Revision History:
+ 	3.0.0
+	   Initial Revision.
+	3.0.1
+	 1. Dynamic interrupt coalescing.
+	 2. Removed prev_stats.
+	 3. MII support.
+	 4. Dynamic IPG support
+	3.0.2  05/29/2003
+	 1. Bug fix: Fixed failure to send jumbo packets larger than 4k.
+	 2. Bug fix: Fixed VLAN support failure.
+	 3. Bug fix: Fixed receive interrupt coalescing bug.
+	 4. Dynamic IPG support is disabled by default.
+	3.0.3 06/05/2003
+	 1. Bug fix: Fixed failure to close the interface if SMP is enabled.
+	3.0.4 12/09/2003
+	 1. Added set_mac_address routine for bonding driver support.
+	 2. Tested the driver for bonding support
+	 3. Bug fix: Fixed mismach in actual receive buffer lenth and lenth
+	    indicated to the h/w.
+	 4. Modified amd8111e_rx() routine to receive all the received packets
+	    in the first interrupt.
+	 5. Bug fix: Corrected  rx_errors  reported in get_stats() function.
+	3.0.5 03/22/2004
+	 1. Added NAPI support
+
+*/
+
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/compiler.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/if_vlan.h>
+#include <linux/ctype.h>
+#include <linux/crc32.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/byteorder.h>
+#include <asm/uaccess.h>
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+#define AMD8111E_VLAN_TAG_USED 1
+#else
+#define AMD8111E_VLAN_TAG_USED 0
+#endif
+
+#include "amd8111e.h"
+#define MODULE_NAME	"amd8111e"
+#define MODULE_VERS	"3.0.7"
+MODULE_AUTHOR("Advanced Micro Devices, Inc.");
+MODULE_DESCRIPTION ("AMD8111 based 10/100 Ethernet Controller. Driver Version "MODULE_VERS);
+MODULE_LICENSE("GPL");
+MODULE_DEVICE_TABLE(pci, amd8111e_pci_tbl);
+module_param_array(speed_duplex, int, NULL, 0);
+MODULE_PARM_DESC(speed_duplex, "Set device speed and duplex modes, 0: Auto Negotiate, 1: 10Mbps Half Duplex, 2: 10Mbps Full Duplex, 3: 100Mbps Half Duplex, 4: 100Mbps Full Duplex");
+module_param_array(coalesce, bool, NULL, 0);
+MODULE_PARM_DESC(coalesce, "Enable or Disable interrupt coalescing, 1: Enable, 0: Disable");
+module_param_array(dynamic_ipg, bool, NULL, 0);
+MODULE_PARM_DESC(dynamic_ipg, "Enable or Disable dynamic IPG, 1: Enable, 0: Disable");
+
+static DEFINE_PCI_DEVICE_TABLE(amd8111e_pci_tbl) = {
+
+	{ PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD8111E_7462,
+	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ 0, }
+
+};
+/*
+This function will read the PHY registers.
+*/
+static int amd8111e_read_phy(struct amd8111e_priv* lp, int phy_id, int reg, u32* val)
+{
+	void __iomem *mmio = lp->mmio;
+	unsigned int reg_val;
+	unsigned int repeat= REPEAT_CNT;
+
+	reg_val = readl(mmio + PHY_ACCESS);
+	while (reg_val & PHY_CMD_ACTIVE)
+		reg_val = readl( mmio + PHY_ACCESS );
+
+	writel( PHY_RD_CMD | ((phy_id & 0x1f) << 21) |
+			   ((reg & 0x1f) << 16),  mmio +PHY_ACCESS);
+	do{
+		reg_val = readl(mmio + PHY_ACCESS);
+		udelay(30);  /* It takes 30 us to read/write data */
+	} while (--repeat && (reg_val & PHY_CMD_ACTIVE));
+	if(reg_val & PHY_RD_ERR)
+		goto err_phy_read;
+
+	*val = reg_val & 0xffff;
+	return 0;
+err_phy_read:
+	*val = 0;
+	return -EINVAL;
+
+}
+
+/*
+This function will write into PHY registers.
+*/
+static int amd8111e_write_phy(struct amd8111e_priv* lp,int phy_id, int reg, u32 val)
+{
+	unsigned int repeat = REPEAT_CNT;
+	void __iomem *mmio = lp->mmio;
+	unsigned int reg_val;
+
+	reg_val = readl(mmio + PHY_ACCESS);
+	while (reg_val & PHY_CMD_ACTIVE)
+		reg_val = readl( mmio + PHY_ACCESS );
+
+	writel( PHY_WR_CMD | ((phy_id & 0x1f) << 21) |
+			   ((reg & 0x1f) << 16)|val, mmio + PHY_ACCESS);
+
+	do{
+		reg_val = readl(mmio + PHY_ACCESS);
+		udelay(30);  /* It takes 30 us to read/write the data */
+	} while (--repeat && (reg_val & PHY_CMD_ACTIVE));
+
+	if(reg_val & PHY_RD_ERR)
+		goto err_phy_write;
+
+	return 0;
+
+err_phy_write:
+	return -EINVAL;
+
+}
+/*
+This is the mii register read function provided to the mii interface.
+*/
+static int amd8111e_mdio_read(struct net_device * dev, int phy_id, int reg_num)
+{
+	struct amd8111e_priv* lp = netdev_priv(dev);
+	unsigned int reg_val;
+
+	amd8111e_read_phy(lp,phy_id,reg_num,&reg_val);
+	return reg_val;
+
+}
+
+/*
+This is the mii register write function provided to the mii interface.
+*/
+static void amd8111e_mdio_write(struct net_device * dev, int phy_id, int reg_num, int val)
+{
+	struct amd8111e_priv* lp = netdev_priv(dev);
+
+	amd8111e_write_phy(lp, phy_id, reg_num, val);
+}
+
+/*
+This function will set PHY speed. During initialization sets the original speed to 100 full.
+*/
+static void amd8111e_set_ext_phy(struct net_device *dev)
+{
+	struct amd8111e_priv *lp = netdev_priv(dev);
+	u32 bmcr,advert,tmp;
+
+	/* Determine mii register values to set the speed */
+	advert = amd8111e_mdio_read(dev, lp->ext_phy_addr, MII_ADVERTISE);
+	tmp = advert & ~(ADVERTISE_ALL | ADVERTISE_100BASE4);
+	switch (lp->ext_phy_option){
+
+		default:
+		case SPEED_AUTONEG: /* advertise all values */
+			tmp |= ( ADVERTISE_10HALF|ADVERTISE_10FULL|
+				ADVERTISE_100HALF|ADVERTISE_100FULL) ;
+			break;
+		case SPEED10_HALF:
+			tmp |= ADVERTISE_10HALF;
+			break;
+		case SPEED10_FULL:
+			tmp |= ADVERTISE_10FULL;
+			break;
+		case SPEED100_HALF:
+			tmp |= ADVERTISE_100HALF;
+			break;
+		case SPEED100_FULL:
+			tmp |= ADVERTISE_100FULL;
+			break;
+	}
+
+	if(advert != tmp)
+		amd8111e_mdio_write(dev, lp->ext_phy_addr, MII_ADVERTISE, tmp);
+	/* Restart auto negotiation */
+	bmcr = amd8111e_mdio_read(dev, lp->ext_phy_addr, MII_BMCR);
+	bmcr |= (BMCR_ANENABLE | BMCR_ANRESTART);
+	amd8111e_mdio_write(dev, lp->ext_phy_addr, MII_BMCR, bmcr);
+
+}
+
+/*
+This function will unmap skb->data space and will free
+all transmit and receive skbuffs.
+*/
+static int amd8111e_free_skbs(struct net_device *dev)
+{
+	struct amd8111e_priv *lp = netdev_priv(dev);
+	struct sk_buff* rx_skbuff;
+	int i;
+
+	/* Freeing transmit skbs */
+	for(i = 0; i < NUM_TX_BUFFERS; i++){
+		if(lp->tx_skbuff[i]){
+			pci_unmap_single(lp->pci_dev,lp->tx_dma_addr[i],					lp->tx_skbuff[i]->len,PCI_DMA_TODEVICE);
+			dev_kfree_skb (lp->tx_skbuff[i]);
+			lp->tx_skbuff[i] = NULL;
+			lp->tx_dma_addr[i] = 0;
+		}
+	}
+	/* Freeing previously allocated receive buffers */
+	for (i = 0; i < NUM_RX_BUFFERS; i++){
+		rx_skbuff = lp->rx_skbuff[i];
+		if(rx_skbuff != NULL){
+			pci_unmap_single(lp->pci_dev,lp->rx_dma_addr[i],
+				  lp->rx_buff_len - 2,PCI_DMA_FROMDEVICE);
+			dev_kfree_skb(lp->rx_skbuff[i]);
+			lp->rx_skbuff[i] = NULL;
+			lp->rx_dma_addr[i] = 0;
+		}
+	}
+
+	return 0;
+}
+
+/*
+This will set the receive buffer length corresponding to the mtu size of networkinterface.
+*/
+static inline void amd8111e_set_rx_buff_len(struct net_device* dev)
+{
+	struct amd8111e_priv* lp = netdev_priv(dev);
+	unsigned int mtu = dev->mtu;
+
+	if (mtu > ETH_DATA_LEN){
+		/* MTU + ethernet header + FCS
+		+ optional VLAN tag + skb reserve space 2 */
+
+		lp->rx_buff_len = mtu + ETH_HLEN + 10;
+		lp->options |= OPTION_JUMBO_ENABLE;
+	} else{
+		lp->rx_buff_len = PKT_BUFF_SZ;
+		lp->options &= ~OPTION_JUMBO_ENABLE;
+	}
+}
+
+/*
+This function will free all the previously allocated buffers, determine new receive buffer length  and will allocate new receive buffers. This function also allocates and initializes both the transmitter and receive hardware descriptors.
+ */
+static int amd8111e_init_ring(struct net_device *dev)
+{
+	struct amd8111e_priv *lp = netdev_priv(dev);
+	int i;
+
+	lp->rx_idx = lp->tx_idx = 0;
+	lp->tx_complete_idx = 0;
+	lp->tx_ring_idx = 0;
+
+
+	if(lp->opened)
+		/* Free previously allocated transmit and receive skbs */
+		amd8111e_free_skbs(dev);
+
+	else{
+		 /* allocate the tx and rx descriptors */
+	     	if((lp->tx_ring = pci_alloc_consistent(lp->pci_dev,
+			sizeof(struct amd8111e_tx_dr)*NUM_TX_RING_DR,
+			&lp->tx_ring_dma_addr)) == NULL)
+
+			goto err_no_mem;
+
+	     	if((lp->rx_ring = pci_alloc_consistent(lp->pci_dev,
+			sizeof(struct amd8111e_rx_dr)*NUM_RX_RING_DR,
+			&lp->rx_ring_dma_addr)) == NULL)
+
+			goto err_free_tx_ring;
+
+	}
+	/* Set new receive buff size */
+	amd8111e_set_rx_buff_len(dev);
+
+	/* Allocating receive  skbs */
+	for (i = 0; i < NUM_RX_BUFFERS; i++) {
+
+		if (!(lp->rx_skbuff[i] = dev_alloc_skb(lp->rx_buff_len))) {
+				/* Release previos allocated skbs */
+				for(--i; i >= 0 ;i--)
+					dev_kfree_skb(lp->rx_skbuff[i]);
+				goto err_free_rx_ring;
+		}
+		skb_reserve(lp->rx_skbuff[i],2);
+	}
+        /* Initilaizing receive descriptors */
+	for (i = 0; i < NUM_RX_BUFFERS; i++) {
+		lp->rx_dma_addr[i] = pci_map_single(lp->pci_dev,
+			lp->rx_skbuff[i]->data,lp->rx_buff_len-2, PCI_DMA_FROMDEVICE);
+
+		lp->rx_ring[i].buff_phy_addr = cpu_to_le32(lp->rx_dma_addr[i]);
+		lp->rx_ring[i].buff_count = cpu_to_le16(lp->rx_buff_len-2);
+		wmb();
+		lp->rx_ring[i].rx_flags = cpu_to_le16(OWN_BIT);
+	}
+
+	/* Initializing transmit descriptors */
+	for (i = 0; i < NUM_TX_RING_DR; i++) {
+		lp->tx_ring[i].buff_phy_addr = 0;
+		lp->tx_ring[i].tx_flags = 0;
+		lp->tx_ring[i].buff_count = 0;
+	}
+
+	return 0;
+
+err_free_rx_ring:
+
+	pci_free_consistent(lp->pci_dev,
+		sizeof(struct amd8111e_rx_dr)*NUM_RX_RING_DR,lp->rx_ring,
+		lp->rx_ring_dma_addr);
+
+err_free_tx_ring:
+
+	pci_free_consistent(lp->pci_dev,
+		 sizeof(struct amd8111e_tx_dr)*NUM_TX_RING_DR,lp->tx_ring,
+		 lp->tx_ring_dma_addr);
+
+err_no_mem:
+	return -ENOMEM;
+}
+/* This function will set the interrupt coalescing according to the input arguments */
+static int amd8111e_set_coalesce(struct net_device * dev, enum coal_mode cmod)
+{
+	unsigned int timeout;
+	unsigned int event_count;
+
+	struct amd8111e_priv *lp = netdev_priv(dev);
+	void __iomem *mmio = lp->mmio;
+	struct amd8111e_coalesce_conf * coal_conf = &lp->coal_conf;
+
+
+	switch(cmod)
+	{
+		case RX_INTR_COAL :
+			timeout = coal_conf->rx_timeout;
+			event_count = coal_conf->rx_event_count;
+			if( timeout > MAX_TIMEOUT ||
+					event_count > MAX_EVENT_COUNT )
+				return -EINVAL;
+
+			timeout = timeout * DELAY_TIMER_CONV;
+			writel(VAL0|STINTEN, mmio+INTEN0);
+			writel((u32)DLY_INT_A_R0|( event_count<< 16 )|timeout,
+							mmio+DLY_INT_A);
+			break;
+
+		case TX_INTR_COAL :
+			timeout = coal_conf->tx_timeout;
+			event_count = coal_conf->tx_event_count;
+			if( timeout > MAX_TIMEOUT ||
+					event_count > MAX_EVENT_COUNT )
+				return -EINVAL;
+
+
+			timeout = timeout * DELAY_TIMER_CONV;
+			writel(VAL0|STINTEN,mmio+INTEN0);
+			writel((u32)DLY_INT_B_T0|( event_count<< 16 )|timeout,
+							 mmio+DLY_INT_B);
+			break;
+
+		case DISABLE_COAL:
+			writel(0,mmio+STVAL);
+			writel(STINTEN, mmio+INTEN0);
+			writel(0, mmio +DLY_INT_B);
+			writel(0, mmio+DLY_INT_A);
+			break;
+		 case ENABLE_COAL:
+		       /* Start the timer */
+			writel((u32)SOFT_TIMER_FREQ, mmio+STVAL); /*  0.5 sec */
+			writel(VAL0|STINTEN, mmio+INTEN0);
+			break;
+		default:
+			break;
+
+   }
+	return 0;
+
+}
+
+/*
+This function initializes the device registers  and starts the device.
+*/
+static int amd8111e_restart(struct net_device *dev)
+{
+	struct amd8111e_priv *lp = netdev_priv(dev);
+	void __iomem *mmio = lp->mmio;
+	int i,reg_val;
+
+	/* stop the chip */
+	 writel(RUN, mmio + CMD0);
+
+	if(amd8111e_init_ring(dev))
+		return -ENOMEM;
+
+	/* enable the port manager and set auto negotiation always */
+	writel((u32) VAL1|EN_PMGR, mmio + CMD3 );
+	writel((u32)XPHYANE|XPHYRST , mmio + CTRL2);
+
+	amd8111e_set_ext_phy(dev);
+
+	/* set control registers */
+	reg_val = readl(mmio + CTRL1);
+	reg_val &= ~XMTSP_MASK;
+	writel( reg_val| XMTSP_128 | CACHE_ALIGN, mmio + CTRL1 );
+
+	/* enable interrupt */
+	writel( APINT5EN | APINT4EN | APINT3EN | APINT2EN | APINT1EN |
+		APINT0EN | MIIPDTINTEN | MCCIINTEN | MCCINTEN | MREINTEN |
+		SPNDINTEN | MPINTEN | SINTEN | STINTEN, mmio + INTEN0);
+
+	writel(VAL3 | LCINTEN | VAL1 | TINTEN0 | VAL0 | RINTEN0, mmio + INTEN0);
+
+	/* initialize tx and rx ring base addresses */
+	writel((u32)lp->tx_ring_dma_addr,mmio + XMT_RING_BASE_ADDR0);
+	writel((u32)lp->rx_ring_dma_addr,mmio+ RCV_RING_BASE_ADDR0);
+
+	writew((u32)NUM_TX_RING_DR, mmio + XMT_RING_LEN0);
+	writew((u16)NUM_RX_RING_DR, mmio + RCV_RING_LEN0);
+
+	/* set default IPG to 96 */
+	writew((u32)DEFAULT_IPG,mmio+IPG);
+	writew((u32)(DEFAULT_IPG-IFS1_DELTA), mmio + IFS1);
+
+	if(lp->options & OPTION_JUMBO_ENABLE){
+		writel((u32)VAL2|JUMBO, mmio + CMD3);
+		/* Reset REX_UFLO */
+		writel( REX_UFLO, mmio + CMD2);
+		/* Should not set REX_UFLO for jumbo frames */
+		writel( VAL0 | APAD_XMT|REX_RTRY , mmio + CMD2);
+	}else{
+		writel( VAL0 | APAD_XMT | REX_RTRY|REX_UFLO, mmio + CMD2);
+		writel((u32)JUMBO, mmio + CMD3);
+	}
+
+#if AMD8111E_VLAN_TAG_USED
+	writel((u32) VAL2|VSIZE|VL_TAG_DEL, mmio + CMD3);
+#endif
+	writel( VAL0 | APAD_XMT | REX_RTRY, mmio + CMD2 );
+
+	/* Setting the MAC address to the device */
+	for(i = 0; i < ETH_ADDR_LEN; i++)
+		writeb( dev->dev_addr[i], mmio + PADR + i );
+
+	/* Enable interrupt coalesce */
+	if(lp->options & OPTION_INTR_COAL_ENABLE){
+		printk(KERN_INFO "%s: Interrupt Coalescing Enabled.\n",
+								dev->name);
+		amd8111e_set_coalesce(dev,ENABLE_COAL);
+	}
+
+	/* set RUN bit to start the chip */
+	writel(VAL2 | RDMD0, mmio + CMD0);
+	writel(VAL0 | INTREN | RUN, mmio + CMD0);
+
+	/* To avoid PCI posting bug */
+	readl(mmio+CMD0);
+	return 0;
+}
+/*
+This function clears necessary the device registers.
+*/
+static void amd8111e_init_hw_default( struct amd8111e_priv* lp)
+{
+	unsigned int reg_val;
+	unsigned int logic_filter[2] ={0,};
+	void __iomem *mmio = lp->mmio;
+
+
+        /* stop the chip */
+	writel(RUN, mmio + CMD0);
+
+	/* AUTOPOLL0 Register *//*TBD default value is 8100 in FPS */
+	writew( 0x8100 | lp->ext_phy_addr, mmio + AUTOPOLL0);
+
+	/* Clear RCV_RING_BASE_ADDR */
+	writel(0, mmio + RCV_RING_BASE_ADDR0);
+
+	/* Clear XMT_RING_BASE_ADDR */
+	writel(0, mmio + XMT_RING_BASE_ADDR0);
+	writel(0, mmio + XMT_RING_BASE_ADDR1);
+	writel(0, mmio + XMT_RING_BASE_ADDR2);
+	writel(0, mmio + XMT_RING_BASE_ADDR3);
+
+	/* Clear CMD0  */
+	writel(CMD0_CLEAR,mmio + CMD0);
+
+	/* Clear CMD2 */
+	writel(CMD2_CLEAR, mmio +CMD2);
+
+	/* Clear CMD7 */
+	writel(CMD7_CLEAR , mmio + CMD7);
+
+	/* Clear DLY_INT_A and DLY_INT_B */
+	writel(0x0, mmio + DLY_INT_A);
+	writel(0x0, mmio + DLY_INT_B);
+
+	/* Clear FLOW_CONTROL */
+	writel(0x0, mmio + FLOW_CONTROL);
+
+	/* Clear INT0  write 1 to clear register */
+	reg_val = readl(mmio + INT0);
+	writel(reg_val, mmio + INT0);
+
+	/* Clear STVAL */
+	writel(0x0, mmio + STVAL);
+
+	/* Clear INTEN0 */
+	writel( INTEN0_CLEAR, mmio + INTEN0);
+
+	/* Clear LADRF */
+	writel(0x0 , mmio + LADRF);
+
+	/* Set SRAM_SIZE & SRAM_BOUNDARY registers  */
+	writel( 0x80010,mmio + SRAM_SIZE);
+
+	/* Clear RCV_RING0_LEN */
+	writel(0x0, mmio +  RCV_RING_LEN0);
+
+	/* Clear XMT_RING0/1/2/3_LEN */
+	writel(0x0, mmio +  XMT_RING_LEN0);
+	writel(0x0, mmio +  XMT_RING_LEN1);
+	writel(0x0, mmio +  XMT_RING_LEN2);
+	writel(0x0, mmio +  XMT_RING_LEN3);
+
+	/* Clear XMT_RING_LIMIT */
+	writel(0x0, mmio + XMT_RING_LIMIT);
+
+	/* Clear MIB */
+	writew(MIB_CLEAR, mmio + MIB_ADDR);
+
+	/* Clear LARF */
+	amd8111e_writeq(*(u64*)logic_filter,mmio+LADRF);
+
+	/* SRAM_SIZE register */
+	reg_val = readl(mmio + SRAM_SIZE);
+
+	if(lp->options & OPTION_JUMBO_ENABLE)
+		writel( VAL2|JUMBO, mmio + CMD3);
+#if AMD8111E_VLAN_TAG_USED
+	writel(VAL2|VSIZE|VL_TAG_DEL, mmio + CMD3 );
+#endif
+	/* Set default value to CTRL1 Register */
+	writel(CTRL1_DEFAULT, mmio + CTRL1);
+
+	/* To avoid PCI posting bug */
+	readl(mmio + CMD2);
+
+}
+
+/*
+This function disables the interrupt and clears all the pending
+interrupts in INT0
+ */
+static void amd8111e_disable_interrupt(struct amd8111e_priv* lp)
+{
+	u32 intr0;
+
+	/* Disable interrupt */
+	writel(INTREN, lp->mmio + CMD0);
+
+	/* Clear INT0 */
+	intr0 = readl(lp->mmio + INT0);
+	writel(intr0, lp->mmio + INT0);
+
+	/* To avoid PCI posting bug */
+	readl(lp->mmio + INT0);
+
+}
+
+/*
+This function stops the chip.
+*/
+static void amd8111e_stop_chip(struct amd8111e_priv* lp)
+{
+	writel(RUN, lp->mmio + CMD0);
+
+	/* To avoid PCI posting bug */
+	readl(lp->mmio + CMD0);
+}
+
+/*
+This function frees the  transmiter and receiver descriptor rings.
+*/
+static void amd8111e_free_ring(struct amd8111e_priv* lp)
+{
+	/* Free transmit and receive descriptor rings */
+	if(lp->rx_ring){
+		pci_free_consistent(lp->pci_dev,
+			sizeof(struct amd8111e_rx_dr)*NUM_RX_RING_DR,
+			lp->rx_ring, lp->rx_ring_dma_addr);
+		lp->rx_ring = NULL;
+	}
+
+	if(lp->tx_ring){
+		pci_free_consistent(lp->pci_dev,
+			sizeof(struct amd8111e_tx_dr)*NUM_TX_RING_DR,
+			lp->tx_ring, lp->tx_ring_dma_addr);
+
+		lp->tx_ring = NULL;
+	}
+
+}
+
+/*
+This function will free all the transmit skbs that are actually transmitted by the device. It will check the ownership of the skb before freeing the skb.
+*/
+static int amd8111e_tx(struct net_device *dev)
+{
+	struct amd8111e_priv* lp = netdev_priv(dev);
+	int tx_index = lp->tx_complete_idx & TX_RING_DR_MOD_MASK;
+	int status;
+	/* Complete all the transmit packet */
+	while (lp->tx_complete_idx != lp->tx_idx){
+		tx_index =  lp->tx_complete_idx & TX_RING_DR_MOD_MASK;
+		status = le16_to_cpu(lp->tx_ring[tx_index].tx_flags);
+
+		if(status & OWN_BIT)
+			break;	/* It still hasn't been Txed */
+
+		lp->tx_ring[tx_index].buff_phy_addr = 0;
+
+		/* We must free the original skb */
+		if (lp->tx_skbuff[tx_index]) {
+			pci_unmap_single(lp->pci_dev, lp->tx_dma_addr[tx_index],
+				  	lp->tx_skbuff[tx_index]->len,
+					PCI_DMA_TODEVICE);
+			dev_kfree_skb_irq (lp->tx_skbuff[tx_index]);
+			lp->tx_skbuff[tx_index] = NULL;
+			lp->tx_dma_addr[tx_index] = 0;
+		}
+		lp->tx_complete_idx++;
+		/*COAL update tx coalescing parameters */
+		lp->coal_conf.tx_packets++;
+		lp->coal_conf.tx_bytes +=
+			le16_to_cpu(lp->tx_ring[tx_index].buff_count);
+
+		if (netif_queue_stopped(dev) &&
+			lp->tx_complete_idx > lp->tx_idx - NUM_TX_BUFFERS +2){
+			/* The ring is no longer full, clear tbusy. */
+			/* lp->tx_full = 0; */
+			netif_wake_queue (dev);
+		}
+	}
+	return 0;
+}
+
+/* This function handles the driver receive operation in polling mode */
+static int amd8111e_rx_poll(struct napi_struct *napi, int budget)
+{
+	struct amd8111e_priv *lp = container_of(napi, struct amd8111e_priv, napi);
+	struct net_device *dev = lp->amd8111e_net_dev;
+	int rx_index = lp->rx_idx & RX_RING_DR_MOD_MASK;
+	void __iomem *mmio = lp->mmio;
+	struct sk_buff *skb,*new_skb;
+	int min_pkt_len, status;
+	unsigned int intr0;
+	int num_rx_pkt = 0;
+	short pkt_len;
+#if AMD8111E_VLAN_TAG_USED
+	short vtag;
+#endif
+	int rx_pkt_limit = budget;
+	unsigned long flags;
+
+	do{
+		/* process receive packets until we use the quota*/
+		/* If we own the next entry, it's a new packet. Send it up. */
+		while(1) {
+			status = le16_to_cpu(lp->rx_ring[rx_index].rx_flags);
+			if (status & OWN_BIT)
+				break;
+
+			/*
+			 * There is a tricky error noted by John Murphy,
+			 * <murf@perftech.com> to Russ Nelson: Even with
+			 * full-sized * buffers it's possible for a
+			 * jabber packet to use two buffers, with only
+			 * the last correctly noting the error.
+			 */
+
+			if(status & ERR_BIT) {
+				/* reseting flags */
+				lp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;
+				goto err_next_pkt;
+			}
+			/* check for STP and ENP */
+			if(!((status & STP_BIT) && (status & ENP_BIT))){
+				/* reseting flags */
+				lp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;
+				goto err_next_pkt;
+			}
+			pkt_len = le16_to_cpu(lp->rx_ring[rx_index].msg_count) - 4;
+
+#if AMD8111E_VLAN_TAG_USED
+			vtag = status & TT_MASK;
+			/*MAC will strip vlan tag*/
+			if (vtag != 0)
+				min_pkt_len =MIN_PKT_LEN - 4;
+			else
+#endif
+				min_pkt_len =MIN_PKT_LEN;
+
+			if (pkt_len < min_pkt_len) {
+				lp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;
+				lp->drv_rx_errors++;
+				goto err_next_pkt;
+			}
+			if(--rx_pkt_limit < 0)
+				goto rx_not_empty;
+			if(!(new_skb = dev_alloc_skb(lp->rx_buff_len))){
+				/* if allocation fail,
+				   ignore that pkt and go to next one */
+				lp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;
+				lp->drv_rx_errors++;
+				goto err_next_pkt;
+			}
+
+			skb_reserve(new_skb, 2);
+			skb = lp->rx_skbuff[rx_index];
+			pci_unmap_single(lp->pci_dev,lp->rx_dma_addr[rx_index],
+					 lp->rx_buff_len-2, PCI_DMA_FROMDEVICE);
+			skb_put(skb, pkt_len);
+			lp->rx_skbuff[rx_index] = new_skb;
+			lp->rx_dma_addr[rx_index] = pci_map_single(lp->pci_dev,
+								   new_skb->data,
+								   lp->rx_buff_len-2,
+								   PCI_DMA_FROMDEVICE);
+
+			skb->protocol = eth_type_trans(skb, dev);
+
+#if AMD8111E_VLAN_TAG_USED
+			if (vtag == TT_VLAN_TAGGED){
+				u16 vlan_tag = le16_to_cpu(lp->rx_ring[rx_index].tag_ctrl_info);
+				__vlan_hwaccel_put_tag(skb, vlan_tag);
+			}
+#endif
+			netif_receive_skb(skb);
+			/*COAL update rx coalescing parameters*/
+			lp->coal_conf.rx_packets++;
+			lp->coal_conf.rx_bytes += pkt_len;
+			num_rx_pkt++;
+
+		err_next_pkt:
+			lp->rx_ring[rx_index].buff_phy_addr
+				= cpu_to_le32(lp->rx_dma_addr[rx_index]);
+			lp->rx_ring[rx_index].buff_count =
+				cpu_to_le16(lp->rx_buff_len-2);
+			wmb();
+			lp->rx_ring[rx_index].rx_flags |= cpu_to_le16(OWN_BIT);
+			rx_index = (++lp->rx_idx) & RX_RING_DR_MOD_MASK;
+		}
+		/* Check the interrupt status register for more packets in the
+		   mean time. Process them since we have not used up our quota.*/
+
+		intr0 = readl(mmio + INT0);
+		/*Ack receive packets */
+		writel(intr0 & RINT0,mmio + INT0);
+
+	} while(intr0 & RINT0);
+
+	if (rx_pkt_limit > 0) {
+		/* Receive descriptor is empty now */
+		spin_lock_irqsave(&lp->lock, flags);
+		__napi_complete(napi);
+		writel(VAL0|RINTEN0, mmio + INTEN0);
+		writel(VAL2 | RDMD0, mmio + CMD0);
+		spin_unlock_irqrestore(&lp->lock, flags);
+	}
+
+rx_not_empty:
+	return num_rx_pkt;
+}
+
+/*
+This function will indicate the link status to the kernel.
+*/
+static int amd8111e_link_change(struct net_device* dev)
+{
+	struct amd8111e_priv *lp = netdev_priv(dev);
+	int status0,speed;
+
+	/* read the link change */
+     	status0 = readl(lp->mmio + STAT0);
+
+	if(status0 & LINK_STATS){
+		if(status0 & AUTONEG_COMPLETE)
+			lp->link_config.autoneg = AUTONEG_ENABLE;
+		else
+			lp->link_config.autoneg = AUTONEG_DISABLE;
+
+		if(status0 & FULL_DPLX)
+			lp->link_config.duplex = DUPLEX_FULL;
+		else
+			lp->link_config.duplex = DUPLEX_HALF;
+		speed = (status0 & SPEED_MASK) >> 7;
+		if(speed == PHY_SPEED_10)
+			lp->link_config.speed = SPEED_10;
+		else if(speed == PHY_SPEED_100)
+			lp->link_config.speed = SPEED_100;
+
+		printk(KERN_INFO "%s: Link is Up. Speed is %s Mbps %s Duplex\n",			dev->name,
+		       (lp->link_config.speed == SPEED_100) ? "100": "10",
+		       (lp->link_config.duplex == DUPLEX_FULL)? "Full": "Half");
+		netif_carrier_on(dev);
+	}
+	else{
+		lp->link_config.speed = SPEED_INVALID;
+		lp->link_config.duplex = DUPLEX_INVALID;
+		lp->link_config.autoneg = AUTONEG_INVALID;
+		printk(KERN_INFO "%s: Link is Down.\n",dev->name);
+		netif_carrier_off(dev);
+	}
+
+	return 0;
+}
+/*
+This function reads the mib counters.
+*/
+static int amd8111e_read_mib(void __iomem *mmio, u8 MIB_COUNTER)
+{
+	unsigned int  status;
+	unsigned  int data;
+	unsigned int repeat = REPEAT_CNT;
+
+	writew( MIB_RD_CMD | MIB_COUNTER, mmio + MIB_ADDR);
+	do {
+		status = readw(mmio + MIB_ADDR);
+		udelay(2);	/* controller takes MAX 2 us to get mib data */
+	}
+	while (--repeat && (status & MIB_CMD_ACTIVE));
+
+	data = readl(mmio + MIB_DATA);
+	return data;
+}
+
+/*
+ * This function reads the mib registers and returns the hardware statistics.
+ * It updates previous internal driver statistics with new values.
+ */
+static struct net_device_stats *amd8111e_get_stats(struct net_device *dev)
+{
+	struct amd8111e_priv *lp = netdev_priv(dev);
+	void __iomem *mmio = lp->mmio;
+	unsigned long flags;
+	struct net_device_stats *new_stats = &dev->stats;
+
+	if (!lp->opened)
+		return new_stats;
+	spin_lock_irqsave (&lp->lock, flags);
+
+	/* stats.rx_packets */
+	new_stats->rx_packets = amd8111e_read_mib(mmio, rcv_broadcast_pkts)+
+				amd8111e_read_mib(mmio, rcv_multicast_pkts)+
+				amd8111e_read_mib(mmio, rcv_unicast_pkts);
+
+	/* stats.tx_packets */
+	new_stats->tx_packets = amd8111e_read_mib(mmio, xmt_packets);
+
+	/*stats.rx_bytes */
+	new_stats->rx_bytes = amd8111e_read_mib(mmio, rcv_octets);
+
+	/* stats.tx_bytes */
+	new_stats->tx_bytes = amd8111e_read_mib(mmio, xmt_octets);
+
+	/* stats.rx_errors */
+	/* hw errors + errors driver reported */
+	new_stats->rx_errors = amd8111e_read_mib(mmio, rcv_undersize_pkts)+
+				amd8111e_read_mib(mmio, rcv_fragments)+
+				amd8111e_read_mib(mmio, rcv_jabbers)+
+				amd8111e_read_mib(mmio, rcv_alignment_errors)+
+				amd8111e_read_mib(mmio, rcv_fcs_errors)+
+				amd8111e_read_mib(mmio, rcv_miss_pkts)+
+				lp->drv_rx_errors;
+
+	/* stats.tx_errors */
+	new_stats->tx_errors = amd8111e_read_mib(mmio, xmt_underrun_pkts);
+
+	/* stats.rx_dropped*/
+	new_stats->rx_dropped = amd8111e_read_mib(mmio, rcv_miss_pkts);
+
+	/* stats.tx_dropped*/
+	new_stats->tx_dropped = amd8111e_read_mib(mmio,  xmt_underrun_pkts);
+
+	/* stats.multicast*/
+	new_stats->multicast = amd8111e_read_mib(mmio, rcv_multicast_pkts);
+
+	/* stats.collisions*/
+	new_stats->collisions = amd8111e_read_mib(mmio, xmt_collisions);
+
+	/* stats.rx_length_errors*/
+	new_stats->rx_length_errors =
+		amd8111e_read_mib(mmio, rcv_undersize_pkts)+
+		amd8111e_read_mib(mmio, rcv_oversize_pkts);
+
+	/* stats.rx_over_errors*/
+	new_stats->rx_over_errors = amd8111e_read_mib(mmio, rcv_miss_pkts);
+
+	/* stats.rx_crc_errors*/
+	new_stats->rx_crc_errors = amd8111e_read_mib(mmio, rcv_fcs_errors);
+
+	/* stats.rx_frame_errors*/
+	new_stats->rx_frame_errors =
+		amd8111e_read_mib(mmio, rcv_alignment_errors);
+
+	/* stats.rx_fifo_errors */
+	new_stats->rx_fifo_errors = amd8111e_read_mib(mmio, rcv_miss_pkts);
+
+	/* stats.rx_missed_errors */
+	new_stats->rx_missed_errors = amd8111e_read_mib(mmio, rcv_miss_pkts);
+
+	/* stats.tx_aborted_errors*/
+	new_stats->tx_aborted_errors =
+		amd8111e_read_mib(mmio, xmt_excessive_collision);
+
+	/* stats.tx_carrier_errors*/
+	new_stats->tx_carrier_errors =
+		amd8111e_read_mib(mmio, xmt_loss_carrier);
+
+	/* stats.tx_fifo_errors*/
+	new_stats->tx_fifo_errors = amd8111e_read_mib(mmio, xmt_underrun_pkts);
+
+	/* stats.tx_window_errors*/
+	new_stats->tx_window_errors =
+		amd8111e_read_mib(mmio, xmt_late_collision);
+
+	/* Reset the mibs for collecting new statistics */
+	/* writew(MIB_CLEAR, mmio + MIB_ADDR);*/
+
+	spin_unlock_irqrestore (&lp->lock, flags);
+
+	return new_stats;
+}
+/* This function recalculate the interrupt coalescing  mode on every interrupt
+according to the datarate and the packet rate.
+*/
+static int amd8111e_calc_coalesce(struct net_device *dev)
+{
+	struct amd8111e_priv *lp = netdev_priv(dev);
+	struct amd8111e_coalesce_conf * coal_conf = &lp->coal_conf;
+	int tx_pkt_rate;
+	int rx_pkt_rate;
+	int tx_data_rate;
+	int rx_data_rate;
+	int rx_pkt_size;
+	int tx_pkt_size;
+
+	tx_pkt_rate = coal_conf->tx_packets - coal_conf->tx_prev_packets;
+	coal_conf->tx_prev_packets =  coal_conf->tx_packets;
+
+	tx_data_rate = coal_conf->tx_bytes - coal_conf->tx_prev_bytes;
+	coal_conf->tx_prev_bytes =  coal_conf->tx_bytes;
+
+	rx_pkt_rate = coal_conf->rx_packets - coal_conf->rx_prev_packets;
+	coal_conf->rx_prev_packets =  coal_conf->rx_packets;
+
+	rx_data_rate = coal_conf->rx_bytes - coal_conf->rx_prev_bytes;
+	coal_conf->rx_prev_bytes =  coal_conf->rx_bytes;
+
+	if(rx_pkt_rate < 800){
+		if(coal_conf->rx_coal_type != NO_COALESCE){
+
+			coal_conf->rx_timeout = 0x0;
+			coal_conf->rx_event_count = 0;
+			amd8111e_set_coalesce(dev,RX_INTR_COAL);
+			coal_conf->rx_coal_type = NO_COALESCE;
+		}
+	}
+	else{
+
+		rx_pkt_size = rx_data_rate/rx_pkt_rate;
+		if (rx_pkt_size < 128){
+			if(coal_conf->rx_coal_type != NO_COALESCE){
+
+				coal_conf->rx_timeout = 0;
+				coal_conf->rx_event_count = 0;
+				amd8111e_set_coalesce(dev,RX_INTR_COAL);
+				coal_conf->rx_coal_type = NO_COALESCE;
+			}
+
+		}
+		else if ( (rx_pkt_size >= 128) && (rx_pkt_size < 512) ){
+
+			if(coal_conf->rx_coal_type !=  LOW_COALESCE){
+				coal_conf->rx_timeout = 1;
+				coal_conf->rx_event_count = 4;
+				amd8111e_set_coalesce(dev,RX_INTR_COAL);
+				coal_conf->rx_coal_type = LOW_COALESCE;
+			}
+		}
+		else if ((rx_pkt_size >= 512) && (rx_pkt_size < 1024)){
+
+			if(coal_conf->rx_coal_type !=  MEDIUM_COALESCE){
+				coal_conf->rx_timeout = 1;
+				coal_conf->rx_event_count = 4;
+				amd8111e_set_coalesce(dev,RX_INTR_COAL);
+				coal_conf->rx_coal_type = MEDIUM_COALESCE;
+			}
+
+		}
+		else if(rx_pkt_size >= 1024){
+			if(coal_conf->rx_coal_type !=  HIGH_COALESCE){
+				coal_conf->rx_timeout = 2;
+				coal_conf->rx_event_count = 3;
+				amd8111e_set_coalesce(dev,RX_INTR_COAL);
+				coal_conf->rx_coal_type = HIGH_COALESCE;
+			}
+		}
+	}
+    	/* NOW FOR TX INTR COALESC */
+	if(tx_pkt_rate < 800){
+		if(coal_conf->tx_coal_type != NO_COALESCE){
+
+			coal_conf->tx_timeout = 0x0;
+			coal_conf->tx_event_count = 0;
+			amd8111e_set_coalesce(dev,TX_INTR_COAL);
+			coal_conf->tx_coal_type = NO_COALESCE;
+		}
+	}
+	else{
+
+		tx_pkt_size = tx_data_rate/tx_pkt_rate;
+		if (tx_pkt_size < 128){
+
+			if(coal_conf->tx_coal_type != NO_COALESCE){
+
+				coal_conf->tx_timeout = 0;
+				coal_conf->tx_event_count = 0;
+				amd8111e_set_coalesce(dev,TX_INTR_COAL);
+				coal_conf->tx_coal_type = NO_COALESCE;
+			}
+
+		}
+		else if ( (tx_pkt_size >= 128) && (tx_pkt_size < 512) ){
+
+			if(coal_conf->tx_coal_type !=  LOW_COALESCE){
+				coal_conf->tx_timeout = 1;
+				coal_conf->tx_event_count = 2;
+				amd8111e_set_coalesce(dev,TX_INTR_COAL);
+				coal_conf->tx_coal_type = LOW_COALESCE;
+
+			}
+		}
+		else if ((tx_pkt_size >= 512) && (tx_pkt_size < 1024)){
+
+			if(coal_conf->tx_coal_type !=  MEDIUM_COALESCE){
+				coal_conf->tx_timeout = 2;
+				coal_conf->tx_event_count = 5;
+				amd8111e_set_coalesce(dev,TX_INTR_COAL);
+				coal_conf->tx_coal_type = MEDIUM_COALESCE;
+			}
+
+		}
+		else if(tx_pkt_size >= 1024){
+			if (tx_pkt_size >= 1024){
+				if(coal_conf->tx_coal_type !=  HIGH_COALESCE){
+					coal_conf->tx_timeout = 4;
+					coal_conf->tx_event_count = 8;
+					amd8111e_set_coalesce(dev,TX_INTR_COAL);
+					coal_conf->tx_coal_type = HIGH_COALESCE;
+				}
+			}
+		}
+	}
+	return 0;
+
+}
+/*
+This is device interrupt function. It handles transmit, receive,link change and hardware timer interrupts.
+*/
+static irqreturn_t amd8111e_interrupt(int irq, void *dev_id)
+{
+
+	struct net_device * dev = (struct net_device *) dev_id;
+	struct amd8111e_priv *lp = netdev_priv(dev);
+	void __iomem *mmio = lp->mmio;
+	unsigned int intr0, intren0;
+	unsigned int handled = 1;
+
+	if(unlikely(dev == NULL))
+		return IRQ_NONE;
+
+	spin_lock(&lp->lock);
+
+	/* disabling interrupt */
+	writel(INTREN, mmio + CMD0);
+
+	/* Read interrupt status */
+	intr0 = readl(mmio + INT0);
+	intren0 = readl(mmio + INTEN0);
+
+	/* Process all the INT event until INTR bit is clear. */
+
+	if (!(intr0 & INTR)){
+		handled = 0;
+		goto err_no_interrupt;
+	}
+
+	/* Current driver processes 4 interrupts : RINT,TINT,LCINT,STINT */
+	writel(intr0, mmio + INT0);
+
+	/* Check if Receive Interrupt has occurred. */
+	if (intr0 & RINT0) {
+		if (napi_schedule_prep(&lp->napi)) {
+			/* Disable receive interupts */
+			writel(RINTEN0, mmio + INTEN0);
+			/* Schedule a polling routine */
+			__napi_schedule(&lp->napi);
+		} else if (intren0 & RINTEN0) {
+			printk("************Driver bug! interrupt while in poll\n");
+			/* Fix by disable receive interrupts */
+			writel(RINTEN0, mmio + INTEN0);
+		}
+	}
+
+	/* Check if  Transmit Interrupt has occurred. */
+	if (intr0 & TINT0)
+		amd8111e_tx(dev);
+
+	/* Check if  Link Change Interrupt has occurred. */
+	if (intr0 & LCINT)
+		amd8111e_link_change(dev);
+
+	/* Check if Hardware Timer Interrupt has occurred. */
+	if (intr0 & STINT)
+		amd8111e_calc_coalesce(dev);
+
+err_no_interrupt:
+	writel( VAL0 | INTREN,mmio + CMD0);
+
+	spin_unlock(&lp->lock);
+
+	return IRQ_RETVAL(handled);
+}
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+static void amd8111e_poll(struct net_device *dev)
+{
+	unsigned long flags;
+	local_irq_save(flags);
+	amd8111e_interrupt(0, dev);
+	local_irq_restore(flags);
+}
+#endif
+
+
+/*
+This function closes the network interface and updates the statistics so that most recent statistics will be available after the interface is down.
+*/
+static int amd8111e_close(struct net_device * dev)
+{
+	struct amd8111e_priv *lp = netdev_priv(dev);
+	netif_stop_queue(dev);
+
+	napi_disable(&lp->napi);
+
+	spin_lock_irq(&lp->lock);
+
+	amd8111e_disable_interrupt(lp);
+	amd8111e_stop_chip(lp);
+
+	/* Free transmit and receive skbs */
+	amd8111e_free_skbs(lp->amd8111e_net_dev);
+
+	netif_carrier_off(lp->amd8111e_net_dev);
+
+	/* Delete ipg timer */
+	if(lp->options & OPTION_DYN_IPG_ENABLE)
+		del_timer_sync(&lp->ipg_data.ipg_timer);
+
+	spin_unlock_irq(&lp->lock);
+	free_irq(dev->irq, dev);
+	amd8111e_free_ring(lp);
+
+	/* Update the statistics before closing */
+	amd8111e_get_stats(dev);
+	lp->opened = 0;
+	return 0;
+}
+/* This function opens new interface.It requests irq for the device, initializes the device,buffers and descriptors, and starts the device.
+*/
+static int amd8111e_open(struct net_device * dev )
+{
+	struct amd8111e_priv *lp = netdev_priv(dev);
+
+	if(dev->irq ==0 || request_irq(dev->irq, amd8111e_interrupt, IRQF_SHARED,
+					 dev->name, dev))
+		return -EAGAIN;
+
+	napi_enable(&lp->napi);
+
+	spin_lock_irq(&lp->lock);
+
+	amd8111e_init_hw_default(lp);
+
+	if(amd8111e_restart(dev)){
+		spin_unlock_irq(&lp->lock);
+		napi_disable(&lp->napi);
+		if (dev->irq)
+			free_irq(dev->irq, dev);
+		return -ENOMEM;
+	}
+	/* Start ipg timer */
+	if(lp->options & OPTION_DYN_IPG_ENABLE){
+		add_timer(&lp->ipg_data.ipg_timer);
+		printk(KERN_INFO "%s: Dynamic IPG Enabled.\n",dev->name);
+	}
+
+	lp->opened = 1;
+
+	spin_unlock_irq(&lp->lock);
+
+	netif_start_queue(dev);
+
+	return 0;
+}
+/*
+This function checks if there is any transmit  descriptors available to queue more packet.
+*/
+static int amd8111e_tx_queue_avail(struct amd8111e_priv* lp )
+{
+	int tx_index = lp->tx_idx & TX_BUFF_MOD_MASK;
+	if (lp->tx_skbuff[tx_index])
+		return -1;
+	else
+		return 0;
+
+}
+/*
+This function will queue the transmit packets to the descriptors and will trigger the send operation. It also initializes the transmit descriptors with buffer physical address, byte count, ownership to hardware etc.
+*/
+
+static netdev_tx_t amd8111e_start_xmit(struct sk_buff *skb,
+				       struct net_device * dev)
+{
+	struct amd8111e_priv *lp = netdev_priv(dev);
+	int tx_index;
+	unsigned long flags;
+
+	spin_lock_irqsave(&lp->lock, flags);
+
+	tx_index = lp->tx_idx & TX_RING_DR_MOD_MASK;
+
+	lp->tx_ring[tx_index].buff_count = cpu_to_le16(skb->len);
+
+	lp->tx_skbuff[tx_index] = skb;
+	lp->tx_ring[tx_index].tx_flags = 0;
+
+#if AMD8111E_VLAN_TAG_USED
+	if (vlan_tx_tag_present(skb)) {
+		lp->tx_ring[tx_index].tag_ctrl_cmd |=
+				cpu_to_le16(TCC_VLAN_INSERT);
+		lp->tx_ring[tx_index].tag_ctrl_info =
+				cpu_to_le16(vlan_tx_tag_get(skb));
+
+	}
+#endif
+	lp->tx_dma_addr[tx_index] =
+	    pci_map_single(lp->pci_dev, skb->data, skb->len, PCI_DMA_TODEVICE);
+	lp->tx_ring[tx_index].buff_phy_addr =
+	    cpu_to_le32(lp->tx_dma_addr[tx_index]);
+
+	/*  Set FCS and LTINT bits */
+	wmb();
+	lp->tx_ring[tx_index].tx_flags |=
+	    cpu_to_le16(OWN_BIT | STP_BIT | ENP_BIT|ADD_FCS_BIT|LTINT_BIT);
+
+	lp->tx_idx++;
+
+	/* Trigger an immediate send poll. */
+	writel( VAL1 | TDMD0, lp->mmio + CMD0);
+	writel( VAL2 | RDMD0,lp->mmio + CMD0);
+
+	if(amd8111e_tx_queue_avail(lp) < 0){
+		netif_stop_queue(dev);
+	}
+	spin_unlock_irqrestore(&lp->lock, flags);
+	return NETDEV_TX_OK;
+}
+/*
+This function returns all the memory mapped registers of the device.
+*/
+static void amd8111e_read_regs(struct amd8111e_priv *lp, u32 *buf)
+{
+	void __iomem *mmio = lp->mmio;
+	/* Read only necessary registers */
+	buf[0] = readl(mmio + XMT_RING_BASE_ADDR0);
+	buf[1] = readl(mmio + XMT_RING_LEN0);
+	buf[2] = readl(mmio + RCV_RING_BASE_ADDR0);
+	buf[3] = readl(mmio + RCV_RING_LEN0);
+	buf[4] = readl(mmio + CMD0);
+	buf[5] = readl(mmio + CMD2);
+	buf[6] = readl(mmio + CMD3);
+	buf[7] = readl(mmio + CMD7);
+	buf[8] = readl(mmio + INT0);
+	buf[9] = readl(mmio + INTEN0);
+	buf[10] = readl(mmio + LADRF);
+	buf[11] = readl(mmio + LADRF+4);
+	buf[12] = readl(mmio + STAT0);
+}
+
+
+/*
+This function sets promiscuos mode, all-multi mode or the multicast address
+list to the device.
+*/
+static void amd8111e_set_multicast_list(struct net_device *dev)
+{
+	struct netdev_hw_addr *ha;
+	struct amd8111e_priv *lp = netdev_priv(dev);
+	u32 mc_filter[2] ;
+	int bit_num;
+
+	if(dev->flags & IFF_PROMISC){
+		writel( VAL2 | PROM, lp->mmio + CMD2);
+		return;
+	}
+	else
+		writel( PROM, lp->mmio + CMD2);
+	if (dev->flags & IFF_ALLMULTI ||
+	    netdev_mc_count(dev) > MAX_FILTER_SIZE) {
+		/* get all multicast packet */
+		mc_filter[1] = mc_filter[0] = 0xffffffff;
+		lp->options |= OPTION_MULTICAST_ENABLE;
+		amd8111e_writeq(*(u64*)mc_filter,lp->mmio + LADRF);
+		return;
+	}
+	if (netdev_mc_empty(dev)) {
+		/* get only own packets */
+		mc_filter[1] = mc_filter[0] = 0;
+		lp->options &= ~OPTION_MULTICAST_ENABLE;
+		amd8111e_writeq(*(u64*)mc_filter,lp->mmio + LADRF);
+		/* disable promiscuous mode */
+		writel(PROM, lp->mmio + CMD2);
+		return;
+	}
+	/* load all the multicast addresses in the logic filter */
+	lp->options |= OPTION_MULTICAST_ENABLE;
+	mc_filter[1] = mc_filter[0] = 0;
+	netdev_for_each_mc_addr(ha, dev) {
+		bit_num = (ether_crc_le(ETH_ALEN, ha->addr) >> 26) & 0x3f;
+		mc_filter[bit_num >> 5] |= 1 << (bit_num & 31);
+	}
+	amd8111e_writeq(*(u64*)mc_filter,lp->mmio+ LADRF);
+
+	/* To eliminate PCI posting bug */
+	readl(lp->mmio + CMD2);
+
+}
+
+static void amd8111e_get_drvinfo(struct net_device* dev, struct ethtool_drvinfo *info)
+{
+	struct amd8111e_priv *lp = netdev_priv(dev);
+	struct pci_dev *pci_dev = lp->pci_dev;
+	strcpy (info->driver, MODULE_NAME);
+	strcpy (info->version, MODULE_VERS);
+	sprintf(info->fw_version,"%u",chip_version);
+	strcpy (info->bus_info, pci_name(pci_dev));
+}
+
+static int amd8111e_get_regs_len(struct net_device *dev)
+{
+	return AMD8111E_REG_DUMP_LEN;
+}
+
+static void amd8111e_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *buf)
+{
+	struct amd8111e_priv *lp = netdev_priv(dev);
+	regs->version = 0;
+	amd8111e_read_regs(lp, buf);
+}
+
+static int amd8111e_get_settings(struct net_device *dev, struct ethtool_cmd *ecmd)
+{
+	struct amd8111e_priv *lp = netdev_priv(dev);
+	spin_lock_irq(&lp->lock);
+	mii_ethtool_gset(&lp->mii_if, ecmd);
+	spin_unlock_irq(&lp->lock);
+	return 0;
+}
+
+static int amd8111e_set_settings(struct net_device *dev, struct ethtool_cmd *ecmd)
+{
+	struct amd8111e_priv *lp = netdev_priv(dev);
+	int res;
+	spin_lock_irq(&lp->lock);
+	res = mii_ethtool_sset(&lp->mii_if, ecmd);
+	spin_unlock_irq(&lp->lock);
+	return res;
+}
+
+static int amd8111e_nway_reset(struct net_device *dev)
+{
+	struct amd8111e_priv *lp = netdev_priv(dev);
+	return mii_nway_restart(&lp->mii_if);
+}
+
+static u32 amd8111e_get_link(struct net_device *dev)
+{
+	struct amd8111e_priv *lp = netdev_priv(dev);
+	return mii_link_ok(&lp->mii_if);
+}
+
+static void amd8111e_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol_info)
+{
+	struct amd8111e_priv *lp = netdev_priv(dev);
+	wol_info->supported = WAKE_MAGIC|WAKE_PHY;
+	if (lp->options & OPTION_WOL_ENABLE)
+		wol_info->wolopts = WAKE_MAGIC;
+}
+
+static int amd8111e_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol_info)
+{
+	struct amd8111e_priv *lp = netdev_priv(dev);
+	if (wol_info->wolopts & ~(WAKE_MAGIC|WAKE_PHY))
+		return -EINVAL;
+	spin_lock_irq(&lp->lock);
+	if (wol_info->wolopts & WAKE_MAGIC)
+		lp->options |=
+			(OPTION_WOL_ENABLE | OPTION_WAKE_MAGIC_ENABLE);
+	else if(wol_info->wolopts & WAKE_PHY)
+		lp->options |=
+			(OPTION_WOL_ENABLE | OPTION_WAKE_PHY_ENABLE);
+	else
+		lp->options &= ~OPTION_WOL_ENABLE;
+	spin_unlock_irq(&lp->lock);
+	return 0;
+}
+
+static const struct ethtool_ops ops = {
+	.get_drvinfo = amd8111e_get_drvinfo,
+	.get_regs_len = amd8111e_get_regs_len,
+	.get_regs = amd8111e_get_regs,
+	.get_settings = amd8111e_get_settings,
+	.set_settings = amd8111e_set_settings,
+	.nway_reset = amd8111e_nway_reset,
+	.get_link = amd8111e_get_link,
+	.get_wol = amd8111e_get_wol,
+	.set_wol = amd8111e_set_wol,
+};
+
+/*
+This function handles all the  ethtool ioctls. It gives driver info, gets/sets driver speed, gets memory mapped register values, forces auto negotiation, sets/gets WOL options for ethtool application.
+*/
+
+static int amd8111e_ioctl(struct net_device * dev , struct ifreq *ifr, int cmd)
+{
+	struct mii_ioctl_data *data = if_mii(ifr);
+	struct amd8111e_priv *lp = netdev_priv(dev);
+	int err;
+	u32 mii_regval;
+
+	switch(cmd) {
+	case SIOCGMIIPHY:
+		data->phy_id = lp->ext_phy_addr;
+
+	/* fallthru */
+	case SIOCGMIIREG:
+
+		spin_lock_irq(&lp->lock);
+		err = amd8111e_read_phy(lp, data->phy_id,
+			data->reg_num & PHY_REG_ADDR_MASK, &mii_regval);
+		spin_unlock_irq(&lp->lock);
+
+		data->val_out = mii_regval;
+		return err;
+
+	case SIOCSMIIREG:
+
+		spin_lock_irq(&lp->lock);
+		err = amd8111e_write_phy(lp, data->phy_id,
+			data->reg_num & PHY_REG_ADDR_MASK, data->val_in);
+		spin_unlock_irq(&lp->lock);
+
+		return err;
+
+	default:
+		/* do nothing */
+		break;
+	}
+	return -EOPNOTSUPP;
+}
+static int amd8111e_set_mac_address(struct net_device *dev, void *p)
+{
+	struct amd8111e_priv *lp = netdev_priv(dev);
+	int i;
+	struct sockaddr *addr = p;
+
+	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
+	spin_lock_irq(&lp->lock);
+	/* Setting the MAC address to the device */
+	for(i = 0; i < ETH_ADDR_LEN; i++)
+		writeb( dev->dev_addr[i], lp->mmio + PADR + i );
+
+	spin_unlock_irq(&lp->lock);
+
+	return 0;
+}
+
+/*
+This function changes the mtu of the device. It restarts the device  to initialize the descriptor with new receive buffers.
+*/
+static int amd8111e_change_mtu(struct net_device *dev, int new_mtu)
+{
+	struct amd8111e_priv *lp = netdev_priv(dev);
+	int err;
+
+	if ((new_mtu < AMD8111E_MIN_MTU) || (new_mtu > AMD8111E_MAX_MTU))
+		return -EINVAL;
+
+	if (!netif_running(dev)) {
+		/* new_mtu will be used
+		   when device starts netxt time */
+		dev->mtu = new_mtu;
+		return 0;
+	}
+
+	spin_lock_irq(&lp->lock);
+
+        /* stop the chip */
+	writel(RUN, lp->mmio + CMD0);
+
+	dev->mtu = new_mtu;
+
+	err = amd8111e_restart(dev);
+	spin_unlock_irq(&lp->lock);
+	if(!err)
+		netif_start_queue(dev);
+	return err;
+}
+
+static int amd8111e_enable_magicpkt(struct amd8111e_priv* lp)
+{
+	writel( VAL1|MPPLBA, lp->mmio + CMD3);
+	writel( VAL0|MPEN_SW, lp->mmio + CMD7);
+
+	/* To eliminate PCI posting bug */
+	readl(lp->mmio + CMD7);
+	return 0;
+}
+
+static int amd8111e_enable_link_change(struct amd8111e_priv* lp)
+{
+
+	/* Adapter is already stoped/suspended/interrupt-disabled */
+	writel(VAL0|LCMODE_SW,lp->mmio + CMD7);
+
+	/* To eliminate PCI posting bug */
+	readl(lp->mmio + CMD7);
+	return 0;
+}
+
+/*
+ * This function is called when a packet transmission fails to complete
+ * within a reasonable period, on the assumption that an interrupt have
+ * failed or the interface is locked up. This function will reinitialize
+ * the hardware.
+ */
+static void amd8111e_tx_timeout(struct net_device *dev)
+{
+	struct amd8111e_priv* lp = netdev_priv(dev);
+	int err;
+
+	printk(KERN_ERR "%s: transmit timed out, resetting\n",
+	 					      dev->name);
+	spin_lock_irq(&lp->lock);
+	err = amd8111e_restart(dev);
+	spin_unlock_irq(&lp->lock);
+	if(!err)
+		netif_wake_queue(dev);
+}
+static int amd8111e_suspend(struct pci_dev *pci_dev, pm_message_t state)
+{
+	struct net_device *dev = pci_get_drvdata(pci_dev);
+	struct amd8111e_priv *lp = netdev_priv(dev);
+
+	if (!netif_running(dev))
+		return 0;
+
+	/* disable the interrupt */
+	spin_lock_irq(&lp->lock);
+	amd8111e_disable_interrupt(lp);
+	spin_unlock_irq(&lp->lock);
+
+	netif_device_detach(dev);
+
+	/* stop chip */
+	spin_lock_irq(&lp->lock);
+	if(lp->options & OPTION_DYN_IPG_ENABLE)
+		del_timer_sync(&lp->ipg_data.ipg_timer);
+	amd8111e_stop_chip(lp);
+	spin_unlock_irq(&lp->lock);
+
+	if(lp->options & OPTION_WOL_ENABLE){
+		 /* enable wol */
+		if(lp->options & OPTION_WAKE_MAGIC_ENABLE)
+			amd8111e_enable_magicpkt(lp);
+		if(lp->options & OPTION_WAKE_PHY_ENABLE)
+			amd8111e_enable_link_change(lp);
+
+		pci_enable_wake(pci_dev, PCI_D3hot, 1);
+		pci_enable_wake(pci_dev, PCI_D3cold, 1);
+
+	}
+	else{
+		pci_enable_wake(pci_dev, PCI_D3hot, 0);
+		pci_enable_wake(pci_dev, PCI_D3cold, 0);
+	}
+
+	pci_save_state(pci_dev);
+	pci_set_power_state(pci_dev, PCI_D3hot);
+
+	return 0;
+}
+static int amd8111e_resume(struct pci_dev *pci_dev)
+{
+	struct net_device *dev = pci_get_drvdata(pci_dev);
+	struct amd8111e_priv *lp = netdev_priv(dev);
+
+	if (!netif_running(dev))
+		return 0;
+
+	pci_set_power_state(pci_dev, PCI_D0);
+	pci_restore_state(pci_dev);
+
+	pci_enable_wake(pci_dev, PCI_D3hot, 0);
+	pci_enable_wake(pci_dev, PCI_D3cold, 0); /* D3 cold */
+
+	netif_device_attach(dev);
+
+	spin_lock_irq(&lp->lock);
+	amd8111e_restart(dev);
+	/* Restart ipg timer */
+	if(lp->options & OPTION_DYN_IPG_ENABLE)
+		mod_timer(&lp->ipg_data.ipg_timer,
+				jiffies + IPG_CONVERGE_JIFFIES);
+	spin_unlock_irq(&lp->lock);
+
+	return 0;
+}
+
+
+static void __devexit amd8111e_remove_one(struct pci_dev *pdev)
+{
+	struct net_device *dev = pci_get_drvdata(pdev);
+	if (dev) {
+		unregister_netdev(dev);
+		iounmap(((struct amd8111e_priv *)netdev_priv(dev))->mmio);
+		free_netdev(dev);
+		pci_release_regions(pdev);
+		pci_disable_device(pdev);
+		pci_set_drvdata(pdev, NULL);
+	}
+}
+static void amd8111e_config_ipg(struct net_device* dev)
+{
+	struct amd8111e_priv *lp = netdev_priv(dev);
+	struct ipg_info* ipg_data = &lp->ipg_data;
+	void __iomem *mmio = lp->mmio;
+	unsigned int prev_col_cnt = ipg_data->col_cnt;
+	unsigned int total_col_cnt;
+	unsigned int tmp_ipg;
+
+	if(lp->link_config.duplex == DUPLEX_FULL){
+		ipg_data->ipg = DEFAULT_IPG;
+		return;
+	}
+
+	if(ipg_data->ipg_state == SSTATE){
+
+		if(ipg_data->timer_tick == IPG_STABLE_TIME){
+
+			ipg_data->timer_tick = 0;
+			ipg_data->ipg = MIN_IPG - IPG_STEP;
+			ipg_data->current_ipg = MIN_IPG;
+			ipg_data->diff_col_cnt = 0xFFFFFFFF;
+			ipg_data->ipg_state = CSTATE;
+		}
+		else
+			ipg_data->timer_tick++;
+	}
+
+	if(ipg_data->ipg_state == CSTATE){
+
+		/* Get the current collision count */
+
+		total_col_cnt = ipg_data->col_cnt =
+				amd8111e_read_mib(mmio, xmt_collisions);
+
+		if ((total_col_cnt - prev_col_cnt) <
+				(ipg_data->diff_col_cnt)){
+
+			ipg_data->diff_col_cnt =
+				total_col_cnt - prev_col_cnt ;
+
+			ipg_data->ipg = ipg_data->current_ipg;
+		}
+
+		ipg_data->current_ipg += IPG_STEP;
+
+		if (ipg_data->current_ipg <= MAX_IPG)
+			tmp_ipg = ipg_data->current_ipg;
+		else{
+			tmp_ipg = ipg_data->ipg;
+			ipg_data->ipg_state = SSTATE;
+		}
+		writew((u32)tmp_ipg, mmio + IPG);
+		writew((u32)(tmp_ipg - IFS1_DELTA), mmio + IFS1);
+	}
+	 mod_timer(&lp->ipg_data.ipg_timer, jiffies + IPG_CONVERGE_JIFFIES);
+	return;
+
+}
+
+static void __devinit amd8111e_probe_ext_phy(struct net_device* dev)
+{
+	struct amd8111e_priv *lp = netdev_priv(dev);
+	int i;
+
+	for (i = 0x1e; i >= 0; i--) {
+		u32 id1, id2;
+
+		if (amd8111e_read_phy(lp, i, MII_PHYSID1, &id1))
+			continue;
+		if (amd8111e_read_phy(lp, i, MII_PHYSID2, &id2))
+			continue;
+		lp->ext_phy_id = (id1 << 16) | id2;
+		lp->ext_phy_addr = i;
+		return;
+	}
+	lp->ext_phy_id = 0;
+	lp->ext_phy_addr = 1;
+}
+
+static const struct net_device_ops amd8111e_netdev_ops = {
+	.ndo_open		= amd8111e_open,
+	.ndo_stop		= amd8111e_close,
+	.ndo_start_xmit		= amd8111e_start_xmit,
+	.ndo_tx_timeout		= amd8111e_tx_timeout,
+	.ndo_get_stats		= amd8111e_get_stats,
+	.ndo_set_multicast_list = amd8111e_set_multicast_list,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_set_mac_address	= amd8111e_set_mac_address,
+	.ndo_do_ioctl		= amd8111e_ioctl,
+	.ndo_change_mtu		= amd8111e_change_mtu,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller	 = amd8111e_poll,
+#endif
+};
+
+static int __devinit amd8111e_probe_one(struct pci_dev *pdev,
+				  const struct pci_device_id *ent)
+{
+	int err,i,pm_cap;
+	unsigned long reg_addr,reg_len;
+	struct amd8111e_priv* lp;
+	struct net_device* dev;
+
+	err = pci_enable_device(pdev);
+	if(err){
+		printk(KERN_ERR "amd8111e: Cannot enable new PCI device, "
+			"exiting.\n");
+		return err;
+	}
+
+	if(!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)){
+		printk(KERN_ERR "amd8111e: Cannot find PCI base address, "
+		       "exiting.\n");
+		err = -ENODEV;
+		goto err_disable_pdev;
+	}
+
+	err = pci_request_regions(pdev, MODULE_NAME);
+	if(err){
+		printk(KERN_ERR "amd8111e: Cannot obtain PCI resources, "
+		       "exiting.\n");
+		goto err_disable_pdev;
+	}
+
+	pci_set_master(pdev);
+
+	/* Find power-management capability. */
+	if((pm_cap = pci_find_capability(pdev, PCI_CAP_ID_PM))==0){
+		printk(KERN_ERR "amd8111e: No Power Management capability, "
+		       "exiting.\n");
+		goto err_free_reg;
+	}
+
+	/* Initialize DMA */
+	if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) < 0) {
+		printk(KERN_ERR "amd8111e: DMA not supported,"
+			"exiting.\n");
+		goto err_free_reg;
+	}
+
+	reg_addr = pci_resource_start(pdev, 0);
+	reg_len = pci_resource_len(pdev, 0);
+
+	dev = alloc_etherdev(sizeof(struct amd8111e_priv));
+	if (!dev) {
+		printk(KERN_ERR "amd8111e: Etherdev alloc failed, exiting.\n");
+		err = -ENOMEM;
+		goto err_free_reg;
+	}
+
+	SET_NETDEV_DEV(dev, &pdev->dev);
+
+#if AMD8111E_VLAN_TAG_USED
+	dev->features |= NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX ;
+#endif
+
+	lp = netdev_priv(dev);
+	lp->pci_dev = pdev;
+	lp->amd8111e_net_dev = dev;
+	lp->pm_cap = pm_cap;
+
+	spin_lock_init(&lp->lock);
+
+	lp->mmio = ioremap(reg_addr, reg_len);
+	if (!lp->mmio) {
+		printk(KERN_ERR "amd8111e: Cannot map device registers, "
+		       "exiting\n");
+		err = -ENOMEM;
+		goto err_free_dev;
+	}
+
+	/* Initializing MAC address */
+	for(i = 0; i < ETH_ADDR_LEN; i++)
+		dev->dev_addr[i] = readb(lp->mmio + PADR + i);
+
+	/* Setting user defined parametrs */
+	lp->ext_phy_option = speed_duplex[card_idx];
+	if(coalesce[card_idx])
+		lp->options |= OPTION_INTR_COAL_ENABLE;
+	if(dynamic_ipg[card_idx++])
+		lp->options |= OPTION_DYN_IPG_ENABLE;
+
+
+	/* Initialize driver entry points */
+	dev->netdev_ops = &amd8111e_netdev_ops;
+	SET_ETHTOOL_OPS(dev, &ops);
+	dev->irq =pdev->irq;
+	dev->watchdog_timeo = AMD8111E_TX_TIMEOUT;
+	netif_napi_add(dev, &lp->napi, amd8111e_rx_poll, 32);
+
+#if AMD8111E_VLAN_TAG_USED
+	dev->features |= NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX;
+#endif
+	/* Probe the external PHY */
+	amd8111e_probe_ext_phy(dev);
+
+	/* setting mii default values */
+	lp->mii_if.dev = dev;
+	lp->mii_if.mdio_read = amd8111e_mdio_read;
+	lp->mii_if.mdio_write = amd8111e_mdio_write;
+	lp->mii_if.phy_id = lp->ext_phy_addr;
+
+	/* Set receive buffer length and set jumbo option*/
+	amd8111e_set_rx_buff_len(dev);
+
+
+	err = register_netdev(dev);
+	if (err) {
+		printk(KERN_ERR "amd8111e: Cannot register net device, "
+		       "exiting.\n");
+		goto err_iounmap;
+	}
+
+	pci_set_drvdata(pdev, dev);
+
+	/* Initialize software ipg timer */
+	if(lp->options & OPTION_DYN_IPG_ENABLE){
+		init_timer(&lp->ipg_data.ipg_timer);
+		lp->ipg_data.ipg_timer.data = (unsigned long) dev;
+		lp->ipg_data.ipg_timer.function = (void *)&amd8111e_config_ipg;
+		lp->ipg_data.ipg_timer.expires = jiffies +
+						 IPG_CONVERGE_JIFFIES;
+		lp->ipg_data.ipg = DEFAULT_IPG;
+		lp->ipg_data.ipg_state = CSTATE;
+	}
+
+	/*  display driver and device information */
+
+    	chip_version = (readl(lp->mmio + CHIPID) & 0xf0000000)>>28;
+	printk(KERN_INFO "%s: AMD-8111e Driver Version: %s\n",
+	       dev->name,MODULE_VERS);
+	printk(KERN_INFO "%s: [ Rev %x ] PCI 10/100BaseT Ethernet %pM\n",
+	       dev->name, chip_version, dev->dev_addr);
+	if (lp->ext_phy_id)
+		printk(KERN_INFO "%s: Found MII PHY ID 0x%08x at address 0x%02x\n",
+		       dev->name, lp->ext_phy_id, lp->ext_phy_addr);
+	else
+		printk(KERN_INFO "%s: Couldn't detect MII PHY, assuming address 0x01\n",
+		       dev->name);
+    	return 0;
+err_iounmap:
+	iounmap(lp->mmio);
+
+err_free_dev:
+	free_netdev(dev);
+
+err_free_reg:
+	pci_release_regions(pdev);
+
+err_disable_pdev:
+	pci_disable_device(pdev);
+	pci_set_drvdata(pdev, NULL);
+	return err;
+
+}
+
+static struct pci_driver amd8111e_driver = {
+	.name   	= MODULE_NAME,
+	.id_table	= amd8111e_pci_tbl,
+	.probe		= amd8111e_probe_one,
+	.remove		= __devexit_p(amd8111e_remove_one),
+	.suspend	= amd8111e_suspend,
+	.resume		= amd8111e_resume
+};
+
+static int __init amd8111e_init(void)
+{
+	return pci_register_driver(&amd8111e_driver);
+}
+
+static void __exit amd8111e_cleanup(void)
+{
+	pci_unregister_driver(&amd8111e_driver);
+}
+
+module_init(amd8111e_init);
+module_exit(amd8111e_cleanup);
