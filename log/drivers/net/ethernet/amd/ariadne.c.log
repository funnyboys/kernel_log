commit 0290bd291cc0e0488e35e66bf39efcd7d9d9122b
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Tue Dec 10 09:23:51 2019 -0500

    netdev: pass the stuck queue to the timeout handler
    
    This allows incrementing the correct timeout statistic without any mess.
    Down the road, devices can learn to reset just the specific queue.
    
    The patch was generated with the following script:
    
    use strict;
    use warnings;
    
    our $^I = '.bak';
    
    my @work = (
    ["arch/m68k/emu/nfeth.c", "nfeth_tx_timeout"],
    ["arch/um/drivers/net_kern.c", "uml_net_tx_timeout"],
    ["arch/um/drivers/vector_kern.c", "vector_net_tx_timeout"],
    ["arch/xtensa/platforms/iss/network.c", "iss_net_tx_timeout"],
    ["drivers/char/pcmcia/synclink_cs.c", "hdlcdev_tx_timeout"],
    ["drivers/infiniband/ulp/ipoib/ipoib_main.c", "ipoib_timeout"],
    ["drivers/infiniband/ulp/ipoib/ipoib_main.c", "ipoib_timeout"],
    ["drivers/message/fusion/mptlan.c", "mpt_lan_tx_timeout"],
    ["drivers/misc/sgi-xp/xpnet.c", "xpnet_dev_tx_timeout"],
    ["drivers/net/appletalk/cops.c", "cops_timeout"],
    ["drivers/net/arcnet/arcdevice.h", "arcnet_timeout"],
    ["drivers/net/arcnet/arcnet.c", "arcnet_timeout"],
    ["drivers/net/arcnet/com20020.c", "arcnet_timeout"],
    ["drivers/net/ethernet/3com/3c509.c", "el3_tx_timeout"],
    ["drivers/net/ethernet/3com/3c515.c", "corkscrew_timeout"],
    ["drivers/net/ethernet/3com/3c574_cs.c", "el3_tx_timeout"],
    ["drivers/net/ethernet/3com/3c589_cs.c", "el3_tx_timeout"],
    ["drivers/net/ethernet/3com/3c59x.c", "vortex_tx_timeout"],
    ["drivers/net/ethernet/3com/3c59x.c", "vortex_tx_timeout"],
    ["drivers/net/ethernet/3com/typhoon.c", "typhoon_tx_timeout"],
    ["drivers/net/ethernet/8390/8390.h", "ei_tx_timeout"],
    ["drivers/net/ethernet/8390/8390.h", "eip_tx_timeout"],
    ["drivers/net/ethernet/8390/8390.c", "ei_tx_timeout"],
    ["drivers/net/ethernet/8390/8390p.c", "eip_tx_timeout"],
    ["drivers/net/ethernet/8390/ax88796.c", "ax_ei_tx_timeout"],
    ["drivers/net/ethernet/8390/axnet_cs.c", "axnet_tx_timeout"],
    ["drivers/net/ethernet/8390/etherh.c", "__ei_tx_timeout"],
    ["drivers/net/ethernet/8390/hydra.c", "__ei_tx_timeout"],
    ["drivers/net/ethernet/8390/mac8390.c", "__ei_tx_timeout"],
    ["drivers/net/ethernet/8390/mcf8390.c", "__ei_tx_timeout"],
    ["drivers/net/ethernet/8390/lib8390.c", "__ei_tx_timeout"],
    ["drivers/net/ethernet/8390/ne2k-pci.c", "ei_tx_timeout"],
    ["drivers/net/ethernet/8390/pcnet_cs.c", "ei_tx_timeout"],
    ["drivers/net/ethernet/8390/smc-ultra.c", "ei_tx_timeout"],
    ["drivers/net/ethernet/8390/wd.c", "ei_tx_timeout"],
    ["drivers/net/ethernet/8390/zorro8390.c", "__ei_tx_timeout"],
    ["drivers/net/ethernet/adaptec/starfire.c", "tx_timeout"],
    ["drivers/net/ethernet/agere/et131x.c", "et131x_tx_timeout"],
    ["drivers/net/ethernet/allwinner/sun4i-emac.c", "emac_timeout"],
    ["drivers/net/ethernet/alteon/acenic.c", "ace_watchdog"],
    ["drivers/net/ethernet/amazon/ena/ena_netdev.c", "ena_tx_timeout"],
    ["drivers/net/ethernet/amd/7990.h", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/7990.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/a2065.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/am79c961a.c", "am79c961_timeout"],
    ["drivers/net/ethernet/amd/amd8111e.c", "amd8111e_tx_timeout"],
    ["drivers/net/ethernet/amd/ariadne.c", "ariadne_tx_timeout"],
    ["drivers/net/ethernet/amd/atarilance.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/au1000_eth.c", "au1000_tx_timeout"],
    ["drivers/net/ethernet/amd/declance.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/lance.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/mvme147.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/ni65.c", "ni65_timeout"],
    ["drivers/net/ethernet/amd/nmclan_cs.c", "mace_tx_timeout"],
    ["drivers/net/ethernet/amd/pcnet32.c", "pcnet32_tx_timeout"],
    ["drivers/net/ethernet/amd/sunlance.c", "lance_tx_timeout"],
    ["drivers/net/ethernet/amd/xgbe/xgbe-drv.c", "xgbe_tx_timeout"],
    ["drivers/net/ethernet/apm/xgene-v2/main.c", "xge_timeout"],
    ["drivers/net/ethernet/apm/xgene/xgene_enet_main.c", "xgene_enet_timeout"],
    ["drivers/net/ethernet/apple/macmace.c", "mace_tx_timeout"],
    ["drivers/net/ethernet/atheros/ag71xx.c", "ag71xx_tx_timeout"],
    ["drivers/net/ethernet/atheros/alx/main.c", "alx_tx_timeout"],
    ["drivers/net/ethernet/atheros/atl1c/atl1c_main.c", "atl1c_tx_timeout"],
    ["drivers/net/ethernet/atheros/atl1e/atl1e_main.c", "atl1e_tx_timeout"],
    ["drivers/net/ethernet/atheros/atlx/atl.c", "atlx_tx_timeout"],
    ["drivers/net/ethernet/atheros/atlx/atl1.c", "atlx_tx_timeout"],
    ["drivers/net/ethernet/atheros/atlx/atl2.c", "atl2_tx_timeout"],
    ["drivers/net/ethernet/broadcom/b44.c", "b44_tx_timeout"],
    ["drivers/net/ethernet/broadcom/bcmsysport.c", "bcm_sysport_tx_timeout"],
    ["drivers/net/ethernet/broadcom/bnx2.c", "bnx2_tx_timeout"],
    ["drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h", "bnx2x_tx_timeout"],
    ["drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c", "bnx2x_tx_timeout"],
    ["drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c", "bnx2x_tx_timeout"],
    ["drivers/net/ethernet/broadcom/bnxt/bnxt.c", "bnxt_tx_timeout"],
    ["drivers/net/ethernet/broadcom/genet/bcmgenet.c", "bcmgenet_timeout"],
    ["drivers/net/ethernet/broadcom/sb1250-mac.c", "sbmac_tx_timeout"],
    ["drivers/net/ethernet/broadcom/tg3.c", "tg3_tx_timeout"],
    ["drivers/net/ethernet/calxeda/xgmac.c", "xgmac_tx_timeout"],
    ["drivers/net/ethernet/cavium/liquidio/lio_main.c", "liquidio_tx_timeout"],
    ["drivers/net/ethernet/cavium/liquidio/lio_vf_main.c", "liquidio_tx_timeout"],
    ["drivers/net/ethernet/cavium/liquidio/lio_vf_rep.c", "lio_vf_rep_tx_timeout"],
    ["drivers/net/ethernet/cavium/thunder/nicvf_main.c", "nicvf_tx_timeout"],
    ["drivers/net/ethernet/cirrus/cs89x0.c", "net_timeout"],
    ["drivers/net/ethernet/cisco/enic/enic_main.c", "enic_tx_timeout"],
    ["drivers/net/ethernet/cisco/enic/enic_main.c", "enic_tx_timeout"],
    ["drivers/net/ethernet/cortina/gemini.c", "gmac_tx_timeout"],
    ["drivers/net/ethernet/davicom/dm9000.c", "dm9000_timeout"],
    ["drivers/net/ethernet/dec/tulip/de2104x.c", "de_tx_timeout"],
    ["drivers/net/ethernet/dec/tulip/tulip_core.c", "tulip_tx_timeout"],
    ["drivers/net/ethernet/dec/tulip/winbond-840.c", "tx_timeout"],
    ["drivers/net/ethernet/dlink/dl2k.c", "rio_tx_timeout"],
    ["drivers/net/ethernet/dlink/sundance.c", "tx_timeout"],
    ["drivers/net/ethernet/emulex/benet/be_main.c", "be_tx_timeout"],
    ["drivers/net/ethernet/ethoc.c", "ethoc_tx_timeout"],
    ["drivers/net/ethernet/faraday/ftgmac100.c", "ftgmac100_tx_timeout"],
    ["drivers/net/ethernet/fealnx.c", "fealnx_tx_timeout"],
    ["drivers/net/ethernet/freescale/dpaa/dpaa_eth.c", "dpaa_tx_timeout"],
    ["drivers/net/ethernet/freescale/fec_main.c", "fec_timeout"],
    ["drivers/net/ethernet/freescale/fec_mpc52xx.c", "mpc52xx_fec_tx_timeout"],
    ["drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c", "fs_timeout"],
    ["drivers/net/ethernet/freescale/gianfar.c", "gfar_timeout"],
    ["drivers/net/ethernet/freescale/ucc_geth.c", "ucc_geth_timeout"],
    ["drivers/net/ethernet/fujitsu/fmvj18x_cs.c", "fjn_tx_timeout"],
    ["drivers/net/ethernet/google/gve/gve_main.c", "gve_tx_timeout"],
    ["drivers/net/ethernet/hisilicon/hip04_eth.c", "hip04_timeout"],
    ["drivers/net/ethernet/hisilicon/hix5hd2_gmac.c", "hix5hd2_net_timeout"],
    ["drivers/net/ethernet/hisilicon/hns/hns_enet.c", "hns_nic_net_timeout"],
    ["drivers/net/ethernet/hisilicon/hns3/hns3_enet.c", "hns3_nic_net_timeout"],
    ["drivers/net/ethernet/huawei/hinic/hinic_main.c", "hinic_tx_timeout"],
    ["drivers/net/ethernet/i825xx/82596.c", "i596_tx_timeout"],
    ["drivers/net/ethernet/i825xx/ether1.c", "ether1_timeout"],
    ["drivers/net/ethernet/i825xx/lib82596.c", "i596_tx_timeout"],
    ["drivers/net/ethernet/i825xx/sun3_82586.c", "sun3_82586_timeout"],
    ["drivers/net/ethernet/ibm/ehea/ehea_main.c", "ehea_tx_watchdog"],
    ["drivers/net/ethernet/ibm/emac/core.c", "emac_tx_timeout"],
    ["drivers/net/ethernet/ibm/emac/core.c", "emac_tx_timeout"],
    ["drivers/net/ethernet/ibm/ibmvnic.c", "ibmvnic_tx_timeout"],
    ["drivers/net/ethernet/intel/e100.c", "e100_tx_timeout"],
    ["drivers/net/ethernet/intel/e1000/e1000_main.c", "e1000_tx_timeout"],
    ["drivers/net/ethernet/intel/e1000e/netdev.c", "e1000_tx_timeout"],
    ["drivers/net/ethernet/intel/fm10k/fm10k_netdev.c", "fm10k_tx_timeout"],
    ["drivers/net/ethernet/intel/i40e/i40e_main.c", "i40e_tx_timeout"],
    ["drivers/net/ethernet/intel/iavf/iavf_main.c", "iavf_tx_timeout"],
    ["drivers/net/ethernet/intel/ice/ice_main.c", "ice_tx_timeout"],
    ["drivers/net/ethernet/intel/ice/ice_main.c", "ice_tx_timeout"],
    ["drivers/net/ethernet/intel/igb/igb_main.c", "igb_tx_timeout"],
    ["drivers/net/ethernet/intel/igbvf/netdev.c", "igbvf_tx_timeout"],
    ["drivers/net/ethernet/intel/ixgb/ixgb_main.c", "ixgb_tx_timeout"],
    ["drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c", "adapter->netdev->netdev_ops->ndo_tx_timeout(adapter->netdev);"],
    ["drivers/net/ethernet/intel/ixgbe/ixgbe_main.c", "ixgbe_tx_timeout"],
    ["drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c", "ixgbevf_tx_timeout"],
    ["drivers/net/ethernet/jme.c", "jme_tx_timeout"],
    ["drivers/net/ethernet/korina.c", "korina_tx_timeout"],
    ["drivers/net/ethernet/lantiq_etop.c", "ltq_etop_tx_timeout"],
    ["drivers/net/ethernet/marvell/mv643xx_eth.c", "mv643xx_eth_tx_timeout"],
    ["drivers/net/ethernet/marvell/pxa168_eth.c", "pxa168_eth_tx_timeout"],
    ["drivers/net/ethernet/marvell/skge.c", "skge_tx_timeout"],
    ["drivers/net/ethernet/marvell/sky2.c", "sky2_tx_timeout"],
    ["drivers/net/ethernet/marvell/sky2.c", "sky2_tx_timeout"],
    ["drivers/net/ethernet/mediatek/mtk_eth_soc.c", "mtk_tx_timeout"],
    ["drivers/net/ethernet/mellanox/mlx4/en_netdev.c", "mlx4_en_tx_timeout"],
    ["drivers/net/ethernet/mellanox/mlx4/en_netdev.c", "mlx4_en_tx_timeout"],
    ["drivers/net/ethernet/mellanox/mlx5/core/en_main.c", "mlx5e_tx_timeout"],
    ["drivers/net/ethernet/micrel/ks8842.c", "ks8842_tx_timeout"],
    ["drivers/net/ethernet/micrel/ksz884x.c", "netdev_tx_timeout"],
    ["drivers/net/ethernet/microchip/enc28j60.c", "enc28j60_tx_timeout"],
    ["drivers/net/ethernet/microchip/encx24j600.c", "encx24j600_tx_timeout"],
    ["drivers/net/ethernet/natsemi/sonic.h", "sonic_tx_timeout"],
    ["drivers/net/ethernet/natsemi/sonic.c", "sonic_tx_timeout"],
    ["drivers/net/ethernet/natsemi/jazzsonic.c", "sonic_tx_timeout"],
    ["drivers/net/ethernet/natsemi/macsonic.c", "sonic_tx_timeout"],
    ["drivers/net/ethernet/natsemi/natsemi.c", "ns_tx_timeout"],
    ["drivers/net/ethernet/natsemi/ns83820.c", "ns83820_tx_timeout"],
    ["drivers/net/ethernet/natsemi/xtsonic.c", "sonic_tx_timeout"],
    ["drivers/net/ethernet/neterion/s2io.h", "s2io_tx_watchdog"],
    ["drivers/net/ethernet/neterion/s2io.c", "s2io_tx_watchdog"],
    ["drivers/net/ethernet/neterion/vxge/vxge-main.c", "vxge_tx_watchdog"],
    ["drivers/net/ethernet/netronome/nfp/nfp_net_common.c", "nfp_net_tx_timeout"],
    ["drivers/net/ethernet/nvidia/forcedeth.c", "nv_tx_timeout"],
    ["drivers/net/ethernet/nvidia/forcedeth.c", "nv_tx_timeout"],
    ["drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c", "pch_gbe_tx_timeout"],
    ["drivers/net/ethernet/packetengines/hamachi.c", "hamachi_tx_timeout"],
    ["drivers/net/ethernet/packetengines/yellowfin.c", "yellowfin_tx_timeout"],
    ["drivers/net/ethernet/pensando/ionic/ionic_lif.c", "ionic_tx_timeout"],
    ["drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c", "netxen_tx_timeout"],
    ["drivers/net/ethernet/qlogic/qla3xxx.c", "ql3xxx_tx_timeout"],
    ["drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c", "qlcnic_tx_timeout"],
    ["drivers/net/ethernet/qualcomm/emac/emac.c", "emac_tx_timeout"],
    ["drivers/net/ethernet/qualcomm/qca_spi.c", "qcaspi_netdev_tx_timeout"],
    ["drivers/net/ethernet/qualcomm/qca_uart.c", "qcauart_netdev_tx_timeout"],
    ["drivers/net/ethernet/rdc/r6040.c", "r6040_tx_timeout"],
    ["drivers/net/ethernet/realtek/8139cp.c", "cp_tx_timeout"],
    ["drivers/net/ethernet/realtek/8139too.c", "rtl8139_tx_timeout"],
    ["drivers/net/ethernet/realtek/atp.c", "tx_timeout"],
    ["drivers/net/ethernet/realtek/r8169_main.c", "rtl8169_tx_timeout"],
    ["drivers/net/ethernet/renesas/ravb_main.c", "ravb_tx_timeout"],
    ["drivers/net/ethernet/renesas/sh_eth.c", "sh_eth_tx_timeout"],
    ["drivers/net/ethernet/renesas/sh_eth.c", "sh_eth_tx_timeout"],
    ["drivers/net/ethernet/samsung/sxgbe/sxgbe_main.c", "sxgbe_tx_timeout"],
    ["drivers/net/ethernet/seeq/ether3.c", "ether3_timeout"],
    ["drivers/net/ethernet/seeq/sgiseeq.c", "timeout"],
    ["drivers/net/ethernet/sfc/efx.c", "efx_watchdog"],
    ["drivers/net/ethernet/sfc/falcon/efx.c", "ef4_watchdog"],
    ["drivers/net/ethernet/sgi/ioc3-eth.c", "ioc3_timeout"],
    ["drivers/net/ethernet/sgi/meth.c", "meth_tx_timeout"],
    ["drivers/net/ethernet/silan/sc92031.c", "sc92031_tx_timeout"],
    ["drivers/net/ethernet/sis/sis190.c", "sis190_tx_timeout"],
    ["drivers/net/ethernet/sis/sis900.c", "sis900_tx_timeout"],
    ["drivers/net/ethernet/smsc/epic100.c", "epic_tx_timeout"],
    ["drivers/net/ethernet/smsc/smc911x.c", "smc911x_timeout"],
    ["drivers/net/ethernet/smsc/smc9194.c", "smc_timeout"],
    ["drivers/net/ethernet/smsc/smc91c92_cs.c", "smc_tx_timeout"],
    ["drivers/net/ethernet/smsc/smc91x.c", "smc_timeout"],
    ["drivers/net/ethernet/stmicro/stmmac/stmmac_main.c", "stmmac_tx_timeout"],
    ["drivers/net/ethernet/sun/cassini.c", "cas_tx_timeout"],
    ["drivers/net/ethernet/sun/ldmvsw.c", "sunvnet_tx_timeout_common"],
    ["drivers/net/ethernet/sun/niu.c", "niu_tx_timeout"],
    ["drivers/net/ethernet/sun/sunbmac.c", "bigmac_tx_timeout"],
    ["drivers/net/ethernet/sun/sungem.c", "gem_tx_timeout"],
    ["drivers/net/ethernet/sun/sunhme.c", "happy_meal_tx_timeout"],
    ["drivers/net/ethernet/sun/sunqe.c", "qe_tx_timeout"],
    ["drivers/net/ethernet/sun/sunvnet.c", "sunvnet_tx_timeout_common"],
    ["drivers/net/ethernet/sun/sunvnet_common.c", "sunvnet_tx_timeout_common"],
    ["drivers/net/ethernet/sun/sunvnet_common.h", "sunvnet_tx_timeout_common"],
    ["drivers/net/ethernet/synopsys/dwc-xlgmac-net.c", "xlgmac_tx_timeout"],
    ["drivers/net/ethernet/ti/cpmac.c", "cpmac_tx_timeout"],
    ["drivers/net/ethernet/ti/cpsw.c", "cpsw_ndo_tx_timeout"],
    ["drivers/net/ethernet/ti/cpsw_priv.c", "cpsw_ndo_tx_timeout"],
    ["drivers/net/ethernet/ti/cpsw_priv.h", "cpsw_ndo_tx_timeout"],
    ["drivers/net/ethernet/ti/davinci_emac.c", "emac_dev_tx_timeout"],
    ["drivers/net/ethernet/ti/netcp_core.c", "netcp_ndo_tx_timeout"],
    ["drivers/net/ethernet/ti/tlan.c", "tlan_tx_timeout"],
    ["drivers/net/ethernet/toshiba/ps3_gelic_net.h", "gelic_net_tx_timeout"],
    ["drivers/net/ethernet/toshiba/ps3_gelic_net.c", "gelic_net_tx_timeout"],
    ["drivers/net/ethernet/toshiba/ps3_gelic_wireless.c", "gelic_net_tx_timeout"],
    ["drivers/net/ethernet/toshiba/spider_net.c", "spider_net_tx_timeout"],
    ["drivers/net/ethernet/toshiba/tc35815.c", "tc35815_tx_timeout"],
    ["drivers/net/ethernet/via/via-rhine.c", "rhine_tx_timeout"],
    ["drivers/net/ethernet/wiznet/w5100.c", "w5100_tx_timeout"],
    ["drivers/net/ethernet/wiznet/w5300.c", "w5300_tx_timeout"],
    ["drivers/net/ethernet/xilinx/xilinx_emaclite.c", "xemaclite_tx_timeout"],
    ["drivers/net/ethernet/xircom/xirc2ps_cs.c", "xirc_tx_timeout"],
    ["drivers/net/fjes/fjes_main.c", "fjes_tx_retry"],
    ["drivers/net/slip/slip.c", "sl_tx_timeout"],
    ["include/linux/usb/usbnet.h", "usbnet_tx_timeout"],
    ["drivers/net/usb/aqc111.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/asix_devices.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/asix_devices.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/asix_devices.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/ax88172a.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/ax88179_178a.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/catc.c", "catc_tx_timeout"],
    ["drivers/net/usb/cdc_mbim.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/cdc_ncm.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/dm9601.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/hso.c", "hso_net_tx_timeout"],
    ["drivers/net/usb/int51x1.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/ipheth.c", "ipheth_tx_timeout"],
    ["drivers/net/usb/kaweth.c", "kaweth_tx_timeout"],
    ["drivers/net/usb/lan78xx.c", "lan78xx_tx_timeout"],
    ["drivers/net/usb/mcs7830.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/pegasus.c", "pegasus_tx_timeout"],
    ["drivers/net/usb/qmi_wwan.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/r8152.c", "rtl8152_tx_timeout"],
    ["drivers/net/usb/rndis_host.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/rtl8150.c", "rtl8150_tx_timeout"],
    ["drivers/net/usb/sierra_net.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/smsc75xx.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/smsc95xx.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/sr9700.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/sr9800.c", "usbnet_tx_timeout"],
    ["drivers/net/usb/usbnet.c", "usbnet_tx_timeout"],
    ["drivers/net/vmxnet3/vmxnet3_drv.c", "vmxnet3_tx_timeout"],
    ["drivers/net/wan/cosa.c", "cosa_net_timeout"],
    ["drivers/net/wan/farsync.c", "fst_tx_timeout"],
    ["drivers/net/wan/fsl_ucc_hdlc.c", "uhdlc_tx_timeout"],
    ["drivers/net/wan/lmc/lmc_main.c", "lmc_driver_timeout"],
    ["drivers/net/wan/x25_asy.c", "x25_asy_timeout"],
    ["drivers/net/wimax/i2400m/netdev.c", "i2400m_tx_timeout"],
    ["drivers/net/wireless/intel/ipw2x00/ipw2100.c", "ipw2100_tx_timeout"],
    ["drivers/net/wireless/intersil/hostap/hostap_main.c", "prism2_tx_timeout"],
    ["drivers/net/wireless/intersil/hostap/hostap_main.c", "prism2_tx_timeout"],
    ["drivers/net/wireless/intersil/hostap/hostap_main.c", "prism2_tx_timeout"],
    ["drivers/net/wireless/intersil/orinoco/main.c", "orinoco_tx_timeout"],
    ["drivers/net/wireless/intersil/orinoco/orinoco_usb.c", "orinoco_tx_timeout"],
    ["drivers/net/wireless/intersil/orinoco/orinoco.h", "orinoco_tx_timeout"],
    ["drivers/net/wireless/intersil/prism54/islpci_dev.c", "islpci_eth_tx_timeout"],
    ["drivers/net/wireless/intersil/prism54/islpci_eth.c", "islpci_eth_tx_timeout"],
    ["drivers/net/wireless/intersil/prism54/islpci_eth.h", "islpci_eth_tx_timeout"],
    ["drivers/net/wireless/marvell/mwifiex/main.c", "mwifiex_tx_timeout"],
    ["drivers/net/wireless/quantenna/qtnfmac/core.c", "qtnf_netdev_tx_timeout"],
    ["drivers/net/wireless/quantenna/qtnfmac/core.h", "qtnf_netdev_tx_timeout"],
    ["drivers/net/wireless/rndis_wlan.c", "usbnet_tx_timeout"],
    ["drivers/net/wireless/wl3501_cs.c", "wl3501_tx_timeout"],
    ["drivers/net/wireless/zydas/zd1201.c", "zd1201_tx_timeout"],
    ["drivers/s390/net/qeth_core.h", "qeth_tx_timeout"],
    ["drivers/s390/net/qeth_core_main.c", "qeth_tx_timeout"],
    ["drivers/s390/net/qeth_l2_main.c", "qeth_tx_timeout"],
    ["drivers/s390/net/qeth_l2_main.c", "qeth_tx_timeout"],
    ["drivers/s390/net/qeth_l3_main.c", "qeth_tx_timeout"],
    ["drivers/s390/net/qeth_l3_main.c", "qeth_tx_timeout"],
    ["drivers/staging/ks7010/ks_wlan_net.c", "ks_wlan_tx_timeout"],
    ["drivers/staging/qlge/qlge_main.c", "qlge_tx_timeout"],
    ["drivers/staging/rtl8192e/rtl8192e/rtl_core.c", "_rtl92e_tx_timeout"],
    ["drivers/staging/rtl8192u/r8192U_core.c", "tx_timeout"],
    ["drivers/staging/unisys/visornic/visornic_main.c", "visornic_xmit_timeout"],
    ["drivers/staging/wlan-ng/p80211netdev.c", "p80211knetdev_tx_timeout"],
    ["drivers/tty/n_gsm.c", "gsm_mux_net_tx_timeout"],
    ["drivers/tty/synclink.c", "hdlcdev_tx_timeout"],
    ["drivers/tty/synclink_gt.c", "hdlcdev_tx_timeout"],
    ["drivers/tty/synclinkmp.c", "hdlcdev_tx_timeout"],
    ["net/atm/lec.c", "lec_tx_timeout"],
    ["net/bluetooth/bnep/netdev.c", "bnep_net_timeout"]
    );
    
    for my $p (@work) {
            my @pair = @$p;
            my $file = $pair[0];
            my $func = $pair[1];
            print STDERR $file , ": ", $func,"\n";
            our @ARGV = ($file);
            while (<ARGV>) {
                    if (m/($func\s*\(struct\s+net_device\s+\*[A-Za-z_]?[A-Za-z-0-9_]*)(\))/) {
                            print STDERR "found $1+$2 in $file\n";
                    }
                    if (s/($func\s*\(struct\s+net_device\s+\*[A-Za-z_]?[A-Za-z-0-9_]*)(\))/$1, unsigned int txqueue$2/) {
                            print STDERR "$func found in $file\n";
                    }
                    print;
            }
    }
    
    where the list of files and functions is simply from:
    
    git grep ndo_tx_timeout, with manual addition of headers
    in the rare cases where the function is from a header,
    then manually changing the few places which actually
    call ndo_tx_timeout.
    
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Acked-by: Heiner Kallweit <hkallweit1@gmail.com>
    Acked-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Acked-by: Shannon Nelson <snelson@pensando.io>
    Reviewed-by: Martin Habets <mhabets@solarflare.com>
    
    changes from v9:
            fixup a forward declaration
    changes from v9:
            more leftovers from v3 change
    changes from v8:
            fix up a missing direct call to timeout
            rebased on net-next
    changes from v7:
            fixup leftovers from v3 change
    changes from v6:
            fix typo in rtl driver
    changes from v5:
            add missing files (allow any net device argument name)
    changes from v4:
            add a missing driver header
    changes from v3:
            change queue # to unsigned
    Changes from v2:
            added headers
    Changes from v1:
            Fix errors found by kbuild:
            generalize the pattern a bit, to pick up
            a couple of instances missed by the previous
            version.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/ariadne.c b/drivers/net/ethernet/amd/ariadne.c
index 4b6a5cb85dd2..5e0f645f5bde 100644
--- a/drivers/net/ethernet/amd/ariadne.c
+++ b/drivers/net/ethernet/amd/ariadne.c
@@ -530,7 +530,7 @@ static inline void ariadne_reset(struct net_device *dev)
 	netif_start_queue(dev);
 }
 
-static void ariadne_tx_timeout(struct net_device *dev)
+static void ariadne_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	volatile struct Am79C960 *lance = (struct Am79C960 *)dev->base_addr;
 

commit 153890b41b0ad467a89a77d48bb96f6bc3b14120
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Tue Aug 22 23:41:12 2017 +0530

    net: amd: constify zorro_device_id
    
    zorro_device_id are not supposed to change at runtime. All functions
    working with zorro_device_id provided by <linux/zorro.h> work with
    const zorro_device_id. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/ariadne.c b/drivers/net/ethernet/amd/ariadne.c
index 5fd7b15b0574..4b6a5cb85dd2 100644
--- a/drivers/net/ethernet/amd/ariadne.c
+++ b/drivers/net/ethernet/amd/ariadne.c
@@ -692,7 +692,7 @@ static void ariadne_remove_one(struct zorro_dev *z)
 	free_netdev(dev);
 }
 
-static struct zorro_device_id ariadne_zorro_tbl[] = {
+static const struct zorro_device_id ariadne_zorro_tbl[] = {
 	{ ZORRO_PROD_VILLAGE_TRONIC_ARIADNE },
 	{ 0 }
 };

commit a52ad514fdf3b8a57ca4322c92d2d8d5c6182485
Author: Jarod Wilson <jarod@redhat.com>
Date:   Fri Oct 7 22:04:34 2016 -0400

    net: deprecate eth_change_mtu, remove usage
    
    With centralized MTU checking, there's nothing productive done by
    eth_change_mtu that isn't already done in dev_set_mtu, so mark it as
    deprecated and remove all usage of it in the kernel. All callers have been
    audited for calls to alloc_etherdev* or ether_setup directly, which means
    they all have a valid dev->min_mtu and dev->max_mtu. Now eth_change_mtu
    prints out a netdev_warn about being deprecated, for the benefit of
    out-of-tree drivers that might be utilizing it.
    
    Of note, dvb_net.c actually had dev->mtu = 4096, while using
    eth_change_mtu, meaning that if you ever tried changing it's mtu, you
    couldn't set it above 1500 anymore. It's now getting dev->max_mtu also set
    to 4096 to remedy that.
    
    v2: fix up lantiq_etop, missed breakage due to drive not compiling on x86
    
    CC: netdev@vger.kernel.org
    Signed-off-by: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/ariadne.c b/drivers/net/ethernet/amd/ariadne.c
index 968b7bfac8fc..5fd7b15b0574 100644
--- a/drivers/net/ethernet/amd/ariadne.c
+++ b/drivers/net/ethernet/amd/ariadne.c
@@ -706,7 +706,6 @@ static const struct net_device_ops ariadne_netdev_ops = {
 	.ndo_get_stats		= ariadne_get_stats,
 	.ndo_set_rx_mode	= set_multicast_list,
 	.ndo_validate_addr	= eth_validate_addr,
-	.ndo_change_mtu		= eth_change_mtu,
 	.ndo_set_mac_address	= eth_mac_addr,
 };
 

commit 688c3b003382c16be811072b4c6e88408672861c
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Thu May 15 05:43:19 2014 +0200

    net/ariadne: delete unneeded call to netdev_priv
    
    Netdev_priv is an accessor function, and has no purpose if its result is
    not used.
    
    A simplified version of the semantic match that fixes this problem is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@ local idexpression x; @@
    -x = netdev_priv(...);
    ... when != x
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/ariadne.c b/drivers/net/ethernet/amd/ariadne.c
index b08101b31b8b..968b7bfac8fc 100644
--- a/drivers/net/ethernet/amd/ariadne.c
+++ b/drivers/net/ethernet/amd/ariadne.c
@@ -718,7 +718,6 @@ static int ariadne_init_one(struct zorro_dev *z,
 	unsigned long mem_start = board + ARIADNE_RAM;
 	struct resource *r1, *r2;
 	struct net_device *dev;
-	struct ariadne_private *priv;
 	u32 serial;
 	int err;
 
@@ -738,8 +737,6 @@ static int ariadne_init_one(struct zorro_dev *z,
 		return -ENOMEM;
 	}
 
-	priv = netdev_priv(dev);
-
 	r1->name = dev->name;
 	r2->name = dev->name;
 

commit bd9ba8f40ee30edf31cc0845d8838bc43d172ef3
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Fri Oct 4 09:38:53 2013 +0200

    zorro/UAPI: Use proper types (endianness/size) in <linux/zorro.h>
    
    Fix member definitions for non-native userspace handling:
      - All multi-byte values are big-endian, hence use __be*,
      - All pointers are 32-bit pointers under AmigaOS, but unused (except for
        cd_BoardAddr) under Linux, hence use __be32.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/net/ethernet/amd/ariadne.c b/drivers/net/ethernet/amd/ariadne.c
index 33822cb69366..b08101b31b8b 100644
--- a/drivers/net/ethernet/amd/ariadne.c
+++ b/drivers/net/ethernet/amd/ariadne.c
@@ -51,6 +51,7 @@
 #include <linux/zorro.h>
 #include <linux/bitops.h>
 
+#include <asm/byteorder.h>
 #include <asm/amigaints.h>
 #include <asm/amigahw.h>
 #include <asm/irq.h>
@@ -718,6 +719,7 @@ static int ariadne_init_one(struct zorro_dev *z,
 	struct resource *r1, *r2;
 	struct net_device *dev;
 	struct ariadne_private *priv;
+	u32 serial;
 	int err;
 
 	r1 = request_mem_region(base_addr, sizeof(struct Am79C960), "Am79C960");
@@ -741,12 +743,13 @@ static int ariadne_init_one(struct zorro_dev *z,
 	r1->name = dev->name;
 	r2->name = dev->name;
 
+	serial = be32_to_cpu(z->rom.er_SerialNumber);
 	dev->dev_addr[0] = 0x00;
 	dev->dev_addr[1] = 0x60;
 	dev->dev_addr[2] = 0x30;
-	dev->dev_addr[3] = (z->rom.er_SerialNumber >> 16) & 0xff;
-	dev->dev_addr[4] = (z->rom.er_SerialNumber >> 8) & 0xff;
-	dev->dev_addr[5] = z->rom.er_SerialNumber & 0xff;
+	dev->dev_addr[3] = (serial >> 16) & 0xff;
+	dev->dev_addr[4] = (serial >> 8) & 0xff;
+	dev->dev_addr[5] = serial & 0xff;
 	dev->base_addr = (unsigned long)ZTWO_VADDR(base_addr);
 	dev->mem_start = (unsigned long)ZTWO_VADDR(mem_start);
 	dev->mem_end = dev->mem_start + ARIADNE_RAM_SIZE;

commit 6112ea0862facaeaeab504ee01c0d04bcd22daaf
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Jan 9 11:03:43 2011 +0100

    zorro: ZTWO_VADDR() should return "void __iomem *"
    
    ZTWO_VADDR() converts from physical to virtual I/O addresses, so it should
    return "void __iomem *" instead of "unsigned long".
    
    This allows to drop several casts, but requires adding a few casts to
    accomodate legacy driver frameworks that store "unsigned long" I/O
    addresses.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/net/ethernet/amd/ariadne.c b/drivers/net/ethernet/amd/ariadne.c
index c178eb4c8166..33822cb69366 100644
--- a/drivers/net/ethernet/amd/ariadne.c
+++ b/drivers/net/ethernet/amd/ariadne.c
@@ -747,8 +747,8 @@ static int ariadne_init_one(struct zorro_dev *z,
 	dev->dev_addr[3] = (z->rom.er_SerialNumber >> 16) & 0xff;
 	dev->dev_addr[4] = (z->rom.er_SerialNumber >> 8) & 0xff;
 	dev->dev_addr[5] = z->rom.er_SerialNumber & 0xff;
-	dev->base_addr = ZTWO_VADDR(base_addr);
-	dev->mem_start = ZTWO_VADDR(mem_start);
+	dev->base_addr = (unsigned long)ZTWO_VADDR(base_addr);
+	dev->mem_start = (unsigned long)ZTWO_VADDR(mem_start);
 	dev->mem_end = dev->mem_start + ARIADNE_RAM_SIZE;
 
 	dev->netdev_ops = &ariadne_netdev_ops;

commit 720a43efd30f04a0a492c85fb997361c44fbae05
Author: Joe Perches <joe@perches.com>
Date:   Fri Mar 8 15:03:25 2013 +0000

    drivers:net: Remove unnecessary OOM messages after netdev_alloc_skb
    
    Emitting netdev_alloc_skb and netdev_alloc_skb_ip_align OOM
    messages is unnecessary as there is already a dump_stack
    after allocation failures.
    
    Other trivial changes around these removals:
    
    Convert a few comparisons of pointer to 0 to !pointer.
    Change flow to remove unnecessary label.
    Remove now unused variable.
    Hoist assignment from if.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/ariadne.c b/drivers/net/ethernet/amd/ariadne.c
index 98f4522fd17b..c178eb4c8166 100644
--- a/drivers/net/ethernet/amd/ariadne.c
+++ b/drivers/net/ethernet/amd/ariadne.c
@@ -193,7 +193,6 @@ static int ariadne_rx(struct net_device *dev)
 
 			skb = netdev_alloc_skb(dev, pkt_len + 2);
 			if (skb == NULL) {
-				netdev_warn(dev, "Memory squeeze, deferring packet\n");
 				for (i = 0; i < RX_RING_SIZE; i++)
 					if (lowb(priv->rx_ring[(entry + i) % RX_RING_SIZE]->RMD1) & RF_OWN)
 						break;

commit 1dd06ae8db716e17ec7e06244b858606edf378c0
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Dec 6 14:30:56 2012 +0000

    drivers/net: fix up function prototypes after __dev* removals
    
    The __dev* removal patches for the network drivers ended up messing up
    the function prototypes for a bunch of drivers.  This patch fixes all of
    them back up to be properly aligned.
    
    Bonus is that this almost removes 100 lines of code, always a nice
    surprise.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/ariadne.c b/drivers/net/ethernet/amd/ariadne.c
index 2ea7a231ef10..98f4522fd17b 100644
--- a/drivers/net/ethernet/amd/ariadne.c
+++ b/drivers/net/ethernet/amd/ariadne.c
@@ -711,7 +711,7 @@ static const struct net_device_ops ariadne_netdev_ops = {
 };
 
 static int ariadne_init_one(struct zorro_dev *z,
-				      const struct zorro_device_id *ent)
+			    const struct zorro_device_id *ent)
 {
 	unsigned long board = z->resource.start;
 	unsigned long base_addr = board + ARIADNE_LANCE;

commit 0cb0568dfea6b51a39362c484c9caddfc94a78b0
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Dec 3 09:23:54 2012 -0500

    net/amd: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/ethernet/amd/ariadne.c b/drivers/net/ethernet/amd/ariadne.c
index f2958df9a1e4..2ea7a231ef10 100644
--- a/drivers/net/ethernet/amd/ariadne.c
+++ b/drivers/net/ethernet/amd/ariadne.c
@@ -682,7 +682,7 @@ static void set_multicast_list(struct net_device *dev)
 }
 
 
-static void __devexit ariadne_remove_one(struct zorro_dev *z)
+static void ariadne_remove_one(struct zorro_dev *z)
 {
 	struct net_device *dev = zorro_get_drvdata(z);
 
@@ -692,7 +692,7 @@ static void __devexit ariadne_remove_one(struct zorro_dev *z)
 	free_netdev(dev);
 }
 
-static struct zorro_device_id ariadne_zorro_tbl[] __devinitdata = {
+static struct zorro_device_id ariadne_zorro_tbl[] = {
 	{ ZORRO_PROD_VILLAGE_TRONIC_ARIADNE },
 	{ 0 }
 };
@@ -710,7 +710,7 @@ static const struct net_device_ops ariadne_netdev_ops = {
 	.ndo_set_mac_address	= eth_mac_addr,
 };
 
-static int __devinit ariadne_init_one(struct zorro_dev *z,
+static int ariadne_init_one(struct zorro_dev *z,
 				      const struct zorro_device_id *ent)
 {
 	unsigned long board = z->resource.start;
@@ -774,7 +774,7 @@ static struct zorro_driver ariadne_driver = {
 	.name		= "ariadne",
 	.id_table	= ariadne_zorro_tbl,
 	.probe		= ariadne_init_one,
-	.remove		= __devexit_p(ariadne_remove_one),
+	.remove		= ariadne_remove_one,
 };
 
 static int __init ariadne_init_module(void)

commit 0eb8694b180c4cf017d1a0bd70a41bd58389375d
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Mon Jun 27 23:09:20 2011 +0200

    net/ariadne: Improve debug prints
    
    Remove casts and use proper printf()-style format specifiers instead.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: netdev@vger.kernel.org
    Acked-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/ariadne.c b/drivers/net/ethernet/amd/ariadne.c
index f4c228e4d76c..f2958df9a1e4 100644
--- a/drivers/net/ethernet/amd/ariadne.c
+++ b/drivers/net/ethernet/amd/ariadne.c
@@ -213,10 +213,10 @@ static int ariadne_rx(struct net_device *dev)
 						(const void *)priv->rx_buff[entry],
 						pkt_len);
 			skb->protocol = eth_type_trans(skb, dev);
-			netdev_dbg(dev, "RX pkt type 0x%04x from %pM to %pM data 0x%08x len %d\n",
+			netdev_dbg(dev, "RX pkt type 0x%04x from %pM to %pM data %p len %u\n",
 				   ((u_short *)skb->data)[6],
 				   skb->data + 6, skb->data,
-				   (int)skb->data, (int)skb->len);
+				   skb->data, skb->len);
 
 			netif_rx(skb);
 			dev->stats.rx_packets++;
@@ -566,10 +566,10 @@ static netdev_tx_t ariadne_start_xmit(struct sk_buff *skb,
 
 	/* Fill in a Tx ring entry */
 
-	netdev_dbg(dev, "TX pkt type 0x%04x from %pM to %pM data 0x%08x len %d\n",
+	netdev_dbg(dev, "TX pkt type 0x%04x from %pM to %pM data %p len %u\n",
 		   ((u_short *)skb->data)[6],
 		   skb->data + 6, skb->data,
-		   (int)skb->data, (int)skb->len);
+		   skb->data, skb->len);
 
 	local_irq_save(flags);
 

commit 1d266430546acf01438ae42d0a7370db4817e2ad
Author: Pradeep A Dalvi <netdev@pradeepdalvi.com>
Date:   Sun Feb 5 02:49:09 2012 +0000

    netdev: ethernet dev_alloc_skb to netdev_alloc_skb
    
    Replaced deprecating dev_alloc_skb with netdev_alloc_skb in drivers/net/ethernet
      - Removed extra skb->dev = dev after netdev_alloc_skb
    
    Signed-off-by: Pradeep A Dalvi <netdev@pradeepdalvi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/ariadne.c b/drivers/net/ethernet/amd/ariadne.c
index eb18e1fe65c8..f4c228e4d76c 100644
--- a/drivers/net/ethernet/amd/ariadne.c
+++ b/drivers/net/ethernet/amd/ariadne.c
@@ -191,7 +191,7 @@ static int ariadne_rx(struct net_device *dev)
 			short pkt_len = swapw(priv->rx_ring[entry]->RMD3);
 			struct sk_buff *skb;
 
-			skb = dev_alloc_skb(pkt_len + 2);
+			skb = netdev_alloc_skb(dev, pkt_len + 2);
 			if (skb == NULL) {
 				netdev_warn(dev, "Memory squeeze, deferring packet\n");
 				for (i = 0; i < RX_RING_SIZE; i++)

commit afc4b13df143122f99a0eb10bfefb216c2806de0
Author: Jiri Pirko <jpirko@redhat.com>
Date:   Tue Aug 16 06:29:01 2011 +0000

    net: remove use of ndo_set_multicast_list in drivers
    
    replace it by ndo_set_rx_mode
    
    Signed-off-by: Jiri Pirko <jpirko@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/amd/ariadne.c b/drivers/net/ethernet/amd/ariadne.c
index 7ed78f402042..eb18e1fe65c8 100644
--- a/drivers/net/ethernet/amd/ariadne.c
+++ b/drivers/net/ethernet/amd/ariadne.c
@@ -704,7 +704,7 @@ static const struct net_device_ops ariadne_netdev_ops = {
 	.ndo_start_xmit		= ariadne_start_xmit,
 	.ndo_tx_timeout		= ariadne_tx_timeout,
 	.ndo_get_stats		= ariadne_get_stats,
-	.ndo_set_multicast_list	= set_multicast_list,
+	.ndo_set_rx_mode	= set_multicast_list,
 	.ndo_validate_addr	= eth_validate_addr,
 	.ndo_change_mtu		= eth_change_mtu,
 	.ndo_set_mac_address	= eth_mac_addr,

commit b955f6ca776f3bab3d1e2c5fb1d247b203cbda14
Author: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Date:   Wed Mar 30 07:46:36 2011 -0700

    amd: Move AMD (Lance) chipset drivers
    
    Moves the drivers for the AMD chipsets into drivers/net/ethernet/amd/
    and the necessary Kconfig and Makfile changes.
    
    The au1000 (Alchemy) driver was also moved into the same directory
    even though it is not a "Lance" driver.
    
    CC: Peter Maydell <pmaydell@chiark.greenend.org.uk>
    CC: Roman Hodek <Roman.Hodek@informatik.uni-erlangen.de>
    CC: "Maciej W. Rozycki" <macro@linux-mips.org>
    CC: Donald Becker <becker@scyld.com>
    CC: Sam Creasey <sammy@users.qual.net>
    CC: Miguel de Icaza <miguel@nuclecu.unam.mx>
    CC: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    CC: Don Fry <pcnet32@frontier.com>
    CC: Geert Uytterhoeven <geert@linux-m68k.org>
    CC: Russell King <linux@arm.linux.org.uk>
    CC: David Davies <davies@maniac.ultranet.com>
    CC: "M.Hipp" <hippm@informatik.uni-tuebingen.de>
    CC: Pete Popov <ppopov@embeddedalley.com>
    CC: David Hinds <dahinds@users.sourceforge.net>
    CC: "Roger C. Pao" <rpao@paonet.org>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/amd/ariadne.c b/drivers/net/ethernet/amd/ariadne.c
new file mode 100644
index 000000000000..7ed78f402042
--- /dev/null
+++ b/drivers/net/ethernet/amd/ariadne.c
@@ -0,0 +1,793 @@
+/*
+ *  Amiga Linux/m68k Ariadne Ethernet Driver
+ *
+ *  Â© Copyright 1995-2003 by Geert Uytterhoeven (geert@linux-m68k.org)
+ *			     Peter De Schrijver (p2@mind.be)
+ *
+ *  ---------------------------------------------------------------------------
+ *
+ *  This program is based on
+ *
+ *	lance.c:	An AMD LANCE ethernet driver for linux.
+ *			Written 1993-94 by Donald Becker.
+ *
+ *	Am79C960:	PCnet(tm)-ISA Single-Chip Ethernet Controller
+ *			Advanced Micro Devices
+ *			Publication #16907, Rev. B, Amendment/0, May 1994
+ *
+ *	MC68230:	Parallel Interface/Timer (PI/T)
+ *			Motorola Semiconductors, December, 1983
+ *
+ *  ---------------------------------------------------------------------------
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License.  See the file COPYING in the main directory of the Linux
+ *  distribution for more details.
+ *
+ *  ---------------------------------------------------------------------------
+ *
+ *  The Ariadne is a Zorro-II board made by Village Tronic. It contains:
+ *
+ *	- an Am79C960 PCnet-ISA Single-Chip Ethernet Controller with both
+ *	  10BASE-2 (thin coax) and 10BASE-T (UTP) connectors
+ *
+ *	- an MC68230 Parallel Interface/Timer configured as 2 parallel ports
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+/*#define DEBUG*/
+
+#include <linux/module.h>
+#include <linux/stddef.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/interrupt.h>
+#include <linux/skbuff.h>
+#include <linux/init.h>
+#include <linux/zorro.h>
+#include <linux/bitops.h>
+
+#include <asm/amigaints.h>
+#include <asm/amigahw.h>
+#include <asm/irq.h>
+
+#include "ariadne.h"
+
+#ifdef ARIADNE_DEBUG
+int ariadne_debug = ARIADNE_DEBUG;
+#else
+int ariadne_debug = 1;
+#endif
+
+/* Macros to Fix Endianness problems */
+
+/* Swap the Bytes in a WORD */
+#define swapw(x)	(((x >> 8) & 0x00ff) | ((x << 8) & 0xff00))
+/* Get the Low BYTE in a WORD */
+#define lowb(x)		(x & 0xff)
+/* Get the Swapped High WORD in a LONG */
+#define swhighw(x)	((((x) >> 8) & 0xff00) | (((x) >> 24) & 0x00ff))
+/* Get the Swapped Low WORD in a LONG */
+#define swloww(x)	((((x) << 8) & 0xff00) | (((x) >> 8) & 0x00ff))
+
+/* Transmit/Receive Ring Definitions */
+
+#define TX_RING_SIZE	5
+#define RX_RING_SIZE	16
+
+#define PKT_BUF_SIZE	1520
+
+/* Private Device Data */
+
+struct ariadne_private {
+	volatile struct TDRE *tx_ring[TX_RING_SIZE];
+	volatile struct RDRE *rx_ring[RX_RING_SIZE];
+	volatile u_short *tx_buff[TX_RING_SIZE];
+	volatile u_short *rx_buff[RX_RING_SIZE];
+	int cur_tx, cur_rx;		/* The next free ring entry */
+	int dirty_tx;			/* The ring entries to be free()ed */
+	char tx_full;
+};
+
+/* Structure Created in the Ariadne's RAM Buffer */
+
+struct lancedata {
+	struct TDRE tx_ring[TX_RING_SIZE];
+	struct RDRE rx_ring[RX_RING_SIZE];
+	u_short tx_buff[TX_RING_SIZE][PKT_BUF_SIZE / sizeof(u_short)];
+	u_short rx_buff[RX_RING_SIZE][PKT_BUF_SIZE / sizeof(u_short)];
+};
+
+static void memcpyw(volatile u_short *dest, u_short *src, int len)
+{
+	while (len >= 2) {
+		*(dest++) = *(src++);
+		len -= 2;
+	}
+	if (len == 1)
+		*dest = (*(u_char *)src) << 8;
+}
+
+static void ariadne_init_ring(struct net_device *dev)
+{
+	struct ariadne_private *priv = netdev_priv(dev);
+	volatile struct lancedata *lancedata = (struct lancedata *)dev->mem_start;
+	int i;
+
+	netif_stop_queue(dev);
+
+	priv->tx_full = 0;
+	priv->cur_rx = priv->cur_tx = 0;
+	priv->dirty_tx = 0;
+
+	/* Set up TX Ring */
+	for (i = 0; i < TX_RING_SIZE; i++) {
+		volatile struct TDRE *t = &lancedata->tx_ring[i];
+		t->TMD0 = swloww(ARIADNE_RAM +
+				 offsetof(struct lancedata, tx_buff[i]));
+		t->TMD1 = swhighw(ARIADNE_RAM +
+				  offsetof(struct lancedata, tx_buff[i])) |
+			TF_STP | TF_ENP;
+		t->TMD2 = swapw((u_short)-PKT_BUF_SIZE);
+		t->TMD3 = 0;
+		priv->tx_ring[i] = &lancedata->tx_ring[i];
+		priv->tx_buff[i] = lancedata->tx_buff[i];
+		netdev_dbg(dev, "TX Entry %2d at %p, Buf at %p\n",
+			   i, &lancedata->tx_ring[i], lancedata->tx_buff[i]);
+	}
+
+	/* Set up RX Ring */
+	for (i = 0; i < RX_RING_SIZE; i++) {
+		volatile struct RDRE *r = &lancedata->rx_ring[i];
+		r->RMD0 = swloww(ARIADNE_RAM +
+				 offsetof(struct lancedata, rx_buff[i]));
+		r->RMD1 = swhighw(ARIADNE_RAM +
+				  offsetof(struct lancedata, rx_buff[i])) |
+			RF_OWN;
+		r->RMD2 = swapw((u_short)-PKT_BUF_SIZE);
+		r->RMD3 = 0x0000;
+		priv->rx_ring[i] = &lancedata->rx_ring[i];
+		priv->rx_buff[i] = lancedata->rx_buff[i];
+		netdev_dbg(dev, "RX Entry %2d at %p, Buf at %p\n",
+			   i, &lancedata->rx_ring[i], lancedata->rx_buff[i]);
+	}
+}
+
+static int ariadne_rx(struct net_device *dev)
+{
+	struct ariadne_private *priv = netdev_priv(dev);
+	int entry = priv->cur_rx % RX_RING_SIZE;
+	int i;
+
+	/* If we own the next entry, it's a new packet. Send it up */
+	while (!(lowb(priv->rx_ring[entry]->RMD1) & RF_OWN)) {
+		int status = lowb(priv->rx_ring[entry]->RMD1);
+
+		if (status != (RF_STP | RF_ENP)) {	/* There was an error */
+			/* There is a tricky error noted by
+			 * John Murphy <murf@perftech.com> to Russ Nelson:
+			 * Even with full-sized buffers it's possible for a
+			 * jabber packet to use two buffers, with only the
+			 * last correctly noting the error
+			 */
+			/* Only count a general error at the end of a packet */
+			if (status & RF_ENP)
+				dev->stats.rx_errors++;
+			if (status & RF_FRAM)
+				dev->stats.rx_frame_errors++;
+			if (status & RF_OFLO)
+				dev->stats.rx_over_errors++;
+			if (status & RF_CRC)
+				dev->stats.rx_crc_errors++;
+			if (status & RF_BUFF)
+				dev->stats.rx_fifo_errors++;
+			priv->rx_ring[entry]->RMD1 &= 0xff00 | RF_STP | RF_ENP;
+		} else {
+			/* Malloc up new buffer, compatible with net-3 */
+			short pkt_len = swapw(priv->rx_ring[entry]->RMD3);
+			struct sk_buff *skb;
+
+			skb = dev_alloc_skb(pkt_len + 2);
+			if (skb == NULL) {
+				netdev_warn(dev, "Memory squeeze, deferring packet\n");
+				for (i = 0; i < RX_RING_SIZE; i++)
+					if (lowb(priv->rx_ring[(entry + i) % RX_RING_SIZE]->RMD1) & RF_OWN)
+						break;
+
+				if (i > RX_RING_SIZE - 2) {
+					dev->stats.rx_dropped++;
+					priv->rx_ring[entry]->RMD1 |= RF_OWN;
+					priv->cur_rx++;
+				}
+				break;
+			}
+
+
+			skb_reserve(skb, 2);	/* 16 byte align */
+			skb_put(skb, pkt_len);	/* Make room */
+			skb_copy_to_linear_data(skb,
+						(const void *)priv->rx_buff[entry],
+						pkt_len);
+			skb->protocol = eth_type_trans(skb, dev);
+			netdev_dbg(dev, "RX pkt type 0x%04x from %pM to %pM data 0x%08x len %d\n",
+				   ((u_short *)skb->data)[6],
+				   skb->data + 6, skb->data,
+				   (int)skb->data, (int)skb->len);
+
+			netif_rx(skb);
+			dev->stats.rx_packets++;
+			dev->stats.rx_bytes += pkt_len;
+		}
+
+		priv->rx_ring[entry]->RMD1 |= RF_OWN;
+		entry = (++priv->cur_rx) % RX_RING_SIZE;
+	}
+
+	priv->cur_rx = priv->cur_rx % RX_RING_SIZE;
+
+	/* We should check that at least two ring entries are free.
+	 * If not, we should free one and mark stats->rx_dropped++
+	 */
+
+	return 0;
+}
+
+static irqreturn_t ariadne_interrupt(int irq, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	volatile struct Am79C960 *lance = (struct Am79C960 *)dev->base_addr;
+	struct ariadne_private *priv;
+	int csr0, boguscnt;
+	int handled = 0;
+
+	lance->RAP = CSR0;		/* PCnet-ISA Controller Status */
+
+	if (!(lance->RDP & INTR))	/* Check if any interrupt has been */
+		return IRQ_NONE;	/* generated by the board */
+
+	priv = netdev_priv(dev);
+
+	boguscnt = 10;
+	while ((csr0 = lance->RDP) & (ERR | RINT | TINT) && --boguscnt >= 0) {
+		/* Acknowledge all of the current interrupt sources ASAP */
+		lance->RDP = csr0 & ~(INEA | TDMD | STOP | STRT | INIT);
+
+#ifdef DEBUG
+		if (ariadne_debug > 5) {
+			netdev_dbg(dev, "interrupt  csr0=%#02x new csr=%#02x [",
+				   csr0, lance->RDP);
+			if (csr0 & INTR)
+				pr_cont(" INTR");
+			if (csr0 & INEA)
+				pr_cont(" INEA");
+			if (csr0 & RXON)
+				pr_cont(" RXON");
+			if (csr0 & TXON)
+				pr_cont(" TXON");
+			if (csr0 & TDMD)
+				pr_cont(" TDMD");
+			if (csr0 & STOP)
+				pr_cont(" STOP");
+			if (csr0 & STRT)
+				pr_cont(" STRT");
+			if (csr0 & INIT)
+				pr_cont(" INIT");
+			if (csr0 & ERR)
+				pr_cont(" ERR");
+			if (csr0 & BABL)
+				pr_cont(" BABL");
+			if (csr0 & CERR)
+				pr_cont(" CERR");
+			if (csr0 & MISS)
+				pr_cont(" MISS");
+			if (csr0 & MERR)
+				pr_cont(" MERR");
+			if (csr0 & RINT)
+				pr_cont(" RINT");
+			if (csr0 & TINT)
+				pr_cont(" TINT");
+			if (csr0 & IDON)
+				pr_cont(" IDON");
+			pr_cont(" ]\n");
+		}
+#endif
+
+		if (csr0 & RINT) {	/* Rx interrupt */
+			handled = 1;
+			ariadne_rx(dev);
+		}
+
+		if (csr0 & TINT) {	/* Tx-done interrupt */
+			int dirty_tx = priv->dirty_tx;
+
+			handled = 1;
+			while (dirty_tx < priv->cur_tx) {
+				int entry = dirty_tx % TX_RING_SIZE;
+				int status = lowb(priv->tx_ring[entry]->TMD1);
+
+				if (status & TF_OWN)
+					break;	/* It still hasn't been Txed */
+
+				priv->tx_ring[entry]->TMD1 &= 0xff00;
+
+				if (status & TF_ERR) {
+					/* There was an major error, log it */
+					int err_status = priv->tx_ring[entry]->TMD3;
+					dev->stats.tx_errors++;
+					if (err_status & EF_RTRY)
+						dev->stats.tx_aborted_errors++;
+					if (err_status & EF_LCAR)
+						dev->stats.tx_carrier_errors++;
+					if (err_status & EF_LCOL)
+						dev->stats.tx_window_errors++;
+					if (err_status & EF_UFLO) {
+						/* Ackk!  On FIFO errors the Tx unit is turned off! */
+						dev->stats.tx_fifo_errors++;
+						/* Remove this verbosity later! */
+						netdev_err(dev, "Tx FIFO error! Status %04x\n",
+							   csr0);
+						/* Restart the chip */
+						lance->RDP = STRT;
+					}
+				} else {
+					if (status & (TF_MORE | TF_ONE))
+						dev->stats.collisions++;
+					dev->stats.tx_packets++;
+				}
+				dirty_tx++;
+			}
+
+#ifndef final_version
+			if (priv->cur_tx - dirty_tx >= TX_RING_SIZE) {
+				netdev_err(dev, "out-of-sync dirty pointer, %d vs. %d, full=%d\n",
+					   dirty_tx, priv->cur_tx,
+					   priv->tx_full);
+				dirty_tx += TX_RING_SIZE;
+			}
+#endif
+
+			if (priv->tx_full && netif_queue_stopped(dev) &&
+			    dirty_tx > priv->cur_tx - TX_RING_SIZE + 2) {
+				/* The ring is no longer full */
+				priv->tx_full = 0;
+				netif_wake_queue(dev);
+			}
+
+			priv->dirty_tx = dirty_tx;
+		}
+
+		/* Log misc errors */
+		if (csr0 & BABL) {
+			handled = 1;
+			dev->stats.tx_errors++;	/* Tx babble */
+		}
+		if (csr0 & MISS) {
+			handled = 1;
+			dev->stats.rx_errors++;	/* Missed a Rx frame */
+		}
+		if (csr0 & MERR) {
+			handled = 1;
+			netdev_err(dev, "Bus master arbitration failure, status %04x\n",
+				   csr0);
+			/* Restart the chip */
+			lance->RDP = STRT;
+		}
+	}
+
+	/* Clear any other interrupt, and set interrupt enable */
+	lance->RAP = CSR0;		/* PCnet-ISA Controller Status */
+	lance->RDP = INEA | BABL | CERR | MISS | MERR | IDON;
+
+	if (ariadne_debug > 4)
+		netdev_dbg(dev, "exiting interrupt, csr%d=%#04x\n",
+			   lance->RAP, lance->RDP);
+
+	return IRQ_RETVAL(handled);
+}
+
+static int ariadne_open(struct net_device *dev)
+{
+	volatile struct Am79C960 *lance = (struct Am79C960 *)dev->base_addr;
+	u_short in;
+	u_long version;
+	int i;
+
+	/* Reset the LANCE */
+	in = lance->Reset;
+
+	/* Stop the LANCE */
+	lance->RAP = CSR0;		/* PCnet-ISA Controller Status */
+	lance->RDP = STOP;
+
+	/* Check the LANCE version */
+	lance->RAP = CSR88;		/* Chip ID */
+	version = swapw(lance->RDP);
+	lance->RAP = CSR89;		/* Chip ID */
+	version |= swapw(lance->RDP) << 16;
+	if ((version & 0x00000fff) != 0x00000003) {
+		pr_warn("Couldn't find AMD Ethernet Chip\n");
+		return -EAGAIN;
+	}
+	if ((version & 0x0ffff000) != 0x00003000) {
+		pr_warn("Couldn't find Am79C960 (Wrong part number = %ld)\n",
+		       (version & 0x0ffff000) >> 12);
+		return -EAGAIN;
+	}
+
+	netdev_dbg(dev, "Am79C960 (PCnet-ISA) Revision %ld\n",
+		   (version & 0xf0000000) >> 28);
+
+	ariadne_init_ring(dev);
+
+	/* Miscellaneous Stuff */
+	lance->RAP = CSR3;		/* Interrupt Masks and Deferral Control */
+	lance->RDP = 0x0000;
+	lance->RAP = CSR4;		/* Test and Features Control */
+	lance->RDP = DPOLL | APAD_XMT | MFCOM | RCVCCOM | TXSTRTM | JABM;
+
+	/* Set the Multicast Table */
+	lance->RAP = CSR8;		/* Logical Address Filter, LADRF[15:0] */
+	lance->RDP = 0x0000;
+	lance->RAP = CSR9;		/* Logical Address Filter, LADRF[31:16] */
+	lance->RDP = 0x0000;
+	lance->RAP = CSR10;		/* Logical Address Filter, LADRF[47:32] */
+	lance->RDP = 0x0000;
+	lance->RAP = CSR11;		/* Logical Address Filter, LADRF[63:48] */
+	lance->RDP = 0x0000;
+
+	/* Set the Ethernet Hardware Address */
+	lance->RAP = CSR12;		/* Physical Address Register, PADR[15:0] */
+	lance->RDP = ((u_short *)&dev->dev_addr[0])[0];
+	lance->RAP = CSR13;		/* Physical Address Register, PADR[31:16] */
+	lance->RDP = ((u_short *)&dev->dev_addr[0])[1];
+	lance->RAP = CSR14;		/* Physical Address Register, PADR[47:32] */
+	lance->RDP = ((u_short *)&dev->dev_addr[0])[2];
+
+	/* Set the Init Block Mode */
+	lance->RAP = CSR15;		/* Mode Register */
+	lance->RDP = 0x0000;
+
+	/* Set the Transmit Descriptor Ring Pointer */
+	lance->RAP = CSR30;		/* Base Address of Transmit Ring */
+	lance->RDP = swloww(ARIADNE_RAM + offsetof(struct lancedata, tx_ring));
+	lance->RAP = CSR31;		/* Base Address of transmit Ring */
+	lance->RDP = swhighw(ARIADNE_RAM + offsetof(struct lancedata, tx_ring));
+
+	/* Set the Receive Descriptor Ring Pointer */
+	lance->RAP = CSR24;		/* Base Address of Receive Ring */
+	lance->RDP = swloww(ARIADNE_RAM + offsetof(struct lancedata, rx_ring));
+	lance->RAP = CSR25;		/* Base Address of Receive Ring */
+	lance->RDP = swhighw(ARIADNE_RAM + offsetof(struct lancedata, rx_ring));
+
+	/* Set the Number of RX and TX Ring Entries */
+	lance->RAP = CSR76;		/* Receive Ring Length */
+	lance->RDP = swapw(((u_short)-RX_RING_SIZE));
+	lance->RAP = CSR78;		/* Transmit Ring Length */
+	lance->RDP = swapw(((u_short)-TX_RING_SIZE));
+
+	/* Enable Media Interface Port Auto Select (10BASE-2/10BASE-T) */
+	lance->RAP = ISACSR2;		/* Miscellaneous Configuration */
+	lance->IDP = ASEL;
+
+	/* LED Control */
+	lance->RAP = ISACSR5;		/* LED1 Status */
+	lance->IDP = PSE|XMTE;
+	lance->RAP = ISACSR6;	/* LED2 Status */
+	lance->IDP = PSE|COLE;
+	lance->RAP = ISACSR7;	/* LED3 Status */
+	lance->IDP = PSE|RCVE;
+
+	netif_start_queue(dev);
+
+	i = request_irq(IRQ_AMIGA_PORTS, ariadne_interrupt, IRQF_SHARED,
+			dev->name, dev);
+	if (i)
+		return i;
+
+	lance->RAP = CSR0;		/* PCnet-ISA Controller Status */
+	lance->RDP = INEA | STRT;
+
+	return 0;
+}
+
+static int ariadne_close(struct net_device *dev)
+{
+	volatile struct Am79C960 *lance = (struct Am79C960 *)dev->base_addr;
+
+	netif_stop_queue(dev);
+
+	lance->RAP = CSR112;		/* Missed Frame Count */
+	dev->stats.rx_missed_errors = swapw(lance->RDP);
+	lance->RAP = CSR0;		/* PCnet-ISA Controller Status */
+
+	if (ariadne_debug > 1) {
+		netdev_dbg(dev, "Shutting down ethercard, status was %02x\n",
+			   lance->RDP);
+		netdev_dbg(dev, "%lu packets missed\n",
+			   dev->stats.rx_missed_errors);
+	}
+
+	/* We stop the LANCE here -- it occasionally polls memory if we don't */
+	lance->RDP = STOP;
+
+	free_irq(IRQ_AMIGA_PORTS, dev);
+
+	return 0;
+}
+
+static inline void ariadne_reset(struct net_device *dev)
+{
+	volatile struct Am79C960 *lance = (struct Am79C960 *)dev->base_addr;
+
+	lance->RAP = CSR0;	/* PCnet-ISA Controller Status */
+	lance->RDP = STOP;
+	ariadne_init_ring(dev);
+	lance->RDP = INEA | STRT;
+	netif_start_queue(dev);
+}
+
+static void ariadne_tx_timeout(struct net_device *dev)
+{
+	volatile struct Am79C960 *lance = (struct Am79C960 *)dev->base_addr;
+
+	netdev_err(dev, "transmit timed out, status %04x, resetting\n",
+		   lance->RDP);
+	ariadne_reset(dev);
+	netif_wake_queue(dev);
+}
+
+static netdev_tx_t ariadne_start_xmit(struct sk_buff *skb,
+				      struct net_device *dev)
+{
+	struct ariadne_private *priv = netdev_priv(dev);
+	volatile struct Am79C960 *lance = (struct Am79C960 *)dev->base_addr;
+	int entry;
+	unsigned long flags;
+	int len = skb->len;
+
+#if 0
+	if (ariadne_debug > 3) {
+		lance->RAP = CSR0;	/* PCnet-ISA Controller Status */
+		netdev_dbg(dev, "%s: csr0 %04x\n", __func__, lance->RDP);
+		lance->RDP = 0x0000;
+	}
+#endif
+
+	/* FIXME: is the 79C960 new enough to do its own padding right ? */
+	if (skb->len < ETH_ZLEN) {
+		if (skb_padto(skb, ETH_ZLEN))
+			return NETDEV_TX_OK;
+		len = ETH_ZLEN;
+	}
+
+	/* Fill in a Tx ring entry */
+
+	netdev_dbg(dev, "TX pkt type 0x%04x from %pM to %pM data 0x%08x len %d\n",
+		   ((u_short *)skb->data)[6],
+		   skb->data + 6, skb->data,
+		   (int)skb->data, (int)skb->len);
+
+	local_irq_save(flags);
+
+	entry = priv->cur_tx % TX_RING_SIZE;
+
+	/* Caution: the write order is important here, set the base address with
+	   the "ownership" bits last */
+
+	priv->tx_ring[entry]->TMD2 = swapw((u_short)-skb->len);
+	priv->tx_ring[entry]->TMD3 = 0x0000;
+	memcpyw(priv->tx_buff[entry], (u_short *)skb->data, len);
+
+#ifdef DEBUG
+	print_hex_dump(KERN_DEBUG, "tx_buff: ", DUMP_PREFIX_OFFSET, 16, 1,
+		       (void *)priv->tx_buff[entry],
+		       skb->len > 64 ? 64 : skb->len, true);
+#endif
+
+	priv->tx_ring[entry]->TMD1 = (priv->tx_ring[entry]->TMD1 & 0xff00)
+		| TF_OWN | TF_STP | TF_ENP;
+
+	dev_kfree_skb(skb);
+
+	priv->cur_tx++;
+	if ((priv->cur_tx >= TX_RING_SIZE) &&
+	    (priv->dirty_tx >= TX_RING_SIZE)) {
+
+		netdev_dbg(dev, "*** Subtracting TX_RING_SIZE from cur_tx (%d) and dirty_tx (%d)\n",
+			   priv->cur_tx, priv->dirty_tx);
+
+		priv->cur_tx -= TX_RING_SIZE;
+		priv->dirty_tx -= TX_RING_SIZE;
+	}
+	dev->stats.tx_bytes += len;
+
+	/* Trigger an immediate send poll */
+	lance->RAP = CSR0;		/* PCnet-ISA Controller Status */
+	lance->RDP = INEA | TDMD;
+
+	if (lowb(priv->tx_ring[(entry + 1) % TX_RING_SIZE]->TMD1) != 0) {
+		netif_stop_queue(dev);
+		priv->tx_full = 1;
+	}
+	local_irq_restore(flags);
+
+	return NETDEV_TX_OK;
+}
+
+static struct net_device_stats *ariadne_get_stats(struct net_device *dev)
+{
+	volatile struct Am79C960 *lance = (struct Am79C960 *)dev->base_addr;
+	short saved_addr;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	saved_addr = lance->RAP;
+	lance->RAP = CSR112;		/* Missed Frame Count */
+	dev->stats.rx_missed_errors = swapw(lance->RDP);
+	lance->RAP = saved_addr;
+	local_irq_restore(flags);
+
+	return &dev->stats;
+}
+
+/* Set or clear the multicast filter for this adaptor.
+ * num_addrs == -1	Promiscuous mode, receive all packets
+ * num_addrs == 0	Normal mode, clear multicast list
+ * num_addrs > 0	Multicast mode, receive normal and MC packets,
+ * 			and do best-effort filtering.
+ */
+static void set_multicast_list(struct net_device *dev)
+{
+	volatile struct Am79C960 *lance = (struct Am79C960 *)dev->base_addr;
+
+	if (!netif_running(dev))
+		return;
+
+	netif_stop_queue(dev);
+
+	/* We take the simple way out and always enable promiscuous mode */
+	lance->RAP = CSR0;		/* PCnet-ISA Controller Status */
+	lance->RDP = STOP;		/* Temporarily stop the lance */
+	ariadne_init_ring(dev);
+
+	if (dev->flags & IFF_PROMISC) {
+		lance->RAP = CSR15;	/* Mode Register */
+		lance->RDP = PROM;	/* Set promiscuous mode */
+	} else {
+		short multicast_table[4];
+		int num_addrs = netdev_mc_count(dev);
+		int i;
+		/* We don't use the multicast table,
+		 * but rely on upper-layer filtering
+		 */
+		memset(multicast_table, (num_addrs == 0) ? 0 : -1,
+		       sizeof(multicast_table));
+		for (i = 0; i < 4; i++) {
+			lance->RAP = CSR8 + (i << 8);
+					/* Logical Address Filter */
+			lance->RDP = swapw(multicast_table[i]);
+		}
+		lance->RAP = CSR15;	/* Mode Register */
+		lance->RDP = 0x0000;	/* Unset promiscuous mode */
+	}
+
+	lance->RAP = CSR0;		/* PCnet-ISA Controller Status */
+	lance->RDP = INEA | STRT | IDON;/* Resume normal operation */
+
+	netif_wake_queue(dev);
+}
+
+
+static void __devexit ariadne_remove_one(struct zorro_dev *z)
+{
+	struct net_device *dev = zorro_get_drvdata(z);
+
+	unregister_netdev(dev);
+	release_mem_region(ZTWO_PADDR(dev->base_addr), sizeof(struct Am79C960));
+	release_mem_region(ZTWO_PADDR(dev->mem_start), ARIADNE_RAM_SIZE);
+	free_netdev(dev);
+}
+
+static struct zorro_device_id ariadne_zorro_tbl[] __devinitdata = {
+	{ ZORRO_PROD_VILLAGE_TRONIC_ARIADNE },
+	{ 0 }
+};
+MODULE_DEVICE_TABLE(zorro, ariadne_zorro_tbl);
+
+static const struct net_device_ops ariadne_netdev_ops = {
+	.ndo_open		= ariadne_open,
+	.ndo_stop		= ariadne_close,
+	.ndo_start_xmit		= ariadne_start_xmit,
+	.ndo_tx_timeout		= ariadne_tx_timeout,
+	.ndo_get_stats		= ariadne_get_stats,
+	.ndo_set_multicast_list	= set_multicast_list,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+	.ndo_set_mac_address	= eth_mac_addr,
+};
+
+static int __devinit ariadne_init_one(struct zorro_dev *z,
+				      const struct zorro_device_id *ent)
+{
+	unsigned long board = z->resource.start;
+	unsigned long base_addr = board + ARIADNE_LANCE;
+	unsigned long mem_start = board + ARIADNE_RAM;
+	struct resource *r1, *r2;
+	struct net_device *dev;
+	struct ariadne_private *priv;
+	int err;
+
+	r1 = request_mem_region(base_addr, sizeof(struct Am79C960), "Am79C960");
+	if (!r1)
+		return -EBUSY;
+	r2 = request_mem_region(mem_start, ARIADNE_RAM_SIZE, "RAM");
+	if (!r2) {
+		release_mem_region(base_addr, sizeof(struct Am79C960));
+		return -EBUSY;
+	}
+
+	dev = alloc_etherdev(sizeof(struct ariadne_private));
+	if (dev == NULL) {
+		release_mem_region(base_addr, sizeof(struct Am79C960));
+		release_mem_region(mem_start, ARIADNE_RAM_SIZE);
+		return -ENOMEM;
+	}
+
+	priv = netdev_priv(dev);
+
+	r1->name = dev->name;
+	r2->name = dev->name;
+
+	dev->dev_addr[0] = 0x00;
+	dev->dev_addr[1] = 0x60;
+	dev->dev_addr[2] = 0x30;
+	dev->dev_addr[3] = (z->rom.er_SerialNumber >> 16) & 0xff;
+	dev->dev_addr[4] = (z->rom.er_SerialNumber >> 8) & 0xff;
+	dev->dev_addr[5] = z->rom.er_SerialNumber & 0xff;
+	dev->base_addr = ZTWO_VADDR(base_addr);
+	dev->mem_start = ZTWO_VADDR(mem_start);
+	dev->mem_end = dev->mem_start + ARIADNE_RAM_SIZE;
+
+	dev->netdev_ops = &ariadne_netdev_ops;
+	dev->watchdog_timeo = 5 * HZ;
+
+	err = register_netdev(dev);
+	if (err) {
+		release_mem_region(base_addr, sizeof(struct Am79C960));
+		release_mem_region(mem_start, ARIADNE_RAM_SIZE);
+		free_netdev(dev);
+		return err;
+	}
+	zorro_set_drvdata(z, dev);
+
+	netdev_info(dev, "Ariadne at 0x%08lx, Ethernet Address %pM\n",
+		    board, dev->dev_addr);
+
+	return 0;
+}
+
+static struct zorro_driver ariadne_driver = {
+	.name		= "ariadne",
+	.id_table	= ariadne_zorro_tbl,
+	.probe		= ariadne_init_one,
+	.remove		= __devexit_p(ariadne_remove_one),
+};
+
+static int __init ariadne_init_module(void)
+{
+	return zorro_register_driver(&ariadne_driver);
+}
+
+static void __exit ariadne_cleanup_module(void)
+{
+	zorro_unregister_driver(&ariadne_driver);
+}
+
+module_init(ariadne_init_module);
+module_exit(ariadne_cleanup_module);
+
+MODULE_LICENSE("GPL");
