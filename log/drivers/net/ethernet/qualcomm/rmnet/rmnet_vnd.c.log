commit 376d5307e0572688997abdd7414da43002335cb8
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Sun Mar 8 13:47:06 2020 +0000

    net: rmnet: set NETIF_F_LLTX flag
    
    The rmnet_vnd_setup(), which is the callback of ->ndo_start_xmit() is
    allowed to call concurrently because it uses RCU protected data.
    So, it doesn't need tx lock.
    
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
index d7c52e398e4a..d58b51d277f1 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -212,6 +212,8 @@ void rmnet_vnd_setup(struct net_device *rmnet_dev)
 	rmnet_dev->needs_free_netdev = true;
 	rmnet_dev->ethtool_ops = &rmnet_ethtool_ops;
 
+	rmnet_dev->features |= NETIF_F_LLTX;
+
 	/* This perm addr will be used as interface identifier by IPv6 */
 	rmnet_dev->addr_assign_type = NET_ADDR_RANDOM;
 	eth_random_addr(rmnet_dev->perm_addr);

commit fcf8f4eb81fb266f56505e821591070becc9eeb0
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Wed Mar 4 23:25:22 2020 +0000

    net: rmnet: print error message when command fails
    
    When rmnet netlink command fails, it doesn't print any error message.
    So, users couldn't know the exact reason.
    In order to tell the exact reason to the user, the extack error message
    is used in this patch.
    
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
index 26ad40f19c64..d7c52e398e4a 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -222,16 +222,17 @@ void rmnet_vnd_setup(struct net_device *rmnet_dev)
 int rmnet_vnd_newlink(u8 id, struct net_device *rmnet_dev,
 		      struct rmnet_port *port,
 		      struct net_device *real_dev,
-		      struct rmnet_endpoint *ep)
+		      struct rmnet_endpoint *ep,
+		      struct netlink_ext_ack *extack)
+
 {
 	struct rmnet_priv *priv = netdev_priv(rmnet_dev);
 	int rc;
 
-	if (ep->egress_dev)
-		return -EINVAL;
-
-	if (rmnet_get_endpoint(port, id))
+	if (rmnet_get_endpoint(port, id)) {
+		NL_SET_ERR_MSG_MOD(extack, "MUX ID already exists");
 		return -EBUSY;
+	}
 
 	rmnet_dev->hw_features = NETIF_F_RXCSUM;
 	rmnet_dev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;

commit d939b6d30bea1a2322bc536b12be0a7c4c2bccd7
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Thu Feb 27 12:26:02 2020 +0000

    net: rmnet: fix bridge mode bugs
    
    In order to attach a bridge interface to the rmnet interface,
    "master" operation is used.
    (e.g. ip link set dummy1 master rmnet0)
    But, in the rmnet_add_bridge(), which is a callback of ->ndo_add_slave()
    doesn't register lower interface.
    So, ->ndo_del_slave() doesn't work.
    There are other problems too.
    1. It couldn't detect circular upper/lower interface relationship.
    2. It couldn't prevent stack overflow because of too deep depth
    of upper/lower interface
    3. It doesn't check the number of lower interfaces.
    4. Panics because of several reasons.
    
    The root problem of these issues is actually the same.
    So, in this patch, these all problems will be fixed.
    
    Test commands:
        modprobe rmnet
        ip link add dummy0 type dummy
        ip link add rmnet0 link dummy0 type rmnet mux_id 1
        ip link add dummy1 master rmnet0 type dummy
        ip link add dummy2 master rmnet0 type dummy
        ip link del rmnet0
        ip link del dummy2
        ip link del dummy1
    
    Splat looks like:
    [   41.867595][ T1164] general protection fault, probably for non-canonical address 0xdffffc0000000101I
    [   41.869993][ T1164] KASAN: null-ptr-deref in range [0x0000000000000808-0x000000000000080f]
    [   41.872950][ T1164] CPU: 0 PID: 1164 Comm: ip Not tainted 5.6.0-rc1+ #447
    [   41.873915][ T1164] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [   41.875161][ T1164] RIP: 0010:rmnet_unregister_bridge.isra.6+0x71/0xf0 [rmnet]
    [   41.876178][ T1164] Code: 48 89 ef 48 89 c6 5b 5d e9 fc fe ff ff e8 f7 f3 ff ff 48 8d b8 08 08 00 00 48 ba 00 7
    [   41.878925][ T1164] RSP: 0018:ffff8880c4d0f188 EFLAGS: 00010202
    [   41.879774][ T1164] RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000101
    [   41.887689][ T1164] RDX: dffffc0000000000 RSI: ffffffffb8cf64f0 RDI: 0000000000000808
    [   41.888727][ T1164] RBP: ffff8880c40e4000 R08: ffffed101b3c0e3c R09: 0000000000000001
    [   41.889749][ T1164] R10: 0000000000000001 R11: ffffed101b3c0e3b R12: 1ffff110189a1e3c
    [   41.890783][ T1164] R13: ffff8880c4d0f200 R14: ffffffffb8d56160 R15: ffff8880ccc2c000
    [   41.891794][ T1164] FS:  00007f4300edc0c0(0000) GS:ffff8880d9c00000(0000) knlGS:0000000000000000
    [   41.892953][ T1164] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   41.893800][ T1164] CR2: 00007f43003bc8c0 CR3: 00000000ca53e001 CR4: 00000000000606f0
    [   41.894824][ T1164] Call Trace:
    [   41.895274][ T1164]  ? rcu_is_watching+0x2c/0x80
    [   41.895895][ T1164]  rmnet_config_notify_cb+0x1f7/0x590 [rmnet]
    [   41.896687][ T1164]  ? rmnet_unregister_bridge.isra.6+0xf0/0xf0 [rmnet]
    [   41.897611][ T1164]  ? rmnet_unregister_bridge.isra.6+0xf0/0xf0 [rmnet]
    [   41.898508][ T1164]  ? __module_text_address+0x13/0x140
    [   41.899162][ T1164]  notifier_call_chain+0x90/0x160
    [   41.899814][ T1164]  rollback_registered_many+0x660/0xcf0
    [   41.900544][ T1164]  ? netif_set_real_num_tx_queues+0x780/0x780
    [   41.901316][ T1164]  ? __lock_acquire+0xdfe/0x3de0
    [   41.901958][ T1164]  ? memset+0x1f/0x40
    [   41.902468][ T1164]  ? __nla_validate_parse+0x98/0x1ab0
    [   41.903166][ T1164]  unregister_netdevice_many.part.133+0x13/0x1b0
    [   41.903988][ T1164]  rtnl_delete_link+0xbc/0x100
    [ ... ]
    
    Fixes: 60d58f971c10 ("net: qualcomm: rmnet: Implement bridge mode")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
index 509dfc895a33..26ad40f19c64 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -266,14 +266,6 @@ int rmnet_vnd_dellink(u8 id, struct rmnet_port *port,
 	return 0;
 }
 
-u8 rmnet_vnd_get_mux(struct net_device *rmnet_dev)
-{
-	struct rmnet_priv *priv;
-
-	priv = netdev_priv(rmnet_dev);
-	return priv->mux_id;
-}
-
 int rmnet_vnd_do_flow_control(struct net_device *rmnet_dev, int enable)
 {
 	netdev_dbg(rmnet_dev, "Setting VND TX queue state to %d\n", enable);

commit 97fb5e8d9b57f10f294303c9a5d1bd033eded6bf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:17:58 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 284
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 and
      only version 2 as published by the free software foundation this
      program is distributed in the hope that it will be useful but
      without any warranty without even the implied warranty of
      merchantability or fitness for a particular purpose see the gnu
      general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 294 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141900.825281744@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
index d11c16aeb19a..509dfc895a33 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -1,17 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /* Copyright (c) 2013-2018, The Linux Foundation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
  *
  * RMNET Data virtual network driver
- *
  */
 
 #include <linux/etherdevice.h>

commit d02854dc1999ed3e7fd79ec700c64ac23ac0c458
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Fri Nov 9 18:56:27 2018 -0700

    net: qualcomm: rmnet: Fix incorrect assignment of real_dev
    
    A null dereference was observed when a sysctl was being set
    from userspace and rmnet was stuck trying to complete some actions
    in the NETDEV_REGISTER callback. This is because the real_dev is set
    only after the device registration handler completes.
    
    sysctl call stack -
    
    <6> Unable to handle kernel NULL pointer dereference at
        virtual address 00000108
    <2> pc : rmnet_vnd_get_iflink+0x1c/0x28
    <2> lr : dev_get_iflink+0x2c/0x40
    <2>  rmnet_vnd_get_iflink+0x1c/0x28
    <2>  inet6_fill_ifinfo+0x15c/0x234
    <2>  inet6_ifinfo_notify+0x68/0xd4
    <2>  ndisc_ifinfo_sysctl_change+0x1b8/0x234
    <2>  proc_sys_call_handler+0xac/0x100
    <2>  proc_sys_write+0x3c/0x4c
    <2>  __vfs_write+0x54/0x14c
    <2>  vfs_write+0xcc/0x188
    <2>  SyS_write+0x60/0xc0
    <2>  el0_svc_naked+0x34/0x38
    
    device register call stack -
    
    <2>  notifier_call_chain+0x84/0xbc
    <2>  raw_notifier_call_chain+0x38/0x48
    <2>  call_netdevice_notifiers_info+0x40/0x70
    <2>  call_netdevice_notifiers+0x38/0x60
    <2>  register_netdevice+0x29c/0x3d8
    <2>  rmnet_vnd_newlink+0x68/0xe8
    <2>  rmnet_newlink+0xa0/0x160
    <2>  rtnl_newlink+0x57c/0x6c8
    <2>  rtnetlink_rcv_msg+0x1dc/0x328
    <2>  netlink_rcv_skb+0xac/0x118
    <2>  rtnetlink_rcv+0x24/0x30
    <2>  netlink_unicast+0x158/0x1f0
    <2>  netlink_sendmsg+0x32c/0x338
    <2>  sock_sendmsg+0x44/0x60
    <2>  SyS_sendto+0x150/0x1ac
    <2>  el0_svc_naked+0x34/0x38
    
    Fixes: b752eff5be24 ("net: qualcomm: rmnet: Implement ndo_get_iflink")
    Signed-off-by: Sean Tranchetti <stranche@codeaurora.org>
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
index 0afc3d335d56..d11c16aeb19a 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -234,7 +234,7 @@ int rmnet_vnd_newlink(u8 id, struct net_device *rmnet_dev,
 		      struct net_device *real_dev,
 		      struct rmnet_endpoint *ep)
 {
-	struct rmnet_priv *priv;
+	struct rmnet_priv *priv = netdev_priv(rmnet_dev);
 	int rc;
 
 	if (ep->egress_dev)
@@ -247,6 +247,8 @@ int rmnet_vnd_newlink(u8 id, struct net_device *rmnet_dev,
 	rmnet_dev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
 	rmnet_dev->hw_features |= NETIF_F_SG;
 
+	priv->real_dev = real_dev;
+
 	rc = register_netdevice(rmnet_dev);
 	if (!rc) {
 		ep->egress_dev = rmnet_dev;
@@ -255,9 +257,7 @@ int rmnet_vnd_newlink(u8 id, struct net_device *rmnet_dev,
 
 		rmnet_dev->rtnl_link_ops = &rmnet_link_ops;
 
-		priv = netdev_priv(rmnet_dev);
 		priv->mux_id = id;
-		priv->real_dev = real_dev;
 
 		netdev_dbg(rmnet_dev, "rmnet dev created\n");
 	}

commit 6c1f0a1ffb7c2b0501521b9fc1f53b4109f1791b
Author: Joe Perches <joe@perches.com>
Date:   Fri Jun 22 10:51:00 2018 -0700

    net: drivers/net: Convert random_ether_addr to eth_random_addr
    
    random_ether_addr is a #define for eth_random_addr which is
    generally preferred in kernel code by ~3:1
    
    Convert the uses of random_ether_addr to enable removing the #define
    
    Miscellanea:
    
    o Convert &vfmac[0] to equivalent vfmac and avoid unnecessary line wrap
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
index b9a7548ec6a0..0afc3d335d56 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -210,7 +210,7 @@ void rmnet_vnd_setup(struct net_device *rmnet_dev)
 	rmnet_dev->netdev_ops = &rmnet_vnd_ops;
 	rmnet_dev->mtu = RMNET_DFLT_PACKET_SIZE;
 	rmnet_dev->needed_headroom = RMNET_NEEDED_HEADROOM;
-	random_ether_addr(rmnet_dev->dev_addr);
+	eth_random_addr(rmnet_dev->dev_addr);
 	rmnet_dev->tx_queue_len = RMNET_TX_QUEUE_LEN;
 
 	/* Raw IP mode */

commit 9deb441c113ae9e761e42f78d90736d762ff49a3
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Mon Jun 4 19:26:07 2018 -0600

    net: ipv6: Generate random IID for addresses on RAWIP devices
    
    RAWIP devices such as rmnet do not have a hardware address and
    instead require the kernel to generate a random IID for the
    IPv6 addresses.
    
    Signed-off-by: Sean Tranchetti <stranche@codeaurora.org>
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
index cb02e1a015c1..b9a7548ec6a0 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -221,6 +221,10 @@ void rmnet_vnd_setup(struct net_device *rmnet_dev)
 
 	rmnet_dev->needs_free_netdev = true;
 	rmnet_dev->ethtool_ops = &rmnet_ethtool_ops;
+
+	/* This perm addr will be used as interface identifier by IPv6 */
+	rmnet_dev->addr_assign_type = NET_ADDR_RANDOM;
+	eth_random_addr(rmnet_dev->perm_addr);
 }
 
 /* Exposed API */

commit bbde32d38bfbbc4a6970498c7470a8a817122735
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Tue May 15 18:52:01 2018 -0600

    net: qualcomm: rmnet: Add support for ethtool private stats
    
    Add ethtool private stats handler to debug the handling of packets
    with checksum offload header / trailer. This allows to keep track of
    the number of packets for which hardware computes the checksum and
    counts and reasons where checksum computation was skipped in hardware
    and was done in the network stack.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
index 2ea16a088de8..cb02e1a015c1 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -152,6 +152,56 @@ static const struct net_device_ops rmnet_vnd_ops = {
 	.ndo_get_stats64 = rmnet_get_stats64,
 };
 
+static const char rmnet_gstrings_stats[][ETH_GSTRING_LEN] = {
+	"Checksum ok",
+	"Checksum valid bit not set",
+	"Checksum validation failed",
+	"Checksum error bad buffer",
+	"Checksum error bad ip version",
+	"Checksum error bad transport",
+	"Checksum skipped on ip fragment",
+	"Checksum skipped",
+	"Checksum computed in software",
+};
+
+static void rmnet_get_strings(struct net_device *dev, u32 stringset, u8 *buf)
+{
+	switch (stringset) {
+	case ETH_SS_STATS:
+		memcpy(buf, &rmnet_gstrings_stats,
+		       sizeof(rmnet_gstrings_stats));
+		break;
+	}
+}
+
+static int rmnet_get_sset_count(struct net_device *dev, int sset)
+{
+	switch (sset) {
+	case ETH_SS_STATS:
+		return ARRAY_SIZE(rmnet_gstrings_stats);
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+static void rmnet_get_ethtool_stats(struct net_device *dev,
+				    struct ethtool_stats *stats, u64 *data)
+{
+	struct rmnet_priv *priv = netdev_priv(dev);
+	struct rmnet_priv_stats *st = &priv->stats;
+
+	if (!data)
+		return;
+
+	memcpy(data, st, ARRAY_SIZE(rmnet_gstrings_stats) * sizeof(u64));
+}
+
+static const struct ethtool_ops rmnet_ethtool_ops = {
+	.get_ethtool_stats = rmnet_get_ethtool_stats,
+	.get_strings = rmnet_get_strings,
+	.get_sset_count = rmnet_get_sset_count,
+};
+
 /* Called by kernel whenever a new rmnet<n> device is created. Sets MTU,
  * flags, ARP type, needed headroom, etc...
  */
@@ -170,6 +220,7 @@ void rmnet_vnd_setup(struct net_device *rmnet_dev)
 	rmnet_dev->flags &= ~(IFF_BROADCAST | IFF_MULTICAST);
 
 	rmnet_dev->needs_free_netdev = true;
+	rmnet_dev->ethtool_ops = &rmnet_ethtool_ops;
 }
 
 /* Exposed API */

commit 9dcaec042600dce169ae74527e5eead349f8eb90
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Wed Mar 21 19:48:12 2018 -0600

    net: qualcomm: rmnet: Update copyright year to 2018
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
index 346d310914df..2ea16a088de8 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2013-2017, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2013-2018, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and

commit 4dba8bbce94541c560940ac65ca9cd563fd43348
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Fri Feb 16 15:56:38 2018 -0700

    net: qualcomm: rmnet: Fix warning seen with 64 bit stats
    
    With CONFIG_DEBUG_PREEMPT enabled, a warning was seen on device
    creation. This occurs due to the incorrect cpu API usage in
    ndo_get_stats64 handler.
    
    BUG: using smp_processor_id() in preemptible [00000000] code: rmnetcli/5743
    caller is debug_smp_processor_id+0x1c/0x24
    Call trace:
    [<ffffff9d48c8967c>] dump_backtrace+0x0/0x2a8
    [<ffffff9d48c89bbc>] show_stack+0x20/0x28
    [<ffffff9d4901fff8>] dump_stack+0xa8/0xe0
    [<ffffff9d490421e0>] check_preemption_disabled+0x104/0x108
    [<ffffff9d49042200>] debug_smp_processor_id+0x1c/0x24
    [<ffffff9d494a36b0>] rmnet_get_stats64+0x64/0x13c
    [<ffffff9d49b014e0>] dev_get_stats+0x68/0xd8
    [<ffffff9d49d58df8>] rtnl_fill_stats+0x54/0x140
    [<ffffff9d49b1f0b8>] rtnl_fill_ifinfo+0x428/0x9cc
    [<ffffff9d49b23834>] rtmsg_ifinfo_build_skb+0x80/0xf4
    [<ffffff9d49b23930>] rtnetlink_event+0x88/0xb4
    [<ffffff9d48cd21b4>] raw_notifier_call_chain+0x58/0x78
    [<ffffff9d49b028a4>] call_netdevice_notifiers_info+0x48/0x78
    [<ffffff9d49b08bf8>] __netdev_upper_dev_link+0x290/0x5e8
    [<ffffff9d49b08fcc>] netdev_master_upper_dev_link+0x3c/0x48
    [<ffffff9d494a2e74>] rmnet_newlink+0xf0/0x1c8
    [<ffffff9d49b23360>] rtnl_newlink+0x57c/0x6c8
    [<ffffff9d49b2355c>] rtnetlink_rcv_msg+0xb0/0x244
    [<ffffff9d49b5230c>] netlink_rcv_skb+0xb4/0xdc
    [<ffffff9d49b204f4>] rtnetlink_rcv+0x34/0x44
    [<ffffff9d49b51af0>] netlink_unicast+0x1ec/0x294
    [<ffffff9d49b51fdc>] netlink_sendmsg+0x320/0x390
    [<ffffff9d49ae6858>] sock_sendmsg+0x54/0x60
    [<ffffff9d49ae91bc>] SyS_sendto+0x1a0/0x1e4
    [<ffffff9d48c83770>] el0_svc_naked+0x24/0x28
    
    Fixes: 192c4b5d48f2 ("net: qualcomm: rmnet: Add support for 64 bit stats")
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
index 570a227acdd8..346d310914df 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -121,7 +121,7 @@ static void rmnet_get_stats64(struct net_device *dev,
 	memset(&total_stats, 0, sizeof(struct rmnet_vnd_stats));
 
 	for_each_possible_cpu(cpu) {
-		pcpu_ptr = this_cpu_ptr(priv->pcpu_stats);
+		pcpu_ptr = per_cpu_ptr(priv->pcpu_stats, cpu);
 
 		do {
 			start = u64_stats_fetch_begin_irq(&pcpu_ptr->syncp);

commit 0c9214d5ed70486d7cfd99fa56fdc98b2c4c1962
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Sun Jan 7 11:36:40 2018 -0700

    net: qualcomm: rmnet: Add support for GSO
    
    Real devices may support scatter gather(SG), so enable SG on rmnet
    devices to use GSO. GSO reduces CPU cycles by 20% for a rate of
    146Mpbs for a single stream TCP connection.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
index f7f57ce931e3..570a227acdd8 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -190,6 +190,7 @@ int rmnet_vnd_newlink(u8 id, struct net_device *rmnet_dev,
 
 	rmnet_dev->hw_features = NETIF_F_RXCSUM;
 	rmnet_dev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
+	rmnet_dev->hw_features |= NETIF_F_SG;
 
 	rc = register_netdevice(rmnet_dev);
 	if (!rc) {

commit 5eb5f8608ef118c2cfefc10c8dbbb89b14fac506
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Sun Jan 7 11:36:39 2018 -0700

    net: qualcomm: rmnet: Add support for TX checksum offload
    
    TX checksum offload applies to TCP / UDP packets which are not
    fragmented using the MAPv4 checksum trailer. The following needs to be
    done to have checksum computed in hardware -
    
    1. Set the checksum start offset and inset offset.
    2. Set the csum_enabled bit
    3. Compute and set 1's complement of partial checksum field in
       transport header.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
index 879a2e01acdb..f7f57ce931e3 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -189,6 +189,7 @@ int rmnet_vnd_newlink(u8 id, struct net_device *rmnet_dev,
 		return -EBUSY;
 
 	rmnet_dev->hw_features = NETIF_F_RXCSUM;
+	rmnet_dev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
 
 	rc = register_netdevice(rmnet_dev);
 	if (!rc) {

commit bbd21b247cb596a426a1df0ad7658f141f558f86
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Sun Jan 7 11:36:37 2018 -0700

    net: qualcomm: rmnet: Add support for RX checksum offload
    
    When using the MAPv4 packet format, receive checksum offload can be
    enabled in hardware. The checksum computation over pseudo header is
    not offloaded but the rest of the checksum computation over
    the payload is offloaded. This applies only for TCP / UDP packets
    which are not fragmented.
    
    rmnet validates the TCP/UDP checksum for the packet using the checksum
    from the checksum trailer added to the packet by hardware. The
    validation performed is as following -
    
    1. Perform 1's complement over the checksum value from the trailer
    2. Compute 1's complement checksum over IPv4 / IPv6 header and
       subtracts it from the value from step 1
    3. Computes 1's complement checksum over IPv4 / IPv6 pseudo header and
       adds it to the value from step 2
    4. Subtracts the checksum value from the TCP / UDP header from the
       value from step 3.
    5. Compares the value from step 4 to the checksum value from the
       TCP / UDP header.
    6. If the comparison in step 5 succeeds, CHECKSUM_UNNECESSARY is set
       and the packet is passed on to network stack. If there is a
       failure, then the packet is passed on as such without modifying
       the ip_summed field.
    
    The checksum field is also checked for UDP checksum 0 as per RFC 768
    and for unexpected TCP checksum of 0.
    
    If checksum offload is disabled when using MAPv4 packet format in
    receive path, the packet is queued as is to network stack without
    the validations above.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
index 5bb29f44d114..879a2e01acdb 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -188,6 +188,8 @@ int rmnet_vnd_newlink(u8 id, struct net_device *rmnet_dev,
 	if (rmnet_get_endpoint(port, id))
 		return -EBUSY;
 
+	rmnet_dev->hw_features = NETIF_F_RXCSUM;
+
 	rc = register_netdevice(rmnet_dev);
 	if (!rc) {
 		ep->egress_dev = rmnet_dev;

commit e971a9a09da356d1fc7be1d815a3a379590d2835
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Mon Dec 11 17:30:12 2017 -0700

    net: qualcomm: rmnet: Allow only one rmnet dev per muxid per real dev
    
    Upon de-multiplexing data from one real dev, the packets can be sent
    to an unique rmnet device for a given mux id.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
index 9caa5e387450..5bb29f44d114 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -185,6 +185,9 @@ int rmnet_vnd_newlink(u8 id, struct net_device *rmnet_dev,
 	if (ep->egress_dev)
 		return -EINVAL;
 
+	if (rmnet_get_endpoint(port, id))
+		return -EBUSY;
+
 	rc = register_netdevice(rmnet_dev);
 	if (!rc) {
 		ep->egress_dev = rmnet_dev;

commit ca32fb034c19e00cfb5e0fd7217eb92f81302048
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Thu Oct 26 11:06:49 2017 -0600

    net: qualcomm: rmnet: Add support for GRO
    
    Add gro_cells so that rmnet devices can call gro_cells_receive
    instead of netif_receive_skb.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Cc: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
index b0befa18cb10..9caa5e387450 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -87,11 +87,18 @@ static int rmnet_vnd_get_iflink(const struct net_device *dev)
 static int rmnet_vnd_init(struct net_device *dev)
 {
 	struct rmnet_priv *priv = netdev_priv(dev);
+	int err;
 
 	priv->pcpu_stats = alloc_percpu(struct rmnet_pcpu_stats);
 	if (!priv->pcpu_stats)
 		return -ENOMEM;
 
+	err = gro_cells_init(&priv->gro_cells, dev);
+	if (err) {
+		free_percpu(priv->pcpu_stats);
+		return err;
+	}
+
 	return 0;
 }
 
@@ -99,6 +106,7 @@ static void rmnet_vnd_uninit(struct net_device *dev)
 {
 	struct rmnet_priv *priv = netdev_priv(dev);
 
+	gro_cells_destroy(&priv->gro_cells);
 	free_percpu(priv->pcpu_stats);
 }
 

commit 192c4b5d48f2ae25a4ce323b4cb8b024fac3efd2
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Thu Oct 26 11:06:48 2017 -0600

    net: qualcomm: rmnet: Add support for 64 bit stats
    
    Implement 64 bit per cpu stats.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
index 12bd0bbd5235..b0befa18cb10 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -27,14 +27,28 @@
 
 void rmnet_vnd_rx_fixup(struct sk_buff *skb, struct net_device *dev)
 {
-	dev->stats.rx_packets++;
-	dev->stats.rx_bytes += skb->len;
+	struct rmnet_priv *priv = netdev_priv(dev);
+	struct rmnet_pcpu_stats *pcpu_ptr;
+
+	pcpu_ptr = this_cpu_ptr(priv->pcpu_stats);
+
+	u64_stats_update_begin(&pcpu_ptr->syncp);
+	pcpu_ptr->stats.rx_pkts++;
+	pcpu_ptr->stats.rx_bytes += skb->len;
+	u64_stats_update_end(&pcpu_ptr->syncp);
 }
 
 void rmnet_vnd_tx_fixup(struct sk_buff *skb, struct net_device *dev)
 {
-	dev->stats.tx_packets++;
-	dev->stats.tx_bytes += skb->len;
+	struct rmnet_priv *priv = netdev_priv(dev);
+	struct rmnet_pcpu_stats *pcpu_ptr;
+
+	pcpu_ptr = this_cpu_ptr(priv->pcpu_stats);
+
+	u64_stats_update_begin(&pcpu_ptr->syncp);
+	pcpu_ptr->stats.tx_pkts++;
+	pcpu_ptr->stats.tx_bytes += skb->len;
+	u64_stats_update_end(&pcpu_ptr->syncp);
 }
 
 /* Network Device Operations */
@@ -48,7 +62,7 @@ static netdev_tx_t rmnet_vnd_start_xmit(struct sk_buff *skb,
 	if (priv->real_dev) {
 		rmnet_egress_handler(skb);
 	} else {
-		dev->stats.tx_dropped++;
+		this_cpu_inc(priv->pcpu_stats->stats.tx_drops);
 		kfree_skb(skb);
 	}
 	return NETDEV_TX_OK;
@@ -70,12 +84,64 @@ static int rmnet_vnd_get_iflink(const struct net_device *dev)
 	return priv->real_dev->ifindex;
 }
 
+static int rmnet_vnd_init(struct net_device *dev)
+{
+	struct rmnet_priv *priv = netdev_priv(dev);
+
+	priv->pcpu_stats = alloc_percpu(struct rmnet_pcpu_stats);
+	if (!priv->pcpu_stats)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static void rmnet_vnd_uninit(struct net_device *dev)
+{
+	struct rmnet_priv *priv = netdev_priv(dev);
+
+	free_percpu(priv->pcpu_stats);
+}
+
+static void rmnet_get_stats64(struct net_device *dev,
+			      struct rtnl_link_stats64 *s)
+{
+	struct rmnet_priv *priv = netdev_priv(dev);
+	struct rmnet_vnd_stats total_stats;
+	struct rmnet_pcpu_stats *pcpu_ptr;
+	unsigned int cpu, start;
+
+	memset(&total_stats, 0, sizeof(struct rmnet_vnd_stats));
+
+	for_each_possible_cpu(cpu) {
+		pcpu_ptr = this_cpu_ptr(priv->pcpu_stats);
+
+		do {
+			start = u64_stats_fetch_begin_irq(&pcpu_ptr->syncp);
+			total_stats.rx_pkts += pcpu_ptr->stats.rx_pkts;
+			total_stats.rx_bytes += pcpu_ptr->stats.rx_bytes;
+			total_stats.tx_pkts += pcpu_ptr->stats.tx_pkts;
+			total_stats.tx_bytes += pcpu_ptr->stats.tx_bytes;
+		} while (u64_stats_fetch_retry_irq(&pcpu_ptr->syncp, start));
+
+		total_stats.tx_drops += pcpu_ptr->stats.tx_drops;
+	}
+
+	s->rx_packets = total_stats.rx_pkts;
+	s->rx_bytes = total_stats.rx_bytes;
+	s->tx_packets = total_stats.tx_pkts;
+	s->tx_bytes = total_stats.tx_bytes;
+	s->tx_dropped = total_stats.tx_drops;
+}
+
 static const struct net_device_ops rmnet_vnd_ops = {
 	.ndo_start_xmit = rmnet_vnd_start_xmit,
 	.ndo_change_mtu = rmnet_vnd_change_mtu,
 	.ndo_get_iflink = rmnet_vnd_get_iflink,
 	.ndo_add_slave  = rmnet_add_bridge,
 	.ndo_del_slave  = rmnet_del_bridge,
+	.ndo_init       = rmnet_vnd_init,
+	.ndo_uninit     = rmnet_vnd_uninit,
+	.ndo_get_stats64 = rmnet_get_stats64,
 };
 
 /* Called by kernel whenever a new rmnet<n> device is created. Sets MTU,

commit 60d58f971c1077a0f2467b2d5bc38058df43a819
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Wed Oct 11 18:43:58 2017 -0600

    net: qualcomm: rmnet: Implement bridge mode
    
    Add support to bridge two devices which can send multiplexing and
    aggregation (MAP) data. This is done only when the data itself is
    not going to be consumed in the stack but is being passed on to a
    different endpoint. This is mainly used for testing.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
index 1b6747d7154f..12bd0bbd5235 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -74,6 +74,8 @@ static const struct net_device_ops rmnet_vnd_ops = {
 	.ndo_start_xmit = rmnet_vnd_start_xmit,
 	.ndo_change_mtu = rmnet_vnd_change_mtu,
 	.ndo_get_iflink = rmnet_vnd_get_iflink,
+	.ndo_add_slave  = rmnet_add_bridge,
+	.ndo_del_slave  = rmnet_del_bridge,
 };
 
 /* Called by kernel whenever a new rmnet<n> device is created. Sets MTU,

commit 3352e6c45760fd6675468a35ef699ab94617cab4
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Wed Oct 11 18:43:57 2017 -0600

    net: qualcomm: rmnet: Convert the muxed endpoint to hlist
    
    Rather than using a static array, use a hlist to store the muxed
    endpoints and use the mux id to query the rmnet_device.
    This is useful as usually very few mux ids are used.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Cc: Dan Williams <dcbw@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
index 8b8497b17f52..1b6747d7154f 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -100,17 +100,19 @@ void rmnet_vnd_setup(struct net_device *rmnet_dev)
 
 int rmnet_vnd_newlink(u8 id, struct net_device *rmnet_dev,
 		      struct rmnet_port *port,
-		      struct net_device *real_dev)
+		      struct net_device *real_dev,
+		      struct rmnet_endpoint *ep)
 {
 	struct rmnet_priv *priv;
 	int rc;
 
-	if (port->muxed_ep[id].egress_dev)
+	if (ep->egress_dev)
 		return -EINVAL;
 
 	rc = register_netdevice(rmnet_dev);
 	if (!rc) {
-		port->muxed_ep[id].egress_dev = rmnet_dev;
+		ep->egress_dev = rmnet_dev;
+		ep->mux_id = id;
 		port->nr_rmnet_devs++;
 
 		rmnet_dev->rtnl_link_ops = &rmnet_link_ops;
@@ -125,12 +127,13 @@ int rmnet_vnd_newlink(u8 id, struct net_device *rmnet_dev,
 	return rc;
 }
 
-int rmnet_vnd_dellink(u8 id, struct rmnet_port *port)
+int rmnet_vnd_dellink(u8 id, struct rmnet_port *port,
+		      struct rmnet_endpoint *ep)
 {
-	if (id >= RMNET_MAX_LOGICAL_EP || !port->muxed_ep[id].egress_dev)
+	if (id >= RMNET_MAX_LOGICAL_EP || !ep->egress_dev)
 		return -EINVAL;
 
-	port->muxed_ep[id].egress_dev = NULL;
+	ep->egress_dev = NULL;
 	port->nr_rmnet_devs--;
 	return 0;
 }

commit 5451237ff7a77ded1d81538e3daa76dc3ee60538
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Wed Oct 11 18:43:56 2017 -0600

    net: qualcomm: rmnet: Remove duplicate setting of rmnet_devices
    
    The rmnet_devices information is already stored in muxed_ep, so
    storing this in rmnet_devices[] again is redundant.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
index 4ca59a4389b8..8b8497b17f52 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -105,12 +105,12 @@ int rmnet_vnd_newlink(u8 id, struct net_device *rmnet_dev,
 	struct rmnet_priv *priv;
 	int rc;
 
-	if (port->rmnet_devices[id])
+	if (port->muxed_ep[id].egress_dev)
 		return -EINVAL;
 
 	rc = register_netdevice(rmnet_dev);
 	if (!rc) {
-		port->rmnet_devices[id] = rmnet_dev;
+		port->muxed_ep[id].egress_dev = rmnet_dev;
 		port->nr_rmnet_devs++;
 
 		rmnet_dev->rtnl_link_ops = &rmnet_link_ops;
@@ -127,10 +127,10 @@ int rmnet_vnd_newlink(u8 id, struct net_device *rmnet_dev,
 
 int rmnet_vnd_dellink(u8 id, struct rmnet_port *port)
 {
-	if (id >= RMNET_MAX_LOGICAL_EP || !port->rmnet_devices[id])
+	if (id >= RMNET_MAX_LOGICAL_EP || !port->muxed_ep[id].egress_dev)
 		return -EINVAL;
 
-	port->rmnet_devices[id] = NULL;
+	port->muxed_ep[id].egress_dev = NULL;
 	port->nr_rmnet_devs--;
 	return 0;
 }

commit 56470c927f1ba1e101b5e5a93e02d23a14fd99b7
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Wed Oct 11 18:43:55 2017 -0600

    net: qualcomm: rmnet: Remove duplicate setting of rmnet private info
    
    The end point is set twice in the local_ep as well as the mux_id and
    the real_dev in the rmnet private structure. Remove the local_ep.
    While these elements are equivalent, rmnet_endpoint will be
    used only as part of the rmnet_port for muxed scenarios in VND mode.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
index 7f90d5587653..4ca59a4389b8 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -45,8 +45,8 @@ static netdev_tx_t rmnet_vnd_start_xmit(struct sk_buff *skb,
 	struct rmnet_priv *priv;
 
 	priv = netdev_priv(dev);
-	if (priv->local_ep.egress_dev) {
-		rmnet_egress_handler(skb, &priv->local_ep);
+	if (priv->real_dev) {
+		rmnet_egress_handler(skb);
 	} else {
 		dev->stats.tx_dropped++;
 		kfree_skb(skb);
@@ -143,21 +143,6 @@ u8 rmnet_vnd_get_mux(struct net_device *rmnet_dev)
 	return priv->mux_id;
 }
 
-/* Gets the logical endpoint configuration for a RmNet virtual network device
- * node. Caller should confirm that devices is a RmNet VND before calling.
- */
-struct rmnet_endpoint *rmnet_vnd_get_endpoint(struct net_device *rmnet_dev)
-{
-	struct rmnet_priv *priv;
-
-	if (!rmnet_dev)
-		return NULL;
-
-	priv = netdev_priv(rmnet_dev);
-
-	return &priv->local_ep;
-}
-
 int rmnet_vnd_do_flow_control(struct net_device *rmnet_dev, int enable)
 {
 	netdev_dbg(rmnet_dev, "Setting VND TX queue state to %d\n", enable);

commit b665f4f82d31c17926df3ac7c4a59bbff7af463b
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Sat Sep 2 23:30:46 2017 -0600

    net: qualcomm: rmnet: Rename real_dev_info to port
    
    Make it similar to drivers like ipvlan / macvlan so it is easier to read.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Cc: Dan Williams <dcbw@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
index f5c63b78338b..7f90d5587653 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -99,19 +99,20 @@ void rmnet_vnd_setup(struct net_device *rmnet_dev)
 /* Exposed API */
 
 int rmnet_vnd_newlink(u8 id, struct net_device *rmnet_dev,
-		      struct rmnet_real_dev_info *r,
+		      struct rmnet_port *port,
 		      struct net_device *real_dev)
 {
 	struct rmnet_priv *priv;
 	int rc;
 
-	if (r->rmnet_devices[id])
+	if (port->rmnet_devices[id])
 		return -EINVAL;
 
 	rc = register_netdevice(rmnet_dev);
 	if (!rc) {
-		r->rmnet_devices[id] = rmnet_dev;
-		r->nr_rmnet_devs++;
+		port->rmnet_devices[id] = rmnet_dev;
+		port->nr_rmnet_devs++;
+
 		rmnet_dev->rtnl_link_ops = &rmnet_link_ops;
 
 		priv = netdev_priv(rmnet_dev);
@@ -124,13 +125,13 @@ int rmnet_vnd_newlink(u8 id, struct net_device *rmnet_dev,
 	return rc;
 }
 
-int rmnet_vnd_dellink(u8 id, struct rmnet_real_dev_info *r)
+int rmnet_vnd_dellink(u8 id, struct rmnet_port *port)
 {
-	if (id >= RMNET_MAX_LOGICAL_EP || !r->rmnet_devices[id])
+	if (id >= RMNET_MAX_LOGICAL_EP || !port->rmnet_devices[id])
 		return -EINVAL;
 
-	r->rmnet_devices[id] = NULL;
-	r->nr_rmnet_devs--;
+	port->rmnet_devices[id] = NULL;
+	port->nr_rmnet_devs--;
 	return 0;
 }
 

commit b752eff5be24ec146393944848d2ffbef92b43a7
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Sat Sep 2 23:30:45 2017 -0600

    net: qualcomm: rmnet: Implement ndo_get_iflink
    
    This makes it easier to find out the parent dev.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Cc: Dan Williams <dcbw@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
index a6de0419d68b..f5c63b78338b 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -63,9 +63,17 @@ static int rmnet_vnd_change_mtu(struct net_device *rmnet_dev, int new_mtu)
 	return 0;
 }
 
+static int rmnet_vnd_get_iflink(const struct net_device *dev)
+{
+	struct rmnet_priv *priv = netdev_priv(dev);
+
+	return priv->real_dev->ifindex;
+}
+
 static const struct net_device_ops rmnet_vnd_ops = {
 	.ndo_start_xmit = rmnet_vnd_start_xmit,
 	.ndo_change_mtu = rmnet_vnd_change_mtu,
+	.ndo_get_iflink = rmnet_vnd_get_iflink,
 };
 
 /* Called by kernel whenever a new rmnet<n> device is created. Sets MTU,
@@ -91,7 +99,8 @@ void rmnet_vnd_setup(struct net_device *rmnet_dev)
 /* Exposed API */
 
 int rmnet_vnd_newlink(u8 id, struct net_device *rmnet_dev,
-		      struct rmnet_real_dev_info *r)
+		      struct rmnet_real_dev_info *r,
+		      struct net_device *real_dev)
 {
 	struct rmnet_priv *priv;
 	int rc;
@@ -107,6 +116,7 @@ int rmnet_vnd_newlink(u8 id, struct net_device *rmnet_dev,
 
 		priv = netdev_priv(rmnet_dev);
 		priv->mux_id = id;
+		priv->real_dev = real_dev;
 
 		netdev_dbg(rmnet_dev, "rmnet dev created\n");
 	}

commit 032ee46828e7a2531c77bf80052fa1237820ec9c
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Sat Sep 2 23:30:44 2017 -0600

    net: qualcomm: rmnet: Refactor the new rmnet dev creation
    
    Data format can be directly set from rmnet_newlink() since the
    rmnet real dev info is already available.
    
    Since __rmnet_get_real_dev_info() is no longer used in rmnet_config.c
    after removal of those functions, move content to
    rmnet_get_real_dev_info().
    
    __rmnet_set_endpoint_config() is collapsed into
    rmnet_set_endpoint_config() since only mux_id was being set additionally
    within it. Remove an unnecessary mux_id check.
    
    Set the mux_id for the rmnet_dev within rmnet_vnd_newlink() itself.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Cc: Dan Williams <dcbw@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
index 7c7305208498..a6de0419d68b 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -93,6 +93,7 @@ void rmnet_vnd_setup(struct net_device *rmnet_dev)
 int rmnet_vnd_newlink(u8 id, struct net_device *rmnet_dev,
 		      struct rmnet_real_dev_info *r)
 {
+	struct rmnet_priv *priv;
 	int rc;
 
 	if (r->rmnet_devices[id])
@@ -103,6 +104,10 @@ int rmnet_vnd_newlink(u8 id, struct net_device *rmnet_dev,
 		r->rmnet_devices[id] = rmnet_dev;
 		r->nr_rmnet_devs++;
 		rmnet_dev->rtnl_link_ops = &rmnet_link_ops;
+
+		priv = netdev_priv(rmnet_dev);
+		priv->mux_id = id;
+
 		netdev_dbg(rmnet_dev, "rmnet dev created\n");
 	}
 
@@ -127,14 +132,6 @@ u8 rmnet_vnd_get_mux(struct net_device *rmnet_dev)
 	return priv->mux_id;
 }
 
-void rmnet_vnd_set_mux(struct net_device *rmnet_dev, u8 mux_id)
-{
-	struct rmnet_priv *priv;
-
-	priv = netdev_priv(rmnet_dev);
-	priv->mux_id = mux_id;
-}
-
 /* Gets the logical endpoint configuration for a RmNet virtual network device
  * node. Caller should confirm that devices is a RmNet VND before calling.
  */

commit 2d516c0d904af52967bb974ee58aa74819d8d05f
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Sat Sep 2 23:30:43 2017 -0600

    net: qualcomm: rmnet: Move the device creation log
    
    The current log is not very useful as it does not log the device
    name since it it is prior to registration -
    
    (unnamed net_device) (uninitialized): Setting up device
    
    Modify to log after the device registration -
    
    rmnet1: rmnet dev created
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
index 0e0001becb61..7c7305208498 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -73,8 +73,6 @@ static const struct net_device_ops rmnet_vnd_ops = {
  */
 void rmnet_vnd_setup(struct net_device *rmnet_dev)
 {
-	netdev_dbg(rmnet_dev, "Setting up device %s\n", rmnet_dev->name);
-
 	rmnet_dev->netdev_ops = &rmnet_vnd_ops;
 	rmnet_dev->mtu = RMNET_DFLT_PACKET_SIZE;
 	rmnet_dev->needed_headroom = RMNET_NEEDED_HEADROOM;
@@ -105,6 +103,7 @@ int rmnet_vnd_newlink(u8 id, struct net_device *rmnet_dev,
 		r->rmnet_devices[id] = rmnet_dev;
 		r->nr_rmnet_devs++;
 		rmnet_dev->rtnl_link_ops = &rmnet_link_ops;
+		netdev_dbg(rmnet_dev, "rmnet dev created\n");
 	}
 
 	return rc;

commit 009e1b2b7a302219562999f3b273bd4cbf4d9b40
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Sat Sep 2 23:30:41 2017 -0600

    net: qualcomm: rmnet: Fix memory corruption if mux_id is greater than 32
    
    rmnet_rtnl_validate() was checking for upto mux_id 254, however the
    rmnet_devices devices could hold upto 32 entries only. Fix this by
    increasing the size of the rmnet_devices.
    
    Fixes: ceed73a2cf4a ("drivers: net: ethernet: qualcomm: rmnet: Initial implementation")
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Cc: Dan Williams <dcbw@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
index bf7455fdafcc..0e0001becb61 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -112,7 +112,7 @@ int rmnet_vnd_newlink(u8 id, struct net_device *rmnet_dev,
 
 int rmnet_vnd_dellink(u8 id, struct rmnet_real_dev_info *r)
 {
-	if (id >= RMNET_MAX_VND || !r->rmnet_devices[id])
+	if (id >= RMNET_MAX_LOGICAL_EP || !r->rmnet_devices[id])
 		return -EINVAL;
 
 	r->rmnet_devices[id] = NULL;

commit 5debc53ffecf79ca1c2d6fc194764cb6a8fa91a9
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Aug 31 15:07:27 2017 +0100

    net: qualcomm: rmnet: remove unused variable priv
    
    priv is being assigned but is never used, so remove it.
    
    Cleans up clang build warning:
    "warning: Value stored to 'priv' is never read"
    
    Fixes: ceed73a2cf4a ("drivers: net: ethernet: qualcomm: rmnet: Initial implementation")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Acked-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
index c8b573d28dcf..bf7455fdafcc 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -73,9 +73,6 @@ static const struct net_device_ops rmnet_vnd_ops = {
  */
 void rmnet_vnd_setup(struct net_device *rmnet_dev)
 {
-	struct rmnet_priv *priv;
-
-	priv = netdev_priv(rmnet_dev);
 	netdev_dbg(rmnet_dev, "Setting up device %s\n", rmnet_dev->name);
 
 	rmnet_dev->netdev_ops = &rmnet_vnd_ops;

commit ceed73a2cf4aff2921802aa3d21d45280677547d
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Tue Aug 29 22:44:18 2017 -0600

    drivers: net: ethernet: qualcomm: rmnet: Initial implementation
    
    RmNet driver provides a transport agnostic MAP (multiplexing and
    aggregation protocol) support in embedded module. Module provides
    virtual network devices which can be attached to any IP-mode
    physical device. This will be used to provide all MAP functionality
    on future hardware in a single consistent location.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
new file mode 100644
index 000000000000..c8b573d28dcf
--- /dev/null
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c
@@ -0,0 +1,170 @@
+/* Copyright (c) 2013-2017, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ * RMNET Data virtual network driver
+ *
+ */
+
+#include <linux/etherdevice.h>
+#include <linux/if_arp.h>
+#include <net/pkt_sched.h>
+#include "rmnet_config.h"
+#include "rmnet_handlers.h"
+#include "rmnet_private.h"
+#include "rmnet_map.h"
+#include "rmnet_vnd.h"
+
+/* RX/TX Fixup */
+
+void rmnet_vnd_rx_fixup(struct sk_buff *skb, struct net_device *dev)
+{
+	dev->stats.rx_packets++;
+	dev->stats.rx_bytes += skb->len;
+}
+
+void rmnet_vnd_tx_fixup(struct sk_buff *skb, struct net_device *dev)
+{
+	dev->stats.tx_packets++;
+	dev->stats.tx_bytes += skb->len;
+}
+
+/* Network Device Operations */
+
+static netdev_tx_t rmnet_vnd_start_xmit(struct sk_buff *skb,
+					struct net_device *dev)
+{
+	struct rmnet_priv *priv;
+
+	priv = netdev_priv(dev);
+	if (priv->local_ep.egress_dev) {
+		rmnet_egress_handler(skb, &priv->local_ep);
+	} else {
+		dev->stats.tx_dropped++;
+		kfree_skb(skb);
+	}
+	return NETDEV_TX_OK;
+}
+
+static int rmnet_vnd_change_mtu(struct net_device *rmnet_dev, int new_mtu)
+{
+	if (new_mtu < 0 || new_mtu > RMNET_MAX_PACKET_SIZE)
+		return -EINVAL;
+
+	rmnet_dev->mtu = new_mtu;
+	return 0;
+}
+
+static const struct net_device_ops rmnet_vnd_ops = {
+	.ndo_start_xmit = rmnet_vnd_start_xmit,
+	.ndo_change_mtu = rmnet_vnd_change_mtu,
+};
+
+/* Called by kernel whenever a new rmnet<n> device is created. Sets MTU,
+ * flags, ARP type, needed headroom, etc...
+ */
+void rmnet_vnd_setup(struct net_device *rmnet_dev)
+{
+	struct rmnet_priv *priv;
+
+	priv = netdev_priv(rmnet_dev);
+	netdev_dbg(rmnet_dev, "Setting up device %s\n", rmnet_dev->name);
+
+	rmnet_dev->netdev_ops = &rmnet_vnd_ops;
+	rmnet_dev->mtu = RMNET_DFLT_PACKET_SIZE;
+	rmnet_dev->needed_headroom = RMNET_NEEDED_HEADROOM;
+	random_ether_addr(rmnet_dev->dev_addr);
+	rmnet_dev->tx_queue_len = RMNET_TX_QUEUE_LEN;
+
+	/* Raw IP mode */
+	rmnet_dev->header_ops = NULL;  /* No header */
+	rmnet_dev->type = ARPHRD_RAWIP;
+	rmnet_dev->hard_header_len = 0;
+	rmnet_dev->flags &= ~(IFF_BROADCAST | IFF_MULTICAST);
+
+	rmnet_dev->needs_free_netdev = true;
+}
+
+/* Exposed API */
+
+int rmnet_vnd_newlink(u8 id, struct net_device *rmnet_dev,
+		      struct rmnet_real_dev_info *r)
+{
+	int rc;
+
+	if (r->rmnet_devices[id])
+		return -EINVAL;
+
+	rc = register_netdevice(rmnet_dev);
+	if (!rc) {
+		r->rmnet_devices[id] = rmnet_dev;
+		r->nr_rmnet_devs++;
+		rmnet_dev->rtnl_link_ops = &rmnet_link_ops;
+	}
+
+	return rc;
+}
+
+int rmnet_vnd_dellink(u8 id, struct rmnet_real_dev_info *r)
+{
+	if (id >= RMNET_MAX_VND || !r->rmnet_devices[id])
+		return -EINVAL;
+
+	r->rmnet_devices[id] = NULL;
+	r->nr_rmnet_devs--;
+	return 0;
+}
+
+u8 rmnet_vnd_get_mux(struct net_device *rmnet_dev)
+{
+	struct rmnet_priv *priv;
+
+	priv = netdev_priv(rmnet_dev);
+	return priv->mux_id;
+}
+
+void rmnet_vnd_set_mux(struct net_device *rmnet_dev, u8 mux_id)
+{
+	struct rmnet_priv *priv;
+
+	priv = netdev_priv(rmnet_dev);
+	priv->mux_id = mux_id;
+}
+
+/* Gets the logical endpoint configuration for a RmNet virtual network device
+ * node. Caller should confirm that devices is a RmNet VND before calling.
+ */
+struct rmnet_endpoint *rmnet_vnd_get_endpoint(struct net_device *rmnet_dev)
+{
+	struct rmnet_priv *priv;
+
+	if (!rmnet_dev)
+		return NULL;
+
+	priv = netdev_priv(rmnet_dev);
+
+	return &priv->local_ep;
+}
+
+int rmnet_vnd_do_flow_control(struct net_device *rmnet_dev, int enable)
+{
+	netdev_dbg(rmnet_dev, "Setting VND TX queue state to %d\n", enable);
+	/* Although we expect similar number of enable/disable
+	 * commands, optimize for the disable. That is more
+	 * latency sensitive than enable
+	 */
+	if (unlikely(enable))
+		netif_wake_queue(rmnet_dev);
+	else
+		netif_stop_queue(rmnet_dev);
+
+	return 0;
+}
