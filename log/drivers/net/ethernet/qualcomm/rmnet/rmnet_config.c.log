commit 2fb2799a2abb39d7dbb48abb3baa1133bf5e921a
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Thu Jul 2 17:08:55 2020 +0000

    net: rmnet: do not allow to add multiple bridge interfaces
    
    rmnet can have only two bridge interface.
    One of them is a link interface and another one is added by
    the master operation.
    rmnet interface shouldn't allow adding additional
    bridge interfaces by mater operation.
    But, there is no code to deny additional interfaces.
    So, interface leak occurs.
    
    Test commands:
        ip link add dummy0 type dummy
        ip link add dummy1 type dummy
        ip link add dummy2 type dummy
        ip link add rmnet0 link dummy0 type rmnet mux_id 1
        ip link set dummy1 master rmnet0
        ip link set dummy2 master rmnet0
        ip link del rmnet0
    
    In the above test command, the dummy0 was attached to rmnet as VND mode.
    Then, dummy1 was attached to rmnet0 as BRIDGE mode.
    At this point, dummy0 mode is switched from VND to BRIDGE automatically.
    Then, dummy2 is attached to rmnet as BRIDGE mode.
    At this point, rmnet0 should deny this operation.
    But, rmnet0 doesn't deny this.
    So that below splat occurs when the rmnet0 interface is deleted.
    
    Splat looks like:
    [  186.684787][    C2] WARNING: CPU: 2 PID: 1009 at net/core/dev.c:8992 rollback_registered_many+0x986/0xcf0
    [  186.684788][    C2] Modules linked in: rmnet dummy openvswitch nsh nf_conncount nf_nat nf_conntrack nf_defrag_x
    [  186.684805][    C2] CPU: 2 PID: 1009 Comm: ip Not tainted 5.8.0-rc1+ #621
    [  186.684807][    C2] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [  186.684808][    C2] RIP: 0010:rollback_registered_many+0x986/0xcf0
    [  186.684811][    C2] Code: 41 8b 4e cc 45 31 c0 31 d2 4c 89 ee 48 89 df e8 e0 47 ff ff 85 c0 0f 84 cd fc ff ff 5
    [  186.684812][    C2] RSP: 0018:ffff8880cd9472e0 EFLAGS: 00010287
    [  186.684815][    C2] RAX: ffff8880cc56da58 RBX: ffff8880ab21c000 RCX: ffffffff9329d323
    [  186.684816][    C2] RDX: 1ffffffff2be6410 RSI: 0000000000000008 RDI: ffffffff95f32080
    [  186.684818][    C2] RBP: dffffc0000000000 R08: fffffbfff2be6411 R09: fffffbfff2be6411
    [  186.684819][    C2] R10: ffffffff95f32087 R11: 0000000000000001 R12: ffff8880cd947480
    [  186.684820][    C2] R13: ffff8880ab21c0b8 R14: ffff8880cd947400 R15: ffff8880cdf10640
    [  186.684822][    C2] FS:  00007f00843890c0(0000) GS:ffff8880d4e00000(0000) knlGS:0000000000000000
    [  186.684823][    C2] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  186.684825][    C2] CR2: 000055b8ab1077b8 CR3: 00000000ab612006 CR4: 00000000000606e0
    [  186.684826][    C2] Call Trace:
    [  186.684827][    C2]  ? lockdep_hardirqs_on_prepare+0x379/0x540
    [  186.684829][    C2]  ? netif_set_real_num_tx_queues+0x780/0x780
    [  186.684830][    C2]  ? rmnet_unregister_real_device+0x56/0x90 [rmnet]
    [  186.684831][    C2]  ? __kasan_slab_free+0x126/0x150
    [  186.684832][    C2]  ? kfree+0xdc/0x320
    [  186.684834][    C2]  ? rmnet_unregister_real_device+0x56/0x90 [rmnet]
    [  186.684835][    C2]  unregister_netdevice_many.part.135+0x13/0x1b0
    [  186.684836][    C2]  rtnl_delete_link+0xbc/0x100
    [ ... ]
    [  238.440071][ T1009] unregister_netdevice: waiting for rmnet0 to become free. Usage count = 1
    
    Fixes: 037f9cdf72fb ("net: rmnet: use upper/lower device infrastructure")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index 2c8c252b7b97..fcdecddb2812 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -429,6 +429,11 @@ int rmnet_add_bridge(struct net_device *rmnet_dev,
 		return -EINVAL;
 	}
 
+	if (port->rmnet_mode != RMNET_EPMODE_VND) {
+		NL_SET_ERR_MSG_MOD(extack, "more than one bridge dev attached");
+		return -EINVAL;
+	}
+
 	if (rmnet_is_real_dev_registered(slave_dev)) {
 		NL_SET_ERR_MSG_MOD(extack,
 				   "slave cannot be another rmnet dev");

commit 2a762e9e8cd1cf1242e4269a2244666ed02eecd1
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Thu Jul 2 17:08:18 2020 +0000

    net: rmnet: fix lower interface leak
    
    There are two types of the lower interface of rmnet that are VND
    and BRIDGE.
    Each lower interface can have only one type either VND or BRIDGE.
    But, there is a case, which uses both lower interface types.
    Due to this unexpected behavior, lower interface leak occurs.
    
    Test commands:
        ip link add dummy0 type dummy
        ip link add dummy1 type dummy
        ip link add rmnet0 link dummy0 type rmnet mux_id 1
        ip link set dummy1 master rmnet0
        ip link add rmnet1 link dummy1 type rmnet mux_id 2
        ip link del rmnet0
    
    The dummy1 was attached as BRIDGE interface of rmnet0.
    Then, it also was attached as VND interface of rmnet1.
    This is unexpected behavior and there is no code for handling this case.
    So that below splat occurs when the rmnet0 interface is deleted.
    
    Splat looks like:
    [   53.254112][    C1] WARNING: CPU: 1 PID: 1192 at net/core/dev.c:8992 rollback_registered_many+0x986/0xcf0
    [   53.254117][    C1] Modules linked in: rmnet dummy openvswitch nsh nf_conncount nf_nat nf_conntrack nf_defrag_ipv6 nfx
    [   53.254182][    C1] CPU: 1 PID: 1192 Comm: ip Not tainted 5.8.0-rc1+ #620
    [   53.254188][    C1] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [   53.254192][    C1] RIP: 0010:rollback_registered_many+0x986/0xcf0
    [   53.254200][    C1] Code: 41 8b 4e cc 45 31 c0 31 d2 4c 89 ee 48 89 df e8 e0 47 ff ff 85 c0 0f 84 cd fc ff ff 0f 0b e5
    [   53.254205][    C1] RSP: 0018:ffff888050a5f2e0 EFLAGS: 00010287
    [   53.254214][    C1] RAX: ffff88805756d658 RBX: ffff88804d99c000 RCX: ffffffff8329d323
    [   53.254219][    C1] RDX: 1ffffffff0be6410 RSI: 0000000000000008 RDI: ffffffff85f32080
    [   53.254223][    C1] RBP: dffffc0000000000 R08: fffffbfff0be6411 R09: fffffbfff0be6411
    [   53.254228][    C1] R10: ffffffff85f32087 R11: 0000000000000001 R12: ffff888050a5f480
    [   53.254233][    C1] R13: ffff88804d99c0b8 R14: ffff888050a5f400 R15: ffff8880548ebe40
    [   53.254238][    C1] FS:  00007f6b86b370c0(0000) GS:ffff88806c200000(0000) knlGS:0000000000000000
    [   53.254243][    C1] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   53.254248][    C1] CR2: 0000562c62438758 CR3: 000000003f600005 CR4: 00000000000606e0
    [   53.254253][    C1] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [   53.254257][    C1] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    [   53.254261][    C1] Call Trace:
    [   53.254266][    C1]  ? lockdep_hardirqs_on_prepare+0x379/0x540
    [   53.254270][    C1]  ? netif_set_real_num_tx_queues+0x780/0x780
    [   53.254275][    C1]  ? rmnet_unregister_real_device+0x56/0x90 [rmnet]
    [   53.254279][    C1]  ? __kasan_slab_free+0x126/0x150
    [   53.254283][    C1]  ? kfree+0xdc/0x320
    [   53.254288][    C1]  ? rmnet_unregister_real_device+0x56/0x90 [rmnet]
    [   53.254293][    C1]  unregister_netdevice_many.part.135+0x13/0x1b0
    [   53.254297][    C1]  rtnl_delete_link+0xbc/0x100
    [   53.254301][    C1]  ? rtnl_af_register+0xc0/0xc0
    [   53.254305][    C1]  rtnl_dellink+0x2dc/0x840
    [   53.254309][    C1]  ? find_held_lock+0x39/0x1d0
    [   53.254314][    C1]  ? valid_fdb_dump_strict+0x620/0x620
    [   53.254318][    C1]  ? rtnetlink_rcv_msg+0x457/0x890
    [   53.254322][    C1]  ? lock_contended+0xd20/0xd20
    [   53.254326][    C1]  rtnetlink_rcv_msg+0x4a8/0x890
    [ ... ]
    [   73.813696][ T1192] unregister_netdevice: waiting for rmnet0 to become free. Usage count = 1
    
    Fixes: 037f9cdf72fb ("net: rmnet: use upper/lower device infrastructure")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index 40efe60eff8d..2c8c252b7b97 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -47,15 +47,23 @@ static int rmnet_unregister_real_device(struct net_device *real_dev)
 	return 0;
 }
 
-static int rmnet_register_real_device(struct net_device *real_dev)
+static int rmnet_register_real_device(struct net_device *real_dev,
+				      struct netlink_ext_ack *extack)
 {
 	struct rmnet_port *port;
 	int rc, entry;
 
 	ASSERT_RTNL();
 
-	if (rmnet_is_real_dev_registered(real_dev))
+	if (rmnet_is_real_dev_registered(real_dev)) {
+		port = rmnet_get_port_rtnl(real_dev);
+		if (port->rmnet_mode != RMNET_EPMODE_VND) {
+			NL_SET_ERR_MSG_MOD(extack, "bridge device already exists");
+			return -EINVAL;
+		}
+
 		return 0;
+	}
 
 	port = kzalloc(sizeof(*port), GFP_KERNEL);
 	if (!port)
@@ -133,7 +141,7 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 
 	mux_id = nla_get_u16(data[IFLA_RMNET_MUX_ID]);
 
-	err = rmnet_register_real_device(real_dev);
+	err = rmnet_register_real_device(real_dev, extack);
 	if (err)
 		goto err0;
 
@@ -421,11 +429,6 @@ int rmnet_add_bridge(struct net_device *rmnet_dev,
 		return -EINVAL;
 	}
 
-	if (port->rmnet_mode != RMNET_EPMODE_VND) {
-		NL_SET_ERR_MSG_MOD(extack, "bridge device already exists");
-		return -EINVAL;
-	}
-
 	if (rmnet_is_real_dev_registered(slave_dev)) {
 		NL_SET_ERR_MSG_MOD(extack,
 				   "slave cannot be another rmnet dev");
@@ -433,7 +436,7 @@ int rmnet_add_bridge(struct net_device *rmnet_dev,
 		return -EBUSY;
 	}
 
-	err = rmnet_register_real_device(slave_dev);
+	err = rmnet_register_real_device(slave_dev, extack);
 	if (err)
 		return -EBUSY;
 

commit 2abb5792387eb188b12051337d5dcd2cba615cb0
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Wed Apr 1 15:23:55 2020 -0600

    net: qualcomm: rmnet: Allow configuration updates to existing devices
    
    This allows the changelink operation to succeed if the mux_id was
    specified as an argument. Note that the mux_id must match the
    existing mux_id of the rmnet device or should be an unused mux_id.
    
    Fixes: 1dc49e9d164c ("net: rmnet: do not allow to change mux id if mux id is duplicated")
    Reported-and-tested-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Sean Tranchetti <stranche@codeaurora.org>
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index 1305522f72d6..40efe60eff8d 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -282,7 +282,6 @@ static int rmnet_changelink(struct net_device *dev, struct nlattr *tb[],
 {
 	struct rmnet_priv *priv = netdev_priv(dev);
 	struct net_device *real_dev;
-	struct rmnet_endpoint *ep;
 	struct rmnet_port *port;
 	u16 mux_id;
 
@@ -297,19 +296,27 @@ static int rmnet_changelink(struct net_device *dev, struct nlattr *tb[],
 
 	if (data[IFLA_RMNET_MUX_ID]) {
 		mux_id = nla_get_u16(data[IFLA_RMNET_MUX_ID]);
-		if (rmnet_get_endpoint(port, mux_id)) {
-			NL_SET_ERR_MSG_MOD(extack, "MUX ID already exists");
-			return -EINVAL;
-		}
-		ep = rmnet_get_endpoint(port, priv->mux_id);
-		if (!ep)
-			return -ENODEV;
 
-		hlist_del_init_rcu(&ep->hlnode);
-		hlist_add_head_rcu(&ep->hlnode, &port->muxed_ep[mux_id]);
+		if (mux_id != priv->mux_id) {
+			struct rmnet_endpoint *ep;
+
+			ep = rmnet_get_endpoint(port, priv->mux_id);
+			if (!ep)
+				return -ENODEV;
 
-		ep->mux_id = mux_id;
-		priv->mux_id = mux_id;
+			if (rmnet_get_endpoint(port, mux_id)) {
+				NL_SET_ERR_MSG_MOD(extack,
+						   "MUX ID already exists");
+				return -EINVAL;
+			}
+
+			hlist_del_init_rcu(&ep->hlnode);
+			hlist_add_head_rcu(&ep->hlnode,
+					   &port->muxed_ep[mux_id]);
+
+			ep->mux_id = mux_id;
+			priv->mux_id = mux_id;
+		}
 	}
 
 	if (data[IFLA_RMNET_FLAGS]) {

commit 9c9cc918152e5775a60442171ef32235f17e1d72
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Wed Mar 4 23:25:43 2020 +0000

    net: rmnet: use GFP_KERNEL instead of GFP_ATOMIC
    
    In the current code, rmnet_register_real_device() and rmnet_newlink()
    are using GFP_ATOMIC.
    But, these functions are allowed to sleep.
    So, GFP_KERNEL can be used.
    
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index 63d0c2017ee5..1305522f72d6 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -57,7 +57,7 @@ static int rmnet_register_real_device(struct net_device *real_dev)
 	if (rmnet_is_real_dev_registered(real_dev))
 		return 0;
 
-	port = kzalloc(sizeof(*port), GFP_ATOMIC);
+	port = kzalloc(sizeof(*port), GFP_KERNEL);
 	if (!port)
 		return -ENOMEM;
 
@@ -127,7 +127,7 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 		return -ENODEV;
 	}
 
-	ep = kzalloc(sizeof(*ep), GFP_ATOMIC);
+	ep = kzalloc(sizeof(*ep), GFP_KERNEL);
 	if (!ep)
 		return -ENOMEM;
 

commit fcf8f4eb81fb266f56505e821591070becc9eeb0
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Wed Mar 4 23:25:22 2020 +0000

    net: rmnet: print error message when command fails
    
    When rmnet netlink command fails, it doesn't print any error message.
    So, users couldn't know the exact reason.
    In order to tell the exact reason to the user, the extack error message
    is used in this patch.
    
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index d846a0ccea8f..63d0c2017ee5 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -122,11 +122,10 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 	}
 
 	real_dev = __dev_get_by_index(src_net, nla_get_u32(tb[IFLA_LINK]));
-	if (!real_dev || !dev)
+	if (!real_dev) {
+		NL_SET_ERR_MSG_MOD(extack, "link does not exist");
 		return -ENODEV;
-
-	if (!data[IFLA_RMNET_MUX_ID])
-		return -EINVAL;
+	}
 
 	ep = kzalloc(sizeof(*ep), GFP_ATOMIC);
 	if (!ep)
@@ -139,7 +138,7 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 		goto err0;
 
 	port = rmnet_get_port_rtnl(real_dev);
-	err = rmnet_vnd_newlink(mux_id, dev, port, real_dev, ep);
+	err = rmnet_vnd_newlink(mux_id, dev, port, real_dev, ep, extack);
 	if (err)
 		goto err1;
 
@@ -263,12 +262,16 @@ static int rmnet_rtnl_validate(struct nlattr *tb[], struct nlattr *data[],
 {
 	u16 mux_id;
 
-	if (!data || !data[IFLA_RMNET_MUX_ID])
+	if (!data || !data[IFLA_RMNET_MUX_ID]) {
+		NL_SET_ERR_MSG_MOD(extack, "MUX ID not specified");
 		return -EINVAL;
+	}
 
 	mux_id = nla_get_u16(data[IFLA_RMNET_MUX_ID]);
-	if (mux_id > (RMNET_MAX_LOGICAL_EP - 1))
+	if (mux_id > (RMNET_MAX_LOGICAL_EP - 1)) {
+		NL_SET_ERR_MSG_MOD(extack, "invalid MUX ID");
 		return -ERANGE;
+	}
 
 	return 0;
 }
@@ -406,14 +409,22 @@ int rmnet_add_bridge(struct net_device *rmnet_dev,
 	/* If there is more than one rmnet dev attached, its probably being
 	 * used for muxing. Skip the briding in that case
 	 */
-	if (port->nr_rmnet_devs > 1)
+	if (port->nr_rmnet_devs > 1) {
+		NL_SET_ERR_MSG_MOD(extack, "more than one rmnet dev attached");
 		return -EINVAL;
+	}
 
-	if (port->rmnet_mode != RMNET_EPMODE_VND)
+	if (port->rmnet_mode != RMNET_EPMODE_VND) {
+		NL_SET_ERR_MSG_MOD(extack, "bridge device already exists");
 		return -EINVAL;
+	}
+
+	if (rmnet_is_real_dev_registered(slave_dev)) {
+		NL_SET_ERR_MSG_MOD(extack,
+				   "slave cannot be another rmnet dev");
 
-	if (rmnet_is_real_dev_registered(slave_dev))
 		return -EBUSY;
+	}
 
 	err = rmnet_register_real_device(slave_dev);
 	if (err)

commit eed22a0685d651fc531bc63f215bb2a71d4b98e5
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Wed Mar 4 23:24:42 2020 +0000

    net: rmnet: add missing module alias
    
    In the current rmnet code, there is no module alias.
    So, RTNL couldn't load rmnet module automatically.
    
    Test commands:
        ip link add dummy0 type dummy
        modprobe -rv rmnet
        ip link add rmnet0 link dummy0 type rmnet  mux_id 1
    
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index fbf4cbcf1a65..d846a0ccea8f 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -475,4 +475,5 @@ static void __exit rmnet_exit(void)
 
 module_init(rmnet_init)
 module_exit(rmnet_exit)
+MODULE_ALIAS_RTNL_LINK("rmnet");
 MODULE_LICENSE("GPL v2");

commit d939b6d30bea1a2322bc536b12be0a7c4c2bccd7
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Thu Feb 27 12:26:02 2020 +0000

    net: rmnet: fix bridge mode bugs
    
    In order to attach a bridge interface to the rmnet interface,
    "master" operation is used.
    (e.g. ip link set dummy1 master rmnet0)
    But, in the rmnet_add_bridge(), which is a callback of ->ndo_add_slave()
    doesn't register lower interface.
    So, ->ndo_del_slave() doesn't work.
    There are other problems too.
    1. It couldn't detect circular upper/lower interface relationship.
    2. It couldn't prevent stack overflow because of too deep depth
    of upper/lower interface
    3. It doesn't check the number of lower interfaces.
    4. Panics because of several reasons.
    
    The root problem of these issues is actually the same.
    So, in this patch, these all problems will be fixed.
    
    Test commands:
        modprobe rmnet
        ip link add dummy0 type dummy
        ip link add rmnet0 link dummy0 type rmnet mux_id 1
        ip link add dummy1 master rmnet0 type dummy
        ip link add dummy2 master rmnet0 type dummy
        ip link del rmnet0
        ip link del dummy2
        ip link del dummy1
    
    Splat looks like:
    [   41.867595][ T1164] general protection fault, probably for non-canonical address 0xdffffc0000000101I
    [   41.869993][ T1164] KASAN: null-ptr-deref in range [0x0000000000000808-0x000000000000080f]
    [   41.872950][ T1164] CPU: 0 PID: 1164 Comm: ip Not tainted 5.6.0-rc1+ #447
    [   41.873915][ T1164] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [   41.875161][ T1164] RIP: 0010:rmnet_unregister_bridge.isra.6+0x71/0xf0 [rmnet]
    [   41.876178][ T1164] Code: 48 89 ef 48 89 c6 5b 5d e9 fc fe ff ff e8 f7 f3 ff ff 48 8d b8 08 08 00 00 48 ba 00 7
    [   41.878925][ T1164] RSP: 0018:ffff8880c4d0f188 EFLAGS: 00010202
    [   41.879774][ T1164] RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000101
    [   41.887689][ T1164] RDX: dffffc0000000000 RSI: ffffffffb8cf64f0 RDI: 0000000000000808
    [   41.888727][ T1164] RBP: ffff8880c40e4000 R08: ffffed101b3c0e3c R09: 0000000000000001
    [   41.889749][ T1164] R10: 0000000000000001 R11: ffffed101b3c0e3b R12: 1ffff110189a1e3c
    [   41.890783][ T1164] R13: ffff8880c4d0f200 R14: ffffffffb8d56160 R15: ffff8880ccc2c000
    [   41.891794][ T1164] FS:  00007f4300edc0c0(0000) GS:ffff8880d9c00000(0000) knlGS:0000000000000000
    [   41.892953][ T1164] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   41.893800][ T1164] CR2: 00007f43003bc8c0 CR3: 00000000ca53e001 CR4: 00000000000606f0
    [   41.894824][ T1164] Call Trace:
    [   41.895274][ T1164]  ? rcu_is_watching+0x2c/0x80
    [   41.895895][ T1164]  rmnet_config_notify_cb+0x1f7/0x590 [rmnet]
    [   41.896687][ T1164]  ? rmnet_unregister_bridge.isra.6+0xf0/0xf0 [rmnet]
    [   41.897611][ T1164]  ? rmnet_unregister_bridge.isra.6+0xf0/0xf0 [rmnet]
    [   41.898508][ T1164]  ? __module_text_address+0x13/0x140
    [   41.899162][ T1164]  notifier_call_chain+0x90/0x160
    [   41.899814][ T1164]  rollback_registered_many+0x660/0xcf0
    [   41.900544][ T1164]  ? netif_set_real_num_tx_queues+0x780/0x780
    [   41.901316][ T1164]  ? __lock_acquire+0xdfe/0x3de0
    [   41.901958][ T1164]  ? memset+0x1f/0x40
    [   41.902468][ T1164]  ? __nla_validate_parse+0x98/0x1ab0
    [   41.903166][ T1164]  unregister_netdevice_many.part.133+0x13/0x1b0
    [   41.903988][ T1164]  rtnl_delete_link+0xbc/0x100
    [ ... ]
    
    Fixes: 60d58f971c10 ("net: qualcomm: rmnet: Implement bridge mode")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index e3fbf2331b96..fbf4cbcf1a65 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -13,25 +13,6 @@
 #include "rmnet_vnd.h"
 #include "rmnet_private.h"
 
-/* Locking scheme -
- * The shared resource which needs to be protected is realdev->rx_handler_data.
- * For the writer path, this is using rtnl_lock(). The writer paths are
- * rmnet_newlink(), rmnet_dellink() and rmnet_force_unassociate_device(). These
- * paths are already called with rtnl_lock() acquired in. There is also an
- * ASSERT_RTNL() to ensure that we are calling with rtnl acquired. For
- * dereference here, we will need to use rtnl_dereference(). Dev list writing
- * needs to happen with rtnl_lock() acquired for netdev_master_upper_dev_link().
- * For the reader path, the real_dev->rx_handler_data is called in the TX / RX
- * path. We only need rcu_read_lock() for these scenarios. In these cases,
- * the rcu_read_lock() is held in __dev_queue_xmit() and
- * netif_receive_skb_internal(), so readers need to use rcu_dereference_rtnl()
- * to get the relevant information. For dev list reading, we again acquire
- * rcu_read_lock() in rmnet_dellink() for netdev_master_upper_dev_get_rcu().
- * We also use unregister_netdevice_many() to free all rmnet devices in
- * rmnet_force_unassociate_device() so we dont lose the rtnl_lock() and free in
- * same context.
- */
-
 /* Local Definitions and Declarations */
 
 static const struct nla_policy rmnet_policy[IFLA_RMNET_MAX + 1] = {
@@ -51,9 +32,10 @@ rmnet_get_port_rtnl(const struct net_device *real_dev)
 	return rtnl_dereference(real_dev->rx_handler_data);
 }
 
-static int rmnet_unregister_real_device(struct net_device *real_dev,
-					struct rmnet_port *port)
+static int rmnet_unregister_real_device(struct net_device *real_dev)
 {
+	struct rmnet_port *port = rmnet_get_port_rtnl(real_dev);
+
 	if (port->nr_rmnet_devs)
 		return -EINVAL;
 
@@ -93,28 +75,33 @@ static int rmnet_register_real_device(struct net_device *real_dev)
 	return 0;
 }
 
-static void rmnet_unregister_bridge(struct net_device *dev,
-				    struct rmnet_port *port)
+static void rmnet_unregister_bridge(struct rmnet_port *port)
 {
-	struct rmnet_port *bridge_port;
-	struct net_device *bridge_dev;
+	struct net_device *bridge_dev, *real_dev, *rmnet_dev;
+	struct rmnet_port *real_port;
 
 	if (port->rmnet_mode != RMNET_EPMODE_BRIDGE)
 		return;
 
-	/* bridge slave handling */
+	rmnet_dev = port->rmnet_dev;
 	if (!port->nr_rmnet_devs) {
-		bridge_dev = port->bridge_ep;
+		/* bridge device */
+		real_dev = port->bridge_ep;
+		bridge_dev = port->dev;
 
-		bridge_port = rmnet_get_port_rtnl(bridge_dev);
-		bridge_port->bridge_ep = NULL;
-		bridge_port->rmnet_mode = RMNET_EPMODE_VND;
+		real_port = rmnet_get_port_rtnl(real_dev);
+		real_port->bridge_ep = NULL;
+		real_port->rmnet_mode = RMNET_EPMODE_VND;
 	} else {
+		/* real device */
 		bridge_dev = port->bridge_ep;
 
-		bridge_port = rmnet_get_port_rtnl(bridge_dev);
-		rmnet_unregister_real_device(bridge_dev, bridge_port);
+		port->bridge_ep = NULL;
+		port->rmnet_mode = RMNET_EPMODE_VND;
 	}
+
+	netdev_upper_dev_unlink(bridge_dev, rmnet_dev);
+	rmnet_unregister_real_device(bridge_dev);
 }
 
 static int rmnet_newlink(struct net *src_net, struct net_device *dev,
@@ -161,6 +148,7 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 		goto err2;
 
 	port->rmnet_mode = mode;
+	port->rmnet_dev = dev;
 
 	hlist_add_head_rcu(&ep->hlnode, &port->muxed_ep[mux_id]);
 
@@ -178,8 +166,9 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 
 err2:
 	unregister_netdevice(dev);
+	rmnet_vnd_dellink(mux_id, port, ep);
 err1:
-	rmnet_unregister_real_device(real_dev, port);
+	rmnet_unregister_real_device(real_dev);
 err0:
 	kfree(ep);
 	return err;
@@ -188,30 +177,32 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 static void rmnet_dellink(struct net_device *dev, struct list_head *head)
 {
 	struct rmnet_priv *priv = netdev_priv(dev);
-	struct net_device *real_dev;
+	struct net_device *real_dev, *bridge_dev;
+	struct rmnet_port *real_port, *bridge_port;
 	struct rmnet_endpoint *ep;
-	struct rmnet_port *port;
-	u8 mux_id;
+	u8 mux_id = priv->mux_id;
 
 	real_dev = priv->real_dev;
 
-	if (!real_dev || !rmnet_is_real_dev_registered(real_dev))
+	if (!rmnet_is_real_dev_registered(real_dev))
 		return;
 
-	port = rmnet_get_port_rtnl(real_dev);
-
-	mux_id = rmnet_vnd_get_mux(dev);
+	real_port = rmnet_get_port_rtnl(real_dev);
+	bridge_dev = real_port->bridge_ep;
+	if (bridge_dev) {
+		bridge_port = rmnet_get_port_rtnl(bridge_dev);
+		rmnet_unregister_bridge(bridge_port);
+	}
 
-	ep = rmnet_get_endpoint(port, mux_id);
+	ep = rmnet_get_endpoint(real_port, mux_id);
 	if (ep) {
 		hlist_del_init_rcu(&ep->hlnode);
-		rmnet_unregister_bridge(dev, port);
-		rmnet_vnd_dellink(mux_id, port, ep);
+		rmnet_vnd_dellink(mux_id, real_port, ep);
 		kfree(ep);
 	}
-	netdev_upper_dev_unlink(real_dev, dev);
-	rmnet_unregister_real_device(real_dev, port);
 
+	netdev_upper_dev_unlink(real_dev, dev);
+	rmnet_unregister_real_device(real_dev);
 	unregister_netdevice_queue(dev, head);
 }
 
@@ -223,23 +214,23 @@ static void rmnet_force_unassociate_device(struct net_device *real_dev)
 	unsigned long bkt_ep;
 	LIST_HEAD(list);
 
-	ASSERT_RTNL();
-
 	port = rmnet_get_port_rtnl(real_dev);
 
-	rmnet_unregister_bridge(real_dev, port);
-
-	hash_for_each_safe(port->muxed_ep, bkt_ep, tmp_ep, ep, hlnode) {
-		netdev_upper_dev_unlink(real_dev, ep->egress_dev);
-		unregister_netdevice_queue(ep->egress_dev, &list);
-		rmnet_vnd_dellink(ep->mux_id, port, ep);
-		hlist_del_init_rcu(&ep->hlnode);
-		kfree(ep);
+	if (port->nr_rmnet_devs) {
+		/* real device */
+		rmnet_unregister_bridge(port);
+		hash_for_each_safe(port->muxed_ep, bkt_ep, tmp_ep, ep, hlnode) {
+			unregister_netdevice_queue(ep->egress_dev, &list);
+			netdev_upper_dev_unlink(real_dev, ep->egress_dev);
+			rmnet_vnd_dellink(ep->mux_id, port, ep);
+			hlist_del_init_rcu(&ep->hlnode);
+			kfree(ep);
+		}
+		rmnet_unregister_real_device(real_dev);
+		unregister_netdevice_many(&list);
+	} else {
+		rmnet_unregister_bridge(port);
 	}
-
-	unregister_netdevice_many(&list);
-
-	rmnet_unregister_real_device(real_dev, port);
 }
 
 static int rmnet_config_notify_cb(struct notifier_block *nb,
@@ -418,6 +409,9 @@ int rmnet_add_bridge(struct net_device *rmnet_dev,
 	if (port->nr_rmnet_devs > 1)
 		return -EINVAL;
 
+	if (port->rmnet_mode != RMNET_EPMODE_VND)
+		return -EINVAL;
+
 	if (rmnet_is_real_dev_registered(slave_dev))
 		return -EBUSY;
 
@@ -425,9 +419,17 @@ int rmnet_add_bridge(struct net_device *rmnet_dev,
 	if (err)
 		return -EBUSY;
 
+	err = netdev_master_upper_dev_link(slave_dev, rmnet_dev, NULL, NULL,
+					   extack);
+	if (err) {
+		rmnet_unregister_real_device(slave_dev);
+		return err;
+	}
+
 	slave_port = rmnet_get_port_rtnl(slave_dev);
 	slave_port->rmnet_mode = RMNET_EPMODE_BRIDGE;
 	slave_port->bridge_ep = real_dev;
+	slave_port->rmnet_dev = rmnet_dev;
 
 	port->rmnet_mode = RMNET_EPMODE_BRIDGE;
 	port->bridge_ep = slave_dev;
@@ -439,16 +441,9 @@ int rmnet_add_bridge(struct net_device *rmnet_dev,
 int rmnet_del_bridge(struct net_device *rmnet_dev,
 		     struct net_device *slave_dev)
 {
-	struct rmnet_priv *priv = netdev_priv(rmnet_dev);
-	struct net_device *real_dev = priv->real_dev;
-	struct rmnet_port *port, *slave_port;
-
-	port = rmnet_get_port_rtnl(real_dev);
-	port->rmnet_mode = RMNET_EPMODE_VND;
-	port->bridge_ep = NULL;
+	struct rmnet_port *port = rmnet_get_port_rtnl(slave_dev);
 
-	slave_port = rmnet_get_port_rtnl(slave_dev);
-	rmnet_unregister_real_device(slave_dev, slave_port);
+	rmnet_unregister_bridge(port);
 
 	netdev_dbg(slave_dev, "removed from rmnet as slave\n");
 	return 0;

commit 037f9cdf72fb8a7ff9ec2b5dd05336ec1492bdf1
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Thu Feb 27 12:25:43 2020 +0000

    net: rmnet: use upper/lower device infrastructure
    
    netdev_upper_dev_link() is useful to manage lower/upper interfaces.
    And this function internally validates looping, maximum depth.
    All or most virtual interfaces that could have a real interface
    (e.g. macsec, macvlan, ipvlan etc.) use lower/upper infrastructure.
    
    Test commands:
        modprobe rmnet
        ip link add dummy0 type dummy
        ip link add rmnet1 link dummy0 type rmnet mux_id 1
        for i in {2..100}
        do
            let A=$i-1
            ip link add rmnet$i link rmnet$A type rmnet mux_id $i
        done
        ip link del dummy0
    
    The purpose of the test commands is to make stack overflow.
    
    Splat looks like:
    [   52.411438][ T1395] BUG: KASAN: slab-out-of-bounds in find_busiest_group+0x27e/0x2c00
    [   52.413218][ T1395] Write of size 64 at addr ffff8880c774bde0 by task ip/1395
    [   52.414841][ T1395]
    [   52.430720][ T1395] CPU: 1 PID: 1395 Comm: ip Not tainted 5.6.0-rc1+ #447
    [   52.496511][ T1395] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [   52.513597][ T1395] Call Trace:
    [   52.546516][ T1395]
    [   52.558773][ T1395] Allocated by task 3171537984:
    [   52.588290][ T1395] BUG: unable to handle page fault for address: ffffffffb999e260
    [   52.589311][ T1395] #PF: supervisor read access in kernel mode
    [   52.590529][ T1395] #PF: error_code(0x0000) - not-present page
    [   52.591374][ T1395] PGD d6818067 P4D d6818067 PUD d6819063 PMD 0
    [   52.592288][ T1395] Thread overran stack, or stack corrupted
    [   52.604980][ T1395] Oops: 0000 [#1] SMP DEBUG_PAGEALLOC KASAN PTI
    [   52.605856][ T1395] CPU: 1 PID: 1395 Comm: ip Not tainted 5.6.0-rc1+ #447
    [   52.611764][ T1395] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [   52.621520][ T1395] RIP: 0010:stack_depot_fetch+0x10/0x30
    [   52.622296][ T1395] Code: ff e9 f9 fe ff ff 48 89 df e8 9c 1d 91 ff e9 ca fe ff ff cc cc cc cc cc cc cc 89 f8 0
    [   52.627887][ T1395] RSP: 0018:ffff8880c774bb60 EFLAGS: 00010006
    [   52.628735][ T1395] RAX: 00000000001f8880 RBX: ffff8880c774d140 RCX: 0000000000000000
    [   52.631773][ T1395] RDX: 000000000000001d RSI: ffff8880c774bb68 RDI: 0000000000003ff0
    [   52.649584][ T1395] RBP: ffffea00031dd200 R08: ffffed101b43e403 R09: ffffed101b43e403
    [   52.674857][ T1395] R10: 0000000000000001 R11: ffffed101b43e402 R12: ffff8880d900e5c0
    [   52.678257][ T1395] R13: ffff8880c774c000 R14: 0000000000000000 R15: dffffc0000000000
    [   52.694541][ T1395] FS:  00007fe867f6e0c0(0000) GS:ffff8880da000000(0000) knlGS:0000000000000000
    [   52.764039][ T1395] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   52.815008][ T1395] CR2: ffffffffb999e260 CR3: 00000000c26aa005 CR4: 00000000000606e0
    [   52.862312][ T1395] Call Trace:
    [   52.887133][ T1395] Modules linked in: dummy rmnet veth openvswitch nsh nf_conncount nf_nat nf_conntrack nf_dex
    [   52.936749][ T1395] CR2: ffffffffb999e260
    [   52.965695][ T1395] ---[ end trace 7e32ca99482dbb31 ]---
    [   52.966556][ T1395] RIP: 0010:stack_depot_fetch+0x10/0x30
    [   52.971083][ T1395] Code: ff e9 f9 fe ff ff 48 89 df e8 9c 1d 91 ff e9 ca fe ff ff cc cc cc cc cc cc cc 89 f8 0
    [   53.003650][ T1395] RSP: 0018:ffff8880c774bb60 EFLAGS: 00010006
    [   53.043183][ T1395] RAX: 00000000001f8880 RBX: ffff8880c774d140 RCX: 0000000000000000
    [   53.076480][ T1395] RDX: 000000000000001d RSI: ffff8880c774bb68 RDI: 0000000000003ff0
    [   53.093858][ T1395] RBP: ffffea00031dd200 R08: ffffed101b43e403 R09: ffffed101b43e403
    [   53.112795][ T1395] R10: 0000000000000001 R11: ffffed101b43e402 R12: ffff8880d900e5c0
    [   53.139837][ T1395] R13: ffff8880c774c000 R14: 0000000000000000 R15: dffffc0000000000
    [   53.141500][ T1395] FS:  00007fe867f6e0c0(0000) GS:ffff8880da000000(0000) knlGS:0000000000000000
    [   53.143343][ T1395] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   53.152007][ T1395] CR2: ffffffffb999e260 CR3: 00000000c26aa005 CR4: 00000000000606e0
    [   53.156459][ T1395] Kernel panic - not syncing: Fatal exception
    [   54.213570][ T1395] Shutting down cpus with NMI
    [   54.354112][ T1395] Kernel Offset: 0x33000000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0x)
    [   54.355687][ T1395] Rebooting in 5 seconds..
    
    Fixes: b37f78f234bf ("net: qualcomm: rmnet: Fix crash on real dev unregistration")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index 3c0e6d24d083..e3fbf2331b96 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -61,9 +61,6 @@ static int rmnet_unregister_real_device(struct net_device *real_dev,
 
 	kfree(port);
 
-	/* release reference on real_dev */
-	dev_put(real_dev);
-
 	netdev_dbg(real_dev, "Removed from rmnet\n");
 	return 0;
 }
@@ -89,9 +86,6 @@ static int rmnet_register_real_device(struct net_device *real_dev)
 		return -EBUSY;
 	}
 
-	/* hold on to real dev for MAP data */
-	dev_hold(real_dev);
-
 	for (entry = 0; entry < RMNET_MAX_LOGICAL_EP; entry++)
 		INIT_HLIST_HEAD(&port->muxed_ep[entry]);
 
@@ -162,6 +156,10 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 	if (err)
 		goto err1;
 
+	err = netdev_upper_dev_link(real_dev, dev, extack);
+	if (err < 0)
+		goto err2;
+
 	port->rmnet_mode = mode;
 
 	hlist_add_head_rcu(&ep->hlnode, &port->muxed_ep[mux_id]);
@@ -178,6 +176,8 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 
 	return 0;
 
+err2:
+	unregister_netdevice(dev);
 err1:
 	rmnet_unregister_real_device(real_dev, port);
 err0:
@@ -209,33 +209,30 @@ static void rmnet_dellink(struct net_device *dev, struct list_head *head)
 		rmnet_vnd_dellink(mux_id, port, ep);
 		kfree(ep);
 	}
+	netdev_upper_dev_unlink(real_dev, dev);
 	rmnet_unregister_real_device(real_dev, port);
 
 	unregister_netdevice_queue(dev, head);
 }
 
-static void rmnet_force_unassociate_device(struct net_device *dev)
+static void rmnet_force_unassociate_device(struct net_device *real_dev)
 {
-	struct net_device *real_dev = dev;
 	struct hlist_node *tmp_ep;
 	struct rmnet_endpoint *ep;
 	struct rmnet_port *port;
 	unsigned long bkt_ep;
 	LIST_HEAD(list);
 
-	if (!rmnet_is_real_dev_registered(real_dev))
-		return;
-
 	ASSERT_RTNL();
 
-	port = rmnet_get_port_rtnl(dev);
+	port = rmnet_get_port_rtnl(real_dev);
 
-	rmnet_unregister_bridge(dev, port);
+	rmnet_unregister_bridge(real_dev, port);
 
 	hash_for_each_safe(port->muxed_ep, bkt_ep, tmp_ep, ep, hlnode) {
+		netdev_upper_dev_unlink(real_dev, ep->egress_dev);
 		unregister_netdevice_queue(ep->egress_dev, &list);
 		rmnet_vnd_dellink(ep->mux_id, port, ep);
-
 		hlist_del_init_rcu(&ep->hlnode);
 		kfree(ep);
 	}
@@ -248,15 +245,15 @@ static void rmnet_force_unassociate_device(struct net_device *dev)
 static int rmnet_config_notify_cb(struct notifier_block *nb,
 				  unsigned long event, void *data)
 {
-	struct net_device *dev = netdev_notifier_info_to_dev(data);
+	struct net_device *real_dev = netdev_notifier_info_to_dev(data);
 
-	if (!dev)
+	if (!rmnet_is_real_dev_registered(real_dev))
 		return NOTIFY_DONE;
 
 	switch (event) {
 	case NETDEV_UNREGISTER:
-		netdev_dbg(dev, "Kernel unregister\n");
-		rmnet_force_unassociate_device(dev);
+		netdev_dbg(real_dev, "Kernel unregister\n");
+		rmnet_force_unassociate_device(real_dev);
 		break;
 
 	default:
@@ -477,8 +474,8 @@ static int __init rmnet_init(void)
 
 static void __exit rmnet_exit(void)
 {
-	unregister_netdevice_notifier(&rmnet_dev_notifier);
 	rtnl_link_unregister(&rmnet_link_ops);
+	unregister_netdevice_notifier(&rmnet_dev_notifier);
 }
 
 module_init(rmnet_init)

commit 1dc49e9d164cd7e11c81279c83db84a147e14740
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Thu Feb 27 12:25:19 2020 +0000

    net: rmnet: do not allow to change mux id if mux id is duplicated
    
    Basically, duplicate mux id isn't be allowed.
    So, the creation of rmnet will be failed if there is duplicate mux id
    is existing.
    But, changelink routine doesn't check duplicate mux id.
    
    Test commands:
        modprobe rmnet
        ip link add dummy0 type dummy
        ip link add rmnet0 link dummy0 type rmnet mux_id 1
        ip link add rmnet1 link dummy0 type rmnet mux_id 2
        ip link set rmnet1 type rmnet mux_id 1
    
    Fixes: 23790ef12082 ("net: qualcomm: rmnet: Allow to configure flags for existing devices")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index 0ad64aa66592..3c0e6d24d083 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -306,6 +306,10 @@ static int rmnet_changelink(struct net_device *dev, struct nlattr *tb[],
 
 	if (data[IFLA_RMNET_MUX_ID]) {
 		mux_id = nla_get_u16(data[IFLA_RMNET_MUX_ID]);
+		if (rmnet_get_endpoint(port, mux_id)) {
+			NL_SET_ERR_MSG_MOD(extack, "MUX ID already exists");
+			return -EINVAL;
+		}
 		ep = rmnet_get_endpoint(port, priv->mux_id);
 		if (!ep)
 			return -ENODEV;

commit c026d970102e9af9958edefb4a015702c6aab636
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Thu Feb 27 12:25:05 2020 +0000

    net: rmnet: remove rcu_read_lock in rmnet_force_unassociate_device()
    
    The notifier_call() of the slave interface removes rmnet interface with
    unregister_netdevice_queue().
    But, before calling unregister_netdevice_queue(), it acquires
    rcu readlock.
    In the RCU critical section, sleeping isn't be allowed.
    But, unregister_netdevice_queue() internally calls synchronize_net(),
    which would sleep.
    So, suspicious RCU usage warning occurs.
    
    Test commands:
        modprobe rmnet
        ip link add dummy0 type dummy
        ip link add dummy1 type dummy
        ip link add rmnet0 link dummy0 type rmnet mux_id 1
        ip link set dummy1 master rmnet0
        ip link del dummy0
    
    Splat looks like:
    [   79.639245][ T1195] =============================
    [   79.640134][ T1195] WARNING: suspicious RCU usage
    [   79.640852][ T1195] 5.6.0-rc1+ #447 Not tainted
    [   79.641657][ T1195] -----------------------------
    [   79.642472][ T1195] ./include/linux/rcupdate.h:273 Illegal context switch in RCU read-side critical section!
    [   79.644043][ T1195]
    [   79.644043][ T1195] other info that might help us debug this:
    [   79.644043][ T1195]
    [   79.645682][ T1195]
    [   79.645682][ T1195] rcu_scheduler_active = 2, debug_locks = 1
    [   79.646980][ T1195] 2 locks held by ip/1195:
    [   79.647629][ T1195]  #0: ffffffffa3cf64f0 (rtnl_mutex){+.+.}, at: rtnetlink_rcv_msg+0x457/0x890
    [   79.649312][ T1195]  #1: ffffffffa39256c0 (rcu_read_lock){....}, at: rmnet_config_notify_cb+0xf0/0x590 [rmnet]
    [   79.651717][ T1195]
    [   79.651717][ T1195] stack backtrace:
    [   79.652650][ T1195] CPU: 3 PID: 1195 Comm: ip Not tainted 5.6.0-rc1+ #447
    [   79.653702][ T1195] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [   79.655037][ T1195] Call Trace:
    [   79.655560][ T1195]  dump_stack+0x96/0xdb
    [   79.656252][ T1195]  ___might_sleep+0x345/0x440
    [   79.656994][ T1195]  synchronize_net+0x18/0x30
    [   79.661132][ T1195]  netdev_rx_handler_unregister+0x40/0xb0
    [   79.666266][ T1195]  rmnet_unregister_real_device+0x42/0xb0 [rmnet]
    [   79.667211][ T1195]  rmnet_config_notify_cb+0x1f7/0x590 [rmnet]
    [   79.668121][ T1195]  ? rmnet_unregister_bridge.isra.6+0xf0/0xf0 [rmnet]
    [   79.669166][ T1195]  ? rmnet_unregister_bridge.isra.6+0xf0/0xf0 [rmnet]
    [   79.670286][ T1195]  ? __module_text_address+0x13/0x140
    [   79.671139][ T1195]  notifier_call_chain+0x90/0x160
    [   79.671973][ T1195]  rollback_registered_many+0x660/0xcf0
    [   79.672893][ T1195]  ? netif_set_real_num_tx_queues+0x780/0x780
    [   79.675091][ T1195]  ? __lock_acquire+0xdfe/0x3de0
    [   79.675825][ T1195]  ? memset+0x1f/0x40
    [   79.676367][ T1195]  ? __nla_validate_parse+0x98/0x1ab0
    [   79.677290][ T1195]  unregister_netdevice_many.part.133+0x13/0x1b0
    [   79.678163][ T1195]  rtnl_delete_link+0xbc/0x100
    [ ... ]
    
    Fixes: ceed73a2cf4a ("drivers: net: ethernet: qualcomm: rmnet: Initial implementation")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index fc68ecdd804b..0ad64aa66592 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -230,7 +230,6 @@ static void rmnet_force_unassociate_device(struct net_device *dev)
 
 	port = rmnet_get_port_rtnl(dev);
 
-	rcu_read_lock();
 	rmnet_unregister_bridge(dev, port);
 
 	hash_for_each_safe(port->muxed_ep, bkt_ep, tmp_ep, ep, hlnode) {
@@ -241,7 +240,6 @@ static void rmnet_force_unassociate_device(struct net_device *dev)
 		kfree(ep);
 	}
 
-	rcu_read_unlock();
 	unregister_netdevice_many(&list);
 
 	rmnet_unregister_real_device(real_dev, port);

commit 102210f7664442d8c0ce332c006ea90626df745b
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Thu Feb 27 12:24:45 2020 +0000

    net: rmnet: fix suspicious RCU usage
    
    rmnet_get_port() internally calls rcu_dereference_rtnl(),
    which checks RTNL.
    But rmnet_get_port() could be called by packet path.
    The packet path is not protected by RTNL.
    So, the suspicious RCU usage problem occurs.
    
    Test commands:
        modprobe rmnet
        ip netns add nst
        ip link add veth0 type veth peer name veth1
        ip link set veth1 netns nst
        ip link add rmnet0 link veth0 type rmnet mux_id 1
        ip netns exec nst ip link add rmnet1 link veth1 type rmnet mux_id 1
        ip netns exec nst ip link set veth1 up
        ip netns exec nst ip link set rmnet1 up
        ip netns exec nst ip a a 192.168.100.2/24 dev rmnet1
        ip link set veth0 up
        ip link set rmnet0 up
        ip a a 192.168.100.1/24 dev rmnet0
        ping 192.168.100.2
    
    Splat looks like:
    [  146.630958][ T1174] WARNING: suspicious RCU usage
    [  146.631735][ T1174] 5.6.0-rc1+ #447 Not tainted
    [  146.632387][ T1174] -----------------------------
    [  146.633151][ T1174] drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c:386 suspicious rcu_dereference_check() !
    [  146.634742][ T1174]
    [  146.634742][ T1174] other info that might help us debug this:
    [  146.634742][ T1174]
    [  146.645992][ T1174]
    [  146.645992][ T1174] rcu_scheduler_active = 2, debug_locks = 1
    [  146.646937][ T1174] 5 locks held by ping/1174:
    [  146.647609][ T1174]  #0: ffff8880c31dea70 (sk_lock-AF_INET){+.+.}, at: raw_sendmsg+0xab8/0x2980
    [  146.662463][ T1174]  #1: ffffffff93925660 (rcu_read_lock_bh){....}, at: ip_finish_output2+0x243/0x2150
    [  146.671696][ T1174]  #2: ffffffff93925660 (rcu_read_lock_bh){....}, at: __dev_queue_xmit+0x213/0x2940
    [  146.673064][ T1174]  #3: ffff8880c19ecd58 (&dev->qdisc_running_key#7){+...}, at: ip_finish_output2+0x714/0x2150
    [  146.690358][ T1174]  #4: ffff8880c5796898 (&dev->qdisc_xmit_lock_key#3){+.-.}, at: sch_direct_xmit+0x1e2/0x1020
    [  146.699875][ T1174]
    [  146.699875][ T1174] stack backtrace:
    [  146.701091][ T1174] CPU: 0 PID: 1174 Comm: ping Not tainted 5.6.0-rc1+ #447
    [  146.705215][ T1174] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [  146.706565][ T1174] Call Trace:
    [  146.707102][ T1174]  dump_stack+0x96/0xdb
    [  146.708007][ T1174]  rmnet_get_port.part.9+0x76/0x80 [rmnet]
    [  146.709233][ T1174]  rmnet_egress_handler+0x107/0x420 [rmnet]
    [  146.710492][ T1174]  ? sch_direct_xmit+0x1e2/0x1020
    [  146.716193][ T1174]  rmnet_vnd_start_xmit+0x3d/0xa0 [rmnet]
    [  146.717012][ T1174]  dev_hard_start_xmit+0x160/0x740
    [  146.717854][ T1174]  sch_direct_xmit+0x265/0x1020
    [  146.718577][ T1174]  ? register_lock_class+0x14d0/0x14d0
    [  146.719429][ T1174]  ? dev_watchdog+0xac0/0xac0
    [  146.723738][ T1174]  ? __dev_queue_xmit+0x15fd/0x2940
    [  146.724469][ T1174]  ? lock_acquire+0x164/0x3b0
    [  146.725172][ T1174]  __dev_queue_xmit+0x20c7/0x2940
    [ ... ]
    
    Fixes: ceed73a2cf4a ("drivers: net: ethernet: qualcomm: rmnet: Initial implementation")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index ac58f584190b..fc68ecdd804b 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -382,11 +382,10 @@ struct rtnl_link_ops rmnet_link_ops __read_mostly = {
 	.fill_info	= rmnet_fill_info,
 };
 
-/* Needs either rcu_read_lock() or rtnl lock */
-struct rmnet_port *rmnet_get_port(struct net_device *real_dev)
+struct rmnet_port *rmnet_get_port_rcu(struct net_device *real_dev)
 {
 	if (rmnet_is_real_dev_registered(real_dev))
-		return rcu_dereference_rtnl(real_dev->rx_handler_data);
+		return rcu_dereference_bh(real_dev->rx_handler_data);
 	else
 		return NULL;
 }
@@ -412,7 +411,7 @@ int rmnet_add_bridge(struct net_device *rmnet_dev,
 	struct rmnet_port *port, *slave_port;
 	int err;
 
-	port = rmnet_get_port(real_dev);
+	port = rmnet_get_port_rtnl(real_dev);
 
 	/* If there is more than one rmnet dev attached, its probably being
 	 * used for muxing. Skip the briding in that case
@@ -427,7 +426,7 @@ int rmnet_add_bridge(struct net_device *rmnet_dev,
 	if (err)
 		return -EBUSY;
 
-	slave_port = rmnet_get_port(slave_dev);
+	slave_port = rmnet_get_port_rtnl(slave_dev);
 	slave_port->rmnet_mode = RMNET_EPMODE_BRIDGE;
 	slave_port->bridge_ep = real_dev;
 
@@ -445,11 +444,11 @@ int rmnet_del_bridge(struct net_device *rmnet_dev,
 	struct net_device *real_dev = priv->real_dev;
 	struct rmnet_port *port, *slave_port;
 
-	port = rmnet_get_port(real_dev);
+	port = rmnet_get_port_rtnl(real_dev);
 	port->rmnet_mode = RMNET_EPMODE_VND;
 	port->bridge_ep = NULL;
 
-	slave_port = rmnet_get_port(slave_dev);
+	slave_port = rmnet_get_port_rtnl(slave_dev);
 	rmnet_unregister_real_device(slave_dev, slave_port);
 
 	netdev_dbg(slave_dev, "removed from rmnet as slave\n");

commit 1eb1f43a6e37282348a41e3d68f5e9a6a4359212
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Thu Feb 27 12:24:26 2020 +0000

    net: rmnet: fix NULL pointer dereference in rmnet_changelink()
    
    In the rmnet_changelink(), it uses IFLA_LINK without checking
    NULL pointer.
    tb[IFLA_LINK] could be NULL pointer.
    So, NULL-ptr-deref could occur.
    
    rmnet already has a lower interface (real_dev).
    So, after this patch, rmnet_changelink() does not use IFLA_LINK anymore.
    
    Test commands:
        modprobe rmnet
        ip link add dummy0 type dummy
        ip link add rmnet0 link dummy0 type rmnet mux_id 1
        ip link set rmnet0 type rmnet mux_id 2
    
    Splat looks like:
    [   90.578726][ T1131] general protection fault, probably for non-canonical address 0xdffffc0000000000I
    [   90.581121][ T1131] KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]
    [   90.582380][ T1131] CPU: 2 PID: 1131 Comm: ip Not tainted 5.6.0-rc1+ #447
    [   90.584285][ T1131] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [   90.587506][ T1131] RIP: 0010:rmnet_changelink+0x5a/0x8a0 [rmnet]
    [   90.588546][ T1131] Code: 83 ec 20 48 c1 ea 03 80 3c 02 00 0f 85 6f 07 00 00 48 8b 5e 28 48 b8 00 00 00 00 00 0
    [   90.591447][ T1131] RSP: 0018:ffff8880ce78f1b8 EFLAGS: 00010247
    [   90.592329][ T1131] RAX: dffffc0000000000 RBX: 0000000000000000 RCX: ffff8880ce78f8b0
    [   90.593253][ T1131] RDX: 0000000000000000 RSI: ffff8880ce78f4a0 RDI: 0000000000000004
    [   90.594058][ T1131] RBP: ffff8880cf543e00 R08: 0000000000000002 R09: 0000000000000002
    [   90.594859][ T1131] R10: ffffffffc0586a40 R11: 0000000000000000 R12: ffff8880ca47c000
    [   90.595690][ T1131] R13: ffff8880ca47c000 R14: ffff8880cf545000 R15: 0000000000000000
    [   90.596553][ T1131] FS:  00007f21f6c7e0c0(0000) GS:ffff8880da400000(0000) knlGS:0000000000000000
    [   90.597504][ T1131] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   90.599418][ T1131] CR2: 0000556e413db458 CR3: 00000000c917a002 CR4: 00000000000606e0
    [   90.600289][ T1131] Call Trace:
    [   90.600631][ T1131]  __rtnl_newlink+0x922/0x1270
    [   90.601194][ T1131]  ? lock_downgrade+0x6e0/0x6e0
    [   90.601724][ T1131]  ? rtnl_link_unregister+0x220/0x220
    [   90.602309][ T1131]  ? lock_acquire+0x164/0x3b0
    [   90.602784][ T1131]  ? is_bpf_image_address+0xff/0x1d0
    [   90.603331][ T1131]  ? rtnl_newlink+0x4c/0x90
    [   90.603810][ T1131]  ? kernel_text_address+0x111/0x140
    [   90.604419][ T1131]  ? __kernel_text_address+0xe/0x30
    [   90.604981][ T1131]  ? unwind_get_return_address+0x5f/0xa0
    [   90.605616][ T1131]  ? create_prof_cpu_mask+0x20/0x20
    [   90.606304][ T1131]  ? arch_stack_walk+0x83/0xb0
    [   90.606985][ T1131]  ? stack_trace_save+0x82/0xb0
    [   90.607656][ T1131]  ? stack_trace_consume_entry+0x160/0x160
    [   90.608503][ T1131]  ? deactivate_slab.isra.78+0x2c5/0x800
    [   90.609336][ T1131]  ? kasan_unpoison_shadow+0x30/0x40
    [   90.610096][ T1131]  ? kmem_cache_alloc_trace+0x135/0x350
    [   90.610889][ T1131]  ? rtnl_newlink+0x4c/0x90
    [   90.611512][ T1131]  rtnl_newlink+0x65/0x90
    [ ... ]
    
    Fixes: 23790ef12082 ("net: qualcomm: rmnet: Allow to configure flags for existing devices")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index 471e3b2a1403..ac58f584190b 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -300,10 +300,8 @@ static int rmnet_changelink(struct net_device *dev, struct nlattr *tb[],
 	if (!dev)
 		return -ENODEV;
 
-	real_dev = __dev_get_by_index(dev_net(dev),
-				      nla_get_u32(tb[IFLA_LINK]));
-
-	if (!real_dev || !rmnet_is_real_dev_registered(real_dev))
+	real_dev = priv->real_dev;
+	if (!rmnet_is_real_dev_registered(real_dev))
 		return -ENODEV;
 
 	port = rmnet_get_port_rtnl(real_dev);

commit 93b5cbfa9636d385126f211dca9efa7e3f683202
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Thu Feb 27 12:23:52 2020 +0000

    net: rmnet: fix NULL pointer dereference in rmnet_newlink()
    
    rmnet registers IFLA_LINK interface as a lower interface.
    But, IFLA_LINK could be NULL.
    In the current code, rmnet doesn't check IFLA_LINK.
    So, panic would occur.
    
    Test commands:
        modprobe rmnet
        ip link add rmnet0 type rmnet mux_id 1
    
    Splat looks like:
    [   36.826109][ T1115] general protection fault, probably for non-canonical address 0xdffffc0000000000I
    [   36.838817][ T1115] KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]
    [   36.839908][ T1115] CPU: 1 PID: 1115 Comm: ip Not tainted 5.6.0-rc1+ #447
    [   36.840569][ T1115] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [   36.841408][ T1115] RIP: 0010:rmnet_newlink+0x54/0x510 [rmnet]
    [   36.841986][ T1115] Code: 83 ec 18 48 c1 e9 03 80 3c 01 00 0f 85 d4 03 00 00 48 8b 6a 28 48 b8 00 00 00 00 00 c
    [   36.843923][ T1115] RSP: 0018:ffff8880b7e0f1c0 EFLAGS: 00010247
    [   36.844756][ T1115] RAX: dffffc0000000000 RBX: ffff8880d14cca00 RCX: 1ffff11016fc1e99
    [   36.845859][ T1115] RDX: 0000000000000000 RSI: ffff8880c3d04000 RDI: 0000000000000004
    [   36.846961][ T1115] RBP: 0000000000000000 R08: ffff8880b7e0f8b0 R09: ffff8880b6ac2d90
    [   36.848020][ T1115] R10: ffffffffc0589a40 R11: ffffed1016d585b7 R12: ffffffff88ceaf80
    [   36.848788][ T1115] R13: ffff8880c3d04000 R14: ffff8880b7e0f8b0 R15: ffff8880c3d04000
    [   36.849546][ T1115] FS:  00007f50ab3360c0(0000) GS:ffff8880da000000(0000) knlGS:0000000000000000
    [   36.851784][ T1115] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [   36.852422][ T1115] CR2: 000055871afe5ab0 CR3: 00000000ae246001 CR4: 00000000000606e0
    [   36.853181][ T1115] Call Trace:
    [   36.853514][ T1115]  __rtnl_newlink+0xbdb/0x1270
    [   36.853967][ T1115]  ? lock_downgrade+0x6e0/0x6e0
    [   36.854420][ T1115]  ? rtnl_link_unregister+0x220/0x220
    [   36.854936][ T1115]  ? lock_acquire+0x164/0x3b0
    [   36.855376][ T1115]  ? is_bpf_image_address+0xff/0x1d0
    [   36.855884][ T1115]  ? rtnl_newlink+0x4c/0x90
    [   36.856304][ T1115]  ? kernel_text_address+0x111/0x140
    [   36.856857][ T1115]  ? __kernel_text_address+0xe/0x30
    [   36.857440][ T1115]  ? unwind_get_return_address+0x5f/0xa0
    [   36.858063][ T1115]  ? create_prof_cpu_mask+0x20/0x20
    [   36.858644][ T1115]  ? arch_stack_walk+0x83/0xb0
    [   36.859171][ T1115]  ? stack_trace_save+0x82/0xb0
    [   36.859710][ T1115]  ? stack_trace_consume_entry+0x160/0x160
    [   36.860357][ T1115]  ? deactivate_slab.isra.78+0x2c5/0x800
    [   36.860928][ T1115]  ? kasan_unpoison_shadow+0x30/0x40
    [   36.861520][ T1115]  ? kmem_cache_alloc_trace+0x135/0x350
    [   36.862125][ T1115]  ? rtnl_newlink+0x4c/0x90
    [   36.864073][ T1115]  rtnl_newlink+0x65/0x90
    [ ... ]
    
    Fixes: ceed73a2cf4a ("drivers: net: ethernet: qualcomm: rmnet: Initial implementation")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index 06de59521fc4..471e3b2a1403 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -135,6 +135,11 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 	int err = 0;
 	u16 mux_id;
 
+	if (!tb[IFLA_LINK]) {
+		NL_SET_ERR_MSG_MOD(extack, "link not specified");
+		return -EINVAL;
+	}
+
 	real_dev = __dev_get_by_index(src_net, nla_get_u32(tb[IFLA_LINK]));
 	if (!real_dev || !dev)
 		return -ENODEV;

commit e7a86c687e64ab24f88330ad24ecc9442ce40c5a
Author: Sean Tranchetti <stranche@codeaurora.org>
Date:   Mon Nov 4 17:54:22 2019 -0700

    net: qualcomm: rmnet: Fix potential UAF when unregistering
    
    During the exit/unregistration process of the RmNet driver, the function
    rmnet_unregister_real_device() is called to handle freeing the driver's
    internal state and removing the RX handler on the underlying physical
    device. However, the order of operations this function performs is wrong
    and can lead to a use after free of the rmnet_port structure.
    
    Before calling netdev_rx_handler_unregister(), this port structure is
    freed with kfree(). If packets are received on any RmNet devices before
    synchronize_net() completes, they will attempt to use this already-freed
    port structure when processing the packet. As such, before cleaning up any
    other internal state, the RX handler must be unregistered in order to
    guarantee that no further packets will arrive on the device.
    
    Fixes: ceed73a2cf4a ("drivers: net: ethernet: qualcomm: rmnet: Initial implementation")
    Signed-off-by: Sean Tranchetti <stranche@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index 9c54b715228e..06de59521fc4 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -57,10 +57,10 @@ static int rmnet_unregister_real_device(struct net_device *real_dev,
 	if (port->nr_rmnet_devs)
 		return -EINVAL;
 
-	kfree(port);
-
 	netdev_rx_handler_unregister(real_dev);
 
+	kfree(port);
+
 	/* release reference on real_dev */
 	dev_put(real_dev);
 

commit 97fb5e8d9b57f10f294303c9a5d1bd033eded6bf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:17:58 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 284
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 and
      only version 2 as published by the free software foundation this
      program is distributed in the hope that it will be useful but
      without any warranty without even the implied warranty of
      merchantability or fitness for a particular purpose see the gnu
      general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 294 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141900.825281744@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index b8bbee645f51..9c54b715228e 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -1,16 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /* Copyright (c) 2013-2018, The Linux Foundation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  *
  * RMNET configuration engine
- *
  */
 
 #include <net/sock.h>

commit 3c18aa1464f9232d6abac8d7b4540f61b0658d62
Author: Colin Ian King <colin.king@canonical.com>
Date:   Sat Nov 24 15:03:02 2018 +0000

    net: qualcomm: rmnet: move null check on dev before dereferecing it
    
    Currently dev is dereferenced by the call dev_net(dev) before dev is null
    checked.  Fix this by null checking dev before the potential null
    pointer dereference.
    
    Detected by CoverityScan, CID#1462955 ("Dereference before null check")
    
    Fixes: 23790ef12082 ("net: qualcomm: rmnet: Allow to configure flags for existing devices")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index 5f4e447c5dce..b8bbee645f51 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -301,10 +301,13 @@ static int rmnet_changelink(struct net_device *dev, struct nlattr *tb[],
 	struct rmnet_port *port;
 	u16 mux_id;
 
+	if (!dev)
+		return -ENODEV;
+
 	real_dev = __dev_get_by_index(dev_net(dev),
 				      nla_get_u32(tb[IFLA_LINK]));
 
-	if (!real_dev || !dev || !rmnet_is_real_dev_registered(real_dev))
+	if (!real_dev || !rmnet_is_real_dev_registered(real_dev))
 		return -ENODEV;
 
 	port = rmnet_get_port_rtnl(real_dev);

commit 64e86fec54069266ba32be551d7b7f75e88ab60c
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Tue Apr 17 17:40:00 2018 -0600

    net: qualcomm: rmnet: Fix warning seen with fill_info
    
    When the last rmnet device attached to a real device is removed, the
    real device is unregistered from rmnet. As a result, the real device
    lookup fails resulting in a warning when the fill_info handler is
    called as part of the rmnet device unregistration.
    
    Fix this by returning the rmnet flags as 0 when no real device is
    present.
    
    WARNING: CPU: 0 PID: 1779 at net/core/rtnetlink.c:3254
    rtmsg_ifinfo_build_skb+0xca/0x10d
    Modules linked in:
    CPU: 0 PID: 1779 Comm: ip Not tainted 4.16.0-11872-g7ce2367 #1
    Stack:
     7fe655f0 60371ea3 00000000 00000000
     60282bc6 6006b116 7fe65600 60371ee8
     7fe65660 6003a68c 00000000 900000000
    Call Trace:
     [<6006b116>] ? printk+0x0/0x94
     [<6001f375>] show_stack+0xfe/0x158
     [<60371ea3>] ? dump_stack_print_info+0xe8/0xf1
     [<60282bc6>] ? rtmsg_ifinfo_build_skb+0xca/0x10d
     [<6006b116>] ? printk+0x0/0x94
     [<60371ee8>] dump_stack+0x2a/0x2c
     [<6003a68c>] __warn+0x10e/0x13e
     [<6003a82c>] warn_slowpath_null+0x48/0x4f
     [<60282bc6>] rtmsg_ifinfo_build_skb+0xca/0x10d
     [<60282c4d>] rtmsg_ifinfo_event.part.37+0x1e/0x43
     [<60282c2f>] ? rtmsg_ifinfo_event.part.37+0x0/0x43
     [<60282d03>] rtmsg_ifinfo+0x24/0x28
     [<60264e86>] dev_close_many+0xba/0x119
     [<60282cdf>] ? rtmsg_ifinfo+0x0/0x28
     [<6027c225>] ? rtnl_is_locked+0x0/0x1c
     [<6026ca67>] rollback_registered_many+0x1ae/0x4ae
     [<600314be>] ? unblock_signals+0x0/0xae
     [<6026cdc0>] ? unregister_netdevice_queue+0x19/0xec
     [<6026ceec>] unregister_netdevice_many+0x21/0xa1
     [<6027c765>] rtnl_delete_link+0x3e/0x4e
     [<60280ecb>] rtnl_dellink+0x262/0x29c
     [<6027c241>] ? rtnl_get_link+0x0/0x3e
     [<6027f867>] rtnetlink_rcv_msg+0x235/0x274
    
    Fixes: be81a85f5f87 ("net: qualcomm: rmnet: Implement fill_info")
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index d33988570217..5f4e447c5dce 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -350,15 +350,16 @@ static int rmnet_fill_info(struct sk_buff *skb, const struct net_device *dev)
 
 	real_dev = priv->real_dev;
 
-	if (!rmnet_is_real_dev_registered(real_dev))
-		return -ENODEV;
-
 	if (nla_put_u16(skb, IFLA_RMNET_MUX_ID, priv->mux_id))
 		goto nla_put_failure;
 
-	port = rmnet_get_port_rtnl(real_dev);
+	if (rmnet_is_real_dev_registered(real_dev)) {
+		port = rmnet_get_port_rtnl(real_dev);
+		f.flags = port->data_format;
+	} else {
+		f.flags = 0;
+	}
 
-	f.flags = port->data_format;
 	f.mask  = ~0;
 
 	if (nla_put(skb, IFLA_RMNET_FLAGS, sizeof(f), &f))

commit 0c29ba1b43df1eb7d8beb03fc929d2dac4c15f7e
Author: Colin Ian King <colin.king@canonical.com>
Date:   Fri Mar 23 23:51:57 2018 +0000

    net: qualcomm: rmnet: check for null ep to avoid null pointer dereference
    
    The call to rmnet_get_endpoint can potentially return NULL so check
    for this to avoid any subsequent null pointer dereferences on a NULL
    ep.
    
    Detected by CoverityScan, CID#1465385 ("Dereference null return value")
    
    Fixes: 23790ef12082 ("net: qualcomm: rmnet: Allow to configure flags for existing devices")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index 38d9356ebcc4..d33988570217 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -312,6 +312,8 @@ static int rmnet_changelink(struct net_device *dev, struct nlattr *tb[],
 	if (data[IFLA_RMNET_MUX_ID]) {
 		mux_id = nla_get_u16(data[IFLA_RMNET_MUX_ID]);
 		ep = rmnet_get_endpoint(port, priv->mux_id);
+		if (!ep)
+			return -ENODEV;
 
 		hlist_del_init_rcu(&ep->hlnode);
 		hlist_add_head_rcu(&ep->hlnode, &port->muxed_ep[mux_id]);

commit be81a85f5f87d3c7ae994b646d00b1d828e754a1
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Wed Mar 21 19:48:15 2018 -0600

    net: qualcomm: rmnet: Implement fill_info
    
    This is needed to query the mux_id and flags of a rmnet device.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index c5b7b2af25d8..38d9356ebcc4 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -339,6 +339,35 @@ static size_t rmnet_get_size(const struct net_device *dev)
 		nla_total_size(sizeof(struct ifla_rmnet_flags));
 }
 
+static int rmnet_fill_info(struct sk_buff *skb, const struct net_device *dev)
+{
+	struct rmnet_priv *priv = netdev_priv(dev);
+	struct net_device *real_dev;
+	struct ifla_rmnet_flags f;
+	struct rmnet_port *port;
+
+	real_dev = priv->real_dev;
+
+	if (!rmnet_is_real_dev_registered(real_dev))
+		return -ENODEV;
+
+	if (nla_put_u16(skb, IFLA_RMNET_MUX_ID, priv->mux_id))
+		goto nla_put_failure;
+
+	port = rmnet_get_port_rtnl(real_dev);
+
+	f.flags = port->data_format;
+	f.mask  = ~0;
+
+	if (nla_put(skb, IFLA_RMNET_FLAGS, sizeof(f), &f))
+		goto nla_put_failure;
+
+	return 0;
+
+nla_put_failure:
+	return -EMSGSIZE;
+}
+
 struct rtnl_link_ops rmnet_link_ops __read_mostly = {
 	.kind		= "rmnet",
 	.maxtype	= __IFLA_RMNET_MAX,
@@ -350,6 +379,7 @@ struct rtnl_link_ops rmnet_link_ops __read_mostly = {
 	.get_size	= rmnet_get_size,
 	.changelink     = rmnet_changelink,
 	.policy		= rmnet_policy,
+	.fill_info	= rmnet_fill_info,
 };
 
 /* Needs either rcu_read_lock() or rtnl lock */

commit 14452ca3b5ce304fb2fea96dbc9ca1e4e7978551
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Wed Mar 21 19:48:14 2018 -0600

    net: qualcomm: rmnet: Export mux_id and flags to netlink
    
    Define new netlink attributes for rmnet mux_id and flags. These
    flags / mux_id were earlier using vlan flags / id respectively.
    The flag bits are also moved to uapi and are renamed with
    prefix RMNET_FLAG_*.
    
    Also add the rmnet policy to handle the new netlink attributes.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index 096301a31c4f..c5b7b2af25d8 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -43,6 +43,11 @@
 
 /* Local Definitions and Declarations */
 
+static const struct nla_policy rmnet_policy[IFLA_RMNET_MAX + 1] = {
+	[IFLA_RMNET_MUX_ID]	= { .type = NLA_U16 },
+	[IFLA_RMNET_FLAGS]	= { .len = sizeof(struct ifla_rmnet_flags) },
+};
+
 static int rmnet_is_real_dev_registered(const struct net_device *real_dev)
 {
 	return rcu_access_pointer(real_dev->rx_handler) == rmnet_rx_handler;
@@ -131,7 +136,7 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 			 struct nlattr *tb[], struct nlattr *data[],
 			 struct netlink_ext_ack *extack)
 {
-	u32 data_format = RMNET_INGRESS_FORMAT_DEAGGREGATION;
+	u32 data_format = RMNET_FLAGS_INGRESS_DEAGGREGATION;
 	struct net_device *real_dev;
 	int mode = RMNET_EPMODE_VND;
 	struct rmnet_endpoint *ep;
@@ -143,14 +148,14 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 	if (!real_dev || !dev)
 		return -ENODEV;
 
-	if (!data[IFLA_VLAN_ID])
+	if (!data[IFLA_RMNET_MUX_ID])
 		return -EINVAL;
 
 	ep = kzalloc(sizeof(*ep), GFP_ATOMIC);
 	if (!ep)
 		return -ENOMEM;
 
-	mux_id = nla_get_u16(data[IFLA_VLAN_ID]);
+	mux_id = nla_get_u16(data[IFLA_RMNET_MUX_ID]);
 
 	err = rmnet_register_real_device(real_dev);
 	if (err)
@@ -165,10 +170,10 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 
 	hlist_add_head_rcu(&ep->hlnode, &port->muxed_ep[mux_id]);
 
-	if (data[IFLA_VLAN_FLAGS]) {
-		struct ifla_vlan_flags *flags;
+	if (data[IFLA_RMNET_FLAGS]) {
+		struct ifla_rmnet_flags *flags;
 
-		flags = nla_data(data[IFLA_VLAN_FLAGS]);
+		flags = nla_data(data[IFLA_RMNET_FLAGS]);
 		data_format = flags->flags & flags->mask;
 	}
 
@@ -276,10 +281,10 @@ static int rmnet_rtnl_validate(struct nlattr *tb[], struct nlattr *data[],
 {
 	u16 mux_id;
 
-	if (!data || !data[IFLA_VLAN_ID])
+	if (!data || !data[IFLA_RMNET_MUX_ID])
 		return -EINVAL;
 
-	mux_id = nla_get_u16(data[IFLA_VLAN_ID]);
+	mux_id = nla_get_u16(data[IFLA_RMNET_MUX_ID]);
 	if (mux_id > (RMNET_MAX_LOGICAL_EP - 1))
 		return -ERANGE;
 
@@ -304,8 +309,8 @@ static int rmnet_changelink(struct net_device *dev, struct nlattr *tb[],
 
 	port = rmnet_get_port_rtnl(real_dev);
 
-	if (data[IFLA_VLAN_ID]) {
-		mux_id = nla_get_u16(data[IFLA_VLAN_ID]);
+	if (data[IFLA_RMNET_MUX_ID]) {
+		mux_id = nla_get_u16(data[IFLA_RMNET_MUX_ID]);
 		ep = rmnet_get_endpoint(port, priv->mux_id);
 
 		hlist_del_init_rcu(&ep->hlnode);
@@ -315,10 +320,10 @@ static int rmnet_changelink(struct net_device *dev, struct nlattr *tb[],
 		priv->mux_id = mux_id;
 	}
 
-	if (data[IFLA_VLAN_FLAGS]) {
-		struct ifla_vlan_flags *flags;
+	if (data[IFLA_RMNET_FLAGS]) {
+		struct ifla_rmnet_flags *flags;
 
-		flags = nla_data(data[IFLA_VLAN_FLAGS]);
+		flags = nla_data(data[IFLA_RMNET_FLAGS]);
 		port->data_format = flags->flags & flags->mask;
 	}
 
@@ -327,13 +332,16 @@ static int rmnet_changelink(struct net_device *dev, struct nlattr *tb[],
 
 static size_t rmnet_get_size(const struct net_device *dev)
 {
-	return nla_total_size(2) /* IFLA_VLAN_ID */ +
-	       nla_total_size(sizeof(struct ifla_vlan_flags)); /* IFLA_VLAN_FLAGS */
+	return
+		/* IFLA_RMNET_MUX_ID */
+		nla_total_size(2) +
+		/* IFLA_RMNET_FLAGS */
+		nla_total_size(sizeof(struct ifla_rmnet_flags));
 }
 
 struct rtnl_link_ops rmnet_link_ops __read_mostly = {
 	.kind		= "rmnet",
-	.maxtype	= __IFLA_VLAN_MAX,
+	.maxtype	= __IFLA_RMNET_MAX,
 	.priv_size	= sizeof(struct rmnet_priv),
 	.setup		= rmnet_vnd_setup,
 	.validate	= rmnet_rtnl_validate,
@@ -341,6 +349,7 @@ struct rtnl_link_ops rmnet_link_ops __read_mostly = {
 	.dellink	= rmnet_dellink,
 	.get_size	= rmnet_get_size,
 	.changelink     = rmnet_changelink,
+	.policy		= rmnet_policy,
 };
 
 /* Needs either rcu_read_lock() or rtnl lock */

commit 9dcaec042600dce169ae74527e5eead349f8eb90
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Wed Mar 21 19:48:12 2018 -0600

    net: qualcomm: rmnet: Update copyright year to 2018
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index c4949183eef3..096301a31c4f 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2013-2017, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2013-2018, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and

commit b37f78f234bf4fd98979d6c3ccc0f85e508f978f
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Fri Feb 16 15:56:37 2018 -0700

    net: qualcomm: rmnet: Fix crash on real dev unregistration
    
    With CONFIG_DEBUG_PREEMPT enabled, a crash with the following call
    stack was observed when removing a real dev which had rmnet devices
    attached to it.
    To fix this, remove the netdev_upper link APIs and instead use the
    existing information in rmnet_port and rmnet_priv to get the
    association between real and rmnet devs.
    
    BUG: sleeping function called from invalid context
    in_atomic(): 0, irqs_disabled(): 0, pid: 5762, name: ip
    Preemption disabled at:
    [<ffffff9d49043564>] debug_object_active_state+0xa4/0x16c
    Internal error: Oops - BUG: 0 [#1] PREEMPT SMP
    Modules linked in:
    PC is at ___might_sleep+0x13c/0x180
    LR is at ___might_sleep+0x17c/0x180
    [<ffffff9d48ce0924>] ___might_sleep+0x13c/0x180
    [<ffffff9d48ce09c0>] __might_sleep+0x58/0x8c
    [<ffffff9d49d6253c>] mutex_lock+0x2c/0x48
    [<ffffff9d48ed4840>] kernfs_remove_by_name_ns+0x48/0xa8
    [<ffffff9d48ed6ec8>] sysfs_remove_link+0x30/0x58
    [<ffffff9d49b05840>] __netdev_adjacent_dev_remove+0x14c/0x1e0
    [<ffffff9d49b05914>] __netdev_adjacent_dev_unlink_lists+0x40/0x68
    [<ffffff9d49b08820>] netdev_upper_dev_unlink+0xb4/0x1fc
    [<ffffff9d494a29f0>] rmnet_dev_walk_unreg+0x6c/0xc8
    [<ffffff9d49b00b40>] netdev_walk_all_lower_dev_rcu+0x58/0xb4
    [<ffffff9d494a30fc>] rmnet_config_notify_cb+0xf4/0x134
    [<ffffff9d48cd21b4>] raw_notifier_call_chain+0x58/0x78
    [<ffffff9d49b028a4>] call_netdevice_notifiers_info+0x48/0x78
    [<ffffff9d49b0b568>] rollback_registered_many+0x230/0x3c8
    [<ffffff9d49b0b738>] unregister_netdevice_many+0x38/0x94
    [<ffffff9d49b1e110>] rtnl_delete_link+0x58/0x88
    [<ffffff9d49b201dc>] rtnl_dellink+0xbc/0x1cc
    [<ffffff9d49b2355c>] rtnetlink_rcv_msg+0xb0/0x244
    [<ffffff9d49b5230c>] netlink_rcv_skb+0xb4/0xdc
    [<ffffff9d49b204f4>] rtnetlink_rcv+0x34/0x44
    [<ffffff9d49b51af0>] netlink_unicast+0x1ec/0x294
    [<ffffff9d49b51fdc>] netlink_sendmsg+0x320/0x390
    [<ffffff9d49ae6858>] sock_sendmsg+0x54/0x60
    [<ffffff9d49ae6f94>] ___sys_sendmsg+0x298/0x2b0
    [<ffffff9d49ae98f8>] SyS_sendmsg+0xb4/0xf0
    [<ffffff9d48c83770>] el0_svc_naked+0x24/0x28
    
    Fixes: ceed73a2cf4a ("drivers: net: ethernet: qualcomm: rmnet: Initial implementation")
    Fixes: 60d58f971c10 ("net: qualcomm: rmnet: Implement bridge mode")
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index 7e7704daf5f1..c4949183eef3 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -43,12 +43,6 @@
 
 /* Local Definitions and Declarations */
 
-struct rmnet_walk_data {
-	struct net_device *real_dev;
-	struct list_head *head;
-	struct rmnet_port *port;
-};
-
 static int rmnet_is_real_dev_registered(const struct net_device *real_dev)
 {
 	return rcu_access_pointer(real_dev->rx_handler) == rmnet_rx_handler;
@@ -112,17 +106,14 @@ static int rmnet_register_real_device(struct net_device *real_dev)
 static void rmnet_unregister_bridge(struct net_device *dev,
 				    struct rmnet_port *port)
 {
-	struct net_device *rmnet_dev, *bridge_dev;
 	struct rmnet_port *bridge_port;
+	struct net_device *bridge_dev;
 
 	if (port->rmnet_mode != RMNET_EPMODE_BRIDGE)
 		return;
 
 	/* bridge slave handling */
 	if (!port->nr_rmnet_devs) {
-		rmnet_dev = netdev_master_upper_dev_get_rcu(dev);
-		netdev_upper_dev_unlink(dev, rmnet_dev);
-
 		bridge_dev = port->bridge_ep;
 
 		bridge_port = rmnet_get_port_rtnl(bridge_dev);
@@ -132,9 +123,6 @@ static void rmnet_unregister_bridge(struct net_device *dev,
 		bridge_dev = port->bridge_ep;
 
 		bridge_port = rmnet_get_port_rtnl(bridge_dev);
-		rmnet_dev = netdev_master_upper_dev_get_rcu(bridge_dev);
-		netdev_upper_dev_unlink(bridge_dev, rmnet_dev);
-
 		rmnet_unregister_real_device(bridge_dev, bridge_port);
 	}
 }
@@ -173,10 +161,6 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 	if (err)
 		goto err1;
 
-	err = netdev_master_upper_dev_link(dev, real_dev, NULL, NULL, extack);
-	if (err)
-		goto err2;
-
 	port->rmnet_mode = mode;
 
 	hlist_add_head_rcu(&ep->hlnode, &port->muxed_ep[mux_id]);
@@ -193,8 +177,6 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 
 	return 0;
 
-err2:
-	rmnet_vnd_dellink(mux_id, port, ep);
 err1:
 	rmnet_unregister_real_device(real_dev, port);
 err0:
@@ -204,14 +186,13 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 
 static void rmnet_dellink(struct net_device *dev, struct list_head *head)
 {
+	struct rmnet_priv *priv = netdev_priv(dev);
 	struct net_device *real_dev;
 	struct rmnet_endpoint *ep;
 	struct rmnet_port *port;
 	u8 mux_id;
 
-	rcu_read_lock();
-	real_dev = netdev_master_upper_dev_get_rcu(dev);
-	rcu_read_unlock();
+	real_dev = priv->real_dev;
 
 	if (!real_dev || !rmnet_is_real_dev_registered(real_dev))
 		return;
@@ -219,7 +200,6 @@ static void rmnet_dellink(struct net_device *dev, struct list_head *head)
 	port = rmnet_get_port_rtnl(real_dev);
 
 	mux_id = rmnet_vnd_get_mux(dev);
-	netdev_upper_dev_unlink(dev, real_dev);
 
 	ep = rmnet_get_endpoint(port, mux_id);
 	if (ep) {
@@ -233,30 +213,13 @@ static void rmnet_dellink(struct net_device *dev, struct list_head *head)
 	unregister_netdevice_queue(dev, head);
 }
 
-static int rmnet_dev_walk_unreg(struct net_device *rmnet_dev, void *data)
-{
-	struct rmnet_walk_data *d = data;
-	struct rmnet_endpoint *ep;
-	u8 mux_id;
-
-	mux_id = rmnet_vnd_get_mux(rmnet_dev);
-	ep = rmnet_get_endpoint(d->port, mux_id);
-	if (ep) {
-		hlist_del_init_rcu(&ep->hlnode);
-		rmnet_vnd_dellink(mux_id, d->port, ep);
-		kfree(ep);
-	}
-	netdev_upper_dev_unlink(rmnet_dev, d->real_dev);
-	unregister_netdevice_queue(rmnet_dev, d->head);
-
-	return 0;
-}
-
 static void rmnet_force_unassociate_device(struct net_device *dev)
 {
 	struct net_device *real_dev = dev;
-	struct rmnet_walk_data d;
+	struct hlist_node *tmp_ep;
+	struct rmnet_endpoint *ep;
 	struct rmnet_port *port;
+	unsigned long bkt_ep;
 	LIST_HEAD(list);
 
 	if (!rmnet_is_real_dev_registered(real_dev))
@@ -264,16 +227,19 @@ static void rmnet_force_unassociate_device(struct net_device *dev)
 
 	ASSERT_RTNL();
 
-	d.real_dev = real_dev;
-	d.head = &list;
-
 	port = rmnet_get_port_rtnl(dev);
-	d.port = port;
 
 	rcu_read_lock();
 	rmnet_unregister_bridge(dev, port);
 
-	netdev_walk_all_lower_dev_rcu(real_dev, rmnet_dev_walk_unreg, &d);
+	hash_for_each_safe(port->muxed_ep, bkt_ep, tmp_ep, ep, hlnode) {
+		unregister_netdevice_queue(ep->egress_dev, &list);
+		rmnet_vnd_dellink(ep->mux_id, port, ep);
+
+		hlist_del_init_rcu(&ep->hlnode);
+		kfree(ep);
+	}
+
 	rcu_read_unlock();
 	unregister_netdevice_many(&list);
 
@@ -422,11 +388,6 @@ int rmnet_add_bridge(struct net_device *rmnet_dev,
 	if (err)
 		return -EBUSY;
 
-	err = netdev_master_upper_dev_link(slave_dev, rmnet_dev, NULL, NULL,
-					   extack);
-	if (err)
-		return -EINVAL;
-
 	slave_port = rmnet_get_port(slave_dev);
 	slave_port->rmnet_mode = RMNET_EPMODE_BRIDGE;
 	slave_port->bridge_ep = real_dev;
@@ -449,7 +410,6 @@ int rmnet_del_bridge(struct net_device *rmnet_dev,
 	port->rmnet_mode = RMNET_EPMODE_VND;
 	port->bridge_ep = NULL;
 
-	netdev_upper_dev_unlink(slave_dev, rmnet_dev);
 	slave_port = rmnet_get_port(slave_dev);
 	rmnet_unregister_real_device(slave_dev, slave_port);
 

commit b23e722ed69075b8a35070a272405653c6911fa5
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Sun Jan 7 11:36:34 2018 -0700

    net: qualcomm: rmnet: Rename ingress data format to data format
    
    This is done so that we can use this field for both ingress and
    egress flags.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index cedacddf50fb..7e7704daf5f1 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -143,7 +143,7 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 			 struct nlattr *tb[], struct nlattr *data[],
 			 struct netlink_ext_ack *extack)
 {
-	int ingress_format = RMNET_INGRESS_FORMAT_DEAGGREGATION;
+	u32 data_format = RMNET_INGRESS_FORMAT_DEAGGREGATION;
 	struct net_device *real_dev;
 	int mode = RMNET_EPMODE_VND;
 	struct rmnet_endpoint *ep;
@@ -185,11 +185,11 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 		struct ifla_vlan_flags *flags;
 
 		flags = nla_data(data[IFLA_VLAN_FLAGS]);
-		ingress_format = flags->flags & flags->mask;
+		data_format = flags->flags & flags->mask;
 	}
 
-	netdev_dbg(dev, "data format [ingress 0x%08X]\n", ingress_format);
-	port->ingress_data_format = ingress_format;
+	netdev_dbg(dev, "data format [0x%08X]\n", data_format);
+	port->data_format = data_format;
 
 	return 0;
 
@@ -353,7 +353,7 @@ static int rmnet_changelink(struct net_device *dev, struct nlattr *tb[],
 		struct ifla_vlan_flags *flags;
 
 		flags = nla_data(data[IFLA_VLAN_FLAGS]);
-		port->ingress_data_format = flags->flags & flags->mask;
+		port->data_format = flags->flags & flags->mask;
 	}
 
 	return 0;

commit 23790ef12082a14e18580ec1fc4e9570588a0024
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Mon Dec 11 17:30:15 2017 -0700

    net: qualcomm: rmnet: Allow to configure flags for existing devices
    
    Add an option to configure the mux id, aggregation and commad feature
    for existing rmnet devices. Implement the changelink netlink
    operation for this.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index 7a4c26e5a31d..cedacddf50fb 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -320,6 +320,45 @@ static int rmnet_rtnl_validate(struct nlattr *tb[], struct nlattr *data[],
 	return 0;
 }
 
+static int rmnet_changelink(struct net_device *dev, struct nlattr *tb[],
+			    struct nlattr *data[],
+			    struct netlink_ext_ack *extack)
+{
+	struct rmnet_priv *priv = netdev_priv(dev);
+	struct net_device *real_dev;
+	struct rmnet_endpoint *ep;
+	struct rmnet_port *port;
+	u16 mux_id;
+
+	real_dev = __dev_get_by_index(dev_net(dev),
+				      nla_get_u32(tb[IFLA_LINK]));
+
+	if (!real_dev || !dev || !rmnet_is_real_dev_registered(real_dev))
+		return -ENODEV;
+
+	port = rmnet_get_port_rtnl(real_dev);
+
+	if (data[IFLA_VLAN_ID]) {
+		mux_id = nla_get_u16(data[IFLA_VLAN_ID]);
+		ep = rmnet_get_endpoint(port, priv->mux_id);
+
+		hlist_del_init_rcu(&ep->hlnode);
+		hlist_add_head_rcu(&ep->hlnode, &port->muxed_ep[mux_id]);
+
+		ep->mux_id = mux_id;
+		priv->mux_id = mux_id;
+	}
+
+	if (data[IFLA_VLAN_FLAGS]) {
+		struct ifla_vlan_flags *flags;
+
+		flags = nla_data(data[IFLA_VLAN_FLAGS]);
+		port->ingress_data_format = flags->flags & flags->mask;
+	}
+
+	return 0;
+}
+
 static size_t rmnet_get_size(const struct net_device *dev)
 {
 	return nla_total_size(2) /* IFLA_VLAN_ID */ +
@@ -335,6 +374,7 @@ struct rtnl_link_ops rmnet_link_ops __read_mostly = {
 	.newlink	= rmnet_newlink,
 	.dellink	= rmnet_dellink,
 	.get_size	= rmnet_get_size,
+	.changelink     = rmnet_changelink,
 };
 
 /* Needs either rcu_read_lock() or rtnl lock */

commit 6b8ecc23f209b649b98160af9c565b7736cc8224
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Mon Dec 11 17:30:14 2017 -0700

    net: qualcomm: rmnet: Allow to configure flags for new devices
    
    Add an option to configure the rmnet aggregation and command features
    on device creation. This is achieved by using the vlan flags option.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index 46bb2282b4a6..7a4c26e5a31d 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -177,11 +177,20 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 	if (err)
 		goto err2;
 
-	netdev_dbg(dev, "data format [ingress 0x%08X]\n", ingress_format);
-	port->ingress_data_format = ingress_format;
 	port->rmnet_mode = mode;
 
 	hlist_add_head_rcu(&ep->hlnode, &port->muxed_ep[mux_id]);
+
+	if (data[IFLA_VLAN_FLAGS]) {
+		struct ifla_vlan_flags *flags;
+
+		flags = nla_data(data[IFLA_VLAN_FLAGS]);
+		ingress_format = flags->flags & flags->mask;
+	}
+
+	netdev_dbg(dev, "data format [ingress 0x%08X]\n", ingress_format);
+	port->ingress_data_format = ingress_format;
+
 	return 0;
 
 err2:
@@ -313,7 +322,8 @@ static int rmnet_rtnl_validate(struct nlattr *tb[], struct nlattr *data[],
 
 static size_t rmnet_get_size(const struct net_device *dev)
 {
-	return nla_total_size(2); /* IFLA_VLAN_ID */
+	return nla_total_size(2) /* IFLA_VLAN_ID */ +
+	       nla_total_size(sizeof(struct ifla_vlan_flags)); /* IFLA_VLAN_FLAGS */
 }
 
 struct rtnl_link_ops rmnet_link_ops __read_mostly = {

commit 8de721e21e202ceff3444e5c7abe7428a912a1f5
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Mon Dec 11 17:30:11 2017 -0700

    net: qualcomm: rmnet: Remove the some redundant macros
    
    Multiplexing is always enabled when transmiting from a rmnet device,
    so remove the redundant egress macros. De-multiplexing is always
    enabled when receiving packets from a rmnet device, so remove those
    ingress macros.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index df21e900f874..46bb2282b4a6 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -143,11 +143,7 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 			 struct nlattr *tb[], struct nlattr *data[],
 			 struct netlink_ext_ack *extack)
 {
-	int ingress_format = RMNET_INGRESS_FORMAT_DEMUXING |
-			     RMNET_INGRESS_FORMAT_DEAGGREGATION |
-			     RMNET_INGRESS_FORMAT_MAP;
-	int egress_format = RMNET_EGRESS_FORMAT_MUXING |
-			    RMNET_EGRESS_FORMAT_MAP;
+	int ingress_format = RMNET_INGRESS_FORMAT_DEAGGREGATION;
 	struct net_device *real_dev;
 	int mode = RMNET_EPMODE_VND;
 	struct rmnet_endpoint *ep;
@@ -181,9 +177,7 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 	if (err)
 		goto err2;
 
-	netdev_dbg(dev, "data format [ingress 0x%08X] [egress 0x%08X]\n",
-		   ingress_format, egress_format);
-	port->egress_data_format = egress_format;
+	netdev_dbg(dev, "data format [ingress 0x%08X]\n", ingress_format);
 	port->ingress_data_format = ingress_format;
 	port->rmnet_mode = mode;
 

commit 6296928fa3b9f656d7760fbf346c0cf834788a78
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Tue Dec 5 13:41:18 2017 -0700

    net: qualcomm: rmnet: Fix leak in device creation failure
    
    If the rmnet device creation fails in the newlink either while
    registering with the physical device or after subsequent
    operations, the rmnet endpoint information is never freed.
    
    Fixes: ceed73a2cf4a ("drivers: net: ethernet: qualcomm: rmnet: Initial implementation")
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index 71bee1af71ef..df21e900f874 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -195,6 +195,7 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 err1:
 	rmnet_unregister_real_device(real_dev, port);
 err0:
+	kfree(ep);
 	return err;
 }
 

commit 60d58f971c1077a0f2467b2d5bc38058df43a819
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Wed Oct 11 18:43:58 2017 -0600

    net: qualcomm: rmnet: Implement bridge mode
    
    Add support to bridge two devices which can send multiplexing and
    aggregation (MAP) data. This is done only when the data itself is
    not going to be consumed in the stack but is being passed on to a
    different endpoint. This is mainly used for testing.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index b5fe3f4d22a6..71bee1af71ef 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -109,6 +109,36 @@ static int rmnet_register_real_device(struct net_device *real_dev)
 	return 0;
 }
 
+static void rmnet_unregister_bridge(struct net_device *dev,
+				    struct rmnet_port *port)
+{
+	struct net_device *rmnet_dev, *bridge_dev;
+	struct rmnet_port *bridge_port;
+
+	if (port->rmnet_mode != RMNET_EPMODE_BRIDGE)
+		return;
+
+	/* bridge slave handling */
+	if (!port->nr_rmnet_devs) {
+		rmnet_dev = netdev_master_upper_dev_get_rcu(dev);
+		netdev_upper_dev_unlink(dev, rmnet_dev);
+
+		bridge_dev = port->bridge_ep;
+
+		bridge_port = rmnet_get_port_rtnl(bridge_dev);
+		bridge_port->bridge_ep = NULL;
+		bridge_port->rmnet_mode = RMNET_EPMODE_VND;
+	} else {
+		bridge_dev = port->bridge_ep;
+
+		bridge_port = rmnet_get_port_rtnl(bridge_dev);
+		rmnet_dev = netdev_master_upper_dev_get_rcu(bridge_dev);
+		netdev_upper_dev_unlink(bridge_dev, rmnet_dev);
+
+		rmnet_unregister_real_device(bridge_dev, bridge_port);
+	}
+}
+
 static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 			 struct nlattr *tb[], struct nlattr *data[],
 			 struct netlink_ext_ack *extack)
@@ -190,10 +220,10 @@ static void rmnet_dellink(struct net_device *dev, struct list_head *head)
 	ep = rmnet_get_endpoint(port, mux_id);
 	if (ep) {
 		hlist_del_init_rcu(&ep->hlnode);
+		rmnet_unregister_bridge(dev, port);
 		rmnet_vnd_dellink(mux_id, port, ep);
 		kfree(ep);
 	}
-
 	rmnet_unregister_real_device(real_dev, port);
 
 	unregister_netdevice_queue(dev, head);
@@ -237,6 +267,8 @@ static void rmnet_force_unassociate_device(struct net_device *dev)
 	d.port = port;
 
 	rcu_read_lock();
+	rmnet_unregister_bridge(dev, port);
+
 	netdev_walk_all_lower_dev_rcu(real_dev, rmnet_dev_walk_unreg, &d);
 	rcu_read_unlock();
 	unregister_netdevice_many(&list);
@@ -321,6 +353,65 @@ struct rmnet_endpoint *rmnet_get_endpoint(struct rmnet_port *port, u8 mux_id)
 	return NULL;
 }
 
+int rmnet_add_bridge(struct net_device *rmnet_dev,
+		     struct net_device *slave_dev,
+		     struct netlink_ext_ack *extack)
+{
+	struct rmnet_priv *priv = netdev_priv(rmnet_dev);
+	struct net_device *real_dev = priv->real_dev;
+	struct rmnet_port *port, *slave_port;
+	int err;
+
+	port = rmnet_get_port(real_dev);
+
+	/* If there is more than one rmnet dev attached, its probably being
+	 * used for muxing. Skip the briding in that case
+	 */
+	if (port->nr_rmnet_devs > 1)
+		return -EINVAL;
+
+	if (rmnet_is_real_dev_registered(slave_dev))
+		return -EBUSY;
+
+	err = rmnet_register_real_device(slave_dev);
+	if (err)
+		return -EBUSY;
+
+	err = netdev_master_upper_dev_link(slave_dev, rmnet_dev, NULL, NULL,
+					   extack);
+	if (err)
+		return -EINVAL;
+
+	slave_port = rmnet_get_port(slave_dev);
+	slave_port->rmnet_mode = RMNET_EPMODE_BRIDGE;
+	slave_port->bridge_ep = real_dev;
+
+	port->rmnet_mode = RMNET_EPMODE_BRIDGE;
+	port->bridge_ep = slave_dev;
+
+	netdev_dbg(slave_dev, "registered with rmnet as slave\n");
+	return 0;
+}
+
+int rmnet_del_bridge(struct net_device *rmnet_dev,
+		     struct net_device *slave_dev)
+{
+	struct rmnet_priv *priv = netdev_priv(rmnet_dev);
+	struct net_device *real_dev = priv->real_dev;
+	struct rmnet_port *port, *slave_port;
+
+	port = rmnet_get_port(real_dev);
+	port->rmnet_mode = RMNET_EPMODE_VND;
+	port->bridge_ep = NULL;
+
+	netdev_upper_dev_unlink(slave_dev, rmnet_dev);
+	slave_port = rmnet_get_port(slave_dev);
+	rmnet_unregister_real_device(slave_dev, slave_port);
+
+	netdev_dbg(slave_dev, "removed from rmnet as slave\n");
+	return 0;
+}
+
 /* Startup/Shutdown */
 
 static int __init rmnet_init(void)

commit 3352e6c45760fd6675468a35ef699ab94617cab4
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Wed Oct 11 18:43:57 2017 -0600

    net: qualcomm: rmnet: Convert the muxed endpoint to hlist
    
    Rather than using a static array, use a hlist to store the muxed
    endpoints and use the mux id to query the rmnet_device.
    This is useful as usually very few mux ids are used.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Cc: Dan Williams <dcbw@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index 96058bbccf71..b5fe3f4d22a6 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -61,18 +61,6 @@ rmnet_get_port_rtnl(const struct net_device *real_dev)
 	return rtnl_dereference(real_dev->rx_handler_data);
 }
 
-static struct rmnet_endpoint*
-rmnet_get_endpoint(struct net_device *dev, int config_id)
-{
-	struct rmnet_endpoint *ep;
-	struct rmnet_port *port;
-
-	port = rmnet_get_port_rtnl(dev);
-	ep = &port->muxed_ep[config_id];
-
-	return ep;
-}
-
 static int rmnet_unregister_real_device(struct net_device *real_dev,
 					struct rmnet_port *port)
 {
@@ -93,7 +81,7 @@ static int rmnet_unregister_real_device(struct net_device *real_dev,
 static int rmnet_register_real_device(struct net_device *real_dev)
 {
 	struct rmnet_port *port;
-	int rc;
+	int rc, entry;
 
 	ASSERT_RTNL();
 
@@ -114,26 +102,13 @@ static int rmnet_register_real_device(struct net_device *real_dev)
 	/* hold on to real dev for MAP data */
 	dev_hold(real_dev);
 
+	for (entry = 0; entry < RMNET_MAX_LOGICAL_EP; entry++)
+		INIT_HLIST_HEAD(&port->muxed_ep[entry]);
+
 	netdev_dbg(real_dev, "registered with rmnet\n");
 	return 0;
 }
 
-static void rmnet_set_endpoint_config(struct net_device *dev,
-				      u8 mux_id, struct net_device *egress_dev)
-{
-	struct rmnet_endpoint *ep;
-
-	netdev_dbg(dev, "id %d dev %s\n", mux_id, egress_dev->name);
-
-	ep = rmnet_get_endpoint(dev, mux_id);
-	/* This config is cleared on every set, so its ok to not
-	 * clear it on a device delete.
-	 */
-	memset(ep, 0, sizeof(struct rmnet_endpoint));
-	ep->egress_dev = egress_dev;
-	ep->mux_id = mux_id;
-}
-
 static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 			 struct nlattr *tb[], struct nlattr *data[],
 			 struct netlink_ext_ack *extack)
@@ -145,6 +120,7 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 			    RMNET_EGRESS_FORMAT_MAP;
 	struct net_device *real_dev;
 	int mode = RMNET_EPMODE_VND;
+	struct rmnet_endpoint *ep;
 	struct rmnet_port *port;
 	int err = 0;
 	u16 mux_id;
@@ -156,6 +132,10 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 	if (!data[IFLA_VLAN_ID])
 		return -EINVAL;
 
+	ep = kzalloc(sizeof(*ep), GFP_ATOMIC);
+	if (!ep)
+		return -ENOMEM;
+
 	mux_id = nla_get_u16(data[IFLA_VLAN_ID]);
 
 	err = rmnet_register_real_device(real_dev);
@@ -163,7 +143,7 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 		goto err0;
 
 	port = rmnet_get_port_rtnl(real_dev);
-	err = rmnet_vnd_newlink(mux_id, dev, port, real_dev);
+	err = rmnet_vnd_newlink(mux_id, dev, port, real_dev, ep);
 	if (err)
 		goto err1;
 
@@ -177,11 +157,11 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 	port->ingress_data_format = ingress_format;
 	port->rmnet_mode = mode;
 
-	rmnet_set_endpoint_config(real_dev, mux_id, dev);
+	hlist_add_head_rcu(&ep->hlnode, &port->muxed_ep[mux_id]);
 	return 0;
 
 err2:
-	rmnet_vnd_dellink(mux_id, port);
+	rmnet_vnd_dellink(mux_id, port, ep);
 err1:
 	rmnet_unregister_real_device(real_dev, port);
 err0:
@@ -191,6 +171,7 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 static void rmnet_dellink(struct net_device *dev, struct list_head *head)
 {
 	struct net_device *real_dev;
+	struct rmnet_endpoint *ep;
 	struct rmnet_port *port;
 	u8 mux_id;
 
@@ -204,8 +185,15 @@ static void rmnet_dellink(struct net_device *dev, struct list_head *head)
 	port = rmnet_get_port_rtnl(real_dev);
 
 	mux_id = rmnet_vnd_get_mux(dev);
-	rmnet_vnd_dellink(mux_id, port);
 	netdev_upper_dev_unlink(dev, real_dev);
+
+	ep = rmnet_get_endpoint(port, mux_id);
+	if (ep) {
+		hlist_del_init_rcu(&ep->hlnode);
+		rmnet_vnd_dellink(mux_id, port, ep);
+		kfree(ep);
+	}
+
 	rmnet_unregister_real_device(real_dev, port);
 
 	unregister_netdevice_queue(dev, head);
@@ -214,11 +202,16 @@ static void rmnet_dellink(struct net_device *dev, struct list_head *head)
 static int rmnet_dev_walk_unreg(struct net_device *rmnet_dev, void *data)
 {
 	struct rmnet_walk_data *d = data;
+	struct rmnet_endpoint *ep;
 	u8 mux_id;
 
 	mux_id = rmnet_vnd_get_mux(rmnet_dev);
-
-	rmnet_vnd_dellink(mux_id, d->port);
+	ep = rmnet_get_endpoint(d->port, mux_id);
+	if (ep) {
+		hlist_del_init_rcu(&ep->hlnode);
+		rmnet_vnd_dellink(mux_id, d->port, ep);
+		kfree(ep);
+	}
 	netdev_upper_dev_unlink(rmnet_dev, d->real_dev);
 	unregister_netdevice_queue(rmnet_dev, d->head);
 
@@ -316,6 +309,18 @@ struct rmnet_port *rmnet_get_port(struct net_device *real_dev)
 		return NULL;
 }
 
+struct rmnet_endpoint *rmnet_get_endpoint(struct rmnet_port *port, u8 mux_id)
+{
+	struct rmnet_endpoint *ep;
+
+	hlist_for_each_entry_rcu(ep, &port->muxed_ep[mux_id], hlnode) {
+		if (ep->mux_id == mux_id)
+			return ep;
+	}
+
+	return NULL;
+}
+
 /* Startup/Shutdown */
 
 static int __init rmnet_init(void)

commit 56470c927f1ba1e101b5e5a93e02d23a14fd99b7
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Wed Oct 11 18:43:55 2017 -0600

    net: qualcomm: rmnet: Remove duplicate setting of rmnet private info
    
    The end point is set twice in the local_ep as well as the mux_id and
    the real_dev in the rmnet private structure. Remove the local_ep.
    While these elements are equivalent, rmnet_endpoint will be
    used only as part of the rmnet_port for muxed scenarios in VND mode.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index 85fce9c4d234..96058bbccf71 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -67,13 +67,8 @@ rmnet_get_endpoint(struct net_device *dev, int config_id)
 	struct rmnet_endpoint *ep;
 	struct rmnet_port *port;
 
-	if (!rmnet_is_real_dev_registered(dev)) {
-		ep = rmnet_vnd_get_endpoint(dev);
-	} else {
-		port = rmnet_get_port_rtnl(dev);
-
-		ep = &port->muxed_ep[config_id];
-	}
+	port = rmnet_get_port_rtnl(dev);
+	ep = &port->muxed_ep[config_id];
 
 	return ep;
 }
@@ -183,7 +178,6 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 	port->rmnet_mode = mode;
 
 	rmnet_set_endpoint_config(real_dev, mux_id, dev);
-	rmnet_set_endpoint_config(dev, mux_id, real_dev);
 	return 0;
 
 err2:

commit 9148963201a4627a632d2c769805c9278f6d22d7
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Wed Oct 11 18:43:54 2017 -0600

    net: qualcomm: rmnet: Move rmnet_mode to rmnet_port
    
    Mode information on the real device makes it easier to route packets
    to rmnet device or bridged device based on the configuration.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index 8403eea08d0e..85fce9c4d234 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -124,20 +124,17 @@ static int rmnet_register_real_device(struct net_device *real_dev)
 }
 
 static void rmnet_set_endpoint_config(struct net_device *dev,
-				      u8 mux_id, u8 rmnet_mode,
-				      struct net_device *egress_dev)
+				      u8 mux_id, struct net_device *egress_dev)
 {
 	struct rmnet_endpoint *ep;
 
-	netdev_dbg(dev, "id %d mode %d dev %s\n",
-		   mux_id, rmnet_mode, egress_dev->name);
+	netdev_dbg(dev, "id %d dev %s\n", mux_id, egress_dev->name);
 
 	ep = rmnet_get_endpoint(dev, mux_id);
 	/* This config is cleared on every set, so its ok to not
 	 * clear it on a device delete.
 	 */
 	memset(ep, 0, sizeof(struct rmnet_endpoint));
-	ep->rmnet_mode = rmnet_mode;
 	ep->egress_dev = egress_dev;
 	ep->mux_id = mux_id;
 }
@@ -183,9 +180,10 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 		   ingress_format, egress_format);
 	port->egress_data_format = egress_format;
 	port->ingress_data_format = ingress_format;
+	port->rmnet_mode = mode;
 
-	rmnet_set_endpoint_config(real_dev, mux_id, mode, dev);
-	rmnet_set_endpoint_config(dev, mux_id, mode, real_dev);
+	rmnet_set_endpoint_config(real_dev, mux_id, dev);
+	rmnet_set_endpoint_config(dev, mux_id, real_dev);
 	return 0;
 
 err2:

commit 53954cf8c5d205624167a2bfd117cc0c1a5f3c6d
Merge: 4b54db137575 7a92616c0bac
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Oct 5 17:57:03 2017 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Just simple overlapping changes.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 42ab19ee90292993370a30ad242599d75a3b749e
Author: David Ahern <dsahern@gmail.com>
Date:   Wed Oct 4 17:48:47 2017 -0700

    net: Add extack to upper device linking
    
    Add extack arg to netdev_upper_dev_link and netdev_master_upper_dev_link
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index 98f22551eb45..1af326a60cbb 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -178,7 +178,7 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 	if (err)
 		goto err1;
 
-	err = netdev_master_upper_dev_link(dev, real_dev, NULL, NULL);
+	err = netdev_master_upper_dev_link(dev, real_dev, NULL, NULL, extack);
 	if (err)
 		goto err2;
 

commit 5c346525d3591cb032eca86d0f904cc01f1069ff
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Thu Sep 21 18:00:36 2017 -0600

    net: qualcomm: rmnet: Fix rcu splat in rmnet_is_real_dev_registered
    
    Xiaolong reported a suspicious rcu_dereference_check in the device
    unregister notifier callback. Since we do not dereference the
    rx_handler_data, it's ok to just check for the value of the pointer.
    Note that this section is already protected by rtnl_lock.
    
    [  101.364846] WARNING: suspicious RCU usage
    [  101.365654] 4.13.0-rc6-01701-gceed73a #1 Not tainted
    [  101.370873] -----------------------------
    [  101.372472] drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c:57 suspicious rcu_dereference_check() usage!
    [  101.374427]
    [  101.374427] other info that might help us debug this:
    [  101.374427]
    [  101.387491]
    [  101.387491] rcu_scheduler_active = 2, debug_locks = 1
    [  101.389368] 1 lock held by trinity-main/2809:
    [  101.390736]  #0:  (rtnl_mutex){+.+.+.}, at: [<8146085b>] rtnl_lock+0xf/0x11
    [  101.395482]
    [  101.395482] stack backtrace:
    [  101.396948] CPU: 0 PID: 2809 Comm: trinity-main Not tainted 4.13.0-rc6-01701-gceed73a #1
    [  101.398857] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.9.3-20161025_171302-gandalf 04/01/2014
    [  101.401079] Call Trace:
    [  101.401656]  dump_stack+0xa1/0xeb
    [  101.402871]  lockdep_rcu_suspicious+0xc7/0xd0
    [  101.403665]  rmnet_is_real_dev_registered+0x40/0x4e
    [  101.405199]  rmnet_config_notify_cb+0x2c/0x142
    [  101.406344]  ? wireless_nlevent_flush+0x47/0x71
    [  101.407385]  notifier_call_chain+0x2d/0x47
    [  101.408645]  raw_notifier_call_chain+0xc/0xe
    [  101.409882]  call_netdevice_notifiers_info+0x41/0x49
    [  101.411402]  call_netdevice_notifiers+0xc/0xe
    [  101.412713]  rollback_registered_many+0x268/0x36e
    [  101.413702]  rollback_registered+0x39/0x56
    [  101.414965]  unregister_netdevice_queue+0x79/0x88
    [  101.415908]  unregister_netdev+0x16/0x1d
    
    Fixes: ceed73a2cf4a ("drivers: net: ethernet: qualcomm: rmnet: Initial implementation")
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Reported-by: kernel test robot <xiaolong.ye@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index 98f22551eb45..1e33aea59f50 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -51,10 +51,7 @@ struct rmnet_walk_data {
 
 static int rmnet_is_real_dev_registered(const struct net_device *real_dev)
 {
-	rx_handler_func_t *rx_handler;
-
-	rx_handler = rcu_dereference(real_dev->rx_handler);
-	return (rx_handler == rmnet_rx_handler);
+	return rcu_access_pointer(real_dev->rx_handler) == rmnet_rx_handler;
 }
 
 /* Needs rtnl lock */

commit b665f4f82d31c17926df3ac7c4a59bbff7af463b
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Sat Sep 2 23:30:46 2017 -0600

    net: qualcomm: rmnet: Rename real_dev_info to port
    
    Make it similar to drivers like ipvlan / macvlan so it is easier to read.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Cc: Dan Williams <dcbw@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index 6f21cd018a79..98f22551eb45 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -46,7 +46,7 @@
 struct rmnet_walk_data {
 	struct net_device *real_dev;
 	struct list_head *head;
-	struct rmnet_real_dev_info *real_dev_info;
+	struct rmnet_port *port;
 };
 
 static int rmnet_is_real_dev_registered(const struct net_device *real_dev)
@@ -58,8 +58,8 @@ static int rmnet_is_real_dev_registered(const struct net_device *real_dev)
 }
 
 /* Needs rtnl lock */
-static struct rmnet_real_dev_info*
-rmnet_get_real_dev_info_rtnl(const struct net_device *real_dev)
+static struct rmnet_port*
+rmnet_get_port_rtnl(const struct net_device *real_dev)
 {
 	return rtnl_dereference(real_dev->rx_handler_data);
 }
@@ -67,27 +67,27 @@ rmnet_get_real_dev_info_rtnl(const struct net_device *real_dev)
 static struct rmnet_endpoint*
 rmnet_get_endpoint(struct net_device *dev, int config_id)
 {
-	struct rmnet_real_dev_info *r;
 	struct rmnet_endpoint *ep;
+	struct rmnet_port *port;
 
 	if (!rmnet_is_real_dev_registered(dev)) {
 		ep = rmnet_vnd_get_endpoint(dev);
 	} else {
-		r = rmnet_get_real_dev_info_rtnl(dev);
+		port = rmnet_get_port_rtnl(dev);
 
-		ep = &r->muxed_ep[config_id];
+		ep = &port->muxed_ep[config_id];
 	}
 
 	return ep;
 }
 
 static int rmnet_unregister_real_device(struct net_device *real_dev,
-					struct rmnet_real_dev_info *r)
+					struct rmnet_port *port)
 {
-	if (r->nr_rmnet_devs)
+	if (port->nr_rmnet_devs)
 		return -EINVAL;
 
-	kfree(r);
+	kfree(port);
 
 	netdev_rx_handler_unregister(real_dev);
 
@@ -100,7 +100,7 @@ static int rmnet_unregister_real_device(struct net_device *real_dev,
 
 static int rmnet_register_real_device(struct net_device *real_dev)
 {
-	struct rmnet_real_dev_info *r;
+	struct rmnet_port *port;
 	int rc;
 
 	ASSERT_RTNL();
@@ -108,14 +108,14 @@ static int rmnet_register_real_device(struct net_device *real_dev)
 	if (rmnet_is_real_dev_registered(real_dev))
 		return 0;
 
-	r = kzalloc(sizeof(*r), GFP_ATOMIC);
-	if (!r)
+	port = kzalloc(sizeof(*port), GFP_ATOMIC);
+	if (!port)
 		return -ENOMEM;
 
-	r->dev = real_dev;
-	rc = netdev_rx_handler_register(real_dev, rmnet_rx_handler, r);
+	port->dev = real_dev;
+	rc = netdev_rx_handler_register(real_dev, rmnet_rx_handler, port);
 	if (rc) {
-		kfree(r);
+		kfree(port);
 		return -EBUSY;
 	}
 
@@ -154,9 +154,9 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 			     RMNET_INGRESS_FORMAT_MAP;
 	int egress_format = RMNET_EGRESS_FORMAT_MUXING |
 			    RMNET_EGRESS_FORMAT_MAP;
-	struct rmnet_real_dev_info *r;
 	struct net_device *real_dev;
 	int mode = RMNET_EPMODE_VND;
+	struct rmnet_port *port;
 	int err = 0;
 	u16 mux_id;
 
@@ -173,8 +173,8 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 	if (err)
 		goto err0;
 
-	r = rmnet_get_real_dev_info_rtnl(real_dev);
-	err = rmnet_vnd_newlink(mux_id, dev, r, real_dev);
+	port = rmnet_get_port_rtnl(real_dev);
+	err = rmnet_vnd_newlink(mux_id, dev, port, real_dev);
 	if (err)
 		goto err1;
 
@@ -184,25 +184,25 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 
 	netdev_dbg(dev, "data format [ingress 0x%08X] [egress 0x%08X]\n",
 		   ingress_format, egress_format);
-	r->egress_data_format = egress_format;
-	r->ingress_data_format = ingress_format;
+	port->egress_data_format = egress_format;
+	port->ingress_data_format = ingress_format;
 
 	rmnet_set_endpoint_config(real_dev, mux_id, mode, dev);
 	rmnet_set_endpoint_config(dev, mux_id, mode, real_dev);
 	return 0;
 
 err2:
-	rmnet_vnd_dellink(mux_id, r);
+	rmnet_vnd_dellink(mux_id, port);
 err1:
-	rmnet_unregister_real_device(real_dev, r);
+	rmnet_unregister_real_device(real_dev, port);
 err0:
 	return err;
 }
 
 static void rmnet_dellink(struct net_device *dev, struct list_head *head)
 {
-	struct rmnet_real_dev_info *r;
 	struct net_device *real_dev;
+	struct rmnet_port *port;
 	u8 mux_id;
 
 	rcu_read_lock();
@@ -212,12 +212,12 @@ static void rmnet_dellink(struct net_device *dev, struct list_head *head)
 	if (!real_dev || !rmnet_is_real_dev_registered(real_dev))
 		return;
 
-	r = rmnet_get_real_dev_info_rtnl(real_dev);
+	port = rmnet_get_port_rtnl(real_dev);
 
 	mux_id = rmnet_vnd_get_mux(dev);
-	rmnet_vnd_dellink(mux_id, r);
+	rmnet_vnd_dellink(mux_id, port);
 	netdev_upper_dev_unlink(dev, real_dev);
-	rmnet_unregister_real_device(real_dev, r);
+	rmnet_unregister_real_device(real_dev, port);
 
 	unregister_netdevice_queue(dev, head);
 }
@@ -229,7 +229,7 @@ static int rmnet_dev_walk_unreg(struct net_device *rmnet_dev, void *data)
 
 	mux_id = rmnet_vnd_get_mux(rmnet_dev);
 
-	rmnet_vnd_dellink(mux_id, d->real_dev_info);
+	rmnet_vnd_dellink(mux_id, d->port);
 	netdev_upper_dev_unlink(rmnet_dev, d->real_dev);
 	unregister_netdevice_queue(rmnet_dev, d->head);
 
@@ -239,8 +239,8 @@ static int rmnet_dev_walk_unreg(struct net_device *rmnet_dev, void *data)
 static void rmnet_force_unassociate_device(struct net_device *dev)
 {
 	struct net_device *real_dev = dev;
-	struct rmnet_real_dev_info *r;
 	struct rmnet_walk_data d;
+	struct rmnet_port *port;
 	LIST_HEAD(list);
 
 	if (!rmnet_is_real_dev_registered(real_dev))
@@ -251,15 +251,15 @@ static void rmnet_force_unassociate_device(struct net_device *dev)
 	d.real_dev = real_dev;
 	d.head = &list;
 
-	r = rmnet_get_real_dev_info_rtnl(dev);
-	d.real_dev_info = r;
+	port = rmnet_get_port_rtnl(dev);
+	d.port = port;
 
 	rcu_read_lock();
 	netdev_walk_all_lower_dev_rcu(real_dev, rmnet_dev_walk_unreg, &d);
 	rcu_read_unlock();
 	unregister_netdevice_many(&list);
 
-	rmnet_unregister_real_device(real_dev, r);
+	rmnet_unregister_real_device(real_dev, port);
 }
 
 static int rmnet_config_notify_cb(struct notifier_block *nb,
@@ -319,8 +319,7 @@ struct rtnl_link_ops rmnet_link_ops __read_mostly = {
 };
 
 /* Needs either rcu_read_lock() or rtnl lock */
-struct rmnet_real_dev_info*
-rmnet_get_real_dev_info(struct net_device *real_dev)
+struct rmnet_port *rmnet_get_port(struct net_device *real_dev)
 {
 	if (rmnet_is_real_dev_registered(real_dev))
 		return rcu_dereference_rtnl(real_dev->rx_handler_data);

commit b752eff5be24ec146393944848d2ffbef92b43a7
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Sat Sep 2 23:30:45 2017 -0600

    net: qualcomm: rmnet: Implement ndo_get_iflink
    
    This makes it easier to find out the parent dev.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Cc: Dan Williams <dcbw@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index c0aed7cd0b88..6f21cd018a79 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -174,7 +174,7 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 		goto err0;
 
 	r = rmnet_get_real_dev_info_rtnl(real_dev);
-	err = rmnet_vnd_newlink(mux_id, dev, r);
+	err = rmnet_vnd_newlink(mux_id, dev, r, real_dev);
 	if (err)
 		goto err1;
 

commit 032ee46828e7a2531c77bf80052fa1237820ec9c
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Sat Sep 2 23:30:44 2017 -0600

    net: qualcomm: rmnet: Refactor the new rmnet dev creation
    
    Data format can be directly set from rmnet_newlink() since the
    rmnet real dev info is already available.
    
    Since __rmnet_get_real_dev_info() is no longer used in rmnet_config.c
    after removal of those functions, move content to
    rmnet_get_real_dev_info().
    
    __rmnet_set_endpoint_config() is collapsed into
    rmnet_set_endpoint_config() since only mux_id was being set additionally
    within it. Remove an unnecessary mux_id check.
    
    Set the mux_id for the rmnet_dev within rmnet_vnd_newlink() itself.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Cc: Dan Williams <dcbw@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index 3ca98ecda02b..c0aed7cd0b88 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -57,16 +57,6 @@ static int rmnet_is_real_dev_registered(const struct net_device *real_dev)
 	return (rx_handler == rmnet_rx_handler);
 }
 
-/* Needs either rcu_read_lock() or rtnl lock */
-static struct rmnet_real_dev_info*
-__rmnet_get_real_dev_info(const struct net_device *real_dev)
-{
-	if (rmnet_is_real_dev_registered(real_dev))
-		return rcu_dereference_rtnl(real_dev->rx_handler_data);
-	else
-		return NULL;
-}
-
 /* Needs rtnl lock */
 static struct rmnet_real_dev_info*
 rmnet_get_real_dev_info_rtnl(const struct net_device *real_dev)
@@ -83,10 +73,7 @@ rmnet_get_endpoint(struct net_device *dev, int config_id)
 	if (!rmnet_is_real_dev_registered(dev)) {
 		ep = rmnet_vnd_get_endpoint(dev);
 	} else {
-		r = __rmnet_get_real_dev_info(dev);
-
-		if (!r)
-			return NULL;
+		r = rmnet_get_real_dev_info_rtnl(dev);
 
 		ep = &r->muxed_ep[config_id];
 	}
@@ -139,70 +126,23 @@ static int rmnet_register_real_device(struct net_device *real_dev)
 	return 0;
 }
 
-static int rmnet_set_ingress_data_format(struct net_device *dev, u32 idf)
-{
-	struct rmnet_real_dev_info *r;
-
-	netdev_dbg(dev, "Ingress format 0x%08X\n", idf);
-
-	r = __rmnet_get_real_dev_info(dev);
-
-	r->ingress_data_format = idf;
-
-	return 0;
-}
-
-static int rmnet_set_egress_data_format(struct net_device *dev, u32 edf,
-					u16 agg_size, u16 agg_count)
+static void rmnet_set_endpoint_config(struct net_device *dev,
+				      u8 mux_id, u8 rmnet_mode,
+				      struct net_device *egress_dev)
 {
-	struct rmnet_real_dev_info *r;
-
-	netdev_dbg(dev, "Egress format 0x%08X agg size %d cnt %d\n",
-		   edf, agg_size, agg_count);
-
-	r = __rmnet_get_real_dev_info(dev);
-
-	r->egress_data_format = edf;
-
-	return 0;
-}
-
-static int __rmnet_set_endpoint_config(struct net_device *dev, int config_id,
-				       struct rmnet_endpoint *ep)
-{
-	struct rmnet_endpoint *dev_ep;
-
-	dev_ep = rmnet_get_endpoint(dev, config_id);
-
-	if (!dev_ep)
-		return -EINVAL;
-
-	memcpy(dev_ep, ep, sizeof(struct rmnet_endpoint));
-	dev_ep->mux_id = config_id;
-
-	return 0;
-}
-
-static int rmnet_set_endpoint_config(struct net_device *dev,
-				     int config_id, u8 rmnet_mode,
-				     struct net_device *egress_dev)
-{
-	struct rmnet_endpoint ep;
+	struct rmnet_endpoint *ep;
 
 	netdev_dbg(dev, "id %d mode %d dev %s\n",
-		   config_id, rmnet_mode, egress_dev->name);
-
-	if (config_id >= RMNET_MAX_LOGICAL_EP)
-		return -EINVAL;
+		   mux_id, rmnet_mode, egress_dev->name);
 
+	ep = rmnet_get_endpoint(dev, mux_id);
 	/* This config is cleared on every set, so its ok to not
 	 * clear it on a device delete.
 	 */
-	memset(&ep, 0, sizeof(struct rmnet_endpoint));
-	ep.rmnet_mode = rmnet_mode;
-	ep.egress_dev = egress_dev;
-
-	return __rmnet_set_endpoint_config(dev, config_id, &ep);
+	memset(ep, 0, sizeof(struct rmnet_endpoint));
+	ep->rmnet_mode = rmnet_mode;
+	ep->egress_dev = egress_dev;
+	ep->mux_id = mux_id;
 }
 
 static int rmnet_newlink(struct net *src_net, struct net_device *dev,
@@ -242,9 +182,11 @@ static int rmnet_newlink(struct net *src_net, struct net_device *dev,
 	if (err)
 		goto err2;
 
-	rmnet_vnd_set_mux(dev, mux_id);
-	rmnet_set_egress_data_format(real_dev, egress_format, 0, 0);
-	rmnet_set_ingress_data_format(real_dev, ingress_format);
+	netdev_dbg(dev, "data format [ingress 0x%08X] [egress 0x%08X]\n",
+		   ingress_format, egress_format);
+	r->egress_data_format = egress_format;
+	r->ingress_data_format = ingress_format;
+
 	rmnet_set_endpoint_config(real_dev, mux_id, mode, dev);
 	rmnet_set_endpoint_config(dev, mux_id, mode, real_dev);
 	return 0;
@@ -376,10 +318,14 @@ struct rtnl_link_ops rmnet_link_ops __read_mostly = {
 	.get_size	= rmnet_get_size,
 };
 
+/* Needs either rcu_read_lock() or rtnl lock */
 struct rmnet_real_dev_info*
 rmnet_get_real_dev_info(struct net_device *real_dev)
 {
-	return __rmnet_get_real_dev_info(real_dev);
+	if (rmnet_is_real_dev_registered(real_dev))
+		return rcu_dereference_rtnl(real_dev->rx_handler_data);
+	else
+		return NULL;
 }
 
 /* Startup/Shutdown */

commit 61bf5490ec47f61b522ecf24958c835aefa38812
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Sat Sep 2 23:30:42 2017 -0600

    net: qualcomm: rmnet: Remove the unused endpoint -1
    
    This was used only in the original patch series where the IOCTLs were
    present and is no longer in use.
    
    Fixes: ceed73a2cf4a ("drivers: net: ethernet: qualcomm: rmnet: Initial implementation")
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Cc: Dan Williams <dcbw@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index e836d267d5cc..3ca98ecda02b 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -42,7 +42,6 @@
  */
 
 /* Local Definitions and Declarations */
-#define RMNET_LOCAL_LOGICAL_ENDPOINT -1
 
 struct rmnet_walk_data {
 	struct net_device *real_dev;
@@ -89,10 +88,7 @@ rmnet_get_endpoint(struct net_device *dev, int config_id)
 		if (!r)
 			return NULL;
 
-		if (config_id == RMNET_LOCAL_LOGICAL_ENDPOINT)
-			ep = &r->local_ep;
-		else
-			ep = &r->muxed_ep[config_id];
+		ep = &r->muxed_ep[config_id];
 	}
 
 	return ep;
@@ -182,10 +178,7 @@ static int __rmnet_set_endpoint_config(struct net_device *dev, int config_id,
 		return -EINVAL;
 
 	memcpy(dev_ep, ep, sizeof(struct rmnet_endpoint));
-	if (config_id == RMNET_LOCAL_LOGICAL_ENDPOINT)
-		dev_ep->mux_id = 0;
-	else
-		dev_ep->mux_id = config_id;
+	dev_ep->mux_id = config_id;
 
 	return 0;
 }
@@ -199,8 +192,7 @@ static int rmnet_set_endpoint_config(struct net_device *dev,
 	netdev_dbg(dev, "id %d mode %d dev %s\n",
 		   config_id, rmnet_mode, egress_dev->name);
 
-	if (config_id < RMNET_LOCAL_LOGICAL_ENDPOINT ||
-	    config_id >= RMNET_MAX_LOGICAL_EP)
+	if (config_id >= RMNET_MAX_LOGICAL_EP)
 		return -EINVAL;
 
 	/* This config is cleared on every set, so its ok to not

commit ceed73a2cf4aff2921802aa3d21d45280677547d
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Tue Aug 29 22:44:18 2017 -0600

    drivers: net: ethernet: qualcomm: rmnet: Initial implementation
    
    RmNet driver provides a transport agnostic MAP (multiplexing and
    aggregation protocol) support in embedded module. Module provides
    virtual network devices which can be attached to any IP-mode
    physical device. This will be used to provide all MAP functionality
    on future hardware in a single consistent location.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
new file mode 100644
index 000000000000..e836d267d5cc
--- /dev/null
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -0,0 +1,419 @@
+/* Copyright (c) 2013-2017, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * RMNET configuration engine
+ *
+ */
+
+#include <net/sock.h>
+#include <linux/module.h>
+#include <linux/netlink.h>
+#include <linux/netdevice.h>
+#include "rmnet_config.h"
+#include "rmnet_handlers.h"
+#include "rmnet_vnd.h"
+#include "rmnet_private.h"
+
+/* Locking scheme -
+ * The shared resource which needs to be protected is realdev->rx_handler_data.
+ * For the writer path, this is using rtnl_lock(). The writer paths are
+ * rmnet_newlink(), rmnet_dellink() and rmnet_force_unassociate_device(). These
+ * paths are already called with rtnl_lock() acquired in. There is also an
+ * ASSERT_RTNL() to ensure that we are calling with rtnl acquired. For
+ * dereference here, we will need to use rtnl_dereference(). Dev list writing
+ * needs to happen with rtnl_lock() acquired for netdev_master_upper_dev_link().
+ * For the reader path, the real_dev->rx_handler_data is called in the TX / RX
+ * path. We only need rcu_read_lock() for these scenarios. In these cases,
+ * the rcu_read_lock() is held in __dev_queue_xmit() and
+ * netif_receive_skb_internal(), so readers need to use rcu_dereference_rtnl()
+ * to get the relevant information. For dev list reading, we again acquire
+ * rcu_read_lock() in rmnet_dellink() for netdev_master_upper_dev_get_rcu().
+ * We also use unregister_netdevice_many() to free all rmnet devices in
+ * rmnet_force_unassociate_device() so we dont lose the rtnl_lock() and free in
+ * same context.
+ */
+
+/* Local Definitions and Declarations */
+#define RMNET_LOCAL_LOGICAL_ENDPOINT -1
+
+struct rmnet_walk_data {
+	struct net_device *real_dev;
+	struct list_head *head;
+	struct rmnet_real_dev_info *real_dev_info;
+};
+
+static int rmnet_is_real_dev_registered(const struct net_device *real_dev)
+{
+	rx_handler_func_t *rx_handler;
+
+	rx_handler = rcu_dereference(real_dev->rx_handler);
+	return (rx_handler == rmnet_rx_handler);
+}
+
+/* Needs either rcu_read_lock() or rtnl lock */
+static struct rmnet_real_dev_info*
+__rmnet_get_real_dev_info(const struct net_device *real_dev)
+{
+	if (rmnet_is_real_dev_registered(real_dev))
+		return rcu_dereference_rtnl(real_dev->rx_handler_data);
+	else
+		return NULL;
+}
+
+/* Needs rtnl lock */
+static struct rmnet_real_dev_info*
+rmnet_get_real_dev_info_rtnl(const struct net_device *real_dev)
+{
+	return rtnl_dereference(real_dev->rx_handler_data);
+}
+
+static struct rmnet_endpoint*
+rmnet_get_endpoint(struct net_device *dev, int config_id)
+{
+	struct rmnet_real_dev_info *r;
+	struct rmnet_endpoint *ep;
+
+	if (!rmnet_is_real_dev_registered(dev)) {
+		ep = rmnet_vnd_get_endpoint(dev);
+	} else {
+		r = __rmnet_get_real_dev_info(dev);
+
+		if (!r)
+			return NULL;
+
+		if (config_id == RMNET_LOCAL_LOGICAL_ENDPOINT)
+			ep = &r->local_ep;
+		else
+			ep = &r->muxed_ep[config_id];
+	}
+
+	return ep;
+}
+
+static int rmnet_unregister_real_device(struct net_device *real_dev,
+					struct rmnet_real_dev_info *r)
+{
+	if (r->nr_rmnet_devs)
+		return -EINVAL;
+
+	kfree(r);
+
+	netdev_rx_handler_unregister(real_dev);
+
+	/* release reference on real_dev */
+	dev_put(real_dev);
+
+	netdev_dbg(real_dev, "Removed from rmnet\n");
+	return 0;
+}
+
+static int rmnet_register_real_device(struct net_device *real_dev)
+{
+	struct rmnet_real_dev_info *r;
+	int rc;
+
+	ASSERT_RTNL();
+
+	if (rmnet_is_real_dev_registered(real_dev))
+		return 0;
+
+	r = kzalloc(sizeof(*r), GFP_ATOMIC);
+	if (!r)
+		return -ENOMEM;
+
+	r->dev = real_dev;
+	rc = netdev_rx_handler_register(real_dev, rmnet_rx_handler, r);
+	if (rc) {
+		kfree(r);
+		return -EBUSY;
+	}
+
+	/* hold on to real dev for MAP data */
+	dev_hold(real_dev);
+
+	netdev_dbg(real_dev, "registered with rmnet\n");
+	return 0;
+}
+
+static int rmnet_set_ingress_data_format(struct net_device *dev, u32 idf)
+{
+	struct rmnet_real_dev_info *r;
+
+	netdev_dbg(dev, "Ingress format 0x%08X\n", idf);
+
+	r = __rmnet_get_real_dev_info(dev);
+
+	r->ingress_data_format = idf;
+
+	return 0;
+}
+
+static int rmnet_set_egress_data_format(struct net_device *dev, u32 edf,
+					u16 agg_size, u16 agg_count)
+{
+	struct rmnet_real_dev_info *r;
+
+	netdev_dbg(dev, "Egress format 0x%08X agg size %d cnt %d\n",
+		   edf, agg_size, agg_count);
+
+	r = __rmnet_get_real_dev_info(dev);
+
+	r->egress_data_format = edf;
+
+	return 0;
+}
+
+static int __rmnet_set_endpoint_config(struct net_device *dev, int config_id,
+				       struct rmnet_endpoint *ep)
+{
+	struct rmnet_endpoint *dev_ep;
+
+	dev_ep = rmnet_get_endpoint(dev, config_id);
+
+	if (!dev_ep)
+		return -EINVAL;
+
+	memcpy(dev_ep, ep, sizeof(struct rmnet_endpoint));
+	if (config_id == RMNET_LOCAL_LOGICAL_ENDPOINT)
+		dev_ep->mux_id = 0;
+	else
+		dev_ep->mux_id = config_id;
+
+	return 0;
+}
+
+static int rmnet_set_endpoint_config(struct net_device *dev,
+				     int config_id, u8 rmnet_mode,
+				     struct net_device *egress_dev)
+{
+	struct rmnet_endpoint ep;
+
+	netdev_dbg(dev, "id %d mode %d dev %s\n",
+		   config_id, rmnet_mode, egress_dev->name);
+
+	if (config_id < RMNET_LOCAL_LOGICAL_ENDPOINT ||
+	    config_id >= RMNET_MAX_LOGICAL_EP)
+		return -EINVAL;
+
+	/* This config is cleared on every set, so its ok to not
+	 * clear it on a device delete.
+	 */
+	memset(&ep, 0, sizeof(struct rmnet_endpoint));
+	ep.rmnet_mode = rmnet_mode;
+	ep.egress_dev = egress_dev;
+
+	return __rmnet_set_endpoint_config(dev, config_id, &ep);
+}
+
+static int rmnet_newlink(struct net *src_net, struct net_device *dev,
+			 struct nlattr *tb[], struct nlattr *data[],
+			 struct netlink_ext_ack *extack)
+{
+	int ingress_format = RMNET_INGRESS_FORMAT_DEMUXING |
+			     RMNET_INGRESS_FORMAT_DEAGGREGATION |
+			     RMNET_INGRESS_FORMAT_MAP;
+	int egress_format = RMNET_EGRESS_FORMAT_MUXING |
+			    RMNET_EGRESS_FORMAT_MAP;
+	struct rmnet_real_dev_info *r;
+	struct net_device *real_dev;
+	int mode = RMNET_EPMODE_VND;
+	int err = 0;
+	u16 mux_id;
+
+	real_dev = __dev_get_by_index(src_net, nla_get_u32(tb[IFLA_LINK]));
+	if (!real_dev || !dev)
+		return -ENODEV;
+
+	if (!data[IFLA_VLAN_ID])
+		return -EINVAL;
+
+	mux_id = nla_get_u16(data[IFLA_VLAN_ID]);
+
+	err = rmnet_register_real_device(real_dev);
+	if (err)
+		goto err0;
+
+	r = rmnet_get_real_dev_info_rtnl(real_dev);
+	err = rmnet_vnd_newlink(mux_id, dev, r);
+	if (err)
+		goto err1;
+
+	err = netdev_master_upper_dev_link(dev, real_dev, NULL, NULL);
+	if (err)
+		goto err2;
+
+	rmnet_vnd_set_mux(dev, mux_id);
+	rmnet_set_egress_data_format(real_dev, egress_format, 0, 0);
+	rmnet_set_ingress_data_format(real_dev, ingress_format);
+	rmnet_set_endpoint_config(real_dev, mux_id, mode, dev);
+	rmnet_set_endpoint_config(dev, mux_id, mode, real_dev);
+	return 0;
+
+err2:
+	rmnet_vnd_dellink(mux_id, r);
+err1:
+	rmnet_unregister_real_device(real_dev, r);
+err0:
+	return err;
+}
+
+static void rmnet_dellink(struct net_device *dev, struct list_head *head)
+{
+	struct rmnet_real_dev_info *r;
+	struct net_device *real_dev;
+	u8 mux_id;
+
+	rcu_read_lock();
+	real_dev = netdev_master_upper_dev_get_rcu(dev);
+	rcu_read_unlock();
+
+	if (!real_dev || !rmnet_is_real_dev_registered(real_dev))
+		return;
+
+	r = rmnet_get_real_dev_info_rtnl(real_dev);
+
+	mux_id = rmnet_vnd_get_mux(dev);
+	rmnet_vnd_dellink(mux_id, r);
+	netdev_upper_dev_unlink(dev, real_dev);
+	rmnet_unregister_real_device(real_dev, r);
+
+	unregister_netdevice_queue(dev, head);
+}
+
+static int rmnet_dev_walk_unreg(struct net_device *rmnet_dev, void *data)
+{
+	struct rmnet_walk_data *d = data;
+	u8 mux_id;
+
+	mux_id = rmnet_vnd_get_mux(rmnet_dev);
+
+	rmnet_vnd_dellink(mux_id, d->real_dev_info);
+	netdev_upper_dev_unlink(rmnet_dev, d->real_dev);
+	unregister_netdevice_queue(rmnet_dev, d->head);
+
+	return 0;
+}
+
+static void rmnet_force_unassociate_device(struct net_device *dev)
+{
+	struct net_device *real_dev = dev;
+	struct rmnet_real_dev_info *r;
+	struct rmnet_walk_data d;
+	LIST_HEAD(list);
+
+	if (!rmnet_is_real_dev_registered(real_dev))
+		return;
+
+	ASSERT_RTNL();
+
+	d.real_dev = real_dev;
+	d.head = &list;
+
+	r = rmnet_get_real_dev_info_rtnl(dev);
+	d.real_dev_info = r;
+
+	rcu_read_lock();
+	netdev_walk_all_lower_dev_rcu(real_dev, rmnet_dev_walk_unreg, &d);
+	rcu_read_unlock();
+	unregister_netdevice_many(&list);
+
+	rmnet_unregister_real_device(real_dev, r);
+}
+
+static int rmnet_config_notify_cb(struct notifier_block *nb,
+				  unsigned long event, void *data)
+{
+	struct net_device *dev = netdev_notifier_info_to_dev(data);
+
+	if (!dev)
+		return NOTIFY_DONE;
+
+	switch (event) {
+	case NETDEV_UNREGISTER:
+		netdev_dbg(dev, "Kernel unregister\n");
+		rmnet_force_unassociate_device(dev);
+		break;
+
+	default:
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block rmnet_dev_notifier __read_mostly = {
+	.notifier_call = rmnet_config_notify_cb,
+};
+
+static int rmnet_rtnl_validate(struct nlattr *tb[], struct nlattr *data[],
+			       struct netlink_ext_ack *extack)
+{
+	u16 mux_id;
+
+	if (!data || !data[IFLA_VLAN_ID])
+		return -EINVAL;
+
+	mux_id = nla_get_u16(data[IFLA_VLAN_ID]);
+	if (mux_id > (RMNET_MAX_LOGICAL_EP - 1))
+		return -ERANGE;
+
+	return 0;
+}
+
+static size_t rmnet_get_size(const struct net_device *dev)
+{
+	return nla_total_size(2); /* IFLA_VLAN_ID */
+}
+
+struct rtnl_link_ops rmnet_link_ops __read_mostly = {
+	.kind		= "rmnet",
+	.maxtype	= __IFLA_VLAN_MAX,
+	.priv_size	= sizeof(struct rmnet_priv),
+	.setup		= rmnet_vnd_setup,
+	.validate	= rmnet_rtnl_validate,
+	.newlink	= rmnet_newlink,
+	.dellink	= rmnet_dellink,
+	.get_size	= rmnet_get_size,
+};
+
+struct rmnet_real_dev_info*
+rmnet_get_real_dev_info(struct net_device *real_dev)
+{
+	return __rmnet_get_real_dev_info(real_dev);
+}
+
+/* Startup/Shutdown */
+
+static int __init rmnet_init(void)
+{
+	int rc;
+
+	rc = register_netdevice_notifier(&rmnet_dev_notifier);
+	if (rc != 0)
+		return rc;
+
+	rc = rtnl_link_register(&rmnet_link_ops);
+	if (rc != 0) {
+		unregister_netdevice_notifier(&rmnet_dev_notifier);
+		return rc;
+	}
+	return rc;
+}
+
+static void __exit rmnet_exit(void)
+{
+	unregister_netdevice_notifier(&rmnet_dev_notifier);
+	rtnl_link_unregister(&rmnet_link_ops);
+}
+
+module_init(rmnet_init)
+module_exit(rmnet_exit)
+MODULE_LICENSE("GPL v2");
