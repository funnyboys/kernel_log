commit ad3cc31b599ea80f06b29ebdc18b3a39878a48d6
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Thu Feb 27 12:26:15 2020 +0000

    net: rmnet: fix packet forwarding in rmnet bridge mode
    
    Packet forwarding is not working in rmnet bridge mode.
    Because when a packet is forwarded, skb_push() for an ethernet header
    is needed. But it doesn't call skb_push().
    So, the ethernet header will be lost.
    
    Test commands:
        modprobe rmnet
        ip netns add nst
        ip netns add nst2
        ip link add veth0 type veth peer name veth1
        ip link add veth2 type veth peer name veth3
        ip link set veth1 netns nst
        ip link set veth3 netns nst2
    
        ip link add rmnet0 link veth0 type rmnet mux_id 1
        ip link set veth2 master rmnet0
        ip link set veth0 up
        ip link set veth2 up
        ip link set rmnet0 up
        ip a a 192.168.100.1/24 dev rmnet0
    
        ip netns exec nst ip link set veth1 up
        ip netns exec nst ip a a 192.168.100.2/24 dev veth1
        ip netns exec nst2 ip link set veth3 up
        ip netns exec nst2 ip a a 192.168.100.3/24 dev veth3
        ip netns exec nst2 ping 192.168.100.2
    
    Fixes: 60d58f971c10 ("net: qualcomm: rmnet: Implement bridge mode")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index 074a8b326c30..29a7bfa2584d 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -159,6 +159,9 @@ static int rmnet_map_egress_handler(struct sk_buff *skb,
 static void
 rmnet_bridge_handler(struct sk_buff *skb, struct net_device *bridge_dev)
 {
+	if (skb_mac_header_was_set(skb))
+		skb_push(skb, skb->mac_len);
+
 	if (bridge_dev) {
 		skb->dev = bridge_dev;
 		dev_queue_xmit(skb);

commit 102210f7664442d8c0ce332c006ea90626df745b
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Thu Feb 27 12:24:45 2020 +0000

    net: rmnet: fix suspicious RCU usage
    
    rmnet_get_port() internally calls rcu_dereference_rtnl(),
    which checks RTNL.
    But rmnet_get_port() could be called by packet path.
    The packet path is not protected by RTNL.
    So, the suspicious RCU usage problem occurs.
    
    Test commands:
        modprobe rmnet
        ip netns add nst
        ip link add veth0 type veth peer name veth1
        ip link set veth1 netns nst
        ip link add rmnet0 link veth0 type rmnet mux_id 1
        ip netns exec nst ip link add rmnet1 link veth1 type rmnet mux_id 1
        ip netns exec nst ip link set veth1 up
        ip netns exec nst ip link set rmnet1 up
        ip netns exec nst ip a a 192.168.100.2/24 dev rmnet1
        ip link set veth0 up
        ip link set rmnet0 up
        ip a a 192.168.100.1/24 dev rmnet0
        ping 192.168.100.2
    
    Splat looks like:
    [  146.630958][ T1174] WARNING: suspicious RCU usage
    [  146.631735][ T1174] 5.6.0-rc1+ #447 Not tainted
    [  146.632387][ T1174] -----------------------------
    [  146.633151][ T1174] drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c:386 suspicious rcu_dereference_check() !
    [  146.634742][ T1174]
    [  146.634742][ T1174] other info that might help us debug this:
    [  146.634742][ T1174]
    [  146.645992][ T1174]
    [  146.645992][ T1174] rcu_scheduler_active = 2, debug_locks = 1
    [  146.646937][ T1174] 5 locks held by ping/1174:
    [  146.647609][ T1174]  #0: ffff8880c31dea70 (sk_lock-AF_INET){+.+.}, at: raw_sendmsg+0xab8/0x2980
    [  146.662463][ T1174]  #1: ffffffff93925660 (rcu_read_lock_bh){....}, at: ip_finish_output2+0x243/0x2150
    [  146.671696][ T1174]  #2: ffffffff93925660 (rcu_read_lock_bh){....}, at: __dev_queue_xmit+0x213/0x2940
    [  146.673064][ T1174]  #3: ffff8880c19ecd58 (&dev->qdisc_running_key#7){+...}, at: ip_finish_output2+0x714/0x2150
    [  146.690358][ T1174]  #4: ffff8880c5796898 (&dev->qdisc_xmit_lock_key#3){+.-.}, at: sch_direct_xmit+0x1e2/0x1020
    [  146.699875][ T1174]
    [  146.699875][ T1174] stack backtrace:
    [  146.701091][ T1174] CPU: 0 PID: 1174 Comm: ping Not tainted 5.6.0-rc1+ #447
    [  146.705215][ T1174] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [  146.706565][ T1174] Call Trace:
    [  146.707102][ T1174]  dump_stack+0x96/0xdb
    [  146.708007][ T1174]  rmnet_get_port.part.9+0x76/0x80 [rmnet]
    [  146.709233][ T1174]  rmnet_egress_handler+0x107/0x420 [rmnet]
    [  146.710492][ T1174]  ? sch_direct_xmit+0x1e2/0x1020
    [  146.716193][ T1174]  rmnet_vnd_start_xmit+0x3d/0xa0 [rmnet]
    [  146.717012][ T1174]  dev_hard_start_xmit+0x160/0x740
    [  146.717854][ T1174]  sch_direct_xmit+0x265/0x1020
    [  146.718577][ T1174]  ? register_lock_class+0x14d0/0x14d0
    [  146.719429][ T1174]  ? dev_watchdog+0xac0/0xac0
    [  146.723738][ T1174]  ? __dev_queue_xmit+0x15fd/0x2940
    [  146.724469][ T1174]  ? lock_acquire+0x164/0x3b0
    [  146.725172][ T1174]  __dev_queue_xmit+0x20c7/0x2940
    [ ... ]
    
    Fixes: ceed73a2cf4a ("drivers: net: ethernet: qualcomm: rmnet: Initial implementation")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index 1b74bc160402..074a8b326c30 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -184,7 +184,7 @@ rx_handler_result_t rmnet_rx_handler(struct sk_buff **pskb)
 		return RX_HANDLER_PASS;
 
 	dev = skb->dev;
-	port = rmnet_get_port(dev);
+	port = rmnet_get_port_rcu(dev);
 
 	switch (port->rmnet_mode) {
 	case RMNET_EPMODE_VND:
@@ -217,7 +217,7 @@ void rmnet_egress_handler(struct sk_buff *skb)
 	skb->dev = priv->real_dev;
 	mux_id = priv->mux_id;
 
-	port = rmnet_get_port(skb->dev);
+	port = rmnet_get_port_rcu(skb->dev);
 	if (!port)
 		goto drop;
 

commit 97fb5e8d9b57f10f294303c9a5d1bd033eded6bf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:17:58 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 284
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 and
      only version 2 as published by the free software foundation this
      program is distributed in the hope that it will be useful but
      without any warranty without even the implied warranty of
      merchantability or fitness for a particular purpose see the gnu
      general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 294 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141900.825281744@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index 11167abe5934..1b74bc160402 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -1,16 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /* Copyright (c) 2013-2018, The Linux Foundation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  *
  * RMNET Data ingress/egress handler
- *
  */
 
 #include <linux/netdevice.h>

commit ec405641e2b73160e26ef17580d0cf28565d146c
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Tue Oct 2 18:52:03 2018 -0600

    net: qualcomm: rmnet: Fix incorrect allocation flag in receive path
    
    The incoming skb needs to be reallocated in case the headroom
    is not sufficient to adjust the ethernet header. This allocation
    needs to be atomic otherwise it results in this splat
    
     [<600601bb>] ___might_sleep+0x185/0x1a3
     [<603f6314>] ? _raw_spin_unlock_irqrestore+0x0/0x27
     [<60069bb0>] ? __wake_up_common_lock+0x95/0xd1
     [<600602b0>] __might_sleep+0xd7/0xe2
     [<60065598>] ? enqueue_task_fair+0x112/0x209
     [<600eea13>] __kmalloc_track_caller+0x5d/0x124
     [<600ee9b6>] ? __kmalloc_track_caller+0x0/0x124
     [<602696d5>] __kmalloc_reserve.isra.34+0x30/0x7e
     [<603f629b>] ? _raw_spin_lock_irqsave+0x0/0x3d
     [<6026b744>] pskb_expand_head+0xbf/0x310
     [<6025ca6a>] rmnet_rx_handler+0x7e/0x16b
     [<6025c9ec>] ? rmnet_rx_handler+0x0/0x16b
     [<6027ad0c>] __netif_receive_skb_core+0x301/0x96f
     [<60033c17>] ? set_signals+0x0/0x40
     [<6027bbcb>] __netif_receive_skb+0x24/0x8e
    
    Fixes: 74692caf1b0b ("net: qualcomm: rmnet: Process packets over ethernet")
    Signed-off-by: Sean Tranchetti <stranche@codeaurora.org>
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index 1f98d65473cf..11167abe5934 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -113,7 +113,7 @@ rmnet_map_ingress_handler(struct sk_buff *skb,
 	struct sk_buff *skbn;
 
 	if (skb->dev->type == ARPHRD_ETHER) {
-		if (pskb_expand_head(skb, ETH_HLEN, 0, GFP_KERNEL)) {
+		if (pskb_expand_head(skb, ETH_HLEN, 0, GFP_ATOMIC)) {
 			kfree_skb(skb);
 			return;
 		}

commit 6392ff3c8e4c23d0a09b0ae9f94feb3effed490b
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Tue Oct 2 18:52:02 2018 -0600

    net: qualcomm: rmnet: Fix incorrect allocation flag in transmit
    
    The incoming skb needs to be reallocated in case the headroom
    is not sufficient to add the MAP header. This allocation needs to
    be atomic otherwise it results in the following splat
    
    [32805.801456] BUG: sleeping function called from invalid context
    [32805.841141] Internal error: Oops - BUG: 0 [#1] PREEMPT SMP
    [32805.904773] task: ffffffd7c5f62280 task.stack: ffffff80464a8000
    [32805.910851] pc : ___might_sleep+0x180/0x188
    [32805.915143] lr : ___might_sleep+0x180/0x188
    [32806.131520] Call trace:
    [32806.134041]  ___might_sleep+0x180/0x188
    [32806.137980]  __might_sleep+0x50/0x84
    [32806.141653]  __kmalloc_track_caller+0x80/0x3bc
    [32806.146215]  __kmalloc_reserve+0x3c/0x88
    [32806.150241]  pskb_expand_head+0x74/0x288
    [32806.154269]  rmnet_egress_handler+0xb0/0x1d8
    [32806.162239]  rmnet_vnd_start_xmit+0xc8/0x13c
    [32806.166627]  dev_hard_start_xmit+0x148/0x280
    [32806.181181]  sch_direct_xmit+0xa4/0x198
    [32806.185125]  __qdisc_run+0x1f8/0x310
    [32806.188803]  net_tx_action+0x23c/0x26c
    [32806.192655]  __do_softirq+0x220/0x408
    [32806.196420]  do_softirq+0x4c/0x70
    
    Fixes: ceed73a2cf4a ("drivers: net: ethernet: qualcomm: rmnet: Initial implementation")
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index 6908b26feb9e..1f98d65473cf 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -147,7 +147,7 @@ static int rmnet_map_egress_handler(struct sk_buff *skb,
 	}
 
 	if (skb_headroom(skb) < required_headroom) {
-		if (pskb_expand_head(skb, required_headroom, 0, GFP_KERNEL))
+		if (pskb_expand_head(skb, required_headroom, 0, GFP_ATOMIC))
 			return -ENOMEM;
 	}
 

commit a07f388e2cde2be74b263f85df6f672fea0305a1
Author: Sean Tranchetti <stranche@codeaurora.org>
Date:   Tue Oct 2 18:52:01 2018 -0600

    net: qualcomm: rmnet: Skip processing loopback packets
    
    RMNET RX handler was processing invalid packets that were
    originally sent on the real device and were looped back via
    dev_loopback_xmit(). This was detected using syzkaller.
    
    Fixes: ceed73a2cf4a ("drivers: net: ethernet: qualcomm: rmnet: Initial implementation")
    Signed-off-by: Sean Tranchetti <stranche@codeaurora.org>
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index 7fd86d40a337..6908b26feb9e 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -189,6 +189,9 @@ rx_handler_result_t rmnet_rx_handler(struct sk_buff **pskb)
 	if (!skb)
 		goto done;
 
+	if (skb->pkt_type == PACKET_LOOPBACK)
+		return RX_HANDLER_PASS;
+
 	dev = skb->dev;
 	port = rmnet_get_port(dev);
 

commit 1eece799d3f611a28a25319aabbccd4ac948098f
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Tue May 15 18:52:00 2018 -0600

    net: qualcomm: rmnet: Capture all drops in transmit path
    
    Packets in transmit path could potentially be dropped if there were
    errors while adding the MAP header or the checksum header.
    Increment the tx_drops stats in these cases.
    
    Additionally, refactor the code to free the packet and increment
    the tx_drops stat under a single label.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index 6fcd586e9804..7fd86d40a337 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -148,7 +148,7 @@ static int rmnet_map_egress_handler(struct sk_buff *skb,
 
 	if (skb_headroom(skb) < required_headroom) {
 		if (pskb_expand_head(skb, required_headroom, 0, GFP_KERNEL))
-			goto fail;
+			return -ENOMEM;
 	}
 
 	if (port->data_format & RMNET_FLAGS_EGRESS_MAP_CKSUMV4)
@@ -156,17 +156,13 @@ static int rmnet_map_egress_handler(struct sk_buff *skb,
 
 	map_header = rmnet_map_add_map_header(skb, additional_header_len, 0);
 	if (!map_header)
-		goto fail;
+		return -ENOMEM;
 
 	map_header->mux_id = mux_id;
 
 	skb->protocol = htons(ETH_P_MAP);
 
 	return 0;
-
-fail:
-	kfree_skb(skb);
-	return -ENOMEM;
 }
 
 static void
@@ -228,15 +224,18 @@ void rmnet_egress_handler(struct sk_buff *skb)
 	mux_id = priv->mux_id;
 
 	port = rmnet_get_port(skb->dev);
-	if (!port) {
-		kfree_skb(skb);
-		return;
-	}
+	if (!port)
+		goto drop;
 
 	if (rmnet_map_egress_handler(skb, port, mux_id, orig_dev))
-		return;
+		goto drop;
 
 	rmnet_vnd_tx_fixup(skb, orig_dev);
 
 	dev_queue_xmit(skb);
+	return;
+
+drop:
+	this_cpu_inc(priv->pcpu_stats->stats.tx_drops);
+	kfree_skb(skb);
 }

commit 14452ca3b5ce304fb2fea96dbc9ca1e4e7978551
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Wed Mar 21 19:48:14 2018 -0600

    net: qualcomm: rmnet: Export mux_id and flags to netlink
    
    Define new netlink attributes for rmnet mux_id and flags. These
    flags / mux_id were earlier using vlan flags / id respectively.
    The flag bits are also moved to uapi and are renamed with
    prefix RMNET_FLAG_*.
    
    Also add the rmnet policy to handle the new netlink attributes.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index c758248bf2cd..6fcd586e9804 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -70,7 +70,7 @@ __rmnet_map_ingress_handler(struct sk_buff *skb,
 	u8 mux_id;
 
 	if (RMNET_MAP_GET_CD_BIT(skb)) {
-		if (port->data_format & RMNET_INGRESS_FORMAT_MAP_COMMANDS)
+		if (port->data_format & RMNET_FLAGS_INGRESS_MAP_COMMANDS)
 			return rmnet_map_command(skb, port);
 
 		goto free_skb;
@@ -93,7 +93,7 @@ __rmnet_map_ingress_handler(struct sk_buff *skb,
 	skb_pull(skb, sizeof(struct rmnet_map_header));
 	rmnet_set_skb_proto(skb);
 
-	if (port->data_format & RMNET_INGRESS_FORMAT_MAP_CKSUMV4) {
+	if (port->data_format & RMNET_FLAGS_INGRESS_MAP_CKSUMV4) {
 		if (!rmnet_map_checksum_downlink_packet(skb, len + pad))
 			skb->ip_summed = CHECKSUM_UNNECESSARY;
 	}
@@ -121,7 +121,7 @@ rmnet_map_ingress_handler(struct sk_buff *skb,
 		skb_push(skb, ETH_HLEN);
 	}
 
-	if (port->data_format & RMNET_INGRESS_FORMAT_DEAGGREGATION) {
+	if (port->data_format & RMNET_FLAGS_INGRESS_DEAGGREGATION) {
 		while ((skbn = rmnet_map_deaggregate(skb, port)) != NULL)
 			__rmnet_map_ingress_handler(skbn, port);
 
@@ -141,7 +141,7 @@ static int rmnet_map_egress_handler(struct sk_buff *skb,
 	additional_header_len = 0;
 	required_headroom = sizeof(struct rmnet_map_header);
 
-	if (port->data_format & RMNET_EGRESS_FORMAT_MAP_CKSUMV4) {
+	if (port->data_format & RMNET_FLAGS_EGRESS_MAP_CKSUMV4) {
 		additional_header_len = sizeof(struct rmnet_map_ul_csum_header);
 		required_headroom += additional_header_len;
 	}
@@ -151,7 +151,7 @@ static int rmnet_map_egress_handler(struct sk_buff *skb,
 			goto fail;
 	}
 
-	if (port->data_format & RMNET_EGRESS_FORMAT_MAP_CKSUMV4)
+	if (port->data_format & RMNET_FLAGS_EGRESS_MAP_CKSUMV4)
 		rmnet_map_checksum_uplink_packet(skb, orig_dev);
 
 	map_header = rmnet_map_add_map_header(skb, additional_header_len, 0);

commit 9dcaec042600dce169ae74527e5eead349f8eb90
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Wed Mar 21 19:48:12 2018 -0600

    net: qualcomm: rmnet: Update copyright year to 2018
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index 601edec28c5f..c758248bf2cd 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2013-2017, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2013-2018, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and

commit 5eb5f8608ef118c2cfefc10c8dbbb89b14fac506
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Sun Jan 7 11:36:39 2018 -0700

    net: qualcomm: rmnet: Add support for TX checksum offload
    
    TX checksum offload applies to TCP / UDP packets which are not
    fragmented using the MAPv4 checksum trailer. The following needs to be
    done to have checksum computed in hardware -
    
    1. Set the checksum start offset and inset offset.
    2. Set the csum_enabled bit
    3. Compute and set 1's complement of partial checksum field in
       transport header.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index 340945857d23..601edec28c5f 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -141,11 +141,19 @@ static int rmnet_map_egress_handler(struct sk_buff *skb,
 	additional_header_len = 0;
 	required_headroom = sizeof(struct rmnet_map_header);
 
+	if (port->data_format & RMNET_EGRESS_FORMAT_MAP_CKSUMV4) {
+		additional_header_len = sizeof(struct rmnet_map_ul_csum_header);
+		required_headroom += additional_header_len;
+	}
+
 	if (skb_headroom(skb) < required_headroom) {
 		if (pskb_expand_head(skb, required_headroom, 0, GFP_KERNEL))
 			goto fail;
 	}
 
+	if (port->data_format & RMNET_EGRESS_FORMAT_MAP_CKSUMV4)
+		rmnet_map_checksum_uplink_packet(skb, orig_dev);
+
 	map_header = rmnet_map_add_map_header(skb, additional_header_len, 0);
 	if (!map_header)
 		goto fail;

commit bbd21b247cb596a426a1df0ad7658f141f558f86
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Sun Jan 7 11:36:37 2018 -0700

    net: qualcomm: rmnet: Add support for RX checksum offload
    
    When using the MAPv4 packet format, receive checksum offload can be
    enabled in hardware. The checksum computation over pseudo header is
    not offloaded but the rest of the checksum computation over
    the payload is offloaded. This applies only for TCP / UDP packets
    which are not fragmented.
    
    rmnet validates the TCP/UDP checksum for the packet using the checksum
    from the checksum trailer added to the packet by hardware. The
    validation performed is as following -
    
    1. Perform 1's complement over the checksum value from the trailer
    2. Compute 1's complement checksum over IPv4 / IPv6 header and
       subtracts it from the value from step 1
    3. Computes 1's complement checksum over IPv4 / IPv6 pseudo header and
       adds it to the value from step 2
    4. Subtracts the checksum value from the TCP / UDP header from the
       value from step 3.
    5. Compares the value from step 4 to the checksum value from the
       TCP / UDP header.
    6. If the comparison in step 5 succeeds, CHECKSUM_UNNECESSARY is set
       and the packet is passed on to network stack. If there is a
       failure, then the packet is passed on as such without modifying
       the ip_summed field.
    
    The checksum field is also checked for UDP checksum 0 as per RFC 768
    and for unexpected TCP checksum of 0.
    
    If checksum offload is disabled when using MAPv4 packet format in
    receive path, the packet is queued as is to network stack without
    the validations above.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index 8f8c4f205166..340945857d23 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -66,8 +66,8 @@ __rmnet_map_ingress_handler(struct sk_buff *skb,
 			    struct rmnet_port *port)
 {
 	struct rmnet_endpoint *ep;
+	u16 len, pad;
 	u8 mux_id;
-	u16 len;
 
 	if (RMNET_MAP_GET_CD_BIT(skb)) {
 		if (port->data_format & RMNET_INGRESS_FORMAT_MAP_COMMANDS)
@@ -77,7 +77,8 @@ __rmnet_map_ingress_handler(struct sk_buff *skb,
 	}
 
 	mux_id = RMNET_MAP_GET_MUX_ID(skb);
-	len = RMNET_MAP_GET_LENGTH(skb) - RMNET_MAP_GET_PAD(skb);
+	pad = RMNET_MAP_GET_PAD(skb);
+	len = RMNET_MAP_GET_LENGTH(skb) - pad;
 
 	if (mux_id >= RMNET_MAX_LOGICAL_EP)
 		goto free_skb;
@@ -90,8 +91,14 @@ __rmnet_map_ingress_handler(struct sk_buff *skb,
 
 	/* Subtract MAP header */
 	skb_pull(skb, sizeof(struct rmnet_map_header));
-	skb_trim(skb, len);
 	rmnet_set_skb_proto(skb);
+
+	if (port->data_format & RMNET_INGRESS_FORMAT_MAP_CKSUMV4) {
+		if (!rmnet_map_checksum_downlink_packet(skb, len + pad))
+			skb->ip_summed = CHECKSUM_UNNECESSARY;
+	}
+
+	skb_trim(skb, len);
 	rmnet_deliver_skb(skb);
 	return;
 
@@ -115,7 +122,7 @@ rmnet_map_ingress_handler(struct sk_buff *skb,
 	}
 
 	if (port->data_format & RMNET_INGRESS_FORMAT_DEAGGREGATION) {
-		while ((skbn = rmnet_map_deaggregate(skb)) != NULL)
+		while ((skbn = rmnet_map_deaggregate(skb, port)) != NULL)
 			__rmnet_map_ingress_handler(skbn, port);
 
 		consume_skb(skb);

commit 4e8683a95c963d766c7341eddbbc2d0c20022ebf
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Sun Jan 7 11:36:35 2018 -0700

    net: qualcomm: rmnet: Set pacing shift
    
    The real device over which the rmnet devices are installed also
    aggregate multiple IP packets and sends them as a single large
    aggregate frame to the hardware. This causes degraded throughput
    for TCP TX due to bufferbloat.
    
    To overcome this problem, pacing shift value of 8 is set using the
    sk_pacing_shift_update() helper. This value was determined based
    on experiments with a single stream TCP TX using iperf for a
    duration of 30s.
    
    Pacing shift | Observed data rate (Mbps)
              10 | 9
               9 | 140
               8 | 146 (Max link rate)
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index 8e1f43a69227..8f8c4f205166 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -16,6 +16,7 @@
 #include <linux/netdevice.h>
 #include <linux/netdev_features.h>
 #include <linux/if_arp.h>
+#include <net/sock.h>
 #include "rmnet_private.h"
 #include "rmnet_config.h"
 #include "rmnet_vnd.h"
@@ -204,6 +205,8 @@ void rmnet_egress_handler(struct sk_buff *skb)
 	struct rmnet_priv *priv;
 	u8 mux_id;
 
+	sk_pacing_shift_update(skb->sk, 8);
+
 	orig_dev = skb->dev;
 	priv = netdev_priv(orig_dev);
 	skb->dev = priv->real_dev;

commit b23e722ed69075b8a35070a272405653c6911fa5
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Sun Jan 7 11:36:34 2018 -0700

    net: qualcomm: rmnet: Rename ingress data format to data format
    
    This is done so that we can use this field for both ingress and
    egress flags.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index b2d317e34ee9..8e1f43a69227 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -69,8 +69,7 @@ __rmnet_map_ingress_handler(struct sk_buff *skb,
 	u16 len;
 
 	if (RMNET_MAP_GET_CD_BIT(skb)) {
-		if (port->ingress_data_format
-		    & RMNET_INGRESS_FORMAT_MAP_COMMANDS)
+		if (port->data_format & RMNET_INGRESS_FORMAT_MAP_COMMANDS)
 			return rmnet_map_command(skb, port);
 
 		goto free_skb;
@@ -114,7 +113,7 @@ rmnet_map_ingress_handler(struct sk_buff *skb,
 		skb_push(skb, ETH_HLEN);
 	}
 
-	if (port->ingress_data_format & RMNET_INGRESS_FORMAT_DEAGGREGATION) {
+	if (port->data_format & RMNET_INGRESS_FORMAT_DEAGGREGATION) {
 		while ((skbn = rmnet_map_deaggregate(skb)) != NULL)
 			__rmnet_map_ingress_handler(skbn, port);
 

commit 0b59a2340e5ef220b532393de52aa7f693e1f5cd
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Sun Jan 7 11:36:32 2018 -0700

    net: qualcomm: rmnet: Remove invalid condition while stamping mux id
    
    rmnet devices cannot have a mux id of 255. This is validated when
    assigning the mux id to the rmnet devices. As a result, checking for
    mux id 255 does not apply in egress path.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index 05539321ba3a..b2d317e34ee9 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -143,10 +143,7 @@ static int rmnet_map_egress_handler(struct sk_buff *skb,
 	if (!map_header)
 		goto fail;
 
-	if (mux_id == 0xff)
-		map_header->mux_id = 0;
-	else
-		map_header->mux_id = mux_id;
+	map_header->mux_id = mux_id;
 
 	skb->protocol = htons(ETH_P_MAP);
 

commit 74692caf1b0bd14454e61da1b7cd04254964beff
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Mon Dec 11 17:30:13 2017 -0700

    net: qualcomm: rmnet: Process packets over ethernet
    
    Add support to send and receive packets over ethernet.
    An example of usage is testing the data path on UML. This can be
    achieved by setting up two UML instances in multicast mode and
    associating rmnet over the UML ethernet device.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index a46053ce6b24..05539321ba3a 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -15,6 +15,7 @@
 
 #include <linux/netdevice.h>
 #include <linux/netdev_features.h>
+#include <linux/if_arp.h>
 #include "rmnet_private.h"
 #include "rmnet_config.h"
 #include "rmnet_vnd.h"
@@ -104,6 +105,15 @@ rmnet_map_ingress_handler(struct sk_buff *skb,
 {
 	struct sk_buff *skbn;
 
+	if (skb->dev->type == ARPHRD_ETHER) {
+		if (pskb_expand_head(skb, ETH_HLEN, 0, GFP_KERNEL)) {
+			kfree_skb(skb);
+			return;
+		}
+
+		skb_push(skb, ETH_HLEN);
+	}
+
 	if (port->ingress_data_format & RMNET_INGRESS_FORMAT_DEAGGREGATION) {
 		while ((skbn = rmnet_map_deaggregate(skb)) != NULL)
 			__rmnet_map_ingress_handler(skbn, port);

commit 8de721e21e202ceff3444e5c7abe7428a912a1f5
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Mon Dec 11 17:30:11 2017 -0700

    net: qualcomm: rmnet: Remove the some redundant macros
    
    Multiplexing is always enabled when transmiting from a rmnet device,
    so remove the redundant egress macros. De-multiplexing is always
    enabled when receiving packets from a rmnet device, so remove those
    ingress macros.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index 1e1ea100f28c..a46053ce6b24 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -133,12 +133,10 @@ static int rmnet_map_egress_handler(struct sk_buff *skb,
 	if (!map_header)
 		goto fail;
 
-	if (port->egress_data_format & RMNET_EGRESS_FORMAT_MUXING) {
-		if (mux_id == 0xff)
-			map_header->mux_id = 0;
-		else
-			map_header->mux_id = mux_id;
-	}
+	if (mux_id == 0xff)
+		map_header->mux_id = 0;
+	else
+		map_header->mux_id = mux_id;
 
 	skb->protocol = htons(ETH_P_MAP);
 
@@ -178,8 +176,7 @@ rx_handler_result_t rmnet_rx_handler(struct sk_buff **pskb)
 
 	switch (port->rmnet_mode) {
 	case RMNET_EPMODE_VND:
-		if (port->ingress_data_format & RMNET_INGRESS_FORMAT_MAP)
-			rmnet_map_ingress_handler(skb, port);
+		rmnet_map_ingress_handler(skb, port);
 		break;
 	case RMNET_EPMODE_BRIDGE:
 		rmnet_bridge_handler(skb, port->bridge_ep);
@@ -212,10 +209,8 @@ void rmnet_egress_handler(struct sk_buff *skb)
 		return;
 	}
 
-	if (port->egress_data_format & RMNET_EGRESS_FORMAT_MAP) {
-		if (rmnet_map_egress_handler(skb, port, mux_id, orig_dev))
-			return;
-	}
+	if (rmnet_map_egress_handler(skb, port, mux_id, orig_dev))
+		return;
 
 	rmnet_vnd_tx_fixup(skb, orig_dev);
 

commit cf2fe57b0cc22060f8f7dd0478afc35153e4172c
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Mon Dec 11 17:30:10 2017 -0700

    net: qualcomm: rmnet: Remove the rmnet_map_results enum
    
    Only the success and consumed entries were actually in use.
    Use standard error codes instead.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index 08e4afc0ab39..1e1ea100f28c 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -142,11 +142,11 @@ static int rmnet_map_egress_handler(struct sk_buff *skb,
 
 	skb->protocol = htons(ETH_P_MAP);
 
-	return RMNET_MAP_SUCCESS;
+	return 0;
 
 fail:
 	kfree_skb(skb);
-	return RMNET_MAP_CONSUMED;
+	return -ENOMEM;
 }
 
 static void
@@ -213,17 +213,8 @@ void rmnet_egress_handler(struct sk_buff *skb)
 	}
 
 	if (port->egress_data_format & RMNET_EGRESS_FORMAT_MAP) {
-		switch (rmnet_map_egress_handler(skb, port, mux_id, orig_dev)) {
-		case RMNET_MAP_CONSUMED:
+		if (rmnet_map_egress_handler(skb, port, mux_id, orig_dev))
 			return;
-
-		case RMNET_MAP_SUCCESS:
-			break;
-
-		default:
-			kfree_skb(skb);
-			return;
-		}
 	}
 
 	rmnet_vnd_tx_fixup(skb, orig_dev);

commit c20a548792f15f8d8e38cd74356301c6db0d241f
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Tue Dec 5 13:41:17 2017 -0700

    net: qualcomm: rmnet: Fix leak on transmit failure
    
    If a skb in transmit path does not have sufficient headroom to add
    the map header, the skb is not sent out and is never freed.
    
    Fixes: ceed73a2cf4a ("drivers: net: ethernet: qualcomm: rmnet: Initial implementation")
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index 29842ccc91a9..08e4afc0ab39 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -126,12 +126,12 @@ static int rmnet_map_egress_handler(struct sk_buff *skb,
 
 	if (skb_headroom(skb) < required_headroom) {
 		if (pskb_expand_head(skb, required_headroom, 0, GFP_KERNEL))
-			return RMNET_MAP_CONSUMED;
+			goto fail;
 	}
 
 	map_header = rmnet_map_add_map_header(skb, additional_header_len, 0);
 	if (!map_header)
-		return RMNET_MAP_CONSUMED;
+		goto fail;
 
 	if (port->egress_data_format & RMNET_EGRESS_FORMAT_MUXING) {
 		if (mux_id == 0xff)
@@ -143,6 +143,10 @@ static int rmnet_map_egress_handler(struct sk_buff *skb,
 	skb->protocol = htons(ETH_P_MAP);
 
 	return RMNET_MAP_SUCCESS;
+
+fail:
+	kfree_skb(skb);
+	return RMNET_MAP_CONSUMED;
 }
 
 static void

commit ca32fb034c19e00cfb5e0fd7217eb92f81302048
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Thu Oct 26 11:06:49 2017 -0600

    net: qualcomm: rmnet: Add support for GRO
    
    Add gro_cells so that rmnet devices can call gro_cells_receive
    instead of netif_receive_skb.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Cc: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index 1ea978335da3..29842ccc91a9 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -46,13 +46,15 @@ static void rmnet_set_skb_proto(struct sk_buff *skb)
 static void
 rmnet_deliver_skb(struct sk_buff *skb)
 {
+	struct rmnet_priv *priv = netdev_priv(skb->dev);
+
 	skb_reset_transport_header(skb);
 	skb_reset_network_header(skb);
 	rmnet_vnd_rx_fixup(skb, skb->dev);
 
 	skb->pkt_type = PACKET_HOST;
 	skb_set_mac_header(skb, 0);
-	netif_receive_skb(skb);
+	gro_cells_receive(&priv->gro_cells, skb);
 }
 
 /* MAP handler */

commit 85355d775ff70d9ba77a5f94dd786b23852e1c72
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Thu Oct 26 11:06:47 2017 -0600

    net: qualcomm: rmnet: Always assign rmnet dev in deaggregation path
    
    The rmnet device needs to assigned for all packets in the
    deaggregation path based on the mux id, so the check is not needed.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index 5dd186d4d0e4..1ea978335da3 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -83,8 +83,7 @@ __rmnet_map_ingress_handler(struct sk_buff *skb,
 	if (!ep)
 		goto free_skb;
 
-	if (port->ingress_data_format & RMNET_INGRESS_FORMAT_DEMUXING)
-		skb->dev = ep->egress_dev;
+	skb->dev = ep->egress_dev;
 
 	/* Subtract MAP header */
 	skb_pull(skb, sizeof(struct rmnet_map_header));

commit 2ffbbf0f91288f909b3d495cbf029d8e4cc7db66
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Thu Oct 26 11:06:46 2017 -0600

    net: qualcomm: rmnet: Fix the return value of rmnet_rx_handler()
    
    Since packet is always consumed by rmnet_rx_handler(), we always
    return RX_HANDLER_CONSUMED. There is no need to pass on this
    value through multiple functions.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index df3d2d16ce55..5dd186d4d0e4 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -43,7 +43,7 @@ static void rmnet_set_skb_proto(struct sk_buff *skb)
 
 /* Generic handler */
 
-static rx_handler_result_t
+static void
 rmnet_deliver_skb(struct sk_buff *skb)
 {
 	skb_reset_transport_header(skb);
@@ -53,12 +53,11 @@ rmnet_deliver_skb(struct sk_buff *skb)
 	skb->pkt_type = PACKET_HOST;
 	skb_set_mac_header(skb, 0);
 	netif_receive_skb(skb);
-	return RX_HANDLER_CONSUMED;
 }
 
 /* MAP handler */
 
-static rx_handler_result_t
+static void
 __rmnet_map_ingress_handler(struct sk_buff *skb,
 			    struct rmnet_port *port)
 {
@@ -91,31 +90,27 @@ __rmnet_map_ingress_handler(struct sk_buff *skb,
 	skb_pull(skb, sizeof(struct rmnet_map_header));
 	skb_trim(skb, len);
 	rmnet_set_skb_proto(skb);
-	return rmnet_deliver_skb(skb);
+	rmnet_deliver_skb(skb);
+	return;
 
 free_skb:
 	kfree_skb(skb);
-	return RX_HANDLER_CONSUMED;
 }
 
-static rx_handler_result_t
+static void
 rmnet_map_ingress_handler(struct sk_buff *skb,
 			  struct rmnet_port *port)
 {
 	struct sk_buff *skbn;
-	int rc;
 
 	if (port->ingress_data_format & RMNET_INGRESS_FORMAT_DEAGGREGATION) {
 		while ((skbn = rmnet_map_deaggregate(skb)) != NULL)
 			__rmnet_map_ingress_handler(skbn, port);
 
 		consume_skb(skb);
-		rc = RX_HANDLER_CONSUMED;
 	} else {
-		rc = __rmnet_map_ingress_handler(skb, port);
+		__rmnet_map_ingress_handler(skb, port);
 	}
-
-	return rc;
 }
 
 static int rmnet_map_egress_handler(struct sk_buff *skb,
@@ -149,15 +144,13 @@ static int rmnet_map_egress_handler(struct sk_buff *skb,
 	return RMNET_MAP_SUCCESS;
 }
 
-static rx_handler_result_t
+static void
 rmnet_bridge_handler(struct sk_buff *skb, struct net_device *bridge_dev)
 {
 	if (bridge_dev) {
 		skb->dev = bridge_dev;
 		dev_queue_xmit(skb);
 	}
-
-	return RX_HANDLER_CONSUMED;
 }
 
 /* Ingress / Egress Entry Points */
@@ -168,13 +161,12 @@ rmnet_bridge_handler(struct sk_buff *skb, struct net_device *bridge_dev)
  */
 rx_handler_result_t rmnet_rx_handler(struct sk_buff **pskb)
 {
-	int rc = RX_HANDLER_CONSUMED;
 	struct sk_buff *skb = *pskb;
 	struct rmnet_port *port;
 	struct net_device *dev;
 
 	if (!skb)
-		return RX_HANDLER_CONSUMED;
+		goto done;
 
 	dev = skb->dev;
 	port = rmnet_get_port(dev);
@@ -182,14 +174,15 @@ rx_handler_result_t rmnet_rx_handler(struct sk_buff **pskb)
 	switch (port->rmnet_mode) {
 	case RMNET_EPMODE_VND:
 		if (port->ingress_data_format & RMNET_INGRESS_FORMAT_MAP)
-			rc = rmnet_map_ingress_handler(skb, port);
+			rmnet_map_ingress_handler(skb, port);
 		break;
 	case RMNET_EPMODE_BRIDGE:
-		rc = rmnet_bridge_handler(skb, port->bridge_ep);
+		rmnet_bridge_handler(skb, port->bridge_ep);
 		break;
 	}
 
-	return rc;
+done:
+	return RX_HANDLER_CONSUMED;
 }
 
 /* Modifies packet as per logical endpoint configuration and egress data format

commit 60d58f971c1077a0f2467b2d5bc38058df43a819
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Wed Oct 11 18:43:58 2017 -0600

    net: qualcomm: rmnet: Implement bridge mode
    
    Add support to bridge two devices which can send multiplexing and
    aggregation (MAP) data. This is done only when the data itself is
    not going to be consumed in the stack but is being passed on to a
    different endpoint. This is mainly used for testing.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index fa24ffb69713..df3d2d16ce55 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -149,6 +149,17 @@ static int rmnet_map_egress_handler(struct sk_buff *skb,
 	return RMNET_MAP_SUCCESS;
 }
 
+static rx_handler_result_t
+rmnet_bridge_handler(struct sk_buff *skb, struct net_device *bridge_dev)
+{
+	if (bridge_dev) {
+		skb->dev = bridge_dev;
+		dev_queue_xmit(skb);
+	}
+
+	return RX_HANDLER_CONSUMED;
+}
+
 /* Ingress / Egress Entry Points */
 
 /* Processes packet as per ingress data format for receiving device. Logical
@@ -157,10 +168,10 @@ static int rmnet_map_egress_handler(struct sk_buff *skb,
  */
 rx_handler_result_t rmnet_rx_handler(struct sk_buff **pskb)
 {
-	struct rmnet_port *port;
+	int rc = RX_HANDLER_CONSUMED;
 	struct sk_buff *skb = *pskb;
+	struct rmnet_port *port;
 	struct net_device *dev;
-	int rc;
 
 	if (!skb)
 		return RX_HANDLER_CONSUMED;
@@ -168,8 +179,15 @@ rx_handler_result_t rmnet_rx_handler(struct sk_buff **pskb)
 	dev = skb->dev;
 	port = rmnet_get_port(dev);
 
-	if (port->ingress_data_format & RMNET_INGRESS_FORMAT_MAP)
-		rc = rmnet_map_ingress_handler(skb, port);
+	switch (port->rmnet_mode) {
+	case RMNET_EPMODE_VND:
+		if (port->ingress_data_format & RMNET_INGRESS_FORMAT_MAP)
+			rc = rmnet_map_ingress_handler(skb, port);
+		break;
+	case RMNET_EPMODE_BRIDGE:
+		rc = rmnet_bridge_handler(skb, port->bridge_ep);
+		break;
+	}
 
 	return rc;
 }

commit 3352e6c45760fd6675468a35ef699ab94617cab4
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Wed Oct 11 18:43:57 2017 -0600

    net: qualcomm: rmnet: Convert the muxed endpoint to hlist
    
    Rather than using a static array, use a hlist to store the muxed
    endpoints and use the mux id to query the rmnet_device.
    This is useful as usually very few mux ids are used.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Cc: Dan Williams <dcbw@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index e0802d32d6a5..fa24ffb69713 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -71,19 +71,18 @@ __rmnet_map_ingress_handler(struct sk_buff *skb,
 		    & RMNET_INGRESS_FORMAT_MAP_COMMANDS)
 			return rmnet_map_command(skb, port);
 
-		kfree_skb(skb);
-		return RX_HANDLER_CONSUMED;
+		goto free_skb;
 	}
 
 	mux_id = RMNET_MAP_GET_MUX_ID(skb);
 	len = RMNET_MAP_GET_LENGTH(skb) - RMNET_MAP_GET_PAD(skb);
 
-	if (mux_id >= RMNET_MAX_LOGICAL_EP) {
-		kfree_skb(skb);
-		return RX_HANDLER_CONSUMED;
-	}
+	if (mux_id >= RMNET_MAX_LOGICAL_EP)
+		goto free_skb;
 
-	ep = &port->muxed_ep[mux_id];
+	ep = rmnet_get_endpoint(port, mux_id);
+	if (!ep)
+		goto free_skb;
 
 	if (port->ingress_data_format & RMNET_INGRESS_FORMAT_DEMUXING)
 		skb->dev = ep->egress_dev;
@@ -93,6 +92,10 @@ __rmnet_map_ingress_handler(struct sk_buff *skb,
 	skb_trim(skb, len);
 	rmnet_set_skb_proto(skb);
 	return rmnet_deliver_skb(skb);
+
+free_skb:
+	kfree_skb(skb);
+	return RX_HANDLER_CONSUMED;
 }
 
 static rx_handler_result_t

commit 56470c927f1ba1e101b5e5a93e02d23a14fd99b7
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Wed Oct 11 18:43:55 2017 -0600

    net: qualcomm: rmnet: Remove duplicate setting of rmnet private info
    
    The end point is set twice in the local_ep as well as the mux_id and
    the real_dev in the rmnet private structure. Remove the local_ep.
    While these elements are equivalent, rmnet_endpoint will be
    used only as part of the rmnet_port for muxed scenarios in VND mode.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index 86e37cc3b52c..e0802d32d6a5 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -116,8 +116,7 @@ rmnet_map_ingress_handler(struct sk_buff *skb,
 }
 
 static int rmnet_map_egress_handler(struct sk_buff *skb,
-				    struct rmnet_port *port,
-				    struct rmnet_endpoint *ep,
+				    struct rmnet_port *port, u8 mux_id,
 				    struct net_device *orig_dev)
 {
 	int required_headroom, additional_header_len;
@@ -136,10 +135,10 @@ static int rmnet_map_egress_handler(struct sk_buff *skb,
 		return RMNET_MAP_CONSUMED;
 
 	if (port->egress_data_format & RMNET_EGRESS_FORMAT_MUXING) {
-		if (ep->mux_id == 0xff)
+		if (mux_id == 0xff)
 			map_header->mux_id = 0;
 		else
-			map_header->mux_id = ep->mux_id;
+			map_header->mux_id = mux_id;
 	}
 
 	skb->protocol = htons(ETH_P_MAP);
@@ -176,14 +175,17 @@ rx_handler_result_t rmnet_rx_handler(struct sk_buff **pskb)
  * for egress device configured in logical endpoint. Packet is then transmitted
  * on the egress device.
  */
-void rmnet_egress_handler(struct sk_buff *skb,
-			  struct rmnet_endpoint *ep)
+void rmnet_egress_handler(struct sk_buff *skb)
 {
 	struct net_device *orig_dev;
 	struct rmnet_port *port;
+	struct rmnet_priv *priv;
+	u8 mux_id;
 
 	orig_dev = skb->dev;
-	skb->dev = ep->egress_dev;
+	priv = netdev_priv(orig_dev);
+	skb->dev = priv->real_dev;
+	mux_id = priv->mux_id;
 
 	port = rmnet_get_port(skb->dev);
 	if (!port) {
@@ -192,7 +194,7 @@ void rmnet_egress_handler(struct sk_buff *skb,
 	}
 
 	if (port->egress_data_format & RMNET_EGRESS_FORMAT_MAP) {
-		switch (rmnet_map_egress_handler(skb, port, ep, orig_dev)) {
+		switch (rmnet_map_egress_handler(skb, port, mux_id, orig_dev)) {
 		case RMNET_MAP_CONSUMED:
 			return;
 

commit 9148963201a4627a632d2c769805c9278f6d22d7
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Wed Oct 11 18:43:54 2017 -0600

    net: qualcomm: rmnet: Move rmnet_mode to rmnet_port
    
    Mode information on the real device makes it easier to route packets
    to rmnet device or bridged device based on the configuration.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index b50f40181661..86e37cc3b52c 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -205,8 +205,7 @@ void rmnet_egress_handler(struct sk_buff *skb,
 		}
 	}
 
-	if (ep->rmnet_mode == RMNET_EPMODE_VND)
-		rmnet_vnd_tx_fixup(skb, orig_dev);
+	rmnet_vnd_tx_fixup(skb, orig_dev);
 
 	dev_queue_xmit(skb);
 }

commit d8bbb07adbfab5a8e03c361c7dd67fe0003d3757
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Wed Oct 11 18:43:52 2017 -0600

    net: qualcomm: rmnet: Remove existing logic for bridge mode
    
    This will be rewritten in the following patches.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index 540c7622dcb1..b50f40181661 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -44,56 +44,18 @@ static void rmnet_set_skb_proto(struct sk_buff *skb)
 /* Generic handler */
 
 static rx_handler_result_t
-rmnet_bridge_handler(struct sk_buff *skb, struct rmnet_endpoint *ep)
+rmnet_deliver_skb(struct sk_buff *skb)
 {
-	if (!ep->egress_dev)
-		kfree_skb(skb);
-	else
-		rmnet_egress_handler(skb, ep);
+	skb_reset_transport_header(skb);
+	skb_reset_network_header(skb);
+	rmnet_vnd_rx_fixup(skb, skb->dev);
 
+	skb->pkt_type = PACKET_HOST;
+	skb_set_mac_header(skb, 0);
+	netif_receive_skb(skb);
 	return RX_HANDLER_CONSUMED;
 }
 
-static rx_handler_result_t
-rmnet_deliver_skb(struct sk_buff *skb, struct rmnet_endpoint *ep)
-{
-	switch (ep->rmnet_mode) {
-	case RMNET_EPMODE_NONE:
-		return RX_HANDLER_PASS;
-
-	case RMNET_EPMODE_BRIDGE:
-		return rmnet_bridge_handler(skb, ep);
-
-	case RMNET_EPMODE_VND:
-		skb_reset_transport_header(skb);
-		skb_reset_network_header(skb);
-		rmnet_vnd_rx_fixup(skb, skb->dev);
-
-		skb->pkt_type = PACKET_HOST;
-		skb_set_mac_header(skb, 0);
-		netif_receive_skb(skb);
-		return RX_HANDLER_CONSUMED;
-
-	default:
-		kfree_skb(skb);
-		return RX_HANDLER_CONSUMED;
-	}
-}
-
-static rx_handler_result_t
-rmnet_ingress_deliver_packet(struct sk_buff *skb,
-			     struct rmnet_port *port)
-{
-	if (!port) {
-		kfree_skb(skb);
-		return RX_HANDLER_CONSUMED;
-	}
-
-	skb->dev = port->local_ep.egress_dev;
-
-	return rmnet_deliver_skb(skb, &port->local_ep);
-}
-
 /* MAP handler */
 
 static rx_handler_result_t
@@ -130,7 +92,7 @@ __rmnet_map_ingress_handler(struct sk_buff *skb,
 	skb_pull(skb, sizeof(struct rmnet_map_header));
 	skb_trim(skb, len);
 	rmnet_set_skb_proto(skb);
-	return rmnet_deliver_skb(skb, ep);
+	return rmnet_deliver_skb(skb);
 }
 
 static rx_handler_result_t
@@ -204,29 +166,8 @@ rx_handler_result_t rmnet_rx_handler(struct sk_buff **pskb)
 	dev = skb->dev;
 	port = rmnet_get_port(dev);
 
-	if (port->ingress_data_format & RMNET_INGRESS_FORMAT_MAP) {
+	if (port->ingress_data_format & RMNET_INGRESS_FORMAT_MAP)
 		rc = rmnet_map_ingress_handler(skb, port);
-	} else {
-		switch (ntohs(skb->protocol)) {
-		case ETH_P_MAP:
-			if (port->local_ep.rmnet_mode ==
-				RMNET_EPMODE_BRIDGE) {
-				rc = rmnet_ingress_deliver_packet(skb, port);
-			} else {
-				kfree_skb(skb);
-				rc = RX_HANDLER_CONSUMED;
-			}
-			break;
-
-		case ETH_P_IP:
-		case ETH_P_IPV6:
-			rc = rmnet_ingress_deliver_packet(skb, port);
-			break;
-
-		default:
-			rc = RX_HANDLER_PASS;
-		}
-	}
 
 	return rc;
 }

commit b665f4f82d31c17926df3ac7c4a59bbff7af463b
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Sat Sep 2 23:30:46 2017 -0600

    net: qualcomm: rmnet: Rename real_dev_info to port
    
    Make it similar to drivers like ipvlan / macvlan so it is easier to read.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Cc: Dan Williams <dcbw@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
index 7dab3bbfeda5..540c7622dcb1 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -82,32 +82,32 @@ rmnet_deliver_skb(struct sk_buff *skb, struct rmnet_endpoint *ep)
 
 static rx_handler_result_t
 rmnet_ingress_deliver_packet(struct sk_buff *skb,
-			     struct rmnet_real_dev_info *r)
+			     struct rmnet_port *port)
 {
-	if (!r) {
+	if (!port) {
 		kfree_skb(skb);
 		return RX_HANDLER_CONSUMED;
 	}
 
-	skb->dev = r->local_ep.egress_dev;
+	skb->dev = port->local_ep.egress_dev;
 
-	return rmnet_deliver_skb(skb, &r->local_ep);
+	return rmnet_deliver_skb(skb, &port->local_ep);
 }
 
 /* MAP handler */
 
 static rx_handler_result_t
 __rmnet_map_ingress_handler(struct sk_buff *skb,
-			    struct rmnet_real_dev_info *r)
+			    struct rmnet_port *port)
 {
 	struct rmnet_endpoint *ep;
 	u8 mux_id;
 	u16 len;
 
 	if (RMNET_MAP_GET_CD_BIT(skb)) {
-		if (r->ingress_data_format
+		if (port->ingress_data_format
 		    & RMNET_INGRESS_FORMAT_MAP_COMMANDS)
-			return rmnet_map_command(skb, r);
+			return rmnet_map_command(skb, port);
 
 		kfree_skb(skb);
 		return RX_HANDLER_CONSUMED;
@@ -121,9 +121,9 @@ __rmnet_map_ingress_handler(struct sk_buff *skb,
 		return RX_HANDLER_CONSUMED;
 	}
 
-	ep = &r->muxed_ep[mux_id];
+	ep = &port->muxed_ep[mux_id];
 
-	if (r->ingress_data_format & RMNET_INGRESS_FORMAT_DEMUXING)
+	if (port->ingress_data_format & RMNET_INGRESS_FORMAT_DEMUXING)
 		skb->dev = ep->egress_dev;
 
 	/* Subtract MAP header */
@@ -135,26 +135,26 @@ __rmnet_map_ingress_handler(struct sk_buff *skb,
 
 static rx_handler_result_t
 rmnet_map_ingress_handler(struct sk_buff *skb,
-			  struct rmnet_real_dev_info *r)
+			  struct rmnet_port *port)
 {
 	struct sk_buff *skbn;
 	int rc;
 
-	if (r->ingress_data_format & RMNET_INGRESS_FORMAT_DEAGGREGATION) {
-		while ((skbn = rmnet_map_deaggregate(skb, r)) != NULL)
-			__rmnet_map_ingress_handler(skbn, r);
+	if (port->ingress_data_format & RMNET_INGRESS_FORMAT_DEAGGREGATION) {
+		while ((skbn = rmnet_map_deaggregate(skb)) != NULL)
+			__rmnet_map_ingress_handler(skbn, port);
 
 		consume_skb(skb);
 		rc = RX_HANDLER_CONSUMED;
 	} else {
-		rc = __rmnet_map_ingress_handler(skb, r);
+		rc = __rmnet_map_ingress_handler(skb, port);
 	}
 
 	return rc;
 }
 
 static int rmnet_map_egress_handler(struct sk_buff *skb,
-				    struct rmnet_real_dev_info *r,
+				    struct rmnet_port *port,
 				    struct rmnet_endpoint *ep,
 				    struct net_device *orig_dev)
 {
@@ -173,7 +173,7 @@ static int rmnet_map_egress_handler(struct sk_buff *skb,
 	if (!map_header)
 		return RMNET_MAP_CONSUMED;
 
-	if (r->egress_data_format & RMNET_EGRESS_FORMAT_MUXING) {
+	if (port->egress_data_format & RMNET_EGRESS_FORMAT_MUXING) {
 		if (ep->mux_id == 0xff)
 			map_header->mux_id = 0;
 		else
@@ -193,7 +193,7 @@ static int rmnet_map_egress_handler(struct sk_buff *skb,
  */
 rx_handler_result_t rmnet_rx_handler(struct sk_buff **pskb)
 {
-	struct rmnet_real_dev_info *r;
+	struct rmnet_port *port;
 	struct sk_buff *skb = *pskb;
 	struct net_device *dev;
 	int rc;
@@ -202,16 +202,16 @@ rx_handler_result_t rmnet_rx_handler(struct sk_buff **pskb)
 		return RX_HANDLER_CONSUMED;
 
 	dev = skb->dev;
-	r = rmnet_get_real_dev_info(dev);
+	port = rmnet_get_port(dev);
 
-	if (r->ingress_data_format & RMNET_INGRESS_FORMAT_MAP) {
-		rc = rmnet_map_ingress_handler(skb, r);
+	if (port->ingress_data_format & RMNET_INGRESS_FORMAT_MAP) {
+		rc = rmnet_map_ingress_handler(skb, port);
 	} else {
 		switch (ntohs(skb->protocol)) {
 		case ETH_P_MAP:
-			if (r->local_ep.rmnet_mode ==
+			if (port->local_ep.rmnet_mode ==
 				RMNET_EPMODE_BRIDGE) {
-				rc = rmnet_ingress_deliver_packet(skb, r);
+				rc = rmnet_ingress_deliver_packet(skb, port);
 			} else {
 				kfree_skb(skb);
 				rc = RX_HANDLER_CONSUMED;
@@ -220,7 +220,7 @@ rx_handler_result_t rmnet_rx_handler(struct sk_buff **pskb)
 
 		case ETH_P_IP:
 		case ETH_P_IPV6:
-			rc = rmnet_ingress_deliver_packet(skb, r);
+			rc = rmnet_ingress_deliver_packet(skb, port);
 			break;
 
 		default:
@@ -238,20 +238,20 @@ rx_handler_result_t rmnet_rx_handler(struct sk_buff **pskb)
 void rmnet_egress_handler(struct sk_buff *skb,
 			  struct rmnet_endpoint *ep)
 {
-	struct rmnet_real_dev_info *r;
 	struct net_device *orig_dev;
+	struct rmnet_port *port;
 
 	orig_dev = skb->dev;
 	skb->dev = ep->egress_dev;
 
-	r = rmnet_get_real_dev_info(skb->dev);
-	if (!r) {
+	port = rmnet_get_port(skb->dev);
+	if (!port) {
 		kfree_skb(skb);
 		return;
 	}
 
-	if (r->egress_data_format & RMNET_EGRESS_FORMAT_MAP) {
-		switch (rmnet_map_egress_handler(skb, r, ep, orig_dev)) {
+	if (port->egress_data_format & RMNET_EGRESS_FORMAT_MAP) {
+		switch (rmnet_map_egress_handler(skb, port, ep, orig_dev)) {
 		case RMNET_MAP_CONSUMED:
 			return;
 

commit ceed73a2cf4aff2921802aa3d21d45280677547d
Author: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
Date:   Tue Aug 29 22:44:18 2017 -0600

    drivers: net: ethernet: qualcomm: rmnet: Initial implementation
    
    RmNet driver provides a transport agnostic MAP (multiplexing and
    aggregation protocol) support in embedded module. Module provides
    virtual network devices which can be attached to any IP-mode
    physical device. This will be used to provide all MAP functionality
    on future hardware in a single consistent location.
    
    Signed-off-by: Subash Abhinov Kasiviswanathan <subashab@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
new file mode 100644
index 000000000000..7dab3bbfeda5
--- /dev/null
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c
@@ -0,0 +1,271 @@
+/* Copyright (c) 2013-2017, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * RMNET Data ingress/egress handler
+ *
+ */
+
+#include <linux/netdevice.h>
+#include <linux/netdev_features.h>
+#include "rmnet_private.h"
+#include "rmnet_config.h"
+#include "rmnet_vnd.h"
+#include "rmnet_map.h"
+#include "rmnet_handlers.h"
+
+#define RMNET_IP_VERSION_4 0x40
+#define RMNET_IP_VERSION_6 0x60
+
+/* Helper Functions */
+
+static void rmnet_set_skb_proto(struct sk_buff *skb)
+{
+	switch (skb->data[0] & 0xF0) {
+	case RMNET_IP_VERSION_4:
+		skb->protocol = htons(ETH_P_IP);
+		break;
+	case RMNET_IP_VERSION_6:
+		skb->protocol = htons(ETH_P_IPV6);
+		break;
+	default:
+		skb->protocol = htons(ETH_P_MAP);
+		break;
+	}
+}
+
+/* Generic handler */
+
+static rx_handler_result_t
+rmnet_bridge_handler(struct sk_buff *skb, struct rmnet_endpoint *ep)
+{
+	if (!ep->egress_dev)
+		kfree_skb(skb);
+	else
+		rmnet_egress_handler(skb, ep);
+
+	return RX_HANDLER_CONSUMED;
+}
+
+static rx_handler_result_t
+rmnet_deliver_skb(struct sk_buff *skb, struct rmnet_endpoint *ep)
+{
+	switch (ep->rmnet_mode) {
+	case RMNET_EPMODE_NONE:
+		return RX_HANDLER_PASS;
+
+	case RMNET_EPMODE_BRIDGE:
+		return rmnet_bridge_handler(skb, ep);
+
+	case RMNET_EPMODE_VND:
+		skb_reset_transport_header(skb);
+		skb_reset_network_header(skb);
+		rmnet_vnd_rx_fixup(skb, skb->dev);
+
+		skb->pkt_type = PACKET_HOST;
+		skb_set_mac_header(skb, 0);
+		netif_receive_skb(skb);
+		return RX_HANDLER_CONSUMED;
+
+	default:
+		kfree_skb(skb);
+		return RX_HANDLER_CONSUMED;
+	}
+}
+
+static rx_handler_result_t
+rmnet_ingress_deliver_packet(struct sk_buff *skb,
+			     struct rmnet_real_dev_info *r)
+{
+	if (!r) {
+		kfree_skb(skb);
+		return RX_HANDLER_CONSUMED;
+	}
+
+	skb->dev = r->local_ep.egress_dev;
+
+	return rmnet_deliver_skb(skb, &r->local_ep);
+}
+
+/* MAP handler */
+
+static rx_handler_result_t
+__rmnet_map_ingress_handler(struct sk_buff *skb,
+			    struct rmnet_real_dev_info *r)
+{
+	struct rmnet_endpoint *ep;
+	u8 mux_id;
+	u16 len;
+
+	if (RMNET_MAP_GET_CD_BIT(skb)) {
+		if (r->ingress_data_format
+		    & RMNET_INGRESS_FORMAT_MAP_COMMANDS)
+			return rmnet_map_command(skb, r);
+
+		kfree_skb(skb);
+		return RX_HANDLER_CONSUMED;
+	}
+
+	mux_id = RMNET_MAP_GET_MUX_ID(skb);
+	len = RMNET_MAP_GET_LENGTH(skb) - RMNET_MAP_GET_PAD(skb);
+
+	if (mux_id >= RMNET_MAX_LOGICAL_EP) {
+		kfree_skb(skb);
+		return RX_HANDLER_CONSUMED;
+	}
+
+	ep = &r->muxed_ep[mux_id];
+
+	if (r->ingress_data_format & RMNET_INGRESS_FORMAT_DEMUXING)
+		skb->dev = ep->egress_dev;
+
+	/* Subtract MAP header */
+	skb_pull(skb, sizeof(struct rmnet_map_header));
+	skb_trim(skb, len);
+	rmnet_set_skb_proto(skb);
+	return rmnet_deliver_skb(skb, ep);
+}
+
+static rx_handler_result_t
+rmnet_map_ingress_handler(struct sk_buff *skb,
+			  struct rmnet_real_dev_info *r)
+{
+	struct sk_buff *skbn;
+	int rc;
+
+	if (r->ingress_data_format & RMNET_INGRESS_FORMAT_DEAGGREGATION) {
+		while ((skbn = rmnet_map_deaggregate(skb, r)) != NULL)
+			__rmnet_map_ingress_handler(skbn, r);
+
+		consume_skb(skb);
+		rc = RX_HANDLER_CONSUMED;
+	} else {
+		rc = __rmnet_map_ingress_handler(skb, r);
+	}
+
+	return rc;
+}
+
+static int rmnet_map_egress_handler(struct sk_buff *skb,
+				    struct rmnet_real_dev_info *r,
+				    struct rmnet_endpoint *ep,
+				    struct net_device *orig_dev)
+{
+	int required_headroom, additional_header_len;
+	struct rmnet_map_header *map_header;
+
+	additional_header_len = 0;
+	required_headroom = sizeof(struct rmnet_map_header);
+
+	if (skb_headroom(skb) < required_headroom) {
+		if (pskb_expand_head(skb, required_headroom, 0, GFP_KERNEL))
+			return RMNET_MAP_CONSUMED;
+	}
+
+	map_header = rmnet_map_add_map_header(skb, additional_header_len, 0);
+	if (!map_header)
+		return RMNET_MAP_CONSUMED;
+
+	if (r->egress_data_format & RMNET_EGRESS_FORMAT_MUXING) {
+		if (ep->mux_id == 0xff)
+			map_header->mux_id = 0;
+		else
+			map_header->mux_id = ep->mux_id;
+	}
+
+	skb->protocol = htons(ETH_P_MAP);
+
+	return RMNET_MAP_SUCCESS;
+}
+
+/* Ingress / Egress Entry Points */
+
+/* Processes packet as per ingress data format for receiving device. Logical
+ * endpoint is determined from packet inspection. Packet is then sent to the
+ * egress device listed in the logical endpoint configuration.
+ */
+rx_handler_result_t rmnet_rx_handler(struct sk_buff **pskb)
+{
+	struct rmnet_real_dev_info *r;
+	struct sk_buff *skb = *pskb;
+	struct net_device *dev;
+	int rc;
+
+	if (!skb)
+		return RX_HANDLER_CONSUMED;
+
+	dev = skb->dev;
+	r = rmnet_get_real_dev_info(dev);
+
+	if (r->ingress_data_format & RMNET_INGRESS_FORMAT_MAP) {
+		rc = rmnet_map_ingress_handler(skb, r);
+	} else {
+		switch (ntohs(skb->protocol)) {
+		case ETH_P_MAP:
+			if (r->local_ep.rmnet_mode ==
+				RMNET_EPMODE_BRIDGE) {
+				rc = rmnet_ingress_deliver_packet(skb, r);
+			} else {
+				kfree_skb(skb);
+				rc = RX_HANDLER_CONSUMED;
+			}
+			break;
+
+		case ETH_P_IP:
+		case ETH_P_IPV6:
+			rc = rmnet_ingress_deliver_packet(skb, r);
+			break;
+
+		default:
+			rc = RX_HANDLER_PASS;
+		}
+	}
+
+	return rc;
+}
+
+/* Modifies packet as per logical endpoint configuration and egress data format
+ * for egress device configured in logical endpoint. Packet is then transmitted
+ * on the egress device.
+ */
+void rmnet_egress_handler(struct sk_buff *skb,
+			  struct rmnet_endpoint *ep)
+{
+	struct rmnet_real_dev_info *r;
+	struct net_device *orig_dev;
+
+	orig_dev = skb->dev;
+	skb->dev = ep->egress_dev;
+
+	r = rmnet_get_real_dev_info(skb->dev);
+	if (!r) {
+		kfree_skb(skb);
+		return;
+	}
+
+	if (r->egress_data_format & RMNET_EGRESS_FORMAT_MAP) {
+		switch (rmnet_map_egress_handler(skb, r, ep, orig_dev)) {
+		case RMNET_MAP_CONSUMED:
+			return;
+
+		case RMNET_MAP_SUCCESS:
+			break;
+
+		default:
+			kfree_skb(skb);
+			return;
+		}
+	}
+
+	if (ep->rmnet_mode == RMNET_EPMODE_VND)
+		rmnet_vnd_tx_fixup(skb, orig_dev);
+
+	dev_queue_xmit(skb);
+}
