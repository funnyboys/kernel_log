commit f49b2759821e3af7c3740b52ca91053b16c91103
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Mon Feb 24 10:32:52 2020 -0600

    toshiba: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/toshiba/ps3_gelic_wireless.h b/drivers/net/ethernet/toshiba/ps3_gelic_wireless.h
index 4041d946b649..1f203d1ae8db 100644
--- a/drivers/net/ethernet/toshiba/ps3_gelic_wireless.h
+++ b/drivers/net/ethernet/toshiba/ps3_gelic_wireless.h
@@ -158,7 +158,7 @@ struct gelic_eurus_scan_info {
 	__be32 reserved2;
 	__be32 reserved3;
 	__be32 reserved4;
-	u8 elements[0]; /* ie */
+	u8 elements[]; /* ie */
 } __packed;
 
 /* the hypervisor returns bbs up to 16 */

commit 38e1884df76301b85ab43ba8a000847984e544db
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:17 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 301
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2 this program is distributed
      in the hope that it will be useful but without any warranty without
      even the implied warranty of merchantability or fitness for a
      particular purpose see the gnu general public license for more
      details you should have received a copy of the gnu general public
      license along with this program if not write to the free software
      foundation inc 675 mass ave cambridge ma 02139 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 1 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000433.566744158@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/ethernet/toshiba/ps3_gelic_wireless.h b/drivers/net/ethernet/toshiba/ps3_gelic_wireless.h
index 11f443d8e4ea..4041d946b649 100644
--- a/drivers/net/ethernet/toshiba/ps3_gelic_wireless.h
+++ b/drivers/net/ethernet/toshiba/ps3_gelic_wireless.h
@@ -1,21 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  *  PS3 gelic network driver.
  *
  * Copyright (C) 2007 Sony Computer Entertainment Inc.
  * Copyright 2007 Sony Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation version 2.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 #ifndef _GELIC_WIRELESS_H
 #define _GELIC_WIRELESS_H

commit 3e0dd1f4722f8e0c10a47b9bbb26e891e79fef60
Author: Joe Perches <joe@perches.com>
Date:   Mon Sep 23 11:37:59 2013 -0700

    toshiba: Remove extern from function prototypes
    
    There are a mix of function prototypes with and without extern
    in the kernel sources.  Standardize on not using extern for
    function prototypes.
    
    Function prototypes don't need to be written with extern.
    extern is assumed by the compiler.  Its use is as unnecessary as
    using auto to declare automatic/local variables in a block.
    
    Signed-off-by: Joe Perches <joe@perches.com>

diff --git a/drivers/net/ethernet/toshiba/ps3_gelic_wireless.h b/drivers/net/ethernet/toshiba/ps3_gelic_wireless.h
index f7e51b7d7049..11f443d8e4ea 100644
--- a/drivers/net/ethernet/toshiba/ps3_gelic_wireless.h
+++ b/drivers/net/ethernet/toshiba/ps3_gelic_wireless.h
@@ -320,7 +320,7 @@ struct gelic_eurus_cmd {
 #define GELIC_WL_PRIV_SET_PSK		(SIOCIWFIRSTPRIV + 0)
 #define GELIC_WL_PRIV_GET_PSK		(SIOCIWFIRSTPRIV + 1)
 
-extern int gelic_wl_driver_probe(struct gelic_card *card);
-extern int gelic_wl_driver_remove(struct gelic_card *card);
-extern void gelic_wl_interrupt(struct net_device *netdev, u64 status);
+int gelic_wl_driver_probe(struct gelic_card *card);
+int gelic_wl_driver_remove(struct gelic_card *card);
+void gelic_wl_interrupt(struct net_device *netdev, u64 status);
 #endif /* _GELIC_WIRELESS_H */

commit 8df158ac36fa0937f51c372f0c2d0ad1b86ebe4c
Author: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Date:   Sat Jul 30 00:36:02 2011 -0700

    toshiba: Move the Toshiba drivers
    
    Move the Toshiba ethernet drivers into drivers/net/ethernet/toshiba
    and make the necessary Kconfig and Makefile changes.
    
    CC: Geoff Levand <geoff@infradead.org>
    CC: Jens Osterkamp <Jens.Osterkamp@de.ibm.com>
    CC: Ishizaki Kou <kou.ishizaki@toshiba.co.jp>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/toshiba/ps3_gelic_wireless.h b/drivers/net/ethernet/toshiba/ps3_gelic_wireless.h
new file mode 100644
index 000000000000..f7e51b7d7049
--- /dev/null
+++ b/drivers/net/ethernet/toshiba/ps3_gelic_wireless.h
@@ -0,0 +1,326 @@
+/*
+ *  PS3 gelic network driver.
+ *
+ * Copyright (C) 2007 Sony Computer Entertainment Inc.
+ * Copyright 2007 Sony Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#ifndef _GELIC_WIRELESS_H
+#define _GELIC_WIRELESS_H
+
+#include <linux/wireless.h>
+#include <net/iw_handler.h>
+
+
+/* return value from  GELIC_LV1_GET_WLAN_EVENT netcontrol */
+enum gelic_lv1_wl_event {
+	GELIC_LV1_WL_EVENT_DEVICE_READY   = 0x01, /* Eurus ready */
+	GELIC_LV1_WL_EVENT_SCAN_COMPLETED = 0x02, /* Scan has completed */
+	GELIC_LV1_WL_EVENT_DEAUTH         = 0x04, /* Deauthed by the AP */
+	GELIC_LV1_WL_EVENT_BEACON_LOST    = 0x08, /* Beacon lost detected */
+	GELIC_LV1_WL_EVENT_CONNECTED      = 0x10, /* Connected to AP */
+	GELIC_LV1_WL_EVENT_WPA_CONNECTED  = 0x20, /* WPA connection */
+	GELIC_LV1_WL_EVENT_WPA_ERROR      = 0x40, /* MIC error */
+};
+
+/* arguments for GELIC_LV1_POST_WLAN_COMMAND netcontrol */
+enum gelic_eurus_command {
+	GELIC_EURUS_CMD_ASSOC		=  1, /* association start */
+	GELIC_EURUS_CMD_DISASSOC	=  2, /* disassociate      */
+	GELIC_EURUS_CMD_START_SCAN	=  3, /* scan start        */
+	GELIC_EURUS_CMD_GET_SCAN	=  4, /* get scan result   */
+	GELIC_EURUS_CMD_SET_COMMON_CFG	=  5, /* set common config */
+	GELIC_EURUS_CMD_GET_COMMON_CFG	=  6, /* set common config */
+	GELIC_EURUS_CMD_SET_WEP_CFG	=  7, /* set WEP config    */
+	GELIC_EURUS_CMD_GET_WEP_CFG	=  8, /* get WEP config    */
+	GELIC_EURUS_CMD_SET_WPA_CFG	=  9, /* set WPA config    */
+	GELIC_EURUS_CMD_GET_WPA_CFG	= 10, /* get WPA config    */
+	GELIC_EURUS_CMD_GET_RSSI_CFG	= 11, /* get RSSI info.    */
+	GELIC_EURUS_CMD_MAX_INDEX
+};
+
+/* for GELIC_EURUS_CMD_COMMON_CFG */
+enum gelic_eurus_bss_type {
+	GELIC_EURUS_BSS_INFRA = 0,
+	GELIC_EURUS_BSS_ADHOC = 1, /* not supported */
+};
+
+enum gelic_eurus_auth_method {
+	GELIC_EURUS_AUTH_OPEN = 0, /* FIXME: WLAN_AUTH_OPEN */
+	GELIC_EURUS_AUTH_SHARED = 1, /* not supported */
+};
+
+enum gelic_eurus_opmode {
+	GELIC_EURUS_OPMODE_11BG = 0, /* 802.11b/g */
+	GELIC_EURUS_OPMODE_11B = 1, /* 802.11b only */
+	GELIC_EURUS_OPMODE_11G = 2, /* 802.11g only */
+};
+
+struct gelic_eurus_common_cfg {
+	/* all fields are big endian */
+	u16 scan_index;
+	u16 bss_type;    /* infra or adhoc */
+	u16 auth_method; /* shared key or open */
+	u16 op_mode; /* B/G */
+} __packed;
+
+
+/* for GELIC_EURUS_CMD_WEP_CFG */
+enum gelic_eurus_wep_security {
+	GELIC_EURUS_WEP_SEC_NONE	= 0,
+	GELIC_EURUS_WEP_SEC_40BIT	= 1,
+	GELIC_EURUS_WEP_SEC_104BIT	= 2,
+};
+
+struct gelic_eurus_wep_cfg {
+	/* all fields are big endian */
+	u16 security;
+	u8 key[4][16];
+} __packed;
+
+/* for GELIC_EURUS_CMD_WPA_CFG */
+enum gelic_eurus_wpa_security {
+	GELIC_EURUS_WPA_SEC_NONE		= 0x0000,
+	/* group=TKIP, pairwise=TKIP */
+	GELIC_EURUS_WPA_SEC_WPA_TKIP_TKIP	= 0x0001,
+	/* group=AES, pairwise=AES */
+	GELIC_EURUS_WPA_SEC_WPA_AES_AES		= 0x0002,
+	/* group=TKIP, pairwise=TKIP */
+	GELIC_EURUS_WPA_SEC_WPA2_TKIP_TKIP	= 0x0004,
+	/* group=AES, pairwise=AES */
+	GELIC_EURUS_WPA_SEC_WPA2_AES_AES	= 0x0008,
+	/* group=TKIP, pairwise=AES */
+	GELIC_EURUS_WPA_SEC_WPA_TKIP_AES	= 0x0010,
+	/* group=TKIP, pairwise=AES */
+	GELIC_EURUS_WPA_SEC_WPA2_TKIP_AES	= 0x0020,
+};
+
+enum gelic_eurus_wpa_psk_type {
+	GELIC_EURUS_WPA_PSK_PASSPHRASE	= 0, /* passphrase string   */
+	GELIC_EURUS_WPA_PSK_BIN		= 1, /* 32 bytes binary key */
+};
+
+#define GELIC_WL_EURUS_PSK_MAX_LEN	64
+#define WPA_PSK_LEN			32 /* WPA spec says 256bit */
+
+struct gelic_eurus_wpa_cfg {
+	/* all fields are big endian */
+	u16 security;
+	u16 psk_type; /* psk key encoding type */
+	u8 psk[GELIC_WL_EURUS_PSK_MAX_LEN]; /* psk key; hex or passphrase */
+} __packed;
+
+/* for GELIC_EURUS_CMD_{START,GET}_SCAN */
+enum gelic_eurus_scan_capability {
+	GELIC_EURUS_SCAN_CAP_ADHOC	= 0x0000,
+	GELIC_EURUS_SCAN_CAP_INFRA	= 0x0001,
+	GELIC_EURUS_SCAN_CAP_MASK	= 0x0001,
+};
+
+enum gelic_eurus_scan_sec_type {
+	GELIC_EURUS_SCAN_SEC_NONE	= 0x0000,
+	GELIC_EURUS_SCAN_SEC_WEP	= 0x0100,
+	GELIC_EURUS_SCAN_SEC_WPA	= 0x0200,
+	GELIC_EURUS_SCAN_SEC_WPA2	= 0x0400,
+	GELIC_EURUS_SCAN_SEC_MASK	= 0x0f00,
+};
+
+enum gelic_eurus_scan_sec_wep_type {
+	GELIC_EURUS_SCAN_SEC_WEP_UNKNOWN	= 0x0000,
+	GELIC_EURUS_SCAN_SEC_WEP_40		= 0x0001,
+	GELIC_EURUS_SCAN_SEC_WEP_104		= 0x0002,
+	GELIC_EURUS_SCAN_SEC_WEP_MASK		= 0x0003,
+};
+
+enum gelic_eurus_scan_sec_wpa_type {
+	GELIC_EURUS_SCAN_SEC_WPA_UNKNOWN	= 0x0000,
+	GELIC_EURUS_SCAN_SEC_WPA_TKIP		= 0x0001,
+	GELIC_EURUS_SCAN_SEC_WPA_AES		= 0x0002,
+	GELIC_EURUS_SCAN_SEC_WPA_MASK		= 0x0003,
+};
+
+/*
+ * hw BSS information structure returned from GELIC_EURUS_CMD_GET_SCAN
+ */
+struct gelic_eurus_scan_info {
+	/* all fields are big endian */
+	__be16 size;
+	__be16 rssi; /* percentage */
+	__be16 channel; /* channel number */
+	__be16 beacon_period; /* FIXME: in msec unit */
+	__be16 capability;
+	__be16 security;
+	u8  bssid[8]; /* last ETH_ALEN are valid. bssid[0],[1] are unused */
+	u8  essid[32]; /* IW_ESSID_MAX_SIZE */
+	u8  rate[16]; /* first 12 are valid */
+	u8  ext_rate[16]; /* first 16 are valid */
+	__be32 reserved1;
+	__be32 reserved2;
+	__be32 reserved3;
+	__be32 reserved4;
+	u8 elements[0]; /* ie */
+} __packed;
+
+/* the hypervisor returns bbs up to 16 */
+#define GELIC_EURUS_MAX_SCAN  (16)
+struct gelic_wl_scan_info {
+	struct list_head list;
+	struct gelic_eurus_scan_info *hwinfo;
+
+	int valid; /* set 1 if this entry was in latest scanned list
+		     * from Eurus */
+	unsigned int eurus_index; /* index in the Eurus list */
+	unsigned long last_scanned; /* acquired time */
+
+	unsigned int rate_len;
+	unsigned int rate_ext_len;
+	unsigned int essid_len;
+};
+
+/* for GELIC_EURUS_CMD_GET_RSSI */
+struct gelic_eurus_rssi_info {
+	/* big endian */
+	__be16 rssi;
+} __packed;
+
+
+/* for 'stat' member of gelic_wl_info */
+enum gelic_wl_info_status_bit {
+	GELIC_WL_STAT_CONFIGURED,
+	GELIC_WL_STAT_CH_INFO,   /* ch info acquired */
+	GELIC_WL_STAT_ESSID_SET, /* ESSID specified by userspace */
+	GELIC_WL_STAT_BSSID_SET, /* BSSID specified by userspace */
+	GELIC_WL_STAT_WPA_PSK_SET, /* PMK specified by userspace */
+	GELIC_WL_STAT_WPA_LEVEL_SET, /* WEP or WPA[2] selected */
+};
+
+/* for 'scan_stat' member of gelic_wl_info */
+enum gelic_wl_scan_state {
+	/* just initialized or get last scan result failed */
+	GELIC_WL_SCAN_STAT_INIT,
+	/* scan request issued, accepted or chip is scanning */
+	GELIC_WL_SCAN_STAT_SCANNING,
+	/* scan results retrieved */
+	GELIC_WL_SCAN_STAT_GOT_LIST,
+};
+
+/* for 'cipher_method' */
+enum gelic_wl_cipher_method {
+	GELIC_WL_CIPHER_NONE,
+	GELIC_WL_CIPHER_WEP,
+	GELIC_WL_CIPHER_TKIP,
+	GELIC_WL_CIPHER_AES,
+};
+
+/* for 'wpa_level' */
+enum gelic_wl_wpa_level {
+	GELIC_WL_WPA_LEVEL_NONE,
+	GELIC_WL_WPA_LEVEL_WPA,
+	GELIC_WL_WPA_LEVEL_WPA2,
+};
+
+/* for 'assoc_stat' */
+enum gelic_wl_assoc_state {
+	GELIC_WL_ASSOC_STAT_DISCONN,
+	GELIC_WL_ASSOC_STAT_ASSOCIATING,
+	GELIC_WL_ASSOC_STAT_ASSOCIATED,
+};
+/* part of private data alloc_etherdev() allocated */
+#define GELIC_WEP_KEYS 4
+struct gelic_wl_info {
+	/* bss list */
+	struct mutex scan_lock;
+	struct list_head network_list;
+	struct list_head network_free_list;
+	struct gelic_wl_scan_info *networks;
+
+	unsigned long scan_age; /* last scanned time */
+	enum gelic_wl_scan_state scan_stat;
+	struct completion scan_done;
+
+	/* eurus command queue */
+	struct workqueue_struct *eurus_cmd_queue;
+	struct completion cmd_done_intr;
+
+	/* eurus event handling */
+	struct workqueue_struct *event_queue;
+	struct delayed_work event_work;
+
+	/* wl status bits */
+	unsigned long stat;
+	enum gelic_eurus_auth_method auth_method; /* open/shared */
+	enum gelic_wl_cipher_method group_cipher_method;
+	enum gelic_wl_cipher_method pairwise_cipher_method;
+	enum gelic_wl_wpa_level wpa_level; /* wpa/wpa2 */
+
+	/* association handling */
+	struct mutex assoc_stat_lock;
+	struct delayed_work assoc_work;
+	enum gelic_wl_assoc_state assoc_stat;
+	struct completion assoc_done;
+
+	spinlock_t lock;
+	u16 ch_info; /* available channels. bit0 = ch1 */
+	/* WEP keys */
+	u8 key[GELIC_WEP_KEYS][IW_ENCODING_TOKEN_MAX];
+	unsigned long key_enabled;
+	unsigned int key_len[GELIC_WEP_KEYS];
+	unsigned int current_key;
+	/* WWPA PSK */
+	u8 psk[GELIC_WL_EURUS_PSK_MAX_LEN];
+	enum gelic_eurus_wpa_psk_type psk_type;
+	unsigned int psk_len;
+
+	u8 essid[IW_ESSID_MAX_SIZE];
+	u8 bssid[ETH_ALEN]; /* userland requested */
+	u8 active_bssid[ETH_ALEN]; /* associated bssid */
+	unsigned int essid_len;
+
+	struct iw_public_data wireless_data;
+	struct iw_statistics iwstat;
+};
+
+#define GELIC_WL_BSS_MAX_ENT 32
+#define GELIC_WL_ASSOC_RETRY 50
+static inline struct gelic_port *wl_port(struct gelic_wl_info *wl)
+{
+	return container_of((void *)wl, struct gelic_port, priv);
+}
+static inline struct gelic_wl_info *port_wl(struct gelic_port *port)
+{
+	return port_priv(port);
+}
+
+struct gelic_eurus_cmd {
+	struct work_struct work;
+	struct gelic_wl_info *wl;
+	unsigned int cmd; /* command code */
+	u64 tag;
+	u64 size;
+	void *buffer;
+	unsigned int buf_size;
+	struct completion done;
+	int status;
+	u64 cmd_status;
+};
+
+/* private ioctls to pass PSK */
+#define GELIC_WL_PRIV_SET_PSK		(SIOCIWFIRSTPRIV + 0)
+#define GELIC_WL_PRIV_GET_PSK		(SIOCIWFIRSTPRIV + 1)
+
+extern int gelic_wl_driver_probe(struct gelic_card *card);
+extern int gelic_wl_driver_remove(struct gelic_card *card);
+extern void gelic_wl_interrupt(struct net_device *netdev, u64 status);
+#endif /* _GELIC_WIRELESS_H */
