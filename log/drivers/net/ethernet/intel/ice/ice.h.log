commit 28bf26724fdb0e02267d19e280d6717ee810a10d
Author: Brett Creeley <brett.creeley@intel.com>
Date:   Mon May 11 18:01:46 2020 -0700

    ice: Implement aRFS
    
    Enable accelerated Receive Flow Steering (aRFS). It is used to steer Rx
    flows to a specific queue. This functionality is triggered by the network
    stack through ndo_rx_flow_steer and requires Flow Director (ntuple on) to
    function.
    
    The fltr_info is used to add/remove/update flow rules in the HW, the
    fltr_state is used to determine what to do with the filter with respect
    to HW and/or SW, and the flow_id is used in co-ordination with the
    network stack.
    
    The work for aRFS is split into two paths: the ndo_rx_flow_steer
    operation and the ice_service_task. The former is where the kernel hands
    us an Rx SKB among other items to setup aRFS and the latter is where
    the driver adds/updates/removes filter rules from HW and updates filter
    state.
    
    In the Rx path the following things can happen:
            1. New aRFS entries are added to the hash table and the state is
               set to ICE_ARFS_INACTIVE so the filter can be updated in HW
               by the ice_service_task path.
            2. aRFS entries have their Rx Queue updated if we receive a
               pre-existing flow_id and the filter state is ICE_ARFS_ACTIVE.
               The state is set to ICE_ARFS_INACTIVE so the filter can be
               updated in HW by the ice_service_task path.
            3. aRFS entries marked as ICE_ARFS_TODEL are deleted
    
    In the ice_service_task path the following things can happen:
            1. New aRFS entries marked as ICE_ARFS_INACTIVE are added or
               updated in HW.
               and their state is updated to ICE_ARFS_ACTIVE.
            2. aRFS entries are deleted from HW and their state is updated
               to ICE_ARFS_TODEL.
    
    Signed-off-by: Brett Creeley <brett.creeley@intel.com>
    Signed-off-by: Madhu Chittim <madhu.chittim@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 38739ee8cd94..5792ee616b5c 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -34,6 +34,7 @@
 #include <linux/ctype.h>
 #include <linux/bpf.h>
 #include <linux/avf/virtchnl.h>
+#include <linux/cpu_rmap.h>
 #include <net/devlink.h>
 #include <net/ipv6.h>
 #include <net/xdp_sock.h>
@@ -52,6 +53,7 @@
 #include "ice_sriov.h"
 #include "ice_fdir.h"
 #include "ice_xsk.h"
+#include "ice_arfs.h"
 
 extern const char ice_drv_ver[];
 #define ICE_BAR0		0
@@ -271,6 +273,14 @@ struct ice_vsi {
 	u8 *rss_lut_user;	/* User configured lookup table entries */
 	u8 rss_lut_type;	/* used to configure Get/Set RSS LUT AQ call */
 
+	/* aRFS members only allocated for the PF VSI */
+#define ICE_MAX_ARFS_LIST	1024
+#define ICE_ARFS_LST_MASK	(ICE_MAX_ARFS_LIST - 1)
+	struct hlist_head *arfs_fltr_list;
+	struct ice_arfs_active_fltr_cntrs *arfs_fltr_cntrs;
+	spinlock_t arfs_lock;	/* protects aRFS hash table and filter state */
+	atomic_t *arfs_last_fltr_id;
+
 	u16 max_frame;
 	u16 rx_buf_len;
 
@@ -558,6 +568,9 @@ int ice_schedule_reset(struct ice_pf *pf, enum ice_reset_req reset);
 void ice_print_link_msg(struct ice_vsi *vsi, bool isup);
 const char *ice_stat_str(enum ice_status stat_err);
 const char *ice_aq_str(enum ice_aq_err aq_err);
+int
+ice_fdir_write_fltr(struct ice_pf *pf, struct ice_fdir_fltr *input, bool add,
+		    bool is_tun);
 void ice_vsi_manage_fdir(struct ice_vsi *vsi, bool ena);
 int ice_add_fdir_ethtool(struct ice_vsi *vsi, struct ethtool_rxnfc *cmd);
 int ice_del_fdir_ethtool(struct ice_vsi *vsi, struct ethtool_rxnfc *cmd);
@@ -571,5 +584,6 @@ void ice_fdir_replay_fltrs(struct ice_pf *pf);
 int ice_fdir_create_dflt_rules(struct ice_pf *pf);
 int ice_open(struct net_device *netdev);
 int ice_stop(struct net_device *netdev);
+void ice_service_task_schedule(struct ice_pf *pf);
 
 #endif /* _ICE_H_ */

commit 83af00395190bc2db05a67a417a2ea0d5967b74d
Author: Henry Tieman <henry.w.tieman@intel.com>
Date:   Mon May 11 18:01:45 2020 -0700

    ice: Restore filters following reset
    
    Following a reset, Flow Director filters are cleared from the hardware.
    Rebuild the filters using the software structures containing the filter
    rules.
    
    Signed-off-by: Henry Tieman <henry.w.tieman@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 298a65a3799c..38739ee8cd94 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -566,6 +566,8 @@ int
 ice_get_fdir_fltr_ids(struct ice_hw *hw, struct ethtool_rxnfc *cmd,
 		      u32 *rule_locs);
 void ice_fdir_release_flows(struct ice_hw *hw);
+void ice_fdir_replay_flows(struct ice_hw *hw);
+void ice_fdir_replay_fltrs(struct ice_pf *pf);
 int ice_fdir_create_dflt_rules(struct ice_pf *pf);
 int ice_open(struct net_device *netdev);
 int ice_stop(struct net_device *netdev);

commit cac2a27cd9ab1638e21df11ec583d2bc919a3ae3
Author: Henry Tieman <henry.w.tieman@intel.com>
Date:   Mon May 11 18:01:42 2020 -0700

    ice: Support IPv4 Flow Director filters
    
    Support the addition and deletion of IPv4 filters.
    
    Supported fields are: src-ip, dst-ip, src-port, and dst-port
    Supported flow-types are: tcp4, udp4, sctp4, ip4
    
    Example usage:
    
    ethtool -N eth0 flow-type tcp4 src-ip 192.168.0.55 dst-ip 172.16.0.55 \
    src-port 16 dst-port 12 action 32
    
    Signed-off-by: Henry Tieman <henry.w.tieman@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index e0c9e4a30d82..298a65a3799c 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -96,6 +96,7 @@ extern const char ice_drv_ver[];
 #define ICE_TX_DESC(R, i) (&(((struct ice_tx_desc *)((R)->desc))[i]))
 #define ICE_RX_DESC(R, i) (&(((union ice_32b_rx_flex_desc *)((R)->desc))[i]))
 #define ICE_TX_CTX_DESC(R, i) (&(((struct ice_tx_ctx_desc *)((R)->desc))[i]))
+#define ICE_TX_FDIRDESC(R, i) (&(((struct ice_fltr_desc *)((R)->desc))[i]))
 
 /* Macro for each VSI in a PF */
 #define ice_for_each_vsi(pf, i) \
@@ -216,6 +217,7 @@ enum ice_state {
 	__ICE_CFG_BUSY,
 	__ICE_SERVICE_SCHED,
 	__ICE_SERVICE_DIS,
+	__ICE_FD_FLUSH_REQ,
 	__ICE_OICR_INTR_DIS,		/* Global OICR interrupt disabled */
 	__ICE_MDD_VF_PRINT_PENDING,	/* set when MDD event handle */
 	__ICE_VF_RESETS_DISABLED,	/* disable resets during ice_remove */
@@ -557,6 +559,8 @@ void ice_print_link_msg(struct ice_vsi *vsi, bool isup);
 const char *ice_stat_str(enum ice_status stat_err);
 const char *ice_aq_str(enum ice_aq_err aq_err);
 void ice_vsi_manage_fdir(struct ice_vsi *vsi, bool ena);
+int ice_add_fdir_ethtool(struct ice_vsi *vsi, struct ethtool_rxnfc *cmd);
+int ice_del_fdir_ethtool(struct ice_vsi *vsi, struct ethtool_rxnfc *cmd);
 int ice_get_ethtool_fdir_entry(struct ice_hw *hw, struct ethtool_rxnfc *cmd);
 int
 ice_get_fdir_fltr_ids(struct ice_hw *hw, struct ethtool_rxnfc *cmd,

commit 4ab956462f67763be4049b03a414aa7c9b2d4c96
Author: Henry Tieman <henry.w.tieman@intel.com>
Date:   Mon May 11 18:01:41 2020 -0700

    ice: Support displaying ntuple rules
    
    Add functionality for ethtool --show-ntuple, allowing for filters to be
    displayed when set functionality is added. Add statistics related to
    Flow Director matches and status.
    
    Signed-off-by: Henry Tieman <henry.w.tieman@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index ffd11bc2e5f0..e0c9e4a30d82 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -525,6 +525,11 @@ static inline struct ice_vsi *ice_get_ctrl_vsi(struct ice_pf *pf)
 	return pf->vsi[pf->ctrl_vsi_idx];
 }
 
+#define ICE_FD_STAT_CTR_BLOCK_COUNT	256
+#define ICE_FD_STAT_PF_IDX(base_idx) \
+			((base_idx) * ICE_FD_STAT_CTR_BLOCK_COUNT)
+#define ICE_FD_SB_STAT_IDX(base_idx) ICE_FD_STAT_PF_IDX(base_idx)
+
 int ice_vsi_setup_tx_rings(struct ice_vsi *vsi);
 int ice_vsi_setup_rx_rings(struct ice_vsi *vsi);
 int ice_vsi_open_ctrl(struct ice_vsi *vsi);
@@ -552,6 +557,10 @@ void ice_print_link_msg(struct ice_vsi *vsi, bool isup);
 const char *ice_stat_str(enum ice_status stat_err);
 const char *ice_aq_str(enum ice_aq_err aq_err);
 void ice_vsi_manage_fdir(struct ice_vsi *vsi, bool ena);
+int ice_get_ethtool_fdir_entry(struct ice_hw *hw, struct ethtool_rxnfc *cmd);
+int
+ice_get_fdir_fltr_ids(struct ice_hw *hw, struct ethtool_rxnfc *cmd,
+		      u32 *rule_locs);
 void ice_fdir_release_flows(struct ice_hw *hw);
 int ice_fdir_create_dflt_rules(struct ice_pf *pf);
 int ice_open(struct net_device *netdev);

commit 148beb612031255156d68b342170140524afb36e
Author: Henry Tieman <henry.w.tieman@intel.com>
Date:   Mon May 11 18:01:40 2020 -0700

    ice: Initialize Flow Director resources
    
    Flow Director allows for redirection based on ntuple rules. Rules are
    programmed using the ethtool set-ntuple interface. Supported actions are
    redirect to queue and drop.
    
    Setup the initial framework to process Flow Director filters. Create and
    allocate resources to manage and program filters to the hardware. Filters
    are processed via a sideband interface; a control VSI is created to manage
    communication and process requests through the sideband. Upon allocation of
    resources, update the hardware tables to accept perfect filters.
    
    Signed-off-by: Henry Tieman <henry.w.tieman@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 58d0d6436c7f..ffd11bc2e5f0 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -50,6 +50,7 @@
 #include "ice_sched.h"
 #include "ice_virtchnl_pf.h"
 #include "ice_sriov.h"
+#include "ice_fdir.h"
 #include "ice_xsk.h"
 
 extern const char ice_drv_ver[];
@@ -66,6 +67,7 @@ extern const char ice_drv_ver[];
 #define ICE_AQ_LEN		64
 #define ICE_MBXSQ_LEN		64
 #define ICE_MIN_MSIX		2
+#define ICE_FDIR_MSIX		1
 #define ICE_NO_VSI		0xffff
 #define ICE_VSI_MAP_CONTIG	0
 #define ICE_VSI_MAP_SCATTER	1
@@ -257,6 +259,8 @@ struct ice_vsi {
 	s16 vf_id;			/* VF ID for SR-IOV VSIs */
 
 	u16 ethtype;			/* Ethernet protocol for pause frame */
+	u16 num_gfltr;
+	u16 num_bfltr;
 
 	/* RSS config */
 	u16 rss_table_size;	/* HW RSS table size */
@@ -339,6 +343,7 @@ enum ice_pf_flags {
 	ICE_FLAG_SRIOV_CAPABLE,
 	ICE_FLAG_DCB_CAPABLE,
 	ICE_FLAG_DCB_ENA,
+	ICE_FLAG_FD_ENA,
 	ICE_FLAG_ADV_FEATURES,
 	ICE_FLAG_LINK_DOWN_ON_CLOSE_ENA,
 	ICE_FLAG_NO_MEDIA,
@@ -367,6 +372,8 @@ struct ice_pf {
 	 */
 	u16 sriov_base_vector;
 
+	u16 ctrl_vsi_idx;		/* control VSI index in pf->vsi array */
+
 	struct ice_vsi **vsi;		/* VSIs created by the driver */
 	struct ice_sw *first_sw;	/* first switch created by firmware */
 	/* Virtchnl/SR-IOV config info */
@@ -505,8 +512,22 @@ static inline struct ice_vsi *ice_get_main_vsi(struct ice_pf *pf)
 	return NULL;
 }
 
+/**
+ * ice_get_ctrl_vsi - Get the control VSI
+ * @pf: PF instance
+ */
+static inline struct ice_vsi *ice_get_ctrl_vsi(struct ice_pf *pf)
+{
+	/* if pf->ctrl_vsi_idx is ICE_NO_VSI, control VSI was not set up */
+	if (!pf->vsi || pf->ctrl_vsi_idx == ICE_NO_VSI)
+		return NULL;
+
+	return pf->vsi[pf->ctrl_vsi_idx];
+}
+
 int ice_vsi_setup_tx_rings(struct ice_vsi *vsi);
 int ice_vsi_setup_rx_rings(struct ice_vsi *vsi);
+int ice_vsi_open_ctrl(struct ice_vsi *vsi);
 void ice_set_ethtool_ops(struct net_device *netdev);
 void ice_set_ethtool_safe_mode_ops(struct net_device *netdev);
 u16 ice_get_avail_txq_count(struct ice_pf *pf);
@@ -530,6 +551,9 @@ int ice_schedule_reset(struct ice_pf *pf, enum ice_reset_req reset);
 void ice_print_link_msg(struct ice_vsi *vsi, bool isup);
 const char *ice_stat_str(enum ice_status stat_err);
 const char *ice_aq_str(enum ice_aq_err aq_err);
+void ice_vsi_manage_fdir(struct ice_vsi *vsi, bool ena);
+void ice_fdir_release_flows(struct ice_hw *hw);
+int ice_fdir_create_dflt_rules(struct ice_pf *pf);
 int ice_open(struct net_device *netdev);
 int ice_stop(struct net_device *netdev);
 

commit 53bb66983f34d4ff0af179fe228e2c55e1e45921
Author: Jesse Brandeburg <jesse.brandeburg@intel.com>
Date:   Thu May 7 17:41:06 2020 -0700

    ice: cleanup vf_id signedness
    
    The vf_id variable is dealt with in the code in inconsistent
    ways of sign usage, preventing compilation with -Werror=sign-compare.
    Fix this problem in the code by always treating vf_id as unsigned, since
    there are no valid values of vf_id that are negative.
    
    Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index cd2bf9b8e385..58d0d6436c7f 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -371,7 +371,7 @@ struct ice_pf {
 	struct ice_sw *first_sw;	/* first switch created by firmware */
 	/* Virtchnl/SR-IOV config info */
 	struct ice_vf *vf;
-	int num_alloc_vfs;		/* actual number of VFs allocated */
+	u16 num_alloc_vfs;		/* actual number of VFs allocated */
 	u16 num_vfs_supported;		/* num VFs supported for this PF */
 	u16 num_qps_per_vf;
 	u16 num_msix_per_vf;

commit 88865fc4bbd61e48d04e2747d59b85d2014cca82
Author: Karol Kolacinski <karol.kolacinski@intel.com>
Date:   Thu May 7 17:41:05 2020 -0700

    ice: Fix casting issues
    
    Change min() macros to min_t() which has compare type specified and it
    helps avoid precision loss.
    
    In some cases there was precision loss during calls or assignments.
    Some fields in structs were unnecessarily large and gave multiple
    warnings.
    
    There were also some minor type differences which are now fixed as well as
    some cases where a simple cast was needed.
    
    Callers were were passing data that is a u16 to
    ice_sched_cfg_node_bw_alloc() but the function was truncating that to a u8.
    Fix that by changing the function to take a u16.
    
    Signed-off-by: Karol Kolacinski <karol.kolacinski@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index be90337cabb8..cd2bf9b8e385 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -248,8 +248,8 @@ struct ice_vsi {
 	u32 tx_busy;
 	u32 rx_buf_failed;
 	u32 rx_page_failed;
-	int num_q_vectors;
-	int base_vector;		/* IRQ base for OS reserved vectors */
+	u16 num_q_vectors;
+	u16 base_vector;		/* IRQ base for OS reserved vectors */
 	enum ice_vsi_type type;
 	u16 vsi_num;			/* HW (absolute) index of this VSI */
 	u16 idx;			/* software index in pf->vsi[] */
@@ -390,11 +390,11 @@ struct ice_pf {
 	struct mutex tc_mutex;		/* lock to protect TC changes */
 	u32 msg_enable;
 	u32 hw_csum_rx_error;
-	u32 oicr_idx;		/* Other interrupt cause MSIX vector index */
-	u32 num_avail_sw_msix;	/* remaining MSIX SW vectors left unclaimed */
+	u16 oicr_idx;		/* Other interrupt cause MSIX vector index */
+	u16 num_avail_sw_msix;	/* remaining MSIX SW vectors left unclaimed */
 	u16 max_pf_txqs;	/* Total Tx queues PF wide */
 	u16 max_pf_rxqs;	/* Total Rx queues PF wide */
-	u32 num_lan_msix;	/* Total MSIX vectors for base driver */
+	u16 num_lan_msix;	/* Total MSIX vectors for base driver */
 	u16 num_lan_tx;		/* num LAN Tx queues setup */
 	u16 num_lan_rx;		/* num LAN Rx queues setup */
 	u16 next_vsi;		/* Next free slot in pf->vsi[] - 0-based! */

commit 0fee35774d8f2277cfb101dd1d9d0d5e39015b93
Author: Lihong Yang <lihong.yang@intel.com>
Date:   Thu May 7 17:41:04 2020 -0700

    ice: Provide more meaningful error message
    
    When printing the ice status or AQ error codes, instead of printing out the
    numerical value, provide the description of the error code. This provides
    more info about the issue than a number.
    
    Signed-off-by: Lihong Yang <lihong.yang@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index ce7172901428..be90337cabb8 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -528,6 +528,8 @@ int ice_get_rss(struct ice_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size);
 void ice_fill_rss_lut(u8 *lut, u16 rss_table_size, u16 rss_size);
 int ice_schedule_reset(struct ice_pf *pf, enum ice_reset_req reset);
 void ice_print_link_msg(struct ice_vsi *vsi, bool isup);
+const char *ice_stat_str(enum ice_status stat_err);
+const char *ice_aq_str(enum ice_aq_err aq_err);
 int ice_open(struct net_device *netdev);
 int ice_stop(struct net_device *netdev);
 

commit 01b5e89aab498dad5a38d04a71beca2b562d9449
Author: Brett Creeley <brett.creeley@intel.com>
Date:   Thu May 7 17:40:59 2020 -0700

    ice: Add VF promiscuous support
    
    Implement promiscuous support for VF VSIs. Behaviour of promiscuous support
    is based on VF trust as well as the, introduced, vf-true-promisc flag.
    
    A trusted VF with vf-true-promisc disabled will be the default VSI, which
    means that all traffic without a matching destination MAC address in the
    device's internal switch will be forwarded to this VF VSI.
    
    A trusted VF with vf-true-promisc enabled will go into "true promiscuous
    mode". This amounts to the VF receiving all ingress and egress traffic
    that hits the device's internal switch.
    
    An untrusted VF will only receive traffic destined for that VF.
    
    The vf-true-promisc-support flag cannot be toggled while any VF is in
    promiscuous mode. This flag should be set prior to loading the iavf driver
    or spawning VF(s).
    
    Signed-off-by: Brett Creeley <brett.creeley@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 43349eaa02b2..ce7172901428 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -345,6 +345,7 @@ enum ice_pf_flags {
 	ICE_FLAG_FW_LLDP_AGENT,
 	ICE_FLAG_ETHTOOL_CTXT,		/* set when ethtool holds RTNL lock */
 	ICE_FLAG_LEGACY_RX,
+	ICE_FLAG_VF_TRUE_PROMISC_ENA,
 	ICE_FLAG_MDD_AUTO_RESET_VF,
 	ICE_PF_FLAGS_NBITS		/* must be last */
 };

commit a4e82a81f57387803f950cc3d9d112bcc5553a3d
Author: Tony Nguyen <anthony.l.nguyen@intel.com>
Date:   Wed May 6 09:32:30 2020 -0700

    ice: Add support for tunnel offloads
    
    Create a boost TCAM entry for each tunnel port in order to get a tunnel
    PTYPE. Update netdev feature flags and implement the appropriate logic to
    get and set values for hardware offloads.
    
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Signed-off-by: Henry Tieman <henry.w.tieman@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 5c11448bfbb3..43349eaa02b2 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -37,6 +37,10 @@
 #include <net/devlink.h>
 #include <net/ipv6.h>
 #include <net/xdp_sock.h>
+#include <net/geneve.h>
+#include <net/gre.h>
+#include <net/udp_tunnel.h>
+#include <net/vxlan.h>
 #include "ice_devids.h"
 #include "ice_type.h"
 #include "ice_txrx.h"

commit dce730f17825f4814649c1ba7970af5737415c78
Author: Jacob Keller <jacob.e.keller@intel.com>
Date:   Thu Mar 26 11:37:18 2020 -0700

    ice: add a devlink region for dumping NVM contents
    
    Add a devlink region for exposing the device's Non Volatime Memory flash
    contents.
    
    Support the recently added .snapshot operation, enabling userspace to
    request a snapshot of the NVM contents via DEVLINK_CMD_REGION_NEW.
    
    Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
    Reviewed-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 8ce3afcfeca0..5c11448bfbb3 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -351,6 +351,8 @@ struct ice_pf {
 	/* devlink port data */
 	struct devlink_port devlink_port;
 
+	struct devlink_region *nvm_region;
+
 	/* OS reserved IRQ details */
 	struct msix_entry *msix_entries;
 	struct ice_res_tracker *irq_tracker;

commit 1adf7ead8204094516994d18e5aa02e34e4765f2
Author: Jacob Keller <jacob.e.keller@intel.com>
Date:   Wed Mar 11 18:58:15 2020 -0700

    ice: enable initial devlink support
    
    Begin implementing support for the devlink interface with the ice
    driver.
    
    The pf structure is currently memory managed through devres, via
    a devm_alloc. To mimic this behavior, after allocating the devlink
    pointer, use devm_add_action to add a teardown action for releasing the
    devlink memory on exit.
    
    The ice hardware is a multi-function PCIe device. Thus, each physical
    function will get its own devlink instance. This means that each
    function will be treated independently, with its own parameters and
    configuration. This is done because the ice driver loads a separate
    instance for each function.
    
    Due to this, the implementation does not enable devlink to manage
    device-wide resources or configuration, as each physical function will
    be treated independently. This is done for simplicity, as managing
    a devlink instance across multiple driver instances would significantly
    increase the complexity for minimal gain.
    
    Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
    Reviewed-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index ce73a6a96aac..8ce3afcfeca0 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -34,6 +34,7 @@
 #include <linux/ctype.h>
 #include <linux/bpf.h>
 #include <linux/avf/virtchnl.h>
+#include <net/devlink.h>
 #include <net/ipv6.h>
 #include <net/xdp_sock.h>
 #include "ice_devids.h"
@@ -347,6 +348,9 @@ enum ice_pf_flags {
 struct ice_pf {
 	struct pci_dev *pdev;
 
+	/* devlink port data */
+	struct devlink_port devlink_port;
+
 	/* OS reserved IRQ details */
 	struct msix_entry *msix_entries;
 	struct ice_res_tracker *irq_tracker;

commit c8a1071df934934a63e80b0bbd068b37043715e6
Author: Lukasz Czapnik <lukasz.czapnik@intel.com>
Date:   Thu Feb 27 10:15:00 2020 -0800

    ice: Increase mailbox receive queue length to maximum
    
    Currently the PF's mailbox receive queue is only 512 entries. This fine,
    but considering that all VF's mailbox send queues funnel into the PF's
    single mailbox receive queue, let's increase it to the maximum size. This
    will help prevent any possible bottleneck/slowdown occurring from the PF's
    mailbox receive queue being full.
    
    Signed-off-by: Lukasz Czapnik <lukasz.czapnik@intel.com>
    Signed-off-by: Brett Creeley <brett.creeley@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 4d5b1fdb0688..ce73a6a96aac 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -60,7 +60,6 @@ extern const char ice_drv_ver[];
 #define ICE_INT_NAME_STR_LEN	(IFNAMSIZ + 16)
 #define ICE_AQ_LEN		64
 #define ICE_MBXSQ_LEN		64
-#define ICE_MBXRQ_LEN		512
 #define ICE_MIN_MSIX		2
 #define ICE_NO_VSI		0xffff
 #define ICE_VSI_MAP_CONTIG	0

commit f844d5212cb0207334e75bdb94a2add6fb9c8c0b
Author: Brett Creeley <brett.creeley@intel.com>
Date:   Thu Feb 27 10:14:55 2020 -0800

    ice: Fix removing driver while bare-metal VFs pass traffic
    
    Currently, if there are bare-metal VFs passing traffic and the ice
    driver is removed, there is a possibility of VFs triggering a Tx timeout
    right before iavf_remove(). This is causing iavf_close() to not be
    called because there is a check in the beginning of iavf_remove() that
    bails out early if (adapter->state < IAVF_DOWN_PENDING). This makes it
    so some resources do not get cleaned up. Specifically, free_irq()
    is never called for data interrupts, which results in the following line
    of code to trigger:
    
    pci_disable_msix()
            free_msi_irqs()
                    ...
                    BUG_ON(irq_has_action(entry->irq + i));
                    ...
    
    To prevent the Tx timeout from occurring on the VF during driver unload
    for ice and the iavf there are a few changes that are needed.
    
    [1] Don't disable all active VF Tx/Rx queues prior to calling
    pci_disable_sriov.
    
    [2] Call ice_free_vfs() before disabling the service task.
    
    [3] Disable VF resets when the ice driver is being unloaded by setting
    the pf->state flag __ICE_VF_RESETS_DISABLED.
    
    Changing [1] and [2] allow each VF driver's remove flow to successfully
    send VIRTCHNL requests, which includes queue disable. This prevents
    unexpected Tx timeouts because the PF driver is no longer forcefully
    disabling queues.
    
    Due to [1] and [2] there is a possibility that the PF driver will get a
    VFLR or reset request over VIRTCHNL from a VF during PF driver unload.
    Prevent that by doing [3].
    
    Signed-off-by: Brett Creeley <brett.creeley@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index aed3ff31e064..4d5b1fdb0688 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -212,6 +212,7 @@ enum ice_state {
 	__ICE_SERVICE_DIS,
 	__ICE_OICR_INTR_DIS,		/* Global OICR interrupt disabled */
 	__ICE_MDD_VF_PRINT_PENDING,	/* set when MDD event handle */
+	__ICE_VF_RESETS_DISABLED,	/* disable resets during ice_remove */
 	__ICE_STATE_NBITS		/* must be last */
 };
 

commit 46c276cebfb47ec43e17bb0e147f18d0f3e57a28
Author: Brett Creeley <brett.creeley@intel.com>
Date:   Thu Feb 27 10:14:53 2020 -0800

    ice: Improve clarity of prints and variables
    
    Currently when the device runs out of MSI-X interrupts a cryptic and
    unhelpful message is printed. This will cause confusion when hitting this
    case. Fix this by clearing up the error message for both SR-IOV and non
    SR-IOV use cases.
    
    Also, make a few minor changes to increase clarity of variables.
    1. Change per VF MSI-X and queue pair variables in the PF structure.
    2. Use ICE_NONQ_VECS_VF when determining pf->num_msix_per_vf instead of
    the magic number "1". This vector is reserved for the OICR.
    
    All of the resource tracking functions were moved to avoid adding
    any forward declaration function prototypes.
    
    Signed-off-by: Brett Creeley <brett.creeley@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index fac8c14ecc55..aed3ff31e064 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -362,8 +362,8 @@ struct ice_pf {
 	struct ice_vf *vf;
 	int num_alloc_vfs;		/* actual number of VFs allocated */
 	u16 num_vfs_supported;		/* num VFs supported for this PF */
-	u16 num_vf_qps;			/* num queue pairs per VF */
-	u16 num_vf_msix;		/* num vectors per VF */
+	u16 num_qps_per_vf;
+	u16 num_msix_per_vf;
 	/* used to ratelimit the MDD event logging */
 	unsigned long last_printed_mdd_jiffies;
 	DECLARE_BITMAP(state, __ICE_STATE_NBITS);

commit 0ca469fbc3ca8df98921fbf451621b3510dc0a9d
Author: Mitch Williams <mitch.a.williams@intel.com>
Date:   Thu Feb 27 10:14:52 2020 -0800

    ice: allow bigger VFs
    
    Unlike the XL710 series, 800-series hardware can allocate more than 4
    MSI-X vectors per VF. This patch enables that functionality. We
    dynamically allocate vectors and queues depending on how many VFs are
    enabled. Allocating the maximum number of VFs replicates XL710
    behavior with 4 queues and 4 vectors. But allocating a smaller number
    of VFs will give you 16 queues and 16 vectors.
    
    Signed-off-by: Mitch Williams <mitch.a.williams@intel.com>
    Signed-off-by: Brett Creeley <brett.creeley@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 2d51ceaa2c8c..fac8c14ecc55 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -70,7 +70,6 @@ extern const char ice_drv_ver[];
 #define ICE_Q_WAIT_RETRY_LIMIT	10
 #define ICE_Q_WAIT_MAX_RETRY	(5 * ICE_Q_WAIT_RETRY_LIMIT)
 #define ICE_MAX_LG_RSS_QS	256
-#define ICE_MAX_SMALL_RSS_QS	8
 #define ICE_RES_VALID_BIT	0x8000
 #define ICE_RES_MISC_VEC_ID	(ICE_RES_VALID_BIT - 1)
 #define ICE_INVAL_Q_INDEX	0xffff

commit 9d5c5a5290d4d7ae65dcd05e7b986fde4c679ff0
Author: Paul Greenwalt <paul.greenwalt@intel.com>
Date:   Thu Feb 13 13:31:16 2020 -0800

    ice: update malicious driver detection event handling
    
    Update the PF VFs MDD event message to rate limit once per second and
    report the total number Rx|Tx event count. Add support to print pending
    MDD events that occur during the rate limit. The use of net_ratelimit did
    not allow for per VF Rx|Tx granularity.
    
    Additional PF MDD log messages are guarded by netif_msg_[rx|tx]_err().
    
    Since VF RX MDD events disable the queue, add ethtool private flag
    mdd-auto-reset-vf to configure VF reset to re-enable the queue.
    
    Disable anti-spoof detection interrupt to prevent spurious events
    during a function reset.
    
    To avoid race condition do not make PF MDD register reads conditional
    on global MDD result.
    
    Signed-off-by: Paul Greenwalt <paul.greenwalt@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index cb10abb14e11..2d51ceaa2c8c 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -212,6 +212,7 @@ enum ice_state {
 	__ICE_SERVICE_SCHED,
 	__ICE_SERVICE_DIS,
 	__ICE_OICR_INTR_DIS,		/* Global OICR interrupt disabled */
+	__ICE_MDD_VF_PRINT_PENDING,	/* set when MDD event handle */
 	__ICE_STATE_NBITS		/* must be last */
 };
 
@@ -340,6 +341,7 @@ enum ice_pf_flags {
 	ICE_FLAG_FW_LLDP_AGENT,
 	ICE_FLAG_ETHTOOL_CTXT,		/* set when ethtool holds RTNL lock */
 	ICE_FLAG_LEGACY_RX,
+	ICE_FLAG_MDD_AUTO_RESET_VF,
 	ICE_PF_FLAGS_NBITS		/* must be last */
 };
 
@@ -363,6 +365,8 @@ struct ice_pf {
 	u16 num_vfs_supported;		/* num VFs supported for this PF */
 	u16 num_vf_qps;			/* num queue pairs per VF */
 	u16 num_vf_msix;		/* num vectors per VF */
+	/* used to ratelimit the MDD event logging */
+	unsigned long last_printed_mdd_jiffies;
 	DECLARE_BITMAP(state, __ICE_STATE_NBITS);
 	DECLARE_BITMAP(flags, ICE_PF_FLAGS_NBITS);
 	unsigned long *avail_txqs;	/* bitmap to track PF Tx queue usage */

commit 65bb559b6c11dfe3311d1b77ba5a4b8b34a3ec75
Author: Krzysztof Kazimierczak <krzysztof.kazimierczak@intel.com>
Date:   Thu Dec 12 03:13:06 2019 -0800

    ice: Add a boundary check in ice_xsk_umem()
    
    In ice_xsk_umem(), variable qid which is later used as an array index,
    is not validated for a possible boundary exceedance. Because of that,
    a calling function might receive an invalid address, which causes
    general protection fault when dereferenced.
    
    To address this, add a boundary check to see if qid is greater than the
    size of a UMEM array. Also, don't let user change vsi->num_xsk_umems
    just by trying to setup a second UMEM if its value is already set up
    (i.e. UMEM region has already been allocated for this VSI).
    
    While at it, make sure that ring->zca.free pointer is always zeroed out
    if there is no UMEM on a specified ring.
    
    Signed-off-by: Krzysztof Kazimierczak <krzysztof.kazimierczak@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 1376219a6c7e..cb10abb14e11 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -465,12 +465,13 @@ static inline void ice_set_ring_xdp(struct ice_ring *ring)
 static inline struct xdp_umem *ice_xsk_umem(struct ice_ring *ring)
 {
 	struct xdp_umem **umems = ring->vsi->xsk_umems;
-	int qid = ring->q_index;
+	u16 qid = ring->q_index;
 
 	if (ice_ring_is_xdp(ring))
 		qid -= ring->vsi->num_xdp_txq;
 
-	if (!umems || !umems[qid] || !ice_is_xdp_ena_vsi(ring->vsi))
+	if (qid >= ring->vsi->num_xsk_umems || !umems || !umems[qid] ||
+	    !ice_is_xdp_ena_vsi(ring->vsi))
 		return NULL;
 
 	return umems[qid];

commit fc0f39bcb50cd4a414ee5d5fef5208a7d04c4c32
Author: Brett Creeley <brett.creeley@intel.com>
Date:   Thu Dec 12 03:12:55 2019 -0800

    ice: Add code to keep track of current dflt_vsi
    
    We can't have more than one default VSI so prevent another VSI from
    overwriting the current dflt_vsi. This was achieved by adding the
    following functions:
    
    ice_is_dflt_vsi_in_use()
    - Used to check if the default VSI is already being used.
    
    ice_is_vsi_dflt_vsi()
    - Used to check if VSI passed in is in fact the default VSI.
    
    ice_set_dflt_vsi()
    - Used to set the default VSI via a switch rule
    
    ice_clear_dflt_vsi()
    - Used to clear the default VSI via a switch rule.
    
    Also, there was no need to introduce any locking because all mailbox
    events and synchronization of switch filters for the PF happen in the
    service task.
    
    Signed-off-by: Brett Creeley <brett.creeley@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 54b2c349c195..1376219a6c7e 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -174,6 +174,8 @@ struct ice_sw {
 	struct ice_pf *pf;
 	u16 sw_id;		/* switch ID for this switch */
 	u16 bridge_mode;	/* VEB/VEPA/Port Virtualizer */
+	struct ice_vsi *dflt_vsi;	/* default VSI for this switch */
+	u8 dflt_vsi_ena:1;	/* true if above dflt_vsi is enabled */
 };
 
 enum ice_state {

commit cd6d6b83316a9cd2cb97df2bb0bbe617e832d0df
Author: Brett Creeley <brett.creeley@intel.com>
Date:   Thu Dec 12 03:12:54 2019 -0800

    ice: Fix VF spoofchk
    
    There are many things wrong with the function
    ice_set_vf_spoofchk().
    
    1. The VSI being modified is the PF VSI, not the VF VSI.
    2. We are enabling Rx VLAN pruning instead of Tx VLAN anti-spoof.
    3. The spoofchk setting for each VF is not initialized correctly
       or re-initialized correctly on reset.
    
    To fix [1] we need to make sure we are modifying the VF VSI.
    This is done by using the vf->lan_vsi_idx to index into the PF's
    VSI array.
    
    To fix [2] replace setting Rx VLAN pruning in ice_set_vf_spoofchk()
    with setting Tx VLAN anti-spoof.
    
    To Fix [3] we need to make sure the initial VSI settings match what
    is done in ice_set_vf_spoofchk() for spoofchk=on. Also make sure
    this also works for VF reset. This was done by modifying ice_vsi_init()
    to account for the current spoofchk state of the VF VSI.
    
    Because of these changes, Tx VLAN anti-spoof needs to be removed
    from ice_cfg_vlan_pruning(). This is okay for the VF because this
    is now controlled from the admin enabling/disabling spoofchk. For the
    PF, Tx VLAN anti-spoof should not be set. This change requires us to
    call ice_set_vf_spoofchk() when configuring promiscuous mode for
    the VF which requires ice_set_vf_spoofchk() to move in order to prevent
    a forward declaration prototype.
    
    Also, add VLAN 0 by default when allocating a VF since the PF is unaware
    if the guest OS is running the 8021q module. Without this, MDD events will
    trigger on untagged traffic because spoofcheck is enabled by default. Due
    to this change, ignore add/delete messages for VLAN 0 from VIRTCHNL since
    this is added/deleted during VF initialization/teardown respectively and
    should not be modified.
    
    Signed-off-by: Brett Creeley <brett.creeley@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index f972dce8aebb..54b2c349c195 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -275,6 +275,7 @@ struct ice_vsi {
 	u8 current_isup:1;		 /* Sync 'link up' logging */
 	u8 stat_offsets_loaded:1;
 	u8 vlan_ena:1;
+	u16 num_vlan;
 
 	/* queue information */
 	u8 tx_mapping_mode;		 /* ICE_MAP_MODE_[CONTIG|SCATTER] */

commit 87324e747fde7693620f6d4c74aa11b7551e096d
Author: Henry Tieman <henry.w.tieman@intel.com>
Date:   Fri Nov 8 06:23:29 2019 -0800

    ice: Implement ethtool ops for channels
    
    Add code to query and set the number of channels on the primary VSI for a
    PF. This is accessed from the 'ethtool -l' and 'ethtool -L' commands,
    respectively.  Though the ice driver supports asymmetric queues report an
    IRQ vector that has both Rx and Tx queues attached and is counted as a
    'combined' channel.
    
    Signed-off-by: Henry Tieman <henry.w.tieman@intel.com>
    Co-developed-by: Maciej Fijalkowski <maciej.fijalkowski@intel.com>
    Signed-off-by: Maciej Fijalkowski <maciej.fijalkowski@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index cb7259c27353..f972dce8aebb 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -285,6 +285,8 @@ struct ice_vsi {
 	u16 num_txq;			 /* Used Tx queues */
 	u16 alloc_rxq;			 /* Allocated Rx queues */
 	u16 num_rxq;			 /* Used Rx queues */
+	u16 req_txq;			 /* User requested Tx queues */
+	u16 req_rxq;			 /* User requested Rx queues */
 	u16 num_rx_desc;
 	u16 num_tx_desc;
 	struct ice_tc_cfg tc_cfg;
@@ -491,6 +493,7 @@ void ice_set_ethtool_ops(struct net_device *netdev);
 void ice_set_ethtool_safe_mode_ops(struct net_device *netdev);
 u16 ice_get_avail_txq_count(struct ice_pf *pf);
 u16 ice_get_avail_rxq_count(struct ice_pf *pf);
+int ice_vsi_recfg_qs(struct ice_vsi *vsi, int new_rx, int new_tx);
 void ice_update_vsi_stats(struct ice_vsi *vsi);
 void ice_update_pf_stats(struct ice_pf *pf);
 int ice_up(struct ice_vsi *vsi);
@@ -505,6 +508,7 @@ ice_xdp_xmit(struct net_device *dev, int n, struct xdp_frame **frames,
 int ice_set_rss(struct ice_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size);
 int ice_get_rss(struct ice_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size);
 void ice_fill_rss_lut(u8 *lut, u16 rss_table_size, u16 rss_size);
+int ice_schedule_reset(struct ice_pf *pf, enum ice_reset_req reset);
 void ice_print_link_msg(struct ice_vsi *vsi, bool isup);
 int ice_open(struct net_device *netdev);
 int ice_stop(struct net_device *netdev);

commit 4015d11e4b9720718de7df28d25c04d08d8b6226
Author: Brett Creeley <brett.creeley@intel.com>
Date:   Fri Nov 8 06:23:26 2019 -0800

    ice: Add ice_pf_to_dev(pf) macro
    
    We use &pf->dev->pdev all over the code. Add a simple
    macro to do this for us. When multiple de-references
    like this are being done add a local struct device
    variable.
    
    Signed-off-by: Brett Creeley <brett.creeley@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 8d7e8fc55585..cb7259c27353 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -130,6 +130,8 @@ extern const char ice_drv_ver[];
 				     ICE_PROMISC_VLAN_TX  | \
 				     ICE_PROMISC_VLAN_RX)
 
+#define ice_pf_to_dev(pf) (&((pf)->pdev->dev))
+
 struct ice_txq_meta {
 	u32 q_teid;	/* Tx-scheduler element identifier */
 	u16 q_id;	/* Entry in VSI's txq_map bitmap */

commit b94b013eb6269526eeb3768101666ba6f526313e
Author: Dave Ertman <david.m.ertman@intel.com>
Date:   Wed Nov 6 02:05:29 2019 -0800

    ice: Implement DCBNL support
    
    Implement interface layer for the DCBNL subsystem. These are the functions
    to support the callbacks defined in the dcbnl_rtnl_ops struct. These
    callbacks are going to be used to interface with the DCB settings of the
    device. Implementation of dcb_nl set functions and supporting SW DCB
    functions.
    
    Signed-off-by: Dave Ertman <david.m.ertman@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 7da4ae9608c4..8d7e8fc55585 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -180,6 +180,7 @@ enum ice_state {
 	__ICE_NEEDS_RESTART,
 	__ICE_PREPARED_FOR_RESET,	/* set by driver when prepared */
 	__ICE_RESET_OICR_RECV,		/* set by driver after rcv reset OICR */
+	__ICE_DCBNL_DEVRESET,		/* set by dcbnl devreset */
 	__ICE_PFR_REQ,			/* set by driver and peers */
 	__ICE_CORER_REQ,		/* set by driver and peers */
 	__ICE_GLOBR_REQ,		/* set by driver and peers */
@@ -365,6 +366,7 @@ struct ice_pf {
 	struct work_struct serv_task;
 	struct mutex avail_q_mutex;	/* protects access to avail_[rx|tx]qs */
 	struct mutex sw_mutex;		/* lock for protecting VSI alloc flow */
+	struct mutex tc_mutex;		/* lock to protect TC changes */
 	u32 msg_enable;
 	u32 hw_csum_rx_error;
 	u32 oicr_idx;		/* Other interrupt cause MSIX vector index */

commit 9d614b6425f844a722630d66b9cb7eb531fd706e
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Wed Nov 6 02:05:27 2019 -0800

    ice: Use ice_ena_vsi and ice_dis_vsi in DCB configuration flow
    
    DCB configuration flow needs to disable and enable only the PF (main)
    VSI, so use ice_ena_vsi and ice_dis_vsi. To avoid the use of ifdef to
    control the staticness of these functions, move them to ice_lib.c.
    
    Also replace the allocate and copy of old_cfg to kmemdup() in
    ice_pf_dcb_cfg().
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index f552a67467aa..7da4ae9608c4 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -502,10 +502,6 @@ int ice_set_rss(struct ice_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size);
 int ice_get_rss(struct ice_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size);
 void ice_fill_rss_lut(u8 *lut, u16 rss_table_size, u16 rss_size);
 void ice_print_link_msg(struct ice_vsi *vsi, bool isup);
-#ifdef CONFIG_DCB
-int ice_pf_ena_all_vsi(struct ice_pf *pf, bool locked);
-void ice_pf_dis_all_vsi(struct ice_pf *pf, bool locked);
-#endif /* CONFIG_DCB */
 int ice_open(struct net_device *netdev);
 int ice_stop(struct net_device *netdev);
 

commit 7237f5b0dba443756e190bdbecd83f9b1377a912
Author: Maciej Fijalkowski <maciej.fijalkowski@intel.com>
Date:   Thu Oct 24 01:11:22 2019 -0700

    ice: introduce legacy Rx flag
    
    Add an ethtool "legacy-rx" priv flag for toggling the Rx path. This
    control knob will be mainly used for build_skb usage as well as buffer
    size/MTU manipulation.
    
    In preparation for adding build_skb support in a way that it takes
    care of how we set the values of max_frame and rx_buf_len fields of
    struct ice_vsi. Specifically, in this patch mentioned fields are set to
    values that will allow us to provide headroom and tailroom in-place.
    
    This can be mostly broken down onto following:
    - for legacy-rx "on" ethtool control knob, old behaviour is kept;
    - for standard 1500 MTU size configure the buffer of size 1536, as
      network stack is expecting the NET_SKB_PAD to be provided and
      NET_IP_ALIGN can have a non-zero value (these can be typically equal
      to 32 and 2, respectively);
    - for larger MTUs go with max_frame set to 9k and configure the 3k
      buffer in case when PAGE_SIZE of underlying arch is less than 8k; 3k
      buffer is implying the need for order 1 page, so that our page
      recycling scheme can still be applied;
    
    With that said, substitute the hardcoded ICE_RXBUF_2048 and PAGE_SIZE
    values in DMA API that we're making use of with rx_ring->rx_buf_len and
    ice_rx_pg_size(rx_ring). The latter is an introduced helper for
    determining the page size based on its order (which was figured out via
    ice_rx_pg_order). Last but not least, take care of truesize calculation.
    
    In the followup patch the headroom/tailroom computation logic will be
    introduced.
    
    This change aligns the buffer and frame configuration with other Intel
    drivers, most importantly with iavf.
    
    Signed-off-by: Maciej Fijalkowski <maciej.fijalkowski@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 1df18fda83e5..f552a67467aa 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -331,6 +331,7 @@ enum ice_pf_flags {
 	ICE_FLAG_NO_MEDIA,
 	ICE_FLAG_FW_LLDP_AGENT,
 	ICE_FLAG_ETHTOOL_CTXT,		/* set when ethtool holds RTNL lock */
+	ICE_FLAG_LEGACY_RX,
 	ICE_PF_FLAGS_NBITS		/* must be last */
 };
 

commit 2d4238f5569722197612656163d824098208519c
Author: Krzysztof Kazimierczak <krzysztof.kazimierczak@intel.com>
Date:   Mon Nov 4 09:38:56 2019 -0800

    ice: Add support for AF_XDP
    
    Add zero copy AF_XDP support.  This patch adds zero copy support for
    Tx and Rx; code for zero copy is added to ice_xsk.h and ice_xsk.c.
    
    For Tx, implement ndo_xsk_wakeup. As with other drivers, reuse
    existing XDP Tx queues for this task, since XDP_REDIRECT guarantees
    mutual exclusion between different NAPI contexts based on CPU ID. In
    turn, a netdev can XDP_REDIRECT to another netdev with a different
    NAPI context, since the operation is bound to a specific core and each
    core has its own hardware ring.
    
    For Rx, allocate frames as MEM_TYPE_ZERO_COPY on queues that AF_XDP is
    enabled.
    
    Signed-off-by: Krzysztof Kazimierczak <krzysztof.kazimierczak@intel.com>
    Co-developed-by: Maciej Fijalkowski <maciej.fijalkowski@intel.com>
    Signed-off-by: Maciej Fijalkowski <maciej.fijalkowski@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index b2451f768707..1df18fda83e5 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -35,6 +35,7 @@
 #include <linux/bpf.h>
 #include <linux/avf/virtchnl.h>
 #include <net/ipv6.h>
+#include <net/xdp_sock.h>
 #include "ice_devids.h"
 #include "ice_type.h"
 #include "ice_txrx.h"
@@ -44,6 +45,7 @@
 #include "ice_sched.h"
 #include "ice_virtchnl_pf.h"
 #include "ice_sriov.h"
+#include "ice_xsk.h"
 
 extern const char ice_drv_ver[];
 #define ICE_BAR0		0
@@ -287,6 +289,9 @@ struct ice_vsi {
 	struct ice_ring **xdp_rings;	 /* XDP ring array */
 	u16 num_xdp_txq;		 /* Used XDP queues */
 	u8 xdp_mapping_mode;		 /* ICE_MAP_MODE_[CONTIG|SCATTER] */
+	struct xdp_umem **xsk_umems;
+	u16 num_xsk_umems_used;
+	u16 num_xsk_umems;
 } ____cacheline_internodealigned_in_smp;
 
 /* struct that defines an interrupt vector */
@@ -440,6 +445,27 @@ static inline void ice_set_ring_xdp(struct ice_ring *ring)
 	ring->flags |= ICE_TX_FLAGS_RING_XDP;
 }
 
+/**
+ * ice_xsk_umem - get XDP UMEM bound to a ring
+ * @ring - ring to use
+ *
+ * Returns a pointer to xdp_umem structure if there is an UMEM present,
+ * NULL otherwise.
+ */
+static inline struct xdp_umem *ice_xsk_umem(struct ice_ring *ring)
+{
+	struct xdp_umem **umems = ring->vsi->xsk_umems;
+	int qid = ring->q_index;
+
+	if (ice_ring_is_xdp(ring))
+		qid -= ring->vsi->num_xdp_txq;
+
+	if (!umems || !umems[qid] || !ice_is_xdp_ena_vsi(ring->vsi))
+		return NULL;
+
+	return umems[qid];
+}
+
 /**
  * ice_get_main_vsi - Get the PF VSI
  * @pf: PF instance

commit efc2214b6047b6f5b4ca53151eba62521b9452d6
Author: Maciej Fijalkowski <maciej.fijalkowski@intel.com>
Date:   Mon Nov 4 09:38:56 2019 -0800

    ice: Add support for XDP
    
    Add support for XDP. Implement ndo_bpf and ndo_xdp_xmit.  Upon load of
    an XDP program, allocate additional Tx rings for dedicated XDP use.
    The following actions are supported: XDP_TX, XDP_DROP, XDP_REDIRECT,
    XDP_PASS, and XDP_ABORTED.
    
    Signed-off-by: Maciej Fijalkowski <maciej.fijalkowski@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 0b5aa8feae26..b2451f768707 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -29,8 +29,10 @@
 #include <linux/ip.h>
 #include <linux/sctp.h>
 #include <linux/ipv6.h>
+#include <linux/pkt_sched.h>
 #include <linux/if_bridge.h>
 #include <linux/ctype.h>
+#include <linux/bpf.h>
 #include <linux/avf/virtchnl.h>
 #include <net/ipv6.h>
 #include "ice_devids.h"
@@ -78,8 +80,7 @@ extern const char ice_drv_ver[];
 
 #define ICE_DFLT_NETIF_M (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK)
 
-#define ICE_MAX_MTU	(ICE_AQ_SET_MAC_FRAME_SIZE_MAX - \
-			(ETH_HLEN + ETH_FCS_LEN + (VLAN_HLEN * 2)))
+#define ICE_MAX_MTU	(ICE_AQ_SET_MAC_FRAME_SIZE_MAX - ICE_ETH_PKT_HDR_PAD)
 
 #define ICE_UP_TABLE_TRANSLATE(val, i) \
 		(((val) << ICE_AQ_VSI_UP_TABLE_UP##i##_S) & \
@@ -282,6 +283,10 @@ struct ice_vsi {
 	u16 num_rx_desc;
 	u16 num_tx_desc;
 	struct ice_tc_cfg tc_cfg;
+	struct bpf_prog *xdp_prog;
+	struct ice_ring **xdp_rings;	 /* XDP ring array */
+	u16 num_xdp_txq;		 /* Used XDP queues */
+	u8 xdp_mapping_mode;		 /* ICE_MAP_MODE_[CONTIG|SCATTER] */
 } ____cacheline_internodealigned_in_smp;
 
 /* struct that defines an interrupt vector */
@@ -425,6 +430,16 @@ static inline struct ice_pf *ice_netdev_to_pf(struct net_device *netdev)
 	return np->vsi->back;
 }
 
+static inline bool ice_is_xdp_ena_vsi(struct ice_vsi *vsi)
+{
+	return !!vsi->xdp_prog;
+}
+
+static inline void ice_set_ring_xdp(struct ice_ring *ring)
+{
+	ring->flags |= ICE_TX_FLAGS_RING_XDP;
+}
+
 /**
  * ice_get_main_vsi - Get the PF VSI
  * @pf: PF instance
@@ -451,6 +466,11 @@ int ice_up(struct ice_vsi *vsi);
 int ice_down(struct ice_vsi *vsi);
 int ice_vsi_cfg(struct ice_vsi *vsi);
 struct ice_vsi *ice_lb_vsi_setup(struct ice_pf *pf, struct ice_port_info *pi);
+int ice_prepare_xdp_rings(struct ice_vsi *vsi, struct bpf_prog *prog);
+int ice_destroy_xdp_rings(struct ice_vsi *vsi);
+int
+ice_xdp_xmit(struct net_device *dev, int n, struct xdp_frame **frames,
+	     u32 flags);
 int ice_set_rss(struct ice_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size);
 int ice_get_rss(struct ice_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size);
 void ice_fill_rss_lut(u8 *lut, u16 rss_table_size, u16 rss_size);

commit eff380aaffedb279b69d160061e2c01f9df5da96
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Thu Oct 24 01:11:17 2019 -0700

    ice: Introduce ice_base.c
    
    Remove a few uses of kernel configuration flags from ice_lib.c by
    introducing a new source file ice_base.c. Also move corresponding
    function prototypes from ice_lib.h to ice_base.h and include ice_base.h
    where required.
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 45e100666049..0b5aa8feae26 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -127,6 +127,14 @@ extern const char ice_drv_ver[];
 				     ICE_PROMISC_VLAN_TX  | \
 				     ICE_PROMISC_VLAN_RX)
 
+struct ice_txq_meta {
+	u32 q_teid;	/* Tx-scheduler element identifier */
+	u16 q_id;	/* Entry in VSI's txq_map bitmap */
+	u16 q_handle;	/* Relative index of Tx queue within TC */
+	u16 vsi_idx;	/* VSI index that Tx queue belongs to */
+	u8 tc;		/* TC number that Tx queue belongs to */
+};
+
 struct ice_tc_info {
 	u16 qoffset;
 	u16 qcount_tx;

commit 462acf6aca85cd4ee3e475f01240144c314f562c
Author: Tony Nguyen <anthony.l.nguyen@intel.com>
Date:   Mon Sep 9 06:47:46 2019 -0700

    ice: Enable DDP package download
    
    Attempt to request an optional device-specific DDP package file
    (one with the PCIe Device Serial Number in its name so that different DDP
    package files can be used on different devices). If the optional package
    file exists, download it to the device. If not, download the default
    package file.
    
    Log an appropriate message based on whether or not a DDP package
    file exists and the return code from the attempt to download it to the
    device.  If the download fails and there is not already a package file on
    the device, go into "Safe Mode" where some features are not supported.
    
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 3a3e69a2bc5a..45e100666049 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -8,6 +8,7 @@
 #include <linux/errno.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/firmware.h>
 #include <linux/netdevice.h>
 #include <linux/compiler.h>
 #include <linux/etherdevice.h>
@@ -307,6 +308,7 @@ enum ice_pf_flags {
 	ICE_FLAG_SRIOV_CAPABLE,
 	ICE_FLAG_DCB_CAPABLE,
 	ICE_FLAG_DCB_ENA,
+	ICE_FLAG_ADV_FEATURES,
 	ICE_FLAG_LINK_DOWN_ON_CLOSE_ENA,
 	ICE_FLAG_NO_MEDIA,
 	ICE_FLAG_FW_LLDP_AGENT,
@@ -404,6 +406,17 @@ ice_irq_dynamic_ena(struct ice_hw *hw, struct ice_vsi *vsi,
 	wr32(hw, GLINT_DYN_CTL(vector), val);
 }
 
+/**
+ * ice_netdev_to_pf - Retrieve the PF struct associated with a netdev
+ * @netdev: pointer to the netdev struct
+ */
+static inline struct ice_pf *ice_netdev_to_pf(struct net_device *netdev)
+{
+	struct ice_netdev_priv *np = netdev_priv(netdev);
+
+	return np->vsi->back;
+}
+
 /**
  * ice_get_main_vsi - Get the PF VSI
  * @pf: PF instance
@@ -421,6 +434,7 @@ static inline struct ice_vsi *ice_get_main_vsi(struct ice_pf *pf)
 int ice_vsi_setup_tx_rings(struct ice_vsi *vsi);
 int ice_vsi_setup_rx_rings(struct ice_vsi *vsi);
 void ice_set_ethtool_ops(struct net_device *netdev);
+void ice_set_ethtool_safe_mode_ops(struct net_device *netdev);
 u16 ice_get_avail_txq_count(struct ice_pf *pf);
 u16 ice_get_avail_rxq_count(struct ice_pf *pf);
 void ice_update_vsi_stats(struct ice_vsi *vsi);

commit 870f805e97d9af3ffa752cd5b9cc6e81bc7d96ad
Author: Lukasz Czapnik <lukasz.czapnik@intel.com>
Date:   Mon Sep 9 06:47:43 2019 -0700

    ice: Fix FW version formatting in dmesg
    
    The FW build id is currently being displayed as an int which doesn't make
    sense. Instead display FW build id as a hex value. Also add other useful
    information to the output such as NVM version, API patch info, and FW
    build hash.
    
    Signed-off-by: Lukasz Czapnik <lukasz.czapnik@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 4cdedcebb163..3a3e69a2bc5a 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -53,7 +53,6 @@ extern const char ice_drv_ver[];
 
 #define ICE_DFLT_TRAFFIC_CLASS	BIT(0)
 #define ICE_INT_NAME_STR_LEN	(IFNAMSIZ + 16)
-#define ICE_ETHTOOL_FWVER_LEN	32
 #define ICE_AQ_LEN		64
 #define ICE_MBXSQ_LEN		64
 #define ICE_MBXRQ_LEN		512

commit e3710a01a869917271718acdc53134ced24d4c82
Author: Paul M Stillwell Jr <paul.m.stillwell.jr@intel.com>
Date:   Mon Sep 9 06:47:42 2019 -0700

    ice: send driver version to firmware
    
    The driver is required to send a version to the firmware
    to indicate that the driver is up. If the driver doesn't
    do this the firmware doesn't behave properly.
    
    Signed-off-by: Paul M Stillwell Jr <paul.m.stillwell.jr@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index b36e1cf0e461..4cdedcebb163 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -29,6 +29,7 @@
 #include <linux/sctp.h>
 #include <linux/ipv6.h>
 #include <linux/if_bridge.h>
+#include <linux/ctype.h>
 #include <linux/avf/virtchnl.h>
 #include <net/ipv6.h>
 #include "ice_devids.h"

commit dd47e1fd8650417af7956c63f46b000ad0e314f5
Author: Jesse Brandeburg <jesse.brandeburg@intel.com>
Date:   Tue Sep 3 01:31:07 2019 -0700

    ice: change default number of receive descriptors
    
    The driver should start out with a reasonable number of descriptors that
    can prevent drops due to a CPU being in a power management state.
    Change the default number of descriptors to 2048.
    The user can always change the value at runtime.  Transmit descriptor
    counts are not modified because they don't need to change due to the
    speed of the interface, or for power managed CPUs, but the code is
    simplified to a fixed value for the transmit default.
    
    Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 6c4faf7551f6..b36e1cf0e461 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -47,23 +47,8 @@ extern const char ice_drv_ver[];
 #define ICE_MIN_NUM_DESC	64
 #define ICE_MAX_NUM_DESC	8160
 #define ICE_DFLT_MIN_RX_DESC	512
-/* if the default number of Rx descriptors between ICE_MAX_NUM_DESC and the
- * number of descriptors to fill up an entire page is greater than or equal to
- * ICE_DFLT_MIN_RX_DESC set it based on page size, otherwise set it to
- * ICE_DFLT_MIN_RX_DESC
- */
-#define ICE_DFLT_NUM_RX_DESC \
-	min_t(u16, ICE_MAX_NUM_DESC, \
-	      max_t(u16, ALIGN(PAGE_SIZE / sizeof(union ice_32byte_rx_desc), \
-			       ICE_REQ_DESC_MULTIPLE), \
-		    ICE_DFLT_MIN_RX_DESC))
-/* set default number of Tx descriptors to the minimum between ICE_MAX_NUM_DESC
- * and the number of descriptors to fill up an entire page
- */
-#define ICE_DFLT_NUM_TX_DESC	min_t(u16, ICE_MAX_NUM_DESC, \
-				      ALIGN(PAGE_SIZE / \
-					    sizeof(struct ice_tx_desc), \
-					    ICE_REQ_DESC_MULTIPLE))
+#define ICE_DFLT_NUM_TX_DESC	256
+#define ICE_DFLT_NUM_RX_DESC	2048
 
 #define ICE_DFLT_TRAFFIC_CLASS	BIT(0)
 #define ICE_INT_NAME_STR_LEN	(IFNAMSIZ + 16)

commit 8c243700ab10a56171858cc9dd17c5d6494a0ed6
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Tue Sep 3 01:31:06 2019 -0700

    ice: Minor refactor in queue management
    
    Remove q_left_tx and q_left_rx from the PF struct as these can be
    obtained by calling ice_get_avail_txq_count and ice_get_avail_rxq_count
    respectively.
    
    The function ice_determine_q_usage is only setting num_lan_tx and
    num_lan_rx in the PF structure, and these are later assigned to
    vsi->alloc_txq and vsi->alloc_rxq respectively. This is an unnecessary
    indirection, so remove ice_determine_q_usage and just assign values
    for vsi->alloc_txq and vsi->alloc_rxq in ice_vsi_set_num_qs and use
    these to set num_lan_tx and num_lan_rx respectively.
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index c7f234688499..6c4faf7551f6 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -368,8 +368,6 @@ struct ice_pf {
 	u32 num_lan_msix;	/* Total MSIX vectors for base driver */
 	u16 num_lan_tx;		/* num LAN Tx queues setup */
 	u16 num_lan_rx;		/* num LAN Rx queues setup */
-	u16 q_left_tx;		/* remaining num Tx queues left unclaimed */
-	u16 q_left_rx;		/* remaining num Rx queues left unclaimed */
 	u16 next_vsi;		/* Next free slot in pf->vsi[] - 0-based! */
 	u16 num_alloc_vsi;
 	u16 corer_count;	/* Core reset count */
@@ -438,6 +436,8 @@ static inline struct ice_vsi *ice_get_main_vsi(struct ice_pf *pf)
 int ice_vsi_setup_tx_rings(struct ice_vsi *vsi);
 int ice_vsi_setup_rx_rings(struct ice_vsi *vsi);
 void ice_set_ethtool_ops(struct net_device *netdev);
+u16 ice_get_avail_txq_count(struct ice_pf *pf);
+u16 ice_get_avail_rxq_count(struct ice_pf *pf);
 void ice_update_vsi_stats(struct ice_vsi *vsi);
 void ice_update_pf_stats(struct ice_pf *pf);
 int ice_up(struct ice_vsi *vsi);

commit 9d56b7fd6a1a2293c61749fa3b6b8a133ade9d44
Author: Jesse Brandeburg <jesse.brandeburg@intel.com>
Date:   Thu Aug 8 07:39:38 2019 -0700

    ice: change work limit to a constant
    
    The driver has supported a transmit work limit
    that was configurable from ethtool for a long time, but
    there are no good use cases for having it be a variable
    that can be changed at run time.  In addition, this
    variable was noted to be causing performance overhead
    due to cache misses.
    
    Just remove the variable and let the code use a constant
    so that the functionality is maintained (a limit on the
    number of transmits that will be cleaned in any one call
    to the clean routines) without the cache miss.
    
    Removes code, removes a variable, removes testing surface. Yay.
    
    Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index bbb3c290a0bf..c7f234688499 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -247,9 +247,6 @@ struct ice_vsi {
 	u16 vsi_num;			/* HW (absolute) index of this VSI */
 	u16 idx;			/* software index in pf->vsi[] */
 
-	/* Interrupt thresholds */
-	u16 work_lmt;
-
 	s16 vf_id;			/* VF ID for SR-IOV VSIs */
 
 	u16 ethtype;			/* Ethernet protocol for pause frame */

commit 208ff75135cd68a42638221626d2af2f8f17a3cb
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Thu Aug 8 07:39:33 2019 -0700

    ice: Add ice_get_main_vsi to get PF/main VSI
    
    There are multiple places where we currently use ice_find_vsi_by_type
    to get the PF (a.k.a. main) VSI. The PF VSI by definition is always
    the first element in the pf->vsi array (i.e. pf->vsi[0]). So instead
    add and use a new helper function ice_get_main_vsi, which just returns
    pf->vsi[0].
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index fb2bc836b20a..bbb3c290a0bf 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -425,21 +425,15 @@ ice_irq_dynamic_ena(struct ice_hw *hw, struct ice_vsi *vsi,
 }
 
 /**
- * ice_find_vsi_by_type - Find and return VSI of a given type
- * @pf: PF to search for VSI
- * @type: Value indicating type of VSI we are looking for
+ * ice_get_main_vsi - Get the PF VSI
+ * @pf: PF instance
+ *
+ * returns pf->vsi[0], which by definition is the PF VSI
  */
-static inline struct ice_vsi *
-ice_find_vsi_by_type(struct ice_pf *pf, enum ice_vsi_type type)
+static inline struct ice_vsi *ice_get_main_vsi(struct ice_pf *pf)
 {
-	int i;
-
-	for (i = 0; i < pf->num_alloc_vsi; i++) {
-		struct ice_vsi *vsi = pf->vsi[i];
-
-		if (vsi && vsi->type == type)
-			return vsi;
-	}
+	if (pf->vsi)
+		return pf->vsi[0];
 
 	return NULL;
 }

commit 78b5713ac12417d796bbdcabf67dd94584f6102b
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Fri Aug 2 01:25:21 2019 -0700

    ice: Alloc queue management bitmaps and arrays dynamically
    
    The total number of queues available on the device is divided between
    multiple physical functions (PF) in the firmware and provided to the
    driver when it gets function capabilities from the firmware. Thus
    each PF knows how many Tx/Rx queues it has. These queues are then
    doled out to different VSIs (for LAN traffic, SR-IOV VF traffic, etc.)
    
    To track usage of these queues at the PF level, the driver uses two
    bitmaps avail_txqs and avail_rxqs. At the VSI level (i.e. struct ice_vsi
    instances) the driver uses two arrays txq_map and rxq_map, to track
    ownership of VSIs' queues in avail_txqs and avail_rxqs respectively.
    
    The aforementioned bitmaps and arrays should be allocated dynamically,
    because the number of queues supported by a PF is only available once
    function capabilities have been queried. The current static allocation
    consumes way more memory than required.
    
    This patch removes the DECLARE_BITMAP for avail_txqs and avail_rxqs
    and instead uses bitmap_zalloc to allocate the bitmaps during init.
    Similarly txq_map and rxq_map are now allocated in ice_vsi_alloc_arrays.
    As a result ICE_MAX_TXQS and ICE_MAX_RXQS defines are no longer needed.
    Also as txq_map and rxq_map are now allocated and freed, some code
    reordering was required in ice_vsi_rebuild for correct functioning.
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 97d0f61cf52b..fb2bc836b20a 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -73,8 +73,6 @@ extern const char ice_drv_ver[];
 #define ICE_MBXRQ_LEN		512
 #define ICE_MIN_MSIX		2
 #define ICE_NO_VSI		0xffff
-#define ICE_MAX_TXQS		2048
-#define ICE_MAX_RXQS		2048
 #define ICE_VSI_MAP_CONTIG	0
 #define ICE_VSI_MAP_SCATTER	1
 #define ICE_MAX_SCATTER_TXQS	16
@@ -284,8 +282,8 @@ struct ice_vsi {
 	/* queue information */
 	u8 tx_mapping_mode;		 /* ICE_MAP_MODE_[CONTIG|SCATTER] */
 	u8 rx_mapping_mode;		 /* ICE_MAP_MODE_[CONTIG|SCATTER] */
-	u16 txq_map[ICE_MAX_TXQS];	 /* index in pf->avail_txqs */
-	u16 rxq_map[ICE_MAX_RXQS];	 /* index in pf->avail_rxqs */
+	u16 *txq_map;			 /* index in pf->avail_txqs */
+	u16 *rxq_map;			 /* index in pf->avail_rxqs */
 	u16 alloc_txq;			 /* Allocated Tx queues */
 	u16 num_txq;			 /* Used Tx queues */
 	u16 alloc_rxq;			 /* Allocated Rx queues */
@@ -355,9 +353,9 @@ struct ice_pf {
 	u16 num_vf_qps;			/* num queue pairs per VF */
 	u16 num_vf_msix;		/* num vectors per VF */
 	DECLARE_BITMAP(state, __ICE_STATE_NBITS);
-	DECLARE_BITMAP(avail_txqs, ICE_MAX_TXQS);
-	DECLARE_BITMAP(avail_rxqs, ICE_MAX_RXQS);
 	DECLARE_BITMAP(flags, ICE_PF_FLAGS_NBITS);
+	unsigned long *avail_txqs;	/* bitmap to track PF Tx queue usage */
+	unsigned long *avail_rxqs;	/* bitmap to track PF Rx queue usage */
 	unsigned long serv_tmr_period;
 	unsigned long serv_tmr_prev;
 	struct timer_list serv_tmr;
@@ -368,6 +366,8 @@ struct ice_pf {
 	u32 hw_csum_rx_error;
 	u32 oicr_idx;		/* Other interrupt cause MSIX vector index */
 	u32 num_avail_sw_msix;	/* remaining MSIX SW vectors left unclaimed */
+	u16 max_pf_txqs;	/* Total Tx queues PF wide */
+	u16 max_pf_rxqs;	/* Total Rx queues PF wide */
 	u32 num_lan_msix;	/* Total MSIX vectors for base driver */
 	u16 num_lan_tx;		/* num LAN Tx queues setup */
 	u16 num_lan_rx;		/* num LAN Rx queues setup */

commit 5a4a8673102761fb87c94ee20633bf1f2a6911ca
Author: Bruce Allan <bruce.w.allan@intel.com>
Date:   Thu Jul 25 02:53:50 2019 -0700

    ice: update ethtool stats on-demand
    
    Users expect ethtool statistics to be updated on-demand when invoking
    'ethtool -S <iface>' instead of providing a snapshot of statistics taken
    once a second (the frequency of the watchdog task where stats are currently
    updated).  Update stats every time 'ethtool -S <iface>' is run.
    
    Also, fix an indentation style issue and an unnecessary local variable
    initialization in ice_get_ethtool_stats() discovered while investigating
    the subject issue.
    
    Signed-off-by: Bruce Allan <bruce.w.allan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 99e0febd8e50..97d0f61cf52b 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -447,6 +447,8 @@ ice_find_vsi_by_type(struct ice_pf *pf, enum ice_vsi_type type)
 int ice_vsi_setup_tx_rings(struct ice_vsi *vsi);
 int ice_vsi_setup_rx_rings(struct ice_vsi *vsi);
 void ice_set_ethtool_ops(struct net_device *netdev);
+void ice_update_vsi_stats(struct ice_vsi *vsi);
+void ice_update_pf_stats(struct ice_pf *pf);
 int ice_up(struct ice_vsi *vsi);
 int ice_down(struct ice_vsi *vsi);
 int ice_vsi_cfg(struct ice_vsi *vsi);

commit 84a118ab58edddf3d29e9972136a4c4a923ea1fa
Author: Dave Ertman <david.m.ertman@intel.com>
Date:   Mon Jul 29 02:04:50 2019 -0700

    ice: Rename ethtool private flag for lldp
    
    The current flag name of "enable-fw-lldp" is a bit cumbersome.
    
    Change priv-flag name to "fw-lldp-agent" with a value of on or
    off.  This is more straight-forward in meaning.
    
    Signed-off-by: Dave Ertman <david.m.ertman@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 9f9c30d29eb5..99e0febd8e50 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -329,7 +329,7 @@ enum ice_pf_flags {
 	ICE_FLAG_DCB_ENA,
 	ICE_FLAG_LINK_DOWN_ON_CLOSE_ENA,
 	ICE_FLAG_NO_MEDIA,
-	ICE_FLAG_ENABLE_FW_LLDP,
+	ICE_FLAG_FW_LLDP_AGENT,
 	ICE_FLAG_ETHTOOL_CTXT,		/* set when ethtool holds RTNL lock */
 	ICE_PF_FLAGS_NBITS		/* must be last */
 };

commit c275684b9250f66e83b1769d76120e03ac964ec4
Author: Akeem G Abodunrin <akeem.g.abodunrin@intel.com>
Date:   Thu Jul 25 01:55:39 2019 -0700

    ice: Move VF resources definition to SR-IOV specific file
    
    In order to use some of the VF resources definition in the SR-IOV specific
    virtchnl header file, this patch moves applicable code to
    ice_virtchnl_pf.h file accordingly... and they should have been defined in
    the destination file originally.
    
    Signed-off-by: Akeem G Abodunrin <akeem.g.abodunrin@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index b60e64c0036b..9f9c30d29eb5 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -87,16 +87,6 @@ extern const char ice_drv_ver[];
 #define ICE_RES_MISC_VEC_ID	(ICE_RES_VALID_BIT - 1)
 #define ICE_INVAL_Q_INDEX	0xffff
 #define ICE_INVAL_VFID		256
-#define ICE_MAX_VF_COUNT	256
-#define ICE_MAX_QS_PER_VF		256
-#define ICE_MIN_QS_PER_VF		1
-#define ICE_DFLT_QS_PER_VF		4
-#define ICE_NONQ_VECS_VF		1
-#define ICE_MAX_SCATTER_QS_PER_VF	16
-#define ICE_MAX_BASE_QS_PER_VF		16
-#define ICE_MAX_INTR_PER_VF		65
-#define ICE_MIN_INTR_PER_VF		(ICE_MIN_QS_PER_VF + 1)
-#define ICE_DFLT_INTR_PER_VF		(ICE_DFLT_QS_PER_VF + 1)
 
 #define ICE_MAX_RESET_WAIT		20
 

commit 11836214d5b7fbfe9df8aeb5dc2b23a6bedf185c
Author: Brett Creeley <brett.creeley@intel.com>
Date:   Thu Jul 25 01:55:38 2019 -0700

    ice: Increase size of Mailbox receive queue for many VFs
    
    Currently we use the ICE_MBXQ_LEN for both the Mailbox send and receive
    queues that are used to communicate with VFs. This is fine for the send
    queue because the PF driver will lock the queue for every single send,
    but for the Mailbox receive queue every VF is posting to its Mailbox
    send queue and the hardware is then handing the message to the PF on its
    Mailbox receive queue. This becomes a problem with many VFs because it
    seems to overburden the Mailbox receive queue on the PF. Fix this by
    increasing the Mailbox receive queue for the PF to 512 entries.
    
    The number 512 was determined based on the number of VFs supported by
    the device. We can have a total of 256 VFs so in the worst case this
    allows the VFs to put 2 messages in the PFs Mailbox receive queue at the
    same time.
    
    Signed-off-by: Brett Creeley <brett.creeley@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index bde0b3617d9b..b60e64c0036b 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -69,7 +69,8 @@ extern const char ice_drv_ver[];
 #define ICE_INT_NAME_STR_LEN	(IFNAMSIZ + 16)
 #define ICE_ETHTOOL_FWVER_LEN	32
 #define ICE_AQ_LEN		64
-#define ICE_MBXQ_LEN		64
+#define ICE_MBXSQ_LEN		64
+#define ICE_MBXRQ_LEN		512
 #define ICE_MIN_MSIX		2
 #define ICE_NO_VSI		0xffff
 #define ICE_MAX_TXQS		2048

commit d82dd83df27e31da3f2a838b32d0b82940dcd504
Author: Akeem G Abodunrin <akeem.g.abodunrin@intel.com>
Date:   Thu Jul 25 01:55:30 2019 -0700

    ice: Restructure VFs initialization flows
    
    This patch restructures how VFs are configured, and resources allocated.
    Instead of freeing resources that were never allocated, and resetting
    empty VFs that have never been created - the new flow will just allocate
    resources for number of requested VFs based on the availability.
    
    During VFs initialization process, global interrupt is disabled, and
    rearmed after getting MSIX vectors for VFs. This allows immediate mailbox
    communications, instead of delaying it till later and VFs.
    PF communications resulted to using polling instead of actual interrupt.
    The issue manifested when creating higher number of VFs (128 VFs) per PF.
    
    Signed-off-by: Akeem G Abodunrin <akeem.g.abodunrin@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 794d97460fc7..bde0b3617d9b 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -220,6 +220,7 @@ enum ice_state {
 	__ICE_CFG_BUSY,
 	__ICE_SERVICE_SCHED,
 	__ICE_SERVICE_DIS,
+	__ICE_OICR_INTR_DIS,		/* Global OICR interrupt disabled */
 	__ICE_STATE_NBITS		/* must be last */
 };
 

commit ba880734ba9c24eca589b3f734d38309568301b2
Author: Brett Creeley <brett.creeley@intel.com>
Date:   Wed Jun 26 02:20:25 2019 -0700

    ice: Remove unnecessary flag ICE_FLAG_MSIX_ENA
    
    This flag is not needed and is called every time we re-enable interrupts
    in the hotpath so remove it. Also remove ice_vsi_req_irq() because it
    was a wrapper function for ice_vsi_req_irq_msix() whose sole purpose was
    checking the ICE_FLAG_MSIX_ENA flag.
    
    Signed-off-by: Brett Creeley <brett.creeley@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 596b09a905aa..794d97460fc7 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -329,7 +329,6 @@ struct ice_q_vector {
 } ____cacheline_internodealigned_in_smp;
 
 enum ice_pf_flags {
-	ICE_FLAG_MSIX_ENA,
 	ICE_FLAG_FLTR_SYNC,
 	ICE_FLAG_RSS_ENA,
 	ICE_FLAG_SRIOV_ENA,

commit 6d5999467df03d1d7fd64ac761ffa20d00ce9e52
Author: Tony Nguyen <anthony.l.nguyen@intel.com>
Date:   Wed Jun 26 02:20:17 2019 -0700

    ice: Do not configure port with no media
    
    The firmware reports an error when trying to configure a port with no
    media. Instead of always configuring the port, check for media before
    attempting to configure it. In the absence of media, turn off link and
    poll for media to become available before re-enabling link.
    
    Move ice_force_phys_link_state() up to avoid forward declaration.
    
    Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 9ee6b55553c0..596b09a905aa 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -337,6 +337,7 @@ enum ice_pf_flags {
 	ICE_FLAG_DCB_CAPABLE,
 	ICE_FLAG_DCB_ENA,
 	ICE_FLAG_LINK_DOWN_ON_CLOSE_ENA,
+	ICE_FLAG_NO_MEDIA,
 	ICE_FLAG_ENABLE_FW_LLDP,
 	ICE_FLAG_ETHTOOL_CTXT,		/* set when ethtool holds RTNL lock */
 	ICE_PF_FLAGS_NBITS		/* must be last */

commit 8be92a76c3e998af76c73ce9349d2e0bbf8782e5
Author: Preethi Banala <preethi.banala@intel.com>
Date:   Tue Apr 16 10:34:56 2019 -0700

    ice: Change minimum descriptor count value for Tx/Rx rings
    
    Change minimum number of descriptor count from 32 to 64. This is to have
    a feature parity with previous Intel NIC drivers.
    
    Signed-off-by: Preethi Banala <preethi.banala@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index c1e4dd7357b4..9ee6b55553c0 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -44,7 +44,7 @@
 extern const char ice_drv_ver[];
 #define ICE_BAR0		0
 #define ICE_REQ_DESC_MULTIPLE	32
-#define ICE_MIN_NUM_DESC	ICE_REQ_DESC_MULTIPLE
+#define ICE_MIN_NUM_DESC	64
 #define ICE_MAX_NUM_DESC	8160
 #define ICE_DFLT_MIN_RX_DESC	512
 /* if the default number of Rx descriptors between ICE_MAX_NUM_DESC and the

commit cbe66bfee6a0b781a7b334003f6d48a92a601164
Author: Brett Creeley <brett.creeley@intel.com>
Date:   Tue Apr 16 10:30:44 2019 -0700

    ice: Refactor interrupt tracking
    
    Currently we have two MSI-x (IRQ) trackers, one for OS requested MSI-x
    entries (sw_irq_tracker) and one for hardware MSI-x vectors
    (hw_irq_tracker). Generally the sw_irq_tracker has less entries than the
    hw_irq_tracker because the hw_irq_tracker has entries equal to the max
    allowed MSI-x per PF and the sw_irq_tracker is mainly the minimum (non
    SR-IOV portion of the vectors, kernel granted IRQs). All of the non
    SR-IOV portions of the driver (i.e. LAN queues, RDMA queues, OICR, etc.)
    take at least one of each type of tracker resource. SR-IOV only grabs
    entries from the hw_irq_tracker. There are a few issues with this approach
    that can be seen when doing any kind of device reconfiguration (i.e.
    ethtool -L, SR-IOV, etc.). One of them being, any time the driver creates
    an ice_q_vector and associates it to a LAN queue pair it will grab and
    use one entry from the hw_irq_tracker and one from the sw_irq_tracker.
    If the indices on these does not match it will cause a Tx timeout, which
    will cause a reset and then the indices will match up again and traffic
    will resume. The mismatched indices come from the trackers not being the
    same size and/or the search_hint in the two trackers not being equal.
    Another reason for the refactor is the co-existence of features with
    SR-IOV. If SR-IOV is enabled and the interrupts are taken from the end
    of the sw_irq_tracker then other features can no longer use this space
    because the hardware has now given the remaining interrupts to SR-IOV.
    
    This patch reworks how we track MSI-x vectors by removing the
    hw_irq_tracker completely and instead MSI-x resources needed for SR-IOV
    are determined all at once instead of per VF. This can be done because
    when creating VFs we know how many are wanted and how many MSI-x vectors
    each VF needs. This also allows us to start using MSI-x resources from
    the end of the PF's allowed MSI-x vectors so we are less likely to use
    entries needed for other features (i.e. RDMA, L2 Offload, etc).
    
    This patch also reworks the ice_res_tracker structure by removing the
    search_hint and adding a new member - "end". Instead of having a
    search_hint we will always search from 0. The new member, "end", will be
    used to manipulate the end of the ice_res_tracker (specifically
    sw_irq_tracker) during runtime based on MSI-x vectors needed by SR-IOV.
    In the normal case, the end of ice_res_tracker will be equal to the
    ice_res_tracker's num_entries.
    
    The sriov_base_vector member was added to the PF structure. It is used
    to represent the starting MSI-x index of all the needed MSI-x vectors
    for all SR-IOV VFs. Depending on how many MSI-x are needed, SR-IOV may
    have to take resources from the sw_irq_tracker. This is done by setting
    the sw_irq_tracker->end equal to the pf->sriov_base_vector. When all
    SR-IOV VFs are removed then the sw_irq_tracker->end is reset back to
    sw_irq_tracker->num_entries. The sriov_base_vector, along with the VF's
    number of MSI-x (pf->num_vf_msix), vf_id, and the base MSI-x index on
    the PF (pf->hw.func_caps.common_cap.msix_vector_first_id), is used to
    calculate the first HW absolute MSI-x index for each VF, which is used
    to write to the VPINT_ALLOC[_PCI] and GLINT_VECT2FUNC registers to
    program the VFs MSI-x PCI configuration bits. Also, the sriov_base_vector
    is used along with VF's num_vf_msix, vf_id, and q_vector->v_idx to
    determine the MSI-x register index (used for writing to GLINT_DYN_CTL)
    within the PF's space.
    
    Interrupt changes removed any references to hw_base_vector, hw_oicr_idx,
    and hw_irq_tracker. Only sw_base_vector, sw_oicr_idx, and sw_irq_tracker
    variables remain. Change all of these by removing the "sw_" prefix to
    help avoid confusion with these variables and their use.
    
    Signed-off-by: Brett Creeley <brett.creeley@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 5c5b9e3e9e5c..c1e4dd7357b4 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -167,7 +167,7 @@ struct ice_tc_cfg {
 
 struct ice_res_tracker {
 	u16 num_entries;
-	u16 search_hint;
+	u16 end;
 	u16 list[1];
 };
 
@@ -252,8 +252,7 @@ struct ice_vsi {
 	u32 rx_buf_failed;
 	u32 rx_page_failed;
 	int num_q_vectors;
-	int sw_base_vector;		/* Irq base for OS reserved vectors */
-	int hw_base_vector;		/* HW (absolute) index of a vector */
+	int base_vector;		/* IRQ base for OS reserved vectors */
 	enum ice_vsi_type type;
 	u16 vsi_num;			/* HW (absolute) index of this VSI */
 	u16 idx;			/* software index in pf->vsi[] */
@@ -348,10 +347,12 @@ struct ice_pf {
 
 	/* OS reserved IRQ details */
 	struct msix_entry *msix_entries;
-	struct ice_res_tracker *sw_irq_tracker;
-
-	/* HW reserved Interrupts for this PF */
-	struct ice_res_tracker *hw_irq_tracker;
+	struct ice_res_tracker *irq_tracker;
+	/* First MSIX vector used by SR-IOV VFs. Calculated by subtracting the
+	 * number of MSIX vectors needed for all SR-IOV VFs from the number of
+	 * MSIX vectors allowed on this PF.
+	 */
+	u16 sriov_base_vector;
 
 	struct ice_vsi **vsi;		/* VSIs created by the driver */
 	struct ice_sw *first_sw;	/* first switch created by firmware */
@@ -373,10 +374,8 @@ struct ice_pf {
 	struct mutex sw_mutex;		/* lock for protecting VSI alloc flow */
 	u32 msg_enable;
 	u32 hw_csum_rx_error;
-	u32 sw_oicr_idx;	/* Other interrupt cause SW vector index */
+	u32 oicr_idx;		/* Other interrupt cause MSIX vector index */
 	u32 num_avail_sw_msix;	/* remaining MSIX SW vectors left unclaimed */
-	u32 hw_oicr_idx;	/* Other interrupt cause vector HW index */
-	u32 num_avail_hw_msix;	/* remaining HW MSIX vectors left unclaimed */
 	u32 num_lan_msix;	/* Total MSIX vectors for base driver */
 	u16 num_lan_tx;		/* num LAN Tx queues setup */
 	u16 num_lan_rx;		/* num LAN Rx queues setup */
@@ -418,7 +417,7 @@ ice_irq_dynamic_ena(struct ice_hw *hw, struct ice_vsi *vsi,
 		    struct ice_q_vector *q_vector)
 {
 	u32 vector = (vsi && q_vector) ? q_vector->reg_idx :
-				((struct ice_pf *)hw->back)->hw_oicr_idx;
+				((struct ice_pf *)hw->back)->oicr_idx;
 	int itr = ICE_ITR_NONE;
 	u32 val;
 

commit 0e674aeb0b7790424716b6ab15d9502e2776c339
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Tue Apr 16 10:30:43 2019 -0700

    ice: Add handler for ethtool selftest
    
    This patch adds a handler for ethtool selftest. Selftest includes
    testing link, interrupts, eeprom, registers and packet loopback.
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 0555d09614d8..5c5b9e3e9e5c 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -189,6 +189,7 @@ struct ice_sw {
 };
 
 enum ice_state {
+	__ICE_TESTING,
 	__ICE_DOWN,
 	__ICE_NEEDS_RESTART,
 	__ICE_PREPARED_FOR_RESET,	/* set by driver when prepared */
@@ -399,6 +400,7 @@ struct ice_pf {
 	unsigned long tx_timeout_last_recovery;
 	u32 tx_timeout_recovery_level;
 	char int_name[ICE_INT_NAME_STR_LEN];
+	u32 sw_int_count;
 };
 
 struct ice_netdev_priv {
@@ -451,9 +453,13 @@ ice_find_vsi_by_type(struct ice_pf *pf, enum ice_vsi_type type)
 	return NULL;
 }
 
+int ice_vsi_setup_tx_rings(struct ice_vsi *vsi);
+int ice_vsi_setup_rx_rings(struct ice_vsi *vsi);
 void ice_set_ethtool_ops(struct net_device *netdev);
 int ice_up(struct ice_vsi *vsi);
 int ice_down(struct ice_vsi *vsi);
+int ice_vsi_cfg(struct ice_vsi *vsi);
+struct ice_vsi *ice_lb_vsi_setup(struct ice_pf *pf, struct ice_port_info *pi);
 int ice_set_rss(struct ice_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size);
 int ice_get_rss(struct ice_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size);
 void ice_fill_rss_lut(u8 *lut, u16 rss_table_size, u16 rss_size);
@@ -462,5 +468,7 @@ void ice_print_link_msg(struct ice_vsi *vsi, bool isup);
 int ice_pf_ena_all_vsi(struct ice_pf *pf, bool locked);
 void ice_pf_dis_all_vsi(struct ice_pf *pf, bool locked);
 #endif /* CONFIG_DCB */
+int ice_open(struct net_device *netdev);
+int ice_stop(struct net_device *netdev);
 
 #endif /* _ICE_H_ */

commit 1aec6e1b0886569c5c6e92d6d5fc25e6779e7f23
Author: Brett Creeley <brett.creeley@intel.com>
Date:   Tue Apr 16 10:30:41 2019 -0700

    ice: Set minimum default Rx descriptor count to 512
    
    Currently we set the default number of Rx descriptors per
    queue to the system's page size divided by the number of bytes per
    descriptor. For 4K page size systems this is resulting in 128 Rx
    descriptors per queue. This is causing more dropped packets than desired
    in the default configuration. Fix this by setting the minimum default
    Rx descriptor count per queue to 512.
    
    Signed-off-by: Brett Creeley <brett.creeley@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index b5990ba0ee4c..0555d09614d8 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -46,13 +46,20 @@ extern const char ice_drv_ver[];
 #define ICE_REQ_DESC_MULTIPLE	32
 #define ICE_MIN_NUM_DESC	ICE_REQ_DESC_MULTIPLE
 #define ICE_MAX_NUM_DESC	8160
-/* set default number of Rx/Tx descriptors to the minimum between
- * ICE_MAX_NUM_DESC and the number of descriptors to fill up an entire page
+#define ICE_DFLT_MIN_RX_DESC	512
+/* if the default number of Rx descriptors between ICE_MAX_NUM_DESC and the
+ * number of descriptors to fill up an entire page is greater than or equal to
+ * ICE_DFLT_MIN_RX_DESC set it based on page size, otherwise set it to
+ * ICE_DFLT_MIN_RX_DESC
+ */
+#define ICE_DFLT_NUM_RX_DESC \
+	min_t(u16, ICE_MAX_NUM_DESC, \
+	      max_t(u16, ALIGN(PAGE_SIZE / sizeof(union ice_32byte_rx_desc), \
+			       ICE_REQ_DESC_MULTIPLE), \
+		    ICE_DFLT_MIN_RX_DESC))
+/* set default number of Tx descriptors to the minimum between ICE_MAX_NUM_DESC
+ * and the number of descriptors to fill up an entire page
  */
-#define ICE_DFLT_NUM_RX_DESC	min_t(u16, ICE_MAX_NUM_DESC, \
-				      ALIGN(PAGE_SIZE / \
-					    sizeof(union ice_32byte_rx_desc), \
-					    ICE_REQ_DESC_MULTIPLE))
 #define ICE_DFLT_NUM_TX_DESC	min_t(u16, ICE_MAX_NUM_DESC, \
 				      ALIGN(PAGE_SIZE / \
 					    sizeof(struct ice_tx_desc), \

commit aa6ccf3f2d7042f94c4e91538956ce7051e7856e
Author: Brett Creeley <brett.creeley@intel.com>
Date:   Tue Apr 16 10:24:37 2019 -0700

    ice: Fix couple of issues in ice_vsi_release
    
    Currently the driver is calling ice_napi_del() and then
    unregister_netdev(). The call to unregister_netdev() will result in a
    call to ice_stop() and then ice_vsi_close(). This is where we call
    napi_disable() for all the MSI-X vectors. This flow is reversed so make
    the changes to ensure napi_disable() happens prior to napi_del().
    
    Before calling napi_del() and free_netdev() make sure
    unregister_netdev() was called. This is done by making sure the
    __ICE_DOWN bit is set in the vsi->state for the interested VSI.
    
    Signed-off-by: Brett Creeley <brett.creeley@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 23e30a69f5fa..b5990ba0ee4c 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -451,7 +451,6 @@ int ice_set_rss(struct ice_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size);
 int ice_get_rss(struct ice_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size);
 void ice_fill_rss_lut(u8 *lut, u16 rss_table_size, u16 rss_size);
 void ice_print_link_msg(struct ice_vsi *vsi, bool isup);
-void ice_napi_del(struct ice_vsi *vsi);
 #ifdef CONFIG_DCB
 int ice_pf_ena_all_vsi(struct ice_pf *pf, bool locked);
 void ice_pf_dis_all_vsi(struct ice_pf *pf, bool locked);

commit 0ab54c5f2fe8929d04d965bc3e05325e37de45ba
Author: Jesse Brandeburg <jesse.brandeburg@intel.com>
Date:   Tue Apr 16 10:24:35 2019 -0700

    ice: Use bitfields when possible
    
    We can use bit fields to store boolean values and when the
    bit fields are next to each other, the compiler will combine them
    (as long as the size holds enough).
    
    Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 7958f2bac8da..23e30a69f5fa 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -277,10 +277,10 @@ struct ice_vsi {
 	struct list_head tmp_sync_list;		/* MAC filters to be synced */
 	struct list_head tmp_unsync_list;	/* MAC filters to be unsynced */
 
-	u8 irqs_ready;
-	u8 current_isup;		 /* Sync 'link up' logging */
-	u8 stat_offsets_loaded;
-	u8 vlan_ena;
+	u8 irqs_ready:1;
+	u8 current_isup:1;		 /* Sync 'link up' logging */
+	u8 stat_offsets_loaded:1;
+	u8 vlan_ena:1;
 
 	/* queue information */
 	u8 tx_mapping_mode;		 /* ICE_MAP_MODE_[CONTIG|SCATTER] */
@@ -384,7 +384,7 @@ struct ice_pf {
 	struct ice_hw_port_stats stats;
 	struct ice_hw_port_stats stats_prev;
 	struct ice_hw hw;
-	u8 stat_prev_loaded;	/* has previous stats been loaded */
+	u8 stat_prev_loaded:1; /* has previous stats been loaded */
 #ifdef CONFIG_DCB
 	u16 dcbx_cap;
 #endif /* CONFIG_DCB */

commit 31eafa403b9945997cf5b321ae3560f072b74efe
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Tue Apr 16 10:24:25 2019 -0700

    ice: Implement LLDP persistence
    
    Implement LLDP persistence across reboots, start and stop of LLDP agent.
    Add additional parameter to ice_aq_start_lldp and ice_aq_stop_lldp.
    
    Also change the ethtool private flag from "disable-fw-lldp" to
    "enable-fw-lldp". This change will flip the boolean logic of the
    functionality of the flag (on = enable, off = disable). The change
    in name and functionality is to differentiate between the
    pre-persistence and post-persistence states.
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 792e6e42030e..7958f2bac8da 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -330,7 +330,7 @@ enum ice_pf_flags {
 	ICE_FLAG_DCB_CAPABLE,
 	ICE_FLAG_DCB_ENA,
 	ICE_FLAG_LINK_DOWN_ON_CLOSE_ENA,
-	ICE_FLAG_DISABLE_FW_LLDP,
+	ICE_FLAG_ENABLE_FW_LLDP,
 	ICE_FLAG_ETHTOOL_CTXT,		/* set when ethtool holds RTNL lock */
 	ICE_PF_FLAGS_NBITS		/* must be last */
 };

commit d95276ced00060dc3d4d157b1eba61eb7830eb02
Author: Akeem G Abodunrin <akeem.g.abodunrin@intel.com>
Date:   Tue Apr 16 10:21:24 2019 -0700

    ice: Add function to program ethertype based filter rule on VSIs
    
    This patch adds function to program VSI with ethertype based filter rule,
    so that all flow control frames would be disallowed from being transmitted
    to the client, in order to prevent malicious VSI, especially VF from
    sending out PAUSE or PFC frames, and then control other VSIs traffic.
    
    Signed-off-by: Akeem G Abodunrin <akeem.g.abodunrin@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 6f970edf50c7..792e6e42030e 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -255,6 +255,8 @@ struct ice_vsi {
 
 	s16 vf_id;			/* VF ID for SR-IOV VSIs */
 
+	u16 ethtype;			/* Ethernet protocol for pause frame */
+
 	/* RSS config */
 	u16 rss_table_size;	/* HW RSS table size */
 	u16 rss_size;		/* Allocated RSS queues */

commit ba0db585bdb696d28bd6ec3ae9908d45c0bdeb37
Author: Michal Swiatkowski <michal.swiatkowski@intel.com>
Date:   Tue Apr 16 10:21:17 2019 -0700

    ice: Add more validation in ice_vc_cfg_irq_map_msg
    
    Add few checks to validate msg from iavf driver.
    
    Test if we have got enough q_vectors allocated in VSI connected with VF.
    Add masks for itr_indx and msix_indx to avoid writing to reserved fieldi
    of QINT. Clear q_vector->num_ring_rx/tx, without it we can increment this
    value every time we send irq map msg from VF. So after second call this
    value will be incorrect.
    
    Decrement num_vectors from msg, because last vector in iavf msg is misc
    vector (we don't set map for it).
    
    Signed-off-by: Michal Swiatkowski <michal.swiatkowski@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 804d12c2f1df..6f970edf50c7 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -83,6 +83,8 @@ extern const char ice_drv_ver[];
 #define ICE_MAX_QS_PER_VF		256
 #define ICE_MIN_QS_PER_VF		1
 #define ICE_DFLT_QS_PER_VF		4
+#define ICE_NONQ_VECS_VF		1
+#define ICE_MAX_SCATTER_QS_PER_VF	16
 #define ICE_MAX_BASE_QS_PER_VF		16
 #define ICE_MAX_INTR_PER_VF		65
 #define ICE_MIN_INTR_PER_VF		(ICE_MIN_QS_PER_VF + 1)

commit c2a23e00613bde4a6d5f88c2b4facd5c7be6be87
Author: Brett Creeley <brett.creeley@intel.com>
Date:   Thu Feb 28 15:26:01 2019 -0800

    ice: Refactor link event flow
    
    Currently the link event flow works, but can be much better.
    Refactor the link event flow to make it cleaner and more clear
    on what is going on.
    
    Signed-off-by: Brett Creeley <brett.creeley@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index d66aad49bfd4..804d12c2f1df 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -420,6 +420,26 @@ ice_irq_dynamic_ena(struct ice_hw *hw, struct ice_vsi *vsi,
 	wr32(hw, GLINT_DYN_CTL(vector), val);
 }
 
+/**
+ * ice_find_vsi_by_type - Find and return VSI of a given type
+ * @pf: PF to search for VSI
+ * @type: Value indicating type of VSI we are looking for
+ */
+static inline struct ice_vsi *
+ice_find_vsi_by_type(struct ice_pf *pf, enum ice_vsi_type type)
+{
+	int i;
+
+	for (i = 0; i < pf->num_alloc_vsi; i++) {
+		struct ice_vsi *vsi = pf->vsi[i];
+
+		if (vsi && vsi->type == type)
+			return vsi;
+	}
+
+	return NULL;
+}
+
 void ice_set_ethtool_ops(struct net_device *netdev);
 int ice_up(struct ice_vsi *vsi);
 int ice_down(struct ice_vsi *vsi);

commit b07833a00d70fb731bb3aba8876a56e37b549f3e
Author: Brett Creeley <brett.creeley@intel.com>
Date:   Thu Feb 28 15:25:59 2019 -0800

    ice: Add reg_idx variable in ice_q_vector structure
    
    Every time we want to re-enable interrupts and/or write to a register
    that requires an interrupt vector's hardware index we do the following:
    
    vsi->hw_base_vector + q_vector->v_idx
    
    This is a wasteful operation, especially in the hot path. Fix this by
    adding a u16 reg_idx member to the ice_q_vector structure and make the
    necessary changes to make this work.
    
    Signed-off-by: Brett Creeley <brett.creeley@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 878a75182d6d..d66aad49bfd4 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -297,6 +297,7 @@ struct ice_q_vector {
 	struct ice_vsi *vsi;
 
 	u16 v_idx;			/* index in the vsi->q_vector array. */
+	u16 reg_idx;
 	u8 num_ring_rx;			/* total number of Rx rings in vector */
 	u8 num_ring_tx;			/* total number of Tx rings in vector */
 	u8 itr_countdown;		/* when 0 should adjust adaptive ITR */
@@ -403,7 +404,7 @@ static inline void
 ice_irq_dynamic_ena(struct ice_hw *hw, struct ice_vsi *vsi,
 		    struct ice_q_vector *q_vector)
 {
-	u32 vector = (vsi && q_vector) ? vsi->hw_base_vector + q_vector->v_idx :
+	u32 vector = (vsi && q_vector) ? q_vector->reg_idx :
 				((struct ice_pf *)hw->back)->hw_oicr_idx;
 	int itr = ICE_ITR_NONE;
 	u32 val;

commit 3a257a1404f8bf751a258ab92262dcb2cce39eef
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Thu Feb 28 15:24:31 2019 -0800

    ice: Add code to control FW LLDP and DCBX
    
    This patch adds code to start or stop LLDP and DCBX in firmware through
    use of ethtool private flags.
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 6ca1094cb24a..878a75182d6d 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -325,6 +325,8 @@ enum ice_pf_flags {
 	ICE_FLAG_DCB_CAPABLE,
 	ICE_FLAG_DCB_ENA,
 	ICE_FLAG_LINK_DOWN_ON_CLOSE_ENA,
+	ICE_FLAG_DISABLE_FW_LLDP,
+	ICE_FLAG_ETHTOOL_CTXT,		/* set when ethtool holds RTNL lock */
 	ICE_PF_FLAGS_NBITS		/* must be last */
 };
 

commit 7b9ffc76bf5998aad8feaa26d9d3fcb65ec7a21b
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Thu Feb 28 15:24:24 2019 -0800

    ice: Add code for DCB initialization part 3/4
    
    This patch adds a new function ice_pf_dcb_cfg (and related helpers)
    which applies the DCB configuration obtained from the firmware. As
    part of this, VSIs/netdevs are updated with traffic class information.
    
    This patch requires a bit of a refactor of existing code.
    
    1. For a MIB change event, the associated VSI is closed and brought up
       again. The gap between closing and opening the VSI can cause a race
       condition. Fix this by grabbing the rtnl_lock prior to closing the
       VSI and then only free it after re-opening the VSI during a MIB
       change event.
    
    2. ice_sched_query_elem is used in ice_sched.c and with this patch, in
       ice_dcb.c as well. However, ice_dcb.c is not built when CONFIG_DCB is
       unset. This results in namespace warnings (ice_sched.o: Externally
       defined symbols with no external references) when CONFIG_DCB is unset.
       To avoid this move ice_sched_query_elem from ice_sched.c to
       ice_common.c.
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index d76333c808a3..6ca1094cb24a 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -378,6 +378,9 @@ struct ice_pf {
 	struct ice_hw_port_stats stats_prev;
 	struct ice_hw hw;
 	u8 stat_prev_loaded;	/* has previous stats been loaded */
+#ifdef CONFIG_DCB
+	u16 dcbx_cap;
+#endif /* CONFIG_DCB */
 	u32 tx_timeout_count;
 	unsigned long tx_timeout_last_recovery;
 	u32 tx_timeout_recovery_level;
@@ -414,12 +417,6 @@ ice_irq_dynamic_ena(struct ice_hw *hw, struct ice_vsi *vsi,
 	wr32(hw, GLINT_DYN_CTL(vector), val);
 }
 
-static inline void ice_vsi_set_tc_cfg(struct ice_vsi *vsi)
-{
-	vsi->tc_cfg.ena_tc =  ICE_DFLT_TRAFFIC_CLASS;
-	vsi->tc_cfg.numtc = 1;
-}
-
 void ice_set_ethtool_ops(struct net_device *netdev);
 int ice_up(struct ice_vsi *vsi);
 int ice_down(struct ice_vsi *vsi);
@@ -428,5 +425,9 @@ int ice_get_rss(struct ice_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size);
 void ice_fill_rss_lut(u8 *lut, u16 rss_table_size, u16 rss_size);
 void ice_print_link_msg(struct ice_vsi *vsi, bool isup);
 void ice_napi_del(struct ice_vsi *vsi);
+#ifdef CONFIG_DCB
+int ice_pf_ena_all_vsi(struct ice_pf *pf, bool locked);
+void ice_pf_dis_all_vsi(struct ice_pf *pf, bool locked);
+#endif /* CONFIG_DCB */
 
 #endif /* _ICE_H_ */

commit 37b6f6469f75070e4fb2e32995eb858e79b8860a
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Thu Feb 28 15:24:22 2019 -0800

    ice: Add code for DCB initialization part 1/4
    
    This patch introduces a skeleton for ice_init_pf_dcb, the top level
    function for DCB initialization. Subsequent patches will add to this
    DCB init flow.
    
    In this patch, ice_init_pf_dcb checks if DCB is a supported capability.
    If so, an admin queue call to start the LLDP and DCBx in firmware is
    issued. If not, an error is reported. Note that we don't fail the driver
    init if DCB init fails.
    
    Reviewed-by: Bruce Allan <bruce.w.allan@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index c04debc1a0ea..d76333c808a3 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -34,6 +34,7 @@
 #include "ice_devids.h"
 #include "ice_type.h"
 #include "ice_txrx.h"
+#include "ice_dcb.h"
 #include "ice_switch.h"
 #include "ice_common.h"
 #include "ice_sched.h"
@@ -321,6 +322,8 @@ enum ice_pf_flags {
 	ICE_FLAG_RSS_ENA,
 	ICE_FLAG_SRIOV_ENA,
 	ICE_FLAG_SRIOV_CAPABLE,
+	ICE_FLAG_DCB_CAPABLE,
+	ICE_FLAG_DCB_ENA,
 	ICE_FLAG_LINK_DOWN_ON_CLOSE_ENA,
 	ICE_PF_FLAGS_NBITS		/* must be last */
 };

commit f9867df6d96593fe678a138230379cda78403429
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Tue Feb 19 15:04:13 2019 -0800

    ice: Fix incorrect use of abbreviations
    
    Capitalize abbreviations and spell out some that aren't obvious.
    
    Reviewed-by: Bruce Allan <bruce.w.allan@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index f685235afb62..c04debc1a0ea 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -151,7 +151,7 @@ struct ice_tc_info {
 
 struct ice_tc_cfg {
 	u8 numtc; /* Total number of enabled TCs */
-	u8 ena_tc; /* TX map */
+	u8 ena_tc; /* Tx map */
 	struct ice_tc_info tc_info[ICE_MAX_TRAFFIC_CLASS];
 };
 
@@ -360,8 +360,8 @@ struct ice_pf {
 	u32 hw_oicr_idx;	/* Other interrupt cause vector HW index */
 	u32 num_avail_hw_msix;	/* remaining HW MSIX vectors left unclaimed */
 	u32 num_lan_msix;	/* Total MSIX vectors for base driver */
-	u16 num_lan_tx;		/* num lan Tx queues setup */
-	u16 num_lan_rx;		/* num lan Rx queues setup */
+	u16 num_lan_tx;		/* num LAN Tx queues setup */
+	u16 num_lan_rx;		/* num LAN Rx queues setup */
 	u16 q_left_tx;		/* remaining num Tx queues left unclaimed */
 	u16 q_left_rx;		/* remaining num Rx queues left unclaimed */
 	u16 next_vsi;		/* Next free slot in pf->vsi[] - 0-based! */
@@ -387,8 +387,8 @@ struct ice_netdev_priv {
 
 /**
  * ice_irq_dynamic_ena - Enable default interrupt generation settings
- * @hw: pointer to hw struct
- * @vsi: pointer to vsi struct, can be NULL
+ * @hw: pointer to HW struct
+ * @vsi: pointer to VSI struct, can be NULL
  * @q_vector: pointer to q_vector, can be NULL
  */
 static inline void

commit 94c4441b5a80f38d203432a4389d2dd349403ae5
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Tue Feb 19 15:04:12 2019 -0800

    ice: Fix typos in code comments
    
    This patch fixes typos in code comments.
    
    Reviewed-by: Bruce Allan <bruce.w.allan@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index b819689da7e2..f685235afb62 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -162,7 +162,7 @@ struct ice_res_tracker {
 };
 
 struct ice_qs_cfg {
-	struct mutex *qs_mutex;  /* will be assgined to &pf->avail_q_mutex */
+	struct mutex *qs_mutex;  /* will be assigned to &pf->avail_q_mutex */
 	unsigned long *pf_map;
 	unsigned long pf_map_size;
 	unsigned int q_count;

commit 8244dd2d23b251dcba3238e42216e9277beb5729
Author: Brett Creeley <brett.creeley@intel.com>
Date:   Tue Feb 19 15:04:05 2019 -0800

    ice: Audit hotpath structures with pahole
    
    Currently the ice_q_vector structure and ice_ring_container structure
    are taking up more space than necessary due to cache alignment holes
    and unnecessary variables respectively. This is not helping the
    driver's performance. The following fixes were done to improve cache
    alignment, reduce wasted space, and increase performance.
    
    1. Remove the ice_latency_range enum as it is unused.
    2. Remove the latency_range variable in the ice_ring_container structure.
    3. Change the size of the itr_idx in the ice_ring_container structure
       from an int to an u16. This reduced the size of ice_ring_container
       structure to 32 Bytes so it has no holes or padding.
    4. Re-arrange the ice_q_vector structure using pahole to align
       members as best as possible in regards to 64 Byte cache line size.
    
    Signed-off-by: Brett Creeley <brett.creeley@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 7609cccb251e..b819689da7e2 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -294,20 +294,25 @@ struct ice_vsi {
 /* struct that defines an interrupt vector */
 struct ice_q_vector {
 	struct ice_vsi *vsi;
-	cpumask_t affinity_mask;
-	struct napi_struct napi;
-	struct ice_ring_container rx;
-	struct ice_ring_container tx;
-	struct irq_affinity_notify affinity_notify;
+
 	u16 v_idx;			/* index in the vsi->q_vector array. */
-	u8 num_ring_tx;			/* total number of Tx rings in vector */
 	u8 num_ring_rx;			/* total number of Rx rings in vector */
-	char name[ICE_INT_NAME_STR_LEN];
+	u8 num_ring_tx;			/* total number of Tx rings in vector */
+	u8 itr_countdown;		/* when 0 should adjust adaptive ITR */
 	/* in usecs, need to use ice_intrl_to_usecs_reg() before writing this
 	 * value to the device
 	 */
 	u8 intrl;
-	u8 itr_countdown;	/* when 0 should adjust adaptive ITR */
+
+	struct napi_struct napi;
+
+	struct ice_ring_container rx;
+	struct ice_ring_container tx;
+
+	cpumask_t affinity_mask;
+	struct irq_affinity_notify affinity_notify;
+
+	char name[ICE_INT_NAME_STR_LEN];
 } ____cacheline_internodealigned_in_smp;
 
 enum ice_pf_flags {

commit 64a59d05a4b3ddb37eb5ad3a3be0f17148f449f5
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Tue Feb 19 15:04:01 2019 -0800

    ice: Fix for adaptive interrupt moderation
    
    commit 63f545ed1285 ("ice: Add support for adaptive interrupt moderation")
    was meant to add support for adaptive interrupt moderation but there was
    an error on my part while formatting the patch, and thus only part of the
    patch ended up being submitted.
    
    This patch rectifies the error by adding the rest of the code.
    
    Fixes: 63f545ed1285 ("ice: Add support for adaptive interrupt moderation")
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 0843868d1bbd..7609cccb251e 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -307,6 +307,7 @@ struct ice_q_vector {
 	 * value to the device
 	 */
 	u8 intrl;
+	u8 itr_countdown;	/* when 0 should adjust adaptive ITR */
 } ____cacheline_internodealigned_in_smp;
 
 enum ice_pf_flags {

commit 5eda8afd6bcc89d4e4aa5d56b5f54276f63158ae
Author: Akeem G Abodunrin <akeem.g.abodunrin@intel.com>
Date:   Tue Feb 26 16:35:14 2019 -0800

    ice: Add support for PF/VF promiscuous mode
    
    Implement support for VF promiscuous mode, MAC/VLAN/MAC_VLAN and PF
    multicast MAC/VLAN/MAC_VLAN promiscuous mode.
    
    Signed-off-by: Akeem G Abodunrin <akeem.g.abodunrin@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 2bb2898efb82..0843868d1bbd 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -125,6 +125,23 @@ extern const char ice_drv_ver[];
 #define ice_for_each_q_vector(vsi, i) \
 	for ((i) = 0; (i) < (vsi)->num_q_vectors; (i)++)
 
+#define ICE_UCAST_PROMISC_BITS (ICE_PROMISC_UCAST_TX | ICE_PROMISC_MCAST_TX | \
+				ICE_PROMISC_UCAST_RX | ICE_PROMISC_MCAST_RX)
+
+#define ICE_UCAST_VLAN_PROMISC_BITS (ICE_PROMISC_UCAST_TX | \
+				     ICE_PROMISC_MCAST_TX | \
+				     ICE_PROMISC_UCAST_RX | \
+				     ICE_PROMISC_MCAST_RX | \
+				     ICE_PROMISC_VLAN_TX  | \
+				     ICE_PROMISC_VLAN_RX)
+
+#define ICE_MCAST_PROMISC_BITS (ICE_PROMISC_MCAST_TX | ICE_PROMISC_MCAST_RX)
+
+#define ICE_MCAST_VLAN_PROMISC_BITS (ICE_PROMISC_MCAST_TX | \
+				     ICE_PROMISC_MCAST_RX | \
+				     ICE_PROMISC_VLAN_TX  | \
+				     ICE_PROMISC_VLAN_RX)
+
 struct ice_tc_info {
 	u16 qoffset;
 	u16 qcount_tx;
@@ -258,6 +275,7 @@ struct ice_vsi {
 	u8 irqs_ready;
 	u8 current_isup;		 /* Sync 'link up' logging */
 	u8 stat_offsets_loaded;
+	u8 vlan_ena;
 
 	/* queue information */
 	u8 tx_mapping_mode;		 /* ICE_MAP_MODE_[CONTIG|SCATTER] */

commit c8b7abdd7d8e4696d5ffa25cebaa82931e0e39b3
Author: Bruce Allan <bruce.w.allan@intel.com>
Date:   Tue Feb 26 16:35:11 2019 -0800

    ice: fix some function prototype and signature style issues
    
    Put the return type on a separate line for function prototypes and
    signatures that would exceed the 80-character limit if both were on
    the same line.
    
    Signed-off-by: Bruce Allan <bruce.w.allan@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 38a5aafb8840..2bb2898efb82 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -367,8 +367,9 @@ struct ice_netdev_priv {
  * @vsi: pointer to vsi struct, can be NULL
  * @q_vector: pointer to q_vector, can be NULL
  */
-static inline void ice_irq_dynamic_ena(struct ice_hw *hw, struct ice_vsi *vsi,
-				       struct ice_q_vector *q_vector)
+static inline void
+ice_irq_dynamic_ena(struct ice_hw *hw, struct ice_vsi *vsi,
+		    struct ice_q_vector *q_vector)
 {
 	u32 vector = (vsi && q_vector) ? vsi->hw_base_vector + q_vector->v_idx :
 				((struct ice_pf *)hw->back)->hw_oicr_idx;

commit ad71b256ba4e6e469d60e3f7b9973fd195b04bee
Author: Brett Creeley <brett.creeley@intel.com>
Date:   Fri Feb 8 12:50:59 2019 -0800

    ice: Determine descriptor count and ring size based on PAGE_SIZE
    
    Currently we set the default number of Tx and Rx descriptors to 128 by
    default. For Rx this amounts to a full page (assuming 4K pages) because
    each Rx descriptor is 32 Bytes, but for Tx it only amounts to a half
    page because each Tx descriptor is 16 Bytes (assuming 4K pages).
    Instead of assuming 4K pages, determine the ring size and the number of
    descriptors for Tx and Rx based on a calculation using the PAGE_SIZE,
    ICE_MAX_NUM_DESC, and ICE_REQ_DESC_MULTIPLE. This change is being made
    to improve the performance of the driver when using the default
    settings.
    
    Signed-off-by: Brett Creeley <brett.creeley@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 89440775aea1..38a5aafb8840 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -42,10 +42,21 @@
 
 extern const char ice_drv_ver[];
 #define ICE_BAR0		0
-#define ICE_DFLT_NUM_DESC	128
 #define ICE_REQ_DESC_MULTIPLE	32
 #define ICE_MIN_NUM_DESC	ICE_REQ_DESC_MULTIPLE
 #define ICE_MAX_NUM_DESC	8160
+/* set default number of Rx/Tx descriptors to the minimum between
+ * ICE_MAX_NUM_DESC and the number of descriptors to fill up an entire page
+ */
+#define ICE_DFLT_NUM_RX_DESC	min_t(u16, ICE_MAX_NUM_DESC, \
+				      ALIGN(PAGE_SIZE / \
+					    sizeof(union ice_32byte_rx_desc), \
+					    ICE_REQ_DESC_MULTIPLE))
+#define ICE_DFLT_NUM_TX_DESC	min_t(u16, ICE_MAX_NUM_DESC, \
+				      ALIGN(PAGE_SIZE / \
+					    sizeof(struct ice_tx_desc), \
+					    ICE_REQ_DESC_MULTIPLE))
+
 #define ICE_DFLT_TRAFFIC_CLASS	BIT(0)
 #define ICE_INT_NAME_STR_LEN	(IFNAMSIZ + 16)
 #define ICE_ETHTOOL_FWVER_LEN	32
@@ -257,7 +268,8 @@ struct ice_vsi {
 	u16 num_txq;			 /* Used Tx queues */
 	u16 alloc_rxq;			 /* Allocated Rx queues */
 	u16 num_rxq;			 /* Used Rx queues */
-	u16 num_desc;
+	u16 num_rx_desc;
+	u16 num_tx_desc;
 	struct ice_tc_cfg tc_cfg;
 } ____cacheline_internodealigned_in_smp;
 

commit 5ed5d316d90b1487c51b8973c2b845495f3558c0
Author: Maciej Fijalkowski <maciej.fijalkowski@intel.com>
Date:   Fri Feb 8 12:50:29 2019 -0800

    ice: Fix the calculation of ICE_MAX_MTU
    
    Currently ICE_MAX_MTU subtracts only ETH_HLEN from max frame size and
    adds ETH_FCS_LEN and VLAN_HLEN, which is not what was intended.
    The ETH_HLEN + ETH_FCS_LEN + VLAN_HLEN expression should be surrounded
    with parentheses.
    
    Wrap mentioned expression and take into account VLAN double tagging.
    
    Signed-off-by: Maciej Fijalkowski <maciej.fijalkowski@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 55944e089558..89440775aea1 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -83,7 +83,7 @@ extern const char ice_drv_ver[];
 #define ICE_DFLT_NETIF_M (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK)
 
 #define ICE_MAX_MTU	(ICE_AQ_SET_MAC_FRAME_SIZE_MAX - \
-			 ETH_HLEN + ETH_FCS_LEN + VLAN_HLEN)
+			(ETH_HLEN + ETH_FCS_LEN + (VLAN_HLEN * 2)))
 
 #define ICE_UP_TABLE_TRANSLATE(val, i) \
 		(((val) << ICE_AQ_VSI_UP_TABLE_UP##i##_S) & \

commit cf909e19acf373a2e1d9bd877846a11bc8e20a54
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Wed Dec 19 10:03:32 2018 -0800

    ice: Offload SCTP checksum
    
    This patch adds the ability to offload SCTP checksum calculations to the
    NIC.
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index ac8bf7491d08..55944e089558 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -26,6 +26,7 @@
 #include <linux/bitmap.h>
 #include <linux/log2.h>
 #include <linux/ip.h>
+#include <linux/sctp.h>
 #include <linux/ipv6.h>
 #include <linux/if_bridge.h>
 #include <linux/avf/virtchnl.h>

commit 67fe64d78c437d3f5a280a074e8467fa9b16216d
Author: Brett Creeley <brett.creeley@intel.com>
Date:   Wed Dec 19 10:03:30 2018 -0800

    ice: Implement getting and setting ethtool coalesce
    
    This patch includes the following ethtool operations:
    
    1. get_coalesce
    2. set_coalesce
    3. get_per_q_coalesce
    4. set_per_q_coalesce
    
    Each ITR value (current_itr/target_itr) are stored on a per
    ice_ring_container basis. This is because each valid ice_ring_container
    can have 1 or more rings that are tied to the same q_vector ITR index.
    
    Signed-off-by: Brett Creeley <brett.creeley@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index ffe4ffe16912..ac8bf7491d08 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -110,6 +110,9 @@ extern const char ice_drv_ver[];
 #define ice_for_each_alloc_rxq(vsi, i) \
 	for ((i) = 0; (i) < (vsi)->alloc_rxq; (i)++)
 
+#define ice_for_each_q_vector(vsi, i) \
+	for ((i) = 0; (i) < (vsi)->num_q_vectors; (i)++)
+
 struct ice_tc_info {
 	u16 qoffset;
 	u16 qcount_tx;

commit 03f7a986684597607de02f3023aa6c3657a78ab5
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Wed Dec 19 10:03:27 2018 -0800

    ice: Rework queue management code for reuse
    
    This patch reworks the queue management code to allow for reuse with the
    XDP feature (to be added in a future patch).
    
    Signed-off-by: Maciej Fijalkowski <maciej.fijalkowski@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 8af882a2b070..ffe4ffe16912 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -129,6 +129,17 @@ struct ice_res_tracker {
 	u16 list[1];
 };
 
+struct ice_qs_cfg {
+	struct mutex *qs_mutex;  /* will be assgined to &pf->avail_q_mutex */
+	unsigned long *pf_map;
+	unsigned long pf_map_size;
+	unsigned int q_count;
+	unsigned int scatter_count;
+	u16 *vsi_map;
+	u16 vsi_map_offset;
+	u8 mapping_mode;
+};
+
 struct ice_sw {
 	struct ice_pf *pf;
 	u16 sw_id;		/* switch ID for this switch */

commit ab4ab73fc1ec6dec548fa36c5e383ef5faa7b4c1
Author: Bruce Allan <bruce.w.allan@intel.com>
Date:   Wed Dec 19 10:03:26 2018 -0800

    ice: Add ethtool private flag to make forcing link down optional
    
    Add new infrastructure for implementing ethtool private flags using the
    existing pf->flags bitmap to store them, and add the link-down-on-close
    ethtool private flag to optionally bring down the PHY link when the
    interface is administratively downed.
    
    Signed-off-by: Bruce Allan <bruce.w.allan@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index a385575600f6..8af882a2b070 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -270,6 +270,7 @@ enum ice_pf_flags {
 	ICE_FLAG_RSS_ENA,
 	ICE_FLAG_SRIOV_ENA,
 	ICE_FLAG_SRIOV_CAPABLE,
+	ICE_FLAG_LINK_DOWN_ON_CLOSE_ENA,
 	ICE_PF_FLAGS_NBITS		/* must be last */
 };
 

commit d337f2afb7aceb16840a2621c5e2f9e868630653
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Fri Oct 26 11:44:47 2018 -0700

    ice: Use Tx|Rx in comments
    
    In code comments, use Tx|Rx instead of tx|rx
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 60b2e0c9faf5..a385575600f6 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -96,14 +96,14 @@ extern const char ice_drv_ver[];
 #define ice_for_each_vsi(pf, i) \
 	for ((i) = 0; (i) < (pf)->num_alloc_vsi; (i)++)
 
-/* Macros for each tx/rx ring in a VSI */
+/* Macros for each Tx/Rx ring in a VSI */
 #define ice_for_each_txq(vsi, i) \
 	for ((i) = 0; (i) < (vsi)->num_txq; (i)++)
 
 #define ice_for_each_rxq(vsi, i) \
 	for ((i) = 0; (i) < (vsi)->num_rxq; (i)++)
 
-/* Macros for each allocated tx/rx ring whether used or not in a VSI */
+/* Macros for each allocated Tx/Rx ring whether used or not in a VSI */
 #define ice_for_each_alloc_txq(vsi, i) \
 	for ((i) = 0; (i) < (vsi)->alloc_txq; (i)++)
 
@@ -183,8 +183,8 @@ struct ice_vsi {
 	struct ice_sw *vsw;		 /* switch this VSI is on */
 	struct ice_pf *back;		 /* back pointer to PF */
 	struct ice_port_info *port_info; /* back pointer to port_info */
-	struct ice_ring **rx_rings;	 /* rx ring array */
-	struct ice_ring **tx_rings;	 /* tx ring array */
+	struct ice_ring **rx_rings;	 /* Rx ring array */
+	struct ice_ring **tx_rings;	 /* Tx ring array */
 	struct ice_q_vector **q_vectors; /* q_vector array */
 
 	irqreturn_t (*irq_handler)(int irq, void *data);
@@ -255,8 +255,8 @@ struct ice_q_vector {
 	struct ice_ring_container tx;
 	struct irq_affinity_notify affinity_notify;
 	u16 v_idx;			/* index in the vsi->q_vector array. */
-	u8 num_ring_tx;			/* total number of tx rings in vector */
-	u8 num_ring_rx;			/* total number of rx rings in vector */
+	u8 num_ring_tx;			/* total number of Tx rings in vector */
+	u8 num_ring_rx;			/* total number of Rx rings in vector */
 	char name[ICE_INT_NAME_STR_LEN];
 	/* in usecs, need to use ice_intrl_to_usecs_reg() before writing this
 	 * value to the device
@@ -308,10 +308,10 @@ struct ice_pf {
 	u32 hw_oicr_idx;	/* Other interrupt cause vector HW index */
 	u32 num_avail_hw_msix;	/* remaining HW MSIX vectors left unclaimed */
 	u32 num_lan_msix;	/* Total MSIX vectors for base driver */
-	u16 num_lan_tx;		/* num lan tx queues setup */
-	u16 num_lan_rx;		/* num lan rx queues setup */
-	u16 q_left_tx;		/* remaining num tx queues left unclaimed */
-	u16 q_left_rx;		/* remaining num rx queues left unclaimed */
+	u16 num_lan_tx;		/* num lan Tx queues setup */
+	u16 num_lan_rx;		/* num lan Rx queues setup */
+	u16 q_left_tx;		/* remaining num Tx queues left unclaimed */
+	u16 q_left_rx;		/* remaining num Rx queues left unclaimed */
 	u16 next_vsi;		/* Next free slot in pf->vsi[] - 0-based! */
 	u16 num_alloc_vsi;
 	u16 corer_count;	/* Core reset count */

commit df17b7e02f0fa3a13c5aac26c317447d72612e1c
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Fri Oct 26 11:44:46 2018 -0700

    ice: Cosmetic formatting changes
    
    1. Fix several cases of double spacing
    2. Fix typos
    3. Capitalize abbreviations
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 7d8575d11786..60b2e0c9faf5 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -150,10 +150,10 @@ enum ice_state {
 	__ICE_RESET_FAILED,		/* set by reset/rebuild */
 	/* When checking for the PF to be in a nominal operating state, the
 	 * bits that are grouped at the beginning of the list need to be
-	 * checked.  Bits occurring before __ICE_STATE_NOMINAL_CHECK_BITS will
-	 * be checked.  If you need to add a bit into consideration for nominal
+	 * checked. Bits occurring before __ICE_STATE_NOMINAL_CHECK_BITS will
+	 * be checked. If you need to add a bit into consideration for nominal
 	 * operating state, it must be added before
-	 * __ICE_STATE_NOMINAL_CHECK_BITS.  Do not move this entry's position
+	 * __ICE_STATE_NOMINAL_CHECK_BITS. Do not move this entry's position
 	 * without appropriate consideration.
 	 */
 	__ICE_STATE_NOMINAL_CHECK_BITS,
@@ -201,8 +201,8 @@ struct ice_vsi {
 	int sw_base_vector;		/* Irq base for OS reserved vectors */
 	int hw_base_vector;		/* HW (absolute) index of a vector */
 	enum ice_vsi_type type;
-	u16 vsi_num;			 /* HW (absolute) index of this VSI */
-	u16 idx;			 /* software index in pf->vsi[] */
+	u16 vsi_num;			/* HW (absolute) index of this VSI */
+	u16 idx;			/* software index in pf->vsi[] */
 
 	/* Interrupt thresholds */
 	u16 work_lmt;

commit c5a2a4a38856faed6fa6654746c838231289e8d6
Author: Usha Ketineni <usha.k.ketineni@intel.com>
Date:   Fri Oct 26 11:44:35 2018 -0700

    ice: Fix to make VLAN priority tagged traffic to appear on all TCs
    
    This patch includes below changes to resolve the issue of ETS bandwidth
    shaping to work.
    
    1. Allocation of Tx queues is accounted for based on the enabled TC's
       in ice_vsi_setup_q_map() and enabled the Tx queues on those TC's via
       ice_vsi_cfg_txqs()
    
    2. Get the mapped netdev TC # for the user priority and set the priority
       to TC mapping for the VSI.
    
    Signed-off-by: Usha Ketineni <usha.k.ketineni@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index ba03cbd3638e..7d8575d11786 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -112,7 +112,9 @@ extern const char ice_drv_ver[];
 
 struct ice_tc_info {
 	u16 qoffset;
-	u16 qcount;
+	u16 qcount_tx;
+	u16 qcount_rx;
+	u8 netdev_tc;
 };
 
 struct ice_tc_cfg {

commit 995c90f2de819b020bdb0758ea4d486b0851e11a
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Fri Oct 26 10:41:03 2018 -0700

    ice: Calculate guaranteed VSIs per function and use it
    
    Currently we are setting the guar_num_vsi to equal to ICE_MAX_VSI
    which is the device limit of 768. This is incorrect and could have
    unintended consequences. To fix this use the valid_function's 8-bit
    bitmap returned from discovering device capabilities to determine the
    guar_num_vsi per function. guar_num_vsi value is then passed on to
    pf->num_alloc_vsi.
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index b8548370f1c7..ba03cbd3638e 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -52,7 +52,6 @@ extern const char ice_drv_ver[];
 #define ICE_MBXQ_LEN		64
 #define ICE_MIN_MSIX		2
 #define ICE_NO_VSI		0xffff
-#define ICE_MAX_VSI_ALLOC	130
 #define ICE_MAX_TXQS		2048
 #define ICE_MAX_RXQS		2048
 #define ICE_VSI_MAP_CONTIG	0

commit 25525b69bb44a628841492f44a5a8e74f34724f4
Author: Dave Ertman <david.m.ertman@intel.com>
Date:   Fri Oct 26 10:40:57 2018 -0700

    ice: Fix napi delete calls for remove
    
    In the remove path, the vsi->netdev is being set to NULL before the call
    to free vectors. This is causing the netif_napi_del call to never be made.
    
    Add a call to ice_napi_del to the same location as the calls to
    unregister_netdev and just prior to them. This will use the reverse flow
    as the register and netif_napi_add calls.
    
    Signed-off-by: Dave Ertman <david.m.ertman@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 1639e955f158..b8548370f1c7 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -370,5 +370,6 @@ int ice_set_rss(struct ice_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size);
 int ice_get_rss(struct ice_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size);
 void ice_fill_rss_lut(u8 *lut, u16 rss_table_size, u16 rss_size);
 void ice_print_link_msg(struct ice_vsi *vsi, bool isup);
+void ice_napi_del(struct ice_vsi *vsi);
 
 #endif /* _ICE_H_ */

commit 9ecd25c26810a61b9c3abc6c73de32dca6da96e1
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Fri Oct 26 10:40:54 2018 -0700

    ice: Remove duplicate addition of VLANs in replay path
    
    ice_restore_vlan and active_vlans were originally put in place to
    reprogram VLAN filters in the replay path. This is now done as part
    of the much broader VSI rebuild/replay framework. So remove both
    ice_restore_vlan and active_vlans
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index e5b37fa60884..1639e955f158 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -191,7 +191,6 @@ struct ice_vsi {
 	u64 tx_linearize;
 	DECLARE_BITMAP(state, __ICE_STATE_NBITS);
 	DECLARE_BITMAP(flags, ICE_VSI_FLAG_NBITS);
-	unsigned long active_vlans[BITS_TO_LONGS(VLAN_N_VID)];
 	unsigned int current_netdev_flags;
 	u32 tx_restart;
 	u32 tx_busy;

commit afd9d4ab58db20029a75cf82f23b6a5641cd7d6f
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Fri Oct 26 10:40:51 2018 -0700

    ice: Check for reset in progress during remove
    
    The remove path does not currently check to see if a
    reset is in progress before proceeding.  This can cause
    a resource collision resulting in various types of errors.
    
    Check for reset in progress and wait for a reasonable
    amount of time before allowing the remove to progress.
    
    Signed-off-by: Dave Ertman <david.m.ertman@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 4c4b5717a627..e5b37fa60884 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -76,6 +76,8 @@ extern const char ice_drv_ver[];
 #define ICE_MIN_INTR_PER_VF		(ICE_MIN_QS_PER_VF + 1)
 #define ICE_DFLT_INTR_PER_VF		(ICE_DFLT_QS_PER_VF + 1)
 
+#define ICE_MAX_RESET_WAIT		20
+
 #define ICE_VSIQF_HKEY_ARRAY_SIZE	((VSIQF_HKEY_MAX_INDEX + 1) *	4)
 
 #define ICE_DFLT_NETIF_M (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK)

commit 1071a8358a286df4ca7d3baa2ccea8b4cfe33c7a
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Wed Sep 19 17:42:59 2018 -0700

    ice: Implement virtchnl commands for AVF support
    
    virtchnl is a protocol/interface specification that allows the Intel
    "Adaptive Virtual Function (AVF)" driver (iavf.ko) to work with more than
    one physical function driver. The AVF driver sends "virtchnl commands"
    (control plane only) to the PF driver over mailbox queues and the PF driver
    executes these commands and returns a result to the VF, again over mailbox.
    
    This patch adds AVF support for the ice PF driver by implementing the
    following virtchnl commands:
    
    VIRTCHNL_OP_VERSION
    VIRTCHNL_OP_GET_VF_RESOURCES
    VIRTCHNL_OP_RESET_VF
    VIRTCHNL_OP_ADD_ETH_ADDR
    VIRTCHNL_OP_DEL_ETH_ADDR
    VIRTCHNL_OP_CONFIG_VSI_QUEUES
    VIRTCHNL_OP_ENABLE_QUEUES
    VIRTCHNL_OP_DISABLE_QUEUES
    VIRTCHNL_OP_ADD_ETH_ADDR
    VIRTCHNL_OP_DEL_ETH_ADDR
    VIRTCHNL_OP_CONFIG_VSI_QUEUES
    VIRTCHNL_OP_ENABLE_QUEUES
    VIRTCHNL_OP_DISABLE_QUEUES
    VIRTCHNL_OP_REQUEST_QUEUES
    VIRTCHNL_OP_CONFIG_IRQ_MAP
    VIRTCHNL_OP_CONFIG_RSS_KEY
    VIRTCHNL_OP_CONFIG_RSS_LUT
    VIRTCHNL_OP_GET_STATS
    VIRTCHNL_OP_ADD_VLAN
    VIRTCHNL_OP_DEL_VLAN
    VIRTCHNL_OP_ENABLE_VLAN_STRIPPING
    VIRTCHNL_OP_DISABLE_VLAN_STRIPPING
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index a9572f8ef6bf..4c4b5717a627 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -71,6 +71,7 @@ extern const char ice_drv_ver[];
 #define ICE_MAX_QS_PER_VF		256
 #define ICE_MIN_QS_PER_VF		1
 #define ICE_DFLT_QS_PER_VF		4
+#define ICE_MAX_BASE_QS_PER_VF		16
 #define ICE_MAX_INTR_PER_VF		65
 #define ICE_MIN_INTR_PER_VF		(ICE_MIN_QS_PER_VF + 1)
 #define ICE_DFLT_INTR_PER_VF		(ICE_DFLT_QS_PER_VF + 1)

commit 007676b4ac920d4ceb4e4aa8aa668ac32d4764ad
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Wed Sep 19 17:42:57 2018 -0700

    ice: Add support for VF reset events
    
    Post VF initialization, there are a couple of different ways in which a
    VF reset can be triggered. One is when the underlying PF itself goes
    through a reset and other is via a VFLR interrupt. ice_reset_vf introduced
    in this patch handles both these cases.
    
    Also introduced in this patch is a helper function ice_aq_send_msg_to_vf
    to send messages to VF over the mailbox queue. The PF uses this to send
    reset notifications to VFs.
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 89ec05e9983b..a9572f8ef6bf 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -37,6 +37,7 @@
 #include "ice_common.h"
 #include "ice_sched.h"
 #include "ice_virtchnl_pf.h"
+#include "ice_sriov.h"
 
 extern const char ice_drv_ver[];
 #define ICE_BAR0		0
@@ -155,6 +156,7 @@ enum ice_state {
 	__ICE_ADMINQ_EVENT_PENDING,
 	__ICE_MAILBOXQ_EVENT_PENDING,
 	__ICE_MDD_EVENT_PENDING,
+	__ICE_VFLR_EVENT_PENDING,
 	__ICE_FLTR_OVERFLOW_PROMISC,
 	__ICE_VF_DIS,
 	__ICE_CFG_BUSY,

commit 8ede01785f32269ef4766cf17a535e70ee3c1541
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Wed Sep 19 17:42:56 2018 -0700

    ice: Update VSI and queue management code to handle VF VSI
    
    Until now, all the VSI and queue management code supported only the PF
    VSI type (ICE_VSI_PF). Update these flows to handle the VF VSI type
    (ICE_VSI_VF) type as well.
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index f788cd63237a..89ec05e9983b 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -202,6 +202,8 @@ struct ice_vsi {
 	/* Interrupt thresholds */
 	u16 work_lmt;
 
+	s16 vf_id;			/* VF ID for SR-IOV VSIs */
+
 	/* RSS config */
 	u16 rss_table_size;	/* HW RSS table size */
 	u16 rss_size;		/* Allocated RSS queues */

commit ddf30f7ff840d4467ef45ec0b443575f9e95bec6
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Wed Sep 19 17:42:55 2018 -0700

    ice: Add handler to configure SR-IOV
    
    This patch implements parts of ice_sriov_configure and VF reset flow.
    
    To create virtual functions (VFs), the user sets a value in num_vfs
    through sysfs. This results in the kernel calling the handler for
    .sriov_configure which is ice_sriov_configure.
    
    VF setup first starts with a VF reset, followed by allocation of the VF
    VSI using ice_vf_vsi_setup. Once the VF setup is complete a state bit
    ICE_VF_STATE_INIT is set in the vf->states bitmap to indicate that
    the VF is ready to go.
    
    Also for VF reset to go into effect, it's necessary to issue a disable
    queue command (ice_aqc_opc_dis_txqs). So this patch updates multiple
    functions in the disable queue flow to take additional parameters that
    distinguish if queues are being disabled due to VF reset.
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 639d45d1da49..f788cd63237a 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -28,6 +28,7 @@
 #include <linux/ip.h>
 #include <linux/ipv6.h>
 #include <linux/if_bridge.h>
+#include <linux/avf/virtchnl.h>
 #include <net/ipv6.h>
 #include "ice_devids.h"
 #include "ice_type.h"
@@ -35,6 +36,7 @@
 #include "ice_switch.h"
 #include "ice_common.h"
 #include "ice_sched.h"
+#include "ice_virtchnl_pf.h"
 
 extern const char ice_drv_ver[];
 #define ICE_BAR0		0
@@ -65,6 +67,12 @@ extern const char ice_drv_ver[];
 #define ICE_INVAL_Q_INDEX	0xffff
 #define ICE_INVAL_VFID		256
 #define ICE_MAX_VF_COUNT	256
+#define ICE_MAX_QS_PER_VF		256
+#define ICE_MIN_QS_PER_VF		1
+#define ICE_DFLT_QS_PER_VF		4
+#define ICE_MAX_INTR_PER_VF		65
+#define ICE_MIN_INTR_PER_VF		(ICE_MIN_QS_PER_VF + 1)
+#define ICE_DFLT_INTR_PER_VF		(ICE_DFLT_QS_PER_VF + 1)
 
 #define ICE_VSIQF_HKEY_ARRAY_SIZE	((VSIQF_HKEY_MAX_INDEX + 1) *	4)
 
@@ -135,10 +143,20 @@ enum ice_state {
 	__ICE_EMPR_RECV,		/* set by OICR handler */
 	__ICE_SUSPENDED,		/* set on module remove path */
 	__ICE_RESET_FAILED,		/* set by reset/rebuild */
+	/* When checking for the PF to be in a nominal operating state, the
+	 * bits that are grouped at the beginning of the list need to be
+	 * checked.  Bits occurring before __ICE_STATE_NOMINAL_CHECK_BITS will
+	 * be checked.  If you need to add a bit into consideration for nominal
+	 * operating state, it must be added before
+	 * __ICE_STATE_NOMINAL_CHECK_BITS.  Do not move this entry's position
+	 * without appropriate consideration.
+	 */
+	__ICE_STATE_NOMINAL_CHECK_BITS,
 	__ICE_ADMINQ_EVENT_PENDING,
 	__ICE_MAILBOXQ_EVENT_PENDING,
 	__ICE_MDD_EVENT_PENDING,
 	__ICE_FLTR_OVERFLOW_PROMISC,
+	__ICE_VF_DIS,
 	__ICE_CFG_BUSY,
 	__ICE_SERVICE_SCHED,
 	__ICE_SERVICE_DIS,
@@ -243,6 +261,7 @@ enum ice_pf_flags {
 	ICE_FLAG_MSIX_ENA,
 	ICE_FLAG_FLTR_SYNC,
 	ICE_FLAG_RSS_ENA,
+	ICE_FLAG_SRIOV_ENA,
 	ICE_FLAG_SRIOV_CAPABLE,
 	ICE_PF_FLAGS_NBITS		/* must be last */
 };
@@ -259,7 +278,12 @@ struct ice_pf {
 
 	struct ice_vsi **vsi;		/* VSIs created by the driver */
 	struct ice_sw *first_sw;	/* first switch created by firmware */
+	/* Virtchnl/SR-IOV config info */
+	struct ice_vf *vf;
+	int num_alloc_vfs;		/* actual number of VFs allocated */
 	u16 num_vfs_supported;		/* num VFs supported for this PF */
+	u16 num_vf_qps;			/* num queue pairs per VF */
+	u16 num_vf_msix;		/* num vectors per VF */
 	DECLARE_BITMAP(state, __ICE_STATE_NBITS);
 	DECLARE_BITMAP(avail_txqs, ICE_MAX_TXQS);
 	DECLARE_BITMAP(avail_rxqs, ICE_MAX_RXQS);

commit 75d2b253026b8b1cb625f6ccdb9d54cdecae7935
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Wed Sep 19 17:42:54 2018 -0700

    ice: Add support to detect SR-IOV capability and mailbox queues
    
    Mailbox queue is a type of control queue that's used for communication
    between PF and VF. This patch adds code to initialize, configure and
    use mailbox queues.
    
    This patch also adds support to detect and parse SR-IOV capabilities
    returned by the hardware.
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 0b269c470343..639d45d1da49 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -46,6 +46,7 @@ extern const char ice_drv_ver[];
 #define ICE_INT_NAME_STR_LEN	(IFNAMSIZ + 16)
 #define ICE_ETHTOOL_FWVER_LEN	32
 #define ICE_AQ_LEN		64
+#define ICE_MBXQ_LEN		64
 #define ICE_MIN_MSIX		2
 #define ICE_NO_VSI		0xffff
 #define ICE_MAX_VSI_ALLOC	130
@@ -63,6 +64,7 @@ extern const char ice_drv_ver[];
 #define ICE_RES_MISC_VEC_ID	(ICE_RES_VALID_BIT - 1)
 #define ICE_INVAL_Q_INDEX	0xffff
 #define ICE_INVAL_VFID		256
+#define ICE_MAX_VF_COUNT	256
 
 #define ICE_VSIQF_HKEY_ARRAY_SIZE	((VSIQF_HKEY_MAX_INDEX + 1) *	4)
 
@@ -134,6 +136,7 @@ enum ice_state {
 	__ICE_SUSPENDED,		/* set on module remove path */
 	__ICE_RESET_FAILED,		/* set by reset/rebuild */
 	__ICE_ADMINQ_EVENT_PENDING,
+	__ICE_MAILBOXQ_EVENT_PENDING,
 	__ICE_MDD_EVENT_PENDING,
 	__ICE_FLTR_OVERFLOW_PROMISC,
 	__ICE_CFG_BUSY,
@@ -240,6 +243,7 @@ enum ice_pf_flags {
 	ICE_FLAG_MSIX_ENA,
 	ICE_FLAG_FLTR_SYNC,
 	ICE_FLAG_RSS_ENA,
+	ICE_FLAG_SRIOV_CAPABLE,
 	ICE_PF_FLAGS_NBITS		/* must be last */
 };
 
@@ -255,6 +259,7 @@ struct ice_pf {
 
 	struct ice_vsi **vsi;		/* VSIs created by the driver */
 	struct ice_sw *first_sw;	/* first switch created by firmware */
+	u16 num_vfs_supported;		/* num VFs supported for this PF */
 	DECLARE_BITMAP(state, __ICE_STATE_NBITS);
 	DECLARE_BITMAP(avail_txqs, ICE_MAX_TXQS);
 	DECLARE_BITMAP(avail_rxqs, ICE_MAX_RXQS);

commit 9e4ab4c29a62d2ccbf4be42707669be2f42d391c
Author: Brett Creeley <brett.creeley@intel.com>
Date:   Wed Sep 19 17:23:19 2018 -0700

    ice: Add support for dynamic interrupt moderation
    
    Currently there is no support for dynamic interrupt moderation. This
    patch adds some initial code to support this. The following changes
    were made:
    
    1. Currently we are using multiple members to store the interrupt
       granularity (itr_gran_25/50/100/200). This is not necessary because
       we can query the device to determine what the interrupt granularity
       should be set to, done by a new function ice_get_itr_intrl_gran.
    
    2. Added intrl to ice_q_vector structure to support interrupt rate
       limiting.
    
    3. Added the function ice_intrl_usecs_to_reg for converting to a value
       in usecs that the device understands.
    
    4. Added call to write to the GLINT_RATE register. Disable intrl by
       default for now.
    
    5. Changed rx/tx_itr_setting to itr_setting because having both seems
       redundant because a ring is either Tx or Rx.
    
    6. Initialize itr_setting for both Tx/Rx rings in ice_vsi_alloc_rings()
    
    Signed-off-by: Brett Creeley <brett.creeley@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index fc6bc1233f10..0b269c470343 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -230,6 +230,10 @@ struct ice_q_vector {
 	u8 num_ring_tx;			/* total number of tx rings in vector */
 	u8 num_ring_rx;			/* total number of rx rings in vector */
 	char name[ICE_INT_NAME_STR_LEN];
+	/* in usecs, need to use ice_intrl_to_usecs_reg() before writing this
+	 * value to the device
+	 */
+	u8 intrl;
 } ____cacheline_internodealigned_in_smp;
 
 enum ice_pf_flags {

commit eb0208ec42d319bc09fead0e1afe2bc0c28aeca0
Author: Preethi Banala <preethi.banala@intel.com>
Date:   Wed Sep 19 17:23:16 2018 -0700

    ice: Split irq_tracker into sw_irq_tracker and hw_irq_tracker
    
    For the PF driver, when mapping interrupts to queues, we need to request
    IRQs from the kernel and we also have to allocate interrupts from
    the device.
    
    Similarly, when the VF driver (iavf.ko) initializes, it requests the kernel
    IRQs that it needs but it can't directly allocate interrupts in the device.
    Instead, it sends a mailbox message to the ice driver, which then allocates
    interrupts in the device on the VF driver's behalf.
    
    Currently both these cases end up having to reserve entries in
    pf->irq_tracker but irq_tracker itself is sized based on how many vectors
    the PF driver needs. Under the right circumstances, the VF driver can fail
    to get entries in irq_tracker, which will result in the VF driver failing
    probe.
    
    To fix this, sw_irq_tracker and hw_irq_tracker are introduced. The
    sw_irq_tracker tracks only the PF's IRQ request and doesn't play any
    role in VF init. hw_irq_tracker represents the device's interrupt space.
    When interrupts have to be allocated in the device for either PF or VF,
    hw_irq_tracker will be looked up to see if the device has run out of
    interrupts.
    
    Signed-off-by: Preethi Banala <preethi.banala@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 9cce4cb91401..fc6bc1233f10 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -172,7 +172,8 @@ struct ice_vsi {
 	u32 rx_buf_failed;
 	u32 rx_page_failed;
 	int num_q_vectors;
-	int base_vector;
+	int sw_base_vector;		/* Irq base for OS reserved vectors */
+	int hw_base_vector;		/* HW (absolute) index of a vector */
 	enum ice_vsi_type type;
 	u16 vsi_num;			 /* HW (absolute) index of this VSI */
 	u16 idx;			 /* software index in pf->vsi[] */
@@ -240,8 +241,14 @@ enum ice_pf_flags {
 
 struct ice_pf {
 	struct pci_dev *pdev;
+
+	/* OS reserved IRQ details */
 	struct msix_entry *msix_entries;
-	struct ice_res_tracker *irq_tracker;
+	struct ice_res_tracker *sw_irq_tracker;
+
+	/* HW reserved Interrupts for this PF */
+	struct ice_res_tracker *hw_irq_tracker;
+
 	struct ice_vsi **vsi;		/* VSIs created by the driver */
 	struct ice_sw *first_sw;	/* first switch created by firmware */
 	DECLARE_BITMAP(state, __ICE_STATE_NBITS);
@@ -256,9 +263,11 @@ struct ice_pf {
 	struct mutex sw_mutex;		/* lock for protecting VSI alloc flow */
 	u32 msg_enable;
 	u32 hw_csum_rx_error;
-	u32 oicr_idx;		/* Other interrupt cause vector index */
+	u32 sw_oicr_idx;	/* Other interrupt cause SW vector index */
+	u32 num_avail_sw_msix;	/* remaining MSIX SW vectors left unclaimed */
+	u32 hw_oicr_idx;	/* Other interrupt cause vector HW index */
+	u32 num_avail_hw_msix;	/* remaining HW MSIX vectors left unclaimed */
 	u32 num_lan_msix;	/* Total MSIX vectors for base driver */
-	u32 num_avail_msix;	/* remaining MSIX vectors left unclaimed */
 	u16 num_lan_tx;		/* num lan tx queues setup */
 	u16 num_lan_rx;		/* num lan rx queues setup */
 	u16 q_left_tx;		/* remaining num tx queues left unclaimed */
@@ -293,8 +302,8 @@ struct ice_netdev_priv {
 static inline void ice_irq_dynamic_ena(struct ice_hw *hw, struct ice_vsi *vsi,
 				       struct ice_q_vector *q_vector)
 {
-	u32 vector = (vsi && q_vector) ? vsi->base_vector + q_vector->v_idx :
-					((struct ice_pf *)hw->back)->oicr_idx;
+	u32 vector = (vsi && q_vector) ? vsi->hw_base_vector + q_vector->v_idx :
+				((struct ice_pf *)hw->back)->hw_oicr_idx;
 	int itr = ICE_ITR_NONE;
 	u32 val;
 

commit 5df7e45d54fc99dd7c73e3a1f163cbfafc8b51f5
Author: Dave Ertman <david.m.ertman@intel.com>
Date:   Wed Sep 19 17:23:11 2018 -0700

    ice: Change pf state behavior to protect reset path
    
    Currently, there is no bit, or set of bits, that protect the entirety
    of the reset path.
    
    If the reset is originated by the driver, then the relevant
    one of the following bits will be set when the reset is scheduled:
    __ICE_PFR_REQ
    __ICE_CORER_REQ
    __ICE_GLOBR_REQ
    This bit will not be cleared until after the rebuild has completed.
    
    If the reset is originated by the FW, then the first the driver knows of
    it will be the reception of the OICR interrupt.  The __ICE_RESET_OICR_RECV
    bit will be set in the interrupt handler.  This will also be the indicator
    in a SW originated reset that we have completed the pre-OICR tasks and
    have informed the FW that a reset was requested.
    
    To utilize these bits, change the function:
    ice_is_reset_recovery_pending()
            to be:
    ice_is_reset_in_progress()
    
    The new function will check all of the above bits in the pf->state and
    will return a true if one or more of these bits are set.
    
    Signed-off-by: Dave Ertman <david.m.ertman@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index e84a612ffa71..9cce4cb91401 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -124,7 +124,7 @@ enum ice_state {
 	__ICE_DOWN,
 	__ICE_NEEDS_RESTART,
 	__ICE_PREPARED_FOR_RESET,	/* set by driver when prepared */
-	__ICE_RESET_RECOVERY_PENDING,	/* set by driver when reset starts */
+	__ICE_RESET_OICR_RECV,		/* set by driver after rcv reset OICR */
 	__ICE_PFR_REQ,			/* set by driver and peers */
 	__ICE_CORER_REQ,		/* set by driver and peers */
 	__ICE_GLOBR_REQ,		/* set by driver and peers */

commit 3b6bf296c44f2b1233b7622c847a6ac5b1aeba0f
Author: Bruce Allan <bruce.w.allan@intel.com>
Date:   Wed Sep 19 17:23:11 2018 -0700

    ice: fix changing of ring descriptor size (ethtool -G)
    
    rx_mini_pending was set to an incorrect value. This was causing EINVAL to
    always be returned to 'ethtool -G'. The driver does not support mini or
    jumbo rings so the respective settings should be zero.
    
    Also, change the valid range of the number of descriptors in the rings to
    make the code simpler and easier for users to understand (this removes the
    valid settings of 8 and 16). Add a system log message indicating when the
    number is rounded-up from what the user specifies with the 'ethtool -G'
    command (i.e. when it is not a multiple of 32), and update the log message
    when a user-provided value is out of range to also indicate the stride.
    
    Signed-off-by: Bruce Allan <bruce.w.allan@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 9cf233d085d8..e84a612ffa71 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -39,9 +39,9 @@
 extern const char ice_drv_ver[];
 #define ICE_BAR0		0
 #define ICE_DFLT_NUM_DESC	128
-#define ICE_MIN_NUM_DESC	8
-#define ICE_MAX_NUM_DESC	8160
 #define ICE_REQ_DESC_MULTIPLE	32
+#define ICE_MIN_NUM_DESC	ICE_REQ_DESC_MULTIPLE
+#define ICE_MAX_NUM_DESC	8160
 #define ICE_DFLT_TRAFFIC_CLASS	BIT(0)
 #define ICE_INT_NAME_STR_LEN	(IFNAMSIZ + 16)
 #define ICE_ETHTOOL_FWVER_LEN	32

commit 8d81fa55bac0c730d59e990db099ebecd82d7880
Author: Akeem G Abodunrin <akeem.g.abodunrin@intel.com>
Date:   Thu Aug 9 06:29:57 2018 -0700

    ice: Introduce SERVICE_DIS flag and service routine functions
    
    This patch introduces SERVICE_DIS flag to use for stopping service task.
    This flag will be checked before scheduling new tasks. Also add new
    functions ice_service_task_stop to stop service task.
    
    Signed-off-by: Akeem G Abodunrin <akeem.g.abodunrin@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Tony Brelinski <tonyx.brelinski@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 6f44a850c4b2..9cf233d085d8 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -138,6 +138,7 @@ enum ice_state {
 	__ICE_FLTR_OVERFLOW_PROMISC,
 	__ICE_CFG_BUSY,
 	__ICE_SERVICE_SCHED,
+	__ICE_SERVICE_DIS,
 	__ICE_STATE_NBITS		/* must be last */
 };
 

commit b3969fd727aa1f2ace4794f2a180f9769128027c
Author: Sudheer Mogilappagari <sudheer.mogilappagari@intel.com>
Date:   Thu Aug 9 06:29:53 2018 -0700

    ice: Add support for Tx hang, Tx timeout and malicious driver detection
    
    When a malicious operation is detected, the firmware triggers an
    interrupt, which is then picked up by the service task (specifically by
    ice_handle_mdd_event). A reset is scheduled if required.
    
    Tx hang detection works in a similar way, except the logic here monitors
    the VSI's Tx queues and tries to revive them if stalled. If the hang is
    not resolved, the kernel eventually calls ndo_tx_timeout, which is
    handled by ice_tx_timeout.
    
    Signed-off-by: Sudheer Mogilappagari <sudheer.mogilappagari@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Tony Brelinski <tonyx.brelinski@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index e17030db0bee..6f44a850c4b2 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -134,6 +134,7 @@ enum ice_state {
 	__ICE_SUSPENDED,		/* set on module remove path */
 	__ICE_RESET_FAILED,		/* set by reset/rebuild */
 	__ICE_ADMINQ_EVENT_PENDING,
+	__ICE_MDD_EVENT_PENDING,
 	__ICE_FLTR_OVERFLOW_PROMISC,
 	__ICE_CFG_BUSY,
 	__ICE_SERVICE_SCHED,
@@ -272,6 +273,9 @@ struct ice_pf {
 	struct ice_hw_port_stats stats_prev;
 	struct ice_hw hw;
 	u8 stat_prev_loaded;	/* has previous stats been loaded */
+	u32 tx_timeout_count;
+	unsigned long tx_timeout_last_recovery;
+	u32 tx_timeout_recovery_level;
 	char int_name[ICE_INT_NAME_STR_LEN];
 };
 

commit 0f9d5027a7496c451737f0f549be083688a40549
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Thu Aug 9 06:29:50 2018 -0700

    ice: Refactor VSI allocation, deletion and rebuild flow
    
    This patch refactors aspects of the VSI allocation, deletion and rebuild
    flow. Some of the more noteworthy changes are described below.
    
    1) On reset, all switch filters applied in the hardware are lost. In
       the rebuild flow, only MAC and broadcast filters are being restored.
       Instead, use a new function ice_replay_all_fltr to restore all the
       filters that were previously added. To do this, remove calls to
       ice_remove_vsi_fltr to prevent cleaning out the internal bookkeeping
       structures that ice_replay_all_fltr uses to replay filters.
    
    2) Introduce a new state bit __ICE_PREPARED_FOR_RESET to distinguish the
       PF that requested the reset (and consequently prepared for it) from
       the rest of the PFs. These other PFs will prepare for reset only
       when they receive an interrupt from the firmware.
    
    3) Use new functions ice_add_vsi and ice_free_vsi to create and destroy
       VSIs respectively. These functions accept a handle to uniquely
       identify a VSI. This same handle is required to rebuild the VSI post
       reset. To prevent confusion, the existing ice_vsi_add was renamed to
       ice_vsi_init.
    
    4) Enhance ice_vsi_setup for the upcoming SR-IOV changes and expose a
       new wrapper function ice_pf_vsi_setup to create PF VSIs. Rework the
       error handling path in ice_setup_pf_sw.
    
    5) Introduce a new function ice_vsi_release_all to release all PF VSIs.
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Tony Brelinski <tonyx.brelinski@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 868f4a1d0f72..e17030db0bee 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -62,6 +62,7 @@ extern const char ice_drv_ver[];
 #define ICE_RES_VALID_BIT	0x8000
 #define ICE_RES_MISC_VEC_ID	(ICE_RES_VALID_BIT - 1)
 #define ICE_INVAL_Q_INDEX	0xffff
+#define ICE_INVAL_VFID		256
 
 #define ICE_VSIQF_HKEY_ARRAY_SIZE	((VSIQF_HKEY_MAX_INDEX + 1) *	4)
 
@@ -122,6 +123,7 @@ struct ice_sw {
 enum ice_state {
 	__ICE_DOWN,
 	__ICE_NEEDS_RESTART,
+	__ICE_PREPARED_FOR_RESET,	/* set by driver when prepared */
 	__ICE_RESET_RECOVERY_PENDING,	/* set by driver when reset starts */
 	__ICE_PFR_REQ,			/* set by driver and peers */
 	__ICE_CORER_REQ,		/* set by driver and peers */

commit 43f8b22450f0a721915f1d2c7e3db6dd9573e76b
Author: Bruce Allan <bruce.w.allan@intel.com>
Date:   Thu Aug 9 06:29:02 2018 -0700

    ice: Change struct members from bool to u8
    
    Recent versions of checkpatch have a new warning based on a documented
    preference of Linus to not use bool in structures due to wasted space and
    the size of bool is implementation dependent.  For more information, see
    the email thread at https://lkml.org/lkml/2017/11/21/384.
    
    Signed-off-by: Bruce Allan <bruce.w.allan@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Tony Brelinski <tonyx.brelinski@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index ed071ea75f20..868f4a1d0f72 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -196,9 +196,9 @@ struct ice_vsi {
 	struct list_head tmp_sync_list;		/* MAC filters to be synced */
 	struct list_head tmp_unsync_list;	/* MAC filters to be unsynced */
 
-	bool irqs_ready;
-	bool current_isup;		 /* Sync 'link up' logging */
-	bool stat_offsets_loaded;
+	u8 irqs_ready;
+	u8 current_isup;		 /* Sync 'link up' logging */
+	u8 stat_offsets_loaded;
 
 	/* queue information */
 	u8 tx_mapping_mode;		 /* ICE_MAP_MODE_[CONTIG|SCATTER] */
@@ -269,7 +269,7 @@ struct ice_pf {
 	struct ice_hw_port_stats stats;
 	struct ice_hw_port_stats stats_prev;
 	struct ice_hw hw;
-	bool stat_prev_loaded;	/* has previous stats been loaded */
+	u8 stat_prev_loaded;	/* has previous stats been loaded */
 	char int_name[ICE_INT_NAME_STR_LEN];
 };
 

commit f8ba7db850350319348b6d3c276f8ba19bc098ef
Author: Jacob Keller <jacob.e.keller@intel.com>
Date:   Thu Aug 9 06:28:54 2018 -0700

    ice: Report stats for allocated queues via ethtool stats
    
    It is not safe to have the string table for statistics change order or
    size over the lifetime of a given netdevice. This is because of the
    nature of the 3-step process for obtaining stats. First, user space
    performs a request for the size of the strings table. Second it performs
    a separate request for the strings themselves, after allocating space
    for the table. Third, it requests the stats themselves, also allocating
    space for the table.
    
    If the size decreased, there is potential to see garbage data or stats
    values. In the worst case, we could potentially see stats values become
    mis-aligned with their strings, so that it looks like a statistic is
    being reported differently than it actually is.
    
    Even worse, if the size increased, there is potential that the strings
    table or stats table was not allocated large enough and the stats code
    could access and write to memory it should not, potentially resulting in
    undefined behavior and system crashes.
    
    It isn't even safe if the size always changes under the RTNL lock. This
    is because the calls take place over multiple user space commands, so it
    is not possible to hold the RTNL lock for the entire duration of
    obtaining strings and stats. Further, not all consumers of the ethtool
    API are the user space ethtool program, and it is possible that one
    assumes the strings will not change (valid under the current contract),
    and thus only requests the stats values when requesting stats in a loop.
    
    Finally, it's not possible in the general case to detect when the size
    changes, because it is quite possible that one value which could impact
    the stat size increased, while another decreased. This would result in
    the same total number of stats, but reordering them so that stats no
    longer line up with the strings they belong to. Since only size changes
    aren't enough, we would need some sort of hash or token to determine
    when the strings no longer match. This would require extending the
    ethtool stats commands, but there is no more space in the relevant
    structures.
    
    The real solution to resolve this would be to add a completely new API
    for stats, probably over netlink.
    
    In the ice driver, the only thing impacting the stats that is not
    constant is the number of queues. Instead of reporting stats for each
    used queue, report stats for each allocated queue. We do not change the
    number of queues allocated for a given netdevice, as we pass this into
    the alloc_etherdev_mq() function to set the num_tx_queues and
    num_rx_queues.
    
    This resolves the potential bugs at the slight cost of displaying many
    queue statistics which will not be activated.
    
    Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Tony Brelinski <tonyx.brelinski@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index d8b5fff581e7..ed071ea75f20 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -89,6 +89,13 @@ extern const char ice_drv_ver[];
 #define ice_for_each_rxq(vsi, i) \
 	for ((i) = 0; (i) < (vsi)->num_rxq; (i)++)
 
+/* Macros for each allocated tx/rx ring whether used or not in a VSI */
+#define ice_for_each_alloc_txq(vsi, i) \
+	for ((i) = 0; (i) < (vsi)->alloc_txq; (i)++)
+
+#define ice_for_each_alloc_rxq(vsi, i) \
+	for ((i) = 0; (i) < (vsi)->alloc_rxq; (i)++)
+
 struct ice_tc_info {
 	u16 qoffset;
 	u16 qcount;

commit e94d4478669357cd742170c77fc28d6db2040ce4
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Tue Mar 20 07:58:19 2018 -0700

    ice: Implement filter sync, NDO operations and bump version
    
    This patch implements multiple pieces of functionality:
    
    1. Added ice_vsi_sync_filters, which is called through the service task
       to push filter updates to the hardware.
    
    2. Add support to enable/disable promiscuous mode on an interface.
       Enabling/disabling promiscuous mode on an interface results in
       addition/removal of a promisc filter rule through ice_vsi_sync_filters.
    
    3. Implement handlers for ndo_set_mac_address, ndo_change_mtu,
       ndo_poll_controller and ndo_set_rx_mode.
    
    This patch also marks the end of the driver addition by bumping up the
    driver version.
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Tony Brelinski <tonyx.brelinski@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 24ce4b71c9ce..d8b5fff581e7 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -125,11 +125,20 @@ enum ice_state {
 	__ICE_SUSPENDED,		/* set on module remove path */
 	__ICE_RESET_FAILED,		/* set by reset/rebuild */
 	__ICE_ADMINQ_EVENT_PENDING,
+	__ICE_FLTR_OVERFLOW_PROMISC,
 	__ICE_CFG_BUSY,
 	__ICE_SERVICE_SCHED,
 	__ICE_STATE_NBITS		/* must be last */
 };
 
+enum ice_vsi_flags {
+	ICE_VSI_FLAG_UMAC_FLTR_CHANGED,
+	ICE_VSI_FLAG_MMAC_FLTR_CHANGED,
+	ICE_VSI_FLAG_VLAN_FLTR_CHANGED,
+	ICE_VSI_FLAG_PROMISC_CHANGED,
+	ICE_VSI_FLAG_NBITS		/* must be last */
+};
+
 /* struct that defines a VSI, associated with a dev */
 struct ice_vsi {
 	struct net_device *netdev;
@@ -144,7 +153,9 @@ struct ice_vsi {
 
 	u64 tx_linearize;
 	DECLARE_BITMAP(state, __ICE_STATE_NBITS);
+	DECLARE_BITMAP(flags, ICE_VSI_FLAG_NBITS);
 	unsigned long active_vlans[BITS_TO_LONGS(VLAN_N_VID)];
+	unsigned int current_netdev_flags;
 	u32 tx_restart;
 	u32 tx_busy;
 	u32 rx_buf_failed;
@@ -175,6 +186,9 @@ struct ice_vsi {
 	struct ice_eth_stats eth_stats;
 	struct ice_eth_stats eth_stats_prev;
 
+	struct list_head tmp_sync_list;		/* MAC filters to be synced */
+	struct list_head tmp_unsync_list;	/* MAC filters to be unsynced */
+
 	bool irqs_ready;
 	bool current_isup;		 /* Sync 'link up' logging */
 	bool stat_offsets_loaded;

commit 0b28b702e72a6ff90d417689159f72e8891fed78
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Tue Mar 20 07:58:18 2018 -0700

    ice: Support link events, reset and rebuild
    
    Link events are posted to a PF's admin receive queue (ARQ). This patch
    adds the ability to detect and process link events.
    
    This patch also adds the ability to process resets.
    
    The driver can process the following resets:
        1) EMP Reset (EMPR)
        2) Global Reset (GLOBR)
        3) Core Reset (CORER)
        4) Physical Function Reset (PFR)
    
    EMPR is the largest level of reset that the driver can handle. An EMPR
    resets the manageability block and also the data path, including PHY and
    link for all the PFs. The affected PFs are notified of this event through
    a miscellaneous interrupt.
    
    GLOBR is a subset of EMPR. It does everything EMPR does except that it
    doesn't reset the manageability block.
    
    CORER is a subset of GLOBR. It does everything GLOBR does but doesn't
    reset PHY and link.
    
    PFR is a subset of CORER and affects only the given physical function.
    In other words, PFR can be thought of as a CORER for a single PF. Since
    only the issuing PF is affected, a PFR doesn't result in the miscellaneous
    interrupt being triggered.
    
    All the resets have the following in common:
    1) Tx/Rx is halted and all queues are stopped.
    2) All the VSIs and filters programmed for the PF are lost and have to be
       reprogrammed.
    3) Control queue interfaces are reset and have to be reprogrammed.
    
    In the rebuild flow, control queues are reinitialized, VSIs are reallocated
    and filters are restored.
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Tony Brelinski <tonyx.brelinski@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 8898255e5a65..24ce4b71c9ce 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -78,6 +78,11 @@ extern const char ice_drv_ver[];
 #define ICE_RX_DESC(R, i) (&(((union ice_32b_rx_flex_desc *)((R)->desc))[i]))
 #define ICE_TX_CTX_DESC(R, i) (&(((struct ice_tx_ctx_desc *)((R)->desc))[i]))
 
+/* Macro for each VSI in a PF */
+#define ice_for_each_vsi(pf, i) \
+	for ((i) = 0; (i) < (pf)->num_alloc_vsi; (i)++)
+
+/* Macros for each tx/rx ring in a VSI */
 #define ice_for_each_txq(vsi, i) \
 	for ((i) = 0; (i) < (vsi)->num_txq; (i)++)
 
@@ -109,7 +114,16 @@ struct ice_sw {
 
 enum ice_state {
 	__ICE_DOWN,
+	__ICE_NEEDS_RESTART,
+	__ICE_RESET_RECOVERY_PENDING,	/* set by driver when reset starts */
 	__ICE_PFR_REQ,			/* set by driver and peers */
+	__ICE_CORER_REQ,		/* set by driver and peers */
+	__ICE_GLOBR_REQ,		/* set by driver and peers */
+	__ICE_CORER_RECV,		/* set by OICR handler */
+	__ICE_GLOBR_RECV,		/* set by OICR handler */
+	__ICE_EMPR_RECV,		/* set by OICR handler */
+	__ICE_SUSPENDED,		/* set on module remove path */
+	__ICE_RESET_FAILED,		/* set by reset/rebuild */
 	__ICE_ADMINQ_EVENT_PENDING,
 	__ICE_CFG_BUSY,
 	__ICE_SERVICE_SCHED,
@@ -226,6 +240,11 @@ struct ice_pf {
 	u16 q_left_rx;		/* remaining num rx queues left unclaimed */
 	u16 next_vsi;		/* Next free slot in pf->vsi[] - 0-based! */
 	u16 num_alloc_vsi;
+	u16 corer_count;	/* Core reset count */
+	u16 globr_count;	/* Global reset count */
+	u16 empr_count;		/* EMP reset count */
+	u16 pfr_count;		/* PF reset count */
+
 	struct ice_hw_port_stats stats;
 	struct ice_hw_port_stats stats_prev;
 	struct ice_hw hw;

commit 5513b920a4f7869acffc8e6d800aebee608409e0
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Tue Mar 20 07:58:17 2018 -0700

    ice: Update Tx scheduler tree for VSI multi-Tx queue support
    
    This patch adds the ability for a VSI to use multiple Tx queues. More
    specifically, the patch
        1) Provides the ability to update the Tx scheduler tree in the
           firmware. The driver can configure the Tx scheduler tree by
           adding/removing multiple Tx queues per TC per VSI.
    
        2) Allows a VSI to reconfigure its Tx queues during runtime.
    
        3) Synchronizes the Tx scheduler update operations using locks.
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Tony Brelinski <tonyx.brelinski@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 66d0976afa46..8898255e5a65 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -42,6 +42,7 @@ extern const char ice_drv_ver[];
 #define ICE_MIN_NUM_DESC	8
 #define ICE_MAX_NUM_DESC	8160
 #define ICE_REQ_DESC_MULTIPLE	32
+#define ICE_DFLT_TRAFFIC_CLASS	BIT(0)
 #define ICE_INT_NAME_STR_LEN	(IFNAMSIZ + 16)
 #define ICE_ETHTOOL_FWVER_LEN	32
 #define ICE_AQ_LEN		64
@@ -261,6 +262,12 @@ static inline void ice_irq_dynamic_ena(struct ice_hw *hw, struct ice_vsi *vsi,
 	wr32(hw, GLINT_DYN_CTL(vector), val);
 }
 
+static inline void ice_vsi_set_tc_cfg(struct ice_vsi *vsi)
+{
+	vsi->tc_cfg.ena_tc =  ICE_DFLT_TRAFFIC_CLASS;
+	vsi->tc_cfg.numtc = 1;
+}
+
 void ice_set_ethtool_ops(struct net_device *netdev);
 int ice_up(struct ice_vsi *vsi);
 int ice_down(struct ice_vsi *vsi);

commit fcea6f3da546b93050f3534aadea7bd96c1d7349
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Tue Mar 20 07:58:16 2018 -0700

    ice: Add stats and ethtool support
    
    This patch implements a watchdog task to get packet statistics from
    the device.
    
    This patch also adds support for the following ethtool operations:
    
    ethtool devname
    ethtool -s devname [msglvl N] [msglevel type on|off]
    ethtool -g|--show-ring devname
    ethtool -G|--set-ring devname [rx N] [tx N]
    ethtool -i|--driver devname
    ethtool -d|--register-dump devname [raw on|off] [hex on|off] [file name]
    ethtool -k|--show-features|--show-offload devname
    ethtool -K|--features|--offload devname feature on|off
    ethtool -P|--show-permaddr devname
    ethtool -S|--statistics devname
    ethtool -a|--show-pause devname
    ethtool -A|--pause devname [autoneg on|off] [rx on|off] [tx on|off]
    ethtool -r|--negotiate devname
    
    CC: Andrew Lunn <andrew@lunn.ch>
    CC: Jakub Kicinski <kubakici@wp.pl>
    CC: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Acked-by: Stephen Hemminger <stephen@networkplumber.org>
    Tested-by: Tony Brelinski <tonyx.brelinski@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 51cc955c7220..66d0976afa46 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -13,12 +13,14 @@
 #include <linux/etherdevice.h>
 #include <linux/skbuff.h>
 #include <linux/cpumask.h>
+#include <linux/rtnetlink.h>
 #include <linux/if_vlan.h>
 #include <linux/dma-mapping.h>
 #include <linux/pci.h>
 #include <linux/workqueue.h>
 #include <linux/aer.h>
 #include <linux/interrupt.h>
+#include <linux/ethtool.h>
 #include <linux/timer.h>
 #include <linux/delay.h>
 #include <linux/bitmap.h>
@@ -34,10 +36,14 @@
 #include "ice_common.h"
 #include "ice_sched.h"
 
+extern const char ice_drv_ver[];
 #define ICE_BAR0		0
 #define ICE_DFLT_NUM_DESC	128
+#define ICE_MIN_NUM_DESC	8
+#define ICE_MAX_NUM_DESC	8160
 #define ICE_REQ_DESC_MULTIPLE	32
 #define ICE_INT_NAME_STR_LEN	(IFNAMSIZ + 16)
+#define ICE_ETHTOOL_FWVER_LEN	32
 #define ICE_AQ_LEN		64
 #define ICE_MIN_MSIX		2
 #define ICE_NO_VSI		0xffff
@@ -56,6 +62,8 @@
 #define ICE_RES_MISC_VEC_ID	(ICE_RES_VALID_BIT - 1)
 #define ICE_INVAL_Q_INDEX	0xffff
 
+#define ICE_VSIQF_HKEY_ARRAY_SIZE	((VSIQF_HKEY_MAX_INDEX + 1) *	4)
+
 #define ICE_DFLT_NETIF_M (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK)
 
 #define ICE_MAX_MTU	(ICE_AQ_SET_MAC_FRAME_SIZE_MAX - \
@@ -102,6 +110,7 @@ enum ice_state {
 	__ICE_DOWN,
 	__ICE_PFR_REQ,			/* set by driver and peers */
 	__ICE_ADMINQ_EVENT_PENDING,
+	__ICE_CFG_BUSY,
 	__ICE_SERVICE_SCHED,
 	__ICE_STATE_NBITS		/* must be last */
 };
@@ -118,8 +127,13 @@ struct ice_vsi {
 
 	irqreturn_t (*irq_handler)(int irq, void *data);
 
+	u64 tx_linearize;
 	DECLARE_BITMAP(state, __ICE_STATE_NBITS);
 	unsigned long active_vlans[BITS_TO_LONGS(VLAN_N_VID)];
+	u32 tx_restart;
+	u32 tx_busy;
+	u32 rx_buf_failed;
+	u32 rx_page_failed;
 	int num_q_vectors;
 	int base_vector;
 	enum ice_vsi_type type;
@@ -141,8 +155,14 @@ struct ice_vsi {
 
 	struct ice_aqc_vsi_props info;	 /* VSI properties */
 
+	/* VSI stats */
+	struct rtnl_link_stats64 net_stats;
+	struct ice_eth_stats eth_stats;
+	struct ice_eth_stats eth_stats_prev;
+
 	bool irqs_ready;
 	bool current_isup;		 /* Sync 'link up' logging */
+	bool stat_offsets_loaded;
 
 	/* queue information */
 	u8 tx_mapping_mode;		 /* ICE_MAP_MODE_[CONTIG|SCATTER] */
@@ -205,8 +225,10 @@ struct ice_pf {
 	u16 q_left_rx;		/* remaining num rx queues left unclaimed */
 	u16 next_vsi;		/* Next free slot in pf->vsi[] - 0-based! */
 	u16 num_alloc_vsi;
-
+	struct ice_hw_port_stats stats;
+	struct ice_hw_port_stats stats_prev;
 	struct ice_hw hw;
+	bool stat_prev_loaded;	/* has previous stats been loaded */
 	char int_name[ICE_INT_NAME_STR_LEN];
 };
 
@@ -239,8 +261,12 @@ static inline void ice_irq_dynamic_ena(struct ice_hw *hw, struct ice_vsi *vsi,
 	wr32(hw, GLINT_DYN_CTL(vector), val);
 }
 
+void ice_set_ethtool_ops(struct net_device *netdev);
+int ice_up(struct ice_vsi *vsi);
+int ice_down(struct ice_vsi *vsi);
 int ice_set_rss(struct ice_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size);
 int ice_get_rss(struct ice_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size);
 void ice_fill_rss_lut(u8 *lut, u16 rss_table_size, u16 rss_size);
+void ice_print_link_msg(struct ice_vsi *vsi, bool isup);
 
 #endif /* _ICE_H_ */

commit d76a60ba7afb89523c88cf2ed3a044ce4180289e
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Tue Mar 20 07:58:15 2018 -0700

    ice: Add support for VLANs and offloads
    
    This patch adds support for VLANs. When a VLAN is created a switch filter
    is added to direct the VLAN traffic to the corresponding VSI. When a VLAN
    is deleted, the filter is deleted as well.
    
    This patch also adds support for the following hardware offloads.
        1) VLAN tag insertion/stripping
        2) Receive Side Scaling (RSS)
        3) Tx checksum and TCP segmentation
        4) Rx checksum
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Tony Brelinski <tonyx.brelinski@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 6f01395a7f34..51cc955c7220 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -23,7 +23,10 @@
 #include <linux/delay.h>
 #include <linux/bitmap.h>
 #include <linux/log2.h>
+#include <linux/ip.h>
+#include <linux/ipv6.h>
 #include <linux/if_bridge.h>
+#include <net/ipv6.h>
 #include "ice_devids.h"
 #include "ice_type.h"
 #include "ice_txrx.h"
@@ -47,6 +50,8 @@
 #define ICE_MAX_SCATTER_RXQS	16
 #define ICE_Q_WAIT_RETRY_LIMIT	10
 #define ICE_Q_WAIT_MAX_RETRY	(5 * ICE_Q_WAIT_RETRY_LIMIT)
+#define ICE_MAX_LG_RSS_QS	256
+#define ICE_MAX_SMALL_RSS_QS	8
 #define ICE_RES_VALID_BIT	0x8000
 #define ICE_RES_MISC_VEC_ID	(ICE_RES_VALID_BIT - 1)
 #define ICE_INVAL_Q_INDEX	0xffff
@@ -62,6 +67,7 @@
 
 #define ICE_TX_DESC(R, i) (&(((struct ice_tx_desc *)((R)->desc))[i]))
 #define ICE_RX_DESC(R, i) (&(((union ice_32b_rx_flex_desc *)((R)->desc))[i]))
+#define ICE_TX_CTX_DESC(R, i) (&(((struct ice_tx_ctx_desc *)((R)->desc))[i]))
 
 #define ice_for_each_txq(vsi, i) \
 	for ((i) = 0; (i) < (vsi)->num_txq; (i)++)
@@ -113,6 +119,7 @@ struct ice_vsi {
 	irqreturn_t (*irq_handler)(int irq, void *data);
 
 	DECLARE_BITMAP(state, __ICE_STATE_NBITS);
+	unsigned long active_vlans[BITS_TO_LONGS(VLAN_N_VID)];
 	int num_q_vectors;
 	int base_vector;
 	enum ice_vsi_type type;
@@ -122,6 +129,13 @@ struct ice_vsi {
 	/* Interrupt thresholds */
 	u16 work_lmt;
 
+	/* RSS config */
+	u16 rss_table_size;	/* HW RSS table size */
+	u16 rss_size;		/* Allocated RSS queues */
+	u8 *rss_hkey_user;	/* User configured hash keys */
+	u8 *rss_lut_user;	/* User configured lookup table entries */
+	u8 rss_lut_type;	/* used to configure Get/Set RSS LUT AQ call */
+
 	u16 max_frame;
 	u16 rx_buf_len;
 
@@ -181,6 +195,7 @@ struct ice_pf {
 	struct mutex avail_q_mutex;	/* protects access to avail_[rx|tx]qs */
 	struct mutex sw_mutex;		/* lock for protecting VSI alloc flow */
 	u32 msg_enable;
+	u32 hw_csum_rx_error;
 	u32 oicr_idx;		/* Other interrupt cause vector index */
 	u32 num_lan_msix;	/* Total MSIX vectors for base driver */
 	u32 num_avail_msix;	/* remaining MSIX vectors left unclaimed */
@@ -224,4 +239,8 @@ static inline void ice_irq_dynamic_ena(struct ice_hw *hw, struct ice_vsi *vsi,
 	wr32(hw, GLINT_DYN_CTL(vector), val);
 }
 
+int ice_set_rss(struct ice_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size);
+int ice_get_rss(struct ice_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size);
+void ice_fill_rss_lut(u8 *lut, u16 rss_table_size, u16 rss_size);
+
 #endif /* _ICE_H_ */

commit 2b245cb29421abbad508e93cdfedf81adc12edf1
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Tue Mar 20 07:58:14 2018 -0700

    ice: Implement transmit and NAPI support
    
    This patch implements ice_start_xmit (the handler for ndo_start_xmit) and
    related functions. ice_start_xmit ultimately calls ice_tx_map, where the
    Tx descriptor is built and posted to the hardware by bumping the ring tail.
    
    This patch also implements ice_napi_poll, which is invoked when there's an
    interrupt on the VSI's queues. The interrupt can be due to either a
    completed Tx or an Rx event. In case of a completed Tx/Rx event, resources
    are reclaimed. Additionally, in case of an Rx event, the skb is fetched
    and passed up to the network stack.
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Tony Brelinski <tonyx.brelinski@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 46cf82212ed8..6f01395a7f34 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -60,6 +60,7 @@
 		(((val) << ICE_AQ_VSI_UP_TABLE_UP##i##_S) & \
 		  ICE_AQ_VSI_UP_TABLE_UP##i##_M)
 
+#define ICE_TX_DESC(R, i) (&(((struct ice_tx_desc *)((R)->desc))[i]))
 #define ICE_RX_DESC(R, i) (&(((union ice_32b_rx_flex_desc *)((R)->desc))[i]))
 
 #define ice_for_each_txq(vsi, i) \

commit cdedef59deb020e78721d820a5692100128c8c73
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Tue Mar 20 07:58:13 2018 -0700

    ice: Configure VSIs for Tx/Rx
    
    This patch configures the VSIs to be able to send and receive
    packets by doing the following:
    
    1) Initialize flexible parser to extract and include certain
       fields in the Rx descriptor.
    
    2) Add Tx queues by programming the Tx queue context (implemented in
       ice_vsi_cfg_txqs). Note that adding the queues also enables (starts)
       the queues.
    
    3) Add Rx queues by programming Rx queue context (implemented in
       ice_vsi_cfg_rxqs). Note that this only adds queues but doesn't start
       them. The rings will be started by calling ice_vsi_start_rx_rings on
       interface up.
    
    4) Configure interrupts for VSI queues.
    
    5) Implement ice_open and ice_stop.
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Tony Brelinski <tonyx.brelinski@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 21d0c237ee3f..46cf82212ed8 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -11,8 +11,10 @@
 #include <linux/netdevice.h>
 #include <linux/compiler.h>
 #include <linux/etherdevice.h>
+#include <linux/skbuff.h>
 #include <linux/cpumask.h>
 #include <linux/if_vlan.h>
+#include <linux/dma-mapping.h>
 #include <linux/pci.h>
 #include <linux/workqueue.h>
 #include <linux/aer.h>
@@ -43,6 +45,8 @@
 #define ICE_VSI_MAP_SCATTER	1
 #define ICE_MAX_SCATTER_TXQS	16
 #define ICE_MAX_SCATTER_RXQS	16
+#define ICE_Q_WAIT_RETRY_LIMIT	10
+#define ICE_Q_WAIT_MAX_RETRY	(5 * ICE_Q_WAIT_RETRY_LIMIT)
 #define ICE_RES_VALID_BIT	0x8000
 #define ICE_RES_MISC_VEC_ID	(ICE_RES_VALID_BIT - 1)
 #define ICE_INVAL_Q_INDEX	0xffff
@@ -56,6 +60,14 @@
 		(((val) << ICE_AQ_VSI_UP_TABLE_UP##i##_S) & \
 		  ICE_AQ_VSI_UP_TABLE_UP##i##_M)
 
+#define ICE_RX_DESC(R, i) (&(((union ice_32b_rx_flex_desc *)((R)->desc))[i]))
+
+#define ice_for_each_txq(vsi, i) \
+	for ((i) = 0; (i) < (vsi)->num_txq; (i)++)
+
+#define ice_for_each_rxq(vsi, i) \
+	for ((i) = 0; (i) < (vsi)->num_rxq; (i)++)
+
 struct ice_tc_info {
 	u16 qoffset;
 	u16 qcount;
@@ -96,6 +108,9 @@ struct ice_vsi {
 	struct ice_ring **rx_rings;	 /* rx ring array */
 	struct ice_ring **tx_rings;	 /* tx ring array */
 	struct ice_q_vector **q_vectors; /* q_vector array */
+
+	irqreturn_t (*irq_handler)(int irq, void *data);
+
 	DECLARE_BITMAP(state, __ICE_STATE_NBITS);
 	int num_q_vectors;
 	int base_vector;
@@ -106,8 +121,14 @@ struct ice_vsi {
 	/* Interrupt thresholds */
 	u16 work_lmt;
 
+	u16 max_frame;
+	u16 rx_buf_len;
+
 	struct ice_aqc_vsi_props info;	 /* VSI properties */
 
+	bool irqs_ready;
+	bool current_isup;		 /* Sync 'link up' logging */
+
 	/* queue information */
 	u8 tx_mapping_mode;		 /* ICE_MAP_MODE_[CONTIG|SCATTER] */
 	u8 rx_mapping_mode;		 /* ICE_MAP_MODE_[CONTIG|SCATTER] */
@@ -128,9 +149,11 @@ struct ice_q_vector {
 	struct napi_struct napi;
 	struct ice_ring_container rx;
 	struct ice_ring_container tx;
+	struct irq_affinity_notify affinity_notify;
 	u16 v_idx;			/* index in the vsi->q_vector array. */
 	u8 num_ring_tx;			/* total number of tx rings in vector */
 	u8 num_ring_rx;			/* total number of rx rings in vector */
+	char name[ICE_INT_NAME_STR_LEN];
 } ____cacheline_internodealigned_in_smp;
 
 enum ice_pf_flags {
@@ -178,10 +201,14 @@ struct ice_netdev_priv {
 /**
  * ice_irq_dynamic_ena - Enable default interrupt generation settings
  * @hw: pointer to hw struct
+ * @vsi: pointer to vsi struct, can be NULL
+ * @q_vector: pointer to q_vector, can be NULL
  */
-static inline void ice_irq_dynamic_ena(struct ice_hw *hw)
+static inline void ice_irq_dynamic_ena(struct ice_hw *hw, struct ice_vsi *vsi,
+				       struct ice_q_vector *q_vector)
 {
-	u32 vector = ((struct ice_pf *)hw->back)->oicr_idx;
+	u32 vector = (vsi && q_vector) ? vsi->base_vector + q_vector->v_idx :
+					((struct ice_pf *)hw->back)->oicr_idx;
 	int itr = ICE_ITR_NONE;
 	u32 val;
 
@@ -190,7 +217,10 @@ static inline void ice_irq_dynamic_ena(struct ice_hw *hw)
 	 */
 	val = GLINT_DYN_CTL_INTENA_M | GLINT_DYN_CTL_CLEARPBA_M |
 	      (itr << GLINT_DYN_CTL_ITR_INDX_S);
-
+	if (vsi)
+		if (test_bit(__ICE_DOWN, vsi->state))
+			return;
 	wr32(hw, GLINT_DYN_CTL(vector), val);
 }
+
 #endif /* _ICE_H_ */

commit 3a858ba392c3b19986c40a4c170ddc37b144115f
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Tue Mar 20 07:58:11 2018 -0700

    ice: Add support for VSI allocation and deallocation
    
    This patch introduces data structures and functions to alloc/free
    VSIs. The driver represents a VSI using the ice_vsi structure.
    
    Some noteworthy points about VSI allocation:
    
    1) A VSI is allocated in the firmware using the "add VSI" admin queue
       command (implemented as ice_aq_add_vsi). The firmware returns an
       identifier for the allocated VSI. The VSI context is used to program
       certain aspects (loopback, queue map, etc.) of the VSI's configuration.
    
    2) A VSI is deleted using the "free VSI" admin queue command (implemented
       as ice_aq_free_vsi).
    
    3) The driver represents a VSI using struct ice_vsi. This is allocated
       and initialized as part of the ice_vsi_alloc flow, and deallocated
       as part of the ice_vsi_delete flow.
    
    4) Once the VSI is created, a netdev is allocated and associated with it.
       The VSI's ring and vector related data structures are also allocated
       and initialized.
    
    5) A VSI's queues can either be contiguous or scattered. To do this, the
       driver maintains a bitmap (vsi->avail_txqs) which is kept in sync with
       the firmware's VSI queue allocation imap. If the VSI can't get a
       contiguous queue allocation, it will fallback to scatter. This is
       implemented in ice_vsi_get_qs which is called as part of the VSI setup
       flow. In the release flow, the VSI's queues are released and the bitmap
       is updated to reflect this by ice_vsi_put_qs.
    
    CC: Shannon Nelson <shannon.nelson@oracle.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Acked-by: Shannon Nelson <shannon.nelson@oracle.com>
    Tested-by: Tony Brelinski <tonyx.brelinski@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 8103e61e67f9..21d0c237ee3f 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -11,6 +11,8 @@
 #include <linux/netdevice.h>
 #include <linux/compiler.h>
 #include <linux/etherdevice.h>
+#include <linux/cpumask.h>
+#include <linux/if_vlan.h>
 #include <linux/pci.h>
 #include <linux/workqueue.h>
 #include <linux/aer.h>
@@ -18,6 +20,7 @@
 #include <linux/timer.h>
 #include <linux/delay.h>
 #include <linux/bitmap.h>
+#include <linux/log2.h>
 #include <linux/if_bridge.h>
 #include "ice_devids.h"
 #include "ice_type.h"
@@ -27,17 +30,43 @@
 #include "ice_sched.h"
 
 #define ICE_BAR0		0
+#define ICE_DFLT_NUM_DESC	128
+#define ICE_REQ_DESC_MULTIPLE	32
 #define ICE_INT_NAME_STR_LEN	(IFNAMSIZ + 16)
 #define ICE_AQ_LEN		64
 #define ICE_MIN_MSIX		2
+#define ICE_NO_VSI		0xffff
 #define ICE_MAX_VSI_ALLOC	130
 #define ICE_MAX_TXQS		2048
 #define ICE_MAX_RXQS		2048
+#define ICE_VSI_MAP_CONTIG	0
+#define ICE_VSI_MAP_SCATTER	1
+#define ICE_MAX_SCATTER_TXQS	16
+#define ICE_MAX_SCATTER_RXQS	16
 #define ICE_RES_VALID_BIT	0x8000
 #define ICE_RES_MISC_VEC_ID	(ICE_RES_VALID_BIT - 1)
+#define ICE_INVAL_Q_INDEX	0xffff
 
 #define ICE_DFLT_NETIF_M (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK)
 
+#define ICE_MAX_MTU	(ICE_AQ_SET_MAC_FRAME_SIZE_MAX - \
+			 ETH_HLEN + ETH_FCS_LEN + VLAN_HLEN)
+
+#define ICE_UP_TABLE_TRANSLATE(val, i) \
+		(((val) << ICE_AQ_VSI_UP_TABLE_UP##i##_S) & \
+		  ICE_AQ_VSI_UP_TABLE_UP##i##_M)
+
+struct ice_tc_info {
+	u16 qoffset;
+	u16 qcount;
+};
+
+struct ice_tc_cfg {
+	u8 numtc; /* Total number of enabled TCs */
+	u8 ena_tc; /* TX map */
+	struct ice_tc_info tc_info[ICE_MAX_TRAFFIC_CLASS];
+};
+
 struct ice_res_tracker {
 	u16 num_entries;
 	u16 search_hint;
@@ -61,8 +90,47 @@ enum ice_state {
 /* struct that defines a VSI, associated with a dev */
 struct ice_vsi {
 	struct net_device *netdev;
+	struct ice_sw *vsw;		 /* switch this VSI is on */
+	struct ice_pf *back;		 /* back pointer to PF */
 	struct ice_port_info *port_info; /* back pointer to port_info */
+	struct ice_ring **rx_rings;	 /* rx ring array */
+	struct ice_ring **tx_rings;	 /* tx ring array */
+	struct ice_q_vector **q_vectors; /* q_vector array */
+	DECLARE_BITMAP(state, __ICE_STATE_NBITS);
+	int num_q_vectors;
+	int base_vector;
+	enum ice_vsi_type type;
 	u16 vsi_num;			 /* HW (absolute) index of this VSI */
+	u16 idx;			 /* software index in pf->vsi[] */
+
+	/* Interrupt thresholds */
+	u16 work_lmt;
+
+	struct ice_aqc_vsi_props info;	 /* VSI properties */
+
+	/* queue information */
+	u8 tx_mapping_mode;		 /* ICE_MAP_MODE_[CONTIG|SCATTER] */
+	u8 rx_mapping_mode;		 /* ICE_MAP_MODE_[CONTIG|SCATTER] */
+	u16 txq_map[ICE_MAX_TXQS];	 /* index in pf->avail_txqs */
+	u16 rxq_map[ICE_MAX_RXQS];	 /* index in pf->avail_rxqs */
+	u16 alloc_txq;			 /* Allocated Tx queues */
+	u16 num_txq;			 /* Used Tx queues */
+	u16 alloc_rxq;			 /* Allocated Rx queues */
+	u16 num_rxq;			 /* Used Rx queues */
+	u16 num_desc;
+	struct ice_tc_cfg tc_cfg;
+} ____cacheline_internodealigned_in_smp;
+
+/* struct that defines an interrupt vector */
+struct ice_q_vector {
+	struct ice_vsi *vsi;
+	cpumask_t affinity_mask;
+	struct napi_struct napi;
+	struct ice_ring_container rx;
+	struct ice_ring_container tx;
+	u16 v_idx;			/* index in the vsi->q_vector array. */
+	u8 num_ring_tx;			/* total number of tx rings in vector */
+	u8 num_ring_rx;			/* total number of rx rings in vector */
 } ____cacheline_internodealigned_in_smp;
 
 enum ice_pf_flags {
@@ -103,6 +171,10 @@ struct ice_pf {
 	char int_name[ICE_INT_NAME_STR_LEN];
 };
 
+struct ice_netdev_priv {
+	struct ice_vsi *vsi;
+};
+
 /**
  * ice_irq_dynamic_ena - Enable default interrupt generation settings
  * @hw: pointer to hw struct

commit 940b61af02f497fcd911b9e2d75c6b8cf76b92fd
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Tue Mar 20 07:58:10 2018 -0700

    ice: Initialize PF and setup miscellaneous interrupt
    
    This patch continues the initialization flow as follows:
    
    1) Allocate and initialize necessary fields (like vsi, num_alloc_vsi,
       irq_tracker, etc) in the ice_pf instance.
    
    2) Setup the miscellaneous interrupt handler. This also known as the
       "other interrupt causes" (OIC) handler and is used to handle non
       hotpath interrupts (like control queue events, link events,
       exceptions, etc.
    
    3) Implement a background task to process admin queue receive (ARQ)
       events received by the driver.
    
    CC: Shannon Nelson <shannon.nelson@oracle.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Acked-by: Shannon Nelson <shannon.nelson@oracle.com>
    Tested-by: Tony Brelinski <tonyx.brelinski@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 1a1776a2a5a1..8103e61e67f9 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -12,29 +12,113 @@
 #include <linux/compiler.h>
 #include <linux/etherdevice.h>
 #include <linux/pci.h>
+#include <linux/workqueue.h>
 #include <linux/aer.h>
+#include <linux/interrupt.h>
+#include <linux/timer.h>
 #include <linux/delay.h>
 #include <linux/bitmap.h>
+#include <linux/if_bridge.h>
 #include "ice_devids.h"
 #include "ice_type.h"
+#include "ice_txrx.h"
 #include "ice_switch.h"
 #include "ice_common.h"
 #include "ice_sched.h"
 
 #define ICE_BAR0		0
+#define ICE_INT_NAME_STR_LEN	(IFNAMSIZ + 16)
 #define ICE_AQ_LEN		64
+#define ICE_MIN_MSIX		2
+#define ICE_MAX_VSI_ALLOC	130
+#define ICE_MAX_TXQS		2048
+#define ICE_MAX_RXQS		2048
+#define ICE_RES_VALID_BIT	0x8000
+#define ICE_RES_MISC_VEC_ID	(ICE_RES_VALID_BIT - 1)
 
 #define ICE_DFLT_NETIF_M (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK)
 
+struct ice_res_tracker {
+	u16 num_entries;
+	u16 search_hint;
+	u16 list[1];
+};
+
+struct ice_sw {
+	struct ice_pf *pf;
+	u16 sw_id;		/* switch ID for this switch */
+	u16 bridge_mode;	/* VEB/VEPA/Port Virtualizer */
+};
+
 enum ice_state {
 	__ICE_DOWN,
+	__ICE_PFR_REQ,			/* set by driver and peers */
+	__ICE_ADMINQ_EVENT_PENDING,
+	__ICE_SERVICE_SCHED,
 	__ICE_STATE_NBITS		/* must be last */
 };
 
+/* struct that defines a VSI, associated with a dev */
+struct ice_vsi {
+	struct net_device *netdev;
+	struct ice_port_info *port_info; /* back pointer to port_info */
+	u16 vsi_num;			 /* HW (absolute) index of this VSI */
+} ____cacheline_internodealigned_in_smp;
+
+enum ice_pf_flags {
+	ICE_FLAG_MSIX_ENA,
+	ICE_FLAG_FLTR_SYNC,
+	ICE_FLAG_RSS_ENA,
+	ICE_PF_FLAGS_NBITS		/* must be last */
+};
+
 struct ice_pf {
 	struct pci_dev *pdev;
+	struct msix_entry *msix_entries;
+	struct ice_res_tracker *irq_tracker;
+	struct ice_vsi **vsi;		/* VSIs created by the driver */
+	struct ice_sw *first_sw;	/* first switch created by firmware */
 	DECLARE_BITMAP(state, __ICE_STATE_NBITS);
+	DECLARE_BITMAP(avail_txqs, ICE_MAX_TXQS);
+	DECLARE_BITMAP(avail_rxqs, ICE_MAX_RXQS);
+	DECLARE_BITMAP(flags, ICE_PF_FLAGS_NBITS);
+	unsigned long serv_tmr_period;
+	unsigned long serv_tmr_prev;
+	struct timer_list serv_tmr;
+	struct work_struct serv_task;
+	struct mutex avail_q_mutex;	/* protects access to avail_[rx|tx]qs */
+	struct mutex sw_mutex;		/* lock for protecting VSI alloc flow */
 	u32 msg_enable;
+	u32 oicr_idx;		/* Other interrupt cause vector index */
+	u32 num_lan_msix;	/* Total MSIX vectors for base driver */
+	u32 num_avail_msix;	/* remaining MSIX vectors left unclaimed */
+	u16 num_lan_tx;		/* num lan tx queues setup */
+	u16 num_lan_rx;		/* num lan rx queues setup */
+	u16 q_left_tx;		/* remaining num tx queues left unclaimed */
+	u16 q_left_rx;		/* remaining num rx queues left unclaimed */
+	u16 next_vsi;		/* Next free slot in pf->vsi[] - 0-based! */
+	u16 num_alloc_vsi;
+
 	struct ice_hw hw;
+	char int_name[ICE_INT_NAME_STR_LEN];
 };
+
+/**
+ * ice_irq_dynamic_ena - Enable default interrupt generation settings
+ * @hw: pointer to hw struct
+ */
+static inline void ice_irq_dynamic_ena(struct ice_hw *hw)
+{
+	u32 vector = ((struct ice_pf *)hw->back)->oicr_idx;
+	int itr = ICE_ITR_NONE;
+	u32 val;
+
+	/* clear the PBA here, as this function is meant to clean out all
+	 * previous interrupts and enable the interrupt
+	 */
+	val = GLINT_DYN_CTL_INTENA_M | GLINT_DYN_CTL_CLEARPBA_M |
+	      (itr << GLINT_DYN_CTL_ITR_INDX_S);
+
+	wr32(hw, GLINT_DYN_CTL(vector), val);
+}
 #endif /* _ICE_H_ */

commit dc49c77236769c571e77d49450b2dfc001d60e33
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Tue Mar 20 07:58:09 2018 -0700

    ice: Get MAC/PHY/link info and scheduler topology
    
    This patch adds code to continue the initialization flow as follows:
    
    1) Get PHY/link information and store it
    2) Get default scheduler tree topology and store it
    3) Get the MAC address associated with the port and store it
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Tony Brelinski <tonyx.brelinski@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 716c555532f4..1a1776a2a5a1 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -10,6 +10,7 @@
 #include <linux/module.h>
 #include <linux/netdevice.h>
 #include <linux/compiler.h>
+#include <linux/etherdevice.h>
 #include <linux/pci.h>
 #include <linux/aer.h>
 #include <linux/delay.h>

commit 9c20346b6309e20f64ee8e7054914ddc92c60baf
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Tue Mar 20 07:58:08 2018 -0700

    ice: Get switch config, scheduler config and device capabilities
    
    This patch adds to the initialization flow by getting switch
    configuration, scheduler configuration and device capabilities.
    
    Switch configuration:
    On boot, an L2 switch element is created in the firmware per physical
    function. Each physical function is also mapped to a port, to which its
    switch element is connected. In other words, this switch can be visualized
    as an embedded vSwitch that can connect a physical function's virtual
    station interfaces (VSIs) to the egress/ingress port. Egress/ingress
    filters will be eventually created and applied on this switch element.
    As part of the initialization flow, the driver gets configuration data
    from this switch element and stores it.
    
    Scheduler configuration:
    The Tx scheduler is a subsystem responsible for setting and enforcing QoS.
    As part of the initialization flow, the driver queries and stores the
    default scheduler configuration for the given physical function.
    
    Device capabilities:
    As part of initialization, the driver has to determine what the device is
    capable of (ex. max queues, VSIs, etc). This information is obtained from
    the firmware and stored by the driver.
    
    CC: Shannon Nelson <shannon.nelson@oracle.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Acked-by: Shannon Nelson <shannon.nelson@oracle.com>
    Tested-by: Tony Brelinski <tonyx.brelinski@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 4c4f161768ed..716c555532f4 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -16,7 +16,9 @@
 #include <linux/bitmap.h>
 #include "ice_devids.h"
 #include "ice_type.h"
+#include "ice_switch.h"
 #include "ice_common.h"
+#include "ice_sched.h"
 
 #define ICE_BAR0		0
 #define ICE_AQ_LEN		64

commit f31e4b6fe227dfd7ed51c3fc0550878c7d7a8cf2
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Tue Mar 20 07:58:07 2018 -0700

    ice: Start hardware initialization
    
    This patch implements multiple pieces of the initialization flow
    as follows:
    
    1) A reset is issued to ensure a clean device state, followed
       by initialization of admin queue interface.
    
    2) Once the admin queue interface is up, clear the PF config
       and transition the device to non-PXE mode.
    
    3) Get the NVM configuration stored in the device's non-volatile
       memory (NVM) using ice_init_nvm.
    
    CC: Shannon Nelson <shannon.nelson@oracle.com>
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Acked-by: Shannon Nelson <shannon.nelson@oracle.com>
    Tested-by: Tony Brelinski <tonyx.brelinski@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 59b1400f9e81..4c4f161768ed 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -16,8 +16,10 @@
 #include <linux/bitmap.h>
 #include "ice_devids.h"
 #include "ice_type.h"
+#include "ice_common.h"
 
 #define ICE_BAR0		0
+#define ICE_AQ_LEN		64
 
 #define ICE_DFLT_NETIF_M (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK)
 

commit 7ec59eeac804a59ea6fff81e89b6e584e9955e5b
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Tue Mar 20 07:58:06 2018 -0700

    ice: Add support for control queues
    
    A control queue is a hardware interface which is used by the driver
    to interact with other subsystems (like firmware, PHY, etc.). It is
    implemented as a producer-consumer ring. More specifically, an
    "admin queue" is a type of control queue used to interact with the
    firmware.
    
    This patch introduces data structures and functions to initialize
    and teardown control/admin queues. Once the admin queue is initialized,
    the driver uses it to get the firmware version.
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Tony Brelinski <tonyx.brelinski@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index e3c1672d4976..59b1400f9e81 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -12,6 +12,7 @@
 #include <linux/compiler.h>
 #include <linux/pci.h>
 #include <linux/aer.h>
+#include <linux/delay.h>
 #include <linux/bitmap.h>
 #include "ice_devids.h"
 #include "ice_type.h"

commit 837f08fdecbe4b2ffc7725624342e73b886665a8
Author: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
Date:   Tue Mar 20 07:58:05 2018 -0700

    ice: Add basic driver framework for Intel(R) E800 Series
    
    This patch adds a basic driver framework for the Intel(R) E800 Ethernet
    Series of network devices. There is no functionality right now other than
    the ability to load.
    
    Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
    Tested-by: Tony Brelinski <tonyx.brelinski@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
new file mode 100644
index 000000000000..e3c1672d4976
--- /dev/null
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -0,0 +1,34 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (c) 2018, Intel Corporation. */
+
+#ifndef _ICE_H_
+#define _ICE_H_
+
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/compiler.h>
+#include <linux/pci.h>
+#include <linux/aer.h>
+#include <linux/bitmap.h>
+#include "ice_devids.h"
+#include "ice_type.h"
+
+#define ICE_BAR0		0
+
+#define ICE_DFLT_NETIF_M (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK)
+
+enum ice_state {
+	__ICE_DOWN,
+	__ICE_STATE_NBITS		/* must be last */
+};
+
+struct ice_pf {
+	struct pci_dev *pdev;
+	DECLARE_BITMAP(state, __ICE_STATE_NBITS);
+	u32 msg_enable;
+	struct ice_hw hw;
+};
+#endif /* _ICE_H_ */
