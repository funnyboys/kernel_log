commit d3757ba4c1421d2ad00d2bf97119005e37ad2902
Author: Joe Perches <joe@perches.com>
Date:   Fri Mar 23 16:34:44 2018 -0700

    ethernet: Use octal not symbolic permissions
    
    Prefer the direct use of octal for permissions.
    
    Done with checkpatch -f --types=SYMBOLIC_PERMS --fix-inplace
    and some typing.
    
    Miscellanea:
    
    o Whitespace neatening around these conversions.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/8390/stnic.c b/drivers/net/ethernet/8390/stnic.c
index aca957d4e121..1f0670cd3ea3 100644
--- a/drivers/net/ethernet/8390/stnic.c
+++ b/drivers/net/ethernet/8390/stnic.c
@@ -71,7 +71,7 @@ static void stnic_init (struct net_device *dev);
 
 static u32 stnic_msg_enable;
 
-module_param_named(msg_enable, stnic_msg_enable, uint, (S_IRUSR|S_IRGRP|S_IROTH));
+module_param_named(msg_enable, stnic_msg_enable, uint, 0444);
 MODULE_PARM_DESC(msg_enable, "Debug message level (see linux/netdevice.h for bitmap)");
 
 /* SH7750 specific read/write io. */

commit c45f812f0280c13f1b7992be5e0de512312a9e8f
Author: Matthew Whitehead <tedheadster@gmail.com>
Date:   Wed Dec 11 17:00:59 2013 -0500

    8390 : Replace ei_debug with msg_enable/NETIF_MSG_* feature
    
    Removed the shared ei_debug variable. Replaced it by adding u32 msg_enable to
    the private struct ei_device. Now each 8390 ethernet instance has a per-device
    logging variable.
    
    Changed older style printk() calls to more canonical forms.
    
    Tested on: ne, ne2k-pci, smc-ultra, and wd hardware.
    
    V4.0
    - Substituted pr_info() and pr_debug() for printk() KERN_INFO and KERN_DEBUG
    
    V3.0
    - Checked for cases where pr_cont() was most appropriate choice.
    - Changed module parameter from 'debug' to 'msg_enable' because debug was
    no longer the best description.
    
    V2.0
    - Changed netif_msg_(drv|probe|ifdown|rx_err|tx_err|tx_queued|intr|rx_status|hw)
    to netif_(dbg|info|warn|err) where possible.
    
    Signed-off-by: Matthew Whitehead <tedheadster@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/8390/stnic.c b/drivers/net/ethernet/8390/stnic.c
index 8df4c4157230..aca957d4e121 100644
--- a/drivers/net/ethernet/8390/stnic.c
+++ b/drivers/net/ethernet/8390/stnic.c
@@ -69,6 +69,11 @@ static void stnic_block_output (struct net_device *dev, int count,
 
 static void stnic_init (struct net_device *dev);
 
+static u32 stnic_msg_enable;
+
+module_param_named(msg_enable, stnic_msg_enable, uint, (S_IRUSR|S_IRGRP|S_IROTH));
+MODULE_PARM_DESC(msg_enable, "Debug message level (see linux/netdevice.h for bitmap)");
+
 /* SH7750 specific read/write io. */
 static inline void
 STNIC_DELAY (void)
@@ -100,6 +105,7 @@ static int __init stnic_probe(void)
 {
   struct net_device *dev;
   int i, err;
+  struct ei_device *ei_local;
 
   /* If we are not running on a SolutionEngine, give up now */
   if (! MACH_SE)
@@ -125,10 +131,10 @@ static int __init stnic_probe(void)
      share and the board will usually be enabled. */
   err = request_irq (dev->irq, ei_interrupt, 0, DRV_NAME, dev);
   if (err)  {
-      printk (KERN_EMERG " unable to get IRQ %d.\n", dev->irq);
-      free_netdev(dev);
-      return err;
-    }
+	netdev_emerg(dev, " unable to get IRQ %d.\n", dev->irq);
+	free_netdev(dev);
+	return err;
+  }
 
   ei_status.name = dev->name;
   ei_status.word16 = 1;
@@ -147,6 +153,8 @@ static int __init stnic_probe(void)
   ei_status.block_output = &stnic_block_output;
 
   stnic_init (dev);
+  ei_local = netdev_priv(dev);
+  ei_local->msg_enable = stnic_msg_enable;
 
   err = register_netdev(dev);
   if (err) {
@@ -156,7 +164,7 @@ static int __init stnic_probe(void)
   }
   stnic_dev = dev;
 
-  printk (KERN_INFO "NS ST-NIC 83902A\n");
+  netdev_info(dev, "NS ST-NIC 83902A\n");
 
   return 0;
 }
@@ -164,10 +172,11 @@ static int __init stnic_probe(void)
 static void
 stnic_reset (struct net_device *dev)
 {
+  struct ei_device *ei_local = netdev_priv(dev);
+
   *(vhalf *) PA_83902_RST = 0;
   udelay (5);
-  if (ei_debug > 1)
-    printk (KERN_WARNING "8390 reset done (%ld).\n", jiffies);
+  netif_warn(ei_local, hw, dev, "8390 reset done (%ld).\n", jiffies);
   *(vhalf *) PA_83902_RST = ~0;
   udelay (5);
 }
@@ -176,6 +185,8 @@ static void
 stnic_get_hdr (struct net_device *dev, struct e8390_pkt_hdr *hdr,
 	       int ring_page)
 {
+  struct ei_device *ei_local = netdev_priv(dev);
+
   half buf[2];
 
   STNIC_WRITE (PG0_RSAR0, 0);
@@ -196,8 +207,7 @@ stnic_get_hdr (struct net_device *dev, struct e8390_pkt_hdr *hdr,
   hdr->count = ((buf[1] >> 8) & 0xff) | (buf[1] << 8);
 #endif
 
-  if (ei_debug > 1)
-    printk (KERN_DEBUG "ring %x status %02x next %02x count %04x.\n",
+  netif_dbg(ei_local, probe, dev, "ring %x status %02x next %02x count %04x.\n",
 	    ring_page, hdr->status, hdr->next, hdr->count);
 
   STNIC_WRITE (STNIC_CR, CR_RDMA | CR_PG0 | CR_STA);

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/net/ethernet/8390/stnic.c b/drivers/net/ethernet/8390/stnic.c
index 3b903759980a..8df4c4157230 100644
--- a/drivers/net/ethernet/8390/stnic.c
+++ b/drivers/net/ethernet/8390/stnic.c
@@ -17,7 +17,6 @@
 #include <linux/init.h>
 #include <linux/delay.h>
 
-#include <asm/system.h>
 #include <asm/io.h>
 #include <mach-se/mach/se.h>
 #include <asm/machvec.h>

commit 104bf3fb963cbc39c6675b23d46d2c9ab3f311d8
Author: Joe Perches <joe@perches.com>
Date:   Wed Nov 16 09:38:03 2011 +0000

    ethernet: Convert ETHER_ADDR_LEN uses to ETH_ALEN
    
    Reduce the number of #defines, use the normal #define from if_ether.h
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/8390/stnic.c b/drivers/net/ethernet/8390/stnic.c
index d85f0a84bc7b..3b903759980a 100644
--- a/drivers/net/ethernet/8390/stnic.c
+++ b/drivers/net/ethernet/8390/stnic.c
@@ -114,7 +114,7 @@ static int __init stnic_probe(void)
 #ifdef CONFIG_SH_STANDARD_BIOS
   sh_bios_get_node_addr (stnic_eadr);
 #endif
-  for (i = 0; i < ETHER_ADDR_LEN; i++)
+  for (i = 0; i < ETH_ALEN; i++)
     dev->dev_addr[i] = stnic_eadr[i];
 
   /* Set the base address to point to the NIC, not the "real" base! */

commit 644570b830266ff33ff5f3542b9c838f93a55ea6
Author: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Date:   Sat Apr 2 06:20:12 2011 -0700

    8390: Move the 8390 related drivers
    
    Moves the drivers for the National Semi-conductor 8390 chipset into
    drivers/net/ethernet/8390/ and the necessary Kconfig and Makefile
    changes.
    
    CC: Donald Becker <becker@scyld.com>
    CC: Paul Gortmaker <paul.gortmaker@windriver.com>
    CC: Alain Malek <alain.malek@cryogen.com>
    CC: Peter De Schrijver <p2@mind.be>
    CC: "David Huggins-Daines" <dhd@debian.org>
    CC: Wim Dumon <wimpie@kotnet.org>
    CC: Yoshinori Sato <ysato@users.sourceforge.jp>
    CC: David Hinds <dahinds@users.sourceforge.net>
    CC: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/8390/stnic.c b/drivers/net/ethernet/8390/stnic.c
new file mode 100644
index 000000000000..d85f0a84bc7b
--- /dev/null
+++ b/drivers/net/ethernet/8390/stnic.c
@@ -0,0 +1,294 @@
+/* stnic.c : A SH7750 specific part of driver for NS DP83902A ST-NIC.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1999 kaz Kojima
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <mach-se/mach/se.h>
+#include <asm/machvec.h>
+#ifdef CONFIG_SH_STANDARD_BIOS
+#include <asm/sh_bios.h>
+#endif
+
+#include "8390.h"
+
+#define DRV_NAME "stnic"
+
+#define byte	unsigned char
+#define half	unsigned short
+#define word	unsigned int
+#define vbyte	volatile unsigned char
+#define vhalf	volatile unsigned short
+#define vword	volatile unsigned int
+
+#define STNIC_RUN	0x01	/* 1 == Run, 0 == reset. */
+
+#define START_PG	0	/* First page of TX buffer */
+#define STOP_PG		128	/* Last page +1 of RX ring */
+
+/* Alias */
+#define STNIC_CR	E8390_CMD
+#define PG0_RSAR0	EN0_RSARLO
+#define PG0_RSAR1	EN0_RSARHI
+#define PG0_RBCR0	EN0_RCNTLO
+#define PG0_RBCR1	EN0_RCNTHI
+
+#define CR_RRD		E8390_RREAD
+#define CR_RWR		E8390_RWRITE
+#define CR_PG0		E8390_PAGE0
+#define CR_STA		E8390_START
+#define CR_RDMA		E8390_NODMA
+
+/* FIXME! YOU MUST SET YOUR OWN ETHER ADDRESS.  */
+static byte stnic_eadr[6] =
+{0x00, 0xc0, 0x6e, 0x00, 0x00, 0x07};
+
+static struct net_device *stnic_dev;
+
+static void stnic_reset (struct net_device *dev);
+static void stnic_get_hdr (struct net_device *dev, struct e8390_pkt_hdr *hdr,
+			   int ring_page);
+static void stnic_block_input (struct net_device *dev, int count,
+			       struct sk_buff *skb , int ring_offset);
+static void stnic_block_output (struct net_device *dev, int count,
+				const unsigned char *buf, int start_page);
+
+static void stnic_init (struct net_device *dev);
+
+/* SH7750 specific read/write io. */
+static inline void
+STNIC_DELAY (void)
+{
+  vword trash;
+  trash = *(vword *) 0xa0000000;
+  trash = *(vword *) 0xa0000000;
+  trash = *(vword *) 0xa0000000;
+}
+
+static inline byte
+STNIC_READ (int reg)
+{
+  byte val;
+
+  val = (*(vhalf *) (PA_83902 + ((reg) << 1)) >> 8) & 0xff;
+  STNIC_DELAY ();
+  return val;
+}
+
+static inline void
+STNIC_WRITE (int reg, byte val)
+{
+  *(vhalf *) (PA_83902 + ((reg) << 1)) = ((half) (val) << 8);
+  STNIC_DELAY ();
+}
+
+static int __init stnic_probe(void)
+{
+  struct net_device *dev;
+  int i, err;
+
+  /* If we are not running on a SolutionEngine, give up now */
+  if (! MACH_SE)
+    return -ENODEV;
+
+  /* New style probing API */
+  dev = alloc_ei_netdev();
+  if (!dev)
+  	return -ENOMEM;
+
+#ifdef CONFIG_SH_STANDARD_BIOS
+  sh_bios_get_node_addr (stnic_eadr);
+#endif
+  for (i = 0; i < ETHER_ADDR_LEN; i++)
+    dev->dev_addr[i] = stnic_eadr[i];
+
+  /* Set the base address to point to the NIC, not the "real" base! */
+  dev->base_addr = 0x1000;
+  dev->irq = IRQ_STNIC;
+  dev->netdev_ops = &ei_netdev_ops;
+
+  /* Snarf the interrupt now.  There's no point in waiting since we cannot
+     share and the board will usually be enabled. */
+  err = request_irq (dev->irq, ei_interrupt, 0, DRV_NAME, dev);
+  if (err)  {
+      printk (KERN_EMERG " unable to get IRQ %d.\n", dev->irq);
+      free_netdev(dev);
+      return err;
+    }
+
+  ei_status.name = dev->name;
+  ei_status.word16 = 1;
+#ifdef __LITTLE_ENDIAN__
+  ei_status.bigendian = 0;
+#else
+  ei_status.bigendian = 1;
+#endif
+  ei_status.tx_start_page = START_PG;
+  ei_status.rx_start_page = START_PG + TX_PAGES;
+  ei_status.stop_page = STOP_PG;
+
+  ei_status.reset_8390 = &stnic_reset;
+  ei_status.get_8390_hdr = &stnic_get_hdr;
+  ei_status.block_input = &stnic_block_input;
+  ei_status.block_output = &stnic_block_output;
+
+  stnic_init (dev);
+
+  err = register_netdev(dev);
+  if (err) {
+    free_irq(dev->irq, dev);
+    free_netdev(dev);
+    return err;
+  }
+  stnic_dev = dev;
+
+  printk (KERN_INFO "NS ST-NIC 83902A\n");
+
+  return 0;
+}
+
+static void
+stnic_reset (struct net_device *dev)
+{
+  *(vhalf *) PA_83902_RST = 0;
+  udelay (5);
+  if (ei_debug > 1)
+    printk (KERN_WARNING "8390 reset done (%ld).\n", jiffies);
+  *(vhalf *) PA_83902_RST = ~0;
+  udelay (5);
+}
+
+static void
+stnic_get_hdr (struct net_device *dev, struct e8390_pkt_hdr *hdr,
+	       int ring_page)
+{
+  half buf[2];
+
+  STNIC_WRITE (PG0_RSAR0, 0);
+  STNIC_WRITE (PG0_RSAR1, ring_page);
+  STNIC_WRITE (PG0_RBCR0, 4);
+  STNIC_WRITE (PG0_RBCR1, 0);
+  STNIC_WRITE (STNIC_CR, CR_RRD | CR_PG0 | CR_STA);
+
+  buf[0] = *(vhalf *) PA_83902_IF;
+  STNIC_DELAY ();
+  buf[1] = *(vhalf *) PA_83902_IF;
+  STNIC_DELAY ();
+  hdr->next = buf[0] >> 8;
+  hdr->status = buf[0] & 0xff;
+#ifdef __LITTLE_ENDIAN__
+  hdr->count = buf[1];
+#else
+  hdr->count = ((buf[1] >> 8) & 0xff) | (buf[1] << 8);
+#endif
+
+  if (ei_debug > 1)
+    printk (KERN_DEBUG "ring %x status %02x next %02x count %04x.\n",
+	    ring_page, hdr->status, hdr->next, hdr->count);
+
+  STNIC_WRITE (STNIC_CR, CR_RDMA | CR_PG0 | CR_STA);
+}
+
+/* Block input and output, similar to the Crynwr packet driver. If you are
+   porting to a new ethercard look at the packet driver source for hints.
+   The HP LAN doesn't use shared memory -- we put the packet
+   out through the "remote DMA" dataport. */
+
+static void
+stnic_block_input (struct net_device *dev, int length, struct sk_buff *skb,
+		   int offset)
+{
+  char *buf = skb->data;
+  half val;
+
+  STNIC_WRITE (PG0_RSAR0, offset & 0xff);
+  STNIC_WRITE (PG0_RSAR1, offset >> 8);
+  STNIC_WRITE (PG0_RBCR0, length & 0xff);
+  STNIC_WRITE (PG0_RBCR1, length >> 8);
+  STNIC_WRITE (STNIC_CR, CR_RRD | CR_PG0 | CR_STA);
+
+  if (length & 1)
+    length++;
+
+  while (length > 0)
+    {
+      val = *(vhalf *) PA_83902_IF;
+#ifdef __LITTLE_ENDIAN__
+      *buf++ = val & 0xff;
+      *buf++ = val >> 8;
+#else
+      *buf++ = val >> 8;
+      *buf++ = val & 0xff;
+#endif
+      STNIC_DELAY ();
+      length -= sizeof (half);
+    }
+
+  STNIC_WRITE (STNIC_CR, CR_RDMA | CR_PG0 | CR_STA);
+}
+
+static void
+stnic_block_output (struct net_device *dev, int length,
+		    const unsigned char *buf, int output_page)
+{
+  STNIC_WRITE (PG0_RBCR0, 1);	/* Write non-zero value */
+  STNIC_WRITE (STNIC_CR, CR_RRD | CR_PG0 | CR_STA);
+  STNIC_DELAY ();
+
+  STNIC_WRITE (PG0_RBCR0, length & 0xff);
+  STNIC_WRITE (PG0_RBCR1, length >> 8);
+  STNIC_WRITE (PG0_RSAR0, 0);
+  STNIC_WRITE (PG0_RSAR1, output_page);
+  STNIC_WRITE (STNIC_CR, CR_RWR | CR_PG0 | CR_STA);
+
+  if (length & 1)
+    length++;
+
+  while (length > 0)
+    {
+#ifdef __LITTLE_ENDIAN__
+      *(vhalf *) PA_83902_IF = ((half) buf[1] << 8) | buf[0];
+#else
+      *(vhalf *) PA_83902_IF = ((half) buf[0] << 8) | buf[1];
+#endif
+      STNIC_DELAY ();
+      buf += sizeof (half);
+      length -= sizeof (half);
+    }
+
+  STNIC_WRITE (STNIC_CR, CR_RDMA | CR_PG0 | CR_STA);
+}
+
+/* This function resets the STNIC if something screws up.  */
+static void
+stnic_init (struct net_device *dev)
+{
+  stnic_reset (dev);
+  NS8390_init (dev, 0);
+}
+
+static void __exit stnic_cleanup(void)
+{
+	unregister_netdev(stnic_dev);
+	free_irq(stnic_dev->irq, stnic_dev);
+	free_netdev(stnic_dev);
+}
+
+module_init(stnic_probe);
+module_exit(stnic_cleanup);
+MODULE_LICENSE("GPL");
