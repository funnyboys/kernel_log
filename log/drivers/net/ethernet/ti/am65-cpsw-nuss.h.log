commit 8127224c2708aa1558e2be7bbd1b7e9b07860de6
Author: Ivan Khoronzhuk <ivan.khoronzhuk@linaro.org>
Date:   Wed May 13 09:26:15 2020 -0400

    ethernet: ti: am65-cpsw-qos: add TAPRIO offload support
    
    AM65 CPSW h/w supports Enhanced Scheduled Traffic (EST – defined
    in P802.1Qbv/D2.2 that later got included in IEEE 802.1Q-2018)
    configuration. EST allows express queue traffic to be scheduled
    (placed) on the wire at specific repeatable time intervals. In
    Linux kernel, EST configuration is done through tc command and
    the taprio scheduler in the net core implements a software only
    scheduler (SCH_TAPRIO). If the NIC is capable of EST configuration,
    user indicate "flag 2" in the command which is then parsed by
    taprio scheduler in net core and indicate that the command is to
    be offloaded to h/w. taprio then offloads the command to the
    driver by calling ndo_setup_tc() ndo ops. This patch implements
    ndo_setup_tc() to offload EST configuration to CPSW h/w.
    
    Currently driver supports only SetGateStates operation. EST
    operates on a repeating time interval generated by the CPTS EST
    function generator. Each Ethernet port has a global EST fetch
    RAM that can be configured as 2 buffers, each of 64 locations
    or one large buffer of 128 locations. In 2 buffer configuration,
    a ping pong mechanism is used to hold the active schedule (oper)
    in one buffer and new (admin) command in the other. Each 22-bit
    fetch command consists of a 14-bit fetch count (14 MSB’s) and an
    8-bit priority fetch allow (8 LSB’s) that will be applied for the
    fetch count time in wireside clocks. Driver process each of the
    sched-entry in the offload command and update the fetch RAM.
    Driver configures duration in sched-entry into the fetch count
    and Gate mask into the priority fetch bits of the RAM. Then
    configures the CPTS EST function generator to activate the
    schedule. Currently driver supports only 2 buffer configuration
    which means driver supports a max cycle time of ~8 msec.
    
    CPSW supports a configurable number of priority queues (up to 8)
    and needs to be switched to this mode from the default round
    robin mode before EST can be offloaded. User configures
    these through ethtool commands (-L for changing number of
    queues and --set-priv-flags to disable round robin mode).
    Driver doesn't enable EST if pf_p0_rx_ptype_rrobin privat flag
    is set. The flag is common for all ports, and so can't be just
    overridden by taprio configuration w/o user involvement.
    Command fails if pf_p0_rx_ptype_rrobin is already set in the
    driver.
    
    Scheds (commands) configuration depends on interface speed so
    driver translates the duration to the fetch count based on
    link speed. Each schedule can be constructed with several
    command entries in fetch RAM  depending on interval. For example
    if each sched has timer interval < ~130us on 1000 Mb link then
    each sched consumes one command and have 1:1 mapping. When
    Ethernet link goes down, driver purge the configuration if link
    is down for more than 1 second.
    
    The patch allows to update the timer and scheds memory only if it's
    really needed, and skip cases required the user to stop timer by
    configuring only shceds memory.
    
    Signed-off-by: Ivan Khoronzhuk <ivan.khoronzhuk@linaro.org>
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/am65-cpsw-nuss.h b/drivers/net/ethernet/ti/am65-cpsw-nuss.h
index 8a6382188cb5..9faf4fb1409b 100644
--- a/drivers/net/ethernet/ti/am65-cpsw-nuss.h
+++ b/drivers/net/ethernet/ti/am65-cpsw-nuss.h
@@ -9,7 +9,9 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/netdevice.h>
+#include <linux/phy.h>
 #include <linux/platform_device.h>
+#include "am65-cpsw-qos.h"
 
 struct am65_cpts;
 
@@ -38,10 +40,12 @@ struct am65_cpsw_port {
 	u32				port_id;
 	void __iomem			*port_base;
 	void __iomem			*stat_base;
+	void __iomem			*fetch_ram_base;
 	bool				disabled;
 	struct am65_cpsw_slave_data	slave;
 	bool				tx_ts_enabled;
 	bool				rx_ts_enabled;
+	struct am65_cpsw_qos		qos;
 };
 
 struct am65_cpsw_host {
@@ -104,6 +108,7 @@ struct am65_cpsw_common {
 	u32			cpsw_ver;
 	bool			pf_p0_rx_ptype_rrobin;
 	struct am65_cpts	*cpts;
+	int			est_enabled;
 };
 
 struct am65_cpsw_ndev_stats {

commit a45cfcc69a2519463db0e18db5b7f9c7739f559d
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Wed May 6 21:13:59 2020 +0300

    net: ethernet: ti: am65-cpsw-nuss: use of_platform_device_create() for mdio
    
    The MCU CPSW expected to populate only MDIO device, but follow up patches
    will add "compatible" property to the MCU CPSW CPTS node which will cause
    creation of CPTS device and MCU CPSW init failure. Hence, switch to use
    of_platform_device_create() instead of of_platform_populate() for MDIO
    device population.
    
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/am65-cpsw-nuss.h b/drivers/net/ethernet/ti/am65-cpsw-nuss.h
index b1cddfd05a45..8a6382188cb5 100644
--- a/drivers/net/ethernet/ti/am65-cpsw-nuss.h
+++ b/drivers/net/ethernet/ti/am65-cpsw-nuss.h
@@ -9,6 +9,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/netdevice.h>
+#include <linux/platform_device.h>
 
 struct am65_cpts;
 
@@ -76,6 +77,7 @@ struct am65_cpsw_pdata {
 
 struct am65_cpsw_common {
 	struct device		*dev;
+	struct device		*mdio_dev;
 	const struct am65_cpsw_pdata *pdata;
 
 	void __iomem		*ss_base;

commit b1f66a5bee07adaab218fb98800928185e5f0f18
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Fri May 1 23:50:07 2020 +0300

    net: ethernet: ti: am65-cpsw-nuss: enable packet timestamping support
    
    The MCU CPSW Common Platform Time Sync (CPTS) provides possibility to
    timestamp TX PTP packets and all RX packets.
    
    This enables corresponding support in TI AM65x/J721E MCU CPSW driver.
    
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/am65-cpsw-nuss.h b/drivers/net/ethernet/ti/am65-cpsw-nuss.h
index 41ae5b4c7931..b1cddfd05a45 100644
--- a/drivers/net/ethernet/ti/am65-cpsw-nuss.h
+++ b/drivers/net/ethernet/ti/am65-cpsw-nuss.h
@@ -10,6 +10,8 @@
 #include <linux/module.h>
 #include <linux/netdevice.h>
 
+struct am65_cpts;
+
 #define HOST_PORT_NUM		0
 
 #define AM65_CPSW_MAX_TX_QUEUES	8
@@ -37,6 +39,8 @@ struct am65_cpsw_port {
 	void __iomem			*stat_base;
 	bool				disabled;
 	struct am65_cpsw_slave_data	slave;
+	bool				tx_ts_enabled;
+	bool				rx_ts_enabled;
 };
 
 struct am65_cpsw_host {
@@ -96,8 +100,8 @@ struct am65_cpsw_common {
 
 	u32			nuss_ver;
 	u32			cpsw_ver;
-
 	bool			pf_p0_rx_ptype_rrobin;
+	struct am65_cpts	*cpts;
 };
 
 struct am65_cpsw_ndev_stats {

commit 93a76530316a3d8cc2d82c3deca48424fee92100
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Tue Mar 24 00:52:49 2020 +0200

    net: ethernet: ti: introduce am65x/j721e gigabit eth subsystem driver
    
    The TI AM65x/J721E SoCs Gigabit Ethernet Switch subsystem (CPSW2G NUSS) has
    two ports - One Ethernet port (port 1) with selectable RGMII and RMII
    interfaces and an internal Communications Port Programming Interface (CPPI)
    port (Host port 0) and with ALE in between. It also contains
     - Management Data Input/Output (MDIO) interface for physical layer device
    (PHY) management;
     - Updated Address Lookup Engine (ALE) module;
     - (TBD) New version of Common platform time sync (CPTS) module.
    
    On the TI am65x/J721E SoCs CPSW NUSS Ethernet subsystem into device MCU
    domain named MCU_CPSW0.
    
    Host Port 0 CPPI Packet Streaming Interface interface supports 8 TX
    channels and one RX channels operating by TI am654 NAVSS Unified DMA
    Peripheral Root Complex (UDMA-P) controller.
    
    Introduced driver provides standard Linux net_device to user space and supports:
     - ifconfig up/down
     - MAC address configuration
     - ethtool operation:
       --driver
       --change
       --register-dump
       --negotiate phy
       --statistics
       --set-eee phy
       --show-ring
       --show-channels
       --set-channels
     - net_device ioctl mii-control
     - promisc mode
    
     - rx checksum offload for non-fragmented IPv4/IPv6 TCP/UDP packets.
       The CPSW NUSS can verify IPv4/IPv6 TCP/UDP packets checksum and fills
       csum information for each packet in psdata[2] word:
       - BIT(16) CHECKSUM_ERROR - indicates csum error
       - BIT(17) FRAGMENT -  indicates fragmented packet
       - BIT(18) TCP_UDP_N -  Indicates TCP packet was detected
       - BIT(19) IPV6_VALID,  BIT(20) IPV4_VALID - indicates IPv6/IPv4 packet
       - BIT(15, 0) CHECKSUM_ADD - This is the value that was summed
       during the checksum computation. This value is FFFFh for non fragmented
       IPV4/6 UDP/TCP packets with no checksum error.
    
       RX csum offload can be disabled:
             ethtool -K <dev> rx-checksum on|off
    
     - tx checksum offload support for IPv4/IPv6 TCP/UDP packets (J721E only).
       TX csum HW offload  can be enabled/disabled:
             ethtool -K <dev> tx-checksum-ip-generic on|off
    
     - multiq and switch between round robin/prio modes for cppi tx queues by
       using Netdev private flag "p0-rx-ptype-rrobin" to switch between
       Round Robin and Fixed priority modes:
             # ethtool --show-priv-flags eth0
             Private flags for eth0:
             p0-rx-ptype-rrobin: on
             # ethtool --set-priv-flags eth0 p0-rx-ptype-rrobin off
    
       Number of TX DMA channels can be changed using "ethtool -L eth0 tx <N>".
    
     - GRO support: the napi_gro_receive() and napi_complete_done() are used.
    
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Tested-by: Murali Karicheri <m-karicheri2@ti.com>
    Tested-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/am65-cpsw-nuss.h b/drivers/net/ethernet/ti/am65-cpsw-nuss.h
new file mode 100644
index 000000000000..41ae5b4c7931
--- /dev/null
+++ b/drivers/net/ethernet/ti/am65-cpsw-nuss.h
@@ -0,0 +1,142 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2020 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ */
+
+#ifndef AM65_CPSW_NUSS_H_
+#define AM65_CPSW_NUSS_H_
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+
+#define HOST_PORT_NUM		0
+
+#define AM65_CPSW_MAX_TX_QUEUES	8
+#define AM65_CPSW_MAX_RX_QUEUES	1
+#define AM65_CPSW_MAX_RX_FLOWS	1
+
+struct am65_cpsw_slave_data {
+	bool				mac_only;
+	struct cpsw_sl			*mac_sl;
+	struct device_node		*phy_node;
+	struct phy_device		*phy;
+	phy_interface_t			phy_if;
+	struct phy			*ifphy;
+	bool				rx_pause;
+	bool				tx_pause;
+	u8				mac_addr[ETH_ALEN];
+};
+
+struct am65_cpsw_port {
+	struct am65_cpsw_common		*common;
+	struct net_device		*ndev;
+	const char			*name;
+	u32				port_id;
+	void __iomem			*port_base;
+	void __iomem			*stat_base;
+	bool				disabled;
+	struct am65_cpsw_slave_data	slave;
+};
+
+struct am65_cpsw_host {
+	struct am65_cpsw_common		*common;
+	void __iomem			*port_base;
+	void __iomem			*stat_base;
+};
+
+struct am65_cpsw_tx_chn {
+	struct napi_struct napi_tx;
+	struct am65_cpsw_common	*common;
+	struct k3_cppi_desc_pool *desc_pool;
+	struct k3_udma_glue_tx_channel *tx_chn;
+	int irq;
+	u32 id;
+	u32 descs_num;
+	char tx_chn_name[128];
+};
+
+struct am65_cpsw_rx_chn {
+	struct device *dev;
+	struct k3_cppi_desc_pool *desc_pool;
+	struct k3_udma_glue_rx_channel *rx_chn;
+	u32 descs_num;
+	int irq;
+};
+
+#define AM65_CPSW_QUIRK_I2027_NO_TX_CSUM BIT(0)
+
+struct am65_cpsw_pdata {
+	u32	quirks;
+};
+
+struct am65_cpsw_common {
+	struct device		*dev;
+	const struct am65_cpsw_pdata *pdata;
+
+	void __iomem		*ss_base;
+	void __iomem		*cpsw_base;
+
+	u32			port_num;
+	struct am65_cpsw_host   host;
+	struct am65_cpsw_port	*ports;
+	u32			disabled_ports_mask;
+
+	int			usage_count; /* number of opened ports */
+	struct cpsw_ale		*ale;
+	int			tx_ch_num;
+	u32			rx_flow_id_base;
+
+	struct am65_cpsw_tx_chn	tx_chns[AM65_CPSW_MAX_TX_QUEUES];
+	struct completion	tdown_complete;
+	atomic_t		tdown_cnt;
+
+	struct am65_cpsw_rx_chn	rx_chns;
+	struct napi_struct	napi_rx;
+
+	u32			nuss_ver;
+	u32			cpsw_ver;
+
+	bool			pf_p0_rx_ptype_rrobin;
+};
+
+struct am65_cpsw_ndev_stats {
+	u64 tx_packets;
+	u64 tx_bytes;
+	u64 rx_packets;
+	u64 rx_bytes;
+	struct u64_stats_sync syncp;
+};
+
+struct am65_cpsw_ndev_priv {
+	u32			msg_enable;
+	struct am65_cpsw_port	*port;
+	struct am65_cpsw_ndev_stats __percpu *stats;
+};
+
+#define am65_ndev_to_priv(ndev) \
+	((struct am65_cpsw_ndev_priv *)netdev_priv(ndev))
+#define am65_ndev_to_port(ndev) (am65_ndev_to_priv(ndev)->port)
+#define am65_ndev_to_common(ndev) (am65_ndev_to_port(ndev)->common)
+#define am65_ndev_to_slave(ndev) (&am65_ndev_to_port(ndev)->slave)
+
+#define am65_common_get_host(common) (&(common)->host)
+#define am65_common_get_port(common, id) (&(common)->ports[(id) - 1])
+
+#define am65_cpsw_napi_to_common(pnapi) \
+	container_of(pnapi, struct am65_cpsw_common, napi_rx)
+#define am65_cpsw_napi_to_tx_chn(pnapi) \
+	container_of(pnapi, struct am65_cpsw_tx_chn, napi_tx)
+
+#define AM65_CPSW_DRV_NAME "am65-cpsw-nuss"
+
+#define AM65_CPSW_IS_CPSW2G(common) ((common)->port_num == 1)
+
+extern const struct ethtool_ops am65_cpsw_ethtool_ops_slave;
+
+void am65_cpsw_nuss_adjust_link(struct net_device *ndev);
+void am65_cpsw_nuss_set_p0_ptype(struct am65_cpsw_common *common);
+void am65_cpsw_nuss_remove_tx_chns(struct am65_cpsw_common *common);
+int am65_cpsw_nuss_update_tx_chns(struct am65_cpsw_common *common, int num_tx);
+
+#endif /* AM65_CPSW_NUSS_H_ */
