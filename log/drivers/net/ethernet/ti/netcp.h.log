commit 68cf027f3d9d586366391beed8721ba319fee5c0
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Fri Apr 26 20:12:23 2019 +0300

    net: ethernet: ti: convert to SPDX license identifiers
    
    Replace textual license with SPDX-License-Identifier.
    
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/netcp.h b/drivers/net/ethernet/ti/netcp.h
index c4ffdf47bad5..43d5cd59b56b 100644
--- a/drivers/net/ethernet/ti/netcp.h
+++ b/drivers/net/ethernet/ti/netcp.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * NetCP driver local header
  *
@@ -8,15 +9,6 @@
  *		Santosh Shilimkar <santosh.shilimkar@ti.com>
  *		Wingman Kwok <w-kwok2@ti.com>
  *		Murali Karicheri <m-karicheri2@ti.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation version 2.
- *
- * This program is distributed "as is" WITHOUT ANY WARRANTY of any
- * kind, whether express or implied; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 #ifndef __NETCP_H__
 #define __NETCP_H__

commit 0542a87c546726510e7a572b16c5493ca42024c4
Author: WingMan Kwok <w-kwok2@ti.com>
Date:   Tue Apr 17 17:30:41 2018 -0400

    net: netcp: add api to support set rx mode in netcp modules
    
    This patch adds an API to support setting rx mode in
    netcp modules.  If a netcp module needs to be notified
    when upper layer transitions from one rx mode to
    another and react accordingly, such a module will implement
    the new API set_rx_mode added in this patch.  Currently
    rx modes supported are PROMISCUOUS and NON_PROMISCUOUS
    modes.
    
    Signed-off-by: WingMan Kwok <w-kwok2@ti.com>
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/netcp.h b/drivers/net/ethernet/ti/netcp.h
index 416f732a00f7..c4ffdf47bad5 100644
--- a/drivers/net/ethernet/ti/netcp.h
+++ b/drivers/net/ethernet/ti/netcp.h
@@ -214,6 +214,7 @@ struct netcp_module {
 	int	(*add_vid)(void *intf_priv, int vid);
 	int	(*del_vid)(void *intf_priv, int vid);
 	int	(*ioctl)(void *intf_priv, struct ifreq *req, int cmd);
+	int	(*set_rx_mode)(void *intf_priv, bool promisc);
 
 	/* used internally */
 	struct list_head	module_list;

commit 478e9a5fcf3fda621f3d660979c42d24f3435d73
Author: Murali Karicheri <m-karicheri2@ti.com>
Date:   Tue Apr 17 17:30:34 2018 -0400

    net: netcp: ethss: add support for handling rgmii link interface
    
    2u cpsw hardware on K2G uses rgmii link to interface with Phy. So add
    support for this interface in the code so that driver can be re-used
    for 2u hardware.
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/netcp.h b/drivers/net/ethernet/ti/netcp.h
index 8900a6fad318..416f732a00f7 100644
--- a/drivers/net/ethernet/ti/netcp.h
+++ b/drivers/net/ethernet/ti/netcp.h
@@ -33,6 +33,8 @@
 #define SGMII_LINK_MAC_MAC_FORCED	2
 #define SGMII_LINK_MAC_FIBER		3
 #define SGMII_LINK_MAC_PHY_NO_MDIO	4
+#define RGMII_LINK_MAC_PHY		5
+#define RGMII_LINK_MAC_PHY_NO_MDIO	7
 #define XGMII_LINK_MAC_PHY		10
 #define XGMII_LINK_MAC_MAC_FORCED	11
 

commit 4cd85a61d2185a79389cd5e52c02223db9062559
Author: Karicheri, Muralidharan <m-karicheri2@ti.com>
Date:   Fri Jan 6 15:37:43 2017 -0500

    net: netcp: use hw capability to remove FCS word from rx packets
    
    Some of the newer Ethernet switch hw (such as that on k2e/l/g) can
    strip the Etherenet FCS from packet at the port 0 egress of the switch.
    So use this capability instead of doing it in software.
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/netcp.h b/drivers/net/ethernet/ti/netcp.h
index d243c5df9d6b..8900a6fad318 100644
--- a/drivers/net/ethernet/ti/netcp.h
+++ b/drivers/net/ethernet/ti/netcp.h
@@ -102,6 +102,8 @@ struct netcp_intf {
 	void			*rx_fdq[KNAV_DMA_FDQ_PER_CHAN];
 	struct napi_struct	rx_napi;
 	struct napi_struct	tx_napi;
+#define ETH_SW_CAN_REMOVE_ETH_FCS	BIT(0)
+	u32			hw_cap;
 
 	/* 64-bit netcp stats */
 	struct netcp_stats	stats;

commit 6a8162e99ef344fcffe14c9a4d1061493c4a81a4
Author: Michael Scherban <m-scherban@ti.com>
Date:   Fri Jan 6 15:37:41 2017 -0500

    net: netcp: store network statistics in 64 bits
    
    Previously the network statistics were stored in 32 bit variable
    which can cause some stats to roll over after several minutes of
    high traffic. This implements 64 bit storage so larger numbers
    can be stored.
    
    Signed-off-by: Michael Scherban <m-scherban@ti.com>
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/netcp.h b/drivers/net/ethernet/ti/netcp.h
index a92abd62ec60..d243c5df9d6b 100644
--- a/drivers/net/ethernet/ti/netcp.h
+++ b/drivers/net/ethernet/ti/netcp.h
@@ -23,6 +23,7 @@
 
 #include <linux/netdevice.h>
 #include <linux/soc/ti/knav_dma.h>
+#include <linux/u64_stats_sync.h>
 
 /* Maximum Ethernet frame size supported by Keystone switch */
 #define NETCP_MAX_FRAME_SIZE		9504
@@ -68,6 +69,20 @@ struct netcp_addr {
 	struct list_head	node;
 };
 
+struct netcp_stats {
+	struct u64_stats_sync   syncp_rx ____cacheline_aligned_in_smp;
+	u64                     rx_packets;
+	u64                     rx_bytes;
+	u32                     rx_errors;
+	u32                     rx_dropped;
+
+	struct u64_stats_sync   syncp_tx ____cacheline_aligned_in_smp;
+	u64                     tx_packets;
+	u64                     tx_bytes;
+	u32                     tx_errors;
+	u32                     tx_dropped;
+};
+
 struct netcp_intf {
 	struct device		*dev;
 	struct device		*ndev_dev;
@@ -88,6 +103,9 @@ struct netcp_intf {
 	struct napi_struct	rx_napi;
 	struct napi_struct	tx_napi;
 
+	/* 64-bit netcp stats */
+	struct netcp_stats	stats;
+
 	void			*rx_channel;
 	const char		*dma_chan_name;
 	u32			rx_pool_size;

commit 69d707d034b6078f0b5998f80e5883c8243b205c
Author: Karicheri, Muralidharan <m-karicheri2@ti.com>
Date:   Fri Jan 6 15:37:39 2017 -0500

    net: netcp: extract eflag from desc for rx_hook handling
    
    Extract the eflag bits from the received desc and pass it down
    the rx_hook chain to be available for netcp modules. Also the
    psdata and epib data has to be inspected by the netcp modules.
    So the desc can be freed only after returning from the rx_hook.
    So move knav_pool_desc_put() after the rx_hook processing.
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/netcp.h b/drivers/net/ethernet/ti/netcp.h
index 0f58c584ae09..a92abd62ec60 100644
--- a/drivers/net/ethernet/ti/netcp.h
+++ b/drivers/net/ethernet/ti/netcp.h
@@ -115,6 +115,7 @@ struct netcp_packet {
 	struct sk_buff		*skb;
 	__le32			*epib;
 	u32			*psdata;
+	u32			eflags;
 	unsigned int		psdata_len;
 	struct netcp_intf	*netcp;
 	struct netcp_tx_pipe	*tx_pipe;

commit 6246168b4a38357b135d07370464f27d4f3a68ce
Author: WingMan Kwok <w-kwok2@ti.com>
Date:   Thu Dec 8 16:21:56 2016 -0600

    net: ethernet: ti: netcp: add support of cpts
    
    This patch adds support of the cpts device found in the
    gbe and 10gbe ethernet switches on the keystone 2 SoCs
    (66AK2E/L/Hx, 66AK2Gx).
    
    Cc: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: WingMan Kwok <w-kwok2@ti.com>
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/netcp.h b/drivers/net/ethernet/ti/netcp.h
index 17a26a429b71..0f58c584ae09 100644
--- a/drivers/net/ethernet/ti/netcp.h
+++ b/drivers/net/ethernet/ti/netcp.h
@@ -121,7 +121,7 @@ struct netcp_packet {
 	bool			rxtstamp_complete;
 	void			*ts_context;
 
-	int	(*txtstamp_complete)(void *ctx, struct netcp_packet *pkt);
+	void (*txtstamp)(void *ctx, struct sk_buff *skb);
 };
 
 static inline u32 *netcp_push_psdata(struct netcp_packet *p_info,

commit 9dd2d6c5c9755b160fe0111bcdad9491676feea8
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Dec 8 16:32:59 2015 +0100

    netcp: add more __le32 annotations
    
    The handling of epib and psdata remains a bit unclear in the driver,
    as we access the same fields both as CPU-endian and through DMA
    from the device.
    
    Sparse warns about this:
    ti/netcp_core.c:1147:21: warning: incorrect type in assignment (different base types)
    ti/netcp_core.c:1147:21:    expected unsigned int [usertype] *[assigned] epib
    ti/netcp_core.c:1147:21:    got restricted __le32 *<noident>
    
    This uses __le32 types in a few places and uses __force where the code
    looks fishy. The previous patch should really have produced the correct
    behavior, but this second patch is needed to shut up the warnings about
    it. Ideally it would be slightly rewritten to not need those casts,
    but I don't dare do that without access to the hardware for proper
    testing.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/netcp.h b/drivers/net/ethernet/ti/netcp.h
index bb1bb72121c0..17a26a429b71 100644
--- a/drivers/net/ethernet/ti/netcp.h
+++ b/drivers/net/ethernet/ti/netcp.h
@@ -113,7 +113,7 @@ struct netcp_intf {
 #define	NETCP_PSDATA_LEN		KNAV_DMA_NUM_PS_WORDS
 struct netcp_packet {
 	struct sk_buff		*skb;
-	u32			*epib;
+	__le32			*epib;
 	u32			*psdata;
 	unsigned int		psdata_len;
 	struct netcp_intf	*netcp;

commit 866b8b18e380f810ba96e21d25843b841271bb07
Author: WingMan Kwok <w-kwok2@ti.com>
Date:   Tue Aug 4 16:56:53 2015 -0400

    net: netcp: fix unused interface rx buffer size configuration
    
    Prior to this patch, rx buffer size for each rx queue
    of an interface is configurable through dts bindings.
    But for an interface, the first rx queue's rx buffer
    size is always the usual MTU size (plus usual overhead)
    and page size for the remaining rx queues (if they are
    enabled by specifying a non-zero rx queue depth dts
    binding of the corresponding interface).  This patch
    removes the rx buffer size configuration capability.
    
    Signed-off-by: WingMan Kwok <w-kwok2@ti.com>
    Acked-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/netcp.h b/drivers/net/ethernet/ti/netcp.h
index a8a730641bbb..bb1bb72121c0 100644
--- a/drivers/net/ethernet/ti/netcp.h
+++ b/drivers/net/ethernet/ti/netcp.h
@@ -85,7 +85,6 @@ struct netcp_intf {
 	struct list_head	rxhook_list_head;
 	unsigned int		rx_queue_id;
 	void			*rx_fdq[KNAV_DMA_FDQ_PER_CHAN];
-	u32			rx_buffer_sizes[KNAV_DMA_FDQ_PER_CHAN];
 	struct napi_struct	rx_napi;
 	struct napi_struct	tx_napi;
 

commit 7025e88a79d64aa4ba58fd03d630a78b12cce6ae
Author: WingMan Kwok <w-kwok2@ti.com>
Date:   Fri Jul 24 15:02:29 2015 -0400

    net: netcp: Fixes SGMII reset on network interface shutdown
    
    This patch asserts SGMII RTRESET, i.e. resetting the SGMII Tx/Rx
    logic,  during network interface shutdown to avoid having the
    hardware wedge when shutting down with high incoming traffic rates.
    This is cleared (brought out of RTRESET) when the interface is
    brought back up.
    
    Signed-off-by: WingMan Kwok <w-kwok2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/netcp.h b/drivers/net/ethernet/ti/netcp.h
index bbacf5cccec2..a8a730641bbb 100644
--- a/drivers/net/ethernet/ti/netcp.h
+++ b/drivers/net/ethernet/ti/netcp.h
@@ -223,6 +223,7 @@ void *netcp_device_find_module(struct netcp_device *netcp_device,
 
 /* SGMII functions */
 int netcp_sgmii_reset(void __iomem *sgmii_ofs, int port);
+bool netcp_sgmii_rtreset(void __iomem *sgmii_ofs, int port, bool set);
 int netcp_sgmii_get_port_link(void __iomem *sgmii_ofs, int port);
 int netcp_sgmii_config(void __iomem *sgmii_ofs, int port, u32 interface);
 

commit e170f409924235478317bd6f2062d3a0c874ff9a
Author: Karicheri, Muralidharan <m-karicheri2@ti.com>
Date:   Fri Mar 20 16:11:21 2015 -0400

    net: netcp: fix forward port number usage for 10G ethss
    
    10G switch requires forward port number in the taginfo field,
    where as it should be in packet_info field for necp 1.4 Ethss. So
    fill this value correctly in the knav dma descriptor.
    
    Also rename dma_psflags field in struct netcp_tx_pipe to switch_to_port
    as it contain no flag, but the switch port number for forwarding the
    packet. Add a flag to hold the new flag,  SWITCH_TO_PORT_IN_TAGINFO which
    will be set for 10G. This can also used in the future for other flags for
    the tx_pipe.
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: WingMan Kwok <w-kwok2@ti.com>
    CC: "David S. Miller" <davem@davemloft.net>
    CC: Mugunthan V N <mugunthanvnm@ti.com>
    CC: "Lad, Prabhakar" <prabhakar.csengg@gmail.com>
    CC: Grygorii Strashko <grygorii.strashko@ti.com>
    CC: Christoph Jaeger <cj@linux.com>
    CC: Lokesh Vutla <lokeshvutla@ti.com>
    CC: Markus Pargmann <mpa@pengutronix.de>
    CC: Kumar Gala <galak@codeaurora.org>
    CC: Ian Campbell <ijc+devicetree@hellion.org.uk>
    CC: Mark Rutland <mark.rutland@arm.com>
    CC: Pawel Moll <pawel.moll@arm.com>
    CC: Rob Herring <robh+dt@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/netcp.h b/drivers/net/ethernet/ti/netcp.h
index 906e9bc412f5..bbacf5cccec2 100644
--- a/drivers/net/ethernet/ti/netcp.h
+++ b/drivers/net/ethernet/ti/netcp.h
@@ -41,7 +41,10 @@ struct netcp_tx_pipe {
 	struct netcp_device	*netcp_device;
 	void			*dma_queue;
 	unsigned int		dma_queue_id;
-	u8			dma_psflags;
+	/* To port for packet forwarded to switch. Used only by ethss */
+	u8			switch_to_port;
+#define	SWITCH_TO_PORT_IN_TAGINFO	BIT(0)
+	u8			flags;
 	void			*dma_channel;
 	const char		*dma_chan_name;
 };

commit 84640e27f23041d474c31d3362c3e2185ad68ec2
Author: Karicheri, Muralidharan <m-karicheri2@ti.com>
Date:   Thu Jan 15 19:12:50 2015 -0500

    net: netcp: Add Keystone NetCP core ethernet driver
    
    The network coprocessor (NetCP) is a hardware accelerator available in
    Keystone SoCs that processes Ethernet packets. NetCP consists of following
    hardware components
    
     1 Gigabit Ethernet (GbE) subsystem with a Ethernet switch sub-module to
       send and receive packets.
     2 Packet Accelerator (PA) module to perform packet classification
       operations such as header matching, and packet modification operations
       such as checksum generation.
     3 Security Accelerator(SA) capable of performing IPSec operations on
       ingress/egress packets.
     4 An optional 10 Gigabit Ethernet Subsystem (XGbE) which includes a
       3-port Ethernet switch sub-module capable of 10Gb/s and 1Gb/s rates
       per Ethernet port.
     5 Packet DMA and Queue Management Subsystem (QMSS) to enqueue and dequeue
       packets and DMA the packets between memory and NetCP hardware components
       described above.
    
    NetCP core driver make use of the Keystone Navigator driver API to allocate
    DMA channel for the Ethenet device and to handle packet queue/de-queue,
    Please refer API's in include/linux/soc/ti/knav_dma.h and
    drivers/soc/ti/knav_qmss.h for details.
    
    NetCP driver consists of NetCP core driver and at a minimum Gigabit
    Ethernet (GBE) module (1) driver to implement the Network device function.
    Other modules (2,3) can be optionally added to achieve supported hardware
    acceleration function. The initial version of the driver include NetCP
    core driver and GBE driver modules.
    
    Please refer Documentation/devicetree/bindings/net/keystone-netcp.txt
    for design of the driver.
    
     Cc: David Miller <davem@davemloft.net>
     Cc: Rob Herring <robh+dt@kernel.org>
     Cc: Grant Likely <grant.likely@linaro.org>
     Cc: Santosh Shilimkar <santosh.shilimkar@kernel.org>
     Cc: Pawel Moll <pawel.moll@arm.com>
     Cc: Mark Rutland <mark.rutland@arm.com>
     Cc: Ian Campbell <ijc+devicetree@hellion.org.uk>
     Cc: Kumar Gala <galak@codeaurora.org>
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: Wingman Kwok <w-kwok2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/netcp.h b/drivers/net/ethernet/ti/netcp.h
new file mode 100644
index 000000000000..906e9bc412f5
--- /dev/null
+++ b/drivers/net/ethernet/ti/netcp.h
@@ -0,0 +1,229 @@
+/*
+ * NetCP driver local header
+ *
+ * Copyright (C) 2014 Texas Instruments Incorporated
+ * Authors:	Sandeep Nair <sandeep_n@ti.com>
+ *		Sandeep Paulraj <s-paulraj@ti.com>
+ *		Cyril Chemparathy <cyril@ti.com>
+ *		Santosh Shilimkar <santosh.shilimkar@ti.com>
+ *		Wingman Kwok <w-kwok2@ti.com>
+ *		Murali Karicheri <m-karicheri2@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __NETCP_H__
+#define __NETCP_H__
+
+#include <linux/netdevice.h>
+#include <linux/soc/ti/knav_dma.h>
+
+/* Maximum Ethernet frame size supported by Keystone switch */
+#define NETCP_MAX_FRAME_SIZE		9504
+
+#define SGMII_LINK_MAC_MAC_AUTONEG	0
+#define SGMII_LINK_MAC_PHY		1
+#define SGMII_LINK_MAC_MAC_FORCED	2
+#define SGMII_LINK_MAC_FIBER		3
+#define SGMII_LINK_MAC_PHY_NO_MDIO	4
+#define XGMII_LINK_MAC_PHY		10
+#define XGMII_LINK_MAC_MAC_FORCED	11
+
+struct netcp_device;
+
+struct netcp_tx_pipe {
+	struct netcp_device	*netcp_device;
+	void			*dma_queue;
+	unsigned int		dma_queue_id;
+	u8			dma_psflags;
+	void			*dma_channel;
+	const char		*dma_chan_name;
+};
+
+#define ADDR_NEW			BIT(0)
+#define ADDR_VALID			BIT(1)
+
+enum netcp_addr_type {
+	ADDR_ANY,
+	ADDR_DEV,
+	ADDR_UCAST,
+	ADDR_MCAST,
+	ADDR_BCAST
+};
+
+struct netcp_addr {
+	struct netcp_intf	*netcp;
+	unsigned char		addr[ETH_ALEN];
+	enum netcp_addr_type	type;
+	unsigned int		flags;
+	struct list_head	node;
+};
+
+struct netcp_intf {
+	struct device		*dev;
+	struct device		*ndev_dev;
+	struct net_device	*ndev;
+	bool			big_endian;
+	unsigned int		tx_compl_qid;
+	void			*tx_pool;
+	struct list_head	txhook_list_head;
+	unsigned int		tx_pause_threshold;
+	void			*tx_compl_q;
+
+	unsigned int		tx_resume_threshold;
+	void			*rx_queue;
+	void			*rx_pool;
+	struct list_head	rxhook_list_head;
+	unsigned int		rx_queue_id;
+	void			*rx_fdq[KNAV_DMA_FDQ_PER_CHAN];
+	u32			rx_buffer_sizes[KNAV_DMA_FDQ_PER_CHAN];
+	struct napi_struct	rx_napi;
+	struct napi_struct	tx_napi;
+
+	void			*rx_channel;
+	const char		*dma_chan_name;
+	u32			rx_pool_size;
+	u32			rx_pool_region_id;
+	u32			tx_pool_size;
+	u32			tx_pool_region_id;
+	struct list_head	module_head;
+	struct list_head	interface_list;
+	struct list_head	addr_list;
+	bool			netdev_registered;
+	bool			primary_module_attached;
+
+	/* Lock used for protecting Rx/Tx hook list management */
+	spinlock_t		lock;
+	struct netcp_device	*netcp_device;
+	struct device_node	*node_interface;
+
+	/* DMA configuration data */
+	u32			msg_enable;
+	u32			rx_queue_depths[KNAV_DMA_FDQ_PER_CHAN];
+};
+
+#define	NETCP_PSDATA_LEN		KNAV_DMA_NUM_PS_WORDS
+struct netcp_packet {
+	struct sk_buff		*skb;
+	u32			*epib;
+	u32			*psdata;
+	unsigned int		psdata_len;
+	struct netcp_intf	*netcp;
+	struct netcp_tx_pipe	*tx_pipe;
+	bool			rxtstamp_complete;
+	void			*ts_context;
+
+	int	(*txtstamp_complete)(void *ctx, struct netcp_packet *pkt);
+};
+
+static inline u32 *netcp_push_psdata(struct netcp_packet *p_info,
+				     unsigned int bytes)
+{
+	u32 *buf;
+	unsigned int words;
+
+	if ((bytes & 0x03) != 0)
+		return NULL;
+	words = bytes >> 2;
+
+	if ((p_info->psdata_len + words) > NETCP_PSDATA_LEN)
+		return NULL;
+
+	p_info->psdata_len += words;
+	buf = &p_info->psdata[NETCP_PSDATA_LEN - p_info->psdata_len];
+	return buf;
+}
+
+static inline int netcp_align_psdata(struct netcp_packet *p_info,
+				     unsigned int byte_align)
+{
+	int padding;
+
+	switch (byte_align) {
+	case 0:
+		padding = -EINVAL;
+		break;
+	case 1:
+	case 2:
+	case 4:
+		padding = 0;
+		break;
+	case 8:
+		padding = (p_info->psdata_len << 2) % 8;
+		break;
+	case 16:
+		padding = (p_info->psdata_len << 2) % 16;
+		break;
+	default:
+		padding = (p_info->psdata_len << 2) % byte_align;
+		break;
+	}
+	return padding;
+}
+
+struct netcp_module {
+	const char		*name;
+	struct module		*owner;
+	bool			primary;
+
+	/* probe/remove: called once per NETCP instance */
+	int	(*probe)(struct netcp_device *netcp_device,
+			 struct device *device, struct device_node *node,
+			 void **inst_priv);
+	int	(*remove)(struct netcp_device *netcp_device, void *inst_priv);
+
+	/* attach/release: called once per network interface */
+	int	(*attach)(void *inst_priv, struct net_device *ndev,
+			  struct device_node *node, void **intf_priv);
+	int	(*release)(void *intf_priv);
+	int	(*open)(void *intf_priv, struct net_device *ndev);
+	int	(*close)(void *intf_priv, struct net_device *ndev);
+	int	(*add_addr)(void *intf_priv, struct netcp_addr *naddr);
+	int	(*del_addr)(void *intf_priv, struct netcp_addr *naddr);
+	int	(*add_vid)(void *intf_priv, int vid);
+	int	(*del_vid)(void *intf_priv, int vid);
+	int	(*ioctl)(void *intf_priv, struct ifreq *req, int cmd);
+
+	/* used internally */
+	struct list_head	module_list;
+	struct list_head	interface_list;
+};
+
+int netcp_register_module(struct netcp_module *module);
+void netcp_unregister_module(struct netcp_module *module);
+void *netcp_module_get_intf_data(struct netcp_module *module,
+				 struct netcp_intf *intf);
+
+int netcp_txpipe_init(struct netcp_tx_pipe *tx_pipe,
+		      struct netcp_device *netcp_device,
+		      const char *dma_chan_name, unsigned int dma_queue_id);
+int netcp_txpipe_open(struct netcp_tx_pipe *tx_pipe);
+int netcp_txpipe_close(struct netcp_tx_pipe *tx_pipe);
+
+typedef int netcp_hook_rtn(int order, void *data, struct netcp_packet *packet);
+int netcp_register_txhook(struct netcp_intf *netcp_priv, int order,
+			  netcp_hook_rtn *hook_rtn, void *hook_data);
+int netcp_unregister_txhook(struct netcp_intf *netcp_priv, int order,
+			    netcp_hook_rtn *hook_rtn, void *hook_data);
+int netcp_register_rxhook(struct netcp_intf *netcp_priv, int order,
+			  netcp_hook_rtn *hook_rtn, void *hook_data);
+int netcp_unregister_rxhook(struct netcp_intf *netcp_priv, int order,
+			    netcp_hook_rtn *hook_rtn, void *hook_data);
+void *netcp_device_find_module(struct netcp_device *netcp_device,
+			       const char *name);
+
+/* SGMII functions */
+int netcp_sgmii_reset(void __iomem *sgmii_ofs, int port);
+int netcp_sgmii_get_port_link(void __iomem *sgmii_ofs, int port);
+int netcp_sgmii_config(void __iomem *sgmii_ofs, int port, u32 interface);
+
+/* XGBE SERDES init functions */
+int netcp_xgbe_serdes_init(void __iomem *serdes_regs, void __iomem *xgbe_regs);
+
+#endif	/* __NETCP_H__ */
