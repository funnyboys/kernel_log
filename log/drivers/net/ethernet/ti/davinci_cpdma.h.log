commit 962fb618909ef64e0c89af5b79ba0fed910b78e3
Author: Ivan Khoronzhuk <ivan.khoronzhuk@linaro.org>
Date:   Tue Jul 9 00:34:30 2019 +0300

    net: ethernet: ti: davinci_cpdma: allow desc split while down
    
    That's possible to set ring params while interfaces are down. When
    interface gets up it uses number of descs to fill rx queue and on
    later on changes to create rx pools. Usually, this resplit can happen
    after phy is up, but it can be needed before this, so allow it to
    happen while setting number of rx descs, when interfaces are down.
    Also, if no dependency on intf state, move it to cpdma layer, where
    it should be.
    
    Signed-off-by: Ivan Khoronzhuk <ivan.khoronzhuk@linaro.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/davinci_cpdma.h b/drivers/net/ethernet/ti/davinci_cpdma.h
index 0271a20c2e09..d3cfe234d16a 100644
--- a/drivers/net/ethernet/ti/davinci_cpdma.h
+++ b/drivers/net/ethernet/ti/davinci_cpdma.h
@@ -116,8 +116,7 @@ enum cpdma_control {
 int cpdma_control_get(struct cpdma_ctlr *ctlr, int control);
 int cpdma_control_set(struct cpdma_ctlr *ctlr, int control, int value);
 int cpdma_get_num_rx_descs(struct cpdma_ctlr *ctlr);
-void cpdma_set_num_rx_descs(struct cpdma_ctlr *ctlr, int num_rx_desc);
+int cpdma_set_num_rx_descs(struct cpdma_ctlr *ctlr, int num_rx_desc);
 int cpdma_get_num_tx_descs(struct cpdma_ctlr *ctlr);
-int cpdma_chan_split_pool(struct cpdma_ctlr *ctlr);
 
 #endif

commit 6670acacd59eb72acfe5d69c966b5d2724cc521b
Author: Ivan Khoronzhuk <ivan.khoronzhuk@linaro.org>
Date:   Tue Jul 9 00:34:29 2019 +0300

    net: ethernet: ti: davinci_cpdma: add dma mapped submit
    
    In case if dma mapped packet needs to be sent, like with XDP
    page pool, the "mapped" submit can be used. This patch adds dma
    mapped submit based on regular one.
    
    Signed-off-by: Ivan Khoronzhuk <ivan.khoronzhuk@linaro.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/davinci_cpdma.h b/drivers/net/ethernet/ti/davinci_cpdma.h
index 9343c8c73c1b..0271a20c2e09 100644
--- a/drivers/net/ethernet/ti/davinci_cpdma.h
+++ b/drivers/net/ethernet/ti/davinci_cpdma.h
@@ -77,8 +77,12 @@ int cpdma_chan_stop(struct cpdma_chan *chan);
 
 int cpdma_chan_get_stats(struct cpdma_chan *chan,
 			 struct cpdma_chan_stats *stats);
+int cpdma_chan_submit_mapped(struct cpdma_chan *chan, void *token,
+			     dma_addr_t data, int len, int directed);
 int cpdma_chan_submit(struct cpdma_chan *chan, void *token, void *data,
 		      int len, int directed);
+int cpdma_chan_idle_submit_mapped(struct cpdma_chan *chan, void *token,
+				  dma_addr_t data, int len, int directed);
 int cpdma_chan_idle_submit(struct cpdma_chan *chan, void *token, void *data,
 			   int len, int directed);
 int cpdma_chan_process(struct cpdma_chan *chan, int quota);

commit 871e846585919adf727f21398f433fd424b6f0e1
Author: Ivan Khoronzhuk <ivan.khoronzhuk@linaro.org>
Date:   Sat Jun 15 14:01:32 2019 +0300

    net: ethernet: ti: davinci_cpdma: use idled submit
    
    While data pass suspend, reuse of rx descriptors can be disabled using
    channel state & lock from cpdma layer. For this, submit to a channel
    has to be disabled using state != "not active" under lock, what is done
    with this patch. The same submit is used to fill rx channel while
    ndo_open, when channel is idled, so add idled submit routine that
    allows to prepare descs for the channel. All this simplifies code and
    helps to avoid dormant mode usage and send packets only to active
    channels, avoiding potential race in later on changes. Also add missed
    sync barrier analogically like in other places after stopping tx
    queues.
    
    Signed-off-by: Ivan Khoronzhuk <ivan.khoronzhuk@linaro.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/davinci_cpdma.h b/drivers/net/ethernet/ti/davinci_cpdma.h
index 10376062dafa..9343c8c73c1b 100644
--- a/drivers/net/ethernet/ti/davinci_cpdma.h
+++ b/drivers/net/ethernet/ti/davinci_cpdma.h
@@ -79,6 +79,8 @@ int cpdma_chan_get_stats(struct cpdma_chan *chan,
 			 struct cpdma_chan_stats *stats);
 int cpdma_chan_submit(struct cpdma_chan *chan, void *token, void *data,
 		      int len, int directed);
+int cpdma_chan_idle_submit(struct cpdma_chan *chan, void *token, void *data,
+			   int len, int directed);
 int cpdma_chan_process(struct cpdma_chan *chan, int quota);
 
 int cpdma_ctlr_int_ctrl(struct cpdma_ctlr *ctlr, bool enable);

commit 5dea39851476216f6535a9fb0320611bdb576d49
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Fri Apr 26 20:12:38 2019 +0300

    net: ethernet: ti: davinci_cpdma: use dma_addr_t for desc_mem_phys and desc_hw_addr
    
    Use dma_addr_t for desc_mem_phys and desc_hw_addr to avoid types
    conversions.
    
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/davinci_cpdma.h b/drivers/net/ethernet/ti/davinci_cpdma.h
index 7d38210f3267..10376062dafa 100644
--- a/drivers/net/ethernet/ti/davinci_cpdma.h
+++ b/drivers/net/ethernet/ti/davinci_cpdma.h
@@ -27,8 +27,8 @@ struct cpdma_params {
 	int			num_chan;
 	bool			has_soft_reset;
 	int			min_packet_size;
-	u32			desc_mem_phys;
-	u32			desc_hw_addr;
+	dma_addr_t		desc_mem_phys;
+	dma_addr_t		desc_hw_addr;
 	int			desc_mem_size;
 	int			desc_align;
 	u32			bus_freq_mhz;

commit 68cf027f3d9d586366391beed8721ba319fee5c0
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Fri Apr 26 20:12:23 2019 +0300

    net: ethernet: ti: convert to SPDX license identifiers
    
    Replace textual license with SPDX-License-Identifier.
    
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/davinci_cpdma.h b/drivers/net/ethernet/ti/davinci_cpdma.h
index d399af5389b8..7d38210f3267 100644
--- a/drivers/net/ethernet/ti/davinci_cpdma.h
+++ b/drivers/net/ethernet/ti/davinci_cpdma.h
@@ -1,16 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Texas Instruments CPDMA Driver
  *
  * Copyright (C) 2010 Texas Instruments
  *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation version 2.
- *
- * This program is distributed "as is" WITHOUT ANY WARRANTY of any
- * kind, whether express or implied; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 #ifndef __DAVINCI_CPDMA_H__
 #define __DAVINCI_CPDMA_H__

commit a3a41d2f9487469364aeafae0f63d39c2e7179fd
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Thu Mar 15 15:15:50 2018 -0500

    net: ethernet: ti: cpsw: enable vlan rx vlan offload
    
    In VLAN_AWARE mode CPSW can insert VLAN header encapsulation word on Host
    port 0 egress (RX) before the packet data if RX_VLAN_ENCAP bit is set in
    CPSW_CONTROL register. VLAN header encapsulation word has following format:
    
     HDR_PKT_Priority bits 29-31 - Header Packet VLAN prio (Highest prio: 7)
     HDR_PKT_CFI      bits 28 - Header Packet VLAN CFI bit.
     HDR_PKT_Vid      bits 27-16 - Header Packet VLAN ID
     PKT_Type         bits 8-9 - Packet Type. Indicates whether the packet is
                            VLAN-tagged, priority-tagged, or non-tagged.
            00: VLAN-tagged packet
            01: Reserved
            10: Priority-tagged packet
            11: Non-tagged packet
    
    This feature can be used to implement TX VLAN offload in case of
    VLAN-tagged packets and to insert VLAN tag in case Non-tagged packet was
    received on port with PVID set. As per documentation, CPSW never modifies
    packet data on Host egress (RX) and as result, without this feature
    enabled, Host port will not be able to receive properly packets which
    entered switch non-tagged through external Port with PVID set (when
    non-tagged packet forwarded from external Port with PVID set to another
    external Port - packet will be VLAN tagged properly).
    
    Implementation details:
    - on RX driver will check CPDMA status bit RX_VLAN_ENCAP BIT(19) in CPPI
    descriptor to identify when VLAN header encapsulation word is present.
    - PKT_Type = 0x01 or 0x02 then ignore VLAN header encapsulation word and
    pass packet as is;
    - if HDR_PKT_Vid = 0 then ignore VLAN header encapsulation word and pass
    packet as is;
    - In dual mac mode traffic is separated between ports using default port
    vlans, which are not be visible to Host and so should not be reported.
    Hence, check for default port vlans in dual mac mode and ignore VLAN header
    encapsulation word;
    - otherwise fill SKB with VLAN info using __vlan_hwaccel_put_tag();
    - PKT_Type = 0x00 (VLAN-tagged) then strip out VLAN header from SKB.
    
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/davinci_cpdma.h b/drivers/net/ethernet/ti/davinci_cpdma.h
index fd65ce2b83de..d399af5389b8 100644
--- a/drivers/net/ethernet/ti/davinci_cpdma.h
+++ b/drivers/net/ethernet/ti/davinci_cpdma.h
@@ -19,6 +19,8 @@
 
 #define CPDMA_RX_SOURCE_PORT(__status__)	((__status__ >> 16) & 0x7)
 
+#define CPDMA_RX_VLAN_ENCAP BIT(19)
+
 #define CPDMA_EOI_RX_THRESH	0x0
 #define CPDMA_EOI_RX		0x1
 #define CPDMA_EOI_TX		0x2

commit be034fc14015c7fcabe62317d156e98b508a759b
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Fri Jan 6 14:07:34 2017 -0600

    net: ethernet: ti: cpsw: add support for ringparam configuration
    
    The CPDMA uses one pool of descriptors for both RX and TX which by default
    split between all channels proportionally depending on total number of
    CPDMA channels and number of TX and RX channels. As result, more
    descriptors will be consumed by TX path if there are more TX channels and
    there is no way now to dedicate more descriptors for RX path.
    
    So, add the ability to re-split CPDMA pool of descriptors between RX and TX
    path via ethtool '-G' command wich will allow to configure and fix number
    of descriptors used by RX and TX path, which, then, will be split between
    RX/TX channels proportionally depending on RX/TX channels number and
    weight. ethtool '-G' command will accept only number of RX entries and rest
    of descriptors will be arranged for TX automatically.
    
    Command:
      ethtool -G <devname> rx <number of descriptors>
    
    defaults and limitations:
    - minimum number of rx descriptors is 10% of total number of descriptors in
      CPDMA pool
    - maximum number of rx descriptors is 90% of total number of descriptors in
      CPDMA pool
    - by default, descriptors will be split equally between RX/TX path
    - any values passed in "tx" parameter will be ignored
    
    Usage:
    
     # ethtool -g eth0
            Pre-set maximums:
            RX:             7372
            RX Mini:        0
            RX Jumbo:       0
            TX:             0
            Current hardware settings:
            RX:             4096
            RX Mini:        0
            RX Jumbo:       0
            TX:             4096
    
     # ethtool -G eth0 rx 7372
     # ethtool -g eth0
            Ring parameters for eth0:
            Pre-set maximums:
            RX:             7372
            RX Mini:        0
            RX Jumbo:       0
            TX:             0
            Current hardware settings:
            RX:             7372
            RX Mini:        0
            RX Jumbo:       0
            TX:             820
    
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/davinci_cpdma.h b/drivers/net/ethernet/ti/davinci_cpdma.h
index cb45f8f543d9..fd65ce2b83de 100644
--- a/drivers/net/ethernet/ti/davinci_cpdma.h
+++ b/drivers/net/ethernet/ti/davinci_cpdma.h
@@ -114,5 +114,9 @@ enum cpdma_control {
 
 int cpdma_control_get(struct cpdma_ctlr *ctlr, int control);
 int cpdma_control_set(struct cpdma_ctlr *ctlr, int control, int value);
+int cpdma_get_num_rx_descs(struct cpdma_ctlr *ctlr);
+void cpdma_set_num_rx_descs(struct cpdma_ctlr *ctlr, int num_rx_desc);
+int cpdma_get_num_tx_descs(struct cpdma_ctlr *ctlr);
+int cpdma_chan_split_pool(struct cpdma_ctlr *ctlr);
 
 #endif

commit 90225bf0ba35ab43d1e9825c22f3810826c8bfe8
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Fri Jan 6 14:07:33 2017 -0600

    net: ethernet: ti: cpsw: add support for descs pool size configuration
    
    The CPSW CPDMA can process buffer descriptors placed as in internal
    CPPI RAM as in DDR. This patch adds support in CPSW and CPDMA for
    descs_pool_size mudule parameter, which defines total number of CPDMA CPPI
    descriptors to be used for both ingress/egress packets processing:
     - memory size, required for CPDMA descriptor pool, is calculated basing
    on number of descriptors specified by user in descs_pool_size and
    CPDMA descriptor size and allocated from coherent memory (CMA area);
     - CPDMA descriptor pool will be allocated in DDR if pool memory size >
    internal CPPI RAM or use internal CPPI RAM otherwise;
     - if descs_pool_size not specified in DT - the default value 256 will
    be used which will allow to place CPDMA descriptors pool into the
    internal CPPI RAM (current default behaviour);
     - CPDMA will ignore descs_pool_size if descs_pool_size = 0 for
    backward comaptiobility with davinci_emac.
    
    descs_pool_size is boot time setting and can't be changed once
    CPSW/CPDMA is initialized.
    
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/davinci_cpdma.h b/drivers/net/ethernet/ti/davinci_cpdma.h
index 4a167db2abab..cb45f8f543d9 100644
--- a/drivers/net/ethernet/ti/davinci_cpdma.h
+++ b/drivers/net/ethernet/ti/davinci_cpdma.h
@@ -37,6 +37,7 @@ struct cpdma_params {
 	int			desc_mem_size;
 	int			desc_align;
 	u32			bus_freq_mhz;
+	u32			descs_pool_size;
 
 	/*
 	 * Some instances of embedded cpdma controllers have extra control and

commit 8f32b90981dcdb355516fb95953133f8d4e6b11d
Author: Ivan Khoronzhuk <ivan.khoronzhuk@linaro.org>
Date:   Tue Nov 29 17:00:48 2016 +0200

    net: ethernet: ti: davinci_cpdma: add set rate for a channel
    
    The cpdma has 8 rate limited tx channels. This patch adds
    ability for cpdma driver to use 8 tx h/w shapers. If at least one
    channel is not rate limited then it must have higher number, this
    is because the rate limited channels have to have higher priority
    then not rate limited channels. The channel priority is set in low-hi
    direction already, so that when a new channel is added with ethtool
    and it doesn't have rate yet, it cannot affect on rate limited
    channels. It can be useful for TSN streams and just in cases when
    h/w rate limited channels are needed.
    
    Signed-off-by: Ivan Khoronzhuk <ivan.khoronzhuk@linaro.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/davinci_cpdma.h b/drivers/net/ethernet/ti/davinci_cpdma.h
index 629020cbc205..4a167db2abab 100644
--- a/drivers/net/ethernet/ti/davinci_cpdma.h
+++ b/drivers/net/ethernet/ti/davinci_cpdma.h
@@ -36,6 +36,7 @@ struct cpdma_params {
 	u32			desc_hw_addr;
 	int			desc_mem_size;
 	int			desc_align;
+	u32			bus_freq_mhz;
 
 	/*
 	 * Some instances of embedded cpdma controllers have extra control and
@@ -91,8 +92,12 @@ u32 cpdma_ctrl_rxchs_state(struct cpdma_ctlr *ctlr);
 u32 cpdma_ctrl_txchs_state(struct cpdma_ctlr *ctlr);
 bool cpdma_check_free_tx_desc(struct cpdma_chan *chan);
 int cpdma_chan_set_weight(struct cpdma_chan *ch, int weight);
+int cpdma_chan_set_rate(struct cpdma_chan *ch, u32 rate);
+u32 cpdma_chan_get_rate(struct cpdma_chan *ch);
+u32 cpdma_chan_get_min_rate(struct cpdma_ctlr *ctlr);
 
 enum cpdma_control {
+	CPDMA_TX_RLIM,			/* read-write */
 	CPDMA_CMD_IDLE,			/* write-only */
 	CPDMA_COPY_ERROR_FRAMES,	/* read-write */
 	CPDMA_RX_OFF_LEN_UPDATE,	/* read-write */

commit 0fc6432cc78d8dc683474d8e28ea30543ae033b3
Author: Ivan Khoronzhuk <ivan.khoronzhuk@linaro.org>
Date:   Tue Nov 29 17:00:47 2016 +0200

    net: ethernet: ti: davinci_cpdma: add weight function for channels
    
    The weight of a channel is needed to split descriptors between
    channels. The weight can depend on maximum rate of channels, maximum
    rate of an interface or other reasons. The channel weight is in
    percentage and is independent for rx and tx channels.
    
    Signed-off-by: Ivan Khoronzhuk <ivan.khoronzhuk@linaro.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/davinci_cpdma.h b/drivers/net/ethernet/ti/davinci_cpdma.h
index a07b22b12bc1..629020cbc205 100644
--- a/drivers/net/ethernet/ti/davinci_cpdma.h
+++ b/drivers/net/ethernet/ti/davinci_cpdma.h
@@ -90,6 +90,7 @@ int cpdma_chan_int_ctrl(struct cpdma_chan *chan, bool enable);
 u32 cpdma_ctrl_rxchs_state(struct cpdma_ctlr *ctlr);
 u32 cpdma_ctrl_txchs_state(struct cpdma_ctlr *ctlr);
 bool cpdma_check_free_tx_desc(struct cpdma_chan *chan);
+int cpdma_chan_set_weight(struct cpdma_chan *ch, int weight);
 
 enum cpdma_control {
 	CPDMA_CMD_IDLE,			/* write-only */

commit 925d65e6d8a4c84c54fbad060f32385b57e210ed
Author: Ivan Khoronzhuk <ivan.khoronzhuk@linaro.org>
Date:   Mon Aug 22 21:18:27 2016 +0300

    net: ethernet: ti: davinci_cpdma: move cpdma channel struct macroses to internals
    
    Keep the driver internals in C file. Currently it's not required for
    drivers to know rx or tx a channel is, except create function.
    So correct "channel create" function, and use all channel struct
    macroses only for internal use.
    
    Reviewed-by: Mugunthan V N <mugunthanvnm@ti.com>
    Signed-off-by: Ivan Khoronzhuk <ivan.khoronzhuk@linaro.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/davinci_cpdma.h b/drivers/net/ethernet/ti/davinci_cpdma.h
index 070f1d0ea848..a07b22b12bc1 100644
--- a/drivers/net/ethernet/ti/davinci_cpdma.h
+++ b/drivers/net/ethernet/ti/davinci_cpdma.h
@@ -17,13 +17,6 @@
 
 #define CPDMA_MAX_CHANNELS	BITS_PER_LONG
 
-#define tx_chan_num(chan)	(chan)
-#define rx_chan_num(chan)	((chan) + CPDMA_MAX_CHANNELS)
-#define is_rx_chan(chan)	((chan)->chan_num >= CPDMA_MAX_CHANNELS)
-#define is_tx_chan(chan)	(!is_rx_chan(chan))
-#define __chan_linear(chan_num)	((chan_num) & (CPDMA_MAX_CHANNELS - 1))
-#define chan_linear(chan)	__chan_linear((chan)->chan_num)
-
 #define CPDMA_RX_SOURCE_PORT(__status__)	((__status__ >> 16) & 0x7)
 
 #define CPDMA_EOI_RX_THRESH	0x0
@@ -79,7 +72,7 @@ int cpdma_ctlr_start(struct cpdma_ctlr *ctlr);
 int cpdma_ctlr_stop(struct cpdma_ctlr *ctlr);
 
 struct cpdma_chan *cpdma_chan_create(struct cpdma_ctlr *ctlr, int chan_num,
-				     cpdma_handler_fn handler);
+				     cpdma_handler_fn handler, int rx_type);
 int cpdma_chan_get_rx_buf_num(struct cpdma_chan *chan);
 int cpdma_chan_destroy(struct cpdma_chan *chan);
 int cpdma_chan_start(struct cpdma_chan *chan);

commit e05107e6b74700762e2feda0abd2e74984c24227
Author: Ivan Khoronzhuk <ivan.khoronzhuk@linaro.org>
Date:   Mon Aug 22 21:18:26 2016 +0300

    net: ethernet: ti: cpsw: add multi queue support
    
    The cpsw h/w supports up to 8 tx and 8 rx channels. This patch adds
    multi-queue support to the driver only, shaper configuration will
    be added with separate patch series. Default shaper mode, as
    before, priority mode, but with corrected priority order, 0 - is
    highest priority, 7 - lowest.
    
    The poll function handles all unprocessed channels, till all of
    them are free, beginning from hi priority channel.
    
    In dual_emac mode the channels are shared between two network devices,
    as it's with single-queue default mode.
    
    The statistic for every channel can be read with:
    $ ethtool -S ethX
    
    Signed-off-by: Ivan Khoronzhuk <ivan.khoronzhuk@linaro.org>
    Reviewed-by: Mugunthan V N <mugunthanvnm@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/davinci_cpdma.h b/drivers/net/ethernet/ti/davinci_cpdma.h
index 9119b43f4f7d..070f1d0ea848 100644
--- a/drivers/net/ethernet/ti/davinci_cpdma.h
+++ b/drivers/net/ethernet/ti/davinci_cpdma.h
@@ -94,6 +94,8 @@ int cpdma_chan_process(struct cpdma_chan *chan, int quota);
 int cpdma_ctlr_int_ctrl(struct cpdma_ctlr *ctlr, bool enable);
 void cpdma_ctlr_eoi(struct cpdma_ctlr *ctlr, u32 value);
 int cpdma_chan_int_ctrl(struct cpdma_chan *chan, bool enable);
+u32 cpdma_ctrl_rxchs_state(struct cpdma_ctlr *ctlr);
+u32 cpdma_ctrl_txchs_state(struct cpdma_ctlr *ctlr);
 bool cpdma_check_free_tx_desc(struct cpdma_chan *chan);
 
 enum cpdma_control {

commit 3802dce178d244c02c6b11fdcbbd202ceac37f0a
Author: Ivan Khoronzhuk <ivan.khoronzhuk@linaro.org>
Date:   Mon Aug 22 21:18:24 2016 +0300

    net: ethernet: ti: davinci_cpdma: split descs num between all channels
    
    Tx channels share same pool of descriptors. Thus one channel can
    block another if pool is emptied by one. But, the shaper should
    decide which channel is allowed to send packets. To avoid such
    impact of one channel on another, let every channel to have its
    own piece of pool.
    
    Signed-off-by: Ivan Khoronzhuk <ivan.khoronzhuk@linaro.org>
    Reviewed-by: Mugunthan V N <mugunthanvnm@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/davinci_cpdma.h b/drivers/net/ethernet/ti/davinci_cpdma.h
index 4b46cd6e9a3f..9119b43f4f7d 100644
--- a/drivers/net/ethernet/ti/davinci_cpdma.h
+++ b/drivers/net/ethernet/ti/davinci_cpdma.h
@@ -80,7 +80,7 @@ int cpdma_ctlr_stop(struct cpdma_ctlr *ctlr);
 
 struct cpdma_chan *cpdma_chan_create(struct cpdma_ctlr *ctlr, int chan_num,
 				     cpdma_handler_fn handler);
-int cpdma_chan_get_rx_buf_num(struct cpdma_ctlr *ctlr);
+int cpdma_chan_get_rx_buf_num(struct cpdma_chan *chan);
 int cpdma_chan_destroy(struct cpdma_chan *chan);
 int cpdma_chan_start(struct cpdma_chan *chan);
 int cpdma_chan_stop(struct cpdma_chan *chan);

commit 3568bdf0419fcaeebc5bba7cb2e034436b3e4125
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Mon Jul 25 11:54:45 2016 +0200

    net: davinci_cpdma: remove excessive dump of register values to kernel log
    
    Such a big dump of register values is hardly useful on a production
    system.
    
    Another downside of the now removed functions is that calling
    emac_dump_regs resulted in at least 87 calls to dev_info while holding a
    spinlock and having irqs off which is a big source of latency.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/davinci_cpdma.h b/drivers/net/ethernet/ti/davinci_cpdma.h
index 80c015cbbce5..4b46cd6e9a3f 100644
--- a/drivers/net/ethernet/ti/davinci_cpdma.h
+++ b/drivers/net/ethernet/ti/davinci_cpdma.h
@@ -77,7 +77,6 @@ struct cpdma_ctlr *cpdma_ctlr_create(struct cpdma_params *params);
 int cpdma_ctlr_destroy(struct cpdma_ctlr *ctlr);
 int cpdma_ctlr_start(struct cpdma_ctlr *ctlr);
 int cpdma_ctlr_stop(struct cpdma_ctlr *ctlr);
-int cpdma_ctlr_dump(struct cpdma_ctlr *ctlr);
 
 struct cpdma_chan *cpdma_chan_create(struct cpdma_ctlr *ctlr, int chan_num,
 				     cpdma_handler_fn handler);
@@ -85,7 +84,6 @@ int cpdma_chan_get_rx_buf_num(struct cpdma_ctlr *ctlr);
 int cpdma_chan_destroy(struct cpdma_chan *chan);
 int cpdma_chan_start(struct cpdma_chan *chan);
 int cpdma_chan_stop(struct cpdma_chan *chan);
-int cpdma_chan_dump(struct cpdma_chan *chan);
 
 int cpdma_chan_get_stats(struct cpdma_chan *chan,
 			 struct cpdma_chan_stats *stats);

commit 1793331e0943f1ddd8649dd1ccea11f3f267d371
Author: Ivan Khoronzhuk <ivan.khoronzhuk@linaro.org>
Date:   Fri Jun 17 13:25:39 2016 +0300

    net: ethernet: ti: cpsw: remove rx_descs property
    
    There is no reason in rx_descs property because davinici_cpdma
    driver splits pool of descriptors equally between tx and rx channels.
    That is, if number of descriptors 256, 128 of them are for rx
    channels. While receiving, the descriptor is freed to the pool and
    then allocated with new skb. And if in DT the "rx_descs" is set to
    64, then 128 - 64 = 64 descriptors are always in the pool and cannot
    be used, for tx, for instance. It's not correct resource usage,
    better to set it to half of pool, then the rx pool can be used in
    full. It will not have any impact on performance, as anyway, the
    "redundant" descriptors were unused.
    
    Signed-off-by: Ivan Khoronzhuk <ivan.khoronzhuk@linaro.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/davinci_cpdma.h b/drivers/net/ethernet/ti/davinci_cpdma.h
index 86dee487f2f0..80c015cbbce5 100644
--- a/drivers/net/ethernet/ti/davinci_cpdma.h
+++ b/drivers/net/ethernet/ti/davinci_cpdma.h
@@ -81,6 +81,7 @@ int cpdma_ctlr_dump(struct cpdma_ctlr *ctlr);
 
 struct cpdma_chan *cpdma_chan_create(struct cpdma_ctlr *ctlr, int chan_num,
 				     cpdma_handler_fn handler);
+int cpdma_chan_get_rx_buf_num(struct cpdma_ctlr *ctlr);
 int cpdma_chan_destroy(struct cpdma_chan *chan);
 int cpdma_chan_start(struct cpdma_chan *chan);
 int cpdma_chan_stop(struct cpdma_chan *chan);

commit aef614e13dfbdd3b9ae44ad110159f75b9029bba
Author: Sebastian Siewior <bigeasy@linutronix.de>
Date:   Tue Apr 23 07:31:38 2013 +0000

    net/davinci_cpdma: remove unused argument in cpdma_chan_submit()
    
    The gfp_mask argument is not used in cpdma_chan_submit() and always set
    to GFP_KERNEL even in atomic sections. This patch drops it since it is
    unused.
    
    Acked-by: Mugunthan V N <mugunthanvnm@ti.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/davinci_cpdma.h b/drivers/net/ethernet/ti/davinci_cpdma.h
index d9bcc6032fdc..86dee487f2f0 100644
--- a/drivers/net/ethernet/ti/davinci_cpdma.h
+++ b/drivers/net/ethernet/ti/davinci_cpdma.h
@@ -89,7 +89,7 @@ int cpdma_chan_dump(struct cpdma_chan *chan);
 int cpdma_chan_get_stats(struct cpdma_chan *chan,
 			 struct cpdma_chan_stats *stats);
 int cpdma_chan_submit(struct cpdma_chan *chan, void *token, void *data,
-		      int len, int directed, gfp_t gfp_mask);
+		      int len, int directed);
 int cpdma_chan_process(struct cpdma_chan *chan, int quota);
 
 int cpdma_ctlr_int_ctrl(struct cpdma_ctlr *ctlr, bool enable);

commit 510a1e7249298f6bbd049e1ec98041ddf5ef6452
Author: Mugunthan V N <mugunthanvnm@ti.com>
Date:   Sun Feb 17 22:19:20 2013 +0000

    drivers: net: davinci_cpdma: acknowledge interrupt properly
    
    CPDMA interrupts are not properly acknowledged which leads to interrupt
    storm, only cpdma interrupt 0 is acknowledged in Davinci CPDMA driver.
    Changed cpdma_ctlr_eoi api to acknowledge 1 and 2 interrupts which are
    used for rx and tx respectively.
    
    Reported-by: Pantelis Antoniou <panto@antoniou-consulting.com>
    Signed-off-by: Mugunthan V N <mugunthanvnm@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/davinci_cpdma.h b/drivers/net/ethernet/ti/davinci_cpdma.h
index a97d6ab30941..d9bcc6032fdc 100644
--- a/drivers/net/ethernet/ti/davinci_cpdma.h
+++ b/drivers/net/ethernet/ti/davinci_cpdma.h
@@ -26,6 +26,11 @@
 
 #define CPDMA_RX_SOURCE_PORT(__status__)	((__status__ >> 16) & 0x7)
 
+#define CPDMA_EOI_RX_THRESH	0x0
+#define CPDMA_EOI_RX		0x1
+#define CPDMA_EOI_TX		0x2
+#define CPDMA_EOI_MISC		0x3
+
 struct cpdma_params {
 	struct device		*dev;
 	void __iomem		*dmaregs;
@@ -88,7 +93,7 @@ int cpdma_chan_submit(struct cpdma_chan *chan, void *token, void *data,
 int cpdma_chan_process(struct cpdma_chan *chan, int quota);
 
 int cpdma_ctlr_int_ctrl(struct cpdma_ctlr *ctlr, bool enable);
-void cpdma_ctlr_eoi(struct cpdma_ctlr *ctlr);
+void cpdma_ctlr_eoi(struct cpdma_ctlr *ctlr, u32 value);
 int cpdma_chan_int_ctrl(struct cpdma_chan *chan, bool enable);
 bool cpdma_check_free_tx_desc(struct cpdma_chan *chan);
 

commit f6e135c81eeb648c6addc6aeff2ee80f28ea413b
Author: Mugunthan V N <mugunthanvnm@ti.com>
Date:   Mon Feb 11 09:52:18 2013 +0000

    driver: net: ethernet: davinci_cpdma: add support for directed packet and source port detection
    
    * Introduced parameter to add port number for directed packet in cpdma_chan_submit
    * Source port detection macro with DMA descriptor status
    
    Signed-off-by: Mugunthan V N <mugunthanvnm@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/davinci_cpdma.h b/drivers/net/ethernet/ti/davinci_cpdma.h
index 8d2aeb2096ac..a97d6ab30941 100644
--- a/drivers/net/ethernet/ti/davinci_cpdma.h
+++ b/drivers/net/ethernet/ti/davinci_cpdma.h
@@ -24,6 +24,8 @@
 #define __chan_linear(chan_num)	((chan_num) & (CPDMA_MAX_CHANNELS - 1))
 #define chan_linear(chan)	__chan_linear((chan)->chan_num)
 
+#define CPDMA_RX_SOURCE_PORT(__status__)	((__status__ >> 16) & 0x7)
+
 struct cpdma_params {
 	struct device		*dev;
 	void __iomem		*dmaregs;
@@ -82,7 +84,7 @@ int cpdma_chan_dump(struct cpdma_chan *chan);
 int cpdma_chan_get_stats(struct cpdma_chan *chan,
 			 struct cpdma_chan_stats *stats);
 int cpdma_chan_submit(struct cpdma_chan *chan, void *token, void *data,
-		      int len, gfp_t gfp_mask);
+		      int len, int directed, gfp_t gfp_mask);
 int cpdma_chan_process(struct cpdma_chan *chan, int quota);
 
 int cpdma_ctlr_int_ctrl(struct cpdma_ctlr *ctlr, bool enable);

commit fae50823d0ee579e006a7ba2b20880e354388b25
Author: Mugunthan V N <mugunthanvnm@ti.com>
Date:   Thu Jan 17 06:31:34 2013 +0000

    net: ethernet: davinci_cpdma: Add boundary for rx and tx descriptors
    
    When there is heavy transmission traffic in the CPDMA, then Rx descriptors
    memory is also utilized as tx desc memory looses all rx descriptors and the
    driver stops working then.
    
    This patch adds boundary for tx and rx descriptors in bd ram dividing the
    descriptor memory to ensure that during heavy transmission tx doesn't use
    rx descriptors.
    
    This patch is already applied to davinci_emac driver, since CPSW and
    davici_dmac shares the same CPDMA, moving the boundry seperation from
    Davinci EMAC driver to CPDMA driver which was done in the following
    commit
    
    commit 86d8c07ff2448eb4e860e50f34ef6ee78e45c40c
    Author: Sascha Hauer <s.hauer@pengutronix.de>
    Date:   Tue Jan 3 05:27:47 2012 +0000
    
        net/davinci: do not use all descriptors for tx packets
    
        The driver uses a shared pool for both rx and tx descriptors.
        During open it queues fixed number of 128 descriptors for receive
        packets. For each received packet it tries to queue another
        descriptor. If this fails the descriptor is lost for rx.
        The driver has no limitation on tx descriptors to use, so it
        can happen during a nmap / ping -f attack that the driver
        allocates all descriptors for tx and looses all rx descriptors.
        The driver stops working then.
        To fix this limit the number of tx descriptors used to half of
        the descriptors available, the rx path uses the other half.
    
        Tested on a custom board using nmap / ping -f to the board from
        two different hosts.
    
    Signed-off-by: Mugunthan V N <mugunthanvnm@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/davinci_cpdma.h b/drivers/net/ethernet/ti/davinci_cpdma.h
index afa19a0c0d81..8d2aeb2096ac 100644
--- a/drivers/net/ethernet/ti/davinci_cpdma.h
+++ b/drivers/net/ethernet/ti/davinci_cpdma.h
@@ -88,6 +88,7 @@ int cpdma_chan_process(struct cpdma_chan *chan, int quota);
 int cpdma_ctlr_int_ctrl(struct cpdma_ctlr *ctlr, bool enable);
 void cpdma_ctlr_eoi(struct cpdma_ctlr *ctlr);
 int cpdma_chan_int_ctrl(struct cpdma_chan *chan, bool enable);
+bool cpdma_check_free_tx_desc(struct cpdma_chan *chan);
 
 enum cpdma_control {
 	CPDMA_CMD_IDLE,			/* write-only */

commit b544dbac41218fd015ac79455cfc1e57736e9b0c
Author: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Date:   Tue Jun 14 12:56:50 2011 -0700

    davinci*/tlan/cpmac: Move the Texas Instruments (TI) drivers
    
    Move the Texas Instruments drivers to drivers/net/ethernet/ti/ and
    make the necessary Kconfig and Makefile changes.
    
    CC: Sriram <srk@ti.com>
    CC: Vinay Hegde <vinay.hegde@ti.com>
    CC: Cyril Chemparathy <cyril@ti.com>
    CC: Samuel Chessman <chessman@tux.org>
    CC: <torben.mathiasen@compaq.com>
    CC: Eugene Konev <ejka@imfi.kspu.ru>
    CC: Florian Fainelli <florian@openwrt.org>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/ti/davinci_cpdma.h b/drivers/net/ethernet/ti/davinci_cpdma.h
new file mode 100644
index 000000000000..afa19a0c0d81
--- /dev/null
+++ b/drivers/net/ethernet/ti/davinci_cpdma.h
@@ -0,0 +1,109 @@
+/*
+ * Texas Instruments CPDMA Driver
+ *
+ * Copyright (C) 2010 Texas Instruments
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __DAVINCI_CPDMA_H__
+#define __DAVINCI_CPDMA_H__
+
+#define CPDMA_MAX_CHANNELS	BITS_PER_LONG
+
+#define tx_chan_num(chan)	(chan)
+#define rx_chan_num(chan)	((chan) + CPDMA_MAX_CHANNELS)
+#define is_rx_chan(chan)	((chan)->chan_num >= CPDMA_MAX_CHANNELS)
+#define is_tx_chan(chan)	(!is_rx_chan(chan))
+#define __chan_linear(chan_num)	((chan_num) & (CPDMA_MAX_CHANNELS - 1))
+#define chan_linear(chan)	__chan_linear((chan)->chan_num)
+
+struct cpdma_params {
+	struct device		*dev;
+	void __iomem		*dmaregs;
+	void __iomem		*txhdp, *rxhdp, *txcp, *rxcp;
+	void __iomem		*rxthresh, *rxfree;
+	int			num_chan;
+	bool			has_soft_reset;
+	int			min_packet_size;
+	u32			desc_mem_phys;
+	u32			desc_hw_addr;
+	int			desc_mem_size;
+	int			desc_align;
+
+	/*
+	 * Some instances of embedded cpdma controllers have extra control and
+	 * status registers.  The following flag enables access to these
+	 * "extended" registers.
+	 */
+	bool			has_ext_regs;
+};
+
+struct cpdma_chan_stats {
+	u32			head_enqueue;
+	u32			tail_enqueue;
+	u32			pad_enqueue;
+	u32			misqueued;
+	u32			desc_alloc_fail;
+	u32			pad_alloc_fail;
+	u32			runt_receive_buff;
+	u32			runt_transmit_buff;
+	u32			empty_dequeue;
+	u32			busy_dequeue;
+	u32			good_dequeue;
+	u32			requeue;
+	u32			teardown_dequeue;
+};
+
+struct cpdma_ctlr;
+struct cpdma_chan;
+
+typedef void (*cpdma_handler_fn)(void *token, int len, int status);
+
+struct cpdma_ctlr *cpdma_ctlr_create(struct cpdma_params *params);
+int cpdma_ctlr_destroy(struct cpdma_ctlr *ctlr);
+int cpdma_ctlr_start(struct cpdma_ctlr *ctlr);
+int cpdma_ctlr_stop(struct cpdma_ctlr *ctlr);
+int cpdma_ctlr_dump(struct cpdma_ctlr *ctlr);
+
+struct cpdma_chan *cpdma_chan_create(struct cpdma_ctlr *ctlr, int chan_num,
+				     cpdma_handler_fn handler);
+int cpdma_chan_destroy(struct cpdma_chan *chan);
+int cpdma_chan_start(struct cpdma_chan *chan);
+int cpdma_chan_stop(struct cpdma_chan *chan);
+int cpdma_chan_dump(struct cpdma_chan *chan);
+
+int cpdma_chan_get_stats(struct cpdma_chan *chan,
+			 struct cpdma_chan_stats *stats);
+int cpdma_chan_submit(struct cpdma_chan *chan, void *token, void *data,
+		      int len, gfp_t gfp_mask);
+int cpdma_chan_process(struct cpdma_chan *chan, int quota);
+
+int cpdma_ctlr_int_ctrl(struct cpdma_ctlr *ctlr, bool enable);
+void cpdma_ctlr_eoi(struct cpdma_ctlr *ctlr);
+int cpdma_chan_int_ctrl(struct cpdma_chan *chan, bool enable);
+
+enum cpdma_control {
+	CPDMA_CMD_IDLE,			/* write-only */
+	CPDMA_COPY_ERROR_FRAMES,	/* read-write */
+	CPDMA_RX_OFF_LEN_UPDATE,	/* read-write */
+	CPDMA_RX_OWNERSHIP_FLIP,	/* read-write */
+	CPDMA_TX_PRIO_FIXED,		/* read-write */
+	CPDMA_STAT_IDLE,		/* read-only */
+	CPDMA_STAT_TX_ERR_CHAN,		/* read-only */
+	CPDMA_STAT_TX_ERR_CODE,		/* read-only */
+	CPDMA_STAT_RX_ERR_CHAN,		/* read-only */
+	CPDMA_STAT_RX_ERR_CODE,		/* read-only */
+	CPDMA_RX_BUFFER_OFFSET,		/* read-write */
+};
+
+int cpdma_control_get(struct cpdma_ctlr *ctlr, int control);
+int cpdma_control_set(struct cpdma_ctlr *ctlr, int control, int value);
+
+#endif
