commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/ethernet/sun/sunqe.h b/drivers/net/ethernet/sun/sunqe.h
index ae190b77431b..0daed05b7c83 100644
--- a/drivers/net/ethernet/sun/sunqe.h
+++ b/drivers/net/ethernet/sun/sunqe.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /* $Id: sunqe.h,v 1.13 2000/02/09 11:15:42 davem Exp $
  * sunqe.h: Definitions for the Sun QuadEthernet driver.
  *

commit 266439c94df9e6aee3390c6e1cfdb645e566f704
Author: Tushar Dave <tushar.n.dave@oracle.com>
Date:   Mon Oct 17 13:56:59 2016 -0700

    sunqe: Fix compiler warnings
    
    sunqe uses '__u32' for dma handle while invoking kernel DMA APIs,
    instead of using dma_addr_t. This hasn't caused any 'incompatible
    pointer type' warning on SPARC because until now dma_addr_t is of
    type u32. However, recent changes in SPARC ATU (iommu) enables 64bit
    DMA and therefore dma_addr_t becomes of type u64. This makes
    'incompatible pointer type' warnings inevitable.
    
    e.g.
    drivers/net/ethernet/sun/sunqe.c: In function ‘qec_ether_init’:
    drivers/net/ethernet/sun/sunqe.c:883: warning: passing argument 3 of ‘dma_alloc_coherent’ from incompatible pointer type
    ./include/linux/dma-mapping.h:445: note: expected ‘dma_addr_t *’ but argument is of type ‘__u32 *’
    drivers/net/ethernet/sun/sunqe.c:885: warning: passing argument 3 of ‘dma_alloc_coherent’ from incompatible pointer type
    ./include/linux/dma-mapping.h:445: note: expected ‘dma_addr_t *’ but argument is of type ‘__u32 *’
    
    This patch resolves above compiler warnings.
    
    Signed-off-by: Tushar Dave <tushar.n.dave@oracle.com>
    Reviewed-by: chris hyser <chris.hyser@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/sun/sunqe.h b/drivers/net/ethernet/sun/sunqe.h
index 581781b6b2fa..ae190b77431b 100644
--- a/drivers/net/ethernet/sun/sunqe.h
+++ b/drivers/net/ethernet/sun/sunqe.h
@@ -334,12 +334,12 @@ struct sunqe {
 	void __iomem			*qcregs;		/* QEC per-channel Registers   */
 	void __iomem			*mregs;		/* Per-channel MACE Registers  */
 	struct qe_init_block      	*qe_block;	/* RX and TX descriptors       */
-	__u32                      	qblock_dvma;	/* RX and TX descriptors       */
+	dma_addr_t			qblock_dvma;	/* RX and TX descriptors       */
 	spinlock_t			lock;		/* Protects txfull state       */
 	int                        	rx_new, rx_old;	/* RX ring extents	       */
 	int			   	tx_new, tx_old;	/* TX ring extents	       */
 	struct sunqe_buffers		*buffers;	/* CPU visible address.        */
-	__u32				buffers_dvma;	/* DVMA visible address.       */
+	dma_addr_t			buffers_dvma;	/* DVMA visible address.       */
 	struct sunqec			*parent;
 	u8				mconfig;	/* Base MACE mconfig value     */
 	struct platform_device		*op;		/* QE's OF device struct       */

commit e689cf4a042772f727450035b102579b0c01bdc7
Author: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Date:   Thu May 12 23:04:46 2011 -0700

    cassini/niu/sun*: Move the Sun drivers
    
    Moves the Sun drivers into drivers/net/ethernet/sun/ and make
    the necessary Kconfig and Makefile changes.
    
    Oliver Hartkopp <socketcan@hartkopp.net> suggested removing the
    sun* prefix on the driver names.  This type of change I will
    leave up to the driver maintainers.
    
    CC: Sam Creasey <sammy@sammy.net>
    CC: Adrian Sun <asun@darksunrising.com>
    CC: Benjamin Herrenscmidt <benh@kernel.crashing.org>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/sun/sunqe.h b/drivers/net/ethernet/sun/sunqe.h
new file mode 100644
index 000000000000..581781b6b2fa
--- /dev/null
+++ b/drivers/net/ethernet/sun/sunqe.h
@@ -0,0 +1,350 @@
+/* $Id: sunqe.h,v 1.13 2000/02/09 11:15:42 davem Exp $
+ * sunqe.h: Definitions for the Sun QuadEthernet driver.
+ *
+ * Copyright (C) 1996 David S. Miller (davem@caip.rutgers.edu)
+ */
+
+#ifndef _SUNQE_H
+#define _SUNQE_H
+
+/* QEC global registers. */
+#define GLOB_CTRL	0x00UL		/* Control			*/
+#define GLOB_STAT	0x04UL		/* Status			*/
+#define GLOB_PSIZE	0x08UL		/* Packet Size			*/
+#define GLOB_MSIZE	0x0cUL		/* Local-memory Size		*/
+#define GLOB_RSIZE	0x10UL		/* Receive partition size	*/
+#define GLOB_TSIZE	0x14UL		/* Transmit partition size	*/
+#define GLOB_REG_SIZE	0x18UL
+
+#define GLOB_CTRL_MMODE       0x40000000 /* MACE qec mode            */
+#define GLOB_CTRL_BMODE       0x10000000 /* BigMAC qec mode          */
+#define GLOB_CTRL_EPAR        0x00000020 /* Enable parity            */
+#define GLOB_CTRL_ACNTRL      0x00000018 /* SBUS arbitration control */
+#define GLOB_CTRL_B64         0x00000004 /* 64 byte dvma bursts      */
+#define GLOB_CTRL_B32         0x00000002 /* 32 byte dvma bursts      */
+#define GLOB_CTRL_B16         0x00000000 /* 16 byte dvma bursts      */
+#define GLOB_CTRL_RESET       0x00000001 /* Reset the QEC            */
+
+#define GLOB_STAT_TX          0x00000008 /* BigMAC Transmit IRQ      */
+#define GLOB_STAT_RX          0x00000004 /* BigMAC Receive IRQ       */
+#define GLOB_STAT_BM          0x00000002 /* BigMAC Global IRQ        */
+#define GLOB_STAT_ER          0x00000001 /* BigMAC Error IRQ         */
+
+#define GLOB_PSIZE_2048       0x00       /* 2k packet size           */
+#define GLOB_PSIZE_4096       0x01       /* 4k packet size           */
+#define GLOB_PSIZE_6144       0x10       /* 6k packet size           */
+#define GLOB_PSIZE_8192       0x11       /* 8k packet size           */
+
+/* In MACE mode, there are four qe channels.  Each channel has it's own
+ * status bits in the QEC status register.  This macro picks out the
+ * ones you want.
+ */
+#define GLOB_STAT_PER_QE(status, channel) (((status) >> ((channel) * 4)) & 0xf)
+
+/* The following registers are for per-qe channel information/status. */
+#define CREG_CTRL	0x00UL	/* Control                   */
+#define CREG_STAT	0x04UL	/* Status                    */
+#define CREG_RXDS	0x08UL	/* RX descriptor ring ptr    */
+#define CREG_TXDS	0x0cUL	/* TX descriptor ring ptr    */
+#define CREG_RIMASK	0x10UL	/* RX Interrupt Mask         */
+#define CREG_TIMASK	0x14UL	/* TX Interrupt Mask         */
+#define CREG_QMASK	0x18UL	/* QEC Error Interrupt Mask  */
+#define CREG_MMASK	0x1cUL	/* MACE Error Interrupt Mask */
+#define CREG_RXWBUFPTR	0x20UL	/* Local memory rx write ptr */
+#define CREG_RXRBUFPTR	0x24UL	/* Local memory rx read ptr  */
+#define CREG_TXWBUFPTR	0x28UL	/* Local memory tx write ptr */
+#define CREG_TXRBUFPTR	0x2cUL	/* Local memory tx read ptr  */
+#define CREG_CCNT	0x30UL	/* Collision Counter         */
+#define CREG_PIPG	0x34UL	/* Inter-Frame Gap           */
+#define CREG_REG_SIZE	0x38UL
+
+#define CREG_CTRL_RXOFF       0x00000004  /* Disable this qe's receiver*/
+#define CREG_CTRL_RESET       0x00000002  /* Reset this qe channel     */
+#define CREG_CTRL_TWAKEUP     0x00000001  /* Transmitter Wakeup, 'go'. */
+
+#define CREG_STAT_EDEFER      0x10000000  /* Excessive Defers          */
+#define CREG_STAT_CLOSS       0x08000000  /* Carrier Loss              */
+#define CREG_STAT_ERETRIES    0x04000000  /* More than 16 retries      */
+#define CREG_STAT_LCOLL       0x02000000  /* Late TX Collision         */
+#define CREG_STAT_FUFLOW      0x01000000  /* FIFO Underflow            */
+#define CREG_STAT_JERROR      0x00800000  /* Jabber Error              */
+#define CREG_STAT_BERROR      0x00400000  /* Babble Error              */
+#define CREG_STAT_TXIRQ       0x00200000  /* Transmit Interrupt        */
+#define CREG_STAT_CCOFLOW     0x00100000  /* TX Coll-counter Overflow  */
+#define CREG_STAT_TXDERROR    0x00080000  /* TX Descriptor is bogus    */
+#define CREG_STAT_TXLERR      0x00040000  /* Late Transmit Error       */
+#define CREG_STAT_TXPERR      0x00020000  /* Transmit Parity Error     */
+#define CREG_STAT_TXSERR      0x00010000  /* Transmit SBUS error ack   */
+#define CREG_STAT_RCCOFLOW    0x00001000  /* RX Coll-counter Overflow  */
+#define CREG_STAT_RUOFLOW     0x00000800  /* Runt Counter Overflow     */
+#define CREG_STAT_MCOFLOW     0x00000400  /* Missed Counter Overflow   */
+#define CREG_STAT_RXFOFLOW    0x00000200  /* RX FIFO Overflow          */
+#define CREG_STAT_RLCOLL      0x00000100  /* RX Late Collision         */
+#define CREG_STAT_FCOFLOW     0x00000080  /* Frame Counter Overflow    */
+#define CREG_STAT_CECOFLOW    0x00000040  /* CRC Error-counter Overflow*/
+#define CREG_STAT_RXIRQ       0x00000020  /* Receive Interrupt         */
+#define CREG_STAT_RXDROP      0x00000010  /* Dropped a RX'd packet     */
+#define CREG_STAT_RXSMALL     0x00000008  /* Receive buffer too small  */
+#define CREG_STAT_RXLERR      0x00000004  /* Receive Late Error        */
+#define CREG_STAT_RXPERR      0x00000002  /* Receive Parity Error      */
+#define CREG_STAT_RXSERR      0x00000001  /* Receive SBUS Error ACK    */
+
+#define CREG_STAT_ERRORS      (CREG_STAT_EDEFER|CREG_STAT_CLOSS|CREG_STAT_ERETRIES|     \
+			       CREG_STAT_LCOLL|CREG_STAT_FUFLOW|CREG_STAT_JERROR|       \
+			       CREG_STAT_BERROR|CREG_STAT_CCOFLOW|CREG_STAT_TXDERROR|   \
+			       CREG_STAT_TXLERR|CREG_STAT_TXPERR|CREG_STAT_TXSERR|      \
+			       CREG_STAT_RCCOFLOW|CREG_STAT_RUOFLOW|CREG_STAT_MCOFLOW| \
+			       CREG_STAT_RXFOFLOW|CREG_STAT_RLCOLL|CREG_STAT_FCOFLOW|   \
+			       CREG_STAT_CECOFLOW|CREG_STAT_RXDROP|CREG_STAT_RXSMALL|   \
+			       CREG_STAT_RXLERR|CREG_STAT_RXPERR|CREG_STAT_RXSERR)
+
+#define CREG_QMASK_COFLOW     0x00100000  /* CollCntr overflow         */
+#define CREG_QMASK_TXDERROR   0x00080000  /* TXD error                 */
+#define CREG_QMASK_TXLERR     0x00040000  /* TX late error             */
+#define CREG_QMASK_TXPERR     0x00020000  /* TX parity error           */
+#define CREG_QMASK_TXSERR     0x00010000  /* TX sbus error ack         */
+#define CREG_QMASK_RXDROP     0x00000010  /* RX drop                   */
+#define CREG_QMASK_RXBERROR   0x00000008  /* RX buffer error           */
+#define CREG_QMASK_RXLEERR    0x00000004  /* RX late error             */
+#define CREG_QMASK_RXPERR     0x00000002  /* RX parity error           */
+#define CREG_QMASK_RXSERR     0x00000001  /* RX sbus error ack         */
+
+#define CREG_MMASK_EDEFER     0x10000000  /* Excess defer              */
+#define CREG_MMASK_CLOSS      0x08000000  /* Carrier loss              */
+#define CREG_MMASK_ERETRY     0x04000000  /* Excess retry              */
+#define CREG_MMASK_LCOLL      0x02000000  /* Late collision error      */
+#define CREG_MMASK_UFLOW      0x01000000  /* Underflow                 */
+#define CREG_MMASK_JABBER     0x00800000  /* Jabber error              */
+#define CREG_MMASK_BABBLE     0x00400000  /* Babble error              */
+#define CREG_MMASK_OFLOW      0x00000800  /* Overflow                  */
+#define CREG_MMASK_RXCOLL     0x00000400  /* RX Coll-Cntr overflow     */
+#define CREG_MMASK_RPKT       0x00000200  /* Runt pkt overflow         */
+#define CREG_MMASK_MPKT       0x00000100  /* Missed pkt overflow       */
+
+#define CREG_PIPG_TENAB       0x00000020  /* Enable Throttle           */
+#define CREG_PIPG_MMODE       0x00000010  /* Manual Mode               */
+#define CREG_PIPG_WMASK       0x0000000f  /* SBUS Wait Mask            */
+
+/* Per-channel AMD 79C940 MACE registers. */
+#define MREGS_RXFIFO	0x00UL	/* Receive FIFO                   */
+#define MREGS_TXFIFO	0x01UL	/* Transmit FIFO                  */
+#define MREGS_TXFCNTL	0x02UL	/* Transmit Frame Control         */
+#define MREGS_TXFSTAT	0x03UL	/* Transmit Frame Status          */
+#define MREGS_TXRCNT	0x04UL	/* Transmit Retry Count           */
+#define MREGS_RXFCNTL	0x05UL	/* Receive Frame Control          */
+#define MREGS_RXFSTAT	0x06UL	/* Receive Frame Status           */
+#define MREGS_FFCNT	0x07UL	/* FIFO Frame Count               */
+#define MREGS_IREG	0x08UL	/* Interrupt Register             */
+#define MREGS_IMASK	0x09UL	/* Interrupt Mask                 */
+#define MREGS_POLL	0x0aUL	/* POLL Register                  */
+#define MREGS_BCONFIG	0x0bUL	/* BIU Config                     */
+#define MREGS_FCONFIG	0x0cUL	/* FIFO Config                    */
+#define MREGS_MCONFIG	0x0dUL	/* MAC Config                     */
+#define MREGS_PLSCONFIG	0x0eUL	/* PLS Config                     */
+#define MREGS_PHYCONFIG	0x0fUL	/* PHY Config                     */
+#define MREGS_CHIPID1	0x10UL	/* Chip-ID, low bits              */
+#define MREGS_CHIPID2	0x11UL	/* Chip-ID, high bits             */
+#define MREGS_IACONFIG	0x12UL	/* Internal Address Config        */
+	/* 0x13UL, reserved */
+#define MREGS_FILTER	0x14UL	/* Logical Address Filter         */
+#define MREGS_ETHADDR	0x15UL	/* Our Ethernet Address           */
+	/* 0x16UL, reserved */
+	/* 0x17UL, reserved */
+#define MREGS_MPCNT	0x18UL	/* Missed Packet Count            */
+	/* 0x19UL, reserved */
+#define MREGS_RPCNT	0x1aUL	/* Runt Packet Count              */
+#define MREGS_RCCNT	0x1bUL	/* RX Collision Count             */
+	/* 0x1cUL, reserved */
+#define MREGS_UTEST	0x1dUL	/* User Test                      */
+#define MREGS_RTEST1	0x1eUL	/* Reserved Test 1                */
+#define MREGS_RTEST2	0x1fUL	/* Reserved Test 2                */
+#define MREGS_REG_SIZE	0x20UL
+
+#define MREGS_TXFCNTL_DRETRY        0x80 /* Retry disable                  */
+#define MREGS_TXFCNTL_DFCS          0x08 /* Disable TX FCS                 */
+#define MREGS_TXFCNTL_AUTOPAD       0x01 /* TX auto pad                    */
+
+#define MREGS_TXFSTAT_VALID         0x80 /* TX valid                       */
+#define MREGS_TXFSTAT_UNDERFLOW     0x40 /* TX underflow                   */
+#define MREGS_TXFSTAT_LCOLL         0x20 /* TX late collision              */
+#define MREGS_TXFSTAT_MRETRY        0x10 /* TX > 1 retries                 */
+#define MREGS_TXFSTAT_ORETRY        0x08 /* TX 1 retry                     */
+#define MREGS_TXFSTAT_PDEFER        0x04 /* TX pkt deferred                */
+#define MREGS_TXFSTAT_CLOSS         0x02 /* TX carrier lost                */
+#define MREGS_TXFSTAT_RERROR        0x01 /* TX retry error                 */
+
+#define MREGS_TXRCNT_EDEFER         0x80 /* TX Excess defers               */
+#define MREGS_TXRCNT_CMASK          0x0f /* TX retry count                 */
+
+#define MREGS_RXFCNTL_LOWLAT        0x08 /* RX low latency                 */
+#define MREGS_RXFCNTL_AREJECT       0x04 /* RX addr match rej              */
+#define MREGS_RXFCNTL_AUTOSTRIP     0x01 /* RX auto strip                  */
+
+#define MREGS_RXFSTAT_OVERFLOW      0x80 /* RX overflow                    */
+#define MREGS_RXFSTAT_LCOLL         0x40 /* RX late collision              */
+#define MREGS_RXFSTAT_FERROR        0x20 /* RX framing error               */
+#define MREGS_RXFSTAT_FCSERROR      0x10 /* RX FCS error                   */
+#define MREGS_RXFSTAT_RBCNT         0x0f /* RX msg byte count              */
+
+#define MREGS_FFCNT_RX              0xf0 /* RX FIFO frame cnt              */
+#define MREGS_FFCNT_TX              0x0f /* TX FIFO frame cnt              */
+
+#define MREGS_IREG_JABBER           0x80 /* IRQ Jabber error               */
+#define MREGS_IREG_BABBLE           0x40 /* IRQ Babble error               */
+#define MREGS_IREG_COLL             0x20 /* IRQ Collision error            */
+#define MREGS_IREG_RCCO             0x10 /* IRQ Collision cnt overflow     */
+#define MREGS_IREG_RPKTCO           0x08 /* IRQ Runt packet count overflow */
+#define MREGS_IREG_MPKTCO           0x04 /* IRQ missed packet cnt overflow */
+#define MREGS_IREG_RXIRQ            0x02 /* IRQ RX'd a packet              */
+#define MREGS_IREG_TXIRQ            0x01 /* IRQ TX'd a packet              */
+
+#define MREGS_IMASK_BABBLE          0x40 /* IMASK Babble errors            */
+#define MREGS_IMASK_COLL            0x20 /* IMASK Collision errors         */
+#define MREGS_IMASK_MPKTCO          0x04 /* IMASK Missed pkt cnt overflow  */
+#define MREGS_IMASK_RXIRQ           0x02 /* IMASK RX interrupts            */
+#define MREGS_IMASK_TXIRQ           0x01 /* IMASK TX interrupts            */
+
+#define MREGS_POLL_TXVALID          0x80 /* TX is valid                    */
+#define MREGS_POLL_TDTR             0x40 /* TX data transfer request       */
+#define MREGS_POLL_RDTR             0x20 /* RX data transfer request       */
+
+#define MREGS_BCONFIG_BSWAP         0x40 /* Byte Swap                      */
+#define MREGS_BCONFIG_4TS           0x00 /* 4byte transmit start point     */
+#define MREGS_BCONFIG_16TS          0x10 /* 16byte transmit start point    */
+#define MREGS_BCONFIG_64TS          0x20 /* 64byte transmit start point    */
+#define MREGS_BCONFIG_112TS         0x30 /* 112byte transmit start point   */
+#define MREGS_BCONFIG_RESET         0x01 /* SW-Reset the MACE              */
+
+#define MREGS_FCONFIG_TXF8          0x00 /* TX fifo 8 write cycles         */
+#define MREGS_FCONFIG_TXF32         0x80 /* TX fifo 32 write cycles        */
+#define MREGS_FCONFIG_TXF16         0x40 /* TX fifo 16 write cycles        */
+#define MREGS_FCONFIG_RXF64         0x20 /* RX fifo 64 write cycles        */
+#define MREGS_FCONFIG_RXF32         0x10 /* RX fifo 32 write cycles        */
+#define MREGS_FCONFIG_RXF16         0x00 /* RX fifo 16 write cycles        */
+#define MREGS_FCONFIG_TFWU          0x08 /* TX fifo watermark update       */
+#define MREGS_FCONFIG_RFWU          0x04 /* RX fifo watermark update       */
+#define MREGS_FCONFIG_TBENAB        0x02 /* TX burst enable                */
+#define MREGS_FCONFIG_RBENAB        0x01 /* RX burst enable                */
+
+#define MREGS_MCONFIG_PROMISC       0x80 /* Promiscuous mode enable        */
+#define MREGS_MCONFIG_TPDDISAB      0x40 /* TX 2part deferral enable       */
+#define MREGS_MCONFIG_MBAENAB       0x20 /* Modified backoff enable        */
+#define MREGS_MCONFIG_RPADISAB      0x08 /* RX physical addr disable       */
+#define MREGS_MCONFIG_RBDISAB       0x04 /* RX broadcast disable           */
+#define MREGS_MCONFIG_TXENAB        0x02 /* Enable transmitter             */
+#define MREGS_MCONFIG_RXENAB        0x01 /* Enable receiver                */
+
+#define MREGS_PLSCONFIG_TXMS        0x08 /* TX mode select                 */
+#define MREGS_PLSCONFIG_GPSI        0x06 /* Use GPSI connector             */
+#define MREGS_PLSCONFIG_DAI         0x04 /* Use DAI connector              */
+#define MREGS_PLSCONFIG_TP          0x02 /* Use TwistedPair connector      */
+#define MREGS_PLSCONFIG_AUI         0x00 /* Use AUI connector              */
+#define MREGS_PLSCONFIG_IOENAB      0x01 /* PLS I/O enable                 */
+
+#define MREGS_PHYCONFIG_LSTAT       0x80 /* Link status                    */
+#define MREGS_PHYCONFIG_LTESTDIS    0x40 /* Disable link test logic        */
+#define MREGS_PHYCONFIG_RXPOLARITY  0x20 /* RX polarity                    */
+#define MREGS_PHYCONFIG_APCDISAB    0x10 /* AutoPolarityCorrect disab      */
+#define MREGS_PHYCONFIG_LTENAB      0x08 /* Select low threshold           */
+#define MREGS_PHYCONFIG_AUTO        0x04 /* Connector port auto-sel        */
+#define MREGS_PHYCONFIG_RWU         0x02 /* Remote WakeUp                  */
+#define MREGS_PHYCONFIG_AW          0x01 /* Auto Wakeup                    */
+
+#define MREGS_IACONFIG_ACHNGE       0x80 /* Do address change              */
+#define MREGS_IACONFIG_PARESET      0x04 /* Physical address reset         */
+#define MREGS_IACONFIG_LARESET      0x02 /* Logical address reset          */
+
+#define MREGS_UTEST_RTRENAB         0x80 /* Enable resv test register      */
+#define MREGS_UTEST_RTRDISAB        0x40 /* Disab resv test register       */
+#define MREGS_UTEST_RPACCEPT        0x20 /* Accept runt packets            */
+#define MREGS_UTEST_FCOLL           0x10 /* Force collision status         */
+#define MREGS_UTEST_FCSENAB         0x08 /* Enable FCS on RX               */
+#define MREGS_UTEST_INTLOOPM        0x06 /* Intern lpback w/MENDEC         */
+#define MREGS_UTEST_INTLOOP         0x04 /* Intern lpback                  */
+#define MREGS_UTEST_EXTLOOP         0x02 /* Extern lpback                  */
+#define MREGS_UTEST_NOLOOP          0x00 /* No loopback                    */
+
+struct qe_rxd {
+	u32 rx_flags;
+	u32 rx_addr;
+};
+
+#define RXD_OWN      0x80000000 /* Ownership.      */
+#define RXD_UPDATE   0x10000000 /* Being Updated?  */
+#define RXD_LENGTH   0x000007ff /* Packet Length.  */
+
+struct qe_txd {
+	u32 tx_flags;
+	u32 tx_addr;
+};
+
+#define TXD_OWN      0x80000000 /* Ownership.      */
+#define TXD_SOP      0x40000000 /* Start Of Packet */
+#define TXD_EOP      0x20000000 /* End Of Packet   */
+#define TXD_UPDATE   0x10000000 /* Being Updated?  */
+#define TXD_LENGTH   0x000007ff /* Packet Length.  */
+
+#define TX_RING_MAXSIZE   256
+#define RX_RING_MAXSIZE   256
+
+#define TX_RING_SIZE      16
+#define RX_RING_SIZE      16
+
+#define NEXT_RX(num)       (((num) + 1) & (RX_RING_MAXSIZE - 1))
+#define NEXT_TX(num)       (((num) + 1) & (TX_RING_MAXSIZE - 1))
+#define PREV_RX(num)       (((num) - 1) & (RX_RING_MAXSIZE - 1))
+#define PREV_TX(num)       (((num) - 1) & (TX_RING_MAXSIZE - 1))
+
+#define TX_BUFFS_AVAIL(qp)                                    \
+        (((qp)->tx_old <= (qp)->tx_new) ?                     \
+	  (qp)->tx_old + (TX_RING_SIZE - 1) - (qp)->tx_new :  \
+			    (qp)->tx_old - (qp)->tx_new - 1)
+
+struct qe_init_block {
+	struct qe_rxd qe_rxd[RX_RING_MAXSIZE];
+	struct qe_txd qe_txd[TX_RING_MAXSIZE];
+};
+
+#define qib_offset(mem, elem) \
+((__u32)((unsigned long)(&(((struct qe_init_block *)0)->mem[elem]))))
+
+struct sunqe;
+
+struct sunqec {
+	void __iomem		*gregs;		/* QEC Global Registers         */
+	struct sunqe		*qes[4];	/* Each child MACE              */
+	unsigned int            qec_bursts;	/* Support burst sizes          */
+	struct platform_device	*op;		/* QEC's OF device              */
+	struct sunqec		*next_module;	/* List of all QECs in system   */
+};
+
+#define PKT_BUF_SZ	1664
+#define RXD_PKT_SZ	1664
+
+struct sunqe_buffers {
+	u8	tx_buf[TX_RING_SIZE][PKT_BUF_SZ];
+	u8	__pad[2];
+	u8	rx_buf[RX_RING_SIZE][PKT_BUF_SZ];
+};
+
+#define qebuf_offset(mem, elem) \
+((__u32)((unsigned long)(&(((struct sunqe_buffers *)0)->mem[elem][0]))))
+
+struct sunqe {
+	void __iomem			*qcregs;		/* QEC per-channel Registers   */
+	void __iomem			*mregs;		/* Per-channel MACE Registers  */
+	struct qe_init_block      	*qe_block;	/* RX and TX descriptors       */
+	__u32                      	qblock_dvma;	/* RX and TX descriptors       */
+	spinlock_t			lock;		/* Protects txfull state       */
+	int                        	rx_new, rx_old;	/* RX ring extents	       */
+	int			   	tx_new, tx_old;	/* TX ring extents	       */
+	struct sunqe_buffers		*buffers;	/* CPU visible address.        */
+	__u32				buffers_dvma;	/* DVMA visible address.       */
+	struct sunqec			*parent;
+	u8				mconfig;	/* Base MACE mconfig value     */
+	struct platform_device		*op;		/* QE's OF device struct       */
+	struct net_device		*dev;		/* QE's netdevice struct       */
+	int				channel;	/* Who am I?                   */
+};
+
+#endif /* !(_SUNQE_H) */
