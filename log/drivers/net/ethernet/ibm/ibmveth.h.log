commit 9aedc6e2f1c6708120b80748556fb6ad0567d15d
Author: Cris Forno <cforno12@linux.vnet.ibm.com>
Date:   Fri Feb 28 14:12:05 2020 -0600

    net/ethtool: Introduce link_ksettings API for virtual network devices
    
    With the ethtool_virtdev_set_link_ksettings function in core/ethtool.c,
    ibmveth, netvsc, and virtio now use the core's helper function.
    
    Funtionality changes that pertain to ibmveth driver include:
    
      1. Changed the initial hardcoded link speed to 1GB.
    
      2. Added support for allowing a user to change the reported link
      speed via ethtool.
    
    Functionality changes to the netvsc driver include:
    
      1. When netvsc_get_link_ksettings is called, it will defer to the VF
      device if it exists to pull accelerated networking values, otherwise
      pull default or user-defined values.
    
      2. Similarly, if netvsc_set_link_ksettings called and a VF device
      exists, the real values of speed and duplex are changed.
    
    Signed-off-by: Cris Forno <cforno12@linux.vnet.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ibm/ibmveth.h b/drivers/net/ethernet/ibm/ibmveth.h
index 4e9bf3421f4f..27dfff200166 100644
--- a/drivers/net/ethernet/ibm/ibmveth.h
+++ b/drivers/net/ethernet/ibm/ibmveth.h
@@ -162,6 +162,9 @@ struct ibmveth_adapter {
     u64 tx_send_failed;
     u64 tx_large_packets;
     u64 rx_large_packets;
+    /* Ethtool settings */
+	u8 duplex;
+	u32 speed;
 };
 
 /*

commit 1ccea77e2a2687cae171b7987eb44730ec8c6d5f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 15:51:43 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 13
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not see http www gnu org licenses
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details [based]
      [from] [clk] [highbank] [c] you should have received a copy of the
      gnu general public license along with this program if not see http
      www gnu org licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 355 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Jilayne Lovejoy <opensource@jilayne.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190519154041.837383322@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/ethernet/ibm/ibmveth.h b/drivers/net/ethernet/ibm/ibmveth.h
index 01c587fc02c7..4e9bf3421f4f 100644
--- a/drivers/net/ethernet/ibm/ibmveth.h
+++ b/drivers/net/ethernet/ibm/ibmveth.h
@@ -1,19 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * IBM Power Virtual Ethernet Device Driver
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
- *
  * Copyright (C) IBM Corporation, 2003, 2010
  *
  * Authors: Dave Larson <larson1@us.ibm.com>

commit 66aa0678efc29abd2ab02a09b23f9a8bc9f12a6c
Author: Sivakumar Krishnasamy <ksiva@linux.vnet.ibm.com>
Date:   Fri May 19 05:30:38 2017 -0400

    ibmveth: Support to enable LSO/CSO for Trunk VEA.
    
    Current largesend and checksum offload feature in ibmveth driver,
     - Source VM sends the TCP packets with ip_summed field set as
       CHECKSUM_PARTIAL and TCP pseudo header checksum is placed in
       checksum field
     - CHECKSUM_PARTIAL flag in SKB will enable ibmveth driver to mark
       "no checksum" and "checksum good" bits in transmit buffer descriptor
       before the packet is delivered to pseries PowerVM Hypervisor
     - If ibmveth has largesend capability enabled, transmit buffer descriptors
       are market accordingly before packet is delivered to Hypervisor
       (along with mss value for packets with length > MSS)
     - Destination VM's ibmveth driver receives the packet with "checksum good"
       bit set and so, SKB's ip_summed field is set with CHECKSUM_UNNECESSARY
     - If "largesend" bit was on, mss value is copied from receive descriptor
       into SKB's gso_size and other flags are appropriately set for
       packets > MSS size
     - The packet is now successfully delivered up the stack in destination VM
    
    The offloads described above works fine for TCP communication among VMs in
    the same pseries server ( VM A <=> PowerVM Hypervisor <=> VM B )
    
    We are now enabling support for OVS in pseries PowerVM environment. One of
    our requirements is to have ibmveth driver configured in "Trunk" mode, when
    they are used with OVS. This is because, PowerVM Hypervisor will no more
    bridge the packets between VMs, instead the packets are delivered to
    IO Server which hosts OVS to bridge them between VMs or to external
    networks (flow shown below),
      VM A <=> PowerVM Hypervisor <=> IO Server(OVS) <=> PowerVM Hypervisor
                                                                       <=> VM B
    In "IO server" the packet is received by inbound Trunk ibmveth and then
    delivered to OVS, which is then bridged to outbound Trunk ibmveth (shown
    below),
            Inbound Trunk ibmveth <=> OVS <=> Outbound Trunk ibmveth
    
    In this model, we hit the following issues which impacted the VM
    communication performance,
    
     - Issue 1: ibmveth doesn't support largesend and checksum offload features
       when configured as "Trunk". Driver has explicit checks to prevent
       enabling these offloads.
    
     - Issue 2: SYN packet drops seen at destination VM. When the packet
       originates, it has CHECKSUM_PARTIAL flag set and as it gets delivered to
       IO server's inbound Trunk ibmveth, on validating "checksum good" bits
       in ibmveth receive routine, SKB's ip_summed field is set with
       CHECKSUM_UNNECESSARY flag. This packet is then bridged by OVS (or Linux
       Bridge) and delivered to outbound Trunk ibmveth. At this point the
       outbound ibmveth transmit routine will not set "no checksum" and
       "checksum good" bits in transmit buffer descriptor, as it does so only
       when the ip_summed field is CHECKSUM_PARTIAL. When this packet gets
       delivered to destination VM, TCP layer receives the packet with checksum
       value of 0 and with no checksum related flags in ip_summed field. This
       leads to packet drops. So, TCP connections never goes through fine.
    
     - Issue 3: First packet of a TCP connection will be dropped, if there is
       no OVS flow cached in datapath. OVS while trying to identify the flow,
       computes the checksum. The computed checksum will be invalid at the
       receiving end, as ibmveth transmit routine zeroes out the pseudo
       checksum value in the packet. This leads to packet drop.
    
     - Issue 4: ibmveth driver doesn't have support for SKB's with frag_list.
       When Physical NIC has GRO enabled and when OVS bridges these packets,
       OVS vport send code will end up calling dev_queue_xmit, which in turn
       calls validate_xmit_skb.
       In validate_xmit_skb routine, the larger packets will get segmented into
       MSS sized segments, if SKB has a frag_list and if the driver to which
       they are delivered to doesn't support NETIF_F_FRAGLIST feature.
    
    This patch addresses the above four issues, thereby enabling end to end
    largesend and checksum offload support for better performance.
    
     - Fix for Issue 1 : Remove checks which prevent enabling TCP largesend and
       checksum offloads.
     - Fix for Issue 2 : When ibmveth receives a packet with "checksum good"
       bit set and if its configured in Trunk mode, set appropriate SKB fields
       using skb_partial_csum_set (ip_summed field is set with
       CHECKSUM_PARTIAL)
     - Fix for Issue 3: Recompute the pseudo header checksum before sending the
       SKB up the stack.
     - Fix for Issue 4: Linearize the SKBs with frag_list. Though we end up
       allocating buffers and copying data, this fix gives
       upto 4X throughput increase.
    
    Note: All these fixes need to be dropped together as fixing just one of
    them will lead to other issues immediately (especially for Issues 1,2 & 3).
    
    Signed-off-by: Sivakumar Krishnasamy <ksiva@linux.vnet.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ibm/ibmveth.h b/drivers/net/ethernet/ibm/ibmveth.h
index ed8780cca982..01c587fc02c7 100644
--- a/drivers/net/ethernet/ibm/ibmveth.h
+++ b/drivers/net/ethernet/ibm/ibmveth.h
@@ -156,6 +156,7 @@ struct ibmveth_adapter {
     int pool_config;
     int rx_csum;
     int large_send;
+    bool is_active_trunk;
     void *bounce_buffer;
     dma_addr_t bounce_buffer_dma;
 

commit 8c2ef1978fd4b818d3269554016bd29bfe880562
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Mon Mar 27 08:56:15 2017 +0200

    net: ibmveth: Remove unused stats member from struct ibmveth_adapter
    
    The ibmveth driver keeps its statistics in net_device->stats, so the
    stats member in struct ibmveth_adapter is unused. Remove it.
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ibm/ibmveth.h b/drivers/net/ethernet/ibm/ibmveth.h
index 7acda04d034e..ed8780cca982 100644
--- a/drivers/net/ethernet/ibm/ibmveth.h
+++ b/drivers/net/ethernet/ibm/ibmveth.h
@@ -146,7 +146,6 @@ struct ibmveth_adapter {
     struct vio_dev *vdev;
     struct net_device *netdev;
     struct napi_struct napi;
-    struct net_device_stats stats;
     unsigned int mcastFilterSize;
     void * buffer_list_addr;
     void * filter_list_addr;

commit 7b5967389f5a8dfb9d32843830f5e2717e20995d
Author: Thomas Falcon <tlfalcon@linux.vnet.ibm.com>
Date:   Thu Dec 8 16:40:03 2016 -0600

    ibmveth: set correct gso_size and gso_type
    
    This patch is based on an earlier one submitted
    by Jon Maxwell with the following commit message:
    
    "We recently encountered a bug where a few customers using ibmveth on the
    same LPAR hit an issue where a TCP session hung when large receive was
    enabled. Closer analysis revealed that the session was stuck because the
    one side was advertising a zero window repeatedly.
    
    We narrowed this down to the fact the ibmveth driver did not set gso_size
    which is translated by TCP into the MSS later up the stack. The MSS is
    used to calculate the TCP window size and as that was abnormally large,
    it was calculating a zero window, even although the sockets receive buffer
    was completely empty."
    
    We rely on the Virtual I/O Server partition in a pseries
    environment to provide the MSS through the TCP header checksum
    field. The stipulation is that users should not disable checksum
    offloading if rx packet aggregation is enabled through VIOS.
    
    Some firmware offerings provide the MSS in the RX buffer.
    This is signalled by a bit in the RX queue descriptor.
    
    Reviewed-by: Brian King <brking@linux.vnet.ibm.com>
    Reviewed-by: Pradeep Satyanarayana <pradeeps@linux.vnet.ibm.com>
    Reviewed-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Reviewed-by: Jonathan Maxwell <jmaxwell37@gmail.com>
    Reviewed-by: David Dai <zdai@us.ibm.com>
    Signed-off-by: Thomas Falcon <tlfalcon@linux.vnet.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ibm/ibmveth.h b/drivers/net/ethernet/ibm/ibmveth.h
index 4eade67fe30c..7acda04d034e 100644
--- a/drivers/net/ethernet/ibm/ibmveth.h
+++ b/drivers/net/ethernet/ibm/ibmveth.h
@@ -209,6 +209,7 @@ struct ibmveth_rx_q_entry {
 #define IBMVETH_RXQ_TOGGLE		0x80000000
 #define IBMVETH_RXQ_TOGGLE_SHIFT	31
 #define IBMVETH_RXQ_VALID		0x40000000
+#define IBMVETH_RXQ_LRG_PKT		0x04000000
 #define IBMVETH_RXQ_NO_CSUM		0x02000000
 #define IBMVETH_RXQ_CSUM_GOOD		0x01000000
 #define IBMVETH_RXQ_OFF_MASK		0x0000FFFF

commit 07e6a97da1eba064bb35cfd5c121e90865393a60
Author: Thomas Falcon <tlfalcon@linux.vnet.ibm.com>
Date:   Tue Jul 14 10:51:51 2015 -0500

    ibmveth: add support for TSO6
    
    This patch adds support for a new method of signalling the firmware
    that TSO packets are being sent. The new method removes the need to
    alter the ip and tcp checksums and allows TSO6 support.
    
    Signed-off-by: Thomas Falcon <tlfalcon@linux.vnet.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ibm/ibmveth.h b/drivers/net/ethernet/ibm/ibmveth.h
index 41dedb1fb2ae..4eade67fe30c 100644
--- a/drivers/net/ethernet/ibm/ibmveth.h
+++ b/drivers/net/ethernet/ibm/ibmveth.h
@@ -40,6 +40,8 @@
 #define IbmVethMcastRemoveFilter     0x2UL
 #define IbmVethMcastClearFilterTable 0x3UL
 
+#define IBMVETH_ILLAN_LRG_SR_ENABLED	0x0000000000010000UL
+#define IBMVETH_ILLAN_LRG_SND_SUPPORT	0x0000000000008000UL
 #define IBMVETH_ILLAN_PADDED_PKT_CSUM	0x0000000000002000UL
 #define IBMVETH_ILLAN_TRUNK_PRI_MASK	0x0000000000000F00UL
 #define IBMVETH_ILLAN_IPV6_TCP_CSUM		0x0000000000000004UL
@@ -59,13 +61,20 @@
 static inline long h_send_logical_lan(unsigned long unit_address,
 		unsigned long desc1, unsigned long desc2, unsigned long desc3,
 		unsigned long desc4, unsigned long desc5, unsigned long desc6,
-		unsigned long corellator_in, unsigned long *corellator_out)
+		unsigned long corellator_in, unsigned long *corellator_out,
+		unsigned long mss, unsigned long large_send_support)
 {
 	long rc;
 	unsigned long retbuf[PLPAR_HCALL9_BUFSIZE];
 
-	rc = plpar_hcall9(H_SEND_LOGICAL_LAN, retbuf, unit_address, desc1,
-			desc2, desc3, desc4, desc5, desc6, corellator_in);
+	if (large_send_support)
+		rc = plpar_hcall9(H_SEND_LOGICAL_LAN, retbuf, unit_address,
+				  desc1, desc2, desc3, desc4, desc5, desc6,
+				  corellator_in, mss);
+	else
+		rc = plpar_hcall9(H_SEND_LOGICAL_LAN, retbuf, unit_address,
+				  desc1, desc2, desc3, desc4, desc5, desc6,
+				  corellator_in);
 
 	*corellator_out = retbuf[0];
 
@@ -147,11 +156,13 @@ struct ibmveth_adapter {
     struct ibmveth_rx_q rx_queue;
     int pool_config;
     int rx_csum;
+    int large_send;
     void *bounce_buffer;
     dma_addr_t bounce_buffer_dma;
 
     u64 fw_ipv6_csum_support;
     u64 fw_ipv4_csum_support;
+    u64 fw_large_send_support;
     /* adapter specific stats */
     u64 replenish_task_cycles;
     u64 replenish_no_mem;
@@ -182,6 +193,7 @@ struct ibmveth_buf_desc_fields {
 #endif
 #define IBMVETH_BUF_VALID	0x80000000
 #define IBMVETH_BUF_TOGGLE	0x40000000
+#define IBMVETH_BUF_LRG_SND     0x04000000
 #define IBMVETH_BUF_NO_CSUM	0x02000000
 #define IBMVETH_BUF_CSUM_GOOD	0x01000000
 #define IBMVETH_BUF_LEN_MASK	0x00FFFFFF

commit 9c7e8bc584f52ae42f4528ca459f711ad38a130f
Author: Thomas Falcon <tlfalcon@linux.vnet.ibm.com>
Date:   Wed Apr 29 16:25:47 2015 -0500

    ibmveth: Add support for Large Receive Offload
    
    Enables receiving large packets from other LPARs. These packets
    have a -1 IP header checksum, so we must recalculate to have
    a valid checksum.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: Thomas Falcon <tlfalcon@linux.vnet.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ibm/ibmveth.h b/drivers/net/ethernet/ibm/ibmveth.h
index 56d1e22bd1d3..41dedb1fb2ae 100644
--- a/drivers/net/ethernet/ibm/ibmveth.h
+++ b/drivers/net/ethernet/ibm/ibmveth.h
@@ -162,6 +162,7 @@ struct ibmveth_adapter {
     u64 tx_map_failed;
     u64 tx_send_failed;
     u64 tx_large_packets;
+    u64 rx_large_packets;
 };
 
 /*

commit 8641dd85799f85bef5f0d1f87356aaa12cb2195e
Author: Thomas Falcon <tlfalcon@linux.vnet.ibm.com>
Date:   Wed Apr 29 16:25:45 2015 -0500

    ibmveth: Add support for TSO
    
    Add support for TSO.  TSO is turned off by default and
    must be enabled and configured by the user.  The driver
    version number is increased so that users can be sure
    that they are using ibmveth with TSO support.
    
    Cc: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: Thomas Falcon <tlfalcon@linux.vnet.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ibm/ibmveth.h b/drivers/net/ethernet/ibm/ibmveth.h
index 0dc664bebd4b..56d1e22bd1d3 100644
--- a/drivers/net/ethernet/ibm/ibmveth.h
+++ b/drivers/net/ethernet/ibm/ibmveth.h
@@ -161,6 +161,7 @@ struct ibmveth_adapter {
     u64 rx_no_buffer;
     u64 tx_map_failed;
     u64 tx_send_failed;
+    u64 tx_large_packets;
 };
 
 /*

commit cd7c7ec3687986c71b48848637066d4460c92b95
Author: Thomas Falcon <tlfalcon@linux.vnet.ibm.com>
Date:   Wed Apr 29 16:25:44 2015 -0500

    ibmveth: change rx buffer default allocation for CMO
    
    This patch enables 64k rx buffer pools by default.  If Cooperative
    Memory Overcommitment (CMO) is enabled, the number of 64k buffers
    is reduced to save memory.
    
    Cc: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: Thomas Falcon <tlfalcon@linux.vnet.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ibm/ibmveth.h b/drivers/net/ethernet/ibm/ibmveth.h
index 1f37499d4398..0dc664bebd4b 100644
--- a/drivers/net/ethernet/ibm/ibmveth.h
+++ b/drivers/net/ethernet/ibm/ibmveth.h
@@ -104,7 +104,8 @@ static inline long h_illan_attributes(unsigned long unit_address,
 
 static int pool_size[] = { 512, 1024 * 2, 1024 * 16, 1024 * 32, 1024 * 64 };
 static int pool_count[] = { 256, 512, 256, 256, 256 };
-static int pool_active[] = { 1, 1, 0, 0, 0};
+static int pool_count_cmo[] = { 256, 512, 256, 256, 64 };
+static int pool_active[] = { 1, 1, 0, 0, 1};
 
 #define IBM_VETH_INVALID_MAP ((u16)0xffff)
 

commit d746ca9561440685edb62614d1bcbbc27ff50e66
Author: Anton Blanchard <anton@samba.org>
Date:   Wed Mar 5 14:51:37 2014 +1100

    ibmveth: Fix endian issues with MAC addresses
    
    The code to load a MAC address into a u64 for passing to the
    hypervisor via a register is broken on little endian.
    
    Create a helper function called ibmveth_encode_mac_addr
    which does the right thing in both big and little endian.
    
    We were storing the MAC address in a long in struct ibmveth_adapter.
    It's never used so remove it - we don't need another place in the
    driver where we create endian issues with MAC addresses.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Cc: stable@vger.kernel.org
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ibm/ibmveth.h b/drivers/net/ethernet/ibm/ibmveth.h
index 451ba7949e15..1f37499d4398 100644
--- a/drivers/net/ethernet/ibm/ibmveth.h
+++ b/drivers/net/ethernet/ibm/ibmveth.h
@@ -138,7 +138,6 @@ struct ibmveth_adapter {
     struct napi_struct napi;
     struct net_device_stats stats;
     unsigned int mcastFilterSize;
-    unsigned long mac_addr;
     void * buffer_list_addr;
     void * filter_list_addr;
     dma_addr_t buffer_list_dma;

commit 0ab75ae81da249988bf3c7a38e0a48d4b9be1e0c
Author: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Date:   Fri Dec 6 06:28:43 2013 -0800

    ethernet: Fix FSF address in file headers
    
    Several files refer to an old address for the Free Software Foundation
    in the file header comment.  Resolve by replacing the address with
    the URL <http://www.gnu.org/licenses/> so that we do not have to keep
    updating the header comments anytime the address changes.
    
    CC: Santosh Raspatur <santosh@chelsio.com>
    CC: Dimitris Michailidis <dm@chelsio.com>
    CC: Michael Chan <mchan@broadcom.com>
    CC: Santiago Leon <santil@linux.vnet.ibm.com>
    CC: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    CC: Olof Johansson <olof@lixom.net>
    CC: Manish Chopra <manish.chopra@qlogic.com>
    CC: Sony Chacko <sony.chacko@qlogic.com>
    CC: Rajesh Borundia <rajesh.borundia@qlogic.com>
    CC: Nicolas Pitre <nico@fluxnic.net>
    CC: Steve Glendinning <steve.glendinning@shawell.net>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ibm/ibmveth.h b/drivers/net/ethernet/ibm/ibmveth.h
index 84066bafe057..451ba7949e15 100644
--- a/drivers/net/ethernet/ibm/ibmveth.h
+++ b/drivers/net/ethernet/ibm/ibmveth.h
@@ -12,8 +12,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
  *
  * Copyright (C) IBM Corporation, 2003, 2010
  *

commit 0b536be7b987de14dab63ea565fc1e271a7f3a5f
Author: Anton Blanchard <anton@samba.org>
Date:   Tue Sep 3 09:55:32 2013 +1000

    ibmveth: Fix little endian issues
    
    The hypervisor is big endian, so little endian kernel builds need
    to byteswap.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ibm/ibmveth.h b/drivers/net/ethernet/ibm/ibmveth.h
index 43a794fab9ff..84066bafe057 100644
--- a/drivers/net/ethernet/ibm/ibmveth.h
+++ b/drivers/net/ethernet/ibm/ibmveth.h
@@ -164,14 +164,26 @@ struct ibmveth_adapter {
     u64 tx_send_failed;
 };
 
+/*
+ * We pass struct ibmveth_buf_desc_fields to the hypervisor in registers,
+ * so we don't need to byteswap the two elements. However since we use
+ * a union (ibmveth_buf_desc) to convert from the struct to a u64 we
+ * do end up with endian specific ordering of the elements and that
+ * needs correcting.
+ */
 struct ibmveth_buf_desc_fields {
+#ifdef __BIG_ENDIAN
+	u32 flags_len;
+	u32 address;
+#else
+	u32 address;
 	u32 flags_len;
+#endif
 #define IBMVETH_BUF_VALID	0x80000000
 #define IBMVETH_BUF_TOGGLE	0x40000000
 #define IBMVETH_BUF_NO_CSUM	0x02000000
 #define IBMVETH_BUF_CSUM_GOOD	0x01000000
 #define IBMVETH_BUF_LEN_MASK	0x00FFFFFF
-	u32 address;
 };
 
 union ibmveth_buf_desc {
@@ -180,7 +192,7 @@ union ibmveth_buf_desc {
 };
 
 struct ibmveth_rx_q_entry {
-	u32 flags_off;
+	__be32 flags_off;
 #define IBMVETH_RXQ_TOGGLE		0x80000000
 #define IBMVETH_RXQ_TOGGLE_SHIFT	31
 #define IBMVETH_RXQ_VALID		0x40000000
@@ -188,7 +200,8 @@ struct ibmveth_rx_q_entry {
 #define IBMVETH_RXQ_CSUM_GOOD		0x01000000
 #define IBMVETH_RXQ_OFF_MASK		0x0000FFFF
 
-	u32 length;
+	__be32 length;
+	/* correlator is only used by the OS, no need to byte swap */
 	u64 correlator;
 };
 

commit 9aa3283595451ca093500ff0977b106e1f465586
Author: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Date:   Fri May 13 14:29:12 2011 -0700

    ehea/ibm*: Move the IBM drivers
    
    Move the IBM drivers into drivers/net/ethernet/ibm/ and make the
    necessary Kconfig and Makefile changes.
    
    - Renamed ibm_new_emac to emac
    - Cleaned up Makefile and Kconfig options which referred to
      IBM_NEW_EMAC to IBM_EMAC
    - ibmlana driver is a National Semiconductor SONIC driver so
      it was not moved
    
    CC: Christoph Raisch <raisch@de.ibm.com>
    CC: Santiago Leon <santil@linux.vnet.ibm.com>
    CC: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    CC: David Gibson <dwg@au1.ibm.com>
    CC: Kyle Lucke <klucke@us.ibm.com>
    CC: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/ibm/ibmveth.h b/drivers/net/ethernet/ibm/ibmveth.h
new file mode 100644
index 000000000000..43a794fab9ff
--- /dev/null
+++ b/drivers/net/ethernet/ibm/ibmveth.h
@@ -0,0 +1,195 @@
+/*
+ * IBM Power Virtual Ethernet Device Driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (C) IBM Corporation, 2003, 2010
+ *
+ * Authors: Dave Larson <larson1@us.ibm.com>
+ *	    Santiago Leon <santil@linux.vnet.ibm.com>
+ *	    Brian King <brking@linux.vnet.ibm.com>
+ *	    Robert Jennings <rcj@linux.vnet.ibm.com>
+ *	    Anton Blanchard <anton@au.ibm.com>
+ */
+
+#ifndef _IBMVETH_H
+#define _IBMVETH_H
+
+/* constants for H_MULTICAST_CTRL */
+#define IbmVethMcastReceptionModifyBit     0x80000UL
+#define IbmVethMcastReceptionEnableBit     0x20000UL
+#define IbmVethMcastFilterModifyBit        0x40000UL
+#define IbmVethMcastFilterEnableBit        0x10000UL
+
+#define IbmVethMcastEnableRecv       (IbmVethMcastReceptionModifyBit | IbmVethMcastReceptionEnableBit)
+#define IbmVethMcastDisableRecv      (IbmVethMcastReceptionModifyBit)
+#define IbmVethMcastEnableFiltering  (IbmVethMcastFilterModifyBit | IbmVethMcastFilterEnableBit)
+#define IbmVethMcastDisableFiltering (IbmVethMcastFilterModifyBit)
+#define IbmVethMcastAddFilter        0x1UL
+#define IbmVethMcastRemoveFilter     0x2UL
+#define IbmVethMcastClearFilterTable 0x3UL
+
+#define IBMVETH_ILLAN_PADDED_PKT_CSUM	0x0000000000002000UL
+#define IBMVETH_ILLAN_TRUNK_PRI_MASK	0x0000000000000F00UL
+#define IBMVETH_ILLAN_IPV6_TCP_CSUM		0x0000000000000004UL
+#define IBMVETH_ILLAN_IPV4_TCP_CSUM		0x0000000000000002UL
+#define IBMVETH_ILLAN_ACTIVE_TRUNK		0x0000000000000001UL
+
+/* hcall macros */
+#define h_register_logical_lan(ua, buflst, rxq, fltlst, mac) \
+  plpar_hcall_norets(H_REGISTER_LOGICAL_LAN, ua, buflst, rxq, fltlst, mac)
+
+#define h_free_logical_lan(ua) \
+  plpar_hcall_norets(H_FREE_LOGICAL_LAN, ua)
+
+#define h_add_logical_lan_buffer(ua, buf) \
+  plpar_hcall_norets(H_ADD_LOGICAL_LAN_BUFFER, ua, buf)
+
+static inline long h_send_logical_lan(unsigned long unit_address,
+		unsigned long desc1, unsigned long desc2, unsigned long desc3,
+		unsigned long desc4, unsigned long desc5, unsigned long desc6,
+		unsigned long corellator_in, unsigned long *corellator_out)
+{
+	long rc;
+	unsigned long retbuf[PLPAR_HCALL9_BUFSIZE];
+
+	rc = plpar_hcall9(H_SEND_LOGICAL_LAN, retbuf, unit_address, desc1,
+			desc2, desc3, desc4, desc5, desc6, corellator_in);
+
+	*corellator_out = retbuf[0];
+
+	return rc;
+}
+
+static inline long h_illan_attributes(unsigned long unit_address,
+				      unsigned long reset_mask, unsigned long set_mask,
+				      unsigned long *ret_attributes)
+{
+	long rc;
+	unsigned long retbuf[PLPAR_HCALL_BUFSIZE];
+
+	rc = plpar_hcall(H_ILLAN_ATTRIBUTES, retbuf, unit_address,
+			 reset_mask, set_mask);
+
+	*ret_attributes = retbuf[0];
+
+	return rc;
+}
+
+#define h_multicast_ctrl(ua, cmd, mac) \
+  plpar_hcall_norets(H_MULTICAST_CTRL, ua, cmd, mac)
+
+#define h_change_logical_lan_mac(ua, mac) \
+  plpar_hcall_norets(H_CHANGE_LOGICAL_LAN_MAC, ua, mac)
+
+#define IBMVETH_NUM_BUFF_POOLS 5
+#define IBMVETH_IO_ENTITLEMENT_DEFAULT 4243456 /* MTU of 1500 needs 4.2Mb */
+#define IBMVETH_BUFF_OH 22 /* Overhead: 14 ethernet header + 8 opaque handle */
+#define IBMVETH_MIN_MTU 68
+#define IBMVETH_MAX_POOL_COUNT 4096
+#define IBMVETH_BUFF_LIST_SIZE 4096
+#define IBMVETH_FILT_LIST_SIZE 4096
+#define IBMVETH_MAX_BUF_SIZE (1024 * 128)
+
+static int pool_size[] = { 512, 1024 * 2, 1024 * 16, 1024 * 32, 1024 * 64 };
+static int pool_count[] = { 256, 512, 256, 256, 256 };
+static int pool_active[] = { 1, 1, 0, 0, 0};
+
+#define IBM_VETH_INVALID_MAP ((u16)0xffff)
+
+struct ibmveth_buff_pool {
+    u32 size;
+    u32 index;
+    u32 buff_size;
+    u32 threshold;
+    atomic_t available;
+    u32 consumer_index;
+    u32 producer_index;
+    u16 *free_map;
+    dma_addr_t *dma_addr;
+    struct sk_buff **skbuff;
+    int active;
+    struct kobject kobj;
+};
+
+struct ibmveth_rx_q {
+    u64        index;
+    u64        num_slots;
+    u64        toggle;
+    dma_addr_t queue_dma;
+    u32        queue_len;
+    struct ibmveth_rx_q_entry *queue_addr;
+};
+
+struct ibmveth_adapter {
+    struct vio_dev *vdev;
+    struct net_device *netdev;
+    struct napi_struct napi;
+    struct net_device_stats stats;
+    unsigned int mcastFilterSize;
+    unsigned long mac_addr;
+    void * buffer_list_addr;
+    void * filter_list_addr;
+    dma_addr_t buffer_list_dma;
+    dma_addr_t filter_list_dma;
+    struct ibmveth_buff_pool rx_buff_pool[IBMVETH_NUM_BUFF_POOLS];
+    struct ibmveth_rx_q rx_queue;
+    int pool_config;
+    int rx_csum;
+    void *bounce_buffer;
+    dma_addr_t bounce_buffer_dma;
+
+    u64 fw_ipv6_csum_support;
+    u64 fw_ipv4_csum_support;
+    /* adapter specific stats */
+    u64 replenish_task_cycles;
+    u64 replenish_no_mem;
+    u64 replenish_add_buff_failure;
+    u64 replenish_add_buff_success;
+    u64 rx_invalid_buffer;
+    u64 rx_no_buffer;
+    u64 tx_map_failed;
+    u64 tx_send_failed;
+};
+
+struct ibmveth_buf_desc_fields {
+	u32 flags_len;
+#define IBMVETH_BUF_VALID	0x80000000
+#define IBMVETH_BUF_TOGGLE	0x40000000
+#define IBMVETH_BUF_NO_CSUM	0x02000000
+#define IBMVETH_BUF_CSUM_GOOD	0x01000000
+#define IBMVETH_BUF_LEN_MASK	0x00FFFFFF
+	u32 address;
+};
+
+union ibmveth_buf_desc {
+    u64 desc;
+    struct ibmveth_buf_desc_fields fields;
+};
+
+struct ibmveth_rx_q_entry {
+	u32 flags_off;
+#define IBMVETH_RXQ_TOGGLE		0x80000000
+#define IBMVETH_RXQ_TOGGLE_SHIFT	31
+#define IBMVETH_RXQ_VALID		0x40000000
+#define IBMVETH_RXQ_NO_CSUM		0x02000000
+#define IBMVETH_RXQ_CSUM_GOOD		0x01000000
+#define IBMVETH_RXQ_OFF_MASK		0x0000FFFF
+
+	u32 length;
+	u64 correlator;
+};
+
+#endif /* _IBMVETH_H */
