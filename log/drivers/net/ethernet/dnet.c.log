commit 92efe48e8fe2b6848ca56e14436c2b7d20c986d4
Author: Dejin Zheng <zhengdejin5@gmail.com>
Date:   Sun Apr 19 20:02:53 2020 +0800

    net: ethernet: dnet: convert to devm_platform_get_and_ioremap_resource
    
    use devm_platform_get_and_ioremap_resource() to simplify code, which
    contains platform_get_resource() and devm_ioremap_resource(), it also
    get the resource for use by the following code.
    
    Signed-off-by: Dejin Zheng <zhengdejin5@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index 057a508dd6e2..db98274501a0 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -776,8 +776,7 @@ static int dnet_probe(struct platform_device *pdev)
 
 	spin_lock_init(&bp->lock);
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	bp->regs = devm_ioremap_resource(&pdev->dev, res);
+	bp->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
 	if (IS_ERR(bp->regs)) {
 		err = PTR_ERR(bp->regs);
 		goto err_out_free_dev;

commit 672c88dbb69d44d6380eb2b0e5e71b4974440cfb
Author: Leon Romanovsky <leonro@mellanox.com>
Date:   Sun Mar 1 16:44:49 2020 +0200

    net/dnet: Delete static version from the driver
    
    Remove static driver version from the ethtool output.
    
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index 5f8fa1145db6..057a508dd6e2 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -729,7 +729,6 @@ static void dnet_get_drvinfo(struct net_device *dev,
 			     struct ethtool_drvinfo *info)
 {
 	strlcpy(info->driver, DRV_NAME, sizeof(info->driver));
-	strlcpy(info->version, DRV_VERSION, sizeof(info->version));
 	strlcpy(info->bus_info, "0", sizeof(info->bus_info));
 }
 

commit fd786fb1d2cad70b9aaba8c73872cbf63262bd58
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Tue Jan 21 22:09:33 2020 +0100

    net: convert suitable drivers to use phy_do_ioctl_running
    
    Convert suitable drivers to use new helper phy_do_ioctl_running.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Acked-by: Timur Tabi <timur@kernel.org>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index e24979010969..5f8fa1145db6 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -725,19 +725,6 @@ static struct net_device_stats *dnet_get_stats(struct net_device *dev)
 	return nstat;
 }
 
-static int dnet_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
-{
-	struct phy_device *phydev = dev->phydev;
-
-	if (!netif_running(dev))
-		return -EINVAL;
-
-	if (!phydev)
-		return -ENODEV;
-
-	return phy_mii_ioctl(phydev, rq, cmd);
-}
-
 static void dnet_get_drvinfo(struct net_device *dev,
 			     struct ethtool_drvinfo *info)
 {
@@ -759,7 +746,7 @@ static const struct net_device_ops dnet_netdev_ops = {
 	.ndo_stop		= dnet_close,
 	.ndo_get_stats		= dnet_get_stats,
 	.ndo_start_xmit		= dnet_start_xmit,
-	.ndo_do_ioctl		= dnet_ioctl,
+	.ndo_do_ioctl		= phy_do_ioctl_running,
 	.ndo_set_mac_address	= eth_mac_addr,
 	.ndo_validate_addr	= eth_validate_addr,
 };

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index 79521e27f0d1..e24979010969 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Dave DNET Ethernet Controller driver
  *
  * Copyright (C) 2008 Dave S.r.l. <www.dave.eu>
  * Copyright (C) 2009 Ilya Yanok, Emcraft Systems Ltd, <yanok@emcraft.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 #include <linux/io.h>
 #include <linux/module.h>

commit af8d9bb2f2f405ad541794b46f9d7bc70f13e5cb
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Sep 12 01:53:15 2018 +0200

    net: ethernet: Add helper for MACs which support asym pause
    
    Rather than have the MAC drivers manipulate phydev members to indicate
    they support Asym Pause, add a helper function.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index 08b7ad1594ce..79521e27f0d1 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -288,9 +288,7 @@ static int dnet_mii_probe(struct net_device *dev)
 	else
 		phy_set_max_speed(phydev, SPEED_100);
 
-	phydev->supported |= SUPPORTED_Asym_Pause | SUPPORTED_Pause;
-
-	phydev->advertising = phydev->supported;
+	phy_support_asym_pause(phydev);
 
 	bp->link = 0;
 	bp->speed = 0;

commit 58056c1e1b0e4951f3486bd552d8278194f8b84b
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Sep 12 01:53:11 2018 +0200

    net: ethernet: Use phy_set_max_speed() to limit advertised speed
    
    Many Ethernet MAC drivers want to limit the PHY to only advertise a
    maximum speed of 100Mbs or 1Gbps. Rather than using a mask, make use
    of the helper function phy_set_max_speed().
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index 5a847941c46b..08b7ad1594ce 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -284,9 +284,9 @@ static int dnet_mii_probe(struct net_device *dev)
 
 	/* mask with MAC supported features */
 	if (bp->capabilities & DNET_HAS_GIGABIT)
-		phydev->supported &= PHY_GBIT_FEATURES;
+		phy_set_max_speed(phydev, SPEED_1000);
 	else
-		phydev->supported &= PHY_BASIC_FEATURES;
+		phy_set_max_speed(phydev, SPEED_100);
 
 	phydev->supported |= SUPPORTED_Asym_Pause | SUPPORTED_Pause;
 

commit 4df864c1d9afb46e2461a9f808d9f11a42d31bad
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jun 16 14:29:21 2017 +0200

    networking: make skb_put & friends return void pointers
    
    It seems like a historic accident that these return unsigned char *,
    and in many places that means casts are required, more often than not.
    
    Make these functions (skb_put, __skb_put and pskb_put) return void *
    and remove all the casts across the tree, adding a (u8 *) cast only
    where the unsigned char pointer was used directly, all done with the
    following spatch:
    
        @@
        expression SKB, LEN;
        typedef u8;
        identifier fn = { skb_put, __skb_put };
        @@
        - *(fn(SKB, LEN))
        + *(u8 *)fn(SKB, LEN)
    
        @@
        expression E, SKB, LEN;
        identifier fn = { skb_put, __skb_put };
        type T;
        @@
        - E = ((T *)(fn(SKB, LEN)))
        + E = fn(SKB, LEN)
    
    which actually doesn't cover pskb_put since there are only three
    users overall.
    
    A handful of stragglers were converted manually, notably a macro in
    drivers/isdn/i4l/isdn_bsdcomp.c and, oddly enough, one of the many
    instances in net/bluetooth/hci_sock.c. In the former file, I also
    had to fix one whitespace problem spatch introduced.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index 3e77dd863175..5a847941c46b 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -399,7 +399,7 @@ static int dnet_poll(struct napi_struct *napi, int budget)
 			 * 'skb_put()' points to the start of sk_buff
 			 * data area.
 			 */
-			data_ptr = (unsigned int *)skb_put(skb, pkt_len);
+			data_ptr = skb_put(skb, pkt_len);
 			for (i = 0; i < (pkt_len + 3) >> 2; i++)
 				*data_ptr++ = dnet_readl(bp, RX_DATA_FIFO);
 			skb->protocol = eth_type_trans(skb, dev);

commit 6ad20165d376fa07919a70e4f43dfae564601829
Author: Eric Dumazet <edumazet@google.com>
Date:   Mon Jan 30 08:22:01 2017 -0800

    drivers: net: generalize napi_complete_done()
    
    napi_complete_done() allows to opt-in for gro_flush_timeout,
    added back in linux-3.19, commit 3b47d30396ba
    ("net: gro: add a per device gro flush timer")
    
    This allows for more efficient GRO aggregation without
    sacrifying latencies.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index 2a17c59f69f9..3e77dd863175 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -415,7 +415,7 @@ static int dnet_poll(struct napi_struct *napi, int budget)
 		/* We processed all packets available.  Tell NAPI it can
 		 * stop polling then re-enable rx interrupts.
 		 */
-		napi_complete(napi);
+		napi_complete_done(napi, npackets);
 		int_enable = dnet_readl(bp, INTR_ENB);
 		int_enable |= DNET_INTR_SRC_RX_CMDFIFOAF;
 		dnet_writel(bp, int_enable, INTR_ENB);

commit a52ad514fdf3b8a57ca4322c92d2d8d5c6182485
Author: Jarod Wilson <jarod@redhat.com>
Date:   Fri Oct 7 22:04:34 2016 -0400

    net: deprecate eth_change_mtu, remove usage
    
    With centralized MTU checking, there's nothing productive done by
    eth_change_mtu that isn't already done in dev_set_mtu, so mark it as
    deprecated and remove all usage of it in the kernel. All callers have been
    audited for calls to alloc_etherdev* or ether_setup directly, which means
    they all have a valid dev->min_mtu and dev->max_mtu. Now eth_change_mtu
    prints out a netdev_warn about being deprecated, for the benefit of
    out-of-tree drivers that might be utilizing it.
    
    Of note, dvb_net.c actually had dev->mtu = 4096, while using
    eth_change_mtu, meaning that if you ever tried changing it's mtu, you
    couldn't set it above 1500 anymore. It's now getting dev->max_mtu also set
    to 4096 to remedy that.
    
    v2: fix up lantiq_etop, missed breakage due to drive not compiling on x86
    
    CC: netdev@vger.kernel.org
    Signed-off-by: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index c3b64cdd0dec..2a17c59f69f9 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -767,7 +767,6 @@ static const struct net_device_ops dnet_netdev_ops = {
 	.ndo_do_ioctl		= dnet_ioctl,
 	.ndo_set_mac_address	= eth_mac_addr,
 	.ndo_validate_addr	= eth_validate_addr,
-	.ndo_change_mtu		= eth_change_mtu,
 };
 
 static int dnet_probe(struct platform_device *pdev)

commit 1ba44a1f4d8160387bdaab0f414bdbcc74f2d59b
Author: Philippe Reynes <tremyfr@gmail.com>
Date:   Thu Jun 23 23:48:59 2016 +0200

    net: ethernet: dnet: use phy_ethtool_{get|set}_link_ksettings
    
    There are two generics functions phy_ethtool_{get|set}_link_ksettings,
    so we can use them instead of defining the same code in the driver.
    
    Signed-off-by: Philippe Reynes <tremyfr@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index 9c6955f4fd79..c3b64cdd0dec 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -730,26 +730,6 @@ static struct net_device_stats *dnet_get_stats(struct net_device *dev)
 	return nstat;
 }
 
-static int dnet_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
-{
-	struct phy_device *phydev = dev->phydev;
-
-	if (!phydev)
-		return -ENODEV;
-
-	return phy_ethtool_gset(phydev, cmd);
-}
-
-static int dnet_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
-{
-	struct phy_device *phydev = dev->phydev;
-
-	if (!phydev)
-		return -ENODEV;
-
-	return phy_ethtool_sset(phydev, cmd);
-}
-
 static int dnet_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	struct phy_device *phydev = dev->phydev;
@@ -772,11 +752,11 @@ static void dnet_get_drvinfo(struct net_device *dev,
 }
 
 static const struct ethtool_ops dnet_ethtool_ops = {
-	.get_settings		= dnet_get_settings,
-	.set_settings		= dnet_set_settings,
 	.get_drvinfo		= dnet_get_drvinfo,
 	.get_link		= ethtool_op_get_link,
 	.get_ts_info		= ethtool_op_get_ts_info,
+	.get_link_ksettings     = phy_ethtool_get_link_ksettings,
+	.set_link_ksettings     = phy_ethtool_set_link_ksettings,
 };
 
 static const struct net_device_ops dnet_netdev_ops = {

commit 958974fdaf7fcd26fcfcf409e3e61fdc3ab4020c
Author: Philippe Reynes <tremyfr@gmail.com>
Date:   Thu Jun 23 23:48:58 2016 +0200

    net: ethernet: dnet: use phydev from struct net_device
    
    The private structure contain a pointer to phydev, but the structure
    net_device already contain such pointer. So we can remove the pointer
    phydev in the private structure, and update the driver to use the
    one contained in struct net_device.
    
    Signed-off-by: Philippe Reynes <tremyfr@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index b69a9eacc531..9c6955f4fd79 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -173,7 +173,7 @@ static int dnet_mdio_write(struct mii_bus *bus, int mii_id, int regnum,
 static void dnet_handle_link_change(struct net_device *dev)
 {
 	struct dnet *bp = netdev_priv(dev);
-	struct phy_device *phydev = bp->phy_dev;
+	struct phy_device *phydev = dev->phydev;
 	unsigned long flags;
 	u32 mode_reg, ctl_reg;
 
@@ -295,7 +295,6 @@ static int dnet_mii_probe(struct net_device *dev)
 	bp->link = 0;
 	bp->speed = 0;
 	bp->duplex = -1;
-	bp->phy_dev = phydev;
 
 	return 0;
 }
@@ -629,16 +628,16 @@ static int dnet_open(struct net_device *dev)
 	struct dnet *bp = netdev_priv(dev);
 
 	/* if the phy is not yet register, retry later */
-	if (!bp->phy_dev)
+	if (!dev->phydev)
 		return -EAGAIN;
 
 	napi_enable(&bp->napi);
 	dnet_init_hw(bp);
 
-	phy_start_aneg(bp->phy_dev);
+	phy_start_aneg(dev->phydev);
 
 	/* schedule a link state check */
-	phy_start(bp->phy_dev);
+	phy_start(dev->phydev);
 
 	netif_start_queue(dev);
 
@@ -652,8 +651,8 @@ static int dnet_close(struct net_device *dev)
 	netif_stop_queue(dev);
 	napi_disable(&bp->napi);
 
-	if (bp->phy_dev)
-		phy_stop(bp->phy_dev);
+	if (dev->phydev)
+		phy_stop(dev->phydev);
 
 	dnet_reset_hw(bp);
 	netif_carrier_off(dev);
@@ -733,8 +732,7 @@ static struct net_device_stats *dnet_get_stats(struct net_device *dev)
 
 static int dnet_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 {
-	struct dnet *bp = netdev_priv(dev);
-	struct phy_device *phydev = bp->phy_dev;
+	struct phy_device *phydev = dev->phydev;
 
 	if (!phydev)
 		return -ENODEV;
@@ -744,8 +742,7 @@ static int dnet_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 
 static int dnet_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 {
-	struct dnet *bp = netdev_priv(dev);
-	struct phy_device *phydev = bp->phy_dev;
+	struct phy_device *phydev = dev->phydev;
 
 	if (!phydev)
 		return -ENODEV;
@@ -755,8 +752,7 @@ static int dnet_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 
 static int dnet_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
-	struct dnet *bp = netdev_priv(dev);
-	struct phy_device *phydev = bp->phy_dev;
+	struct phy_device *phydev = dev->phydev;
 
 	if (!netif_running(dev))
 		return -EINVAL;
@@ -875,7 +871,7 @@ static int dnet_probe(struct platform_device *pdev)
 	       (bp->capabilities & DNET_HAS_IRQ) ? "" : "no ",
 	       (bp->capabilities & DNET_HAS_GIGABIT) ? "" : "no ",
 	       (bp->capabilities & DNET_HAS_DMA) ? "" : "no ");
-	phydev = bp->phy_dev;
+	phydev = dev->phydev;
 	phy_attached_info(phydev);
 
 	return 0;
@@ -899,8 +895,8 @@ static int dnet_remove(struct platform_device *pdev)
 
 	if (dev) {
 		bp = netdev_priv(dev);
-		if (bp->phy_dev)
-			phy_disconnect(bp->phy_dev);
+		if (dev->phydev)
+			phy_disconnect(dev->phydev);
 		mdiobus_unregister(bp->mii_bus);
 		mdiobus_free(bp->mii_bus);
 		unregister_netdev(dev);

commit e7f4dc3536a40097f95103ddf98dd55b3a980f5b
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Jan 6 20:11:15 2016 +0100

    mdio: Move allocation of interrupts into core
    
    Have mdio_alloc() create the array of interrupt numbers, and
    initialize it to POLLING. This is what most MDIO drivers want, so
    allowing code to be removed from the drivers.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index 6557460cf028..b69a9eacc531 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -302,7 +302,7 @@ static int dnet_mii_probe(struct net_device *dev)
 
 static int dnet_mii_init(struct dnet *bp)
 {
-	int err, i;
+	int err;
 
 	bp->mii_bus = mdiobus_alloc();
 	if (bp->mii_bus == NULL)
@@ -317,16 +317,6 @@ static int dnet_mii_init(struct dnet *bp)
 
 	bp->mii_bus->priv = bp;
 
-	bp->mii_bus->irq = devm_kmalloc(&bp->pdev->dev,
-					sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);
-	if (!bp->mii_bus->irq) {
-		err = -ENOMEM;
-		goto err_out;
-	}
-
-	for (i = 0; i < PHY_MAX_ADDR; i++)
-		bp->mii_bus->irq[i] = PHY_POLL;
-
 	if (mdiobus_register(bp->mii_bus)) {
 		err = -ENXIO;
 		goto err_out;

commit 2220943a21e26d97d7fd8f83c004b947326b469d
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Jan 6 20:11:13 2016 +0100

    phy: Centralise print about attached phy
    
    Many Ethernet drivers contain the same netdev_info() print statement
    about the attached phy. Move it into the phy device code. Additionally
    add a varargs function which can be used to append additional
    information.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index 0ec367521354..6557460cf028 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -886,9 +886,7 @@ static int dnet_probe(struct platform_device *pdev)
 	       (bp->capabilities & DNET_HAS_GIGABIT) ? "" : "no ",
 	       (bp->capabilities & DNET_HAS_DMA) ? "" : "no ");
 	phydev = bp->phy_dev;
-	dev_info(&pdev->dev, "attached PHY driver [%s] "
-	       "(mii_bus:phy_addr=%s, irq=%d)\n",
-	       phydev->drv->name, phydev_name(phydev), phydev->irq);
+	phy_attached_info(phydev);
 
 	return 0;
 

commit 04521bf840482af30a6ed54835cefadcecdd56da
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Jan 6 20:11:11 2016 +0100

    net: dnet: Use phy_find_first() helper
    
    Replace the open coded search for the first phy with a call to the
    existing helper function.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index 136b6010f704..0ec367521354 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -255,15 +255,9 @@ static int dnet_mii_probe(struct net_device *dev)
 {
 	struct dnet *bp = netdev_priv(dev);
 	struct phy_device *phydev = NULL;
-	int phy_addr;
 
 	/* find the first phy */
-	for (phy_addr = 0; phy_addr < PHY_MAX_ADDR; phy_addr++) {
-		if (bp->mii_bus->phy_map[phy_addr]) {
-			phydev = bp->mii_bus->phy_map[phy_addr];
-			break;
-		}
-	}
+	phydev = phy_find_first(bp->mii_bus);
 
 	if (!phydev) {
 		printk(KERN_ERR "%s: no PHY found\n", dev->name);

commit 84eff6d194df442bee62c129f2f47efb0dbd0468
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Jan 6 20:11:10 2016 +0100

    phy: add phydev_name() wrapper
    
    Add a phydev_name() function, to help with moving some structure members
    from phy_device.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index 13d00a38a5bd..136b6010f704 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -274,11 +274,11 @@ static int dnet_mii_probe(struct net_device *dev)
 
 	/* attach the mac to the phy */
 	if (bp->capabilities & DNET_HAS_RMII) {
-		phydev = phy_connect(dev, dev_name(&phydev->dev),
+		phydev = phy_connect(dev, phydev_name(phydev),
 				     &dnet_handle_link_change,
 				     PHY_INTERFACE_MODE_RMII);
 	} else {
-		phydev = phy_connect(dev, dev_name(&phydev->dev),
+		phydev = phy_connect(dev, phydev_name(phydev),
 				     &dnet_handle_link_change,
 				     PHY_INTERFACE_MODE_MII);
 	}
@@ -894,7 +894,7 @@ static int dnet_probe(struct platform_device *pdev)
 	phydev = bp->phy_dev;
 	dev_info(&pdev->dev, "attached PHY driver [%s] "
 	       "(mii_bus:phy_addr=%s, irq=%d)\n",
-	       phydev->drv->name, dev_name(&phydev->dev), phydev->irq);
+	       phydev->drv->name, phydev_name(phydev), phydev->irq);
 
 	return 0;
 

commit 12d80ac4e77265a89b87c3b80e2c9a7b29f7fdfb
Author: Eric Dumazet <edumazet@google.com>
Date:   Sun Jan 11 11:02:32 2015 -0800

    net: dnet: fix dnet_poll()
    
    A NAPI poll() handler is supposed to return exactly the budget when/if
    napi_complete() has not been called.
    
    It is also supposed to return number of frames that were received, so
    that netdev_budget can have a meaning.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index a379c3e4b57f..13d00a38a5bd 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -398,13 +398,8 @@ static int dnet_poll(struct napi_struct *napi, int budget)
 		 * break out of while loop if there are no more
 		 * packets waiting
 		 */
-		if (!(dnet_readl(bp, RX_FIFO_WCNT) >> 16)) {
-			napi_complete(napi);
-			int_enable = dnet_readl(bp, INTR_ENB);
-			int_enable |= DNET_INTR_SRC_RX_CMDFIFOAF;
-			dnet_writel(bp, int_enable, INTR_ENB);
-			return 0;
-		}
+		if (!(dnet_readl(bp, RX_FIFO_WCNT) >> 16))
+			break;
 
 		cmd_word = dnet_readl(bp, RX_LEN_FIFO);
 		pkt_len = cmd_word & 0xFFFF;
@@ -433,20 +428,17 @@ static int dnet_poll(struct napi_struct *napi, int budget)
 			       "size %u.\n", dev->name, pkt_len);
 	}
 
-	budget -= npackets;
-
 	if (npackets < budget) {
 		/* We processed all packets available.  Tell NAPI it can
-		 * stop polling then re-enable rx interrupts */
+		 * stop polling then re-enable rx interrupts.
+		 */
 		napi_complete(napi);
 		int_enable = dnet_readl(bp, INTR_ENB);
 		int_enable |= DNET_INTR_SRC_RX_CMDFIFOAF;
 		dnet_writel(bp, int_enable, INTR_ENB);
-		return 0;
 	}
 
-	/* There are still packets waiting */
-	return 1;
+	return npackets;
 }
 
 static irqreturn_t dnet_interrupt(int irq, void *dev_id)

commit ae29223eaf0ecf4c701457a6b40d7b8f19c90413
Author: Himangi Saraogi <himangi774@gmail.com>
Date:   Fri Aug 1 21:00:03 2014 +0530

    net: dnet: Use managed interfaces
    
    This patch introduces the use of managed interfaces like
    devm_ioremap_resource and does away with the calls to free the
    allocated memory in the probe and remove functions. Also, some
    labels and variable are done away with. This fixes a bug as there
    was a missing release_mem_region in the remove function.
    
    Signed-off-by: Himangi Saraogi <himangi774@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index e9b0faba3078..a379c3e4b57f 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -323,7 +323,8 @@ static int dnet_mii_init(struct dnet *bp)
 
 	bp->mii_bus->priv = bp;
 
-	bp->mii_bus->irq = kmalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);
+	bp->mii_bus->irq = devm_kmalloc(&bp->pdev->dev,
+					sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);
 	if (!bp->mii_bus->irq) {
 		err = -ENOMEM;
 		goto err_out;
@@ -334,7 +335,7 @@ static int dnet_mii_init(struct dnet *bp)
 
 	if (mdiobus_register(bp->mii_bus)) {
 		err = -ENXIO;
-		goto err_out_free_mdio_irq;
+		goto err_out;
 	}
 
 	if (dnet_mii_probe(bp->dev) != 0) {
@@ -346,8 +347,6 @@ static int dnet_mii_init(struct dnet *bp)
 
 err_out_unregister_bus:
 	mdiobus_unregister(bp->mii_bus);
-err_out_free_mdio_irq:
-	kfree(bp->mii_bus->irq);
 err_out:
 	mdiobus_free(bp->mii_bus);
 	return err;
@@ -825,28 +824,14 @@ static int dnet_probe(struct platform_device *pdev)
 	struct net_device *dev;
 	struct dnet *bp;
 	struct phy_device *phydev;
-	int err = -ENXIO;
-	unsigned int mem_base, mem_size, irq;
+	int err;
+	unsigned int irq;
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(&pdev->dev, "no mmio resource defined\n");
-		goto err_out;
-	}
-	mem_base = res->start;
-	mem_size = resource_size(res);
 	irq = platform_get_irq(pdev, 0);
 
-	if (!request_mem_region(mem_base, mem_size, DRV_NAME)) {
-		dev_err(&pdev->dev, "no memory region available\n");
-		err = -EBUSY;
-		goto err_out;
-	}
-
-	err = -ENOMEM;
 	dev = alloc_etherdev(sizeof(*bp));
 	if (!dev)
-		goto err_out_release_mem;
+		return -ENOMEM;
 
 	/* TODO: Actually, we have some interesting features... */
 	dev->features |= 0;
@@ -859,10 +844,10 @@ static int dnet_probe(struct platform_device *pdev)
 
 	spin_lock_init(&bp->lock);
 
-	bp->regs = ioremap(mem_base, mem_size);
-	if (!bp->regs) {
-		dev_err(&pdev->dev, "failed to map registers, aborting.\n");
-		err = -ENOMEM;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	bp->regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(bp->regs)) {
+		err = PTR_ERR(bp->regs);
 		goto err_out_free_dev;
 	}
 
@@ -871,7 +856,7 @@ static int dnet_probe(struct platform_device *pdev)
 	if (err) {
 		dev_err(&pdev->dev, "Unable to request IRQ %d (error %d)\n",
 		       irq, err);
-		goto err_out_iounmap;
+		goto err_out_free_dev;
 	}
 
 	dev->netdev_ops = &dnet_netdev_ops;
@@ -908,7 +893,7 @@ static int dnet_probe(struct platform_device *pdev)
 		goto err_out_unregister_netdev;
 
 	dev_info(&pdev->dev, "Dave DNET at 0x%p (0x%08x) irq %d %pM\n",
-	       bp->regs, mem_base, dev->irq, dev->dev_addr);
+	       bp->regs, (unsigned int)res->start, dev->irq, dev->dev_addr);
 	dev_info(&pdev->dev, "has %smdio, %sirq, %sgigabit, %sdma\n",
 	       (bp->capabilities & DNET_HAS_MDIO) ? "" : "no ",
 	       (bp->capabilities & DNET_HAS_IRQ) ? "" : "no ",
@@ -925,13 +910,8 @@ static int dnet_probe(struct platform_device *pdev)
 	unregister_netdev(dev);
 err_out_free_irq:
 	free_irq(dev->irq, dev);
-err_out_iounmap:
-	iounmap(bp->regs);
 err_out_free_dev:
 	free_netdev(dev);
-err_out_release_mem:
-	release_mem_region(mem_base, mem_size);
-err_out:
 	return err;
 }
 
@@ -948,11 +928,9 @@ static int dnet_remove(struct platform_device *pdev)
 		if (bp->phy_dev)
 			phy_disconnect(bp->phy_dev);
 		mdiobus_unregister(bp->mii_bus);
-		kfree(bp->mii_bus->irq);
 		mdiobus_free(bp->mii_bus);
 		unregister_netdev(dev);
 		free_irq(dev->irq, dev);
-		iounmap(bp->regs);
 		free_netdev(dev);
 	}
 

commit 89e158f909253d8c7c2a65d1b2cbac2f07a28ed0
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Wed Mar 26 18:07:16 2014 -0700

    dnet: remove empty MDIO bus reset function
    
    dnet_mdio_reset() does nothing useful and is optional for the MDIO bus
    code, so let's just remove it.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index 8a79a32a5674..e9b0faba3078 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -170,11 +170,6 @@ static int dnet_mdio_write(struct mii_bus *bus, int mii_id, int regnum,
 	return 0;
 }
 
-static int dnet_mdio_reset(struct mii_bus *bus)
-{
-	return 0;
-}
-
 static void dnet_handle_link_change(struct net_device *dev)
 {
 	struct dnet *bp = netdev_priv(dev);
@@ -322,7 +317,6 @@ static int dnet_mii_init(struct dnet *bp)
 	bp->mii_bus->name = "dnet_mii_bus";
 	bp->mii_bus->read = &dnet_mdio_read;
 	bp->mii_bus->write = &dnet_mdio_write;
-	bp->mii_bus->reset = &dnet_mdio_reset;
 
 	snprintf(bp->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",
 		bp->pdev->name, bp->pdev->id);

commit a81ab36bf52d0ca3a32251a923be1dbced726141
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Jan 8 15:32:47 2014 -0500

    drivers/net: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.   Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    This covers everything under drivers/net except for wireless, which
    has been submitted separately.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index f3d60eb13c3a..8a79a32a5674 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -15,7 +15,6 @@
 #include <linux/types.h>
 #include <linux/slab.h>
 #include <linux/delay.h>
-#include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>

commit f9a8f83b04e0c362a2fc660dbad980d24af209fc
Author: Florian Fainelli <florian@openwrt.org>
Date:   Mon Jan 14 00:52:52 2013 +0000

    net: phy: remove flags argument from phy_{attach, connect, connect_direct}
    
    The flags argument of the phy_{attach,connect,connect_direct} functions
    is then used to assign a struct phy_device dev_flags with its value.
    All callers but the tg3 driver pass the flag 0, which results in the
    underlying PHY drivers in drivers/net/phy/ not being able to actually
    use any of the flags they would set in dev_flags. This patch gets rid of
    the flags argument, and passes phydev->dev_flags to the internal PHY
    library call phy_attach_direct() such that drivers which actually modify
    a phy device dev_flags get the value preserved for use by the underlying
    phy driver.
    
    Acked-by: Kosta Zertsekel <konszert@marvell.com>
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index 2c177b329c8b..f3d60eb13c3a 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -281,11 +281,11 @@ static int dnet_mii_probe(struct net_device *dev)
 	/* attach the mac to the phy */
 	if (bp->capabilities & DNET_HAS_RMII) {
 		phydev = phy_connect(dev, dev_name(&phydev->dev),
-				     &dnet_handle_link_change, 0,
+				     &dnet_handle_link_change,
 				     PHY_INTERFACE_MODE_RMII);
 	} else {
 		phydev = phy_connect(dev, dev_name(&phydev->dev),
-				     &dnet_handle_link_change, 0,
+				     &dnet_handle_link_change,
 				     PHY_INTERFACE_MODE_MII);
 	}
 

commit a0a4efedf9dea0f2dd9625181b48c1f8c6d5418e
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Dec 3 09:24:09 2012 -0500

    net/ethernet: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index feb5095d81b7..2c177b329c8b 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -72,7 +72,7 @@ static void __dnet_set_hwaddr(struct dnet *bp)
 	dnet_writew_mac(bp, DNET_INTERNAL_MAC_ADDR_2_REG, tmp);
 }
 
-static void __devinit dnet_get_hwaddr(struct dnet *bp)
+static void dnet_get_hwaddr(struct dnet *bp)
 {
 	u16 tmp;
 	u8 addr[6];
@@ -826,7 +826,7 @@ static const struct net_device_ops dnet_netdev_ops = {
 	.ndo_change_mtu		= eth_change_mtu,
 };
 
-static int __devinit dnet_probe(struct platform_device *pdev)
+static int dnet_probe(struct platform_device *pdev)
 {
 	struct resource *res;
 	struct net_device *dev;
@@ -942,7 +942,7 @@ static int __devinit dnet_probe(struct platform_device *pdev)
 	return err;
 }
 
-static int __devexit dnet_remove(struct platform_device *pdev)
+static int dnet_remove(struct platform_device *pdev)
 {
 
 	struct net_device *dev;
@@ -968,7 +968,7 @@ static int __devexit dnet_remove(struct platform_device *pdev)
 
 static struct platform_driver dnet_driver = {
 	.probe		= dnet_probe,
-	.remove		= __devexit_p(dnet_remove),
+	.remove		= dnet_remove,
 	.driver		= {
 		.name		= "dnet",
 	},

commit c867b55eb4831a493631205f2744b2e77ce0983b
Author: Joachim Eastwood <manabian@gmail.com>
Date:   Fri Nov 16 04:47:15 2012 +0000

    net/ethernet: remove useless is_valid_ether_addr from drivers ndo_open
    
    If ndo_validate_addr is set to the generic eth_validate_addr
    function there is no point in calling is_valid_ether_addr
    from driver ndo_open if ndo_open is not used elsewhere in
    the driver.
    
    With this change is_valid_ether_addr will be called from the
    generic eth_validate_addr function. So there should be no change
    in the actual behavior.
    
    Signed-off-by: Joachim Eastwood <manabian@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index 290b26f868c9..feb5095d81b7 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -664,9 +664,6 @@ static int dnet_open(struct net_device *dev)
 	if (!bp->phy_dev)
 		return -EAGAIN;
 
-	if (!is_valid_ether_addr(dev->dev_addr))
-		return -EADDRNOTAVAIL;
-
 	napi_enable(&bp->napi);
 	dnet_init_hw(bp);
 

commit eb774cbeae027d1060cb71a235bb085df8eb2874
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Tue Apr 3 22:59:25 2012 +0000

    dnet: Support the get_ts_info ethtool method.
    
    Signed-off-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index b276469f74e9..290b26f868c9 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -815,6 +815,7 @@ static const struct ethtool_ops dnet_ethtool_ops = {
 	.set_settings		= dnet_set_settings,
 	.get_drvinfo		= dnet_get_drvinfo,
 	.get_link		= ethtool_op_get_link,
+	.get_ts_info		= ethtool_op_get_ts_info,
 };
 
 static const struct net_device_ops dnet_netdev_ops = {

commit f2cedb63df14342ad40a8b5b324fc5d94a60b665
Author: Danny Kukawka <danny.kukawka@bisect.de>
Date:   Wed Feb 15 06:45:39 2012 +0000

    net: replace random_ether_addr() with eth_hw_addr_random()
    
    Replace usage of random_ether_addr() with eth_hw_addr_random()
    to set addr_assign_type correctly to NET_ADDR_RANDOM.
    
    Change the trivial cases.
    
    v2: adapt to renamed eth_hw_addr_random()
    
    Signed-off-by: Danny Kukawka <danny.kukawka@bisect.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index 8536e376555a..b276469f74e9 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -895,7 +895,7 @@ static int __devinit dnet_probe(struct platform_device *pdev)
 
 	if (!is_valid_ether_addr(dev->dev_addr)) {
 		/* choose a random ethernet address */
-		random_ether_addr(dev->dev_addr);
+		eth_hw_addr_random(dev);
 		__dnet_set_hwaddr(bp);
 	}
 

commit 21a4e46995fa1a76281ac0281ff837f706231a37
Author: Pradeep A Dalvi <netdev@pradeepdalvi.com>
Date:   Sun Feb 5 02:50:10 2012 +0000

    netdev: ethernet dev_alloc_skb to netdev_alloc_skb
    
    Replaced deprecating dev_alloc_skb with netdev_alloc_skb in drivers/net/ethernet
      - Removed extra skb->dev = dev after netdev_alloc_skb
    
    Signed-off-by: Pradeep A Dalvi <netdev@pradeepdalvi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index fe48cb7dde21..8536e376555a 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -421,7 +421,7 @@ static int dnet_poll(struct napi_struct *napi, int budget)
 			printk(KERN_ERR "%s packet receive error %x\n",
 			       __func__, cmd_word);
 
-		skb = dev_alloc_skb(pkt_len + 5);
+		skb = netdev_alloc_skb(dev, pkt_len + 5);
 		if (skb != NULL) {
 			/* Align IP on 16 byte boundaries */
 			skb_reserve(skb, 2);

commit 41de8d4cff21a2e81e3d9ff66f5f7c903f9c3ab1
Author: Joe Perches <joe@perches.com>
Date:   Sun Jan 29 13:47:52 2012 +0000

    drivers/net: Remove alloc_etherdev error messages
    
    alloc_etherdev has a generic OOM/unable to alloc message.
    Remove the duplicative messages after alloc_etherdev calls.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index 925c9bafc9b9..fe48cb7dde21 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -854,10 +854,8 @@ static int __devinit dnet_probe(struct platform_device *pdev)
 
 	err = -ENOMEM;
 	dev = alloc_etherdev(sizeof(*bp));
-	if (!dev) {
-		dev_err(&pdev->dev, "etherdev alloc failed, aborting.\n");
+	if (!dev)
 		goto err_out_release_mem;
-	}
 
 	/* TODO: Actually, we have some interesting features... */
 	dev->features |= 0;

commit 63f678301fb952c2d758d9ded4ed88c1da6c0c50
Author: Florian Fainelli <florian@openwrt.org>
Date:   Mon Jan 9 23:59:12 2012 +0000

    dnet: use an unique MDIO bus name.
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index ce88c0f399f6..925c9bafc9b9 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -325,7 +325,8 @@ static int dnet_mii_init(struct dnet *bp)
 	bp->mii_bus->write = &dnet_mdio_write;
 	bp->mii_bus->reset = &dnet_mdio_reset;
 
-	snprintf(bp->mii_bus->id, MII_BUS_ID_SIZE, "%x", 0);
+	snprintf(bp->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",
+		bp->pdev->name, bp->pdev->id);
 
 	bp->mii_bus->priv = bp;
 

commit db62f684deeb291ab2533b99843d5df9a36b1f19
Author: Axel Lin <axel.lin@gmail.com>
Date:   Sun Nov 27 16:44:17 2011 +0000

    net/ethernet: convert drivers/net/ethernet/* to use module_platform_driver()
    
    This patch converts the drivers in drivers/net/ethernet/* to use the
    module_platform_driver() macro which makes the code smaller and a bit
    simpler.
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Pantelis Antoniou <pantelis.antoniou@gmail.com>
    Cc: Vitaly Bordug <vbordug@ru.mvista.com>
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Cc: Nicolas Pitre <nico@fluxnic.net>
    Cc: Giuseppe Cavallaro <peppe.cavallaro@st.com>
    Cc: Marc Kleine-Budde <mkl@pengutronix.de>
    Cc: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Cc: Jiri Pirko <jpirko@redhat.com>
    Cc: Daniel Hellstrom <daniel@gaisler.com>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Tobias Klauser <tklauser@distanz.ch>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Richard Cochran <richard.cochran@omicron.at>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Sebastian Poehn <sebastian.poehn@belden.com>
    Cc: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Cc: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Cc: "Michał Mirosław" <mirq-linux@rere.qmqm.pl>
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Acked-by: Wan ZongShun <mcuos.com@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index d94b9686b80c..ce88c0f399f6 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -977,18 +977,7 @@ static struct platform_driver dnet_driver = {
 	},
 };
 
-static int __init dnet_init(void)
-{
-	return platform_driver_register(&dnet_driver);
-}
-
-static void __exit dnet_exit(void)
-{
-	platform_driver_unregister(&dnet_driver);
-}
-
-module_init(dnet_init);
-module_exit(dnet_exit);
+module_platform_driver(dnet_driver);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Dave DNET Ethernet driver");

commit 68aad78c5023b8aa82da99b47f9d8cf40e8ca453
Author: Rick Jones <rick.jones2@hp.com>
Date:   Mon Nov 7 13:29:27 2011 +0000

    sweep the floors and convert some .get_drvinfo routines to strlcpy
    
    Per the mention made by Ben Hutchings that strlcpy is now the preferred
    string copy routine for a .get_drvinfo routine, do a bit of floor
    sweeping and convert some of the as-yet unconverted ethernet drivers to
    it.
    
    Signed-off-by: Rick Jones <rick.jones2@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index c1063d1540c2..d94b9686b80c 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -804,9 +804,9 @@ static int dnet_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 static void dnet_get_drvinfo(struct net_device *dev,
 			     struct ethtool_drvinfo *info)
 {
-	strcpy(info->driver, DRV_NAME);
-	strcpy(info->version, DRV_VERSION);
-	strcpy(info->bus_info, "0");
+	strlcpy(info->driver, DRV_NAME, sizeof(info->driver));
+	strlcpy(info->version, DRV_VERSION, sizeof(info->version));
+	strlcpy(info->bus_info, "0", sizeof(info->bus_info));
 }
 
 static const struct ethtool_ops dnet_ethtool_ops = {

commit 9c8571da0a85e4491d1d5bda088b534087e29497
Author: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Date:   Sun Jul 24 14:01:17 2011 -0700

    dnet: Move the Dave Ethernet driver
    
    Move the Dave Ethernet driver into drivers/net/ethernet/ and
    make the necessary Kconfig and Makefile changes.
    
    CC: Ilya Yanok <yanok@emcraft.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
new file mode 100644
index 000000000000..c1063d1540c2
--- /dev/null
+++ b/drivers/net/ethernet/dnet.c
@@ -0,0 +1,996 @@
+/*
+ * Dave DNET Ethernet Controller driver
+ *
+ * Copyright (C) 2008 Dave S.r.l. <www.dave.eu>
+ * Copyright (C) 2009 Ilya Yanok, Emcraft Systems Ltd, <yanok@emcraft.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/phy.h>
+
+#include "dnet.h"
+
+#undef DEBUG
+
+/* function for reading internal MAC register */
+static u16 dnet_readw_mac(struct dnet *bp, u16 reg)
+{
+	u16 data_read;
+
+	/* issue a read */
+	dnet_writel(bp, reg, MACREG_ADDR);
+
+	/* since a read/write op to the MAC is very slow,
+	 * we must wait before reading the data */
+	ndelay(500);
+
+	/* read data read from the MAC register */
+	data_read = dnet_readl(bp, MACREG_DATA);
+
+	/* all done */
+	return data_read;
+}
+
+/* function for writing internal MAC register */
+static void dnet_writew_mac(struct dnet *bp, u16 reg, u16 val)
+{
+	/* load data to write */
+	dnet_writel(bp, val, MACREG_DATA);
+
+	/* issue a write */
+	dnet_writel(bp, reg | DNET_INTERNAL_WRITE, MACREG_ADDR);
+
+	/* since a read/write op to the MAC is very slow,
+	 * we must wait before exiting */
+	ndelay(500);
+}
+
+static void __dnet_set_hwaddr(struct dnet *bp)
+{
+	u16 tmp;
+
+	tmp = be16_to_cpup((__be16 *)bp->dev->dev_addr);
+	dnet_writew_mac(bp, DNET_INTERNAL_MAC_ADDR_0_REG, tmp);
+	tmp = be16_to_cpup((__be16 *)(bp->dev->dev_addr + 2));
+	dnet_writew_mac(bp, DNET_INTERNAL_MAC_ADDR_1_REG, tmp);
+	tmp = be16_to_cpup((__be16 *)(bp->dev->dev_addr + 4));
+	dnet_writew_mac(bp, DNET_INTERNAL_MAC_ADDR_2_REG, tmp);
+}
+
+static void __devinit dnet_get_hwaddr(struct dnet *bp)
+{
+	u16 tmp;
+	u8 addr[6];
+
+	/*
+	 * from MAC docs:
+	 * "Note that the MAC address is stored in the registers in Hexadecimal
+	 * form. For example, to set the MAC Address to: AC-DE-48-00-00-80
+	 * would require writing 0xAC (octet 0) to address 0x0B (high byte of
+	 * Mac_addr[15:0]), 0xDE (octet 1) to address 0x0A (Low byte of
+	 * Mac_addr[15:0]), 0x48 (octet 2) to address 0x0D (high byte of
+	 * Mac_addr[15:0]), 0x00 (octet 3) to address 0x0C (Low byte of
+	 * Mac_addr[15:0]), 0x00 (octet 4) to address 0x0F (high byte of
+	 * Mac_addr[15:0]), and 0x80 (octet 5) to address * 0x0E (Low byte of
+	 * Mac_addr[15:0]).
+	 */
+	tmp = dnet_readw_mac(bp, DNET_INTERNAL_MAC_ADDR_0_REG);
+	*((__be16 *)addr) = cpu_to_be16(tmp);
+	tmp = dnet_readw_mac(bp, DNET_INTERNAL_MAC_ADDR_1_REG);
+	*((__be16 *)(addr + 2)) = cpu_to_be16(tmp);
+	tmp = dnet_readw_mac(bp, DNET_INTERNAL_MAC_ADDR_2_REG);
+	*((__be16 *)(addr + 4)) = cpu_to_be16(tmp);
+
+	if (is_valid_ether_addr(addr))
+		memcpy(bp->dev->dev_addr, addr, sizeof(addr));
+}
+
+static int dnet_mdio_read(struct mii_bus *bus, int mii_id, int regnum)
+{
+	struct dnet *bp = bus->priv;
+	u16 value;
+
+	while (!(dnet_readw_mac(bp, DNET_INTERNAL_GMII_MNG_CTL_REG)
+				& DNET_INTERNAL_GMII_MNG_CMD_FIN))
+		cpu_relax();
+
+	/* only 5 bits allowed for phy-addr and reg_offset */
+	mii_id &= 0x1f;
+	regnum &= 0x1f;
+
+	/* prepare reg_value for a read */
+	value = (mii_id << 8);
+	value |= regnum;
+
+	/* write control word */
+	dnet_writew_mac(bp, DNET_INTERNAL_GMII_MNG_CTL_REG, value);
+
+	/* wait for end of transfer */
+	while (!(dnet_readw_mac(bp, DNET_INTERNAL_GMII_MNG_CTL_REG)
+				& DNET_INTERNAL_GMII_MNG_CMD_FIN))
+		cpu_relax();
+
+	value = dnet_readw_mac(bp, DNET_INTERNAL_GMII_MNG_DAT_REG);
+
+	pr_debug("mdio_read %02x:%02x <- %04x\n", mii_id, regnum, value);
+
+	return value;
+}
+
+static int dnet_mdio_write(struct mii_bus *bus, int mii_id, int regnum,
+			   u16 value)
+{
+	struct dnet *bp = bus->priv;
+	u16 tmp;
+
+	pr_debug("mdio_write %02x:%02x <- %04x\n", mii_id, regnum, value);
+
+	while (!(dnet_readw_mac(bp, DNET_INTERNAL_GMII_MNG_CTL_REG)
+				& DNET_INTERNAL_GMII_MNG_CMD_FIN))
+		cpu_relax();
+
+	/* prepare for a write operation */
+	tmp = (1 << 13);
+
+	/* only 5 bits allowed for phy-addr and reg_offset */
+	mii_id &= 0x1f;
+	regnum &= 0x1f;
+
+	/* only 16 bits on data */
+	value &= 0xffff;
+
+	/* prepare reg_value for a write */
+	tmp |= (mii_id << 8);
+	tmp |= regnum;
+
+	/* write data to write first */
+	dnet_writew_mac(bp, DNET_INTERNAL_GMII_MNG_DAT_REG, value);
+
+	/* write control word */
+	dnet_writew_mac(bp, DNET_INTERNAL_GMII_MNG_CTL_REG, tmp);
+
+	while (!(dnet_readw_mac(bp, DNET_INTERNAL_GMII_MNG_CTL_REG)
+				& DNET_INTERNAL_GMII_MNG_CMD_FIN))
+		cpu_relax();
+
+	return 0;
+}
+
+static int dnet_mdio_reset(struct mii_bus *bus)
+{
+	return 0;
+}
+
+static void dnet_handle_link_change(struct net_device *dev)
+{
+	struct dnet *bp = netdev_priv(dev);
+	struct phy_device *phydev = bp->phy_dev;
+	unsigned long flags;
+	u32 mode_reg, ctl_reg;
+
+	int status_change = 0;
+
+	spin_lock_irqsave(&bp->lock, flags);
+
+	mode_reg = dnet_readw_mac(bp, DNET_INTERNAL_MODE_REG);
+	ctl_reg = dnet_readw_mac(bp, DNET_INTERNAL_RXTX_CONTROL_REG);
+
+	if (phydev->link) {
+		if (bp->duplex != phydev->duplex) {
+			if (phydev->duplex)
+				ctl_reg &=
+				    ~(DNET_INTERNAL_RXTX_CONTROL_ENABLEHALFDUP);
+			else
+				ctl_reg |=
+				    DNET_INTERNAL_RXTX_CONTROL_ENABLEHALFDUP;
+
+			bp->duplex = phydev->duplex;
+			status_change = 1;
+		}
+
+		if (bp->speed != phydev->speed) {
+			status_change = 1;
+			switch (phydev->speed) {
+			case 1000:
+				mode_reg |= DNET_INTERNAL_MODE_GBITEN;
+				break;
+			case 100:
+			case 10:
+				mode_reg &= ~DNET_INTERNAL_MODE_GBITEN;
+				break;
+			default:
+				printk(KERN_WARNING
+				       "%s: Ack!  Speed (%d) is not "
+				       "10/100/1000!\n", dev->name,
+				       phydev->speed);
+				break;
+			}
+			bp->speed = phydev->speed;
+		}
+	}
+
+	if (phydev->link != bp->link) {
+		if (phydev->link) {
+			mode_reg |=
+			    (DNET_INTERNAL_MODE_RXEN | DNET_INTERNAL_MODE_TXEN);
+		} else {
+			mode_reg &=
+			    ~(DNET_INTERNAL_MODE_RXEN |
+			      DNET_INTERNAL_MODE_TXEN);
+			bp->speed = 0;
+			bp->duplex = -1;
+		}
+		bp->link = phydev->link;
+
+		status_change = 1;
+	}
+
+	if (status_change) {
+		dnet_writew_mac(bp, DNET_INTERNAL_RXTX_CONTROL_REG, ctl_reg);
+		dnet_writew_mac(bp, DNET_INTERNAL_MODE_REG, mode_reg);
+	}
+
+	spin_unlock_irqrestore(&bp->lock, flags);
+
+	if (status_change) {
+		if (phydev->link)
+			printk(KERN_INFO "%s: link up (%d/%s)\n",
+			       dev->name, phydev->speed,
+			       DUPLEX_FULL == phydev->duplex ? "Full" : "Half");
+		else
+			printk(KERN_INFO "%s: link down\n", dev->name);
+	}
+}
+
+static int dnet_mii_probe(struct net_device *dev)
+{
+	struct dnet *bp = netdev_priv(dev);
+	struct phy_device *phydev = NULL;
+	int phy_addr;
+
+	/* find the first phy */
+	for (phy_addr = 0; phy_addr < PHY_MAX_ADDR; phy_addr++) {
+		if (bp->mii_bus->phy_map[phy_addr]) {
+			phydev = bp->mii_bus->phy_map[phy_addr];
+			break;
+		}
+	}
+
+	if (!phydev) {
+		printk(KERN_ERR "%s: no PHY found\n", dev->name);
+		return -ENODEV;
+	}
+
+	/* TODO : add pin_irq */
+
+	/* attach the mac to the phy */
+	if (bp->capabilities & DNET_HAS_RMII) {
+		phydev = phy_connect(dev, dev_name(&phydev->dev),
+				     &dnet_handle_link_change, 0,
+				     PHY_INTERFACE_MODE_RMII);
+	} else {
+		phydev = phy_connect(dev, dev_name(&phydev->dev),
+				     &dnet_handle_link_change, 0,
+				     PHY_INTERFACE_MODE_MII);
+	}
+
+	if (IS_ERR(phydev)) {
+		printk(KERN_ERR "%s: Could not attach to PHY\n", dev->name);
+		return PTR_ERR(phydev);
+	}
+
+	/* mask with MAC supported features */
+	if (bp->capabilities & DNET_HAS_GIGABIT)
+		phydev->supported &= PHY_GBIT_FEATURES;
+	else
+		phydev->supported &= PHY_BASIC_FEATURES;
+
+	phydev->supported |= SUPPORTED_Asym_Pause | SUPPORTED_Pause;
+
+	phydev->advertising = phydev->supported;
+
+	bp->link = 0;
+	bp->speed = 0;
+	bp->duplex = -1;
+	bp->phy_dev = phydev;
+
+	return 0;
+}
+
+static int dnet_mii_init(struct dnet *bp)
+{
+	int err, i;
+
+	bp->mii_bus = mdiobus_alloc();
+	if (bp->mii_bus == NULL)
+		return -ENOMEM;
+
+	bp->mii_bus->name = "dnet_mii_bus";
+	bp->mii_bus->read = &dnet_mdio_read;
+	bp->mii_bus->write = &dnet_mdio_write;
+	bp->mii_bus->reset = &dnet_mdio_reset;
+
+	snprintf(bp->mii_bus->id, MII_BUS_ID_SIZE, "%x", 0);
+
+	bp->mii_bus->priv = bp;
+
+	bp->mii_bus->irq = kmalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);
+	if (!bp->mii_bus->irq) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	for (i = 0; i < PHY_MAX_ADDR; i++)
+		bp->mii_bus->irq[i] = PHY_POLL;
+
+	if (mdiobus_register(bp->mii_bus)) {
+		err = -ENXIO;
+		goto err_out_free_mdio_irq;
+	}
+
+	if (dnet_mii_probe(bp->dev) != 0) {
+		err = -ENXIO;
+		goto err_out_unregister_bus;
+	}
+
+	return 0;
+
+err_out_unregister_bus:
+	mdiobus_unregister(bp->mii_bus);
+err_out_free_mdio_irq:
+	kfree(bp->mii_bus->irq);
+err_out:
+	mdiobus_free(bp->mii_bus);
+	return err;
+}
+
+/* For Neptune board: LINK1000 as Link LED and TX as activity LED */
+static int dnet_phy_marvell_fixup(struct phy_device *phydev)
+{
+	return phy_write(phydev, 0x18, 0x4148);
+}
+
+static void dnet_update_stats(struct dnet *bp)
+{
+	u32 __iomem *reg = bp->regs + DNET_RX_PKT_IGNR_CNT;
+	u32 *p = &bp->hw_stats.rx_pkt_ignr;
+	u32 *end = &bp->hw_stats.rx_byte + 1;
+
+	WARN_ON((unsigned long)(end - p - 1) !=
+		(DNET_RX_BYTE_CNT - DNET_RX_PKT_IGNR_CNT) / 4);
+
+	for (; p < end; p++, reg++)
+		*p += readl(reg);
+
+	reg = bp->regs + DNET_TX_UNICAST_CNT;
+	p = &bp->hw_stats.tx_unicast;
+	end = &bp->hw_stats.tx_byte + 1;
+
+	WARN_ON((unsigned long)(end - p - 1) !=
+		(DNET_TX_BYTE_CNT - DNET_TX_UNICAST_CNT) / 4);
+
+	for (; p < end; p++, reg++)
+		*p += readl(reg);
+}
+
+static int dnet_poll(struct napi_struct *napi, int budget)
+{
+	struct dnet *bp = container_of(napi, struct dnet, napi);
+	struct net_device *dev = bp->dev;
+	int npackets = 0;
+	unsigned int pkt_len;
+	struct sk_buff *skb;
+	unsigned int *data_ptr;
+	u32 int_enable;
+	u32 cmd_word;
+	int i;
+
+	while (npackets < budget) {
+		/*
+		 * break out of while loop if there are no more
+		 * packets waiting
+		 */
+		if (!(dnet_readl(bp, RX_FIFO_WCNT) >> 16)) {
+			napi_complete(napi);
+			int_enable = dnet_readl(bp, INTR_ENB);
+			int_enable |= DNET_INTR_SRC_RX_CMDFIFOAF;
+			dnet_writel(bp, int_enable, INTR_ENB);
+			return 0;
+		}
+
+		cmd_word = dnet_readl(bp, RX_LEN_FIFO);
+		pkt_len = cmd_word & 0xFFFF;
+
+		if (cmd_word & 0xDF180000)
+			printk(KERN_ERR "%s packet receive error %x\n",
+			       __func__, cmd_word);
+
+		skb = dev_alloc_skb(pkt_len + 5);
+		if (skb != NULL) {
+			/* Align IP on 16 byte boundaries */
+			skb_reserve(skb, 2);
+			/*
+			 * 'skb_put()' points to the start of sk_buff
+			 * data area.
+			 */
+			data_ptr = (unsigned int *)skb_put(skb, pkt_len);
+			for (i = 0; i < (pkt_len + 3) >> 2; i++)
+				*data_ptr++ = dnet_readl(bp, RX_DATA_FIFO);
+			skb->protocol = eth_type_trans(skb, dev);
+			netif_receive_skb(skb);
+			npackets++;
+		} else
+			printk(KERN_NOTICE
+			       "%s: No memory to allocate a sk_buff of "
+			       "size %u.\n", dev->name, pkt_len);
+	}
+
+	budget -= npackets;
+
+	if (npackets < budget) {
+		/* We processed all packets available.  Tell NAPI it can
+		 * stop polling then re-enable rx interrupts */
+		napi_complete(napi);
+		int_enable = dnet_readl(bp, INTR_ENB);
+		int_enable |= DNET_INTR_SRC_RX_CMDFIFOAF;
+		dnet_writel(bp, int_enable, INTR_ENB);
+		return 0;
+	}
+
+	/* There are still packets waiting */
+	return 1;
+}
+
+static irqreturn_t dnet_interrupt(int irq, void *dev_id)
+{
+	struct net_device *dev = dev_id;
+	struct dnet *bp = netdev_priv(dev);
+	u32 int_src, int_enable, int_current;
+	unsigned long flags;
+	unsigned int handled = 0;
+
+	spin_lock_irqsave(&bp->lock, flags);
+
+	/* read and clear the DNET irq (clear on read) */
+	int_src = dnet_readl(bp, INTR_SRC);
+	int_enable = dnet_readl(bp, INTR_ENB);
+	int_current = int_src & int_enable;
+
+	/* restart the queue if we had stopped it for TX fifo almost full */
+	if (int_current & DNET_INTR_SRC_TX_FIFOAE) {
+		int_enable = dnet_readl(bp, INTR_ENB);
+		int_enable &= ~DNET_INTR_ENB_TX_FIFOAE;
+		dnet_writel(bp, int_enable, INTR_ENB);
+		netif_wake_queue(dev);
+		handled = 1;
+	}
+
+	/* RX FIFO error checking */
+	if (int_current &
+	    (DNET_INTR_SRC_RX_CMDFIFOFF | DNET_INTR_SRC_RX_DATAFIFOFF)) {
+		printk(KERN_ERR "%s: RX fifo error %x, irq %x\n", __func__,
+		       dnet_readl(bp, RX_STATUS), int_current);
+		/* we can only flush the RX FIFOs */
+		dnet_writel(bp, DNET_SYS_CTL_RXFIFOFLUSH, SYS_CTL);
+		ndelay(500);
+		dnet_writel(bp, 0, SYS_CTL);
+		handled = 1;
+	}
+
+	/* TX FIFO error checking */
+	if (int_current &
+	    (DNET_INTR_SRC_TX_FIFOFULL | DNET_INTR_SRC_TX_DISCFRM)) {
+		printk(KERN_ERR "%s: TX fifo error %x, irq %x\n", __func__,
+		       dnet_readl(bp, TX_STATUS), int_current);
+		/* we can only flush the TX FIFOs */
+		dnet_writel(bp, DNET_SYS_CTL_TXFIFOFLUSH, SYS_CTL);
+		ndelay(500);
+		dnet_writel(bp, 0, SYS_CTL);
+		handled = 1;
+	}
+
+	if (int_current & DNET_INTR_SRC_RX_CMDFIFOAF) {
+		if (napi_schedule_prep(&bp->napi)) {
+			/*
+			 * There's no point taking any more interrupts
+			 * until we have processed the buffers
+			 */
+			/* Disable Rx interrupts and schedule NAPI poll */
+			int_enable = dnet_readl(bp, INTR_ENB);
+			int_enable &= ~DNET_INTR_SRC_RX_CMDFIFOAF;
+			dnet_writel(bp, int_enable, INTR_ENB);
+			__napi_schedule(&bp->napi);
+		}
+		handled = 1;
+	}
+
+	if (!handled)
+		pr_debug("%s: irq %x remains\n", __func__, int_current);
+
+	spin_unlock_irqrestore(&bp->lock, flags);
+
+	return IRQ_RETVAL(handled);
+}
+
+#ifdef DEBUG
+static inline void dnet_print_skb(struct sk_buff *skb)
+{
+	int k;
+	printk(KERN_DEBUG PFX "data:");
+	for (k = 0; k < skb->len; k++)
+		printk(" %02x", (unsigned int)skb->data[k]);
+	printk("\n");
+}
+#else
+#define dnet_print_skb(skb)	do {} while (0)
+#endif
+
+static netdev_tx_t dnet_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+
+	struct dnet *bp = netdev_priv(dev);
+	u32 tx_status, irq_enable;
+	unsigned int len, i, tx_cmd, wrsz;
+	unsigned long flags;
+	unsigned int *bufp;
+
+	tx_status = dnet_readl(bp, TX_STATUS);
+
+	pr_debug("start_xmit: len %u head %p data %p\n",
+	       skb->len, skb->head, skb->data);
+	dnet_print_skb(skb);
+
+	/* frame size (words) */
+	len = (skb->len + 3) >> 2;
+
+	spin_lock_irqsave(&bp->lock, flags);
+
+	tx_status = dnet_readl(bp, TX_STATUS);
+
+	bufp = (unsigned int *)(((unsigned long) skb->data) & ~0x3UL);
+	wrsz = (u32) skb->len + 3;
+	wrsz += ((unsigned long) skb->data) & 0x3;
+	wrsz >>= 2;
+	tx_cmd = ((((unsigned long)(skb->data)) & 0x03) << 16) | (u32) skb->len;
+
+	/* check if there is enough room for the current frame */
+	if (wrsz < (DNET_FIFO_SIZE - dnet_readl(bp, TX_FIFO_WCNT))) {
+		for (i = 0; i < wrsz; i++)
+			dnet_writel(bp, *bufp++, TX_DATA_FIFO);
+
+		/*
+		 * inform MAC that a packet's written and ready to be
+		 * shipped out
+		 */
+		dnet_writel(bp, tx_cmd, TX_LEN_FIFO);
+	}
+
+	if (dnet_readl(bp, TX_FIFO_WCNT) > DNET_FIFO_TX_DATA_AF_TH) {
+		netif_stop_queue(dev);
+		tx_status = dnet_readl(bp, INTR_SRC);
+		irq_enable = dnet_readl(bp, INTR_ENB);
+		irq_enable |= DNET_INTR_ENB_TX_FIFOAE;
+		dnet_writel(bp, irq_enable, INTR_ENB);
+	}
+
+	skb_tx_timestamp(skb);
+
+	/* free the buffer */
+	dev_kfree_skb(skb);
+
+	spin_unlock_irqrestore(&bp->lock, flags);
+
+	return NETDEV_TX_OK;
+}
+
+static void dnet_reset_hw(struct dnet *bp)
+{
+	/* put ts_mac in IDLE state i.e. disable rx/tx */
+	dnet_writew_mac(bp, DNET_INTERNAL_MODE_REG, DNET_INTERNAL_MODE_FCEN);
+
+	/*
+	 * RX FIFO almost full threshold: only cmd FIFO almost full is
+	 * implemented for RX side
+	 */
+	dnet_writel(bp, DNET_FIFO_RX_CMD_AF_TH, RX_FIFO_TH);
+	/*
+	 * TX FIFO almost empty threshold: only data FIFO almost empty
+	 * is implemented for TX side
+	 */
+	dnet_writel(bp, DNET_FIFO_TX_DATA_AE_TH, TX_FIFO_TH);
+
+	/* flush rx/tx fifos */
+	dnet_writel(bp, DNET_SYS_CTL_RXFIFOFLUSH | DNET_SYS_CTL_TXFIFOFLUSH,
+			SYS_CTL);
+	msleep(1);
+	dnet_writel(bp, 0, SYS_CTL);
+}
+
+static void dnet_init_hw(struct dnet *bp)
+{
+	u32 config;
+
+	dnet_reset_hw(bp);
+	__dnet_set_hwaddr(bp);
+
+	config = dnet_readw_mac(bp, DNET_INTERNAL_RXTX_CONTROL_REG);
+
+	if (bp->dev->flags & IFF_PROMISC)
+		/* Copy All Frames */
+		config |= DNET_INTERNAL_RXTX_CONTROL_ENPROMISC;
+	if (!(bp->dev->flags & IFF_BROADCAST))
+		/* No BroadCast */
+		config |= DNET_INTERNAL_RXTX_CONTROL_RXMULTICAST;
+
+	config |= DNET_INTERNAL_RXTX_CONTROL_RXPAUSE |
+	    DNET_INTERNAL_RXTX_CONTROL_RXBROADCAST |
+	    DNET_INTERNAL_RXTX_CONTROL_DROPCONTROL |
+	    DNET_INTERNAL_RXTX_CONTROL_DISCFXFCS;
+
+	dnet_writew_mac(bp, DNET_INTERNAL_RXTX_CONTROL_REG, config);
+
+	/* clear irq before enabling them */
+	config = dnet_readl(bp, INTR_SRC);
+
+	/* enable RX/TX interrupt, recv packet ready interrupt */
+	dnet_writel(bp, DNET_INTR_ENB_GLOBAL_ENABLE | DNET_INTR_ENB_RX_SUMMARY |
+			DNET_INTR_ENB_TX_SUMMARY | DNET_INTR_ENB_RX_FIFOERR |
+			DNET_INTR_ENB_RX_ERROR | DNET_INTR_ENB_RX_FIFOFULL |
+			DNET_INTR_ENB_TX_FIFOFULL | DNET_INTR_ENB_TX_DISCFRM |
+			DNET_INTR_ENB_RX_PKTRDY, INTR_ENB);
+}
+
+static int dnet_open(struct net_device *dev)
+{
+	struct dnet *bp = netdev_priv(dev);
+
+	/* if the phy is not yet register, retry later */
+	if (!bp->phy_dev)
+		return -EAGAIN;
+
+	if (!is_valid_ether_addr(dev->dev_addr))
+		return -EADDRNOTAVAIL;
+
+	napi_enable(&bp->napi);
+	dnet_init_hw(bp);
+
+	phy_start_aneg(bp->phy_dev);
+
+	/* schedule a link state check */
+	phy_start(bp->phy_dev);
+
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+static int dnet_close(struct net_device *dev)
+{
+	struct dnet *bp = netdev_priv(dev);
+
+	netif_stop_queue(dev);
+	napi_disable(&bp->napi);
+
+	if (bp->phy_dev)
+		phy_stop(bp->phy_dev);
+
+	dnet_reset_hw(bp);
+	netif_carrier_off(dev);
+
+	return 0;
+}
+
+static inline void dnet_print_pretty_hwstats(struct dnet_stats *hwstat)
+{
+	pr_debug("%s\n", __func__);
+	pr_debug("----------------------------- RX statistics "
+		 "-------------------------------\n");
+	pr_debug("RX_PKT_IGNR_CNT %-8x\n", hwstat->rx_pkt_ignr);
+	pr_debug("RX_LEN_CHK_ERR_CNT %-8x\n", hwstat->rx_len_chk_err);
+	pr_debug("RX_LNG_FRM_CNT %-8x\n", hwstat->rx_lng_frm);
+	pr_debug("RX_SHRT_FRM_CNT %-8x\n", hwstat->rx_shrt_frm);
+	pr_debug("RX_IPG_VIOL_CNT %-8x\n", hwstat->rx_ipg_viol);
+	pr_debug("RX_CRC_ERR_CNT %-8x\n", hwstat->rx_crc_err);
+	pr_debug("RX_OK_PKT_CNT %-8x\n", hwstat->rx_ok_pkt);
+	pr_debug("RX_CTL_FRM_CNT %-8x\n", hwstat->rx_ctl_frm);
+	pr_debug("RX_PAUSE_FRM_CNT %-8x\n", hwstat->rx_pause_frm);
+	pr_debug("RX_MULTICAST_CNT %-8x\n", hwstat->rx_multicast);
+	pr_debug("RX_BROADCAST_CNT %-8x\n", hwstat->rx_broadcast);
+	pr_debug("RX_VLAN_TAG_CNT %-8x\n", hwstat->rx_vlan_tag);
+	pr_debug("RX_PRE_SHRINK_CNT %-8x\n", hwstat->rx_pre_shrink);
+	pr_debug("RX_DRIB_NIB_CNT %-8x\n", hwstat->rx_drib_nib);
+	pr_debug("RX_UNSUP_OPCD_CNT %-8x\n", hwstat->rx_unsup_opcd);
+	pr_debug("RX_BYTE_CNT %-8x\n", hwstat->rx_byte);
+	pr_debug("----------------------------- TX statistics "
+		 "-------------------------------\n");
+	pr_debug("TX_UNICAST_CNT %-8x\n", hwstat->tx_unicast);
+	pr_debug("TX_PAUSE_FRM_CNT %-8x\n", hwstat->tx_pause_frm);
+	pr_debug("TX_MULTICAST_CNT %-8x\n", hwstat->tx_multicast);
+	pr_debug("TX_BRDCAST_CNT %-8x\n", hwstat->tx_brdcast);
+	pr_debug("TX_VLAN_TAG_CNT %-8x\n", hwstat->tx_vlan_tag);
+	pr_debug("TX_BAD_FCS_CNT %-8x\n", hwstat->tx_bad_fcs);
+	pr_debug("TX_JUMBO_CNT %-8x\n", hwstat->tx_jumbo);
+	pr_debug("TX_BYTE_CNT %-8x\n", hwstat->tx_byte);
+}
+
+static struct net_device_stats *dnet_get_stats(struct net_device *dev)
+{
+
+	struct dnet *bp = netdev_priv(dev);
+	struct net_device_stats *nstat = &dev->stats;
+	struct dnet_stats *hwstat = &bp->hw_stats;
+
+	/* read stats from hardware */
+	dnet_update_stats(bp);
+
+	/* Convert HW stats into netdevice stats */
+	nstat->rx_errors = (hwstat->rx_len_chk_err +
+			    hwstat->rx_lng_frm + hwstat->rx_shrt_frm +
+			    /* ignore IGP violation error
+			    hwstat->rx_ipg_viol + */
+			    hwstat->rx_crc_err +
+			    hwstat->rx_pre_shrink +
+			    hwstat->rx_drib_nib + hwstat->rx_unsup_opcd);
+	nstat->tx_errors = hwstat->tx_bad_fcs;
+	nstat->rx_length_errors = (hwstat->rx_len_chk_err +
+				   hwstat->rx_lng_frm +
+				   hwstat->rx_shrt_frm + hwstat->rx_pre_shrink);
+	nstat->rx_crc_errors = hwstat->rx_crc_err;
+	nstat->rx_frame_errors = hwstat->rx_pre_shrink + hwstat->rx_drib_nib;
+	nstat->rx_packets = hwstat->rx_ok_pkt;
+	nstat->tx_packets = (hwstat->tx_unicast +
+			     hwstat->tx_multicast + hwstat->tx_brdcast);
+	nstat->rx_bytes = hwstat->rx_byte;
+	nstat->tx_bytes = hwstat->tx_byte;
+	nstat->multicast = hwstat->rx_multicast;
+	nstat->rx_missed_errors = hwstat->rx_pkt_ignr;
+
+	dnet_print_pretty_hwstats(hwstat);
+
+	return nstat;
+}
+
+static int dnet_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct dnet *bp = netdev_priv(dev);
+	struct phy_device *phydev = bp->phy_dev;
+
+	if (!phydev)
+		return -ENODEV;
+
+	return phy_ethtool_gset(phydev, cmd);
+}
+
+static int dnet_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct dnet *bp = netdev_priv(dev);
+	struct phy_device *phydev = bp->phy_dev;
+
+	if (!phydev)
+		return -ENODEV;
+
+	return phy_ethtool_sset(phydev, cmd);
+}
+
+static int dnet_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct dnet *bp = netdev_priv(dev);
+	struct phy_device *phydev = bp->phy_dev;
+
+	if (!netif_running(dev))
+		return -EINVAL;
+
+	if (!phydev)
+		return -ENODEV;
+
+	return phy_mii_ioctl(phydev, rq, cmd);
+}
+
+static void dnet_get_drvinfo(struct net_device *dev,
+			     struct ethtool_drvinfo *info)
+{
+	strcpy(info->driver, DRV_NAME);
+	strcpy(info->version, DRV_VERSION);
+	strcpy(info->bus_info, "0");
+}
+
+static const struct ethtool_ops dnet_ethtool_ops = {
+	.get_settings		= dnet_get_settings,
+	.set_settings		= dnet_set_settings,
+	.get_drvinfo		= dnet_get_drvinfo,
+	.get_link		= ethtool_op_get_link,
+};
+
+static const struct net_device_ops dnet_netdev_ops = {
+	.ndo_open		= dnet_open,
+	.ndo_stop		= dnet_close,
+	.ndo_get_stats		= dnet_get_stats,
+	.ndo_start_xmit		= dnet_start_xmit,
+	.ndo_do_ioctl		= dnet_ioctl,
+	.ndo_set_mac_address	= eth_mac_addr,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+};
+
+static int __devinit dnet_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct net_device *dev;
+	struct dnet *bp;
+	struct phy_device *phydev;
+	int err = -ENXIO;
+	unsigned int mem_base, mem_size, irq;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "no mmio resource defined\n");
+		goto err_out;
+	}
+	mem_base = res->start;
+	mem_size = resource_size(res);
+	irq = platform_get_irq(pdev, 0);
+
+	if (!request_mem_region(mem_base, mem_size, DRV_NAME)) {
+		dev_err(&pdev->dev, "no memory region available\n");
+		err = -EBUSY;
+		goto err_out;
+	}
+
+	err = -ENOMEM;
+	dev = alloc_etherdev(sizeof(*bp));
+	if (!dev) {
+		dev_err(&pdev->dev, "etherdev alloc failed, aborting.\n");
+		goto err_out_release_mem;
+	}
+
+	/* TODO: Actually, we have some interesting features... */
+	dev->features |= 0;
+
+	bp = netdev_priv(dev);
+	bp->dev = dev;
+
+	platform_set_drvdata(pdev, dev);
+	SET_NETDEV_DEV(dev, &pdev->dev);
+
+	spin_lock_init(&bp->lock);
+
+	bp->regs = ioremap(mem_base, mem_size);
+	if (!bp->regs) {
+		dev_err(&pdev->dev, "failed to map registers, aborting.\n");
+		err = -ENOMEM;
+		goto err_out_free_dev;
+	}
+
+	dev->irq = irq;
+	err = request_irq(dev->irq, dnet_interrupt, 0, DRV_NAME, dev);
+	if (err) {
+		dev_err(&pdev->dev, "Unable to request IRQ %d (error %d)\n",
+		       irq, err);
+		goto err_out_iounmap;
+	}
+
+	dev->netdev_ops = &dnet_netdev_ops;
+	netif_napi_add(dev, &bp->napi, dnet_poll, 64);
+	dev->ethtool_ops = &dnet_ethtool_ops;
+
+	dev->base_addr = (unsigned long)bp->regs;
+
+	bp->capabilities = dnet_readl(bp, VERCAPS) & DNET_CAPS_MASK;
+
+	dnet_get_hwaddr(bp);
+
+	if (!is_valid_ether_addr(dev->dev_addr)) {
+		/* choose a random ethernet address */
+		random_ether_addr(dev->dev_addr);
+		__dnet_set_hwaddr(bp);
+	}
+
+	err = register_netdev(dev);
+	if (err) {
+		dev_err(&pdev->dev, "Cannot register net device, aborting.\n");
+		goto err_out_free_irq;
+	}
+
+	/* register the PHY board fixup (for Marvell 88E1111) */
+	err = phy_register_fixup_for_uid(0x01410cc0, 0xfffffff0,
+					 dnet_phy_marvell_fixup);
+	/* we can live without it, so just issue a warning */
+	if (err)
+		dev_warn(&pdev->dev, "Cannot register PHY board fixup.\n");
+
+	err = dnet_mii_init(bp);
+	if (err)
+		goto err_out_unregister_netdev;
+
+	dev_info(&pdev->dev, "Dave DNET at 0x%p (0x%08x) irq %d %pM\n",
+	       bp->regs, mem_base, dev->irq, dev->dev_addr);
+	dev_info(&pdev->dev, "has %smdio, %sirq, %sgigabit, %sdma\n",
+	       (bp->capabilities & DNET_HAS_MDIO) ? "" : "no ",
+	       (bp->capabilities & DNET_HAS_IRQ) ? "" : "no ",
+	       (bp->capabilities & DNET_HAS_GIGABIT) ? "" : "no ",
+	       (bp->capabilities & DNET_HAS_DMA) ? "" : "no ");
+	phydev = bp->phy_dev;
+	dev_info(&pdev->dev, "attached PHY driver [%s] "
+	       "(mii_bus:phy_addr=%s, irq=%d)\n",
+	       phydev->drv->name, dev_name(&phydev->dev), phydev->irq);
+
+	return 0;
+
+err_out_unregister_netdev:
+	unregister_netdev(dev);
+err_out_free_irq:
+	free_irq(dev->irq, dev);
+err_out_iounmap:
+	iounmap(bp->regs);
+err_out_free_dev:
+	free_netdev(dev);
+err_out_release_mem:
+	release_mem_region(mem_base, mem_size);
+err_out:
+	return err;
+}
+
+static int __devexit dnet_remove(struct platform_device *pdev)
+{
+
+	struct net_device *dev;
+	struct dnet *bp;
+
+	dev = platform_get_drvdata(pdev);
+
+	if (dev) {
+		bp = netdev_priv(dev);
+		if (bp->phy_dev)
+			phy_disconnect(bp->phy_dev);
+		mdiobus_unregister(bp->mii_bus);
+		kfree(bp->mii_bus->irq);
+		mdiobus_free(bp->mii_bus);
+		unregister_netdev(dev);
+		free_irq(dev->irq, dev);
+		iounmap(bp->regs);
+		free_netdev(dev);
+	}
+
+	return 0;
+}
+
+static struct platform_driver dnet_driver = {
+	.probe		= dnet_probe,
+	.remove		= __devexit_p(dnet_remove),
+	.driver		= {
+		.name		= "dnet",
+	},
+};
+
+static int __init dnet_init(void)
+{
+	return platform_driver_register(&dnet_driver);
+}
+
+static void __exit dnet_exit(void)
+{
+	platform_driver_unregister(&dnet_driver);
+}
+
+module_init(dnet_init);
+module_exit(dnet_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Dave DNET Ethernet driver");
+MODULE_AUTHOR("Ilya Yanok <yanok@emcraft.com>, "
+	      "Matteo Vit <matteo.vit@dave.eu>");
