commit bf5a6b4c474c589244dc25ee1af2c3c829228ef8
Author: Salil Mehta <salil.mehta@huawei.com>
Date:   Thu Nov 7 17:09:53 2019 +0000

    net: hns: Fix the stray netpoll locks causing deadlock in NAPI path
    
    This patch fixes the problem of the spin locks, originally
    meant for the netpoll path of hns driver, causing deadlock in
    the normal NAPI poll path. The issue happened due to the presence
    of the stray leftover spin lock code related to the netpoll,
    whose support was earlier removed from the HNS[1], got activated
    due to enabling of NET_POLL_CONTROLLER switch.
    
    Earlier background:
    The netpoll handling code originally had this bug(as identified
    by Marc Zyngier[2]) of wrong spin lock API being used which did
    not disable the interrupts and hence could cause locking issues.
    i.e. if the lock were first acquired in context to thread like
    'ip' util and this lock if ever got later acquired again in
    context to the interrupt context like TX/RX (Interrupts could
    always pre-empt the lock holding task and acquire the lock again)
    and hence could cause deadlock.
    
    Proposed Solution:
    1. If the netpoll was enabled in the HNS driver, which is not
       right now, we could have simply used spin_[un]lock_irqsave()
    2. But as netpoll is disabled, therefore, it is best to get rid
       of the existing locks and stray code for now. This should
       solve the problem reported by Marc.
    
    [1] https://git.kernel.org/torvalds/c/4bd2c03be7
    [2] https://patchwork.ozlabs.org/patch/1189139/
    
    Fixes: 4bd2c03be707 ("net: hns: remove ndo_poll_controller")
    Cc: lipeng <lipeng321@huawei.com>
    Cc: Yisen Zhuang <yisen.zhuang@huawei.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: David S. Miller <davem@davemloft.net>
    Reported-by: Marc Zyngier <maz@kernel.org>
    Acked-by: Marc Zyngier <maz@kernel.org>
    Tested-by: Marc Zyngier <maz@kernel.org>
    Signed-off-by: Salil Mehta <salil.mehta@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/hisilicon/hns/hnae.c b/drivers/net/ethernet/hisilicon/hns/hnae.c
index 6d0457eb4faa..08339278c722 100644
--- a/drivers/net/ethernet/hisilicon/hns/hnae.c
+++ b/drivers/net/ethernet/hisilicon/hns/hnae.c
@@ -199,7 +199,6 @@ hnae_init_ring(struct hnae_queue *q, struct hnae_ring *ring, int flags)
 
 	ring->q = q;
 	ring->flags = flags;
-	spin_lock_init(&ring->lock);
 	ring->coal_param = q->handle->coal_param;
 	assert(!ring->desc && !ring->desc_cb && !ring->desc_dma_addr);
 

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/ethernet/hisilicon/hns/hnae.c b/drivers/net/ethernet/hisilicon/hns/hnae.c
index c7fa97a7e1f4..6d0457eb4faa 100644
--- a/drivers/net/ethernet/hisilicon/hns/hnae.c
+++ b/drivers/net/ethernet/hisilicon/hns/hnae.c
@@ -1,10 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2014-2015 Hisilicon Limited.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
  */
 
 #include <linux/dma-mapping.h>

commit 8601a99d7c0256b7a7fdd1ab14cf6c1f1dfcadc6
Author: Yonglong Liu <liuyonglong@huawei.com>
Date:   Thu Apr 4 16:46:46 2019 +0800

    net: hns: Fix WARNING when remove HNS driver with SMMU enabled
    
    When enable SMMU, remove HNS driver will cause a WARNING:
    
    [  141.924177] WARNING: CPU: 36 PID: 2708 at drivers/iommu/dma-iommu.c:443 __iommu_dma_unmap+0xc0/0xc8
    [  141.954673] Modules linked in: hns_enet_drv(-)
    [  141.963615] CPU: 36 PID: 2708 Comm: rmmod Tainted: G        W         5.0.0-rc1-28723-gb729c57de95c-dirty #32
    [  141.983593] Hardware name: Huawei D05/D05, BIOS Hisilicon D05 UEFI Nemo 1.8 RC0 08/31/2017
    [  142.000244] pstate: 60000005 (nZCv daif -PAN -UAO)
    [  142.009886] pc : __iommu_dma_unmap+0xc0/0xc8
    [  142.018476] lr : __iommu_dma_unmap+0xc0/0xc8
    [  142.027066] sp : ffff000013533b90
    [  142.033728] x29: ffff000013533b90 x28: ffff8013e6983600
    [  142.044420] x27: 0000000000000000 x26: 0000000000000000
    [  142.055113] x25: 0000000056000000 x24: 0000000000000015
    [  142.065806] x23: 0000000000000028 x22: ffff8013e66eee68
    [  142.076499] x21: ffff8013db919800 x20: 0000ffffefbff000
    [  142.087192] x19: 0000000000001000 x18: 0000000000000007
    [  142.097885] x17: 000000000000000e x16: 0000000000000001
    [  142.108578] x15: 0000000000000019 x14: 363139343a70616d
    [  142.119270] x13: 6e75656761705f67 x12: 0000000000000000
    [  142.129963] x11: 00000000ffffffff x10: 0000000000000006
    [  142.140656] x9 : 1346c1aa88093500 x8 : ffff0000114de4e0
    [  142.151349] x7 : 6662666578303d72 x6 : ffff0000105ffec8
    [  142.162042] x5 : 0000000000000000 x4 : 0000000000000000
    [  142.172734] x3 : 00000000ffffffff x2 : ffff0000114de500
    [  142.183427] x1 : 0000000000000000 x0 : 0000000000000035
    [  142.194120] Call trace:
    [  142.199030]  __iommu_dma_unmap+0xc0/0xc8
    [  142.206920]  iommu_dma_unmap_page+0x20/0x28
    [  142.215335]  __iommu_unmap_page+0x40/0x60
    [  142.223399]  hnae_unmap_buffer+0x110/0x134
    [  142.231639]  hnae_free_desc+0x6c/0x10c
    [  142.239177]  hnae_fini_ring+0x14/0x34
    [  142.246540]  hnae_fini_queue+0x2c/0x40
    [  142.254080]  hnae_put_handle+0x38/0xcc
    [  142.261619]  hns_nic_dev_remove+0x54/0xfc [hns_enet_drv]
    [  142.272312]  platform_drv_remove+0x24/0x64
    [  142.280552]  device_release_driver_internal+0x17c/0x20c
    [  142.291070]  driver_detach+0x4c/0x90
    [  142.298259]  bus_remove_driver+0x5c/0xd8
    [  142.306148]  driver_unregister+0x2c/0x54
    [  142.314037]  platform_driver_unregister+0x10/0x18
    [  142.323505]  hns_nic_dev_driver_exit+0x14/0xf0c [hns_enet_drv]
    [  142.335248]  __arm64_sys_delete_module+0x214/0x25c
    [  142.344891]  el0_svc_common+0xb0/0x10c
    [  142.352430]  el0_svc_handler+0x24/0x80
    [  142.359968]  el0_svc+0x8/0x7c0
    [  142.366104] ---[ end trace 60ad1cd58e63c407 ]---
    
    The tx ring buffer map when xmit and unmap when xmit done. So in
    hnae_init_ring() did not map tx ring buffer, but in hnae_fini_ring()
    have a unmap operation for tx ring buffer, which is already unmapped
    when xmit done, than cause this WARNING.
    
    The hnae_alloc_buffers() is called in hnae_init_ring(),
    so the hnae_free_buffers() should be in hnae_fini_ring(), not in
    hnae_free_desc().
    
    In hnae_fini_ring(), adds a check is_rx_ring() as in hnae_init_ring().
    When the ring buffer is tx ring, adds a piece of code to ensure that
    the tx ring is unmap.
    
    Signed-off-by: Yonglong Liu <liuyonglong@huawei.com>
    Signed-off-by: Peng Li <lipeng321@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/hisilicon/hns/hnae.c b/drivers/net/ethernet/hisilicon/hns/hnae.c
index 79d03f8ee7b1..c7fa97a7e1f4 100644
--- a/drivers/net/ethernet/hisilicon/hns/hnae.c
+++ b/drivers/net/ethernet/hisilicon/hns/hnae.c
@@ -150,7 +150,6 @@ static int hnae_alloc_buffers(struct hnae_ring *ring)
 /* free desc along with its attached buffer */
 static void hnae_free_desc(struct hnae_ring *ring)
 {
-	hnae_free_buffers(ring);
 	dma_unmap_single(ring_to_dev(ring), ring->desc_dma_addr,
 			 ring->desc_num * sizeof(ring->desc[0]),
 			 ring_to_dma_dir(ring));
@@ -183,6 +182,9 @@ static int hnae_alloc_desc(struct hnae_ring *ring)
 /* fini ring, also free the buffer for the ring */
 static void hnae_fini_ring(struct hnae_ring *ring)
 {
+	if (is_rx_ring(ring))
+		hnae_free_buffers(ring);
+
 	hnae_free_desc(ring);
 	kfree(ring->desc_cb);
 	ring->desc_cb = NULL;

commit 2e9361efa707e186d91b938e44f9e326725259f7
Author: Yunsheng Lin <linyunsheng@huawei.com>
Date:   Tue Sep 25 10:21:55 2018 +0100

    net: hns: fix for unmapping problem when SMMU is on
    
    If SMMU is on, there is more likely that skb_shinfo(skb)->frags[i]
    can not send by a single BD. when this happen, the
    hns_nic_net_xmit_hw function map the whole data in a frags using
    skb_frag_dma_map, but unmap each BD' data individually when tx is
    done, which causes problem when SMMU is on.
    
    This patch fixes this problem by ummapping the whole data in a
    frags when tx is done.
    
    Signed-off-by: Yunsheng Lin <linyunsheng@huawei.com>
    Signed-off-by: Peng Li <lipeng321@huawei.com>
    Reviewed-by: Yisen Zhuang <yisen.zhuang@huawei.com>
    Signed-off-by: Salil Mehta <salil.mehta@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/hisilicon/hns/hnae.c b/drivers/net/ethernet/hisilicon/hns/hnae.c
index a051e582d541..79d03f8ee7b1 100644
--- a/drivers/net/ethernet/hisilicon/hns/hnae.c
+++ b/drivers/net/ethernet/hisilicon/hns/hnae.c
@@ -84,7 +84,7 @@ static void hnae_unmap_buffer(struct hnae_ring *ring, struct hnae_desc_cb *cb)
 	if (cb->type == DESC_TYPE_SKB)
 		dma_unmap_single(ring_to_dev(ring), cb->dma, cb->length,
 				 ring_to_dma_dir(ring));
-	else
+	else if (cb->length)
 		dma_unmap_page(ring_to_dev(ring), cb->dma, cb->length,
 			       ring_to_dma_dir(ring));
 }

commit b8c17f7088310e7ee34ca61929f737045adfd449
Author: Lin Yun Sheng <linyunsheng@huawei.com>
Date:   Wed Aug 2 17:57:37 2017 +0800

    net: hns: Add self-adaptive interrupt coalesce support in hns driver
    
    When deal with low and high throughput, it is hard to achiece both
    high performance and low latency. In order to achiece that, this patch
    calculates the rx rate, and adjust the interrupt coalesce parameter
    accordingly.
    
    Signed-off-by: Yunsheng Lin <linyunsheng@huawei.com>
    Tested-by: Weiwei Deng <dengweiwei@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/hisilicon/hns/hnae.c b/drivers/net/ethernet/hisilicon/hns/hnae.c
index 9d9b6e6dd988..a051e582d541 100644
--- a/drivers/net/ethernet/hisilicon/hns/hnae.c
+++ b/drivers/net/ethernet/hisilicon/hns/hnae.c
@@ -202,6 +202,7 @@ hnae_init_ring(struct hnae_queue *q, struct hnae_ring *ring, int flags)
 	ring->q = q;
 	ring->flags = flags;
 	spin_lock_init(&ring->lock);
+	ring->coal_param = q->handle->coal_param;
 	assert(!ring->desc && !ring->desc_cb && !ring->desc_dma_addr);
 
 	/* not matter for tx or rx ring, the ntc and ntc start from 0 */

commit 820c90cb3e2e452c80824391953cab9d5b5af154
Author: lipeng <lipeng321@huawei.com>
Date:   Sat Apr 1 12:03:47 2017 +0100

    net: hns: Avoid Hip06 chip TX packet line bug
    
    There is a bug on Hip06 that tx ring interrupts packets count will be
    clear when drivers send data to tx ring, so that the tx packets count
    will never upgrade to packets line, and cause the interrupts engendered
    was delayed.
    Sometimes, it will cause sending performance lower than expected.
    
    To fix this bug, we set tx ring interrupts packets line to 1 forever,
    to avoid count clear. And set the gap time to 20us, to solve the problem
    that too many interrupts engendered when packets line is 1.
    
    This patch could advance the send performance on ARM  from 6.6G to 9.37G
    when an iperf send thread on ARM and an iperf send thread on X86 for XGE.
    
    Signed-off-by: lipeng <lipeng321@huawei.com>
    Signed-off-by: Salil Mehta <salil.mehta@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/hisilicon/hns/hnae.c b/drivers/net/ethernet/hisilicon/hns/hnae.c
index ef818b7d5021..9d9b6e6dd988 100644
--- a/drivers/net/ethernet/hisilicon/hns/hnae.c
+++ b/drivers/net/ethernet/hisilicon/hns/hnae.c
@@ -57,10 +57,15 @@ static int hnae_alloc_buffer(struct hnae_ring *ring, struct hnae_desc_cb *cb)
 
 static void hnae_free_buffer(struct hnae_ring *ring, struct hnae_desc_cb *cb)
 {
+	if (unlikely(!cb->priv))
+		return;
+
 	if (cb->type == DESC_TYPE_SKB)
 		dev_kfree_skb_any((struct sk_buff *)cb->priv);
 	else if (unlikely(is_rx_ring(ring)))
 		put_page((struct page *)cb->priv);
+
+	cb->priv = NULL;
 }
 
 static int hnae_map_buffer(struct hnae_ring *ring, struct hnae_desc_cb *cb)

commit f2aaed557ecff57f7523f889acf1981fb23c4047
Author: lipeng <lipeng321@huawei.com>
Date:   Sat Apr 1 12:03:38 2017 +0100

    net: hns: Replace netif_tx_lock to ring spin lock
    
    netif_tx_lock is a global spin lock, it will take affect
    in all rings in the netdevice. In tx_poll_one process, it can
    only lock the current ring, in this case, we define a spin lock
    in hnae_ring struct for it.
    
    Signed-off-by: lipeng <lipeng321@huawei.com>
    reviewed-by: Yisen Zhuang <yisen.zhuang@huawei.com>
    Signed-off-by: Salil Mehta <salil.mehta@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/hisilicon/hns/hnae.c b/drivers/net/ethernet/hisilicon/hns/hnae.c
index 8138dde4e767..ef818b7d5021 100644
--- a/drivers/net/ethernet/hisilicon/hns/hnae.c
+++ b/drivers/net/ethernet/hisilicon/hns/hnae.c
@@ -196,6 +196,7 @@ hnae_init_ring(struct hnae_queue *q, struct hnae_ring *ring, int flags)
 
 	ring->q = q;
 	ring->flags = flags;
+	spin_lock_init(&ring->lock);
 	assert(!ring->desc && !ring->desc_cb && !ring->desc_dma_addr);
 
 	/* not matter for tx or rx ring, the ntc and ntc start from 0 */

commit fb0672d11634dd072bfb66a0b546b4fc592f4158
Author: lipeng <lipeng321@huawei.com>
Date:   Sat Apr 1 12:03:34 2017 +0100

    net: hns: Remove redundant memset during buffer release
    
    Because all members of desc_cb is assigned when xmit one package, so it
    can delete in hnae_free_buffer, as follows:
            - "dma, priv, length, type" are assigned in fill_v2_desc.
            - "page_offset, reuse_flag, buf" are not used in tx direction.
    
    Signed-off-by: lipeng <lipeng321@huawei.com>
    Signed-off-by: Weiwei Deng <dengweiwei@huawei.com>
    Reviewed-by: Yisen Zhuang <yisen.zhuang@huawei.com>
    Signed-off-by: Salil Mehta <salil.mehta@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/hisilicon/hns/hnae.c b/drivers/net/ethernet/hisilicon/hns/hnae.c
index 120427a40883..8138dde4e767 100644
--- a/drivers/net/ethernet/hisilicon/hns/hnae.c
+++ b/drivers/net/ethernet/hisilicon/hns/hnae.c
@@ -61,7 +61,6 @@ static void hnae_free_buffer(struct hnae_ring *ring, struct hnae_desc_cb *cb)
 		dev_kfree_skb_any((struct sk_buff *)cb->priv);
 	else if (unlikely(is_rx_ring(ring)))
 		put_page((struct page *)cb->priv);
-	memset(cb, 0, sizeof(*cb));
 }
 
 static int hnae_map_buffer(struct hnae_ring *ring, struct hnae_desc_cb *cb)

commit c6e970a04bdceb7ef1fdbac6be3bd4cd0a0a02bd
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Tue Mar 28 23:45:06 2017 +0200

    net: break include loop netdevice.h, dsa.h, devlink.h
    
    There is an include loop between netdevice.h, dsa.h, devlink.h because
    of NETDEV_ALIGN, making it impossible to use devlink structures in
    dsa.h.
    
    Break this loop by taking dsa.h out of netdevice.h, add a forward
    declaration of dsa_switch_tree and netdev_set_default_ethtool_ops()
    function, which is what netdevice.h requires.
    
    No longer having dsa.h in netdevice.h means the includes in dsa.h no
    longer get included. This breaks a few other files which depend on
    these includes. Add these directly in the affected file.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/hisilicon/hns/hnae.c b/drivers/net/ethernet/hisilicon/hns/hnae.c
index b6ed818f78ff..120427a40883 100644
--- a/drivers/net/ethernet/hisilicon/hns/hnae.c
+++ b/drivers/net/ethernet/hisilicon/hns/hnae.c
@@ -9,9 +9,9 @@
 
 #include <linux/dma-mapping.h>
 #include <linux/interrupt.h>
+#include <linux/of.h>
 #include <linux/skbuff.h>
 #include <linux/slab.h>
-
 #include "hnae.h"
 
 #define cls_to_ae_dev(dev) container_of(dev, struct hnae_ae_dev, cls_dev)

commit 2271150bfb814b72ec57ae2fdf66e39da2eafafd
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Nov 3 18:40:22 2016 +0100

    net: hns: fix device reference leaks
    
    Make sure to drop the reference taken by class_find_device() in
    hnae_get_handle() on errors and when later releasing the handle.
    
    Fixes: 6fe6611ff275 ("net: add Hisilicon Network Subsystem...")
    Cc: Yisen Zhuang <yisen.zhuang@huawei.com>
    Cc: Salil Mehta <salil.mehta@huawei.com>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/hisilicon/hns/hnae.c b/drivers/net/ethernet/hisilicon/hns/hnae.c
index c54c6fac0d1d..b6ed818f78ff 100644
--- a/drivers/net/ethernet/hisilicon/hns/hnae.c
+++ b/drivers/net/ethernet/hisilicon/hns/hnae.c
@@ -332,8 +332,10 @@ struct hnae_handle *hnae_get_handle(struct device *owner_dev,
 		return ERR_PTR(-ENODEV);
 
 	handle = dev->ops->get_handle(dev, port_id);
-	if (IS_ERR(handle))
+	if (IS_ERR(handle)) {
+		put_device(&dev->cls_dev);
 		return handle;
+	}
 
 	handle->dev = dev;
 	handle->owner_dev = owner_dev;
@@ -356,6 +358,8 @@ struct hnae_handle *hnae_get_handle(struct device *owner_dev,
 	for (j = i - 1; j >= 0; j--)
 		hnae_fini_queue(handle->qs[j]);
 
+	put_device(&dev->cls_dev);
+
 	return ERR_PTR(-ENOMEM);
 }
 EXPORT_SYMBOL(hnae_get_handle);
@@ -377,6 +381,8 @@ void hnae_put_handle(struct hnae_handle *h)
 		dev->ops->put_handle(h);
 
 	module_put(dev->owner);
+
+	put_device(&dev->cls_dev);
 }
 EXPORT_SYMBOL(hnae_put_handle);
 

commit 454784d85de372991ad2e473d562d4ad31f4502a
Author: Daode Huang <huangdaode@hisilicon.com>
Date:   Tue Jun 21 11:56:34 2016 +0800

    net: hns: delete redundancy ring enable operations
    
    When network interface is enabled, the ring enable operation is
    conducted twice. This patch deletes the redundancy code of ring enable,
    and integrates hnae_ae_ops.toggle_queue_status other functions to
    hns_ae_start.
    
    Signed-off-by: Daode Huang <huangdaode@hisilicon.com>
    Signed-off-by: Yisen Zhuang <Yisen.Zhuang@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/hisilicon/hns/hnae.c b/drivers/net/ethernet/hisilicon/hns/hnae.c
index 5d3047cc8380..c54c6fac0d1d 100644
--- a/drivers/net/ethernet/hisilicon/hns/hnae.c
+++ b/drivers/net/ethernet/hisilicon/hns/hnae.c
@@ -400,7 +400,6 @@ int hnae_ae_register(struct hnae_ae_dev *hdev, struct module *owner)
 
 	if (!hdev->ops || !hdev->ops->get_handle ||
 	    !hdev->ops->toggle_ring_irq ||
-	    !hdev->ops->toggle_queue_status ||
 	    !hdev->ops->get_status || !hdev->ops->adjust_link)
 		return -EINVAL;
 

commit 652d39b0d50a6e99495442431c8dadeb8c05c986
Author: Kejian Yan <yankejian@huawei.com>
Date:   Fri Jun 3 10:55:16 2016 +0800

    net: hns: add uniform interface for phy connection
    
    As device_node is only used by DT case, HNS needs to treat the other
    cases including ACPI. It needs to use uniform ways to handle both of
    DT and ACPI. This patch chooses phy_device, and of_phy_connect and
    of_phy_attach are only used by DT case. It needs to use uniform interface
    to handle that sequence by both DT and ACPI.
    
    Signed-off-by: Kejian Yan <yankejian@huawei.com>
    Signed-off-by: Yisen Zhuang <Yisen.Zhuang@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/hisilicon/hns/hnae.c b/drivers/net/ethernet/hisilicon/hns/hnae.c
index d630acdb0749..5d3047cc8380 100644
--- a/drivers/net/ethernet/hisilicon/hns/hnae.c
+++ b/drivers/net/ethernet/hisilicon/hns/hnae.c
@@ -96,7 +96,13 @@ static int __ae_match(struct device *dev, const void *data)
 {
 	struct hnae_ae_dev *hdev = cls_to_ae_dev(dev);
 
-	return (data == &hdev->dev->of_node->fwnode);
+	if (dev_of_node(hdev->dev))
+		return (data == &hdev->dev->of_node->fwnode);
+	else if (is_acpi_node(hdev->dev->fwnode))
+		return (data == hdev->dev->fwnode);
+
+	dev_err(dev, "__ae_match cannot read cfg data from OF or acpi\n");
+	return 0;
 }
 
 static struct hnae_ae_dev *find_ae(const struct fwnode_handle *fwnode)

commit 7b2acae6fb28f0b3d32c0620f8045c4a1bf5bb92
Author: Kejian Yan <yankejian@huawei.com>
Date:   Fri Jun 3 10:55:15 2016 +0800

    net: hns: enet specify a reference to dsaf by fwnode_handle
    
    As device_node is only used by DT case, it is expected to find uniform
    ways. So fwnode_handle is the suitable method.
    
    Signed-off-by: Kejian Yan <yankejian@huawei.com>
    Signed-off-by: Yisen Zhuang <Yisen.Zhuang@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/hisilicon/hns/hnae.c b/drivers/net/ethernet/hisilicon/hns/hnae.c
index 3bfe36f9405b..d630acdb0749 100644
--- a/drivers/net/ethernet/hisilicon/hns/hnae.c
+++ b/drivers/net/ethernet/hisilicon/hns/hnae.c
@@ -96,16 +96,16 @@ static int __ae_match(struct device *dev, const void *data)
 {
 	struct hnae_ae_dev *hdev = cls_to_ae_dev(dev);
 
-	return hdev->dev->of_node == data;
+	return (data == &hdev->dev->of_node->fwnode);
 }
 
-static struct hnae_ae_dev *find_ae(const struct device_node *ae_node)
+static struct hnae_ae_dev *find_ae(const struct fwnode_handle *fwnode)
 {
 	struct device *dev;
 
-	WARN_ON(!ae_node);
+	WARN_ON(!fwnode);
 
-	dev = class_find_device(hnae_class, NULL, ae_node, __ae_match);
+	dev = class_find_device(hnae_class, NULL, fwnode, __ae_match);
 
 	return dev ? cls_to_ae_dev(dev) : NULL;
 }
@@ -312,7 +312,7 @@ EXPORT_SYMBOL(hnae_reinit_handle);
  * return handle ptr or ERR_PTR
  */
 struct hnae_handle *hnae_get_handle(struct device *owner_dev,
-				    const struct device_node *ae_node,
+				    const struct fwnode_handle	*fwnode,
 				    u32 port_id,
 				    struct hnae_buf_ops *bops)
 {
@@ -321,7 +321,7 @@ struct hnae_handle *hnae_get_handle(struct device *owner_dev,
 	int i, j;
 	int ret;
 
-	dev = find_ae(ae_node);
+	dev = find_ae(fwnode);
 	if (!dev)
 		return ERR_PTR(-ENODEV);
 

commit 48189d6aaf1ed1b382666289a94a50e5269a8946
Author: yankejian <yankejian@huawei.com>
Date:   Wed Jan 20 16:00:19 2016 +0800

    net: hns: enet specifies a reference to dsaf
    
    This patch replace the assoication between dsaf and enet from string
    matching to object reference. It requires the DTS to be updated within
    BIOS. Thanks god it can be done for all released boards.
    
    Signed-off-by: Kejian Yan <yankejian@huawei.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Acked-by: Yisen Zhuang <yisen.zhuang@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/hisilicon/hns/hnae.c b/drivers/net/ethernet/hisilicon/hns/hnae.c
index b3645297477e..3bfe36f9405b 100644
--- a/drivers/net/ethernet/hisilicon/hns/hnae.c
+++ b/drivers/net/ethernet/hisilicon/hns/hnae.c
@@ -95,21 +95,17 @@ static struct hnae_buf_ops hnae_bops = {
 static int __ae_match(struct device *dev, const void *data)
 {
 	struct hnae_ae_dev *hdev = cls_to_ae_dev(dev);
-	const char *ae_id = data;
 
-	if (!strncmp(ae_id, hdev->name, AE_NAME_SIZE))
-		return 1;
-
-	return 0;
+	return hdev->dev->of_node == data;
 }
 
-static struct hnae_ae_dev *find_ae(const char *ae_id)
+static struct hnae_ae_dev *find_ae(const struct device_node *ae_node)
 {
 	struct device *dev;
 
-	WARN_ON(!ae_id);
+	WARN_ON(!ae_node);
 
-	dev = class_find_device(hnae_class, NULL, ae_id, __ae_match);
+	dev = class_find_device(hnae_class, NULL, ae_node, __ae_match);
 
 	return dev ? cls_to_ae_dev(dev) : NULL;
 }
@@ -316,7 +312,8 @@ EXPORT_SYMBOL(hnae_reinit_handle);
  * return handle ptr or ERR_PTR
  */
 struct hnae_handle *hnae_get_handle(struct device *owner_dev,
-				    const char *ae_id, u32 port_id,
+				    const struct device_node *ae_node,
+				    u32 port_id,
 				    struct hnae_buf_ops *bops)
 {
 	struct hnae_ae_dev *dev;
@@ -324,7 +321,7 @@ struct hnae_handle *hnae_get_handle(struct device *owner_dev,
 	int i, j;
 	int ret;
 
-	dev = find_ae(ae_id);
+	dev = find_ae(ae_node);
 	if (!dev)
 		return ERR_PTR(-ENODEV);
 

commit c6aa74d546ccb94c99a1e95fb461f8b0e9410a3e
Author: Wu Fengguang <fengguang.wu@intel.com>
Date:   Tue Oct 20 14:56:00 2015 +0800

    net: hisilicon: fix ptr_ret.cocci warnings
    
    drivers/net/ethernet/hisilicon/hns/hnae.c:442:1-3: WARNING: PTR_ERR_OR_ZERO can be used
    
     Use PTR_ERR_OR_ZERO rather than if(IS_ERR(...)) + PTR_ERR
    
    Generated by: scripts/coccinelle/api/ptr_ret.cocci
    
    CC: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/hisilicon/hns/hnae.c b/drivers/net/ethernet/hisilicon/hns/hnae.c
index 9d3bb8349a73..b3645297477e 100644
--- a/drivers/net/ethernet/hisilicon/hns/hnae.c
+++ b/drivers/net/ethernet/hisilicon/hns/hnae.c
@@ -439,10 +439,7 @@ EXPORT_SYMBOL(hnae_ae_unregister);
 static int __init hnae_init(void)
 {
 	hnae_class = class_create(THIS_MODULE, "hnae");
-	if (IS_ERR(hnae_class))
-		return PTR_ERR(hnae_class);
-
-	return 0;
+	return PTR_ERR_OR_ZERO(hnae_class);
 }
 
 static void __exit hnae_exit(void)

commit 31bbd77189a82ed0b7f167d3b8b6561898fa8a80
Author: huangdaode <huangdaode@hisilicon.com>
Date:   Fri Oct 16 11:54:16 2015 +0800

    net: hisilicon rm hnae sysfs interface
    
    This patch removes the hns driver hnae sysfs interface according to
    Arnd's review comments.
    
    Signed-off-by: huangdaode <huangdaode@hisilicon.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/hisilicon/hns/hnae.c b/drivers/net/ethernet/hisilicon/hns/hnae.c
index f52e99acf463..9d3bb8349a73 100644
--- a/drivers/net/ethernet/hisilicon/hns/hnae.c
+++ b/drivers/net/ethernet/hisilicon/hns/hnae.c
@@ -436,59 +436,12 @@ void hnae_ae_unregister(struct hnae_ae_dev *hdev)
 }
 EXPORT_SYMBOL(hnae_ae_unregister);
 
-static ssize_t handles_show(struct device *dev,
-			    struct device_attribute *attr, char *buf)
-{
-	ssize_t s = 0;
-	struct hnae_ae_dev *hdev = cls_to_ae_dev(dev);
-	struct hnae_handle *h;
-	int i = 0, j;
-
-	list_for_each_entry_rcu(h, &hdev->handle_list, node) {
-		s += sprintf(buf + s, "handle %d (eport_id=%u from %s):\n",
-			    i++, h->eport_id, h->dev->name);
-		for (j = 0; j < h->q_num; j++) {
-			s += sprintf(buf + s, "\tqueue[%d] on %p\n",
-				     j, h->qs[i]->io_base);
-#define HANDEL_TX_MSG "\t\ttx_ring on %p:%u,%u,%u,%u,%u,%llu,%llu\n"
-			s += sprintf(buf + s,
-				     HANDEL_TX_MSG,
-				     h->qs[i]->tx_ring.io_base,
-				     h->qs[i]->tx_ring.buf_size,
-				     h->qs[i]->tx_ring.desc_num,
-				     h->qs[i]->tx_ring.max_desc_num_per_pkt,
-				     h->qs[i]->tx_ring.max_raw_data_sz_per_desc,
-				     h->qs[i]->tx_ring.max_pkt_size,
-				 h->qs[i]->tx_ring.stats.sw_err_cnt,
-				 h->qs[i]->tx_ring.stats.io_err_cnt);
-			s += sprintf(buf + s,
-				"\t\trx_ring on %p:%u,%u,%llu,%llu,%llu\n",
-				h->qs[i]->rx_ring.io_base,
-				h->qs[i]->rx_ring.buf_size,
-				h->qs[i]->rx_ring.desc_num,
-				h->qs[i]->rx_ring.stats.sw_err_cnt,
-				h->qs[i]->rx_ring.stats.io_err_cnt,
-				h->qs[i]->rx_ring.stats.seg_pkt_cnt);
-		}
-	}
-
-	return s;
-}
-
-static DEVICE_ATTR_RO(handles);
-static struct attribute *hnae_class_attrs[] = {
-	&dev_attr_handles.attr,
-	NULL,
-};
-ATTRIBUTE_GROUPS(hnae_class);
-
 static int __init hnae_init(void)
 {
 	hnae_class = class_create(THIS_MODULE, "hnae");
 	if (IS_ERR(hnae_class))
 		return PTR_ERR(hnae_class);
 
-	hnae_class->dev_groups = hnae_class_groups;
 	return 0;
 }
 

commit dfdd7230c5a2d9d675b4e7d6e111a8ead13cfb11
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Oct 6 23:53:57 2015 +0200

    net: hns: fix 32-bit build warning
    
    The recently added hns driver causes a build warning in ARM
    allmodconfig builds:
    
    drivers/net/ethernet/hisilicon/hns/hnae.c: In function 'handles_show':
    drivers/net/ethernet/hisilicon/hns/hnae.c:452:13: warning: cast from pointer to integer of different size [-Wpointer-to-int-cast]
              j, (u64)h->qs[i]->io_base);
                 ^
    
    This removes the pointless cast and prints the pointer address using
    the "%p" format string in all three locations.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/hisilicon/hns/hnae.c b/drivers/net/ethernet/hisilicon/hns/hnae.c
index 0a0a9e80dcd7..f52e99acf463 100644
--- a/drivers/net/ethernet/hisilicon/hns/hnae.c
+++ b/drivers/net/ethernet/hisilicon/hns/hnae.c
@@ -448,12 +448,12 @@ static ssize_t handles_show(struct device *dev,
 		s += sprintf(buf + s, "handle %d (eport_id=%u from %s):\n",
 			    i++, h->eport_id, h->dev->name);
 		for (j = 0; j < h->q_num; j++) {
-			s += sprintf(buf + s, "\tqueue[%d] on 0x%llx\n",
-				     j, (u64)h->qs[i]->io_base);
-#define HANDEL_TX_MSG "\t\ttx_ring on 0x%llx:%u,%u,%u,%u,%u,%llu,%llu\n"
+			s += sprintf(buf + s, "\tqueue[%d] on %p\n",
+				     j, h->qs[i]->io_base);
+#define HANDEL_TX_MSG "\t\ttx_ring on %p:%u,%u,%u,%u,%u,%llu,%llu\n"
 			s += sprintf(buf + s,
 				     HANDEL_TX_MSG,
-				     (u64)h->qs[i]->tx_ring.io_base,
+				     h->qs[i]->tx_ring.io_base,
 				     h->qs[i]->tx_ring.buf_size,
 				     h->qs[i]->tx_ring.desc_num,
 				     h->qs[i]->tx_ring.max_desc_num_per_pkt,
@@ -462,8 +462,8 @@ static ssize_t handles_show(struct device *dev,
 				 h->qs[i]->tx_ring.stats.sw_err_cnt,
 				 h->qs[i]->tx_ring.stats.io_err_cnt);
 			s += sprintf(buf + s,
-				"\t\trx_ring on 0x%llx:%u,%u,%llu,%llu,%llu\n",
-				(u64)h->qs[i]->rx_ring.io_base,
+				"\t\trx_ring on %p:%u,%u,%llu,%llu,%llu\n",
+				h->qs[i]->rx_ring.io_base,
 				h->qs[i]->rx_ring.buf_size,
 				h->qs[i]->rx_ring.desc_num,
 				h->qs[i]->rx_ring.stats.sw_err_cnt,

commit 6fe6611ff275522a4e4c0359e2f46cdd07780d2f
Author: huangdaode <huangdaode@hisilicon.com>
Date:   Thu Sep 17 14:51:48 2015 +0800

    net: add Hisilicon Network Subsystem hnae framework support
    
    HNAE (Hisilicon Network Acceleration Engine) is a framework to provide a
    unified ring buffer interface for Hisilicon Network Acceleration
    Engines.
    
    With the interface, upper layer can work as ethernet driver, ODP driver
    or other service driver on purpose.
    
    Signed-off-by: huangdaode <huangdaode@hisilicon.com>
    Signed-off-by: Kenneth Lee <liguozhu@huawei.com>
    Signed-off-by: Yisen Zhuang <Yisen.Zhuang@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/hisilicon/hns/hnae.c b/drivers/net/ethernet/hisilicon/hns/hnae.c
new file mode 100644
index 000000000000..0a0a9e80dcd7
--- /dev/null
+++ b/drivers/net/ethernet/hisilicon/hns/hnae.c
@@ -0,0 +1,507 @@
+/*
+ * Copyright (c) 2014-2015 Hisilicon Limited.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+
+#include "hnae.h"
+
+#define cls_to_ae_dev(dev) container_of(dev, struct hnae_ae_dev, cls_dev)
+
+static struct class *hnae_class;
+
+static void
+hnae_list_add(spinlock_t *lock, struct list_head *node, struct list_head *head)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(lock, flags);
+	list_add_tail_rcu(node, head);
+	spin_unlock_irqrestore(lock, flags);
+}
+
+static void hnae_list_del(spinlock_t *lock, struct list_head *node)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(lock, flags);
+	list_del_rcu(node);
+	spin_unlock_irqrestore(lock, flags);
+}
+
+static int hnae_alloc_buffer(struct hnae_ring *ring, struct hnae_desc_cb *cb)
+{
+	unsigned int order = hnae_page_order(ring);
+	struct page *p = dev_alloc_pages(order);
+
+	if (!p)
+		return -ENOMEM;
+
+	cb->priv = p;
+	cb->page_offset = 0;
+	cb->reuse_flag = 0;
+	cb->buf  = page_address(p);
+	cb->length = hnae_page_size(ring);
+	cb->type = DESC_TYPE_PAGE;
+
+	return 0;
+}
+
+static void hnae_free_buffer(struct hnae_ring *ring, struct hnae_desc_cb *cb)
+{
+	if (cb->type == DESC_TYPE_SKB)
+		dev_kfree_skb_any((struct sk_buff *)cb->priv);
+	else if (unlikely(is_rx_ring(ring)))
+		put_page((struct page *)cb->priv);
+	memset(cb, 0, sizeof(*cb));
+}
+
+static int hnae_map_buffer(struct hnae_ring *ring, struct hnae_desc_cb *cb)
+{
+	cb->dma = dma_map_page(ring_to_dev(ring), cb->priv, 0,
+			       cb->length, ring_to_dma_dir(ring));
+
+	if (dma_mapping_error(ring_to_dev(ring), cb->dma))
+		return -EIO;
+
+	return 0;
+}
+
+static void hnae_unmap_buffer(struct hnae_ring *ring, struct hnae_desc_cb *cb)
+{
+	if (cb->type == DESC_TYPE_SKB)
+		dma_unmap_single(ring_to_dev(ring), cb->dma, cb->length,
+				 ring_to_dma_dir(ring));
+	else
+		dma_unmap_page(ring_to_dev(ring), cb->dma, cb->length,
+			       ring_to_dma_dir(ring));
+}
+
+static struct hnae_buf_ops hnae_bops = {
+	.alloc_buffer = hnae_alloc_buffer,
+	.free_buffer = hnae_free_buffer,
+	.map_buffer = hnae_map_buffer,
+	.unmap_buffer = hnae_unmap_buffer,
+};
+
+static int __ae_match(struct device *dev, const void *data)
+{
+	struct hnae_ae_dev *hdev = cls_to_ae_dev(dev);
+	const char *ae_id = data;
+
+	if (!strncmp(ae_id, hdev->name, AE_NAME_SIZE))
+		return 1;
+
+	return 0;
+}
+
+static struct hnae_ae_dev *find_ae(const char *ae_id)
+{
+	struct device *dev;
+
+	WARN_ON(!ae_id);
+
+	dev = class_find_device(hnae_class, NULL, ae_id, __ae_match);
+
+	return dev ? cls_to_ae_dev(dev) : NULL;
+}
+
+static void hnae_free_buffers(struct hnae_ring *ring)
+{
+	int i;
+
+	for (i = 0; i < ring->desc_num; i++)
+		hnae_free_buffer_detach(ring, i);
+}
+
+/* Allocate memory for raw pkg, and map with dma */
+static int hnae_alloc_buffers(struct hnae_ring *ring)
+{
+	int i, j, ret;
+
+	for (i = 0; i < ring->desc_num; i++) {
+		ret = hnae_alloc_buffer_attach(ring, i);
+		if (ret)
+			goto out_buffer_fail;
+	}
+
+	return 0;
+
+out_buffer_fail:
+	for (j = i - 1; j >= 0; j--)
+		hnae_free_buffer_detach(ring, j);
+	return ret;
+}
+
+/* free desc along with its attached buffer */
+static void hnae_free_desc(struct hnae_ring *ring)
+{
+	hnae_free_buffers(ring);
+	dma_unmap_single(ring_to_dev(ring), ring->desc_dma_addr,
+			 ring->desc_num * sizeof(ring->desc[0]),
+			 ring_to_dma_dir(ring));
+	ring->desc_dma_addr = 0;
+	kfree(ring->desc);
+	ring->desc = NULL;
+}
+
+/* alloc desc, without buffer attached */
+static int hnae_alloc_desc(struct hnae_ring *ring)
+{
+	int size = ring->desc_num * sizeof(ring->desc[0]);
+
+	ring->desc = kzalloc(size, GFP_KERNEL);
+	if (!ring->desc)
+		return -ENOMEM;
+
+	ring->desc_dma_addr = dma_map_single(ring_to_dev(ring),
+		ring->desc, size, ring_to_dma_dir(ring));
+	if (dma_mapping_error(ring_to_dev(ring), ring->desc_dma_addr)) {
+		ring->desc_dma_addr = 0;
+		kfree(ring->desc);
+		ring->desc = NULL;
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+/* fini ring, also free the buffer for the ring */
+static void hnae_fini_ring(struct hnae_ring *ring)
+{
+	hnae_free_desc(ring);
+	kfree(ring->desc_cb);
+	ring->desc_cb = NULL;
+	ring->next_to_clean = 0;
+	ring->next_to_use = 0;
+}
+
+/* init ring, and with buffer for rx ring */
+static int
+hnae_init_ring(struct hnae_queue *q, struct hnae_ring *ring, int flags)
+{
+	int ret;
+
+	if (ring->desc_num <= 0 || ring->buf_size <= 0)
+		return -EINVAL;
+
+	ring->q = q;
+	ring->flags = flags;
+	assert(!ring->desc && !ring->desc_cb && !ring->desc_dma_addr);
+
+	/* not matter for tx or rx ring, the ntc and ntc start from 0 */
+	assert(ring->next_to_use == 0);
+	assert(ring->next_to_clean == 0);
+
+	ring->desc_cb = kcalloc(ring->desc_num, sizeof(ring->desc_cb[0]),
+			GFP_KERNEL);
+	if (!ring->desc_cb) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = hnae_alloc_desc(ring);
+	if (ret)
+		goto out_with_desc_cb;
+
+	if (is_rx_ring(ring)) {
+		ret = hnae_alloc_buffers(ring);
+		if (ret)
+			goto out_with_desc;
+	}
+
+	return 0;
+
+out_with_desc:
+	hnae_free_desc(ring);
+out_with_desc_cb:
+	kfree(ring->desc_cb);
+	ring->desc_cb = NULL;
+out:
+	return ret;
+}
+
+static int hnae_init_queue(struct hnae_handle *h, struct hnae_queue *q,
+			   struct hnae_ae_dev *dev)
+{
+	int ret;
+
+	q->dev = dev;
+	q->handle = h;
+
+	ret = hnae_init_ring(q, &q->tx_ring, q->tx_ring.flags | RINGF_DIR);
+	if (ret)
+		goto out;
+
+	ret = hnae_init_ring(q, &q->rx_ring, q->rx_ring.flags & ~RINGF_DIR);
+	if (ret)
+		goto out_with_tx_ring;
+
+	if (dev->ops->init_queue)
+		dev->ops->init_queue(q);
+
+	return 0;
+
+out_with_tx_ring:
+	hnae_fini_ring(&q->tx_ring);
+out:
+	return ret;
+}
+
+static void hnae_fini_queue(struct hnae_queue *q)
+{
+	if (q->dev->ops->fini_queue)
+		q->dev->ops->fini_queue(q);
+
+	hnae_fini_ring(&q->tx_ring);
+	hnae_fini_ring(&q->rx_ring);
+}
+
+/**
+ * ae_chain - define ae chain head
+ */
+static RAW_NOTIFIER_HEAD(ae_chain);
+
+int hnae_register_notifier(struct notifier_block *nb)
+{
+	return raw_notifier_chain_register(&ae_chain, nb);
+}
+EXPORT_SYMBOL(hnae_register_notifier);
+
+void hnae_unregister_notifier(struct notifier_block *nb)
+{
+	if (raw_notifier_chain_unregister(&ae_chain, nb))
+		dev_err(NULL, "notifier chain unregister fail\n");
+}
+EXPORT_SYMBOL(hnae_unregister_notifier);
+
+int hnae_reinit_handle(struct hnae_handle *handle)
+{
+	int i, j;
+	int ret;
+
+	for (i = 0; i < handle->q_num; i++) /* free ring*/
+		hnae_fini_queue(handle->qs[i]);
+
+	if (handle->dev->ops->reset)
+		handle->dev->ops->reset(handle);
+
+	for (i = 0; i < handle->q_num; i++) {/* reinit ring*/
+		ret = hnae_init_queue(handle, handle->qs[i], handle->dev);
+		if (ret)
+			goto out_when_init_queue;
+	}
+	return 0;
+out_when_init_queue:
+	for (j = i - 1; j >= 0; j--)
+		hnae_fini_queue(handle->qs[j]);
+	return ret;
+}
+EXPORT_SYMBOL(hnae_reinit_handle);
+
+/* hnae_get_handle - get a handle from the AE
+ * @owner_dev: the dev use this handle
+ * @ae_id: the id of the ae to be used
+ * @ae_opts: the options set for the handle
+ * @bops: the callbacks for buffer management
+ *
+ * return handle ptr or ERR_PTR
+ */
+struct hnae_handle *hnae_get_handle(struct device *owner_dev,
+				    const char *ae_id, u32 port_id,
+				    struct hnae_buf_ops *bops)
+{
+	struct hnae_ae_dev *dev;
+	struct hnae_handle *handle;
+	int i, j;
+	int ret;
+
+	dev = find_ae(ae_id);
+	if (!dev)
+		return ERR_PTR(-ENODEV);
+
+	handle = dev->ops->get_handle(dev, port_id);
+	if (IS_ERR(handle))
+		return handle;
+
+	handle->dev = dev;
+	handle->owner_dev = owner_dev;
+	handle->bops = bops ? bops : &hnae_bops;
+	handle->eport_id = port_id;
+
+	for (i = 0; i < handle->q_num; i++) {
+		ret = hnae_init_queue(handle, handle->qs[i], dev);
+		if (ret)
+			goto out_when_init_queue;
+	}
+
+	__module_get(dev->owner);
+
+	hnae_list_add(&dev->lock, &handle->node, &dev->handle_list);
+
+	return handle;
+
+out_when_init_queue:
+	for (j = i - 1; j >= 0; j--)
+		hnae_fini_queue(handle->qs[j]);
+
+	return ERR_PTR(-ENOMEM);
+}
+EXPORT_SYMBOL(hnae_get_handle);
+
+void hnae_put_handle(struct hnae_handle *h)
+{
+	struct hnae_ae_dev *dev = h->dev;
+	int i;
+
+	for (i = 0; i < h->q_num; i++)
+		hnae_fini_queue(h->qs[i]);
+
+	if (h->dev->ops->reset)
+		h->dev->ops->reset(h);
+
+	hnae_list_del(&dev->lock, &h->node);
+
+	if (dev->ops->put_handle)
+		dev->ops->put_handle(h);
+
+	module_put(dev->owner);
+}
+EXPORT_SYMBOL(hnae_put_handle);
+
+static void hnae_release(struct device *dev)
+{
+}
+
+/**
+ * hnae_ae_register - register a AE engine to hnae framework
+ * @hdev: the hnae ae engine device
+ * @owner:  the module who provides this dev
+ * NOTE: the duplicated name will not be checked
+ */
+int hnae_ae_register(struct hnae_ae_dev *hdev, struct module *owner)
+{
+	static atomic_t id = ATOMIC_INIT(-1);
+	int ret;
+
+	if (!hdev->dev)
+		return -ENODEV;
+
+	if (!hdev->ops || !hdev->ops->get_handle ||
+	    !hdev->ops->toggle_ring_irq ||
+	    !hdev->ops->toggle_queue_status ||
+	    !hdev->ops->get_status || !hdev->ops->adjust_link)
+		return -EINVAL;
+
+	hdev->owner = owner;
+	hdev->id = (int)atomic_inc_return(&id);
+	hdev->cls_dev.parent = hdev->dev;
+	hdev->cls_dev.class = hnae_class;
+	hdev->cls_dev.release = hnae_release;
+	(void)dev_set_name(&hdev->cls_dev, "hnae%d", hdev->id);
+	ret = device_register(&hdev->cls_dev);
+	if (ret)
+		return ret;
+
+	__module_get(THIS_MODULE);
+
+	INIT_LIST_HEAD(&hdev->handle_list);
+	spin_lock_init(&hdev->lock);
+
+	ret = raw_notifier_call_chain(&ae_chain, HNAE_AE_REGISTER, NULL);
+	if (ret)
+		dev_dbg(hdev->dev,
+			"has not notifier for AE: %s\n", hdev->name);
+
+	return 0;
+}
+EXPORT_SYMBOL(hnae_ae_register);
+
+/**
+ * hnae_ae_unregister - unregisters a HNAE AE engine
+ * @cdev: the device to unregister
+ */
+void hnae_ae_unregister(struct hnae_ae_dev *hdev)
+{
+	device_unregister(&hdev->cls_dev);
+	module_put(THIS_MODULE);
+}
+EXPORT_SYMBOL(hnae_ae_unregister);
+
+static ssize_t handles_show(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	ssize_t s = 0;
+	struct hnae_ae_dev *hdev = cls_to_ae_dev(dev);
+	struct hnae_handle *h;
+	int i = 0, j;
+
+	list_for_each_entry_rcu(h, &hdev->handle_list, node) {
+		s += sprintf(buf + s, "handle %d (eport_id=%u from %s):\n",
+			    i++, h->eport_id, h->dev->name);
+		for (j = 0; j < h->q_num; j++) {
+			s += sprintf(buf + s, "\tqueue[%d] on 0x%llx\n",
+				     j, (u64)h->qs[i]->io_base);
+#define HANDEL_TX_MSG "\t\ttx_ring on 0x%llx:%u,%u,%u,%u,%u,%llu,%llu\n"
+			s += sprintf(buf + s,
+				     HANDEL_TX_MSG,
+				     (u64)h->qs[i]->tx_ring.io_base,
+				     h->qs[i]->tx_ring.buf_size,
+				     h->qs[i]->tx_ring.desc_num,
+				     h->qs[i]->tx_ring.max_desc_num_per_pkt,
+				     h->qs[i]->tx_ring.max_raw_data_sz_per_desc,
+				     h->qs[i]->tx_ring.max_pkt_size,
+				 h->qs[i]->tx_ring.stats.sw_err_cnt,
+				 h->qs[i]->tx_ring.stats.io_err_cnt);
+			s += sprintf(buf + s,
+				"\t\trx_ring on 0x%llx:%u,%u,%llu,%llu,%llu\n",
+				(u64)h->qs[i]->rx_ring.io_base,
+				h->qs[i]->rx_ring.buf_size,
+				h->qs[i]->rx_ring.desc_num,
+				h->qs[i]->rx_ring.stats.sw_err_cnt,
+				h->qs[i]->rx_ring.stats.io_err_cnt,
+				h->qs[i]->rx_ring.stats.seg_pkt_cnt);
+		}
+	}
+
+	return s;
+}
+
+static DEVICE_ATTR_RO(handles);
+static struct attribute *hnae_class_attrs[] = {
+	&dev_attr_handles.attr,
+	NULL,
+};
+ATTRIBUTE_GROUPS(hnae_class);
+
+static int __init hnae_init(void)
+{
+	hnae_class = class_create(THIS_MODULE, "hnae");
+	if (IS_ERR(hnae_class))
+		return PTR_ERR(hnae_class);
+
+	hnae_class->dev_groups = hnae_class_groups;
+	return 0;
+}
+
+static void __exit hnae_exit(void)
+{
+	class_destroy(hnae_class);
+}
+
+subsys_initcall(hnae_init);
+module_exit(hnae_exit);
+
+MODULE_AUTHOR("Hisilicon, Inc.");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Hisilicon Network Acceleration Engine Framework");
+
+/* vi: set tw=78 noet: */
