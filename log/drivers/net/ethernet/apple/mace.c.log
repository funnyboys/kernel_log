commit 65fddcfca8ad14778f71a57672fd01e8112d30fa
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:42 2020 -0700

    mm: reorder includes after introduction of linux/pgtable.h
    
    The replacement of <asm/pgrable.h> with <linux/pgtable.h> made the include
    of the latter in the middle of asm includes.  Fix this up with the aid of
    the below script and manual adjustments here and there.
    
            import sys
            import re
    
            if len(sys.argv) is not 3:
                print "USAGE: %s <file> <header>" % (sys.argv[0])
                sys.exit(1)
    
            hdr_to_move="#include <linux/%s>" % sys.argv[2]
            moved = False
            in_hdrs = False
    
            with open(sys.argv[1], "r") as f:
                lines = f.readlines()
                for _line in lines:
                    line = _line.rstrip('
    ')
                    if line == hdr_to_move:
                        continue
                    if line.startswith("#include <linux/"):
                        in_hdrs = True
                    elif not moved and in_hdrs:
                        moved = True
                        print hdr_to_move
                    print line
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-4-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/net/ethernet/apple/mace.c b/drivers/net/ethernet/apple/mace.c
index 6580976fef5c..9e5006e59215 100644
--- a/drivers/net/ethernet/apple/mace.c
+++ b/drivers/net/ethernet/apple/mace.c
@@ -19,10 +19,10 @@
 #include <linux/spinlock.h>
 #include <linux/bitrev.h>
 #include <linux/slab.h>
+#include <linux/pgtable.h>
 #include <asm/prom.h>
 #include <asm/dbdma.h>
 #include <asm/io.h>
-#include <linux/pgtable.h>
 #include <asm/macio.h>
 
 #include "mace.h"

commit ca5999fde0a1761665a38e4c9a72dbcd7d190a81
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:38 2020 -0700

    mm: introduce include/linux/pgtable.h
    
    The include/linux/pgtable.h is going to be the home of generic page table
    manipulation functions.
    
    Start with moving asm-generic/pgtable.h to include/linux/pgtable.h and
    make the latter include asm/pgtable.h.
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-3-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/net/ethernet/apple/mace.c b/drivers/net/ethernet/apple/mace.c
index b8ba2abf5b3a..6580976fef5c 100644
--- a/drivers/net/ethernet/apple/mace.c
+++ b/drivers/net/ethernet/apple/mace.c
@@ -22,7 +22,7 @@
 #include <asm/prom.h>
 #include <asm/dbdma.h>
 #include <asm/io.h>
-#include <asm/pgtable.h>
+#include <linux/pgtable.h>
 #include <asm/macio.h>
 
 #include "mace.h"

commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/ethernet/apple/mace.c b/drivers/net/ethernet/apple/mace.c
index 4d9819d2894d..b8ba2abf5b3a 100644
--- a/drivers/net/ethernet/apple/mace.c
+++ b/drivers/net/ethernet/apple/mace.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Network device driver for the MACE ethernet controller on
  * Apple Powermacs.  Assumes it's under a DBDMA controller.

commit 5f5a8c75daed965a3631ab98a783846260d2729d
Author: Yang Wei <yang.wei9@zte.com.cn>
Date:   Tue Feb 12 23:52:53 2019 +0800

    net: apple: replace dev_kfree_skb_irq by dev_consume_skb_irq for drop profiles
    
    dev_consume_skb_irq() should be called in mace_interrupt() when skb
    xmit done. It makes drop profiles(dropwatch, perf) more friendly.
    
    Signed-off-by: Yang Wei <yang.wei9@zte.com.cn>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/apple/mace.c b/drivers/net/ethernet/apple/mace.c
index 68b9ee489489..4d9819d2894d 100644
--- a/drivers/net/ethernet/apple/mace.c
+++ b/drivers/net/ethernet/apple/mace.c
@@ -764,7 +764,7 @@ static irqreturn_t mace_interrupt(int irq, void *dev_id)
 	    dev->stats.tx_bytes += mp->tx_bufs[i]->len;
 	    ++dev->stats.tx_packets;
 	}
-	dev_kfree_skb_irq(mp->tx_bufs[i]);
+	dev_consume_skb_irq(mp->tx_bufs[i]);
 	--mp->tx_active;
 	if (++i >= N_TX_RING)
 	    i = 0;

commit e6ce3822a9f264b3f24c1acdc624131fb014f2f0
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Fri Sep 21 11:46:37 2018 +0800

    net: apple: fix return type of ndo_start_xmit function
    
    The method ndo_start_xmit() is defined as returning an 'netdev_tx_t',
    which is a typedef for an enum type, so make sure the implementation in
    this driver has returns 'netdev_tx_t' value, and change the function
    return type to netdev_tx_t.
    
    Found by coccinelle.
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/apple/mace.c b/drivers/net/ethernet/apple/mace.c
index 0b5429d76bcf..68b9ee489489 100644
--- a/drivers/net/ethernet/apple/mace.c
+++ b/drivers/net/ethernet/apple/mace.c
@@ -78,7 +78,7 @@ struct mace_data {
 
 static int mace_open(struct net_device *dev);
 static int mace_close(struct net_device *dev);
-static int mace_xmit_start(struct sk_buff *skb, struct net_device *dev);
+static netdev_tx_t mace_xmit_start(struct sk_buff *skb, struct net_device *dev);
 static void mace_set_multicast(struct net_device *dev);
 static void mace_reset(struct net_device *dev);
 static int mace_set_address(struct net_device *dev, void *addr);
@@ -525,7 +525,7 @@ static inline void mace_set_timeout(struct net_device *dev)
     mp->timeout_active = 1;
 }
 
-static int mace_xmit_start(struct sk_buff *skb, struct net_device *dev)
+static netdev_tx_t mace_xmit_start(struct sk_buff *skb, struct net_device *dev)
 {
     struct mace_data *mp = netdev_priv(dev);
     volatile struct dbdma_regs __iomem *td = mp->tx_dma;

commit de892f8f2cc8176368a490e0778fd2de15e9bfda
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Oct 16 17:29:27 2017 -0700

    net: ethernet: apple: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Johannes Berg <johannes.berg@intel.com>
    Cc: Jarod Wilson <jarod@redhat.com>
    Cc: Rob Herring <robh@kernel.org>
    Cc: netdev@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/apple/mace.c b/drivers/net/ethernet/apple/mace.c
index e58b157b7d7c..0b5429d76bcf 100644
--- a/drivers/net/ethernet/apple/mace.c
+++ b/drivers/net/ethernet/apple/mace.c
@@ -86,7 +86,7 @@ static irqreturn_t mace_interrupt(int irq, void *dev_id);
 static irqreturn_t mace_txdma_intr(int irq, void *dev_id);
 static irqreturn_t mace_rxdma_intr(int irq, void *dev_id);
 static void mace_set_timeout(struct net_device *dev);
-static void mace_tx_timeout(unsigned long data);
+static void mace_tx_timeout(struct timer_list *t);
 static inline void dbdma_reset(volatile struct dbdma_regs __iomem *dma);
 static inline void mace_clean_rings(struct mace_data *mp);
 static void __mace_set_address(struct net_device *dev, void *addr);
@@ -196,7 +196,7 @@ static int mace_probe(struct macio_dev *mdev, const struct of_device_id *match)
 
 	memset((char *) mp->tx_cmds, 0,
 	       (NCMDS_TX*N_TX_RING + N_RX_RING + 2) * sizeof(struct dbdma_cmd));
-	init_timer(&mp->tx_timeout);
+	timer_setup(&mp->tx_timeout, mace_tx_timeout, 0);
 	spin_lock_init(&mp->lock);
 	mp->timeout_active = 0;
 
@@ -521,8 +521,6 @@ static inline void mace_set_timeout(struct net_device *dev)
     if (mp->timeout_active)
 	del_timer(&mp->tx_timeout);
     mp->tx_timeout.expires = jiffies + TX_TIMEOUT;
-    mp->tx_timeout.function = mace_tx_timeout;
-    mp->tx_timeout.data = (unsigned long) dev;
     add_timer(&mp->tx_timeout);
     mp->timeout_active = 1;
 }
@@ -801,10 +799,10 @@ static irqreturn_t mace_interrupt(int irq, void *dev_id)
     return IRQ_HANDLED;
 }
 
-static void mace_tx_timeout(unsigned long data)
+static void mace_tx_timeout(struct timer_list *t)
 {
-    struct net_device *dev = (struct net_device *) data;
-    struct mace_data *mp = netdev_priv(dev);
+    struct mace_data *mp = from_timer(mp, t, tx_timeout);
+    struct net_device *dev = macio_get_drvdata(mp->mdev);
     volatile struct mace __iomem *mb = mp->mace;
     volatile struct dbdma_regs __iomem *td = mp->tx_dma;
     volatile struct dbdma_regs __iomem *rd = mp->rx_dma;

commit f7ce91038d52780060ccb0d7ee6dd48967b3e132
Author: Rob Herring <robh@kernel.org>
Date:   Tue Jul 18 16:43:19 2017 -0500

    net: Convert to using %pOF instead of full_name
    
    Now that we have a custom printf format specifier, convert users of
    full_name to use %pOF instead. This is preparation to remove storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/apple/mace.c b/drivers/net/ethernet/apple/mace.c
index 96dd5300e0e5..e58b157b7d7c 100644
--- a/drivers/net/ethernet/apple/mace.c
+++ b/drivers/net/ethernet/apple/mace.c
@@ -114,8 +114,8 @@ static int mace_probe(struct macio_dev *mdev, const struct of_device_id *match)
 	int j, rev, rc = -EBUSY;
 
 	if (macio_resource_count(mdev) != 3 || macio_irq_count(mdev) != 3) {
-		printk(KERN_ERR "can't use MACE %s: need 3 addrs and 3 irqs\n",
-		       mace->full_name);
+		printk(KERN_ERR "can't use MACE %pOF: need 3 addrs and 3 irqs\n",
+		       mace);
 		return -ENODEV;
 	}
 
@@ -123,8 +123,8 @@ static int mace_probe(struct macio_dev *mdev, const struct of_device_id *match)
 	if (addr == NULL) {
 		addr = of_get_property(mace, "local-mac-address", NULL);
 		if (addr == NULL) {
-			printk(KERN_ERR "Can't get mac-address for MACE %s\n",
-			       mace->full_name);
+			printk(KERN_ERR "Can't get mac-address for MACE %pOF\n",
+			       mace);
 			return -ENODEV;
 		}
 	}

commit a52ad514fdf3b8a57ca4322c92d2d8d5c6182485
Author: Jarod Wilson <jarod@redhat.com>
Date:   Fri Oct 7 22:04:34 2016 -0400

    net: deprecate eth_change_mtu, remove usage
    
    With centralized MTU checking, there's nothing productive done by
    eth_change_mtu that isn't already done in dev_set_mtu, so mark it as
    deprecated and remove all usage of it in the kernel. All callers have been
    audited for calls to alloc_etherdev* or ether_setup directly, which means
    they all have a valid dev->min_mtu and dev->max_mtu. Now eth_change_mtu
    prints out a netdev_warn about being deprecated, for the benefit of
    out-of-tree drivers that might be utilizing it.
    
    Of note, dvb_net.c actually had dev->mtu = 4096, while using
    eth_change_mtu, meaning that if you ever tried changing it's mtu, you
    couldn't set it above 1500 anymore. It's now getting dev->max_mtu also set
    to 4096 to remedy that.
    
    v2: fix up lantiq_etop, missed breakage due to drive not compiling on x86
    
    CC: netdev@vger.kernel.org
    Signed-off-by: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/apple/mace.c b/drivers/net/ethernet/apple/mace.c
index e58a7c73766e..96dd5300e0e5 100644
--- a/drivers/net/ethernet/apple/mace.c
+++ b/drivers/net/ethernet/apple/mace.c
@@ -102,7 +102,6 @@ static const struct net_device_ops mace_netdev_ops = {
 	.ndo_start_xmit		= mace_xmit_start,
 	.ndo_set_rx_mode	= mace_set_multicast,
 	.ndo_set_mac_address	= mace_set_address,
-	.ndo_change_mtu		= eth_change_mtu,
 	.ndo_validate_addr	= eth_validate_addr,
 };
 

commit d19d5efd8c8840aa4f38a6dfbfe500d8cc27de46
Merge: 34c9a0ffc75a 2fe0753d4940
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 16 13:53:32 2015 -0500

    Merge tag 'powerpc-4.1-1' of git://git.kernel.org/pub/scm/linux/kernel/git/mpe/linux
    
    Pull powerpc updates from Michael Ellerman:
    
     - Numerous minor fixes, cleanups etc.
    
     - More EEH work from Gavin to remove its dependency on device_nodes.
    
     - Memory hotplug implemented entirely in the kernel from Nathan
       Fontenot.
    
     - Removal of redundant CONFIG_PPC_OF by Kevin Hao.
    
     - Rewrite of VPHN parsing logic & tests from Greg Kurz.
    
     - A fix from Nish Aravamudan to reduce memory usage by clamping
       nodes_possible_map.
    
     - Support for pstore on powernv from Hari Bathini.
    
     - Removal of old powerpc specific byte swap routines by David Gibson.
    
     - Fix from Vasant Hegde to prevent the flash driver telling you it was
       flashing your firmware when it wasn't.
    
     - Patch from Ben Herrenschmidt to add an OPAL heartbeat driver.
    
     - Fix for an oops causing get/put_cpu_var() imbalance in perf by Jan
       Stancek.
    
     - Some fixes for migration from Tyrel Datwyler.
    
     - A new syscall to switch the cpu endian by Michael Ellerman.
    
     - Large series from Wei Yang to implement SRIOV, reviewed and acked by
       Bjorn.
    
     - A fix for the OPAL sensor driver from Cédric Le Goater.
    
     - Fixes to get STRICT_MM_TYPECHECKS building again by Michael Ellerman.
    
     - Large series from Daniel Axtens to make our PCI hooks per PHB rather
       than per machine.
    
     - Small patch from Sam Bobroff to explicitly abort non-suspended
       transactions on syscalls, plus a test to exercise it.
    
     - Numerous reworks and fixes for the 24x7 PMU from Sukadev Bhattiprolu.
    
     - Small patch to enable the hard lockup detector from Anton Blanchard.
    
     - Fix from Dave Olson for missing L2 cache information on some CPUs.
    
     - Some fixes from Michael Ellerman to get Cell machines booting again.
    
     - Freescale updates from Scott: Highlights include BMan device tree
       nodes, an MSI erratum workaround, a couple minor performance
       improvements, config updates, and misc fixes/cleanup.
    
    * tag 'powerpc-4.1-1' of git://git.kernel.org/pub/scm/linux/kernel/git/mpe/linux: (196 commits)
      powerpc/powermac: Fix build error seen with powermac smp builds
      powerpc/pseries: Fix compile of memory hotplug without CONFIG_MEMORY_HOTREMOVE
      powerpc: Remove PPC32 code from pseries specific find_and_init_phbs()
      powerpc/cell: Fix iommu breakage caused by controller_ops change
      powerpc/eeh: Fix crash in eeh_add_device_early() on Cell
      powerpc/perf: Cap 64bit userspace backtraces to PERF_MAX_STACK_DEPTH
      powerpc/perf/hv-24x7: Fail 24x7 initcall if create_events_from_catalog() fails
      powerpc/pseries: Correct memory hotplug locking
      powerpc: Fix missing L2 cache size in /sys/devices/system/cpu
      powerpc: Add ppc64 hard lockup detector support
      oprofile: Disable oprofile NMI timer on ppc64
      powerpc/perf/hv-24x7: Add missing put_cpu_var()
      powerpc/perf/hv-24x7: Break up single_24x7_request
      powerpc/perf/hv-24x7: Define update_event_count()
      powerpc/perf/hv-24x7: Whitespace cleanup
      powerpc/perf/hv-24x7: Define add_event_to_24x7_request()
      powerpc/perf/hv-24x7: Rename hv_24x7_event_update
      powerpc/perf/hv-24x7: Move debug prints to separate function
      powerpc/perf/hv-24x7: Drop event_24x7_request()
      powerpc/perf/hv-24x7: Use pr_devel() to log message
      ...
    
    Conflicts:
            tools/testing/selftests/powerpc/Makefile
            tools/testing/selftests/powerpc/tm/Makefile

commit f5718726714cd6114876c4e3ca9b6992ab81176c
Author: David Gibson <david@gibson.dropbear.id.au>
Date:   Tue Feb 3 16:36:21 2015 +1100

    powerpc: Move Power Macintosh drivers to generic byteswappers
    
    ppc has special instruction forms to efficiently load and store values
    in non-native endianness.  These can be accessed via the arch-specific
    {ld,st}_le{16,32}() inlines in arch/powerpc/include/asm/swab.h.
    
    However, gcc is perfectly capable of generating the byte-reversing
    load/store instructions when using the normal, generic cpu_to_le*() and
    le*_to_cpu() functions eaning the arch-specific functions don't have much
    point.
    
    Worse the "le" in the names of the arch specific functions is now
    misleading, because they always generate byte-reversing forms, but some
    ppc machines can now run a little-endian kernel.
    
    To start getting rid of the arch-specific forms, this patch removes them
    from all the old Power Macintosh drivers, replacing them with the
    generic byteswappers.
    
    Signed-off-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/net/ethernet/apple/mace.c b/drivers/net/ethernet/apple/mace.c
index 842fe7684904..73afe49624f2 100644
--- a/drivers/net/ethernet/apple/mace.c
+++ b/drivers/net/ethernet/apple/mace.c
@@ -310,7 +310,7 @@ static void dbdma_reset(volatile struct dbdma_regs __iomem *dma)
      * way on some machines.
      */
     for (i = 200; i > 0; --i)
-	if (ld_le32(&dma->control) & RUN)
+	if (le32_to_cpu(dma->control) & RUN)
 	    udelay(1);
 }
 
@@ -452,21 +452,21 @@ static int mace_open(struct net_device *dev)
 	    data = skb->data;
 	}
 	mp->rx_bufs[i] = skb;
-	st_le16(&cp->req_count, RX_BUFLEN);
-	st_le16(&cp->command, INPUT_LAST + INTR_ALWAYS);
-	st_le32(&cp->phy_addr, virt_to_bus(data));
+	cp->req_count = cpu_to_le16(RX_BUFLEN);
+	cp->command = cpu_to_le16(INPUT_LAST + INTR_ALWAYS);
+	cp->phy_addr = cpu_to_le32(virt_to_bus(data));
 	cp->xfer_status = 0;
 	++cp;
     }
     mp->rx_bufs[i] = NULL;
-    st_le16(&cp->command, DBDMA_STOP);
+    cp->command = cpu_to_le16(DBDMA_STOP);
     mp->rx_fill = i;
     mp->rx_empty = 0;
 
     /* Put a branch back to the beginning of the receive command list */
     ++cp;
-    st_le16(&cp->command, DBDMA_NOP + BR_ALWAYS);
-    st_le32(&cp->cmd_dep, virt_to_bus(mp->rx_cmds));
+    cp->command = cpu_to_le16(DBDMA_NOP + BR_ALWAYS);
+    cp->cmd_dep = cpu_to_le32(virt_to_bus(mp->rx_cmds));
 
     /* start rx dma */
     out_le32(&rd->control, (RUN|PAUSE|FLUSH|WAKE) << 16); /* clear run bit */
@@ -475,8 +475,8 @@ static int mace_open(struct net_device *dev)
 
     /* put a branch at the end of the tx command list */
     cp = mp->tx_cmds + NCMDS_TX * N_TX_RING;
-    st_le16(&cp->command, DBDMA_NOP + BR_ALWAYS);
-    st_le32(&cp->cmd_dep, virt_to_bus(mp->tx_cmds));
+    cp->command = cpu_to_le16(DBDMA_NOP + BR_ALWAYS);
+    cp->cmd_dep = cpu_to_le32(virt_to_bus(mp->tx_cmds));
 
     /* reset tx dma */
     out_le32(&td->control, (RUN|PAUSE|FLUSH|WAKE) << 16);
@@ -507,8 +507,8 @@ static int mace_close(struct net_device *dev)
     out_8(&mb->imr, 0xff);		/* disable all intrs */
 
     /* disable rx and tx dma */
-    st_le32(&rd->control, (RUN|PAUSE|FLUSH|WAKE) << 16); /* clear run bit */
-    st_le32(&td->control, (RUN|PAUSE|FLUSH|WAKE) << 16); /* clear run bit */
+    rd->control = cpu_to_le32((RUN|PAUSE|FLUSH|WAKE) << 16); /* clear run bit */
+    td->control = cpu_to_le32((RUN|PAUSE|FLUSH|WAKE) << 16); /* clear run bit */
 
     mace_clean_rings(mp);
 
@@ -558,8 +558,8 @@ static int mace_xmit_start(struct sk_buff *skb, struct net_device *dev)
     }
     mp->tx_bufs[fill] = skb;
     cp = mp->tx_cmds + NCMDS_TX * fill;
-    st_le16(&cp->req_count, len);
-    st_le32(&cp->phy_addr, virt_to_bus(skb->data));
+    cp->req_count = cpu_to_le16(len);
+    cp->phy_addr = cpu_to_le32(virt_to_bus(skb->data));
 
     np = mp->tx_cmds + NCMDS_TX * next;
     out_le16(&np->command, DBDMA_STOP);
@@ -691,7 +691,7 @@ static irqreturn_t mace_interrupt(int irq, void *dev_id)
 	    out_8(&mb->xmtfc, AUTO_PAD_XMIT);
 	    continue;
 	}
-	dstat = ld_le32(&td->status);
+	dstat = le32_to_cpu(td->status);
 	/* stop DMA controller */
 	out_le32(&td->control, RUN << 16);
 	/*
@@ -724,7 +724,7 @@ static irqreturn_t mace_interrupt(int irq, void *dev_id)
 		 */
 	}
 	cp = mp->tx_cmds + NCMDS_TX * i;
-	stat = ld_le16(&cp->xfer_status);
+	stat = le16_to_cpu(cp->xfer_status);
 	if ((fs & (UFLO|LCOL|LCAR|RTRY)) || (dstat & DEAD) || xcount == 0) {
 	    /*
 	     * Check whether there were in fact 2 bytes written to
@@ -830,7 +830,7 @@ static void mace_tx_timeout(unsigned long data)
     mace_reset(dev);
 
     /* restart rx dma */
-    cp = bus_to_virt(ld_le32(&rd->cmdptr));
+    cp = bus_to_virt(le32_to_cpu(rd->cmdptr));
     dbdma_reset(rd);
     out_le16(&cp->xfer_status, 0);
     out_le32(&rd->cmdptr, virt_to_bus(cp));
@@ -889,20 +889,20 @@ static irqreturn_t mace_rxdma_intr(int irq, void *dev_id)
     spin_lock_irqsave(&mp->lock, flags);
     for (i = mp->rx_empty; i != mp->rx_fill; ) {
 	cp = mp->rx_cmds + i;
-	stat = ld_le16(&cp->xfer_status);
+	stat = le16_to_cpu(cp->xfer_status);
 	if ((stat & ACTIVE) == 0) {
 	    next = i + 1;
 	    if (next >= N_RX_RING)
 		next = 0;
 	    np = mp->rx_cmds + next;
 	    if (next != mp->rx_fill &&
-		(ld_le16(&np->xfer_status) & ACTIVE) != 0) {
+		(le16_to_cpu(np->xfer_status) & ACTIVE) != 0) {
 		printk(KERN_DEBUG "mace: lost a status word\n");
 		++mace_lost_status;
 	    } else
 		break;
 	}
-	nb = ld_le16(&cp->req_count) - ld_le16(&cp->res_count);
+	nb = le16_to_cpu(cp->req_count) - le16_to_cpu(cp->res_count);
 	out_le16(&cp->command, DBDMA_STOP);
 	/* got a packet, have a look at it */
 	skb = mp->rx_bufs[i];
@@ -962,13 +962,13 @@ static irqreturn_t mace_rxdma_intr(int irq, void *dev_id)
 		mp->rx_bufs[i] = skb;
 	    }
 	}
-	st_le16(&cp->req_count, RX_BUFLEN);
+	cp->req_count = cpu_to_le16(RX_BUFLEN);
 	data = skb? skb->data: dummy_buf;
-	st_le32(&cp->phy_addr, virt_to_bus(data));
+	cp->phy_addr = cpu_to_le32(virt_to_bus(data));
 	out_le16(&cp->xfer_status, 0);
 	out_le16(&cp->command, INPUT_LAST + INTR_ALWAYS);
 #if 0
-	if ((ld_le32(&rd->status) & ACTIVE) != 0) {
+	if ((le32_to_cpu(rd->status) & ACTIVE) != 0) {
 	    out_le32(&rd->control, (PAUSE << 16) | PAUSE);
 	    while ((in_le32(&rd->status) & ACTIVE) != 0)
 		;

commit 14448e2f8031a46d509c01dacc9834bd623a928d
Author: Fabian Frederick <fabf@skynet.be>
Date:   Tue Mar 17 19:37:37 2015 +0100

    net: ethernet: apple: constify of_device_id array
    
    of_device_id is always used as const.
    (See driver.of_match_table and open firmware functions)
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/apple/mace.c b/drivers/net/ethernet/apple/mace.c
index 7fcaf0da42a8..a18948286682 100644
--- a/drivers/net/ethernet/apple/mace.c
+++ b/drivers/net/ethernet/apple/mace.c
@@ -984,7 +984,7 @@ static irqreturn_t mace_rxdma_intr(int irq, void *dev_id)
     return IRQ_HANDLED;
 }
 
-static struct of_device_id mace_match[] =
+static const struct of_device_id mace_match[] =
 {
 	{
 	.name 		= "mace",

commit dbedd44e982d61c156337b1a3fb252b24085f8e3
Author: Joe Perches <joe@perches.com>
Date:   Fri Mar 6 20:49:12 2015 -0800

    ethernet: codespell comment spelling fixes
    
    To test a checkpatch spelling patch, I ran codespell against
    drivers/net/ethernet/.
    
    $ git ls-files drivers/net/ethernet/ | \
      while read file ; do \
        codespell -w $file; \
      done
    
    I removed a false positive in e1000_hw.h
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/apple/mace.c b/drivers/net/ethernet/apple/mace.c
index 842fe7684904..7fcaf0da42a8 100644
--- a/drivers/net/ethernet/apple/mace.c
+++ b/drivers/net/ethernet/apple/mace.c
@@ -720,7 +720,7 @@ static irqreturn_t mace_interrupt(int irq, void *dev_id)
 	    mace_reset(dev);
 		/*
 		 * XXX mace likes to hang the machine after a xmtfs error.
-		 * This is hard to reproduce, reseting *may* help
+		 * This is hard to reproduce, resetting *may* help
 		 */
 	}
 	cp = mp->tx_cmds + NCMDS_TX * i;

commit 97c71ad4cef8bf9af36d2c495a971e149a9b77c8
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Dec 3 09:23:55 2012 -0500

    net/apple: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/ethernet/apple/mace.c b/drivers/net/ethernet/apple/mace.c
index e1df4b76c885..842fe7684904 100644
--- a/drivers/net/ethernet/apple/mace.c
+++ b/drivers/net/ethernet/apple/mace.c
@@ -106,7 +106,7 @@ static const struct net_device_ops mace_netdev_ops = {
 	.ndo_validate_addr	= eth_validate_addr,
 };
 
-static int __devinit mace_probe(struct macio_dev *mdev, const struct of_device_id *match)
+static int mace_probe(struct macio_dev *mdev, const struct of_device_id *match)
 {
 	struct device_node *mace = macio_get_of_node(mdev);
 	struct net_device *dev;
@@ -271,7 +271,7 @@ static int __devinit mace_probe(struct macio_dev *mdev, const struct of_device_i
 	return rc;
 }
 
-static int __devexit mace_remove(struct macio_dev *mdev)
+static int mace_remove(struct macio_dev *mdev)
 {
 	struct net_device *dev = macio_get_drvdata(mdev);
 	struct mace_data *mp;

commit 31a4c8b82788fa369c709bb3366c8b90c77c0dee
Author: Pradeep A. Dalvi <netdev@pradeepdalvi.com>
Date:   Wed Feb 8 00:03:15 2012 +0000

    mace: Fix build for mace due to netdev_alloc_skb
    
    Refs:
    1. pmac32_defconfig
    http://kisskb.ellerman.id.au/kisskb/buildresult/5583746/
    2. ppc6xx_defconfig
    http://kisskb.ellerman.id.au/kisskb/buildresult/5584116/
    
    Confirmed any such occurances from all failed defconfigs &
    in net-next sources with
    grep -nrs "netdev_alloc_skb" drivers/net/ethernet/ | grep -v ","
    
    Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Pradeep A Dalvi <netdev@pradeepdalvi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/apple/mace.c b/drivers/net/ethernet/apple/mace.c
index 06998462e0d3..e1df4b76c885 100644
--- a/drivers/net/ethernet/apple/mace.c
+++ b/drivers/net/ethernet/apple/mace.c
@@ -956,7 +956,7 @@ static irqreturn_t mace_rxdma_intr(int irq, void *dev_id)
 	cp = mp->rx_cmds + i;
 	skb = mp->rx_bufs[i];
 	if (!skb) {
-	    skb = netdev_alloc_skb(RX_BUFLEN + 2);
+	    skb = netdev_alloc_skb(dev, RX_BUFLEN + 2);
 	    if (skb) {
 		skb_reserve(skb, 2);
 		mp->rx_bufs[i] = skb;

commit 1d266430546acf01438ae42d0a7370db4817e2ad
Author: Pradeep A Dalvi <netdev@pradeepdalvi.com>
Date:   Sun Feb 5 02:49:09 2012 +0000

    netdev: ethernet dev_alloc_skb to netdev_alloc_skb
    
    Replaced deprecating dev_alloc_skb with netdev_alloc_skb in drivers/net/ethernet
      - Removed extra skb->dev = dev after netdev_alloc_skb
    
    Signed-off-by: Pradeep A Dalvi <netdev@pradeepdalvi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/apple/mace.c b/drivers/net/ethernet/apple/mace.c
index bd5555dbe027..06998462e0d3 100644
--- a/drivers/net/ethernet/apple/mace.c
+++ b/drivers/net/ethernet/apple/mace.c
@@ -444,7 +444,7 @@ static int mace_open(struct net_device *dev)
     memset((char *)mp->rx_cmds, 0, N_RX_RING * sizeof(struct dbdma_cmd));
     cp = mp->rx_cmds;
     for (i = 0; i < N_RX_RING - 1; ++i) {
-	skb = dev_alloc_skb(RX_BUFLEN + 2);
+	skb = netdev_alloc_skb(dev, RX_BUFLEN + 2);
 	if (!skb) {
 	    data = dummy_buf;
 	} else {
@@ -956,7 +956,7 @@ static irqreturn_t mace_rxdma_intr(int irq, void *dev_id)
 	cp = mp->rx_cmds + i;
 	skb = mp->rx_bufs[i];
 	if (!skb) {
-	    skb = dev_alloc_skb(RX_BUFLEN + 2);
+	    skb = netdev_alloc_skb(RX_BUFLEN + 2);
 	    if (skb) {
 		skb_reserve(skb, 2);
 		mp->rx_bufs[i] = skb;

commit 41de8d4cff21a2e81e3d9ff66f5f7c903f9c3ab1
Author: Joe Perches <joe@perches.com>
Date:   Sun Jan 29 13:47:52 2012 +0000

    drivers/net: Remove alloc_etherdev error messages
    
    alloc_etherdev has a generic OOM/unable to alloc message.
    Remove the duplicative messages after alloc_etherdev calls.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/apple/mace.c b/drivers/net/ethernet/apple/mace.c
index 45ba18ee3d6a..bd5555dbe027 100644
--- a/drivers/net/ethernet/apple/mace.c
+++ b/drivers/net/ethernet/apple/mace.c
@@ -147,7 +147,6 @@ static int __devinit mace_probe(struct macio_dev *mdev, const struct of_device_i
 
 	dev = alloc_etherdev(PRIV_BYTES);
 	if (!dev) {
-		printk(KERN_ERR "MACE: can't allocate ethernet device !\n");
 		rc = -ENOMEM;
 		goto err_release;
 	}

commit e404decb0fb017be80552adee894b35307b6c7b4
Author: Joe Perches <joe@perches.com>
Date:   Sun Jan 29 12:56:23 2012 +0000

    drivers/net: Remove unnecessary k.alloc/v.alloc OOM messages
    
    alloc failures use dump_stack so emitting an additional
    out-of-memory message is an unnecessary duplication.
    
    Remove the allocation failure messages.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/apple/mace.c b/drivers/net/ethernet/apple/mace.c
index bec87bd9195c..45ba18ee3d6a 100644
--- a/drivers/net/ethernet/apple/mace.c
+++ b/drivers/net/ethernet/apple/mace.c
@@ -136,10 +136,8 @@ static int __devinit mace_probe(struct macio_dev *mdev, const struct of_device_i
 	 */
 	if (dummy_buf == NULL) {
 		dummy_buf = kmalloc(RX_BUFLEN+2, GFP_KERNEL);
-		if (dummy_buf == NULL) {
-			printk(KERN_ERR "MACE: couldn't allocate dummy buffer\n");
+		if (dummy_buf == NULL)
 			return -ENOMEM;
-		}
 	}
 
 	if (macio_request_resources(mdev, "mace")) {

commit afc4b13df143122f99a0eb10bfefb216c2806de0
Author: Jiri Pirko <jpirko@redhat.com>
Date:   Tue Aug 16 06:29:01 2011 +0000

    net: remove use of ndo_set_multicast_list in drivers
    
    replace it by ndo_set_rx_mode
    
    Signed-off-by: Jiri Pirko <jpirko@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/apple/mace.c b/drivers/net/ethernet/apple/mace.c
index 2074e9724ba3..bec87bd9195c 100644
--- a/drivers/net/ethernet/apple/mace.c
+++ b/drivers/net/ethernet/apple/mace.c
@@ -100,7 +100,7 @@ static const struct net_device_ops mace_netdev_ops = {
 	.ndo_open		= mace_open,
 	.ndo_stop		= mace_close,
 	.ndo_start_xmit		= mace_xmit_start,
-	.ndo_set_multicast_list	= mace_set_multicast,
+	.ndo_set_rx_mode	= mace_set_multicast,
 	.ndo_set_mac_address	= mace_set_address,
 	.ndo_change_mtu		= eth_change_mtu,
 	.ndo_validate_addr	= eth_validate_addr,

commit 8fb6b0908176704a3ea22005e8a9fa3ebf35b5be
Author: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Date:   Mon May 16 01:39:01 2011 -0700

    bmac/mace/macmace/mac89x0/cs89x0: Move the Macintosh (Apple) drivers
    
    Move the Apple drivers into driver/net/ethernet/apple/ and make the
    necessary Kconfig and Makefile changes.
    
    CC: Paul Mackerras <paulus@samba.org>
    CC: Paul Mackerras <paulus@au.ibm.com>
    CC: Russell Nelson <nelson@crynwr.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/apple/mace.c b/drivers/net/ethernet/apple/mace.c
new file mode 100644
index 000000000000..2074e9724ba3
--- /dev/null
+++ b/drivers/net/ethernet/apple/mace.c
@@ -0,0 +1,1031 @@
+/*
+ * Network device driver for the MACE ethernet controller on
+ * Apple Powermacs.  Assumes it's under a DBDMA controller.
+ *
+ * Copyright (C) 1996 Paul Mackerras.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/crc32.h>
+#include <linux/spinlock.h>
+#include <linux/bitrev.h>
+#include <linux/slab.h>
+#include <asm/prom.h>
+#include <asm/dbdma.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/macio.h>
+
+#include "mace.h"
+
+static int port_aaui = -1;
+
+#define N_RX_RING	8
+#define N_TX_RING	6
+#define MAX_TX_ACTIVE	1
+#define NCMDS_TX	1	/* dma commands per element in tx ring */
+#define RX_BUFLEN	(ETH_FRAME_LEN + 8)
+#define TX_TIMEOUT	HZ	/* 1 second */
+
+/* Chip rev needs workaround on HW & multicast addr change */
+#define BROKEN_ADDRCHG_REV	0x0941
+
+/* Bits in transmit DMA status */
+#define TX_DMA_ERR	0x80
+
+struct mace_data {
+    volatile struct mace __iomem *mace;
+    volatile struct dbdma_regs __iomem *tx_dma;
+    int tx_dma_intr;
+    volatile struct dbdma_regs __iomem *rx_dma;
+    int rx_dma_intr;
+    volatile struct dbdma_cmd *tx_cmds;	/* xmit dma command list */
+    volatile struct dbdma_cmd *rx_cmds;	/* recv dma command list */
+    struct sk_buff *rx_bufs[N_RX_RING];
+    int rx_fill;
+    int rx_empty;
+    struct sk_buff *tx_bufs[N_TX_RING];
+    int tx_fill;
+    int tx_empty;
+    unsigned char maccc;
+    unsigned char tx_fullup;
+    unsigned char tx_active;
+    unsigned char tx_bad_runt;
+    struct timer_list tx_timeout;
+    int timeout_active;
+    int port_aaui;
+    int chipid;
+    struct macio_dev *mdev;
+    spinlock_t lock;
+};
+
+/*
+ * Number of bytes of private data per MACE: allow enough for
+ * the rx and tx dma commands plus a branch dma command each,
+ * and another 16 bytes to allow us to align the dma command
+ * buffers on a 16 byte boundary.
+ */
+#define PRIV_BYTES	(sizeof(struct mace_data) \
+	+ (N_RX_RING + NCMDS_TX * N_TX_RING + 3) * sizeof(struct dbdma_cmd))
+
+static int mace_open(struct net_device *dev);
+static int mace_close(struct net_device *dev);
+static int mace_xmit_start(struct sk_buff *skb, struct net_device *dev);
+static void mace_set_multicast(struct net_device *dev);
+static void mace_reset(struct net_device *dev);
+static int mace_set_address(struct net_device *dev, void *addr);
+static irqreturn_t mace_interrupt(int irq, void *dev_id);
+static irqreturn_t mace_txdma_intr(int irq, void *dev_id);
+static irqreturn_t mace_rxdma_intr(int irq, void *dev_id);
+static void mace_set_timeout(struct net_device *dev);
+static void mace_tx_timeout(unsigned long data);
+static inline void dbdma_reset(volatile struct dbdma_regs __iomem *dma);
+static inline void mace_clean_rings(struct mace_data *mp);
+static void __mace_set_address(struct net_device *dev, void *addr);
+
+/*
+ * If we can't get a skbuff when we need it, we use this area for DMA.
+ */
+static unsigned char *dummy_buf;
+
+static const struct net_device_ops mace_netdev_ops = {
+	.ndo_open		= mace_open,
+	.ndo_stop		= mace_close,
+	.ndo_start_xmit		= mace_xmit_start,
+	.ndo_set_multicast_list	= mace_set_multicast,
+	.ndo_set_mac_address	= mace_set_address,
+	.ndo_change_mtu		= eth_change_mtu,
+	.ndo_validate_addr	= eth_validate_addr,
+};
+
+static int __devinit mace_probe(struct macio_dev *mdev, const struct of_device_id *match)
+{
+	struct device_node *mace = macio_get_of_node(mdev);
+	struct net_device *dev;
+	struct mace_data *mp;
+	const unsigned char *addr;
+	int j, rev, rc = -EBUSY;
+
+	if (macio_resource_count(mdev) != 3 || macio_irq_count(mdev) != 3) {
+		printk(KERN_ERR "can't use MACE %s: need 3 addrs and 3 irqs\n",
+		       mace->full_name);
+		return -ENODEV;
+	}
+
+	addr = of_get_property(mace, "mac-address", NULL);
+	if (addr == NULL) {
+		addr = of_get_property(mace, "local-mac-address", NULL);
+		if (addr == NULL) {
+			printk(KERN_ERR "Can't get mac-address for MACE %s\n",
+			       mace->full_name);
+			return -ENODEV;
+		}
+	}
+
+	/*
+	 * lazy allocate the driver-wide dummy buffer. (Note that we
+	 * never have more than one MACE in the system anyway)
+	 */
+	if (dummy_buf == NULL) {
+		dummy_buf = kmalloc(RX_BUFLEN+2, GFP_KERNEL);
+		if (dummy_buf == NULL) {
+			printk(KERN_ERR "MACE: couldn't allocate dummy buffer\n");
+			return -ENOMEM;
+		}
+	}
+
+	if (macio_request_resources(mdev, "mace")) {
+		printk(KERN_ERR "MACE: can't request IO resources !\n");
+		return -EBUSY;
+	}
+
+	dev = alloc_etherdev(PRIV_BYTES);
+	if (!dev) {
+		printk(KERN_ERR "MACE: can't allocate ethernet device !\n");
+		rc = -ENOMEM;
+		goto err_release;
+	}
+	SET_NETDEV_DEV(dev, &mdev->ofdev.dev);
+
+	mp = netdev_priv(dev);
+	mp->mdev = mdev;
+	macio_set_drvdata(mdev, dev);
+
+	dev->base_addr = macio_resource_start(mdev, 0);
+	mp->mace = ioremap(dev->base_addr, 0x1000);
+	if (mp->mace == NULL) {
+		printk(KERN_ERR "MACE: can't map IO resources !\n");
+		rc = -ENOMEM;
+		goto err_free;
+	}
+	dev->irq = macio_irq(mdev, 0);
+
+	rev = addr[0] == 0 && addr[1] == 0xA0;
+	for (j = 0; j < 6; ++j) {
+		dev->dev_addr[j] = rev ? bitrev8(addr[j]): addr[j];
+	}
+	mp->chipid = (in_8(&mp->mace->chipid_hi) << 8) |
+			in_8(&mp->mace->chipid_lo);
+
+
+	mp = netdev_priv(dev);
+	mp->maccc = ENXMT | ENRCV;
+
+	mp->tx_dma = ioremap(macio_resource_start(mdev, 1), 0x1000);
+	if (mp->tx_dma == NULL) {
+		printk(KERN_ERR "MACE: can't map TX DMA resources !\n");
+		rc = -ENOMEM;
+		goto err_unmap_io;
+	}
+	mp->tx_dma_intr = macio_irq(mdev, 1);
+
+	mp->rx_dma = ioremap(macio_resource_start(mdev, 2), 0x1000);
+	if (mp->rx_dma == NULL) {
+		printk(KERN_ERR "MACE: can't map RX DMA resources !\n");
+		rc = -ENOMEM;
+		goto err_unmap_tx_dma;
+	}
+	mp->rx_dma_intr = macio_irq(mdev, 2);
+
+	mp->tx_cmds = (volatile struct dbdma_cmd *) DBDMA_ALIGN(mp + 1);
+	mp->rx_cmds = mp->tx_cmds + NCMDS_TX * N_TX_RING + 1;
+
+	memset((char *) mp->tx_cmds, 0,
+	       (NCMDS_TX*N_TX_RING + N_RX_RING + 2) * sizeof(struct dbdma_cmd));
+	init_timer(&mp->tx_timeout);
+	spin_lock_init(&mp->lock);
+	mp->timeout_active = 0;
+
+	if (port_aaui >= 0)
+		mp->port_aaui = port_aaui;
+	else {
+		/* Apple Network Server uses the AAUI port */
+		if (of_machine_is_compatible("AAPL,ShinerESB"))
+			mp->port_aaui = 1;
+		else {
+#ifdef CONFIG_MACE_AAUI_PORT
+			mp->port_aaui = 1;
+#else
+			mp->port_aaui = 0;
+#endif
+		}
+	}
+
+	dev->netdev_ops = &mace_netdev_ops;
+
+	/*
+	 * Most of what is below could be moved to mace_open()
+	 */
+	mace_reset(dev);
+
+	rc = request_irq(dev->irq, mace_interrupt, 0, "MACE", dev);
+	if (rc) {
+		printk(KERN_ERR "MACE: can't get irq %d\n", dev->irq);
+		goto err_unmap_rx_dma;
+	}
+	rc = request_irq(mp->tx_dma_intr, mace_txdma_intr, 0, "MACE-txdma", dev);
+	if (rc) {
+		printk(KERN_ERR "MACE: can't get irq %d\n", mp->tx_dma_intr);
+		goto err_free_irq;
+	}
+	rc = request_irq(mp->rx_dma_intr, mace_rxdma_intr, 0, "MACE-rxdma", dev);
+	if (rc) {
+		printk(KERN_ERR "MACE: can't get irq %d\n", mp->rx_dma_intr);
+		goto err_free_tx_irq;
+	}
+
+	rc = register_netdev(dev);
+	if (rc) {
+		printk(KERN_ERR "MACE: Cannot register net device, aborting.\n");
+		goto err_free_rx_irq;
+	}
+
+	printk(KERN_INFO "%s: MACE at %pM, chip revision %d.%d\n",
+	       dev->name, dev->dev_addr,
+	       mp->chipid >> 8, mp->chipid & 0xff);
+
+	return 0;
+
+ err_free_rx_irq:
+	free_irq(macio_irq(mdev, 2), dev);
+ err_free_tx_irq:
+	free_irq(macio_irq(mdev, 1), dev);
+ err_free_irq:
+	free_irq(macio_irq(mdev, 0), dev);
+ err_unmap_rx_dma:
+	iounmap(mp->rx_dma);
+ err_unmap_tx_dma:
+	iounmap(mp->tx_dma);
+ err_unmap_io:
+	iounmap(mp->mace);
+ err_free:
+	free_netdev(dev);
+ err_release:
+	macio_release_resources(mdev);
+
+	return rc;
+}
+
+static int __devexit mace_remove(struct macio_dev *mdev)
+{
+	struct net_device *dev = macio_get_drvdata(mdev);
+	struct mace_data *mp;
+
+	BUG_ON(dev == NULL);
+
+	macio_set_drvdata(mdev, NULL);
+
+	mp = netdev_priv(dev);
+
+	unregister_netdev(dev);
+
+	free_irq(dev->irq, dev);
+	free_irq(mp->tx_dma_intr, dev);
+	free_irq(mp->rx_dma_intr, dev);
+
+	iounmap(mp->rx_dma);
+	iounmap(mp->tx_dma);
+	iounmap(mp->mace);
+
+	free_netdev(dev);
+
+	macio_release_resources(mdev);
+
+	return 0;
+}
+
+static void dbdma_reset(volatile struct dbdma_regs __iomem *dma)
+{
+    int i;
+
+    out_le32(&dma->control, (WAKE|FLUSH|PAUSE|RUN) << 16);
+
+    /*
+     * Yes this looks peculiar, but apparently it needs to be this
+     * way on some machines.
+     */
+    for (i = 200; i > 0; --i)
+	if (ld_le32(&dma->control) & RUN)
+	    udelay(1);
+}
+
+static void mace_reset(struct net_device *dev)
+{
+    struct mace_data *mp = netdev_priv(dev);
+    volatile struct mace __iomem *mb = mp->mace;
+    int i;
+
+    /* soft-reset the chip */
+    i = 200;
+    while (--i) {
+	out_8(&mb->biucc, SWRST);
+	if (in_8(&mb->biucc) & SWRST) {
+	    udelay(10);
+	    continue;
+	}
+	break;
+    }
+    if (!i) {
+	printk(KERN_ERR "mace: cannot reset chip!\n");
+	return;
+    }
+
+    out_8(&mb->imr, 0xff);	/* disable all intrs for now */
+    i = in_8(&mb->ir);
+    out_8(&mb->maccc, 0);	/* turn off tx, rx */
+
+    out_8(&mb->biucc, XMTSP_64);
+    out_8(&mb->utr, RTRD);
+    out_8(&mb->fifocc, RCVFW_32 | XMTFW_16 | XMTFWU | RCVFWU | XMTBRST);
+    out_8(&mb->xmtfc, AUTO_PAD_XMIT); /* auto-pad short frames */
+    out_8(&mb->rcvfc, 0);
+
+    /* load up the hardware address */
+    __mace_set_address(dev, dev->dev_addr);
+
+    /* clear the multicast filter */
+    if (mp->chipid == BROKEN_ADDRCHG_REV)
+	out_8(&mb->iac, LOGADDR);
+    else {
+	out_8(&mb->iac, ADDRCHG | LOGADDR);
+	while ((in_8(&mb->iac) & ADDRCHG) != 0)
+		;
+    }
+    for (i = 0; i < 8; ++i)
+	out_8(&mb->ladrf, 0);
+
+    /* done changing address */
+    if (mp->chipid != BROKEN_ADDRCHG_REV)
+	out_8(&mb->iac, 0);
+
+    if (mp->port_aaui)
+    	out_8(&mb->plscc, PORTSEL_AUI + ENPLSIO);
+    else
+    	out_8(&mb->plscc, PORTSEL_GPSI + ENPLSIO);
+}
+
+static void __mace_set_address(struct net_device *dev, void *addr)
+{
+    struct mace_data *mp = netdev_priv(dev);
+    volatile struct mace __iomem *mb = mp->mace;
+    unsigned char *p = addr;
+    int i;
+
+    /* load up the hardware address */
+    if (mp->chipid == BROKEN_ADDRCHG_REV)
+    	out_8(&mb->iac, PHYADDR);
+    else {
+    	out_8(&mb->iac, ADDRCHG | PHYADDR);
+	while ((in_8(&mb->iac) & ADDRCHG) != 0)
+	    ;
+    }
+    for (i = 0; i < 6; ++i)
+	out_8(&mb->padr, dev->dev_addr[i] = p[i]);
+    if (mp->chipid != BROKEN_ADDRCHG_REV)
+        out_8(&mb->iac, 0);
+}
+
+static int mace_set_address(struct net_device *dev, void *addr)
+{
+    struct mace_data *mp = netdev_priv(dev);
+    volatile struct mace __iomem *mb = mp->mace;
+    unsigned long flags;
+
+    spin_lock_irqsave(&mp->lock, flags);
+
+    __mace_set_address(dev, addr);
+
+    /* note: setting ADDRCHG clears ENRCV */
+    out_8(&mb->maccc, mp->maccc);
+
+    spin_unlock_irqrestore(&mp->lock, flags);
+    return 0;
+}
+
+static inline void mace_clean_rings(struct mace_data *mp)
+{
+    int i;
+
+    /* free some skb's */
+    for (i = 0; i < N_RX_RING; ++i) {
+	if (mp->rx_bufs[i] != NULL) {
+	    dev_kfree_skb(mp->rx_bufs[i]);
+	    mp->rx_bufs[i] = NULL;
+	}
+    }
+    for (i = mp->tx_empty; i != mp->tx_fill; ) {
+	dev_kfree_skb(mp->tx_bufs[i]);
+	if (++i >= N_TX_RING)
+	    i = 0;
+    }
+}
+
+static int mace_open(struct net_device *dev)
+{
+    struct mace_data *mp = netdev_priv(dev);
+    volatile struct mace __iomem *mb = mp->mace;
+    volatile struct dbdma_regs __iomem *rd = mp->rx_dma;
+    volatile struct dbdma_regs __iomem *td = mp->tx_dma;
+    volatile struct dbdma_cmd *cp;
+    int i;
+    struct sk_buff *skb;
+    unsigned char *data;
+
+    /* reset the chip */
+    mace_reset(dev);
+
+    /* initialize list of sk_buffs for receiving and set up recv dma */
+    mace_clean_rings(mp);
+    memset((char *)mp->rx_cmds, 0, N_RX_RING * sizeof(struct dbdma_cmd));
+    cp = mp->rx_cmds;
+    for (i = 0; i < N_RX_RING - 1; ++i) {
+	skb = dev_alloc_skb(RX_BUFLEN + 2);
+	if (!skb) {
+	    data = dummy_buf;
+	} else {
+	    skb_reserve(skb, 2);	/* so IP header lands on 4-byte bdry */
+	    data = skb->data;
+	}
+	mp->rx_bufs[i] = skb;
+	st_le16(&cp->req_count, RX_BUFLEN);
+	st_le16(&cp->command, INPUT_LAST + INTR_ALWAYS);
+	st_le32(&cp->phy_addr, virt_to_bus(data));
+	cp->xfer_status = 0;
+	++cp;
+    }
+    mp->rx_bufs[i] = NULL;
+    st_le16(&cp->command, DBDMA_STOP);
+    mp->rx_fill = i;
+    mp->rx_empty = 0;
+
+    /* Put a branch back to the beginning of the receive command list */
+    ++cp;
+    st_le16(&cp->command, DBDMA_NOP + BR_ALWAYS);
+    st_le32(&cp->cmd_dep, virt_to_bus(mp->rx_cmds));
+
+    /* start rx dma */
+    out_le32(&rd->control, (RUN|PAUSE|FLUSH|WAKE) << 16); /* clear run bit */
+    out_le32(&rd->cmdptr, virt_to_bus(mp->rx_cmds));
+    out_le32(&rd->control, (RUN << 16) | RUN);
+
+    /* put a branch at the end of the tx command list */
+    cp = mp->tx_cmds + NCMDS_TX * N_TX_RING;
+    st_le16(&cp->command, DBDMA_NOP + BR_ALWAYS);
+    st_le32(&cp->cmd_dep, virt_to_bus(mp->tx_cmds));
+
+    /* reset tx dma */
+    out_le32(&td->control, (RUN|PAUSE|FLUSH|WAKE) << 16);
+    out_le32(&td->cmdptr, virt_to_bus(mp->tx_cmds));
+    mp->tx_fill = 0;
+    mp->tx_empty = 0;
+    mp->tx_fullup = 0;
+    mp->tx_active = 0;
+    mp->tx_bad_runt = 0;
+
+    /* turn it on! */
+    out_8(&mb->maccc, mp->maccc);
+    /* enable all interrupts except receive interrupts */
+    out_8(&mb->imr, RCVINT);
+
+    return 0;
+}
+
+static int mace_close(struct net_device *dev)
+{
+    struct mace_data *mp = netdev_priv(dev);
+    volatile struct mace __iomem *mb = mp->mace;
+    volatile struct dbdma_regs __iomem *rd = mp->rx_dma;
+    volatile struct dbdma_regs __iomem *td = mp->tx_dma;
+
+    /* disable rx and tx */
+    out_8(&mb->maccc, 0);
+    out_8(&mb->imr, 0xff);		/* disable all intrs */
+
+    /* disable rx and tx dma */
+    st_le32(&rd->control, (RUN|PAUSE|FLUSH|WAKE) << 16); /* clear run bit */
+    st_le32(&td->control, (RUN|PAUSE|FLUSH|WAKE) << 16); /* clear run bit */
+
+    mace_clean_rings(mp);
+
+    return 0;
+}
+
+static inline void mace_set_timeout(struct net_device *dev)
+{
+    struct mace_data *mp = netdev_priv(dev);
+
+    if (mp->timeout_active)
+	del_timer(&mp->tx_timeout);
+    mp->tx_timeout.expires = jiffies + TX_TIMEOUT;
+    mp->tx_timeout.function = mace_tx_timeout;
+    mp->tx_timeout.data = (unsigned long) dev;
+    add_timer(&mp->tx_timeout);
+    mp->timeout_active = 1;
+}
+
+static int mace_xmit_start(struct sk_buff *skb, struct net_device *dev)
+{
+    struct mace_data *mp = netdev_priv(dev);
+    volatile struct dbdma_regs __iomem *td = mp->tx_dma;
+    volatile struct dbdma_cmd *cp, *np;
+    unsigned long flags;
+    int fill, next, len;
+
+    /* see if there's a free slot in the tx ring */
+    spin_lock_irqsave(&mp->lock, flags);
+    fill = mp->tx_fill;
+    next = fill + 1;
+    if (next >= N_TX_RING)
+	next = 0;
+    if (next == mp->tx_empty) {
+	netif_stop_queue(dev);
+	mp->tx_fullup = 1;
+	spin_unlock_irqrestore(&mp->lock, flags);
+	return NETDEV_TX_BUSY;		/* can't take it at the moment */
+    }
+    spin_unlock_irqrestore(&mp->lock, flags);
+
+    /* partially fill in the dma command block */
+    len = skb->len;
+    if (len > ETH_FRAME_LEN) {
+	printk(KERN_DEBUG "mace: xmit frame too long (%d)\n", len);
+	len = ETH_FRAME_LEN;
+    }
+    mp->tx_bufs[fill] = skb;
+    cp = mp->tx_cmds + NCMDS_TX * fill;
+    st_le16(&cp->req_count, len);
+    st_le32(&cp->phy_addr, virt_to_bus(skb->data));
+
+    np = mp->tx_cmds + NCMDS_TX * next;
+    out_le16(&np->command, DBDMA_STOP);
+
+    /* poke the tx dma channel */
+    spin_lock_irqsave(&mp->lock, flags);
+    mp->tx_fill = next;
+    if (!mp->tx_bad_runt && mp->tx_active < MAX_TX_ACTIVE) {
+	out_le16(&cp->xfer_status, 0);
+	out_le16(&cp->command, OUTPUT_LAST);
+	out_le32(&td->control, ((RUN|WAKE) << 16) + (RUN|WAKE));
+	++mp->tx_active;
+	mace_set_timeout(dev);
+    }
+    if (++next >= N_TX_RING)
+	next = 0;
+    if (next == mp->tx_empty)
+	netif_stop_queue(dev);
+    spin_unlock_irqrestore(&mp->lock, flags);
+
+    return NETDEV_TX_OK;
+}
+
+static void mace_set_multicast(struct net_device *dev)
+{
+    struct mace_data *mp = netdev_priv(dev);
+    volatile struct mace __iomem *mb = mp->mace;
+    int i;
+    u32 crc;
+    unsigned long flags;
+
+    spin_lock_irqsave(&mp->lock, flags);
+    mp->maccc &= ~PROM;
+    if (dev->flags & IFF_PROMISC) {
+	mp->maccc |= PROM;
+    } else {
+	unsigned char multicast_filter[8];
+	struct netdev_hw_addr *ha;
+
+	if (dev->flags & IFF_ALLMULTI) {
+	    for (i = 0; i < 8; i++)
+		multicast_filter[i] = 0xff;
+	} else {
+	    for (i = 0; i < 8; i++)
+		multicast_filter[i] = 0;
+	    netdev_for_each_mc_addr(ha, dev) {
+	        crc = ether_crc_le(6, ha->addr);
+		i = crc >> 26;	/* bit number in multicast_filter */
+		multicast_filter[i >> 3] |= 1 << (i & 7);
+	    }
+	}
+#if 0
+	printk("Multicast filter :");
+	for (i = 0; i < 8; i++)
+	    printk("%02x ", multicast_filter[i]);
+	printk("\n");
+#endif
+
+	if (mp->chipid == BROKEN_ADDRCHG_REV)
+	    out_8(&mb->iac, LOGADDR);
+	else {
+	    out_8(&mb->iac, ADDRCHG | LOGADDR);
+	    while ((in_8(&mb->iac) & ADDRCHG) != 0)
+		;
+	}
+	for (i = 0; i < 8; ++i)
+	    out_8(&mb->ladrf, multicast_filter[i]);
+	if (mp->chipid != BROKEN_ADDRCHG_REV)
+	    out_8(&mb->iac, 0);
+    }
+    /* reset maccc */
+    out_8(&mb->maccc, mp->maccc);
+    spin_unlock_irqrestore(&mp->lock, flags);
+}
+
+static void mace_handle_misc_intrs(struct mace_data *mp, int intr, struct net_device *dev)
+{
+    volatile struct mace __iomem *mb = mp->mace;
+    static int mace_babbles, mace_jabbers;
+
+    if (intr & MPCO)
+	dev->stats.rx_missed_errors += 256;
+    dev->stats.rx_missed_errors += in_8(&mb->mpc);   /* reading clears it */
+    if (intr & RNTPCO)
+	dev->stats.rx_length_errors += 256;
+    dev->stats.rx_length_errors += in_8(&mb->rntpc); /* reading clears it */
+    if (intr & CERR)
+	++dev->stats.tx_heartbeat_errors;
+    if (intr & BABBLE)
+	if (mace_babbles++ < 4)
+	    printk(KERN_DEBUG "mace: babbling transmitter\n");
+    if (intr & JABBER)
+	if (mace_jabbers++ < 4)
+	    printk(KERN_DEBUG "mace: jabbering transceiver\n");
+}
+
+static irqreturn_t mace_interrupt(int irq, void *dev_id)
+{
+    struct net_device *dev = (struct net_device *) dev_id;
+    struct mace_data *mp = netdev_priv(dev);
+    volatile struct mace __iomem *mb = mp->mace;
+    volatile struct dbdma_regs __iomem *td = mp->tx_dma;
+    volatile struct dbdma_cmd *cp;
+    int intr, fs, i, stat, x;
+    int xcount, dstat;
+    unsigned long flags;
+    /* static int mace_last_fs, mace_last_xcount; */
+
+    spin_lock_irqsave(&mp->lock, flags);
+    intr = in_8(&mb->ir);		/* read interrupt register */
+    in_8(&mb->xmtrc);			/* get retries */
+    mace_handle_misc_intrs(mp, intr, dev);
+
+    i = mp->tx_empty;
+    while (in_8(&mb->pr) & XMTSV) {
+	del_timer(&mp->tx_timeout);
+	mp->timeout_active = 0;
+	/*
+	 * Clear any interrupt indication associated with this status
+	 * word.  This appears to unlatch any error indication from
+	 * the DMA controller.
+	 */
+	intr = in_8(&mb->ir);
+	if (intr != 0)
+	    mace_handle_misc_intrs(mp, intr, dev);
+	if (mp->tx_bad_runt) {
+	    fs = in_8(&mb->xmtfs);
+	    mp->tx_bad_runt = 0;
+	    out_8(&mb->xmtfc, AUTO_PAD_XMIT);
+	    continue;
+	}
+	dstat = ld_le32(&td->status);
+	/* stop DMA controller */
+	out_le32(&td->control, RUN << 16);
+	/*
+	 * xcount is the number of complete frames which have been
+	 * written to the fifo but for which status has not been read.
+	 */
+	xcount = (in_8(&mb->fifofc) >> XMTFC_SH) & XMTFC_MASK;
+	if (xcount == 0 || (dstat & DEAD)) {
+	    /*
+	     * If a packet was aborted before the DMA controller has
+	     * finished transferring it, it seems that there are 2 bytes
+	     * which are stuck in some buffer somewhere.  These will get
+	     * transmitted as soon as we read the frame status (which
+	     * reenables the transmit data transfer request).  Turning
+	     * off the DMA controller and/or resetting the MACE doesn't
+	     * help.  So we disable auto-padding and FCS transmission
+	     * so the two bytes will only be a runt packet which should
+	     * be ignored by other stations.
+	     */
+	    out_8(&mb->xmtfc, DXMTFCS);
+	}
+	fs = in_8(&mb->xmtfs);
+	if ((fs & XMTSV) == 0) {
+	    printk(KERN_ERR "mace: xmtfs not valid! (fs=%x xc=%d ds=%x)\n",
+		   fs, xcount, dstat);
+	    mace_reset(dev);
+		/*
+		 * XXX mace likes to hang the machine after a xmtfs error.
+		 * This is hard to reproduce, reseting *may* help
+		 */
+	}
+	cp = mp->tx_cmds + NCMDS_TX * i;
+	stat = ld_le16(&cp->xfer_status);
+	if ((fs & (UFLO|LCOL|LCAR|RTRY)) || (dstat & DEAD) || xcount == 0) {
+	    /*
+	     * Check whether there were in fact 2 bytes written to
+	     * the transmit FIFO.
+	     */
+	    udelay(1);
+	    x = (in_8(&mb->fifofc) >> XMTFC_SH) & XMTFC_MASK;
+	    if (x != 0) {
+		/* there were two bytes with an end-of-packet indication */
+		mp->tx_bad_runt = 1;
+		mace_set_timeout(dev);
+	    } else {
+		/*
+		 * Either there weren't the two bytes buffered up, or they
+		 * didn't have an end-of-packet indication.
+		 * We flush the transmit FIFO just in case (by setting the
+		 * XMTFWU bit with the transmitter disabled).
+		 */
+		out_8(&mb->maccc, in_8(&mb->maccc) & ~ENXMT);
+		out_8(&mb->fifocc, in_8(&mb->fifocc) | XMTFWU);
+		udelay(1);
+		out_8(&mb->maccc, in_8(&mb->maccc) | ENXMT);
+		out_8(&mb->xmtfc, AUTO_PAD_XMIT);
+	    }
+	}
+	/* dma should have finished */
+	if (i == mp->tx_fill) {
+	    printk(KERN_DEBUG "mace: tx ring ran out? (fs=%x xc=%d ds=%x)\n",
+		   fs, xcount, dstat);
+	    continue;
+	}
+	/* Update stats */
+	if (fs & (UFLO|LCOL|LCAR|RTRY)) {
+	    ++dev->stats.tx_errors;
+	    if (fs & LCAR)
+		++dev->stats.tx_carrier_errors;
+	    if (fs & (UFLO|LCOL|RTRY))
+		++dev->stats.tx_aborted_errors;
+	} else {
+	    dev->stats.tx_bytes += mp->tx_bufs[i]->len;
+	    ++dev->stats.tx_packets;
+	}
+	dev_kfree_skb_irq(mp->tx_bufs[i]);
+	--mp->tx_active;
+	if (++i >= N_TX_RING)
+	    i = 0;
+#if 0
+	mace_last_fs = fs;
+	mace_last_xcount = xcount;
+#endif
+    }
+
+    if (i != mp->tx_empty) {
+	mp->tx_fullup = 0;
+	netif_wake_queue(dev);
+    }
+    mp->tx_empty = i;
+    i += mp->tx_active;
+    if (i >= N_TX_RING)
+	i -= N_TX_RING;
+    if (!mp->tx_bad_runt && i != mp->tx_fill && mp->tx_active < MAX_TX_ACTIVE) {
+	do {
+	    /* set up the next one */
+	    cp = mp->tx_cmds + NCMDS_TX * i;
+	    out_le16(&cp->xfer_status, 0);
+	    out_le16(&cp->command, OUTPUT_LAST);
+	    ++mp->tx_active;
+	    if (++i >= N_TX_RING)
+		i = 0;
+	} while (i != mp->tx_fill && mp->tx_active < MAX_TX_ACTIVE);
+	out_le32(&td->control, ((RUN|WAKE) << 16) + (RUN|WAKE));
+	mace_set_timeout(dev);
+    }
+    spin_unlock_irqrestore(&mp->lock, flags);
+    return IRQ_HANDLED;
+}
+
+static void mace_tx_timeout(unsigned long data)
+{
+    struct net_device *dev = (struct net_device *) data;
+    struct mace_data *mp = netdev_priv(dev);
+    volatile struct mace __iomem *mb = mp->mace;
+    volatile struct dbdma_regs __iomem *td = mp->tx_dma;
+    volatile struct dbdma_regs __iomem *rd = mp->rx_dma;
+    volatile struct dbdma_cmd *cp;
+    unsigned long flags;
+    int i;
+
+    spin_lock_irqsave(&mp->lock, flags);
+    mp->timeout_active = 0;
+    if (mp->tx_active == 0 && !mp->tx_bad_runt)
+	goto out;
+
+    /* update various counters */
+    mace_handle_misc_intrs(mp, in_8(&mb->ir), dev);
+
+    cp = mp->tx_cmds + NCMDS_TX * mp->tx_empty;
+
+    /* turn off both tx and rx and reset the chip */
+    out_8(&mb->maccc, 0);
+    printk(KERN_ERR "mace: transmit timeout - resetting\n");
+    dbdma_reset(td);
+    mace_reset(dev);
+
+    /* restart rx dma */
+    cp = bus_to_virt(ld_le32(&rd->cmdptr));
+    dbdma_reset(rd);
+    out_le16(&cp->xfer_status, 0);
+    out_le32(&rd->cmdptr, virt_to_bus(cp));
+    out_le32(&rd->control, (RUN << 16) | RUN);
+
+    /* fix up the transmit side */
+    i = mp->tx_empty;
+    mp->tx_active = 0;
+    ++dev->stats.tx_errors;
+    if (mp->tx_bad_runt) {
+	mp->tx_bad_runt = 0;
+    } else if (i != mp->tx_fill) {
+	dev_kfree_skb(mp->tx_bufs[i]);
+	if (++i >= N_TX_RING)
+	    i = 0;
+	mp->tx_empty = i;
+    }
+    mp->tx_fullup = 0;
+    netif_wake_queue(dev);
+    if (i != mp->tx_fill) {
+	cp = mp->tx_cmds + NCMDS_TX * i;
+	out_le16(&cp->xfer_status, 0);
+	out_le16(&cp->command, OUTPUT_LAST);
+	out_le32(&td->cmdptr, virt_to_bus(cp));
+	out_le32(&td->control, (RUN << 16) | RUN);
+	++mp->tx_active;
+	mace_set_timeout(dev);
+    }
+
+    /* turn it back on */
+    out_8(&mb->imr, RCVINT);
+    out_8(&mb->maccc, mp->maccc);
+
+out:
+    spin_unlock_irqrestore(&mp->lock, flags);
+}
+
+static irqreturn_t mace_txdma_intr(int irq, void *dev_id)
+{
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t mace_rxdma_intr(int irq, void *dev_id)
+{
+    struct net_device *dev = (struct net_device *) dev_id;
+    struct mace_data *mp = netdev_priv(dev);
+    volatile struct dbdma_regs __iomem *rd = mp->rx_dma;
+    volatile struct dbdma_cmd *cp, *np;
+    int i, nb, stat, next;
+    struct sk_buff *skb;
+    unsigned frame_status;
+    static int mace_lost_status;
+    unsigned char *data;
+    unsigned long flags;
+
+    spin_lock_irqsave(&mp->lock, flags);
+    for (i = mp->rx_empty; i != mp->rx_fill; ) {
+	cp = mp->rx_cmds + i;
+	stat = ld_le16(&cp->xfer_status);
+	if ((stat & ACTIVE) == 0) {
+	    next = i + 1;
+	    if (next >= N_RX_RING)
+		next = 0;
+	    np = mp->rx_cmds + next;
+	    if (next != mp->rx_fill &&
+		(ld_le16(&np->xfer_status) & ACTIVE) != 0) {
+		printk(KERN_DEBUG "mace: lost a status word\n");
+		++mace_lost_status;
+	    } else
+		break;
+	}
+	nb = ld_le16(&cp->req_count) - ld_le16(&cp->res_count);
+	out_le16(&cp->command, DBDMA_STOP);
+	/* got a packet, have a look at it */
+	skb = mp->rx_bufs[i];
+	if (!skb) {
+	    ++dev->stats.rx_dropped;
+	} else if (nb > 8) {
+	    data = skb->data;
+	    frame_status = (data[nb-3] << 8) + data[nb-4];
+	    if (frame_status & (RS_OFLO|RS_CLSN|RS_FRAMERR|RS_FCSERR)) {
+		++dev->stats.rx_errors;
+		if (frame_status & RS_OFLO)
+		    ++dev->stats.rx_over_errors;
+		if (frame_status & RS_FRAMERR)
+		    ++dev->stats.rx_frame_errors;
+		if (frame_status & RS_FCSERR)
+		    ++dev->stats.rx_crc_errors;
+	    } else {
+		/* Mace feature AUTO_STRIP_RCV is on by default, dropping the
+		 * FCS on frames with 802.3 headers. This means that Ethernet
+		 * frames have 8 extra octets at the end, while 802.3 frames
+		 * have only 4. We need to correctly account for this. */
+		if (*(unsigned short *)(data+12) < 1536) /* 802.3 header */
+		    nb -= 4;
+		else	/* Ethernet header; mace includes FCS */
+		    nb -= 8;
+		skb_put(skb, nb);
+		skb->protocol = eth_type_trans(skb, dev);
+		dev->stats.rx_bytes += skb->len;
+		netif_rx(skb);
+		mp->rx_bufs[i] = NULL;
+		++dev->stats.rx_packets;
+	    }
+	} else {
+	    ++dev->stats.rx_errors;
+	    ++dev->stats.rx_length_errors;
+	}
+
+	/* advance to next */
+	if (++i >= N_RX_RING)
+	    i = 0;
+    }
+    mp->rx_empty = i;
+
+    i = mp->rx_fill;
+    for (;;) {
+	next = i + 1;
+	if (next >= N_RX_RING)
+	    next = 0;
+	if (next == mp->rx_empty)
+	    break;
+	cp = mp->rx_cmds + i;
+	skb = mp->rx_bufs[i];
+	if (!skb) {
+	    skb = dev_alloc_skb(RX_BUFLEN + 2);
+	    if (skb) {
+		skb_reserve(skb, 2);
+		mp->rx_bufs[i] = skb;
+	    }
+	}
+	st_le16(&cp->req_count, RX_BUFLEN);
+	data = skb? skb->data: dummy_buf;
+	st_le32(&cp->phy_addr, virt_to_bus(data));
+	out_le16(&cp->xfer_status, 0);
+	out_le16(&cp->command, INPUT_LAST + INTR_ALWAYS);
+#if 0
+	if ((ld_le32(&rd->status) & ACTIVE) != 0) {
+	    out_le32(&rd->control, (PAUSE << 16) | PAUSE);
+	    while ((in_le32(&rd->status) & ACTIVE) != 0)
+		;
+	}
+#endif
+	i = next;
+    }
+    if (i != mp->rx_fill) {
+	out_le32(&rd->control, ((RUN|WAKE) << 16) | (RUN|WAKE));
+	mp->rx_fill = i;
+    }
+    spin_unlock_irqrestore(&mp->lock, flags);
+    return IRQ_HANDLED;
+}
+
+static struct of_device_id mace_match[] =
+{
+	{
+	.name 		= "mace",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE (of, mace_match);
+
+static struct macio_driver mace_driver =
+{
+	.driver = {
+		.name 		= "mace",
+		.owner		= THIS_MODULE,
+		.of_match_table	= mace_match,
+	},
+	.probe		= mace_probe,
+	.remove		= mace_remove,
+};
+
+
+static int __init mace_init(void)
+{
+	return macio_register_driver(&mace_driver);
+}
+
+static void __exit mace_cleanup(void)
+{
+	macio_unregister_driver(&mace_driver);
+
+	kfree(dummy_buf);
+	dummy_buf = NULL;
+}
+
+MODULE_AUTHOR("Paul Mackerras");
+MODULE_DESCRIPTION("PowerMac MACE driver.");
+module_param(port_aaui, int, 0);
+MODULE_PARM_DESC(port_aaui, "MACE uses AAUI port (0-1)");
+MODULE_LICENSE("GPL");
+
+module_init(mace_init);
+module_exit(mace_cleanup);
