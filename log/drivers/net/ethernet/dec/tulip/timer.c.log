commit a8c22a2bbc67d001479696c5696ae11c84116701
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Oct 16 17:29:05 2017 -0700

    net: tulip: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Jarod Wilson <jarod@redhat.com>
    Cc: Stephen Hemminger <stephen@networkplumber.org>
    Cc: Johannes Berg <johannes.berg@intel.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Philippe Reynes <tremyfr@gmail.com>
    Cc: "yuval.shaia@oracle.com" <yuval.shaia@oracle.com>
    Cc: netdev@vger.kernel.org
    Cc: linux-parisc@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dec/tulip/timer.c b/drivers/net/ethernet/dec/tulip/timer.c
index 523d9dde50a2..642e9dfc5451 100644
--- a/drivers/net/ethernet/dec/tulip/timer.c
+++ b/drivers/net/ethernet/dec/tulip/timer.c
@@ -137,10 +137,10 @@ void tulip_media_task(struct work_struct *work)
 }
 
 
-void mxic_timer(unsigned long data)
+void mxic_timer(struct timer_list *t)
 {
-	struct net_device *dev = (struct net_device *)data;
-	struct tulip_private *tp = netdev_priv(dev);
+	struct tulip_private *tp = from_timer(tp, t, timer);
+	struct net_device *dev = tp->dev;
 	void __iomem *ioaddr = tp->base_addr;
 	int next_tick = 60*HZ;
 
@@ -154,10 +154,10 @@ void mxic_timer(unsigned long data)
 }
 
 
-void comet_timer(unsigned long data)
+void comet_timer(struct timer_list *t)
 {
-	struct net_device *dev = (struct net_device *)data;
-	struct tulip_private *tp = netdev_priv(dev);
+	struct tulip_private *tp = from_timer(tp, t, timer);
+	struct net_device *dev = tp->dev;
 	int next_tick = 2*HZ;
 
 	if (tulip_debug > 1)

commit 143fa2efea137d24baee3c5920fb7b0dacc09b6c
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Sun Jun 22 12:01:12 2014 +0200

    tulip: Poll link status more frequently for Comet chips
    
    It now takes up to 60 seconds to detect cable (un)plug on ADMtek Comet chips.
    That's too slow and might cause people to think that it doesn't work at all.
    
    Poll link status every 2 seconds instead of 60 for ADMtek Comet chips.
    That should be fast enough while not stressing the system too much.
    
    Tested with ADMtek AN983B.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dec/tulip/timer.c b/drivers/net/ethernet/dec/tulip/timer.c
index 768379b8aee9..523d9dde50a2 100644
--- a/drivers/net/ethernet/dec/tulip/timer.c
+++ b/drivers/net/ethernet/dec/tulip/timer.c
@@ -158,7 +158,7 @@ void comet_timer(unsigned long data)
 {
 	struct net_device *dev = (struct net_device *)data;
 	struct tulip_private *tp = netdev_priv(dev);
-	int next_tick = 60*HZ;
+	int next_tick = 2*HZ;
 
 	if (tulip_debug > 1)
 		netdev_dbg(dev, "Comet link status %04x partner capability %04x\n",

commit 3396c7823efb3a5b8630388c464e1034ea031ced
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jan 27 13:36:01 2012 +0000

    drivers/net: fix up stale paths from driver reorg
    
    The reorganization of the driver layout in drivers/net
    left behind some stale paths in comments and in Kconfig
    help text.  Bring them up to date.  No actual change to
    any code takes place here.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    CC: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dec/tulip/timer.c b/drivers/net/ethernet/dec/tulip/timer.c
index 19078d28ffb9..768379b8aee9 100644
--- a/drivers/net/ethernet/dec/tulip/timer.c
+++ b/drivers/net/ethernet/dec/tulip/timer.c
@@ -1,5 +1,5 @@
 /*
-	drivers/net/tulip/timer.c
+	drivers/net/ethernet/dec/tulip/timer.c
 
 	Copyright 2000,2001  The Linux Kernel Team
 	Written/copyright 1994-2001 by Donald Becker.

commit 8a9ea3237e7eb5c25f09e429ad242ae5a3d5ea22
Merge: 1be025d3cb40 8b3408f8ee99
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 25 13:25:22 2011 +0200

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next: (1745 commits)
      dp83640: free packet queues on remove
      dp83640: use proper function to free transmit time stamping packets
      ipv6: Do not use routes from locally generated RAs
      |PATCH net-next] tg3: add tx_dropped counter
      be2net: don't create multiple RX/TX rings in multi channel mode
      be2net: don't create multiple TXQs in BE2
      be2net: refactor VF setup/teardown code into be_vf_setup/clear()
      be2net: add vlan/rx-mode/flow-control config to be_setup()
      net_sched: cls_flow: use skb_header_pointer()
      ipv4: avoid useless call of the function check_peer_pmtu
      TCP: remove TCP_DEBUG
      net: Fix driver name for mdio-gpio.c
      ipv4: tcp: fix TOS value in ACK messages sent from TIME_WAIT
      rtnetlink: Add missing manual netlink notification in dev_change_net_namespaces
      ipv4: fix ipsec forward performance regression
      jme: fix irq storm after suspend/resume
      route: fix ICMP redirect validation
      net: hold sock reference while processing tx timestamps
      tcp: md5: add more const attributes
      Add ethtool -g support to virtio_net
      ...
    
    Fix up conflicts in:
     - drivers/net/Kconfig:
            The split-up generated a trivial conflict with removal of a
            stale reference to Documentation/networking/net-modules.txt.
            Remove it from the new location instead.
     - fs/sysfs/dir.c:
            Fairly nasty conflicts with the sysfs rb-tree usage, conflicting
            with Eric Biederman's changes for tagged directories.

commit a88394cfb58007cca945699545469017beb0d206
Author: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Date:   Fri May 20 07:15:19 2011 -0700

    ewrk3/tulip: Move the DEC - Tulip drivers
    
    Move the DEC - Tulip driver into drivers/net/ethernet/dec/tulip/
    and make the necessary Kconfig and Makefile changes.
    
    The Digital Equioment (DEC) driver ewrk3 was moved into
    drivers/net/ethernet/dec/ and the remaining drivers (Tulip)
    were moved into drivers/net/ethernet/dec/tulip/
    
    CC: Tobias Ringstrom <tori@unhappy.mine.nu>
    CC: Grant Grundler <grundler@parisc-linux.org>
    CC: David Davies <davies@maniac.ultranet.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Acked-by: Grant Grundler <grundler@parisc-linux.org>

diff --git a/drivers/net/ethernet/dec/tulip/timer.c b/drivers/net/ethernet/dec/tulip/timer.c
new file mode 100644
index 000000000000..2017faf2d0e6
--- /dev/null
+++ b/drivers/net/ethernet/dec/tulip/timer.c
@@ -0,0 +1,179 @@
+/*
+	drivers/net/tulip/timer.c
+
+	Copyright 2000,2001  The Linux Kernel Team
+	Written/copyright 1994-2001 by Donald Becker.
+
+	This software may be used and distributed according to the terms
+	of the GNU General Public License, incorporated herein by reference.
+
+	Please refer to Documentation/DocBook/tulip-user.{pdf,ps,html}
+	for more information on this driver.
+
+	Please submit bugs to http://bugzilla.kernel.org/ .
+*/
+
+
+#include "tulip.h"
+
+
+void tulip_media_task(struct work_struct *work)
+{
+	struct tulip_private *tp =
+		container_of(work, struct tulip_private, media_work);
+	struct net_device *dev = tp->dev;
+	void __iomem *ioaddr = tp->base_addr;
+	u32 csr12 = ioread32(ioaddr + CSR12);
+	int next_tick = 2*HZ;
+	unsigned long flags;
+
+	if (tulip_debug > 2) {
+		netdev_dbg(dev, "Media selection tick, %s, status %08x mode %08x SIA %08x %08x %08x %08x\n",
+			   medianame[dev->if_port],
+			   ioread32(ioaddr + CSR5), ioread32(ioaddr + CSR6),
+			   csr12, ioread32(ioaddr + CSR13),
+			   ioread32(ioaddr + CSR14), ioread32(ioaddr + CSR15));
+	}
+	switch (tp->chip_id) {
+	case DC21140:
+	case DC21142:
+	case MX98713:
+	case COMPEX9881:
+	case DM910X:
+	default: {
+		struct medialeaf *mleaf;
+		unsigned char *p;
+		if (tp->mtable == NULL) {	/* No EEPROM info, use generic code. */
+			/* Not much that can be done.
+			   Assume this a generic MII or SYM transceiver. */
+			next_tick = 60*HZ;
+			if (tulip_debug > 2)
+				netdev_dbg(dev, "network media monitor CSR6 %08x CSR12 0x%02x\n",
+					   ioread32(ioaddr + CSR6),
+					   csr12 & 0xff);
+			break;
+		}
+		mleaf = &tp->mtable->mleaf[tp->cur_index];
+		p = mleaf->leafdata;
+		switch (mleaf->type) {
+		case 0: case 4: {
+			/* Type 0 serial or 4 SYM transceiver.  Check the link beat bit. */
+			int offset = mleaf->type == 4 ? 5 : 2;
+			s8 bitnum = p[offset];
+			if (p[offset+1] & 0x80) {
+				if (tulip_debug > 1)
+					netdev_dbg(dev, "Transceiver monitor tick CSR12=%#02x, no media sense\n",
+						   csr12);
+				if (mleaf->type == 4) {
+					if (mleaf->media == 3 && (csr12 & 0x02))
+						goto select_next_media;
+				}
+				break;
+			}
+			if (tulip_debug > 2)
+				netdev_dbg(dev, "Transceiver monitor tick: CSR12=%#02x bit %d is %d, expecting %d\n",
+					   csr12, (bitnum >> 1) & 7,
+					   (csr12 & (1 << ((bitnum >> 1) & 7))) != 0,
+					   (bitnum >= 0));
+			/* Check that the specified bit has the proper value. */
+			if ((bitnum < 0) !=
+				((csr12 & (1 << ((bitnum >> 1) & 7))) != 0)) {
+				if (tulip_debug > 2)
+					netdev_dbg(dev, "Link beat detected for %s\n",
+						   medianame[mleaf->media & MEDIA_MASK]);
+				if ((p[2] & 0x61) == 0x01)	/* Bogus Znyx board. */
+					goto actually_mii;
+				netif_carrier_on(dev);
+				break;
+			}
+			netif_carrier_off(dev);
+			if (tp->medialock)
+				break;
+	  select_next_media:
+			if (--tp->cur_index < 0) {
+				/* We start again, but should instead look for default. */
+				tp->cur_index = tp->mtable->leafcount - 1;
+			}
+			dev->if_port = tp->mtable->mleaf[tp->cur_index].media;
+			if (tulip_media_cap[dev->if_port] & MediaIsFD)
+				goto select_next_media; /* Skip FD entries. */
+			if (tulip_debug > 1)
+				netdev_dbg(dev, "No link beat on media %s, trying transceiver type %s\n",
+					   medianame[mleaf->media & MEDIA_MASK],
+					   medianame[tp->mtable->mleaf[tp->cur_index].media]);
+			tulip_select_media(dev, 0);
+			/* Restart the transmit process. */
+			tulip_restart_rxtx(tp);
+			next_tick = (24*HZ)/10;
+			break;
+		}
+		case 1:  case 3:		/* 21140, 21142 MII */
+		actually_mii:
+			if (tulip_check_duplex(dev) < 0) {
+				netif_carrier_off(dev);
+				next_tick = 3*HZ;
+			} else {
+				netif_carrier_on(dev);
+				next_tick = 60*HZ;
+			}
+			break;
+		case 2:					/* 21142 serial block has no link beat. */
+		default:
+			break;
+		}
+	}
+	break;
+	}
+
+
+	spin_lock_irqsave(&tp->lock, flags);
+	if (tp->timeout_recovery) {
+		tulip_tx_timeout_complete(tp, ioaddr);
+		tp->timeout_recovery = 0;
+	}
+	spin_unlock_irqrestore(&tp->lock, flags);
+
+	/* mod_timer synchronizes us with potential add_timer calls
+	 * from interrupts.
+	 */
+	mod_timer(&tp->timer, RUN_AT(next_tick));
+}
+
+
+void mxic_timer(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct tulip_private *tp = netdev_priv(dev);
+	void __iomem *ioaddr = tp->base_addr;
+	int next_tick = 60*HZ;
+
+	if (tulip_debug > 3) {
+		dev_info(&dev->dev, "MXIC negotiation status %08x\n",
+			 ioread32(ioaddr + CSR12));
+	}
+	if (next_tick) {
+		mod_timer(&tp->timer, RUN_AT(next_tick));
+	}
+}
+
+
+void comet_timer(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct tulip_private *tp = netdev_priv(dev);
+	int next_tick = 60*HZ;
+
+	if (tulip_debug > 1)
+		netdev_dbg(dev, "Comet link status %04x partner capability %04x\n",
+			   tulip_mdio_read(dev, tp->phys[0], 1),
+			   tulip_mdio_read(dev, tp->phys[0], 5));
+	/* mod_timer synchronizes us with potential add_timer calls
+	 * from interrupts.
+	 */
+	if (tulip_check_duplex(dev) < 0)
+		{ netif_carrier_off(dev); }
+	else
+		{ netif_carrier_on(dev); }
+	mod_timer(&tp->timer, RUN_AT(next_tick));
+}
+
