commit a8c22a2bbc67d001479696c5696ae11c84116701
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Oct 16 17:29:05 2017 -0700

    net: tulip: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Jarod Wilson <jarod@redhat.com>
    Cc: Stephen Hemminger <stephen@networkplumber.org>
    Cc: Johannes Berg <johannes.berg@intel.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Philippe Reynes <tremyfr@gmail.com>
    Cc: "yuval.shaia@oracle.com" <yuval.shaia@oracle.com>
    Cc: netdev@vger.kernel.org
    Cc: linux-parisc@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dec/tulip/pnic.c b/drivers/net/ethernet/dec/tulip/pnic.c
index 7bcccf5cac7a..3fb39e32e1b4 100644
--- a/drivers/net/ethernet/dec/tulip/pnic.c
+++ b/drivers/net/ethernet/dec/tulip/pnic.c
@@ -84,10 +84,10 @@ void pnic_lnk_change(struct net_device *dev, int csr5)
 	}
 }
 
-void pnic_timer(unsigned long data)
+void pnic_timer(struct timer_list *t)
 {
-	struct net_device *dev = (struct net_device *)data;
-	struct tulip_private *tp = netdev_priv(dev);
+	struct tulip_private *tp = from_timer(tp, t, timer);
+	struct net_device *dev = tp->dev;
 	void __iomem *ioaddr = tp->base_addr;
 	int next_tick = 60*HZ;
 

commit 860e9538a9482bb84589f7d0718a7e6d0a944d58
Author: Florian Westphal <fw@strlen.de>
Date:   Tue May 3 16:33:13 2016 +0200

    treewide: replace dev->trans_start update with helper
    
    Replace all trans_start updates with netif_trans_update helper.
    change was done via spatch:
    
    struct net_device *d;
    @@
    - d->trans_start = jiffies
    + netif_trans_update(d)
    
    Compile tested only.
    
    Cc: user-mode-linux-devel@lists.sourceforge.net
    Cc: linux-xtensa@linux-xtensa.org
    Cc: linux1394-devel@lists.sourceforge.net
    Cc: linux-rdma@vger.kernel.org
    Cc: netdev@vger.kernel.org
    Cc: MPT-FusionLinux.pdl@broadcom.com
    Cc: linux-scsi@vger.kernel.org
    Cc: linux-can@vger.kernel.org
    Cc: linux-parisc@vger.kernel.org
    Cc: linux-omap@vger.kernel.org
    Cc: linux-hams@vger.kernel.org
    Cc: linux-usb@vger.kernel.org
    Cc: linux-wireless@vger.kernel.org
    Cc: linux-s390@vger.kernel.org
    Cc: devel@driverdev.osuosl.org
    Cc: b.a.t.m.a.n@lists.open-mesh.org
    Cc: linux-bluetooth@vger.kernel.org
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Mugunthan V N <mugunthanvnm@ti.com>
    Acked-by: Antonio Quartulli <a@unstable.cc>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dec/tulip/pnic.c b/drivers/net/ethernet/dec/tulip/pnic.c
index 5364563c4378..7bcccf5cac7a 100644
--- a/drivers/net/ethernet/dec/tulip/pnic.c
+++ b/drivers/net/ethernet/dec/tulip/pnic.c
@@ -44,7 +44,7 @@ void pnic_do_nway(struct net_device *dev)
 			tp->csr6 = new_csr6;
 			/* Restart Tx */
 			tulip_restart_rxtx(tp);
-			dev->trans_start = jiffies;
+			netif_trans_update(dev);
 		}
 	}
 }
@@ -70,7 +70,7 @@ void pnic_lnk_change(struct net_device *dev, int csr5)
 			iowrite32(tp->csr6, ioaddr + CSR6);
 			iowrite32(0x30, ioaddr + CSR12);
 			iowrite32(0x0201F078, ioaddr + 0xB8); /* Turn on autonegotiation. */
-			dev->trans_start = jiffies;
+			netif_trans_update(dev);
 		}
 	} else if (ioread32(ioaddr + CSR5) & TPLnkPass) {
 		if (tulip_media_cap[dev->if_port] & MediaIsMII) {
@@ -147,7 +147,7 @@ void pnic_timer(unsigned long data)
 				tp->csr6 = new_csr6;
 				/* Restart Tx */
 				tulip_restart_rxtx(tp);
-				dev->trans_start = jiffies;
+				netif_trans_update(dev);
 				if (tulip_debug > 1)
 					dev_info(&dev->dev,
 						 "Changing PNIC configuration to %s %s-duplex, CSR6 %08x\n",

commit 3396c7823efb3a5b8630388c464e1034ea031ced
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jan 27 13:36:01 2012 +0000

    drivers/net: fix up stale paths from driver reorg
    
    The reorganization of the driver layout in drivers/net
    left behind some stale paths in comments and in Kconfig
    help text.  Bring them up to date.  No actual change to
    any code takes place here.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    CC: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dec/tulip/pnic.c b/drivers/net/ethernet/dec/tulip/pnic.c
index 9c16e4ad02a6..5364563c4378 100644
--- a/drivers/net/ethernet/dec/tulip/pnic.c
+++ b/drivers/net/ethernet/dec/tulip/pnic.c
@@ -1,5 +1,5 @@
 /*
-	drivers/net/tulip/pnic.c
+	drivers/net/ethernet/dec/tulip/pnic.c
 
 	Copyright 2000,2001  The Linux Kernel Team
 	Written/copyright 1994-2001 by Donald Becker.

commit 8a9ea3237e7eb5c25f09e429ad242ae5a3d5ea22
Merge: 1be025d3cb40 8b3408f8ee99
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 25 13:25:22 2011 +0200

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next: (1745 commits)
      dp83640: free packet queues on remove
      dp83640: use proper function to free transmit time stamping packets
      ipv6: Do not use routes from locally generated RAs
      |PATCH net-next] tg3: add tx_dropped counter
      be2net: don't create multiple RX/TX rings in multi channel mode
      be2net: don't create multiple TXQs in BE2
      be2net: refactor VF setup/teardown code into be_vf_setup/clear()
      be2net: add vlan/rx-mode/flow-control config to be_setup()
      net_sched: cls_flow: use skb_header_pointer()
      ipv4: avoid useless call of the function check_peer_pmtu
      TCP: remove TCP_DEBUG
      net: Fix driver name for mdio-gpio.c
      ipv4: tcp: fix TOS value in ACK messages sent from TIME_WAIT
      rtnetlink: Add missing manual netlink notification in dev_change_net_namespaces
      ipv4: fix ipsec forward performance regression
      jme: fix irq storm after suspend/resume
      route: fix ICMP redirect validation
      net: hold sock reference while processing tx timestamps
      tcp: md5: add more const attributes
      Add ethtool -g support to virtio_net
      ...
    
    Fix up conflicts in:
     - drivers/net/Kconfig:
            The split-up generated a trivial conflict with removal of a
            stale reference to Documentation/networking/net-modules.txt.
            Remove it from the new location instead.
     - fs/sysfs/dir.c:
            Fairly nasty conflicts with the sysfs rb-tree usage, conflicting
            with Eric Biederman's changes for tagged directories.

commit a88394cfb58007cca945699545469017beb0d206
Author: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Date:   Fri May 20 07:15:19 2011 -0700

    ewrk3/tulip: Move the DEC - Tulip drivers
    
    Move the DEC - Tulip driver into drivers/net/ethernet/dec/tulip/
    and make the necessary Kconfig and Makefile changes.
    
    The Digital Equioment (DEC) driver ewrk3 was moved into
    drivers/net/ethernet/dec/ and the remaining drivers (Tulip)
    were moved into drivers/net/ethernet/dec/tulip/
    
    CC: Tobias Ringstrom <tori@unhappy.mine.nu>
    CC: Grant Grundler <grundler@parisc-linux.org>
    CC: David Davies <davies@maniac.ultranet.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Acked-by: Grant Grundler <grundler@parisc-linux.org>

diff --git a/drivers/net/ethernet/dec/tulip/pnic.c b/drivers/net/ethernet/dec/tulip/pnic.c
new file mode 100644
index 000000000000..52d898bdbeb4
--- /dev/null
+++ b/drivers/net/ethernet/dec/tulip/pnic.c
@@ -0,0 +1,173 @@
+/*
+	drivers/net/tulip/pnic.c
+
+	Copyright 2000,2001  The Linux Kernel Team
+	Written/copyright 1994-2001 by Donald Becker.
+
+	This software may be used and distributed according to the terms
+	of the GNU General Public License, incorporated herein by reference.
+
+	Please refer to Documentation/DocBook/tulip-user.{pdf,ps,html}
+	for more information on this driver.
+
+	Please submit bugs to http://bugzilla.kernel.org/ .
+*/
+
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/jiffies.h>
+#include "tulip.h"
+
+
+void pnic_do_nway(struct net_device *dev)
+{
+	struct tulip_private *tp = netdev_priv(dev);
+	void __iomem *ioaddr = tp->base_addr;
+	u32 phy_reg = ioread32(ioaddr + 0xB8);
+	u32 new_csr6 = tp->csr6 & ~0x40C40200;
+
+	if (phy_reg & 0x78000000) { /* Ignore baseT4 */
+		if (phy_reg & 0x20000000)		dev->if_port = 5;
+		else if (phy_reg & 0x40000000)	dev->if_port = 3;
+		else if (phy_reg & 0x10000000)	dev->if_port = 4;
+		else if (phy_reg & 0x08000000)	dev->if_port = 0;
+		tp->nwayset = 1;
+		new_csr6 = (dev->if_port & 1) ? 0x01860000 : 0x00420000;
+		iowrite32(0x32 | (dev->if_port & 1), ioaddr + CSR12);
+		if (dev->if_port & 1)
+			iowrite32(0x1F868, ioaddr + 0xB8);
+		if (phy_reg & 0x30000000) {
+			tp->full_duplex = 1;
+			new_csr6 |= 0x00000200;
+		}
+		if (tulip_debug > 1)
+			netdev_dbg(dev, "PNIC autonegotiated status %08x, %s\n",
+				   phy_reg, medianame[dev->if_port]);
+		if (tp->csr6 != new_csr6) {
+			tp->csr6 = new_csr6;
+			/* Restart Tx */
+			tulip_restart_rxtx(tp);
+			dev->trans_start = jiffies;
+		}
+	}
+}
+
+void pnic_lnk_change(struct net_device *dev, int csr5)
+{
+	struct tulip_private *tp = netdev_priv(dev);
+	void __iomem *ioaddr = tp->base_addr;
+	int phy_reg = ioread32(ioaddr + 0xB8);
+
+	if (tulip_debug > 1)
+		netdev_dbg(dev, "PNIC link changed state %08x, CSR5 %08x\n",
+			   phy_reg, csr5);
+	if (ioread32(ioaddr + CSR5) & TPLnkFail) {
+		iowrite32((ioread32(ioaddr + CSR7) & ~TPLnkFail) | TPLnkPass, ioaddr + CSR7);
+		/* If we use an external MII, then we mustn't use the
+		 * internal negotiation.
+		 */
+		if (tulip_media_cap[dev->if_port] & MediaIsMII)
+			return;
+		if (! tp->nwayset || time_after(jiffies, dev_trans_start(dev) + 1*HZ)) {
+			tp->csr6 = 0x00420000 | (tp->csr6 & 0x0000fdff);
+			iowrite32(tp->csr6, ioaddr + CSR6);
+			iowrite32(0x30, ioaddr + CSR12);
+			iowrite32(0x0201F078, ioaddr + 0xB8); /* Turn on autonegotiation. */
+			dev->trans_start = jiffies;
+		}
+	} else if (ioread32(ioaddr + CSR5) & TPLnkPass) {
+		if (tulip_media_cap[dev->if_port] & MediaIsMII) {
+			spin_lock(&tp->lock);
+			tulip_check_duplex(dev);
+			spin_unlock(&tp->lock);
+		} else {
+			pnic_do_nway(dev);
+		}
+		iowrite32((ioread32(ioaddr + CSR7) & ~TPLnkPass) | TPLnkFail, ioaddr + CSR7);
+	}
+}
+
+void pnic_timer(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct tulip_private *tp = netdev_priv(dev);
+	void __iomem *ioaddr = tp->base_addr;
+	int next_tick = 60*HZ;
+
+	if(!ioread32(ioaddr + CSR7)) {
+		/* the timer was called due to a work overflow
+		 * in the interrupt handler. Skip the connection
+		 * checks, the nic is definitively speaking with
+		 * his link partner.
+		 */
+		goto too_good_connection;
+	}
+
+	if (tulip_media_cap[dev->if_port] & MediaIsMII) {
+		spin_lock_irq(&tp->lock);
+		if (tulip_check_duplex(dev) > 0)
+			next_tick = 3*HZ;
+		spin_unlock_irq(&tp->lock);
+	} else {
+		int csr12 = ioread32(ioaddr + CSR12);
+		int new_csr6 = tp->csr6 & ~0x40C40200;
+		int phy_reg = ioread32(ioaddr + 0xB8);
+		int csr5 = ioread32(ioaddr + CSR5);
+
+		if (tulip_debug > 1)
+			netdev_dbg(dev, "PNIC timer PHY status %08x, %s CSR5 %08x\n",
+				   phy_reg, medianame[dev->if_port], csr5);
+		if (phy_reg & 0x04000000) {	/* Remote link fault */
+			iowrite32(0x0201F078, ioaddr + 0xB8);
+			next_tick = 1*HZ;
+			tp->nwayset = 0;
+		} else if (phy_reg & 0x78000000) { /* Ignore baseT4 */
+			pnic_do_nway(dev);
+			next_tick = 60*HZ;
+		} else if (csr5 & TPLnkFail) { /* 100baseTx link beat */
+			if (tulip_debug > 1)
+				netdev_dbg(dev, "%s link beat failed, CSR12 %04x, CSR5 %08x, PHY %03x\n",
+					   medianame[dev->if_port],
+					   csr12,
+					   ioread32(ioaddr + CSR5),
+					   ioread32(ioaddr + 0xB8));
+			next_tick = 3*HZ;
+			if (tp->medialock) {
+			} else if (tp->nwayset  &&  (dev->if_port & 1)) {
+				next_tick = 1*HZ;
+			} else if (dev->if_port == 0) {
+				dev->if_port = 3;
+				iowrite32(0x33, ioaddr + CSR12);
+				new_csr6 = 0x01860000;
+				iowrite32(0x1F868, ioaddr + 0xB8);
+			} else {
+				dev->if_port = 0;
+				iowrite32(0x32, ioaddr + CSR12);
+				new_csr6 = 0x00420000;
+				iowrite32(0x1F078, ioaddr + 0xB8);
+			}
+			if (tp->csr6 != new_csr6) {
+				tp->csr6 = new_csr6;
+				/* Restart Tx */
+				tulip_restart_rxtx(tp);
+				dev->trans_start = jiffies;
+				if (tulip_debug > 1)
+					dev_info(&dev->dev,
+						 "Changing PNIC configuration to %s %s-duplex, CSR6 %08x\n",
+						 medianame[dev->if_port],
+						 tp->full_duplex ? "full" : "half",
+						 new_csr6);
+			}
+		}
+	}
+too_good_connection:
+	mod_timer(&tp->timer, RUN_AT(next_tick));
+	if(!ioread32(ioaddr + CSR7)) {
+		if (tulip_debug > 1)
+			dev_info(&dev->dev, "sw timer wakeup\n");
+		disable_irq(dev->irq);
+		tulip_refill_rx(dev);
+		enable_irq(dev->irq);
+		iowrite32(tulip_tbl[tp->chip_id].valid_intrs, ioaddr + CSR7);
+	}
+}
