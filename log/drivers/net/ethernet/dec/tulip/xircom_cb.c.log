commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/net/ethernet/dec/tulip/xircom_cb.c b/drivers/net/ethernet/dec/tulip/xircom_cb.c
index 19e4ea15b504..a8de79355578 100644
--- a/drivers/net/ethernet/dec/tulip/xircom_cb.c
+++ b/drivers/net/ethernet/dec/tulip/xircom_cb.c
@@ -30,7 +30,7 @@
 #include <linux/delay.h>
 #include <linux/bitops.h>
 
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <asm/io.h>
 #ifdef CONFIG_NET_POLL_CONTROLLER
 #include <asm/irq.h>

commit a52ad514fdf3b8a57ca4322c92d2d8d5c6182485
Author: Jarod Wilson <jarod@redhat.com>
Date:   Fri Oct 7 22:04:34 2016 -0400

    net: deprecate eth_change_mtu, remove usage
    
    With centralized MTU checking, there's nothing productive done by
    eth_change_mtu that isn't already done in dev_set_mtu, so mark it as
    deprecated and remove all usage of it in the kernel. All callers have been
    audited for calls to alloc_etherdev* or ether_setup directly, which means
    they all have a valid dev->min_mtu and dev->max_mtu. Now eth_change_mtu
    prints out a netdev_warn about being deprecated, for the benefit of
    out-of-tree drivers that might be utilizing it.
    
    Of note, dvb_net.c actually had dev->mtu = 4096, while using
    eth_change_mtu, meaning that if you ever tried changing it's mtu, you
    couldn't set it above 1500 anymore. It's now getting dev->max_mtu also set
    to 4096 to remedy that.
    
    v2: fix up lantiq_etop, missed breakage due to drive not compiling on x86
    
    CC: netdev@vger.kernel.org
    Signed-off-by: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dec/tulip/xircom_cb.c b/drivers/net/ethernet/dec/tulip/xircom_cb.c
index 0e721cedfa67..19e4ea15b504 100644
--- a/drivers/net/ethernet/dec/tulip/xircom_cb.c
+++ b/drivers/net/ethernet/dec/tulip/xircom_cb.c
@@ -174,7 +174,6 @@ static const struct net_device_ops netdev_ops = {
 	.ndo_open		= xircom_open,
 	.ndo_stop		= xircom_close,
 	.ndo_start_xmit		= xircom_start_xmit,
-	.ndo_change_mtu		= eth_change_mtu,
 	.ndo_set_mac_address	= eth_mac_addr,
 	.ndo_validate_addr	= eth_validate_addr,
 #ifdef CONFIG_NET_POLL_CONTROLLER

commit 9baa3c34ac4e27f7e062f266f50cc5dbea26a6c1
Author: Benoit Taine <benoit.taine@lip6.fr>
Date:   Fri Aug 8 15:56:03 2014 +0200

    PCI: Remove DEFINE_PCI_DEVICE_TABLE macro use
    
    We should prefer `struct pci_device_id` over `DEFINE_PCI_DEVICE_TABLE` to
    meet kernel coding style guidelines.  This issue was reported by checkpatch.
    
    A simplified version of the semantic patch that makes this change is as
    follows (http://coccinelle.lip6.fr/):
    
    // <smpl>
    
    @@
    identifier i;
    declarer name DEFINE_PCI_DEVICE_TABLE;
    initializer z;
    @@
    
    - DEFINE_PCI_DEVICE_TABLE(i)
    + const struct pci_device_id i[]
    = z;
    
    // </smpl>
    
    [bhelgaas: add semantic patch]
    Signed-off-by: Benoit Taine <benoit.taine@lip6.fr>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/net/ethernet/dec/tulip/xircom_cb.c b/drivers/net/ethernet/dec/tulip/xircom_cb.c
index 6204cdfe43a6..0e721cedfa67 100644
--- a/drivers/net/ethernet/dec/tulip/xircom_cb.c
+++ b/drivers/net/ethernet/dec/tulip/xircom_cb.c
@@ -137,7 +137,7 @@ static int link_status(struct xircom_private *card);
 
 
 
-static DEFINE_PCI_DEVICE_TABLE(xircom_pci_table) = {
+static const struct pci_device_id xircom_pci_table[] = {
 	{ PCI_VDEVICE(XIRCOM, 0x0003), },
 	{0,},
 };

commit a81ab36bf52d0ca3a32251a923be1dbced726141
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Jan 8 15:32:47 2014 -0500

    drivers/net: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.   Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    This covers everything under drivers/net except for wireless, which
    has been submitted separately.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dec/tulip/xircom_cb.c b/drivers/net/ethernet/dec/tulip/xircom_cb.c
index ab7ebac6fbea..6204cdfe43a6 100644
--- a/drivers/net/ethernet/dec/tulip/xircom_cb.c
+++ b/drivers/net/ethernet/dec/tulip/xircom_cb.c
@@ -28,7 +28,6 @@
 #include <linux/etherdevice.h>
 #include <linux/skbuff.h>
 #include <linux/delay.h>
-#include <linux/init.h>
 #include <linux/bitops.h>
 
 #include <asm/uaccess.h>

commit 3c5b9caf3237b16a9e5019f523b284f056bc4f74
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Mon Oct 21 11:09:26 2013 +0900

    net: tulip: remove unnecessary pci_set_drvdata()
    
    The driver core clears the driver data to NULL after device_release
    or on probe failure. Thus, it is not needed to manually clear the
    device driver data to NULL.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dec/tulip/xircom_cb.c b/drivers/net/ethernet/dec/tulip/xircom_cb.c
index 9b84cb04fe5f..ab7ebac6fbea 100644
--- a/drivers/net/ethernet/dec/tulip/xircom_cb.c
+++ b/drivers/net/ethernet/dec/tulip/xircom_cb.c
@@ -289,7 +289,6 @@ static int xircom_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 err_unmap:
 	pci_iounmap(pdev, private->ioaddr);
 reg_fail:
-	pci_set_drvdata(pdev, NULL);
 	dma_free_coherent(d, 8192, private->tx_buffer, private->tx_dma_handle);
 tx_buf_fail:
 	dma_free_coherent(d, 8192, private->rx_buffer, private->rx_dma_handle);
@@ -317,7 +316,6 @@ static void xircom_remove(struct pci_dev *pdev)
 
 	unregister_netdev(dev);
 	pci_iounmap(pdev, card->ioaddr);
-	pci_set_drvdata(pdev, NULL);
 	dma_free_coherent(d, 8192, card->tx_buffer, card->tx_dma_handle);
 	dma_free_coherent(d, 8192, card->rx_buffer, card->rx_dma_handle);
 	free_netdev(dev);

commit 31d60ebfbe6792068e8951741f92f40bdea97837
Author: Peter HÃ¼we <PeterHuewe@gmx.de>
Date:   Tue May 21 12:42:11 2013 +0000

    net/ethernet/dec/tulip/xircom_cb: Use module_pci_driver to register driver
    
    Removing some boilerplate by using module_pci_driver instead of calling
    register and unregister in the otherwise empty init/exit functions.
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Reviewed-by: Grant Grundler <grundler@parisc-linux.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dec/tulip/xircom_cb.c b/drivers/net/ethernet/dec/tulip/xircom_cb.c
index cdbcd1643141..9b84cb04fe5f 100644
--- a/drivers/net/ethernet/dec/tulip/xircom_cb.c
+++ b/drivers/net/ethernet/dec/tulip/xircom_cb.c
@@ -1171,16 +1171,4 @@ investigate_write_descriptor(struct net_device *dev,
 	}
 }
 
-static int __init xircom_init(void)
-{
-	return pci_register_driver(&xircom_ops);
-}
-
-static void __exit xircom_exit(void)
-{
-	pci_unregister_driver(&xircom_ops);
-}
-
-module_init(xircom_init)
-module_exit(xircom_exit)
-
+module_pci_driver(xircom_ops);

commit d0320f750093d012d3ed69fc1e8b385f654523d5
Author: Joe Perches <joe@perches.com>
Date:   Thu Mar 14 13:07:21 2013 +0000

    drivers:net: Remove dma_alloc_coherent OOM messages
    
    I believe these error messages are already logged
    on allocation failure by warn_alloc_failed and so
    get a dump_stack on OOM.
    
    Remove the unnecessary additional error logging.
    
    Around these deletions:
    
    o Alignment neatening.
    o Remove unnecessary casts of dma_alloc_coherent.
    o Hoist assigns from ifs.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dec/tulip/xircom_cb.c b/drivers/net/ethernet/dec/tulip/xircom_cb.c
index 88feced9a629..cdbcd1643141 100644
--- a/drivers/net/ethernet/dec/tulip/xircom_cb.c
+++ b/drivers/net/ethernet/dec/tulip/xircom_cb.c
@@ -236,17 +236,14 @@ static int xircom_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	private->rx_buffer = dma_alloc_coherent(d, 8192,
 						&private->rx_dma_handle,
 						GFP_KERNEL);
-	if (private->rx_buffer == NULL) {
-		pr_err("%s: no memory for rx buffer\n", __func__);
+	if (private->rx_buffer == NULL)
 		goto rx_buf_fail;
-	}
+
 	private->tx_buffer = dma_alloc_coherent(d, 8192,
 						&private->tx_dma_handle,
 						GFP_KERNEL);
-	if (private->tx_buffer == NULL) {
-		pr_err("%s: no memory for tx buffer\n", __func__);
+	if (private->tx_buffer == NULL)
 		goto tx_buf_fail;
-	}
 
 	SET_NETDEV_DEV(dev, &pdev->dev);
 

commit 779c1a85813a4622cc3bb3d25ce10b523bd055ba
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Dec 3 09:23:41 2012 -0500

    tulip: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Grant Grundler <grundler@parisc-linux.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/ethernet/dec/tulip/xircom_cb.c b/drivers/net/ethernet/dec/tulip/xircom_cb.c
index 138bf83bc98e..88feced9a629 100644
--- a/drivers/net/ethernet/dec/tulip/xircom_cb.c
+++ b/drivers/net/ethernet/dec/tulip/xircom_cb.c
@@ -148,7 +148,7 @@ static struct pci_driver xircom_ops = {
 	.name		= "xircom_cb",
 	.id_table	= xircom_pci_table,
 	.probe		= xircom_probe,
-	.remove		= __devexit_p(xircom_remove),
+	.remove		= xircom_remove,
 };
 
 
@@ -190,7 +190,7 @@ static const struct net_device_ops netdev_ops = {
          first two packets that get send, and pump hates that.
 
  */
-static int __devinit xircom_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+static int xircom_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 {
 	struct device *d = &pdev->dev;
 	struct net_device *dev = NULL;
@@ -312,7 +312,7 @@ static int __devinit xircom_probe(struct pci_dev *pdev, const struct pci_device_
  Interrupts and such are already stopped in the "ifconfig ethX down"
  code.
  */
-static void __devexit xircom_remove(struct pci_dev *pdev)
+static void xircom_remove(struct pci_dev *pdev)
 {
 	struct net_device *dev = pci_get_drvdata(pdev);
 	struct xircom_private *card = netdev_priv(dev);

commit ebaf7f8f78e8600b56010121766ed832f2f57b0f
Author: Francois Romieu <romieu@fr.zoreil.com>
Date:   Tue Mar 13 09:27:47 2012 +0100

    xircom_cb: stop using net_device.{base_addr, irq} and convert to __iomem.
    
    Signed-off-by: Francois Romieu <romieu@fr.zoreil.com>
    Acked-by: Grant Grundler <grundler@parisc-linux.org>

diff --git a/drivers/net/ethernet/dec/tulip/xircom_cb.c b/drivers/net/ethernet/dec/tulip/xircom_cb.c
index cbcc6d6f3f31..138bf83bc98e 100644
--- a/drivers/net/ethernet/dec/tulip/xircom_cb.c
+++ b/drivers/net/ethernet/dec/tulip/xircom_cb.c
@@ -41,7 +41,9 @@ MODULE_DESCRIPTION("Xircom Cardbus ethernet driver");
 MODULE_AUTHOR("Arjan van de Ven <arjanv@redhat.com>");
 MODULE_LICENSE("GPL");
 
-
+#define xw32(reg, val)	iowrite32(val, ioaddr + (reg))
+#define xr32(reg)	ioread32(ioaddr + (reg))
+#define xr8(reg)	ioread8(ioaddr + (reg))
 
 /* IO registers on the card, offsets */
 #define CSR0	0x00
@@ -83,7 +85,7 @@ struct xircom_private {
 
 	struct sk_buff *tx_skb[4];
 
-	unsigned long io_port;
+	void __iomem *ioaddr;
 	int open;
 
 	/* transmit_used is the rotating counter that indicates which transmit
@@ -137,7 +139,7 @@ static int link_status(struct xircom_private *card);
 
 
 static DEFINE_PCI_DEVICE_TABLE(xircom_pci_table) = {
-	{0x115D, 0x0003, PCI_ANY_ID, PCI_ANY_ID,},
+	{ PCI_VDEVICE(XIRCOM, 0x0003), },
 	{0,},
 };
 MODULE_DEVICE_TABLE(pci, xircom_pci_table);
@@ -146,9 +148,7 @@ static struct pci_driver xircom_ops = {
 	.name		= "xircom_cb",
 	.id_table	= xircom_pci_table,
 	.probe		= xircom_probe,
-	.remove		= xircom_remove,
-	.suspend =NULL,
-	.resume =NULL
+	.remove		= __devexit_p(xircom_remove),
 };
 
 
@@ -253,10 +253,13 @@ static int __devinit xircom_probe(struct pci_dev *pdev, const struct pci_device_
 
 	private->dev = dev;
 	private->pdev = pdev;
-	private->io_port = pci_resource_start(pdev, 0);
+
+	/* IO range. */
+	private->ioaddr = pci_iomap(pdev, 0, 0);
+	if (!private->ioaddr)
+		goto reg_fail;
+
 	spin_lock_init(&private->lock);
-	dev->irq = pdev->irq;
-	dev->base_addr = private->io_port;
 
 	initialize_card(private);
 	read_mac_address(private);
@@ -268,7 +271,7 @@ static int __devinit xircom_probe(struct pci_dev *pdev, const struct pci_device_
 	rc = register_netdev(dev);
 	if (rc < 0) {
 		pr_err("%s: netdevice registration failed\n", __func__);
-		goto reg_fail;
+		goto err_unmap;
 	}
 
 	netdev_info(dev, "Xircom cardbus revision %i at irq %i\n",
@@ -286,6 +289,8 @@ static int __devinit xircom_probe(struct pci_dev *pdev, const struct pci_device_
 out:
 	return rc;
 
+err_unmap:
+	pci_iounmap(pdev, private->ioaddr);
 reg_fail:
 	pci_set_drvdata(pdev, NULL);
 	dma_free_coherent(d, 8192, private->tx_buffer, private->tx_dma_handle);
@@ -314,6 +319,7 @@ static void __devexit xircom_remove(struct pci_dev *pdev)
 	struct device *d = &pdev->dev;
 
 	unregister_netdev(dev);
+	pci_iounmap(pdev, card->ioaddr);
 	pci_set_drvdata(pdev, NULL);
 	dma_free_coherent(d, 8192, card->tx_buffer, card->tx_dma_handle);
 	dma_free_coherent(d, 8192, card->rx_buffer, card->rx_dma_handle);
@@ -326,11 +332,12 @@ static irqreturn_t xircom_interrupt(int irq, void *dev_instance)
 {
 	struct net_device *dev = (struct net_device *) dev_instance;
 	struct xircom_private *card = netdev_priv(dev);
+	void __iomem *ioaddr = card->ioaddr;
 	unsigned int status;
 	int i;
 
 	spin_lock(&card->lock);
-	status = inl(card->io_port+CSR5);
+	status = xr32(CSR5);
 
 #if defined DEBUG && DEBUG > 1
 	print_binary(status);
@@ -360,7 +367,7 @@ static irqreturn_t xircom_interrupt(int irq, void *dev_instance)
 	/* Clear all remaining interrupts */
 	status |= 0xffffffff; /* FIXME: make this clear only the
 				        real existing bits */
-	outl(status,card->io_port+CSR5);
+	xw32(CSR5, status);
 
 
 	for (i=0;i<NUMDESCRIPTORS;i++)
@@ -438,11 +445,11 @@ static netdev_tx_t xircom_start_xmit(struct sk_buff *skb,
 static int xircom_open(struct net_device *dev)
 {
 	struct xircom_private *xp = netdev_priv(dev);
+	const int irq = xp->pdev->irq;
 	int retval;
 
-	netdev_info(dev, "xircom cardbus adaptor found, using irq %i\n",
-		    dev->irq);
-	retval = request_irq(dev->irq, xircom_interrupt, IRQF_SHARED, dev->name, dev);
+	netdev_info(dev, "xircom cardbus adaptor found, using irq %i\n", irq);
+	retval = request_irq(irq, xircom_interrupt, IRQF_SHARED, dev->name, dev);
 	if (retval)
 		return retval;
 
@@ -474,7 +481,7 @@ static int xircom_close(struct net_device *dev)
 	spin_unlock_irqrestore(&card->lock,flags);
 
 	card->open = 0;
-	free_irq(dev->irq,dev);
+	free_irq(card->pdev->irq, dev);
 
 	return 0;
 
@@ -484,35 +491,39 @@ static int xircom_close(struct net_device *dev)
 #ifdef CONFIG_NET_POLL_CONTROLLER
 static void xircom_poll_controller(struct net_device *dev)
 {
-	disable_irq(dev->irq);
-	xircom_interrupt(dev->irq, dev);
-	enable_irq(dev->irq);
+	struct xircom_private *xp = netdev_priv(dev);
+	const int irq = xp->pdev->irq;
+
+	disable_irq(irq);
+	xircom_interrupt(irq, dev);
+	enable_irq(irq);
 }
 #endif
 
 
 static void initialize_card(struct xircom_private *card)
 {
-	unsigned int val;
+	void __iomem *ioaddr = card->ioaddr;
 	unsigned long flags;
+	u32 val;
 
 	spin_lock_irqsave(&card->lock, flags);
 
 	/* First: reset the card */
-	val = inl(card->io_port + CSR0);
+	val = xr32(CSR0);
 	val |= 0x01;		/* Software reset */
-	outl(val, card->io_port + CSR0);
+	xw32(CSR0, val);
 
 	udelay(100);		/* give the card some time to reset */
 
-	val = inl(card->io_port + CSR0);
+	val = xr32(CSR0);
 	val &= ~0x01;		/* disable Software reset */
-	outl(val, card->io_port + CSR0);
+	xw32(CSR0, val);
 
 
 	val = 0;		/* Value 0x00 is a safe and conservative value
 				   for the PCI configuration settings */
-	outl(val, card->io_port + CSR0);
+	xw32(CSR0, val);
 
 
 	disable_all_interrupts(card);
@@ -530,10 +541,9 @@ ignored; I chose zero.
 */
 static void trigger_transmit(struct xircom_private *card)
 {
-	unsigned int val;
+	void __iomem *ioaddr = card->ioaddr;
 
-	val = 0;
-	outl(val, card->io_port + CSR1);
+	xw32(CSR1, 0);
 }
 
 /*
@@ -545,10 +555,9 @@ ignored; I chose zero.
 */
 static void trigger_receive(struct xircom_private *card)
 {
-	unsigned int val;
+	void __iomem *ioaddr = card->ioaddr;
 
-	val = 0;
-	outl(val, card->io_port + CSR2);
+	xw32(CSR2, 0);
 }
 
 /*
@@ -557,6 +566,7 @@ descriptors and programs the addresses into the card.
 */
 static void setup_descriptors(struct xircom_private *card)
 {
+	void __iomem *ioaddr = card->ioaddr;
 	u32 address;
 	int i;
 
@@ -586,7 +596,7 @@ static void setup_descriptors(struct xircom_private *card)
 	wmb();
 	/* Write the receive descriptor ring address to the card */
 	address = card->rx_dma_handle;
-	outl(address, card->io_port + CSR3);	/* Receive descr list address */
+	xw32(CSR3, address);	/* Receive descr list address */
 
 
 	/* transmit descriptors */
@@ -611,7 +621,7 @@ static void setup_descriptors(struct xircom_private *card)
 	wmb();
 	/* wite the transmit descriptor ring to the card */
 	address = card->tx_dma_handle;
-	outl(address, card->io_port + CSR4);	/* xmit descr list address */
+	xw32(CSR4, address);	/* xmit descr list address */
 }
 
 /*
@@ -620,11 +630,12 @@ valid by setting the address in the card to 0x00.
 */
 static void remove_descriptors(struct xircom_private *card)
 {
+	void __iomem *ioaddr = card->ioaddr;
 	unsigned int val;
 
 	val = 0;
-	outl(val, card->io_port + CSR3);	/* Receive descriptor address */
-	outl(val, card->io_port + CSR4);	/* Send descriptor address */
+	xw32(CSR3, val);	/* Receive descriptor address */
+	xw32(CSR4, val);	/* Send descriptor address */
 }
 
 /*
@@ -635,17 +646,17 @@ This function also clears the status-bit.
 */
 static int link_status_changed(struct xircom_private *card)
 {
+	void __iomem *ioaddr = card->ioaddr;
 	unsigned int val;
 
-	val = inl(card->io_port + CSR5);	/* Status register */
-
-	if ((val & (1 << 27)) == 0)		/* no change */
+	val = xr32(CSR5);	/* Status register */
+	if (!(val & (1 << 27)))	/* no change */
 		return 0;
 
 	/* clear the event by writing a 1 to the bit in the
 	   status register. */
 	val = (1 << 27);
-	outl(val, card->io_port + CSR5);
+	xw32(CSR5, val);
 
 	return 1;
 }
@@ -657,11 +668,9 @@ in a non-stopped state.
 */
 static int transmit_active(struct xircom_private *card)
 {
-	unsigned int val;
+	void __iomem *ioaddr = card->ioaddr;
 
-	val = inl(card->io_port + CSR5);	/* Status register */
-
-	if ((val & (7 << 20)) == 0)		/* transmitter disabled */
+	if (!(xr32(CSR5) & (7 << 20)))	/* transmitter disabled */
 		return 0;
 
 	return 1;
@@ -673,11 +682,9 @@ in a non-stopped state.
 */
 static int receive_active(struct xircom_private *card)
 {
-	unsigned int val;
-
-	val = inl(card->io_port + CSR5);	/* Status register */
+	void __iomem *ioaddr = card->ioaddr;
 
-	if ((val & (7 << 17)) == 0)		/* receiver disabled */
+	if (!(xr32(CSR5) & (7 << 17)))	/* receiver disabled */
 		return 0;
 
 	return 1;
@@ -695,10 +702,11 @@ must be called with the lock held and interrupts disabled.
 */
 static void activate_receiver(struct xircom_private *card)
 {
+	void __iomem *ioaddr = card->ioaddr;
 	unsigned int val;
 	int counter;
 
-	val = inl(card->io_port + CSR6);	/* Operation mode */
+	val = xr32(CSR6);	/* Operation mode */
 
 	/* If the "active" bit is set and the receiver is already
 	   active, no need to do the expensive thing */
@@ -707,7 +715,7 @@ static void activate_receiver(struct xircom_private *card)
 
 
 	val = val & ~2;		/* disable the receiver */
-	outl(val, card->io_port + CSR6);
+	xw32(CSR6, val);
 
 	counter = 10;
 	while (counter > 0) {
@@ -721,9 +729,9 @@ static void activate_receiver(struct xircom_private *card)
 	}
 
 	/* enable the receiver */
-	val = inl(card->io_port + CSR6);	/* Operation mode */
-	val = val | 2;				/* enable the receiver */
-	outl(val, card->io_port + CSR6);
+	val = xr32(CSR6);	/* Operation mode */
+	val = val | 2;		/* enable the receiver */
+	xw32(CSR6, val);
 
 	/* now wait for the card to activate again */
 	counter = 10;
@@ -748,12 +756,13 @@ must be called with the lock held and interrupts disabled.
 */
 static void deactivate_receiver(struct xircom_private *card)
 {
+	void __iomem *ioaddr = card->ioaddr;
 	unsigned int val;
 	int counter;
 
-	val = inl(card->io_port + CSR6);	/* Operation mode */
-	val = val & ~2;				/* disable the receiver */
-	outl(val, card->io_port + CSR6);
+	val = xr32(CSR6);	/* Operation mode */
+	val = val & ~2;		/* disable the receiver */
+	xw32(CSR6, val);
 
 	counter = 10;
 	while (counter > 0) {
@@ -780,10 +789,11 @@ must be called with the lock held and interrupts disabled.
 */
 static void activate_transmitter(struct xircom_private *card)
 {
+	void __iomem *ioaddr = card->ioaddr;
 	unsigned int val;
 	int counter;
 
-	val = inl(card->io_port + CSR6);	/* Operation mode */
+	val = xr32(CSR6);	/* Operation mode */
 
 	/* If the "active" bit is set and the receiver is already
 	   active, no need to do the expensive thing */
@@ -791,7 +801,7 @@ static void activate_transmitter(struct xircom_private *card)
 		return;
 
 	val = val & ~(1 << 13);	/* disable the transmitter */
-	outl(val, card->io_port + CSR6);
+	xw32(CSR6, val);
 
 	counter = 10;
 	while (counter > 0) {
@@ -806,9 +816,9 @@ static void activate_transmitter(struct xircom_private *card)
 	}
 
 	/* enable the transmitter */
-	val = inl(card->io_port + CSR6);	/* Operation mode */
+	val = xr32(CSR6);	/* Operation mode */
 	val = val | (1 << 13);	/* enable the transmitter */
-	outl(val, card->io_port + CSR6);
+	xw32(CSR6, val);
 
 	/* now wait for the card to activate again */
 	counter = 10;
@@ -833,12 +843,13 @@ must be called with the lock held and interrupts disabled.
 */
 static void deactivate_transmitter(struct xircom_private *card)
 {
+	void __iomem *ioaddr = card->ioaddr;
 	unsigned int val;
 	int counter;
 
-	val = inl(card->io_port + CSR6);	/* Operation mode */
+	val = xr32(CSR6);	/* Operation mode */
 	val = val & ~2;		/* disable the transmitter */
-	outl(val, card->io_port + CSR6);
+	xw32(CSR6, val);
 
 	counter = 20;
 	while (counter > 0) {
@@ -861,11 +872,12 @@ must be called with the lock held and interrupts disabled.
 */
 static void enable_transmit_interrupt(struct xircom_private *card)
 {
+	void __iomem *ioaddr = card->ioaddr;
 	unsigned int val;
 
-	val = inl(card->io_port + CSR7);	/* Interrupt enable register */
-	val |= 1;				/* enable the transmit interrupt */
-	outl(val, card->io_port + CSR7);
+	val = xr32(CSR7);	/* Interrupt enable register */
+	val |= 1;		/* enable the transmit interrupt */
+	xw32(CSR7, val);
 }
 
 
@@ -876,11 +888,12 @@ must be called with the lock held and interrupts disabled.
 */
 static void enable_receive_interrupt(struct xircom_private *card)
 {
+	void __iomem *ioaddr = card->ioaddr;
 	unsigned int val;
 
-	val = inl(card->io_port + CSR7);	/* Interrupt enable register */
-	val = val | (1 << 6);			/* enable the receive interrupt */
-	outl(val, card->io_port + CSR7);
+	val = xr32(CSR7);	/* Interrupt enable register */
+	val = val | (1 << 6);	/* enable the receive interrupt */
+	xw32(CSR7, val);
 }
 
 /*
@@ -890,11 +903,12 @@ must be called with the lock held and interrupts disabled.
 */
 static void enable_link_interrupt(struct xircom_private *card)
 {
+	void __iomem *ioaddr = card->ioaddr;
 	unsigned int val;
 
-	val = inl(card->io_port + CSR7);	/* Interrupt enable register */
-	val = val | (1 << 27);			/* enable the link status chage interrupt */
-	outl(val, card->io_port + CSR7);
+	val = xr32(CSR7);	/* Interrupt enable register */
+	val = val | (1 << 27);	/* enable the link status chage interrupt */
+	xw32(CSR7, val);
 }
 
 
@@ -906,10 +920,9 @@ must be called with the lock held and interrupts disabled.
 */
 static void disable_all_interrupts(struct xircom_private *card)
 {
-	unsigned int val;
+	void __iomem *ioaddr = card->ioaddr;
 
-	val = 0;				/* disable all interrupts */
-	outl(val, card->io_port + CSR7);
+	xw32(CSR7, 0);
 }
 
 /*
@@ -919,9 +932,10 @@ must be called with the lock held and interrupts disabled.
 */
 static void enable_common_interrupts(struct xircom_private *card)
 {
+	void __iomem *ioaddr = card->ioaddr;
 	unsigned int val;
 
-	val = inl(card->io_port + CSR7);	/* Interrupt enable register */
+	val = xr32(CSR7);	/* Interrupt enable register */
 	val |= (1<<16); /* Normal Interrupt Summary */
 	val |= (1<<15); /* Abnormal Interrupt Summary */
 	val |= (1<<13); /* Fatal bus error */
@@ -930,7 +944,7 @@ static void enable_common_interrupts(struct xircom_private *card)
 	val |= (1<<5);  /* Transmit Underflow */
 	val |= (1<<2);  /* Transmit Buffer Unavailable */
 	val |= (1<<1);  /* Transmit Process Stopped */
-	outl(val, card->io_port + CSR7);
+	xw32(CSR7, val);
 }
 
 /*
@@ -940,11 +954,12 @@ must be called with the lock held and interrupts disabled.
 */
 static int enable_promisc(struct xircom_private *card)
 {
+	void __iomem *ioaddr = card->ioaddr;
 	unsigned int val;
 
-	val = inl(card->io_port + CSR6);
+	val = xr32(CSR6);
 	val = val | (1 << 6);
-	outl(val, card->io_port + CSR6);
+	xw32(CSR6, val);
 
 	return 1;
 }
@@ -959,13 +974,16 @@ Must be called in locked state with interrupts disabled
 */
 static int link_status(struct xircom_private *card)
 {
-	unsigned int val;
+	void __iomem *ioaddr = card->ioaddr;
+	u8 val;
 
-	val = inb(card->io_port + CSR12);
+	val = xr8(CSR12);
 
-	if (!(val&(1<<2)))  /* bit 2 is 0 for 10mbit link, 1 for not an 10mbit link */
+	/* bit 2 is 0 for 10mbit link, 1 for not an 10mbit link */
+	if (!(val & (1 << 2)))
 		return 10;
-	if (!(val&(1<<1)))  /* bit 1 is 0 for 100mbit link, 1 for not an 100mbit link */
+	/* bit 1 is 0 for 100mbit link, 1 for not an 100mbit link */
+	if (!(val & (1 << 1)))
 		return 100;
 
 	/* If we get here -> no link at all */
@@ -984,29 +1002,31 @@ static int link_status(struct xircom_private *card)
  */
 static void read_mac_address(struct xircom_private *card)
 {
-	unsigned char j, tuple, link, data_id, data_count;
+	void __iomem *ioaddr = card->ioaddr;
 	unsigned long flags;
+	u8 link;
 	int i;
 
 	spin_lock_irqsave(&card->lock, flags);
 
-	outl(1 << 12, card->io_port + CSR9);	/* enable boot rom access */
+	xw32(CSR9, 1 << 12);	/* enable boot rom access */
 	for (i = 0x100; i < 0x1f7; i += link + 2) {
-		outl(i, card->io_port + CSR10);
-		tuple = inl(card->io_port + CSR9) & 0xff;
-		outl(i + 1, card->io_port + CSR10);
-		link = inl(card->io_port + CSR9) & 0xff;
-		outl(i + 2, card->io_port + CSR10);
-		data_id = inl(card->io_port + CSR9) & 0xff;
-		outl(i + 3, card->io_port + CSR10);
-		data_count = inl(card->io_port + CSR9) & 0xff;
+		u8 tuple, data_id, data_count;
+
+		xw32(CSR10, i);
+		tuple = xr32(CSR9);
+		xw32(CSR10, i + 1);
+		link = xr32(CSR9);
+		xw32(CSR10, i + 2);
+		data_id = xr32(CSR9);
+		xw32(CSR10, i + 3);
+		data_count = xr32(CSR9);
 		if ((tuple == 0x22) && (data_id == 0x04) && (data_count == 0x06)) {
-			/*
-			 * This is it.  We have the data we want.
-			 */
+			int j;
+
 			for (j = 0; j < 6; j++) {
-				outl(i + j + 4, card->io_port + CSR10);
-				card->dev->dev_addr[j] = inl(card->io_port + CSR9) & 0xff;
+				xw32(CSR10, i + j + 4);
+				card->dev->dev_addr[j] = xr32(CSR9) & 0xff;
 			}
 			break;
 		} else if (link == 0) {
@@ -1025,6 +1045,7 @@ static void read_mac_address(struct xircom_private *card)
  */
 static void transceiver_voodoo(struct xircom_private *card)
 {
+	void __iomem *ioaddr = card->ioaddr;
 	unsigned long flags;
 
 	/* disable all powermanagement */
@@ -1034,14 +1055,14 @@ static void transceiver_voodoo(struct xircom_private *card)
 
 	spin_lock_irqsave(&card->lock, flags);
 
-	outl(0x0008, card->io_port + CSR15);
-        udelay(25);
-        outl(0xa8050000, card->io_port + CSR15);
-        udelay(25);
-        outl(0xa00f0000, card->io_port + CSR15);
-        udelay(25);
+	xw32(CSR15, 0x0008);
+	udelay(25);
+	xw32(CSR15, 0xa8050000);
+	udelay(25);
+	xw32(CSR15, 0xa00f0000);
+	udelay(25);
 
-        spin_unlock_irqrestore(&card->lock, flags);
+	spin_unlock_irqrestore(&card->lock, flags);
 
 	netif_start_queue(card->dev);
 }

commit d59a1881c0ff63f9edbc7f4ad5a5e593fe779e1b
Author: Francois Romieu <romieu@fr.zoreil.com>
Date:   Sun Mar 11 23:34:54 2012 +0100

    xircom_cb: fix device probe error path.
    
    - unbalanced pci_disable_device
    - PCI ressources were not released
    - mismatching pci_alloc_.../kfree pairs are replaced by DMA alloc helpers.
    
    Signed-off-by: Francois Romieu <romieu@fr.zoreil.com>
    Ack-by: Grant Grundler <grundler@parisc-linux.org>

diff --git a/drivers/net/ethernet/dec/tulip/xircom_cb.c b/drivers/net/ethernet/dec/tulip/xircom_cb.c
index fdb329fe6e8e..cbcc6d6f3f31 100644
--- a/drivers/net/ethernet/dec/tulip/xircom_cb.c
+++ b/drivers/net/ethernet/dec/tulip/xircom_cb.c
@@ -192,15 +192,18 @@ static const struct net_device_ops netdev_ops = {
  */
 static int __devinit xircom_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 {
+	struct device *d = &pdev->dev;
 	struct net_device *dev = NULL;
 	struct xircom_private *private;
 	unsigned long flags;
 	unsigned short tmp16;
+	int rc;
 
 	/* First do the PCI initialisation */
 
-	if (pci_enable_device(pdev))
-		return -ENODEV;
+	rc = pci_enable_device(pdev);
+	if (rc < 0)
+		goto out;
 
 	/* disable all powermanagement */
 	pci_write_config_dword(pdev, PCI_POWERMGMT, 0x0000);
@@ -211,11 +214,13 @@ static int __devinit xircom_probe(struct pci_dev *pdev, const struct pci_device_
 	pci_read_config_word (pdev,PCI_STATUS, &tmp16);
 	pci_write_config_word (pdev, PCI_STATUS,tmp16);
 
-	if (!request_region(pci_resource_start(pdev, 0), 128, "xircom_cb")) {
+	rc = pci_request_regions(pdev, "xircom_cb");
+	if (rc < 0) {
 		pr_err("%s: failed to allocate io-region\n", __func__);
-		return -ENODEV;
+		goto err_disable;
 	}
 
+	rc = -ENOMEM;
 	/*
 	   Before changing the hardware, allocate the memory.
 	   This way, we can fail gracefully if not enough memory
@@ -223,17 +228,21 @@ static int __devinit xircom_probe(struct pci_dev *pdev, const struct pci_device_
 	 */
 	dev = alloc_etherdev(sizeof(struct xircom_private));
 	if (!dev)
-		goto device_fail;
+		goto err_release;
 
 	private = netdev_priv(dev);
 
 	/* Allocate the send/receive buffers */
-	private->rx_buffer = pci_alloc_consistent(pdev,8192,&private->rx_dma_handle);
+	private->rx_buffer = dma_alloc_coherent(d, 8192,
+						&private->rx_dma_handle,
+						GFP_KERNEL);
 	if (private->rx_buffer == NULL) {
 		pr_err("%s: no memory for rx buffer\n", __func__);
 		goto rx_buf_fail;
 	}
-	private->tx_buffer = pci_alloc_consistent(pdev,8192,&private->tx_dma_handle);
+	private->tx_buffer = dma_alloc_coherent(d, 8192,
+						&private->tx_dma_handle,
+						GFP_KERNEL);
 	if (private->tx_buffer == NULL) {
 		pr_err("%s: no memory for tx buffer\n", __func__);
 		goto tx_buf_fail;
@@ -256,7 +265,8 @@ static int __devinit xircom_probe(struct pci_dev *pdev, const struct pci_device_
 	dev->netdev_ops = &netdev_ops;
 	pci_set_drvdata(pdev, dev);
 
-	if (register_netdev(dev)) {
+	rc = register_netdev(dev);
+	if (rc < 0) {
 		pr_err("%s: netdevice registration failed\n", __func__);
 		goto reg_fail;
 	}
@@ -273,17 +283,21 @@ static int __devinit xircom_probe(struct pci_dev *pdev, const struct pci_device_
 	spin_unlock_irqrestore(&private->lock,flags);
 
 	trigger_receive(private);
-
-	return 0;
+out:
+	return rc;
 
 reg_fail:
-	kfree(private->tx_buffer);
+	pci_set_drvdata(pdev, NULL);
+	dma_free_coherent(d, 8192, private->tx_buffer, private->tx_dma_handle);
 tx_buf_fail:
-	kfree(private->rx_buffer);
+	dma_free_coherent(d, 8192, private->rx_buffer, private->rx_dma_handle);
 rx_buf_fail:
 	free_netdev(dev);
-device_fail:
-	return -ENODEV;
+err_release:
+	pci_release_regions(pdev);
+err_disable:
+	pci_disable_device(pdev);
+	goto out;
 }
 
 
@@ -297,14 +311,15 @@ static void __devexit xircom_remove(struct pci_dev *pdev)
 {
 	struct net_device *dev = pci_get_drvdata(pdev);
 	struct xircom_private *card = netdev_priv(dev);
+	struct device *d = &pdev->dev;
 
-	pci_free_consistent(pdev,8192,card->rx_buffer,card->rx_dma_handle);
-	pci_free_consistent(pdev,8192,card->tx_buffer,card->tx_dma_handle);
-
-	release_region(dev->base_addr, 128);
 	unregister_netdev(dev);
-	free_netdev(dev);
 	pci_set_drvdata(pdev, NULL);
+	dma_free_coherent(d, 8192, card->tx_buffer, card->tx_dma_handle);
+	dma_free_coherent(d, 8192, card->rx_buffer, card->rx_dma_handle);
+	free_netdev(dev);
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
 }
 
 static irqreturn_t xircom_interrupt(int irq, void *dev_instance)

commit 21a4e46995fa1a76281ac0281ff837f706231a37
Author: Pradeep A Dalvi <netdev@pradeepdalvi.com>
Date:   Sun Feb 5 02:50:10 2012 +0000

    netdev: ethernet dev_alloc_skb to netdev_alloc_skb
    
    Replaced deprecating dev_alloc_skb with netdev_alloc_skb in drivers/net/ethernet
      - Removed extra skb->dev = dev after netdev_alloc_skb
    
    Signed-off-by: Pradeep A Dalvi <netdev@pradeepdalvi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dec/tulip/xircom_cb.c b/drivers/net/ethernet/dec/tulip/xircom_cb.c
index b7c73eefb54b..fdb329fe6e8e 100644
--- a/drivers/net/ethernet/dec/tulip/xircom_cb.c
+++ b/drivers/net/ethernet/dec/tulip/xircom_cb.c
@@ -1084,7 +1084,7 @@ investigate_read_descriptor(struct net_device *dev, struct xircom_private *card,
 			pkt_len = 1518;
 		}
 
-		skb = dev_alloc_skb(pkt_len + 2);
+		skb = netdev_alloc_skb(dev, pkt_len + 2);
 		if (skb == NULL) {
 			dev->stats.rx_dropped++;
 			goto out;

commit 41de8d4cff21a2e81e3d9ff66f5f7c903f9c3ab1
Author: Joe Perches <joe@perches.com>
Date:   Sun Jan 29 13:47:52 2012 +0000

    drivers/net: Remove alloc_etherdev error messages
    
    alloc_etherdev has a generic OOM/unable to alloc message.
    Remove the duplicative messages after alloc_etherdev calls.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/dec/tulip/xircom_cb.c b/drivers/net/ethernet/dec/tulip/xircom_cb.c
index 988b8eb24d37..b7c73eefb54b 100644
--- a/drivers/net/ethernet/dec/tulip/xircom_cb.c
+++ b/drivers/net/ethernet/dec/tulip/xircom_cb.c
@@ -222,10 +222,9 @@ static int __devinit xircom_probe(struct pci_dev *pdev, const struct pci_device_
 	   is available.
 	 */
 	dev = alloc_etherdev(sizeof(struct xircom_private));
-	if (!dev) {
-		pr_err("%s: failed to allocate etherdev\n", __func__);
+	if (!dev)
 		goto device_fail;
-	}
+
 	private = netdev_priv(dev);
 
 	/* Allocate the send/receive buffers */

commit a88394cfb58007cca945699545469017beb0d206
Author: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Date:   Fri May 20 07:15:19 2011 -0700

    ewrk3/tulip: Move the DEC - Tulip drivers
    
    Move the DEC - Tulip driver into drivers/net/ethernet/dec/tulip/
    and make the necessary Kconfig and Makefile changes.
    
    The Digital Equioment (DEC) driver ewrk3 was moved into
    drivers/net/ethernet/dec/ and the remaining drivers (Tulip)
    were moved into drivers/net/ethernet/dec/tulip/
    
    CC: Tobias Ringstrom <tori@unhappy.mine.nu>
    CC: Grant Grundler <grundler@parisc-linux.org>
    CC: David Davies <davies@maniac.ultranet.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Acked-by: Grant Grundler <grundler@parisc-linux.org>

diff --git a/drivers/net/ethernet/dec/tulip/xircom_cb.c b/drivers/net/ethernet/dec/tulip/xircom_cb.c
new file mode 100644
index 000000000000..988b8eb24d37
--- /dev/null
+++ b/drivers/net/ethernet/dec/tulip/xircom_cb.c
@@ -0,0 +1,1154 @@
+/*
+ * xircom_cb: A driver for the (tulip-like) Xircom Cardbus ethernet cards
+ *
+ * This software is (C) by the respective authors, and licensed under the GPL
+ * License.
+ *
+ * Written by Arjan van de Ven for Red Hat, Inc.
+ * Based on work by Jeff Garzik, Doug Ledford and Donald Becker
+ *
+ *  	This software may be used and distributed according to the terms
+ *      of the GNU General Public License, incorporated herein by reference.
+ *
+ *
+ * 	$Id: xircom_cb.c,v 1.33 2001/03/19 14:02:07 arjanv Exp $
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/bitops.h>
+
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#ifdef CONFIG_NET_POLL_CONTROLLER
+#include <asm/irq.h>
+#endif
+
+MODULE_DESCRIPTION("Xircom Cardbus ethernet driver");
+MODULE_AUTHOR("Arjan van de Ven <arjanv@redhat.com>");
+MODULE_LICENSE("GPL");
+
+
+
+/* IO registers on the card, offsets */
+#define CSR0	0x00
+#define CSR1	0x08
+#define CSR2	0x10
+#define CSR3	0x18
+#define CSR4	0x20
+#define CSR5	0x28
+#define CSR6	0x30
+#define CSR7	0x38
+#define CSR8	0x40
+#define CSR9	0x48
+#define CSR10	0x50
+#define CSR11	0x58
+#define CSR12	0x60
+#define CSR13	0x68
+#define CSR14	0x70
+#define CSR15	0x78
+#define CSR16	0x80
+
+/* PCI registers */
+#define PCI_POWERMGMT 	0x40
+
+/* Offsets of the buffers within the descriptor pages, in bytes */
+
+#define NUMDESCRIPTORS 4
+
+static int bufferoffsets[NUMDESCRIPTORS] = {128,2048,4096,6144};
+
+
+struct xircom_private {
+	/* Send and receive buffers, kernel-addressable and dma addressable forms */
+
+	__le32 *rx_buffer;
+	__le32 *tx_buffer;
+
+	dma_addr_t rx_dma_handle;
+	dma_addr_t tx_dma_handle;
+
+	struct sk_buff *tx_skb[4];
+
+	unsigned long io_port;
+	int open;
+
+	/* transmit_used is the rotating counter that indicates which transmit
+	   descriptor has to be used next */
+	int transmit_used;
+
+	/* Spinlock to serialize register operations.
+	   It must be helt while manipulating the following registers:
+	   CSR0, CSR6, CSR7, CSR9, CSR10, CSR15
+	 */
+	spinlock_t lock;
+
+	struct pci_dev *pdev;
+	struct net_device *dev;
+};
+
+
+/* Function prototypes */
+static int xircom_probe(struct pci_dev *pdev, const struct pci_device_id *id);
+static void xircom_remove(struct pci_dev *pdev);
+static irqreturn_t xircom_interrupt(int irq, void *dev_instance);
+static netdev_tx_t xircom_start_xmit(struct sk_buff *skb,
+					   struct net_device *dev);
+static int xircom_open(struct net_device *dev);
+static int xircom_close(struct net_device *dev);
+static void xircom_up(struct xircom_private *card);
+#ifdef CONFIG_NET_POLL_CONTROLLER
+static void xircom_poll_controller(struct net_device *dev);
+#endif
+
+static void investigate_read_descriptor(struct net_device *dev,struct xircom_private *card, int descnr, unsigned int bufferoffset);
+static void investigate_write_descriptor(struct net_device *dev, struct xircom_private *card, int descnr, unsigned int bufferoffset);
+static void read_mac_address(struct xircom_private *card);
+static void transceiver_voodoo(struct xircom_private *card);
+static void initialize_card(struct xircom_private *card);
+static void trigger_transmit(struct xircom_private *card);
+static void trigger_receive(struct xircom_private *card);
+static void setup_descriptors(struct xircom_private *card);
+static void remove_descriptors(struct xircom_private *card);
+static int link_status_changed(struct xircom_private *card);
+static void activate_receiver(struct xircom_private *card);
+static void deactivate_receiver(struct xircom_private *card);
+static void activate_transmitter(struct xircom_private *card);
+static void deactivate_transmitter(struct xircom_private *card);
+static void enable_transmit_interrupt(struct xircom_private *card);
+static void enable_receive_interrupt(struct xircom_private *card);
+static void enable_link_interrupt(struct xircom_private *card);
+static void disable_all_interrupts(struct xircom_private *card);
+static int link_status(struct xircom_private *card);
+
+
+
+static DEFINE_PCI_DEVICE_TABLE(xircom_pci_table) = {
+	{0x115D, 0x0003, PCI_ANY_ID, PCI_ANY_ID,},
+	{0,},
+};
+MODULE_DEVICE_TABLE(pci, xircom_pci_table);
+
+static struct pci_driver xircom_ops = {
+	.name		= "xircom_cb",
+	.id_table	= xircom_pci_table,
+	.probe		= xircom_probe,
+	.remove		= xircom_remove,
+	.suspend =NULL,
+	.resume =NULL
+};
+
+
+#if defined DEBUG && DEBUG > 1
+static void print_binary(unsigned int number)
+{
+	int i,i2;
+	char buffer[64];
+	memset(buffer,0,64);
+	i2=0;
+	for (i=31;i>=0;i--) {
+		if (number & (1<<i))
+			buffer[i2++]='1';
+		else
+			buffer[i2++]='0';
+		if ((i&3)==0)
+			buffer[i2++]=' ';
+	}
+	pr_debug("%s\n",buffer);
+}
+#endif
+
+static const struct net_device_ops netdev_ops = {
+	.ndo_open		= xircom_open,
+	.ndo_stop		= xircom_close,
+	.ndo_start_xmit		= xircom_start_xmit,
+	.ndo_change_mtu		= eth_change_mtu,
+	.ndo_set_mac_address	= eth_mac_addr,
+	.ndo_validate_addr	= eth_validate_addr,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller	= xircom_poll_controller,
+#endif
+};
+
+/* xircom_probe is the code that gets called on device insertion.
+   it sets up the hardware and registers the device to the networklayer.
+
+   TODO: Send 1 or 2 "dummy" packets here as the card seems to discard the
+         first two packets that get send, and pump hates that.
+
+ */
+static int __devinit xircom_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+{
+	struct net_device *dev = NULL;
+	struct xircom_private *private;
+	unsigned long flags;
+	unsigned short tmp16;
+
+	/* First do the PCI initialisation */
+
+	if (pci_enable_device(pdev))
+		return -ENODEV;
+
+	/* disable all powermanagement */
+	pci_write_config_dword(pdev, PCI_POWERMGMT, 0x0000);
+
+	pci_set_master(pdev); /* Why isn't this done by pci_enable_device ?*/
+
+	/* clear PCI status, if any */
+	pci_read_config_word (pdev,PCI_STATUS, &tmp16);
+	pci_write_config_word (pdev, PCI_STATUS,tmp16);
+
+	if (!request_region(pci_resource_start(pdev, 0), 128, "xircom_cb")) {
+		pr_err("%s: failed to allocate io-region\n", __func__);
+		return -ENODEV;
+	}
+
+	/*
+	   Before changing the hardware, allocate the memory.
+	   This way, we can fail gracefully if not enough memory
+	   is available.
+	 */
+	dev = alloc_etherdev(sizeof(struct xircom_private));
+	if (!dev) {
+		pr_err("%s: failed to allocate etherdev\n", __func__);
+		goto device_fail;
+	}
+	private = netdev_priv(dev);
+
+	/* Allocate the send/receive buffers */
+	private->rx_buffer = pci_alloc_consistent(pdev,8192,&private->rx_dma_handle);
+	if (private->rx_buffer == NULL) {
+		pr_err("%s: no memory for rx buffer\n", __func__);
+		goto rx_buf_fail;
+	}
+	private->tx_buffer = pci_alloc_consistent(pdev,8192,&private->tx_dma_handle);
+	if (private->tx_buffer == NULL) {
+		pr_err("%s: no memory for tx buffer\n", __func__);
+		goto tx_buf_fail;
+	}
+
+	SET_NETDEV_DEV(dev, &pdev->dev);
+
+
+	private->dev = dev;
+	private->pdev = pdev;
+	private->io_port = pci_resource_start(pdev, 0);
+	spin_lock_init(&private->lock);
+	dev->irq = pdev->irq;
+	dev->base_addr = private->io_port;
+
+	initialize_card(private);
+	read_mac_address(private);
+	setup_descriptors(private);
+
+	dev->netdev_ops = &netdev_ops;
+	pci_set_drvdata(pdev, dev);
+
+	if (register_netdev(dev)) {
+		pr_err("%s: netdevice registration failed\n", __func__);
+		goto reg_fail;
+	}
+
+	netdev_info(dev, "Xircom cardbus revision %i at irq %i\n",
+		    pdev->revision, pdev->irq);
+	/* start the transmitter to get a heartbeat */
+	/* TODO: send 2 dummy packets here */
+	transceiver_voodoo(private);
+
+	spin_lock_irqsave(&private->lock,flags);
+	activate_transmitter(private);
+	activate_receiver(private);
+	spin_unlock_irqrestore(&private->lock,flags);
+
+	trigger_receive(private);
+
+	return 0;
+
+reg_fail:
+	kfree(private->tx_buffer);
+tx_buf_fail:
+	kfree(private->rx_buffer);
+rx_buf_fail:
+	free_netdev(dev);
+device_fail:
+	return -ENODEV;
+}
+
+
+/*
+ xircom_remove is called on module-unload or on device-eject.
+ it unregisters the irq, io-region and network device.
+ Interrupts and such are already stopped in the "ifconfig ethX down"
+ code.
+ */
+static void __devexit xircom_remove(struct pci_dev *pdev)
+{
+	struct net_device *dev = pci_get_drvdata(pdev);
+	struct xircom_private *card = netdev_priv(dev);
+
+	pci_free_consistent(pdev,8192,card->rx_buffer,card->rx_dma_handle);
+	pci_free_consistent(pdev,8192,card->tx_buffer,card->tx_dma_handle);
+
+	release_region(dev->base_addr, 128);
+	unregister_netdev(dev);
+	free_netdev(dev);
+	pci_set_drvdata(pdev, NULL);
+}
+
+static irqreturn_t xircom_interrupt(int irq, void *dev_instance)
+{
+	struct net_device *dev = (struct net_device *) dev_instance;
+	struct xircom_private *card = netdev_priv(dev);
+	unsigned int status;
+	int i;
+
+	spin_lock(&card->lock);
+	status = inl(card->io_port+CSR5);
+
+#if defined DEBUG && DEBUG > 1
+	print_binary(status);
+	pr_debug("tx status 0x%08x 0x%08x\n",
+		 card->tx_buffer[0], card->tx_buffer[4]);
+	pr_debug("rx status 0x%08x 0x%08x\n",
+		 card->rx_buffer[0], card->rx_buffer[4]);
+#endif
+	/* Handle shared irq and hotplug */
+	if (status == 0 || status == 0xffffffff) {
+		spin_unlock(&card->lock);
+		return IRQ_NONE;
+	}
+
+	if (link_status_changed(card)) {
+		int newlink;
+		netdev_dbg(dev, "Link status has changed\n");
+		newlink = link_status(card);
+		netdev_info(dev, "Link is %d mbit\n", newlink);
+		if (newlink)
+			netif_carrier_on(dev);
+		else
+			netif_carrier_off(dev);
+
+	}
+
+	/* Clear all remaining interrupts */
+	status |= 0xffffffff; /* FIXME: make this clear only the
+				        real existing bits */
+	outl(status,card->io_port+CSR5);
+
+
+	for (i=0;i<NUMDESCRIPTORS;i++)
+		investigate_write_descriptor(dev,card,i,bufferoffsets[i]);
+	for (i=0;i<NUMDESCRIPTORS;i++)
+		investigate_read_descriptor(dev,card,i,bufferoffsets[i]);
+
+	spin_unlock(&card->lock);
+	return IRQ_HANDLED;
+}
+
+static netdev_tx_t xircom_start_xmit(struct sk_buff *skb,
+					   struct net_device *dev)
+{
+	struct xircom_private *card;
+	unsigned long flags;
+	int nextdescriptor;
+	int desc;
+
+	card = netdev_priv(dev);
+	spin_lock_irqsave(&card->lock,flags);
+
+	/* First see if we can free some descriptors */
+	for (desc=0;desc<NUMDESCRIPTORS;desc++)
+		investigate_write_descriptor(dev,card,desc,bufferoffsets[desc]);
+
+
+	nextdescriptor = (card->transmit_used +1) % (NUMDESCRIPTORS);
+	desc = card->transmit_used;
+
+	/* only send the packet if the descriptor is free */
+	if (card->tx_buffer[4*desc]==0) {
+			/* Copy the packet data; zero the memory first as the card
+			   sometimes sends more than you ask it to. */
+
+			memset(&card->tx_buffer[bufferoffsets[desc]/4],0,1536);
+			skb_copy_from_linear_data(skb,
+				  &(card->tx_buffer[bufferoffsets[desc] / 4]),
+						  skb->len);
+			/* FIXME: The specification tells us that the length we send HAS to be a multiple of
+			   4 bytes. */
+
+			card->tx_buffer[4*desc+1] = cpu_to_le32(skb->len);
+			if (desc == NUMDESCRIPTORS - 1) /* bit 25: last descriptor of the ring */
+				card->tx_buffer[4*desc+1] |= cpu_to_le32(1<<25);  
+
+			card->tx_buffer[4*desc+1] |= cpu_to_le32(0xF0000000);
+						 /* 0xF0... means want interrupts*/
+			card->tx_skb[desc] = skb;
+
+			wmb();
+			/* This gives the descriptor to the card */
+			card->tx_buffer[4*desc] = cpu_to_le32(0x80000000);
+			trigger_transmit(card);
+			if (card->tx_buffer[nextdescriptor*4] & cpu_to_le32(0x8000000)) {
+				/* next descriptor is occupied... */
+				netif_stop_queue(dev);
+			}
+			card->transmit_used = nextdescriptor;
+			spin_unlock_irqrestore(&card->lock,flags);
+			return NETDEV_TX_OK;
+	}
+
+	/* Uh oh... no free descriptor... drop the packet */
+	netif_stop_queue(dev);
+	spin_unlock_irqrestore(&card->lock,flags);
+	trigger_transmit(card);
+
+	return NETDEV_TX_BUSY;
+}
+
+
+
+
+static int xircom_open(struct net_device *dev)
+{
+	struct xircom_private *xp = netdev_priv(dev);
+	int retval;
+
+	netdev_info(dev, "xircom cardbus adaptor found, using irq %i\n",
+		    dev->irq);
+	retval = request_irq(dev->irq, xircom_interrupt, IRQF_SHARED, dev->name, dev);
+	if (retval)
+		return retval;
+
+	xircom_up(xp);
+	xp->open = 1;
+
+	return 0;
+}
+
+static int xircom_close(struct net_device *dev)
+{
+	struct xircom_private *card;
+	unsigned long flags;
+
+	card = netdev_priv(dev);
+	netif_stop_queue(dev); /* we don't want new packets */
+
+
+	spin_lock_irqsave(&card->lock,flags);
+
+	disable_all_interrupts(card);
+#if 0
+	/* We can enable this again once we send dummy packets on ifconfig ethX up */
+	deactivate_receiver(card);
+	deactivate_transmitter(card);
+#endif
+	remove_descriptors(card);
+
+	spin_unlock_irqrestore(&card->lock,flags);
+
+	card->open = 0;
+	free_irq(dev->irq,dev);
+
+	return 0;
+
+}
+
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+static void xircom_poll_controller(struct net_device *dev)
+{
+	disable_irq(dev->irq);
+	xircom_interrupt(dev->irq, dev);
+	enable_irq(dev->irq);
+}
+#endif
+
+
+static void initialize_card(struct xircom_private *card)
+{
+	unsigned int val;
+	unsigned long flags;
+
+	spin_lock_irqsave(&card->lock, flags);
+
+	/* First: reset the card */
+	val = inl(card->io_port + CSR0);
+	val |= 0x01;		/* Software reset */
+	outl(val, card->io_port + CSR0);
+
+	udelay(100);		/* give the card some time to reset */
+
+	val = inl(card->io_port + CSR0);
+	val &= ~0x01;		/* disable Software reset */
+	outl(val, card->io_port + CSR0);
+
+
+	val = 0;		/* Value 0x00 is a safe and conservative value
+				   for the PCI configuration settings */
+	outl(val, card->io_port + CSR0);
+
+
+	disable_all_interrupts(card);
+	deactivate_receiver(card);
+	deactivate_transmitter(card);
+
+	spin_unlock_irqrestore(&card->lock, flags);
+}
+
+/*
+trigger_transmit causes the card to check for frames to be transmitted.
+This is accomplished by writing to the CSR1 port. The documentation
+claims that the act of writing is sufficient and that the value is
+ignored; I chose zero.
+*/
+static void trigger_transmit(struct xircom_private *card)
+{
+	unsigned int val;
+
+	val = 0;
+	outl(val, card->io_port + CSR1);
+}
+
+/*
+trigger_receive causes the card to check for empty frames in the
+descriptor list in which packets can be received.
+This is accomplished by writing to the CSR2 port. The documentation
+claims that the act of writing is sufficient and that the value is
+ignored; I chose zero.
+*/
+static void trigger_receive(struct xircom_private *card)
+{
+	unsigned int val;
+
+	val = 0;
+	outl(val, card->io_port + CSR2);
+}
+
+/*
+setup_descriptors initializes the send and receive buffers to be valid
+descriptors and programs the addresses into the card.
+*/
+static void setup_descriptors(struct xircom_private *card)
+{
+	u32 address;
+	int i;
+
+	BUG_ON(card->rx_buffer == NULL);
+	BUG_ON(card->tx_buffer == NULL);
+
+	/* Receive descriptors */
+	memset(card->rx_buffer, 0, 128);	/* clear the descriptors */
+	for (i=0;i<NUMDESCRIPTORS;i++ ) {
+
+		/* Rx Descr0: It's empty, let the card own it, no errors -> 0x80000000 */
+		card->rx_buffer[i*4 + 0] = cpu_to_le32(0x80000000);
+		/* Rx Descr1: buffer 1 is 1536 bytes, buffer 2 is 0 bytes */
+		card->rx_buffer[i*4 + 1] = cpu_to_le32(1536);
+		if (i == NUMDESCRIPTORS - 1) /* bit 25 is "last descriptor" */
+			card->rx_buffer[i*4 + 1] |= cpu_to_le32(1 << 25);
+
+		/* Rx Descr2: address of the buffer
+		   we store the buffer at the 2nd half of the page */
+
+		address = card->rx_dma_handle;
+		card->rx_buffer[i*4 + 2] = cpu_to_le32(address + bufferoffsets[i]);
+		/* Rx Desc3: address of 2nd buffer -> 0 */
+		card->rx_buffer[i*4 + 3] = 0;
+	}
+
+	wmb();
+	/* Write the receive descriptor ring address to the card */
+	address = card->rx_dma_handle;
+	outl(address, card->io_port + CSR3);	/* Receive descr list address */
+
+
+	/* transmit descriptors */
+	memset(card->tx_buffer, 0, 128);	/* clear the descriptors */
+
+	for (i=0;i<NUMDESCRIPTORS;i++ ) {
+		/* Tx Descr0: Empty, we own it, no errors -> 0x00000000 */
+		card->tx_buffer[i*4 + 0] = 0x00000000;
+		/* Tx Descr1: buffer 1 is 1536 bytes, buffer 2 is 0 bytes */
+		card->tx_buffer[i*4 + 1] = cpu_to_le32(1536);
+		if (i == NUMDESCRIPTORS - 1) /* bit 25 is "last descriptor" */
+			card->tx_buffer[i*4 + 1] |= cpu_to_le32(1 << 25);
+
+		/* Tx Descr2: address of the buffer
+		   we store the buffer at the 2nd half of the page */
+		address = card->tx_dma_handle;
+		card->tx_buffer[i*4 + 2] = cpu_to_le32(address + bufferoffsets[i]);
+		/* Tx Desc3: address of 2nd buffer -> 0 */
+		card->tx_buffer[i*4 + 3] = 0;
+	}
+
+	wmb();
+	/* wite the transmit descriptor ring to the card */
+	address = card->tx_dma_handle;
+	outl(address, card->io_port + CSR4);	/* xmit descr list address */
+}
+
+/*
+remove_descriptors informs the card the descriptors are no longer
+valid by setting the address in the card to 0x00.
+*/
+static void remove_descriptors(struct xircom_private *card)
+{
+	unsigned int val;
+
+	val = 0;
+	outl(val, card->io_port + CSR3);	/* Receive descriptor address */
+	outl(val, card->io_port + CSR4);	/* Send descriptor address */
+}
+
+/*
+link_status_changed returns 1 if the card has indicated that
+the link status has changed. The new link status has to be read from CSR12.
+
+This function also clears the status-bit.
+*/
+static int link_status_changed(struct xircom_private *card)
+{
+	unsigned int val;
+
+	val = inl(card->io_port + CSR5);	/* Status register */
+
+	if ((val & (1 << 27)) == 0)		/* no change */
+		return 0;
+
+	/* clear the event by writing a 1 to the bit in the
+	   status register. */
+	val = (1 << 27);
+	outl(val, card->io_port + CSR5);
+
+	return 1;
+}
+
+
+/*
+transmit_active returns 1 if the transmitter on the card is
+in a non-stopped state.
+*/
+static int transmit_active(struct xircom_private *card)
+{
+	unsigned int val;
+
+	val = inl(card->io_port + CSR5);	/* Status register */
+
+	if ((val & (7 << 20)) == 0)		/* transmitter disabled */
+		return 0;
+
+	return 1;
+}
+
+/*
+receive_active returns 1 if the receiver on the card is
+in a non-stopped state.
+*/
+static int receive_active(struct xircom_private *card)
+{
+	unsigned int val;
+
+	val = inl(card->io_port + CSR5);	/* Status register */
+
+	if ((val & (7 << 17)) == 0)		/* receiver disabled */
+		return 0;
+
+	return 1;
+}
+
+/*
+activate_receiver enables the receiver on the card.
+Before being allowed to active the receiver, the receiver
+must be completely de-activated. To achieve this,
+this code actually disables the receiver first; then it waits for the
+receiver to become inactive, then it activates the receiver and then
+it waits for the receiver to be active.
+
+must be called with the lock held and interrupts disabled.
+*/
+static void activate_receiver(struct xircom_private *card)
+{
+	unsigned int val;
+	int counter;
+
+	val = inl(card->io_port + CSR6);	/* Operation mode */
+
+	/* If the "active" bit is set and the receiver is already
+	   active, no need to do the expensive thing */
+	if ((val&2) && (receive_active(card)))
+		return;
+
+
+	val = val & ~2;		/* disable the receiver */
+	outl(val, card->io_port + CSR6);
+
+	counter = 10;
+	while (counter > 0) {
+		if (!receive_active(card))
+			break;
+		/* wait a while */
+		udelay(50);
+		counter--;
+		if (counter <= 0)
+			netdev_err(card->dev, "Receiver failed to deactivate\n");
+	}
+
+	/* enable the receiver */
+	val = inl(card->io_port + CSR6);	/* Operation mode */
+	val = val | 2;				/* enable the receiver */
+	outl(val, card->io_port + CSR6);
+
+	/* now wait for the card to activate again */
+	counter = 10;
+	while (counter > 0) {
+		if (receive_active(card))
+			break;
+		/* wait a while */
+		udelay(50);
+		counter--;
+		if (counter <= 0)
+			netdev_err(card->dev,
+				   "Receiver failed to re-activate\n");
+	}
+}
+
+/*
+deactivate_receiver disables the receiver on the card.
+To achieve this this code disables the receiver first;
+then it waits for the receiver to become inactive.
+
+must be called with the lock held and interrupts disabled.
+*/
+static void deactivate_receiver(struct xircom_private *card)
+{
+	unsigned int val;
+	int counter;
+
+	val = inl(card->io_port + CSR6);	/* Operation mode */
+	val = val & ~2;				/* disable the receiver */
+	outl(val, card->io_port + CSR6);
+
+	counter = 10;
+	while (counter > 0) {
+		if (!receive_active(card))
+			break;
+		/* wait a while */
+		udelay(50);
+		counter--;
+		if (counter <= 0)
+			netdev_err(card->dev, "Receiver failed to deactivate\n");
+	}
+}
+
+
+/*
+activate_transmitter enables the transmitter on the card.
+Before being allowed to active the transmitter, the transmitter
+must be completely de-activated. To achieve this,
+this code actually disables the transmitter first; then it waits for the
+transmitter to become inactive, then it activates the transmitter and then
+it waits for the transmitter to be active again.
+
+must be called with the lock held and interrupts disabled.
+*/
+static void activate_transmitter(struct xircom_private *card)
+{
+	unsigned int val;
+	int counter;
+
+	val = inl(card->io_port + CSR6);	/* Operation mode */
+
+	/* If the "active" bit is set and the receiver is already
+	   active, no need to do the expensive thing */
+	if ((val&(1<<13)) && (transmit_active(card)))
+		return;
+
+	val = val & ~(1 << 13);	/* disable the transmitter */
+	outl(val, card->io_port + CSR6);
+
+	counter = 10;
+	while (counter > 0) {
+		if (!transmit_active(card))
+			break;
+		/* wait a while */
+		udelay(50);
+		counter--;
+		if (counter <= 0)
+			netdev_err(card->dev,
+				   "Transmitter failed to deactivate\n");
+	}
+
+	/* enable the transmitter */
+	val = inl(card->io_port + CSR6);	/* Operation mode */
+	val = val | (1 << 13);	/* enable the transmitter */
+	outl(val, card->io_port + CSR6);
+
+	/* now wait for the card to activate again */
+	counter = 10;
+	while (counter > 0) {
+		if (transmit_active(card))
+			break;
+		/* wait a while */
+		udelay(50);
+		counter--;
+		if (counter <= 0)
+			netdev_err(card->dev,
+				   "Transmitter failed to re-activate\n");
+	}
+}
+
+/*
+deactivate_transmitter disables the transmitter on the card.
+To achieve this this code disables the transmitter first;
+then it waits for the transmitter to become inactive.
+
+must be called with the lock held and interrupts disabled.
+*/
+static void deactivate_transmitter(struct xircom_private *card)
+{
+	unsigned int val;
+	int counter;
+
+	val = inl(card->io_port + CSR6);	/* Operation mode */
+	val = val & ~2;		/* disable the transmitter */
+	outl(val, card->io_port + CSR6);
+
+	counter = 20;
+	while (counter > 0) {
+		if (!transmit_active(card))
+			break;
+		/* wait a while */
+		udelay(50);
+		counter--;
+		if (counter <= 0)
+			netdev_err(card->dev,
+				   "Transmitter failed to deactivate\n");
+	}
+}
+
+
+/*
+enable_transmit_interrupt enables the transmit interrupt
+
+must be called with the lock held and interrupts disabled.
+*/
+static void enable_transmit_interrupt(struct xircom_private *card)
+{
+	unsigned int val;
+
+	val = inl(card->io_port + CSR7);	/* Interrupt enable register */
+	val |= 1;				/* enable the transmit interrupt */
+	outl(val, card->io_port + CSR7);
+}
+
+
+/*
+enable_receive_interrupt enables the receive interrupt
+
+must be called with the lock held and interrupts disabled.
+*/
+static void enable_receive_interrupt(struct xircom_private *card)
+{
+	unsigned int val;
+
+	val = inl(card->io_port + CSR7);	/* Interrupt enable register */
+	val = val | (1 << 6);			/* enable the receive interrupt */
+	outl(val, card->io_port + CSR7);
+}
+
+/*
+enable_link_interrupt enables the link status change interrupt
+
+must be called with the lock held and interrupts disabled.
+*/
+static void enable_link_interrupt(struct xircom_private *card)
+{
+	unsigned int val;
+
+	val = inl(card->io_port + CSR7);	/* Interrupt enable register */
+	val = val | (1 << 27);			/* enable the link status chage interrupt */
+	outl(val, card->io_port + CSR7);
+}
+
+
+
+/*
+disable_all_interrupts disables all interrupts
+
+must be called with the lock held and interrupts disabled.
+*/
+static void disable_all_interrupts(struct xircom_private *card)
+{
+	unsigned int val;
+
+	val = 0;				/* disable all interrupts */
+	outl(val, card->io_port + CSR7);
+}
+
+/*
+enable_common_interrupts enables several weird interrupts
+
+must be called with the lock held and interrupts disabled.
+*/
+static void enable_common_interrupts(struct xircom_private *card)
+{
+	unsigned int val;
+
+	val = inl(card->io_port + CSR7);	/* Interrupt enable register */
+	val |= (1<<16); /* Normal Interrupt Summary */
+	val |= (1<<15); /* Abnormal Interrupt Summary */
+	val |= (1<<13); /* Fatal bus error */
+	val |= (1<<8);  /* Receive Process Stopped */
+	val |= (1<<7);  /* Receive Buffer Unavailable */
+	val |= (1<<5);  /* Transmit Underflow */
+	val |= (1<<2);  /* Transmit Buffer Unavailable */
+	val |= (1<<1);  /* Transmit Process Stopped */
+	outl(val, card->io_port + CSR7);
+}
+
+/*
+enable_promisc starts promisc mode
+
+must be called with the lock held and interrupts disabled.
+*/
+static int enable_promisc(struct xircom_private *card)
+{
+	unsigned int val;
+
+	val = inl(card->io_port + CSR6);
+	val = val | (1 << 6);
+	outl(val, card->io_port + CSR6);
+
+	return 1;
+}
+
+
+
+
+/*
+link_status() checks the links status and will return 0 for no link, 10 for 10mbit link and 100 for.. guess what.
+
+Must be called in locked state with interrupts disabled
+*/
+static int link_status(struct xircom_private *card)
+{
+	unsigned int val;
+
+	val = inb(card->io_port + CSR12);
+
+	if (!(val&(1<<2)))  /* bit 2 is 0 for 10mbit link, 1 for not an 10mbit link */
+		return 10;
+	if (!(val&(1<<1)))  /* bit 1 is 0 for 100mbit link, 1 for not an 100mbit link */
+		return 100;
+
+	/* If we get here -> no link at all */
+
+	return 0;
+}
+
+
+
+
+
+/*
+  read_mac_address() reads the MAC address from the NIC and stores it in the "dev" structure.
+
+  This function will take the spinlock itself and can, as a result, not be called with the lock helt.
+ */
+static void read_mac_address(struct xircom_private *card)
+{
+	unsigned char j, tuple, link, data_id, data_count;
+	unsigned long flags;
+	int i;
+
+	spin_lock_irqsave(&card->lock, flags);
+
+	outl(1 << 12, card->io_port + CSR9);	/* enable boot rom access */
+	for (i = 0x100; i < 0x1f7; i += link + 2) {
+		outl(i, card->io_port + CSR10);
+		tuple = inl(card->io_port + CSR9) & 0xff;
+		outl(i + 1, card->io_port + CSR10);
+		link = inl(card->io_port + CSR9) & 0xff;
+		outl(i + 2, card->io_port + CSR10);
+		data_id = inl(card->io_port + CSR9) & 0xff;
+		outl(i + 3, card->io_port + CSR10);
+		data_count = inl(card->io_port + CSR9) & 0xff;
+		if ((tuple == 0x22) && (data_id == 0x04) && (data_count == 0x06)) {
+			/*
+			 * This is it.  We have the data we want.
+			 */
+			for (j = 0; j < 6; j++) {
+				outl(i + j + 4, card->io_port + CSR10);
+				card->dev->dev_addr[j] = inl(card->io_port + CSR9) & 0xff;
+			}
+			break;
+		} else if (link == 0) {
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&card->lock, flags);
+	pr_debug(" %pM\n", card->dev->dev_addr);
+}
+
+
+/*
+ transceiver_voodoo() enables the external UTP plug thingy.
+ it's called voodoo as I stole this code and cannot cross-reference
+ it with the specification.
+ */
+static void transceiver_voodoo(struct xircom_private *card)
+{
+	unsigned long flags;
+
+	/* disable all powermanagement */
+	pci_write_config_dword(card->pdev, PCI_POWERMGMT, 0x0000);
+
+	setup_descriptors(card);
+
+	spin_lock_irqsave(&card->lock, flags);
+
+	outl(0x0008, card->io_port + CSR15);
+        udelay(25);
+        outl(0xa8050000, card->io_port + CSR15);
+        udelay(25);
+        outl(0xa00f0000, card->io_port + CSR15);
+        udelay(25);
+
+        spin_unlock_irqrestore(&card->lock, flags);
+
+	netif_start_queue(card->dev);
+}
+
+
+static void xircom_up(struct xircom_private *card)
+{
+	unsigned long flags;
+	int i;
+
+	/* disable all powermanagement */
+	pci_write_config_dword(card->pdev, PCI_POWERMGMT, 0x0000);
+
+	setup_descriptors(card);
+
+	spin_lock_irqsave(&card->lock, flags);
+
+
+	enable_link_interrupt(card);
+	enable_transmit_interrupt(card);
+	enable_receive_interrupt(card);
+	enable_common_interrupts(card);
+	enable_promisc(card);
+
+	/* The card can have received packets already, read them away now */
+	for (i=0;i<NUMDESCRIPTORS;i++)
+		investigate_read_descriptor(card->dev,card,i,bufferoffsets[i]);
+
+
+	spin_unlock_irqrestore(&card->lock, flags);
+	trigger_receive(card);
+	trigger_transmit(card);
+	netif_start_queue(card->dev);
+}
+
+/* Bufferoffset is in BYTES */
+static void
+investigate_read_descriptor(struct net_device *dev, struct xircom_private *card,
+			    int descnr, unsigned int bufferoffset)
+{
+	int status;
+
+	status = le32_to_cpu(card->rx_buffer[4*descnr]);
+
+	if (status > 0) {		/* packet received */
+
+		/* TODO: discard error packets */
+
+		short pkt_len = ((status >> 16) & 0x7ff) - 4;
+					/* minus 4, we don't want the CRC */
+		struct sk_buff *skb;
+
+		if (pkt_len > 1518) {
+			netdev_err(dev, "Packet length %i is bogus\n", pkt_len);
+			pkt_len = 1518;
+		}
+
+		skb = dev_alloc_skb(pkt_len + 2);
+		if (skb == NULL) {
+			dev->stats.rx_dropped++;
+			goto out;
+		}
+		skb_reserve(skb, 2);
+		skb_copy_to_linear_data(skb,
+					&card->rx_buffer[bufferoffset / 4],
+					pkt_len);
+		skb_put(skb, pkt_len);
+		skb->protocol = eth_type_trans(skb, dev);
+		netif_rx(skb);
+		dev->stats.rx_packets++;
+		dev->stats.rx_bytes += pkt_len;
+
+out:
+		/* give the buffer back to the card */
+		card->rx_buffer[4*descnr] = cpu_to_le32(0x80000000);
+		trigger_receive(card);
+	}
+}
+
+
+/* Bufferoffset is in BYTES */
+static void
+investigate_write_descriptor(struct net_device *dev,
+			     struct xircom_private *card,
+			     int descnr, unsigned int bufferoffset)
+{
+	int status;
+
+	status = le32_to_cpu(card->tx_buffer[4*descnr]);
+#if 0
+	if (status & 0x8000) {	/* Major error */
+		pr_err("Major transmit error status %x\n", status);
+		card->tx_buffer[4*descnr] = 0;
+		netif_wake_queue (dev);
+	}
+#endif
+	if (status > 0) {	/* bit 31 is 0 when done */
+		if (card->tx_skb[descnr]!=NULL) {
+			dev->stats.tx_bytes += card->tx_skb[descnr]->len;
+			dev_kfree_skb_irq(card->tx_skb[descnr]);
+		}
+		card->tx_skb[descnr] = NULL;
+		/* Bit 8 in the status field is 1 if there was a collision */
+		if (status & (1 << 8))
+			dev->stats.collisions++;
+		card->tx_buffer[4*descnr] = 0; /* descriptor is free again */
+		netif_wake_queue (dev);
+		dev->stats.tx_packets++;
+	}
+}
+
+static int __init xircom_init(void)
+{
+	return pci_register_driver(&xircom_ops);
+}
+
+static void __exit xircom_exit(void)
+{
+	pci_unregister_driver(&xircom_ops);
+}
+
+module_init(xircom_init)
+module_exit(xircom_exit)
+
