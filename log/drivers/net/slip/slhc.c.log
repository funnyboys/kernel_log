commit 110a40dfb708fe940a3f3704d470e431c368d256
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Mar 4 15:51:43 2020 -0800

    slip: make slhc_compress() more robust against malicious packets
    
    Before accessing various fields in IPV4 network header
    and TCP header, make sure the packet :
    
    - Has IP version 4 (ip->version == 4)
    - Has not a silly network length (ip->ihl >= 5)
    - Is big enough to hold network and transport headers
    - Has not a silly TCP header size (th->doff >= sizeof(struct tcphdr) / 4)
    
    syzbot reported :
    
    BUG: KMSAN: uninit-value in slhc_compress+0x5b9/0x2e60 drivers/net/slip/slhc.c:270
    CPU: 0 PID: 11728 Comm: syz-executor231 Not tainted 5.6.0-rc2-syzkaller #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Call Trace:
     __dump_stack lib/dump_stack.c:77 [inline]
     dump_stack+0x1c9/0x220 lib/dump_stack.c:118
     kmsan_report+0xf7/0x1e0 mm/kmsan/kmsan_report.c:118
     __msan_warning+0x58/0xa0 mm/kmsan/kmsan_instr.c:215
     slhc_compress+0x5b9/0x2e60 drivers/net/slip/slhc.c:270
     ppp_send_frame drivers/net/ppp/ppp_generic.c:1637 [inline]
     __ppp_xmit_process+0x1902/0x2970 drivers/net/ppp/ppp_generic.c:1495
     ppp_xmit_process+0x147/0x2f0 drivers/net/ppp/ppp_generic.c:1516
     ppp_write+0x6bb/0x790 drivers/net/ppp/ppp_generic.c:512
     do_loop_readv_writev fs/read_write.c:717 [inline]
     do_iter_write+0x812/0xdc0 fs/read_write.c:1000
     compat_writev+0x2df/0x5a0 fs/read_write.c:1351
     do_compat_pwritev64 fs/read_write.c:1400 [inline]
     __do_compat_sys_pwritev fs/read_write.c:1420 [inline]
     __se_compat_sys_pwritev fs/read_write.c:1414 [inline]
     __ia32_compat_sys_pwritev+0x349/0x3f0 fs/read_write.c:1414
     do_syscall_32_irqs_on arch/x86/entry/common.c:339 [inline]
     do_fast_syscall_32+0x3c7/0x6e0 arch/x86/entry/common.c:410
     entry_SYSENTER_compat+0x68/0x77 arch/x86/entry/entry_64_compat.S:139
    RIP: 0023:0xf7f7cd99
    Code: 90 e8 0b 00 00 00 f3 90 0f ae e8 eb f9 8d 74 26 00 89 3c 24 c3 90 90 90 90 90 90 90 90 90 90 90 90 51 52 55 89 e5 0f 34 cd 80 <5d> 5a 59 c3 90 90 90 90 eb 0d 90 90 90 90 90 90 90 90 90 90 90 90
    RSP: 002b:00000000ffdb84ac EFLAGS: 00000217 ORIG_RAX: 000000000000014e
    RAX: ffffffffffffffda RBX: 0000000000000003 RCX: 00000000200001c0
    RDX: 0000000000000001 RSI: 0000000000000000 RDI: 0000000000000003
    RBP: 0000000040047459 R08: 0000000000000000 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000
    R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000
    
    Uninit was created at:
     kmsan_save_stack_with_flags mm/kmsan/kmsan.c:144 [inline]
     kmsan_internal_poison_shadow+0x66/0xd0 mm/kmsan/kmsan.c:127
     kmsan_slab_alloc+0x8a/0xe0 mm/kmsan/kmsan_hooks.c:82
     slab_alloc_node mm/slub.c:2793 [inline]
     __kmalloc_node_track_caller+0xb40/0x1200 mm/slub.c:4401
     __kmalloc_reserve net/core/skbuff.c:142 [inline]
     __alloc_skb+0x2fd/0xac0 net/core/skbuff.c:210
     alloc_skb include/linux/skbuff.h:1051 [inline]
     ppp_write+0x115/0x790 drivers/net/ppp/ppp_generic.c:500
     do_loop_readv_writev fs/read_write.c:717 [inline]
     do_iter_write+0x812/0xdc0 fs/read_write.c:1000
     compat_writev+0x2df/0x5a0 fs/read_write.c:1351
     do_compat_pwritev64 fs/read_write.c:1400 [inline]
     __do_compat_sys_pwritev fs/read_write.c:1420 [inline]
     __se_compat_sys_pwritev fs/read_write.c:1414 [inline]
     __ia32_compat_sys_pwritev+0x349/0x3f0 fs/read_write.c:1414
     do_syscall_32_irqs_on arch/x86/entry/common.c:339 [inline]
     do_fast_syscall_32+0x3c7/0x6e0 arch/x86/entry/common.c:410
     entry_SYSENTER_compat+0x68/0x77 arch/x86/entry/entry_64_compat.S:139
    
    Fixes: b5451d783ade ("slip: Move the SLIP drivers")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/slip/slhc.c b/drivers/net/slip/slhc.c
index 58a69f830d29..f78ceba42e57 100644
--- a/drivers/net/slip/slhc.c
+++ b/drivers/net/slip/slhc.c
@@ -232,7 +232,7 @@ slhc_compress(struct slcompress *comp, unsigned char *icp, int isize,
 	struct cstate *cs = lcs->next;
 	unsigned long deltaS, deltaA;
 	short changes = 0;
-	int hlen;
+	int nlen, hlen;
 	unsigned char new_seq[16];
 	unsigned char *cp = new_seq;
 	struct iphdr *ip;
@@ -248,6 +248,8 @@ slhc_compress(struct slcompress *comp, unsigned char *icp, int isize,
 		return isize;
 
 	ip = (struct iphdr *) icp;
+	if (ip->version != 4 || ip->ihl < 5)
+		return isize;
 
 	/* Bail if this packet isn't TCP, or is an IP fragment */
 	if (ip->protocol != IPPROTO_TCP || (ntohs(ip->frag_off) & 0x3fff)) {
@@ -258,10 +260,14 @@ slhc_compress(struct slcompress *comp, unsigned char *icp, int isize,
 			comp->sls_o_tcp++;
 		return isize;
 	}
-	/* Extract TCP header */
+	nlen = ip->ihl * 4;
+	if (isize < nlen + sizeof(*th))
+		return isize;
 
-	th = (struct tcphdr *)(((unsigned char *)ip) + ip->ihl*4);
-	hlen = ip->ihl*4 + th->doff*4;
+	th = (struct tcphdr *)(icp + nlen);
+	if (th->doff < sizeof(struct tcphdr) / 4)
+		return isize;
+	hlen = nlen + th->doff * 4;
 
 	/*  Bail if the TCP packet isn't `compressible' (i.e., ACK isn't set or
 	 *  some other control bit is set). Also uncompressible if

commit 9d2f11238398793be11830a6f41908652b661395
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Aug 5 23:34:41 2019 +0300

    net: delete "register" keyword
    
    Delete long obsoleted "register" keyword.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/slip/slhc.c b/drivers/net/slip/slhc.c
index ea90db3c7705..58a69f830d29 100644
--- a/drivers/net/slip/slhc.c
+++ b/drivers/net/slip/slhc.c
@@ -91,8 +91,8 @@ static unsigned short pull16(unsigned char **cpp);
 struct slcompress *
 slhc_init(int rslots, int tslots)
 {
-	register short i;
-	register struct cstate *ts;
+	short i;
+	struct cstate *ts;
 	struct slcompress *comp;
 
 	if (rslots < 0 || rslots > 255 || tslots < 0 || tslots > 255)
@@ -206,7 +206,7 @@ pull16(unsigned char **cpp)
 static long
 decode(unsigned char **cpp)
 {
-	register int x;
+	int x;
 
 	x = *(*cpp)++;
 	if(x == 0){
@@ -227,14 +227,14 @@ int
 slhc_compress(struct slcompress *comp, unsigned char *icp, int isize,
 	unsigned char *ocp, unsigned char **cpp, int compress_cid)
 {
-	register struct cstate *ocs = &(comp->tstate[comp->xmit_oldest]);
-	register struct cstate *lcs = ocs;
-	register struct cstate *cs = lcs->next;
-	register unsigned long deltaS, deltaA;
-	register short changes = 0;
+	struct cstate *ocs = &(comp->tstate[comp->xmit_oldest]);
+	struct cstate *lcs = ocs;
+	struct cstate *cs = lcs->next;
+	unsigned long deltaS, deltaA;
+	short changes = 0;
 	int hlen;
 	unsigned char new_seq[16];
-	register unsigned char *cp = new_seq;
+	unsigned char *cp = new_seq;
 	struct iphdr *ip;
 	struct tcphdr *th, *oth;
 	__sum16 csum;
@@ -486,11 +486,11 @@ slhc_compress(struct slcompress *comp, unsigned char *icp, int isize,
 int
 slhc_uncompress(struct slcompress *comp, unsigned char *icp, int isize)
 {
-	register int changes;
+	int changes;
 	long x;
-	register struct tcphdr *thp;
-	register struct iphdr *ip;
-	register struct cstate *cs;
+	struct tcphdr *thp;
+	struct iphdr *ip;
+	struct cstate *cs;
 	int len, hdrlen;
 	unsigned char *cp = icp;
 
@@ -543,7 +543,7 @@ slhc_uncompress(struct slcompress *comp, unsigned char *icp, int isize)
 	switch(changes & SPECIALS_MASK){
 	case SPECIAL_I:		/* Echoed terminal traffic */
 		{
-		register short i;
+		short i;
 		i = ntohs(ip->tot_len) - hdrlen;
 		thp->ack_seq = htonl( ntohl(thp->ack_seq) + i);
 		thp->seq = htonl( ntohl(thp->seq) + i);
@@ -637,7 +637,7 @@ slhc_uncompress(struct slcompress *comp, unsigned char *icp, int isize)
 int
 slhc_remember(struct slcompress *comp, unsigned char *icp, int isize)
 {
-	register struct cstate *cs;
+	struct cstate *cs;
 	unsigned ihl;
 
 	unsigned char index;

commit baf76f0c58aec435a3a864075b8f6d8ee5d1f17e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 25 16:13:58 2019 -0700

    slip: make slhc_free() silently accept an error pointer
    
    This way, slhc_free() accepts what slhc_init() returns, whether that is
    an error or not.
    
    In particular, the pattern in sl_alloc_bufs() is
    
            slcomp = slhc_init(16, 16);
            ...
            slhc_free(slcomp);
    
    for the error handling path, and rather than complicate that code, just
    make it ok to always free what was returned by the init function.
    
    That's what the code used to do before commit 4ab42d78e37a ("ppp, slip:
    Validate VJ compression slot parameters completely") when slhc_init()
    just returned NULL for the error case, with no actual indication of the
    details of the error.
    
    Reported-by: syzbot+45474c076a4927533d2e@syzkaller.appspotmail.com
    Fixes: 4ab42d78e37a ("ppp, slip: Validate VJ compression slot parameters completely")
    Acked-by: Ben Hutchings <ben@decadent.org.uk>
    Cc: David Miller <davem@davemloft.net>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/net/slip/slhc.c b/drivers/net/slip/slhc.c
index f4e93f5fc204..ea90db3c7705 100644
--- a/drivers/net/slip/slhc.c
+++ b/drivers/net/slip/slhc.c
@@ -153,7 +153,7 @@ slhc_init(int rslots, int tslots)
 void
 slhc_free(struct slcompress *comp)
 {
-	if ( comp == NULLSLCOMPR )
+	if ( IS_ERR_OR_NULL(comp) )
 		return;
 
 	if ( comp->tstate != NULLSLSTATE )

commit 3f01ddb962dc506916c243f9524e8bef97119b77
Author: Tejaswi Tanikella <tejaswit@codeaurora.org>
Date:   Wed Apr 11 16:34:47 2018 +0530

    slip: Check if rstate is initialized before uncompressing
    
    On receiving a packet the state index points to the rstate which must be
    used to fill up IP and TCP headers. But if the state index points to a
    rstate which is unitialized, i.e. filled with zeros, it gets stuck in an
    infinite loop inside ip_fast_csum trying to compute the ip checsum of a
    header with zero length.
    
    89.666953:   <2> [<ffffff9dd3e94d38>] slhc_uncompress+0x464/0x468
    89.666965:   <2> [<ffffff9dd3e87d88>] ppp_receive_nonmp_frame+0x3b4/0x65c
    89.666978:   <2> [<ffffff9dd3e89dd4>] ppp_receive_frame+0x64/0x7e0
    89.666991:   <2> [<ffffff9dd3e8a708>] ppp_input+0x104/0x198
    89.667005:   <2> [<ffffff9dd3e93868>] pppopns_recv_core+0x238/0x370
    89.667027:   <2> [<ffffff9dd4428fc8>] __sk_receive_skb+0xdc/0x250
    89.667040:   <2> [<ffffff9dd3e939e4>] pppopns_recv+0x44/0x60
    89.667053:   <2> [<ffffff9dd4426848>] __sock_queue_rcv_skb+0x16c/0x24c
    89.667065:   <2> [<ffffff9dd4426954>] sock_queue_rcv_skb+0x2c/0x38
    89.667085:   <2> [<ffffff9dd44f7358>] raw_rcv+0x124/0x154
    89.667098:   <2> [<ffffff9dd44f7568>] raw_local_deliver+0x1e0/0x22c
    89.667117:   <2> [<ffffff9dd44c8ba0>] ip_local_deliver_finish+0x70/0x24c
    89.667131:   <2> [<ffffff9dd44c92f4>] ip_local_deliver+0x100/0x10c
    
    ./scripts/faddr2line vmlinux slhc_uncompress+0x464/0x468 output:
     ip_fast_csum at arch/arm64/include/asm/checksum.h:40
     (inlined by) slhc_uncompress at drivers/net/slip/slhc.c:615
    
    Adding a variable to indicate if the current rstate is initialized. If
    such a packet arrives, move to toss state.
    
    Signed-off-by: Tejaswi Tanikella <tejaswit@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/slip/slhc.c b/drivers/net/slip/slhc.c
index 5782733959f0..f4e93f5fc204 100644
--- a/drivers/net/slip/slhc.c
+++ b/drivers/net/slip/slhc.c
@@ -509,6 +509,10 @@ slhc_uncompress(struct slcompress *comp, unsigned char *icp, int isize)
 		if(x < 0 || x > comp->rslot_limit)
 			goto bad;
 
+		/* Check if the cstate is initialized */
+		if (!comp->rstate[x].initialized)
+			goto bad;
+
 		comp->flags &=~ SLF_TOSS;
 		comp->recv_current = x;
 	} else {
@@ -673,6 +677,7 @@ slhc_remember(struct slcompress *comp, unsigned char *icp, int isize)
 	if (cs->cs_tcp.doff > 5)
 	  memcpy(cs->cs_tcpopt, icp + ihl*4 + sizeof(struct tcphdr), (cs->cs_tcp.doff - 5) * 4);
 	cs->cs_hsize = ihl*2 + cs->cs_tcp.doff*2;
+	cs->initialized = true;
 	/* Put headers back on packet
 	 * Neither header checksum is recalculated
 	 */

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/net/slip/slhc.c b/drivers/net/slip/slhc.c
index 27ed25252aac..5782733959f0 100644
--- a/drivers/net/slip/slhc.c
+++ b/drivers/net/slip/slhc.c
@@ -75,7 +75,7 @@
 #include <linux/skbuff.h>
 #include <net/sock.h>
 #include <linux/timer.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <net/checksum.h>
 #include <asm/unaligned.h>
 

commit 4ab42d78e37a294ac7bc56901d563c642e03c4ae
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Sun Nov 1 16:22:53 2015 +0000

    ppp, slip: Validate VJ compression slot parameters completely
    
    Currently slhc_init() treats out-of-range values of rslots and tslots
    as equivalent to 0, except that if tslots is too large it will
    dereference a null pointer (CVE-2015-7799).
    
    Add a range-check at the top of the function and make it return an
    ERR_PTR() on error instead of NULL.  Change the callers accordingly.
    
    Compile-tested only.
    
    Reported-by: 郭永刚 <guoyonggang@360.cn>
    References: http://article.gmane.org/gmane.comp.security.oss.general/17908
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/slip/slhc.c b/drivers/net/slip/slhc.c
index 079f7adfcde5..27ed25252aac 100644
--- a/drivers/net/slip/slhc.c
+++ b/drivers/net/slip/slhc.c
@@ -84,8 +84,9 @@ static long decode(unsigned char **cpp);
 static unsigned char * put16(unsigned char *cp, unsigned short x);
 static unsigned short pull16(unsigned char **cpp);
 
-/* Initialize compression data structure
+/* Allocate compression data structure
  *	slots must be in range 0 to 255 (zero meaning no compression)
+ * Returns pointer to structure or ERR_PTR() on error.
  */
 struct slcompress *
 slhc_init(int rslots, int tslots)
@@ -94,11 +95,14 @@ slhc_init(int rslots, int tslots)
 	register struct cstate *ts;
 	struct slcompress *comp;
 
+	if (rslots < 0 || rslots > 255 || tslots < 0 || tslots > 255)
+		return ERR_PTR(-EINVAL);
+
 	comp = kzalloc(sizeof(struct slcompress), GFP_KERNEL);
 	if (! comp)
 		goto out_fail;
 
-	if ( rslots > 0  &&  rslots < 256 ) {
+	if (rslots > 0) {
 		size_t rsize = rslots * sizeof(struct cstate);
 		comp->rstate = kzalloc(rsize, GFP_KERNEL);
 		if (! comp->rstate)
@@ -106,7 +110,7 @@ slhc_init(int rslots, int tslots)
 		comp->rslot_limit = rslots - 1;
 	}
 
-	if ( tslots > 0  &&  tslots < 256 ) {
+	if (tslots > 0) {
 		size_t tsize = tslots * sizeof(struct cstate);
 		comp->tstate = kzalloc(tsize, GFP_KERNEL);
 		if (! comp->tstate)
@@ -141,7 +145,7 @@ slhc_init(int rslots, int tslots)
 out_free:
 	kfree(comp);
 out_fail:
-	return NULL;
+	return ERR_PTR(-ENOMEM);
 }
 
 

commit 8904120b52e0ca35597ca743bb67db5d273ecd2c
Author: Fabian Frederick <fabf@skynet.be>
Date:   Sat Jul 12 20:09:48 2014 +0200

    slip: remove unnecessary break after goto
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/slip/slhc.c b/drivers/net/slip/slhc.c
index 1252d9c726a7..079f7adfcde5 100644
--- a/drivers/net/slip/slhc.c
+++ b/drivers/net/slip/slhc.c
@@ -396,7 +396,6 @@ slhc_compress(struct slcompress *comp, unsigned char *icp, int isize,
 		   ntohs(cs->cs_ip.tot_len) == hlen)
 			break;
 		goto uncompressed;
-		break;
 	case SPECIAL_I:
 	case SPECIAL_D:
 		/* actual changes match one of our special case encodings --

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/net/slip/slhc.c b/drivers/net/slip/slhc.c
index 0a0a6643cf3a..1252d9c726a7 100644
--- a/drivers/net/slip/slhc.c
+++ b/drivers/net/slip/slhc.c
@@ -75,7 +75,6 @@
 #include <linux/skbuff.h>
 #include <net/sock.h>
 #include <linux/timer.h>
-#include <asm/system.h>
 #include <asm/uaccess.h>
 #include <net/checksum.h>
 #include <asm/unaligned.h>

commit b5451d783ade99308dfccdf5ca284ed07affa4ff
Author: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Date:   Wed Aug 3 03:17:13 2011 -0700

    slip: Move the SLIP drivers
    
    Move the Serial Line Internet Protocol (SLIP) drivers into
    drivers/net/slip/ and make the necessary Kconfig and Makefile
    changes.
    
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Acked-by: Alan Cox <alan@linux.intel.com>

diff --git a/drivers/net/slip/slhc.c b/drivers/net/slip/slhc.c
new file mode 100644
index 000000000000..0a0a6643cf3a
--- /dev/null
+++ b/drivers/net/slip/slhc.c
@@ -0,0 +1,742 @@
+/*
+ * Routines to compress and uncompress tcp packets (for transmission
+ * over low speed serial lines).
+ *
+ * Copyright (c) 1989 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by the University of California, Berkeley.  The name of the
+ * University may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ *	Van Jacobson (van@helios.ee.lbl.gov), Dec 31, 1989:
+ *	- Initial distribution.
+ *
+ *
+ * modified for KA9Q Internet Software Package by
+ * Katie Stevens (dkstevens@ucdavis.edu)
+ * University of California, Davis
+ * Computing Services
+ *	- 01-31-90	initial adaptation (from 1.19)
+ *	PPP.05	02-15-90 [ks]
+ *	PPP.08	05-02-90 [ks]	use PPP protocol field to signal compression
+ *	PPP.15	09-90	 [ks]	improve mbuf handling
+ *	PPP.16	11-02	 [karn]	substantially rewritten to use NOS facilities
+ *
+ *	- Feb 1991	Bill_Simpson@um.cc.umich.edu
+ *			variable number of conversation slots
+ *			allow zero or one slots
+ *			separate routines
+ *			status display
+ *	- Jul 1994	Dmitry Gorodchanin
+ *			Fixes for memory leaks.
+ *      - Oct 1994      Dmitry Gorodchanin
+ *                      Modularization.
+ *	- Jan 1995	Bjorn Ekwall
+ *			Use ip_fast_csum from ip.h
+ *	- July 1995	Christos A. Polyzols
+ *			Spotted bug in tcp option checking
+ *
+ *
+ *	This module is a difficult issue. It's clearly inet code but it's also clearly
+ *	driver code belonging close to PPP and SLIP
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <net/slhc_vj.h>
+
+#ifdef CONFIG_INET
+/* Entire module is for IP only */
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/termios.h>
+#include <linux/in.h>
+#include <linux/fcntl.h>
+#include <linux/inet.h>
+#include <linux/netdevice.h>
+#include <net/ip.h>
+#include <net/protocol.h>
+#include <net/icmp.h>
+#include <net/tcp.h>
+#include <linux/skbuff.h>
+#include <net/sock.h>
+#include <linux/timer.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+#include <net/checksum.h>
+#include <asm/unaligned.h>
+
+static unsigned char *encode(unsigned char *cp, unsigned short n);
+static long decode(unsigned char **cpp);
+static unsigned char * put16(unsigned char *cp, unsigned short x);
+static unsigned short pull16(unsigned char **cpp);
+
+/* Initialize compression data structure
+ *	slots must be in range 0 to 255 (zero meaning no compression)
+ */
+struct slcompress *
+slhc_init(int rslots, int tslots)
+{
+	register short i;
+	register struct cstate *ts;
+	struct slcompress *comp;
+
+	comp = kzalloc(sizeof(struct slcompress), GFP_KERNEL);
+	if (! comp)
+		goto out_fail;
+
+	if ( rslots > 0  &&  rslots < 256 ) {
+		size_t rsize = rslots * sizeof(struct cstate);
+		comp->rstate = kzalloc(rsize, GFP_KERNEL);
+		if (! comp->rstate)
+			goto out_free;
+		comp->rslot_limit = rslots - 1;
+	}
+
+	if ( tslots > 0  &&  tslots < 256 ) {
+		size_t tsize = tslots * sizeof(struct cstate);
+		comp->tstate = kzalloc(tsize, GFP_KERNEL);
+		if (! comp->tstate)
+			goto out_free2;
+		comp->tslot_limit = tslots - 1;
+	}
+
+	comp->xmit_oldest = 0;
+	comp->xmit_current = 255;
+	comp->recv_current = 255;
+	/*
+	 * don't accept any packets with implicit index until we get
+	 * one with an explicit index.  Otherwise the uncompress code
+	 * will try to use connection 255, which is almost certainly
+	 * out of range
+	 */
+	comp->flags |= SLF_TOSS;
+
+	if ( tslots > 0 ) {
+		ts = comp->tstate;
+		for(i = comp->tslot_limit; i > 0; --i){
+			ts[i].cs_this = i;
+			ts[i].next = &(ts[i - 1]);
+		}
+		ts[0].next = &(ts[comp->tslot_limit]);
+		ts[0].cs_this = 0;
+	}
+	return comp;
+
+out_free2:
+	kfree(comp->rstate);
+out_free:
+	kfree(comp);
+out_fail:
+	return NULL;
+}
+
+
+/* Free a compression data structure */
+void
+slhc_free(struct slcompress *comp)
+{
+	if ( comp == NULLSLCOMPR )
+		return;
+
+	if ( comp->tstate != NULLSLSTATE )
+		kfree( comp->tstate );
+
+	if ( comp->rstate != NULLSLSTATE )
+		kfree( comp->rstate );
+
+	kfree( comp );
+}
+
+
+/* Put a short in host order into a char array in network order */
+static inline unsigned char *
+put16(unsigned char *cp, unsigned short x)
+{
+	*cp++ = x >> 8;
+	*cp++ = x;
+
+	return cp;
+}
+
+
+/* Encode a number */
+static unsigned char *
+encode(unsigned char *cp, unsigned short n)
+{
+	if(n >= 256 || n == 0){
+		*cp++ = 0;
+		cp = put16(cp,n);
+	} else {
+		*cp++ = n;
+	}
+	return cp;
+}
+
+/* Pull a 16-bit integer in host order from buffer in network byte order */
+static unsigned short
+pull16(unsigned char **cpp)
+{
+	short rval;
+
+	rval = *(*cpp)++;
+	rval <<= 8;
+	rval |= *(*cpp)++;
+	return rval;
+}
+
+/* Decode a number */
+static long
+decode(unsigned char **cpp)
+{
+	register int x;
+
+	x = *(*cpp)++;
+	if(x == 0){
+		return pull16(cpp) & 0xffff;	/* pull16 returns -1 on error */
+	} else {
+		return x & 0xff;		/* -1 if PULLCHAR returned error */
+	}
+}
+
+/*
+ * icp and isize are the original packet.
+ * ocp is a place to put a copy if necessary.
+ * cpp is initially a pointer to icp.  If the copy is used,
+ *    change it to ocp.
+ */
+
+int
+slhc_compress(struct slcompress *comp, unsigned char *icp, int isize,
+	unsigned char *ocp, unsigned char **cpp, int compress_cid)
+{
+	register struct cstate *ocs = &(comp->tstate[comp->xmit_oldest]);
+	register struct cstate *lcs = ocs;
+	register struct cstate *cs = lcs->next;
+	register unsigned long deltaS, deltaA;
+	register short changes = 0;
+	int hlen;
+	unsigned char new_seq[16];
+	register unsigned char *cp = new_seq;
+	struct iphdr *ip;
+	struct tcphdr *th, *oth;
+	__sum16 csum;
+
+
+	/*
+	 *	Don't play with runt packets.
+	 */
+
+	if(isize<sizeof(struct iphdr))
+		return isize;
+
+	ip = (struct iphdr *) icp;
+
+	/* Bail if this packet isn't TCP, or is an IP fragment */
+	if (ip->protocol != IPPROTO_TCP || (ntohs(ip->frag_off) & 0x3fff)) {
+		/* Send as regular IP */
+		if(ip->protocol != IPPROTO_TCP)
+			comp->sls_o_nontcp++;
+		else
+			comp->sls_o_tcp++;
+		return isize;
+	}
+	/* Extract TCP header */
+
+	th = (struct tcphdr *)(((unsigned char *)ip) + ip->ihl*4);
+	hlen = ip->ihl*4 + th->doff*4;
+
+	/*  Bail if the TCP packet isn't `compressible' (i.e., ACK isn't set or
+	 *  some other control bit is set). Also uncompressible if
+	 *  it's a runt.
+	 */
+	if(hlen > isize || th->syn || th->fin || th->rst ||
+	    ! (th->ack)){
+		/* TCP connection stuff; send as regular IP */
+		comp->sls_o_tcp++;
+		return isize;
+	}
+	/*
+	 * Packet is compressible -- we're going to send either a
+	 * COMPRESSED_TCP or UNCOMPRESSED_TCP packet.  Either way,
+	 * we need to locate (or create) the connection state.
+	 *
+	 * States are kept in a circularly linked list with
+	 * xmit_oldest pointing to the end of the list.  The
+	 * list is kept in lru order by moving a state to the
+	 * head of the list whenever it is referenced.  Since
+	 * the list is short and, empirically, the connection
+	 * we want is almost always near the front, we locate
+	 * states via linear search.  If we don't find a state
+	 * for the datagram, the oldest state is (re-)used.
+	 */
+	for ( ; ; ) {
+		if( ip->saddr == cs->cs_ip.saddr
+		 && ip->daddr == cs->cs_ip.daddr
+		 && th->source == cs->cs_tcp.source
+		 && th->dest == cs->cs_tcp.dest)
+			goto found;
+
+		/* if current equal oldest, at end of list */
+		if ( cs == ocs )
+			break;
+		lcs = cs;
+		cs = cs->next;
+		comp->sls_o_searches++;
+	}
+	/*
+	 * Didn't find it -- re-use oldest cstate.  Send an
+	 * uncompressed packet that tells the other side what
+	 * connection number we're using for this conversation.
+	 *
+	 * Note that since the state list is circular, the oldest
+	 * state points to the newest and we only need to set
+	 * xmit_oldest to update the lru linkage.
+	 */
+	comp->sls_o_misses++;
+	comp->xmit_oldest = lcs->cs_this;
+	goto uncompressed;
+
+found:
+	/*
+	 * Found it -- move to the front on the connection list.
+	 */
+	if(lcs == ocs) {
+ 		/* found at most recently used */
+	} else if (cs == ocs) {
+		/* found at least recently used */
+		comp->xmit_oldest = lcs->cs_this;
+	} else {
+		/* more than 2 elements */
+		lcs->next = cs->next;
+		cs->next = ocs->next;
+		ocs->next = cs;
+	}
+
+	/*
+	 * Make sure that only what we expect to change changed.
+	 * Check the following:
+	 * IP protocol version, header length & type of service.
+	 * The "Don't fragment" bit.
+	 * The time-to-live field.
+	 * The TCP header length.
+	 * IP options, if any.
+	 * TCP options, if any.
+	 * If any of these things are different between the previous &
+	 * current datagram, we send the current datagram `uncompressed'.
+	 */
+	oth = &cs->cs_tcp;
+
+	if(ip->version != cs->cs_ip.version || ip->ihl != cs->cs_ip.ihl
+	 || ip->tos != cs->cs_ip.tos
+	 || (ip->frag_off & htons(0x4000)) != (cs->cs_ip.frag_off & htons(0x4000))
+	 || ip->ttl != cs->cs_ip.ttl
+	 || th->doff != cs->cs_tcp.doff
+	 || (ip->ihl > 5 && memcmp(ip+1,cs->cs_ipopt,((ip->ihl)-5)*4) != 0)
+	 || (th->doff > 5 && memcmp(th+1,cs->cs_tcpopt,((th->doff)-5)*4) != 0)){
+		goto uncompressed;
+	}
+
+	/*
+	 * Figure out which of the changing fields changed.  The
+	 * receiver expects changes in the order: urgent, window,
+	 * ack, seq (the order minimizes the number of temporaries
+	 * needed in this section of code).
+	 */
+	if(th->urg){
+		deltaS = ntohs(th->urg_ptr);
+		cp = encode(cp,deltaS);
+		changes |= NEW_U;
+	} else if(th->urg_ptr != oth->urg_ptr){
+		/* argh! URG not set but urp changed -- a sensible
+		 * implementation should never do this but RFC793
+		 * doesn't prohibit the change so we have to deal
+		 * with it. */
+		goto uncompressed;
+	}
+	if((deltaS = ntohs(th->window) - ntohs(oth->window)) != 0){
+		cp = encode(cp,deltaS);
+		changes |= NEW_W;
+	}
+	if((deltaA = ntohl(th->ack_seq) - ntohl(oth->ack_seq)) != 0L){
+		if(deltaA > 0x0000ffff)
+			goto uncompressed;
+		cp = encode(cp,deltaA);
+		changes |= NEW_A;
+	}
+	if((deltaS = ntohl(th->seq) - ntohl(oth->seq)) != 0L){
+		if(deltaS > 0x0000ffff)
+			goto uncompressed;
+		cp = encode(cp,deltaS);
+		changes |= NEW_S;
+	}
+
+	switch(changes){
+	case 0:	/* Nothing changed. If this packet contains data and the
+		 * last one didn't, this is probably a data packet following
+		 * an ack (normal on an interactive connection) and we send
+		 * it compressed.  Otherwise it's probably a retransmit,
+		 * retransmitted ack or window probe.  Send it uncompressed
+		 * in case the other side missed the compressed version.
+		 */
+		if(ip->tot_len != cs->cs_ip.tot_len &&
+		   ntohs(cs->cs_ip.tot_len) == hlen)
+			break;
+		goto uncompressed;
+		break;
+	case SPECIAL_I:
+	case SPECIAL_D:
+		/* actual changes match one of our special case encodings --
+		 * send packet uncompressed.
+		 */
+		goto uncompressed;
+	case NEW_S|NEW_A:
+		if(deltaS == deltaA &&
+		    deltaS == ntohs(cs->cs_ip.tot_len) - hlen){
+			/* special case for echoed terminal traffic */
+			changes = SPECIAL_I;
+			cp = new_seq;
+		}
+		break;
+	case NEW_S:
+		if(deltaS == ntohs(cs->cs_ip.tot_len) - hlen){
+			/* special case for data xfer */
+			changes = SPECIAL_D;
+			cp = new_seq;
+		}
+		break;
+	}
+	deltaS = ntohs(ip->id) - ntohs(cs->cs_ip.id);
+	if(deltaS != 1){
+		cp = encode(cp,deltaS);
+		changes |= NEW_I;
+	}
+	if(th->psh)
+		changes |= TCP_PUSH_BIT;
+	/* Grab the cksum before we overwrite it below.  Then update our
+	 * state with this packet's header.
+	 */
+	csum = th->check;
+	memcpy(&cs->cs_ip,ip,20);
+	memcpy(&cs->cs_tcp,th,20);
+	/* We want to use the original packet as our compressed packet.
+	 * (cp - new_seq) is the number of bytes we need for compressed
+	 * sequence numbers.  In addition we need one byte for the change
+	 * mask, one for the connection id and two for the tcp checksum.
+	 * So, (cp - new_seq) + 4 bytes of header are needed.
+	 */
+	deltaS = cp - new_seq;
+	if(compress_cid == 0 || comp->xmit_current != cs->cs_this){
+		cp = ocp;
+		*cpp = ocp;
+		*cp++ = changes | NEW_C;
+		*cp++ = cs->cs_this;
+		comp->xmit_current = cs->cs_this;
+	} else {
+		cp = ocp;
+		*cpp = ocp;
+		*cp++ = changes;
+	}
+	*(__sum16 *)cp = csum;
+	cp += 2;
+/* deltaS is now the size of the change section of the compressed header */
+	memcpy(cp,new_seq,deltaS);	/* Write list of deltas */
+	memcpy(cp+deltaS,icp+hlen,isize-hlen);
+	comp->sls_o_compressed++;
+	ocp[0] |= SL_TYPE_COMPRESSED_TCP;
+	return isize - hlen + deltaS + (cp - ocp);
+
+	/* Update connection state cs & send uncompressed packet (i.e.,
+	 * a regular ip/tcp packet but with the 'conversation id' we hope
+	 * to use on future compressed packets in the protocol field).
+	 */
+uncompressed:
+	memcpy(&cs->cs_ip,ip,20);
+	memcpy(&cs->cs_tcp,th,20);
+	if (ip->ihl > 5)
+	  memcpy(cs->cs_ipopt, ip+1, ((ip->ihl) - 5) * 4);
+	if (th->doff > 5)
+	  memcpy(cs->cs_tcpopt, th+1, ((th->doff) - 5) * 4);
+	comp->xmit_current = cs->cs_this;
+	comp->sls_o_uncompressed++;
+	memcpy(ocp, icp, isize);
+	*cpp = ocp;
+	ocp[9] = cs->cs_this;
+	ocp[0] |= SL_TYPE_UNCOMPRESSED_TCP;
+	return isize;
+}
+
+
+int
+slhc_uncompress(struct slcompress *comp, unsigned char *icp, int isize)
+{
+	register int changes;
+	long x;
+	register struct tcphdr *thp;
+	register struct iphdr *ip;
+	register struct cstate *cs;
+	int len, hdrlen;
+	unsigned char *cp = icp;
+
+	/* We've got a compressed packet; read the change byte */
+	comp->sls_i_compressed++;
+	if(isize < 3){
+		comp->sls_i_error++;
+		return 0;
+	}
+	changes = *cp++;
+	if(changes & NEW_C){
+		/* Make sure the state index is in range, then grab the state.
+		 * If we have a good state index, clear the 'discard' flag.
+		 */
+		x = *cp++;	/* Read conn index */
+		if(x < 0 || x > comp->rslot_limit)
+			goto bad;
+
+		comp->flags &=~ SLF_TOSS;
+		comp->recv_current = x;
+	} else {
+		/* this packet has an implicit state index.  If we've
+		 * had a line error since the last time we got an
+		 * explicit state index, we have to toss the packet. */
+		if(comp->flags & SLF_TOSS){
+			comp->sls_i_tossed++;
+			return 0;
+		}
+	}
+	cs = &comp->rstate[comp->recv_current];
+	thp = &cs->cs_tcp;
+	ip = &cs->cs_ip;
+
+	thp->check = *(__sum16 *)cp;
+	cp += 2;
+
+	thp->psh = (changes & TCP_PUSH_BIT) ? 1 : 0;
+/*
+ * we can use the same number for the length of the saved header and
+ * the current one, because the packet wouldn't have been sent
+ * as compressed unless the options were the same as the previous one
+ */
+
+	hdrlen = ip->ihl * 4 + thp->doff * 4;
+
+	switch(changes & SPECIALS_MASK){
+	case SPECIAL_I:		/* Echoed terminal traffic */
+		{
+		register short i;
+		i = ntohs(ip->tot_len) - hdrlen;
+		thp->ack_seq = htonl( ntohl(thp->ack_seq) + i);
+		thp->seq = htonl( ntohl(thp->seq) + i);
+		}
+		break;
+
+	case SPECIAL_D:			/* Unidirectional data */
+		thp->seq = htonl( ntohl(thp->seq) +
+				  ntohs(ip->tot_len) - hdrlen);
+		break;
+
+	default:
+		if(changes & NEW_U){
+			thp->urg = 1;
+			if((x = decode(&cp)) == -1) {
+				goto bad;
+			}
+			thp->urg_ptr = htons(x);
+		} else
+			thp->urg = 0;
+		if(changes & NEW_W){
+			if((x = decode(&cp)) == -1) {
+				goto bad;
+			}
+			thp->window = htons( ntohs(thp->window) + x);
+		}
+		if(changes & NEW_A){
+			if((x = decode(&cp)) == -1) {
+				goto bad;
+			}
+			thp->ack_seq = htonl( ntohl(thp->ack_seq) + x);
+		}
+		if(changes & NEW_S){
+			if((x = decode(&cp)) == -1) {
+				goto bad;
+			}
+			thp->seq = htonl( ntohl(thp->seq) + x);
+		}
+		break;
+	}
+	if(changes & NEW_I){
+		if((x = decode(&cp)) == -1) {
+			goto bad;
+		}
+		ip->id = htons (ntohs (ip->id) + x);
+	} else
+		ip->id = htons (ntohs (ip->id) + 1);
+
+	/*
+	 * At this point, cp points to the first byte of data in the
+	 * packet.  Put the reconstructed TCP and IP headers back on the
+	 * packet.  Recalculate IP checksum (but not TCP checksum).
+	 */
+
+	len = isize - (cp - icp);
+	if (len < 0)
+		goto bad;
+	len += hdrlen;
+	ip->tot_len = htons(len);
+	ip->check = 0;
+
+	memmove(icp + hdrlen, cp, len - hdrlen);
+
+	cp = icp;
+	memcpy(cp, ip, 20);
+	cp += 20;
+
+	if (ip->ihl > 5) {
+	  memcpy(cp, cs->cs_ipopt, (ip->ihl - 5) * 4);
+	  cp += (ip->ihl - 5) * 4;
+	}
+
+	put_unaligned(ip_fast_csum(icp, ip->ihl),
+		      &((struct iphdr *)icp)->check);
+
+	memcpy(cp, thp, 20);
+	cp += 20;
+
+	if (thp->doff > 5) {
+	  memcpy(cp, cs->cs_tcpopt, ((thp->doff) - 5) * 4);
+	  cp += ((thp->doff) - 5) * 4;
+	}
+
+	return len;
+bad:
+	comp->sls_i_error++;
+	return slhc_toss( comp );
+}
+
+
+int
+slhc_remember(struct slcompress *comp, unsigned char *icp, int isize)
+{
+	register struct cstate *cs;
+	unsigned ihl;
+
+	unsigned char index;
+
+	if(isize < 20) {
+		/* The packet is shorter than a legal IP header */
+		comp->sls_i_runt++;
+		return slhc_toss( comp );
+	}
+	/* Peek at the IP header's IHL field to find its length */
+	ihl = icp[0] & 0xf;
+	if(ihl < 20 / 4){
+		/* The IP header length field is too small */
+		comp->sls_i_runt++;
+		return slhc_toss( comp );
+	}
+	index = icp[9];
+	icp[9] = IPPROTO_TCP;
+
+	if (ip_fast_csum(icp, ihl)) {
+		/* Bad IP header checksum; discard */
+		comp->sls_i_badcheck++;
+		return slhc_toss( comp );
+	}
+	if(index > comp->rslot_limit) {
+		comp->sls_i_error++;
+		return slhc_toss(comp);
+	}
+
+	/* Update local state */
+	cs = &comp->rstate[comp->recv_current = index];
+	comp->flags &=~ SLF_TOSS;
+	memcpy(&cs->cs_ip,icp,20);
+	memcpy(&cs->cs_tcp,icp + ihl*4,20);
+	if (ihl > 5)
+	  memcpy(cs->cs_ipopt, icp + sizeof(struct iphdr), (ihl - 5) * 4);
+	if (cs->cs_tcp.doff > 5)
+	  memcpy(cs->cs_tcpopt, icp + ihl*4 + sizeof(struct tcphdr), (cs->cs_tcp.doff - 5) * 4);
+	cs->cs_hsize = ihl*2 + cs->cs_tcp.doff*2;
+	/* Put headers back on packet
+	 * Neither header checksum is recalculated
+	 */
+	comp->sls_i_uncompressed++;
+	return isize;
+}
+
+int
+slhc_toss(struct slcompress *comp)
+{
+	if ( comp == NULLSLCOMPR )
+		return 0;
+
+	comp->flags |= SLF_TOSS;
+	return 0;
+}
+
+#else /* CONFIG_INET */
+
+int
+slhc_toss(struct slcompress *comp)
+{
+  printk(KERN_DEBUG "Called IP function on non IP-system: slhc_toss");
+  return -EINVAL;
+}
+int
+slhc_uncompress(struct slcompress *comp, unsigned char *icp, int isize)
+{
+  printk(KERN_DEBUG "Called IP function on non IP-system: slhc_uncompress");
+  return -EINVAL;
+}
+int
+slhc_compress(struct slcompress *comp, unsigned char *icp, int isize,
+	unsigned char *ocp, unsigned char **cpp, int compress_cid)
+{
+  printk(KERN_DEBUG "Called IP function on non IP-system: slhc_compress");
+  return -EINVAL;
+}
+
+int
+slhc_remember(struct slcompress *comp, unsigned char *icp, int isize)
+{
+  printk(KERN_DEBUG "Called IP function on non IP-system: slhc_remember");
+  return -EINVAL;
+}
+
+void
+slhc_free(struct slcompress *comp)
+{
+  printk(KERN_DEBUG "Called IP function on non IP-system: slhc_free");
+}
+struct slcompress *
+slhc_init(int rslots, int tslots)
+{
+  printk(KERN_DEBUG "Called IP function on non IP-system: slhc_init");
+  return NULL;
+}
+
+#endif /* CONFIG_INET */
+
+/* VJ header compression */
+EXPORT_SYMBOL(slhc_init);
+EXPORT_SYMBOL(slhc_free);
+EXPORT_SYMBOL(slhc_remember);
+EXPORT_SYMBOL(slhc_compress);
+EXPORT_SYMBOL(slhc_uncompress);
+EXPORT_SYMBOL(slhc_toss);
+
+MODULE_LICENSE("Dual BSD/GPL");
