commit 845e0ebb4408d4473cf60d21224a897037e9a77a
Author: Cong Wang <xiyou.wangcong@gmail.com>
Date:   Mon Jun 8 14:53:01 2020 -0700

    net: change addr_list_lock back to static key
    
    The dynamic key update for addr_list_lock still causes troubles,
    for example the following race condition still exists:
    
    CPU 0:                          CPU 1:
    (RCU read lock)                 (RTNL lock)
    dev_mc_seq_show()               netdev_update_lockdep_key()
                                      -> lockdep_unregister_key()
     -> netif_addr_lock_bh()
    
    because lockdep doesn't provide an API to update it atomically.
    Therefore, we have to move it back to static keys and use subclass
    for nest locking like before.
    
    In commit 1a33e10e4a95 ("net: partially revert dynamic lockdep key
    changes"), I already reverted most parts of commit ab92d68fc22f
    ("net: core: add generic lockdep keys").
    
    This patch reverts the rest and also part of commit f3b0a18bb6cb
    ("net: remove unnecessary variables and callback"). After this
    patch, addr_list_lock changes back to using static keys and
    subclasses to satisfy lockdep. Thanks to dev->lower_level, we do
    not have to change back to ->ndo_get_lock_subclass().
    
    And hopefully this reduces some syzbot lockdep noises too.
    
    Reported-by: syzbot+f3a0e80c34b3fc28ac5e@syzkaller.appspotmail.com
    Cc: Taehee Yoo <ap420073@gmail.com>
    Cc: Dmitry Vyukov <dvyukov@google.com>
    Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 215c10923289..ddb3916d3506 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -1398,8 +1398,6 @@ static int bond_option_slaves_set(struct bonding *bond,
 	case '-':
 		slave_dbg(bond->dev, dev, "Releasing interface\n");
 		ret = bond_release(bond->dev, dev);
-		if (!ret)
-			netdev_update_lockdep_key(dev);
 		break;
 
 	default:

commit 064ff66e2bef84f1153087612032b5b9eab005bd
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Sat Feb 15 10:50:08 2020 +0000

    bonding: add missing netdev_update_lockdep_key()
    
    After bond_release(), netdev_update_lockdep_key() should be called.
    But both ioctl path and attribute path don't call
    netdev_update_lockdep_key().
    This patch adds missing netdev_update_lockdep_key().
    
    Test commands:
        ip link add bond0 type bond
        ip link add bond1 type bond
        ifenslave bond0 bond1
        ifenslave -d bond0 bond1
        ifenslave bond1 bond0
    
    Splat looks like:
    [   29.501182][ T1046] WARNING: possible circular locking dependency detected
    [   29.501945][ T1039] hardirqs last disabled at (1962): [<ffffffffac6c807f>] handle_mm_fault+0x13f/0x700
    [   29.503442][ T1046] 5.5.0+ #322 Not tainted
    [   29.503447][ T1046] ------------------------------------------------------
    [   29.504277][ T1039] softirqs last  enabled at (1180): [<ffffffffade00678>] __do_softirq+0x678/0x981
    [   29.505443][ T1046] ifenslave/1046 is trying to acquire lock:
    [   29.505886][ T1039] softirqs last disabled at (1169): [<ffffffffac19c18a>] irq_exit+0x17a/0x1a0
    [   29.509997][ T1046] ffff88805d5da280 (&dev->addr_list_lock_key#3){+...}, at: dev_mc_sync_multiple+0x95/0x120
    [   29.511243][ T1046]
    [   29.511243][ T1046] but task is already holding lock:
    [   29.512192][ T1046] ffff8880460f2280 (&dev->addr_list_lock_key#4){+...}, at: bond_enslave+0x4482/0x47b0 [bonding]
    [   29.514124][ T1046]
    [   29.514124][ T1046] which lock already depends on the new lock.
    [   29.514124][ T1046]
    [   29.517297][ T1046]
    [   29.517297][ T1046] the existing dependency chain (in reverse order) is:
    [   29.518231][ T1046]
    [   29.518231][ T1046] -> #1 (&dev->addr_list_lock_key#4){+...}:
    [   29.519076][ T1046]        _raw_spin_lock+0x30/0x70
    [   29.519588][ T1046]        dev_mc_sync_multiple+0x95/0x120
    [   29.520208][ T1046]        bond_enslave+0x448d/0x47b0 [bonding]
    [   29.520862][ T1046]        bond_option_slaves_set+0x1a3/0x370 [bonding]
    [   29.521640][ T1046]        __bond_opt_set+0x1ff/0xbb0 [bonding]
    [   29.522438][ T1046]        __bond_opt_set_notify+0x2b/0xf0 [bonding]
    [   29.523251][ T1046]        bond_opt_tryset_rtnl+0x92/0xf0 [bonding]
    [   29.524082][ T1046]        bonding_sysfs_store_option+0x8a/0xf0 [bonding]
    [   29.524959][ T1046]        kernfs_fop_write+0x276/0x410
    [   29.525620][ T1046]        vfs_write+0x197/0x4a0
    [   29.526218][ T1046]        ksys_write+0x141/0x1d0
    [   29.526818][ T1046]        do_syscall_64+0x99/0x4f0
    [   29.527430][ T1046]        entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [   29.528265][ T1046]
    [   29.528265][ T1046] -> #0 (&dev->addr_list_lock_key#3){+...}:
    [   29.529272][ T1046]        __lock_acquire+0x2d8d/0x3de0
    [   29.529935][ T1046]        lock_acquire+0x164/0x3b0
    [   29.530638][ T1046]        _raw_spin_lock+0x30/0x70
    [   29.531187][ T1046]        dev_mc_sync_multiple+0x95/0x120
    [   29.531790][ T1046]        bond_enslave+0x448d/0x47b0 [bonding]
    [   29.532451][ T1046]        bond_option_slaves_set+0x1a3/0x370 [bonding]
    [   29.533163][ T1046]        __bond_opt_set+0x1ff/0xbb0 [bonding]
    [   29.533789][ T1046]        __bond_opt_set_notify+0x2b/0xf0 [bonding]
    [   29.534595][ T1046]        bond_opt_tryset_rtnl+0x92/0xf0 [bonding]
    [   29.535500][ T1046]        bonding_sysfs_store_option+0x8a/0xf0 [bonding]
    [   29.536379][ T1046]        kernfs_fop_write+0x276/0x410
    [   29.537057][ T1046]        vfs_write+0x197/0x4a0
    [   29.537640][ T1046]        ksys_write+0x141/0x1d0
    [   29.538251][ T1046]        do_syscall_64+0x99/0x4f0
    [   29.538870][ T1046]        entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [   29.539659][ T1046]
    [   29.539659][ T1046] other info that might help us debug this:
    [   29.539659][ T1046]
    [   29.540953][ T1046]  Possible unsafe locking scenario:
    [   29.540953][ T1046]
    [   29.541883][ T1046]        CPU0                    CPU1
    [   29.542540][ T1046]        ----                    ----
    [   29.543209][ T1046]   lock(&dev->addr_list_lock_key#4);
    [   29.543880][ T1046]                                lock(&dev->addr_list_lock_key#3);
    [   29.544873][ T1046]                                lock(&dev->addr_list_lock_key#4);
    [   29.545863][ T1046]   lock(&dev->addr_list_lock_key#3);
    [   29.546525][ T1046]
    [   29.546525][ T1046]  *** DEADLOCK ***
    [   29.546525][ T1046]
    [   29.547542][ T1046] 5 locks held by ifenslave/1046:
    [   29.548196][ T1046]  #0: ffff88806044c478 (sb_writers#5){.+.+}, at: vfs_write+0x3bb/0x4a0
    [   29.549248][ T1046]  #1: ffff88805af00890 (&of->mutex){+.+.}, at: kernfs_fop_write+0x1cf/0x410
    [   29.550343][ T1046]  #2: ffff88805b8b54b0 (kn->count#157){.+.+}, at: kernfs_fop_write+0x1f2/0x410
    [   29.551575][ T1046]  #3: ffffffffaecf4cf0 (rtnl_mutex){+.+.}, at: bond_opt_tryset_rtnl+0x5f/0xf0 [bonding]
    [   29.552819][ T1046]  #4: ffff8880460f2280 (&dev->addr_list_lock_key#4){+...}, at: bond_enslave+0x4482/0x47b0 [bonding]
    [   29.554175][ T1046]
    [   29.554175][ T1046] stack backtrace:
    [   29.554907][ T1046] CPU: 0 PID: 1046 Comm: ifenslave Not tainted 5.5.0+ #322
    [   29.555854][ T1046] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [   29.557064][ T1046] Call Trace:
    [   29.557504][ T1046]  dump_stack+0x96/0xdb
    [   29.558054][ T1046]  check_noncircular+0x371/0x450
    [   29.558723][ T1046]  ? print_circular_bug.isra.35+0x310/0x310
    [   29.559486][ T1046]  ? hlock_class+0x130/0x130
    [   29.560100][ T1046]  ? __lock_acquire+0x2d8d/0x3de0
    [   29.560761][ T1046]  __lock_acquire+0x2d8d/0x3de0
    [   29.561366][ T1046]  ? register_lock_class+0x14d0/0x14d0
    [   29.562045][ T1046]  ? find_held_lock+0x39/0x1d0
    [   29.562641][ T1046]  lock_acquire+0x164/0x3b0
    [   29.563199][ T1046]  ? dev_mc_sync_multiple+0x95/0x120
    [   29.563872][ T1046]  _raw_spin_lock+0x30/0x70
    [   29.564464][ T1046]  ? dev_mc_sync_multiple+0x95/0x120
    [   29.565146][ T1046]  dev_mc_sync_multiple+0x95/0x120
    [   29.565793][ T1046]  bond_enslave+0x448d/0x47b0 [bonding]
    [   29.566487][ T1046]  ? bond_update_slave_arr+0x940/0x940 [bonding]
    [   29.567279][ T1046]  ? bstr_printf+0xc20/0xc20
    [   29.567857][ T1046]  ? stack_trace_consume_entry+0x160/0x160
    [   29.568614][ T1046]  ? deactivate_slab.isra.77+0x2c5/0x800
    [   29.569320][ T1046]  ? check_chain_key+0x236/0x5d0
    [   29.569939][ T1046]  ? sscanf+0x93/0xc0
    [   29.570442][ T1046]  ? vsscanf+0x1e20/0x1e20
    [   29.571003][ T1046]  bond_option_slaves_set+0x1a3/0x370 [bonding]
    [ ... ]
    
    Fixes: ab92d68fc22f ("net: core: add generic lockdep keys")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index ddb3916d3506..215c10923289 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -1398,6 +1398,8 @@ static int bond_option_slaves_set(struct bonding *bond,
 	case '-':
 		slave_dbg(bond->dev, dev, "Releasing interface\n");
 		ret = bond_release(bond->dev, dev);
+		if (!ret)
+			netdev_update_lockdep_key(dev);
 		break;
 
 	default:

commit 07a4ddec3ce9b0a533b5f90f582f1057390d5e63
Author: Vincent Bernat <vincent@bernat.ch>
Date:   Tue Jul 2 19:43:54 2019 +0200

    bonding: add an option to specify a delay between peer notifications
    
    Currently, gratuitous ARP/ND packets are sent every `miimon'
    milliseconds. This commit allows a user to specify a custom delay
    through a new option, `peer_notif_delay'.
    
    Like for `updelay' and `downdelay', this delay should be a multiple of
    `miimon' to avoid managing an additional work queue. The configuration
    logic is copied from `updelay' and `downdelay'. However, the default
    value cannot be set using a module parameter: Netlink or sysfs should
    be used to configure this feature.
    
    When setting `miimon' to 100 and `peer_notif_delay' to 500, we can
    observe the 500 ms delay is respected:
    
        20:30:19.354693 ARP, Request who-has 203.0.113.10 tell 203.0.113.10, length 28
        20:30:19.874892 ARP, Request who-has 203.0.113.10 tell 203.0.113.10, length 28
        20:30:20.394919 ARP, Request who-has 203.0.113.10 tell 203.0.113.10, length 28
        20:30:20.914963 ARP, Request who-has 203.0.113.10 tell 203.0.113.10, length 28
    
    In bond_mii_monitor(), I have tried to keep the lock logic readable.
    The change is due to the fact we cannot rely on a notification to
    lower the value of `bond->send_peer_notif' as `NETDEV_NOTIFY_PEERS' is
    only triggered once every N times, while we need to decrement the
    counter each time.
    
    iproute2 also needs to be updated to be able to specify this new
    attribute through `ip link'.
    
    Signed-off-by: Vincent Bernat <vincent@bernat.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 0d852fe9da7c..ddb3916d3506 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -24,6 +24,8 @@ static int bond_option_updelay_set(struct bonding *bond,
 				   const struct bond_opt_value *newval);
 static int bond_option_downdelay_set(struct bonding *bond,
 				     const struct bond_opt_value *newval);
+static int bond_option_peer_notif_delay_set(struct bonding *bond,
+					    const struct bond_opt_value *newval);
 static int bond_option_use_carrier_set(struct bonding *bond,
 				       const struct bond_opt_value *newval);
 static int bond_option_arp_interval_set(struct bonding *bond,
@@ -424,6 +426,13 @@ static const struct bond_option bond_opts[BOND_OPT_LAST] = {
 		.desc = "Number of peer notifications to send on failover event",
 		.values = bond_num_peer_notif_tbl,
 		.set = bond_option_num_peer_notif_set
+	},
+	[BOND_OPT_PEER_NOTIF_DELAY] = {
+		.id = BOND_OPT_PEER_NOTIF_DELAY,
+		.name = "peer_notif_delay",
+		.desc = "Delay between each peer notification on failover event, in milliseconds",
+		.values = bond_intmax_tbl,
+		.set = bond_option_peer_notif_delay_set
 	}
 };
 
@@ -841,6 +850,9 @@ static int bond_option_miimon_set(struct bonding *bond,
 	if (bond->params.downdelay)
 		netdev_dbg(bond->dev, "Note: Updating downdelay (to %d) since it is a multiple of the miimon value\n",
 			   bond->params.downdelay * bond->params.miimon);
+	if (bond->params.peer_notif_delay)
+		netdev_dbg(bond->dev, "Note: Updating peer_notif_delay (to %d) since it is a multiple of the miimon value\n",
+			   bond->params.peer_notif_delay * bond->params.miimon);
 	if (newval->value && bond->params.arp_interval) {
 		netdev_dbg(bond->dev, "MII monitoring cannot be used with ARP monitoring - disabling ARP monitoring...\n");
 		bond->params.arp_interval = 0;
@@ -864,52 +876,59 @@ static int bond_option_miimon_set(struct bonding *bond,
 	return 0;
 }
 
-/* Set up and down delays. These must be multiples of the
- * MII monitoring value, and are stored internally as the multiplier.
- * Thus, we must translate to MS for the real world.
+/* Set up, down and peer notification delays. These must be multiples
+ * of the MII monitoring value, and are stored internally as the
+ * multiplier. Thus, we must translate to MS for the real world.
  */
-static int bond_option_updelay_set(struct bonding *bond,
-				   const struct bond_opt_value *newval)
+static int _bond_option_delay_set(struct bonding *bond,
+				  const struct bond_opt_value *newval,
+				  const char *name,
+				  int *target)
 {
 	int value = newval->value;
 
 	if (!bond->params.miimon) {
-		netdev_err(bond->dev, "Unable to set up delay as MII monitoring is disabled\n");
+		netdev_err(bond->dev, "Unable to set %s as MII monitoring is disabled\n",
+			   name);
 		return -EPERM;
 	}
 	if ((value % bond->params.miimon) != 0) {
-		netdev_warn(bond->dev, "up delay (%d) is not a multiple of miimon (%d), updelay rounded to %d ms\n",
+		netdev_warn(bond->dev,
+			    "%s (%d) is not a multiple of miimon (%d), value rounded to %d ms\n",
+			    name,
 			    value, bond->params.miimon,
 			    (value / bond->params.miimon) *
 			    bond->params.miimon);
 	}
-	bond->params.updelay = value / bond->params.miimon;
-	netdev_dbg(bond->dev, "Setting up delay to %d\n",
-		   bond->params.updelay * bond->params.miimon);
+	*target = value / bond->params.miimon;
+	netdev_dbg(bond->dev, "Setting %s to %d\n",
+		   name,
+		   *target * bond->params.miimon);
 
 	return 0;
 }
 
+static int bond_option_updelay_set(struct bonding *bond,
+				   const struct bond_opt_value *newval)
+{
+	return _bond_option_delay_set(bond, newval, "up delay",
+				      &bond->params.updelay);
+}
+
 static int bond_option_downdelay_set(struct bonding *bond,
 				     const struct bond_opt_value *newval)
 {
-	int value = newval->value;
-
-	if (!bond->params.miimon) {
-		netdev_err(bond->dev, "Unable to set down delay as MII monitoring is disabled\n");
-		return -EPERM;
-	}
-	if ((value % bond->params.miimon) != 0) {
-		netdev_warn(bond->dev, "down delay (%d) is not a multiple of miimon (%d), delay rounded to %d ms\n",
-			    value, bond->params.miimon,
-			    (value / bond->params.miimon) *
-			    bond->params.miimon);
-	}
-	bond->params.downdelay = value / bond->params.miimon;
-	netdev_dbg(bond->dev, "Setting down delay to %d\n",
-		   bond->params.downdelay * bond->params.miimon);
+	return _bond_option_delay_set(bond, newval, "down delay",
+				      &bond->params.downdelay);
+}
 
-	return 0;
+static int bond_option_peer_notif_delay_set(struct bonding *bond,
+					    const struct bond_opt_value *newval)
+{
+	int ret = _bond_option_delay_set(bond, newval,
+					 "peer notification delay",
+					 &bond->params.peer_notif_delay);
+	return ret;
 }
 
 static int bond_option_use_carrier_set(struct bonding *bond,

commit f887e54ce34906c266b30b8fca0907d3151ac925
Author: Jarod Wilson <jarod@redhat.com>
Date:   Fri Jun 7 10:59:32 2019 -0400

    bonding/options: convert to using slave printk macros
    
    All of these printk instances benefit from having both master and slave
    device information included, so convert to using a standardized macro
    format and remove redundant information.
    
    Suggested-by: Joe Perches <joe@perches.com>
    CC: Jay Vosburgh <j.vosburgh@gmail.com>
    CC: Veaceslav Falico <vfalico@gmail.com>
    CC: Andy Gospodarek <andy@greyhouse.net>
    CC: netdev@vger.kernel.org
    Signed-off-by: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 9677418e0362..0d852fe9da7c 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -783,14 +783,12 @@ static int bond_option_active_slave_set(struct bonding *bond,
 
 	if (slave_dev) {
 		if (!netif_is_bond_slave(slave_dev)) {
-			netdev_err(bond->dev, "Device %s is not bonding slave\n",
-				   slave_dev->name);
+			slave_err(bond->dev, slave_dev, "Device is not bonding slave\n");
 			return -EINVAL;
 		}
 
 		if (bond->dev != netdev_master_upper_dev_get(slave_dev)) {
-			netdev_err(bond->dev, "Device %s is not our slave\n",
-				   slave_dev->name);
+			slave_err(bond->dev, slave_dev, "Device is not our slave\n");
 			return -EINVAL;
 		}
 	}
@@ -809,18 +807,15 @@ static int bond_option_active_slave_set(struct bonding *bond,
 
 		if (new_active == old_active) {
 			/* do nothing */
-			netdev_dbg(bond->dev, "%s is already the current active slave\n",
-				   new_active->dev->name);
+			slave_dbg(bond->dev, new_active->dev, "is already the current active slave\n");
 		} else {
 			if (old_active && (new_active->link == BOND_LINK_UP) &&
 			    bond_slave_is_up(new_active)) {
-				netdev_dbg(bond->dev, "Setting %s as active slave\n",
-					   new_active->dev->name);
+				slave_dbg(bond->dev, new_active->dev, "Setting as active slave\n");
 				bond_change_active_slave(bond, new_active);
 			} else {
-				netdev_err(bond->dev, "Could not set %s as active slave; either %s is down or the link is down\n",
-					   new_active->dev->name,
-					   new_active->dev->name);
+				slave_err(bond->dev, new_active->dev, "Could not set as active slave; either %s is down or the link is down\n",
+					  new_active->dev->name);
 				ret = -EINVAL;
 			}
 		}
@@ -1132,8 +1127,7 @@ static int bond_option_primary_set(struct bonding *bond,
 
 	bond_for_each_slave(bond, slave, iter) {
 		if (strncmp(slave->dev->name, primary, IFNAMSIZ) == 0) {
-			netdev_dbg(bond->dev, "Setting %s as primary slave\n",
-				   slave->dev->name);
+			slave_dbg(bond->dev, slave->dev, "Setting as primary slave\n");
 			rcu_assign_pointer(bond->primary_slave, slave);
 			strcpy(bond->params.primary, slave->dev->name);
 			bond->force_primary = true;
@@ -1150,8 +1144,8 @@ static int bond_option_primary_set(struct bonding *bond,
 	strncpy(bond->params.primary, primary, IFNAMSIZ);
 	bond->params.primary[IFNAMSIZ - 1] = 0;
 
-	netdev_dbg(bond->dev, "Recording %s as primary, but it has not been enslaved to %s yet\n",
-		   primary, bond->dev->name);
+	netdev_dbg(bond->dev, "Recording %s as primary, but it has not been enslaved yet\n",
+		   primary);
 
 out:
 	unblock_netpoll_tx();
@@ -1378,12 +1372,12 @@ static int bond_option_slaves_set(struct bonding *bond,
 
 	switch (command[0]) {
 	case '+':
-		netdev_dbg(bond->dev, "Adding slave %s\n", dev->name);
+		slave_dbg(bond->dev, dev, "Enslaving interface\n");
 		ret = bond_enslave(bond->dev, dev, NULL);
 		break;
 
 	case '-':
-		netdev_dbg(bond->dev, "Removing slave %s\n", dev->name);
+		slave_dbg(bond->dev, dev, "Releasing interface\n");
 		ret = bond_release(bond->dev, dev);
 		break;
 
@@ -1447,7 +1441,7 @@ static int bond_option_ad_actor_system_set(struct bonding *bond,
 	return 0;
 
 err:
-	netdev_err(bond->dev, "Invalid MAC address.\n");
+	netdev_err(bond->dev, "Invalid ad_actor_system MAC address.\n");
 	return -EINVAL;
 }
 

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index b996967af8d9..9677418e0362 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -1,12 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * drivers/net/bond/bond_options.c - bonding options
  * Copyright (c) 2013 Jiri Pirko <jiri@resnulli.us>
  * Copyright (c) 2013 Scott Feldman <sfeldma@cumulusnetworks.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
  */
 
 #include <linux/errno.h>

commit a9b8a2b39ce65df45687cf9ef648885c2a99fe75
Author: Jarod Wilson <jarod@redhat.com>
Date:   Fri May 10 17:57:09 2019 -0400

    bonding: fix arp_validate toggling in active-backup mode
    
    There's currently a problem with toggling arp_validate on and off with an
    active-backup bond. At the moment, you can start up a bond, like so:
    
    modprobe bonding mode=1 arp_interval=100 arp_validate=0 arp_ip_targets=192.168.1.1
    ip link set bond0 down
    echo "ens4f0" > /sys/class/net/bond0/bonding/slaves
    echo "ens4f1" > /sys/class/net/bond0/bonding/slaves
    ip link set bond0 up
    ip addr add 192.168.1.2/24 dev bond0
    
    Pings to 192.168.1.1 work just fine. Now turn on arp_validate:
    
    echo 1 > /sys/class/net/bond0/bonding/arp_validate
    
    Pings to 192.168.1.1 continue to work just fine. Now when you go to turn
    arp_validate off again, the link falls flat on it's face:
    
    echo 0 > /sys/class/net/bond0/bonding/arp_validate
    dmesg
    ...
    [133191.911987] bond0: Setting arp_validate to none (0)
    [133194.257793] bond0: bond_should_notify_peers: slave ens4f0
    [133194.258031] bond0: link status definitely down for interface ens4f0, disabling it
    [133194.259000] bond0: making interface ens4f1 the new active one
    [133197.330130] bond0: link status definitely down for interface ens4f1, disabling it
    [133197.331191] bond0: now running without any active interface!
    
    The problem lies in bond_options.c, where passing in arp_validate=0
    results in bond->recv_probe getting set to NULL. This flies directly in
    the face of commit 3fe68df97c7f, which says we need to set recv_probe =
    bond_arp_recv, even if we're not using arp_validate. Said commit fixed
    this in bond_option_arp_interval_set, but missed that we can get to that
    same state in bond_option_arp_validate_set as well.
    
    One solution would be to universally set recv_probe = bond_arp_recv here
    as well, but I don't think bond_option_arp_validate_set has any business
    touching recv_probe at all, and that should be left to the arp_interval
    code, so we can just make things much tidier here.
    
    Fixes: 3fe68df97c7f ("bonding: always set recv_probe to bond_arp_rcv in arp monitor")
    CC: Jay Vosburgh <j.vosburgh@gmail.com>
    CC: Veaceslav Falico <vfalico@gmail.com>
    CC: Andy Gospodarek <andy@greyhouse.net>
    CC: "David S. Miller" <davem@davemloft.net>
    CC: netdev@vger.kernel.org
    Signed-off-by: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: Jay Vosburgh <jay.vosburgh@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index da1fc17295d9..b996967af8d9 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -1098,13 +1098,6 @@ static int bond_option_arp_validate_set(struct bonding *bond,
 {
 	netdev_dbg(bond->dev, "Setting arp_validate to %s (%llu)\n",
 		   newval->string, newval->value);
-
-	if (bond->dev->flags & IFF_UP) {
-		if (!newval->value)
-			bond->recv_probe = NULL;
-		else if (bond->params.arp_interval)
-			bond->recv_probe = bond_arp_rcv;
-	}
 	bond->params.arp_validate = newval->value;
 
 	return 0;

commit 415d39427317d1532d7f097471cc8aca5f229b69
Author: Tonghao Zhang <xiangxia.m.yue@gmail.com>
Date:   Mon Feb 11 10:49:48 2019 -0800

    bonding: check slave set command firstly
    
    This patch is a little improvement. If user use the
    command shown as below, we should print the info [1]
    instead of [2]. The eth0 exists actually, and it may
    confuse user.
    
    $ echo "eth0" > /sys/class/net/bond4/bonding/slaves
    
    [1] "bond4: no command found in slaves file - use +ifname or -ifname"
    [2] "write error: No such device"
    
    Signed-off-by: Tonghao Zhang <xiangxia.m.yue@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 4d5d01cb8141..da1fc17295d9 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -1375,6 +1375,7 @@ static int bond_option_slaves_set(struct bonding *bond,
 	sscanf(newval->string, "%16s", command); /* IFNAMSIZ*/
 	ifname = command + 1;
 	if ((strlen(command) <= 1) ||
+	    (command[0] != '+' && command[0] != '-') ||
 	    !dev_valid_name(ifname))
 		goto err_no_cmd;
 
@@ -1398,6 +1399,7 @@ static int bond_option_slaves_set(struct bonding *bond,
 		break;
 
 	default:
+		/* should not run here. */
 		goto err_no_cmd;
 	}
 

commit c1f897ce186a529a494441642125479d38727a3d
Author: Jarod Wilson <jarod@redhat.com>
Date:   Wed Jul 18 14:49:36 2018 -0400

    bonding: set default miimon value for non-arp modes if not set
    
    For some time now, if you load the bonding driver and configure bond
    parameters via sysfs using minimal config options, such as specifying
    nothing but the mode, relying on defaults for everything else, modes
    that cannot use arp monitoring (802.3ad, balance-tlb, balance-alb) all
    wind up with both arp_interval=0 (as it should be) and miimon=0, which
    means the miimon monitor thread never actually runs. This is particularly
    problematic for 802.3ad.
    
    For example, from an LNST recipe I've set up:
    
    $ modprobe bonding max_bonds=0"
    $ echo "+t_bond0" > /sys/class/net/bonding_masters"
    $ ip link set t_bond0 down"
    $ echo "802.3ad" > /sys/class/net/t_bond0/bonding/mode"
    $ ip link set ens1f1 down"
    $ echo "+ens1f1" > /sys/class/net/t_bond0/bonding/slaves"
    $ ip link set ens1f0 down"
    $ echo "+ens1f0" > /sys/class/net/t_bond0/bonding/slaves"
    $ ethtool -i t_bond0"
    $ ip link set ens1f1 up"
    $ ip link set ens1f0 up"
    $ ip link set t_bond0 up"
    $ ip addr add 192.168.9.1/24 dev t_bond0"
    $ ip addr add 2002::1/64 dev t_bond0"
    
    This bond comes up okay, but things look slightly suspect in
    /proc/net/bonding/t_bond0 output:
    
    $ grep -i mii /proc/net/bonding/t_bond0
    MII Status: up
    MII Polling Interval (ms): 0
    MII Status: up
    MII Status: up
    
    Now, pull a cable on one of the ports in the bond, then reconnect it, and
    you'll see:
    
    Slave Interface: ens1f0
    MII Status: down
    Speed: 1000 Mbps
    Duplex: full
    
    I believe this became a major issue as of commit 4d2c0cda0744, which for
    802.3ad bonds, sets slave->link = BOND_LINK_DOWN, with a comment about
    relying on link monitoring via miimon to set it correctly, but since the
    miimon work queue never runs, the link just stays marked down.
    
    If we simply tweak bond_option_mode_set() slightly, we can check for the
    non-arp modes having no miimon value set, and insert BOND_DEFAULT_MIIMON,
    which gets things back in full working order. This problem exists as far
    back as 4.14, and might be worth fixing in all stable trees since, though
    the work-around is to simply specify an miimon value yourself.
    
    Reported-by: Bob Ball <ball@umich.edu>
    Signed-off-by: Jarod Wilson <jarod@redhat.com>
    Acked-by: Mahesh Bandewar <maheshb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 98663c50ded0..4d5d01cb8141 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -743,15 +743,20 @@ const struct bond_option *bond_opt_get(unsigned int option)
 static int bond_option_mode_set(struct bonding *bond,
 				const struct bond_opt_value *newval)
 {
-	if (!bond_mode_uses_arp(newval->value) && bond->params.arp_interval) {
-		netdev_dbg(bond->dev, "%s mode is incompatible with arp monitoring, start mii monitoring\n",
-			   newval->string);
-		/* disable arp monitoring */
-		bond->params.arp_interval = 0;
-		/* set miimon to default value */
-		bond->params.miimon = BOND_DEFAULT_MIIMON;
-		netdev_dbg(bond->dev, "Setting MII monitoring interval to %d\n",
-			   bond->params.miimon);
+	if (!bond_mode_uses_arp(newval->value)) {
+		if (bond->params.arp_interval) {
+			netdev_dbg(bond->dev, "%s mode is incompatible with arp monitoring, start mii monitoring\n",
+				   newval->string);
+			/* disable arp monitoring */
+			bond->params.arp_interval = 0;
+		}
+
+		if (!bond->params.miimon) {
+			/* set miimon to default value */
+			bond->params.miimon = BOND_DEFAULT_MIIMON;
+			netdev_dbg(bond->dev, "Setting MII monitoring interval to %d\n",
+				   bond->params.miimon);
+		}
 	}
 
 	if (newval->value == BOND_MODE_ALB)

commit eb55bbf865d9979098c6a7a17cbdb41237ece951
Author: Xiangning Yu <yuxiangning@gmail.com>
Date:   Thu Jun 7 13:39:59 2018 +0800

    bonding: re-evaluate force_primary when the primary slave name changes
    
    There is a timing issue under active-standy mode, when bond_enslave() is
    called, bond->params.primary might not be initialized yet.
    
    Any time the primary slave string changes, bond->force_primary should be
    set to true to make sure the primary becomes the active slave.
    
    Signed-off-by: Xiangning Yu <yuxiangning@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 8a945c9341d6..98663c50ded0 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -1142,6 +1142,7 @@ static int bond_option_primary_set(struct bonding *bond,
 				   slave->dev->name);
 			rcu_assign_pointer(bond->primary_slave, slave);
 			strcpy(bond->params.primary, slave->dev->name);
+			bond->force_primary = true;
 			bond_select_active_slave(bond);
 			goto out;
 		}

commit b3c898e20b1881b0876c3e811c58b039b37dd5fd
Author: Debabrata Banerjee <dbanerje@akamai.com>
Date:   Wed May 16 14:02:13 2018 -0400

    Revert "bonding: allow carrier and link status to determine link state"
    
    This reverts commit 1386c36b30388f46a95100924bfcae75160db715.
    
    We don't want to encourage drivers to not report carrier status
    correctly, therefore remove this commit.
    
    Signed-off-by: Debabrata Banerjee <dbanerje@akamai.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index dba6cef05134..8a945c9341d6 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -164,10 +164,9 @@ static const struct bond_opt_value bond_primary_reselect_tbl[] = {
 };
 
 static const struct bond_opt_value bond_use_carrier_tbl[] = {
-	{ "off",  0,  0},
-	{ "on",   1,  BOND_VALFLAG_DEFAULT},
-	{ "both", 2,  0},
-	{ NULL,  -1,  0}
+	{ "off", 0,  0},
+	{ "on",  1,  BOND_VALFLAG_DEFAULT},
+	{ NULL,  -1, 0}
 };
 
 static const struct bond_opt_value bond_all_slaves_active_tbl[] = {

commit 1386c36b30388f46a95100924bfcae75160db715
Author: Debabrata Banerjee <dbanerje@akamai.com>
Date:   Mon May 14 14:48:10 2018 -0400

    bonding: allow carrier and link status to determine link state
    
    In a mixed environment it may be difficult to tell if your hardware
    support carrier, if it does not it can always report true. With a new
    use_carrier option of 2, we can check both carrier and link status
    sequentially, instead of one or the other
    
    Signed-off-by: Debabrata Banerjee <dbanerje@akamai.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 8a945c9341d6..dba6cef05134 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -164,9 +164,10 @@ static const struct bond_opt_value bond_primary_reselect_tbl[] = {
 };
 
 static const struct bond_opt_value bond_use_carrier_tbl[] = {
-	{ "off", 0,  0},
-	{ "on",  1,  BOND_VALFLAG_DEFAULT},
-	{ NULL,  -1, 0}
+	{ "off",  0,  0},
+	{ "on",   1,  BOND_VALFLAG_DEFAULT},
+	{ "both", 2,  0},
+	{ NULL,  -1,  0}
 };
 
 static const struct bond_opt_value bond_all_slaves_active_tbl[] = {

commit e79c1055749e3183a2beee04a24da378623329c5
Author: Debabrata Banerjee <dbanerje@akamai.com>
Date:   Mon May 14 14:48:09 2018 -0400

    bonding: allow use of tx hashing in balance-alb
    
    The rx load balancing provided by balance-alb is not mutually
    exclusive with using hashing for tx selection, and should provide a decent
    speed increase because this eliminates spinlocks and cache contention.
    
    Signed-off-by: Debabrata Banerjee <dbanerje@akamai.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 58c705f24f96..8a945c9341d6 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -395,7 +395,7 @@ static const struct bond_option bond_opts[BOND_OPT_LAST] = {
 		.id = BOND_OPT_TLB_DYNAMIC_LB,
 		.name = "tlb_dynamic_lb",
 		.desc = "Enable dynamic flow shuffling",
-		.unsuppmodes = BOND_MODE_ALL_EX(BIT(BOND_MODE_TLB)),
+		.unsuppmodes = BOND_MODE_ALL_EX(BIT(BOND_MODE_TLB) | BIT(BOND_MODE_ALB)),
 		.values = bond_tlb_dynamic_lb_tbl,
 		.flags = BOND_OPTFLAG_IFDOWN,
 		.set = bond_option_tlb_dynamic_lb_set,

commit ce5c144f48d5e465bd9b9d676902cf4dcfcae4b9
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Dec 19 20:20:44 2017 +0200

    net: bonding: Replace mac address parsing
    
    Replace sscanf() with mac_pton().
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Andy Gospodarek <andy@greyhouse.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 8a9b085c2a98..58c705f24f96 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -1431,13 +1431,9 @@ static int bond_option_ad_actor_system_set(struct bonding *bond,
 {
 	u8 macaddr[ETH_ALEN];
 	u8 *mac;
-	int i;
 
 	if (newval->string) {
-		i = sscanf(newval->string, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
-			   &macaddr[0], &macaddr[1], &macaddr[2],
-			   &macaddr[3], &macaddr[4], &macaddr[5]);
-		if (i != ETH_ALEN)
+		if (!mac_pton(newval->string, macaddr))
 			goto err;
 		mac = macaddr;
 	} else {

commit 33eaf2a6eb48ebf00374aaaf4b1b43f9950dcbe4
Author: David Ahern <dsahern@gmail.com>
Date:   Wed Oct 4 17:48:46 2017 -0700

    net: Add extack to ndo_add_slave
    
    Pass extack to do_set_master and down to ndo_add_slave
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 5931aa2fe997..8a9b085c2a98 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -1383,7 +1383,7 @@ static int bond_option_slaves_set(struct bonding *bond,
 	switch (command[0]) {
 	case '+':
 		netdev_dbg(bond->dev, "Adding slave %s\n", dev->name);
-		ret = bond_enslave(bond->dev, dev);
+		ret = bond_enslave(bond->dev, dev, NULL);
 		break;
 
 	case '-':

commit c6644d07eff6588b2dedf881279fb0d1c7783970
Author: Kosuke Tatsukawa <tatsu@ab.jp.nec.com>
Date:   Wed Sep 6 22:47:59 2017 +0000

    net: bonding: Fix transmit load balancing in balance-alb mode if specified by sysfs
    
    Commit cbf5ecb30560 ("net: bonding: Fix transmit load balancing in
    balance-alb mode") tried to fix transmit dynamic load balancing in
    balance-alb mode, which wasn't working after commit 8b426dc54cf4
    ("bonding: remove hardcoded value").
    
    It turned out that my previous patch only fixed the case when
    balance-alb was specified as bonding module parameter, and not when
    balance-alb mode was set using /sys/class/net/*/bonding/mode (the most
    common usage).  In the latter case, tlb_dynamic_lb was set up according
    to the default mode of the bonding interface, which happens to be
    balance-rr.
    
    This additional patch addresses this issue by setting up tlb_dynamic_lb
    to 1 if "mode" is set to balance-alb through the sysfs interface.
    
    I didn't add code to change tlb_balance_lb back to the default value for
    other modes, because "mode" is usually set up only once during
    initialization, and it's not worthwhile to change the static variable
    bonding_defaults in bond_main.c to a global variable just for this
    purpose.
    
    Commit 8b426dc54cf4 also changes the value of tlb_dynamic_lb for
    balance-tlb mode if it is set up using the sysfs interface.  I didn't
    change that behavior, because the value of tlb_balance_lb can be changed
    using the sysfs interface for balance-tlb, and I didn't like changing
    the default value back and forth for balance-tlb.
    
    As for balance-alb, /sys/class/net/*/bonding/tlb_balance_lb cannot be
    written to.  However, I think balance-alb with tlb_dynamic_lb set to 0
    is not an intended usage, so there is little use making it writable at
    this moment.
    
    Fixes: 8b426dc54cf4 ("bonding: remove hardcoded value")
    Reported-by: Reinis Rozitis <r@roze.lv>
    Signed-off-by: Kosuke Tatsukawa <tatsu@ab.jp.nec.com>
    Cc: stable@vger.kernel.org  # v4.12+
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Acked-by: Mahesh Bandewar <maheshb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index a12d603d41c6..5931aa2fe997 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -754,6 +754,9 @@ static int bond_option_mode_set(struct bonding *bond,
 			   bond->params.miimon);
 	}
 
+	if (newval->value == BOND_MODE_ALB)
+		bond->params.tlb_dynamic_lb = 1;
+
 	/* don't cache arp_validate between modes */
 	bond->params.arp_validate = BOND_ARP_VALIDATE_NONE;
 	bond->params.mode = newval->value;

commit eac306b4adb7452c0228f32dd004f791ab08aae8
Author: Michael Dilmore <michael.j.dilmore@gmail.com>
Date:   Mon Jun 26 16:49:46 2017 +0100

    Bonding: Convert multiple netdev_info messages to netdev_dbg
    
    The bond_options.c file contains multiple netdev_info statements that clutter kernel output.
    This patch replaces all netdev_info with netdev_dbg and adds a netdev_dbg statement for the
    packets per slave parameter. Also fixes misalignment at line 467.
    
    Suggested-by: Joe Perches <joe@perches.com>
    Signed-off-by: Michael J Dilmore <michael.j.dilmore@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 8ca683396fcc..a12d603d41c6 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -464,7 +464,7 @@ const struct bond_opt_value *bond_opt_get_val(unsigned int option, u64 val)
 
 /* Searches for a value in opt's values[] table which matches the flagmask */
 static const struct bond_opt_value *bond_opt_get_flags(const struct bond_option *opt,
-						 u32 flagmask)
+						       u32 flagmask)
 {
 	int i;
 
@@ -744,14 +744,14 @@ static int bond_option_mode_set(struct bonding *bond,
 				const struct bond_opt_value *newval)
 {
 	if (!bond_mode_uses_arp(newval->value) && bond->params.arp_interval) {
-		netdev_info(bond->dev, "%s mode is incompatible with arp monitoring, start mii monitoring\n",
-			    newval->string);
+		netdev_dbg(bond->dev, "%s mode is incompatible with arp monitoring, start mii monitoring\n",
+			   newval->string);
 		/* disable arp monitoring */
 		bond->params.arp_interval = 0;
 		/* set miimon to default value */
 		bond->params.miimon = BOND_DEFAULT_MIIMON;
-		netdev_info(bond->dev, "Setting MII monitoring interval to %d\n",
-			    bond->params.miimon);
+		netdev_dbg(bond->dev, "Setting MII monitoring interval to %d\n",
+			   bond->params.miimon);
 	}
 
 	/* don't cache arp_validate between modes */
@@ -794,7 +794,7 @@ static int bond_option_active_slave_set(struct bonding *bond,
 	block_netpoll_tx();
 	/* check to see if we are clearing active */
 	if (!slave_dev) {
-		netdev_info(bond->dev, "Clearing current active slave\n");
+		netdev_dbg(bond->dev, "Clearing current active slave\n");
 		RCU_INIT_POINTER(bond->curr_active_slave, NULL);
 		bond_select_active_slave(bond);
 	} else {
@@ -805,13 +805,13 @@ static int bond_option_active_slave_set(struct bonding *bond,
 
 		if (new_active == old_active) {
 			/* do nothing */
-			netdev_info(bond->dev, "%s is already the current active slave\n",
-				    new_active->dev->name);
+			netdev_dbg(bond->dev, "%s is already the current active slave\n",
+				   new_active->dev->name);
 		} else {
 			if (old_active && (new_active->link == BOND_LINK_UP) &&
 			    bond_slave_is_up(new_active)) {
-				netdev_info(bond->dev, "Setting %s as active slave\n",
-					    new_active->dev->name);
+				netdev_dbg(bond->dev, "Setting %s as active slave\n",
+					   new_active->dev->name);
 				bond_change_active_slave(bond, new_active);
 			} else {
 				netdev_err(bond->dev, "Could not set %s as active slave; either %s is down or the link is down\n",
@@ -833,17 +833,17 @@ static int bond_option_active_slave_set(struct bonding *bond,
 static int bond_option_miimon_set(struct bonding *bond,
 				  const struct bond_opt_value *newval)
 {
-	netdev_info(bond->dev, "Setting MII monitoring interval to %llu\n",
-		    newval->value);
+	netdev_dbg(bond->dev, "Setting MII monitoring interval to %llu\n",
+		   newval->value);
 	bond->params.miimon = newval->value;
 	if (bond->params.updelay)
-		netdev_info(bond->dev, "Note: Updating updelay (to %d) since it is a multiple of the miimon value\n",
-			bond->params.updelay * bond->params.miimon);
+		netdev_dbg(bond->dev, "Note: Updating updelay (to %d) since it is a multiple of the miimon value\n",
+			   bond->params.updelay * bond->params.miimon);
 	if (bond->params.downdelay)
-		netdev_info(bond->dev, "Note: Updating downdelay (to %d) since it is a multiple of the miimon value\n",
-			    bond->params.downdelay * bond->params.miimon);
+		netdev_dbg(bond->dev, "Note: Updating downdelay (to %d) since it is a multiple of the miimon value\n",
+			   bond->params.downdelay * bond->params.miimon);
 	if (newval->value && bond->params.arp_interval) {
-		netdev_info(bond->dev, "MII monitoring cannot be used with ARP monitoring - disabling ARP monitoring...\n");
+		netdev_dbg(bond->dev, "MII monitoring cannot be used with ARP monitoring - disabling ARP monitoring...\n");
 		bond->params.arp_interval = 0;
 		if (bond->params.arp_validate)
 			bond->params.arp_validate = BOND_ARP_VALIDATE_NONE;
@@ -885,8 +885,8 @@ static int bond_option_updelay_set(struct bonding *bond,
 			    bond->params.miimon);
 	}
 	bond->params.updelay = value / bond->params.miimon;
-	netdev_info(bond->dev, "Setting up delay to %d\n",
-		    bond->params.updelay * bond->params.miimon);
+	netdev_dbg(bond->dev, "Setting up delay to %d\n",
+		   bond->params.updelay * bond->params.miimon);
 
 	return 0;
 }
@@ -907,8 +907,8 @@ static int bond_option_downdelay_set(struct bonding *bond,
 			    bond->params.miimon);
 	}
 	bond->params.downdelay = value / bond->params.miimon;
-	netdev_info(bond->dev, "Setting down delay to %d\n",
-		    bond->params.downdelay * bond->params.miimon);
+	netdev_dbg(bond->dev, "Setting down delay to %d\n",
+		   bond->params.downdelay * bond->params.miimon);
 
 	return 0;
 }
@@ -916,8 +916,8 @@ static int bond_option_downdelay_set(struct bonding *bond,
 static int bond_option_use_carrier_set(struct bonding *bond,
 				       const struct bond_opt_value *newval)
 {
-	netdev_info(bond->dev, "Setting use_carrier to %llu\n",
-		    newval->value);
+	netdev_dbg(bond->dev, "Setting use_carrier to %llu\n",
+		   newval->value);
 	bond->params.use_carrier = newval->value;
 
 	return 0;
@@ -930,16 +930,16 @@ static int bond_option_use_carrier_set(struct bonding *bond,
 static int bond_option_arp_interval_set(struct bonding *bond,
 					const struct bond_opt_value *newval)
 {
-	netdev_info(bond->dev, "Setting ARP monitoring interval to %llu\n",
-		    newval->value);
+	netdev_dbg(bond->dev, "Setting ARP monitoring interval to %llu\n",
+		   newval->value);
 	bond->params.arp_interval = newval->value;
 	if (newval->value) {
 		if (bond->params.miimon) {
-			netdev_info(bond->dev, "ARP monitoring cannot be used with MII monitoring. Disabling MII monitoring\n");
+			netdev_dbg(bond->dev, "ARP monitoring cannot be used with MII monitoring. Disabling MII monitoring\n");
 			bond->params.miimon = 0;
 		}
 		if (!bond->params.arp_targets[0])
-			netdev_info(bond->dev, "ARP monitoring has been set up, but no ARP targets have been specified\n");
+			netdev_dbg(bond->dev, "ARP monitoring has been set up, but no ARP targets have been specified\n");
 	}
 	if (bond->dev->flags & IFF_UP) {
 		/* If the interface is up, we may need to fire off
@@ -1000,7 +1000,7 @@ static int _bond_option_arp_ip_target_add(struct bonding *bond, __be32 target)
 		return -EINVAL;
 	}
 
-	netdev_info(bond->dev, "Adding ARP target %pI4\n", &target);
+	netdev_dbg(bond->dev, "Adding ARP target %pI4\n", &target);
 
 	_bond_options_arp_ip_target_set(bond, ind, target, jiffies);
 
@@ -1036,7 +1036,7 @@ static int bond_option_arp_ip_target_rem(struct bonding *bond, __be32 target)
 	if (ind == 0 && !targets[1] && bond->params.arp_interval)
 		netdev_warn(bond->dev, "Removing last arp target with arp_interval on\n");
 
-	netdev_info(bond->dev, "Removing ARP target %pI4\n", &target);
+	netdev_dbg(bond->dev, "Removing ARP target %pI4\n", &target);
 
 	bond_for_each_slave(bond, slave, iter) {
 		targets_rx = slave->target_last_arp_rx;
@@ -1088,8 +1088,8 @@ static int bond_option_arp_ip_targets_set(struct bonding *bond,
 static int bond_option_arp_validate_set(struct bonding *bond,
 					const struct bond_opt_value *newval)
 {
-	netdev_info(bond->dev, "Setting arp_validate to %s (%llu)\n",
-		    newval->string, newval->value);
+	netdev_dbg(bond->dev, "Setting arp_validate to %s (%llu)\n",
+		   newval->string, newval->value);
 
 	if (bond->dev->flags & IFF_UP) {
 		if (!newval->value)
@@ -1105,8 +1105,8 @@ static int bond_option_arp_validate_set(struct bonding *bond,
 static int bond_option_arp_all_targets_set(struct bonding *bond,
 					   const struct bond_opt_value *newval)
 {
-	netdev_info(bond->dev, "Setting arp_all_targets to %s (%llu)\n",
-		    newval->string, newval->value);
+	netdev_dbg(bond->dev, "Setting arp_all_targets to %s (%llu)\n",
+		   newval->string, newval->value);
 	bond->params.arp_all_targets = newval->value;
 
 	return 0;
@@ -1126,7 +1126,7 @@ static int bond_option_primary_set(struct bonding *bond,
 		*p = '\0';
 	/* check to see if we are clearing primary */
 	if (!strlen(primary)) {
-		netdev_info(bond->dev, "Setting primary slave to None\n");
+		netdev_dbg(bond->dev, "Setting primary slave to None\n");
 		RCU_INIT_POINTER(bond->primary_slave, NULL);
 		memset(bond->params.primary, 0, sizeof(bond->params.primary));
 		bond_select_active_slave(bond);
@@ -1135,8 +1135,8 @@ static int bond_option_primary_set(struct bonding *bond,
 
 	bond_for_each_slave(bond, slave, iter) {
 		if (strncmp(slave->dev->name, primary, IFNAMSIZ) == 0) {
-			netdev_info(bond->dev, "Setting %s as primary slave\n",
-				    slave->dev->name);
+			netdev_dbg(bond->dev, "Setting %s as primary slave\n",
+				   slave->dev->name);
 			rcu_assign_pointer(bond->primary_slave, slave);
 			strcpy(bond->params.primary, slave->dev->name);
 			bond_select_active_slave(bond);
@@ -1145,15 +1145,15 @@ static int bond_option_primary_set(struct bonding *bond,
 	}
 
 	if (rtnl_dereference(bond->primary_slave)) {
-		netdev_info(bond->dev, "Setting primary slave to None\n");
+		netdev_dbg(bond->dev, "Setting primary slave to None\n");
 		RCU_INIT_POINTER(bond->primary_slave, NULL);
 		bond_select_active_slave(bond);
 	}
 	strncpy(bond->params.primary, primary, IFNAMSIZ);
 	bond->params.primary[IFNAMSIZ - 1] = 0;
 
-	netdev_info(bond->dev, "Recording %s as primary, but it has not been enslaved to %s yet\n",
-		    primary, bond->dev->name);
+	netdev_dbg(bond->dev, "Recording %s as primary, but it has not been enslaved to %s yet\n",
+		   primary, bond->dev->name);
 
 out:
 	unblock_netpoll_tx();
@@ -1164,8 +1164,8 @@ static int bond_option_primary_set(struct bonding *bond,
 static int bond_option_primary_reselect_set(struct bonding *bond,
 					    const struct bond_opt_value *newval)
 {
-	netdev_info(bond->dev, "Setting primary_reselect to %s (%llu)\n",
-		    newval->string, newval->value);
+	netdev_dbg(bond->dev, "Setting primary_reselect to %s (%llu)\n",
+		   newval->string, newval->value);
 	bond->params.primary_reselect = newval->value;
 
 	block_netpoll_tx();
@@ -1178,8 +1178,8 @@ static int bond_option_primary_reselect_set(struct bonding *bond,
 static int bond_option_fail_over_mac_set(struct bonding *bond,
 					 const struct bond_opt_value *newval)
 {
-	netdev_info(bond->dev, "Setting fail_over_mac to %s (%llu)\n",
-		    newval->string, newval->value);
+	netdev_dbg(bond->dev, "Setting fail_over_mac to %s (%llu)\n",
+		   newval->string, newval->value);
 	bond->params.fail_over_mac = newval->value;
 
 	return 0;
@@ -1188,8 +1188,8 @@ static int bond_option_fail_over_mac_set(struct bonding *bond,
 static int bond_option_xmit_hash_policy_set(struct bonding *bond,
 					    const struct bond_opt_value *newval)
 {
-	netdev_info(bond->dev, "Setting xmit hash policy to %s (%llu)\n",
-		    newval->string, newval->value);
+	netdev_dbg(bond->dev, "Setting xmit hash policy to %s (%llu)\n",
+		   newval->string, newval->value);
 	bond->params.xmit_policy = newval->value;
 
 	return 0;
@@ -1198,8 +1198,8 @@ static int bond_option_xmit_hash_policy_set(struct bonding *bond,
 static int bond_option_resend_igmp_set(struct bonding *bond,
 				       const struct bond_opt_value *newval)
 {
-	netdev_info(bond->dev, "Setting resend_igmp to %llu\n",
-		    newval->value);
+	netdev_dbg(bond->dev, "Setting resend_igmp to %llu\n",
+		   newval->value);
 	bond->params.resend_igmp = newval->value;
 
 	return 0;
@@ -1237,8 +1237,8 @@ static int bond_option_all_slaves_active_set(struct bonding *bond,
 static int bond_option_min_links_set(struct bonding *bond,
 				     const struct bond_opt_value *newval)
 {
-	netdev_info(bond->dev, "Setting min links value to %llu\n",
-		    newval->value);
+	netdev_dbg(bond->dev, "Setting min links value to %llu\n",
+		   newval->value);
 	bond->params.min_links = newval->value;
 	bond_set_carrier(bond);
 
@@ -1256,6 +1256,8 @@ static int bond_option_lp_interval_set(struct bonding *bond,
 static int bond_option_pps_set(struct bonding *bond,
 			       const struct bond_opt_value *newval)
 {
+	netdev_dbg(bond->dev, "Setting packets per slave to %llu\n",
+		   newval->value);
 	bond->params.packets_per_slave = newval->value;
 	if (newval->value > 0) {
 		bond->params.reciprocal_packets_per_slave =
@@ -1274,8 +1276,8 @@ static int bond_option_pps_set(struct bonding *bond,
 static int bond_option_lacp_rate_set(struct bonding *bond,
 				     const struct bond_opt_value *newval)
 {
-	netdev_info(bond->dev, "Setting LACP rate to %s (%llu)\n",
-		    newval->string, newval->value);
+	netdev_dbg(bond->dev, "Setting LACP rate to %s (%llu)\n",
+		   newval->string, newval->value);
 	bond->params.lacp_fast = newval->value;
 	bond_3ad_update_lacp_rate(bond);
 
@@ -1285,8 +1287,8 @@ static int bond_option_lacp_rate_set(struct bonding *bond,
 static int bond_option_ad_select_set(struct bonding *bond,
 				     const struct bond_opt_value *newval)
 {
-	netdev_info(bond->dev, "Setting ad_select to %s (%llu)\n",
-		    newval->string, newval->value);
+	netdev_dbg(bond->dev, "Setting ad_select to %s (%llu)\n",
+		   newval->string, newval->value);
 	bond->params.ad_select = newval->value;
 
 	return 0;
@@ -1347,7 +1349,7 @@ static int bond_option_queue_id_set(struct bonding *bond,
 	return ret;
 
 err_no_cmd:
-	netdev_info(bond->dev, "invalid input for queue_id set\n");
+	netdev_dbg(bond->dev, "invalid input for queue_id set\n");
 	ret = -EPERM;
 	goto out;
 
@@ -1369,20 +1371,20 @@ static int bond_option_slaves_set(struct bonding *bond,
 
 	dev = __dev_get_by_name(dev_net(bond->dev), ifname);
 	if (!dev) {
-		netdev_info(bond->dev, "interface %s does not exist!\n",
-			    ifname);
+		netdev_dbg(bond->dev, "interface %s does not exist!\n",
+			   ifname);
 		ret = -ENODEV;
 		goto out;
 	}
 
 	switch (command[0]) {
 	case '+':
-		netdev_info(bond->dev, "Adding slave %s\n", dev->name);
+		netdev_dbg(bond->dev, "Adding slave %s\n", dev->name);
 		ret = bond_enslave(bond->dev, dev);
 		break;
 
 	case '-':
-		netdev_info(bond->dev, "Removing slave %s\n", dev->name);
+		netdev_dbg(bond->dev, "Removing slave %s\n", dev->name);
 		ret = bond_release(bond->dev, dev);
 		break;
 
@@ -1402,8 +1404,8 @@ static int bond_option_slaves_set(struct bonding *bond,
 static int bond_option_tlb_dynamic_lb_set(struct bonding *bond,
 					  const struct bond_opt_value *newval)
 {
-	netdev_info(bond->dev, "Setting dynamic-lb to %s (%llu)\n",
-		    newval->string, newval->value);
+	netdev_dbg(bond->dev, "Setting dynamic-lb to %s (%llu)\n",
+		   newval->string, newval->value);
 	bond->params.tlb_dynamic_lb = newval->value;
 
 	return 0;
@@ -1412,8 +1414,8 @@ static int bond_option_tlb_dynamic_lb_set(struct bonding *bond,
 static int bond_option_ad_actor_sys_prio_set(struct bonding *bond,
 					     const struct bond_opt_value *newval)
 {
-	netdev_info(bond->dev, "Setting ad_actor_sys_prio to %llu\n",
-		    newval->value);
+	netdev_dbg(bond->dev, "Setting ad_actor_sys_prio to %llu\n",
+		   newval->value);
 
 	bond->params.ad_actor_sys_prio = newval->value;
 	bond_3ad_update_ad_actor_settings(bond);
@@ -1442,7 +1444,7 @@ static int bond_option_ad_actor_system_set(struct bonding *bond,
 	if (!is_valid_ether_addr(mac))
 		goto err;
 
-	netdev_info(bond->dev, "Setting ad_actor_system to %pM\n", mac);
+	netdev_dbg(bond->dev, "Setting ad_actor_system to %pM\n", mac);
 	ether_addr_copy(bond->params.ad_actor_system, mac);
 	bond_3ad_update_ad_actor_settings(bond);
 
@@ -1456,8 +1458,8 @@ static int bond_option_ad_actor_system_set(struct bonding *bond,
 static int bond_option_ad_user_port_key_set(struct bonding *bond,
 					    const struct bond_opt_value *newval)
 {
-	netdev_info(bond->dev, "Setting ad_user_port_key to %llu\n",
-		    newval->value);
+	netdev_dbg(bond->dev, "Setting ad_user_port_key to %llu\n",
+		   newval->value);
 
 	bond->params.ad_user_port_key = newval->value;
 	return 0;

commit 7a7e96e09d463c7c3d51a51c539ae4352085ed18
Author: Vlad Yasevich <vyasevich@gmail.com>
Date:   Sat May 27 10:14:35 2017 -0400

    bonding: Prevent duplicate userspace notification
    
    Whenever a user changes bonding options, a NETDEV_CHANGEINFODATA
    notificatin is generated which results in a rtnelink message to
    be sent.  While runnig 'ip monitor', we can actually see 2 messages,
    one a result of the event, and the other a result of state change
    that is generated bo netdev_state_change().  However, this is not
    always the case. If bonding changes were done via sysfs or ifenslave
    (old ioctl interface), then only 1 message is seen.
    
    This patch removes duplicate messages in the case of using netlink
    to configure bonding.  It introduceds a separte function that
    triggers a netdev event and uses that function in the syfs and ioctl
    cases.
    
    This was discovered while auditing all the different envents and
    continues the effort of cleaning up duplicated netlink messages.
    
    CC: David Ahern <dsa@cumulusnetworks.com>
    CC: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: Vladislav Yasevich <vyasevic@redhat.com>
    Acked-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 1bcbb8913e17..8ca683396fcc 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -673,7 +673,30 @@ int __bond_opt_set(struct bonding *bond,
 out:
 	if (ret)
 		bond_opt_error_interpret(bond, opt, ret, val);
-	else if (bond->dev->reg_state == NETREG_REGISTERED)
+
+	return ret;
+}
+/**
+ * __bond_opt_set_notify - set a bonding option
+ * @bond: target bond device
+ * @option: option to set
+ * @val: value to set it to
+ *
+ * This function is used to change the bond's option value and trigger
+ * a notification to user sapce. It can be used for both enabling/changing
+ * an option and for disabling it. RTNL lock must be obtained before calling
+ * this function.
+ */
+int __bond_opt_set_notify(struct bonding *bond,
+			  unsigned int option, struct bond_opt_value *val)
+{
+	int ret = -ENOENT;
+
+	ASSERT_RTNL();
+
+	ret = __bond_opt_set(bond, option, val);
+
+	if (!ret && (bond->dev->reg_state == NETREG_REGISTERED))
 		call_netdevice_notifiers(NETDEV_CHANGEINFODATA, bond->dev);
 
 	return ret;
@@ -696,7 +719,7 @@ int bond_opt_tryset_rtnl(struct bonding *bond, unsigned int option, char *buf)
 	if (!rtnl_trylock())
 		return restart_syscall();
 	bond_opt_initstr(&optval, buf);
-	ret = __bond_opt_set(bond, option, &optval);
+	ret = __bond_opt_set_notify(bond, option, &optval);
 	rtnl_unlock();
 
 	return ret;

commit 174cd4b1e5fbd0d74c68cf3a74f5bd4923485512
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Feb 2 19:15:33 2017 +0100

    sched/headers: Prepare to move signal wakeup & sigpending methods from <linux/sched.h> into <linux/sched/signal.h>
    
    Fix up affected files that include this signal functionality via sched.h.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 577e57cad1dc..1bcbb8913e17 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -16,6 +16,8 @@
 #include <linux/rcupdate.h>
 #include <linux/ctype.h>
 #include <linux/inet.h>
+#include <linux/sched/signal.h>
+
 #include <net/bonding.h>
 
 static int bond_option_active_slave_set(struct bonding *bond,

commit 7f20cd252185702f951009e0a56778f870d50ca6
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Thu Feb 4 17:42:28 2016 +0100

    bonding: 3ad: allow to set ad_actor settings while the bond is up
    
    No need to require the bond down while changing these settings, the change
    will be reflected immediately and the 3ad mode will sort itself out.
    For faster convergence set port->ntt to true in order to generate new
    LACPDUs immediately.
    
    CC: Jay Vosburgh <j.vosburgh@gmail.com>
    CC: Veaceslav Falico <vfalico@gmail.com>
    CC: Andy Gospodarek <gospo@cumulusnetworks.com>
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index ed0bdae64f5e..577e57cad1dc 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -402,7 +402,6 @@ static const struct bond_option bond_opts[BOND_OPT_LAST] = {
 		.id = BOND_OPT_AD_ACTOR_SYS_PRIO,
 		.name = "ad_actor_sys_prio",
 		.unsuppmodes = BOND_MODE_ALL_EX(BIT(BOND_MODE_8023AD)),
-		.flags = BOND_OPTFLAG_IFDOWN,
 		.values = bond_ad_actor_sys_prio_tbl,
 		.set = bond_option_ad_actor_sys_prio_set,
 	},
@@ -410,7 +409,7 @@ static const struct bond_option bond_opts[BOND_OPT_LAST] = {
 		.id = BOND_OPT_AD_ACTOR_SYSTEM,
 		.name = "ad_actor_system",
 		.unsuppmodes = BOND_MODE_ALL_EX(BIT(BOND_MODE_8023AD)),
-		.flags = BOND_OPTFLAG_RAWVAL | BOND_OPTFLAG_IFDOWN,
+		.flags = BOND_OPTFLAG_RAWVAL,
 		.set = bond_option_ad_actor_system_set,
 	},
 	[BOND_OPT_AD_USER_PORT_KEY] = {

commit 5ee14e6d336f1daacf5ba73e831029c5ab7ae329
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Wed Feb 3 13:17:01 2016 +0100

    bonding: 3ad: apply ad_actor settings changes immediately
    
    Currently the bonding allows to set ad_actor_system and prio while the
    bond device is down, but these are actually applied only if there aren't
    any slaves yet (applied to bond device when first slave shows up, and to
    slaves at 3ad bind time). After this patch changes are applied immediately
    and the new values can be used/seen after the bond's upped so it's not
    necessary anymore to release all and enslave again to see the changes.
    
    CC: Jay Vosburgh <j.vosburgh@gmail.com>
    CC: Veaceslav Falico <vfalico@gmail.com>
    CC: Andy Gospodarek <gospo@cumulusnetworks.com>
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: Jay Vosburgh <jay.vosburgh@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 55e93b6b6d21..ed0bdae64f5e 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -1392,6 +1392,8 @@ static int bond_option_ad_actor_sys_prio_set(struct bonding *bond,
 		    newval->value);
 
 	bond->params.ad_actor_sys_prio = newval->value;
+	bond_3ad_update_ad_actor_settings(bond);
+
 	return 0;
 }
 
@@ -1418,6 +1420,8 @@ static int bond_option_ad_actor_system_set(struct bonding *bond,
 
 	netdev_info(bond->dev, "Setting ad_actor_system to %pM\n", mac);
 	ether_addr_copy(bond->params.ad_actor_system, mac);
+	bond_3ad_update_ad_actor_settings(bond);
+
 	return 0;
 
 err:

commit 26d2177e977c912863ac04f6c1a967e793ca3a56
Merge: a794b4f32921 d1178cbcdcf9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Sep 9 08:33:31 2015 -0700

    Merge tag 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dledford/rdma
    
    Pull inifiniband/rdma updates from Doug Ledford:
     "This is a fairly sizeable set of changes.  I've put them through a
      decent amount of testing prior to sending the pull request due to
      that.
    
      There are still a few fixups that I know are coming, but I wanted to
      go ahead and get the big, sizable chunk into your hands sooner rather
      than waiting for those last few fixups.
    
      Of note is the fact that this creates what is intended to be a
      temporary area in the drivers/staging tree specifically for some
      cleanups and additions that are coming for the RDMA stack.  We
      deprecated two drivers (ipath and amso1100) and are waiting to hear
      back if we can deprecate another one (ehca).  We also put Intel's new
      hfi1 driver into this area because it needs to be refactored and a
      transfer library created out of the factored out code, and then it and
      the qib driver and the soft-roce driver should all be modified to use
      that library.
    
      I expect drivers/staging/rdma to be around for three or four kernel
      releases and then to go away as all of the work is completed and final
      deletions of deprecated drivers are done.
    
      Summary of changes for 4.3:
    
       - Create drivers/staging/rdma
       - Move amso1100 driver to staging/rdma and schedule for deletion
       - Move ipath driver to staging/rdma and schedule for deletion
       - Add hfi1 driver to staging/rdma and set TODO for move to regular
         tree
       - Initial support for namespaces to be used on RDMA devices
       - Add RoCE GID table handling to the RDMA core caching code
       - Infrastructure to support handling of devices with differing read
         and write scatter gather capabilities
       - Various iSER updates
       - Kill off unsafe usage of global mr registrations
       - Update SRP driver
       - Misc  mlx4 driver updates
       - Support for the mr_alloc verb
       - Support for a netlink interface between kernel and user space cache
         daemon to speed path record queries and route resolution
       - Ininitial support for safe hot removal of verbs devices"
    
    * tag 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dledford/rdma: (136 commits)
      IB/ipoib: Suppress warning for send only join failures
      IB/ipoib: Clean up send-only multicast joins
      IB/srp: Fix possible protection fault
      IB/core: Move SM class defines from ib_mad.h to ib_smi.h
      IB/core: Remove unnecessary defines from ib_mad.h
      IB/hfi1: Add PSM2 user space header to header_install
      IB/hfi1: Add CSRs for CONFIG_SDMA_VERBOSITY
      mlx5: Fix incorrect wc pkey_index assignment for GSI messages
      IB/mlx5: avoid destroying a NULL mr in reg_user_mr error flow
      IB/uverbs: reject invalid or unknown opcodes
      IB/cxgb4: Fix if statement in pick_local_ip6adddrs
      IB/sa: Fix rdma netlink message flags
      IB/ucma: HW Device hot-removal support
      IB/mlx4_ib: Disassociate support
      IB/uverbs: Enable device removal when there are active user space applications
      IB/uverbs: Explicitly pass ib_dev to uverbs commands
      IB/uverbs: Fix race between ib_uverbs_open and remove_one
      IB/uverbs: Fix reference counting usage of event files
      IB/core: Make ib_dealloc_pd return void
      IB/srp: Create an insecure all physical rkey only if needed
      ...

commit e999869548b9ab97b7dffa053ba2fee81c31d069
Author: Matan Barak <matanb@mellanox.com>
Date:   Thu Jul 30 18:33:24 2015 +0300

    net/bonding: Export bond_option_active_slave_get_rcu
    
    Some consumers of the netdev events API would like to know who is the
    active slave when a NETDEV_CHANGEUPPER or NETDEV_BONDING_FAILOVER
    events occur. For example, when managing RoCE GIDs, GIDs based on the
    bond's ips should only be set on the port which corresponds to active
    slave netdevice.
    
    Signed-off-by: Matan Barak <matanb@mellanox.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index e9c624d54dd4..28bd005ab9e7 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -730,19 +730,6 @@ static int bond_option_mode_set(struct bonding *bond,
 	return 0;
 }
 
-static struct net_device *__bond_option_active_slave_get(struct bonding *bond,
-							 struct slave *slave)
-{
-	return bond_uses_primary(bond) && slave ? slave->dev : NULL;
-}
-
-struct net_device *bond_option_active_slave_get_rcu(struct bonding *bond)
-{
-	struct slave *slave = rcu_dereference(bond->curr_active_slave);
-
-	return __bond_option_active_slave_get(bond, slave);
-}
-
 static int bond_option_active_slave_set(struct bonding *bond,
 					const struct bond_opt_value *newval)
 {

commit 205845a34763432040496908c8f52f1f97e5ee62
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Fri Jul 24 15:50:31 2015 +0200

    bonding: convert num_grat_arp to the new bonding option API
    
    num_grat_arp wasn't converted to the new bonding option API, so do this
    now and remove the specific sysfs store option in order to use the
    standard one. num_grat_arp is the same as num_unsol_na so add it as an
    alias with the same option settings. An important difference is the option
    name which is matched in bond_sysfs_store_option().
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Acked-by: Veaceslav Falico <vfalico@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index e9c624d54dd4..6dda57e2e724 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -420,6 +420,13 @@ static const struct bond_option bond_opts[BOND_OPT_LAST] = {
 		.flags = BOND_OPTFLAG_IFDOWN,
 		.values = bond_ad_user_port_key_tbl,
 		.set = bond_option_ad_user_port_key_set,
+	},
+	[BOND_OPT_NUM_PEER_NOTIF_ALIAS] = {
+		.id = BOND_OPT_NUM_PEER_NOTIF_ALIAS,
+		.name = "num_grat_arp",
+		.desc = "Number of peer notifications to send on failover event",
+		.values = bond_num_peer_notif_tbl,
+		.set = bond_option_num_peer_notif_set
 	}
 };
 

commit 36583eb54d46c36a447afd6c379839f292397429
Merge: fa7912be9671 cf539cbd8a81
Author: David S. Miller <davem@davemloft.net>
Date:   Sat May 23 01:22:35 2015 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts:
            drivers/net/ethernet/cadence/macb.c
            drivers/net/phy/phy.c
            include/linux/skbuff.h
            net/ipv4/tcp.c
            net/switchdev/switchdev.c
    
    Switchdev was a case of RTNH_H_{EXTERNAL --> OFFLOAD}
    renaming overlapping with net-next changes of various
    sorts.
    
    phy.c was a case of two changes, one adding a local
    variable to a function whilst the second was removing
    one.
    
    tcp.c overlapped a deadlock fix with the addition of new tcp_info
    statistic values.
    
    macb.c involved the addition of two zyncq device entries.
    
    skbuff.h involved adding back ipv4_daddr to nf_bridge_info
    whilst net-next changes put two other existing members of
    that struct into a union.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit ed2a80ab7b76f11af0b2c6255709c4ebf164b667
Author: Nicolas Dichtel <nicolas.dichtel@6wind.com>
Date:   Wed May 13 14:19:42 2015 +0200

    rtnl/bond: don't send rtnl msg for unregistered iface
    
    Before the patch, the command 'ip link add bond2 type bond mode 802.3ad'
    causes the kernel to send a rtnl message for the bond2 interface, with an
    ifindex 0.
    
    'ip monitor' shows:
    0: bond2: <BROADCAST,MULTICAST,MASTER> mtu 1500 state DOWN group default
        link/ether 00:00:00:00:00:00 brd ff:ff:ff:ff:ff:ff
    9: bond2@NONE: <BROADCAST,MULTICAST,MASTER> mtu 1500 qdisc noop state DOWN group default
        link/ether ea:3e:1f:53:92:7b brd ff:ff:ff:ff:ff:ff
    [snip]
    
    The patch fixes the spotted bug by checking in bond driver if the interface
    is registered before calling the notifier chain.
    It also adds a check in rtmsg_ifinfo() to prevent this kind of bug in the
    future.
    
    Fixes: d4261e565000 ("bonding: create netlink event when bonding option is changed")
    CC: Jiri Pirko <jiri@resnulli.us>
    Reported-by: Julien Meunier <julien.meunier@6wind.com>
    Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 4df28943d222..e8d3c1d35453 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -624,7 +624,7 @@ int __bond_opt_set(struct bonding *bond,
 out:
 	if (ret)
 		bond_opt_error_interpret(bond, opt, ret, val);
-	else
+	else if (bond->dev->reg_state == NETREG_REGISTERED)
 		call_netdevice_notifiers(NETDEV_CHANGEINFODATA, bond->dev);
 
 	return ret;

commit 171a42c38c6e1a5a076d6276e94e55a0b5b7868c
Author: Andy Gospodarek <gospo@cumulusnetworks.com>
Date:   Sat May 9 00:01:58 2015 -0700

    bonding: add netlink support for sys prio, actor sys mac, and port key
    
    Adds netlink support for the following bonding options:
    * BOND_OPT_AD_ACTOR_SYS_PRIO
    * BOND_OPT_AD_ACTOR_SYSTEM
    * BOND_OPT_AD_USER_PORT_KEY
    
    When setting the actor system mac address we assume the netlink message
    contains a binary mac and not a string representation of a mac.
    
    Signed-off-by: Andy Gospodarek <gospo@cumulusnetworks.com>
    [jt: completed the setting side of the netlink attributes]
    Signed-off-by: Jonathan Toppins <jtoppins@cumulusnetworks.com>
    Signed-off-by: Nikolay Aleksandrov <razor@blackwall.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index c85da05721e6..9a32bbd7724e 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -1394,7 +1394,7 @@ static int bond_option_tlb_dynamic_lb_set(struct bonding *bond,
 static int bond_option_ad_actor_sys_prio_set(struct bonding *bond,
 					     const struct bond_opt_value *newval)
 {
-	netdev_info(bond->dev, "Setting ad_actor_sys_prio to (%llu)\n",
+	netdev_info(bond->dev, "Setting ad_actor_sys_prio to %llu\n",
 		    newval->value);
 
 	bond->params.ad_actor_sys_prio = newval->value;
@@ -1405,24 +1405,36 @@ static int bond_option_ad_actor_system_set(struct bonding *bond,
 					   const struct bond_opt_value *newval)
 {
 	u8 macaddr[ETH_ALEN];
+	u8 *mac;
 	int i;
 
-	i = sscanf(newval->string, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
-		   &macaddr[0], &macaddr[1], &macaddr[2],
-		   &macaddr[3], &macaddr[4], &macaddr[5]);
-	if (i != ETH_ALEN || !is_valid_ether_addr(macaddr)) {
-		netdev_err(bond->dev, "Invalid MAC address.\n");
-		return -EINVAL;
+	if (newval->string) {
+		i = sscanf(newval->string, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
+			   &macaddr[0], &macaddr[1], &macaddr[2],
+			   &macaddr[3], &macaddr[4], &macaddr[5]);
+		if (i != ETH_ALEN)
+			goto err;
+		mac = macaddr;
+	} else {
+		mac = (u8 *)&newval->value;
 	}
 
-	ether_addr_copy(bond->params.ad_actor_system, macaddr);
+	if (!is_valid_ether_addr(mac))
+		goto err;
+
+	netdev_info(bond->dev, "Setting ad_actor_system to %pM\n", mac);
+	ether_addr_copy(bond->params.ad_actor_system, mac);
 	return 0;
+
+err:
+	netdev_err(bond->dev, "Invalid MAC address.\n");
+	return -EINVAL;
 }
 
 static int bond_option_ad_user_port_key_set(struct bonding *bond,
 					    const struct bond_opt_value *newval)
 {
-	netdev_info(bond->dev, "Setting ad_user_port_key to (%llu)\n",
+	netdev_info(bond->dev, "Setting ad_user_port_key to %llu\n",
 		    newval->value);
 
 	bond->params.ad_user_port_key = newval->value;

commit d22a5fc0c32edcf5c3bb973ee8c9a2606ba500a8
Author: Mahesh Bandewar <maheshb@google.com>
Date:   Sat May 9 00:01:57 2015 -0700

    bonding: Implement user key part of port_key in an AD system.
    
    The port key has three components - user-key, speed-part, and duplex-part.
    The LSBit is for the duplex-part, next 5 bits are for the speed while the
    remaining 10 bits are the user defined key bits. Get these 10 bits
    from the user-space (through the SysFs interface) and use it to form the
    admin port-key. Allowed range for the user-key is 0 - 1023 (10 bits). If
    it is not provided then use zero for the user-key-bits (default).
    
    It can set using following example code -
    
       # modprobe bonding mode=4
       # usr_port_key=$(( RANDOM & 0x3FF ))
       # echo $usr_port_key > /sys/class/net/bond0/bonding/ad_user_port_key
       # echo +eth1 > /sys/class/net/bond0/bonding/slaves
       ...
       # ip link set bond0 up
    
    Signed-off-by: Mahesh Bandewar <maheshb@google.com>
    Reviewed-by: Nikolay Aleksandrov <nikolay@redhat.com>
    [jt: * fixed up style issues reported by checkpatch
         * fixed up context from change in ad_actor_sys_prio patch]
    Signed-off-by: Jonathan Toppins <jtoppins@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index cdcef217ac84..c85da05721e6 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -74,6 +74,8 @@ static int bond_option_ad_actor_sys_prio_set(struct bonding *bond,
 					     const struct bond_opt_value *newval);
 static int bond_option_ad_actor_system_set(struct bonding *bond,
 					   const struct bond_opt_value *newval);
+static int bond_option_ad_user_port_key_set(struct bonding *bond,
+					    const struct bond_opt_value *newval);
 
 
 static const struct bond_opt_value bond_mode_tbl[] = {
@@ -196,6 +198,12 @@ static const struct bond_opt_value bond_ad_actor_sys_prio_tbl[] = {
 	{ NULL,      -1,    0},
 };
 
+static const struct bond_opt_value bond_ad_user_port_key_tbl[] = {
+	{ "minval",  0,     BOND_VALFLAG_MIN | BOND_VALFLAG_DEFAULT},
+	{ "maxval",  1023,  BOND_VALFLAG_MAX},
+	{ NULL,      -1,    0},
+};
+
 static const struct bond_option bond_opts[BOND_OPT_LAST] = {
 	[BOND_OPT_MODE] = {
 		.id = BOND_OPT_MODE,
@@ -405,6 +413,14 @@ static const struct bond_option bond_opts[BOND_OPT_LAST] = {
 		.flags = BOND_OPTFLAG_RAWVAL | BOND_OPTFLAG_IFDOWN,
 		.set = bond_option_ad_actor_system_set,
 	},
+	[BOND_OPT_AD_USER_PORT_KEY] = {
+		.id = BOND_OPT_AD_USER_PORT_KEY,
+		.name = "ad_user_port_key",
+		.unsuppmodes = BOND_MODE_ALL_EX(BIT(BOND_MODE_8023AD)),
+		.flags = BOND_OPTFLAG_IFDOWN,
+		.values = bond_ad_user_port_key_tbl,
+		.set = bond_option_ad_user_port_key_set,
+	}
 };
 
 /* Searches for an option by name */
@@ -1402,3 +1418,13 @@ static int bond_option_ad_actor_system_set(struct bonding *bond,
 	ether_addr_copy(bond->params.ad_actor_system, macaddr);
 	return 0;
 }
+
+static int bond_option_ad_user_port_key_set(struct bonding *bond,
+					    const struct bond_opt_value *newval)
+{
+	netdev_info(bond->dev, "Setting ad_user_port_key to (%llu)\n",
+		    newval->value);
+
+	bond->params.ad_user_port_key = newval->value;
+	return 0;
+}

commit 74514957552edd4661a4608618121f3c71d4e891
Author: Mahesh Bandewar <maheshb@google.com>
Date:   Sat May 9 00:01:56 2015 -0700

    bonding: Allow userspace to set actors' macaddr in an AD-system.
    
    In an AD system, the communication between actor and partner is the
    business between these two entities. In the current setup anyone on the
    same L2 can "guess" the LACPDU contents and then possibly send the
    spoofed LACPDUs and trick the partner causing connectivity issues for
    the AD system. This patch allows to use a random mac-address obscuring
    it's identity making it harder for someone in the L2 is do the same thing.
    
    This patch allows user-space to choose the mac-address for the AD-system.
    This mac-address can not be NULL or a Multicast. If the mac-address is set
    from user-space; kernel will honor it and will not overwrite it. In the
    absence (value from user space); the logic will default to using the
    masters' mac as the mac-address for the AD-system.
    
    It can be set using example code below -
    
       # modprobe bonding mode=4
       # sys_mac_addr=$(printf '%02x:%02x:%02x:%02x:%02x:%02x' \
                        $(( (RANDOM & 0xFE) | 0x02 )) \
                        $(( RANDOM & 0xFF )) \
                        $(( RANDOM & 0xFF )) \
                        $(( RANDOM & 0xFF )) \
                        $(( RANDOM & 0xFF )) \
                        $(( RANDOM & 0xFF )))
       # echo $sys_mac_addr > /sys/class/net/bond0/bonding/ad_actor_system
       # echo +eth1 > /sys/class/net/bond0/bonding/slaves
       ...
       # ip link set bond0 up
    
    Signed-off-by: Mahesh Bandewar <maheshb@google.com>
    Reviewed-by: Nikolay Aleksandrov <nikolay@redhat.com>
    [jt: fixed up style issues reported by checkpatch]
    Signed-off-by: Jonathan Toppins <jtoppins@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index d2b47e5e99f7..cdcef217ac84 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -72,6 +72,8 @@ static int bond_option_tlb_dynamic_lb_set(struct bonding *bond,
 				  const struct bond_opt_value *newval);
 static int bond_option_ad_actor_sys_prio_set(struct bonding *bond,
 					     const struct bond_opt_value *newval);
+static int bond_option_ad_actor_system_set(struct bonding *bond,
+					   const struct bond_opt_value *newval);
 
 
 static const struct bond_opt_value bond_mode_tbl[] = {
@@ -396,6 +398,13 @@ static const struct bond_option bond_opts[BOND_OPT_LAST] = {
 		.values = bond_ad_actor_sys_prio_tbl,
 		.set = bond_option_ad_actor_sys_prio_set,
 	},
+	[BOND_OPT_AD_ACTOR_SYSTEM] = {
+		.id = BOND_OPT_AD_ACTOR_SYSTEM,
+		.name = "ad_actor_system",
+		.unsuppmodes = BOND_MODE_ALL_EX(BIT(BOND_MODE_8023AD)),
+		.flags = BOND_OPTFLAG_RAWVAL | BOND_OPTFLAG_IFDOWN,
+		.set = bond_option_ad_actor_system_set,
+	},
 };
 
 /* Searches for an option by name */
@@ -1375,3 +1384,21 @@ static int bond_option_ad_actor_sys_prio_set(struct bonding *bond,
 	bond->params.ad_actor_sys_prio = newval->value;
 	return 0;
 }
+
+static int bond_option_ad_actor_system_set(struct bonding *bond,
+					   const struct bond_opt_value *newval)
+{
+	u8 macaddr[ETH_ALEN];
+	int i;
+
+	i = sscanf(newval->string, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
+		   &macaddr[0], &macaddr[1], &macaddr[2],
+		   &macaddr[3], &macaddr[4], &macaddr[5]);
+	if (i != ETH_ALEN || !is_valid_ether_addr(macaddr)) {
+		netdev_err(bond->dev, "Invalid MAC address.\n");
+		return -EINVAL;
+	}
+
+	ether_addr_copy(bond->params.ad_actor_system, macaddr);
+	return 0;
+}

commit 6791e4661c4bd3e9f193a84247f2c389578a4336
Author: Mahesh Bandewar <maheshb@google.com>
Date:   Sat May 9 00:01:55 2015 -0700

    bonding: Allow userspace to set actors' system_priority in AD system
    
    This patch allows user to randomize the system-priority in an ad-system.
    The allowed range is 1 - 0xFFFF while default value is 0xFFFF. If user
    does not specify this value, the system defaults to 0xFFFF, which is
    what it was before this patch.
    
    Following example code could set the value -
        # modprobe bonding mode=4
        # sys_prio=$(( 1 + RANDOM + RANDOM ))
        # echo $sys_prio > /sys/class/net/bond0/bonding/ad_actor_sys_prio
        # echo +eth1 > /sys/class/net/bond0/bonding/slaves
        ...
        # ip link set bond0 up
    
    Signed-off-by: Mahesh Bandewar <maheshb@google.com>
    Reviewed-by: Nikolay Aleksandrov <nikolay@redhat.com>
    [jt: * fixed up style issues reported by checkpatch
         * changed how the default value is set in bond_check_params(), this
           makes the default consistent between what gets set for a new bond
           and what the default is claimed to be in the bonding options.]
    Signed-off-by: Jonathan Toppins <jtoppins@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 4df28943d222..d2b47e5e99f7 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -70,6 +70,8 @@ static int bond_option_slaves_set(struct bonding *bond,
 				  const struct bond_opt_value *newval);
 static int bond_option_tlb_dynamic_lb_set(struct bonding *bond,
 				  const struct bond_opt_value *newval);
+static int bond_option_ad_actor_sys_prio_set(struct bonding *bond,
+					     const struct bond_opt_value *newval);
 
 
 static const struct bond_opt_value bond_mode_tbl[] = {
@@ -186,6 +188,12 @@ static const struct bond_opt_value bond_tlb_dynamic_lb_tbl[] = {
 	{ NULL,  -1, 0}
 };
 
+static const struct bond_opt_value bond_ad_actor_sys_prio_tbl[] = {
+	{ "minval",  1,     BOND_VALFLAG_MIN},
+	{ "maxval",  65535, BOND_VALFLAG_MAX | BOND_VALFLAG_DEFAULT},
+	{ NULL,      -1,    0},
+};
+
 static const struct bond_option bond_opts[BOND_OPT_LAST] = {
 	[BOND_OPT_MODE] = {
 		.id = BOND_OPT_MODE,
@@ -379,7 +387,15 @@ static const struct bond_option bond_opts[BOND_OPT_LAST] = {
 		.values = bond_tlb_dynamic_lb_tbl,
 		.flags = BOND_OPTFLAG_IFDOWN,
 		.set = bond_option_tlb_dynamic_lb_set,
-	}
+	},
+	[BOND_OPT_AD_ACTOR_SYS_PRIO] = {
+		.id = BOND_OPT_AD_ACTOR_SYS_PRIO,
+		.name = "ad_actor_sys_prio",
+		.unsuppmodes = BOND_MODE_ALL_EX(BIT(BOND_MODE_8023AD)),
+		.flags = BOND_OPTFLAG_IFDOWN,
+		.values = bond_ad_actor_sys_prio_tbl,
+		.set = bond_option_ad_actor_sys_prio_set,
+	},
 };
 
 /* Searches for an option by name */
@@ -1349,3 +1365,13 @@ static int bond_option_tlb_dynamic_lb_set(struct bonding *bond,
 
 	return 0;
 }
+
+static int bond_option_ad_actor_sys_prio_set(struct bonding *bond,
+					     const struct bond_opt_value *newval)
+{
+	netdev_info(bond->dev, "Setting ad_actor_sys_prio to (%llu)\n",
+		    newval->value);
+
+	bond->params.ad_actor_sys_prio = newval->value;
+	return 0;
+}

commit 2477bc9a3db53540c64687c79efae9a7f1f60cef
Author: Jonathan Toppins <jtoppins@cumulusnetworks.com>
Date:   Mon Jan 26 01:16:57 2015 -0500

    bonding: update bond carrier state when min_links option changes
    
    Cc: Andy Gospodarek <gospo@cumulusnetworks.com>
    Signed-off-by: Jonathan Toppins <jtoppins@cumulusnetworks.com>
    Signed-off-by: Jay Vosburgh <jay.vosburgh@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 9bd538d4474b..4df28943d222 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -1181,6 +1181,7 @@ static int bond_option_min_links_set(struct bonding *bond,
 	netdev_info(bond->dev, "Setting min links value to %llu\n",
 		    newval->value);
 	bond->params.min_links = newval->value;
+	bond_set_carrier(bond);
 
 	return 0;
 }

commit 7bfa014500ceffa8b787ffc3a6e00252443631d0
Author: Jonathan Toppins <jtoppins@cumulusnetworks.com>
Date:   Fri Jan 9 13:31:08 2015 -0500

    bonding: cleanup bond_opts array
    
    Remove the empty array element initializer and size the array with
    BOND_OPT_LAST so the compiler will complain if more elements are in
    there than should be.
    
    An interesting unwanted side effect of this initializer is that if one
    inserts new options into the middle of the array then this initializer
    will zero out the option that equals BOND_OPT_TLB_DYNAMIC_LB+1.
    
    Example:
    Extend the OPTS enum:
    enum {
       ...
       BOND_OPT_TLB_DYNAMIC_LB,
       BOND_OPT_LACP_NEW1,
       BOND_OPT_LAST
    };
    
    Now insert into bond_opts array:
    static const struct bond_option bond_opts[] = {
          ...
          [BOND_OPT_LACP_RATE] = { .... unchanged stuff .... },
          [BOND_OPT_LACP_NEW1] = { ... new stuff ... },
          ...
          [BOND_OPT_TLB_DYNAMIC_LB] = { .... unchanged stuff ....},
          { } // MARK A
    };
    
    Since BOND_OPT_LACP_NEW1 = BOND_OPT_TLB_DYNAMIC_LB+1, the last
    initializer (MARK A) will overwrite the contents of BOND_OPT_LACP_NEW1
    and can be easily viewed with the crash utility.
    
    Signed-off-by: Jonathan Toppins <jtoppins@cumulusnetworks.com>
    Cc: Andy Gospodarek <gospo@cumulusnetworks.com>
    Cc: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: Andy Gospodarek <gospo@cumulusnetworks.com>
    Acked-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 1a61cc9b3402..9bd538d4474b 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -186,7 +186,7 @@ static const struct bond_opt_value bond_tlb_dynamic_lb_tbl[] = {
 	{ NULL,  -1, 0}
 };
 
-static const struct bond_option bond_opts[] = {
+static const struct bond_option bond_opts[BOND_OPT_LAST] = {
 	[BOND_OPT_MODE] = {
 		.id = BOND_OPT_MODE,
 		.name = "mode",
@@ -379,8 +379,7 @@ static const struct bond_option bond_opts[] = {
 		.values = bond_tlb_dynamic_lb_tbl,
 		.flags = BOND_OPTFLAG_IFDOWN,
 		.set = bond_option_tlb_dynamic_lb_set,
-	},
-	{ }
+	}
 };
 
 /* Searches for an option by name */

commit 1ef8019be8799c39f316a772ffdd705c46029752
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Nov 10 13:27:49 2014 -0500

    net: Move bonding headers under include/net
    
    This ways drivers like cxgb4 don't need to do ugly relative includes.
    
    Reported-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index b62697f4a3de..1a61cc9b3402 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -16,7 +16,7 @@
 #include <linux/rcupdate.h>
 #include <linux/ctype.h>
 #include <linux/inet.h>
-#include "bonding.h"
+#include <net/bonding.h>
 
 static int bond_option_active_slave_set(struct bonding *bond,
 					const struct bond_opt_value *newval);

commit 1c72cfdc96e63bf975cab514c4ca4d8a661ba0e6
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Thu Sep 11 22:49:24 2014 +0200

    bonding: clean curr_slave_lock use
    
    Mostly all users of curr_slave_lock already have RTNL as we've discussed
    previously so there's no point in using it, the one case where the lock
    must stay is the 3ad code, in fact it's the only one.
    It's okay to remove it from bond_do_fail_over_mac() as it's called with
    RTNL and drops the curr_slave_lock anyway.
    bond_change_active_slave() is one of the main places where
    curr_slave_lock was used, it's okay to remove it as all callers use RTNL
    these days before calling it, that's why we move the ASSERT_RTNL() in
    the beginning to catch any potential offenders to this rule.
    The RTNL argument actually applies to all of the places where
    curr_slave_lock has been removed from in this patch.
    Also remove the unnecessary bond_deref_active_protected() macro and use
    rtnl_dereference() instead.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 534c0600484e..b62697f4a3de 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -734,15 +734,13 @@ static int bond_option_active_slave_set(struct bonding *bond,
 	}
 
 	block_netpoll_tx();
-	write_lock_bh(&bond->curr_slave_lock);
-
 	/* check to see if we are clearing active */
 	if (!slave_dev) {
 		netdev_info(bond->dev, "Clearing current active slave\n");
 		RCU_INIT_POINTER(bond->curr_active_slave, NULL);
 		bond_select_active_slave(bond);
 	} else {
-		struct slave *old_active = bond_deref_active_protected(bond);
+		struct slave *old_active = rtnl_dereference(bond->curr_active_slave);
 		struct slave *new_active = bond_slave_get_rtnl(slave_dev);
 
 		BUG_ON(!new_active);
@@ -765,8 +763,6 @@ static int bond_option_active_slave_set(struct bonding *bond,
 			}
 		}
 	}
-
-	write_unlock_bh(&bond->curr_slave_lock);
 	unblock_netpoll_tx();
 
 	return ret;
@@ -1066,7 +1062,6 @@ static int bond_option_primary_set(struct bonding *bond,
 	struct slave *slave;
 
 	block_netpoll_tx();
-	write_lock_bh(&bond->curr_slave_lock);
 
 	p = strchr(primary, '\n');
 	if (p)
@@ -1103,7 +1098,6 @@ static int bond_option_primary_set(struct bonding *bond,
 		    primary, bond->dev->name);
 
 out:
-	write_unlock_bh(&bond->curr_slave_lock);
 	unblock_netpoll_tx();
 
 	return 0;
@@ -1117,9 +1111,7 @@ static int bond_option_primary_reselect_set(struct bonding *bond,
 	bond->params.primary_reselect = newval->value;
 
 	block_netpoll_tx();
-	write_lock_bh(&bond->curr_slave_lock);
 	bond_select_active_slave(bond);
-	write_unlock_bh(&bond->curr_slave_lock);
 	unblock_netpoll_tx();
 
 	return 0;

commit 246df7b423aa61a8bd0b58404759a9abb4c15081
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Tue Sep 9 23:17:02 2014 +0200

    bonding: options: remove bond->lock usage
    
    We're safe to remove the bond->lock use from the arp targets because
    arp_rcv_probe no longer acquires bond->lock, only rcu_read_lock.
    Also setting the primary slave is safe because noone uses the bond->lock
    as a syncing mechanism for that anymore.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 7c9e176baecc..534c0600484e 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -955,14 +955,7 @@ static int _bond_option_arp_ip_target_add(struct bonding *bond, __be32 target)
 
 static int bond_option_arp_ip_target_add(struct bonding *bond, __be32 target)
 {
-	int ret;
-
-	/* not to race with bond_arp_rcv */
-	write_lock_bh(&bond->lock);
-	ret = _bond_option_arp_ip_target_add(bond, target);
-	write_unlock_bh(&bond->lock);
-
-	return ret;
+	return _bond_option_arp_ip_target_add(bond, target);
 }
 
 static int bond_option_arp_ip_target_rem(struct bonding *bond, __be32 target)
@@ -991,9 +984,6 @@ static int bond_option_arp_ip_target_rem(struct bonding *bond, __be32 target)
 
 	netdev_info(bond->dev, "Removing ARP target %pI4\n", &target);
 
-	/* not to race with bond_arp_rcv */
-	write_lock_bh(&bond->lock);
-
 	bond_for_each_slave(bond, slave, iter) {
 		targets_rx = slave->target_last_arp_rx;
 		for (i = ind; (i < BOND_MAX_ARP_TARGETS-1) && targets[i+1]; i++)
@@ -1004,8 +994,6 @@ static int bond_option_arp_ip_target_rem(struct bonding *bond, __be32 target)
 		targets[i] = targets[i+1];
 	targets[i] = 0;
 
-	write_unlock_bh(&bond->lock);
-
 	return 0;
 }
 
@@ -1013,11 +1001,8 @@ void bond_option_arp_ip_targets_clear(struct bonding *bond)
 {
 	int i;
 
-	/* not to race with bond_arp_rcv */
-	write_lock_bh(&bond->lock);
 	for (i = 0; i < BOND_MAX_ARP_TARGETS; i++)
 		_bond_options_arp_ip_target_set(bond, i, 0, 0);
-	write_unlock_bh(&bond->lock);
 }
 
 static int bond_option_arp_ip_targets_set(struct bonding *bond,
@@ -1081,7 +1066,6 @@ static int bond_option_primary_set(struct bonding *bond,
 	struct slave *slave;
 
 	block_netpoll_tx();
-	read_lock(&bond->lock);
 	write_lock_bh(&bond->curr_slave_lock);
 
 	p = strchr(primary, '\n');
@@ -1120,7 +1104,6 @@ static int bond_option_primary_set(struct bonding *bond,
 
 out:
 	write_unlock_bh(&bond->curr_slave_lock);
-	read_unlock(&bond->lock);
 	unblock_netpoll_tx();
 
 	return 0;

commit 059b47e8aaf997245bc531e980581de492315fe6
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Tue Sep 9 23:17:00 2014 +0200

    bonding: convert primary_slave to use RCU
    
    This is necessary mainly for two bonding call sites: procfs and
    sysfs as it was dereferenced without any real protection.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index d8dc17faa6b4..7c9e176baecc 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -1090,7 +1090,7 @@ static int bond_option_primary_set(struct bonding *bond,
 	/* check to see if we are clearing primary */
 	if (!strlen(primary)) {
 		netdev_info(bond->dev, "Setting primary slave to None\n");
-		bond->primary_slave = NULL;
+		RCU_INIT_POINTER(bond->primary_slave, NULL);
 		memset(bond->params.primary, 0, sizeof(bond->params.primary));
 		bond_select_active_slave(bond);
 		goto out;
@@ -1100,16 +1100,16 @@ static int bond_option_primary_set(struct bonding *bond,
 		if (strncmp(slave->dev->name, primary, IFNAMSIZ) == 0) {
 			netdev_info(bond->dev, "Setting %s as primary slave\n",
 				    slave->dev->name);
-			bond->primary_slave = slave;
+			rcu_assign_pointer(bond->primary_slave, slave);
 			strcpy(bond->params.primary, slave->dev->name);
 			bond_select_active_slave(bond);
 			goto out;
 		}
 	}
 
-	if (bond->primary_slave) {
+	if (rtnl_dereference(bond->primary_slave)) {
 		netdev_info(bond->dev, "Setting primary slave to None\n");
-		bond->primary_slave = NULL;
+		RCU_INIT_POINTER(bond->primary_slave, NULL);
 		bond_select_active_slave(bond);
 	}
 	strncpy(bond->params.primary, primary, IFNAMSIZ);

commit d4261e5650004d6d51137553ea5433d5828562dc
Author: Jiri Pirko <jiri@resnulli.us>
Date:   Tue Aug 19 16:02:12 2014 +0200

    bonding: create netlink event when bonding option is changed
    
    Userspace needs to be notified if one changes some option.
    
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Acked-by: Veaceslav Falico <vfalico@gmail.com>
    Acked-by: Andy Gospodarek <gospo@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index dc73463c2c23..d8dc17faa6b4 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -625,6 +625,8 @@ int __bond_opt_set(struct bonding *bond,
 out:
 	if (ret)
 		bond_opt_error_interpret(bond, opt, ret, val);
+	else
+		call_netdevice_notifiers(NETDEV_CHANGEINFODATA, bond->dev);
 
 	return ret;
 }

commit cb25235860c8b6552a8f9cca3291e9d46efb7925
Author: Veaceslav Falico <vfalico@gmail.com>
Date:   Tue Jul 15 19:36:09 2014 +0200

    bonding: remove pr_fmt from bond_options.c
    
    To maintain the same message structure as netdev_* functions print.
    
    CC: Jay Vosburgh <j.vosburgh@gmail.com>
    CC: Andy Gospodarek <andy@greyhouse.net>
    Signed-off-by: Veaceslav Falico <vfalico@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 1e28de28dddd..dc73463c2c23 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -9,8 +9,6 @@
  * (at your option) any later version.
  */
 
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
 #include <linux/errno.h>
 #include <linux/if.h>
 #include <linux/netdevice.h>

commit 2de390bace7c533c88359404911ff6e080de4004
Author: Veaceslav Falico <vfalico@gmail.com>
Date:   Tue Jul 15 19:36:08 2014 +0200

    bonding: convert bond_options.c to use netdev_printk instead of pr_
    
    CC: Jay Vosburgh <j.vosburgh@gmail.com>
    CC: Andy Gospodarek <andy@greyhouse.net>
    Signed-off-by: Veaceslav Falico <vfalico@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index cf720ce1b69e..1e28de28dddd 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -544,9 +544,8 @@ static void bond_opt_dep_print(struct bonding *bond,
 	params = &bond->params;
 	modeval = bond_opt_get_val(BOND_OPT_MODE, params->mode);
 	if (test_bit(params->mode, &opt->unsuppmodes))
-		pr_err("%s: option %s: mode dependency failed, not supported in mode %s(%llu)\n",
-		       bond->dev->name, opt->name,
-		       modeval->string, modeval->value);
+		netdev_err(bond->dev, "option %s: mode dependency failed, not supported in mode %s(%llu)\n",
+			   opt->name, modeval->string, modeval->value);
 }
 
 static void bond_opt_error_interpret(struct bonding *bond,
@@ -564,31 +563,30 @@ static void bond_opt_error_interpret(struct bonding *bond,
 				p = strchr(val->string, '\n');
 				if (p)
 					*p = '\0';
-				pr_err("%s: option %s: invalid value (%s)\n",
-				       bond->dev->name, opt->name, val->string);
+				netdev_err(bond->dev, "option %s: invalid value (%s)\n",
+					   opt->name, val->string);
 			} else {
-				pr_err("%s: option %s: invalid value (%llu)\n",
-				       bond->dev->name, opt->name, val->value);
+				netdev_err(bond->dev, "option %s: invalid value (%llu)\n",
+					   opt->name, val->value);
 			}
 		}
 		minval = bond_opt_get_flags(opt, BOND_VALFLAG_MIN);
 		maxval = bond_opt_get_flags(opt, BOND_VALFLAG_MAX);
 		if (!maxval)
 			break;
-		pr_err("%s: option %s: allowed values %llu - %llu\n",
-		       bond->dev->name, opt->name, minval ? minval->value : 0,
-		       maxval->value);
+		netdev_err(bond->dev, "option %s: allowed values %llu - %llu\n",
+			   opt->name, minval ? minval->value : 0, maxval->value);
 		break;
 	case -EACCES:
 		bond_opt_dep_print(bond, opt);
 		break;
 	case -ENOTEMPTY:
-		pr_err("%s: option %s: unable to set because the bond device has slaves\n",
-		       bond->dev->name, opt->name);
+		netdev_err(bond->dev, "option %s: unable to set because the bond device has slaves\n",
+			   opt->name);
 		break;
 	case -EBUSY:
-		pr_err("%s: option %s: unable to set because the bond device is up\n",
-		       bond->dev->name, opt->name);
+		netdev_err(bond->dev, "option %s: unable to set because the bond device is up\n",
+			   opt->name);
 		break;
 	default:
 		break;
@@ -675,14 +673,14 @@ static int bond_option_mode_set(struct bonding *bond,
 				const struct bond_opt_value *newval)
 {
 	if (!bond_mode_uses_arp(newval->value) && bond->params.arp_interval) {
-		pr_info("%s: %s mode is incompatible with arp monitoring, start mii monitoring\n",
-			bond->dev->name, newval->string);
+		netdev_info(bond->dev, "%s mode is incompatible with arp monitoring, start mii monitoring\n",
+			    newval->string);
 		/* disable arp monitoring */
 		bond->params.arp_interval = 0;
 		/* set miimon to default value */
 		bond->params.miimon = BOND_DEFAULT_MIIMON;
-		pr_info("%s: Setting MII monitoring interval to %d\n",
-			bond->dev->name, bond->params.miimon);
+		netdev_info(bond->dev, "Setting MII monitoring interval to %d\n",
+			    bond->params.miimon);
 	}
 
 	/* don't cache arp_validate between modes */
@@ -723,14 +721,14 @@ static int bond_option_active_slave_set(struct bonding *bond,
 
 	if (slave_dev) {
 		if (!netif_is_bond_slave(slave_dev)) {
-			pr_err("Device %s is not bonding slave\n",
-			       slave_dev->name);
+			netdev_err(bond->dev, "Device %s is not bonding slave\n",
+				   slave_dev->name);
 			return -EINVAL;
 		}
 
 		if (bond->dev != netdev_master_upper_dev_get(slave_dev)) {
-			pr_err("%s: Device %s is not our slave\n",
-			       bond->dev->name, slave_dev->name);
+			netdev_err(bond->dev, "Device %s is not our slave\n",
+				   slave_dev->name);
 			return -EINVAL;
 		}
 	}
@@ -740,7 +738,7 @@ static int bond_option_active_slave_set(struct bonding *bond,
 
 	/* check to see if we are clearing active */
 	if (!slave_dev) {
-		pr_info("%s: Clearing current active slave\n", bond->dev->name);
+		netdev_info(bond->dev, "Clearing current active slave\n");
 		RCU_INIT_POINTER(bond->curr_active_slave, NULL);
 		bond_select_active_slave(bond);
 	} else {
@@ -751,18 +749,18 @@ static int bond_option_active_slave_set(struct bonding *bond,
 
 		if (new_active == old_active) {
 			/* do nothing */
-			pr_info("%s: %s is already the current active slave\n",
-				bond->dev->name, new_active->dev->name);
+			netdev_info(bond->dev, "%s is already the current active slave\n",
+				    new_active->dev->name);
 		} else {
 			if (old_active && (new_active->link == BOND_LINK_UP) &&
 			    bond_slave_is_up(new_active)) {
-				pr_info("%s: Setting %s as active slave\n",
-					bond->dev->name, new_active->dev->name);
+				netdev_info(bond->dev, "Setting %s as active slave\n",
+					    new_active->dev->name);
 				bond_change_active_slave(bond, new_active);
 			} else {
-				pr_err("%s: Could not set %s as active slave; either %s is down or the link is down\n",
-				       bond->dev->name, new_active->dev->name,
-				       new_active->dev->name);
+				netdev_err(bond->dev, "Could not set %s as active slave; either %s is down or the link is down\n",
+					   new_active->dev->name,
+					   new_active->dev->name);
 				ret = -EINVAL;
 			}
 		}
@@ -781,20 +779,17 @@ static int bond_option_active_slave_set(struct bonding *bond,
 static int bond_option_miimon_set(struct bonding *bond,
 				  const struct bond_opt_value *newval)
 {
-	pr_info("%s: Setting MII monitoring interval to %llu\n",
-		bond->dev->name, newval->value);
+	netdev_info(bond->dev, "Setting MII monitoring interval to %llu\n",
+		    newval->value);
 	bond->params.miimon = newval->value;
 	if (bond->params.updelay)
-		pr_info("%s: Note: Updating updelay (to %d) since it is a multiple of the miimon value\n",
-			bond->dev->name,
+		netdev_info(bond->dev, "Note: Updating updelay (to %d) since it is a multiple of the miimon value\n",
 			bond->params.updelay * bond->params.miimon);
 	if (bond->params.downdelay)
-		pr_info("%s: Note: Updating downdelay (to %d) since it is a multiple of the miimon value\n",
-			bond->dev->name,
-			bond->params.downdelay * bond->params.miimon);
+		netdev_info(bond->dev, "Note: Updating downdelay (to %d) since it is a multiple of the miimon value\n",
+			    bond->params.downdelay * bond->params.miimon);
 	if (newval->value && bond->params.arp_interval) {
-		pr_info("%s: MII monitoring cannot be used with ARP monitoring - disabling ARP monitoring...\n",
-			bond->dev->name);
+		netdev_info(bond->dev, "MII monitoring cannot be used with ARP monitoring - disabling ARP monitoring...\n");
 		bond->params.arp_interval = 0;
 		if (bond->params.arp_validate)
 			bond->params.arp_validate = BOND_ARP_VALIDATE_NONE;
@@ -826,20 +821,18 @@ static int bond_option_updelay_set(struct bonding *bond,
 	int value = newval->value;
 
 	if (!bond->params.miimon) {
-		pr_err("%s: Unable to set up delay as MII monitoring is disabled\n",
-		       bond->dev->name);
+		netdev_err(bond->dev, "Unable to set up delay as MII monitoring is disabled\n");
 		return -EPERM;
 	}
 	if ((value % bond->params.miimon) != 0) {
-		pr_warn("%s: Warning: up delay (%d) is not a multiple of miimon (%d), updelay rounded to %d ms\n",
-			bond->dev->name, value,
-			bond->params.miimon,
-			(value / bond->params.miimon) *
-			bond->params.miimon);
+		netdev_warn(bond->dev, "up delay (%d) is not a multiple of miimon (%d), updelay rounded to %d ms\n",
+			    value, bond->params.miimon,
+			    (value / bond->params.miimon) *
+			    bond->params.miimon);
 	}
 	bond->params.updelay = value / bond->params.miimon;
-	pr_info("%s: Setting up delay to %d\n",
-		bond->dev->name, bond->params.updelay * bond->params.miimon);
+	netdev_info(bond->dev, "Setting up delay to %d\n",
+		    bond->params.updelay * bond->params.miimon);
 
 	return 0;
 }
@@ -850,20 +843,18 @@ static int bond_option_downdelay_set(struct bonding *bond,
 	int value = newval->value;
 
 	if (!bond->params.miimon) {
-		pr_err("%s: Unable to set down delay as MII monitoring is disabled\n",
-		       bond->dev->name);
+		netdev_err(bond->dev, "Unable to set down delay as MII monitoring is disabled\n");
 		return -EPERM;
 	}
 	if ((value % bond->params.miimon) != 0) {
-		pr_warn("%s: Warning: down delay (%d) is not a multiple of miimon (%d), delay rounded to %d ms\n",
-			bond->dev->name, value,
-			bond->params.miimon,
-			(value / bond->params.miimon) *
-			bond->params.miimon);
+		netdev_warn(bond->dev, "down delay (%d) is not a multiple of miimon (%d), delay rounded to %d ms\n",
+			    value, bond->params.miimon,
+			    (value / bond->params.miimon) *
+			    bond->params.miimon);
 	}
 	bond->params.downdelay = value / bond->params.miimon;
-	pr_info("%s: Setting down delay to %d\n",
-		bond->dev->name, bond->params.downdelay * bond->params.miimon);
+	netdev_info(bond->dev, "Setting down delay to %d\n",
+		    bond->params.downdelay * bond->params.miimon);
 
 	return 0;
 }
@@ -871,8 +862,8 @@ static int bond_option_downdelay_set(struct bonding *bond,
 static int bond_option_use_carrier_set(struct bonding *bond,
 				       const struct bond_opt_value *newval)
 {
-	pr_info("%s: Setting use_carrier to %llu\n",
-		bond->dev->name, newval->value);
+	netdev_info(bond->dev, "Setting use_carrier to %llu\n",
+		    newval->value);
 	bond->params.use_carrier = newval->value;
 
 	return 0;
@@ -885,18 +876,16 @@ static int bond_option_use_carrier_set(struct bonding *bond,
 static int bond_option_arp_interval_set(struct bonding *bond,
 					const struct bond_opt_value *newval)
 {
-	pr_info("%s: Setting ARP monitoring interval to %llu\n",
-		bond->dev->name, newval->value);
+	netdev_info(bond->dev, "Setting ARP monitoring interval to %llu\n",
+		    newval->value);
 	bond->params.arp_interval = newval->value;
 	if (newval->value) {
 		if (bond->params.miimon) {
-			pr_info("%s: ARP monitoring cannot be used with MII monitoring. %s Disabling MII monitoring\n",
-				bond->dev->name, bond->dev->name);
+			netdev_info(bond->dev, "ARP monitoring cannot be used with MII monitoring. Disabling MII monitoring\n");
 			bond->params.miimon = 0;
 		}
 		if (!bond->params.arp_targets[0])
-			pr_info("%s: ARP monitoring has been set up, but no ARP targets have been specified\n",
-				bond->dev->name);
+			netdev_info(bond->dev, "ARP monitoring has been set up, but no ARP targets have been specified\n");
 	}
 	if (bond->dev->flags & IFF_UP) {
 		/* If the interface is up, we may need to fire off
@@ -940,24 +929,24 @@ static int _bond_option_arp_ip_target_add(struct bonding *bond, __be32 target)
 	int ind;
 
 	if (!bond_is_ip_target_ok(target)) {
-		pr_err("%s: invalid ARP target %pI4 specified for addition\n",
-		       bond->dev->name, &target);
+		netdev_err(bond->dev, "invalid ARP target %pI4 specified for addition\n",
+			   &target);
 		return -EINVAL;
 	}
 
 	if (bond_get_targets_ip(targets, target) != -1) { /* dup */
-		pr_err("%s: ARP target %pI4 is already present\n",
-		       bond->dev->name, &target);
+		netdev_err(bond->dev, "ARP target %pI4 is already present\n",
+			   &target);
 		return -EINVAL;
 	}
 
 	ind = bond_get_targets_ip(targets, 0); /* first free slot */
 	if (ind == -1) {
-		pr_err("%s: ARP target table is full!\n", bond->dev->name);
+		netdev_err(bond->dev, "ARP target table is full!\n");
 		return -EINVAL;
 	}
 
-	pr_info("%s: Adding ARP target %pI4\n", bond->dev->name, &target);
+	netdev_info(bond->dev, "Adding ARP target %pI4\n", &target);
 
 	_bond_options_arp_ip_target_set(bond, ind, target, jiffies);
 
@@ -985,23 +974,22 @@ static int bond_option_arp_ip_target_rem(struct bonding *bond, __be32 target)
 	int ind, i;
 
 	if (!bond_is_ip_target_ok(target)) {
-		pr_err("%s: invalid ARP target %pI4 specified for removal\n",
-		       bond->dev->name, &target);
+		netdev_err(bond->dev, "invalid ARP target %pI4 specified for removal\n",
+			   &target);
 		return -EINVAL;
 	}
 
 	ind = bond_get_targets_ip(targets, target);
 	if (ind == -1) {
-		pr_err("%s: unable to remove nonexistent ARP target %pI4\n",
-		       bond->dev->name, &target);
+		netdev_err(bond->dev, "unable to remove nonexistent ARP target %pI4\n",
+			   &target);
 		return -EINVAL;
 	}
 
 	if (ind == 0 && !targets[1] && bond->params.arp_interval)
-		pr_warn("%s: Removing last arp target with arp_interval on\n",
-			bond->dev->name);
+		netdev_warn(bond->dev, "Removing last arp target with arp_interval on\n");
 
-	pr_info("%s: Removing ARP target %pI4\n", bond->dev->name, &target);
+	netdev_info(bond->dev, "Removing ARP target %pI4\n", &target);
 
 	/* not to race with bond_arp_rcv */
 	write_lock_bh(&bond->lock);
@@ -1040,8 +1028,8 @@ static int bond_option_arp_ip_targets_set(struct bonding *bond,
 
 	if (newval->string) {
 		if (!in4_pton(newval->string+1, -1, (u8 *)&target, -1, NULL)) {
-			pr_err("%s: invalid ARP target %pI4 specified\n",
-			       bond->dev->name, &target);
+			netdev_err(bond->dev, "invalid ARP target %pI4 specified\n",
+				   &target);
 			return ret;
 		}
 		if (newval->string[0] == '+')
@@ -1049,8 +1037,7 @@ static int bond_option_arp_ip_targets_set(struct bonding *bond,
 		else if (newval->string[0] == '-')
 			ret = bond_option_arp_ip_target_rem(bond, target);
 		else
-			pr_err("no command found in arp_ip_targets file for bond %s - use +<addr> or -<addr>\n",
-			       bond->dev->name);
+			netdev_err(bond->dev, "no command found in arp_ip_targets file - use +<addr> or -<addr>\n");
 	} else {
 		target = newval->value;
 		ret = bond_option_arp_ip_target_add(bond, target);
@@ -1062,8 +1049,8 @@ static int bond_option_arp_ip_targets_set(struct bonding *bond,
 static int bond_option_arp_validate_set(struct bonding *bond,
 					const struct bond_opt_value *newval)
 {
-	pr_info("%s: Setting arp_validate to %s (%llu)\n",
-		bond->dev->name, newval->string, newval->value);
+	netdev_info(bond->dev, "Setting arp_validate to %s (%llu)\n",
+		    newval->string, newval->value);
 
 	if (bond->dev->flags & IFF_UP) {
 		if (!newval->value)
@@ -1079,8 +1066,8 @@ static int bond_option_arp_validate_set(struct bonding *bond,
 static int bond_option_arp_all_targets_set(struct bonding *bond,
 					   const struct bond_opt_value *newval)
 {
-	pr_info("%s: Setting arp_all_targets to %s (%llu)\n",
-		bond->dev->name, newval->string, newval->value);
+	netdev_info(bond->dev, "Setting arp_all_targets to %s (%llu)\n",
+		    newval->string, newval->value);
 	bond->params.arp_all_targets = newval->value;
 
 	return 0;
@@ -1102,7 +1089,7 @@ static int bond_option_primary_set(struct bonding *bond,
 		*p = '\0';
 	/* check to see if we are clearing primary */
 	if (!strlen(primary)) {
-		pr_info("%s: Setting primary slave to None\n", bond->dev->name);
+		netdev_info(bond->dev, "Setting primary slave to None\n");
 		bond->primary_slave = NULL;
 		memset(bond->params.primary, 0, sizeof(bond->params.primary));
 		bond_select_active_slave(bond);
@@ -1111,8 +1098,8 @@ static int bond_option_primary_set(struct bonding *bond,
 
 	bond_for_each_slave(bond, slave, iter) {
 		if (strncmp(slave->dev->name, primary, IFNAMSIZ) == 0) {
-			pr_info("%s: Setting %s as primary slave\n",
-				bond->dev->name, slave->dev->name);
+			netdev_info(bond->dev, "Setting %s as primary slave\n",
+				    slave->dev->name);
 			bond->primary_slave = slave;
 			strcpy(bond->params.primary, slave->dev->name);
 			bond_select_active_slave(bond);
@@ -1121,15 +1108,15 @@ static int bond_option_primary_set(struct bonding *bond,
 	}
 
 	if (bond->primary_slave) {
-		pr_info("%s: Setting primary slave to None\n", bond->dev->name);
+		netdev_info(bond->dev, "Setting primary slave to None\n");
 		bond->primary_slave = NULL;
 		bond_select_active_slave(bond);
 	}
 	strncpy(bond->params.primary, primary, IFNAMSIZ);
 	bond->params.primary[IFNAMSIZ - 1] = 0;
 
-	pr_info("%s: Recording %s as primary, but it has not been enslaved to %s yet\n",
-		bond->dev->name, primary, bond->dev->name);
+	netdev_info(bond->dev, "Recording %s as primary, but it has not been enslaved to %s yet\n",
+		    primary, bond->dev->name);
 
 out:
 	write_unlock_bh(&bond->curr_slave_lock);
@@ -1142,8 +1129,8 @@ static int bond_option_primary_set(struct bonding *bond,
 static int bond_option_primary_reselect_set(struct bonding *bond,
 					    const struct bond_opt_value *newval)
 {
-	pr_info("%s: Setting primary_reselect to %s (%llu)\n",
-		bond->dev->name, newval->string, newval->value);
+	netdev_info(bond->dev, "Setting primary_reselect to %s (%llu)\n",
+		    newval->string, newval->value);
 	bond->params.primary_reselect = newval->value;
 
 	block_netpoll_tx();
@@ -1158,8 +1145,8 @@ static int bond_option_primary_reselect_set(struct bonding *bond,
 static int bond_option_fail_over_mac_set(struct bonding *bond,
 					 const struct bond_opt_value *newval)
 {
-	pr_info("%s: Setting fail_over_mac to %s (%llu)\n",
-		bond->dev->name, newval->string, newval->value);
+	netdev_info(bond->dev, "Setting fail_over_mac to %s (%llu)\n",
+		    newval->string, newval->value);
 	bond->params.fail_over_mac = newval->value;
 
 	return 0;
@@ -1168,8 +1155,8 @@ static int bond_option_fail_over_mac_set(struct bonding *bond,
 static int bond_option_xmit_hash_policy_set(struct bonding *bond,
 					    const struct bond_opt_value *newval)
 {
-	pr_info("%s: Setting xmit hash policy to %s (%llu)\n",
-		bond->dev->name, newval->string, newval->value);
+	netdev_info(bond->dev, "Setting xmit hash policy to %s (%llu)\n",
+		    newval->string, newval->value);
 	bond->params.xmit_policy = newval->value;
 
 	return 0;
@@ -1178,8 +1165,8 @@ static int bond_option_xmit_hash_policy_set(struct bonding *bond,
 static int bond_option_resend_igmp_set(struct bonding *bond,
 				       const struct bond_opt_value *newval)
 {
-	pr_info("%s: Setting resend_igmp to %llu\n",
-		bond->dev->name, newval->value);
+	netdev_info(bond->dev, "Setting resend_igmp to %llu\n",
+		    newval->value);
 	bond->params.resend_igmp = newval->value;
 
 	return 0;
@@ -1217,8 +1204,8 @@ static int bond_option_all_slaves_active_set(struct bonding *bond,
 static int bond_option_min_links_set(struct bonding *bond,
 				     const struct bond_opt_value *newval)
 {
-	pr_info("%s: Setting min links value to %llu\n",
-		bond->dev->name, newval->value);
+	netdev_info(bond->dev, "Setting min links value to %llu\n",
+		    newval->value);
 	bond->params.min_links = newval->value;
 
 	return 0;
@@ -1253,8 +1240,8 @@ static int bond_option_pps_set(struct bonding *bond,
 static int bond_option_lacp_rate_set(struct bonding *bond,
 				     const struct bond_opt_value *newval)
 {
-	pr_info("%s: Setting LACP rate to %s (%llu)\n",
-		bond->dev->name, newval->string, newval->value);
+	netdev_info(bond->dev, "Setting LACP rate to %s (%llu)\n",
+		    newval->string, newval->value);
 	bond->params.lacp_fast = newval->value;
 	bond_3ad_update_lacp_rate(bond);
 
@@ -1264,8 +1251,8 @@ static int bond_option_lacp_rate_set(struct bonding *bond,
 static int bond_option_ad_select_set(struct bonding *bond,
 				     const struct bond_opt_value *newval)
 {
-	pr_info("%s: Setting ad_select to %s (%llu)\n",
-		bond->dev->name, newval->string, newval->value);
+	netdev_info(bond->dev, "Setting ad_select to %s (%llu)\n",
+		    newval->string, newval->value);
 	bond->params.ad_select = newval->value;
 
 	return 0;
@@ -1326,7 +1313,7 @@ static int bond_option_queue_id_set(struct bonding *bond,
 	return ret;
 
 err_no_cmd:
-	pr_info("invalid input for queue_id set for %s\n", bond->dev->name);
+	netdev_info(bond->dev, "invalid input for queue_id set\n");
 	ret = -EPERM;
 	goto out;
 
@@ -1348,20 +1335,20 @@ static int bond_option_slaves_set(struct bonding *bond,
 
 	dev = __dev_get_by_name(dev_net(bond->dev), ifname);
 	if (!dev) {
-		pr_info("%s: interface %s does not exist!\n",
-			bond->dev->name, ifname);
+		netdev_info(bond->dev, "interface %s does not exist!\n",
+			    ifname);
 		ret = -ENODEV;
 		goto out;
 	}
 
 	switch (command[0]) {
 	case '+':
-		pr_info("%s: Adding slave %s\n", bond->dev->name, dev->name);
+		netdev_info(bond->dev, "Adding slave %s\n", dev->name);
 		ret = bond_enslave(bond->dev, dev);
 		break;
 
 	case '-':
-		pr_info("%s: Removing slave %s\n", bond->dev->name, dev->name);
+		netdev_info(bond->dev, "Removing slave %s\n", dev->name);
 		ret = bond_release(bond->dev, dev);
 		break;
 
@@ -1373,8 +1360,7 @@ static int bond_option_slaves_set(struct bonding *bond,
 	return ret;
 
 err_no_cmd:
-	pr_err("no command found in slaves file for bond %s - use +ifname or -ifname\n",
-	       bond->dev->name);
+	netdev_err(bond->dev, "no command found in slaves file - use +ifname or -ifname\n");
 	ret = -EPERM;
 	goto out;
 }
@@ -1382,8 +1368,8 @@ static int bond_option_slaves_set(struct bonding *bond,
 static int bond_option_tlb_dynamic_lb_set(struct bonding *bond,
 					  const struct bond_opt_value *newval)
 {
-	pr_info("%s: Setting dynamic-lb to %s (%llu)\n",
-		bond->dev->name, newval->string, newval->value);
+	netdev_info(bond->dev, "Setting dynamic-lb to %s (%llu)\n",
+		    newval->string, newval->value);
 	bond->params.tlb_dynamic_lb = newval->value;
 
 	return 0;

commit ff11d8b27dcd85e7b96ac2570116d5061130bd5e
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Tue Jul 15 16:08:57 2014 +0200

    bonding: fix bond_option_mode_set warning
    
    During the conversion to "static" functions this one got left out, only its
    prototype was converted, thus resulting in:
    drivers/net/bonding//bond_options.c:674:5: warning: symbol
    'bond_option_mode_set' was not declared. Should it be static?
    
    Fix it by making it static and also break the line in two as it was too
    long.
    
    CC: Stephen Hemminger <stephen@networkplumber.org>
    CC: Jay Vosburgh <j.vosburgh@gmail.com>
    CC: Veaceslav Falico <vfalico@gmail.com>
    CC: Andy Gospodarek <andy@greyhouse.net>
    CC: David S. Miller <davem@davemloft.net>
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index f908e65e86c1..cf720ce1b69e 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -671,7 +671,8 @@ const struct bond_option *bond_opt_get(unsigned int option)
 	return &bond_opts[option];
 }
 
-int bond_option_mode_set(struct bonding *bond, const struct bond_opt_value *newval)
+static int bond_option_mode_set(struct bonding *bond,
+				const struct bond_opt_value *newval)
 {
 	if (!bond_mode_uses_arp(newval->value) && bond->params.arp_interval) {
 		pr_info("%s: %s mode is incompatible with arp monitoring, start mii monitoring\n",

commit 4740d6382790077f22c606d03804f5d9f15b90d7
Author: Eric Dumazet <edumazet@google.com>
Date:   Tue Jul 15 06:56:55 2014 -0700

    bonding: add proper __rcu annotation for curr_active_slave
    
    RCU was added to bonding in linux-3.12 but lacked proper sparse annotations.
    
    Using __rcu annotation actually helps to spot all accesses to bond->curr_active_slave
    are correctly protected, with LOCKDEP support.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Acked-by: Veaceslav Falico <vfalico@gmail.com>
    Reviewed-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index b26271fd7b09..f908e65e86c1 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -743,7 +743,7 @@ static int bond_option_active_slave_set(struct bonding *bond,
 		RCU_INIT_POINTER(bond->curr_active_slave, NULL);
 		bond_select_active_slave(bond);
 	} else {
-		struct slave *old_active = bond->curr_active_slave;
+		struct slave *old_active = bond_deref_active_protected(bond);
 		struct slave *new_active = bond_slave_get_rtnl(slave_dev);
 
 		BUG_ON(!new_active);

commit e965f8049460569bab12fe7bb5381bb2279712e2
Author: Eric Dumazet <edumazet@google.com>
Date:   Tue Jul 15 06:56:53 2014 -0700

    bonding: get rid of bond_option_active_slave_get()
    
    Only keep bond_option_active_slave_get_rcu() helper.
    
    bond_fill_info() uses a new bond_option_active_slave_get_ifindex()
    helper.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Acked-by: Veaceslav Falico <vfalico@gmail.com>
    Reviewed-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 540e0167bf24..b26271fd7b09 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -704,11 +704,6 @@ struct net_device *bond_option_active_slave_get_rcu(struct bonding *bond)
 	return __bond_option_active_slave_get(bond, slave);
 }
 
-struct net_device *bond_option_active_slave_get(struct bonding *bond)
-{
-	return __bond_option_active_slave_get(bond, bond->curr_active_slave);
-}
-
 static int bond_option_active_slave_set(struct bonding *bond,
 					const struct bond_opt_value *newval)
 {

commit 54e5c4def0614ab540fbdf68e45342a4af141702
Merge: be65de717412 1ee1ceafb572
Author: David S. Miller <davem@davemloft.net>
Date:   Sat May 24 00:32:30 2014 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts:
            drivers/net/bonding/bond_alb.c
            drivers/net/ethernet/altera/altera_msgdma.c
            drivers/net/ethernet/altera/altera_sgdma.c
            net/ipv6/xfrm6_output.c
    
    Several cases of overlapping changes.
    
    The xfrm6_output.c has a bug fix which overlaps the renaming
    of skb->local_df to skb->ignore_df.
    
    In the Altera TSE driver cases, the register access cleanups
    in net-next overlapped with bug fixes done in net.
    
    Similarly a bug fix to send ALB packets in the bonding driver using
    the right source address overlaps with cleanups in net-next.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit b6adc610f183061bd607d965857870e618d229a6
Author: Veaceslav Falico <vfalico@gmail.com>
Date:   Thu May 15 21:39:57 2014 +0200

    bonding: convert IS_UP(slave->dev) to inline function
    
    Also, remove the IFF_UP verification cause we can't be netif_running() with
    being also IFF_UP.
    
    CC: Jay Vosburgh <j.vosburgh@gmail.com>
    CC: Andy Gospodarek <andy@greyhouse.net>
    Signed-off-by: Veaceslav Falico <vfalico@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 0cf4c1a9bb7b..94094b3d5a3e 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -758,7 +758,7 @@ static int bond_option_active_slave_set(struct bonding *bond,
 				bond->dev->name, new_active->dev->name);
 		} else {
 			if (old_active && (new_active->link == BOND_LINK_UP) &&
-			    IS_UP(new_active->dev)) {
+			    bond_slave_is_up(new_active)) {
 				pr_info("%s: Setting %s as active slave\n",
 					bond->dev->name, new_active->dev->name);
 				bond_change_active_slave(bond, new_active);

commit 2807a9feb2393648f4db114fdf3fa99860ff6a36
Author: Veaceslav Falico <vfalico@gmail.com>
Date:   Thu May 15 21:39:56 2014 +0200

    bonding: make IS_IP_TARGET_UNUSABLE_ADDRESS an inline function
    
    Also, use standard IP primitives to check the address.
    
    CC: Jay Vosburgh <j.vosburgh@gmail.com>
    CC: Andy Gospodarek <andy@greyhouse.net>
    Signed-off-by: Veaceslav Falico <vfalico@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index dd7292fa4665..0cf4c1a9bb7b 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -942,7 +942,7 @@ static int _bond_option_arp_ip_target_add(struct bonding *bond, __be32 target)
 	__be32 *targets = bond->params.arp_targets;
 	int ind;
 
-	if (IS_IP_TARGET_UNUSABLE_ADDRESS(target)) {
+	if (!bond_is_ip_target_ok(target)) {
 		pr_err("%s: invalid ARP target %pI4 specified for addition\n",
 		       bond->dev->name, &target);
 		return -EINVAL;
@@ -987,7 +987,7 @@ static int bond_option_arp_ip_target_rem(struct bonding *bond, __be32 target)
 	unsigned long *targets_rx;
 	int ind, i;
 
-	if (IS_IP_TARGET_UNUSABLE_ADDRESS(target)) {
+	if (!bond_is_ip_target_ok(target)) {
 		pr_err("%s: invalid ARP target %pI4 specified for removal\n",
 		       bond->dev->name, &target);
 		return -EINVAL;

commit ec0865a94991d1819d4f99866a2492af8df5c882
Author: Veaceslav Falico <vfalico@gmail.com>
Date:   Thu May 15 21:39:54 2014 +0200

    bonding: make USES_PRIMARY inline functions
    
    Change the name a bit to better reflect its scope, and update some
    comments. Two functions added - one which takes bond as a param and the
    other which takes the mode.
    
    CC: Jay Vosburgh <j.vosburgh@gmail.com>
    CC: Andy Gospodarek <andy@greyhouse.net>
    Signed-off-by: Veaceslav Falico <vfalico@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 98c8801ddb67..dd7292fa4665 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -693,7 +693,7 @@ int bond_option_mode_set(struct bonding *bond, const struct bond_opt_value *newv
 static struct net_device *__bond_option_active_slave_get(struct bonding *bond,
 							 struct slave *slave)
 {
-	return USES_PRIMARY(bond->params.mode) && slave ? slave->dev : NULL;
+	return bond_uses_primary(bond) && slave ? slave->dev : NULL;
 }
 
 struct net_device *bond_option_active_slave_get_rcu(struct bonding *bond)

commit 267bed777a5f8a8f5acd50a9134c7341fc46d822
Author: Veaceslav Falico <vfalico@gmail.com>
Date:   Thu May 15 21:39:53 2014 +0200

    bonding: make BOND_NO_USES_ARP an inline function
    
    Also, change its name to better reflect its scope, and skip the "no"
    part.
    
    CC: Jay Vosburgh <j.vosburgh@gmail.com>
    CC: Andy Gospodarek <andy@greyhouse.net>
    Signed-off-by: Veaceslav Falico <vfalico@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 6dc49da106d6..98c8801ddb67 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -672,7 +672,7 @@ const struct bond_option *bond_opt_get(unsigned int option)
 
 int bond_option_mode_set(struct bonding *bond, const struct bond_opt_value *newval)
 {
-	if (BOND_NO_USES_ARP(newval->value) && bond->params.arp_interval) {
+	if (!bond_mode_uses_arp(newval->value) && bond->params.arp_interval) {
 		pr_info("%s: %s mode is incompatible with arp monitoring, start mii monitoring\n",
 			bond->dev->name, newval->string);
 		/* disable arp monitoring */

commit 81c708068dfedece038e07d818ba68333d8d885d
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Thu May 15 13:35:23 2014 +0200

    bonding: fix out of range parameters for bond_intmax_tbl
    
    I've missed to add a NULL entry to the bond_intmax_tbl when I introduced
    it with the conversion of arp_interval so add it now.
    
    CC: Jay Vosburgh <j.vosburgh@gmail.com>
    CC: Veaceslav Falico <vfalico@gmail.com>
    CC: Andy Gospodarek <andy@greyhouse.net>
    
    Fixes: 7bdb04ed0dbf ("bonding: convert arp_interval to use the new option API")
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Acked-by: Veaceslav Falico <vfalico@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 724e30fa20b9..832070298446 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -125,6 +125,7 @@ static const struct bond_opt_value bond_fail_over_mac_tbl[] = {
 static const struct bond_opt_value bond_intmax_tbl[] = {
 	{ "off",     0,       BOND_VALFLAG_DEFAULT},
 	{ "maxval",  INT_MAX, BOND_VALFLAG_MAX},
+	{ NULL,      -1,      0}
 };
 
 static const struct bond_opt_value bond_lacp_rate_tbl[] = {

commit dc3e5d18f2a21f4523f75800f4062348a7e94d14
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Thu May 8 14:23:54 2014 +0200

    bonding: make a generic sysfs option store and fix comments
    
    Introduce a generic option store function for sysfs and remove the
    specific ones. The attribute name is used to match against the option
    which is to be set.
    Also adjust the "name" of tlb_dynamic_lb option to match the sysfs
    entry and fix the comments and comment style in bond_sysfs.c
    The comments which showed obvious behaviour (i.e. behaviour that's seen
    in the option's entry) are removed, the ones that explained important
    points about the setting function have been moved above the respective
    set function in bond_options.c
    
    There's only 1 exception: num_unsol_na/num_grat_arp since it has 2 names
    
    CC: Jay Vosburgh <j.vosburgh@gmail.com>
    CC: Veaceslav Falico <vfalico@gmail.com>
    CC: Andy Gospodarek <andy@greyhouse.net>
    CC: David S. Miller <davem@davemloft.net>
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 9fba7a1e6d51..6dc49da106d6 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -374,7 +374,7 @@ static const struct bond_option bond_opts[] = {
 	},
 	[BOND_OPT_TLB_DYNAMIC_LB] = {
 		.id = BOND_OPT_TLB_DYNAMIC_LB,
-		.name = "dynamic_lb",
+		.name = "tlb_dynamic_lb",
 		.desc = "Enable dynamic flow shuffling",
 		.unsuppmodes = BOND_MODE_ALL_EX(BIT(BOND_MODE_TLB)),
 		.values = bond_tlb_dynamic_lb_tbl,
@@ -384,6 +384,21 @@ static const struct bond_option bond_opts[] = {
 	{ }
 };
 
+/* Searches for an option by name */
+const struct bond_option *bond_opt_get_by_name(const char *name)
+{
+	const struct bond_option *opt;
+	int option;
+
+	for (option = 0; option < BOND_OPT_LAST; option++) {
+		opt = bond_opt_get(option);
+		if (opt && !strcmp(opt->name, name))
+			return opt;
+	}
+
+	return NULL;
+}
+
 /* Searches for a value in opt's values[] table */
 const struct bond_opt_value *bond_opt_get_val(unsigned int option, u64 val)
 {
@@ -762,6 +777,10 @@ static int bond_option_active_slave_set(struct bonding *bond,
 	return ret;
 }
 
+/* There are two tricky bits here.  First, if MII monitoring is activated, then
+ * we must disable ARP monitoring.  Second, if the timer isn't running, we must
+ * start it.
+ */
 static int bond_option_miimon_set(struct bonding *bond,
 				  const struct bond_opt_value *newval)
 {
@@ -800,6 +819,10 @@ static int bond_option_miimon_set(struct bonding *bond,
 	return 0;
 }
 
+/* Set up and down delays. These must be multiples of the
+ * MII monitoring value, and are stored internally as the multiplier.
+ * Thus, we must translate to MS for the real world.
+ */
 static int bond_option_updelay_set(struct bonding *bond,
 				   const struct bond_opt_value *newval)
 {
@@ -858,6 +881,10 @@ static int bond_option_use_carrier_set(struct bonding *bond,
 	return 0;
 }
 
+/* There are two tricky bits here.  First, if ARP monitoring is activated, then
+ * we must disable MII monitoring.  Second, if the ARP timer isn't running,
+ * we must start it.
+ */
 static int bond_option_arp_interval_set(struct bonding *bond,
 					const struct bond_opt_value *newval)
 {

commit e9f0fb88493570200b8dc1cc02d3e676412d25bc
Author: Mahesh Bandewar <maheshb@google.com>
Date:   Tue Apr 22 16:30:22 2014 -0700

    bonding: Add tlb_dynamic_lb parameter for tlb mode
    
    The aggresive load balancing causes packet re-ordering as active
    flows are moved from a slave to another within the group. Sometime
    this aggresive lb is not necessary if the preference is for less
    re-ordering. This parameter if used with value "0" disables
    this dynamic flow shuffling minimizing packet re-ordering. Of course
    the side effect is that it has to live with the static load balancing
    that the hashing distribution provides. This impact is less severe if
    the correct xmit-hashing-policy is used for the tlb setup.
    
    The default value of the parameter is set to "1" mimicing the earlier
    behavior.
    
    Ran the netperf test with 200 stream for 1 min between two hosts with
    4x1G trunk (xmit-lb mode with xmit-policy L3+4) before and after these
    changes. Following was the command used for those 200 instances -
    
        netperf -t TCP_RR -l 60 -s 5 -H <host> -- -r81920,81920
    
    Transactions per second:
        Before change: 1,367.11
        After  change: 1,470.65
    
    Change-Id: Ie3f75c77282cf602e83a6e833c6eb164e72a0990
    Signed-off-by: Mahesh Bandewar <maheshb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index dc3893841752..9fba7a1e6d51 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -70,6 +70,8 @@ static int bond_option_mode_set(struct bonding *bond,
 				const struct bond_opt_value *newval);
 static int bond_option_slaves_set(struct bonding *bond,
 				  const struct bond_opt_value *newval);
+static int bond_option_tlb_dynamic_lb_set(struct bonding *bond,
+				  const struct bond_opt_value *newval);
 
 
 static const struct bond_opt_value bond_mode_tbl[] = {
@@ -179,6 +181,12 @@ static const struct bond_opt_value bond_lp_interval_tbl[] = {
 	{ NULL,      -1,      0},
 };
 
+static const struct bond_opt_value bond_tlb_dynamic_lb_tbl[] = {
+	{ "off", 0,  0},
+	{ "on",  1,  BOND_VALFLAG_DEFAULT},
+	{ NULL,  -1, 0}
+};
+
 static const struct bond_option bond_opts[] = {
 	[BOND_OPT_MODE] = {
 		.id = BOND_OPT_MODE,
@@ -364,6 +372,15 @@ static const struct bond_option bond_opts[] = {
 		.flags = BOND_OPTFLAG_RAWVAL,
 		.set = bond_option_slaves_set
 	},
+	[BOND_OPT_TLB_DYNAMIC_LB] = {
+		.id = BOND_OPT_TLB_DYNAMIC_LB,
+		.name = "dynamic_lb",
+		.desc = "Enable dynamic flow shuffling",
+		.unsuppmodes = BOND_MODE_ALL_EX(BIT(BOND_MODE_TLB)),
+		.values = bond_tlb_dynamic_lb_tbl,
+		.flags = BOND_OPTFLAG_IFDOWN,
+		.set = bond_option_tlb_dynamic_lb_set,
+	},
 	{ }
 };
 
@@ -1337,3 +1354,13 @@ static int bond_option_slaves_set(struct bonding *bond,
 	ret = -EPERM;
 	goto out;
 }
+
+static int bond_option_tlb_dynamic_lb_set(struct bonding *bond,
+					  const struct bond_opt_value *newval)
+{
+	pr_info("%s: Setting dynamic-lb to %s (%llu)\n",
+		bond->dev->name, newval->string, newval->value);
+	bond->params.tlb_dynamic_lb = newval->value;
+
+	return 0;
+}

commit f05b42eaa22cd7c6736d31316e6046c5127f8721
Author: Mahesh Bandewar <maheshb@google.com>
Date:   Tue Apr 22 16:30:20 2014 -0700

    bonding: Added bond_tlb_xmit() for tlb mode.
    
    Re-organized the xmit function for the lb mode separating tlb xmit
    from the alb mode. This will enable use of the hashing policies
    like 802.3ad mode. Also extended use of xmit-hash-policy to tlb mode.
    
    Now the tlb-mode defaults to BOND_XMIT_POLICY_LAYER2 if the xmit policy
    module parameter is not set (just like 802.3ad, or Xor mode).
    
    Change-Id: I140257403d272df75f477b380207338d0f04963e
    Signed-off-by: Mahesh Bandewar <maheshb@google.com>
    Acked-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 724e30fa20b9..dc3893841752 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -199,7 +199,7 @@ static const struct bond_option bond_opts[] = {
 	[BOND_OPT_XMIT_HASH] = {
 		.id = BOND_OPT_XMIT_HASH,
 		.name = "xmit_hash_policy",
-		.desc = "balance-xor and 802.3ad hashing method",
+		.desc = "balance-xor, 802.3ad, and tlb hashing method",
 		.values = bond_xmit_hashtype_tbl,
 		.set = bond_option_xmit_hash_policy_set
 	},

commit 8800a244fa1ab75192cf65ecf8e3ca3ec1420b1b
Author: Monam Agarwal <monamagarwal123@gmail.com>
Date:   Mon Mar 24 00:00:17 2014 +0530

    drivers/net: Use RCU_INIT_POINTER(x, NULL) in bonding/bond_options.c
    
    This patch replaces rcu_assign_pointer(x, NULL) with RCU_INIT_POINTER(x, NULL)
    
    The rcu_assign_pointer() ensures that the initialization of a structure
    is carried out before storing a pointer to that structure.
    And in the case of the NULL pointer, there is no structure to initialize.
    So, rcu_assign_pointer(p, NULL) can be safely converted to RCU_INIT_POINTER(p, NULL)
    
    Signed-off-by: Monam Agarwal <monamagarwal123@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 6e6b09359ec3..724e30fa20b9 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -712,7 +712,7 @@ static int bond_option_active_slave_set(struct bonding *bond,
 	/* check to see if we are clearing active */
 	if (!slave_dev) {
 		pr_info("%s: Clearing current active slave\n", bond->dev->name);
-		rcu_assign_pointer(bond->curr_active_slave, NULL);
+		RCU_INIT_POINTER(bond->curr_active_slave, NULL);
 		bond_select_active_slave(bond);
 	} else {
 		struct slave *old_active = bond->curr_active_slave;

commit 85dcce7a73f1cc59f7a96fe52713b1630f4ca272
Merge: 4c4e4113db24 a4ecdf82f8ea
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Mar 14 22:31:55 2014 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts:
            drivers/net/usb/r8152.c
            drivers/net/xen-netback/netback.c
    
    Both the r8152 and netback conflicts were simple overlapping
    changes.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 28f084cca35a73698568d8c060bbb98193021db5
Author: stephen hemminger <stephen@networkplumber.org>
Date:   Thu Mar 6 14:20:17 2014 -0800

    bonding: fix const in options processing
    
    This is a fixup patch to resolve issues with const from my earlier patch.
    Make all the setter functions use const on input parameter.
    
    Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index fc6d25e7d053..22800bde9752 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -21,55 +21,55 @@
 #include "bonding.h"
 
 static int bond_option_active_slave_set(struct bonding *bond,
-					struct bond_opt_value *newval);
+					const struct bond_opt_value *newval);
 static int bond_option_miimon_set(struct bonding *bond,
-				  struct bond_opt_value *newval);
+				  const struct bond_opt_value *newval);
 static int bond_option_updelay_set(struct bonding *bond,
-				   struct bond_opt_value *newval);
+				   const struct bond_opt_value *newval);
 static int bond_option_downdelay_set(struct bonding *bond,
-				     struct bond_opt_value *newval);
+				     const struct bond_opt_value *newval);
 static int bond_option_use_carrier_set(struct bonding *bond,
-				       struct bond_opt_value *newval);
+				       const struct bond_opt_value *newval);
 static int bond_option_arp_interval_set(struct bonding *bond,
-					struct bond_opt_value *newval);
+					const struct bond_opt_value *newval);
 static int bond_option_arp_ip_target_add(struct bonding *bond, __be32 target);
 static int bond_option_arp_ip_target_rem(struct bonding *bond, __be32 target);
 static int bond_option_arp_ip_targets_set(struct bonding *bond,
-					  struct bond_opt_value *newval);
+					  const struct bond_opt_value *newval);
 static int bond_option_arp_validate_set(struct bonding *bond,
-					struct bond_opt_value *newval);
+					const struct bond_opt_value *newval);
 static int bond_option_arp_all_targets_set(struct bonding *bond,
-					   struct bond_opt_value *newval);
+					   const struct bond_opt_value *newval);
 static int bond_option_primary_set(struct bonding *bond,
-				   struct bond_opt_value *newval);
+				   const struct bond_opt_value *newval);
 static int bond_option_primary_reselect_set(struct bonding *bond,
-					    struct bond_opt_value *newval);
+					    const struct bond_opt_value *newval);
 static int bond_option_fail_over_mac_set(struct bonding *bond,
-					 struct bond_opt_value *newval);
+					 const struct bond_opt_value *newval);
 static int bond_option_xmit_hash_policy_set(struct bonding *bond,
-					    struct bond_opt_value *newval);
+					    const struct bond_opt_value *newval);
 static int bond_option_resend_igmp_set(struct bonding *bond,
-				       struct bond_opt_value *newval);
+				       const struct bond_opt_value *newval);
 static int bond_option_num_peer_notif_set(struct bonding *bond,
-					  struct bond_opt_value *newval);
+					  const struct bond_opt_value *newval);
 static int bond_option_all_slaves_active_set(struct bonding *bond,
-					     struct bond_opt_value *newval);
+					     const struct bond_opt_value *newval);
 static int bond_option_min_links_set(struct bonding *bond,
-				     struct bond_opt_value *newval);
+				     const struct bond_opt_value *newval);
 static int bond_option_lp_interval_set(struct bonding *bond,
-				       struct bond_opt_value *newval);
+				       const struct bond_opt_value *newval);
 static int bond_option_pps_set(struct bonding *bond,
-			       struct bond_opt_value *newval);
+			       const struct bond_opt_value *newval);
 static int bond_option_lacp_rate_set(struct bonding *bond,
-				     struct bond_opt_value *newval);
+				     const struct bond_opt_value *newval);
 static int bond_option_ad_select_set(struct bonding *bond,
-				     struct bond_opt_value *newval);
+				     const struct bond_opt_value *newval);
 static int bond_option_queue_id_set(struct bonding *bond,
-				    struct bond_opt_value *newval);
+				    const struct bond_opt_value *newval);
 static int bond_option_mode_set(struct bonding *bond,
-				struct bond_opt_value *newval);
+				const struct bond_opt_value *newval);
 static int bond_option_slaves_set(struct bonding *bond,
-				  struct bond_opt_value *newval);
+				  const struct bond_opt_value *newval);
 
 
 static const struct bond_opt_value bond_mode_tbl[] = {
@@ -504,7 +504,7 @@ static int bond_opt_check_deps(struct bonding *bond,
 static void bond_opt_dep_print(struct bonding *bond,
 			       const struct bond_option *opt)
 {
-	struct bond_opt_value *modeval;
+	const struct bond_opt_value *modeval;
 	struct bond_params *params;
 
 	params = &bond->params;
@@ -517,9 +517,9 @@ static void bond_opt_dep_print(struct bonding *bond,
 
 static void bond_opt_error_interpret(struct bonding *bond,
 				     const struct bond_option *opt,
-				     int error, struct bond_opt_value *val)
+				     int error, const struct bond_opt_value *val)
 {
-	struct bond_opt_value *minval, *maxval;
+	const struct bond_opt_value *minval, *maxval;
 	char *p;
 
 	switch (error) {
@@ -574,7 +574,7 @@ static void bond_opt_error_interpret(struct bonding *bond,
 int __bond_opt_set(struct bonding *bond,
 		   unsigned int option, struct bond_opt_value *val)
 {
-	struct bond_opt_value *retval = NULL;
+	const struct bond_opt_value *retval = NULL;
 	const struct bond_option *opt;
 	int ret = -ENOENT;
 
@@ -637,7 +637,7 @@ const struct bond_option *bond_opt_get(unsigned int option)
 	return &bond_opts[option];
 }
 
-int bond_option_mode_set(struct bonding *bond, struct bond_opt_value *newval)
+int bond_option_mode_set(struct bonding *bond, const struct bond_opt_value *newval)
 {
 	if (BOND_NO_USES_ARP(newval->value) && bond->params.arp_interval) {
 		pr_info("%s: %s mode is incompatible with arp monitoring, start mii monitoring\n",
@@ -676,7 +676,7 @@ struct net_device *bond_option_active_slave_get(struct bonding *bond)
 }
 
 static int bond_option_active_slave_set(struct bonding *bond,
-					struct bond_opt_value *newval)
+					const struct bond_opt_value *newval)
 {
 	char ifname[IFNAMSIZ] = { 0, };
 	struct net_device *slave_dev;
@@ -745,7 +745,7 @@ static int bond_option_active_slave_set(struct bonding *bond,
 }
 
 static int bond_option_miimon_set(struct bonding *bond,
-				  struct bond_opt_value *newval)
+				  const struct bond_opt_value *newval)
 {
 	pr_info("%s: Setting MII monitoring interval to %llu\n",
 		bond->dev->name, newval->value);
@@ -783,7 +783,7 @@ static int bond_option_miimon_set(struct bonding *bond,
 }
 
 static int bond_option_updelay_set(struct bonding *bond,
-				   struct bond_opt_value *newval)
+				   const struct bond_opt_value *newval)
 {
 	int value = newval->value;
 
@@ -807,7 +807,7 @@ static int bond_option_updelay_set(struct bonding *bond,
 }
 
 static int bond_option_downdelay_set(struct bonding *bond,
-				     struct bond_opt_value *newval)
+				     const struct bond_opt_value *newval)
 {
 	int value = newval->value;
 
@@ -831,7 +831,7 @@ static int bond_option_downdelay_set(struct bonding *bond,
 }
 
 static int bond_option_use_carrier_set(struct bonding *bond,
-				       struct bond_opt_value *newval)
+				       const struct bond_opt_value *newval)
 {
 	pr_info("%s: Setting use_carrier to %llu\n",
 		bond->dev->name, newval->value);
@@ -841,7 +841,7 @@ static int bond_option_use_carrier_set(struct bonding *bond,
 }
 
 static int bond_option_arp_interval_set(struct bonding *bond,
-					struct bond_opt_value *newval)
+					const struct bond_opt_value *newval)
 {
 	pr_info("%s: Setting ARP monitoring interval to %llu\n",
 		bond->dev->name, newval->value);
@@ -991,7 +991,7 @@ void bond_option_arp_ip_targets_clear(struct bonding *bond)
 }
 
 static int bond_option_arp_ip_targets_set(struct bonding *bond,
-					  struct bond_opt_value *newval)
+					  const struct bond_opt_value *newval)
 {
 	int ret = -EPERM;
 	__be32 target;
@@ -1018,7 +1018,7 @@ static int bond_option_arp_ip_targets_set(struct bonding *bond,
 }
 
 static int bond_option_arp_validate_set(struct bonding *bond,
-					struct bond_opt_value *newval)
+					const struct bond_opt_value *newval)
 {
 	pr_info("%s: Setting arp_validate to %s (%llu)\n",
 		bond->dev->name, newval->string, newval->value);
@@ -1035,7 +1035,7 @@ static int bond_option_arp_validate_set(struct bonding *bond,
 }
 
 static int bond_option_arp_all_targets_set(struct bonding *bond,
-					   struct bond_opt_value *newval)
+					   const struct bond_opt_value *newval)
 {
 	pr_info("%s: Setting arp_all_targets to %s (%llu)\n",
 		bond->dev->name, newval->string, newval->value);
@@ -1045,7 +1045,7 @@ static int bond_option_arp_all_targets_set(struct bonding *bond,
 }
 
 static int bond_option_primary_set(struct bonding *bond,
-				   struct bond_opt_value *newval)
+				   const struct bond_opt_value *newval)
 {
 	char *p, *primary = newval->string;
 	struct list_head *iter;
@@ -1098,7 +1098,7 @@ static int bond_option_primary_set(struct bonding *bond,
 }
 
 static int bond_option_primary_reselect_set(struct bonding *bond,
-					    struct bond_opt_value *newval)
+					    const struct bond_opt_value *newval)
 {
 	pr_info("%s: Setting primary_reselect to %s (%llu)\n",
 		bond->dev->name, newval->string, newval->value);
@@ -1114,7 +1114,7 @@ static int bond_option_primary_reselect_set(struct bonding *bond,
 }
 
 static int bond_option_fail_over_mac_set(struct bonding *bond,
-					 struct bond_opt_value *newval)
+					 const struct bond_opt_value *newval)
 {
 	pr_info("%s: Setting fail_over_mac to %s (%llu)\n",
 		bond->dev->name, newval->string, newval->value);
@@ -1124,7 +1124,7 @@ static int bond_option_fail_over_mac_set(struct bonding *bond,
 }
 
 static int bond_option_xmit_hash_policy_set(struct bonding *bond,
-					    struct bond_opt_value *newval)
+					    const struct bond_opt_value *newval)
 {
 	pr_info("%s: Setting xmit hash policy to %s (%llu)\n",
 		bond->dev->name, newval->string, newval->value);
@@ -1134,7 +1134,7 @@ static int bond_option_xmit_hash_policy_set(struct bonding *bond,
 }
 
 static int bond_option_resend_igmp_set(struct bonding *bond,
-				       struct bond_opt_value *newval)
+				       const struct bond_opt_value *newval)
 {
 	pr_info("%s: Setting resend_igmp to %llu\n",
 		bond->dev->name, newval->value);
@@ -1144,7 +1144,7 @@ static int bond_option_resend_igmp_set(struct bonding *bond,
 }
 
 static int bond_option_num_peer_notif_set(struct bonding *bond,
-				   struct bond_opt_value *newval)
+				   const struct bond_opt_value *newval)
 {
 	bond->params.num_peer_notif = newval->value;
 
@@ -1152,7 +1152,7 @@ static int bond_option_num_peer_notif_set(struct bonding *bond,
 }
 
 static int bond_option_all_slaves_active_set(struct bonding *bond,
-					     struct bond_opt_value *newval)
+					     const struct bond_opt_value *newval)
 {
 	struct list_head *iter;
 	struct slave *slave;
@@ -1173,7 +1173,7 @@ static int bond_option_all_slaves_active_set(struct bonding *bond,
 }
 
 static int bond_option_min_links_set(struct bonding *bond,
-				     struct bond_opt_value *newval)
+				     const struct bond_opt_value *newval)
 {
 	pr_info("%s: Setting min links value to %llu\n",
 		bond->dev->name, newval->value);
@@ -1183,7 +1183,7 @@ static int bond_option_min_links_set(struct bonding *bond,
 }
 
 static int bond_option_lp_interval_set(struct bonding *bond,
-				       struct bond_opt_value *newval)
+				       const struct bond_opt_value *newval)
 {
 	bond->params.lp_interval = newval->value;
 
@@ -1191,7 +1191,7 @@ static int bond_option_lp_interval_set(struct bonding *bond,
 }
 
 static int bond_option_pps_set(struct bonding *bond,
-			       struct bond_opt_value *newval)
+			       const struct bond_opt_value *newval)
 {
 	bond->params.packets_per_slave = newval->value;
 	if (newval->value > 0) {
@@ -1209,7 +1209,7 @@ static int bond_option_pps_set(struct bonding *bond,
 }
 
 static int bond_option_lacp_rate_set(struct bonding *bond,
-				     struct bond_opt_value *newval)
+				     const struct bond_opt_value *newval)
 {
 	pr_info("%s: Setting LACP rate to %s (%llu)\n",
 		bond->dev->name, newval->string, newval->value);
@@ -1220,7 +1220,7 @@ static int bond_option_lacp_rate_set(struct bonding *bond,
 }
 
 static int bond_option_ad_select_set(struct bonding *bond,
-				     struct bond_opt_value *newval)
+				     const struct bond_opt_value *newval)
 {
 	pr_info("%s: Setting ad_select to %s (%llu)\n",
 		bond->dev->name, newval->string, newval->value);
@@ -1230,7 +1230,7 @@ static int bond_option_ad_select_set(struct bonding *bond,
 }
 
 static int bond_option_queue_id_set(struct bonding *bond,
-				    struct bond_opt_value *newval)
+				    const struct bond_opt_value *newval)
 {
 	struct slave *slave, *update_slave;
 	struct net_device *sdev;
@@ -1291,7 +1291,7 @@ static int bond_option_queue_id_set(struct bonding *bond,
 }
 
 static int bond_option_slaves_set(struct bonding *bond,
-				  struct bond_opt_value *newval)
+				  const struct bond_opt_value *newval)
 {
 	char command[IFNAMSIZ + 1] = { 0, };
 	struct net_device *dev;

commit 5bd4e4c158ceb4e76ce9ed005c876d59caad8af2
Author: Sasha Levin <sasha.levin@oracle.com>
Date:   Thu Mar 6 16:53:11 2014 -0500

    bonding: correctly handle out of range parameters for lp_interval
    
    We didn't correctly check cases where the value for lp_interval is not
    within the legal range due to a missing table terminator.
    
    This would let userspace trigger a kernel panic by specifying a value out
    of range:
    
            echo -1 > /sys/devices/virtual/net/bond0/bonding/lp_interval
    
    Introduced by commit 4325b374f84 ("bonding: convert lp_interval to use
    the new option API").
    
    Acked-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index c37878432717..298c26509095 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -121,6 +121,7 @@ static struct bond_opt_value bond_resend_igmp_tbl[] = {
 static struct bond_opt_value bond_lp_interval_tbl[] = {
 	{ "minval",  1,       BOND_VALFLAG_MIN | BOND_VALFLAG_DEFAULT},
 	{ "maxval",  INT_MAX, BOND_VALFLAG_MAX},
+	{ NULL,      -1,      0},
 };
 
 static struct bond_option bond_opts[] = {

commit f3253339a47ff3690ce52e2acd95ec295f8521b3
Author: stephen hemminger <stephen@networkplumber.org>
Date:   Tue Mar 4 16:36:44 2014 -0800

    bonding: options handling cleanup
    
    Make local functions static (ie. only used in bond_options.c)
    Make bond options parsing tables constant.
    
    Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 23f365510b58..fc6d25e7d053 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -20,7 +20,59 @@
 #include <linux/inet.h>
 #include "bonding.h"
 
-static struct bond_opt_value bond_mode_tbl[] = {
+static int bond_option_active_slave_set(struct bonding *bond,
+					struct bond_opt_value *newval);
+static int bond_option_miimon_set(struct bonding *bond,
+				  struct bond_opt_value *newval);
+static int bond_option_updelay_set(struct bonding *bond,
+				   struct bond_opt_value *newval);
+static int bond_option_downdelay_set(struct bonding *bond,
+				     struct bond_opt_value *newval);
+static int bond_option_use_carrier_set(struct bonding *bond,
+				       struct bond_opt_value *newval);
+static int bond_option_arp_interval_set(struct bonding *bond,
+					struct bond_opt_value *newval);
+static int bond_option_arp_ip_target_add(struct bonding *bond, __be32 target);
+static int bond_option_arp_ip_target_rem(struct bonding *bond, __be32 target);
+static int bond_option_arp_ip_targets_set(struct bonding *bond,
+					  struct bond_opt_value *newval);
+static int bond_option_arp_validate_set(struct bonding *bond,
+					struct bond_opt_value *newval);
+static int bond_option_arp_all_targets_set(struct bonding *bond,
+					   struct bond_opt_value *newval);
+static int bond_option_primary_set(struct bonding *bond,
+				   struct bond_opt_value *newval);
+static int bond_option_primary_reselect_set(struct bonding *bond,
+					    struct bond_opt_value *newval);
+static int bond_option_fail_over_mac_set(struct bonding *bond,
+					 struct bond_opt_value *newval);
+static int bond_option_xmit_hash_policy_set(struct bonding *bond,
+					    struct bond_opt_value *newval);
+static int bond_option_resend_igmp_set(struct bonding *bond,
+				       struct bond_opt_value *newval);
+static int bond_option_num_peer_notif_set(struct bonding *bond,
+					  struct bond_opt_value *newval);
+static int bond_option_all_slaves_active_set(struct bonding *bond,
+					     struct bond_opt_value *newval);
+static int bond_option_min_links_set(struct bonding *bond,
+				     struct bond_opt_value *newval);
+static int bond_option_lp_interval_set(struct bonding *bond,
+				       struct bond_opt_value *newval);
+static int bond_option_pps_set(struct bonding *bond,
+			       struct bond_opt_value *newval);
+static int bond_option_lacp_rate_set(struct bonding *bond,
+				     struct bond_opt_value *newval);
+static int bond_option_ad_select_set(struct bonding *bond,
+				     struct bond_opt_value *newval);
+static int bond_option_queue_id_set(struct bonding *bond,
+				    struct bond_opt_value *newval);
+static int bond_option_mode_set(struct bonding *bond,
+				struct bond_opt_value *newval);
+static int bond_option_slaves_set(struct bonding *bond,
+				  struct bond_opt_value *newval);
+
+
+static const struct bond_opt_value bond_mode_tbl[] = {
 	{ "balance-rr",    BOND_MODE_ROUNDROBIN,   BOND_VALFLAG_DEFAULT},
 	{ "active-backup", BOND_MODE_ACTIVEBACKUP, 0},
 	{ "balance-xor",   BOND_MODE_XOR,          0},
@@ -31,13 +83,13 @@ static struct bond_opt_value bond_mode_tbl[] = {
 	{ NULL,            -1,                     0},
 };
 
-static struct bond_opt_value bond_pps_tbl[] = {
+static const struct bond_opt_value bond_pps_tbl[] = {
 	{ "default", 1,         BOND_VALFLAG_DEFAULT},
 	{ "maxval",  USHRT_MAX, BOND_VALFLAG_MAX},
 	{ NULL,      -1,        0},
 };
 
-static struct bond_opt_value bond_xmit_hashtype_tbl[] = {
+static const struct bond_opt_value bond_xmit_hashtype_tbl[] = {
 	{ "layer2",   BOND_XMIT_POLICY_LAYER2, BOND_VALFLAG_DEFAULT},
 	{ "layer3+4", BOND_XMIT_POLICY_LAYER34, 0},
 	{ "layer2+3", BOND_XMIT_POLICY_LAYER23, 0},
@@ -46,7 +98,7 @@ static struct bond_opt_value bond_xmit_hashtype_tbl[] = {
 	{ NULL,       -1,                       0},
 };
 
-static struct bond_opt_value bond_arp_validate_tbl[] = {
+static const struct bond_opt_value bond_arp_validate_tbl[] = {
 	{ "none",		BOND_ARP_VALIDATE_NONE,		BOND_VALFLAG_DEFAULT},
 	{ "active",		BOND_ARP_VALIDATE_ACTIVE,	0},
 	{ "backup",		BOND_ARP_VALIDATE_BACKUP,	0},
@@ -57,76 +109,76 @@ static struct bond_opt_value bond_arp_validate_tbl[] = {
 	{ NULL,			-1,				0},
 };
 
-static struct bond_opt_value bond_arp_all_targets_tbl[] = {
+static const struct bond_opt_value bond_arp_all_targets_tbl[] = {
 	{ "any", BOND_ARP_TARGETS_ANY, BOND_VALFLAG_DEFAULT},
 	{ "all", BOND_ARP_TARGETS_ALL, 0},
 	{ NULL,  -1,                   0},
 };
 
-static struct bond_opt_value bond_fail_over_mac_tbl[] = {
+static const struct bond_opt_value bond_fail_over_mac_tbl[] = {
 	{ "none",   BOND_FOM_NONE,   BOND_VALFLAG_DEFAULT},
 	{ "active", BOND_FOM_ACTIVE, 0},
 	{ "follow", BOND_FOM_FOLLOW, 0},
 	{ NULL,     -1,              0},
 };
 
-static struct bond_opt_value bond_intmax_tbl[] = {
+static const struct bond_opt_value bond_intmax_tbl[] = {
 	{ "off",     0,       BOND_VALFLAG_DEFAULT},
 	{ "maxval",  INT_MAX, BOND_VALFLAG_MAX},
 };
 
-static struct bond_opt_value bond_lacp_rate_tbl[] = {
+static const struct bond_opt_value bond_lacp_rate_tbl[] = {
 	{ "slow", AD_LACP_SLOW, 0},
 	{ "fast", AD_LACP_FAST, 0},
 	{ NULL,   -1,           0},
 };
 
-static struct bond_opt_value bond_ad_select_tbl[] = {
+static const struct bond_opt_value bond_ad_select_tbl[] = {
 	{ "stable",    BOND_AD_STABLE,    BOND_VALFLAG_DEFAULT},
 	{ "bandwidth", BOND_AD_BANDWIDTH, 0},
 	{ "count",     BOND_AD_COUNT,     0},
 	{ NULL,        -1,                0},
 };
 
-static struct bond_opt_value bond_num_peer_notif_tbl[] = {
+static const struct bond_opt_value bond_num_peer_notif_tbl[] = {
 	{ "off",     0,   0},
 	{ "maxval",  255, BOND_VALFLAG_MAX},
 	{ "default", 1,   BOND_VALFLAG_DEFAULT},
 	{ NULL,      -1,  0}
 };
 
-static struct bond_opt_value bond_primary_reselect_tbl[] = {
+static const struct bond_opt_value bond_primary_reselect_tbl[] = {
 	{ "always",  BOND_PRI_RESELECT_ALWAYS,  BOND_VALFLAG_DEFAULT},
 	{ "better",  BOND_PRI_RESELECT_BETTER,  0},
 	{ "failure", BOND_PRI_RESELECT_FAILURE, 0},
 	{ NULL,      -1},
 };
 
-static struct bond_opt_value bond_use_carrier_tbl[] = {
+static const struct bond_opt_value bond_use_carrier_tbl[] = {
 	{ "off", 0,  0},
 	{ "on",  1,  BOND_VALFLAG_DEFAULT},
 	{ NULL,  -1, 0}
 };
 
-static struct bond_opt_value bond_all_slaves_active_tbl[] = {
+static const struct bond_opt_value bond_all_slaves_active_tbl[] = {
 	{ "off", 0,  BOND_VALFLAG_DEFAULT},
 	{ "on",  1,  0},
 	{ NULL,  -1, 0}
 };
 
-static struct bond_opt_value bond_resend_igmp_tbl[] = {
+static const struct bond_opt_value bond_resend_igmp_tbl[] = {
 	{ "off",     0,   0},
 	{ "maxval",  255, BOND_VALFLAG_MAX},
 	{ "default", 1,   BOND_VALFLAG_DEFAULT},
 	{ NULL,      -1,  0}
 };
 
-static struct bond_opt_value bond_lp_interval_tbl[] = {
+static const struct bond_opt_value bond_lp_interval_tbl[] = {
 	{ "minval",  1,       BOND_VALFLAG_MIN | BOND_VALFLAG_DEFAULT},
 	{ "maxval",  INT_MAX, BOND_VALFLAG_MAX},
 };
 
-static struct bond_option bond_opts[] = {
+static const struct bond_option bond_opts[] = {
 	[BOND_OPT_MODE] = {
 		.id = BOND_OPT_MODE,
 		.name = "mode",
@@ -315,9 +367,9 @@ static struct bond_option bond_opts[] = {
 };
 
 /* Searches for a value in opt's values[] table */
-struct bond_opt_value *bond_opt_get_val(unsigned int option, u64 val)
+const struct bond_opt_value *bond_opt_get_val(unsigned int option, u64 val)
 {
-	struct bond_option *opt;
+	const struct bond_option *opt;
 	int i;
 
 	opt = bond_opt_get(option);
@@ -331,7 +383,7 @@ struct bond_opt_value *bond_opt_get_val(unsigned int option, u64 val)
 }
 
 /* Searches for a value in opt's values[] table which matches the flagmask */
-static struct bond_opt_value *bond_opt_get_flags(const struct bond_option *opt,
+static const struct bond_opt_value *bond_opt_get_flags(const struct bond_option *opt,
 						 u32 flagmask)
 {
 	int i;
@@ -348,7 +400,7 @@ static struct bond_opt_value *bond_opt_get_flags(const struct bond_option *opt,
  */
 static bool bond_opt_check_range(const struct bond_option *opt, u64 val)
 {
-	struct bond_opt_value *minval, *maxval;
+	const struct bond_opt_value *minval, *maxval;
 
 	minval = bond_opt_get_flags(opt, BOND_VALFLAG_MIN);
 	maxval = bond_opt_get_flags(opt, BOND_VALFLAG_MAX);
@@ -368,11 +420,12 @@ static bool bond_opt_check_range(const struct bond_option *opt, u64 val)
  * or the struct_opt_value that matched. It also strips the new line from
  * @val->string if it's present.
  */
-struct bond_opt_value *bond_opt_parse(const struct bond_option *opt,
-				      struct bond_opt_value *val)
+const struct bond_opt_value *bond_opt_parse(const struct bond_option *opt,
+					    struct bond_opt_value *val)
 {
 	char *p, valstr[BOND_OPT_MAX_NAMELEN + 1] = { 0, };
-	struct bond_opt_value *tbl, *ret = NULL;
+	const struct bond_opt_value *tbl;
+	const struct bond_opt_value *ret = NULL;
 	bool checkval;
 	int i, rv;
 
@@ -576,7 +629,7 @@ int bond_opt_tryset_rtnl(struct bonding *bond, unsigned int option, char *buf)
  * This function checks if option is valid and if so returns a pointer
  * to its entry in the bond_opts[] option array.
  */
-struct bond_option *bond_opt_get(unsigned int option)
+const struct bond_option *bond_opt_get(unsigned int option)
 {
 	if (!BOND_OPT_VALID(option))
 		return NULL;
@@ -622,8 +675,8 @@ struct net_device *bond_option_active_slave_get(struct bonding *bond)
 	return __bond_option_active_slave_get(bond, bond->curr_active_slave);
 }
 
-int bond_option_active_slave_set(struct bonding *bond,
-				 struct bond_opt_value *newval)
+static int bond_option_active_slave_set(struct bonding *bond,
+					struct bond_opt_value *newval)
 {
 	char ifname[IFNAMSIZ] = { 0, };
 	struct net_device *slave_dev;
@@ -691,7 +744,8 @@ int bond_option_active_slave_set(struct bonding *bond,
 	return ret;
 }
 
-int bond_option_miimon_set(struct bonding *bond, struct bond_opt_value *newval)
+static int bond_option_miimon_set(struct bonding *bond,
+				  struct bond_opt_value *newval)
 {
 	pr_info("%s: Setting MII monitoring interval to %llu\n",
 		bond->dev->name, newval->value);
@@ -728,7 +782,8 @@ int bond_option_miimon_set(struct bonding *bond, struct bond_opt_value *newval)
 	return 0;
 }
 
-int bond_option_updelay_set(struct bonding *bond, struct bond_opt_value *newval)
+static int bond_option_updelay_set(struct bonding *bond,
+				   struct bond_opt_value *newval)
 {
 	int value = newval->value;
 
@@ -751,8 +806,8 @@ int bond_option_updelay_set(struct bonding *bond, struct bond_opt_value *newval)
 	return 0;
 }
 
-int bond_option_downdelay_set(struct bonding *bond,
-			      struct bond_opt_value *newval)
+static int bond_option_downdelay_set(struct bonding *bond,
+				     struct bond_opt_value *newval)
 {
 	int value = newval->value;
 
@@ -775,8 +830,8 @@ int bond_option_downdelay_set(struct bonding *bond,
 	return 0;
 }
 
-int bond_option_use_carrier_set(struct bonding *bond,
-				struct bond_opt_value *newval)
+static int bond_option_use_carrier_set(struct bonding *bond,
+				       struct bond_opt_value *newval)
 {
 	pr_info("%s: Setting use_carrier to %llu\n",
 		bond->dev->name, newval->value);
@@ -785,8 +840,8 @@ int bond_option_use_carrier_set(struct bonding *bond,
 	return 0;
 }
 
-int bond_option_arp_interval_set(struct bonding *bond,
-				 struct bond_opt_value *newval)
+static int bond_option_arp_interval_set(struct bonding *bond,
+					struct bond_opt_value *newval)
 {
 	pr_info("%s: Setting ARP monitoring interval to %llu\n",
 		bond->dev->name, newval->value);
@@ -867,7 +922,7 @@ static int _bond_option_arp_ip_target_add(struct bonding *bond, __be32 target)
 	return 0;
 }
 
-int bond_option_arp_ip_target_add(struct bonding *bond, __be32 target)
+static int bond_option_arp_ip_target_add(struct bonding *bond, __be32 target)
 {
 	int ret;
 
@@ -879,7 +934,7 @@ int bond_option_arp_ip_target_add(struct bonding *bond, __be32 target)
 	return ret;
 }
 
-int bond_option_arp_ip_target_rem(struct bonding *bond, __be32 target)
+static int bond_option_arp_ip_target_rem(struct bonding *bond, __be32 target)
 {
 	__be32 *targets = bond->params.arp_targets;
 	struct list_head *iter;
@@ -935,8 +990,8 @@ void bond_option_arp_ip_targets_clear(struct bonding *bond)
 	write_unlock_bh(&bond->lock);
 }
 
-int bond_option_arp_ip_targets_set(struct bonding *bond,
-				   struct bond_opt_value *newval)
+static int bond_option_arp_ip_targets_set(struct bonding *bond,
+					  struct bond_opt_value *newval)
 {
 	int ret = -EPERM;
 	__be32 target;
@@ -962,8 +1017,8 @@ int bond_option_arp_ip_targets_set(struct bonding *bond,
 	return ret;
 }
 
-int bond_option_arp_validate_set(struct bonding *bond,
-				 struct bond_opt_value *newval)
+static int bond_option_arp_validate_set(struct bonding *bond,
+					struct bond_opt_value *newval)
 {
 	pr_info("%s: Setting arp_validate to %s (%llu)\n",
 		bond->dev->name, newval->string, newval->value);
@@ -979,8 +1034,8 @@ int bond_option_arp_validate_set(struct bonding *bond,
 	return 0;
 }
 
-int bond_option_arp_all_targets_set(struct bonding *bond,
-				    struct bond_opt_value *newval)
+static int bond_option_arp_all_targets_set(struct bonding *bond,
+					   struct bond_opt_value *newval)
 {
 	pr_info("%s: Setting arp_all_targets to %s (%llu)\n",
 		bond->dev->name, newval->string, newval->value);
@@ -989,7 +1044,8 @@ int bond_option_arp_all_targets_set(struct bonding *bond,
 	return 0;
 }
 
-int bond_option_primary_set(struct bonding *bond, struct bond_opt_value *newval)
+static int bond_option_primary_set(struct bonding *bond,
+				   struct bond_opt_value *newval)
 {
 	char *p, *primary = newval->string;
 	struct list_head *iter;
@@ -1041,8 +1097,8 @@ int bond_option_primary_set(struct bonding *bond, struct bond_opt_value *newval)
 	return 0;
 }
 
-int bond_option_primary_reselect_set(struct bonding *bond,
-				     struct bond_opt_value *newval)
+static int bond_option_primary_reselect_set(struct bonding *bond,
+					    struct bond_opt_value *newval)
 {
 	pr_info("%s: Setting primary_reselect to %s (%llu)\n",
 		bond->dev->name, newval->string, newval->value);
@@ -1057,8 +1113,8 @@ int bond_option_primary_reselect_set(struct bonding *bond,
 	return 0;
 }
 
-int bond_option_fail_over_mac_set(struct bonding *bond,
-				  struct bond_opt_value *newval)
+static int bond_option_fail_over_mac_set(struct bonding *bond,
+					 struct bond_opt_value *newval)
 {
 	pr_info("%s: Setting fail_over_mac to %s (%llu)\n",
 		bond->dev->name, newval->string, newval->value);
@@ -1067,8 +1123,8 @@ int bond_option_fail_over_mac_set(struct bonding *bond,
 	return 0;
 }
 
-int bond_option_xmit_hash_policy_set(struct bonding *bond,
-				     struct bond_opt_value *newval)
+static int bond_option_xmit_hash_policy_set(struct bonding *bond,
+					    struct bond_opt_value *newval)
 {
 	pr_info("%s: Setting xmit hash policy to %s (%llu)\n",
 		bond->dev->name, newval->string, newval->value);
@@ -1077,8 +1133,8 @@ int bond_option_xmit_hash_policy_set(struct bonding *bond,
 	return 0;
 }
 
-int bond_option_resend_igmp_set(struct bonding *bond,
-				struct bond_opt_value *newval)
+static int bond_option_resend_igmp_set(struct bonding *bond,
+				       struct bond_opt_value *newval)
 {
 	pr_info("%s: Setting resend_igmp to %llu\n",
 		bond->dev->name, newval->value);
@@ -1087,7 +1143,7 @@ int bond_option_resend_igmp_set(struct bonding *bond,
 	return 0;
 }
 
-int bond_option_num_peer_notif_set(struct bonding *bond,
+static int bond_option_num_peer_notif_set(struct bonding *bond,
 				   struct bond_opt_value *newval)
 {
 	bond->params.num_peer_notif = newval->value;
@@ -1095,8 +1151,8 @@ int bond_option_num_peer_notif_set(struct bonding *bond,
 	return 0;
 }
 
-int bond_option_all_slaves_active_set(struct bonding *bond,
-				      struct bond_opt_value *newval)
+static int bond_option_all_slaves_active_set(struct bonding *bond,
+					     struct bond_opt_value *newval)
 {
 	struct list_head *iter;
 	struct slave *slave;
@@ -1116,8 +1172,8 @@ int bond_option_all_slaves_active_set(struct bonding *bond,
 	return 0;
 }
 
-int bond_option_min_links_set(struct bonding *bond,
-			      struct bond_opt_value *newval)
+static int bond_option_min_links_set(struct bonding *bond,
+				     struct bond_opt_value *newval)
 {
 	pr_info("%s: Setting min links value to %llu\n",
 		bond->dev->name, newval->value);
@@ -1126,15 +1182,16 @@ int bond_option_min_links_set(struct bonding *bond,
 	return 0;
 }
 
-int bond_option_lp_interval_set(struct bonding *bond,
-				struct bond_opt_value *newval)
+static int bond_option_lp_interval_set(struct bonding *bond,
+				       struct bond_opt_value *newval)
 {
 	bond->params.lp_interval = newval->value;
 
 	return 0;
 }
 
-int bond_option_pps_set(struct bonding *bond, struct bond_opt_value *newval)
+static int bond_option_pps_set(struct bonding *bond,
+			       struct bond_opt_value *newval)
 {
 	bond->params.packets_per_slave = newval->value;
 	if (newval->value > 0) {
@@ -1151,8 +1208,8 @@ int bond_option_pps_set(struct bonding *bond, struct bond_opt_value *newval)
 	return 0;
 }
 
-int bond_option_lacp_rate_set(struct bonding *bond,
-			      struct bond_opt_value *newval)
+static int bond_option_lacp_rate_set(struct bonding *bond,
+				     struct bond_opt_value *newval)
 {
 	pr_info("%s: Setting LACP rate to %s (%llu)\n",
 		bond->dev->name, newval->string, newval->value);
@@ -1162,8 +1219,8 @@ int bond_option_lacp_rate_set(struct bonding *bond,
 	return 0;
 }
 
-int bond_option_ad_select_set(struct bonding *bond,
-			      struct bond_opt_value *newval)
+static int bond_option_ad_select_set(struct bonding *bond,
+				     struct bond_opt_value *newval)
 {
 	pr_info("%s: Setting ad_select to %s (%llu)\n",
 		bond->dev->name, newval->string, newval->value);
@@ -1172,8 +1229,8 @@ int bond_option_ad_select_set(struct bonding *bond,
 	return 0;
 }
 
-int bond_option_queue_id_set(struct bonding *bond,
-			     struct bond_opt_value *newval)
+static int bond_option_queue_id_set(struct bonding *bond,
+				    struct bond_opt_value *newval)
 {
 	struct slave *slave, *update_slave;
 	struct net_device *sdev;
@@ -1233,7 +1290,8 @@ int bond_option_queue_id_set(struct bonding *bond,
 
 }
 
-int bond_option_slaves_set(struct bonding *bond, struct bond_opt_value *newval)
+static int bond_option_slaves_set(struct bonding *bond,
+				  struct bond_opt_value *newval)
 {
 	char command[IFNAMSIZ + 1] = { 0, };
 	struct net_device *dev;

commit 1e8d6421cff2c24fe0b345711e7a21af02e8bcf5
Merge: f7b12606b5de 960dfc4eb23a
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Feb 19 01:24:22 2014 -0500

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts:
            drivers/net/bonding/bond_3ad.h
            drivers/net/bonding/bond_main.c
    
    Two minor conflicts in bonding, both of which were overlapping
    changes.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 896149ff1b2c48962b7e8eee797552c61f8d5b93
Author: Veaceslav Falico <vfalico@redhat.com>
Date:   Tue Feb 18 07:48:40 2014 +0100

    bonding: extend arp_validate to be able to receive unvalidated arp-only traffic
    
    Currently we can either receive any traffic as a proff of slave being up,
    or only *validated* arp traffic (i.e. with src/dst ip checked).
    
    Add an option to be able to specify if we want to receive non-validated arp
    traffic only.
    
    CC: Jay Vosburgh <fubar@us.ibm.com>
    CC: Andy Gospodarek <andy@greyhouse.net>
    Signed-off-by: Veaceslav Falico <vfalico@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index ad20c8ca11b6..5f997b9af54d 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -47,11 +47,14 @@ static struct bond_opt_value bond_xmit_hashtype_tbl[] = {
 };
 
 static struct bond_opt_value bond_arp_validate_tbl[] = {
-	{ "none",   BOND_ARP_VALIDATE_NONE,   BOND_VALFLAG_DEFAULT},
-	{ "active", BOND_ARP_VALIDATE_ACTIVE, 0},
-	{ "backup", BOND_ARP_VALIDATE_BACKUP, 0},
-	{ "all",    BOND_ARP_VALIDATE_ALL,    0},
-	{ NULL,     -1,                       0},
+	{ "none",		BOND_ARP_VALIDATE_NONE,		BOND_VALFLAG_DEFAULT},
+	{ "active",		BOND_ARP_VALIDATE_ACTIVE,	0},
+	{ "backup",		BOND_ARP_VALIDATE_BACKUP,	0},
+	{ "all",		BOND_ARP_VALIDATE_ALL,		0},
+	{ "filter",		BOND_ARP_FILTER,		0},
+	{ "filter_active",	BOND_ARP_FILTER_ACTIVE,		0},
+	{ "filter_backup",	BOND_ARP_FILTER_BACKUP,		0},
+	{ NULL,			-1,				0},
 };
 
 static struct bond_opt_value bond_arp_all_targets_tbl[] = {

commit 3fe68df97c7f132495664358e0bfbfcd4ca7809c
Author: Veaceslav Falico <vfalico@redhat.com>
Date:   Tue Feb 18 07:48:39 2014 +0100

    bonding: always set recv_probe to bond_arp_rcv in arp monitor
    
    Currently we only set bond_arp_rcv() if we're using arp_validate, however
    this makes us skip updating last_arp_rx if we're not validating incoming
    ARPs - thus, if arp_validate is off, last_arp_rx will never be updated.
    
    Fix this by always setting up recv_probe = bond_arp_rcv, even if we're not
    using arp_validate.
    
    CC: Jay Vosburgh <fubar@us.ibm.com>
    CC: Andy Gospodarek <andy@greyhouse.net>
    Signed-off-by: Veaceslav Falico <vfalico@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 4d58645b117d..ad20c8ca11b6 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -810,8 +810,7 @@ int bond_option_arp_interval_set(struct bonding *bond,
 			cancel_delayed_work_sync(&bond->arp_work);
 		} else {
 			/* arp_validate can be set only in active-backup mode */
-			if (bond->params.arp_validate)
-				bond->recv_probe = bond_arp_rcv;
+			bond->recv_probe = bond_arp_rcv;
 			cancel_delayed_work_sync(&bond->mii_work);
 			queue_delayed_work(bond->wq, &bond->arp_work, 0);
 		}

commit 13ac34a8866e31b31db6237c73aa558aff84d765
Author: Veaceslav Falico <vfalico@redhat.com>
Date:   Tue Feb 18 07:48:37 2014 +0100

    bonding: permit using arp_validate with non-ab modes
    
    Currently it's disabled because it's sometimes hard, in typical configs, to
    make it work - because of the nature how the loadbalance modes work - as
    it's hard to deliver valid arp replies to correct slaves by the switch.
    
    However we still can use arp_validation in loadbalance with several other
    configs, per example with arp_validate == 2 for backup with one broadcast
    domain, without the switch(es) doing any balancing - this way we'd be (a
    bit more) sure that the slave is up.
    
    So, enable it to let users decide which one works/suits them best. Also
    correct the mode limitation from BOND_OPT_ARP_VALIDATE.
    
    CC: Nikolay Aleksandrov <nikolay@redhat.com>
    CC: Jay Vosburgh <fubar@us.ibm.com>
    CC: Andy Gospodarek <andy@greyhouse.net>
    Signed-off-by: Veaceslav Falico <vfalico@redhat.com>
    Acked-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index f3eb44d2e231..4d58645b117d 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -151,7 +151,8 @@ static struct bond_option bond_opts[] = {
 		.id = BOND_OPT_ARP_VALIDATE,
 		.name = "arp_validate",
 		.desc = "validate src/dst of ARP probes",
-		.unsuppmodes = BOND_MODE_ALL_EX(BIT(BOND_MODE_ACTIVEBACKUP)),
+		.unsuppmodes = BIT(BOND_MODE_8023AD) | BIT(BOND_MODE_TLB) |
+			       BIT(BOND_MODE_ALB),
 		.values = bond_arp_validate_tbl,
 		.set = bond_option_arp_validate_set
 	},

commit 90194264ceffdff809e625f54767f6f8c292a28e
Author: Joe Perches <joe@perches.com>
Date:   Sat Feb 15 16:01:45 2014 -0800

    bonding: Neaten pr_<level>
    
    Add missing terminating newlines.
    Convert uses of pr_info to pr_cont in bond_check_params.
    Standardize upper/lower case styles.
    Typo fixes, remove unnecessary parentheses and periods.
    Alignment neatening.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 832d6e90b1b9..f3eb44d2e231 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -473,10 +473,10 @@ static void bond_opt_error_interpret(struct bonding *bond,
 				p = strchr(val->string, '\n');
 				if (p)
 					*p = '\0';
-				pr_err("%s: option %s: invalid value (%s).\n",
+				pr_err("%s: option %s: invalid value (%s)\n",
 				       bond->dev->name, opt->name, val->string);
 			} else {
-				pr_err("%s: option %s: invalid value (%llu).\n",
+				pr_err("%s: option %s: invalid value (%llu)\n",
 				       bond->dev->name, opt->name, val->value);
 			}
 		}
@@ -484,7 +484,7 @@ static void bond_opt_error_interpret(struct bonding *bond,
 		maxval = bond_opt_get_flags(opt, BOND_VALFLAG_MAX);
 		if (!maxval)
 			break;
-		pr_err("%s: option %s: allowed values %llu - %llu.\n",
+		pr_err("%s: option %s: allowed values %llu - %llu\n",
 		       bond->dev->name, opt->name, minval ? minval->value : 0,
 		       maxval->value);
 		break;
@@ -492,11 +492,11 @@ static void bond_opt_error_interpret(struct bonding *bond,
 		bond_opt_dep_print(bond, opt);
 		break;
 	case -ENOTEMPTY:
-		pr_err("%s: option %s: unable to set because the bond device has slaves.\n",
+		pr_err("%s: option %s: unable to set because the bond device has slaves\n",
 		       bond->dev->name, opt->name);
 		break;
 	case -EBUSY:
-		pr_err("%s: option %s: unable to set because the bond device is up.\n",
+		pr_err("%s: option %s: unable to set because the bond device is up\n",
 		       bond->dev->name, opt->name);
 		break;
 	default:
@@ -589,7 +589,7 @@ int bond_option_mode_set(struct bonding *bond, struct bond_opt_value *newval)
 		bond->params.arp_interval = 0;
 		/* set miimon to default value */
 		bond->params.miimon = BOND_DEFAULT_MIIMON;
-		pr_info("%s: Setting MII monitoring interval to %d.\n",
+		pr_info("%s: Setting MII monitoring interval to %d\n",
 			bond->dev->name, bond->params.miimon);
 	}
 
@@ -636,13 +636,13 @@ int bond_option_active_slave_set(struct bonding *bond,
 
 	if (slave_dev) {
 		if (!netif_is_bond_slave(slave_dev)) {
-			pr_err("Device %s is not bonding slave.\n",
+			pr_err("Device %s is not bonding slave\n",
 			       slave_dev->name);
 			return -EINVAL;
 		}
 
 		if (bond->dev != netdev_master_upper_dev_get(slave_dev)) {
-			pr_err("%s: Device %s is not our slave.\n",
+			pr_err("%s: Device %s is not our slave\n",
 			       bond->dev->name, slave_dev->name);
 			return -EINVAL;
 		}
@@ -653,8 +653,7 @@ int bond_option_active_slave_set(struct bonding *bond,
 
 	/* check to see if we are clearing active */
 	if (!slave_dev) {
-		pr_info("%s: Clearing current active slave.\n",
-		bond->dev->name);
+		pr_info("%s: Clearing current active slave\n", bond->dev->name);
 		rcu_assign_pointer(bond->curr_active_slave, NULL);
 		bond_select_active_slave(bond);
 	} else {
@@ -665,16 +664,16 @@ int bond_option_active_slave_set(struct bonding *bond,
 
 		if (new_active == old_active) {
 			/* do nothing */
-			pr_info("%s: %s is already the current active slave.\n",
+			pr_info("%s: %s is already the current active slave\n",
 				bond->dev->name, new_active->dev->name);
 		} else {
 			if (old_active && (new_active->link == BOND_LINK_UP) &&
 			    IS_UP(new_active->dev)) {
-				pr_info("%s: Setting %s as active slave.\n",
+				pr_info("%s: Setting %s as active slave\n",
 					bond->dev->name, new_active->dev->name);
 				bond_change_active_slave(bond, new_active);
 			} else {
-				pr_err("%s: Could not set %s as active slave; either %s is down or the link is down.\n",
+				pr_err("%s: Could not set %s as active slave; either %s is down or the link is down\n",
 				       bond->dev->name, new_active->dev->name,
 				       new_active->dev->name);
 				ret = -EINVAL;
@@ -690,19 +689,19 @@ int bond_option_active_slave_set(struct bonding *bond,
 
 int bond_option_miimon_set(struct bonding *bond, struct bond_opt_value *newval)
 {
-	pr_info("%s: Setting MII monitoring interval to %llu.\n",
+	pr_info("%s: Setting MII monitoring interval to %llu\n",
 		bond->dev->name, newval->value);
 	bond->params.miimon = newval->value;
 	if (bond->params.updelay)
-		pr_info("%s: Note: Updating updelay (to %d) since it is a multiple of the miimon value.\n",
+		pr_info("%s: Note: Updating updelay (to %d) since it is a multiple of the miimon value\n",
 			bond->dev->name,
 			bond->params.updelay * bond->params.miimon);
 	if (bond->params.downdelay)
-		pr_info("%s: Note: Updating downdelay (to %d) since it is a multiple of the miimon value.\n",
+		pr_info("%s: Note: Updating downdelay (to %d) since it is a multiple of the miimon value\n",
 			bond->dev->name,
 			bond->params.downdelay * bond->params.miimon);
 	if (newval->value && bond->params.arp_interval) {
-		pr_info("%s: MII monitoring cannot be used with ARP monitoring. Disabling ARP monitoring...\n",
+		pr_info("%s: MII monitoring cannot be used with ARP monitoring - disabling ARP monitoring...\n",
 			bond->dev->name);
 		bond->params.arp_interval = 0;
 		if (bond->params.arp_validate)
@@ -742,9 +741,8 @@ int bond_option_updelay_set(struct bonding *bond, struct bond_opt_value *newval)
 			bond->params.miimon);
 	}
 	bond->params.updelay = value / bond->params.miimon;
-	pr_info("%s: Setting up delay to %d.\n",
-		bond->dev->name,
-		bond->params.updelay * bond->params.miimon);
+	pr_info("%s: Setting up delay to %d\n",
+		bond->dev->name, bond->params.updelay * bond->params.miimon);
 
 	return 0;
 }
@@ -767,9 +765,8 @@ int bond_option_downdelay_set(struct bonding *bond,
 			bond->params.miimon);
 	}
 	bond->params.downdelay = value / bond->params.miimon;
-	pr_info("%s: Setting down delay to %d.\n",
-		bond->dev->name,
-		bond->params.downdelay * bond->params.miimon);
+	pr_info("%s: Setting down delay to %d\n",
+		bond->dev->name, bond->params.downdelay * bond->params.miimon);
 
 	return 0;
 }
@@ -777,7 +774,7 @@ int bond_option_downdelay_set(struct bonding *bond,
 int bond_option_use_carrier_set(struct bonding *bond,
 				struct bond_opt_value *newval)
 {
-	pr_info("%s: Setting use_carrier to %llu.\n",
+	pr_info("%s: Setting use_carrier to %llu\n",
 		bond->dev->name, newval->value);
 	bond->params.use_carrier = newval->value;
 
@@ -787,17 +784,17 @@ int bond_option_use_carrier_set(struct bonding *bond,
 int bond_option_arp_interval_set(struct bonding *bond,
 				 struct bond_opt_value *newval)
 {
-	pr_info("%s: Setting ARP monitoring interval to %llu.\n",
+	pr_info("%s: Setting ARP monitoring interval to %llu\n",
 		bond->dev->name, newval->value);
 	bond->params.arp_interval = newval->value;
 	if (newval->value) {
 		if (bond->params.miimon) {
-			pr_info("%s: ARP monitoring cannot be used with MII monitoring. %s Disabling MII monitoring.\n",
+			pr_info("%s: ARP monitoring cannot be used with MII monitoring. %s Disabling MII monitoring\n",
 				bond->dev->name, bond->dev->name);
 			bond->params.miimon = 0;
 		}
 		if (!bond->params.arp_targets[0])
-			pr_info("%s: ARP monitoring has been set up, but no ARP targets have been specified.\n",
+			pr_info("%s: ARP monitoring has been set up, but no ARP targets have been specified\n",
 				bond->dev->name);
 	}
 	if (bond->dev->flags & IFF_UP) {
@@ -856,12 +853,11 @@ static int _bond_option_arp_ip_target_add(struct bonding *bond, __be32 target)
 
 	ind = bond_get_targets_ip(targets, 0); /* first free slot */
 	if (ind == -1) {
-		pr_err("%s: ARP target table is full!\n",
-		       bond->dev->name);
+		pr_err("%s: ARP target table is full!\n", bond->dev->name);
 		return -EINVAL;
 	}
 
-	pr_info("%s: adding ARP target %pI4.\n", bond->dev->name, &target);
+	pr_info("%s: Adding ARP target %pI4\n", bond->dev->name, &target);
 
 	_bond_options_arp_ip_target_set(bond, ind, target, jiffies);
 
@@ -896,17 +892,16 @@ int bond_option_arp_ip_target_rem(struct bonding *bond, __be32 target)
 
 	ind = bond_get_targets_ip(targets, target);
 	if (ind == -1) {
-		pr_err("%s: unable to remove nonexistent ARP target %pI4.\n",
+		pr_err("%s: unable to remove nonexistent ARP target %pI4\n",
 		       bond->dev->name, &target);
 		return -EINVAL;
 	}
 
 	if (ind == 0 && !targets[1] && bond->params.arp_interval)
-		pr_warn("%s: removing last arp target with arp_interval on\n",
+		pr_warn("%s: Removing last arp target with arp_interval on\n",
 			bond->dev->name);
 
-	pr_info("%s: removing ARP target %pI4.\n", bond->dev->name,
-		&target);
+	pr_info("%s: Removing ARP target %pI4\n", bond->dev->name, &target);
 
 	/* not to race with bond_arp_rcv */
 	write_lock_bh(&bond->lock);
@@ -954,7 +949,7 @@ int bond_option_arp_ip_targets_set(struct bonding *bond,
 		else if (newval->string[0] == '-')
 			ret = bond_option_arp_ip_target_rem(bond, target);
 		else
-			pr_err("no command found in arp_ip_targets file for bond %s. Use +<addr> or -<addr>.\n",
+			pr_err("no command found in arp_ip_targets file for bond %s - use +<addr> or -<addr>\n",
 			       bond->dev->name);
 	} else {
 		target = newval->value;
@@ -967,7 +962,7 @@ int bond_option_arp_ip_targets_set(struct bonding *bond,
 int bond_option_arp_validate_set(struct bonding *bond,
 				 struct bond_opt_value *newval)
 {
-	pr_info("%s: setting arp_validate to %s (%llu).\n",
+	pr_info("%s: Setting arp_validate to %s (%llu)\n",
 		bond->dev->name, newval->string, newval->value);
 
 	if (bond->dev->flags & IFF_UP) {
@@ -984,7 +979,7 @@ int bond_option_arp_validate_set(struct bonding *bond,
 int bond_option_arp_all_targets_set(struct bonding *bond,
 				    struct bond_opt_value *newval)
 {
-	pr_info("%s: setting arp_all_targets to %s (%llu).\n",
+	pr_info("%s: Setting arp_all_targets to %s (%llu)\n",
 		bond->dev->name, newval->string, newval->value);
 	bond->params.arp_all_targets = newval->value;
 
@@ -1006,8 +1001,7 @@ int bond_option_primary_set(struct bonding *bond, struct bond_opt_value *newval)
 		*p = '\0';
 	/* check to see if we are clearing primary */
 	if (!strlen(primary)) {
-		pr_info("%s: Setting primary slave to None.\n",
-			bond->dev->name);
+		pr_info("%s: Setting primary slave to None\n", bond->dev->name);
 		bond->primary_slave = NULL;
 		memset(bond->params.primary, 0, sizeof(bond->params.primary));
 		bond_select_active_slave(bond);
@@ -1016,7 +1010,7 @@ int bond_option_primary_set(struct bonding *bond, struct bond_opt_value *newval)
 
 	bond_for_each_slave(bond, slave, iter) {
 		if (strncmp(slave->dev->name, primary, IFNAMSIZ) == 0) {
-			pr_info("%s: Setting %s as primary slave.\n",
+			pr_info("%s: Setting %s as primary slave\n",
 				bond->dev->name, slave->dev->name);
 			bond->primary_slave = slave;
 			strcpy(bond->params.primary, slave->dev->name);
@@ -1026,15 +1020,14 @@ int bond_option_primary_set(struct bonding *bond, struct bond_opt_value *newval)
 	}
 
 	if (bond->primary_slave) {
-		pr_info("%s: Setting primary slave to None.\n",
-			bond->dev->name);
+		pr_info("%s: Setting primary slave to None\n", bond->dev->name);
 		bond->primary_slave = NULL;
 		bond_select_active_slave(bond);
 	}
 	strncpy(bond->params.primary, primary, IFNAMSIZ);
 	bond->params.primary[IFNAMSIZ - 1] = 0;
 
-	pr_info("%s: Recording %s as primary, but it has not been enslaved to %s yet.\n",
+	pr_info("%s: Recording %s as primary, but it has not been enslaved to %s yet\n",
 		bond->dev->name, primary, bond->dev->name);
 
 out:
@@ -1048,7 +1041,7 @@ int bond_option_primary_set(struct bonding *bond, struct bond_opt_value *newval)
 int bond_option_primary_reselect_set(struct bonding *bond,
 				     struct bond_opt_value *newval)
 {
-	pr_info("%s: setting primary_reselect to %s (%llu).\n",
+	pr_info("%s: Setting primary_reselect to %s (%llu)\n",
 		bond->dev->name, newval->string, newval->value);
 	bond->params.primary_reselect = newval->value;
 
@@ -1064,7 +1057,7 @@ int bond_option_primary_reselect_set(struct bonding *bond,
 int bond_option_fail_over_mac_set(struct bonding *bond,
 				  struct bond_opt_value *newval)
 {
-	pr_info("%s: Setting fail_over_mac to %s (%llu).\n",
+	pr_info("%s: Setting fail_over_mac to %s (%llu)\n",
 		bond->dev->name, newval->string, newval->value);
 	bond->params.fail_over_mac = newval->value;
 
@@ -1074,7 +1067,7 @@ int bond_option_fail_over_mac_set(struct bonding *bond,
 int bond_option_xmit_hash_policy_set(struct bonding *bond,
 				     struct bond_opt_value *newval)
 {
-	pr_info("%s: setting xmit hash policy to %s (%llu).\n",
+	pr_info("%s: Setting xmit hash policy to %s (%llu)\n",
 		bond->dev->name, newval->string, newval->value);
 	bond->params.xmit_policy = newval->value;
 
@@ -1084,7 +1077,7 @@ int bond_option_xmit_hash_policy_set(struct bonding *bond,
 int bond_option_resend_igmp_set(struct bonding *bond,
 				struct bond_opt_value *newval)
 {
-	pr_info("%s: Setting resend_igmp to %llu.\n",
+	pr_info("%s: Setting resend_igmp to %llu\n",
 		bond->dev->name, newval->value);
 	bond->params.resend_igmp = newval->value;
 
@@ -1158,7 +1151,7 @@ int bond_option_pps_set(struct bonding *bond, struct bond_opt_value *newval)
 int bond_option_lacp_rate_set(struct bonding *bond,
 			      struct bond_opt_value *newval)
 {
-	pr_info("%s: Setting LACP rate to %s (%llu).\n",
+	pr_info("%s: Setting LACP rate to %s (%llu)\n",
 		bond->dev->name, newval->string, newval->value);
 	bond->params.lacp_fast = newval->value;
 	bond_3ad_update_lacp_rate(bond);
@@ -1169,7 +1162,7 @@ int bond_option_lacp_rate_set(struct bonding *bond,
 int bond_option_ad_select_set(struct bonding *bond,
 			      struct bond_opt_value *newval)
 {
-	pr_info("%s: Setting ad_select to %s (%llu).\n",
+	pr_info("%s: Setting ad_select to %s (%llu)\n",
 		bond->dev->name, newval->string, newval->value);
 	bond->params.ad_select = newval->value;
 
@@ -1231,8 +1224,7 @@ int bond_option_queue_id_set(struct bonding *bond,
 	return ret;
 
 err_no_cmd:
-	pr_info("invalid input for queue_id set for %s.\n",
-		bond->dev->name);
+	pr_info("invalid input for queue_id set for %s\n", bond->dev->name);
 	ret = -EPERM;
 	goto out;
 
@@ -1253,7 +1245,7 @@ int bond_option_slaves_set(struct bonding *bond, struct bond_opt_value *newval)
 
 	dev = __dev_get_by_name(dev_net(bond->dev), ifname);
 	if (!dev) {
-		pr_info("%s: Interface %s does not exist!\n",
+		pr_info("%s: interface %s does not exist!\n",
 			bond->dev->name, ifname);
 		ret = -ENODEV;
 		goto out;
@@ -1261,12 +1253,12 @@ int bond_option_slaves_set(struct bonding *bond, struct bond_opt_value *newval)
 
 	switch (command[0]) {
 	case '+':
-		pr_info("%s: Adding slave %s.\n", bond->dev->name, dev->name);
+		pr_info("%s: Adding slave %s\n", bond->dev->name, dev->name);
 		ret = bond_enslave(bond->dev, dev);
 		break;
 
 	case '-':
-		pr_info("%s: Removing slave %s.\n", bond->dev->name, dev->name);
+		pr_info("%s: Removing slave %s\n", bond->dev->name, dev->name);
 		ret = bond_release(bond->dev, dev);
 		break;
 
@@ -1278,7 +1270,7 @@ int bond_option_slaves_set(struct bonding *bond, struct bond_opt_value *newval)
 	return ret;
 
 err_no_cmd:
-	pr_err("no command found in slaves file for bond %s. Use +ifname or -ifname.\n",
+	pr_err("no command found in slaves file for bond %s - use +ifname or -ifname\n",
 	       bond->dev->name);
 	ret = -EPERM;
 	goto out;

commit eb2d4c64879c99fc78e739b0147db28731ff474e
Author: Mike Galbraith <bitbucket@online.de>
Date:   Fri Feb 14 08:21:04 2014 +0100

    net,bonding: fix bond_options.c direct rwlock.h include
    
    drivers/net/bonding/bond_options.c includes rwlock.h directly,
    which is a nono, and which also breaks RT kernel build.
    
    Signed-off-by: Mike Galbraith <bitbucket@online.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 11cb943222d5..c37878432717 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -14,7 +14,7 @@
 #include <linux/errno.h>
 #include <linux/if.h>
 #include <linux/netdevice.h>
-#include <linux/rwlock.h>
+#include <linux/spinlock.h>
 #include <linux/rcupdate.h>
 #include <linux/ctype.h>
 #include <linux/inet.h>

commit c313c89edb93eeac0646dcc6d6cb7fb404d4056d
Author: dingtianhong <dingtianhong@huawei.com>
Date:   Wed Feb 12 14:58:50 2014 +0800

    bonding: remove the redundant judgements for bond_option_queue_id_set()
    
    The dev_valid_name() will check the buffer length for input name, no need to
    check it twice.
    
    Cc: Jay Vosburgh <fubar@us.ibm.com>
    Cc: Veaceslav Falico <vfalico@redhat.com>
    Cc: Andy Gospodarek <andy@greyhouse.net>
    Signed-off-by: Ding Tianhong <dingtianhong@huawei.com>
    Reviewed-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 11cb943222d5..832d6e90b1b9 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -1199,8 +1199,7 @@ int bond_option_queue_id_set(struct bonding *bond,
 		goto err_no_cmd;
 
 	/* Check buffer length, valid ifname and queue id */
-	if (strlen(newval->string) > IFNAMSIZ ||
-	    !dev_valid_name(newval->string) ||
+	if (!dev_valid_name(newval->string) ||
 	    qid > bond->dev->real_num_tx_queues)
 		goto err_no_cmd;
 

commit 0681a28264dcf948e0236adb7bf505a638c4dec1
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Thu Jan 23 23:43:43 2014 +0100

    bonding: fix u64 division
    
    After the option conversion downdelay and updelay divide a u64
    and on a 32 bit this causes the following errors:
    ERROR: "__udivdi3" [drivers/net/bonding/bonding.ko] undefined!
    ERROR: "__umoddi3" [drivers/net/bonding/bonding.ko] undefined!
    
    Fix it by using a normal int instead because newval->value is capped
    at INT_MAX by the way the option is defined.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 4cee04aa6eb3..11cb943222d5 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -727,19 +727,21 @@ int bond_option_miimon_set(struct bonding *bond, struct bond_opt_value *newval)
 
 int bond_option_updelay_set(struct bonding *bond, struct bond_opt_value *newval)
 {
+	int value = newval->value;
+
 	if (!bond->params.miimon) {
 		pr_err("%s: Unable to set up delay as MII monitoring is disabled\n",
 		       bond->dev->name);
 		return -EPERM;
 	}
-	if ((newval->value % bond->params.miimon) != 0) {
-		pr_warn("%s: Warning: up delay (%llu) is not a multiple of miimon (%d), updelay rounded to %llu ms\n",
-			bond->dev->name, newval->value,
+	if ((value % bond->params.miimon) != 0) {
+		pr_warn("%s: Warning: up delay (%d) is not a multiple of miimon (%d), updelay rounded to %d ms\n",
+			bond->dev->name, value,
 			bond->params.miimon,
-			(newval->value / bond->params.miimon) *
+			(value / bond->params.miimon) *
 			bond->params.miimon);
 	}
-	bond->params.updelay = newval->value / bond->params.miimon;
+	bond->params.updelay = value / bond->params.miimon;
 	pr_info("%s: Setting up delay to %d.\n",
 		bond->dev->name,
 		bond->params.updelay * bond->params.miimon);
@@ -750,19 +752,21 @@ int bond_option_updelay_set(struct bonding *bond, struct bond_opt_value *newval)
 int bond_option_downdelay_set(struct bonding *bond,
 			      struct bond_opt_value *newval)
 {
+	int value = newval->value;
+
 	if (!bond->params.miimon) {
 		pr_err("%s: Unable to set down delay as MII monitoring is disabled\n",
 		       bond->dev->name);
 		return -EPERM;
 	}
-	if ((newval->value % bond->params.miimon) != 0) {
-		pr_warn("%s: Warning: down delay (%llu) is not a multiple of miimon (%d), delay rounded to %llu ms\n",
-			bond->dev->name, newval->value,
+	if ((value % bond->params.miimon) != 0) {
+		pr_warn("%s: Warning: down delay (%d) is not a multiple of miimon (%d), delay rounded to %d ms\n",
+			bond->dev->name, value,
 			bond->params.miimon,
-			(newval->value / bond->params.miimon) *
+			(value / bond->params.miimon) *
 			bond->params.miimon);
 	}
-	bond->params.downdelay = newval->value / bond->params.miimon;
+	bond->params.downdelay = value / bond->params.miimon;
 	pr_info("%s: Setting down delay to %d.\n",
 		bond->dev->name,
 		bond->params.downdelay * bond->params.miimon);

commit c59ab673699b6dcf457caea46799679e2526917c
Author: dingtianhong <dingtianhong@huawei.com>
Date:   Sat Jan 18 16:28:52 2014 +0800

    bonding: clean the primary slave if there is no slave matching new primary
    
    If the new primay is not matching any slave in the bond, the bond should
    record it to params, clean the primary slave and select a new active slave.
    
    Signed-off-by: Ding Tianhong <dingtianhong@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 05a402c99bff..4cee04aa6eb3 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -1021,6 +1021,12 @@ int bond_option_primary_set(struct bonding *bond, struct bond_opt_value *newval)
 		}
 	}
 
+	if (bond->primary_slave) {
+		pr_info("%s: Setting primary slave to None.\n",
+			bond->dev->name);
+		bond->primary_slave = NULL;
+		bond_select_active_slave(bond);
+	}
 	strncpy(bond->params.primary, primary, IFNAMSIZ);
 	bond->params.primary[IFNAMSIZ - 1] = 0;
 

commit 0e2e5b66e9de377d69f50a456fdd60462889c64f
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Wed Jan 22 14:53:40 2014 +0100

    bonding: convert slaves to use the new option API
    
    This patch adds the necessary changes so slaves would use
    the new bonding option API. Also move the option to its own set function
    in bond_options.c and fix some style errors.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 60d700139811..05a402c99bff 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -300,6 +300,13 @@ static struct bond_option bond_opts[] = {
 		.values = bond_lp_interval_tbl,
 		.set = bond_option_lp_interval_set
 	},
+	[BOND_OPT_SLAVES] = {
+		.id = BOND_OPT_SLAVES,
+		.name = "slaves",
+		.desc = "Slave membership management",
+		.flags = BOND_OPTFLAG_RAWVAL,
+		.set = bond_option_slaves_set
+	},
 	{ }
 };
 
@@ -1221,3 +1228,49 @@ int bond_option_queue_id_set(struct bonding *bond,
 	goto out;
 
 }
+
+int bond_option_slaves_set(struct bonding *bond, struct bond_opt_value *newval)
+{
+	char command[IFNAMSIZ + 1] = { 0, };
+	struct net_device *dev;
+	char *ifname;
+	int ret;
+
+	sscanf(newval->string, "%16s", command); /* IFNAMSIZ*/
+	ifname = command + 1;
+	if ((strlen(command) <= 1) ||
+	    !dev_valid_name(ifname))
+		goto err_no_cmd;
+
+	dev = __dev_get_by_name(dev_net(bond->dev), ifname);
+	if (!dev) {
+		pr_info("%s: Interface %s does not exist!\n",
+			bond->dev->name, ifname);
+		ret = -ENODEV;
+		goto out;
+	}
+
+	switch (command[0]) {
+	case '+':
+		pr_info("%s: Adding slave %s.\n", bond->dev->name, dev->name);
+		ret = bond_enslave(bond->dev, dev);
+		break;
+
+	case '-':
+		pr_info("%s: Removing slave %s.\n", bond->dev->name, dev->name);
+		ret = bond_release(bond->dev, dev);
+		break;
+
+	default:
+		goto err_no_cmd;
+	}
+
+out:
+	return ret;
+
+err_no_cmd:
+	pr_err("no command found in slaves file for bond %s. Use +ifname or -ifname.\n",
+	       bond->dev->name);
+	ret = -EPERM;
+	goto out;
+}

commit 4325b374f84e59226851636df946f2500d0bfeba
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Wed Jan 22 14:53:39 2014 +0100

    bonding: convert lp_interval to use the new option API
    
    This patch adds the necessary changes so lp_interval would use
    the new bonding option API.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 1373093d1c6a..60d700139811 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -118,6 +118,11 @@ static struct bond_opt_value bond_resend_igmp_tbl[] = {
 	{ NULL,      -1,  0}
 };
 
+static struct bond_opt_value bond_lp_interval_tbl[] = {
+	{ "minval",  1,       BOND_VALFLAG_MIN | BOND_VALFLAG_DEFAULT},
+	{ "maxval",  INT_MAX, BOND_VALFLAG_MAX},
+};
+
 static struct bond_option bond_opts[] = {
 	[BOND_OPT_MODE] = {
 		.id = BOND_OPT_MODE,
@@ -288,6 +293,13 @@ static struct bond_option bond_opts[] = {
 		.values = bond_resend_igmp_tbl,
 		.set = bond_option_resend_igmp_set
 	},
+	[BOND_OPT_LP_INTERVAL] = {
+		.id = BOND_OPT_LP_INTERVAL,
+		.name = "lp_interval",
+		.desc = "The number of seconds between instances where the bonding driver sends learning packets to each slave's peer switch",
+		.values = bond_lp_interval_tbl,
+		.set = bond_option_lp_interval_set
+	},
 	{ }
 };
 
@@ -1101,15 +1113,10 @@ int bond_option_min_links_set(struct bonding *bond,
 	return 0;
 }
 
-int bond_option_lp_interval_set(struct bonding *bond, int lp_interval)
+int bond_option_lp_interval_set(struct bonding *bond,
+				struct bond_opt_value *newval)
 {
-	if (lp_interval <= 0) {
-		pr_err("%s: lp_interval must be between 1 and %d\n",
-		       bond->dev->name, INT_MAX);
-		return -EINVAL;
-	}
-
-	bond->params.lp_interval = lp_interval;
+	bond->params.lp_interval = newval->value;
 
 	return 0;
 }

commit 105c8fb6c55e9c5055798184cbb5ef61343139b4
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Wed Jan 22 14:53:38 2014 +0100

    bonding: convert resend_igmp to use the new option API
    
    This patch adds the necessary changes so resend_igmp would use
    the new bonding option API.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 7fafc34ca47b..1373093d1c6a 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -111,6 +111,13 @@ static struct bond_opt_value bond_all_slaves_active_tbl[] = {
 	{ NULL,  -1, 0}
 };
 
+static struct bond_opt_value bond_resend_igmp_tbl[] = {
+	{ "off",     0,   0},
+	{ "maxval",  255, BOND_VALFLAG_MAX},
+	{ "default", 1,   BOND_VALFLAG_DEFAULT},
+	{ NULL,      -1,  0}
+};
+
 static struct bond_option bond_opts[] = {
 	[BOND_OPT_MODE] = {
 		.id = BOND_OPT_MODE,
@@ -274,6 +281,13 @@ static struct bond_option bond_opts[] = {
 		.values = bond_all_slaves_active_tbl,
 		.set = bond_option_all_slaves_active_set
 	},
+	[BOND_OPT_RESEND_IGMP] = {
+		.id = BOND_OPT_RESEND_IGMP,
+		.name = "resend_igmp",
+		.desc = "Number of IGMP membership reports to send on link failure",
+		.values = bond_resend_igmp_tbl,
+		.set = bond_option_resend_igmp_set
+	},
 	{ }
 };
 
@@ -1038,17 +1052,12 @@ int bond_option_xmit_hash_policy_set(struct bonding *bond,
 	return 0;
 }
 
-int bond_option_resend_igmp_set(struct bonding *bond, int resend_igmp)
+int bond_option_resend_igmp_set(struct bonding *bond,
+				struct bond_opt_value *newval)
 {
-	if (resend_igmp < 0 || resend_igmp > 255) {
-		pr_err("%s: Invalid resend_igmp value %d not in range 0-255; rejected.\n",
-		       bond->dev->name, resend_igmp);
-		return -EINVAL;
-	}
-
-	bond->params.resend_igmp = resend_igmp;
-	pr_info("%s: Setting resend_igmp to %d.\n",
-		bond->dev->name, resend_igmp);
+	pr_info("%s: Setting resend_igmp to %llu.\n",
+		bond->dev->name, newval->value);
+	bond->params.resend_igmp = newval->value;
 
 	return 0;
 }

commit 3df011625135fa1c670cb8e24618fc7ca38e00b0
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Wed Jan 22 14:53:37 2014 +0100

    bonding: convert all_slaves_active to use the new option API
    
    This patch adds the necessary changes so all_slaves_active would use
    the new bonding option API.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 8775c724c700..7fafc34ca47b 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -105,6 +105,12 @@ static struct bond_opt_value bond_use_carrier_tbl[] = {
 	{ NULL,  -1, 0}
 };
 
+static struct bond_opt_value bond_all_slaves_active_tbl[] = {
+	{ "off", 0,  BOND_VALFLAG_DEFAULT},
+	{ "on",  1,  0},
+	{ NULL,  -1, 0}
+};
+
 static struct bond_option bond_opts[] = {
 	[BOND_OPT_MODE] = {
 		.id = BOND_OPT_MODE,
@@ -261,6 +267,13 @@ static struct bond_option bond_opts[] = {
 		.flags = BOND_OPTFLAG_RAWVAL,
 		.set = bond_option_queue_id_set
 	},
+	[BOND_OPT_ALL_SLAVES_ACTIVE] = {
+		.id = BOND_OPT_ALL_SLAVES_ACTIVE,
+		.name = "all_slaves_active",
+		.desc = "Keep all frames received on an interface by setting active flag for all slaves",
+		.values = bond_all_slaves_active_tbl,
+		.set = bond_option_all_slaves_active_set
+	},
 	{ }
 };
 
@@ -1049,25 +1062,17 @@ int bond_option_num_peer_notif_set(struct bonding *bond,
 }
 
 int bond_option_all_slaves_active_set(struct bonding *bond,
-				      int all_slaves_active)
+				      struct bond_opt_value *newval)
 {
 	struct list_head *iter;
 	struct slave *slave;
 
-	if (all_slaves_active == bond->params.all_slaves_active)
+	if (newval->value == bond->params.all_slaves_active)
 		return 0;
-
-	if ((all_slaves_active == 0) || (all_slaves_active == 1)) {
-		bond->params.all_slaves_active = all_slaves_active;
-	} else {
-		pr_info("%s: Ignoring invalid all_slaves_active value %d.\n",
-			bond->dev->name, all_slaves_active);
-		return -EINVAL;
-	}
-
+	bond->params.all_slaves_active = newval->value;
 	bond_for_each_slave(bond, slave, iter) {
 		if (!bond_is_active_slave(slave)) {
-			if (all_slaves_active)
+			if (newval->value)
 				slave->inactive = 0;
 			else
 				slave->inactive = 1;

commit 24089ba1026a684d64bc0eeb6af634e26c9501c4
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Wed Jan 22 14:53:36 2014 +0100

    bonding: convert queue_id to use the new option API
    
    This patch adds the necessary changes so queue_id would use
    the new bonding option API. Also move it to its own set function in
    bond_options.c and fix some style errors.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 2315104de8c0..8775c724c700 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -254,6 +254,13 @@ static struct bond_option bond_opts[] = {
 						BIT(BOND_MODE_ALB)),
 		.set = bond_option_active_slave_set
 	},
+	[BOND_OPT_QUEUE_ID] = {
+		.id = BOND_OPT_QUEUE_ID,
+		.name = "queue_id",
+		.desc = "Set queue id of a slave",
+		.flags = BOND_OPTFLAG_RAWVAL,
+		.set = bond_option_queue_id_set
+	},
 	{ }
 };
 
@@ -1130,3 +1137,66 @@ int bond_option_ad_select_set(struct bonding *bond,
 
 	return 0;
 }
+
+int bond_option_queue_id_set(struct bonding *bond,
+			     struct bond_opt_value *newval)
+{
+	struct slave *slave, *update_slave;
+	struct net_device *sdev;
+	struct list_head *iter;
+	char *delim;
+	int ret = 0;
+	u16 qid;
+
+	/* delim will point to queue id if successful */
+	delim = strchr(newval->string, ':');
+	if (!delim)
+		goto err_no_cmd;
+
+	/* Terminate string that points to device name and bump it
+	 * up one, so we can read the queue id there.
+	 */
+	*delim = '\0';
+	if (sscanf(++delim, "%hd\n", &qid) != 1)
+		goto err_no_cmd;
+
+	/* Check buffer length, valid ifname and queue id */
+	if (strlen(newval->string) > IFNAMSIZ ||
+	    !dev_valid_name(newval->string) ||
+	    qid > bond->dev->real_num_tx_queues)
+		goto err_no_cmd;
+
+	/* Get the pointer to that interface if it exists */
+	sdev = __dev_get_by_name(dev_net(bond->dev), newval->string);
+	if (!sdev)
+		goto err_no_cmd;
+
+	/* Search for thes slave and check for duplicate qids */
+	update_slave = NULL;
+	bond_for_each_slave(bond, slave, iter) {
+		if (sdev == slave->dev)
+			/* We don't need to check the matching
+			 * slave for dups, since we're overwriting it
+			 */
+			update_slave = slave;
+		else if (qid && qid == slave->queue_id) {
+			goto err_no_cmd;
+		}
+	}
+
+	if (!update_slave)
+		goto err_no_cmd;
+
+	/* Actually set the qids for the slave */
+	update_slave->queue_id = qid;
+
+out:
+	return ret;
+
+err_no_cmd:
+	pr_info("invalid input for queue_id set for %s.\n",
+		bond->dev->name);
+	ret = -EPERM;
+	goto out;
+
+}

commit d1fbd3ed9366904b58b1c0c30b22d51dc793de99
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Wed Jan 22 14:53:35 2014 +0100

    bonding: convert active_slave to use the new option API
    
    This patch adds the necessary changes so active_slave would use
    the new bonding option API. Also some trivial/style fixes.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 18b1cc0d8b80..2315104de8c0 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -244,6 +244,16 @@ static struct bond_option bond_opts[] = {
 		.values = bond_use_carrier_tbl,
 		.set = bond_option_use_carrier_set
 	},
+	[BOND_OPT_ACTIVE_SLAVE] = {
+		.id = BOND_OPT_ACTIVE_SLAVE,
+		.name = "active_slave",
+		.desc = "Currently active slave",
+		.flags = BOND_OPTFLAG_RAWVAL,
+		.unsuppmodes = BOND_MODE_ALL_EX(BIT(BOND_MODE_ACTIVEBACKUP) |
+						BIT(BOND_MODE_TLB) |
+						BIT(BOND_MODE_ALB)),
+		.set = bond_option_active_slave_set
+	},
 	{ }
 };
 
@@ -556,10 +566,21 @@ struct net_device *bond_option_active_slave_get(struct bonding *bond)
 }
 
 int bond_option_active_slave_set(struct bonding *bond,
-				 struct net_device *slave_dev)
+				 struct bond_opt_value *newval)
 {
+	char ifname[IFNAMSIZ] = { 0, };
+	struct net_device *slave_dev;
 	int ret = 0;
 
+	sscanf(newval->string, "%15s", ifname); /* IFNAMSIZ */
+	if (!strlen(ifname) || newval->string[0] == '\n') {
+		slave_dev = NULL;
+	} else {
+		slave_dev = __dev_get_by_name(dev_net(bond->dev), ifname);
+		if (!slave_dev)
+			return -ENODEV;
+	}
+
 	if (slave_dev) {
 		if (!netif_is_bond_slave(slave_dev)) {
 			pr_err("Device %s is not bonding slave.\n",
@@ -574,12 +595,6 @@ int bond_option_active_slave_set(struct bonding *bond,
 		}
 	}
 
-	if (!USES_PRIMARY(bond->params.mode)) {
-		pr_err("%s: Unable to change active slave; %s is in mode %d\n",
-		       bond->dev->name, bond->dev->name, bond->params.mode);
-		return -EINVAL;
-	}
-
 	block_netpoll_tx();
 	write_lock_bh(&bond->curr_slave_lock);
 
@@ -616,6 +631,7 @@ int bond_option_active_slave_set(struct bonding *bond,
 
 	write_unlock_bh(&bond->curr_slave_lock);
 	unblock_netpoll_tx();
+
 	return ret;
 }
 

commit 0fff060877426f3faf6754c201e28cd5b34756c0
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Wed Jan 22 14:53:34 2014 +0100

    bonding: convert use_carrier to use the new option API
    
    This patch adds the necessary changes so use_carrier would use
    the new bonding option API.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index eaa3d4057cd3..18b1cc0d8b80 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -99,6 +99,12 @@ static struct bond_opt_value bond_primary_reselect_tbl[] = {
 	{ NULL,      -1},
 };
 
+static struct bond_opt_value bond_use_carrier_tbl[] = {
+	{ "off", 0,  0},
+	{ "on",  1,  BOND_VALFLAG_DEFAULT},
+	{ NULL,  -1, 0}
+};
+
 static struct bond_option bond_opts[] = {
 	[BOND_OPT_MODE] = {
 		.id = BOND_OPT_MODE,
@@ -231,6 +237,13 @@ static struct bond_option bond_opts[] = {
 		.values = bond_primary_reselect_tbl,
 		.set = bond_option_primary_reselect_set
 	},
+	[BOND_OPT_USE_CARRIER] = {
+		.id = BOND_OPT_USE_CARRIER,
+		.name = "use_carrier",
+		.desc = "Use netif_carrier_ok (vs MII ioctls) in miimon",
+		.values = bond_use_carrier_tbl,
+		.set = bond_option_use_carrier_set
+	},
 	{ }
 };
 
@@ -688,16 +701,12 @@ int bond_option_downdelay_set(struct bonding *bond,
 	return 0;
 }
 
-int bond_option_use_carrier_set(struct bonding *bond, int use_carrier)
+int bond_option_use_carrier_set(struct bonding *bond,
+				struct bond_opt_value *newval)
 {
-	if ((use_carrier == 0) || (use_carrier == 1)) {
-		bond->params.use_carrier = use_carrier;
-		pr_info("%s: Setting use_carrier to %d.\n",
-			bond->dev->name, use_carrier);
-	} else {
-		pr_info("%s: Ignoring invalid use_carrier value %d.\n",
-			bond->dev->name, use_carrier);
-	}
+	pr_info("%s: Setting use_carrier to %llu.\n",
+		bond->dev->name, newval->value);
+	bond->params.use_carrier = newval->value;
 
 	return 0;
 }

commit 388d3a6d4aa356b885bcd023c185060df9ea2484
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Wed Jan 22 14:53:33 2014 +0100

    bonding: convert primary_reselect to use the new option API
    
    This patch adds the necessary changes so primary_reselect would use
    the new bonding option API.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index f094a313adb3..eaa3d4057cd3 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -92,6 +92,13 @@ static struct bond_opt_value bond_num_peer_notif_tbl[] = {
 	{ NULL,      -1,  0}
 };
 
+static struct bond_opt_value bond_primary_reselect_tbl[] = {
+	{ "always",  BOND_PRI_RESELECT_ALWAYS,  BOND_VALFLAG_DEFAULT},
+	{ "better",  BOND_PRI_RESELECT_BETTER,  0},
+	{ "failure", BOND_PRI_RESELECT_FAILURE, 0},
+	{ NULL,      -1},
+};
+
 static struct bond_option bond_opts[] = {
 	[BOND_OPT_MODE] = {
 		.id = BOND_OPT_MODE,
@@ -217,6 +224,13 @@ static struct bond_option bond_opts[] = {
 						BIT(BOND_MODE_ALB)),
 		.set = bond_option_primary_set
 	},
+	[BOND_OPT_PRIMARY_RESELECT] = {
+		.id = BOND_OPT_PRIMARY_RESELECT,
+		.name = "primary_reselect",
+		.desc = "Reselect primary slave once it comes up",
+		.values = bond_primary_reselect_tbl,
+		.set = bond_option_primary_reselect_set
+	},
 	{ }
 };
 
@@ -943,18 +957,12 @@ int bond_option_primary_set(struct bonding *bond, struct bond_opt_value *newval)
 	return 0;
 }
 
-int bond_option_primary_reselect_set(struct bonding *bond, int primary_reselect)
+int bond_option_primary_reselect_set(struct bonding *bond,
+				     struct bond_opt_value *newval)
 {
-	if (bond_parm_tbl_lookup(primary_reselect, pri_reselect_tbl) < 0) {
-		pr_err("%s: Ignoring invalid primary_reselect value %d.\n",
-		       bond->dev->name, primary_reselect);
-		return -EINVAL;
-	}
-
-	bond->params.primary_reselect = primary_reselect;
-	pr_info("%s: setting primary_reselect to %s (%d).\n",
-		bond->dev->name, pri_reselect_tbl[primary_reselect].modename,
-		primary_reselect);
+	pr_info("%s: setting primary_reselect to %s (%llu).\n",
+		bond->dev->name, newval->string, newval->value);
+	bond->params.primary_reselect = newval->value;
 
 	block_netpoll_tx();
 	write_lock_bh(&bond->curr_slave_lock);

commit 180222f08861d8206b3ff1c6392101e29d4ae161
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Wed Jan 22 14:53:32 2014 +0100

    bonding: convert primary to use the new option API
    
    This patch adds the necessary changes so primary would use
    the new bonding option API.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index cb515d94864d..f094a313adb3 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -207,6 +207,16 @@ static struct bond_option bond_opts[] = {
 		.values = bond_intmax_tbl,
 		.set = bond_option_miimon_set
 	},
+	[BOND_OPT_PRIMARY] = {
+		.id = BOND_OPT_PRIMARY,
+		.name = "primary",
+		.desc = "Primary network device to use",
+		.flags = BOND_OPTFLAG_RAWVAL,
+		.unsuppmodes = BOND_MODE_ALL_EX(BIT(BOND_MODE_ACTIVEBACKUP) |
+						BIT(BOND_MODE_TLB) |
+						BIT(BOND_MODE_ALB)),
+		.set = bond_option_primary_set
+	},
 	{ }
 };
 
@@ -885,23 +895,19 @@ int bond_option_arp_all_targets_set(struct bonding *bond,
 	return 0;
 }
 
-int bond_option_primary_set(struct bonding *bond, const char *primary)
+int bond_option_primary_set(struct bonding *bond, struct bond_opt_value *newval)
 {
+	char *p, *primary = newval->string;
 	struct list_head *iter;
 	struct slave *slave;
-	int err = 0;
 
 	block_netpoll_tx();
 	read_lock(&bond->lock);
 	write_lock_bh(&bond->curr_slave_lock);
 
-	if (!USES_PRIMARY(bond->params.mode)) {
-		pr_err("%s: Unable to set primary slave; %s is in mode %d\n",
-		       bond->dev->name, bond->dev->name, bond->params.mode);
-		err = -EINVAL;
-		goto out;
-	}
-
+	p = strchr(primary, '\n');
+	if (p)
+		*p = '\0';
 	/* check to see if we are clearing primary */
 	if (!strlen(primary)) {
 		pr_info("%s: Setting primary slave to None.\n",
@@ -934,7 +940,7 @@ int bond_option_primary_set(struct bonding *bond, const char *primary)
 	read_unlock(&bond->lock);
 	unblock_netpoll_tx();
 
-	return err;
+	return 0;
 }
 
 int bond_option_primary_reselect_set(struct bonding *bond, int primary_reselect)

commit b98d9c66e1c3823c50a3cd5e8e59f12b97d7ba5d
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Wed Jan 22 14:53:31 2014 +0100

    bonding: convert miimon to use the new option API
    
    This patch adds the necessary changes so miimon would use
    the new bonding option API. The "default" definition has been removed as
    it was 0.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 1bd19f1f1af2..cb515d94864d 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -200,6 +200,13 @@ static struct bond_option bond_opts[] = {
 		.values = bond_num_peer_notif_tbl,
 		.set = bond_option_num_peer_notif_set
 	},
+	[BOND_OPT_MIIMON] = {
+		.id = BOND_OPT_MIIMON,
+		.name = "miimon",
+		.desc = "Link check interval in milliseconds",
+		.values = bond_intmax_tbl,
+		.set = bond_option_miimon_set
+	},
 	{ }
 };
 
@@ -575,16 +582,11 @@ int bond_option_active_slave_set(struct bonding *bond,
 	return ret;
 }
 
-int bond_option_miimon_set(struct bonding *bond, int miimon)
+int bond_option_miimon_set(struct bonding *bond, struct bond_opt_value *newval)
 {
-	if (miimon < 0) {
-		pr_err("%s: Invalid miimon value %d not in range %d-%d; rejected.\n",
-		       bond->dev->name, miimon, 0, INT_MAX);
-		return -EINVAL;
-	}
-	pr_info("%s: Setting MII monitoring interval to %d.\n",
-		bond->dev->name, miimon);
-	bond->params.miimon = miimon;
+	pr_info("%s: Setting MII monitoring interval to %llu.\n",
+		bond->dev->name, newval->value);
+	bond->params.miimon = newval->value;
 	if (bond->params.updelay)
 		pr_info("%s: Note: Updating updelay (to %d) since it is a multiple of the miimon value.\n",
 			bond->dev->name,
@@ -593,7 +595,7 @@ int bond_option_miimon_set(struct bonding *bond, int miimon)
 		pr_info("%s: Note: Updating downdelay (to %d) since it is a multiple of the miimon value.\n",
 			bond->dev->name,
 			bond->params.downdelay * bond->params.miimon);
-	if (miimon && bond->params.arp_interval) {
+	if (newval->value && bond->params.arp_interval) {
 		pr_info("%s: MII monitoring cannot be used with ARP monitoring. Disabling ARP monitoring...\n",
 			bond->dev->name);
 		bond->params.arp_interval = 0;
@@ -606,13 +608,14 @@ int bond_option_miimon_set(struct bonding *bond, int miimon)
 		 * timer will get fired off when the open function
 		 * is called.
 		 */
-		if (!miimon) {
+		if (!newval->value) {
 			cancel_delayed_work_sync(&bond->mii_work);
 		} else {
 			cancel_delayed_work_sync(&bond->arp_work);
 			queue_delayed_work(bond->wq, &bond->mii_work, 0);
 		}
 	}
+
 	return 0;
 }
 

commit ef56becbb37251f0371ad94210f50dc90e18830a
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Wed Jan 22 14:53:30 2014 +0100

    bonding: convert num_peer_notif to use the new option API
    
    This patch adds the necessary changes so num_peer_notif would use
    the new bonding option API.
    When the auto-sysfs generation is done an alias should be added for
    this option as there're currently 2 entries in sysfs for it.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 081ab9b5d48a..1bd19f1f1af2 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -85,6 +85,13 @@ static struct bond_opt_value bond_ad_select_tbl[] = {
 	{ NULL,        -1,                0},
 };
 
+static struct bond_opt_value bond_num_peer_notif_tbl[] = {
+	{ "off",     0,   0},
+	{ "maxval",  255, BOND_VALFLAG_MAX},
+	{ "default", 1,   BOND_VALFLAG_DEFAULT},
+	{ NULL,      -1,  0}
+};
+
 static struct bond_option bond_opts[] = {
 	[BOND_OPT_MODE] = {
 		.id = BOND_OPT_MODE,
@@ -186,6 +193,13 @@ static struct bond_option bond_opts[] = {
 		.values = bond_ad_select_tbl,
 		.set = bond_option_ad_select_set
 	},
+	[BOND_OPT_NUM_PEER_NOTIF] = {
+		.id = BOND_OPT_NUM_PEER_NOTIF,
+		.name = "num_unsol_na",
+		.desc = "Number of peer notifications to send on failover event",
+		.values = bond_num_peer_notif_tbl,
+		.set = bond_option_num_peer_notif_set
+	},
 	{ }
 };
 
@@ -977,9 +991,11 @@ int bond_option_resend_igmp_set(struct bonding *bond, int resend_igmp)
 	return 0;
 }
 
-int bond_option_num_peer_notif_set(struct bonding *bond, int num_peer_notif)
+int bond_option_num_peer_notif_set(struct bonding *bond,
+				   struct bond_opt_value *newval)
 {
-	bond->params.num_peer_notif = num_peer_notif;
+	bond->params.num_peer_notif = newval->value;
+
 	return 0;
 }
 

commit 9e5f5eebe765b340af0318dba261e5de0f2aaf32
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Wed Jan 22 14:53:29 2014 +0100

    bonding: convert ad_select to use the new option API
    
    This patch adds the necessary changes so ad_select would use
    the new bonding option API.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index f8821696f823..081ab9b5d48a 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -78,6 +78,13 @@ static struct bond_opt_value bond_lacp_rate_tbl[] = {
 	{ NULL,   -1,           0},
 };
 
+static struct bond_opt_value bond_ad_select_tbl[] = {
+	{ "stable",    BOND_AD_STABLE,    BOND_VALFLAG_DEFAULT},
+	{ "bandwidth", BOND_AD_BANDWIDTH, 0},
+	{ "count",     BOND_AD_COUNT,     0},
+	{ NULL,        -1,                0},
+};
+
 static struct bond_option bond_opts[] = {
 	[BOND_OPT_MODE] = {
 		.id = BOND_OPT_MODE,
@@ -171,6 +178,14 @@ static struct bond_option bond_opts[] = {
 		.values = bond_intmax_tbl,
 		.set = bond_option_min_links_set
 	},
+	[BOND_OPT_AD_SELECT] = {
+		.id = BOND_OPT_AD_SELECT,
+		.name = "ad_select",
+		.desc = "803.ad aggregation selection logic",
+		.flags = BOND_OPTFLAG_IFDOWN,
+		.values = bond_ad_select_tbl,
+		.set = bond_option_ad_select_set
+	},
 	{ }
 };
 
@@ -1048,24 +1063,12 @@ int bond_option_lacp_rate_set(struct bonding *bond,
 	return 0;
 }
 
-int bond_option_ad_select_set(struct bonding *bond, int ad_select)
+int bond_option_ad_select_set(struct bonding *bond,
+			      struct bond_opt_value *newval)
 {
-	if (bond_parm_tbl_lookup(ad_select, ad_select_tbl) < 0) {
-		pr_err("%s: Ignoring invalid ad_select value %d.\n",
-		       bond->dev->name, ad_select);
-		return -EINVAL;
-	}
-
-	if (bond->dev->flags & IFF_UP) {
-		pr_err("%s: Unable to update ad_select because interface is up.\n",
-		       bond->dev->name);
-		return -EPERM;
-	}
-
-	bond->params.ad_select = ad_select;
-	pr_info("%s: Setting ad_select to %s (%d).\n",
-		bond->dev->name, ad_select_tbl[ad_select].modename,
-		ad_select);
+	pr_info("%s: Setting ad_select to %s (%llu).\n",
+		bond->dev->name, newval->string, newval->value);
+	bond->params.ad_select = newval->value;
 
 	return 0;
 }

commit 633ddc9e9bafd168861dee1000b2c6ff725e85c5
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Wed Jan 22 14:53:28 2014 +0100

    bonding: convert min_links to use the new option API
    
    This patch adds the necessary changes so min_links would use
    the new bonding option API.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 680296c279dc..f8821696f823 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -164,6 +164,13 @@ static struct bond_option bond_opts[] = {
 		.values = bond_lacp_rate_tbl,
 		.set = bond_option_lacp_rate_set
 	},
+	[BOND_OPT_MINLINKS] = {
+		.id = BOND_OPT_MINLINKS,
+		.name = "min_links",
+		.desc = "Minimum number of available links before turning on carrier",
+		.values = bond_intmax_tbl,
+		.set = bond_option_min_links_set
+	},
 	{ }
 };
 
@@ -990,11 +997,12 @@ int bond_option_all_slaves_active_set(struct bonding *bond,
 	return 0;
 }
 
-int bond_option_min_links_set(struct bonding *bond, int min_links)
+int bond_option_min_links_set(struct bonding *bond,
+			      struct bond_opt_value *newval)
 {
-	pr_info("%s: Setting min links value to %u\n",
-		bond->dev->name, min_links);
-	bond->params.min_links = min_links;
+	pr_info("%s: Setting min links value to %llu\n",
+		bond->dev->name, newval->value);
+	bond->params.min_links = newval->value;
 
 	return 0;
 }

commit d3131de76b1b1a4d95f145846bd61f96e72f0411
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Wed Jan 22 14:53:27 2014 +0100

    bonding: convert lacp_rate to use the new option API
    
    This patch adds the necessary changes so lacp_rate would use
    the new bonding option API. Also some trivial/style error fixes.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 9cc21628032f..680296c279dc 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -72,6 +72,12 @@ static struct bond_opt_value bond_intmax_tbl[] = {
 	{ "maxval",  INT_MAX, BOND_VALFLAG_MAX},
 };
 
+static struct bond_opt_value bond_lacp_rate_tbl[] = {
+	{ "slow", AD_LACP_SLOW, 0},
+	{ "fast", AD_LACP_FAST, 0},
+	{ NULL,   -1,           0},
+};
+
 static struct bond_option bond_opts[] = {
 	[BOND_OPT_MODE] = {
 		.id = BOND_OPT_MODE,
@@ -149,7 +155,15 @@ static struct bond_option bond_opts[] = {
 		.values = bond_intmax_tbl,
 		.set = bond_option_updelay_set
 	},
-
+	[BOND_OPT_LACP_RATE] = {
+		.id = BOND_OPT_LACP_RATE,
+		.name = "lacp_rate",
+		.desc = "LACPDU tx rate to request from 802.3ad partner",
+		.flags = BOND_OPTFLAG_IFDOWN,
+		.unsuppmodes = BOND_MODE_ALL_EX(BIT(BOND_MODE_8023AD)),
+		.values = bond_lacp_rate_tbl,
+		.set = bond_option_lacp_rate_set
+	},
 	{ }
 };
 
@@ -1015,31 +1029,13 @@ int bond_option_pps_set(struct bonding *bond, struct bond_opt_value *newval)
 	return 0;
 }
 
-int bond_option_lacp_rate_set(struct bonding *bond, int lacp_rate)
+int bond_option_lacp_rate_set(struct bonding *bond,
+			      struct bond_opt_value *newval)
 {
-	if (bond_parm_tbl_lookup(lacp_rate, bond_lacp_tbl) < 0) {
-		pr_err("%s: Ignoring invalid LACP rate value %d.\n",
-		       bond->dev->name, lacp_rate);
-		return -EINVAL;
-	}
-
-	if (bond->dev->flags & IFF_UP) {
-		pr_err("%s: Unable to update LACP rate because interface is up.\n",
-		       bond->dev->name);
-		return -EPERM;
-	}
-
-	if (bond->params.mode != BOND_MODE_8023AD) {
-		pr_err("%s: Unable to update LACP rate because bond is not in 802.3ad mode.\n",
-		       bond->dev->name);
-		return -EPERM;
-	}
-
-	bond->params.lacp_fast = lacp_rate;
+	pr_info("%s: Setting LACP rate to %s (%llu).\n",
+		bond->dev->name, newval->string, newval->value);
+	bond->params.lacp_fast = newval->value;
 	bond_3ad_update_lacp_rate(bond);
-	pr_info("%s: Setting LACP rate to %s (%d).\n",
-		bond->dev->name, bond_lacp_tbl[lacp_rate].modename,
-		lacp_rate);
 
 	return 0;
 }

commit e499461275023e20c4aecb6a546e7e213631b99f
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Wed Jan 22 14:53:26 2014 +0100

    bonding: convert updelay to use the new option API
    
    This patch adds the necessary changes so updelay would use
    the new bonding option API. Also some trivial style fixes.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 03514f7e17b9..9cc21628032f 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -142,6 +142,14 @@ static struct bond_option bond_opts[] = {
 		.values = bond_intmax_tbl,
 		.set = bond_option_downdelay_set
 	},
+	[BOND_OPT_UPDELAY] = {
+		.id = BOND_OPT_UPDELAY,
+		.name = "updelay",
+		.desc = "Delay before considering link up, in milliseconds",
+		.values = bond_intmax_tbl,
+		.set = bond_option_updelay_set
+	},
+
 	{ }
 };
 
@@ -558,31 +566,24 @@ int bond_option_miimon_set(struct bonding *bond, int miimon)
 	return 0;
 }
 
-int bond_option_updelay_set(struct bonding *bond, int updelay)
+int bond_option_updelay_set(struct bonding *bond, struct bond_opt_value *newval)
 {
-	if (!(bond->params.miimon)) {
+	if (!bond->params.miimon) {
 		pr_err("%s: Unable to set up delay as MII monitoring is disabled\n",
 		       bond->dev->name);
 		return -EPERM;
 	}
-
-	if (updelay < 0) {
-		pr_err("%s: Invalid up delay value %d not in range %d-%d; rejected.\n",
-		       bond->dev->name, updelay, 0, INT_MAX);
-		return -EINVAL;
-	} else {
-		if ((updelay % bond->params.miimon) != 0) {
-			pr_warn("%s: Warning: up delay (%d) is not a multiple of miimon (%d), updelay rounded to %d ms\n",
-				bond->dev->name, updelay,
-				bond->params.miimon,
-				(updelay / bond->params.miimon) *
-				bond->params.miimon);
-		}
-		bond->params.updelay = updelay / bond->params.miimon;
-		pr_info("%s: Setting up delay to %d.\n",
-			bond->dev->name,
-			bond->params.updelay * bond->params.miimon);
+	if ((newval->value % bond->params.miimon) != 0) {
+		pr_warn("%s: Warning: up delay (%llu) is not a multiple of miimon (%d), updelay rounded to %llu ms\n",
+			bond->dev->name, newval->value,
+			bond->params.miimon,
+			(newval->value / bond->params.miimon) *
+			bond->params.miimon);
 	}
+	bond->params.updelay = newval->value / bond->params.miimon;
+	pr_info("%s: Setting up delay to %d.\n",
+		bond->dev->name,
+		bond->params.updelay * bond->params.miimon);
 
 	return 0;
 }

commit 25a9b54a4b4a996e5a996c1e841c265d40db1d40
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Wed Jan 22 14:53:25 2014 +0100

    bonding: convert downdelay to use the new option API
    
    This patch adds the necessary changes so downdelay would use
    the new bonding option API. Also some trivial style fixes.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index df5f007ddaa5..03514f7e17b9 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -135,6 +135,13 @@ static struct bond_option bond_opts[] = {
 		.flags = BOND_OPTFLAG_RAWVAL,
 		.set = bond_option_arp_ip_targets_set
 	},
+	[BOND_OPT_DOWNDELAY] = {
+		.id = BOND_OPT_DOWNDELAY,
+		.name = "downdelay",
+		.desc = "Delay before considering link down, in milliseconds",
+		.values = bond_intmax_tbl,
+		.set = bond_option_downdelay_set
+	},
 	{ }
 };
 
@@ -580,31 +587,25 @@ int bond_option_updelay_set(struct bonding *bond, int updelay)
 	return 0;
 }
 
-int bond_option_downdelay_set(struct bonding *bond, int downdelay)
+int bond_option_downdelay_set(struct bonding *bond,
+			      struct bond_opt_value *newval)
 {
-	if (!(bond->params.miimon)) {
+	if (!bond->params.miimon) {
 		pr_err("%s: Unable to set down delay as MII monitoring is disabled\n",
 		       bond->dev->name);
 		return -EPERM;
 	}
-
-	if (downdelay < 0) {
-		pr_err("%s: Invalid down delay value %d not in range %d-%d; rejected.\n",
-		       bond->dev->name, downdelay, 0, INT_MAX);
-		return -EINVAL;
-	} else {
-		if ((downdelay % bond->params.miimon) != 0) {
-			pr_warn("%s: Warning: down delay (%d) is not a multiple of miimon (%d), delay rounded to %d ms\n",
-				bond->dev->name, downdelay,
-				bond->params.miimon,
-				(downdelay / bond->params.miimon) *
-				bond->params.miimon);
-		}
-		bond->params.downdelay = downdelay / bond->params.miimon;
-		pr_info("%s: Setting down delay to %d.\n",
-			bond->dev->name,
-			bond->params.downdelay * bond->params.miimon);
+	if ((newval->value % bond->params.miimon) != 0) {
+		pr_warn("%s: Warning: down delay (%llu) is not a multiple of miimon (%d), delay rounded to %llu ms\n",
+			bond->dev->name, newval->value,
+			bond->params.miimon,
+			(newval->value / bond->params.miimon) *
+			bond->params.miimon);
 	}
+	bond->params.downdelay = newval->value / bond->params.miimon;
+	pr_info("%s: Setting down delay to %d.\n",
+		bond->dev->name,
+		bond->params.downdelay * bond->params.miimon);
 
 	return 0;
 }

commit 4fb0ef585eb2825ef4e542c2b1d302dc53f36860
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Wed Jan 22 14:53:24 2014 +0100

    bonding: convert arp_ip_target to use the new option API
    
    This patch adds the necessary changes so arp_ip_target would use
    the new bonding option API. This option is an exception because of
    the way it's currently implemented that's why its netlink code is
    a bit different from the other options to keep the functionality as
    before and at the same time to have a single set function.
    
    This patch also fixes a few stylistic errors.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index df693afbb1a5..df5f007ddaa5 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -17,6 +17,7 @@
 #include <linux/rwlock.h>
 #include <linux/rcupdate.h>
 #include <linux/ctype.h>
+#include <linux/inet.h>
 #include "bonding.h"
 
 static struct bond_opt_value bond_mode_tbl[] = {
@@ -127,6 +128,13 @@ static struct bond_option bond_opts[] = {
 		.values = bond_intmax_tbl,
 		.set = bond_option_arp_interval_set
 	},
+	[BOND_OPT_ARP_TARGETS] = {
+		.id = BOND_OPT_ARP_TARGETS,
+		.name = "arp_ip_target",
+		.desc = "arp targets in n.n.n.n form",
+		.flags = BOND_OPTFLAG_RAWVAL,
+		.set = bond_option_arp_ip_targets_set
+	},
 	{ }
 };
 
@@ -757,29 +765,41 @@ int bond_option_arp_ip_target_rem(struct bonding *bond, __be32 target)
 	return 0;
 }
 
-int bond_option_arp_ip_targets_set(struct bonding *bond, __be32 *targets,
-				   int count)
+void bond_option_arp_ip_targets_clear(struct bonding *bond)
 {
-	int i, ret = 0;
+	int i;
 
 	/* not to race with bond_arp_rcv */
 	write_lock_bh(&bond->lock);
-
-	/* clear table */
 	for (i = 0; i < BOND_MAX_ARP_TARGETS; i++)
 		_bond_options_arp_ip_target_set(bond, i, 0, 0);
+	write_unlock_bh(&bond->lock);
+}
 
-	if (count == 0 && bond->params.arp_interval)
-		pr_warn("%s: removing last arp target with arp_interval on\n",
-			bond->dev->name);
-
-	for (i = 0; i < count; i++) {
-		ret = _bond_option_arp_ip_target_add(bond, targets[i]);
-		if (ret)
-			break;
+int bond_option_arp_ip_targets_set(struct bonding *bond,
+				   struct bond_opt_value *newval)
+{
+	int ret = -EPERM;
+	__be32 target;
+
+	if (newval->string) {
+		if (!in4_pton(newval->string+1, -1, (u8 *)&target, -1, NULL)) {
+			pr_err("%s: invalid ARP target %pI4 specified\n",
+			       bond->dev->name, &target);
+			return ret;
+		}
+		if (newval->string[0] == '+')
+			ret = bond_option_arp_ip_target_add(bond, target);
+		else if (newval->string[0] == '-')
+			ret = bond_option_arp_ip_target_rem(bond, target);
+		else
+			pr_err("no command found in arp_ip_targets file for bond %s. Use +<addr> or -<addr>.\n",
+			       bond->dev->name);
+	} else {
+		target = newval->value;
+		ret = bond_option_arp_ip_target_add(bond, target);
 	}
 
-	write_unlock_bh(&bond->lock);
 	return ret;
 }
 

commit 7bdb04ed0dbf9f0e94110be43db4f8bb7df58de2
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Wed Jan 22 14:53:23 2014 +0100

    bonding: convert arp_interval to use the new option API
    
    This patch adds the necessary changes so arp_interval would use
    the new bonding option API. The "default" definition has been removed as
    it was 0.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index c73d3acbdd37..df693afbb1a5 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -66,6 +66,11 @@ static struct bond_opt_value bond_fail_over_mac_tbl[] = {
 	{ NULL,     -1,              0},
 };
 
+static struct bond_opt_value bond_intmax_tbl[] = {
+	{ "off",     0,       BOND_VALFLAG_DEFAULT},
+	{ "maxval",  INT_MAX, BOND_VALFLAG_MAX},
+};
+
 static struct bond_option bond_opts[] = {
 	[BOND_OPT_MODE] = {
 		.id = BOND_OPT_MODE,
@@ -113,6 +118,15 @@ static struct bond_option bond_opts[] = {
 		.values = bond_fail_over_mac_tbl,
 		.set = bond_option_fail_over_mac_set
 	},
+	[BOND_OPT_ARP_INTERVAL] = {
+		.id = BOND_OPT_ARP_INTERVAL,
+		.name = "arp_interval",
+		.desc = "arp interval in milliseconds",
+		.unsuppmodes = BIT(BOND_MODE_8023AD) | BIT(BOND_MODE_TLB) |
+			       BIT(BOND_MODE_ALB),
+		.values = bond_intmax_tbl,
+		.set = bond_option_arp_interval_set
+	},
 	{ }
 };
 
@@ -601,22 +615,13 @@ int bond_option_use_carrier_set(struct bonding *bond, int use_carrier)
 	return 0;
 }
 
-int bond_option_arp_interval_set(struct bonding *bond, int arp_interval)
+int bond_option_arp_interval_set(struct bonding *bond,
+				 struct bond_opt_value *newval)
 {
-	if (arp_interval < 0) {
-		pr_err("%s: Invalid arp_interval value %d not in range 0-%d; rejected.\n",
-		       bond->dev->name, arp_interval, INT_MAX);
-		return -EINVAL;
-	}
-	if (BOND_NO_USES_ARP(bond->params.mode)) {
-		pr_info("%s: ARP monitoring cannot be used with ALB/TLB/802.3ad. Only MII monitoring is supported on %s.\n",
-			bond->dev->name, bond->dev->name);
-		return -EINVAL;
-	}
-	pr_info("%s: Setting ARP monitoring interval to %d.\n",
-		bond->dev->name, arp_interval);
-	bond->params.arp_interval = arp_interval;
-	if (arp_interval) {
+	pr_info("%s: Setting ARP monitoring interval to %llu.\n",
+		bond->dev->name, newval->value);
+	bond->params.arp_interval = newval->value;
+	if (newval->value) {
 		if (bond->params.miimon) {
 			pr_info("%s: ARP monitoring cannot be used with MII monitoring. %s Disabling MII monitoring.\n",
 				bond->dev->name, bond->dev->name);
@@ -632,7 +637,7 @@ int bond_option_arp_interval_set(struct bonding *bond, int arp_interval)
 		 * timer will get fired off when the open function
 		 * is called.
 		 */
-		if (!arp_interval) {
+		if (!newval->value) {
 			if (bond->params.arp_validate)
 				bond->recv_probe = NULL;
 			cancel_delayed_work_sync(&bond->arp_work);

commit 1df6b6aa334c99b39f9366f4199b7f5e479a8899
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Wed Jan 22 14:53:22 2014 +0100

    bonding: convert fail_over_mac to use the new option API
    
    This patch adds the necessary changes so fail_over_mac would use
    the new bonding option API. Also fixes a trivial copy/paste error in
    bond_check_params where the wrong variable was used for the error msg.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index e136e7525a02..c73d3acbdd37 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -59,6 +59,13 @@ static struct bond_opt_value bond_arp_all_targets_tbl[] = {
 	{ NULL,  -1,                   0},
 };
 
+static struct bond_opt_value bond_fail_over_mac_tbl[] = {
+	{ "none",   BOND_FOM_NONE,   BOND_VALFLAG_DEFAULT},
+	{ "active", BOND_FOM_ACTIVE, 0},
+	{ "follow", BOND_FOM_FOLLOW, 0},
+	{ NULL,     -1,              0},
+};
+
 static struct bond_option bond_opts[] = {
 	[BOND_OPT_MODE] = {
 		.id = BOND_OPT_MODE,
@@ -98,6 +105,14 @@ static struct bond_option bond_opts[] = {
 		.values = bond_arp_all_targets_tbl,
 		.set = bond_option_arp_all_targets_set
 	},
+	[BOND_OPT_FAIL_OVER_MAC] = {
+		.id = BOND_OPT_FAIL_OVER_MAC,
+		.name = "fail_over_mac",
+		.desc = "For active-backup, do not set all slaves to the same MAC",
+		.flags = BOND_OPTFLAG_NOSLAVES,
+		.values = bond_fail_over_mac_tbl,
+		.set = bond_option_fail_over_mac_set
+	},
 	{ }
 };
 
@@ -864,24 +879,12 @@ int bond_option_primary_reselect_set(struct bonding *bond, int primary_reselect)
 	return 0;
 }
 
-int bond_option_fail_over_mac_set(struct bonding *bond, int fail_over_mac)
+int bond_option_fail_over_mac_set(struct bonding *bond,
+				  struct bond_opt_value *newval)
 {
-	if (bond_parm_tbl_lookup(fail_over_mac, fail_over_mac_tbl) < 0) {
-		pr_err("%s: Ignoring invalid fail_over_mac value %d.\n",
-		       bond->dev->name, fail_over_mac);
-		return -EINVAL;
-	}
-
-	if (bond_has_slaves(bond)) {
-		pr_err("%s: Can't alter fail_over_mac with slaves in bond.\n",
-		       bond->dev->name);
-		return -EPERM;
-	}
-
-	bond->params.fail_over_mac = fail_over_mac;
-	pr_info("%s: Setting fail_over_mac to %s (%d).\n",
-		bond->dev->name, fail_over_mac_tbl[fail_over_mac].modename,
-		fail_over_mac);
+	pr_info("%s: Setting fail_over_mac to %s (%llu).\n",
+		bond->dev->name, newval->string, newval->value);
+	bond->params.fail_over_mac = newval->value;
 
 	return 0;
 }

commit edf36b24c58dbbd5f2e708096537bf0a88ffa477
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Wed Jan 22 14:53:21 2014 +0100

    bonding: convert arp_all_targets to use the new option API
    
    This patch adds the necessary changes so arp_all_targets would use the
    new bonding option API.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index eff68a0f71f0..e136e7525a02 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -53,6 +53,12 @@ static struct bond_opt_value bond_arp_validate_tbl[] = {
 	{ NULL,     -1,                       0},
 };
 
+static struct bond_opt_value bond_arp_all_targets_tbl[] = {
+	{ "any", BOND_ARP_TARGETS_ANY, BOND_VALFLAG_DEFAULT},
+	{ "all", BOND_ARP_TARGETS_ALL, 0},
+	{ NULL,  -1,                   0},
+};
+
 static struct bond_option bond_opts[] = {
 	[BOND_OPT_MODE] = {
 		.id = BOND_OPT_MODE,
@@ -85,6 +91,13 @@ static struct bond_option bond_opts[] = {
 		.values = bond_arp_validate_tbl,
 		.set = bond_option_arp_validate_set
 	},
+	[BOND_OPT_ARP_ALL_TARGETS] = {
+		.id = BOND_OPT_ARP_ALL_TARGETS,
+		.name = "arp_all_targets",
+		.desc = "fail on any/all arp targets timeout",
+		.values = bond_arp_all_targets_tbl,
+		.set = bond_option_arp_all_targets_set
+	},
 	{ }
 };
 
@@ -767,19 +780,12 @@ int bond_option_arp_validate_set(struct bonding *bond,
 	return 0;
 }
 
-int bond_option_arp_all_targets_set(struct bonding *bond, int arp_all_targets)
+int bond_option_arp_all_targets_set(struct bonding *bond,
+				    struct bond_opt_value *newval)
 {
-	if (bond_parm_tbl_lookup(arp_all_targets, arp_all_targets_tbl) < 0) {
-		pr_err("%s: Ignoring invalid arp_all_targets value %d.\n",
-		       bond->dev->name, arp_all_targets);
-		return -EINVAL;
-	}
-
-	pr_info("%s: setting arp_all_targets to %s (%d).\n",
-		bond->dev->name, arp_all_targets_tbl[arp_all_targets].modename,
-		arp_all_targets);
-
-	bond->params.arp_all_targets = arp_all_targets;
+	pr_info("%s: setting arp_all_targets to %s (%llu).\n",
+		bond->dev->name, newval->string, newval->value);
+	bond->params.arp_all_targets = newval->value;
 
 	return 0;
 }

commit 162288810c9ebd2efb79ee6dc364e266044cac9e
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Wed Jan 22 14:53:20 2014 +0100

    bonding: convert arp_validate to use the new option API
    
    This patch adds the necessary changes so arp_validate would use the
    new bonding option API. Also fix some trivial/style errors.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 71e8c5279bc1..eff68a0f71f0 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -45,6 +45,14 @@ static struct bond_opt_value bond_xmit_hashtype_tbl[] = {
 	{ NULL,       -1,                       0},
 };
 
+static struct bond_opt_value bond_arp_validate_tbl[] = {
+	{ "none",   BOND_ARP_VALIDATE_NONE,   BOND_VALFLAG_DEFAULT},
+	{ "active", BOND_ARP_VALIDATE_ACTIVE, 0},
+	{ "backup", BOND_ARP_VALIDATE_BACKUP, 0},
+	{ "all",    BOND_ARP_VALIDATE_ALL,    0},
+	{ NULL,     -1,                       0},
+};
+
 static struct bond_option bond_opts[] = {
 	[BOND_OPT_MODE] = {
 		.id = BOND_OPT_MODE,
@@ -69,6 +77,14 @@ static struct bond_option bond_opts[] = {
 		.values = bond_xmit_hashtype_tbl,
 		.set = bond_option_xmit_hash_policy_set
 	},
+	[BOND_OPT_ARP_VALIDATE] = {
+		.id = BOND_OPT_ARP_VALIDATE,
+		.name = "arp_validate",
+		.desc = "validate src/dst of ARP probes",
+		.unsuppmodes = BOND_MODE_ALL_EX(BIT(BOND_MODE_ACTIVEBACKUP)),
+		.values = bond_arp_validate_tbl,
+		.set = bond_option_arp_validate_set
+	},
 	{ }
 };
 
@@ -734,31 +750,19 @@ int bond_option_arp_ip_targets_set(struct bonding *bond, __be32 *targets,
 	return ret;
 }
 
-int bond_option_arp_validate_set(struct bonding *bond, int arp_validate)
+int bond_option_arp_validate_set(struct bonding *bond,
+				 struct bond_opt_value *newval)
 {
-	if (bond_parm_tbl_lookup(arp_validate, arp_validate_tbl) < 0) {
-		pr_err("%s: Ignoring invalid arp_validate value %d.\n",
-		       bond->dev->name, arp_validate);
-		return -EINVAL;
-	}
-
-	if (bond->params.mode != BOND_MODE_ACTIVEBACKUP) {
-		pr_err("%s: arp_validate only supported in active-backup mode.\n",
-		       bond->dev->name);
-		return -EINVAL;
-	}
-
-	pr_info("%s: setting arp_validate to %s (%d).\n",
-		bond->dev->name, arp_validate_tbl[arp_validate].modename,
-		arp_validate);
+	pr_info("%s: setting arp_validate to %s (%llu).\n",
+		bond->dev->name, newval->string, newval->value);
 
 	if (bond->dev->flags & IFF_UP) {
-		if (!arp_validate)
+		if (!newval->value)
 			bond->recv_probe = NULL;
 		else if (bond->params.arp_interval)
 			bond->recv_probe = bond_arp_rcv;
 	}
-	bond->params.arp_validate = arp_validate;
+	bond->params.arp_validate = newval->value;
 
 	return 0;
 }

commit a4b32ce7f891d507aa663bc78118ef267f0d6d4c
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Wed Jan 22 14:53:19 2014 +0100

    bonding: convert xmit_hash_policy to use the new option API
    
    This patch adds the necessary changes so xmit_hash_policy would use the
    new bonding option API. Also fix some trivial/style errors.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 6d2a7d9cee19..71e8c5279bc1 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -36,6 +36,15 @@ static struct bond_opt_value bond_pps_tbl[] = {
 	{ NULL,      -1,        0},
 };
 
+static struct bond_opt_value bond_xmit_hashtype_tbl[] = {
+	{ "layer2",   BOND_XMIT_POLICY_LAYER2, BOND_VALFLAG_DEFAULT},
+	{ "layer3+4", BOND_XMIT_POLICY_LAYER34, 0},
+	{ "layer2+3", BOND_XMIT_POLICY_LAYER23, 0},
+	{ "encap2+3", BOND_XMIT_POLICY_ENCAP23, 0},
+	{ "encap3+4", BOND_XMIT_POLICY_ENCAP34, 0},
+	{ NULL,       -1,                       0},
+};
+
 static struct bond_option bond_opts[] = {
 	[BOND_OPT_MODE] = {
 		.id = BOND_OPT_MODE,
@@ -53,6 +62,13 @@ static struct bond_option bond_opts[] = {
 		.values = bond_pps_tbl,
 		.set = bond_option_pps_set
 	},
+	[BOND_OPT_XMIT_HASH] = {
+		.id = BOND_OPT_XMIT_HASH,
+		.name = "xmit_hash_policy",
+		.desc = "balance-xor and 802.3ad hashing method",
+		.values = bond_xmit_hashtype_tbl,
+		.set = bond_option_xmit_hash_policy_set
+	},
 	{ }
 };
 
@@ -860,18 +876,12 @@ int bond_option_fail_over_mac_set(struct bonding *bond, int fail_over_mac)
 	return 0;
 }
 
-int bond_option_xmit_hash_policy_set(struct bonding *bond, int xmit_hash_policy)
+int bond_option_xmit_hash_policy_set(struct bonding *bond,
+				     struct bond_opt_value *newval)
 {
-	if (bond_parm_tbl_lookup(xmit_hash_policy, xmit_hashtype_tbl) < 0) {
-		pr_err("%s: Ignoring invalid xmit_hash_policy value %d.\n",
-		       bond->dev->name, xmit_hash_policy);
-		return -EINVAL;
-	}
-
-	bond->params.xmit_policy = xmit_hash_policy;
-	pr_info("%s: setting xmit hash policy to %s (%d).\n",
-		bond->dev->name,
-		xmit_hashtype_tbl[xmit_hash_policy].modename, xmit_hash_policy);
+	pr_info("%s: setting xmit hash policy to %s (%llu).\n",
+		bond->dev->name, newval->string, newval->value);
+	bond->params.xmit_policy = newval->value;
 
 	return 0;
 }

commit aa59d8517d1017e571b803ba6302c4b693b324ab
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Wed Jan 22 14:53:18 2014 +0100

    bonding: convert packets_per_slave to use the new option API
    
    This patch adds the necessary changes so packets_per_slave would use the
    new bonding option API.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 5696b2fb5cb4..6d2a7d9cee19 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -30,6 +30,12 @@ static struct bond_opt_value bond_mode_tbl[] = {
 	{ NULL,            -1,                     0},
 };
 
+static struct bond_opt_value bond_pps_tbl[] = {
+	{ "default", 1,         BOND_VALFLAG_DEFAULT},
+	{ "maxval",  USHRT_MAX, BOND_VALFLAG_MAX},
+	{ NULL,      -1,        0},
+};
+
 static struct bond_option bond_opts[] = {
 	[BOND_OPT_MODE] = {
 		.id = BOND_OPT_MODE,
@@ -39,6 +45,14 @@ static struct bond_option bond_opts[] = {
 		.values = bond_mode_tbl,
 		.set = bond_option_mode_set
 	},
+	[BOND_OPT_PACKETS_PER_SLAVE] = {
+		.id = BOND_OPT_PACKETS_PER_SLAVE,
+		.name = "packets_per_slave",
+		.desc = "Packets to send per slave in RR mode",
+		.unsuppmodes = BOND_MODE_ALL_EX(BIT(BOND_MODE_ROUNDROBIN)),
+		.values = bond_pps_tbl,
+		.set = bond_option_pps_set
+	},
 	{ }
 };
 
@@ -934,23 +948,12 @@ int bond_option_lp_interval_set(struct bonding *bond, int lp_interval)
 	return 0;
 }
 
-int bond_option_packets_per_slave_set(struct bonding *bond,
-				      int packets_per_slave)
+int bond_option_pps_set(struct bonding *bond, struct bond_opt_value *newval)
 {
-	if (packets_per_slave < 0 || packets_per_slave > USHRT_MAX) {
-		pr_err("%s: packets_per_slave must be between 0 and %u\n",
-		       bond->dev->name, USHRT_MAX);
-		return -EINVAL;
-	}
-
-	if (bond->params.mode != BOND_MODE_ROUNDROBIN)
-		pr_warn("%s: Warning: packets_per_slave has effect only in balance-rr mode\n",
-			bond->dev->name);
-
-	bond->params.packets_per_slave = packets_per_slave;
-	if (packets_per_slave > 0) {
+	bond->params.packets_per_slave = newval->value;
+	if (newval->value > 0) {
 		bond->params.reciprocal_packets_per_slave =
-			reciprocal_value(packets_per_slave);
+			reciprocal_value(newval->value);
 	} else {
 		/* reciprocal_packets_per_slave is unused if
 		 * packets_per_slave is 0 or 1, just initialize it

commit 2b3798d5e1377ce6c67993bb271754c9c5ab4833
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Wed Jan 22 14:53:17 2014 +0100

    bonding: convert mode setting to use the new option API
    
    This patch makes the bond's mode setting use the new option API and
    adds support for dependency printing which relies on having an entry for
    the mode option in the bond_opts[] array.
    Also add the ability to print the mode name when mode dependency fails
    and fix some trivial/style errors.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 3ad140bfed1a..5696b2fb5cb4 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -19,7 +19,26 @@
 #include <linux/ctype.h>
 #include "bonding.h"
 
+static struct bond_opt_value bond_mode_tbl[] = {
+	{ "balance-rr",    BOND_MODE_ROUNDROBIN,   BOND_VALFLAG_DEFAULT},
+	{ "active-backup", BOND_MODE_ACTIVEBACKUP, 0},
+	{ "balance-xor",   BOND_MODE_XOR,          0},
+	{ "broadcast",     BOND_MODE_BROADCAST,    0},
+	{ "802.3ad",       BOND_MODE_8023AD,       0},
+	{ "balance-tlb",   BOND_MODE_TLB,          0},
+	{ "balance-alb",   BOND_MODE_ALB,          0},
+	{ NULL,            -1,                     0},
+};
+
 static struct bond_option bond_opts[] = {
+	[BOND_OPT_MODE] = {
+		.id = BOND_OPT_MODE,
+		.name = "mode",
+		.desc = "bond device mode",
+		.flags = BOND_OPTFLAG_NOSLAVES | BOND_OPTFLAG_IFDOWN,
+		.values = bond_mode_tbl,
+		.set = bond_option_mode_set
+	},
 	{ }
 };
 
@@ -160,12 +179,15 @@ static int bond_opt_check_deps(struct bonding *bond,
 static void bond_opt_dep_print(struct bonding *bond,
 			       const struct bond_option *opt)
 {
+	struct bond_opt_value *modeval;
 	struct bond_params *params;
 
 	params = &bond->params;
+	modeval = bond_opt_get_val(BOND_OPT_MODE, params->mode);
 	if (test_bit(params->mode, &opt->unsuppmodes))
-		pr_err("%s: option %s: mode dependency failed\n",
-		       bond->dev->name, opt->name);
+		pr_err("%s: option %s: mode dependency failed, not supported in mode %s(%llu)\n",
+		       bond->dev->name, opt->name,
+		       modeval->string, modeval->value);
 }
 
 static void bond_opt_error_interpret(struct bonding *bond,
@@ -290,29 +312,11 @@ struct bond_option *bond_opt_get(unsigned int option)
 	return &bond_opts[option];
 }
 
-int bond_option_mode_set(struct bonding *bond, int mode)
+int bond_option_mode_set(struct bonding *bond, struct bond_opt_value *newval)
 {
-	if (bond_parm_tbl_lookup(mode, bond_mode_tbl) < 0) {
-		pr_err("%s: Ignoring invalid mode value %d.\n",
-		       bond->dev->name, mode);
-		return -EINVAL;
-	}
-
-	if (bond->dev->flags & IFF_UP) {
-		pr_err("%s: unable to update mode because interface is up.\n",
-		       bond->dev->name);
-		return -EPERM;
-	}
-
-	if (bond_has_slaves(bond)) {
-		pr_err("%s: unable to update mode because bond has slaves.\n",
-			bond->dev->name);
-		return -EPERM;
-	}
-
-	if (BOND_NO_USES_ARP(mode) && bond->params.arp_interval) {
+	if (BOND_NO_USES_ARP(newval->value) && bond->params.arp_interval) {
 		pr_info("%s: %s mode is incompatible with arp monitoring, start mii monitoring\n",
-			bond->dev->name, bond_mode_tbl[mode].modename);
+			bond->dev->name, newval->string);
 		/* disable arp monitoring */
 		bond->params.arp_interval = 0;
 		/* set miimon to default value */
@@ -323,7 +327,8 @@ int bond_option_mode_set(struct bonding *bond, int mode)
 
 	/* don't cache arp_validate between modes */
 	bond->params.arp_validate = BOND_ARP_VALIDATE_NONE;
-	bond->params.mode = mode;
+	bond->params.mode = newval->value;
+
 	return 0;
 }
 

commit 0911736245df19b423a3b156f6709e7bba48b18a
Author: Nikolay Aleksandrov <nikolay@redhat.com>
Date:   Wed Jan 22 14:53:16 2014 +0100

    bonding: add infrastructure for an option API
    
    This patch adds the necessary basic infrastructure to support
    centralized and unified option manipulation API for the bonding. The new
    structure bond_option will be used to describe each option with its
    dependencies on modes which will be checked automatically thus removing a
    lot of duplicated code. Also automatic range checking is added for
    some options. Currently the option setting function requires RTNL to
    be acquired prior to calling it, since many options already rely on RTNL
    it seemed like the best choice to protect all against common race
    conditions.
    In order to add an option the following steps need to be done:
    1. Add an entry BOND_OPT_<option> to bond_options.h so it gets a unique id
       and a bit corresponding to the id
    2. Add a bond_option entry to the bond_opts[] array in bond_options.c which
       describes the option, its dependencies and its manipulation function
    3. Add code to export the option through sysfs and/or as a module parameter
       (the sysfs export will be made automatically in the future)
    
    The options can have different flags set, currently the following are
    supported:
    BOND_OPTFLAG_NOSLAVES - require that the bond device has no slaves prior
                            to setting the option
    BOND_OPTFLAG_IFDOWN - require that the bond device is down prior to
                          setting the option
    BOND_OPTFLAG_RAWVAL - don't parse the value but return it raw for the
                          option to parse
    
    There's a new value structure to describe different types of values
    which can have the following flags:
    BOND_VALFLAG_DEFAULT - marks the default option (permanent string alias
                           to this option is "default")
    BOND_VALFLAG_MIN - the minimum value that this option can have
    BOND_VALFLAG_MAX - the maximum value that this option can have
    
    An example would be nice here, so if we have an option which can have
    the values "off"(2), "special"(4, default) and supports a range, say
    16 - 32, it should be defined as follows:
    "off", 2,
    "special", 4, BOND_VALFLAG_DEFAULT,
    "rangemin", 16, BOND_VALFLAG_MIN,
    "rangemax", 32, BOND_VALFLAG_MAX
    So we have the valid intervals: [2, 2], [4, 4], [16, 32]
    Also the valid strings: "off" = 2, "special" and "default" = 4
                            "rangemin" = 16, "rangemax" = 32
    
    BOND_VALFLAG_(MIN|MAX) can be used to specify a valid range for an
    option, if MIN is omitted then 0 is considered as a minimum. If an
    exact match is found in the values[] table it will be returned,
    otherwise the range is tried (if available).
    
    The option parameter passing is done by using a special structure called
    bond_opt_value which can take either a string or a value to parse. One
    of the bond_opt_init(val|str) macros should be used depending on which
    one does the user want to parse (string or value). Then a call to
    __bond_opt_set should be done under RTNL.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 85e434886f2e..3ad140bfed1a 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -16,8 +16,280 @@
 #include <linux/netdevice.h>
 #include <linux/rwlock.h>
 #include <linux/rcupdate.h>
+#include <linux/ctype.h>
 #include "bonding.h"
 
+static struct bond_option bond_opts[] = {
+	{ }
+};
+
+/* Searches for a value in opt's values[] table */
+struct bond_opt_value *bond_opt_get_val(unsigned int option, u64 val)
+{
+	struct bond_option *opt;
+	int i;
+
+	opt = bond_opt_get(option);
+	if (WARN_ON(!opt))
+		return NULL;
+	for (i = 0; opt->values && opt->values[i].string; i++)
+		if (opt->values[i].value == val)
+			return &opt->values[i];
+
+	return NULL;
+}
+
+/* Searches for a value in opt's values[] table which matches the flagmask */
+static struct bond_opt_value *bond_opt_get_flags(const struct bond_option *opt,
+						 u32 flagmask)
+{
+	int i;
+
+	for (i = 0; opt->values && opt->values[i].string; i++)
+		if (opt->values[i].flags & flagmask)
+			return &opt->values[i];
+
+	return NULL;
+}
+
+/* If maxval is missing then there's no range to check. In case minval is
+ * missing then it's considered to be 0.
+ */
+static bool bond_opt_check_range(const struct bond_option *opt, u64 val)
+{
+	struct bond_opt_value *minval, *maxval;
+
+	minval = bond_opt_get_flags(opt, BOND_VALFLAG_MIN);
+	maxval = bond_opt_get_flags(opt, BOND_VALFLAG_MAX);
+	if (!maxval || (minval && val < minval->value) || val > maxval->value)
+		return false;
+
+	return true;
+}
+
+/**
+ * bond_opt_parse - parse option value
+ * @opt: the option to parse against
+ * @val: value to parse
+ *
+ * This function tries to extract the value from @val and check if it's
+ * a possible match for the option and returns NULL if a match isn't found,
+ * or the struct_opt_value that matched. It also strips the new line from
+ * @val->string if it's present.
+ */
+struct bond_opt_value *bond_opt_parse(const struct bond_option *opt,
+				      struct bond_opt_value *val)
+{
+	char *p, valstr[BOND_OPT_MAX_NAMELEN + 1] = { 0, };
+	struct bond_opt_value *tbl, *ret = NULL;
+	bool checkval;
+	int i, rv;
+
+	/* No parsing if the option wants a raw val */
+	if (opt->flags & BOND_OPTFLAG_RAWVAL)
+		return val;
+
+	tbl = opt->values;
+	if (!tbl)
+		goto out;
+
+	/* ULLONG_MAX is used to bypass string processing */
+	checkval = val->value != ULLONG_MAX;
+	if (!checkval) {
+		if (!val->string)
+			goto out;
+		p = strchr(val->string, '\n');
+		if (p)
+			*p = '\0';
+		for (p = val->string; *p; p++)
+			if (!(isdigit(*p) || isspace(*p)))
+				break;
+		/* The following code extracts the string to match or the value
+		 * and sets checkval appropriately
+		 */
+		if (*p) {
+			rv = sscanf(val->string, "%32s", valstr);
+		} else {
+			rv = sscanf(val->string, "%llu", &val->value);
+			checkval = true;
+		}
+		if (!rv)
+			goto out;
+	}
+
+	for (i = 0; tbl[i].string; i++) {
+		/* Check for exact match */
+		if (checkval) {
+			if (val->value == tbl[i].value)
+				ret = &tbl[i];
+		} else {
+			if (!strcmp(valstr, "default") &&
+			    (tbl[i].flags & BOND_VALFLAG_DEFAULT))
+				ret = &tbl[i];
+
+			if (!strcmp(valstr, tbl[i].string))
+				ret = &tbl[i];
+		}
+		/* Found an exact match */
+		if (ret)
+			goto out;
+	}
+	/* Possible range match */
+	if (checkval && bond_opt_check_range(opt, val->value))
+		ret = val;
+out:
+	return ret;
+}
+
+/* Check opt's dependencies against bond mode and currently set options */
+static int bond_opt_check_deps(struct bonding *bond,
+			       const struct bond_option *opt)
+{
+	struct bond_params *params = &bond->params;
+
+	if (test_bit(params->mode, &opt->unsuppmodes))
+		return -EACCES;
+	if ((opt->flags & BOND_OPTFLAG_NOSLAVES) && bond_has_slaves(bond))
+		return -ENOTEMPTY;
+	if ((opt->flags & BOND_OPTFLAG_IFDOWN) && (bond->dev->flags & IFF_UP))
+		return -EBUSY;
+
+	return 0;
+}
+
+static void bond_opt_dep_print(struct bonding *bond,
+			       const struct bond_option *opt)
+{
+	struct bond_params *params;
+
+	params = &bond->params;
+	if (test_bit(params->mode, &opt->unsuppmodes))
+		pr_err("%s: option %s: mode dependency failed\n",
+		       bond->dev->name, opt->name);
+}
+
+static void bond_opt_error_interpret(struct bonding *bond,
+				     const struct bond_option *opt,
+				     int error, struct bond_opt_value *val)
+{
+	struct bond_opt_value *minval, *maxval;
+	char *p;
+
+	switch (error) {
+	case -EINVAL:
+		if (val) {
+			if (val->string) {
+				/* sometimes RAWVAL opts may have new lines */
+				p = strchr(val->string, '\n');
+				if (p)
+					*p = '\0';
+				pr_err("%s: option %s: invalid value (%s).\n",
+				       bond->dev->name, opt->name, val->string);
+			} else {
+				pr_err("%s: option %s: invalid value (%llu).\n",
+				       bond->dev->name, opt->name, val->value);
+			}
+		}
+		minval = bond_opt_get_flags(opt, BOND_VALFLAG_MIN);
+		maxval = bond_opt_get_flags(opt, BOND_VALFLAG_MAX);
+		if (!maxval)
+			break;
+		pr_err("%s: option %s: allowed values %llu - %llu.\n",
+		       bond->dev->name, opt->name, minval ? minval->value : 0,
+		       maxval->value);
+		break;
+	case -EACCES:
+		bond_opt_dep_print(bond, opt);
+		break;
+	case -ENOTEMPTY:
+		pr_err("%s: option %s: unable to set because the bond device has slaves.\n",
+		       bond->dev->name, opt->name);
+		break;
+	case -EBUSY:
+		pr_err("%s: option %s: unable to set because the bond device is up.\n",
+		       bond->dev->name, opt->name);
+		break;
+	default:
+		break;
+	}
+}
+
+/**
+ * __bond_opt_set - set a bonding option
+ * @bond: target bond device
+ * @option: option to set
+ * @val: value to set it to
+ *
+ * This function is used to change the bond's option value, it can be
+ * used for both enabling/changing an option and for disabling it. RTNL lock
+ * must be obtained before calling this function.
+ */
+int __bond_opt_set(struct bonding *bond,
+		   unsigned int option, struct bond_opt_value *val)
+{
+	struct bond_opt_value *retval = NULL;
+	const struct bond_option *opt;
+	int ret = -ENOENT;
+
+	ASSERT_RTNL();
+
+	opt = bond_opt_get(option);
+	if (WARN_ON(!val) || WARN_ON(!opt))
+		goto out;
+	ret = bond_opt_check_deps(bond, opt);
+	if (ret)
+		goto out;
+	retval = bond_opt_parse(opt, val);
+	if (!retval) {
+		ret = -EINVAL;
+		goto out;
+	}
+	ret = opt->set(bond, retval);
+out:
+	if (ret)
+		bond_opt_error_interpret(bond, opt, ret, val);
+
+	return ret;
+}
+
+/**
+ * bond_opt_tryset_rtnl - try to acquire rtnl and call __bond_opt_set
+ * @bond: target bond device
+ * @option: option to set
+ * @buf: value to set it to
+ *
+ * This function tries to acquire RTNL without blocking and if successful
+ * calls __bond_opt_set. It is mainly used for sysfs option manipulation.
+ */
+int bond_opt_tryset_rtnl(struct bonding *bond, unsigned int option, char *buf)
+{
+	struct bond_opt_value optval;
+	int ret;
+
+	if (!rtnl_trylock())
+		return restart_syscall();
+	bond_opt_initstr(&optval, buf);
+	ret = __bond_opt_set(bond, option, &optval);
+	rtnl_unlock();
+
+	return ret;
+}
+
+/**
+ * bond_opt_get - get a pointer to an option
+ * @option: option for which to return a pointer
+ *
+ * This function checks if option is valid and if so returns a pointer
+ * to its entry in the bond_opts[] option array.
+ */
+struct bond_option *bond_opt_get(unsigned int option)
+{
+	if (!BOND_OPT_VALID(option))
+		return NULL;
+
+	return &bond_opts[option];
+}
+
 int bond_option_mode_set(struct bonding *bond, int mode)
 {
 	if (bond_parm_tbl_lookup(mode, bond_mode_tbl) < 0) {

commit 809fa972fd90ff27225294b17a027e908b2d7b7a
Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
Date:   Wed Jan 22 02:29:41 2014 +0100

    reciprocal_divide: update/correction of the algorithm
    
    Jakub Zawadzki noticed that some divisions by reciprocal_divide()
    were not correct [1][2], which he could also show with BPF code
    after divisions are transformed into reciprocal_value() for runtime
    invariance which can be passed to reciprocal_divide() later on;
    reverse in BPF dump ended up with a different, off-by-one K in
    some situations.
    
    This has been fixed by Eric Dumazet in commit aee636c4809fa5
    ("bpf: do not use reciprocal divide"). This follow-up patch
    improves reciprocal_value() and reciprocal_divide() to work in
    all cases by using Granlund and Montgomery method, so that also
    future use is safe and without any non-obvious side-effects.
    Known problems with the old implementation were that division by 1
    always returned 0 and some off-by-ones when the dividend and divisor
    where very large. This seemed to not be problematic with its
    current users, as far as we can tell. Eric Dumazet checked for
    the slab usage, we cannot surely say so in the case of flex_array.
    Still, in order to fix that, we propose an extension from the
    original implementation from commit 6a2d7a955d8d resp. [3][4],
    by using the algorithm proposed in "Division by Invariant Integers
    Using Multiplication" [5], Torbjörn Granlund and Peter L.
    Montgomery, that is, pseudocode for q = n/d where q, n, d is in
    u32 universe:
    
    1) Initialization:
    
      int l = ceil(log_2 d)
      uword m' = floor((1<<32)*((1<<l)-d)/d)+1
      int sh_1 = min(l,1)
      int sh_2 = max(l-1,0)
    
    2) For q = n/d, all uword:
    
      uword t = (n*m')>>32
      q = (t+((n-t)>>sh_1))>>sh_2
    
    The assembler implementation from Agner Fog [6] also helped a lot
    while implementing. We have tested the implementation on x86_64,
    ppc64, i686, s390x; on x86_64/haswell we're still half the latency
    compared to normal divide.
    
    Joint work with Daniel Borkmann.
    
      [1] http://www.wireshark.org/~darkjames/reciprocal-buggy.c
      [2] http://www.wireshark.org/~darkjames/set-and-dump-filter-k-bug.c
      [3] https://gmplib.org/~tege/division-paper.pdf
      [4] http://homepage.cs.uiowa.edu/~jones/bcd/divide.html
      [5] http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.1.2556
      [6] http://www.agner.org/optimize/asmlib.zip
    
    Reported-by: Jakub Zawadzki <darkjames-ws@darkjames.pl>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Austin S Hemmelgarn <ahferroin7@gmail.com>
    Cc: linux-kernel@vger.kernel.org
    Cc: Jesse Gross <jesse@nicira.com>
    Cc: Jamal Hadi Salim <jhs@mojatatu.com>
    Cc: Stephen Hemminger <stephen@networkplumber.org>
    Cc: Matt Mackall <mpm@selenic.com>
    Cc: Pekka Enberg <penberg@kernel.org>
    Cc: Christoph Lameter <cl@linux-foundation.org>
    Cc: Andy Gospodarek <andy@greyhouse.net>
    Cc: Veaceslav Falico <vfalico@redhat.com>
    Cc: Jay Vosburgh <fubar@us.ibm.com>
    Cc: Jakub Zawadzki <darkjames-ws@darkjames.pl>
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 945a6668da83..85e434886f2e 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -16,7 +16,6 @@
 #include <linux/netdevice.h>
 #include <linux/rwlock.h>
 #include <linux/rcupdate.h>
-#include <linux/reciprocal_div.h>
 #include "bonding.h"
 
 int bond_option_mode_set(struct bonding *bond, int mode)
@@ -671,11 +670,17 @@ int bond_option_packets_per_slave_set(struct bonding *bond,
 		pr_warn("%s: Warning: packets_per_slave has effect only in balance-rr mode\n",
 			bond->dev->name);
 
-	if (packets_per_slave > 1)
-		bond->params.packets_per_slave =
+	bond->params.packets_per_slave = packets_per_slave;
+	if (packets_per_slave > 0) {
+		bond->params.reciprocal_packets_per_slave =
 			reciprocal_value(packets_per_slave);
-	else
-		bond->params.packets_per_slave = packets_per_slave;
+	} else {
+		/* reciprocal_packets_per_slave is unused if
+		 * packets_per_slave is 0 or 1, just initialize it
+		 */
+		bond->params.reciprocal_packets_per_slave =
+			(struct reciprocal_value) { 0 };
+	}
 
 	return 0;
 }

commit 3243c47b1abaa2653c62364f78212400556164c6
Author: sfeldma@cumulusnetworks.com <sfeldma@cumulusnetworks.com>
Date:   Fri Jan 3 14:28:18 2014 -0800

    bonding: add bounds checking for tbl params
    
    Add bounds checking for params defined with parm tbl.
    
    Signed-off-by: Scott Feldman <sfeldma@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index c9691bf0586c..945a6668da83 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -19,19 +19,11 @@
 #include <linux/reciprocal_div.h>
 #include "bonding.h"
 
-static bool bond_mode_is_valid(int mode)
-{
-	int i;
-
-	for (i = 0; bond_mode_tbl[i].modename; i++);
-
-	return mode >= 0 && mode < i;
-}
-
 int bond_option_mode_set(struct bonding *bond, int mode)
 {
-	if (!bond_mode_is_valid(mode)) {
-		pr_err("invalid mode value %d.\n", mode);
+	if (bond_parm_tbl_lookup(mode, bond_mode_tbl) < 0) {
+		pr_err("%s: Ignoring invalid mode value %d.\n",
+		       bond->dev->name, mode);
 		return -EINVAL;
 	}
 
@@ -438,11 +430,18 @@ int bond_option_arp_ip_targets_set(struct bonding *bond, __be32 *targets,
 
 int bond_option_arp_validate_set(struct bonding *bond, int arp_validate)
 {
+	if (bond_parm_tbl_lookup(arp_validate, arp_validate_tbl) < 0) {
+		pr_err("%s: Ignoring invalid arp_validate value %d.\n",
+		       bond->dev->name, arp_validate);
+		return -EINVAL;
+	}
+
 	if (bond->params.mode != BOND_MODE_ACTIVEBACKUP) {
 		pr_err("%s: arp_validate only supported in active-backup mode.\n",
 		       bond->dev->name);
 		return -EINVAL;
 	}
+
 	pr_info("%s: setting arp_validate to %s (%d).\n",
 		bond->dev->name, arp_validate_tbl[arp_validate].modename,
 		arp_validate);
@@ -460,6 +459,12 @@ int bond_option_arp_validate_set(struct bonding *bond, int arp_validate)
 
 int bond_option_arp_all_targets_set(struct bonding *bond, int arp_all_targets)
 {
+	if (bond_parm_tbl_lookup(arp_all_targets, arp_all_targets_tbl) < 0) {
+		pr_err("%s: Ignoring invalid arp_all_targets value %d.\n",
+		       bond->dev->name, arp_all_targets);
+		return -EINVAL;
+	}
+
 	pr_info("%s: setting arp_all_targets to %s (%d).\n",
 		bond->dev->name, arp_all_targets_tbl[arp_all_targets].modename,
 		arp_all_targets);
@@ -523,6 +528,12 @@ int bond_option_primary_set(struct bonding *bond, const char *primary)
 
 int bond_option_primary_reselect_set(struct bonding *bond, int primary_reselect)
 {
+	if (bond_parm_tbl_lookup(primary_reselect, pri_reselect_tbl) < 0) {
+		pr_err("%s: Ignoring invalid primary_reselect value %d.\n",
+		       bond->dev->name, primary_reselect);
+		return -EINVAL;
+	}
+
 	bond->params.primary_reselect = primary_reselect;
 	pr_info("%s: setting primary_reselect to %s (%d).\n",
 		bond->dev->name, pri_reselect_tbl[primary_reselect].modename,
@@ -539,6 +550,12 @@ int bond_option_primary_reselect_set(struct bonding *bond, int primary_reselect)
 
 int bond_option_fail_over_mac_set(struct bonding *bond, int fail_over_mac)
 {
+	if (bond_parm_tbl_lookup(fail_over_mac, fail_over_mac_tbl) < 0) {
+		pr_err("%s: Ignoring invalid fail_over_mac value %d.\n",
+		       bond->dev->name, fail_over_mac);
+		return -EINVAL;
+	}
+
 	if (bond_has_slaves(bond)) {
 		pr_err("%s: Can't alter fail_over_mac with slaves in bond.\n",
 		       bond->dev->name);
@@ -555,6 +572,12 @@ int bond_option_fail_over_mac_set(struct bonding *bond, int fail_over_mac)
 
 int bond_option_xmit_hash_policy_set(struct bonding *bond, int xmit_hash_policy)
 {
+	if (bond_parm_tbl_lookup(xmit_hash_policy, xmit_hashtype_tbl) < 0) {
+		pr_err("%s: Ignoring invalid xmit_hash_policy value %d.\n",
+		       bond->dev->name, xmit_hash_policy);
+		return -EINVAL;
+	}
+
 	bond->params.xmit_policy = xmit_hash_policy;
 	pr_info("%s: setting xmit hash policy to %s (%d).\n",
 		bond->dev->name,
@@ -659,6 +682,12 @@ int bond_option_packets_per_slave_set(struct bonding *bond,
 
 int bond_option_lacp_rate_set(struct bonding *bond, int lacp_rate)
 {
+	if (bond_parm_tbl_lookup(lacp_rate, bond_lacp_tbl) < 0) {
+		pr_err("%s: Ignoring invalid LACP rate value %d.\n",
+		       bond->dev->name, lacp_rate);
+		return -EINVAL;
+	}
+
 	if (bond->dev->flags & IFF_UP) {
 		pr_err("%s: Unable to update LACP rate because interface is up.\n",
 		       bond->dev->name);
@@ -671,35 +700,29 @@ int bond_option_lacp_rate_set(struct bonding *bond, int lacp_rate)
 		return -EPERM;
 	}
 
-	if ((lacp_rate == 1) || (lacp_rate == 0)) {
-		bond->params.lacp_fast = lacp_rate;
-		bond_3ad_update_lacp_rate(bond);
-		pr_info("%s: Setting LACP rate to %s (%d).\n",
-			bond->dev->name, bond_lacp_tbl[lacp_rate].modename,
-			lacp_rate);
-	} else {
-		pr_err("%s: Ignoring invalid LACP rate value %d.\n",
-		       bond->dev->name, lacp_rate);
-		return -EINVAL;
-	}
+	bond->params.lacp_fast = lacp_rate;
+	bond_3ad_update_lacp_rate(bond);
+	pr_info("%s: Setting LACP rate to %s (%d).\n",
+		bond->dev->name, bond_lacp_tbl[lacp_rate].modename,
+		lacp_rate);
 
 	return 0;
 }
 
 int bond_option_ad_select_set(struct bonding *bond, int ad_select)
 {
-	if (bond->dev->flags & IFF_UP) {
-		pr_err("%s: Unable to update ad_select because interface is up.\n",
-		       bond->dev->name);
-		return -EPERM;
-	}
-
 	if (bond_parm_tbl_lookup(ad_select, ad_select_tbl) < 0) {
 		pr_err("%s: Ignoring invalid ad_select value %d.\n",
 		       bond->dev->name, ad_select);
 		return -EINVAL;
 	}
 
+	if (bond->dev->flags & IFF_UP) {
+		pr_err("%s: Unable to update ad_select because interface is up.\n",
+		       bond->dev->name);
+		return -EPERM;
+	}
+
 	bond->params.ad_select = ad_select;
 	pr_info("%s: Setting ad_select to %s (%d).\n",
 		bond->dev->name, ad_select_tbl[ad_select].modename,

commit ec029fac3e96980fa8f6f81b8327787a9600dfaa
Author: sfeldma@cumulusnetworks.com <sfeldma@cumulusnetworks.com>
Date:   Fri Jan 3 14:18:49 2014 -0800

    bonding: add ad_select attribute netlink support
    
    Add IFLA_BOND_AD_SELECT to allow get/set of bonding parameter
    ad_select via netlink.
    
    Signed-off-by: Scott Feldman <sfeldma@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index ad67fbf1ba61..c9691bf0586c 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -685,3 +685,25 @@ int bond_option_lacp_rate_set(struct bonding *bond, int lacp_rate)
 
 	return 0;
 }
+
+int bond_option_ad_select_set(struct bonding *bond, int ad_select)
+{
+	if (bond->dev->flags & IFF_UP) {
+		pr_err("%s: Unable to update ad_select because interface is up.\n",
+		       bond->dev->name);
+		return -EPERM;
+	}
+
+	if (bond_parm_tbl_lookup(ad_select, ad_select_tbl) < 0) {
+		pr_err("%s: Ignoring invalid ad_select value %d.\n",
+		       bond->dev->name, ad_select);
+		return -EINVAL;
+	}
+
+	bond->params.ad_select = ad_select;
+	pr_info("%s: Setting ad_select to %s (%d).\n",
+		bond->dev->name, ad_select_tbl[ad_select].modename,
+		ad_select);
+
+	return 0;
+}

commit 998e40bbf8f0e10b5d84107afc61e29dbc8d2de4
Author: sfeldma@cumulusnetworks.com <sfeldma@cumulusnetworks.com>
Date:   Fri Jan 3 14:18:41 2014 -0800

    bonding: add lacp_rate attribute netlink support
    
    Add IFLA_BOND_AD_LACP_RATE to allow get/set of bonding parameter
    lacp_rate via netlink.
    
    Signed-off-by: Scott Feldman <sfeldma@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index f8a2cd8c7b57..ad67fbf1ba61 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -656,3 +656,32 @@ int bond_option_packets_per_slave_set(struct bonding *bond,
 
 	return 0;
 }
+
+int bond_option_lacp_rate_set(struct bonding *bond, int lacp_rate)
+{
+	if (bond->dev->flags & IFF_UP) {
+		pr_err("%s: Unable to update LACP rate because interface is up.\n",
+		       bond->dev->name);
+		return -EPERM;
+	}
+
+	if (bond->params.mode != BOND_MODE_8023AD) {
+		pr_err("%s: Unable to update LACP rate because bond is not in 802.3ad mode.\n",
+		       bond->dev->name);
+		return -EPERM;
+	}
+
+	if ((lacp_rate == 1) || (lacp_rate == 0)) {
+		bond->params.lacp_fast = lacp_rate;
+		bond_3ad_update_lacp_rate(bond);
+		pr_info("%s: Setting LACP rate to %s (%d).\n",
+			bond->dev->name, bond_lacp_tbl[lacp_rate].modename,
+			lacp_rate);
+	} else {
+		pr_err("%s: Ignoring invalid LACP rate value %d.\n",
+		       bond->dev->name, lacp_rate);
+		return -EINVAL;
+	}
+
+	return 0;
+}

commit c13ab3ff176eab78b6ee93817484584af5807cf2
Author: sfeldma@cumulusnetworks.com <sfeldma@cumulusnetworks.com>
Date:   Tue Dec 17 21:30:37 2013 -0800

    bonding: add packets_per_slave attribute netlink support
    
    Add IFLA_BOND_PACKETS_PER_SLAVE to allow get/set of bonding parameter
    packets_per_slave via netlink.
    
    Signed-off-by: Scott Feldman <sfeldma@cumulusnetworks.com>
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index e313a8f8fae0..f8a2cd8c7b57 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -16,6 +16,7 @@
 #include <linux/netdevice.h>
 #include <linux/rwlock.h>
 #include <linux/rcupdate.h>
+#include <linux/reciprocal_div.h>
 #include "bonding.h"
 
 static bool bond_mode_is_valid(int mode)
@@ -633,3 +634,25 @@ int bond_option_lp_interval_set(struct bonding *bond, int lp_interval)
 
 	return 0;
 }
+
+int bond_option_packets_per_slave_set(struct bonding *bond,
+				      int packets_per_slave)
+{
+	if (packets_per_slave < 0 || packets_per_slave > USHRT_MAX) {
+		pr_err("%s: packets_per_slave must be between 0 and %u\n",
+		       bond->dev->name, USHRT_MAX);
+		return -EINVAL;
+	}
+
+	if (bond->params.mode != BOND_MODE_ROUNDROBIN)
+		pr_warn("%s: Warning: packets_per_slave has effect only in balance-rr mode\n",
+			bond->dev->name);
+
+	if (packets_per_slave > 1)
+		bond->params.packets_per_slave =
+			reciprocal_value(packets_per_slave);
+	else
+		bond->params.packets_per_slave = packets_per_slave;
+
+	return 0;
+}

commit 8d836d092ed7b77d13ac1108399165ee7de7463f
Author: sfeldma@cumulusnetworks.com <sfeldma@cumulusnetworks.com>
Date:   Tue Dec 17 21:30:30 2013 -0800

    bonding: add lp_interval attribute netlink support
    
    Add IFLA_BOND_LP_INTERVAL to allow get/set of bonding parameter
    lp_interval via netlink.
    
    Signed-off-by: Scott Feldman <sfeldma@cumulusnetworks.com>
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index da49ac4a8d8e..e313a8f8fae0 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -620,3 +620,16 @@ int bond_option_min_links_set(struct bonding *bond, int min_links)
 
 	return 0;
 }
+
+int bond_option_lp_interval_set(struct bonding *bond, int lp_interval)
+{
+	if (lp_interval <= 0) {
+		pr_err("%s: lp_interval must be between 1 and %d\n",
+		       bond->dev->name, INT_MAX);
+		return -EINVAL;
+	}
+
+	bond->params.lp_interval = lp_interval;
+
+	return 0;
+}

commit 7d1010082785b2020b1e2e1211b76209976a33df
Author: sfeldma@cumulusnetworks.com <sfeldma@cumulusnetworks.com>
Date:   Tue Dec 17 21:30:23 2013 -0800

    bonding: add min_links attribute netlink support
    
    Add IFLA_BOND_MIN_LINKS to allow get/set of bonding parameter
    min_links via netlink.
    
    Signed-off-by: Scott Feldman <sfeldma@cumulusnetworks.com>
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index cbd832293da4..da49ac4a8d8e 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -611,3 +611,12 @@ int bond_option_all_slaves_active_set(struct bonding *bond,
 
 	return 0;
 }
+
+int bond_option_min_links_set(struct bonding *bond, int min_links)
+{
+	pr_info("%s: Setting min links value to %u\n",
+		bond->dev->name, min_links);
+	bond->params.min_links = min_links;
+
+	return 0;
+}

commit 1cc0b1e30c662d84a89690f42826cf49e2278b97
Author: sfeldma@cumulusnetworks.com <sfeldma@cumulusnetworks.com>
Date:   Tue Dec 17 21:30:16 2013 -0800

    bonding: add all_slaves_active attribute netlink support
    
    Add IFLA_BOND_ALL_SLAVES_ACTIVE to allow get/set of bonding parameter
    all_slaves_active via netlink.
    
    Signed-off-by: Scott Feldman <sfeldma@cumulusnetworks.com>
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 01a966916dcb..cbd832293da4 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -582,3 +582,32 @@ int bond_option_num_peer_notif_set(struct bonding *bond, int num_peer_notif)
 	bond->params.num_peer_notif = num_peer_notif;
 	return 0;
 }
+
+int bond_option_all_slaves_active_set(struct bonding *bond,
+				      int all_slaves_active)
+{
+	struct list_head *iter;
+	struct slave *slave;
+
+	if (all_slaves_active == bond->params.all_slaves_active)
+		return 0;
+
+	if ((all_slaves_active == 0) || (all_slaves_active == 1)) {
+		bond->params.all_slaves_active = all_slaves_active;
+	} else {
+		pr_info("%s: Ignoring invalid all_slaves_active value %d.\n",
+			bond->dev->name, all_slaves_active);
+		return -EINVAL;
+	}
+
+	bond_for_each_slave(bond, slave, iter) {
+		if (!bond_is_active_slave(slave)) {
+			if (all_slaves_active)
+				slave->inactive = 0;
+			else
+				slave->inactive = 1;
+		}
+	}
+
+	return 0;
+}

commit 2c9839c143bbc8c6612f56351dae8d57111aee37
Author: sfeldma@cumulusnetworks.com <sfeldma@cumulusnetworks.com>
Date:   Tue Dec 17 21:30:09 2013 -0800

    bonding: add num_grat_arp attribute netlink support
    
    Add IFLA_BOND_NUM_PEER_NOTIF to allow get/set of bonding parameter
    num_grat_arp via netlink.  Bonding parameter num_unsol_na is
    synonymous with num_grat_arp, so add only one netlink attribute
    to represent both bonding parameters.
    
    Signed-off-by: Scott Feldman <sfeldma@cumulusnetworks.com>
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 1ed7dff9a679..01a966916dcb 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -576,3 +576,9 @@ int bond_option_resend_igmp_set(struct bonding *bond, int resend_igmp)
 
 	return 0;
 }
+
+int bond_option_num_peer_notif_set(struct bonding *bond, int num_peer_notif)
+{
+	bond->params.num_peer_notif = num_peer_notif;
+	return 0;
+}

commit d8838de70adc64e20db531333e035aacd5910fca
Author: sfeldma@cumulusnetworks.com <sfeldma@cumulusnetworks.com>
Date:   Sun Dec 15 16:42:19 2013 -0800

    bonding: add resend_igmp attribute netlink support
    
    Add IFLA_BOND_RESEND_IGMP to allow get/set of bonding parameter
    resend_igmp via netlink.
    
    Signed-off-by: Scott Feldman <sfeldma@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 8510c6df115b..1ed7dff9a679 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -561,3 +561,18 @@ int bond_option_xmit_hash_policy_set(struct bonding *bond, int xmit_hash_policy)
 
 	return 0;
 }
+
+int bond_option_resend_igmp_set(struct bonding *bond, int resend_igmp)
+{
+	if (resend_igmp < 0 || resend_igmp > 255) {
+		pr_err("%s: Invalid resend_igmp value %d not in range 0-255; rejected.\n",
+		       bond->dev->name, resend_igmp);
+		return -EINVAL;
+	}
+
+	bond->params.resend_igmp = resend_igmp;
+	pr_info("%s: Setting resend_igmp to %d.\n",
+		bond->dev->name, resend_igmp);
+
+	return 0;
+}

commit f70161c67231f54f784529d7447ce4386d258b7a
Author: sfeldma@cumulusnetworks.com <sfeldma@cumulusnetworks.com>
Date:   Sun Dec 15 16:42:12 2013 -0800

    bonding: add xmit_hash_policy attribute netlink support
    
    Add IFLA_BOND_XMIT_HASH_POLICY to allow get/set of bonding parameter
    xmit_hash_policy via netlink.
    
    Signed-off-by: Scott Feldman <sfeldma@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 86f462008932..8510c6df115b 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -551,3 +551,13 @@ int bond_option_fail_over_mac_set(struct bonding *bond, int fail_over_mac)
 
 	return 0;
 }
+
+int bond_option_xmit_hash_policy_set(struct bonding *bond, int xmit_hash_policy)
+{
+	bond->params.xmit_policy = xmit_hash_policy;
+	pr_info("%s: setting xmit hash policy to %s (%d).\n",
+		bond->dev->name,
+		xmit_hashtype_tbl[xmit_hash_policy].modename, xmit_hash_policy);
+
+	return 0;
+}

commit 89901972de4c00e74e56529804493734d77ee3d3
Author: sfeldma@cumulusnetworks.com <sfeldma@cumulusnetworks.com>
Date:   Sun Dec 15 16:42:05 2013 -0800

    bonding: add fail_over_mac attribute netlink support
    
    Add IFLA_BOND_FAIL_OVER_MAC to allow get/set of bonding parameter
    fail_over_mac via netlink.
    
    Signed-off-by: Scott Feldman <sfeldma@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 80a9df4e4bf7..86f462008932 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -535,3 +535,19 @@ int bond_option_primary_reselect_set(struct bonding *bond, int primary_reselect)
 
 	return 0;
 }
+
+int bond_option_fail_over_mac_set(struct bonding *bond, int fail_over_mac)
+{
+	if (bond_has_slaves(bond)) {
+		pr_err("%s: Can't alter fail_over_mac with slaves in bond.\n",
+		       bond->dev->name);
+		return -EPERM;
+	}
+
+	bond->params.fail_over_mac = fail_over_mac;
+	pr_info("%s: Setting fail_over_mac to %s (%d).\n",
+		bond->dev->name, fail_over_mac_tbl[fail_over_mac].modename,
+		fail_over_mac);
+
+	return 0;
+}

commit 8a41ae4496e534a8b68d9bc3c79113e16d1fcd4c
Author: sfeldma@cumulusnetworks.com <sfeldma@cumulusnetworks.com>
Date:   Sun Dec 15 16:41:58 2013 -0800

    bonding: add primary_select attribute netlink support
    
    Add IFLA_BOND_PRIMARY_SELECT to allow get/set of bonding parameter
    primary_select via netlink.
    
    Signed-off-by: Scott Feldman <sfeldma@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index c410d2d0dc33..80a9df4e4bf7 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -519,3 +519,19 @@ int bond_option_primary_set(struct bonding *bond, const char *primary)
 
 	return err;
 }
+
+int bond_option_primary_reselect_set(struct bonding *bond, int primary_reselect)
+{
+	bond->params.primary_reselect = primary_reselect;
+	pr_info("%s: setting primary_reselect to %s (%d).\n",
+		bond->dev->name, pri_reselect_tbl[primary_reselect].modename,
+		primary_reselect);
+
+	block_netpoll_tx();
+	write_lock_bh(&bond->curr_slave_lock);
+	bond_select_active_slave(bond);
+	write_unlock_bh(&bond->curr_slave_lock);
+	unblock_netpoll_tx();
+
+	return 0;
+}

commit 0a98a0d12c40f9354b942325045cae123d594341
Author: sfeldma@cumulusnetworks.com <sfeldma@cumulusnetworks.com>
Date:   Sun Dec 15 16:41:51 2013 -0800

    bonding: add primary attribute netlink support
    
    Add IFLA_BOND_PRIMARY to allow get/set of bonding parameter
    primary via netlink.
    
    Signed-off-by: Scott Feldman <sfeldma@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 600779e5904f..c410d2d0dc33 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -467,3 +467,55 @@ int bond_option_arp_all_targets_set(struct bonding *bond, int arp_all_targets)
 
 	return 0;
 }
+
+int bond_option_primary_set(struct bonding *bond, const char *primary)
+{
+	struct list_head *iter;
+	struct slave *slave;
+	int err = 0;
+
+	block_netpoll_tx();
+	read_lock(&bond->lock);
+	write_lock_bh(&bond->curr_slave_lock);
+
+	if (!USES_PRIMARY(bond->params.mode)) {
+		pr_err("%s: Unable to set primary slave; %s is in mode %d\n",
+		       bond->dev->name, bond->dev->name, bond->params.mode);
+		err = -EINVAL;
+		goto out;
+	}
+
+	/* check to see if we are clearing primary */
+	if (!strlen(primary)) {
+		pr_info("%s: Setting primary slave to None.\n",
+			bond->dev->name);
+		bond->primary_slave = NULL;
+		memset(bond->params.primary, 0, sizeof(bond->params.primary));
+		bond_select_active_slave(bond);
+		goto out;
+	}
+
+	bond_for_each_slave(bond, slave, iter) {
+		if (strncmp(slave->dev->name, primary, IFNAMSIZ) == 0) {
+			pr_info("%s: Setting %s as primary slave.\n",
+				bond->dev->name, slave->dev->name);
+			bond->primary_slave = slave;
+			strcpy(bond->params.primary, slave->dev->name);
+			bond_select_active_slave(bond);
+			goto out;
+		}
+	}
+
+	strncpy(bond->params.primary, primary, IFNAMSIZ);
+	bond->params.primary[IFNAMSIZ - 1] = 0;
+
+	pr_info("%s: Recording %s as primary, but it has not been enslaved to %s yet.\n",
+		bond->dev->name, primary, bond->dev->name);
+
+out:
+	write_unlock_bh(&bond->curr_slave_lock);
+	read_unlock(&bond->lock);
+	unblock_netpoll_tx();
+
+	return err;
+}

commit 4e789fc1a62d4c25726ee053044399d71471fe2f
Author: dingtianhong <dingtianhong@huawei.com>
Date:   Fri Dec 13 10:20:17 2013 +0800

    bonding: remove unwanted lock for bond_option_active_slave_set()
    
    The bond_option_active_slave_set() is always called in RTNL,
    the RTNL could protect bond slave list, so remove the unwanted
    bond lock.
    
    Suggested-by: Jay Vosburgh <fubar@us.ibm.com>
    Suggested-by: Veaceslav Falico <vfalico@redhat.com>
    Signed-off-by: Ding Tianhong <dingtianhong@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index dfef673d53d1..600779e5904f 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -107,7 +107,6 @@ int bond_option_active_slave_set(struct bonding *bond,
 	}
 
 	block_netpoll_tx();
-	read_lock(&bond->lock);
 	write_lock_bh(&bond->curr_slave_lock);
 
 	/* check to see if we are clearing active */
@@ -142,7 +141,6 @@ int bond_option_active_slave_set(struct bonding *bond,
 	}
 
 	write_unlock_bh(&bond->curr_slave_lock);
-	read_unlock(&bond->lock);
 	unblock_netpoll_tx();
 	return ret;
 }

commit d5c842544342fc3f13774ffc5581d4dd3975059b
Author: sfeldma@cumulusnetworks.com <sfeldma@cumulusnetworks.com>
Date:   Thu Dec 12 14:10:45 2013 -0800

    bonding: add arp_all_targets netlink support
    
    Add IFLA_BOND_ARP_ALL_TARGETS to allow get/set of bonding parameter
    arp_all_targets via netlink.
    
    Signed-off-by: Scott Feldman <sfeldma@cumulusnetworks.com>
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 698079e94e74..dfef673d53d1 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -458,3 +458,14 @@ int bond_option_arp_validate_set(struct bonding *bond, int arp_validate)
 
 	return 0;
 }
+
+int bond_option_arp_all_targets_set(struct bonding *bond, int arp_all_targets)
+{
+	pr_info("%s: setting arp_all_targets to %s (%d).\n",
+		bond->dev->name, arp_all_targets_tbl[arp_all_targets].modename,
+		arp_all_targets);
+
+	bond->params.arp_all_targets = arp_all_targets;
+
+	return 0;
+}

commit 29c4948293bfc426e52a921f4259eb3676961e81
Author: sfeldma@cumulusnetworks.com <sfeldma@cumulusnetworks.com>
Date:   Thu Dec 12 14:10:38 2013 -0800

    bonding: add arp_validate netlink support
    
    Add IFLA_BOND_ARP_VALIDATE to allow get/set of bonding parameter
    arp_validate via netlink.
    
    Signed-off-by: Scott Feldman <sfeldma@cumulusnetworks.com>
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index f8c2e4f17066..698079e94e74 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -436,3 +436,25 @@ int bond_option_arp_ip_targets_set(struct bonding *bond, __be32 *targets,
 	write_unlock_bh(&bond->lock);
 	return ret;
 }
+
+int bond_option_arp_validate_set(struct bonding *bond, int arp_validate)
+{
+	if (bond->params.mode != BOND_MODE_ACTIVEBACKUP) {
+		pr_err("%s: arp_validate only supported in active-backup mode.\n",
+		       bond->dev->name);
+		return -EINVAL;
+	}
+	pr_info("%s: setting arp_validate to %s (%d).\n",
+		bond->dev->name, arp_validate_tbl[arp_validate].modename,
+		arp_validate);
+
+	if (bond->dev->flags & IFF_UP) {
+		if (!arp_validate)
+			bond->recv_probe = NULL;
+		else if (bond->params.arp_interval)
+			bond->recv_probe = bond_arp_rcv;
+	}
+	bond->params.arp_validate = arp_validate;
+
+	return 0;
+}

commit 7f28fa10e21376a10d3b9faad5836869465cc376
Author: sfeldma@cumulusnetworks.com <sfeldma@cumulusnetworks.com>
Date:   Thu Dec 12 14:10:31 2013 -0800

    bonding: add arp_ip_target netlink support
    
    Add IFLA_BOND_ARP_IP_TARGET to allow get/set of bonding parameter
    arp_ip_target via netlink.
    
    Signed-off-by: Scott Feldman <sfeldma@cumulusnetworks.com>
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index a84e729d02ef..f8c2e4f17066 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -306,3 +306,133 @@ int bond_option_arp_interval_set(struct bonding *bond, int arp_interval)
 
 	return 0;
 }
+
+static void _bond_options_arp_ip_target_set(struct bonding *bond, int slot,
+					    __be32 target,
+					    unsigned long last_rx)
+{
+	__be32 *targets = bond->params.arp_targets;
+	struct list_head *iter;
+	struct slave *slave;
+
+	if (slot >= 0 && slot < BOND_MAX_ARP_TARGETS) {
+		bond_for_each_slave(bond, slave, iter)
+			slave->target_last_arp_rx[slot] = last_rx;
+		targets[slot] = target;
+	}
+}
+
+static int _bond_option_arp_ip_target_add(struct bonding *bond, __be32 target)
+{
+	__be32 *targets = bond->params.arp_targets;
+	int ind;
+
+	if (IS_IP_TARGET_UNUSABLE_ADDRESS(target)) {
+		pr_err("%s: invalid ARP target %pI4 specified for addition\n",
+		       bond->dev->name, &target);
+		return -EINVAL;
+	}
+
+	if (bond_get_targets_ip(targets, target) != -1) { /* dup */
+		pr_err("%s: ARP target %pI4 is already present\n",
+		       bond->dev->name, &target);
+		return -EINVAL;
+	}
+
+	ind = bond_get_targets_ip(targets, 0); /* first free slot */
+	if (ind == -1) {
+		pr_err("%s: ARP target table is full!\n",
+		       bond->dev->name);
+		return -EINVAL;
+	}
+
+	pr_info("%s: adding ARP target %pI4.\n", bond->dev->name, &target);
+
+	_bond_options_arp_ip_target_set(bond, ind, target, jiffies);
+
+	return 0;
+}
+
+int bond_option_arp_ip_target_add(struct bonding *bond, __be32 target)
+{
+	int ret;
+
+	/* not to race with bond_arp_rcv */
+	write_lock_bh(&bond->lock);
+	ret = _bond_option_arp_ip_target_add(bond, target);
+	write_unlock_bh(&bond->lock);
+
+	return ret;
+}
+
+int bond_option_arp_ip_target_rem(struct bonding *bond, __be32 target)
+{
+	__be32 *targets = bond->params.arp_targets;
+	struct list_head *iter;
+	struct slave *slave;
+	unsigned long *targets_rx;
+	int ind, i;
+
+	if (IS_IP_TARGET_UNUSABLE_ADDRESS(target)) {
+		pr_err("%s: invalid ARP target %pI4 specified for removal\n",
+		       bond->dev->name, &target);
+		return -EINVAL;
+	}
+
+	ind = bond_get_targets_ip(targets, target);
+	if (ind == -1) {
+		pr_err("%s: unable to remove nonexistent ARP target %pI4.\n",
+		       bond->dev->name, &target);
+		return -EINVAL;
+	}
+
+	if (ind == 0 && !targets[1] && bond->params.arp_interval)
+		pr_warn("%s: removing last arp target with arp_interval on\n",
+			bond->dev->name);
+
+	pr_info("%s: removing ARP target %pI4.\n", bond->dev->name,
+		&target);
+
+	/* not to race with bond_arp_rcv */
+	write_lock_bh(&bond->lock);
+
+	bond_for_each_slave(bond, slave, iter) {
+		targets_rx = slave->target_last_arp_rx;
+		for (i = ind; (i < BOND_MAX_ARP_TARGETS-1) && targets[i+1]; i++)
+			targets_rx[i] = targets_rx[i+1];
+		targets_rx[i] = 0;
+	}
+	for (i = ind; (i < BOND_MAX_ARP_TARGETS-1) && targets[i+1]; i++)
+		targets[i] = targets[i+1];
+	targets[i] = 0;
+
+	write_unlock_bh(&bond->lock);
+
+	return 0;
+}
+
+int bond_option_arp_ip_targets_set(struct bonding *bond, __be32 *targets,
+				   int count)
+{
+	int i, ret = 0;
+
+	/* not to race with bond_arp_rcv */
+	write_lock_bh(&bond->lock);
+
+	/* clear table */
+	for (i = 0; i < BOND_MAX_ARP_TARGETS; i++)
+		_bond_options_arp_ip_target_set(bond, i, 0, 0);
+
+	if (count == 0 && bond->params.arp_interval)
+		pr_warn("%s: removing last arp target with arp_interval on\n",
+			bond->dev->name);
+
+	for (i = 0; i < count; i++) {
+		ret = _bond_option_arp_ip_target_add(bond, targets[i]);
+		if (ret)
+			break;
+	}
+
+	write_unlock_bh(&bond->lock);
+	return ret;
+}

commit 06151dbcf3f76edbe900138cde9e862f429918c9
Author: sfeldma@cumulusnetworks.com <sfeldma@cumulusnetworks.com>
Date:   Thu Dec 12 14:10:24 2013 -0800

    bonding: add arp_interval netlink support
    
    Add IFLA_BOND_ARP_INTERVAL to allow get/set of bonding parameter
    arp_interval via netlink.
    
    Signed-off-by: Scott Feldman <sfeldma@cumulusnetworks.com>
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 6fc7bbf0b85f..a84e729d02ef 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -259,3 +259,50 @@ int bond_option_use_carrier_set(struct bonding *bond, int use_carrier)
 
 	return 0;
 }
+
+int bond_option_arp_interval_set(struct bonding *bond, int arp_interval)
+{
+	if (arp_interval < 0) {
+		pr_err("%s: Invalid arp_interval value %d not in range 0-%d; rejected.\n",
+		       bond->dev->name, arp_interval, INT_MAX);
+		return -EINVAL;
+	}
+	if (BOND_NO_USES_ARP(bond->params.mode)) {
+		pr_info("%s: ARP monitoring cannot be used with ALB/TLB/802.3ad. Only MII monitoring is supported on %s.\n",
+			bond->dev->name, bond->dev->name);
+		return -EINVAL;
+	}
+	pr_info("%s: Setting ARP monitoring interval to %d.\n",
+		bond->dev->name, arp_interval);
+	bond->params.arp_interval = arp_interval;
+	if (arp_interval) {
+		if (bond->params.miimon) {
+			pr_info("%s: ARP monitoring cannot be used with MII monitoring. %s Disabling MII monitoring.\n",
+				bond->dev->name, bond->dev->name);
+			bond->params.miimon = 0;
+		}
+		if (!bond->params.arp_targets[0])
+			pr_info("%s: ARP monitoring has been set up, but no ARP targets have been specified.\n",
+				bond->dev->name);
+	}
+	if (bond->dev->flags & IFF_UP) {
+		/* If the interface is up, we may need to fire off
+		 * the ARP timer.  If the interface is down, the
+		 * timer will get fired off when the open function
+		 * is called.
+		 */
+		if (!arp_interval) {
+			if (bond->params.arp_validate)
+				bond->recv_probe = NULL;
+			cancel_delayed_work_sync(&bond->arp_work);
+		} else {
+			/* arp_validate can be set only in active-backup mode */
+			if (bond->params.arp_validate)
+				bond->recv_probe = bond_arp_rcv;
+			cancel_delayed_work_sync(&bond->mii_work);
+			queue_delayed_work(bond->wq, &bond->arp_work, 0);
+		}
+	}
+
+	return 0;
+}

commit 9f53e14e86c46a2300f17309f6308ad0dfbb53ff
Author: sfeldma@cumulusnetworks.com <sfeldma@cumulusnetworks.com>
Date:   Thu Dec 12 14:10:16 2013 -0800

    bonding: add use_carrier netlink support
    
    Add IFLA_BOND_USE_CARRIER to allow get/set of bonding parameter
    use_carrier via netlink.
    
    Signed-off-by: Scott Feldman <sfeldma@cumulusnetworks.com>
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 2914d649ee34..6fc7bbf0b85f 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -245,3 +245,17 @@ int bond_option_downdelay_set(struct bonding *bond, int downdelay)
 
 	return 0;
 }
+
+int bond_option_use_carrier_set(struct bonding *bond, int use_carrier)
+{
+	if ((use_carrier == 0) || (use_carrier == 1)) {
+		bond->params.use_carrier = use_carrier;
+		pr_info("%s: Setting use_carrier to %d.\n",
+			bond->dev->name, use_carrier);
+	} else {
+		pr_info("%s: Ignoring invalid use_carrier value %d.\n",
+			bond->dev->name, use_carrier);
+	}
+
+	return 0;
+}

commit c7461f9bf5a11bf88fdbd05b26c6d55b77dcd46d
Author: sfeldma@cumulusnetworks.com <sfeldma@cumulusnetworks.com>
Date:   Thu Dec 12 14:10:09 2013 -0800

    bonding: add downdelay netlink support
    
    Add IFLA_BOND_DOWNDELAY to allow get/set of bonding parameter
    downdelay via netlink.
    
    Signed-off-by: Scott Feldman <sfeldma@cumulusnetworks.com>
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index ae94b847ffcc..2914d649ee34 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -216,3 +216,32 @@ int bond_option_updelay_set(struct bonding *bond, int updelay)
 
 	return 0;
 }
+
+int bond_option_downdelay_set(struct bonding *bond, int downdelay)
+{
+	if (!(bond->params.miimon)) {
+		pr_err("%s: Unable to set down delay as MII monitoring is disabled\n",
+		       bond->dev->name);
+		return -EPERM;
+	}
+
+	if (downdelay < 0) {
+		pr_err("%s: Invalid down delay value %d not in range %d-%d; rejected.\n",
+		       bond->dev->name, downdelay, 0, INT_MAX);
+		return -EINVAL;
+	} else {
+		if ((downdelay % bond->params.miimon) != 0) {
+			pr_warn("%s: Warning: down delay (%d) is not a multiple of miimon (%d), delay rounded to %d ms\n",
+				bond->dev->name, downdelay,
+				bond->params.miimon,
+				(downdelay / bond->params.miimon) *
+				bond->params.miimon);
+		}
+		bond->params.downdelay = downdelay / bond->params.miimon;
+		pr_info("%s: Setting down delay to %d.\n",
+			bond->dev->name,
+			bond->params.downdelay * bond->params.miimon);
+	}
+
+	return 0;
+}

commit 25852e29dfc58d249ad0db235996b36c33db6d61
Author: sfeldma@cumulusnetworks.com <sfeldma@cumulusnetworks.com>
Date:   Thu Dec 12 14:10:02 2013 -0800

    bonding: add updelay netlink support
    
    Add IFLA_BOND_UPDELAY to allow get/set of bonding parameter
    updelay via netlink.
    
    Signed-off-by: Scott Feldman <sfeldma@cumulusnetworks.com>
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 8ae42d36f11f..ae94b847ffcc 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -187,3 +187,32 @@ int bond_option_miimon_set(struct bonding *bond, int miimon)
 	}
 	return 0;
 }
+
+int bond_option_updelay_set(struct bonding *bond, int updelay)
+{
+	if (!(bond->params.miimon)) {
+		pr_err("%s: Unable to set up delay as MII monitoring is disabled\n",
+		       bond->dev->name);
+		return -EPERM;
+	}
+
+	if (updelay < 0) {
+		pr_err("%s: Invalid up delay value %d not in range %d-%d; rejected.\n",
+		       bond->dev->name, updelay, 0, INT_MAX);
+		return -EINVAL;
+	} else {
+		if ((updelay % bond->params.miimon) != 0) {
+			pr_warn("%s: Warning: up delay (%d) is not a multiple of miimon (%d), updelay rounded to %d ms\n",
+				bond->dev->name, updelay,
+				bond->params.miimon,
+				(updelay / bond->params.miimon) *
+				bond->params.miimon);
+		}
+		bond->params.updelay = updelay / bond->params.miimon;
+		pr_info("%s: Setting up delay to %d.\n",
+			bond->dev->name,
+			bond->params.updelay * bond->params.miimon);
+	}
+
+	return 0;
+}

commit eecdaa6e20284efbe9e76eebd44eac2b22f7b5d7
Author: sfeldma@cumulusnetworks.com <sfeldma@cumulusnetworks.com>
Date:   Thu Dec 12 14:09:55 2013 -0800

    bonding: add miimon netlink support
    
    Add IFLA_BOND_MIIMON to allow get/set of bonding parameter
    miimon via netlink.
    
    Signed-off-by: Scott Feldman <sfeldma@cumulusnetworks.com>
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index ea6f640782b7..8ae42d36f11f 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -1,6 +1,7 @@
 /*
  * drivers/net/bond/bond_options.c - bonding options
  * Copyright (c) 2013 Jiri Pirko <jiri@resnulli.us>
+ * Copyright (c) 2013 Scott Feldman <sfeldma@cumulusnetworks.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -145,3 +146,44 @@ int bond_option_active_slave_set(struct bonding *bond,
 	unblock_netpoll_tx();
 	return ret;
 }
+
+int bond_option_miimon_set(struct bonding *bond, int miimon)
+{
+	if (miimon < 0) {
+		pr_err("%s: Invalid miimon value %d not in range %d-%d; rejected.\n",
+		       bond->dev->name, miimon, 0, INT_MAX);
+		return -EINVAL;
+	}
+	pr_info("%s: Setting MII monitoring interval to %d.\n",
+		bond->dev->name, miimon);
+	bond->params.miimon = miimon;
+	if (bond->params.updelay)
+		pr_info("%s: Note: Updating updelay (to %d) since it is a multiple of the miimon value.\n",
+			bond->dev->name,
+			bond->params.updelay * bond->params.miimon);
+	if (bond->params.downdelay)
+		pr_info("%s: Note: Updating downdelay (to %d) since it is a multiple of the miimon value.\n",
+			bond->dev->name,
+			bond->params.downdelay * bond->params.miimon);
+	if (miimon && bond->params.arp_interval) {
+		pr_info("%s: MII monitoring cannot be used with ARP monitoring. Disabling ARP monitoring...\n",
+			bond->dev->name);
+		bond->params.arp_interval = 0;
+		if (bond->params.arp_validate)
+			bond->params.arp_validate = BOND_ARP_VALIDATE_NONE;
+	}
+	if (bond->dev->flags & IFF_UP) {
+		/* If the interface is up, we may need to fire off
+		 * the MII timer. If the interface is down, the
+		 * timer will get fired off when the open function
+		 * is called.
+		 */
+		if (!miimon) {
+			cancel_delayed_work_sync(&bond->mii_work);
+		} else {
+			cancel_delayed_work_sync(&bond->arp_work);
+			queue_delayed_work(bond->wq, &bond->mii_work, 0);
+		}
+	}
+	return 0;
+}

commit fe9d04afe9bee0ec37a9724937443b2c0e39ce4b
Author: dingtianhong <dingtianhong@huawei.com>
Date:   Fri Nov 22 22:28:43 2013 +0800

    bonding: disable arp and enable mii monitoring when bond change to no uses arp mode
    
    Because the ARP monitoring is not support for 802.3ad, but I still
    could change the mode to 802.3ad from ab mode while ARP monitoring
    is running, it is incorrect.
    
    So add a check for 802.3ad in bonding_store_mode to fix the problem,
    and make a new macro BOND_NO_USES_ARP() to simplify the code.
    
    v2: according to the Dan Williams's suggestion, bond mode is the most
        important bond option, it should override any of the other sub-options.
        So when the mode is changed, the conficting values should be cleared
        or reset, otherwise the user has to duplicate more operations to modify
        the logic. I disable the arp and enable mii monitoring when the bond mode
        is changed to AB, TB and 8023AD if the arp interval is true.
    
    v3: according to the Nik's suggestion, the default value of miimon should need
        a name, there is several place to use it, and the bond_store_arp_interval()
        could use micro BOND_NO_USES_ARP to make the code more simpify.
    
    Suggested-by: Dan Williams <dcbw@redhat.com>
    Suggested-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: Ding Tianhong <dingtianhong@huawei.com>
    Reviewed-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 9a5223c7b4d1..ea6f640782b7 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -45,10 +45,15 @@ int bond_option_mode_set(struct bonding *bond, int mode)
 		return -EPERM;
 	}
 
-	if (BOND_MODE_IS_LB(mode) && bond->params.arp_interval) {
-		pr_err("%s: %s mode is incompatible with arp monitoring.\n",
-		       bond->dev->name, bond_mode_tbl[mode].modename);
-		return -EINVAL;
+	if (BOND_NO_USES_ARP(mode) && bond->params.arp_interval) {
+		pr_info("%s: %s mode is incompatible with arp monitoring, start mii monitoring\n",
+			bond->dev->name, bond_mode_tbl[mode].modename);
+		/* disable arp monitoring */
+		bond->params.arp_interval = 0;
+		/* set miimon to default value */
+		bond->params.miimon = BOND_DEFAULT_MIIMON;
+		pr_info("%s: Setting MII monitoring interval to %d.\n",
+			bond->dev->name, bond->params.miimon);
 	}
 
 	/* don't cache arp_validate between modes */

commit 752d48b52ec929c6fd6ccd7ea9728571830fdd49
Author: Jiri Pirko <jiri@resnulli.us>
Date:   Fri Oct 18 17:43:37 2013 +0200

    bonding: move active_slave getting into separate function
    
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 09af5d10d43a..9a5223c7b4d1 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -57,6 +57,24 @@ int bond_option_mode_set(struct bonding *bond, int mode)
 	return 0;
 }
 
+static struct net_device *__bond_option_active_slave_get(struct bonding *bond,
+							 struct slave *slave)
+{
+	return USES_PRIMARY(bond->params.mode) && slave ? slave->dev : NULL;
+}
+
+struct net_device *bond_option_active_slave_get_rcu(struct bonding *bond)
+{
+	struct slave *slave = rcu_dereference(bond->curr_active_slave);
+
+	return __bond_option_active_slave_get(bond, slave);
+}
+
+struct net_device *bond_option_active_slave_get(struct bonding *bond)
+{
+	return __bond_option_active_slave_get(bond, bond->curr_active_slave);
+}
+
 int bond_option_active_slave_set(struct bonding *bond,
 				 struct net_device *slave_dev)
 {

commit d9e32b21cb394c0816f206539b8c7e9c023db332
Author: Jiri Pirko <jiri@resnulli.us>
Date:   Fri Oct 18 17:43:35 2013 +0200

    bonding: move active_slave setting into separate function
    
    Do a bit of refactoring on the way.
    
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
index 294b7660b054..09af5d10d43a 100644
--- a/drivers/net/bonding/bond_options.c
+++ b/drivers/net/bonding/bond_options.c
@@ -12,6 +12,9 @@
 
 #include <linux/errno.h>
 #include <linux/if.h>
+#include <linux/netdevice.h>
+#include <linux/rwlock.h>
+#include <linux/rcupdate.h>
 #include "bonding.h"
 
 static bool bond_mode_is_valid(int mode)
@@ -53,3 +56,69 @@ int bond_option_mode_set(struct bonding *bond, int mode)
 	bond->params.mode = mode;
 	return 0;
 }
+
+int bond_option_active_slave_set(struct bonding *bond,
+				 struct net_device *slave_dev)
+{
+	int ret = 0;
+
+	if (slave_dev) {
+		if (!netif_is_bond_slave(slave_dev)) {
+			pr_err("Device %s is not bonding slave.\n",
+			       slave_dev->name);
+			return -EINVAL;
+		}
+
+		if (bond->dev != netdev_master_upper_dev_get(slave_dev)) {
+			pr_err("%s: Device %s is not our slave.\n",
+			       bond->dev->name, slave_dev->name);
+			return -EINVAL;
+		}
+	}
+
+	if (!USES_PRIMARY(bond->params.mode)) {
+		pr_err("%s: Unable to change active slave; %s is in mode %d\n",
+		       bond->dev->name, bond->dev->name, bond->params.mode);
+		return -EINVAL;
+	}
+
+	block_netpoll_tx();
+	read_lock(&bond->lock);
+	write_lock_bh(&bond->curr_slave_lock);
+
+	/* check to see if we are clearing active */
+	if (!slave_dev) {
+		pr_info("%s: Clearing current active slave.\n",
+		bond->dev->name);
+		rcu_assign_pointer(bond->curr_active_slave, NULL);
+		bond_select_active_slave(bond);
+	} else {
+		struct slave *old_active = bond->curr_active_slave;
+		struct slave *new_active = bond_slave_get_rtnl(slave_dev);
+
+		BUG_ON(!new_active);
+
+		if (new_active == old_active) {
+			/* do nothing */
+			pr_info("%s: %s is already the current active slave.\n",
+				bond->dev->name, new_active->dev->name);
+		} else {
+			if (old_active && (new_active->link == BOND_LINK_UP) &&
+			    IS_UP(new_active->dev)) {
+				pr_info("%s: Setting %s as active slave.\n",
+					bond->dev->name, new_active->dev->name);
+				bond_change_active_slave(bond, new_active);
+			} else {
+				pr_err("%s: Could not set %s as active slave; either %s is down or the link is down.\n",
+				       bond->dev->name, new_active->dev->name,
+				       new_active->dev->name);
+				ret = -EINVAL;
+			}
+		}
+	}
+
+	write_unlock_bh(&bond->curr_slave_lock);
+	read_unlock(&bond->lock);
+	unblock_netpoll_tx();
+	return ret;
+}

commit 72be35fee6eda2fad7122f7f0c959effa3b2b791
Author: Jiri Pirko <jiri@resnulli.us>
Date:   Fri Oct 18 17:43:34 2013 +0200

    bonding: move mode setting into separate function
    
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c
new file mode 100644
index 000000000000..294b7660b054
--- /dev/null
+++ b/drivers/net/bonding/bond_options.c
@@ -0,0 +1,55 @@
+/*
+ * drivers/net/bond/bond_options.c - bonding options
+ * Copyright (c) 2013 Jiri Pirko <jiri@resnulli.us>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/errno.h>
+#include <linux/if.h>
+#include "bonding.h"
+
+static bool bond_mode_is_valid(int mode)
+{
+	int i;
+
+	for (i = 0; bond_mode_tbl[i].modename; i++);
+
+	return mode >= 0 && mode < i;
+}
+
+int bond_option_mode_set(struct bonding *bond, int mode)
+{
+	if (!bond_mode_is_valid(mode)) {
+		pr_err("invalid mode value %d.\n", mode);
+		return -EINVAL;
+	}
+
+	if (bond->dev->flags & IFF_UP) {
+		pr_err("%s: unable to update mode because interface is up.\n",
+		       bond->dev->name);
+		return -EPERM;
+	}
+
+	if (bond_has_slaves(bond)) {
+		pr_err("%s: unable to update mode because bond has slaves.\n",
+			bond->dev->name);
+		return -EPERM;
+	}
+
+	if (BOND_MODE_IS_LB(mode) && bond->params.arp_interval) {
+		pr_err("%s: %s mode is incompatible with arp monitoring.\n",
+		       bond->dev->name, bond_mode_tbl[mode].modename);
+		return -EINVAL;
+	}
+
+	/* don't cache arp_validate between modes */
+	bond->params.arp_validate = BOND_ARP_VALIDATE_NONE;
+	bond->params.mode = mode;
+	return 0;
+}
