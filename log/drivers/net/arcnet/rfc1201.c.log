commit d58ff35122847a83ba55394e2ae3a1527b6febf5
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jun 16 14:29:23 2017 +0200

    networking: make skb_push & __skb_push return void pointers
    
    It seems like a historic accident that these return unsigned char *,
    and in many places that means casts are required, more often than not.
    
    Make these functions return void * and remove all the casts across
    the tree, adding a (u8 *) cast only where the unsigned char pointer
    was used directly, all done with the following spatch:
    
        @@
        expression SKB, LEN;
        typedef u8;
        identifier fn = { skb_push, __skb_push, skb_push_rcsum };
        @@
        - *(fn(SKB, LEN))
        + *(u8 *)fn(SKB, LEN)
    
        @@
        expression E, SKB, LEN;
        identifier fn = { skb_push, __skb_push, skb_push_rcsum };
        type T;
        @@
        - E = ((T *)(fn(SKB, LEN)))
        + E = fn(SKB, LEN)
    
        @@
        expression SKB, LEN;
        identifier fn = { skb_push, __skb_push, skb_push_rcsum };
        @@
        - fn(SKB, LEN)[0]
        + *(u8 *)fn(SKB, LEN)
    
    Note that the last part there converts from push(...)[0] to the
    more idiomatic *(u8 *)push(...).
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/arcnet/rfc1201.c b/drivers/net/arcnet/rfc1201.c
index 566da5ecdc9d..a4c856282674 100644
--- a/drivers/net/arcnet/rfc1201.c
+++ b/drivers/net/arcnet/rfc1201.c
@@ -379,7 +379,7 @@ static int build_header(struct sk_buff *skb, struct net_device *dev,
 {
 	struct arcnet_local *lp = netdev_priv(dev);
 	int hdr_size = ARC_HDR_SIZE + RFC1201_HDR_SIZE;
-	struct archdr *pkt = (struct archdr *)skb_push(skb, hdr_size);
+	struct archdr *pkt = skb_push(skb, hdr_size);
 	struct arc_rfc1201 *soft = &pkt->soft.rfc1201;
 
 	/* set the protocol ID according to RFC1201 */

commit 26c6d281688e8bb8154fa78c60e551d024f5d0b8
Author: Joe Perches <joe@perches.com>
Date:   Tue May 5 10:06:03 2015 -0700

    arcnet: Move files out of include/linux
    
    These #include files don't need to be in the include/linux directory
    as they can be local to drivers/net/arcnet/
    
    Move them and update the #include statements.
    
    Update the MAINTAINERS file pattern by deleting arcdevice from the
    NETWORKING block as arcnet is currently unmaintained.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>

diff --git a/drivers/net/arcnet/rfc1201.c b/drivers/net/arcnet/rfc1201.c
index aaa1966593aa..566da5ecdc9d 100644
--- a/drivers/net/arcnet/rfc1201.c
+++ b/drivers/net/arcnet/rfc1201.c
@@ -32,7 +32,8 @@
 #include <linux/if_arp.h>
 #include <linux/netdevice.h>
 #include <linux/skbuff.h>
-#include <linux/arcdevice.h>
+
+#include "arcdevice.h"
 
 MODULE_LICENSE("GPL");
 

commit d6d7d3ed56e3bfe7fd34108dbe23f0610e3d8621
Author: Joe Perches <joe@perches.com>
Date:   Tue May 5 10:06:02 2015 -0700

    arcnet: Wrap some long lines
    
    Just neatening.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>

diff --git a/drivers/net/arcnet/rfc1201.c b/drivers/net/arcnet/rfc1201.c
index 1d777c1e8383..aaa1966593aa 100644
--- a/drivers/net/arcnet/rfc1201.c
+++ b/drivers/net/arcnet/rfc1201.c
@@ -188,11 +188,14 @@ static void rx(struct net_device *dev, int bufnum,
 		pkt = (struct archdr *)skb->data;
 		soft = &pkt->soft.rfc1201;
 
-		/* up to sizeof(pkt->soft) has already been copied from the card */
+		/* up to sizeof(pkt->soft) has already
+		 * been copied from the card
+		 */
 		memcpy(pkt, pkthdr, sizeof(struct archdr));
 		if (length > sizeof(pkt->soft))
-			lp->hw.copy_from_card(dev, bufnum, ofs + sizeof(pkt->soft),
-				       pkt->soft.raw + sizeof(pkt->soft),
+			lp->hw.copy_from_card(dev, bufnum,
+					      ofs + sizeof(pkt->soft),
+					      pkt->soft.raw + sizeof(pkt->soft),
 					      length - sizeof(pkt->soft));
 
 		/* ARP packets have problems when sent from some DOS systems:
@@ -318,7 +321,8 @@ static void rx(struct net_device *dev, int bufnum,
 				return;
 			}
 			in->lastpacket++;
-			if (packetnum != in->lastpacket) {	/* not the right flag! */
+			/* if not the right flag */
+			if (packetnum != in->lastpacket) {
 				/* harmless duplicate? ignore. */
 				if (packetnum <= in->lastpacket - 1) {
 					arc_printk(D_EXTRA, dev, "duplicate splitpacket ignored! (splitflag=%d)\n",
@@ -477,7 +481,8 @@ static int prepare_tx(struct net_device *dev, struct archdr *pkt, int length,
 	arc_printk(D_DURING, dev, "prepare_tx: txbufs=%d/%d/%d\n",
 		   lp->next_tx, lp->cur_tx, bufnum);
 
-	length -= ARC_HDR_SIZE;	/* hard header is not included in packet length */
+	/* hard header is not included in packet length */
+	length -= ARC_HDR_SIZE;
 	pkt->soft.rfc1201.split_flag = 0;
 
 	/* need to do a split packet? */

commit d8101e7bec352b7b6a154ec2e428d01bddb7e5b4
Author: Joe Perches <joe@perches.com>
Date:   Tue May 5 10:06:00 2015 -0700

    arcnet: Remove pointer comparisons to NULL
    
    Use direct tests of pointer instead.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>

diff --git a/drivers/net/arcnet/rfc1201.c b/drivers/net/arcnet/rfc1201.c
index 9040a8be155c..1d777c1e8383 100644
--- a/drivers/net/arcnet/rfc1201.c
+++ b/drivers/net/arcnet/rfc1201.c
@@ -178,7 +178,7 @@ static void rx(struct net_device *dev, int bufnum,
 		in->sequence = soft->sequence;
 
 		skb = alloc_skb(length + ARC_HDR_SIZE, GFP_ATOMIC);
-		if (skb == NULL) {
+		if (!skb) {
 			dev->stats.rx_dropped++;
 			return;
 		}
@@ -286,7 +286,7 @@ static void rx(struct net_device *dev, int bufnum,
 			}
 			in->skb = skb = alloc_skb(508 * in->numpackets + ARC_HDR_SIZE,
 						  GFP_ATOMIC);
-			if (skb == NULL) {
+			if (!skb) {
 				arc_printk(D_NORMAL, dev, "(split) memory squeeze, dropping packet.\n");
 				lp->rfc1201.aborted_seq = soft->sequence;
 				dev->stats.rx_dropped++;

commit 5628d98fc5e99e29f2a480d4a7b1faba94a0d422
Author: Joe Perches <joe@perches.com>
Date:   Tue May 5 10:05:58 2015 -0700

    arcnet: Remove unnecessary OOM messages
    
    Alloc failures have generic stack dumps so these are redundant.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>

diff --git a/drivers/net/arcnet/rfc1201.c b/drivers/net/arcnet/rfc1201.c
index 3dae14166120..9040a8be155c 100644
--- a/drivers/net/arcnet/rfc1201.c
+++ b/drivers/net/arcnet/rfc1201.c
@@ -179,7 +179,6 @@ static void rx(struct net_device *dev, int bufnum,
 
 		skb = alloc_skb(length + ARC_HDR_SIZE, GFP_ATOMIC);
 		if (skb == NULL) {
-			arc_printk(D_NORMAL, dev, "Memory squeeze, dropping packet\n");
 			dev->stats.rx_dropped++;
 			return;
 		}

commit 05a24b234b9dda3720208b74503f2cf1d05774ee
Author: Joe Perches <joe@perches.com>
Date:   Tue May 5 10:05:56 2015 -0700

    arcnet: Convert printk to pr_<level>
    
    Use the more current logging style.
    
    Remove #define VERSION, use pr_info normally.
    Add pr_fmt with "arcnet:" prefixes and KBUILD_MODNAME.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>

diff --git a/drivers/net/arcnet/rfc1201.c b/drivers/net/arcnet/rfc1201.c
index 97af7d92c020..3dae14166120 100644
--- a/drivers/net/arcnet/rfc1201.c
+++ b/drivers/net/arcnet/rfc1201.c
@@ -23,6 +23,9 @@
  *
  * **********************
  */
+
+#define pr_fmt(fmt) "arcnet:" KBUILD_MODNAME ": " fmt
+
 #include <linux/gfp.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -32,7 +35,6 @@
 #include <linux/arcdevice.h>
 
 MODULE_LICENSE("GPL");
-#define VERSION "arcnet: RFC1201 \"standard\" (`a') encapsulation support loaded.\n"
 
 static __be16 type_trans(struct sk_buff *skb, struct net_device *dev);
 static void rx(struct net_device *dev, int bufnum,
@@ -56,7 +58,7 @@ static struct ArcProto rfc1201_proto = {
 
 static int __init arcnet_rfc1201_init(void)
 {
-	printk(VERSION);
+	pr_info("%s\n", "RFC1201 \"standard\" (`a') encapsulation support loaded");
 
 	arc_proto_map[ARC_P_IP]
 	    = arc_proto_map[ARC_P_IPV6]

commit a34c0932c3b2f28542825ffc5280d562c49ad42d
Author: Joe Perches <joe@perches.com>
Date:   Tue May 5 10:05:55 2015 -0700

    arcnet: Convert BUGMSG and BUGMSG2 to arc_prink and arc_cont
    
    These macros don't actually represent BUG uses but are more commonly
    used as logging macros, so use a more kernel style macro.
    
    Convert the BUGMSG from a netdev_ like use to actually use netdev_<level>.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>

diff --git a/drivers/net/arcnet/rfc1201.c b/drivers/net/arcnet/rfc1201.c
index d052976ebdfa..97af7d92c020 100644
--- a/drivers/net/arcnet/rfc1201.c
+++ b/drivers/net/arcnet/rfc1201.c
@@ -136,7 +136,8 @@ static void rx(struct net_device *dev, int bufnum,
 	int saddr = pkt->hard.source, ofs;
 	struct Incoming *in = &lp->rfc1201.incoming[saddr];
 
-	BUGMSG(D_DURING, "it's an RFC1201 packet (length=%d)\n", length);
+	arc_printk(D_DURING, dev, "it's an RFC1201 packet (length=%d)\n",
+		   length);
 
 	if (length >= MinTU)
 		ofs = 512 - length;
@@ -145,10 +146,10 @@ static void rx(struct net_device *dev, int bufnum,
 
 	if (soft->split_flag == 0xFF) {		/* Exception Packet */
 		if (length >= 4 + RFC1201_HDR_SIZE) {
-			BUGMSG(D_DURING, "compensating for exception packet\n");
+			arc_printk(D_DURING, dev, "compensating for exception packet\n");
 		} else {
-			BUGMSG(D_EXTRA, "short RFC1201 exception packet from %02Xh",
-			       saddr);
+			arc_printk(D_EXTRA, dev, "short RFC1201 exception packet from %02Xh",
+				   saddr);
 			return;
 		}
 
@@ -159,12 +160,13 @@ static void rx(struct net_device *dev, int bufnum,
 				      soft, sizeof(pkt->soft));
 	}
 	if (!soft->split_flag) {	/* not split */
-		BUGMSG(D_RX, "incoming is not split (splitflag=%d)\n",
-		       soft->split_flag);
+		arc_printk(D_RX, dev, "incoming is not split (splitflag=%d)\n",
+			   soft->split_flag);
 
 		if (in->skb) {	/* already assembling one! */
-			BUGMSG(D_EXTRA, "aborting assembly (seq=%d) for unsplit packet (splitflag=%d, seq=%d)\n",
-			       in->sequence, soft->split_flag, soft->sequence);
+			arc_printk(D_EXTRA, dev, "aborting assembly (seq=%d) for unsplit packet (splitflag=%d, seq=%d)\n",
+				   in->sequence, soft->split_flag,
+				   soft->sequence);
 			lp->rfc1201.aborted_seq = soft->sequence;
 			dev_kfree_skb_irq(in->skb);
 			dev->stats.rx_errors++;
@@ -175,7 +177,7 @@ static void rx(struct net_device *dev, int bufnum,
 
 		skb = alloc_skb(length + ARC_HDR_SIZE, GFP_ATOMIC);
 		if (skb == NULL) {
-			BUGMSG(D_NORMAL, "Memory squeeze, dropping packet.\n");
+			arc_printk(D_NORMAL, dev, "Memory squeeze, dropping packet\n");
 			dev->stats.rx_dropped++;
 			return;
 		}
@@ -205,18 +207,18 @@ static void rx(struct net_device *dev, int bufnum,
 				uint8_t *cptr = (uint8_t *)arp + sizeof(struct arphdr);
 
 				if (!*cptr) {	/* is saddr = 00? */
-					BUGMSG(D_EXTRA,
-					       "ARP source address was 00h, set to %02Xh.\n",
-					       saddr);
+					arc_printk(D_EXTRA, dev,
+						   "ARP source address was 00h, set to %02Xh\n",
+						   saddr);
 					dev->stats.rx_crc_errors++;
 					*cptr = saddr;
 				} else {
-					BUGMSG(D_DURING, "ARP source address (%Xh) is fine.\n",
-					       *cptr);
+					arc_printk(D_DURING, dev, "ARP source address (%Xh) is fine.\n",
+						   *cptr);
 				}
 			} else {
-				BUGMSG(D_NORMAL, "funny-shaped ARP packet. (%Xh, %Xh)\n",
-				       arp->ar_hln, arp->ar_pln);
+				arc_printk(D_NORMAL, dev, "funny-shaped ARP packet. (%Xh, %Xh)\n",
+					   arp->ar_hln, arp->ar_pln);
 				dev->stats.rx_errors++;
 				dev->stats.rx_crc_errors++;
 			}
@@ -245,13 +247,13 @@ static void rx(struct net_device *dev, int bufnum,
 		 * other way to be reliable.
 		 */
 
-		BUGMSG(D_RX, "packet is split (splitflag=%d, seq=%d)\n",
-		       soft->split_flag, in->sequence);
+		arc_printk(D_RX, dev, "packet is split (splitflag=%d, seq=%d)\n",
+			   soft->split_flag, in->sequence);
 
 		if (in->skb && in->sequence != soft->sequence) {
-			BUGMSG(D_EXTRA, "wrong seq number (saddr=%d, expected=%d, seq=%d, splitflag=%d)\n",
-			       saddr, in->sequence, soft->sequence,
-			       soft->split_flag);
+			arc_printk(D_EXTRA, dev, "wrong seq number (saddr=%d, expected=%d, seq=%d, splitflag=%d)\n",
+				   saddr, in->sequence, soft->sequence,
+				   soft->split_flag);
 			dev_kfree_skb_irq(in->skb);
 			in->skb = NULL;
 			dev->stats.rx_errors++;
@@ -259,12 +261,12 @@ static void rx(struct net_device *dev, int bufnum,
 			in->lastpacket = in->numpackets = 0;
 		}
 		if (soft->split_flag & 1) {	/* first packet in split */
-			BUGMSG(D_RX, "brand new splitpacket (splitflag=%d)\n",
-			       soft->split_flag);
+			arc_printk(D_RX, dev, "brand new splitpacket (splitflag=%d)\n",
+				   soft->split_flag);
 			if (in->skb) {	/* already assembling one! */
-				BUGMSG(D_EXTRA, "aborting previous (seq=%d) assembly (splitflag=%d, seq=%d)\n",
-				       in->sequence, soft->split_flag,
-				       soft->sequence);
+				arc_printk(D_EXTRA, dev, "aborting previous (seq=%d) assembly (splitflag=%d, seq=%d)\n",
+					   in->sequence, soft->split_flag,
+					   soft->sequence);
 				dev->stats.rx_errors++;
 				dev->stats.rx_missed_errors++;
 				dev_kfree_skb_irq(in->skb);
@@ -274,8 +276,8 @@ static void rx(struct net_device *dev, int bufnum,
 			in->lastpacket = 1;
 
 			if (in->numpackets > 16) {
-				BUGMSG(D_EXTRA, "incoming packet more than 16 segments; dropping. (splitflag=%d)\n",
-				       soft->split_flag);
+				arc_printk(D_EXTRA, dev, "incoming packet more than 16 segments; dropping. (splitflag=%d)\n",
+					   soft->split_flag);
 				lp->rfc1201.aborted_seq = soft->sequence;
 				dev->stats.rx_errors++;
 				dev->stats.rx_length_errors++;
@@ -284,7 +286,7 @@ static void rx(struct net_device *dev, int bufnum,
 			in->skb = skb = alloc_skb(508 * in->numpackets + ARC_HDR_SIZE,
 						  GFP_ATOMIC);
 			if (skb == NULL) {
-				BUGMSG(D_NORMAL, "(split) memory squeeze, dropping packet.\n");
+				arc_printk(D_NORMAL, dev, "(split) memory squeeze, dropping packet.\n");
 				lp->rfc1201.aborted_seq = soft->sequence;
 				dev->stats.rx_dropped++;
 				return;
@@ -305,9 +307,10 @@ static void rx(struct net_device *dev, int bufnum,
 			 */
 			if (!in->skb) {
 				if (lp->rfc1201.aborted_seq != soft->sequence) {
-					BUGMSG(D_EXTRA, "can't continue split without starting first! (splitflag=%d, seq=%d, aborted=%d)\n",
-					soft->split_flag, soft->sequence,
-					       lp->rfc1201.aborted_seq);
+					arc_printk(D_EXTRA, dev, "can't continue split without starting first! (splitflag=%d, seq=%d, aborted=%d)\n",
+						   soft->split_flag,
+						   soft->sequence,
+						   lp->rfc1201.aborted_seq);
 					dev->stats.rx_errors++;
 					dev->stats.rx_missed_errors++;
 				}
@@ -317,15 +320,16 @@ static void rx(struct net_device *dev, int bufnum,
 			if (packetnum != in->lastpacket) {	/* not the right flag! */
 				/* harmless duplicate? ignore. */
 				if (packetnum <= in->lastpacket - 1) {
-					BUGMSG(D_EXTRA, "duplicate splitpacket ignored! (splitflag=%d)\n",
-					       soft->split_flag);
+					arc_printk(D_EXTRA, dev, "duplicate splitpacket ignored! (splitflag=%d)\n",
+						   soft->split_flag);
 					dev->stats.rx_errors++;
 					dev->stats.rx_frame_errors++;
 					return;
 				}
 				/* "bad" duplicate, kill reassembly */
-				BUGMSG(D_EXTRA, "out-of-order splitpacket, reassembly (seq=%d) aborted (splitflag=%d, seq=%d)\n",
-				       in->sequence, soft->split_flag, soft->sequence);
+				arc_printk(D_EXTRA, dev, "out-of-order splitpacket, reassembly (seq=%d) aborted (splitflag=%d, seq=%d)\n",
+					   in->sequence, soft->split_flag,
+					   soft->sequence);
 				lp->rfc1201.aborted_seq = soft->sequence;
 				dev_kfree_skb_irq(in->skb);
 				in->skb = NULL;
@@ -350,10 +354,10 @@ static void rx(struct net_device *dev, int bufnum,
 			in->skb = NULL;
 			in->lastpacket = in->numpackets = 0;
 
-			BUGMSG(D_SKB_SIZE, "skb: received %d bytes from %02X (unsplit)\n",
-			       skb->len, pkt->hard.source);
-			BUGMSG(D_SKB_SIZE, "skb: received %d bytes from %02X (split)\n",
-			       skb->len, pkt->hard.source);
+			arc_printk(D_SKB_SIZE, dev, "skb: received %d bytes from %02X (unsplit)\n",
+				   skb->len, pkt->hard.source);
+			arc_printk(D_SKB_SIZE, dev, "skb: received %d bytes from %02X (split)\n",
+				   skb->len, pkt->hard.source);
 			if (BUGLVL(D_SKB))
 				arcnet_dump_skb(dev, skb, "rx");
 
@@ -395,8 +399,8 @@ static int build_header(struct sk_buff *skb, struct net_device *dev,
 		soft->proto = ARC_P_ATALK;
 		break;
 	default:
-		BUGMSG(D_NORMAL, "RFC1201: I don't understand protocol %d (%Xh)\n",
-		       type, type);
+		arc_printk(D_NORMAL, dev, "RFC1201: I don't understand protocol %d (%Xh)\n",
+			   type, type);
 		dev->stats.tx_errors++;
 		dev->stats.tx_aborted_errors++;
 		return 0;
@@ -469,8 +473,8 @@ static int prepare_tx(struct net_device *dev, struct archdr *pkt, int length,
 	const int maxsegsize = XMTU - RFC1201_HDR_SIZE;
 	struct Outgoing *out;
 
-	BUGMSG(D_DURING, "prepare_tx: txbufs=%d/%d/%d\n",
-	       lp->next_tx, lp->cur_tx, bufnum);
+	arc_printk(D_DURING, dev, "prepare_tx: txbufs=%d/%d/%d\n",
+		   lp->next_tx, lp->cur_tx, bufnum);
 
 	length -= ARC_HDR_SIZE;	/* hard header is not included in packet length */
 	pkt->soft.rfc1201.split_flag = 0;
@@ -484,9 +488,9 @@ static int prepare_tx(struct net_device *dev, struct archdr *pkt, int length,
 		out->numsegs = (out->dataleft + maxsegsize - 1) / maxsegsize;
 		out->segnum = 0;
 
-		BUGMSG(D_DURING, "rfc1201 prep_tx: ready for %d-segment split (%d bytes, seq=%d)\n",
-		       out->numsegs, out->length,
-		       pkt->soft.rfc1201.sequence);
+		arc_printk(D_DURING, dev, "rfc1201 prep_tx: ready for %d-segment split (%d bytes, seq=%d)\n",
+			   out->numsegs, out->length,
+			   pkt->soft.rfc1201.sequence);
 
 		return 0;	/* not done */
 	}
@@ -505,9 +509,9 @@ static int continue_tx(struct net_device *dev, int bufnum)
 	int maxsegsize = XMTU - RFC1201_HDR_SIZE;
 	int seglen;
 
-	BUGMSG(D_DURING,
-	       "rfc1201 continue_tx: loading segment %d(+1) of %d (seq=%d)\n",
-	       out->segnum, out->numsegs, soft->sequence);
+	arc_printk(D_DURING, dev,
+		   "rfc1201 continue_tx: loading segment %d(+1) of %d (seq=%d)\n",
+		   out->segnum, out->numsegs, soft->sequence);
 
 	/* the "new" soft header comes right before the data chunk */
 	newsoft = (struct arc_rfc1201 *)

commit 72aeea4841c037b9b3abf65859673cbd7b6664a9
Author: Joe Perches <joe@perches.com>
Date:   Tue May 5 10:05:54 2015 -0700

    arcnet: Expand odd BUGLVL macro with if and uses
    
    Don't hide what should be obvious.
    
    Make the macro a simple test instead of using if and test.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>

diff --git a/drivers/net/arcnet/rfc1201.c b/drivers/net/arcnet/rfc1201.c
index 4ebfbcbe5de3..d052976ebdfa 100644
--- a/drivers/net/arcnet/rfc1201.c
+++ b/drivers/net/arcnet/rfc1201.c
@@ -221,7 +221,8 @@ static void rx(struct net_device *dev, int bufnum,
 				dev->stats.rx_crc_errors++;
 			}
 		}
-		BUGLVL(D_SKB) arcnet_dump_skb(dev, skb, "rx");
+		if (BUGLVL(D_SKB))
+			arcnet_dump_skb(dev, skb, "rx");
 
 		skb->protocol = type_trans(skb, dev);
 		netif_rx(skb);
@@ -353,7 +354,8 @@ static void rx(struct net_device *dev, int bufnum,
 			       skb->len, pkt->hard.source);
 			BUGMSG(D_SKB_SIZE, "skb: received %d bytes from %02X (split)\n",
 			       skb->len, pkt->hard.source);
-			BUGLVL(D_SKB) arcnet_dump_skb(dev, skb, "rx");
+			if (BUGLVL(D_SKB))
+				arcnet_dump_skb(dev, skb, "rx");
 
 			skb->protocol = type_trans(skb, dev);
 			netif_rx(skb);

commit f2f0a16bf89a1bbf2f774e060de85ffbd8fff162
Author: Joe Perches <joe@perches.com>
Date:   Tue May 5 10:05:52 2015 -0700

    arcnet: Use network block comment style
    
    Conformity can be useful.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>

diff --git a/drivers/net/arcnet/rfc1201.c b/drivers/net/arcnet/rfc1201.c
index 47750173fd14..4ebfbcbe5de3 100644
--- a/drivers/net/arcnet/rfc1201.c
+++ b/drivers/net/arcnet/rfc1201.c
@@ -81,8 +81,7 @@ static void __exit arcnet_rfc1201_exit(void)
 module_init(arcnet_rfc1201_init);
 module_exit(arcnet_rfc1201_exit);
 
-/*
- * Determine a packet's protocol ID.
+/* Determine a packet's protocol ID.
  *
  * With ARCnet we have to convert everything to Ethernet-style stuff.
  */
@@ -193,10 +192,10 @@ static void rx(struct net_device *dev, int bufnum,
 				       pkt->soft.raw + sizeof(pkt->soft),
 					      length - sizeof(pkt->soft));
 
-		/*
-		 * ARP packets have problems when sent from some DOS systems: the
-		 * source address is always 0!  So we take the hardware source addr
-		 * (which is impossible to fumble) and insert it ourselves.
+		/* ARP packets have problems when sent from some DOS systems:
+		 * the source address is always 0!
+		 * So we take the hardware source addr (which is impossible
+		 * to fumble) and insert it ourselves.
 		 */
 		if (soft->proto == ARC_P_ARP) {
 			struct arphdr *arp = (struct arphdr *)soft->payload;
@@ -227,21 +226,22 @@ static void rx(struct net_device *dev, int bufnum,
 		skb->protocol = type_trans(skb, dev);
 		netif_rx(skb);
 	} else {		/* split packet */
-		/*
-		 * NOTE: MSDOS ARP packet correction should only need to apply to
-		 * unsplit packets, since ARP packets are so short.
+		/* NOTE: MSDOS ARP packet correction should only need to
+		 * apply to unsplit packets, since ARP packets are so short.
 		 *
-		 * My interpretation of the RFC1201 document is that if a packet is
-		 * received out of order, the entire assembly process should be
-		 * aborted.
+		 * My interpretation of the RFC1201 document is that if a
+		 * packet is received out of order, the entire assembly
+		 * process should be aborted.
 		 *
-		 * The RFC also mentions "it is possible for successfully received
-		 * packets to be retransmitted." As of 0.40 all previously received
-		 * packets are allowed, not just the most recent one.
+		 * The RFC also mentions "it is possible for successfully
+		 * received packets to be retransmitted." As of 0.40 all
+		 * previously received packets are allowed, not just the
+		 * most recent one.
 		 *
-		 * We allow multiple assembly processes, one for each ARCnet card
-		 * possible on the network.  Seems rather like a waste of memory,
-		 * but there's no other way to be reliable.
+		 * We allow multiple assembly processes, one for each
+		 * ARCnet card possible on the network.
+		 * Seems rather like a waste of memory, but there's no
+		 * other way to be reliable.
 		 */
 
 		BUGMSG(D_RX, "packet is split (splitflag=%d, seq=%d)\n",
@@ -299,8 +299,7 @@ static void rx(struct net_device *dev, int bufnum,
 		} else {	/* not first packet */
 			int packetnum = ((unsigned)soft->split_flag >> 1) + 1;
 
-			/*
-			 * if we're not assembling, there's no point trying to
+			/* if we're not assembling, there's no point trying to
 			 * continue.
 			 */
 			if (!in->skb) {
@@ -401,12 +400,11 @@ static int build_header(struct sk_buff *skb, struct net_device *dev,
 		return 0;
 	}
 
-	/*
-	 * Set the source hardware address.
+	/* Set the source hardware address.
 	 *
 	 * This is pretty pointless for most purposes, but it can help in
-	 * debugging.  ARCnet does not allow us to change the source address in
-	 * the actual packet sent)
+	 * debugging.  ARCnet does not allow us to change the source address
+	 * in the actual packet sent.
 	 */
 	pkt->hard.source = *dev->dev_addr;
 
@@ -416,10 +414,10 @@ static int build_header(struct sk_buff *skb, struct net_device *dev,
 	/* see linux/net/ethernet/eth.c to see where I got the following */
 
 	if (dev->flags & (IFF_LOOPBACK | IFF_NOARP)) {
-		/*
-		 * FIXME: fill in the last byte of the dest ipaddr here to better
-		 * comply with RFC1051 in "noarp" mode.  For now, always broadcasting
-		 * will probably at least get packets sent out :)
+		/* FIXME: fill in the last byte of the dest ipaddr here
+		 * to better comply with RFC1051 in "noarp" mode.
+		 * For now, always broadcasting will probably at least get
+		 * packets sent out :)
 		 */
 		pkt->hard.dest = 0;
 		return hdr_size;

commit 3b4e55510f3151cd906cd221f6fba5cb56b8cfed
Author: Joe Perches <joe@perches.com>
Date:   Tue May 5 10:05:50 2015 -0700

    arcnet: Coalesce string fragments
    
    Using coalesced strings helps grep for specific messages.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>

diff --git a/drivers/net/arcnet/rfc1201.c b/drivers/net/arcnet/rfc1201.c
index 4abb20e26ead..47750173fd14 100644
--- a/drivers/net/arcnet/rfc1201.c
+++ b/drivers/net/arcnet/rfc1201.c
@@ -261,8 +261,7 @@ static void rx(struct net_device *dev, int bufnum,
 			BUGMSG(D_RX, "brand new splitpacket (splitflag=%d)\n",
 			       soft->split_flag);
 			if (in->skb) {	/* already assembling one! */
-				BUGMSG(D_EXTRA, "aborting previous (seq=%d) assembly "
-				       "(splitflag=%d, seq=%d)\n",
+				BUGMSG(D_EXTRA, "aborting previous (seq=%d) assembly (splitflag=%d, seq=%d)\n",
 				       in->sequence, soft->split_flag,
 				       soft->sequence);
 				dev->stats.rx_errors++;
@@ -306,8 +305,7 @@ static void rx(struct net_device *dev, int bufnum,
 			 */
 			if (!in->skb) {
 				if (lp->rfc1201.aborted_seq != soft->sequence) {
-					BUGMSG(D_EXTRA, "can't continue split without starting "
-					       "first! (splitflag=%d, seq=%d, aborted=%d)\n",
+					BUGMSG(D_EXTRA, "can't continue split without starting first! (splitflag=%d, seq=%d, aborted=%d)\n",
 					soft->split_flag, soft->sequence,
 					       lp->rfc1201.aborted_seq);
 					dev->stats.rx_errors++;
@@ -326,8 +324,7 @@ static void rx(struct net_device *dev, int bufnum,
 					return;
 				}
 				/* "bad" duplicate, kill reassembly */
-				BUGMSG(D_EXTRA, "out-of-order splitpacket, reassembly "
-				       "(seq=%d) aborted (splitflag=%d, seq=%d)\n",
+				BUGMSG(D_EXTRA, "out-of-order splitpacket, reassembly (seq=%d) aborted (splitflag=%d, seq=%d)\n",
 				       in->sequence, soft->split_flag, soft->sequence);
 				lp->rfc1201.aborted_seq = soft->sequence;
 				dev_kfree_skb_irq(in->skb);
@@ -487,8 +484,8 @@ static int prepare_tx(struct net_device *dev, struct archdr *pkt, int length,
 		out->numsegs = (out->dataleft + maxsegsize - 1) / maxsegsize;
 		out->segnum = 0;
 
-		BUGMSG(D_DURING, "rfc1201 prep_tx: ready for %d-segment split "
-		       "(%d bytes, seq=%d)\n", out->numsegs, out->length,
+		BUGMSG(D_DURING, "rfc1201 prep_tx: ready for %d-segment split (%d bytes, seq=%d)\n",
+		       out->numsegs, out->length,
 		       pkt->soft.rfc1201.sequence);
 
 		return 0;	/* not done */

commit 7f5e760c1b269044a4ba1b269263beca80ae2741
Author: Joe Perches <joe@perches.com>
Date:   Tue May 5 10:05:49 2015 -0700

    arcnet: Use normal kernel brace style
    
    Move braces normal kernel locations.
    Add missing braces.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>

diff --git a/drivers/net/arcnet/rfc1201.c b/drivers/net/arcnet/rfc1201.c
index 15f103a8a9db..4abb20e26ead 100644
--- a/drivers/net/arcnet/rfc1201.c
+++ b/drivers/net/arcnet/rfc1201.c
@@ -43,8 +43,7 @@ static int prepare_tx(struct net_device *dev, struct archdr *pkt, int length,
 		      int bufnum);
 static int continue_tx(struct net_device *dev, int bufnum);
 
-static struct ArcProto rfc1201_proto =
-{
+static struct ArcProto rfc1201_proto = {
 	.suffix		= 'a',
 	.mtu		= 1500,	/* could be more, but some receivers can't handle it... */
 	.is_ip          = 1,    /* This is for sending IP and ARP packages */
@@ -97,9 +96,9 @@ static __be16 type_trans(struct sk_buff *skb, struct net_device *dev)
 	skb_reset_mac_header(skb);
 	skb_pull(skb, hdr_size);
 
-	if (pkt->hard.dest == 0)
+	if (pkt->hard.dest == 0) {
 		skb->pkt_type = PACKET_BROADCAST;
-	else if (dev->flags & IFF_PROMISC) {
+	} else if (dev->flags & IFF_PROMISC) {
 		/* if we're not sending to ourselves :) */
 		if (pkt->hard.dest != dev->dev_addr[0])
 			skb->pkt_type = PACKET_OTHERHOST;
@@ -146,9 +145,9 @@ static void rx(struct net_device *dev, int bufnum,
 		ofs = 256 - length;
 
 	if (soft->split_flag == 0xFF) {		/* Exception Packet */
-		if (length >= 4 + RFC1201_HDR_SIZE)
+		if (length >= 4 + RFC1201_HDR_SIZE) {
 			BUGMSG(D_DURING, "compensating for exception packet\n");
-		else {
+		} else {
 			BUGMSG(D_EXTRA, "short RFC1201 exception packet from %02Xh",
 			       saddr);
 			return;
@@ -456,8 +455,9 @@ static void load_pkt(struct net_device *dev, struct arc_hardware *hard,
 		hard->offset[1] = ofs - RFC1201_HDR_SIZE;
 		lp->hw.copy_to_card(dev, bufnum, ofs - RFC1201_HDR_SIZE,
 				    &excsoft, RFC1201_HDR_SIZE);
-	} else
+	} else {
 		hard->offset[0] = ofs = 256 - softlen;
+	}
 
 	lp->hw.copy_to_card(dev, bufnum, 0, hard, ARC_HDR_SIZE);
 	lp->hw.copy_to_card(dev, bufnum, ofs, soft, softlen);

commit 01a1d5ac4e1a5890fd6c0d0ae900e1b6e4f851d6
Author: Joe Perches <joe@perches.com>
Date:   Tue May 5 10:05:48 2015 -0700

    arcnet: Add and remove blank lines
    
    Use a more current kernel line style.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>

diff --git a/drivers/net/arcnet/rfc1201.c b/drivers/net/arcnet/rfc1201.c
index bf2a8cb3f0e2..15f103a8a9db 100644
--- a/drivers/net/arcnet/rfc1201.c
+++ b/drivers/net/arcnet/rfc1201.c
@@ -34,7 +34,6 @@
 MODULE_LICENSE("GPL");
 #define VERSION "arcnet: RFC1201 \"standard\" (`a') encapsulation support loaded.\n"
 
-
 static __be16 type_trans(struct sk_buff *skb, struct net_device *dev);
 static void rx(struct net_device *dev, int bufnum,
 	       struct archdr *pkthdr, int length);
@@ -56,7 +55,6 @@ static struct ArcProto rfc1201_proto =
 	.ack_tx         = NULL
 };
 
-
 static int __init arcnet_rfc1201_init(void)
 {
 	printk(VERSION);
@@ -129,7 +127,6 @@ static __be16 type_trans(struct sk_buff *skb, struct net_device *dev)
 	return htons(ETH_P_IP);
 }
 
-
 /* packet receiver */
 static void rx(struct net_device *dev, int bufnum,
 	       struct archdr *pkthdr, int length)
@@ -369,7 +366,6 @@ static void rx(struct net_device *dev, int bufnum,
 	}
 }
 
-
 /* Create the ARCnet hard/soft headers for RFC1201. */
 static int build_header(struct sk_buff *skb, struct net_device *dev,
 			unsigned short type, uint8_t daddr)
@@ -437,7 +433,6 @@ static int build_header(struct sk_buff *skb, struct net_device *dev,
 	return hdr_size;
 }
 
-
 static void load_pkt(struct net_device *dev, struct arc_hardware *hard,
 		     struct arc_rfc1201 *soft, int softlen, int bufnum)
 {
@@ -470,7 +465,6 @@ static void load_pkt(struct net_device *dev, struct arc_hardware *hard,
 	lp->lastload_dest = hard->dest;
 }
 
-
 static int prepare_tx(struct net_device *dev, struct archdr *pkt, int length,
 		      int bufnum)
 {
@@ -478,7 +472,6 @@ static int prepare_tx(struct net_device *dev, struct archdr *pkt, int length,
 	const int maxsegsize = XMTU - RFC1201_HDR_SIZE;
 	struct Outgoing *out;
 
-
 	BUGMSG(D_DURING, "prepare_tx: txbufs=%d/%d/%d\n",
 	       lp->next_tx, lp->cur_tx, bufnum);
 
@@ -506,7 +499,6 @@ static int prepare_tx(struct net_device *dev, struct archdr *pkt, int length,
 	return 1;		/* done */
 }
 
-
 static int continue_tx(struct net_device *dev, int bufnum)
 {
 	struct arcnet_local *lp = netdev_priv(dev);

commit cb334648a10c7fa6f0f163c22602f4dc1c6d56b4
Author: Joe Perches <joe@perches.com>
Date:   Tue May 5 10:05:47 2015 -0700

    arcnet: Use normal kernel spacing style
    
    Standardized spacing is easier to read.
    
    git diff -w shows no differences.
    objdiff shows no differences.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>

diff --git a/drivers/net/arcnet/rfc1201.c b/drivers/net/arcnet/rfc1201.c
index b71431aae084..bf2a8cb3f0e2 100644
--- a/drivers/net/arcnet/rfc1201.c
+++ b/drivers/net/arcnet/rfc1201.c
@@ -1,6 +1,6 @@
 /*
  * Linux ARCnet driver - RFC1201 (standard) packet encapsulation
- * 
+ *
  * Written 1994-1999 by Avery Pennarun.
  * Derived from skeleton.c by Donald Becker.
  *
@@ -86,12 +86,12 @@ module_exit(arcnet_rfc1201_exit);
 
 /*
  * Determine a packet's protocol ID.
- * 
+ *
  * With ARCnet we have to convert everything to Ethernet-style stuff.
  */
 static __be16 type_trans(struct sk_buff *skb, struct net_device *dev)
 {
-	struct archdr *pkt = (struct archdr *) skb->data;
+	struct archdr *pkt = (struct archdr *)skb->data;
 	struct arc_rfc1201 *soft = &pkt->soft.rfc1201;
 	int hdr_size = ARC_HDR_SIZE + RFC1201_HDR_SIZE;
 
@@ -169,7 +169,7 @@ static void rx(struct net_device *dev, int bufnum,
 
 		if (in->skb) {	/* already assembling one! */
 			BUGMSG(D_EXTRA, "aborting assembly (seq=%d) for unsplit packet (splitflag=%d, seq=%d)\n",
-			 in->sequence, soft->split_flag, soft->sequence);
+			       in->sequence, soft->split_flag, soft->sequence);
 			lp->rfc1201.aborted_seq = soft->sequence;
 			dev_kfree_skb_irq(in->skb);
 			dev->stats.rx_errors++;
@@ -187,7 +187,7 @@ static void rx(struct net_device *dev, int bufnum,
 		skb_put(skb, length + ARC_HDR_SIZE);
 		skb->dev = dev;
 
-		pkt = (struct archdr *) skb->data;
+		pkt = (struct archdr *)skb->data;
 		soft = &pkt->soft.rfc1201;
 
 		/* up to sizeof(pkt->soft) has already been copied from the card */
@@ -203,11 +203,11 @@ static void rx(struct net_device *dev, int bufnum,
 		 * (which is impossible to fumble) and insert it ourselves.
 		 */
 		if (soft->proto == ARC_P_ARP) {
-			struct arphdr *arp = (struct arphdr *) soft->payload;
+			struct arphdr *arp = (struct arphdr *)soft->payload;
 
 			/* make sure addresses are the right length */
 			if (arp->ar_hln == 1 && arp->ar_pln == 4) {
-				uint8_t *cptr = (uint8_t *) arp + sizeof(struct arphdr);
+				uint8_t *cptr = (uint8_t *)arp + sizeof(struct arphdr);
 
 				if (!*cptr) {	/* is saddr = 00? */
 					BUGMSG(D_EXTRA,
@@ -274,7 +274,7 @@ static void rx(struct net_device *dev, int bufnum,
 				dev_kfree_skb_irq(in->skb);
 			}
 			in->sequence = soft->sequence;
-			in->numpackets = ((unsigned) soft->split_flag >> 1) + 2;
+			in->numpackets = ((unsigned)soft->split_flag >> 1) + 2;
 			in->lastpacket = 1;
 
 			if (in->numpackets > 16) {
@@ -294,7 +294,7 @@ static void rx(struct net_device *dev, int bufnum,
 				return;
 			}
 			skb->dev = dev;
-			pkt = (struct archdr *) skb->data;
+			pkt = (struct archdr *)skb->data;
 			soft = &pkt->soft.rfc1201;
 
 			memcpy(pkt, pkthdr, ARC_HDR_SIZE + RFC1201_HDR_SIZE);
@@ -302,7 +302,7 @@ static void rx(struct net_device *dev, int bufnum,
 
 			soft->split_flag = 0;	/* end result won't be split */
 		} else {	/* not first packet */
-			int packetnum = ((unsigned) soft->split_flag >> 1) + 1;
+			int packetnum = ((unsigned)soft->split_flag >> 1) + 1;
 
 			/*
 			 * if we're not assembling, there's no point trying to
@@ -341,7 +341,7 @@ static void rx(struct net_device *dev, int bufnum,
 				in->lastpacket = in->numpackets = 0;
 				return;
 			}
-			pkt = (struct archdr *) in->skb->data;
+			pkt = (struct archdr *)in->skb->data;
 			soft = &pkt->soft.rfc1201;
 		}
 
@@ -357,10 +357,10 @@ static void rx(struct net_device *dev, int bufnum,
 			in->skb = NULL;
 			in->lastpacket = in->numpackets = 0;
 
-	    BUGMSG(D_SKB_SIZE, "skb: received %d bytes from %02X (unsplit)\n",
-    		skb->len, pkt->hard.source);
-	    BUGMSG(D_SKB_SIZE, "skb: received %d bytes from %02X (split)\n",
-    		skb->len, pkt->hard.source);
+			BUGMSG(D_SKB_SIZE, "skb: received %d bytes from %02X (unsplit)\n",
+			       skb->len, pkt->hard.source);
+			BUGMSG(D_SKB_SIZE, "skb: received %d bytes from %02X (split)\n",
+			       skb->len, pkt->hard.source);
 			BUGLVL(D_SKB) arcnet_dump_skb(dev, skb, "rx");
 
 			skb->protocol = type_trans(skb, dev);
@@ -376,7 +376,7 @@ static int build_header(struct sk_buff *skb, struct net_device *dev,
 {
 	struct arcnet_local *lp = netdev_priv(dev);
 	int hdr_size = ARC_HDR_SIZE + RFC1201_HDR_SIZE;
-	struct archdr *pkt = (struct archdr *) skb_push(skb, hdr_size);
+	struct archdr *pkt = (struct archdr *)skb_push(skb, hdr_size);
 	struct arc_rfc1201 *soft = &pkt->soft.rfc1201;
 
 	/* set the protocol ID according to RFC1201 */
@@ -424,7 +424,7 @@ static int build_header(struct sk_buff *skb, struct net_device *dev,
 	/* see linux/net/ethernet/eth.c to see where I got the following */
 
 	if (dev->flags & (IFF_LOOPBACK | IFF_NOARP)) {
-		/* 
+		/*
 		 * FIXME: fill in the last byte of the dest ipaddr here to better
 		 * comply with RFC1051 in "noarp" mode.  For now, always broadcasting
 		 * will probably at least get packets sent out :)
@@ -517,7 +517,7 @@ static int continue_tx(struct net_device *dev, int bufnum)
 	int seglen;
 
 	BUGMSG(D_DURING,
-	  "rfc1201 continue_tx: loading segment %d(+1) of %d (seq=%d)\n",
+	       "rfc1201 continue_tx: loading segment %d(+1) of %d (seq=%d)\n",
 	       out->segnum, out->numsegs, soft->sequence);
 
 	/* the "new" soft header comes right before the data chunk */

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/net/arcnet/rfc1201.c b/drivers/net/arcnet/rfc1201.c
index 745530651c45..b71431aae084 100644
--- a/drivers/net/arcnet/rfc1201.c
+++ b/drivers/net/arcnet/rfc1201.c
@@ -23,6 +23,7 @@
  *
  * **********************
  */
+#include <linux/gfp.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/if_arp.h>

commit 5803c5122acb31ebf5f76b1a9925e2c72c4436e1
Author: Stephen Hemminger <shemminger@linux-foundation.org>
Date:   Fri Jan 9 13:01:08 2009 +0000

    arcnet: convert to internal stats
    
    Use pre-existing network_device_stats inside network_device rather than own
    private structure.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/arcnet/rfc1201.c b/drivers/net/arcnet/rfc1201.c
index 2303d3a1f4b6..745530651c45 100644
--- a/drivers/net/arcnet/rfc1201.c
+++ b/drivers/net/arcnet/rfc1201.c
@@ -92,7 +92,6 @@ static __be16 type_trans(struct sk_buff *skb, struct net_device *dev)
 {
 	struct archdr *pkt = (struct archdr *) skb->data;
 	struct arc_rfc1201 *soft = &pkt->soft.rfc1201;
-	struct arcnet_local *lp = netdev_priv(dev);
 	int hdr_size = ARC_HDR_SIZE + RFC1201_HDR_SIZE;
 
 	/* Pull off the arcnet header. */
@@ -121,8 +120,8 @@ static __be16 type_trans(struct sk_buff *skb, struct net_device *dev)
 	case ARC_P_NOVELL_EC:
 		return htons(ETH_P_802_3);
 	default:
-		lp->stats.rx_errors++;
-		lp->stats.rx_crc_errors++;
+		dev->stats.rx_errors++;
+		dev->stats.rx_crc_errors++;
 		return 0;
 	}
 
@@ -172,8 +171,8 @@ static void rx(struct net_device *dev, int bufnum,
 			 in->sequence, soft->split_flag, soft->sequence);
 			lp->rfc1201.aborted_seq = soft->sequence;
 			dev_kfree_skb_irq(in->skb);
-			lp->stats.rx_errors++;
-			lp->stats.rx_missed_errors++;
+			dev->stats.rx_errors++;
+			dev->stats.rx_missed_errors++;
 			in->skb = NULL;
 		}
 		in->sequence = soft->sequence;
@@ -181,7 +180,7 @@ static void rx(struct net_device *dev, int bufnum,
 		skb = alloc_skb(length + ARC_HDR_SIZE, GFP_ATOMIC);
 		if (skb == NULL) {
 			BUGMSG(D_NORMAL, "Memory squeeze, dropping packet.\n");
-			lp->stats.rx_dropped++;
+			dev->stats.rx_dropped++;
 			return;
 		}
 		skb_put(skb, length + ARC_HDR_SIZE);
@@ -213,7 +212,7 @@ static void rx(struct net_device *dev, int bufnum,
 					BUGMSG(D_EXTRA,
 					       "ARP source address was 00h, set to %02Xh.\n",
 					       saddr);
-					lp->stats.rx_crc_errors++;
+					dev->stats.rx_crc_errors++;
 					*cptr = saddr;
 				} else {
 					BUGMSG(D_DURING, "ARP source address (%Xh) is fine.\n",
@@ -222,8 +221,8 @@ static void rx(struct net_device *dev, int bufnum,
 			} else {
 				BUGMSG(D_NORMAL, "funny-shaped ARP packet. (%Xh, %Xh)\n",
 				       arp->ar_hln, arp->ar_pln);
-				lp->stats.rx_errors++;
-				lp->stats.rx_crc_errors++;
+				dev->stats.rx_errors++;
+				dev->stats.rx_crc_errors++;
 			}
 		}
 		BUGLVL(D_SKB) arcnet_dump_skb(dev, skb, "rx");
@@ -257,8 +256,8 @@ static void rx(struct net_device *dev, int bufnum,
 			       soft->split_flag);
 			dev_kfree_skb_irq(in->skb);
 			in->skb = NULL;
-			lp->stats.rx_errors++;
-			lp->stats.rx_missed_errors++;
+			dev->stats.rx_errors++;
+			dev->stats.rx_missed_errors++;
 			in->lastpacket = in->numpackets = 0;
 		}
 		if (soft->split_flag & 1) {	/* first packet in split */
@@ -269,8 +268,8 @@ static void rx(struct net_device *dev, int bufnum,
 				       "(splitflag=%d, seq=%d)\n",
 				       in->sequence, soft->split_flag,
 				       soft->sequence);
-				lp->stats.rx_errors++;
-				lp->stats.rx_missed_errors++;
+				dev->stats.rx_errors++;
+				dev->stats.rx_missed_errors++;
 				dev_kfree_skb_irq(in->skb);
 			}
 			in->sequence = soft->sequence;
@@ -281,8 +280,8 @@ static void rx(struct net_device *dev, int bufnum,
 				BUGMSG(D_EXTRA, "incoming packet more than 16 segments; dropping. (splitflag=%d)\n",
 				       soft->split_flag);
 				lp->rfc1201.aborted_seq = soft->sequence;
-				lp->stats.rx_errors++;
-				lp->stats.rx_length_errors++;
+				dev->stats.rx_errors++;
+				dev->stats.rx_length_errors++;
 				return;
 			}
 			in->skb = skb = alloc_skb(508 * in->numpackets + ARC_HDR_SIZE,
@@ -290,7 +289,7 @@ static void rx(struct net_device *dev, int bufnum,
 			if (skb == NULL) {
 				BUGMSG(D_NORMAL, "(split) memory squeeze, dropping packet.\n");
 				lp->rfc1201.aborted_seq = soft->sequence;
-				lp->stats.rx_dropped++;
+				dev->stats.rx_dropped++;
 				return;
 			}
 			skb->dev = dev;
@@ -314,8 +313,8 @@ static void rx(struct net_device *dev, int bufnum,
 					       "first! (splitflag=%d, seq=%d, aborted=%d)\n",
 					soft->split_flag, soft->sequence,
 					       lp->rfc1201.aborted_seq);
-					lp->stats.rx_errors++;
-					lp->stats.rx_missed_errors++;
+					dev->stats.rx_errors++;
+					dev->stats.rx_missed_errors++;
 				}
 				return;
 			}
@@ -325,8 +324,8 @@ static void rx(struct net_device *dev, int bufnum,
 				if (packetnum <= in->lastpacket - 1) {
 					BUGMSG(D_EXTRA, "duplicate splitpacket ignored! (splitflag=%d)\n",
 					       soft->split_flag);
-					lp->stats.rx_errors++;
-					lp->stats.rx_frame_errors++;
+					dev->stats.rx_errors++;
+					dev->stats.rx_frame_errors++;
 					return;
 				}
 				/* "bad" duplicate, kill reassembly */
@@ -336,8 +335,8 @@ static void rx(struct net_device *dev, int bufnum,
 				lp->rfc1201.aborted_seq = soft->sequence;
 				dev_kfree_skb_irq(in->skb);
 				in->skb = NULL;
-				lp->stats.rx_errors++;
-				lp->stats.rx_missed_errors++;
+				dev->stats.rx_errors++;
+				dev->stats.rx_missed_errors++;
 				in->lastpacket = in->numpackets = 0;
 				return;
 			}
@@ -404,8 +403,8 @@ static int build_header(struct sk_buff *skb, struct net_device *dev,
 	default:
 		BUGMSG(D_NORMAL, "RFC1201: I don't understand protocol %d (%Xh)\n",
 		       type, type);
-		lp->stats.tx_errors++;
-		lp->stats.tx_aborted_errors++;
+		dev->stats.tx_errors++;
+		dev->stats.tx_aborted_errors++;
 		return 0;
 	}
 

commit 454d7c9b14e20fd1949e2686e9de4a2926e01476
Author: Wang Chen <wangchen@cn.fujitsu.com>
Date:   Wed Nov 12 23:37:49 2008 -0800

    netdevice: safe convert to netdev_priv() #part-1
    
    We have some reasons to kill netdev->priv:
    1. netdev->priv is equal to netdev_priv().
    2. netdev_priv() wraps the calculation of netdev->priv's offset, obviously
       netdev_priv() is more flexible than netdev->priv.
    But we cann't kill netdev->priv, because so many drivers reference to it
    directly.
    
    This patch is a safe convert for netdev->priv to netdev_priv(netdev).
    Since all of the netdev->priv is only for read.
    But it is too big to be sent in one mail.
    I split it to 4 parts and make every part smaller than 100,000 bytes,
    which is max size allowed by vger.
    
    Signed-off-by: Wang Chen <wangchen@cn.fujitsu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/arcnet/rfc1201.c b/drivers/net/arcnet/rfc1201.c
index 962641e96450..2303d3a1f4b6 100644
--- a/drivers/net/arcnet/rfc1201.c
+++ b/drivers/net/arcnet/rfc1201.c
@@ -92,7 +92,7 @@ static __be16 type_trans(struct sk_buff *skb, struct net_device *dev)
 {
 	struct archdr *pkt = (struct archdr *) skb->data;
 	struct arc_rfc1201 *soft = &pkt->soft.rfc1201;
-	struct arcnet_local *lp = dev->priv;
+	struct arcnet_local *lp = netdev_priv(dev);
 	int hdr_size = ARC_HDR_SIZE + RFC1201_HDR_SIZE;
 
 	/* Pull off the arcnet header. */
@@ -134,7 +134,7 @@ static __be16 type_trans(struct sk_buff *skb, struct net_device *dev)
 static void rx(struct net_device *dev, int bufnum,
 	       struct archdr *pkthdr, int length)
 {
-	struct arcnet_local *lp = dev->priv;
+	struct arcnet_local *lp = netdev_priv(dev);
 	struct sk_buff *skb;
 	struct archdr *pkt = pkthdr;
 	struct arc_rfc1201 *soft = &pkthdr->soft.rfc1201;
@@ -374,7 +374,7 @@ static void rx(struct net_device *dev, int bufnum,
 static int build_header(struct sk_buff *skb, struct net_device *dev,
 			unsigned short type, uint8_t daddr)
 {
-	struct arcnet_local *lp = dev->priv;
+	struct arcnet_local *lp = netdev_priv(dev);
 	int hdr_size = ARC_HDR_SIZE + RFC1201_HDR_SIZE;
 	struct archdr *pkt = (struct archdr *) skb_push(skb, hdr_size);
 	struct arc_rfc1201 *soft = &pkt->soft.rfc1201;
@@ -441,7 +441,7 @@ static int build_header(struct sk_buff *skb, struct net_device *dev,
 static void load_pkt(struct net_device *dev, struct arc_hardware *hard,
 		     struct arc_rfc1201 *soft, int softlen, int bufnum)
 {
-	struct arcnet_local *lp = dev->priv;
+	struct arcnet_local *lp = netdev_priv(dev);
 	int ofs;
 
 	/* assume length <= XMTU: someone should have handled that by now. */
@@ -474,7 +474,7 @@ static void load_pkt(struct net_device *dev, struct arc_hardware *hard,
 static int prepare_tx(struct net_device *dev, struct archdr *pkt, int length,
 		      int bufnum)
 {
-	struct arcnet_local *lp = dev->priv;
+	struct arcnet_local *lp = netdev_priv(dev);
 	const int maxsegsize = XMTU - RFC1201_HDR_SIZE;
 	struct Outgoing *out;
 
@@ -509,7 +509,7 @@ static int prepare_tx(struct net_device *dev, struct archdr *pkt, int length,
 
 static int continue_tx(struct net_device *dev, int bufnum)
 {
-	struct arcnet_local *lp = dev->priv;
+	struct arcnet_local *lp = netdev_priv(dev);
 	struct Outgoing *out = &lp->outgoing;
 	struct arc_hardware *hard = &out->pkt->hard;
 	struct arc_rfc1201 *soft = &out->pkt->soft.rfc1201, *newsoft;

commit babcda74e9d96bb58fd9c6c5112dbdbff169e695
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Nov 3 21:11:17 2008 -0800

    drivers/net: Kill now superfluous ->last_rx stores.
    
    The generic packet receive code takes care of setting
    netdev->last_rx when necessary, for the sake of the
    bonding ARP monitor.
    
    Drivers need not do it any more.
    
    Some cases had to be skipped over because the drivers
    were making use of the ->last_rx value themselves.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/arcnet/rfc1201.c b/drivers/net/arcnet/rfc1201.c
index 6d6d95cc4404..962641e96450 100644
--- a/drivers/net/arcnet/rfc1201.c
+++ b/drivers/net/arcnet/rfc1201.c
@@ -230,7 +230,6 @@ static void rx(struct net_device *dev, int bufnum,
 
 		skb->protocol = type_trans(skb, dev);
 		netif_rx(skb);
-		dev->last_rx = jiffies;
 	} else {		/* split packet */
 		/*
 		 * NOTE: MSDOS ARP packet correction should only need to apply to
@@ -366,7 +365,6 @@ static void rx(struct net_device *dev, int bufnum,
 
 			skb->protocol = type_trans(skb, dev);
 			netif_rx(skb);
-			dev->last_rx = jiffies;
 		}
 	}
 }

commit 701181ac1d9ac465a3614061cb60ded4033c4d07
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Aug 22 22:59:11 2007 -0400

    arcnet endianness annotations
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/net/arcnet/rfc1201.c b/drivers/net/arcnet/rfc1201.c
index 460a095000c2..6d6d95cc4404 100644
--- a/drivers/net/arcnet/rfc1201.c
+++ b/drivers/net/arcnet/rfc1201.c
@@ -34,7 +34,7 @@ MODULE_LICENSE("GPL");
 #define VERSION "arcnet: RFC1201 \"standard\" (`a') encapsulation support loaded.\n"
 
 
-static unsigned short type_trans(struct sk_buff *skb, struct net_device *dev);
+static __be16 type_trans(struct sk_buff *skb, struct net_device *dev);
 static void rx(struct net_device *dev, int bufnum,
 	       struct archdr *pkthdr, int length);
 static int build_header(struct sk_buff *skb, struct net_device *dev,
@@ -88,7 +88,7 @@ module_exit(arcnet_rfc1201_exit);
  * 
  * With ARCnet we have to convert everything to Ethernet-style stuff.
  */
-static unsigned short type_trans(struct sk_buff *skb, struct net_device *dev)
+static __be16 type_trans(struct sk_buff *skb, struct net_device *dev)
 {
 	struct archdr *pkt = (struct archdr *) skb->data;
 	struct arc_rfc1201 *soft = &pkt->soft.rfc1201;
@@ -456,7 +456,7 @@ static void load_pkt(struct net_device *dev, struct arc_hardware *hard,
 
 		excsoft.proto = soft->proto;
 		excsoft.split_flag = 0xff;
-		excsoft.sequence = 0xffff;
+		excsoft.sequence = htons(0xffff);
 
 		hard->offset[0] = 0;
 		ofs = 512 - softlen;

commit 459a98ed881802dee55897441bc7f77af614368e
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 19 15:30:44 2007 -0700

    [SK_BUFF]: Introduce skb_reset_mac_header(skb)
    
    For the common, open coded 'skb->mac.raw = skb->data' operation, so that we can
    later turn skb->mac.raw into a offset, reducing the size of struct sk_buff in
    64bit land while possibly keeping it as a pointer on 32bit.
    
    This one touches just the most simple case, next will handle the slightly more
    "complex" cases.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/arcnet/rfc1201.c b/drivers/net/arcnet/rfc1201.c
index bee34226abfa..460a095000c2 100644
--- a/drivers/net/arcnet/rfc1201.c
+++ b/drivers/net/arcnet/rfc1201.c
@@ -96,7 +96,7 @@ static unsigned short type_trans(struct sk_buff *skb, struct net_device *dev)
 	int hdr_size = ARC_HDR_SIZE + RFC1201_HDR_SIZE;
 
 	/* Pull off the arcnet header. */
-	skb->mac.raw = skb->data;
+	skb_reset_mac_header(skb);
 	skb_pull(skb, hdr_size);
 
 	if (pkt->hard.dest == 0)

commit f03aa2d89ad600a1ed21a223f196776f217cfe00
Author: Adrian Bunk <bunk@stusta.de>
Date:   Sat Jan 14 03:10:22 2006 +0100

    [PATCH] drivers/net/arcnet/: possible cleanups
    
    This patch contains the following possible cleanups:
    - make needlessly global code static
    - arcnet.c: remove the unneeded EXPORT_SYMBOL(arc_proto_null)
    - arcnet.c: remove the unneeded EXPORT_SYMBOL(arcnet_dump_packet)
    
    To make Jeff happy, arcnet.c still prints
      arcnet: v3.93 BETA 2000/04/29 - by Avery Pennarun et al.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/drivers/net/arcnet/rfc1201.c b/drivers/net/arcnet/rfc1201.c
index 6b6ae4bf3d39..bee34226abfa 100644
--- a/drivers/net/arcnet/rfc1201.c
+++ b/drivers/net/arcnet/rfc1201.c
@@ -43,7 +43,7 @@ static int prepare_tx(struct net_device *dev, struct archdr *pkt, int length,
 		      int bufnum);
 static int continue_tx(struct net_device *dev, int bufnum);
 
-struct ArcProto rfc1201_proto =
+static struct ArcProto rfc1201_proto =
 {
 	.suffix		= 'a',
 	.mtu		= 1500,	/* could be more, but some receivers can't handle it... */

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/net/arcnet/rfc1201.c b/drivers/net/arcnet/rfc1201.c
new file mode 100644
index 000000000000..6b6ae4bf3d39
--- /dev/null
+++ b/drivers/net/arcnet/rfc1201.c
@@ -0,0 +1,549 @@
+/*
+ * Linux ARCnet driver - RFC1201 (standard) packet encapsulation
+ * 
+ * Written 1994-1999 by Avery Pennarun.
+ * Derived from skeleton.c by Donald Becker.
+ *
+ * Special thanks to Contemporary Controls, Inc. (www.ccontrols.com)
+ *  for sponsoring the further development of this driver.
+ *
+ * **********************
+ *
+ * The original copyright of skeleton.c was as follows:
+ *
+ * skeleton.c Written 1993 by Donald Becker.
+ * Copyright 1993 United States Government as represented by the
+ * Director, National Security Agency.  This software may only be used
+ * and distributed according to the terms of the GNU General Public License as
+ * modified by SRC, incorporated herein by reference.
+ *
+ * **********************
+ *
+ * For more details, see drivers/net/arcnet.c
+ *
+ * **********************
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/if_arp.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/arcdevice.h>
+
+MODULE_LICENSE("GPL");
+#define VERSION "arcnet: RFC1201 \"standard\" (`a') encapsulation support loaded.\n"
+
+
+static unsigned short type_trans(struct sk_buff *skb, struct net_device *dev);
+static void rx(struct net_device *dev, int bufnum,
+	       struct archdr *pkthdr, int length);
+static int build_header(struct sk_buff *skb, struct net_device *dev,
+			unsigned short type, uint8_t daddr);
+static int prepare_tx(struct net_device *dev, struct archdr *pkt, int length,
+		      int bufnum);
+static int continue_tx(struct net_device *dev, int bufnum);
+
+struct ArcProto rfc1201_proto =
+{
+	.suffix		= 'a',
+	.mtu		= 1500,	/* could be more, but some receivers can't handle it... */
+	.is_ip          = 1,    /* This is for sending IP and ARP packages */
+	.rx		= rx,
+	.build_header	= build_header,
+	.prepare_tx	= prepare_tx,
+	.continue_tx	= continue_tx,
+	.ack_tx         = NULL
+};
+
+
+static int __init arcnet_rfc1201_init(void)
+{
+	printk(VERSION);
+
+	arc_proto_map[ARC_P_IP]
+	    = arc_proto_map[ARC_P_IPV6]
+	    = arc_proto_map[ARC_P_ARP]
+	    = arc_proto_map[ARC_P_RARP]
+	    = arc_proto_map[ARC_P_IPX]
+	    = arc_proto_map[ARC_P_NOVELL_EC]
+	    = &rfc1201_proto;
+
+	/* if someone else already owns the broadcast, we won't take it */
+	if (arc_bcast_proto == arc_proto_default)
+		arc_bcast_proto = &rfc1201_proto;
+
+	return 0;
+}
+
+static void __exit arcnet_rfc1201_exit(void)
+{
+	arcnet_unregister_proto(&rfc1201_proto);
+}
+
+module_init(arcnet_rfc1201_init);
+module_exit(arcnet_rfc1201_exit);
+
+/*
+ * Determine a packet's protocol ID.
+ * 
+ * With ARCnet we have to convert everything to Ethernet-style stuff.
+ */
+static unsigned short type_trans(struct sk_buff *skb, struct net_device *dev)
+{
+	struct archdr *pkt = (struct archdr *) skb->data;
+	struct arc_rfc1201 *soft = &pkt->soft.rfc1201;
+	struct arcnet_local *lp = dev->priv;
+	int hdr_size = ARC_HDR_SIZE + RFC1201_HDR_SIZE;
+
+	/* Pull off the arcnet header. */
+	skb->mac.raw = skb->data;
+	skb_pull(skb, hdr_size);
+
+	if (pkt->hard.dest == 0)
+		skb->pkt_type = PACKET_BROADCAST;
+	else if (dev->flags & IFF_PROMISC) {
+		/* if we're not sending to ourselves :) */
+		if (pkt->hard.dest != dev->dev_addr[0])
+			skb->pkt_type = PACKET_OTHERHOST;
+	}
+	/* now return the protocol number */
+	switch (soft->proto) {
+	case ARC_P_IP:
+		return htons(ETH_P_IP);
+	case ARC_P_IPV6:
+		return htons(ETH_P_IPV6);
+	case ARC_P_ARP:
+		return htons(ETH_P_ARP);
+	case ARC_P_RARP:
+		return htons(ETH_P_RARP);
+
+	case ARC_P_IPX:
+	case ARC_P_NOVELL_EC:
+		return htons(ETH_P_802_3);
+	default:
+		lp->stats.rx_errors++;
+		lp->stats.rx_crc_errors++;
+		return 0;
+	}
+
+	return htons(ETH_P_IP);
+}
+
+
+/* packet receiver */
+static void rx(struct net_device *dev, int bufnum,
+	       struct archdr *pkthdr, int length)
+{
+	struct arcnet_local *lp = dev->priv;
+	struct sk_buff *skb;
+	struct archdr *pkt = pkthdr;
+	struct arc_rfc1201 *soft = &pkthdr->soft.rfc1201;
+	int saddr = pkt->hard.source, ofs;
+	struct Incoming *in = &lp->rfc1201.incoming[saddr];
+
+	BUGMSG(D_DURING, "it's an RFC1201 packet (length=%d)\n", length);
+
+	if (length >= MinTU)
+		ofs = 512 - length;
+	else
+		ofs = 256 - length;
+
+	if (soft->split_flag == 0xFF) {		/* Exception Packet */
+		if (length >= 4 + RFC1201_HDR_SIZE)
+			BUGMSG(D_DURING, "compensating for exception packet\n");
+		else {
+			BUGMSG(D_EXTRA, "short RFC1201 exception packet from %02Xh",
+			       saddr);
+			return;
+		}
+
+		/* skip over 4-byte junkola */
+		length -= 4;
+		ofs += 4;
+		lp->hw.copy_from_card(dev, bufnum, 512 - length,
+				      soft, sizeof(pkt->soft));
+	}
+	if (!soft->split_flag) {	/* not split */
+		BUGMSG(D_RX, "incoming is not split (splitflag=%d)\n",
+		       soft->split_flag);
+
+		if (in->skb) {	/* already assembling one! */
+			BUGMSG(D_EXTRA, "aborting assembly (seq=%d) for unsplit packet (splitflag=%d, seq=%d)\n",
+			 in->sequence, soft->split_flag, soft->sequence);
+			lp->rfc1201.aborted_seq = soft->sequence;
+			dev_kfree_skb_irq(in->skb);
+			lp->stats.rx_errors++;
+			lp->stats.rx_missed_errors++;
+			in->skb = NULL;
+		}
+		in->sequence = soft->sequence;
+
+		skb = alloc_skb(length + ARC_HDR_SIZE, GFP_ATOMIC);
+		if (skb == NULL) {
+			BUGMSG(D_NORMAL, "Memory squeeze, dropping packet.\n");
+			lp->stats.rx_dropped++;
+			return;
+		}
+		skb_put(skb, length + ARC_HDR_SIZE);
+		skb->dev = dev;
+
+		pkt = (struct archdr *) skb->data;
+		soft = &pkt->soft.rfc1201;
+
+		/* up to sizeof(pkt->soft) has already been copied from the card */
+		memcpy(pkt, pkthdr, sizeof(struct archdr));
+		if (length > sizeof(pkt->soft))
+			lp->hw.copy_from_card(dev, bufnum, ofs + sizeof(pkt->soft),
+				       pkt->soft.raw + sizeof(pkt->soft),
+					      length - sizeof(pkt->soft));
+
+		/*
+		 * ARP packets have problems when sent from some DOS systems: the
+		 * source address is always 0!  So we take the hardware source addr
+		 * (which is impossible to fumble) and insert it ourselves.
+		 */
+		if (soft->proto == ARC_P_ARP) {
+			struct arphdr *arp = (struct arphdr *) soft->payload;
+
+			/* make sure addresses are the right length */
+			if (arp->ar_hln == 1 && arp->ar_pln == 4) {
+				uint8_t *cptr = (uint8_t *) arp + sizeof(struct arphdr);
+
+				if (!*cptr) {	/* is saddr = 00? */
+					BUGMSG(D_EXTRA,
+					       "ARP source address was 00h, set to %02Xh.\n",
+					       saddr);
+					lp->stats.rx_crc_errors++;
+					*cptr = saddr;
+				} else {
+					BUGMSG(D_DURING, "ARP source address (%Xh) is fine.\n",
+					       *cptr);
+				}
+			} else {
+				BUGMSG(D_NORMAL, "funny-shaped ARP packet. (%Xh, %Xh)\n",
+				       arp->ar_hln, arp->ar_pln);
+				lp->stats.rx_errors++;
+				lp->stats.rx_crc_errors++;
+			}
+		}
+		BUGLVL(D_SKB) arcnet_dump_skb(dev, skb, "rx");
+
+		skb->protocol = type_trans(skb, dev);
+		netif_rx(skb);
+		dev->last_rx = jiffies;
+	} else {		/* split packet */
+		/*
+		 * NOTE: MSDOS ARP packet correction should only need to apply to
+		 * unsplit packets, since ARP packets are so short.
+		 *
+		 * My interpretation of the RFC1201 document is that if a packet is
+		 * received out of order, the entire assembly process should be
+		 * aborted.
+		 *
+		 * The RFC also mentions "it is possible for successfully received
+		 * packets to be retransmitted." As of 0.40 all previously received
+		 * packets are allowed, not just the most recent one.
+		 *
+		 * We allow multiple assembly processes, one for each ARCnet card
+		 * possible on the network.  Seems rather like a waste of memory,
+		 * but there's no other way to be reliable.
+		 */
+
+		BUGMSG(D_RX, "packet is split (splitflag=%d, seq=%d)\n",
+		       soft->split_flag, in->sequence);
+
+		if (in->skb && in->sequence != soft->sequence) {
+			BUGMSG(D_EXTRA, "wrong seq number (saddr=%d, expected=%d, seq=%d, splitflag=%d)\n",
+			       saddr, in->sequence, soft->sequence,
+			       soft->split_flag);
+			dev_kfree_skb_irq(in->skb);
+			in->skb = NULL;
+			lp->stats.rx_errors++;
+			lp->stats.rx_missed_errors++;
+			in->lastpacket = in->numpackets = 0;
+		}
+		if (soft->split_flag & 1) {	/* first packet in split */
+			BUGMSG(D_RX, "brand new splitpacket (splitflag=%d)\n",
+			       soft->split_flag);
+			if (in->skb) {	/* already assembling one! */
+				BUGMSG(D_EXTRA, "aborting previous (seq=%d) assembly "
+				       "(splitflag=%d, seq=%d)\n",
+				       in->sequence, soft->split_flag,
+				       soft->sequence);
+				lp->stats.rx_errors++;
+				lp->stats.rx_missed_errors++;
+				dev_kfree_skb_irq(in->skb);
+			}
+			in->sequence = soft->sequence;
+			in->numpackets = ((unsigned) soft->split_flag >> 1) + 2;
+			in->lastpacket = 1;
+
+			if (in->numpackets > 16) {
+				BUGMSG(D_EXTRA, "incoming packet more than 16 segments; dropping. (splitflag=%d)\n",
+				       soft->split_flag);
+				lp->rfc1201.aborted_seq = soft->sequence;
+				lp->stats.rx_errors++;
+				lp->stats.rx_length_errors++;
+				return;
+			}
+			in->skb = skb = alloc_skb(508 * in->numpackets + ARC_HDR_SIZE,
+						  GFP_ATOMIC);
+			if (skb == NULL) {
+				BUGMSG(D_NORMAL, "(split) memory squeeze, dropping packet.\n");
+				lp->rfc1201.aborted_seq = soft->sequence;
+				lp->stats.rx_dropped++;
+				return;
+			}
+			skb->dev = dev;
+			pkt = (struct archdr *) skb->data;
+			soft = &pkt->soft.rfc1201;
+
+			memcpy(pkt, pkthdr, ARC_HDR_SIZE + RFC1201_HDR_SIZE);
+			skb_put(skb, ARC_HDR_SIZE + RFC1201_HDR_SIZE);
+
+			soft->split_flag = 0;	/* end result won't be split */
+		} else {	/* not first packet */
+			int packetnum = ((unsigned) soft->split_flag >> 1) + 1;
+
+			/*
+			 * if we're not assembling, there's no point trying to
+			 * continue.
+			 */
+			if (!in->skb) {
+				if (lp->rfc1201.aborted_seq != soft->sequence) {
+					BUGMSG(D_EXTRA, "can't continue split without starting "
+					       "first! (splitflag=%d, seq=%d, aborted=%d)\n",
+					soft->split_flag, soft->sequence,
+					       lp->rfc1201.aborted_seq);
+					lp->stats.rx_errors++;
+					lp->stats.rx_missed_errors++;
+				}
+				return;
+			}
+			in->lastpacket++;
+			if (packetnum != in->lastpacket) {	/* not the right flag! */
+				/* harmless duplicate? ignore. */
+				if (packetnum <= in->lastpacket - 1) {
+					BUGMSG(D_EXTRA, "duplicate splitpacket ignored! (splitflag=%d)\n",
+					       soft->split_flag);
+					lp->stats.rx_errors++;
+					lp->stats.rx_frame_errors++;
+					return;
+				}
+				/* "bad" duplicate, kill reassembly */
+				BUGMSG(D_EXTRA, "out-of-order splitpacket, reassembly "
+				       "(seq=%d) aborted (splitflag=%d, seq=%d)\n",
+				       in->sequence, soft->split_flag, soft->sequence);
+				lp->rfc1201.aborted_seq = soft->sequence;
+				dev_kfree_skb_irq(in->skb);
+				in->skb = NULL;
+				lp->stats.rx_errors++;
+				lp->stats.rx_missed_errors++;
+				in->lastpacket = in->numpackets = 0;
+				return;
+			}
+			pkt = (struct archdr *) in->skb->data;
+			soft = &pkt->soft.rfc1201;
+		}
+
+		skb = in->skb;
+
+		lp->hw.copy_from_card(dev, bufnum, ofs + RFC1201_HDR_SIZE,
+				      skb->data + skb->len,
+				      length - RFC1201_HDR_SIZE);
+		skb_put(skb, length - RFC1201_HDR_SIZE);
+
+		/* are we done? */
+		if (in->lastpacket == in->numpackets) {
+			in->skb = NULL;
+			in->lastpacket = in->numpackets = 0;
+
+	    BUGMSG(D_SKB_SIZE, "skb: received %d bytes from %02X (unsplit)\n",
+    		skb->len, pkt->hard.source);
+	    BUGMSG(D_SKB_SIZE, "skb: received %d bytes from %02X (split)\n",
+    		skb->len, pkt->hard.source);
+			BUGLVL(D_SKB) arcnet_dump_skb(dev, skb, "rx");
+
+			skb->protocol = type_trans(skb, dev);
+			netif_rx(skb);
+			dev->last_rx = jiffies;
+		}
+	}
+}
+
+
+/* Create the ARCnet hard/soft headers for RFC1201. */
+static int build_header(struct sk_buff *skb, struct net_device *dev,
+			unsigned short type, uint8_t daddr)
+{
+	struct arcnet_local *lp = dev->priv;
+	int hdr_size = ARC_HDR_SIZE + RFC1201_HDR_SIZE;
+	struct archdr *pkt = (struct archdr *) skb_push(skb, hdr_size);
+	struct arc_rfc1201 *soft = &pkt->soft.rfc1201;
+
+	/* set the protocol ID according to RFC1201 */
+	switch (type) {
+	case ETH_P_IP:
+		soft->proto = ARC_P_IP;
+		break;
+	case ETH_P_IPV6:
+		soft->proto = ARC_P_IPV6;
+		break;
+	case ETH_P_ARP:
+		soft->proto = ARC_P_ARP;
+		break;
+	case ETH_P_RARP:
+		soft->proto = ARC_P_RARP;
+		break;
+	case ETH_P_IPX:
+	case ETH_P_802_3:
+	case ETH_P_802_2:
+		soft->proto = ARC_P_IPX;
+		break;
+	case ETH_P_ATALK:
+		soft->proto = ARC_P_ATALK;
+		break;
+	default:
+		BUGMSG(D_NORMAL, "RFC1201: I don't understand protocol %d (%Xh)\n",
+		       type, type);
+		lp->stats.tx_errors++;
+		lp->stats.tx_aborted_errors++;
+		return 0;
+	}
+
+	/*
+	 * Set the source hardware address.
+	 *
+	 * This is pretty pointless for most purposes, but it can help in
+	 * debugging.  ARCnet does not allow us to change the source address in
+	 * the actual packet sent)
+	 */
+	pkt->hard.source = *dev->dev_addr;
+
+	soft->sequence = htons(lp->rfc1201.sequence++);
+	soft->split_flag = 0;	/* split packets are done elsewhere */
+
+	/* see linux/net/ethernet/eth.c to see where I got the following */
+
+	if (dev->flags & (IFF_LOOPBACK | IFF_NOARP)) {
+		/* 
+		 * FIXME: fill in the last byte of the dest ipaddr here to better
+		 * comply with RFC1051 in "noarp" mode.  For now, always broadcasting
+		 * will probably at least get packets sent out :)
+		 */
+		pkt->hard.dest = 0;
+		return hdr_size;
+	}
+	/* otherwise, drop in the dest address */
+	pkt->hard.dest = daddr;
+	return hdr_size;
+}
+
+
+static void load_pkt(struct net_device *dev, struct arc_hardware *hard,
+		     struct arc_rfc1201 *soft, int softlen, int bufnum)
+{
+	struct arcnet_local *lp = dev->priv;
+	int ofs;
+
+	/* assume length <= XMTU: someone should have handled that by now. */
+
+	if (softlen > MinTU) {
+		hard->offset[0] = 0;
+		hard->offset[1] = ofs = 512 - softlen;
+	} else if (softlen > MTU) {	/* exception packet - add an extra header */
+		struct arc_rfc1201 excsoft;
+
+		excsoft.proto = soft->proto;
+		excsoft.split_flag = 0xff;
+		excsoft.sequence = 0xffff;
+
+		hard->offset[0] = 0;
+		ofs = 512 - softlen;
+		hard->offset[1] = ofs - RFC1201_HDR_SIZE;
+		lp->hw.copy_to_card(dev, bufnum, ofs - RFC1201_HDR_SIZE,
+				    &excsoft, RFC1201_HDR_SIZE);
+	} else
+		hard->offset[0] = ofs = 256 - softlen;
+
+	lp->hw.copy_to_card(dev, bufnum, 0, hard, ARC_HDR_SIZE);
+	lp->hw.copy_to_card(dev, bufnum, ofs, soft, softlen);
+
+	lp->lastload_dest = hard->dest;
+}
+
+
+static int prepare_tx(struct net_device *dev, struct archdr *pkt, int length,
+		      int bufnum)
+{
+	struct arcnet_local *lp = dev->priv;
+	const int maxsegsize = XMTU - RFC1201_HDR_SIZE;
+	struct Outgoing *out;
+
+
+	BUGMSG(D_DURING, "prepare_tx: txbufs=%d/%d/%d\n",
+	       lp->next_tx, lp->cur_tx, bufnum);
+
+	length -= ARC_HDR_SIZE;	/* hard header is not included in packet length */
+	pkt->soft.rfc1201.split_flag = 0;
+
+	/* need to do a split packet? */
+	if (length > XMTU) {
+		out = &lp->outgoing;
+
+		out->length = length - RFC1201_HDR_SIZE;
+		out->dataleft = lp->outgoing.length;
+		out->numsegs = (out->dataleft + maxsegsize - 1) / maxsegsize;
+		out->segnum = 0;
+
+		BUGMSG(D_DURING, "rfc1201 prep_tx: ready for %d-segment split "
+		       "(%d bytes, seq=%d)\n", out->numsegs, out->length,
+		       pkt->soft.rfc1201.sequence);
+
+		return 0;	/* not done */
+	}
+	/* just load the packet into the buffers and send it off */
+	load_pkt(dev, &pkt->hard, &pkt->soft.rfc1201, length, bufnum);
+
+	return 1;		/* done */
+}
+
+
+static int continue_tx(struct net_device *dev, int bufnum)
+{
+	struct arcnet_local *lp = dev->priv;
+	struct Outgoing *out = &lp->outgoing;
+	struct arc_hardware *hard = &out->pkt->hard;
+	struct arc_rfc1201 *soft = &out->pkt->soft.rfc1201, *newsoft;
+	int maxsegsize = XMTU - RFC1201_HDR_SIZE;
+	int seglen;
+
+	BUGMSG(D_DURING,
+	  "rfc1201 continue_tx: loading segment %d(+1) of %d (seq=%d)\n",
+	       out->segnum, out->numsegs, soft->sequence);
+
+	/* the "new" soft header comes right before the data chunk */
+	newsoft = (struct arc_rfc1201 *)
+	    (out->pkt->soft.raw + out->length - out->dataleft);
+
+	if (!out->segnum)	/* first packet; newsoft == soft */
+		newsoft->split_flag = ((out->numsegs - 2) << 1) | 1;
+	else {
+		newsoft->split_flag = out->segnum << 1;
+		newsoft->proto = soft->proto;
+		newsoft->sequence = soft->sequence;
+	}
+
+	seglen = maxsegsize;
+	if (seglen > out->dataleft)
+		seglen = out->dataleft;
+	out->dataleft -= seglen;
+
+	load_pkt(dev, hard, newsoft, seglen + RFC1201_HDR_SIZE, bufnum);
+
+	out->segnum++;
+	if (out->segnum >= out->numsegs)
+		return 1;
+	else
+		return 0;
+}
