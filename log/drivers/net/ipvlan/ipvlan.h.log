commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h
index b906d2f6bd04..3837c897832e 100644
--- a/drivers/net/ipvlan/ipvlan.h
+++ b/drivers/net/ipvlan/ipvlan.h
@@ -1,11 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * Copyright (c) 2014 Mahesh Bandewar <maheshb@google.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
  */
 #ifndef __IPVLAN_H
 #define __IPVLAN_H

commit c675e06a98a474f7ad0af32ce467613da818da52
Author: Daniel Borkmann <daniel@iogearbox.net>
Date:   Fri Feb 8 13:55:31 2019 +0100

    ipvlan: decouple l3s mode dependencies from other modes
    
    Right now ipvlan has a hard dependency on CONFIG_NETFILTER and
    otherwise it cannot be built. However, the only ipvlan operation
    mode that actually depends on netfilter is l3s, everything else
    is independent of it. Break this hard dependency such that users
    are able to use ipvlan l3 mode on systems where netfilter is not
    compiled in.
    
    Therefore, this adds a hidden CONFIG_IPVLAN_L3S bool which is
    defaulting to y when CONFIG_NETFILTER is set in order to retain
    existing behavior for l3s. All l3s related code is refactored
    into ipvlan_l3s.c that is compiled in when enabled.
    
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Cc: Mahesh Bandewar <maheshb@google.com>
    Cc: Florian Westphal <fw@strlen.de>
    Cc: Martynas Pumputis <m@lambda.lt>
    Acked-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h
index adb826f55e60..b906d2f6bd04 100644
--- a/drivers/net/ipvlan/ipvlan.h
+++ b/drivers/net/ipvlan/ipvlan.h
@@ -165,10 +165,9 @@ struct ipvl_addr *ipvlan_find_addr(const struct ipvl_dev *ipvlan,
 				   const void *iaddr, bool is_v6);
 bool ipvlan_addr_busy(struct ipvl_port *port, void *iaddr, bool is_v6);
 void ipvlan_ht_addr_del(struct ipvl_addr *addr);
-struct sk_buff *ipvlan_l3_rcv(struct net_device *dev, struct sk_buff *skb,
-			      u16 proto);
-unsigned int ipvlan_nf_input(void *priv, struct sk_buff *skb,
-			     const struct nf_hook_state *state);
+struct ipvl_addr *ipvlan_addr_lookup(struct ipvl_port *port, void *lyr3h,
+				     int addr_type, bool use_dest);
+void *ipvlan_get_L3_hdr(struct ipvl_port *port, struct sk_buff *skb, int *type);
 void ipvlan_count_rx(const struct ipvl_dev *ipvlan,
 		     unsigned int len, bool success, bool mcast);
 int ipvlan_link_new(struct net *src_net, struct net_device *dev,
@@ -177,6 +176,36 @@ int ipvlan_link_new(struct net *src_net, struct net_device *dev,
 void ipvlan_link_delete(struct net_device *dev, struct list_head *head);
 void ipvlan_link_setup(struct net_device *dev);
 int ipvlan_link_register(struct rtnl_link_ops *ops);
+#ifdef CONFIG_IPVLAN_L3S
+int ipvlan_l3s_register(struct ipvl_port *port);
+void ipvlan_l3s_unregister(struct ipvl_port *port);
+void ipvlan_migrate_l3s_hook(struct net *oldnet, struct net *newnet);
+int ipvlan_l3s_init(void);
+void ipvlan_l3s_cleanup(void);
+#else
+static inline int ipvlan_l3s_register(struct ipvl_port *port)
+{
+	return -ENOTSUPP;
+}
+
+static inline void ipvlan_l3s_unregister(struct ipvl_port *port)
+{
+}
+
+static inline void ipvlan_migrate_l3s_hook(struct net *oldnet,
+					   struct net *newnet)
+{
+}
+
+static inline int ipvlan_l3s_init(void)
+{
+	return 0;
+}
+
+static inline void ipvlan_l3s_cleanup(void)
+{
+}
+#endif /* CONFIG_IPVLAN_L3S */
 
 static inline bool netif_is_ipvlan_port(const struct net_device *dev)
 {

commit ae5799dc7ec77fe0382d58cdcba9f6d1204157ae
Author: Paolo Abeni <pabeni@redhat.com>
Date:   Thu Mar 8 10:29:30 2018 +0100

    ipvlan: properly annotate rx_handler access
    
    The rx_handler field is rcu-protected, but I forgot to use the
    proper accessor while refactoring netif_is_ipvlan_port(). Such
    function only check the rx_handler value, so it is safe, but we need
    to properly read rx_handler via rcu_access_pointer() to avoid sparse
    warnings.
    
    Fixes: 1ec54cb44e67 ("net: unpollute priv_flags space")
    Signed-off-by: Paolo Abeni <pabeni@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h
index c818b9bdab6e..adb826f55e60 100644
--- a/drivers/net/ipvlan/ipvlan.h
+++ b/drivers/net/ipvlan/ipvlan.h
@@ -180,7 +180,7 @@ int ipvlan_link_register(struct rtnl_link_ops *ops);
 
 static inline bool netif_is_ipvlan_port(const struct net_device *dev)
 {
-	return dev->rx_handler == ipvlan_handle_frame;
+	return rcu_access_pointer(dev->rx_handler) == ipvlan_handle_frame;
 }
 
 #endif /* __IPVLAN_H */

commit 1ec54cb44e6731c3cb251bcf9251d65a4b4f6306
Author: Paolo Abeni <pabeni@redhat.com>
Date:   Tue Mar 6 10:56:31 2018 +0100

    net: unpollute priv_flags space
    
    the ipvlan device driver defines and uses 2 bits inside the priv_flags
    net_device field. Such bits and the related helper are used only
    inside the ipvlan device driver, and the core networking does not
    need to be aware of them.
    
    This change moves netif_is_ipvlan* helper in the ipvlan driver and
    re-implement them looking for ipvlan specific symbols instead of
    using priv_flags.
    
    Overall this frees two bits inside priv_flags - and move the following
    ones to avoid gaps - without any intended functional change.
    
    Signed-off-by: Paolo Abeni <pabeni@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h
index a115f12bf130..c818b9bdab6e 100644
--- a/drivers/net/ipvlan/ipvlan.h
+++ b/drivers/net/ipvlan/ipvlan.h
@@ -177,4 +177,10 @@ int ipvlan_link_new(struct net *src_net, struct net_device *dev,
 void ipvlan_link_delete(struct net_device *dev, struct list_head *head);
 void ipvlan_link_setup(struct net_device *dev);
 int ipvlan_link_register(struct rtnl_link_ops *ops);
+
+static inline bool netif_is_ipvlan_port(const struct net_device *dev)
+{
+	return dev->rx_handler == ipvlan_handle_frame;
+}
+
 #endif /* __IPVLAN_H */

commit 8230819494b3bf284ca7262ac5f877333147b937
Author: Paolo Abeni <pabeni@redhat.com>
Date:   Wed Feb 28 10:59:27 2018 +0100

    ipvlan: use per device spinlock to protect addrs list updates
    
    This changeset moves ipvlan address under RCU protection, using
    a per ipvlan device spinlock to protect list mutation and RCU
    read access to protect list traversal.
    
    Also explicitly use RCU read lock to traverse the per port
    ipvlans list, so that we can now perform a full address lookup
    without asserting the RTNL lock.
    
    Overall this allows the ipvlan driver to check fully for duplicate
    addresses - before this commit ipv6 addresses assigned by autoconf
    via prefix delegation where accepted without any check - and avoid
    the following rntl assertion failure still in the same code path:
    
     RTNL: assertion failed at drivers/net/ipvlan/ipvlan_core.c (124)
     WARNING: CPU: 15 PID: 0 at drivers/net/ipvlan/ipvlan_core.c:124 ipvlan_addr_busy+0x97/0xa0 [ipvlan]
     Modules linked in: ipvlan(E) ixgbe
     CPU: 15 PID: 0 Comm: swapper/15 Tainted: G            E    4.16.0-rc2.ipvlan+ #1782
     Hardware name: Dell Inc. PowerEdge R730/072T6D, BIOS 2.1.7 06/16/2016
     RIP: 0010:ipvlan_addr_busy+0x97/0xa0 [ipvlan]
     RSP: 0018:ffff881ff9e03768 EFLAGS: 00010286
     RAX: 0000000000000000 RBX: ffff881fdf2a9000 RCX: 0000000000000000
     RDX: 0000000000000001 RSI: 00000000000000f6 RDI: 0000000000000300
     RBP: ffff881fdf2a8000 R08: 0000000000000000 R09: 0000000000000000
     R10: 0000000000000001 R11: ffff881ff9e034c0 R12: ffff881fe07bcc00
     R13: 0000000000000001 R14: ffffffffa02002b0 R15: 0000000000000001
     FS:  0000000000000000(0000) GS:ffff881ff9e00000(0000) knlGS:0000000000000000
     CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
     CR2: 00007fc5c1a4f248 CR3: 000000207e012005 CR4: 00000000001606e0
     Call Trace:
      <IRQ>
      ipvlan_addr6_event+0x6c/0xd0 [ipvlan]
      notifier_call_chain+0x49/0x90
      atomic_notifier_call_chain+0x6a/0x100
      ipv6_add_addr+0x5f9/0x720
      addrconf_prefix_rcv_add_addr+0x244/0x3c0
      addrconf_prefix_rcv+0x2f3/0x790
      ndisc_router_discovery+0x633/0xb70
      ndisc_rcv+0x155/0x180
      icmpv6_rcv+0x4ac/0x5f0
      ip6_input_finish+0x138/0x6a0
      ip6_input+0x41/0x1f0
      ipv6_rcv+0x4db/0x8d0
      __netif_receive_skb_core+0x3d5/0xe40
      netif_receive_skb_internal+0x89/0x370
      napi_gro_receive+0x14f/0x1e0
      ixgbe_clean_rx_irq+0x4ce/0x1020 [ixgbe]
      ixgbe_poll+0x31a/0x7a0 [ixgbe]
      net_rx_action+0x296/0x4f0
      __do_softirq+0xcf/0x4f5
      irq_exit+0xf5/0x110
      do_IRQ+0x62/0x110
      common_interrupt+0x91/0x91
      </IRQ>
    
     v1 -> v2: drop unneeded in_softirq check in ipvlan_addr6_validator_event()
    
    Fixes: e9997c2938b2 ("ipvlan: fix check for IP addresses in control path")
    Signed-off-by: Paolo Abeni <pabeni@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h
index 5166575a164d..a115f12bf130 100644
--- a/drivers/net/ipvlan/ipvlan.h
+++ b/drivers/net/ipvlan/ipvlan.h
@@ -74,6 +74,7 @@ struct ipvl_dev {
 	DECLARE_BITMAP(mac_filters, IPVLAN_MAC_FILTER_SIZE);
 	netdev_features_t	sfeatures;
 	u32			msg_enable;
+	spinlock_t		addrs_lock;
 };
 
 struct ipvl_addr {

commit fe89aa6b250c1011ccf425fbb7998e96bd54263f
Author: Mahesh Bandewar <maheshb@google.com>
Date:   Thu Oct 26 15:09:25 2017 -0700

    ipvlan: implement VEPA mode
    
    This is very similar to the Macvlan VEPA mode, however, there is some
    difference. IPvlan uses the mac-address of the lower device, so the VEPA
    mode has implications of ICMP-redirects for packets destined for its
    immediate neighbors sharing same master since the packets will have same
    source and dest mac. The external switch/router will send redirect msg.
    
    Having said that, this will be useful tool in terms of debugging
    since IPvlan will not switch packets within its slaves and rely completely
    on the external entity as intended in 802.1Qbg.
    
    Signed-off-by: Mahesh Bandewar <maheshb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h
index 9941851bcc13..5166575a164d 100644
--- a/drivers/net/ipvlan/ipvlan.h
+++ b/drivers/net/ipvlan/ipvlan.h
@@ -139,6 +139,21 @@ static inline void ipvlan_clear_private(struct ipvl_port *port)
 	port->flags &= ~IPVLAN_F_PRIVATE;
 }
 
+static inline bool ipvlan_is_vepa(const struct ipvl_port *port)
+{
+	return !!(port->flags & IPVLAN_F_VEPA);
+}
+
+static inline void ipvlan_mark_vepa(struct ipvl_port *port)
+{
+	port->flags |= IPVLAN_F_VEPA;
+}
+
+static inline void ipvlan_clear_vepa(struct ipvl_port *port)
+{
+	port->flags &= ~IPVLAN_F_VEPA;
+}
+
 void ipvlan_init_secret(void);
 unsigned int ipvlan_mac_hash(const unsigned char *addr);
 rx_handler_result_t ipvlan_handle_frame(struct sk_buff **pskb);

commit a190d04db93710ae166749055b6985397c6d13f5
Author: Mahesh Bandewar <maheshb@google.com>
Date:   Thu Oct 26 15:09:21 2017 -0700

    ipvlan: introduce 'private' attribute for all existing modes.
    
    IPvlan has always operated in bridge mode. However there are scenarios
    where each slave should be able to talk through the master device but
    not necessarily across each other. Think of an environment where each
    of a namespace is a private and independant customer. In this scenario
    the machine which is hosting these namespaces neither want to tell who
    their neighbor is nor the individual namespaces care to talk to neighbor
    on short-circuited network path.
    
    This patch implements the mode that is very similar to the 'private' mode
    in macvlan where individual slaves can send and receive traffic through
    the master device, just that they can not talk among slave devices.
    
    Signed-off-by: Mahesh Bandewar <maheshb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h
index ba8173a0b62e..9941851bcc13 100644
--- a/drivers/net/ipvlan/ipvlan.h
+++ b/drivers/net/ipvlan/ipvlan.h
@@ -96,6 +96,7 @@ struct ipvl_port {
 	struct hlist_head	hlhead[IPVLAN_HASH_SIZE];
 	struct list_head	ipvlans;
 	u16			mode;
+	u16			flags;
 	u16			dev_id_start;
 	struct work_struct	wq;
 	struct sk_buff_head	backlog;
@@ -123,6 +124,21 @@ static inline struct ipvl_port *ipvlan_port_get_rtnl(const struct net_device *d)
 	return rtnl_dereference(d->rx_handler_data);
 }
 
+static inline bool ipvlan_is_private(const struct ipvl_port *port)
+{
+	return !!(port->flags & IPVLAN_F_PRIVATE);
+}
+
+static inline void ipvlan_mark_private(struct ipvl_port *port)
+{
+	port->flags |= IPVLAN_F_PRIVATE;
+}
+
+static inline void ipvlan_clear_private(struct ipvl_port *port)
+{
+	port->flags &= ~IPVLAN_F_PRIVATE;
+}
+
 void ipvlan_init_secret(void);
 unsigned int ipvlan_mac_hash(const unsigned char *addr);
 rx_handler_result_t ipvlan_handle_frame(struct sk_buff **pskb);

commit 7a3f4a185169b195c33f1c54f33a44eba2d6aa96
Author: Matthias Schiffer <mschiffer@universe-factory.net>
Date:   Sun Jun 25 23:55:59 2017 +0200

    net: add netlink_ext_ack argument to rtnl_link_ops.newlink
    
    Add support for extended error reporting.
    
    Signed-off-by: Matthias Schiffer <mschiffer@universe-factory.net>
    Acked-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h
index 7919369c0a72..ba8173a0b62e 100644
--- a/drivers/net/ipvlan/ipvlan.h
+++ b/drivers/net/ipvlan/ipvlan.h
@@ -140,7 +140,8 @@ unsigned int ipvlan_nf_input(void *priv, struct sk_buff *skb,
 void ipvlan_count_rx(const struct ipvl_dev *ipvlan,
 		     unsigned int len, bool success, bool mcast);
 int ipvlan_link_new(struct net *src_net, struct net_device *dev,
-		    struct nlattr *tb[], struct nlattr *data[]);
+		    struct nlattr *tb[], struct nlattr *data[],
+		    struct netlink_ext_ack *extack);
 void ipvlan_link_delete(struct net_device *dev, struct list_head *head);
 void ipvlan_link_setup(struct net_device *dev);
 int ipvlan_link_register(struct rtnl_link_ops *ops);

commit 3133822f5ac13b04c2ca46f27cfe74606bbd4a6d
Author: Florian Westphal <fw@strlen.de>
Date:   Thu Apr 20 18:08:15 2017 +0200

    ipvlan: use pernet operations and restrict l3s hooks to master netns
    
    commit 4fbae7d83c98c30efc ("ipvlan: Introduce l3s mode") added
    registration of netfilter hooks via nf_register_hooks().
    
    This API provides the illusion of 'global' netfilter hooks by placing the
    hooks in all current and future network namespaces.
    
    In case of ipvlan the hook appears to be only needed in the namespace
    that contains the ipvlan master device (i.e., usually init_net), so
    placing them in all namespaces is not needed.
    
    This switches ipvlan driver to pernet operations, and then only registers
    hooks in namespaces where a ipvlan master device is set to l3s mode.
    
    Extra care has to be taken when the master device is moved to another
    namespace, as we might have to 'move' the netfilter hooks too.
    
    This is done by storing the namespace the ipvlan port was created in.
    On REGISTER event, do (un)register operations in the old/new namespaces.
    
    This will also allow removal of the nf_register_hooks() in a future patch.
    
    Cc: Mahesh Bandewar <maheshb@google.com>
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h
index 800a46c8d26c..7919369c0a72 100644
--- a/drivers/net/ipvlan/ipvlan.h
+++ b/drivers/net/ipvlan/ipvlan.h
@@ -26,6 +26,7 @@
 #include <linux/netfilter.h>
 #include <net/ip.h>
 #include <net/ip6_route.h>
+#include <net/netns/generic.h>
 #include <net/rtnetlink.h>
 #include <net/route.h>
 #include <net/addrconf.h>
@@ -91,6 +92,7 @@ struct ipvl_addr {
 
 struct ipvl_port {
 	struct net_device	*dev;
+	possible_net_t		pnet;
 	struct hlist_head	hlhead[IPVLAN_HASH_SIZE];
 	struct list_head	ipvlans;
 	u16			mode;

commit 235a9d89da976e2975b3de9afc0bed7b72557983
Author: Sainath Grandhi <sainath.grandhi@intel.com>
Date:   Fri Feb 10 16:03:52 2017 -0800

    ipvtap: IP-VLAN based tap driver
    
    This patch adds a tap character device driver that is based on the
    IP-VLAN network interface, called ipvtap. An ipvtap device can be created
    in the same way as an ipvlan device, using 'type ipvtap', and then accessed
    using the tap user space interface.
    
    Signed-off-by: Sainath Grandhi <sainath.grandhi@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h
index 406ae4ff0ae8..800a46c8d26c 100644
--- a/drivers/net/ipvlan/ipvlan.h
+++ b/drivers/net/ipvlan/ipvlan.h
@@ -135,4 +135,11 @@ struct sk_buff *ipvlan_l3_rcv(struct net_device *dev, struct sk_buff *skb,
 			      u16 proto);
 unsigned int ipvlan_nf_input(void *priv, struct sk_buff *skb,
 			     const struct nf_hook_state *state);
+void ipvlan_count_rx(const struct ipvl_dev *ipvlan,
+		     unsigned int len, bool success, bool mcast);
+int ipvlan_link_new(struct net *src_net, struct net_device *dev,
+		    struct nlattr *tb[], struct nlattr *data[]);
+void ipvlan_link_delete(struct net_device *dev, struct list_head *head);
+void ipvlan_link_setup(struct net_device *dev);
+int ipvlan_link_register(struct rtnl_link_ops *ops);
 #endif /* __IPVLAN_H */

commit da36e13cf653541e385a8d2ec2637fff6ea3461a
Author: Mahesh Bandewar <maheshb@google.com>
Date:   Mon Jan 9 15:05:54 2017 -0800

    ipvlan: improvise dev_id generation logic in IPvlan
    
    The patch 009146d117b ("ipvlan: assign unique dev-id for each slave
    device.") used ida_simple_get() to generate dev_ids assigned to the
    slave devices. However (Eric has pointed out that) there is a shortcoming
    with that approach as it always uses the first available ID. This
    becomes a problem when a slave gets deleted and a new slave gets added.
    The ID gets reassigned causing the new slave to get the same link-local
    address. This side-effect is undesirable.
    
    This patch adds a per-port variable that keeps track of the IDs
    assigned and used as the stat-base for the IDR api. This base will be
    wrapped around when it reaches the MAX (0xFFFE) value possibly on a
    busy system where slaves are added and deleted routinely.
    
    Fixes: 009146d117b ("ipvlan: assign unique dev-id for each slave device.")
    Signed-off-by: Mahesh Bandewar <maheshb@google.com>
    CC: Eric Dumazet <edumazet@google.com>
    CC: David Miller <davem@davemloft.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h
index 0a9068fdee0f..406ae4ff0ae8 100644
--- a/drivers/net/ipvlan/ipvlan.h
+++ b/drivers/net/ipvlan/ipvlan.h
@@ -94,6 +94,7 @@ struct ipvl_port {
 	struct hlist_head	hlhead[IPVLAN_HASH_SIZE];
 	struct list_head	ipvlans;
 	u16			mode;
+	u16			dev_id_start;
 	struct work_struct	wq;
 	struct sk_buff_head	backlog;
 	int			count;

commit 009146d117b9b816193fce0f1ed75f015a398721
Author: Mahesh Bandewar <maheshb@google.com>
Date:   Tue Jan 3 12:47:16 2017 -0800

    ipvlan: assign unique dev-id for each slave device.
    
    IPvlan setup uses one mac-address (of master). The IPv6 link-local
    addresses are derived using the mac-address on the link. Lack of
    dev-ids makes these link-local addresses same for all slaves including
    that of master device. dev-ids are necessary to add differentiation
    when L2 address is shared.
    
    Signed-off-by: Mahesh Bandewar <maheshb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h
index dbfbb33ac66c..0a9068fdee0f 100644
--- a/drivers/net/ipvlan/ipvlan.h
+++ b/drivers/net/ipvlan/ipvlan.h
@@ -97,6 +97,7 @@ struct ipvl_port {
 	struct work_struct	wq;
 	struct sk_buff_head	backlog;
 	int			count;
+	struct ida		ida;
 };
 
 struct ipvl_skb_cb {

commit e252536068efd1578c6e23e7323527c5e6e980bd
Author: Mahesh Bandewar <maheshb@google.com>
Date:   Wed Dec 21 17:30:16 2016 -0800

    ipvlan: fix multicast processing
    
    In an IPvlan setup when master is set in loopback mode e.g.
    
      ethtool -K eth0 set loopback on
    
      where eth0 is master device for IPvlan setup.
    
    The failure is caused by the faulty logic that determines if the
    packet is from TX-path vs. RX-path by just looking at the mac-
    addresses on the packet while processing multicast packets.
    
    In the loopback-mode where this crash was happening, the packets
    that are sent out are reflected by the NIC and are processed on
    the RX path, but mac-address check tricks into thinking this
    packet is from TX path and falsely uses dev_forward_skb() to pass
    packets to the slave (virtual) devices.
    
    This patch records the path while queueing packets and eliminates
    logic of looking at mac-addresses for the same decision.
    
    ------------[ cut here ]------------
    kernel BUG at include/linux/skbuff.h:1737!
    Call Trace:
     [<ffffffff921fbbc2>] dev_forward_skb+0x92/0xd0
     [<ffffffffc031ac65>] ipvlan_process_multicast+0x395/0x4c0 [ipvlan]
     [<ffffffffc031a9a7>] ? ipvlan_process_multicast+0xd7/0x4c0 [ipvlan]
     [<ffffffff91cdfea7>] ? process_one_work+0x147/0x660
     [<ffffffff91cdff09>] process_one_work+0x1a9/0x660
     [<ffffffff91cdfea7>] ? process_one_work+0x147/0x660
     [<ffffffff91ce086d>] worker_thread+0x11d/0x360
     [<ffffffff91ce0750>] ? rescuer_thread+0x350/0x350
     [<ffffffff91ce960b>] kthread+0xdb/0xe0
     [<ffffffff91c05c70>] ? _raw_spin_unlock_irq+0x30/0x50
     [<ffffffff91ce9530>] ? flush_kthread_worker+0xc0/0xc0
     [<ffffffff92348b7a>] ret_from_fork+0x9a/0xd0
     [<ffffffff91ce9530>] ? flush_kthread_worker+0xc0/0xc0
    
    Fixes: ba35f8588f47 ("ipvlan: Defer multicast / broadcast processing to a work-queue")
    Signed-off-by: Mahesh Bandewar <maheshb@google.com>
    CC: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h
index 031093e1c25f..dbfbb33ac66c 100644
--- a/drivers/net/ipvlan/ipvlan.h
+++ b/drivers/net/ipvlan/ipvlan.h
@@ -99,6 +99,11 @@ struct ipvl_port {
 	int			count;
 };
 
+struct ipvl_skb_cb {
+	bool tx_pkt;
+};
+#define IPVL_SKB_CB(_skb) ((struct ipvl_skb_cb *)&((_skb)->cb[0]))
+
 static inline struct ipvl_port *ipvlan_port_get_rcu(const struct net_device *d)
 {
 	return rcu_dereference(d->rx_handler_data);

commit 48140a210b450db229cc9dd927480f65537dc7eb
Author: Gao Feng <fgao@ikuai8.com>
Date:   Wed Dec 7 08:44:47 2016 +0800

    driver: ipvlan: Free ipvl_port directly with kfree instead of kfree_rcu
    
    There are two functions which would free the ipvl_port now. The first
    is ipvlan_port_create. It frees the ipvl_port in the error handler,
    so it could kfree it directly. The second is ipvlan_port_destroy. It
    invokes netdev_rx_handler_unregister which enforces one grace period
    by synchronize_net firstly, so it also could kfree the ipvl_port
    directly and safely.
    
    So it is unnecessary to use kfree_rcu to free ipvl_port.
    
    Signed-off-by: Gao Feng <fgao@ikuai8.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h
index 05a62d2216c5..031093e1c25f 100644
--- a/drivers/net/ipvlan/ipvlan.h
+++ b/drivers/net/ipvlan/ipvlan.h
@@ -97,7 +97,6 @@ struct ipvl_port {
 	struct work_struct	wq;
 	struct sk_buff_head	backlog;
 	int			count;
-	struct rcu_head		rcu;
 };
 
 static inline struct ipvl_port *ipvlan_port_get_rcu(const struct net_device *d)

commit 8f679ed88f8860206edddff725e2749b4cdbb0e8
Author: Gao Feng <fgao@ikuai8.com>
Date:   Wed Nov 30 08:48:44 2016 +0800

    driver: ipvlan: Remove useless member mtu_adj of struct ipvl_dev
    
    The mtu_adj is initialized to zero when alloc mem, there is no any
    assignment to mtu_adj. It is only used in ipvlan_adjust_mtu as one
    right value.
    So it is useless member of struct ipvl_dev, then remove it.
    
    Signed-off-by: Gao Feng <fgao@ikuai8.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h
index 7e0732f5ea07..05a62d2216c5 100644
--- a/drivers/net/ipvlan/ipvlan.h
+++ b/drivers/net/ipvlan/ipvlan.h
@@ -73,7 +73,6 @@ struct ipvl_dev {
 	DECLARE_BITMAP(mac_filters, IPVLAN_MAC_FILTER_SIZE);
 	netdev_features_t	sfeatures;
 	u32			msg_enable;
-	u16			mtu_adj;
 };
 
 struct ipvl_addr {

commit 4fbae7d83c98c30efcf0a2a2ac55fbb75ef5a1a5
Author: Mahesh Bandewar <maheshb@google.com>
Date:   Fri Sep 16 12:59:19 2016 -0700

    ipvlan: Introduce l3s mode
    
    In a typical IPvlan L3 setup where master is in default-ns and
    each slave is into different (slave) ns. In this setup egress
    packet processing for traffic originating from slave-ns will
    hit all NF_HOOKs in slave-ns as well as default-ns. However same
    is not true for ingress processing. All these NF_HOOKs are
    hit only in the slave-ns skipping them in the default-ns.
    IPvlan in L3 mode is restrictive and if admins want to deploy
    iptables rules in default-ns, this asymmetric data path makes it
    impossible to do so.
    
    This patch makes use of the l3_rcv() (added as part of l3mdev
    enhancements) to perform input route lookup on RX packets without
    changing the skb->dev and then uses nf_hook at NF_INET_LOCAL_IN
    to change the skb->dev just before handing over skb to L4.
    
    Signed-off-by: Mahesh Bandewar <maheshb@google.com>
    CC: David Ahern <dsa@cumulusnetworks.com>
    Reviewed-by: David Ahern <dsa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h
index 695a5dc9ace3..7e0732f5ea07 100644
--- a/drivers/net/ipvlan/ipvlan.h
+++ b/drivers/net/ipvlan/ipvlan.h
@@ -23,11 +23,13 @@
 #include <linux/if_vlan.h>
 #include <linux/ip.h>
 #include <linux/inetdevice.h>
+#include <linux/netfilter.h>
 #include <net/ip.h>
 #include <net/ip6_route.h>
 #include <net/rtnetlink.h>
 #include <net/route.h>
 #include <net/addrconf.h>
+#include <net/l3mdev.h>
 
 #define IPVLAN_DRV	"ipvlan"
 #define IPV_DRV_VER	"0.1"
@@ -124,4 +126,8 @@ struct ipvl_addr *ipvlan_find_addr(const struct ipvl_dev *ipvlan,
 				   const void *iaddr, bool is_v6);
 bool ipvlan_addr_busy(struct ipvl_port *port, void *iaddr, bool is_v6);
 void ipvlan_ht_addr_del(struct ipvl_addr *addr);
+struct sk_buff *ipvlan_l3_rcv(struct net_device *dev, struct sk_buff *skb,
+			      u16 proto);
+unsigned int ipvlan_nf_input(void *priv, struct sk_buff *skb,
+			     const struct nf_hook_state *state);
 #endif /* __IPVLAN_H */

commit ab5b7013db3cc637a8f19e00d71310e40db75bf6
Author: Mahesh Bandewar <maheshb@google.com>
Date:   Sat Feb 20 19:31:41 2016 -0800

    ipvlan: misc changes
    
    1. scope correction for few functions that are used in single file.
    2. Adjust variables that are used in fast-path to fit into single cacheline
    3. Update rcv_frame() to skip shared check for frames coming over wire
    
    Signed-off-by: Mahesh Bandewar <maheshb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h
index 817cab1a7959..695a5dc9ace3 100644
--- a/drivers/net/ipvlan/ipvlan.h
+++ b/drivers/net/ipvlan/ipvlan.h
@@ -84,19 +84,19 @@ struct ipvl_addr {
 #define ip4addr ipu.ip4
 	struct hlist_node	hlnode;  /* Hash-table linkage */
 	struct list_head	anode;   /* logical-interface linkage */
-	struct rcu_head		rcu;
 	ipvl_hdr_type		atype;
+	struct rcu_head		rcu;
 };
 
 struct ipvl_port {
 	struct net_device	*dev;
 	struct hlist_head	hlhead[IPVLAN_HASH_SIZE];
 	struct list_head	ipvlans;
-	struct rcu_head		rcu;
+	u16			mode;
 	struct work_struct	wq;
 	struct sk_buff_head	backlog;
 	int			count;
-	u16			mode;
+	struct rcu_head		rcu;
 };
 
 static inline struct ipvl_port *ipvlan_port_get_rcu(const struct net_device *d)
@@ -114,7 +114,6 @@ static inline struct ipvl_port *ipvlan_port_get_rtnl(const struct net_device *d)
 	return rtnl_dereference(d->rx_handler_data);
 }
 
-void ipvlan_adjust_mtu(struct ipvl_dev *ipvlan, struct net_device *dev);
 void ipvlan_init_secret(void);
 unsigned int ipvlan_mac_hash(const unsigned char *addr);
 rx_handler_result_t ipvlan_handle_frame(struct sk_buff **pskb);
@@ -124,7 +123,5 @@ void ipvlan_ht_addr_add(struct ipvl_dev *ipvlan, struct ipvl_addr *addr);
 struct ipvl_addr *ipvlan_find_addr(const struct ipvl_dev *ipvlan,
 				   const void *iaddr, bool is_v6);
 bool ipvlan_addr_busy(struct ipvl_port *port, void *iaddr, bool is_v6);
-struct ipvl_addr *ipvlan_ht_addr_lookup(const struct ipvl_port *port,
-					const void *iaddr, bool is_v6);
 void ipvlan_ht_addr_del(struct ipvl_addr *addr);
 #endif /* __IPVLAN_H */

commit e93fbc5a15ff25d4f9fd92a13c33cd37d99a2340
Author: Mahesh Bandewar <maheshb@google.com>
Date:   Sat Feb 20 19:31:36 2016 -0800

    ipvlan: mode is u16
    
    The mode argument was erronusly defined as u32 but it has always
    been u16. Also use ipvlan_set_mode() helper to set the mode instead
    of assigning directly. This should avoid future erronus assignments /
    updates.
    
    Signed-off-by: Mahesh Bandewar <maheshb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h
index 9542b7bac61a..817cab1a7959 100644
--- a/drivers/net/ipvlan/ipvlan.h
+++ b/drivers/net/ipvlan/ipvlan.h
@@ -115,7 +115,6 @@ static inline struct ipvl_port *ipvlan_port_get_rtnl(const struct net_device *d)
 }
 
 void ipvlan_adjust_mtu(struct ipvl_dev *ipvlan, struct net_device *dev);
-void ipvlan_set_port_mode(struct ipvl_port *port, u32 nval);
 void ipvlan_init_secret(void);
 unsigned int ipvlan_mac_hash(const unsigned char *addr);
 rx_handler_result_t ipvlan_handle_frame(struct sk_buff **pskb);

commit 0fba37a3af03a7e74bf9e75473729adb98da49c3
Author: WANG Cong <xiyou.wangcong@gmail.com>
Date:   Tue Jul 14 16:35:54 2015 +0300

    ipvlan: use rcu_deference_bh() in ipvlan_queue_xmit()
    
    In tx path rcu_read_lock_bh() is held, so we need rcu_deference_bh().
    This fixes the following warning:
    
     ===============================
     [ INFO: suspicious RCU usage. ]
     4.1.0-rc1+ #1007 Not tainted
     -------------------------------
     drivers/net/ipvlan/ipvlan.h:106 suspicious rcu_dereference_check() usage!
    
     other info that might help us debug this:
    
     rcu_scheduler_active = 1, debug_locks = 0
     1 lock held by dhclient/1076:
      #0:  (rcu_read_lock_bh){......}, at: [<ffffffff817e8d84>] rcu_lock_acquire+0x0/0x26
    
     stack backtrace:
     CPU: 2 PID: 1076 Comm: dhclient Not tainted 4.1.0-rc1+ #1007
     Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011
      0000000000000001 ffff8800d381bac8 ffffffff81a4154f 000000003c1a3c19
      ffff8800d4d0a690 ffff8800d381baf8 ffffffff810b849f ffff880117d41148
      ffff880117d40000 ffff880117d40068 0000000000000156 ffff8800d381bb18
     Call Trace:
      [<ffffffff81a4154f>] dump_stack+0x4c/0x65
      [<ffffffff810b849f>] lockdep_rcu_suspicious+0x107/0x110
      [<ffffffff8165a522>] ipvlan_port_get_rcu+0x47/0x4e
      [<ffffffff8165ad14>] ipvlan_queue_xmit+0x35/0x450
      [<ffffffff817ea45d>] ? rcu_read_unlock+0x3e/0x5f
      [<ffffffff810a20bf>] ? local_clock+0x19/0x22
      [<ffffffff810b4781>] ? __lock_is_held+0x39/0x52
      [<ffffffff8165b64c>] ipvlan_start_xmit+0x1b/0x44
      [<ffffffff817edf7f>] dev_hard_start_xmit+0x2ae/0x467
      [<ffffffff817ee642>] __dev_queue_xmit+0x50a/0x60c
      [<ffffffff817ee7a7>] dev_queue_xmit_sk+0x13/0x15
      [<ffffffff81997596>] dev_queue_xmit+0x10/0x12
      [<ffffffff8199b41c>] packet_sendmsg+0xb6b/0xbdf
      [<ffffffff810b5ea7>] ? mark_lock+0x2e/0x226
      [<ffffffff810a1fcc>] ? sched_clock_cpu+0x9e/0xb7
      [<ffffffff817d56f9>] sock_sendmsg_nosec+0x12/0x1d
      [<ffffffff817d7257>] sock_sendmsg+0x29/0x2e
      [<ffffffff817d72cc>] sock_write_iter+0x70/0x91
      [<ffffffff81199563>] __vfs_write+0x7e/0xa7
      [<ffffffff811996bc>] vfs_write+0x92/0xe8
      [<ffffffff811997d7>] SyS_write+0x47/0x7e
      [<ffffffff81a4d517>] system_call_fastpath+0x12/0x6f
    
    Fixes: 2ad7bf363841 ("ipvlan: Initial check-in of the IPVLAN driver.")
    Cc: Mahesh Bandewar <maheshb@google.com>
    Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
    Acked-by: Mahesh Bandewar <maheshb@google.com>
    Acked-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h
index 40f9d7e4a0ea..9542b7bac61a 100644
--- a/drivers/net/ipvlan/ipvlan.h
+++ b/drivers/net/ipvlan/ipvlan.h
@@ -104,6 +104,11 @@ static inline struct ipvl_port *ipvlan_port_get_rcu(const struct net_device *d)
 	return rcu_dereference(d->rx_handler_data);
 }
 
+static inline struct ipvl_port *ipvlan_port_get_rcu_bh(const struct net_device *d)
+{
+	return rcu_dereference_bh(d->rx_handler_data);
+}
+
 static inline struct ipvl_port *ipvlan_port_get_rtnl(const struct net_device *d)
 {
 	return rtnl_dereference(d->rx_handler_data);

commit 6640e673c6f3dbaace085ca2686a8a343dc23a71
Author: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
Date:   Tue Jul 14 16:35:53 2015 +0300

    ipvlan: unhash addresses without synchronize_rcu
    
    All structures used in traffic forwarding are rcu-protected:
    ipvl_addr, ipvl_dev and ipvl_port. Thus we can unhash addresses
    without synchronization. We'll anyway hash it back into the same
    bucket: in worst case lockless lookup will scan hash once again.
    
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h
index 68e2549c28c6..40f9d7e4a0ea 100644
--- a/drivers/net/ipvlan/ipvlan.h
+++ b/drivers/net/ipvlan/ipvlan.h
@@ -122,5 +122,5 @@ struct ipvl_addr *ipvlan_find_addr(const struct ipvl_dev *ipvlan,
 bool ipvlan_addr_busy(struct ipvl_port *port, void *iaddr, bool is_v6);
 struct ipvl_addr *ipvlan_ht_addr_lookup(const struct ipvl_port *port,
 					const void *iaddr, bool is_v6);
-void ipvlan_ht_addr_del(struct ipvl_addr *addr, bool sync);
+void ipvlan_ht_addr_del(struct ipvl_addr *addr);
 #endif /* __IPVLAN_H */

commit 515866f8185b92fb18a782408c53839f003c7669
Author: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
Date:   Tue Jul 14 16:35:50 2015 +0300

    ipvlan: remove counters of ipv4 and ipv6 addresses
    
    They are unused after commit f631c44bbe15 ("ipvlan: Always set broadcast bit in
    multicast filter").
    
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h
index 953a97492fab..68e2549c28c6 100644
--- a/drivers/net/ipvlan/ipvlan.h
+++ b/drivers/net/ipvlan/ipvlan.h
@@ -67,8 +67,6 @@ struct ipvl_dev {
 	struct ipvl_port	*port;
 	struct net_device	*phy_dev;
 	struct list_head	addrs;
-	int			ipv4cnt;
-	int			ipv6cnt;
 	struct ipvl_pcpu_stats	__percpu *pcpu_stats;
 	DECLARE_BITMAP(mac_filters, IPVLAN_MAC_FILTER_SIZE);
 	netdev_features_t	sfeatures;

commit ba35f8588f474d5bf8988615b04ee722a2684fd2
Author: Mahesh Bandewar <maheshb@google.com>
Date:   Mon May 4 17:06:03 2015 -0700

    ipvlan: Defer multicast / broadcast processing to a work-queue
    
    Processing multicast / broadcast in fast path is performance draining
    and having more links means more cloning and bringing performance
    down further.
    
    Broadcast; in particular, need to be given to all the virtual links.
    Earlier tricks of enabling broadcast bit for IPv4 only interfaces are not
    really working since it fails autoconf. Which means enabling broadcast
    for all the links if protocol specific hacks do not have to be added into
    the driver.
    
    This patch defers all (incoming as well as outgoing) multicast traffic to
    a work-queue leaving only the unicast traffic in the fast-path. Now if we
    need to apply any additional tricks to further reduce the impact of this
    (multicast / broadcast) type of traffic, it can be implemented while
    processing this work without affecting the fast-path.
    
    Signed-off-by: Mahesh Bandewar <maheshb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h
index 54549a6223dd..953a97492fab 100644
--- a/drivers/net/ipvlan/ipvlan.h
+++ b/drivers/net/ipvlan/ipvlan.h
@@ -39,6 +39,8 @@
 #define IPVLAN_MAC_FILTER_SIZE	(1 << IPVLAN_MAC_FILTER_BITS)
 #define IPVLAN_MAC_FILTER_MASK	(IPVLAN_MAC_FILTER_SIZE - 1)
 
+#define IPVLAN_QBACKLOG_LIMIT	1000
+
 typedef enum {
 	IPVL_IPV6 = 0,
 	IPVL_ICMPV6,
@@ -93,6 +95,8 @@ struct ipvl_port {
 	struct hlist_head	hlhead[IPVLAN_HASH_SIZE];
 	struct list_head	ipvlans;
 	struct rcu_head		rcu;
+	struct work_struct	wq;
+	struct sk_buff_head	backlog;
 	int			count;
 	u16			mode;
 };
@@ -112,6 +116,7 @@ void ipvlan_set_port_mode(struct ipvl_port *port, u32 nval);
 void ipvlan_init_secret(void);
 unsigned int ipvlan_mac_hash(const unsigned char *addr);
 rx_handler_result_t ipvlan_handle_frame(struct sk_buff **pskb);
+void ipvlan_process_multicast(struct work_struct *work);
 int ipvlan_queue_xmit(struct sk_buff *skb, struct net_device *dev);
 void ipvlan_ht_addr_add(struct ipvl_dev *ipvlan, struct ipvl_addr *addr);
 struct ipvl_addr *ipvlan_find_addr(const struct ipvl_dev *ipvlan,

commit e9997c2938b23d792528da1597b3aea9b0f2a324
Author: Jiri Benc <jbenc@redhat.com>
Date:   Sat Mar 28 19:13:25 2015 +0100

    ipvlan: fix check for IP addresses in control path
    
    When an ipvlan interface is down, its addresses are not on the hash list.
    Fix checks for existence of addresses not to depend on the hash list, walk
    through all interface addresses instead.
    
    Signed-off-by: Jiri Benc <jbenc@redhat.com>
    Acked-by: Mahesh Bandewar <maheshb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h
index 924ea98bd531..54549a6223dd 100644
--- a/drivers/net/ipvlan/ipvlan.h
+++ b/drivers/net/ipvlan/ipvlan.h
@@ -114,7 +114,9 @@ unsigned int ipvlan_mac_hash(const unsigned char *addr);
 rx_handler_result_t ipvlan_handle_frame(struct sk_buff **pskb);
 int ipvlan_queue_xmit(struct sk_buff *skb, struct net_device *dev);
 void ipvlan_ht_addr_add(struct ipvl_dev *ipvlan, struct ipvl_addr *addr);
-bool ipvlan_addr_busy(struct ipvl_dev *ipvlan, void *iaddr, bool is_v6);
+struct ipvl_addr *ipvlan_find_addr(const struct ipvl_dev *ipvlan,
+				   const void *iaddr, bool is_v6);
+bool ipvlan_addr_busy(struct ipvl_port *port, void *iaddr, bool is_v6);
 struct ipvl_addr *ipvlan_ht_addr_lookup(const struct ipvl_port *port,
 					const void *iaddr, bool is_v6);
 void ipvlan_ht_addr_del(struct ipvl_addr *addr, bool sync);

commit 6aa6395ff320abe242e05766ae201f23e7978a94
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Feb 11 19:51:46 2015 -0800

    ipvlan: add a missing __percpu pcpu_stats
    
    Cosmetic patch to add __percpu qualifier to pcpu_stats
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h
index 2729f64b3e7e..924ea98bd531 100644
--- a/drivers/net/ipvlan/ipvlan.h
+++ b/drivers/net/ipvlan/ipvlan.h
@@ -67,7 +67,7 @@ struct ipvl_dev {
 	struct list_head	addrs;
 	int			ipv4cnt;
 	int			ipv6cnt;
-	struct ipvl_pcpu_stats	*pcpu_stats;
+	struct ipvl_pcpu_stats	__percpu *pcpu_stats;
 	DECLARE_BITMAP(mac_filters, IPVLAN_MAC_FILTER_SIZE);
 	netdev_features_t	sfeatures;
 	u32			msg_enable;

commit 5933fea7aa7237ba52d67c069c39ad5c3ab7a036
Author: Mahesh Bandewar <maheshb@google.com>
Date:   Sat Dec 6 15:53:33 2014 -0800

    ipvlan: move the device check function into netdevice.h
    
    Move the port check [ipvlan_dev_master()] and device check
    [ipvlan_dev_slave()] functions to netdevice.h and rename them
    netif_is_ipvlan_port() and netif_is_ipvlan() resp. to be
    consistent with macvlan api naming.
    
    Signed-off-by: Mahesh Bandewar <maheshb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h
index c44d29eca6c0..2729f64b3e7e 100644
--- a/drivers/net/ipvlan/ipvlan.h
+++ b/drivers/net/ipvlan/ipvlan.h
@@ -107,16 +107,6 @@ static inline struct ipvl_port *ipvlan_port_get_rtnl(const struct net_device *d)
 	return rtnl_dereference(d->rx_handler_data);
 }
 
-static inline bool ipvlan_dev_master(struct net_device *d)
-{
-	return d->priv_flags & IFF_IPVLAN_MASTER;
-}
-
-static inline bool ipvlan_dev_slave(struct net_device *d)
-{
-	return d->priv_flags & IFF_IPVLAN_SLAVE;
-}
-
 void ipvlan_adjust_mtu(struct ipvl_dev *ipvlan, struct net_device *dev);
 void ipvlan_set_port_mode(struct ipvl_port *port, u32 nval);
 void ipvlan_init_secret(void);

commit 265de6d19cdd56745bf2277f0bc81ba5109b8717
Author: Mahesh Bandewar <maheshb@google.com>
Date:   Wed Nov 26 21:13:45 2014 -0800

    ipvlan: ipvlan depends on INET and IPV6
    
    This driver uses ip_out_local() and ip6_route_output() which are
    defined only if CONFIG_INET and CONFIG_IPV6 are enabled respectively.
    
    Reported-by: Jim Davis <jim.epost@gmail.com>
    Signed-off-by: Mahesh Bandewar <maheshb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h
index ab3e7614ed71..c44d29eca6c0 100644
--- a/drivers/net/ipvlan/ipvlan.h
+++ b/drivers/net/ipvlan/ipvlan.h
@@ -23,8 +23,9 @@
 #include <linux/if_vlan.h>
 #include <linux/ip.h>
 #include <linux/inetdevice.h>
+#include <net/ip.h>
+#include <net/ip6_route.h>
 #include <net/rtnetlink.h>
-#include <net/gre.h>
 #include <net/route.h>
 #include <net/addrconf.h>
 

commit 2ad7bf3638411cb547f2823df08166c13ab04269
Author: Mahesh Bandewar <maheshb@google.com>
Date:   Sun Nov 23 23:07:46 2014 -0800

    ipvlan: Initial check-in of the IPVLAN driver.
    
    This driver is very similar to the macvlan driver except that it
    uses L3 on the frame to determine the logical interface while
    functioning as packet dispatcher. It inherits L2 of the master
    device hence the packets on wire will have the same L2 for all
    the packets originating from all virtual devices off of the same
    master device.
    
    This driver was developed keeping the namespace use-case in
    mind. Hence most of the examples given here take that as the
    base setup where main-device belongs to the default-ns and
    virtual devices are assigned to the additional namespaces.
    
    The device operates in two different modes and the difference
    in these two modes in primarily in the TX side.
    
    (a) L2 mode : In this mode, the device behaves as a L2 device.
    TX processing upto L2 happens on the stack of the virtual device
    associated with (namespace). Packets are switched after that
    into the main device (default-ns) and queued for xmit.
    
    RX processing is simple and all multicast, broadcast (if
    applicable), and unicast belonging to the address(es) are
    delivered to the virtual devices.
    
    (b) L3 mode : In this mode, the device behaves like a L3 device.
    TX processing upto L3 happens on the stack of the virtual device
    associated with (namespace). Packets are switched to the
    main-device (default-ns) for the L2 processing. Hence the routing
    table of the default-ns will be used in this mode.
    
    RX processins is somewhat similar to the L2 mode except that in
    this mode only Unicast packets are delivered to the virtual device
    while main-dev will handle all other packets.
    
    The devices can be added using the "ip" command from the iproute2
    package -
    
            ip link add link <master> <virtual> type ipvlan mode [ l2 | l3 ]
    
    Signed-off-by: Mahesh Bandewar <maheshb@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Maciej Żenczykowski <maze@google.com>
    Cc: Laurent Chavey <chavey@google.com>
    Cc: Tim Hockin <thockin@google.com>
    Cc: Brandon Philips <brandon.philips@coreos.com>
    Cc: Pavel Emelianov <xemul@parallels.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h
new file mode 100644
index 000000000000..ab3e7614ed71
--- /dev/null
+++ b/drivers/net/ipvlan/ipvlan.h
@@ -0,0 +1,130 @@
+/*
+ * Copyright (c) 2014 Mahesh Bandewar <maheshb@google.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef __IPVLAN_H
+#define __IPVLAN_H
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/rculist.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/if_arp.h>
+#include <linux/if_link.h>
+#include <linux/if_vlan.h>
+#include <linux/ip.h>
+#include <linux/inetdevice.h>
+#include <net/rtnetlink.h>
+#include <net/gre.h>
+#include <net/route.h>
+#include <net/addrconf.h>
+
+#define IPVLAN_DRV	"ipvlan"
+#define IPV_DRV_VER	"0.1"
+
+#define IPVLAN_HASH_SIZE	(1 << BITS_PER_BYTE)
+#define IPVLAN_HASH_MASK	(IPVLAN_HASH_SIZE - 1)
+
+#define IPVLAN_MAC_FILTER_BITS	8
+#define IPVLAN_MAC_FILTER_SIZE	(1 << IPVLAN_MAC_FILTER_BITS)
+#define IPVLAN_MAC_FILTER_MASK	(IPVLAN_MAC_FILTER_SIZE - 1)
+
+typedef enum {
+	IPVL_IPV6 = 0,
+	IPVL_ICMPV6,
+	IPVL_IPV4,
+	IPVL_ARP,
+} ipvl_hdr_type;
+
+struct ipvl_pcpu_stats {
+	u64			rx_pkts;
+	u64			rx_bytes;
+	u64			rx_mcast;
+	u64			tx_pkts;
+	u64			tx_bytes;
+	struct u64_stats_sync	syncp;
+	u32			rx_errs;
+	u32			tx_drps;
+};
+
+struct ipvl_port;
+
+struct ipvl_dev {
+	struct net_device	*dev;
+	struct list_head	pnode;
+	struct ipvl_port	*port;
+	struct net_device	*phy_dev;
+	struct list_head	addrs;
+	int			ipv4cnt;
+	int			ipv6cnt;
+	struct ipvl_pcpu_stats	*pcpu_stats;
+	DECLARE_BITMAP(mac_filters, IPVLAN_MAC_FILTER_SIZE);
+	netdev_features_t	sfeatures;
+	u32			msg_enable;
+	u16			mtu_adj;
+};
+
+struct ipvl_addr {
+	struct ipvl_dev		*master; /* Back pointer to master */
+	union {
+		struct in6_addr	ip6;	 /* IPv6 address on logical interface */
+		struct in_addr	ip4;	 /* IPv4 address on logical interface */
+	} ipu;
+#define ip6addr	ipu.ip6
+#define ip4addr ipu.ip4
+	struct hlist_node	hlnode;  /* Hash-table linkage */
+	struct list_head	anode;   /* logical-interface linkage */
+	struct rcu_head		rcu;
+	ipvl_hdr_type		atype;
+};
+
+struct ipvl_port {
+	struct net_device	*dev;
+	struct hlist_head	hlhead[IPVLAN_HASH_SIZE];
+	struct list_head	ipvlans;
+	struct rcu_head		rcu;
+	int			count;
+	u16			mode;
+};
+
+static inline struct ipvl_port *ipvlan_port_get_rcu(const struct net_device *d)
+{
+	return rcu_dereference(d->rx_handler_data);
+}
+
+static inline struct ipvl_port *ipvlan_port_get_rtnl(const struct net_device *d)
+{
+	return rtnl_dereference(d->rx_handler_data);
+}
+
+static inline bool ipvlan_dev_master(struct net_device *d)
+{
+	return d->priv_flags & IFF_IPVLAN_MASTER;
+}
+
+static inline bool ipvlan_dev_slave(struct net_device *d)
+{
+	return d->priv_flags & IFF_IPVLAN_SLAVE;
+}
+
+void ipvlan_adjust_mtu(struct ipvl_dev *ipvlan, struct net_device *dev);
+void ipvlan_set_port_mode(struct ipvl_port *port, u32 nval);
+void ipvlan_init_secret(void);
+unsigned int ipvlan_mac_hash(const unsigned char *addr);
+rx_handler_result_t ipvlan_handle_frame(struct sk_buff **pskb);
+int ipvlan_queue_xmit(struct sk_buff *skb, struct net_device *dev);
+void ipvlan_ht_addr_add(struct ipvl_dev *ipvlan, struct ipvl_addr *addr);
+bool ipvlan_addr_busy(struct ipvl_dev *ipvlan, void *iaddr, bool is_v6);
+struct ipvl_addr *ipvlan_ht_addr_lookup(const struct ipvl_port *port,
+					const void *iaddr, bool is_v6);
+void ipvlan_ht_addr_del(struct ipvl_addr *addr, bool sync);
+#endif /* __IPVLAN_H */
