commit 6a24c8fb0d889b39079215970210f88255b81c80
Author: Fuqian Huang <huangfq.daxian@gmail.com>
Date:   Mon Jul 15 11:19:21 2019 +0800

    hippi: Remove call to memset after pci_alloc_consistent
    
    pci_alloc_consistent calls dma_alloc_coherent directly.
    In commit 518a2f1925c3
    ("dma-mapping: zero memory returned from dma_alloc_*"),
    dma_alloc_coherent has already zeroed the memory.
    So memset is not needed.
    
    Signed-off-by: Fuqian Huang <huangfq.daxian@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index 7b9350dbebdd..2a6ec5394966 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -1196,7 +1196,6 @@ static int rr_open(struct net_device *dev)
 		goto error;
 	}
 	rrpriv->rx_ctrl_dma = dma_addr;
-	memset(rrpriv->rx_ctrl, 0, 256*sizeof(struct ring_ctrl));
 
 	rrpriv->info = pci_alloc_consistent(pdev, sizeof(struct rr_info),
 					    &dma_addr);
@@ -1205,7 +1204,6 @@ static int rr_open(struct net_device *dev)
 		goto error;
 	}
 	rrpriv->info_dma = dma_addr;
-	memset(rrpriv->info, 0, sizeof(struct rr_info));
 	wmb();
 
 	spin_lock_irqsave(&rrpriv->lock, flags);

commit bb522f7305d6d91342d20c964dbc60984da89474
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 24 12:03:48 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 128
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify it
      under the terms of the gnu general public license as published by the
      free software foundation either version 2 of the license or at your
      option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Daniel M German <dmg@turingmachine.org>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527063114.385641227@linutronix.de
    Link: https://lkml.kernel.org/r/20190524100843.113522467@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index 0f7025f3a384..7b9350dbebdd 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * rrunner.c: Linux driver for the Essential RoadRunner HIPPI board.
  *
@@ -9,11 +10,6 @@
  * for sorting out the legal issues, with the NDA, allowing the code to
  * be released under the GPL.
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
  * Thanks to Jayaram Bhat from ODS/Essential for fixing some of the
  * stupid bugs in my code.
  *

commit fa8b9e8bea50c226559381b1ea2dee7329031625
Author: Fuqian Huang <huangfq.daxian@gmail.com>
Date:   Sun Apr 21 19:48:26 2019 +0800

    net: hippi:Fix misuse of %x in rrunner.c
    
    The pointer should be printed with %p or %px rather than
    cast to unsigned long type and printed with %08lx.
    Change %08lx to %p to print the pointer.
    
    Signed-off-by: Fuqian Huang <huangfq.daxian@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index 029206e4da3b..0f7025f3a384 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -1298,11 +1298,11 @@ static void rr_dump(struct net_device *dev)
 	if (rrpriv->tx_skbuff[cons]){
 		len = min_t(int, 0x80, rrpriv->tx_skbuff[cons]->len);
 		printk("skbuff for cons %i is valid - dumping data (0x%x bytes - skbuff len 0x%x)\n", cons, len, rrpriv->tx_skbuff[cons]->len);
-		printk("mode 0x%x, size 0x%x,\n phys %08Lx, skbuff-addr %08lx, truesize 0x%x\n",
+		printk("mode 0x%x, size 0x%x,\n phys %08Lx, skbuff-addr %p, truesize 0x%x\n",
 		       rrpriv->tx_ring[cons].mode,
 		       rrpriv->tx_ring[cons].size,
 		       (unsigned long long) rrpriv->tx_ring[cons].addr.addrlo,
-		       (unsigned long)rrpriv->tx_skbuff[cons]->data,
+		       rrpriv->tx_skbuff[cons]->data,
 		       (unsigned int)rrpriv->tx_skbuff[cons]->truesize);
 		for (i = 0; i < len; i++){
 			if (!(i & 7))

commit 6da2ec56059c3c7a7e5f729e6349e74ace1e5c57
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 13:55:00 2018 -0700

    treewide: kmalloc() -> kmalloc_array()
    
    The kmalloc() function has a 2-factor argument form, kmalloc_array(). This
    patch replaces cases of:
    
            kmalloc(a * b, gfp)
    
    with:
            kmalloc_array(a * b, gfp)
    
    as well as handling cases of:
    
            kmalloc(a * b * c, gfp)
    
    with:
    
            kmalloc(array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            kmalloc_array(array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            kmalloc(4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The tools/ directory was manually excluded, since it has its own
    implementation of kmalloc().
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      kmalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      kmalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      kmalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
    - kmalloc
    + kmalloc_array
      (
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      kmalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      kmalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kmalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kmalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      kmalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      kmalloc(C1 * C2 * C3, ...)
    |
      kmalloc(
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kmalloc(
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kmalloc(
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kmalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      kmalloc(sizeof(THING) * C2, ...)
    |
      kmalloc(sizeof(TYPE) * C2, ...)
    |
      kmalloc(C1 * C2 * C3, ...)
    |
      kmalloc(C1 * C2, ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index f41116488079..029206e4da3b 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -1583,7 +1583,7 @@ static int rr_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 			return -EPERM;
 		}
 
-		image = kmalloc(EEPROM_WORDS * sizeof(u32), GFP_KERNEL);
+		image = kmalloc_array(EEPROM_WORDS, sizeof(u32), GFP_KERNEL);
 		if (!image)
 			return -ENOMEM;
 

commit 8f678036f9780c7bf93241f09cf4f269e090ea94
Author: Colin Ian King <colin.king@canonical.com>
Date:   Fri May 18 11:09:22 2018 +0100

    hippi: fix spelling mistake: "Framming" -> "Framing"
    
    Trivial fix to spelling mistake in printk message text
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index 1ab97d99b9ba..f41116488079 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -867,7 +867,7 @@ static u32 rr_handle_event(struct net_device *dev, u32 prodidx, u32 eidx)
 			       dev->name);
 			goto drop;
 		case E_FRM_ERR:
-			printk(KERN_WARNING "%s: Framming Error\n",
+			printk(KERN_WARNING "%s: Framing Error\n",
 			       dev->name);
 			goto drop;
 		case E_FLG_SYN_ERR:

commit 6e266610eb6553cfb7e7eb5d11914bd01509c406
Author: Jia-Ju Bai <baijiaju1990@163.com>
Date:   Tue Dec 12 16:49:52 2017 +0800

    hippi: Fix a Fix a possible sleep-in-atomic bug in rr_close
    
    The driver may sleep under a spinlock.
    The function call path is:
    rr_close (acquire the spinlock)
      free_irq --> may sleep
    
    To fix it, free_irq is moved to the place without holding the spinlock.
    
    This bug is found by my static analysis tool(DSAC) and checked by my code review.
    
    Signed-off-by: Jia-Ju Bai <baijiaju1990@163.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index 8483f03d5a41..1ab97d99b9ba 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -1379,8 +1379,8 @@ static int rr_close(struct net_device *dev)
 			    rrpriv->info_dma);
 	rrpriv->info = NULL;
 
-	free_irq(pdev->irq, dev);
 	spin_unlock_irqrestore(&rrpriv->lock, flags);
+	free_irq(pdev->irq, dev);
 
 	return 0;
 }

commit 0eba23bbcece8f0fe925f302facbae27f086b887
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Oct 25 03:51:29 2017 -0700

    drivers/net: hippi: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Cc: Jes Sorensen <jes@trained-monkey.org>
    Cc: linux-hippi@sunsite.dk
    Cc: netdev@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index 76cc140774a2..8483f03d5a41 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -1146,10 +1146,10 @@ static inline void rr_raz_rx(struct rr_private *rrpriv,
 	}
 }
 
-static void rr_timer(unsigned long data)
+static void rr_timer(struct timer_list *t)
 {
-	struct net_device *dev = (struct net_device *)data;
-	struct rr_private *rrpriv = netdev_priv(dev);
+	struct rr_private *rrpriv = from_timer(rrpriv, t, timer);
+	struct net_device *dev = pci_get_drvdata(rrpriv->pci_dev);
 	struct rr_regs __iomem *regs = rrpriv->regs;
 	unsigned long flags;
 
@@ -1229,7 +1229,7 @@ static int rr_open(struct net_device *dev)
 
 	/* Set the timer to switch to check for link beat and perhaps switch
 	   to an alternate media type. */
-	setup_timer(&rrpriv->timer, rr_timer, (unsigned long)dev);
+	timer_setup(&rrpriv->timer, rr_timer, 0);
 	rrpriv->timer.expires = RUN_AT(5*HZ);           /* 5 sec. watchdog */
 	add_timer(&rrpriv->timer);
 

commit 0625d739cc61d186b65b8619ee8c41da2fd24894
Author: Allen Pais <allen.lkml@gmail.com>
Date:   Thu Sep 21 22:34:49 2017 +0530

    drivers: net: hippi: use setup_timer() helper.
    
    Use setup_timer function instead of initializing timer with the
        function and data fields.
    
    Signed-off-by: Allen Pais <allen.lkml@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index 71ddadbf2368..76cc140774a2 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -1229,10 +1229,8 @@ static int rr_open(struct net_device *dev)
 
 	/* Set the timer to switch to check for link beat and perhaps switch
 	   to an alternate media type. */
-	init_timer(&rrpriv->timer);
+	setup_timer(&rrpriv->timer, rr_timer, (unsigned long)dev);
 	rrpriv->timer.expires = RUN_AT(5*HZ);           /* 5 sec. watchdog */
-	rrpriv->timer.data = (unsigned long)dev;
-	rrpriv->timer.function = rr_timer;               /* timer handler */
 	add_timer(&rrpriv->timer);
 
 	netif_start_queue(dev);

commit d58ff35122847a83ba55394e2ae3a1527b6febf5
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jun 16 14:29:23 2017 +0200

    networking: make skb_push & __skb_push return void pointers
    
    It seems like a historic accident that these return unsigned char *,
    and in many places that means casts are required, more often than not.
    
    Make these functions return void * and remove all the casts across
    the tree, adding a (u8 *) cast only where the unsigned char pointer
    was used directly, all done with the following spatch:
    
        @@
        expression SKB, LEN;
        typedef u8;
        identifier fn = { skb_push, __skb_push, skb_push_rcsum };
        @@
        - *(fn(SKB, LEN))
        + *(u8 *)fn(SKB, LEN)
    
        @@
        expression E, SKB, LEN;
        identifier fn = { skb_push, __skb_push, skb_push_rcsum };
        type T;
        @@
        - E = ((T *)(fn(SKB, LEN)))
        + E = fn(SKB, LEN)
    
        @@
        expression SKB, LEN;
        identifier fn = { skb_push, __skb_push, skb_push_rcsum };
        @@
        - fn(SKB, LEN)[0]
        + *(u8 *)fn(SKB, LEN)
    
    Note that the last part there converts from push(...)[0] to the
    more idiomatic *(u8 *)push(...).
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index 7683fd544344..71ddadbf2368 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -1422,7 +1422,7 @@ static netdev_tx_t rr_start_xmit(struct sk_buff *skb,
 		skb = new_skb;
 	}
 
-	ifield = (u32 *)skb_push(skb, 8);
+	ifield = skb_push(skb, 8);
 
 	ifield[0] = 0;
 	ifield[1] = hcb->ifield;

commit 59ae1d127ac0ae404baf414c434ba2651b793f46
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jun 16 14:29:20 2017 +0200

    networking: introduce and use skb_put_data()
    
    A common pattern with skb_put() is to just want to memcpy()
    some data into the new space, introduce skb_put_data() for
    this.
    
    An spatch similar to the one for skb_put_zero() converts many
    of the places using it:
    
        @@
        identifier p, p2;
        expression len, skb, data;
        type t, t2;
        @@
        (
        -p = skb_put(skb, len);
        +p = skb_put_data(skb, data, len);
        |
        -p = (t)skb_put(skb, len);
        +p = skb_put_data(skb, data, len);
        )
        (
        p2 = (t2)p;
        -memcpy(p2, data, len);
        |
        -memcpy(p, data, len);
        )
    
        @@
        type t, t2;
        identifier p, p2;
        expression skb, data;
        @@
        t *p;
        ...
        (
        -p = skb_put(skb, sizeof(t));
        +p = skb_put_data(skb, data, sizeof(t));
        |
        -p = (t *)skb_put(skb, sizeof(t));
        +p = skb_put_data(skb, data, sizeof(t));
        )
        (
        p2 = (t2)p;
        -memcpy(p2, data, sizeof(*p));
        |
        -memcpy(p, data, sizeof(*p));
        )
    
        @@
        expression skb, len, data;
        @@
        -memcpy(skb_put(skb, len), data, len);
        +skb_put_data(skb, data, len);
    
    (again, manually post-processed to retain some comments)
    
    Reviewed-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index 1ce6239a4849..7683fd544344 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -962,8 +962,8 @@ static void rx_int(struct net_device *dev, u32 rxlimit, u32 index)
 								    pkt_len,
 								    PCI_DMA_FROMDEVICE);
 
-					memcpy(skb_put(skb, pkt_len),
-					       rx_skb->data, pkt_len);
+					skb_put_data(skb, rx_skb->data,
+						     pkt_len);
 
 					pci_dma_sync_single_for_device(rrpriv->pci_dev,
 								       desc->addr.addrlo,

commit 50fb55d88c999b3c17f93357a009b04d22eda4f7
Merge: 4879b7ae0543 657831ffc38e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 9 15:42:31 2017 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Pull networking fixes from David Miller:
    
     1) Fix multiqueue in stmmac driver on PCI, from Andy Shevchenko.
    
     2) cdc_ncm doesn't actually fully zero out the padding area is
        allocates on TX, from Jim Baxter.
    
     3) Don't leak map addresses in BPF verifier, from Daniel Borkmann.
    
     4) If we randomize TCP timestamps, we have to do it everywhere
        including SYN cookies. From Eric Dumazet.
    
     5) Fix "ethtool -S" crash in aquantia driver, from Pavel Belous.
    
     6) Fix allocation size for ntp filter bitmap in bnxt_en driver, from
        Dan Carpenter.
    
     7) Add missing memory allocation return value check to DSA loop driver,
        from Christophe Jaillet.
    
     8) Fix XDP leak on driver unload in qed driver, from Suddarsana Reddy
        Kalluru.
    
     9) Don't inherit MC list from parent inet connection sockets, another
        syzkaller spotted gem. Fix from Eric Dumazet.
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net: (43 commits)
      dccp/tcp: do not inherit mc_list from parent
      qede: Split PF/VF ndos.
      qed: Correct doorbell configuration for !4Kb pages
      qed: Tell QM the number of tasks
      qed: Fix VF removal sequence
      qede: Fix XDP memory leak on unload
      net/mlx4_core: Reduce harmless SRIOV error message to debug level
      net/mlx4_en: Avoid adding steering rules with invalid ring
      net/mlx4_en: Change the error print to debug print
      drivers: net: wimax: i2400m: i2400m-usb: Use time_after for time comparison
      DECnet: Use container_of() for embedded struct
      Revert "ipv4: restore rt->fi for reference counting"
      net: mdio-mux: bcm-iproc: call mdiobus_free() in error path
      net: ethernet: ti: cpsw: adjust cpsw fifos depth for fullduplex flow control
      ipv6: reorder ip6_route_dev_notifier after ipv6_dev_notf
      net: cdc_ncm: Fix TX zero padding
      stmmac: pci: split out common_default_data() helper
      stmmac: pci: RX queue routing configuration
      stmmac: pci: TX and RX queue priority configuration
      stmmac: pci: set default number of rx and tx queues
      ...

commit 063246641d4a9e9de84a2466fbad50112faf88dc
Author: Kees Cook <keescook@chromium.org>
Date:   Mon May 8 15:59:05 2017 -0700

    format-security: move static strings to const
    
    While examining output from trial builds with -Wformat-security enabled,
    many strings were found that should be defined as "const", or as a char
    array instead of char pointer.  This makes some static analysis easier,
    by producing fewer false positives.
    
    As these are all trivial changes, it seemed best to put them all in a
    single patch rather than chopping them up per maintainer.
    
    Link: http://lkml.kernel.org/r/20170405214711.GA5711@beast
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Jes Sorensen <jes@trained-monkey.org> [runner.c]
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: "Maciej W. Rozycki" <macro@linux-mips.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Yisen Zhuang <yisen.zhuang@huawei.com>
    Cc: Salil Mehta <salil.mehta@huawei.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Patrice Chotard <patrice.chotard@st.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: Matt Redfearn <matt.redfearn@imgtec.com>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: Mugunthan V N <mugunthanvnm@ti.com>
    Cc: Felipe Balbi <felipe.balbi@linux.intel.com>
    Cc: Jarod Wilson <jarod@redhat.com>
    Cc: Florian Westphal <fw@strlen.de>
    Cc: Antonio Quartulli <a@unstable.cc>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Kejian Yan <yankejian@huawei.com>
    Cc: Daode Huang <huangdaode@hisilicon.com>
    Cc: Qianqian Xie <xieqianqian@huawei.com>
    Cc: Philippe Reynes <tremyfr@gmail.com>
    Cc: Colin Ian King <colin.king@canonical.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Christian Gromm <christian.gromm@microchip.com>
    Cc: Andrey Shvetsov <andrey.shvetsov@k2l.de>
    Cc: Jason Litzinger <jlitzingerdev@gmail.com>
    Cc: WANG Cong <xiyou.wangcong@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index dd7fc6659ad4..9b0d6148e994 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -60,7 +60,8 @@ MODULE_AUTHOR("Jes Sorensen <jes@wildopensource.com>");
 MODULE_DESCRIPTION("Essential RoadRunner HIPPI driver");
 MODULE_LICENSE("GPL");
 
-static char version[] = "rrunner.c: v0.50 11/11/2002  Jes Sorensen (jes@wildopensource.com)\n";
+static const char version[] =
+"rrunner.c: v0.50 11/11/2002  Jes Sorensen (jes@wildopensource.com)\n";
 
 
 static const struct net_device_ops rr_netdev_ops = {

commit 294316a4af16cd5c355a80bd2dc7ea803b88f6ba
Author: Geliang Tang <geliangtang@gmail.com>
Date:   Sat May 6 23:42:16 2017 +0800

    net/hippi/rrunner: use memdup_user
    
    Use memdup_user() helper instead of open-coding to simplify the code.
    
    Signed-off-by: Geliang Tang <geliangtang@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index dd7fc6659ad4..365c4d987a01 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -1615,17 +1615,14 @@ static int rr_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 			return -EPERM;
 		}
 
-		image = kmalloc(EEPROM_WORDS * sizeof(u32), GFP_KERNEL);
-		oldimage = kmalloc(EEPROM_WORDS * sizeof(u32), GFP_KERNEL);
-		if (!image || !oldimage) {
-			error = -ENOMEM;
-			goto wf_out;
-		}
+		image = memdup_user(rq->ifr_data, EEPROM_BYTES);
+		if (IS_ERR(image))
+			return PTR_ERR(image);
 
-		error = copy_from_user(image, rq->ifr_data, EEPROM_BYTES);
-		if (error) {
-			error = -EFAULT;
-			goto wf_out;
+		oldimage = kmalloc(EEPROM_BYTES, GFP_KERNEL);
+		if (!oldimage) {
+			kfree(image);
+			return -ENOMEM;
 		}
 
 		if (rrpriv->fw_running){

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index f5a9728b89f3..dd7fc6659ad4 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -46,7 +46,7 @@
 #include <asm/byteorder.h>
 #include <asm/io.h>
 #include <asm/irq.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 
 #define rr_if_busy(dev)     netif_queue_stopped(dev)
 #define rr_if_running(dev)  netif_running(dev)

commit b3e3893e1253692c3d2b8e8ebd5a26183ed30443
Author: Jarod Wilson <jarod@redhat.com>
Date:   Thu Oct 20 13:55:22 2016 -0400

    net: use core MTU range checking in misc drivers
    
    firewire-net:
    - set min/max_mtu
    - remove fwnet_change_mtu
    
    nes:
    - set max_mtu
    - clean up nes_netdev_change_mtu
    
    xpnet:
    - set min/max_mtu
    - remove xpnet_dev_change_mtu
    
    hippi:
    - set min/max_mtu
    - remove hippi_change_mtu
    
    batman-adv:
    - set max_mtu
    - remove batadv_interface_change_mtu
    - initialization is a little async, not 100% certain that max_mtu is set
      in the optimal place, don't have hardware to test with
    
    rionet:
    - set min/max_mtu
    - remove rionet_change_mtu
    
    slip:
    - set min/max_mtu
    - streamline sl_change_mtu
    
    um/net_kern:
    - remove pointless ndo_change_mtu
    
    hsi/clients/ssi_protocol:
    - use core MTU range checking
    - remove now redundant ssip_pn_set_mtu
    
    ipoib:
    - set a default max MTU value
    - Note: ipoib's actual max MTU can vary, depending on if the device is in
      connected mode or not, so we'll just set the max_mtu value to the max
      possible, and let the ndo_change_mtu function continue to validate any new
      MTU change requests with checks for CM or not. Note that ipoib has no
      min_mtu set, and thus, the network core's mtu > 0 check is the only lower
      bounds here.
    
    mptlan:
    - use net core MTU range checking
    - remove now redundant mpt_lan_change_mtu
    
    fddi:
    - min_mtu = 21, max_mtu = 4470
    - remove now redundant fddi_change_mtu (including export)
    
    fjes:
    - min_mtu = 8192, max_mtu = 65536
    - The max_mtu value is actually one over IP_MAX_MTU here, but the idea is to
      get past the core net MTU range checks so fjes_change_mtu can validate a
      new MTU against what it supports (see fjes_support_mtu in fjes_hw.c)
    
    hsr:
    - min_mtu = 0 (calls ether_setup, max_mtu is 1500)
    
    f_phonet:
    - min_mtu = 6, max_mtu = 65541
    
    u_ether:
    - min_mtu = 14, max_mtu = 15412
    
    phonet/pep-gprs:
    - min_mtu = 576, max_mtu = 65530
    - remove redundant gprs_set_mtu
    
    CC: netdev@vger.kernel.org
    CC: linux-rdma@vger.kernel.org
    CC: Stefan Richter <stefanr@s5r6.in-berlin.de>
    CC: Faisal Latif <faisal.latif@intel.com>
    CC: linux-rdma@vger.kernel.org
    CC: Cliff Whickman <cpw@sgi.com>
    CC: Robin Holt <robinmholt@gmail.com>
    CC: Jes Sorensen <jes@trained-monkey.org>
    CC: Marek Lindner <mareklindner@neomailbox.ch>
    CC: Simon Wunderlich <sw@simonwunderlich.de>
    CC: Antonio Quartulli <a@unstable.cc>
    CC: Sathya Prakash <sathya.prakash@broadcom.com>
    CC: Chaitra P B <chaitra.basappa@broadcom.com>
    CC: Suganath Prabu Subramani <suganath-prabu.subramani@broadcom.com>
    CC: MPT-FusionLinux.pdl@broadcom.com
    CC: Sebastian Reichel <sre@kernel.org>
    CC: Felipe Balbi <balbi@kernel.org>
    CC: Arvid Brodin <arvid.brodin@alten.se>
    CC: Remi Denis-Courmont <courmisch@gmail.com>
    Signed-off-by: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index 95c0b45a68fb..f5a9728b89f3 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -68,7 +68,6 @@ static const struct net_device_ops rr_netdev_ops = {
 	.ndo_stop		= rr_close,
 	.ndo_do_ioctl		= rr_ioctl,
 	.ndo_start_xmit		= rr_start_xmit,
-	.ndo_change_mtu		= hippi_change_mtu,
 	.ndo_set_mac_address	= hippi_mac_addr,
 };
 

commit 9baa3c34ac4e27f7e062f266f50cc5dbea26a6c1
Author: Benoit Taine <benoit.taine@lip6.fr>
Date:   Fri Aug 8 15:56:03 2014 +0200

    PCI: Remove DEFINE_PCI_DEVICE_TABLE macro use
    
    We should prefer `struct pci_device_id` over `DEFINE_PCI_DEVICE_TABLE` to
    meet kernel coding style guidelines.  This issue was reported by checkpatch.
    
    A simplified version of the semantic patch that makes this change is as
    follows (http://coccinelle.lip6.fr/):
    
    // <smpl>
    
    @@
    identifier i;
    declarer name DEFINE_PCI_DEVICE_TABLE;
    initializer z;
    @@
    
    - DEFINE_PCI_DEVICE_TABLE(i)
    + const struct pci_device_id i[]
    = z;
    
    // </smpl>
    
    [bhelgaas: add semantic patch]
    Signed-off-by: Benoit Taine <benoit.taine@lip6.fr>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index e580583f196d..95c0b45a68fb 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -1668,7 +1668,7 @@ static int rr_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 	}
 }
 
-static DEFINE_PCI_DEVICE_TABLE(rr_pci_tbl) = {
+static const struct pci_device_id rr_pci_tbl[] = {
 	{ PCI_VENDOR_ID_ESSENTIAL, PCI_DEVICE_ID_ESSENTIAL_ROADRUNNER,
 		PCI_ANY_ID, PCI_ANY_ID, },
 	{ 0,}

commit a81ab36bf52d0ca3a32251a923be1dbced726141
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Jan 8 15:32:47 2014 -0500

    drivers/net: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.   Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    This covers everything under drivers/net except for wireless, which
    has been submitted separately.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index cd85f24637e1..e580583f196d 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -37,7 +37,6 @@
 #include <linux/netdevice.h>
 #include <linux/hippidevice.h>
 #include <linux/skbuff.h>
-#include <linux/init.h>
 #include <linux/delay.h>
 #include <linux/mm.h>
 #include <linux/slab.h>

commit 79ac7c941124866a72f000bb1fbb65dc1d1cf8cb
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Dec 10 12:48:38 2013 +0900

    net: hippi: remove unnecessary pci_set_drvdata()
    
    The driver core clears the driver data to NULL after device_release
    or on probe failure. Thus, it is not needed to manually clear the
    device driver data to NULL.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index 00ed75155ce8..cd85f24637e1 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -213,10 +213,8 @@ static int rr_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 				    rrpriv->tx_ring_dma);
 	if (rrpriv->regs)
 		pci_iounmap(pdev, rrpriv->regs);
-	if (pdev) {
+	if (pdev)
 		pci_release_regions(pdev);
-		pci_set_drvdata(pdev, NULL);
-	}
  out2:
 	free_netdev(dev);
  out3:
@@ -244,7 +242,6 @@ static void rr_remove_one(struct pci_dev *pdev)
 	pci_iounmap(pdev, rr->regs);
 	pci_release_regions(pdev);
 	pci_disable_device(pdev);
-	pci_set_drvdata(pdev, NULL);
 	free_netdev(dev);
 }
 

commit ff7150550d9e3d9dd9ceadebbe8ee45e74c1ffdb
Author: Peter HÃ¼we <PeterHuewe@gmx.de>
Date:   Tue May 21 13:42:53 2013 +0000

    net/hippi/rrunner: Use module_pci_driver to register driver
    
    Removing some boilerplate by using module_pci_driver instead of calling
    register and unregister in the otherwise empty init/exit functions.
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index 3c4d6274bb9b..00ed75155ce8 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -1686,15 +1686,4 @@ static struct pci_driver rr_driver = {
 	.remove		= rr_remove_one,
 };
 
-static int __init rr_init_module(void)
-{
-	return pci_register_driver(&rr_driver);
-}
-
-static void __exit rr_cleanup_module(void)
-{
-	pci_unregister_driver(&rr_driver);
-}
-
-module_init(rr_init_module);
-module_exit(rr_cleanup_module);
+module_pci_driver(rr_driver);

commit fef4c86e59a76f2ec1a77d5732f40752700bd5dd
Author: David Oostdyk <daveo@ll.mit.edu>
Date:   Fri Mar 8 08:28:15 2013 +0000

    rrunner.c: fix possible memory leak in rr_init_one()
    
    In the event that register_netdev() failed, the rrpriv->evt_ring
    allocation would have not been freed.
    
    Signed-off-by: David Oostdyk <daveo@ll.mit.edu>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index e5b19b056909..3c4d6274bb9b 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -202,6 +202,9 @@ static int rr_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 	return 0;
 
  out:
+	if (rrpriv->evt_ring)
+		pci_free_consistent(pdev, EVT_RING_SIZE, rrpriv->evt_ring,
+				    rrpriv->evt_ring_dma);
 	if (rrpriv->rx_ring)
 		pci_free_consistent(pdev, RX_TOTAL_SIZE, rrpriv->rx_ring,
 				    rrpriv->rx_ring_dma);

commit 1dd06ae8db716e17ec7e06244b858606edf378c0
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Dec 6 14:30:56 2012 +0000

    drivers/net: fix up function prototypes after __dev* removals
    
    The __dev* removal patches for the network drivers ended up messing up
    the function prototypes for a bunch of drivers.  This patch fixes all of
    them back up to be properly aligned.
    
    Bonus is that this almost removes 100 lines of code, always a nice
    surprise.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index e54b84d5ad76..e5b19b056909 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -88,8 +88,7 @@ static const struct net_device_ops rr_netdev_ops = {
  * stack will need to know about I/O vectors or something similar.
  */
 
-static int rr_init_one(struct pci_dev *pdev,
-	const struct pci_device_id *ent)
+static int rr_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	struct net_device *dev;
 	static int version_disp;

commit 6e9454913e9b0e7b02377ee102348dd8e9681f44
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Dec 3 09:24:11 2012 -0500

    hippi: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Jes Sorensen <jes@trained-monkey.org>
    Cc: linux-hippi@sunsite.dk
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index d4719632ffc6..e54b84d5ad76 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -61,7 +61,7 @@ MODULE_AUTHOR("Jes Sorensen <jes@wildopensource.com>");
 MODULE_DESCRIPTION("Essential RoadRunner HIPPI driver");
 MODULE_LICENSE("GPL");
 
-static char version[] __devinitdata = "rrunner.c: v0.50 11/11/2002  Jes Sorensen (jes@wildopensource.com)\n";
+static char version[] = "rrunner.c: v0.50 11/11/2002  Jes Sorensen (jes@wildopensource.com)\n";
 
 
 static const struct net_device_ops rr_netdev_ops = {
@@ -88,7 +88,7 @@ static const struct net_device_ops rr_netdev_ops = {
  * stack will need to know about I/O vectors or something similar.
  */
 
-static int __devinit rr_init_one(struct pci_dev *pdev,
+static int rr_init_one(struct pci_dev *pdev,
 	const struct pci_device_id *ent)
 {
 	struct net_device *dev;
@@ -221,7 +221,7 @@ static int __devinit rr_init_one(struct pci_dev *pdev,
 	return ret;
 }
 
-static void __devexit rr_remove_one (struct pci_dev *pdev)
+static void rr_remove_one(struct pci_dev *pdev)
 {
 	struct net_device *dev = pci_get_drvdata(pdev);
 	struct rr_private *rr = netdev_priv(dev);
@@ -503,7 +503,7 @@ static unsigned int write_eeprom(struct rr_private *rrpriv,
 }
 
 
-static int __devinit rr_init(struct net_device *dev)
+static int rr_init(struct net_device *dev)
 {
 	struct rr_private *rrpriv;
 	struct rr_regs __iomem *regs;
@@ -1681,7 +1681,7 @@ static struct pci_driver rr_driver = {
 	.name		= "rrunner",
 	.id_table	= rr_pci_tbl,
 	.probe		= rr_init_one,
-	.remove		= __devexit_p(rr_remove_one),
+	.remove		= rr_remove_one,
 };
 
 static int __init rr_init_module(void)

commit ecffe75f934b4e3c5301fe5db278068e0efb0d6b
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Mon Apr 16 15:01:33 2012 +0000

    hippi: fix printk format in rrunner.c
    
    Fix printk format warning (from i386 build):
    
    drivers/net/hippi/rrunner.c:146:9: warning: format '%08llx' expects type 'long long unsigned int', but argument 3 has type 'resource_size_t'
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Cc: Jes Sorensen <jes@trained-monkey.org>
    Cc:     linux-hippi@sunsite.dk
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index b6a2bdeff595..d4719632ffc6 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -142,8 +142,9 @@ static int __devinit rr_init_one(struct pci_dev *pdev,
 	pci_set_master(pdev);
 
 	printk(KERN_INFO "%s: Essential RoadRunner serial HIPPI "
-	       "at 0x%08llx, irq %i, PCI latency %i\n", dev->name,
-	       pci_resource_start(pdev, 0), pdev->irq, pci_latency);
+	       "at 0x%llx, irq %i, PCI latency %i\n", dev->name,
+	       (unsigned long long)pci_resource_start(pdev, 0),
+	       pdev->irq, pci_latency);
 
 	/*
 	 * Remap the MMIO regs into kernel space.

commit 06eb4eafbdc0796d741d139a44f1253278da8611
Merge: 32ed53b83ea5 f68e556e23d1
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Apr 10 14:30:45 2012 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net

commit 0193fc5efd95c18bed1d03c57b2f916906662753
Author: Francois Romieu <romieu@fr.zoreil.com>
Date:   Fri Mar 23 19:20:14 2012 +0100

    rrunner: stop using net_device.{base_addr, irq}.
    
    Signed-off-by: Francois Romieu <romieu@fr.zoreil.com>

diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index 2a51363d9fed..248c4f17846c 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -114,10 +114,9 @@ static int __devinit rr_init_one(struct pci_dev *pdev,
 
 	SET_NETDEV_DEV(dev, &pdev->dev);
 
-	if (pci_request_regions(pdev, "rrunner")) {
-		ret = -EIO;
+	ret = pci_request_regions(pdev, "rrunner");
+	if (ret < 0)
 		goto out;
-	}
 
 	pci_set_drvdata(pdev, dev);
 
@@ -125,11 +124,8 @@ static int __devinit rr_init_one(struct pci_dev *pdev,
 
 	spin_lock_init(&rrpriv->lock);
 
-	dev->irq = pdev->irq;
 	dev->netdev_ops = &rr_netdev_ops;
 
-	dev->base_addr = pci_resource_start(pdev, 0);
-
 	/* display version info if adapter is found */
 	if (!version_disp) {
 		/* set display flag to TRUE so that */
@@ -147,16 +143,14 @@ static int __devinit rr_init_one(struct pci_dev *pdev,
 	pci_set_master(pdev);
 
 	printk(KERN_INFO "%s: Essential RoadRunner serial HIPPI "
-	       "at 0x%08lx, irq %i, PCI latency %i\n", dev->name,
-	       dev->base_addr, dev->irq, pci_latency);
+	       "at 0x%08llx, irq %i, PCI latency %i\n", dev->name,
+	       pci_resource_start(pdev, 0), pdev->irq, pci_latency);
 
 	/*
-	 * Remap the regs into kernel space.
+	 * Remap the MMIO regs into kernel space.
 	 */
-
-	rrpriv->regs = ioremap(dev->base_addr, 0x1000);
-
-	if (!rrpriv->regs){
+	rrpriv->regs = pci_iomap(pdev, 0, 0x1000);
+	if (!rrpriv->regs) {
 		printk(KERN_ERR "%s:  Unable to map I/O register, "
 			"RoadRunner will be disabled.\n", dev->name);
 		ret = -EIO;
@@ -203,8 +197,6 @@ static int __devinit rr_init_one(struct pci_dev *pdev,
 
 	rr_init(dev);
 
-	dev->base_addr = 0;
-
 	ret = register_netdev(dev);
 	if (ret)
 		goto out;
@@ -218,7 +210,7 @@ static int __devinit rr_init_one(struct pci_dev *pdev,
 		pci_free_consistent(pdev, TX_TOTAL_SIZE, rrpriv->tx_ring,
 				    rrpriv->tx_ring_dma);
 	if (rrpriv->regs)
-		iounmap(rrpriv->regs);
+		pci_iounmap(pdev, rrpriv->regs);
 	if (pdev) {
 		pci_release_regions(pdev);
 		pci_set_drvdata(pdev, NULL);
@@ -232,29 +224,26 @@ static int __devinit rr_init_one(struct pci_dev *pdev,
 static void __devexit rr_remove_one (struct pci_dev *pdev)
 {
 	struct net_device *dev = pci_get_drvdata(pdev);
+	struct rr_private *rr = netdev_priv(dev);
 
-	if (dev) {
-		struct rr_private *rr = netdev_priv(dev);
-
-		if (!(readl(&rr->regs->HostCtrl) & NIC_HALTED)){
-			printk(KERN_ERR "%s: trying to unload running NIC\n",
-			       dev->name);
-			writel(HALT_NIC, &rr->regs->HostCtrl);
-		}
-
-		pci_free_consistent(pdev, EVT_RING_SIZE, rr->evt_ring,
-				    rr->evt_ring_dma);
-		pci_free_consistent(pdev, RX_TOTAL_SIZE, rr->rx_ring,
-				    rr->rx_ring_dma);
-		pci_free_consistent(pdev, TX_TOTAL_SIZE, rr->tx_ring,
-				    rr->tx_ring_dma);
-		unregister_netdev(dev);
-		iounmap(rr->regs);
-		free_netdev(dev);
-		pci_release_regions(pdev);
-		pci_disable_device(pdev);
-		pci_set_drvdata(pdev, NULL);
+	if (!(readl(&rr->regs->HostCtrl) & NIC_HALTED)) {
+		printk(KERN_ERR "%s: trying to unload running NIC\n",
+		       dev->name);
+		writel(HALT_NIC, &rr->regs->HostCtrl);
 	}
+
+	unregister_netdev(dev);
+	pci_free_consistent(pdev, EVT_RING_SIZE, rr->evt_ring,
+			    rr->evt_ring_dma);
+	pci_free_consistent(pdev, RX_TOTAL_SIZE, rr->rx_ring,
+			    rr->rx_ring_dma);
+	pci_free_consistent(pdev, TX_TOTAL_SIZE, rr->tx_ring,
+			    rr->tx_ring_dma);
+	pci_iounmap(pdev, rr->regs);
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+	pci_set_drvdata(pdev, NULL);
+	free_netdev(dev);
 }
 
 
@@ -1230,9 +1219,9 @@ static int rr_open(struct net_device *dev)
 	readl(&regs->HostCtrl);
 	spin_unlock_irqrestore(&rrpriv->lock, flags);
 
-	if (request_irq(dev->irq, rr_interrupt, IRQF_SHARED, dev->name, dev)) {
+	if (request_irq(pdev->irq, rr_interrupt, IRQF_SHARED, dev->name, dev)) {
 		printk(KERN_WARNING "%s: Requested IRQ %d is busy\n",
-		       dev->name, dev->irq);
+		       dev->name, pdev->irq);
 		ecode = -EAGAIN;
 		goto error;
 	}
@@ -1339,16 +1328,15 @@ static void rr_dump(struct net_device *dev)
 
 static int rr_close(struct net_device *dev)
 {
-	struct rr_private *rrpriv;
-	struct rr_regs __iomem *regs;
+	struct rr_private *rrpriv = netdev_priv(dev);
+	struct rr_regs __iomem *regs = rrpriv->regs;
+	struct pci_dev *pdev = rrpriv->pci_dev;
 	unsigned long flags;
 	u32 tmp;
 	short i;
 
 	netif_stop_queue(dev);
 
-	rrpriv = netdev_priv(dev);
-	regs = rrpriv->regs;
 
 	/*
 	 * Lock to make sure we are not cleaning up while another CPU
@@ -1387,15 +1375,15 @@ static int rr_close(struct net_device *dev)
 	rr_raz_tx(rrpriv, dev);
 	rr_raz_rx(rrpriv, dev);
 
-	pci_free_consistent(rrpriv->pci_dev, 256 * sizeof(struct ring_ctrl),
+	pci_free_consistent(pdev, 256 * sizeof(struct ring_ctrl),
 			    rrpriv->rx_ctrl, rrpriv->rx_ctrl_dma);
 	rrpriv->rx_ctrl = NULL;
 
-	pci_free_consistent(rrpriv->pci_dev, sizeof(struct rr_info),
-			    rrpriv->info, rrpriv->info_dma);
+	pci_free_consistent(pdev, sizeof(struct rr_info), rrpriv->info,
+			    rrpriv->info_dma);
 	rrpriv->info = NULL;
 
-	free_irq(dev->irq, dev);
+	free_irq(pdev->irq, dev);
 	spin_unlock_irqrestore(&rrpriv->lock, flags);
 
 	return 0;

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index 2a51363d9fed..168c8f41d09f 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -43,7 +43,6 @@
 #include <linux/slab.h>
 #include <net/sock.h>
 
-#include <asm/system.h>
 #include <asm/cache.h>
 #include <asm/byteorder.h>
 #include <asm/io.h>

commit e404decb0fb017be80552adee894b35307b6c7b4
Author: Joe Perches <joe@perches.com>
Date:   Sun Jan 29 12:56:23 2012 +0000

    drivers/net: Remove unnecessary k.alloc/v.alloc OOM messages
    
    alloc failures use dump_stack so emitting an additional
    out-of-memory message is an unnecessary duplication.
    
    Remove the allocation failure messages.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index e68c941926f1..2a51363d9fed 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -1600,12 +1600,8 @@ static int rr_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 		}
 
 		image = kmalloc(EEPROM_WORDS * sizeof(u32), GFP_KERNEL);
-		if (!image){
-			printk(KERN_ERR "%s: Unable to allocate memory "
-			       "for EEPROM image\n", dev->name);
+		if (!image)
 			return -ENOMEM;
-		}
-
 
 		if (rrpriv->fw_running){
 			printk("%s: Firmware already running\n", dev->name);
@@ -1637,8 +1633,6 @@ static int rr_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 		image = kmalloc(EEPROM_WORDS * sizeof(u32), GFP_KERNEL);
 		oldimage = kmalloc(EEPROM_WORDS * sizeof(u32), GFP_KERNEL);
 		if (!image || !oldimage) {
-			printk(KERN_ERR "%s: Unable to allocate memory "
-			       "for EEPROM image\n", dev->name);
 			error = -ENOMEM;
 			goto wf_out;
 		}

commit ff5a3b509e4ec96a2a4c57052a2d96e855778a24
Author: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Date:   Mon Aug 1 22:48:13 2011 -0700

    hippi: Move the HIPPI driver
    
    Move the HIPPI driver into drivers/net/hippi/ and make the
    necessary Kconfig and Makefile changes.
    
    CC: Jes Sorensen <jes@wildopensource.com>
    CC: Jes Sorensen <jes@trained-monkey.org>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
new file mode 100644
index 000000000000..e68c941926f1
--- /dev/null
+++ b/drivers/net/hippi/rrunner.c
@@ -0,0 +1,1716 @@
+/*
+ * rrunner.c: Linux driver for the Essential RoadRunner HIPPI board.
+ *
+ * Copyright (C) 1998-2002 by Jes Sorensen, <jes@wildopensource.com>.
+ *
+ * Thanks to Essential Communication for providing us with hardware
+ * and very comprehensive documentation without which I would not have
+ * been able to write this driver. A special thank you to John Gibbon
+ * for sorting out the legal issues, with the NDA, allowing the code to
+ * be released under the GPL.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * Thanks to Jayaram Bhat from ODS/Essential for fixing some of the
+ * stupid bugs in my code.
+ *
+ * Softnet support and various other patches from Val Henson of
+ * ODS/Essential.
+ *
+ * PCI DMA mapping code partly based on work by Francois Romieu.
+ */
+
+
+#define DEBUG 1
+#define RX_DMA_SKBUFF 1
+#define PKT_COPY_THRESHOLD 512
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/hippidevice.h>
+#include <linux/skbuff.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <net/sock.h>
+
+#include <asm/system.h>
+#include <asm/cache.h>
+#include <asm/byteorder.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+
+#define rr_if_busy(dev)     netif_queue_stopped(dev)
+#define rr_if_running(dev)  netif_running(dev)
+
+#include "rrunner.h"
+
+#define RUN_AT(x) (jiffies + (x))
+
+
+MODULE_AUTHOR("Jes Sorensen <jes@wildopensource.com>");
+MODULE_DESCRIPTION("Essential RoadRunner HIPPI driver");
+MODULE_LICENSE("GPL");
+
+static char version[] __devinitdata = "rrunner.c: v0.50 11/11/2002  Jes Sorensen (jes@wildopensource.com)\n";
+
+
+static const struct net_device_ops rr_netdev_ops = {
+	.ndo_open 		= rr_open,
+	.ndo_stop		= rr_close,
+	.ndo_do_ioctl		= rr_ioctl,
+	.ndo_start_xmit		= rr_start_xmit,
+	.ndo_change_mtu		= hippi_change_mtu,
+	.ndo_set_mac_address	= hippi_mac_addr,
+};
+
+/*
+ * Implementation notes:
+ *
+ * The DMA engine only allows for DMA within physical 64KB chunks of
+ * memory. The current approach of the driver (and stack) is to use
+ * linear blocks of memory for the skbuffs. However, as the data block
+ * is always the first part of the skb and skbs are 2^n aligned so we
+ * are guarantted to get the whole block within one 64KB align 64KB
+ * chunk.
+ *
+ * On the long term, relying on being able to allocate 64KB linear
+ * chunks of memory is not feasible and the skb handling code and the
+ * stack will need to know about I/O vectors or something similar.
+ */
+
+static int __devinit rr_init_one(struct pci_dev *pdev,
+	const struct pci_device_id *ent)
+{
+	struct net_device *dev;
+	static int version_disp;
+	u8 pci_latency;
+	struct rr_private *rrpriv;
+	void *tmpptr;
+	dma_addr_t ring_dma;
+	int ret = -ENOMEM;
+
+	dev = alloc_hippi_dev(sizeof(struct rr_private));
+	if (!dev)
+		goto out3;
+
+	ret = pci_enable_device(pdev);
+	if (ret) {
+		ret = -ENODEV;
+		goto out2;
+	}
+
+	rrpriv = netdev_priv(dev);
+
+	SET_NETDEV_DEV(dev, &pdev->dev);
+
+	if (pci_request_regions(pdev, "rrunner")) {
+		ret = -EIO;
+		goto out;
+	}
+
+	pci_set_drvdata(pdev, dev);
+
+	rrpriv->pci_dev = pdev;
+
+	spin_lock_init(&rrpriv->lock);
+
+	dev->irq = pdev->irq;
+	dev->netdev_ops = &rr_netdev_ops;
+
+	dev->base_addr = pci_resource_start(pdev, 0);
+
+	/* display version info if adapter is found */
+	if (!version_disp) {
+		/* set display flag to TRUE so that */
+		/* we only display this string ONCE */
+		version_disp = 1;
+		printk(version);
+	}
+
+	pci_read_config_byte(pdev, PCI_LATENCY_TIMER, &pci_latency);
+	if (pci_latency <= 0x58){
+		pci_latency = 0x58;
+		pci_write_config_byte(pdev, PCI_LATENCY_TIMER, pci_latency);
+	}
+
+	pci_set_master(pdev);
+
+	printk(KERN_INFO "%s: Essential RoadRunner serial HIPPI "
+	       "at 0x%08lx, irq %i, PCI latency %i\n", dev->name,
+	       dev->base_addr, dev->irq, pci_latency);
+
+	/*
+	 * Remap the regs into kernel space.
+	 */
+
+	rrpriv->regs = ioremap(dev->base_addr, 0x1000);
+
+	if (!rrpriv->regs){
+		printk(KERN_ERR "%s:  Unable to map I/O register, "
+			"RoadRunner will be disabled.\n", dev->name);
+		ret = -EIO;
+		goto out;
+	}
+
+	tmpptr = pci_alloc_consistent(pdev, TX_TOTAL_SIZE, &ring_dma);
+	rrpriv->tx_ring = tmpptr;
+	rrpriv->tx_ring_dma = ring_dma;
+
+	if (!tmpptr) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	tmpptr = pci_alloc_consistent(pdev, RX_TOTAL_SIZE, &ring_dma);
+	rrpriv->rx_ring = tmpptr;
+	rrpriv->rx_ring_dma = ring_dma;
+
+	if (!tmpptr) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	tmpptr = pci_alloc_consistent(pdev, EVT_RING_SIZE, &ring_dma);
+	rrpriv->evt_ring = tmpptr;
+	rrpriv->evt_ring_dma = ring_dma;
+
+	if (!tmpptr) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/*
+	 * Don't access any register before this point!
+	 */
+#ifdef __BIG_ENDIAN
+	writel(readl(&rrpriv->regs->HostCtrl) | NO_SWAP,
+		&rrpriv->regs->HostCtrl);
+#endif
+	/*
+	 * Need to add a case for little-endian 64-bit hosts here.
+	 */
+
+	rr_init(dev);
+
+	dev->base_addr = 0;
+
+	ret = register_netdev(dev);
+	if (ret)
+		goto out;
+	return 0;
+
+ out:
+	if (rrpriv->rx_ring)
+		pci_free_consistent(pdev, RX_TOTAL_SIZE, rrpriv->rx_ring,
+				    rrpriv->rx_ring_dma);
+	if (rrpriv->tx_ring)
+		pci_free_consistent(pdev, TX_TOTAL_SIZE, rrpriv->tx_ring,
+				    rrpriv->tx_ring_dma);
+	if (rrpriv->regs)
+		iounmap(rrpriv->regs);
+	if (pdev) {
+		pci_release_regions(pdev);
+		pci_set_drvdata(pdev, NULL);
+	}
+ out2:
+	free_netdev(dev);
+ out3:
+	return ret;
+}
+
+static void __devexit rr_remove_one (struct pci_dev *pdev)
+{
+	struct net_device *dev = pci_get_drvdata(pdev);
+
+	if (dev) {
+		struct rr_private *rr = netdev_priv(dev);
+
+		if (!(readl(&rr->regs->HostCtrl) & NIC_HALTED)){
+			printk(KERN_ERR "%s: trying to unload running NIC\n",
+			       dev->name);
+			writel(HALT_NIC, &rr->regs->HostCtrl);
+		}
+
+		pci_free_consistent(pdev, EVT_RING_SIZE, rr->evt_ring,
+				    rr->evt_ring_dma);
+		pci_free_consistent(pdev, RX_TOTAL_SIZE, rr->rx_ring,
+				    rr->rx_ring_dma);
+		pci_free_consistent(pdev, TX_TOTAL_SIZE, rr->tx_ring,
+				    rr->tx_ring_dma);
+		unregister_netdev(dev);
+		iounmap(rr->regs);
+		free_netdev(dev);
+		pci_release_regions(pdev);
+		pci_disable_device(pdev);
+		pci_set_drvdata(pdev, NULL);
+	}
+}
+
+
+/*
+ * Commands are considered to be slow, thus there is no reason to
+ * inline this.
+ */
+static void rr_issue_cmd(struct rr_private *rrpriv, struct cmd *cmd)
+{
+	struct rr_regs __iomem *regs;
+	u32 idx;
+
+	regs = rrpriv->regs;
+	/*
+	 * This is temporary - it will go away in the final version.
+	 * We probably also want to make this function inline.
+	 */
+	if (readl(&regs->HostCtrl) & NIC_HALTED){
+		printk("issuing command for halted NIC, code 0x%x, "
+		       "HostCtrl %08x\n", cmd->code, readl(&regs->HostCtrl));
+		if (readl(&regs->Mode) & FATAL_ERR)
+			printk("error codes Fail1 %02x, Fail2 %02x\n",
+			       readl(&regs->Fail1), readl(&regs->Fail2));
+	}
+
+	idx = rrpriv->info->cmd_ctrl.pi;
+
+	writel(*(u32*)(cmd), &regs->CmdRing[idx]);
+	wmb();
+
+	idx = (idx - 1) % CMD_RING_ENTRIES;
+	rrpriv->info->cmd_ctrl.pi = idx;
+	wmb();
+
+	if (readl(&regs->Mode) & FATAL_ERR)
+		printk("error code %02x\n", readl(&regs->Fail1));
+}
+
+
+/*
+ * Reset the board in a sensible manner. The NIC is already halted
+ * when we get here and a spin-lock is held.
+ */
+static int rr_reset(struct net_device *dev)
+{
+	struct rr_private *rrpriv;
+	struct rr_regs __iomem *regs;
+	u32 start_pc;
+	int i;
+
+	rrpriv = netdev_priv(dev);
+	regs = rrpriv->regs;
+
+	rr_load_firmware(dev);
+
+	writel(0x01000000, &regs->TX_state);
+	writel(0xff800000, &regs->RX_state);
+	writel(0, &regs->AssistState);
+	writel(CLEAR_INTA, &regs->LocalCtrl);
+	writel(0x01, &regs->BrkPt);
+	writel(0, &regs->Timer);
+	writel(0, &regs->TimerRef);
+	writel(RESET_DMA, &regs->DmaReadState);
+	writel(RESET_DMA, &regs->DmaWriteState);
+	writel(0, &regs->DmaWriteHostHi);
+	writel(0, &regs->DmaWriteHostLo);
+	writel(0, &regs->DmaReadHostHi);
+	writel(0, &regs->DmaReadHostLo);
+	writel(0, &regs->DmaReadLen);
+	writel(0, &regs->DmaWriteLen);
+	writel(0, &regs->DmaWriteLcl);
+	writel(0, &regs->DmaWriteIPchecksum);
+	writel(0, &regs->DmaReadLcl);
+	writel(0, &regs->DmaReadIPchecksum);
+	writel(0, &regs->PciState);
+#if (BITS_PER_LONG == 64) && defined __LITTLE_ENDIAN
+	writel(SWAP_DATA | PTR64BIT | PTR_WD_SWAP, &regs->Mode);
+#elif (BITS_PER_LONG == 64)
+	writel(SWAP_DATA | PTR64BIT | PTR_WD_NOSWAP, &regs->Mode);
+#else
+	writel(SWAP_DATA | PTR32BIT | PTR_WD_NOSWAP, &regs->Mode);
+#endif
+
+#if 0
+	/*
+	 * Don't worry, this is just black magic.
+	 */
+	writel(0xdf000, &regs->RxBase);
+	writel(0xdf000, &regs->RxPrd);
+	writel(0xdf000, &regs->RxCon);
+	writel(0xce000, &regs->TxBase);
+	writel(0xce000, &regs->TxPrd);
+	writel(0xce000, &regs->TxCon);
+	writel(0, &regs->RxIndPro);
+	writel(0, &regs->RxIndCon);
+	writel(0, &regs->RxIndRef);
+	writel(0, &regs->TxIndPro);
+	writel(0, &regs->TxIndCon);
+	writel(0, &regs->TxIndRef);
+	writel(0xcc000, &regs->pad10[0]);
+	writel(0, &regs->DrCmndPro);
+	writel(0, &regs->DrCmndCon);
+	writel(0, &regs->DwCmndPro);
+	writel(0, &regs->DwCmndCon);
+	writel(0, &regs->DwCmndRef);
+	writel(0, &regs->DrDataPro);
+	writel(0, &regs->DrDataCon);
+	writel(0, &regs->DrDataRef);
+	writel(0, &regs->DwDataPro);
+	writel(0, &regs->DwDataCon);
+	writel(0, &regs->DwDataRef);
+#endif
+
+	writel(0xffffffff, &regs->MbEvent);
+	writel(0, &regs->Event);
+
+	writel(0, &regs->TxPi);
+	writel(0, &regs->IpRxPi);
+
+	writel(0, &regs->EvtCon);
+	writel(0, &regs->EvtPrd);
+
+	rrpriv->info->evt_ctrl.pi = 0;
+
+	for (i = 0; i < CMD_RING_ENTRIES; i++)
+		writel(0, &regs->CmdRing[i]);
+
+/*
+ * Why 32 ? is this not cache line size dependent?
+ */
+	writel(RBURST_64|WBURST_64, &regs->PciState);
+	wmb();
+
+	start_pc = rr_read_eeprom_word(rrpriv,
+			offsetof(struct eeprom, rncd_info.FwStart));
+
+#if (DEBUG > 1)
+	printk("%s: Executing firmware at address 0x%06x\n",
+	       dev->name, start_pc);
+#endif
+
+	writel(start_pc + 0x800, &regs->Pc);
+	wmb();
+	udelay(5);
+
+	writel(start_pc, &regs->Pc);
+	wmb();
+
+	return 0;
+}
+
+
+/*
+ * Read a string from the EEPROM.
+ */
+static unsigned int rr_read_eeprom(struct rr_private *rrpriv,
+				unsigned long offset,
+				unsigned char *buf,
+				unsigned long length)
+{
+	struct rr_regs __iomem *regs = rrpriv->regs;
+	u32 misc, io, host, i;
+
+	io = readl(&regs->ExtIo);
+	writel(0, &regs->ExtIo);
+	misc = readl(&regs->LocalCtrl);
+	writel(0, &regs->LocalCtrl);
+	host = readl(&regs->HostCtrl);
+	writel(host | HALT_NIC, &regs->HostCtrl);
+	mb();
+
+	for (i = 0; i < length; i++){
+		writel((EEPROM_BASE + ((offset+i) << 3)), &regs->WinBase);
+		mb();
+		buf[i] = (readl(&regs->WinData) >> 24) & 0xff;
+		mb();
+	}
+
+	writel(host, &regs->HostCtrl);
+	writel(misc, &regs->LocalCtrl);
+	writel(io, &regs->ExtIo);
+	mb();
+	return i;
+}
+
+
+/*
+ * Shortcut to read one word (4 bytes) out of the EEPROM and convert
+ * it to our CPU byte-order.
+ */
+static u32 rr_read_eeprom_word(struct rr_private *rrpriv,
+			    size_t offset)
+{
+	__be32 word;
+
+	if ((rr_read_eeprom(rrpriv, offset,
+			    (unsigned char *)&word, 4) == 4))
+		return be32_to_cpu(word);
+	return 0;
+}
+
+
+/*
+ * Write a string to the EEPROM.
+ *
+ * This is only called when the firmware is not running.
+ */
+static unsigned int write_eeprom(struct rr_private *rrpriv,
+				 unsigned long offset,
+				 unsigned char *buf,
+				 unsigned long length)
+{
+	struct rr_regs __iomem *regs = rrpriv->regs;
+	u32 misc, io, data, i, j, ready, error = 0;
+
+	io = readl(&regs->ExtIo);
+	writel(0, &regs->ExtIo);
+	misc = readl(&regs->LocalCtrl);
+	writel(ENABLE_EEPROM_WRITE, &regs->LocalCtrl);
+	mb();
+
+	for (i = 0; i < length; i++){
+		writel((EEPROM_BASE + ((offset+i) << 3)), &regs->WinBase);
+		mb();
+		data = buf[i] << 24;
+		/*
+		 * Only try to write the data if it is not the same
+		 * value already.
+		 */
+		if ((readl(&regs->WinData) & 0xff000000) != data){
+			writel(data, &regs->WinData);
+			ready = 0;
+			j = 0;
+			mb();
+			while(!ready){
+				udelay(20);
+				if ((readl(&regs->WinData) & 0xff000000) ==
+				    data)
+					ready = 1;
+				mb();
+				if (j++ > 5000){
+					printk("data mismatch: %08x, "
+					       "WinData %08x\n", data,
+					       readl(&regs->WinData));
+					ready = 1;
+					error = 1;
+				}
+			}
+		}
+	}
+
+	writel(misc, &regs->LocalCtrl);
+	writel(io, &regs->ExtIo);
+	mb();
+
+	return error;
+}
+
+
+static int __devinit rr_init(struct net_device *dev)
+{
+	struct rr_private *rrpriv;
+	struct rr_regs __iomem *regs;
+	u32 sram_size, rev;
+
+	rrpriv = netdev_priv(dev);
+	regs = rrpriv->regs;
+
+	rev = readl(&regs->FwRev);
+	rrpriv->fw_rev = rev;
+	if (rev > 0x00020024)
+		printk("  Firmware revision: %i.%i.%i\n", (rev >> 16),
+		       ((rev >> 8) & 0xff), (rev & 0xff));
+	else if (rev >= 0x00020000) {
+		printk("  Firmware revision: %i.%i.%i (2.0.37 or "
+		       "later is recommended)\n", (rev >> 16),
+		       ((rev >> 8) & 0xff), (rev & 0xff));
+	}else{
+		printk("  Firmware revision too old: %i.%i.%i, please "
+		       "upgrade to 2.0.37 or later.\n",
+		       (rev >> 16), ((rev >> 8) & 0xff), (rev & 0xff));
+	}
+
+#if (DEBUG > 2)
+	printk("  Maximum receive rings %i\n", readl(&regs->MaxRxRng));
+#endif
+
+	/*
+	 * Read the hardware address from the eeprom.  The HW address
+	 * is not really necessary for HIPPI but awfully convenient.
+	 * The pointer arithmetic to put it in dev_addr is ugly, but
+	 * Donald Becker does it this way for the GigE version of this
+	 * card and it's shorter and more portable than any
+	 * other method I've seen.  -VAL
+	 */
+
+	*(__be16 *)(dev->dev_addr) =
+	  htons(rr_read_eeprom_word(rrpriv, offsetof(struct eeprom, manf.BoardULA)));
+	*(__be32 *)(dev->dev_addr+2) =
+	  htonl(rr_read_eeprom_word(rrpriv, offsetof(struct eeprom, manf.BoardULA[4])));
+
+	printk("  MAC: %pM\n", dev->dev_addr);
+
+	sram_size = rr_read_eeprom_word(rrpriv, 8);
+	printk("  SRAM size 0x%06x\n", sram_size);
+
+	return 0;
+}
+
+
+static int rr_init1(struct net_device *dev)
+{
+	struct rr_private *rrpriv;
+	struct rr_regs __iomem *regs;
+	unsigned long myjif, flags;
+	struct cmd cmd;
+	u32 hostctrl;
+	int ecode = 0;
+	short i;
+
+	rrpriv = netdev_priv(dev);
+	regs = rrpriv->regs;
+
+	spin_lock_irqsave(&rrpriv->lock, flags);
+
+	hostctrl = readl(&regs->HostCtrl);
+	writel(hostctrl | HALT_NIC | RR_CLEAR_INT, &regs->HostCtrl);
+	wmb();
+
+	if (hostctrl & PARITY_ERR){
+		printk("%s: Parity error halting NIC - this is serious!\n",
+		       dev->name);
+		spin_unlock_irqrestore(&rrpriv->lock, flags);
+		ecode = -EFAULT;
+		goto error;
+	}
+
+	set_rxaddr(regs, rrpriv->rx_ctrl_dma);
+	set_infoaddr(regs, rrpriv->info_dma);
+
+	rrpriv->info->evt_ctrl.entry_size = sizeof(struct event);
+	rrpriv->info->evt_ctrl.entries = EVT_RING_ENTRIES;
+	rrpriv->info->evt_ctrl.mode = 0;
+	rrpriv->info->evt_ctrl.pi = 0;
+	set_rraddr(&rrpriv->info->evt_ctrl.rngptr, rrpriv->evt_ring_dma);
+
+	rrpriv->info->cmd_ctrl.entry_size = sizeof(struct cmd);
+	rrpriv->info->cmd_ctrl.entries = CMD_RING_ENTRIES;
+	rrpriv->info->cmd_ctrl.mode = 0;
+	rrpriv->info->cmd_ctrl.pi = 15;
+
+	for (i = 0; i < CMD_RING_ENTRIES; i++) {
+		writel(0, &regs->CmdRing[i]);
+	}
+
+	for (i = 0; i < TX_RING_ENTRIES; i++) {
+		rrpriv->tx_ring[i].size = 0;
+		set_rraddr(&rrpriv->tx_ring[i].addr, 0);
+		rrpriv->tx_skbuff[i] = NULL;
+	}
+	rrpriv->info->tx_ctrl.entry_size = sizeof(struct tx_desc);
+	rrpriv->info->tx_ctrl.entries = TX_RING_ENTRIES;
+	rrpriv->info->tx_ctrl.mode = 0;
+	rrpriv->info->tx_ctrl.pi = 0;
+	set_rraddr(&rrpriv->info->tx_ctrl.rngptr, rrpriv->tx_ring_dma);
+
+	/*
+	 * Set dirty_tx before we start receiving interrupts, otherwise
+	 * the interrupt handler might think it is supposed to process
+	 * tx ints before we are up and running, which may cause a null
+	 * pointer access in the int handler.
+	 */
+	rrpriv->tx_full = 0;
+	rrpriv->cur_rx = 0;
+	rrpriv->dirty_rx = rrpriv->dirty_tx = 0;
+
+	rr_reset(dev);
+
+	/* Tuning values */
+	writel(0x5000, &regs->ConRetry);
+	writel(0x100, &regs->ConRetryTmr);
+	writel(0x500000, &regs->ConTmout);
+ 	writel(0x60, &regs->IntrTmr);
+	writel(0x500000, &regs->TxDataMvTimeout);
+	writel(0x200000, &regs->RxDataMvTimeout);
+ 	writel(0x80, &regs->WriteDmaThresh);
+ 	writel(0x80, &regs->ReadDmaThresh);
+
+	rrpriv->fw_running = 0;
+	wmb();
+
+	hostctrl &= ~(HALT_NIC | INVALID_INST_B | PARITY_ERR);
+	writel(hostctrl, &regs->HostCtrl);
+	wmb();
+
+	spin_unlock_irqrestore(&rrpriv->lock, flags);
+
+	for (i = 0; i < RX_RING_ENTRIES; i++) {
+		struct sk_buff *skb;
+		dma_addr_t addr;
+
+		rrpriv->rx_ring[i].mode = 0;
+		skb = alloc_skb(dev->mtu + HIPPI_HLEN, GFP_ATOMIC);
+		if (!skb) {
+			printk(KERN_WARNING "%s: Unable to allocate memory "
+			       "for receive ring - halting NIC\n", dev->name);
+			ecode = -ENOMEM;
+			goto error;
+		}
+		rrpriv->rx_skbuff[i] = skb;
+	        addr = pci_map_single(rrpriv->pci_dev, skb->data,
+			dev->mtu + HIPPI_HLEN, PCI_DMA_FROMDEVICE);
+		/*
+		 * Sanity test to see if we conflict with the DMA
+		 * limitations of the Roadrunner.
+		 */
+		if ((((unsigned long)skb->data) & 0xfff) > ~65320)
+			printk("skb alloc error\n");
+
+		set_rraddr(&rrpriv->rx_ring[i].addr, addr);
+		rrpriv->rx_ring[i].size = dev->mtu + HIPPI_HLEN;
+	}
+
+	rrpriv->rx_ctrl[4].entry_size = sizeof(struct rx_desc);
+	rrpriv->rx_ctrl[4].entries = RX_RING_ENTRIES;
+	rrpriv->rx_ctrl[4].mode = 8;
+	rrpriv->rx_ctrl[4].pi = 0;
+	wmb();
+	set_rraddr(&rrpriv->rx_ctrl[4].rngptr, rrpriv->rx_ring_dma);
+
+	udelay(1000);
+
+	/*
+	 * Now start the FirmWare.
+	 */
+	cmd.code = C_START_FW;
+	cmd.ring = 0;
+	cmd.index = 0;
+
+	rr_issue_cmd(rrpriv, &cmd);
+
+	/*
+	 * Give the FirmWare time to chew on the `get running' command.
+	 */
+	myjif = jiffies + 5 * HZ;
+	while (time_before(jiffies, myjif) && !rrpriv->fw_running)
+		cpu_relax();
+
+	netif_start_queue(dev);
+
+	return ecode;
+
+ error:
+	/*
+	 * We might have gotten here because we are out of memory,
+	 * make sure we release everything we allocated before failing
+	 */
+	for (i = 0; i < RX_RING_ENTRIES; i++) {
+		struct sk_buff *skb = rrpriv->rx_skbuff[i];
+
+		if (skb) {
+	        	pci_unmap_single(rrpriv->pci_dev,
+					 rrpriv->rx_ring[i].addr.addrlo,
+					 dev->mtu + HIPPI_HLEN,
+					 PCI_DMA_FROMDEVICE);
+			rrpriv->rx_ring[i].size = 0;
+			set_rraddr(&rrpriv->rx_ring[i].addr, 0);
+			dev_kfree_skb(skb);
+			rrpriv->rx_skbuff[i] = NULL;
+		}
+	}
+	return ecode;
+}
+
+
+/*
+ * All events are considered to be slow (RX/TX ints do not generate
+ * events) and are handled here, outside the main interrupt handler,
+ * to reduce the size of the handler.
+ */
+static u32 rr_handle_event(struct net_device *dev, u32 prodidx, u32 eidx)
+{
+	struct rr_private *rrpriv;
+	struct rr_regs __iomem *regs;
+	u32 tmp;
+
+	rrpriv = netdev_priv(dev);
+	regs = rrpriv->regs;
+
+	while (prodidx != eidx){
+		switch (rrpriv->evt_ring[eidx].code){
+		case E_NIC_UP:
+			tmp = readl(&regs->FwRev);
+			printk(KERN_INFO "%s: Firmware revision %i.%i.%i "
+			       "up and running\n", dev->name,
+			       (tmp >> 16), ((tmp >> 8) & 0xff), (tmp & 0xff));
+			rrpriv->fw_running = 1;
+			writel(RX_RING_ENTRIES - 1, &regs->IpRxPi);
+			wmb();
+			break;
+		case E_LINK_ON:
+			printk(KERN_INFO "%s: Optical link ON\n", dev->name);
+			break;
+		case E_LINK_OFF:
+			printk(KERN_INFO "%s: Optical link OFF\n", dev->name);
+			break;
+		case E_RX_IDLE:
+			printk(KERN_WARNING "%s: RX data not moving\n",
+			       dev->name);
+			goto drop;
+		case E_WATCHDOG:
+			printk(KERN_INFO "%s: The watchdog is here to see "
+			       "us\n", dev->name);
+			break;
+		case E_INTERN_ERR:
+			printk(KERN_ERR "%s: HIPPI Internal NIC error\n",
+			       dev->name);
+			writel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,
+			       &regs->HostCtrl);
+			wmb();
+			break;
+		case E_HOST_ERR:
+			printk(KERN_ERR "%s: Host software error\n",
+			       dev->name);
+			writel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,
+			       &regs->HostCtrl);
+			wmb();
+			break;
+		/*
+		 * TX events.
+		 */
+		case E_CON_REJ:
+			printk(KERN_WARNING "%s: Connection rejected\n",
+			       dev->name);
+			dev->stats.tx_aborted_errors++;
+			break;
+		case E_CON_TMOUT:
+			printk(KERN_WARNING "%s: Connection timeout\n",
+			       dev->name);
+			break;
+		case E_DISC_ERR:
+			printk(KERN_WARNING "%s: HIPPI disconnect error\n",
+			       dev->name);
+			dev->stats.tx_aborted_errors++;
+			break;
+		case E_INT_PRTY:
+			printk(KERN_ERR "%s: HIPPI Internal Parity error\n",
+			       dev->name);
+			writel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,
+			       &regs->HostCtrl);
+			wmb();
+			break;
+		case E_TX_IDLE:
+			printk(KERN_WARNING "%s: Transmitter idle\n",
+			       dev->name);
+			break;
+		case E_TX_LINK_DROP:
+			printk(KERN_WARNING "%s: Link lost during transmit\n",
+			       dev->name);
+			dev->stats.tx_aborted_errors++;
+			writel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,
+			       &regs->HostCtrl);
+			wmb();
+			break;
+		case E_TX_INV_RNG:
+			printk(KERN_ERR "%s: Invalid send ring block\n",
+			       dev->name);
+			writel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,
+			       &regs->HostCtrl);
+			wmb();
+			break;
+		case E_TX_INV_BUF:
+			printk(KERN_ERR "%s: Invalid send buffer address\n",
+			       dev->name);
+			writel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,
+			       &regs->HostCtrl);
+			wmb();
+			break;
+		case E_TX_INV_DSC:
+			printk(KERN_ERR "%s: Invalid descriptor address\n",
+			       dev->name);
+			writel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,
+			       &regs->HostCtrl);
+			wmb();
+			break;
+		/*
+		 * RX events.
+		 */
+		case E_RX_RNG_OUT:
+			printk(KERN_INFO "%s: Receive ring full\n", dev->name);
+			break;
+
+		case E_RX_PAR_ERR:
+			printk(KERN_WARNING "%s: Receive parity error\n",
+			       dev->name);
+			goto drop;
+		case E_RX_LLRC_ERR:
+			printk(KERN_WARNING "%s: Receive LLRC error\n",
+			       dev->name);
+			goto drop;
+		case E_PKT_LN_ERR:
+			printk(KERN_WARNING "%s: Receive packet length "
+			       "error\n", dev->name);
+			goto drop;
+		case E_DTA_CKSM_ERR:
+			printk(KERN_WARNING "%s: Data checksum error\n",
+			       dev->name);
+			goto drop;
+		case E_SHT_BST:
+			printk(KERN_WARNING "%s: Unexpected short burst "
+			       "error\n", dev->name);
+			goto drop;
+		case E_STATE_ERR:
+			printk(KERN_WARNING "%s: Recv. state transition"
+			       " error\n", dev->name);
+			goto drop;
+		case E_UNEXP_DATA:
+			printk(KERN_WARNING "%s: Unexpected data error\n",
+			       dev->name);
+			goto drop;
+		case E_LST_LNK_ERR:
+			printk(KERN_WARNING "%s: Link lost error\n",
+			       dev->name);
+			goto drop;
+		case E_FRM_ERR:
+			printk(KERN_WARNING "%s: Framming Error\n",
+			       dev->name);
+			goto drop;
+		case E_FLG_SYN_ERR:
+			printk(KERN_WARNING "%s: Flag sync. lost during "
+			       "packet\n", dev->name);
+			goto drop;
+		case E_RX_INV_BUF:
+			printk(KERN_ERR "%s: Invalid receive buffer "
+			       "address\n", dev->name);
+			writel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,
+			       &regs->HostCtrl);
+			wmb();
+			break;
+		case E_RX_INV_DSC:
+			printk(KERN_ERR "%s: Invalid receive descriptor "
+			       "address\n", dev->name);
+			writel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,
+			       &regs->HostCtrl);
+			wmb();
+			break;
+		case E_RNG_BLK:
+			printk(KERN_ERR "%s: Invalid ring block\n",
+			       dev->name);
+			writel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,
+			       &regs->HostCtrl);
+			wmb();
+			break;
+		drop:
+			/* Label packet to be dropped.
+			 * Actual dropping occurs in rx
+			 * handling.
+			 *
+			 * The index of packet we get to drop is
+			 * the index of the packet following
+			 * the bad packet. -kbf
+			 */
+			{
+				u16 index = rrpriv->evt_ring[eidx].index;
+				index = (index + (RX_RING_ENTRIES - 1)) %
+					RX_RING_ENTRIES;
+				rrpriv->rx_ring[index].mode |=
+					(PACKET_BAD | PACKET_END);
+			}
+			break;
+		default:
+			printk(KERN_WARNING "%s: Unhandled event 0x%02x\n",
+			       dev->name, rrpriv->evt_ring[eidx].code);
+		}
+		eidx = (eidx + 1) % EVT_RING_ENTRIES;
+	}
+
+	rrpriv->info->evt_ctrl.pi = eidx;
+	wmb();
+	return eidx;
+}
+
+
+static void rx_int(struct net_device *dev, u32 rxlimit, u32 index)
+{
+	struct rr_private *rrpriv = netdev_priv(dev);
+	struct rr_regs __iomem *regs = rrpriv->regs;
+
+	do {
+		struct rx_desc *desc;
+		u32 pkt_len;
+
+		desc = &(rrpriv->rx_ring[index]);
+		pkt_len = desc->size;
+#if (DEBUG > 2)
+		printk("index %i, rxlimit %i\n", index, rxlimit);
+		printk("len %x, mode %x\n", pkt_len, desc->mode);
+#endif
+		if ( (rrpriv->rx_ring[index].mode & PACKET_BAD) == PACKET_BAD){
+			dev->stats.rx_dropped++;
+			goto defer;
+		}
+
+		if (pkt_len > 0){
+			struct sk_buff *skb, *rx_skb;
+
+			rx_skb = rrpriv->rx_skbuff[index];
+
+			if (pkt_len < PKT_COPY_THRESHOLD) {
+				skb = alloc_skb(pkt_len, GFP_ATOMIC);
+				if (skb == NULL){
+					printk(KERN_WARNING "%s: Unable to allocate skb (%i bytes), deferring packet\n", dev->name, pkt_len);
+					dev->stats.rx_dropped++;
+					goto defer;
+				} else {
+					pci_dma_sync_single_for_cpu(rrpriv->pci_dev,
+								    desc->addr.addrlo,
+								    pkt_len,
+								    PCI_DMA_FROMDEVICE);
+
+					memcpy(skb_put(skb, pkt_len),
+					       rx_skb->data, pkt_len);
+
+					pci_dma_sync_single_for_device(rrpriv->pci_dev,
+								       desc->addr.addrlo,
+								       pkt_len,
+								       PCI_DMA_FROMDEVICE);
+				}
+			}else{
+				struct sk_buff *newskb;
+
+				newskb = alloc_skb(dev->mtu + HIPPI_HLEN,
+					GFP_ATOMIC);
+				if (newskb){
+					dma_addr_t addr;
+
+	        			pci_unmap_single(rrpriv->pci_dev,
+						desc->addr.addrlo, dev->mtu +
+						HIPPI_HLEN, PCI_DMA_FROMDEVICE);
+					skb = rx_skb;
+					skb_put(skb, pkt_len);
+					rrpriv->rx_skbuff[index] = newskb;
+	        			addr = pci_map_single(rrpriv->pci_dev,
+						newskb->data,
+						dev->mtu + HIPPI_HLEN,
+						PCI_DMA_FROMDEVICE);
+					set_rraddr(&desc->addr, addr);
+				} else {
+					printk("%s: Out of memory, deferring "
+					       "packet\n", dev->name);
+					dev->stats.rx_dropped++;
+					goto defer;
+				}
+			}
+			skb->protocol = hippi_type_trans(skb, dev);
+
+			netif_rx(skb);		/* send it up */
+
+			dev->stats.rx_packets++;
+			dev->stats.rx_bytes += pkt_len;
+		}
+	defer:
+		desc->mode = 0;
+		desc->size = dev->mtu + HIPPI_HLEN;
+
+		if ((index & 7) == 7)
+			writel(index, &regs->IpRxPi);
+
+		index = (index + 1) % RX_RING_ENTRIES;
+	} while(index != rxlimit);
+
+	rrpriv->cur_rx = index;
+	wmb();
+}
+
+
+static irqreturn_t rr_interrupt(int irq, void *dev_id)
+{
+	struct rr_private *rrpriv;
+	struct rr_regs __iomem *regs;
+	struct net_device *dev = (struct net_device *)dev_id;
+	u32 prodidx, rxindex, eidx, txcsmr, rxlimit, txcon;
+
+	rrpriv = netdev_priv(dev);
+	regs = rrpriv->regs;
+
+	if (!(readl(&regs->HostCtrl) & RR_INT))
+		return IRQ_NONE;
+
+	spin_lock(&rrpriv->lock);
+
+	prodidx = readl(&regs->EvtPrd);
+	txcsmr = (prodidx >> 8) & 0xff;
+	rxlimit = (prodidx >> 16) & 0xff;
+	prodidx &= 0xff;
+
+#if (DEBUG > 2)
+	printk("%s: interrupt, prodidx = %i, eidx = %i\n", dev->name,
+	       prodidx, rrpriv->info->evt_ctrl.pi);
+#endif
+	/*
+	 * Order here is important.  We must handle events
+	 * before doing anything else in order to catch
+	 * such things as LLRC errors, etc -kbf
+	 */
+
+	eidx = rrpriv->info->evt_ctrl.pi;
+	if (prodidx != eidx)
+		eidx = rr_handle_event(dev, prodidx, eidx);
+
+	rxindex = rrpriv->cur_rx;
+	if (rxindex != rxlimit)
+		rx_int(dev, rxlimit, rxindex);
+
+	txcon = rrpriv->dirty_tx;
+	if (txcsmr != txcon) {
+		do {
+			/* Due to occational firmware TX producer/consumer out
+			 * of sync. error need to check entry in ring -kbf
+			 */
+			if(rrpriv->tx_skbuff[txcon]){
+				struct tx_desc *desc;
+				struct sk_buff *skb;
+
+				desc = &(rrpriv->tx_ring[txcon]);
+				skb = rrpriv->tx_skbuff[txcon];
+
+				dev->stats.tx_packets++;
+				dev->stats.tx_bytes += skb->len;
+
+				pci_unmap_single(rrpriv->pci_dev,
+						 desc->addr.addrlo, skb->len,
+						 PCI_DMA_TODEVICE);
+				dev_kfree_skb_irq(skb);
+
+				rrpriv->tx_skbuff[txcon] = NULL;
+				desc->size = 0;
+				set_rraddr(&rrpriv->tx_ring[txcon].addr, 0);
+				desc->mode = 0;
+			}
+			txcon = (txcon + 1) % TX_RING_ENTRIES;
+		} while (txcsmr != txcon);
+		wmb();
+
+		rrpriv->dirty_tx = txcon;
+		if (rrpriv->tx_full && rr_if_busy(dev) &&
+		    (((rrpriv->info->tx_ctrl.pi + 1) % TX_RING_ENTRIES)
+		     != rrpriv->dirty_tx)){
+			rrpriv->tx_full = 0;
+			netif_wake_queue(dev);
+		}
+	}
+
+	eidx |= ((txcsmr << 8) | (rxlimit << 16));
+	writel(eidx, &regs->EvtCon);
+	wmb();
+
+	spin_unlock(&rrpriv->lock);
+	return IRQ_HANDLED;
+}
+
+static inline void rr_raz_tx(struct rr_private *rrpriv,
+			     struct net_device *dev)
+{
+	int i;
+
+	for (i = 0; i < TX_RING_ENTRIES; i++) {
+		struct sk_buff *skb = rrpriv->tx_skbuff[i];
+
+		if (skb) {
+			struct tx_desc *desc = &(rrpriv->tx_ring[i]);
+
+	        	pci_unmap_single(rrpriv->pci_dev, desc->addr.addrlo,
+				skb->len, PCI_DMA_TODEVICE);
+			desc->size = 0;
+			set_rraddr(&desc->addr, 0);
+			dev_kfree_skb(skb);
+			rrpriv->tx_skbuff[i] = NULL;
+		}
+	}
+}
+
+
+static inline void rr_raz_rx(struct rr_private *rrpriv,
+			     struct net_device *dev)
+{
+	int i;
+
+	for (i = 0; i < RX_RING_ENTRIES; i++) {
+		struct sk_buff *skb = rrpriv->rx_skbuff[i];
+
+		if (skb) {
+			struct rx_desc *desc = &(rrpriv->rx_ring[i]);
+
+	        	pci_unmap_single(rrpriv->pci_dev, desc->addr.addrlo,
+				dev->mtu + HIPPI_HLEN, PCI_DMA_FROMDEVICE);
+			desc->size = 0;
+			set_rraddr(&desc->addr, 0);
+			dev_kfree_skb(skb);
+			rrpriv->rx_skbuff[i] = NULL;
+		}
+	}
+}
+
+static void rr_timer(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct rr_private *rrpriv = netdev_priv(dev);
+	struct rr_regs __iomem *regs = rrpriv->regs;
+	unsigned long flags;
+
+	if (readl(&regs->HostCtrl) & NIC_HALTED){
+		printk("%s: Restarting nic\n", dev->name);
+		memset(rrpriv->rx_ctrl, 0, 256 * sizeof(struct ring_ctrl));
+		memset(rrpriv->info, 0, sizeof(struct rr_info));
+		wmb();
+
+		rr_raz_tx(rrpriv, dev);
+		rr_raz_rx(rrpriv, dev);
+
+		if (rr_init1(dev)) {
+			spin_lock_irqsave(&rrpriv->lock, flags);
+			writel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,
+			       &regs->HostCtrl);
+			spin_unlock_irqrestore(&rrpriv->lock, flags);
+		}
+	}
+	rrpriv->timer.expires = RUN_AT(5*HZ);
+	add_timer(&rrpriv->timer);
+}
+
+
+static int rr_open(struct net_device *dev)
+{
+	struct rr_private *rrpriv = netdev_priv(dev);
+	struct pci_dev *pdev = rrpriv->pci_dev;
+	struct rr_regs __iomem *regs;
+	int ecode = 0;
+	unsigned long flags;
+	dma_addr_t dma_addr;
+
+	regs = rrpriv->regs;
+
+	if (rrpriv->fw_rev < 0x00020000) {
+		printk(KERN_WARNING "%s: trying to configure device with "
+		       "obsolete firmware\n", dev->name);
+		ecode = -EBUSY;
+		goto error;
+	}
+
+	rrpriv->rx_ctrl = pci_alloc_consistent(pdev,
+					       256 * sizeof(struct ring_ctrl),
+					       &dma_addr);
+	if (!rrpriv->rx_ctrl) {
+		ecode = -ENOMEM;
+		goto error;
+	}
+	rrpriv->rx_ctrl_dma = dma_addr;
+	memset(rrpriv->rx_ctrl, 0, 256*sizeof(struct ring_ctrl));
+
+	rrpriv->info = pci_alloc_consistent(pdev, sizeof(struct rr_info),
+					    &dma_addr);
+	if (!rrpriv->info) {
+		ecode = -ENOMEM;
+		goto error;
+	}
+	rrpriv->info_dma = dma_addr;
+	memset(rrpriv->info, 0, sizeof(struct rr_info));
+	wmb();
+
+	spin_lock_irqsave(&rrpriv->lock, flags);
+	writel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT, &regs->HostCtrl);
+	readl(&regs->HostCtrl);
+	spin_unlock_irqrestore(&rrpriv->lock, flags);
+
+	if (request_irq(dev->irq, rr_interrupt, IRQF_SHARED, dev->name, dev)) {
+		printk(KERN_WARNING "%s: Requested IRQ %d is busy\n",
+		       dev->name, dev->irq);
+		ecode = -EAGAIN;
+		goto error;
+	}
+
+	if ((ecode = rr_init1(dev)))
+		goto error;
+
+	/* Set the timer to switch to check for link beat and perhaps switch
+	   to an alternate media type. */
+	init_timer(&rrpriv->timer);
+	rrpriv->timer.expires = RUN_AT(5*HZ);           /* 5 sec. watchdog */
+	rrpriv->timer.data = (unsigned long)dev;
+	rrpriv->timer.function = rr_timer;               /* timer handler */
+	add_timer(&rrpriv->timer);
+
+	netif_start_queue(dev);
+
+	return ecode;
+
+ error:
+	spin_lock_irqsave(&rrpriv->lock, flags);
+	writel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT, &regs->HostCtrl);
+	spin_unlock_irqrestore(&rrpriv->lock, flags);
+
+	if (rrpriv->info) {
+		pci_free_consistent(pdev, sizeof(struct rr_info), rrpriv->info,
+				    rrpriv->info_dma);
+		rrpriv->info = NULL;
+	}
+	if (rrpriv->rx_ctrl) {
+		pci_free_consistent(pdev, sizeof(struct ring_ctrl),
+				    rrpriv->rx_ctrl, rrpriv->rx_ctrl_dma);
+		rrpriv->rx_ctrl = NULL;
+	}
+
+	netif_stop_queue(dev);
+
+	return ecode;
+}
+
+
+static void rr_dump(struct net_device *dev)
+{
+	struct rr_private *rrpriv;
+	struct rr_regs __iomem *regs;
+	u32 index, cons;
+	short i;
+	int len;
+
+	rrpriv = netdev_priv(dev);
+	regs = rrpriv->regs;
+
+	printk("%s: dumping NIC TX rings\n", dev->name);
+
+	printk("RxPrd %08x, TxPrd %02x, EvtPrd %08x, TxPi %02x, TxCtrlPi %02x\n",
+	       readl(&regs->RxPrd), readl(&regs->TxPrd),
+	       readl(&regs->EvtPrd), readl(&regs->TxPi),
+	       rrpriv->info->tx_ctrl.pi);
+
+	printk("Error code 0x%x\n", readl(&regs->Fail1));
+
+	index = (((readl(&regs->EvtPrd) >> 8) & 0xff) - 1) % TX_RING_ENTRIES;
+	cons = rrpriv->dirty_tx;
+	printk("TX ring index %i, TX consumer %i\n",
+	       index, cons);
+
+	if (rrpriv->tx_skbuff[index]){
+		len = min_t(int, 0x80, rrpriv->tx_skbuff[index]->len);
+		printk("skbuff for index %i is valid - dumping data (0x%x bytes - DMA len 0x%x)\n", index, len, rrpriv->tx_ring[index].size);
+		for (i = 0; i < len; i++){
+			if (!(i & 7))
+				printk("\n");
+			printk("%02x ", (unsigned char) rrpriv->tx_skbuff[index]->data[i]);
+		}
+		printk("\n");
+	}
+
+	if (rrpriv->tx_skbuff[cons]){
+		len = min_t(int, 0x80, rrpriv->tx_skbuff[cons]->len);
+		printk("skbuff for cons %i is valid - dumping data (0x%x bytes - skbuff len 0x%x)\n", cons, len, rrpriv->tx_skbuff[cons]->len);
+		printk("mode 0x%x, size 0x%x,\n phys %08Lx, skbuff-addr %08lx, truesize 0x%x\n",
+		       rrpriv->tx_ring[cons].mode,
+		       rrpriv->tx_ring[cons].size,
+		       (unsigned long long) rrpriv->tx_ring[cons].addr.addrlo,
+		       (unsigned long)rrpriv->tx_skbuff[cons]->data,
+		       (unsigned int)rrpriv->tx_skbuff[cons]->truesize);
+		for (i = 0; i < len; i++){
+			if (!(i & 7))
+				printk("\n");
+			printk("%02x ", (unsigned char)rrpriv->tx_ring[cons].size);
+		}
+		printk("\n");
+	}
+
+	printk("dumping TX ring info:\n");
+	for (i = 0; i < TX_RING_ENTRIES; i++)
+		printk("mode 0x%x, size 0x%x, phys-addr %08Lx\n",
+		       rrpriv->tx_ring[i].mode,
+		       rrpriv->tx_ring[i].size,
+		       (unsigned long long) rrpriv->tx_ring[i].addr.addrlo);
+
+}
+
+
+static int rr_close(struct net_device *dev)
+{
+	struct rr_private *rrpriv;
+	struct rr_regs __iomem *regs;
+	unsigned long flags;
+	u32 tmp;
+	short i;
+
+	netif_stop_queue(dev);
+
+	rrpriv = netdev_priv(dev);
+	regs = rrpriv->regs;
+
+	/*
+	 * Lock to make sure we are not cleaning up while another CPU
+	 * is handling interrupts.
+	 */
+	spin_lock_irqsave(&rrpriv->lock, flags);
+
+	tmp = readl(&regs->HostCtrl);
+	if (tmp & NIC_HALTED){
+		printk("%s: NIC already halted\n", dev->name);
+		rr_dump(dev);
+	}else{
+		tmp |= HALT_NIC | RR_CLEAR_INT;
+		writel(tmp, &regs->HostCtrl);
+		readl(&regs->HostCtrl);
+	}
+
+	rrpriv->fw_running = 0;
+
+	del_timer_sync(&rrpriv->timer);
+
+	writel(0, &regs->TxPi);
+	writel(0, &regs->IpRxPi);
+
+	writel(0, &regs->EvtCon);
+	writel(0, &regs->EvtPrd);
+
+	for (i = 0; i < CMD_RING_ENTRIES; i++)
+		writel(0, &regs->CmdRing[i]);
+
+	rrpriv->info->tx_ctrl.entries = 0;
+	rrpriv->info->cmd_ctrl.pi = 0;
+	rrpriv->info->evt_ctrl.pi = 0;
+	rrpriv->rx_ctrl[4].entries = 0;
+
+	rr_raz_tx(rrpriv, dev);
+	rr_raz_rx(rrpriv, dev);
+
+	pci_free_consistent(rrpriv->pci_dev, 256 * sizeof(struct ring_ctrl),
+			    rrpriv->rx_ctrl, rrpriv->rx_ctrl_dma);
+	rrpriv->rx_ctrl = NULL;
+
+	pci_free_consistent(rrpriv->pci_dev, sizeof(struct rr_info),
+			    rrpriv->info, rrpriv->info_dma);
+	rrpriv->info = NULL;
+
+	free_irq(dev->irq, dev);
+	spin_unlock_irqrestore(&rrpriv->lock, flags);
+
+	return 0;
+}
+
+
+static netdev_tx_t rr_start_xmit(struct sk_buff *skb,
+				 struct net_device *dev)
+{
+	struct rr_private *rrpriv = netdev_priv(dev);
+	struct rr_regs __iomem *regs = rrpriv->regs;
+	struct hippi_cb *hcb = (struct hippi_cb *) skb->cb;
+	struct ring_ctrl *txctrl;
+	unsigned long flags;
+	u32 index, len = skb->len;
+	u32 *ifield;
+	struct sk_buff *new_skb;
+
+	if (readl(&regs->Mode) & FATAL_ERR)
+		printk("error codes Fail1 %02x, Fail2 %02x\n",
+		       readl(&regs->Fail1), readl(&regs->Fail2));
+
+	/*
+	 * We probably need to deal with tbusy here to prevent overruns.
+	 */
+
+	if (skb_headroom(skb) < 8){
+		printk("incoming skb too small - reallocating\n");
+		if (!(new_skb = dev_alloc_skb(len + 8))) {
+			dev_kfree_skb(skb);
+			netif_wake_queue(dev);
+			return NETDEV_TX_OK;
+		}
+		skb_reserve(new_skb, 8);
+		skb_put(new_skb, len);
+		skb_copy_from_linear_data(skb, new_skb->data, len);
+		dev_kfree_skb(skb);
+		skb = new_skb;
+	}
+
+	ifield = (u32 *)skb_push(skb, 8);
+
+	ifield[0] = 0;
+	ifield[1] = hcb->ifield;
+
+	/*
+	 * We don't need the lock before we are actually going to start
+	 * fiddling with the control blocks.
+	 */
+	spin_lock_irqsave(&rrpriv->lock, flags);
+
+	txctrl = &rrpriv->info->tx_ctrl;
+
+	index = txctrl->pi;
+
+	rrpriv->tx_skbuff[index] = skb;
+	set_rraddr(&rrpriv->tx_ring[index].addr, pci_map_single(
+		rrpriv->pci_dev, skb->data, len + 8, PCI_DMA_TODEVICE));
+	rrpriv->tx_ring[index].size = len + 8; /* include IFIELD */
+	rrpriv->tx_ring[index].mode = PACKET_START | PACKET_END;
+	txctrl->pi = (index + 1) % TX_RING_ENTRIES;
+	wmb();
+	writel(txctrl->pi, &regs->TxPi);
+
+	if (txctrl->pi == rrpriv->dirty_tx){
+		rrpriv->tx_full = 1;
+		netif_stop_queue(dev);
+	}
+
+	spin_unlock_irqrestore(&rrpriv->lock, flags);
+
+	return NETDEV_TX_OK;
+}
+
+
+/*
+ * Read the firmware out of the EEPROM and put it into the SRAM
+ * (or from user space - later)
+ *
+ * This operation requires the NIC to be halted and is performed with
+ * interrupts disabled and with the spinlock hold.
+ */
+static int rr_load_firmware(struct net_device *dev)
+{
+	struct rr_private *rrpriv;
+	struct rr_regs __iomem *regs;
+	size_t eptr, segptr;
+	int i, j;
+	u32 localctrl, sptr, len, tmp;
+	u32 p2len, p2size, nr_seg, revision, io, sram_size;
+
+	rrpriv = netdev_priv(dev);
+	regs = rrpriv->regs;
+
+	if (dev->flags & IFF_UP)
+		return -EBUSY;
+
+	if (!(readl(&regs->HostCtrl) & NIC_HALTED)){
+		printk("%s: Trying to load firmware to a running NIC.\n",
+		       dev->name);
+		return -EBUSY;
+	}
+
+	localctrl = readl(&regs->LocalCtrl);
+	writel(0, &regs->LocalCtrl);
+
+	writel(0, &regs->EvtPrd);
+	writel(0, &regs->RxPrd);
+	writel(0, &regs->TxPrd);
+
+	/*
+	 * First wipe the entire SRAM, otherwise we might run into all
+	 * kinds of trouble ... sigh, this took almost all afternoon
+	 * to track down ;-(
+	 */
+	io = readl(&regs->ExtIo);
+	writel(0, &regs->ExtIo);
+	sram_size = rr_read_eeprom_word(rrpriv, 8);
+
+	for (i = 200; i < sram_size / 4; i++){
+		writel(i * 4, &regs->WinBase);
+		mb();
+		writel(0, &regs->WinData);
+		mb();
+	}
+	writel(io, &regs->ExtIo);
+	mb();
+
+	eptr = rr_read_eeprom_word(rrpriv,
+		       offsetof(struct eeprom, rncd_info.AddrRunCodeSegs));
+	eptr = ((eptr & 0x1fffff) >> 3);
+
+	p2len = rr_read_eeprom_word(rrpriv, 0x83*4);
+	p2len = (p2len << 2);
+	p2size = rr_read_eeprom_word(rrpriv, 0x84*4);
+	p2size = ((p2size & 0x1fffff) >> 3);
+
+	if ((eptr < p2size) || (eptr > (p2size + p2len))){
+		printk("%s: eptr is invalid\n", dev->name);
+		goto out;
+	}
+
+	revision = rr_read_eeprom_word(rrpriv,
+			offsetof(struct eeprom, manf.HeaderFmt));
+
+	if (revision != 1){
+		printk("%s: invalid firmware format (%i)\n",
+		       dev->name, revision);
+		goto out;
+	}
+
+	nr_seg = rr_read_eeprom_word(rrpriv, eptr);
+	eptr +=4;
+#if (DEBUG > 1)
+	printk("%s: nr_seg %i\n", dev->name, nr_seg);
+#endif
+
+	for (i = 0; i < nr_seg; i++){
+		sptr = rr_read_eeprom_word(rrpriv, eptr);
+		eptr += 4;
+		len = rr_read_eeprom_word(rrpriv, eptr);
+		eptr += 4;
+		segptr = rr_read_eeprom_word(rrpriv, eptr);
+		segptr = ((segptr & 0x1fffff) >> 3);
+		eptr += 4;
+#if (DEBUG > 1)
+		printk("%s: segment %i, sram address %06x, length %04x, segptr %06x\n",
+		       dev->name, i, sptr, len, segptr);
+#endif
+		for (j = 0; j < len; j++){
+			tmp = rr_read_eeprom_word(rrpriv, segptr);
+			writel(sptr, &regs->WinBase);
+			mb();
+			writel(tmp, &regs->WinData);
+			mb();
+			segptr += 4;
+			sptr += 4;
+		}
+	}
+
+out:
+	writel(localctrl, &regs->LocalCtrl);
+	mb();
+	return 0;
+}
+
+
+static int rr_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct rr_private *rrpriv;
+	unsigned char *image, *oldimage;
+	unsigned long flags;
+	unsigned int i;
+	int error = -EOPNOTSUPP;
+
+	rrpriv = netdev_priv(dev);
+
+	switch(cmd){
+	case SIOCRRGFW:
+		if (!capable(CAP_SYS_RAWIO)){
+			return -EPERM;
+		}
+
+		image = kmalloc(EEPROM_WORDS * sizeof(u32), GFP_KERNEL);
+		if (!image){
+			printk(KERN_ERR "%s: Unable to allocate memory "
+			       "for EEPROM image\n", dev->name);
+			return -ENOMEM;
+		}
+
+
+		if (rrpriv->fw_running){
+			printk("%s: Firmware already running\n", dev->name);
+			error = -EPERM;
+			goto gf_out;
+		}
+
+		spin_lock_irqsave(&rrpriv->lock, flags);
+		i = rr_read_eeprom(rrpriv, 0, image, EEPROM_BYTES);
+		spin_unlock_irqrestore(&rrpriv->lock, flags);
+		if (i != EEPROM_BYTES){
+			printk(KERN_ERR "%s: Error reading EEPROM\n",
+			       dev->name);
+			error = -EFAULT;
+			goto gf_out;
+		}
+		error = copy_to_user(rq->ifr_data, image, EEPROM_BYTES);
+		if (error)
+			error = -EFAULT;
+	gf_out:
+		kfree(image);
+		return error;
+
+	case SIOCRRPFW:
+		if (!capable(CAP_SYS_RAWIO)){
+			return -EPERM;
+		}
+
+		image = kmalloc(EEPROM_WORDS * sizeof(u32), GFP_KERNEL);
+		oldimage = kmalloc(EEPROM_WORDS * sizeof(u32), GFP_KERNEL);
+		if (!image || !oldimage) {
+			printk(KERN_ERR "%s: Unable to allocate memory "
+			       "for EEPROM image\n", dev->name);
+			error = -ENOMEM;
+			goto wf_out;
+		}
+
+		error = copy_from_user(image, rq->ifr_data, EEPROM_BYTES);
+		if (error) {
+			error = -EFAULT;
+			goto wf_out;
+		}
+
+		if (rrpriv->fw_running){
+			printk("%s: Firmware already running\n", dev->name);
+			error = -EPERM;
+			goto wf_out;
+		}
+
+		printk("%s: Updating EEPROM firmware\n", dev->name);
+
+		spin_lock_irqsave(&rrpriv->lock, flags);
+		error = write_eeprom(rrpriv, 0, image, EEPROM_BYTES);
+		if (error)
+			printk(KERN_ERR "%s: Error writing EEPROM\n",
+			       dev->name);
+
+		i = rr_read_eeprom(rrpriv, 0, oldimage, EEPROM_BYTES);
+		spin_unlock_irqrestore(&rrpriv->lock, flags);
+
+		if (i != EEPROM_BYTES)
+			printk(KERN_ERR "%s: Error reading back EEPROM "
+			       "image\n", dev->name);
+
+		error = memcmp(image, oldimage, EEPROM_BYTES);
+		if (error){
+			printk(KERN_ERR "%s: Error verifying EEPROM image\n",
+			       dev->name);
+			error = -EFAULT;
+		}
+	wf_out:
+		kfree(oldimage);
+		kfree(image);
+		return error;
+
+	case SIOCRRID:
+		return put_user(0x52523032, (int __user *)rq->ifr_data);
+	default:
+		return error;
+	}
+}
+
+static DEFINE_PCI_DEVICE_TABLE(rr_pci_tbl) = {
+	{ PCI_VENDOR_ID_ESSENTIAL, PCI_DEVICE_ID_ESSENTIAL_ROADRUNNER,
+		PCI_ANY_ID, PCI_ANY_ID, },
+	{ 0,}
+};
+MODULE_DEVICE_TABLE(pci, rr_pci_tbl);
+
+static struct pci_driver rr_driver = {
+	.name		= "rrunner",
+	.id_table	= rr_pci_tbl,
+	.probe		= rr_init_one,
+	.remove		= __devexit_p(rr_remove_one),
+};
+
+static int __init rr_init_module(void)
+{
+	return pci_register_driver(&rr_driver);
+}
+
+static void __exit rr_cleanup_module(void)
+{
+	pci_unregister_driver(&rr_driver);
+}
+
+module_init(rr_init_module);
+module_exit(rr_cleanup_module);
