commit 53efdc9cb9e6a6f693a81da005280df92b813933
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Thu Mar 19 18:06:17 2020 -0500

    wl3501_cs: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/20200319230617.GA15035@embeddedor.com

diff --git a/drivers/net/wireless/wl3501.h b/drivers/net/wireless/wl3501.h
index efdce9ae36ea..b446cb369557 100644
--- a/drivers/net/wireless/wl3501.h
+++ b/drivers/net/wireless/wl3501.h
@@ -231,7 +231,7 @@ struct iw_mgmt_info_element {
 	u8 id; /* one of enum iw_mgmt_info_element_ids,
 		  but sizeof(enum) > sizeof(u8) :-( */
 	u8 len;
-	u8 data[0];
+	u8 data[];
 } __packed;
 
 struct iw_mgmt_essid_pset {

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/wireless/wl3501.h b/drivers/net/wireless/wl3501.h
index 3fbfd19818f1..efdce9ae36ea 100644
--- a/drivers/net/wireless/wl3501.h
+++ b/drivers/net/wireless/wl3501.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __WL3501_H__
 #define __WL3501_H__
 

commit ba2d3587912f82d1ab4367975b1df460db60fb1e
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Wed Jun 2 18:10:09 2010 +0000

    drivers/net: use __packed annotation
    
    cleanup patch.
    
    Use new __packed annotation in drivers/net/
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/wl3501.h b/drivers/net/wireless/wl3501.h
index 8816e371fd0e..3fbfd19818f1 100644
--- a/drivers/net/wireless/wl3501.h
+++ b/drivers/net/wireless/wl3501.h
@@ -231,12 +231,12 @@ struct iw_mgmt_info_element {
 		  but sizeof(enum) > sizeof(u8) :-( */
 	u8 len;
 	u8 data[0];
-} __attribute__ ((packed));
+} __packed;
 
 struct iw_mgmt_essid_pset {
 	struct iw_mgmt_info_element el;
 	u8 			    essid[IW_ESSID_MAX_SIZE];
-} __attribute__ ((packed));
+} __packed;
 
 /*
  * According to 802.11 Wireless Netowors, the definitive guide - O'Reilly
@@ -247,12 +247,12 @@ struct iw_mgmt_essid_pset {
 struct iw_mgmt_data_rset {
 	struct iw_mgmt_info_element el;
 	u8 			    data_rate_labels[IW_DATA_RATE_MAX_LABELS];
-} __attribute__ ((packed));
+} __packed;
 
 struct iw_mgmt_ds_pset {
 	struct iw_mgmt_info_element el;
 	u8 			    chan;
-} __attribute__ ((packed));
+} __packed;
 
 struct iw_mgmt_cf_pset {
 	struct iw_mgmt_info_element el;
@@ -260,12 +260,12 @@ struct iw_mgmt_cf_pset {
 	u8 			    cfp_period;
 	u16 			    cfp_max_duration;
 	u16 			    cfp_dur_remaining;
-} __attribute__ ((packed));
+} __packed;
 
 struct iw_mgmt_ibss_pset {
 	struct iw_mgmt_info_element el;
 	u16 			    atim_window;
-} __attribute__ ((packed));
+} __packed;
 
 struct wl3501_tx_hdr {
 	u16	tx_cnt;
@@ -544,12 +544,12 @@ struct wl3501_80211_tx_plcp_hdr {
 	u8	service;
 	u16	len;
 	u16	crc16;
-} __attribute__ ((packed));
+} __packed;
 
 struct wl3501_80211_tx_hdr {
 	struct wl3501_80211_tx_plcp_hdr	pclp_hdr;
 	struct ieee80211_hdr		mac_hdr;
-} __attribute__ ((packed));
+} __packed;
 
 /*
    Reserve the beginning Tx space for descriptor use.

commit c7c2fa079073ab92b0736a161b4cf1051a3e631f
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sat Mar 20 19:39:26 2010 +0100

    pcmcia: dev_node removal (drivers with unregister_netdev check)
    
    As a third step, remove any usage of dev_node_t from drivers which
    only wrote to this typedef/struct, except to determine whether
    register_netdev() succeeded previously. However, the function calling
    unregister_netdev() was only ever called by the PCMCIA core if
    register_netdev() succeeded previously. The lonely exception was
    easily fixed.
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/wl3501.h b/drivers/net/wireless/wl3501.h
index 8bce1a550a22..8816e371fd0e 100644
--- a/drivers/net/wireless/wl3501.h
+++ b/drivers/net/wireless/wl3501.h
@@ -610,7 +610,6 @@ struct wl3501_card {
 	struct iw_statistics		wstats;
 	struct iw_spy_data		spy_data;
 	struct iw_public_data		wireless_data;
-	struct dev_node_t		node;
 	struct pcmcia_device		*p_dev;
 };
 #endif

commit 4255d411452f1fe4dbcb2de4de35a7a028c5415a
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Fri Mar 20 19:36:29 2009 +0000

    wl3501: convert to internal net_device_stats
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/wl3501.h b/drivers/net/wireless/wl3501.h
index 59bb3a55ab48..8bce1a550a22 100644
--- a/drivers/net/wireless/wl3501.h
+++ b/drivers/net/wireless/wl3501.h
@@ -606,7 +606,7 @@ struct wl3501_card {
 	u8				reg_domain;
 	u8				version[2];
 	struct wl3501_scan_confirm	bss_set[20];
-	struct net_device_stats 	stats;
+
 	struct iw_statistics		wstats;
 	struct iw_spy_data		spy_data;
 	struct iw_public_data		wireless_data;

commit 2c706002fc147decdba2658ea48e4436faca3af2
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu Oct 30 22:09:54 2008 +0100

    don't use net/ieee80211.h
    
    Convert all the drivers using net/ieee80211.h to use linux/ieee80211.h.
    Contains a bugfix in libertas where the SSID parsing could overrun the
    buffer when the AP sends invalid information.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Acked-by: Dan Williams <dcbw@redhat.com> [airo, libertas]
    Acked-by: Pavel Roskin <proski@gnu.org> [orinoco]
    Acked-by: David Kilroy <kilroyd@googlemail.com> [orinoco]
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/wl3501.h b/drivers/net/wireless/wl3501.h
index 65ceb088f700..59bb3a55ab48 100644
--- a/drivers/net/wireless/wl3501.h
+++ b/drivers/net/wireless/wl3501.h
@@ -2,7 +2,7 @@
 #define __WL3501_H__
 
 #include <linux/spinlock.h>
-#include <net/ieee80211.h>
+#include <linux/ieee80211.h>
 
 /* define for WLA 2.0 */
 #define WL3501_BLKSZ 256
@@ -548,7 +548,7 @@ struct wl3501_80211_tx_plcp_hdr {
 
 struct wl3501_80211_tx_hdr {
 	struct wl3501_80211_tx_plcp_hdr	pclp_hdr;
-	struct ieee80211_hdr_4addr		mac_hdr;
+	struct ieee80211_hdr		mac_hdr;
 } __attribute__ ((packed));
 
 /*

commit fd238232cd0ff4840ae6946bb338502154096d88
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 5 10:45:09 2006 +0100

    [PATCH] pcmcia: embed dev_link_t into struct pcmcia_device
    
    Embed dev_link_t into struct pcmcia_device(), as they basically address the
    same entity. The actual contents of dev_link_t will be cleaned up step by step.
    This patch includes a bugfix from and signed-off-by Andrew Morton.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/wl3501.h b/drivers/net/wireless/wl3501.h
index 4303c50c2ab6..65ceb088f700 100644
--- a/drivers/net/wireless/wl3501.h
+++ b/drivers/net/wireless/wl3501.h
@@ -611,5 +611,6 @@ struct wl3501_card {
 	struct iw_spy_data		spy_data;
 	struct iw_public_data		wireless_data;
 	struct dev_node_t		node;
+	struct pcmcia_device		*p_dev;
 };
 #endif

commit af9288a707b609cdb1069cfe5bde0d6567c12c31
Author: James Ketrenos <jketreno@linux.intel.com>
Date:   Thu Sep 22 15:43:07 2005 -0400

    ieee80211: update orinoco, wl3501 drivers for latest struct naming

diff --git a/drivers/net/wireless/wl3501.h b/drivers/net/wireless/wl3501.h
index 7fcbe589c3f2..4303c50c2ab6 100644
--- a/drivers/net/wireless/wl3501.h
+++ b/drivers/net/wireless/wl3501.h
@@ -548,7 +548,7 @@ struct wl3501_80211_tx_plcp_hdr {
 
 struct wl3501_80211_tx_hdr {
 	struct wl3501_80211_tx_plcp_hdr	pclp_hdr;
-	struct ieee80211_hdr		mac_hdr;
+	struct ieee80211_hdr_4addr		mac_hdr;
 } __attribute__ ((packed));
 
 /*

commit 00b309f561e9746fd6ac9598c4203c6610fcb26c
Author: Jean Tourrilhes <jt@hpl.hp.com>
Date:   Fri Sep 2 11:37:38 2005 -0700

    [PATCH] wl3501_cs : WE-17 support
    
            wl3501_cs won't compile with WE-19. This patches fixes it.
    
    Signed-off-by: Jean Tourrilhes <jt@hpl.hp.com>
    Acked-by: Arnaldo Carvalho de Melo <acme@conectiva.com.br>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/drivers/net/wireless/wl3501.h b/drivers/net/wireless/wl3501.h
index b5719437e981..7fcbe589c3f2 100644
--- a/drivers/net/wireless/wl3501.h
+++ b/drivers/net/wireless/wl3501.h
@@ -609,6 +609,7 @@ struct wl3501_card {
 	struct net_device_stats 	stats;
 	struct iw_statistics		wstats;
 	struct iw_spy_data		spy_data;
+	struct iw_public_data		wireless_data;
 	struct dev_node_t		node;
 };
 #endif

commit b453872c35cfcbdbf5a794737817f7d4e7b1b579
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Thu May 12 22:48:20 2005 -0400

    [NET] ieee80211 subsystem
    
    Contributors:
    Host AP contributors
    James Ketrenos <jketreno@linux.intel.com>
    Francois Romieu <romieu@fr.zoreil.com>
    Adrian Bunk <bunk@stusta.de>
    Matthew Galgoci <mgalgoci@parcelfarce.linux.th
    eplanet.co.uk>

diff --git a/drivers/net/wireless/wl3501.h b/drivers/net/wireless/wl3501.h
index 8636d9306785..b5719437e981 100644
--- a/drivers/net/wireless/wl3501.h
+++ b/drivers/net/wireless/wl3501.h
@@ -2,7 +2,7 @@
 #define __WL3501_H__
 
 #include <linux/spinlock.h>
-#include "ieee802_11.h"
+#include <net/ieee80211.h>
 
 /* define for WLA 2.0 */
 #define WL3501_BLKSZ 256
@@ -548,7 +548,7 @@ struct wl3501_80211_tx_plcp_hdr {
 
 struct wl3501_80211_tx_hdr {
 	struct wl3501_80211_tx_plcp_hdr	pclp_hdr;
-	struct ieee802_11_hdr		mac_hdr;
+	struct ieee80211_hdr		mac_hdr;
 } __attribute__ ((packed));
 
 /*

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/net/wireless/wl3501.h b/drivers/net/wireless/wl3501.h
new file mode 100644
index 000000000000..8636d9306785
--- /dev/null
+++ b/drivers/net/wireless/wl3501.h
@@ -0,0 +1,614 @@
+#ifndef __WL3501_H__
+#define __WL3501_H__
+
+#include <linux/spinlock.h>
+#include "ieee802_11.h"
+
+/* define for WLA 2.0 */
+#define WL3501_BLKSZ 256
+/*
+ * ID for input Signals of DRIVER block
+ * bit[7-5] is block ID: 000
+ * bit[4-0] is signal ID
+*/
+enum wl3501_signals {
+	WL3501_SIG_ALARM,
+	WL3501_SIG_MD_CONFIRM,
+	WL3501_SIG_MD_IND,
+	WL3501_SIG_ASSOC_CONFIRM,
+	WL3501_SIG_ASSOC_IND,
+	WL3501_SIG_AUTH_CONFIRM,
+	WL3501_SIG_AUTH_IND,
+	WL3501_SIG_DEAUTH_CONFIRM,
+	WL3501_SIG_DEAUTH_IND,
+	WL3501_SIG_DISASSOC_CONFIRM,
+	WL3501_SIG_DISASSOC_IND,
+	WL3501_SIG_GET_CONFIRM,
+	WL3501_SIG_JOIN_CONFIRM,
+	WL3501_SIG_PWR_MGMT_CONFIRM,
+	WL3501_SIG_REASSOC_CONFIRM,
+	WL3501_SIG_REASSOC_IND,
+	WL3501_SIG_SCAN_CONFIRM,
+	WL3501_SIG_SET_CONFIRM,
+	WL3501_SIG_START_CONFIRM,
+	WL3501_SIG_RESYNC_CONFIRM,
+	WL3501_SIG_SITE_CONFIRM,
+	WL3501_SIG_SAVE_CONFIRM,
+	WL3501_SIG_RFTEST_CONFIRM,
+/*
+ * ID for input Signals of MLME block
+ * bit[7-5] is block ID: 010
+ * bit[4-0] is signal ID
+ */
+	WL3501_SIG_ASSOC_REQ = 0x20,
+	WL3501_SIG_AUTH_REQ,
+	WL3501_SIG_DEAUTH_REQ,
+	WL3501_SIG_DISASSOC_REQ,
+	WL3501_SIG_GET_REQ,
+	WL3501_SIG_JOIN_REQ,
+	WL3501_SIG_PWR_MGMT_REQ,
+	WL3501_SIG_REASSOC_REQ,
+	WL3501_SIG_SCAN_REQ,
+	WL3501_SIG_SET_REQ,
+	WL3501_SIG_START_REQ,
+	WL3501_SIG_MD_REQ,
+	WL3501_SIG_RESYNC_REQ,
+	WL3501_SIG_SITE_REQ,
+	WL3501_SIG_SAVE_REQ,
+	WL3501_SIG_RF_TEST_REQ,
+	WL3501_SIG_MM_CONFIRM = 0x60,
+	WL3501_SIG_MM_IND,
+};
+
+enum wl3501_mib_attribs {
+	WL3501_MIB_ATTR_STATION_ID,
+	WL3501_MIB_ATTR_AUTH_ALGORITHMS,
+	WL3501_MIB_ATTR_AUTH_TYPE,
+	WL3501_MIB_ATTR_MEDIUM_OCCUPANCY_LIMIT,
+	WL3501_MIB_ATTR_CF_POLLABLE,
+	WL3501_MIB_ATTR_CFP_PERIOD,
+	WL3501_MIB_ATTR_CFPMAX_DURATION,
+	WL3501_MIB_ATTR_AUTH_RESP_TMOUT,
+	WL3501_MIB_ATTR_RX_DTIMS,
+	WL3501_MIB_ATTR_PRIV_OPT_IMPLEMENTED,
+	WL3501_MIB_ATTR_PRIV_INVOKED,
+	WL3501_MIB_ATTR_WEP_DEFAULT_KEYS,
+	WL3501_MIB_ATTR_WEP_DEFAULT_KEY_ID,
+	WL3501_MIB_ATTR_WEP_KEY_MAPPINGS,
+	WL3501_MIB_ATTR_WEP_KEY_MAPPINGS_LEN,
+	WL3501_MIB_ATTR_EXCLUDE_UNENCRYPTED,
+	WL3501_MIB_ATTR_WEP_ICV_ERROR_COUNT,
+	WL3501_MIB_ATTR_WEP_UNDECRYPTABLE_COUNT,
+	WL3501_MIB_ATTR_WEP_EXCLUDED_COUNT,
+	WL3501_MIB_ATTR_MAC_ADDR,
+	WL3501_MIB_ATTR_GROUP_ADDRS,
+	WL3501_MIB_ATTR_RTS_THRESHOLD,
+	WL3501_MIB_ATTR_SHORT_RETRY_LIMIT,
+	WL3501_MIB_ATTR_LONG_RETRY_LIMIT,
+	WL3501_MIB_ATTR_FRAG_THRESHOLD,
+	WL3501_MIB_ATTR_MAX_TX_MSDU_LIFETIME,
+	WL3501_MIB_ATTR_MAX_RX_LIFETIME,
+	WL3501_MIB_ATTR_MANUFACTURER_ID,
+	WL3501_MIB_ATTR_PRODUCT_ID,
+	WL3501_MIB_ATTR_TX_FRAG_COUNT,
+	WL3501_MIB_ATTR_MULTICAST_TX_FRAME_COUNT,
+	WL3501_MIB_ATTR_FAILED_COUNT,
+	WL3501_MIB_ATTR_RX_FRAG_COUNT,
+	WL3501_MIB_ATTR_MULTICAST_RX_COUNT,
+	WL3501_MIB_ATTR_FCS_ERROR_COUNT,
+	WL3501_MIB_ATTR_RETRY_COUNT,
+	WL3501_MIB_ATTR_MULTIPLE_RETRY_COUNT,
+	WL3501_MIB_ATTR_RTS_SUCCESS_COUNT,
+	WL3501_MIB_ATTR_RTS_FAILURE_COUNT,
+	WL3501_MIB_ATTR_ACK_FAILURE_COUNT,
+	WL3501_MIB_ATTR_FRAME_DUPLICATE_COUNT,
+	WL3501_MIB_ATTR_PHY_TYPE,
+	WL3501_MIB_ATTR_REG_DOMAINS_SUPPORT,
+	WL3501_MIB_ATTR_CURRENT_REG_DOMAIN,
+	WL3501_MIB_ATTR_SLOT_TIME,
+	WL3501_MIB_ATTR_CCA_TIME,
+	WL3501_MIB_ATTR_RX_TX_TURNAROUND_TIME,
+	WL3501_MIB_ATTR_TX_PLCP_DELAY,
+	WL3501_MIB_ATTR_RX_TX_SWITCH_TIME,
+	WL3501_MIB_ATTR_TX_RAMP_ON_TIME,
+	WL3501_MIB_ATTR_TX_RF_DELAY,
+	WL3501_MIB_ATTR_SIFS_TIME,
+	WL3501_MIB_ATTR_RX_RF_DELAY,
+	WL3501_MIB_ATTR_RX_PLCP_DELAY,
+	WL3501_MIB_ATTR_MAC_PROCESSING_DELAY,
+	WL3501_MIB_ATTR_TX_RAMP_OFF_TIME,
+	WL3501_MIB_ATTR_PREAMBLE_LEN,
+	WL3501_MIB_ATTR_PLCP_HEADER_LEN,
+	WL3501_MIB_ATTR_MPDU_DURATION_FACTOR,
+	WL3501_MIB_ATTR_AIR_PROPAGATION_TIME,
+	WL3501_MIB_ATTR_TEMP_TYPE,
+	WL3501_MIB_ATTR_CW_MIN,
+	WL3501_MIB_ATTR_CW_MAX,
+	WL3501_MIB_ATTR_SUPPORT_DATA_RATES_TX,
+	WL3501_MIB_ATTR_SUPPORT_DATA_RATES_RX,
+	WL3501_MIB_ATTR_MPDU_MAX_LEN,
+	WL3501_MIB_ATTR_SUPPORT_TX_ANTENNAS,
+	WL3501_MIB_ATTR_CURRENT_TX_ANTENNA,
+	WL3501_MIB_ATTR_SUPPORT_RX_ANTENNAS,
+	WL3501_MIB_ATTR_DIVERSITY_SUPPORT,
+	WL3501_MIB_ATTR_DIVERSITY_SELECTION_RS,
+	WL3501_MIB_ATTR_NR_SUPPORTED_PWR_LEVELS,
+	WL3501_MIB_ATTR_TX_PWR_LEVEL1,
+	WL3501_MIB_ATTR_TX_PWR_LEVEL2,
+	WL3501_MIB_ATTR_TX_PWR_LEVEL3,
+	WL3501_MIB_ATTR_TX_PWR_LEVEL4,
+	WL3501_MIB_ATTR_TX_PWR_LEVEL5,
+	WL3501_MIB_ATTR_TX_PWR_LEVEL6,
+	WL3501_MIB_ATTR_TX_PWR_LEVEL7,
+	WL3501_MIB_ATTR_TX_PWR_LEVEL8,
+	WL3501_MIB_ATTR_CURRENT_TX_PWR_LEVEL,
+	WL3501_MIB_ATTR_CURRENT_CHAN,
+	WL3501_MIB_ATTR_CCA_MODE_SUPPORTED,
+	WL3501_MIB_ATTR_CURRENT_CCA_MODE,
+	WL3501_MIB_ATTR_ED_THRESHOLD,
+	WL3501_MIB_ATTR_SINTHESIZER_LOCKED,
+	WL3501_MIB_ATTR_CURRENT_PWR_STATE,
+	WL3501_MIB_ATTR_DOZE_TURNON_TIME,
+	WL3501_MIB_ATTR_RCR33,
+	WL3501_MIB_ATTR_DEFAULT_CHAN,
+	WL3501_MIB_ATTR_SSID,
+	WL3501_MIB_ATTR_PWR_MGMT_ENABLE,
+	WL3501_MIB_ATTR_NET_CAPABILITY,
+	WL3501_MIB_ATTR_ROUTING,
+};
+
+enum wl3501_net_type {
+	WL3501_NET_TYPE_INFRA,
+	WL3501_NET_TYPE_ADHOC,
+	WL3501_NET_TYPE_ANY_BSS,
+};
+
+enum wl3501_scan_type {
+	WL3501_SCAN_TYPE_ACTIVE,
+	WL3501_SCAN_TYPE_PASSIVE,
+};
+
+enum wl3501_tx_result {
+	WL3501_TX_RESULT_SUCCESS,
+	WL3501_TX_RESULT_NO_BSS,
+	WL3501_TX_RESULT_RETRY_LIMIT,
+};
+
+enum wl3501_sys_type {
+	WL3501_SYS_TYPE_OPEN,
+	WL3501_SYS_TYPE_SHARE_KEY,
+};
+
+enum wl3501_status {
+	WL3501_STATUS_SUCCESS,
+	WL3501_STATUS_INVALID,
+	WL3501_STATUS_TIMEOUT,
+	WL3501_STATUS_REFUSED,
+	WL3501_STATUS_MANY_REQ,
+	WL3501_STATUS_ALREADY_BSS,
+};
+
+#define WL3501_MGMT_CAPABILITY_ESS		0x0001  /* see 802.11 p.58 */
+#define WL3501_MGMT_CAPABILITY_IBSS		0x0002  /*      - " -	   */
+#define WL3501_MGMT_CAPABILITY_CF_POLLABLE	0x0004  /*      - " -	   */
+#define WL3501_MGMT_CAPABILITY_CF_POLL_REQUEST	0x0008  /*      - " -	   */
+#define WL3501_MGMT_CAPABILITY_PRIVACY		0x0010  /*      - " -	   */
+
+#define IW_REG_DOMAIN_FCC	0x10	/* Channel 1 to 11	USA    */
+#define IW_REG_DOMAIN_DOC	0x20	/* Channel 1 to 11	Canada */
+#define IW_REG_DOMAIN_ETSI	0x30	/* Channel 1 to 13	Europe */
+#define IW_REG_DOMAIN_SPAIN	0x31	/* Channel 10 to 11	Spain  */
+#define IW_REG_DOMAIN_FRANCE	0x32	/* Channel 10 to 13	France */
+#define IW_REG_DOMAIN_MKK	0x40	/* Channel 14		Japan  */
+#define IW_REG_DOMAIN_MKK1	0x41	/* Channel 1-14		Japan  */
+#define IW_REG_DOMAIN_ISRAEL	0x50	/* Channel 3 - 9	Israel */
+
+#define IW_MGMT_RATE_LABEL_MANDATORY 128 /* MSB */
+
+enum iw_mgmt_rate_labels {
+	IW_MGMT_RATE_LABEL_1MBIT   = 2,
+	IW_MGMT_RATE_LABEL_2MBIT   = 4,
+	IW_MGMT_RATE_LABEL_5_5MBIT = 11,
+	IW_MGMT_RATE_LABEL_11MBIT  = 22,
+};
+
+enum iw_mgmt_info_element_ids {
+	IW_MGMT_INFO_ELEMENT_SSID,		  /* Service Set Identity */
+	IW_MGMT_INFO_ELEMENT_SUPPORTED_RATES,
+	IW_MGMT_INFO_ELEMENT_FH_PARAMETER_SET,
+	IW_MGMT_INFO_ELEMENT_DS_PARAMETER_SET,
+	IW_MGMT_INFO_ELEMENT_CS_PARAMETER_SET,
+	IW_MGMT_INFO_ELEMENT_CS_TIM,		  /* Traffic Information Map */
+	IW_MGMT_INFO_ELEMENT_IBSS_PARAMETER_SET,
+	/* 7-15: Reserved, unused */
+	IW_MGMT_INFO_ELEMENT_CHALLENGE_TEXT = 16,
+	/* 17-31 Reserved for challenge text extension */
+	/* 32-255 Reserved, unused */
+};
+
+struct iw_mgmt_info_element {
+	u8 id; /* one of enum iw_mgmt_info_element_ids,
+		  but sizeof(enum) > sizeof(u8) :-( */
+	u8 len;
+	u8 data[0];
+} __attribute__ ((packed));
+
+struct iw_mgmt_essid_pset {
+	struct iw_mgmt_info_element el;
+	u8 			    essid[IW_ESSID_MAX_SIZE];
+} __attribute__ ((packed));
+
+/*
+ * According to 802.11 Wireless Netowors, the definitive guide - O'Reilly
+ * Pg 75
+ */ 
+#define IW_DATA_RATE_MAX_LABELS 8
+
+struct iw_mgmt_data_rset {
+	struct iw_mgmt_info_element el;
+	u8 			    data_rate_labels[IW_DATA_RATE_MAX_LABELS];
+} __attribute__ ((packed));
+
+struct iw_mgmt_ds_pset {
+	struct iw_mgmt_info_element el;
+	u8 			    chan;
+} __attribute__ ((packed));
+
+struct iw_mgmt_cf_pset {
+	struct iw_mgmt_info_element el;
+	u8 			    cfp_count;
+	u8 			    cfp_period;
+	u16 			    cfp_max_duration;
+	u16 			    cfp_dur_remaining;
+} __attribute__ ((packed));
+
+struct iw_mgmt_ibss_pset {
+	struct iw_mgmt_info_element el;
+	u16 			    atim_window;
+} __attribute__ ((packed));
+
+struct wl3501_tx_hdr {
+	u16	tx_cnt;
+	u8	sync[16];
+	u16	sfd;
+	u8	signal;
+	u8	service;
+	u16	len;
+	u16	crc16;
+	u16	frame_ctrl;
+	u16	duration_id;
+	u8	addr1[ETH_ALEN];
+	u8	addr2[ETH_ALEN];
+	u8	addr3[ETH_ALEN];
+	u16	seq_ctrl;
+	u8	addr4[ETH_ALEN];
+};
+
+struct wl3501_rx_hdr {
+	u16	rx_next_blk;
+	u16	rc_next_frame_blk;
+	u8	rx_blk_ctrl;
+	u8	rx_next_frame;
+	u8	rx_next_frame1;
+	u8	rssi;
+	char	time[8];
+	u8	signal;
+	u8	service;
+	u16	len;
+	u16	crc16;
+	u16	frame_ctrl;
+	u16	duration;
+	u8	addr1[ETH_ALEN];
+	u8	addr2[ETH_ALEN];
+	u8	addr3[ETH_ALEN];
+	u16	seq;
+	u8	addr4[ETH_ALEN];
+};
+
+struct wl3501_start_req {
+	u16			    next_blk;
+	u8			    sig_id;
+	u8			    bss_type;
+	u16			    beacon_period;
+	u16			    dtim_period;
+	u16			    probe_delay;
+	u16			    cap_info;
+	struct iw_mgmt_essid_pset   ssid;
+	struct iw_mgmt_data_rset    bss_basic_rset;
+	struct iw_mgmt_data_rset    operational_rset;
+	struct iw_mgmt_cf_pset	    cf_pset;
+	struct iw_mgmt_ds_pset	    ds_pset;
+	struct iw_mgmt_ibss_pset    ibss_pset;
+};
+
+struct wl3501_assoc_req {
+	u16	next_blk;
+	u8	sig_id;
+	u8	reserved;
+	u16	timeout;
+	u16	cap_info;
+	u16	listen_interval;
+	u8	mac_addr[ETH_ALEN];
+};
+
+struct wl3501_assoc_confirm {
+	u16	next_blk;
+	u8	sig_id;
+	u8	reserved;
+	u16	status;
+};
+
+struct wl3501_assoc_ind {
+	u16	next_blk;
+	u8	sig_id;
+	u8	mac_addr[ETH_ALEN];
+};
+
+struct wl3501_auth_req {
+	u16	next_blk;
+	u8	sig_id;
+	u8	reserved;
+	u16	type;
+	u16	timeout;
+	u8	mac_addr[ETH_ALEN];
+};
+
+struct wl3501_auth_confirm {
+	u16	next_blk;
+	u8	sig_id;
+	u8	reserved;
+	u16	type;
+	u16	status;
+	u8	mac_addr[ETH_ALEN];
+};
+
+struct wl3501_get_req {
+	u16	next_blk;
+	u8	sig_id;
+	u8	reserved;
+	u16	mib_attrib;
+};
+
+struct wl3501_get_confirm {
+	u16	next_blk;
+	u8	sig_id;
+	u8	reserved;
+	u16	mib_status;
+	u16	mib_attrib;
+	u8	mib_value[100];
+};
+
+struct wl3501_join_req {
+	u16			    next_blk;
+	u8			    sig_id;
+	u8			    reserved;
+	struct iw_mgmt_data_rset    operational_rset;
+	u16			    reserved2;
+	u16			    timeout;
+	u16			    probe_delay;
+	u8			    timestamp[8];
+	u8			    local_time[8];
+	u16			    beacon_period;
+	u16			    dtim_period;
+	u16			    cap_info;
+	u8			    bss_type;
+	u8			    bssid[ETH_ALEN];
+	struct iw_mgmt_essid_pset   ssid;
+	struct iw_mgmt_ds_pset	    ds_pset;
+	struct iw_mgmt_cf_pset	    cf_pset;
+	struct iw_mgmt_ibss_pset    ibss_pset;
+	struct iw_mgmt_data_rset    bss_basic_rset;
+};
+
+struct wl3501_join_confirm {
+	u16	next_blk;
+	u8	sig_id;
+	u8	reserved;
+	u16	status;
+};
+
+struct wl3501_pwr_mgmt_req {
+	u16	next_blk;
+	u8	sig_id;
+	u8	pwr_save;
+	u8	wake_up;
+	u8	receive_dtims;
+};
+
+struct wl3501_pwr_mgmt_confirm {
+	u16	next_blk;
+	u8	sig_id;
+	u8	reserved;
+	u16	status;
+};
+
+struct wl3501_scan_req {
+	u16			    next_blk;
+	u8			    sig_id;
+	u8			    bss_type;
+	u16			    probe_delay;
+	u16			    min_chan_time;
+	u16			    max_chan_time;
+	u8			    chan_list[14];
+	u8			    bssid[ETH_ALEN];
+	struct iw_mgmt_essid_pset   ssid;
+	enum wl3501_scan_type	    scan_type;
+};
+
+struct wl3501_scan_confirm {
+	u16			    next_blk;
+	u8			    sig_id;
+	u8			    reserved;
+	u16			    status;
+	char			    timestamp[8];
+	char			    localtime[8];
+	u16			    beacon_period;
+	u16			    dtim_period;
+	u16			    cap_info;
+	u8			    bss_type;
+	u8			    bssid[ETH_ALEN];
+	struct iw_mgmt_essid_pset   ssid;
+	struct iw_mgmt_ds_pset	    ds_pset;
+	struct iw_mgmt_cf_pset	    cf_pset;
+	struct iw_mgmt_ibss_pset    ibss_pset;
+	struct iw_mgmt_data_rset    bss_basic_rset;
+	u8			    rssi;
+};
+
+struct wl3501_start_confirm {
+	u16	next_blk;
+	u8	sig_id;
+	u8	reserved;
+	u16	status;
+};
+
+struct wl3501_md_req {
+	u16	next_blk;
+	u8	sig_id;
+	u8	routing;
+	u16	data;
+	u16	size;
+	u8	pri;
+	u8	service_class;
+	u8	daddr[ETH_ALEN];
+	u8	saddr[ETH_ALEN];
+};
+
+struct wl3501_md_ind {
+	u16	next_blk;
+	u8	sig_id;
+	u8	routing;
+	u16	data;
+	u16	size;
+	u8	reception;
+	u8	pri;
+	u8	service_class;
+	u8	daddr[ETH_ALEN];
+	u8	saddr[ETH_ALEN];
+};
+
+struct wl3501_md_confirm {
+	u16	next_blk;
+	u8	sig_id;
+	u8	reserved;
+	u16	data;
+	u8	status;
+	u8	pri;
+	u8	service_class;
+};
+
+struct wl3501_resync_req {
+	u16	next_blk;
+	u8	sig_id;
+};
+
+/* Definitions for supporting clone adapters. */
+/* System Interface Registers (SIR space) */
+#define WL3501_NIC_GCR ((u8)0x00)	/* SIR0 - General Conf Register */
+#define WL3501_NIC_BSS ((u8)0x01)	/* SIR1 - Bank Switching Select Reg */
+#define WL3501_NIC_LMAL ((u8)0x02)	/* SIR2 - Local Mem addr Reg [7:0] */
+#define WL3501_NIC_LMAH ((u8)0x03)	/* SIR3 - Local Mem addr Reg [14:8] */
+#define WL3501_NIC_IODPA ((u8)0x04)	/* SIR4 - I/O Data Port A */
+#define WL3501_NIC_IODPB ((u8)0x05)	/* SIR5 - I/O Data Port B */
+#define WL3501_NIC_IODPC ((u8)0x06)	/* SIR6 - I/O Data Port C */
+#define WL3501_NIC_IODPD ((u8)0x07)	/* SIR7 - I/O Data Port D */
+
+/* Bits in GCR */
+#define WL3501_GCR_SWRESET ((u8)0x80)
+#define WL3501_GCR_CORESET ((u8)0x40)
+#define WL3501_GCR_DISPWDN ((u8)0x20)
+#define WL3501_GCR_ECWAIT  ((u8)0x10)
+#define WL3501_GCR_ECINT   ((u8)0x08)
+#define WL3501_GCR_INT2EC  ((u8)0x04)
+#define WL3501_GCR_ENECINT ((u8)0x02)
+#define WL3501_GCR_DAM     ((u8)0x01)
+
+/* Bits in BSS (Bank Switching Select Register) */
+#define WL3501_BSS_FPAGE0 ((u8)0x20)	/* Flash memory page0 */
+#define WL3501_BSS_FPAGE1 ((u8)0x28)
+#define WL3501_BSS_FPAGE2 ((u8)0x30)
+#define WL3501_BSS_FPAGE3 ((u8)0x38)
+#define WL3501_BSS_SPAGE0 ((u8)0x00)	/* SRAM page0 */
+#define WL3501_BSS_SPAGE1 ((u8)0x08)
+#define WL3501_BSS_SPAGE2 ((u8)0x10)
+#define WL3501_BSS_SPAGE3 ((u8)0x18)
+
+/* Define Driver Interface */
+/* Refer IEEE 802.11 */
+/* Tx packet header, include PLCP and MPDU */
+/* Tx PLCP Header */
+struct wl3501_80211_tx_plcp_hdr {
+	u8	sync[16];
+	u16	sfd;
+	u8	signal;
+	u8	service;
+	u16	len;
+	u16	crc16;
+} __attribute__ ((packed));
+
+struct wl3501_80211_tx_hdr {
+	struct wl3501_80211_tx_plcp_hdr	pclp_hdr;
+	struct ieee802_11_hdr		mac_hdr;
+} __attribute__ ((packed));
+
+/*
+   Reserve the beginning Tx space for descriptor use.
+
+   TxBlockOffset -->	*----*----*----*----* \
+	(TxFreeDesc)	|  0 |  1 |  2 |  3 |  \
+			|  4 |  5 |  6 |  7 |   |
+			|  8 |  9 | 10 | 11 |   TX_DESC * 20
+			| 12 | 13 | 14 | 15 |   |
+			| 16 | 17 | 18 | 19 |  /
+   TxBufferBegin -->	*----*----*----*----* /
+   (TxBufferHead)	| 		    |
+   (TxBufferTail)	| 		    |
+			|    Send Buffer    |
+			| 		    |
+			|		    |
+			*-------------------*
+   TxBufferEnd    -------------------------/
+
+*/
+
+struct wl3501_card {
+	int				base_addr;
+	u8				mac_addr[ETH_ALEN];
+	spinlock_t			lock;
+	wait_queue_head_t		wait;
+	struct wl3501_get_confirm	sig_get_confirm;
+	struct wl3501_pwr_mgmt_confirm	sig_pwr_mgmt_confirm;
+	u16				tx_buffer_size;
+	u16				tx_buffer_head;
+	u16				tx_buffer_tail;
+	u16				tx_buffer_cnt;
+	u16				esbq_req_start;
+	u16				esbq_req_end;
+	u16				esbq_req_head;
+	u16				esbq_req_tail;
+	u16				esbq_confirm_start;
+	u16				esbq_confirm_end;
+	u16				esbq_confirm;
+	struct iw_mgmt_essid_pset  	essid;
+	struct iw_mgmt_essid_pset  	keep_essid;
+	u8				bssid[ETH_ALEN];
+	int				net_type;
+	char				nick[32];
+	char				card_name[32];
+	char				firmware_date[32];
+	u8				chan;
+	u8				cap_info;
+	u16				start_seg;
+	u16				bss_cnt;
+	u16				join_sta_bss;
+	u8				rssi;
+	u8				adhoc_times;
+	u8				reg_domain;
+	u8				version[2];
+	struct wl3501_scan_confirm	bss_set[20];
+	struct net_device_stats 	stats;
+	struct iw_statistics		wstats;
+	struct iw_spy_data		spy_data;
+	struct dev_node_t		node;
+};
+#endif
