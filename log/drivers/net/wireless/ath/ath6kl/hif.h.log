commit cb8e59cc87201af93dfbb6c3dccc8fcad72a09c2
Merge: 2e63f6ce7ed2 065fcfd49763
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 3 16:27:18 2020 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next
    
    Pull networking updates from David Miller:
    
     1) Allow setting bluetooth L2CAP modes via socket option, from Luiz
        Augusto von Dentz.
    
     2) Add GSO partial support to igc, from Sasha Neftin.
    
     3) Several cleanups and improvements to r8169 from Heiner Kallweit.
    
     4) Add IF_OPER_TESTING link state and use it when ethtool triggers a
        device self-test. From Andrew Lunn.
    
     5) Start moving away from custom driver versions, use the globally
        defined kernel version instead, from Leon Romanovsky.
    
     6) Support GRO vis gro_cells in DSA layer, from Alexander Lobakin.
    
     7) Allow hard IRQ deferral during NAPI, from Eric Dumazet.
    
     8) Add sriov and vf support to hinic, from Luo bin.
    
     9) Support Media Redundancy Protocol (MRP) in the bridging code, from
        Horatiu Vultur.
    
    10) Support netmap in the nft_nat code, from Pablo Neira Ayuso.
    
    11) Allow UDPv6 encapsulation of ESP in the ipsec code, from Sabrina
        Dubroca. Also add ipv6 support for espintcp.
    
    12) Lots of ReST conversions of the networking documentation, from Mauro
        Carvalho Chehab.
    
    13) Support configuration of ethtool rxnfc flows in bcmgenet driver,
        from Doug Berger.
    
    14) Allow to dump cgroup id and filter by it in inet_diag code, from
        Dmitry Yakunin.
    
    15) Add infrastructure to export netlink attribute policies to
        userspace, from Johannes Berg.
    
    16) Several optimizations to sch_fq scheduler, from Eric Dumazet.
    
    17) Fallback to the default qdisc if qdisc init fails because otherwise
        a packet scheduler init failure will make a device inoperative. From
        Jesper Dangaard Brouer.
    
    18) Several RISCV bpf jit optimizations, from Luke Nelson.
    
    19) Correct the return type of the ->ndo_start_xmit() method in several
        drivers, it's netdev_tx_t but many drivers were using
        'int'. From Yunjian Wang.
    
    20) Add an ethtool interface for PHY master/slave config, from Oleksij
        Rempel.
    
    21) Add BPF iterators, from Yonghang Song.
    
    22) Add cable test infrastructure, including ethool interfaces, from
        Andrew Lunn. Marvell PHY driver is the first to support this
        facility.
    
    23) Remove zero-length arrays all over, from Gustavo A. R. Silva.
    
    24) Calculate and maintain an explicit frame size in XDP, from Jesper
        Dangaard Brouer.
    
    25) Add CAP_BPF, from Alexei Starovoitov.
    
    26) Support terse dumps in the packet scheduler, from Vlad Buslov.
    
    27) Support XDP_TX bulking in dpaa2 driver, from Ioana Ciornei.
    
    28) Add devm_register_netdev(), from Bartosz Golaszewski.
    
    29) Minimize qdisc resets, from Cong Wang.
    
    30) Get rid of kernel_getsockopt and kernel_setsockopt in order to
        eliminate set_fs/get_fs calls. From Christoph Hellwig.
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next: (2517 commits)
      selftests: net: ip_defrag: ignore EPERM
      net_failover: fixed rollback in net_failover_open()
      Revert "tipc: Fix potential tipc_aead refcnt leak in tipc_crypto_rcv"
      Revert "tipc: Fix potential tipc_node refcnt leak in tipc_rcv"
      vmxnet3: allow rx flow hash ops only when rss is enabled
      hinic: add set_channels ethtool_ops support
      selftests/bpf: Add a default $(CXX) value
      tools/bpf: Don't use $(COMPILE.c)
      bpf, selftests: Use bpf_probe_read_kernel
      s390/bpf: Use bcr 0,%0 as tail call nop filler
      s390/bpf: Maintain 8-byte stack alignment
      selftests/bpf: Fix verifier test
      selftests/bpf: Fix sample_cnt shared between two threads
      bpf, selftests: Adapt cls_redirect to call csum_level helper
      bpf: Add csum_level helper for fixing up csum levels
      bpf: Fix up bpf_skb_adjust_room helper's skb csum setting
      sfc: add missing annotation for efx_ef10_try_update_nic_stats_vf()
      crypto/chtls: IPv6 support for inline TLS
      Crypto/chcr: Fixes a coccinile check error
      Crypto/chcr: Fixes compilations warnings
      ...

commit ecc2f3962587aed327ccd3c32e99ccfc9e744fa0
Author: Pali Rohár <pali@kernel.org>
Date:   Fri May 22 16:44:08 2020 +0200

    mmc: sdio: Move SDIO IDs from ath6kl driver to common include file
    
    Also replace generic MANUFACTURER macros by proper SDIO IDs macros.
    
    Check for "AR6003 or later" is slightly modified to use SDIO device IDs.
    This allows removal of all custom MANUFACTURER macros from ath6kl.
    
    Signed-off-by: Pali Rohár <pali@kernel.org>
    Acked-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/20200522144412.19712-8-pali@kernel.org
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/net/wireless/ath/ath6kl/hif.h b/drivers/net/wireless/ath/ath6kl/hif.h
index dc6bd8cd9b83..c6dafc38936a 100644
--- a/drivers/net/wireless/ath/ath6kl/hif.h
+++ b/drivers/net/wireless/ath/ath6kl/hif.h
@@ -35,12 +35,6 @@
 #define MAX_SCATTER_ENTRIES_PER_REQ      16
 #define MAX_SCATTER_REQ_TRANSFER_SIZE    (32 * 1024)
 
-#define MANUFACTURER_ID_AR6003_BASE        0x300
-#define MANUFACTURER_ID_AR6004_BASE        0x400
-    /* SDIO manufacturer ID and Codes */
-#define MANUFACTURER_ID_ATH6KL_BASE_MASK     0xFF00
-#define MANUFACTURER_CODE                  0x271	/* Atheros */
-
 /* Mailbox address in SDIO address space */
 #define HIF_MBOX_BASE_ADDR                 0x800
 #define HIF_MBOX_WIDTH                     0x800

commit ee4dd7061891d7295328302104037520d831ce43
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Mon May 4 15:08:38 2020 -0500

    ath6kl: Replace zero-length array with flexible-array
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    sizeof(flexible-array-member) triggers a warning because flexible array
    members have incomplete type[1]. There are some instances of code in
    which the sizeof operator is being incorrectly/erroneously applied to
    zero-length arrays and the result is zero. Such instances may be hiding
    some bugs. So, this work (flexible-array member conversions) will also
    help to get completely rid of those sorts of issues.
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/20200504200838.GA31974@embeddedor

diff --git a/drivers/net/wireless/ath/ath6kl/hif.h b/drivers/net/wireless/ath/ath6kl/hif.h
index dc6bd8cd9b83..aea7fea2a81e 100644
--- a/drivers/net/wireless/ath/ath6kl/hif.h
+++ b/drivers/net/wireless/ath/ath6kl/hif.h
@@ -199,7 +199,7 @@ struct hif_scatter_req {
 
 	u32 scat_q_depth;
 
-	struct hif_scatter_item scat_list[0];
+	struct hif_scatter_item scat_list[];
 };
 
 struct ath6kl_irq_proc_registers {

commit 31b9cc9a873dcab161999622314f98a75d838975
Author: Kalle Valo <kvalo@qca.qualcomm.com>
Date:   Tue Mar 11 12:58:00 2014 +0200

    ath6kl: fix struct hif_scatter_req list handling
    
    Jason noticed that with Yocto GCC 4.8.1 ath6kl crashes with this iperf command:
    
    iperf -c $TARGET_IP -i 5 -t 50 -w 1M
    
    The crash was:
    
    Unable to handle kernel paging request at virtual address 1a480000
    pgd = 80004000
    [1a480000] *pgd=00000000
    Internal error: Oops: 805 [#1] SMP ARM
    Modules linked in: ath6kl_sdio ath6kl_core [last unloaded: ath6kl_core]
    CPU: 0 PID: 1953 Comm: kworker/u4:0 Not tainted 3.10.9-1.0.0_alpha+dbf364b #1
    Workqueue: ath6kl ath6kl_sdio_write_async_work [ath6kl_sdio]
    task: dcc9a680 ti: dc9ae000 task.ti: dc9ae000
    PC is at v7_dma_clean_range+0x20/0x38
    LR is at dma_cache_maint_page+0x50/0x54
    pc : [<8001a6f8>]    lr : [<800170fc>]    psr: 20000093
    sp : dc9afcf8  ip : 8001a748  fp : 00000004
    r10: 00000000  r9 : 00000001  r8 : 00000000
    r7 : 00000001  r6 : 00000000  r5 : 80cb7000  r4 : 03f9a480
    r3 : 0000001f  r2 : 00000020  r1 : 1a480000  r0 : 1a480000
    Flags: nzCv  IRQs off  FIQs on  Mode SVC_32  ISA ARM  Segment kernel
    Control: 10c53c7d  Table: 6cc5004a  DAC: 00000015
    Process kworker/u4:0 (pid: 1953, stack limit = 0xdc9ae238)
    Stack: (0xdc9afcf8 to 0xdc9b0000)
    fce0:                                                       80c9b29c 00000000
    fd00: 00000000 80017134 8001a748 dc302ac0 00000000 00000000 dc454a00 80c12ed8
    fd20: dc115410 80017238 00000000 dc454a10 00000001 80017588 00000001 00000000
    fd40: 00000000 dc302ac0 dc9afe38 dc9afe68 00000004 80c12ed8 00000000 dc454a00
    fd60: 00000004 80436f88 00000000 00000000 00000600 0000ffff 0000000c 80c113c4
    fd80: 80c9b29c 00000001 00000004 dc115470 60000013 dc302ac0 dc46e000 dc302800
    fda0: dc9afe10 dc302b78 60000013 dc302ac0 dc46e000 00000035 dc46e5b0 80438c90
    fdc0: dc9afe10 dc302800 dc302800 dc9afe68 dc9afe38 80424cb4 00000005 dc9afe10
    fde0: dc9afe20 80424de8 dc9afe10 dc302800 dc46e910 80424e90 dc473c00 dc454f00
    fe00: 000001b5 7f619d64 dcc7c830 00000000 00000000 dc9afe38 dc9afe68 00000000
    fe20: 00000000 00000000 dc9afe28 dc9afe28 80424d80 00000000 00000035 9cac0034
    fe40: 00000000 00000000 00000000 00000000 000001b5 00000000 00000000 00000000
    fe60: dc9afe68 dc9afe10 3b9aca00 00000000 00000080 00000034 00000000 00000100
    fe80: 00000000 00000000 dc9afe10 00000004 dc454a00 00000000 dc46e010 dc46e96c
    fea0: dc46e000 dc46e964 00200200 00100100 dc46e910 7f619ec0 00000600 80c0e770
    fec0: dc15a900 dcc7c838 00000000 dc46e954 8042d434 dcc44680 dc46e954 dc004400
    fee0: dc454500 00000000 00000000 dc9ae038 dc004400 8003c450 dcc44680 dc004414
    ff00: dc46e954 dc454500 00000001 dcc44680 dc004414 dcc44698 dc9ae000 dc9ae030
    ff20: 00000001 dc9ae000 dc004400 8003d158 8003d020 00000000 00000000 80c53941
    ff40: dc9aff64 dcb71ea0 00000000 dcc44680 8003d020 00000000 00000000 00000000
    ff60: 00000000 80042480 00000000 00000000 000000f8 dcc44680 00000000 00000000
    ff80: dc9aff80 dc9aff80 00000000 00000000 dc9aff90 dc9aff90 dc9affac dcb71ea0
    ffa0: 800423cc 00000000 00000000 8000e018 00000000 00000000 00000000 00000000
    ffc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    ffe0: 00000000 00000000 00000000 00000000 00000013 00000000 00000000 00000000
    [<8001a6f8>] (v7_dma_clean_range+0x20/0x38) from [<800170fc>] (dma_cache_maint_page+0x50/0x54)
    [<800170fc>] (dma_cache_maint_page+0x50/0x54) from [<80017134>] (__dma_page_cpu_to_dev+0x34/0x9c)
    [<80017134>] (__dma_page_cpu_to_dev+0x34/0x9c) from [<80017238>] (arm_dma_map_page+0x64/0x68)
    [<80017238>] (arm_dma_map_page+0x64/0x68) from [<80017588>] (arm_dma_map_sg+0x7c/0xf4)
    [<80017588>] (arm_dma_map_sg+0x7c/0xf4) from [<80436f88>] (sdhci_send_command+0x894/0xe00)
    [<80436f88>] (sdhci_send_command+0x894/0xe00) from [<80438c90>] (sdhci_request+0xc0/0x1ec)
    [<80438c90>] (sdhci_request+0xc0/0x1ec) from [<80424cb4>] (mmc_start_request+0xb8/0xd4)
    [<80424cb4>] (mmc_start_request+0xb8/0xd4) from [<80424de8>] (__mmc_start_req+0x60/0x84)
    [<80424de8>] (__mmc_start_req+0x60/0x84) from [<80424e90>] (mmc_wait_for_req+0x10/0x20)
    [<80424e90>] (mmc_wait_for_req+0x10/0x20) from [<7f619d64>] (ath6kl_sdio_scat_rw.isra.10+0x1dc/0x240 [ath6kl_sdio])
    [<7f619d64>] (ath6kl_sdio_scat_rw.isra.10+0x1dc/0x240 [ath6kl_sdio]) from [<7f619ec0>] (ath6kl_sdio_write_async_work+0x5c/0x104 [ath6kl_sdio])
    [<7f619ec0>] (ath6kl_sdio_write_async_work+0x5c/0x104 [ath6kl_sdio]) from [<8003c450>] (process_one_work+0x10c/0x370)
    [<8003c450>] (process_one_work+0x10c/0x370) from [<8003d158>] (worker_thread+0x138/0x3fc)
    [<8003d158>] (worker_thread+0x138/0x3fc) from [<80042480>] (kthread+0xb4/0xb8)
    [<80042480>] (kthread+0xb4/0xb8) from [<8000e018>] (ret_from_fork+0x14/0x3c)
    Code: e1a02312 e2423001 e1c00003 f57ff04f (ee070f3a)
    ---[ end trace 0c038f0b8e0b67a3 ]---
    Kernel panic - not syncing: Fatal exception
    
    Jason's analysis:
    
      "The GCC 4.8.1 compiler will not do the for-loop till scat_entries, instead,
       it only run one round loop. This may be caused by that the GCC 4.8.1 thought
       that the scat_list only have one item and then no need to do full iteration,
       but this is simply wrong by looking at the assebly code. This will cause the sg
       buffer not get set when scat_entries > 1 and thus lead to kernel panic.
    
       Note: This issue not observed with GCC 4.7.2, only found on the GCC 4.8.1)"
    
    Fix this by using the normal [0] style for defining unknown number of list
    entries following the struct. This also fixes corruption with scat_q_depth, which
    was mistankely added to the end of struct and overwritten if there were more
    than item in the scat list.
    
    Reported-by: Jason Liu <r64343@freescale.com>
    Tested-by: Jason Liu <r64343@freescale.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath6kl/hif.h b/drivers/net/wireless/ath/ath6kl/hif.h
index 61f6b21fb0ae..dc6bd8cd9b83 100644
--- a/drivers/net/wireless/ath/ath6kl/hif.h
+++ b/drivers/net/wireless/ath/ath6kl/hif.h
@@ -197,9 +197,9 @@ struct hif_scatter_req {
 	/* bounce buffer for upper layers to copy to/from */
 	u8 *virt_dma_buf;
 
-	struct hif_scatter_item scat_list[1];
-
 	u32 scat_q_depth;
+
+	struct hif_scatter_item scat_list[0];
 };
 
 struct ath6kl_irq_proc_registers {

commit 636f828844fad9421ea6e7df053bba995febdecf
Author: Kalle Valo <kvalo@qca.qualcomm.com>
Date:   Sun Mar 25 17:15:28 2012 +0300

    ath6kl: Add HTC pipe implementation
    
    This is needed for USB.
    
    Based on code by Kevin Fang.
    
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath6kl/hif.h b/drivers/net/wireless/ath/ath6kl/hif.h
index 20ed6b73517b..61f6b21fb0ae 100644
--- a/drivers/net/wireless/ath/ath6kl/hif.h
+++ b/drivers/net/wireless/ath/ath6kl/hif.h
@@ -256,6 +256,12 @@ struct ath6kl_hif_ops {
 	int (*power_on)(struct ath6kl *ar);
 	int (*power_off)(struct ath6kl *ar);
 	void (*stop)(struct ath6kl *ar);
+	int (*pipe_send)(struct ath6kl *ar, u8 pipe, struct sk_buff *hdr_buf,
+			 struct sk_buff *buf);
+	void (*pipe_get_default)(struct ath6kl *ar, u8 *pipe_ul, u8 *pipe_dl);
+	int (*pipe_map_service)(struct ath6kl *ar, u16 service_id, u8 *pipe_ul,
+				u8 *pipe_dl);
+	u16 (*pipe_get_free_queue_number)(struct ath6kl *ar, u8 pipe);
 };
 
 int ath6kl_hif_setup(struct ath6kl_device *dev);

commit 12eb9444a8df7ab4aa5f4c91f8e3049af5d9819b
Author: Kalle Valo <kvalo@qca.qualcomm.com>
Date:   Wed Mar 7 20:04:00 2012 +0200

    ath6kl: document all spinlocks
    
    Also fixes quite a few checkpatch warnings like this:
    
    ath6kl/hif.h:226: CHECK: spinlock_t definition without comment
    
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath6kl/hif.h b/drivers/net/wireless/ath/ath6kl/hif.h
index 904458ab484b..20ed6b73517b 100644
--- a/drivers/net/wireless/ath/ath6kl/hif.h
+++ b/drivers/net/wireless/ath/ath6kl/hif.h
@@ -223,6 +223,7 @@ struct ath6kl_irq_enable_reg {
 } __packed;
 
 struct ath6kl_device {
+	/* protects irq_proc_reg and irq_en_reg below */
 	spinlock_t lock;
 	struct ath6kl_irq_proc_registers irq_proc_reg;
 	struct ath6kl_irq_enable_reg irq_en_reg;

commit b29072cc7b0e08ace48ab709c40cf6246fb2e8b0
Author: Chilam Ng <chilamng@qca.qualcomm.com>
Date:   Tue Feb 7 01:33:00 2012 -0800

    ath6kl: prioritize Tx bundling based on AC priorities
    
    Tx bundling is the more efficient use of SDIO bus and allows more packet
    transfers with fewer bus transactions, and is a way to improve overall
    throughput. However, Tx bundling has only 4 scatter request resources available.
    When there are multiple traffic streams of different priorities, it's possible
    that lower priority traffic may hog all the scatter requests and lock out the
    higher prioirty traffic from bundling.
    Tx bundling is now enabled per AC. When an AC do a scatter request and
    the remaining scatter request resources is lower than a configurable
    threshold, it will disable Tx bundling for all AC's of lower priorities.
    When an AC has Tx bundling disabled and has no Tx bundles sent in a
    consecutive and configurable number of packets, Tx bundling will be re-enabled
    for that AC.
    
    Signed-off-by: Chilam Ng <chilamng@qca.qualcomm.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath6kl/hif.h b/drivers/net/wireless/ath/ath6kl/hif.h
index fb4186f5d432..904458ab484b 100644
--- a/drivers/net/wireless/ath/ath6kl/hif.h
+++ b/drivers/net/wireless/ath/ath6kl/hif.h
@@ -198,6 +198,8 @@ struct hif_scatter_req {
 	u8 *virt_dma_buf;
 
 	struct hif_scatter_item scat_list[1];
+
+	u32 scat_q_depth;
 };
 
 struct ath6kl_irq_proc_registers {

commit 1b2df4073447234034e2329f0df584c6346a8ec3
Author: Vasanthakumar Thiagarajan <vthiagar@qca.qualcomm.com>
Date:   Mon Feb 6 20:15:53 2012 +0530

    ath6kl: Update license header
    
    Update license header with the copyright to Qualcomm Atheros, Inc.
    for the year 2011-2012.
    
    Signed-off-by: Vasanthakumar Thiagarajan <vthiagar@qca.qualcomm.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath6kl/hif.h b/drivers/net/wireless/ath/ath6kl/hif.h
index 699a036f3a44..fb4186f5d432 100644
--- a/drivers/net/wireless/ath/ath6kl/hif.h
+++ b/drivers/net/wireless/ath/ath6kl/hif.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2004-2011 Atheros Communications Inc.
+ * Copyright (c) 2011 Qualcomm Atheros, Inc.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above

commit d93e2c2f2109a3b804fa799079a6dd4d315af857
Author: Naveen Gangadharan <ngangadh@qca.qualcomm.com>
Date:   Fri Nov 11 12:18:14 2011 +0200

    ath6kl: AR6004 SDIO support
    
    Add support for AR6004 SDIO. Tested scan, association (open mode) and
    ping.
    
    kvalo: change commit log a bit, drop board address changes
    
    Signed-off-by: Naveen Gangadharan <ngangadh@qca.qualcomm.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath6kl/hif.h b/drivers/net/wireless/ath/ath6kl/hif.h
index 15b5d98c7dc4..699a036f3a44 100644
--- a/drivers/net/wireless/ath/ath6kl/hif.h
+++ b/drivers/net/wireless/ath/ath6kl/hif.h
@@ -35,6 +35,7 @@
 #define MAX_SCATTER_REQ_TRANSFER_SIZE    (32 * 1024)
 
 #define MANUFACTURER_ID_AR6003_BASE        0x300
+#define MANUFACTURER_ID_AR6004_BASE        0x400
     /* SDIO manufacturer ID and Codes */
 #define MANUFACTURER_ID_ATH6KL_BASE_MASK     0xFF00
 #define MANUFACTURER_CODE                  0x271	/* Atheros */

commit c71114959dc952a509822f22251d01004b3b94cc
Author: Kalle Valo <kvalo@qca.qualcomm.com>
Date:   Fri Nov 11 12:17:51 2011 +0200

    ath6kl: move diag commands to hif driver
    
    This is preparation for USB support which will have different diag
    commands.
    
    Based on code by Kevin Fang.
    
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath6kl/hif.h b/drivers/net/wireless/ath/ath6kl/hif.h
index 42004e9069b6..15b5d98c7dc4 100644
--- a/drivers/net/wireless/ath/ath6kl/hif.h
+++ b/drivers/net/wireless/ath/ath6kl/hif.h
@@ -244,6 +244,8 @@ struct ath6kl_hif_ops {
 	void (*cleanup_scatter)(struct ath6kl *ar);
 	int (*suspend)(struct ath6kl *ar, struct cfg80211_wowlan *wow);
 	int (*resume)(struct ath6kl *ar);
+	int (*diag_read32)(struct ath6kl *ar, u32 address, u32 *value);
+	int (*diag_write32)(struct ath6kl *ar, u32 address, __le32 value);
 	int (*bmi_read)(struct ath6kl *ar, u8 *buf, u32 len);
 	int (*bmi_write)(struct ath6kl *ar, u8 *buf, u32 len);
 	int (*power_on)(struct ath6kl *ar);

commit 66b693c3b84876d33afd35b9d717d8b9d07384c8
Author: Kalle Valo <kvalo@qca.qualcomm.com>
Date:   Fri Nov 11 12:17:33 2011 +0200

    ath6kl: move bmi calls to hif driver
    
    In preparation for USB support which has it's own method for bmi.
    
    Based on code by Kevin Fang.
    
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath6kl/hif.h b/drivers/net/wireless/ath/ath6kl/hif.h
index f2dc3bcdae4a..42004e9069b6 100644
--- a/drivers/net/wireless/ath/ath6kl/hif.h
+++ b/drivers/net/wireless/ath/ath6kl/hif.h
@@ -244,6 +244,8 @@ struct ath6kl_hif_ops {
 	void (*cleanup_scatter)(struct ath6kl *ar);
 	int (*suspend)(struct ath6kl *ar, struct cfg80211_wowlan *wow);
 	int (*resume)(struct ath6kl *ar);
+	int (*bmi_read)(struct ath6kl *ar, u8 *buf, u32 len);
+	int (*bmi_write)(struct ath6kl *ar, u8 *buf, u32 len);
 	int (*power_on)(struct ath6kl *ar);
 	int (*power_off)(struct ath6kl *ar);
 	void (*stop)(struct ath6kl *ar);

commit 0f60e9f4c239554ad75ab8e4d864030a7f0dd6f7
Author: Raja Mani <rmani@qca.qualcomm.com>
Date:   Mon Nov 7 22:52:45 2011 +0200

    ath6kl: Include new parameter in suspend path for wowlan
    
    cfg80211 layer provides user defined wow parameters like Filter options, Patterns,
    Pattern's mask, etc via "struct cfg80211_wowlan *wow" to suspend function.
    
    Right now, this wowlan parameter is not handled in __ath6kl_cfg80211_suspend func.
    This parameter has to be passed to HIF layer, So that it can be passed back to
    ath6kl's cfg interface layer when WOW mode is selected.
    
    In case of deep sleep and cut power mode, it's not handled.
    
    Signed-off-by: Raja Mani <rmani@qca.qualcomm.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath6kl/hif.h b/drivers/net/wireless/ath/ath6kl/hif.h
index 814386d19b83..f2dc3bcdae4a 100644
--- a/drivers/net/wireless/ath/ath6kl/hif.h
+++ b/drivers/net/wireless/ath/ath6kl/hif.h
@@ -242,7 +242,7 @@ struct ath6kl_hif_ops {
 	int (*scat_req_rw) (struct ath6kl *ar,
 			    struct hif_scatter_req *scat_req);
 	void (*cleanup_scatter)(struct ath6kl *ar);
-	int (*suspend)(struct ath6kl *ar);
+	int (*suspend)(struct ath6kl *ar, struct cfg80211_wowlan *wow);
 	int (*resume)(struct ath6kl *ar);
 	int (*power_on)(struct ath6kl *ar);
 	int (*power_off)(struct ath6kl *ar);

commit 32a07e4448f78158a75f7c1f0056289647d83946
Author: Kalle Valo <kvalo@qca.qualcomm.com>
Date:   Sun Oct 30 21:15:57 2011 +0200

    ath6kl: create ath6kl_hif_stop()
    
    This is to reset hif layer for powering down hw.
    
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath6kl/hif.h b/drivers/net/wireless/ath/ath6kl/hif.h
index 78a6c79f8cab..814386d19b83 100644
--- a/drivers/net/wireless/ath/ath6kl/hif.h
+++ b/drivers/net/wireless/ath/ath6kl/hif.h
@@ -246,6 +246,7 @@ struct ath6kl_hif_ops {
 	int (*resume)(struct ath6kl *ar);
 	int (*power_on)(struct ath6kl *ar);
 	int (*power_off)(struct ath6kl *ar);
+	void (*stop)(struct ath6kl *ar);
 };
 
 int ath6kl_hif_setup(struct ath6kl_device *dev);

commit d60e8ab6b9bcbbb5eb7591c1989f8c79d6b3d964
Author: Kalle Valo <kvalo@qca.qualcomm.com>
Date:   Thu Oct 27 18:48:52 2011 +0300

    ath6kl: add a timeout to ath6kl_hif_intr_bh_handler()
    
    It's possible to busyloop forever in ath6kl_hif_intr_bh_handler(). Add
    a check that it lasts only one second.
    
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath6kl/hif.h b/drivers/net/wireless/ath/ath6kl/hif.h
index ee7c31a4135a..78a6c79f8cab 100644
--- a/drivers/net/wireless/ath/ath6kl/hif.h
+++ b/drivers/net/wireless/ath/ath6kl/hif.h
@@ -69,6 +69,8 @@
 #define ATH6KL_MAX_TRANSFER_SIZE_PER_SCATTER      (16 * 1024)
 #define ATH6KL_SCATTER_REQS                       4
 
+#define ATH6KL_HIF_COMMUNICATION_TIMEOUT	1000
+
 struct bus_request {
 	struct list_head list;
 

commit b2e756989e9744d94f7cbae47586858c3efc8430
Author: Kalle Valo <kvalo@qca.qualcomm.com>
Date:   Thu Oct 27 18:48:14 2011 +0300

    ath6kl: move power control from sdio to core
    
    In preparation for cutting down power from the chip on the fly.
    
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath6kl/hif.h b/drivers/net/wireless/ath/ath6kl/hif.h
index 93d29127881d..ee7c31a4135a 100644
--- a/drivers/net/wireless/ath/ath6kl/hif.h
+++ b/drivers/net/wireless/ath/ath6kl/hif.h
@@ -242,6 +242,8 @@ struct ath6kl_hif_ops {
 	void (*cleanup_scatter)(struct ath6kl *ar);
 	int (*suspend)(struct ath6kl *ar);
 	int (*resume)(struct ath6kl *ar);
+	int (*power_on)(struct ath6kl *ar);
+	int (*power_off)(struct ath6kl *ar);
 };
 
 int ath6kl_hif_setup(struct ath6kl_device *dev);

commit 2e1cb23c5e3c38b25a678a8a14d7464341e8207f
Author: Kalle Valo <kvalo@qca.qualcomm.com>
Date:   Wed Oct 5 12:23:49 2011 +0300

    ath6kl: move remaining content from htc_hif.h to hif.h
    
    Now htc_hif.h can be removed.
    
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath6kl/hif.h b/drivers/net/wireless/ath/ath6kl/hif.h
index 906fde95bdd4..93d29127881d 100644
--- a/drivers/net/wireless/ath/ath6kl/hif.h
+++ b/drivers/net/wireless/ath/ath6kl/hif.h
@@ -59,6 +59,16 @@
 /* mode to enable special 4-bit interrupt assertion without clock */
 #define SDIO_IRQ_MODE_ASYNC_4BIT_IRQ   (1 << 0)
 
+/* HTC runs over mailbox 0 */
+#define HTC_MAILBOX	0
+
+#define ATH6KL_TARGET_DEBUG_INTR_MASK     0x01
+
+/* FIXME: are these duplicates with MAX_SCATTER_ values in hif.h? */
+#define ATH6KL_SCATTER_ENTRIES_PER_REQ            16
+#define ATH6KL_MAX_TRANSFER_SIZE_PER_SCATTER      (16 * 1024)
+#define ATH6KL_SCATTER_REQS                       4
+
 struct bus_request {
 	struct list_head list;
 
@@ -186,6 +196,34 @@ struct hif_scatter_req {
 	struct hif_scatter_item scat_list[1];
 };
 
+struct ath6kl_irq_proc_registers {
+	u8 host_int_status;
+	u8 cpu_int_status;
+	u8 error_int_status;
+	u8 counter_int_status;
+	u8 mbox_frame;
+	u8 rx_lkahd_valid;
+	u8 host_int_status2;
+	u8 gmbox_rx_avail;
+	__le32 rx_lkahd[2];
+	__le32 rx_gmbox_lkahd_alias[2];
+} __packed;
+
+struct ath6kl_irq_enable_reg {
+	u8 int_status_en;
+	u8 cpu_int_status_en;
+	u8 err_int_status_en;
+	u8 cntr_int_status_en;
+} __packed;
+
+struct ath6kl_device {
+	spinlock_t lock;
+	struct ath6kl_irq_proc_registers irq_proc_reg;
+	struct ath6kl_irq_enable_reg irq_en_reg;
+	struct htc_target *htc_cnxt;
+	struct ath6kl *ar;
+};
+
 struct ath6kl_hif_ops {
 	int (*read_write_sync)(struct ath6kl *ar, u32 addr, u8 *buf,
 			       u32 len, u32 request);
@@ -206,4 +244,19 @@ struct ath6kl_hif_ops {
 	int (*resume)(struct ath6kl *ar);
 };
 
+int ath6kl_hif_setup(struct ath6kl_device *dev);
+int ath6kl_hif_unmask_intrs(struct ath6kl_device *dev);
+int ath6kl_hif_mask_intrs(struct ath6kl_device *dev);
+int ath6kl_hif_poll_mboxmsg_rx(struct ath6kl_device *dev,
+			       u32 *lk_ahd, int timeout);
+int ath6kl_hif_rx_control(struct ath6kl_device *dev, bool enable_rx);
+int ath6kl_hif_disable_intrs(struct ath6kl_device *dev);
+
+int ath6kl_hif_rw_comp_handler(void *context, int status);
+int ath6kl_hif_intr_bh_handler(struct ath6kl *ar);
+
+/* Scatter Function and Definitions */
+int ath6kl_hif_submit_scat_req(struct ath6kl_device *dev,
+			       struct hif_scatter_req *scat_req, bool read);
+
 #endif

commit aa6cffc1a275a9369ca83e13cebc4b09e4f23954
Author: Chilam Ng <chilamng@qca.qualcomm.com>
Date:   Wed Oct 5 10:12:52 2011 +0300

    ath6kl: make sure WLAN power save is enabled during suspend
    
    Power save is enabled during ath6kl init. But when user space disables power
    save, the system will go into suspend with power save disabled. The ath6kl
    driver will now explicitly enable power save prior to entering suspend and
    restore its previous setting upon resume
    
    Signed-off-by: Chilam Ng <chilamng@qca.qualcomm.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath6kl/hif.h b/drivers/net/wireless/ath/ath6kl/hif.h
index 797e2d1d9bf9..906fde95bdd4 100644
--- a/drivers/net/wireless/ath/ath6kl/hif.h
+++ b/drivers/net/wireless/ath/ath6kl/hif.h
@@ -203,6 +203,7 @@ struct ath6kl_hif_ops {
 			    struct hif_scatter_req *scat_req);
 	void (*cleanup_scatter)(struct ath6kl *ar);
 	int (*suspend)(struct ath6kl *ar);
+	int (*resume)(struct ath6kl *ar);
 };
 
 #endif

commit abcb344b3b823c8c9eac6e13e45a53eaf1d5d00b
Author: Kalle Valo <kvalo@qca.qualcomm.com>
Date:   Fri Jul 22 08:26:20 2011 +0300

    ath6kl: implement suspend support
    
    For now this is implemented so that if host supports power is kept in
    the chip. If that's not supported, an error is returned and sdio stack
    will remove the device during suspend.
    
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath6kl/hif.h b/drivers/net/wireless/ath/ath6kl/hif.h
index 5ceff54775a1..797e2d1d9bf9 100644
--- a/drivers/net/wireless/ath/ath6kl/hif.h
+++ b/drivers/net/wireless/ath/ath6kl/hif.h
@@ -202,6 +202,7 @@ struct ath6kl_hif_ops {
 	int (*scat_req_rw) (struct ath6kl *ar,
 			    struct hif_scatter_req *scat_req);
 	void (*cleanup_scatter)(struct ath6kl *ar);
+	int (*suspend)(struct ath6kl *ar);
 };
 
 #endif

commit 50745af7ebb38d3f8f2487f92db6c59c13dc0b89
Author: Vasanthakumar Thiagarajan <vthiagar@qca.qualcomm.com>
Date:   Mon Jul 18 14:23:29 2011 +0530

    ath6kl: Move scatter information from ath6kl_device to htc_target
    
    Signed-off-by: Vasanthakumar Thiagarajan <vthiagar@qca.qualcomm.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath6kl/hif.h b/drivers/net/wireless/ath/ath6kl/hif.h
index bbacba466cb7..5ceff54775a1 100644
--- a/drivers/net/wireless/ath/ath6kl/hif.h
+++ b/drivers/net/wireless/ath/ath6kl/hif.h
@@ -186,11 +186,6 @@ struct hif_scatter_req {
 	struct hif_scatter_item scat_list[1];
 };
 
-struct hif_dev_scat_sup_info {
-	int max_scat_entries;
-	int max_xfer_szper_scatreq;
-};
-
 struct ath6kl_hif_ops {
 	int (*read_write_sync)(struct ath6kl *ar, u32 addr, u8 *buf,
 			       u32 len, u32 request);
@@ -203,8 +198,7 @@ struct ath6kl_hif_ops {
 	struct hif_scatter_req *(*scatter_req_get)(struct ath6kl *ar);
 	void (*scatter_req_add)(struct ath6kl *ar,
 				struct hif_scatter_req *s_req);
-	int (*enable_scatter)(struct ath6kl *ar,
-			      struct hif_dev_scat_sup_info *info);
+	int (*enable_scatter)(struct ath6kl *ar);
 	int (*scat_req_rw) (struct ath6kl *ar,
 			    struct hif_scatter_req *scat_req);
 	void (*cleanup_scatter)(struct ath6kl *ar);

commit 4a005c3ed0e6424e991daeea385bd08a9b97b67a
Author: Vasanthakumar Thiagarajan <vthiagar@qca.qualcomm.com>
Date:   Sat Jul 16 20:29:15 2011 +0530

    ath6kl: Moe virt_scat from hif_dev_scat_sup_info to hif_scatter_req
    
    Signed-off-by: Vasanthakumar Thiagarajan <vthiagar@qca.qualcomm.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath6kl/hif.h b/drivers/net/wireless/ath/ath6kl/hif.h
index d5a79911bdc9..bbacba466cb7 100644
--- a/drivers/net/wireless/ath/ath6kl/hif.h
+++ b/drivers/net/wireless/ath/ath6kl/hif.h
@@ -171,6 +171,8 @@ struct hif_scatter_req {
 	/* total length of entire transfer */
 	u32 len;
 
+	bool virt_scat;
+
 	void (*complete) (struct htc_target *, struct hif_scatter_req *);
 	int status;
 	int scat_entries;
@@ -187,7 +189,6 @@ struct hif_scatter_req {
 struct hif_dev_scat_sup_info {
 	int max_scat_entries;
 	int max_xfer_szper_scatreq;
-	bool virt_scat;
 };
 
 struct ath6kl_hif_ops {

commit cfeab10b117cee7c2b3a8aaf1dc49d28482aeca0
Author: Vasanthakumar Thiagarajan <vthiagar@qca.qualcomm.com>
Date:   Sat Jul 16 20:29:14 2011 +0530

    ath6kl: Merge scatter gather setup functions for two method
    
    Signed-off-by: Vasanthakumar Thiagarajan <vthiagar@qca.qualcomm.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath6kl/hif.h b/drivers/net/wireless/ath/ath6kl/hif.h
index 1458660a1c03..d5a79911bdc9 100644
--- a/drivers/net/wireless/ath/ath6kl/hif.h
+++ b/drivers/net/wireless/ath/ath6kl/hif.h
@@ -187,6 +187,7 @@ struct hif_scatter_req {
 struct hif_dev_scat_sup_info {
 	int max_scat_entries;
 	int max_xfer_szper_scatreq;
+	bool virt_scat;
 };
 
 struct ath6kl_hif_ops {

commit e041c7f9af5a3583ee2bd20af1b03ec56b6adcca
Author: Vasanthakumar Thiagarajan <vthiagar@qca.qualcomm.com>
Date:   Sat Jul 16 20:29:09 2011 +0530

    ath6kl: Remove endpoint reference from hif_scatter_req
    
    Endpoint id ffrom htc_packet can be used instead.
    
    Signed-off-by: Vasanthakumar Thiagarajan <vthiagar@qca.qualcomm.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath6kl/hif.h b/drivers/net/wireless/ath/ath6kl/hif.h
index f17ae57ee303..1458660a1c03 100644
--- a/drivers/net/wireless/ath/ath6kl/hif.h
+++ b/drivers/net/wireless/ath/ath6kl/hif.h
@@ -171,9 +171,8 @@ struct hif_scatter_req {
 	/* total length of entire transfer */
 	u32 len;
 
-	void (*complete) (struct hif_scatter_req *);
+	void (*complete) (struct htc_target *, struct hif_scatter_req *);
 	int status;
-	struct htc_endpoint *ep;
 	int scat_entries;
 
 	struct bus_request *busrequest;

commit 7c565b6f8c635fc22535c763e08184379b16920e
Author: Vasanthakumar Thiagarajan <vthiagar@qca.qualcomm.com>
Date:   Sat Jul 16 20:29:08 2011 +0530

    ath6kl: Remove useless flags in hif_scatter_req
    
    Signed-off-by: Vasanthakumar Thiagarajan <vthiagar@qca.qualcomm.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath6kl/hif.h b/drivers/net/wireless/ath/ath6kl/hif.h
index 35f90a3b5a8b..f17ae57ee303 100644
--- a/drivers/net/wireless/ath/ath6kl/hif.h
+++ b/drivers/net/wireless/ath/ath6kl/hif.h
@@ -171,7 +171,6 @@ struct hif_scatter_req {
 	/* total length of entire transfer */
 	u32 len;
 
-	u32 flags;
 	void (*complete) (struct hif_scatter_req *);
 	int status;
 	struct htc_endpoint *ep;

commit d4df78904d12850c1c57bfffde8eff5195f3cd4d
Author: Vasanthakumar Thiagarajan <vthiagar@qca.qualcomm.com>
Date:   Sat Jul 16 20:29:07 2011 +0530

    ath6kl: Remove struct hif_scatter_req_priv
    
    Signed-off-by: Vasanthakumar Thiagarajan <vthiagar@qca.qualcomm.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath6kl/hif.h b/drivers/net/wireless/ath/ath6kl/hif.h
index ca401041abfb..35f90a3b5a8b 100644
--- a/drivers/net/wireless/ath/ath6kl/hif.h
+++ b/drivers/net/wireless/ath/ath6kl/hif.h
@@ -177,7 +177,8 @@ struct hif_scatter_req {
 	struct htc_endpoint *ep;
 	int scat_entries;
 
-	struct hif_scatter_req_priv *req_priv;
+	struct bus_request *busrequest;
+	struct scatterlist *sgentries;
 
 	/* bounce buffer for upper layers to copy to/from */
 	u8 *virt_dma_buf;
@@ -190,11 +191,6 @@ struct hif_dev_scat_sup_info {
 	int max_xfer_szper_scatreq;
 };
 
-struct hif_scatter_req_priv {
-	struct bus_request *busrequest;
-	struct scatterlist sgentries[MAX_SCATTER_ENTRIES_PER_REQ];
-};
-
 struct ath6kl_hif_ops {
 	int (*read_write_sync)(struct ath6kl *ar, u32 addr, u8 *buf,
 			       u32 len, u32 request);

commit f74a7361b8affcd76ffe1e2baa5748af4d63bcea
Author: Vasanthakumar Thiagarajan <vthiagar@qca.qualcomm.com>
Date:   Sat Jul 16 20:29:05 2011 +0530

    ath6kl: cleanup callbacks for different scatter gather method
    
    Define a hook in ath6kl_hif_ops for hif scatter gather mechanism.
    When virtual scatter gather is used, call the respective function
    directly.
    
    Signed-off-by: Vasanthakumar Thiagarajan <vthiagar@qca.qualcomm.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath6kl/hif.h b/drivers/net/wireless/ath/ath6kl/hif.h
index 7d39c1769fe4..ca401041abfb 100644
--- a/drivers/net/wireless/ath/ath6kl/hif.h
+++ b/drivers/net/wireless/ath/ath6kl/hif.h
@@ -186,7 +186,6 @@ struct hif_scatter_req {
 };
 
 struct hif_dev_scat_sup_info {
-	int (*rw_scat_func) (struct ath6kl *ar, struct hif_scatter_req *);
 	int max_scat_entries;
 	int max_xfer_szper_scatreq;
 };
@@ -210,6 +209,8 @@ struct ath6kl_hif_ops {
 				struct hif_scatter_req *s_req);
 	int (*enable_scatter)(struct ath6kl *ar,
 			      struct hif_dev_scat_sup_info *info);
+	int (*scat_req_rw) (struct ath6kl *ar,
+			    struct hif_scatter_req *scat_req);
 	void (*cleanup_scatter)(struct ath6kl *ar);
 };
 

commit bdcd81707973cf8aa9305337166f8ee842a050d4
Author: Kalle Valo <kvalo@qca.qualcomm.com>
Date:   Mon Jul 18 00:22:30 2011 +0300

    Add ath6kl cleaned up driver
    
    Last May we started working on cleaning up ath6kl driver which is
    currently in staging. The work has happened in a separate
    ath6kl-cleanup tree:
    
    http://git.kernel.org/?p=linux/kernel/git/kvalo/ath6kl-cleanup.git;a=summary
    
    After over 1100 (!) patches we have now reached a state where I would
    like to start discussing about pushing the driver to the wireless
    trees and replacing the staging driver.
    
    The driver is now a lot smaller and looks like a proper Linux driver.
    The size of the driver (measured with simple wc -l) dropped from 49
    kLOC to 18 kLOC and the number of the .c and .h files dropped from 107
    to 22. Most importantly the number of subdirectories reduced from 26
    to zero :)
    
    There are two remaining checkpatch warnings in the driver which we
    decided to omit for now:
    
    drivers/net/wireless/ath/ath6kl/debug.c:31:
      WARNING: printk() should include KERN_ facility level
    drivers/net/wireless/ath/ath6kl/sdio.c:527:
      WARNING: msleep < 20ms can sleep for up to 20ms;
      see Documentation/timers/timers-howto.txt
    
    The driver has endian annotations for all the hardware specific
    structures and there are no sparse errors. Unfortunately I don't have
    any big endian hardware to test that right now.
    
    We have been testing the driver both on x86 and arm platforms. The
    code is also compiled with sparc and parisc cross compilers.
    
    Notable missing features compared to the current staging driver are:
    
    o HCI over SDIO support
    o nl80211 testmode
    o firmware logging
    o suspend support
    
    Testmode, firmware logging and suspend support will be added soon. HCI
    over SDIO support will be more difficult as the HCI driver needs to
    share code with the wifi driver. This is something we need to research
    more.
    
    Also I want to point out the changes I did for signed endian support.
    As I wasn't able to find any support for signed endian annotations I
    decided to follow what NTFS has done and added my own. Grep for sle16
    and sle32, especially from wmi.h.
    
    Various people have been working on the cleanup, the hall of
    fame based on number of patches is:
    
       543  Vasanthakumar Thiagarajan
       403  Raja Mani
       252  Kalle Valo
        16  Vivek Natarajan
        12  Suraj Sumangala
         3  Joe Perches
         2  Jouni Malinen
    
    Signed-off-by: Vasanthakumar Thiagarajan <vthiagar@qca.qualcomm.com>
    Signed-off-by: Raja Mani <rmani@qca.qualcomm.com>
    Signed-off-by: Vivek Natarajan <nataraja@qca.qualcomm.com>
    Signed-off-by: Suraj Sumangala <surajs@qca.qualcomm.com>
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Jouni Malinen <jouni@qca.qualcomm.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath6kl/hif.h b/drivers/net/wireless/ath/ath6kl/hif.h
new file mode 100644
index 000000000000..7d39c1769fe4
--- /dev/null
+++ b/drivers/net/wireless/ath/ath6kl/hif.h
@@ -0,0 +1,216 @@
+/*
+ * Copyright (c) 2004-2011 Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef HIF_H
+#define HIF_H
+
+#include "common.h"
+#include "core.h"
+
+#include <linux/scatterlist.h>
+
+#define BUS_REQUEST_MAX_NUM                64
+#define HIF_MBOX_BLOCK_SIZE                128
+#define HIF_MBOX0_BLOCK_SIZE               1
+
+#define HIF_DMA_BUFFER_SIZE (32 * 1024)
+#define CMD53_FIXED_ADDRESS 1
+#define CMD53_INCR_ADDRESS  2
+
+#define MAX_SCATTER_REQUESTS             4
+#define MAX_SCATTER_ENTRIES_PER_REQ      16
+#define MAX_SCATTER_REQ_TRANSFER_SIZE    (32 * 1024)
+
+#define MANUFACTURER_ID_AR6003_BASE        0x300
+    /* SDIO manufacturer ID and Codes */
+#define MANUFACTURER_ID_ATH6KL_BASE_MASK     0xFF00
+#define MANUFACTURER_CODE                  0x271	/* Atheros */
+
+/* Mailbox address in SDIO address space */
+#define HIF_MBOX_BASE_ADDR                 0x800
+#define HIF_MBOX_WIDTH                     0x800
+
+#define HIF_MBOX_END_ADDR  (HTC_MAILBOX_NUM_MAX * HIF_MBOX_WIDTH - 1)
+
+/* version 1 of the chip has only a 12K extended mbox range */
+#define HIF_MBOX0_EXT_BASE_ADDR  0x4000
+#define HIF_MBOX0_EXT_WIDTH      (12*1024)
+
+/* GMBOX addresses */
+#define HIF_GMBOX_BASE_ADDR                0x7000
+#define HIF_GMBOX_WIDTH                    0x4000
+
+/* interrupt mode register */
+#define CCCR_SDIO_IRQ_MODE_REG         0xF0
+
+/* mode to enable special 4-bit interrupt assertion without clock */
+#define SDIO_IRQ_MODE_ASYNC_4BIT_IRQ   (1 << 0)
+
+struct bus_request {
+	struct list_head list;
+
+	/* request data */
+	u32 address;
+
+	u8 *buffer;
+	u32 length;
+	u32 request;
+	struct htc_packet *packet;
+	int status;
+
+	/* this is a scatter request */
+	struct hif_scatter_req *scat_req;
+};
+
+/* direction of transfer (read/write) */
+#define HIF_READ                    0x00000001
+#define HIF_WRITE                   0x00000002
+#define HIF_DIR_MASK                (HIF_READ | HIF_WRITE)
+
+/*
+ *     emode - This indicates the whether the command is to be executed in a
+ *             blocking or non-blocking fashion (HIF_SYNCHRONOUS/
+ *             HIF_ASYNCHRONOUS). The read/write data paths in HTC have been
+ *             implemented using the asynchronous mode allowing the the bus
+ *             driver to indicate the completion of operation through the
+ *             registered callback routine. The requirement primarily comes
+ *             from the contexts these operations get called from (a driver's
+ *             transmit context or the ISR context in case of receive).
+ *             Support for both of these modes is essential.
+ */
+#define HIF_SYNCHRONOUS             0x00000010
+#define HIF_ASYNCHRONOUS            0x00000020
+#define HIF_EMODE_MASK              (HIF_SYNCHRONOUS | HIF_ASYNCHRONOUS)
+
+/*
+ *     dmode - An interface may support different kinds of commands based on
+ *             the tradeoff between the amount of data it can carry and the
+ *             setup time. Byte and Block modes are supported (HIF_BYTE_BASIS/
+ *             HIF_BLOCK_BASIS). In case of latter, the data is rounded off
+ *             to the nearest block size by padding. The size of the block is
+ *             configurable at compile time using the HIF_BLOCK_SIZE and is
+ *             negotiated with the target during initialization after the
+ *             ATH6KL interrupts are enabled.
+ */
+#define HIF_BYTE_BASIS              0x00000040
+#define HIF_BLOCK_BASIS             0x00000080
+#define HIF_DMODE_MASK              (HIF_BYTE_BASIS | HIF_BLOCK_BASIS)
+
+/*
+ *     amode - This indicates if the address has to be incremented on ATH6KL
+ *             after every read/write operation (HIF?FIXED_ADDRESS/
+ *             HIF_INCREMENTAL_ADDRESS).
+ */
+#define HIF_FIXED_ADDRESS           0x00000100
+#define HIF_INCREMENTAL_ADDRESS     0x00000200
+#define HIF_AMODE_MASK		  (HIF_FIXED_ADDRESS | HIF_INCREMENTAL_ADDRESS)
+
+#define HIF_WR_ASYNC_BYTE_INC					\
+	(HIF_WRITE | HIF_ASYNCHRONOUS |				\
+	 HIF_BYTE_BASIS | HIF_INCREMENTAL_ADDRESS)
+
+#define HIF_WR_ASYNC_BLOCK_INC					\
+	(HIF_WRITE | HIF_ASYNCHRONOUS |				\
+	 HIF_BLOCK_BASIS | HIF_INCREMENTAL_ADDRESS)
+
+#define HIF_WR_SYNC_BYTE_FIX					\
+	(HIF_WRITE | HIF_SYNCHRONOUS |				\
+	 HIF_BYTE_BASIS | HIF_FIXED_ADDRESS)
+
+#define HIF_WR_SYNC_BYTE_INC					\
+	(HIF_WRITE | HIF_SYNCHRONOUS |				\
+	 HIF_BYTE_BASIS | HIF_INCREMENTAL_ADDRESS)
+
+#define HIF_WR_SYNC_BLOCK_INC					\
+	(HIF_WRITE | HIF_SYNCHRONOUS |				\
+	 HIF_BLOCK_BASIS | HIF_INCREMENTAL_ADDRESS)
+
+#define HIF_RD_SYNC_BYTE_INC						\
+	(HIF_READ | HIF_SYNCHRONOUS |					\
+	 HIF_BYTE_BASIS | HIF_INCREMENTAL_ADDRESS)
+
+#define HIF_RD_SYNC_BYTE_FIX						\
+	(HIF_READ | HIF_SYNCHRONOUS |					\
+	 HIF_BYTE_BASIS | HIF_FIXED_ADDRESS)
+
+#define HIF_RD_ASYNC_BLOCK_FIX						\
+	(HIF_READ | HIF_ASYNCHRONOUS |					\
+	 HIF_BLOCK_BASIS | HIF_FIXED_ADDRESS)
+
+#define HIF_RD_SYNC_BLOCK_FIX						\
+	(HIF_READ | HIF_SYNCHRONOUS |					\
+	 HIF_BLOCK_BASIS | HIF_FIXED_ADDRESS)
+
+struct hif_scatter_item {
+	u8 *buf;
+	int len;
+	struct htc_packet *packet;
+};
+
+struct hif_scatter_req {
+	struct list_head list;
+	/* address for the read/write operation */
+	u32 addr;
+
+	/* request flags */
+	u32 req;
+
+	/* total length of entire transfer */
+	u32 len;
+
+	u32 flags;
+	void (*complete) (struct hif_scatter_req *);
+	int status;
+	struct htc_endpoint *ep;
+	int scat_entries;
+
+	struct hif_scatter_req_priv *req_priv;
+
+	/* bounce buffer for upper layers to copy to/from */
+	u8 *virt_dma_buf;
+
+	struct hif_scatter_item scat_list[1];
+};
+
+struct hif_dev_scat_sup_info {
+	int (*rw_scat_func) (struct ath6kl *ar, struct hif_scatter_req *);
+	int max_scat_entries;
+	int max_xfer_szper_scatreq;
+};
+
+struct hif_scatter_req_priv {
+	struct bus_request *busrequest;
+	struct scatterlist sgentries[MAX_SCATTER_ENTRIES_PER_REQ];
+};
+
+struct ath6kl_hif_ops {
+	int (*read_write_sync)(struct ath6kl *ar, u32 addr, u8 *buf,
+			       u32 len, u32 request);
+	int (*write_async)(struct ath6kl *ar, u32 address, u8 *buffer,
+			   u32 length, u32 request, struct htc_packet *packet);
+
+	void (*irq_enable)(struct ath6kl *ar);
+	void (*irq_disable)(struct ath6kl *ar);
+
+	struct hif_scatter_req *(*scatter_req_get)(struct ath6kl *ar);
+	void (*scatter_req_add)(struct ath6kl *ar,
+				struct hif_scatter_req *s_req);
+	int (*enable_scatter)(struct ath6kl *ar,
+			      struct hif_dev_scat_sup_info *info);
+	void (*cleanup_scatter)(struct ath6kl *ar);
+};
+
+#endif
