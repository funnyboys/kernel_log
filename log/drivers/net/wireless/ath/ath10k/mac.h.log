commit 1382993f882b6b96c99837fd8b705300a208de3a
Author: Wen Gong <wgong@codeaurora.org>
Date:   Tue Oct 1 15:04:56 2019 +0300

    ath10k: add support for hardware rfkill
    
    When hardware rfkill is enabled in the firmware it will report the
    capability via using WMI_TLV_SYS_CAP_INFO_RFKILL bit in the WMI_SERVICE_READY
    event to the host. ath10k will check the capability, and if it is enabled then
    ath10k will set the GPIO information to firmware using WMI_PDEV_SET_PARAM. When
    the firmware detects hardware rfkill is enabled by the user, it will report it
    via WMI_RFKILL_STATE_CHANGE_EVENTID. Once ath10k receives the event it will
    send wmi command WMI_PDEV_SET_PARAM to the firmware to enable/disable the radio
    and also notifies cfg80211.
    
    We can't power off the device when rfkill is enabled, as otherwise the
    firmware would not be able to detect GPIO changes and report them to the
    host. So when rfkill is enabled, we need to keep the firmware running.
    
    Tested with QCA6174 PCI with firmware
    WLAN.RM.4.4.1-00109-QCARMSWPZ-1.
    
    Signed-off-by: Alan Liu <alanliu@codeaurora.org>
    Signed-off-by: Wen Gong <wgong@codeaurora.org>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/ath/ath10k/mac.h b/drivers/net/wireless/ath/ath10k/mac.h
index 1fe84948b868..98d83a26ea60 100644
--- a/drivers/net/wireless/ath/ath10k/mac.h
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -72,6 +72,7 @@ struct ieee80211_txq *ath10k_mac_txq_lookup(struct ath10k *ar,
 					    u8 tid);
 int ath10k_mac_ext_resource_config(struct ath10k *ar, u32 val);
 void ath10k_mac_wait_tx_complete(struct ath10k *ar);
+int ath10k_mac_rfkill_enable_radio(struct ath10k *ar, bool enable);
 
 static inline void ath10k_tx_h_seq_no(struct ieee80211_vif *vif,
 				      struct sk_buff *skb)

commit f0553ca9ceb5ff403623e31b7501d33ec84ce1fa
Author: Kalle Valo <kvalo@codeaurora.org>
Date:   Tue Feb 19 19:45:26 2019 +0200

    ath10k: switch to use SPDX license identifiers
    
    Use SPDX identifiers everywhere in ath10k.
    
    Makefile was incorrectly marked in commit b24413180f56 ("License cleanup: add
    SPDX GPL-2.0 license identifier to files with no license"), fix that as well.
    
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/ath/ath10k/mac.h b/drivers/net/wireless/ath/ath10k/mac.h
index 570493d2d648..1fe84948b868 100644
--- a/drivers/net/wireless/ath/ath10k/mac.h
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -1,18 +1,7 @@
+/* SPDX-License-Identifier: ISC */
 /*
  * Copyright (c) 2005-2011 Atheros Communications Inc.
  * Copyright (c) 2011-2017 Qualcomm Atheros, Inc.
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
 #ifndef _MAC_H_

commit 828853ac58265c93249b53ba81782213962d5d4e
Author: Wen Gong <wgong@codeaurora.org>
Date:   Tue Aug 28 19:48:42 2018 +0300

    ath10k: add waiting htt tx complete before wow enable
    
    If there are some tx packets pending in firmware, and then system
    enters suspend, firmware will fail for wow enable. This will trigger
    mac80211 to stop ath10k and download firmware again, then it is
    non-wow suspend.
    
    After add the waiting htt tx complete, then firmware will have some
    time window to send or flush the pending tx packets.
    
    Tested with QCA6174 PCI with firmware
    WLAN.RM.4.4.1-00109-QCARMSWPZ-1, but this will also affect QCA9377 PCI.
    It's not a regression with new firmware releases.
    
    Signed-off-by: Wen Gong <wgong@codeaurora.org>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/ath/ath10k/mac.h b/drivers/net/wireless/ath/ath10k/mac.h
index 81f8d6c0af35..570493d2d648 100644
--- a/drivers/net/wireless/ath/ath10k/mac.h
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -82,6 +82,7 @@ struct ieee80211_txq *ath10k_mac_txq_lookup(struct ath10k *ar,
 					    u16 peer_id,
 					    u8 tid);
 int ath10k_mac_ext_resource_config(struct ath10k *ar, u32 val);
+void ath10k_mac_wait_tx_complete(struct ath10k *ar);
 
 static inline void ath10k_tx_h_seq_no(struct ieee80211_vif *vif,
 				      struct sk_buff *skb)

commit 8b1083d6188222c5efceb120b3334f0d8527c215
Author: Kalle Valo <kvalo@qca.qualcomm.com>
Date:   Fri Dec 22 18:31:13 2017 +0200

    ath10k: update copyright year
    
    Update year for Qualcomm Atheros, Inc. copyrights.
    
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath10k/mac.h b/drivers/net/wireless/ath/ath10k/mac.h
index 553747bc19ed..81f8d6c0af35 100644
--- a/drivers/net/wireless/ath/ath10k/mac.h
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2005-2011 Atheros Communications Inc.
- * Copyright (c) 2011-2013 Qualcomm Atheros, Inc.
+ * Copyright (c) 2011-2017 Qualcomm Atheros, Inc.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above

commit 56ac13bfc703d5189e8b91c5c2f512830d1cb013
Author: Amadeusz Sławiński <amadeusz.slawinski@tieto.com>
Date:   Mon Feb 13 12:38:37 2017 +0200

    ath10k: remove ath10k_vif_to_arvif()
    
    it adds unnecessary level of indirection, while we just access structure
    field
    
    Signed-off-by: Amadeusz Sławiński <amadeusz.slawinski@tieto.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath10k/mac.h b/drivers/net/wireless/ath/ath10k/mac.h
index 1bd29ecfcdcc..553747bc19ed 100644
--- a/drivers/net/wireless/ath/ath10k/mac.h
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -83,17 +83,12 @@ struct ieee80211_txq *ath10k_mac_txq_lookup(struct ath10k *ar,
 					    u8 tid);
 int ath10k_mac_ext_resource_config(struct ath10k *ar, u32 val);
 
-static inline struct ath10k_vif *ath10k_vif_to_arvif(struct ieee80211_vif *vif)
-{
-	return (struct ath10k_vif *)vif->drv_priv;
-}
-
 static inline void ath10k_tx_h_seq_no(struct ieee80211_vif *vif,
 				      struct sk_buff *skb)
 {
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
-	struct ath10k_vif *arvif = ath10k_vif_to_arvif(vif);
+	struct ath10k_vif *arvif = (void *)vif->drv_priv;
 
 	if (info->flags  & IEEE80211_TX_CTL_ASSIGN_SEQ) {
 		if (arvif->tx_seq_no == 0)

commit 7e247a9e88dc811d0b7b6a70af1d741054772bc4
Author: Raja Mani <rmani@qti.qualcomm.com>
Date:   Tue Apr 12 20:15:53 2016 +0530

    ath10k: add dynamic tx mode switch config support for qca4019
    
    push-pull mode needs certain amount the host driver involvement for
    managing queues in the host memory and packet delivery to firmware.
    qca4019 wifi firmware has an option to stay in push mode for less
    number of active traffic flow and then switch to push-pull mode when
    the active traffic flow goes beyond the certain limit.
    
    The advantage of staying in push mode for less active traffic is, the
    host cpu consumption is reduced. qca4019 firmware supports this
    flexibility of the mode switch. It takes the host driver interest
    (LOW_PERF/HIGH_PERF) via WMI_EXT_RESOURCE_CFG_CMDID,
    
     LOW_PERF  - fw would stay in push mode and switch to push-pull
                   based on demand.
     HIGH_PERF - fw would stay in push-pull mode from the boot.
    
    To make this configuration generic, new WMI services
    WMI_SERVICE_TX_MODE_PUSH_ONLY, WMI_SERVICE_TX_MODE_PUSH_PULL,
    WMI_SERVICE_TX_MODE_DYNAMIC are introduced to take dynamic tx mode
    switch support availability in firmware.
    Based on WMI_SERVICE_TX_MODE_DYNAMIC, LOW_PERF or HIGHT_PERF is
    configured to the firmware.
    
    Signed-off-by: Raja Mani <rmani@qti.qualcomm.com>
    Signed-off-by: Tamizh chelvam <c_traja@qti.qualcomm.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath10k/mac.h b/drivers/net/wireless/ath/ath10k/mac.h
index 2c3327beb445..1bd29ecfcdcc 100644
--- a/drivers/net/wireless/ath/ath10k/mac.h
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -81,6 +81,7 @@ int ath10k_mac_tx_push_txq(struct ieee80211_hw *hw,
 struct ieee80211_txq *ath10k_mac_txq_lookup(struct ath10k *ar,
 					    u16 peer_id,
 					    u8 tid);
+int ath10k_mac_ext_resource_config(struct ath10k *ar, u32 val);
 
 static inline struct ath10k_vif *ath10k_vif_to_arvif(struct ieee80211_vif *vif)
 {

commit 426e10eaf76d7229ed6c2978f0d473d04ba0b377
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Sun Mar 6 16:14:43 2016 +0200

    ath10k: implement push-pull tx
    
    The current/old tx path design was that host, at
    its own leisure, pushed tx frames to the device.
    For HTT there was ~1000-1400 msdu queue depth.
    
    After reaching that limit the driver would request
    mac80211 to stop queues. There was little control
    over what packets got in there as far as
    DA/RA was considered so it was rather easy to
    starve per-station traffic flows.
    
    With MU-MIMO this became a significant problem
    because the queue depth was insufficient to buffer
    frames from multiple clients (which could have
    different signal quality and capabilities) in an
    efficient fashion.
    
    Hence the new tx path in 10.4 was introduced: a
    pull-push mode.
    
    Firmware and host can share tx queue state via
    DMA. The state is logically a 2 dimensional array
    addressed via peer_id+tid pair. Each entry is a
    counter (either number of bytes or packets. Host
    keeps it updated and firmware uses it for
    scheduling Tx pull requests to host.
    
    This allows MU-MIMO to become a lot more effective
    with 10+ clients.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath10k/mac.h b/drivers/net/wireless/ath/ath10k/mac.h
index 453f606a250e..2c3327beb445 100644
--- a/drivers/net/wireless/ath/ath10k/mac.h
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -76,6 +76,11 @@ void ath10k_mac_vif_tx_lock(struct ath10k_vif *arvif, int reason);
 void ath10k_mac_vif_tx_unlock(struct ath10k_vif *arvif, int reason);
 bool ath10k_mac_tx_frm_has_freq(struct ath10k *ar);
 void ath10k_mac_tx_push_pending(struct ath10k *ar);
+int ath10k_mac_tx_push_txq(struct ieee80211_hw *hw,
+			   struct ieee80211_txq *txq);
+struct ieee80211_txq *ath10k_mac_txq_lookup(struct ath10k *ar,
+					    u16 peer_id,
+					    u8 tid);
 
 static inline struct ath10k_vif *ath10k_vif_to_arvif(struct ieee80211_vif *vif)
 {

commit 299468782d94331f99a7eeb6e0d56598863be9fe
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Sun Mar 6 16:14:34 2016 +0200

    ath10k: implement wake_tx_queue
    
    This implements very basic support for software
    queueing. It also contains some knobs that will be
    patched later.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath10k/mac.h b/drivers/net/wireless/ath/ath10k/mac.h
index 53091588090d..453f606a250e 100644
--- a/drivers/net/wireless/ath/ath10k/mac.h
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -75,6 +75,7 @@ void ath10k_mac_tx_unlock(struct ath10k *ar, int reason);
 void ath10k_mac_vif_tx_lock(struct ath10k_vif *arvif, int reason);
 void ath10k_mac_vif_tx_unlock(struct ath10k_vif *arvif, int reason);
 bool ath10k_mac_tx_frm_has_freq(struct ath10k *ar);
+void ath10k_mac_tx_push_pending(struct ath10k *ar);
 
 static inline struct ath10k_vif *ath10k_vif_to_arvif(struct ieee80211_vif *vif)
 {

commit 4b7f353b8026b43e66af475ef2266958ddcfa6eb
Author: Yanbo Li <yanbol@qca.qualcomm.com>
Date:   Thu Nov 12 10:36:10 2015 -0800

    ath10k: fix the wrong RX rate idx report at 11G mode
    
    The RX rate idx is not correct for 11G mode OFDM packet.
    Because the bitrate table start with CCK index instead of OFDM.
    
    Signed-off-by: Yanbo Li <yanbol@qca.qualcomm.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath10k/mac.h b/drivers/net/wireless/ath/ath10k/mac.h
index f5048049b870..53091588090d 100644
--- a/drivers/net/wireless/ath/ath10k/mac.h
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -66,7 +66,7 @@ void ath10k_mac_handle_tx_pause_vdev(struct ath10k *ar, u32 vdev_id,
 				     enum wmi_tlv_tx_pause_action action);
 
 u8 ath10k_mac_hw_rate_to_idx(const struct ieee80211_supported_band *sband,
-			     u8 hw_rate);
+			     u8 hw_rate, bool cck);
 u8 ath10k_mac_bitrate_to_idx(const struct ieee80211_supported_band *sband,
 			     u32 bitrate);
 

commit d39de9919a0cded8ddb1655441cf403ad5690d6d
Author: Vasanthakumar Thiagarajan <vthiagar@qti.qualcomm.com>
Date:   Thu Nov 5 11:34:00 2015 +0530

    ath10k: fix peerid configuration in htt tx desc for htt version < 3.4
    
    Of a word in struct htt_data_tx_desc htt version >= 3.4 firmware uses
    LSB 16-bit for frequency configuration which is used for offchannel tx
    and MSB 16-bit is for peerid. But other firmwares using version 2.X
    (10.1, 10.2.2, 10.2.4 and 10.4) are using 32-bit for peerid in htt tx
    desc. So far no issue is found with the existing code setting peerid and
    freq for HTT version 2.X, this could be mainly because of 0 as frequecy
    (home channel) is being always passed with those firmwares. There may be
    issues when non-zero freq is passed with firmware using < 3.4 htt version.
    To be safe use target_version_major and target_version_minor along with
    htt-op-version before configuring peer id and freq in htt tx desc. This
    patch extends ath10k_mac_tx_frm_has_freq() to check for htt_op_version_tlv
    and uses the helper while setting peerid in htt_tx_desc.
    
    Fixes: 8d6d36243610 ("ath10k: fix offchan reliability")
    Signed-off-by: Vasanthakumar Thiagarajan <vthiagar@qti.qualcomm.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath10k/mac.h b/drivers/net/wireless/ath/ath10k/mac.h
index e3cefe4c7cfd..f5048049b870 100644
--- a/drivers/net/wireless/ath/ath10k/mac.h
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -74,6 +74,7 @@ void ath10k_mac_tx_lock(struct ath10k *ar, int reason);
 void ath10k_mac_tx_unlock(struct ath10k *ar, int reason);
 void ath10k_mac_vif_tx_lock(struct ath10k_vif *arvif, int reason);
 void ath10k_mac_vif_tx_unlock(struct ath10k_vif *arvif, int reason);
+bool ath10k_mac_tx_frm_has_freq(struct ath10k *ar);
 
 static inline struct ath10k_vif *ath10k_vif_to_arvif(struct ieee80211_vif *vif)
 {

commit acd0b27bb13a09dd0a56d4562d3eb4137a7318b2
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Thu Jul 9 13:08:38 2015 +0200

    ath10k: fix per-vif queue locking
    
    Whenever any vdev was supposed to be paused all Tx
    queues were stopped (except offchannel) instead of
    only these associated with the given vdev.
    
    This caused subtle issues with
    multi-channel/multi-vif scenarios, e.g.
    authentication of station vif could sometimes fail
    depending on fw tx pause request timing.
    
    Fixes: b4aa539dd8f2 ("ath10k: implement tx pause wmi event")
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath10k/mac.h b/drivers/net/wireless/ath/ath10k/mac.h
index b291f063705c..e3cefe4c7cfd 100644
--- a/drivers/net/wireless/ath/ath10k/mac.h
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -61,9 +61,9 @@ int ath10k_mac_vif_chan(struct ieee80211_vif *vif,
 
 void ath10k_mac_handle_beacon(struct ath10k *ar, struct sk_buff *skb);
 void ath10k_mac_handle_beacon_miss(struct ath10k *ar, u32 vdev_id);
-void ath10k_mac_handle_tx_pause(struct ath10k *ar, u32 vdev_id,
-				enum wmi_tlv_tx_pause_id pause_id,
-				enum wmi_tlv_tx_pause_action action);
+void ath10k_mac_handle_tx_pause_vdev(struct ath10k *ar, u32 vdev_id,
+				     enum wmi_tlv_tx_pause_id pause_id,
+				     enum wmi_tlv_tx_pause_action action);
 
 u8 ath10k_mac_hw_rate_to_idx(const struct ieee80211_supported_band *sband,
 			     u8 hw_rate);

commit b4aa539dd8f2e086f7b03e0781ec85897913c3cb
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Tue Mar 31 10:26:24 2015 +0000

    ath10k: implement tx pause wmi event
    
    qca6174 wmi-tlv firmware defines a new wmi event
    for host tx pausing (i.e. stop/wake tx queues).
    
    Map these events to ath10k/mac80211 tx queue
    control.
    
    This is important for multi-channel throughput
    performance.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath10k/mac.h b/drivers/net/wireless/ath/ath10k/mac.h
index 25819efb8b5d..b291f063705c 100644
--- a/drivers/net/wireless/ath/ath10k/mac.h
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -23,6 +23,9 @@
 
 #define WEP_KEYID_SHIFT 6
 
+enum wmi_tlv_tx_pause_id;
+enum wmi_tlv_tx_pause_action;
+
 struct ath10k_generic_iter {
 	struct ath10k *ar;
 	int ret;
@@ -55,8 +58,12 @@ bool ath10k_mac_is_peer_wep_key_set(struct ath10k *ar, const u8 *addr,
 				    u8 keyidx);
 int ath10k_mac_vif_chan(struct ieee80211_vif *vif,
 			struct cfg80211_chan_def *def);
+
 void ath10k_mac_handle_beacon(struct ath10k *ar, struct sk_buff *skb);
 void ath10k_mac_handle_beacon_miss(struct ath10k *ar, u32 vdev_id);
+void ath10k_mac_handle_tx_pause(struct ath10k *ar, u32 vdev_id,
+				enum wmi_tlv_tx_pause_id pause_id,
+				enum wmi_tlv_tx_pause_action action);
 
 u8 ath10k_mac_hw_rate_to_idx(const struct ieee80211_supported_band *sband,
 			     u8 hw_rate);

commit 96d828d45e166d6d6cc240b7ef082d312d6f579f
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Tue Mar 31 10:26:23 2015 +0000

    ath10k: rework tx queue locking
    
    Tx queue locking was very simple until now.
    Multi-channel support will require a more flexible
    and fine grained control.
    
    This introduces a per-hw and per-vif (each with a
    bitmask of reasons) tx queue locking.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath10k/mac.h b/drivers/net/wireless/ath/ath10k/mac.h
index b1e3653e5e20..25819efb8b5d 100644
--- a/drivers/net/wireless/ath/ath10k/mac.h
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -63,6 +63,11 @@ u8 ath10k_mac_hw_rate_to_idx(const struct ieee80211_supported_band *sband,
 u8 ath10k_mac_bitrate_to_idx(const struct ieee80211_supported_band *sband,
 			     u32 bitrate);
 
+void ath10k_mac_tx_lock(struct ath10k *ar, int reason);
+void ath10k_mac_tx_unlock(struct ath10k *ar, int reason);
+void ath10k_mac_vif_tx_lock(struct ath10k_vif *arvif, int reason);
+void ath10k_mac_vif_tx_unlock(struct ath10k_vif *arvif, int reason);
+
 static inline struct ath10k_vif *ath10k_vif_to_arvif(struct ieee80211_vif *vif)
 {
 	return (struct ath10k_vif *)vif->drv_priv;

commit 500ff9f9389dcf4836e2f3b0cd355d16b7860e74
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Tue Mar 31 10:26:21 2015 +0000

    ath10k: implement chanctx API
    
    The chanctx API will allow ath10k to support
    multi-channel operation.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath10k/mac.h b/drivers/net/wireless/ath/ath10k/mac.h
index a381740b8fc8..b1e3653e5e20 100644
--- a/drivers/net/wireless/ath/ath10k/mac.h
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -53,6 +53,8 @@ void ath10k_mac_vif_beacon_free(struct ath10k_vif *arvif);
 void ath10k_drain_tx(struct ath10k *ar);
 bool ath10k_mac_is_peer_wep_key_set(struct ath10k *ar, const u8 *addr,
 				    u8 keyidx);
+int ath10k_mac_vif_chan(struct ieee80211_vif *vif,
+			struct cfg80211_chan_def *def);
 void ath10k_mac_handle_beacon(struct ath10k *ar, struct sk_buff *skb);
 void ath10k_mac_handle_beacon_miss(struct ath10k *ar, u32 vdev_id);
 

commit 01cebe1c50d43a79de1ee48bd9917c9fbbd3901d
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Mon Mar 30 09:51:56 2015 +0300

    ath10k: deduplicate bitrate to rate idx conversion
    
    It's possible to derive rate index from bitrate
    without any additional mapping structures/logic.
    
    This should have little to none impact on
    performance since this is only done for management
    frames and the previous approach wasn't
    particularly optimized.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath10k/mac.h b/drivers/net/wireless/ath/ath10k/mac.h
index af806c6f569b..a381740b8fc8 100644
--- a/drivers/net/wireless/ath/ath10k/mac.h
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -55,8 +55,11 @@ bool ath10k_mac_is_peer_wep_key_set(struct ath10k *ar, const u8 *addr,
 				    u8 keyidx);
 void ath10k_mac_handle_beacon(struct ath10k *ar, struct sk_buff *skb);
 void ath10k_mac_handle_beacon_miss(struct ath10k *ar, u32 vdev_id);
+
 u8 ath10k_mac_hw_rate_to_idx(const struct ieee80211_supported_band *sband,
 			     u8 hw_rate);
+u8 ath10k_mac_bitrate_to_idx(const struct ieee80211_supported_band *sband,
+			     u32 bitrate);
 
 static inline struct ath10k_vif *ath10k_vif_to_arvif(struct ieee80211_vif *vif)
 {

commit 5528e032702be937acdfe8c6395461e0e8acaa85
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Mon Mar 30 09:51:56 2015 +0300

    ath10k: rework legacy rx rate decoding
    
    Instead of using a hacky table and magic values
    use supported band information advertised to
    mac80211.
    
    This may impact performance a little when dealing
    with legacy rx rates depending on system
    architecture. It's probably negligible.
    
    This also fixes a highly theoretical corner case
    when HT/VHT rates weren't reported correctly if
    channel frequency wasn't known.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath10k/mac.h b/drivers/net/wireless/ath/ath10k/mac.h
index 2cdf68d7f08c..af806c6f569b 100644
--- a/drivers/net/wireless/ath/ath10k/mac.h
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -55,6 +55,8 @@ bool ath10k_mac_is_peer_wep_key_set(struct ath10k *ar, const u8 *addr,
 				    u8 keyidx);
 void ath10k_mac_handle_beacon(struct ath10k *ar, struct sk_buff *skb);
 void ath10k_mac_handle_beacon_miss(struct ath10k *ar, u32 vdev_id);
+u8 ath10k_mac_hw_rate_to_idx(const struct ieee80211_supported_band *sband,
+			     u8 hw_rate);
 
 static inline struct ath10k_vif *ath10k_vif_to_arvif(struct ieee80211_vif *vif)
 {

commit d740d8fd243933dfd399c9f8d78063ca020eb8bf
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Mon Mar 30 09:51:51 2015 +0300

    ath10k: unify tx mode and dispatch
    
    There are a few different tx paths depending on
    firmware and frame itself.
    
    Creating a uniform decision will make it possible
    to switch between different txmode easier, both
    for testing and for future features as well.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Marek Puzyniak <marek.puzyniak@tieto.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath10k/mac.h b/drivers/net/wireless/ath/ath10k/mac.h
index 3b64d99f9eea..2cdf68d7f08c 100644
--- a/drivers/net/wireless/ath/ath10k/mac.h
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -28,6 +28,14 @@ struct ath10k_generic_iter {
 	int ret;
 };
 
+struct rfc1042_hdr {
+	u8 llc_dsap;
+	u8 llc_ssap;
+	u8 llc_ctrl;
+	u8 snap_oui[3];
+	__be16 snap_type;
+} __packed;
+
 struct ath10k *ath10k_mac_create(size_t priv_size);
 void ath10k_mac_destroy(struct ath10k *ar);
 int ath10k_mac_register(struct ath10k *ar);

commit cc9904e694fa3b0f49bdaccdc7603ec6afa48a7a
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Tue Mar 10 16:22:01 2015 +0200

    ath10k: add hw connection monitor support
    
    Some firmware revisions (e.g. qca6174 with fw73)
    don't deliver beacons to host reliably. This
    causes random disconnects even in perfect
    conditions. This is most visible with
    multi-channel operation.
    
    All available firmware revisions seem to support
    beacon miss offloading so there shouldn't be any
    problems.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath10k/mac.h b/drivers/net/wireless/ath/ath10k/mac.h
index 68296117d203..3b64d99f9eea 100644
--- a/drivers/net/wireless/ath/ath10k/mac.h
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -45,6 +45,8 @@ void ath10k_mac_vif_beacon_free(struct ath10k_vif *arvif);
 void ath10k_drain_tx(struct ath10k *ar);
 bool ath10k_mac_is_peer_wep_key_set(struct ath10k *ar, const u8 *addr,
 				    u8 keyidx);
+void ath10k_mac_handle_beacon(struct ath10k *ar, struct sk_buff *skb);
+void ath10k_mac_handle_beacon_miss(struct ath10k *ar, u32 vdev_id);
 
 static inline struct ath10k_vif *ath10k_vif_to_arvif(struct ieee80211_vif *vif)
 {

commit 504f6cdf4ac3dfcf645453b5cd65dcc9aed0e1b9
Author: Sujith Manoharan <c_manoha@qca.qualcomm.com>
Date:   Tue Nov 25 11:46:58 2014 +0530

    ath10k: fix shared WEP
    
    When static keys are used in shared WEP, when a
    station is associated, message 3 is sent with an
    encrypted payload. But, for subsequent
    authentications that are triggered without a
    deauth, the auth frame is decrypted by the HW.
    
    To handle this, check if the WEP keys have already
    been set for the peer and if so, mark the
    frame as decrypted. This scenario can happen
    when a station changes its default TX key and initiates
    a new authentication sequence.
    
    Signed-off-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath10k/mac.h b/drivers/net/wireless/ath/ath10k/mac.h
index 4e3c989aa841..68296117d203 100644
--- a/drivers/net/wireless/ath/ath10k/mac.h
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -21,6 +21,8 @@
 #include <net/mac80211.h>
 #include "core.h"
 
+#define WEP_KEYID_SHIFT 6
+
 struct ath10k_generic_iter {
 	struct ath10k *ar;
 	int ret;
@@ -41,6 +43,8 @@ void ath10k_mgmt_over_wmi_tx_work(struct work_struct *work);
 void ath10k_halt(struct ath10k *ar);
 void ath10k_mac_vif_beacon_free(struct ath10k_vif *arvif);
 void ath10k_drain_tx(struct ath10k *ar);
+bool ath10k_mac_is_peer_wep_key_set(struct ath10k *ar, const u8 *addr,
+				    u8 keyidx);
 
 static inline struct ath10k_vif *ath10k_vif_to_arvif(struct ieee80211_vif *vif)
 {

commit 7962b0d898accdc683955af495528d4d6d24e0b3
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Tue Oct 28 10:34:38 2014 +0100

    ath10k: speed up hw recovery
    
    In some cases hw recovery was taking an absurdly
    long time due to ath10k waiting for things that
    would never really complete.
    
    Instead of waiting for inevitable timeouts poke
    all completions and wakequeues and check if it's
    still worth waiting.
    
    Reading/writing ar->state requires conf_mutex.
    Since waiters might be holding it introduce a new
    flag CRASH_FLUSH so it's possible to tell waiters
    to abort whatever they were waiting for.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath10k/mac.h b/drivers/net/wireless/ath/ath10k/mac.h
index 965c51117499..4e3c989aa841 100644
--- a/drivers/net/wireless/ath/ath10k/mac.h
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -40,6 +40,7 @@ void ath10k_mgmt_over_wmi_tx_purge(struct ath10k *ar);
 void ath10k_mgmt_over_wmi_tx_work(struct work_struct *work);
 void ath10k_halt(struct ath10k *ar);
 void ath10k_mac_vif_beacon_free(struct ath10k_vif *arvif);
+void ath10k_drain_tx(struct ath10k *ar);
 
 static inline struct ath10k_vif *ath10k_vif_to_arvif(struct ieee80211_vif *vif)
 {

commit 64badcb6d6459cc6f7b46f7d45e44c95ab874337
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Thu Sep 18 11:18:02 2014 +0300

    ath10k: workaround fw beaconing bug
    
    Some firmware revisions don't wait for beacon tx
    completion before sending another SWBA event. This
    could lead to hardware using old (freed) beacon
    data in some cases, e.g. tx credit starvation
    combined with missed TBTT. This is very very rare.
    
    On non-IOMMU-enabled hosts this could be a
    possible security issue because hw could beacon
    some random data on the air.  On IOMMU-enabled
    hosts DMAR faults would occur in most cases and
    target device would crash.
    
    Since there are no beacon tx completions (implicit
    nor explicit) propagated to host the only
    workaround for this is to allocate a DMA-coherent
    buffer for a lifetime of a vif and use it for all
    beacon tx commands. Worst case for this approach
    is some beacons may become corrupted, e.g. garbled
    IEs or out-of-date TIM bitmap.
    
    Keep the original beacon-related code as-is in
    case future firmware revisions solve this problem
    so that the old path can be easily re-enabled with
    a fw_feature flag.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath10k/mac.h b/drivers/net/wireless/ath/ath10k/mac.h
index 6c80eeada3e2..965c51117499 100644
--- a/drivers/net/wireless/ath/ath10k/mac.h
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -39,6 +39,7 @@ void ath10k_offchan_tx_work(struct work_struct *work);
 void ath10k_mgmt_over_wmi_tx_purge(struct ath10k *ar);
 void ath10k_mgmt_over_wmi_tx_work(struct work_struct *work);
 void ath10k_halt(struct ath10k *ar);
+void ath10k_mac_vif_beacon_free(struct ath10k_vif *arvif);
 
 static inline struct ath10k_vif *ath10k_vif_to_arvif(struct ieee80211_vif *vif)
 {

commit e7b541948b7ae542267257a6183341f6a92ed1b8
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Thu Aug 7 11:03:27 2014 +0200

    ath10k: embed ar_pci inside ar
    
    Use the common convention of embedding private
    structures inside parent structures. This
    reduces allocations and simplifies pci probing
    code.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath10k/mac.h b/drivers/net/wireless/ath/ath10k/mac.h
index e64fce70e9eb..6c80eeada3e2 100644
--- a/drivers/net/wireless/ath/ath10k/mac.h
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -26,7 +26,7 @@ struct ath10k_generic_iter {
 	int ret;
 };
 
-struct ath10k *ath10k_mac_create(void);
+struct ath10k *ath10k_mac_create(size_t priv_size);
 void ath10k_mac_destroy(struct ath10k *ar);
 int ath10k_mac_register(struct ath10k *ar);
 void ath10k_mac_unregister(struct ath10k *ar);

commit 5c81c7fd62004be13a3c9345ca25607d14862cc4
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Tue Aug 5 14:54:44 2014 +0200

    ath10k: introduce a stricter scan state machine
    
    This aims at fixing some rare scan bugs related to
    firmware reporting unexpected scan event
    sequences.
    
    One such bug was if spectral scan phyerr reporting
    prevented firmware from properly propagating scan
    events to host. This led to scan timeout. After
    that next scan would trigger scan completed event
    first (before scan started event) leading to
    ar->scan.in_progress and timeout timer states to
    be overwritten incorrectly and making the very
    next scan to hang forever.
    
    Reported-by: Janusz Dziedzic <janusz.dziedzic@tieto.com>
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath10k/mac.h b/drivers/net/wireless/ath/ath10k/mac.h
index ef4f84376d7c..e64fce70e9eb 100644
--- a/drivers/net/wireless/ath/ath10k/mac.h
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -31,7 +31,9 @@ void ath10k_mac_destroy(struct ath10k *ar);
 int ath10k_mac_register(struct ath10k *ar);
 void ath10k_mac_unregister(struct ath10k *ar);
 struct ath10k_vif *ath10k_get_arvif(struct ath10k *ar, u32 vdev_id);
-void ath10k_reset_scan(unsigned long ptr);
+void __ath10k_scan_finish(struct ath10k *ar);
+void ath10k_scan_finish(struct ath10k *ar);
+void ath10k_scan_timeout_work(struct work_struct *work);
 void ath10k_offchan_tx_purge(struct ath10k *ar);
 void ath10k_offchan_tx_work(struct work_struct *work);
 void ath10k_mgmt_over_wmi_tx_purge(struct ath10k *ar);

commit 4b6045586f31c7cc49b641a7ad5298b0c379a1c7
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Mon Jul 21 21:03:09 2014 +0300

    ath10k: simplify tx helpers
    
    It always bugged me how tid is computed and stored
    in a temporary var before written to the control
    buffer. It was confusing and it made it difficult
    to work with tx helpers.
    
    While at it rename the qos workaround function as
    it was misleading - it's not a workaround but
    preparation for nwifi tx mode.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath10k/mac.h b/drivers/net/wireless/ath/ath10k/mac.h
index ba1021997b8f..ef4f84376d7c 100644
--- a/drivers/net/wireless/ath/ath10k/mac.h
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -43,11 +43,11 @@ static inline struct ath10k_vif *ath10k_vif_to_arvif(struct ieee80211_vif *vif)
 	return (struct ath10k_vif *)vif->drv_priv;
 }
 
-static inline void ath10k_tx_h_seq_no(struct sk_buff *skb)
+static inline void ath10k_tx_h_seq_no(struct ieee80211_vif *vif,
+				      struct sk_buff *skb)
 {
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
-	struct ieee80211_vif *vif = info->control.vif;
 	struct ath10k_vif *arvif = ath10k_vif_to_arvif(vif);
 
 	if (info->flags  & IEEE80211_TX_CTL_ASSIGN_SEQ) {

commit 5e00d31a0fb74c36f3b174ff0d4914cf09016e6f
Author: Bartosz Markowski <bartosz.markowski@tieto.com>
Date:   Thu Sep 26 17:47:12 2013 +0200

    ath10k: bring back the WMI path for mgmt frames
    
    This is still the only way to submit mgmt frames in case
    of 10.X firmware.
    
    This patch introduces wmi_mgmt_tx queue, because of the
    fact WMI command can block. This is a problem for
    ath10k_tx_htt(), since it's called from atomic context.
    The skb queue and worker are introduced to move the mgmt
    frame handling out of .tx callback context and not block.
    
    Signed-off-by: Bartosz Markowski <bartosz.markowski@tieto.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath10k/mac.h b/drivers/net/wireless/ath/ath10k/mac.h
index 6fce9bfb19a5..ba1021997b8f 100644
--- a/drivers/net/wireless/ath/ath10k/mac.h
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -34,6 +34,8 @@ struct ath10k_vif *ath10k_get_arvif(struct ath10k *ar, u32 vdev_id);
 void ath10k_reset_scan(unsigned long ptr);
 void ath10k_offchan_tx_purge(struct ath10k *ar);
 void ath10k_offchan_tx_work(struct work_struct *work);
+void ath10k_mgmt_over_wmi_tx_purge(struct ath10k *ar);
+void ath10k_mgmt_over_wmi_tx_work(struct work_struct *work);
 void ath10k_halt(struct ath10k *ar);
 
 static inline struct ath10k_vif *ath10k_vif_to_arvif(struct ieee80211_vif *vif)

commit affd321733eebc92b12cd329505f63e94ae80c93
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Tue Jul 16 09:54:35 2013 +0200

    ath10k: implement device recovery
    
    Restart the hardware if FW crashes.
    
    If FW crashes during recovery we leave the
    hardware in a "wedged" state to avoid recursive
    recoveries.
    
    When in "wedged" state userspace may bring
    interfaces down (to issue stop()) and then bring
    one interface (to issue start()) to reload
    hardware manually.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath10k/mac.h b/drivers/net/wireless/ath/ath10k/mac.h
index 27fc92e58829..6fce9bfb19a5 100644
--- a/drivers/net/wireless/ath/ath10k/mac.h
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -34,6 +34,7 @@ struct ath10k_vif *ath10k_get_arvif(struct ath10k *ar, u32 vdev_id);
 void ath10k_reset_scan(unsigned long ptr);
 void ath10k_offchan_tx_purge(struct ath10k *ar);
 void ath10k_offchan_tx_work(struct work_struct *work);
+void ath10k_halt(struct ath10k *ar);
 
 static inline struct ath10k_vif *ath10k_vif_to_arvif(struct ieee80211_vif *vif)
 {

commit 5e3dd157d7e70f0e3cea3f2573ed69fb156a19d5
Author: Kalle Valo <kvalo@qca.qualcomm.com>
Date:   Wed Jun 12 20:52:10 2013 +0300

    ath10k: mac80211 driver for Qualcomm Atheros 802.11ac CQA98xx devices
    
    Here's a new mac80211 driver for Qualcomm Atheros 802.11ac QCA98xx devices.
    A major difference from ath9k is that there's now a firmware and
    that's why we had to implement a new driver.
    
    The wiki page for the driver is:
    
    http://wireless.kernel.org/en/users/Drivers/ath10k
    
    The driver has had many authors, they are listed here alphabetically:
    
    Bartosz Markowski <bartosz.markowski@tieto.com>
    Janusz Dziedzic <janusz.dziedzic@tieto.com>
    Kalle Valo <kvalo@qca.qualcomm.com>
    Marek Kwaczynski <marek.kwaczynski@tieto.com>
    Marek Puzyniak <marek.puzyniak@tieto.com>
    Michal Kazior <michal.kazior@tieto.com>
    Sujith Manoharan <c_manoha@qca.qualcomm.com>
    
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath10k/mac.h b/drivers/net/wireless/ath/ath10k/mac.h
new file mode 100644
index 000000000000..27fc92e58829
--- /dev/null
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2005-2011 Atheros Communications Inc.
+ * Copyright (c) 2011-2013 Qualcomm Atheros, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _MAC_H_
+#define _MAC_H_
+
+#include <net/mac80211.h>
+#include "core.h"
+
+struct ath10k_generic_iter {
+	struct ath10k *ar;
+	int ret;
+};
+
+struct ath10k *ath10k_mac_create(void);
+void ath10k_mac_destroy(struct ath10k *ar);
+int ath10k_mac_register(struct ath10k *ar);
+void ath10k_mac_unregister(struct ath10k *ar);
+struct ath10k_vif *ath10k_get_arvif(struct ath10k *ar, u32 vdev_id);
+void ath10k_reset_scan(unsigned long ptr);
+void ath10k_offchan_tx_purge(struct ath10k *ar);
+void ath10k_offchan_tx_work(struct work_struct *work);
+
+static inline struct ath10k_vif *ath10k_vif_to_arvif(struct ieee80211_vif *vif)
+{
+	return (struct ath10k_vif *)vif->drv_priv;
+}
+
+static inline void ath10k_tx_h_seq_no(struct sk_buff *skb)
+{
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+	struct ieee80211_vif *vif = info->control.vif;
+	struct ath10k_vif *arvif = ath10k_vif_to_arvif(vif);
+
+	if (info->flags  & IEEE80211_TX_CTL_ASSIGN_SEQ) {
+		if (arvif->tx_seq_no == 0)
+			arvif->tx_seq_no = 0x1000;
+
+		if (info->flags & IEEE80211_TX_CTL_FIRST_FRAGMENT)
+			arvif->tx_seq_no += 0x10;
+		hdr->seq_ctrl &= cpu_to_le16(IEEE80211_SCTL_FRAG);
+		hdr->seq_ctrl |= cpu_to_le16(arvif->tx_seq_no);
+	}
+}
+
+#endif /* _MAC_H_ */
