commit 2dc016599cfa9672a147528ca26d70c3654a5423
Author: Wen Gong <wgong@codeaurora.org>
Date:   Fri Nov 29 07:34:09 2019 +0000

    ath: add support for special 0x0 regulatory domain
    
    Some sdio chips of rome QCA6174's regulatory domain code of EEPROM is
    empty, then ath_is_world_regd will return false for this case, and
    it will lead function __ath_reg_dyn_country not work, thus the regdomain
    will not update for NL80211_REGDOM_SET_BY_COUNTRY_IE type, it result
    ath10k set the same regdomain/reg_5ghz_ctl/reg_2ghz_ctl to firmware,
    then the tx power will not changed with different regdomain's AP. The
    regulatory domain code of EEPROM of some QCA6174 PCIE chip is 0x6c, it
    means world wide regdomain, for this chip, it does not have the issue.
    
    For empty reulatory domain code chip, set it to world regulatory domain
    in functio ath_regd_sanitize, then it will fix the issue.
    
    Tested with QCA6174 SDIO with firmware
    WLAN.RMH.4.4.1-00029.
    
    Signed-off-by: Wen Gong <wgong@codeaurora.org>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 20f4f8ea9f89..bee9110b91f3 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -666,14 +666,14 @@ ath_regd_init_wiphy(struct ath_regulatory *reg,
 
 /*
  * Some users have reported their EEPROM programmed with
- * 0x8000 set, this is not a supported regulatory domain
- * but since we have more than one user with it we need
- * a solution for them. We default to 0x64, which is the
- * default Atheros world regulatory domain.
+ * 0x8000 or 0x0 set, this is not a supported regulatory
+ * domain but since we have more than one user with it we
+ * need a solution for them. We default to 0x64, which is
+ * the default Atheros world regulatory domain.
  */
 static void ath_regd_sanitize(struct ath_regulatory *reg)
 {
-	if (reg->current_rd != COUNTRY_ERD_FLAG)
+	if (reg->current_rd != COUNTRY_ERD_FLAG && reg->current_rd != 0)
 		return;
 	printk(KERN_DEBUG "ath: EEPROM regdomain sanitized\n");
 	reg->current_rd = 0x64;

commit f433abfc2f76b7ebf9a7211351bd2ee021daed17
Author: Tomislav Požega <pozega.tomislav@gmail.com>
Date:   Thu Oct 10 22:53:15 2019 +0200

    ath: rename regulatory rules
    
    Regulatory rule defines in regd.c are used not only by ath9k but also
    ath10k driver (haven't test other drivers) and thus should be
    renamed from ATH9K* to ATH*.
    
    Signed-off-by: Tomislav Požega <pozega.tomislav@gmail.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index e25bfdf78c2e..20f4f8ea9f89 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -33,33 +33,33 @@ static int __ath_regd_init(struct ath_regulatory *reg);
  */
 
 /* Only these channels all allow active scan on all world regulatory domains */
-#define ATH9K_2GHZ_CH01_11	REG_RULE(2412-10, 2462+10, 40, 0, 20, 0)
+#define ATH_2GHZ_CH01_11	REG_RULE(2412-10, 2462+10, 40, 0, 20, 0)
 
 /* We enable active scan on these a case by case basis by regulatory domain */
-#define ATH9K_2GHZ_CH12_13	REG_RULE(2467-10, 2472+10, 40, 0, 20,\
+#define ATH_2GHZ_CH12_13	REG_RULE(2467-10, 2472+10, 40, 0, 20,\
 					 NL80211_RRF_NO_IR)
-#define ATH9K_2GHZ_CH14		REG_RULE(2484-10, 2484+10, 40, 0, 20,\
+#define ATH_2GHZ_CH14		REG_RULE(2484-10, 2484+10, 40, 0, 20,\
 					 NL80211_RRF_NO_IR | \
 					 NL80211_RRF_NO_OFDM)
 
 /* We allow IBSS on these on a case by case basis by regulatory domain */
-#define ATH9K_5GHZ_5150_5350	REG_RULE(5150-10, 5350+10, 80, 0, 30,\
+#define ATH_5GHZ_5150_5350	REG_RULE(5150-10, 5350+10, 80, 0, 30,\
 					 NL80211_RRF_NO_IR)
-#define ATH9K_5GHZ_5470_5850	REG_RULE(5470-10, 5850+10, 80, 0, 30,\
+#define ATH_5GHZ_5470_5850	REG_RULE(5470-10, 5850+10, 80, 0, 30,\
 					 NL80211_RRF_NO_IR)
-#define ATH9K_5GHZ_5725_5850	REG_RULE(5725-10, 5850+10, 80, 0, 30,\
+#define ATH_5GHZ_5725_5850	REG_RULE(5725-10, 5850+10, 80, 0, 30,\
 					 NL80211_RRF_NO_IR)
 
-#define ATH9K_2GHZ_ALL		ATH9K_2GHZ_CH01_11, \
-				ATH9K_2GHZ_CH12_13, \
-				ATH9K_2GHZ_CH14
+#define ATH_2GHZ_ALL		ATH_2GHZ_CH01_11, \
+				ATH_2GHZ_CH12_13, \
+				ATH_2GHZ_CH14
 
-#define ATH9K_5GHZ_ALL		ATH9K_5GHZ_5150_5350, \
-				ATH9K_5GHZ_5470_5850
+#define ATH_5GHZ_ALL		ATH_5GHZ_5150_5350, \
+				ATH_5GHZ_5470_5850
 
 /* This one skips what we call "mid band" */
-#define ATH9K_5GHZ_NO_MIDBAND	ATH9K_5GHZ_5150_5350, \
-				ATH9K_5GHZ_5725_5850
+#define ATH_5GHZ_NO_MIDBAND	ATH_5GHZ_5150_5350, \
+				ATH_5GHZ_5725_5850
 
 /* Can be used for:
  * 0x60, 0x61, 0x62 */
@@ -67,8 +67,8 @@ static const struct ieee80211_regdomain ath_world_regdom_60_61_62 = {
 	.n_reg_rules = 5,
 	.alpha2 =  "99",
 	.reg_rules = {
-		ATH9K_2GHZ_ALL,
-		ATH9K_5GHZ_ALL,
+		ATH_2GHZ_ALL,
+		ATH_5GHZ_ALL,
 	}
 };
 
@@ -77,9 +77,9 @@ static const struct ieee80211_regdomain ath_world_regdom_63_65 = {
 	.n_reg_rules = 4,
 	.alpha2 =  "99",
 	.reg_rules = {
-		ATH9K_2GHZ_CH01_11,
-		ATH9K_2GHZ_CH12_13,
-		ATH9K_5GHZ_NO_MIDBAND,
+		ATH_2GHZ_CH01_11,
+		ATH_2GHZ_CH12_13,
+		ATH_5GHZ_NO_MIDBAND,
 	}
 };
 
@@ -88,8 +88,8 @@ static const struct ieee80211_regdomain ath_world_regdom_64 = {
 	.n_reg_rules = 3,
 	.alpha2 =  "99",
 	.reg_rules = {
-		ATH9K_2GHZ_CH01_11,
-		ATH9K_5GHZ_NO_MIDBAND,
+		ATH_2GHZ_CH01_11,
+		ATH_5GHZ_NO_MIDBAND,
 	}
 };
 
@@ -98,8 +98,8 @@ static const struct ieee80211_regdomain ath_world_regdom_66_69 = {
 	.n_reg_rules = 3,
 	.alpha2 =  "99",
 	.reg_rules = {
-		ATH9K_2GHZ_CH01_11,
-		ATH9K_5GHZ_ALL,
+		ATH_2GHZ_CH01_11,
+		ATH_5GHZ_ALL,
 	}
 };
 
@@ -108,9 +108,9 @@ static const struct ieee80211_regdomain ath_world_regdom_67_68_6A_6C = {
 	.n_reg_rules = 4,
 	.alpha2 =  "99",
 	.reg_rules = {
-		ATH9K_2GHZ_CH01_11,
-		ATH9K_2GHZ_CH12_13,
-		ATH9K_5GHZ_ALL,
+		ATH_2GHZ_CH01_11,
+		ATH_2GHZ_CH12_13,
+		ATH_5GHZ_ALL,
 	}
 };
 

commit c0c345d4cacc6a1f39d4856f37dcf6e34f51a5e4
Author: Mohammed Shafi Shajakhan <mohammed@qti.qualcomm.com>
Date:   Wed Apr 12 23:19:37 2017 +0530

    ath: Fix updating radar flags for coutry code India
    
    As per latest regulatory update for India, channel 52, 56, 60, 64
    is no longer restricted to DFS. Enabling DFS/no infra flags in driver
    results in applying all DFS related restrictions (like doing CAC etc
    before this channel moves to 'available state') for these channels
    even though the country code is programmed as 'India' in he hardware,
    fix this by relaxing the frequency range while applying RADAR flags
    only if the country code is programmed to India. If the frequency range
    needs to modified based on different country code, ath_is_radar_freq
    can be extended/modified dynamically.
    
    Signed-off-by: Mohammed Shafi Shajakhan <mohammed@qti.qualcomm.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 43afa83a9f0c..e25bfdf78c2e 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -254,8 +254,12 @@ bool ath_is_49ghz_allowed(u16 regdomain)
 EXPORT_SYMBOL(ath_is_49ghz_allowed);
 
 /* Frequency is one where radar detection is required */
-static bool ath_is_radar_freq(u16 center_freq)
+static bool ath_is_radar_freq(u16 center_freq,
+			      struct ath_regulatory *reg)
+
 {
+	if (reg->country_code == CTRY_INDIA)
+		return (center_freq >= 5500 && center_freq <= 5700);
 	return (center_freq >= 5260 && center_freq <= 5700);
 }
 
@@ -306,7 +310,7 @@ __ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
 				enum nl80211_reg_initiator initiator,
 				struct ieee80211_channel *ch)
 {
-	if (ath_is_radar_freq(ch->center_freq) ||
+	if (ath_is_radar_freq(ch->center_freq, reg) ||
 	    (ch->flags & IEEE80211_CHAN_RADAR))
 		return;
 
@@ -395,8 +399,9 @@ ath_reg_apply_ir_flags(struct wiphy *wiphy,
 	}
 }
 
-/* Always apply Radar/DFS rules on freq range 5260 MHz - 5700 MHz */
-static void ath_reg_apply_radar_flags(struct wiphy *wiphy)
+/* Always apply Radar/DFS rules on freq range 5500 MHz - 5700 MHz */
+static void ath_reg_apply_radar_flags(struct wiphy *wiphy,
+				      struct ath_regulatory *reg)
 {
 	struct ieee80211_supported_band *sband;
 	struct ieee80211_channel *ch;
@@ -409,7 +414,7 @@ static void ath_reg_apply_radar_flags(struct wiphy *wiphy)
 
 	for (i = 0; i < sband->n_channels; i++) {
 		ch = &sband->channels[i];
-		if (!ath_is_radar_freq(ch->center_freq))
+		if (!ath_is_radar_freq(ch->center_freq, reg))
 			continue;
 		/* We always enable radar detection/DFS on this
 		 * frequency range. Additionally we also apply on
@@ -506,7 +511,7 @@ void ath_reg_notifier_apply(struct wiphy *wiphy,
 	struct ath_common *common = container_of(reg, struct ath_common,
 						 regulatory);
 	/* We always apply this */
-	ath_reg_apply_radar_flags(wiphy);
+	ath_reg_apply_radar_flags(wiphy, reg);
 
 	/*
 	 * This would happen when we have sent a custom regulatory request
@@ -654,7 +659,7 @@ ath_regd_init_wiphy(struct ath_regulatory *reg,
 	}
 
 	wiphy_apply_custom_regulatory(wiphy, regd);
-	ath_reg_apply_radar_flags(wiphy);
+	ath_reg_apply_radar_flags(wiphy, reg);
 	ath_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER, reg);
 	return 0;
 }

commit d291d8e0592ad5effaaa1af7de95dc9bfecc4f9e
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Wed Sep 28 15:11:57 2016 +0300

    ath: export alpha2 helper
    
    This will be helpful for drivers that can acquire
    alpha2 regulatory codes.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Bartosz Markowski <bartosz.markowski@tieto.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index f8506037736f..43afa83a9f0c 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -449,7 +449,7 @@ static void ath_reg_apply_world_flags(struct wiphy *wiphy,
 	}
 }
 
-static u16 ath_regd_find_country_by_name(char *alpha2)
+u16 ath_regd_find_country_by_name(char *alpha2)
 {
 	unsigned int i;
 
@@ -460,6 +460,7 @@ static u16 ath_regd_find_country_by_name(char *alpha2)
 
 	return -1;
 }
+EXPORT_SYMBOL(ath_regd_find_country_by_name);
 
 static int __ath_reg_dyn_country(struct wiphy *wiphy,
 				 struct ath_regulatory *reg,

commit 97f2645f358b411ba2afb22e5966753f0ad92916
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed Aug 3 13:45:50 2016 -0700

    tree-wide: replace config_enabled() with IS_ENABLED()
    
    The use of config_enabled() against config options is ambiguous.  In
    practical terms, config_enabled() is equivalent to IS_BUILTIN(), but the
    author might have used it for the meaning of IS_ENABLED().  Using
    IS_ENABLED(), IS_BUILTIN(), IS_MODULE() etc.  makes the intention
    clearer.
    
    This commit replaces config_enabled() with IS_ENABLED() where possible.
    This commit is only touching bool config options.
    
    I noticed two cases where config_enabled() is used against a tristate
    option:
    
     - config_enabled(CONFIG_HWMON)
      [ drivers/net/wireless/ath/ath10k/thermal.c ]
    
     - config_enabled(CONFIG_BACKLIGHT_CLASS_DEVICE)
      [ drivers/gpu/drm/gma500/opregion.c ]
    
    I did not touch them because they should be converted to IS_BUILTIN()
    in order to keep the logic, but I was not sure it was the authors'
    intention.
    
    Link: http://lkml.kernel.org/r/1465215656-20569-1-git-send-email-yamada.masahiro@socionext.com
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Cc: Stas Sergeev <stsp@list.ru>
    Cc: Matt Redfearn <matt.redfearn@imgtec.com>
    Cc: Joshua Kinard <kumba@gentoo.org>
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Markos Chandras <markos.chandras@imgtec.com>
    Cc: "Dmitry V. Levin" <ldv@altlinux.org>
    Cc: yu-cheng yu <yu-cheng.yu@intel.com>
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Johannes Berg <johannes@sipsolutions.net>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Will Drewry <wad@chromium.org>
    Cc: Nikolay Martynov <mar.kolya@gmail.com>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Cc: Rafal Milecki <zajec5@gmail.com>
    Cc: James Cowgill <James.Cowgill@imgtec.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Alex Smith <alex.smith@imgtec.com>
    Cc: Adam Buchbinder <adam.buchbinder@gmail.com>
    Cc: Qais Yousef <qais.yousef@imgtec.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Mikko Rapeli <mikko.rapeli@iki.fi>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: Brian Norris <computersforpeace@gmail.com>
    Cc: Hidehiro Kawai <hidehiro.kawai.ez@hitachi.com>
    Cc: "Luis R. Rodriguez" <mcgrof@do-not-panic.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
    Cc: Roland McGrath <roland@hack.frob.com>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: Kalle Valo <kvalo@qca.qualcomm.com>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Tony Wu <tung7970@gmail.com>
    Cc: Huaitong Han <huaitong.han@intel.com>
    Cc: Sumit Semwal <sumit.semwal@linaro.org>
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Andrea Gelmini <andrea.gelmini@gelma.net>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Rabin Vincent <rabin@rab.in>
    Cc: "Maciej W. Rozycki" <macro@imgtec.com>
    Cc: David Daney <david.daney@cavium.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 7e15ed9ed31f..f8506037736f 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -116,7 +116,7 @@ static const struct ieee80211_regdomain ath_world_regdom_67_68_6A_6C = {
 
 static bool dynamic_country_user_possible(struct ath_regulatory *reg)
 {
-	if (config_enabled(CONFIG_ATH_REG_DYNAMIC_USER_CERT_TESTING))
+	if (IS_ENABLED(CONFIG_ATH_REG_DYNAMIC_USER_CERT_TESTING))
 		return true;
 
 	switch (reg->country_code) {
@@ -188,7 +188,7 @@ static bool dynamic_country_user_possible(struct ath_regulatory *reg)
 
 static bool ath_reg_dyn_country_user_allow(struct ath_regulatory *reg)
 {
-	if (!config_enabled(CONFIG_ATH_REG_DYNAMIC_USER_REG_HINTS))
+	if (!IS_ENABLED(CONFIG_ATH_REG_DYNAMIC_USER_REG_HINTS))
 		return false;
 	if (!dynamic_country_user_possible(reg))
 		return false;

commit 57fbcce37be7c1d2622b56587c10ade00e96afa3
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Apr 12 15:56:15 2016 +0200

    cfg80211: remove enum ieee80211_band
    
    This enum is already perfectly aliased to enum nl80211_band, and
    the only reason for it is that we get IEEE80211_NUM_BANDS out of
    it. There's no really good reason to not declare the number of
    bands in nl80211 though, so do that and remove the cfg80211 one.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 06ea6cc9e30a..7e15ed9ed31f 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -336,12 +336,12 @@ ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
 			      struct ath_regulatory *reg,
 			      enum nl80211_reg_initiator initiator)
 {
-	enum ieee80211_band band;
+	enum nl80211_band band;
 	struct ieee80211_supported_band *sband;
 	struct ieee80211_channel *ch;
 	unsigned int i;
 
-	for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
+	for (band = 0; band < NUM_NL80211_BANDS; band++) {
 		if (!wiphy->bands[band])
 			continue;
 		sband = wiphy->bands[band];
@@ -374,7 +374,7 @@ ath_reg_apply_ir_flags(struct wiphy *wiphy,
 {
 	struct ieee80211_supported_band *sband;
 
-	sband = wiphy->bands[IEEE80211_BAND_2GHZ];
+	sband = wiphy->bands[NL80211_BAND_2GHZ];
 	if (!sband)
 		return;
 
@@ -402,10 +402,10 @@ static void ath_reg_apply_radar_flags(struct wiphy *wiphy)
 	struct ieee80211_channel *ch;
 	unsigned int i;
 
-	if (!wiphy->bands[IEEE80211_BAND_5GHZ])
+	if (!wiphy->bands[NL80211_BAND_5GHZ])
 		return;
 
-	sband = wiphy->bands[IEEE80211_BAND_5GHZ];
+	sband = wiphy->bands[NL80211_BAND_5GHZ];
 
 	for (i = 0; i < sband->n_channels; i++) {
 		ch = &sband->channels[i];
@@ -772,7 +772,7 @@ ath_regd_init(struct ath_regulatory *reg,
 EXPORT_SYMBOL(ath_regd_init);
 
 u32 ath_regd_get_band_ctl(struct ath_regulatory *reg,
-			  enum ieee80211_band band)
+			  enum nl80211_band band)
 {
 	if (!reg->regpair ||
 	    (reg->country_code == CTRY_DEFAULT &&
@@ -794,9 +794,9 @@ u32 ath_regd_get_band_ctl(struct ath_regulatory *reg,
 	}
 
 	switch (band) {
-	case IEEE80211_BAND_2GHZ:
+	case NL80211_BAND_2GHZ:
 		return reg->regpair->reg_2ghz_ctl;
-	case IEEE80211_BAND_5GHZ:
+	case NL80211_BAND_5GHZ:
 		return reg->regpair->reg_5ghz_ctl;
 	default:
 		return NO_CTL;

commit 94e05900770c0abe31200881df93e41d296fe8bd
Author: Felix Fietkau <nbd@openwrt.org>
Date:   Wed Oct 22 15:27:53 2014 +0200

    ath: use CTL region from cfg80211 if unset in EEPROM
    
    Many AP devices do not have the proper regulatory domain programmed in
    EEPROM. Instead they expect the software to set the appropriate region.
    For these devices, the country code defaults to US, and the driver uses
    the US CTL tables as well.
    On devices bought in Europe this can lead to tx power being set too high
    on the band edges, even if the cfg80211 regdomain is set correctly.
    Fix this issue by taking into account the DFS region, but only when the
    EEPROM regdomain is set to default.
    
    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 415393dfb6fc..06ea6cc9e30a 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -515,6 +515,7 @@ void ath_reg_notifier_apply(struct wiphy *wiphy,
 	if (!request)
 		return;
 
+	reg->region = request->dfs_region;
 	switch (request->initiator) {
 	case NL80211_REGDOM_SET_BY_CORE:
 		/*
@@ -779,6 +780,19 @@ u32 ath_regd_get_band_ctl(struct ath_regulatory *reg,
 		return SD_NO_CTL;
 	}
 
+	if (ath_regd_get_eepromRD(reg) == CTRY_DEFAULT) {
+		switch (reg->region) {
+		case NL80211_DFS_FCC:
+			return CTL_FCC;
+		case NL80211_DFS_ETSI:
+			return CTL_ETSI;
+		case NL80211_DFS_JP:
+			return CTL_MKK;
+		default:
+			break;
+		}
+	}
+
 	switch (band) {
 	case IEEE80211_BAND_2GHZ:
 		return reg->regpair->reg_2ghz_ctl;

commit ef8c00174a8738ea334197c0164143354644cb16
Author: Kalle Valo <kvalo@qca.qualcomm.com>
Date:   Thu Feb 13 18:13:12 2014 +0200

    ath: remove camel case from struct reg_dmn_pair_mapping
    
    Fixes a checkpatch warning in ath10k:
    
    drivers/net/wireless/ath/ath10k/mac.c:1636: WARNING: Avoid CamelCase: <regpair->regDmnEnum>
    
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index e5e905910db4..415393dfb6fc 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -222,7 +222,7 @@ static const struct ieee80211_regdomain *ath_default_world_regdomain(void)
 static const struct
 ieee80211_regdomain *ath_world_regdomain(struct ath_regulatory *reg)
 {
-	switch (reg->regpair->regDmnEnum) {
+	switch (reg->regpair->reg_domain) {
 	case 0x60:
 	case 0x61:
 	case 0x62:
@@ -431,7 +431,7 @@ static void ath_reg_apply_world_flags(struct wiphy *wiphy,
 				      enum nl80211_reg_initiator initiator,
 				      struct ath_regulatory *reg)
 {
-	switch (reg->regpair->regDmnEnum) {
+	switch (reg->regpair->reg_domain) {
 	case 0x60:
 	case 0x63:
 	case 0x66:
@@ -560,7 +560,7 @@ static bool ath_regd_is_eeprom_valid(struct ath_regulatory *reg)
 			printk(KERN_DEBUG "ath: EEPROM indicates we "
 			       "should expect a direct regpair map\n");
 		for (i = 0; i < ARRAY_SIZE(regDomainPairs); i++)
-			if (regDomainPairs[i].regDmnEnum == rd)
+			if (regDomainPairs[i].reg_domain == rd)
 				return true;
 	}
 	printk(KERN_DEBUG
@@ -617,7 +617,7 @@ ath_get_regpair(int regdmn)
 	if (regdmn == NO_ENUMRD)
 		return NULL;
 	for (i = 0; i < ARRAY_SIZE(regDomainPairs); i++) {
-		if (regDomainPairs[i].regDmnEnum == regdmn)
+		if (regDomainPairs[i].reg_domain == regdmn)
 			return &regDomainPairs[i];
 	}
 	return NULL;
@@ -741,7 +741,7 @@ static int __ath_regd_init(struct ath_regulatory *reg)
 	printk(KERN_DEBUG "ath: Country alpha2 being used: %c%c\n",
 		reg->alpha2[0], reg->alpha2[1]);
 	printk(KERN_DEBUG "ath: Regpair used: 0x%0x\n",
-		reg->regpair->regDmnEnum);
+		reg->regpair->reg_domain);
 
 	return 0;
 }

commit 4f7b91404cd5da3657a82b00394f4f5dfbff13d6
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Sat Dec 14 20:09:06 2013 +0100

    cfg80211: make regulatory_hint() remove REGULATORY_CUSTOM_REG
    
    The REGULATORY_CUSTOM_REG can be used during early init with
    the goal of overriding the wiphy's default regulatory settings
    in case the alpha2 of the device is not known. In the case that
    the alpha2 becomes known lets avoid having drivers having to
    clear the REGULATORY_CUSTOM_REG flag by doing it for them
    when regulatory_hint() is used.
    
    Cc: Sujith Manoharan <c_manoha@qca.qualcomm.com>
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 56c3d05c6224..e5e905910db4 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -652,8 +652,6 @@ ath_regd_init_wiphy(struct ath_regulatory *reg,
 	}
 
 	wiphy_apply_custom_regulatory(wiphy, regd);
-	if (!ath_is_world_regd(reg))
-		wiphy->regulatory_flags &= ~REGULATORY_CUSTOM_REG;
 	ath_reg_apply_radar_flags(wiphy);
 	ath_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER, reg);
 	return 0;

commit 8fc685803a8d7b42a5f69dcad7f7cef6f8b60edf
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Sat Dec 14 20:09:05 2013 +0100

    ath: fix warning on usage of REGULATORY_CUSTOM_REG
    
    ath wants to first apply the custom regd and only later
    will it revert to not using it if an alpha2 regulatory
    domain is found. Since the wireless core now enforces
    usage of the REGULATORY_CUSTOM_REG strictly when
    wiphy_apply_custom_regulatory() is used this makes
    ath adhere to the expected behaviour but also updates
    the wiphy after its done with the custom usage.
    
    This fixes this warning:
    
    [    5.488733] ath: phy0: ASPM enabled: 0x43
    [    5.488735] ath: EEPROM regdomain: 0x0
    [    5.488736] ath: EEPROM indicates default country code should be used
    [    5.488736] ath: doing EEPROM country->regdmn map search
    [    5.488737] ath: country maps to regdmn code: 0x3a
    [    5.488737] ath: Country alpha2 being used: US
    [    5.488738] ath: Regpair used: 0x3a
    [    5.488738] ------------[ cut here ]------------
    [    5.488745] WARNING: CPU: 0 PID: 161 at
            /home/sujith/dev/wireless-testing/net/wireless/reg.c:1361
            wiphy_apply_custom_regulatory+0x17a/0x1b0 [cfg80211]()
    [    5.488746] wiphy should have REGULATORY_CUSTOM_REG
    
    The wireless core can *later* lift this flag for us for when
    using the regulatory_hint() to make this fix more generic.
    
    Reported-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 9e154732afaa..56c3d05c6224 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -632,7 +632,8 @@ ath_regd_init_wiphy(struct ath_regulatory *reg,
 	const struct ieee80211_regdomain *regd;
 
 	wiphy->reg_notifier = reg_notifier;
-	wiphy->regulatory_flags |= REGULATORY_STRICT_REG;
+	wiphy->regulatory_flags |= REGULATORY_STRICT_REG |
+				   REGULATORY_CUSTOM_REG;
 
 	if (ath_is_world_regd(reg)) {
 		/*
@@ -640,8 +641,7 @@ ath_regd_init_wiphy(struct ath_regulatory *reg,
 		 * saved on the wiphy orig_* parameters
 		 */
 		regd = ath_world_regdomain(reg);
-		wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG |
-					   REGULATORY_COUNTRY_IE_FOLLOW_POWER;
+		wiphy->regulatory_flags |= REGULATORY_COUNTRY_IE_FOLLOW_POWER;
 	} else {
 		/*
 		 * This gets applied in the case of the absence of CRDA,
@@ -650,7 +650,10 @@ ath_regd_init_wiphy(struct ath_regulatory *reg,
 		 */
 		regd = ath_default_world_regdomain();
 	}
+
 	wiphy_apply_custom_regulatory(wiphy, regd);
+	if (!ath_is_world_regd(reg))
+		wiphy->regulatory_flags &= ~REGULATORY_CUSTOM_REG;
 	ath_reg_apply_radar_flags(wiphy);
 	ath_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER, reg);
 	return 0;

commit 251c9ba19143caa5eb5b6ec52c77c70c9d7b3d8f
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Wed Oct 30 00:10:07 2013 +0100

    ath: fix dynamic user regulatory domain support
    
    As it stands dynamic user regulatory domain support is
    only possible for a few programmed regulatory domains as
    a few countries do not allow for this.
    
    The existing code however only would take advantage of
    the feature if a custom world regulatory domain is used
    though as that's when we clear beconing flags. We need
    to lift this restriction as otherwise this feature is
    pointless.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 4a6c232c6c9b..9e154732afaa 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -302,6 +302,7 @@ static void ath_force_no_ir_freq(struct wiphy *wiphy, u16 center_freq)
 
 static void
 __ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
+				struct ath_regulatory *reg,
 				enum nl80211_reg_initiator initiator,
 				struct ieee80211_channel *ch)
 {
@@ -313,6 +314,10 @@ __ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
 	case NL80211_REGDOM_SET_BY_COUNTRY_IE:
 		ath_force_clear_no_ir_chan(wiphy, ch);
 		break;
+	case NL80211_REGDOM_SET_BY_USER:
+		if (ath_reg_dyn_country_user_allow(reg))
+			ath_force_clear_no_ir_chan(wiphy, ch);
+		break;
 	default:
 		if (ch->beacon_found)
 			ch->flags &= ~IEEE80211_CHAN_NO_IR;
@@ -328,6 +333,7 @@ __ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
  */
 static void
 ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
+			      struct ath_regulatory *reg,
 			      enum nl80211_reg_initiator initiator)
 {
 	enum ieee80211_band band;
@@ -341,8 +347,8 @@ ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
 		sband = wiphy->bands[band];
 		for (i = 0; i < sband->n_channels; i++) {
 			ch = &sband->channels[i];
-			__ath_reg_apply_beaconing_flags(wiphy, initiator, ch);
-
+			__ath_reg_apply_beaconing_flags(wiphy, reg,
+							initiator, ch);
 		}
 	}
 }
@@ -363,7 +369,8 @@ ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
  */
 static void
 ath_reg_apply_ir_flags(struct wiphy *wiphy,
-				enum nl80211_reg_initiator initiator)
+		       struct ath_regulatory *reg,
+		       enum nl80211_reg_initiator initiator)
 {
 	struct ieee80211_supported_band *sband;
 
@@ -376,6 +383,12 @@ ath_reg_apply_ir_flags(struct wiphy *wiphy,
 		ath_force_clear_no_ir_freq(wiphy, 2467);
 		ath_force_clear_no_ir_freq(wiphy, 2472);
 		break;
+	case NL80211_REGDOM_SET_BY_USER:
+		if (!ath_reg_dyn_country_user_allow(reg))
+			break;
+		ath_force_clear_no_ir_freq(wiphy, 2467);
+		ath_force_clear_no_ir_freq(wiphy, 2472);
+		break;
 	default:
 		ath_force_no_ir_freq(wiphy, 2467);
 		ath_force_no_ir_freq(wiphy, 2472);
@@ -424,12 +437,15 @@ static void ath_reg_apply_world_flags(struct wiphy *wiphy,
 	case 0x66:
 	case 0x67:
 	case 0x6C:
-		ath_reg_apply_beaconing_flags(wiphy, initiator);
+		ath_reg_apply_beaconing_flags(wiphy, reg, initiator);
 		break;
 	case 0x68:
-		ath_reg_apply_beaconing_flags(wiphy, initiator);
-		ath_reg_apply_ir_flags(wiphy, initiator);
+		ath_reg_apply_beaconing_flags(wiphy, reg, initiator);
+		ath_reg_apply_ir_flags(wiphy, reg, initiator);
 		break;
+	default:
+		if (ath_reg_dyn_country_user_allow(reg))
+			ath_reg_apply_beaconing_flags(wiphy, reg, initiator);
 	}
 }
 

commit ba94c049e555d1701d547025f7d547a582833d03
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Tue Oct 29 23:39:05 2013 +0100

    ath: dynamic user allow check helper to the top
    
    This will be used later.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index e7d01723ea09..4a6c232c6c9b 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -186,6 +186,15 @@ static bool dynamic_country_user_possible(struct ath_regulatory *reg)
 	return true;
 }
 
+static bool ath_reg_dyn_country_user_allow(struct ath_regulatory *reg)
+{
+	if (!config_enabled(CONFIG_ATH_REG_DYNAMIC_USER_REG_HINTS))
+		return false;
+	if (!dynamic_country_user_possible(reg))
+		return false;
+	return true;
+}
+
 static inline bool is_wwr_sku(u16 regd)
 {
 	return ((regd & COUNTRY_ERD_FLAG) != COUNTRY_ERD_FLAG) &&
@@ -473,17 +482,6 @@ static void ath_reg_dyn_country(struct wiphy *wiphy,
 	       reg_initiator_name(request->initiator));
 }
 
-static void ath_reg_dyn_country_user(struct wiphy *wiphy,
-				     struct ath_regulatory *reg,
-				     struct regulatory_request *request)
-{
-	if (!config_enabled(CONFIG_ATH_REG_DYNAMIC_USER_REG_HINTS))
-		return;
-	if (!dynamic_country_user_possible(reg))
-		return;
-	ath_reg_dyn_country(wiphy, reg, request);
-}
-
 void ath_reg_notifier_apply(struct wiphy *wiphy,
 			    struct regulatory_request *request,
 			    struct ath_regulatory *reg)
@@ -516,7 +514,8 @@ void ath_reg_notifier_apply(struct wiphy *wiphy,
 	case NL80211_REGDOM_SET_BY_DRIVER:
 		break;
 	case NL80211_REGDOM_SET_BY_USER:
-		ath_reg_dyn_country_user(wiphy, reg, request);
+		if (ath_reg_dyn_country_user_allow(reg))
+			ath_reg_dyn_country(wiphy, reg, request);
 		break;
 	case NL80211_REGDOM_SET_BY_COUNTRY_IE:
 		ath_reg_dyn_country(wiphy, reg, request);

commit a44ea6ffbbf716cca9c2abaa4a3a3a9a9ce7c75a
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Tue Oct 29 23:39:04 2013 +0100

    ath: move dynamic_country_user_possible() to the top
    
    This will be used later.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 3baafa5b8ce0..e7d01723ea09 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -114,6 +114,78 @@ static const struct ieee80211_regdomain ath_world_regdom_67_68_6A_6C = {
 	}
 };
 
+static bool dynamic_country_user_possible(struct ath_regulatory *reg)
+{
+	if (config_enabled(CONFIG_ATH_REG_DYNAMIC_USER_CERT_TESTING))
+		return true;
+
+	switch (reg->country_code) {
+	case CTRY_UNITED_STATES:
+	case CTRY_JAPAN1:
+	case CTRY_JAPAN2:
+	case CTRY_JAPAN3:
+	case CTRY_JAPAN4:
+	case CTRY_JAPAN5:
+	case CTRY_JAPAN6:
+	case CTRY_JAPAN7:
+	case CTRY_JAPAN8:
+	case CTRY_JAPAN9:
+	case CTRY_JAPAN10:
+	case CTRY_JAPAN11:
+	case CTRY_JAPAN12:
+	case CTRY_JAPAN13:
+	case CTRY_JAPAN14:
+	case CTRY_JAPAN15:
+	case CTRY_JAPAN16:
+	case CTRY_JAPAN17:
+	case CTRY_JAPAN18:
+	case CTRY_JAPAN19:
+	case CTRY_JAPAN20:
+	case CTRY_JAPAN21:
+	case CTRY_JAPAN22:
+	case CTRY_JAPAN23:
+	case CTRY_JAPAN24:
+	case CTRY_JAPAN25:
+	case CTRY_JAPAN26:
+	case CTRY_JAPAN27:
+	case CTRY_JAPAN28:
+	case CTRY_JAPAN29:
+	case CTRY_JAPAN30:
+	case CTRY_JAPAN31:
+	case CTRY_JAPAN32:
+	case CTRY_JAPAN33:
+	case CTRY_JAPAN34:
+	case CTRY_JAPAN35:
+	case CTRY_JAPAN36:
+	case CTRY_JAPAN37:
+	case CTRY_JAPAN38:
+	case CTRY_JAPAN39:
+	case CTRY_JAPAN40:
+	case CTRY_JAPAN41:
+	case CTRY_JAPAN42:
+	case CTRY_JAPAN43:
+	case CTRY_JAPAN44:
+	case CTRY_JAPAN45:
+	case CTRY_JAPAN46:
+	case CTRY_JAPAN47:
+	case CTRY_JAPAN48:
+	case CTRY_JAPAN49:
+	case CTRY_JAPAN50:
+	case CTRY_JAPAN51:
+	case CTRY_JAPAN52:
+	case CTRY_JAPAN53:
+	case CTRY_JAPAN54:
+	case CTRY_JAPAN55:
+	case CTRY_JAPAN56:
+	case CTRY_JAPAN57:
+	case CTRY_JAPAN58:
+	case CTRY_JAPAN59:
+		return false;
+	}
+
+	return true;
+}
+
 static inline bool is_wwr_sku(u16 regd)
 {
 	return ((regd & COUNTRY_ERD_FLAG) != COUNTRY_ERD_FLAG) &&
@@ -401,78 +473,6 @@ static void ath_reg_dyn_country(struct wiphy *wiphy,
 	       reg_initiator_name(request->initiator));
 }
 
-static bool dynamic_country_user_possible(struct ath_regulatory *reg)
-{
-	if (config_enabled(CONFIG_ATH_REG_DYNAMIC_USER_CERT_TESTING))
-		return true;
-
-	switch (reg->country_code) {
-	case CTRY_UNITED_STATES:
-	case CTRY_JAPAN1:
-	case CTRY_JAPAN2:
-	case CTRY_JAPAN3:
-	case CTRY_JAPAN4:
-	case CTRY_JAPAN5:
-	case CTRY_JAPAN6:
-	case CTRY_JAPAN7:
-	case CTRY_JAPAN8:
-	case CTRY_JAPAN9:
-	case CTRY_JAPAN10:
-	case CTRY_JAPAN11:
-	case CTRY_JAPAN12:
-	case CTRY_JAPAN13:
-	case CTRY_JAPAN14:
-	case CTRY_JAPAN15:
-	case CTRY_JAPAN16:
-	case CTRY_JAPAN17:
-	case CTRY_JAPAN18:
-	case CTRY_JAPAN19:
-	case CTRY_JAPAN20:
-	case CTRY_JAPAN21:
-	case CTRY_JAPAN22:
-	case CTRY_JAPAN23:
-	case CTRY_JAPAN24:
-	case CTRY_JAPAN25:
-	case CTRY_JAPAN26:
-	case CTRY_JAPAN27:
-	case CTRY_JAPAN28:
-	case CTRY_JAPAN29:
-	case CTRY_JAPAN30:
-	case CTRY_JAPAN31:
-	case CTRY_JAPAN32:
-	case CTRY_JAPAN33:
-	case CTRY_JAPAN34:
-	case CTRY_JAPAN35:
-	case CTRY_JAPAN36:
-	case CTRY_JAPAN37:
-	case CTRY_JAPAN38:
-	case CTRY_JAPAN39:
-	case CTRY_JAPAN40:
-	case CTRY_JAPAN41:
-	case CTRY_JAPAN42:
-	case CTRY_JAPAN43:
-	case CTRY_JAPAN44:
-	case CTRY_JAPAN45:
-	case CTRY_JAPAN46:
-	case CTRY_JAPAN47:
-	case CTRY_JAPAN48:
-	case CTRY_JAPAN49:
-	case CTRY_JAPAN50:
-	case CTRY_JAPAN51:
-	case CTRY_JAPAN52:
-	case CTRY_JAPAN53:
-	case CTRY_JAPAN54:
-	case CTRY_JAPAN55:
-	case CTRY_JAPAN56:
-	case CTRY_JAPAN57:
-	case CTRY_JAPAN58:
-	case CTRY_JAPAN59:
-		return false;
-	}
-
-	return true;
-}
-
 static void ath_reg_dyn_country_user(struct wiphy *wiphy,
 				     struct ath_regulatory *reg,
 				     struct regulatory_request *request)

commit 62452a99d0b225a0f5d34d34b2aef63d7b44157b
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Tue Oct 29 19:34:24 2013 +0100

    ath: fix usage of freq_reg_info()
    
    freq_reg_info() expects KHz and not MHz, fix this. In
    this case we'll now be getting the no-ir flags cleared
    on channels for any channel when the country IE trusts
    that channel.
    
    @@
    struct ieee80211_channel *ch;
    struct wiphy *wiphy;
    const struct ieee80211_reg_rule *rule;
    @@
    
    -rule = freq_reg_info(wiphy, ch->center_freq);
    +rule = freq_reg_info(wiphy, MHZ_TO_KHZ(ch->center_freq));
    
    Generated-by: Coccinelle SmPL
    Cc: Julia Lawall <julia.lawall@lip6.fr>
    Cc: Peter Senna Tschudin <peter.senna@gmail.com>
    Reported-by: Mihir Shete <smihir@qti.qualcomm.com>
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index b02b43e690d9..3baafa5b8ce0 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -183,7 +183,7 @@ static void ath_force_clear_no_ir_chan(struct wiphy *wiphy,
 {
 	const struct ieee80211_reg_rule *reg_rule;
 
-	reg_rule = freq_reg_info(wiphy, ch->center_freq);
+	reg_rule = freq_reg_info(wiphy, MHZ_TO_KHZ(ch->center_freq));
 	if (IS_ERR(reg_rule))
 		return;
 

commit 07782d94d90b9ab94a97b1a1841575251484e5bb
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Mon Oct 21 19:14:51 2013 +0200

    ath: move the channel for ath_reg_apply_beaconing_flags() into helper
    
    While at it convert this into a switch statement, this
    makes it easier and manage.
    
    Cc: smihir@qti.qualcomm.com
    Cc: tushnimb@qca.qualcomm.com
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 817340acfb53..b02b43e690d9 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -219,6 +219,25 @@ static void ath_force_no_ir_freq(struct wiphy *wiphy, u16 center_freq)
 	ath_force_no_ir_chan(ch);
 }
 
+static void
+__ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
+				enum nl80211_reg_initiator initiator,
+				struct ieee80211_channel *ch)
+{
+	if (ath_is_radar_freq(ch->center_freq) ||
+	    (ch->flags & IEEE80211_CHAN_RADAR))
+		return;
+
+	switch (initiator) {
+	case NL80211_REGDOM_SET_BY_COUNTRY_IE:
+		ath_force_clear_no_ir_chan(wiphy, ch);
+		break;
+	default:
+		if (ch->beacon_found)
+			ch->flags &= ~IEEE80211_CHAN_NO_IR;
+	}
+}
+
 /*
  * These exception rules do not apply radar frequencies.
  *
@@ -236,33 +255,15 @@ ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
 	unsigned int i;
 
 	for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
-
 		if (!wiphy->bands[band])
 			continue;
-
 		sband = wiphy->bands[band];
-
 		for (i = 0; i < sband->n_channels; i++) {
-
 			ch = &sband->channels[i];
+			__ath_reg_apply_beaconing_flags(wiphy, initiator, ch);
 
-			if (ath_is_radar_freq(ch->center_freq) ||
-			    (ch->flags & IEEE80211_CHAN_RADAR))
-				continue;
-
-			/*
-			 * If the country IE says initiating radiation
-			 * is OK we trust that.
-			 */
-			if (initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE)
-				ath_force_clear_no_ir_chan(wiphy, ch);
-			else {
-				if (ch->beacon_found)
-					ch->flags &= ~IEEE80211_CHAN_NO_IR;
-			}
 		}
 	}
-
 }
 
 /**

commit 6c3af5888eb1df139c81bf74024f5d63ab336b04
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Mon Oct 21 19:14:50 2013 +0200

    ath: simplify ath_reg_apply_beaconing_flags()
    
    Simplify ath_reg_apply_beaconing_flags() by making use of
    thew new no-ir helper.
    
    Cc: smihir@qti.qualcomm.com
    Cc: tushnimb@qca.qualcomm.com
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index a5cbaca41b7b..817340acfb53 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -220,13 +220,11 @@ static void ath_force_no_ir_freq(struct wiphy *wiphy, u16 center_freq)
 }
 
 /*
- * N.B: These exception rules do not apply radar freqs.
+ * These exception rules do not apply radar frequencies.
  *
- * - We enable adhoc (or beaconing) if allowed by 11d
- * - We enable active scan if the channel is allowed by 11d
+ * - We enable initiating radiation if the country IE says its fine:
  * - If no country IE has been processed and a we determine we have
- *   received a beacon on a channel we can enable active scan and
- *   adhoc (or beaconing).
+ *   received a beacon on a channel we can enable initiating radiation.
  */
 static void
 ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
@@ -234,7 +232,6 @@ ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
 {
 	enum ieee80211_band band;
 	struct ieee80211_supported_band *sband;
-	const struct ieee80211_reg_rule *reg_rule;
 	struct ieee80211_channel *ch;
 	unsigned int i;
 
@@ -253,21 +250,13 @@ ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
 			    (ch->flags & IEEE80211_CHAN_RADAR))
 				continue;
 
-			if (initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE) {
-				reg_rule = freq_reg_info(wiphy, ch->center_freq);
-				if (IS_ERR(reg_rule))
-					continue;
-				/*
-				 * If 11d had a rule for this channel ensure
-				 * we enable adhoc/beaconing if it allows us to
-				 * use it. Note that we would have disabled it
-				 * by applying our static world regdomain by
-				 * default during init, prior to calling our
-				 * regulatory_hint().
-				 */
-				if (!(reg_rule->flags & NL80211_RRF_NO_IR))
-					ch->flags &= ~IEEE80211_CHAN_NO_IR;
-			} else {
+			/*
+			 * If the country IE says initiating radiation
+			 * is OK we trust that.
+			 */
+			if (initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE)
+				ath_force_clear_no_ir_chan(wiphy, ch);
+			else {
 				if (ch->beacon_found)
 					ch->flags &= ~IEEE80211_CHAN_NO_IR;
 			}

commit f33cbc4f4350003a0cfb12be07750f3a95965867
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Mon Oct 21 19:14:49 2013 +0200

    ath: rename ath_reg_apply_active_scan_flags() to ath_reg_apply_ir_flags()
    
    This also applies the no-ibss flag to the channels or clears it.
    The idea here is to clarify no initiated radiation should be
    allowed on these channels.
    
    Cc: smihir@qti.qualcomm.com
    Cc: tushnimb@qca.qualcomm.com
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index f4bb9295b6c6..a5cbaca41b7b 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -277,7 +277,7 @@ ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
 }
 
 /**
- * ath_reg_apply_active_scan_flags()
+ * ath_reg_apply_ir_flags()
  * @wiphy: the wiphy to use
  * @initiator: the regulatory hint initiator
  *
@@ -291,7 +291,7 @@ ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
  * custom regulatory domain.
  */
 static void
-ath_reg_apply_active_scan_flags(struct wiphy *wiphy,
+ath_reg_apply_ir_flags(struct wiphy *wiphy,
 				enum nl80211_reg_initiator initiator)
 {
 	struct ieee80211_supported_band *sband;
@@ -357,7 +357,7 @@ static void ath_reg_apply_world_flags(struct wiphy *wiphy,
 		break;
 	case 0x68:
 		ath_reg_apply_beaconing_flags(wiphy, initiator);
-		ath_reg_apply_active_scan_flags(wiphy, initiator);
+		ath_reg_apply_ir_flags(wiphy, initiator);
 		break;
 	}
 }

commit bc0aa0691806dc30cf1a69fe50ae90cf8f752977
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Mon Oct 21 19:14:48 2013 +0200

    ath: clean up ath_reg_apply_active_scan_flags()
    
    The routine ath_reg_apply_active_scan_flags() can be a bit
    hard to read, this cleans it up by adding helpers for the
    two cases of clearing IR flags or adding them. This approach
    also makes no assumptions on the index of channels 12 and 13
    so it should be portable accross different drivers.
    
    Cc: smihir@qti.qualcomm.com
    Cc: tushnimb@qca.qualcomm.com
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 3d596e25ba82..f4bb9295b6c6 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -178,6 +178,47 @@ static bool ath_is_radar_freq(u16 center_freq)
 	return (center_freq >= 5260 && center_freq <= 5700);
 }
 
+static void ath_force_clear_no_ir_chan(struct wiphy *wiphy,
+				       struct ieee80211_channel *ch)
+{
+	const struct ieee80211_reg_rule *reg_rule;
+
+	reg_rule = freq_reg_info(wiphy, ch->center_freq);
+	if (IS_ERR(reg_rule))
+		return;
+
+	if (!(reg_rule->flags & NL80211_RRF_NO_IR))
+		if (ch->flags & IEEE80211_CHAN_NO_IR)
+			ch->flags &= ~IEEE80211_CHAN_NO_IR;
+}
+
+static void ath_force_clear_no_ir_freq(struct wiphy *wiphy, u16 center_freq)
+{
+	struct ieee80211_channel *ch;
+
+	ch = ieee80211_get_channel(wiphy, center_freq);
+	if (!ch)
+		return;
+
+	ath_force_clear_no_ir_chan(wiphy, ch);
+}
+
+static void ath_force_no_ir_chan(struct ieee80211_channel *ch)
+{
+	ch->flags |= IEEE80211_CHAN_NO_IR;
+}
+
+static void ath_force_no_ir_freq(struct wiphy *wiphy, u16 center_freq)
+{
+	struct ieee80211_channel *ch;
+
+	ch = ieee80211_get_channel(wiphy, center_freq);
+	if (!ch)
+		return;
+
+	ath_force_no_ir_chan(ch);
+}
+
 /*
  * N.B: These exception rules do not apply radar freqs.
  *
@@ -235,54 +276,38 @@ ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
 
 }
 
-/* Allows active scan scan on Ch 12 and 13 */
+/**
+ * ath_reg_apply_active_scan_flags()
+ * @wiphy: the wiphy to use
+ * @initiator: the regulatory hint initiator
+ *
+ * If no country IE has been received always enable passive scan
+ * and no-ibss on these channels. This is only done for specific
+ * regulatory SKUs.
+ *
+ * If a country IE has been received check its rule for this
+ * channel first before enabling active scan. The passive scan
+ * would have been enforced by the initial processing of our
+ * custom regulatory domain.
+ */
 static void
 ath_reg_apply_active_scan_flags(struct wiphy *wiphy,
 				enum nl80211_reg_initiator initiator)
 {
 	struct ieee80211_supported_band *sband;
-	struct ieee80211_channel *ch;
-	const struct ieee80211_reg_rule *reg_rule;
 
 	sband = wiphy->bands[IEEE80211_BAND_2GHZ];
 	if (!sband)
 		return;
 
-	/*
-	 * If no country IE has been received always enable passive scan
-	 * and no-ibss on these channels. This is only done for specific
-	 * regulatory SKUs.
-	 */
-	if (initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE) {
-		ch = &sband->channels[11]; /* CH 12 */
-		ch->flags |= IEEE80211_CHAN_NO_IR;
-
-		ch = &sband->channels[12]; /* CH 13 */
-		ch->flags |= IEEE80211_CHAN_NO_IR;
-		return;
-	}
-
-	/*
-	 * If a country IE has been received check its rule for this
-	 * channel first before enabling active scan. The passive scan
-	 * would have been enforced by the initial processing of our
-	 * custom regulatory domain.
-	 */
-
-	ch = &sband->channels[11]; /* CH 12 */
-	reg_rule = freq_reg_info(wiphy, ch->center_freq);
-	if (!IS_ERR(reg_rule)) {
-		if (!(reg_rule->flags & NL80211_RRF_NO_IR))
-			if (ch->flags & IEEE80211_CHAN_NO_IR)
-				ch->flags &= ~IEEE80211_CHAN_NO_IR;
-	}
-
-	ch = &sband->channels[12]; /* CH 13 */
-	reg_rule = freq_reg_info(wiphy, ch->center_freq);
-	if (!IS_ERR(reg_rule)) {
-		if (!(reg_rule->flags & NL80211_RRF_NO_IR))
-			if (ch->flags & IEEE80211_CHAN_NO_IR)
-				ch->flags &= ~IEEE80211_CHAN_NO_IR;
+	switch(initiator) {
+	case NL80211_REGDOM_SET_BY_COUNTRY_IE:
+		ath_force_clear_no_ir_freq(wiphy, 2467);
+		ath_force_clear_no_ir_freq(wiphy, 2472);
+		break;
+	default:
+		ath_force_no_ir_freq(wiphy, 2467);
+		ath_force_no_ir_freq(wiphy, 2472);
 	}
 }
 

commit d44040de6a991999b466adefc7588e479680b98d
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Mon Oct 21 19:14:47 2013 +0200

    ath: fix logic on ath_reg_apply_active_scan_flags()
    
    The existing logic removes the passive scan flag from
    channels 12 and 13 when a regulatory hint coming from
    something other than a country IE has been passed. This
    is incorrect, the original intention was to ensure we
    always have passive scan enabled for these two channels
    for a specific set of custom world regulatory domains.
    
    Cc: smihir@qti.qualcomm.com
    Cc: tushnimb@qca.qualcomm.com
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index d3bbf48522b6..3d596e25ba82 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -249,16 +249,16 @@ ath_reg_apply_active_scan_flags(struct wiphy *wiphy,
 		return;
 
 	/*
-	 * If no country IE has been received always enable active scan
-	 * on these channels. This is only done for specific regulatory SKUs
+	 * If no country IE has been received always enable passive scan
+	 * and no-ibss on these channels. This is only done for specific
+	 * regulatory SKUs.
 	 */
 	if (initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE) {
 		ch = &sband->channels[11]; /* CH 12 */
-		if (ch->flags & IEEE80211_CHAN_NO_IR)
-			ch->flags &= ~IEEE80211_CHAN_NO_IR;
+		ch->flags |= IEEE80211_CHAN_NO_IR;
+
 		ch = &sband->channels[12]; /* CH 13 */
-		if (ch->flags & IEEE80211_CHAN_NO_IR)
-			ch->flags &= ~IEEE80211_CHAN_NO_IR;
+		ch->flags |= IEEE80211_CHAN_NO_IR;
 		return;
 	}
 

commit 4b074b07625f603d40d4d04937f8874a00415dc4
Merge: 7d68849f40cd ddcc347b70f2
Author: John W. Linville <linville@tuxdriver.com>
Date:   Mon Dec 2 14:25:38 2013 -0500

    Merge branch 'for-john' of git://git.kernel.org/pub/scm/linux/kernel/git/jberg/mac80211-next

commit a09a85a013523a8b572dc5732b5c30e0785195f3
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Mon Nov 11 22:15:30 2013 +0100

    cfg80211: add flags to define country IE processing rules
    
    802.11 cards may have different country IE parsing behavioural
    preferences and vendors may want to support these. These preferences
    were managed by the REGULATORY_CUSTOM_REG and the REGULATORY_STRICT_REG
    flags and their combination. Instead of using this existing notation,
    split out the country IE behavioural preferences as a new flag. This
    will allow us to add more customizations easily and make the code more
    maintainable.
    
    Cc: Mihir Shete <smihir@qti.qualcomm.com>
    Cc: Henri Bahini <hbahini@qca.qualcomm.com>
    Cc: Tushnim Bhattacharyya <tushnimb@qca.qualcomm.com>
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    [fix up conflicts]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index aba782cd09a2..bef5539192c6 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -609,7 +609,8 @@ ath_regd_init_wiphy(struct ath_regulatory *reg,
 		 * saved on the wiphy orig_* parameters
 		 */
 		regd = ath_world_regdomain(reg);
-		wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG;
+		wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG |
+					   REGULATORY_COUNTRY_IE_FOLLOW_POWER;
 	} else {
 		/*
 		 * This gets applied in the case of the absence of CRDA,

commit a2f73b6c5db3c272d87eaebb5bed355d75a0f25f
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Mon Nov 11 22:15:29 2013 +0100

    cfg80211: move regulatory flags to their own variable
    
    We'll expand this later, this will make it easier to
    classify and review what things are related to regulatory
    or not.
    
    Coccinelle only missed 4 hits, which I had to do manually,
    supplying the SmPL in case of merge conflicts.
    
    @@
    struct wiphy *wiphy;
    @@
    -wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY
    +wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG
    @@
    expression e;
    @@
    -e->flags |= WIPHY_FLAG_CUSTOM_REGULATORY
    +e->regulatory_flags |= REGULATORY_CUSTOM_REG
    @@
    struct wiphy *wiphy;
    @@
    -wiphy->flags &= ~WIPHY_FLAG_CUSTOM_REGULATORY
    +wiphy->regulatory_flags &= ~REGULATORY_CUSTOM_REG
    @@
    struct wiphy *wiphy;
    @@
    -wiphy->flags & WIPHY_FLAG_CUSTOM_REGULATORY
    +wiphy->regulatory_flags & REGULATORY_CUSTOM_REG
    
    @@
    struct wiphy *wiphy;
    @@
    -wiphy->flags |= WIPHY_FLAG_STRICT_REGULATORY
    +wiphy->regulatory_flags |= REGULATORY_STRICT_REG
    @@
    expression e;
    @@
    -e->flags |= WIPHY_FLAG_STRICT_REGULATORY
    +e->regulatory_flags |= REGULATORY_STRICT_REG
    @@
    struct wiphy *wiphy;
    @@
    -wiphy->flags &= ~WIPHY_FLAG_STRICT_REGULATORY
    +wiphy->regulatory_flags &= ~REGULATORY_STRICT_REG
    @@
    struct wiphy *wiphy;
    @@
    -wiphy->flags & WIPHY_FLAG_STRICT_REGULATORY
    +wiphy->regulatory_flags & REGULATORY_STRICT_REG
    
    @@
    struct wiphy *wiphy;
    @@
    -wiphy->flags |= WIPHY_FLAG_DISABLE_BEACON_HINTS
    +wiphy->regulatory_flags |= REGULATORY_DISABLE_BEACON_HINTS
    @@
    expression e;
    @@
    -e->flags |= WIPHY_FLAG_DISABLE_BEACON_HINTS
    +e->regulatory_flags |= REGULATORY_DISABLE_BEACON_HINTS
    @@
    struct wiphy *wiphy;
    @@
    -wiphy->flags &= ~WIPHY_FLAG_DISABLE_BEACON_HINTS
    +wiphy->regulatory_flags &= ~REGULATORY_DISABLE_BEACON_HINTS
    @@
    struct wiphy *wiphy;
    @@
    -wiphy->flags & WIPHY_FLAG_DISABLE_BEACON_HINTS
    +wiphy->regulatory_flags & REGULATORY_DISABLE_BEACON_HINTS
    
    Generated-by: Coccinelle SmPL
    Cc: Julia Lawall <julia.lawall@lip6.fr>
    Cc: Peter Senna Tschudin <peter.senna@gmail.com>
    Cc: Mihir Shete <smihir@qti.qualcomm.com>
    Cc: Henri Bahini <hbahini@qca.qualcomm.com>
    Cc: Tushnim Bhattacharyya <tushnimb@qca.qualcomm.com>
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    [fix up whitespace damage, overly long lines]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index e93e517a699f..aba782cd09a2 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -601,7 +601,7 @@ ath_regd_init_wiphy(struct ath_regulatory *reg,
 	const struct ieee80211_regdomain *regd;
 
 	wiphy->reg_notifier = reg_notifier;
-	wiphy->flags |= WIPHY_FLAG_STRICT_REGULATORY;
+	wiphy->regulatory_flags |= REGULATORY_STRICT_REG;
 
 	if (ath_is_world_regd(reg)) {
 		/*
@@ -609,7 +609,7 @@ ath_regd_init_wiphy(struct ath_regulatory *reg,
 		 * saved on the wiphy orig_* parameters
 		 */
 		regd = ath_world_regdomain(reg);
-		wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;
+		wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG;
 	} else {
 		/*
 		 * This gets applied in the case of the absence of CRDA,

commit 8fe02e167efa8ed4a4503a5eedc0f49fcb7e3eb9
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Mon Oct 21 19:22:25 2013 +0200

    cfg80211: consolidate passive-scan and no-ibss flags
    
    These two flags are used for the same purpose, just
    combine them into a no-ir flag to annotate no initiating
    radiation is allowed.
    
    Old userspace sending either flag will have it treated as
    the no-ir flag. To be considerate to older userspace we
    also send both the no-ir flag and the old no-ibss flags.
    Newer userspace will have to be aware of older kernels.
    
    Update all places in the tree using these flags with the
    following semantic patch:
    
    @@
    @@
    -NL80211_RRF_PASSIVE_SCAN
    +NL80211_RRF_NO_IR
    @@
    @@
    -NL80211_RRF_NO_IBSS
    +NL80211_RRF_NO_IR
    @@
    @@
    -IEEE80211_CHAN_PASSIVE_SCAN
    +IEEE80211_CHAN_NO_IR
    @@
    @@
    -IEEE80211_CHAN_NO_IBSS
    +IEEE80211_CHAN_NO_IR
    @@
    @@
    -NL80211_RRF_NO_IR | NL80211_RRF_NO_IR
    +NL80211_RRF_NO_IR
    @@
    @@
    -IEEE80211_CHAN_NO_IR | IEEE80211_CHAN_NO_IR
    +IEEE80211_CHAN_NO_IR
    @@
    @@
    -(NL80211_RRF_NO_IR)
    +NL80211_RRF_NO_IR
    @@
    @@
    -(IEEE80211_CHAN_NO_IR)
    +IEEE80211_CHAN_NO_IR
    
    Along with some hand-optimisations in documentation, to
    remove duplicates and to fix some indentation.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    [do all the driver updates in one go]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index c00687e05688..e93e517a699f 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -37,17 +37,18 @@ static int __ath_regd_init(struct ath_regulatory *reg);
 
 /* We enable active scan on these a case by case basis by regulatory domain */
 #define ATH9K_2GHZ_CH12_13	REG_RULE(2467-10, 2472+10, 40, 0, 20,\
-					NL80211_RRF_PASSIVE_SCAN)
+					 NL80211_RRF_NO_IR)
 #define ATH9K_2GHZ_CH14		REG_RULE(2484-10, 2484+10, 40, 0, 20,\
-				NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_OFDM)
+					 NL80211_RRF_NO_IR | \
+					 NL80211_RRF_NO_OFDM)
 
 /* We allow IBSS on these on a case by case basis by regulatory domain */
 #define ATH9K_5GHZ_5150_5350	REG_RULE(5150-10, 5350+10, 80, 0, 30,\
-				NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
+					 NL80211_RRF_NO_IR)
 #define ATH9K_5GHZ_5470_5850	REG_RULE(5470-10, 5850+10, 80, 0, 30,\
-				NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
+					 NL80211_RRF_NO_IR)
 #define ATH9K_5GHZ_5725_5850	REG_RULE(5725-10, 5850+10, 80, 0, 30,\
-				NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
+					 NL80211_RRF_NO_IR)
 
 #define ATH9K_2GHZ_ALL		ATH9K_2GHZ_CH01_11, \
 				ATH9K_2GHZ_CH12_13, \
@@ -223,18 +224,11 @@ ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
 				 * default during init, prior to calling our
 				 * regulatory_hint().
 				 */
-				if (!(reg_rule->flags &
-				    NL80211_RRF_NO_IBSS))
-					ch->flags &=
-					  ~IEEE80211_CHAN_NO_IBSS;
-				if (!(reg_rule->flags &
-				    NL80211_RRF_PASSIVE_SCAN))
-					ch->flags &=
-					  ~IEEE80211_CHAN_PASSIVE_SCAN;
+				if (!(reg_rule->flags & NL80211_RRF_NO_IR))
+					ch->flags &= ~IEEE80211_CHAN_NO_IR;
 			} else {
 				if (ch->beacon_found)
-					ch->flags &= ~(IEEE80211_CHAN_NO_IBSS |
-					  IEEE80211_CHAN_PASSIVE_SCAN);
+					ch->flags &= ~IEEE80211_CHAN_NO_IR;
 			}
 		}
 	}
@@ -260,11 +254,11 @@ ath_reg_apply_active_scan_flags(struct wiphy *wiphy,
 	 */
 	if (initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE) {
 		ch = &sband->channels[11]; /* CH 12 */
-		if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
-			ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
+		if (ch->flags & IEEE80211_CHAN_NO_IR)
+			ch->flags &= ~IEEE80211_CHAN_NO_IR;
 		ch = &sband->channels[12]; /* CH 13 */
-		if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
-			ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
+		if (ch->flags & IEEE80211_CHAN_NO_IR)
+			ch->flags &= ~IEEE80211_CHAN_NO_IR;
 		return;
 	}
 
@@ -278,17 +272,17 @@ ath_reg_apply_active_scan_flags(struct wiphy *wiphy,
 	ch = &sband->channels[11]; /* CH 12 */
 	reg_rule = freq_reg_info(wiphy, ch->center_freq);
 	if (!IS_ERR(reg_rule)) {
-		if (!(reg_rule->flags & NL80211_RRF_PASSIVE_SCAN))
-			if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
-				ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
+		if (!(reg_rule->flags & NL80211_RRF_NO_IR))
+			if (ch->flags & IEEE80211_CHAN_NO_IR)
+				ch->flags &= ~IEEE80211_CHAN_NO_IR;
 	}
 
 	ch = &sband->channels[12]; /* CH 13 */
 	reg_rule = freq_reg_info(wiphy, ch->center_freq);
 	if (!IS_ERR(reg_rule)) {
-		if (!(reg_rule->flags & NL80211_RRF_PASSIVE_SCAN))
-			if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
-				ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
+		if (!(reg_rule->flags & NL80211_RRF_NO_IR))
+			if (ch->flags & IEEE80211_CHAN_NO_IR)
+				ch->flags &= ~IEEE80211_CHAN_NO_IR;
 	}
 }
 
@@ -320,8 +314,7 @@ static void ath_reg_apply_radar_flags(struct wiphy *wiphy)
 		 */
 		if (!(ch->flags & IEEE80211_CHAN_DISABLED))
 			ch->flags |= IEEE80211_CHAN_RADAR |
-				     IEEE80211_CHAN_NO_IBSS |
-				     IEEE80211_CHAN_PASSIVE_SCAN;
+				     IEEE80211_CHAN_NO_IR;
 	}
 }
 

commit 3e850edd58800e7b9b29a8dc2c950ebdf489a3e3
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Tue Nov 12 19:33:20 2013 +0100

    ath: fix dynamic user regulatory settings
    
    A world regulatory domain check was in place that
    prevents user dynamic regulatory hints from being
    processed. This was there for historical reasons
    as this was only possible previously for world
    roaming cards and dynamic regulatory settings was
    only possible for country IEs. Fix this by enforcing
    the world regulatory domain check only for when the
    initiator is a country IE. Support for dynamic user
    regulatory support is already checked.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index c00687e05688..1217c52ab28e 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -362,7 +362,8 @@ static int __ath_reg_dyn_country(struct wiphy *wiphy,
 {
 	u16 country_code;
 
-	if (!ath_is_world_regd(reg))
+	if (request->initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE &&
+	    !ath_is_world_regd(reg))
 		return -EINVAL;
 
 	country_code = ath_regd_find_country_by_name(request->alpha2);

commit 94e7876daa4396d7a997d57dfcceaab6851bd017
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Mon Oct 14 17:42:09 2013 -0700

    ath: add support for proper dynamic regulatory hints
    
    This enables support for dynamic user regulatory hints.
    This is enabled only when CFG80211_CERTIFICATION_ONUS
    is selected. For US and JP this is explicitly disabled
    unless the systems are being used for strict controlled
    testing.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 7222eebba47e..c00687e05688 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -392,6 +392,89 @@ static void ath_reg_dyn_country(struct wiphy *wiphy,
 	       reg_initiator_name(request->initiator));
 }
 
+static bool dynamic_country_user_possible(struct ath_regulatory *reg)
+{
+	if (config_enabled(CONFIG_ATH_REG_DYNAMIC_USER_CERT_TESTING))
+		return true;
+
+	switch (reg->country_code) {
+	case CTRY_UNITED_STATES:
+	case CTRY_JAPAN1:
+	case CTRY_JAPAN2:
+	case CTRY_JAPAN3:
+	case CTRY_JAPAN4:
+	case CTRY_JAPAN5:
+	case CTRY_JAPAN6:
+	case CTRY_JAPAN7:
+	case CTRY_JAPAN8:
+	case CTRY_JAPAN9:
+	case CTRY_JAPAN10:
+	case CTRY_JAPAN11:
+	case CTRY_JAPAN12:
+	case CTRY_JAPAN13:
+	case CTRY_JAPAN14:
+	case CTRY_JAPAN15:
+	case CTRY_JAPAN16:
+	case CTRY_JAPAN17:
+	case CTRY_JAPAN18:
+	case CTRY_JAPAN19:
+	case CTRY_JAPAN20:
+	case CTRY_JAPAN21:
+	case CTRY_JAPAN22:
+	case CTRY_JAPAN23:
+	case CTRY_JAPAN24:
+	case CTRY_JAPAN25:
+	case CTRY_JAPAN26:
+	case CTRY_JAPAN27:
+	case CTRY_JAPAN28:
+	case CTRY_JAPAN29:
+	case CTRY_JAPAN30:
+	case CTRY_JAPAN31:
+	case CTRY_JAPAN32:
+	case CTRY_JAPAN33:
+	case CTRY_JAPAN34:
+	case CTRY_JAPAN35:
+	case CTRY_JAPAN36:
+	case CTRY_JAPAN37:
+	case CTRY_JAPAN38:
+	case CTRY_JAPAN39:
+	case CTRY_JAPAN40:
+	case CTRY_JAPAN41:
+	case CTRY_JAPAN42:
+	case CTRY_JAPAN43:
+	case CTRY_JAPAN44:
+	case CTRY_JAPAN45:
+	case CTRY_JAPAN46:
+	case CTRY_JAPAN47:
+	case CTRY_JAPAN48:
+	case CTRY_JAPAN49:
+	case CTRY_JAPAN50:
+	case CTRY_JAPAN51:
+	case CTRY_JAPAN52:
+	case CTRY_JAPAN53:
+	case CTRY_JAPAN54:
+	case CTRY_JAPAN55:
+	case CTRY_JAPAN56:
+	case CTRY_JAPAN57:
+	case CTRY_JAPAN58:
+	case CTRY_JAPAN59:
+		return false;
+	}
+
+	return true;
+}
+
+static void ath_reg_dyn_country_user(struct wiphy *wiphy,
+				     struct ath_regulatory *reg,
+				     struct regulatory_request *request)
+{
+	if (!config_enabled(CONFIG_ATH_REG_DYNAMIC_USER_REG_HINTS))
+		return;
+	if (!dynamic_country_user_possible(reg))
+		return;
+	ath_reg_dyn_country(wiphy, reg, request);
+}
+
 void ath_reg_notifier_apply(struct wiphy *wiphy,
 			    struct regulatory_request *request,
 			    struct ath_regulatory *reg)
@@ -424,6 +507,7 @@ void ath_reg_notifier_apply(struct wiphy *wiphy,
 	case NL80211_REGDOM_SET_BY_DRIVER:
 		break;
 	case NL80211_REGDOM_SET_BY_USER:
+		ath_reg_dyn_country_user(wiphy, reg, request);
 		break;
 	case NL80211_REGDOM_SET_BY_COUNTRY_IE:
 		ath_reg_dyn_country(wiphy, reg, request);

commit 4da225bbc366a4efd6458636c155b34ac9784d4b
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Mon Oct 14 17:42:08 2013 -0700

    ath: split user and driver reguluatory hint parsing
    
    On the regulatory notifier split up the parsing of the
    hints coming from drivers or user. We'll treat these
    separately.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 8373650a946e..7222eebba47e 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -422,6 +422,7 @@ void ath_reg_notifier_apply(struct wiphy *wiphy,
 		       sizeof(struct ath_regulatory));
 		break;
 	case NL80211_REGDOM_SET_BY_DRIVER:
+		break;
 	case NL80211_REGDOM_SET_BY_USER:
 		break;
 	case NL80211_REGDOM_SET_BY_COUNTRY_IE:

commit 8a3b6c800a993bbc7559bcfa77a34e4fc633cf0e
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Mon Oct 14 17:42:07 2013 -0700

    ath: move common dynamic regulatory domain setting to a helper
    
    This moves the dynamic regulatory domain selection code into
    a helper.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 7d077c752dd5..8373650a946e 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -356,14 +356,48 @@ static u16 ath_regd_find_country_by_name(char *alpha2)
 	return -1;
 }
 
+static int __ath_reg_dyn_country(struct wiphy *wiphy,
+				 struct ath_regulatory *reg,
+				 struct regulatory_request *request)
+{
+	u16 country_code;
+
+	if (!ath_is_world_regd(reg))
+		return -EINVAL;
+
+	country_code = ath_regd_find_country_by_name(request->alpha2);
+	if (country_code == (u16) -1)
+		return -EINVAL;
+
+	reg->current_rd = COUNTRY_ERD_FLAG;
+	reg->current_rd |= country_code;
+
+	__ath_regd_init(reg);
+
+	ath_reg_apply_world_flags(wiphy, request->initiator, reg);
+
+	return 0;
+}
+
+static void ath_reg_dyn_country(struct wiphy *wiphy,
+				struct ath_regulatory *reg,
+				struct regulatory_request *request)
+{
+	if (__ath_reg_dyn_country(wiphy, reg, request))
+		return;
+
+	printk(KERN_DEBUG "ath: regdomain 0x%0x "
+			  "dynamically updated by %s\n",
+	       reg->current_rd,
+	       reg_initiator_name(request->initiator));
+}
+
 void ath_reg_notifier_apply(struct wiphy *wiphy,
 			    struct regulatory_request *request,
 			    struct ath_regulatory *reg)
 {
 	struct ath_common *common = container_of(reg, struct ath_common,
 						 regulatory);
-	u16 country_code;
-
 	/* We always apply this */
 	ath_reg_apply_radar_flags(wiphy);
 
@@ -391,22 +425,7 @@ void ath_reg_notifier_apply(struct wiphy *wiphy,
 	case NL80211_REGDOM_SET_BY_USER:
 		break;
 	case NL80211_REGDOM_SET_BY_COUNTRY_IE:
-		if (!ath_is_world_regd(reg))
-			break;
-
-		country_code = ath_regd_find_country_by_name(request->alpha2);
-		if (country_code == (u16) -1)
-			break;
-
-		reg->current_rd = COUNTRY_ERD_FLAG;
-		reg->current_rd |= country_code;
-
-		printk(KERN_DEBUG "ath: regdomain 0x%0x updated by CountryIE\n",
-			reg->current_rd);
-		__ath_regd_init(reg);
-
-		ath_reg_apply_world_flags(wiphy, request->initiator, reg);
-
+		ath_reg_dyn_country(wiphy, reg, request);
 		break;
 	}
 }

commit d619c62f161a43db1f40e5039ff1285dd29b8658
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Wed Jun 5 20:45:36 2013 -0700

    ath: add VHT80 support for regulatory domains
    
    This adds VHT80 support for the QCA world regulatory
    domains.
    
    Cc: kvalo@qca.qualcomm.com
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index ccc4c718f124..7d077c752dd5 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -42,11 +42,11 @@ static int __ath_regd_init(struct ath_regulatory *reg);
 				NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_OFDM)
 
 /* We allow IBSS on these on a case by case basis by regulatory domain */
-#define ATH9K_5GHZ_5150_5350	REG_RULE(5150-10, 5350+10, 40, 0, 30,\
+#define ATH9K_5GHZ_5150_5350	REG_RULE(5150-10, 5350+10, 80, 0, 30,\
 				NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
-#define ATH9K_5GHZ_5470_5850	REG_RULE(5470-10, 5850+10, 40, 0, 30,\
+#define ATH9K_5GHZ_5470_5850	REG_RULE(5470-10, 5850+10, 80, 0, 30,\
 				NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
-#define ATH9K_5GHZ_5725_5850	REG_RULE(5725-10, 5850+10, 40, 0, 30,\
+#define ATH9K_5GHZ_5725_5850	REG_RULE(5725-10, 5850+10, 80, 0, 30,\
 				NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
 
 #define ATH9K_2GHZ_ALL		ATH9K_2GHZ_CH01_11, \

commit 0c0280bd0ba410326eecdaeb1b936696eda6381d
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Fri Jan 11 18:39:36 2013 +0000

    wireless: make the reg_notifier() void
    
    The reg_notifier()'s return value need not be checked
    as it is only supposed to do post regulatory work and
    that should never fail. Any behaviour to regulatory
    that needs to be considered before cfg80211 does work
    to a driver should be specified by using the already
    existing flags, the reg_notifier() just does post
    processing should it find it needs to.
    
    Also make lbs_reg_notifier static.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    [move lbs_reg_notifier to not break compile]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 7a6c79e1f819..ccc4c718f124 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -356,9 +356,9 @@ static u16 ath_regd_find_country_by_name(char *alpha2)
 	return -1;
 }
 
-int ath_reg_notifier_apply(struct wiphy *wiphy,
-			   struct regulatory_request *request,
-			   struct ath_regulatory *reg)
+void ath_reg_notifier_apply(struct wiphy *wiphy,
+			    struct regulatory_request *request,
+			    struct ath_regulatory *reg)
 {
 	struct ath_common *common = container_of(reg, struct ath_common,
 						 regulatory);
@@ -373,7 +373,7 @@ int ath_reg_notifier_apply(struct wiphy *wiphy,
 	 * any pending requests in the queue.
 	 */
 	if (!request)
-		return 0;
+		return;
 
 	switch (request->initiator) {
 	case NL80211_REGDOM_SET_BY_CORE:
@@ -409,8 +409,6 @@ int ath_reg_notifier_apply(struct wiphy *wiphy,
 
 		break;
 	}
-
-	return 0;
 }
 EXPORT_SYMBOL(ath_reg_notifier_apply);
 
@@ -500,8 +498,8 @@ ath_get_regpair(int regdmn)
 static int
 ath_regd_init_wiphy(struct ath_regulatory *reg,
 		    struct wiphy *wiphy,
-		    int (*reg_notifier)(struct wiphy *wiphy,
-					struct regulatory_request *request))
+		    void (*reg_notifier)(struct wiphy *wiphy,
+					 struct regulatory_request *request))
 {
 	const struct ieee80211_regdomain *regd;
 
@@ -621,8 +619,8 @@ static int __ath_regd_init(struct ath_regulatory *reg)
 int
 ath_regd_init(struct ath_regulatory *reg,
 	      struct wiphy *wiphy,
-	      int (*reg_notifier)(struct wiphy *wiphy,
-				  struct regulatory_request *request))
+	      void (*reg_notifier)(struct wiphy *wiphy,
+				   struct regulatory_request *request))
 {
 	struct ath_common *common = container_of(reg, struct ath_common,
 						 regulatory);

commit 361c9c8b0eeeec7d881e018d5143bf883558c566
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Dec 6 15:57:14 2012 +0100

    regulatory: use IS_ERR macro family for freq_reg_info
    
    Instead of returning an error and filling a pointer
    return the pointer and an ERR_PTR value in error cases.
    
    Acked-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 8ae58c404c67..7a6c79e1f819 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -195,7 +195,6 @@ ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
 	const struct ieee80211_reg_rule *reg_rule;
 	struct ieee80211_channel *ch;
 	unsigned int i;
-	int r;
 
 	for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
 
@@ -213,10 +212,8 @@ ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
 				continue;
 
 			if (initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE) {
-				r = freq_reg_info(wiphy,
-						  ch->center_freq,
-						  &reg_rule);
-				if (r)
+				reg_rule = freq_reg_info(wiphy, ch->center_freq);
+				if (IS_ERR(reg_rule))
 					continue;
 				/*
 				 * If 11d had a rule for this channel ensure
@@ -252,7 +249,6 @@ ath_reg_apply_active_scan_flags(struct wiphy *wiphy,
 	struct ieee80211_supported_band *sband;
 	struct ieee80211_channel *ch;
 	const struct ieee80211_reg_rule *reg_rule;
-	int r;
 
 	sband = wiphy->bands[IEEE80211_BAND_2GHZ];
 	if (!sband)
@@ -280,16 +276,16 @@ ath_reg_apply_active_scan_flags(struct wiphy *wiphy,
 	 */
 
 	ch = &sband->channels[11]; /* CH 12 */
-	r = freq_reg_info(wiphy, ch->center_freq, &reg_rule);
-	if (!r) {
+	reg_rule = freq_reg_info(wiphy, ch->center_freq);
+	if (!IS_ERR(reg_rule)) {
 		if (!(reg_rule->flags & NL80211_RRF_PASSIVE_SCAN))
 			if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
 				ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
 	}
 
 	ch = &sband->channels[12]; /* CH 13 */
-	r = freq_reg_info(wiphy, ch->center_freq, &reg_rule);
-	if (!r) {
+	reg_rule = freq_reg_info(wiphy, ch->center_freq);
+	if (!IS_ERR(reg_rule)) {
 		if (!(reg_rule->flags & NL80211_RRF_PASSIVE_SCAN))
 			if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
 				ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;

commit fe7ef5e9ba0c60bab01390493a4c6790f7b093af
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Dec 4 15:07:34 2012 +0100

    regulatory: remove handling of channel bandwidth
    
    The channel bandwidth handling isn't really quite right,
    it assumes that a 40 MHz channel is really two 20 MHz
    channels, which isn't strictly true. This is the way the
    regulatory database handling is defined right now though
    so remove the logic to handle other channel widths.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index d81698015bf7..8ae58c404c67 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -195,7 +195,6 @@ ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
 	const struct ieee80211_reg_rule *reg_rule;
 	struct ieee80211_channel *ch;
 	unsigned int i;
-	u32 bandwidth = 0;
 	int r;
 
 	for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
@@ -216,7 +215,6 @@ ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
 			if (initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE) {
 				r = freq_reg_info(wiphy,
 						  ch->center_freq,
-						  bandwidth,
 						  &reg_rule);
 				if (r)
 					continue;
@@ -254,7 +252,6 @@ ath_reg_apply_active_scan_flags(struct wiphy *wiphy,
 	struct ieee80211_supported_band *sband;
 	struct ieee80211_channel *ch;
 	const struct ieee80211_reg_rule *reg_rule;
-	u32 bandwidth = 0;
 	int r;
 
 	sband = wiphy->bands[IEEE80211_BAND_2GHZ];
@@ -283,7 +280,7 @@ ath_reg_apply_active_scan_flags(struct wiphy *wiphy,
 	 */
 
 	ch = &sband->channels[11]; /* CH 12 */
-	r = freq_reg_info(wiphy, ch->center_freq, bandwidth, &reg_rule);
+	r = freq_reg_info(wiphy, ch->center_freq, &reg_rule);
 	if (!r) {
 		if (!(reg_rule->flags & NL80211_RRF_PASSIVE_SCAN))
 			if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
@@ -291,7 +288,7 @@ ath_reg_apply_active_scan_flags(struct wiphy *wiphy,
 	}
 
 	ch = &sband->channels[12]; /* CH 13 */
-	r = freq_reg_info(wiphy, ch->center_freq, bandwidth, &reg_rule);
+	r = freq_reg_info(wiphy, ch->center_freq, &reg_rule);
 	if (!r) {
 		if (!(reg_rule->flags & NL80211_RRF_PASSIVE_SCAN))
 			if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)

commit 516304b0f45614fb8967dc86ff681499204cdbb1
Author: Joe Perches <joe@perches.com>
Date:   Sun Mar 18 17:30:52 2012 -0700

    ath: Add and use pr_fmt, convert printks to pr_<level>
    
    Use a more current logging style.
    Make sure all output is prefixed appropriately.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 10dea37431b3..d81698015bf7 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -14,6 +14,8 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/kernel.h>
 #include <linux/export.h>
 #include <net/cfg80211.h>
@@ -562,7 +564,7 @@ static int __ath_regd_init(struct ath_regulatory *reg)
 	printk(KERN_DEBUG "ath: EEPROM regdomain: 0x%0x\n", reg->current_rd);
 
 	if (!ath_regd_is_eeprom_valid(reg)) {
-		printk(KERN_ERR "ath: Invalid EEPROM contents\n");
+		pr_err("Invalid EEPROM contents\n");
 		return -EINVAL;
 	}
 

commit de1c732b1891a25f3f2f52ef7211a3d567bbd588
Author: Luis R. Rodriguez <rodrigue@qca.qualcomm.com>
Date:   Thu Dec 8 23:59:24 2011 +0530

    ath: optimize processing of CTLs for country IEs for world roaming cards
    
    When we receive a country IE hint and we have a world roaming card
    we can optimize output power further by ensuring that we use the
    calibrated data for the country by using that country's own CTL data.
    That is -- when world roaming and when we process a country IE we
    no longer need to use the lowest output power of all CTLs instead
    we use an optimized CTL output power for that specific country.
    
    We accomplish this by copying the regulatory data prior on init
    and restoring it when cfg80211 tells us it gets a core hint. Core
    hints are only sent on init and when it wants to restore reguulatory
    settings. We take advantage of this fact and apply the cached
    regulatory data when we get a core hint. When we get a country IE
    hint though we process the regulatory data as if programmed for
    a specific country.
    
    Tested-by: Rajkumar Manoharan <rmanohar@qca.qualcomm.com>
    Signed-off-by: Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
    Acked-by: Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index ed4966fdb8d3..10dea37431b3 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -21,6 +21,8 @@
 #include "regd.h"
 #include "regd_common.h"
 
+static int __ath_regd_init(struct ath_regulatory *reg);
+
 /*
  * This is a set of common rules used by our world regulatory domains.
  * We have 12 world regulatory domains. To save space we consolidate
@@ -347,10 +349,26 @@ static void ath_reg_apply_world_flags(struct wiphy *wiphy,
 	}
 }
 
+static u16 ath_regd_find_country_by_name(char *alpha2)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(allCountries); i++) {
+		if (!memcmp(allCountries[i].isoName, alpha2, 2))
+			return allCountries[i].countryCode;
+	}
+
+	return -1;
+}
+
 int ath_reg_notifier_apply(struct wiphy *wiphy,
 			   struct regulatory_request *request,
 			   struct ath_regulatory *reg)
 {
+	struct ath_common *common = container_of(reg, struct ath_common,
+						 regulatory);
+	u16 country_code;
+
 	/* We always apply this */
 	ath_reg_apply_radar_flags(wiphy);
 
@@ -363,14 +381,37 @@ int ath_reg_notifier_apply(struct wiphy *wiphy,
 		return 0;
 
 	switch (request->initiator) {
-	case NL80211_REGDOM_SET_BY_DRIVER:
 	case NL80211_REGDOM_SET_BY_CORE:
+		/*
+		 * If common->reg_world_copy is world roaming it means we *were*
+		 * world roaming... so we now have to restore that data.
+		 */
+		if (!ath_is_world_regd(&common->reg_world_copy))
+			break;
+
+		memcpy(reg, &common->reg_world_copy,
+		       sizeof(struct ath_regulatory));
+		break;
+	case NL80211_REGDOM_SET_BY_DRIVER:
 	case NL80211_REGDOM_SET_BY_USER:
 		break;
 	case NL80211_REGDOM_SET_BY_COUNTRY_IE:
-		if (ath_is_world_regd(reg))
-			ath_reg_apply_world_flags(wiphy, request->initiator,
-						  reg);
+		if (!ath_is_world_regd(reg))
+			break;
+
+		country_code = ath_regd_find_country_by_name(request->alpha2);
+		if (country_code == (u16) -1)
+			break;
+
+		reg->current_rd = COUNTRY_ERD_FLAG;
+		reg->current_rd |= country_code;
+
+		printk(KERN_DEBUG "ath: regdomain 0x%0x updated by CountryIE\n",
+			reg->current_rd);
+		__ath_regd_init(reg);
+
+		ath_reg_apply_world_flags(wiphy, request->initiator, reg);
+
 		break;
 	}
 
@@ -588,12 +629,18 @@ ath_regd_init(struct ath_regulatory *reg,
 	      int (*reg_notifier)(struct wiphy *wiphy,
 				  struct regulatory_request *request))
 {
+	struct ath_common *common = container_of(reg, struct ath_common,
+						 regulatory);
 	int r;
 
 	r = __ath_regd_init(reg);
 	if (r)
 		return r;
 
+	if (ath_is_world_regd(reg))
+		memcpy(&common->reg_world_copy, reg,
+		       sizeof(struct ath_regulatory));
+
 	ath_regd_init_wiphy(reg, wiphy, reg_notifier);
 
 	return 0;

commit 43fcb430a4cfb7bd7c82600edeb3ca65f202a5f3
Author: Luis R. Rodriguez <rodrigue@qca.qualcomm.com>
Date:   Thu Dec 8 23:59:23 2011 +0530

    ath: add a helper for processing reg data on init
    
    This has no functional change. The helper can be used later
    for other things like country IE changes and following the CTL
    for different countries.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
    Acked-by: Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 65ecb5bab25a..ed4966fdb8d3 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -508,11 +508,7 @@ static void ath_regd_sanitize(struct ath_regulatory *reg)
 	reg->current_rd = 0x64;
 }
 
-int
-ath_regd_init(struct ath_regulatory *reg,
-	      struct wiphy *wiphy,
-	      int (*reg_notifier)(struct wiphy *wiphy,
-				  struct regulatory_request *request))
+static int __ath_regd_init(struct ath_regulatory *reg)
 {
 	struct country_code_to_enum_rd *country = NULL;
 	u16 regdmn;
@@ -583,7 +579,23 @@ ath_regd_init(struct ath_regulatory *reg,
 	printk(KERN_DEBUG "ath: Regpair used: 0x%0x\n",
 		reg->regpair->regDmnEnum);
 
+	return 0;
+}
+
+int
+ath_regd_init(struct ath_regulatory *reg,
+	      struct wiphy *wiphy,
+	      int (*reg_notifier)(struct wiphy *wiphy,
+				  struct regulatory_request *request))
+{
+	int r;
+
+	r = __ath_regd_init(reg);
+	if (r)
+		return r;
+
 	ath_regd_init_wiphy(reg, wiphy, reg_notifier);
+
 	return 0;
 }
 EXPORT_SYMBOL(ath_regd_init);

commit 515db09338704a6ad7d27b5f1e33820d3052edd2
Merge: 30be52e44fd4 cfcfc9eca2bc
Author: John W. Linville <linville@tuxdriver.com>
Date:   Tue Nov 22 14:05:46 2011 -0500

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux
    
    Conflicts:
            drivers/net/wireless/iwlegacy/iwl-debugfs.c
            drivers/net/wireless/iwlegacy/iwl-rx.c
            drivers/net/wireless/iwlegacy/iwl-scan.c
            drivers/net/wireless/iwlegacy/iwl-tx.c
            include/net/bluetooth/bluetooth.h

commit a59be0811c322f80aaa886b144239393efece42d
Author: Helmut Schaa <helmut.schaa@googlemail.com>
Date:   Tue Nov 8 14:01:13 2011 +0100

    ath: Fix NULL ptr dereference in ath_reg_apply_world_flags
    
    This happens with devices using a regulatory domain 0x68 that are only
    5Ghz capable because ath_reg_apply_active_scan_flags assumes that we
    always have a 2,4Ghz band.
    
    CPU 0 Unable to handle kernel paging request at virtual address 00000000, epc == 82cd838c, ra == 82cd8384
    Oops[#1]:
    Cpu 0
    $ 0 : 00000000 00000061 00000003 00000024
    $ 4 : 00000003 000016c1 82f900ac 00000024
    $ 8 : 00000000 82cda304 0058bad8 00000005
    $12 : 005908f8 001e8481 00000003 1dcd6500
    $16 : 00000002 00000000 82c700c0 82c700c0
    $20 : 82d415e4 82c70d64 82c70200 82c715bc
    $24 : 00000000 11e1a300
    $28 : 82ce2000 82ce3c70 82c715a8 82cd8384
    Hi : 00000000
    Lo : 0000001e
    epc : 82cd838c ath_reg_apply_world_flags+0x78/0x17c [ath]
    Not tainted
    ra : 82cd8384 ath_reg_apply_world_flags+0x70/0x17c [ath]
    Status: 1000d403 KERNEL EXL IE
    Cause : 80800008
    BadVA : 00000000
    PrId : 00019374 (MIPS 24Kc)
    Modules linked in: ath9k(+) ath9k_common ath9k_hw ath mac80211 cfg80211
            compat_firmware_class compat arc4 aes_generic deflate ecb cbc
            leds_gpio button_hotplug gpio_buttons input_polldev ie
    Process insmod (pid: 464, threadinfo=82ce2000, task=838b31d8, tls=00000000)
    Stack : 00000000 00000002 82f900ac 82c700c0 82d415e4 82c70d64 00000000 00000068
    82f900ac 82cd88f4 82c700c0 82cda304 00000001 000020f0 82f90000 82c70d40
    00000002 82f90000 82f900ac 82d4207c 82d518a0 00000002 7fee6118 8017c0d8
    00000008 8397ba00 82c70d40 00000000 82c70200 83813000 83813058 b0010000
    82d518a0 00000002 7fee6118 82d4b8c8 83445cc0 80120dc0 83804000 800eeda0
    ...
    Call Trace:
    [<82cd838c>] ath_reg_apply_world_flags+0x78/0x17c [ath]
    [<82cd88f4>] ath_regd_init+0x464/0x488 [ath]
    [<82d4207c>] ath9k_init_device+0x6a4/0x6b4 [ath9k]
    [<82d4b8c8>] ath_pci_probe+0x27c/0x358 [ath9k]
    [<80181de0>] pci_device_probe+0x64/0xa4
    [<8019e874>] driver_probe_device+0xb8/0x190
    [<8019e9b8>] __driver_attach+0x6c/0xa4
    [<8019dfc0>] bus_for_each_dev+0x60/0xb0
    [<8019d744>] bus_add_driver+0xc4/0x25c
    [<8019ed6c>] driver_register+0xe0/0x198
    [<8018206c>] __pci_register_driver+0x50/0xe0
    [<82dd0010>] ath9k_init+0x10/0x54 [ath9k]
    [<8006b4a0>] do_one_initcall+0x68/0x1ec
    [<800a901c>] sys_init_module+0xec/0x23c
    [<80062544>] stack_done+0x20/0x3c
    
    Signed-off-by: Helmut Schaa <helmut.schaa@googlemail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 028310f263c8..f1be57f0f5bb 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -253,6 +253,8 @@ ath_reg_apply_active_scan_flags(struct wiphy *wiphy,
 	int r;
 
 	sband = wiphy->bands[IEEE80211_BAND_2GHZ];
+	if (!sband)
+		return;
 
 	/*
 	 * If no country IE has been received always enable active scan

commit ee40fa0656a730491765545ff7550f3c1ceb0fbc
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri May 27 16:14:23 2011 -0400

    drivers/net: Add export.h to files using EXPORT_SYMBOL/THIS_MODULE
    
    These were getting the macros from an implicit module.h
    include via device.h, but we are planning to clean that up.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    
    drivers/net: Add export.h to wireless/brcm80211/brcmfmac/bcmsdh.c
    
    This relatively recently added file uses EXPORT_SYMBOL and hence
    needs export.h included so that it is compatible with the module.h
    split up work.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 028310f263c8..85fa9cc73502 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -15,6 +15,7 @@
  */
 
 #include <linux/kernel.h>
+#include <linux/export.h>
 #include <net/cfg80211.h>
 #include <net/mac80211.h>
 #include "regd.h"

commit cfef6047c4027a8448ec8dafeaf2bb362cc882e4
Merge: b71d1d426d26 73b48099cc26
Author: John W. Linville <linville@tuxdriver.com>
Date:   Mon Apr 25 14:34:25 2011 -0400

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless-next-2.6 into for-davem
    
    Conflicts:
            drivers/net/wireless/iwlwifi/iwl-core.c
            drivers/net/wireless/rt2x00/rt2x00queue.c
            drivers/net/wireless/rt2x00/rt2x00queue.h

commit 2290a9c35df271cc33601b69e7836fa288e2fc7d
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Thu Apr 14 14:55:36 2011 -0700

    ath: fix 0x6C for beaconing/passive scan flags based on country IE
    
    The 0x6C regulatory domain is just like the 0x6A regulatory
    domain but differs in that 0x6C will allow adhoc and active
    scan on its channels only if we are associated to an AP
    with a country IE that allows those channels. The
    ath_reg_apply_beaconing_flags() does just this -- we respect
    the manufacturer's intent on only enabling beaconing modes
    of operation if and only if blessed by the country IE.
    
    Cc: David Quan <david.quan@atheros.com>
    Cc: Senthil Balasubramanian <senthilkumar@atheros.com>
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 7e3b29015dda..02b896208b1a 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -334,6 +334,7 @@ static void ath_reg_apply_world_flags(struct wiphy *wiphy,
 	case 0x63:
 	case 0x66:
 	case 0x67:
+	case 0x6C:
 		ath_reg_apply_beaconing_flags(wiphy, initiator);
 		break;
 	case 0x68:

commit 34a0a2025c8bddc6505b56a58ef2e7333a4e4165
Author: Senthil Balasubramanian <senthilkumar@atheros.com>
Date:   Thu Apr 14 16:41:30 2011 +0530

    ath: Add a missing world regulatory domain 0x6C
    
    Some customers use 0x6C world regulatory domain and this patch
    adds the support.
    
    Cc: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: Senthil Balasubramanian <senthilkumar@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index f828f294ba89..7e3b29015dda 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -97,8 +97,8 @@ static const struct ieee80211_regdomain ath_world_regdom_66_69 = {
 	}
 };
 
-/* Can be used by 0x67, 0x6A and 0x68 */
-static const struct ieee80211_regdomain ath_world_regdom_67_68_6A = {
+/* Can be used by 0x67, 0x68, 0x6A and 0x6C */
+static const struct ieee80211_regdomain ath_world_regdom_67_68_6A_6C = {
 	.n_reg_rules = 4,
 	.alpha2 =  "99",
 	.reg_rules = {
@@ -151,7 +151,8 @@ ieee80211_regdomain *ath_world_regdomain(struct ath_regulatory *reg)
 	case 0x67:
 	case 0x68:
 	case 0x6A:
-		return &ath_world_regdom_67_68_6A;
+	case 0x6C:
+		return &ath_world_regdom_67_68_6A_6C;
 	default:
 		WARN_ON(1);
 		return ath_default_world_regdomain();

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index f828f294ba89..0e1b8793c864 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -268,7 +268,7 @@ ath_reg_apply_active_scan_flags(struct wiphy *wiphy,
 	}
 
 	/*
-	 * If a country IE has been recieved check its rule for this
+	 * If a country IE has been received check its rule for this
 	 * channel first before enabling active scan. The passive scan
 	 * would have been enforced by the initial processing of our
 	 * custom regulatory domain.
@@ -476,7 +476,7 @@ ath_regd_init_wiphy(struct ath_regulatory *reg,
 		wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;
 	} else {
 		/*
-		 * This gets applied in the case of the absense of CRDA,
+		 * This gets applied in the case of the absence of CRDA,
 		 * it's our own custom world regulatory domain, similar to
 		 * cfg80211's but we enable passive scanning.
 		 */

commit 5719efdde1d0ae8670b96eb8748d1a0dc6a37be2
Author: Bruno Randolf <br1@einfach.org>
Date:   Tue Jan 25 13:15:33 2011 +0900

    ath: Add function to check if 4.9GHz channels are allowed
    
    This adds a helper function to ath/regd.c which can be asked if 4.9GHz channels
    are allowed for a given regulatory domain code. This keeps the knowledge of
    regdomains and defines like MKK9_MKKC in one place. I'm passing the regdomain
    code instead of the ath_regulatory structure because this needs to be called
    quite early in the driver inititalization where ath_regulatory is not available
    yet in ath5k.
    
    I'm using MKK9_MKKC only because this is the regdomain in the 802.11j enabled
    sample cards we got from our vendor. I found some hints in HAL code that this
    is used by Atheros to indicate 4.9GHz channels support and that there might be
    other domain codes as well, but as I don't have any documentation I'm just
    putting in what I need right now. It can be extended later.
    
    Signed-off-by: Bruno Randolf <br1@einfach.org>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 2b14775e6bc6..f828f294ba89 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -158,6 +158,13 @@ ieee80211_regdomain *ath_world_regdomain(struct ath_regulatory *reg)
 	}
 }
 
+bool ath_is_49ghz_allowed(u16 regdomain)
+{
+	/* possibly more */
+	return regdomain == MKK9_MKKC;
+}
+EXPORT_SYMBOL(ath_is_49ghz_allowed);
+
 /* Frequency is one where radar detection is required */
 static bool ath_is_radar_freq(u16 center_freq)
 {

commit 931299cf87701962ea1811dc216f48f3f7a4ebc8
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Wed Dec 15 19:24:12 2010 -0800

    ath: fix NULL pointer dereference on reg_notifier()
    
    The reg_notifier() was recently updated as being capable of
    having the request passed as NULL, fix ath to follow this API
    change. Without this we end up oopsing:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000004
    IP: [<ffffffffa02fb8cb>] ath_reg_notifier_apply+0x5b/0xa0 [ath]
    PGD b4c4c067 PUD b4c4d067 PMD 0
    Oops: 0000 [#1] SMP DEBUG_PAGEALLOC
    last sysfs file: /sys/devices/pci0000:00/0000:00:1b.0/uevent
    CPU 1
    Modules linked in: <etc>
    Pid: 436, comm: modprobe Not tainted 2.6.37-rc5-wl+ #36 6460DWU/6460DWU
    RIP: 0010:[<ffffffffa02fb8cb>]  [<ffffffffa02fb8cb>] ath_reg_notifier_apply+0x5b/0xa0 [ath]
    RSP: 0018:ffff8800b6f6baa8  EFLAGS: 00010246
    RAX: ffff8800b527b254 RBX: ffff8800b532c180 RCX: 0000000000000018
    RDX: ffff8800b530c108 RSI: 0000000000000000 RDI: ffff8800b532c180
    RBP: ffff8800b6f6baa8 R08: ffff8800b532f268 R09: 0000000000000235
    R10: 00000000000016ad R11: 0000000000000018 R12: 0000000000000000
    R13: 0000000000000016 R14: ffff8800b532f268 R15: 0000000000000011
    FS:  00007f0c53104700(0000) GS:ffff8800bed00000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    CR2: 0000000000000004 CR3: 00000000b6531000 CR4: 00000000000006e0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    Process modprobe (pid: 436, threadinfo ffff8800b6f6a000, task ffff8800b404dc40)
    Stack:
     ffff8800b6f6bac8 ffffffffa03ea651 ffff8800b532c180 ffff8800b527b254
     ffff8800b6f6bb38 ffffffffa01835ca ffffffffa019ed00 00000000a019ed80
     0000000000000002 ffff880000000002 ffffffffa0366140 0000000010aee572
    Call Trace:
     [<ffffffffa03ea651>] ath9k_reg_notifier+0x41/0x50 [ath9k]
     [<ffffffffa01835ca>] wiphy_update_regulatory+0x4ba/0x5a0 [cfg80211]
     [<ffffffffa0366140>] ? ieee80211_register_hw+0xa0/0x5b0 [mac80211]
     [<ffffffffa0366140>] ? ieee80211_register_hw+0xa0/0x5b0 [mac80211]
     [<ffffffffa017f994>] wiphy_register+0x1d4/0x360 [cfg80211]
     [<ffffffff8114b918>] ? __kmalloc+0x108/0x1c0
     [<ffffffffa0366223>] ieee80211_register_hw+0x183/0x5b0 [mac80211]
     [<ffffffffa03eb49b>] ath9k_init_device+0x66b/0x850 [ath9k]
     [<ffffffffa03f9dd6>] ath_pci_probe+0x2f6/0x3c0 [ath9k]
     [<ffffffff81037529>] ? default_spin_lock_flags+0x9/0x10
     [<ffffffff812e19cf>] local_pci_probe+0x5f/0xd0
     [<ffffffff812e2bf1>] pci_device_probe+0x101/0x120
     [<ffffffff81390aca>] ? driver_sysfs_add+0x7a/0xb0
     [<ffffffff81390c26>] driver_probe_device+0x96/0x1c0
     [<ffffffff81390deb>] __driver_attach+0x9b/0xa0
     [<ffffffff81390d50>] ? __driver_attach+0x0/0xa0
     [<ffffffff81390008>] bus_for_each_dev+0x68/0x90
     [<ffffffff81390a4e>] driver_attach+0x1e/0x20
     [<ffffffff81390309>] bus_add_driver+0xe9/0x290
     [<ffffffffa0407000>] ? ath9k_init+0x0/0x4d [ath9k]
     [<ffffffff81391130>] driver_register+0x80/0x150
     [<ffffffffa0407000>] ? ath9k_init+0x0/0x4d [ath9k]
     [<ffffffffa0407000>] ? ath9k_init+0x0/0x4d [ath9k]
     [<ffffffff812e2e76>] __pci_register_driver+0x56/0xd0
     [<ffffffffa03f9ec3>] ath_pci_init+0x23/0x30 [ath9k]
     [<ffffffffa040702b>] ath9k_init+0x2b/0x4d [ath9k]
     [<ffffffff81002053>] do_one_initcall+0x43/0x190
     [<ffffffff8109fb5b>] sys_init_module+0xbb/0x200
     [<ffffffff8100c042>] system_call_fastpath+0x16/0x1b
    Code: <who even reads this anyway? haha, ok you do>
    RIP  [<ffffffffa02fb8cb>] ath_reg_notifier_apply+0x5b/0xa0 [ath]
     RSP <ffff8800b6f6baa8>
    CR2: 0000000000000004
    ---[ end trace 6d03d3c7eda9f06b ]---
    
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 3f4244f56ce5..2b14775e6bc6 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -342,6 +342,14 @@ int ath_reg_notifier_apply(struct wiphy *wiphy,
 	/* We always apply this */
 	ath_reg_apply_radar_flags(wiphy);
 
+	/*
+	 * This would happen when we have sent a custom regulatory request
+	 * a world regulatory domain and the scheduler hasn't yet processed
+	 * any pending requests in the queue.
+	 */
+	if (!request)
+		return 0;
+
 	switch (request->initiator) {
 	case NL80211_REGDOM_SET_BY_DRIVER:
 	case NL80211_REGDOM_SET_BY_CORE:

commit a4b770972b8f819e408d7cc3ae9637e15bff62f6
Author: Joe Perches <joe@perches.com>
Date:   Fri May 14 00:19:28 2010 -0700

    drivers/net: Remove unnecessary returns from void function()s
    
    This patch removes from drivers/net/ all the unnecessary
    return; statements that precede the last closing brace of
    void functions.
    
    It does not remove the returns that are immediately
    preceded by a label as gcc doesn't like that.
    
    It also does not remove null void functions with return.
    
    Done via:
    $ grep -rP --include=*.[ch] -l "return;\n}" net/ | \
      xargs perl -i -e 'local $/ ; while (<>) { s/\n[ \t\n]+return;\n}/\n}/g; print; }'
    
    with some cleanups by hand.
    
    Compile tested x86 allmodconfig only.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 24d59883d944..3f4244f56ce5 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -333,7 +333,6 @@ static void ath_reg_apply_world_flags(struct wiphy *wiphy,
 		ath_reg_apply_active_scan_flags(wiphy, initiator);
 		break;
 	}
-	return;
 }
 
 int ath_reg_notifier_apply(struct wiphy *wiphy,

commit 5c01d5669356e13f0fb468944c1dd4c6a7e978ad
Merge: fea069152614 a5e944f1d955
Author: John W. Linville <linville@tuxdriver.com>
Date:   Thu Apr 15 16:21:34 2010 -0400

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless-next-2.6 into for-davem
    
    Conflicts:
            Documentation/feature-removal-schedule.txt
            drivers/net/wireless/ath/ath5k/phy.c
            drivers/net/wireless/wl12xx/wl1271_main.c

commit cfcfe4469cc39625cb8257355c00dd8f35f900aa
Author: Luis de Bethencourt <luisbg@ubuntu.com>
Date:   Tue Mar 30 16:44:33 2010 +0100

    ath: fix code readability in regd.c
    
    This is a patch to the ath/regd.c file that fixes two code
    readability issues. A space between to separate two defines
    and the indentation inside the ath_redg_is_eeprom_valid
    function.
    
    Signed-off-by: Luis de Bethencourt <luisbg@ubuntu.com>
    Acked-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 04abd1f556b7..d5c23328aef1 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -51,6 +51,7 @@
 
 #define ATH9K_5GHZ_ALL		ATH9K_5GHZ_5150_5350, \
 				ATH9K_5GHZ_5470_5850
+
 /* This one skips what we call "mid band" */
 #define ATH9K_5GHZ_NO_MIDBAND	ATH9K_5GHZ_5150_5350, \
 				ATH9K_5GHZ_5725_5850
@@ -361,7 +362,7 @@ EXPORT_SYMBOL(ath_reg_notifier_apply);
 
 static bool ath_regd_is_eeprom_valid(struct ath_regulatory *reg)
 {
-	 u16 rd = ath_regd_get_eepromRD(reg);
+	u16 rd = ath_regd_get_eepromRD(reg);
 	int i;
 
 	if (rd & COUNTRY_ERD_FLAG) {

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 04abd1f556b7..00489c40be0c 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -15,7 +15,6 @@
  */
 
 #include <linux/kernel.h>
-#include <linux/slab.h>
 #include <net/cfg80211.h>
 #include <net/mac80211.h>
 #include "regd.h"

commit 641eabb0a3717020d1a93d3f91493ab0d826c910
Author: Christian Lamparter <chunkeey@googlemail.com>
Date:   Sun Feb 7 16:01:55 2010 +0100

    ath: fix WARN_ON with Polish (Poland) Contry code
    
    This patch fixes a WARN_ON which is triggered
    by Poland's country code.
    
    ath: EEPROM regdomain: 0x8268
    ath: EEPROM indicates we should expect a country code
    ath: doing EEPROM country->regdmn map search
    ath: country maps to regdmn code: 0x37
    ath: Country alpha2 being used: PL
    ath: Regpair used: 0x37
      -----------[ cut here ]------------
    WARNING: at drivers/net/wireless/ath/regd.c:155 ath_regd_init+0x30b
    Pid: 12661, comm: firmware/carl91 2.6.33-rc5-wl #18
    Call Trace:
     [<>] ? warn_slowpath_common+0x76/0x8c
     [<>] ? ar9170_reg_notifier+0x0/0x2d [carl9170usb]
     [<>] ? ath_regd_init+0x30b/0x377 [ath]
     [<>] ? ar9170_register+0x3b3/0x3ca [carl9170usb]
    [...]
    ---[ end trace ]---
    
    Note: Poland is just an example. But it is very likely
    that more country codes are affected.
    
    Cc: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: Christian Lamparter <chunkeey@googlemail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 039ac490465c..04abd1f556b7 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -110,8 +110,9 @@ static const struct ieee80211_regdomain ath_world_regdom_67_68_6A = {
 
 static inline bool is_wwr_sku(u16 regd)
 {
-	return ((regd & WORLD_SKU_MASK) == WORLD_SKU_PREFIX) ||
-		(regd == WORLD);
+	return ((regd & COUNTRY_ERD_FLAG) != COUNTRY_ERD_FLAG) &&
+		(((regd & WORLD_SKU_MASK) == WORLD_SKU_PREFIX) ||
+		(regd == WORLD));
 }
 
 static u16 ath_regd_get_eepromRD(struct ath_regulatory *reg)

commit 5be83de54c16944dea9c16c6a5a53c1fa75ed304
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu Nov 19 00:56:28 2009 +0100

    cfg80211: convert bools into flags
    
    We've accumulated a number of options for wiphys
    which make more sense as flags as we keep adding
    more. Convert the existing ones.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 077bcc142cde..039ac490465c 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -450,7 +450,7 @@ ath_regd_init_wiphy(struct ath_regulatory *reg,
 	const struct ieee80211_regdomain *regd;
 
 	wiphy->reg_notifier = reg_notifier;
-	wiphy->strict_regulatory = true;
+	wiphy->flags |= WIPHY_FLAG_STRICT_REGULATORY;
 
 	if (ath_is_world_regd(reg)) {
 		/*
@@ -458,8 +458,7 @@ ath_regd_init_wiphy(struct ath_regulatory *reg,
 		 * saved on the wiphy orig_* parameters
 		 */
 		regd = ath_world_regdomain(reg);
-		wiphy->custom_regulatory = true;
-		wiphy->strict_regulatory = false;
+		wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;
 	} else {
 		/*
 		 * This gets applied in the case of the absense of CRDA,

commit 74d154189d597b91da4322996dbf4f5c3d1544ab
Merge: 5a6338db3788 ffafa60d496f
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Jul 23 19:03:51 2009 -0700

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/davem/net-2.6
    
    Conflicts:
            drivers/net/wireless/iwmc3200wifi/netdev.c
            net/wireless/scan.c

commit 5d2214ac5e7f72c9ae70b2444649e8d1d3e1086d
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Mon Jul 20 08:32:47 2009 -0700

    ath: add support for special 0x8000 regulatory domain
    
    Two users of ar9170 devices have now reported their cards
    have been programmed with a regulatory domain of 0x8000.
    This is not a valid regulatory domain as such these users were
    unable to use these devices. Since this doesn't seem to be
    a device EEPROM corruption we must treat it specially. It
    may have been possible the manufacturer intended to use 0x0
    as the regulatory domain and that would ultimately yield
    to US but since we cannot get confirmationf or this we
    default this special case to one of our world regulatory
    domains, specifically 0x64.
    
    Reported-by: DavidFreeman on #linux-wireless
    Reported-by: Joerg Albert <jal2@gmx.de>
    Cc: Christian Lamparter <chunkeey@web.de>,
    Cc: Stephen Chen <stephen.chen@atheros.com>
    Cc: David Quan <david.quan@atheros.com>
    Cc: Tony Yang <tony.yang@atheros.com>
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index eef370bd1211..bf3d25ba7be1 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -474,6 +474,21 @@ ath_regd_init_wiphy(struct ath_regulatory *reg,
 	return 0;
 }
 
+/*
+ * Some users have reported their EEPROM programmed with
+ * 0x8000 set, this is not a supported regulatory domain
+ * but since we have more than one user with it we need
+ * a solution for them. We default to 0x64, which is the
+ * default Atheros world regulatory domain.
+ */
+static void ath_regd_sanitize(struct ath_regulatory *reg)
+{
+	if (reg->current_rd != COUNTRY_ERD_FLAG)
+		return;
+	printk(KERN_DEBUG "ath: EEPROM regdomain sanitized\n");
+	reg->current_rd = 0x64;
+}
+
 int
 ath_regd_init(struct ath_regulatory *reg,
 	      struct wiphy *wiphy,
@@ -486,6 +501,8 @@ ath_regd_init(struct ath_regulatory *reg,
 	if (!reg)
 		return -EINVAL;
 
+	ath_regd_sanitize(reg);
+
 	printk(KERN_DEBUG "ath: EEPROM regdomain: 0x%0x\n", reg->current_rd);
 
 	if (!ath_regd_is_eeprom_valid(reg)) {

commit 88f6bfe1829d67bea37b060d53131b2b96ebc8ac
Author: Bob Copeland <me@bobcopeland.com>
Date:   Sat Jul 4 12:59:53 2009 -0400

    ath: remove unnecessary return in ath_regd_get_band_ctl
    
    'default' case already returns NO_CTL
    
    Signed-off-by: Bob Copeland <me@bobcopeland.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index eef370bd1211..f37c83275793 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -569,7 +569,5 @@ u32 ath_regd_get_band_ctl(struct ath_regulatory *reg,
 	default:
 		return NO_CTL;
 	}
-
-	return NO_CTL;
 }
 EXPORT_SYMBOL(ath_regd_get_band_ctl);

commit e03e5ffd8d3327d23d76be5d63cfbbb537b1af59
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Tue Jun 2 16:30:56 2009 -0400

    ath: make regulatory parsing more verbose on debug
    
    This should help when reviewing issues regarding regulatory
    domain on ath5k/ath9k/ar9170.
    
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 7a89f9fac7d4..eef370bd1211 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -366,11 +366,17 @@ static bool ath_regd_is_eeprom_valid(struct ath_regulatory *reg)
 	if (rd & COUNTRY_ERD_FLAG) {
 		/* EEPROM value is a country code */
 		u16 cc = rd & ~COUNTRY_ERD_FLAG;
+		printk(KERN_DEBUG
+		       "ath: EEPROM indicates we should expect "
+			"a country code\n");
 		for (i = 0; i < ARRAY_SIZE(allCountries); i++)
 			if (allCountries[i].countryCode == cc)
 				return true;
 	} else {
 		/* EEPROM value is a regpair value */
+		if (rd != CTRY_DEFAULT)
+			printk(KERN_DEBUG "ath: EEPROM indicates we "
+			       "should expect a direct regpair map\n");
 		for (i = 0; i < ARRAY_SIZE(regDomainPairs); i++)
 			if (regDomainPairs[i].regDmnEnum == rd)
 				return true;
@@ -477,6 +483,11 @@ ath_regd_init(struct ath_regulatory *reg,
 	struct country_code_to_enum_rd *country = NULL;
 	u16 regdmn;
 
+	if (!reg)
+		return -EINVAL;
+
+	printk(KERN_DEBUG "ath: EEPROM regdomain: 0x%0x\n", reg->current_rd);
+
 	if (!ath_regd_is_eeprom_valid(reg)) {
 		printk(KERN_ERR "ath: Invalid EEPROM contents\n");
 		return -EINVAL;
@@ -486,20 +497,30 @@ ath_regd_init(struct ath_regulatory *reg,
 	reg->country_code = ath_regd_get_default_country(regdmn);
 
 	if (reg->country_code == CTRY_DEFAULT &&
-	    regdmn == CTRY_DEFAULT)
+	    regdmn == CTRY_DEFAULT) {
+		printk(KERN_DEBUG "ath: EEPROM indicates default "
+		       "country code should be used\n");
 		reg->country_code = CTRY_UNITED_STATES;
+	}
 
 	if (reg->country_code == CTRY_DEFAULT) {
 		country = NULL;
 	} else {
+		printk(KERN_DEBUG "ath: doing EEPROM country->regdmn "
+		       "map search\n");
 		country = ath_regd_find_country(reg->country_code);
 		if (country == NULL) {
 			printk(KERN_DEBUG
-				"ath: Country is NULL!!!!, cc= %d\n",
+				"ath: no valid country maps found for "
+				"country code: 0x%0x\n",
 				reg->country_code);
 			return -EINVAL;
-		} else
+		} else {
 			regdmn = country->regDmnEnum;
+			printk(KERN_DEBUG "ath: country maps to "
+			       "regdmn code: 0x%0x\n",
+			       regdmn);
+		}
 	}
 
 	reg->regpair = ath_get_regpair(regdmn);
@@ -523,7 +544,7 @@ ath_regd_init(struct ath_regulatory *reg,
 
 	printk(KERN_DEBUG "ath: Country alpha2 being used: %c%c\n",
 		reg->alpha2[0], reg->alpha2[1]);
-	printk(KERN_DEBUG "ath: Regpair detected: 0x%0x\n",
+	printk(KERN_DEBUG "ath: Regpair used: 0x%0x\n",
 		reg->regpair->regDmnEnum);
 
 	ath_regd_init_wiphy(reg, wiphy, reg_notifier);

commit 038659e7c6b385065cb223872771ac437ef70b62
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Sat May 2 00:37:17 2009 -0400

    cfg80211: Process regulatory max bandwidth checks for HT40
    
    We are not correctly listening to the regulatory max bandwidth
    settings. To actually make use of it we need to redesign things
    a bit. This patch does the work for that. We do this to so we
    can obey to regulatory rules accordingly for use of HT40.
    
    We end up dealing with HT40 by having two passes for each channel.
    
    The first check will see if a 20 MHz channel fits into the channel's
    center freq on a given frequency range. We check for a 20 MHz
    banwidth channel as that is the maximum an individual channel
    will use, at least for now. The first pass will go ahead and
    check if the regulatory rule for that given center of frequency
    allows 40 MHz bandwidths and we use this to determine whether
    or not the channel supports HT40 or not. So to support HT40 you'll
    need at a regulatory rule that allows you to use 40 MHz channels
    but you're channel must also be enabled and support 20 MHz by itself.
    
    The second pass is done after we do the regulatory checks over
    an device's supported channel list. On each channel we'll check
    if the control channel and the extension both:
    
     o exist
     o are enabled
     o regulatory allows 40 MHz bandwidth on its frequency range
    
    This work allows allows us to idependently check for HT40- and
    HT40+.
    
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index fdf07c822081..7a89f9fac7d4 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -200,8 +200,10 @@ ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
 				continue;
 
 			if (initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE) {
-				r = freq_reg_info(wiphy, ch->center_freq,
-					&bandwidth, &reg_rule);
+				r = freq_reg_info(wiphy,
+						  ch->center_freq,
+						  bandwidth,
+						  &reg_rule);
 				if (r)
 					continue;
 				/*
@@ -265,7 +267,7 @@ ath_reg_apply_active_scan_flags(struct wiphy *wiphy,
 	 */
 
 	ch = &sband->channels[11]; /* CH 12 */
-	r = freq_reg_info(wiphy, ch->center_freq, &bandwidth, &reg_rule);
+	r = freq_reg_info(wiphy, ch->center_freq, bandwidth, &reg_rule);
 	if (!r) {
 		if (!(reg_rule->flags & NL80211_RRF_PASSIVE_SCAN))
 			if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
@@ -273,7 +275,7 @@ ath_reg_apply_active_scan_flags(struct wiphy *wiphy,
 	}
 
 	ch = &sband->channels[12]; /* CH 13 */
-	r = freq_reg_info(wiphy, ch->center_freq, &bandwidth, &reg_rule);
+	r = freq_reg_info(wiphy, ch->center_freq, bandwidth, &reg_rule);
 	if (!r) {
 		if (!(reg_rule->flags & NL80211_RRF_PASSIVE_SCAN))
 			if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)

commit d323655372590c533c275b1d798f9d1221efb5c6
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Mon Apr 20 14:31:42 2009 +0200

    cfg80211: clean up includes
    
    Trying to separate header files into net/wireless.h and
    net/cfg80211.h has been a source of confusion. Remove
    net/wireless.h (because there also is the linux/wireless.h)
    and subsume everything into net/cfg80211.h -- except the
    definitions for regulatory structures which get moved to
    a new header net/regulatory.h.
    
    The "new" net/cfg80211.h is now divided into sections.
    
    There are no real changes in this patch but code shuffling
    and some very minor documentation fixes.
    
    I have also, to make things reflect reality, put in a
    copyright line for Luis to net/regulatory.h since that
    is probably exclusively written by him but was formerly
    in a file that only had my copyright line.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Cc: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 526c7f1308db..fdf07c822081 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -18,7 +18,6 @@
 #include <linux/slab.h>
 #include <net/cfg80211.h>
 #include <net/mac80211.h>
-#include <net/wireless.h>
 #include "regd.h"
 #include "regd_common.h"
 

commit 85efc86eb7c6cbb1c8ce8d99b10b948be033fbb9
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Mon Apr 13 21:41:46 2009 -0400

    atheros: fix propagation of bad EEPROM on regulatory init
    
    When the EEPROM is not in good condition we cannot continue so
    we currently bail out but only ath5k is bailing out properly.
    Both ath9k and ar9170 were proceeding and if a user were to run
    into this they'd see an obscure panic. Lets propagate the error
    as intended and make sure we inform the user by lifting the
    error message from debug to a kernel error.
    
    Stable note: You can find a port of this page here:
    
    http://bombadil.infradead.org/~mcgrof/patches/ath9k/ath9k-fix-eeprom.patch.txt
    
    Cc: stable@kernel.org
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 4b5c851b81ff..526c7f1308db 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -477,7 +477,7 @@ ath_regd_init(struct ath_regulatory *reg,
 	u16 regdmn;
 
 	if (!ath_regd_is_eeprom_valid(reg)) {
-		printk(KERN_DEBUG "ath: Invalid EEPROM contents\n");
+		printk(KERN_ERR "ath: Invalid EEPROM contents\n");
 		return -EINVAL;
 	}
 

commit 6b2b2ffbef7750e51bfa74e92229ecee10b59307
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Mon Mar 30 22:30:34 2009 -0400

    ath: space cleanup
    
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 3ccf21cceb5a..4b5c851b81ff 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -173,9 +173,9 @@ static bool ath_is_radar_freq(u16 center_freq)
  *   received a beacon on a channel we can enable active scan and
  *   adhoc (or beaconing).
  */
-static void ath_reg_apply_beaconing_flags(
-	struct wiphy *wiphy,
-	enum nl80211_reg_initiator initiator)
+static void
+ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
+			      enum nl80211_reg_initiator initiator)
 {
 	enum ieee80211_band band;
 	struct ieee80211_supported_band *sband;
@@ -232,9 +232,9 @@ static void ath_reg_apply_beaconing_flags(
 }
 
 /* Allows active scan scan on Ch 12 and 13 */
-static void ath_reg_apply_active_scan_flags(
-	struct wiphy *wiphy,
-	enum nl80211_reg_initiator initiator)
+static void
+ath_reg_apply_active_scan_flags(struct wiphy *wiphy,
+				enum nl80211_reg_initiator initiator)
 {
 	struct ieee80211_supported_band *sband;
 	struct ieee80211_channel *ch;
@@ -316,8 +316,8 @@ static void ath_reg_apply_radar_flags(struct wiphy *wiphy)
 }
 
 static void ath_reg_apply_world_flags(struct wiphy *wiphy,
-				 enum nl80211_reg_initiator initiator,
-				 struct ath_regulatory *reg)
+				      enum nl80211_reg_initiator initiator,
+				      struct ath_regulatory *reg)
 {
 	switch (reg->regpair->regDmnEnum) {
 	case 0x60:
@@ -335,7 +335,8 @@ static void ath_reg_apply_world_flags(struct wiphy *wiphy,
 }
 
 int ath_reg_notifier_apply(struct wiphy *wiphy,
-	struct regulatory_request *request, struct ath_regulatory *reg)
+			   struct regulatory_request *request,
+			   struct ath_regulatory *reg)
 {
 	/* We always apply this */
 	ath_reg_apply_radar_flags(wiphy);
@@ -433,8 +434,10 @@ ath_get_regpair(int regdmn)
 	return NULL;
 }
 
-static int ath_regd_init_wiphy(struct ath_regulatory *reg, struct wiphy *wiphy,
-			       int (*reg_notifier)(struct wiphy *wiphy,
+static int
+ath_regd_init_wiphy(struct ath_regulatory *reg,
+		    struct wiphy *wiphy,
+		    int (*reg_notifier)(struct wiphy *wiphy,
 					struct regulatory_request *request))
 {
 	const struct ieee80211_regdomain *regd;
@@ -464,9 +467,11 @@ static int ath_regd_init_wiphy(struct ath_regulatory *reg, struct wiphy *wiphy,
 	return 0;
 }
 
-int ath_regd_init(struct ath_regulatory *reg, struct wiphy *wiphy,
-		  int (*reg_notifier)(struct wiphy *wiphy,
-			    struct regulatory_request *request))
+int
+ath_regd_init(struct ath_regulatory *reg,
+	      struct wiphy *wiphy,
+	      int (*reg_notifier)(struct wiphy *wiphy,
+				  struct regulatory_request *request))
 {
 	struct country_code_to_enum_rd *country = NULL;
 	u16 regdmn;

commit e3bb249be89dd387e78ca382d08fad31745edac9
Author: Bob Copeland <me@bobcopeland.com>
Date:   Mon Mar 30 22:30:30 2009 -0400

    ath: move more setup code into ath_regd_init
    
    Setup the wiphy regulatory parameters when first initializing the
    Atheros regulatory module.  We can remove five exported symbols this
    way and simplify the driver code for both ath5k and ath9k.
    
    Signed-off-by: Bob Copeland <me@bobcopeland.com>
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 4d3935b6fbdd..3ccf21cceb5a 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -126,14 +126,13 @@ bool ath_is_world_regd(struct ath_regulatory *reg)
 }
 EXPORT_SYMBOL(ath_is_world_regd);
 
-const struct ieee80211_regdomain *ath_default_world_regdomain(void)
+static const struct ieee80211_regdomain *ath_default_world_regdomain(void)
 {
 	/* this is the most restrictive */
 	return &ath_world_regdom_64;
 }
-EXPORT_SYMBOL(ath_default_world_regdomain);
 
-const struct
+static const struct
 ieee80211_regdomain *ath_world_regdomain(struct ath_regulatory *reg)
 {
 	switch (reg->regpair->regDmnEnum) {
@@ -158,7 +157,6 @@ ieee80211_regdomain *ath_world_regdomain(struct ath_regulatory *reg)
 		return ath_default_world_regdomain();
 	}
 }
-EXPORT_SYMBOL(ath_world_regdomain);
 
 /* Frequency is one where radar detection is required */
 static bool ath_is_radar_freq(u16 center_freq)
@@ -285,7 +283,7 @@ static void ath_reg_apply_active_scan_flags(
 }
 
 /* Always apply Radar/DFS rules on freq range 5260 MHz - 5700 MHz */
-void ath_reg_apply_radar_flags(struct wiphy *wiphy)
+static void ath_reg_apply_radar_flags(struct wiphy *wiphy)
 {
 	struct ieee80211_supported_band *sband;
 	struct ieee80211_channel *ch;
@@ -316,11 +314,10 @@ void ath_reg_apply_radar_flags(struct wiphy *wiphy)
 				     IEEE80211_CHAN_PASSIVE_SCAN;
 	}
 }
-EXPORT_SYMBOL(ath_reg_apply_radar_flags);
 
-void ath_reg_apply_world_flags(struct wiphy *wiphy,
-			       enum nl80211_reg_initiator initiator,
-			       struct ath_regulatory *reg)
+static void ath_reg_apply_world_flags(struct wiphy *wiphy,
+				 enum nl80211_reg_initiator initiator,
+				 struct ath_regulatory *reg)
 {
 	switch (reg->regpair->regDmnEnum) {
 	case 0x60:
@@ -336,7 +333,6 @@ void ath_reg_apply_world_flags(struct wiphy *wiphy,
 	}
 	return;
 }
-EXPORT_SYMBOL(ath_reg_apply_world_flags);
 
 int ath_reg_notifier_apply(struct wiphy *wiphy,
 	struct regulatory_request *request, struct ath_regulatory *reg)
@@ -360,7 +356,7 @@ int ath_reg_notifier_apply(struct wiphy *wiphy,
 }
 EXPORT_SYMBOL(ath_reg_notifier_apply);
 
-bool ath_regd_is_eeprom_valid(struct ath_regulatory *reg)
+static bool ath_regd_is_eeprom_valid(struct ath_regulatory *reg)
 {
 	 u16 rd = ath_regd_get_eepromRD(reg);
 	int i;
@@ -381,7 +377,6 @@ bool ath_regd_is_eeprom_valid(struct ath_regulatory *reg)
 		 "ath: invalid regulatory domain/country code 0x%x\n", rd);
 	return false;
 }
-EXPORT_SYMBOL(ath_regd_is_eeprom_valid);
 
 /* EEPROM country code to regpair mapping */
 static struct country_code_to_enum_rd*
@@ -438,7 +433,40 @@ ath_get_regpair(int regdmn)
 	return NULL;
 }
 
-int ath_regd_init(struct ath_regulatory *reg)
+static int ath_regd_init_wiphy(struct ath_regulatory *reg, struct wiphy *wiphy,
+			       int (*reg_notifier)(struct wiphy *wiphy,
+					struct regulatory_request *request))
+{
+	const struct ieee80211_regdomain *regd;
+
+	wiphy->reg_notifier = reg_notifier;
+	wiphy->strict_regulatory = true;
+
+	if (ath_is_world_regd(reg)) {
+		/*
+		 * Anything applied here (prior to wiphy registration) gets
+		 * saved on the wiphy orig_* parameters
+		 */
+		regd = ath_world_regdomain(reg);
+		wiphy->custom_regulatory = true;
+		wiphy->strict_regulatory = false;
+	} else {
+		/*
+		 * This gets applied in the case of the absense of CRDA,
+		 * it's our own custom world regulatory domain, similar to
+		 * cfg80211's but we enable passive scanning.
+		 */
+		regd = ath_default_world_regdomain();
+	}
+	wiphy_apply_custom_regulatory(wiphy, regd);
+	ath_reg_apply_radar_flags(wiphy);
+	ath_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER, reg);
+	return 0;
+}
+
+int ath_regd_init(struct ath_regulatory *reg, struct wiphy *wiphy,
+		  int (*reg_notifier)(struct wiphy *wiphy,
+			    struct regulatory_request *request))
 {
 	struct country_code_to_enum_rd *country = NULL;
 	u16 regdmn;
@@ -492,6 +520,7 @@ int ath_regd_init(struct ath_regulatory *reg)
 	printk(KERN_DEBUG "ath: Regpair detected: 0x%0x\n",
 		reg->regpair->regDmnEnum);
 
+	ath_regd_init_wiphy(reg, wiphy, reg_notifier);
 	return 0;
 }
 EXPORT_SYMBOL(ath_regd_init);

commit 3a702e49c03ba959e3f5bb2b74ec9921a81c8c98
Author: Bob Copeland <me@bobcopeland.com>
Date:   Mon Mar 30 22:30:29 2009 -0400

    atheros: introduce ath module containing common ath5k/ath9k/ar9170 code
    
    This change creates a new module, ath.ko, which includes code that can
    be shared between ath5k, ath9k and ar9170. For now, extract most of the ath9k
    regulatory code so it can also be used in ath5k.
    
    Signed-off-by: Bob Copeland <me@bobcopeland.com>
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
new file mode 100644
index 000000000000..4d3935b6fbdd
--- /dev/null
+++ b/drivers/net/wireless/ath/regd.c
@@ -0,0 +1,519 @@
+/*
+ * Copyright (c) 2008-2009 Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <net/cfg80211.h>
+#include <net/mac80211.h>
+#include <net/wireless.h>
+#include "regd.h"
+#include "regd_common.h"
+
+/*
+ * This is a set of common rules used by our world regulatory domains.
+ * We have 12 world regulatory domains. To save space we consolidate
+ * the regulatory domains in 5 structures by frequency and change
+ * the flags on our reg_notifier() on a case by case basis.
+ */
+
+/* Only these channels all allow active scan on all world regulatory domains */
+#define ATH9K_2GHZ_CH01_11	REG_RULE(2412-10, 2462+10, 40, 0, 20, 0)
+
+/* We enable active scan on these a case by case basis by regulatory domain */
+#define ATH9K_2GHZ_CH12_13	REG_RULE(2467-10, 2472+10, 40, 0, 20,\
+					NL80211_RRF_PASSIVE_SCAN)
+#define ATH9K_2GHZ_CH14		REG_RULE(2484-10, 2484+10, 40, 0, 20,\
+				NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_OFDM)
+
+/* We allow IBSS on these on a case by case basis by regulatory domain */
+#define ATH9K_5GHZ_5150_5350	REG_RULE(5150-10, 5350+10, 40, 0, 30,\
+				NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
+#define ATH9K_5GHZ_5470_5850	REG_RULE(5470-10, 5850+10, 40, 0, 30,\
+				NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
+#define ATH9K_5GHZ_5725_5850	REG_RULE(5725-10, 5850+10, 40, 0, 30,\
+				NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
+
+#define ATH9K_2GHZ_ALL		ATH9K_2GHZ_CH01_11, \
+				ATH9K_2GHZ_CH12_13, \
+				ATH9K_2GHZ_CH14
+
+#define ATH9K_5GHZ_ALL		ATH9K_5GHZ_5150_5350, \
+				ATH9K_5GHZ_5470_5850
+/* This one skips what we call "mid band" */
+#define ATH9K_5GHZ_NO_MIDBAND	ATH9K_5GHZ_5150_5350, \
+				ATH9K_5GHZ_5725_5850
+
+/* Can be used for:
+ * 0x60, 0x61, 0x62 */
+static const struct ieee80211_regdomain ath_world_regdom_60_61_62 = {
+	.n_reg_rules = 5,
+	.alpha2 =  "99",
+	.reg_rules = {
+		ATH9K_2GHZ_ALL,
+		ATH9K_5GHZ_ALL,
+	}
+};
+
+/* Can be used by 0x63 and 0x65 */
+static const struct ieee80211_regdomain ath_world_regdom_63_65 = {
+	.n_reg_rules = 4,
+	.alpha2 =  "99",
+	.reg_rules = {
+		ATH9K_2GHZ_CH01_11,
+		ATH9K_2GHZ_CH12_13,
+		ATH9K_5GHZ_NO_MIDBAND,
+	}
+};
+
+/* Can be used by 0x64 only */
+static const struct ieee80211_regdomain ath_world_regdom_64 = {
+	.n_reg_rules = 3,
+	.alpha2 =  "99",
+	.reg_rules = {
+		ATH9K_2GHZ_CH01_11,
+		ATH9K_5GHZ_NO_MIDBAND,
+	}
+};
+
+/* Can be used by 0x66 and 0x69 */
+static const struct ieee80211_regdomain ath_world_regdom_66_69 = {
+	.n_reg_rules = 3,
+	.alpha2 =  "99",
+	.reg_rules = {
+		ATH9K_2GHZ_CH01_11,
+		ATH9K_5GHZ_ALL,
+	}
+};
+
+/* Can be used by 0x67, 0x6A and 0x68 */
+static const struct ieee80211_regdomain ath_world_regdom_67_68_6A = {
+	.n_reg_rules = 4,
+	.alpha2 =  "99",
+	.reg_rules = {
+		ATH9K_2GHZ_CH01_11,
+		ATH9K_2GHZ_CH12_13,
+		ATH9K_5GHZ_ALL,
+	}
+};
+
+static inline bool is_wwr_sku(u16 regd)
+{
+	return ((regd & WORLD_SKU_MASK) == WORLD_SKU_PREFIX) ||
+		(regd == WORLD);
+}
+
+static u16 ath_regd_get_eepromRD(struct ath_regulatory *reg)
+{
+	return reg->current_rd & ~WORLDWIDE_ROAMING_FLAG;
+}
+
+bool ath_is_world_regd(struct ath_regulatory *reg)
+{
+	return is_wwr_sku(ath_regd_get_eepromRD(reg));
+}
+EXPORT_SYMBOL(ath_is_world_regd);
+
+const struct ieee80211_regdomain *ath_default_world_regdomain(void)
+{
+	/* this is the most restrictive */
+	return &ath_world_regdom_64;
+}
+EXPORT_SYMBOL(ath_default_world_regdomain);
+
+const struct
+ieee80211_regdomain *ath_world_regdomain(struct ath_regulatory *reg)
+{
+	switch (reg->regpair->regDmnEnum) {
+	case 0x60:
+	case 0x61:
+	case 0x62:
+		return &ath_world_regdom_60_61_62;
+	case 0x63:
+	case 0x65:
+		return &ath_world_regdom_63_65;
+	case 0x64:
+		return &ath_world_regdom_64;
+	case 0x66:
+	case 0x69:
+		return &ath_world_regdom_66_69;
+	case 0x67:
+	case 0x68:
+	case 0x6A:
+		return &ath_world_regdom_67_68_6A;
+	default:
+		WARN_ON(1);
+		return ath_default_world_regdomain();
+	}
+}
+EXPORT_SYMBOL(ath_world_regdomain);
+
+/* Frequency is one where radar detection is required */
+static bool ath_is_radar_freq(u16 center_freq)
+{
+	return (center_freq >= 5260 && center_freq <= 5700);
+}
+
+/*
+ * N.B: These exception rules do not apply radar freqs.
+ *
+ * - We enable adhoc (or beaconing) if allowed by 11d
+ * - We enable active scan if the channel is allowed by 11d
+ * - If no country IE has been processed and a we determine we have
+ *   received a beacon on a channel we can enable active scan and
+ *   adhoc (or beaconing).
+ */
+static void ath_reg_apply_beaconing_flags(
+	struct wiphy *wiphy,
+	enum nl80211_reg_initiator initiator)
+{
+	enum ieee80211_band band;
+	struct ieee80211_supported_band *sband;
+	const struct ieee80211_reg_rule *reg_rule;
+	struct ieee80211_channel *ch;
+	unsigned int i;
+	u32 bandwidth = 0;
+	int r;
+
+	for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
+
+		if (!wiphy->bands[band])
+			continue;
+
+		sband = wiphy->bands[band];
+
+		for (i = 0; i < sband->n_channels; i++) {
+
+			ch = &sband->channels[i];
+
+			if (ath_is_radar_freq(ch->center_freq) ||
+			    (ch->flags & IEEE80211_CHAN_RADAR))
+				continue;
+
+			if (initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE) {
+				r = freq_reg_info(wiphy, ch->center_freq,
+					&bandwidth, &reg_rule);
+				if (r)
+					continue;
+				/*
+				 * If 11d had a rule for this channel ensure
+				 * we enable adhoc/beaconing if it allows us to
+				 * use it. Note that we would have disabled it
+				 * by applying our static world regdomain by
+				 * default during init, prior to calling our
+				 * regulatory_hint().
+				 */
+				if (!(reg_rule->flags &
+				    NL80211_RRF_NO_IBSS))
+					ch->flags &=
+					  ~IEEE80211_CHAN_NO_IBSS;
+				if (!(reg_rule->flags &
+				    NL80211_RRF_PASSIVE_SCAN))
+					ch->flags &=
+					  ~IEEE80211_CHAN_PASSIVE_SCAN;
+			} else {
+				if (ch->beacon_found)
+					ch->flags &= ~(IEEE80211_CHAN_NO_IBSS |
+					  IEEE80211_CHAN_PASSIVE_SCAN);
+			}
+		}
+	}
+
+}
+
+/* Allows active scan scan on Ch 12 and 13 */
+static void ath_reg_apply_active_scan_flags(
+	struct wiphy *wiphy,
+	enum nl80211_reg_initiator initiator)
+{
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_channel *ch;
+	const struct ieee80211_reg_rule *reg_rule;
+	u32 bandwidth = 0;
+	int r;
+
+	sband = wiphy->bands[IEEE80211_BAND_2GHZ];
+
+	/*
+	 * If no country IE has been received always enable active scan
+	 * on these channels. This is only done for specific regulatory SKUs
+	 */
+	if (initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE) {
+		ch = &sband->channels[11]; /* CH 12 */
+		if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
+			ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
+		ch = &sband->channels[12]; /* CH 13 */
+		if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
+			ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
+		return;
+	}
+
+	/*
+	 * If a country IE has been recieved check its rule for this
+	 * channel first before enabling active scan. The passive scan
+	 * would have been enforced by the initial processing of our
+	 * custom regulatory domain.
+	 */
+
+	ch = &sband->channels[11]; /* CH 12 */
+	r = freq_reg_info(wiphy, ch->center_freq, &bandwidth, &reg_rule);
+	if (!r) {
+		if (!(reg_rule->flags & NL80211_RRF_PASSIVE_SCAN))
+			if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
+				ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
+	}
+
+	ch = &sband->channels[12]; /* CH 13 */
+	r = freq_reg_info(wiphy, ch->center_freq, &bandwidth, &reg_rule);
+	if (!r) {
+		if (!(reg_rule->flags & NL80211_RRF_PASSIVE_SCAN))
+			if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
+				ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
+	}
+}
+
+/* Always apply Radar/DFS rules on freq range 5260 MHz - 5700 MHz */
+void ath_reg_apply_radar_flags(struct wiphy *wiphy)
+{
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_channel *ch;
+	unsigned int i;
+
+	if (!wiphy->bands[IEEE80211_BAND_5GHZ])
+		return;
+
+	sband = wiphy->bands[IEEE80211_BAND_5GHZ];
+
+	for (i = 0; i < sband->n_channels; i++) {
+		ch = &sband->channels[i];
+		if (!ath_is_radar_freq(ch->center_freq))
+			continue;
+		/* We always enable radar detection/DFS on this
+		 * frequency range. Additionally we also apply on
+		 * this frequency range:
+		 * - If STA mode does not yet have DFS supports disable
+		 *   active scanning
+		 * - If adhoc mode does not support DFS yet then
+		 *   disable adhoc in the frequency.
+		 * - If AP mode does not yet support radar detection/DFS
+		 *   do not allow AP mode
+		 */
+		if (!(ch->flags & IEEE80211_CHAN_DISABLED))
+			ch->flags |= IEEE80211_CHAN_RADAR |
+				     IEEE80211_CHAN_NO_IBSS |
+				     IEEE80211_CHAN_PASSIVE_SCAN;
+	}
+}
+EXPORT_SYMBOL(ath_reg_apply_radar_flags);
+
+void ath_reg_apply_world_flags(struct wiphy *wiphy,
+			       enum nl80211_reg_initiator initiator,
+			       struct ath_regulatory *reg)
+{
+	switch (reg->regpair->regDmnEnum) {
+	case 0x60:
+	case 0x63:
+	case 0x66:
+	case 0x67:
+		ath_reg_apply_beaconing_flags(wiphy, initiator);
+		break;
+	case 0x68:
+		ath_reg_apply_beaconing_flags(wiphy, initiator);
+		ath_reg_apply_active_scan_flags(wiphy, initiator);
+		break;
+	}
+	return;
+}
+EXPORT_SYMBOL(ath_reg_apply_world_flags);
+
+int ath_reg_notifier_apply(struct wiphy *wiphy,
+	struct regulatory_request *request, struct ath_regulatory *reg)
+{
+	/* We always apply this */
+	ath_reg_apply_radar_flags(wiphy);
+
+	switch (request->initiator) {
+	case NL80211_REGDOM_SET_BY_DRIVER:
+	case NL80211_REGDOM_SET_BY_CORE:
+	case NL80211_REGDOM_SET_BY_USER:
+		break;
+	case NL80211_REGDOM_SET_BY_COUNTRY_IE:
+		if (ath_is_world_regd(reg))
+			ath_reg_apply_world_flags(wiphy, request->initiator,
+						  reg);
+		break;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(ath_reg_notifier_apply);
+
+bool ath_regd_is_eeprom_valid(struct ath_regulatory *reg)
+{
+	 u16 rd = ath_regd_get_eepromRD(reg);
+	int i;
+
+	if (rd & COUNTRY_ERD_FLAG) {
+		/* EEPROM value is a country code */
+		u16 cc = rd & ~COUNTRY_ERD_FLAG;
+		for (i = 0; i < ARRAY_SIZE(allCountries); i++)
+			if (allCountries[i].countryCode == cc)
+				return true;
+	} else {
+		/* EEPROM value is a regpair value */
+		for (i = 0; i < ARRAY_SIZE(regDomainPairs); i++)
+			if (regDomainPairs[i].regDmnEnum == rd)
+				return true;
+	}
+	printk(KERN_DEBUG
+		 "ath: invalid regulatory domain/country code 0x%x\n", rd);
+	return false;
+}
+EXPORT_SYMBOL(ath_regd_is_eeprom_valid);
+
+/* EEPROM country code to regpair mapping */
+static struct country_code_to_enum_rd*
+ath_regd_find_country(u16 countryCode)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(allCountries); i++) {
+		if (allCountries[i].countryCode == countryCode)
+			return &allCountries[i];
+	}
+	return NULL;
+}
+
+/* EEPROM rd code to regpair mapping */
+static struct country_code_to_enum_rd*
+ath_regd_find_country_by_rd(int regdmn)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(allCountries); i++) {
+		if (allCountries[i].regDmnEnum == regdmn)
+			return &allCountries[i];
+	}
+	return NULL;
+}
+
+/* Returns the map of the EEPROM set RD to a country code */
+static u16 ath_regd_get_default_country(u16 rd)
+{
+	if (rd & COUNTRY_ERD_FLAG) {
+		struct country_code_to_enum_rd *country = NULL;
+		u16 cc = rd & ~COUNTRY_ERD_FLAG;
+
+		country = ath_regd_find_country(cc);
+		if (country != NULL)
+			return cc;
+	}
+
+	return CTRY_DEFAULT;
+}
+
+static struct reg_dmn_pair_mapping*
+ath_get_regpair(int regdmn)
+{
+	int i;
+
+	if (regdmn == NO_ENUMRD)
+		return NULL;
+	for (i = 0; i < ARRAY_SIZE(regDomainPairs); i++) {
+		if (regDomainPairs[i].regDmnEnum == regdmn)
+			return &regDomainPairs[i];
+	}
+	return NULL;
+}
+
+int ath_regd_init(struct ath_regulatory *reg)
+{
+	struct country_code_to_enum_rd *country = NULL;
+	u16 regdmn;
+
+	if (!ath_regd_is_eeprom_valid(reg)) {
+		printk(KERN_DEBUG "ath: Invalid EEPROM contents\n");
+		return -EINVAL;
+	}
+
+	regdmn = ath_regd_get_eepromRD(reg);
+	reg->country_code = ath_regd_get_default_country(regdmn);
+
+	if (reg->country_code == CTRY_DEFAULT &&
+	    regdmn == CTRY_DEFAULT)
+		reg->country_code = CTRY_UNITED_STATES;
+
+	if (reg->country_code == CTRY_DEFAULT) {
+		country = NULL;
+	} else {
+		country = ath_regd_find_country(reg->country_code);
+		if (country == NULL) {
+			printk(KERN_DEBUG
+				"ath: Country is NULL!!!!, cc= %d\n",
+				reg->country_code);
+			return -EINVAL;
+		} else
+			regdmn = country->regDmnEnum;
+	}
+
+	reg->regpair = ath_get_regpair(regdmn);
+
+	if (!reg->regpair) {
+		printk(KERN_DEBUG "ath: "
+			"No regulatory domain pair found, cannot continue\n");
+		return -EINVAL;
+	}
+
+	if (!country)
+		country = ath_regd_find_country_by_rd(regdmn);
+
+	if (country) {
+		reg->alpha2[0] = country->isoName[0];
+		reg->alpha2[1] = country->isoName[1];
+	} else {
+		reg->alpha2[0] = '0';
+		reg->alpha2[1] = '0';
+	}
+
+	printk(KERN_DEBUG "ath: Country alpha2 being used: %c%c\n",
+		reg->alpha2[0], reg->alpha2[1]);
+	printk(KERN_DEBUG "ath: Regpair detected: 0x%0x\n",
+		reg->regpair->regDmnEnum);
+
+	return 0;
+}
+EXPORT_SYMBOL(ath_regd_init);
+
+u32 ath_regd_get_band_ctl(struct ath_regulatory *reg,
+			  enum ieee80211_band band)
+{
+	if (!reg->regpair ||
+	    (reg->country_code == CTRY_DEFAULT &&
+	     is_wwr_sku(ath_regd_get_eepromRD(reg)))) {
+		return SD_NO_CTL;
+	}
+
+	switch (band) {
+	case IEEE80211_BAND_2GHZ:
+		return reg->regpair->reg_2ghz_ctl;
+	case IEEE80211_BAND_5GHZ:
+		return reg->regpair->reg_5ghz_ctl;
+	default:
+		return NO_CTL;
+	}
+
+	return NO_CTL;
+}
+EXPORT_SYMBOL(ath_regd_get_band_ctl);
