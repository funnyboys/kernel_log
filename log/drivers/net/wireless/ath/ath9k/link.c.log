commit 7ac767645ab1f2f96b2c84ee8857d72d25c4eadd
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Oct 24 02:29:54 2017 -0700

    ath: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Cc: Kalle Valo <kvalo@qca.qualcomm.com>
    Cc: linux-wireless@vger.kernel.org
    Cc: netdev@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index 3f4f01c829f0..9d84003db800 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -301,11 +301,11 @@ void ath_paprd_calibrate(struct work_struct *work)
  *  When the task is complete, it reschedules itself depending on the
  *  appropriate interval that was calculated.
  */
-void ath_ani_calibrate(unsigned long data)
+void ath_ani_calibrate(struct timer_list *t)
 {
-	struct ath_softc *sc = (struct ath_softc *)data;
+	struct ath_common *common = from_timer(common, t, ani.timer);
+	struct ath_softc *sc = (struct ath_softc *)common->priv;
 	struct ath_hw *ah = sc->sc_ah;
-	struct ath_common *common = ath9k_hw_common(ah);
 	bool longcal = false;
 	bool shortcal = false;
 	bool aniflag = false;

commit ba24d63dd3748bae134365e3bcfd9c13b4e3c3e4
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Mon Sep 18 22:59:19 2017 +0300

    ath9k: Avoid a potential deadlock
    
    Lockdep warns us that sc_pm_lock and cc_lock can cause a deadlock when
    cc_lock is acquired by itself with interrupts enabled. Disable irqs
    whenever taking cc_lock to avoid this.
    
    [   19.094524] kworker/u2:0/5 just changed the state of lock:
    [   19.094578]  (&(&sc->sc_pm_lock)->rlock){-.-...}, at: [<f836c00e>] ath_isr+0x15e/0x200 [ath9k]
    [   19.094674] but this lock took another, HARDIRQ-unsafe lock in the past:
    [   19.094731]  (&(&common->cc_lock)->rlock){+.-...}
    [   19.094741]
    
                   and interrupts could create inverse lock ordering between them.
    
    [   19.094866]
                   other info that might help us debug this:
    [   19.094926]  Possible interrupt unsafe locking scenario:
    
    [   19.094985]        CPU0                    CPU1
    [   19.095036]        ----                    ----
    [   19.095086]   lock(&(&common->cc_lock)->rlock);
    [   19.095197]                                local_irq_disable();
    [   19.095305]                                lock(&(&sc->sc_pm_lock)->rlock);
    [   19.095423]                                lock(&(&common->cc_lock)->rlock);
    [   19.095539]   <Interrupt>
    [   19.095636]     lock(&(&sc->sc_pm_lock)->rlock);
    [   19.095745]
                    *** DEADLOCK ***
    
    [   19.095965] 3 locks held by kworker/u2:0/5:
    [   19.096067]  #0:  ("%s"wiphy_name(local->hw.wiphy)){.+.+.+}, at: [<c1067f37>] process_one_work+0x127/0x580
    [   19.096260]  #1:  ((&local->dynamic_ps_enable_work)){+.+...}, at: [<c1067f37>] process_one_work+0x127/0x580
    [   19.096447]  #2:  (&sc->mutex){+.+...}, at: [<f836b8b0>] ath9k_config+0x30/0x1d0 [ath9k]
    [   19.096639]
                   the shortest dependencies between 2nd lock and 1st lock:
    [   19.096813]  -> (&(&common->cc_lock)->rlock){+.-...} ops: 38 {
    [   19.096816]     HARDIRQ-ON-W at:
    [   19.096816]                       __lock_acquire+0x57e/0x1260
    [   19.096816]                       lock_acquire+0xb1/0x1c0
    [   19.096816]                       _raw_spin_lock_bh+0x3f/0x50
    [   19.096816]                       ath_chanctx_set_channel+0xb6/0x2c0 [ath9k]
    [   19.096816]                       ath9k_config+0xa8/0x1d0 [ath9k]
    [   19.096816]                       ieee80211_hw_config+0xa8/0x5f0 [mac80211]
    [   19.096816]                       ieee80211_do_open+0x67a/0x920 [mac80211]
    [   19.096816]                       ieee80211_open+0x41/0x50 [mac80211]
    [   19.096816]                       __dev_open+0xab/0x140
    [   19.096816]                       __dev_change_flags+0x89/0x150
    [   19.096816]                       dev_change_flags+0x28/0x60
    [   19.096816]                       do_setlink+0x290/0x890
    [   19.096816]                       rtnl_newlink+0x7cf/0x8e0
    [   19.096816]                       rtnetlink_rcv_msg+0xbf/0x1f0
    [   19.096816]                       netlink_rcv_skb+0xb9/0xe0
    [   19.096816]                       rtnetlink_rcv+0x1e/0x30
    [   19.096816]                       netlink_unicast+0x13a/0x2c0
    [   19.096816]                       netlink_sendmsg+0x290/0x380
    [   19.096816]                       ___sys_sendmsg+0x1e2/0x280
    [   19.096816]                       __sys_sendmsg+0x3f/0x80
    [   19.096816]                       SyS_socketcall+0x58c/0x6b0
    [   19.096816]                       do_fast_syscall_32+0x96/0x1d0
    [   19.096816]                       entry_SYSENTER_32+0x4c/0x7b
    [   19.096816]     IN-SOFTIRQ-W at:
    [   19.096816]                       __lock_acquire+0x55a/0x1260
    [   19.096816]                       lock_acquire+0xb1/0x1c0
    [   19.096816]                       _raw_spin_lock+0x3c/0x50
    [   19.096816]                       ath_ps_full_sleep+0x24/0x70 [ath9k]
    [   19.096816]                       call_timer_fn+0xa4/0x300
    [   19.096816]                       run_timer_softirq+0x1b1/0x560
    [   19.096816]                       __do_softirq+0xb0/0x430
    [   19.096816]                       do_softirq_own_stack+0x33/0x40
    [   19.096816]                       irq_exit+0xad/0xc0
    [   19.096816]                       smp_apic_timer_interrupt+0x31/0x40
    [   19.096816]                       apic_timer_interrupt+0x37/0x3c
    [   19.096816]                       wp_page_copy+0xb8/0x580
    [   19.096816]                       do_wp_page+0x64/0x420
    [   19.096816]                       handle_mm_fault+0x430/0x990
    [   19.096816]                       __do_page_fault+0x18b/0x430
    [   19.096816]                       do_page_fault+0xb/0x10
    [   19.096816]                       common_exception+0x62/0x6a
    [   19.096816]     INITIAL USE at:
    [   19.096816]                      __lock_acquire+0x204/0x1260
    [   19.096816]                      lock_acquire+0xb1/0x1c0
    [   19.096816]                      _raw_spin_lock_bh+0x3f/0x50
    [   19.096816]                      ath_chanctx_set_channel+0xb6/0x2c0 [ath9k]
    [   19.096816]                      ath9k_config+0xa8/0x1d0 [ath9k]
    [   19.096816]                      ieee80211_hw_config+0xa8/0x5f0 [mac80211]
    [   19.096816]                      ieee80211_do_open+0x67a/0x920 [mac80211]
    [   19.096816]                      ieee80211_open+0x41/0x50 [mac80211]
    [   19.096816]                      __dev_open+0xab/0x140
    [   19.096816]                      __dev_change_flags+0x89/0x150
    [   19.096816]                      dev_change_flags+0x28/0x60
    [   19.096816]                      do_setlink+0x290/0x890
    [   19.096816]                      rtnl_newlink+0x7cf/0x8e0
    [   19.096816]                      rtnetlink_rcv_msg+0xbf/0x1f0
    [   19.096816]                      netlink_rcv_skb+0xb9/0xe0
    [   19.096816]                      rtnetlink_rcv+0x1e/0x30
    [   19.096816]                      netlink_unicast+0x13a/0x2c0
    [   19.096816]                      netlink_sendmsg+0x290/0x380
    [   19.096816]                      ___sys_sendmsg+0x1e2/0x280
    [   19.096816]                      __sys_sendmsg+0x3f/0x80
    [   19.096816]                      SyS_socketcall+0x58c/0x6b0
    [   19.096816]                      do_fast_syscall_32+0x96/0x1d0
    [   19.096816]                      entry_SYSENTER_32+0x4c/0x7b
    [   19.096816]   }
    [   19.096816]   ... key      at: [<f837b694>] __key.61991+0x0/0xffffc96c [ath9k]
    [   19.096816]   ... acquired at:
    [   19.096816]    lock_acquire+0xb1/0x1c0
    [   19.096816]    _raw_spin_lock+0x3c/0x50
    [   19.096816]    ath9k_ps_wakeup+0x85/0xe0 [ath9k]
    [   19.096816]    ath9k_bss_info_changed+0x2a/0x1b0 [ath9k]
    [   19.096816]    ieee80211_bss_info_change_notify+0xf3/0x360 [mac80211]
    [   19.096816]    ieee80211_recalc_txpower+0x33/0x40 [mac80211]
    [   19.096816]    ieee80211_set_tx_power+0x45/0x1d0 [mac80211]
    [   19.096816]    cfg80211_wext_siwtxpower+0xd3/0x350 [cfg80211]
    [   19.096816]    ioctl_standard_call+0x4e/0x400
    [   19.096816]    wext_handle_ioctl+0xf4/0x190
    [   19.096816]    dev_ioctl+0xb7/0x630
    [   19.096816]    sock_ioctl+0x13e/0x2d0
    [   19.096816]    do_vfs_ioctl+0x84/0x750
    [   19.096816]    SyS_ioctl+0x34/0x60
    [   19.096816]    do_fast_syscall_32+0x96/0x1d0
    [   19.096816]    entry_SYSENTER_32+0x4c/0x7b
    
    [   19.096816] -> (&(&sc->sc_pm_lock)->rlock){-.-...} ops: 597 {
    [   19.096816]    IN-HARDIRQ-W at:
    [   19.096816]                     __lock_acquire+0x6ae/0x1260
    [   19.096816]                     lock_acquire+0xb1/0x1c0
    [   19.096816]                     _raw_spin_lock_irqsave+0x45/0x60
    [   19.096816]                     ath_isr+0x15e/0x200 [ath9k]
    [   19.096816]                     __handle_irq_event_percpu+0x44/0x340
    [   19.096816]                     handle_irq_event_percpu+0x1d/0x50
    [   19.096816]                     handle_irq_event+0x32/0x60
    [   19.096816]                     handle_level_irq+0x81/0x100
    [   19.096816]                     handle_irq+0x9c/0xd0
    [   19.096816]                     do_IRQ+0x5c/0x120
    [   19.096816]                     common_interrupt+0x36/0x3c
    [   19.096816]                     _raw_spin_unlock_irqrestore+0x57/0x70
    [   19.096816]                     ath9k_config+0x16a/0x1d0 [ath9k]
    [   19.096816]                     ieee80211_hw_config+0xa8/0x5f0 [mac80211]
    [   19.096816]                     ieee80211_dynamic_ps_enable_work+0x1c3/0x680 [mac80211]
    [   19.096816]                     process_one_work+0x1d1/0x580
    [   19.096816]                     worker_thread+0x31/0x380
    [   19.096816]                     kthread+0xd9/0x110
    [   19.096816]                     ret_from_fork+0x19/0x24
    [   19.096816]    IN-SOFTIRQ-W at:
    [   19.096816]                     __lock_acquire+0x55a/0x1260
    [   19.096816]                     lock_acquire+0xb1/0x1c0
    [   19.096816]                     _raw_spin_lock_irqsave+0x45/0x60
    [   19.096816]                     ath9k_ps_wakeup+0x24/0xe0 [ath9k]
    [   19.096816]                     ath9k_tasklet+0x42/0x260 [ath9k]
    [   19.096816]                     tasklet_action+0x196/0x1e0
    [   19.096816]                     __do_softirq+0xb0/0x430
    [   19.096816]                     do_softirq_own_stack+0x33/0x40
    [   19.096816]                     irq_exit+0xad/0xc0
    [   19.096816]                     do_IRQ+0x65/0x120
    [   19.096816]                     common_interrupt+0x36/0x3c
    [   19.096816]                     get_page_from_freelist+0x20a/0x970
    [   19.096816]                     __alloc_pages_nodemask+0xca/0xed0
    [   19.096816]                     __get_free_pages+0x14/0x30
    [   19.096816]                     pgd_alloc+0x1d/0x160
    [   19.096816]                     mm_init.isra.47+0x13a/0x1b0
    [   19.096816]                     copy_process.part.54+0xb55/0x1700
    [   19.096816]                     _do_fork+0xd4/0x6a0
    [   19.096816]                     SyS_clone+0x27/0x30
    [   19.096816]                     do_fast_syscall_32+0x96/0x1d0
    [   19.096816]                     entry_SYSENTER_32+0x4c/0x7b
    [   19.096816]    INITIAL USE at:
    [   19.096816]                    __lock_acquire+0x204/0x1260
    [   19.096816]                    lock_acquire+0xb1/0x1c0
    [   19.096816]                    _raw_spin_lock_irqsave+0x45/0x60
    [   19.096816]                    ath9k_ps_wakeup+0x24/0xe0 [ath9k]
    [   19.096816]                    ath9k_start+0x29/0x1f0 [ath9k]
    [   19.096816]                    drv_start+0x71/0x270 [mac80211]
    [   19.096816]                    ieee80211_do_open+0x31f/0x920 [mac80211]
    [   19.096816]                    ieee80211_open+0x41/0x50 [mac80211]
    [   19.096816]                    __dev_open+0xab/0x140
    [   19.096816]                    __dev_change_flags+0x89/0x150
    [   19.096816]                    dev_change_flags+0x28/0x60
    [   19.096816]                    do_setlink+0x290/0x890
    [   19.096816]                    rtnl_newlink+0x7cf/0x8e0
    [   19.096816]                    rtnetlink_rcv_msg+0xbf/0x1f0
    [   19.096816]                    netlink_rcv_skb+0xb9/0xe0
    [   19.096816]                    rtnetlink_rcv+0x1e/0x30
    [   19.096816]                    netlink_unicast+0x13a/0x2c0
    [   19.096816]                    netlink_sendmsg+0x290/0x380
    [   19.096816]                    ___sys_sendmsg+0x1e2/0x280
    [   19.096816]                    __sys_sendmsg+0x3f/0x80
    [   19.096816]                    SyS_socketcall+0x58c/0x6b0
    [   19.096816]                    do_fast_syscall_32+0x96/0x1d0
    [   19.096816]                    entry_SYSENTER_32+0x4c/0x7b
    [   19.096816]  }
    [   19.096816]  ... key      at: [<f837b67c>] __key.61994+0x0/0xffffc984 [ath9k]
    [   19.096816]  ... acquired at:
    [   19.096816]    check_usage_forwards+0x118/0x120
    [   19.096816]    mark_lock+0x2e4/0x590
    [   19.096816]    __lock_acquire+0x6ae/0x1260
    [   19.096816]    lock_acquire+0xb1/0x1c0
    [   19.096816]    _raw_spin_lock_irqsave+0x45/0x60
    [   19.096816]    ath_isr+0x15e/0x200 [ath9k]
    [   19.096816]    __handle_irq_event_percpu+0x44/0x340
    [   19.096816]    handle_irq_event_percpu+0x1d/0x50
    [   19.096816]    handle_irq_event+0x32/0x60
    [   19.096816]    handle_level_irq+0x81/0x100
    [   19.096816]    handle_irq+0x9c/0xd0
    [   19.096816]    do_IRQ+0x5c/0x120
    [   19.096816]    common_interrupt+0x36/0x3c
    [   19.096816]    _raw_spin_unlock_irqrestore+0x57/0x70
    [   19.096816]    ath9k_config+0x16a/0x1d0 [ath9k]
    [   19.096816]    ieee80211_hw_config+0xa8/0x5f0 [mac80211]
    [   19.096816]    ieee80211_dynamic_ps_enable_work+0x1c3/0x680 [mac80211]
    [   19.096816]    process_one_work+0x1d1/0x580
    [   19.096816]    worker_thread+0x31/0x380
    [   19.096816]    kthread+0xd9/0x110
    [   19.096816]    ret_from_fork+0x19/0x24
    
    [   19.096816]
                   stack backtrace:
    [   19.096816] CPU: 0 PID: 5 Comm: kworker/u2:0 Not tainted 4.13.0-mgm-ovl+ #51
    [   19.096816] Hardware name: FUJITSU SIEMENS LIFEBOOK S6120/FJNB16C, BIOS Version 1.26  05/10/2004
    [   19.096816] Workqueue: phy0 ieee80211_dynamic_ps_enable_work [mac80211]
    [   19.096816] Call Trace:
    [   19.096816]  <IRQ>
    [   19.096816]  dump_stack+0x16/0x19
    [   19.096816]  print_irq_inversion_bug.part.37+0x16c/0x179
    [   19.096816]  check_usage_forwards+0x118/0x120
    [   19.096816]  ? ret_from_fork+0x19/0x24
    [   19.096816]  ? print_shortest_lock_dependencies+0x1a0/0x1a0
    [   19.096816]  mark_lock+0x2e4/0x590
    [   19.096816]  ? print_shortest_lock_dependencies+0x1a0/0x1a0
    [   19.096816]  __lock_acquire+0x6ae/0x1260
    [   19.096816]  lock_acquire+0xb1/0x1c0
    [   19.096816]  ? ath_isr+0x15e/0x200 [ath9k]
    [   19.096816]  _raw_spin_lock_irqsave+0x45/0x60
    [   19.096816]  ? ath_isr+0x15e/0x200 [ath9k]
    [   19.096816]  ath_isr+0x15e/0x200 [ath9k]
    [   19.096816]  __handle_irq_event_percpu+0x44/0x340
    [   19.096816]  handle_irq_event_percpu+0x1d/0x50
    [   19.096816]  handle_irq_event+0x32/0x60
    [   19.096816]  ? handle_nested_irq+0x100/0x100
    [   19.096816]  handle_level_irq+0x81/0x100
    [   19.096816]  handle_irq+0x9c/0xd0
    [   19.096816]  </IRQ>
    [   19.096816]  do_IRQ+0x5c/0x120
    [   19.096816]  common_interrupt+0x36/0x3c
    [   19.096816] EIP: _raw_spin_unlock_irqrestore+0x57/0x70
    [   19.096816] EFLAGS: 00000286 CPU: 0
    [   19.096816] EAX: f60a3600 EBX: 00000286 ECX: 00000006 EDX: 00000001
    [   19.096816] ESI: f46c9e68 EDI: f46c8620 EBP: f60b5e8c ESP: f60b5e84
    [   19.096816]  DS: 007b ES: 007b FS: 0000 GS: 0000 SS: 0068
    [   19.096816]  ath9k_config+0x16a/0x1d0 [ath9k]
    [   19.096816]  ieee80211_hw_config+0xa8/0x5f0 [mac80211]
    [   19.096816]  ? ieee80211_hw_config+0x1db/0x5f0 [mac80211]
    [   19.096816]  ieee80211_dynamic_ps_enable_work+0x1c3/0x680 [mac80211]
    [   19.096816]  ? process_one_work+0x127/0x580
    [   19.096816]  ? process_one_work+0x127/0x580
    [   19.096816]  process_one_work+0x1d1/0x580
    [   19.096816]  ? process_one_work+0x127/0x580
    [   19.096816]  worker_thread+0x31/0x380
    [   19.096816]  kthread+0xd9/0x110
    [   19.096816]  ? process_one_work+0x580/0x580
    [   19.096816]  ? kthread_create_on_node+0x30/0x30
    [   19.096816]  ret_from_fork+0x19/0x24
    
    Cc: QCA ath9k Development <ath9k-devel@qca.qualcomm.com>
    Cc: Kalle Valo <kvalo@codeaurora.org>
    Cc: netdev@vger.kernel.org
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index 27c50562dc47..3f4f01c829f0 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -367,10 +367,10 @@ void ath_ani_calibrate(unsigned long data)
 
 	/* Call ANI routine if necessary */
 	if (aniflag) {
-		spin_lock(&common->cc_lock);
+		spin_lock_irqsave(&common->cc_lock, flags);
 		ath9k_hw_ani_monitor(ah, ah->curchan);
 		ath_update_survey_stats(sc);
-		spin_unlock(&common->cc_lock);
+		spin_unlock_irqrestore(&common->cc_lock, flags);
 	}
 
 	/* Perform calibration if necessary */

commit d63ffc45c5d3df15f6fc8c73079458ce4a111995
Author: Felix Fietkau <nbd@nbd.name>
Date:   Thu Feb 2 10:14:50 2017 +0100

    ath9k: rename tx_complete_work to hw_check_work
    
    Also include common MAC alive check. This should make the hang checks
    more reliable for modes where beacons are not sent and is used as a
    starting point for further hang check improvements
    
    Signed-off-by: Felix Fietkau <nbd@nbd.name>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index 5ad0feeebc86..27c50562dc47 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -20,20 +20,13 @@
  * TX polling - checks if the TX engine is stuck somewhere
  * and issues a chip reset if so.
  */
-void ath_tx_complete_poll_work(struct work_struct *work)
+static bool ath_tx_complete_check(struct ath_softc *sc)
 {
-	struct ath_softc *sc = container_of(work, struct ath_softc,
-					    tx_complete_work.work);
 	struct ath_txq *txq;
 	int i;
-	bool needreset = false;
-
 
-	if (sc->tx99_state) {
-		ath_dbg(ath9k_hw_common(sc->sc_ah), RESET,
-			"skip tx hung detection on tx99\n");
-		return;
-	}
+	if (sc->tx99_state)
+		return true;
 
 	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
 		txq = sc->tx.txq_map[i];
@@ -41,25 +34,36 @@ void ath_tx_complete_poll_work(struct work_struct *work)
 		ath_txq_lock(sc, txq);
 		if (txq->axq_depth) {
 			if (txq->axq_tx_inprogress) {
-				needreset = true;
 				ath_txq_unlock(sc, txq);
-				break;
-			} else {
-				txq->axq_tx_inprogress = true;
+				goto reset;
 			}
+
+			txq->axq_tx_inprogress = true;
 		}
 		ath_txq_unlock(sc, txq);
 	}
 
-	if (needreset) {
-		ath_dbg(ath9k_hw_common(sc->sc_ah), RESET,
-			"tx hung, resetting the chip\n");
-		ath9k_queue_reset(sc, RESET_TYPE_TX_HANG);
+	return true;
+
+reset:
+	ath_dbg(ath9k_hw_common(sc->sc_ah), RESET,
+		"tx hung, resetting the chip\n");
+	ath9k_queue_reset(sc, RESET_TYPE_TX_HANG);
+	return false;
+
+}
+
+void ath_hw_check_work(struct work_struct *work)
+{
+	struct ath_softc *sc = container_of(work, struct ath_softc,
+					    hw_check_work.work);
+
+	if (!ath_hw_check(sc) ||
+	    !ath_tx_complete_check(sc))
 		return;
-	}
 
-	ieee80211_queue_delayed_work(sc->hw, &sc->tx_complete_work,
-				     msecs_to_jiffies(ATH_TX_COMPLETE_POLL_INT));
+	ieee80211_queue_delayed_work(sc->hw, &sc->hw_check_work,
+				     msecs_to_jiffies(ATH_HW_CHECK_POLL_INT));
 }
 
 /*

commit ab63cb8b0cc84a89f65e418357d7e6b9b914c89a
Author: Nicholas Mc Guire <hofrat@osadl.org>
Date:   Thu May 14 18:56:16 2015 +0200

    ath9k: match wait_for_completion_timeout return type
    
    Return type of wait_for_completion_timeout is unsigned long not int.
    As time_left is exclusively used for wait_for_completion_timeout here its
    type is simply changed to unsigned long.
    
    API conformance testing for completions with coccinelle spatches are being
    used to locate API usage inconsistencies:
    ./drivers/net/wireless/ath/ath9k/link.c:197
            int return assigned to unsigned long
    
    Patch was compile tested with x86_64_defconfig + CONFIG_ATH_CARDS=m,
    
    Patch is against 4.1-rc3 (localversion-next is -next-20150514)
    
    Signed-off-by: Nicholas Mc Guire <hofrat@osadl.org>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index 90631d768a60..5ad0feeebc86 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -172,7 +172,7 @@ static bool ath_paprd_send_frame(struct ath_softc *sc, struct sk_buff *skb, int
 	struct ath_hw *ah = sc->sc_ah;
 	struct ath_common *common = ath9k_hw_common(ah);
 	struct ath_tx_control txctl;
-	int time_left;
+	unsigned long time_left;
 
 	memset(&txctl, 0, sizeof(txctl));
 	txctl.txq = sc->tx.txq_map[IEEE80211_AC_BE];

commit 4ed20bebf51578229a1986efcf46344075ec8447
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Nov 14 16:35:34 2014 +0100

    cfg80211: remove "channel" from survey names
    
    All of the survey data is (currently) per channel anyway,
    so having the word "channel" in the name does nothing. In
    the next patch I'll introduce global data to the survey,
    where the word "channel" is actually confusing.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index b829263e3d0a..90631d768a60 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -516,14 +516,14 @@ int ath_update_survey_stats(struct ath_softc *sc)
 		ath_hw_cycle_counters_update(common);
 
 	if (cc->cycles > 0) {
-		survey->filled |= SURVEY_INFO_CHANNEL_TIME |
-			SURVEY_INFO_CHANNEL_TIME_BUSY |
-			SURVEY_INFO_CHANNEL_TIME_RX |
-			SURVEY_INFO_CHANNEL_TIME_TX;
-		survey->channel_time += cc->cycles / div;
-		survey->channel_time_busy += cc->rx_busy / div;
-		survey->channel_time_rx += cc->rx_frame / div;
-		survey->channel_time_tx += cc->tx_frame / div;
+		survey->filled |= SURVEY_INFO_TIME |
+			SURVEY_INFO_TIME_BUSY |
+			SURVEY_INFO_TIME_RX |
+			SURVEY_INFO_TIME_TX;
+		survey->time += cc->cycles / div;
+		survey->time_busy += cc->rx_busy / div;
+		survey->time_rx += cc->rx_frame / div;
+		survey->time_tx += cc->tx_frame / div;
 	}
 
 	if (cc->cycles < div)

commit 7b8aaead958e38b1eb8944c5f9c90ce066500268
Author: Felix Fietkau <nbd@openwrt.org>
Date:   Sat Oct 25 17:19:30 2014 +0200

    ath9k: restart hardware after noise floor calibration failure
    
    When NF calibration fails, the radio often becomes deaf. The usual
    hardware hang checks do not detect this, so it's better to issue a reset
    when that happens.
    
    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index 2343f56e6498..b829263e3d0a 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -371,9 +371,15 @@ void ath_ani_calibrate(unsigned long data)
 
 	/* Perform calibration if necessary */
 	if (longcal || shortcal) {
-		common->ani.caldone =
-			ath9k_hw_calibrate(ah, ah->curchan,
-					   ah->rxchainmask, longcal);
+		int ret = ath9k_hw_calibrate(ah, ah->curchan, ah->rxchainmask,
+					     longcal);
+		if (ret < 0) {
+			common->ani.caldone = 0;
+			ath9k_queue_reset(sc, RESET_TYPE_CALIBRATION);
+			return;
+		}
+
+		common->ani.caldone = ret;
 	}
 
 	ath_dbg(common, ANI,

commit ca900ac9d9f0e38782f5a24e64b05f607fd6eb4c
Author: Rajkumar Manoharan <rmanohar@qti.qualcomm.com>
Date:   Wed Jun 11 16:18:02 2014 +0530

    ath9k: Move beacon config to channel context
    
    Signed-off-by: Rajkumar Manoharan <rmanohar@qti.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index d9c01d563cc2..2343f56e6498 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -440,7 +440,7 @@ void ath_check_ani(struct ath_softc *sc)
 {
 	struct ath_hw *ah = sc->sc_ah;
 	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
-	struct ath_beacon_config *cur_conf = &sc->cur_beacon_conf;
+	struct ath_beacon_config *cur_conf = &sc->cur_chan->beacon;
 
 	/*
 	 * Check for the various conditions in which ANI has to

commit bff117669841c04d08bd1d23617818e0030b3299
Author: Felix Fietkau <nbd@openwrt.org>
Date:   Wed Jun 11 16:17:52 2014 +0530

    ath9k: Add channel context worker thread
    
    The channel context worker is used to switch to next requested
    channel context.
    
    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
    Signed-off-by: Rajkumar Manoharan <rmanohar@qti.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index 6f91974c7b08..d9c01d563cc2 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -178,7 +178,7 @@ static bool ath_paprd_send_frame(struct ath_softc *sc, struct sk_buff *skb, int
 	txctl.txq = sc->tx.txq_map[IEEE80211_AC_BE];
 
 	memset(tx_info, 0, sizeof(*tx_info));
-	tx_info->band = hw->conf.chandef.chan->band;
+	tx_info->band = sc->cur_chandef.chan->band;
 	tx_info->flags |= IEEE80211_TX_CTL_NO_ACK;
 	tx_info->control.rates[0].idx = 0;
 	tx_info->control.rates[0].count = 1;

commit fbbcd14690d3c42b664740d58a22af50a77d5689
Author: Felix Fietkau <nbd@openwrt.org>
Date:   Wed Jun 11 16:17:49 2014 +0530

    ath9k: Add channel context structure
    
    The channel context structure is defined to enable
    multi-channel concurrency support.
    
    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
    Signed-off-by: Rajkumar Manoharan <rmanohar@qti.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index 72a715fe8f24..6f91974c7b08 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -416,7 +416,7 @@ void ath_start_ani(struct ath_softc *sc)
 
 	if (common->disable_ani ||
 	    !test_bit(ATH_OP_ANI_RUN, &common->op_flags) ||
-	    (sc->hw->conf.flags & IEEE80211_CONF_OFFCHANNEL))
+	    sc->cur_chan->offchannel)
 		return;
 
 	common->ani.longcal_timer = timestamp;

commit eefa01ddd57893c7f4482024029fec323c8e1b89
Author: Oleksij Rempel <linux@rempel-privat.de>
Date:   Thu Feb 27 11:40:46 2014 +0100

    ath9k: move sc_flags to ath_common
    
    we will need it for ath9k_htc, may be other drivers too
    
    Signed-off-by: Oleksij Rempel <linux@rempel-privat.de>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index 30dcef5aba10..72a715fe8f24 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -115,13 +115,14 @@ void ath_hw_pll_work(struct work_struct *work)
 	u32 pll_sqsum;
 	struct ath_softc *sc = container_of(work, struct ath_softc,
 					    hw_pll_work.work);
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
 	/*
 	 * ensure that the PLL WAR is executed only
 	 * after the STA is associated (or) if the
 	 * beaconing had started in interfaces that
 	 * uses beacons.
 	 */
-	if (!test_bit(SC_OP_BEACONS, &sc->sc_flags))
+	if (!test_bit(ATH_OP_BEACONS, &common->op_flags))
 		return;
 
 	if (sc->tx99_state)
@@ -414,7 +415,7 @@ void ath_start_ani(struct ath_softc *sc)
 	unsigned long timestamp = jiffies_to_msecs(jiffies);
 
 	if (common->disable_ani ||
-	    !test_bit(SC_OP_ANI_RUN, &sc->sc_flags) ||
+	    !test_bit(ATH_OP_ANI_RUN, &common->op_flags) ||
 	    (sc->hw->conf.flags & IEEE80211_CONF_OFFCHANNEL))
 		return;
 
@@ -438,6 +439,7 @@ void ath_stop_ani(struct ath_softc *sc)
 void ath_check_ani(struct ath_softc *sc)
 {
 	struct ath_hw *ah = sc->sc_ah;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
 	struct ath_beacon_config *cur_conf = &sc->cur_beacon_conf;
 
 	/*
@@ -453,23 +455,23 @@ void ath_check_ani(struct ath_softc *sc)
 			 * Disable ANI only when there are no
 			 * associated stations.
 			 */
-			if (!test_bit(SC_OP_PRIM_STA_VIF, &sc->sc_flags))
+			if (!test_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags))
 				goto stop_ani;
 		}
 	} else if (ah->opmode == NL80211_IFTYPE_STATION) {
-		if (!test_bit(SC_OP_PRIM_STA_VIF, &sc->sc_flags))
+		if (!test_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags))
 			goto stop_ani;
 	}
 
-	if (!test_bit(SC_OP_ANI_RUN, &sc->sc_flags)) {
-		set_bit(SC_OP_ANI_RUN, &sc->sc_flags);
+	if (!test_bit(ATH_OP_ANI_RUN, &common->op_flags)) {
+		set_bit(ATH_OP_ANI_RUN, &common->op_flags);
 		ath_start_ani(sc);
 	}
 
 	return;
 
 stop_ani:
-	clear_bit(SC_OP_ANI_RUN, &sc->sc_flags);
+	clear_bit(ATH_OP_ANI_RUN, &common->op_flags);
 	ath_stop_ani(sc);
 }
 

commit b7cc9b972db1525ccb0bddf5750365e427c0902e
Author: Sujith Manoharan <c_manoha@qca.qualcomm.com>
Date:   Thu Dec 26 08:14:40 2013 +0530

    ath9k: Fix "cc_lock" usage
    
    IRQ save/restore is not required for the cycle counters
    since they are accessed only from softirq and process context.
    
    Signed-off-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index c92ca81350de..30dcef5aba10 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -362,10 +362,10 @@ void ath_ani_calibrate(unsigned long data)
 
 	/* Call ANI routine if necessary */
 	if (aniflag) {
-		spin_lock_irqsave(&common->cc_lock, flags);
+		spin_lock(&common->cc_lock);
 		ath9k_hw_ani_monitor(ah, ah->curchan);
 		ath_update_survey_stats(sc);
-		spin_unlock_irqrestore(&common->cc_lock, flags);
+		spin_unlock(&common->cc_lock);
 	}
 
 	/* Perform calibration if necessary */

commit 415ec61b66198f93962b76107f3324571475a3e2
Author: Sujith Manoharan <c_manoha@qca.qualcomm.com>
Date:   Tue Dec 24 10:44:25 2013 +0530

    ath9k: Remove RX Poll
    
    This patch removes the convoluted and hacky method of
    monitoring for connectivity. We rely on mac80211's connection
    loss logic and doing it in the driver is not necessary.
    
    The HW check for MAC/BB hangs is also simplified, there
    is no need to have a separate work instance for it.
    
    Signed-off-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index aed7e29dc50f..c92ca81350de 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -65,50 +65,26 @@ void ath_tx_complete_poll_work(struct work_struct *work)
 /*
  * Checks if the BB/MAC is hung.
  */
-void ath_hw_check(struct work_struct *work)
+bool ath_hw_check(struct ath_softc *sc)
 {
-	struct ath_softc *sc = container_of(work, struct ath_softc, hw_check_work);
 	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
-	unsigned long flags;
-	int busy;
-	u8 is_alive, nbeacon = 1;
 	enum ath_reset_type type;
+	bool is_alive;
 
 	ath9k_ps_wakeup(sc);
+
 	is_alive = ath9k_hw_check_alive(sc->sc_ah);
 
-	if ((is_alive && !AR_SREV_9300(sc->sc_ah)) || sc->tx99_state)
-		goto out;
-	else if (!is_alive && AR_SREV_9300(sc->sc_ah)) {
+	if (!is_alive) {
 		ath_dbg(common, RESET,
-			"DCU stuck is detected. Schedule chip reset\n");
+			"HW hang detected, schedule chip reset\n");
 		type = RESET_TYPE_MAC_HANG;
-		goto sched_reset;
-	}
-
-	spin_lock_irqsave(&common->cc_lock, flags);
-	busy = ath_update_survey_stats(sc);
-	spin_unlock_irqrestore(&common->cc_lock, flags);
-
-	ath_dbg(common, RESET, "Possible baseband hang, busy=%d (try %d)\n",
-		busy, sc->hw_busy_count + 1);
-	if (busy >= 99) {
-		if (++sc->hw_busy_count >= 3) {
-			type = RESET_TYPE_BB_HANG;
-			goto sched_reset;
-		}
-	} else if (busy >= 0) {
-		sc->hw_busy_count = 0;
-		nbeacon = 3;
+		ath9k_queue_reset(sc, type);
 	}
 
-	ath_start_rx_poll(sc, nbeacon);
-	goto out;
-
-sched_reset:
-	ath9k_queue_reset(sc, type);
-out:
 	ath9k_ps_restore(sc);
+
+	return is_alive;
 }
 
 /*
@@ -161,29 +137,6 @@ void ath_hw_pll_work(struct work_struct *work)
 				     msecs_to_jiffies(ATH_PLL_WORK_INTERVAL));
 }
 
-/*
- * RX Polling - monitors baseband hangs.
- */
-void ath_start_rx_poll(struct ath_softc *sc, u8 nbeacon)
-{
-	if (!AR_SREV_9300(sc->sc_ah))
-		return;
-
-	if (!test_bit(SC_OP_PRIM_STA_VIF, &sc->sc_flags))
-		return;
-
-	mod_timer(&sc->rx_poll_timer, jiffies + msecs_to_jiffies
-		  (nbeacon * sc->cur_beacon_conf.beacon_interval));
-}
-
-void ath_rx_poll(unsigned long data)
-{
-	struct ath_softc *sc = (struct ath_softc *)data;
-
-	if (!test_bit(SC_OP_INVALID, &sc->sc_flags))
-		ieee80211_queue_work(sc->hw, &sc->hw_check_work);
-}
-
 /*
  * PA Pre-distortion.
  */

commit 89f927af7f3389e20c8ad24abfb3d1369f3ffc10
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Mon Oct 14 17:42:11 2013 -0700

    ath9k: add TX99 support
    
    TX99 support enables Specific Absorption Rate (SAR) testing.
    SAR is the unit of measurement for the amount of radio frequency(RF)
    absorbed by the body when using a wireless device. The RF
    exposure limits used are expressed in the terms of SAR, which is a
    measure of the electric and magnetic field strength and power density
    for transmitters operating at frequencies from 300 kHz to 100 GHz.
    
    Regulatory bodies around the world require that wireless device
    be evaluated to meet the RF exposure limits set forth in the
    governmental SAR regulations.
    
    In the examples below, for more bit rate options see the iw TX bitrate
    setting documentation:
    
    http://wireless.kernel.org/en/users/Documentation/iw#Modifying_transmit_bitrates
    
    Example usage:
    
    iw phy phy0 interface add moni0 type monitor
    ip link set dev moni0 up
    
    iw dev moni0 set channel 36 HT40+
    iw set bitrates mcs-5 4
    
    echo 10 > /sys/kernel/debug/ieee80211/phy0/ath9k/tx99_power
    echo 1  > /sys/kernel/debug/ieee80211/phy0/ath9k/tx99
    
    Signed-off-by: Rajkumar Manoharan <rmanohar@qca.qualcomm.com>
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index b7975195d740..aed7e29dc50f 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -28,6 +28,13 @@ void ath_tx_complete_poll_work(struct work_struct *work)
 	int i;
 	bool needreset = false;
 
+
+	if (sc->tx99_state) {
+		ath_dbg(ath9k_hw_common(sc->sc_ah), RESET,
+			"skip tx hung detection on tx99\n");
+		return;
+	}
+
 	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
 		txq = sc->tx.txq_map[i];
 
@@ -70,7 +77,7 @@ void ath_hw_check(struct work_struct *work)
 	ath9k_ps_wakeup(sc);
 	is_alive = ath9k_hw_check_alive(sc->sc_ah);
 
-	if (is_alive && !AR_SREV_9300(sc->sc_ah))
+	if ((is_alive && !AR_SREV_9300(sc->sc_ah)) || sc->tx99_state)
 		goto out;
 	else if (!is_alive && AR_SREV_9300(sc->sc_ah)) {
 		ath_dbg(common, RESET,
@@ -141,6 +148,9 @@ void ath_hw_pll_work(struct work_struct *work)
 	if (!test_bit(SC_OP_BEACONS, &sc->sc_flags))
 		return;
 
+	if (sc->tx99_state)
+		return;
+
 	ath9k_ps_wakeup(sc);
 	pll_sqsum = ar9003_get_pll_sqsum_dvc(sc->sc_ah);
 	ath9k_ps_restore(sc);

commit 5bc225acfe6a6226333061107708033a8d181d39
Author: Lorenzo Bianconi <lorenzo.bianconi83@gmail.com>
Date:   Fri Oct 11 14:09:54 2013 +0200

    ath9k: add noise floor parameter to ath9k_hw_getchan_noise
    
    Add nf parameter to ath9k_hw_getchan_noise() in order to compute NF for EXT
    chains with the same scale of noise floor calculated on CTL chains.
    ath9k_hw_getchan_noise() will be used in ath_process_fft() for spectral scan on
    HT40 channels
    
    Signed-off-by: Lorenzo Bianconi <lorenzo.bianconi83@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index 84a60644f93a..b7975195d740 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -518,7 +518,8 @@ void ath_update_survey_nf(struct ath_softc *sc, int channel)
 
 	if (chan->noisefloor) {
 		survey->filled |= SURVEY_INFO_NOISE_DBM;
-		survey->noise = ath9k_hw_getchan_noise(ah, chan);
+		survey->noise = ath9k_hw_getchan_noise(ah, chan,
+						       chan->noisefloor);
 	}
 }
 

commit 4b9b42bfe08fa369c4f51f00d5f349b32242cd8c
Author: Sujith Manoharan <c_manoha@qca.qualcomm.com>
Date:   Wed Sep 11 16:36:31 2013 +0530

    ath9k: Use bitops for calibration flags
    
    Signed-off-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index 2f831db396ac..84a60644f93a 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -184,7 +184,7 @@ static void ath_paprd_activate(struct ath_softc *sc)
 	struct ath9k_hw_cal_data *caldata = ah->caldata;
 	int chain;
 
-	if (!caldata || !caldata->paprd_done) {
+	if (!caldata || !test_bit(PAPRD_DONE, &caldata->cal_flags)) {
 		ath_dbg(common, CALIBRATE, "Failed to activate PAPRD\n");
 		return;
 	}
@@ -256,7 +256,9 @@ void ath_paprd_calibrate(struct work_struct *work)
 	int len = 1800;
 	int ret;
 
-	if (!caldata || !caldata->paprd_packet_sent || caldata->paprd_done) {
+	if (!caldata ||
+	    !test_bit(PAPRD_PACKET_SENT, &caldata->cal_flags) ||
+	    test_bit(PAPRD_DONE, &caldata->cal_flags)) {
 		ath_dbg(common, CALIBRATE, "Skipping PAPRD calibration\n");
 		return;
 	}
@@ -316,7 +318,7 @@ void ath_paprd_calibrate(struct work_struct *work)
 	kfree_skb(skb);
 
 	if (chain_ok) {
-		caldata->paprd_done = true;
+		set_bit(PAPRD_DONE, &caldata->cal_flags);
 		ath_paprd_activate(sc);
 	}
 
@@ -343,7 +345,7 @@ void ath_ani_calibrate(unsigned long data)
 	u32 cal_interval, short_cal_interval, long_cal_interval;
 	unsigned long flags;
 
-	if (ah->caldata && ah->caldata->nfcal_interference)
+	if (ah->caldata && test_bit(NFCAL_INTF, &ah->caldata->cal_flags))
 		long_cal_interval = ATH_LONG_CALINTERVAL_INT;
 	else
 		long_cal_interval = ATH_LONG_CALINTERVAL;
@@ -432,7 +434,7 @@ void ath_ani_calibrate(unsigned long data)
 	mod_timer(&common->ani.timer, jiffies + msecs_to_jiffies(cal_interval));
 
 	if (ar9003_is_paprd_enabled(ah) && ah->caldata) {
-		if (!ah->caldata->paprd_done) {
+		if (!test_bit(PAPRD_DONE, &ah->caldata->cal_flags)) {
 			ieee80211_queue_work(sc->hw, &sc->paprd_work);
 		} else if (!ah->paprd_table_write_done) {
 			ath9k_ps_wakeup(sc);

commit d4c04ba141d4c5981aebc0aa0ecadc0f16f99387
Author: Sujith Manoharan <c_manoha@qca.qualcomm.com>
Date:   Mon Aug 26 11:47:22 2013 +0530

    ath9k: Fix TX poll work locking
    
    There is no need to call ath_txq_unlock_complete() in the
    TX poll routine - frame completion is not done here,
    so use ath_txq_unlock().
    
    Signed-off-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index fff5d3ccc663..2f831db396ac 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -41,7 +41,7 @@ void ath_tx_complete_poll_work(struct work_struct *work)
 				txq->axq_tx_inprogress = true;
 			}
 		}
-		ath_txq_unlock_complete(sc, txq);
+		ath_txq_unlock(sc, txq);
 	}
 
 	if (needreset) {

commit e323300d9741d44e6543ece3659671742f93acba
Author: Sujith Manoharan <c_manoha@qca.qualcomm.com>
Date:   Mon Jun 3 09:19:26 2013 +0530

    ath9k: Simplify ANI initialization
    
    The check "enable_ani" is not required since it is always
    set to true and the logic for disabling/enabling ANI via
    debugfs is done at a higher layer.
    
    Signed-off-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index cc422a4dfa17..fff5d3ccc663 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -390,9 +390,7 @@ void ath_ani_calibrate(unsigned long data)
 	}
 
 	/* Verify whether we must check ANI */
-	if (sc->sc_ah->config.enable_ani
-	    && (timestamp - common->ani.checkani_timer) >=
-	    ah->config.ani_poll_interval) {
+	if ((timestamp - common->ani.checkani_timer) >= ah->config.ani_poll_interval) {
 		aniflag = true;
 		common->ani.checkani_timer = timestamp;
 	}
@@ -427,9 +425,7 @@ void ath_ani_calibrate(unsigned long data)
 	* short calibration and long calibration.
 	*/
 	cal_interval = ATH_LONG_CALINTERVAL;
-	if (sc->sc_ah->config.enable_ani)
-		cal_interval = min(cal_interval,
-				   (u32)ah->config.ani_poll_interval);
+	cal_interval = min(cal_interval, (u32)ah->config.ani_poll_interval);
 	if (!common->ani.caldone)
 		cal_interval = min(cal_interval, (u32)short_cal_interval);
 

commit cf657a2bc50dff0191d55fff4e7b31e7a6a542a5
Author: Sujith Manoharan <c_manoha@qca.qualcomm.com>
Date:   Wed May 8 05:03:30 2013 +0530

    ath9k: Remove MAC_DEBUG
    
    This option has not been enabled by default in any
    distribution, has never been enabled in OpenWrt and no developer
    has asked for this information in a bug report.
    
    Dumping pages of random values doesn't help debugging,
    remove this option (along with the vmalloc() abuse).
    
    Signed-off-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index 849259b07370..cc422a4dfa17 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -418,7 +418,6 @@ void ath_ani_calibrate(unsigned long data)
 		longcal ? "long" : "", shortcal ? "short" : "",
 		aniflag ? "ani" : "", common->ani.caldone ? "true" : "false");
 
-	ath9k_debug_samp_bb_mac(sc);
 	ath9k_ps_restore(sc);
 
 set_timer:

commit 655d8e2328a6ef6b6b514609a4c1e33508d3a1da
Merge: 6fe5468f452c ddc4db2e3d53
Author: John W. Linville <linville@tuxdriver.com>
Date:   Wed Apr 10 14:09:54 2013 -0400

    Merge branch 'for-john' of git://git.kernel.org/pub/scm/linux/kernel/git/jberg/mac80211-next
    
    Conflicts:
            drivers/net/wireless/ath/carl9170/debug.c
            drivers/net/wireless/ath/carl9170/main.c
            net/mac80211/ieee80211_i.h

commit 7fc0357479eeff4ca808c4d8c09bc7631f576b8d
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Mon Mar 25 11:27:46 2013 -0700

    ath9k: avoid queueing hw check work when suspended
    
    The following issue was reported.
    
    WARNING: at net/mac80211/util.c:599 ieee80211_can_queue_work.isra.7+0x32/0x40 [mac80211]()
    Hardware name: iMac12,1
    queueing ieee80211 work while going to suspend
    Pid: 0, comm: swapper/0 Tainted: PF          O 3.8.2-206.fc18.x86_64 #1
    Call Trace: Mar 16 09:39:17 Parags-iMac kernel: [ 3993.642992]  <IRQ>
    [<ffffffff8105e61f>] warn_slowpath_common+0x7f/0xc0
    [<ffffffffa0581420>] ? ath_start_rx_poll+0x70/0x70 [ath9k]
    <ffffffff8105e716>] warn_slowpath_fmt+0x46/0x50
    [<ffffffffa045b542>] ieee80211_can_queue_work.isra.7+0x32/0x40
    
    Fix this by avoiding to queue the work if our device has
    already been marked as suspended or stopped.
    
    Reported-by: Parag Warudkar <parag.lkml@gmail.com>
    Tested-by: Parag Warudkar <parag.lkml@gmail.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index 39c84ecf6a42..7fdac6c7b3ea 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -170,7 +170,8 @@ void ath_rx_poll(unsigned long data)
 {
 	struct ath_softc *sc = (struct ath_softc *)data;
 
-	ieee80211_queue_work(sc->hw, &sc->hw_check_work);
+	if (!test_bit(SC_OP_INVALID, &sc->sc_flags))
+		ieee80211_queue_work(sc->hw, &sc->hw_check_work);
 }
 
 /*

commit 675a0b049abf6edf30f8dd84c5610b6edc2296c8
Author: Karl Beldan <karl.beldan@rivierawaves.com>
Date:   Mon Mar 25 16:26:57 2013 +0100

    mac80211: Use a cfg80211_chan_def in ieee80211_hw_conf_chan
    
    Drivers that don't use chanctxes cannot perform VHT association because
    they still use a "backward compatibility" pair of {ieee80211_channel,
    nl80211_channel_type} in ieee80211_conf and ieee80211_local.
    
    Signed-off-by: Karl Beldan <karl.beldan@rivierawaves.com>
    [fix kernel-doc]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index ade3afb21f91..b1433f561cd2 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -213,7 +213,7 @@ static bool ath_paprd_send_frame(struct ath_softc *sc, struct sk_buff *skb, int
 	txctl.txq = sc->tx.txq_map[IEEE80211_AC_BE];
 
 	memset(tx_info, 0, sizeof(*tx_info));
-	tx_info->band = hw->conf.channel->band;
+	tx_info->band = hw->conf.chandef.chan->band;
 	tx_info->flags |= IEEE80211_TX_CTL_NO_ACK;
 	tx_info->control.rates[0].idx = 0;
 	tx_info->control.rates[0].count = 1;

commit 01d4ab96d2e7fceaad204e5a8710ce34e229b8c5
Author: Felix Fietkau <nbd@openwrt.org>
Date:   Fri Mar 15 16:18:44 2013 +0100

    ath9k: limit tx path hang check to normal data queues
    
    The beacon and multicast-buffer queues are managed by the beacon
    tasklet, and the generic tx path hang check does not help in any way
    here. Running it on those queues anyway can introduce some race
    conditions leading to unnecessary chip resets.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index ade3afb21f91..39c84ecf6a42 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -28,21 +28,21 @@ void ath_tx_complete_poll_work(struct work_struct *work)
 	int i;
 	bool needreset = false;
 
-	for (i = 0; i < ATH9K_NUM_TX_QUEUES; i++)
-		if (ATH_TXQ_SETUP(sc, i)) {
-			txq = &sc->tx.txq[i];
-			ath_txq_lock(sc, txq);
-			if (txq->axq_depth) {
-				if (txq->axq_tx_inprogress) {
-					needreset = true;
-					ath_txq_unlock(sc, txq);
-					break;
-				} else {
-					txq->axq_tx_inprogress = true;
-				}
+	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
+		txq = sc->tx.txq_map[i];
+
+		ath_txq_lock(sc, txq);
+		if (txq->axq_depth) {
+			if (txq->axq_tx_inprogress) {
+				needreset = true;
+				ath_txq_unlock(sc, txq);
+				break;
+			} else {
+				txq->axq_tx_inprogress = true;
 			}
-			ath_txq_unlock_complete(sc, txq);
 		}
+		ath_txq_unlock_complete(sc, txq);
+	}
 
 	if (needreset) {
 		ath_dbg(ath9k_hw_common(sc->sc_ah), RESET,

commit 0f21ee8d9c8a041b974cfb75d81d07b61bd0869f
Author: Sujith Manoharan <c_manoha@qca.qualcomm.com>
Date:   Mon Dec 10 07:22:37 2012 +0530

    ath9k_hw: Add HW cap for PAPRD
    
    Add a HW capability to indicate whether PAPRD is enabled
    for the card, since PAPRD could be enabled in the EEPROM, but
    disabled in the driver. This makes things clearer.
    
    Signed-off-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index c70b31a72556..ade3afb21f91 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -435,7 +435,7 @@ void ath_ani_calibrate(unsigned long data)
 
 	mod_timer(&common->ani.timer, jiffies + msecs_to_jiffies(cal_interval));
 
-	if (ah->eep_ops->get_eeprom(ah, EEP_PAPRD) && ah->caldata) {
+	if (ar9003_is_paprd_enabled(ah) && ah->caldata) {
 		if (!ah->caldata->paprd_done) {
 			ieee80211_queue_work(sc->hw, &sc->paprd_work);
 		} else if (!ah->paprd_table_write_done) {

commit 19f7842240eb30b1fdf4eacdd444bc9f61f97382
Author: Sujith Manoharan <c_manoha@qca.qualcomm.com>
Date:   Mon Dec 10 07:22:34 2012 +0530

    ath9k: Fix redundant PS wrappers
    
    Move the PowerSave wrappers outside ath_paprd_activate(),
    since they are already being used in ath_paprd_calibrate().
    
    Signed-off-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index 3c996ffe63c3..c70b31a72556 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -188,7 +188,6 @@ static void ath_paprd_activate(struct ath_softc *sc)
 		return;
 	}
 
-	ath9k_ps_wakeup(sc);
 	ar9003_paprd_enable(ah, false);
 	for (chain = 0; chain < AR9300_MAX_CHAINS; chain++) {
 		if (!(ah->txchainmask & BIT(chain)))
@@ -199,7 +198,6 @@ static void ath_paprd_activate(struct ath_softc *sc)
 
 	ath_dbg(common, CALIBRATE, "Activating PAPRD\n");
 	ar9003_paprd_enable(ah, true);
-	ath9k_ps_restore(sc);
 }
 
 static bool ath_paprd_send_frame(struct ath_softc *sc, struct sk_buff *skb, int chain)
@@ -436,11 +434,15 @@ void ath_ani_calibrate(unsigned long data)
 		cal_interval = min(cal_interval, (u32)short_cal_interval);
 
 	mod_timer(&common->ani.timer, jiffies + msecs_to_jiffies(cal_interval));
+
 	if (ah->eep_ops->get_eeprom(ah, EEP_PAPRD) && ah->caldata) {
-		if (!ah->caldata->paprd_done)
+		if (!ah->caldata->paprd_done) {
 			ieee80211_queue_work(sc->hw, &sc->paprd_work);
-		else if (!ah->paprd_table_write_done)
+		} else if (!ah->paprd_table_write_done) {
+			ath9k_ps_wakeup(sc);
 			ath_paprd_activate(sc);
+			ath9k_ps_restore(sc);
+		}
 	}
 }
 

commit 914d0f4def3817c295d3e8cbb7ea53bef8b0efcb
Author: Sujith Manoharan <c_manoha@qca.qualcomm.com>
Date:   Mon Dec 10 07:22:33 2012 +0530

    ath9k: Add a few debug messages for PAPRD
    
    Signed-off-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index fc6b075ad635..3c996ffe63c3 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -179,11 +179,14 @@ void ath_rx_poll(unsigned long data)
 static void ath_paprd_activate(struct ath_softc *sc)
 {
 	struct ath_hw *ah = sc->sc_ah;
+	struct ath_common *common = ath9k_hw_common(ah);
 	struct ath9k_hw_cal_data *caldata = ah->caldata;
 	int chain;
 
-	if (!caldata || !caldata->paprd_done)
+	if (!caldata || !caldata->paprd_done) {
+		ath_dbg(common, CALIBRATE, "Failed to activate PAPRD\n");
 		return;
+	}
 
 	ath9k_ps_wakeup(sc);
 	ar9003_paprd_enable(ah, false);
@@ -194,6 +197,7 @@ static void ath_paprd_activate(struct ath_softc *sc)
 		ar9003_paprd_populate_single_table(ah, caldata, chain);
 	}
 
+	ath_dbg(common, CALIBRATE, "Activating PAPRD\n");
 	ar9003_paprd_enable(ah, true);
 	ath9k_ps_restore(sc);
 }
@@ -253,8 +257,10 @@ void ath_paprd_calibrate(struct work_struct *work)
 	int len = 1800;
 	int ret;
 
-	if (!caldata || !caldata->paprd_packet_sent || caldata->paprd_done)
+	if (!caldata || !caldata->paprd_packet_sent || caldata->paprd_done) {
+		ath_dbg(common, CALIBRATE, "Skipping PAPRD calibration\n");
 		return;
+	}
 
 	ath9k_ps_wakeup(sc);
 

commit 78ef731ce549dd9baf6eba8cf52f61727613690a
Author: Sujith Manoharan <c_manoha@qca.qualcomm.com>
Date:   Wed Nov 21 18:13:11 2012 +0530

    ath9k: Fix the 'xmit' debugfs file
    
    The 'xmit' debugfs file has become big and unwieldy, fix
    multiple issues with its usage:
    
    * Store TX counters/statistics only for the 4 Access Categories.
      Use IEEE80211_NUM_ACS instead of ATH9K_NUM_TX_QUEUES.
    
    * Move various utility macros to debug.h, they can be reused
      elsewhere.
    
    * Remove tx_complete_poll_work_seen.
    
    * Remove code that accesses various internal queue-specific
      variables without any locking whatsoever. HW/SW queue details
      will be handled in a subsequent patch.
    
    * Do not print internal values like txq_headidx and txq_headidx.
      They were mostly unused anyway, considering code like:
      PRX("txq_tailidx:     ", txq_headidx);
    
    * Handle 'txprocdesc' for EDMA too.
    
    Signed-off-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index 227fdb814817..fc6b075ad635 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -27,9 +27,6 @@ void ath_tx_complete_poll_work(struct work_struct *work)
 	struct ath_txq *txq;
 	int i;
 	bool needreset = false;
-#ifdef CONFIG_ATH9K_DEBUGFS
-	sc->tx_complete_poll_work_seen++;
-#endif
 
 	for (i = 0; i < ATH9K_NUM_TX_QUEUES; i++)
 		if (ATH_TXQ_SETUP(sc, i)) {

commit bea843c73854becf998047a83af22a90de3fd19b
Author: Sujith Manoharan <c_manoha@qca.qualcomm.com>
Date:   Wed Nov 21 18:13:10 2012 +0530

    ath9k/ath9k_htc: Remove WME macros
    
    Use the macros provided by mac80211 and remove redundant
    declarations inside the drivers.
    
    Signed-off-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index 223b9693527e..227fdb814817 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -211,7 +211,7 @@ static bool ath_paprd_send_frame(struct ath_softc *sc, struct sk_buff *skb, int
 	int time_left;
 
 	memset(&txctl, 0, sizeof(txctl));
-	txctl.txq = sc->tx.txq_map[WME_AC_BE];
+	txctl.txq = sc->tx.txq_map[IEEE80211_AC_BE];
 
 	memset(tx_info, 0, sizeof(*tx_info));
 	tx_info->band = hw->conf.channel->band;

commit 424749c75daf3611a68a49eca5940ac2b74e4406
Author: Rajkumar Manoharan <rmanohar@qca.qualcomm.com>
Date:   Wed Oct 10 23:03:02 2012 +0530

    ath9k: perform ANI cycle in idle state
    
    As of now the ANI cycle is executed only when the chip is awake.
    On idle state case, the station wakes up from network sleep for
    beacon reception. Since most of the time, ANI cycle is not syncing
    with beacon wakeup, ANI cycle is ignored. Approx 5 mins once, the
    calibration is performed. This could affect the connection stability
    when the station is idle for long. Even though the OFDM and CCK phy
    error rates are too high, ANI is unable to tune its immunity level
    as quick enough due to rare execution.
    
    Here the experiment shows that OFDM and CCK levels are at default
    even on higher phy error rate.
    
    listenTime=44 OFDM:3 errs=121977/s CCK:2 errs=440818/s ofdm_turn=1
    
    This change ensures that ANI calibration will be exectued atleast
    once for every 10 seconds. The below result shows improvements and
    immunity levels are adopted quick enough.
    
    listenTime=557 OFDM:4 errs=752/s CCK:4 errs=125/s ofdm_turn=0
    
    Signed-off-by: Rajkumar Manoharan <rmanohar@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index 7b88b9c39ccd..223b9693527e 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -350,8 +350,18 @@ void ath_ani_calibrate(unsigned long data)
 		ATH_AP_SHORT_CALINTERVAL : ATH_STA_SHORT_CALINTERVAL;
 
 	/* Only calibrate if awake */
-	if (sc->sc_ah->power_mode != ATH9K_PM_AWAKE)
+	if (sc->sc_ah->power_mode != ATH9K_PM_AWAKE) {
+		if (++ah->ani_skip_count >= ATH_ANI_MAX_SKIP_COUNT) {
+			spin_lock_irqsave(&sc->sc_pm_lock, flags);
+			sc->ps_flags |= PS_WAIT_FOR_ANI;
+			spin_unlock_irqrestore(&sc->sc_pm_lock, flags);
+		}
 		goto set_timer;
+	}
+	ah->ani_skip_count = 0;
+	spin_lock_irqsave(&sc->sc_pm_lock, flags);
+	sc->ps_flags &= ~PS_WAIT_FOR_ANI;
+	spin_unlock_irqrestore(&sc->sc_pm_lock, flags);
 
 	ath9k_ps_wakeup(sc);
 

commit 74673db99ca3c09d34ea479f684522ceedb65eb9
Author: Felix Fietkau <nbd@openwrt.org>
Date:   Sat Sep 8 15:24:17 2012 +0200

    ath9k: make PA linearization optional, disabled by default and fix checks
    
    Some checks for PA linearization support checked ATH9K_HW_CAP_PAPRD and some
    used the EEPROM ops, leading to issues in tx power handling, since those
    two can be out of sync.
    
    Disable the feature by default, since it has been reported that it can
    cause damage to the rx path under some circumstances. It can now be enabled
    for testing via debugfs.
    
    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index 825a29cc9313..7b88b9c39ccd 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -423,7 +423,7 @@ void ath_ani_calibrate(unsigned long data)
 		cal_interval = min(cal_interval, (u32)short_cal_interval);
 
 	mod_timer(&common->ani.timer, jiffies + msecs_to_jiffies(cal_interval));
-	if ((sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_PAPRD) && ah->caldata) {
+	if (ah->eep_ops->get_eeprom(ah, EEP_PAPRD) && ah->caldata) {
 		if (!ah->caldata->paprd_done)
 			ieee80211_queue_work(sc->hw, &sc->paprd_work);
 		else if (!ah->paprd_table_write_done)

commit 51dea9be7e01d7e825ed1882246693f09c21374c
Author: Felix Fietkau <nbd@openwrt.org>
Date:   Mon Aug 27 17:00:07 2012 +0200

    ath9k: fix PA linearization calibration related crash
    
    Before PAPRD training can run, the card needs to have sent a packet for
    thermal calibration. Sending a dummy packet with the PAPRD training flag
    set causes a crash under some circumstance.
    Fix the code by replacing the dummy tx with a delay that waits for a
    real packet tx to have occurred.
    
    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index 1c241921f95e..825a29cc9313 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -256,7 +256,7 @@ void ath_paprd_calibrate(struct work_struct *work)
 	int len = 1800;
 	int ret;
 
-	if (!caldata)
+	if (!caldata || !caldata->paprd_packet_sent || caldata->paprd_done)
 		return;
 
 	ath9k_ps_wakeup(sc);
@@ -283,13 +283,6 @@ void ath_paprd_calibrate(struct work_struct *work)
 			continue;
 
 		chain_ok = 0;
-
-		ath_dbg(common, CALIBRATE,
-			"Sending PAPRD frame for thermal measurement on chain %d\n",
-			chain);
-		if (!ath_paprd_send_frame(sc, skb, chain))
-			goto fail_paprd;
-
 		ar9003_paprd_setup_gain_table(ah, chain);
 
 		ath_dbg(common, CALIBRATE,

commit 381c726c09bb43aea8088ede5ce24eaa158289dc
Author: Felix Fietkau <nbd@openwrt.org>
Date:   Mon Aug 27 17:00:05 2012 +0200

    ath9k_hw: calibrate PA input for PA predistortion
    
    Re-train if the calibrated PA linearization curve is out of bounds
    (affects AR933x and AR9485).
    
    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index d4549e9aac5c..1c241921f95e 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -254,6 +254,7 @@ void ath_paprd_calibrate(struct work_struct *work)
 	int chain_ok = 0;
 	int chain;
 	int len = 1800;
+	int ret;
 
 	if (!caldata)
 		return;
@@ -302,7 +303,13 @@ void ath_paprd_calibrate(struct work_struct *work)
 			break;
 		}
 
-		if (ar9003_paprd_create_curve(ah, caldata, chain)) {
+		ret = ar9003_paprd_create_curve(ah, caldata, chain);
+		if (ret == -EINPROGRESS) {
+			ath_dbg(common, CALIBRATE,
+				"PAPRD curve on chain %d needs to be re-trained\n",
+				chain);
+			break;
+		} else if (ret) {
 			ath_dbg(common, CALIBRATE,
 				"PAPRD create curve failed on chain %d\n",
 				chain);

commit 124b979baeb2d7a0593be8d392f43725578478c1
Author: Rajkumar Manoharan <rmanohar@qca.qualcomm.com>
Date:   Tue Jul 17 17:16:42 2012 +0530

    ath9k: Fix race in reset-work usage
    
    Using work_pending() to defer certain operations when
    a HW-reset work has been queued is racy since the check
    would return false when the work item is actually in
    execution. Use SC_OP_HW_RESET instead to fix this race.
    Also, unify the reset debug statistics maintenance.
    
    Signed-off-by: Rajkumar Manoharan <rmanohar@qca.qualcomm.com>
    Signed-off-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index 42fc0a374c61..d4549e9aac5c 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -50,8 +50,7 @@ void ath_tx_complete_poll_work(struct work_struct *work)
 	if (needreset) {
 		ath_dbg(ath9k_hw_common(sc->sc_ah), RESET,
 			"tx hung, resetting the chip\n");
-		RESET_STAT_INC(sc, RESET_TYPE_TX_HANG);
-		ieee80211_queue_work(sc->hw, &sc->hw_reset_work);
+		ath9k_queue_reset(sc, RESET_TYPE_TX_HANG);
 		return;
 	}
 
@@ -69,6 +68,7 @@ void ath_hw_check(struct work_struct *work)
 	unsigned long flags;
 	int busy;
 	u8 is_alive, nbeacon = 1;
+	enum ath_reset_type type;
 
 	ath9k_ps_wakeup(sc);
 	is_alive = ath9k_hw_check_alive(sc->sc_ah);
@@ -78,7 +78,7 @@ void ath_hw_check(struct work_struct *work)
 	else if (!is_alive && AR_SREV_9300(sc->sc_ah)) {
 		ath_dbg(common, RESET,
 			"DCU stuck is detected. Schedule chip reset\n");
-		RESET_STAT_INC(sc, RESET_TYPE_MAC_HANG);
+		type = RESET_TYPE_MAC_HANG;
 		goto sched_reset;
 	}
 
@@ -90,7 +90,7 @@ void ath_hw_check(struct work_struct *work)
 		busy, sc->hw_busy_count + 1);
 	if (busy >= 99) {
 		if (++sc->hw_busy_count >= 3) {
-			RESET_STAT_INC(sc, RESET_TYPE_BB_HANG);
+			type = RESET_TYPE_BB_HANG;
 			goto sched_reset;
 		}
 	} else if (busy >= 0) {
@@ -102,7 +102,7 @@ void ath_hw_check(struct work_struct *work)
 	goto out;
 
 sched_reset:
-	ieee80211_queue_work(sc->hw, &sc->hw_reset_work);
+	ath9k_queue_reset(sc, type);
 out:
 	ath9k_ps_restore(sc);
 }
@@ -119,8 +119,7 @@ static bool ath_hw_pll_rx_hang_check(struct ath_softc *sc, u32 pll_sqsum)
 		count++;
 		if (count == 3) {
 			ath_dbg(common, RESET, "PLL WAR, resetting the chip\n");
-			RESET_STAT_INC(sc, RESET_TYPE_PLL_HANG);
-			ieee80211_queue_work(sc->hw, &sc->hw_reset_work);
+			ath9k_queue_reset(sc, RESET_TYPE_PLL_HANG);
 			count = 0;
 			return true;
 		}

commit da0d45f7b1dd08ab1ea4f542db797a0c51724281
Author: Sujith Manoharan <c_manoha@qca.qualcomm.com>
Date:   Tue Jul 17 17:16:29 2012 +0530

    ath9k: Fix ANI management
    
    Currently, there are problems with how ANI is handled in
    multi-VIF scenarios. This patch addresses them by unifying
    the start/stop logic.
    
    Signed-off-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index 91650fe50461..42fc0a374c61 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -432,26 +432,72 @@ void ath_ani_calibrate(unsigned long data)
 	}
 }
 
-void ath_start_ani(struct ath_common *common)
+void ath_start_ani(struct ath_softc *sc)
 {
-	struct ath_hw *ah = common->ah;
+	struct ath_hw *ah = sc->sc_ah;
+	struct ath_common *common = ath9k_hw_common(ah);
 	unsigned long timestamp = jiffies_to_msecs(jiffies);
-	struct ath_softc *sc = (struct ath_softc *) common->priv;
-
-	if (!test_bit(SC_OP_ANI_RUN, &sc->sc_flags))
-		return;
 
-	if (sc->hw->conf.flags & IEEE80211_CONF_OFFCHANNEL)
+	if (common->disable_ani ||
+	    !test_bit(SC_OP_ANI_RUN, &sc->sc_flags) ||
+	    (sc->hw->conf.flags & IEEE80211_CONF_OFFCHANNEL))
 		return;
 
 	common->ani.longcal_timer = timestamp;
 	common->ani.shortcal_timer = timestamp;
 	common->ani.checkani_timer = timestamp;
 
+	ath_dbg(common, ANI, "Starting ANI\n");
 	mod_timer(&common->ani.timer,
 		  jiffies + msecs_to_jiffies((u32)ah->config.ani_poll_interval));
 }
 
+void ath_stop_ani(struct ath_softc *sc)
+{
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+
+	ath_dbg(common, ANI, "Stopping ANI\n");
+	del_timer_sync(&common->ani.timer);
+}
+
+void ath_check_ani(struct ath_softc *sc)
+{
+	struct ath_hw *ah = sc->sc_ah;
+	struct ath_beacon_config *cur_conf = &sc->cur_beacon_conf;
+
+	/*
+	 * Check for the various conditions in which ANI has to
+	 * be stopped.
+	 */
+	if (ah->opmode == NL80211_IFTYPE_ADHOC) {
+		if (!cur_conf->enable_beacon)
+			goto stop_ani;
+	} else if (ah->opmode == NL80211_IFTYPE_AP) {
+		if (!cur_conf->enable_beacon) {
+			/*
+			 * Disable ANI only when there are no
+			 * associated stations.
+			 */
+			if (!test_bit(SC_OP_PRIM_STA_VIF, &sc->sc_flags))
+				goto stop_ani;
+		}
+	} else if (ah->opmode == NL80211_IFTYPE_STATION) {
+		if (!test_bit(SC_OP_PRIM_STA_VIF, &sc->sc_flags))
+			goto stop_ani;
+	}
+
+	if (!test_bit(SC_OP_ANI_RUN, &sc->sc_flags)) {
+		set_bit(SC_OP_ANI_RUN, &sc->sc_flags);
+		ath_start_ani(sc);
+	}
+
+	return;
+
+stop_ani:
+	clear_bit(SC_OP_ANI_RUN, &sc->sc_flags);
+	ath_stop_ani(sc);
+}
+
 void ath_update_survey_nf(struct ath_softc *sc, int channel)
 {
 	struct ath_hw *ah = sc->sc_ah;

commit 5039f38e16695a0a5c72b08c6a6cc66844a657b1
Author: Rajkumar Manoharan <rmanohar@qca.qualcomm.com>
Date:   Tue Jun 19 14:50:28 2012 +0530

    ath9k: do not sampling on ani timer when chip is in sleep
    
    The baseband and cycle counters are being sampled during ani
    processing for debugging purpose. Whenever the ani is postponded
    due to sleep state, taking samples on that time is of no use and
    also unneccesarily waking up the chip might increase the power
    consumption on idle associated state. Hence moving debug function
    within powersave block.
    
    Signed-off-by: Rajkumar Manoharan <rmanohar@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index a105c9426251..91650fe50461 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -407,6 +407,7 @@ void ath_ani_calibrate(unsigned long data)
 		longcal ? "long" : "", shortcal ? "short" : "",
 		aniflag ? "ani" : "", common->ani.caldone ? "true" : "false");
 
+	ath9k_debug_samp_bb_mac(sc);
 	ath9k_ps_restore(sc);
 
 set_timer:
@@ -415,7 +416,6 @@ void ath_ani_calibrate(unsigned long data)
 	* The interval must be the shortest necessary to satisfy ANI,
 	* short calibration and long calibration.
 	*/
-	ath9k_debug_samp_bb_mac(sc);
 	cal_interval = ATH_LONG_CALINTERVAL;
 	if (sc->sc_ah->config.enable_ani)
 		cal_interval = min(cal_interval,

commit 64bc1239c790e051ff677e023435d770d2ffa174
Author: Mohammed Shafi Shajakhan <mohammed@qca.qualcomm.com>
Date:   Tue Jun 12 20:13:43 2012 +0530

    ath9k: Fix softlockup in AR9485
    
    steps to recreate:
    load latest ath9k driver with AR9485
    stop the network-manager and wpa_supplicant
    bring the interface up
    
            Call Trace:
            [<ffffffffa0517490>] ? ath_hw_check+0xe0/0xe0 [ath9k]
            [<ffffffff812cd1e8>] __const_udelay+0x28/0x30
            [<ffffffffa03bae7a>] ar9003_get_pll_sqsum_dvc+0x4a/0x80 [ath9k_hw]
            [<ffffffffa05174eb>] ath_hw_pll_work+0x5b/0xe0 [ath9k]
            [<ffffffff810744fe>] process_one_work+0x11e/0x470
            [<ffffffff8107530f>] worker_thread+0x15f/0x360
            [<ffffffff810751b0>] ? manage_workers+0x230/0x230
            [<ffffffff81079af3>] kthread+0x93/0xa0
            [<ffffffff815fd3a4>] kernel_thread_helper+0x4/0x10
            [<ffffffff81079a60>] ? kthread_freezable_should_stop+0x70/0x70
            [<ffffffff815fd3a0>] ? gs_change+0x13/0x13
    
    ensure that the PLL-WAR for AR9485/AR9340 is executed only if the STA is
    associated (or) IBSS/AP mode had started beaconing. Ideally this WAR
    is needed to recover from some rare beacon stuck during stress testing.
    Before the STA is associated/IBSS had started beaconing, PLL4(0x1618c)
    always seem to have zero even though we had configured PLL3(0x16188) to
    query about PLL's locking status. When we keep on polling infinitely PLL4's
    8th bit(ie check for PLL locking measurements is done), machine hangs
    due to softlockup.
    
    fixes https://bugzilla.redhat.com/show_bug.cgi?id=811142
    
    Reported-by: Rolf Offermanns <rolf.offermanns@gmx.net>
    Cc: stable@vger.kernel.org
    Tested-by: Mohammed Shafi Shajakhan <mohammed@qca.qualcomm.com>
    Signed-off-by: Mohammed Shafi Shajakhan <mohammed@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index 0cc4c70f7f0c..a105c9426251 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -136,6 +136,14 @@ void ath_hw_pll_work(struct work_struct *work)
 	u32 pll_sqsum;
 	struct ath_softc *sc = container_of(work, struct ath_softc,
 					    hw_pll_work.work);
+	/*
+	 * ensure that the PLL WAR is executed only
+	 * after the STA is associated (or) if the
+	 * beaconing had started in interfaces that
+	 * uses beacons.
+	 */
+	if (!test_bit(SC_OP_BEACONS, &sc->sc_flags))
+		return;
 
 	ath9k_ps_wakeup(sc);
 	pll_sqsum = ar9003_get_pll_sqsum_dvc(sc->sc_ah);

commit 781b14a3153a722fec820374271316537881076e
Author: Sujith Manoharan <c_manoha@qca.qualcomm.com>
Date:   Mon Jun 4 20:23:55 2012 +0530

    ath9k: Use atomic operations
    
    The 'sc_flags' variable is being used in a number of places
    with no locking whatsoever. This patch converts the usage
    of sc_flags to atomic ops.
    
    Signed-off-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index 89b38a9ab7c5..0cc4c70f7f0c 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -155,7 +155,7 @@ void ath_start_rx_poll(struct ath_softc *sc, u8 nbeacon)
 	if (!AR_SREV_9300(sc->sc_ah))
 		return;
 
-	if (!(sc->sc_flags & SC_OP_PRIM_STA_VIF))
+	if (!test_bit(SC_OP_PRIM_STA_VIF, &sc->sc_flags))
 		return;
 
 	mod_timer(&sc->rx_poll_timer, jiffies + msecs_to_jiffies
@@ -430,7 +430,7 @@ void ath_start_ani(struct ath_common *common)
 	unsigned long timestamp = jiffies_to_msecs(jiffies);
 	struct ath_softc *sc = (struct ath_softc *) common->priv;
 
-	if (!(sc->sc_flags & SC_OP_ANI_RUN))
+	if (!test_bit(SC_OP_ANI_RUN, &sc->sc_flags))
 		return;
 
 	if (sc->hw->conf.flags & IEEE80211_CONF_OFFCHANNEL)

commit af68abadac378f7a4a44fe766383e7b88c7f9c3b
Author: Sujith Manoharan <c_manoha@qca.qualcomm.com>
Date:   Mon Jun 4 20:23:43 2012 +0530

    ath9k: Fix work handling
    
    * Currently, there is no synchronization between the reset
      work and the tx-poll work. Fix this and make sure that we
      bail out properly if a reset work is in progress.
    
    * Cleanup the PLL WAR and enable it for AR9340 too and
      use a helper for restarting work/timers after a reset.
    
    Signed-off-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index 7368b9630b99..89b38a9ab7c5 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -52,6 +52,7 @@ void ath_tx_complete_poll_work(struct work_struct *work)
 			"tx hung, resetting the chip\n");
 		RESET_STAT_INC(sc, RESET_TYPE_TX_HANG);
 		ieee80211_queue_work(sc->hw, &sc->hw_reset_work);
+		return;
 	}
 
 	ieee80211_queue_delayed_work(sc->hw, &sc->tx_complete_work,
@@ -107,9 +108,9 @@ void ath_hw_check(struct work_struct *work)
 }
 
 /*
- * PLL-WAR for AR9485.
+ * PLL-WAR for AR9485/AR9340
  */
-static void ath_hw_pll_rx_hang_check(struct ath_softc *sc, u32 pll_sqsum)
+static bool ath_hw_pll_rx_hang_check(struct ath_softc *sc, u32 pll_sqsum)
 {
 	static int count;
 	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
@@ -117,29 +118,33 @@ static void ath_hw_pll_rx_hang_check(struct ath_softc *sc, u32 pll_sqsum)
 	if (pll_sqsum >= 0x40000) {
 		count++;
 		if (count == 3) {
-			/* Rx is hung for more than 500ms. Reset it */
-			ath_dbg(common, RESET, "Possible RX hang, resetting\n");
+			ath_dbg(common, RESET, "PLL WAR, resetting the chip\n");
 			RESET_STAT_INC(sc, RESET_TYPE_PLL_HANG);
 			ieee80211_queue_work(sc->hw, &sc->hw_reset_work);
 			count = 0;
+			return true;
 		}
-	} else
+	} else {
 		count = 0;
+	}
+
+	return false;
 }
 
 void ath_hw_pll_work(struct work_struct *work)
 {
+	u32 pll_sqsum;
 	struct ath_softc *sc = container_of(work, struct ath_softc,
 					    hw_pll_work.work);
-	u32 pll_sqsum;
 
-	if (AR_SREV_9485(sc->sc_ah)) {
-		ath9k_ps_wakeup(sc);
-		pll_sqsum = ar9003_get_pll_sqsum_dvc(sc->sc_ah);
-		ath9k_ps_restore(sc);
-		ath_hw_pll_rx_hang_check(sc, pll_sqsum);
-		ieee80211_queue_delayed_work(sc->hw, &sc->hw_pll_work, HZ/5);
-	}
+	ath9k_ps_wakeup(sc);
+	pll_sqsum = ar9003_get_pll_sqsum_dvc(sc->sc_ah);
+	ath9k_ps_restore(sc);
+	if (ath_hw_pll_rx_hang_check(sc, pll_sqsum))
+		return;
+
+	ieee80211_queue_delayed_work(sc->hw, &sc->hw_pll_work,
+				     msecs_to_jiffies(ATH_PLL_WORK_INTERVAL));
 }
 
 /*
@@ -293,7 +298,7 @@ void ath_paprd_calibrate(struct work_struct *work)
 		if (ar9003_paprd_create_curve(ah, caldata, chain)) {
 			ath_dbg(common, CALIBRATE,
 				"PAPRD create curve failed on chain %d\n",
-								   chain);
+				chain);
 			break;
 		}
 

commit ef1b6cd9a1ba06a3daf9a03aa8f25d52d1f2c31a
Author: Sujith Manoharan <c_manoha@qca.qualcomm.com>
Date:   Mon Jun 4 20:23:37 2012 +0530

    ath9k: Group link monitoring logic
    
    Add link.c and move all the link/connection monitoring
    code to it.
    
    Signed-off-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
new file mode 100644
index 000000000000..7368b9630b99
--- /dev/null
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -0,0 +1,497 @@
+/*
+ * Copyright (c) 2012 Qualcomm Atheros, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "ath9k.h"
+
+/*
+ * TX polling - checks if the TX engine is stuck somewhere
+ * and issues a chip reset if so.
+ */
+void ath_tx_complete_poll_work(struct work_struct *work)
+{
+	struct ath_softc *sc = container_of(work, struct ath_softc,
+					    tx_complete_work.work);
+	struct ath_txq *txq;
+	int i;
+	bool needreset = false;
+#ifdef CONFIG_ATH9K_DEBUGFS
+	sc->tx_complete_poll_work_seen++;
+#endif
+
+	for (i = 0; i < ATH9K_NUM_TX_QUEUES; i++)
+		if (ATH_TXQ_SETUP(sc, i)) {
+			txq = &sc->tx.txq[i];
+			ath_txq_lock(sc, txq);
+			if (txq->axq_depth) {
+				if (txq->axq_tx_inprogress) {
+					needreset = true;
+					ath_txq_unlock(sc, txq);
+					break;
+				} else {
+					txq->axq_tx_inprogress = true;
+				}
+			}
+			ath_txq_unlock_complete(sc, txq);
+		}
+
+	if (needreset) {
+		ath_dbg(ath9k_hw_common(sc->sc_ah), RESET,
+			"tx hung, resetting the chip\n");
+		RESET_STAT_INC(sc, RESET_TYPE_TX_HANG);
+		ieee80211_queue_work(sc->hw, &sc->hw_reset_work);
+	}
+
+	ieee80211_queue_delayed_work(sc->hw, &sc->tx_complete_work,
+				     msecs_to_jiffies(ATH_TX_COMPLETE_POLL_INT));
+}
+
+/*
+ * Checks if the BB/MAC is hung.
+ */
+void ath_hw_check(struct work_struct *work)
+{
+	struct ath_softc *sc = container_of(work, struct ath_softc, hw_check_work);
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+	unsigned long flags;
+	int busy;
+	u8 is_alive, nbeacon = 1;
+
+	ath9k_ps_wakeup(sc);
+	is_alive = ath9k_hw_check_alive(sc->sc_ah);
+
+	if (is_alive && !AR_SREV_9300(sc->sc_ah))
+		goto out;
+	else if (!is_alive && AR_SREV_9300(sc->sc_ah)) {
+		ath_dbg(common, RESET,
+			"DCU stuck is detected. Schedule chip reset\n");
+		RESET_STAT_INC(sc, RESET_TYPE_MAC_HANG);
+		goto sched_reset;
+	}
+
+	spin_lock_irqsave(&common->cc_lock, flags);
+	busy = ath_update_survey_stats(sc);
+	spin_unlock_irqrestore(&common->cc_lock, flags);
+
+	ath_dbg(common, RESET, "Possible baseband hang, busy=%d (try %d)\n",
+		busy, sc->hw_busy_count + 1);
+	if (busy >= 99) {
+		if (++sc->hw_busy_count >= 3) {
+			RESET_STAT_INC(sc, RESET_TYPE_BB_HANG);
+			goto sched_reset;
+		}
+	} else if (busy >= 0) {
+		sc->hw_busy_count = 0;
+		nbeacon = 3;
+	}
+
+	ath_start_rx_poll(sc, nbeacon);
+	goto out;
+
+sched_reset:
+	ieee80211_queue_work(sc->hw, &sc->hw_reset_work);
+out:
+	ath9k_ps_restore(sc);
+}
+
+/*
+ * PLL-WAR for AR9485.
+ */
+static void ath_hw_pll_rx_hang_check(struct ath_softc *sc, u32 pll_sqsum)
+{
+	static int count;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+
+	if (pll_sqsum >= 0x40000) {
+		count++;
+		if (count == 3) {
+			/* Rx is hung for more than 500ms. Reset it */
+			ath_dbg(common, RESET, "Possible RX hang, resetting\n");
+			RESET_STAT_INC(sc, RESET_TYPE_PLL_HANG);
+			ieee80211_queue_work(sc->hw, &sc->hw_reset_work);
+			count = 0;
+		}
+	} else
+		count = 0;
+}
+
+void ath_hw_pll_work(struct work_struct *work)
+{
+	struct ath_softc *sc = container_of(work, struct ath_softc,
+					    hw_pll_work.work);
+	u32 pll_sqsum;
+
+	if (AR_SREV_9485(sc->sc_ah)) {
+		ath9k_ps_wakeup(sc);
+		pll_sqsum = ar9003_get_pll_sqsum_dvc(sc->sc_ah);
+		ath9k_ps_restore(sc);
+		ath_hw_pll_rx_hang_check(sc, pll_sqsum);
+		ieee80211_queue_delayed_work(sc->hw, &sc->hw_pll_work, HZ/5);
+	}
+}
+
+/*
+ * RX Polling - monitors baseband hangs.
+ */
+void ath_start_rx_poll(struct ath_softc *sc, u8 nbeacon)
+{
+	if (!AR_SREV_9300(sc->sc_ah))
+		return;
+
+	if (!(sc->sc_flags & SC_OP_PRIM_STA_VIF))
+		return;
+
+	mod_timer(&sc->rx_poll_timer, jiffies + msecs_to_jiffies
+		  (nbeacon * sc->cur_beacon_conf.beacon_interval));
+}
+
+void ath_rx_poll(unsigned long data)
+{
+	struct ath_softc *sc = (struct ath_softc *)data;
+
+	ieee80211_queue_work(sc->hw, &sc->hw_check_work);
+}
+
+/*
+ * PA Pre-distortion.
+ */
+static void ath_paprd_activate(struct ath_softc *sc)
+{
+	struct ath_hw *ah = sc->sc_ah;
+	struct ath9k_hw_cal_data *caldata = ah->caldata;
+	int chain;
+
+	if (!caldata || !caldata->paprd_done)
+		return;
+
+	ath9k_ps_wakeup(sc);
+	ar9003_paprd_enable(ah, false);
+	for (chain = 0; chain < AR9300_MAX_CHAINS; chain++) {
+		if (!(ah->txchainmask & BIT(chain)))
+			continue;
+
+		ar9003_paprd_populate_single_table(ah, caldata, chain);
+	}
+
+	ar9003_paprd_enable(ah, true);
+	ath9k_ps_restore(sc);
+}
+
+static bool ath_paprd_send_frame(struct ath_softc *sc, struct sk_buff *skb, int chain)
+{
+	struct ieee80211_hw *hw = sc->hw;
+	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
+	struct ath_hw *ah = sc->sc_ah;
+	struct ath_common *common = ath9k_hw_common(ah);
+	struct ath_tx_control txctl;
+	int time_left;
+
+	memset(&txctl, 0, sizeof(txctl));
+	txctl.txq = sc->tx.txq_map[WME_AC_BE];
+
+	memset(tx_info, 0, sizeof(*tx_info));
+	tx_info->band = hw->conf.channel->band;
+	tx_info->flags |= IEEE80211_TX_CTL_NO_ACK;
+	tx_info->control.rates[0].idx = 0;
+	tx_info->control.rates[0].count = 1;
+	tx_info->control.rates[0].flags = IEEE80211_TX_RC_MCS;
+	tx_info->control.rates[1].idx = -1;
+
+	init_completion(&sc->paprd_complete);
+	txctl.paprd = BIT(chain);
+
+	if (ath_tx_start(hw, skb, &txctl) != 0) {
+		ath_dbg(common, CALIBRATE, "PAPRD TX failed\n");
+		dev_kfree_skb_any(skb);
+		return false;
+	}
+
+	time_left = wait_for_completion_timeout(&sc->paprd_complete,
+			msecs_to_jiffies(ATH_PAPRD_TIMEOUT));
+
+	if (!time_left)
+		ath_dbg(common, CALIBRATE,
+			"Timeout waiting for paprd training on TX chain %d\n",
+			chain);
+
+	return !!time_left;
+}
+
+void ath_paprd_calibrate(struct work_struct *work)
+{
+	struct ath_softc *sc = container_of(work, struct ath_softc, paprd_work);
+	struct ieee80211_hw *hw = sc->hw;
+	struct ath_hw *ah = sc->sc_ah;
+	struct ieee80211_hdr *hdr;
+	struct sk_buff *skb = NULL;
+	struct ath9k_hw_cal_data *caldata = ah->caldata;
+	struct ath_common *common = ath9k_hw_common(ah);
+	int ftype;
+	int chain_ok = 0;
+	int chain;
+	int len = 1800;
+
+	if (!caldata)
+		return;
+
+	ath9k_ps_wakeup(sc);
+
+	if (ar9003_paprd_init_table(ah) < 0)
+		goto fail_paprd;
+
+	skb = alloc_skb(len, GFP_KERNEL);
+	if (!skb)
+		goto fail_paprd;
+
+	skb_put(skb, len);
+	memset(skb->data, 0, len);
+	hdr = (struct ieee80211_hdr *)skb->data;
+	ftype = IEEE80211_FTYPE_DATA | IEEE80211_STYPE_NULLFUNC;
+	hdr->frame_control = cpu_to_le16(ftype);
+	hdr->duration_id = cpu_to_le16(10);
+	memcpy(hdr->addr1, hw->wiphy->perm_addr, ETH_ALEN);
+	memcpy(hdr->addr2, hw->wiphy->perm_addr, ETH_ALEN);
+	memcpy(hdr->addr3, hw->wiphy->perm_addr, ETH_ALEN);
+
+	for (chain = 0; chain < AR9300_MAX_CHAINS; chain++) {
+		if (!(ah->txchainmask & BIT(chain)))
+			continue;
+
+		chain_ok = 0;
+
+		ath_dbg(common, CALIBRATE,
+			"Sending PAPRD frame for thermal measurement on chain %d\n",
+			chain);
+		if (!ath_paprd_send_frame(sc, skb, chain))
+			goto fail_paprd;
+
+		ar9003_paprd_setup_gain_table(ah, chain);
+
+		ath_dbg(common, CALIBRATE,
+			"Sending PAPRD training frame on chain %d\n", chain);
+		if (!ath_paprd_send_frame(sc, skb, chain))
+			goto fail_paprd;
+
+		if (!ar9003_paprd_is_done(ah)) {
+			ath_dbg(common, CALIBRATE,
+				"PAPRD not yet done on chain %d\n", chain);
+			break;
+		}
+
+		if (ar9003_paprd_create_curve(ah, caldata, chain)) {
+			ath_dbg(common, CALIBRATE,
+				"PAPRD create curve failed on chain %d\n",
+								   chain);
+			break;
+		}
+
+		chain_ok = 1;
+	}
+	kfree_skb(skb);
+
+	if (chain_ok) {
+		caldata->paprd_done = true;
+		ath_paprd_activate(sc);
+	}
+
+fail_paprd:
+	ath9k_ps_restore(sc);
+}
+
+/*
+ *  ANI performs periodic noise floor calibration
+ *  that is used to adjust and optimize the chip performance.  This
+ *  takes environmental changes (location, temperature) into account.
+ *  When the task is complete, it reschedules itself depending on the
+ *  appropriate interval that was calculated.
+ */
+void ath_ani_calibrate(unsigned long data)
+{
+	struct ath_softc *sc = (struct ath_softc *)data;
+	struct ath_hw *ah = sc->sc_ah;
+	struct ath_common *common = ath9k_hw_common(ah);
+	bool longcal = false;
+	bool shortcal = false;
+	bool aniflag = false;
+	unsigned int timestamp = jiffies_to_msecs(jiffies);
+	u32 cal_interval, short_cal_interval, long_cal_interval;
+	unsigned long flags;
+
+	if (ah->caldata && ah->caldata->nfcal_interference)
+		long_cal_interval = ATH_LONG_CALINTERVAL_INT;
+	else
+		long_cal_interval = ATH_LONG_CALINTERVAL;
+
+	short_cal_interval = (ah->opmode == NL80211_IFTYPE_AP) ?
+		ATH_AP_SHORT_CALINTERVAL : ATH_STA_SHORT_CALINTERVAL;
+
+	/* Only calibrate if awake */
+	if (sc->sc_ah->power_mode != ATH9K_PM_AWAKE)
+		goto set_timer;
+
+	ath9k_ps_wakeup(sc);
+
+	/* Long calibration runs independently of short calibration. */
+	if ((timestamp - common->ani.longcal_timer) >= long_cal_interval) {
+		longcal = true;
+		common->ani.longcal_timer = timestamp;
+	}
+
+	/* Short calibration applies only while caldone is false */
+	if (!common->ani.caldone) {
+		if ((timestamp - common->ani.shortcal_timer) >= short_cal_interval) {
+			shortcal = true;
+			common->ani.shortcal_timer = timestamp;
+			common->ani.resetcal_timer = timestamp;
+		}
+	} else {
+		if ((timestamp - common->ani.resetcal_timer) >=
+		    ATH_RESTART_CALINTERVAL) {
+			common->ani.caldone = ath9k_hw_reset_calvalid(ah);
+			if (common->ani.caldone)
+				common->ani.resetcal_timer = timestamp;
+		}
+	}
+
+	/* Verify whether we must check ANI */
+	if (sc->sc_ah->config.enable_ani
+	    && (timestamp - common->ani.checkani_timer) >=
+	    ah->config.ani_poll_interval) {
+		aniflag = true;
+		common->ani.checkani_timer = timestamp;
+	}
+
+	/* Call ANI routine if necessary */
+	if (aniflag) {
+		spin_lock_irqsave(&common->cc_lock, flags);
+		ath9k_hw_ani_monitor(ah, ah->curchan);
+		ath_update_survey_stats(sc);
+		spin_unlock_irqrestore(&common->cc_lock, flags);
+	}
+
+	/* Perform calibration if necessary */
+	if (longcal || shortcal) {
+		common->ani.caldone =
+			ath9k_hw_calibrate(ah, ah->curchan,
+					   ah->rxchainmask, longcal);
+	}
+
+	ath_dbg(common, ANI,
+		"Calibration @%lu finished: %s %s %s, caldone: %s\n",
+		jiffies,
+		longcal ? "long" : "", shortcal ? "short" : "",
+		aniflag ? "ani" : "", common->ani.caldone ? "true" : "false");
+
+	ath9k_ps_restore(sc);
+
+set_timer:
+	/*
+	* Set timer interval based on previous results.
+	* The interval must be the shortest necessary to satisfy ANI,
+	* short calibration and long calibration.
+	*/
+	ath9k_debug_samp_bb_mac(sc);
+	cal_interval = ATH_LONG_CALINTERVAL;
+	if (sc->sc_ah->config.enable_ani)
+		cal_interval = min(cal_interval,
+				   (u32)ah->config.ani_poll_interval);
+	if (!common->ani.caldone)
+		cal_interval = min(cal_interval, (u32)short_cal_interval);
+
+	mod_timer(&common->ani.timer, jiffies + msecs_to_jiffies(cal_interval));
+	if ((sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_PAPRD) && ah->caldata) {
+		if (!ah->caldata->paprd_done)
+			ieee80211_queue_work(sc->hw, &sc->paprd_work);
+		else if (!ah->paprd_table_write_done)
+			ath_paprd_activate(sc);
+	}
+}
+
+void ath_start_ani(struct ath_common *common)
+{
+	struct ath_hw *ah = common->ah;
+	unsigned long timestamp = jiffies_to_msecs(jiffies);
+	struct ath_softc *sc = (struct ath_softc *) common->priv;
+
+	if (!(sc->sc_flags & SC_OP_ANI_RUN))
+		return;
+
+	if (sc->hw->conf.flags & IEEE80211_CONF_OFFCHANNEL)
+		return;
+
+	common->ani.longcal_timer = timestamp;
+	common->ani.shortcal_timer = timestamp;
+	common->ani.checkani_timer = timestamp;
+
+	mod_timer(&common->ani.timer,
+		  jiffies + msecs_to_jiffies((u32)ah->config.ani_poll_interval));
+}
+
+void ath_update_survey_nf(struct ath_softc *sc, int channel)
+{
+	struct ath_hw *ah = sc->sc_ah;
+	struct ath9k_channel *chan = &ah->channels[channel];
+	struct survey_info *survey = &sc->survey[channel];
+
+	if (chan->noisefloor) {
+		survey->filled |= SURVEY_INFO_NOISE_DBM;
+		survey->noise = ath9k_hw_getchan_noise(ah, chan);
+	}
+}
+
+/*
+ * Updates the survey statistics and returns the busy time since last
+ * update in %, if the measurement duration was long enough for the
+ * result to be useful, -1 otherwise.
+ */
+int ath_update_survey_stats(struct ath_softc *sc)
+{
+	struct ath_hw *ah = sc->sc_ah;
+	struct ath_common *common = ath9k_hw_common(ah);
+	int pos = ah->curchan - &ah->channels[0];
+	struct survey_info *survey = &sc->survey[pos];
+	struct ath_cycle_counters *cc = &common->cc_survey;
+	unsigned int div = common->clockrate * 1000;
+	int ret = 0;
+
+	if (!ah->curchan)
+		return -1;
+
+	if (ah->power_mode == ATH9K_PM_AWAKE)
+		ath_hw_cycle_counters_update(common);
+
+	if (cc->cycles > 0) {
+		survey->filled |= SURVEY_INFO_CHANNEL_TIME |
+			SURVEY_INFO_CHANNEL_TIME_BUSY |
+			SURVEY_INFO_CHANNEL_TIME_RX |
+			SURVEY_INFO_CHANNEL_TIME_TX;
+		survey->channel_time += cc->cycles / div;
+		survey->channel_time_busy += cc->rx_busy / div;
+		survey->channel_time_rx += cc->rx_frame / div;
+		survey->channel_time_tx += cc->tx_frame / div;
+	}
+
+	if (cc->cycles < div)
+		return -1;
+
+	if (cc->cycles > 0)
+		ret = cc->rx_busy * 100 / cc->cycles;
+
+	memset(cc, 0, sizeof(*cc));
+
+	ath_update_survey_nf(sc, pos);
+
+	return ret;
+}
