commit 473becac4b310dd720a0f5e07ce149a09467f1a4
Author: Miaoqing Pan <miaoqing@codeaurora.org>
Date:   Tue Jun 27 17:31:54 2017 +0300

    ath9k: avoid potential freezing during random generator read
    
    In the worst case, ath9k_rng_stop() may take 10s to stop rng kthread.
    The time is too long for users, use wait_event_interruptible_timeout()
    instead of msleep_interruptible(), wakup immediately once
    kthread_should_stop() is true.
    
    Signed-off-by: Miaoqing Pan <miaoqing@codeaurora.org>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath9k/rng.c b/drivers/net/wireless/ath/ath9k/rng.c
index 73f46fb3e83a..f9d3d6eedd3c 100644
--- a/drivers/net/wireless/ath/ath9k/rng.c
+++ b/drivers/net/wireless/ath/ath9k/rng.c
@@ -24,6 +24,8 @@
 #define ATH9K_RNG_BUF_SIZE	320
 #define ATH9K_RNG_ENTROPY(x)	(((x) * 8 * 10) >> 5) /* quality: 10/32 */
 
+static DECLARE_WAIT_QUEUE_HEAD(rng_queue);
+
 static int ath9k_rng_data_read(struct ath_softc *sc, u32 *buf, u32 buf_size)
 {
 	int i, j;
@@ -85,7 +87,9 @@ static int ath9k_rng_kthread(void *data)
 						 ATH9K_RNG_BUF_SIZE);
 		if (unlikely(!bytes_read)) {
 			delay = ath9k_rng_delay_get(++fail_stats);
-			msleep_interruptible(delay);
+			wait_event_interruptible_timeout(rng_queue,
+							 kthread_should_stop(),
+							 msecs_to_jiffies(delay));
 			continue;
 		}
 

commit 07246c115801c27652700e3679bb58661ef7ed65
Author: Miaoqing Pan <miaoqing@codeaurora.org>
Date:   Tue Jun 27 17:31:53 2017 +0300

    ath9k: fix an invalid pointer dereference in ath9k_rng_stop()
    
    The bug was triggered when do suspend/resuming continuously
    on Dell XPS L322X/0PJHXN version 9333 (2013) with kernel
    4.12.0-041200rc4-generic. But can't reproduce on DELL
    E5440 + AR9300 PCIE chips.
    
    The warning is caused by accessing invalid pointer sc->rng_task.
    sc->rng_task is not be cleared after kthread_stop(sc->rng_task)
    be called in ath9k_rng_stop(). Because the kthread is stopped
    before ath9k_rng_kthread() be scheduled.
    
    So set sc->rng_task to null after kthread_stop(sc->rng_task) to
    resolve this issue.
    
    WARNING: CPU: 0 PID: 984 at linux/kernel/kthread.c:71 kthread_stop+0xf1/0x100
    CPU: 0 PID: 984 Comm: NetworkManager Not tainted 4.12.0-041200rc4-generic #201706042031
    Hardware name: Dell Inc.          Dell System XPS L322X/0PJHXN, BIOS A09 05/15/2013
    task: ffff950170fdda00 task.stack: ffffa22c01538000
    RIP: 0010:kthread_stop+0xf1/0x100
    RSP: 0018:ffffa22c0153b5b0 EFLAGS: 00010246
    RAX: ffffffffa6257800 RBX: ffff950171b79560 RCX: 0000000000000000
    RDX: 0000000080000000 RSI: 000000007fffffff RDI: ffff9500ac9a9680
    RBP: ffffa22c0153b5c8 R08: 0000000000000000 R09: 0000000000000000
    R10: ffffa22c0153b648 R11: ffff9501768004b8 R12: ffff9500ac9a9680
    R13: ffff950171b79f70 R14: ffff950171b78780 R15: ffff9501749dc018
    FS:  00007f0d6bfd5540(0000) GS:ffff95017f200000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00007fc190161a08 CR3: 0000000232906000 CR4: 00000000001406f0
    Call Trace:
      ath9k_rng_stop+0x1a/0x20 [ath9k]
      ath9k_stop+0x3b/0x1d0 [ath9k]
      drv_stop+0x33/0xf0 [mac80211]
      ieee80211_stop_device+0x43/0x50 [mac80211]
      ieee80211_do_stop+0x4f2/0x810 [mac80211]
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=196043
    Reported-by: Giulio Genovese <giulio.genovese@gmail.com>
    Tested-by: Giulio Genovese <giulio.genovese@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Miaoqing Pan <miaoqing@codeaurora.org>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath9k/rng.c b/drivers/net/wireless/ath/ath9k/rng.c
index 568b1c6c2b2b..73f46fb3e83a 100644
--- a/drivers/net/wireless/ath/ath9k/rng.c
+++ b/drivers/net/wireless/ath/ath9k/rng.c
@@ -120,6 +120,8 @@ void ath9k_rng_start(struct ath_softc *sc)
 
 void ath9k_rng_stop(struct ath_softc *sc)
 {
-	if (sc->rng_task)
+	if (sc->rng_task) {
 		kthread_stop(sc->rng_task);
+		sc->rng_task = NULL;
+	}
 }

commit e463139a726276cd2995ed21c809504d6470f061
Author: Miaoqing Pan <miaoqing@codeaurora.org>
Date:   Tue Aug 9 15:02:26 2016 +0800

    ath9k: change entropy formula for easier understanding
    
    The quality of ADC entropy is 10 bits of min-entropy for
    a 32-bit value, change '(((x) * 8 * 320) >> 10)' to
    '(((x) * 8 * 10) >> 5)' for easier understanding.
    
    Signed-off-by: Miaoqing Pan <miaoqing@codeaurora.org>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath9k/rng.c b/drivers/net/wireless/ath/ath9k/rng.c
index d38e50f96db7..568b1c6c2b2b 100644
--- a/drivers/net/wireless/ath/ath9k/rng.c
+++ b/drivers/net/wireless/ath/ath9k/rng.c
@@ -22,7 +22,7 @@
 #include "ar9003_phy.h"
 
 #define ATH9K_RNG_BUF_SIZE	320
-#define ATH9K_RNG_ENTROPY(x)	(((x) * 8 * 320) >> 10) /* quality: 320/1024 */
+#define ATH9K_RNG_ENTROPY(x)	(((x) * 8 * 10) >> 5) /* quality: 10/32 */
 
 static int ath9k_rng_data_read(struct ath_softc *sc, u32 *buf, u32 buf_size)
 {

commit a2cb3d5f043e4cc646c396a3e188a171b38c15a0
Author: Miaoqing Pan <miaoqing@codeaurora.org>
Date:   Fri Mar 18 17:54:56 2016 +0800

    ath9k: fix rng high cpu load
    
    If no valid ADC randomness output, ath9k rng will continuously
    reading ADC, which will cause high CPU load. So increase the
    delay to wait for ADC ready.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=114261
    Signed-off-by: Miaoqing Pan <miaoqing@codeaurora.org>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath9k/rng.c b/drivers/net/wireless/ath/ath9k/rng.c
index c9cb2aad7b6f..d38e50f96db7 100644
--- a/drivers/net/wireless/ath/ath9k/rng.c
+++ b/drivers/net/wireless/ath/ath9k/rng.c
@@ -55,11 +55,26 @@ static int ath9k_rng_data_read(struct ath_softc *sc, u32 *buf, u32 buf_size)
 	return j << 2;
 }
 
+static u32 ath9k_rng_delay_get(u32 fail_stats)
+{
+	u32 delay;
+
+	if (fail_stats < 100)
+		delay = 10;
+	else if (fail_stats < 105)
+		delay = 1000;
+	else
+		delay = 10000;
+
+	return delay;
+}
+
 static int ath9k_rng_kthread(void *data)
 {
 	int bytes_read;
 	struct ath_softc *sc = data;
 	u32 *rng_buf;
+	u32 delay, fail_stats = 0;
 
 	rng_buf = kmalloc_array(ATH9K_RNG_BUF_SIZE, sizeof(u32), GFP_KERNEL);
 	if (!rng_buf)
@@ -69,10 +84,13 @@ static int ath9k_rng_kthread(void *data)
 		bytes_read = ath9k_rng_data_read(sc, rng_buf,
 						 ATH9K_RNG_BUF_SIZE);
 		if (unlikely(!bytes_read)) {
-			msleep_interruptible(10);
+			delay = ath9k_rng_delay_get(++fail_stats);
+			msleep_interruptible(delay);
 			continue;
 		}
 
+		fail_stats = 0;
+
 		/* sleep until entropy bits under write_wakeup_threshold */
 		add_hwgenerator_randomness((void *)rng_buf, bytes_read,
 					   ATH9K_RNG_ENTROPY(bytes_read));

commit ed14dc0af7ccea867b479feb88efdfe43ca2a0f9
Author: Miaoqing Pan <miaoqing@codeaurora.org>
Date:   Fri Oct 9 17:06:45 2015 +0800

    ath9k: feeding entropy in kernel from ADC capture
    
    This patch is derived from
    commit 6301566e0b2d ("ath9k: export HW random number generator"),
    
    We evaluated the entropy of the ADC data on QCA9531, QCA9561, QCA955x,
    and AR9340, and it has sufficient quality random data (at least 10 bits
    and up to 22 bits of min-entropy for a 32-bit value). We conservatively
    assume the min-entropy is 10 bits out of 32 bits. Thus, ATH9K_RNG_BUF_SIZE
    is set to 320 (u32) i.e., 1.25 kilobytes of data is inserted to fill up
    the pool as soon as the entropy counter becomes 896/4096 (set by random.c).
    Since ADC was not designed to be a dedicated HW RNG, we do not want to bind
    it to /dev/hwrng framework directly. This patch feeds the entropy directly
    from the WiFi driver to the input pool. The ADC register output is only
    used as a seed for the Linux entropy pool. No conditioning is needed,
    since all the conditioning is performed by the pool itself.
    
    Signed-off-by: Miaoqing Pan <miaoqing@codeaurora.org>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath9k/rng.c b/drivers/net/wireless/ath/ath9k/rng.c
new file mode 100644
index 000000000000..c9cb2aad7b6f
--- /dev/null
+++ b/drivers/net/wireless/ath/ath9k/rng.c
@@ -0,0 +1,107 @@
+/*
+ * Copyright (c) 2015 Qualcomm Atheros, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/hw_random.h>
+#include <linux/kthread.h>
+
+#include "ath9k.h"
+#include "hw.h"
+#include "ar9003_phy.h"
+
+#define ATH9K_RNG_BUF_SIZE	320
+#define ATH9K_RNG_ENTROPY(x)	(((x) * 8 * 320) >> 10) /* quality: 320/1024 */
+
+static int ath9k_rng_data_read(struct ath_softc *sc, u32 *buf, u32 buf_size)
+{
+	int i, j;
+	u32  v1, v2, rng_last = sc->rng_last;
+	struct ath_hw *ah = sc->sc_ah;
+
+	ath9k_ps_wakeup(sc);
+
+	REG_RMW_FIELD(ah, AR_PHY_TEST, AR_PHY_TEST_BBB_OBS_SEL, 1);
+	REG_CLR_BIT(ah, AR_PHY_TEST, AR_PHY_TEST_RX_OBS_SEL_BIT5);
+	REG_RMW_FIELD(ah, AR_PHY_TEST_CTL_STATUS, AR_PHY_TEST_CTL_RX_OBS_SEL, 0);
+
+	for (i = 0, j = 0; i < buf_size; i++) {
+		v1 = REG_READ(ah, AR_PHY_TST_ADC) & 0xffff;
+		v2 = REG_READ(ah, AR_PHY_TST_ADC) & 0xffff;
+
+		/* wait for data ready */
+		if (v1 && v2 && rng_last != v1 && v1 != v2 && v1 != 0xffff &&
+		    v2 != 0xffff)
+			buf[j++] = (v1 << 16) | v2;
+
+		rng_last = v2;
+	}
+
+	ath9k_ps_restore(sc);
+
+	sc->rng_last = rng_last;
+
+	return j << 2;
+}
+
+static int ath9k_rng_kthread(void *data)
+{
+	int bytes_read;
+	struct ath_softc *sc = data;
+	u32 *rng_buf;
+
+	rng_buf = kmalloc_array(ATH9K_RNG_BUF_SIZE, sizeof(u32), GFP_KERNEL);
+	if (!rng_buf)
+		goto out;
+
+	while (!kthread_should_stop()) {
+		bytes_read = ath9k_rng_data_read(sc, rng_buf,
+						 ATH9K_RNG_BUF_SIZE);
+		if (unlikely(!bytes_read)) {
+			msleep_interruptible(10);
+			continue;
+		}
+
+		/* sleep until entropy bits under write_wakeup_threshold */
+		add_hwgenerator_randomness((void *)rng_buf, bytes_read,
+					   ATH9K_RNG_ENTROPY(bytes_read));
+	}
+
+	kfree(rng_buf);
+out:
+	sc->rng_task = NULL;
+
+	return 0;
+}
+
+void ath9k_rng_start(struct ath_softc *sc)
+{
+	struct ath_hw *ah = sc->sc_ah;
+
+	if (sc->rng_task)
+		return;
+
+	if (!AR_SREV_9300_20_OR_LATER(ah))
+		return;
+
+	sc->rng_task = kthread_run(ath9k_rng_kthread, sc, "ath9k-hwrng");
+	if (IS_ERR(sc->rng_task))
+		sc->rng_task = NULL;
+}
+
+void ath9k_rng_stop(struct ath_softc *sc)
+{
+	if (sc->rng_task)
+		kthread_stop(sc->rng_task);
+}
