commit acc79d981c1462b22a7a2cb0d39725f8c01fc425
Author: Sriram R <srirrama@codeaurora.org>
Date:   Tue Mar 17 16:52:38 2020 +0200

    ath11k: Perform per-msdu rx processing
    
    As Hash based reo destination selection is configured,
    the decapped packets reach different reo destintion rings
    based on the destintaion ring selected for the computed hash (based on
    the 5-tuple {ip src/ip dst/src port/dst port/protocol}) by hw and
    as configured by driver.
    
    Hence the current implementation of amsdu list based processing after all
    the subframes of amsdu are received (since all msdu's for a pdev are
    received in same reo dest ring), is not applicable here and hence is
    replaced with per msdu based handling as these subframes
    can be received in different reo dest rings.
    
    Also, as some of the rx descriptor fields might be valid only for the
    first msdu (for ex. received 80211 header, encryption type, etc),
    it might not be useful now as we cannot sync between different
    subframes received in different rings. Hence do not rely on those
    fields and replace them with fieds valid only on per msdu descriptors.
    Also cache other details such as encryption type for a peer so that
    it can be reused when a packet is received from it.
    
    Co-developed-by: Tamizh Chelvam Raja <tamizhr@codeaurora.org>
    Signed-off-by: Tamizh Chelvam Raja <tamizhr@codeaurora.org>
    Signed-off-by: Sriram R <srirrama@codeaurora.org>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/ath/ath11k/mac.h b/drivers/net/wireless/ath/ath11k/mac.h
index f4937a03e92b..0607479774a9 100644
--- a/drivers/net/wireless/ath/ath11k/mac.h
+++ b/drivers/net/wireless/ath/ath11k/mac.h
@@ -145,4 +145,5 @@ void ath11k_mac_peer_cleanup_all(struct ath11k *ar);
 int ath11k_mac_tx_mgmt_pending_free(int buf_id, void *skb, void *ctx);
 u8 ath11k_mac_bw_to_mac80211_bw(u8 bw);
 enum ath11k_supported_bw ath11k_mac_mac80211_bw_to_ath11k_bw(enum rate_info_bw bw);
+enum hal_encrypt_type ath11k_dp_tx_get_encrypt_type(u32 cipher);
 #endif

commit 92bacd1c165c2895dda82bbeb49ad9f190a9dd98
Author: Venkateswara Naralasetty <vnaralas@codeaurora.org>
Date:   Wed Feb 5 14:05:30 2020 +0530

    ath11k: fix incorrect peer stats counters update
    
    Convert mac80211 bw to ath11k bw before updating peer stats
    bw counters, which fixes incorrect peer stats counters update.
    
    Signed-off-by: Venkateswara Naralasetty <vnaralas@codeaurora.org>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/ath/ath11k/mac.h b/drivers/net/wireless/ath/ath11k/mac.h
index f286531cdd78..f4937a03e92b 100644
--- a/drivers/net/wireless/ath/ath11k/mac.h
+++ b/drivers/net/wireless/ath/ath11k/mac.h
@@ -144,4 +144,5 @@ void ath11k_mac_drain_tx(struct ath11k *ar);
 void ath11k_mac_peer_cleanup_all(struct ath11k *ar);
 int ath11k_mac_tx_mgmt_pending_free(int buf_id, void *skb, void *ctx);
 u8 ath11k_mac_bw_to_mac80211_bw(u8 bw);
+enum ath11k_supported_bw ath11k_mac_mac80211_bw_to_ath11k_bw(enum rate_info_bw bw);
 #endif

commit 0366f42640a4100198edcf03bf7625ee1c46f42b
Author: Vasanthakumar Thiagarajan <vthiagar@codeaurora.org>
Date:   Thu Nov 28 08:21:57 2019 +0000

    ath11k: Move mac80211 hw allocation before wmi_init command
    
    This is to prepare REO ring setup before sending wmi_init command.
    Firmware expects all the required REO rings to be setup while processing
    wmi_init command. But as per the current initialization sequence, REO ring
    configurations are done only after wmi_init command is sent.
    Also refactoring ath11k_mac_create() into ath11k_mac_alloc() and
    ath11k_mac_register() to it mac80211 hw structure available before sending
    wmi_init command.
    
    Signed-off-by: Vasanthakumar Thiagarajan <vthiagar@codeaurora.org>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/ath/ath11k/mac.h b/drivers/net/wireless/ath/ath11k/mac.h
index 8c37573ae5dc..f286531cdd78 100644
--- a/drivers/net/wireless/ath/ath11k/mac.h
+++ b/drivers/net/wireless/ath/ath11k/mac.h
@@ -118,9 +118,10 @@ struct ath11k_generic_iter {
 
 extern const struct htt_rx_ring_tlv_filter ath11k_mac_mon_status_filter_default;
 
-int ath11k_mac_create(struct ath11k_base *ab);
 void ath11k_mac_destroy(struct ath11k_base *ab);
 void ath11k_mac_unregister(struct ath11k_base *ab);
+int ath11k_mac_register(struct ath11k_base *ab);
+int ath11k_mac_allocate(struct ath11k_base *ab);
 int ath11k_mac_hw_ratecode_to_legacy_rate(u8 hw_rc, u8 preamble, u8 *rateidx,
 					  u16 *rate);
 u8 ath11k_mac_bitrate_to_idx(const struct ieee80211_supported_band *sband,

commit 39e81c6a2907eff835247d61c0f467327ab6d6c0
Author: Tamizh chelvam <tamizhr@codeaurora.org>
Date:   Mon Nov 25 16:36:23 2019 +0000

    ath11k: fix missed bw conversion in tx completion
    
    TX rate stats for the retried packets for a station comes through
    tx completion events. Assigning hw reported bandwidth information
    directly to station's txrate bandwidth will cause below warning.
    Fix this warning by converting the hw reported bandwidth to
    mac80211 base bandwidth.
    
    [ 134.758190] PC is at cfg80211_calculate_bitrate+0x1bc/0x214 [cfg80211]
    [ 134.765730] LR is at cfg80211_calculate_bitrate+0x1bc/0x214 [cfg80211]
    [ 134.875014] [<ffffffbffca8d708>] cfg80211_calculate_bitrate+0x1bc/0x214 [cfg80211]
    [ 134.877192] [<ffffffbffcaa9704>] nl80211_put_sta_rate+0x54/0xf24 [cfg80211]
    [ 134.884829] [<ffffffbffcaa9d48>] nl80211_put_sta_rate+0x698/0xf24 [cfg80211]
    [ 134.891687] [<ffffffbffcaaa490>] nl80211_put_sta_rate+0xde0/0xf24 [cfg80211]
    [ 134.898975] [<ffffffc0004de748>] genl_lock_dumpit+0x30/0x4c
    [ 134.905998] [<ffffffc0004dc264>] netlink_dump+0xf4/0x248
    [ 134.911291] [<ffffffc0004dc910>] __netlink_dump_start+0xe0/0x174
    [ 134.916850] [<ffffffc0004df114>] genl_family_rcv_msg+0x130/0x2c0
    
    Signed-off-by: Tamizh chelvam <tamizhr@codeaurora.org>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/ath/ath11k/mac.h b/drivers/net/wireless/ath/ath11k/mac.h
index f84af1fc4952..8c37573ae5dc 100644
--- a/drivers/net/wireless/ath/ath11k/mac.h
+++ b/drivers/net/wireless/ath/ath11k/mac.h
@@ -142,4 +142,5 @@ struct ath11k *ath11k_mac_get_ar_vdev_stop_status(struct ath11k_base *ab,
 void ath11k_mac_drain_tx(struct ath11k *ar);
 void ath11k_mac_peer_cleanup_all(struct ath11k *ar);
 int ath11k_mac_tx_mgmt_pending_free(int buf_id, void *skb, void *ctx);
+u8 ath11k_mac_bw_to_mac80211_bw(u8 bw);
 #endif

commit d5c65159f2895379e11ca13f62feabe93278985d
Author: Kalle Valo <kvalo@codeaurora.org>
Date:   Sat Nov 23 09:58:40 2019 +0200

    ath11k: driver for Qualcomm IEEE 802.11ax devices
    
    ath11k is a new driver for Qualcomm IEEE 802.11ax devices, first
    supporting only IPQ8074 SoC using the shared memory AHB bus. ath11k
    uses mac80211 and supports AP, Station and Mesh modes.
    
    Even though ath11k has some similar code as with ath10k (especially
    the WMI layer) it was concluded to be simpler to have a "clean start"
    for ath11k code base and not try to share the code with ath10k. This
    makes maintenance easier and avoids major changes in ath10k, which
    would have significantly increased the risk of regressions in existing
    setups.
    
    Even though the driver is very similar with ath10k but there are major
    differences as well. The datapath is completely different. ath11k
    supports multiple MACs, called "soc" in the firmware interface. And
    there's only one WMI interface to support.
    
    Currently ath11k supports only IEEE 802.11ac mode, but patches for
    802.11ax are available and they will be submitted after ath11k is
    accepted to upstream.
    
    The firmware images are available from ath11k-firmware repository but
    they will be also submitted to linux-firmware:
    
    https://github.com/kvalo/ath11k-firmware
    
    This was tested with firmware version WLAN.HK.2.1.0.1-00629-QCAHKSWPL_SILICONZ-1.
    
    The driver has had multiple authors who are listed in alphabetical
    order below.
    
    Signed-off-by: Anilkumar Kolli <akolli@codeaurora.org>
    Signed-off-by: Bhagavathi Perumal S <bperumal@codeaurora.org>
    Signed-off-by: Ganesh Sesetti <gseset@codeaurora.org>
    Signed-off-by: Govindaraj Saminathan <gsamin@codeaurora.org>
    Signed-off-by: John Crispin <john@phrozen.org>
    Signed-off-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Signed-off-by: Karthikeyan Periyasamy <periyasa@codeaurora.org>
    Signed-off-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Maharaja Kennadyrajan <mkenna@codeaurora.org>
    Signed-off-by: Manikanta Pubbisetty <mpubbise@codeaurora.org>
    Signed-off-by: Miles Hu <milehu@codeaurora.org>
    Signed-off-by: Muna Sinada <msinada@codeaurora.org>
    Signed-off-by: Pradeep Kumar Chitrapu <pradeepc@codeaurora.org>
    Signed-off-by: Rajkumar Manoharan <rmanohar@codeaurora.org>
    Signed-off-by: Sathishkumar Muruganandam <murugana@codeaurora.org>
    Signed-off-by: Shashidhar Lakkavalli <slakkavalli@datto.com>
    Signed-off-by: Sriram R <srirrama@codeaurora.org>
    Signed-off-by: Sven Eckelmann <seckelmann@datto.com>
    Signed-off-by: Vasanthakumar Thiagarajan <vthiagar@codeaurora.org>
    Signed-off-by: Venkateswara Naralasetty <vnaralas@codeaurora.org>

diff --git a/drivers/net/wireless/ath/ath11k/mac.h b/drivers/net/wireless/ath/ath11k/mac.h
new file mode 100644
index 000000000000..f84af1fc4952
--- /dev/null
+++ b/drivers/net/wireless/ath/ath11k/mac.h
@@ -0,0 +1,145 @@
+/* SPDX-License-Identifier: BSD-3-Clause-Clear */
+/*
+ * Copyright (c) 2018-2019 The Linux Foundation. All rights reserved.
+ */
+
+#ifndef ATH11K_MAC_H
+#define ATH11K_MAC_H
+
+#include <net/mac80211.h>
+#include <net/cfg80211.h>
+
+struct ath11k;
+struct ath11k_base;
+
+struct ath11k_generic_iter {
+	struct ath11k *ar;
+	int ret;
+};
+
+/* number of failed packets (20 packets with 16 sw reties each) */
+#define ATH11K_KICKOUT_THRESHOLD		(20 * 16)
+
+/* Use insanely high numbers to make sure that the firmware implementation
+ * won't start, we have the same functionality already in hostapd. Unit
+ * is seconds.
+ */
+#define ATH11K_KEEPALIVE_MIN_IDLE		3747
+#define ATH11K_KEEPALIVE_MAX_IDLE		3895
+#define ATH11K_KEEPALIVE_MAX_UNRESPONSIVE	3900
+
+#define WMI_HOST_RC_DS_FLAG			0x01
+#define WMI_HOST_RC_CW40_FLAG			0x02
+#define WMI_HOST_RC_SGI_FLAG			0x04
+#define WMI_HOST_RC_HT_FLAG			0x08
+#define WMI_HOST_RC_RTSCTS_FLAG			0x10
+#define WMI_HOST_RC_TX_STBC_FLAG		0x20
+#define WMI_HOST_RC_RX_STBC_FLAG		0xC0
+#define WMI_HOST_RC_RX_STBC_FLAG_S		6
+#define WMI_HOST_RC_WEP_TKIP_FLAG		0x100
+#define WMI_HOST_RC_TS_FLAG			0x200
+#define WMI_HOST_RC_UAPSD_FLAG			0x400
+
+#define WMI_HT_CAP_ENABLED			0x0001
+#define WMI_HT_CAP_HT20_SGI			0x0002
+#define WMI_HT_CAP_DYNAMIC_SMPS			0x0004
+#define WMI_HT_CAP_TX_STBC			0x0008
+#define WMI_HT_CAP_TX_STBC_MASK_SHIFT		3
+#define WMI_HT_CAP_RX_STBC			0x0030
+#define WMI_HT_CAP_RX_STBC_MASK_SHIFT		4
+#define WMI_HT_CAP_LDPC				0x0040
+#define WMI_HT_CAP_L_SIG_TXOP_PROT		0x0080
+#define WMI_HT_CAP_MPDU_DENSITY			0x0700
+#define WMI_HT_CAP_MPDU_DENSITY_MASK_SHIFT	8
+#define WMI_HT_CAP_HT40_SGI			0x0800
+#define WMI_HT_CAP_RX_LDPC			0x1000
+#define WMI_HT_CAP_TX_LDPC			0x2000
+#define WMI_HT_CAP_IBF_BFER			0x4000
+
+/* These macros should be used when we wish to advertise STBC support for
+ * only 1SS or 2SS or 3SS.
+ */
+#define WMI_HT_CAP_RX_STBC_1SS			0x0010
+#define WMI_HT_CAP_RX_STBC_2SS			0x0020
+#define WMI_HT_CAP_RX_STBC_3SS			0x0030
+
+#define WMI_HT_CAP_DEFAULT_ALL (WMI_HT_CAP_ENABLED    | \
+				WMI_HT_CAP_HT20_SGI   | \
+				WMI_HT_CAP_HT40_SGI   | \
+				WMI_HT_CAP_TX_STBC    | \
+				WMI_HT_CAP_RX_STBC    | \
+				WMI_HT_CAP_LDPC)
+
+#define WMI_VHT_CAP_MAX_MPDU_LEN_MASK		0x00000003
+#define WMI_VHT_CAP_RX_LDPC			0x00000010
+#define WMI_VHT_CAP_SGI_80MHZ			0x00000020
+#define WMI_VHT_CAP_SGI_160MHZ			0x00000040
+#define WMI_VHT_CAP_TX_STBC			0x00000080
+#define WMI_VHT_CAP_RX_STBC_MASK		0x00000300
+#define WMI_VHT_CAP_RX_STBC_MASK_SHIFT		8
+#define WMI_VHT_CAP_SU_BFER			0x00000800
+#define WMI_VHT_CAP_SU_BFEE			0x00001000
+#define WMI_VHT_CAP_MAX_CS_ANT_MASK		0x0000E000
+#define WMI_VHT_CAP_MAX_CS_ANT_MASK_SHIFT	13
+#define WMI_VHT_CAP_MAX_SND_DIM_MASK		0x00070000
+#define WMI_VHT_CAP_MAX_SND_DIM_MASK_SHIFT	16
+#define WMI_VHT_CAP_MU_BFER			0x00080000
+#define WMI_VHT_CAP_MU_BFEE			0x00100000
+#define WMI_VHT_CAP_MAX_AMPDU_LEN_EXP		0x03800000
+#define WMI_VHT_CAP_MAX_AMPDU_LEN_EXP_SHIT	23
+#define WMI_VHT_CAP_RX_FIXED_ANT		0x10000000
+#define WMI_VHT_CAP_TX_FIXED_ANT		0x20000000
+
+#define WMI_VHT_CAP_MAX_MPDU_LEN_11454		0x00000002
+
+/* These macros should be used when we wish to advertise STBC support for
+ * only 1SS or 2SS or 3SS.
+ */
+#define WMI_VHT_CAP_RX_STBC_1SS			0x00000100
+#define WMI_VHT_CAP_RX_STBC_2SS			0x00000200
+#define WMI_VHT_CAP_RX_STBC_3SS			0x00000300
+
+#define WMI_VHT_CAP_DEFAULT_ALL (WMI_VHT_CAP_MAX_MPDU_LEN_11454  | \
+				 WMI_VHT_CAP_SGI_80MHZ      |       \
+				 WMI_VHT_CAP_TX_STBC        |       \
+				 WMI_VHT_CAP_RX_STBC_MASK   |       \
+				 WMI_VHT_CAP_RX_LDPC        |       \
+				 WMI_VHT_CAP_MAX_AMPDU_LEN_EXP   |  \
+				 WMI_VHT_CAP_RX_FIXED_ANT   |       \
+				 WMI_VHT_CAP_TX_FIXED_ANT)
+
+/* FIXME: should these be in ieee80211.h? */
+#define IEEE80211_VHT_MCS_SUPPORT_0_11_MASK	GENMASK(23, 16)
+#define IEEE80211_DISABLE_VHT_MCS_SUPPORT_0_11	BIT(24)
+
+#define WMI_MAX_SPATIAL_STREAM			3
+
+#define ATH11K_CHAN_WIDTH_NUM			8
+
+extern const struct htt_rx_ring_tlv_filter ath11k_mac_mon_status_filter_default;
+
+int ath11k_mac_create(struct ath11k_base *ab);
+void ath11k_mac_destroy(struct ath11k_base *ab);
+void ath11k_mac_unregister(struct ath11k_base *ab);
+int ath11k_mac_hw_ratecode_to_legacy_rate(u8 hw_rc, u8 preamble, u8 *rateidx,
+					  u16 *rate);
+u8 ath11k_mac_bitrate_to_idx(const struct ieee80211_supported_band *sband,
+			     u32 bitrate);
+u8 ath11k_mac_hw_rate_to_idx(const struct ieee80211_supported_band *sband,
+			     u8 hw_rate, bool cck);
+
+void __ath11k_mac_scan_finish(struct ath11k *ar);
+void ath11k_mac_scan_finish(struct ath11k *ar);
+
+struct ath11k_vif *ath11k_mac_get_arvif(struct ath11k *ar, u32 vdev_id);
+struct ath11k_vif *ath11k_mac_get_arvif_by_vdev_id(struct ath11k_base *ab,
+						   u32 vdev_id);
+struct ath11k *ath11k_mac_get_ar_by_vdev_id(struct ath11k_base *ab, u32 vdev_id);
+struct ath11k *ath11k_mac_get_ar_by_pdev_id(struct ath11k_base *ab, u32 pdev_id);
+struct ath11k *ath11k_mac_get_ar_vdev_stop_status(struct ath11k_base *ab,
+						  u32 vdev_id);
+
+void ath11k_mac_drain_tx(struct ath11k *ar);
+void ath11k_mac_peer_cleanup_all(struct ath11k *ar);
+int ath11k_mac_tx_mgmt_pending_free(int buf_id, void *skb, void *ctx);
+#endif
