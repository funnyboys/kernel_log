commit 614b1f874454b6d01f1e376f72172cba5404e738
Author: Ping-Ke Shih <pkshih@realtek.com>
Date:   Mon May 4 18:50:06 2020 +0800

    rtw88: handle C2H_CCX_TX_RPT to know if packet TX'ed successfully
    
    TX status report of 8723D differs from 8822B/8822C, it uses
    C2H_CCX_TX_RPT (0x03) with different format. With sequence number
    and TX status, driver can know if certain packet was transmitted
    successfully.
    
    Signed-off-by: Ping-Ke Shih <pkshih@realtek.com>
    Signed-off-by: Yan-Hsuan Chuang <yhchuang@realtek.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/20200504105010.10780-5-yhchuang@realtek.com

diff --git a/drivers/net/wireless/realtek/rtw88/tx.h b/drivers/net/wireless/realtek/rtw88/tx.h
index b973de0f4dc0..72dfd4059f03 100644
--- a/drivers/net/wireless/realtek/rtw88/tx.h
+++ b/drivers/net/wireless/realtek/rtw88/tx.h
@@ -95,7 +95,7 @@ void rtw_tx_pkt_info_update(struct rtw_dev *rtwdev,
 			    struct sk_buff *skb);
 void rtw_tx_fill_tx_desc(struct rtw_tx_pkt_info *pkt_info, struct sk_buff *skb);
 void rtw_tx_report_enqueue(struct rtw_dev *rtwdev, struct sk_buff *skb, u8 sn);
-void rtw_tx_report_handle(struct rtw_dev *rtwdev, struct sk_buff *skb);
+void rtw_tx_report_handle(struct rtw_dev *rtwdev, struct sk_buff *skb, int src);
 void rtw_rsvd_page_pkt_info_update(struct rtw_dev *rtwdev,
 				   struct rtw_tx_pkt_info *pkt_info,
 				   struct sk_buff *skb);

commit 2542469d1258b2b2f2849ce1f4df88e86a761f7c
Author: Tzu-En Huang <tehuang@realtek.com>
Date:   Thu Mar 26 10:04:08 2020 +0800

    rtw88: fix non-increase management packet sequence number
    
    In previous setting, management packets' sequence numbers will
    not increase and always stay at 0. Add hw sequence number support
    for mgmt packets.
    The table below shows different sequence number setting in the
    tx descriptor.
    
    seq num ctrl      | EN_HWSEQ | DISQSELSEL | HW_SSN_SEL
    ------------------------------------------------------
    sw ctrl           |    0     |    N/A     |    N/A
    hw ctrl per MACID |    1     |     0      |    N/A
    hw ctrl per HWREG |    1     |     1      |HWREG(0/1/2/3)
    
    Signed-off-by: Tzu-En Huang <tehuang@realtek.com>
    Signed-off-by: Yan-Hsuan Chuang <yhchuang@realtek.com>
    Reviewed-by: Brian Norris <briannorris@chromium.org>
    Tested-by: Brian Norris <briannorris@chromium.org>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/20200326020408.25218-1-yhchuang@realtek.com

diff --git a/drivers/net/wireless/realtek/rtw88/tx.h b/drivers/net/wireless/realtek/rtw88/tx.h
index e488a2643eb3..b973de0f4dc0 100644
--- a/drivers/net/wireless/realtek/rtw88/tx.h
+++ b/drivers/net/wireless/realtek/rtw88/tx.h
@@ -53,6 +53,12 @@
 	le32p_replace_bits((__le32 *)(txdesc) + 0x02, value, BIT(19))
 #define SET_TX_DESC_SW_DEFINE(tx_desc, value)                                  \
 	le32p_replace_bits((__le32 *)(txdesc) + 0x06, value, GENMASK(11, 0))
+#define SET_TX_DESC_DISQSELSEQ(txdesc, value)                                 \
+	le32p_replace_bits((__le32 *)(txdesc) + 0x00, value, BIT(31))
+#define SET_TX_DESC_EN_HWSEQ(txdesc, value)                                   \
+	le32p_replace_bits((__le32 *)(txdesc) + 0x08, value, BIT(15))
+#define SET_TX_DESC_HW_SSN_SEL(txdesc, value)                                 \
+	le32p_replace_bits((__le32 *)(txdesc) + 0x03, value, GENMASK(7, 6))
 
 enum rtw_tx_desc_queue_select {
 	TX_DESC_QSEL_TID0	= 0,

commit aaab5d0e673749f82ff34e5f15ea8a689789a9ce
Author: Yan-Hsuan Chuang <yhchuang@realtek.com>
Date:   Thu Mar 12 16:08:52 2020 +0800

    rtw88: kick off TX packets once for higher efficiency
    
    Driver used to kick off every TX packets, that will waste some
    time while we can do better to kick off the TX packets once after
    they are all prepared to be transmitted.
    
    For PCI, it uses DMA engine to transfer the SKBs to the device,
    and the transition of the state of the DMA engine could be a cost.
    Driver can save some time to kick off multiple SKBs once so that
    the DMA engine will have only one transition.
    
    So, split rtw_hci_ops::tx() to rtw_hci_ops::tx_write() and
    rtw_hci_ops::tx_kick_off() to explicitly kick the SKBs off after
    they are written to the prepared buffer. For packets come from
    ieee80211_ops::tx(), write one and then kick it off immediately.
    For packets queued in TX queue, which come from
    ieee80211_ops::wake_tx_queue(), we can dequeue them, write them
    to the buffer, and then kick them off together.
    
    Signed-off-by: Yan-Hsuan Chuang <yhchuang@realtek.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/20200312080852.16684-6-yhchuang@realtek.com

diff --git a/drivers/net/wireless/realtek/rtw88/tx.h b/drivers/net/wireless/realtek/rtw88/tx.h
index e8e7756866b1..e488a2643eb3 100644
--- a/drivers/net/wireless/realtek/rtw88/tx.h
+++ b/drivers/net/wireless/realtek/rtw88/tx.h
@@ -85,7 +85,7 @@ void rtw_txq_cleanup(struct rtw_dev *rtwdev, struct ieee80211_txq *txq);
 void rtw_tx_tasklet(unsigned long data);
 void rtw_tx_pkt_info_update(struct rtw_dev *rtwdev,
 			    struct rtw_tx_pkt_info *pkt_info,
-			    struct ieee80211_tx_control *control,
+			    struct ieee80211_sta *sta,
 			    struct sk_buff *skb);
 void rtw_tx_fill_tx_desc(struct rtw_tx_pkt_info *pkt_info, struct sk_buff *skb);
 void rtw_tx_report_enqueue(struct rtw_dev *rtwdev, struct sk_buff *skb, u8 sn);

commit da14a0409e3f0df6497516705608a023de400794
Author: Yan-Hsuan Chuang <yhchuang@realtek.com>
Date:   Thu Mar 12 16:08:49 2020 +0800

    rtw88: extract alloc rsvd_page and h2c skb routines
    
    Extract skb allocation routines for rsvd_page and h2c.
    These routines should also be used by USB and SDIO.
    
    This should not change the logic at all.
    memset() for pkt_info is unnecessary, just declare as {0}.
    Also skb_put()/memcpy() can be replaced by skb_put_data().
    
    Signed-off-by: Yan-Hsuan Chuang <yhchuang@realtek.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/20200312080852.16684-3-yhchuang@realtek.com

diff --git a/drivers/net/wireless/realtek/rtw88/tx.h b/drivers/net/wireless/realtek/rtw88/tx.h
index 9ca4f74a501b..e8e7756866b1 100644
--- a/drivers/net/wireless/realtek/rtw88/tx.h
+++ b/drivers/net/wireless/realtek/rtw88/tx.h
@@ -93,5 +93,13 @@ void rtw_tx_report_handle(struct rtw_dev *rtwdev, struct sk_buff *skb);
 void rtw_rsvd_page_pkt_info_update(struct rtw_dev *rtwdev,
 				   struct rtw_tx_pkt_info *pkt_info,
 				   struct sk_buff *skb);
+struct sk_buff *
+rtw_tx_write_data_rsvd_page_get(struct rtw_dev *rtwdev,
+				struct rtw_tx_pkt_info *pkt_info,
+				u8 *buf, u32 size);
+struct sk_buff *
+rtw_tx_write_data_h2c_get(struct rtw_dev *rtwdev,
+			  struct rtw_tx_pkt_info *pkt_info,
+			  u8 *buf, u32 size);
 
 #endif

commit 3745d3e550d1e6c4301596ac05a5fe82c11301ce
Author: Yan-Hsuan Chuang <yhchuang@realtek.com>
Date:   Wed Oct 2 14:35:20 2019 +0800

    rtw88: add driver TX queue support
    
    The mac80211 provides software TX queue for driver, as long as
    driver has hooked ieee80211_ops::wake_tx_queue. Each time a
    packet is queued onto the TX queue, that queue will be woken
    up the inform driver to serve the queue.
    
    Now driver only supports PCI interface ICs, there's no specific
    traffic control for each queue, just schedule a tasklet, and
    dump all of the packets at once to the DMA ring. Instead of TX
    the packets whenever TX queue is woke, tasklet handler can have
    more packets dumped to the device, takes advantage of burst
    write with DMA engine.
    
    And if the driver is going to support USB/SDIO ICs, the tasklet
    can be more flexible for aggregating the packets, enhance the
    efficiency of bandwidth usage.
    
    Signed-off-by: Yan-Hsuan Chuang <yhchuang@realtek.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/realtek/rtw88/tx.h b/drivers/net/wireless/realtek/rtw88/tx.h
index ab5b71f8ac22..9ca4f74a501b 100644
--- a/drivers/net/wireless/realtek/rtw88/tx.h
+++ b/drivers/net/wireless/realtek/rtw88/tx.h
@@ -77,6 +77,12 @@ enum rtw_tx_desc_queue_select {
 	TX_DESC_QSEL_H2C	= 19,
 };
 
+void rtw_tx(struct rtw_dev *rtwdev,
+	    struct ieee80211_tx_control *control,
+	    struct sk_buff *skb);
+void rtw_txq_init(struct rtw_dev *rtwdev, struct ieee80211_txq *txq);
+void rtw_txq_cleanup(struct rtw_dev *rtwdev, struct ieee80211_txq *txq);
+void rtw_tx_tasklet(unsigned long data);
 void rtw_tx_pkt_info_update(struct rtw_dev *rtwdev,
 			    struct rtw_tx_pkt_info *pkt_info,
 			    struct ieee80211_tx_control *control,

commit 942e2a5d39a9706aa0115078a67659b4d071aece
Author: Yan-Hsuan Chuang <yhchuang@realtek.com>
Date:   Wed Oct 2 14:35:19 2019 +0800

    rtw88: allows to set RTS in TX descriptor
    
    Allows driver to send RTS by filling tx descriptor.
    
    The user may want to set the rts threshold. But since we have not
    been taking over rate control from mac80211 to driver by setting flag
    IEEE80211_HW_HAS_RATE_CONTROL, there is nothing we can do about it.
    So here just store the value, and mac80211 will tell us to use rts
    protection by ieee80211_tx_info::control::use_rts.
    
    Signed-off-by: Yan-Hsuan Chuang <yhchuang@realtek.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/realtek/rtw88/tx.h b/drivers/net/wireless/realtek/rtw88/tx.h
index 8338dbf55576..ab5b71f8ac22 100644
--- a/drivers/net/wireless/realtek/rtw88/tx.h
+++ b/drivers/net/wireless/realtek/rtw88/tx.h
@@ -35,6 +35,8 @@
 	le32p_replace_bits((__le32 *)(txdesc) + 0x09, value, GENMASK(23, 12))
 #define SET_TX_DESC_MAX_AGG_NUM(txdesc, value)                                 \
 	le32p_replace_bits((__le32 *)(txdesc) + 0x03, value, GENMASK(21, 17))
+#define SET_TX_DESC_USE_RTS(tx_desc, value)                                    \
+	le32p_replace_bits((__le32 *)(txdesc) + 0x03, value, BIT(12))
 #define SET_TX_DESC_AMPDU_DENSITY(txdesc, value)                               \
 	le32p_replace_bits((__le32 *)(txdesc) + 0x02, value, GENMASK(22, 20))
 #define SET_TX_DESC_DATA_STBC(txdesc, value)                                   \

commit e3037485c68ec1a299ff41160d8fedbd4abc29b9
Author: Yan-Hsuan Chuang <yhchuang@realtek.com>
Date:   Fri Apr 26 15:17:37 2019 +0300

    rtw88: new Realtek 802.11ac driver
    
    This is a new mac80211 driver for Realtek 802.11ac wireless network chips.
    rtw88 now supports RTL8822BE/RTL8822CE now, with basic station mode
    functionalities. The firmware for both can be found at linux-firmware.
    
    https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git
    For RTL8822BE: rtw88/rtw8822b_fw.bin
    For RTL8822CE: rtw88/rtw8822c_fw.bin
    
    And for now, only PCI buses (RTL8xxxE) are supported. We will add support
    for USB and SDIO in the future. The bus interface abstraction can be seen
    in this driver such as hci.h. Most of the hardware setting are the same
    except for some TRX path or probing setup should be separated.
    
    Supported:
    
     * Basic STA/AP/ADHOC mode, and TDLS (STA is well tested)
    
    Missing feature:
    
     * WOW/PNO
     * USB & SDIO bus (such as RTL8xxxU/RTL8xxxS)
     * BT coexistence (8822B/8822C are combo ICs)
     * Multiple interfaces (for now single STA is better supported)
     * Dynamic hardware calibrations (to improve/stabilize performance)
    
    Potential problems:
    
     * static calibration spends too much time, and it is painful for
       driver to leave IDLE state. And slows down associate process.
       But reload function are under development, will be added soon!
     * TRX statictics misleading, as we are not reporting status correctly,
       or say, not reporting for "every" packet.
    
    The next patch set should have BT coexistence code since RTL8822B/C are
    combo ICs, and the driver for BT can be found after Linux Kernel v4.20.
    So it is better to add it first to make WiFi + BT work concurrently.
    
    Although now rtw88 is simple but we are developing more features for it.
    Even we want to add support for more chips such as RTL8821C/RTL8814B.
    
    Finally, rtw88 has many authors, listed alphabetically:
    
    Ping-Ke Shih <pkshih@realtek.com>
    Tzu-En Huang <tehuang@realtek.com>
    Yan-Hsuan Chuang <yhchuang@realtek.com>
    
    Reviewed-by: Stanislaw Gruszka <sgruszka@redhat.com>
    Reviewed-by: Brian Norris <briannorris@chromium.org>
    Tested-by: Brian Norris <briannorris@chromium.org>
    Signed-off-by: Yan-Hsuan Chuang <yhchuang@realtek.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/realtek/rtw88/tx.h b/drivers/net/wireless/realtek/rtw88/tx.h
new file mode 100644
index 000000000000..8338dbf55576
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtw88/tx.h
@@ -0,0 +1,89 @@
+/* SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause */
+/* Copyright(c) 2018-2019  Realtek Corporation
+ */
+
+#ifndef __RTW_TX_H_
+#define __RTW_TX_H_
+
+#define RTK_TX_MAX_AGG_NUM_MASK		0x1f
+
+#define RTW_TX_PROBE_TIMEOUT		msecs_to_jiffies(500)
+
+#define SET_TX_DESC_TXPKTSIZE(txdesc, value)                                   \
+	le32p_replace_bits((__le32 *)(txdesc) + 0x00, value, GENMASK(15, 0))
+#define SET_TX_DESC_OFFSET(txdesc, value)                                      \
+	le32p_replace_bits((__le32 *)(txdesc) + 0x00, value, GENMASK(23, 16))
+#define SET_TX_DESC_PKT_OFFSET(txdesc, value)                                  \
+	le32p_replace_bits((__le32 *)(txdesc) + 0x01, value, GENMASK(28, 24))
+#define SET_TX_DESC_QSEL(txdesc, value)                                        \
+	le32p_replace_bits((__le32 *)(txdesc) + 0x01, value, GENMASK(12, 8))
+#define SET_TX_DESC_BMC(txdesc, value)                                         \
+	le32p_replace_bits((__le32 *)(txdesc) + 0x00, value, BIT(24))
+#define SET_TX_DESC_RATE_ID(txdesc, value)                                     \
+	le32p_replace_bits((__le32 *)(txdesc) + 0x01, value, GENMASK(20, 16))
+#define SET_TX_DESC_DATARATE(txdesc, value)                                    \
+	le32p_replace_bits((__le32 *)(txdesc) + 0x04, value, GENMASK(6, 0))
+#define SET_TX_DESC_DISDATAFB(txdesc, value)                                   \
+	le32p_replace_bits((__le32 *)(txdesc) + 0x03, value, BIT(10))
+#define SET_TX_DESC_USE_RATE(txdesc, value)                                    \
+	le32p_replace_bits((__le32 *)(txdesc) + 0x03, value, BIT(8))
+#define SET_TX_DESC_SEC_TYPE(txdesc, value)                                    \
+	le32p_replace_bits((__le32 *)(txdesc) + 0x01, value, GENMASK(23, 22))
+#define SET_TX_DESC_DATA_BW(txdesc, value)                                     \
+	le32p_replace_bits((__le32 *)(txdesc) + 0x05, value, GENMASK(6, 5))
+#define SET_TX_DESC_SW_SEQ(txdesc, value)                                      \
+	le32p_replace_bits((__le32 *)(txdesc) + 0x09, value, GENMASK(23, 12))
+#define SET_TX_DESC_MAX_AGG_NUM(txdesc, value)                                 \
+	le32p_replace_bits((__le32 *)(txdesc) + 0x03, value, GENMASK(21, 17))
+#define SET_TX_DESC_AMPDU_DENSITY(txdesc, value)                               \
+	le32p_replace_bits((__le32 *)(txdesc) + 0x02, value, GENMASK(22, 20))
+#define SET_TX_DESC_DATA_STBC(txdesc, value)                                   \
+	le32p_replace_bits((__le32 *)(txdesc) + 0x05, value, GENMASK(9, 8))
+#define SET_TX_DESC_DATA_LDPC(txdesc, value)                                   \
+	le32p_replace_bits((__le32 *)(txdesc) + 0x05, value, BIT(7))
+#define SET_TX_DESC_AGG_EN(txdesc, value)                                      \
+	le32p_replace_bits((__le32 *)(txdesc) + 0x02, value, BIT(12))
+#define SET_TX_DESC_LS(txdesc, value)                                          \
+	le32p_replace_bits((__le32 *)(txdesc) + 0x00, value, BIT(26))
+#define SET_TX_DESC_DATA_SHORT(txdesc, value)				       \
+	le32p_replace_bits((__le32 *)(txdesc) + 0x05, value, BIT(4))
+#define SET_TX_DESC_SPE_RPT(tx_desc, value)                                    \
+	le32p_replace_bits((__le32 *)(txdesc) + 0x02, value, BIT(19))
+#define SET_TX_DESC_SW_DEFINE(tx_desc, value)                                  \
+	le32p_replace_bits((__le32 *)(txdesc) + 0x06, value, GENMASK(11, 0))
+
+enum rtw_tx_desc_queue_select {
+	TX_DESC_QSEL_TID0	= 0,
+	TX_DESC_QSEL_TID1	= 1,
+	TX_DESC_QSEL_TID2	= 2,
+	TX_DESC_QSEL_TID3	= 3,
+	TX_DESC_QSEL_TID4	= 4,
+	TX_DESC_QSEL_TID5	= 5,
+	TX_DESC_QSEL_TID6	= 6,
+	TX_DESC_QSEL_TID7	= 7,
+	TX_DESC_QSEL_TID8	= 8,
+	TX_DESC_QSEL_TID9	= 9,
+	TX_DESC_QSEL_TID10	= 10,
+	TX_DESC_QSEL_TID11	= 11,
+	TX_DESC_QSEL_TID12	= 12,
+	TX_DESC_QSEL_TID13	= 13,
+	TX_DESC_QSEL_TID14	= 14,
+	TX_DESC_QSEL_TID15	= 15,
+	TX_DESC_QSEL_BEACON	= 16,
+	TX_DESC_QSEL_HIGH	= 17,
+	TX_DESC_QSEL_MGMT	= 18,
+	TX_DESC_QSEL_H2C	= 19,
+};
+
+void rtw_tx_pkt_info_update(struct rtw_dev *rtwdev,
+			    struct rtw_tx_pkt_info *pkt_info,
+			    struct ieee80211_tx_control *control,
+			    struct sk_buff *skb);
+void rtw_tx_fill_tx_desc(struct rtw_tx_pkt_info *pkt_info, struct sk_buff *skb);
+void rtw_tx_report_enqueue(struct rtw_dev *rtwdev, struct sk_buff *skb, u8 sn);
+void rtw_tx_report_handle(struct rtw_dev *rtwdev, struct sk_buff *skb);
+void rtw_rsvd_page_pkt_info_update(struct rtw_dev *rtwdev,
+				   struct rtw_tx_pkt_info *pkt_info,
+				   struct sk_buff *skb);
+
+#endif
