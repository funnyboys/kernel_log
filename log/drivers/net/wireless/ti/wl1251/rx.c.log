commit 2b27bdcc20958d644d04f9f12d683e52b37a5427
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:50 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 336
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 51 franklin st fifth floor boston ma 02110
      1301 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 246 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000436.674189849@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/wireless/ti/wl1251/rx.c b/drivers/net/wireless/ti/wl1251/rx.c
index 50fb2a4a5259..b4b0ba854202 100644
--- a/drivers/net/wireless/ti/wl1251/rx.c
+++ b/drivers/net/wireless/ti/wl1251/rx.c
@@ -1,23 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * This file is part of wl1251
  *
  * Copyright (c) 1998-2007 Texas Instruments Incorporated
  * Copyright (C) 2008 Nokia Corporation
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
  */
 
 #include <linux/skbuff.h>

commit 7fdd69c5af2160236e97668bc1fb7d70855c66ae
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Apr 26 11:13:00 2017 +0200

    mac80211: clean up rate encoding bits in RX status
    
    In preparation for adding support for HE rates, clean up
    the driver report encoding for rate/bandwidth reporting
    on RX frames.
    
    Much of this patch was done with the following spatch:
    
    @@
    expression status;
    @@
    -status->flag & (RX_FLAG_HT | RX_FLAG_VHT)
    +status->enc_flags & (RX_ENC_FLAG_HT | RX_ENC_FLAG_VHT)
    
    @@
    assignment operator op;
    expression status;
    @@
    -status->flag op RX_FLAG_SHORTPRE
    +status->enc_flags op RX_ENC_FLAG_SHORTPRE
    @@
    expression status;
    @@
    -status->flag & RX_FLAG_SHORTPRE
    +status->enc_flags & RX_ENC_FLAG_SHORTPRE
    
    @@
    assignment operator op;
    expression status;
    @@
    -status->flag op RX_FLAG_HT
    +status->enc_flags op RX_ENC_FLAG_HT
    @@
    expression status;
    @@
    -status->flag & RX_FLAG_HT
    +status->enc_flags & RX_ENC_FLAG_HT
    
    @@
    assignment operator op;
    expression status;
    @@
    -status->flag op RX_FLAG_40MHZ
    +status->enc_flags op RX_ENC_FLAG_40MHZ
    @@
    expression status;
    @@
    -status->flag & RX_FLAG_40MHZ
    +status->enc_flags & RX_ENC_FLAG_40MHZ
    
    @@
    assignment operator op;
    expression status;
    @@
    -status->flag op RX_FLAG_SHORT_GI
    +status->enc_flags op RX_ENC_FLAG_SHORT_GI
    @@
    expression status;
    @@
    -status->flag & RX_FLAG_SHORT_GI
    +status->enc_flags & RX_ENC_FLAG_SHORT_GI
    
    @@
    assignment operator op;
    expression status;
    @@
    -status->flag op RX_FLAG_HT_GF
    +status->enc_flags op RX_ENC_FLAG_HT_GF
    @@
    expression status;
    @@
    -status->flag & RX_FLAG_HT_GF
    +status->enc_flags & RX_ENC_FLAG_HT_GF
    
    @@
    assignment operator op;
    expression status;
    @@
    -status->flag op RX_FLAG_VHT
    +status->enc_flags op RX_ENC_FLAG_VHT
    @@
    expression status;
    @@
    -status->flag & RX_FLAG_VHT
    +status->enc_flags & RX_ENC_FLAG_VHT
    
    @@
    assignment operator op;
    expression status;
    @@
    -status->flag op RX_FLAG_STBC_MASK
    +status->enc_flags op RX_ENC_FLAG_STBC_MASK
    @@
    expression status;
    @@
    -status->flag & RX_FLAG_STBC_MASK
    +status->enc_flags & RX_ENC_FLAG_STBC_MASK
    
    @@
    assignment operator op;
    expression status;
    @@
    -status->flag op RX_FLAG_LDPC
    +status->enc_flags op RX_ENC_FLAG_LDPC
    @@
    expression status;
    @@
    -status->flag & RX_FLAG_LDPC
    +status->enc_flags & RX_ENC_FLAG_LDPC
    
    @@
    assignment operator op;
    expression status;
    @@
    -status->flag op RX_FLAG_10MHZ
    +status->enc_flags op RX_ENC_FLAG_10MHZ
    @@
    expression status;
    @@
    -status->flag & RX_FLAG_10MHZ
    +status->enc_flags & RX_ENC_FLAG_10MHZ
    
    @@
    assignment operator op;
    expression status;
    @@
    -status->flag op RX_FLAG_5MHZ
    +status->enc_flags op RX_ENC_FLAG_5MHZ
    @@
    expression status;
    @@
    -status->flag & RX_FLAG_5MHZ
    +status->enc_flags & RX_ENC_FLAG_5MHZ
    
    @@
    assignment operator op;
    expression status;
    @@
    -status->vht_flag op RX_VHT_FLAG_80MHZ
    +status->enc_flags op RX_ENC_FLAG_80MHZ
    @@
    expression status;
    @@
    -status->vht_flag & RX_VHT_FLAG_80MHZ
    +status->enc_flags & RX_ENC_FLAG_80MHZ
    
    @@
    assignment operator op;
    expression status;
    @@
    -status->vht_flag op RX_VHT_FLAG_160MHZ
    +status->enc_flags op RX_ENC_FLAG_160MHZ
    @@
    expression status;
    @@
    -status->vht_flag & RX_VHT_FLAG_160MHZ
    +status->enc_flags & RX_ENC_FLAG_160MHZ
    
    @@
    assignment operator op;
    expression status;
    @@
    -status->vht_flag op RX_VHT_FLAG_BF
    +status->enc_flags op RX_ENC_FLAG_BF
    @@
    expression status;
    @@
    -status->vht_flag & RX_VHT_FLAG_BF
    +status->enc_flags & RX_ENC_FLAG_BF
    
    @@
    assignment operator op;
    expression status, STBC;
    @@
    -status->flag op STBC << RX_FLAG_STBC_SHIFT
    +status->enc_flags op STBC << RX_ENC_FLAG_STBC_SHIFT
    
    @@
    assignment operator op;
    expression status;
    @@
    -status.flag op RX_FLAG_SHORTPRE
    +status.enc_flags op RX_ENC_FLAG_SHORTPRE
    @@
    expression status;
    @@
    -status.flag & RX_FLAG_SHORTPRE
    +status.enc_flags & RX_ENC_FLAG_SHORTPRE
    
    @@
    assignment operator op;
    expression status;
    @@
    -status.flag op RX_FLAG_HT
    +status.enc_flags op RX_ENC_FLAG_HT
    @@
    expression status;
    @@
    -status.flag & RX_FLAG_HT
    +status.enc_flags & RX_ENC_FLAG_HT
    
    @@
    assignment operator op;
    expression status;
    @@
    -status.flag op RX_FLAG_40MHZ
    +status.enc_flags op RX_ENC_FLAG_40MHZ
    @@
    expression status;
    @@
    -status.flag & RX_FLAG_40MHZ
    +status.enc_flags & RX_ENC_FLAG_40MHZ
    
    @@
    assignment operator op;
    expression status;
    @@
    -status.flag op RX_FLAG_SHORT_GI
    +status.enc_flags op RX_ENC_FLAG_SHORT_GI
    @@
    expression status;
    @@
    -status.flag & RX_FLAG_SHORT_GI
    +status.enc_flags & RX_ENC_FLAG_SHORT_GI
    
    @@
    assignment operator op;
    expression status;
    @@
    -status.flag op RX_FLAG_HT_GF
    +status.enc_flags op RX_ENC_FLAG_HT_GF
    @@
    expression status;
    @@
    -status.flag & RX_FLAG_HT_GF
    +status.enc_flags & RX_ENC_FLAG_HT_GF
    
    @@
    assignment operator op;
    expression status;
    @@
    -status.flag op RX_FLAG_VHT
    +status.enc_flags op RX_ENC_FLAG_VHT
    @@
    expression status;
    @@
    -status.flag & RX_FLAG_VHT
    +status.enc_flags & RX_ENC_FLAG_VHT
    
    @@
    assignment operator op;
    expression status;
    @@
    -status.flag op RX_FLAG_STBC_MASK
    +status.enc_flags op RX_ENC_FLAG_STBC_MASK
    @@
    expression status;
    @@
    -status.flag & RX_FLAG_STBC_MASK
    +status.enc_flags & RX_ENC_FLAG_STBC_MASK
    
    @@
    assignment operator op;
    expression status;
    @@
    -status.flag op RX_FLAG_LDPC
    +status.enc_flags op RX_ENC_FLAG_LDPC
    @@
    expression status;
    @@
    -status.flag & RX_FLAG_LDPC
    +status.enc_flags & RX_ENC_FLAG_LDPC
    
    @@
    assignment operator op;
    expression status;
    @@
    -status.flag op RX_FLAG_10MHZ
    +status.enc_flags op RX_ENC_FLAG_10MHZ
    @@
    expression status;
    @@
    -status.flag & RX_FLAG_10MHZ
    +status.enc_flags & RX_ENC_FLAG_10MHZ
    
    @@
    assignment operator op;
    expression status;
    @@
    -status.flag op RX_FLAG_5MHZ
    +status.enc_flags op RX_ENC_FLAG_5MHZ
    @@
    expression status;
    @@
    -status.flag & RX_FLAG_5MHZ
    +status.enc_flags & RX_ENC_FLAG_5MHZ
    
    @@
    assignment operator op;
    expression status;
    @@
    -status.vht_flag op RX_VHT_FLAG_80MHZ
    +status.enc_flags op RX_ENC_FLAG_80MHZ
    @@
    expression status;
    @@
    -status.vht_flag & RX_VHT_FLAG_80MHZ
    +status.enc_flags & RX_ENC_FLAG_80MHZ
    
    @@
    assignment operator op;
    expression status;
    @@
    -status.vht_flag op RX_VHT_FLAG_160MHZ
    +status.enc_flags op RX_ENC_FLAG_160MHZ
    @@
    expression status;
    @@
    -status.vht_flag & RX_VHT_FLAG_160MHZ
    +status.enc_flags & RX_ENC_FLAG_160MHZ
    
    @@
    assignment operator op;
    expression status;
    @@
    -status.vht_flag op RX_VHT_FLAG_BF
    +status.enc_flags op RX_ENC_FLAG_BF
    @@
    expression status;
    @@
    -status.vht_flag & RX_VHT_FLAG_BF
    +status.enc_flags & RX_ENC_FLAG_BF
    
    @@
    assignment operator op;
    expression status, STBC;
    @@
    -status.flag op STBC << RX_FLAG_STBC_SHIFT
    +status.enc_flags op STBC << RX_ENC_FLAG_STBC_SHIFT
    
    @@
    @@
    -RX_FLAG_STBC_SHIFT
    +RX_ENC_FLAG_STBC_SHIFT
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/drivers/net/wireless/ti/wl1251/rx.c b/drivers/net/wireless/ti/wl1251/rx.c
index a27d4c22b6e8..50fb2a4a5259 100644
--- a/drivers/net/wireless/ti/wl1251/rx.c
+++ b/drivers/net/wireless/ti/wl1251/rx.c
@@ -141,7 +141,7 @@ static void wl1251_rx_status(struct wl1251 *wl,
 	}
 
 	if (desc->mod_pre & SHORT_PREAMBLE_BIT)
-		status->flag |= RX_FLAG_SHORTPRE;
+		status->enc_flags |= RX_ENC_FLAG_SHORTPRE;
 }
 
 static void wl1251_rx_body(struct wl1251 *wl,

commit 57fbcce37be7c1d2622b56587c10ade00e96afa3
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Apr 12 15:56:15 2016 +0200

    cfg80211: remove enum ieee80211_band
    
    This enum is already perfectly aliased to enum nl80211_band, and
    the only reason for it is that we get IEEE80211_NUM_BANDS out of
    it. There's no really good reason to not declare the number of
    bands in nl80211 though, so do that and remove the cfg80211 one.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/drivers/net/wireless/ti/wl1251/rx.c b/drivers/net/wireless/ti/wl1251/rx.c
index cde0eaf99714..a27d4c22b6e8 100644
--- a/drivers/net/wireless/ti/wl1251/rx.c
+++ b/drivers/net/wireless/ti/wl1251/rx.c
@@ -53,7 +53,7 @@ static void wl1251_rx_status(struct wl1251 *wl,
 
 	memset(status, 0, sizeof(struct ieee80211_rx_status));
 
-	status->band = IEEE80211_BAND_2GHZ;
+	status->band = NL80211_BAND_2GHZ;
 	status->mactime = desc->timestamp;
 
 	/*

commit b6251243ac0a3cb63afe748133f6600f77526078
Author: Ivaylo Dimitrov <ivo.g.dimitrov.75@gmail.com>
Date:   Sat Mar 1 14:52:06 2014 +0200

    wl1251: use skb_trim to make skb shorter
    
    the current code is directly setting skb->len, which is not correct and
    brings problems with HAVE_EFFICIENT_UNALIGNED_ACCESS enabled in config
    
    Signed-off-by: Ivaylo Dimitrov <ivo.g.dimitrov.75@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ti/wl1251/rx.c b/drivers/net/wireless/ti/wl1251/rx.c
index 123c4bb50e0a..cde0eaf99714 100644
--- a/drivers/net/wireless/ti/wl1251/rx.c
+++ b/drivers/net/wireless/ti/wl1251/rx.c
@@ -180,7 +180,7 @@ static void wl1251_rx_body(struct wl1251 *wl,
 	wl1251_mem_read(wl, rx_packet_ring_addr, rx_buffer, length);
 
 	/* The actual length doesn't include the target's alignment */
-	skb->len = desc->length  - PLCP_HEADER_LENGTH;
+	skb_trim(skb, desc->length - PLCP_HEADER_LENGTH);
 
 	fc = (u16 *)skb->data;
 

commit 4d09b5378defd4ef685f9d33e0d35b380109eafa
Author: David Gnedt <david.gnedt@davizone.at>
Date:   Tue Jan 7 13:07:52 2014 +0100

    wl1251: configure hardware en-/decryption for monitor mode
    
    Disable hardware encryption (DF_ENCRYPTION_DISABLE) and decryption
    (DF_SNIFF_MODE_ENABLE) via wl1251_acx_feature_cfg while monitor interface is
    present.
    
    Signed-off-by: David Gnedt <david.gnedt@davizone.at>
    Signed-off-by: Pali Roh√°r <pali.rohar@gmail.com>
    Signed-off-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ti/wl1251/rx.c b/drivers/net/wireless/ti/wl1251/rx.c
index 23289d49dd31..123c4bb50e0a 100644
--- a/drivers/net/wireless/ti/wl1251/rx.c
+++ b/drivers/net/wireless/ti/wl1251/rx.c
@@ -83,7 +83,7 @@ static void wl1251_rx_status(struct wl1251 *wl,
 
 	status->flag |= RX_FLAG_MACTIME_START;
 
-	if (desc->flags & RX_DESC_ENCRYPTION_MASK) {
+	if (!wl->monitor_present && (desc->flags & RX_DESC_ENCRYPTION_MASK)) {
 		status->flag |= RX_FLAG_IV_STRIPPED | RX_FLAG_MMIC_STRIPPED;
 
 		if (likely(!(desc->flags & RX_DESC_DECRYPT_FAIL)))

commit f4bda337bbb6e245e2a07f344990adeb6a70ff35
Author: Thomas Pedersen <thomas@cozybit.com>
Date:   Tue Nov 13 10:46:27 2012 -0800

    mac80211: support RX_FLAG_MACTIME_END
    
    Allow drivers to indicate their mactime is at RX completion and adjust
    for this in mac80211. Also rename the existing RX_FLAG_MACTIME_MPDU to
    RX_FLAG_MACTIME_START to clarify its intent. Based on similar code by
    Johannes Berg.
    
    Signed-off-by: Thomas Pedersen <thomas@cozybit.com>
    [fix docs, atheros drivers]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/drivers/net/wireless/ti/wl1251/rx.c b/drivers/net/wireless/ti/wl1251/rx.c
index 6af35265c900..23289d49dd31 100644
--- a/drivers/net/wireless/ti/wl1251/rx.c
+++ b/drivers/net/wireless/ti/wl1251/rx.c
@@ -81,7 +81,7 @@ static void wl1251_rx_status(struct wl1251 *wl,
 	status->freq = ieee80211_channel_to_frequency(desc->channel,
 						      status->band);
 
-	status->flag |= RX_FLAG_MACTIME_MPDU;
+	status->flag |= RX_FLAG_MACTIME_START;
 
 	if (desc->flags & RX_DESC_ENCRYPTION_MASK) {
 		status->flag |= RX_FLAG_IV_STRIPPED | RX_FLAG_MMIC_STRIPPED;

commit 90921014608d91a03766d0025fa32662dc7c5062
Author: Luciano Coelho <coelho@ti.com>
Date:   Sun Nov 20 21:40:41 2011 +0200

    wireless/wl12xx/wl1251: move TI WLAN modules to a common ti subdirectory
    
    Move wl12xx and wl1251 modules into a new drivers/net/wireless/ti
    directory.  Add a TI WLAN Kconfig option and Makefile to support this
    change.
    
    Signed-off-by: Luciano Coelho <coelho@ti.com>
    Cc: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ti/wl1251/rx.c b/drivers/net/wireless/ti/wl1251/rx.c
new file mode 100644
index 000000000000..6af35265c900
--- /dev/null
+++ b/drivers/net/wireless/ti/wl1251/rx.c
@@ -0,0 +1,235 @@
+/*
+ * This file is part of wl1251
+ *
+ * Copyright (c) 1998-2007 Texas Instruments Incorporated
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/skbuff.h>
+#include <linux/gfp.h>
+#include <net/mac80211.h>
+
+#include "wl1251.h"
+#include "reg.h"
+#include "io.h"
+#include "rx.h"
+#include "cmd.h"
+#include "acx.h"
+
+static void wl1251_rx_header(struct wl1251 *wl,
+			     struct wl1251_rx_descriptor *desc)
+{
+	u32 rx_packet_ring_addr;
+
+	rx_packet_ring_addr = wl->data_path->rx_packet_ring_addr;
+	if (wl->rx_current_buffer)
+		rx_packet_ring_addr += wl->data_path->rx_packet_ring_chunk_size;
+
+	wl1251_mem_read(wl, rx_packet_ring_addr, desc, sizeof(*desc));
+}
+
+static void wl1251_rx_status(struct wl1251 *wl,
+			     struct wl1251_rx_descriptor *desc,
+			     struct ieee80211_rx_status *status,
+			     u8 beacon)
+{
+	u64 mactime;
+	int ret;
+
+	memset(status, 0, sizeof(struct ieee80211_rx_status));
+
+	status->band = IEEE80211_BAND_2GHZ;
+	status->mactime = desc->timestamp;
+
+	/*
+	 * The rx status timestamp is a 32 bits value while the TSF is a
+	 * 64 bits one.
+	 * For IBSS merging, TSF is mandatory, so we have to get it
+	 * somehow, so we ask for ACX_TSF_INFO.
+	 * That could be moved to the get_tsf() hook, but unfortunately,
+	 * this one must be atomic, while our SPI routines can sleep.
+	 */
+	if ((wl->bss_type == BSS_TYPE_IBSS) && beacon) {
+		ret = wl1251_acx_tsf_info(wl, &mactime);
+		if (ret == 0)
+			status->mactime = mactime;
+	}
+
+	status->signal = desc->rssi;
+
+	/*
+	 * FIXME: guessing that snr needs to be divided by two, otherwise
+	 * the values don't make any sense
+	 */
+	wl->noise = desc->rssi - desc->snr / 2;
+
+	status->freq = ieee80211_channel_to_frequency(desc->channel,
+						      status->band);
+
+	status->flag |= RX_FLAG_MACTIME_MPDU;
+
+	if (desc->flags & RX_DESC_ENCRYPTION_MASK) {
+		status->flag |= RX_FLAG_IV_STRIPPED | RX_FLAG_MMIC_STRIPPED;
+
+		if (likely(!(desc->flags & RX_DESC_DECRYPT_FAIL)))
+			status->flag |= RX_FLAG_DECRYPTED;
+
+		if (unlikely(desc->flags & RX_DESC_MIC_FAIL))
+			status->flag |= RX_FLAG_MMIC_ERROR;
+	}
+
+	if (unlikely(!(desc->flags & RX_DESC_VALID_FCS)))
+		status->flag |= RX_FLAG_FAILED_FCS_CRC;
+
+	switch (desc->rate) {
+		/* skip 1 and 12 Mbps because they have same value 0x0a */
+	case RATE_2MBPS:
+		status->rate_idx = 1;
+		break;
+	case RATE_5_5MBPS:
+		status->rate_idx = 2;
+		break;
+	case RATE_11MBPS:
+		status->rate_idx = 3;
+		break;
+	case RATE_6MBPS:
+		status->rate_idx = 4;
+		break;
+	case RATE_9MBPS:
+		status->rate_idx = 5;
+		break;
+	case RATE_18MBPS:
+		status->rate_idx = 7;
+		break;
+	case RATE_24MBPS:
+		status->rate_idx = 8;
+		break;
+	case RATE_36MBPS:
+		status->rate_idx = 9;
+		break;
+	case RATE_48MBPS:
+		status->rate_idx = 10;
+		break;
+	case RATE_54MBPS:
+		status->rate_idx = 11;
+		break;
+	}
+
+	/* for 1 and 12 Mbps we have to check the modulation */
+	if (desc->rate == RATE_1MBPS) {
+		if (!(desc->mod_pre & OFDM_RATE_BIT))
+			/* CCK -> RATE_1MBPS */
+			status->rate_idx = 0;
+		else
+			/* OFDM -> RATE_12MBPS */
+			status->rate_idx = 6;
+	}
+
+	if (desc->mod_pre & SHORT_PREAMBLE_BIT)
+		status->flag |= RX_FLAG_SHORTPRE;
+}
+
+static void wl1251_rx_body(struct wl1251 *wl,
+			   struct wl1251_rx_descriptor *desc)
+{
+	struct sk_buff *skb;
+	struct ieee80211_rx_status status;
+	u8 *rx_buffer, beacon = 0;
+	u16 length, *fc;
+	u32 curr_id, last_id_inc, rx_packet_ring_addr;
+
+	length = WL1251_RX_ALIGN(desc->length  - PLCP_HEADER_LENGTH);
+	curr_id = (desc->flags & RX_DESC_SEQNUM_MASK) >> RX_DESC_PACKETID_SHIFT;
+	last_id_inc = (wl->rx_last_id + 1) % (RX_MAX_PACKET_ID + 1);
+
+	if (last_id_inc != curr_id) {
+		wl1251_warning("curr ID:%d, last ID inc:%d",
+			       curr_id, last_id_inc);
+		wl->rx_last_id = curr_id;
+	} else {
+		wl->rx_last_id = last_id_inc;
+	}
+
+	rx_packet_ring_addr = wl->data_path->rx_packet_ring_addr +
+		sizeof(struct wl1251_rx_descriptor) + 20;
+	if (wl->rx_current_buffer)
+		rx_packet_ring_addr += wl->data_path->rx_packet_ring_chunk_size;
+
+	skb = __dev_alloc_skb(length, GFP_KERNEL);
+	if (!skb) {
+		wl1251_error("Couldn't allocate RX frame");
+		return;
+	}
+
+	rx_buffer = skb_put(skb, length);
+	wl1251_mem_read(wl, rx_packet_ring_addr, rx_buffer, length);
+
+	/* The actual length doesn't include the target's alignment */
+	skb->len = desc->length  - PLCP_HEADER_LENGTH;
+
+	fc = (u16 *)skb->data;
+
+	if ((*fc & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_BEACON)
+		beacon = 1;
+
+	wl1251_rx_status(wl, desc, &status, beacon);
+
+	wl1251_debug(DEBUG_RX, "rx skb 0x%p: %d B %s", skb, skb->len,
+		     beacon ? "beacon" : "");
+
+	memcpy(IEEE80211_SKB_RXCB(skb), &status, sizeof(status));
+	ieee80211_rx_ni(wl->hw, skb);
+}
+
+static void wl1251_rx_ack(struct wl1251 *wl)
+{
+	u32 data, addr;
+
+	if (wl->rx_current_buffer) {
+		addr = ACX_REG_INTERRUPT_TRIG_H;
+		data = INTR_TRIG_RX_PROC1;
+	} else {
+		addr = ACX_REG_INTERRUPT_TRIG;
+		data = INTR_TRIG_RX_PROC0;
+	}
+
+	wl1251_reg_write32(wl, addr, data);
+
+	/* Toggle buffer ring */
+	wl->rx_current_buffer = !wl->rx_current_buffer;
+}
+
+
+void wl1251_rx(struct wl1251 *wl)
+{
+	struct wl1251_rx_descriptor *rx_desc;
+
+	if (wl->state != WL1251_STATE_ON)
+		return;
+
+	rx_desc = wl->rx_descriptor;
+
+	/* We first read the frame's header */
+	wl1251_rx_header(wl, rx_desc);
+
+	/* Now we can read the body */
+	wl1251_rx_body(wl, rx_desc);
+
+	/* Finally, we need to ACK the RX */
+	wl1251_rx_ack(wl);
+}
