commit 2b27bdcc20958d644d04f9f12d683e52b37a5427
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:50 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 336
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 51 franklin st fifth floor boston ma 02110
      1301 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 246 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000436.674189849@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/wireless/ti/wl18xx/acx.h b/drivers/net/wireless/ti/wl18xx/acx.h
index 2edbbbfd8421..cba195911978 100644
--- a/drivers/net/wireless/ti/wl18xx/acx.h
+++ b/drivers/net/wireless/ti/wl18xx/acx.h
@@ -1,22 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * This file is part of wl18xx
  *
  * Copyright (C) 2011 Texas Instruments. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
  */
 
 #ifndef __WL18XX_ACX_H__

commit c5aa9541818a1aacf05ab9a30c3f525841cdc1c9
Author: Guy Mishol <guym@ti.com>
Date:   Wed Aug 24 14:35:27 2016 +0300

    wl18xx: add time sync configuration api
    
    Add time sync configuration api.
    The new api allows to configure the synchronization
    mode (STA/AP/MESH) and (in case of Mesh mode) the
    master address of each zone.
    
    Signed-off-by: Guy Mishol <guym@ti.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/ti/wl18xx/acx.h b/drivers/net/wireless/ti/wl18xx/acx.h
index 342a2993ef98..2edbbbfd8421 100644
--- a/drivers/net/wireless/ti/wl18xx/acx.h
+++ b/drivers/net/wireless/ti/wl18xx/acx.h
@@ -37,6 +37,7 @@ enum {
 	ACX_RX_BA_FILTER		 = 0x0058,
 	ACX_AP_SLEEP_CFG                 = 0x0059,
 	ACX_DYNAMIC_TRACES_CFG		 = 0x005A,
+	ACX_TIME_SYNC_CFG		 = 0x005B,
 };
 
 /* numbers of bits the length field takes (add 1 for the actual number) */
@@ -388,6 +389,17 @@ struct acx_dynamic_fw_traces_cfg {
 	__le32 dynamic_fw_traces;
 } __packed;
 
+/*
+ * ACX_TIME_SYNC_CFG
+ * configure the time sync parameters
+ */
+struct acx_time_sync_cfg {
+	struct acx_header header;
+	u8 sync_mode;
+	u8 zone_mac_addr[ETH_ALEN];
+	u8 padding[1];
+} __packed;
+
 int wl18xx_acx_host_if_cfg_bitmap(struct wl1271 *wl, u32 host_cfg_bitmap,
 				  u32 sdio_blk_size, u32 extra_mem_blks,
 				  u32 len_field_size);
@@ -402,5 +414,6 @@ int wl18xx_acx_interrupt_notify_config(struct wl1271 *wl, bool action);
 int wl18xx_acx_rx_ba_filter(struct wl1271 *wl, bool action);
 int wl18xx_acx_ap_sleep(struct wl1271 *wl);
 int wl18xx_acx_dynamic_fw_traces(struct wl1271 *wl);
+int wl18xx_acx_time_sync_cfg(struct wl1271 *wl);
 
 #endif /* __WL18XX_ACX_H__ */

commit fc645df093926d8cd33a9dd9b6532ff3fd937193
Author: Guy Mishol <guym@ti.com>
Date:   Tue Aug 11 10:02:57 2015 +0300

    wl18xx: add diversity statistics
    
    Add diversity statistics and sync the driver
    statistics acx and debugfs representation
    with the current fw api.
    
    Signed-off-by: Guy Mishol <guym@ti.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/ti/wl18xx/acx.h b/drivers/net/wireless/ti/wl18xx/acx.h
index 6c5fef33b0be..342a2993ef98 100644
--- a/drivers/net/wireless/ti/wl18xx/acx.h
+++ b/drivers/net/wireless/ti/wl18xx/acx.h
@@ -112,20 +112,6 @@ struct wl18xx_acx_error_stats {
 	u32 tbc_exch_mismatch;
 } __packed;
 
-struct wl18xx_acx_debug_stats {
-	u32 debug1;
-	u32 debug2;
-	u32 debug3;
-	u32 debug4;
-	u32 debug5;
-	u32 debug6;
-} __packed;
-
-struct wl18xx_acx_ring_stats {
-	u32 prepared_descs;
-	u32 tx_cmplt;
-} __packed;
-
 #define NUM_OF_RATES_INDEXES 30
 struct wl18xx_acx_tx_stats {
 	u32 tx_prepared_descs;
@@ -215,21 +201,6 @@ struct wl18xx_acx_pwr_stats {
 	u32 ap_sleep_counter;
 } __packed;
 
-struct wl18xx_acx_event_stats {
-	u32 calibration;
-	u32 rx_mismatch;
-	u32 rx_mem_empty;
-} __packed;
-
-struct wl18xx_acx_ps_poll_stats {
-	u32 ps_poll_timeouts;
-	u32 upsd_timeouts;
-	u32 upsd_max_ap_turn;
-	u32 ps_poll_max_ap_turn;
-	u32 ps_poll_utilization;
-	u32 upsd_utilization;
-} __packed;
-
 struct wl18xx_acx_rx_filter_stats {
 	u32 beacon_filter;
 	u32 arp_filter;
@@ -260,8 +231,6 @@ struct wl18xx_acx_aggr_stats {
 struct wl18xx_acx_pipeline_stats {
 	u32 hs_tx_stat_fifo_int;
 	u32 hs_rx_stat_fifo_int;
-	u32 tcp_tx_stat_fifo_int;
-	u32 tcp_rx_stat_fifo_int;
 	u32 enc_tx_stat_fifo_int;
 	u32 enc_rx_stat_fifo_int;
 	u32 rx_complete_stat_fifo_int;
@@ -269,22 +238,19 @@ struct wl18xx_acx_pipeline_stats {
 	u32 post_proc_swi;
 	u32 sec_frag_swi;
 	u32 pre_to_defrag_swi;
-	u32 defrag_to_csum_swi;
-	u32 csum_to_rx_xfer_swi;
+	u32 defrag_to_rx_xfer_swi;
 	u32 dec_packet_in;
 	u32 dec_packet_in_fifo_full;
 	u32 dec_packet_out;
-	u32 cs_rx_packet_in;
-	u32 cs_rx_packet_out;
 	u16 pipeline_fifo_full[PIPE_STATS_HW_FIFO];
 	u16 padding;
 } __packed;
 
-struct wl18xx_acx_mem_stats {
-	u32 rx_free_mem_blks;
-	u32 tx_free_mem_blks;
-	u32 fwlog_free_mem_blks;
-	u32 fw_gen_free_mem_blks;
+#define DIVERSITY_STATS_NUM_OF_ANT	2
+
+struct wl18xx_acx_diversity_stats {
+	u32 num_of_packets_per_ant[DIVERSITY_STATS_NUM_OF_ANT];
+	u32 total_num_of_toggles;
 } __packed;
 
 struct wl18xx_acx_thermal_stats {
@@ -322,6 +288,7 @@ struct wl18xx_acx_statistics {
 	struct wl18xx_acx_rx_rate_stats		rx_rate;
 	struct wl18xx_acx_aggr_stats		aggr_size;
 	struct wl18xx_acx_pipeline_stats	pipeline;
+	struct wl18xx_acx_diversity_stats	diversity;
 	struct wl18xx_acx_thermal_stats		thermal;
 	struct wl18xx_acx_calib_failure_stats	calib;
 	struct wl18xx_roaming_stats		roaming;

commit c48276cbbeaedd49cdf32f2b734b4a1ec6d6ccad
Author: Eliad Peller <eliad@wizery.com>
Date:   Tue Aug 11 10:02:56 2015 +0300

    wl18xx: update statistics acx and debugfs files
    
    Sync the driver statistics acx and debugfs representation
    with the current fw api.
    
    Signed-off-by: Eliad Peller <eliad@wizery.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/ti/wl18xx/acx.h b/drivers/net/wireless/ti/wl18xx/acx.h
index c8a33f43916e..6c5fef33b0be 100644
--- a/drivers/net/wireless/ti/wl18xx/acx.h
+++ b/drivers/net/wireless/ti/wl18xx/acx.h
@@ -93,11 +93,23 @@ struct wl18xx_acx_checksum_state {
 
 
 struct wl18xx_acx_error_stats {
-	u32 error_frame;
-	u32 error_null_Frame_tx_start;
-	u32 error_numll_frame_cts_start;
-	u32 error_bar_retry;
-	u32 error_frame_cts_nul_flid;
+	u32 error_frame_non_ctrl;
+	u32 error_frame_ctrl;
+	u32 error_frame_during_protection;
+	u32 null_frame_tx_start;
+	u32 null_frame_cts_start;
+	u32 bar_retry;
+	u32 num_frame_cts_nul_flid;
+	u32 tx_abort_failure;
+	u32 tx_resume_failure;
+	u32 rx_cmplt_db_overflow_cnt;
+	u32 elp_while_rx_exch;
+	u32 elp_while_tx_exch;
+	u32 elp_while_tx;
+	u32 elp_while_nvic_pending;
+	u32 rx_excessive_frame_len;
+	u32 burst_mismatch;
+	u32 tbc_exch_mismatch;
 } __packed;
 
 struct wl18xx_acx_debug_stats {
@@ -114,6 +126,7 @@ struct wl18xx_acx_ring_stats {
 	u32 tx_cmplt;
 } __packed;
 
+#define NUM_OF_RATES_INDEXES 30
 struct wl18xx_acx_tx_stats {
 	u32 tx_prepared_descs;
 	u32 tx_cmplt;
@@ -123,7 +136,7 @@ struct wl18xx_acx_tx_stats {
 	u32 tx_data_programmed;
 	u32 tx_burst_programmed;
 	u32 tx_starts;
-	u32 tx_imm_resp;
+	u32 tx_stop;
 	u32 tx_start_templates;
 	u32 tx_start_int_templates;
 	u32 tx_start_fw_gen;
@@ -132,13 +145,14 @@ struct wl18xx_acx_tx_stats {
 	u32 tx_exch;
 	u32 tx_retry_template;
 	u32 tx_retry_data;
+	u32 tx_retry_per_rate[NUM_OF_RATES_INDEXES];
 	u32 tx_exch_pending;
 	u32 tx_exch_expiry;
 	u32 tx_done_template;
 	u32 tx_done_data;
 	u32 tx_done_int_template;
-	u32 tx_frame_checksum;
-	u32 tx_checksum_result;
+	u32 tx_cfe1;
+	u32 tx_cfe2;
 	u32 frag_called;
 	u32 frag_mpdu_alloc_failed;
 	u32 frag_init_called;
@@ -166,11 +180,8 @@ struct wl18xx_acx_rx_stats {
 	u32 rx_cmplt_task;
 	u32 rx_phy_hdr;
 	u32 rx_timeout;
+	u32 rx_rts_timeout;
 	u32 rx_timeout_wa;
-	u32 rx_wa_density_dropped_frame;
-	u32 rx_wa_ba_not_expected;
-	u32 rx_frame_checksum;
-	u32 rx_checksum_result;
 	u32 defrag_called;
 	u32 defrag_init_called;
 	u32 defrag_in_process_called;
@@ -180,6 +191,7 @@ struct wl18xx_acx_rx_stats {
 	u32 decrypt_key_not_found;
 	u32 defrag_need_decrypt;
 	u32 rx_tkip_replays;
+	u32 rx_xfr;
 } __packed;
 
 struct wl18xx_acx_isr_stats {
@@ -194,6 +206,13 @@ struct wl18xx_acx_pwr_stats {
 	u32 connection_out_of_sync;
 	u32 cont_miss_bcns_spread[PWR_STAT_MAX_CONT_MISSED_BCNS_SPREAD];
 	u32 rcvd_awake_bcns_cnt;
+	u32 sleep_time_count;
+	u32 sleep_time_avg;
+	u32 sleep_cycle_avg;
+	u32 sleep_percent;
+	u32 ap_sleep_active_conf;
+	u32 ap_sleep_user_conf;
+	u32 ap_sleep_counter;
 } __packed;
 
 struct wl18xx_acx_event_stats {
@@ -228,11 +247,11 @@ struct wl18xx_acx_rx_rate_stats {
 } __packed;
 
 #define AGGR_STATS_TX_AGG	16
-#define AGGR_STATS_TX_RATE	16
 #define AGGR_STATS_RX_SIZE_LEN	16
 
 struct wl18xx_acx_aggr_stats {
-	u32 tx_agg_vs_rate[AGGR_STATS_TX_AGG * AGGR_STATS_TX_RATE];
+	u32 tx_agg_rate[AGGR_STATS_TX_AGG];
+	u32 tx_agg_len[AGGR_STATS_TX_AGG];
 	u32 rx_size[AGGR_STATS_RX_SIZE_LEN];
 } __packed;
 
@@ -258,6 +277,7 @@ struct wl18xx_acx_pipeline_stats {
 	u32 cs_rx_packet_in;
 	u32 cs_rx_packet_out;
 	u16 pipeline_fifo_full[PIPE_STATS_HW_FIFO];
+	u16 padding;
 } __packed;
 
 struct wl18xx_acx_mem_stats {
@@ -267,21 +287,45 @@ struct wl18xx_acx_mem_stats {
 	u32 fw_gen_free_mem_blks;
 } __packed;
 
+struct wl18xx_acx_thermal_stats {
+	u16 irq_thr_low;
+	u16 irq_thr_high;
+	u16 tx_stop;
+	u16 tx_resume;
+	u16 false_irq;
+	u16 adc_source_unexpected;
+} __packed;
+
+#define WL18XX_NUM_OF_CALIBRATIONS_ERRORS 18
+struct wl18xx_acx_calib_failure_stats {
+	u16 fail_count[WL18XX_NUM_OF_CALIBRATIONS_ERRORS];
+	u32 calib_count;
+} __packed;
+
+struct wl18xx_roaming_stats {
+	s32 rssi_level;
+} __packed;
+
+struct wl18xx_dfs_stats {
+	u32 num_of_radar_detections;
+} __packed;
+
 struct wl18xx_acx_statistics {
 	struct acx_header header;
 
 	struct wl18xx_acx_error_stats		error;
-	struct wl18xx_acx_debug_stats		debug;
 	struct wl18xx_acx_tx_stats		tx;
 	struct wl18xx_acx_rx_stats		rx;
 	struct wl18xx_acx_isr_stats		isr;
 	struct wl18xx_acx_pwr_stats		pwr;
-	struct wl18xx_acx_ps_poll_stats		ps_poll;
 	struct wl18xx_acx_rx_filter_stats	rx_filter;
 	struct wl18xx_acx_rx_rate_stats		rx_rate;
 	struct wl18xx_acx_aggr_stats		aggr_size;
 	struct wl18xx_acx_pipeline_stats	pipeline;
-	struct wl18xx_acx_mem_stats		mem;
+	struct wl18xx_acx_thermal_stats		thermal;
+	struct wl18xx_acx_calib_failure_stats	calib;
+	struct wl18xx_roaming_stats		roaming;
+	struct wl18xx_dfs_stats			dfs;
 } __packed;
 
 struct wl18xx_acx_clear_statistics {

commit d1c5409612ad25d8a35a49a89ad302fc797eeb8e
Author: Guy Mishol <guym@ti.com>
Date:   Mon Jul 27 09:46:02 2015 +0300

    wl18xx: add dynamic fw traces
    
    add option to dynamically configure the fw
    which debug traces to open
    
    Signed-off-by: Guy Mishol <guym@ti.com>
    Signed-off-by: Eliad Peller <eliad@wizery.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/ti/wl18xx/acx.h b/drivers/net/wireless/ti/wl18xx/acx.h
index 4afccd4b9467..c8a33f43916e 100644
--- a/drivers/net/wireless/ti/wl18xx/acx.h
+++ b/drivers/net/wireless/ti/wl18xx/acx.h
@@ -35,7 +35,8 @@ enum {
 	ACX_PEER_CAP			 = 0x0056,
 	ACX_INTERRUPT_NOTIFY		 = 0x0057,
 	ACX_RX_BA_FILTER		 = 0x0058,
-	ACX_AP_SLEEP_CFG                 = 0x0059
+	ACX_AP_SLEEP_CFG                 = 0x0059,
+	ACX_DYNAMIC_TRACES_CFG		 = 0x005A,
 };
 
 /* numbers of bits the length field takes (add 1 for the actual number) */
@@ -367,6 +368,15 @@ struct acx_ap_sleep_cfg {
 	u8 idle_conn_thresh;
 } __packed;
 
+/*
+ * ACX_DYNAMIC_TRACES_CFG
+ * configure the FW dynamic traces
+ */
+struct acx_dynamic_fw_traces_cfg {
+	struct acx_header header;
+	__le32 dynamic_fw_traces;
+} __packed;
+
 int wl18xx_acx_host_if_cfg_bitmap(struct wl1271 *wl, u32 host_cfg_bitmap,
 				  u32 sdio_blk_size, u32 extra_mem_blks,
 				  u32 len_field_size);
@@ -380,5 +390,6 @@ int wl18xx_acx_set_peer_cap(struct wl1271 *wl,
 int wl18xx_acx_interrupt_notify_config(struct wl1271 *wl, bool action);
 int wl18xx_acx_rx_ba_filter(struct wl1271 *wl, bool action);
 int wl18xx_acx_ap_sleep(struct wl1271 *wl);
+int wl18xx_acx_dynamic_fw_traces(struct wl1271 *wl);
 
 #endif /* __WL18XX_ACX_H__ */

commit e2f1e50f62ae70c7ddde8420ed586c6a1aa1e28c
Author: Kobi L <kobi.lev100@gmail.com>
Date:   Mon Dec 29 08:24:06 2014 +0200

    wlcore: enable sleep during AP mode operation
    
    Enable ELP authorization in AP mode and enable the use
    of the wakeup bit in the ELP register.
    
    Introduce AP role sleep configuration which is disabled
    by default. When configured, it allows the AP to sleep
    when ELP is authorized for it.
    
    Signed-off-by: Kobi Leibovitch <kobi.lev100@gmail.com>
    Signed-off-by: Arik Nemtsov <arik@wizery.com>
    Signed-off-by: Eliad Peller <eliad@wizery.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/ti/wl18xx/acx.h b/drivers/net/wireless/ti/wl18xx/acx.h
index 1234bdc6d1b9..4afccd4b9467 100644
--- a/drivers/net/wireless/ti/wl18xx/acx.h
+++ b/drivers/net/wireless/ti/wl18xx/acx.h
@@ -34,8 +34,8 @@ enum {
 	ACX_AUTO_RX_STREAMING		 = 0x0055,
 	ACX_PEER_CAP			 = 0x0056,
 	ACX_INTERRUPT_NOTIFY		 = 0x0057,
-	ACX_RX_BA_FILTER		 = 0x0058
-
+	ACX_RX_BA_FILTER		 = 0x0058,
+	ACX_AP_SLEEP_CFG                 = 0x0059
 };
 
 /* numbers of bits the length field takes (add 1 for the actual number) */
@@ -347,6 +347,26 @@ struct wl18xx_acx_rx_ba_filter {
 	u32 enable;
 };
 
+struct acx_ap_sleep_cfg {
+	struct acx_header header;
+	/* Duty Cycle (20-80% of staying Awake) for IDLE AP
+	 * (0: disable)
+	 */
+	u8 idle_duty_cycle;
+	/* Duty Cycle (20-80% of staying Awake) for Connected AP
+	 * (0: disable)
+	 */
+	u8 connected_duty_cycle;
+	/* Maximum stations that are allowed to be connected to AP
+	 *  (255: no limit)
+	 */
+	u8 max_stations_thresh;
+	/* Timeout till enabling the Sleep Mechanism after data stops
+	 * [unit: 100 msec]
+	 */
+	u8 idle_conn_thresh;
+} __packed;
+
 int wl18xx_acx_host_if_cfg_bitmap(struct wl1271 *wl, u32 host_cfg_bitmap,
 				  u32 sdio_blk_size, u32 extra_mem_blks,
 				  u32 len_field_size);
@@ -359,5 +379,6 @@ int wl18xx_acx_set_peer_cap(struct wl1271 *wl,
 			    u32 rate_set, u8 hlid);
 int wl18xx_acx_interrupt_notify_config(struct wl1271 *wl, bool action);
 int wl18xx_acx_rx_ba_filter(struct wl1271 *wl, bool action);
+int wl18xx_acx_ap_sleep(struct wl1271 *wl);
 
 #endif /* __WL18XX_ACX_H__ */

commit 6d5a748d4836ddd0ca626fe4870942a0e90a5c3d
Author: Ram Amrani <ramrani@ti.com>
Date:   Mon Dec 29 08:24:04 2014 +0200

    wlcore: add ability to reduce FW interrupts during suspend
    
    Add the ability to mask FW interrupts on RX BA activity, PSM
    entry/exit and fast-link notifications. This is used when the host
    is suspended in order to decrease redundant wake ups.
    
    Signed-off-by: Ram Amrani <ramrani@ti.com>
    Signed-off-by: Arik Nemtsov <arik@wizery.com>
    Signed-off-by: Eliad Peller <eliad@wizery.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/ti/wl18xx/acx.h b/drivers/net/wireless/ti/wl18xx/acx.h
index 0e636def1217..1234bdc6d1b9 100644
--- a/drivers/net/wireless/ti/wl18xx/acx.h
+++ b/drivers/net/wireless/ti/wl18xx/acx.h
@@ -32,7 +32,10 @@ enum {
 	ACX_SIM_CONFIG			 = 0x0053,
 	ACX_CLEAR_STATISTICS		 = 0x0054,
 	ACX_AUTO_RX_STREAMING		 = 0x0055,
-	ACX_PEER_CAP			 = 0x0056
+	ACX_PEER_CAP			 = 0x0056,
+	ACX_INTERRUPT_NOTIFY		 = 0x0057,
+	ACX_RX_BA_FILTER		 = 0x0058
+
 };
 
 /* numbers of bits the length field takes (add 1 for the actual number) */
@@ -326,6 +329,24 @@ struct wlcore_acx_peer_cap {
 	u8 padding;
 } __packed;
 
+/*
+ * ACX_INTERRUPT_NOTIFY
+ * enable/disable fast-link/PSM notification from FW
+ */
+struct wl18xx_acx_interrupt_notify {
+	struct acx_header header;
+	u32 enable;
+};
+
+/*
+ * ACX_RX_BA_FILTER
+ * enable/disable RX BA filtering in FW
+ */
+struct wl18xx_acx_rx_ba_filter {
+	struct acx_header header;
+	u32 enable;
+};
+
 int wl18xx_acx_host_if_cfg_bitmap(struct wl1271 *wl, u32 host_cfg_bitmap,
 				  u32 sdio_blk_size, u32 extra_mem_blks,
 				  u32 len_field_size);
@@ -336,5 +357,7 @@ int wl18xx_acx_set_peer_cap(struct wl1271 *wl,
 			    struct ieee80211_sta_ht_cap *ht_cap,
 			    bool allow_ht_operation,
 			    u32 rate_set, u8 hlid);
+int wl18xx_acx_interrupt_notify_config(struct wl1271 *wl, bool action);
+int wl18xx_acx_rx_ba_filter(struct wl1271 *wl, bool action);
 
 #endif /* __WL18XX_ACX_H__ */

commit 530abe195df6918d43c9381fd9a70b7e16d55036
Author: Eliad Peller <eliad@wizery.com>
Date:   Wed Nov 28 11:42:31 2012 +0200

    wlcore: add ACX_PEER_CAP command
    
    ACX_PEER_CAP command is just ACX_PEER_HT_CAP, but allows
    configuring the peer's support rates as well.
    
    this is needed because we start the station role when
    the remote rates are not known yet.
    
    the two commands should be unified in future fw versions,
    but for now add a new set_peer_cap per-hw op, that will
    use ACX_PEER_CAP for 18xx, and ACX_PEER_HT_CAP for 12xx.
    
    Signed-off-by: Eliad Peller <eliad@wizery.com>
    Signed-off-by: Arik Nemtsov <arik@wizery.com>
    Signed-off-by: Luciano Coelho <coelho@ti.com>

diff --git a/drivers/net/wireless/ti/wl18xx/acx.h b/drivers/net/wireless/ti/wl18xx/acx.h
index b57e3483509d..0e636def1217 100644
--- a/drivers/net/wireless/ti/wl18xx/acx.h
+++ b/drivers/net/wireless/ti/wl18xx/acx.h
@@ -297,11 +297,44 @@ struct wlcore_peer_ht_operation_mode {
 	u8 padding[2];
 };
 
+/*
+ * ACX_PEER_CAP
+ * this struct is very similar to wl1271_acx_ht_capabilities, with the
+ * addition of supported rates
+ */
+struct wlcore_acx_peer_cap {
+	struct acx_header header;
+
+	/* bitmask of capability bits supported by the peer */
+	__le32 ht_capabilites;
+
+	/* rates supported by the remote peer */
+	__le32 supported_rates;
+
+	/* Indicates to which link these capabilities apply. */
+	u8 hlid;
+
+	/*
+	 * This the maximum A-MPDU length supported by the AP. The FW may not
+	 * exceed this length when sending A-MPDUs
+	 */
+	u8 ampdu_max_length;
+
+	/* This is the minimal spacing required when sending A-MPDUs to the AP*/
+	u8 ampdu_min_spacing;
+
+	u8 padding;
+} __packed;
+
 int wl18xx_acx_host_if_cfg_bitmap(struct wl1271 *wl, u32 host_cfg_bitmap,
 				  u32 sdio_blk_size, u32 extra_mem_blks,
 				  u32 len_field_size);
 int wl18xx_acx_set_checksum_state(struct wl1271 *wl);
 int wl18xx_acx_clear_statistics(struct wl1271 *wl);
 int wl18xx_acx_peer_ht_operation_mode(struct wl1271 *wl, u8 hlid, bool wide);
+int wl18xx_acx_set_peer_cap(struct wl1271 *wl,
+			    struct ieee80211_sta_ht_cap *ht_cap,
+			    bool allow_ht_operation,
+			    u32 rate_set, u8 hlid);
 
 #endif /* __WL18XX_ACX_H__ */

commit 5f9b67770be4201f4449b0f180effecaac4e2686
Author: Arik Nemtsov <arik@wizery.com>
Date:   Mon Nov 26 18:05:41 2012 +0200

    wlcore: use new set bandwidth command to adjusting channel BW
    
    We support changing the channel BW when we started the STA role on
    a 40Mhz bandwidth. Otherwise a reconnection is required.
    Save the started channel width and use it when channel width updates
    arrive.
    
    Signed-off-by: Arik Nemtsov <arik@wizery.com>
    Signed-off-by: Luciano Coelho <coelho@ti.com>

diff --git a/drivers/net/wireless/ti/wl18xx/acx.h b/drivers/net/wireless/ti/wl18xx/acx.h
index 394d12500834..b57e3483509d 100644
--- a/drivers/net/wireless/ti/wl18xx/acx.h
+++ b/drivers/net/wireless/ti/wl18xx/acx.h
@@ -284,10 +284,24 @@ struct wl18xx_acx_clear_statistics {
 	struct acx_header header;
 };
 
+enum wlcore_bandwidth {
+	WLCORE_BANDWIDTH_20MHZ,
+	WLCORE_BANDWIDTH_40MHZ,
+};
+
+struct wlcore_peer_ht_operation_mode {
+	struct acx_header header;
+
+	u8 hlid;
+	u8 bandwidth; /* enum wlcore_bandwidth */
+	u8 padding[2];
+};
+
 int wl18xx_acx_host_if_cfg_bitmap(struct wl1271 *wl, u32 host_cfg_bitmap,
 				  u32 sdio_blk_size, u32 extra_mem_blks,
 				  u32 len_field_size);
 int wl18xx_acx_set_checksum_state(struct wl1271 *wl);
 int wl18xx_acx_clear_statistics(struct wl1271 *wl);
+int wl18xx_acx_peer_ht_operation_mode(struct wl1271 *wl, u8 hlid, bool wide);
 
 #endif /* __WL18XX_ACX_H__ */

commit b6acb4e00e187cb5ae8dd479958a02fe0ea97bf0
Author: Eliad Peller <eliad@wizery.com>
Date:   Thu Nov 22 18:06:17 2012 +0200

    wlcore: update acx enum
    
    update the acx enum to the new fw api.
    
    Signed-off-by: Eliad Peller <eliad@wizery.com>
    Signed-off-by: Luciano Coelho <coelho@ti.com>

diff --git a/drivers/net/wireless/ti/wl18xx/acx.h b/drivers/net/wireless/ti/wl18xx/acx.h
index e2609a6b7341..394d12500834 100644
--- a/drivers/net/wireless/ti/wl18xx/acx.h
+++ b/drivers/net/wireless/ti/wl18xx/acx.h
@@ -26,7 +26,13 @@
 #include "../wlcore/acx.h"
 
 enum {
-	ACX_CLEAR_STATISTICS		 = 0x0047,
+	ACX_NS_IPV6_FILTER		 = 0x0050,
+	ACX_PEER_HT_OPERATION_MODE_CFG	 = 0x0051,
+	ACX_CSUM_CONFIG			 = 0x0052,
+	ACX_SIM_CONFIG			 = 0x0053,
+	ACX_CLEAR_STATISTICS		 = 0x0054,
+	ACX_AUTO_RX_STREAMING		 = 0x0055,
+	ACX_PEER_CAP			 = 0x0056
 };
 
 /* numbers of bits the length field takes (add 1 for the actual number) */

commit e59bec1628654b6dcbad4e64d43c41c1f31d216c
Author: Luciano Coelho <coelho@ti.com>
Date:   Mon Jun 25 14:15:55 2012 +0300

    wl18xx: deprecate PG1 support
    
    The new PG2 version of the chip has a few differences in terms of FW
    API if compared to PG1.  PG1 is just a sample that shouldn't be used
    in real life, so to avoid having to handle both separately, mark the
    PG1 version as deprecated and bail out during probe.
    
    Signed-off-by: Luciano Coelho <coelho@ti.com>

diff --git a/drivers/net/wireless/ti/wl18xx/acx.h b/drivers/net/wireless/ti/wl18xx/acx.h
index ebbaf611e97b..e2609a6b7341 100644
--- a/drivers/net/wireless/ti/wl18xx/acx.h
+++ b/drivers/net/wireless/ti/wl18xx/acx.h
@@ -32,25 +32,21 @@ enum {
 /* numbers of bits the length field takes (add 1 for the actual number) */
 #define WL18XX_HOST_IF_LEN_SIZE_FIELD 15
 
-#define WL18XX_ACX_EVENTS_VECTOR_PG1	(WL1271_ACX_INTR_WATCHDOG      | \
-					WL1271_ACX_INTR_INIT_COMPLETE | \
-					WL1271_ACX_INTR_EVENT_A       | \
-					WL1271_ACX_INTR_EVENT_B       | \
-					WL1271_ACX_INTR_CMD_COMPLETE  | \
-					WL1271_ACX_INTR_HW_AVAILABLE  | \
-					WL1271_ACX_INTR_DATA)
-
-#define WL18XX_ACX_EVENTS_VECTOR_PG2	(WL18XX_ACX_EVENTS_VECTOR_PG1 | \
-					WL1271_ACX_SW_INTR_WATCHDOG)
-
-#define WL18XX_INTR_MASK_PG1		(WL1271_ACX_INTR_WATCHDOG      | \
-					WL1271_ACX_INTR_EVENT_A       | \
-					WL1271_ACX_INTR_EVENT_B       | \
-					WL1271_ACX_INTR_HW_AVAILABLE  | \
-					WL1271_ACX_INTR_DATA)
-
-#define WL18XX_INTR_MASK_PG2		(WL18XX_INTR_MASK_PG1         | \
-					WL1271_ACX_SW_INTR_WATCHDOG)
+#define WL18XX_ACX_EVENTS_VECTOR	(WL1271_ACX_INTR_WATCHDOG	| \
+					 WL1271_ACX_INTR_INIT_COMPLETE	| \
+					 WL1271_ACX_INTR_EVENT_A	| \
+					 WL1271_ACX_INTR_EVENT_B	| \
+					 WL1271_ACX_INTR_CMD_COMPLETE	| \
+					 WL1271_ACX_INTR_HW_AVAILABLE	| \
+					 WL1271_ACX_INTR_DATA		| \
+					 WL1271_ACX_SW_INTR_WATCHDOG)
+
+#define WL18XX_INTR_MASK		(WL1271_ACX_INTR_WATCHDOG	| \
+					 WL1271_ACX_INTR_EVENT_A	| \
+					 WL1271_ACX_INTR_EVENT_B	| \
+					 WL1271_ACX_INTR_HW_AVAILABLE	| \
+					 WL1271_ACX_INTR_DATA		| \
+					 WL1271_ACX_SW_INTR_WATCHDOG)
 
 struct wl18xx_acx_host_config_bitmap {
 	struct acx_header header;

commit 8dd8e53c6f0a5116b988445484b1d68d8e22ced9
Author: Ido Reis <idor@ti.com>
Date:   Tue May 22 12:34:10 2012 +0300

    wl18xx: update fw statistics
    
    Aligned to the struct in FW 8.2.0.0.91 and updated the debugfs entries
    accordingly.
    
    Signed-off-by: Ido Reis <idor@ti.com>
    Signed-off-by: Luciano Coelho <coelho@ti.com>

diff --git a/drivers/net/wireless/ti/wl18xx/acx.h b/drivers/net/wireless/ti/wl18xx/acx.h
index 3e5cd9fddcf1..ebbaf611e97b 100644
--- a/drivers/net/wireless/ti/wl18xx/acx.h
+++ b/drivers/net/wireless/ti/wl18xx/acx.h
@@ -85,6 +85,15 @@ struct wl18xx_acx_checksum_state {
 	u8 pad[3];
 } __packed;
 
+
+struct wl18xx_acx_error_stats {
+	u32 error_frame;
+	u32 error_null_Frame_tx_start;
+	u32 error_numll_frame_cts_start;
+	u32 error_bar_retry;
+	u32 error_frame_cts_nul_flid;
+} __packed;
+
 struct wl18xx_acx_debug_stats {
 	u32 debug1;
 	u32 debug2;
@@ -100,6 +109,8 @@ struct wl18xx_acx_ring_stats {
 } __packed;
 
 struct wl18xx_acx_tx_stats {
+	u32 tx_prepared_descs;
+	u32 tx_cmplt;
 	u32 tx_template_prepared;
 	u32 tx_data_prepared;
 	u32 tx_template_programmed;
@@ -136,7 +147,8 @@ struct wl18xx_acx_tx_stats {
 } __packed;
 
 struct wl18xx_acx_rx_stats {
-	u32 rx_out_of_mem;
+	u32 rx_beacon_early_term;
+	u32 rx_out_of_mpdu_nodes;
 	u32 rx_hdr_overflow;
 	u32 rx_dropped_frame;
 	u32 rx_done_stage;
@@ -148,6 +160,9 @@ struct wl18xx_acx_rx_stats {
 	u32 rx_cmplt_task;
 	u32 rx_phy_hdr;
 	u32 rx_timeout;
+	u32 rx_timeout_wa;
+	u32 rx_wa_density_dropped_frame;
+	u32 rx_wa_ba_not_expected;
 	u32 rx_frame_checksum;
 	u32 rx_checksum_result;
 	u32 defrag_called;
@@ -158,6 +173,7 @@ struct wl18xx_acx_rx_stats {
 	u32 defrag_decrypt_failed;
 	u32 decrypt_key_not_found;
 	u32 defrag_need_decrypt;
+	u32 rx_tkip_replays;
 } __packed;
 
 struct wl18xx_acx_isr_stats {
@@ -197,20 +213,25 @@ struct wl18xx_acx_rx_filter_stats {
 	u32 data_filter;
 	u32 ibss_filter;
 	u32 protection_filter;
+	u32 accum_arp_pend_requests;
+	u32 max_arp_queue_dep;
 } __packed;
 
 struct wl18xx_acx_rx_rate_stats {
 	u32 rx_frames_per_rates[50];
 } __packed;
 
-#define AGGR_STATS_TX_SIZE_LEN 11
-#define AGGR_STATS_RX_SIZE_LEN 11
+#define AGGR_STATS_TX_AGG	16
+#define AGGR_STATS_TX_RATE	16
+#define AGGR_STATS_RX_SIZE_LEN	16
 
 struct wl18xx_acx_aggr_stats {
-	u32 tx_size[AGGR_STATS_TX_SIZE_LEN];
+	u32 tx_agg_vs_rate[AGGR_STATS_TX_AGG * AGGR_STATS_TX_RATE];
 	u32 rx_size[AGGR_STATS_RX_SIZE_LEN];
 } __packed;
 
+#define PIPE_STATS_HW_FIFO	11
+
 struct wl18xx_acx_pipeline_stats {
 	u32 hs_tx_stat_fifo_int;
 	u32 hs_rx_stat_fifo_int;
@@ -230,6 +251,7 @@ struct wl18xx_acx_pipeline_stats {
 	u32 dec_packet_out;
 	u32 cs_rx_packet_in;
 	u32 cs_rx_packet_out;
+	u16 pipeline_fifo_full[PIPE_STATS_HW_FIFO];
 } __packed;
 
 struct wl18xx_acx_mem_stats {
@@ -242,13 +264,12 @@ struct wl18xx_acx_mem_stats {
 struct wl18xx_acx_statistics {
 	struct acx_header header;
 
-	struct wl18xx_acx_ring_stats		ring;
+	struct wl18xx_acx_error_stats		error;
 	struct wl18xx_acx_debug_stats		debug;
 	struct wl18xx_acx_tx_stats		tx;
 	struct wl18xx_acx_rx_stats		rx;
 	struct wl18xx_acx_isr_stats		isr;
 	struct wl18xx_acx_pwr_stats		pwr;
-	struct wl18xx_acx_event_stats		event;
 	struct wl18xx_acx_ps_poll_stats		ps_poll;
 	struct wl18xx_acx_rx_filter_stats	rx_filter;
 	struct wl18xx_acx_rx_rate_stats		rx_rate;

commit f74ea74b82cf6b6aeef1e46d68fbbb02d2bce8b7
Author: Luciano Coelho <coelho@ti.com>
Date:   Thu Jun 7 23:39:22 2012 +0300

    wl18xx: add support to clear FW statistics
    
    This patch calls ACX_CLEAR_STATISTICS to clear the firmware
    statistics.  The trigger is a new debugfs file called
    clear_fw_statistics in the fw_stats directory.
    
    Signed-off-by: Luciano Coelho <coelho@ti.com>

diff --git a/drivers/net/wireless/ti/wl18xx/acx.h b/drivers/net/wireless/ti/wl18xx/acx.h
index 7d74b031f114..3e5cd9fddcf1 100644
--- a/drivers/net/wireless/ti/wl18xx/acx.h
+++ b/drivers/net/wireless/ti/wl18xx/acx.h
@@ -25,6 +25,10 @@
 #include "../wlcore/wlcore.h"
 #include "../wlcore/acx.h"
 
+enum {
+	ACX_CLEAR_STATISTICS		 = 0x0047,
+};
+
 /* numbers of bits the length field takes (add 1 for the actual number) */
 #define WL18XX_HOST_IF_LEN_SIZE_FIELD 15
 
@@ -253,9 +257,14 @@ struct wl18xx_acx_statistics {
 	struct wl18xx_acx_mem_stats		mem;
 } __packed;
 
+struct wl18xx_acx_clear_statistics {
+	struct acx_header header;
+};
+
 int wl18xx_acx_host_if_cfg_bitmap(struct wl1271 *wl, u32 host_cfg_bitmap,
 				  u32 sdio_blk_size, u32 extra_mem_blks,
 				  u32 len_field_size);
 int wl18xx_acx_set_checksum_state(struct wl1271 *wl);
+int wl18xx_acx_clear_statistics(struct wl1271 *wl);
 
 #endif /* __WL18XX_ACX_H__ */

commit f5755fe96cb010031a50458e6d1391377d94c275
Author: Ido Reis <idor@ti.com>
Date:   Mon Apr 23 17:35:25 2012 +0300

    wl18xx: PG2.0 HW Watch dog interrupt support
    
    In PG2, the HW watchdog interrupt occupies bit0 of the event vector, and
    the SW watchdog is relocated to bit9. We perform the relocation
    globally, as there's only one watchdog bit on previous platforms (bit0).
    
    [Only mask in the new bit9 for platforms supporting it. This avoids
    spurious events on other platforms - Arik]
    
    Signed-off-by: Orit Brayer <orit@ti.com>
    Signed-off-by: Ido Reis <idor@ti.com>
    Signed-off-by: Arik Nemtsov <arik@wizery.com>
    Signed-off-by: Luciano Coelho <coelho@ti.com>

diff --git a/drivers/net/wireless/ti/wl18xx/acx.h b/drivers/net/wireless/ti/wl18xx/acx.h
index cb6fd85d077f..7d74b031f114 100644
--- a/drivers/net/wireless/ti/wl18xx/acx.h
+++ b/drivers/net/wireless/ti/wl18xx/acx.h
@@ -28,6 +28,26 @@
 /* numbers of bits the length field takes (add 1 for the actual number) */
 #define WL18XX_HOST_IF_LEN_SIZE_FIELD 15
 
+#define WL18XX_ACX_EVENTS_VECTOR_PG1	(WL1271_ACX_INTR_WATCHDOG      | \
+					WL1271_ACX_INTR_INIT_COMPLETE | \
+					WL1271_ACX_INTR_EVENT_A       | \
+					WL1271_ACX_INTR_EVENT_B       | \
+					WL1271_ACX_INTR_CMD_COMPLETE  | \
+					WL1271_ACX_INTR_HW_AVAILABLE  | \
+					WL1271_ACX_INTR_DATA)
+
+#define WL18XX_ACX_EVENTS_VECTOR_PG2	(WL18XX_ACX_EVENTS_VECTOR_PG1 | \
+					WL1271_ACX_SW_INTR_WATCHDOG)
+
+#define WL18XX_INTR_MASK_PG1		(WL1271_ACX_INTR_WATCHDOG      | \
+					WL1271_ACX_INTR_EVENT_A       | \
+					WL1271_ACX_INTR_EVENT_B       | \
+					WL1271_ACX_INTR_HW_AVAILABLE  | \
+					WL1271_ACX_INTR_DATA)
+
+#define WL18XX_INTR_MASK_PG2		(WL18XX_INTR_MASK_PG1         | \
+					WL1271_ACX_SW_INTR_WATCHDOG)
+
 struct wl18xx_acx_host_config_bitmap {
 	struct acx_header header;
 

commit c5d94169e8189d02dfbd6143411908357865d777
Author: Luciano Coelho <coelho@ti.com>
Date:   Thu May 10 12:14:22 2012 +0300

    wl18xx: use new fw stats structures
    
    Some of the structures were updated, other structures had a few
    missing values and a few new ones were added.  Change the driver
    structs accordingly.
    
    Signed-off-by: Luciano Coelho <coelho@ti.com>
    Signed-off-by: Arik Nemtsov <arik@wizery.com>

diff --git a/drivers/net/wireless/ti/wl18xx/acx.h b/drivers/net/wireless/ti/wl18xx/acx.h
index c2ccf70bcfb3..cb6fd85d077f 100644
--- a/drivers/net/wireless/ti/wl18xx/acx.h
+++ b/drivers/net/wireless/ti/wl18xx/acx.h
@@ -71,13 +71,8 @@ struct wl18xx_acx_debug_stats {
 } __packed;
 
 struct wl18xx_acx_ring_stats {
-	u32 tx_procs;
 	u32 prepared_descs;
-	u32 tx_xfr;
-	u32 tx_dma;
 	u32 tx_cmplt;
-	u32 rx_procs;
-	u32 rx_data;
 } __packed;
 
 struct wl18xx_acx_tx_stats {
@@ -98,60 +93,53 @@ struct wl18xx_acx_tx_stats {
 	u32 tx_retry_data;
 	u32 tx_exch_pending;
 	u32 tx_exch_expiry;
-	u32 tx_exch_mismatch;
 	u32 tx_done_template;
 	u32 tx_done_data;
 	u32 tx_done_int_template;
-	u32 tx_pre_xfr;
-	u32 tx_xfr;
-	u32 tx_xfr_out_of_mem;
-	u32 tx_dma_programmed;
-	u32 tx_dma_done;
+	u32 tx_frame_checksum;
+	u32 tx_checksum_result;
+	u32 frag_called;
+	u32 frag_mpdu_alloc_failed;
+	u32 frag_init_called;
+	u32 frag_in_process_called;
+	u32 frag_tkip_called;
+	u32 frag_key_not_found;
+	u32 frag_need_fragmentation;
+	u32 frag_bad_mblk_num;
+	u32 frag_failed;
+	u32 frag_cache_hit;
+	u32 frag_cache_miss;
 } __packed;
 
 struct wl18xx_acx_rx_stats {
 	u32 rx_out_of_mem;
 	u32 rx_hdr_overflow;
-	u32 rx_hw_stuck;
 	u32 rx_dropped_frame;
-	u32 rx_complete_dropped_frame;
-	u32 rx_alloc_frame;
-	u32 rx_done_queue;
+	u32 rx_done_stage;
 	u32 rx_done;
 	u32 rx_defrag;
 	u32 rx_defrag_end;
-	u32 rx_mic;
-	u32 rx_mic_end;
-	u32 rx_xfr;
-	u32 rx_xfr_end;
 	u32 rx_cmplt;
 	u32 rx_pre_complt;
 	u32 rx_cmplt_task;
 	u32 rx_phy_hdr;
 	u32 rx_timeout;
-} __packed;
-
-struct wl18xx_acx_dma_stats {
-	u32 rx_dma_errors;
-	u32 tx_dma_errors;
+	u32 rx_frame_checksum;
+	u32 rx_checksum_result;
+	u32 defrag_called;
+	u32 defrag_init_called;
+	u32 defrag_in_process_called;
+	u32 defrag_tkip_called;
+	u32 defrag_need_defrag;
+	u32 defrag_decrypt_failed;
+	u32 decrypt_key_not_found;
+	u32 defrag_need_decrypt;
 } __packed;
 
 struct wl18xx_acx_isr_stats {
 	u32 irqs;
 } __packed;
 
-struct wl18xx_acx_wep_stats {
-	u32 wep_add_key_count;
-	u32 wep_default_key_count;
-	u32 wep_key_not_found;
-	u32 wep_decrypt_fail;
-	u32 wep_encrypt_fail;
-	u32 wep_dec_packets;
-	u32 wep_dec_interrupt;
-	u32 wep_enc_packets;
-	u32 wep_enc_interrupts;
-} __packed;
-
 #define PWR_STAT_MAX_CONT_MISSED_BCNS_SPREAD 10
 
 struct wl18xx_acx_pwr_stats {
@@ -162,29 +150,6 @@ struct wl18xx_acx_pwr_stats {
 	u32 rcvd_awake_bcns_cnt;
 } __packed;
 
-struct wl18xx_acx_mic_stats {
-	u32 mic_rx_pkts;
-	u32 mic_calc_failure;
-} __packed;
-
-struct wl18xx_acx_aes_stats {
-	u32 aes_encrypt_fail;
-	u32 aes_decrypt_fail;
-	u32 aes_encrypt_packets;
-	u32 aes_decrypt_packets;
-	u32 aes_encrypt_interrupt;
-	u32 aes_decrypt_interrupt;
-} __packed;
-
-struct wl18xx_acx_gem_stats {
-	u32 gem_encrypt_fail;
-	u32 gem_decrypt_fail;
-	u32 gem_encrypt_packets;
-	u32 gem_decrypt_packets;
-	u32 gem_encrypt_interrupt;
-	u32 gem_decrypt_interrupt;
-} __packed;
-
 struct wl18xx_acx_event_stats {
 	u32 calibration;
 	u32 rx_mismatch;
@@ -210,31 +175,44 @@ struct wl18xx_acx_rx_filter_stats {
 	u32 protection_filter;
 } __packed;
 
-struct wl18xx_acx_calibration_stats {
-	u32 init_cal_total;
-	u32 init_radio_bands_fail;
-	u32 init_set_params;
-	u32 init_tx_clpc_fail;
-	u32 init_rx_iw_mm_fail;
-	u32 tune_cal_total;
-	u32 tune_drpw_rtrim_fail;
-	u32 tune_drpw_pd_buf_fail;
-	u32 tune_drpw_tx_mix_freq_fail;
-	u32 tune_drpw_ta_cal;
-	u32 tune_drpw_rx_if_2_gain;
-	u32 tune_drpw_rx_dac;
-	u32 tune_drpw_chan_tune;
-	u32 tune_drpw_rx_tx_lpf;
-	u32 tune_drpw_lna_tank;
-	u32 tune_tx_lo_leak_fail;
-	u32 tune_tx_iq_mm_fail;
-	u32 tune_tx_pdet_fail;
-	u32 tune_tx_ppa_fail;
-	u32 tune_tx_clpc_fail;
-	u32 tune_rx_ana_dc_fail;
-	u32 tune_rx_dig_dc_fail; /* check if this is needed */
-	u32 tune_rx_iq_mm_fail;
-	u32 cal_state_fail;
+struct wl18xx_acx_rx_rate_stats {
+	u32 rx_frames_per_rates[50];
+} __packed;
+
+#define AGGR_STATS_TX_SIZE_LEN 11
+#define AGGR_STATS_RX_SIZE_LEN 11
+
+struct wl18xx_acx_aggr_stats {
+	u32 tx_size[AGGR_STATS_TX_SIZE_LEN];
+	u32 rx_size[AGGR_STATS_RX_SIZE_LEN];
+} __packed;
+
+struct wl18xx_acx_pipeline_stats {
+	u32 hs_tx_stat_fifo_int;
+	u32 hs_rx_stat_fifo_int;
+	u32 tcp_tx_stat_fifo_int;
+	u32 tcp_rx_stat_fifo_int;
+	u32 enc_tx_stat_fifo_int;
+	u32 enc_rx_stat_fifo_int;
+	u32 rx_complete_stat_fifo_int;
+	u32 pre_proc_swi;
+	u32 post_proc_swi;
+	u32 sec_frag_swi;
+	u32 pre_to_defrag_swi;
+	u32 defrag_to_csum_swi;
+	u32 csum_to_rx_xfer_swi;
+	u32 dec_packet_in;
+	u32 dec_packet_in_fifo_full;
+	u32 dec_packet_out;
+	u32 cs_rx_packet_in;
+	u32 cs_rx_packet_out;
+} __packed;
+
+struct wl18xx_acx_mem_stats {
+	u32 rx_free_mem_blks;
+	u32 tx_free_mem_blks;
+	u32 fwlog_free_mem_blks;
+	u32 fw_gen_free_mem_blks;
 } __packed;
 
 struct wl18xx_acx_statistics {
@@ -244,17 +222,15 @@ struct wl18xx_acx_statistics {
 	struct wl18xx_acx_debug_stats		debug;
 	struct wl18xx_acx_tx_stats		tx;
 	struct wl18xx_acx_rx_stats		rx;
-	struct wl18xx_acx_dma_stats		dma;
 	struct wl18xx_acx_isr_stats		isr;
-	struct wl18xx_acx_wep_stats		wep;
 	struct wl18xx_acx_pwr_stats		pwr;
-	struct wl18xx_acx_aes_stats		aes;
-	struct wl18xx_acx_mic_stats		mic;
 	struct wl18xx_acx_event_stats		event;
 	struct wl18xx_acx_ps_poll_stats		ps_poll;
 	struct wl18xx_acx_rx_filter_stats	rx_filter;
-	struct wl18xx_acx_calibration_stats	calibration;
-	struct wl18xx_acx_gem_stats		gem;
+	struct wl18xx_acx_rx_rate_stats		rx_rate;
+	struct wl18xx_acx_aggr_stats		aggr_size;
+	struct wl18xx_acx_pipeline_stats	pipeline;
+	struct wl18xx_acx_mem_stats		mem;
 } __packed;
 
 int wl18xx_acx_host_if_cfg_bitmap(struct wl1271 *wl, u32 host_cfg_bitmap,

commit 8c0ea1021c38cfd2f0ba5d8fdd48a9e9827bbc03
Author: Luciano Coelho <coelho@ti.com>
Date:   Thu May 10 12:14:09 2012 +0300

    wl18xx: implement fw status debugfs entries
    
    Implement the operations that are necessary to fetch the
    wl18xx-specific FW statistics and export them in debugfs.
    
    Signed-off-by: Luciano Coelho <coelho@ti.com>
    Signed-off-by: Arik Nemtsov <arik@wizery.com>

diff --git a/drivers/net/wireless/ti/wl18xx/acx.h b/drivers/net/wireless/ti/wl18xx/acx.h
index 544db6ef3841..c2ccf70bcfb3 100644
--- a/drivers/net/wireless/ti/wl18xx/acx.h
+++ b/drivers/net/wireless/ti/wl18xx/acx.h
@@ -23,6 +23,7 @@
 #define __WL18XX_ACX_H__
 
 #include "../wlcore/wlcore.h"
+#include "../wlcore/acx.h"
 
 /* numbers of bits the length field takes (add 1 for the actual number) */
 #define WL18XX_HOST_IF_LEN_SIZE_FIELD 15
@@ -60,9 +61,205 @@ struct wl18xx_acx_checksum_state {
 	u8 pad[3];
 } __packed;
 
+struct wl18xx_acx_debug_stats {
+	u32 debug1;
+	u32 debug2;
+	u32 debug3;
+	u32 debug4;
+	u32 debug5;
+	u32 debug6;
+} __packed;
+
+struct wl18xx_acx_ring_stats {
+	u32 tx_procs;
+	u32 prepared_descs;
+	u32 tx_xfr;
+	u32 tx_dma;
+	u32 tx_cmplt;
+	u32 rx_procs;
+	u32 rx_data;
+} __packed;
+
+struct wl18xx_acx_tx_stats {
+	u32 tx_template_prepared;
+	u32 tx_data_prepared;
+	u32 tx_template_programmed;
+	u32 tx_data_programmed;
+	u32 tx_burst_programmed;
+	u32 tx_starts;
+	u32 tx_imm_resp;
+	u32 tx_start_templates;
+	u32 tx_start_int_templates;
+	u32 tx_start_fw_gen;
+	u32 tx_start_data;
+	u32 tx_start_null_frame;
+	u32 tx_exch;
+	u32 tx_retry_template;
+	u32 tx_retry_data;
+	u32 tx_exch_pending;
+	u32 tx_exch_expiry;
+	u32 tx_exch_mismatch;
+	u32 tx_done_template;
+	u32 tx_done_data;
+	u32 tx_done_int_template;
+	u32 tx_pre_xfr;
+	u32 tx_xfr;
+	u32 tx_xfr_out_of_mem;
+	u32 tx_dma_programmed;
+	u32 tx_dma_done;
+} __packed;
+
+struct wl18xx_acx_rx_stats {
+	u32 rx_out_of_mem;
+	u32 rx_hdr_overflow;
+	u32 rx_hw_stuck;
+	u32 rx_dropped_frame;
+	u32 rx_complete_dropped_frame;
+	u32 rx_alloc_frame;
+	u32 rx_done_queue;
+	u32 rx_done;
+	u32 rx_defrag;
+	u32 rx_defrag_end;
+	u32 rx_mic;
+	u32 rx_mic_end;
+	u32 rx_xfr;
+	u32 rx_xfr_end;
+	u32 rx_cmplt;
+	u32 rx_pre_complt;
+	u32 rx_cmplt_task;
+	u32 rx_phy_hdr;
+	u32 rx_timeout;
+} __packed;
+
+struct wl18xx_acx_dma_stats {
+	u32 rx_dma_errors;
+	u32 tx_dma_errors;
+} __packed;
+
+struct wl18xx_acx_isr_stats {
+	u32 irqs;
+} __packed;
+
+struct wl18xx_acx_wep_stats {
+	u32 wep_add_key_count;
+	u32 wep_default_key_count;
+	u32 wep_key_not_found;
+	u32 wep_decrypt_fail;
+	u32 wep_encrypt_fail;
+	u32 wep_dec_packets;
+	u32 wep_dec_interrupt;
+	u32 wep_enc_packets;
+	u32 wep_enc_interrupts;
+} __packed;
+
+#define PWR_STAT_MAX_CONT_MISSED_BCNS_SPREAD 10
+
+struct wl18xx_acx_pwr_stats {
+	u32 missing_bcns_cnt;
+	u32 rcvd_bcns_cnt;
+	u32 connection_out_of_sync;
+	u32 cont_miss_bcns_spread[PWR_STAT_MAX_CONT_MISSED_BCNS_SPREAD];
+	u32 rcvd_awake_bcns_cnt;
+} __packed;
+
+struct wl18xx_acx_mic_stats {
+	u32 mic_rx_pkts;
+	u32 mic_calc_failure;
+} __packed;
+
+struct wl18xx_acx_aes_stats {
+	u32 aes_encrypt_fail;
+	u32 aes_decrypt_fail;
+	u32 aes_encrypt_packets;
+	u32 aes_decrypt_packets;
+	u32 aes_encrypt_interrupt;
+	u32 aes_decrypt_interrupt;
+} __packed;
+
+struct wl18xx_acx_gem_stats {
+	u32 gem_encrypt_fail;
+	u32 gem_decrypt_fail;
+	u32 gem_encrypt_packets;
+	u32 gem_decrypt_packets;
+	u32 gem_encrypt_interrupt;
+	u32 gem_decrypt_interrupt;
+} __packed;
+
+struct wl18xx_acx_event_stats {
+	u32 calibration;
+	u32 rx_mismatch;
+	u32 rx_mem_empty;
+} __packed;
+
+struct wl18xx_acx_ps_poll_stats {
+	u32 ps_poll_timeouts;
+	u32 upsd_timeouts;
+	u32 upsd_max_ap_turn;
+	u32 ps_poll_max_ap_turn;
+	u32 ps_poll_utilization;
+	u32 upsd_utilization;
+} __packed;
+
+struct wl18xx_acx_rx_filter_stats {
+	u32 beacon_filter;
+	u32 arp_filter;
+	u32 mc_filter;
+	u32 dup_filter;
+	u32 data_filter;
+	u32 ibss_filter;
+	u32 protection_filter;
+} __packed;
+
+struct wl18xx_acx_calibration_stats {
+	u32 init_cal_total;
+	u32 init_radio_bands_fail;
+	u32 init_set_params;
+	u32 init_tx_clpc_fail;
+	u32 init_rx_iw_mm_fail;
+	u32 tune_cal_total;
+	u32 tune_drpw_rtrim_fail;
+	u32 tune_drpw_pd_buf_fail;
+	u32 tune_drpw_tx_mix_freq_fail;
+	u32 tune_drpw_ta_cal;
+	u32 tune_drpw_rx_if_2_gain;
+	u32 tune_drpw_rx_dac;
+	u32 tune_drpw_chan_tune;
+	u32 tune_drpw_rx_tx_lpf;
+	u32 tune_drpw_lna_tank;
+	u32 tune_tx_lo_leak_fail;
+	u32 tune_tx_iq_mm_fail;
+	u32 tune_tx_pdet_fail;
+	u32 tune_tx_ppa_fail;
+	u32 tune_tx_clpc_fail;
+	u32 tune_rx_ana_dc_fail;
+	u32 tune_rx_dig_dc_fail; /* check if this is needed */
+	u32 tune_rx_iq_mm_fail;
+	u32 cal_state_fail;
+} __packed;
+
+struct wl18xx_acx_statistics {
+	struct acx_header header;
+
+	struct wl18xx_acx_ring_stats		ring;
+	struct wl18xx_acx_debug_stats		debug;
+	struct wl18xx_acx_tx_stats		tx;
+	struct wl18xx_acx_rx_stats		rx;
+	struct wl18xx_acx_dma_stats		dma;
+	struct wl18xx_acx_isr_stats		isr;
+	struct wl18xx_acx_wep_stats		wep;
+	struct wl18xx_acx_pwr_stats		pwr;
+	struct wl18xx_acx_aes_stats		aes;
+	struct wl18xx_acx_mic_stats		mic;
+	struct wl18xx_acx_event_stats		event;
+	struct wl18xx_acx_ps_poll_stats		ps_poll;
+	struct wl18xx_acx_rx_filter_stats	rx_filter;
+	struct wl18xx_acx_calibration_stats	calibration;
+	struct wl18xx_acx_gem_stats		gem;
+} __packed;
+
 int wl18xx_acx_host_if_cfg_bitmap(struct wl1271 *wl, u32 host_cfg_bitmap,
 				  u32 sdio_blk_size, u32 extra_mem_blks,
 				  u32 len_field_size);
 int wl18xx_acx_set_checksum_state(struct wl1271 *wl);
 
-#endif /* __WL12XX_ACX_H__ */
+#endif /* __WL18XX_ACX_H__ */

commit 2fc28de5989e1c40fee4e92e2a8f3bdd47b1b34a
Author: Arik Nemtsov <arik@wizery.com>
Date:   Thu May 10 12:13:27 2012 +0300

    wlcore/wl18xx: add hw op for setting Tx HW checksum
    
    Some chip families are capable of checksumming certain classes of Tx
    packets in HW. Indicate this fact in the netdev features and perform the
    HW checksum by protocol type for the 18xx family.
    
    Fix the location of the skb network header when we move it so we can
    rely on it when setting the checksum.
    
    Signed-off-by: Arik Nemtsov <arik@wizery.com>
    Signed-off-by: Luciano Coelho <coelho@ti.com>

diff --git a/drivers/net/wireless/ti/wl18xx/acx.h b/drivers/net/wireless/ti/wl18xx/acx.h
index c8eebd8500c1..544db6ef3841 100644
--- a/drivers/net/wireless/ti/wl18xx/acx.h
+++ b/drivers/net/wireless/ti/wl18xx/acx.h
@@ -45,8 +45,24 @@ struct wl18xx_acx_host_config_bitmap {
 
 } __packed;
 
+enum {
+	CHECKSUM_OFFLOAD_DISABLED = 0,
+	CHECKSUM_OFFLOAD_ENABLED  = 1,
+	CHECKSUM_OFFLOAD_FAKE_RX  = 2,
+	CHECKSUM_OFFLOAD_INVALID  = 0xFF
+};
+
+struct wl18xx_acx_checksum_state {
+	struct acx_header header;
+
+	 /* enum acx_checksum_state */
+	u8 checksum_state;
+	u8 pad[3];
+} __packed;
+
 int wl18xx_acx_host_if_cfg_bitmap(struct wl1271 *wl, u32 host_cfg_bitmap,
 				  u32 sdio_blk_size, u32 extra_mem_blks,
 				  u32 len_field_size);
+int wl18xx_acx_set_checksum_state(struct wl1271 *wl);
 
 #endif /* __WL12XX_ACX_H__ */

commit b8422dcb865befc5d2d7c21e8427eedf32558fea
Author: Luciano Coelho <coelho@ti.com>
Date:   Thu May 10 12:13:26 2012 +0300

    wl18xx: add hw_init operation
    
    Add wl18xx-specific HW initialization operation and create acx.[ch]
    files to support that.
    
    Signed-off-by: Luciano Coelho <coelho@ti.com>
    Signed-off-by: Arik Nemtsov <arik@wizery.com>

diff --git a/drivers/net/wireless/ti/wl18xx/acx.h b/drivers/net/wireless/ti/wl18xx/acx.h
new file mode 100644
index 000000000000..c8eebd8500c1
--- /dev/null
+++ b/drivers/net/wireless/ti/wl18xx/acx.h
@@ -0,0 +1,52 @@
+/*
+ * This file is part of wl18xx
+ *
+ * Copyright (C) 2011 Texas Instruments. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef __WL18XX_ACX_H__
+#define __WL18XX_ACX_H__
+
+#include "../wlcore/wlcore.h"
+
+/* numbers of bits the length field takes (add 1 for the actual number) */
+#define WL18XX_HOST_IF_LEN_SIZE_FIELD 15
+
+struct wl18xx_acx_host_config_bitmap {
+	struct acx_header header;
+
+	__le32 host_cfg_bitmap;
+
+	__le32 host_sdio_block_size;
+
+	/* extra mem blocks per frame in TX. */
+	__le32 extra_mem_blocks;
+
+	/*
+	 * number of bits of the length field in the first TX word
+	 * (up to 15 - for using the entire 16 bits).
+	 */
+	__le32 length_field_size;
+
+} __packed;
+
+int wl18xx_acx_host_if_cfg_bitmap(struct wl1271 *wl, u32 host_cfg_bitmap,
+				  u32 sdio_blk_size, u32 extra_mem_blks,
+				  u32 len_field_size);
+
+#endif /* __WL12XX_ACX_H__ */
