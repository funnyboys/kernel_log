commit 46d55fcec1637c58b39b6e1b4907906808bb7c32
Author: Sergey Matyukevich <sergey.matyukevich.os@quantenna.com>
Date:   Wed Nov 13 11:06:55 2019 +0000

    qtnfmac: send EAPOL frames via control path
    
    Send EAPOL frames via control path so they can be treated in a different
    way rather than normal data frames. In this case EAPOLs are sent with
    higher priority and with disabled aggregation and encryption. Besides,
    all devices benefit from sending EAPOL frames via high priority path,
    so move the functionality from chip specific to common code.
    
    Signed-off-by: Igor Mitsyanko <igor.mitsyanko.os@quantenna.com>
    Signed-off-by: Sergey Matyukevich <sergey.matyukevich.os@quantenna.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h b/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h
index 8bc4300518d0..2a6a928e13bd 100644
--- a/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h
+++ b/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h
@@ -63,7 +63,6 @@ struct qtnf_pcie_bus_priv {
 	u32 tx_done_count;
 	u32 tx_reclaim_done;
 	u32 tx_reclaim_req;
-	u32 tx_eapol;
 
 	u8 msi_enabled;
 	u8 tx_stopped;

commit 97aef03cb71b49e651ea286beea2ec75cae86d8b
Author: Sergey Matyukevich <sergey.matyukevich.os@quantenna.com>
Date:   Wed Nov 13 11:06:53 2019 +0000

    qtnfmac: modify Rx descriptors queue setup
    
    Rx descriptors queue length is hardware specific. Current common default
    value is no more than an accident. So move Rx descriptor queue setup to
    platform PCIe backend in the same way as it is already done for Tx.
    
    Signed-off-by: Sergey Matyukevich <sergey.matyukevich.os@quantenna.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h b/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h
index 5e8b9cb68419..8bc4300518d0 100644
--- a/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h
+++ b/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h
@@ -23,7 +23,8 @@
 struct qtnf_pcie_bus_priv {
 	struct pci_dev *pdev;
 
-	int (*probe_cb)(struct qtnf_bus *bus, unsigned int tx_bd_size);
+	int (*probe_cb)(struct qtnf_bus *bus, unsigned int tx_bd_size,
+			unsigned int rx_bd_size);
 	void (*remove_cb)(struct qtnf_bus *bus);
 	int (*suspend_cb)(struct qtnf_bus *bus);
 	int (*resume_cb)(struct qtnf_bus *bus);

commit bc70732f9bd98a451cdbddf57a183543df618367
Author: Igor Mitsyanko <igor.mitsyanko.os@quantenna.com>
Date:   Wed Mar 20 10:04:09 2019 +0000

    qtnfmac: send EAPOL frames via control path
    
    Use control path to send EAPOL frames to make sure they are
    sent with higher priority with aggregation disabled.
    
    Signed-off-by: Igor Mitsyanko <igor.mitsyanko.os@quantenna.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h b/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h
index b21de4f52a9d..5e8b9cb68419 100644
--- a/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h
+++ b/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h
@@ -62,6 +62,7 @@ struct qtnf_pcie_bus_priv {
 	u32 tx_done_count;
 	u32 tx_reclaim_done;
 	u32 tx_reclaim_req;
+	u32 tx_eapol;
 
 	u8 msi_enabled;
 	u8 tx_stopped;

commit ae1946be26bc602dae3e6637df80a78fba5ff58b
Author: Sergey Matyukevich <sergey.matyukevich.os@quantenna.com>
Date:   Wed Mar 20 10:04:02 2019 +0000

    qtnfmac: fix core attach error path in pcie backend
    
    Report that firmware is up and running only for successful firmware
    download. Simplify qtnf_pcie_fw_boot_done: modify error path so that
    no need to pass firmware dowload result to this function. Finally,
    do not create debugfs entries if firmware download succeeded,
    but core attach failed.
    
    Signed-off-by: Sergey Matyukevich <sergey.matyukevich.os@quantenna.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h b/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h
index bbc074e1f34d..b21de4f52a9d 100644
--- a/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h
+++ b/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h
@@ -70,7 +70,7 @@ struct qtnf_pcie_bus_priv {
 
 int qtnf_pcie_control_tx(struct qtnf_bus *bus, struct sk_buff *skb);
 int qtnf_pcie_alloc_skb_array(struct qtnf_pcie_bus_priv *priv);
-void qtnf_pcie_fw_boot_done(struct qtnf_bus *bus, bool boot_success);
+int qtnf_pcie_fw_boot_done(struct qtnf_bus *bus);
 void qtnf_pcie_init_shm_ipc(struct qtnf_pcie_bus_priv *priv,
 			    struct qtnf_shm_ipc_region __iomem *ipc_tx_reg,
 			    struct qtnf_shm_ipc_region __iomem *ipc_rx_reg,

commit e401fa25cfa23df8b17960a656ff11f49facae84
Author: Sergey Matyukevich <sergey.matyukevich.os@quantenna.com>
Date:   Tue Oct 16 10:23:58 2018 +0000

    qtnfmac: add support for Topaz chipsets
    
    This patch adds support for QSR1000/QSR2000 family of chipsets
    to qtnfmac_pcie platform driver.
    
    QSR1000/QSR2000 (aka Topaz) is a family of 80MHz, 11ac Wave2,
    4x4/2x4/2x2 chips, including single and dual band devices.
    Depending on specific chip model and firmware in use, either
    STA or both STA and AP modes are supported.
    
    Patch adds Topaz support to qtnfmac_pcie driver. Proper platform
    bus will be selected on probing based on chip ID.
    
    Signed-off-by: Igor Mitsyanko <igor.mitsyanko.os@quantenna.com>
    Signed-off-by: Sergey Matyukevich <sergey.matyukevich.os@quantenna.com>
    Signed-off-by: Andrey Shevchenko <ashevchenko@quantenna.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h b/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h
index 7c742c56efaf..bbc074e1f34d 100644
--- a/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h
+++ b/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h
@@ -76,6 +76,7 @@ void qtnf_pcie_init_shm_ipc(struct qtnf_pcie_bus_priv *priv,
 			    struct qtnf_shm_ipc_region __iomem *ipc_rx_reg,
 			    const struct qtnf_shm_ipc_int *ipc_int);
 struct qtnf_bus *qtnf_pcie_pearl_alloc(struct pci_dev *pdev);
+struct qtnf_bus *qtnf_pcie_topaz_alloc(struct pci_dev *pdev);
 
 static inline void qtnf_non_posted_write(u32 val, void __iomem *basereg)
 {

commit b7da53cd6cd13a782bb08e59b4a3358ec800f724
Author: Igor Mitsyanko <igor.mitsyanko.os@quantenna.com>
Date:   Tue Oct 16 10:23:56 2018 +0000

    qtnfmac_pcie: use single PCIe driver for all platforms
    
    Single PCIe driver can identify hardware type by reading CHIP ID at
    probe time and invoking a correct initialization sequence.
    
    Signed-off-by: Igor Mitsyanko <igor.mitsyanko.os@quantenna.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h b/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h
index 5c70fb4c0f92..7c742c56efaf 100644
--- a/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h
+++ b/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h
@@ -23,9 +23,14 @@
 struct qtnf_pcie_bus_priv {
 	struct pci_dev *pdev;
 
+	int (*probe_cb)(struct qtnf_bus *bus, unsigned int tx_bd_size);
+	void (*remove_cb)(struct qtnf_bus *bus);
+	int (*suspend_cb)(struct qtnf_bus *bus);
+	int (*resume_cb)(struct qtnf_bus *bus);
+	u64 (*dma_mask_get_cb)(void);
+
 	spinlock_t tx_reclaim_lock;
 	spinlock_t tx_lock;
-	int mps;
 
 	struct workqueue_struct *workqueue;
 	struct tasklet_struct reclaim_tq;
@@ -43,6 +48,8 @@ struct qtnf_pcie_bus_priv {
 	struct sk_buff **tx_skb;
 	struct sk_buff **rx_skb;
 
+	unsigned int fw_blksize;
+
 	u32 rx_bd_w_index;
 	u32 rx_bd_r_index;
 
@@ -58,21 +65,17 @@ struct qtnf_pcie_bus_priv {
 
 	u8 msi_enabled;
 	u8 tx_stopped;
+	bool flashboot;
 };
 
 int qtnf_pcie_control_tx(struct qtnf_bus *bus, struct sk_buff *skb);
 int qtnf_pcie_alloc_skb_array(struct qtnf_pcie_bus_priv *priv);
-void qtnf_pcie_bringup_fw_async(struct qtnf_bus *bus);
-void qtnf_pcie_fw_boot_done(struct qtnf_bus *bus, bool boot_success,
-			    const char *drv_name);
+void qtnf_pcie_fw_boot_done(struct qtnf_bus *bus, bool boot_success);
 void qtnf_pcie_init_shm_ipc(struct qtnf_pcie_bus_priv *priv,
 			    struct qtnf_shm_ipc_region __iomem *ipc_tx_reg,
 			    struct qtnf_shm_ipc_region __iomem *ipc_rx_reg,
 			    const struct qtnf_shm_ipc_int *ipc_int);
-int qtnf_pcie_probe(struct pci_dev *pdev, size_t priv_size,
-		    const struct qtnf_bus_ops *bus_ops, u64 dma_mask,
-		    bool use_msi);
-void qtnf_pcie_remove(struct qtnf_bus *bus, struct qtnf_pcie_bus_priv *priv);
+struct qtnf_bus *qtnf_pcie_pearl_alloc(struct pci_dev *pdev);
 
 static inline void qtnf_non_posted_write(u32 val, void __iomem *basereg)
 {

commit addc7540708f52959c99ed3b9758a09070c102dc
Author: Igor Mitsyanko <igor.mitsyanko.os@quantenna.com>
Date:   Mon Sep 24 15:15:12 2018 -0700

    qtnfmac_pcie: extract platform-independent PCIe code
    
    Extract platform-independent PCIe driver code into a separate file, and
    use it from platform-specific modules.
    
    Signed-off-by: Igor Mitsyanko <igor.mitsyanko.os@quantenna.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h b/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h
index 8da9612eeed3..5c70fb4c0f92 100644
--- a/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h
+++ b/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h
@@ -12,6 +12,7 @@
 #include <linux/interrupt.h>
 
 #include "shm_ipc.h"
+#include "bus.h"
 
 #define SKB_BUF_SIZE		2048
 
@@ -59,6 +60,20 @@ struct qtnf_pcie_bus_priv {
 	u8 tx_stopped;
 };
 
+int qtnf_pcie_control_tx(struct qtnf_bus *bus, struct sk_buff *skb);
+int qtnf_pcie_alloc_skb_array(struct qtnf_pcie_bus_priv *priv);
+void qtnf_pcie_bringup_fw_async(struct qtnf_bus *bus);
+void qtnf_pcie_fw_boot_done(struct qtnf_bus *bus, bool boot_success,
+			    const char *drv_name);
+void qtnf_pcie_init_shm_ipc(struct qtnf_pcie_bus_priv *priv,
+			    struct qtnf_shm_ipc_region __iomem *ipc_tx_reg,
+			    struct qtnf_shm_ipc_region __iomem *ipc_rx_reg,
+			    const struct qtnf_shm_ipc_int *ipc_int);
+int qtnf_pcie_probe(struct pci_dev *pdev, size_t priv_size,
+		    const struct qtnf_bus_ops *bus_ops, u64 dma_mask,
+		    bool use_msi);
+void qtnf_pcie_remove(struct qtnf_bus *bus, struct qtnf_pcie_bus_priv *priv);
+
 static inline void qtnf_non_posted_write(u32 val, void __iomem *basereg)
 {
 	writel(val, basereg);

commit c9ff6c9157c2e6d68aafd50078520519bf99ea94
Author: Igor Mitsyanko <igor.mitsyanko.os@quantenna.com>
Date:   Mon Sep 24 15:15:09 2018 -0700

    qtnfmac_pcie: separate platform-independent PCIe structure
    
    Move platform-independent PCIe data structure to a separate header file
    so it can be reused by different devices.
    
    Signed-off-by: Igor Mitsyanko <igor.mitsyanko.os@quantenna.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h b/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h
new file mode 100644
index 000000000000..8da9612eeed3
--- /dev/null
+++ b/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie_priv.h
@@ -0,0 +1,70 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/* Copyright (c) 2018 Quantenna Communications, Inc. All rights reserved. */
+
+#ifndef _QTN_FMAC_PCIE_H_
+#define _QTN_FMAC_PCIE_H_
+
+#include <linux/pci.h>
+#include <linux/spinlock.h>
+#include <linux/io.h>
+#include <linux/skbuff.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+
+#include "shm_ipc.h"
+
+#define SKB_BUF_SIZE		2048
+
+#define QTN_FW_DL_TIMEOUT_MS	3000
+#define QTN_FW_QLINK_TIMEOUT_MS	30000
+#define QTN_EP_RESET_WAIT_MS	1000
+
+struct qtnf_pcie_bus_priv {
+	struct pci_dev *pdev;
+
+	spinlock_t tx_reclaim_lock;
+	spinlock_t tx_lock;
+	int mps;
+
+	struct workqueue_struct *workqueue;
+	struct tasklet_struct reclaim_tq;
+
+	void __iomem *sysctl_bar;
+	void __iomem *epmem_bar;
+	void __iomem *dmareg_bar;
+
+	struct qtnf_shm_ipc shm_ipc_ep_in;
+	struct qtnf_shm_ipc shm_ipc_ep_out;
+
+	u16 tx_bd_num;
+	u16 rx_bd_num;
+
+	struct sk_buff **tx_skb;
+	struct sk_buff **rx_skb;
+
+	u32 rx_bd_w_index;
+	u32 rx_bd_r_index;
+
+	u32 tx_bd_w_index;
+	u32 tx_bd_r_index;
+
+	/* diagnostics stats */
+	u32 pcie_irq_count;
+	u32 tx_full_count;
+	u32 tx_done_count;
+	u32 tx_reclaim_done;
+	u32 tx_reclaim_req;
+
+	u8 msi_enabled;
+	u8 tx_stopped;
+};
+
+static inline void qtnf_non_posted_write(u32 val, void __iomem *basereg)
+{
+	writel(val, basereg);
+
+	/* flush posted write */
+	readl(basereg);
+}
+
+#endif /* _QTN_FMAC_PCIE_H_ */
